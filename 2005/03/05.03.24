00:00:40 <boegel> @seen samc
00:00:40 <lambdabot> I haven't seen samc
00:01:00 <boegel> does anyone know who he is ? and does someone have his e-mail adress ?
00:01:22 <adiabatic> SamC or SamB?
00:01:33 <boegel> samc
00:08:11 <boegel> hey Itkovian
00:11:31 <Itkovian> bogel.
00:11:34 <Itkovian> boegel
00:54:40 <boegel> nobody has samc his e-mail ?
01:31:30 * Lunar^ ask if anyone would be interested in starting an "Offer SPJ a Mozilla Thunderbird" campaign...
01:36:15 <musasabi> morning
01:36:34 <musasabi> Lunar^: what is he using?
01:37:05 <musasabi> and most likely things like that are mandated in the workplace.
01:38:03 <Lunar^> musasabi: spj breaks threads whereas simonmar doesn't
01:39:49 <Lunar^> musasabi: so I don't know if it's really mandated
01:40:48 <musasabi> breaking threads is not nice(tm).
01:46:23 <kosmikus> musasabi: there's nothing mandated at msr, but using certain tools might make other things easier ...
01:46:48 <musasabi> kosmikus: ok, sounds like a very nice place then :-)
01:48:16 <kosmikus> it is
01:53:18 <nlv11757_> is there something in lhs2tex so a_1 actually puts 1 in subscript?
01:54:24 <kosmikus> %format a_1
01:54:36 <kosmikus> that works with 10pre
01:55:14 <kosmikus> in 1.9, you can only say %format a1
01:55:36 <kosmikus> or you have to spell out the directive %format a_1 = a "_{" 1 "}"
01:55:53 <nlv11757_> so saying %format a1 does a_1
01:55:56 <nlv11757_> without spelling it out?
01:56:03 <kosmikus> yes
01:56:11 <kosmikus> you're using 1.9 then?
01:56:11 <nlv11757_> ow nice default behaviour
01:56:14 <nlv11757_> yeah
01:56:54 <nlv11757_> from which latex package does \llbracket comes?
01:57:11 <kosmikus> there's a section called "Implicit formatting" in the lhs2TeX documentation
01:57:14 <kosmikus> that explains it
01:57:25 <kosmikus> \llbracket should be stmaryrd
01:58:33 <nlv11757_> :/ I get " Stack space overflow: current size 1048576 bytes.
01:58:33 <nlv11757_> Use `+RTS -Ksize' to increase it."
01:58:41 <nlv11757_> after doing %format a1
01:58:49 <nlv11757_> probably im using it wrong
01:59:03 <kosmikus> you have a %format a somwhere as well?
01:59:33 <nlv11757_> ow crap i thought %format an was also necessary
01:59:36 <nlv11757_> my bad
01:59:42 <nlv11757_> to get a_n i mean
01:59:51 <musasabi> Has anyone done a greek alphabet patch for haddock?
02:00:06 <kosmikus> ah, this won't work with 1.9
02:00:14 <kosmikus> you cannot get a_n implicitly
02:00:18 <kosmikus> you have to upgrade then :)
02:00:28 <nlv11757_> ok, is 10pre prett stable?
02:00:32 <nlv11757_> pretty
02:00:33 <kosmikus> yes
02:00:40 * musasabi would like to have 'a -> alpha', and 't -> tau'.
02:00:45 <nlv11757_> does it break a lot of 1.9 code?
02:01:03 <kosmikus> musasabi: you can always have these things, but explicitly
02:01:11 <kosmikus> musasabi: %format a = "\alpha"
02:01:30 <kosmikus> nlv11757_: it shouldn't break any, actually, although I'm not completely sure
02:01:33 <musasabi> kosmikus: for haddock, I don't do literate source files ;)
02:01:54 <kosmikus> musasabi: ah, ok
02:02:28 <kosmikus> it's on my todo list for lhs2TeX to make it work on non-literate source files, and to have it interpret haddock directives in some sensible way
02:03:14 <musasabi> kosmikus: that sounds very nice :-)
02:04:37 <kosmikus> I'm still undecided whether it's easier to hack lhs2TeX to do that or to hack haddock to produce suitable output to run through current lhs2TeX afterwards
02:04:45 <nlv11757_> in my experience, todo lists are waaaaay too long :)
02:05:02 <kosmikus> sure, being on the todo list doesn't mean it ever gets done
02:05:06 <nlv11757_> :D
02:05:07 <kosmikus> ;)
02:05:31 <nlv11757_> i wonder if there exist todo lists that are actually cleared
02:05:38 <nlv11757_> is something ever finished
02:06:00 <kosmikus> TeX the program?
02:06:32 <nlv11757_> TeX is final forever?
02:07:21 <a5> okasaki describes a lazy functional list data structure with constant-time appends, is it possible to configure a program to use a custom data structure like this in place of normal lists, i.e. whenever [] is written?
02:07:44 <musasabi> a5: not really.
02:07:59 <kosmikus> nlv11757_: not necessarily; if some major bug occurs, it will probably get fixed, but apart from that, Knuth has announced that he won't work on it anymore
02:08:11 <musasabi> a5: your real problem is pattern matching.
02:08:38 <kosmikus> I'm not sure, it might work with ghc's rebindable syntax extension
02:08:42 <musasabi> a5: because you have code like case a of (x:xs) -> ... ; [] -> ...
02:09:04 <musasabi> and in this context you are defining the syntax quite hard.
02:09:28 <kosmikus> but yeah, I think you'd need at least views as a Haskell extension in addition
02:09:45 <kosmikus> I keep wanting views over and over again during these last few months
02:10:13 <musasabi> being able to rewrite (x:xs) as a pattern guard would be enough - but you would need views to do that.
02:15:26 <kosmikus> pattern guards are still less convenient than views, but you wouldn't need views to do that, because you could write "(x:xs) <- myview ys", where myview :: SuperCoolOkasakiLazyList a -> [a]
02:23:22 <a5> views?
02:24:12 <kosmikus> a5: http://www.haskell.org/development/views.html, for example
02:26:29 <nlv11757_> where can i see what stuff is already predefined in lhs2tex
02:26:33 <nlv11757_> the .sty?
02:26:49 <nlv11757_> so what formats are predefined
02:27:07 <a5> am i wrong in thinking that constant-time append is important?
02:27:26 <nlv11757_> is appending so costly then?
02:27:32 <nlv11757_> i thought (:) was pretty efficient
02:29:08 <nlv11757_> a it was lhs2TeX.fmt
02:29:10 <nlv11757_> nm
02:29:11 <kosmikus> yes
02:29:19 <a5> not (:), (++)
02:29:28 <a5> it's linear-time
02:31:36 <nlv11757_> ow sorry, my confusion, (:) is cons, (++) is append, check
02:35:39 <musasabi> What would be the best way to deal with library version information inside the library? a constant of Version or just a plain [Int] (or perhaps a String/Double) ?
02:36:25 <adiabatic> String.
02:36:31 <adiabatic> Maybe.
02:36:54 <kosmikus> what do you want to do with that information? export it? use it? print it?
02:37:18 <musasabi> kosmikus: well it is the version of the serialization library on wire format..
02:38:59 <nlv11757_> hmmm im using /\, but lhs2tex doesnt replace it
02:39:20 <kosmikus> no
02:39:51 <nlv11757_> ow i have to define meta
02:39:56 * nlv11757_ bump
02:40:25 <kosmikus> meta?
02:40:53 <kosmikus> %format /\ = "\whatever" should work
02:41:08 <kosmikus> ah, you mean that meta
02:41:16 <nlv11757_> you %if meta .....
02:41:28 <kosmikus> that's the problem, I don't, Ralf does ...
02:41:30 <kosmikus> :)
02:41:40 <kosmikus> so I don't even know that this is defined in lhs2TeX.fmt
02:41:40 <nlv11757_> ow thats ralf stuff
02:41:59 <nlv11757_> ok, so he already defined /\ but only when meta is defined
02:42:24 <kosmikus> ok
02:42:30 <kosmikus> then you have to %let meta = True
02:42:36 <kosmikus> before %include lhs2TeX.fmt
02:43:11 <nlv11757_> sweeeeeet, thanx
02:45:12 <nlv11757_> im printing that file
03:04:12 <RemiTurk> hia ll
03:17:32 <Forest> why do they make condoms with different smells ?
03:19:28 <Lemmih> Is that a lead-in to a joke or a real question?
03:20:13 <Forest> it's a question
03:22:57 <RemiTurk> omdat smaken nou eenmaal verschillen
03:27:33 <vincenz> hehe
03:28:43 <RemiTurk> now, a question back to Forest: what's its relation to haskell?
03:30:06 <Forest> RemiTurk: learning haskell is a kind of f...ing
03:30:18 <Forest> for first time
03:30:33 <bringert> Forest: how so?
03:30:45 <skew> are you enjoying?
03:31:20 <Forest> bringert: i meant for brains
03:31:33 <Oeje1> lol
03:31:46 * RemiTurk remembers breaking his head over "any . (==)" for days, but really cannot see any sexual analogue to that
03:32:10 <skew> oh, that's nice
03:32:14 <skew> days?
03:32:51 <RemiTurk> yeah, though of course not without long breaks of sleep, school, dinner, beer, tv, biking etc ;)
03:33:03 <Forest> skew: no, i just a little offtopic is acceptabled in the channel )
03:33:10 <bringert> it's awkward the first time, but as you go along you gain experience and confidence. most people enjoy it enough that they continue doing it for the rest of their lives.
03:33:12 <Forest> * ijust thought
03:33:25 <bringert> I'm talking about functional programming of course
03:33:33 <Forest> ^)
03:34:06 <bringert> Forest: was that what you meant?
03:34:34 * RemiTurk still doesn't see any haskell concept analogous to different flavours of condoms
03:34:51 <Forest> RemiTurk: it is offtopic
03:35:12 <xerox> What's about any.(==)?
03:35:23 <Oeje1> Haskell is a very safe language, though.
03:35:30 <skew> elem = any.(==)
03:35:49 <RemiTurk> xerox: nothing, except that it was hard to grok back when I was learning haskell
03:35:59 <xerox> Ah :D
03:36:12 <xerox> skew, right!
03:36:37 <RemiTurk> ahh
03:36:48 <skew> It's cool, but I don't see much mindbending about it.
03:36:49 <RemiTurk> side-effects...
03:37:42 <skew> I was confused for a while by the examples in the arrows paper
03:37:51 <RemiTurk> skew: neither do I now, but it definitely was difficult for me in a time I only new various basics, C/C++/Objective C, python and some pascal
03:38:09 <skew> Ah.
03:38:20 <skew> The language I learned immediately before Haskell was unlambda, iirc
03:38:45 <Forest> what's Objective C
03:38:52 <Forest> isnt it c++ )
03:38:59 <RemiTurk> the absurd lovechild of C and Smalltalk
03:39:52 <adiabatic> Brackets beat parentheses.
03:40:14 <RemiTurk> it's mainly much more dynamic, smaller and (IMO) cleaner than C++
03:40:44 <adiabatic> It needs namespaces.
03:40:45 <skew> speaking of clean languages, I started looking at lua recently
03:41:17 <RemiTurk> and NextStep/OpenStep/GNUStep/OSX is largely built in it
03:41:23 <RemiTurk> (ObjC, not lua)
03:41:51 <skew> I haven't done much with it, but it seems a lot like Python with a clean foundation
03:42:13 * RemiTurk hasn't ever seriously looked at lua
03:42:28 <Forest> all of them are not functional
03:43:33 <skew> For example, the Python object system seems to be very ad-hoc
03:44:12 <skew> Does anyone know of a simple way of handling operator precedence in a Happy parser?
03:44:38 * adiabatic giggles
03:44:43 <adiabatic> "happy fun parser"
03:46:06 * RemiTurk never was a happy user
03:47:38 <skew> the GLR stuff is really cool
03:54:27 <skew> bah, I guess I'll just do the usual thing
04:02:45 <_metaperl> I'm interested in starting cooperative internet hosting with the system tools based primary around Haskell
04:03:58 <Lunar^> _metaperl: What do you mean?
04:04:18 <_metaperl> web / internet hosting done cooperatively
04:04:25 <_metaperl> where do you host your websites?
04:04:34 <_metaperl> I currently host at hcoop.net
04:04:39 <nlv11757_> at home
04:04:42 <_metaperl> but I am having issues with the founders
04:05:04 <_metaperl> nlv you have permanent IP?
04:05:40 <earthy> um... is that so odd?
04:05:58 <_metaperl> what is "that" earthy?
04:06:01 <adiabatic> is what so odd?
04:06:05 <nlv11757_> metaperl, yes i do
04:06:07 <earthy> permanent IP
04:06:10 <nlv11757_> until my isp dies
04:06:12 <earthy> ie. fixed IP
04:06:19 <_metaperl> oh, well you have to pay more for it
04:06:23 <adiabatic> earthy: It's not guaranteed.
04:06:25 <_metaperl> I have dsl but no permanent IP
04:06:27 <earthy> nope.
04:06:35 <earthy> we have fixed IP with the ADSL
04:06:43 <earthy> at least, at one provider we doe. ;)
04:06:45 <earthy> -e
04:06:47 <nlv11757_> so theoretically, the ip CAN change, but it will never do
04:06:57 <adiabatic> I have static with my DSL provider, but from what I gather, it's somewhat odd these days.
04:07:33 <adiabatic> And even then, they called me at home and asked me to change my IP addresses once...
04:08:55 <nlv11757_> earthy, how much time do you reckon this coll. thing takes?
04:09:00 <mflux> static ip is nice, its something you can put into dns
04:09:14 <nlv11757_> I remembered I still have to do it sometime
04:09:54 <earthy> what coll.thing?
04:10:05 <boegel> I'll ask it again, hopefully someone can help me now... does anyone have samc's email ?
04:10:07 <nlv11757_> colloquiem or however you write it :D
04:10:45 <adiabatic> Colloquium?
04:11:08 <adiabatic> (I'm not sure what it is, but the spelling checker doesn't trip on it)
04:11:36 <nlv11757_> thats the correct spelling indeed
04:11:50 <Itkovian> boegel: you can leave him a memo, no?
04:12:01 <skew> does anyone know if alex regular expressions have an option for non-greedy repetition?
04:12:27 <earthy> sigh
04:12:34 <skew> I don't see anything in the docs, but it would be nice for parsing comments.
04:12:43 <skew> So I'm still hoping :)
04:13:47 <skew> what's wrong earthy?
04:16:07 <boegel> Itkovian: I doubt anyone really uses that
04:20:49 <nlv11757_> boegel: why don't you just mail him
04:20:59 <nlv11757_> :P
04:21:43 <boegel> nlv11757_: because I don't have his mail-adress... (I thought that was pretty clear by now)
04:21:58 <nlv11757_> boegel: I was being annoying :P
04:22:36 <boegel> nlv11757_: well done then ! :)
04:24:23 <TheHunter> skew, apperently the RevState monad is instance of a more general pattern:
04:26:05 <TheHunter> note to self: never mess with the locale, i can't copy+paste from my urxvt anymore.
04:28:03 <Itkovian> ok, you trustworthy lot. any suggestions on the purchase of an ibook/powerbook?
04:29:07 <earthy> go for it.
04:29:12 <skew> TheHunter: so, what was the pattern?
04:29:26 <TheHunter> one sec.
04:29:28 <earthy> itkovian: what more suggestions did you want?
04:29:58 <TheHunter> puh, apperently at least the locale en_US is supported by the goddam C library.
04:31:29 <TheHunter> newtype Rev m a = Rev { runRev :: m a } deriving Functor
04:31:29 <TheHunter> instance MonadFix m => Monad (Rev m) where
04:31:29 <TheHunter>   return = Rev . return
04:31:29 <TheHunter>   Rev m >>= f = Rev $ mdo y <- runRev $ f x; x <- m; return y
04:31:41 <nlv11757_> what is the additional value of an ibook in comparison to a laptop with linux?
04:32:37 <Philippa_> being designed for people who don't want to know about adminning a *nix system
04:33:24 <Itkovian> well ... I admin a linux at home and at work, so that wouldn't be any problem.
04:33:54 <musasabi> laptop hardware + linux = pain.
04:33:59 <Philippa_> you also get access to various mac-only apps, Cocoa etc etc. Not much of which appeals to me, but hey
04:34:14 <musasabi> things like working wireless ;)
04:34:17 <Itkovian> I was just wondering which of them has the better price/value ratio
04:34:21 <skew> note that Basilisk works very nice for playing old mac games :)
04:34:47 <Itkovian> musasabi: you're damn right there ... we've got a dell here and it's a pain in the ass to get the wireless working, let alone the sleep/suspend mode
04:35:32 <musasabi> Apple laptops are not really more expensive than other laptops, and they just work.
04:36:22 <Itkovian> no, but the powerbook would cost me 343 more euro's than the ibook
04:36:26 <musasabi> But of course if you want to play with getting Linux/*BSD/... to work with the hardware (usually with limited success) then that is fine also.
04:37:21 <TheHunter> *Main Control.Monad.Error> runRev (do x <- return 1; Rev $ throwError "foo"; Rev $ throwError "bar"; return x) :: Either String Int
04:37:21 <TheHunter> Left "bar"
04:37:24 <nlv11757_> dell uses lousy hardware in their laptops with respect to linux support then?
04:37:48 <musasabi> nlv11757_: linux has lousy support for most new laptop hardware.
04:38:03 <nlv11757_> ah, the other world around
04:42:52 <TheHunter> *Main> liftM2 (,) [1,2] [3,4] :: [(Int,Int)]
04:42:52 <TheHunter> [(1,3),(1,4),(2,3),(2,4)]
04:42:52 <TheHunter> *Main> runRev $ liftM2 (,) (Rev [1,2]) (Rev [3,4]) :: [(Int,Int)]
04:42:52 <TheHunter> [(1,3),(2,3),(1,4),(2,4)]
04:59:35 <_metaperl> @type run
04:59:36 <lambdabot> bzzt
05:00:01 <Itkovian> hehe .. you can't run buddy
05:20:49 <hellish> Woot! My first non-trivial haskell application!
05:21:14 <_metaperl> hellish, what is it?
05:21:30 <xerox> Schroeder algo?
05:21:46 <hellish> _metaperl, the solitaire cryptosystem.
05:22:13 <_metaperl> i dont know much about encryption
05:27:25 <hellish> _metaperl, it's a stream cipher designed to be used with a pack of cards. I wrote a software implementation.
05:27:42 <_metaperl> playing cards?
05:28:54 <hellish> _metaperl, yes. Less incriminating
05:29:12 <_metaperl> hi JaffaCake, I just ordered your book, so please dont announce that edition 3 is on its way out now :)
05:29:44 <JaffaCake> probably not my book, perhaps my colleague Simon PJ?
05:29:55 <_metaperl> simon thompson
05:29:59 <JaffaCake> ah
05:29:59 <_metaperl> oops
05:30:03 <_metaperl> 3 simons out there :)
05:30:10 <JaffaCake> that's ok, Simon confusion is common
05:30:31 * JaffaCake thinks he should write a book too
05:30:54 <_metaperl> make sure that is available online for free
05:31:01 <JaffaCake> of course ;)
05:31:19 <_metaperl> what interest does Microsoft have in Haskell?
05:31:41 <JaffaCake> well... none directly
05:32:12 <JaffaCake> but Haskell is an interesting research vehicle, and MS pays us to do research
05:32:33 <_metaperl> does it influence the design of C#, for instance?
05:32:50 <_metaperl> I dont see the influence of Haskell in any microsoft products
05:32:50 <JaffaCake> not directly, but C# is getting generics
05:32:52 <nlv11757_> Simon is at ms research isnt he?
05:32:56 <kenr> anyone out there have a moment for a relatively subtle functional programming question?
05:33:05 <nlv11757_> ms keeps ghc in the air no?
05:33:13 <_metaperl> 2 of the 3 simons are: simon p-j and simon mar(jaffacake)
05:33:20 <_metaperl> the other simon is at kent
05:33:42 <JaffaCake> there's also Simon Jones, don't know where he's got to these days
05:33:44 <nlv11757_> i meant *the* simon, no offence :P
05:34:13 <eq> kenr: don't ask to ask, just ask
05:34:41 <kenr> eq, thanks -- i'm new to irc.
05:36:03 <kenr> inspired by Felleisen's functional objects presentation (http://www.ccs.neu.edu/home/matthias/Presentations/ecoop2004.pdf) i'm trying to implement a purely functional GUI. everything is working fine, but i keep running into the issue of references to pieces of the functional data structure.
05:37:23 <kenr> i'm currently keeping references by including an integer id in each component, but that seems really inelegant to me.
05:38:12 <nlv11757_> whyyyy cant i get these frikin parametrized formatting directives to work in lhs2TeX
05:38:23 <kenr> it seems like this must be a common issue in functional programming, but i've yet to track down a reference to the standard way this is done yet.
05:38:35 <nlv11757_> what am i doing wrong here; '%format meta (a) = "\textcolor{red}{" a "}"
05:39:06 <nlv11757_> then i use it as '| blablabalbalbla meta(() adsd |'
05:39:11 <nlv11757_> it keeps printing just the red dot
05:39:43 <_metaperl> kenr, have you looked at wxHaskell?
05:40:13 <_metaperl> http://www.cs.uu.nl/~daan/wxhaskell.html
05:41:20 <kenr> thanks metaperl -- looking at the paper now -- are you familar with its implementation?
05:45:18 <kosmikus> nlv11757_: because blablabalbalbla binds to meta
05:45:51 <kosmikus> do %format (meta (a)) = ...
05:46:05 <kosmikus> and then "foo (meta(bar))"
05:46:33 <nlv11757_> hmm i obviously dont get the binding thing
05:47:42 <kosmikus> just use what I said ;)
05:47:58 <kosmikus> it's like in Haskell, if you write "a b (c)"
05:48:10 <kosmikus> then it is an application of "a" to "b" and "(c)"
05:48:15 <kosmikus> not an application of "b" to "c"
05:48:52 <kosmikus> if you want the latter, you have to write "a (b (c))"
05:49:48 <nlv11757_> ow does it work like that
05:49:51 <nlv11757_> ty
06:11:52 <duncan_> kenr: at the moment there is no standard high level GUI API. There are a number of low/medium level toolkits like wxHaskell, gtk2hs and hs-fltk but all of these are more low level than what you're after. They all require you to use IORefs to maintain GUI program state. There are some higher level things implemented on top of these toolkits like wxFruit http://zoo.cs.yale.edu/classes/cs490/03-04b/bartholomew.robinson/ (based on http://hask
06:11:52 <duncan_> ell.org/fruit/) and "FG" http://kevin.atkinson.dhs.org/fg/
06:14:03 <kosmikus> JaffaCake: any plans for a new haddock release?
06:14:17 <JaffaCake> yeah, I should do one really
06:14:31 <JaffaCake> hopefully soon
06:14:44 <JaffaCake> code in CVS works pretty well, if you want to use that
06:14:58 <duncan_> JaffaCake: it fixes all my previous complaints
06:15:11 <JaffaCake> great!
06:15:16 <kosmikus> it's about Gentoo; we can't really unmask ghc-6.4 until haddock works with it ...
06:15:26 <JaffaCake> ah, i ses
06:15:30 <JaffaCake> see
06:15:44 <kosmikus> we could make a CVS snapshot version, but if you say that you're doing a release very soon anyway, we'll just wait
06:15:57 <JaffaCake> haddock 0.6 doesn't work with 6.4?
06:16:03 <duncan_> kosmikus: remind me: ghc-6.4 needs cvs haddock?
06:16:23 <duncan_> I know the docs on the ghc web page use haddoc 0.7
06:16:29 <kosmikus> well ... ghc-6.4 depends on haddock for documentation generation
06:16:42 <JaffaCake> but does it actually need 0.7?
06:16:52 <kosmikus> no
06:16:58 <JaffaCake> there you go then ;)
06:17:26 <kosmikus> still not nice
06:17:52 <kosmikus> someone without ghc installed will be forced to bootstrap off ghc-6.2.2 instead of ghc-6.4 just because haddock needs to be built with ghc-6.2.2
06:18:29 <duncan_> oh so it's the other way around, haddock 0.6 does not build with ghc 6.4?
06:18:30 <_metaperl> JaffaCake, what is a "JaffaCake" ?
06:18:37 <earthy> Data.Map is new for 6.4 right?
06:18:37 <kosmikus> duncan_: yes
06:19:03 <duncan_> _metaperl: it's a sort of biscuit / small cake, popular in the UK
06:19:05 <kosmikus> duncan_: that's the only problem
06:19:05 <ibid> _metaperl: at least in finland, a delicious cookie :)
06:19:16 <_metaperl> oh, we dont have that here in the United States :)
06:19:43 <JaffaCake> _metaperl: go search for McVities Jaffa Cakes
06:20:18 <duncan_> kosmikus: can we fix haddock to work with ghc 6.4?
06:20:41 <JaffaCake> I wasn't aware that it didn't... looks like a release is more urgent
06:20:48 <earthy> damn, my libreadline is b0rked so that ghc 6.2 won't work with it anymore
06:20:56 <earthy> time to upgrade
06:21:24 <earthy> i.e. throw away all vestiges of finks ghc and install wolfgang's package
06:23:29 <kosmikus> let me check again what the problem is
06:25:24 <duncan_> HaddockUtil.hs:191:76: lexical error in string/character literal
06:28:35 <Heffalump> anyone know about installing HaXml with ghc 6.4? I think the pkg.conf format change is upsetting it.
06:29:19 <duncan_> Heffalump: yep, that upsets everything. All packages need updating. :-(
06:30:09 <Heffalump> does anyone know a quick fix, or do I need to manually edit the conf file?
06:30:43 <kosmikus> duncan_: is that the error you get?
06:31:07 <duncan_> kosmikus: yes, it's the multiline string problem
06:31:38 <kosmikus> are you actually using the ebuild?
06:31:59 <duncan_> kosmikus: no
06:32:19 <duncan_> just the 0.6 tarball that I had lying around
06:32:20 <kosmikus> ah, because there's a gcc-3.4 patch
06:32:33 * Heffalump reads the new package.conf format and goes UGH
06:32:35 <duncan_> oh, ok
06:32:55 <duncan_> Heffalump: and remember to add the complete list of exposed modules...
06:33:38 <kosmikus> I get a quite strange linking error which I haven't investigated any further
06:33:40 <Lemmih> There's a cabalized HaXml is the fptools cvs.
06:34:23 <Lemmih> s/is/in/
06:34:41 <kosmikus> maybe that's actually easy to fix: Main.o(.text+0x157c3): In function `__stginit_Main_':
06:34:44 <kosmikus> : undefined reference to `__stginit_ControlziMonadziWriter_'
06:34:58 <musasabi> kosmikus: -package mtl
06:35:13 <Heffalump> lemmih: hmm, do you know when they plan to make a release?
06:35:28 <Heffalump> btw, just saw HaCanon, looks really cool.
06:36:12 <kosmikus> musasabi: ok, thanks
06:38:53 <termol> hi guys. how to split a string into words in haskell?
06:39:05 <duncan_> kosmikus: yes that works for me, add -package mtl to SRC_HC_OPTS, haddock/src/Makefile line 10
06:39:09 <boegel> @type split
06:39:10 <lambdabot> bzzt
06:39:14 <boegel> @index split
06:39:15 <lambdabot> Language.Haskell.THSyntax,GHC.Exts,System.Random,Random
06:39:17 <Heffalump> @type words
06:39:18 <lambdabot> words :: String -> [String]
06:39:20 <Itkovian> termol: words?
06:39:25 <boegel> yeah, what he says :p
06:39:40 <boegel> I believed there was a function split too ?
06:39:55 <termol> yes i have a line of words (a line in a string)
06:41:10 <termol> what about an arbitray split character? (not just space)
06:43:06 <kosmikus> duncan_: indeed, I'll fix the ebuild
06:43:34 <kosmikus> JaffaCake: looks like the new haddock release isn't that urgent after all ;)
06:43:49 <JaffaCake> phew
06:43:57 <earthy> but we'd still *like* it... :)
06:44:30 <kosmikus> earthy: hi ... how was your talk?
06:46:22 <earthy> very, very, very lousy.
06:46:32 <earthy> I'm up for Doaitse's thunder next tuesday
06:47:01 <kosmikus> how so?
06:47:19 <earthy> (too abstract, no concrete results, nothing you can actually show `here, that shows why this approach works')
06:47:20 <kosmikus> what did you do? did you actually claim that attribute grammars are the world's biggest curse?
06:47:35 <duncan_> kosmikus: :-)
06:47:42 <earthy> nope
06:47:45 <earthy> not that :)
06:48:06 <Muad_Dibber> should have though :P
06:48:33 <earthy> thing is it's still too much work in progress, but Wishnu and Doaitse think I should've gotten further already
06:48:47 <kosmikus> Muad_Dibber: blasphemy!
06:49:10 <earthy> may in fact be true... haven't really spent enough time on it lately, what with teaching duties and moving and such
06:49:27 <kosmikus> hmmm
06:49:29 <Oeje1> Data.List would be more useful with a function splits :: [a] -> [a] -> [[a]], so that words = splits [' ', '\t'].
06:49:31 <Muad_Dibber> earthy : talking about the colloquiem talk?
06:49:36 * earthy nods
06:50:54 <Muad_Dibber> okay
06:51:27 <kosmikus> earthy: you have a lot of teaching duties, don't you? and you're doing the STC organisation as well ... they should see that.
06:51:48 <earthy> I had internet programming
06:51:53 <earthy> last period
06:51:57 <Muad_Dibber> and good work takes time
06:51:59 <earthy> and Lennart has been somewhat away
06:52:13 <kosmikus> I had the impression you were spending a lot of time on that
06:52:20 <kosmikus> and you had your move, too
06:52:25 <earthy> almost full time, indeed.
06:52:58 <earthy> anyway, Wishnu was Not Pleased, nor Doaitse. I'll see tuesday.
06:53:13 <kosmikus> I think you have enough justification to claim that you'll do better during the next few months :)
06:53:23 <earthy> ah, yes. :)
06:53:35 <earthy> now I need something to substantiate that claim
06:53:41 <earthy> by tuesday. :P
06:53:50 <Muad_Dibber> at least i learned doaitse's lemma today :P
06:54:01 <kosmikus> Muad_Dibber: what is it?
06:54:01 <earthy> doaitse has a lot of them :)
06:54:18 <earthy> btw, Muad_Dibber, did you get what I was talking about?
06:54:48 <Muad_Dibber> Monads are not like Aspirin: aspirin cures an headache, whereas monads cause one
06:55:03 <kosmikus> sounds like Doaitse to me
06:55:08 <_metaperl> aspirin masks a headache
06:55:17 <earthy> monads mask complexity
06:55:24 <earthy> they *are* similar in a sens.e. :)
06:56:14 <Muad_Dibber> earthy : mostly i got it, but since i'm not all that familiar with the orginial transformer semeantics and such, it remains a bit vague as to its usefullness etc
06:56:37 <earthy> at least I succeeded in bringing the base ideas across then.
06:56:53 <earthy> good to hear that
06:59:59 <nlv11757__> internet programming didnt take that much time did it :P
07:00:17 <earthy> not for you guys :)
07:00:30 <nlv11757__> hey btw, i did have frikin lot of work
07:00:40 <nlv11757__> i got more than proportional piece of grading work
07:00:58 <nlv11757__> didnt weigh up to assisting two more hours
07:01:00 * earthy went through all the assignments to compare if you guys where on a level with eachother
07:01:03 * earthy knows
07:01:17 <earthy> I did mention it to Lennart once or twice
07:01:32 <bourbaki> moin
07:01:34 <earthy> he `forgot' to take it into account on the last assignment
07:01:37 <nlv11757__> what a nightmare sometimes....i got 26 or so
07:01:40 <nlv11757__> when other guys had 7 :S
07:01:56 <bourbaki> is there anyway to get haskell into c?
07:02:20 <CosmicRay> bourbaki: do you mean, "call haskell code from C" or "transform haskell code to C"?
07:02:22 <nlv11757__> embedding Haskell inside your C program?
07:02:53 <bourbaki> CosmicRay: as in link a lib in c and pass the code to the lib and compile it
07:03:13 <ibid> pass which code?
07:03:21 <bourbaki> the haskell code
07:03:27 <CosmicRay> still confused, how do you "pass the code to the lib"?
07:03:27 <ibid> a specific library or any library?
07:03:28 <nlv11757__> lib.dothishaskellplease("module bla where ....")
07:03:38 <CosmicRay> ah.
07:03:46 <ibid> well, one can write such a lib :)
07:03:49 <_metaperl> hi CosmicRay
07:03:49 <nlv11757__> i was jokinh cosmic
07:03:49 <CosmicRay> perhaps hs-plugins would be of itnerest
07:03:50 <earthy>     Illegal instance declaration for `Show (FiniteMap String Integer)'
07:03:50 <ibid> doubt that one exists
07:03:52 <bourbaki> just call a function like thelib.compile(the_code) :)
07:03:54 <earthy> !sigh
07:03:55 <CosmicRay> morning metaperl
07:04:00 <earthy> I should know this shite
07:04:09 <CosmicRay> _metaperl: just got your e-mail... I use memset.com
07:04:10 <kosmikus> duncan_: ok, the new haddock-0.6-r3 is committed, ghc-6.4 block removed
07:04:12 <nlv11757__> :/ ow damn bourbaki did mean that :D
07:04:20 <_metaperl> ok
07:04:30 <bourbaki> the prob is i want to get scheme/lisp, prolog, haskell and c/c++ within one framework
07:04:36 <nlv11757__> eeeeeek
07:04:43 <CosmicRay> _metaperl: they have good prices on user-mode-linux servers, especially if you prepay for a year
07:05:47 <duncan_> kosmikus: ok, how long does one usually have to wait before the rsync mirrors update?
07:06:15 <earthy> right. it just wasn't plain Haskell'98
07:06:15 <kosmikus> should be maximum of 60 minutes
07:06:19 <duncan_> ok
07:06:24 <nlv11757__> bourbaki, may i ask you for your motivation for this framework?
07:06:55 <bourbaki> nlv11757__: yes, i like to think of problems with specific languages
07:07:10 <bourbaki> c is hardware stuff like rendering and such
07:07:21 <nlv11757__> so sometimes you want to use this language, sometimes that language and all intermixed?
07:07:27 <bourbaki> lisp scheme is for ai due to its typeless ness its easy to use there
07:07:39 <bourbaki> prolog is nice for ai also and such
07:07:49 <bourbaki> and haskell is just the greatest thing for math imho
07:07:56 <bourbaki> right
07:07:58 <earthy> why not embed prolog as a dsl in haskell?
07:08:06 <nlv11757__> possible
07:08:11 <bourbaki> thats is what i might do
07:08:12 <earthy> what are you trying to do?
07:08:24 <nlv11757__> tamagotchi
07:08:29 <bourbaki> useing swi prolog with a c interface is not much more work though
07:08:38 <Muad_Dibber> earthy : why not use stratego for that :P
07:08:38 <bourbaki> earthy: writeing game stuff and such
07:08:40 <earthy> possibly not
07:08:48 <earthy> muad_dibber: for what? :)
07:08:59 <Muad_Dibber> "embedding" prolog in haskell :)
07:09:05 <earthy> owh... yeah... well... :)
07:09:13 <earthy> that's just sugaring. :)
07:09:17 <nlv11757__> using stratego for the embedding :S
07:09:22 <nlv11757__> thats not embedding
07:09:28 <bourbaki> whats stratego?
07:09:33 <earthy> don't ask :)
07:09:35 <earthy> honestly :)
07:09:38 <bourbaki> ok
07:09:41 <nlv11757__> hehe untyped
07:09:45 <nlv11757__> .
07:10:12 <bourbaki> maybe i can build some way that automatically writes object files form haskell code and link that then automatically in c?
07:10:19 <Muad_Dibber> "it is typed, it has terms and strategies" ;) ;)
07:10:22 <bourbaki> within something like an ide
07:10:26 <nlv11757__> it
07:10:29 <nlv11757__> isnt typed
07:12:04 <nlv11757__> i think the pattern matching and rewriting stuff makes it impossible to type, but there were better arguments which i forgot
07:12:13 <nlv11757__> since i erased stratego from my mind
07:16:53 <Muad_Dibber> it probably is
07:17:29 <Muad_Dibber> since if i transform a prolog AST to a haskell AST what will be the type of it somewhere in between?
07:18:12 <earthy> AST
07:18:22 <earthy> ATerm, really
07:18:56 <Muad_Dibber> aterm is just the format used to represent the ast, at least in my point of view :P
07:19:03 <earthy> um. :)
07:19:09 <nlv11757__> earthy, what was it again, that stratego made inherently untyped
07:19:10 <kosmikus> format == type ?
07:19:29 <earthy> there is an ATerm library for haskell allowing you to import ATerms into haskell space... so...
07:19:39 <earthy> nlv11757: unsure
07:19:59 <nlv11757__> i had discussion with doaitse once, he explained to me why it could never be typed, i forgot it :/
07:20:00 <nlv11757__> hehe
07:20:08 <kosmikus> nlv11757__: I don't think it's "inherently" untyped; actually, I think that someone (Ralf L.?) has written a paper about a type system for Stratego, but I think that was so complicated that it's better to have none than that
07:20:27 * earthy concurs
07:20:49 <nlv11757__> ok so i guess what im asking is, what is it in the nature of stratego that makes it so complex
07:20:50 <earthy> anyway, back to the toy-language example that I was working on.
07:20:55 <nlv11757__> hehe
07:21:22 <earthy> (at least the code I write still compiles after the 3rd try)
07:21:50 <nlv11757__> gj :P
07:21:55 <kosmikus> nlv11757__: I think it's the same argument why you cannot suddenly add a static type system on top of Python or Scheme; people use the language in such a way that any reasonably simple type system would rule out almost all current programs as invalid
07:22:58 <Muad_Dibber> kosmikus : but thats not a cause for it, but an argument for usability :)
07:23:06 <earthy> um. which is another way of saying that you'd need full subtyping and automatic unions? :)
07:23:39 <earthy> which quickly makes things undecidable in the absence of type-signatures.
07:24:18 <kosmikus> I think one could design a Stratego-like language with static typing from scratch, but it probably wouldn't be Stratego anymore ...
07:25:01 <kosmikus> and the fact that Stratego has dynamic rules now doesn't make the issue any easier ...
07:25:16 <nlv11757__> you mean rho-stratego by E.Dolstra ?
07:25:37 <kosmikus> for example
07:25:42 <Muad_Dibber> which is?
07:26:13 <kosmikus> http://catamaran.labs.cs.uu.nl/twiki/pt/bin/view/Stratego/RhoStratego
07:30:35 <Muad_Dibber> hmm
07:32:59 <nlv11757__> cool thesis project
07:34:17 <Muad_Dibber> there are many nice thesis projects in this area :)
07:48:47 <JaffaCake> about 250 completed surveys so far :)
07:50:26 <Oeje1> Ciao, _JusSx_.
08:03:21 <duncan_> JaffaCake: how do I enable (building & running) the gtk front pannel in ghc's rts?
08:03:38 <JaffaCake> duncan_: hang on, I'll just check
08:03:48 <duncan_> ta
08:03:58 <JaffaCake> GhcRtsWithFrontPanel = YES
08:04:01 <JaffaCake> in your build.mk
08:04:09 <duncan_> ok, thanks
08:04:17 <JaffaCake> it's bitrotted a lot, though
08:04:31 <duncan_> I know, I was thinking of updateing it to gtk2
08:04:39 <JaffaCake> that would be way cool
08:04:53 <duncan_> & using libglade rather than glade's C code generation
08:05:08 <JaffaCake> right
08:05:48 <duncan_> that'd add an extra .glade file into ghc's $libdir/somewhere/thing.glade
08:05:48 <Philippa> 'lo
08:06:16 <JaffaCake> libglade reads an XML file, or something?
08:06:22 <duncan_> yes
08:07:24 <duncan_> it's the same .glade file you have in CVS (updated to glade 2.x format) but it'd get installed
08:07:27 <JaffaCake> it'd be nice to ship the front panel with GHC as an option - could be an RTS way, or maybe just in there by default if you have GTK and if it doesn't slow things down too much
08:09:12 <nlv11757__> im such an optimist when it comes to the weather.....
08:11:02 <nlv11757__> unfortunately
08:17:50 <duncan_> JaffaCake: have you noticed ghc on amd64 requesting silly amounts of memory and dieing? (i'm using your registerised binary snapshot from a week or so ago) eg: ghc-6.4: out of memory (requested 28608778207232 bytes)
08:18:15 <JaffaCake> might happen if you have old .hi files lying around
08:18:23 <duncan_> ok
08:18:46 <JaffaCake> btw, I have a partially working am64 native code gen now
08:18:52 <duncan_> :-)
08:19:04 <JaffaCake> no floating pt yet
08:19:28 <duncan_> I'd like to put together a patchset for gentoo of ghc-6.4(+) for amd64
08:20:07 <duncan_> kosmikus said it'd probably be ok to do this so long as the patches will apply for all arches without upsetting anything
08:20:29 <duncan_> I mean ok from a gentoo policy point of view
08:20:31 <JaffaCake> you mean specifically the foreign import "wrapper" changes?
08:20:52 <JaffaCake> the registerised changes were in 6.4
08:21:06 <duncan_> oh, they were, ok
08:21:29 <JaffaCake> yup, but I added foreign import "wrapper" later
08:21:45 <duncan_> so, yes the import wrapper and any fixes that are developed for the heap curruption bugs
08:21:59 <JaffaCake> oh yes, must get back to that :)
08:22:40 <duncan_> yesterday I found it writing over gtk's data structures and causing segfaults in gtk libs
08:22:54 <JaffaCake> oops
08:23:25 <JaffaCake> the crash when compiling gtk2hs I'm sure is in the compacting GC
08:23:37 <JaffaCake> because you're using +RTS -M<something>
08:23:49 <duncan_> eg an argument to a function insde gtk code that was suppsoed to be a constant C string "left" became.. something else
08:24:11 <duncan_> oh I see, If I turn off -M it'll be ok (so long as I have enough mem) ?
08:24:20 <duncan_> (probably :-) )
08:24:25 <JaffaCake> should be, that's my guess
08:24:31 <duncan_> I'll try it...
08:34:54 <duncan_> sadly I only have 1Gb of RAM and without -M I had to kill c2hs once it had allocated 1.3Gb :-( but on the upside it didn't die whe it usually did, it got much further
08:38:59 <nlv11757__> sadly, you just have 1Gb of RAM....no what doesn't sound right in that sentence :D
08:39:05 <nlv11757__> *JUST*
08:39:09 <duncan_> :-)
08:39:16 <nlv11757__> people are spoiled
08:39:22 <duncan_> you've never used c2hs in anger :-)
08:39:43 <kosmikus> what's so difficult about what c2hs is doing that it needs these amounts of RAM?
08:39:47 <nlv11757__> translating C to Haskell?
08:39:59 <nlv11757__> is that what c2hs does?
08:41:33 <duncan_> c2hs is an FFI preprocessor, it parses C header files and uses the information it gathers to expand specifications like {# call gtk_widget_new #} into an appropriately typed bit of Haskell code and an associated FFI import decleration
08:42:36 <duncan_> the reason it takes so much memory is that it parses the C headers (which end up being 10,000's of lines) and keeps all that information + some associated lookup maps in memory.
08:43:17 <duncan_> I'd like to modify it to write the maps out into binary files as it reads stuff in, but it's a major invasive change
08:43:44 <duncan_> it's worth a paper I'm sure: "writing external algorithms in Haskell"
08:44:32 <duncan_> I'm sure there's some nice non IO monad in there backed by some low level mmap + tmpfs foo
08:47:04 <nlv11757__> is it comparable to HDirect?
08:50:24 <duncan_> HDirect (if I understand correctly) processes special IDL files which define the interfaces. c2hs reads actual C header files which makes it much easier for binding a C interface since you don't have to write another interface specification (and worry that the two might be inconsistent). Eg every time the Gtk+ devs change something we find out because c2hs will generate code that gives us a type error. Also, c2hs works by processing Haske
08:50:24 <duncan_> ll modules with FFI directives so your binding module can contain other code and extra custom marshaling code etc.
08:59:49 <Lemmih> Hello and goodbye, shapr.
09:11:17 <nlv11757__> probably thought it was time to go home
09:11:52 <Lemmih> nlv11757__: He's self-employed. Where do you think he was? (:
09:12:24 <nlv11757__> darn, i wouldnt like working at home...where's the line between work and free time then
09:14:06 <Lemmih> Never had a job so I wouldn't know the difference.
09:15:01 <a5> you could have two different desks. or two different accounts on your computer.
09:15:21 <a5> uh, just kidding
09:15:26 <nlv11757__> darnnnn
09:22:06 <TNKS> hey guys.   I now what memoization is in theory, and why it's important.  Also I know how to use it for a few problem-types, but I have a hard time noticing when other people employ it.  Is there a web-page that helps explains how it works from the interpreter's perspective?
09:22:30 <TNKS> Maybe something that talks about evaluation rules.
09:31:45 <TNKS> (anybody free)?
09:37:35 <Oeje1> TNKS: Are you thinking about memoization as in dynamic programming?
09:39:02 <TNKS> yeah, I think that's a term for it (I'm not as familiar with the latter).
09:39:22 <TNKS> Maybe we can reference a basic example that I was taught memoization with.
09:39:24 <TNKS> fib = 1:[a+b|(a,b) <-zip fib (0:fib)]
09:39:55 <TNKS> There are other ways to memoize, and I have a hard time detecting them when they don't use list comprehensions and zip.
09:40:06 <TNKS> So I need a deeper understanding.
09:40:49 <TNKS> (I think that my fib function memoizes. . . I did that from memory).
09:41:39 <Oeje1> TNKS: Dynamic programming is just caching.  Sometimes it can reduce an algorithm from O(2^n) to O(n^2).
09:42:20 <skew> memoization is just whenever you record the results of calls to your function in a data structure, and look for a result there before actually calling the function
09:43:48 <skew> You can do it explicitly with a map (associative array/hash, not the list processing thing)
09:44:26 <TNKS> can you give me a quick example, say for fib, that memoizes with map?
09:45:15 <skew> well, actually you probably need mutable state for that, which confuses things a bit
09:46:50 <TNKS> well, any quick one-line example will do.
09:47:14 <TNKS> fib isn't so important, as understanding memoization.
09:47:44 <nlv11757__> in principle you would only calculate everything once
09:48:48 <skew> but you can do something like fib n = do cache <- readIORef cacheRef; cached <- lookupFM cache n; case cached of { Just x -> return x; Nothing -> do {x <- fib (n-1); y <- fib (n-2); writeIORef cacheRef (addToFM cache n (x+y)); return (x+y)}}
09:49:01 <Oeje1> TNKS: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_idx_3322
09:49:21 <kosmikus> there's no need to have mutable state to talk about memoization
09:49:40 <skew> the nicer way is to just use lazy evaluation
09:49:54 <sylvan> just have an array of the first n values or so, they are lazy in their elements
09:50:19 <skew> A value in Haskell is either actual data, or a little box around the code to run to compute the value, if you ever need it
09:50:39 <shapr> wow, 132
09:51:24 <skew> Now that code only runs when you look at the value, so you can make a data structure that notationally contains all the values of your function, and then make the function you actually call just read from the data structure
09:51:42 <Lemmih> Hey shapr.
09:51:46 <shapr> hiya Lemmih
09:51:49 <skew> the first time you need a particular result the Haskell runtime will go off and actually run some code, after that you just get the value
09:51:58 <Lemmih> shapr: I need you!
09:52:10 <shapr> ?
09:52:11 <Lemmih> shapr: Or well, I need your apache config.
09:52:16 <shapr> er, really?
09:53:13 <Lemmih> shapr: I'm trying to hack further on Hackage but I'm having problems with Apache. And I know for sure that you've successfully run Hackage on a Debian box with apache.
09:53:42 <shapr> apache2 at least
10:00:09 <wilx> shapr, I've been looking at the lambdabot...are there any portability requirements? Like not using Text.Regex? Some of the parts could really benefit from using it.
10:00:43 <Igloo> Text.Regex is portable now I think
10:02:54 <shapr> _metaperl: Does issues with the founders mean Smerd? =)
10:03:47 <_metaperl> yes, how did you know about that?
10:03:48 <_metaperl> :)
10:04:27 <_metaperl> oh, I think I mentioned something here earlier today
10:04:33 <shapr> Well, I banned him from #haskell for what was essentially 'being an asshole'.
10:06:18 <shapr> I found an amusing quote that I think sums up Smerd...
10:06:46 <shapr> <eiz>   #ocaml is mainly a guy who tells people to use SML instead [...] <slava> this guy never actually talks about scheme, unless its comparing it with SML
10:08:14 * Lemmih is one of the few who actually likes the guy.
10:08:56 <shapr> imho, the best characters change as a book progresses. I am not convinced it is possible for smerd to receive input in such a way that he gives it a chance to be 'truth'
10:09:19 <shapr> In fact, I prefer to skip the whole goal of 'truth' and 'right'. I want to learn cool stuff.
10:09:44 <skew> shapr: well, that's half an open mind.
10:10:07 <skew> shapr: of course, giving everything a chance to be true is the other half.
10:10:13 <shapr> I am convinced that I do not know everything, and that there are better ways to do stuff.
10:10:22 <shapr> So I keep looking for them, and comparing them to what I have now.
10:10:56 <shapr> skew: what were the two halves?
10:11:29 <skew> for each statement, giving proper consideration to the possibility of it being true and false
10:11:40 <skew> Learning cool stuff is good too :)
10:12:08 <shapr> Lemmih: I don't dislike Smerd, I just don't want to talk to him, or have him in my immediate social environs.
10:13:34 <skew> speaking of better ways to do stuff, do you know any good ways of handling operator precedence in a parser?
10:13:36 <Lemmih> That plus calling him an asshole pretty much qualified as 'dislike' (:
10:13:46 <Lemmih> *qualifies
10:14:01 <shapr> You're right, I should quantify my description.
10:14:02 <_metaperl> wow, banned Smerd from #haskell.... lol
10:14:08 <skew> Lemmih: his exact statement was a little less direct
10:14:08 <shapr> _metaperl: twice even
10:14:18 <_metaperl> I really do think I need to divorce myself from hcoop... any suggestions?
10:14:26 <_metaperl> I want to start a hosting cooperative
10:15:12 <shapr> Specifically, it is valuable and important to me that the people I talk to give my ideas real consideration. And it is equally important to me that I and everyone else gets a chance to 'drive' the conversation, and to contribute their own ideas into any part of a conversation.
10:15:48 <Darius> skew: There are fairly good ways yes.
10:16:24 <skew> about the precedence, my options now are 1) bake a predefined precedence structure into a happy grammer and have a stateful lexer updated with the new operator definitions 2) Use GLR and sort it out after the fact (probably a bit inefficient) 3) Use parsec
10:17:04 <skew> I don't really like 1 because it's annoying coding and doesn't allow cool stuff like an arbitrary partial order of precedence levels
10:17:08 <shapr> It is also important to me that to have a service oriented approach to questions. That is, I will first answer someone's question, then I will offer other approaches that may be advantageous to them. And, everyone gets the chance to say "no, I'm not interested in possibility X" after which I will no longer suggest it to them.
10:17:41 <skew> shapr: this is now "what matters to shapr", now "what did smerd do wrong", right?
10:17:58 <shapr> skew: no this is "what I meant when I used the word asshole"
10:18:04 <shapr> smerd got banned for driving off newbies.
10:18:06 <skew> ah
10:18:14 <wilx> Heh.
10:18:17 <wilx> Nice.
10:18:36 <skew> I do have some sympathy for deciding that certain questions are unproductive
10:18:56 <skew> like the infamous "how do I get an a out of an IO a" :)
10:19:34 <skew> but yes, those seem like good guidelines
10:19:36 <wilx> Hm, then you should either stay quiet or lead the asking person to what you think is what they really want/should want/should do.
10:20:00 <wilx> This is what we try to do on IRCNet's #C++.
10:20:05 <wilx> At least what I try to do.
10:20:28 <shapr> I think the correct approach is to a) give the answer to the question, and b) offer other approaches that may be advantageous.
10:20:58 <skew> interesting tricotomy. How much do "should want" and "should do" differ?
10:21:03 <shapr> I try to say stuff like "if your goal is to learn the powerful ideas that lie in purely functional programming, unsafePerformIO really isn't a good choice."
10:21:47 <ibid> well, uPIO is usually a bad idea even if one is not interested in the powerful ideas of purely functional programming
10:21:48 <shapr> I think there's really what you want and what you need. 'Should' usually turns out to be what your parents or other parts of your society are trying to tell you to do.
10:21:57 <skew> Darius: what sort of things would you suggest?
10:22:05 <ibid> it's unsafe for a reason :)
10:23:40 <skew> shapr: there's an important category that you are currently uninformed or haven't thought enough about the problem, and if you did you would come to a view that is better/more experienced/more like mine
10:23:57 <skew> okay, so the last slash isn't all good.
10:23:58 <Darius> skew: You can use Parsec (see http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text.ParserCombinators.Parsec.Expr.html) or you can do what Parsec does.  GLR seems overkill if it's only precedences you care about.
10:24:23 <Darius> Also I'd think Happy would let you specify precedences like most parser generators.
10:26:06 <skew> Darius: yeah, Happy does have precedence specifications
10:26:16 <skew> the thing is, I don't want to hardcode the operators into the parser
10:26:38 <skew> I want to support something more like Haskell's operator definition and precedence specifications
10:27:16 <Darius> That should be doable with Parsec and dynamically created parsers.
10:27:33 <Darius> Though you may want to be more strict about where fixity declarations can appear.
10:27:48 <skew> Approach 1 is using that dynamic state (through parser<->lexer communication) to translate all the operators of a given precedence to some "infixl7" token, and use that %prec directives and whatever to parse that
10:28:31 <skew> 2.5 is parsing some kind of flat expression and applying precedence afterwards.
10:29:49 <skew> It doesn't quite catch all the tricky examples like Haskell's "expressions extend as far as possible" rule, which says "if x then y else True == False == True" must parse as (if x then y else True == False) == True because == is nonassociative, but if x then y else 1 + 2 + 3 must parse as if x then y else (1 + 2 + 3) because that makes the if longer
10:31:20 <skew> Although I guess to get that I'd need to expose the different precedence levels in the grammar anyway, and if I do that I might as well just give each token the right precedence to begin with
10:31:44 <skew> So, is the simplest way overall to use Parsec?
10:33:45 <Darius> Possibly.  The nice thing about Parsec as compared to a parser generator is that you can abstract from parsers and patterns of parsers, and of course it's way more dynamic.
10:34:58 <autrijus> pugs now compiles mandel.p6 from perl6 to parrot and it just works :)
10:35:20 <Oeje1> Sweat.
10:35:26 <Oeje1> Sweet.
10:35:27 <autrijus> also, pugs can now work with arbitary perl6 code with inline haskell functions, which are reexported as p6 :)
10:35:35 <autrijus> which means inline C as well.
10:36:12 <autrijus> thanks to TH, Language.Haskell.Parser, DynamicLoader, and lots of other magics.
10:36:18 <autrijus> it's all done in one day! :)
10:36:28 <ibid> skew: there's a paper by iirc spj on parsing haskell-like operators using a standard LR parser
10:37:15 <skew> ibid: do you have any more detail
10:37:45 <skew> I've just realized that I dislike writing parsers
10:38:00 <skew> It's must more fun to build interpreters from the AST out
10:38:27 <ibid> skew:  it's rather old. i can try to look it up
10:41:11 <skew> "parsing distfix operators"?
10:41:35 <ibid> yeah
10:41:56 <ibid> infix operators are a special case :)
10:44:09 <skew> I found a paper on scholar.google.com about a special parser generator for handling user-defined operators, and they cited that
10:44:17 <ibid> anyway, a basic idea is to have expression: expression OP1 expression | expression OP2 expression | ... | expression OPn expression (with suitable fixity declarations for OPi in the grammar) and let the lexer remember which operators belong to which terminal symbol
10:44:35 <skew> that's exactly what I was thinking of doing
10:44:57 <ibid> when i do these kinds of grammars, i usually end up writing a recursive descent parser :)
10:45:09 <ibid> (because it's much easier to parametrize them)
10:46:35 <skew> The first paper talked about modifying a parser generator a bit to defer shift/reduce conflicts until runtime, then resolving them based on accumulated precedence information
10:47:10 <shapr> skew: excellent point
10:47:16 <shapr> about the missing category
10:48:24 <skew> I've seen this paper before. Now that I'm reading it again, I remember liking the trick the first time too.
10:48:45 <shapr> I try to explain formulate decisions via 'long term selfishness'.
10:56:37 <CosmicRay> hi shapr
11:00:56 <Igloo> CosmicRay: the experimental alpha buildd successfully built ghc 6.4, BTW. Now I think it's ready to go once sarge releases
11:00:58 <shapr> hiya CosmicRay
11:03:13 * shapr hops
11:03:21 * shapr hOps
11:03:36 <CosmicRay> hey shapr
11:03:39 <CosmicRay> ingy: slick
11:03:42 <CosmicRay> err
11:03:45 <CosmicRay> Igloo: slick :-)
11:03:59 <CosmicRay> Igloo: did someone patch the problem?
11:04:06 <shapr> I have a cold. I feel grotty.
11:04:10 <Igloo> Yes, me  :-)
11:04:11 * shapr throws lambdas at the evil germs.
11:04:15 <CosmicRay> shapr: that sucks
11:04:18 <CosmicRay> Igloo: ahh, thanks :-)
11:04:32 <CosmicRay> shapr: let's hope those germs aren't polymorphic.
11:05:08 <shapr> heh, good point.
11:05:38 * CosmicRay has a headache
11:05:58 <shapr> weak head abnormal form?
11:07:29 <CosmicRay> hm?
11:07:39 * CosmicRay suspects he didn't get the joke
11:08:00 <CosmicRay> incidentally, voip rocks
11:08:18 <skew> CosmicRay: hopefully a headache isn't your weak head's normal form :)
11:08:35 <CosmicRay> heh
11:08:42 <autrijus> aw aw.
11:09:54 <CosmicRay> these sipura phones that I bought can download their configuration via tftp, pretty slick.
11:10:02 <shapr> @foldoc "weak head normal form"
11:10:05 <lambdabot> *** "weak head normal form" foldoc "The Free On-line Dictionary of Computing
11:10:07 <lambdabot> (27 SEP 03)"
11:10:09 <lambdabot> Weak Head Normal Form
11:10:11 <lambdabot>      
11:10:13 <lambdabot>         <reduction, lambda calculus> (WHNF) A {lambda expression} is
11:10:14 <CosmicRay> I'm going to probably write a haskell tool to POST a dialing directory to them
11:10:15 <lambdabot>         in weak head normal form (WHNF) if it is a {head normal form}
11:10:17 <lambdabot>         (HNF) or any {lambda abstraction}.  I.e. the top level is not
11:10:19 <lambdabot>         a {redex}.
11:10:21 <lambdabot> [33 @more lines]
11:11:03 <shapr> Wow, I got mod points on slashdot. But I can't find anything worth modding up.
11:11:33 <CosmicRay> common problem, that.
11:11:37 <autrijus> shapr: my posts? :)
11:11:45 <shapr> autrijus: where are your posts?
11:11:52 <skew> I don't suppose you could post something yourself and mod it up.
11:11:59 <autrijus> shapr: http://it.slashdot.org/comments.pl?sid=142723&threshold=1&mode=nested&commentsort=5&op=Change
11:12:01 <shapr> skew: you don't get to both post and mod in the same discussion.
11:12:30 <skew> Tried to paste that link into firefox and got "shapr is not a registered protocol"
11:12:46 <CosmicRay> heh
11:12:46 * shapr snickers
11:14:12 <Lemmih> I invite you all to add features to the Hackage wish list!
11:14:15 <Lemmih> @wiki Hackage
11:14:16 <lambdabot> http://www.haskell.org/hawiki/Hackage
11:16:25 <Igloo> I think hosting of darcs repos and being the package repository are orthogonal
11:17:00 <Igloo> Why wouldn't we have darcs.haskell.org and hackage.haskell.org, seemingly separate even if run by the same people on the same machine?
11:17:13 <Darius> "This is why I enjoy Perl so much! When you can compile a language, with a compiler written in said language, you have something great."  I don't even think you need Turing completeness to do this.
11:17:23 <CosmicRay> Igloo: I agree
11:17:38 <CosmicRay> Igloo: people may also not use darcs for whatever reason
11:17:47 <Lemmih> Igloo: Just throwing out ideas.
11:18:06 <Igloo> No, you're throwing them in, I'm throwing them out  :-)
11:18:20 <skew> Darius: doesn't HQ9+ have something like that?
11:18:53 <Igloo> You should be able to search by module name (either complete or partial name)
11:19:46 <Darius> skew: I guess technically that would be a trivial form of compilation.
11:19:55 <Igloo> Show dependencies with links to things that satisfy them
11:20:16 <Igloo> Most of the functionality is basically obvious, I think
11:20:22 <skew> Darius: If you are talking about a language that isn't turing complete it's pretty much a trivial form of everything
11:21:24 <Igloo> http://packages.debian.org/unstable/devel/hat might provide inspiration for what the interface should look like
11:21:25 <Darius> Compilation simply requires a fold over the AST which doesn't require Turing-completeness and can be non-trivial.
11:21:35 <skew> At least for pretty large values of trivial - Epigram isn't turing complete
11:25:29 <det> Darius, I guess it is true.
11:25:34 <skew> wait, Pugs is supporting embedded C code via hs-plugins?
11:25:45 <skew> Reduce to the previously solved case, I guess :)
11:25:57 <det> Darius, Any idiot can get an account on slashdot :-)
11:27:41 <autrijus> skew: it does it via DynamicLoader
11:27:42 <Leimy> pugs is pretty interesting :)
11:27:49 <autrijus> not quite hs-plugins
11:33:08 <skew> Maybe I should look at perl sometime.
11:33:18 <skew> Is pugs the first perl6 interpreter?
11:33:51 * Darius was very surprised that Neel Krishnaswami made a trivial type error.
11:34:22 * shapr thinks about abstracting persistence and control flow with Haskell.
11:34:30 <shapr> Darius: on LtU?
11:34:51 <Darius> shapr: c.l.f
11:35:06 <Darius> CPS and Storable?
11:35:32 <autrijus> skew: yes.
11:35:38 <autrijus> skew: and it compiles perl6 to haskell.
11:35:49 <autrijus> (in additional to compiling to parrot)
11:36:00 <skew> I find that immensely entertaining, and encouraging
11:36:28 <shapr> So, a Pugs to Haskell interface is trivial? =)
11:38:08 <autrijus> yes.
11:38:16 <autrijus> skew: see my journal? :)
11:38:19 <shapr> _metaperl: hey, I thought of a cute bit of humor based on something you said earlier "A telepathic journal is totally mind-blogging." (you said mind-blogging)
11:38:27 <autrijus> http://use.perl.org/~autrijus/journal
11:38:31 <autrijus> skew: I've kept a diary since day 1.
11:38:38 <autrijus> today is the 52th day of Pugs.
11:38:43 <shapr> 52nd
11:38:57 <autrijus> thank you, but perl6 understands both 52th and 52nd.
11:38:58 <autrijus> :)
11:39:00 * shapr snickers
11:39:19 <autrijus> (that's in the spec, really.:-))
11:39:38 <Leimy> 52th!
11:39:41 <skew> where are the older entires?
11:40:00 <skew> nm, I just found the link
11:40:27 <Darius> Hey with Perl6 and inlineable Haskell we can still use Perl for the Evil Mangler and have it possibly not be Evil!
11:40:32 <shapr> btw, how do you annotate speech to clarify the difference between 1 and 0 based indexing?
11:40:49 <shapr> I tend to say it's the 5th from the 0th, but I wonder if there's something more sensible.
11:40:51 <skew> I don't know of any standard conventions
11:41:04 <skew> I could invent one for you :)
11:41:04 <Darius> shapr: You don't, because you don't need to, because 0-based is the One True Way!
11:41:06 <autrijus> Darius: yes, because you'll just write that and compile to haskell!
11:41:30 <shapr> Most of my clients don't understand the Zer0th True Way yet.
11:42:11 <shapr> Does this mean Pugs is recursively evil?
11:43:51 <shapr> hiya sysfault
11:44:16 <sysfault> howdy shapr
11:44:20 <sysfault> time to learn me some haskell.
11:44:23 <shapr> yeah!
11:44:29 <Leimy> haskell == good times
11:44:33 <shapr> Speaking of which, I have a commercial use of Pugs in mind already.
11:44:42 <Leimy> Pugly code
11:45:56 <Darius> shapr: What? Switch from Python to Perl to sneak in Haskell via inline?
11:46:21 <shapr> Darius: other way around.
11:46:37 <Leimy> Hython
11:46:44 <Leimy> Paskell
11:46:45 <Leimy> :)
11:47:05 <shapr> Switch from Python to Haskell, and then I can write Haskell, and clients who worry about hiring more developers can use p6
11:47:34 <skew> hmm, "perl6 is easier to learn than Haskell". Maybe I should learn perl sometime
11:48:18 <shapr> Zope offered Perl scripting at one point. A Zope replacement written in Haskell could offer Perl scripting easily.
11:49:35 <palomer> go haskell!
11:49:39 <palomer> could someone explain me what monads do
11:49:47 <palomer> I'm interested in the theoretical aspects of it
11:50:01 <CosmicRay> palomer: try http://www.nomaware.com/monads/html/
11:50:03 <Igloo> You can't call a language Paskell! I already get enough of "What language do you use?" "Haskell." "Oh, Pascal! I used to use that!"
11:50:13 <shapr> I like Paskalle even more.
11:50:15 <CosmicRay> hah
11:50:28 <palomer> I think that a theoretical interpretation could have profound implications in many areas
11:50:47 <shapr> palomer: could be useful in category theory even.
12:06:56 --- topic: '["http://haskell.org/learning.html","See logs http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! ICFP contest 2004","We put the Funk in Funktion","http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne"]'
12:06:56 --- topic: set by Darius on [Wed Mar 23 18:33:40 2005]
12:06:59 <palomer> Darius: more than an epimorphism? what's that supposed to mean?
12:07:08 <autrijus> skew: yes.
12:07:12 <autrijus> skew: see the interview.
12:07:19 <Darius> palomer: It's an embed-project pair.
12:07:23 <autrijus> skew: # http://www.perl.com/pub/a/2005/03/03/pugs_interview.html
12:07:33 <autrijus> I'm almost 3 months into haskell now :)
12:07:42 <skew> I saw the interview, that's where I got the idea that you had just learned Haskell.
12:07:48 <autrijus> yup
12:07:50 <skew> Why did you decide to build perl6 in it?
12:07:53 <Darius> palomer: And I meant calling it just an epimorphism would be akin to calling it just a morphism, it misses part of the point.
12:08:10 <sysfault> what's a good haskell introductory?
12:08:14 <autrijus> skew: because haskell r0x0rz for writing parsers and interpreters and compielrs
12:08:23 <wilx> :)
12:08:24 <Darius> sysfault: What languages do you know already?
12:08:25 <palomer> skew: in category theory for the working mathematician, maclane uses epsilon and eta
12:08:50 <skew> I mean, I think Haskell is a great language for building languages in, but I didn't expect somebody would realize that so quickly :)
12:09:04 <autrijus> skew: I bought TaPL and read it :)
12:09:04 <sysfault> Darius: a little python
12:09:06 <sysfault> bash&awk
12:09:18 <palomer> so unitM and buildM are epsilon and eta respectively?
12:09:19 <autrijus> it says clearly in TaPL that haskell or ML is the way to go :)
12:09:21 <Darius> \varepsilon is typically used for the counit of an adjunction.  skew was talking about the unit and multiplication of a monad.
12:10:14 <skew> autrijus: I read TaPL too, but I didn't really decide that Haskell was totally thoroughly awesome for building languages until I understood the relation between monads and language semantics
12:10:40 <autrijus> skew: oh. I realized that pretty early on :)
12:10:48 <autrijus> <- also bought category theory textbooks.
12:11:04 * skew bought some too but hasn't understood very much
12:11:11 <Darius> sysfault: www.haskell.org/learning.html has a variety of resources, but you may find Yet Another Haskell Tutorial best if you want something big and comprehensive.
12:11:24 <sysfault> ok great.
12:11:25 <autrijus> but maybe it's because I've been writing higher ordered perl for many years.
12:11:25 <sysfault> thanks
12:11:33 <palomer> do they have papers/books on the correspondence between categories and haskell/ml (apart from lambek's book)
12:11:38 <autrijus> so haskell just feels natural.
12:12:04 <skew> palomer: In my copy it seems to be mu and nu. It's the little u with a hangy-down on the left side, and an n with a longer leg on the right.
12:12:05 <Darius> "correspondence" in what way?
12:12:27 <palomer> skew: the long leg n is an eta
12:12:37 <Darius> \eta is the n thing, the v thing is \nu.
12:12:58 <Darius> skew: You can inline latex on HaWiki to see what they look like.
12:13:00 <skew> Darius: types (of kind * at least) = objects, functions (A - > B) = morphisms from A to B
12:13:29 <skew> no,\nu is the curvy v thing. I mean a u with a long downstroke on the left, which I think is \mu
12:13:43 <skew> in any case, it isn't epsilon
12:13:44 <Darius> skew: Yes
12:13:50 <palomer> skew: yes, but we're discussing eta
12:13:56 <palomer> which you said is nu
12:14:18 <skew> palomer: you said the natural transformations in the triple were epsilon and eta, I thought. I'm saying that my copy uses mu and eta
12:14:34 <palomer> I never talked about triples
12:14:34 <skew> not tat it really matters, but it sounded like you were asking if there was some standard notation
12:14:45 <skew> triple = monad
12:14:46 <palomer> skew: you said mu and nu~
12:14:47 <palomer> !
12:14:48 <Darius> skew: That correspondence isn't very interesting unless you describe more of the structure, even then it isn't particularly special, my question was was that it or what about category theory applied to data types etc.
12:14:52 <skew> oh
12:15:22 <skew> Darius: oh, there's that one too. Have you read Comonadic Recursion Schemes?
12:15:29 <palomer> Darius: correspondence in the loosest sense of the term
12:15:42 <Darius> skew: Yes and rederived some of it too.
12:15:50 <skew> plus there's all kinds of stuff about polynomial functors
12:16:16 <Darius> And polymorphic languages are typically talked about in terms of fibrations.
12:16:19 <skew> autrijus: Haskell was my second functional language, after Unlambda
12:16:21 <palomer> it seems that unitM simply evaluates
12:16:32 <Darius> However, little of this is ML or Haskell or even functional specific.
12:16:51 <autrijus> skew: eww Unlambda.
12:16:53 <autrijus> Lazy K is the way!
12:17:14 * Darius agrees with autrijus there.
12:17:18 <palomer> like, the relation between adjoints and monads
12:17:20 <palomer> for example
12:17:34 <skew> palomer: I agree if you are saying that unitM gives you the computation that just has a value without needing to do any "computational" work, for whatever value of "computation" your monad expresses.
12:17:57 <Darius> Or banish syntax errors with Jot.
12:18:13 <palomer> without monads, haskell wouldn't be able to compute anything, right?
12:18:22 <palomer> weak head reduction doesn't get us very far
12:18:26 <Darius> palomer: Haskell existed before it had monads.
12:18:32 <autrijus> you can use continuation-based io
12:18:35 <autrijus> lazy stream io
12:18:36 <Darius> weak head reduction gets you turing completeness.
12:18:41 <skew> not quite. There are some built in operators and things. You can still evaluate a program to a result
12:18:42 <autrijus> and other weirdo constructs.
12:19:03 <musasabi> evening
12:19:03 <palomer> skew: oh? how would you evaluate without monads?
12:19:11 <skew> 1 + 1 => 2, etc
12:19:34 <skew> monads are used to get IO and referential transparency
12:19:47 <autrijus> palomer: you can evaluate "main" to a list of "requests"
12:19:48 <Darius> monads are used to -structure- IO
12:19:50 <palomer> (+ 1 1) is in weak head normal form, it shouldn't get evaluated
12:19:53 <autrijus> and take as an argument a list of "responses"
12:20:02 <autrijus> both are evaluated lazily
12:20:11 <Darius> palomer: No it isn't.
12:20:12 <autrijus> so as long as you generate the request before evaluating the response
12:20:15 <autrijus> then you can do I/O.
12:20:54 <palomer> Darius: fine
12:21:12 <skew> IIRC, the denotation of a value in type IO a is a "description of a side effecting computation", so in some sense a Haskell program evaluates in a pure functional way down to a single value of type IO (), and then the interaction with the world that that value represents is performed
12:22:21 <palomer> could someone explain the lazy call/cc?
12:22:33 <Darius> What lazy call/cc?
12:22:33 <skew> palomer: it's just cps
12:22:40 <palomer> it's really odd
12:23:03 <skew> what is odd?
12:24:07 <palomer> it's .\f\mu alpha [alpha] f (.\x \mu delta [alpha] x)
12:24:17 <palomer> (in lambda mu calculus)
12:24:43 <palomer> hrm, seems noone has an answer to this
12:25:01 <skew> what is the mu in the mu calculus?
12:25:11 <Darius> You haven't/hadn't really asked a well defined question.
12:25:27 <palomer> I don't see how this corresponds to the strict call/cc
12:25:35 <skew> palomer: I said that call/cc in Haskell is obtained from the usual CPS transform.
12:25:49 <Darius> palomer: Is it supposed to?
12:26:20 <Darius> Or in what way does it "not correspond" or what do you mean by "correspond"?
12:28:08 <palomer> (.\mu alpha [beta] t)x = .\mu alpha [beta] t [[alpha] u x / [alpha] u]
12:28:39 <palomer> I'm used to the good ol scheme call/cc where the current continuation is caught and passed around
12:29:13 <Darius> palomer: That's what the above does.
12:29:29 <palomer> .\mu alpha [beta] t takes an x and then replaces all occurences of [alpha] u with [alpha] u x
12:29:38 <palomer> in t
12:30:10 <palomer> hrm
12:30:37 <palomer> I don't see how lazy call/cc catches the current continuation
12:30:48 <palomer> and then passes it to f
12:30:54 <Darius> \mu k. k is the current contination.
12:31:52 <palomer> .\mu k.k is my .\mu alpha [alpha] ?
12:33:30 <Darius> More or less yes.  call/cc in CPS is \f k.f (\v k'.k v) k which is pretty much identical to the lambda-mu.
12:33:35 <palomer> and I don't see how that's the current continuation
12:34:21 <skew> palomer: do you see how that works in the CPS version?
12:34:47 <skew> palomer: I'm reading about this lambda-mu calculus right now, so hopefully I'll be able to talk in your terms soon
12:37:30 <skew> palomer: okay, I think I get it now.
12:38:01 <skew> What's strange about .\f\mu alpha [alpha] f (.\x \mu beta [alpha] x)?
12:38:44 <Igloo> Is there a good example of a language that does type checking rather than type inference?
12:39:02 <Darius> Igloo: Practically all statically typed languages (???)
12:39:35 <Igloo> Such as?
12:39:58 <skew> it takes the function f to be call/cc'd. Then it names the current continuation alpha, and evaluates under that continuation the application of  f to a function that takes an argument and returns it to continuation alpha
12:40:02 <Darius> Java, C, C++, Pascal, Oberon, Ada, Modula, etc.
12:41:34 <skew> Those languages do some amount of type inference, if you count keeping track of the types of subexpressions based on the previously-declared types of variables and functions
12:42:00 <Igloo> Hmm, I guess o
12:42:12 <Darius> skew: I don't count it.
12:42:17 <Igloo> thanks
12:43:55 <Darius> Actually, C++ can be consider as having some degree of type inference.
12:45:20 <Igloo> Well, they all(?) do magic with things like numbers that blur the distinction for the sort of tiny example I want
12:46:35 <Darius> That's overloading not inference.  Also, I don't think Pascal does.  Not sure about Ada, Oberon and Modula.
12:47:59 <Igloo> Yeah, but it makes it harder to write something that clearly shows the difference
12:53:32 * Igloo sidesteps the issue  :-)
12:54:31 <Darius> By not using numbers in the example(s).
12:55:04 <shapr> musasabi: btw, what do you think about my suggestion on the alioth shootout list?
12:58:41 <shapr> hiya Matt-W_
12:59:40 <det> shapr, I dont see any mail from you on the shootout-list
13:00:06 <shapr> I posted via gmane, probably will take five mins or so.
13:00:26 <det> wierd, I just posted as well :-)
13:00:35 * shapr hugs gmane
13:00:40 <shapr> I must donate to gmane, they're so cool.
13:02:05 <xerox> What's gmane? :)
13:02:32 <shapr> gmane.org
13:05:37 <det> shapr, my posts take several hours to appear on the shootout list, maybe it is moderated by busy moderators.
13:06:57 <shapr> could be
13:07:25 <shapr> I suggested that 'code as literature' might be a better benchmark.
13:08:30 <det> You mean, idiomatic code before fast code?
13:08:42 <shapr> Yes, code as communication.
13:08:49 <xerox> How to unsubscribe the mailing lists?
13:08:56 <shapr> xerox: which mls?
13:09:14 <xerox> haskell@ and haskell-cafe@, using gmane I can avoid deleting tons of mails!
13:09:43 <shapr> xerox: http://www.haskell.org/mailman/listinfo/haskell
13:11:00 <musasabi> shapr: didn't see it when I checked mail a while ago.
13:11:18 <musasabi> shapr: when I get to my machine from bed, I'll look whether it has arrived.
13:11:30 <shapr> ok
13:11:35 <shapr> from bed?
13:12:08 <musasabi> yes.
13:12:24 <det> shapr, Interesting viewpoint from a Haskeller. I frequently see Haskellers tailoring code to GHC in order to get very good performance :)
13:12:41 * musasabi has an old machine which serves as firewall near the bed, and it has a console, so I can irc when lying down.
13:12:48 <shapr> neat :-)
13:13:07 <det> musasabi, When is the nueral implant being installed?
13:13:19 <shapr> greetings cybertnt
13:13:23 <Cybertnt> Hey
13:13:25 <_metaperl> shapr, re: mind-blogging. someone said that in response to a type declaration... I didn't say it
13:13:31 * Cybertnt throws a bone to asmodai :D
13:13:31 <_metaperl> i just got back
13:13:37 <xerox> Great.
13:13:46 <shapr> _metaperl: in any case, it's a cute word, and spawned a cute joke.
13:14:16 <Cybertnt> Does anybody know if it is possible to bit shift with haskell?
13:14:17 <_metaperl> ok
13:14:25 <shapr> Today I've been called a Haskeller and an academic. Where's the e-prime people?
13:15:19 <shapr> det: I explained it in the post, but the essence of my point is that source code is primarily communication with humans, and only secondarily communication with computers. (like the cute signoff msg araujo has)
13:15:24 <Cale> Cybertnt: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Bits.html
13:16:06 <Cybertnt> Thanks Cale, i finished the Turing Machine, thanks again for your help :D
13:16:12 <det> I agree with out, however, where do you draw the line?
13:16:23 <shapr> What line?
13:16:24 <det> s/out/you/
13:17:17 <shapr> Oh, 'how do you prioritize communication computers?' My clients complain if something is too slow :-)
13:17:25 <det> program A is most clear, program B is very slightly less clear and scores 1.5x, program C is very much less clear but scores ...
13:17:44 <skew> det: just as ugly as it needs to be to run fast enough
13:17:46 <shapr> I'd choose the Burstall & Darlington solution.
13:18:01 <skew> where "fast enough" is decided by the people with the money
13:18:14 <det> skew, I am talking about the shootout :)
13:18:19 <skew> oh
13:18:39 <skew> Why not have many entries?
13:18:41 <shapr> I think skew's solution is right for the shootout too.
13:18:56 <skew> or at least a fast haskell/pretty haskell split
13:19:39 <skew> I'm sure Haskell could makes the tops of the speed lists and the clear code lists, if maybe not with the same programs
13:19:44 <musasabi> shapr: sorry, just checked mail and it is still not there.
13:20:11 <shapr> The Burstall & Darlington  solution is 'if possible, automate the transformation from pretty ugly such that you only write the pretty version and the compiler makes the ugly version for you' 'if that's not possible, write the pretty version and make it the specification, and hide the fast ugly version lower in the same file'
13:20:33 <musasabi> Two largest problems with haskell in the shootout are 1) IO+show/read, 2) arrays.
13:20:38 <shapr> The Rabhi & Lapalme book on functional algorithms does that, it's great.
13:21:13 <shapr> musasabi: I'll ask you tomorrow then :-)
13:22:07 <det> I think pretty and fast sections for the shootout is a great idea.
13:22:49 <Darius> shapr: Better would be to add QuickCheck (or other) annotations between the specification and (actual) implementation asserting their equality.
13:23:20 <shapr> That's a good point, though it leaves out the languages that don't have a QC implementation.
13:23:32 <shapr> Darius: btw, do you know how to use QCm to do IO testing?
13:24:05 <Darius> I haven't really looked at it and certainly haven't looked at it anytime recently.
13:24:39 * musasabi would like to have qcM too.
13:25:07 <shapr> I'll send a mail to Koen Claessan and John Hughes.
13:25:22 <musasabi> although I have static assertions that are automatically run on compile :-)
13:25:51 <xerox> shapr: do you use gmane with gnus?
13:25:54 <shapr> xerox: yup
13:25:59 <_metaperl> I do
13:26:10 <xerox> Opening nntp server on nntp://news.gmane.org...failed
13:26:16 <xerox> Do you know what can be the cause?
13:26:20 <shapr> How can you mix TH and QC?
13:27:00 <shapr> Maybe your ISP is blocking the port? Can you try to telnet to the nntp port?
13:27:29 <xerox> 200 news.gmane.org InterNetNews NNRP server INN 2.4.1 ready (posting ok).
13:27:35 <Darius> shapr: Easily, except that the script which works by string searching if I understand correctly won't necessarily do what you want, depending on what you're doing.
13:27:37 <xerox> Seems working
13:28:14 <Darius> But of course, you should be able to generate tests and run them at compile-time with TH.
13:29:47 <musasabi> shapr: well I have staticAssert in TH which check that a single expression evaluating to a Bool is true (could be equally well IO Bool)
13:30:17 <xerox> _metaperl: any ideas?
13:30:37 <xerox> (setq gnus-select-method '(nntp "news.libero.it"))
13:30:38 <xerox> (add-to-list 'gnus-secondary-select-methods '(nntp "nntp://news.gmane.org"))
13:31:05 <_metaperl> no ideas... is gmane down?
13:31:47 <CosmicRay> xerox: looks like gnus doesn'tw ant a url
13:32:02 <xerox> Oh RIGHT.
13:32:24 <xerox> Silly me.
13:33:40 <Cybertnt> Cale: it doesnt work :( i loaded the module and tried "xor 1 2" but it just outputs a Unresolved overloading error
13:34:07 <Darius> @type Data.Bits.xor (1 :: Int) 2
13:34:08 <lambdabot> Data.Bits.xor (1 :: Int) 2 :: Int
13:34:12 <Darius> @type Data.Bits.xor
13:34:13 <lambdabot> Data.Bits.xor :: forall a. (Data.Bits.Bits a) => a -> a -> a
13:34:33 <Darius> @type Data.Bits.xor 1 2 :: Integer
13:34:35 <lambdabot> Data.Bits.xor 1 2 :: Integer :: Integer
13:34:39 <Cale> Cybertnt: make sure that the number type is fully specified
13:35:33 <Cybertnt> Cale: how do i do that :/ ?
13:36:47 <Cale> Cybertnt: by specifying a type explicitly with :: or doing things in such a way that type inference will give a specific type for the numbers passed in
13:37:38 <Cybertnt> hmm what type does it have to be?
13:38:03 <Cybertnt> it doesnt like Int/Intger
13:38:05 <Cybertnt> *Integer
13:39:00 <Darius> :info Bits should say what classes (in scope) are instances of Bits (if you are using GHC 6.4)
13:39:05 <Darius> or I think Hugs.
13:39:24 <Cybertnt> xor :: a -> a -> a
13:39:28 <Cybertnt> doesnt that mean any ?
13:39:38 <Darius> @type Data.Bits.xor
13:39:39 <lambdabot> Data.Bits.xor :: forall a. (Data.Bits.Bits a) => a -> a -> a
13:40:24 <Cybertnt> hehe, well i doent understand what lambdabot tries to tell me :/
13:41:01 <Darius> The 'Bits a =>' part says that 'a' has to be an instance of Bits.
13:41:23 <Cybertnt> ok
13:41:48 <Cybertnt> it says ERROR - Undefined type constructor "Bits" though
13:42:23 <palomer> back
13:42:51 <palomer> Darius: hoho, but weak head reduction is not CPS
13:43:08 <palomer> skew: I don't exactly see how it works in cps version
13:43:26 <Darius> palomer: I never said it was and don't see what that has to do with evaluation.
13:43:45 <palomer> holy crap I'm lagged
13:43:51 <Darius> In fact, I'm not even sure why you are mentioning them together.
13:44:40 <palomer> CPS[[call cc]]k = that function which you mentioned earlier (I don't completely understand CPSification yet)
13:44:41 <skew> palomer: In CPS context are explicitly represented as functions. Each expression and function is transformed to take an extra argument, which represents its continuation, and any expression that just evaluated to a value before now applies the continuation to that value
13:45:01 <palomer> skew: right, I understand that part
13:45:15 <palomer> and I can CPS transform things by hand
13:45:29 <palomer> however, I don't yet quite grasp the systematic transformation
13:45:33 <palomer> which is:
13:46:01 <skew> so \f \k . f (\x k' . k x) k is taking the current continuation, and passing it to a normal argument of f
13:46:13 <palomer> CPS[[.\x t]]k = k .\x.\k' CPS[[t]]k'
13:48:24 <palomer> CPS[[x]]k = k x
13:48:24 <palomer> crap, I don't remember application
13:48:25 <palomer> lemme look it up
13:49:09 <palomer> lagging too much to look it up
13:50:25 <Darius> palomer: Do you grasp systematically transforming code to monadic style?
13:51:24 <skew> I think apply is CPS[[a b]]k = .\k' CPS[[a]] (.\f CPS[[b]] (.\x (f x) k))
13:51:27 <palomer> Darius: that I do not, I don't grasp monads whatsoever
13:51:47 <palomer> skew: right, so I know the rules, but I don't understand yet why they work
13:52:51 <palomer> indeed, I'm not even at the point of proving that CPS[[t]]I = t  (beta/eta) (in fact, I don't even know if its true)
13:52:56 <Darius> palomer: Does, [[x]] = return x;[[f x]] = do f' <- f; x' <- x; return (f' x');[[\x.e]] = \x.[[e]] make intuitive sense?
13:53:36 <palomer> Darius: this is another transformation?
13:53:55 <palomer> I don't understand application
13:54:00 <Darius> palomer: Yes and no.  You can just think of it as a Haskell function
13:54:25 <palomer> oh, I don't know the do syntax
13:54:35 <palomer> I've been living in lambda calculus land for the past 3 months
13:55:24 <skew> okay, then [[f x]] = [[f]] >>= (.\f' [[x]] >>= (.\x' return (f' x'___
13:55:35 <palomer> what the
13:55:47 <palomer> [[f x]] = return (f x) <--this is what you mean?
13:56:03 <skew> where m >>= f is join (fmap f m)
13:56:34 <skew> palomer: no, the idea is to put the monad on all the result types
13:56:47 <palomer> skew: I don't understand monads yet
13:57:05 <skew> did you look at that paper I mentioned?
13:57:11 <palomer> skew: yeah
13:57:19 <palomer> it seems as though it's simply a way to evaluate
13:58:47 <palomer> (which makes sense, since how would you print (\abcdef. 4) without being able to evaluate the  arguments)
13:59:03 <skew> what do you mean by evaluate?
13:59:54 <skew> Monads are a convenient way of writing down the evaluation rules of any language you like inside of Haskell, but they have nothing to do with the rules for evaluating Haskell itself
14:00:03 <palomer> make that (\abcdef. 4) 0 0 0 0 0 0
14:00:23 <skew> Haskell is a lazy functional language.
14:00:36 <skew> So that evaluates just like you would expect in a call-by-name lambda calculus
14:01:08 <palomer> I'm lagged to beejeezus
14:14:03 <TheHunter> so, where can I read about the "lazy call/cc"?
14:14:33 <palomer> TheHunter: plotkin wrote about it, I think
14:15:10 <Darius> palomer: Are you sure you aren't thinking the call-by-name continuation passing transform?
14:15:11 <palomer> skew: so how would you print (\abc.4) 0 0 0+
14:15:12 <palomer> ?
14:15:16 <palomer> s/+/?
14:15:38 <Darius> 4
14:15:59 <palomer> Darius: we worked out in class a term with type ((A->B)->A)->A, and got the lambda mu term I gave above
14:16:19 <Darius> Yes, but what does laziness have to do with it.
14:16:35 <palomer> which the teacher then claimed was call/cc
14:16:35 <palomer> puzzled, I confronted him in his office
14:16:35 <palomer> he told me it was the lazy call/cc
14:17:43 <palomer> print ((\abc.4) 0 0 0) <--this is in weak head normal form (not knowing what print does)
14:17:55 <palomer> see, print knows nothing about its argument
14:18:14 <palomer> it could be a number or an application, who knows?
14:18:55 <Darius> That's only in weak head normal form if print doesn't reduce.  If it doesn't reduce, then it is essentially a data value.
14:19:11 <palomer> how is print supposed to know if its supposed to reduce?
14:19:49 <palomer> given a print_int that takes an integer and prints it, how would I make a general print function?
14:19:59 <Darius> palomer: It doesn't "know", it is either defined to (a \delta-rule) or it isn't.
14:20:33 <Darius> palomer: There is no general print function, something of type forall a.a -> String means it doesn't use 'a' by parametricity.
14:20:38 <palomer> delta rule?
14:21:04 <Darius> palomer: An "application" or "language" specific reduction, like 1+1 -> 2.
14:21:27 <Darius> I.e. a grab bag term for "not beta,eta,alpha reduction"
14:22:04 <palomer> when I say general print function, I mean a print function that takes either an int or an application that reduces to an int and prints it
14:23:03 <Darius> palomer: Primitives are usually taken to be strict, at any rate something has to force something at some point.
14:23:03 <mattam> alpha reduction ??
14:23:16 <palomer> mattam: renaming bound variables
14:23:28 <palomer> Darius: right, at which point is something forced?
14:23:44 <palomer> is there a way to tell haskell to force something NOW?
14:24:03 <palomer> or are things forced only for certain primitive functions?
14:24:12 <mattam> well conversion seems more appropriate as as a reduction it wouldn't terminate ...
14:24:23 <Darius> palmor: When it is needed, and yes, and technically yes for the last.
14:24:38 <Darius> palomer: Except that application forces it's first argument.
14:25:00 <palomer> Darius: right, weak head reduction
14:25:13 <Darius> mattam: conversion is usually used, but there's nothing wrong with it being a reduction.
14:25:33 <Darius> mattam: You don't typically reduce to "alpha normal form"
14:25:39 <palomer> mattam: untyped lambda calculus isn't strongly normalizable by beta reduction
14:25:49 <mattam> i know palomer
14:25:58 <palomer> in fact, the terms can even grow indefinitely by beta reduction
14:26:05 <palomer> mattam: so the reduction doesn't terminate
14:26:31 <mattam> but no calculus would be even normalizable if it had alpha as a reduction rule
14:26:36 <palomer> Darius: so haskell isn't totally lazy, it's lazy until you meet the FFI, right?
14:26:57 <palomer> mattam: you'd have to define alpha normal form
14:27:08 <palomer> which I could see done, given a mapping from N to the space of variables
14:27:21 <TheHunter> ok, i've found okasaki, lee, tarditi "call-by-need and continuation-passing style"
14:27:30 <mattam> ok, i see your point
14:27:40 <palomer> TheHunter: call-by-need is something different
14:28:17 <palomer> Darius: getting back to CPS, why does it work?
14:28:22 <Darius> palomer: Haskell isn't totally lazy, but it's not because of the FFI.  But even in a "fully lazy" language you have to evaluate something when you need it, e.g. the function in an application term.
14:28:25 <TheHunter> palomer, i'd say, lazy is something different.
14:28:58 <palomer> TheHunter: difference is symmetric
14:29:36 <palomer> Darius: could you explain CPSification and CPSification in terms of lazy evaluation?
14:29:38 <Darius> palomer: What do you mean by "work"?  It isn't a process it's a style.
14:29:42 <palomer> it would give me the biggest eureka
14:29:50 <palomer> (eurekas is why I'm a theoretician)
14:30:19 <Darius> palomer: CPS doesn't have anything to do with lazy evaluation in one respect.  Whether the language is lazy or not is irrelevant both before and after CPS transform.
14:30:22 <palomer> I meant CPSification
14:30:43 <palomer> Darius: oh, but the transforms are different
14:31:03 <Darius> Yes, there is a call-by-name CPS transform and a call-by-value one.
14:31:19 <palomer> much different
14:31:19 <palomer> in call-by-name, you don't even need to know the environment to CPSify
14:31:55 <Darius> You don't need an environment to perform any CPS transform.
14:32:29 <palomer> CPS[[t]]k <--transform term t in continuation k
14:32:35 <palomer> (I call k the environment)
14:32:48 <palomer> that's the call by value transform
14:33:00 <palomer> in the call by name transform, you don't need to know the environment
14:33:09 <palomer> but lets start by the call-by-value transform..why does it work?
14:33:13 <Darius> You need to specify an initial continuation no matter what CPS transform you do.
14:33:40 <Darius> palomer: You still haven't defined "work".  It doesn't work, it just transforms something.
14:34:07 <TheHunter> ok, i'm confused. What's the common meaning of lazy? call-by-need or anything that's not call-by-name?
14:34:14 <palomer> not according to my prof
14:34:24 <palomer> he gives the transform irrespective of the continuation
14:34:52 <Darius> TheHunter: The -common- usage is both, more strictly it's usually understood to be call-by-need.
14:34:57 <palomer> CPS[[x]] = \u. x u
14:35:50 <palomer> CPS[[\x.t]] = \u.(CPS[[t]] [pi_1 u/x]) (pi_2 u)
14:35:53 <TheHunter> Darius, i expected something like that, thanks.
14:36:05 <Darius> palomer: He's just writing CPS[[x]] = \u.x u instead of CPS[[x]]u = x u
14:36:25 <Darius> Much like you can write f = \x -> x or f x = x in Haskell.
14:36:32 <palomer> CPS[[t u]] = \v(CPS[[t]])<CPS[[u]],v>
14:36:51 <palomer> CPS[[[alpha]t] = CPS[[t]] alpha
14:37:11 <basti_> hi
14:37:33 <palomer> CPS[[\mu alpha.n]] = \alpha. CPS[[n]]
14:37:44 <palomer> pis are projections
14:37:52 <palomer> <..,..> is pairing
14:38:17 <wilx> Huh, you are still talking about that?
14:38:18 <palomer> that, according to my prof, is CPSification
14:38:23 <palomer> it completely mystefies me.
14:38:44 <Darius> palomer: That's translating the lambda-mu calculus into the lambda calculus with products.
14:40:13 <palomer> TheHunter: lazy is weak head reduction
14:40:39 <palomer> Darius: right, why is CPS[[t]] = t in some reduction scheme
14:40:50 <palomer> (for call by value, CPS[[t]]I = t
14:42:02 <palomer> Darius: the fact that the continuation is not specified astounds me
14:42:32 <palomer> and CPS[[x]]u = u x
14:43:46 <TheHunter> anyone got an idea what's with gv not working correctly anymore for quite some time now under debian unstable. Is that just a bug or some kind of religious crap?
14:44:29 <palomer> anyways, lets get back to the call by value case. I've been told that the continuation represents the environment (which I'm willing to swallow), so how does CPS[[t]]k relate to t? what do they have in common?
14:45:14 <Darius> What is your definition of the "call-by-value" translation of the lambda-mu calculus into the lambda calculus with products.
14:46:20 <palomer> stallman has decided that things working was against the spirit of open source
14:46:43 <wilx> :)
14:49:19 <RemiTurk> hi all
14:49:24 <shapr> greetz
14:52:12 <palomer> I gave the definition
14:52:38 <palomer> I can give you tons of logical properties
14:53:04 <palomer> ie if t is of type A, then CPS[[t]] is provable in intuitionistic logic iff A is provable in classical logic
14:53:22 <shapr> TheHunter: gv works for me with debian/unstable
14:54:09 <TheHunter> shapr, for quite a lot of ps's, i don't see the page numbers on the left and i can't move to previous pages.
14:54:58 <TheHunter> for example: http://research.microsoft.com/users/dtarditi/dist/call-by-need.ps
14:55:23 <Darius> palomer: You have only (recently) given the definition for what you call the "call-by-need" version.
14:55:24 <palomer> the type of CPS[[t]]
14:55:38 <TheHunter> and converting to pdf doesn't really help either since it just looks awful then.
14:56:15 <mattam> maybe downgrade version
14:56:50 <shapr> TheHunter: yes, I see the problem with that paper, not sure why it happens.
14:57:43 <TheHunter> yep, happens with a lot of papers and is really annoying.
14:58:03 <palomer> that was call-by-name
14:59:19 <palomer> or at least, it is claimed to be call-by-name CPSification
14:59:44 <palomer> Darius: you do you mean the actual continuation passing style? isn't it identical to the call by value one
14:59:54 <palomer> where every function takes a continuation as its last argument
15:01:17 <palomer> and the last call is a call to that function
15:01:54 <Darius> palomer: If that is the "call-by-name CPSification" then what is the "call-by-value" one?
15:02:43 <palomer> if call-by-name changes the actual style, then I'm all ears
15:03:58 <Darius> That "call-by-name CPSification" is not a standard CPS transform, in fact, I don't believe it's a CPS transform at all.
15:04:12 <Darius> Or at least I'm not sure.
15:04:17 <musasabi> shapr: What approach do you think would work best for integrating SerTH and the LZF compression?
15:05:14 <musasabi> I could just hack-up support for it, but it is really just one special case of a more generic pattern of a mutator in a stream. (and if one wants to later add e.g. encryption)
15:09:26 <palomer> what do types represent in CPS?
15:10:27 <Darius> palomer: The CPS transform is a "source to source" translation, the types are transformed as well but they are still in the same language and mean the same thing.
15:11:45 <shapr> musasabi: first thought is to do something with a container, or something like cStringIO. But those are still mutators in a stream. Possibly stepcut's various stream arrow attempts or Peter Simons' i/o libs can provide inspiration?
15:12:15 <shapr> musasabi: I wonder, can it be a monad transformer?
15:12:48 <musasabi> not really.
15:13:25 <musasabi> shapr: basically you use the parameters to create a value wich is needed as a paramater for the run function of the monad.
15:13:31 <shapr> Darius: do you have time for a round or two of idea tennis?
15:13:58 <musasabi> shapr: lzfEncoder :: Encoder -> IO Encoder, and serializatio uses Encoders.
15:14:47 <Darius> shapr: Sure.
15:14:48 <TheHunter> anyone aware of something that can make pdfs converted from ps's look good?
15:15:11 <Igloo> How are you making the ps?
15:15:26 <TheHunter> ps2pdf.
15:15:34 <Igloo> No, the ps
15:16:08 <shapr> musasabi: ah, now I see the Encoder type.
15:16:09 <TheHunter> heh, i'm not making it. Usually (old) papers are of that kind.
15:16:54 <Igloo> Ah, can't help then
15:17:16 <palomer> Darius: where did you learn all you know?
15:17:16 <palomer> you a prof?
15:17:22 * shapr grins
15:17:36 <Darius> palomer: The Internet.
15:17:41 <TheHunter> oh, sometimes it's simple. gv can view pdfs made from corrupted ps's find. That's good enough for me.
15:17:43 <TheHunter> Thanks.
15:17:45 <basti_> TheHunter: actually its a hinting problem, i think
15:17:49 <shapr> Darius PhD
15:18:48 <palomer> I've had to come to paris to know a little about this (I'm learning about other things which touch upon this)
15:18:57 <fivemack> Good evening, everybody
15:19:01 <shapr> Greetz Mack
15:19:25 <shapr> palomer: I just read a bunch and asked questions to learn what I know.
15:19:31 * fivemack is here to ask the classic newbie question "but how do I use the result to generate a .PNG file?"
15:19:37 <Oeje1> xerox: Did you get Gmane to work with Gnus?  If so, what did you write in your .emacs?
15:19:57 <shapr> fivemack: what result?
15:19:57 <palomer> <palomer> CPS[[.\x t]]k = k .\x.\k' CPS[[t]]k'
15:19:57 <palomer> <palomer> CPS[[x]]k = k x
15:20:03 <fivemack> I assume there's some better way than keeping a 640*480-long list of pixels and modifying it incrementally
15:20:26 <palomer> <skew> I think apply is CPS[[a b]]k = .\k' CPS[[a]] (.\f CPS[[b]] (.\x (f x) k))
15:20:38 <fivemack> shapr: in this particular case, I've got an enumeration of polyominos as a list of lists of offsets, and want to produce a file with pictures of them
15:20:49 <palomer> I don't think skew's rule is correct
15:20:56 <musasabi> The cairo binding maybe?
15:21:19 <Darius> palomer: That's the standard call-by-value transform of application.
15:21:30 <Igloo> fivemack: The easiest way to create a png file is to create a ppm file (man ppm) and then use something else to convert that
15:21:36 <fivemack> I can imagine the Ultimately Nasty Kludge way of doing it, full of [X!!a | a <- enumFromTo(0,lots)] ++ [pixel] ++ [X!!a | a <- enumFromTo(lots+1, end)]
15:21:40 <palomer> the transform I gave isn't a CPS transform?
15:21:52 <palomer> quite possible, but my teacher was adamant
15:22:16 <fivemack> Igloo (ah, haven't I seen you before somewhere?): that I know, but how do I work with the array of pixels that at the end will be hideously putStrLn'd to the ppm file?
15:23:02 <fivemack> Or are arrays obsolete in the brave new functional world, and I actually want some uberdatastructure which happens to have O(log N) time to change one value
15:23:06 <Igloo> take lots X ++ [pixel] ++ drop (lots+1) X is less hideously inefficient, but still hideously inefficient if you are going to do it a lot
15:23:21 <palomer> my god I was lagged
15:23:29 <Igloo> What are you actually trying to do?
15:23:46 <fivemack> oh, is [X!!a | a <- enumFromTo(0, N)] going to take O(N^2) ?
15:23:54 <Igloo> Yes
15:24:10 <palomer> Darius: what's the current question? you don't like my "call-by-name" cpsification?
15:24:29 <Igloo> enumFromTo 0 n   incidentally, nicer written as   [0..n]
15:25:22 <Igloo> If you really do need to update things a lot then you probably want either a DiffArray or a mutable array in the ST monad
15:25:52 <Igloo> But the nicer approach in the functional world would be to just create the list you actually want in the first place, if that is possible
15:25:54 <fivemack> I'm not sure I'll ever be updating a particular location more than once, at least not in this model
15:25:58 <Darius> palomer: I want to see the "call-by-value" "CPSification" for comparison as you are not talking about (standard) CPS transforms.
15:26:04 <Darius> @wiki CpsTransform
15:26:04 <lambdabot> http://www.haskell.org/hawiki/CpsTransform
15:26:15 <palomer> palomer: That's the standard call-by-value transform of application.
15:26:17 <Darius> covers the typical call-by-value and call-by-name CPS transforms.
15:26:18 <palomer> I gave you it!
15:26:23 <fivemack> 'the list you actually want' being the 640*480-entry one?
15:26:29 <Igloo> Yup
15:26:33 <palomer> <Darius> palomer: That's the standard call-by-value transform of application.
15:27:03 <fivemack> OK.  I can produce easily the list of the locations of the pixels I want to set, in a sorted way.
15:27:24 <palomer> Darius: the three rules which I repasted
15:27:31 <Darius> palomer: I want the transformation that includes \mu and [a], you have only given ONE that you describe as "call-by-name", you haven't given an equivalent you've just quoted skew's remarks which ARE NOT ABOUT lambda-mu.
15:27:57 <palomer> Darius: oh, I only know the call-by-name CPSification
15:28:04 <ibid> a spammer seems to have found haskell sequence?
15:28:04 <palomer> I am, however, just repeating my prof
15:28:11 <Igloo> fivemack: I'm missing something. Where do the values you want to set come from? Why can't you just put them in a list and have that by your answer?
15:28:19 <fivemack> Do I then want to put together the list deliberately as, say, concat [map (take (fst a) repeat (snd a)) runlengths]
15:28:56 <fivemack> because the answer I want is a .PPM file, and the values I have at the moment are the coordinates of the pixels to set to create such a file
15:29:32 <fivemack> am I being obtuse?
15:29:42 <Igloo> Ah, so you mean you have [(3, 5), (4, 6)] and you want the ppm file with those two pixels red?
15:30:57 <fivemack> precisely
15:32:13 <KrispyKringle> anyone here use WASH much?
15:32:58 * shapr raises his hand
15:33:02 * shapr raises stepcut's hand
15:33:09 <palomer> oh my, I better get to bed
15:33:16 <palomer> Darius: we must continue this conversation another day
15:33:17 <shapr> pourquoi?
15:33:56 <Igloo> OK, start off pretending you only have a single row from 0 to 9, and your list looks like [3, 6]
15:34:18 <KrispyKringle> shapr: mind if I ask...I'm having some ridiculously stupid difficulty with table. Specifically, ''table $ do tr (td (text "asdf"))'' doesn't compile, and I'm not quite sure what the type error means.
15:34:23 <KrispyKringle> Am I using that wrong?
15:35:43 <Igloo> Then you can write a function    f 10 _ = []; f i [] = replicate (10 - i) "0"; f i (x:xs) = if i == x then "1":f (i+1) xs else "0":f (i+1) (x:xs)
15:36:18 <Igloo> Then f [3, 6] = ["0", "0", "0", "1", ...], right?
15:37:28 <Igloo> Sorry, f 0 [3, 6] does
15:38:26 <fivemack> yes, OK, I can see where this is going; convert list to offsets, sort it, and then write strings of zeros with the occasional one
15:38:36 <Igloo> Yup
15:38:38 <fivemack> is that in any meaningful sense anything like efficient?
15:38:47 <Igloo> It's linear
15:38:54 <Igloo> Well, apart from the sorting, obviously
15:39:09 <fivemack> I suppose you're right.  [the sorting, however, I think is compulsory]
15:39:20 <RemiTurk> does anyone know about GHCi (both 6.2.1 & 6.4) :info giving multiple !'s for unpacked strict datafields?
15:39:36 <Igloo> You might find this useful: (concat . intersperse " ") ["0", "0", "0", "1"] == "0 0 0 1"
15:39:37 <fivemack> it won't work for something like my fractal-clouds application, whose main core is pixelarray[X+W*Y]++, however.
15:39:45 <fivemack> maybe I should be coding that in C++ anyway.
15:39:49 <shapr> KrispyKringle: 'do table (tr (td (text "foo")))' ?
15:40:05 <Darius> accumArray ?
15:40:40 <Igloo> to do what I think you mean there you'd want to create an Array of all values at once, relying on lazy evaluation to make sure everything gets evaluated in the right order
15:41:13 <Igloo> (with normal immutable arrays you don't want to write each cell at a time as that tends to mean the whole array gets copied each time)
15:41:20 <kosmikus> good evening
15:41:23 <shapr> hoi kosmikus
15:41:29 <Darius> fivemack: Failing all this though, you could just use mutable arrays.
15:41:29 <kosmikus> hoi shapr
15:41:33 <shapr> wazzup?
15:41:36 <KrispyKringle> shapr: does it need the "do" still? it's inside a standardQuery "foo" $ do block
15:41:56 <shapr> no, it shouldn't
15:42:03 <kosmikus> or should I say "tere" nowadays ;)
15:42:04 <shapr> I don't think so...
15:42:17 <Igloo> Anyway, back to this problem, something like groupBy (\x y -> fst x == fst y) [(3, 1), (3, 2), (4, 3)] will put the input into lines for you, and then you can map your first function across that and apply unlines to it
15:42:29 <KrispyKringle> shapr: looks like http://rafb.net/paste/results/FXAyOu82.html
15:42:32 <KrispyKringle> doesn't work, either.
15:42:36 <Igloo> Err, which reminds me I should have said unwords rather than (concat . intersperse " ") earlies
15:43:06 <KrispyKringle> shapr: error message is http://rafb.net/paste/results/nHIhOz39.html
15:43:29 <shapr> KrispyKringle: it might want a th
15:44:14 <kosmikus> @seen duncan_
15:44:14 <lambdabot> I saw duncan_ leaving #haskell 3 hours 37 minutes 23 seconds ago.
15:44:22 <fivemack> accumArray sounds very promising :)
15:44:37 <KrispyKringle> shapr: i've seen it used in the WASH examples without that.
15:44:53 <shapr> yeah, I agree.
15:45:02 <KrispyKringle> i can give it a go, though.
15:45:03 <KrispyKringle> hrm.
15:45:09 <shapr> I'd suggest writing up a table example in isolation, away from any other code.
15:45:14 <KrispyKringle> yeah
15:45:24 <shapr> sadly, there's no way to interactively test WASH.
15:45:35 <KrispyKringle> yeah
15:45:45 <KrispyKringle> c'est la vie. its not even NEAR much code, though.
15:46:42 <KrispyKringle> now i have it directly following the standardQuery, and it still doesn't work.
15:46:54 <fivemack> many thanks to igloo
15:47:19 <Igloo> fivemack: Hmm, I'm not convinced. I think you probably just want to create an array whose cells depend on the array being created
15:47:21 <Muad_Dibber> hi
15:47:35 <Igloo> e.g. let arr = array (0, 1) [(0, arr ! 1 + 2), (1, 3)] in arr   give you the same as    array (0,1) [(0,5),(1,3)]
15:48:01 <Igloo> But I don't know the details of what you're doing, so maybe you are right  :-)
15:49:06 <shapr> KrispyKringle: can you comment out the table chunk, load your code into ghci 6.4, and use info (I think) to ask for instances of AdmitChildTr?
15:49:13 <fivemack> I should at least make it draw a mandelbrotset.  How can you say you speak a language when you have not yet drawn a mandelbrotset?
15:49:37 * RemiTurk tries again
15:49:38 <shapr> KrispyKringle: alternatively, fgrep 'instance AdmitChildTR' **/*.hs
15:49:45 <Igloo> :-)
15:49:46 <RemiTurk> @wiki HaskellIrcPastePage
15:49:46 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:50:29 <RemiTurk> does anyone have any idea whether the final snippet is a (un)documented feature or bug?
15:50:43 <xerox> Oeje1: sorry, I didn't :(
15:51:09 <KrispyKringle> shapr: i don't have ghci 6.4 insatlled, so that'd be a tiny bit tricky. :P
15:51:14 * Darius thinks he might only have made a mandelbrot program for QBASIC.
15:51:32 * RemiTurk only did it with pen & paper
15:52:20 <KrispyKringle> hmm
15:52:29 <shapr> did fgrep help any?
15:52:32 <KrispyKringle> yes.
15:52:38 <shapr> yay
15:52:49 <KrispyKringle> TBODY,
15:52:54 <KrispyKringle> TFOOT, and THEAD are the only ones allowed.
15:52:57 <KrispyKringle> very weirdd.
15:53:00 <xerox> shapr: can you share your gnus&&gmane conf with me?
15:53:13 <Darius> RemiTurk: I think it's a feature.
15:53:15 <shapr> xerox: you probably don't want my gnus conf
15:53:32 <fivemack> the other classic is game-of-life, but the way I'm thinking of it at the moment has HUGE SPACE LEEKS OF DOOM
15:53:33 <Darius> RemiTurk: If I were to guess, I'd say it signifies a (successfully) unpacked type.
15:53:50 <KrispyKringle> fivemack: leeks are vegetables.
15:53:50 * Darius hasn't had leeks before.
15:53:52 <shapr> fivemack: extraterrestrial onions?
15:53:54 <KrispyKringle> i'm not a huge fan of leeks.
15:53:59 <shapr> sounds like fun
15:54:08 <xerox> shapr: just the gmane-interaction part. I can't get it working :\
15:54:23 <shapr> (setq gnus-select-method '(nntp "news.gmane.org"))
15:54:27 <shapr> though you probably want...
15:54:27 <RemiTurk> Darius: I'd guess so. Which makes me wonder why Bools apparently aren't unpacked. Will bug ghc-users with a doc-patch :)
15:54:39 <shapr> (add-to-list 'gnus-secondary-select-methods '(nntp "news.gnus.org")) with gmane.org in there
15:54:49 <xerox> Hm yes okay.
15:54:50 <fivemack> Leeks, I'm well aware, are vegetables.  Very nice fried with butter and cream, but then again so is almost everything
15:54:51 <Darius> RemiTurk: data Bool = True | False, GHC doesn't unpack sum types I'm pretty sure.
15:55:08 <fivemack> if you bake them in the oven they go stringy, so don't do that.
15:55:30 <KrispyKringle> shapr: thanks for the help.
15:55:32 <KrispyKringle> got it working.
15:55:36 <shapr> yay!
15:55:39 <shapr> fgrep to the rescue!
15:55:54 <shapr> too bad I didn't suggest sed, that would have gotten me another dons point.
15:55:59 <shapr> y0 wli, wassup?
15:56:33 <kosmikus> what are dons points?
15:56:35 <Darius> shapr: The connection between dons and sed?
15:56:52 <RemiTurk> Darius: Ahh, sounds reasonable indeed.
15:57:19 <shapr> Darius: dons is the master of sed. Have you heard of his \sed (lambda sed) project?
15:57:39 <shapr> dons' sed-fu is at least blackbelt.
15:57:45 <Darius> shapr: I noted it when I looked at his page, but didn't actually look at it.
15:57:54 <wilx> Heh.
15:58:46 <Oeje1> shapr: Symbol's value as variable is void: gnus-secondary-select-methods, GNU Emacs 21.3.2.
15:59:17 <shapr> Oeje1: do you have that code in your .gnus?
15:59:38 <shapr> you need to have gnus loaded before that code is eval'd
16:00:00 <RemiTurk> 'night everyone
16:00:53 <shapr> g'night RemiTurk
16:01:53 <Oeje1> shapr: I have it in my .emacs.  (setq gnus-select-method '(nntp "news.gmane.org")) seems to work, but blocks the news groups on the default server somehow.
16:02:15 <shapr> Oeje1: because gmane is then your default server
16:03:14 <Oeje1> I figured that much.
16:07:58 <xerox> Another silly thing about gnus, last one I promise, how do you close an opened message? 'q' exits from the group too.
16:08:17 <shapr> doesn't for me
16:08:57 <xerox> Hmpf, gnus has something with me I suppose.
16:12:57 <Oeje1> Hm, it only seems to know the list: gmane.linux.ubuntu.hardened.general
16:13:39 <KrispyKringle> there's an ubuntu hardened?
16:13:49 <KrispyKringle> huh. i wonder if it's different than debian hardened.
16:14:05 <Oeje1> KrispyKringle: Gnus and Gmane says so.
16:14:14 <KrispyKringle> heh
16:14:23 <shapr> Oeje1: I used http://news.gmane.org/index.php?prefix=gmane and browsed around for fun stuff.
16:14:46 <shapr> this is my favorite - http://news.gmane.org/index.php?prefix=gmane.comp.lang.haskell
16:15:29 <shapr> but I'm also subscribed to pragprog, refactoring, XP, TDD, lots of zope and plone groups, mit photonic bands, comp.science.concurrency, im2000, etc
16:16:31 <xerox> B nntp RET news.gmane.org
16:16:34 <xerox> RET.
16:16:42 * shapr tries that
16:17:52 <Darius> shapr: What's comp.sci.concurrency like?
16:18:06 <shapr> so far, it sucks
16:18:11 <shapr> it's just conference announcements
16:18:17 <shapr> same for comp.science.types
16:18:28 <shapr> types is better, but still mostly conference announcements.
16:19:17 <Oeje1> xerox: Thanks!  Although, how do I make the groups stick in my group view?
16:20:42 <fivemack> mandelbrot limit size =
16:20:42 <fivemack>   let lx = 1.0 / fst size
16:20:42 <fivemack>       ly = 1.0 / snd size
16:20:42 <fivemack>       p = \x y -> mandel limit ((4*lx-2, 4*ly-2))
16:20:43 <fivemack>   in [[p x y | x <- [0 .. fst size - 1]] | y <- [0 .. fst size - 1]]
16:20:49 <xerox> Oeje1: when I'll feel another disturbance in the force, I think.
16:21:04 <fivemack> but it doesn't work because it seems to evaluate the second argument to 'mandel' as an integer
16:21:17 <fivemack> sorry. I'm a cretin. a large and foolish cretin. on a stick.
16:21:18 <Oeje1> xerox: 'u'
16:21:33 <fivemack> helps if the coordinates depend on x :)
16:22:29 <xerox> Oeje1: oh, obviously..
16:27:45 <xerox> Oeje1: does 'q' -while reading a message- close it, or close the entire group?
16:28:02 <shapr> xerox: ohh, hit =
16:28:18 <xerox> shapr: Great.
16:28:53 <xerox> (What's "ohh", stupor?)
16:28:57 <Oeje1> xerox: I goes back to the group buffer.
16:29:00 <dons> hey #haskell
16:29:05 <xerox> Hiya dons
16:29:16 <shapr> xerox: I thought you meant your focus was on the article, not focus in summary, but viewing article
16:29:35 <shapr> though now I think abou it, that probably works the same, so it's just my confusion.
16:29:37 <xerox> shapr: ah! My poor english skills :)
16:29:45 <Oeje1> xerox: And as shapr said '=' does what that.
16:30:32 <shapr> xerox: I think it was *my* poor english skills ;-)
16:31:27 <Oeje1> *-what
16:31:31 <xerox> ^_^
16:31:33 <Oeje1> And mine too.
16:32:02 <xerox> We have got enough members for #poor-english-gnus-users
16:32:03 <Oeje1> Babel Fish is actually usable for English <-> Portuguese.
16:32:56 <dons> really? it's crazy de->en or en->de
16:33:08 <dons> Though the babelbot lambdabot module is kinda fun :)
16:33:38 <shapr> @cmafihe mi na tavla glico
16:33:39 <lambdabot> mi <KOhA3> [I, me] na <NA> [not] tavla <BRIVLA> [talk] glico <BRIVLA> [English
16:33:39 <lambdabot>  
16:34:17 <dons> 11:33 dons:: @babel en de Today is a nice day
16:34:17 <dons> 11:33 \bot::   Heutiger Tag ist ein schner Tag
16:34:17 <dons> 11:33 dons:: @babel de en Heutiger Tag ist ein schner Tag
16:34:17 <dons> 11:33 \bot::   Today's day is a beautiful day
16:34:27 <dons> not too bad, actually :}
16:34:38 <shapr> dons: can you do @babel en de en ?
16:34:54 <dons> en de en? no.
16:34:56 <fivemack> is it being very clever and using a German idiom?
16:35:03 <shapr> ich veis nicht
16:35:33 <dons> don't know either.
16:35:52 <fivemack> I don't think so, but I have not been to Germany for a long time
16:36:01 <kosmikus> no
16:36:02 <shapr> I spent five days in Germany!
16:36:10 <shapr> It was very organized.
16:36:14 <kosmikus> it's incorrect
16:36:35 <kosmikus> Heute ist ein sch"oner Tag.
16:36:54 <dons> I think it is always incorrect.
16:36:55 <dons> 11:36 dons:: @babel en es Today is a nice day
16:36:55 <dons> 11:36 \bot::   Hoy es un da agradable
16:36:55 <dons> 11:36 dons:: @babel es en 1
16:36:56 <dons> 11:36 \bot::   \-bot> Today it is an pleasant day
16:37:53 <kosmikus> I have no idea why it would translate "Today" with "heutiger Tag", where "heute" is almost always better
16:38:09 <dons> he
16:38:24 * fivemack has a crazy idea of cycling Amsterdam -> Berlin in the summer
16:38:41 <kosmikus> why not?
16:38:41 <fivemack> it is four hundred miles, so in two weeks it can be done, but not sure how much I'd see along the way
16:38:41 <shapr> I want to unicycle to Stockholm.
16:38:46 <fivemack> where are you now, though?
16:38:54 <dons> hmm. I'd like to compose (babel de en . babel en de . megamonad)
16:39:02 <shapr> I'm about 1000km north of Stockholm.
16:39:06 <kosmikus> dons: :)
16:39:06 <fivemack> Ah, the fabled megamonad
16:39:37 <shapr> Where?
16:39:37 <kosmikus> fivemack: where are you from?
16:39:53 <fivemack> Gloucester, England
16:40:25 <kosmikus> why Amsterdam -> Berlin?
16:40:25 <fivemack> but should be in Amsterdam for whatthehack at end of July, and have always wanted to see Berlin
16:40:25 <kosmikus> you want to see these two cities?
16:40:25 <fivemack> also amsterdam->berlin is straight due east, and flat
16:40:33 <kosmikus> yes, but non-flat is more fun
16:41:04 <fivemack> and I haven't seen much of north Germany at all; mostly been to Munich and to alps.
16:41:04 <kosmikus> ok then
16:41:36 <fivemack> it may be that north germany is very flat and boring, but there must be something nice there.
16:41:36 <fivemack> friendly Germans, if nothing else.
16:44:49 <kosmikus> just plan in enough time, to give you the opportunity to enjoy it a bit
16:44:49 <kosmikus> it might be boring after a while ...
16:44:49 <shapr> Somedays I wish for a few boring weeks.
16:44:49 <kosmikus> me too
16:44:49 <tuomov> I haven't had a not boring week in years..
16:44:49 <kosmikus> tuomov: in need of a vacation?
16:44:49 * shapr grins
16:44:49 <tuomov> I've been on a sort of "vacation" for over a half a year now :)
16:44:49 <kosmikus> ah ...
16:44:49 <xerox> OK, 2amalready (-15mins), time to sleep. Goodnight folks.
16:44:49 <kosmikus> that explains it, too
16:44:49 <tuomov> just haven't got around to going anywhere
16:44:49 <tuomov> and my previous job was totally mind-numbing too
16:44:50 <shapr> g'night xerox
16:45:01 <kosmikus> tuomov: I thought you're at the university?
16:45:19 <tuomov> no.. but I'm trying to go back to that world..
16:45:25 <kosmikus> weren't you doing some research in applied mathematics?
16:45:34 <kosmikus> or was that only what you were planning to do?
16:46:23 <tuomov> the first half of my "vacation" I tried to figure out what exactly I want to start doing
16:47:20 <fivemack> is this phd-level research or postdoctoral?
16:47:20 <fivemack> for the former, find an interesting supervisor and he'll have something for you to do
16:47:20 <tuomov> and the latter part, after realising I'm interested a little in too many things, I've just been trying to find some university post.. but things move on slowly
16:47:29 <fivemack> for the latter, figuring out what to do is the hard bit; is why I'm not in a universitypost now.
16:47:29 <tuomov> for a phd
16:48:44 <kosmikus> I sort of agree with fivemack, although in my experience the culture in mathematics is quite a different one, and life as a phd student tends to be less pleasant than in cs
16:48:51 <tuomov> it doesn't pay to just enroll as a postgraduate student.. my income would drop to third from earnings-related unemployment benefits to study benefits
16:49:04 <shapr> hiya djw
16:49:40 <tuomov> I'm actually looking for something in the borderline of cs and maths..
16:49:51 <shapr> programming?
16:49:56 <kosmikus> what's that borderline for you?
16:50:03 <tuomov> pure maths I'm not too intrested in doing research in..
16:50:25 <shapr> fivemack: why don't you have pictures of the curves?
16:50:53 <tuomov> the borderline is quite wide..
16:51:31 <shapr> Beware the Neutral Zone.
16:51:52 <kosmikus> btw, I've now been using ion on both my machines for ~3 months, and I really like it; only that I have the feeling that whenever I get to a computer with a "normal" wm running on it, I cannot use it anymore ... thanks very much, tuomov :)
16:52:50 <Darius> kosmikus: Do you type dvorak too?
16:53:14 <kosmikus> no
16:53:34 <kosmikus> this would make it even worse
16:54:11 <kosmikus> and I guess I could never really play nethack anymore ...
16:54:23 <shapr> hey! that *increased* my productivity!
16:55:04 <shapr> plus you can still play nethack-el :-/
16:55:52 <kosmikus> I don't really see any problems with qwerty, so there's not a huge motivation for me to learn dvorak
16:56:13 <fivemack> shapr: err, which curves do you want pictures of?
16:56:19 <kosmikus> plus, all my German friends do already think I'm crazy that I use qwerty and not qwertz
16:56:59 <dons> shapr: you've switched over to dvorak?
16:57:14 <shapr> yeah, in 1992
16:57:19 <dons> how long did it take you to get back up to speed?
16:57:32 <shapr> in about four days I surpassed by qwerty hunt-and-peck skillz
16:57:56 <Gahhh> dvorak is blasphemy.
16:58:06 <shapr> qwerty is purgatory.
16:58:31 <shapr> But I did think up that hidden markov model layout, which should be at least several level down in the nine hells.
16:58:46 <dons> ok, hunt-and-peck. but i'm typing fairly fast in qwerty.. but I can't imagine it would be more than a few weeks before I'd be back up to speed.
16:58:50 <dons> maybe ..?
16:59:08 <sh10151> aeou
16:59:14 <shapr> I would be surprised if it took more than three weeks till you were up to speed in dvorak.
16:59:35 <Gahhh> I should switch to dvorak at work to alienate my coworkers...
17:00:08 <Darius> dons: Took me a week to get to comfortable in dvorak.
17:00:15 <Gahhh> The IS people are already in total shock when they try to use my machine since I use litestep on winxp.
17:00:20 <dons> shapr: you've convinced me. it's time to change!
17:00:24 <shapr> yay!
17:00:27 <wagle> i tried using an encrypted keyboard once.  was exciting.
17:00:33 <dons> Darius: oh good. that's reassuring.
17:01:02 <Darius> I could touch type QWERTY reasonably fast before.  The main benefit I'd say though is comfort, personally I don't think I'm significantly faster with dvorak (a little though).
17:01:11 <dons> and do you change the keycaps on the keyboard? or just memorise?
17:01:28 <Gahhh> are you still comfortable with qwerty if you need to use it ?
17:01:35 <dons> i guess comp.sci. guys don't do a lot of extended typing - more bursty
17:01:43 <shapr> I'd recommend you don't change your keycaps unless you can touchtype qwerty well. Your BIOS doesn't respect xmodmap.
17:02:19 <wagle> plus, you want to be able to dvorak on all the qwerty keyboards out there
17:02:33 <Darius> Gahhh: Unfortunately no.  I can type it reasonably, but nowhere near as fast as I could.  However, I've typed almost no QWERTY since switching.  And I imagine I could rebecome proficient in a day or less.
17:02:35 <tuomov> the major problem with switching to dvorak is application keybindings that have been designed for qwerty
17:02:41 <hellish> One could write on them in white-out, above the qwerty letters.
17:02:55 <dons> tuomov: good point
17:02:55 <wagle> often its a one-liner to switch a gui to dvorak
17:03:14 <fivemack> shapr: can you tell me more about the hidden-markov-model keyboard layouts?
17:03:15 <wagle> oooo..  vi must be horrible..  8)
17:03:20 <dons> luckily I just use configuratble apps.
17:03:31 <dons> wagle: :P hmm..
17:03:38 <Darius> dons: I did a typing test a few weeks ago and got 62 WPM which is more or less (more less than more, confusing eh) what I'd say for QWERTY before.
17:03:56 <Darius> Of course, I've technically been typing QWERTY since I was like 5 or so, so...
17:04:05 <Darius> wagle: I use vim.
17:04:16 <wagle> Darius: switching to dvorak?
17:04:45 <Darius> wagle: I don't understand the question.  I used vim when I typed QWERTY and now.  I type dvorak now.
17:05:13 <shapr> fivemack: Take a few months of your collected typing statistics, including which key comes after which other key. Then make a separate keymap that should be applied when releasing a letter, focussing on keeping most used keys on the home row. Make sure to include either a timeout or a reset key.
17:05:22 <Gahhh> Darius, if your speed is roughly the same, why stick to dvorak ?
17:05:31 <wagle> my nethack training for vi* is positional
17:05:45 <shapr> fivemack: clear?
17:05:57 <sh10151> i squandered my angband years
17:06:04 <sh10151> used the numeric keypad
17:06:08 <hellish> shapr, That's hilarious
17:06:08 <fivemack> Yes, it's just like models for arithmetic encoding, I think.
17:06:24 <Darius> Gahhh: As I said, it's more comfortable.  It's also more sane in an intellectual manner.  I'm also not sure what my speeds are for how I normally type (as someone mention CS is more bursty than long running).
17:06:24 <shapr> hellish: hellarious maybe...
17:06:25 <fivemack> It needs LCD key-caps initially
17:06:50 <Darius> wagle: I've set most of the vim keys I used to the same positions, a few are different.
17:06:50 <fivemack> then you don't need the timeout key, you just failover to hunt-and-peck
17:06:52 <hellish> shapr, Do you actually use it?
17:07:04 <shapr> hellish: no, though I do modify my keyboard layout every week or so.
17:07:22 <shapr> My current layout is the "I am not a koala" trunk.
17:07:34 <Darius> With regards to keyboard keys, my keyboard has a QWERTY layout.  You should be touch typing so what's on the keys is irrelevant.
17:07:58 <shapr> From what I can tell, human hands are not meant for chording with the fingers, only the thumb.
17:08:07 <shapr> So I've moved all of my modifier keys under my thumbs.
17:08:23 <shapr> Works well.
17:08:25 <wagle> Darius: double encryption...  ooooo
17:08:46 <Gahhh> nah. that's security by obscurity heh
17:09:04 <Darius> dons: If you can touch type now, I'd recommend "cheating" and looking at a the keyboard (if you change the keys) or a dvorak layout image while you learn.
17:09:06 <wagle> (it was totally hilarious when i tried to use someon's dvorak encrypted keyboard when they weren't there)
17:09:13 <shapr> Of course, you need to use the right keyboard - http://kinesis-ergo.com/images/500-blk.jpg Standard keyboards don't give your thumbs *any* access other than the spacebar!
17:09:20 <dons> Darius: yeah - I think I'd need an image.
17:09:32 <dons> but I currently touch type up around 60wpm
17:09:42 <shapr> dons: apt-get install dvorak7min
17:09:44 <fivemack> you change the keyboard layout frequently, and still touch-type?
17:09:46 <Darius> dons: When I was learning I had a PDF open.
17:09:59 * fivemack bows down in awe at the flexibility of your brain's motor centres.
17:10:02 <shapr> fivemack: sure, it's not hard if you do it regularly.
17:10:20 <shapr> fivemack: On the downside, I also require Ritalin to stay employed.
17:10:29 <Gahhh> reminds me of the time when I re-laid out my keys and mouse inversion for quake 3. I couldnt walk for 3 days...
17:10:30 <dons> good idea. ok. so tweak the mapping, get a keyboard image, then practice :)
17:11:59 <bourbaki> moin
17:12:31 <wagle> i knew a kid who could do 120 WPM on qwerty, and 145 in dvorak on a computer typing contest
17:13:40 <Darius> wagle: A friend of mine's whole family seems to be able to type very fast.  His mother, typed 120 WPM I believe (almost certainly QWERTY).
17:14:50 <Leimy> I've tried DVORAK
17:14:59 <shapr> Bach is nice too.
17:15:02 <Leimy> there is no way my company can afford the loss in productivity while I learn
17:15:23 <Leimy> or my ability to hit caps lock at the wrong time
17:15:28 <Leimy> like when I type DVORAK
17:15:29 <Leimy> :)
17:15:39 <Darius> Leimy: A few days of painfully slow typing, then reasonable spped is too much?
17:15:51 <kosmikus> good night ...
17:15:57 <shapr> g'night kosmikus
17:16:08 <Leimy> Darius: there are always fires to put out here...
17:16:17 <fivemack> is your job critical-pathed by typing speed?  with fires to put out, probably ...
17:16:27 <Leimy> fivemack: yep
17:16:32 <Leimy> lots of commuication via email
17:16:35 <Leimy> and coding
17:16:50 <Leimy> vi is nice when hjkl are next to each other :)
17:16:57 <Leimy> and emacs... good lord.
17:17:07 <Darius> Leimy: It'd probably take more time, but you could keep typing QWERTY concurrently.  You should be able to develop dvorak skills in a couple of weekends.
17:17:08 <Leimy> It's hard enough to remember the damned keystrokes :)
17:17:20 <Leimy> Darius: I can sort of type Dvorak now
17:17:23 <Darius> Enough to use for work unless you demand a steady 60+ wpm
17:17:28 <Leimy> I just can't remember the bottom row :)
17:17:56 <Leimy> Mac OS X let's me hot key switch between them
17:17:58 <Leimy> so does KDE
17:18:16 <Leimy> and mac os x has dvorak with qwerty command keys
17:18:26 <Leimy> which I think muddies the water a bit actually ":)
17:18:26 <tuomov> when I tried to learn dvorak, I could type at a tolerable speed in a few days... but the app key bindings were horrible
17:18:46 <tuomov> and I didn't want to start reconfiguring all programs' bindings let alone memoizing the new keys
17:19:22 <Darius> tuomov: Put the bindings in the same positions (or at least the ones that you remember by position).
17:19:27 <sh10151> aah
17:19:31 <Darius> Though, it is a pain in the ass.
17:19:33 <sh10151> that would really speed my typing up!
17:19:39 <sh10151> memoizing keys!
17:19:53 <Leimy> I mean... I'm not against new things
17:19:55 <dons> tuomov: but if I only use a couple of apps: ion, vim, mozilla, that should make it easier
17:19:58 <Leimy> I use Plan 9 from time to time
17:19:59 <sh10151> i would just look at the key and it would be typed
17:20:00 <shapr> I'm a neophile.
17:20:04 <sh10151> as long as I had typed it before
17:20:40 <tuomov> ion, bash, jed, whatever browser sucks the least at the particular moment
17:20:50 <tuomov> s/bash/readline/
17:21:42 <dons> ok. but it's not like there's 48 win32 gui apps with arbitrary mappings to deal with ;)
17:22:24 <dons> if I can get vi keys sorted, that solves ion,vim,w3m,zsh all in one go :)
17:22:39 <dons> just pesky mozilla with stoopid emacs bindings
17:23:02 <sh10151> i use emacs and bash
17:23:17 <Leimy> emacs most of the time
17:23:25 <Leimy> been playing with sxemacs in fact
17:23:33 <Leimy> I often use Acme though
17:23:49 <tuomov> it's just confusing to instruct people with bindings then..
17:24:03 <Leimy> the great thing about acme is it doesn't use control keys
17:24:09 <Leimy> should be great for dvorak learners :)
17:24:18 <Leimy> but they'd get pissed off cuz the mouse is so involved :)
17:27:10 * Darius remapped dvorak and had Ion using dvorak like navigation keys.
17:27:44 <Darius> I was typing dvorak before I used Firefox so that didn't take any effort, though I'd like to make them vim-y too.
17:28:18 <tuomov> keys should have positional names as well..
17:29:06 <tuomov> That way I could also use Mod1+<key left of 1> for scratchpad toggle in Ion default bindings...
17:30:40 <tuomov> users of fancy keyboards would of course have to map these positional symbols in a non-positional way
17:31:34 <shapr> or maybe positional mappings come from keyboard layout descriptions
17:31:54 <shapr> Yi > Emacs
17:32:03 <shapr> dons: hey, do you have the synhl demo code available?
17:32:07 <shapr> I'd like to play with it.
17:34:48 <dons> shapr: I saw your post. Ok, so I'm finding it hard to get any time  to work on yi - so i'll merge into the yi repo the synhl code today or tomorrow, and you can go nuts.
17:35:02 <shapr> w00
17:35:04 <wagle> (sh10151) is cedet active?
17:35:11 <shapr> I'm already nuts, but I can at least try to improve the synhl.
17:35:18 * shapr snrks
17:35:19 <dons> yeah :)
17:35:46 <shapr> emacs got me into a towering screaming howling rage several times in the last month.
17:36:27 <shapr> There's nothing like losing an hour of painful detailed Python work to invoke that sort of frustration.
17:37:05 <wagle> i keep wanting to figure out how to get these large unwieldy programs to rewrite themselves into small clear programs, automagically
17:37:29 <shapr> I switched back to xemacs, but now many of the extensions don't work. That's why I switched to gnumacs in the first place, so I could use eldav, and all the other gnumacs-specific extensions.
17:38:07 <dons> argh. nightmare
17:38:08 <wagle> hey, maple crashed, and zeroes my work AND all the backups i carefully made every few minutes
17:38:14 <sh10151> shapr: autosave didn't work?
17:38:18 <Darius> wagle: Read Heffalump's thesis.
17:38:22 <dons> zeroes the backups!
17:38:36 <sh10151> the cedet list has activity
17:38:42 <sh10151> I don't develop, just lurk
17:38:43 <shapr> sh10151: worse, gnumacs just disappeared *and* trashed all the autosave backups somehow.
17:38:54 <sh10151> shapr: scary stuff
17:39:08 <shapr> gnumacs started disappearing or hanging every hour.
17:39:21 <sh10151> what system?
17:39:25 <sh10151> was it CVS?
17:39:29 <shapr> debian-unstable
17:39:36 <shapr> nah, it's the standard deb.
17:39:51 <sh10151> that's just awful
17:40:07 <shapr> I think the real problem is that most users don't use ange-ftp, tramp, eldav, irc, gnus, eshell, and lots of other stuff all at the same time.
17:40:14 <sh10151> :-D
17:40:21 <sh10151> i can't say that I do
17:40:35 <sh10151> ecb, eshell, tramp is about my limit
17:40:38 <shapr> I'm almost positive the essence of these crashes are a race condition that involves several of these at the same time. I do not wish to track down that race condition.
17:40:38 <sh10151> no irc and gnus
17:41:05 <sh10151> how many times has it crashed?
17:41:32 <shapr> thirty or forty times.
17:41:56 <shapr> I've crashed xemacs once since 1998.
17:42:37 <shapr> gnumacs I have crashed hundreds of times.
17:42:56 <shapr> I used to use gnumacs at work and xemacs at home. It was a nice way to get an overview of the differences.
17:43:17 <sh10151> i use gnu everywhere
17:43:26 <sh10151> because of nxml-mode among other things
17:43:36 <shapr> I ended up deciding that in the case of gnumacs, RMS is an evil selfish dictator who should be ousted.
17:43:44 <sh10151> ha!
17:43:53 <shapr> And that xemacs is a lot easier to use for the most part.
17:43:53 <sh10151> good luck on that one :-)
17:44:18 <shapr> I think the gnu/x emacs split will be the death of the emacs community.
17:44:28 <sh10151> the thing that made xemacs harder to use for me was emacs21
17:44:38 <sh10151> a lot of code just focuses on that
17:45:05 <sh10151> you don't think eclipse will be? ;)
17:45:10 <shapr> no way
17:45:28 <shapr> eclipse isn't open source.
17:45:39 <shapr> Not unless it runs on classpath + jrvm
17:45:56 <Lunar^> shapr: AFAIK, it does
17:45:59 <Lunar^> shapr: look at SableVM
17:46:06 <shapr> !
17:46:22 <shapr> sh10151: In any case, there's a better way....
17:46:32 <shapr> http://www.cse.unsw.edu.au/~dons/yi.html
17:47:22 <wagle> Darius: Higher-order matching for program transformation ?
17:47:24 <Lunar^> shapr: http://sablevm.org/screenshot/e3-full.png
17:47:45 <shapr> Lunar^: wow, cool
17:48:10 <Darius> wagle: Yes, that sounds right.
17:48:27 <wagle> Darius: what am i looking for?
17:48:29 <Lunar^> shapr: http://sablevm.org/wiki/Eclipse
17:49:59 <shapr> Lunar^: I still don't want to use Java if given the choice :-)
17:50:07 <shapr> But I'm glad Eclipse has gone fully open source.
17:50:15 <Darius> wagle: That's it.  Of course, I wasn't being 100% serious
17:50:18 <shapr> anyway, time for sleep.
17:50:36 <wagle> Darius: wondereed what caused you to refer me to it
17:51:09 <Darius> Actually, it's more the other way (and most things are the other way), but the techniques should be useable either way actually.
17:51:46 <Darius> wagle: It's about transforming programs, though typically relatively nice but slow ones into faster but less nice ones.
17:53:42 <wagle> (oic..  finally started skimming it..  you are responding to my "get emacs/gcc to rewrite itself" remark, not my "maple scr00d me!")
17:55:22 <wagle> my favorite editor (cornell synthesizer generator) is (ahem) quite proprietary..
17:56:07 <wagle> you wrote an attribute grammar, and it produced a hybrid text/structure editor in emacs
17:57:22 <dons> cool.
18:05:56 <sh10151> can't emacs and xemacs live together in peace?
18:08:00 <wagle> i lost patience with emacs when they build up their own X libs from scratch
18:09:40 <wagle> (a bit of a while ago)
18:09:59 <wagle> emacs right out of the box seems much more primitive than xemacs
18:13:33 <wagle> (oh darn, thought i had people here who would defend emacs)
18:17:25 <Darius> emacs: the reason you use vim
18:19:25 <sh10151> wagle: emacs has an O'Reilly book, nyah
18:19:26 <sh10151> :)
18:19:46 <_metaperl> could someone answer my Haskell question about half-way down through this file: http://www.hcoop.net/~terry/haskell/sig-gen/SigGen.hs
18:19:59 <wagle> sh10151: which pisses stallman off to no end
18:21:17 * wagle wanders off into the offline wilderness
18:21:20 <sh10151> wagle: oh do tell :)
18:22:08 <Darius> _metaperl: read parses a string into a data structure.
18:22:23 <_metaperl> I guess I have a simple question
18:22:26 <wagle> stallman wrote them a nasty mail when they published it..  gnu software was supposed to make money from sales of documentation, or something..  i heard 2nd (3rd? 4th?) hand
18:23:04 <_metaperl> given that Config has two named fields, can we create data values of type Config in anyway other can supplying both/either field?
18:23:22 <_metaperl> ie, myc = Config(standardPrefix = "hi there")
18:23:30 <_metaperl> ie, myc = Config(standardPostfix = "hi there")
18:23:34 <Darius> _metaperl: Probably by supplying none, but it'd be rather useless.
18:23:36 <_metaperl> both of these are ok right?
18:23:54 <Darius> _metaperl: Ish.  If you try to use the undefined field it will raise an error.
18:23:55 <_metaperl> but read does not supply the string it reads to either named field
18:24:06 <_metaperl> but read does not supply the string it reads to either named field
18:24:15 <_metaperl> so which field does it go into?
18:24:22 <Darius> _metaperl: read parses the input which will look like "Config { standardPrefix = \"hi there\" }"
18:24:39 <_metaperl> you mean it automatically goes into the first named field?
18:24:49 <_metaperl> if no field is given?
18:25:51 <Darius> I mean that read will get the data to fill out the fields from the string.  But in a different respect, yes you can used records as normal data construtors, Config foo bar should work.
18:26:10 <Darius> As well as pattern matching against (Config foo bar)
18:28:02 <_metaperl> *Main> (read "123")::Config
18:28:02 <_metaperl> *** Exception: Prelude.read: no parse
18:28:02 <_metaperl> *Main> read "123"
18:28:02 <_metaperl> 123
18:28:02 <_metaperl> *Main>
18:28:44 <_metaperl> what must the string that read reads in look like in order for it to be accepted via ::Config
18:29:06 <_metaperl> ALSO: is that ::Config the type descriptor or data constructor Config?
18:29:10 <Darius> It depends on the Read instance, but if it is derived then like what you type in the source.
18:29:13 <_metaperl> I really need to get a book on Haskell
18:29:20 <_metaperl> I have Simon Marlow's book on order
18:29:24 <_metaperl> it should be here in a week
18:29:26 <Darius> _metaperl: ':: Config' is a type annotation
18:29:27 <Darius> @type read
18:29:31 <_metaperl> I'm asking a bunch of simple questions
18:29:34 <lambdabot> read :: forall a. (Read a) => String -> a
18:30:01 <_metaperl> but what might you supply to read to get it to work?
18:30:38 <Darius> read "Config { standardPrefix = \"a\", standardPostfix = \"b\" }"
18:31:01 <Darius> Probably with ':: Config' stuck to the end if you run it in an repl
18:31:19 <hellish> Does anyone here use Hunit? Do you think it helps?
18:31:21 <Darius> _metaperl: The above string is exactly what you'd type in the source code to make the record, only escaped.
18:31:54 <dons> metaperl: Simon Marlow's book?
18:32:10 <_metaperl> oh Simon Thompson
18:32:14 <_metaperl> the Simon at Kent
18:32:15 <dons> ok
18:32:17 <_metaperl> not Jaffacake
18:32:21 <_metaperl> or PJ
18:32:38 <_metaperl> It looks like the best systematic introduction to the language I have seen
18:33:07 <Darius> There are quite a few online resources you could look into until it arrives.
18:42:24 <_metaperl> I own the Algorithms book... it's a nice quick intro.. my problem is my attention span is low and I dont use online resources very well to track down where the answe to my problem is... I'm sure if I spent 30 minutes with gentle I mi... actually no.. that was kind of wild what that code did
18:56:45 <KrispyKringle> hey shapr, mind if I ask you another WASH question?
19:11:27 <Darius> _metaperl: Just reading section 2 of the Gentle Introduction would have answered or avoided many of your questions and there doesn't seem to be anything particularly complicated there.
19:12:05 * _metaperl hangs his head in shame
19:20:44 * _metaperl completes section 2.0
19:26:07 <autrijus> is there a way to get argv[0] in ghc?
19:26:13 <autrijus> other than using inline C :)
19:31:45 <autrijus> ok. including using inline C.
19:31:49 <dons> getProgName ?
19:31:49 * autrijus does not seem to see a way
19:31:54 <autrijus> no, that strips off leading dirnames.
19:32:04 <autrijus> so, not terribly useful.
19:32:17 <dons> write your own getProgName
19:32:24 <dons> getProgName :: IO String
19:32:24 <dons> getProgName =
19:32:24 <dons>   alloca $ \ p_argc ->
19:32:24 <dons>   alloca $ \ p_argv -> do
19:32:24 <dons>      getProgArgv p_argc p_argv
19:32:27 <dons>      argv <- peek p_argv
19:32:30 <dons>      unpackProgName argv
19:32:33 <dons> wheree you define a better unpackProgName
19:32:36 <autrijus> getProgArgv?
19:32:48 <dons> getProgName currently runs a local    basename :: String -> String
19:33:46 <autrijus> getProgArgv is not shown in docs...
19:33:49 <autrijus> IOBase?
19:34:12 <dons> System.Environment
19:34:34 <autrijus> foreign import ccall unsafe "getProgArgv"
19:34:34 <autrijus>   getProgArgv :: Ptr CInt -> Ptr (Ptr CString) -> IO ()
19:34:41 <autrijus> only not re-exported.
19:34:45 <autrijus> so I'll need to replicate here
19:34:46 <dons> ah.
19:34:52 <autrijus> ok, that works. thanks!
19:34:55 <autrijus> dons++
19:35:04 <dons> :)
20:02:37 <_metaperl> CosmicRay, I can't find my IRC Snippets on sequence.complete.org
20:03:20 <_metaperl> never mind, found 'em
20:03:37 <CosmicRay> :-)
20:03:41 <_metaperl> one thing
20:03:41 <CosmicRay> sorry, slow response sometimes
20:03:44 <CosmicRay> sure
20:03:59 <_metaperl> My IRC client creates logs with the username of the irc user in <brackets>
20:04:07 <_metaperl> and then drupal freaks out when it sees it
20:04:20 <_metaperl> thus it is rather difficult to paste IRC info into drupal
20:04:22 <CosmicRay> ah, probably so.
20:04:23 <CosmicRay> hmm.
20:04:36 <CosmicRay> can you write a sed script to convert them to &gt; and &lt; ?
20:05:15 <_metaperl> yes, but why not a haskell script? :)
20:05:27 <CosmicRay> :-)
20:05:28 <_metaperl> a parsec script perhaps...
20:05:38 <_metaperl> a bit too hard for me at the moment
20:11:12 <Darius> @type List.concatMap (\c -> case c of "<" -> "&gt;";">" -> "&lt;";_ -> c) . map (:[])
20:11:14 <lambdabot> List.concatMap (\c -> case c of "<" -> "&gt;";">" -> "&lt;";_ -> c) . map
20:11:14 <lambdabot> (:[]) :: [Char]
20:11:14 <lambdabot> 										   -> [Char]
20:11:22 <Darius> @type interact $ List.concatMap (\c -> case c of "<" -> "&gt;";">" -> "&lt;";_ -> c) . map (:[])
20:11:24 <lambdabot> interact $ List.concatMap (\c -> case c of "<" -> "&gt;";">" -> "&lt;";
20:11:24 <lambdabot>  -> c) . map (:[]) :: IO  ()
20:12:29 <Darius> CosmicRay, you running a pretty standard Drupal configuration?
20:13:09 <_metaperl> well, I just wrote a Perl script that I think would be much wordier in Haskell... anyone want to take it on : http://pastebin.com/262406
20:13:46 <autrijus> not if you start your haskell with "import Pugs.Eval"
20:13:49 <autrijus> ;)
20:14:08 <autrijus> and in fact haskell is well-suited to write your program.
20:14:12 <autrijus> @type interact
20:14:13 <Darius> Add main = to the above (and import List), and you have a complete program.=
20:14:13 <lambdabot> interact :: (String -> String) -> IO ()
20:15:06 <_metaperl> lol
20:17:03 <CosmicRay> Darius: yes
20:17:10 <Darius> import List;main = interact $ concatMap (\c -> case c of "<" -> "&gt;"; ">" -> "&lt;"; _ -> c) . map (:[])
20:17:18 <CosmicRay> Darius: the only hack to core was a very simple tb spam thing
20:18:02 <_metaperl> you dont want to escape all angle brackets --- only the ones after the time
20:18:50 <Darius> _metaperl: Won't any (matched) < > cause issues?
20:19:03 <_metaperl> not with Drual
20:19:05 <_metaperl> drupal
20:19:13 <_metaperl> only complete tag-like looking things
20:19:32 <Darius> CosmicRay: The just seems to be some spam posts.  Other Drupal users seem to suggest changing the signin slightly to avoid them.
20:20:47 <CosmicRay> Darius: I know, I get spam notifications and am cleaning them up manually
20:20:56 <CosmicRay> I allow anonymous (un-signed-in) posts
20:20:58 <CosmicRay> which is the main issue
20:21:21 <CosmicRay> the site is still new so the spam module hasn't learned much yet
20:21:27 <CosmicRay> it gets fairly effective as things go along
20:21:42 <CosmicRay> though it doesn't integrate with trackback yet, so I may have to disable those on all drupal sites for now
20:21:56 <Darius> Except that it won't be tailored specifically to the spam your receive, couldn't you initialize it on some corpus?
20:22:11 * _metaperl decides to hit the proverbial hay
20:22:16 <CosmicRay> hmm, theoretically yes, haven't seen one around tho
20:22:19 <CosmicRay> cya metaperl
20:23:37 <gzl> shapr: hey, in WASH, do you happen to know what to do if it complains that some value has type InputField String INVALID instead of InputField String VALID? the value was obtained by having (foo <- makeTextarea ...) in a do block.
20:24:09 <CosmicRay> Darius: afaik all the spam is gone now
20:26:14 <Darius> CosmicRay: It wasn't an issue, I was just checking if you've heard about/implemented the above.
20:26:51 <gzl> if anybody else knows, that would be appreciated too. :)
20:26:53 <Darius> gzl: I believethe VALID and INVALID types are there to keep you from using fields that haven't been initialized/filled out.  But that's from reading the paper a long time ago.
20:26:58 <gzl> hmm.
20:27:28 <gzl> yeah, I know, but these fields are filled out. besides, this is compile time, so how does it know it's not initialized?
20:27:58 <Darius> gzl: It can tell that it won't be initialized by the time it's needed.
20:28:02 <gzl> hm.
20:28:11 <Darius> The papers/documentation should go over it.
20:28:20 <gzl> but I've pre-filled the text area with some sample text.
20:28:33 <gzl> i'll look through them again, but i got kind of stuck.
20:28:35 <CosmicRay> Darius: no, I haven't heard of signin problems
20:28:54 <CosmicRay> Darius: the account creation method already requires e-mail cookies, so it's fairly robust as far as spam prevention is concerned
20:29:03 <CosmicRay> if one were to require commenters to authenticate
20:29:17 <CosmicRay> I have found that not requiring a login to post comments greatly encourages legitimate comment posts
20:29:31 <Darius> I'd agree.
20:30:00 <Darius> I'm going to call it a night now.
23:30:03 <wilx> Hmpf. I cannot find hs-plugins in FreeBSD ports...
23:34:55 <autrijus> because it doesn't work on freebsd.
23:35:03 <autrijus> and alex doesn't compile for me either.
23:35:10 <autrijus> there seems to be multiple autoconf problems
23:35:17 <autrijus> but I gave up tracking it down after I found DynamicLoader.
23:35:33 <autrijus> or, more precisely, NameLoader.
23:46:04 <musasabi> morning
23:51:59 <wilx> Hmm...
