00:18:49 <Itkovian> meuning
00:21:09 <Lemmih> Good morning, #haskell.
00:21:24 <mattam> morning Lemmih
00:21:29 <Oeje1> Hej, Lemmih.
00:59:05 <a5> it's morning again?
00:59:53 <Gahhh> ah these international channels
00:59:55 <pesco> history repeating itself
01:00:04 <rtega> lol
01:00:09 <rtega> mo'nin peops
01:01:53 <a5> guys want to help me with another memory-leakish problem? http://ofb.net/~frederik/difftest/test-autodiff-only.png
01:03:07 <a5> the green curve should be a straight line, and the red one should be horizontal.
01:03:49 <a5> the horizontal axis is time
01:05:20 <a5> it's just doing the same thing in a loop, and the green curve measures the number of times it did it. what i don't understand is why the green curve is segmented. in other cases like this it has been smoothly curved.
01:05:43 <a5> it's like a hash table is growing incrementally...
01:06:11 <pesco> Appearently something is eating up memory and cpu time at the same time.
01:06:15 <pesco> What exactly is it doing in the loop?
01:07:00 <a5> it's doing a simple call to my automatic differentiation library, which does stuff with hash tables .. but there shouldn't be anything persistent
01:07:57 <pesco> Very possibly there are entries kept lingering in the tables, thus consuming memory and making access to the table slower.
01:08:44 <pesco> Have you run this with the GHC heap profiler?
01:08:48 <a5> but the whole tables are supposed to be destroyed between calls
01:09:05 <a5> i've used some -prof options, i don't know if i'm doing it right though
01:09:44 <a5> i got a breakdown of where allocations were being done
01:09:53 <a5> but that's not very helpful for memory leaks
01:10:15 <pesco> Read the documentation carefully. You should be able to generate a graph of memory allocations over time.
01:10:29 <pesco> That should tell you where the code is holding on to memory.
01:11:01 <pesco> The hp2ps utility is what you want, I think. Have you used it?
01:11:10 <a5> oh, no
01:11:22 <a5> will try that, thanks
01:11:27 <pesco> No problem.
02:08:48 <nlv11757_> does hPutStr append or overwrite?
02:09:43 <Lemmih> Did you open your file in append of overwrite mode?
02:09:52 <Lemmih> s/of/or/
02:09:55 <nlv11757_> ow there is a appendmode :/
02:09:56 <nlv11757_> hehe
02:10:01 * nlv11757_ hits himself
02:10:31 <nlv11757_> i thought there were only 3 modes; Read Write ReadWrite
02:11:24 <nlv11757_> ok so with writemode current contents of the file get lost?
02:11:40 <Lemmih> Yes.
02:12:38 <Lemmih> Not sure actually.
02:16:05 <Lemmih> Now I'm sure again.
02:16:10 <nlv11757_> :)
02:16:26 <nlv11757_> so contents are deleted first before writing so to say
02:16:53 <nlv11757_> cause overwrite is a bit ambiguous
02:17:00 <nlv11757_> it is a replace so to say
02:18:20 <musasabi> nlv11757_: WriteMode has the same semantics as C ;)
02:19:55 <Oeje1> Bittorrent sucks:  "time left:      59 hour 51 min 51 sec".
02:19:57 <nlv11757_> hehehe by the ;) im guessing at a low-level it's just C calls?
02:20:56 <musasabi> well doing IO without involving C is kind of hard...
02:21:01 <Muad_Dibber> we not talking illegal downloads are we Oeje1 ?
02:21:31 <Oeje1> Muad_Dibber: http://video.hackinthebox.org/
02:21:55 <Oeje1> Unless Theo de Raadt is a h4x0r.
02:21:57 <Muad_Dibber> :)
02:22:22 <Muad_Dibber>  Keynote Speaker 1 - Theo de Raadt -- Exploit
02:22:31 <Muad_Dibber> hmm, sounds h4x0r like :P
02:23:00 * Oeje1 hides from the BSA rep. who just walked in.
02:24:57 <bourbaki> moin
02:25:29 * Oeje1 is hit by a shot from the BSA guys DOD developed plasma laser stun gun.
02:25:59 <Oeje1> Aaargh...gurgl, gurgl...
02:26:36 <pesco> Stun plasma. BSA wimps.
02:28:52 * pesco swings around his belt-mounted heavy infantry Plascannon and evaporates the intruder.
02:29:50 * Oeje1 sighs in relief.
02:30:22 <a5> the ghc profiling documentation isn't very clear
02:30:34 <pesco> a5: No? Hm.
02:30:50 <pesco> I don't remember the details right now, but I do remember eventually figuring it out...
02:31:04 <pesco> Keep up, you'll make it. ;)
02:31:20 <a5> what's a retainer, for instance? you don't have to define it, but the docs seem to contain a definition but don't.
02:32:01 <pesco> I guess a retainer is something that keeps something else retained in memory.
02:32:11 <pesco> I know I'm vague, but I don't know about this either.
02:32:18 <a5> yeah, that's not it
02:33:09 <araujo> Good morning haskellers
02:33:37 <a5> good night
02:35:22 <a5> but the docs contain a useful comment: "A good example is looking up
02:35:22 <a5> a value in a finite map, where unless the lookup is forced in a timely manner the unevaluated lookup will cause
02:35:22 <a5> the whole mapping to be retained. These kind of space leaks can often be eliminated by forcing the relevant
02:35:24 <a5> computations to be performed eagerly, using seq or strictness annotations on data constructor fields."
02:35:29 <musasabi> a5: a retainer of foo is something that references foo (afaik)
02:36:13 <a5> no, that doesn't fit the docs
02:36:22 <pesco> Sure?
02:36:32 <a5> "An object A is retained by an object B if object A can be reached by recursively following pointers starting
02:36:33 <a5> from object B but not meeting any other retainers on the way."
02:36:35 <musasabi> e.g. "lookup key fm" creates a thunk which references both key and the fm keeping them live.
02:37:45 <a5> yeah IOW i think i may have to put some 'seq' statements in to fix my problem. i actually use some finite maps and that's looking like a place where things are being retained
02:38:04 <musasabi> a5: A is retainer of B => B is reacheble by GC from A keeping B thus live.
02:38:28 <pesco> Why don't they just state that retainers are objects directly referencing the retainee?
02:38:59 <musasabi> pesco: because the reference might not be visible on a semantic level.
02:39:16 <pesco> What do you mean by "semantic level"?
02:39:27 <musasabi> pesco: a thunk has no references on a semantic level but it can have references on the implementation level.
02:39:31 <jlouis> you may have lost the reference
02:39:38 <jlouis> but the pointer in the memory still exists
02:39:39 <a5> musasabi: but there's the bit about not meeting other retainers along the way
02:39:43 <jlouis> afaics
02:40:15 <pesco> By saying "referencing" I meant "pointing to"; sorry, C jargon.
02:40:26 <musasabi> pesco: it would be silly to talk about an Integer referencing other objects semantically, but in reality the Integer may be a thunk which references other objects on the implementation level.
02:41:24 <pesco> So, why don't they state that retainers are objects pointing to the retainee?
02:42:27 <pesco> I don't understand why they first talk about "recursively following pointers" and then restrict that to "but no other retainers on the way". Doesn't anything on the way lead to the retainee by definition?
02:42:57 <pesco> It seems to me that anything but the last object doesn't qualify by that restriction.
02:44:50 <a5> which module has 'seq'?
02:45:01 <pesco> Prelude.
02:45:26 <a5> huh, it's not in the doc I have
02:45:42 <pesco> @info seq
02:45:43 <lambdabot> -- seq is a variable
02:45:43 <lambdabot> infixr 0 `seq`
02:45:43 <lambdabot> seq :: forall a b :: ?. a -> b -> b
02:45:49 <pesco> @index seq
02:45:49 <lambdabot> Control.Parallel,Prelude
02:46:11 <Lemmih> a5: That's a known bug. Fixed in the documentation for GHC 6.4
02:46:23 <pesco> Heh.
02:47:00 <a5> oh. so 'seq x y' returns y and makes it so as soon as y is evaluated, x is also evaluated?
02:47:27 <pesco> Not quite, x is evaluated as soon as  seq x y  is evaluated.
02:47:29 <nlv11757_> hmmm when i pass openFile a hardcoded string of a file which doesnt exist...it creates it....when im passing the name of the file to write to as a commandline arg....it says: 'Fail: debugger.foo: openFile: does not exist (No such file or directory)'
02:47:51 <a5> isn't that the same thing?
02:48:07 <shrimpx> y might not be evaluated until later
02:48:14 <shrimpx> or at all
02:48:35 <a5> don't you mean y could already be evaluated...?
02:48:48 <a5> s/be/have been/
02:49:02 <Lemmih> nlv11757_: Did you open it in ReadMode?
02:49:07 <nlv11757_> no
02:49:29 <pesco> a5: Right.
02:49:40 <TheHunter> hmm, <lambdabot> seq :: forall a b :: ?. a -> b -> b. What's with the `?'?
02:50:10 <nlv11757_> but can this scenario happen; when i doo 'myprog -d arg file.txt' my program will actually think arg is the real file instead of argument to -d since it is an optional argument
02:50:31 <pesco> TheHunter: Interesting question. My ghc 6.2.2 prints  seq :: forall b a. a -> b -> b
02:51:11 <TheHunter> my ghc 6.2.2 printed the `?
02:51:26 <TheHunter> But after a restart, it doesn't do so anymore. Lemme further investigate.
02:51:36 * pesco looks puzzled.
02:51:39 <nlv11757_> Lemmih: i found out what the problem is my -d had an optional argument, but when i left it out....it thought file.txt was the optional argument :S
02:51:40 <Lemmih> nlv11757_: What are you using to parse the cmd args?
02:52:15 <TheHunter> oh, sorry. :i prints the `?', :t doesn't. Perfectly reproducible.
02:53:05 <Lemmih> It's not there in ghc-6.4.20050219
02:53:49 <TheHunter> 6.4.20050303: seq :: forall a (b::?). a -> b -> b
02:54:09 <nlv11757_> Lemmih: im using GetOpt
02:54:10 <TheHunter> ? seems to be some sort of kind.
02:54:16 <Walker> www.otomotivshow.com
02:54:31 <nlv11757_> Lemmih: but the optional argument took my last argument as it
02:54:34 <nlv11757_> s argument
02:54:43 <vegai> sheehs
02:54:45 <Lemmih> Shouldn't we ban that spammer?
02:54:45 <nlv11757_> pretty logical
02:55:20 <vegai> is it from the same IP every time?
02:56:07 <TheHunter> yep, "open kind"
02:56:16 <nlv11757_> zz@85.99.26.205, zz@85.97.91.116
02:56:20 <nlv11757_> these are different
02:57:36 <vegai> 85.* would be too rough?
02:57:54 <musasabi> it is one turkish isp
02:58:22 <Itkovian> kcik his ass
02:58:32 * Itkovian can't type anymore
03:01:55 <TheHunter> "foo :: forall (a :: ?). a -> a" produces a parse error...
03:03:58 <shrimpx> what's an open kind?
03:05:52 <TheHunter> may be either lifted or unlifted.
03:06:12 <shrimpx> hmm
03:06:23 <nlv11757_> aren't those only present internally?
03:07:10 <TheHunter> yes there are. But :i seq reveals them.
03:08:06 <shrimpx> oh it means it can be either boxed or unboxed...
03:08:48 <shrimpx> http://www.haskell.org/pipermail/glasgow-haskell-users/2003-October/005923.html
03:09:01 <TheHunter> i'm not 100% sure that the terms coincide, but they're pretty close.
03:10:16 <shrimpx> that kinda makes sense
03:10:24 <shrimpx> (no pun intended)
03:11:21 <a5> now my program is segfaulting :(
03:11:30 <shrimpx> wha
03:11:56 <a5> "+RTS -hy -hbvoid" segfaults
03:11:56 <TheHunter> in core, you can actually give type variables that kind, but the use of it seems a little restricted...
03:12:04 <Heffalump> there's no way of defaulting a class other than Num or a subclass of it, is there?
03:12:44 <vegai> is it possible for ghc to output slightly smaller binaries in the future?
03:13:28 <vegai> for example, I have tuomov's riot, which is a rather simple program
03:13:35 <vegai> stripped, the binary is 874644 bytes
03:14:37 <vegai> there isn't anything in the language that requires huge binaries, is there? :-)
03:15:01 <TheHunter> Heffalump, think it's impossible.
03:21:53 <a5> so -hd gives closure description as HashHeap.sat_s2zh, what do I do with this? the .prof file is empty
03:22:49 * vegai tests if ghc-6.4 does better
03:25:01 <Lemmih> vegai: Check nhc and upx.
03:25:22 <vegai> upx?
03:25:32 <vegai> ah
03:26:08 <vegai> does really any haskell project compile on nhc?
03:26:15 <vegai> expect those specifically made for it
03:26:57 <vegai> (Yeah, I know, Haskell98 yadda yadda)
03:27:03 <Heffalump> grrr.
03:27:25 <ibid> vegai: i believe the biggest problem is the lack of dynamic linking
03:27:32 <ibid> (or is it solved already?)
03:28:18 <ibid> hm, does ghc link foreign libraries dynamically if available?
03:28:41 <vegai> Lemmih: it's not that I need something that does this *today*. I'm just wondering really
03:29:00 <vegai> ibid: I hope to find out soon :)
03:31:58 <pesco> ibid: I think GHC support for shared Haskell libraries is underway, or am I mistaken.
03:32:10 <pesco> Otherwise, I believe all Haskell code is linked in statically.
03:32:24 <pesco> s/mistaken./mistaken\?/
03:32:35 <ibid> but it seems to link at least the standard foreign libraries dynamically
03:32:45 <Itkovian> any awk people here . #awk seems quiet
03:32:49 <ozone> ibid: it works now on mac os x
03:32:53 <Itkovian> and I've an _urgent_ question
03:32:56 <ozone> there's a wiki page about it if you're interested
03:33:02 <ibid> ozone: what works now on mac os x?
03:33:06 * Itkovian will have to use haskell for evrything soon
03:33:08 <ozone> dynamic linking
03:33:13 <ozone> http://www.haskell.org/hawiki/DynamicLinkingInGhc
03:33:14 <Itkovian> only to have people help when problems arise
03:33:16 <ibid> ozone: of which code?
03:33:36 <vegai> ah, yep
03:33:48 <ozone> you can compile code as system dynamic libraries
03:34:02 <ozone> a long, long overdue feature IMHO
03:34:30 <ibid> ozone: i was mostly wondering about linking foreign code, and dynamic linking there seems to be a standard feature
03:34:37 <Lemmih> Wasn't there some problems with inlining and performance?
03:34:44 <ibid> because static linking is what often creates huge binaries
03:34:57 <ibid> vegai: tried with optimization on?
03:35:27 <ozone> ibid: using the FFI to call system dynamic libraries has worked for quite a while
03:35:55 <ibid> ozone: as i said
03:38:01 <jlouis> what would be a convenient shorthand for (\x -> x a) (a is FV)
03:38:34 <jlouis> thought about: flipApp ed f = f ed
03:38:48 <jlouis> flipApp a
03:39:11 <ibid> that's not much of a *short*hand :)
03:39:22 <jlouis> Maybe the lambda form conveys all the information already
03:39:32 <jlouis> unless there is a standard library function for that
03:39:34 <vegai> FV?
03:39:39 <jlouis> Free Variable
03:39:45 <jlouis> not bound in the lambda expression
03:40:11 <vegai> oh, righ
03:40:22 <Lemmih> @type flip ($)
03:40:23 <TheHunter> what's wrong with ($ a) ?
03:40:24 <lambdabot> flip ($) :: forall b b1. b1 -> (b1 -> b) -> b
03:40:49 <ibid> where do you expect to use it? (i'd probably just define a scratch function for the result in practice)
03:41:08 <vegai> whoa
03:41:09 <vegai> ghc-6.2.2: internal error: evacuate: strange closure type 57552
03:42:45 <a5> so there's no way to turn "HashHeap.sat_s2zh" into something useful? so close but yet so far...
03:43:29 <TheHunter> zh is the z encoding for `#', but I doubt that helps.
03:43:52 <a5> z encoding?
03:45:29 <TheHunter> when translating to core, all special characters are transformed to z encoded form. # -> zh, $ -> zd, ' -> zq, etc.
03:46:35 <a5> but there's no '#' in my file
03:46:43 <TheHunter> do you have sat_s2?
03:47:55 <a5> no, "Binary file HashHeap.o matches" but that's all
03:48:54 <TheHunter> you wrote HashHeap, right?
03:49:34 <a5> yeah
03:50:24 <TheHunter> maybe the usual -p profile shows you which function called the mysterious sat_s2zh.
03:54:45 <a5> it doesn't show up in .prof
03:54:57 <a5> do i need extra options to include more functions?
03:58:39 <a5> well i know what function it's in from -hc, maybe i'll split it into more functions or add cost center annotations
03:58:51 <a5> but now to sleep, thanks for the help
03:58:58 <TheHunter> good night.
04:04:52 <jlouis> TheHunter: ($ a) is nice ;)
04:05:53 <metaperl> how can I get this to work: [(x,y) | x <- [1,2,3], y <- [4,5,6]];
04:06:11 <b0gg1e> hi all.
04:06:19 <Lemmih> By typing it in a Haskell interpreter?
04:06:59 <metaperl> it works fine if I manually type it in but :l nl.hs fails
04:07:04 <metaperl> complaining of possible indentation error
04:07:27 <shrimpx> is it prefixed with "foo = " ?
04:07:33 <metaperl> oh, I have to assign it to something
04:07:36 <metaperl> no it wasnt
04:12:20 * Lemmih feels so dirty for using GHC.PrimopWrappers /-:
04:15:24 <Lemmih> *sob* No unboxed tuples with TH.
04:19:00 <b0gg1e> im looking for a good paper on functional dependencies
04:19:16 <b0gg1e> the ghc docs are a bit sparse on the topic.
04:19:47 <musasabi> there is no good accurate documentation.
04:20:08 <shapr> I didn't do it!
04:20:19 * shapr awakens from a bad dream
04:20:32 <shapr> ahem, good morning #haskell!
04:20:40 <metaperl> good morning shapr
04:20:47 <shapr> wazzup?
04:20:48 <Muad_Dibber> good morning shapr  :)
04:20:57 <metaperl> I have the Algorithms in Haskell book... hope to starting reading in a few
04:22:02 <shapr> I like that book.
04:22:44 <mflux> are there nice (short) examples of building actual applications on haskell?
04:23:06 <mflux> I must admit I haven't really got around on doing anything on haskell, but it would seem to me building algorithms isn't that much different from, say, ocaml
04:23:44 <metaperl> Ocaml is not a pure functional language. It is not lazy either
04:24:08 <Muad_Dibber> they were to lazy to make it lazy right?
04:24:09 <mflux> yes, but I avoid non-pure stuff in algorithms anyway
04:25:35 <vegai> you can do lazy stuff with it, though
04:27:03 <metaperl> yes and you can do eager stuff in Haskell too
04:28:49 <shapr> mflux: You could look at boegel's memory application, that might get you started. It's a memory card-matching game.
04:29:06 <shapr> Simon Marlow's hws is nice, but slightly crufty, and not that small.
04:29:57 <mflux> shapr, hmh, any pointers in the form of url or keywords?-)
04:30:06 <shapr> One surprising facet of Haskell is that the average application is *really tiny* in code size compared to any other language I've used.
04:30:47 <metaperl> mflux  , buy Hudak's book
04:30:54 <metaperl> or read the code of Haskore
04:31:10 <Muad_Dibber> haskore?
04:31:45 <shapr> http://cvs.haskell.org/darcs/haskore/
04:31:54 <shapr> older version - http://www.haskell.org/haskore/
04:32:30 <metaperl> darcs is what got Autrijus into Haskell? did you see perl.com interview today? It was pretty good
04:32:52 <metaperl> it talked about how Haskell scaled linearly for an app Autrijus wrote
04:33:06 * Lemmih wonders why his generated binding is 6.5 times bigger than the handwritten one.
04:33:09 <metaperl> no question mark: darcs is what got Autrijus into Haskell
04:33:55 <b0gg1e> shapr - btw thanks for posting GK to your delicious feed, just what i was looking for.
04:34:03 <shapr> GK?
04:34:06 * shapr looks
04:34:17 <b0gg1e> ah sorry gf grammatical framework
04:34:47 <shapr> oh, credits to bringert for all the work he's done on GF.
04:34:51 <bringert> morning shapr
04:35:01 <shapr> g'mornin bringert
04:35:15 <bringert> shapr: we'll probably release a new version soon
04:35:47 <bringert> can't remember what was in the last release but latey there have been a bucnh of goodies added
04:36:17 <shapr> I look forward to it.
04:36:21 <bringert> multiple module inheritance, memory optimization, module dependency visualization, better parsing etc.
04:36:31 <b0gg1e> a friend of mine (whos is currenlty stuying law) is constantly asking me for nlp tools, because he wants to try tro process and analyze juristical documents.  he cant really program and this looks like a good opportunity to point him towards haskell :-)
04:36:34 <shapr> I keep meaning to get back to my basic swedish teaching webapp.
04:37:06 <shapr> That's a neat idea, he could mix it with SPJ's financial contracts work and come with something particularly useful.
04:37:29 <shapr> In fact, making formal descriptions of law systems just might turn up a nice Gödel attack on the patent system.
04:38:27 <b0gg1e> hmm that's a good point, with the EU democracy being in such a bad shape, this could turn out to be really useful.
04:39:15 <shapr> I am extremely unhappy about that.
04:39:36 * b0gg1e fully agrees.
04:40:26 <shapr> One of the largest reasons I haven't moved back to the US is the mafia-esque laws there. I had hoped that the EU would resist that.
04:40:33 <b0gg1e> btw  to what extent is freedom of science a protection from that?  or do we already have to hide behind anonymizer networks like thor in the future to gift people with open source?
04:40:49 <shapr> I predict tor and more.
04:41:51 <b0gg1e> china could play an doubtful but interesting role in that game, they use linux a lot.  also big guys like ibm promised patent protection for open source. of course, this gives them way to much control.
04:42:22 <bringert> I hope the parliament is going to get really pissed off about what the commision is doing and overturn the decision, whough they need an absolute majority to do it
04:42:36 <vegai> South America, perhaps Africa?
04:42:43 <rtega> well, the last vote on the issue was exactly about that
04:42:47 <rtega> the lack of power of parliament
04:43:17 <rtega> and given the fact that commission simply denies everything the parliament said the last time there's a lot of reason to vote the beast away once more
04:43:26 <b0gg1e> hope they're smart enough to realize that they have to win this one, if they won't to be taken seriously in the upcoming eu suprastate.
04:43:30 <shapr> I don't have much faith in any decision requiring a majority.
04:43:32 <mflux> so, would 'The Craft of Functional Programming' be a useful with the mentioned hudak's book, or do they have much overlapping?
04:44:00 <shapr> mflux: craft is more a step by step approach, hudak requires more math background, but will get you moving faster.
04:44:12 <shapr> I'd say Hudak is higher level all around.
04:44:28 <shrimpx> i hate that stupid book
04:44:30 <mflux> :-)
04:44:56 <metaperl> mflux, if you want to learn application building, help us write Perl 6
04:44:57 <shapr> er, which book?
04:45:00 <dblhelix> question: how would one call a value that does not contain any _|_ values nor is one itself?
04:45:01 <b0gg1e> i hope to get it along with some other haskell books in a week from amazon :-)
04:45:05 <metaperl> we are are doing so in Haskell
04:45:06 <shrimpx> hudak's
04:45:22 <metaperl> we have a living codebase
04:45:35 <metaperl> plenty of monad usage
04:45:43 <metaperl> Parsec for parsing
04:45:51 <metaperl> svn and darcs and svk for version control
04:45:53 <bringert> dblhelix: a total value maybe?
04:45:55 <shapr> Yeah, I'd agree with that. Learn by doing, jump in and swim.
04:46:25 <metaperl> just run through YAHT and join us on #perl6
04:46:43 <shrimpx> most haskell literature is idealistic hippie crap that has almost nothing to do with reality
04:46:50 <mflux> it's just that for the things I'm doing it's very easy to slip into using ocaml, so starting with haskell has become more difficult ;)
04:47:04 <shapr> idealistic hippie crap?
04:47:15 <shapr> Can you give me a description I can unit test? :-)
04:47:15 <b0gg1e> *g*
04:47:23 <shrimpx> haha
04:47:45 <shapr> Specifically, what do you not like about Hudak's book?
04:48:17 <shrimpx> so i read that book and understood pretty much everything. but i was _far_ from being able to write programs that i could write in say, perl
04:48:29 <shrimpx> representing sets as functions is ... cute
04:48:34 <musasabi> One can write C in haskell, only it is not very pretty.
04:48:37 <shrimpx> but helps me not
04:48:55 <musasabi> learning real code comes from reading real code.
04:49:05 <shrimpx> yea :)
04:49:10 <dblhelix> bringert: mmm ... doesn't sound bad ... until now the best I could do was "completely defined value"
04:49:34 <tromp> a normal form
04:49:40 <shapr> Hm, I can write more programs in Haskell than I can in Perl.
04:49:52 <shrimpx> i can too. not thanks to hudak
04:49:54 <shapr> In fact, someone is writing Perl in Haskell, so...
04:50:13 <musasabi> writing anything longer than a single line is complex in perl.
04:50:18 <shapr> So how did you learn to write Haskell programs? What improvements would you suggest?
04:51:42 <dblhelix> tromp: some people use "value" and "normal form" as synonyms ... that might be confusing, although it is probably the best suggestion
04:52:07 <shrimpx> i would like to see a "by example" treatise. working with xml, coding client/server apps, etc.
04:52:28 <shrimpx> lots of stuff like that for java, and very useful
04:52:51 <shapr> shrimpx: Well, write an outline and a summary, and put it up on the wiki. Fill in a few of the 'by example' parts. I'm sure others will chip in and help.
04:52:58 <jlouis> shrimpx: I would propose that a ``by example'' approach to understanding programming is bad.
04:53:06 <dblhelix> shrimpx: but that would perhaps give a wrong expression of haskell as a language, I'd pick something Haskell is particulary strong at: parser combinators perhaps
04:53:13 <Philippa_> jlouis: it's bloody useful for getting a quick showing around a pile of libs
04:53:31 <Philippa_> dblhelix: in the real world, people want client/server apps
04:53:36 <Philippa_> also, Haskell's actually rather good at them
04:53:45 <Philippa_> well, GHC-Haskell is
04:54:09 <Muad_Dibber> haskell is good at a lot of things :)
04:54:14 <shrimpx> well taht's what hudak did :) haskell is particularly good at letting you represent sets as functions =) there's much more to life than parser combinators and cute higher order tricks.
04:54:33 <shrimpx> i'd say haskell is a very good all around language and someone's yet to make a case for it in a book
04:54:48 <dblhelix> Philippa_: well, Haskell is, but somehow I think of client/server apps too complex for learning the language
04:55:31 <Philippa_> there's learning the language and there's learning how to do stuff
04:55:45 <Philippa_> finding out the latter can be hard if you don't already know stuff
04:56:07 <Philippa_> and if you haven't seen it, it's easy to think that eg Haskell has bad IO (it doesn't)
04:56:19 <musasabi> shrimpx: actually most of the time I find my real apps revolve around finding the right set of combinators and hofs for the task and then defining the app in terms of them.
04:56:32 <dblhelix> yeah, I think there's a definite trade-off there
04:56:39 <Philippa_> musasabi: you too?
04:56:45 <Philippa_> dblhelix: there's much "learn the language" material out there
04:56:51 <Philippa_> there's less "learn the libs/how to do things" material
04:57:43 <shapr> musasabi: yeah, me too.
04:57:51 <shapr> Find the basic pattern, and you're 99% done.
04:58:50 <dblhelix> Philippa_: well, there might be a need for such material, then ... :) ... but as an addition on material for learning the language ... not as a replacement
04:59:17 <dblhelix> therefore, I don't think Hudak's book is bad, because it isn't on writing real-world apps
05:00:20 <dblhelix> if one wants a book on how to write real-world apps, one should get one ... one should not blame a learning book for not being a real-world apps book
05:00:26 <shrimpx> so i think the oreilly perl series is good stuff. learning perl introduces you to the language. programming perl takes that two notches further. the perl cookbook shows you how to solve problems
05:00:35 <shrimpx> haskell has lots of 'learning haskell' books and not much else
05:00:42 <Philippa_> dblhelix: "learning to write real world apps", possibly?
05:01:20 <dblhelix> Philippa_: :)
05:01:37 <shapr> I think that's because most people who learn Haskell already know how to program in another language. Once you've learned Haskell, you can port your knowledge from another language into Haskell.
05:01:51 <shapr> But that's not so good for those who have Haskell as the first language.
05:01:53 <dblhelix> shrimpx,Philippa_: so I think a real-world apps book is definitely a good idea
05:02:14 <Philippa_> shapr: you're still left short in terms of "here's what our libs look like and what they can do"
05:02:17 <shrimpx> not really. pure functional programming is a totally different beast than C and Perl banging
05:02:32 <Philippa_> it took me days of research to find basic libs suitable for writing Flippi with. That should not have been the case.
05:02:41 <shrimpx> and new FP programmers don't know how to approach problems "the functional way"
05:03:13 <Philippa_> a lot of the domain problems don't get approached any more functionally than they would otherwise. The mess that's perl's parsing aside :-)
05:03:21 <shapr> shrimpx: in that case, I think you should write up an outline and summary and fill in a few examples, and put the whole thing on the Wiki
05:03:31 <shrimpx> k
05:03:49 * Philippa_ suggests Flippi 0.02 be linked as a CGI example
05:03:52 <shapr> Even a rough fifteen line summary that's a copy of PLEAC.sf.net would be an improvement.
05:03:58 <Philippa_> anyway, 'moff
05:04:54 <shapr> shrimpx: Have you read the "Algorithms: An FP Approach" by Rabhi and Lapalme?
05:06:02 <shrimpx> shapr: not yet. it's coming
05:06:12 <shapr> I was just thinking I'd like that approach in an real-world introduction.
05:06:55 <shapr> My favorite part of that book is that it gives you the gorgeously simple easy to read and not very efficient version first, then it shows you how to turn that into something faster and more efficient but less readable.
05:07:28 <shrimpx> yea that's a good approach in general
05:08:10 <shapr> So for "Shrimp's Guide to Real World Haskell" the same thing could be done.
05:08:38 <shrimpx> haha
05:09:23 <shrimpx> i'll think about it while i regenerate for a few hours
05:09:24 <b0gg1e> i like the idea, too,  such a project would help finding areas where haskell is lacking.
05:09:31 <b0gg1e> (in terms of libraries)
05:09:56 <b0gg1e> so along with showing beginners how to get things done it also shows what needs to be coded.
05:10:06 <vdrab> how about dedicating a part of the hawiki to that end? just a thought...
05:10:51 <vdrab> someone suggests a frequent real-world problem... and the gurus hack away at it, for fame and bragging rights... i'd be grokking it.
05:11:12 <b0gg1e> for example i would like to try doing declarative low-level network programming.  this could turn out to be real fun, using pattern matching on packets.
05:11:31 <metaperl> I find wikis hard to navigate and deficient in hierarchy
05:11:42 <vegai> so, I guess the large binary size of ghc output is bound to be fixed in some hazy point in the future?
05:12:16 <vdrab> meta : true, but for quickly generating momentum for a document like this the format's hard to beat
05:13:29 <vdrab> well, just a thought really.
05:13:38 <b0gg1e> how do i create dynamic versions of the libraries.  compilig with ghc -dynamic gives "ld: can't locate file for: -lHShaskell98_dyn"
05:13:57 <b0gg1e> (im using a recent ghc 6.4)
05:19:42 <shapr> I'd like a wiki setup as well.
05:26:31 <scalopus> hi
05:31:16 <shapr> y0
05:43:30 <shapr> hi hal
05:49:37 <Lemmih> Deriving Enum is not as simple as I thought.
06:36:44 <djo> hello coud someone help me
06:36:54 <djo> I have this simple program
06:37:09 <djo> that I found in a tutorial
06:37:20 <djo> data Pair a b = MkPair a b
06:37:29 <djo> getA :: Pair a b -> a
06:37:42 <djo> getA MkPair x y = x
06:37:54 <djo> main :: IO ()
06:38:03 <djo> main = do putStr $ getA MkPair "aa" "bb"
06:38:40 <djo> when I compile it ghc says "Constructor `MkPair' should have 2 arguments, but has been given 0"
06:38:46 <kosmikus> if you found this in a tutorial, the tutorial is wrong
06:38:51 <kosmikus> which tutorial is it?
06:39:49 <djo> the tutorial explained who t create types xith contructors
06:39:58 <djo> how to create
06:40:21 <djo> and I just added the mais function
06:40:38 <djo> all but the main function are taken from the tutorial
06:40:51 <djo> so what I missing
06:41:25 <djo> the compilation error is in the definition of the "getA" function
06:41:32 <djo> ?
06:42:13 <djo> haskell is driving me crazy
06:43:07 <djo> all I want to do is to show the firts part of a pair
06:43:19 <norpan_> you are missing parenthesis
06:43:30 <norpan_> getA (MkPair "aa" "bb")
06:43:39 <ibid> you need to add either a $ before MkPair in main or what norpan_ said :)
06:44:40 <djo> the problem now is in the definition of my getA fnction
06:44:52 <norpan> apply parenthesis there too
06:45:22 <norpan> parentheses in plural?
06:45:35 <djo> somthing like getA (MkPair x y) = x ???
06:45:39 <norpan> yes
06:45:42 <Cale> djo: yeah
06:46:54 <djo> it complies but when I execute the thing it shows nothing :@
06:47:20 <djo> he have to print "aa" no ?
06:47:40 <Spherical`> Eww, plain milk and coffee is disgusting, sweet and dazzling.
06:47:47 <norpan> try putStrLn
06:48:18 <Cale> It works for me
06:48:29 <Cale> but yeah, try putStrLn
06:48:37 <djo> norpan, yes with putStrLn
06:48:46 <djo> but what is the difference ?
06:49:23 <Cale> It might be that your terminal is strange and overwriting the last line of output with the prompt if it wasn't terminated with a newline
06:49:48 <norpan> maybe you see aa before your prompt though
06:50:03 <djo> ah ha!!!
06:50:09 <Cale> (I get aa before my prompt)
06:50:15 <djo> an to print a list what function should I do ?
06:50:29 <Cale> you can just pass the list to show
06:50:51 <tromp>  getA MkPair x y = x   looks wrong
06:51:03 <norpan> tromp: that's because it is wrong
06:51:06 <Cale> tromp: it is, he fixed it
06:51:09 <djo> :D
06:51:13 <tromp> ok:)
06:51:14 <djo> yes I fixed it
06:51:17 <Cale> or you can "mapM_ print ls"
06:51:24 <Cale> where ls is your list
06:51:34 <norpan> gah
06:51:35 <norpan> ugly
06:51:40 <Cale> which will print each item in the list on a new line
06:51:47 <norpan> putStr (unlines ls)
06:52:11 <Cale> norpan: putStr (unlines (map show ls))
06:52:23 <Cale> if you want to do the same thing :)
06:52:29 <norpan> i thought ls was a list of strings
06:52:33 <Cale> oh
06:52:42 <Cale> then I wouldn't have used print on them :)
06:53:18 <norpan> you can simply do print ls as well
06:53:32 <norpan> that will show you the list using [ and , and ]
06:53:48 <Cale> mhm
07:04:12 <nlv11757_> who has ideas about a naming scheme; I need to generate datatypes for tupels.....so e.g. instead of (Int, Foo) i would generate a new datatype; data IntFoo = IntFoo Int Foo.....
07:04:35 <nlv11757_> this scheme however classes easily because a datatype can't be named IntFoo without causing name clashes
07:04:50 <nlv11757_> s/classes/clashes/
07:07:00 <tromp> use a prefix, e.g. ANCIntFoo
07:07:21 <nlv11757_> a freaky prefix not commonly used
07:07:30 <tromp> AvoidNameClash
07:07:40 <nlv11757_> :)
07:08:05 <nlv11757_> damn, some times the solutions are so simple I don't see them :D thanx.
07:08:21 <bringert> or you could put them in separate modules, and use Haskell's facilities for qualified names
07:08:41 <bringert> if there is some sensible way to divide them into modules
07:09:24 <nlv11757_> hmm module solution won't work nicely because I'm basically generating a lot of datatypes and don't want to clash with user defined ones in the same module
07:10:09 <jlouis> @index peekByteOff
07:10:09 <lambdabot> Foreign,Foreign.Storable,Storable
07:11:19 <nlv11757_> I think im going to use ICP instead of ANC as a prefix though tromp ;)
07:12:21 <Oeje1> nlv11757_: I Curse Prefixes?
07:12:38 <nlv11757_> hehehe creative but no: Insane Clown Posse
07:12:40 <nlv11757_> :P
07:18:15 <tromp> SYS
07:18:51 <nlv11757_> que?
07:19:02 <tromp> SuitYouSelf :)
07:19:07 <tromp> YourSelf
07:19:09 <nlv11757_> :)
07:30:20 <jlouis> (\x -> return $ fromIntegral x) <-- any shorter version in the stdlib?
07:30:29 <jlouis> it is not a liftM ;)
07:31:07 <jlouis> the code is actually: {#somefficall#} >>= (x -> return $ fromIntegral x)
07:31:19 <Igloo> (return . fromIntegral)
07:31:29 <jlouis> mmm
07:31:30 <jlouis> nice
07:31:32 <jlouis> thanks
07:31:56 <jlouis> of course it is a function composition
07:32:03 <TheHunter> fromIntegral `fmap` {#somefficall#}
07:35:13 <Igloo> Or liftM instead of fmap
07:36:53 <CosmicRay> that perl.com interview with autrijus was great
07:37:12 <autrijus> thanks :)
07:37:19 <CosmicRay> :-)
07:37:25 <autrijus> hopefully I did some haskell advocacy :)
07:37:39 <autrijus> and hopefully not as much as darcs deadvocacy as I feared.
07:37:55 <CosmicRay> I found all your comments to be quite fair.
07:38:21 <CosmicRay> I don't use darcs for the very reasons you cited.
07:38:25 <_metaperl> the article also made me really interested in svk
07:38:39 <_metaperl> what were the reasons about darcs? I forgot.
07:39:03 <metaperl> ping
07:39:12 <autrijus> metaperl: the dependency analysis algorithm, mostly
07:39:48 <CosmicRay> autrijus: I am curious about the number of perl and the number of haskell hackers you have working on pugs.
07:39:59 <tuomov> I've been thinking it might be better for patches to store their dependencies, and to record both a version of the patch that applies to current context, and a version that applies to the dependencies, and sign this version
07:40:21 <autrijus> tuomov: that is what I have in mind for SVK 1.1 (or 2.0).
07:40:46 <autrijus> CosmicRay: I don't have a hard number, and perl hackers are gradually haskellizing :)
07:40:52 <autrijus> CosmicRay: but I'd say about 4:1 right now
07:41:13 <tuomov> record would become a bit slower, but I don't think it would really show up here, and this might speed up other operations
07:41:19 <CosmicRay> autrijus: I was just curious, since you referred to the camels and the lambdas.  (which was a great metaphor)
07:41:28 <tuomov> plus enable signing of patches
07:41:51 <autrijus> CosmicRay: my custom greeting on #perl6 is "greetings lambdacamels."
07:41:58 <CosmicRay> autrijus: heh
07:42:04 <tuomov> but I'm not really privy to the inner workings of darcs
07:44:08 <tuomov> I've been meaning to post some thoughts on the list but haven't got around to properly writing them up...
07:47:05 <jlouis> TheHunter, Igloo: liftM fromIntegral {#some-ffi-call#} it is then. Thanks
07:51:13 <metaperl> the algorithms book has given me foldr / foldl fever
07:51:30 <metaperl> please help me get this folding implementation of filter working
07:51:31 <metaperl> filfold p []     = []
07:51:31 <metaperl> filfold p lis    = foldr (\seed elem -> | p elem = elem:seed
07:51:31 <metaperl>                                         | True   = seed ) [] lis
07:51:31 <metaperl>  
07:52:18 <metaperl> I'm not sure if guards work in anonymous functions
07:52:42 <TheHunter> nope.
07:53:07 <metaperl> so I'd have to use if-then-else
07:53:09 <metaperl> gah
07:53:23 <TheHunter> i'd suggest foldr f where f | ... = | ... = ...
07:53:41 <Igloo> You also have the arguments to foldr's function the wrong way round
07:53:59 <metaperl> oh you mean you get the list element and then the seed/running result
07:54:13 <metaperl> TheHunter, your suggestion is not explicit enough for me
07:54:28 <TheHunter> filfold p lis = foldr f where
07:54:41 <TheHunter>   f seed elem | p elem = ...
07:54:44 <TheHunter>   f ...
07:54:55 <metaperl> oh I see
07:55:36 <TheHunter> and you don't need the [] case.
07:58:19 <metaperl> Bingo. somebody bring the medics. I have fold fever
07:59:01 <bourbaki> is there any planner for haskell?
08:00:08 <autrijus> planner..?
08:00:27 <bourbaki> something like strips
08:04:54 <CosmicRay> w00t, FSM has accepted my Haskell article.
08:05:03 <autrijus> FSM?
08:05:10 <CosmicRay> freesoftwaremagazine.com
08:05:17 <boegel> CosmicRay: article on what ?
08:05:25 <boegel> just Haskell in general?
08:05:31 <metaperl> congratulations CosmicRay
08:05:35 <CosmicRay> boegel: introducing haskell to programmers that haven't heard of it
08:06:10 <CosmicRay> boegel: my suggested title was "Haskell: A Very Different Language" and I think they're going to go with it :-)
08:06:51 <metaperl> i'm still pondering shapr's comment that Haskell was good for defining domain-specfiic languages
08:07:03 <CosmicRay> metaperl: it is
08:07:04 <metaperl> i finished yaht (pretty much) and did not see any hint of that
08:07:07 <metaperl> examples?
08:07:19 <CosmicRay> metaperl: have you worked with parsec at all?
08:07:27 <metaperl> no not yet.
08:07:33 <metaperl> i have it installed via Debian
08:07:38 <CosmicRay> metaperl: http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html
08:07:40 <metaperl> it is here... awaiting my commands
08:07:43 <CosmicRay> metaperl: it comes standard with ghc6 these days
08:07:57 <CosmicRay> metaperl: anyway, there is some debate sometimes about just what constitutes a dsl
08:08:08 <CosmicRay> metaperl: for instance, some claim the HaXML is a dsl
08:08:26 <CosmicRay> metaperl: even though you are just using plain haskell to do it.
08:08:34 <metaperl> I need a link to that IBM article on haxml
08:08:35 * metaperl googles
08:08:56 <metaperl> http://www-106.ibm.com/developerworks/xml/library/x-matters14.html
08:09:19 <CosmicRay> metaperl: there is also wash, which implements a haskell pre-processor for embedding xhtml in haskell programs
08:09:52 <metaperl> why would you want to embed xhtml into a haskell program?
08:10:00 <CosmicRay> metaperl: wash is a framework for writing webapps
08:10:20 <metaperl> i think you meant embed haskell in xhtml?
08:10:28 <CosmicRay> metaperl: no, embed xhtml in haskell :-)
08:10:29 <autrijus> metaperl: it's a continuation-based framework.
08:10:33 <CosmicRay> let me get you an example
08:10:36 <autrijus> well, it isn't really, but it can mock one.
08:10:45 <autrijus> metaperl: so you can write web apps just like normal apps.
08:10:48 <metaperl> i'm goggling
08:10:49 <autrijus> i.e. with usual flow control stuff.
08:10:57 <autrijus> metaperl: see "seaside".
08:11:12 <CosmicRay> autrijus: well, not "just like", the inability to return a value from a form submissions is annoying to me (it works only with the continuation style)
08:11:37 <CosmicRay> the wash homepage seems to be down right now
08:11:40 <autrijus> CosmicRay: I think it should be all in a ContT.
08:11:51 <CosmicRay> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
08:11:54 <autrijus> it is one of my goals to make Pugs support serializable continuations natively.
08:12:07 <autrijus> and thereful able to do wash/seaside like stuff easily.
08:12:24 <metaperl> that website is hung at the moment
08:12:24 <autrijus> which, actually, is not hard because the Eval is in a ContT anyway :)
08:13:15 <CosmicRay> metaperl: then if you expand the definition of dsl in the other direction, you get things like the configuration system used in Cabal or my ConfigParser module, which are barely dsl's, but hey.
08:13:47 <CosmicRay> promptCGI _ =
08:13:55 <CosmicRay>     standardPage "Your name, please"
08:13:55 <CosmicRay>        <div>
08:13:55 <CosmicRay>          <p>Enter your name <% iName <- textInputField empty %></p>
08:13:55 <CosmicRay>          <p><% submit iName showResult empty %></p>
08:13:55 <CosmicRay>        </div>
08:13:57 <metaperl> I have a scary feeling that Perl 6 and Haskell are going to be more wed together than they currently are
08:13:58 <boegel> CosmicRay: neet ! do you mention #haskell as a source of Haskell information ? :)
08:14:06 <metaperl> wow
08:14:35 <CosmicRay> boegel: unfortunately not, I was already 200 words over their limit :-)
08:14:42 <CosmicRay> showResult iName =
08:14:42 <CosmicRay>     let name = value iName in
08:14:49 <boegel> CosmicRay: oh, that's a pitty...
08:14:50 <CosmicRay>         standardPage "Hello"
08:14:50 <CosmicRay>           <#>Hello <%=name%>, how are you?</#>
08:14:50 <metaperl> unfortunately that conflicts with my design philosophy for web apps. which is to give all HTML design decisions to the HTML authorers
08:15:04 <boegel> s/pitty/pity ? (which one is correct ?)
08:15:05 <metaperl> that is amazing that he can do that though?
08:15:28 <CosmicRay> metaperl: someone has also ported TAL to haskell, although afaict it currently does static pages only
08:15:52 <Lemmih> Halipeto?
08:16:02 <CosmicRay> metaperl: I agree with you in general, but for one-person projects where the "design" is where to put the <br> tags, wash served me well :-)
08:16:14 <CosmicRay> Lemmih: maybe, I'm not sure if that's the one I'm thinking of or not
08:16:24 <autrijus> metaperl: see Cocoon.
08:16:29 <metaperl> TAL also conflicts with my philosophy
08:16:37 <autrijus> you can call out to xhtml design things to htmlfolks.
08:16:41 <Lemmih> I hacked a dynamic version of Halipeto which is used in Hackage.
08:16:51 <metaperl> I am of the xmlc school
08:16:51 <autrijus> but still use them as proper templates
08:16:55 <metaperl> Halipeto?
08:17:03 <autrijus> in cocoon's case, they use javascript with serializable continuations
08:17:04 <metaperl> Cocoon? I am being flooded
08:17:07 <autrijus> ("Rhino")
08:17:10 <CosmicRay> metaperl: heh
08:17:13 <metaperl> xmlc uses DOM
08:17:20 <metaperl> HTML::Seamstress uses HTML::Tree
08:17:21 <autrijus> to control all the logic that happens between xml calls.
08:17:24 <CosmicRay> metaperl: I was going to show you how the wash preprocessor converts this stuff to haskell :-)
08:17:34 <metaperl> CosmicRay, that's OK
08:17:49 <CosmicRay> it's pretty slick, they have essentially an xhtml monad.
08:18:24 <metaperl> halipeto is similar to TAL --- an embedded mini-language
08:18:38 <autrijus> metaperl: see these:
08:18:39 <autrijus> http://cocoon.apache.org/2.1/userdocs/flow/continuations.html
08:18:43 <autrijus> http://cocoon.apache.org/2.1/userdocs/flow/tutor.html
08:18:46 <metaperl> XMLC is pure HTML and pure Java. HTML::Seamstress is pure HTML and pure Perl
08:18:56 <autrijus> the sendPageAndWait thing in Coon is wonderful.
08:19:09 <autrijus> s/Coon/Cocoon/
08:19:13 <autrijus> and I think I'll base the Pugs WebCont framework on that and seaside.
08:20:01 <autrijus> the code snippets in first link alone is worth a lot of words.
08:37:16 * boegel leaves
08:46:53 <metaperl> if I say data Tree a = Node a [Tree a] to define an n-ary tree, how can I subtype this by placing a constraint on it that the length of the Tree List is between 0 and 2?
08:47:11 <metaperl> thereby deriving a binary tree subtype from the n-ary tree type
08:47:57 <autrijus> that is an excellent question. :)
08:48:22 <Oeje1> I like the idea behind the Beautiful Report Language.  Scheme imbedded in HTML like: <html><body>The sum is [(+ 3 x)] and the product is [(* y 6)]. </body></html>.
08:48:26 <autrijus> I don't think it's easily done in trivial haskell.
08:48:35 <metaperl> I'm good at asking questions. Now creating answers is another story :)
08:49:02 <shapr> I love unicycling, but I may have overdone it a bit today.
08:49:18 <metaperl> does something hurt shapr
08:49:38 <autrijus> metaperl: actually, with such a signature, I'd be surprised that it can be constrained in length at all.
08:49:39 <shapr> Yes, I feel slighly sick. That usually means I pushed myself too hard.
08:49:44 <tromp> what do you mean by subtyping, metaperl?
08:49:45 <autrijus> without some serious metaprogramming foo.
08:49:56 <Lemmih> shapr: No pain, no gain. (:
08:50:04 <metaperl> I just meant deriving a binary tree type from an n-ary tree type
08:50:24 <tromp> it will be a different type then
08:50:24 <metaperl> shapr, what country are you in?
08:50:27 <shapr> Lemmih: yeah, I went part of the way up the road to the local ski slope.
08:50:30 <autrijus> you can't in general derive a type. you can derive a class :)
08:50:42 <shapr> metaperl: I'm in the north Sweden, ~1000km north of Stockholm.
08:50:58 <shapr> 40 miles south of the Arctic Circle, if you're using US distance units.
08:50:59 <metaperl> nice and warm there I bet
08:51:11 <metaperl> I'm in Southern California
08:51:23 <shapr> It was nearly up to freezing today, quite warm.
08:51:26 <metaperl> but I bet the air is very clean there
08:51:36 <metaperl> and the water too
08:51:47 <shapr> Few days back we had -29 celsius, that's too cold for me to unicycle.
08:52:13 <metaperl> I miss the old tennis greats from Sweden - Mats Wilander, Anders Jarryd, Joakim Nystrom, Stefan Edberg, and of course BJORN BORG
08:52:33 <metaperl> those were the days
08:52:41 <SyntaxNinja> : http://blog.syntaxpolice.org for sw337 rock climbing photos :)
08:52:47 <shapr> Yeah, the environment here is clean, but the local business is extremely parochial.
08:53:04 <metaperl> parochial? what does that mean?
08:53:08 <shapr> I moved from Seattle to Europe, so it was a bit of culture shock.
08:53:29 <bourbaki> in a positive or negative way :)?
08:53:29 <shapr> @wn parochial
08:53:31 <lambdabot> *** "parochial" wn "WordNet (r) 2.0"
08:53:32 <lambdabot> parochial
08:53:33 <lambdabot>      adj 1: relating to or supported by or located in a parish;
08:53:35 <lambdabot>             "parochial schools"
08:53:38 <lambdabot>      2: narrowly restricted in outlook or scope; "little sympathy
08:53:39 <lambdabot>         with parocial mentality"; "insular attitudes toward
08:53:41 <lambdabot>         foreigners" [syn: {insular}]
08:53:51 <TheHunter> metaperl, if you want to do that, something along those lines is probably worthwile: http://www.haskell.org/hawiki/IndirectComposite. But it's advanced stuff.
08:53:54 <metaperl> oh, they dont like foreigners
08:54:21 <metaperl> do you speak Swedish?
08:54:24 <shapr> Actually, they like to take ideas from foreigners and use them to make money, as long as the foreigners aren't part of it.
08:54:36 <shapr> Ja, jag talar lite svenska, det är mycket kul.
08:54:39 <metaperl> is Volvo a swedish car?
08:54:43 <shapr> Yes it is.
08:54:55 <tuomov> they haven't been bought by some big american company?
08:55:08 <shapr> I bet they have, but they're still made here last I heard.
08:55:09 <tuomov> like most european car manufacturers
08:55:10 <tromp> volvo is a dutch swedish joint venture
08:55:26 <Oeje1> And Saab?
08:55:52 <tuomov> owned by gm
08:55:55 <tuomov> iirc
08:56:01 * metaperl heads to work
08:57:04 <shapr> What's your job?
09:10:16 * metaperl_ arrives at work
09:12:35 <Gahhh> yay telecommuting
09:16:28 <shapr> I don't know what to do about EuroPatents. I can't afford new hardware on a regular basis, much less a lawyer, so how can I afford to continue to be self-employed?
09:17:36 <shapr> It appears that Bill Gates personal address to the European Council and the pro-patent letters from Ericsson, Sony, Siemens, Alcatel, and Philips have a lot more weight than anything the citizens can say.
09:18:29 <shapr> The only solution I can see is to setup a high-tech service collection outside of these oppressive laws and sell cheap patent-unencumbered services to the suckers inside these oppressive systems.
09:19:07 <shapr> Question is, what place is left to setup a high-tech collective? Antarctica?
09:20:18 <shapr> Someone once jokingly suggested that Microsoft was behind the oil fields invasion, since there was no copyright or patent law there before.
09:21:10 <shapr> Is there any hi-tech or at least high-bandwidth country with non-restrictive patent/copyright/internet censorship laws?
09:22:34 <Darius> If I understand correctly, China doesn't recognize (at least America's) copyrights, so modulo the firewall...
09:22:34 <CosmicRay> shapr: I wonder about south korea
09:22:38 <xerox> That is an interesting question..
09:22:51 <SyntaxNinja> QC is a perfect example of a Haskell library.  It shows all the power of Haskell, it's only 300 lines long...
09:22:52 <CosmicRay> shapr: I know s. korea is very high-bandwidth
09:23:12 <SyntaxNinja> but it hasn't moved an inch in 2 years to become a mature piece of software, to do a bunch of reasonable things that it should do.
09:23:15 <xerox> Why the bandwidth does matter?
09:23:22 <Igloo> Because of the sheer quantity of spam they pump out?  :-)
09:24:11 <CosmicRay> shapr: russia may also be a possibility
09:24:44 <shapr> My original idea is that Europe would kill off the software patents deal, and that would kill off the US monopolies, because they would no longer be competitive against patent unencumbered Europe. Since that's no longer the case, the best pressure I can think of is to offer services that use patent unencumbered software, but don't allow sending that software into the oppressive countries.
09:25:00 <SyntaxNinja> is it the case that Europe has been a place of awesome software appearing due to the lack of patents?
09:25:03 <SyntaxNinja> compared to the US?
09:25:22 <shapr> SyntaxNinja: Linux?
09:25:29 <Igloo> GHC!
09:25:33 <CosmicRay> SyntaxNinja: not afaik.  there were some cases where europe produced better encryption software, back before the us relaxed its export rules
09:25:51 <CosmicRay> shapr: but that's not a euro-only project, and doesn't seem to run afoul of us patents eithe
09:26:09 <SyntaxNinja> exactly
09:26:23 <shapr> gzigzag got shutdown for patent reasons.
09:26:24 <SyntaxNinja> I guess the reason it's a Bad Thing is becuase of the future we all fear
09:26:32 <CosmicRay> SyntaxNinja: I believe gnupg development started in europe because of american cryptography export laws, for example.  however, if memory serves, .fr has cryptography laws far more draconian than .us ever did, so it's a mixed bag there too
09:26:54 <esap> Patents are primarily used to make separate playing ground for big companies and to ensure that small companies have no chance of competing with the big ones.
09:26:55 <SyntaxNinja> yeah
09:26:55 <shapr> Yeah, .fr laws limit you to rot13 pretty much.
09:27:06 <autrijus> s/13/26/
09:27:07 <CosmicRay> and didn't fraunhoffer assert patent on mp3 compression even some years ago in .de?
09:27:25 <shapr> autrijus: heh
09:27:29 <CosmicRay> autrijus: lol
09:28:15 <autrijus> it's the only true lossless encryption format!
09:28:36 <shapr> The worst part about patent law is that it's not the civil punishment that's the dangerous weapon, it's the law process itself. It's like a big game of poker where the amount of legal fees you can afford shows how much power you have.
09:28:42 <CosmicRay> autrijus: and you can implement it with a two-byte function in haskell (id)!
09:28:50 <autrijus> ooh!
09:28:51 <SyntaxNinja> shapr: right
09:29:09 <CosmicRay> shapr: I agree
09:29:17 <autrijus> CosmicRay: I implemented it with 0 bytes!
09:29:42 <CosmicRay> heh
09:29:43 <shapr> Because if your company can't afford two years in patent court and still run, you have to cough up anything to someone who has more poker chips.
09:29:48 <autrijus> via an inline macro
09:30:07 <CosmicRay> autrijus: cheater
09:30:14 <autrijus> :D
09:30:24 <shapr> That system is horribly broken, but I don't know how to fix it.
09:30:47 <autrijus> shorten it to 12 months, renewable at most once?
09:31:07 <shapr> You're talking about the patent system?
09:31:13 <autrijus> yeah.
09:31:23 <Gahhh> shapr, you can rest assured that no one will hit you with a lawsuit if you comment your code well. In my experience, no one reads your code then. ;)
09:31:23 <esap> shapr: Make all litigation free of charge? That'll just flood the system and force change :-)
09:31:53 <shapr> Yeah, but there's a deeper problem that due process of law is unavailable to citizens and companies below a certain amount of income.
09:32:38 <shapr> Get SPJ to write a law combinator library so we can rewrite all the laws in a format the citizens can understand?
09:32:55 <stepcutHM> the company I work  for bought lawsuit insurance, and then when we got sued, they did not want to pay up, so we had to sue the lawsuit insurance company...
09:33:01 <shapr> !
09:33:16 <esap> shapr: naah, have the library also enforce the chosen rules...
09:33:35 <shapr> I had to quit college because my student insurance wouldn't pay my medical bills, so I had to use my tuition to pay.
09:33:43 <CosmicRay> stepcutHM: ouch
09:34:23 <stepcutHM> though, patent lawsuits can also work for the 'little guy', basically, you patent something stupid, and then you go to medium-big companies and say, license my patent for $25K or I will sue
09:34:40 <stepcutHM> It cost the company more to fight than to just pay up
09:34:41 <shapr> Yeah, but that's not a good use of patent law either.
09:34:53 <stepcutHM> nope
09:34:54 <esap> stepcut: That doesn't work, if you are not willing to sue.
09:35:40 <shapr> In fact, patent law shouldn't cost a huge amount of money one way or the other, it's just there to encourage implementation of new ideas.
09:36:01 <shapr> Well, I have a really seriously cool idea, I think it could change the world, but I can't afford to do anything about it.
09:37:12 <stepcutHM> shapr: does it involve disrupting the business of large monopolies or oligopolies ?
09:37:16 <shapr> I can now a) sign my idea over to a company and get a few bucks b) get a vulture capital loan and own some percentage of the result c) save up money until I can afford to develop this myself?
09:37:24 <shapr> stepcutHM: sort of...
09:37:39 <shapr> I suspect it would kill off the car companies at least.
09:38:00 <stepcutHM> shapr: reliable public transportation ?
09:38:09 <esap> shapr: you can also both a) save up money b) implement it yourself (slowly without corporate backing)
09:38:22 <shapr> Speaking of stupid systems, what the heck happened to mass production? You realize we could all easily afford personal transportation if the Model T viewpoint were used today?
09:38:36 <shapr> stepcutHM: vaguely
09:38:54 <esap> shapr: "Model T viewpoint"?
09:39:08 <shapr> Yeah, the Model T used the same parts for seventeen years.
09:39:21 <stepcutHM> shapr: can you develope the product to market in less than 2 years and with a staff of less than 12 people ?
09:39:26 <shapr> It's easier to find parts for a Model T than for many other models of cars from the last twenty years.
09:39:52 <stepcutHM> and the model t comes in any color you want, as long as you want black :)
09:39:53 <shapr> stepcutHM: Yes, I think so. But I'd have to choose the 12 people for their skills and creativity.
09:40:17 <esap> shapr: I suppose that's because incompatibility has become a feature :-)
09:41:00 <shapr> esap: the Model T viewpoint is the difference between pre OS/360 hardware being custom built for each customer, from the boards on up, to the PC with its totally standard arch.
09:41:32 <esap> shapr: Right, the platform vs. application difference.
09:42:21 <stepcutHM> shapr: one last quetion -- does this involve unicycles somehow ?
09:43:01 <shapr> So I thought up a nice simple design that works sort of like a caterpillar, allowing you to build 'trains' out of single units. Each unit can be power, cargo, or control. Cargo can be a variety of things, including people.
09:43:08 <shapr> That's my solution to the Model T problem.
09:43:46 <shapr> Basically, design an open API like the early PC and sell a few simple designs like power plugins that are electric, gasoline, etc
09:44:07 <shapr> stepcutHM: Interestingly, that was my starting point.
09:44:38 <esap> shapr: you are aware that platforms cannot be sold and they will not attract investors :-)
09:44:46 <esap> shapr: ?
09:45:04 <shapr> I don't care about making money, I want to kill off stupid dinosaurs like the car industry.
09:45:40 <shapr> I'd much rather create an open source GPL'd car design like the open source graphics card design that's happening now.
09:46:09 <esap> shapr: Ah ok, only for the design? Now the cars themselves? :-)
09:46:17 <esap> shapr: s/Now/Not/
09:47:11 <shapr> Minä en ymmarra.
09:47:14 <esap> shapr: I think a problem is that all cars are already very much alike in their design. Only minor things are different.
09:47:56 <shapr> I think a problem is that the differences mean that each piece only fits on one car.
09:47:58 <esap> shapr: And the car manufacturers have concluded that they can't compete except by ensuring that they are incompatible with all the other cars.
09:49:29 <esap> shapr: that is, by creating monopoly of their own car model, and therefore creating distinct markets for different brand cars. Then they can compete by charging large prices for spare parts.
09:50:22 <stepcutHM> http://www.atsltd.co.uk/
09:50:39 <esap> shapr: probably the car makers are also ensuring that the cars don't work very well, so they can sell lots of spare parts.
09:52:00 <shapr> But if the car API were standard, if the pieces were all the same, then quality of pieces would get more sales.
09:52:33 <samc> 1. cars share many parts  2. cars from small companies run by car enthusiasts are less reliable
09:52:37 <esap> shapr: No, because the decision to purchase a car is not usually made based on the price of spare parts.
09:53:48 <samc> that's why the mgbgt was successful
09:54:09 <esap> shapr: and cars are considered as a single thing when you purchase it, people don't want to build their cars from spare parts :-)
09:54:33 <shapr> Sounds like windows maybe?
09:54:48 <shapr> We'll sell you the upgrades for more money than you can really afford...
09:54:58 <esap> exactly. It's the same.
09:55:35 <shapr> Ergo, introduce open source watch the monopolies crumble.
09:55:48 <shapr> I have a dream!
09:56:13 <esap> shapr: It's harder to use open source for material goods,  because open source only works if manufacturing costs are negligible.
09:57:13 <shapr> Not necessarily, open source design and co-operative manufacturing might work. Look at the totaly open graphics card recently discussed on the lkml.
09:57:35 <shapr> Well, it's not totally open. But it's a lot more open than anything before it.
09:57:41 <tuomov> the same spare part thing is happening in inkjet printers (or what do you call them in english)
09:57:50 <shapr> yeah, inkjet printers.
09:59:11 <esap> I think the solution is to make clean distinction between infrastructure and applications.
09:59:30 <shapr> |hugues: hiya
09:59:38 <shapr> esap: how so?
09:59:52 <shapr> |hugues: does afp stand for Advanced Functional Programming?
10:01:59 <esap> shapr: That prevents bundling the infrastructure with the applications. Then infrastructure can evolve independently. Infrastructure improvements drive enhancements to applications.
10:03:01 <shapr> That's an excellent point, how to make it happen?
10:03:27 <esap> shapr: Well RMS has done it already, just watch and learn :-)
10:04:31 <esap> shapr: GPL is the mechanism to distinguish infrastructure and applications.
10:06:50 <Pirate> can anyone point me to a good haskell arrays tutorial please
10:07:12 <shapr> I'm sorry, you're clearance level is too low for than information.
10:07:15 <shapr> doh "your"
10:07:18 <shapr> Wow, I am tired.
10:07:46 <shapr> Pirate: how far have you gotten?
10:07:59 <Pirate> ive never used arrays in haskell
10:08:02 <shapr> I have some code that constructs arrays, but I didn't get much further myself.
10:09:00 <shapr> Pirate: Does this help any? http://www.scannedinavian.org/~shae/ProtoArray.hs
10:10:28 <Pirate> not really im afraid
10:12:28 <jlouis> Ok, 1) Pick out your Library reference
10:13:09 <Pirate> Library reference?
10:14:07 <jlouis> ah, 2 secs
10:14:59 <jlouis> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
10:15:23 <jlouis> If you need to remember one URL for haskell programming, this is it ;)
10:15:42 <Pirate> ok
10:17:20 <jlouis> Array i e is an array with indices i and elements e
10:17:49 <jlouis> Data.Array.array :: Ix i => (i, i) -> [(i, e)] -> Array i e is the basic constructor
10:18:32 <jlouis> my _guess_ is that (i, i) is the bounds of the Array and [(i, e)] is an associative list which builds the array in question (index i gets element e)
10:18:50 <Pirate> right ic
10:19:28 <jlouis> Data.Array.(!) :: Ix i => Array i e -> i -> e is the function for referencing a given element
10:22:35 <shapr> The ProtoArray code shows you how to construct an array, an how to do an index map over the array.
10:22:50 <Pirate> right
10:22:55 <Pirate> this is gonna be hard!
10:23:01 <shapr> What do you want to do?
10:23:33 <Pirate> basically ive got a list of instructions and ive got a function that iterates over the list and performs the instructions
10:23:55 <Pirate> but ive got to change it so that it uses an array instead and a program counter to reference the next instruction
10:24:25 <Darius> Pirate: So what part are you thinking is going to be hard?
10:24:59 <Darius> You make the array, you store the PC in an accumulating argument, you use (!).
10:25:24 <Pirate> right ok
10:28:22 <Pirate> i think im gonna do a bit more reading about arrays and then it might become clear!
10:28:58 <jlouis> You have to check /g 11
10:29:00 <jlouis> bleh
10:29:01 <jlouis> sorry
10:29:11 * shapr carefully checks his g11
10:29:17 <shapr> Aha! so that's the problem!
10:29:23 <xerox> Ahah :)
10:37:10 <shapr> right, time for me to work
12:12:50 <Itkovian> @seen boegel
12:12:50 <lambdabot> I saw boegel leaving #haskell 3 hours 35 minutes 31 seconds ago.
12:12:55 <djo> Is there any function in Haskell which transform the string "10" to the integer 10 ???
12:13:12 <Itkovian> read ?
12:13:22 <Itkovian> and then use the result as an Int/Integer
12:13:35 <Itkovian> so the type system will figure out you need an Int/Integer
12:14:34 <wagle> very..  ah.. "dynamic"
12:15:16 <SyntaxNinja> it's not dynamic, it figures out the type at compile time
12:15:38 <wagle> Prelude> 1 + read "10 x"
12:15:38 <wagle> Program error: Prelude.read: no parse
12:16:34 * wagle pokes around looking for a Maybe'ifed version
12:16:37 <Si\> you could use readsPrec to write a function which returns the result in a monad, to cope with failure
12:19:02 * wagle is the local scheme punching bag, having been a schemer in a previous life in the old country
12:20:36 <wagle> haskell isnt as static as people would like to ascribe it
12:21:04 <Si\> how do you mean?
12:22:31 <Philippa> Haskell 98 very much is
12:22:54 <Philippa> GHC's existential constructors might be considered to be less so, but certainly they're fully statically type-checked
12:23:37 <Philippa> GHC's dynamic typing facilities, now that's different :-)
12:23:46 <Darius> I'd say Haskell is impressively static.  However many things can be made dynamic with suitable reification.
12:23:52 <wagle> man, i shouldnt start things right before i want to go to lunch
12:24:03 <Darius> (explicit reification)
12:24:12 <wagle> dynamic == "run time checks"
12:24:21 <wagle> lots of run-timne checks
12:24:23 <Philippa> which type classes don't do
12:24:44 <Philippa> you get run-time dispatch, but that's not the same thing
12:24:45 <wagle> overlapping do
12:24:59 * Darius doesn't like overlapping instances.
12:25:11 * Philippa doesn't consider them Haskell per se either
12:25:17 <Philippa> they're sure as hell not Haskell 98
12:25:47 <bourbaki> does anyone own a mac?
12:25:54 <wagle> you dont have to provide all the possible cases
12:26:00 <wagle> bourbaki: yo!
12:26:14 <bourbaki> wagle: can you costumize the colour scheme?
12:26:31 <wagle> which color scheme?
12:27:01 <Philippa> also, reading the GHC docs it appears the overlapping instances mechanism doesn't do any run-time checks but is instead somewhat conservative?
12:27:21 <bourbaki> wagle: i need a black background
12:28:52 <wagle> Philippa: I was getting run-time errors when i tried to use Liang's OR to fake subtypes..  i think i only tried hugs, though, and it would take a while to reconstruct the example to send it at ghc
12:29:18 <wagle> bourbaki: menu the apple in upper left, choose system preferences
12:29:53 <wagle> Philippa: i wanted static subtyping, so I gave up on that track
12:30:31 <Philippa> wagle: fair enough, Hugs may have a different implementation
12:30:35 <Lemmih> Run-time type errors?
12:31:07 <wagle> Philippa: not clear that ghc could do any differently (is overlapping instances)
12:31:19 <Philippa> wagle: it's rather conservative about when it allows them
12:31:29 <Philippa> it can just fail at compile-time
12:31:44 <wagle> i'll try to get around to checking it out
12:32:49 <Philippa> also, given that it's one implementation's extension I'm not sure you can really level the charge at Haskell as a whole :-)
12:33:32 <Philippa> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#INSTANCE-DECLS
12:33:48 <Philippa> should give you the relevant answers in the first handful of lines
12:34:42 <wagle> i'm responding to the charge that scheme is dynamic, and haskell isnt
12:35:53 <wagle> haskell shares some of the same dynamism that scheme is being accused of, but scheme has nothing like haskell's type and class system..
12:36:05 <wagle> so i prefer haskell
12:36:35 <wagle> i want to reason about my programs as much as possible before i run them
12:37:18 <wagle> scheme lets me run more programs, though, so doesnt require me to understand them before running them to see what happens
12:37:23 <Darius> Why not use a logic implementation then, e.g. HOL/Isabelle, ALF, Coq, etc.
12:38:20 <Philippa> wagle: is overlapping classes the main part of the dynamism you're interested in?
12:38:28 * Philippa likes type classes for what they let you type
12:38:46 <wagle> Philippa: not at all
12:40:02 <Philippa> you know you can to a large extent 'fake' type classes with rank-n polymorphism?
12:40:36 <wagle> getting ready for lunch, i made a flip comment about read generating (apparently uncapturable?) run-time errors being just what scheme does.  Philippa charged to haskell's rescue, and so i felt obligated to justify myself a bit more.  but now i'm going to eat lunch.
12:40:42 <Philippa> it's not as neat by a long way, though not having one unique instance for any given type has its upside
12:40:50 <Philippa> heh. Sorry, didn't mean to bite your head off :-)
12:43:00 <Philippa> anyway, I didn't jump in on (or even see) the read bit. And yeah, read can be a PITA to use, I make a point of annotating which type I expect to get out...
12:43:07 <Si\> IMHO, read is not particularly well implemented, it's pretty much useless if you want to write a backtracking parser, it ought to have type read :: (Read a, Monad m) => String -> m a
12:43:10 <Philippa> (but the issue there's catching parse failure)
12:43:14 <Darius> Philippa: Doesn't rank-n polymorphism simply allow you to type the dictionary passing implementation of type classes.
12:43:23 <Philippa> Darius: yeah
12:43:59 <Philippa> so you lose the overloading if you consider that to be the main point still, and the syntax sucks
12:44:23 <Darius> It's pretty painful.  Some of the @eval code uses dictionary passing.
12:44:35 * Philippa nods
12:44:51 <Philippa> don't worry, I'm not advocating ditching type classes
12:45:50 <Philippa> I've come to the conclusion I don't like describing them as an overloading mechanism though. They're closer to an extensible type
12:49:08 <Darius> One categorical semantics of type classes has them (unsurpisingly) as simply a form of predicates.
12:51:12 <djo> I have a somothing like "data Type1 = Type1 {var1 :: Type3, var2 :: Type4}" how can I access to var1 ?
12:52:17 <Igloo> http://www.haskell.org/pipermail/cvs-ghc/2005-March/023805.html # 6.4 cut off point
12:52:26 <Lemmih> djo: 'var1 variable'.
12:52:26 <Philippa> Darius: HM(X) seems to be a good way to look at this kind of stuff...
12:52:45 <Philippa> they become constraints rather than predicates, but in the situation it's very much same difference
12:55:52 <Darius> djo: You may want to look at http://www.haskell.org/hawiki/UsingRecords
12:56:06 <yonkeltron> does haskell have support for threads?
12:56:33 <Lemmih> yonkeltron: Yes.
12:56:33 <Philippa> FCVO "haskell" and CVO "threads", yes
12:56:34 <Darius> yonkeltron: Not standardly, but GHC has pre-emptive user and OS threads and Hugs has cooperative user threads.
12:56:49 <Darius> Don't know about NHC, but you can also fake them.
12:56:51 <Philippa> what Darius said
12:56:58 <yonkeltron> cool...how about sockets?
12:57:01 <Heffalump> GHC does not have proper pre-emptive threads.
12:57:02 <yonkeltron> i need sockets....
12:57:08 <Lemmih> yonkeltron: Of course.
12:57:13 <Darius> yonkeltron: Same answer as above.
12:57:14 <Heffalump> you can only pre-empt when a memory allocation happens
12:57:32 <Darius> To make Heffalump happy, "effectively pre-emptive user threads"
12:57:52 <Heffalump> depends what you want them for
12:58:12 <yonkeltron> Lemmih, Darius: where are the socket docs and is there a tutorial available?
12:58:13 <Igloo> I think to make Heffalump happy you have to implement proper pre-emption  :-)
12:58:14 <Heffalump> for most applications, they're fine. But they're useless for defending against malicious code, even code that is banned from doing IO.
12:58:35 <Darius> yonkeltron: Try the GHC User Guide and Hierarchical Libraries docs at www.haskell.org/ghc
12:58:41 <Igloo> Depends on your definition of "malicious"
12:58:50 <Darius> And just wander around www.haskell.org for other stuff.
12:58:59 <Heffalump> "wants to perpetrate a DoS" sounds fairly malicious to me
12:59:18 <Darius> Heffalump: That's only if you let one upload actual raw Haskell that is compiled.
12:59:34 <Darius> Even then I expect OS threads would be still be pre-emptive.
12:59:41 <Igloo> It "only" affects DoSs, though
12:59:41 <Heffalump> they're not.
12:59:49 <Philippa> or let the user build the app out of parts. Even with everything fully compiled you could have a malicious Flippi plug-in, for example
13:00:36 <Darius> Philippa: If the parts or their combination allocate memory then...
13:01:10 <Philippa> the combination's not sufficient
13:01:21 <Philippa> once you start the big timewaster of doom, you're screwed
13:01:56 <Philippa> repeatedly twiddling a strict value in an IO array'd do it, for example
13:02:53 <Heffalump> to be fair, no other pre-emptive system would protect against even more malicious code, short of sandboxing
13:04:22 <Darius> Philippa: But to "repeatedly" do something, you'd need to combine the "something" with a "repeatedly do it" part and there would almost certainly be some interpretive overhead.
13:04:39 <Philippa> tail recursion
13:05:06 <Heffalump> darius: let loop 0 = loop 0 in loop 0
13:05:12 <Heffalump> pure code, perfect DoS
13:05:14 <Philippa> Heffalump: not giving the code access to the IO monad and limiting its heap should do?
13:05:29 <Philippa> in terms of preventing stuff other than CPU time DoS
13:05:35 <Heffalump> Philippa: correct.
13:05:53 <Heffalump> but a CPU time DoS is still an issue
13:06:38 <Philippa> more so if you can DDoS
13:06:38 <Darius> Heffalump: My point was in the case that the user can't provide raw Haskell.
13:07:06 <Heffalump> what are you suggesting they provide?
13:07:27 <Philippa> Darius: Flippi plugins are raw haskell compiled in, so there's room for malice (or just dumb non-termination) there
13:07:52 <yonkeltron> Darius: u sure that the networking libs docs are on haskell.org/ghc cause i couldn't seem to find them...i'm newthough
13:08:16 <Darius> yonkeltron: In the hierarchical libraries, the network API is covered.
13:08:53 <Darius> yonkeltron: Albeit that is only reference.  The "Tackling the Awkward Squad" may be useful reading for you.
13:09:22 <Philippa> if you're comfortable with the IO monad generally the rest's not too bad IMO
13:09:31 <Philippa> it didn't take me too long to have a haskell app talking in here, for example
13:09:59 <yonkeltron> Darius: OH! thanx
13:10:00 <Philippa> nor would it take me long to get the nice multi-threaded multi-server setup I'd sketched out coded up
13:15:14 <Darius> Heffalump: The composition of precompiled chunks (through whatever interface).
13:15:40 <Heffalump> huh?
13:17:09 <Darius> In response to "what are you suggesting they provide?".
13:20:23 <Heffalump> that's like a sandbox, really
13:20:53 <Philippa> interpreter inna sandbox, in fact
13:21:40 <Heffalump> anyway, I'm not really sure what your point is. Both Philippa and I have real applications that are vulnerable to DoS because of this weakness in the threading, so it's not like it's a corner case or something.
13:21:52 <Darius> Yes, pretty much anything but raw code would be essentially an interpreter.
13:22:38 <Philippa> Heffalump: in my case the vulnerability's a bit more than that admittedly - Flippi plugins can patch the basic page IO operations, which run in the IO monad
13:23:05 <Philippa> it's kinda unavoidable for the level of power the plugins're supposed to have - caveat admin and all that
13:23:23 <Heffalump> ah, ok
13:23:45 <Heffalump> my application bans IO by a type restriction and restricts imports to prevent unsafePerformIO
13:24:01 <Darius> I said, "That's only if you lot one upload actual raw Haskell that is compiled", if you do that then it applies.
13:24:17 <Darius> I didn't have a point beyond that.
13:25:38 <Darius> Heffalump: And unsafeCoerce?
13:25:44 <Heffalump> I ban all imports.
13:26:06 <Heffalump> which is reasonable for the application in question
13:26:07 <Darius> Heffalump: What is imported then?
13:26:18 <Heffalump> just the Prelude
13:26:26 <Heffalump> and an API I define
13:35:42 <boegel> does anybody know how to switch from azerty to qwerty (and back), using a key-combo ?
13:35:57 <boegel> I forgot, and now I'm stuck in qwerty (by accident)
13:47:58 <int80_h> hello everyone
13:50:56 <boegel> hi int80_h
13:51:30 <int80_h> I borrowed the richard bird book. working through chapters 1-6
13:52:00 <int80_h> glancing through it, it looks like no projects until chapter 5.
14:08:30 <metaperl_> int80_h, I am enjoying the Algorithms book. It's the best intro I have seen
14:08:56 <int80_h> which algorithms book, who is the author?
14:09:11 <metaperl_> Lapalme and one other guy
14:09:20 <metaperl_> RAbhi
14:09:23 <metaperl_> is the other guy
14:09:29 <int80_h> oh cool, it's a goal for me then, once I get the basics down
14:09:32 <metaperl_> better than YAHT and Gentle
14:09:42 <metaperl_> no, this will give you the basics
14:09:47 <xerox> metaperl_, is it free on the internet?
14:09:48 <metaperl_> it is the best intro I have seen
14:09:52 <metaperl_> no
14:09:57 <int80_h> really :)
14:09:57 <metaperl_> I bought it from amazon.com
14:09:59 <int80_h> excellent
14:10:15 <int80_h> well hell, is it on the book list from haskell.org?
14:10:22 <metaperl_> but it was worth the money... it was better than either free resource I used..
14:10:28 <metaperl_> yes it is int80_h
14:10:44 <int80_h> yeah I have found when it comes to getting serious about learning a language, one needs a book.
14:10:45 <metaperl_> and the chief implementor of Perl 6  recommends it as well
14:11:01 <metaperl_> with Perl, the manual pages are all you really need if you are serious
14:11:01 <int80_h> this PUGS was a good marketing move for haskell
14:11:11 <int80_h> it will get us more mindshare.
14:11:16 <metaperl_> :)
14:12:27 <int80_h> man pages don't give you exercises now do they?
14:12:39 <int80_h> I find I need to work through exercises to gain confidence
14:12:55 <int80_h> certainly with functional languages
14:13:13 <int80_h> exercises that test your knowledge is what I look for.
14:13:20 <int80_h> ever increasing in complexity
14:14:41 <CosmicRay>   /join #amportal
14:14:45 <CosmicRay> sorry
14:27:34 <Oeje1> The Puppy multi-session live-CD idea is so cool.
14:28:00 <xerox> 'night folks.
14:37:35 <Remi> hi
14:37:51 <Oeje1> Remi: Hello.  Good night.
15:36:05 <pipe> hi Cale
15:39:46 <elux> hey
15:40:02 <elux> just wondering, but can haskell have pointers to an address of a variable like in c?
15:40:08 <Heffalump> no
15:40:10 <elux> good
15:40:25 <elux> btw ..  how is opengl performance with haskell (hopengl) ?
15:40:31 <elux> in comparison to c with opengl
15:40:45 <pipe> depends
15:40:52 <elux> i was wondering how popular haskell is becoming in the game dev. industry
15:41:08 <pipe> not popular at all
15:41:08 <Heffalump> not at all, would be my suspicion
15:41:22 <Lemmih> There's almost no Haskellers interested in game development.
15:41:33 <pipe> Lemmih: what about tim sweeney?
15:41:34 <elux> hrmm why not though ... its so mathematical, i would imagine it would be a perfect fit for game dev
15:41:59 <elux> my only concern would be performance
15:42:30 <pipe> there is also what's his name who is a bit into haskell
15:42:32 <Lemmih> A well written HOpenGL program can be as fast as the native version.
15:42:43 <dons> there's a reasonable amount of interest in 2 and 3d image and animation generation
15:42:44 <Lemmih> s/native/native C/
15:42:48 <elux> what constitutes are "well written"
15:43:07 <pipe> chris havock i think his name is
15:43:59 <Lemmih> pipe: Tim sweeney?
15:44:05 <Heffalump> there's some cool stuff that tinkers on the edges of the game industry
15:44:27 <pipe> Lemmih: you know him?
15:44:28 <Heffalump> e.g. the image/animation generation dons mentioned, some music generation stuff, the Yampa (functional robots) stuff
15:44:45 <Lemmih> pipe: Haven't heard of him before.
15:44:54 <Heffalump> but I think real game development is a bit too hard-core and performance-oriented for all this high-level abstract stuff.
15:45:43 <pipe> Lemmih: he works at valve, maker of half life 2
15:46:03 <Lemmih> pipe: Did he write it in Haskell?
15:46:20 <pipe> chris havoc i am sure was interested in ocaml at one point, and he also got into haskell a little bit i think
15:46:23 <pipe> Lemmih: no
15:46:46 <elux> do any of you guys use ocaml?
15:47:10 <Lemmih> pipe: Then why should I know about him?
15:47:50 <pipe> Lemmih: i think he comments on LtU sometimes
15:49:33 <Lemmih> I don't see how he conflicts with my previous statement about Haskellers lack of interest for game dev.
15:49:38 <arjanb> heh i thought Tim Sweeney worked on the unreal engine
15:50:04 <pipe> arjanb: yeah you are right
15:54:40 <elux> i wonder if unreal engine uses some haskell :)
15:55:25 <pipe> it doesn't
15:55:40 <pipe> closest thing to haskell that's been used in serious gamedev are some lisp variants
15:59:46 <dons> does guile get used for, say, user-defined game plugins?
16:04:55 <tautologico> Naughty Dog Software uses some lisp languages developed in-house in their games
16:09:34 <ozone> dons: the real question is -- does guile get used for anything?
16:09:49 <ozone> and tim sweeney works for epic, not valve
16:09:55 <dons> i have hear rumours, but haven't seen any examples myself ;)
16:10:01 <dons> heard
16:10:19 <ozone> oh, you were talking about somebody at havoc, nevermind me
16:10:44 <pipe> no, chris havoc, that's his name
16:11:01 <pipe> oh wait, his name is actually chris hecker
16:11:20 <ozone> s/havoc/havok/
16:11:23 <ozone> or whatever they're called :)
16:12:01 <pipe> http://caml.inria.fr/archives/200201/msg00201.html
16:12:06 <pipe> check out the reply by chris hecker
16:48:00 <Pirate_> hi can anyone help me with some haskell array questions
16:48:59 <metaperl_> Pirate, go ahead and ask, someone should see it and answer it
16:49:12 <metaperl_> I'm a beginner. I just finished reading some things on arrays
16:50:19 <Pirate_> ok basically im supposed to make a function that gives an array of instructions, which ive done, now i need to make a function that uses a program counter to reference the instructions from the array
16:50:43 <Pirate_> but i dont understand how to make the array stick in memory so i can use it, with haskell not doing variables and all
16:51:34 <Darius> Pirate_: If it's an immutable array, just use lexical scoping.
16:52:14 <Darius> In fact, even if it's a mutable array you'd do the same thing.
16:52:20 <Pirate_> Darius i dont really understand arrays either, ive sort of just made a best guess attempt at it, so i dont really know what u mean
16:52:54 <Pirate_> let me try and explain better what im trying to do
16:53:52 <Pirate_> i started with a function that gave a list of operations eg 1+2 is [LDN 1,LDN 2,OPR "+",HLT], and i have a function that goes thru the list and works out the answers to the 'program' i gave it
16:54:42 <Pirate_> now i need to change these two functions generate the 'program' in an array instead of a list, and use a program counter (whatever that is) to reference the next instruction
16:54:54 <metaperl_> why not load the curried function into the array?
16:55:05 <Pirate_> curried?
16:55:18 <metaperl_> [LDN 1,LDN 2,OPR myAdd, HLT]
16:55:38 <metaperl_> are you having to pop the numbers from a stack?
16:55:51 <metaperl_> yes: let's say you have add a b = a + b
16:55:52 <mauke> execute (gimmeProgram "1+2") -- or something like that
16:56:10 <metaperl_> you can curry one or both arguments to the function add
16:56:18 <metaperl_> what is execute?
16:56:27 <metaperl_> mycurried_add = (add 5)
16:56:33 <metaperl_> mycurried_add 12
16:56:33 <mauke> the function he's trying to write, I suppose
16:56:36 <metaperl_> yields 17
16:56:50 <metaperl_> anyway I can see I am confusing you
16:57:13 <Darius> Pirate_: If you don't know what the "program counter" is, you need to review the exercise (and whatever related material) more.
16:57:15 <metaperl_> I just think it is easier to put the function in the array instead of using a case statement to dispatch to functions... but not much easier
16:57:29 <metaperl_> yes, the term "program counter" confuses me too
16:57:41 <mauke> why?
16:57:51 <mauke> it's the index of the current instruction
16:57:59 <metaperl_> well, he hasn't defined it.. oh I see
16:58:04 <Pirate_> metaperl_ ive already finished a version that uses the case bit to do the functions, i just need to figure out this array stuff now!
16:58:46 <Darius> @type Data.Array.listArray
16:58:50 <lambdabot> Data.Array.listArray :: forall e i.
16:58:50 <lambdabot> 			(GHC.Arr.Ix i) =>
16:58:50 <lambdabot> 			(i, i) -> [e] -> GHC.Arr.Array i e
17:00:43 <Pirate_> basically im having trouble figuring out why bother using an array since u need to pass it to the function anyhow, why not just pass the list instead?
17:01:14 <Darius> Pirate_: There are reasons, but why indeed.
17:01:42 <Pirate_> sorry im just used to c++, is there anyway to have variables in haskell, that would make this much easier
17:01:48 <Darius> Presumably you are doing this because it's an exercise, if not then pass a list instead if that's not a problem.
17:02:06 <Darius> Pirate_: That aspect has little to nothing to do with anything you've said so far.
17:02:46 <Pirate_> yeah its an excercise,  but im having trouble figuring it out as we havent been taught about haskell arrays and the lecturer doesnt program in haskell
17:03:09 <Darius> What part of arrays have you not figured out?
17:03:14 <mauke> what's the problem with haskell's arrays?
17:03:15 <Pirate_> but anyhow thats just me ranting
17:04:58 <Pirate_> im clearly not good enough at haskell to go from the sml notes using a list to a haskell program using arrays, probably should go and try and do some reading on the subject
17:09:11 <stepcut> heh
17:11:00 * stepcut just uses lists
17:14:00 <Pirate_> yeah i think i'll just stick with a list anyhow, its not like the guy marking it understands haskell anyhow
17:14:11 <SyntaxNinja> I wish lists had the // function like arrays do :)
17:14:24 <Pirate_> whats the // function?
17:14:36 <Pirate_> ps sorry i dont know anything about haskell
17:16:17 <SyntaxNinja>  // updates the array
17:16:19 <Darius> (//) isn't a very good idea for lists or arrays.
17:16:23 <SyntaxNinja> @type Data.Array(//)
17:16:24 <lambdabot> bzzt
17:16:32 <SyntaxNinja> @type Data.Array.(//)
17:16:33 <lambdabot> bzzt
17:16:36 <SyntaxNinja> whatever
17:16:40 <SyntaxNinja> Darius: why?
17:16:43 <SyntaxNinja> (for arrays?)
17:17:04 <Lemmih> @type (Data.Array.//)
17:17:06 <lambdabot> (Data.Array.//) :: forall e i.
17:17:06 <lambdabot> 		   (GHC.Arr.Ix i) =>
17:17:06 <lambdabot> 		   GHC.Arr.Array i e -> [(i, e)] -> GHC.Arr.Array i e
17:17:36 <Pirate_> what does that actually mean?
17:18:30 <Darius> SyntaxNinja: It's rather inefficient.
17:19:20 <Darius> Pirate_: It means that (//) is a function that takes an array an assoc list and produces an array.
17:19:39 <Pirate_> whats an assoc list?
17:20:35 <SyntaxNinja> I thought the whole point of Data.Array.Array is to pretend that we have constant-time access to those elements :)
17:20:35 <mauke> a list of (key, value) pairs
17:21:47 <Darius> SyntaxNinja: We do have constant time access, but not constant time update.
17:22:06 <Pirate_> is it possible to have variables in haskell?
17:22:15 <Darius> Pirate_: Yes.
17:22:24 <Darius> Pirate_: And you don't want them.
17:22:48 <Pirate_> well i would like them
17:23:01 <SyntaxNinja> Darius: he asked for it ;)
17:23:11 <Pirate_> for example i would like a variable called debug which could be set to true or false
17:23:31 <Lemmih> debug = True
17:24:03 <Pirate_> and then changed and used in functions without having to be passed to them as an argument
17:25:23 <Pirate_> possibly after ive written more than 4 haskell programs i'll learn to live without the luxary
17:25:29 <Lemmih> Use a state monad. (:
17:25:44 <Pirate_> whats a monad?
17:26:00 <pipe> hehe, "what's a monad?"
17:26:17 <pipe> no offense man :)
17:26:24 <Pirate_> basically i have no idea about haskell
17:27:02 <SyntaxNinja> Pirate_: you can have a global symbol, debug=True defined at the top level
17:27:02 <Pirate_> our uni stopped teaching us at the stage of u have to use recursion instead of looping
17:27:06 <SyntaxNinja> that's a constant :)
17:27:10 <Pirate_> lol
17:27:30 <SyntaxNinja> Pirate_: but Haskell doesn't have the kind of variables that'll be useful to you as a beginning haskell programmer
17:28:10 <Pirate_> does the irritation at lack of variables go away with time?
17:28:34 <Pirate_> cos this is my 3rd year learning haskell at uni and it hasnt gone away yet
17:28:38 <pipe> having no idea bout haskell is actually a good thing... less bad habits to get rid of during the transition to epigram :P
17:28:40 <tautologico> lack of variables doesn't cause irritation,
17:29:08 <SyntaxNinja> Pirate_: I thought you just said you've only written 4 haskell programs?
17:29:28 <Darius> Pirate_: How can this be your third year of learning about Haskell yet you "have no idea about Haskell"?
17:29:29 <Pirate_> yeah i wrote 2 in my first year, 1 in my second year and this one in my 3rd year
17:29:49 <Pirate_> we have 1 haskell module per year
17:30:02 <SyntaxNinja> Pirate_: yeah, it goes away with experience with the language.
17:30:21 <Pirate_> but we have ~2-4 java modules per year
17:30:37 <Pirate_> still prefer c++ tho
17:30:56 <Pirate_> no offence
17:31:25 * Darius prefers C++ to Java, but prefers Haskell to C++.
17:31:39 <pipe> ugh
17:31:43 <Pirate_> i do kindof like the way haskell doesnt let u get away without worrying about data types
17:33:38 <Pirate_> but anyhow, could someone explain what a monad is, if its not too complicated
17:34:42 <shrimpx> haha
17:35:10 <Darius> Pirate_: Google "All About Monads"
17:35:30 <Pirate_> ah right i guess its complicated then!
17:36:46 <Pirate_> i wrote a universal turing machine in haskell once
17:37:15 <shrimpx> Pirate_: a set of functions that, with nifty function composition tricks, "fake" serialization of evaluation
17:37:16 <Pirate_> which is quite suprising concidering ive no clue about haskell
17:37:25 <Pirate_> ah ok ic
17:37:37 <shrimpx> or that's a decent first approximation
17:42:57 <Pirate_> is it possible to program object oriented stuff in haskell?
17:45:38 <pipe> yeah
17:45:49 <pipe> but you probably don't want to
17:46:10 <Pirate_> nope
17:46:27 <Pirate_> i just thought that cos i just saw the haskell.net website
17:46:38 <Pirate_> as in h# not www.haskell.net
17:51:03 <Cale> pipe: hello
17:52:27 <pipe> hey, what's up?
17:53:33 <vegai> hmm, seems like there's some volcanic activity in St. Helens?
17:53:39 <vegai> anyone from that area here? =)
19:58:35 <yonkeltron> is there a comp.lang.haskell or is that not good enough?
20:41:25 <wagle> the volcano!  eeet lives!  http://immunix.com/~crispin/SaintHelens_march03_2004/
20:44:19 <wagle> http://vulcan.wr.usgs.gov/Volcanoes/MSH/Images/MSH04/framework.html
21:35:15 <juhp> devel hugs is looking good these days
21:47:45 <juhp> does anyone know can't CSConv be replaced by iconv in im-sdk?
21:50:04 <juhp> hm, http://wiki.fdiary.net/iiimf/
22:09:16 <juhp> oops
22:10:03 <juhp> except hugs's version perenial version numbering issue that is :-/
