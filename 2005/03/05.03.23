00:25:51 <musasabi> morninb
00:38:58 <aleator> to qt
01:12:49 <shapr> coi jewel .i ma nuzba
01:13:03 <shapr> hei musasabi
01:14:19 <shapr> I've been idly thinking about writing a day planner in Haskell, and that motivated me to think about a good implementation of intervals. Is there already such a thing?
01:19:21 <shapr> The simplest solution that comes to mind is something like 'data Interval a = Interval a a' but then I'd want to add inclusive and exclusive intervals.
01:19:38 <TheStar> Do any languages (Open source, etc) have a concept of separating program and library code? (I mean, as a design feature)
01:19:50 <musasabi> shapr: morning.
01:19:55 <shapr> TheStar: there's Joy :-)
01:20:29 <TheStar> shapr, Now, how am I going to do a google search on *that*? :)
01:20:40 <shapr> maybe 'data Interval a = Interval (Inclusive a) (Exclusive a)' ?
01:21:06 <musasabi> shapr: a very elegant way to represent intervals is a -> Bool, but that is quite problematic if you need to print them. Maybe a simple interval calculus.
01:21:25 <shapr> TheStar: http://www.latrobe.edu.au/philosophy/phimvt/joy.html
01:21:52 <TheStar> Thanks :)
01:21:59 <shapr> TheStar: it's a tad mind-bending, and I honestly doubt it's what you watn.
01:22:07 <shapr> Have you OCaml's module system?
01:22:21 <shapr> afaiu, signatures are separate from the code.
01:22:22 <TheStar> shapr, I'm making a new language, and it's a feature that we have determined to be neccessary.
01:22:36 <musasabi> data Interval = All Interval Interval | Not Interval | And Interval Interval | Or Interval Interval | Hour ... | Day ... | Weekday ...
01:22:39 <shapr> TheStar: it's going to be painful for compositionality
01:22:50 <TheStar> shapr, What do you mean? compositionality?
01:23:30 <shapr> for example, the @index plugin in lambdabot is the Main module of Haddock
01:23:47 <shapr> I'm using what was/is the 'program' as a library.
01:23:50 <TheStar> Nah, JOy is not what I'm after.
01:24:05 <shapr> Joy is very cool, and teaches some neat ideas.
01:24:13 <TheStar> btw, my language resembles Haskell, with it's type system and all that, except that arguments are passed by reference.
01:24:17 <shapr> postfix concatenative stack-based purely functional, oh my!
01:25:11 <tuomov> eh. aren't args passed by reference in haskell normally... you just can't modify them
01:25:11 <shapr> Mmm, methylphenidate is the breakfast of champions.
01:25:28 <shapr> Yeah, I was wondering that myself.
01:25:39 <shapr> How can you pass anything in Haskell other than by reference?
01:25:40 <TheStar> tuomov, So, in that case they're effectively passed by value.
01:25:46 <tuomov> shapr: unboxed?
01:25:52 <shapr> hm, good point.
01:26:07 <shapr> but wait, wouldn't you still have to make an *explicit* copy somehow?
01:26:10 <TheStar> tuomov, However, I'm probably going ot make integers and strings immutable, as a special exception.
01:26:22 <TheStar> integers, strings and tuples, anyway.
01:26:28 <shapr> Unless you're using the FFI and Ptr, I don't see how pass by value or pass by reference makes any difference.
01:26:35 <shapr> In Haskell, at least.
01:26:39 <pesco> pass by expression
01:26:46 <TheStar> shapr, Apparently it has repercusions for "No side effects".
01:26:48 <shapr> There's no 'identity' in Haskell, just value equality.
01:27:02 <shapr> TheStar: ich verstehe nicht
01:27:07 <pesco> Hi shapr. Hi tuomov, TheStar.
01:27:09 <tuomov> to me, passing by value means making a copy of the data
01:27:10 <shapr> can you elucidate?
01:27:15 <shapr> tuomov: yeah, me too
01:27:18 <TheStar> shapr, I'm trying to learn Italian, NOT GERMAN.
01:27:21 <TheStar> :)
01:27:31 <shapr> minä en ymarran
01:27:39 <shapr> ik begrijp het niet
01:27:45 <TheStar> Nor french...
01:27:47 <shapr> jag forstår inte
01:27:53 <TheStar> *sigh*.
01:27:54 <shapr> je ne comprends pas
01:28:02 <TheStar> shapr, No, I hardly understand it!
01:28:09 <shapr> sorry, that was finnish, dutch, swedish, and then french =)
01:28:11 <pesco> Ce n'etait pas de francais!
01:28:13 <TheStar> shapr, You speak those languages so shockenly.
01:28:22 <TheStar> pesco, Now, *THAT'S* french!
01:29:01 <TheStar> shapr, But ultimately, I do want to be able to just roll of languages like that, but hopefully better than that! ;)
01:29:02 <shapr> Actually, I speak a decent amount of Swedish, and enough French to survive in France. I can read Finnish, but speaking Finnish is very difficult.
01:29:06 <pesco> Oui, bien sur! Mais moi je shun le Francais.
01:29:14 <shapr> pourquoi?
01:29:21 <shapr> j'aime les française =)
01:29:28 <TheStar> shapr, Well, it's the reading and writing that I care about - hearing and speaking I'm not interested at all!
01:29:29 <pesco> 'Ne sais pas.
01:29:44 <TheStar> Man, that was an unusual sentence structure, that one I have been using...
01:29:56 <shapr> TheStar: Finnish is lots of fun to speak. You should try it.
01:30:12 <TheStar> shapr, My dutch friends would probably kill me ;)
01:30:19 <shapr> minä rakastan suklata!
01:30:46 * TheStar departs for TV
01:30:57 <musasabi> Isn't identity problematic to pureness.
01:31:02 <shapr> Dutch is nifty, 'graag gedann' spoken by natives of Nijmegen sounds like it requires years of heavy smoking just to get in shape.
01:31:07 <musasabi> or at least makes things hard to understand.
01:31:20 <musasabi> "let a = b in a == b"
01:31:25 <nlv11757_> its 'graag gedaan' actually
01:31:32 <shapr> whoops, thanks.
01:31:50 <shapr> Still sounds like someone is gonna blow a vocal cord :-)
01:32:16 <pesco> musasabi: Yes, identity (as you mean it) kills pureness (as we mean it). Because a function could decide what to do based on the "identity" (think memory location) of its arguments.
01:32:22 <tuomov> what kind of g is it? is it like, say, in 'gamma', or err.. how it is pronounced as letter in english?
01:32:39 <shapr> tuomov: it's the sound a really pissed off dog makes
01:32:45 <musasabi> pesco: did you get the xsymbol thing btw?
01:32:46 <nlv11757_> they used to test if someone was a german by letting them do the "g" thing
01:32:57 <pesco> musasabi: Yes I did.
01:33:06 <shapr> tuomov: it's like gargling in the back of your throat
01:33:28 <pesco> musasabi: But it's kind of orthogonal to what I'm doing. I think.
01:34:23 <musasabi> pesco: true, it's not the whole solution.
01:34:50 <musasabi> pesco: of course things like haddock will die on unicode symbols probably.
01:34:51 <pesco> musasabi: Yes. I _want_ Unicode characters in my source. Not a fancy way to look at ASCII art.
01:35:06 <pesco> musasabi: Haddock. I don't use anyway. ;-)
01:35:18 * musasabi lives too far of in the iso-8859-1 land.
01:36:01 <musasabi> and anyways my haskell sources should be all in ascii.
01:43:59 <shapr> I want unicode too.
01:44:34 <adiabatic> There's something that lacks unicode?
01:50:02 <TheStar> So, there is no language that (actually requires) separates library code from program code?
01:53:44 * Lemmih throws a lambda after wxHaskell.
01:54:03 <shapr> TheStar: have you already seen OCaml's module system?
01:57:18 <Lemmih> Oejet!
01:58:37 <Oejet> Hello, Lemmih.  You are up early, I see. ;-)
01:58:59 <Lemmih> Been up since 6am (:
01:59:31 <Oejet> Nice.  I slept like a baboon and just got up now.
02:01:02 <Lemmih> A new month will soon begin so I'm doing paying but less fun work /-:
02:01:05 <adiabatic> hrm...
02:01:38 <adiabatic> "foldl (*) 1 [1..100000]" sure is taking a while.
02:02:50 <adiabatic> silly newbie question: what are folds good for other than implementing summations?
02:04:21 <kosmikus> nearly every kind of function that operates on an input list
02:04:25 <musasabi> adiabatic: fold is a traversal of a structure - thus very usefull.
02:05:13 <TheStar> shapr, Actually, it is through this language that I've been learning about Haskell and other functional languages.
02:12:54 <TheStar> shapr, It's like "How can we simplify and make faster? How can we allow _easier_ programming, etc?" and all the solutions remind me that "didn't that book on haskell have _something_ like it?", so of course I then go back to the book and this channell... ;)
02:13:40 <shapr> There are two kinds of faster, faster thinking and faster execution of programs. Sadly, most people are interested in the latter.
02:13:59 <TheStar> shapr, I want a good intersection between the two.
02:13:59 <shapr> I'm more interested in faster development via simpler systems.
02:14:21 <shapr> I'm beginning to think that sufficiently simple systems are just going to be fast.
02:14:32 <TheStar> That's the approach I'm taking.
02:14:42 <shapr> Have you wrapped your head around monads?
02:15:08 <TheStar> Unfortunately, I've made it *incredably* simlpe... It's not complex enough to define libraries, hence the separation.
02:15:13 <shapr> http://www.scannedinavian.com/2004-11-05.html
02:15:35 <TheStar> afaik, monads only provide a place to store state...  If I have pass-by-ref, and mutable arguments, there's no need for monads, right?
02:15:59 <shapr> Monads are an abstraction, in the same way that objects are an abstraction.
02:16:17 <shapr> And in fact, it's just the three pieces monadic interface that is the whole of monads.
02:16:18 <earthy> monads provide a place to hide stuff
02:16:26 <shapr> Right, abstraction.
02:16:30 <TheStar> Why should I need a monad?
02:16:39 <shapr> Because you want simple and powerful systems.
02:16:45 <earthy> do you want to hide the ref passing?
02:16:50 <earthy> in parts of your ssystem?
02:16:52 <shapr> And monads is the best combination of that that I know of.
02:16:58 <TheStar> earthy, No.  *EVERYTHING* is passed by ref.
02:17:12 <TheStar> earthy, Strings and Integers are by default immutable, however.
02:17:31 <earthy> um, but there are no statements that take no arguments?
02:17:59 <tuomov> TheStar: I think lua works that way..
02:18:02 <TheStar> earthy, What do you mean?
02:18:12 <TheStar> tuomov, I've been introduced to lua...
02:18:16 <TheStar> tuomov, Didn't rock my boat.
02:25:09 <shapr> y0 cptchaos
02:25:42 <shapr> musasabi: can you explain this? - data Interval = All Interval Interval | Not Interval | And Interval Interval | Or Interval Interval | Hour ... | Day ... | Weekday ...
02:27:43 <shapr> coi jewel
02:29:26 <shapr> .a'ucu'i
02:36:40 <shapr> mi najundi gunka
02:36:45 <basti_> hi
02:36:54 <shapr> hiya basti_
02:37:41 <pesco> Lemmih: I'd like to talk a bit about the module/package discussion on haskell@. I don't have time right now, will you be online later, say in 10 hours?
02:37:47 <basti_> I'm cooperating with oejet for my tmr article now
02:38:17 <shapr> cool!
02:38:33 <shapr> speaking of which, I could put up the author wiki rather than hack on this Othello game
02:39:14 <basti_> :)
02:39:48 <pesco> shapr: You said it's all Wiki-publishing this time, right?
02:40:03 <basti_> it is?
02:40:08 <shapr> mi nacaca'a gunju'i
02:40:17 <basti_> are you learning hindi?
02:40:20 <shapr> Yes, wiki-publishing.
02:40:25 <shapr> @cmafihe mi nacaca'a gunju'i
02:40:26 <lambdabot> mi <KOhA3> [I, me] nacaca'a <NA PU*> [not currently is] gunju'i <BRIVLA
02:40:26 <lambdabot>  [work-attentive]
02:40:26 <basti_> oh.
02:40:40 <shapr> basti_: happily, you'll still be able to use all your cool LaTeX hacks
02:40:51 <basti_> phew.
02:41:11 <shapr> if not, I'll make an exception for your article, embedded lilypond is way spiffy.
02:41:25 <pesco> What is lilypond?!
02:41:32 <basti_> well i think it should be a quick thing to convert my file to html via latex2html
02:41:33 <shapr> jewel: xu do nacaca'a gunju'i
02:41:36 <basti_> its all ps after all
02:41:43 <basti_> pesco: score typesetting utility
02:41:46 <shapr> pesco: http://lilypond.org/web/
02:41:59 <pesco> I see.
02:42:25 <shapr> pesco: http://lilypond.org/web/images/sondag-morgen.png
02:42:47 <shapr> Doing that in .lhs is worth an exception.
02:43:00 <basti_> =)
02:43:02 <pesco> Very cool.
02:43:26 <shapr> basti_: that's lojban, just another fun language toy.
02:43:48 <basti_> it does beautiful score. Sadly the language is pretty brain damaged.
02:43:56 <pesco> :(
02:44:12 <basti_> but there is a midi-to-lilypond tool
02:44:28 <TheHunter> ok, if we have "class Functor m => Monad m", then Monad is a subclass of Functor, right?
02:44:32 <basti_> so you can edit almost anything in a decent environment and then add the rest by hand
02:44:38 <TheStar> What are Monads?
02:44:57 <basti_> if we only knew.
02:45:21 <TheHunter> @wiki UsingMonads
02:45:22 <lambdabot> http://www.haskell.org/hawiki/UsingMonads
02:45:28 <TheHunter> @wiki MonadsAsContainers
02:45:29 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
02:45:34 <TheStar> basti_, I always thought they were "just" a way to store some kind of state, ie, a mutable variable that's passed by ref?
02:45:35 <skew> TheHunter: I've got a pretty commutativity diagram for that
02:46:04 <skew> TheHunter: nah, monads are good for a lot more, unless you have an unusually general definition of "state"
02:46:20 <basti_> TheStar: i was just kidding
02:46:37 <TheStar> skew, My definition of state is extremely general.
02:46:49 <basti_> TheStar: but i think you got the idea of the use of monads. The Details are pretty gory.
02:46:56 <shapr> TheStar: puerto rico?
02:47:02 <TheHunter> skew, i didn't mean to imply that monads can only be used for state, does one of the wiki pages say that?
02:47:07 <TheStar> basti_, Why would they be so gory?
02:47:13 <TheStar> shammah, Pardon?
02:47:34 <TheStar> shapr, I'm just sick of trying to figure out what you mean, when you could be speaking in any of 7 different languages!
02:47:36 <shapr> TheStar: virgin islands?
02:47:47 <basti_> TheStar: types plays a big role
02:48:03 <shapr> TheStar: you said your definition of state is extremely general, so I wondered, do you count puerto rico and the virgin islands?
02:48:22 <TheStar> shapr, Haha.
02:48:32 <TheStar> shapr, Australia has states in it, but it's still one island.
02:48:33 <pesco> :)
02:48:38 <skew> TheStar: The three examples I would suggest considering are the list monad, as nondeterminism, the continuation monad, and the reverse-propagating state monad for general insanity
02:48:45 <TheStar> basti_, Please explain.
02:48:47 <sqrt> a monad is a functor from a category to it self and some natural transformations that behave nicely.
02:49:04 <basti_> @type >>=
02:49:08 <lambdabot> bzzt
02:49:09 <basti_> hm
02:49:13 <pesco> @type (>>=)
02:49:14 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
02:49:15 <basti_> ah
02:49:16 <TheHunter> skew, reverse-propagating state _monad_ ?
02:49:20 <TheStar> skew, I'm having the continuation monad built-in, and the list is just a generic type, and finally reverse-propagating is just a mutable variable passed by reference. Imho.
02:49:22 <basti_> TheStar: 'nuff said? ;)
02:49:55 <skew> What do you mean having the continuation monad built-in?
02:49:55 <pesco> skew: What is reverse-propagating state?!
02:50:29 <skew> it's just like the state monad, except the state is wired up in the other way
02:50:38 <TheStar> skew, Well, I'm using continuation passing style.
02:50:48 <TheStar> skew, Thus, continuations are built-in.
02:50:51 <TheHunter> data RevState s a = ?
02:51:17 <pesco> TheStar: Monads unlock no new functionality! They present a way to abstract the formulation of programs using certain things, like continuations, state, IO, etc.
02:51:18 <skew> I seriously doubt you can get the reverse-propagaing state by passing a mutable variable by reference in any sane language, without macros or monads or something
02:51:36 <skew> data RevState s a = RevState (s -> (a,s))
02:51:44 <skew> it's the bind operator that is interesting
02:52:05 <TheStar> pesco, I believe I'm calling such a monad a "library" then.
02:52:07 <shapr> TheStar: Sorry about my nonlinearity, it's my normal mode of operating.
02:52:26 <TheStar> shapr, I've gathered that.
02:52:52 <pesco> TheStar: Just have a look at the different Haskell Monads.
02:53:30 <shapr> Linear communication isn't easy for me.
02:53:36 <pesco> TheStar: The point is that Monad is a type class, i.e. all Monads exhibit the same interface, i.e. "do notation" basically.
02:53:40 <TheStar> pesco, I believe I know what they are, just that I was using different terminology.
02:53:59 <TheStar> pesco, Wow, that's *exactly* how I've designed my language, actually!
02:54:17 <TheStar> pesco, Except, monad's are quite complex to define.
02:54:24 <pesco> Hm.
02:54:35 <TheStar> pesco, Unbelievably simple to use, but complex to define. (Thus, a good library is essential)
02:54:58 <skew> (RevState m1) >>= f = RevState (\bottomState -> let m2 = f a1; (a2,midState) = m2 bottomState; (a1,topState) = m1 midState in (a2,topState))
02:55:35 <skew> that is, the 'a' in s -> (a,s) is passed along to the next statement by bind, but the 's' is wired up from each statement to the previous one
02:57:48 <skew> People noticed when the unix time hit 1111111111. Has anybody realized 0x42424242 is just over a day away?
02:57:55 <shapr> wow!
02:58:01 <shapr> post to slashdot!
02:58:04 <basti_> -g-
02:58:17 <shapr> I still want \. for the Haskell community site name.
02:58:25 <pesco> Yes! Me too!
02:58:31 <adiabatic> backslash-dot?
02:58:33 <skew> \.?
02:58:47 <TheStar> www.slashdot.org
02:59:09 <TheStar> Incredibly popular site for bored geeks.
02:59:10 <pesco> That's for wussies. We hang out on backslashdot.org.
02:59:12 <pesco> Or so I wish.
02:59:16 <shapr> adiabatic: in lambda calculus, \x.x is \x -> x
02:59:23 <TheStar> Ah, yeah.
02:59:40 <skew> I wrote my own binary clock yesterday. It shows seconds since the epoch.
02:59:52 <basti_> slashdot is not only popular, it is also stupid.
02:59:55 <TheStar> skew, Why not do seconds since the year 0?
02:59:58 <TheStar> basti_, Agreed.
03:00:02 <smott> slashdot is horrible
03:00:03 <shapr> basti_: yeah, usually.
03:00:14 <TheStar> skew, And have negative numbers for years before that year? ;)
03:00:14 <shapr> but it's great entertainment.
03:00:22 <basti_> yep
03:00:30 <smott> the only worthwhile thing on slashdot is trolltalk
03:00:34 <basti_> especially further down the scroll
03:00:50 <shapr> I keep trying to convert the masses on slashdot. Surprisingly, there are some converts.
03:01:01 <basti_> when people start talking about hitler, or about microsoft.
03:01:09 <basti_> or both. or about jesus christ.
03:01:10 <basti_> (!)
03:01:15 <shapr> You know Godwin's Law?
03:01:18 <basti_> yes
03:01:35 <shapr> btw, does anyone know if there are detailed specs on the Cell CPU anywhere?
03:01:47 * basti_ was useing FIDO when this was actual
03:01:49 <TheStar> I believe I do use Monads in my language design.
03:01:49 <skew> shapr: aren't we supposed to avoid success at all costs?
03:02:20 <basti_> TheStar: actually, one could view C as being only monads ;)
03:02:27 <TheStar> basti_, True.
03:02:31 <TheStar> basti_, But not quite.
03:02:40 <skew> actually just the 'C' mond
03:02:41 <shapr> skew: C++ and Java are the languages du jour, I think we're safe.
03:02:43 <TheStar> basti_, I view monads as an object in most object languages.
03:02:55 <skew> TheStar: that makes little sense
03:02:57 <basti_> C doesnt have a monad object no
03:03:03 <shapr> I would like to continue siphoning off the developers with braincells though.
03:03:06 <TheStar> skew, Why's that?
03:03:20 <skew> TheStar: monads are a notion of sequencing, that's what moggi made them for
03:03:24 <shapr> You could say that every C function is implicity IO
03:03:25 <TheStar> skew, It's methods are associated with that object, just like functions are made for a type.
03:03:28 <shapr> but that's sort of sick.
03:03:48 * TheStar needs to complete his C# assignment...
03:04:01 <shapr> TheStar: go through the nomaware monads tutorial, much will become clear.
03:04:04 <skew> Does GHC generate .NET code yet?
03:04:20 <skew> perhaps a C# assignment could become a Haskell assignment :)
03:04:31 <TheStar> skew, The assignment explicitly specifies the language, the VS.NET, and right down to the darn C# template to use!
03:04:43 <skew> sounds stupid
03:04:44 <TheStar> skew, Unfortunately, it becomes very vague in the problem specification itself...
03:05:00 <skew> doubly so
03:05:05 <TheStar> Indeed.
03:05:15 <shapr> skew: btw, what happened to PHI?
03:05:20 <skew> man, picking the language before they even decide what to build
03:05:25 <skew> shapr: still full of segfaults
03:05:33 <shapr> did you see John Goerzen's version of PHI?
03:05:38 <TheStar> I believe GHC is listed as being a .net language, but so is Python, and I know that I cannot get a decent python to .net interpretor or compiler.
03:05:45 <TheStar> skew, Well, it *is* a C# lecture.
03:05:58 <TheStar> skew, But, I'd have saved so much time using 'notepad' instead of vs.net
03:06:22 <shapr> dons: speaking of vs.net, any word on the synhl for Yi?
03:06:35 <TheStar> synhl?
03:06:42 <shapr> dons: or, could I look at the preview implementation?
03:06:43 <TheStar> Ahh, syntax highlighting. Mine seems to work.
03:07:02 <TheStar> shapr, btw, my name is "TheStar".
03:07:30 <shapr> yes?
03:07:32 <shapr> I know that.
03:07:37 * shapr is confused
03:07:48 <TheStar> shapr, Just think multi-non-linearly.
03:08:09 <nothingmuch> hola
03:08:20 <TheStar> nothingmuch, You speak italian?
03:08:21 <nothingmuch> i'm trying to fix something in pugs
03:08:29 <shapr> dons has written a large portion of a programmer's editor in Haskell, but the syntax highlighting isn't ready yet. So I was asking him about it.
03:08:29 <nothingmuch> nope, sorry
03:08:39 <shapr> TheStar: hola is spanish
03:08:49 <shapr> nothingmuch: ¿hola, como est as?
03:08:50 <nothingmuch> and there are two files, Eval.hs and Bind.hs
03:08:56 <TheStar> shapr, Shows how much I need to learn about italian, heh?
03:09:03 <nothingmuch> eval uses, bind, but now bind will need to use eval too
03:09:04 <skew> shapr: what did John do?
03:09:11 <nothingmuch> so naively i just added import Eval to the top
03:09:16 <nothingmuch> but that complained about cyclic import
03:09:18 <shapr> skew: he rewrite the whole thing, lemme find the url...
03:09:23 <nothingmuch> how can that be fixed?
03:09:32 <nothingmuch> shapr: sorry, no espaÃ±a either...
03:09:44 <shapr> nothingmuch: easiest is to move the code around so you don't have to do that.
03:09:54 <nothingmuch> =(
03:10:04 <shapr> there is a way have recursive modules, but it's not pain-free.
03:10:20 <TheStar> Why would you want recursive modules?
03:10:24 <shapr> You have to compile the modules to .hi files to get recursive modules.
03:10:27 <nothingmuch> TheStar: i don't
03:10:40 <nothingmuch> the original design sort of assumed they aren't recursive
03:10:46 <TheStar> Ahh.
03:10:50 <nothingmuch> but it turns out that it didn't take into account a certain aspect
03:11:05 <TheStar> Is it a limitation if modules *cannot* recurse?
03:11:16 <TheStar> Because in my design, modules basically cannot recurse.
03:11:33 * nothingmuch doesn't know
03:11:38 <TheStar> (Unfortunately that's currently at runtime)
03:11:48 <skew> well, everything else in Haskel is lazy, so recursive modules might as well be allowed
03:11:52 <TheStar> (And that recursion thing may well succeed most of the time, but it isn't guaranteed to work)
03:14:34 <TheStar> (Infact, this recursion thing is still being developed, but imho, recursive code should be deliberately so)
03:14:49 <skew> TheStar: what are you talking about building?
03:14:59 <TheStar> A custom language :)
03:15:04 <Si\> does anyone use HList often?
03:15:14 <nothingmuch> i think it might be nice to have recursive modules
03:15:20 <nothingmuch> simply for the sake of splitting up code into files
03:15:28 <TheStar> nothingmuch, Example?
03:15:30 <sqrt> TheStar: are you making a compiler in C#? (?!)
03:15:39 <TheStar> sqrt, *shudder*
03:15:42 <TheStar> sqrt, Certainly not.
03:15:43 <nothingmuch> TheStar: just now
03:15:45 <tuomov> you can have recursive modules if you bother to write .hi-boot files
03:15:46 <sqrt> pheeeww
03:15:46 <nothingmuch> =)
03:15:55 <tuomov> this should be automated at least
03:15:56 <nothingmuch> the implementation of pugs is basically ops on an AST
03:15:59 <skew> does anyone know a nice way of parsing expressions with precedence in Happy?
03:16:05 <nothingmuch> Eval.hs deals with making expressions into flat values
03:16:07 <tuomov> ghc -some-option trying to figure out what can be put in .hit-boot
03:16:16 <nothingmuch> Bind.hs does parameter binding for subroutine invocation
03:16:34 <skew> I'm a bit too lazy to encode the precedence in the grammar the normal way
03:16:50 <TheStar> nothingmuch, Oh, that'll still work.  My language organizes the language... differently.
03:16:59 <shapr> nothingmuch: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
03:17:09 <nothingmuch> i'm talking about haskell/ghc, TheStar
03:17:12 <hellish> I'm trying to define a type constructor for circular lists, what I have so far is: toDeck x = MkDeck (x : (toDeck x)) which is a type error. How would I do this?
03:17:17 <nothingmuch> i have no clue what your language is ;-)
03:17:29 <TheStar> nothingmuch, My language exists only as a figment of my imagination, actually :)
03:17:38 <skew> hellish: why do you need a new type?
03:17:40 <TheStar> nothingmuch, But it's getting mroe and more defined. One day I'll actually implement it.
03:17:55 <nothingmuch> well, good luck with it then!
03:18:02 <TheStar> (The frightening thing is that it's supposed to scale better than erlang and have two different vm's)
03:18:10 <skew> hellish: plain old [] words just fine for circular lists, and I can't think of any easy way to enforce circularity with the type
03:18:32 <TheStar> skew, Can't you define a circular list?
03:18:41 <skew> of course you can
03:18:41 <nothingmuch> anyway, ciao!
03:18:44 <shapr> hellish: looks like you want ones = 1 : ones
03:18:56 <skew> ones = 1 : ones is an easy example
03:19:09 <shapr> There's also the credit card transform.
03:19:20 <hellish> Credit card transform?
03:19:21 <skew> wow, I didn't realized it was canonical enough that shapr would suggest it
03:19:24 <shapr> greetings JaffaCake
03:19:38 <JaffaCake> hey there
03:19:40 <shapr> I wasn't aware anything I do is canonical =)
03:19:51 <skew> I thought you said 'credit card transfer', like shuffling your balance between several credit cards so you never have to pay it off
03:20:06 <shapr> @wiki CreditCardTransform
03:20:07 <lambdabot> http://www.haskell.org/hawiki/CreditCardTransform
03:20:09 * TheStar wonders why the heck C# doesn't have lazy evaluation.
03:20:26 <TheStar> The function that actually *wants* the file should be able to deal with infinite files!
03:20:40 <TheStar> Rather than the bottleneck occuring at the function that *gets* the file.
03:21:34 <TheStar> My computer gets *EXTREMELY* slow iwth 68 MB files in C# :(
03:21:45 <TheStar> *sigh*.  I hate vs.net and c#, anyway.
03:22:11 <shapr> g'day Svrog
03:22:23 * shapr grumbles at CiteSeer.
03:22:26 <Svrog> hey shapr
03:22:29 <Svrog> how's it going?
03:22:30 <shapr> I wish CiteSeer would stay up!
03:22:32 <skew> shapr: That @wiki thing isn't much use to *me*. I'm using ion without a mouse so I can't grab the url, and my firefox has a hawiki keyword already :)
03:22:43 <TheHunter> skew, what operations does RevState support?
03:22:58 <TheHunter> seems that it leads to nontermination quite easily here.
03:23:05 <skew> TheHunter: the usual state monad operations, with the usual definitions: get, put
03:23:16 <tuomov> does everyone here use ion?-)
03:23:18 <skew> it does make it easy to fail to terminate
03:23:29 <shapr> skew: I'm using ion, and I rarely use the mouse. I have F8 bound to a custom my-jump defun in emacs, so I can hit F8 at the beginning of an url, and browse-url-galeon is called to load that url in the current tab.
03:23:37 <shapr> tuomov: do you use ion? =)
03:23:42 <shapr> I bet JaffaCake doesn't use ion.
03:24:00 <JaffaCake> ion?
03:24:22 <shapr> ion is a keyboard-friendly window manager for X.
03:24:25 <TheHunter> skew, i'm still thinking something like reverse-propagated state should be a comonad (or an arrow, for that matter)
03:24:40 <skew> nah, comonads are totally differnt
03:24:40 <shapr> http://iki.fi/~tuomov/ion/
03:24:49 <JaffaCake> I use Windows as my X window manager :)
03:24:54 <Svrog> any opengl programmers here?
03:24:58 <shammah> anyone here familiar with darcs?
03:25:06 <shapr> shammah: oh I've used darcs before!
03:25:15 <shammah> hey shapr.
03:25:24 <shapr> greetings Andrae
03:25:30 <shammah> I was wondering how darcs handles binary files?
03:25:40 <shapr> it just stuffs them into the repo.
03:26:00 <Svrog> im just wondering whether ghc 6.4 supports ogl2 as the documentation claims cause the library states that ghc only has bindings for 1.5
03:26:02 <skew> TheHunter: it's a monad all right - this is a good example for stretching insufficiently general conceptions of what can be a monad
03:26:03 <TheHunter> data Context c a = Context (c -> a) c
03:26:27 <Svrog> also it doesn't seem to support shaders
03:26:41 <shammah> shapr, It manages binary diffs ok, without problems?
03:26:58 <shapr> shammah: I don't think it does binary diffs
03:27:08 <shammah> I was looking for the equiv' of cvs add -k
03:27:14 <shapr> What does that do?
03:27:16 <TheHunter> skew, it kinda seems to me like: ok, if a monad isn't good enough for what we want to do, let's just loop.
03:27:21 <skew> reverse state and continuations helped me figure out that monads weren't just about threading along normal state
03:27:36 <TheStar> skew, Now, please exlpain that and threading?
03:27:53 <skew> TheHunter: nah, it's just that state going backwards and bindings going forward makes it easy to write loops
03:27:55 <TheStar> skew, See, in my language I'm incorporating the threading responsibility to the monad itself (don't ask me how)
03:28:03 <TheStar> skew, So I'm certainly interested.
03:28:13 <TheHunter> do you have any reading material on that reverse state monad?
03:28:16 <skew> TheHunter: huh?
03:28:17 <shammah> It adds the file as binary, and prevents attempts to perform a diff.  Changes are handled by moving old versions to the attic and replacing the entire file within the repository.
03:28:29 <skew> TheHunter: It was an example in some paper, but I don't remember where
03:29:31 * TheStar is performing looping strictly via function recursion.
03:29:36 <TheHunter> skew, huh? what?
03:29:42 <skew> They were like "okay, now let's thread the state the other way. Why? because we can! Translating this to C is left as an excercise for the masochistic reader."
03:29:58 <TheStar> skew, I'd probably try just that! ;)
03:30:18 <shapr> shammah: afaik, that's the only way darcs handles binary files.
03:30:25 <skew> Okay, now I'm confused. Which The* is talking to me about what?
03:30:46 <TheStar> skew, Usually me, at the moment.
03:30:46 <shammah> shapr: it autodetects them, no need to provide cmdline args?
03:30:55 <TheShapr> skew: evil strikes!
03:31:22 <TheHunter> skew, ok, I guess the huh? wasn't directed at me...
03:31:23 <Svrog> haha
03:31:33 <TheStar> TheHunter, You are correct.
03:31:36 <TheShapr> shammah: I think so.
03:31:57 <TheShapr> shammah: some people say it's too eager to detect files as binary.
03:32:08 <skew> TheShapr: no, that was about "if a monad isn't good enough we just loop"
03:32:15 <skew> er that was for TheHunter
03:32:24 <skew> you're confusing my autocomplete now!
03:32:25 <TheStar> TheShapr, Funny you say that, because now my C# program is reading my text fiel as binary.
03:32:38 <TheStar> skew, Just type in five letters ;)
03:32:50 <skew> TheHunter: I didn't understand what that meant
03:33:23 <TheStar> skew, TheHunter you just accidently referred to each other.  Turn around and walk in the opposite directions!
03:33:24 <xerox> 'morning
03:33:26 * TheShapr cackles evilly
03:33:36 <TheSkew> yay, confusion for all
03:33:38 <shapr> runaway!
03:33:56 * shapr cackles
03:34:05 <TheStar> 5 letters isn't much considering my Jabber nick.
03:34:28 <Arafangion> :)
03:34:32 <TheHunter> skew, ok, i take that back, it's ok for monads to produce loops.
03:34:53 <skew> TheStar: now, what were you asking about threading and something I was talking about?
03:35:04 <Arafangion> skew, I wanted to know what kind of threading you meant.
03:35:28 <Arafangion> skew, Because it seems that erlang, for instance, threads in one way, and java/et/al thread in another very particular way, then there's the way Python threads...
03:35:33 <skew> Arafangion: oh, I meant the way the state is passed along. That's usually called threading too
03:35:45 <Arafangion> skew, And I wanted to know what *that* was too :)
03:36:00 <Arafangion> skew, See, I'm attempting to make threading transparent to the application developer.
03:36:04 <skew> Arafangion: When you pretend to have mutable state
03:36:12 * TheHunter will fool around with RevState a bit before he makes any further comments.
03:36:14 <Arafangion> skew, And so far it seems that I am succeding.
03:36:37 <skew> Arafangion: You pass in an immutable value representing the old state to a function, and it returns a pair of its result and the new value representing the state
03:37:14 <skew> Arafangion: Then you connect up the result state from one function with the state argument on the next, and it's almost like you have a mutable memory cell
03:37:32 <Arafangion> skew, Isn't that really just fudging around the fact that (as far as the programmer is concerned), arguments are passed by value?
03:37:37 <skew> Arafangion: It's called "threading" because there is one chain of data dependencies
03:37:49 <skew> Arafangion: and it has nothing to do with the calling convention
03:37:58 <Arafangion> skew, Actually, that is an interesting concept...
03:38:07 <Arafangion> skew, I quite like it.
03:38:27 <skew> Arafangion: That's the pattern the State monad abstracts
03:38:33 <Arafangion> skew, Now I have to figure out how to transparently incorporate that idea ;)
03:39:02 <Arafangion> skew, Unfortunately, in my language, passing by reference is *faster*.
03:39:26 <skew> Arafangion: actually, I don't think using that encoding of state is a very good way of providing mutable state
03:39:50 <Arafangion> skew, But I could easily emulate that by having a "context" counter, and calling "get value at context <context_id>"
03:40:09 <Svrog> Arafangion: have a look at the state transformer monad - it's pretty simple and it illustrates the concept pretty well
03:40:09 <Arafangion> skew, Maybe not, but it sure does help with stack thrashing and al lthat.
03:40:29 <Arafangion> Svrog, Why? I have understood the concept.
03:40:34 <Arafangion> Svrog, Now, anyway ;)
03:40:39 <Svrog> oh right - sorry then
03:40:45 <Svrog> just trying to be helpful :)
03:42:02 <Arafangion> Svrog, :)  It does help that I'm not learning haskell per se, but just picking up concepts.
03:42:15 <Svrog> cool
03:42:40 <Arafangion> Svrog, It never amazes me how many things I discover when playing in my own language, then discovering that haskell already has soemthing like it.
03:42:42 <shapr> Arafangion: it's possible you'll pick up the concepts faster and with greater clarity if you learn Haskell. It might be worth your while.
03:42:55 <Arafangion> shapr, I actually have a book on Haskell.
03:42:56 <Svrog> i agree with shapr
03:43:02 <Arafangion> shapr, And I've been reading it.
03:43:21 <skew> Arafangion: Haskell has everything
03:43:23 <Arafangion> shapr, But, I understood and grokked the concept skew was discussing very quickly.
03:43:30 <Arafangion> skew, Except truely mutable state, it appears.
03:43:44 <shapr> I propose that you cannot grok something unless you have used it for something.
03:44:02 <shapr> But maybe that's just me.
03:44:04 <Arafangion> shapr, I do not agree.
03:44:10 <skew> Arafangion: Haskell provides the raw material programming language semantics are build out of
03:44:43 <Arafangion> skew, What an obscure sentence structure!
03:44:48 <Svrog> Arafangion: haskell basically simulates mutable variables and side-effects through it's type system - it basically offloads all the dirty bits to the type system and thats how it remains pure :)
03:45:03 <Arafangion> Svrog, I realise that.
03:45:06 <skew> Arafangion: Haskell does have mutable variables, actuall
03:45:15 <skew> Arafangion: They're just in the IO monad.
03:45:33 <Arafangion> Svrog, I thought long and hard about whether values should be mutable/immutable and whether they should be ref-passed or value-passed.
03:45:51 <shammah> shapr, Well I just managed to crash darcs with a stack overflow checking out a small project and it's support files.
03:46:29 <shapr> shammah: wow
03:46:40 <shapr> shammah: 1.0.2 ?
03:46:48 <Arafangion> Svrog, I've decided to use mutable and passing by reference, at the cost of "zero side effects".
03:46:50 <skew> Does anyone know if there is a way to write a monad with pure code providing the same interface as ST?
03:47:04 <TheHunter> skew, i think it's impossible.
03:47:04 <Arafangion> Svrog, But that above discussion gave me an idea how to regain "zero side effects".
03:48:19 <shapr> skew: there was a mailing list discussion about what is possible to do with pure code, Hal Daume was the main author of that thread.
03:48:20 <Arafangion> Svrog, At the unfortunate cost of increased RAM useage, but I think that can be eliminated with fancy code.
03:48:20 <TheHunter> skew, you need some unsafeCoerce# magic, as in the Prompt monad in this paper: http://www.cs.indiana.edu/~sabry/papers/monadicSubcont.pdf
03:48:37 <Arafangion> Svrog, And the increased CPU overheads should still be minimal.
03:49:13 <Arafangion> Svrog, My implementation, if it's ever realised, would most likely be at *least* BSD :)
03:49:35 <hellish> I have a function for moving items around in lists, but I need to do it circularly. By the time my code recognizes that it's reached it the end of the list, the beginning has fallen out of scope. What do I do from here?
03:50:12 <hellish> Do I need to write a monad?
03:50:15 <skew> Arafangion: the implementations details don't matter as long as it looks nice from inside the language
03:50:17 <Svrog> note that you can have a pure functional language even without monads and still have side-effects - you have to give up out-of-order execution (in other words all your code has to be sequential) - in essence this would basically be like using the IO monad for every function in haskell
03:50:38 <Arafangion> skew, That's what I'm attempting.  It does have an unfortunate split between app code and lib code :(
03:50:47 <shapr> hej bringert
03:50:50 <tuomov> clean
03:50:56 <bringert> hej
03:51:06 <shapr> hellish: maybe use map?
03:51:16 <Arafangion> Svrog, All my code is absolutely sequential, for all intents and purposes.
03:51:30 <skew> Arafangion: The language Clean has a type system that can enforce "single-threaded" use in this state-threading stuff, and ends up compiling down to an actual mutable memory cell
03:52:11 <nlv11757_> uniqueness typing yeeey
03:52:11 <Svrog> i should probably check clean out at some point.. my impression was that it wasnt as elegant as haskell
03:52:14 <Svrog> or joy
03:52:32 <hellish> shapr, how does map help here? isn't the function passed to map scoped in the same way?
03:52:32 <nlv11757_> i'd go for Haskell
03:52:51 <nlv11757_> especially for the long run
03:53:55 <Muad_Dibber> why that so nlv11757_?
03:54:18 <Muad_Dibber> i mean, if you wouldn't go for haskell you wouldnt b e here
03:54:19 <Muad_Dibber> :)
03:54:21 <shapr> hellish: can you paste your code on the wiki paste page?
03:54:31 <hellish> it's there already
03:54:34 <Svrog> well for me its not about choosing a language at this point - more about just seeing what the alternatives (like clean) are like - im quite happy with haskell and caml... and to a lesser extent joy (i think joy would be great with a slightly modified syntax and an implementation that isn't a toy)
03:54:56 <hellish> shapr, under hellish's code heading, towards the end of the page.
03:55:00 <nlv11757_> well, i once had to look inside the code generation of Clean and....i was staggered by the fact that probably only one person knows how it actually works. So if this guy gets run over....the're doomed
03:55:24 <nlv11757_> documentation was poor to say the least imo
03:55:33 <Arafangion> skew, But I want my program to be massively multi-threaded.
03:55:34 <shapr> 'low bus number'
03:55:54 <shapr> Arafangion: threads don't scale, choose declarative concurrency.
03:56:07 <skew> Arafangion: I think that's totally unrelated to simulating mutable state
03:56:07 <Svrog> nlv11757_: thats a bit harsh - im sure someone would continue the work on it
03:56:21 <Arafangion> skew, It's realated to your reference to "clean".
03:56:21 * shapr starts writing BusSpotting
03:56:34 <nlv11757_> Svrog: thats exactly what I mean, i don't think it will really be continued at some point
03:56:34 <Arafangion> shapr, Threads enter a queue when they block.
03:56:46 <Arafangion> shapr, And why shouldn't threads scale?
03:56:59 <shapr> For the same reason they never have scaled before.
03:57:07 <Arafangion> shapr, Unlike Erlang?
03:57:12 <nlv11757_> context-switching overhead?
03:57:34 <Svrog> that depends on its user base - if they have any people who are as enthusiastic about clean as people here are enthusiastic about haskell im sure it would continue
03:57:42 <Arafangion> nlv11757_, I have aranged my code to not rely on contexes.
03:57:52 <Arafangion> nlv11757_, Otherwise known as the stack, I understand.
03:58:13 <nlv11757_> svrog: i think the base is much broader for Haskell
03:58:19 <skew> He's not saying that you can't use threads to get good performance on N processors, he's saying that if you write for N processors your code won't benifit much from running on 2^N processors
03:58:46 <shapr> and the other way around too
03:59:35 <Arafangion> skew, I'm attempting to scale for N processors automatically, and having everything effectively non-blocking.
03:59:48 <Arafangion> skew, But it makes for a damn complex library, but my focus is on user code.
04:00:03 <Svrog> nlv11757_: im not quite sure if that was supposed to be a sarcastic comment or not considering how i have no idea how large their user base is but as far as i know it's nowhere near the size of the haskell community
04:00:13 <shapr> This year's games are written to not use threads because each thread has overhead, but they can't take advantage of my two cpu desktop. Declarative concurrency is a more general and scalable solution.
04:00:51 <xerox> hellish: what does `move' has to do?
04:00:54 <shapr> Arafangion: http://lambda-the-ultimate.org/node/view/458
04:01:09 <nlv11757_> svrog: it was not my intention to be unpolite or sarcastic :)
04:01:49 <Svrog> oh right - sorry then - i thought you meant broader as in larger? in which case that comes to me as a surprise
04:02:07 <hellish> xerox, it has to moves items in lists around. More specifically, it has to move cards in a virtual deck, to emulate Bruce Schneier's solitaire encryption algorithm.
04:02:24 <hellish> xerox, mostly, this project is to teach me haskell.
04:02:48 <nlv11757_> svrog: im just saying that Clean has a nice thing with uniqueness typing for example, but i think Clean will be bound to vanish because of their small userbase
04:03:10 <Svrog> ah right
04:03:48 <Svrog> i would have been more inclined to check it out earlier if it wasnt for the license - not sure if they updated it
04:04:11 <nlv11757_> ow thats another thing indeed, they have a commercial thing going on
04:04:12 <Lemmih> hellish: It looks like you're viewing a list as a mutable object.
04:04:39 <nlv11757_> maybe because of those commercial things, they didn't bother documenting the internals very well
04:05:15 <hellish> Lemmih, how can I, if nothing is mutable in haskell?
04:05:18 <Svrog> same reason why i rather use caml then mlton - less restrictive license - if mlton was considerably better then caml i would have probably chose it over caml but they're pretty close so i see no reason to stop using caml
04:05:21 <shapr> hellish: yes, you need to rebuild the new list and return it.
04:05:31 <nlv11757_> Lemmeh: isnt IO Ref what hellish needs?
04:05:52 <Lemmih> hellish: You cant. Which is why it's gonna be slow if you do it like that.
04:05:55 <shapr> hellish: probably iterate until or something.
04:05:57 <Svrog> Arafangion: are you writing a language in order to write games in it? just wondering cause of the games related comment shapr made
04:05:59 <nlv11757_> svrog: how do you appreciate the Objective in OCaml?
04:06:00 <Lemmih> nlv11757_: Or just a smarter algorithm.
04:06:06 <xerox> hellish: what is 'move 10 3 [1..10]' supposed to do?
04:06:35 <nlv11757_> Lemmih: common thing :D manouvring in weird positions just to implement wrong ideas, instead of questioning the ideas in the first place
04:06:44 <Svrog> nlv11757_: i dont - i found oo extensions in caml quite useless
04:06:50 <hellish> xerox, return [1,2,3,10,4,5,6,7,8,9]
04:07:08 <xerox> hellish: try it.
04:07:10 <hellish> xerox, err, [1,2,10,3
04:07:12 <nlv11757_> Svrog: cause my experience was, that I found the Objective part extremely confusing
04:07:24 <Svrog> you can pretty much always replace the code using objects with functors
04:07:35 <shapr> hellish: I don't understand what your code is trying to do.
04:07:35 <Svrog> not to mention it runs faster - objects in caml are pretty slow
04:07:57 <hellish> xerox, exception, non-exhaustive patterns.
04:08:34 <shapr> hellish: ah, rip out the item at index X and then insert it into index Y?
04:08:46 <wilx> lambdabot, @wiki
04:08:53 <wilx> Hmpf.
04:08:53 <hellish> shapr, return the list, with the selected item shifted by the amount of the second parameter, while treating the list as if it were circular
04:09:01 <shapr> ohh
04:09:42 <nlv11757_> why not use a list of pairs, where the first part is the index: once you want the real order, just sort on the first element of the tupel (if that represents the index)
04:09:52 <xerox> wilx: http://haskell.org/hawiki/HaskellIrcPastePage
04:11:40 <hellish> nlv11757_, I could, but that just seems inelegant.
04:13:23 <Svrog> why is it inelegant?
04:13:53 <Svrog> as long as the solution is concise and readable it's all good
04:13:56 <Svrog> :)
04:15:04 <nlv11757_> changing order would simply be, change the first element of the tupel
04:15:13 <nlv11757_> could be quite efficient
04:15:24 <shapr> nlv11757_: how would you deal with duplicate order?
04:15:46 <nlv11757_> shapr: with swapping you mean?
04:16:14 <bringert> I've got a problem with fundep / gadt interference I think
04:16:19 <bringert> pasted it
04:16:23 <bringert> http://haskell.org/hawiki/HaskellIrcPastePage
04:16:24 <shapr> with 'move this card forward five' you can't just add five to the position, you need to also subtract one from the cards between.
04:16:49 <nlv11757_> shapr: i think my biggest problem is that i dont know exactly what hellish wants
04:16:57 <bringert> I can implement the same thing with a hideous type class, but it should be doable with straight GADTs + a fundep
04:17:16 <nlv11757_> therefore my suggestion probably doesnt fit his needs completely
04:17:20 <shapr> He wants a data structure that simulates a deck of cards, and he wants a function that shifts a card forward by N
04:17:45 <wilx> lambdabot: @wiki
04:17:45 <lambdabot> http://www.haskell.org/hawiki/
04:17:57 <bringert> ghc doesn't seem to use fundeps after gadt type instantiation
04:17:58 <shapr> shift 1 2 (a,b,c,d) = b,c,a,d
04:18:03 <bringert> or whatever it's called
04:18:07 <wilx> Somebody should teach it to recognize also comma and not only :.
04:18:15 <shapr> wilx: do it!
04:18:21 <wilx> Yay!
04:18:24 <wilx> How?
04:18:28 <wilx> Where's the source?
04:18:32 <Arafangion> Svrog, I'm writing it for non-server programming.
04:18:41 <Arafangion> Svrog, But I don't see why it couldn't be applied to servers.
04:18:53 <shapr> wilx: http://www.scannedinavian.org/~shae/lbot2.1.tgz
04:19:21 <Arafangion> Svrog, To be precise, I'm trying to develop a RAD language, which explaisn my willingness to make libraries so complicated, in order to make the code so simle.
04:19:22 <Svrog> i was just wondering how does it relate to  games? as in why did shapr mention games? or was that in response to something else?
04:19:50 <shapr> Svrog: games came to mind because I can't play America's Army, my PC isn't fast enough by single-cpu measurement.
04:20:01 <shapr> But I have a second CPU, and AA is unable to use it.
04:20:01 <Arafangion> Svrog, He was comming up with an example as to why threads "do not scale"
04:20:02 <Svrog> ah right
04:20:14 <Arafangion> Svrog, My opinion is that if it doesn't scale, the threadign implementation sucks
04:20:35 <shapr> Arafangion: there is no threading implementation that will scale from 1 to 1024 cpus
04:20:56 <Arafangion> shapr, I'm planning on answering that issue with a daemon farm.
04:20:57 <shapr> declarative parallelism will scale far beyond that.
04:21:25 <Svrog> yeah but most games aren't written with multiprocessor systems in mind - and even those that are are somewhat crippled by poor ogl and directx drivers that are again written with single processor systems in mind
04:21:27 <Arafangion> shapr, I'm inspired by Erlang.
04:21:42 <shapr> Arafangion: did you read that LtU url I gave you?
04:21:50 <Arafangion> shapr, In any case, Games are the *last* application that I'm thinking about.
04:21:55 * Arafangion looks for "LtU".
04:22:11 <shapr> the lambda-the-ultimate url
04:22:24 <Arafangion> shapr, Yes.
04:22:28 <Arafangion> "No free lunch".
04:22:38 <Arafangion> I guess I'm aiming for pervasive threading.
04:22:50 <shapr> Did you see my comment about scaling from one core to 256 cores?
04:22:58 <shapr> Threading won't scale. It just won't.
04:23:09 <Svrog> a recent set of ati slides from gdc this year talk about optimizing opengl code and they recommend something along the lines of a single thread that actually does the rendering (if i remember correctly... i kinda just skimmed through it all :) )
04:24:02 <wilx> lambdabot: @moo
04:24:02 <lambdabot>          (__)
04:24:02 <lambdabot>          (oo)
04:24:02 <lambdabot>    /------\/
04:24:02 <lambdabot>   / |    ||
04:24:02 <lambdabot>  *  /\---/\
04:24:03 <lambdabot>     ~~   ~~
04:24:05 <lambdabot> ...."Have you mooed today?"...
04:24:10 <wilx> Yay1 :D
04:24:19 <Svrog> amusing hehe
04:24:35 <shapr> hellish: I think I know how to do it
04:25:59 <Arafangion> shapr, I can't find that comment.
04:26:48 <hellish> shapr, How?
04:28:11 <shapr> hellish: snip the list at the item you want to shift, save the first part, then use Data.List.insert to insert the item into the second list, unless shift is more than the length of the list, in which case you wrap around to the first list
04:28:57 <shapr> hellish: got it?
04:29:47 <hellish> shapr, Think so.
04:29:57 <shapr> I would code it up, but I have to go work now.
04:30:29 <shapr> Arafangion: anyway, the comments under that LtU post discuss threading, declarative parallelism, etc.
04:31:00 <shapr> And I wrote most of what I have to say about those issues there as well
04:34:01 <Svrog> hellish: what is it you're trying to do again?
04:38:51 <Svrog> nevermind - just found it
04:42:29 <nlv11757_> mutable references still seem usefull
04:42:59 <Arafangion> nlv11757_, I love mutable references.
04:43:10 <Arafangion> nlv11757_, I just cry that StringBuilder in C# runs out of RAM fast, it seems.
04:44:48 <Svrog> you could use haskell ;)
04:46:01 <Arafangion> Svrog, I wish.
04:46:17 <Arafangion> Svrog, Heck, I'd be happier if I was allowed to even use my *template of choice*
04:46:21 <Itkovian> I'm kinda stuck defining an instance of a Read class. The idea is to read a String and parse it to a thingie of type (data TT = T Int). so the String consists of only the Int.
04:46:33 <Svrog> you have to use c#?
04:46:36 <Arafangion> Svrog, As it is, The IDE, Language and class template I have to use is set by assignment specification :(
04:46:44 <Svrog> ah
04:46:49 <Arafangion> Svrog, The language is understandable, C# is the subject.
04:46:57 <Arafangion> Svrog, But why can't I just use a text editor?
04:46:59 <Arafangion> ANyway.
04:47:27 <Svrog> they have no way of knowing which ide or editor you used though :)
04:47:46 <Arafangion> Svrog, Actually they do.
04:47:50 <Svrog> oh?
04:47:55 <Arafangion> Svrog, VS.NET does alot of code generation for you.
04:48:02 <Svrog> ah
04:48:11 <Arafangion> Svrog, Which, unfortunately seems neccessary for gui code.
04:48:31 <Arafangion> Svrog, Or, specifically, neccessary for System.Windows.Forms gui code.
04:50:33 <Svrog> fair enough
04:50:59 <Arafangion> Svrog, I'm just amazed with the weight Microsoft is throwing around about xml and stuff, that they didn't describe the gui in xml.
04:51:00 <Svrog> i hate ides that do automatic code generation with passion
04:51:08 <Arafangion> Svrog, Me too.
04:51:19 <Arafangion> Svrog, Although automatic getters/setters are nice sometimes.
04:51:33 <Arafangion> Svrog, Except vs.net doesn't do that either, afaik.
04:51:38 <Svrog> that usually points to a deficiency in the language
04:51:48 <Arafangion> In the case of Java, yes.
04:52:11 <Arafangion> ALthough, perhaps it's the price for a particular aspect of simplification.
04:52:46 <Svrog> i dont know.. most of the really simple and elegant languages dont have that problem
04:53:04 <Arafangion> The simplicity of Python is masked by it's syntatic sugar.
04:53:05 <Svrog> but anyway... not gonna argue
04:53:20 <Arafangion> It's simplicity, funilly, is *because* of it's syntatic sugar, imho.
04:54:04 <Svrog> scheme has hardly any syntactic sugar and it's really simple and doesn't have such deficiencies for example
04:54:49 <Svrog> i havent played with python but ive heard people describing it as lisp or scheme with more syntax
04:55:17 <Svrog> haskell syntax is pretty simple too
04:55:20 <Arafangion> I have never tried scheme.
04:55:37 <Svrog> scheme is a very cool language
04:55:37 <Arafangion> Python is very simple and quick for people with a history in imperative languages.
04:56:02 <Arafangion> For people to learn Haskell, they have to actually learn a *totally* different syntax, but I suppose that argument is moot.
04:56:24 <Arafangion> It's a matter of English is my native tongue, and currently My native programming tongue is Python.
04:56:39 <Svrog> its not the syntax thats the problem - its the type system - for most people new to functional languages haskell's type system is pretty hard to grasp
04:56:57 <Arafangion> How the heck is Haskell's type system hard to grasp?
04:57:32 <Svrog> monads :P
04:57:34 <bourbaki> moin
04:57:40 <Svrog> hi
04:58:16 <tuomov> it actually complains when you're making a mistake!
04:58:24 <Svrog> yup :)
04:58:28 <Svrog> that oo
04:58:30 <Svrog> too*
04:58:47 <Arafangion> Svrog, imho, the way monads are presented are the problem, but I have to learn haskell completely before I can present a better way of presenting it, imho.
04:59:15 <Svrog> i dont know if there is a better way of presenting it... it's a simple concept but not easy to explain
04:59:38 <Arafangion> It's not easy to explain because people assume that it's completely different to anything else they know.
04:59:47 <Arafangion> When, infact, there are remarkable similarities.
05:00:44 <xerox> hellish: did you resolve it?
05:00:50 <Svrog> similarities in that through monads you can do the stuff that otherwise you wouldn't be able to in haskell - like changing state, side-effects, etc... but monads are still very different to what most people are used to
05:01:13 <tuomov> it might be good to teach monadic IO through Maybe and List..
05:01:30 <Svrog> tuomov: i agree
05:01:40 <Svrog> and some of the tutorials do that
05:01:53 <hellish> xerox, working on it at the moment
05:01:58 <Svrog> theres that famous one that i always forget the name of hehe
05:03:15 <tuomov> yaht?
05:03:22 <tuomov> that seems the most famour here after gentle
05:03:28 <tuomov> of which I've only read the latter
05:04:39 <Svrog> i cant remember - gonna have to look them up - but i know there is one that explains how maybe works and how state transformers work and similar things - thats the one that helped me the most
05:04:55 <Svrog> that and parsec
05:05:06 <Svrog> i found parsec really useful for learning about monads
05:05:48 <Svrog> parsec is great :)
05:07:11 <Svrog> anyway im off
05:07:14 <Svrog> cya people :)
05:25:27 <xerox> A nice way to "lookup" a (Num a) => [(a,b)] list, given the b ?
05:25:54 <Itkovian> xerox: the usual way?
05:26:03 <xerox> Itkovian: prabably
05:26:11 <xerox> *o
05:27:33 <Itkovian> xerox: Data.List.lookup 3 $ map (\(x,y) -> (y,x)) [(2,3),(1,4),(6,3)]
05:27:34 <Itkovian> ?
05:31:25 <xerox> Thank you.
05:37:19 <Itkovian> @seen kosmikus
05:37:20 <lambdabot> kosmikus is in #haskell and #darcs.
05:37:26 <nlv11757_> that would be 'map swap' itkovian
05:37:37 <Itkovian> yeah, well I wasn';t certain swap existed ;-)
05:37:37 <nlv11757_> :)
05:37:42 <nlv11757_> it does
05:37:47 <Itkovian> @type swap
05:37:48 <lambdabot> bzzt
05:39:00 <Itkovian> this morning I was looking for 'member' while I should hev been looking 'elem'
05:39:11 <Itkovian> kinda embarrassing in front of 30 people
05:39:27 <nlv11757_> :D
05:39:39 <nlv11757_> darn i could have sworn i used swap 2 days ago
05:39:46 <nlv11757_> or maybe i defined it myself :P
05:40:38 <Itkovian> heh
05:41:10 <nlv11757_> uncurry (flip (,)) look funkier anyway
05:41:12 <nlv11757_> :P
05:41:26 <nlv11757_> @eval uncurry (flip (,)) $ (1,2)
05:41:26 <lambdabot> (line 1, column 16):
05:41:26 <lambdabot> unexpected ","
05:41:26 <lambdabot> expecting simple term
05:42:02 <nlv11757_> @eval uncurry (flip (,)) (1,2)
05:42:03 <lambdabot> (line 1, column 16):
05:42:03 <lambdabot> unexpected ","
05:42:03 <lambdabot> expecting simple term
05:42:09 <nlv11757_> what lambabots issue
05:42:23 <tuomov> it's not a haskell interpreter iirc
05:42:42 <nlv11757_> what a shame
05:43:08 <nlv11757_> @eval 1 + 1
05:43:08 <lambdabot> 2
05:43:15 <nlv11757_> see it is :)
05:43:32 <nlv11757_> @eval (,) 1 2
05:43:33 <lambdabot> (line 1, column 2):
05:43:33 <lambdabot> unexpected ","
05:43:33 <lambdabot> expecting simple term
05:43:54 <nlv11757_> @type (,)
05:43:56 <lambdabot> (,) :: forall b a. a -> b -> (a, b)
05:44:02 <nlv11757_> hmm
05:44:08 <earthy> ah, but @type and @eval are unrelated
05:44:23 <nlv11757_> it fooled me
05:45:39 <Itkovian> nlv11757_: you should just make it simpler: 'expecting simple term'
05:47:05 <nlv11757_> (,) 1 2 is not simple enough?
05:47:21 <nlv11757_> @eval ((,) 1) 2
05:47:22 <lambdabot> (line 1, column 3):
05:47:22 <lambdabot> unexpected ","
05:47:22 <lambdabot> expecting simple term
05:47:39 <nlv11757_> maybe it just doesnt support using operators as functions
05:47:42 <nlv11757_> (+) 1 2
05:47:47 <nlv11757_> @eval (+) 1 2
05:47:48 <lambdabot> (line 1, column 2):
05:47:48 <lambdabot> unexpected "+"
05:47:48 <lambdabot> expecting simple term
05:47:52 <nlv11757_> aha
05:48:09 <nlv11757_> @eval 1 , 2
05:48:10 <lambdabot> (line 1, column 3):
05:48:10 <lambdabot> unexpected ","
05:48:10 <lambdabot> expecting operator, simple term or end of input
05:48:17 <nlv11757_> ok i give up
05:54:43 <Itkovian> lol
05:56:23 <Lemmih> It would be neat if someone rewamped lambdabot to use hs-plugins.
05:58:54 <kosmikus> Itkovian: ?
06:01:45 <Itkovian> yeah ...
06:01:56 <Itkovian> how 'unstable' is ghc-6.4 under x86 gentoo atm?
06:02:04 <Itkovian> before I waste cycles emerging it
06:05:51 <Lemmih> It's masked because none of other packages will work with it.
06:06:07 <Itkovian> ah ok.
06:06:10 <Itkovian> better wai a while then
06:06:19 <Itkovian> thx
06:06:28 <Lemmih> Or better yet, cabalize the packages (:
06:13:02 <Oeje1> What kind of operator is comma?  >3 , 4 and >3 `,` 4 gives error, while >(,) 3 4 and >(3,4) gives (3,4).
06:14:05 <kosmikus> Itkovian: yes, ghc-6.4 itself should build fine ...
06:14:19 <kosmikus> Oeje1: it's the tuple constructor
06:14:54 <kosmikus> (,) 3 4 is the prefix notation for (3,4)
06:15:00 <kosmikus> (,,) works the same way
06:15:17 <Oeje1> Ah, so it's a data constructor.
06:15:35 <kosmikus> it's also a type constructor
06:15:43 <kosmikus> (,) :: a -> b -> (,) a b
06:16:11 <Oeje1> kosmikus: Thanks.
06:16:44 <Lemmih> (,) :: (->) a ((->) b ((,) a b))
06:16:54 <kosmikus> even that
06:17:41 <Oeje1> Lemmih: Don't make my head explode, please.
06:25:16 <xerox> f el ls = lookup el (map (uncurry (flip (,))) ls)
06:25:40 <xerox> I can't point-free it, sorry.
06:26:23 <kosmikus> Itkovian: actually, one possibility is to quickpkg ghc-6.2.2 before emerging ghc-6.4, then quickpkg ghc-6.4 as well; after that, you can easily switch between the two
06:26:59 <Oeje1> xerox: TheHunter's bot might help you wih point-freeing it.
06:26:59 <kosmikus> Itkovian: or, emerge ghc-6.5 using the ghc-cvs ebuild, which installs in parallel to ghc-6.2.2
06:30:21 <Lemmih> @type flip lookup . map (uncurry (flip (,)))
06:30:22 <lambdabot> flip lookup . map (uncurry (flip (,))) :: forall a b.
06:30:22 <lambdabot> 					  (Eq b) =>
06:30:22 <lambdabot> 					  [(a, b)] -> b -> Maybe a
06:30:27 <Lemmih> Almost (:
06:30:51 <xerox> flip lookup, smart.
06:31:12 <Lemmih> @type flip $ flip lookup . map (uncurry (flip (,)))
06:31:13 <lambdabot> flip $ flip lookup . map (uncurry (flip (,))) :: forall a b.
06:31:13 <lambdabot> 						 (Eq b) =>
06:31:13 <lambdabot> 						 b -> [(a, b)] -> Maybe a
06:31:19 <Lemmih> Hurrah.
06:31:42 * Igloo looks around for GHC powerpc folk
06:31:52 <earthy> even though I know how to do that it still scares me every time I see it
06:31:54 <xerox> I was going with that "template": (f .).g  But it's for another kind of pointfreeing.
06:32:49 <xerox> This: (a -> b) -> a -> b
06:34:05 <hellish> Igloo, I'm a ghc powerpc folk.
06:34:26 <hellish> Igloo, at least in the sense that I'm using it on a ppc machine
06:35:43 <Igloo> Oh, I think I've just seen the problem actually. When I enable library splitting it tries to compile stuff with -split-objs using the old ghc that doesn't support it
06:36:37 <hellish> Igloo, I just resorted to downloading the ppc tarball.
06:38:15 <Lemmih> Bah. Lost yet another software battle. /-:
06:40:26 * Lemmih adds Apache2 to the list of software which doesn't Just Work(TM) the way he want.
06:41:12 <bourbaki> does anyone of the mac users in here know how to get the text to speech interface working/
06:47:30 <xerox> hellish: did you work it out?
06:56:54 <hellish> xerox, yup. I'm onto the next bit now
06:59:15 <bourbaki>  does anyone of you have experiences with text to speech programs?
06:59:21 <bourbaki> er sry wrong window
07:02:34 <mkirank> im trying to install ghc at home on my linux machine .. this is the files that i have to download right http://www.haskell.org/fedora/haskell/1/i386/RPMS.stable/ghc64-6.4-2.i386.rpm  and http://www.haskell.org/fedora/haskell/1/i386/RPMS.stable/ghc-6.4-2.i386.rpm
07:03:11 <hellish> mkirank, that's right if you're running fedora.
07:03:28 <hellish> You only need the second one if you don't have a 64 bit CPU.
07:03:46 <mkirank> yes im running fedora core release 1
07:04:15 <xerox> Hm, how to define an :: a -> a -> Ordering function?
07:04:23 <xerox> (to use with sortBy, for instance)
07:04:38 <mkirank> i tried the first one .. i got the error ghc64 is needed by ghc-6.4-2
07:07:10 <mkirank> oops i mean i tried this ghc-6.4-2.i386.rpm
07:07:21 <sylvan> xerox: Just compare two values (with guards, for example) and return EQ, GT or LT if they are equal, if the first is greater than the second or if the first is less than the second
07:08:31 <xerox> sylvan: oh, that was it. Thanks.
07:09:28 <sylvan> no problem
07:11:28 <Igloo> mkirank: I'd guess ghc is a dummy package just depending on the package providing the latest version
07:11:38 <xerox> hellish: I come up with a solition, but is bugged, wanna see? (And maybe help me fix it?)
07:13:01 <xerox> Hmm, I try hard before.
07:13:47 <mkirank> igloo: hellish mentioned the second is needed if you dont have a 64 bit cpu
07:14:15 <Igloo> Oh, sorry, missed that
07:14:43 <hellish> I was thinking that the first is for opteron/xeon and second is for traditional x86. Just guessing though, as I don't run fedora
07:15:10 <Igloo> I'm unconvinced though, given there's a ghc622-6.2.2-1.i386.rpm in that directory
07:17:07 * hellish shrugs
07:26:19 <nlv11757_> does anyone know the latexcode for semantic brackets from the top of their head, or should i just do [\![ ?
07:27:18 <nlv11757_> mkirank, just do 'yum install ghc64'
07:28:20 <nlv11757_> its short for ghc-6.4, just like ghc622 was for ghc-6.2.2
07:34:16 <mkirank> nv11757 : i did that .. it seems to be getting it from the server  :-)
07:34:45 <nlv11757_> worked for me in any case
07:35:02 <nlv11757_> i am running core 3, but should work for you too :)
07:35:17 <mkirank> thanks
07:35:37 <nlv11757_> np
07:37:04 <TheHunter> thbot: @pointless f el ls = lookup el (map (uncurry (flip (,))) ls)
07:37:05 <thbot> f = (. map (uncurry (flip (,)))) . lookup
07:41:26 <xerox> TheHunter: do you think it's the best way to do that?
07:43:26 <nlv11757_> ah the swapped lookup
07:43:55 <nlv11757_> i personally think there should be a swap, but uncurry (flip (,)) is a lot sexier
07:45:11 <wilx> So, here is the problem: I have a function that transforms one list to another. The best way I know is to write tail recursive function. The transformation depens on its own history so I have to have some kind of state. Now passing it as one of the parameters would work but it doesn't seem to be as nice as using Control.Monad.State. The problem is that one cannot easily write "return val:(foo xs)" becaise foo uses the State monad.
07:45:32 <duncan_> kosmikus: alex-2.01 installs to /usr/alex-2.01 rather than /usr/lib/alex-2.01, do you want another bugzilla bug?
07:45:41 <musasabi> wilx: what about the map-fold function?
07:46:21 <wilx> The number of elements of result can be lower than the number of elements of input.
07:47:01 <musasabi> wilx: just a fold?
07:47:03 <skew> quit
07:47:06 <skew> .quit
07:47:11 <bd_> skew: /quit
07:47:14 <wilx> :)
07:47:58 <wilx> Hmm, how would I use fold? Fold folds all elements into one resulting value.
07:48:10 <TheHunter> xerox, what's the original function?
07:48:32 <kosmikus> duncan_: on the phone, ttys
07:48:55 <TheHunter> xerox, actually, what thbot did there looks pretty short.
07:49:11 <musasabi> wilx: the value can be a pair...
07:49:28 <musasabi> wilx: e.g. (state,[result])
07:49:44 <wilx> Ah...hmm...*ponders*
07:54:30 <nlv11757_> are you pondering what im pondering
07:57:21 <kosmikus> duncan_: re
07:57:34 <duncan_> kosmikus: ?
07:59:58 <kosmikus> I can close the /opt bug then, right?
08:00:08 <duncan_> yes
08:00:54 <duncan_> kosmikus: I've not heard back from the recruiters yet, easter holidays I guess
08:01:23 <xerox> How can I apply a pair of arguments to a list of functions?
08:01:30 <xerox> ($) maybe
08:02:34 <nlv11757_> pair of arguments is (a,b) ?
08:02:48 <nlv11757_> for functions; a -> b -> c ?
08:02:53 <nlv11757_> or (a,b) -> c
08:03:04 <xerox> Found it, ($) works.
08:03:47 <xerox> Yay, hellish I think I got it.
08:06:38 <xerox> Hmpf, damn Maybe.
08:09:29 <xerox> I just don't have the circularity now, a `mod` would do it I think.
08:10:11 <hellish> xerox, mine uses mod. Having fun?
08:11:11 <xerox> Yep.
08:11:22 <xerox> Let me paste it, I think it's working.
08:11:28 <xerox> @wiki HaskellIrcPastePage
08:11:29 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:14:19 <hellish> xerox, I don't see your code there
08:14:46 <xerox> I know, it has a problem, I'll paste anyway.
08:15:00 <xerox> Refresh now
08:18:10 <hellish> Wow, that's a lot more complicated looking than mine...
08:18:36 <xerox> :(
08:19:01 <xerox> I need to re-think the whole thing. Hmpf.
08:19:58 <xerox> Moving 'a' works btw ^__^
08:21:33 <xerox> Can I see your solution?
08:23:39 <autrijus> dons: just a heads-up -- I found that NameLoader Just Works for my needs
08:23:43 <autrijus> and is BSD license to boot
08:23:48 <autrijus> so I think I'll switch to it.
08:24:25 <autrijus> still, thanks a lot for your work :)
08:27:04 <hellish> xerox, sure. It's in the pastebin now.
08:39:06 <Cale> I added my own implementation
08:42:31 <Cale> hellish: the trick is not to use recursion explicitly, as most of the recursion has been written for you in the library.
08:43:36 <Cale> there are of course times when you'll need/want it, but often the code without explicit recursion is cleaner
08:44:34 <xerox> So there is a findIndex ..
08:45:35 <hellish> Cale, you won.
08:45:42 * xerox cries
08:49:16 <Oeje1> xerox: Don't cry.
08:49:26 * Oeje1 gives xerox a tudekiks.
08:49:42 <Lemmih> heh (:
08:51:29 <xerox> Cale: where is fromJust?
08:51:37 <Cale> in Maybe
08:52:08 <Cale> but you could also write: where Just i = findIndex (== x) xs
08:52:30 <xerox> Hm, why your move is Int -> Int -> [Int] -> [Int] ?
08:52:42 <Cale> hm?
08:53:01 <Cale> because it relies on the list processing functions and indices
08:53:17 <Oeje1> I wish, I had â¬ 200 to pay for PAT2005 Summer School in Copenhagen.
08:54:44 <Lemmih> URL?
08:55:19 <xerox> Okay, at least I learnt something new.
08:55:25 <xerox> I wish I didn't spend so much time, btw :\
08:55:58 <Oeje1> Lemmih: http://www.diku.dk/~neil/PAT2005/
08:56:22 <Oeje1> Cool!  Peter Sestoft posted on c.l.functional!  :-)
08:58:24 <xerox> Adding a move :: (Eq a) => a -> Int -> [a] -> [a] worked, Cale.
08:59:25 <Cale> oh, actually, that's the inferred type
08:59:38 <Cale> (I hadn't checked)
09:00:07 <xerox> I want some haskell exercises. With nice solutions, like Cale's ones :)
09:00:37 <_mordechai> is there a sandy beach in kobenhavn?
09:00:47 <_mordechai> where people sunbathe in bikinis?
09:00:49 <_mordechai> lol
09:01:08 <_mordechai> i tought the baltic sea has a temperature of like 5C
09:01:35 <xerox> Cale: how would you add error handling to that funcion?
09:01:37 <kosmikus> when? now?
09:02:42 <Oeje1> _mordechai: Shure there are sandy beaches.
09:03:01 <_mordechai> cool =)
09:03:34 <Oeje1> _mordechai: And a one week summer.  :-P
09:03:52 <_mordechai> hm =)
09:07:33 <Cale> xerox: I have to run, but it's not so hard :) Use a case statement
09:07:35 <Lemmih> We got ~200 days with precipitation a year. But sunny days are great (:
09:08:23 <Cale> er, expression, of course :)
09:18:40 <xerox> Added.
09:19:03 <halcyon10> is there already a library-function that relates to last as tail relates to head? or in other words, which returns all but the last elements of a list. i know how to write such a function myself, i just wanted to know if there is already such a function i don't know about
09:19:33 <xerox> Cale: if you're here check the wikipage.
09:19:57 <Lemmih> @type init
09:19:58 <lambdabot> init :: forall a. [a] -> [a]
09:20:20 <Lemmih> Prelude> init [1..10]
09:20:20 <Lemmih> [1,2,3,4,5,6,7,8,9]
09:20:35 <halcyon10> Lemmih: thanks very much!
09:23:29 <Lemmih> Be aware of the O(n) complexity of that function.
09:24:43 <xerox> Doesn't Haskell have double-linked-lists? Wouldn't be possible to do it O(1)?
09:28:50 <halcyon10> Lemmih: i kind of dislike the fact that lists are only easily accessible one-way. so a kind of FILO/LIFO structure is nicely done with haskell lists. but FIFO/LILO isn't as nice to accomplish
09:29:28 <kosmikus> there are nice queue implementations in Okasaki's book
09:29:46 <jyasskin> And in ghc 6.4
09:30:13 <halcyon10> how do they do it there?
09:31:21 <jyasskin> It's in Data.Queue, and comes from "Simple and efficient purely functional queues and deques" by Chris Okasaki
09:31:43 <kosmikus> the basic idea is, iirc, to keep two lists, one in normal order representing the beginning, one in reversed order to represent the end of the queue
09:32:04 <jyasskin> It's basically the standard two-list queue, which takes amortized O(1) time, but they actually amortize the reverse to get a good worst case.
09:32:10 <kosmikus> the tricky part is to perform rearrangements between the two lists at the right points in time to get good amortized behaviour
09:32:28 <halcyon10> ok, so they sacrifice memory for performance?
09:32:38 <jyasskin> not much memory at all
09:33:02 <halcyon10> i thought double memory, or do they store two halves?
09:33:04 <jyasskin> possibly less than a doubly linked list would waste
09:33:10 <kosmikus> only two halves
09:33:11 <jyasskin> they store the two halves
09:33:14 <halcyon10> ah
09:33:31 <kosmikus> but even if they'd store the whole list, it wouldn't cost double memory because of sharing between the elements
09:33:50 <halcyon10> sharing?
09:33:56 <musasabi> Okasaki has very good descriptions of the various balancing acts you can do to get different time bounds for those queues/
09:34:35 <kosmikus> halcyon10: well if I say \x -> (x,x), I do not actually duplicate the element in memory
09:35:04 <kosmikus> the same element can safely be used twice, because all things are immutable anyway
09:35:20 <halcyon10> kosmikus: ah, i see. so it's a kind of compiler-optimization?
09:35:51 <metaperl_> kosmikus, congratulations on being on the #1 ICFP team for 2004
09:36:01 <kosmikus> I think it's actually part of the language specification that lambda- and let-bound variables have to be shared
09:36:04 <metaperl_> I d/l'ed the code but it was way above my head :)
09:36:14 <kosmikus> metaperl_: thanks
09:36:15 <musasabi> halcyon10: lets say x is an object which take 10kb of memory. (x,x) creates a new tuple which holds two references to x.
09:37:18 <halcyon10> ah, i see
09:38:04 <halcyon10> thank you all for pointing me to the queue-idea/implementation
09:38:16 <halcyon10> btw: what's ICFP ?
09:38:29 <metaperl_> halcyon10, int'l conference on functional programming
09:38:30 <musasabi> halcyon10: because data is immutable one does not need to do deepcopies.
09:38:46 <metaperl_> they have a programming contest every year
09:38:53 <halcyon10> ah, cool
09:39:07 <metaperl_> haskell took first and second and fourth place
09:39:22 <metaperl_> who was on the 2nd and 4th palce teams?
09:39:29 <metaperl_> I dont think they had links to those teams
09:40:18 <halcyon10> musasabi: ah, so it's a direct consequence of being functional that one can do this, because in an imperative language data-elements could change in between. that's nice from a compiler-coder point of view
09:40:32 <musasabi> yes :-)
09:41:05 <musasabi> And no more wondering "can I just return a reference or should I copy the object - and if so shallow or deep?"
09:41:06 <halcyon10> so haskell isn't only fun to program in, but also to write compilers for =)
09:42:25 <musasabi> Haskell is fun to program in, and to write compilers in.
09:42:42 <musasabi> Writing a good optimizing compiler for Haskell is quite hard.
09:43:59 <kosmikus> http://www.sawicki.us/icfp/2004/ is the second place entry
09:44:13 <kosmikus> I don't think hasKilled has a homepage
09:44:36 <halcyon10> kosmikus: ah, i just found http://icfpc.plt-scheme.org/
09:45:38 <kosmikus> yes, that's the upcoming contest
09:46:19 <metaperl_> halcyon10, but that is not the 2004 programming contest
09:46:22 <kosmikus> sadly, it looks unlikely that there'll be a Dunkosmiloolump revival
09:47:01 <metaperl_> halcyon10: http://www.cis.upenn.edu/proj/plclub/contest/index.php
09:53:42 <halcyon10> i just saw that non-functional languages were allowed, too. nice thing not to exclude imperative languages
09:55:47 <halcyon10> it would be a bit too easy to promote functional languages by disallowing any other kind of language, wouldn't it? :)
09:58:13 <kosmikus> it would also be really hard to define which languages are functional enough and which ones aren't
09:59:32 <Oeje1> kosmikus: Well, just go ahead and define them; e.g. ICFP Haskell/OCaml/Scheme contest.
10:00:38 <Oeje1> The latest problems have favored speed of development over speed of execution.  Do you think that trend will continue?
10:01:19 <kosmikus> nah, I wouldn't like that, nor would the ICFP organizers
10:01:45 <kosmikus> it's fascinating to see whether a new language is mature enough to rank high in the contest, for example
10:02:14 <kosmikus> it's also good to have lots of participants, so I definitely like to include imperative languages
10:02:53 <kosmikus> speed of development has always been important, because of the 3-day deadline
10:03:24 <kosmikus> but the 2003 problem also favored speed of execution, I guess
10:04:08 <Oeje1> I both like and dislike when the submission is in a language given by the organizers, for example as Ant Assembler from 2004.
10:05:03 <Oeje1> Much easier for them to evaluate though.
10:08:02 <kosmikus> I liked that; if there's a clearly specified format, you don't have to worry about making the program executable for the judges
10:08:28 <kosmikus> which means you can use all software you have available, and there's a large class of "formal" errors that won't invalidate your submission
10:08:33 <duncan_> Oeje1: but the people who submitted  Ant Assembler did very badly since you couldn't write any large program easily in that language
10:08:57 <Oeje1> duncan_: I know. ;-)
10:09:21 <duncan_> so I don't that was a problem
10:10:20 <duncan_> interestingly this year they are also emphasising maintainability / changeability since you get 3days for the first version and then they change the spec and you get a day or so to change your program
10:11:01 <duncan_> we'll see if the staticly typed languages or the dynamically typed ones do better at that...
10:11:08 <Oeje1> duncan_: And a week in between to work on it.
10:11:38 <kosmikus> that's what I really worry about
10:11:54 <Oeje1> How can it not be an advantage for those who have time during the week.
10:12:02 <duncan_> true
10:12:14 <Oeje1> They shurely must have thought about that.
10:12:24 <kosmikus> they must have
10:12:41 <kosmikus> otherwise they could have made it 2+1 day on one weekend
10:12:53 <kosmikus> but still, I can't see how it will work
10:15:16 <Oeje1> "This year's competition rewards programmers who can plan ahead."  Do they talk about the two weeks in between, when they say "ahead"?
10:17:08 <Oeje1> I expect the change to be huge but in the same domain.  Think domain specific language.
10:17:54 <kosmikus> I really don't know
10:18:10 <kosmikus> should be something unexpected
10:18:25 <kosmikus> the change, I mean
10:19:38 <metaperl_> Oeje1, "shurely" is properly spelled "surely"
10:20:26 <TheHunter> what? instance Foo a requires undecidable instances?
10:20:32 <_mordechai> spelled is properly spelt spelt
10:20:37 <_mordechai> :P~~~
10:21:08 <_mordechai> @type Maybe
10:21:09 <lambdabot> bzzt
10:21:12 <Oeje1> metaperl_: Shure. :-P
10:21:17 <_mordechai> :D
10:21:40 <metaperl_> Shure is a company that makes phonograph needles
10:22:03 <halcyon10> and microphones ;)
10:22:13 <Oeje1> metaperl_: But thanks!  It must be hard for all you native English people.  :-/
10:22:26 <_mordechai> and microphones
10:22:34 <_mordechai> http://images.google.com/images?hl=en&lr=&ie=ISO-8859-1&q=shure&btnG=Search
10:22:37 <metaperl_> heh
10:22:40 <_mordechai> halcyon10, lol
10:22:59 <earthy> good, expensive microphones even
10:23:12 <halcyon10> :)
10:24:06 <halcyon10> who will forget the famous SM58 for example...
10:28:39 <kosmikus> TheHunter: without a context?
10:33:05 <TheHunter> class Foo a
10:33:05 <TheHunter> instance Foo a
10:35:42 <TheHunter> grrr, quickCheck definitely hides to many internals.
10:47:42 <TheHunter> is it generally safe to unsafeCoerce# newtypes?
10:51:09 <Igloo> I'd have thought any typeclass dictionaries at least might be wrong
10:52:24 <Igloo> Why not just export the constructor? You could call it UnsafeFoo rather than Foo
10:52:41 <Igloo> Or export a function unsafeDeFoo
10:53:32 <TNKS> hello everybody.  Is there a Haskell solution for fast matrx operations?
10:53:45 <TNKS> I'd certainly hate to code something like that from scratch.
10:53:49 <desrt> foreign c :)
10:54:05 <TNKS> shucks.  Is that the best option?
10:54:15 <desrt> it's probably the fastest.
10:54:20 <TNKS> I don't know yet how to do foriegn function calls in Haskell.
10:54:28 <TNKS> Is there something that's "as fast as Matlab"
10:54:50 <TheHunter> ok, thanks. (But I can't change the implementation of libraries. Then again, i might just yell at libraries@).
10:55:21 <TheHunter> i'm not even sure yet if my problem comes from inaccessible newtypes...
10:55:26 <Igloo> Which library?
10:55:38 <TheHunter> QuickCheck
10:56:01 <desrt> TNKS; that's not a very high bar....
10:56:10 <desrt> TNKS; you could probably hack something together fairly rapidly
10:56:20 <desrt> what are you trying to do anyway?  inversion, solving systems, etc?
10:57:58 <TheHunter> yah, that issue (providing a generic (==)) is much more complicated then I had anticipated anyway.
10:59:15 <kosmikus> what are you trying to do exactly?
11:00:39 <halcyon10> is there a way to combine guards and 'let' in a similar way as i tried here? : http://pastebin.ca/8066
11:01:30 <TheHunter> kosmikus, me?
11:01:36 <kosmikus> yes, you
11:01:40 <kosmikus> :)
11:01:47 <TheHunter> i'm having a list of Properties and want the Property that all of them are satisfied.
11:03:36 <kosmikus> halcyon10: no, you must either use if/then/else or "case () of _ | ..."
11:03:53 <kosmikus> TheHunter: I don't see yet what this has to do with newtypes, undecidable instances, and a generic (==)
11:04:56 <TheHunter> ok, i'll start again:
11:05:10 <halcyon10> kosmikus: ok, thank you
11:05:34 <TheHunter> i want to be able to define quickcheck laws about monads and similarly complicated objects.
11:05:40 <TNKS> desrt, I know, I just don't want to have to code up BLAS.  I'd rather just have a ready-to-go package.
11:05:44 <TheHunter> which might or might not be functions.
11:06:15 <desrt> TNKS; not that i know of
11:06:31 <TheHunter> no I can't use (==) anywhere, so I thought I'd define a class class Eq' a where (===) :: a -> a -> Property
11:07:49 <kosmikus> ah
11:08:08 <TheHunter> the undecidable instances thing doesn't really have anything to do with that, but i found it so odd that i had to tell the channel.
11:08:28 <kosmikus> and you want (===) to be generic?
11:08:58 <TheHunter> and it would certainly make sense to define such an instance, if you just wanna make your code type check.
11:09:19 <TheHunter> sorry, i guess "generic" wasn't the right term ;)
11:09:44 <TheHunter> i just wanted to say that it includes function types.
11:10:35 <kosmikus> and that's difficult to do for (===)?
11:11:26 <TheHunter> at least more difficult than I thought first.
11:14:47 <_JusSx__> does ghc come with FFI?
11:14:51 <_JusSx__> does ghc come with FFI? tool?
11:15:15 <wilx> Hm, doesn't it have built-in FFI facilities?
11:15:48 <_JusSx__> ok found it
11:15:52 <_JusSx__> thanx
11:16:04 <_JusSx__> too many joint
11:26:21 <TheHunter> ok, it's quite simple actually, but I need implementation details (Property and Result) of QuickCheck.
11:35:52 <Oeje1> _JusSx__: I think the next The Monad.Reader will have something about the FFI.
11:41:44 <kosmikus> @seen JaffaCake
11:41:45 <lambdabot> I saw JaffaCake leaving #haskell 6 hours 10 minutes 15 seconds ago.
11:47:07 <_JusSx__> Oeje1: how can i bind C source code?
11:47:37 <_JusSx__> for example: i will write a C function such as int foo(int a, int b) { return a+b }
11:47:51 <_JusSx__> then how can i use that function in my haskell code?
11:50:25 <Igloo> _JusSx__: http://www.cse.unsw.edu.au/~chak/haskell/ffi/
11:51:20 <Igloo> But in short, something like foreign import "foo.h foo" foo :: CInt -> CInt -> IO CInt
11:53:26 <_JusSx__> thanx
12:08:56 <pesco> @seen Lemmih
12:08:56 <lambdabot> Lemmih is in #haskell.
12:09:02 <pesco> :)
12:09:42 * pesco .o(Then why didn't tab completion work just now...)
12:10:20 <pesco> Lemmih: About those module dependency / packaging / versioning thing...
12:11:46 <pesco> I'm not convinced interface version information in the Haskell code wouldn't be beneficial.
12:12:18 <pesco> (Hm. Actually nobody claimed it wouldn't be, either.)
12:12:43 <pesco> I guess I'm just looking for some real-time opinion before making a lengthy post to the mailing list.
12:13:31 <musasabi> pesco: about the URL thing?
12:13:52 <pesco> musasabi: A side-issue of it.
12:14:49 <pesco> musasabi: I don't think I want URL imports. But the original post by Alexander prompted me to bring interface versioning up, becaus I'd thought about that before.
12:14:57 <musasabi> pesco: versioning is imho best left at the package level.
12:15:15 <Si\> is it possible to splice imports with TH?
12:15:24 <musasabi> pesco: because most modules depend on the other modules being the same version inside the module.
12:15:29 <musasabi> Si\: I don't think so.
12:15:46 <pesco> musasabi: Inside the package you mean.
12:15:52 <Si\> I'll use sed then
12:16:18 <pesco> musasabi: Note that I am not proposing to abandon any other form of versioning.
12:16:23 <pesco> Cabal specifically.
12:16:27 <musasabi> pesco: yes, inside the package.
12:16:39 <musasabi> pesco: what would that give as extra?
12:17:22 <pesco> musasabi: I would like to be free to distribute my modules stand-alone, basically. Without packaging.
12:17:42 <musasabi> pesco: but that doesn't work for anything nontrivial.
12:17:53 <pesco> That's not true.
12:18:09 <pesco> I think.
12:18:51 <musasabi> pesco: complex things tend to 1) have multiple modules with complex interdependencies, 2) maybe need configuring 3) external tools hsc2hs, alex, happy, ...
12:18:56 <musasabi> or even C sources.
12:19:24 <pesco> musasabi: That is all true.
12:19:43 <pesco> However, I believe nothing of it means that per-module interface versioning is a bad idea.
12:20:42 <Darius> pesco: I think the issue, though, is whether it's a good (enough) idea.
12:20:55 <pesco> Right.
12:21:05 <Darius> For example, what group would it benefit?
12:21:17 <musasabi> pesco: so we have a versioned module A, and B which imports A. Now C imports two versions of A. Both B and C are in the same app - what version of A does B use?
12:22:17 <pesco> musasabi: What did B's import statement say about the version of A it wanted? Nothing?
12:22:27 <musasabi> nothing.
12:23:06 <pesco> The latest version.
12:23:59 <musasabi> pesco: that would probably kill things if B and A communicate.
12:24:08 <musasabi> B and C.
12:25:50 <musasabi> pesco: I think a simpler idea is that if you want your modules to be backward compatible name them explicitely.
12:26:12 <musasabi> pesco: e.g. Foo.Bar-1-0
12:28:56 <pesco> musasabi: Thinking...
12:31:11 <pesco> So for code revisions, I'd probably not change the module name.
12:31:34 <pesco> My users would have to look up the number they want.
12:32:30 <musasabi> pesco: just do a simple modules named like Foo-1-0, Foo-1-1 and so on and make module Foo (module Foo-1-1) import Foo-1-1
12:32:58 <musasabi> pesco: and then you just make Foo import the new version when you add that.
12:33:40 <Darius> Yay, my SMTP server decided to work today.
12:33:50 <pesco> But that won't help at all once I break compatibility for someone. They'll have to go and revisit their code.
12:34:06 <pesco> Even worse, figuring out the last version that works.
12:34:13 <musasabi> pesco: how is that different from versioned modules?
12:34:43 <pesco> I was imagining the compiler seeing a blank import (no version info), using the latest version it finds, and emitting a warning.
12:34:48 <Darius> pesco: With versioned modules, either they have to constantly maintain the version until it breaks, or they have to add versioning information when it breaks.
12:35:05 <pesco> So I'd import, compile/load, set the number.
12:35:06 <musasabi> Which is exactly the same as with my scheme.
12:35:26 <musasabi> pesco: just like import Foo-theversionyouwant
12:36:05 <pesco> Kind of.
12:36:22 <musasabi> pesco: Is there anything the addition of versions would make easier?
12:37:30 <pesco> I think in the end, both ways would end up being the same, with one making the version number explicit, the other pretending there were no version numbers.
12:38:45 <musasabi> actually you can use both ways with both schemes. 1) import Foo [1.1] and import Foo-1-1 2) import Foo and import Foo.
12:39:43 <pesco> I don't understand.
12:40:35 <musasabi> Well there are three basic cases:
12:40:41 <Darius> pesco: Who would this most benefit?  It seems there are two potential target audiences, developers who stick to release versions and bleeding-edge developers who fetch from CVS/etc./snapshots.
12:41:07 <musasabi> 1) we want to import the latest version of a module - both schemes would use "import Foo"
12:41:17 <Darius> Each already seems to have a fairly well-defined "version" information, and neither seems particularly interested in fetching a single module.
12:41:34 <musasabi> 2) we want to import Foo version 1.0. "import Foo-1-0" and "import Foo [1.0]"
12:42:42 <musasabi> 3) we want to import Foo 1.0 and Foo 1.1 with different names: "import qualified Foo [1.0] as Old; import qualified Foo [1.1] as New" and "import qualified Foo-1-0 as Old; import qualified Foo-1-1 as New".
12:42:46 <pesco> Darius: The point is that the motivation for this lies in auto-fetching modules.
12:43:18 <musasabi> pesco: then you need a way to map version numbers to filenames.
12:43:39 <pesco> musasabi: Of course. That of all things should be trivial. Or not?
12:43:47 <musasabi> pesco: which is actually doing the "Foo [1.0]" -> "Foo-1-0".
12:44:20 <musasabi> pesco: so there would be little benefit, just yet another extension/
12:44:21 <Darius> When and why would you want to auto-fetch just a module?
12:46:50 <pesco> Darius: I for example have so far written around five Haskell modules which are all perfectly useful stand-alone.
12:47:06 <pesco> Of course I am my own motivation, no use denying. ;)
12:47:31 <pesco> I'd very much like to make them available to everyone.
12:47:43 <Darius> Package them.
12:47:49 <Darius> It should be very easy ;)
12:48:03 <kosmikus> pesco: yes, please, and submit ebuilds :)
12:50:13 <pesco> So I would make a package pesco-cmdline-1.0 which includes my Cmdline module and associated files (docs, test cases, etc.) and pesco-misc-1.0 which includes Pesco.UTF8, Pesco.Prelude, Pesco.Regex, Pesco.Algebra, and Pesco.Comm.
12:51:16 <Darius> Why not?  There are well known libraries (QuickCheck, Observe) that are little more than a module or two themselves.
12:52:36 <musasabi> pesco: I have a package with a single module too.
12:53:57 <kosmikus> I thought that it's the whole point of Cabal that you should be encouraged to do this
12:55:40 <pesco> I don't _want_ to make "packages" of single modules. Because they aren't. They're _modules_. Also suddenly I have to tell people the package and module name. In the packages I put these description files, which I don't want to fill out and the ever-same no-op setup script.
12:56:50 <musasabi> pesco: well when shipping something I need a license, contact information, documentation, README, ...
12:59:20 <Darius> pesco: Package says standalone.
13:02:35 <pesco> musasabi: I have to think about how to connect module and documentation. Of course a trivial answer presents itself.
13:03:01 <Igloo> Why can you give someone a documentationless module but not a documentationless package?
13:03:57 <Igloo> Incidentally, I think module names like Data.Mumble.Pesco are prefered to Pesco.Mumble, if you are going to distribute things
13:04:14 <pesco> Really?
13:04:58 <pesco> Regarding your question. My modules are typically literate programs, seperated from the reference documentation.
13:05:42 <pesco> So if only the module is fetched, the "manpages" are not.
13:06:12 <Igloo> I'm not sure I understand
13:06:16 <kosmikus> I'd really like to use this Mumble datatype
13:06:20 <kosmikus> where can I get it?
13:06:56 <pesco> Igloo: For concrete example. Pesco.Cmdline is a literate program containing detailed documentation about its implementation.
13:07:26 <pesco> Igloo: I have a set of manpages prepared to serve as reference documentation.
13:07:28 <Igloo> kosmikus: It seems pesco has written an implementation  :-)
13:08:13 <pesco> kosmikus: That thing is _so_ useful, I couldn't live without it. Wait till I distribute it.
13:08:34 <Igloo> OK, so why can't you add the manpages to the cabal package under the extra files option (which I'm sure must exist)?
13:08:55 <pesco> I could do that.
13:09:09 <kosmikus> pesco: so I've heard :)
13:11:22 <musasabi> pesco: please distribute that as a package.
13:25:10 <pesco> OK. You've filled my input buffer. Thanks, I'll be back for more discussion tomorrow. :)
13:26:01 * Darius starts constructing a program to overrun pesco's buffer and execute arbitrary code!
13:28:26 * esap constructs an empty stack of type "s (s a -> a)".
13:29:59 * esap corrects myself, it has type "(StackAPI s) => s (s a -> a)"
13:30:49 <wagle> esap: example implementation?
13:31:26 <esap> wagle: data Stack a where { Frame :: f (Stack a) -> Stack (f a) } ; make_stack = Frame id
13:32:09 <wagle> push, pop?
13:32:33 <Darius> fold?
13:33:07 <esap> push :: a -> Stack b -> Stack (a,b) ; push = curry Frame ; pop (Frame x) = x ; pop :: Stack (f b) -> f (Stack b)
13:33:21 <esap> hmm.. I don't have implementation of fold.
13:33:33 * wagle goes off to play with that
13:34:17 <esap> I have map_stack :: (forall a. f a -> g a) -> Stack (f a) -> Stack (g a) ; map_stack f (Frame x) = Frame (f x)
13:34:56 <esap> hmm.. maybe that should be called map_layer instead of map_stack.
13:39:35 <wagle> 13:35 < esap> I have 13:35 < esap> I have 13:35 < esap> I have 13:35 < esap> I have 13:35 < esap> I have 13:35 < esap> I have data Stack a where { Frame :: f (Stack a) -> Stack (f a) }
13:39:45 <wagle> data Stack a where { Frame :: f (Stack a) -> Stack (f a) }
13:39:58 <wagle> ARGh
13:40:03 <wagle> stupid control S
13:40:11 <wagle> data Stack a where { Frame :: f (Stack a) -> Stack (f a) }
13:40:19 <wagle> stack.hs:1: parse error on input `where'
13:40:23 <wagle> .. there
13:40:38 <esap> wagle: you need GHC 4 for GADTs.
13:40:40 <Darius> wagle: That uses GADTs
13:40:53 <wagle> i was afraid you were going to say that
13:41:08 <wagle> i'm trying to wait for fink or darwinports to do it
13:41:08 * esap means GHC 6.4
13:41:49 * esap uses a binary directly from GHC page.
13:43:31 <wagle> i was just too recently happy to get fink working again and finding that I could install hugs and ghc that way..  i dont have a /usr/local deinstaller
13:44:05 <wagle> i will probably lose patience in another week and hand install then
13:44:43 <musasabi> wagle: usually just install under a suitable prefix and symlink the binaries under your path.
13:46:04 <wagle> i installed a newer ghc and hugs from fink, and had to delete the old haskell cruft from /usr/local by hand and guesswork
13:46:22 <wagle> (fink stuff goes in /sw/...
13:46:24 <wagle> )
13:47:54 * esap just installs in-place under my home directory until Debian gets .debs for it.
13:47:58 <wagle> of course, if you guys keep going on about gadt stuff, my patience probably wont last even a week..  8)
13:48:58 <wagle> its more that i want to first (1) fix the /usr/local deinstall problem (2) install some other, more immediately important stuff
13:50:09 <wagle> gadt is categorized under "fun & games"..  8)
14:02:42 * stepcut reads about scheme macro expanding
14:02:47 <esap> Hmm.. Almost fold:   transform_stack :: (forall a. g a -> Stack (g a)) -> (forall a. Stack (f a) -> f a) -> g a -> f a ; transform_stack f g x = g (map_layer (transform_stack f g) (f x))
14:04:32 * boegel greets
14:06:13 <wagle> stepcut: where?
14:08:09 <stepcut> wagle: r5rs
14:10:29 <wagle> r6rs?
14:11:21 <wagle> (r7rs is in progress, but very closed)
14:12:40 * stepcut was reading r5rs
14:13:39 <wagle> yeah..  "hygiene" is a rut that scheme fell into
14:14:47 * stepcut is only worried about r5rs right now
14:15:09 <wagle> i think they are still in it, but I did see oleg mention some unhygienic macro stuff on his web page that i havent chased yet
14:16:16 <stepcut> scheme 5 macros are the next big piece in my scheme compiler -- so I have to finally learn about them :)
14:16:30 <wagle> well, i was hoping to get you to be skeptical/open-minded about the hygiene issue
14:16:59 <stepcut> heh
14:17:06 <wagle> lousy name for one of many possible solutions to a problem of name capture
14:17:08 <stepcut> well, currently, I am simple pragmatic
14:17:21 <stepcut> simply pragmatic
14:17:40 <wagle> my long experience is that the connotations of the name "hygiene" cloud peoples imaginations
14:18:38 <Oeje1> wagle: I'll join you on that one.
14:19:50 <wagle> i tried to use macros to define a dsl, using the macros to extend the syntax of scheme with the dsl, and the macros to _construct_ a scheme program (not beta reduce it, via the hygiene insight)
14:21:19 <wagle> the dsl classically used dynamic binding.  by algebraically transforming the interpreter to macros to be interpreted at compile-time, i transformed the dynamic binding to static binding..  mandatory hygiene broke that
14:23:25 <wagle> Oeje1: whats your take?
14:27:09 <wagle> .. or experience?
14:29:11 <Oeje1> I agree on the naming thing.  Just because e.g. "American" and "lousy dog" is the same word in Russian doesn't mean it's the same.
14:31:30 <Oeje1> Hm.  Well, I think, I'll just go to bed.  I have no intelligent response at this moment.
14:31:47 <wagle> g'night
14:45:23 <Oeje1> Does the BSD license allow binary only distribution?  And does it even allow distribution under a different license?
14:47:39 <Pseudonym> Yes, and sort of.
14:47:56 <Pseudonym> All the (new) BSD licence requires is that if you redistribute the source, you retain the copyright notice.
14:48:23 <Pseudonym> So it allows distribution under a licence which has additional restrictions.
14:48:33 <Pseudonym> But not under one, for example, that requires that you remove the copyright notice.
14:51:09 <Oeje1> "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:"
14:51:23 <Pseudonym> Right.
14:51:36 <Pseudonym> So you can't distribute under a licence that removes those conditions.
14:52:04 <Oeje1> So if I get hold on some BSD licensed source or binary, I'm entitled to distribute modifications.
14:52:24 <Pseudonym> If that's the only licence it's distributed under, yes.
14:52:41 <crot> well no
14:52:50 <Pseudonym> It's easier with the source, though, because you can excuse the non-BSD parts.
14:52:53 <Pseudonym> Hard to do with a binary.
14:53:25 <musasabi> BSD is easier than GPL ;)
14:53:44 <Oeje1> It says that the modification is under the same terms, the BSD.
14:53:45 <crot> it will be interesting to see what happens if dynamic linking ever gets tested in court
14:54:25 <Pseudonym> Yeah, nobody is entirely sure what "derivative work" means for software.
14:54:30 <crot> why should linking to a GPL'd binary make your program a derivative work?
14:54:32 <Pseudonym> There aren't precedents in all jurisdictions.
14:54:35 <crot> the FSF says it generally does
14:54:44 <crot> but I am not sure that is the case, especially in places other than the US
14:54:47 <dons> oh no - i'd have to check Cabal license fields in hs-plugins prior to load :)
14:54:49 * Pseudonym nods
14:55:03 <Pseudonym> I would think, for example, that if the GPL'd binary is a "plug in".
14:55:15 * xerox hops cheerfully
14:55:17 <Pseudonym> Then it would be hard to argue that.
14:55:20 <crot> well in the case of readline
14:55:26 <Pseudonym> Oeje1: What says that?
14:55:27 <crot> they just made a crappier version that had the same interface
14:55:37 <crot> and released it under some other license
14:55:42 * Pseudonym nods
14:55:57 <Pseudonym> The argument is stronger, though, if it's an _optional_ part.
14:56:03 <crot> so the FSF is contradicting themselves a bit
14:56:09 <crot> they are against protected interfaces in some cases
14:56:13 <crot> but they are for them in other cases
14:56:27 <Pseudonym> And if the API is a standard, I think the argument is stronger yet.
14:56:39 <Pseudonym> Linking to a GPL'd implementation of OpenGL, for example.
14:56:46 <Pseudonym> OpenGL is a standard API.
14:57:03 <Pseudonym> If you only call it through the API, then calling your program a "derivative work" is tenuous at best.
14:57:05 <crot> is there a decent GPL'd implementation of OpenGL anyone would want to link to? :P
14:57:15 <Pseudonym> crot: Not the point. :-)
14:57:59 <dons> @seen autrijus
14:57:59 <lambdabot> autrijus is in #haskell.
14:58:31 <crot> well in the case of FFTW
14:58:48 <crot> I know someone who was thinking of making an implementation of fftw.dll using the standard numerical recipes code
14:59:06 <crot> for his proprietary program ;)
14:59:22 <dons> autrijus: re. NameLoader - good, it's a lot simpler than hs-plugins (no dependency checking or runtime compilation). were there any specific problems with hs-plugins you had, in the end?
14:59:32 <Pseudonym> Well, the numerical recipes code has its own licence issues.
15:00:02 <Pseudonym> If I need numeric recipes-type code, I tend to look for old, liberally-licenced Fortran code and translate it.
15:00:14 <Pseudonym> It's usually better quality to begin with.
15:00:53 <crot> in the case of FFT
15:01:04 <dons> you're scaring me Pseudonym ;)
15:01:06 <crot> you might as well just use the code made by your CPU manufacturer (or Apple if you use a Mac)
15:01:21 <Pseudonym> I scare myself sometimes. :-)
15:01:50 <Pseudonym> But I also might be doing the world a favour by getting decent numeric code in a better language.
15:01:50 * musasabi makes a note to bother Pseudonym when needing advice on numerical code
15:01:59 <Pseudonym> musasabi: :-)
15:02:17 <Pseudonym> I've only needed numeric code fairly recently.
15:02:23 <Pseudonym> For my fluid simulation experiments, for example.
15:02:53 <crot> I just do lowly audio
15:03:01 <Pseudonym> Audio is harder, sometimes.
15:03:09 <crot> yeah it is
15:03:17 <crot> because small errors can be audible :P
15:03:20 <Pseudonym> In video, you can ignore all sorts of aliasing difficulties by adding noise.
15:03:23 <crot> and you need to run real-time
15:03:39 <Pseudonym> Because people don't object to seeing noise, especially if it's going by at 24+ fps and it's not correlated between frames.
15:03:40 <crot> unlike my other job, molecular modelling
15:03:43 <Pseudonym> But people object to hearing hiss.
15:03:46 <crot> in which I don't need to run real-time
15:03:52 <Pseudonym> crot: Ah, well, you know all about numeric stuff!
15:03:58 <Pseudonym> Oh, my video isn't real-time.
15:04:10 <crot> good idea
15:04:15 <crot> you probably save a lot of headaches
15:04:36 <Pseudonym> Real-time fluid simulation is difficult at best.  I only have a P4. :-)
15:04:54 <Pseudonym> My other computer isn't a supercomputer, sadly.
15:05:36 <metaperl_> Could someone help me with this error I'm getting: "Type constructor or class not in scope" ... here is the URL: http://hcoop.net/~terry/haskell/eofp/fig1.hs
15:06:38 <metaperl_> I know why it is saying it, but I dont know how to fix it
15:06:47 <Pseudonym> Explain why it's saying it.
15:07:03 <metaperl_> because M is not a data constructor
15:07:12 <metaperl_> not defined as a data constructor
15:07:17 <Pseudonym> OK...
15:07:23 <Pseudonym> So what do you want it to mean?
15:08:08 <metaperl_> well, what it is supposed to mean is that Fun should be a value constructor which takes a function f. f is a function which takes an argument of type Value and puts it in a container type M
15:08:32 <Oeje1> Pseudonym: Well, it states that modifications should include the BSD-license, so that only makes sense, if the new code is also under the BSD, or else only what's left after removal, which is under the BSD licencse.
15:10:06 <Oeje1> Pseudonym:  And also the BSD license is an OSI license which means:  " 2. Source Code  The program must include source code, and must allow distribution in source code as well as compiled form."
15:10:18 <Pseudonym> Yeah.
15:10:53 <musasabi> Oeje1: actually you may distribute BSD licensed works in binary form only too.
15:11:05 <Pseudonym> But it must ALLOW distribution in source code form.
15:11:07 <Pseudonym> Not REQUIRE.
15:11:45 <Oeje1> musasabi: Well, OSI says must.  Maybe I forgot the fine meaning of the word.
15:12:17 <Pseudonym> No, it says you must allow it.
15:12:35 <Pseudonym> Remember, the author of the original code has no copyright claim over your work.
15:12:42 <Pseudonym> You can release it under any terms you want.
15:12:45 <Oeje1> "The program must include source code"
15:12:51 <Pseudonym> The problem is only when you release something that contains their work.
15:12:58 <Pseudonym> Ah, that's different.
15:13:08 <Pseudonym> If you want to claim "open source", you have to release the source.
15:13:59 <Oeje1> Ah, so BSD can be an OSI license or not depending on the additional terms.
15:14:15 <Pseudonym> No, BSD is always an OSI licence.
15:14:35 <Pseudonym> If you release under the BSD licence, as-is, with source included, then your program is open souce.
15:14:40 <adiabatic> But people who do things with BSD-licensed stuff may or may not make OSI-licensed stuff.
15:14:47 <Pseudonym> Bingo.
15:15:28 <xerox> It applies to MIT licencing too?
15:15:41 <adiabatic> Right.
15:15:41 <Pseudonym> New BSD is isomorphic to MIT.
15:16:57 * xerox can't find a good reason to use the word 'isomorphic', you math guys. ;)
15:18:11 <Pseudonym> I thought it was a perfectly cromulent word that embiggened the point.
15:18:56 * xerox chomps
15:20:48 <metaperl_> any feedback on that Fun data constructor: http://hcoop.net/~terry/haskell/eofp/fig1.hs
15:21:02 <Pseudonym> Yes, sorry, back to your problem.
15:21:17 <Pseudonym> You say "f is a function which takes an
15:21:18 <Pseudonym>            argument of type Value and puts it in a container type M"
15:21:22 <Pseudonym> Which is fine,
15:21:28 <Pseudonym> Excelt, as you said, M isn't a type.
15:21:36 <Pseudonym> SO be more specific.  What is it supposed to mean?
15:21:45 <metaperl_> yes, he is attempting to be generic about M
15:21:47 <Oeje1> Since any derivative of a BSD licensed program must contain the BSD license.  So how can redistribution be restricted in the case of a binary of derivative?
15:22:33 <Pseudonym> Right.
15:22:46 <Pseudonym> So what you REALLY want is for M to be variable.
15:22:55 <Pseudonym> data Value m
15:23:01 <Pseudonym>   = Wrong
15:23:04 <Pseudonym>   | Num Int
15:23:16 <Pseudonym>   | Fun (Value m -> m (Value m))
15:23:31 <metaperl_> well one question
15:23:44 <metaperl_> why is there no slash in front
15:23:55 <metaperl_> lie Fun (\Value m -> m (Value m)
15:24:14 <metaperl_> I've never seen a polymorphic data constructor take a function and attempt to type it
15:24:25 <Pseudonym> Err... what would the slash mean?
15:24:38 <metaperl_> (\x -> x + 2) -- creates an anonymous function
15:25:05 <metaperl_> I guess the bottom line is I dont understand the semantic intent of the expression in parentheses after Fun
15:25:15 <metaperl_> Pseudonym, are you Andrew J. Bromage?
15:25:18 <wagle> "Value m -> m (Value m)" is a type expression
15:25:29 <metaperl_> I see, a new one to me
15:25:31 <Pseudonym> metaperl_: Errr... yes...
15:25:51 <wagle> "Value m" is a type expression
15:25:54 <metaperl_> ok, so how did you get out of Perl programming? what do you do for a living?
15:26:02 <Pseudonym> C++ programming. :-)
15:26:02 <wagle> "m (Value m)" is a type expression
15:26:04 <metaperl_> ick
15:26:07 <wagle> "Value m -> m (Value m)" is a type expression
15:26:12 <Darius> metaperl_: It shouldn't be new, any function you write has a type of the form A -> B for some A and B.
15:26:15 <Pseudonym> You say "ick", but you don't really mean it.
15:26:30 <metaperl_> wagle, thanks
15:26:34 <wagle> "Fun (Value m -> m (Value m))" is a _data constructor_ definition <<<
15:26:42 <metaperl_> Pseudonym, C++ is worse than Perl
15:26:49 * Darius isn't sure between Java and Perl which he'd choose, though given the choice, neither.
15:27:02 <metaperl_> Java if you want a job
15:27:06 <metaperl_> Perl work is scarce
15:27:10 <wagle> the Fun data constructor takes one argument, which will be of the specified type (Value m -> m (Value m))
15:27:14 <humasect> haskell.net
15:27:19 <humasect> f#
15:27:22 <metaperl_> C++ if you like writing 40 lines for 2 lines of Perl
15:27:47 <metaperl_> ok, so I need to rework wadler's figure 1
15:27:51 * Darius prefers C++ over both Java and Perl.
15:27:51 <Pseudonym> That's like saying "if you like writing 1000 words for a picture".
15:27:53 <metaperl_> his published code does not work
15:27:53 <Oeje1> Hey, if your productivity is measured in lines of code.
15:28:08 <Pseudonym> True enough, but there are very few sets of 1000 words adequately described by a cpitrue.
15:28:16 <Darius> Though not because Perl takes a lot of typing.
15:28:26 <Pseudonym> Similarly, there are very few sets of 40 C++ lines that can be adequately replaced by 2 lines of Perl.
15:28:31 * Darius likes to be able to understand his code before, during, and after writing it.
15:28:34 <wagle> or Perl if you dont want to ever finish debugging that 1000000 line C++ program
15:28:58 <metaperl_> objective - c : yes, I'll take it any day
15:29:05 <metaperl_> smalltalk : yes
15:29:10 <metaperl_> haskell : YES YES YES!!!
15:29:11 * humasect nods
15:29:12 <wagle> "the right tool for the right job"
15:29:19 <xerox> What would you suggest me between: "Type Theory and Functional Programming", "The Haskell Roat to Logic, Math and Programming", "Types and Programming Languages", "Functional Programming" ?
15:29:21 <Pseudonym> metaperl_: I know you're wrong because I used to say the exact same things that you're saying about C++.
15:29:25 <Pseudonym> THat was before I used it seriously.
15:29:35 <metaperl_> oh really?
15:29:44 <metaperl_> what book changed your mind about C++
15:29:44 <Pseudonym> Really really.
15:29:53 <metaperl_> so you think C++ is a good language?
15:29:55 <Pseudonym> No books, really.
15:30:03 <Pseudonym> Actually DOING something in it changed my mind.
15:30:30 <wagle> i keep hearing from people who seem cluefull that there is a subset of C++ that is perfectly reasonable
15:30:32 <metaperl_> I want One True Language to compliment my One True Editor
15:30:33 <Pseudonym> Though books like "Modern C++ Design" and "Generative Programming" helped bit.
15:30:47 <Pseudonym> wagle: Yes, it's the subset that isn't C.
15:30:50 <Darius> wagle: The subset that doesn't include C
15:30:58 <Pseudonym> Like Darius said.
15:31:06 <wagle> metaperl_: rock, paper, scissors
15:31:11 <Pseudonym> What I'd really like is an Ideal Stepanov Language.
15:31:13 <musasabi> A
15:31:30 <wagle> Pseudonym Darius : funny, but not what they were claimning
15:31:40 <Pseudonym> A language with all of the good features of C++ and then some, but without C underneath.
15:31:41 <metaperl_> Pseudonym: the book by Andrei Alexandrescu
15:31:41 <metaperl_> ?
15:31:46 <Pseudonym> Yes.
15:32:00 <Pseudonym> That book also influenced by Haskell programming, so that helped.
15:32:19 <wagle> <bart simpson> . . o o {"Good old rock! Nothing beats that!"}
15:32:27 <Pseudonym> Design Patterns sowed the seeds early, too.  It emphasised the point that you have to think beyond objects.
15:32:35 <xerox> "Modern C++ Design" ?
15:32:55 <metaperl_> xerox: http://www.amazon.com/exec/obidos/tg/detail/-/0201704315/qid=1111620739/sr=8-1/ref=pd_csp_1/103-9843981-7938245?v=glance&s=books&n=507846
15:33:08 <metaperl_> I really dont like the way Perl 6 is going
15:33:32 <wagle> which way is it going?
15:33:35 <metaperl_> Perl 6 has no idea what it is doing. It is a big confused amoeba
15:33:46 <xerox> @seen autrijus
15:33:47 <lambdabot> autrijus is in #haskell.
15:33:49 <metaperl_> trying it's best to integrate functional programming and oop
15:33:49 <Pseudonym> An Ideal Stepanov Language would have first-class support for concepts and templates (something like Haskell typeclasses, really) plus a decent metaprogramming system and aspects.
15:34:13 <Pseudonym> In fact, I want Scheme, except with a decent, modern, flexible type system and an imperative syntax.
15:34:27 <wagle> perl4 did its job..  needed nested datastructures.  perl5 was horrible
15:34:45 <Pseudonym> Or maybe I want monad-only Haskell plus instantiable modules, aspects and a better metaprogramming system.
15:34:59 <Pseudonym> Not sure.
15:35:21 <wagle> Pseudonym: what's missing from the ML family?
15:35:33 <metaperl_> Template Haskell seems to be a metaprogramming system that people are loking
15:35:48 <metaperl_> ML is not a pure functional language . It is also not lazy
15:35:58 <Pseudonym> And it's not imperative either.
15:36:06 <metaperl_> ?
15:36:08 <wagle> oh..  imperative _syntax_..
15:36:12 <metaperl_> that is not a drawback
15:36:17 <Pseudonym> And it doesn't have metaprogramming facilities.
15:36:41 <Pseudonym> And I'm beginning to think that aspects are much more important than I used to.
15:36:44 <wagle> i thought ML was imperative, just very functional
15:37:04 <metaperl_> is modern C++ design appropriate for a former C expert?
15:37:10 <metaperl_> an Perl professional?
15:37:11 <wagle> need reflection to do aspects right
15:37:26 <Pseudonym> metaperl_: If you know some Haskell (e.g. typeclasses), then you can probably follow it.
15:37:45 <Pseudonym> ML doesn't have destructors, too.
15:37:52 <Pseudonym> WHich is not a problem for ML.
15:37:55 <metaperl_> so now: which is the better language: Haskell or C++?
15:37:58 <Pseudonym> But it is for an Ideal Stepanov Language.
15:38:01 <metaperl_> certainly C++ has more libraries
15:38:04 * Darius hasn't got onto the aspects bandwagon so far, at least not how they are often presented.
15:38:04 <wagle> metaperl_: yes
15:38:23 <Pseudonym> I don't get drawn on which language is better than another, unless the choice is obvious.
15:38:24 * wagle plays paper to metaperl_ 's rock
15:38:38 <Pseudonym> It's obvious, for example, that C++ is better than C for the overwhelming majority of cases.
15:38:46 <xerox> Pseudonym, what do you mean with "imperative syntax" ?
15:39:13 <Pseudonym> xerox: Very good question!
15:39:15 <Pseudonym> I'm not sure.
15:39:35 <Pseudonym> I _think_ the point of imperative syntax is to express a narrative.
15:39:44 <Pseudonym> It's the "programming and writing" thing again.
15:39:56 <Pseudonym> Being able to express "this, then this, then this" emphasises the narrative.
15:40:10 <wagle> Pseudonym: i'm calling it "rewriting"..
15:40:14 <Pseudonym> Aspects give you footnotes which don't break the narrative flow.
15:40:15 <xerox> Pseudonym, how is it different from imperative language?
15:40:50 <wagle> .. with some notion of "interacting with an external environment"
15:40:54 <Pseudonym> xerox: Well, I think an Ideal Stepanov Language would be imperative underneath.
15:41:16 <wagle> whats "Stepanov"?
15:41:36 <xerox> I don't know what do you mean by ISL, so, you're talking about an imperative functional language? (Like javascript?)
15:41:45 <Pseudonym> http://lambda-the-ultimate.org/node/view/553
15:42:17 <xerox> Err, maybe "an imperative language that has functions as first-class citizens" sounds better.
15:42:40 <Pseudonym> I also want a Milner-esque type system with typeclasses.
15:42:48 <xerox> Sigh.
15:43:15 <Pseudonym> Yes, functions as first-class citizens is good, too.
15:43:21 <Pseudonym> Hmmm.
15:43:44 <Pseudonym> I think that's two low-level to be thinking, though.
15:43:59 <Pseudonym> Merely having functions as first-class citizens is a desirable feature.
15:44:08 <Pseudonym> Sorry, let me repeat that.
15:44:13 <Pseudonym> Merely having functions as first-class citizens is certainly a desirable feature.
15:44:36 <Pseudonym> But more important is the way to organise components, handle configuration, and make your code generic.
15:44:46 <Pseudonym> i.e. thinking at the even-higher-level
15:45:01 <xerox> Sorry, pressed the wrong keys.
15:45:13 <Pseudonym> What started me thinking about this was: Could you port the STL to Haskell?
15:45:19 <Pseudonym> And the answer, I think, is "no".
15:46:11 <xerox> Higher level? "Having map/fold/<insert preferred higher-order procedure here>" ?
15:46:13 <humasect> why?
15:46:24 <Darius> Pseudonym: What aspect of the STL did you see as being the most problematic?
15:46:37 <Pseudonym> Darius: The fact that structures are mutable.
15:46:52 <Pseudonym> That you can't describe a piece of a container by merely using a "begin" and "end" point.
15:46:59 <Pseudonym> You also need a handle on the container.
15:47:38 <Pseudonym> Many Haskell algorithms are not fully generic because they can't easily be parameterised on whether or not the data structure sits in a monad or not.
15:47:57 <Pseudonym> An algorithm on a FiniteMap is very different from one on an IOArray.
15:48:10 <Pseudonym> Now sure, you could say that a FiniteMap lives in the Identity monad.
15:48:23 <Pseudonym> And you could write your algorithms that way.
15:48:26 <xerox> An higer-level "Functor thing"?
15:48:33 <Pseudonym> But then you've lost one of the advantages of being pure functional.
15:48:45 <Pseudonym> You can't express your algorithm functionally.
15:48:59 <Pseudonym> You have to do it in a pseudo-imperative way.
15:49:16 <Pseudonym> Darius: WOuld you agree?
15:49:24 * Pseudonym is happy to be shot down in flames if he's wrong about this
15:49:48 <Pseudonym> But IMO, this is one reason why generic algorithms work better in scheme than in Haskell.
15:50:29 <Darius> I've said much the same recently about the latter part recently on c.l.f.  One point though is that with a fixed monad (especially the Identity one) you haven't lost all the benefits of purity.
15:50:31 <Pseudonym> Which is a bit ironic, in the Alanis Morrisette sense.
15:50:40 <Pseudonym> That's true.
15:50:43 <Darius> The main cost seems to be syntax.
15:50:47 <Pseudonym> Right.
15:51:01 <Pseudonym> Which is why, perhaps, what I want is a kind of Haskell which is monad-only.
15:51:15 <Pseudonym> Or, perhaps, arrow-only.
15:51:18 <Darius> Unfortunately, as I said on c.l.f, if you parameterize by the monad, you do lose most (but not all) of the benefits
15:51:56 <Pseudonym> Right.
15:52:06 <Pseudonym> And syntax, sadly, is the Main Thing(tm).
15:52:10 <Darius> Of course, you said before that you were looking for an "imperative syntax", so while for Haskell it's a problem for you it shouldn't be as much of an issue.
15:52:23 <Pseudonym> Syntax is what makes your code readable, as anyone who's read Oleg's code can testify.
15:52:47 <Pseudonym> The thing is, I'm trying to work out what this kind of language would look like.
15:52:58 <Pseudonym> And syntax is the biggie.
15:53:32 <Darius> I still see monadic syntax as (certainly worse than functional but) not significantly worse than "typical" imperative syntax perhaps better.
15:53:46 <Darius> One thing is that it makes order of evaluation explicit.
15:53:58 <Pseudonym> Right.
15:54:02 <Darius> Which has good and bad points, but is usually at least partially necessary.
15:54:12 <Pseudonym> Well, order of evaluation isn't explicit.
15:54:17 <Pseudonym> Compilers are free to reorder.
15:54:33 <Pseudonym> And they will.
15:54:41 <Pseudonym> Because the language is still lazy.
15:55:01 <Darius> It (over-)expresses the intent and the compiler will not reorder from the intended when it matters.
15:55:10 <Pseudonym> Right.
15:55:20 <Pseudonym> There are still data dependency constraints.
15:55:31 <Pseudonym> Even if the control dependencies are a convenient fiction.
15:56:33 <Darius> I'm usually more concerned about the under-expressed intent when it matters than the reverse.
15:56:43 * Pseudonym nods
15:58:12 <bd_> hmm, anyone mind helping me with a newbie question? I'm trying to create a class of which String is an instance, and I'm getting the error 'Cannot use type synonym in instance head' from hugs. I've put the minimal erroring example in http://www.haskell.org/hawiki/HaskellIrcPastePage
15:58:38 <Pseudonym> bd_: Try using hugs -98
15:58:46 <Pseudonym> That's a command-line option.
15:58:48 <bd_> aha
15:58:50 <bd_> that worked
15:58:55 <bd_> thanks
15:58:59 <goron> Pseudonym: Could you give an example?
15:59:02 <xerox> Try using data or newtype declaration for instance, now type?
15:59:08 <bd_> Is there a ghc version?
15:59:10 <Pseudonym> goron: Of what?
15:59:24 <goron> Pseudonym	Many Haskell algorithms are not fully generic because they can't easily be parameterised on whether or not the data structure sits in a monad or not
15:59:25 <bd_> xerox: It needs to accept Strings, or things will be very inconvenient elsewhere :|
15:59:42 <Pseudonym> goron: OK, here's an example.
15:59:44 <xerox> Tryed with [Char] ?
15:59:45 <Pseudonym> You have a container.
16:00:06 <goron> Maybe something, ok to keep simple.
16:00:15 <bd_> xerox: Yes, but the -98 option in hugs worked with String, so it's ok. I'm jst finding the ghc equivalent
16:00:26 <Pseudonym> bd_: -fglasgow-exts
16:00:39 <Pseudonym> goron: OK, but not Maybe.
16:00:47 <Pseudonym> Let's use Array and IOArray.
16:00:55 <Pseudonym> Hmmm.
16:00:59 <Pseudonym> OK, better example.
16:01:02 <bd_> Pseudonym: thanks again :)
16:01:02 <Pseudonym> FiniteMap and Array.
16:01:03 <Darius> Pseudonym: One issue/question is whether pure and impure containers/algorithms/etc. really -are- similar enough?
16:01:21 <Pseudonym> Right, actually, Darius is noting the most important point.
16:01:23 <Darius> For example, you often want both an in-place and a copying quicksort.
16:01:46 <Pseudonym> Suppose you want to turn a container into a lazy list (i.e. an "iterator" over all elements).
16:02:15 <Pseudonym> It's difficult at best to come up with a way to do this for both data structures which live in monads (e.g. IOArray) and ones which don't (e.g. FiniteMap).
16:02:19 <metaperl_> Type variable not in scope: `m'    for Fun (Value m -> m (Value m))
16:03:43 <Darius> metaperl_: [18:23] <Pseudonym> data Value m
16:04:17 <goron> Pseudonym: Don't you have that problem with any different API?
16:05:08 <Pseudonym> By all means try to come up with an API which accommodates both kinds of data structure.
16:05:34 <Pseudonym> What you'll end up doing, I'm pretty certain, is effectively embedding the non-monadic data structures in a monad.
16:05:38 <Pseudonym> Such as the Identity monad.
16:06:06 <metaperl_> Darius, thanks
16:06:47 <Darius> Pseudonym: Has there been an (imperative) language/library that has natural and comprehensively combined mutable and immutable data types under one interface?
16:06:52 <goron> Pseudonym: Well, I meant that you point out an instance of the problem "how to get a value from some datastructure". Therefor my question don't you have that problem with any API? I was not pointing out a possible solution.
16:08:00 <Pseudonym> Darius: Not in a language-checked way.
16:08:05 <Pseudonym> C++ has "const", of course.
16:08:24 <goron> Also, couldn't you just check the type of something at run-time and based on that do something?
16:08:34 <Darius> Pseudonym: By the way, have you seen Erwig's (I believe) "Metamorphic" programming?  Not really what we're talking about but interesting.
16:08:49 <Pseudonym> goron: You can solve all sorts of problems by making decisions at run-time.
16:08:57 <Pseudonym> But you lose efficiency and robustness that way.
16:09:00 <Darius> Refci!
16:09:14 <Pseudonym> I don't want my programs to die in the field.  I want the compiler to find problems for me.
16:09:41 <goron> Pseudonym: Then get an Oracle!
16:10:10 <metaperl_> how does OCaml sit with you Pseudonym?
16:10:53 <Pseudonym> O'Caml is a nice language.
16:13:26 <goron> Pseudonym: So even when the API's are the same, but on a different level (either inside a monad or not), you see a problem?
16:13:31 <ozone> except for its syntax
16:14:07 <Pseudonym> I think there's a problem with languages which look functional but aren't pure.
16:14:19 <Pseudonym> It's a theoretical problem, perhaps, because O'Caml is damn useful.
16:14:26 <metaperl_> your resume says you are working on a kiosk ... is it switching from Perl to C++?
16:14:44 <Pseudonym> My resume is probably old.
16:14:49 * Pseudonym hasn't worked on that for years
16:15:13 <metaperl_> http://andrew.bromage.org/resume/index.html - the link from search.cpan.org
16:17:55 * metaperl_ heads home
16:18:01 <Pseudonym> Farewell.
16:18:07 <metaperl_> well wait!
16:18:36 <metaperl_> type  Environment        =  [(Name, Value)]
16:18:43 <metaperl_> shouldnt that be switched to Value m
16:18:47 <Pseudonym> Right.
16:18:49 <metaperl_> [(Name, Value m)]
16:18:51 <metaperl_> ok
16:18:55 <Pseudonym> So you'll need to parameterise Environment by m, too.
16:20:06 <metaperl_> oh
16:20:17 * Darius wonders if implicit parameters would be more, less, or about as evil at the type-level.
16:20:58 * Darius can just think of it now: Dynamically-typed types!
16:21:35 <Pseudonym> I would like to see implicit configuration properly supported.
16:21:46 <Pseudonym> I think that would get rid of most of the arguments for implicit parameters.
16:23:35 <metaperl_> why was this type signature accepted?
16:23:35 <metaperl_>    showval                   :: Value -> String
16:23:35 <metaperl_>     showval Wrong            =  "<wrong>"
16:23:35 <metaperl_>     showval (Num i)          =  show i
16:23:36 <metaperl_>     showval (Fun f)          =  "<function>"
16:23:49 <metaperl_> it should have been showval :: Value m -> String
16:25:36 <Darius> metaperl_: Do you still define Value somewhere?  Otherwise it shouldn't be accepted.
16:25:52 <metaperl_> yes, it is Value m
16:26:09 <metaperl_> Value m = Wrong | Num Int | Fun (Value m -> m (Value m))
16:27:08 <Darius> Are you sure everything is current, that you don't need to reload something.  Otherwise you should be getting a kind error "Value does not have kind *"
16:27:23 <metaperl_> the full code is right here: http://www.hcoop.net/~terry/haskell/eofp/fig1.hs
16:27:51 <Darius> Pseudonym: Implicit configurations wouldn't help at the type-level.  But, yes, I agree.  I've never liked implicit parameters.
16:28:34 <metaperl_> what are implicit parameters?
16:28:39 <metaperl_> I think I ran across them recently
16:28:42 <Pseudonym> Darius: WHy wouldn't it help at the type-level?
16:28:51 <metaperl_> I guess the bottom line is: "no language is 100% perfect"
16:29:17 <Pseudonym> That's correct.
16:29:28 <Darius> What I'm talking about is something data ?m => Environment = ...
16:29:46 <Pseudonym> Even my theoretical Ideal Stepanov Language would be inconvenient for most purposes.
16:29:48 <Darius> Isn't 100% perfect a bit redundant?
16:29:53 <metaperl_> the first error is because lookup is ambiguous
16:30:03 <Pseudonym> Darius: No, I disagree.
16:30:09 <metaperl_> after the definition of showval.
16:30:14 <Pseudonym> You can achieve perfection on some axes.
16:30:22 <Pseudonym> Without achieving perfection on all of them.
16:30:58 <metaperl_> I wonder why no other language has as much connectivity to Apache as Perl via mod_perl
16:31:11 <Pseudonym> Because Ryan works for Covalent.
16:31:15 <Pseudonym> Or he did, anyway.
16:31:38 <Pseudonym> Technically speaking, C has more connectivity.
16:31:42 <Pseudonym> Or at least as much.
16:31:48 <metaperl_> MacEachern invented mod_perl
16:32:03 <Pseudonym> Oh, yeah.
16:32:10 <Pseudonym> Who was I thinking of?
16:32:20 <metaperl_> not sure
16:32:53 <Pseudonym> Ah, Doug MacEachern is employed at Covalent!
16:32:55 <metaperl_> I don't know how a mod_haskell would work,though there are papers showing how to emulate state in Haskell
16:33:09 <Darius> metaperl_: There is a mod_haskell
16:33:27 <Darius> Though I don't think it's being maintained.
16:33:46 <metaperl_> the advantage of mod_perl is the ability to load a bunch of things up at server startup time... I can't imagine that happening in Haskell
16:34:14 <metaperl_> that's one advantage . the other is manipulating the request cycle
16:34:24 <Pseudonym> The thing is, though, that Haskell is not designed to be a plug-in language.
16:34:40 <metaperl_> It woudl be really interesting see our entire code base re-wrttein in Haskell. I work for valueclick. We serve 50% of all the ads for the internet
16:34:50 <Pseudonym> That's the difference between HLLs and scripting languages.
16:35:02 <Pseudonym> HLLs want to take control.
16:35:14 <Pseudonym> Scripting languages want to play nice in a potentially hostile environment.
16:35:22 <metaperl_> it would be very interesting to see all of our ad-selection algorithms coded in Haskell
16:35:38 <metaperl_> yes, scripting languages are like water -> they change their shape
16:35:49 <Pseudonym> Right.
16:36:37 <metaperl_> Haskell is a language of the gods... people who can't thin kdeeply use scripting languages. It takes a lot of intelligence to use Haskell well...
16:37:14 <metaperl_> your average javascript/html programmer can gravitate over to PHP or Perl, but not Haskell
16:37:30 <neilc> whether that is the fault of haskell or of the programmer is debatable
16:37:47 <neilc> saying people who can't "think deeply" use scripting language is pure nonsense, imho
16:38:03 <metaperl_> oh really?
16:38:14 <neilc> yes, really :)
16:38:14 <Pseudonym> I'd agree with that.
16:38:35 <metaperl_> i'm just thinking of the HTML designers I know...
16:38:44 <Pseudonym> HTML isn't a scripting language.
16:38:53 <Pseudonym> It's a file format.
16:39:02 <metaperl_> it's a tree
16:39:16 <Pseudonym> It's a serialised tree.
16:39:18 <metaperl_> but they treat it as a string...
16:39:21 <Pseudonym> But it's a file format.
16:39:28 <metaperl_> that they can embed things into
16:39:59 <metaperl_> no, I want to stand by my statement. It takes a greater amount of intelligence to use Haskell than PHP/Perl
16:40:10 <xerox> (OT: `least' means the bigger or the smaller?)
16:40:51 <metaperl_> the average javascript/HTML programmer will find a scripting language very amenable to their way of thinking
16:41:00 <Darius> metaperl_: Actually, I'd probably say the latter.  Haskell is a much simpler language than PHP and Perl in many respects.  It may seem to take more effort though if you are -coming- from them.
16:41:16 <metaperl_> the approach of Haskell to HTML is very non-intuitie... just look at HaXML
16:41:25 <Darius> s/latter/converse
16:41:42 <Darius> metaperl_: What's JavaScript's "approach" to HTML?
16:41:43 <Pseudonym> I think you're both right, so there.
16:41:48 <adiabatic> metaperl_: You have to treat HTML as a string when you're generating itâotherwise you'll trip over this one supremely irritating IE bug.
16:41:54 <Pseudonym> Simple languages can be harder to use, because if your problem is this complex:
16:41:57 <Pseudonym> |                                                       |
16:42:03 <Pseudonym> And your language provides this much complexity:
16:42:06 <metaperl_> Perl is very forthcoming with its support. It is eager to provide things to you. Haskell forces you to play ball by its rules
16:42:21 <Pseudonym> |    |
16:42:28 <Pseudonym> Then you need to provide this much:
16:42:35 <Pseudonym>      |                                                  |
16:42:37 <metaperl_> you _must_ type your data... you must not have extraneous variables laying around... my Perl is becoming very crisp thanks to Haskell
16:43:07 <Pseudonym> On the other hand, it requires just as much intelligence to solve the same problem in Perl as in Haskell, for certain classes of problem.
16:43:26 <Pseudonym> i.e. the ones for which there is no canned solution or part-solution
16:44:00 <Darius> Pseudonym: And assuming that each in their own way adds the same amount of accidental complexity.
16:44:28 <Pseudonym> That's an interesting issue.
16:44:46 <Pseudonym> But I think for many classes of problem that assumption is true.
16:45:28 <metaperl_> most of the work in programming Haskell is getting things setup for Haskell to accept it. In perl, you dont have hte setup issue. But you have to deal with the entaglements that ensure from poorly specified data and hanging variables
16:45:39 <metaperl_> and mxing of functional concerns
16:45:52 <Darius> metaperl_: And you think that is easier?
16:45:54 <metaperl_> s/ensure/ensue
16:45:54 <Pseudonym> What you call "getting Haskell to accept it" is actually debugging in advance.
16:46:07 <Pseudonym> You're clarifying your thinking and removing errors.
16:46:09 <metaperl_> it is easier for some people for some problems
16:46:13 <Pseudonym> Errors which have to be removed later in Perl.
16:46:18 <metaperl_> I agree totally
16:46:45 <Darius> metaperl_: But you think not for most people and most problems?
16:46:49 <Pseudonym> There are some problems, though, where the language works against you.
16:47:03 <Pseudonym> I think the generic data structure problem, as I mentioned earlier, is one glaring example.
16:47:11 <metaperl_> but what I'm saying is PHP is the King of web scripting because of how unsophisticated the application is and because a lot of unsophisticated people flock to it and synergistically create more and more useful things for that level of usage
16:47:13 <Pseudonym> The distinction between monadic and non-monadic code in Haskell is huge.
16:47:37 <Pseudonym> PHP is a very thin layer of glue.
16:48:02 <Pseudonym> Which is not a criticism.
16:48:08 <metaperl_> especially since liftM takes arguments in reverse if (>>=)
16:48:31 <metaperl_> liftM and (>>=) do essentially the same thing. but they take the function argument in a different place
16:48:34 <metaperl_> @type liftM
16:48:37 <metaperl_> @type (>>=)
16:48:40 <lambdabot> bzzt
16:48:41 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
16:48:50 <metaperl_> where is liftM?
16:48:50 <Pseudonym> @type Control.Monad.liftM
16:48:51 <lambdabot> Control.Monad.liftM :: forall r m a1.
16:48:51 <lambdabot> 		       (Monad m) =>
16:48:51 <lambdabot> 		       (a1 -> r) -> m a1 -> m r
16:49:07 <metaperl_> see what I mean?
16:49:12 <Pseudonym> @type Control.Monad.fmap
16:49:13 <lambdabot> Control.Monad.fmap :: forall f b a.
16:49:13 <lambdabot> 		      (Functor f) =>
16:49:13 <lambdabot> 		      (a -> b) -> f a -> f b
16:49:24 <metaperl_> it easy to chain things with (>>=) not with liftM
16:49:38 <metaperl_> you start with your data and then chain together a bunch (>>=)
16:49:43 <Pseudonym> I'm not so sure about that.
16:49:45 <metaperl_> but with liftM you can't do that
16:49:51 <metaperl_> because of argument reversal
16:49:55 <Pseudonym> "Functional" dataflow is most naturally expressed from right to left.
16:50:03 <Darius> liftM isn't the same as (>>=) further more there is (=<<)
16:50:04 <Pseudonym> doStuff = f . g . h
16:50:23 <Pseudonym> doStuffM = liftM f . liftM g . liftM h
16:50:35 <Pseudonym> Which is the same as liftM (f . g . h), of course.
16:50:35 <Darius> liftM f m = m >>= return . f not m >>= f
16:50:54 <djo> hello
16:50:59 <metaperl_> hi djo
16:51:11 <Pseudonym> I'm going to have some things to say about this in a future TMR column.
16:51:22 <metaperl_> well, thanks for the interesting conversation. It saved me from having to sneak out of the office early :)
16:51:25 <djo> is there somthing like NULL in haskell ?
16:51:27 <Pseudonym> :-)
16:51:35 <Pseudonym> djo: Yes and no.
16:51:40 <Pseudonym> There's no direct equivalent.
16:51:44 <djo> this is my problem
16:51:52 <Darius> metaperl_: Also your comment was that Haskell took more intelligence to use than Perl/PHP, but your argument for PHP was that it was "unsophisticated", unsophisticated doesn't mean "takes less intelligence to use" and often means the reverse.
16:51:53 <Pseudonym> What is your problem specifically?
16:52:10 <metaperl_> djo, what do you want to do?
16:52:11 <Darius> Pseudonym: "this"? (re TMR)
16:52:33 <Pseudonym> Darius: About reading left-to-right, right-to-left, and in other directions.
16:52:41 <Pseudonym> And about the effectiveness of notations.
16:53:43 <djo> i'm modeling memory with an haskell list of Int and is some cases I want to "reserve" a list entry but without assigning any value...
16:54:12 <Pseudonym> Do you need to test whether or not there's a value there or not?
16:54:19 <Pseudonym> Or do you know by other means?
16:54:19 <djo> no
16:54:23 <Darius> djo: error "NULL" might be acceptable if you don't have to test whether it's occupied or not?
16:54:31 <Pseudonym> Or undefined
16:54:43 <Pseudonym> If you need to test, then Maybe Int is probably better.
16:54:54 <djo> i dont want to test
16:54:57 <Pseudonym> But a bottom value, like error or undefined, will work in your case.
16:55:05 * hellish lambdabot help
16:55:11 <Pseudonym> @type undefined
16:55:12 <lambdabot> undefined :: forall a. a
16:55:18 <Darius> @type error "NULL"
16:55:19 <lambdabot> error "NULL" :: forall a. a
16:55:21 <hellish> err, that should've been msg.
16:55:36 <djo> i just need to put a dummy value (not 0) just to reserv the index
16:55:37 <lambdabot> Foolish humans.
16:55:55 <Pseudonym> undefined works
16:55:56 <Darius> lambdabot: @eval undefined
16:56:03 <lambdabot> out of fuel - use @resume to continue
16:56:17 <Darius> or the error function if you want to customize the error message.
16:56:30 <Darius> or fix id if you want to delve into your navel
16:57:16 <Pseudonym> I think "undefined" should have been called "mu".
16:57:22 <djo> lambdabot, you mean somthing like this "memory++[@eval undefined]" ??? (where memeory = [Int])
16:57:43 <Pseudonym> memory ++ [undefined]
16:57:44 <Pseudonym> That works.
16:57:49 <djo> okey
16:57:59 * djo testing...
16:58:00 <Pseudonym> Meeting.  BBL
16:58:04 <Darius> @get-definition undefined
16:58:04 <thbot> undefined not defined
16:58:04 <lambdabot> undefined = undefined
16:59:11 <hellish> can someone help me point-free this: (ord(toUpper n))-64 ? something like (-64) . ord . toUpper?
17:01:07 <djo> Pseudonym, yes it works !!
17:02:41 <Igloo> subtract 64 . ord . toUpper
17:02:58 <Darius> Except ther is one snafu with syntax that's right, Igloo's remark is the solution.
17:03:12 <Darius> (-64) gets parsed as negative 64.
17:03:54 <hellish> That would be why I was getting an error then. Thanks, Igloo!
17:04:08 <xerox> ((-)64)
17:04:09 <Darius> @type (+(-64))
17:04:11 <lambdabot> (+(-64)) :: forall a. (Num a) => a -> a
17:04:23 <Darius> xerox: That's (64-) not (-64)
17:05:30 <xerox> Oh, yes O_o
17:06:18 <Darius> subtract = flip (-) and was defined purely because of that syntax conflict (or such is my understanding)
17:08:31 <xerox> (flip (-) 64)
17:10:05 <djo> how can I upadate a value at a ginig adress in a list ?
17:10:26 <djo> how can I upadate a value at a giving index in a list ?
17:11:01 <dons> have you read the Data.List documentation?
17:11:11 <djo> yep
17:11:16 <djo> there is no update
17:11:17 <xerox> djo, you have to rebuild the list, there is no mutation in Haskell.
17:11:24 <djo> ha
17:11:41 <djo> combinition of take and drop... humm I see
17:12:05 <xerox> ...or "splits and ++".
17:12:24 <dons> or pattern matching and recursion, or ... :)
17:12:42 <xerox> I like splits and ++ :)
17:13:11 <dons> I usually use break
17:13:18 <xerox> Break?
17:13:23 <dons> @type break
17:13:24 <lambdabot> break :: forall a. (a -> Bool) -> [a] -> ([a], [a])
17:14:14 <dons> @type break (== 0) [1,2,3,0,2,1,3]
17:14:16 <lambdabot> break (== 0) [1,2,3,0,2,1,3] :: forall a. (Num a) => ([a], [a])
17:14:32 <dons> anyway, TMTOWTDI in Haskell ;)
17:14:42 <Igloo> While you /could/ use break to update at a given address, it would be rather perverse  :-)
17:14:49 <dons> hehe
17:15:08 <Darius> How 'bout using regex's ;)
17:15:43 <dons> nah, just define your own lists using lambdas only, and split them using more lambdas
17:15:55 <dons> Igloo: had a look at hbc at all in the last week?
17:16:04 * dons is going to try the port soon
17:16:13 <Igloo> No - I have enough problems already  :-)
17:16:18 <dons> hehe. sure.
17:16:23 <dons> too many archs, not enough time
17:17:20 <Igloo> Does hbc support the accepted addenda?
17:17:33 <xerox> Yay, that's what I did today with hellish problem O_o
17:17:36 <dons> Igloo: hmm. don't reckon so. just h98.
17:17:43 * Igloo remembers its legendary unicode support and wonders if it behaves the same way as hugs
17:17:44 <Darius> HBC isn't even H98.
17:18:02 <dons> ?/
17:18:03 <dons> pill00$ hbi
17:18:03 <dons> Welcome to interactive Haskell98 version 0.9999.5c
17:18:05 * Igloo doubts I'll be packaging it for Debian, then
17:18:44 <dons> I wouldn't be interested either - but that looks like an H98-compliance assertion to me
17:18:45 <xerox> dons, it was "shift an element in a list, acting as it was circular", I went like: map a function leacing it partially applied, and then mapping some other args to the "list of lambdas" :P
17:19:44 <dons> :)
17:19:45 <Darius> Hmm, at the hbc page, it says "The HBC compiler is a compiler and interactive system for Haskell 1.4" and I didn't think 1.4 = H98
17:19:58 <dons> ah, but the website is hella old
17:20:04 <dons> let me see..
17:21:32 <dons> haskell.org says "The Chalmers Haskell-B compiler 0.9999.5c implements Haskell 98, as well as some extensions."
17:21:41 <Darius> Yes, the page says version 0.9999.4 but the page linking to it on Haskell.org is 0.9999.5c
17:22:11 <Darius> Where do you even get HBC now?
17:22:26 <dons> http://www.haskell.org/hbc/hbc-2004-06-29.bin-i386-linux.tar.gz
17:22:42 <dons> some Chalmers guys are maintaining it, I think
17:22:55 <dons> Thomas Hallgren and Magnus Carlsson
17:22:55 <Darius> It's maintained?
17:23:04 <dons> they made a release last June
17:23:17 <dons> let me find the release msg
17:28:06 <dons> hmm. this is a hard msg to fine.
17:28:09 <dons> find
17:28:18 <skew> what are you looking for?
17:28:42 * Darius wonders about the type of a paramorphism in the unapplied predicative polymorphic lambda calculus.
17:28:44 <dons> the release/announce msg for hbc 0.9999.5c last Jun.
17:29:28 <dons> because someone announced it, as I installed hbc on June 30th, 2004
17:30:11 <dons> I wonder if hbc can still compile nhc. That would be an H98 proof, wouldn't it?
17:30:22 * dons tries it
17:31:40 <Darius> I believe you now, I thought HBC hadn't been touched for like the past 7 years or so.
17:32:21 <Darius> @type cons x xs c n = c x xs (xs c n)
17:32:23 <lambdabot> bzzt
17:32:49 <dons> I'm intrigued as to why, despite being a working H98 compiler, there's almost no information on hbc anywhere
17:33:10 <Darius> Because I doubt it was until that release last year.
17:33:28 <skew> dons: apparently "hbc" appears nowhere in any June 2004 mail traffic
17:33:41 <dons> no. so how did I find out about the release? hmm.
17:33:55 <skew> at least not on the haskell list, anyway
17:34:08 <dons> heh. when you untar the hbc src, it creates the "LML" directory
17:34:52 <dons> "hbc includes code generators for: NS32k, M68K, I386, Alpha, ARM, Cray-1, HPPA, MIPS, PowerPC, RT/PC, SPARC, and Vax."
17:35:47 <Igloo> I'm sure it was on some list
17:36:22 <Darius> Hmm, apparently HBC was alive even back in 2001 http://www.haskell.org/pipermail/haskell/2001-June/007458.html
17:37:49 <dons> curiouser and curiouser
17:38:31 <skew> dons: there are two passing references to hbc on haskell-cafe in July 2004, out of April, May, June, and July
17:38:48 <dons> but no announce?
17:39:15 <skew> No, looks like you didn't hear about this from haskell or haskell-cafe
17:39:22 <dons> hmm. weird.
17:40:01 <dons> heh, nhc says: "You said you want to use hbc to build hmake."
17:40:16 <dons> "You are going to build nhc98 with:          hbc"
17:41:33 <dons> there's so much .hs code in the hbc src - it would be a shame to not use it.
17:43:03 <dons> hmm. what's the difference between hbc and lmlc ?
17:43:29 <dons> pill19$ lmlc -v
17:43:29 <dons> lmlc Haskell98 version 0.9999.5c, 2004 Jun 29
17:45:29 <dons> I'm getting somewhere compiling nhc98 with hbc :)
17:45:30 <dons> pill19$ gmake
17:45:30 <dons> hbc  -cpp -o lib/ix86-Linux/hmake-PRAGMA script/hmake-PRAGMA.hs
17:45:30 <dons> cd src/runtime;        make all nhc98heap
17:49:20 <dons> it's managed to compiler the nhc prelude :)
17:49:26 <xerox> Goodnight folks.
17:52:54 <dons> ah ha! found the 'announce' on the nhc list: http://www.haskell.org/pipermail/cvs-nhc98/2004-June/004066.html
17:54:30 <Darius> @type List.split
17:54:32 <lambdabot> bzzt
17:54:36 <Darius> @type split
17:54:38 <lambdabot> bzzt
17:54:43 <Darius> @type List.splitAt
17:54:45 <lambdabot> List.splitAt :: forall a. Int -> [a] -> ([a], [a])
18:09:21 <Darius> What do you call those little site-specific icons in the location textbox or tabs in e.g. Firefox or IE?
18:10:06 <dons> silly?
18:10:22 <dons> :)
18:10:48 <heatsink> favorite.ico
18:11:05 <heatsink> actually, favicon.ico
18:11:53 <Darius> I thought there was some more general sounding name.
18:15:20 <heatsink> not that I know of.
18:22:43 --- topic: set to 'hi' by unnamedz
18:22:56 --- topic: set to 'hi | LOL !' by unnamedz
18:23:27 <dons> that sucks.
18:25:42 --- topic: set to '["http://haskell.org/learning.html","See logs jttp://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! ICFP contest 2004","We put the Funk in Funktion","http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne"]' by Darius
18:25:59 <Darius> dons: What sucks is that person might not actually be a five year old.
18:26:19 <dons> it is bizarre behaviour
18:27:33 <Darius> ["http://haskell.org/learning.html","See logs http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! ICFP contest 2004","We put the Funk in Funktion","http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne"]
18:29:32 --- topic: set to 'http://haskell.org/learning.html","See logs http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! ICFP contest 2004","We put the Funk in Funktion","http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne' by hellish
18:29:45 <hellish> s/jttp/http
18:32:40 --- topic: set to '["http://haskell.org/learning.html","See logs http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! ICFP contest 2004","We put the Funk in Funktion","http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne"]' by Darius
18:35:55 <hellish> why is the topic a list of strings?
18:37:43 <dons> because it is then well-typed, I guess
18:38:45 <Darius> @listmodules
18:38:46 <lambdabot> I have the following modules installed: ["base","cmafihe","dict","dummy
18:38:46 <lambdabot> ,"dynamic","eval","hello","karma","quote","seen","state","system","topic
18:38:46 <lambdabot> ,"type"]
18:38:56 <Darius> @listcommands topic
18:38:57 <lambdabot> Module topic provides the following commands: ["topic-tell","topic-cons
18:38:57 <lambdabot> ,"topic-snoc","topic-tail","topic-init"]
18:39:26 <Darius> @topic-snoc bar
18:40:00 <Darius> @topic-snoc "bar"
18:41:04 <Darius> There was some fiddly thing about it, but I forget what.
18:41:51 <hellish> ah, so the topic is a list of strings for optimum fiddle-ability
18:42:03 <Darius> @eval foldl (\x xs.succ x : xs) [] [1,2,3]
18:42:03 <lambdabot> unbound variable: succ
18:42:14 <Darius> hellish: It's a list of strings so lambdabot can manipulate it.
18:42:23 <Darius> @eval foldl (\x xs.(x+1) : xs) [] [1,2,3]
18:42:23 <lambdabot> type error
18:42:35 <hellish> Darius, that's what I meant
18:43:07 <Darius> @eval foldr (\x xs.(x+1) : xs) [] [1,2,3]
18:43:08 <lambdabot> [2, 3, 4]
18:43:35 * Darius is surprised that an XSLT "programmer" can't cut&paste.
18:43:44 <bourbaki> moin
18:46:23 <waltz> nice
18:51:10 * Darius imagines XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
18:52:59 <_metaperl> @type return
18:53:01 <lambdabot> return :: forall m a. (Monad m) => a -> m a
18:56:16 <Cale> @type liftM
18:56:18 <lambdabot> bzzt
18:56:24 <Cale> @type Control.Monad.liftM
18:56:25 <lambdabot> Control.Monad.liftM :: forall r m a1.
18:56:25 <lambdabot> 		       (Monad m) =>
18:56:25 <lambdabot> 		       (a1 -> r) -> m a1 -> m r
18:57:08 <_metaperl> I'm trying to monadify something Wadler wrote in '92: http://www.hcoop.net/~terry/haskell/eofp/fig1.hs   ... my question is how will return know which container type to use?
18:58:51 <_metaperl> interp (Con i) e         =  return (Num i) -- the line I created which is what my return question is about
18:58:52 <Cale> type inference, or explicit declaration
18:59:25 <_metaperl> so Value a must be declared with a type restriction of Monad m
18:59:26 <_metaperl> ?
18:59:34 <Cale> and perhaps you want the type there to be (m Value)
18:59:43 <Cale> yeah, you'd want that
18:59:48 <_metaperl> if you look higher up (Num Int) is one possible data constructor for value
18:59:50 <Cale> er
19:00:15 <Cale> interp :: (Monad m) => Term -> Environment -> (m Value)
19:00:18 <Darius> The fact that you are using 'return' makes it clear that you want a monad.  The specific monad will be decided by how the code is used, e.g. with runState it would make the monad a State monad.
19:00:38 <Darius> As Cale said, this is just standard type inference and type class resolution.  There is no magic with monads.
19:01:35 <Darius> But to update the example, simply replace all uses of unitM with return and bindM with (>>=) and make instance Monad M where return = unitM;(>>=) = bindM
19:02:39 <_metaperl> if I replace all uses, why would I need any reference to bindM and unitM at all?
19:03:01 <Darius> You need their definitions, but, sure, you could inline them for the instance declaration and get rid of them.
19:03:27 <_metaperl> standard Monad programming makes no mention of unitM or bindM
19:03:33 <dons> yay. hbc can compile the latest nhc98:
19:03:34 <dons> pill19$ ./nhc98 --version
19:03:34 <dons> ./nhc98: v1.18 (2005-03-11 version)
19:03:34 <dons>   [ config: ix86-Linux/hbc by dons@pill19 on Thu Mar 24 12:39:42 EST 2005 ]
19:03:37 <_metaperl> I think this code should run with them completely gone
19:04:04 <Darius> dons: Did it take that long?
19:04:10 <dons> yeah :)
19:04:20 <dons> takes around 30 mins with ghc.
19:05:09 <dons> it took just over an hour -- not too bad
19:05:22 <dons> so I declare hbc in working condition!
19:05:25 <Darius> _metaperl:  The paper you're reading was before monads were added to Haskell and (obviously) the names hadn't been decided on.
19:05:39 <Darius> dons: I don't know.  Have you tested that Vax backend?
19:05:44 <_metaperl> yes, but should unitM and bindM be obsolete-able?
19:05:59 <dons> :P
19:06:21 <Darius> _metaperl: They aren't obsolete, they are just the names Wadler chose for return and (>>=).  unitM and bindM are normal functions.
19:06:48 <Cale> _metaperl:  unitM <--> return,  bindM <--> (>>=)
19:06:49 <Cale> yeah
19:07:07 <_metaperl> yes I know that
19:07:35 <_metaperl> I'm just wondering why Darius said " make instance Monad M where return = unitM;(>>=) = bindM"
19:08:08 <Cale> well, that's if you don't get rid of the old names -- otherwise, just cut and paste the code for them in and rename them appropriately
19:08:08 <_metaperl> I guess he meant do this, with the understanding that return == unitM
19:08:12 <_metaperl> dont actually mention them
19:08:33 <Cale> you could just leave the old definitions in if you felt like it
19:08:48 <_metaperl> no, I want to get rid of them
19:09:12 <Darius> 'instance Monad M where return = unitM; (>>=) = bindM' is executable Haskell assuming M,unitM,and bindM are defined appropriately.
19:12:26 <adiabatic> @eval foldl (*) 1 [1..10]
19:12:26 <lambdabot> (line 1, column 8):
19:12:26 <lambdabot> unexpected "*"
19:12:26 <lambdabot> expecting simple term
19:12:55 <Darius> @eval foldl (\x y.x*y) 1 (fromTo 1 10)
19:12:56 <lambdabot> 3628800
19:13:20 <adiabatic> What language is that?
19:13:28 <bd_> er, haskell? :)
19:13:30 <Darius> A sugared lambda-calculus.
19:13:36 <_metaperl> why didnt his example work?
19:13:43 <adiabatic> Then why won't (*) work?
19:13:43 <_metaperl> he curried *
19:13:44 <Darius> @eval foldl (\x y -> x * y) 1 (fromTo 1 10)
19:13:45 <lambdabot> 3628800
19:14:10 <_metaperl> @eval foldl (\x y -> x * y) 1 [1..10]
19:14:10 <lambdabot> (line 1, column 28):
19:14:10 <lambdabot> unexpected "."
19:14:10 <lambdabot> expecting simple term
19:14:20 <_metaperl> @eval [1..10]
19:14:21 <lambdabot> (line 1, column 4):
19:14:21 <lambdabot> unexpected "."
19:14:21 <lambdabot> expecting simple term
19:14:24 <Darius> The [1..10] syntax isn't implemented.
19:14:33 <adiabatic> implemented in...?
19:14:39 <Darius> Haskell
19:14:44 <_metaperl> @eval foldl (*) (fromTo 1 10)
19:14:44 <lambdabot> (line 1, column 8):
19:14:44 <lambdabot> unexpected "*"
19:14:44 <lambdabot> expecting simple term
19:14:46 <Darius> It's a module of lambdabot.
19:15:00 <Darius> section syntax isn't supported either.
19:15:01 <adiabatic> Is [n..m] part of haskell '98?
19:15:14 <Darius> Both of them can be added with some minor parser hacking.
19:15:19 <Darius> adiabatic: Yes.
19:18:09 <_metaperl> how can we transform  data  Value = Fun (Value -> M Value)    INTO  data  Value m = Fun (Value m -> m (Value m))
19:18:56 <Darius> What do you mean?
19:19:29 <_metaperl> you were saying the program could run as is for appropriate definitions of M, bindM, unitM
19:19:38 <_metaperl> this is how M was used in the original program
19:19:40 <monochrom> that is mind-blogging.  is it even permitted to have data  Value m = Fun (Value m -> m (Value m))?
19:20:02 <Darius> monochrom: Yes, why not?
19:20:21 <_metaperl> it's kind of weird: just put List in for m
19:20:36 <_metaperl> then we have Fun (Value List -> List (Value List))
19:20:38 <_metaperl> weird
19:20:51 <Darius> And you get a kind of non-deterministic pure lambda calculus type.
19:21:00 * _metaperl wonders why Simon Thompson's book is not online for free
19:21:23 <Darius> Or m can be (r ->) and you get Fun (Value (r ->) -> r -> Value (r ->))
19:21:59 <monochrom> Jezum Yaweh, it is permitted!  Haskell type system keeps elluding me!
19:22:44 <_metaperl> one of Wadler's original signatures was   apply                     :: Value -> Value -> M Value
19:22:53 <_metaperl> that M is hard to swallow
19:23:17 <_metaperl> apply takes two values and produces a value in a container I suppose that is what this means
19:23:20 <Darius> That's not M, M will be something like, data M a = M (Env -> a)
19:23:26 <_metaperl> but how to rewrite this in modern syntax?
19:23:48 <_metaperl> ah, he never defined M
19:23:53 <_metaperl> the example did not work off the bat
19:24:05 <Darius> He changes M for different monads.
19:24:06 <_metaperl> when I loaded it in... it lacked definitions for unitM
19:24:31 <_metaperl> ok, I'm going back to his original code and starting from scratch
19:24:34 <Darius> For each feature that's varied or added.
19:25:34 <Darius> Haskell didn't have constructor classes back then.
19:33:46 <_metaperl> the Fun data constructor confuses me a bit:
19:33:46 <_metaperl> data  Value m              =  Wrong
19:33:46 <_metaperl>                               |  Num Int
19:33:46 <_metaperl>                               |  Fun (Value m -> m (Value m))
19:33:46 <_metaperl>  
19:33:47 <_metaperl> what m can serve to be a container type for a datum of type Value m
19:33:47 <Darius> Any m :: * -> *
19:33:47 <_metaperl> no, there are only 3 options for Value
19:33:47 <_metaperl> Wrong, Num Int and Fun
19:33:47 <_metaperl> Wrong can't be it
19:33:47 <_metaperl> Value m == Wrong is not an option
19:33:47 <_metaperl> Value m == Num Int can't be it
19:33:47 <_metaperl> and Fun can't either
19:33:47 <Darius> Value m is a type not a value.
19:33:47 <_metaperl> can m == Int?
19:33:47 <_metaperl> Fun (Value Int -> Int (Value Int))
19:33:47 <_metaperl> that makes no sense
19:33:47 <_metaperl> oh Value m is a type not a data constructor!
19:33:47 <Darius> Not Int has kind *, not kind * -> *.  Int (Value Int) doesn't make sense anymore than ('a' "foo") does.
19:33:47 <_metaperl> ah
19:35:09 <Darius> Let's say m is [], then a value of type Value [] would be for example, Fun (\(Num n) -> [n,n+1])
19:36:25 <Darius> @type \n -> n+n
19:36:27 <lambdabot> \n -> n+n :: forall a. (Num a) => a -> a
19:45:33 <isomer> i installed open office. i feel dirty
19:45:57 * Darius can double-click and have C# installed...
19:46:14 <isomer> but...why would you, Darius?
19:46:30 <Darius> Indeed, I can double click something else and have Painter IX
19:49:42 <isomer> omg, open office is every bit as crappy as ms office! lovely!
19:50:03 <Pseudonym> So it's fully crap-compatible?
19:51:00 <isomer> it's craptastic!
19:51:28 <_metaperl> it has taken me 10 minutes to digest the fact that Value [] could be Wrong or it could be Num 6 or Fun ( (\Num n) -> ...) but I am still stuck on the [n, n+1]
19:51:44 <_metaperl> Num n is an instance of Value m
19:51:56 <_metaperl> a reification of it. a concretization of it
19:52:01 <_metaperl> that's why that is ok
19:52:29 <_metaperl> but I am not quite connecting on how [n, n+1] satisfies m (Value m)
19:52:34 <_metaperl> for Value []
19:52:46 <cm> hi
19:52:47 <_metaperl> clearly the outside m is []
19:52:53 <_metaperl> the container one
19:53:56 <_metaperl> but the Value m it contains must be Wrong or Num Int, not just Int
19:54:29 * Darius needs to implement bit shifting operations for @eval
19:54:33 <_metaperl> given m (Value m)
19:54:38 <_metaperl> do you see my dilemma?
19:55:09 <monochrom> I think [Num n, Num (n+1)] would be kosher, then?
19:55:14 <Darius> _metaperl: That's because I have a type error, [Num n, Num (n+1)] was what I intended.
19:55:26 <_metaperl> AH!!!!
19:56:11 <Darius> @type 0xF0
19:56:12 <lambdabot> 0xF0 :: forall t. (Num t) => t
19:56:16 <Darius> @eval 0xFo
19:56:17 <lambdabot> type error
19:56:19 <Darius> @eval 0xF0
19:56:19 <lambdabot> 240
19:56:24 <Darius> Hey!
19:57:01 <Darius> Is there a not horribly inefficient way of implementing xor in terms of arithmetic operations?
19:57:45 <Darius> And the other bitwise operations.
19:58:19 <cm> Data.Bits hmmkay?
19:59:02 <dons> xor# :: Word# -> Word# -> Word#
19:59:09 <dons> isn't too inefficient ;)
19:59:27 <Darius> dons: But that isn't in terms of arithmetic operatios.
20:00:15 <dons> I don't think I understand what you mean by "in terms of arithmetic operations"? - you want an algo for xor?
20:01:27 <Darius> Yes, but preferably not too too slow.
20:01:34 <Darius> (I.e. bit by bit say)
20:01:54 <Pseudonym> Well you can probably do it the obvious way, by iterating over bits.
20:02:06 <Pseudonym> mod-2-and-shift-right
20:02:18 <Darius> That's what I was trying to avoid.
20:02:29 * Darius was a bit ambiguous.
20:08:17 <heatsink> Darius: I doubt it.  But if you have a fast AND then you can do XOR and OR easily.
20:08:44 <Darius> heatsink: I doubted it too, but was hoping someone would prove me wrong.
20:09:00 <cm> let x a b = (a .|. b) .&. (complement $ a .&. b) -- and so on o0
20:26:36 <skew> join #42424242
20:27:33 <skew> hmm, nobody there
20:30:09 <monochrom> Methinks 101010 is better.  Binary for 42.
20:30:26 <skew> that's hex already
20:30:34 <skew> utime 0x42424242 was some seconds ago
20:32:00 <monochrom> Don't you think 101010 has a pattern?  If someone wants to pull a pun out of computers, don't you think 101010 is quite appropriate and that is probably why the man chose 42?
20:32:45 <Cale> He chose 42 randomly, and it just happens to have that pattern.
20:33:11 <monochrom> I suppose that is the orthodox view.
20:33:26 <Cale> (I remember reading an interview or something somewhere which had him saying that anyway)
20:33:32 <skew> as do I
20:34:26 <Cale> What do people think of the idea to allow default superclass instances in classes?
20:35:05 <skew> what does that mean?
20:35:18 <skew> oh, I see
20:35:42 <Cale> (On the Haskell mailing list)
20:35:56 <skew> I'm not quite up to date on reading the list
20:36:03 <skew> what did they propose for syntax?
20:36:23 <skew> like defaults now, but just use the name of the superclass methods?
20:37:05 <Cale> class Functor m => Monad m where
20:37:09 <Cale>    -- ...
20:37:17 <Cale>    instance Functor m where
20:37:23 <Cale>       fmap = liftM
20:37:50 <Cale> Which is a way to require Monads to be Functors which would maintain backward compatibility.
20:38:51 <Cale> There is the issue of multiple default instance specifications, but it doesn't seem like so much of a problem that we couldn't just emit a warning and choose one, or force the user to provide an instance when they conflict.
20:43:14 <skew> I'm trying to think of a nice way to handle operator precedence in a parser
20:52:48 <skew> is there any paper on functional programming things with a title that isn't a pun?
20:53:21 <skew> I was just looking up FiniteMap docs and noticed the credit to the paper "Efficient seta: a balancing act"
20:53:48 <skew> Then there's Wadler's "comprehending monads"
21:01:04 <heatsink> What's the pun there?
21:02:06 <skew> he is explaining monads, and presenting a monad comprehension notation
21:03:32 <Lemmih> Good morning, #haskell.
21:03:38 <monochrom> I like the pun in "linear types can change the world!" most
21:08:05 <KrispyKringle> heya, folks. am i mistaken, or is (foo, bar) <- baz syntax not allowed in a "do" block? it doesn't seem to be working for me.
21:08:31 <KrispyKringle> er, nevermind.
21:08:33 <monochrom> It is allowed.  Assuming it type-checks.
21:08:41 <KrispyKringle> hrm.
21:08:49 <KrispyKringle> yeah, i seem to have some issues type checking :P
21:08:55 <KrispyKringle> thanks,monochrom
21:12:50 <skew> KrispyKringle: was the error mesage unclear about what sort of error your program had?
21:13:09 <KrispyKringle> skew: yes. but it's possible that that was my fault, and not that of the error message :P
21:13:47 <skew> what was the error?
21:14:13 <KrispyKringle>     Couldn't match `CGI' against `(,) Description'
21:14:16 <KrispyKringle> etc
21:14:39 <skew> continuting "... when checking types in <exr>"?
21:14:54 <KrispyKringle> yes.
21:15:07 <skew> Maybe the bit about types should show up sooner
21:15:29 <KrispyKringle> no, i didn't read over it.
21:16:00 <KrispyKringle> i just was initially thinking that maybe it had trouble with matching the type of the expression on the right side of the assign with the types of the individual variables in the tuple.
21:16:15 <KrispyKringle> i don't know what i was thinking. wanted to eliminate possible sources of error, 'cause i was unclear on this one.
21:18:07 <cm> ..mais deux c'est mieux
21:46:05 <Leimy> anyone got a simple example of a GHC program doing a forkProcess and executeFile I can peek at?
21:46:15 <Leimy> I think I'm doing something stupid again
21:50:09 <skew> Does anyone know of a nice data structure for lists with separators? I want something like a list of Int with a String between each pair of number.
21:55:32 <KrispyKringle> skew: couldn't you just use a list of (Int, String)
21:55:33 <KrispyKringle> ?
21:56:04 <skew> I want to represent expressions before resolving operator precedence, like x + y * z / w
21:56:41 <skew> I started writing some code over FlatExp = Op Atom String FlatExp | Base Atom
21:57:22 <skew> but that got ugly, so now I'm thinking about trees
21:57:49 <skew> That type is just left biased trees, so maybe the same sort of representations would work well
21:57:55 <KrispyKringle> why not make something like [Literal], where Literal = Int | Plus | Minus | Divs | Muls
21:58:00 <KrispyKringle> well, yes, a tree is better
21:58:13 <KrispyKringle> since expr = expr OP expr | Int
21:58:39 <skew> I think just realizing that my type is a biased tree is enough
21:59:44 <skew> I was using functions as accumulating parameters, the tree viewpoint says that those functions are actually representing tree fragments
22:11:09 <wbb4> I've a ghc-pkg type question, I'm trying to install haxml, and I'm getting an invalid syntax error when it tries to --add-package, and the pkg.conf file doesn't look anything like waht the ghc-pkg docs describe
22:11:21 <wbb4> this is ghc 6.4 and haxml 1.12
22:11:31 <Leimy> and Mac OS X right? :)
22:11:37 <wbb4> heh, yup
22:23:23 <Lemmih> wbb4: GHC 6.4 only supports Cabal packages.
22:29:16 <wbb4> Lemmih, ah, ok.  that makes sense with what I'm reading (I'm quite new with haskell :), is there a way to convert the pkg.conf file I have with haxml, or would my best bet be to grab it from cvs, which looks to have a cabal package?
22:29:46 <Lemmih> The latter.
22:29:51 <wbb4> cool, thanks :)
23:13:05 <ozone> Philippa_: ping
23:13:24 <ozone> Philippa_: pseudonym mentioned you had an idea named supertypes (or superclasses?, i forget sorry!)
23:13:31 <ozone> if you're free right now, care to elaborate on it?
