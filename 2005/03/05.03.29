00:00:20 <Heffalump> it's good to have two implementations
00:01:35 <Cybertnt> ok
00:34:13 <Torquemada> \leave
00:39:41 <Gahhh> Would it be correct to say that a parser is a deserializer of an abstract data type ?
00:58:27 <nlv11757_> does this ghc --make replace the Makefile?
00:59:24 <Lemmih> More or less.
01:00:18 <nlv11757_> still need to call ghc from the Makefile you mean?
01:01:34 <Lemmih> No. --make doesn't (and shouldn't) handle files which needs preprocessing (except for cpp).
01:01:52 <Lemmih> This's where Cabal comes in.
01:03:01 <nlv11757_> preprocessing as in ...
01:03:08 <nlv11757_> calling lhs2tex or something like that?
01:04:36 <kosmikus> I think it actually can handle preprocessors to a limited extent, using -pgmF and a suitably intelligent script to dispatch to the "correct" preprocessor
01:04:58 <Lemmih> kosmikus: Yes. It's called Cabal (:
01:05:10 <kosmikus> no, I mean ghc
01:05:36 <kosmikus> this functionality existed long before Cabal
01:05:55 <Lemmih> As in 'ghc --make Main.hs'?
01:06:29 <Lemmih> Figuring out which dependencies require preprocessing and applying it would be a pain.
01:08:33 * Lemmih is saying that 'ghc -c SomeModule' doesn't call greencard on SomeModule.gc if it exist.
01:09:23 <kosmikus> no, but it could work if the sourcefile would not be called .gc
01:09:29 <kosmikus> it works for lhs2TeX, actually
01:10:30 <Lemmih> I still don't see how you would apply individual preprocessing to a list of files.
01:11:31 <kosmikus> using -pgmF, you can pass each source file to a program
01:11:44 <kosmikus> this program can be a script that looks at the file and decides, based on content, what to do with it
01:12:16 <kosmikus> I have a very simple script that decides whether it is an lhs2TeX source file or not, and either calls lhs2TeX on it or does nothing
01:13:08 <kosmikus> I agree, Cabal is much more sophisticated, and so is hmake
01:13:13 <Lemmih> But that wouldn't work with --make!
01:13:21 <kosmikus> why not?
01:14:42 <Lemmih> Because you don't know the dependencies of the compiled module.
01:15:11 <Lemmih> *of the module which is to be compiled.
01:15:27 <kosmikus> I don't understand
01:15:30 <kosmikus> of course you do
01:15:35 <Lemmih> You do?
01:16:10 <kosmikus> let me just try if it works ;)
01:16:19 <kosmikus> I only use it with ghci usually, and that works
01:16:20 <Lemmih> Without calling ghc -M  first?
01:16:27 <kosmikus> so I would be surprised if --make doesn't
01:16:57 <Lemmih> Try a hsc and greencard file.
01:20:16 <kolmodin> when do you prefer ghc -M over ghc --make?
01:21:01 <Lemmih> You don't. You just use Cabal instead.
01:21:37 <kolmodin> even if i'm building just an application, not a package?
01:22:18 <Lemmih> Sure. Cabal = Common Architecture for Building Applications and Libraries.
01:22:39 <kolmodin> ah... neat.. :)
01:22:49 <kosmikus> Lemmih: I never said it'd work with hsc or greencard
01:23:19 <kosmikus> but it works fine with lhs2TeX
01:23:24 <Lemmih> oh (:
01:23:26 <kosmikus> and why shouldn't it? it works with cpp as well
01:24:15 <kosmikus> it works theoretically for anything which is strictly 1:1 (i.e., where the preprocessor doesn't change the dependencies), and if the unpreprocessed sourcefile is still named .hs and .lhs
01:26:17 * Lemmih changes his original statement to include "except for cpp and the likes".
01:29:35 <kosmikus> yeah, but the advantage is that it works transparently from within ghci
01:35:09 <kolmodin> kosmikus: there is no HaXml package to gentoo
01:35:34 <kolmodin> I submitted an ebuild to gentoo bugs and I have not recieved any feedback
01:35:48 * bringert would like a fedora HaXml package
01:35:57 * bringert should probably build one
01:36:39 <kolmodin> the ebuild has some limitation but it works... at least for ghc
01:36:57 <kolmodin> only tested with ghc 6.2.2, though..
01:49:36 <kosmikus> kolmodin: true, I've seen it, but haven't added it yet
01:49:53 <kosmikus> kolmodin: we're a bit reluctant adding non-ghc-6.4-conformant packages at the moment
01:50:24 <kolmodin> ok
01:50:29 <kosmikus> kolmodin: but I should have given some feedback
01:50:36 <kosmikus> sorry for that
01:50:39 <kosmikus> and thanks for the ebuild
01:51:29 <kolmodin> np, I needed it so I had to write it myself
01:52:03 <kolmodin> it's available through the bug page if anyone else needs it
01:52:13 <kosmikus> it's good that you remind me, though
01:53:00 <kolmodin> there is a .cabal-file for HaXml in the fptools cvs
01:53:47 <kolmodin> it's probably better than my ebuild if you can run cabal
01:54:17 <kolmodin> since it most likely works for hugs and nhc aswell
01:56:17 <kosmikus> where's this file?
01:56:27 <kolmodin>  [Haskell Repository] / fptools / libraries / HaXml
01:56:34 <kolmodin> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/HaXml/
01:56:35 <kosmikus> yes, just found it
01:59:59 <nlv11757_>  ow i forgot about my question, let me go back and read the answer :p
02:31:48 <lightstep> what is fptools/libraries/monads ?
02:32:31 <lightstep> my local ghc6.4 docs don't list it as a package
02:33:03 <lightstep> and neither does ghc itself
02:35:08 <Lemmih> Perhaps it's made obsolete by mtl.
02:36:40 <lightstep> it's the other way around: mtl is more than a year old, monads is new
02:36:53 <lightstep> and no explanation is given in the readme
02:37:34 <Lemmih> Installing both shouldn't be a problem.
02:38:32 <lightstep> ofcourse. but now the monads are in base, mtl and monads, which misses the point, since you need a standartized libreary to benefit from monads
02:50:07 <xerox> 'morning
02:54:31 <Muad_Dibber> hi
02:55:46 <Itkovian> hi
03:11:00 <Lemmih> Learning haskell, karingo?
03:20:13 <nlv11757_> this maybe an awkward question, but is 'deriving' lazy ? Does it only derive an instance if I actually use the instance?
03:21:03 <ibid> laziness in the usual haskell sense does not make sense for deriving
03:21:25 <ibid> i believe, thouhg, that the compiler generates the instance code in any case
03:21:51 <ibid> (it may be possible to detect it as dead code and eliminate it. can't say if that's actually done by any haskell compiler)
03:22:05 <dons> deriving  means "generate some functions for me". it happens at compile time.
03:22:43 <nlv11757_> does it take long to derive an instance of Show for example for a large datatype?
03:22:54 <nlv11757_> or not mentionable
03:23:01 <dons> take long? it can sometimes for unusual data types.
03:23:04 <ibid> nlv11757_: why are you interested?
03:23:51 <nlv11757_> im deriving Show, Read and Eq instances for my datatype, which represents the AST of a C application. So, since it is quite large, im wondering if the deriving takes up most of the time in my test application
03:24:25 <dons> no, it happens when you compile the program, not at runtime
03:24:33 <ibid> nlv11757_: it takes no time at run time
03:24:50 <ibid> (except in hugs, possibly:)
03:25:32 <nlv11757_> hehe not using hugs
03:25:46 <dons> ibid: ooh. interesting. but I don't think the evaluator hooks back in to the code generator
03:25:48 <nlv11757_> ok then probably using the derived read takes up a sh*tload of time
03:26:17 <Igloo> http://www.haskell.org/ghc/docs/latest/html/users_guide/sooner-faster-quicker.html says "Don't derive/use Read unnecessarily: It's ugly and slow." but I always assumed actually deriving it had negligible effect (presumably it might have some in cases where the dictionary needs to be passed around)
03:26:43 <ibid> derive => ugly, use => slow? :)
03:27:09 <nlv11757_> writing a parser for a C AST takes up much much MUCH more time then simply using read in my case
03:27:23 <ibid> Igloo: i don't think deriving generates dictionary passing, that happens if your functions are polymorphic with Read constraint
03:28:31 <nlv11757_> if there are no constraints with Read classes, no use passing dictionaries for it as I see it
03:28:57 <ibid> there is no need, even
03:29:56 <ibid> either one is monomorphically using a type that has a Read instance, in which case any calls to Read's methods can be resolved statically, or not, in which case any calls to its methods are type errors
03:30:03 <Igloo> That's what I'd have guessed, but I don't actually know how the implementation works
03:30:10 * ibid neither
03:30:13 <ibid> but that makes sense :)
03:30:43 <Igloo> It just always seemed an odd way of saying it to me
03:32:26 <ibid> hm?
03:32:32 <ibid> what seemed an idd way of saying what?
03:32:44 <ibid> ah, the sooner-faster thing?
03:32:56 <ibid> deriving it probably bloats code
03:34:29 <dons> it does very much bloat code
03:34:41 <dons> for small programs, anyway
03:34:51 <dons> big programs wouldn't notice the difference
03:40:05 <Igloo> Oh, true. For some reason I hadn't noticed which section it was in
03:45:44 <metaperl> autrijus told me one of the virtues of Haskell (compared to Perl) was the ability to abstract anything... however, without Template Haskell, I dont think the guards of a list comprehension can be abstracted
03:46:00 <metaperl> @eval [1..10]
03:46:01 <lambdabot> (line 1, column 4):
03:46:01 <lambdabot> unexpected "."
03:46:01 <lambdabot> expecting simple term
03:46:17 <metaperl> for example
03:46:32 <metaperl> [ c | c <- word, c /= 'r' ]
03:46:57 <metaperl> the guard c /= 'r' cannot be abstracted into a definition... actually I suppose it could
03:47:15 <dons> abstracted into a definition? in what sense?
03:47:27 <ibid> well, list comprehension is irrelevant, anyway ;)
03:47:32 <vegai> [ c | c <- word, abstractThingie c ] ?
03:47:40 <metaperl> [ c | c <- word, guard_filter('r') ]
03:47:56 <metaperl> guard_filter r = r /= 'r'
03:47:58 <autrijus> point-free is that abstraction.
03:48:04 <metaperl> guard_filter c = c /= 'r'
03:48:15 <autrijus> if you are already using the longhand that is list comprehension
03:48:24 <autrijus> you don't get to use abstractions, of course :)
03:48:47 <autrijus> filter (guard 'r') word
03:49:11 <metaperl> yes, rewriting it use filter allows you to abstract the process
03:54:11 <metaperl> @eval 6
03:54:11 <lambdabot> 6
03:54:24 <autrijus> @eval 6 * 7
03:54:24 <lambdabot> 42
03:54:44 <metaperl> @eval zipWith (++) ["hi", "how are you"]  ["fee" , "fi fo fum"]
03:54:44 <lambdabot> (line 1, column 10):
03:54:44 <lambdabot> unexpected "+"
03:54:44 <lambdabot> expecting simple term
03:54:48 <Lemmih> @eval is not a Haskell evaluator.
03:54:49 <lambdabot> (line 1, column 28):
03:54:49 <lambdabot> unexpected end of input
03:54:49 <lambdabot> expecting simple term
03:54:58 <metaperl> @eval zipWith (++)  ["hi", "how are you"]  ["fee" , "fi fo fum"]
03:54:58 <lambdabot> (line 1, column 10):
03:54:58 <lambdabot> unexpected "+"
03:54:58 <lambdabot> expecting simple term
03:55:11 * metaperl heads to ghci
03:55:53 <dons> we need @plugs!
03:56:31 <dons> 21:56 dons:: @plugs zipWith (++)  ["hi", "how are you"]  ["fee" , "fi fo fum"]
03:56:31 <dons> 21:56 \bot:: ["hifee","how are youfi fo fum"]
03:56:45 * shapr is awake!
03:56:55 <shapr> is plugs IO safe?
03:56:55 <dons> hey shapr!
03:57:00 <dons> yeah
03:57:00 <Lemmih> dons: Can't we got your lambdabot in Haskell?
03:57:01 <xerox> yo shapr!
03:57:06 <shapr> y0 xerox
03:57:15 <dons> Lemmih will have to say that again
03:57:26 <dons> s/got/get/?
03:57:29 <Lemmih> dons: Can't we get your lambdabot in Haskell?
03:57:43 <dons> it's just some extra modules for lambdabot
03:57:52 <dons> \bot == lambdabot ++ dons' modules
03:58:10 <Lemmih> Why don't you push them to the lambdabot repo then?
03:58:21 <dons> I will!
03:58:31 <shapr> I have some/all of dons patches.
03:58:50 <shapr> Sadly, lambdabot is a bit forked up.
03:59:12 <_JusSx_> where is lambdabot?
03:59:16 <dons> oh well.
03:59:23 <Lemmih> @seen lambdabot
03:59:23 <dons> share the code!
03:59:23 <lambdabot> Yes, I'm here
03:59:28 <shapr> lambdabot is hiding in Sweden!
03:59:33 <_JusSx_> ok i mean the code
03:59:34 <Lemmih> _JusSx_: He's here (:
04:00:19 <dons> what i'll do is reget shapr's lambdabot, merge in some dons-bot modules, and give shapr back some nice darcsy pathces
04:00:37 <shapr> or we could skip to your lambdabot, that's fine with me.
04:00:52 <shapr> Yours uses hs-plugins already, I assume?
04:01:14 <dons> yeah, but hacked arbitrarily into lambdabot :}
04:01:27 <shapr> that was pretty much my plan too.
04:01:28 <dons> some much to do, so little time
04:01:41 * dons is tired
04:01:43 <shapr> great, we'll call it lambdabot2 or something.
04:01:51 <shapr> Do you have a darcs repo?
04:02:00 <astrolabe> mubot?
04:02:16 <dons> ok. i'm happy to set it up along side my yi repo and other misc code
04:02:24 <shapr> aubot?
04:02:37 <shapr> lambdaubot?
04:02:40 <dons> well lambdabot was originally an aubot, right?
04:02:46 <_JusSx_> so where can i find the code?
04:02:47 <shapr> truly.
04:02:54 <xerox> unlambdabot
04:03:09 <Igloo> dons: Does @plugs deal with non-termination?
04:03:14 <dons> yes :)
04:03:23 * shapr fires lambdabot 
04:03:23 <astrolabe> I've got to go to work  :(
04:03:35 <shapr> @quit you've been fired
04:03:37 <xerox> Byebye channel enforcer.
04:03:53 <Igloo> dons: Even let loop () = loop () in loop ()  ?
04:04:27 <dons> it's running in an external process with limits set, so I imagine it will work. let's see..
04:04:29 <shapr> rik: written any code?
04:04:55 <Igloo> Oh, if you're doing that it's probably easy
04:05:12 <dons> yeah.
04:05:23 <_JusSx_> so where can i download the source code of that bot?
04:05:28 <Igloo> It's with threads we couldn't find a way to do it
04:05:38 <dons> yep.
04:05:48 <dons> Heffalump found the killer case
04:06:08 <Igloo> Yeah - essentially the above I think
04:06:31 <dons> 22:04 dons:: @plugs let loop () = loop () in loop ()
04:06:31 <dons> 22:05 \bot:: /tmp/MrOiQ30387.hs:1:
04:06:31 <dons> 22:05 \bot::     Ambiguous type variable `a' in the top-level constraint:
04:06:31 <dons> 22:05 \bot::       `Show a' arising from use of `show' at <Plugins.Eval>:1
04:06:36 <shapr> dons: can you put up a darcs repo or send me the source so I can put one on ScannedInAvian?
04:07:13 <Si\> dons: How is hs-plugin on GHC 6.4?
04:07:22 <dons> Si\: done and done!
04:07:23 <Itkovian> is the record selection stuff (e.g. data R = RR { i::T1, j::T2} and thus the i function on a R type thingie) not working in Hugd?
04:07:27 <Itkovian> Hugs ...
04:07:37 <dons> shapr: yes. I'll stick one up.
04:07:46 <shapr> spiffy
04:07:48 <Igloo> Oh, it would make sense to use the ghci defaulting magic if possible
04:08:06 <dons> usually plugs times out like so:
04:08:07 <dons> 22:06 dons:: @plugs last [ 0 .. ]
04:08:08 <dons> 22:07 \bot:: bzzt
04:09:15 <Si\> is there a snapshot for it?
04:09:26 <dons> last night's snapshot should be fine
04:09:34 <_JusSx_> so where can i find the code?
04:09:37 <Si\> must appreciated, thankyou!
04:09:57 <shapr> _JusSx_: dons said he'll put up a repo
04:10:01 <shapr> soon
04:10:06 <_JusSx_> ohhh
04:10:08 <_JusSx_> great
04:10:12 <_JusSx_> when?
04:10:18 <dons> tomorrow .au time
04:10:21 <Si\> how well does it mix with GHCs internal Typeable and Data?
04:10:21 <_JusSx_> ok
04:11:12 <dons> internal Typeable is broken wrt. dynamic linking as identical types get different Typeable keys in dynamic and static code
04:11:21 <dons> so hs-plugins provides it's own Typeable
04:11:31 <dons> I haven't hacked up the real fix yet.
04:11:41 <dons> Data i don't know, but probably works fine.
04:12:00 <Si\> ok, well it doesn't matter so much with Data as it's being rewritten anyway
04:12:18 <dons> so instead of Data.Typeable, use AltData.Typeable, and hand-derive instances for now.
04:12:41 <dons> you planning something?
04:13:45 <autrijus> hrm. TH1 backcompat is really not worth it
04:14:04 <dons> back to 6.2.2?
04:14:40 <autrijus> I need probably to switch Pugs over to TH2 and GADT and Cabal.
04:14:44 <Si\> wrt to Data, Ralf's rewritten created a two parameter version so as to allow context customization. wrt to hs-plugin, I'm hoping to use it to write a Haskell evaluator web-service, if not I'll have to use ghc -e
04:14:52 <autrijus> and just drop 6.2.2 support.
04:15:24 <autrijus> GADT+TH2 simplified writing compilers a lot.
04:15:41 <dons> Si\: there's been a few web-service haskell evaluator type projects. so it's definitely possible with hs-plugins
04:15:51 <dons> autrijus: really? how so?
04:16:49 <Si\> yeah, it's got to be function type-centric and it's got to be able to work across and extensible module hiearchy, reflecting XML Schemata
04:17:57 <dons> Si\: peter thiemann hacked up a script evaluator for WASH in a day or 2, which is encouraging.
04:18:19 <autrijus> dons: so I'm writing this parrot IMC compiler
04:18:21 <Si\> Can hs-plugin do type-inference (I can't remember)
04:18:33 <Si\> in eval expressions I mean
04:19:17 <dons> the expressions are compiled by ghc, so they get ghc's type inference
04:19:54 <autrijus> IMC registers are typed, and most OPs only makes sense to some of the types
04:20:25 <dons> autrijus: ok. so GADTs help out there
04:20:33 <autrijus> yup.
04:20:43 <xerox> What is GADT?
04:20:45 <autrijus> now I'm compiling it to haskell
04:21:00 <autrijus> and I want the resulting haskell to Just Run
04:21:13 <autrijus> run program = $( compile [| program |] )
04:21:27 <autrijus> and I found more and more that $(dyn x) is very helpful.
04:21:31 <lightstep> xerox, http://research.microsoft.com/Users/simonpj/papers/gadt/gadt.ps.gz
04:21:42 <shapr> hiya lightstep, how's code?
04:21:49 <autrijus> I will probably make more sense once I checked in the cod e:)
04:22:28 <lightstep> code waits. i'm missing global variables a lot. the only solution i see is StateT ... IO a
04:22:31 <xerox> Generalized algebraic data types, I see.
04:22:52 <autrijus> lightstep: wrong, ReaderT ... IO a
04:23:03 <autrijus> err, forget what I said.
04:23:03 <dons> autrijus: very cool. i'll have to think about this some more. i have a couple of small compilers around that generate Haskell
04:23:08 <autrijus> we had this talk before.
04:23:20 <autrijus> sorry. :)
04:23:59 <dons> IORefs ?
04:24:13 <autrijus> you can use ReaderT + IORefs
04:24:29 <dons> yeah, or just  IO and IORefs ;)
04:24:31 <lightstep> i want them to be global - accessible from everywhere
04:24:54 <autrijus> that's where ReaderT comes in :)
04:24:57 <lightstep> as in ungetc
04:25:05 <autrijus> with ReaderT you don't need to carry the refs around.
04:25:13 <dons> state :: MVar (IORef Editor)
04:25:31 <dons> state = unsafePerformIO $ do
04:25:31 <dons>             ref  <- newIORef emptyEditor
04:25:31 <dons>             newMVar ref
04:25:32 <dons> {-# NOINLINE state #-}
04:25:48 <dons> is a politically incorrect solution
04:25:49 <autrijus> yay for noinline ;)
04:26:27 <dons> yeah :)
04:26:47 <lightstep> i don't like these pragmas. but i also don't like global variables. eventually, i'll figure out a way to get rid of them, but i'm not thinking purely enough yet
04:27:11 <dons> the monadic ways are the cleanest
04:27:33 <dons> maybe you don't need true global vars
04:28:33 <lightstep> you never really want the fully general case
04:29:11 <lightstep> you only want the usage patterns relevant to your program, so reader is better than state is better than io
04:29:20 <lightstep> i just need to figure out where i want to be in that scale
04:29:46 <dons> yep.
04:30:44 * dons -> sleeps
04:38:54 <vegai> so, umm
04:39:08 <shapr> yeah?
04:39:36 <shapr> how do I unhide a package with ghc-pkg?
04:39:46 <shapr> vegai: it's the revolution!
04:40:22 <Igloo> expose, IIRC
04:40:29 * shapr tries that
04:40:46 <metaperl> shapr, would you like to join the extremeperl mailing list?
04:41:12 <metaperl> it's not my list but the guy that runs it writes Perl in a very Haskell-ish way even though he doesnt realize it
04:41:17 <shapr> um. sure.
04:41:45 <metaperl> he developed an OLTP system for Perl called Bivio bOP that is strongly typed: http://www.bivio.biz/hm/download-bOP
04:42:04 <vegai> yeah, I thought I had a problem with parsec, but...
04:42:17 <vegai> ...it turned out that parsec had a problem with me
04:42:23 <metaperl> also, he was wondering about Haskell and databases since his serious problems all involve databases and he read teh Haskell wiki on it as his first impression: http://www.haskell.org/hawiki/HaskellDbTutorial
04:43:15 <shapr> Hey, I wrote the first version of that.
04:43:16 <metaperl> his free book on Extreme Perl is available online: http://www.extremeperl.org/bk/home
04:43:27 <metaperl> and the link to the mailing list is there
04:43:59 <metaperl> after you join the mailing list, you can see his latest query about Haskell and databases which I think you are in a better position to answer
04:44:31 <shapr> Wow, he does TDD.
04:44:36 <metaperl> TDD?
04:44:40 <vegai> the emacs haskell mode doesn't seem to be very clever with do expressions
04:44:41 <shapr> I like this guy already.
04:44:48 <metaperl> :)
04:45:02 <shapr> Extreme Perl is about Extreme Programming!
04:45:03 * shapr boings
04:45:45 <Itkovian> dumb question: how do I do this: map (- 1) [1,2,3,4]
04:46:12 <metaperl> can I get the link to that humasect page which compares Perl cookbook solutions with other languages
04:47:52 <Itkovian> map (flip (-)  1) [1,2,3]
04:47:54 <Itkovian> duh
04:48:26 <xerox> Itkovian: mpa (subtract 1) I think
04:48:31 <xerox> map even.
04:51:51 <shapr> metaperl: yeah, I think I can usefully respond to his question.
04:52:03 <metaperl> ok great
04:57:51 <xerox> mydata = [1 .. 10] -- a list of integers from 1 to 10
04:57:52 <xerox> myfun1 = (-1 * ) -- a function which multiplies an integer by -1
04:57:56 <xerox> then because we can only return data and never overwrite our original:
04:57:57 <xerox> mydata >>= myfun1 -- yields [0..10]
04:58:11 <xerox> (from an email on that ml, it doesn't work for me.. ?)
05:00:38 <shapr> metaperl: I wrote that "unwraps" quote, but at the moment I'm not sure how to explain it well.
05:02:31 <xerox> Does it make sense to you??
05:03:08 <metaperl> hmm, I wrote that wihtout testing
05:03:10 <Lemmih> myfun1 = return . ((-1) *) ?
05:03:21 <shapr> metaperl: stupid question, can you create new operators with limited semantics in Perl? Is there some way to generate always correct SQL from made-up database operators in Perl?
05:03:41 <xerox> Lemmih: oh yes. Thank you.
05:03:43 <metaperl> hmmm I've never seen that done
05:03:56 <metaperl> shapr: you might ask in Perl6 really quick
05:04:01 <shapr> ok
05:04:08 <metaperl> oh, there is Rosetta
05:04:19 <metaperl> it does something vaguely akin to that
05:04:23 * metaperl digs up link
05:04:33 <metaperl> but it does it with oop
05:04:47 <metaperl> http://search.cpan.org/~duncand/Rosetta-0.42/lib/Rosetta.pm
05:05:19 <metaperl> oh and we have plenty of DBI wrappers that take associative arrays and generate SQL from them --- SQL::Abstract, DBIx::Recordset, Class::DBI
05:05:24 <metaperl> DBIx::SQLEngine
05:05:29 <metaperl> etc, etc
05:05:50 <metaperl> eg, my %search = (user => 'bob', age => 25) ;
05:06:14 <shapr> That fills values into a SQL template, right?
05:06:46 <metaperl> oh no
05:06:51 <metaperl> it generates sql
05:07:07 <shapr> That sounds closer to HaskellDB.
05:07:09 <metaperl> my %search = ('!Table' => 'users', id => 12) ;
05:07:15 <metaperl> SELECT * FROM users WHERE id == 12;
05:07:26 <metaperl> my %search = ('!Table' => 'users', id => 12, '*id' = '>') ;
05:07:31 <metaperl> SELECT * FROM users WHERE id > 12;
05:07:39 <shapr> Can you parameterize those queries with arbitrary conditions?
05:08:02 <shapr> I think I see.
05:08:03 <metaperl> i'm not sure what you mean
05:08:58 <shapr> HaskellDB is a 'set theory' language embedded into Haskell, and it maps those set operations into SQL behind the scenes.
05:09:50 <metaperl> the thing that people are wild about in Perl is Class::DBI - http://search.cpan.org/~tmtm/Class-DBI-0.96/lib/Class/DBI.pm
05:09:59 <metaperl> the SYNOPSIS gives an overview of how it works
05:10:07 <shapr> SQL is actually just one layer of indirection for databases, you don't operate directly in database theory land with SQL.
05:10:42 <shapr> With the set theory stuff in HaskellDB, you do operate directly in database theory land, and SQL is the trade pidgin :-)
05:11:16 <metaperl> yes, but oftentimes you need to format a database column type using vendor-specific calls, like extracting the day from a datetime field
05:12:01 <shapr> Which is why HaskellDB allows users to define custom operators.
05:12:15 <metaperl> there's nothing set-theoretical about that is there? or taking a substring of a VARCHAR field
05:12:49 <shapr> Nope, nothing to do with set theory there.
05:13:27 <shapr> Only the part that's expressed with SQL that applies to tables and fields is set theory stuff.
05:14:33 <metaperl> yes, for speed you want lots of non set-theoretic things done server side
05:14:43 <metaperl> taking advantage of caching possibly
05:15:33 <shapr> But for flexibility, the set theory stuff can be cast to SQL, OODBs, in-memory or on-disk databases, Reiser, etc
05:16:07 <shapr> I'm not sure about set theory to OODB actually.
05:16:31 <shapr> Probably not now that I think about it.
05:18:02 * shapr copies this conversation into his reply
05:18:12 <shapr> irc is great for working out ideas.
05:18:39 <shapr> It's like writing interactive essays during a live fire exercise.
05:21:15 * metaperl takes an early morning nap
05:21:17 <shapr> Ah yes, wikipedia says the relational model is not the same as the OODB model.
05:24:16 <jlouis> ... a question on sleazy evaluation ;)
05:29:51 <earthy> sleazy evaluation, is that `go on and on until you feel dirty, then stop'? :)
05:30:10 <earthy> or, rather `go on as long as you feel nice and dirty, otherwise stop'? :)
05:31:03 <Itkovian> brb
05:49:40 <Spark> shapr: at warwick there was some in house software to teach relational database theory
05:49:51 <Spark> it was a special syntax with operators that were more sane than the sql stuff
05:52:24 <Spark> things like join and stuff were more functional : Table * Table -> Table
05:52:46 <Spark> long time ago now though :)
05:52:54 <shapr> Yeah, that's how HaskellDB works.
05:53:11 <Spark> there was a featuer to convert to sql and back again :)
05:53:19 <Spark> and watch the concrete syntax shrink to about 10%
05:53:37 <shapr> create the 'real' ops, then let you use those ops on the 'real' database tables, and export the result to SQL that the backend can execute.
05:54:01 <Spark> mm
05:54:09 <Spark> and you wonder why it wasnt done like that in the first place
05:54:42 <shapr> Because they weren't able to do that in 1971?
05:54:53 <shapr> Isn't that when System R happened?
05:55:21 <shapr> In the 1970s - http://www.mcjones.org/System_R/
05:55:40 <shapr> SQL is shockingly sane for being 30 years old.
05:55:42 <vegai> i.e. guesses wrong
05:55:45 <vegai> oopsie
05:58:20 <xerox> Is there a "GHC api"? Is it possible to do in a program what :info does in the GHCi prompt?
05:58:43 <shapr> Simon Marlow is working on that.
05:59:06 <Spark> heh is it really 30 years old
05:59:17 <Spark> thats like, before programmers existed
05:59:27 <shapr> hey, I'm 33.
05:59:33 * shapr beats Spark with his cane
05:59:49 <shapr> back in my day we had to code uphill both ways! through the SNOW!
05:59:50 <xerox> shapr: any code/link?
05:59:52 <Spark> blimey thats older than my older brother
06:00:31 <shapr> xerox: ask google, ghc-api or "ghc api"
06:02:19 <Igloo> 6.4 has a ghc package disabled by default, I think
06:03:04 <xerox> In fact I was thinking about having some link from the module documentation to the module implementation.
06:04:33 <xerox> Two possibilities: get comfortable with explanations and type declarations, or try making this link. The latter would regard hacking the Haddok package I think.
06:05:01 <shapr> Haddock isn't too difficult to hack.
06:06:42 <xerox> Haddock, whoops.
06:09:01 <TheHunter> xerox, http://www.haskell.org/pipermail/glasgow-haskell-users/2005-March/008028.html
06:10:09 <xerox> So other people had that feeling.. but if *they* say it's difficult..
06:12:43 <TheHunter> @index map
06:12:51 <TheHunter> @find map
06:12:57 <shapr> he's gone...
06:13:00 <shapr> lambdabot was fired.
06:13:16 <shapr> We've hired a replacement, and he'll be in tomorrow.
06:13:16 <TheHunter> will he come back?
06:13:37 <shapr> Ok, I'll bring back lambdabot until tomorrow.
06:13:48 <TheHunter> does the replacement run under ghc-6.4?
06:14:06 <shapr> The replacement uses hs-plugins.
06:14:10 <shapr> and has @plugs
06:14:26 <TheHunter> is there a darcs repo?
06:14:35 <shapr> There will be tomorrow.
06:14:45 <TheHunter> Yay!
06:15:04 <shapr> My thoughts exactly.
06:15:48 <xerox> Do you guys play Chess/Go/.. ?
06:18:24 <wilx> I used to play Go but I would have to play much more to be any good so I stoped :)
06:19:02 <xerox> There are some internet Go servers :)
06:20:20 <shapr> I tried to get good at Chess for years, but instead I continued to suck. So I thought I'd do something else.
06:20:30 <shapr> I'd like to try Go
06:21:17 <xerox> shapr: when you have some free time I can teach you the basic rules sometime.
06:21:35 <xerox> ..no more than 3 rules, by the way ;)
06:25:45 <xerox> I mean, the rules are *really* simple.  The game complexity tends to oo.  More or less like Conway's game of life :)
06:26:05 <earthy> hm.
06:26:06 <xerox> s/tends to/approaches/ ^_^
06:26:28 <earthy> ISTR remembering the `just 3 rules' is slightly hard...
06:26:41 <xerox> What does ISTR mean?
06:26:46 <earthy> I seem to recall
06:26:58 <earthy> install the useful `wtf' tool. :)
06:27:58 <xerox> The rules are mainly about how to capture stones (the round pieces used in the game), and how does some situation are handled.
06:29:39 <jlouis> oy sqrt
06:30:12 <sqrt> :)
06:30:37 <xerox> http://senseis.xmp.net/ Is a good source about Go. I suggest: http://senseis.xmp.net/?BeginnerStudySection
06:39:04 <araujo> what what?, who plays go here? 8)
06:40:39 <jlouis> hehe
06:41:27 * xerox raises his hand
06:42:42 <araujo> yeah, how much your kyu?
06:45:47 <xerox> I used to be an 8k.  Then I stopped for a while and now I'm 11k on KGS.
06:46:57 <araujo> Nice 8)
06:47:09 <xerox> What about you?
06:47:21 <xerox> (It's not so nice, I did like being one-digit-kyu ;)
06:47:56 <araujo> I haven't go further than 8 kyu 8-(
06:48:10 <araujo> well, i got 26k once
06:48:20 <araujo> with a dumb bot 8)
06:49:19 <eixei> wouldn't 26k be pretty bad compared to 8k?
06:49:28 * eixei isn't sure he understood this correctly
06:49:38 <araujo> :-P
06:49:49 <xerox> eixei: yep :)
06:49:55 <eixei> yay :-)
06:50:22 <xerox> I restarted playing for a week, because of easter holidays :) I stopped for months.
06:50:32 <eixei> I might not be able to play go, but at least I understand the kyu/dan system *g*
06:52:23 * xerox opens an Haskell room on KGS ;)
06:54:05 <araujo> haha
06:55:28 <xerox> <spam> "Haskellers", if anyone wants to come. http://kgs.kiseido.com/ </spam>
06:58:00 <nlv11757_> is Go more fun than Chess, and why?
06:58:37 <xerox> nlv11757_: because computers cannot play Go well! yay :D
06:59:03 <sqrt> maybe go contains less things you have to know by heart? i don't know.
06:59:33 <xerox> sqrt: this is the place to start, what's next is the interesting part, the actual complexity of the game.
07:00:16 <sqrt> xerox: math is complex too and also has little things one has to know by heart.
07:00:49 <sqrt> so that is perhaps why people who prefer go to chess prefer math to... perl for example.
07:00:56 <sorje> There are tons of things to know by heart in math
07:00:56 <ferz> Hi
07:01:18 <xerox> sqrt: agreeable, I think. Do you play Go?
07:01:22 <sqrt> sorje: the definitions?
07:01:29 <sqrt> xerox: ;)
07:01:30 <sorje> yeah
07:02:08 <sqrt> there are things to know by heart in go too, sorje. just in an other balance, perhaps, than chess.
07:02:53 <xerox> Oh yes, you can pass lifetime learning joseki/fuseki/terminology :)
07:03:00 <sorje> sure
07:03:43 <xerox> I like the feeling in applying what you learn from games to games.
07:06:52 <nlv11757_> xerox: i think it's an advantage that computers play chess well, that way i don't always rely on human players
07:24:34 <shapr> g'day kunal
07:24:52 <shapr> Looking for Haskell info?
07:25:05 <kunal> Hey ..
07:25:23 <kunal> i din see you online ?
07:25:38 <shapr> You didn't?
07:26:06 <shapr> Were you looking for me?
07:27:00 <shapr> How can we assist you?
07:27:58 <Lemmih> I'm _so_ uninspired today /-:
07:28:14 * shapr inspires Lemmih with a lambda of DOOM!
07:28:49 <shapr> Right, this calls for RC Cola shopping.
07:29:55 * xerox is hungry
07:31:47 * shapr is thirsty
07:31:48 <shapr> time for COLA!
07:32:44 <vegai> hmm
07:32:54 * vegai made his first piece with parsec 
07:33:01 * esap drinks all too much cola.
07:35:57 * Oeje1 prefers Jolly Cola.
07:36:24 * esap doesn't think it's possible to get that in Finland.
07:36:33 * xerox doesn't/can't drink caffeine :(
07:41:06 * vegai also made his first $$$-related piece in Haskell
07:41:46 <wilx> Can't?
07:41:52 <Oeje1> esap: Jolly Cola was initiated in 1959 by some Danish breweries.  Rather local enterprise.
07:42:16 * amb_ loves Africola
07:42:22 <esap> Oeje1: ah ok, that explains why I haven't heard about it.
07:43:34 * Oeje1 envies vegai, and steals his Haskell piece to sell it for $$$'s on the black software market.
07:44:13 <vegai> it was just a stupid parser :)
07:44:26 <vegai> I would've made the same thing in python in 1/4th the time, probably...
07:45:58 <Oeje1> Did you parse anything interesting?
07:47:39 <vegai> nope
07:49:07 <metaperl> if a list is of type Integer, but a function receives an argument of type Int, how do I convert the Int to an Integer?
07:49:08 <metaperl> trans4 :: Integer -> [Char]
07:49:08 <metaperl> trans4 x = replicate x 'a'
07:49:21 <metaperl> mydat = [1 .. 10]
07:49:28 <metaperl> I want to do mydat >>= trans4
07:49:30 <Igloo> fromIntegral
07:49:33 <metaperl> but it wont work
07:49:48 <Igloo> Or genericReplicate
07:50:11 <Lemmih> unsafeCoerce# (:
07:50:16 <metaperl> fromIntegral produces a num
07:50:20 <metaperl> @type fromIntegral
07:50:24 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
07:50:27 <metaperl> not an Int
07:50:53 <Lemmih> Int is an instance of Num.
07:56:04 <xerox> And is also an instance of Integral :)
09:00:48 <sylvan> fromIntegral will take any Integral value and convert it to a numeric value, the context will decide which type the numeric value will have
09:01:10 <rik> shapr: nope. not yet
09:01:19 <sylvan> so fromIntegral used in a context which makes it clear it should convert to Int will convert an intergral value to an Int
09:49:15 <jlouis> sylvan: exactly
09:49:37 <jlouis> oh, you answered, my bad
09:52:37 <SyntaxNinja> morning
09:54:08 <Igloo> hiya
09:58:18 <SyntaxNinja> Igloo: how's it going?
09:59:00 <Igloo> I'm eating pizza; it could be worse
09:59:02 <Igloo> You?
10:01:08 <SyntaxNinja> drinking coffee; could be worse ;)
10:02:05 <SyntaxNinja> just found a bug yay!
10:05:52 <astrolabe> Make sure you splat it.  I don't want to find it in my code.
10:07:26 <SyntaxNinja> it might escape
10:09:48 <astrolabe> I spose one more won't hurt.
10:14:10 <SyntaxNinja> heh
10:14:42 <xerox> 'evening
10:14:56 <x3n0n> afternoon. :)
10:32:54 <Lemmih> Hey SyntaxNinja (:
10:33:40 <SyntaxNinja> heya Lemmih
10:33:41 <Lemmih> Was about to add proper support for several versions of the same package in Hackage but then my boss came.
10:33:49 <SyntaxNinja> bosses :(
10:54:55 <shapr> EXCITEMENT!
10:54:56 <shapr> w00!
10:55:01 <shapr> rik: soon?
10:55:20 <basti_> hi
10:55:50 <shapr> y0
10:56:58 <basti_> hows y0w?
10:57:37 <basti_> and what about that darcs repo?
10:57:37 <shapr> y0w!
10:57:57 <shapr> should be up in about four hours.
10:58:04 <basti_> o0
10:58:12 <basti_> im astonished that you know before
10:58:26 <SyntaxNinja> hey shapr
10:58:27 <shapr> That assumes you and I are discussing the same repo.
10:58:28 <SyntaxNinja> what's you talking about?!
10:58:33 <shapr> y0 SyntaxNinja
10:58:37 <basti_> i thought about that tmr article
10:58:42 <shapr> I's talkin bout lambdabot da revenge
10:58:44 <basti_> and how i could sync it with shapr
10:58:54 <shapr> basti_: yeah, I was purposefully misinterpreting.
10:59:05 <basti_> k
10:59:15 <basti_> but im still wondering that you know when it will be up
11:02:38 <shapr> Well, I don't really
11:02:43 <shapr> I'd rather use wikis in fact.
11:02:56 <basti_> so i should go html?
11:03:40 <shapr> Nah, LaTeX should work.
11:04:04 <basti_> and what will we do with it?
11:04:09 <basti_> html2latex?
11:04:30 <shapr> I dunon yet. I want to dump wiki output into ps somehow...
11:06:29 <basti_> hmmmoooh.
11:06:32 * basti_ shudders
11:07:00 <shapr> sounds painful?
11:08:05 <basti_> a bit
11:09:17 * CosmicRay wonders why !wiki HelpOnProcessors mentions a CSV processor, including a warning about the code, but no information whatsoever about where the code actually is...
11:09:22 <CosmicRay> !wiki HelpOnProcessors
11:09:40 <CosmicRay> @wiki HelpOnProcessors
11:09:41 <lambdabot> http://www.haskell.org/hawiki/HelpOnProcessors
11:09:51 <CosmicRay> to many different bots apparently
11:12:20 * CosmicRay is confused about the current state of discussion wrt what goes into sid and sarge on debian
11:12:48 <Igloo> Why are you confused?
11:13:09 <CosmicRay> is there any decision on what exactly is happening?
11:13:42 <xerox> shapr, tex2html is better than tex2ps, I think.. or do you know some *nice* ps viewer?
11:14:04 <xerox> Not counting that HTML can be hyperlinked..
11:14:18 <Igloo> I'm not putting ghc into sid (before sarge) until I'm confident it's going into sarge. That probably means until all the Haskell packages are working in haskell-unsafe
11:14:37 <CosmicRay> what about hugs then?
11:15:23 <Igloo> Not sure what Isaac plans. Is it actually stopping you get packages you want in sarge through?
11:15:43 <CosmicRay> well, I can't build them in sid
11:15:56 <Igloo> But have you got fixes you need to get through?
11:15:56 <CosmicRay> so I'd have to either upload to t-p-u or evil cpp hackery
11:16:13 <CosmicRay> nothing urgent
11:16:32 <CosmicRay> but then the same argument could be used to support putting ghc6.4 into sid
11:16:42 <SyntaxNinja> hunit is urgent; it has an RC bug
11:16:46 <Igloo> What same argument?
11:17:02 <Igloo> Putting ghc 6.4 in sarge would stop me getting things into sarge
11:17:06 <CosmicRay> Igloo: that t-p-u isn't much of a pain if there aren't important fixes to get into sarge
11:17:20 <CosmicRay> SyntaxNinja: I fixed that yesterday and it doesn't conflict with the newer hugs anyway
11:17:29 <Igloo> t-p-u isn't a pain if you don't need to get things into sarge as you don't need to use it
11:18:03 <CosmicRay> oh, what are you warking on that's pending getting into sarge?
11:18:39 <Igloo> Did nhc98 earlier today. Still need to do hat, and a newer and less buggy ghc-cvs would be nice too
11:18:59 <SyntaxNinja> CosmicRay: oh, good.
11:19:03 <CosmicRay> ah, a ghc-cvs that's not older than ghc6.4? :-)
11:19:20 <SyntaxNinja> CosmicRay: there are RC bugs against hat at least and maybe nhc98?
11:19:35 * Igloo doesn't really see the relevance, but yes
11:20:15 <CosmicRay> SyntaxNinja: I don't see any RC bugs against either of those
11:20:17 <Igloo> All the RC bugs should be fixed now
11:20:29 <CosmicRay> and regarding #184693, don't the nhc98 people specifically say that they don't support 64-bit platforms?
11:20:35 <Igloo> Yes
11:20:41 <CosmicRay> that's the basis for my general "nhc98 sucks" position, anyway :-)
11:20:49 <SyntaxNinja> I guess I'm wrong
11:21:13 <SyntaxNinja> steve l mentioned those two packages to me day before yesterday
11:21:29 <Igloo> I'm hoping it'll get fixed when York get some amd64 machines at some point  :-)
11:21:51 <Igloo> They did have RC bugs, but they're now fixed
11:22:14 <CosmicRay> ok, so if nobody has critical changes they need to get into sarge, why is t-p-u even an issue?
11:22:17 * Igloo wonders why he mentioned them to you
11:22:57 <SyntaxNinja> Igloo: we were talking about stuff we could hack on together, since he lives in the same town as me
11:23:03 <Igloo> Because I have non-RC things to fix
11:23:05 <SyntaxNinja> we're having sushi today, actually :)
11:23:30 <Igloo> Oh, OK, I was very confused about where he lives then
11:23:42 <CosmicRay> Igloo: that depend on ghc6.2 but not an old hugs?
11:23:48 <Igloo> Yes
11:25:05 <Heffalump> what things does the new hugs break, OOI?
11:25:15 <Heffalump> is it just library rearrangements?
11:25:23 <CosmicRay> yes, it's all related to the library
11:25:26 <shapr> Bear hugs break bones!
11:25:36 <Igloo> new {hugs,ghc,nhc98} change a few things, like order of arguments to openFd or something
11:25:43 <CosmicRay> also the occasional I/O breakage, but that can be fixed in a compatible way
11:26:02 <Igloo> New hugs also uses the locale for talking to the outside world whereas everything else pretends it's latin-1
11:26:24 <Igloo> CosmicRay: eh?
11:26:41 <CosmicRay> here's one example: I have some code that makes FiniteMap an instance of show, and relies upon that.  New library has instance show FiniteMap itself.  Remove my own definition and it breaks with old lib.  Keep it and it breaks with new one.
11:26:58 <Igloo> If you mean the unicode thing by "I/O breakage" then it can't be fixed at all
11:27:06 <CosmicRay> Igloo: yes, the locale stuff.  I don't pretend to understand what it's doing, but I use openBinary more now and it works OK for me :-)
11:27:25 <CosmicRay> the whole unicode situation in haskell has me quite mystified, overall
11:27:32 <CosmicRay> it seems inordinately complex and undocumented
11:27:47 <Heffalump> so the library story in sarge is going to be a mess if things stay as they are?
11:27:49 <Igloo> The problem is it's not complex enough  :-)
11:27:58 <Igloo> Heffalump: old everything is currently in sarge
11:28:17 <Igloo> new hugs only is in sid
11:28:21 <CosmicRay> Igloo: sometimes making incorrect assumptions is more complex than being configurable :-)
11:28:26 <SyntaxNinja> Heffalump: the problem is that I uploaded new Hugs to sid, but it has an RC bug preventing it from reachign sarge
11:28:54 <CosmicRay> I dunno, when I start getting warnings about invalid UTF-8 sequences while reading a .gz file, I get a little concerned, especially since I never told the system that it should be reading UTF-8 :-)
11:29:04 <CosmicRay> SyntaxNinja: that is a Good Thing
11:29:11 <shapr> I really want GHC to be utf-8 happy.
11:29:13 <Igloo> It has an RC bug /in order to/ prevent it from reaching sarge
11:29:24 <CosmicRay> shapr: yes, but it has to do that in a sane way
11:29:27 <shapr> true
11:29:33 <shapr> but I don't know what way is sane.
11:29:35 <CosmicRay> shapr: like python does (well, python isn't completely nice, but it's more sane anyway)
11:29:39 <Heffalump> ah, ok, that sounds reasonable
11:29:45 <SyntaxNinja> CosmicRay: the rc bug? yeah we did that based on previous discussion
11:29:57 <CosmicRay> SyntaxNinja: yes, I know
11:30:07 <CosmicRay> SyntaxNinja: I was saying "this isn't a problem; this is good"
11:30:12 <Igloo> CosmicRay: What does python do about filenames?
11:30:33 <CosmicRay> Python normally passes everything verbatim unless told to do otherwise
11:30:48 <rik> shapr: maybe.
11:31:00 <shapr> rik: soon!
11:31:16 <shapr> rik: before the rush of newness passes away!
11:31:18 <Igloo> Right, so roughly the non-new-hugs way, then, except I'm not sure we have a way to tell it otherwise
11:31:24 <rik> shapr: when i have time!
11:31:28 <shapr> ok, fair enough.
11:32:30 <CosmicRay> which is what python should do.
11:32:34 <CosmicRay> and what haskell should do.
11:32:49 <CosmicRay> it should never try to re-encode anything unless specifically told to
11:32:58 <CosmicRay> anything else is, imho, broken
11:33:02 <CosmicRay> including the current implementation
11:33:12 <Igloo> Which current implementation?
11:33:21 <CosmicRay> the one in hugs
11:33:34 <CosmicRay> that tried to parse my .gz file as UTF-8 :-)
11:35:49 <CosmicRay> all the I/O should read or write a stream of bytes, unmodified (excepting standard EOL crap on Windows)
11:36:04 <CosmicRay> if I want to convert it, I should be able to call a codec function to do that
11:36:18 <CosmicRay> relying on the locale to determine the expected type of an input or output file is broken, too
11:36:31 <CosmicRay> (say I'm in ISO8859-5 and receive a UTF-8 file that I want to process, for instance)
11:37:04 <Heffalump> why is translating EOL on Windows ok but not translating UTF-8?
11:37:24 <CosmicRay> Heffalump: because translating EOL on windows is standard behavior for every file opened in text mode
11:37:33 <CosmicRay> Heffalump: and works for every text file, regardless of encoding
11:37:47 <CosmicRay> Heffalump: assuming that an input file is UTF-8 is a bad assumption to make
11:38:01 <mflux> if you read a iso-8859-15 as (corrupted) utf8 and you write it back, you end up with a corrupted file?
11:38:07 <Heffalump> ah, text mode, fair enough
11:38:20 <mflux> as not all binary sequences are valid utf-8
11:38:22 <Igloo> File contents you can already handle with the Binary functions. It's file/name/s that are more troublesome IMO
11:38:30 <Heffalump> mflux: the same would happen if you read a file with unix lineendings
11:38:36 <CosmicRay> mflux: the current library will raise a runtime exception of you try to read such a file as utf-8, at least in hugs
11:39:15 <CosmicRay> Igloo: not quite.  The Binary functions cost you the EOL processing on windows, which is often desirable
11:39:19 <mflux> heffalump, yes, but line end corruption is easier to fix
11:39:23 <mflux> 'corruption'
11:39:39 <CosmicRay> Igloo: the text functions should, by default, differ from the binary ones only in their processing of EOL according to the host platform
11:40:14 <CosmicRay> I should be able to read/write an ISO-8859-15 file in a sane way in text mode on all platforms
11:40:23 * Igloo should hunt around and see if there's a half-designed replacement API anywhere sometime
11:40:46 <CosmicRay> Igloo: of course there are :-)  I think Simon has a newIO or some such even
11:48:50 <CosmicRay> @seen shapr
11:48:51 <lambdabot> I saw shapr leaving #haskell 15 minutes 47 seconds ago.
11:58:50 <Lemmih> Have gtk2hs been cabalized?
12:33:46 <jjang> hey
12:34:20 <ski> hello jjang
12:35:02 <jjang> is haskell nice to use for an AI application?
12:35:32 * sorje thinks lambdabot is one convoluted piece of software..
12:35:39 <ski> i would guess so
12:35:43 <SyntaxNinja> lambdabot: are you convoluted?
12:35:44 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
12:35:54 <SyntaxNinja> jjang: it's a pretty good language for that
12:35:56 <ski> it's easy to manipulate symbolic information
12:36:09 <jjang> ok
12:36:32 <jjang> whats the best way to save data with haskell
12:36:34 <jjang> in a db?
12:37:36 <SyntaxNinja> depends, you can just use read and show instances and write to a flat file
12:37:46 <SyntaxNinja> there are database bindings, though if you want them. it depends on your application, not the language
12:38:20 <jjang> i want to have quick access to a lot of lists
12:39:00 <SyntaxNinja> is it all flat data, or is it relational?
12:39:15 <jjang> the lists have some sort of relation yes
12:39:33 <Lemmih> SyntaxNinja: Hacking HTML in hackage is too annoying. Gonna code a client side package browser with wxHaskell to get a better overview of what's needed.
12:40:13 <SyntaxNinja> Lemmih: I'm surprised that the stuff yo're working on has much of an HTML component
12:40:38 <SyntaxNinja> jjang: I don't know waht'll be best for your application; you might just try a few things, benchmark them, and see what's fastest.
12:41:06 <jjang> well i actually wanna sort stuff out before i start coding :)
12:42:03 <SyntaxNinja> if no one here has better advice, you might ask on a database-related channel
12:42:38 <CosmicRay> jjang: there is always the hsql layer, so you can switch databases without much hassle
12:42:51 <CosmicRay> jjang: sqlite is supported by hsql and is a decent, fast, lightweight, embedded sql engine
12:43:05 <jjang> what about mysql
12:43:12 <Lemmih> SyntaxNinja: I wanted Hackage to show a list of hyperlinked version-numbers when viewing info about a package.
12:43:14 <CosmicRay> works fine with hsql
12:43:15 <SyntaxNinja> jjang: but the important thing to note is that it's all dependent on your application; a language-independent question;
12:43:25 <SyntaxNinja> so you could do some research about how to choose between database implementations.
12:43:32 <SyntaxNinja> Lemmih: ahh.
12:43:33 <jjang> ye
12:43:36 <SyntaxNinja> I'll bbiab, going to lunch
12:43:37 * SyntaxNinja &
12:43:55 <jjang> hsql is some sort of library?
12:44:33 <CosmicRay> yes
12:44:45 <CosmicRay> hsql is a database abstraction library, similar to jdbc (java) or dbi (perl)
12:44:47 <jjang> ok
12:44:57 <CosmicRay> write code once, and change one line or two and it works with a different database
12:45:06 <CosmicRay> hsql natively supports mysql, postgresql, sqlite, and odbc
12:45:13 <jjang> nice
12:45:27 <jjang> i wish they teached us that stuff on school
12:46:30 <mflux> is there some sample code on hsql around, just to get the idea what it's about?
12:46:36 <jjang> whats the name of the *web library* of haskell?
12:51:42 <sylvan> jjang: What? Text.Html ?
12:51:45 <sylvan> Or WASH?
12:51:54 <jjang> no idea thats why i ask
12:52:04 <sylvan> Network.CGI
12:52:14 <sylvan> what exactly are you looking for?=
12:52:16 <Lemmih> Halipeto? Hemplate?
12:52:29 <jjang> some module for apache that executes haskell
12:52:38 <sylvan> HSP
12:52:51 <sylvan> Haskell Server Pages.. not sure if they're done with that yet though
12:52:58 <Lemmih> ModHaskell. http://www.scannedinavian.org/repos/ModHaskell
12:53:11 <jjang> The requested URL /repos/ModHaskell was not found on this server.
12:53:34 <Lemmih> Ops. s/ModHaskell/modhaskell/
12:53:34 <ski> http://www.scannedinavian.org/repos/modhaskell/
12:54:27 <jjang> is it just some hobby project or can i rely on it for a large application?
12:55:00 <Heffalump> it's a hobby project
12:55:07 <mflux> doesn't look like there's much actual code there yet?
12:55:12 <Heffalump> well, it was last time I looked at it
12:55:20 <Lemmih> mflux: But it works (:
12:55:39 <jjang> maybe i should look into something else haskell doesnt seem readdy for the web
12:55:40 <sylvan> what do you need to execute haskell for? what do you want to DO?
12:55:45 <mflux> mod_haskell.c looks really minimal :)
12:55:53 <jjang> i want haskell to do some AI tasks
12:56:01 <Lemmih> It's basically just some Apache API binding code with a hs-plugin module loader.
12:56:02 * Heffalump uses Haskell for web applications.
12:57:37 <jjang> its not bugged or so?
12:58:02 <mflux> I doubt much bugs can fit into that amount of code ;)
13:01:12 <Lemmih> I'm the maintainer and I've had no bugs reported so far.
13:01:52 <mflux> how is the performance btw?
13:03:06 <Heffalump> hmm, I ought to try it again
13:03:14 <Lemmih> It would be great if I could get Apache to only keep one instance of the module.
13:03:41 <mflux> how do you mean?
13:04:00 <mflux> it does, the module is loaded in the main process, and afterwards it is only forked?
13:04:16 <mflux> or do you mean you would want it to use threads (which is possible in apache2.0)
13:04:34 <Heffalump> bah, no greencard in Debian?
13:04:48 <Lemmih> mflux: I'm no Apache expert.
13:04:54 <jjang> Lemmih: dont u have a sourceforge page or so for the module?
13:05:08 <Heffalump> ick, he said sourceforge :-)
13:05:12 <Lemmih> jjang: It's just a small pet project. Nothing serious.
13:05:18 <mflux> I've written a few apache modules (apache 1.3.x)
13:05:23 <jjang> why not make it serious
13:05:24 <Lemmih> jjang: And shapr is kinda like sourceforge.
13:05:31 <jjang> ok
13:05:42 <jjang> never heard of shapr
13:05:55 <Heffalump> it's much more intelligent
13:05:59 <Heffalump> better designed
13:06:06 <Heffalump> a touch eccentric, perhaps
13:06:07 <jjang> shapr.org?
13:06:28 <Heffalump> even has a bot on the channel
13:06:45 <vincenz> jjang: shapr is a concept
13:06:51 <jjang> oh
13:07:26 <Lemmih> ModHaskell is Apache2 only, I think.
13:08:03 <jjang> oh np
13:08:30 <jjang> i need to buy me an own server with customized stuff so i can install anything i want
13:09:22 <Lemmih> I would continue it if I could find an Apache expert to consult.
13:09:52 <jjang> become apache expert yourself :)
13:10:09 <Lemmih> I got a three line description of ModHaskell on my personal webpage, btw. ( www.scannedinavian.org/~lemmih/ )
13:10:38 <jjang> mm whats that hemplate?
13:11:23 <Heffalump> /join #apache :-)
13:16:05 * Lemmih wants a dedicated expert (:
13:26:34 <sylvan> jjang: A CGI-script wouldn't suffice? Compile a WASH module which does what you want, or something...
13:26:51 <jjang> whats wash?
13:27:49 <sylvan> google is your friend!
13:27:57 <sylvan> It's a web-authoring tool
13:28:04 <sylvan> it's pretty sweet actually
13:28:25 <sylvan> if it could be escaped from straight HTML it would kick all the other web-language's ass, IMO
13:29:15 <sylvan> well it still does, but you can't really use it to design nice looking web-sites... well you can, but it's not that convenient.. it's killer for designing complicated functionality though.. and you can call haskell-code from it and stuff.. it's bascially just a Haskell program which executs as a CGI-script
13:29:49 <Cale> There's no reason you couldn't use CSS with it. That's what you're supposed to do anyway :)
13:31:53 <jjang> im css expert so np for me
13:32:11 <jjang> as long as i can generate markup and javascript with it im happy
13:32:19 <jjang> and content ofcourse
13:33:13 <Cale> heh, embed javascript syntax as a Haskell datatype and write a combinator language which generates valid javascript
13:33:43 <jjang> i just have my javascript in a .js file
13:34:01 <jjang> as long as i can generate the <script tag with the necessary attributes im happy
13:35:16 <jjang> mm thats all possible
13:35:22 <jjang> i think this is what i need
13:35:46 <jjang> i wonder how fast it is
13:40:00 <jjang> <!-- generated by WASH/HTML 0.11
13:40:00 <jjang> -->
13:40:03 <jjang> i dont like that
13:40:16 <Heffalump> picky, aren't you :-)
13:40:25 <Heffalump> UTSL.
13:40:33 <jjang> and it adds \n after the closing tag
13:40:42 <Heffalump> shocking!
13:40:43 <jjang> like </li/n>
13:40:56 <CosmicRay> jjang: perfectly valid
13:40:58 <jjang> *inside the closing tag
13:41:02 <CosmicRay> jjang: sounds like it uses haxml
13:41:03 <Heffalump> that is quite ugly, yeah.
13:41:08 <jjang> CosmicRay: valid but ugly
13:41:20 <CosmicRay> yes, but there is a good reason it does this for xml stuff
13:41:29 <CosmicRay> html is unique in that it ignores whitespace in documents
13:41:29 <jjang> whats that reason?
13:41:40 <jjang> i know
13:41:43 <jjang> but i wanna remove it
13:41:43 <CosmicRay> sometimes that isn't the case... for instance, submitting xml stuff to soap or xml-rpc servers
13:41:53 <CosmicRay> jjang: might I suggest a nice regexp? :-)
13:41:58 <CosmicRay> or are you speaking of wash?
13:42:01 <jjang> wash yes
13:42:14 <CosmicRay> ahh, feh, why bother?  wash is outputting for a machine, not a human, anyway
13:42:36 <Heffalump> humans read this stuff quite often
13:42:38 <jjang> ppl i make stuff for care about that
13:43:00 <jjang> i want either remove all white space OR have it perfectly indended etc
13:43:03 <CosmicRay> jjang: I don't know that there's much of a way to modify it in-band so to speak, but once saved to disk, there are plenty of tools such as xmlpretty
13:43:14 <jjang> ye i know
13:43:23 <xerox> School tomorrow! Easter holidays finished. Sigh, sob.  Goodnight folks.
13:43:26 <jjang> but i want it to come pretty out of the box
13:43:29 <CosmicRay> heh
13:43:31 <CosmicRay> cya xerox
13:43:41 <CosmicRay> jjang: then you will probably have to hack the source yourself.
13:44:02 <jjang> ye
13:44:03 <jjang> <!-- generated by WASH/HTML 0.11
13:44:04 <jjang> -->
13:44:08 <jjang> that pisses me off so much
13:44:40 <Heffalump> do stop whinging, there's a good chap
13:44:40 <jjang> what if HP added a line on each doc u print: printed with hewlett packerd d970 x series ultra printer
13:44:54 <vincenz> Anyone ever done pattern recognition/clustering of a series of data?
13:45:51 <Cale> jjang: it's only in a comment
13:46:25 <jjang> ye so?
13:46:39 <jjang> what if hp printed it on the backside of all your documents
13:46:44 <jjang> im sure you would be pissed
13:47:10 <Heffalump> however, I wouldn't be annoyed if they put it in a comment in the PS they sent to the printer.
13:47:46 <Cale> They might even do so.
13:47:56 <Heffalump> they almost certainly do :-)
13:48:19 <jjang> well i hate it
13:48:29 <Heffalump> really?
13:48:31 <Heffalump> we hadn't noticed.
13:48:37 <jjang> ;p
13:49:08 <jjang> what if cannon is interessted in hiring your company but sees printed by hp all over your letters you send them
13:49:14 <jjang> dont think that gonna help;p
13:49:35 <Heffalump> HP also charge for their printers.
13:49:43 <Heffalump> WASH is free.
13:49:54 <Heffalump> And since it's open source, just hack the source and stop bloody moaning.
13:50:21 <CosmicRay> yeah, this should be trivial to fix in the source
13:50:29 <jjang> ye i read the source now
13:50:42 <jjang> on what licenense its distributed?
13:50:55 <Heffalump> is it not in the download?
13:51:18 <jjang> no
13:51:21 <jjang> no license at all
13:51:27 <CosmicRay> that's not right
13:51:34 <Heffalump> or on the webpage?
13:51:40 <jjang> not on the page either
13:52:00 <CosmicRay> didn't think to look in the files named LICENSE? :-)
13:52:29 <jjang> i have 4 files
13:52:41 <jjang> none of them is called license
13:52:55 <CosmicRay> what exactly did you download?
13:53:23 <jjang> the base library
13:53:49 <CosmicRay> which file?  WASP?
13:54:07 <CosmicRay> download washngo for the full thing
13:54:10 <CosmicRay> it has LICENSE in it
13:54:17 <jjang> ah k
13:54:20 <CosmicRay> plus the preprocessor
13:54:22 <jjang> havent downloaded that yet
13:55:45 <jjang> what a sucky license
13:56:08 <jjang> i can do basicly anything with it ;p
13:56:16 <CosmicRay> uhm
13:56:17 <CosmicRay> ah
13:56:21 <CosmicRay> why is that sucky?
13:56:26 <CosmicRay> it's a standard 3-clause BSD license
13:57:01 <jjang> if i was the author i wouldve put a more advanced license on it
13:57:05 <CosmicRay> GPL?
13:57:37 <jjang> maybe
13:57:47 <jjang> but i can add my own license to it if i want
13:58:03 <Cale> You could, but it wouldn't serve much purpose
13:58:08 <CosmicRay> why do that?
13:58:17 <Cale> since the same thing is available without your license
13:58:18 <jjang> if you want to make money with it
13:58:19 <CosmicRay> you still have to acknowledge peter
13:58:40 <CosmicRay> jjang: so you are saddened that you can't make money from someone else's work with this license?
13:58:44 <CosmicRay> (actually, that's false...)
13:58:52 <jjang> i can
13:59:24 <jjang> but i would at least require to not distribute the software with any other licenses
13:59:30 <jjang> if i would make a license for it
14:01:17 <Cale> I've never seen someone complain about someone else putting a license on their code which was too free.
14:01:32 <jjang> just pointing out something
14:03:11 <vincenz> Anyone ever done pattern recognition on linear data?
14:03:19 <Cale> 3-clause BSD is basically public domain, perhaps without quite as much responsibility on the owner.
14:04:26 <CosmicRay> hello metaperl
14:04:48 <metaperl_> hi CosmicRay
14:04:49 <astrolabe> Does matched filtering count?
14:04:56 <vincenz> astrolabe: perhaps
14:05:07 <CosmicRay> metaperl: I've been enjoying your haskell blog posts
14:05:10 <vincenz> astrolabe: basically I'm trying to find patterns in a series of data without losing the time ordering
14:05:36 <vincenz> a b a a b a will become 2 * ( a b a)
14:05:38 <vincenz> but...
14:05:44 <vincenz> a b a c a b a d a b a will stay that
14:05:47 <vincenz> I'd like something like
14:05:56 <vincenz> 1 c 1 d 1 with 1 pointing to an aba group
14:06:15 <CosmicRay> metaperl: I found your comments about communities to be quite perceptive
14:06:26 <astrolabe> vincenz: Not matched filtering then I think
14:06:57 <vincenz> googling for "pattern recognition" gets me a lot of useless "spam"
14:06:58 <astrolabe> I think winzip has something like that.  Can't remember the name of the underlying algorithm
14:07:11 <metaperl_> CosmicRay, thanks
14:07:28 <vincenz> ah, huffman
14:07:29 <vincenz> thx!
14:07:32 <CosmicRay> metaperl: I must admit surprise when you and some other perl people commented positively about haskell... I think the "arrogant, egotistical self-centered people" in the community had so long ago drowned out the sharp folks
14:07:35 <vincenz> completley forgot about that
14:07:37 <vincenz> thanks!!
14:07:48 <CosmicRay> I'm used to perl folks never saying anything nice about anything that isn't written in Perl :-)
14:08:07 <metaperl_> yes. there are indeed perls among the swine... er pearls
14:08:10 <vincenz> astrolabe: thank you for that, that really helpd :)
14:08:11 <CosmicRay> heh
14:08:17 <astrolabe> You are welcome.  But a pre-huffman stage I think
14:08:30 <vincenz> hmm
14:08:33 <vincenz> pre-huffman?
14:08:47 <astrolabe> I mean it is done before huffman
14:08:53 <vincenz> nono, I think it's huffman
14:09:05 <CosmicRay> metaperl: but it's true too, the haskell community is quite unique.  so many helpful, and amazingly smart, people out there.
14:09:14 <astrolabe> My memory is v. hazy.  You a probably right.
14:09:44 <vincenz> hmm
14:09:47 <vincenz> huffman is not optimal tho
14:10:02 <vincenz> a a a a will not be one group
14:10:16 <vincenz> but I guess it's worth a try :)
14:10:47 <metaperl_> personally, I am wired. I have Simon Thompsons Haskell book and I have understood every word so far... and I intend for it to stay that way or hammer away at my confusion til I get it
14:11:30 <metaperl_> this is a book written by an expert with complete control of his delivery... I'm amazed at how both his book and Hudak's center around picture rendering
14:11:57 <CosmicRay> metaperl: this community is also pretty good at self-reflection and figuring out where we're weak
14:12:11 <CosmicRay> and, in at least 50% of the cases, actually doing something about it :-)
14:12:20 <jjang> it looks like only proffessors use haskell
14:12:27 <CosmicRay> jjang: Not really
14:12:32 <CosmicRay> jjang: that probably was the case at one time
14:12:38 <CosmicRay> jjang: look at darcs for an exampel
14:12:51 <astrolabe> hands up all the proffessors
14:12:59 <vincenz> Basically I want maximal sharing
14:13:00 <CosmicRay> jjang: syntaxninja has done great work with cabal
14:13:14 <jjang> the whole software division at my university researches haskell
14:13:18 <CosmicRay> jjang: I've written a Python link, and some pure haskell code
14:13:23 * Philippa doesn't have a degree yet...
14:13:24 <CosmicRay> jjang: that is nifty.  what university?
14:13:25 <jjang> they do nothing else alsmost
14:13:31 <jjang> university of utrecht
14:13:32 <Philippa> Kent?
14:13:34 <Philippa> *ah*
14:13:38 <Philippa> yes :-)
14:13:57 <Heffalump> not true, the Stratego people don't.
14:14:05 <jjang> so majoring software technolgy automaticly forces you into haskell
14:14:15 <jjang> stratego ppl
14:14:15 <CosmicRay> nice :-)
14:14:18 <jjang> thats like 1-2
14:14:22 <jjang> i think
14:14:55 <astrolabe> vincenz: http://en.wikipedia.org/wiki/Lempel-Ziv-Welch
14:15:00 <Philippa> you have to do some haskell at UoN but not much
14:15:19 <Philippa> OTOH, the course'd benefit if they used haskell rather than Java for eg the compilers module (or mebbe they do now? Been a while)
14:16:22 <jjang> we learn only java and haskell
14:16:43 <SyntaxNinja> I hate when peanut M&Ms are missing the peanuts
14:16:50 <jjang> lol
14:16:54 <jjang> those are bad
14:17:12 <Philippa> jjang: we only do those on the mandatory courses
14:17:24 <Philippa> prolog's available, C++ is available, epigram's available
14:17:36 <jjang> prolog we got too
14:17:43 <SyntaxNinja> CosmicRay: thanks :)
14:17:54 <vincenz> astrolabe: yeah lempel ziv is what I meant :D
14:17:55 <jjang> but my teacher thought it was fun to write a prolog parser in haskell
14:17:58 <jjang> so
14:18:05 <CosmicRay> SyntaxNinja: :-)
14:18:06 <jjang> anything u do leads to haskell
14:18:09 <CosmicRay> jjang: heh
14:18:11 <Heffalump> who's your teacher?
14:18:19 <jjang> the devil himself
14:18:24 <Heffalump> Doaitse? :-)
14:18:27 <jjang> yes
14:18:40 <SyntaxNinja> heh
14:18:50 <jjang> he has no clue that writing a prolog parser is actually fucking boring
14:18:58 <jjang> and to make it even worse
14:19:06 <jjang> it was a requirement for our last exam
14:19:13 <jjang> to know how that fucking thing works
14:19:19 <CosmicRay> heh
14:19:26 <jjang> i dont even know prolog
14:19:29 <zamez> reminds me of something
14:19:42 <vincenz> ugh
14:19:52 <vincenz> what's the diff between lempel ziv and huffman again?
14:20:27 <Heffalump> huffmane is a token-based system, lempel ziv is dictionary-based
14:20:27 <Heffalump> s/huffmane/huffman/
14:20:45 <jjang> heffa you had doaitse too?
14:20:46 <astrolabe> Not a clue.  Sorry.
14:20:52 <Heffalump> huffman just tries to guess the probability of each token appearing and tailors the encoding for them appropriately
14:21:08 <vincenz> ah yes
14:21:29 <vincenz> I'll make a lempelziv encoder
14:21:45 <Heffalump> lempel ziv does some kind of "look 5 tokens back in the input stream and read 3 tokens from there"
14:21:54 <Heffalump> jjang: no
14:22:07 <jjang> lucky basterd~
14:22:33 * Heffalump knows several people at Utrecht reasonably well
14:22:44 <Heffalump> (including the PhD students that frequent this channel ;-)
14:22:52 <vincenz> the problem with lempel ziv is the startup cost of a sequence
14:23:27 <jjang> im just a 1st year bachelor
14:23:27 <vincenz> it's not optimally clustered
14:24:50 <vincenz> Any better suggestions?
14:26:33 <vincenz> some sort of higher order run lenght encoding
14:28:06 <Cale> LZMA?
14:29:57 <vincenz> any description anywhere?
14:30:12 <x3n0n> what do you want your output to be?  "cluster :: [a] -> ??"
14:30:35 <x3n0n> some sort of tree structure?
14:30:45 <vincenz> yes
14:30:51 <vincenz> or dag
14:30:58 <vincenz> for maximal sharing
14:31:11 <Cale> http://en.wikipedia.org/wiki/LZMA talks about it, and it sounds neat, but I'm not sure where other information might be available. There's an LGPL'd implementation.
14:31:34 <vincenz> thx
14:31:37 <x3n0n> what is "maximal"?
14:32:03 <vincenz> well
14:32:08 <vincenz> a b a c a b a d a b a
14:32:15 <vincenz> 1 c 1 d 1 with 1 pointing to a b a
14:32:18 <x3n0n> you used "aaaa" -> something earlier--what do you want there?
14:32:30 <vincenz> 4a
14:32:39 <x3n0n> abab?
14:32:45 <vincenz> 2(ab)
14:32:58 <vincenz> aabab -> a (ab)
14:33:01 <vincenz> =2
14:33:05 <astrolabe> Is maximal sharing the same as maximal compression?
14:33:19 <ski> aabaabaac
14:33:24 <vincenz> hmm
14:33:33 <x3n0n> :)
14:33:33 <vincenz> 2(2ab)2ac
14:33:56 <x3n0n> you don't want to lift "aa"?
14:33:59 <vincenz> or 2a2(b2a)c
14:34:13 <vincenz> x3n0n: I did?
14:34:23 <vincenz> oh
14:34:25 <x3n0n> aaabaaabaaac
14:34:45 <vincenz> 2(xb)xc  x-> 3a?
14:35:08 <x3n0n> :) I'm just asking the question--I can't help solve it until I know the spec. :)
14:35:26 <ski> abacabadabacaba
14:36:19 <vincenz> xdx x-> ycy y->aba
14:36:37 <ski> :)
14:37:00 <vincenz> But something efficient
14:37:05 <vincenz> I have about 70M symbols
14:37:26 <vincenz> maybe I could start with just clustering without sharing
14:37:38 <vincenz> so the previous example would remain as is
14:37:46 <vincenz> but if you remove the d you get 2(abacaba)
14:37:46 <x3n0n> is the clustering the run-length encoding?
14:37:59 <vincenz> something higherlevel
14:38:02 <ski> wanna have sharing of abstracted parts, too ?
14:38:09 <vincenz> yes
14:38:47 <x3n0n> is the goal to reveal structure or to compress?
14:38:52 <vincenz> reveal structure
14:39:17 <vincenz> I wanna look at accesspatterns (scoped as I have function calls inside those packets too and those function calls also contain sequences)
14:39:24 <vincenz> and see how the program behaves
14:39:30 <TheHunter> nooooooo
14:39:38 <vincenz> ?
14:39:46 <ski> abacabadabacaba   =>   let f(x,y) = x y x in  f(f(f(a,b),c),d)
14:39:53 * TheHunter just lost all the sml stuff he's been playing around with to a grep -> *.sml
14:40:10 * vincenz smacks TheHunter 
14:40:11 <vincenz> get ocaml
14:40:13 <vincenz> and cvs
14:40:23 <CosmicRay> pfft, get haskell :-)
14:40:27 <CosmicRay> and darcs
14:40:32 <CosmicRay> what channel is this? :-)
14:40:33 * vincenz grins
14:40:38 <TheHunter> ocaml doesn't have callcc, so it's useless to me :-)
14:40:40 <vincenz> algo101
14:40:50 <vincenz> ski: any ideas?
14:41:01 <ski> vincenz : for what ?
14:41:05 <vincenz> how to do it
14:41:13 <ski> um
14:41:28 <ski> no, atm
14:41:32 * vincenz sichs
14:41:36 <vincenz> s/c/g
14:41:52 <ski> s/h/k/ ?
14:42:00 <x3n0n> :)
14:42:00 <vincenz> right now I have a simple system
14:42:12 <vincenz> it's somewhat ok but it'll fail to see higher patterns
14:42:30 <ski> hm
14:42:31 <x3n0n> what is your data stream? that is, what are the tokens?
14:42:44 <vincenz> x3n0n: mallocs, frees, reads, writes, function calls
14:43:46 <x3n0n> and you're trying to reverse-engineer the makeup of the function calls?
14:43:59 <vincenz> yes, though mostly the access behaviour
14:44:18 <vincenz> the function calls is so I can map it back to the applicaiton once I decide to make modifications in the patterns
14:44:49 <ski> vincenz : hm, a simple start for abstractions would possibly be to make an approximate string matcher
14:44:57 <vincenz> ?
14:45:06 <vincenz> I do something like that
14:45:14 <vincenz> basically whenever I get a new token
14:45:28 <vincenz> I try to add it by looking back for matches and when I find a match see if the string matches the previous string
14:45:39 <ski> no
14:45:39 <vincenz> ok....take the left as the next token, the right as result
14:45:43 <vincenz> a -> [a]
14:45:47 <ski> i meant for approximate matches
14:45:53 <vincenz> a -> 2*[a]
14:46:04 <vincenz> b -> [2*[a] b]
14:46:23 <vincenz> a a  -> [2*[a] b] 2*[a]
14:46:29 <vincenz> b -> 2*[2*[a] b]
14:46:34 <ski> abcbaabdba     =>  let f(x) = abxba in f(c) f(d)
14:47:11 <vincenz> well that's nice but I don't think there's an efficient algorithm
14:47:32 <ski> dunno
14:47:52 <vincenz> lempel ziv while nice suffers from the start up cost
14:47:59 <vincenz> and hence makes it apparently more chaotic
14:48:14 <CosmicRay> you mean during compression, not decompression, right?
14:48:18 <vincenz> yes
14:48:34 <vincenz> the idea is to get a higher view of the behaviour
14:48:40 <vincenz> I fear LZ will make it more confusing
14:49:00 <x3n0n> are you looking for matching malloc/free pairs?
14:49:12 <vincenz> possibly
14:50:05 <x3n0n> those seem like natural boundaries (in a stack-ish structured system) for "parenthesizing" the access stream
14:50:28 <vincenz> not quite
14:50:39 <vincenz> the problem is that the application allocates data at the beginning and frees it at the end
14:50:52 <vincenz> the idea of seeing the pattern is moving the allocating/freeing of the data so it's only there when needed
14:51:34 <x3n0n> ah--so the current data stream looks vaguely like "lots of malloc, lots of scattered r/w, lots of free" with interspersed fn calls
14:51:38 <vincenz> but 70M packets = 1.4GB binary data is not exactly readable
14:51:43 <vincenz> x3n0n: yes
14:52:03 <vincenz> heh, for one input it's 23GB data
14:52:15 <vincenz> but I'm sure much of it is nice for loops
14:52:20 <vincenz> that can be detected in the stream
14:52:33 <x3n0n> and you'd like to find places where the r/w are "clustered" so that you can move the mallocs "inward"
14:52:43 <vincenz> yip
14:53:25 <vincenz> or for instance see it's WWWWWRRRRR and decide that by rearranging the code one can get a smaller variable
14:53:49 <vincenz> but for that I first need a highlevel view of behaviour
14:53:50 <vincenz> hence the clustering
14:54:26 <vincenz> maybe I should go for source code analysis instead of the loggingoutput, but I fear that'll introduce too many gritty details I don't care about and abstract away the data-dependent behaviour
14:54:41 <x3n0n> and you care about the "addresses" of the reads and writes, because they presumably are "clustered" that way too
14:55:14 <vincenz> I can get as much detail as I want
14:55:21 <vincenz> I know which block each access accesses
14:55:30 <vincenz> right now I cluster accesses by memory-block size and type-id
14:55:36 <vincenz> well "variable id"
14:56:34 <vincenz> if I can get it more clustered I might look inside the blocks but I feel that will introduce too much detail again
14:56:40 <vincenz> possibly at a latter stage I'll look inside the blocks
14:57:20 <x3n0n> it does seem that when you're done with all this, you'll head back into the source code and have to "prove" that your changes are safe.
14:57:32 <vincenz> right
14:58:07 <x3n0n> do you have function "returns"?
14:58:22 <vincenz> I know when a function starts and ends
14:58:27 <vincenz> so at all points I know where I am in my scope stack
14:58:49 <vincenz> x3n0n: what do you do by the way?
14:59:36 <x3n0n> my day job is OS programming, but I'm just an interested observer here.  I'm a math nut.
14:59:44 <vincenz> coolies
14:59:51 <vincenz> anyways
15:00:03 <vincenz> maybe I should go with source code analysis, but I feel that'll give me too much of a static view
15:00:12 <vincenz> plus, there's no good tools on the market for c++-analysis
15:00:21 <x3n0n> the function entrance/return points seem like they should give you a lot of info.
15:00:48 <vincenz> well that's how I can see "scoped" behaviour
15:00:50 <vincenz> and I do cluster by scopes
15:01:11 <vincenz> in ocaml lingo, the type of the element is:
15:01:13 <x3n0n> do you then "match" access patterns across matching function calls?
15:01:20 <vincenz> no
15:01:27 <vincenz> but I do bundle repetitive function calls
15:01:30 <x3n0n> that seems like an opportunity
15:01:32 <vincenz> and then I bundle inside calls
15:02:04 <vincenz> x3n0n: that's basically removing the scope_starts and scope_ends and clustering that way
15:02:17 <x3n0n> like "every time I enter foo, I do a cluster of writes, and then stuff happens, and then reads, and then I leave"
15:02:40 <vincenz> give you an idea
15:02:55 <vincenz> a_begin read read write write a_end a_begin read read write write a_end
15:02:55 <vincenz> ->
15:03:04 <vincenz> 2*a(2*R 2*>)
15:03:12 <vincenz> s/>/W
15:03:22 <x3n0n> ahhh
15:03:39 <vincenz> however
15:03:46 <vincenz> add a stupid READ between the end and begin
15:03:59 <vincenz> and I get two a's (with innards clustered) with a read in between
15:04:19 <vincenz> of course ifthere is a read after the second a I get a cluster again
15:04:24 <vincenz> 2*(a read)
15:04:27 <vincenz> with a as before
15:05:04 <x3n0n> seems like you could use a generic parser to start turning the a_begin/a_end pairs into "labeled parentheses" to give you your "a->(2R 2W)" things
15:05:11 <vincenz> I do
15:05:28 <vincenz> but one issue is
15:05:31 <vincenz> a a a b a a b a a b
15:05:40 <vincenz> = 3*a b 2*(2*a b)
15:05:41 <vincenz> not
15:05:47 <vincenz> a 3*(2*a b)
15:06:06 <vincenz> obviously the second is more natural
15:06:24 <x3n0n> :)
15:06:31 <vincenz> I could possibly undo clusters to try better clusters
15:06:36 <vincenz> but I fear that might blow up my algo
15:06:48 <x3n0n> so the hard part is figuring out what is "obvious"
15:06:59 <vincenz> yes
15:07:12 <vincenz> and detecting it without having an explosive algorithm
15:07:18 <vincenz> preferably on the fly
15:08:15 <x3n0n> you could do something silly like "every time I find a "complex" run of 2 or more, look backwards to see if there's really one before it"
15:08:47 <x3n0n> I don't think it's an easy problem, though. :)
15:08:55 <vincenz> yip
15:09:00 <vincenz> well I hope what I have for now is good enough
15:09:06 <vincenz> it looks pretty decent
15:09:08 <vincenz> simple but decent
15:09:12 <vincenz> I got it running at work
15:09:20 <vincenz> and have it print out it's effective length
15:09:26 <vincenz> tomorrow I'll see if it's any good :D
15:09:45 <vincenz> if so I'll have it run again and print out the structure for analysis
15:09:52 <x3n0n> good luck
15:10:13 <vincenz> thx
15:11:42 <vincenz> you think going from the source code side might be better?
15:15:18 <x3n0n> ...automated or manual?
15:15:27 <vincenz> possibly automated
15:16:43 <x3n0n> there may already be tools that can give you some pointers in the right direction.  What is your end goal?  "Improve the performance/efficiency of the code"?
15:17:12 <vincenz> for now, improve the dynamism
15:19:09 <x3n0n> well, gotta go; good luck
15:20:41 <vincenz> bye
15:26:33 <TheHunter> man, grep on a 4G partition takes a lot of time...
15:26:54 <vincenz> heh
15:27:00 <vincenz> TheHunter: what about parsing 23 GB of data
15:27:32 <TheHunter> well, that'll take even more time (especially with haskell)
15:27:45 * vincenz uses ocaml
15:27:48 <TheHunter> 4m57s, that's not so bad.
15:28:04 <vincenz> damn that's slow
15:52:56 <SyntaxNinja> I keep trying to eat more things to get the taste of the last thing I ate out of my mouth
15:53:11 <SyntaxNinja> trouble is: nothing good to eat
15:54:03 <vincenz> coke
15:54:09 <vincenz> and cigarettes
15:54:11 <vincenz> in quantities
17:01:45 <SyntaxNinja> are asserts free if I use the -fturnoffassertsorwhatever flag?
17:02:39 <dons> yep
17:02:51 <dons> now, it's documented somewhere.. hmm. let me see.
17:03:10 <SyntaxNinja> yay free asserts
17:04:21 <dons> -fignore-asserts means that expressions of the form P e are rewritten as e, where P is a predicate
17:04:31 <SyntaxNinja> ok sweet
17:05:21 <dons> so the magical "assert" id is really quite magical
17:05:32 <dons> you also get line numbers inserted by the compiler
17:06:18 <SyntaxNinja> when an assertion fails, it prints the line number
17:06:48 <dons> yeah
17:07:24 <dons> ghc rewrites: assert pred val ==> assertError "Main.hs|15" pred val
17:15:03 <TheHunter> doesn't -O turn asserts off?
17:40:17 <Lemmih> Checkout the Hackage screenshot at: www.scannedinavian.org/
17:40:25 <Lemmih> hmm...
17:41:17 <SyntaxNinja> Lemmih: where?
17:42:09 <Lemmih> www.scannedinavian.org/~lemmih/HackageBrowser01.png
17:42:42 <Lemmih> four hours old.
17:42:53 <SyntaxNinja> looks cool!
17:43:18 <Lemmih> -not the screenshot, that is.
17:45:57 <SyntaxNinja> ?
17:46:06 <Lemmih> Comming up features include: Library (if existent), executables, version differeces and dependency graphing.
17:46:33 <SyntaxNinja> is that a client-side browser or server-side?
17:47:15 <Lemmih> The screenshot is all fresh, the program 4 hours old. -Client-side!
17:47:36 <SyntaxNinja> cool!  keep up the good work.
17:47:41 <SyntaxNinja> I gotta run. I'll ttyl.
17:47:45 <SyntaxNinja> is upoading tgzs working yet?
17:47:58 <Lemmih> Kinda.
17:48:07 <SyntaxNinja> ttyl/
17:48:08 <Lemmih> Still don't know where to put 'em.
17:50:46 <metaperl> *UsePictures> whiteSeg
17:50:47 <metaperl> "......"
17:50:47 <metaperl> *UsePictures> blackSeg
17:50:47 <metaperl> "######"
17:50:47 <metaperl> *UsePictures> zipWith (++) whiteSeg blackSeg
17:50:56 <metaperl>  Couldn't match `[a]' against `Char'
17:50:56 <metaperl>         Expected type: [[a]]
17:50:56 <metaperl>         Inferred type: [Char]
17:51:11 <Lemmih> @type zipWith (++)
17:51:13 <metaperl> howver whiteSeg ++ blackSeg works fine
17:51:39 <Lemmih> Prelude> :t zipWith (++)
17:51:39 <Lemmih> zipWith (++) :: [[a]] -> [[a]] -> [[a]]
17:52:00 <Lemmih> [Char] doesn't match [[a]].
17:52:27 <metaperl> Prelude> :t zipWith
17:52:35 <metaperl> @type zipWith
17:53:02 <metaperl> oh I see
17:53:10 <Lemmih> lambdabot is gone.
17:53:49 <Darius> metaperl: zipWith (\x y -> [x,y]) whiteSeg blackSeg
17:56:48 <metaperl> Darius, thanks
18:02:10 <metaperl> does anyone have any suggestions for a tighter way to write this
18:02:22 <metaperl> http://www.hcoop.net/~terry/haskell/craft-of-fp/ex/question.txt
18:07:21 <Darius> unline [if (x > 5 && y < 6) || (x < 6 && y > 5) then '#' else '.' | x <- [0..11], y <- [0..11]]
18:07:29 <Darius> s/unline/unlins
18:07:34 <Darius> Gah unlines
18:08:01 * Darius would probably abstract away from the bounds.
18:15:38 <metaperl> phew, that is a nice one Darius
18:16:13 <metaperl> it makes perfect sense to me now... you worked from the bottom up, creating an expression for what was to be at each position
18:16:40 <metaperl> I was thinking in coarser units
18:16:48 <Darius> Actually I find it a bit ugly, but it is short and I probably would find it a bit less ugly parameterized.
18:17:39 <Darius> metaperl: If I were building a compositional library, I'd probably make a 'block' function plus vertical and horizontal glue functions.
18:18:19 <Darius> Of course, if I did that, I'd probably not use Strings as the "work" data type.
18:18:37 <metaperl> the Picture library has those concatenation operations and that is yet another way to think of this
18:18:45 <metaperl> this is exercise set2 from Thompson's book
18:21:23 <autrijus> my pugs journal today reads like a GHC 6.4 propaganda :D
18:21:24 <autrijus> # http://use.perl.org/~autrijus/journal
18:22:37 <metaperl> Darius, your example does not work :)
18:23:46 <Darius> I wouldn't be surprised if it has an off-by-one error (which is part of why I find it ugly)
18:24:00 <Darius> autrijus: Pugs -is- Haskell propaganda
18:24:23 <metaperl> no, Darius: you are creating one long string which cannot be passed to unlines
18:24:55 <Darius> unlines (map take 12 ...)
18:25:49 <Darius> Or [[ if ... | x <- [0..11]] | y <- [0..11]]
18:28:28 <metaperl> pointLogic x y = if (x > 5 && y < 6) || (x < 6 && y > 5) then '#' else '.'
18:28:28 <metaperl>  
18:28:28 <metaperl> checkerSquare3 = [pointLogic x y | x <- [0..11], y <- [0..11]]
18:28:44 <metaperl> how do I fix the list comprehension to make a list of lists
18:28:58 <Darius> Nesting them as I did above (for one possibility).
18:29:10 <metaperl> I cant follow it
18:29:14 <metaperl> can you write it out?
18:29:40 <Darius> [[pointlogic x y | x <- [0..11]] | y <- [0..11]] should do the right thing.
18:30:30 <Darius> Incidentally, [pointLogic x y | x <- [0..11], y <- [0..11]] is liftM2 pointLogic [0..11] [0..11]
18:30:55 * metaperl reels in a daze
18:31:46 <autrijus> mmmm list monad
18:33:31 <metaperl> it actually does not solve the problem I am doing in Thompson's book though
18:33:52 <metaperl> Darius would that map take 12 work? I can't imagine that working...
18:34:56 <Darius> You can try it.  As you might have noticed, I haven't been running the code through GHCi.
18:35:25 <metaperl> do you think my progression from naive example to your example is a good article for The Monad Reader?
18:36:00 <shapr> metaperl: hello!
18:36:02 <metaperl> for right now, it goes in my blog... shapr will see it and decide
18:36:05 <metaperl> speak of the devil
18:36:06 <shapr> he will?
18:36:07 <metaperl> :)
18:36:09 <Darius> Not really, as the later versions are not particularly elegant or even very representative of typical Haskell.
18:36:16 <Pseudonym> shapr == devil?
18:36:18 <Darius> shapr lambdabot
18:36:21 <Pseudonym> @arr
18:36:25 <shapr> Arr!
18:36:27 <shapr> oops
18:36:46 <shapr> reflex action.
18:37:08 <shapr> metaperl: This extremeperl guy has strong opinions, no doubt about that.
18:37:11 <Darius> metaperl: By the way, with the if statement factored out into a function, I'd probably rewrite it using guards
18:38:10 <metaperl> shapr, yes he runs his own consulting company and is sort of underground in the Perl community...
18:38:28 <metaperl> his Perl code is very Haskellish - quite declarative... razor sharp stuff
18:38:48 <shapr> Yeah, I've seen some of that in his book.
18:38:55 <metaperl> shapr, check out this progression: http://www.hcoop.net/~terry/haskell/craft-of-fp/ex/UsePictures.hs
18:39:18 <shapr> What's the goal?
18:39:24 <metaperl> APPROACH ONE, APPROACH TWO , DARIUS APPROACH
18:39:37 <metaperl> just to create a 12 x 12 checkered board
18:39:44 <shapr> oh, I see
18:39:45 <metaperl> with 2 patches of white and 2 patches of black
18:40:33 * shapr thinks up another one
18:40:48 <metaperl> Darius worked from bottom up and created an expression for what was to be at each point
18:41:03 <metaperl> I was thinking coarsely in terms of white line segments and black line segments
18:43:14 <shapr> foo, my first approach sucked.
18:43:18 <shapr> foo size = unlines $ replicate size $ take size $ cycle ['#','.']
18:43:20 <Darius> checkSquare3 needs a final unlines
18:43:41 <shapr> That replicate gives solid columns instead of checkers.
18:44:16 <metaperl> Darius, the module Picture contains printPicture
18:47:54 <metaperl> shapr, you are generating something different
18:48:26 <Darius> let c@(_:c') = take (size+1) $ cycle ['#','.'] in take size $ cycle [init c,c'], but I don't like the init (says the C++ programmer in me)
18:48:30 <metaperl> I added a picture
18:48:56 <metaperl> we need to inflate the cycle
18:49:03 <metaperl> via replicate
18:49:29 <shapr> oh, you want just four squares of the checkerboard?
18:49:41 <metaperl> yes
18:50:00 <metaperl> The Goal section describes the output
18:50:18 <metaperl> printPicture takes a [ String ] and prints it
18:50:22 <shapr> I haven't looked at SOE in several months, my memory fails me.
18:50:31 <metaperl> SOE?
18:50:42 <shapr> School of Expression, that's what this is, right?
18:50:51 <shapr> Hudak's book?
18:50:52 <metaperl> oh no, this is Craft
18:50:57 <shapr> whoops.
18:51:42 <metaperl> they do have the same practical use case by and large from what I can tell from the toc of Hudak's book
19:00:45 <Darius> autrijus: Have you or will you use monads in your Perl code?
19:07:32 <shapr> metaperl: I have an ugly but arbitrarily sized solution.
19:07:41 <shapr> bar x y = let halfX = (x `div` 2) ; halfY = (y `div` 2) in
19:07:44 <shapr>           (replicate halfY ((take halfX blacks) ++ (take (x - halfX) whites))) ++ (replicate (y - halfY) ((take halfX whites) ++ (take (x - halfX) blacks)))
19:09:04 <shapr> I'm sure I could refactor that into something much smaller.
19:12:11 <shapr> metaperl: btw, I have some half-finished replies to Rob that await real unabused consciousness. I agree with most of the points you've made, but I think the way they were presented didn't really work for him.
19:13:16 <shapr> I disagree with him that all programming paradigms can be learned via Perl. Or at least, I don't believe that the benefits of referential transparency are apparent unless he writes an interpreter for something like Haskell in Perl, and then uses that language.
19:14:07 <shapr> Are Perl community discussions always as  vicious as what he said about strong typing?
19:14:30 <Pseudonym> That depends/.
19:14:37 <Pseudonym> p5p was mostly noise for a long time.
19:14:44 <shapr> g'day Pseudonym
19:14:49 <Pseudonym> G'day.
19:14:57 <shapr> How's code?
19:15:22 <Pseudonym> OTOH, if you ask a Perl luminary, they're smart, respectful and polite.  On the whole.
19:15:49 <Pseudonym> http://www.perl.com/pub/a/2000/12/advocacy.html
19:15:53 <Pseudonym> That sums up the situation pretty well.
19:16:02 <Pseudonym> Havben't coded for a week.
19:16:05 <Pseudonym> Long weekend.
19:16:09 <ozone> Pseudonym: ah, one of the best articles i've ever read, fullstop
19:16:14 <Pseudonym> Yes!
19:16:15 <Pseudonym> I agree.
19:16:54 <ozone> mjd and damian conway are heroes
19:16:59 <Pseudonym> Yup.
19:17:06 <Pseudonym> I used to work at Monash.  I knew Damian.
19:17:08 <ozone> in fact, pretty much all the big names in perl are really really clever
19:17:13 <Pseudonym> Yeah.
19:17:16 <Pseudonym> Even Simon Cozens!
19:17:21 <ozone> yeah, even him :)
19:17:21 <Pseudonym> :-)
19:17:51 <ozone> you've seen that YAPC2002 video, Pseudonym ?
19:18:04 <Pseudonym> Nope.
19:18:40 <ozone> http://www.perl.org/yapc/2002/movies/themovie/
19:18:52 <ozone> or http://www.annodex.net/software/AnnodexFirefoxExtension/index.html#test-content for the annodex version (which now has linux and mac os x plugins)
19:19:29 <shapr> I think maybe I should mention this url on the extremeperl list.
19:19:34 <Pseudonym> I don't have the facilities to read that at the moment.
19:19:40 <shapr> Though these points seem obvious to me, I think they are not obvious to everyone.
19:19:52 * Pseudonym nods
19:20:19 <Pseudonym> In any mainstream group there is usually a sensible core, and a large number of weird hangers-on.
19:20:21 <ozone> shapr: if you want to try out the annodex YAPC video, please do.  our linux plugins could use some testing :)
19:20:35 <shapr> When I have time...
19:20:42 <shapr> I'll bookmark that url for now.
19:20:48 <Pseudonym> You have to remember, of course, that most of these people probably don't even have CPAN checkin rights.
19:20:50 <ozone> cheers
19:20:51 <shapr> I have some interesting ideas for annodex...
19:21:07 <ozone> feel free to /msg or email me about themn :)
19:21:21 <shapr> spiffy :-)
19:21:40 <shapr> In short, I want to mix Fermat's Last Margin and Annodex.
19:21:57 <ozone> sounds ... interesting
19:22:01 <ozone> but first, to lunch i go
19:22:19 <Pseudonym> Lunch for me too.
19:22:31 <shapr> I think I'll have breakfast.
19:22:36 <shapr> It's nearly 6am!
19:22:46 <shapr> But no, back to work instead.
19:23:16 <wagle> 7:23pm.. dinnertime
19:28:58 <shapr> dons: synhl?
19:29:02 * shapr boings eagerly
19:29:53 <dons> shapr!
19:30:09 <dons> shapr: lambdabot is now 6.4 compliant: http://www.cse.unsw.edu.au/~dons/lambdabot
19:30:16 <dons> more patches on their way
19:30:19 <shapr> w00!
19:31:41 <shapr> Shall I continue to run lambdabot on ScannedInAvian?
19:31:54 <shapr> Or would you or someone else rather host lambdabot?
19:32:29 <dons> you should for the time being, I think, but I might take it over in a few days
19:32:39 <dons> I can run it on my openbsd box
19:32:43 <shapr> awright, spiffy
19:33:09 <shapr> I'll setup a new lambdabot after I've rebooted^Hslept.
19:33:23 <dons> ok. :)
19:33:49 <dons> Pseudonym: lambdabot is back in .au :)
19:34:58 <shapr> After a few years abroad...
19:36:27 <heatsink> ...?
19:36:42 <shapr> lambdabot is back in its country of origin.
19:37:12 <heatsink> Has it learned any new languages during its travels?
19:37:17 <Pseudonym> Woohoo!
19:37:31 <Pseudonym> heatsink: Yeah, it learned a cut-down Haskell dialect, for @eval.
19:39:18 <heatsink> So lambdabot has been enriched by the experience.
19:53:25 <cm> hi
19:53:40 <shapr> y0
19:55:52 <cm> shapr-san
19:55:59 <shapr> konichiwa cm-san
19:56:01 <cm> my email reached you, i suppose?
19:56:04 <shapr> ohio gozymous
19:56:11 <shapr> it did, but I've been distracted by work, haven't replied yet.
19:56:29 <cm> ah ok, good to know I spelled scannedinavian right ;)
19:56:36 <shapr> yay!
19:57:49 <shapr> howdy jyasskin
19:57:57 <jyasskin> howdy shapr
19:58:35 <jyasskin> Seen any good articles/books on introductory category theory? preferably online?
19:59:40 <jyasskin> I've been reading wikipedia's articles, but they aren't really aimed at a programmer
19:59:52 <shapr> http://www.xp123.com/wwake/dissertation/model.shtml
20:02:00 <jyasskin> mm, thanks :)
20:02:31 <Gahhh> ascii figures are sexy
20:03:14 * cm shapes shapr some more
20:03:28 <Darius> Baar and Well's ESSLI(?) lecture notes are pretty good and are fairly CompSci/programmer geared.
20:03:50 <shapr> I am well shaped already thank you.
20:04:22 <Gahhh> Every time I see a pictorial description of software (typically UML diagrams), I internally reject the idea. Does this happen to anybody else ?
20:04:43 <shapr> I suspect shape theory will be as important as type theory sometime soon.
20:04:53 <jyasskin> Darius: Google doesn't find anything for that string.. can you give me another clue?
20:05:43 <cm> Gahhh: yes :P
20:05:45 <shapr> Gahhh: if it's UML, sure. But that has more to with my corporate experience (read trauma)
20:05:52 <cm> Gahhh: similar happens for me with XML
20:06:16 <cm> it almost-triggers my spam filter, so the content has to be very convincing ;)
20:06:21 <shapr> Gahhh: what about Aardappel and friends?
20:06:24 <Gahhh> jyasskin, somehow I have a pdf file titled "Computational Category Theory" by Rydeheard and Burstall. It uses ML.
20:07:07 <Gahhh> shapr, I don't know what Aardappel is. Sounds extremely euro, tho. (dutch ?)
20:07:17 <cm> i want to get a graphics tablet in hope it might show me ways to connect my sketched designs (on paper) with my actual programs ;)
20:07:27 <dons> I'd like to automate: :.!echo ":t f" | ghci -v0 Foo.hs in vim.
20:07:27 <heatsink> shapr: shape theory as in Fish?
20:07:30 <shapr> Gahhh: exactly - http://wouter.fov120.com/proglang/index.html
20:07:32 <shapr> heatsink: yup
20:07:39 <shapr> FISh :-)
20:08:38 <heatsink> I don't think it really becomes useful until compiling a program onto multiprocessors starts becoming commonplace.
20:09:17 <shapr> How long until multicore is standard?
20:09:25 <cm> < a year?
20:09:39 <dons> you guys have to got start hacking GPUs!
20:09:43 <heatsink> Multicore hardware is coming out soon.
20:09:46 <dons> they're in your box right now :)
20:10:04 <cm> hacking both GPUs + multiprocessor systems is even more fun :P)
20:10:06 <heatsink> But the only retail apps that want the performance are games.
20:10:11 <dons> http://www.gpgpu.org/
20:10:12 <Gahhh> shapr, I'd have objections to aardappel as it seems to be actualluy about software. My gripe is with those "higher level, overview" type of ad hoc scribbles people make.
20:10:28 <shapr> oh, in that case I *totally* agree with you.
20:10:31 <heatsink> It's going to take a while for Microsoft code bloat to catch up with microprocessor performance ;)
20:10:32 <Gahhh> oops I meant no objections to aardappel
20:11:06 <shapr> heatsink: I betcha OpenOffice will be able to take advantage of multicore real fast.
20:11:12 <Gahhh> It's going to take a while until we realize the exact amount of penalties involved with sync'ing multiple cores.
20:11:23 <Darius> jyasskin: http://www.math.upatras.gr/~cdrossos/Docs/B-W-LectureNotes.pdf
20:11:41 <shapr> Bah, sync is nonoptimal. Declarative parallelism! w00!
20:11:49 <heatsink> shapr: could be.
20:11:55 <cm> non-locking queues! \o\ :p
20:12:13 <dons> damn it, why don't we have lambdas in zsh?
20:12:17 <Gahhh> data has to move. The enemy is von neumann, not single core ;)
20:12:22 <shapr> dons: I dunno, but I sure want that.
20:12:35 <shapr> Gahhh: how so?
20:12:49 <cm> my van neumaenner scale pretty well ;)
20:13:23 <heatsink> When you go above 32 processors in a shared memory system, performance stops increasing.
20:13:24 <shapr> With the parallel array library in GHC, you could likely carry around matching data and code. That would be nice for running on the Cell sidekick CPUs that have only 256k ram/cache/whatever.
20:13:30 <Darius> non-locking data structures in general
20:13:48 <heatsink> For some applications, it happens with as few as eight processors.
20:13:48 <shapr> heatsink: because of cache synchronization? or what?
20:13:53 <heatsink> shapr: yes.
20:14:11 <Gahhh> shapr, that assumes that the main thread can always be partitioned. Some apps just can't do that.
20:14:29 <shapr> What about hardware garbage collection? Then you don't have to sync caches. You could use non-cache-coherent NUMA just fine.
20:14:41 <jyasskin> Darius: from a cursory glance, that PDF looks like exactly what I was looking for.
20:14:44 <jyasskin> Darius: thanks
20:14:57 <cm> games can be segmented pretty well, I believe there is much potential in PS3/"next xbox"
20:15:00 <Darius> jyasskin: How good is your math?
20:15:00 <dons> has anyone written a quick script to add type sigs to top level decls in .hs files, using ghci :t
20:15:18 <shapr> Gahhh: Array ops in Parr can be transparently paralellized. Unroll and share.
20:15:40 <shapr> Admittedly, not everything is an array op, but I suspect it would cover many problems.
20:15:48 <cm> shapr: tell me that this isn't as much of a joke as OpenMP ;)
20:15:49 <heatsink> shapr: Are you talking referentially transparent code or normal code?
20:15:57 <Darius> Gahhh: Many apps can't do it simply because of the way they are written, not for inherent reasons.  Of course, there are inherently sequential programs.
20:16:34 <shapr> I'm talking about Haskell code mostly. I'm just thinking of the limits of what we know.
20:16:55 <shapr> Assuming Haskell code, assuming array ops... then what apps cannot benefite from multiple cores?
20:17:31 <cm> i believe it makes a lot of sense to parallelize at the higher levels
20:18:14 <jyasskin> Darius: I've taken group theory, but don't remember many of the theorems. I can usually follow proofs. I'm mostly having trouble with category theory because they're using a lot of new terms at once.
20:18:48 <cm> not like "oh here's a loop i could parallelize, let's do", but segmenting subsystems and letting them run independently. for said loops i'd rather use SSE2 or stuff. but maybe we're thinking different apps, i'm not concerned with number crunching really.
20:19:01 <Darius> jyasskin: Okay, then I doubt you'll have any trouble at all with the lecture notes (or at least no special problems).
20:19:08 <heatsink> Probably all apps can benefit from multicore, as long as someone writes them carefully so that they can get that benefit.
20:19:29 <Gahhh> Related article (second page has interview with Tim Sweeney of Epic games) http://www.anandtech.com/cpuchipsets/showdoc.aspx?i=2377&p=2
20:19:35 <cm> (for my sake of argument it doesn't matter whether you parallelize, or a program)
20:19:52 <cm> (and Tim Sweeney dislikes OpenMP as well :p)
20:20:17 <shapr> declarative paralellism is like garbage collection, it scales nicely, and is less work and less efficient than manual memory allocation.
20:20:22 <heatsink> OpenMP... isn't that like HPF for C?
20:20:38 <cm> I don't know HPF.
20:21:15 <heatsink> there's a FORALL construct that lets you execute an operation on all elements of an array in parallel.
20:21:24 <Pseudonym> I'd disagree with that.
20:21:36 <Pseudonym> GC isn't always less efficient than manual memory management.
20:21:43 <Pseudonym> It is for the same algorithm.
20:22:05 <Pseudonym> But GC lets you not structure your code around memory management, which often means you get to use different algorithms.
20:22:29 <Pseudonym> That's more true of some kinds of program than others.
20:23:05 <Gahhh> Isn't it also better sometimes ?
20:23:34 <cm> Pseudonym: For what programs do you think is it less true?
20:23:53 <neilc> GC isn't necessarily less efficient for the same algorithm, either
20:24:10 <neilc> memory allocation in a GC'd system is much simpler
20:24:29 <neilc> you also do away with the need for retail free()s
20:24:40 <neilc> admittedly it isn't a net win _most_ of the time...
20:24:56 <cm> it's kind of hard to draw the line between "GCed" and "manually-managed".
20:24:56 <Pseudonym> Well, I've been writing C++ for a living for some time now.
20:25:05 <Pseudonym> And I think I've only once written free() or delete in that time.
20:25:21 <Gahhh> stl and auto_ptr's etc ?
20:25:24 <Pseudonym> Right.
20:25:31 <neilc> fair enough, i'm speaking more of languages where you can't use the stack as easily (e.g. C)
20:25:34 <Pseudonym> auto_ptr, shared_ptr and custom jobs.
20:25:41 <cm> neilc: alloca?
20:25:48 <cm> (not standard yeye)
20:26:09 <Pseudonym> I think the one situation where GC fails is the timeliness factor.
20:26:26 <neilc> cm: yep, it would be nice otherwise...
20:26:33 <Pseudonym> Things which hold real-world resources don't get scavenged soon enough.
20:26:46 <Pseudonym> If it were only memory, it wouldn't be a problem.
20:26:50 <cm> neilc: it's supported on all platforms that i care about ;)
20:27:00 <neilc> cm: well, lucky you :)
20:27:01 <cm> neilc: another question, tho:
20:27:03 <cm> yep :)
20:27:51 <Gahhh> Pseudonym, can you not force releasing the resource ? I can destroy vectors before control reaches the end of the block.
20:28:02 <cm> neilc: suppose you do some simple stupid non-freeing block-allocator in C; it would have equally good performance characteristics as your GC example. is that manual memory management, or GC?
20:28:11 <cm> also, isn't auto_ptr etc. a form of GC?
20:28:32 <jyasskin> Gahhh: sure, you can force it, but C++ lets you scope your resource acquisition so you don't have to explicitly release it. Resources other than memory.
20:28:39 <neilc> cm: i would say that is manual memory allocation
20:28:52 <Pseudonym> You can force releasing resources, but then you're doing manual resource management.
20:28:54 <neilc> cm: but yes, that can be fast -- region-based allocation is very nice
20:29:12 <cm> yeah, mhm
20:29:45 <cm> i kinda like the flexibility about C++
20:30:04 <jyasskin> Pseudonym: Do you know of any systems that do GC and scavenge the real-world resources soon enough? Is something like `bracket` the standard?
20:30:31 <Pseudonym> Well, there are real-time collectors.
20:30:40 <Pseudonym> The overhead for them is a bit big for my taste.
20:30:48 <Pseudonym> The constant factors are big.
20:31:04 <Pseudonym> But having said that, having a guaranteed latency is worth it for some applications.
20:31:44 <jyasskin> I thought the real-time collectors just collected incrementally; not that they guaranteed that a given resource would be collected soon after the last reference goes away.
20:32:18 <shapr> In any case, I claim that threading is like malloc/free, and declarative parallelism is like GC.
20:32:39 <jyasskin> shapr: lol, back to the point?
20:32:41 <Pseudonym> I think that implicit parallelism is more like GC.
20:32:52 <Pseudonym> Where the compiler automatically parallelises your code.
20:33:16 <Pseudonym> Actually, no.  That doesn't scale nicely.
20:33:30 <heatsink> What doesn't?
20:33:40 <cm> shapr: ..and high-level "explicit" parallelism is like fork? :)
20:33:41 <Pseudonym> Automatic parallelisation.
20:34:06 <shapr> What about Nesl/Sisal/Nepal parallelisation? Does that scale?
20:34:28 <heatsink> Are we talking about scaling with program size or runtime size?
20:34:37 <Pseudonym> Yes, I think so.
20:34:48 <shapr> I'm talking about scaling with number of CPUs. I want my code to scale from 1 to 1024.
20:35:01 <Pseudonym> Nesl/Sisal/Nepal scales because it encourages you to write your program in the right way.
20:35:23 <Pseudonym> In fact, it probably scales better than HPF.
20:36:52 <Darius> It's pretty well accepted that taking significant advantage of parallelism requires human intervention.  So the important thing is making that easy and natural.
20:38:02 <Darius> But anyways, 'night.
20:39:15 <shapr> metaperl: who's Adam Turoff? Does he show up on #perl6?
20:46:23 <cm> nn
20:47:25 <dons> add type decls to top level vars in .hs src:
20:47:26 <dons> FILE=$*
20:47:26 <dons> DECL=`cat`
20:47:26 <dons> ID=`echo $DECL | sed 's/^\([^ ]*\).*/\1/'`
20:47:26 <dons> echo ":t $ID" | ghci -v0 -w $FILE
20:47:28 <dons> echo $DECL
20:47:48 <dons> in vim you'd say: :.!type.sh %
20:47:48 <shapr> waoh, cute
20:48:12 <shapr> That would be a *cool* Yi feature.
20:48:24 <dons> yeah :)
20:48:31 <dons> I will add .! soon
20:58:29 <shapr> @y0w!
20:58:29 <lambdabot> Sorry, I don't know the command "y0w!", try "lambdabot: @listcommands"
20:58:59 <TNKS> hello everybody.  I was wondering.  If I use "type" declarations (synonyms) I don't get the benefit of type checking, really.
20:59:03 <TNKS> right?
20:59:44 <shapr> Well, you do get the significant name part of the benefits.
21:00:35 <TNKS> I'm coding up an algorithm that is basically a simulation of a real phenomenon, solved iteratively
21:01:30 <TNKS> There's a bit of indexing involved for some of the functions, and I had the idea of using typing to make sure I don't accidently swap indices.
21:02:07 <TNKS> I don't think "type" protects me from this, but I think "data" is too much overhead.
21:02:11 <heatsink> you can use newtype for that.
21:02:29 <heatsink> You get typechecking, but no runtime overhead.
21:02:33 <TNKS> nice.
21:02:42 <TNKS> I guess that's what newtype was designed for, then?
21:03:00 <heatsink> I dunno.
21:03:42 <TNKS> it's good to know, though.
21:12:42 <gzl> for parsing, one should just use Parsec, right?
21:12:59 * Pseudonym shudders
21:13:28 <gzl> i'm trying to write something that converts wikitext into HTML.
21:13:35 <Pseudonym> I can't believe I wrote this.
21:13:38 <gzl> what would you recommend then?
21:13:45 <gzl> oh, you were shuddering at something else.
21:13:52 <Pseudonym> Yes.
21:15:16 <Pseudonym> http://lambda-the-ultimate.org/node/view/608#comment-5141
21:15:20 <Pseudonym> That's what I was shuddering at.
21:26:14 <shapr> Pseudonym: that's sort of... um.... sick?
21:26:30 <Pseudonym> A bit, yes.
21:30:18 <shapr> Maybe I shouldn't post this reply on LtU....
21:30:30 <shapr> "My experience with humans is that most do as little as possible to survive, and watch TV the rest of the time."
21:30:42 <shapr> Do you think I'll get flamed for that?
21:31:01 <Pseudonym> Maybe not on LtU.
21:31:12 <Pseudonym> BTW, it just goes to show that people want Slack.
21:31:13 <Gahhh> ooh... "friend".
21:31:26 <shapr> friend?
21:31:41 <shapr> oh
21:33:48 <Pseudonym> BRB
21:42:34 <Gahhh> I agree with you that the problem is artificial.
21:44:15 <Gahhh> It reminds me of http://acm.uva.es/p/v1/107.html, which I was using for haskell practice.
21:50:57 <shapr> That is cute.
21:55:33 * shapr cancels that post
21:55:34 <gzl> is there any way of testing strings with newlines in ghci?
21:55:41 <shapr> huh?
21:55:46 <gzl> sorry, badly phrased.
21:55:56 <ozone> autrijus: "Well, ever since the monadic revolution of '98"
21:55:59 <ozone> ^ quote of the day
21:56:10 <ozone> along with the one about parrot :)
21:56:13 <gzl> i want to test some function with some string input that contains newlines
21:56:42 <gzl> but you can't enter newlines within ghci, since it interprets that as running a command
21:57:02 <ozone> great interview too, btw
21:57:03 <shapr> ozone: I dunno, I think the comments in Class.hs count as pretty damn cool too.
21:57:15 <gzl> see what i mean, or am I blathering?
21:57:21 <ozone> shapr: what comments be they?
21:57:26 <shapr> http://svn.openfoundry.org/pugs/src/Class.hs
21:57:41 <heatsink> gzl: "\n"?
21:57:44 <shapr> yeah
21:58:15 * ozone spots unicode in there
21:58:16 <gzl> hm, i assumed it would just parse those as normal letters. i'll try that.
21:58:17 <ozone> huzzah
21:58:37 <gzl> oh, it does work. thanks, heatsink
21:58:42 <gzl> that was easy :)
21:59:02 <ozone> wow, even my terminal views utf-8 properly now
21:59:18 <ozone> it's always nice when you don't expect something to work, and it does, because you set up it up about a year ago and can't remember that you did
22:00:25 <shapr> I don't think that ever happens to me.
22:17:27 <gzl> hm, in Parsec, how would I match either char '\n' or end of input?
22:17:55 <shapr> option (char '\n')
22:18:02 <heatsink> There is a combinator for EOF
22:18:02 <shapr> ?
22:18:10 <shapr> @index isEOF
22:18:11 <lambdabot> GHC.Handle,System.IO,IO
22:18:17 <shapr> @index EOF
22:18:18 <lambdabot> Language.Haskell.Lexer,GHC.IOBase,Text.Read,Text.Read.Lex
22:18:23 <gzl> heatsink: yeah, there's eof, but you can't use it like a normal parser
22:18:37 <gzl> the type is different
22:18:59 <gzl> unless i'm being daft, which is possible too
22:19:21 <heatsink> what is the fully qualified module name?
22:20:06 <gzl> eof is in Text.ParserCombinators.Parsec.Combinator
22:22:05 <shapr> @index eof
22:22:05 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Combinator
22:22:14 <gzl> yeah.
22:22:45 <shapr> Features I want to add to HaddockModule - case insensitivity, substring search, by type search.
22:23:45 <heatsink> gzl: so you want (char '\n') <|> eof, except that doesn't typecheck, right?
22:23:56 <gzl> right.
22:24:12 <heatsink> do char '\n'; return ()
22:24:25 <heatsink> that has the same type as eof
22:25:11 <gzl> yes, but i need something that has the same type as (char '\n'), i think.
22:25:59 <gzl> right now it works if there's a trailing \n but not if the text just ends, i.e. matches "foo\n" but not "foo". that's the basic issue.
22:27:11 <heatsink> You can also make something like eof, that returns a character.
22:28:40 <heatsink> I'm out for tonight.
22:28:51 <gzl> i could, but then i'd have to use some of the slightly lower-level constructs in Parsec, which i'd like to avoid if possible. shouldn't there be a way of matching this simply with some primitive combinators? (incidentally, I tried the 'option' thing but I'm not sure if that does quite what I need)
22:28:56 <gzl> ah well.
22:30:22 <ozone> gzl: i usually just add a 'maybeWhitespace' parser after that
22:30:35 <ozone> maybeWhitespace = skipMany space
22:36:59 <gzl> trying. one sec.
22:38:35 <gzl> hm, no cigar. maybe I'm screwing this up? the full line is (item <- manyTill anyChar (char '\n')). making that (char '\n') into (char '\n' <|> skipMany space) results in a type error, just like with eof.
22:50:26 <shapr> Isn't there a parser that eats all whitespace?
22:51:29 <gzl> yes
22:51:45 <gzl> but i only want to eat \n or eof, not stuff like " " or \t
22:52:28 <shapr> oh
22:53:14 <gzl> the whitespace thing eats any character in " \v\f\t\r\n"
22:53:27 <gzl> i don't think that would match eof anyway
23:12:48 <shapr> good morning martink
23:13:20 <shapr> Man I love Sambal Oelek.
23:13:43 <shapr> oooh, today is Vah Gogh day on google. Love that logo!
23:14:59 <Gahhh> heh
23:16:04 <dons> @plugs map (*2) [0..10]
23:16:05 <lambdabot> Sorry, I don't know the command "plugs", try "lambdabot: @listcommands"
23:16:06 <lambdabot2> [0,2,4,6,8,10,12,14,16,18,20]
23:16:11 <dons> hehe
23:16:21 <dons> @kind (Int -> Int)
23:16:21 <lambdabot> Sorry, I don't know the command "kind", try "lambdabot: @listcommands"
23:16:22 <lambdabot2> (Int -> Int) :: *
23:16:23 <shapr> w00!
23:16:39 <shapr> lambdabot: @quit you're fired!
23:16:41 <gzl> shapr: oh yeah, that's a nice one :)
23:17:07 <dons> so I doubt all the modules are back online - some of them need data files I don't have
23:17:17 <shapr> definitions?
23:17:26 <dons> yeah, like yow etc.
23:17:29 <shapr> oh right
23:17:48 <shapr> I pulled the yow file directly from emacs21
23:18:07 <dons> ok.
23:18:12 <shapr> yow.lines
23:19:22 <dons> anyway, all the patches are sitting in my lambdabot repo
23:19:30 <shapr> I have a copy of definitions - http://www.scannedinavian.org/~shae/definitions
23:19:32 <shapr> awright!
23:20:50 <dons> I cleaned up the build system, made it compile -Wall, hacketty hacketty :)
23:20:55 <shapr> awesome!
23:21:28 <dons> Now i'll import some more of my modules today or tomorrow, and make sure everything is working that is supposed to be working
23:21:48 <dons> @plugs last [0 .. ]
23:21:53 <lambdabot2> bzzt
23:22:07 <nlv11757_> @plugs exit
23:22:09 <lambdabot2> bzzt
23:22:10 <gzl> hmm, this parsing works pretty well, except for that lingering eof issue and the fact that plaintext gets parsed with a newline between each character. :)
23:22:51 <dons> @plugs System.Cmd.system "ls"
23:22:53 <lambdabot2> bzzt
23:23:02 <dons> no IO for you!
23:23:08 <nlv11757_> @plugs bzzt
23:23:09 <lambdabot2> bzzt
23:23:31 <dons> it's almost as bad as ghc's error msgs ;)
23:23:44 <nlv11757_> :)
23:23:57 <nlv11757_> only readable when you're a compiler builder sometimes hehe
23:24:07 <dons> @eval 1 + 2
23:24:08 <lambdabot2> 3
23:24:13 <dons> good.
23:24:13 <ozone> dons: suggestion to replace message with "SECURITY VIOLATION: YOUR EMAIL ADDRESS AND IP HAVE BEEN LOGGED.  YOU HAVE 24 HOUR MAKE YOUR TIME"
23:24:20 <dons> oh man!
23:24:45 <dons> I could certainly have that returned when someone tries an IO type...
23:24:57 <nlv11757_> dont abuse the lambda
23:24:57 <nlv11757_> :)
23:25:36 * shapr thinks
23:25:39 <dons> @plugs let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20 :: Int
23:25:41 <lambdabot2> 10946
23:26:07 <ozone> @plugs [1..]
23:26:15 <lambdabot2> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
23:26:15 <lambdabot2> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
23:26:15 <lambdabot2> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
23:26:15 <lambdabot2> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
23:26:15 <lambdabot2> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
23:26:15 <lambdabot2> 118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,
23:26:17 <lambdabot2> 136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,
23:26:19 <ozone> ahahaha
23:26:19 <lambdabot2> 154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,
23:26:19 <shapr> yow!
23:26:21 <lambdabot2> 172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,
23:26:23 <lambdabot2> [60528 @more lines]
23:26:23 <ozone> ahahahahahaha
23:26:24 <mflux> great
23:26:26 <ozone> DEAFEATED!
23:26:28 <ozone> awww
23:26:32 <ozone> maybe not
23:26:36 <ozone> only 60528 more lines?
23:26:37 <mflux> oh, it had some stupid limit :-/
23:26:39 <shapr> That's the record number of lines I've ever seen.
23:26:52 <dons> mflux: the limit isn't so stupid...
23:26:57 * ozone thinks dons is trying to redefine the meaning of [1..]
23:26:59 <mflux> oh?
23:27:06 <dons> it's 3 seconds you've got to compute in
23:27:31 <ozone> naw, the limit is silly
23:27:34 <ozone> you really should remove it, don
23:27:36 <dons> :P
23:27:47 <dons> one good way to chew up my ip quota..
23:27:51 <mflux> who writes a neat ascii-outputting raytracer for it
23:27:53 <shapr> You have an IP quota?
23:28:00 <nlv11757_> @eval [1..] !! 1634256
23:28:01 <lambdabot2> (line 1, column 4):
23:28:01 <lambdabot2> unexpected "."
23:28:01 <lambdabot2> expecting simple term
23:28:07 <nlv11757_> @eval [1 .. ] !! 1634256
23:28:07 <dons> through unsw, yeah.
23:28:08 <lambdabot2> (line 1, column 5):
23:28:08 <lambdabot2> unexpected "."
23:28:08 <lambdabot2> expecting simple term
23:28:15 <nlv11757_> @plugs [1 .. ] !! 1634256
23:28:16 <shapr> @eval [1..] ! 99999999999
23:28:17 <lambdabot2> bzzt
23:28:17 <lambdabot2> (line 1, column 4):
23:28:17 <lambdabot2> unexpected "."
23:28:17 <lambdabot2> expecting simple term
23:28:24 <nlv11757_> @plugs [1..] !! 1634256
23:28:27 <lambdabot2> bzzt
23:28:30 <shapr> @eval [1..] !! 99999999999
23:28:31 <lambdabot2> (line 1, column 4):
23:28:31 <lambdabot2> unexpected "."
23:28:31 <lambdabot2> expecting simple term
23:28:39 <nlv11757_> @plugs [1..] !! 16
23:28:41 <lambdabot2> 17
23:28:43 <nlv11757_> hmmmm
23:28:44 <nlv11757_> fishy
23:28:48 <dons> 3 seconds, dude.
23:28:59 <dons> ;)
23:29:04 <shapr> That's pretty smart.
23:29:07 <ozone> @plugs [| 'a' |]
23:29:09 <lambdabot2> bzzt
23:29:12 <ozone> dawww
23:29:13 <nlv11757_> suddenly, it wasnt haskell anymore :P
23:29:18 <dons> nah, no TH, just -fglasgow-haskell
23:29:24 <nlv11757_> @plugs [1..] !! 16333
23:29:25 <lambdabot2> 16334
23:29:27 <nlv11757_> @plugs [1..] !! 163333
23:29:29 <lambdabot2> bzzt
23:29:35 <shapr> Doesn't -fglasgow-haskell imply -fth?
23:29:36 <dons> I could turn on TH I guess. not sure how safe that is though...
23:29:41 <nlv11757_> @plugs length [1..]
23:29:42 <mflux> @plugs [1..] !! (16333*16333)
23:29:46 <lambdabot2> bzzt
23:29:47 <ozone> dons: just make sure you give us qIO
23:29:50 <lambdabot2> bzzt
23:29:58 <dons>  @plugs $( [| 'a' |] )
23:30:09 <dons> bot?
23:30:17 <nlv11757_> dead
23:30:23 <nlv11757_> space
23:30:25 <dons> @kind Int
23:30:26 <lambdabot2> Int :: *
23:30:29 <dons> ?
23:32:11 <dons> ok. what else to check. hmm.
23:32:13 <shapr> waow
23:32:13 <dons> @yow
23:32:17 <dons> hey!
23:32:18 <shapr> <lambdabot2> gcc: fork: Resource temporarily unavailable
23:32:18 <shapr> <lambdabot2> Compiled, but didn't create object file `/tmp/MGEiQ23924.o'
23:32:25 <dons> Exception: yow.lines: openFile: does not exist
23:32:31 <shapr> yeah, I never added error checking.
23:32:32 <dons> shapr: bad!
23:32:34 * shapr blushes
23:32:36 <ozone> norti shapr
23:33:02 <ozone> dons: do you want me to get a pick and get medieval on his swedish ass?
23:33:25 <shapr> yipes!
23:33:31 <dons> hehe
23:33:40 <dons> @karma- shapr
23:33:41 <lambdabot2> shapr's karma has been decremented.
23:33:48 <shapr> I'm still kinda impressed with the error I got.
23:33:53 <dons> for fork bombing my machine.
23:33:59 <shapr> oh, is that what happened?
23:34:11 * shapr grins
23:34:13 <dons> yeah, I think it might have been too many procs
23:34:31 <shapr> @cmafihe xu do tavla mi bau la lojban
23:34:39 <shapr> That's a no.
23:34:58 <shapr> @arr
23:35:00 <lambdabot2> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
23:35:02 <shapr> yay!
23:35:14 <shapr> @fortune
23:35:16 <shapr> oops
23:35:20 <shapr> I really gotta fix that.
23:35:23 <dons> yeah.
23:35:33 * shapr grins embarassedly.
23:35:41 <dons> patches!
23:35:46 <shapr> right away
23:36:04 <dons> now, why didn't cmafihe work, I wonder
23:36:27 <shapr> probably because you don't have jbofihe and the lojban-common files installed.
23:36:42 <dons> true.
23:36:50 <shapr> Not terribly important for Haskell-oriented use though.
23:37:12 <dons> ok
