00:04:02 * xerox should have checked the libc version before dowloading Megs and Megs of GHC :)
00:04:32 <dons> can you grab it from your package system?
00:04:52 <xerox> dons: I'm not the administrator on the machine I'd like to run lambdabot on :\
00:09:09 <Svrog> hi everyone
00:09:18 <xerox> Hello Svrog
00:11:18 <Svrog> im a bit confused about something - i was just looking through ghc 6.4 sources and under libraries/monads/Monad directory there's a number of things that just aren't present in ghci - in particular when i try to run the examples, none of them work
00:11:51 <nlv11757_> do you have ghci 6.4 ? :)
00:11:55 <Svrog> yes
00:12:25 <nlv11757_> maybe some things are just not meant for interactive mode but merely to compile.
00:12:27 <nlv11757_> i dont know
00:12:38 <Svrog> i tracked down the missing functions to modules Monad.Prelude which isn't documented anywhere but it exists in libraries/monads/Monad directory
00:12:55 <Svrog> module*
00:13:10 <dons> Thanks Heffalump. Applied.
00:13:52 <Svrog> nlv11757_: well the examples don't seem to have a main function which made me assume they weren't meant to be compiled
00:14:34 <nlv11757_> ow then its strange indeed Svrog
00:14:41 <nlv11757_> it's
00:19:07 * boegel jumps
00:19:36 <Si\> does anyone know if there's a practical reason why import splices are not implemented in TH?
00:19:44 <ozone> import splices?
00:20:19 <Si\> as in "import Data.List"
00:20:36 <ozone> oh.  no, no idea
00:20:39 <ozone> email the TH list
00:20:42 <Si\> have done
00:21:06 <Si\> I need them so I can automatically generated Haskell code for XML-Schema
00:21:44 <Si\> and I reckon you could use them to do this "import via URL" idea
00:22:34 <dons> lambdabot hackers: what's the spec for the @uptime plugin?
00:22:44 <boegel> @uptime
00:22:45 <lambdabot> Sorry, I don't know the command "uptime", try "lambdabot: @listcommands"
00:23:32 <jlouis> dons: is the @fact module compiled in by default?
00:24:14 <dons> nope. You can enable it in BotConfig.hs
00:24:20 <Svrog> ok - i think i figured it out - it's not a part of ghc at all - it's a 3rd party lib called monadLib that seems to be included with ghc in source form but isn't present in the binaries
00:24:20 <jlouis> ok
00:24:33 <dons> I don't know why it isn't enabled by default, I presume there was some reason
00:24:43 <jlouis> dons: postgresql connectivity
00:24:49 <dons> ok.
00:24:58 <dons> Yep, I see.
00:25:01 <jlouis> It hardcodes username/password etc
00:25:20 <dons> to quote shapr, "quick ugly hack to get factoids in lambdabot
00:25:22 <xerox> dons: what do you use to get lambdabot respawning if @quit-ted ?
00:25:34 <dons> while true ; do ./lamdabot ; done
00:25:45 <jlouis> and uses passwords, my my. This must be from a Linux user
00:25:51 <jlouis> (getepeerid) ;)
00:26:05 <dons> hehe
00:26:32 <ozone> dons: if you are leet, you would write echo 'while true; do ./lambdabot; done' > run-lambdabot; screen -S "lambdabot" run-lambdabot
00:26:35 <ozone> :)
00:26:35 <jlouis> getpeerid() even
00:26:47 <xerox> What's @fact ?
00:26:58 <jlouis> getpeereid(), 3rd times a charm
00:27:19 <dons> ozone, good idea.
00:27:45 <dons> ozone: see I had the mac-a-bot up a few mins ago?
00:27:50 <ozone> dons: i do that for e.g. irc on the g5.  very useful
00:27:51 <ozone> yeah
00:27:53 <dons> nice to see it's portable.
00:27:56 <ozone> do you want me to upgrade to ghc 6.4, btw?
00:28:01 <dons> yes please
00:28:15 <Svrog> im off - see ya later people
00:28:16 <jlouis> dons: well there be ghc6.4 packages for OpenBSD soon?
00:28:19 <dons> i'm currently using seafood's build.
00:28:36 <ozone> dons: right
00:28:36 <dons> jlouis: not _really_ soon, maybe a couple of weeks.
00:28:41 <ozone> then you get the joy of playing with -dynamic :)
00:28:42 <jlouis> dons: ok ;)
00:28:53 <dons> until then, use the nightly stable from the Haskell/OpenBSD page.
00:29:01 <jlouis> ok
00:29:34 * xerox compiling hs-plugins
00:29:37 <jlouis> If we get rid of postgresql in the fact module, can we get rid of everything postgresql then?
00:30:12 <dons> I presume so - you'll have to ask shapr on that.
00:30:46 <jlouis> ; grep Database * | wc -l
00:30:46 <jlouis>        2
00:30:54 <jlouis> and that is in the fact module
00:31:02 <jlouis> Hmmm
00:31:32 <jlouis> Maybe one should think about adding a simple persistence layer
00:31:55 <dons> yeah, there's been a small amount of discussion
00:33:05 <xerox> dons: I need anything else than putting runplugs in the $PATH?
00:33:06 * jlouis ponders the situation
00:33:41 <dons> xerox: and ghc needs to be available
00:34:02 <dons> jlouis: i'm inclined to derive Binary on state components, SerTH is another option.
00:34:11 <dons> making it all automagic needs thinking
00:34:40 <dons> a save/restore hook for the typeclassed modules seems reasonable
00:34:42 <xerox> /home/xerox/ghc-6.2.2/lib/i386-unknown-linux/include/HsReadline.h:5: readline/readline.h: No such file or directory
00:34:47 <xerox> /home/xerox/ghc-6.2.2/lib/i386-unknown-linux/include/HsReadline.h:6: readline/history.h: No such file or directory
00:34:48 <ozone> what's SerTH?
00:34:48 <xerox> hmpf..
00:34:52 <dons> no readline.
00:34:59 <xerox> Yep, I hate that admin.
00:35:05 <dons> ozone: a TH Binary deriver by musasabi
00:35:09 <dons> uber-nifty
00:35:13 <ozone> glad to know that readline causes problems on platforms besides mac
00:35:21 <ozone> dons: hmm, sounds juicy
00:35:57 <jlouis> dons: indeed. Save/Restore hooks needs to be there anyway for persistence
00:37:13 <dons> there's not too many state components to worry about - basically just the global irc state. so if we can make sure that is Binary derivable, then it might be fairly easy to write it and restore it
00:37:49 <dons> maybe SerTH would be better, as Binary requires DrIFT.
00:37:55 <dons> Not sure on that point yet.
00:39:06 <jlouis> Will we always have state in-memory?
00:39:14 <jlouis> I mean, the factoid database might grow large
00:39:32 <dons> yeah, that's true.
00:39:45 <dons> individual plugins might have special requirements
00:39:50 <jlouis> Not that I think it matters that much. We need many facts to break 1Mb
00:40:00 <dons> most have no state, or very little
00:40:44 <jlouis> On disk database maps from strings to strings through a double hashing scheme (Dan J. Bernstein - cdb)
00:40:49 <jlouis> ?
00:40:59 <xerox> lmbdabot works! Great.
00:41:00 <jlouis> Do we need more than that in practice?
00:41:21 <dons> currently show/read just works (.e.g. @quote)
00:41:32 <jlouis> nod
00:41:46 <dons> and Binary is a compressed version of that, effectively.
00:42:09 <dons> I'm sure there are fancier techniques that could be employed.
00:42:19 <jlouis> Hmmm, I'll think about it a bit
00:42:41 <dons> have a look at how state is maintained in the bot currently
00:42:56 <dons> this process needs to be fairly automatic.
00:43:10 <Igloo> dons: Did you see plugs allow unsafeCoerce#, BTW?
00:43:12 <dons> ideally, new modules could just 'derive Binary' on their state components
00:43:21 <dons> Igloo: yeah, silly bug, fixed
00:43:28 <Igloo> Cool
00:43:40 <dons> I'd let GHC.* into the module state for some unfathomable reason
00:44:00 <dons> which gave TheHunter free reign :)
00:44:45 <dons> @plugs ((unsafeCoerce# 10) :: Char)
00:44:46 <lambdabot> bzzt
00:45:10 <Heffalump> what modules are imported?
00:45:18 <dons> @plugs GHC.Base.assert (0==1) (1)
00:45:19 <lambdabot> bzzt
00:45:46 <dons> some of Data.*
00:46:01 <dons> i'll have to tie it down further, no doubt.
00:46:32 <xerox> @kind Either Int
00:46:33 <lambdabot> Either Int :: * -> *
00:48:16 <basti_> wow :)
00:48:24 <basti_> @kind Either
00:48:25 <lambdabot> Either :: * -> * -> *
00:48:31 <Heffalump> @kind Monad
00:48:32 <lambdabot> bzzt
00:48:38 <Heffalump> cool.
00:48:40 <basti_> @kind Control.Monad
00:48:41 <lambdabot> bzzt
00:48:46 <basti_> where is it?
00:48:48 <Heffalump> it's a type class, not a type constructor
00:48:52 <Heffalump> so it doesn't have a kind
00:48:57 <basti_> oh
00:48:58 <basti_> yes.
00:49:02 <basti_> -nod-
00:49:17 <Heffalump> @kind ST
00:49:18 <lambdabot> bzzt
00:49:26 <Heffalump> @kind Data.ST
00:49:27 <lambdabot> bzzt
00:49:31 <Heffalump> @kind Control.Monad.ST
00:49:32 <lambdabot> bzzt
00:49:36 <basti_> @info Monad
00:49:37 <lambdabot> Sorry, I don't know the command "info", try "lambdabot: @listcommands"
00:49:43 <basti_> ah yes.
00:49:46 <basti_> ;)
00:50:14 <dons> maybe I won't have to tie it down further - the pure type of the @plugs value should be fairly tight
00:50:22 <dons> even if IO functions are in scope
00:50:36 <dons> just as long as no modules are reexporting coerce functions
00:52:26 <Heffalump> or unsafe
00:52:27 <dons> @plugs ((error "throw me") :: ())
00:52:28 <lambdabot> bzzt
00:52:42 <dons> oh, that actually runs, but returns non-zero.
00:52:45 <Heffalump> being able to actually report exceptions would be nice
00:53:02 <Heffalump> I found I had to use $!! to force evaluation at the right point to do that
00:53:12 <dons> ok.
00:53:26 <Heffalump> (i.e. run user computation, force evaluation, catch errors around that, and show the error instead if one is caught)
00:53:51 <Igloo> ($!!)?
00:54:05 <dons> ah, we currently ignore stderr from runplugs. that's where the Fails are going
00:54:20 <Heffalump> like $! but with DeepSeq
00:54:26 <Igloo> Ah
01:00:42 <dons> @plugs (error "Throw me" :: ())
01:00:43 <lambdabot> Fail: Throw me
01:00:55 <dons> good. we get stderr.
01:02:18 <xerox> Great.
01:11:22 <xerox> metaperl_: I replyed to some comment on your post: http://sequence.complete.org/node/42
01:18:44 <basti_> is everyone happily hacking lambdabot yes? ;)
01:19:15 <dons> I've got a few patches, and I'm still hacking away.
01:22:25 <xerox> dons: My "Yow.hs patch" wasn't completely right.. :(
01:22:43 <dons> yeah, why? :}
01:22:58 <xerox> I just tried :)
01:23:15 <dons> what happened?
01:23:27 <xerox> I saw you incorporated it, in a sane way.
01:23:56 <dons> oh, I just added some catch statements around the file read ops
01:24:32 <dons> you didn't send me a patch, did you?/
01:24:46 <xerox> Hm no, I did it in a similar way
01:24:56 <dons> ok.
01:25:13 <xerox> I mean, I put a catch, but I used return ["Couldn't find .."] Because the return type is IO [[Char]].
01:25:22 <dons> still need to fix the "index too large" problem, if you'd like to look at that
01:25:42 <xerox> I'll try.
01:33:54 <vegai> auchie. I get a segfault from darcs pulling lambdabot2
01:34:06 <dons> darcs version?
01:34:28 <vegai> 1.0.2rc3
01:34:49 <dons> hmm. what OS?
01:34:56 <vegai> Arch Linux
01:35:45 <xerox> How to get the last patches for lambdabot, I saw you added some things.
01:35:53 <xerox> I missed a '?' somewhere ;)
01:36:16 <Igloo> darcs pull
01:36:24 <Igloo> vegai: On x86?
01:36:38 <dons> I can't reproduce this here. get and pull work for me.
01:41:54 <xerox> dons: I think I fixed it.
01:42:10 <xerox> Oh. No, nevermind :)
01:51:32 <vegai> Igloo: yes
01:57:27 <xerox> rawfs <- C.catch (readFile filename) (\_ -> return "Couldn't find yow file")
01:57:54 <xerox> Is it right to think that `return' returns the "Couldn't .." string into rawfs ?
01:58:15 <xerox> (If something goes wrong and the handler is called)
01:58:24 <dons> yep.
01:59:28 <xerox> Ah-ha.
02:00:08 <Heffalump> yes (but in general be careful of laziness)
02:06:27 <xerox> dons: how do I print messages on stderr, for debugging?
02:07:30 <xerox> dons: yay, fixed :D
02:08:44 <dons> :)
02:10:58 <araujo> Good morning.
02:11:14 <xerox> 'morning
02:15:52 <xerox> @pointless \f g h x y z -> f (g (h x y z))
02:15:53 <lambdabot> (. ((.) . (.) . (.))) . (.) . (.) . (.) . (.)
02:16:03 <Itkovian> that seems rather pointy ;-)
02:16:27 <lightstep> @pointlexx \c f x y = f x `c` f y
02:16:28 <lambdabot> Sorry, I don't know the command "pointlexx", try "lambdabot: @listcommands"
02:16:32 <lightstep> @pointless \c f x y = f x `c` f y
02:16:33 <lambdabot> (line 1, column 10):
02:16:33 <lambdabot> unexpected "="
02:16:33 <lambdabot> expecting pattern or "->"
02:16:39 <lightstep> @pointless \c f x y -> f x `c` f y
02:16:40 <lambdabot> flip s id . ((flip . ((.) .)) .) . (.)
02:16:49 <xerox> It *is* pointless.
02:19:20 <dons> @seen xerox
02:19:21 <lambdabot> I haven't seen xerox
02:19:32 <dons> @seen lambdabot
02:19:33 <lambdabot> Yes, I'm here
02:19:37 <dons> @seen dons
02:19:37 <lambdabot> I haven't seen dons
02:19:40 <dons> hmm.
02:19:54 <sqrt> hehe. dons' invisible.
02:20:45 <dons> let's see.
02:20:47 <dons> @seen dons
02:20:48 <lambdabot> I haven't seen dons
02:20:59 <dons> interesting
02:21:04 <sqrt> @seen noclouds
02:21:05 <lambdabot> I haven't seen noclouds
02:21:25 <dons> oh, I know.
02:21:39 <dons> @quit you die!
02:22:02 <dons> @seen dons
02:22:03 <lambdabot> dons is in #haskell. Last spoke just now.
02:22:15 <dons> thankyou bot. @dynamic-reload should reinit.
02:23:50 <vegai> ok, the darcs segfaults are caused by darcs taking 99% of CPU for a long time, which causes my poorly ventilated box to overheat...
02:23:57 <dons> whoa
02:24:19 <dons> @seen vegai
02:24:19 <lambdabot> vegai is in #haskell. Last spoke 29 seconds ago.
02:24:32 <dons> so, vegai, what can be done I wonder.
02:25:36 <dons> water cooled haskell machine?
02:25:49 <vegai> heh
02:26:09 <vegai> I'm gonna be in trouble when the summer comes
02:26:20 <vegai> @version
02:26:21 <lambdabot> Thu Mar 31 14:53:46 EST 2005, GHC 6.4 (OpenBSD i386)
02:26:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:27:46 <sqrt> i don't get why your machine overheats. isn't it built for using all of it's cpu?
02:27:50 <vegai> a get works fine
02:28:05 <vegai> obviously not, sqrt
02:28:25 <lightstep> but how does heating cause segfault?
02:28:30 <vegai> the case sucks (sorry about pun)
02:28:34 <sqrt> that's ... bad.
02:28:39 <lightstep> does your oom figure out what process heats the machine most?
02:29:04 <df_> oom wont segfault apps
02:29:10 <vegai> yes, there are tiny firefighters in there
02:29:56 <dons> I know I've got tiny teensy firefighters fighting off ghc build blazes
02:31:55 <sqrt> so you sould actually "tune" it... down..
02:31:59 <vegai> ok, lambdabot works now
02:32:14 <dons> did spraying water on the box help ?
02:32:43 <sqrt> lambdabot should have an extendable wtf database.
02:33:07 <vegai> I applied some of your icy wit on it :P
02:33:14 <dons> hohoho :)
02:34:03 <sqrt> typically men. he just said sorry for the bad pun five minutes ago and then he makes an other.
02:34:28 <sqrt> :) ;)
02:35:28 * dons -> food
02:40:27 * vegai smirks
03:10:30 * shapr grumbles
03:10:40 <shapr> I've been sick for more than a week. This sucks!
03:16:26 <Itkovian> whoops.
03:16:46 <wilx> You should be in bed and not in front of screen then :)
03:16:50 <ibid> that sounds like Itkovian made shapr sick by accident :)
03:16:51 <Itkovian> fill those buckets!
03:16:58 <shapr> I am in bed, and in front of the screen both :-)
03:17:03 <Itkovian> ibid: he may have seen a pic of me
03:17:14 <ibid> ;)
03:17:25 <Itkovian> shapr: u should sleep - some of us don't have that luxury ;-)
03:18:20 <shapr> I don't really have that luxury either. I can work towards my deadlines from bed.
03:18:48 <shapr> It's hard to take sick days when you're self-employed.
03:19:10 <Itkovian> true
03:19:41 <sqrt> it's hard to take sick days when you're alone with a responsability. nomatter what.
03:22:58 <shapr> Yeah, I agree with that.
03:23:01 <shapr> salut Skal
03:23:15 <shapr> sqrt: But not everyone thinks that way.
03:24:31 <shapr> sqrt: Are you learning Haskell? long-time user?
03:25:05 <sqrt> i am a long time user of category theory. and theoretical cs student...
03:25:29 <sqrt> some times the discussion does fall on those topics.
03:25:59 * sqrt plans to improve her Haskell some time soon also.
03:26:45 <shapr> If you have any Haskell questions, we'd be happy to help.
03:26:51 <sqrt> thank you.
03:27:16 <sqrt> if you have any mathematical questions i'd be happy to help also.
03:27:25 <shapr> How do I make a type-safe penrose tile?
03:27:45 <shapr> I have some ideas, but I think they're less than elegant.
03:28:02 <sqrt> but speaking of responsibility, i have a meeting in ... very short time.
03:28:09 <shapr> I guess that's not really a math question.
03:29:00 <shapr> Well, nice to meet you.
03:29:09 <sqrt> that sounds funny. I'll think about that.
03:29:16 <sqrt> nice to meet you too.
03:29:40 <sqrt> gotta go, have some warm tea and some sleep and get better!
03:30:02 <shapr> :-)
03:48:01 <shapr> hiya metaperl_
03:48:11 <shapr> metaperl plus overscore.
03:48:16 <metaperl> hi
03:49:21 <shapr> Btw, I have an odd suggestion. I was thinking of proposing to Rob that if he can learn everything Haskell in Perl, then it doesn't make sense that it should take him any time to actually learn to use Haskell.
03:49:56 <shapr> I was thinking that I could propose a userstudy where I learn Perl 5 and he learns Haskell.
03:50:14 <metaperl> well, both languages compute the same functions...
03:50:26 <metaperl> there is a good free book on Perl 5
03:50:33 <metaperl> there is no such thing for Haskell
03:50:36 <shapr> But they encourage dramatically approaches.
03:50:38 <metaperl> the Thompson book is worth the money
03:51:04 <shapr> Do you think Rob would go for the tradeoff?
03:51:24 <metaperl> he might... he is CEO of a busy consulting firm in Colorado
03:51:31 <metaperl> but he is certainly keen on learning
03:51:35 <metaperl> I think he would
03:51:43 <metaperl> lesson by lesson in the mailing list would be best
03:51:59 <shapr> Yeah, I agree.
03:53:53 <shapr> Also, I think users of every language claim that it can cover all paradigms.
03:54:21 <dons> yeah, that's often heard on the sed list
03:54:38 <metaperl> shapr: http://learn.perl.org/library/beginning_perl/
03:54:38 <shapr> and in the Python world, and the Lisp world, and ...
03:55:04 <Itkovian> to add a few words to that ...
03:55:19 <Igloo> dons: Which list?
03:55:55 <Itkovian> lately I write my scripts in Haskell, where I find the core stuff I need is easier done ... I used to write those things in perl, where I/O is easier done.
03:55:55 <metaperl> I keep trying to verify a statement autrijus made awhile back because I want to say it now: you can abstract anything in Haskell... not so in Perl
03:56:12 <dons> I'm teasing really, but the sed list is sed-users (http://sed.sourceforge.net/#mailing)
03:56:13 <Itkovian> It all depends on your needs.
03:56:32 <dons> it's fun if you want little sed programming challenges
03:56:37 <Itkovian> I think people who claim that language L is fit for all, well, they should stick to writing binary.
03:56:45 <shapr> You can't abstract a bunch of stacked case statements in Perl unless you use Greg Bucholz' monads in Perl.
03:56:51 <Igloo> Oh, I was looking forward to seeing crazy people explaining how object orientation works in sed  :-(
03:57:06 <Igloo> (we all know it's really just a functional language in the pattern buffer monad, right?  :-)  )
03:57:11 * shapr laughs
03:57:14 <dons> that's TRUE!
03:57:48 <Igloo> Ick, yahoogroups
03:57:53 <dons> yeah.
03:58:10 <shapr> Igloo: many of the interesting yahoogroups also appear on gmane.org
03:58:15 <vegai> hmm, I really wouldn't want to use autotools
03:58:18 <dons> I'm not actually subscribed anymore :} but some of the sed implementors hang out there
03:58:25 <dons> bonzini of gnu sed, for one.
03:58:25 * vegai wonders if there's something better that works fine with ghc 
03:58:39 * Igloo isn't in the news habbit these days
03:59:04 <shapr> gmane.org does read-only web-based too.
03:59:07 <Igloo> vegai: To do what?
03:59:08 <vegai> has anyone tried the 'premake kit'?
03:59:26 <vegai> Igloo: configuring of a source package
03:59:50 <metaperl> Greg Buchholz says Monads are ways of carrying around hidden state. I have learned about Monads as Containers so his statement loses me
04:00:09 <xerox> Yep, sed.user is on gmane.
04:00:15 <Igloo> vegai: If it's just Haskell code then making a cabal package should do once the cabal tools mature
04:01:12 <dons> hmm. google's front page: "Site owners, earn revenue."
04:01:35 <vegai> ah, right. I'll check chat out
04:01:43 <Cale> metaperl: well, that statement only applies to a few monads, but it can be true in specific cases.
04:02:12 <Philippa> yeah, it's not very well hidden in the List monad...
04:02:15 <metaperl> oh, his entire presentation of monads in Perl is predicated on that statement
04:02:28 <metaperl> a List is a container...
04:02:40 <Cale> metaperl: There is another view of monads as an abstraction of computation, which is a better generalisation along that line of thinking.
04:02:42 <metaperl> for indecision about the number of results to return
04:02:52 <Philippa> right. Many container implementations have some hidden data involved, but hey
04:02:55 <metaperl> yes, the nomaware article goes into that
04:02:58 <Philippa> Cale: much, much better IMO
04:03:17 <Philippa> in fact, I prefer the idea that monads're all about semantics...
04:03:35 <Philippa> "alter the language you're working in", if you like (which doesn't necessarily work so well on top of perl)
04:04:52 <xerox> metaperl: did you see the reply to the reply to your post?
04:05:01 <metaperl> which?
04:05:08 <xerox> http://sequence.complete.org/node/42
04:05:16 * metaperl looks
04:06:36 <Cale> I think that monads really have to be looked at simultaneously as containers and a mechanism for abstracting computation, because really they're neither, but the use of both analogies comes close enough to the truth :)
04:06:51 <Cale> (at least in the context of programming)
04:06:56 <xerox> Cale: what's the truth? :)
04:07:10 <mflux> truth is out there?
04:07:17 <mflux> oh, 'what', not 'where'
04:11:10 <Cale> Well, the real definition of monad applies to any category, not just the category of types and computable functions in some programming language.
04:11:46 <Philippa> and is thus meaningless to those who don't already grok category theory
04:11:54 <xerox> Can you elaborate, or is it too deeply obscure mathematically speeking?
04:11:59 <xerox> Okay :)
04:12:00 <Philippa> it has a fairly direct interpretation in a computational context though
04:13:58 <Philippa> if you treat a category as representing a language's semantics, you get something that embeds haskell in <other language> and <other language> in haskell (the latter is just 'programs in it are valid haskell values'), and has fmap and join as operations (join tells you that <other language> has to support higher-order programs)
04:15:18 <Cale> A category is basically a collection of objects and arrows, which obey the basic rules of sets and functions. (associativity, ability to compose whenever it makes sense, existence of identities)
04:15:36 <Philippa> the first bit is just the existance of return coupled with the fact you get back something Haskell can manipulate. >>= can be defined in terms of fmap and join, but typically isn't on grounds of efficiency (you can define fmap and join in terms of >>= too)
04:16:46 <Cale> In mathematics, there are many good examples of categories. The category of vector spaces over a given field and linear transformations between them, the category of groups and group homomorphisms, the category of topological spaces and continuous maps, and many many others.
04:17:18 <Philippa> Cale: does my description make sense in a computational setting as far as you're concerned?
04:17:43 <Philippa> assuming that one of the two categories involved will always be Haskell?
04:18:04 <TheHunter> Philippa, I doubt that. If the compiler manages to inline the definition of fmap and join, the resulting code should be identical to what the "human inliner" does when he defines (>>=).
04:18:21 <Cale> Philippa: I think so
04:18:30 <Philippa> TheHunter: that can't always be assumed though
04:18:45 <Philippa> not everybody's using GHC
04:19:34 <TheHunter> i don't think ghc actually does it, but that's because monads are defined in terms of (>>=) and return.
04:19:57 <Philippa> but it would if you defined join and fmap and defined >>= in terms of them
04:20:01 <TheHunter> if you don't use GHC, you usually don't care about performance.
04:20:29 <Philippa> not quite true, there comes a point where something's too damn slow for comfort regardless
04:20:47 <Philippa> I use GHCi a lot, but if it starts to be quicker to compile and execute I'll do that...
04:21:52 <TheHunter> well, f =<< m = join $ f `fmap` m shouldn't you cost that much performance anyway.
04:21:58 <Cale> Philippa: by the way, the fact that it's an endofunctor gives you fmap, and return is part of what makes it a monad in particular.
04:22:03 <TheHunter> fmap is usually fast.
04:22:05 <mflux> whatever conversions there needs to be done to the code should be done by the compiler, because humans err ;)
04:23:36 <xerox> @type System.Random.randomInt
04:23:41 <lambdabot> bzzt
04:24:35 <dons> there's no randomInt
04:24:56 <shapr> There is chooseR
04:25:04 <Philippa> mflux: in the case where it's easier to define join and fmap on a monad and makes more sense, I'm tempted to agree
04:25:05 <Philippa> but hey
04:25:19 <shapr> Which is what I used in the patch that replaced the crappy code I put into Quote/Yow.
04:25:52 <xerox> dons: @type, @info and @kind need something particular? (Yes sorry, I misuderstood what I read about randomInt, it was just a variable name)
04:26:03 <xerox> I mean, I get "Prelude.tail: empty list".
04:26:06 <Philippa> Cale: yes, am aware :-) Anyway, I keep thinking I should find a way to turn that into a 'WTF are monads?' article
04:26:23 <dons> xerox: hmm. you have ghci in your path?
04:26:34 <xerox> dons: I think so.
04:26:37 <dons> ghci-6.4
04:26:52 <xerox> It is a machine with only 6.2.2
04:27:11 <dons> edit TypeModule.hs: popen "ghci-6.4"
04:27:22 <dons> 6.4 is needed because of :kind
04:27:27 <Philippa> on the grounds that it IMO gives you a really good intuition for the level of power available that I've not quite seen elsewhere, and makes the jump to monad transformers completely trivial
04:27:58 <xerox> dons: I see, thanks again.
04:29:49 * dons sleeps
04:30:28 <shapr> g'nite dons
04:30:35 <xerox> Goodnight dons!
04:31:25 <shapr> metaperl: The nice thing about these discussions on extremeperl is that they put some of my fuzzy assumptions into clear stark unflattering lights, and I have to check them carefully to see if they're right. This is fun.
04:32:04 <shapr> g'mornin Darius
04:32:53 <xerox> Hiya Darius!
04:33:34 <Philippa> shapr: URL? What're they about? Would I have fun?
04:34:09 <shapr> Maybe. I haven't found a gmane.org feed for extremeperl, it's a yahoo group.
04:34:17 <shapr> http://groups.yahoo.com/group/extremeperl/messages
04:34:28 <xerox> No gmane :(
04:34:59 <shapr> Rob Nagler wrote a book on Extreme Programming in Perl, and that's the subject of this discussion group.
04:35:28 <shapr> Rob claims that he can learn everything Haskell can teach him by improving his Perl skills.
04:36:01 <shapr> I think he's right, but that it will likely take ten years of Perl work, as opposed to ten weeks of Haskell work which can then be directly mentally ported back to Perl.
04:36:31 <Philippa> does Perl have an equivalent of ADTs?
04:36:39 <shapr> I don't think so.
04:37:09 <Darius> heya shapr, xerox
04:37:10 <Philippa> okay. I dare say you can /do/ it, but by the time you've done so you'll burst out crying when somebody shows you them...
04:37:23 <shapr> Same for monads in Perl. It's been done, but it makes me cry.
04:38:06 <Philippa> also, some of the static typing tricks in Haskell just cannot be done in Perl for obvious reasons. Of course, an XP crowd tends to have a major downer on static typing because they're not used to cheap (ie not bloody C++ templates) parametric polymorphism
04:38:06 <Cale> He could also spend his time learning to program better with pencil and paper, but depending on what he does, he will be lead naturally in different directions.
04:38:15 <basti_> hi
04:38:18 <shapr> hiya basti_
04:38:20 <Philippa> 'lo
04:38:46 <shapr> Cale: yes, I agree. Imho, Once you skirt the turing tarpit, a language is defined by what it encourages.
04:38:54 <shapr> I'll call that shapr's third law!
04:39:32 <Philippa> what're the first two?
04:39:36 <shapr> I was trying to remember.
04:39:38 <xerox> Darius: dons fixed the Exception: Prelude.read, now lambdabot works nicely on 6.4 :D
04:39:41 <shapr> I have them written down somewhere.
04:39:43 <Philippa> I'm tempted to say most languages encourage not being able to think about them ;-)
04:41:01 <shapr> Philippa: aha! http://www.scannedinavian.com/2004-12-09.html
04:41:14 <xerox> Cale: "learning to program better with pencil and paper" ?!
04:41:30 <Cale> xerox: yeah, why not? :)
04:41:50 <TheHunter> what's the reason that the @more module is disabled?
04:42:03 <xerox> Cale: ouch :)
04:42:37 <Philippa> you can see what's happening more easily though, which helps a lot
04:43:02 * Philippa is inclined to say a language is defined just as much by what it discourages, mind
04:43:04 <shapr> Yeah, I remember the first time I filled in all the m a stuff in a monad.
04:43:11 <shapr> Philippa: sure, I agree.
04:43:15 <Philippa> eg many languages discourage statically-knowable properties of code
04:43:40 <Philippa> yeah, and when I couldn't fully parse the >>= for State I drew out what it was doing as a graph...
04:43:56 <shapr> xerox: have you ever written down on paper a fully filled out definition of some monadic code?
04:44:17 <shapr> It's exciting. And I needed more paper.
04:44:25 * TheHunter uses to write type signatures on paper all the time, but code, very rarely.
04:44:32 <xerox> shapr: I wrote some code on paper, but it was.. err, C.
04:45:10 <TheHunter> oh, I see "wrong type (<<[] Char>>) in ModuleState"
04:45:25 <Darius> xerox: Yeah, he was talking about it before I left last night.
04:45:32 <shapr> MoreModule is another evil hack on my part.
04:45:58 <Darius> "another"?
04:46:40 <TheHunter> i think I just fixed ircPrivmsg, let's see about that more module.
04:46:41 <shapr> Yeah, HaddockModule and some others lambdabot code bits were mentioned recently.
04:47:13 <TheHunter> but I have to learn that weird StateModule stuff whose only purpose seems to be to avoid the unsafePerformIO hack.
04:47:34 <shapr> Oh, you mean the MODULE wrapper?
04:47:48 <xerox> That hack permitted you to read /etc/fstab ?
04:48:32 <TheHunter> no. How State is kept in lambdabot using Dynamics, I think.
04:49:19 <shapr> If it's still the solution from long ago, it's a FiniteMap of String to State.
04:49:47 <TheHunter> yeah, that's it.
04:50:27 * shapr doesn't recognize StateModule
04:50:47 <TheHunter> err, ModuleState.
04:54:11 <Heffalump> thehunter: isn't avoiding unsafePerformIO a good reason?
04:55:10 <TheHunter> Heffalump, nope, if I have to choose between unsafePerformIO and type safety, i prefer type safety.
04:55:26 <Heffalump> unsafePerformIO isn't type safe..
04:55:40 <TheHunter> the "unsafePerformIO hack" is.
04:56:18 <Heffalump> possibly an MPTC and putting the ModuleState in the MODULE type would be nicer.
04:56:23 <TheHunter> well, actually it isn't if your ref has a polymorphic type, but that's easy to ensure.
04:58:24 * Heffalump thinks being able to store all state in one place is good design, too.
04:58:35 <Heffalump> It makes persisting it easier.
04:58:48 <Heffalump> the unsafePerformIO hack would break that
04:59:16 <TheHunter> true.
05:04:24 <Philippa> managing to keep things out of the IO monad where it makes sense is good too
05:04:36 <Philippa> constrained subsets of IO are good
05:04:59 <xerox> What does constrained mean?
05:05:00 <TheHunter> Dynamics are evil!
05:06:16 <Philippa> xerox: roughly speaking, "forced to be within a certain area"
05:06:47 <TheHunter> oh, for crying out loud! wrong type (<<[] Char>>, expected [Char]) in ModuleState
05:06:52 <Philippa> so here I might be talking about disallowing FFI imports and restricting the disk IO available (something that makes a lot of sense for plugin modules)
05:07:37 <shapr> I would like to see IO split into pieces.
05:07:45 <ozone> Philippa: hoi, pseudonym mentioned you had an idea called supertypes, or superclasses, or something along those lines
05:07:50 <Darius> TheHunter: That's not Dynamic's fault, that's GHC's implementation of Dynamics fault.
05:07:52 <ozone> if you have time, do you mind elaborating?
05:07:52 <shapr> I'd also like to see Monsieur JÃ¤ger's monad superclass in place.
05:08:16 <Philippa> ozone: I've a couple, yeah
05:08:18 <TheHunter> Darius, any idea why [] Char and [Char] should be something different?
05:08:45 <Philippa> nothing that you can do in Haskell atm, more stuff that would be cool if you had it. Unless there's something else with a similar name I thought up and forgot about :-)
05:09:11 <Darius> TheHunter: If it's the problem I think it is, it's because GHC's implementation of Dynamics is broken (or rather does not work with dynamic and static code).
05:09:17 <Philippa> but basically: you can reasonably think about constructors in a datatype as being subtypes of the datatype. And you can reasonably put two datatypes together to 'make a bigger sum'
05:09:32 <Philippa> where the two datatypes are a subtype of their sum
05:09:33 <ozone> Philippa: i'm personally interested, since i've been doing some research about OO/subtyping in haskell for a while
05:09:47 * psi is wondering why mapMaybe is different in ghc and in my haskell book (the craft of functional programming)
05:09:48 <ozone> mmm, ok
05:09:51 <Philippa> this is sort of going in the opposite direction - it isn't extensional in the direction most OO folks want
05:10:01 <Philippa> for that, you want type classes and existentially-quantified datatypes
05:10:04 <Darius> @index mapMaybe
05:10:05 <lambdabot> Sorry, I don't know the command "index", try "lambdabot: @listcommands"
05:10:25 <ozone> Philippa: so, you are saying that supertypes are like minus types? :)
05:10:27 <Philippa> it'd be v.easy to build a statically-typed immutable object system in Template Haskell
05:10:32 <psi> in tcofp, mapMaybe has the type (a->b) -> Maybe a -> Maybe b
05:10:37 <Philippa> ozone: minus types?
05:10:43 <ozone> opposite of sym types
05:10:45 <ozone> sum types
05:10:47 <Philippa> no, they're not
05:10:47 <ozone> anyway, carry on
05:10:59 <Philippa> the big deal is that ADTs are based on sums whereas traditional objects are based on products
05:11:14 <Philippa> this means that a lot of stuff is 'backwards' compared to objects
05:11:18 <ozone> sure
05:11:20 <Philippa> (because sums and products are dual)
05:11:29 <ozone> do you have an example of where supertypes are useful?
05:11:31 <Philippa> the direction it's safe to extend in is one
05:11:57 <Philippa> a couple of trivial ones are confirming you've got a value that supports a giving field and typing 'non-empty list'
05:12:14 <Philippa> if you've got a pile of already-understood features there're more fun things you can do though
05:12:44 <Philippa> it's reasonable to allow "any subtype of Foo" patterns - better yet, it's reasonable to allow "any subtype of Foo that's got a known instance of this typeclass"
05:13:11 <ozone> mmmm, i'm not clear what supertypes are
05:13:12 <Philippa> (because it's mildly type-aware syntactic sugar)
05:13:26 <ozone> and how what you're currently talking about relates to them
05:13:35 <Philippa> you can think of the sum-of-T1-and-T2 type as a supertype (of both T1 and T2)
05:13:58 <Philippa> I just tend to refer to the feature as supertyping rather than subtyping because of the reversed direction of most of the things commonly associated with subtyping
05:13:59 <ozone> ah, right
05:15:01 <Philippa> incidentally, try this out for a neat abuse: 'power types', where you start off with a handful of types and generate a hierarchy that's the power set of them. If each of the initial types represents, say, 'has an instance of Foo', you get types for 'has Foo and Bar'...
05:15:39 <ozone> hmmm
05:15:58 <Philippa> which when you pattern-match amounts to solid evidence that the relevant value is a member of said type classes
05:16:01 <ozone> so, if you have types T1 and T2, and a supertype S which is sum(T1,T2), then anywhere you can use a T1 or T2, you can use S?
05:16:09 <ozone> what's the diff between this and subtyping?
05:16:16 <Philippa> that's the one thing that /isn't/ reversed :-)
05:16:52 <ozone> oh, hmm, no, you can't substitute S for T1 or T2
05:17:04 <Philippa> except when describing an output
05:17:11 <ozone> it's the opposite way, so anywhere you can use an S, you can use T1 or T2
05:17:13 <Philippa> in which case you lose info rather than adding info that may not be true
05:17:42 <ozone> right, which makes sense, since you're reversing the contra/covariant stuff with function arguments/output
05:17:51 <ozone> am still trying to think of a scenario where they would be useful :)
05:18:25 <Philippa> 'those constructors that have a field foo' was my initial use case
05:18:58 <Philippa> they get more fun when you're playing with type classes and existentially quantified constructors though, because you can 'reify' the type class hierarchy or bits thereof, dirty/fun stuff like that
05:19:06 <ozone> ah!
05:19:36 <Philippa> it's the sort of thing Oleg'd have great fun with
05:20:17 <ozone> right, think i get it.
05:21:37 <ozone> wouldn't you run into the same type inference problems that you have with subtyping?
05:26:59 <Philippa> oops, sorry, went off to read stuff
05:27:24 <ozone> no worries
05:27:42 <Philippa> most of them don't apply because they don't crop up in well-formed ASTs-with-subtypes
05:28:25 <Philippa> a hindley-milner-with-this implementation is trivial, you need a match as well as a unify to do useful checking but that's where most of the changes are
05:28:57 <Philippa> the only thing that does crop up is when you unify two types and there's more than one viable immediate supertype for them
05:29:07 <Philippa> I just fail and support type annotations to tell the checker which one to pick
05:29:22 * basti_ recently taught Calister how the Haskell type algorithm works
05:29:25 * basti_ :)
05:29:29 <Philippa> heh
05:29:34 <ozone> hmm, interesting.  in a way, you have another way besides type classes to specify restrictions on a data type?
05:29:37 <Philippa> I think I may've done a while back, albeit very briefly
05:29:39 <Philippa> in a way, yeah
05:29:57 <basti_> we needed a drawing.
05:30:02 <TheHunter> ooh, lambdabot does NOT compile with -fno-monomorphism.
05:30:03 <basti_> which i had to render in pdf.
05:30:04 <Philippa> you also get to unbox sone of the cases where you'd have Either a b
05:30:17 <Philippa> basti_: yeah, understandable
05:30:41 <ozone> Philippa: if what you say about the type inference is true (w.r.t. subtyping problems don't apply), that's very nice
05:30:42 <basti_> =)
05:30:49 <basti_> she never learned prolog. stupid thing. ;)
05:30:50 <Philippa> I just put it in terms of 'you walk this tree bottom up and unify lots'
05:31:12 <ozone> intuitively that makes sense, since the "world" of types can't be further subtyped, so it's closed
05:31:31 <Philippa> ozone: yeah. Of course, it doesn't get you as much of the power either, but hey. It's scary what you can do if you're allowed a constraint language though
05:31:38 <Philippa> eg there's an encoding of tuples...
05:31:58 <Philippa> and you'd be able to type the 'get the third element' function to work on all tuples of size three or greater
05:32:07 <ozone> yeah, right
05:32:16 <ozone> you basically have subtyping, but not "open" subtyping
05:32:20 <Philippa> yeah
05:32:35 <ozone> so, the entire world of types is known at compile-time
05:32:43 <Philippa> but you /do/, coupled with already extant features, get to write 'arbitrary-length types' like that tuple
05:32:57 <ozone> very clever
05:32:59 <Philippa> now, you might want to think what that means for binary serialisation? :-)
05:33:01 <basti_> hmm... Philippa can you expand?
05:33:09 <ozone> yeah, sure
05:33:26 <ozone> are you planning to do serious research on this?
05:33:29 <ozone> i.e. submit a paper or something
05:33:39 <ozone> will do wonders for integrating Haskell with OO, which i would like very much ;)
05:33:57 <Philippa> basti_: data MyTuple a b = TNil | forall c.TCons a (b < MyTuple a c)
05:34:23 <basti_> is that higher order Polymorphism?
05:34:40 <Philippa> just a constraint on b
05:34:49 <Philippa> and I goofed it a little
05:35:13 * basti_ would like to know...
05:35:13 <Philippa> the idea is, TCons takes an a and a MyTuple <don'tcare> <don'tcare>
05:35:23 * basti_ nods
05:35:33 <Philippa> and yes, this is supposedly my undergrad dissertation project and a few other folks want a paper
05:36:00 <basti_> btw. Coq can do this sort of things...
05:36:03 <Philippa> and we need the b variable to be the MyTuple <don'tcare> <don'tcare>
05:36:10 <Philippa> so that you can write biiig nested types
05:36:21 <basti_> yup
05:36:34 <basti_> i would love a "dictionary" type
05:37:25 <basti_> if you can see what i mean?
05:37:33 <basti_> like the OO "." operator
05:37:36 * Philippa nods
05:38:15 <basti_> hmm
05:38:55 <basti_> maybe one could then show that the "." operator has a "natural" behaviour in the Type-Reasoning world
05:39:33 <basti_> maybe even "benign" towards compilers...
05:39:43 <basti_> and at the same time loosen its constraints maybe.
05:40:03 <basti_> anyone with me? ;)
05:40:06 <ozone> ooo
05:40:10 * basti_ takes a look at the altimeter
05:40:13 <ozone> basti_: that's always been a pet hate of mine in haskell :)
05:40:15 <basti_> was that a drool?
05:40:27 <basti_> what exactly?
05:40:31 <ozone> i like trolling the haskell lists about it every once in a while
05:40:43 <shapr> TheHunter: what does that imply?
05:40:44 <basti_> object orentation?
05:40:45 * Philippa suspects the easy way to do . involves multiparm typeclasses
05:41:02 <basti_> huffffff.
05:41:06 * basti_ ponders that
05:41:10 <ozone> well, in oo languages, you get inherent namespace separation with each class you define
05:41:15 <TheHunter> Darius, ok, you're right, it's absolutely GHC's Dynamic's fault. unsafeCoerce# works fine.
05:41:22 <basti_> oh
05:41:31 <ozone> you don't get that with haskell.  -> polluted namespace
05:41:35 <basti_> hmm.
05:41:39 <Philippa> foo.MySelector, . :: (isField a b c) => (a -> b -> c), fundep a,b=>c
05:41:49 <basti_> but haskell's typing is different to C's typing in that respect
05:41:49 <Darius> TheHunter: The issue is known.  You could use an alternative (less efficient) Dynamic implementation.
05:41:55 <ozone> Philippa: tried that.  you can do it, but it's pretty ugly
05:41:56 <basti_> take for example the "*" operator
05:42:06 <Philippa> ozone: yeah. For real use it needs sugaring
05:42:10 <basti_> how would a*b in haskell be different to in C, typewise?
05:42:24 <TheHunter> shapr, nothing, i just think code should also compile with -fno-monomorphism-restriction to be unambigous.
05:42:32 <ozone> Philippa: it's surprisingly good without any sugaring
05:42:39 <TheHunter> Darius, it's about lambdabot. What do you suggest?
05:42:50 <Philippa> ozone: yeah, I've done the thinking and so forth. A record system based on it would be good
05:42:58 <ozone> Philippa: the problem is more of a practical one.  at least the way we figured out how to do it, you end up declaring silly numbers of instance declarations ...
05:43:02 <Philippa> you could also encode various kinds of record subtyping that way
05:43:09 <TheHunter> Darius, has that been fixed in 6.4?
05:43:12 <Philippa> right
05:43:17 <Philippa> you want syntactic sugar, 'sall
05:43:36 <ozone> and more seriously, you have to redeclare instances all the way up the class hierarchy
05:44:09 <Darius> TheHunter: I don't know.  As for what to do about it, importing an alternative Dynamic module is a possibility and shouldn't be too difficult).
05:44:24 <Philippa> nah, you have an 'extends' class and a bunch of 'if you extend something with this field, you have it too' stuff
05:44:31 <basti_> humma.
05:44:32 <Philippa> the latter's per-field though, which sucks
05:45:05 <basti_> maybe, though, haskells class inheritance is just the right way of seeing OO
05:45:12 <basti_> i mean it IS similar in sorts isnt it?
05:45:17 <ozone> well, it looks like there's several approaches for extensible records in haskell now
05:45:37 <ozone> there's at least oleg et al's crazy hlist stuff, class associated types, and maybe GADTs
05:45:46 <ozone> we'll see which one wins :)
05:46:05 <TheHunter> Darius, do you know if that problem appears in other modules, too?
05:46:06 <ozone> basti_: it's similar, but the problem is, OO classes are inherently "open-world"
05:46:16 <basti_> hmm
05:46:17 <ozone> type classes are open in the sense that you can add new instances for them
05:46:37 <Philippa> I'm inclined towards a fairly sophisticated approach based on type classes s.t. instances can encode serious compiler hints, but that's because I don't always trust the compiler I guess
05:46:39 <TheHunter> I might as well do the right thing and use a multiparam type class, then. Personally I don't have any problem whatsoever with unsafeCoerce#
05:46:46 <Darius> TheHunter: I'm pretty sure it doesn't.  It will only come up if you try to use a Dynamic generated in a dynamic module in a static module or vice versa.
05:46:57 <basti_> you mean, like, adding a new "type" (class) to the system?
05:47:03 <ozone> but they're closed in the sense that you can't declare a new type, and then say "if i make this new type an instance of type class Coffee, i want it to automatically be an instance of its parent type class Drink too"
05:47:04 <basti_> why is it not "open" in haskell?
05:47:21 <Darius> unsafeCoerce# is EVIL!
05:47:38 <basti_> uhm.
05:47:40 <Philippa> ozone: it /is/, but you have to provide the functions in separate instance blocks
05:47:47 <Philippa> I mean, it's sugarable if you really care
05:48:05 <basti_> i even dont think so
05:48:14 <TheHunter> but then again, Dynamics already use unsafeCoerce# under the hood.
05:48:24 <basti_> Philippa: i think you're referring to "multiple  inheritance" arent you?
05:48:38 <basti_> ozone: and you are thinking like A inherits from B inherits from C?
05:48:44 <Darius> TheHunter: It doesn't need to and it's one controlled use by people who hopefully know what they are doing.
05:48:51 <basti_> Philippa: (A inherits from B *and* C)
05:48:52 <ozone> Philippa: i'm pretty sure there are good reasons why such "automatic instance declarations" aren't there yet
05:49:16 <TheHunter> Darius, it doesn't need to?
05:49:33 <Darius> TheHunter: You can implement Dynamic without unsafeCoerce#
05:49:34 * basti_ goes write some code.
05:49:35 <basti_> ;)
05:49:38 <Philippa> basti_: I'm not per se, what I mean is that type classes are 'interfaces', there's no code to inherit 'til you provide it
05:49:51 <basti_> yes.
05:49:54 <TheHunter> Darius, really?
05:49:55 <basti_> thats right.
05:50:01 <Darius> TheHunter: Yes.
05:50:18 <Philippa> now, you could probably do some funky instancing to get you some neat delegation tricks...
05:50:21 <TheHunter> exsitentials + mptcs?
05:50:24 <Darius> TheHunter: Not in Haskell 98, but with the typical extensions.
05:50:47 <Darius> TheHunter: Really just existentials or (equivalently) rank-2(or higher) types.
05:50:53 <Philippa> Darius: which set, how's it done and what assumptions're made?
05:51:40 <Darius> Philippa: Existentials and you can reimplement the current Dynamic interface exactly
05:51:54 * Philippa smacks herself
05:51:55 <Philippa> of course
05:53:09 <Darius> GADTs should also work
05:53:44 <TheHunter> i can only think of non-local transformations.
05:54:28 <Philippa> yeah, on the basis that it's just a GADT encoding of existentials, as it were
05:54:35 <TheHunter> but you can't reimplement Typeable can you?
05:54:50 <Darius> TheHunter: Typeable is just a type class.
05:55:00 <Darius> And in this case you'd simply use Typeable
05:55:08 <basti_> hmm
05:55:21 <basti_> actually i would haskells OO system like that:
05:55:33 <basti_> if you want to inherit something, you have to specify where from exactly.
05:55:36 <TheHunter> Darius, but you wouldn't use the casts provided by Typeable?
05:55:40 <basti_> its just a bit ugly.
05:55:41 <basti_> ;)
05:56:13 <ozone> basti_: when you have a hierarchy which is only even 3 or 4 deep (very common), it starts getting pretty unmaintainable ...
05:56:43 <basti_> hmm
05:57:36 <ozone> that was the one and only reason we didn't end up using that sort of system for HOC (haskell <-> objective-c binding)
05:57:40 <TheHunter> Darius, well if you're allowed to use Data.Typeable.cast, you're still relying on unsafeCoerce#.
05:57:41 * boegel bounces
05:57:42 <ozone> otherwise, it would've been lovely
05:57:50 <Philippa> TheHunter: implementation detail
05:58:12 <TheHunter> Philippa, i don't understand.
05:58:14 <ozone> TheHunter: there's a paper by doaitse swierstra and ... someone else (arthur baars?) about how to implement it, if you're interested
05:58:22 <ozone> "Typing Dynamic Typing", iirc
05:58:25 <Darius> TheHunter: You don't need unsafeCoerce# to implement Dynamics: Read "Lightweight Generics and Dynamics"
05:58:30 <ozone> well, probably more than one paper
05:58:31 <Philippa> at that point, unsafeCoerce# is doing its duty as a compiler hack
05:58:39 <ozone> yeah, what darius said too :)
05:58:42 * boegel is dazled by the ongoing conversation
05:59:02 * TheHunter doesn't believe any of that but will shut up until he's read the papers.
05:59:19 <ozone> TheHunter: the Typing Dynamic Typing paper made my head spin for quite a while
05:59:35 <ozone> so, good luck to you :)
06:02:31 * basti_ detonates
06:03:40 <kosmikus> I can confirm that the two mentioned papers describe how to implement dynamics without unsafeCoerce or anything ugly
06:03:54 <kosmikus> however, to do it right one would need extensible datatypes instead
06:05:04 <Darius> Philippa: What was your impression of Typed Logic Variables, by the way?
06:05:33 <Philippa> looked fun, I sorta didn't read too deeply but I dare say I'll think about it next time I've got something of that ilk to do
06:05:47 <Philippa> kosmikus: extensible in which direction(s)?
06:05:59 <kosmikus> new constructors
06:06:07 <Philippa> for an existing typename?
06:06:09 <Philippa> ouch
06:06:16 <Philippa> that's inherantly badly-typed
06:06:38 <Philippa> would it be fakeable with a typeclass and an existential type? Is equality enough?
06:06:46 <kosmikus> because what these approaches do is that they allow you to define a representation of all datatypes currently known
06:06:54 * Philippa nods
06:06:59 <Philippa> that's something I don't like
06:07:02 <kosmikus> i.e., you can have dynamics on all these datatypes, or generic on all these datatypes
06:07:06 <kosmikus> generics
06:07:14 <Philippa> as a rule of thumb, if I really /need/ dynamic types I can't work within that restriction
06:07:26 <kosmikus> I agree
06:07:41 <Philippa> (there're a few exceptions, they'd be covered with the power types trick I mentioned earlier)
06:07:49 <kosmikus> still, I think the technique described in the two papers is useful enough to know
06:08:03 <TheHunter> hmm, i just skimmed through Cheney and Hinze's paper and it looks like their dynamics only work for "representable types"
06:08:26 <kosmikus> current dynamics work for representable types only as well, don't they/
06:08:33 <Darius> TheHunter: Which is different from what Dynamic gives you how?
06:09:15 <TheHunter> i'm not sure their Dynamic type can ever be representable
06:09:17 <Philippa> representable types being in a type class
06:09:39 <TheHunter> Darius, newtype Foo = Foo (forall a. (a -> a) -> (a -> a))
06:09:47 <Philippa> but yeah, it still doesn't quite work in the dynamically-loaded-code case unless you can ensure the typereps'll be unique there
06:10:26 <kosmikus> TheHunter: yes, their Dynamic type can be representable, don't they even show that?
06:11:02 <TheHunter> kosmikus, oops, sorry, yes they do.
06:11:53 <nlv11757_> hey im doing this C application and im getting a seg fault, can anyone explain why :P
06:11:56 <ozone> Philippa: i'm not sure if that's a solvable problem (on the type-theory level, that is)
06:12:05 <shapr> nlv11757_: you need a type system :-P
06:12:16 <nlv11757_> yes please
06:12:20 <kosmikus> and not a cheap one
06:12:35 <nlv11757_> ok make it two then
06:12:44 <ozone> 5 dorra, cheap types, last long time
06:12:45 <Philippa> ozone: it's pretty much linker-level. Unless you need to persist your dynamics, in which case we're talking GUIDs
06:13:04 <ozone> Philippa: indeed
06:13:09 <Philippa> you can 'solve' it by namespacing all your typereps by module...
06:14:31 <Darius> TheHunter: Foo can be treated just like any other primitive type.
06:15:02 <TheHunter> Darius, yes i already realized that.
06:15:31 <TheHunter> But I can make up stuff like Foo a = forall b. Foo (forall c. (a -> b) -> Foo c)
06:15:42 <Darius> TheHunter: On the other hand, you may want to look at Clean's dynamic support and some of the papers on staged type checking
06:16:05 <Darius> TheHunter: And make a Typeable instance?
06:16:33 <TheHunter> Darius, why not?
06:16:57 <Darius> If you can make a Typeable instance, that instance will work just as well for the other approach(es).
06:17:45 <TheHunter> But you'd have to extend Rep, which loses the modularity Typeable provides
06:17:54 <kosmikus> yes, I definitely want dynamics that work on all sorts of polymorphic and existenatial types without any hassle
06:18:20 <kosmikus> but this is not going to happen within Haskell as long as it has a predicative type system, I guess
06:24:45 <Philippa> kosmikus: have you got a good use case for that which you can't achieve by wrapping it in an existentially-quantified datatype?
06:25:10 <Philippa> (='reducing the polytype to a name which is thus a monotype')
06:26:44 <xerox> http://www.jadetower.org/muses/archives/000307.html -- "JavaScript = C + Lisp", but it talks about Haskell and Monads, actually.
06:29:59 <kosmikus> Philippa: no :) not right now, but I had one when I was thinking about Dynamics the last time some three weeks ago
06:30:41 <kosmikus> Philippa: something with generic programming, as you might guess; but I've already packed away the notes, because I'm going to fly/move back from .ee to .nl tomorrow
06:31:03 <shapr> xerox: that's nifty, and kinda scary.
06:31:18 <xerox> Agreeable.
06:31:50 <Philippa> kosmikus: generic thingy itself being dyntyped?
06:32:52 <kosmikus> Philippa: when implementing a generic function by matching on a type representation, as in Hinze/Cheney
06:34:24 <kosmikus> Philippa: I think the point is that if you want generic functions to work on existentials/universals in some way, you'd need a Rep_Exists or Rep_Forall of some sort, but that's hard to do without type-level lambda
06:35:16 <kosmikus> Philippa: but I'm not sure if I remember the situation correctly now
06:35:18 <Philippa> ah, yeah
06:40:06 <Darius> xerox: There are some minor code and factual errors in that article.
06:41:52 <xerox> Darius: what exactly?
06:42:25 <shapr> metaperl: I think Mail::Box does exist for Haskell.
06:43:00 <xerox> "The Ability to Define a Function is Insignificant next to the Power of the Monad" ? :)
06:46:39 <Darius> xerox: The raw monadic version of sumTwoLists is wrong, list comprehension notation only works for lists (it did actually work for monads in an earlier revision of Haskell), and (albeit forgiveably) the Identity monad instance is not executable.
06:49:00 <xerox> Right.
06:52:42 <Darius> Finally, all the Monad stuff is pointless as in the end liftCombinator c n = c . fmap ($ n)
06:53:06 <xerox> Hmm, to do a sumTwoLists you need MonadPlus, right?
06:53:25 <Darius> No, it's just a gross typo.
06:55:32 <jlouis> dons: I have a couple of ideas for the @fact module
06:55:53 <jlouis> dons: Will tell later
06:56:21 <xerox> Something like sumTwoLists = mplus :: [a] -> [a] -> [a], but it's not exactly what he meant, I think.
06:56:34 <xerox> Darius: how would you correct it?
06:57:04 <Darius> Simply move the return inward, it should be wrapping k+l (or whatever the names were) as in do version.
06:58:29 <xerox> @type \xs ys = xs >>= \x -> ys >>= \y -> return (x+y)
06:58:36 <lambdabot> bzzt
06:58:37 <xerox> ?
06:59:24 <Darius> @type \xs ys -> xs >>= \x -> ys >>= return (x+y)
06:59:26 <lambdabot> bzzt
06:59:41 <Darius> @type \xs ys -> xs >>= \x -> ys >>return (x+y)
06:59:42 <lambdabot> bzzt
06:59:47 <Darius> @type \xs ys -> xs >>= \x -> ys >>= \y -> return (x+y)
06:59:49 <lambdabot> \xs ys -> xs >>= \x -> ys >>= \y -> return (x+y) :: forall a
06:59:49 <lambdabot>                                                            (m :: * -> *)
06:59:49 <lambdabot> .
06:59:49 <lambdabot>                                                     (Monad m, Num a) =>
06:59:49 <lambdabot>                                                     m a -> m a -> m a
07:00:00 <Darius> Damn pretty printers.
07:00:12 <Darius> Or just
07:00:16 <Darius> @type liftM2 (+)
07:00:18 <lambdabot> bzzt
07:00:27 <Darius> @type Control.Monad.liftM2 (+)
07:00:29 <lambdabot> Control.Monad.liftM2 (+) :: forall a2 (m :: * -> *).
07:00:29 <lambdabot>                             (Monad m, Num a2) =>
07:00:29 <lambdabot>                             m a2 -> m a2 -> m a2
07:01:16 <xerox> Hmm
07:02:05 <xerox> It does work.
07:06:01 <xerox> Darius: last thing, what does it mean that the Identity monad instance is not executable?
07:08:46 <Darius> It's not valid Haskell.
07:11:29 <xerox> :)
07:17:12 <basti_> wow. I think i will have a look into fudgets.
07:18:08 <shapr> yes!
07:18:38 <basti_> i remember typing an accounting software into my trusty c128
07:18:46 <basti_> it hat an "calculator" gadget
07:18:59 <basti_> which was callable almost from everywhere.
07:19:24 <basti_> i thought to myself, "my, wouldnt it be nice if that were possible in a REASONABLE way?"
07:20:44 <basti_> and now i read that in fudgets everything is really modular.
07:23:01 <basti_> shapr: how do you think about a fudgets interface for csound? =)
07:57:52 <CosmicRay> quick question: where could I read about 1) the proper way of using cpp (or a cpp-alike) with cabal to build software with hugs and ghc, 2) the proper way of detecting the newer fptools in ghc and/or hugs using cpp?
07:58:12 <CosmicRay> urgh, brb
08:00:37 * shapr hugs CosmicRay 
08:00:43 <shapr> CosmicRay: thank you for sequence!
08:00:49 <Igloo> 1) is giving cpp as an extension I think
08:01:14 <basti_> sequence?
08:01:43 <basti_> uhm.. did something new happen in the world of fudgets since 1997? ;)
08:01:57 <shapr> basti_: not really.
08:02:05 <basti_> -g-
08:02:12 <basti_> "latest snapshots" *click*
08:02:13 <basti_> cute
08:02:24 <shapr> basti_: http://sequence.complete.org/
08:02:59 <basti_> ah
08:10:41 * CosmicRay returns
08:10:54 <CosmicRay> shapr: glad you're enjoying it!
08:11:04 <CosmicRay> no spam in the last 24 hours <crossing fingers>
08:11:28 <CosmicRay> I'm so glad metaperl is writing stuff there
08:12:13 <CosmicRay> shapr: oh btw, you were interested in asterisk....  here's what Ive done with it: http://changelog.complete.org/node/264
08:15:37 * stepcutHM uses asterisk for an 800 number
08:17:34 <CosmicRay> stepcutHM: who is your voip provider, if you don't mind me asking?
08:17:50 <stepcutHM> currently, iax.cc
08:18:28 <CosmicRay> nice
08:18:33 <CosmicRay> I'm using livevoip.com
08:18:53 <stepcutHM> So far I have used less than 60 seconds of talk time, so I can't give any ratings other than, 'it worked'
08:19:31 <CosmicRay> heh
08:20:03 <CosmicRay> I'm pretty happy with livevoip.com
08:20:09 <CosmicRay> no monthly fee and 1.2cents/min outbound
08:20:10 <stepcutHM> I also have a free DID that connects via my sipphone.com, which works ok
08:20:28 <CosmicRay> interesting, where did you get that free did?
08:20:40 <CosmicRay> livevoip also sells 800 numbers for $1/mo and 1.27cents/min incoming
08:20:54 <CosmicRay> I'm so tempted to get one since they're so cheap, but I just don't know what I'd do with it :-)
08:21:10 <stepcutHM> iax.cc's 800 numbers have no monthly fees
08:22:14 <stepcutHM> $2/min incoming (i think), and $10 minimum purchase
08:22:20 <stepcutHM> oops
08:22:27 <CosmicRay> $.02 maybe? :-)
08:22:29 <stepcutHM> make that, $0.02/min :)
08:23:16 <CosmicRay> I wonder if livevoip charges when I dial a toll-free number.
08:23:27 <CosmicRay> I route outbound toll-free calls via FWD's gateway right now
08:23:30 <CosmicRay> falling back to my pstn line
08:24:46 <CosmicRay> I signed up for a free sip did from ipkall, but they never got it provisioned correctly, it seemed to reach someone else
08:25:09 <stepcutHM> i think I got mine from ipkall
08:25:12 <CosmicRay> I keep thinking there is something cool I could do with haskell and asterisk, but the asterisk dialplan is too darn flexible :-)
08:25:19 <stepcutHM> I can't find any records at the moment :)
08:25:33 <CosmicRay> also I didn't like the "thank you for using ipkall" that they say at the start of every call
08:25:55 <stepcutHM> hrm... I don't get a message like that...
08:26:06 <CosmicRay> when I dial the ipkall did number from a pstn line
08:26:08 <CosmicRay> it says that
08:26:42 <shapr> man, I really miss @index
08:26:51 <CosmicRay> what happened to it?
08:27:03 <shapr> I broke it.
08:27:04 <stepcutHM> I call mine all the time from my cell phone, no message :-/
08:27:10 <CosmicRay> shapr:  tsk tsk
08:27:24 <CosmicRay> stepcutHM: hmm.  maybe I should try signing up again.  maybe my did was fscked somehow.
08:27:41 <stepcutHM> when I am late for work, I call into my asterisk server, enter a mailbox code, and leave a message, which gets emailed to all my coworkers
08:27:43 <CosmicRay> stepcutHM: was yours going to a fwd number or directly to your asterisk server?
08:27:59 <CosmicRay> stepcutHM: yeah that e-mail feature of voicemail is so cool
08:28:00 <stepcutHM> it goes to my sipphone.com number
08:28:04 <CosmicRay> hm.
08:28:12 <CosmicRay> why not have it go to your asterisk box directly?
08:28:32 <stepcutHM> because the ip address on my asterisk box might change ?
08:28:36 <CosmicRay> ah.
08:29:09 <stepcutHM> it's not like the audio actual gets routed through sipphone, they are just a registry to tell people what my ip currently is :)
08:30:17 <CosmicRay> they support reinvite then, eh?
08:30:27 <CosmicRay> though if you're behind nat, they might have to send it to you directly, no?
08:30:43 <stepcutHM> my asterisk server runs on the firewall
08:31:03 <stepcutHM> and mr is too cheap to run a free media server
08:31:12 <CosmicRay> mr?
08:31:23 <stepcutHM> michael robertson
08:31:38 * CosmicRay is still not quite sure he udnerstands how sip reinvites and iax transfers works
08:31:51 <CosmicRay> I just set most things to canreinvite=no and be happy :-)
08:32:11 <CosmicRay> I suspect too that fwd has to relay the audio from any iax call I make to a sip callee
08:32:37 <stepcutHM> probably,
08:32:53 <stepcutHM> I think fwd runs free media servers too
08:34:14 <CosmicRay> by media server, you mean a relay like this?
08:35:27 <stepcutHM> sip proxy servers, are basically just DNS for sipphone numbers. When I want to call 17476691001@sipphone.com, my client connections to proxy01.sipphone.com, and asks "What ip is user 17476691001 currently registered at", then the server responds, any my client connections directly to the person I am trying to call
08:35:50 <CosmicRay> hmm.
08:36:06 <CosmicRay> now I have read that asterisk is not a sip proxy server, and yet I tell my ip phones to register to it as if it was
08:36:08 <stepcutHM> but, that only works if atleast one person is not behind a firewall
08:36:11 <CosmicRay> right
08:36:28 <CosmicRay> so when both are behind, what happens?  does the proxy server relay the audio?
08:36:39 <shapr> My kernel is leaking memory :-(
08:36:49 <CosmicRay> shapr: that sucks.  are you sure it's the kernel?
08:36:54 <stepcutHM> if both people are behind a firewall, then they have to connect to some other machine that they can both reach and route the audio through that
08:37:15 <stepcutHM> that machine is the media server
08:37:20 <shapr> CosmicRay: yeah, if I exit all the apps and shutdown all the services, something is using 300mb of ram.
08:37:21 <CosmicRay> ah
08:37:30 <CosmicRay> shapr: are you sure it's not the cache?
08:37:33 <stepcutHM> i think the proxy server and media servers are often different machines
08:37:39 <CosmicRay> shapr: show me your vmstat
08:37:43 <shapr> Does cache use swap?
08:37:52 <CosmicRay> shouldn't
08:38:14 <shapr> procs -----------memory---------- ---swap-- -----io---- --system-- ----cpu----
08:38:14 <shapr>  r  b   swpd   free   buff  cache   si   so    bi    bo   in    cs us sy id wa
08:38:14 <shapr>  1  0 264572 257972   9280  63348    0    1    14    14   17   113  6  2 92  1
08:38:32 <CosmicRay> hmm, 264MB swapped, about 300MB free...
08:38:48 <CosmicRay> run top, then press Op
08:38:51 <stepcutHM> CosmicRay: as for asterisk not being a proxy server -- That sounds right to me -- though I can't say exactly why
08:39:02 <CosmicRay> shapr: the items on the top of the list will be the ones using the most swap space
08:39:13 <CosmicRay> stepcutHM: ok
08:39:25 <CosmicRay> stepcutHM: do you have any voip hardware?
08:39:45 <shapr> xfree has 170mb used right now, all other used swap is less that 100k.
08:39:54 <shapr> 'less than'
08:40:02 <jlouis> in swap?
08:40:05 <CosmicRay> have you tried killing xfree86?
08:40:07 <stepcutHM> CosmicRay: A budgetone
08:40:19 <jlouis> I would assume it was xfree then
08:40:19 <CosmicRay> it is possible that it is consuming memory that is not on this list, via ipcs and the like
08:40:22 <CosmicRay> yeah
08:40:46 <CosmicRay> I thought that by exit all apps and shutdown all services, you would have killed xf too :-)
08:40:47 <shapr> Even when I exit xfree and everything else, there's still a bunch of memory used.
08:40:56 <shapr> Yes, but I'm not there right now :-)
08:41:00 <CosmicRay> heh
08:41:16 <CosmicRay> try getting back to that state and do the vmstat and top thing again
08:41:19 <jlouis> what kernel?
08:41:21 <shapr> My whole system starts to slow down, even the simplest tasks take forever, and all I can do is reboot.
08:41:21 <CosmicRay> also try running ipcs and see what turns up
08:41:25 <shapr> jlouis: 2.6.10
08:41:40 <CosmicRay> what filesystem are you using?
08:41:46 <jlouis> Seee, that is the problem. You must insteall 3.7
08:41:55 <CosmicRay> stepcutHM: how do you like the budgetone?
08:42:06 <CosmicRay> stepcutHM: I'm using Sipura SPA-847s here.  very pleased with them.
08:42:20 <jlouis> shapr: it is years since I last used Linux. No clue here
08:42:21 <CosmicRay> stepcutHM: a little pricier than the budgetones but all sorts of configuration goodies (and the intercom mode, which is sweet)
08:42:21 <stepcutHM> CosmicRay: it sucks, but the price was right (free)
08:42:25 <CosmicRay> heh
08:42:38 <CosmicRay> jlouis: 3.7? :-)
08:42:46 * CosmicRay confirms the "no clue" bit :-)
08:43:14 <CosmicRay> what's your preferred os, jlouis?
08:44:16 <jlouis> CosmicRay: OpenBSD or NetBSD
08:44:30 <jlouis> small, clean, stable
08:44:33 <CosmicRay> ah, you're the one that reminded me that theo hates me :-)
08:44:45 <jlouis> hehe
08:44:49 <jlouis> Theo hates you ;)
08:45:11 <CosmicRay> jlouis: I thought maybe he likes me now, since he no longer sends me automated e-mails to remind me of that fact :-)
08:45:48 <CosmicRay> shapr: do you ever get a problem that is easy to solve, but it's hard to bring yourself to code it up, precisely because it's too easy?
08:45:55 <CosmicRay> I need to write a csv parser for haskell.
08:46:00 <CosmicRay> should be about a page of code.
08:46:06 * stepcutHM eats breaksfast and reads about accounting
08:46:08 <CosmicRay> but I'm too lazy to do it because I know exactly how it's done
08:46:24 <stepcutHM> CosmicRay: hahah, well I might need one too for parsing paypal and bank statements
08:46:43 <shapr> CosmicRay: write tests first.
08:46:52 <psi> i'm a bit confused about monads. it seems like the 'grandfather' function calls 'father' with a list in this example http://www.nomaware.com/monads/html/solution3.html
08:46:53 <CosmicRay> even more boring ;-)
08:46:54 <Igloo> See how short you can make it - that might provide some sort of challenge  :-)
08:47:02 <psi> is there some "map" thing going on?
08:47:16 <shapr> CosmicRay: write something that Igloo can't improve. *that* will be a challenge.
08:47:19 <CosmicRay> Igloo: ahh, perhaps so, but I usually aim for readability.  maybe I've had the wrong goal all along :-)
08:47:25 <CosmicRay> shapr: hehe
08:47:45 <CosmicRay> shapr: I guess I'll have to convert this CSV file into a giant list of bools first... <ducks>
08:47:55 <ddarius> Do it at the type level, that should be interesting ;)
08:49:11 <CosmicRay> ddarius: indeed, since I have no idea what exactly it is that you're suggesting :-)
08:49:55 <psi> nevermind my question, i figured it out
08:50:19 <CosmicRay> you know, the more I hang out here and on the haskell lists, the more I feel like a newbie
08:50:19 <Darius> CosmicRay: That just makes it more challenging.
08:50:25 <shapr> psi: What was the answer?
08:50:43 <CosmicRay> usually when I've been working with a language and its community for a few months, I feel pretty good about my abilities
08:51:00 <CosmicRay> haskell just shows me over and over how much more I could be learning
08:51:07 <shevegen> hehe
08:51:09 <shapr> I feel the same way.
08:51:14 <shapr> And it's been THREE YEARS!
08:51:18 <CosmicRay> hehe
08:51:56 <CosmicRay> the fact that I don't even understand half the *questions* on the list is a bad sign :-)
08:52:22 <shapr> CosmicRay: I found a neat question last night, how to do typesafe Penrose tiles?
08:52:38 <psi> shapr: well, at first i didn't know what the binding function for the list monad did, so i looked it up. it does a concatMap, apparently, so it makes sense!
08:52:51 <shapr> CosmicRay: How do you implement a type-safe version of this - http://www.cs.uidaho.edu/~casey931/puzzle/penrose/penrose.html ?
08:52:55 <ozone> welp, looks like i'm lucky enough again to discover obscure GHC 6.4 template haskell bugs
08:53:00 <Darius> psi: Follow the types.
08:53:13 <shapr> Follow the yellow typed road!
08:53:26 <CosmicRay> shapr: see, another question I don't understand!
08:53:36 <CosmicRay> shapr: penrose tiles sound like something to put on my shower wall
08:53:38 <psi> Darius: what do you mean?
08:53:41 <stepcutHM> CosmicRay: by the way, here is something that I don't think can be done with a dialplan: Games with state
08:53:42 * CosmicRay follows the url
08:54:01 <CosmicRay> haha
08:54:07 <CosmicRay> stepcutHM: what about per-call variables?
08:54:28 <CosmicRay> stepcutHM: doesn't it sound just a little sad to be dialing up a computer to play a game with it using touchtones? :-)
08:54:48 <psi> it was actually mentioned earlier in the text, i had just forgotten about it
08:55:06 <Darius> psi: Oftentimes just seeing how/getting the types to work together makes what's going on clear(er)
08:55:34 <CosmicRay> shapr: so you want a way to represnet the actual content of the rhomb with a type, so that the compiler can verify a tiling solution for you?
08:55:46 <CosmicRay> or jsut a generic type to represent a rhomb?
08:56:00 <shapr> I want a way to make sure that the tiles are put together according to those tiling rules.
08:56:45 <psi> Darius: *nod*
08:57:27 <stepcutHM> CosmicRay: oh yeah, I forgot about per call variables...
08:57:32 <CosmicRay> shapr: and you want the compiler to enforce those?
08:57:45 <shapr> Yup
08:57:55 <stepcutHM> CosmicRay: but with a 1900 number and the right game, you could be rich ;)
08:57:55 <CosmicRay> shapr: sounds like this is great thesis material :-)
08:58:02 <shapr> I've had some ideas, none of which have really worked.
08:58:03 <CosmicRay> haha
08:58:25 <CosmicRay> stepcutHM: see what I mean?  too much functionality in dialplan to justify a haskell interface to agi :-)
08:58:34 <CosmicRay> than I discovered /var/spool/asterisk/outgoing the other day.
08:58:37 <CosmicRay> s/than/then/
08:58:51 <CosmicRay> highly disappointing that scripting a pbx is so trivial. :-)
08:59:35 <stepcutHM> CosmicRay: maybe we are going the wrong direction then, maybe we need a DSL for generating dial plans ;)
08:59:39 <CosmicRay> shapr: yes, it seems tricky to represent those precise relationships in a 2-dimensional space
08:59:43 <CosmicRay> stepcutHM: haha
08:59:47 <shapr> CosmicRay: did you see the asterisk question to you on planet.debian.org ?
08:59:55 <CosmicRay> stepcutHM: actually, you may have something there
08:59:59 <CosmicRay> shapr: hmm, no, checking
09:00:14 <shapr> basically, 'how to rotate logs during a call?'
09:00:18 <CosmicRay> stepcutHM: could generate a extensions.conf or a dialplan in mysql
09:00:20 <shapr> I think the solution is anacron, btw.
09:00:39 <CosmicRay> shapr: ah, I have discussed this with the guy on the bts, it was my bug that he's talking about
09:01:55 <CosmicRay> shapr: I basically told him to either disable the sqlite logging by default, or to write a little sqlite client that uses sql queries to accomplish it
09:02:16 <shapr> What about a conditional anacron statement?
09:02:40 <shapr> Like, "rotate log files as soon as a call is not in-progress"
09:02:49 <shapr> though that will fail with multi-day calls, I guess.
09:03:11 <CosmicRay> shapr: and at busy sites, where there may never be a time when there is not a call in process
09:03:25 <stepcutHM> CosmicRay: doesn't asterisk have (or maybe it was dropped) mysql support already ?
09:03:29 <tuomov> eh.. haskell doesn't have float^float?
09:03:45 <CosmicRay> stepcutHM: yeah, it does, not sure if it's part of the mainline though
09:04:17 <CosmicRay> stepcutHM: I've only looked into that peripherally... what I gather is that there are at least two distinct database itnerfaces in asterisk 1.0.x, one for cdr and the other for things like extensions.conf, and apparently in cvs these are unified
09:04:50 <CosmicRay> ah ha!  I could write a haskell program to rotate the sqlite files! :-)
09:04:56 <TheHunter> @type (**)
09:04:57 <Darius> @type (**)
09:04:58 <lambdabot> (**) :: forall a. (Floating a) => a -> a -> a
09:04:58 <lambdabot> (**) :: forall a. (Floating a) => a -> a -> a
09:05:14 <CosmicRay> tuomov: one would usually use a Double
09:05:18 <tuomov> another function not documented..
09:05:21 <tuomov> yeah, I use Doubles
09:05:26 <tuomov> float is a general term...
09:05:40 <Darius> It's a standard function
09:06:09 <tuomov> I was scanning the ghc library documentation and it is not documented there
09:08:44 <Darius> It's in class Floating which is in the Prelude and the GHC documentation for the Prelude.
09:09:26 <CosmicRay> but the ghc docs don't say what (**) does
09:10:49 <Darius> Presumably they considered it obvious or assumed that one would check the Prelude as none of Floating's methods have descriptions
09:11:18 <tuomov> well ^ and ^^ are documented which are more obvious
09:12:03 <mflux> btw, is there a haskell-newsgroup?
09:12:41 <shapr> There's c.l.f, LtU, sequence, gmane.org mirrors of the mailing lists.
09:12:42 <ibid> comp.lang.functional is closest
09:12:49 <wilx> @wiki
09:12:50 <lambdabot> Sorry, I don't know the command "wiki", try "lambdabot: @listcommands"
09:13:02 <ibid> LtU, sequence, gmane and mailing lists are not newsgroups :)
09:13:03 <Darius> (+), (-), and (*) aren't.  Perhaps the fact that most of the methods in Floating would be like "sin :: a -> a computes sine" led to them not describing any of them.
09:13:09 <shapr> wilx: http://www.haskell.org/hawiki/FrontPage
09:13:43 <shapr> ibid: true, but I took the liberty of assuming that mflux might want Haskell news via web or nntp.
09:14:23 <ibid> :)
09:15:34 <CosmicRay> ibid: sequence isn't a mailing list ;-)
09:15:54 <mflux> too much information in this regard is quite tolerable
09:16:07 <ibid> CosmicRay: did i say so? :)
09:16:27 <CosmicRay> err, no  you didn't :-)
09:19:00 <mflux> comp.lang.functional looks like endless of hours of wasting time.
09:19:01 <mflux> perfect!
09:19:13 <CosmicRay> heh
09:22:11 <CosmicRay> shapr: http://changelog.complete.org/node/265
09:22:33 <shapr> This discussion on extremeperl is entertaining.
09:22:43 <shapr> It's a lot like usenet, but more polite.
09:23:41 <CosmicRay> and without the penis spam, I hope?
09:23:42 <CosmicRay> url?
09:23:54 <CosmicRay> usenet is one hell of a spammy place
09:24:00 <shapr> http://groups.yahoo.com/group/extremeperl/messages
09:24:03 <CosmicRay> I used to love usenet but I rarely use it anymore
09:25:24 <CosmicRay> nice, shapr.  http://groups.yahoo.com/group/extremeperl/message/194 is insightful.
09:26:41 <shapr> Rob's claim is that he can learn everything he needs to know about Haskell/Prolog/etc without leaving Perl.
09:26:52 <CosmicRay> yeah, that is silly
09:26:53 <shapr> Not everyone agrees.
09:28:00 <shapr> I used Perl once for a coupla weeks... somewhere between 1997 and 1999. I'm tempted to propose that I learn Perl5, and Rob learns Haskell, and as metaperl suggested, we document it on the extremeperl list.
09:28:11 <CosmicRay> I learned ocaml, and then haskell, precisely because I wanted to experience a idfferent way of solving problems.
09:28:18 <CosmicRay> heh
09:29:02 <CosmicRay> whoa, haskelldb on a perl list
09:29:29 <shapr> That's how the whole thing got started. Rob found HaskellDB, asked about it on-list. metaperl_ pointed me to his question.
09:29:40 <CosmicRay> you know, in the past month or so, me respect for the perl community has shot upwards tremendously, and my respect for the python community has shot downwards
09:29:44 <shapr> and tadah! Global Thermonuclear War!
09:29:52 <CosmicRay> crap, AGAIN?!!!
09:30:02 <shapr> CosmicRay: strangely enough, I'm totally with you there.
09:30:15 <CosmicRay> yeah, it is strange, isn't it
09:30:25 <Philippa> is it much more than the attitude towards multiple ways of doing things associated with the language designs?
09:30:31 <CosmicRay> python was my language of choice for 4 years
09:30:51 <shapr> For me something like 7 years.
09:31:01 <CosmicRay> Philippa: I think, for me, it's the willingness to consider new ideas.
09:31:14 <CosmicRay> Philippa: I still don't like perl5 the language.
09:31:30 <CosmicRay> Philippa: but the perl hackers I've come into contact with lately seem much more open to new ideas than, say, guido
09:31:38 <CosmicRay> hell guido is bent on *removing* good ideas from python.
09:31:38 <shapr> Yeah, I agree.
09:31:41 <Philippa> CosmicRay: I guess I mean the communal tendencies that spring from those different principles
09:32:01 <Philippa> though yeah, I guess some of the comments about obfuscation you hear from the python crowd are a wee bit closed-minded
09:32:24 <shapr> I don't think it's about Python's "One Best Way" or Perl's "More Than One", but I'm not sure what it really is.
09:32:40 <CosmicRay> right, it's not that...
09:32:54 <CosmicRay> I have a great deal of respect for the basic idea of a "clean" language
09:32:59 <shapr> Though I guess you could say that Perl's "more than one" includes Perl, and Python's One Best Way only includes Python.
09:33:07 <shapr> Philippa: I see your point there.
09:33:25 <CosmicRay> I think that the desire for a clean language prompted the python one best way mentality
09:33:34 * Philippa nods
09:33:40 <Philippa> the One Best Way is let and lambda though ;-)
09:33:44 <CosmicRay> and I think they're taking it too far now in some ways, and abandoning it totally in others
09:33:47 <shapr> So, both recursively applied, Perl's philosophy says that Perl is not always the best solution, and Python's says that Python always is?
09:33:55 <CosmicRay> heh
09:34:05 <CosmicRay> sneaky, shapr
09:34:20 <shapr> Isn't that what Philippa said?
09:34:31 <shapr> I think Philippa just wan't so explicit about it.
09:34:45 <CosmicRay> I didn't quite follow what philippa said, actually
09:35:01 <Philippa> shapr's pretty much nailed what I was saying, yeah
09:35:29 <CosmicRay> in concrete terms, there were perl guys on this channel asking honest questions about haskell because they seek knowledge
09:35:34 <Philippa> part of the problem I have with the pythonic attitude towards cleanliness is that they have a high moving part count still
09:35:41 <shapr> What's Haskell's philosophy? Maybe a Ph.D. in math just isn't enough math education? =)
09:35:44 <CosmicRay> the python guys would immediately assume that they already have the best answer and not bother.
09:35:59 <CosmicRay> I used to think that's what the perl community was like, too.
09:36:04 <CosmicRay> I guess I was mistaken
09:36:12 <shapr> CosmicRay: yeah, same here.
09:36:22 <Philippa> there're parts of it where that's true, but not as much as you might think
09:36:24 <vegai> shapr: "The learning never ends"
09:36:26 <CosmicRay> or maybe, as the discussion on metaperl's blog suggests, there is some signal amongst the noise :-)
09:36:32 <shapr> vegai: oh I LIKE that!
09:36:50 <CosmicRay> vegai: dammit, that reminds me of the DQ commercials!
09:36:54 <shapr> DQ?
09:36:57 <CosmicRay> dairy queen
09:37:02 <CosmicRay> ice cream chain in the us
09:37:12 <shapr> Dairy Queen teaches you stuff everyday?
09:37:16 <CosmicRay> "where the feeling never ends" is/was their little jingle
09:37:23 <CosmicRay> damn annoying
09:37:33 <CosmicRay> shapr: only where not to buy chicken :-)
09:37:37 * shapr snickers
09:37:49 <CosmicRay> and the "feeling" the speak of is indigestion
09:37:50 <shapr> I still have some of their aluminum ice-creams coins they used to hand out.
09:37:50 <CosmicRay> but hey
09:37:58 <shapr> Those were nifty.
09:38:01 <CosmicRay> their ice cream is decent
09:38:04 <shapr> yeah, it is.
09:38:10 <CosmicRay> but their hot food sucks
09:38:30 <Khisanth> <CosmicRay> "where the feeling never ends" is/was their little jingle <- that sounds suprisingly painful for an icecream commercial
09:38:37 <CosmicRay> hehe
09:38:55 <Philippa> re philosophy, I do like how once you've got all the type declaration out of the way Haskell is just lambdas, applications, lets and case analysis/pattern-matching. The rest's syntactic sugar, and pretty simply so.
09:39:17 <Philippa> All the complicated bits are in the type system and don't appear in the rest of the code. The bits that /do/ things are simple
09:39:32 <Philippa> Khisanth: sensitive teeth?
09:39:53 <Khisanth> Philippa: no, I was thinking about eating icecream too fast :p
09:41:05 <Philippa> that's one of the easiest ways to set sensitive teeth off, too...
09:43:11 <shapr> heippa hei musasabi
09:43:21 <SyntaxNinja> hi all
09:43:28 <shapr> hiya SyntaxNinja
09:43:45 * shapr grumbles
09:43:52 <shapr> I have to reboot, too much swapping going on now.
09:45:56 * Darius feels like some Nanase
09:46:19 <CosmicRay> shapr: what is top saying if you kill x?
09:47:08 <SyntaxNinja> CosmicRay: you tried.
09:48:11 <CosmicRay> heh
09:48:35 <SyntaxNinja> Igloo: you come right before me on the tally sheet; I wonder if our nicks are next to each-other alphabetically
09:48:39 <SyntaxNinja> by nick i mean debian id
09:48:58 <Igloo> You mean of all DDs?
09:49:11 <SyntaxNinja> ja
09:49:46 <Igloo> They are on gluck, but I think that is created on log-in
09:50:07 <Igloo> Someone with some LDAP-fu could probably find out
09:50:33 * CosmicRay afks for lunch
09:51:04 <Igloo> Ah, no, there's an igor
09:51:11 <SyntaxNinja> damn igor
09:51:37 <SyntaxNinja> I met one of my best friends becuase his name was alphabetically close to mine in 5th grade.
09:51:45 <SyntaxNinja> of course I hated him back then, but we're good friends now.
09:52:05 <Igloo> You hated him because of his name?
09:52:20 <musasabi> hellp shapr
09:53:24 <Philippa> he's not on atm
09:55:10 <SyntaxNinja> Igloo: no, he's not like igor
09:55:24 <SyntaxNinja> I hated him because he was a big jerk.  he's ralf, he comes here sometimes.
09:55:44 <Igloo> Heh, OK  :-)
09:56:50 <basti__> oh fudgets HAS a new version (05!)
09:57:14 <SyntaxNinja> I swear that #debian-women has been talking about food for 15 hours straight.
09:57:36 <basti__> whats bad about food?
09:58:18 <SyntaxNinja> nothing. I like food personally.
09:58:40 <SyntaxNinja> in fact, I'm drinking some right now.
10:01:39 <ibid> when are you planning on eating a drink, SyntaxNinja?
10:02:07 <ibid> (eating and drinking are usually complementary activities:)
10:02:14 <Philippa> hmm, vodka jelly?
10:03:12 <ibid> a coworker actually told me the other day how to make something like that
10:03:20 <SyntaxNinja> ibid: it's coffe, it's like food.
10:03:36 <ibid> SyntaxNinja: beer would be more food-y
10:04:00 <SyntaxNinja> hey, there's a way to use guards in any-old expression, right? like instead of using a nested if-then-else-if-else thing?
10:04:12 <ibid> case?
10:04:14 <Philippa> especially a stout
10:04:21 <SyntaxNinja> like case foo of x > 3 -> ... | y < 2
10:04:36 <ibid> of _ | x > 3 ...
10:04:50 <SyntaxNinja> ibid: not quite a case statement; what should be in 'foo' though?
10:04:57 <SyntaxNinja> Philippa: stouts are my favorite :)
10:05:12 <SyntaxNinja> here in portland we have this awesome Terminator Stout. mmmm
10:05:22 <Philippa> I've mixed feelings - Guinness used to be my main pint and that did hell for my waistline...
10:05:24 <Darius> case () of _ | p x || q y -> foo | otherwise -> bar
10:05:32 <ibid> SyntaxNinja: ()
10:05:33 <Philippa> (not least 'cos I could keep up with the lads drinking lager)
10:05:40 <SyntaxNinja> Philippa: haha
10:06:02 <SyntaxNinja> Terminator tastes like Guiness before it gets shipped over the ocean to me
10:06:11 <SyntaxNinja> Darius: ibid thanks...
10:07:00 <SyntaxNinja> haskell-mode really doesn't like this.
10:08:40 * Darius doesn't really like it either.
10:09:12 <Darius> You could also use a value with guards
10:09:46 <SyntaxNinja> eh, an if ended up working best. go figure
10:09:57 <SyntaxNinja> Darius: what do you mean?
10:11:31 <Darius> f x = y where y | p x = bar | otherwise = baz (or let)
10:11:43 <SyntaxNinja> ah hmm
10:11:53 <Philippa> SyntaxNinja: I tend to go for slightly fruity ales most of the time
10:12:18 <Philippa> actually, these days I mostly just don't drink due to bad interactions with various stuff I'm on, but hey
10:12:55 <Lemmih> SyntaxNinja: Hackage isn't proceeding as nicely as it should. The development has stalled again.
10:13:12 <Igloo> What's up, Lemmih?
10:13:17 <SyntaxNinja> Lemmih: did you get uploading tgzs working? what's wrong?
10:13:30 <SyntaxNinja> Lemmih: I'm going to start hacking on it this weekend, fwiw.  if that's OK?
10:14:33 <Lemmih> Sure (: It's open source.
10:14:55 <basti__> hmm what is ghumake?
10:15:18 <Lemmih> But the HTML interface is turning me off.
10:15:29 <basti__> fugets needs this program for building, it says
10:15:41 <SyntaxNinja> there are tedious bits to every system.
10:15:48 <SyntaxNinja> basti__: here's to hoping it's a typo for gnuMake
10:16:05 <basti__> hmm
10:16:12 <basti__> but that program is called gmake isnt it?
10:16:59 <SyntaxNinja> yeah, or make
10:17:03 <basti_> uh ghumake
10:17:04 <basti_> sorry
10:17:06 <cathper> special version of http://www.cs.chalmers.se/~hallgren/Thesis/humake.html ?
10:18:02 <basti_> hmm
10:41:19 <andrei_> Hi, anyone have any clue if ghci works on amd64? I'm getting one of those fun, the impossible has just happened errors
10:41:22 <andrei_> ?
10:41:59 <psi> i'm going nuts. what's wrong with this? main = system "uname -a" >> return ()
10:42:05 <psi> it says "system not in scope"
10:42:13 <psi> i have imported System
10:42:19 <_JusSx_> import System
10:43:20 <SyntaxNinja> import System(system) will probably give you a better error message
10:43:29 <basti_> lol
10:43:51 <_JusSx_> lol
10:43:52 <SyntaxNinja> import System.Cmd(system)
10:43:53 <_JusSx_> yeah
10:44:15 <SyntaxNinja> what's so funny?
10:44:36 <basti_> yes its rather sad.
10:45:16 <psi> thanks SyntaxNinja. i don't get it, though. just "import System" worked a few minutes ago.
10:45:57 <SyntaxNinja> psi: difference between ghc 6.2 and 6.4, I believe.
10:47:10 <psi> it was the same ghc. i just changed something in the source file, reverted the changes, and then i tried to recompile.
10:47:18 <SyntaxNinja> which ghc?
10:47:36 <psi> 6.2.2
10:47:38 <SyntaxNinja> hiya shapr
10:47:38 <Lemmih> shapr: That was a long reboot.
10:47:40 <shapr> y0
10:47:47 <shapr> Lemmih: well, I met this woman, and ....
10:47:50 <SyntaxNinja> psi: hm. 6.2.2 should work, I think.
10:48:16 <SyntaxNinja> psi: but System.Cmd is better anyway. if you say 'import System(system)' does it say "System doesn't export system" or something?
10:48:22 <psi> SyntaxNinja: yep
10:48:31 * SyntaxNinja shrugs
10:48:42 <psi> i wonder why it did export it earlier :)
10:49:31 <andrei_> Anyone have a clue about that ghci /amd64 thing?  I have a working 6.2.2, it just happens in 6.4
10:50:28 <SyntaxNinja> psi: no clue; the 6.2 docs I have in front of me clearly show System exports system.
10:51:59 <shapr> CosmicRay: 160mb of ram used over and above buffers, with pretty much nothing running.
10:52:08 <shapr> I still had necessary kernel services running though.
10:53:11 <Philippa> re shapr
10:53:19 <shapr> Is there some difference between 6.4 debs and everything else? Specifically with the posix-1.0 package?
10:53:36 <psi> SyntaxNinja: hah, i was probably because i called my source file 'system.hs' ;) it worked the first compile, but not after that
10:54:15 <psi> i renamed it, and it works now
10:54:28 <Darius> Hmm, what happens if you have a module import something from itself
10:54:47 <shapr> You probably need a hs-boot
10:55:18 <SyntaxNinja> psi: heh
10:55:27 <shapr> musasabi: you screamt?
10:56:48 <musasabi> shapr: just typoed pong-hello.
10:57:03 <shapr> oh
10:57:41 <shapr> Oh yeah, I was going to ask you your opinion on a 'code as literature' website that would be vaguely related to the Shootout.
10:58:29 <musasabi> I think that a poetry review like approach would work better than the shootout approach.
10:58:52 <shapr> Did you have a chance to look at that paper?
10:59:37 <musasabi> no, have been doing (non-haskell) coding 16h/day this week..
10:59:41 <shapr> yow
10:59:51 <SyntaxNinja> hi xerox
11:00:45 <xerox> Hello!
11:00:52 <shapr> excitement!
11:01:14 <xerox> Did you hacked something nifty in pugs?
11:01:24 <shapr> No, sadly not.
11:01:42 <shapr> I can't get it to build, but other people on debian/unstable ghc6.4 can, so I think it's the darcs mirror.
11:02:04 <shapr> I have just grabbed the svn repo, (though I'd rather use darcs) I'll see if it works there.
11:02:21 <musasabi> When I get a little time I think of finally integrating Codec.Compression.LZF into SerTH and doing the next release.
11:03:59 <xerox> I think I'll play Go this night.
11:04:34 <shapr> oh waitasec
11:04:35 <SyntaxNinja> sweet
11:04:39 * Philippa needs a non-moron, somewhat Go-aware beginner to play against
11:05:08 <Philippa> if I ask for a beginner most places I get someone who does stuff like building gridwork in a corner they already own...
11:05:14 <Philippa> or who loses on their second move
11:05:28 <musasabi> Philippa: what level are you?
11:05:49 <Philippa> 'just started playing'
11:05:59 * xerox remings people: @wiki HaskellGoPeople
11:06:06 <Philippa> well, for 2 years but handful of games values of 'just'
11:06:22 <shapr> Wait, are the standard debian/unstable debs ghc6.4 ?
11:06:44 <SyntaxNinja> no
11:06:46 * musasabi was 15k few years ago but haven't really had time for go in the last years.
11:06:46 <xerox> shapr: I think not, but it passed some time from the last time I checked.
11:06:55 <musasabi> shapr: haskell-unsafe has 6.4
11:06:57 <SyntaxNinja> shapr: are you asking if 6.4 is in sid?
11:06:57 <shapr> well fooey
11:07:02 <xerox> I use halioth or whatever is called.
11:07:12 <musasabi> shapr: it is probably not going into sid before sarge is splitted.
11:07:26 <shapr> This explains my Pugs build problems then.
11:07:37 <musasabi> debian-haskell had a thread about it this week.
11:08:12 <xerox> @fortune
11:08:13 <lambdabot> Couldn't find fortune file
11:08:32 <musasabi> To make it short, sarge is going to be 6.2 and making updates to sarge that don't go via sid is painful.
11:08:52 <xerox> If anyone wants to play, I'm xerox on KGS too.
11:09:08 <Philippa> you any good?
11:09:21 <Philippa> I forget if I had an account or not, still got the client I think...
11:09:36 <shapr> I am very confused now.
11:09:37 <xerox> I was an 8k, before stopping for some time, now I'm likely around 12-10k.
11:09:45 <Philippa> you'll slaughter me then :-)
11:09:50 <shapr> I asked theorbtwo for dpkg -s ghc6, he gave http://sial.org/pbot/8806
11:09:57 <xerox> That's not the purpose of the game, tought :)
11:10:02 <shapr> his version shows as ghc6.4-2
11:10:21 <shapr> my version shows as 6.4-1
11:10:38 <basti_> hmm shapr have you ever compiled fudgets?
11:10:56 <shapr> basti_: no, but I reported a bunch of bugs in my attempts to do so.
11:11:02 <Philippa> xerox: yeah, I know that much. You'll do the abstracted equivalent though
11:11:05 <basti_> lol
11:11:16 <xerox> brb
11:11:26 <basti_> i'm like "?" all the time
11:11:36 <basti_> and wondered if i should write my own widgets lib in hopengl
11:11:38 <musasabi> the right number of handicap will help much.
11:11:39 <basti_> -poit-
11:11:54 <basti_> musasabi: for compiling fudgets?
11:12:17 <musasabi> basti_: I think it is more helpful in go ;)
11:12:50 <basti_> ah.
11:13:39 <Philippa> thankfully I at least understand the relevance of that :-)
11:13:42 <shapr> Igloo: is ghc6.4-2 in experimental or something?
11:13:46 <shapr> I am so lost.
11:13:48 <Philippa> but I've a lot of learning to do
11:14:12 <x3n0n> if I weren't at work, I'd be a good 20kyu-er for you
11:14:45 <musasabi> Philippa: When I was starting it helped me to get tactical things right on 9x9, so that I wouldn't lose my games on the large board because of them.
11:14:47 <SyntaxNinja> shapr: ghc 6.4-something is in experimental
11:14:50 <SyntaxNinja> fwiw
11:15:58 <shapr> What's the trick to get something from experimental when I'm using unstable?
11:16:14 <shapr> -t maybe?
11:16:39 <SyntaxNinja> if it has a higher number, it'll just get installed after an update
11:16:48 <basti_> debian? you'd need to define a source for apt...
11:16:49 <xerox> Back, parents..
11:16:52 <basti_> ...i think
11:16:57 <basti_> parents? whats that?
11:17:09 <SyntaxNinja> basti_: I think he already has; I hope :)
11:17:58 <basti_> this is getting too complicated.
11:18:35 <xerox> I mean, parents ever want something.  But I'm back.
11:18:46 <basti_> -g-
11:19:18 <SyntaxNinja> shapr: do you have haskell-unsafe in your /etc/apt/sources.list? if so, what happens when you apt-get update && apt-get install ghc6?
11:19:32 <SyntaxNinja> also, what is the current situation?
11:19:45 <shapr> current situation is that I have unstable and haskell-unsafe in my sources.list.
11:19:56 <shapr> I have ghc6.4-1 installed.
11:20:20 <shapr> I can't build pugs, but theorbtwo from #perl6 can build pugs. His dpkg -s ghc6 output shows ghc6.4-2
11:20:37 <shapr> ergo, I am confused.
11:22:23 <SyntaxNinja> but did you apt-get update?
11:22:39 <shapr> yes I did.
11:22:41 <SyntaxNinja> because you might have installed ghc 6.4-1 when that was the newest version, but now it's not.
11:22:56 <SyntaxNinja> http://haskell-unsafe.alioth.debian.org/archive/i386/unstable/g/ghc6/
11:23:15 <SyntaxNinja> looks like 6.4-1 is the newest, wonder where theorbtwo got -2?
11:23:20 <shapr> That's what I was wondering.
11:23:36 <shapr> But it sure looks right - http://sial.org/pbot/8806
11:24:06 <shapr> autrijus can also build pugs with ghc6.4, so I assume he has 6.4-2 as well.
11:26:31 <shapr> hmmm - http://ftp.debian.org/debian/pool/main/g/ghc6/ghc6_6.4-2.dsc
11:26:44 <shapr> Maybe my local mirror isn't updating correctly?
11:29:14 <shapr> SyntaxNinja: looks to me like 6.4-2 is only in experimental.
11:31:15 <shapr> y0 metaperl__
11:31:35 <metaperl__> hi
11:31:59 <basti_> hi metaperl__
11:32:16 <metaperl__> hello
11:32:45 <xerox> Whoops, Philippa?
11:32:49 <Philippa> yeah
11:32:55 <Philippa> my connection does this once in a while
11:33:41 <shapr> hiya nmoore
11:33:42 <nmoore> hi, i'm working on an implementation of the LZW codec, is there a sensible way to process data in 12 bit chunks? or should i just use lists of length 12?
11:33:51 <nmoore> shapr:hi
11:34:06 <shapr> Are you writing LZW for educational purposes?
11:34:09 <nmoore> there's nothing special about 12 incidentally
11:34:10 <nmoore> yes
11:34:16 <Heffalump> use lists then
11:34:24 <shapr> ok, otherwise I'd point you to existing LZW implementations.
11:34:36 <nmoore> yes, it's for fun
11:34:46 <nmoore> ;-)
11:35:04 * shapr understands.
11:35:18 <shapr> My fun project of the moment is type-safe Penrose tiles. No clue how that'll work.
11:35:33 <basti_> :-O
11:35:49 <nmoore> i'm only starting with haskell, and it seems difficult enough for me to learn something, but not too hard
11:37:23 <Heffalump> shapr: I have no idea what that means, let alone how it'd work. (I know what a Penrose tile is)
11:38:07 <shapr> I want to enforce the tiling rules via the typesystem.
11:38:44 <basti_> but uhm
11:38:47 <basti_> i
11:38:48 <basti_> well
11:38:55 <shapr> I know how to enforce thin connects to fat, and how to enforce what flavors of edge must connect to the others. I don't know how to enforce space-filling.
11:39:25 <basti_> a circular type? ;)
11:39:33 <Heffalump> you want the type system to model the real numbers??
11:39:41 <shapr> Right now I'm treating a tile as a node in a graph, with four typed edges.
11:40:28 <shapr> data Edges = NoneBlack Tile (Maybe Tile) | BlackNone Tile (Maybe Tile) | NoneGrey Tile (Maybe Tile) | GreyNone Tile (Maybe Tile)
11:41:19 * basti_ .oÂ° (        .         )
11:41:22 <shapr> nmoore: aanyway, how are you processing data now?
11:41:46 <nmoore> shapr: i haven't started yet, i'm just ruminating over the possibilities
11:42:05 <shapr> Heffalump: I think I might be able to use GADTs to do it, what do you think?
11:46:05 <Heffalump> I'd be very surprised.
11:46:21 <nmoore> thanks for the help
11:46:58 <basti_> shapr: i do not have the slightest idea what your tiling type would be useful for.
11:47:11 <shapr> Nor do I.
11:47:17 <shapr> But it sounds like a cool thing to do.
11:47:35 * basti_ nods.
11:47:52 <shapr> How could you enforce tiling by itself?
11:48:29 <basti_> hmm for example an one-dimensional tiling of identical things would be something like the tuple type.
11:48:45 <basti_> (identical, self-matching shape)
11:49:00 <shapr> For example, if you have two values, both of which represent pairs of squares, one above the other, How do you enforce that connecting the top two side-by-side must connect the bottom two side-by-side?
11:49:42 <basti_> hmmm.
11:49:53 <basti_> let me think about it
11:50:06 * basti_ powers emacs
11:51:58 * basti_ generally votes for dependent types btw.
11:51:58 <shapr> The only solution I can think of requires combinators.
11:52:30 <basti_> hmm
11:52:49 <basti_> isnt there some dependant types extension in haskell somewhere?
11:53:02 <shapr> In which case putting one square on top of another would give back a two-square tall result. And then other combinators would check that you've added the right things together.
11:53:11 <shapr> I think you can get dependent types with functional dependencies.
11:53:38 <basti_> I've recently understood those "evolution of a haskell programmer" things... most of them...
11:53:45 <basti_> hmm i think yes
11:54:37 <Heffalump> shapr: that's a runtime check
11:54:47 <shapr> Right, which is not what I want.
11:54:55 <basti_> yup.
11:55:12 <Heffalump> you might be able to get a compile time check using polymorphic recursion
11:56:47 * shapr reaches rank confusion
11:56:52 * Heffalump wonders if JaffaCake is actually at work, or just VPNing
11:57:08 * JaffaCake is VPNing
11:57:53 <JaffaCake> remote desktop over VPN, works a treat :)
11:58:14 <Heffalump> heh
11:58:41 <Heffalump> are you doing that just to IRC, or doing other stuff with it too?
11:59:09 <JaffaCake> nah, I could IRC from home, but I'm doing a bit of hacking too
12:00:02 * Heffalump is resisting getting a copy of my work's VPN client.
12:00:30 <shapr> Heffalump: Do you work with Seward?
12:00:46 <Heffalump> no, he left (got a grant from DARPA to hack valgrind)
12:01:03 <Heffalump> he was replaced by Alastair Reid
12:01:06 <shapr> oh
12:01:24 <Heffalump> but I'm in the product compiler group, not R&D
12:01:37 <shapr> Sounds like the hacker rating stayed about constant.
12:01:46 <JaffaCake> I thought the compiler group were all anti-Haskell
12:01:52 <Heffalump> no comment.
12:01:55 <Heffalump> ;-)
12:01:56 * shapr snickers
12:03:26 <shapr> Any tutorials on polymorphic recursion? Or more details on how it might apply to this problem?
12:03:42 <Heffalump> well, you'd have to encode the positions in the type somehow
12:03:57 <Heffalump> so use something like S (S (S ()) to represent 3
12:04:21 * Heffalump has no real idea if this is feasible, but it's the only idea I have
12:04:29 <shapr> Sounds like it might work.
12:06:42 <shapr> In fact, that might allow a true tiling type check.
12:07:01 <shapr> Though the type hackery involved would be immense.
12:07:36 <Heffalump> so the constructor SideBySide (Shape a) (Shape b) would have the type that constrained b's top-left corner to have the same y coordinate as a's, and an x coordinate that was 1 more.
12:07:42 <Heffalump> oh, that only works for squares.
12:07:57 <Heffalump> so it doesn't get you any further with making non-rectangular shapes, realy.
12:08:04 * Heffalump suspects it's a dead loss.
12:08:21 <shapr> You'd need to encode the rules for angles in polygons, concave and otherwise. But after that, I think you could specify a tile to have the type of its angles and sides, and the type system would check whether it tiles next to something else.
12:08:32 <Heffalump> oh, the Penrose tiling thing is definitely a dead loss
12:08:37 <shapr> How so?
12:08:40 <Heffalump> you have no hope of encoding real numbers in the type system.
12:08:48 <shapr> Why do I need to do that?
12:08:56 <Heffalump> angles?
12:09:05 <Heffalump> positions on the plane?
12:09:19 <Heffalump> given that the Penrose tiling is aperiodic, don't you need to compare arbitrary reals?
12:09:24 <Heffalump> Maybe it's just arbitrary rationals.
12:09:43 <Heffalump> but doing even rational arithmetic in the type system would be seriously hairy
12:10:17 <Heffalump> and you still have the same problem as for square tiles when it comes to compound shapes
12:10:20 <Darius> Not really, though it would be horribly inefficient.
12:10:26 <astrolabe> Could you tell me what you are talking about please.  I missed the beginning, but it sounds interesting.
12:10:32 <Heffalump> darius: how would you simplify 4/2 ?
12:10:36 <shapr> astrolabe: I'm trying to make type-safe penrose tiles.
12:10:51 <Darius> Heffalump: With a type level function.
12:10:54 <shapr> astrolabe: but one piece of the puzzle is how to make type-safe tiles at all.
12:10:55 <Heffalump> I'd summarise by saying shapr's gone mad, but actually he's already been like this ;-)
12:10:58 * shapr laughs
12:11:03 <Heffalump> s/ready/ways/
12:11:03 <shapr> I think I've always been like this :-)
12:11:07 <shapr> right
12:11:07 <SyntaxNinja> heya JaffaCake
12:11:17 <JaffaCake> hey there
12:11:22 <Heffalump> Darius: which is implementable in Haskell how?
12:11:45 <Igloo> Do you actually need to simplify it?
12:11:50 <Darius> Multiparameter functions and fundeps
12:11:51 <shapr> astrolabe: for example, if you have two values, both of which are one square above the other, how can you enforce that putting the top two next to each other puts the bottom two next to each other?
12:11:54 <Heffalump> how do you compare for equality, otherwise?
12:11:57 <wagle> herman geuvers stuff on formalizing mathematics (in twelf, i think) seemed pretty cool: http://www.cs.ru.nl/~herman/research.html
12:11:58 <Igloo> Ignoring efficiency
12:12:05 <astrolabe> Wow.  I don't know what that means, but I suspect the key coordinates of penrose tiles are algebraic integers (or as good as), and so can be stored using integers only.
12:12:07 <Darius> multiparameter typeclasses
12:12:29 <Igloo> By cross multiplying an simplifying integers. Dunno if that's any easier than simplification, though
12:12:30 <Heffalump> darius: you're claiming you can implement division on the type level using MPTCs?
12:12:39 <Darius> and fundeps
12:12:42 <Igloo> s/simplifying/comparing/
12:12:59 <wagle> nooo..  i mean Coq
12:13:03 <Darius> Perhaps with -fallow-undecidable-instances if that becomes necessary.
12:13:10 <Darius> But at that point...
12:13:52 <Heffalump> igloo: oh, true.
12:13:58 <wagle> "Construction of the reals in Coq"
12:14:09 <shapr> I think that solving the 'next to each other' squares problem will solve most of the Penrose tiles problem.
12:14:15 <astrolabe> Could you do it with a one-dimensional tiling?
12:14:36 <shapr> How do you do 1D tiles?
12:14:56 <Darius> intervals, but "tiling" them is pretty trivial I'd say ;)
12:15:08 <wagle> bin packing?
12:15:26 <shapr> That's an interesting point.
12:15:32 <astrolabe> a finite alphabet, where b can follow a iff aRb
12:15:56 <shapr> But how does that help with tiling groups of squares?
12:17:08 <astrolabe> I may be getting the wrong end of the stick.  Do you colour the edges of the squares, and only allow adjacency if the edges match?
12:18:14 <Heffalump> 1D tiles are trivial because any tile can be represented by two numbers.
12:18:35 <shapr> I'd color edges for Penrose tiles, but for the simpler problem of tiling groups of groups of tiles, you wouldn't need to.
12:18:36 <Heffalump> 2D tiles are much much harder because you need a list of arbitrary length *and ways to match up such lists at the type level*
12:18:58 <wagle> n-gons?
12:19:00 <astrolabe> I suspected so Heffalump, but my haskell knowledge is very weak.
12:19:38 <astrolabe> A list is only half infinite at best.
12:19:41 <shapr> It's an interesting point though... can you color a group of groups in such a way that unique common paths are found?
12:20:09 <wagle> do i have to dig carefully through the scroll back, or is there a short one-liner summary of what the current topic here is?
12:20:20 <shapr> wagle: Type safe Penrose tiles.
12:20:33 <Heffalump> using the type system to enforce adjacency of 2D objects
12:20:40 <Philippa> shapr: Arrows. TH. Do your own type checking?
12:20:49 <shapr> Philippa: that's runtime though, isn't it?
12:20:51 <wagle> hmm..  you seen penrose's new book?
12:21:06 <Philippa> shapr: not if you run the static part at compile time
12:21:11 <astrolabe> It is on its way to my bookshelf of shame.
12:21:13 <Heffalump> that's cheating.
12:21:18 <shapr> astrolabe: is it that bad?
12:21:29 <Philippa> though thinking about it you couldn't do it sanely atm due to the splicing/modules thing
12:21:41 <Heffalump> and it doesn't give you any guarantees about programs that only determine the layout at runtime, which are the interesting ones
12:21:41 <Philippa> Heffalump: yes :-)
12:21:41 <wagle> its good, just not as introductory and sir roger was hoping
12:21:48 <Philippa> and, well, yeah
12:21:49 <wagle> its good, just not as introductory as sir roger was hoping
12:21:50 <astrolabe> The first couple of chapters aren't, but I'm too busy these days.
12:22:11 <wagle> its gotten me to move my "visual complex analysis" book to the top of my reading list
12:23:28 <wagle> but i bring it up because i can the feeling that penrose was building the intuition to think about tilings differently than what you are doing here..  but i havent gotten far enough to say for sure
12:23:49 <shapr> Like what?
12:24:14 * xerox screams "who's next!"
12:24:32 <shapr> xerox: did you win?
12:25:23 <wagle> something to do with a better way to view complex analysis..  except i cant follow his complex analysis close enough, hence my prioritizing the visual complex analysis book to "urgent"
12:25:38 <xerox> shapr: I exxagerated.
12:25:48 <xerox> (I'm a little sorry)
12:31:49 <xerox> But I think it was ok as tutoring game..
12:31:49 <wagle> i can see that something really cool is happening in the flashes i can see of the complex analysis, but nothing i can yet verbalize
12:31:49 <wagle> take a look at the book
12:31:49 <zamez> that book is good, wagle
12:31:49 * shapr is saving up for more hardware
12:31:49 <zamez> at least I found it helpful
12:31:49 <shapr> Sure looks tasty - http://www.usfca.edu/vca/
12:31:49 <shapr> After reading the blurbs on that page, maybe I'm not too poor to buy that book.
12:31:49 <zamez> don't you have a library that can buy it for you? :>
12:31:49 <shapr> Nope. I'm a self-employed contract programmer.
12:31:49 <wagle> i need to read that book before getting back to penrose's book: "The Road to Reality"
12:32:37 <mwc> Hmm, somebody stealing fire from the Ocaml crowd with that discriminating hackers crowd?
12:32:50 <xerox> I'm reading a "Road to", too :)
12:33:02 <Heffalump> mwc: sorry?
12:33:04 <wagle> where? what? who? when? why?
12:33:07 <xerox> What is "Penrose's book" ?
12:33:17 <wagle> 12:31 < wagle> i need to read that book before getting back to penrose's book:
12:33:17 <wagle>                "The Road to Reality"
12:33:33 <xerox> Whooops, misread, sorry.
12:33:38 <wagle> (stupid cutnpaste)
12:35:14 <mwc> Heffalump, Ocaml says something exactly like that on their page, or they used to
12:35:24 <mwc> Wondering if you stole their line as a bit of banter for winning the 2004
12:36:11 <shapr> mwc: that's always the first prize for ICFP.
12:36:53 <Heffalump> it's the declaration the winners get from the judges
12:39:34 <shapr> I know there's a collection of rules like "polygons of three sides have angles totalling 180Â°" where could I find those rules for the [1..10] sides or so?
12:40:15 <Darius> shapr: Find the general rule
12:40:44 <astrolabe> The sum of the exterior angles is 360
12:40:59 <shapr> What about concave polygons?
12:41:16 <astrolabe> Just use negative exterior angles
12:41:24 <shapr> That sounds easy enough.
12:41:39 <xerox> How are you going to output graphics?
12:42:13 <astrolabe> Think about driving round the perimeter, and work out how many degrees you have to turn clockwise and anti-clockwise
12:42:19 <shapr> Yeah, I see what you mean.
12:43:24 <Igloo> Are they really the exterior angles? I'd have said the exterior angles were those plus 180 deg
12:44:08 <shapr> So, all you really need to specify any polygon is the order of the angles, and the length of one side, right?
12:44:33 <Heffalump> errm, no
12:44:38 <shapr> value and order of angles
12:44:41 <shapr> and length of one side.
12:44:42 <Heffalump> that doesn't even specify a rectangle
12:44:55 <Heffalump> 90,90,90,90, length of one side = 5
12:44:59 <Heffalump> what's the length of the next side?
12:45:09 <shapr> Oh, I see what you mean.
12:46:00 <xerox> Maybe a [(a,b)] would be enough
12:46:16 <astrolabe> Igloo:  dunno, maybe.
12:55:52 <basti_> @haskellircpastepage
12:55:53 <lambdabot> Sorry, I don't know the command "haskellircpastepage", try "lambdabot: @
12:55:53 <lambdabot> listcommands"
12:56:00 <basti_> gnargh
12:56:14 <basti_> lisppaste2: @url
12:56:15 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:56:46 <lisppaste2> basti_ pasted "Tilings via Types?" at http://paste.lisp.org/display/7074
12:57:05 <basti_> shapr?
12:59:19 <xerox> @wiki HaskellIrcPastePage
12:59:20 <lambdabot> Sorry, I don't know the command "wiki", try "lambdabot: @listcommands"
12:59:42 * xerox cloaks as lambdabot: http://www.haskell.org/hawiki/HaskellIrcPastePage
13:02:11 <shapr> basti_: what?
13:02:37 <wagle> i heard bush cancelled april 1st this year
13:02:55 <shapr> Anyone else here is using ghc 6.4 and can build pugs?
13:03:17 <basti_> shapr: look at the paste please?
13:03:45 <wagle> pugs?
13:03:50 <wagle> (shapr)
13:04:10 <xerox> Do you have any suggestion about the KGS Haskellers room? I think I'm going to ask some admin for making it, there is many people on the HaskellGoPeople page.
13:04:21 <shapr> wagle: pugscode.org
13:04:28 <wagle> o_O What is Pugs? Pugs is an implementation of Perl 6, written in Haskell.
13:04:41 <wagle> damn them for beating me to it!
13:05:07 <wagle> 8)
13:05:19 <Darius> You had plenty of time.
13:05:32 <xerox> there are, even.
13:05:44 <wagle> theres a rainy day round tuit shortage
13:06:04 * shapr grumbles at haskell-mode
13:06:20 <basti_> shapr: http://paste.lisp.org/display/7074
13:07:10 <wagle> actually, i wanted a tighter hybrid "the good parts of perl, as haskell syntax"
13:11:28 <shapr> basti_: I'm trying it.
13:13:36 <basti_> yTile (xTile White) comes to mind for example
13:23:19 <xerox> shapr: where can I get a suitable fortune file for lambdabot?
13:23:40 <shapr> Any fortune file should work.
13:23:41 <astrolabe> xerox:  Where is the HaskellGo People page?
13:23:56 <xerox> astrolabe: http://www.haskell.org/hawiki/HaskellGoPeople
13:24:06 <shapr> xerox: dpkg -L fortunes
13:24:08 <astrolabe> Danker
13:24:43 * CosmicRay returns
13:25:06 <astrolabe> Well I'm more a go person than a Haskell person, but I'm going onto the list!
13:25:07 * shapr liftMs
13:25:22 <xerox> astrolabe: nice ! :)
13:28:17 <wagle> go, like black and while and 19x19?
13:29:28 <astrolabe> That's the one.
13:29:58 <wagle> oh cool! someplace without a sociopath running it..
13:30:07 <wagle> (a go server, that is)
13:30:19 * basti_ .oÂ° ( one should make a game played on an aperiodical tiling )
13:30:25 <xerox> wagle: http://kgs.kiseido.com
13:30:34 <vegai> whoa, Linus has moved all development of the kernel to a darcs repository
13:30:38 <astrolabe> wagle: yeah.  wms seems nice even.
13:30:48 <lightstep> vegai, seriously?
13:30:48 <xerox> I'm trying to have a room for Haskellers, do you have any suggestion for the name?
13:30:49 <CosmicRay> vegai: what?!
13:30:52 <vegai> "Yeah, Bitkeeper started to suck so much, that we decided to move to something better. Plus, Haskell rules!"
13:30:52 <CosmicRay> vegai: url?
13:31:01 <shapr> vegai: scuse me what?
13:31:05 <CosmicRay> vegai: wait, is it April 1 where you are? :-)
13:31:10 <shapr> oh right
13:31:12 * vegai wonders if he overdid it a bit.
13:31:15 <halcyon10> basti: yes, i thought about this, too. I thought of a Penrose Tiling
13:31:21 <CosmicRay> vegai: heh
13:31:30 <basti_> halcyon10: shapr hinted me on this topic
13:31:37 <wagle> linus is sitting here in the coffee shop with me, and nods and shrugs "of course!"
13:31:40 <CosmicRay> oh yes, tomorrow is the day of the thousand obvious fake stories on slashdot and the millions of confused readers
13:31:41 <shapr> basti_: that's actually where I started
13:32:02 <basti_> shapr: so, any results? and, what do you say about my tiling type?
13:32:06 <CosmicRay> the perl guys should do something fun
13:32:15 <CosmicRay> reimplemtnation of ghc in perl or something
13:32:19 <shapr> I have an idea for a game that mixes Penrose tiles and levels of magnetic potentials.
13:32:29 <vegai> personally though, I hate this day
13:32:29 <Darius> CosmicRay: And how is that different from a typical slashdot day?
13:32:31 <halcyon10> oh, that sounds interesting
13:32:33 <CosmicRay> Darius: hah
13:32:43 <basti_> as in, "board game" or "computer game"? ;)
13:32:44 <CosmicRay> Darius: scale :-)
13:33:06 <CosmicRay> yeah wtf is it with /. getting *every single story* about Debian *dead wrong*?
13:33:07 <shapr> basti_: computer game.
13:33:13 <basti_> shapr: i see.
13:34:21 <shapr> Something like tetris or crack-attack.
13:34:40 <Heffalump> is it not true that only 1/3rd of developers have voted, then?
13:34:43 <astrolabe> Games where the last player who can play wins, are theoretically important.  Could you just take turns attaching penrose tiles, according to that edge marking they have?
13:35:34 * basti_ was thinking "nomad ground control" in an infinite landscape.
13:35:34 <basti_> ;)
13:35:59 <xerox> Why don't we just play toroidal Go? ^__^
13:36:59 <CosmicRay> Heffalump: the turnout can't be record-low because the election isn't closed yet.
13:37:57 <lightstep> what are the elections about?
13:40:10 <xerox> Would "Ask hell" be a good room name for the Go room?
13:40:14 * xerox grins
13:41:13 <CosmicRay> lightstep: the next debian project leader
13:41:37 <lightstep> for which project?
13:41:40 <CosmicRay> debian
13:41:45 <lightstep> oh
13:41:52 <CosmicRay> :-)
13:41:53 <lightstep> is the winner any good?
13:41:54 <astrolabe> xerox:  yeah
13:42:00 <CosmicRay> lightstep: we don't know yet, the vote isn't over
13:42:06 <xerox> astrolabe: maybe it's too much :)
13:42:12 <CosmicRay> which is why it's rather premature for slashdot to complain about turnout :-)
13:42:54 <astrolabe> You'd get booted for swearing anyway
13:43:28 <CosmicRay> then a week or two ago, slashdot screams "Debian dropping 8 archs!" or whatever.  When in fact there was a *proposal* that would eventually lead to that, n years in the future.
13:43:44 <CosmicRay> a proposal that was highly controversial and not at all a done deal.
13:43:45 <astrolabe> There is someone writing a go programme in haskell, but I don't see them on the page.
13:43:47 <CosmicRay> sigh at slashdot.
13:44:27 <astrolabe> should be called slash exclamation mark.
13:44:30 <xerox> astrolabe: yep, a Go client/server program, 3dGo if I remember correctly.
13:44:51 <CosmicRay> astrolabe: how about slash minus
13:45:05 <Heffalump> CosmicRay: the claim is supported by a quote from Manoj, and makes it clear that it's turnout up till this point..
13:45:18 <lightstep> slash dash
13:45:50 <CosmicRay> Heffalump: I have no quible with Manoj's quote.  Slashdot's "Record Low Turnout in Debian Leadership Election" is misleading, though.
13:46:10 <astrolabe> xerox: I meant this http://senseis.xmp.net/?HaGo
13:46:21 <KrispyKringle> ok, so this is messy and weird. I've installed WASH from the WashNGo stuff on my Linux box, but the CGIs it generates don't generate the proper header (even though they work on my OSX box). Boa complains that they don't generate LFLF, while Apache says "premature end of script headers." So, the output seems different than that generated on OSX. What gives?
13:46:25 <lightstep> where is the item?
13:46:47 <CosmicRay> lightstep: http://linux.slashdot.org/linux/05/03/30/2258249.shtml?tid=90&tid=218
13:47:05 <CosmicRay> and this business about it "marring" the elections... silly.
13:47:22 <CosmicRay> debian has enough to worry about, why bother with how many people have voted early?
13:47:30 <mwc> Stupid Newbie Question, but what's the file extension for haskell code? .hs?
13:47:49 <CosmicRay> mwc: yes
13:48:00 <mwc> CosmicRay, thanks
13:48:07 <CosmicRay> oh, and this year, we have 19.6% of people voting by this point rather than 23.1%!  Horrors!
13:48:19 <xerox> astrolabe: ah, a *playing* program!
13:48:28 <CosmicRay> a whole 3.5% difference!
13:52:21 <astrolabe> The trouble with this chat is I get no work done.
13:52:26 <SyntaxNinja> mwc: sometimes .lhs
13:52:36 <SyntaxNinja> CosmicRay: I'm with you on the slashdot sigh
13:55:46 <mwc> SyntaxNinja, is there any difference at all?
13:56:04 <lightstep> yes
13:56:06 <lightstep> lhs is literate haskell
13:56:20 <mwc> excellent, I'm illeterate :P
13:56:33 <SyntaxNinja> then use .hs
13:56:41 <lightstep> meaning that the file is a text file, with haskell sections marked as latex code sections, or with birdticks
13:56:46 <SyntaxNinja> S. Alexander Jacobson has a lot of energy.
13:57:08 <Heffalump> Debian is of course free to ignore slashdot :-)
13:57:36 <SyntaxNinja> after the article, the secretary mentioned on IRC that he got a LOT of unsigned votes (developers have to sign their votes to count)
13:57:54 <SyntaxNinja> not sure if that was non-developers trying to vote or developers failing to vote
13:58:15 <CosmicRay> heh
13:58:36 <CosmicRay> probably both
13:58:40 <Khisanth> it's all good as long as there is no recount
13:58:56 <SyntaxNinja> it's instant run-off, there's always  a recount ;)
14:00:02 <Igloo> Bah, why'd I have to check out GHC the day /before/ Simon tweaked half the source to be haddock-friendly?
14:00:11 <SyntaxNinja> heh
14:00:16 <SyntaxNinja> poor igloo
14:02:19 * Igloo rereads the commit message and realises he hasn't actually fixed it yet
14:06:29 <xerox> Goodnight.
14:06:59 <astrolabe> night night
14:10:34 <wagle> CosmicRay: consider the possibility that /. gets EVERY story wrong, and that you only notice when its about debian...
14:11:49 <wagle> .. after my emergency-medical-technician certification, movies got horrifying..  the bad guys would hurt someone, and the medics would run up and murder the victim
14:13:03 <wagle> if you know something about anything, you now see how bad the media mangles it
14:16:09 <wagle> how do you recount in haskell?
14:16:29 <wagle> count once, and it gets memoized
14:17:02 <Darius> Break the sharing.
14:17:03 * Heffalump still thinks the story was perfectly accurate
14:17:13 <Heffalump> why do you want to recount?
14:17:27 <Heffalump> function calls don't generally get memoized
14:17:34 <Heffalump> unless the compiler decided to CSE
14:17:42 <wagle> my brain is still at lunch, so i'm babbling
14:20:36 <wagle> (Darius, if you break the sharing, then its not _re_counting)
14:20:40 <wagle> </babble>
14:22:11 <Darius> Okay.  Then make a call-by-name implementation of Haskell.
14:34:10 <mwc> I'm confused about the type specification for a function in this tutorial. it says: and1 :: Bool -> Bool -> Bool, but isn't a function taking two bools and returning a value of type bool something like Bool, Bool -> Bool? I'm just used to seeing -> being used to seperate parameters from resutls
14:34:59 <lightstep> mwc, (Bool, Bool) -> Bool is the type of functions from pairs of Bools to Bools
14:35:09 <SyntaxNinja> in Haskell, Bool -> Bool -> Bool means it takes two bools and returns a bool.
14:35:23 <wagle> its a function taking a bool and returning a function that takes another bool that returns a bool
14:35:31 <SyntaxNinja> bah
14:35:37 <wagle> bah?
14:35:39 <mwc> wagle, that's how I'd read it too
14:35:43 <mwc> I guess it's curried
14:35:57 <SyntaxNinja> I guess I'm over-simplifying
14:35:57 <Darius> mwc: Or more succintly, the function returns a (Bool -> Bool) function.
14:36:00 <wagle> yeah..
14:36:40 <mwc> so then you could write f1 = and1 True, and then do f1 False
14:36:42 <wagle> Bool -> Bool -> Bool == Bool -> (Bool -> Bool) != (Bool -> Bool) -> Bool
14:36:51 <Darius> mwc: Yes
14:37:08 <mwc> Darius, thanks, I didn't think it automagically curried functions
14:37:24 <Darius> @plugs let f1 = ((&&) True) in f1 False
14:37:26 <wagle> function application
14:37:31 <lambdabot> False
14:37:32 <lightstep> it is. it's the convention in haskell
14:37:43 <mwc> Used to scheme as far as functional languages go
14:37:46 <wagle> function application does only one argument at a time (modulo optimizers)
14:37:51 <lightstep> @plugs (&& True) == id
14:37:52 <lambdabot> bzzt
14:38:08 <lightstep> lambdabot, why not True?
14:38:23 <Darius> Because you can't compare function for equality
14:38:43 <lightstep> i know, i wanted lambdabot to explain
14:39:06 <wagle> @plugs p == np
14:39:07 <lambdabot> bzzt
14:39:12 <wagle> hey!
14:39:32 <wagle> a solution at last
14:39:38 <astrolabe> I guess lambdabot knows it's undecidable
14:39:49 <wagle> isabelle could do that one
14:40:20 <lightstep> returning bzzt, or solving the problem?
14:40:20 <wagle> its decidable for that particular case
14:40:37 <wagle> i took bzzzt to mean false
14:40:49 <Darius> @plugs Debug.QuickCheck.forAll (\bools -> bools && True == bools)
14:40:50 <lambdabot> bzzt
14:40:58 <lightstep> it means "bad input"
14:41:16 <Darius> wagle: For those particular -functions- yes.
14:41:55 <wagle> lightstep: thats right, burst my bubble!  (bully!)
14:44:14 <shapr> Can I ask the ghc6.4 deb for its original package.conf?
14:44:21 <shapr> or is apt-get source easier?
14:45:23 <SyntaxNinja> it's possible that the .deb has a different one from upstream, but probably not
14:45:36 <SyntaxNinja> I don't know how to extract individual files from a .deb, though
14:48:20 <shapr> I still can't build pugs, and I'm beginning to think it's my ghc6.4 config.
14:48:32 <shapr> Of course, this is hypothesis number five or so.
14:49:53 <Heffalump> SyntaxNinja: ar -x
14:50:22 <Heffalump> and then untar the resulting file (one tarball will contain the individual files, the other the metadata)
14:50:37 <lightstep> what are you getting?
14:51:14 <lightstep> yes, i know you got asked and answered this question a lot of times. it just might work now
14:51:23 <sqrt> shapr: what was is you wanted with the penrose tiles?
14:51:30 <shapr> sqrt: type safety.
14:51:57 <shapr> lightstep: I get collisions with System.Directory and Posix.Directory both exporting the same functions.
14:51:58 <sqrt> why haven't you got that already?
14:52:21 <shapr> sqrt: because I can't figure out to encode 2D layout into types in Haskell.
14:52:29 <lightstep> shapr, on what module?
14:52:53 <shapr> Chasing modules from: src/Main.hs \n Could not find module `Posix': \n  it is a member of package posix-1.0, which is hidden
14:52:58 <shapr> that's what I got first.
14:53:10 <shapr> so I did ghc-pkg expose posix-1.0
14:53:29 <CosmicRay> crap, I hate hard disks.
14:53:49 <CosmicRay> 200GB one died on us yesterday.
14:53:58 <CosmicRay> my debian mirror is lost, lost I say!
14:54:08 <shapr> lightstep: after which I get: src/Internals.hs:21:4: \n  Conflicting exports for `createDirectory': \n `module Posix' exports `System.Posix.Directory.createDirectory' imported from Posix at src/Internals.hs:66:0-11 \n `module System.Directory' exports `System.Directory.createDirectory' imported from System.Directory at src/Internals.hs:83:0-22
14:56:18 <lightstep> oh. are you using gmake?
14:58:02 <wagle> CosmicRay: ssshhh!
14:58:53 <shapr> why would ghc --make Main complain about not finding Posix.hs, even though it's in the same directory?
14:59:13 <sqrt> shapr: so for example, what could a type be? a tile or a tiling...?
14:59:22 <wagle> i bought 4 identical disks so i can dd disk images from one to the other..  one now has about 10000 bad blocks
15:00:40 <wagle> it typechecks if its a tiling, fails to typecheck if its not a tiling [,my assumption is that]
15:00:41 <CosmicRay> wagle: hehe
15:01:37 <shapr> sqrt: if you have two values, each of which are two squares one on top of the other, and you put the top two squares next to each other, how can you typecheck that the bottom two squares must be able to meet as well?
15:02:47 <sqrt> ahh, ok..
15:03:10 <sqrt> i see now what you think.
15:05:23 <wagle> could try doing polynominoes on a checkerboard first
15:05:41 <wagle> or even dominoes
15:06:03 <wagle> (the game of matching the numbers, that is)
15:07:07 <wagle> hmm.. is adjacency "type composition"?
15:08:17 <wagle> Flipn exposes arg n (side n) to composition
15:08:36 * shapr runs apt-get -uf remove --purge ghc6
15:09:04 <shapr> wagle: one approach is n-ary arrays, rather than n-dimensional arrays.
15:10:06 <shapr> greetings [newbie], looking for Haskell info?
15:10:08 <wagle> yeah..  but the swing function has been my zen koan of late
15:10:53 <shapr> [newbie]: You're not BC Pierce in disguise are you?
15:11:11 <shapr> wagle: mine too.
15:11:18 <[newbie]> disconnects quickly to hide the truth
15:11:31 <shapr> [newbie]: You are BC Pierce?
15:11:38 <shapr> If so, nice book.
15:11:38 <mattam> hehe
15:11:45 <mattam> +s
15:11:45 <[newbie]> thanks, but i'm not really him
15:11:47 <shapr> whew
15:11:50 <[newbie]> just a student here
15:11:52 <wagle> swing swing swing swing swing == swing swing swing swing swing swing swing
15:12:03 <mattam> what's swinb
15:12:08 <mattam> -b+g ?
15:12:15 <Darius> id id id id = id id !
15:12:18 <shapr> mattam: it's (.).(.) and it does nifty things.
15:12:18 <wagle> swing f = flip (f . flip ($))
15:12:41 <Darius> (stick .'s in there)
15:12:44 <shapr> [newbie]: how can we assist you?
15:12:48 <wagle> composing curried functions is bizarre
15:13:08 <Darius> @type (.) . (.)
15:13:09 <lightstep> @pointless (.).(.)
15:13:10 <lambdabot> (.) . (.) :: forall a b c a1.
15:13:10 <lambdabot>              (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:13:10 <lambdabot> (.) . (.)
15:13:24 <[newbie]> so i just installed hugs (using emege on gentoo) and am trying to use the QuickCheck module
15:13:25 <lightstep> @pointless \f -> flip (f . flip ($))
15:13:26 <lambdabot> flip . (. flip id)
15:13:33 <[newbie]> when I ":import QuickCheck"
15:13:44 <wagle> eep
15:13:51 <[newbie]> i get error messages about the chr and fromInt not being avaiable
15:14:17 <[newbie]> and i think that they sould both be in the prelude (i'm quiet new to haskell, so I could be way off here)
15:14:42 <Darius> Hugs used to have them in the Prelude, but they weren't supposed to be there.
15:14:43 <mattam> shapr: what's so nifty about it ?
15:14:58 <shapr> @type map (.).(.)
15:14:59 <lambdabot> bzzt
15:15:03 <shapr> @type (map (.).(.))
15:15:04 <lambdabot> bzzt
15:15:13 <Lemmih[Brother]> Hey SyntaxNinja, for an outsider the tested-with field eg. "GHC ==6.4, GHC ==6.2" looks clumsy compared to simply writing "GHC 6.4, 6.2", which presumably wouldn't be misunderstood (right?). Would this difference in print be a difficult / appreaciated one?
15:15:26 <mattam> @type map ((.).(.))
15:15:27 <lambdabot> map ((.).(.)) :: forall a b c a1.
15:15:27 <lambdabot>                  [b -> c] -> [(a -> a1 -> b) -> a -> a1 -> c]
15:16:01 <shapr> mattam: swing changes the args to a function from data to function, and from function to data
15:16:16 <Lemmih[Brother]> or "GHC 6.4 6.2"
15:16:19 <shapr> [newbie]: Yes, they should be in the Prelude. What version of Hugs are you using?
15:16:56 <Darius> @type chr
15:16:58 <lambdabot> bzzt
15:17:03 <Darius> @type Data.Char.chr
15:17:04 <lambdabot> Data.Char.chr :: Int -> Char
15:17:08 <[newbie]> i tried both 2005.3 and 2003.11
15:17:09 <mattam> an example of the other direction ?
15:17:21 <mattam> @type ((.).(.)) map
15:17:23 <lambdabot> ((.).(.)) map :: forall a a1 a2 b.
15:17:23 <lambdabot>                  (a -> a1 -> a2 -> b) -> a -> a1 -> [a2] -> [b]
15:17:27 <shapr> [newbie]: You may need to add 'import Data.Char' and change all fromInt calls to fromIntegral
15:17:59 <mattam> hmm
15:18:00 <shapr> Did you grab QuickCheck from Hughes' website?
15:18:04 <Darius> Or try Debug.QuickCheck
15:18:16 <Darius> or possibly Test.QuickCheck
15:18:55 <shapr> mattam: btw, Cale found swing.
15:19:22 <mattam> why he didn't call it boobs instead ? :p
15:19:36 <mattam> couldn't resist... sorry
15:19:48 <[newbie]> shapr: I downloaded it from Chalmer's website
15:19:51 <shapr> I guess swing was the breast thing he could think of.
15:19:57 <shapr> er, best ;-)
15:20:15 <mattam> ;)
15:20:27 <esap> swing is a very interesting function.
15:20:54 <mattam> well if can't think of a usage for it yet...
15:20:54 <shapr> [newbie]: I can add the Data.Char import and change all the fromInt to fromIntegral if you want. But you can do it yourself, it's just search/replace.
15:21:02 <mattam> s/if/I/
15:21:15 <Darius> shapr: I'm pretty sure it has been described earlier and it's just a mild generalization of composition
15:21:42 <shapr> mattam: have you ever wanted to apply a bunch of functions of the same type in a pipeline to a bit of data?
15:21:59 <[newbie]> shapr: I just tried it, but I'm getting a type error:
15:22:14 <mattam> i could have
15:22:38 <dons> moin
15:22:39 <shapr> In that case you could use swing map data [func1,func2,func3]
15:22:58 <shapr> [newbie]: is the type error short?
15:23:20 <mattam> hmm right, i wouldn't have come up with something as elegant
15:23:51 <[newbie]> reasonably, can i paste it here w/o annoying ppl?
15:24:02 <shapr> No, but you can paste on the paste page!
15:24:12 <[newbie]> ?
15:24:17 <[newbie]> what is the paste page?
15:24:21 <shapr> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:25:02 * Darius wonders if there are other wiki pages being used as paste pages.
15:26:15 <mattam> you can add arguments a_'s by putting (.)'s at the left, that's funny
15:26:34 <[newbie]> shapr: just pasted it.  I have a feeling this would be easy, if i knew i bit more haskell:-/
15:26:34 <Muad_Dibber> haskell pwns java :P
15:26:45 <Lemmih> http://www.scannedinavian.org/~lemmih/HackageBrowser0[12].png
15:26:48 <shapr> [newbie]: ok, I just tried it, you're right it's more difficult than that.
15:27:04 <Darius> mattam: id -> (.) -> (.) . (.) -> (.) . (.) . (.) -> etc.
15:27:59 <mattam> what ?
15:28:01 <shapr> Lemmih: my browser doesn't deal with []
15:28:23 <Lemmih> shapr: I meant 01.png and 02.png
15:28:38 <mattam> oh right
15:28:54 <mattam> oh no, why id ?
15:28:57 <shapr> [newbie]: I think I can get you a working version, just a moment.
15:29:25 <Darius> mattam: It's the base case. id . (.) = (.)
15:29:42 <[newbie]> shapr: I would greatly appreciate it:)
15:29:58 * CosmicRay returns from the scary regions of no internet access between home and the town
15:30:41 <dons> welcome back CosmicRay from the dark lands
15:30:56 <Darius> [newbie]: Are those fromIntegers, fromInts that you changed?
15:31:04 <CosmicRay> thank you, oh dons of the shining lambda
15:31:14 <Darius> If so, fromIntegral is what you want.
15:31:16 <dons> :)
15:31:23 <[newbie]> Darius, they started as fromInts and changed to fromInteger
15:31:29 <shapr> [newbie]: try this http://www.scannedinavian.org/~shae/QuickCheck.hs
15:31:30 <[newbie]> Darius: will try
15:31:38 <Lemmih> shapr: Opinions?
15:31:40 <CosmicRay> stepcutHM: ping
15:32:01 <shapr> Lemmih: neat!
15:32:11 <shapr> dons: synhl?
15:32:28 <shapr> Or will I get an April 1st version of synhl if I ask anymore today? =)
15:32:31 <dons> oh man, you're on my back about that again ;)
15:32:43 <mattam> Darius: and what's the recuring scheme then ?
15:33:12 <Darius> composing (post or pre) with (.)
15:33:13 <dons> shapr, how about I just commit what's been sitting in my tree ?
15:33:18 <shapr> dons: yes please!!!
15:33:22 * shapr hops
15:33:23 <dons> OK!
15:33:45 <dons> shapr, btw: Fri Apr  1 09:27:43 EST 2005
15:33:59 <dons> so maybe... hehe
15:34:02 * shapr snickers
15:34:15 <mattam> i mean what does it do ? just 'adds arguments' right ?
15:34:16 <[newbie]> Darius, shapr:  Both seem to fix it!  Thanks a lot!
15:34:24 * Darius is thoroughly in March
15:34:25 <CosmicRay> shapr: what you don't know is that because it's april 1, he will be using arch to commit!! BWAHAHAHAH!!!!
15:34:40 <shapr> Do you think that was really BC Pierce?
15:34:45 <dons> hehehe
15:35:21 <Darius> @type (.) . (.) . (.)
15:35:21 <dons> Darius, re your patch - how did you envisage handling 6.2.2 build? just some extra cpp?/
15:35:23 <lambdabot> (.) . (.) . (.) :: forall a a1 b c a2.
15:35:23 <lambdabot>                    (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 ->
15:35:23 <lambdabot> c
15:35:47 <Darius> With regards to the Posix.hs?
15:35:51 <mattam> yes.... and ?
15:35:51 <dons> yeah
15:36:11 <shapr> g'day Mistah Bromage
15:36:18 <Pseudonym> G'day sah.
15:36:31 <Pseudonym> Did you see my Penrose tile generator?
15:36:39 <shapr> er, no?
15:36:48 <Darius> mattam: The type says all.
15:36:48 <Pseudonym> http://andrew.bromage.org/Penrose.hs
15:37:03 <dons> #if __GLASGOW_HASKELL < 604 popen = Posix.popen #else Darius' popen #endif is that ok with you?
15:37:12 <shapr> oh my
15:37:13 <mattam> i don't understand what you're trying to tell me Darius :p
15:37:24 <Pseudonym> Very simple ADT model.
15:37:29 <Pseudonym> Hierarchical, even.
15:37:32 <mattam> i know this term has this type
15:37:42 <shapr> I'm not used to seeing inline PostScript in Haskell source.
15:37:46 <Pseudonym> :-)
15:37:56 <dons> Darius: on the other hand, I could steal the 6.2.2. rawSystem stuff from ghc that runs on win32
15:38:02 <Pseudonym> I don't know any of the Haskell GUI libraries well enough, so PostScript it is.
15:38:08 <dons> inline PostScript!
15:38:34 <dons> that's what's been missing from my life!
15:38:38 <wagle> postscript is so last millenium.
15:38:45 <shapr> wow, that's cool output!
15:38:59 <Pseudonym> In case you're curious, the algorithm is the subdivision one here:
15:39:02 <Pseudonym> http://mathworld.wolfram.com/PenroseTiles.html
15:39:09 <dons> oh, but  I wan postscript combinators
15:39:23 <shapr> Functional MetaPost?
15:39:36 <shapr> It's too bad Display PostScript died.
15:39:39 <Darius> dons: It's okay for me, we could wait until someone on Win32 who can't use 6.4 comes along.
15:39:40 <dons> ahha
15:39:48 <dons> ok.
15:40:11 <dons> I'll test out the patch on some of the odd archs I have access to - thanks!
15:40:24 <Pseudonym> shapr: The commented out version is if you want an A4 page full of Penrose tiles.
15:40:34 <Pseudonym> I have it on my wall.  I'm seeing patterns in it, which is disturbing.
15:40:35 <Darius> dons: The hope being it doesn't happen while 6.2.2 compatibility is desirable.
15:40:44 <dons> :)
15:41:01 <shapr> Pseudonym: This makes me wish I had a color laser printer.
15:41:02 <dons> is that patch enough to get win32 working?
15:41:25 <shapr> Can I use this to get the same output as /usr/lib/xscreensaver/penrose?
15:41:33 <Pseudonym> Dunno.
15:41:37 <Pseudonym> Maybe.
15:42:23 <shapr> I was thinking of using GADTs with typed edges to do typesafe tiling.
15:43:31 <shapr> But I dunno if that would work.
15:43:40 <wagle> how do you get the output to go to a file?
15:43:49 <shapr> a.out > foo.ps
15:44:15 <wagle> thats want i did..
15:44:15 <wagle> Reading file "/sw/share/hugs/lib/Prelude.hs":
15:44:16 <wagle> Parsing^H ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^HDependency analysis^H ^H^H ^H^H ^H^H \
15:44:19 <wagle> ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^H^H ^HTy\
15:44:23 <wagle> etc..  hehe
15:44:40 <Pseudonym> I can't seem to get ggv to show the second page, though.
15:44:55 <wagle> was wondering about a cleaner way
15:45:01 <Darius> dons: It was compiled, but when I ran it with the changes fixing the package.conf issue, I got a head of empty list error on startup.
15:45:14 <shapr> The commented version is far niftier.
15:45:28 <shapr> I can see the second page with gv.
15:45:42 <Pseudonym> Hmmm.
15:45:53 <Darius> And I decided to read EoPL for a while instead of trying to figure it out.  Unfortunately, EoPL wasn't as good as I was hoping
15:46:12 <wagle> Pseudonym: macosx "Preview" app sees both pages after converting it to pdf
15:46:23 <dons> head of empty list. ok. i'll take a peek
15:46:29 <wagle> cool
15:46:29 <Pseudonym> Must be a ggv-ism, then.
15:46:30 <shapr> It's fun to watch gv draw the first page, takes about twenty seconds here on my dual 1.5GHz
15:46:43 <Pseudonym> Probably my EPS envelope isn't quite right.
15:46:46 * wagle gets chased out of closed coffee shop
15:47:06 <Pseudonym> wagle: Show them the Penrose tiles.  They might let you stay.
15:47:13 <wagle> heh
15:47:44 <dons> does anyone know why noone writes comments in lambdabot source ?
15:48:11 <CosmicRay> dons: perhaps they aught lbamdabot to explain his own design? :-)
15:48:12 <shapr> Where do you want comments?
15:48:25 <lambdabot> Damn straight.
15:48:27 <Heffalump> dons: that would be giving too much away
15:48:29 <CosmicRay> haha
15:48:35 <lambdabot> I don't want you poking around in my innards. Eeeeuuuw.
15:48:35 <SyntaxNinja> jemfinch told me that functional programming discourages comments, that's probably why.
15:48:43 * shapr snickers
15:49:01 <dons> SyntaxNinja: that's probably why.
15:49:01 <MegaMonad> Which makes the user's fault, though. Dumping a .p_o and .p_hi.
15:49:04 <CosmicRay> SyntaxNinja: odd. perl seems to have the same effect on people.
15:49:07 <Darius> EvalModule has a few very useless (not in the "this bind 3 to x" way) comments
15:49:11 <Heffalump> if it's anything I wrote, let me know and I'll try to help..
15:49:11 <dons> MegaMonad!
15:49:22 <shapr> Pseudonym: This is a cute bit of code, you should mention it on -cafe
15:49:24 <CosmicRay> MegaMonad: where have you been, you lazy bot?
15:49:25 <MegaMonad> CosmicRay: Xkb: undertakers make a difference. If you give me the general audience finds "design patterns" "real world" and "lazy evaluation world" is actually a kind of university am i supposed to be a bot.
15:49:27 <Heffalump> /ignore MegaMonad all # Yay for irssi
15:49:32 <CosmicRay> heh
15:49:41 <Heffalump> is there a new TMR?
15:49:47 <shapr> Nope.
15:49:47 <Pseudonym> shapr: Have to clean it up a little first.
15:49:51 <dons> Heffalump: it's not too much of a problem - lambdabot is still pretty easy to understand.
15:49:55 <Pseudonym> Just a little.
15:49:57 <shapr> Next TMR is March 1st
15:50:00 <dons> But i might start adding haddocks as I go.
15:50:06 <CosmicRay> shapr: 2006? :-)
15:50:06 <dons> literate lambdabot.
15:50:11 <lambdabot> I am very easy to flutzpah wibble mangrove flea circus.
15:50:14 <Heffalump> I think that tower of monad transformers I created in IRC.hs might be a little obfuscated.
15:50:16 <Darius> Bah, it's the end-user docs we need.
15:50:22 <CosmicRay> lambdabot: hey, you sound like megamonad!
15:50:23 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
15:50:25 <shapr> lambdabot has end users?
15:50:26 <Darius> Well, for very unurgent values of need.
15:50:34 <dons> he
15:50:39 <lambdabot> Does it please you that I sound like megamonad!
15:50:49 <Darius> Heffalump: Bah, nothing compared to EvalModule.
15:51:00 <shapr> Speaking of which, I gotta commit the VixenLove plugin Mrak wrote.
15:51:03 <Darius> (I hope!)
15:51:17 <Heffalump> ISTR playing some funny games with exceptions
15:51:19 <CosmicRay> heh
15:51:21 <Heffalump> and signals
15:51:30 <Pseudonym> Oh, yeah, I looked at that.
15:51:30 <Pseudonym> Scary.
15:51:36 <Heffalump> is there any reason not to get rid of the lambdabot/ subdir, btw (and mvoe everything to the higher directory)
15:51:52 <shapr> Not that I know of
15:52:03 <dons> nah.
15:52:05 <dons> go for it
15:52:14 <Heffalump> unfortunately such a patch wouldn't commute well with someone adding a new file in the lambdabot/ directory.
15:52:24 <CosmicRay> metaperl!  good evening.
15:52:31 <metaperl> guten evenen
15:52:37 <metaperl> or however they say it Germany
15:52:39 <dons> I'd like to split the plugins and static lambdabot into core/ and plugins/ dirs.
15:52:42 <CosmicRay> metaperl: abend
15:52:48 <metaperl> ah
15:52:50 <dons> that'd clean up the build system a bit too.
15:52:58 <CosmicRay> metaperl: which always makes me chuckle (see jargon file)
15:53:02 <Heffalump> well, now it's autoconf'd, I don't understand the build system :)
15:53:09 <dons> oh :P
15:53:22 <dons> that must be the shortest configure.ac in use
15:53:23 <Heffalump> I'm sure autoconf is a good thing. I just don't grok it.
15:53:38 <CosmicRay> metaperl: some nifty posts on extremeperl.
15:53:40 <Heffalump> ganesh@urchin:~/lambdabot/from-upstream/lambdabot$ wc -l configure.ac
15:53:40 <Heffalump>      85 configure.ac
15:53:44 <Heffalump> I'd hate to see a longer one...
15:53:53 <metaperl> tahnks CosmicRay
15:54:07 <Heffalump> and, err, ick, m4?
15:54:07 <CosmicRay> metaperl: http://changelog.complete.org/node/266
15:54:17 <Pseudonym> shapr: The one thing I'd do before showing this to -cafe is turn the dynamic invariant (i.e. the tree of triangles is balanced) into a static one via the type system.
15:54:24 <CosmicRay> Heffalump: would you expect any, er, less, from autoconf? :-)
15:54:35 <Heffalump> well, no, but.
15:54:39 * Pseudonym now refers to this internally as "Olegising".
15:54:44 <dons> configure.ac is even commented!
15:55:00 <CosmicRay> surely not!
15:55:06 <Heffalump> "# this is arbitrary"
15:55:06 <dons> m4 - yeah - but that's the autoconf way.
15:55:09 <CosmicRay> and are the comments actually accurate!
15:55:10 <Heffalump> "# sanity"
15:55:12 <CosmicRay> heh
15:55:21 <CosmicRay> or does it look like:
15:55:24 <Pseudonym> "# drunk.. fix later"
15:55:27 <CosmicRay> # find the location of gcc
15:55:29 <CosmicRay> rm -r *.c
15:55:32 <CosmicRay> # compile shit
15:55:37 <dons> they look ok to me.
15:55:41 <CosmicRay> cat /dev/null > foobar
15:55:48 <dons> it's not _literate_ autoconf yet.
15:55:49 <CosmicRay> heh
15:56:25 <Heffalump> the comments I quoted weren't jokes, btw, they really are in the .ac file :-)
15:56:34 <dons> I know :)
15:56:47 <Heffalump> I know you know :-p
15:57:02 <shapr> Pseudonym: how can you do that?
15:57:08 <shapr> @quote pseudonym
15:57:09 <lambdabot> pseudonym hasn't said anything memorable
15:57:11 <shapr> @quote Pseudonym
15:57:12 <lambdabot>   Lazy evalution is really, really trippy.
15:57:14 <CosmicRay> Heffalump: did http get out of incoming yet?
15:57:24 <det> @quote shapr
15:57:25 <lambdabot>   Academics are continually chewing pieces off of impossible and making
15:57:25 <lambdabot> them merely difficult.
15:57:25 <Heffalump> if it did I didn't get an email, or it got spamtrapped
15:57:27 <dons> someone want  to add a canonicalisation patch to @quote?
15:57:37 <shapr> nicknames should be case insensitive everywhere. kosmikus sent me a patch for part of that.
15:57:55 <CosmicRay> @quote CosmicRay
15:57:55 <lambdabot> CosmicRay hasn't said anything memorable
15:57:56 <Pseudonym> shapr: Much like the AVL tree hack.
15:58:01 <Heffalump> I did that to @seen. Centralising it would be much better.
15:58:10 <shapr> Pseudonym: huh?
15:58:46 <Pseudonym> @wiki SimulatingDependentTypes
15:58:47 <lambdabot> Sorry, I don't know the command "wiki", try "lambdabot: @listcommands"
15:58:51 <Heffalump> CosmicRay: and packages.debian.org doesn't know about it
15:58:52 <Pseudonym> Hmmm.
15:59:02 <CosmicRay> Heffalump: ok
15:59:04 <shapr> @dynamic-load Dummy
15:59:05 <lambdabot> unknown module
15:59:15 <dons> shapr, send me the missing code, where are these patches?
15:59:18 <CosmicRay> Heffalump: guess not then :-)
15:59:20 <Pseudonym> Anyway, if you look in the wiki there, there's an AVL tree implementation which enforces the balance condition in the type system.
15:59:30 <shapr> dons: @wiki is in there already, in DummyModule.hs
15:59:46 <dons> ah ha!
16:00:12 * Darius made that page less than a day, maybe even only hours before, Oleg posted his stanamically typed version.
16:00:15 <shapr> @wiki FooBar
16:00:15 <lambdabot> http://www.haskell.org/hawiki/FooBar
16:00:21 <shapr> yay for dynamic-load
16:00:22 <Darius> Yay
16:00:40 <shapr> @wiki SimulatingDependentTypes
16:00:40 <lambdabot> http://www.haskell.org/hawiki/SimulatingDependentTypes
16:00:43 <Pseudonym> Yay.
16:01:34 <dons> anything else we should be loading by default?
16:01:35 <Heffalump> this channel has too many nutters^Wtype class hackers ;-)
16:01:38 <shapr> I call a wide variety of Haskelly things Olegizing, but it usually means "extremely complicated transformation that will take me days of background reading to see the point of, much less understand"
16:01:54 <Pseudonym> :-)
16:03:07 <dons> what work has been done on profiling lambdabot to reduce the memory usage?
16:03:28 <shapr> Darius produced a nice quote.
16:03:33 <shapr> @quote darius
16:03:33 <lambdabot>   I imagine XSLT programmers say "It's a one pager" the way most other programme
16:03:33 <lambdabot> s say "It's a one liner".
16:03:36 <shapr> @quote darius
16:03:37 <lambdabot>   I imagine XSLT programmers say "It's a one pager" the way most other programme
16:03:37 <lambdabot> s say "It's a one liner".
16:03:40 <shapr> bah
16:04:11 <shapr> "Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards."
16:04:36 * Pseudonym laughs
16:04:52 <Pseudonym> Not just the barbed wire.  Beware the bananas and envelopes, too.
16:05:11 <Heffalump> dons: none, I imagine.
16:05:15 <Heffalump> Is the memory usage bad?
16:05:17 <Darius> dons: @eval's joy is used, shapr runs out of memory
16:05:25 <dons> not too bad, but  4460K 8972K sleep    select   0:52  0.00% lambdabot
16:05:27 * shapr snickers
16:05:42 <Heffalump> that seems pretty reasonable for a Haskell program
16:05:52 <dons> that's about twice the size of yi, but lambdabot has none of the big buffers yi has
16:05:58 <Heffalump> hmm, ok
16:06:11 <Pseudonym> Go ahead and profile, by all means.
16:06:14 <dons> some of the eval modules push usage up pretty high, 20M or so.
16:06:17 <Heffalump> it doesn't really strike me as a problem, but each to their own :-)
16:06:24 <dons> :)
16:06:33 <dons> 20625 _x11       2    0   11M  248K idle     select   6:13  0.00% XFree86
16:06:53 <dons>  3214 dons       2    0  448K 1572K sleep    select   0:01  0.00% sshd
16:07:22 <dons> we should at least stay under XFree86 ;)
16:07:38 <Darius> eval has some really horrible space leaks that I'v been intending to fix, and is just really horribly inefficient anyways.
16:08:48 <Darius> Of course, with @plugs there isn't too much reason for @eval
16:08:55 <dons>  3682 dons       2    0 2292K 2060K sleep    select   0:00  0.00% yi
16:08:58 <shapr> Neat, StarLog is written in Haskell.
16:09:16 <shapr> Can't all the DynamicLoader code in BotConfig.hs be replaced with hs-plugins?
16:09:25 <dons> yes, I think so.
16:09:41 <dons> and we'd get rid of the _nasty_ package deps in DynamicModule
16:10:06 * dons grimaces
16:10:19 <dons> but I don't want to attempt that until hs-plugins runs on win32
16:10:34 <shapr> does lambdabot have win32 users?
16:10:52 <shapr> does lambdabot have *users*?
16:11:15 <dons> hmm. an hs-plugins-lite would be useful- just load() and dependency resolution. no make/eval stuff.
16:11:33 <dons> shapr, yeah, we had 3 or 4 installations yesterday :)
16:11:40 <dons> that's probably it for now though.
16:12:00 <Pseudonym> It's got us.
16:12:00 <dons> let me see how many downloads there were..
16:12:16 <Pseudonym> I use it, though I don't _run_ it.
16:12:26 <dons> lots of users!
16:13:42 <Darius> dons: Apparently the issue is in one of the (most likely) dynamic modules
16:13:49 <Darius> dariusbot: @type 3
16:13:50 <dariusbot> Sorry, I don't know the command "type", try "dariusbot: @listcommands"
16:14:00 <shapr> dariusbot: @listmodules
16:14:01 <dariusbot> I have the following modules installed: ["base","system"]
16:14:07 <shapr> dariusbot: @dynamic-load type
16:14:08 <dariusbot> Sorry, I don't know the command "dynamic-load", try "dariusbot: @listcommands"
16:14:08 <Darius> Oh yeah /me has forgot what he just said
16:14:55 <Darius> Oh wait that's right, it could still be in RuntimeLoader as I don't statically load DynamicModule and therefore don't need RuntimeLoader
16:15:23 <shapr> metaperl: btw, what does Rob mean by "automatically finding the boundary condition" ?
16:16:20 <metaperl_> he means if you have a function and you want to test the max and min ranges for that function
16:16:46 <metaperl_> I think that's what he means
16:17:12 <metaperl_> so the boundary conditions are the values that might cause problems because they are the smallest or largest values it would take
16:17:27 <metaperl_> just think of all the Haskell I could be learning had I not started this thread 4 days ago :)
16:17:51 <shapr> In that case, QuickCheck does automatically find boundary conditions, right?
16:18:05 <shapr> actually...
16:18:14 <metaperl_> well, you specify them I suppose...
16:18:17 <dons> ok, 22 downloads since we moved it to .au.
16:18:48 <shapr> An orthogonal combinator to shrink would be 'bounds' where for any input that's an instance of Enum it walks back and forth.
16:18:57 <dons> 3 of which were me.
16:19:02 <shapr> dons: one of which was me.
16:19:18 <dons> *.bredbandsbolaget.se ?
16:19:21 <shapr> that's me.
16:19:45 <Igloo> of lambdabot?
16:19:50 <dons> then earth.li too
16:19:57 <shapr> That's Igloo or Heffalump
16:19:58 <Heffalump> urchin.earth.li ?
16:20:02 <dons> yeah.
16:20:05 <Heffalump> me.
16:20:10 <Heffalump> ganesh.bcnadsl.com ?
16:20:40 <dons> ganesh.bcnadsl.com yep.
16:20:49 <Heffalump> me too, predictably enough :-)
16:21:25 <Heffalump> earth.li has cool brand recognition. It's been mentioned to me at two different job interviews, and in my current job I work with two people who know about it independently of each other (and me).
16:22:37 <shapr> Heffalump: oh ye of QuickCheck ideas, how would someone actually use a boundary combinator for QC?
16:23:40 <shapr> lemme guess, specify in the config how far you want it to walk to look for the edges?
16:23:41 <Heffalump> what is it intended to do?
16:23:55 <Heffalump> how can you find rigid edges by random testing?
16:24:01 <Heffalump> (assuming other variables too)
16:24:22 <Darius> dons: Adding in DynamicModule to the statically loaded modules causes the head of empty list error to come back (with no other dynamic modules)
16:24:39 <shapr> If you have at least one success, and you have at least one failure, you know that there's a boundary. If the value you're generating is an instance of Enum, you can succ/pred the generated value to look around.
16:24:51 <Pseudonym> Where's the new darcs repo?
16:25:00 <Pseudonym> Should probably fix @wiki LambdaBot
16:25:01 <shapr> @version
16:25:02 <lambdabot> Thu Mar 31 14:53:46 EST 2005, GHC 6.4 (OpenBSD i386)
16:25:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:25:08 <Pseudonym> Thnaks.
16:25:13 <Heffalump> are you assuming consistent success on one side and consistent failure on the other side?
16:25:41 <shapr> Wouldn't that be a guarantee for QC tests?
16:26:22 <Heffalump> sorry?
16:26:30 <dons> Darius: ok. that narrows it down.
16:26:40 <shapr> Or do you mean that finding one boundary is not necessarily useful if there are lots of boundaries?
16:27:31 <Heffalump> are you trying to find a single boundary in a one-dimensional search space?
16:27:36 <shapr> Yeah, I think so.
16:27:43 <Heffalump> that sounds trivial to me.
16:27:51 <shapr> Enum implies 1D, right?
16:27:54 <Heffalump> Why bother with quickcheck when you have binary chop?
16:28:06 <SyntaxNinja> CHOP!
16:28:22 <Heffalump> effectively, but the question is whether there are other variables that can vary simultaneously with the boundary variable or not
16:28:25 <shapr> Because the point of this combinator is to find the edges of failing QC Props.
16:29:01 <Darius> I think his issue was with the (potential) replication of boundary checking in the quickcheck properties and the actual code.
16:29:32 <shapr> ?
16:29:38 <Heffalump> I think I'm just saying that this proposed combinator is trivial if the only thing that can vary is a single variable.
16:29:53 <Heffalump> and if more than that can vary then what it does is very ill-defined
16:30:00 <Lemmih[Brother]> Hey SyntaxNinja, for an outsider the tested-with field eg. "GHC ==6.4, GHC ==6.2" looks clumsy compared to simply writing "GHC 6.4 6.2", which presumably wouldn't be misunderstood (right?). Would this difference in print be a difficult / appreaciated one?
16:30:59 <Darius> shapr: Rob Nagler's issue.
16:31:02 <SyntaxNinja> Lemmih[Brother]: I think you could just say "GHC >= 6.2"
16:31:23 <SyntaxNinja> Lemmih[Brother]: I guess that's not the same...
16:31:41 <SyntaxNinja> Lemmih[Brother]: I can't remember if that field can take ranges or waht. I don't thin kit's a big deal
16:33:04 <shapr> oh, I think I get it now.
16:33:14 <Lemmih[Brother]> well, I just noticed looking over lemmihs shoulder, and he said you were the one with authority.
16:36:27 <Lemmih[Brother]> btw SyntaxNinja check out the latest screenshot. -It's been resurrected.
16:36:34 <SyntaxNinja> Lemmih[Brother]: URL?
16:36:55 <Lemmih[Brother]> http://www.scannedinavian.org/~lemmih/HackageBrowser02.png
16:37:27 <SyntaxNinja> sweet!
16:37:39 <SyntaxNinja> now that works via xml-rpc?
16:38:09 <ddarius> dons: It's trying to load package unix which I don't have.
16:38:25 <Lemmih[Brother]> lemmih says: not yet.
16:39:23 <ddarius> Removing unix and likely posix in DynamicModule.hs will probably solve taht.
16:41:00 <dons> yep. that's could be it.
16:41:20 <dons> hard coded package deps are evil
16:41:48 <dons> you could add a win32 case to DynamicModule once you get something that works
16:43:10 <Heffalump> what was the argument against replacing DynamicModule with a hs-plugins based implementation?
16:43:27 <dons> hs-plugins doesn't run on win32 yet.
16:43:57 <dons> I'm inclined to create an hs-plugins-lite containing just the loader and dependency chasing via .hi files though
16:44:08 <dons> that would be portable immediately
16:44:08 <SyntaxNinja> Lemmih[Brother]: hm. thought that was a client-side browser, is it using hsql (or whatever) directly?
16:45:13 <shapr> ddarius: you mean Rob was asking whether it's Design By Contract, right?
16:45:20 <Lemmih> SyntaxNinja: Currently I'm reading .cabal files from the cmd line. But that's only for testing.
16:45:58 <ddarius> @dynamic-load type
16:45:58 <dariusbot> not enough privileges
16:45:59 <lambdabot> already loaded
16:46:20 <Heffalump> does DynamicModule run on win32, then?
16:46:32 <dons> i believe it does.
16:46:37 <Heffalump> wow.
16:46:41 <ddarius> It doesn't cause an error starting up at least.
16:46:45 <Heffalump> who made it do that?
16:46:46 <dons> it's just a ghc rts binding, right?
16:46:55 <Heffalump> err, yeah
16:47:17 <Heffalump> I just stole some code from ozone, IIRC
16:47:17 <dons> and I don't see any \ vs / path hacking
16:47:23 <dons> RuntimeLoader is known to work on win32
16:47:27 <Heffalump> fairy nuff.
16:47:56 <SyntaxNinja> Lemmih: OK
16:48:53 <dons> all we really want is the dependency chasing magic from hs-plugins
16:49:27 <dons> we don't need the src compilation code
16:49:55 <dons> and maybe dynamically typed plugins would be nifty too
16:50:01 <Heffalump> right
16:50:09 <shapr> hiya skylan
16:50:12 * Heffalump goes to bed
16:50:13 <shapr> ahem, skew
16:50:21 <psi> hm, is there a standard function String -> [String] that splits a string at each occurence of a specified character?
16:50:34 <shapr> psi: split in lambdabot's Util
16:50:56 <psi> ok, thanks
16:52:08 <Lemmih> SyntaxNinja: Can we expose Distribution.Compat.FilePath? Hackage-browser needs it.
16:53:20 <Darius> dariusbot: @dynamic-load type
16:53:21 <dariusbot> symbol resolution failed
16:53:23 <dons> @version
16:53:24 <dariusbot> Sorry, I don't know the command "version", try "dariusbot: @listcommands"
16:53:24 <lambdabot> Thu Mar 31 14:53:46 EST 2005, GHC 6.4 (OpenBSD i386)
16:53:24 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:53:36 <Darius> @dynamic-load version
16:53:37 <lambdabot> already loaded
16:53:37 <dariusbot> symbol resolution failed
16:54:05 <Darius> dariusbot: @listmodules
16:54:05 <dariusbot> I have the following modules installed: ["base","dynamic","system"]
16:55:03 <Pseudonym> @duel-to-the-death
16:55:04 <dariusbot> Sorry, I don't know the command "duel-to-the-death", try "dariusbot: @listcomman
16:55:04 <dariusbot> s"
16:55:04 <lambdabot> Sorry, I don't know the command "duel-to-the-death", try "lambdabot: @listcomman
16:55:04 <lambdabot> s"
16:55:08 <Pseudonym> Damn.
16:55:13 <Pseudonym> Gotta write that module.
16:56:04 <dons> Darius, you might want to add -DDEBUG HC_OPTS in config.mk, you get more detailed dyn loading msgs
16:56:12 <dons> -DDEBUG to HC_OPTS
16:58:31 <Darius> dons: I'll try it.
16:58:41 <skew> Hi shapr
17:02:15 <Lemmih> @timein copenhagen
17:02:18 <lambdabot>   Friday, April 1, 2005 at 3:03:17 AM CEST
17:02:31 <shapr> @timein boden
17:02:33 <lambdabot>   Sorry, don't know this city
17:02:38 <shapr> @timein stockholm
17:02:39 <lambdabot>   Friday, April 1, 2005 at 3:03:39 AM CEST
17:02:53 <TheHunter> dons, i've sent you a small patch for ircPrivmsg (and adding the @more module)
17:02:55 <Lemmih> @timein SyntaxNinja
17:02:57 <lambdabot>   Sorry, don't know this city
17:03:11 <dons> yep. thanks!
17:03:35 <dons> wow. we're committing 25 patches aa day atm.
17:03:54 <SyntaxNinja> Lemmih: I'm not a city
17:03:57 <SyntaxNinja> @timein columbus
17:03:59 <lambdabot>   Thursday, March 31, 2005 at 8:04:58 PM EST
17:04:04 <SyntaxNinja> @timein portland
17:04:06 <lambdabot>   Thursday, March 31, 2005 at 5:05:05 PM PST
17:04:09 <SyntaxNinja> sweet
17:04:22 <Darius> @timein washington
17:04:23 <lambdabot>   
17:04:41 <dons> it wouldn't be too hard, somebody, to modify @timein to have @timefor nick
17:04:43 <Darius> What're the other washington's?
17:04:51 <dons> also, a patch to @timein to deal with multiple cities
17:04:54 <dons> it's just a regex.
17:04:55 <Lemmih> SyntaxNinja: Can we expose Distribution.Compat.FilePath? Hackage-browser needs it.
17:05:07 <dons> @timein help
17:05:08 <lambdabot>   http://www.timeanddate.com
17:05:12 * SyntaxNinja blames the libraries mailing list for that
17:05:33 <SyntaxNinja> Lemmih: there's going to be a standard one, but there's not yet. use that one if you like, but it might change
17:06:03 <dons> there are 5 washington's in the US.
17:06:09 <dons> what a silly thing to do.
17:08:27 <SyntaxNinja> they really should have planned better
17:12:28 <Darius> Yes, yes, but besides DC are any of them important?
17:13:05 <Pseudonym> @timein melbourne
17:13:07 <lambdabot>   Friday, April 1, 2005 at 11:14:06 AM EST
17:13:08 <Darius> If I were to add a @help command, what would be a decent module to add it to? or should I just make HelpModule
17:13:15 <Pseudonym> Ah, it picked the right Melbourne.
17:13:43 <Pseudonym> @timein springfield
17:13:44 <lambdabot>   
17:13:52 <Darius> @timein sterling
17:13:54 <lambdabot>   Thursday, March 31, 2005 at 8:14:53 PM EST
17:13:55 <skew> Darius: well, one of those Washingtons is a state
17:14:14 <Pseudonym> Unix timezone format might be better.
17:14:15 <skew> Darius: which happens to contain the little town of Redmond
17:14:16 <Darius> skew: I was assuming it didn't do states
17:14:19 <Pseudonym> @timein Australia/Melbourne
17:14:20 <lambdabot>   
17:14:34 <skew> Darius: actually, doing states isn't such a bad idea
17:14:49 <skew> Darius: most states are all in the same timezone
17:15:05 <skew> some countries for that matter
17:15:11 <Darius> skew: Some midwest state (Indiana I think) is in three different timezones
17:15:21 <dons> I like Unix timezone format. Good idea.
17:15:56 <dons> I think a Help module should be a new module, but that the type classed modules should need to provide a help() implementation
17:16:00 <dons> how does that sound?
17:16:19 <dons> so @help would look up the registered modules and invoke that modules help hook
17:19:03 <dons> TheHunter: do you have 6.4 installed?
17:19:23 <dons> check that patches compile with 6.4 if you can.
17:19:37 <Darius> dons: That's pretty much what I was planning, what would be a good type for it.
17:19:58 <Darius> Essentially, helpString :: String would be simple, but some module may want to be more interesting
17:20:13 <skew> a standard help system would be nice
17:20:57 <dons> moduleHelp :: m -> LB [String] ?
17:21:03 <dons> or LB String.
17:22:17 <skew> I'm thinking something like stdHelp :: FiniteMap String String -> <type of generic help interface>
17:22:34 <dons> hmm. do any modules use the 'm' arg to the class methods?
17:22:53 <dons> skew: yeah. modules define multiple commands
17:23:13 <dons> it would be nice to enforce that all Module.commands get help
17:23:24 <dons> so:  commands     _ = return ["type", "kind"]
17:23:41 <dons> if that, then we must provide help for those two commands
17:23:55 <Darius> dons: the 'm' arg is necessary for resolving ambiguity in at least some of the types.
17:23:58 <dons> the keys to the FM could be populate with Module.commands by default
17:24:00 <Igloo> Do you know OTTOYH what "Worker: $wshift4 2" in a ghc interface means, dons?
17:24:24 <dons> and fancier modules can have 'subsections' using other keys to the help FM.
17:24:42 <dons> igloo: not wshift, no.
17:24:57 <Igloo> The worker bit, I mean
17:24:57 <skew> Is there any need for a more generic interface?
17:25:10 <Darius> m -> LB String was the alternative I was thinking of, also with it I can have a default moduleHelp that ridicules the author for not providing help ;)
17:25:21 <dons> yeah.
17:25:22 <skew> Implementing info over IRC, maybe?
17:25:30 <dons> a compile warning would be nicer .. any TH hackers?
17:25:32 <skew> What does the LB monad allow?
17:25:59 <Darius> IO and it carries some state stuff and does exception stuff.
17:26:38 <Darius> The modules are part of the state so it's possible for a HelpModule to get them and get their help strings.
17:26:41 <dons> m -> LB (Map String String) ; class Module a where .. moduleHelp _ = return (fromList (zip command (iterate "lazy!")))
17:27:30 <Darius> dons: A @help command can have an arg and pass it to moduleHelp
17:28:14 <dons> yep. oops. m -> (String -> String)
17:28:38 <dons> something along those lines, anyway.
17:29:17 <Darius> Probably m -> String -> LB String, returning a function isn't too useful as it would typically only be used once before being discarded.
17:29:50 <dons> fair enough.
17:30:14 <dons> I think this isn't too hard. Cracking down on modules that don't provide help would be the fun part :)
17:30:47 <dons> can we use some TH to insert {-# DEPRECATED #-} pragmas, if no help is written?
17:31:02 <dons> that'd be a good incentive...
17:31:07 <Igloo> TH doesn't know about pragmas
17:31:10 <skew> the default implementation can search the internet to find the module author's embarassing nicknames :)
17:31:25 <dons> TH can call sed, though, right?
17:31:41 <Igloo> No, sed is explicitly forbidden
17:31:45 <dons> oh!
17:32:03 <Igloo> In fact, if you try to call sed then ghc might decide to post embarassing pictures of you to USENET
17:32:09 <dons> but I was going to write some Core transformations that way.
17:32:19 <dons> oh, this is very unfair
17:32:28 <Darius> Core transformations... with sed?
17:32:40 <shapr> that's terrifying.
17:32:42 <TheHunter> dons, oh, sorry, I didn't check it with 6.4.
17:32:46 <shapr> I have no idea how many dons points that's worth.
17:33:17 <Pseudonym> @karma+ dons
17:33:18 <lambdabot> dons's karma has been incremented.
17:33:26 <dons> anyway, I'd like DEPRECATED "This module provides no help - don't use it. If you think this is bad email module-author@foo"
17:33:32 <Pseudonym> Oh, gotta fix that apostrophe.
17:33:37 <Pseudonym> That grates on me.
17:33:46 <Igloo> What do you want the sed to do, anyway, dons?
17:33:53 <Darius> Pseudonym: Why?
17:33:58 <Igloo> It can't work on the Haskell module you're currently compiling
17:34:07 <shapr> dons: why not just put that into the @help command in the default typeclass method definition?
17:34:08 <dons> hmm.
17:34:18 <dons> would that work?
17:34:21 <shapr> I dunno
17:34:29 <dons> but  I want the msg at compile time.
17:34:47 <dons> Igloo: good point.  hmm.
17:34:59 <Darius> dons: I don't really see why, you'd be about the only person that'd see them
17:35:01 <Pseudonym> Darius: Because I'm a wannabe pedant.
17:35:29 <dons> ok ok. I retract my demand for compile time coercian of lambdabot hackers.
17:35:39 <Igloo> You could make the help a Maybe Foo and be rude about any Nothings at startup, which is almost as good
17:35:46 <Igloo> Oh, at module load I guess
17:35:46 <dons> coercion.
17:35:47 <Darius> Pseudonym: My understanding of American English says both dons' and dons's are considered correct, and surely it is dons' karma.
17:36:25 <Pseudonym> I don't understand American English at all.
17:36:31 <dons> Igloo: yeah. module load would be ok.
17:36:40 <Darius> Igloo: When someone @help's it, the default method would be called it can say "The author of <modulename> has shamefully not provided any help"
17:36:59 <Pseudonym> But I'll fall short of saying that "American English" is a contradiction in terms.
17:37:22 <dons> TheHunter: cheers
17:39:11 <Darius> dariusbot: @dynamic-load hello
17:39:12 <dariusbot> symbol resolution failed
17:42:39 <dons> so, what did we come up with: moduleHelp ::  m -> String -> LB String  ?
17:43:10 <dons> and just stick an "incentifying" default
17:43:39 <Darius> Looks like.  It's not like it can't be changed later.
17:44:40 <dons> ok. I'll go with that for now.
17:45:38 <dons> (regarding the compile time warning, I was thinking that with the -Werrorr default, they wouldn't be able to compile until they provide @help)
17:47:30 <Darius> Yeah that works, of course, if they still go on @help theircommand throws an ugly exception
17:47:54 <dons> yep
17:48:44 <Darius> Should be recoverable though in the @help call and then a default message could be displayed.
17:49:19 <dons> yep. I'm fine with that.
17:52:05 <dons> TheHunter: is there any reason pl should be in the static modules?
17:52:18 <dons> I'm trying to work out why it is there.
17:52:33 <dons> and eval too, for that matter.
17:53:32 <TheHunter> dons, basically because i copied that stuff from eval ;)
17:54:17 <dons> ok. doesn't seem to be necessary.
17:57:22 <TheHunter> ok, gotta go to bed
18:00:16 <Darius> What I was wondering was why eval and ghci were in the StaticModules.conf list twice.
18:01:24 <dons> yeah, fixed that too.
18:05:34 <wagle> classically, its dons'..  new wave (current strunk and white?) permits dons's, i think
18:07:36 <wagle> if its not the final product, is it a predariusbot?
18:19:17 <Darius> @listmodules
18:19:17 <lambdabot> I have the following modules installed: ["babel","base","dict","dummy","
18:19:17 <lambdabot> dynamic","eval","karma","more","pl","plugs","quote","seen","state","system"
18:19:17 <lambdabot> ,"topic","type","version"]
18:20:42 <Darius> @listcommands pl
18:20:43 <lambdabot> Module pl provides the following commands: ["pointless","pl-resume"]
18:20:54 <Darius> pl-resume?
18:35:19 <Darius> @type Control.Monad.State.gets
18:35:20 <lambdabot> Control.Monad.State.gets :: forall a (m :: * -> *) s.
18:35:20 <lambdabot>                             (Control.Monad.State.MonadState s m) =>
18:35:20 <lambdabot>                             (s -> a) -> m a
18:43:37 <Darius> @type Control.Monad.Error.catchError
18:43:38 <lambdabot> Control.Monad.Error.catchError :: forall (m :: * -> *) e a.
18:43:38 <lambdabot>                                   (Control.Monad.Error.MonadError e m) =
18:43:38 <lambdabot> >
18:43:38 <lambdabot>                                   m a -> (e -> m a) -> m a
18:57:04 <Darius> dons: Compiling with -debug gives an assertion failure in Linker.c for line 2213 on startup
18:58:06 <dons> hm. ok. that's interesting.
18:58:34 <dons> what message?
18:59:24 <Darius> lambdabot.exe: internal error: ASSERTION FAILED: file Linker.c, line 2213
18:59:43 <Darius> Then the "please report a bug" message
18:59:55 <dons> hehe. ok. 2213 is a cpp'd line though.
19:00:23 <dons> I see an assert near there.
19:01:57 <dons> btw, the System.Process patch seems causes popen to block on my box.
19:02:04 <Darius> I'm am statically linking a HelpModule, but I don't think that's part of the problem, by the way.
19:02:34 <Darius> dons: Okay, forking may solve that.
19:02:38 <dons> yeah.
19:02:48 <dons> and we should wait to clean up the zombies
19:03:06 <dons> hmm. we can use -threaded now too.
19:03:20 <ows> can someone there clear up a question about probability && statistics?
19:03:21 <dons> or is -threaded the default these days?
19:04:24 <Darius> dons: Yeah I am not surprised about the zombies.
19:04:46 <Darius> dariusbot: @help
19:04:47 <dariusbot> @help <command>
19:04:48 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
19:05:26 <Darius> dariusbot: @help dynamic-load
19:05:44 <dons> cool.
19:06:17 <Darius> Error catching code apparently doesn't work
19:06:47 <dons> Control.Concurrent.catch and friends should be ok.
19:09:47 <Darius> dons: They'd need to be able to run LB things.
19:10:22 <dons> oh, yep, ic: you're in that code.
19:11:12 <Darius> it may be a laziness thing, let me try something
19:14:30 <Darius> dariusbot: @help dynamic-load
19:15:15 <Darius> Yeah, I did that wrong but thought I still give it a try, next time has a better chance of working
19:15:54 <sjanssen> is there a priority queue implementation somewhere?
19:16:47 <Darius> First chapter of Fun of Programming (which happens to be the sample chapter) has a really simple but efficient one.  In general Okasaki has some cool stuff.
19:17:00 * Darius doesn't think this next try is going to work either.
19:19:17 <Darius> There is likely one is some of the data structure libraries as well, but I don't think there is one in the heirarchical libraries, but I could easily be wrong.
19:19:49 <dons> I think I remember a haskell-cafe@ post about this last year. someone had an implementation
19:28:43 <dons> got it! just have to hClose stdin ;)
19:28:56 <dons>  @plugs was waiting for me to finish :}
19:30:02 <dons> and no more zombies
19:30:16 <Darius> Good call
19:30:24 <ozone> dons: silly stateful file handles
19:30:30 <Darius> I should have realized that.
19:32:01 <Darius> dariusbot: @help dynamic-load
19:32:01 <dariusbot> no help
19:32:14 <Darius> Yay!
19:32:16 <dons> cool.
19:32:25 <KrispyKringle> ok, so I'm having an interesting experience here with WASH.
19:32:27 <KrispyKringle> oi, vhey.
19:32:38 <Darius> So much for the monad laws.
19:33:09 <sjanssen> hmm, the hierarchical libraries list has Data.Graph.Inductive.Internal.Heap, it should be simple to make a priority queue of that
19:34:15 <Darius> A priority queue is simple period.  I'm not sure why there isn't one in the heirarchical libraries.
19:34:31 <Darius> The one in FoP is like six lines all told.
19:35:44 <Darius> catchError is apparently strict in it's first argument so moduleHelp md arg wasn't being evaluated in the dynamic scope of the catchError.
19:36:04 <Darius> So the current ugly hack is (return () >>= \() -> moduleHelp md arg)
19:37:17 <dons> hmm.
19:37:55 <Darius> I could probably lift the catchError, but it would be mildly awkward.
19:42:39 <Darius> dariusbot: @help fraggle
19:42:40 <dariusbot> @help <command>
19:42:41 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
19:43:04 <KrispyKringle> ok, so i want to pass a variable via the GET method to a WASH application (rather than just POSTing things), so that a certain "page" can be linked to by copying and pasting the URL.
19:43:55 <KrispyKringle> So I couldn't quite figureout how to access GET args per se, but I figured even better--more user friendly and all--is that I can use the pathInfo field of CGIEnv to get the string that trails the .cgi (i.e. http://server/~me/cgi-bin/script.cgi/foo -> /foo).
19:44:18 <KrispyKringle> But this (appparently) breaks submit0 style continuations, even when I'm not doing /foo (i.e. when I'm just at the .cgi).
19:44:21 <KrispyKringle> Any idea why?
19:44:34 <Darius> Uh, that sucks (re lilo)
19:44:36 <KrispyKringle> hmm. that can't be causal.
19:44:54 <Darius> Or it's April 1st possibly.
19:44:56 <KrispyKringle> three days?
19:45:08 <KrispyKringle> i'd shoot myself! where would I get haskell help? :)
19:46:46 <Darius> KrispyKringle: Mailinglist, wiki, c.l.f, books, tutorials.
19:46:56 <Darius> But it's looking like it won't be an issue.
19:46:57 <KrispyKringle> hehe
19:46:58 <KrispyKringle> true
19:48:48 * Darius wonders what the news.shtml will be this time
19:50:00 <Darius> A piece of my biology history is intact.
19:50:57 <sjanssen> Darius: I finally found the FoP sample chapter, this will definitely work
19:52:40 <dons> I think it's almost time for a ~/.lambdarc file
19:56:47 <Darius> dons: I'm going to send you the patch that should make HelpModule work, you may want to change some things before/after you apply it and the help strings still need to be written.
19:57:47 <dons> ok. that sounds ok.
19:58:15 <dons> I'm just testing the system.process stuff on the mac, then i'll push it into the main rep
20:07:11 <dons> @version
20:07:12 <dariusbot> Sorry, I don't know the command "version", try "dariusbot: @listcommands"
20:07:12 <mac-a-bot> Fri Apr  1 14:05:19 EST 2005, GHC 6.2.2 (Darwin Power Macintosh)
20:07:12 <mac-a-bot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:07:12 <lambdabot> Fri Apr  1 12:02:58 EST 2005, GHC 6.4 (OpenBSD i386)
20:07:12 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:07:27 <dons> mac-a-bot: @quit
20:12:51 <dons> @babel de en nicht mehr Zombies!
20:12:52 <lambdabot>   no more Zombies!
20:13:30 <dons> thankyou lambdabot
20:15:27 <Darius> @babel en de zombie
20:15:28 <lambdabot>   Zombie
20:20:20 <Darius> dons: I just sent the patches.
20:21:58 <dons> got it. cheers.
20:25:17 * Darius writes moduleHelp for @eval
20:25:36 <Darius> Is anyone interested in keeping @eval by the way if there is @plugs?
20:25:50 <metaperl> is shapr gone?
20:26:35 <Pseudonym> shapr is WAY gone.
20:26:40 <dons> @seen shapr
20:26:41 <lambdabot> shapr is in #haskell. I don't know when shapr last spoke.
20:26:51 <Pseudonym> *** shapr has been 1 hours, 39 minutes and 14 seconds idle
20:27:11 <dons> @seen Darius
20:27:12 <lambdabot> Darius is in #haskell. I don't know when Darius last spoke.
20:27:28 <dons> hm. I think it needs people to join to start counting their time.
20:27:49 <Pseudonym> @seen Pseudonym
20:27:49 <lambdabot> Pseudonym is in #haskell. I don't know when Pseudonym last spoke.
20:28:05 <Pseudonym> @seen Pseudonym
20:28:06 <lambdabot> Pseudonym is in #haskell. I don't know when Pseudonym last spoke.
20:28:10 <Pseudonym> OK.
20:28:16 <Pseudonym> @seen Pseudonym
20:28:17 <lambdabot> Pseudonym is in #haskell. I don't know when Pseudonym last spoke.
20:28:20 <Pseudonym> Does it even work?
20:28:22 <dons> @seen Ppseudonym
20:28:23 <lambdabot> I haven't seen Ppseudonym
20:28:29 <dons> @seen Pseudonym
20:28:30 <lambdabot> Pseudonym is in #haskell. I don't know when Pseudonym last spoke.
20:28:33 <dons> mm.
20:28:40 <Pseudonym> I think it's b0rken.
20:28:45 <ozone> @seen any hot chicks :(
20:28:46 <lambdabot> I haven't seen any
20:28:50 <ozone> doh
20:28:54 <Pseudonym> @seen a purple cow
20:28:55 <dons> @seeon ozone
20:28:55 <lambdabot> I haven't seen a
20:28:55 <lambdabot> Sorry, I don't know the command "seeon", try "lambdabot: @listcommands"
20:29:01 <dons> @seen ozone
20:29:01 <lambdabot> ozone is in #haskell. Last spoke 10 seconds ago.
20:29:04 <dons> !
20:29:07 <ozone> haw
20:29:08 <Pseudonym> Hmmm.
20:29:12 <ozone> look at me!  i am mighty!
20:29:22 <Pseudonym> @seen a_purple_cow,_I_hope_I_never_see_one
20:29:23 <lambdabot> I haven't seen a_purple_cow,_I_hope_I_never_see_one
20:29:28 <dons> maybe there's some irc protocol magic happening
20:29:36 <dons> @seen ozone
20:29:37 <lambdabot> ozone is in #haskell. Last spoke 24 seconds ago.
20:29:39 <ozone> @seen an_honest_politician
20:29:40 <lambdabot> I haven't seen an_honest_politician
20:29:53 <Pseudonym> The person who wrote that poem, BTW...
20:30:11 <Pseudonym> I've never seen a purple cow / I hope I never see one / But I can tell you anyhow / I'd rather see than be one.
20:30:33 <Darius> @seen pseudonym
20:30:34 <lambdabot> pseudonym is in #haskell. I don't know when pseudonym last spoke.
20:30:48 <ozone> @seen dons
20:30:49 <lambdabot> dons is in #haskell. Last spoke 29 seconds ago.
20:30:49 <Pseudonym> 20 years later, he wrote this:
20:31:08 <ozone> @seen sjanssen
20:31:08 <lambdabot> sjanssen is in #haskell. Last spoke 13 minutes 9 seconds ago.
20:31:11 <Pseudonym> Ah yes. I wrote the "Purple Cow" -- / I'm sorry now. I wrote it! / But I can tell you, anyhow. / I'll kill you if you quote it.
20:31:15 <ozone> dons: maybe caps?
20:31:21 <ozone> @seen Darius
20:31:22 <lambdabot> Darius is in #haskell. I don't know when Darius last spoke.
20:31:36 <ozone> @seen mac-a-bot
20:31:37 <lambdabot> I haven't seen mac-a-bot
20:31:38 <dons> could be, yep.
20:31:50 <ozone> @seen cooz
20:31:51 <lambdabot> cooz is in #haskell. I don't know when cooz last spoke.
20:31:52 <dons> it got committed just after Heffa's caps-to-lower patch
20:31:57 <ozone> @seen Igloo
20:31:57 <lambdabot> Igloo is in #haskell. I don't know when Igloo last spoke.
20:32:08 <dons> yeah. that's my guess.
20:32:10 <CosmicRay> @seen smart-java-programmers
20:32:11 <lambdabot> I haven't seen smart-java-programmers
20:32:14 <CosmicRay> thought so.
20:32:16 <Darius> @seen dons
20:32:17 <lambdabot> dons is in #haskell. Last spoke 8 seconds ago.
20:34:54 <CosmicRay> argh, globalnotice jokes.
20:34:55 <CosmicRay> sigh.
20:36:46 <TNKS> hey guys, I'm just now reading about named fields in data declarations.  Right now I'm trying to learn from the Haskell Report.  I see the syntax for specifying named fields.  What about for referencing them?
20:36:49 <Pseudonym> There's a problem with that.  Everyone ignores the global notices.
20:37:19 <Pseudonym> "Wolf!  Wolf!... Just kidding.  April Fool!"
20:37:25 <metaperl> TNKS if no one helps you, then YAHT has the answer
20:37:48 <Pseudonym> TNKS: The field name becomes a function.
20:37:56 <Pseudonym> Hugs or GHCi?
20:38:35 <Darius> @wiki UsingRecords
20:38:35 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
20:39:02 <TNKS> What if you have two variables of the same type?
20:39:13 <CosmicRay> TNKS: try this tutorial: http://www.isi.edu/%7Ehdaume/htut/
20:39:22 <CosmicRay> TNKS: I find it a better resource for learning than the report
20:40:08 <metaperl> everything other than one of the Haskell books is a waste of time
20:40:12 <Darius> I find that it has a lot of minor annoying problems (or at least the version I read did)
20:40:43 <metaperl> going back to Gentle every once and awhile is good, but only the professionally written books handle the material excellently
20:41:09 <metaperl> but YAHT is certainly the best thing you can get for free
20:41:10 <CosmicRay> metaperl: which is the one you are particularly fond of again?  I have Haskell: The Craft of Functional Programming, and it is very nice but I haven't actually read much of it
20:41:20 <metaperl> yes, I am reading Craft now
20:41:24 <metaperl> up to chapter 3
20:41:26 <CosmicRay> metaperl: yes, I'd agree with you, but I wouldn't say YAHT is a waste of time
20:41:29 <metaperl> very happy with it
20:41:30 <Darius> dariusbot: @help dump
20:41:38 <metaperl> YAHT gets spotty at the end
20:41:47 <CosmicRay> metaperl: because the last few chapters haven't been written? :-)
20:41:53 <dariusbot> @dump - dump definitions to disk
20:41:53 <lambdabot> not enough privileges
20:42:02 <metaperl> but yes, it is not bad. It's just not as good as Craft
20:43:02 <dons> lambdaTesting: @seen dons
20:43:03 <lambdaTesting> dons is in #haskell. Last spoke just now.
20:43:24 <dons> lambdaTesting: @seen Darius
20:43:25 <lambdaTesting> Darius is in #haskell. I don't know when Darius last spoke.
20:43:30 <dons> lambdaTesting: @seen ozone
20:43:31 <lambdaTesting> ozone is in #haskell. I don't know when ozone last spoke.
20:43:35 <CosmicRay> metaperl: you may be interested in darcs get http://darcs.complete.org/haskell-v8
20:43:55 <CosmicRay> metaperl: some of us have been working on and off on a sort of haskell for hackers thing
20:44:01 <CosmicRay> very preliminary, very spotty thus far
20:44:15 <CosmicRay> but it strikes me as the sort of thing you might have an interest in
20:44:24 <dons> lambdaTesting: @seen CosmicRay
20:44:25 <lambdaTesting> CosmicRay is in #haskell. Last spoke 9 seconds ago.
20:44:43 <dons> lambdaTesting: @quit
20:44:46 <TNKS> Do you get labelled fields with newtype?
20:45:32 <CosmicRay> TNKS: no.
20:45:42 <TNKS> CosmicRay, thanks.
20:46:46 <Pseudonym> Don't you?
20:46:53 <Pseudonym> You can get one labelled field, I believe.
20:47:00 <Pseudonym> Or is that a Glasgow extension?
20:47:11 <CosmicRay> hmm, that doesn't seem to be what I recall, but I could be wrong
20:47:15 <CosmicRay> in any case, what's the point of that?
20:47:22 <Darius> I use it constantly
20:47:37 <CosmicRay> for the free accessor function?
20:47:46 <Darius> CosmicRay: Pretty much.
20:47:51 <Pseudonym> newtype Foo a = Wrap {unwrap :: a }
20:47:58 <Pseudonym> It's especially useful for this:
20:48:08 <Darius> This usage should be covered on the wiki page.
20:48:10 <CosmicRay> leads to confusing code though
20:48:20 <Pseudonym> newtype State a = State { runState :: s -> (s,a) }
20:48:25 <Darius> CosmicRay: How?
20:49:20 <dons> @seen Pseudonym
20:49:21 <lambdabot> Pseudonym is in #haskell. Last spoke 1 minute ago.
20:49:27 <Darius> @seen Darius
20:49:28 <lambdabot> Darius is in #haskell. Last spoke just now.
20:49:40 <Pseudonym> What was the problem?
20:50:09 <CosmicRay> Darius: Foo {unwrap = 5} seems a little odd, no?
20:50:24 <Pseudonym> Yeah, so you don't do that.
20:50:25 <Darius> CosmicRay: Yes, but no one uses it that way.
20:50:26 <Pseudonym> You just do FOo 5.
20:50:30 <Pseudonym> Foo 5
20:50:31 <dons> Heffa gave me a patch yesterday to normalise nicks in @seen, I then merged in my time counting patch, but didn't add normalising code to it
20:50:43 <Pseudonym> Aaaah.
20:50:45 <Darius> @seen darius
20:50:46 <lambdabot> darius is in #haskell. Last spoke just now.
20:50:54 <dons> @seen Darius
20:50:54 <lambdabot> Darius is in #haskell. Last spoke 8 seconds ago.
20:51:14 <CosmicRay> Pseudonym: huh, is that a standard shortcut?
20:51:25 <Pseudonym> Of course.
20:51:31 <Darius> Yes, record types can be used as positional types
20:51:32 * CosmicRay learned something today, then.
20:51:39 <CosmicRay> nifty.
20:51:40 <Darius> read the UsingRecords page
20:52:21 <Darius> Actually, you may even be able to export the field accessor as a function and not as a field, but I'm guessing here.
20:52:27 <CosmicRay> @wiki UsingRecords
20:52:28 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
20:52:32 <Pseudonym> I think so, yes.
20:52:38 <CosmicRay> Darius: yes, I have done that.
20:53:22 <Darius> Anyways, I'm going to call it a night.
20:54:41 <CosmicRay> me too.
20:54:43 <CosmicRay> cyall tomorrow.
20:55:06 <Pseudonym> Night.
21:35:30 <jmob|> Hello #haskell
21:37:39 <jmob|> Is Haskell at all similar to SML?
21:37:50 <dons> yeah, fairly similar
21:39:04 <jmob|> Then I wonder why a professor would choose to teach SML over Haskell, since Haskell seems to be more alive and actively used.
21:39:26 <dons> that's a good question - most probably because they know it well
21:40:31 <dons> there are some significant, large apps still written in SML - isabelle and twelf come to mind - but they've been around for over a decade
21:40:54 <dons> haskell is where it's at!
21:41:37 <jmob|> yes, I'd like to learn haskell
21:41:59 <jmob|> I like programming with SML, but I like the languages I use to be somewhat "alive"
21:42:16 <dons> cool :) this is a good place to hang out and ask Haskell questions
21:42:42 <dons> there's some useful links in the topic line
21:42:53 <dons> and a friendly bot to answer some queries
21:43:00 <dons> @type 1
21:43:01 <lambdabot> 1 :: forall t. (Num t) => t
21:43:40 * jmob| pets lambdabot 
21:43:44 <dons> @plugs map (+1) [1..10]
21:43:45 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
21:44:23 <dons> and so on. and there's many people here who are happy to answer good Haskell questions
21:44:54 <ozone> as opposed to bad haskell questions, in which case we will hunt you down and cut your toenails
21:45:12 <dons> ozone is a silly monkey - don't mind him
21:46:18 <dons> it's so good not seeing lots of zombies chasing after lambdabot. Long live System.Process
21:48:04 <aheller> This could be a real deficiency in my read of haskell.org/tutorial/, but is there a nice interactive way to have hugs tell me what the type of an expression is?  Short of hoping it's not show-able?
21:49:36 <dons> :t ?
21:49:53 <dons> Hugs.Base> :t 1 + 2
21:49:54 <dons> 1 + 2 :: Num a => a
21:50:21 <aheller> ah; fantastic!
21:50:36 <aheller> thanks!
21:51:37 <dons> same syntax in ghci, btw.
21:51:54 <aheller> even fantastic-er
21:52:08 <aheller> ocaml kind of spoiled me that way.
21:52:31 <dons> and in hmake:
21:52:32 <dons> Prelude> :t 1 + 2
21:52:32 <dons> (Prelude.Num a) => a
21:52:39 <dons> so it's :t all around :)
21:52:44 <aheller> sweet.
21:53:31 <beschmi> :browse is nice too (as in :browse List)
21:54:51 <aheller> Apparently List is not import'd by default in hugs.
21:55:03 <aheller> Or, I don't know what I'm talking about, which would be the more appropriate response.
21:55:45 <dons> Hugs.Base> :load List
21:55:45 <dons> List> :t sort
21:55:45 <dons> sort :: Ord a => [a] -> [a]
21:56:14 <aheller> aha.
21:56:31 <aheller> That one should have been obvious.  I am shamed.
21:56:39 <beschmi> only tested with ghci where you don't have to load the module
21:56:55 <beschmi> for :browse
21:57:01 <aheller> ah...
21:57:25 <aheller> I don't know that I'm at the point where I'm wanting to worry about interpreter differences just yet.
22:12:00 <TNKS> hey guys, is there a function for extracting values from a 2-tuple like "first" and "second".
22:12:13 <TNKS> I've always ended up writing these things from scratch.
22:12:38 <Khisanth> a tuple of tuples?
22:13:23 <TNKS> sorry. . .
22:13:47 <dons> @plugs Data.Tuple.fst ('a','b')
22:13:48 <TNKS> basically, is this pre-defined?  first (a,b) = a
22:13:48 <lambdabot> 'a'
22:13:57 <dons> @plugs Data.Tuple.snd ('a','b')
22:13:58 <lambdabot> 'b'
22:14:05 <TNKS> hey, thanks.
22:14:07 <dons> @plugs Data.Tuple.snd (undefined,'b')
22:14:08 <lambdabot> 'b'
22:14:36 <dons> @plugs Data.Tuple.fst (undefined,'b')
22:14:37 <lambdabot> /tmp/MQWsB11481.hs:1:
22:14:37 <lambdabot>     Ambiguous type variable `a' in the top-level constraint:
22:14:37 <lambdabot>       `Show a' arising from use of `show' at <Plugins.Eval>:1
22:14:41 <dons> hehe
22:14:46 <dons> @plugs Data.Tuple.fst (undefined :: (),'b')
22:14:47 <lambdabot> Fail: Prelude.undefined
22:58:36 <mwc> My god, I've finally grok'd haskell. Damn this is cool.
22:58:50 <beastmaster_> a :: Int
22:58:57 <beastmaster_> ERROR - Undefined variable "a"
22:58:59 <beastmaster_> why?
22:59:20 <mwc> beastmaster_, are you in Hugs?
22:59:20 <Gahhh> That's just a declaration
22:59:29 <beastmaster_> mwc, yep
22:59:53 <mwc> beastmaster_, you'll want to put all definitions in a file and do :l "foo.hs"
23:00:06 <mwc> it had me pretty confused too this afternoon
23:00:18 <beastmaster_> um.. .. weird lol..
23:00:24 <mwc> but by now I'm reading Haskell and not seeing line noise, so I'm pretty excited
23:00:36 <mwc> beastmaster_, hugs' prompt will only evaluate expressions
23:00:43 <beastmaster_> um ok..
23:00:55 <beastmaster_> 1 sec.. let me try it again
23:01:02 <dons> @plugs let a :: Int ; a = 1 in a
23:01:03 <lambdabot> 1
23:01:11 <dons> is one way.
23:01:35 <beastmaster_> interesting =)
23:03:58 <beastmaster_> mwc, it works :D, thanks
23:10:24 <Itkovian> for a sec I thought it said 'breastmaster'
23:10:31 * Itkovian was on the verge of bowing
23:10:37 <Itkovian> :-)
23:10:48 <beastmaster_> lol :p
23:11:19 <beastmaster_> :| it's quite common that ppl see it wrong :>
23:17:46 <Itkovian> makes one wonder where my mind dwas
23:17:50 <Itkovian> not at work, surely
23:18:24 <beastmaster_> :>
23:40:50 <dons> @help eval
23:40:51 <lambdabot> @eval expr - evaluate the lambda calculus expression, expr
23:40:55 <dons> @help help
23:40:56 <lambdabot> @help <command>
23:41:00 <dons> @help plugs
23:41:01 <lambdabot> @plugs <expr>
23:41:01 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
23:42:11 <Heffalump> kewl :-)
23:42:45 <dons> :D
23:43:33 <Heffalump> (why'd it need restarting for the new module, OOI?)
23:43:40 <mflux> how much memory does it have? ..
23:44:24 <dons> I would have had to reload all the modules
23:44:41 <dons> as each has a new moduleHelp method
23:44:50 <dons> mflux: plugs? ulimit -d.
23:48:04 <Heffalump> mflux: and no more than it can allocate in 3 seconds without you being able to explicitly malloc :-)
23:48:21 <Heffalump> @plugs last [1..]
23:48:27 <mflux> :)
23:48:28 <Heffalump> eeek!
23:48:30 <Heffalump> sorry...
23:48:32 <mflux> so apparently quite much :)
23:49:30 * Heffalump had better try that on his own sandboxing code..
23:49:34 <dons> that's odd.
23:49:40 <Heffalump> did it say why it died?
23:50:01 <dons> Exception: waitForProcess: interrupted (Interrupted system call)
23:50:09 <Heffalump> odd.
23:50:22 <Heffalump> wonder if it's a race condition that just happened randomly
23:50:32 <dons> we have just switched over to System.Process, so it hasn't been tested fully yet
23:50:34 <Heffalump> I'll leave it to you to try that again if you want, though :-)
23:51:21 <dons> probably getting a sighup or whatever timing out delivers throws a funny exception
23:51:29 <dons> shouldn't be too hard to catch
23:53:45 <dons> yeah, looks like just an errno exception - probably because the waiting process got terminated for overrunning it's time limit
23:53:57 <dons> so that's something new in 6.
23:53:58 <dons> 4
23:54:24 * dons hacks PosixCompat a bit more
