00:00:08 <shapr> Personally, I don't care so much about the spelling, grammar, and layout. As long as the communication is clear, my goals are learning, teaching and code. I'd prefer articles where the author learned something while writing, is teaching something to the reader, and has working code that comes in or with the article.
00:00:32 <shapr> You think TMR needs an ISSN?
00:01:04 <ibid> it would benefit from one
00:01:10 <ibid> it's a token of respectability :)
00:04:02 <Itkovian> morning musasabi, and the rest of #haskell
00:04:05 <ibid> do you have a length requirement/guideline?
00:04:27 <Lemmih> ISSN?
00:04:32 <Itkovian> shapr: thanks for putting up the 'reduced' one_file_tmr_version
00:04:57 <Itkovian> shapr: if it had an ISBN, I could really put some work into writing articles for it :-)
00:05:02 <ibid> Lemmih: international standard serial number. (almost) all periodicals have one :)
00:05:42 <shapr> Itkovian: how does an ISSN or ISBN change the amount of work you can put in?
00:06:18 <ibid> shapr: ISSN stuff is more respectable, it's easier to justify putting it on ones publications list
00:07:26 <ibid> shapr: and in academic circles, the length of ones pub list is in connection with ones salary and job opportunities :)
00:07:42 <Itkovian> shapr: then I can do it at work ;-)
00:08:07 <Itkovian> It would count as a (minor) publication. Especially if it is reviewed.
00:08:38 <shapr> amazing.
00:09:01 <shapr> If that's true, why don't people start their own journals, review each other's work, and pad their salary that way?
00:09:35 <ibid> shapr: the length of a paper pub-list-wise is proportional to the respectability of the venue
00:09:54 <Itkovian> well, my salary wouldn't get padded ...
00:09:54 <ibid> shapr: an ISSN alone makes a short one :)
00:10:06 <ibid> shapr: and really, people *do* do that :)
00:10:10 <shapr> oh
00:10:20 <Itkovian> and actually, it would take a while and some serious input of well known folks to make the journal acceptable.
00:10:24 <ibid> shapr: but usually there's other motives as well
00:10:52 <ibid> shapr: and as Itkovian says, to make the venue really respectable, it needs to have heavyweight backing :)
00:11:01 <Itkovian> There are quite a number of low-barrier journals, but then usually mean jack shit, because nobody takes what's in them seriously.
00:11:28 <Itkovian> If, say, SPJ would publish on a regular basis in TMR, then well ... you get the pic ...
00:11:36 <shapr> I think well-known folks may end up writing for The Monad.Reader, but my priority is making knowledge available in a more accesible manner.
00:11:43 <Itkovian> yeah.
00:11:49 <Itkovian> that was the goal. stick to it
00:13:08 <shapr> Somebody recently asked for permission to quote one of my emails "Academics are continuously chewing bits off of impossible and turning them into merely difficult" I'd TMR to be the next step "chewing bits off of difficult and making them accessible."
00:13:50 <dons> i don't know about other unis, but I have to send proof of publications to an office which reviews them for international significance, before they augment my salary :)
00:14:16 <dons> so that's what stops me setting up "The Don Journal".
00:15:46 <nlv11757_> it should be just about the knowledge in my perpective
00:16:27 <Itkovian> dons: here we use the ISI database, and stuff counts only if it can be found in the citation index, i.e. A1 journals/conferences
00:16:41 <Itkovian> well, other stuff counts too, but not for much
00:18:45 <shapr> I want articles such that newbies on #haskell can say "Is there a tutorial for doing X Haskell?" and I can point them to the gtk2hs article for GUIs, hopefully my Template Haskell tutorial for next issue, Pugs as a good example of implementing a language in Haskell, etc
00:22:13 <shapr> So, who can I pick on this month? :-)
00:22:38 <shapr> If an ISSN is motivational for authors, I'll check into getting one.
00:22:51 <ibid> i ask again: do you have a length requirement/guideline?
00:22:58 <ibid> shapr: ISSN is pretty easy to get
00:24:27 <shapr> No length requirement/guideline, same quote as always "Begin at the beginning, go to the end, then stop."
00:25:53 <ibid> hmm, where have i heard that one before?
00:47:46 <dons> Itkovian: yeah, same system I think.
01:05:27 <shapr> @index asTypeOf
01:05:27 <lambdabot> GHC.Base,Prelude
01:05:38 <shapr> @type asTypeOf
01:05:41 <lambdabot> asTypeOf :: forall a. a -> a -> a
01:10:05 <shapr> I don't understand Henning Thielemann's post to haskell-cafe.
01:11:11 <Lemmih> He just posted a nicer way of doing the same thing.
01:11:22 <shapr> Yes, but I don't understand how it works.
01:12:16 <shapr> asTypeOf       :: a -> a -> a
01:12:16 <shapr> asTypeOf        = const
01:12:19 * shapr blinks
01:12:45 <swiert> shapr: I think the idea is to force the type checker into not inferring the most general type.
01:13:21 <swiert> instead of inferring that the function must have type a -> b, you coerce the result and argument of the function to be the same (enter asTypeOf)
01:13:52 <shapr> oh, I see.
01:17:44 <shapr> neato, thanks for the explanation.
01:17:56 <shapr> I never thought of using const that way.
01:18:00 <shapr> Anyway, worktime, bbl.
01:23:05 <nlv11757_> is there an advantage of using GHC.IO over System.IO or vice versa?
01:23:46 <Lemmih> Don't use GHC.* unless you're really sure that's what you want.
01:24:12 <nlv11757_> functions for reading files etc are in both....so what should i use then?
01:24:30 <Lemmih> System.IO
01:24:44 <nlv11757_> for portability?
01:24:50 <Lemmih> Yes.
01:30:32 <bourbaki> moin
01:36:10 <bourbaki> good morning boegel
01:36:44 <boegel> hey bourbaki
01:38:06 <tromp> morning bo&bo :)
01:38:34 <bourbaki> hehe
01:39:04 <bourbaki> do you know the original batman soundtrack?
01:41:33 <jlouis> whoa, QuickCheck seems easy to use
01:53:44 * sqrt hasn't learned to love this book on formal semantics. yet?
01:54:08 <nlv11757_> formal semantics of haskell by vaxen?
01:54:33 <nlv11757_> i mean Faxen
02:25:13 <sqrt> nono, of programming languages, nlv11757_.
02:51:59 * kzm rubs his eyes, and looks around.
02:52:07 <kzm> Morning, y'all.
02:52:11 <musasabi> morning
02:52:49 <kzm> Anybody know anything about building index structures with Haskell?
02:53:09 <kzm> (cf. mail on glasgow-haskell-users)
02:54:04 <kzm> ...or any experience with hash tables?
02:54:19 <Lunar^> kzm: IIRC there's things on the wiki
02:54:20 <Lunar^> z
02:54:29 <Lunar^> kzm: And you might things in Okasaki's thesis/book
02:55:19 <kzm> well - yes.  I'm basically looking for experiences and advice on how to do things efficiently with GHC
02:55:52 <Lunar^> mh.. ok
02:55:53 <kzm> (searching the wiki wasn't terribly helpful - perhaps I'll have to check again)
02:56:01 <Lunar^> Data.IntMap might be the fastest available
02:56:24 <kzm> Is it much faster then the old FM?
02:57:05 <kzm> How will creating/destroying lots of arrays work with GC?
02:58:04 <kzm> I guess the right question is:  what is a space efficient way to store updateable sets of integers?
02:58:19 <kzm> (Happily accept linear time with less space)
02:58:36 <musasabi> kzm: using Data.HashTable is not very fast.
02:58:42 <musasabi> strictness is important.
02:58:49 <musasabi> Data.IntMap is quite fast.
02:59:15 <musasabi> kzm: dense or sparse sets?
03:01:15 <kzm> sparse sets
03:01:36 <tromp> fastest are UArrays
03:01:56 <tromp> if your data is happy to live in arrays
03:02:44 <kzm> Define "happy".  Add or delete means allocating a new array, and deleting the old one.  I think that will be expensive, and I suspect the GC may not like it.
03:02:45 <tromp> IOUArray and STUArray don't do any copying
03:03:24 <tromp> your updates will have to be in the IO or an (ST s) monad though
03:03:27 <musasabi> kzm: I would start with Data.IntSet
03:03:56 <kzm> tromp, then I need an IO/ST version of Map for this to be efficient.
03:03:59 <tromp> morning, musasabi
03:04:22 <musasabi> kzm: not really - just MVar/IORef to one.
03:04:31 <musasabi> and be careful with lazyness.
03:04:34 <musasabi> morning tromp
03:04:40 <kzm> musasabi, but that will be no more (less?) space efficient than a list, wouldn't it?  Or are IntSets smarter?
03:04:54 <kzm> Mmm...yes, I didnt' think of that.
03:04:58 <tromp> kzm, i used IOUArrays to implement my own custom hashtable
03:05:34 <tromp> which I don't advise in general though:(
03:05:39 <musasabi> kzm: it is hard to be more space efficient than list (except with list implemented as chunked arrays) for sparse sets.
03:06:34 <tromp> musasabi: you can search my article in gougle groups
03:06:42 <tromp> eg with keywords connect-4 haskell space leak
03:06:52 <kzm> well - perhaps.  In C (etc) I would use updateable arrays.  I must admit to not having used MVars/IORefs before -- wold that give me the same thing?
03:07:40 <tromp> @index MVar
03:07:41 <lambdabot> Control.Concurrent,Control.Concurrent.MVar,GHC.Conc,GHC.IOBase,GHC.IOBase
03:07:53 <kzm> @help
03:07:54 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
03:08:00 <kzm> @listcommands
03:08:00 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
03:08:00 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
03:08:00 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
03:08:00 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
03:08:00 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
03:08:01 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
03:08:03 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
03:08:03 <musasabi> tromp: looking at the source.
03:08:05 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
03:08:07 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
03:08:31 <kzm> interesting
03:08:40 <kzm> (sorry about the noise)
03:08:46 <tromp> what sort of data are you mapping?
03:09:05 <kzm> fixed length words (qgrams) to positions in a large data set
03:09:13 <musasabi> kzm: you don't need an efficient membership test? If not you can use STUArrays just like you would use C arrays.
03:09:26 <tromp> sounds like what i did in my genome comparison program
03:09:58 <tromp> over what alphabet are your qgrams?
03:10:09 <kzm> musasabi: I can keep them sorted, which gives log n binary search.  Or not -- space is more of a consern than time -- at least at this point.
03:10:24 <kzm> tromp, nucleotides, i.e. {A,C,G,T}
03:10:39 <tromp> ah, same thing i did:)
03:11:03 <tromp> i just represented the qgrams as an integer using 2 bits per base
03:11:28 <kzm> Yep, that's the idea.
03:11:28 <tromp> and indexed a big table to get first occurance of that qgram
03:11:50 <kzm> What was the application, if I may ask?
03:12:03 <tromp> genome comparison
03:12:18 <tromp> the program PatternHunter
03:12:46 <kzm> In Haskell?  Cool - I shall have to take a look.  I'm doing ESTs.
03:12:54 <tromp> no, that was in Java
03:12:58 <kzm> Redoing, as a matter of fact.
03:13:01 <tromp> speed mattered a lot:)
03:13:22 <kzm> Ah - sad.  So...which Java implementation is fast, these days?
03:13:41 * kzm is trying to be ironic, but harbours a secret fear that they finally managed to work it out.
03:13:49 <tromp> just pick Sun's or IBM's latest JVM
03:14:01 <tromp> i personally had slightly better exp with IBM's
03:14:13 <kzm> Did you see Tomasz recent posts to c.l.f.?
03:14:41 <tromp> comp.lang.f??
03:14:46 <kzm> Silly microbenchmark counting primes, but his Hs impl beat an OCaml one.
03:14:56 <tromp> functional?
03:14:56 <kzm> (functional)
03:15:03 <kzm> Yes, that's it
03:15:03 <tromp> not subscribed to that
03:15:17 <tromp> i have a nice connect4 benchmark:)
03:15:24 <tromp> in both C, Java and now Haskell
03:16:03 <tromp> i'll have to get some1 to do it in ocaml as well
03:16:12 <kzm> connect4?  And how do the languages fare?
03:16:16 <tromp> dont feel like learning that myself
03:16:26 <tromp> java lags about 30% behind C
03:16:37 <tromp> haskell so far seems 100 times slower
03:16:38 <kzm> Well, that's not so bad.
03:16:43 <kzm> That is bad.
03:16:46 <tromp> but still suffers from space leak
03:16:54 <kzm> Strictness?
03:17:08 <tromp> i made it as strict as i could
03:17:26 <tromp> see my posting to fa.haskell
03:18:07 <tromp> i'll go subscribe to c.l.f
03:18:18 <kzm> And I must read up on MVars.
03:18:27 * kzm goes back to sleep.
03:18:31 <tromp> that's for concurency
03:23:03 <kzm> Snort...zzzz...btw, any interest in a general library for parsing FASTA files?
03:24:03 <tromp> not yet:)
03:24:05 <tromp> l
03:28:14 <basti_> hi all
03:30:01 <basti_> lisppaste2: url
03:30:01 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
03:30:43 <musasabi> tromp: alphabeta should have a stricter signature.
03:30:52 <lisppaste2> basti_ pasted "A really terse permutation function" at http://paste.lisp.org/display/6219
03:31:07 <musasabi> tromp: the current implementation infers a very generic one.
03:31:07 <basti_> since we had it about permutations recently
03:31:13 <basti_> I'd love tips how about to do "thru" betteer
03:31:36 <musasabi> same goes for addArray
03:32:02 <tromp> oh, never thought that lack of signatures cld cause space leaks
03:32:38 <lightstep> what a pretty alternative to reverse!
03:33:14 <tromp> alphabeta :: forall m l a.
03:33:14 <tromp>              (Move m, Lock l, GHC.Arr.Ix m, Data.Array.Base.MArray a Int IO) =>
03:33:14 <tromp>              a m Int -> TTable l -> Int -> GameTree l m -> IO Int
03:33:49 <jlouis> guys, are ``concatIntersperse x = concat . List.intersperse x'' a PreludeExt worthy extension?
03:33:56 <jlouis> I am using it all the time for manipulating lists
03:34:03 <tromp> looks right to me, musasabi
03:34:12 * kzm grumbles.
03:34:15 <musasabi> tromp: it is correct but lax.
03:34:45 <tromp> you mean I have to fix l,m, and a?
03:34:55 <musasabi> yes.
03:35:16 <musasabi> and add a strict signature for addArray too.
03:35:36 <tromp> i'll try
03:36:06 <lightstep> basti_, concatMap = concat . map, but is more efficient
03:36:14 <basti_> lightstep hmm ok.
03:37:00 <basti_> lightstep I was thinking about doing thru differently, as in a recursive function.
03:37:38 <lightstep> if i get it reight, tghru inserts x in every position in every list in xs?
03:37:41 <basti_> yes.
03:37:49 <basti_> uhm no
03:37:52 <basti_> at every position in xs
03:38:00 <basti_> not "at every position in every list
03:38:23 <basti_> try "thru 1 [2,3,4]
03:38:32 * basti_ is second-quote disabled today.
03:39:05 <lightstep> i don't have haskell on this machine. but it seems thru::a->[[a]]->[[a]]
03:39:31 <basti_> no because inits and tails
03:39:43 <basti_> they make [a] -> [[a]]
03:40:20 <lightstep> so a->[a]->[[a]] ?
03:40:27 <basti_> yes.
03:41:51 <TheHunter> basti_, i'm pretty sure ghc's code for "i++(x:t)" and "(i++[x]++t)" is the same (under -O).
03:42:16 <basti_> hmm ok.
03:43:08 <basti_> The latter is easier to read isnt it?
03:43:13 <lightstep> thru x xs = (x:xs) : more where more = case xs of []->[]; (h:t)->h:(thru x t)
03:43:27 <basti_> hmmm nice.
03:43:27 <lightstep> that is how i'd naturally do it
03:43:39 <basti_> yes i had something similar in mind
03:43:52 <basti_> more verbose though
03:44:04 <tromp> it still leaks, musasabi
03:45:33 <musasabi> tromp: do you have the updated version somewhere?
03:47:20 <TheHunter> i think "i++x:t" is easiest to read, but that's personal taste.
03:48:42 <basti_> lightstep this doesnt do fully what it's supposed to do
03:49:06 <basti_> x:xs is a [a] not a single a
03:50:31 <TheHunter> basti_, why not use zipWith?
03:51:10 <basti_> TheHunter didnt see that, but, yes.
03:52:18 <basti_> but something similar to the thing lightstep suggested is even better i think
03:53:07 <lisppaste2> basti_ annotated #6219 with "a better thru" at http://paste.lisp.org/display/6219#1
03:53:08 <tromp> my X server crashed after my haskell program put me in swap hell:(
03:54:56 <tromp> what were u saying before, musasabi?
03:56:04 <musasabi> tromp: could you upload the modified (with the signatures) somewhere?
03:56:06 <kzm> tromp, limit heap usage to available RAM - 10% or so.
03:56:15 <kzm> (+RTS -M, I think)
03:57:11 <kzm> musasabi, I just made a toy impl using FiniteMap Int (MVar Int), and it worked nicely.  All updates/lookups must run in the IO (or another?) monad, though.
03:57:22 <tromp> alphabeta :: IOUArray Int Int -> TTable Word32 -> Int -> GameTree Word32 Int -> IO Int
03:57:28 <tromp> addArray :: Int -> IOUArray Int Int -> Int -> IO ()
03:58:00 <kzm> BTW - any idea why Haskell doesn't support ! in type sigs?  I think clean does.
03:58:05 <tromp> and i had to move the two instance declarations from Main.hs to GameTreeSearch.hs :(
03:58:10 <basti_> kzm whats !?
03:58:13 <basti_> in a type?
03:58:15 <basti_> unique?
03:58:19 <kzm> (I.e. foo :: !Integer -> String
03:58:29 <kzm> Strictness, I mean.
03:58:38 <kzm> (I don't know Clean, btw)
03:58:39 <basti_> hm.
03:59:11 <kzm> instead of foo x | x `seq` False = undefined \n | ....
03:59:20 <kzm> or similar, a bit ugly, patterns
03:59:51 <kzm> It'd be nice to see immediately from the signature, and easier to change...but there may be a reason against it?
03:59:58 <ibid> well, most pattern-matching functions are strict in any case
04:00:20 <TheHunter> i'm with kzm, that'd certainly be useful.
04:00:32 <kzm> ibid, the point is that foo isn't really pattern matching, it's just a convenient place to put strictness dummy code.
04:00:46 <ibid> kzm: hmm?
04:00:57 <kzm> Okay, let's storm the Haskell Towers!  Who's with me?
04:00:58 <kzm> :-)
04:01:13 <ibid> it'd certainly be nice
04:01:22 <ibid> but i've learned to live without it :)
04:01:46 <ibid> if you pattern-match (deconstruct) against a parameter, it's strict
04:01:48 <kzm> if I have a function, e.g. foo x, the usual way to make it strict is to add some guards, with the first case evaluation the strict parameters, and then fail.
04:02:00 <ibid> the "usual way"
04:02:03 <ibid> ?
04:02:18 <ibid> the usual way is just write the function so that it's strict :)
04:02:41 <kzm> ...and that's how to do it.
04:02:43 <kzm> :-)
04:02:56 <ibid> i don't think i've ever seen that kind of dancing around for strictness' sake
04:03:23 <TheHunter> the usual way is $!
04:03:51 <ibid> that's in the wrong side of the fence :)
04:03:52 <kzm> Okay, okay.  Strike 'usual'.  I've seen it on some occasions, at any rate.
04:04:43 <kzm> In general, I often use: arg1 `seq` arg2 `seq` expression arg1 arg2 ...
04:05:22 <ibid> for me, most of the time when it matters the function is pattern-matching so i get it for free
04:05:43 <kzm> Example from c.l.f follows:
04:06:31 <kzm> >         let remove step i  step `seq` i `seq` False = undefined
04:06:46 <kzm> >               | step) otherwise = return ()
04:06:52 <ibid> that's a syntax error, right?
04:07:02 <kzm> Argh...that didnt' quite work.
04:07:04 <ibid> or not haskell
04:07:05 <tromp> can you just copy&paste those 3 changes, musasabi?
04:07:24 <kzm> let remove step i | step `seq`i `seq`False = undefined
04:07:59 <kzm>                 | i <= maxN = unsafeWrite a i False >> remove step (i + step)
04:08:07 <kzm>                    | otherwise = return
04:08:13 <kzm> (Think that's it)
04:08:14 <tromp> btw, the compiler shld be able to work out that i use the functions in this exact restricted way
04:08:42 <kzm> (modulo spacing and indentation)
04:09:16 <kzm> So at least Tomasz Z. uses it :-)
04:09:26 <kzm> Which makes it "usual".  QED.
04:09:27 <kzm> :-)
04:09:42 <lightstep> basti_, from the way you put my suggestion, it screams for swing map, or something similar
04:09:42 <ibid> well, i is forced by the comparison in second line in any case
04:10:17 <ibid> so if you for some reason need to force step (why?) then an explicit seq is appropriate
04:10:49 <lightstep> basti_, except now i see it wouldn't work. too bad there isn't a standard HOF for that sort of thing
04:10:56 <ibid> kzm: why is it important that step and i are forced?
04:11:11 <basti_> lightstep HOF?
04:11:33 <kzm> That is not the point, is it?  Ask Tomasz who wrote the code.  My point is that this way of strictness-annotating the code isn't as pretty as a type-signature annotation.
04:11:38 <lightstep> higher order function, aka combinator
04:11:42 <basti_> ah
04:11:51 <ibid> kzm: *my* point is that it's unnecessary
04:11:56 <basti_> just didnt "get" the shorthand...
04:12:12 <ibid> kzm: unless it's required by something that's not visible in that code
04:12:24 <kzm> Strictness annotations in general?  Surely you jest!
04:12:44 <ibid> kzm: don't put words in my mouth
04:12:54 <ibid> kzm: in that example, i see no reason to strictness-annotate
04:13:35 <ibid> kzm: in general, strictness annotations are necessary mainly as an optimization technique and in some rare cases for some semantic use
04:13:43 <kzm> Okay. Fine.  Sometimes you don't need to use strictness annotations.
04:13:52 <ibid> kzm: in both cases, seq is quite enough
04:14:15 <ibid> kzm: now, strictness flags in data types have also semantic sense
04:14:23 <ibid> kzm: most of the time you don't need them
04:15:16 <kzm> Hmm... exactly what are we disagreeing about?
04:15:52 <ibid> kzm: i don't know. you seemed to go ballistic when i asked why you need strictness in a particular example :)
04:17:11 <ibid> but as i said, strictness annotation in function types would be nice
04:17:26 <ibid> but i don't see any pressing need for them, as you seemed to
04:17:33 <kzm> Well, it's hard to avoid being under the influence of gravity.  Sorry if I sounded rude.
04:17:46 <ibid> no harm done :)
04:18:06 <kzm> No pressing need, just sugar.  But nice, harmless sugar.
04:18:19 <ibid> syntactic sugar causes cancer of the semicolon :)
04:18:40 <ibid> (alan perlis)
04:19:03 <ibid> afk
04:19:13 <kzm> :-)
04:26:04 <Philippa> ibid: strictness annotations would be useful for some list functions
04:29:44 <boegel> hmm, I just got great feedback of my promotor: 'Looking great!' :|
04:29:55 <musasabi> tromp: makeGameTree looks like the guilty party.
04:30:23 <tromp> but when negamax is done on a subtree, why doesn't all the space get released?
04:30:50 <tromp> what links cld or dependencies cld there be on the generated subtree?
04:31:09 <tromp> the global state is just some unboxed arrays
04:33:07 <musasabi> tromp: maybe because it is still referenced from the top-level makeGameTree call.
04:33:22 <tromp> also, makeGameTree has to be lazy, because negamax shld decide which subtrees to search
04:34:08 <tromp> that makes little sense, musasabi
04:34:40 <tromp> gametree is only references in order to evaluate it to a score
04:35:07 <tromp> it's like taking length on a list. once u have the length, you dont need the list
04:35:25 <tromp> i'm stumped:(
04:35:42 <musasabi> tromp: but you can first evaluate the list then return the whole list and then take the length. I think this is similar behaviour.
04:36:09 <u1sf> can you set the infix associativity of a type?
04:36:13 <tromp> no, it only generates what it needs
04:36:34 <tromp> it just fails to release the space once its done with a subtree
04:37:18 <lightstep> u1sf, do you mean a type constructor?
04:37:59 <u1sf> no, I mean like X `Either` Y `Either` Z
04:38:40 <tromp> infixl or infixr
04:40:08 <u1sf> do you have to do that at a particular point in your module?
04:40:45 <lightstep> it's not standard haskell, it's an extension. therefore the rules may change
04:41:10 <u1sf> "infixr 9 Either" -> parse error on input `Either'
04:41:26 <Lemmih> Try "infixr 9 `Either`"
04:41:56 <u1sf> same
04:42:21 <Philippa> tromp: it's exactly like that and the trick is to find a way to clearly let go of the remaining bindings to the list/tree
04:43:06 <tromp> i have no idea what is still referencing the old tree
04:43:10 <u1sf> I'm trying to use Either as a Union type see, but the associativity is wrong
04:43:56 <TheHunter> u1sf, you can't redefine the fixity of imported stuff.
04:44:10 <Philippa> tromp: most likely, the closure where it's created
04:44:21 <Philippa> the fact you don't /use/ the reference after that doesn't count if you still hold it
04:44:27 <u1sf> ok, can I do it with a type synonym?
04:44:34 <TheHunter> u1sf, how bout type a :+: b = Either a b
04:45:23 <musasabi> tromp: [(h,makeGameTree g) | (h,g) <- goodMoves game] ...
04:45:31 <musasabi> is one good candidate.
04:45:31 <u1sf> thanks TheHunter!
04:46:56 <musasabi> What is the best way to map between C constants and Haskell?
04:47:35 <lightstep> wrappers
04:48:15 <musasabi> using values for them appears to be the easiest way but that makes them awkward to use - using data Foo = Foo | Bar | Baz works but makes marshaling them awkward.
04:48:28 <tromp> but the recursive makeGameTree calls in there need to be lazy, musasabi
04:53:05 <Lemmih> musasabi: Use a tool which allows both methods with generated helper functions for accessing/marshalling.
05:00:36 <dblhelix> TheHunter, u1sf: beware that infix type constructors are not Haskell 98, i.e., you will need glasgow exts
05:12:36 <boegel> hey samc
05:12:51 <boegel> thank you for pointing out the layout flaws in my article
05:15:10 <integral> @type FileMode
05:15:12 <lambdabot> bzzt
05:15:23 <integral> @type System.Posix.Types.FileMode
05:15:24 <lambdabot> bzzt
05:16:03 <Lemmih> integral: You want the type of a type?
05:16:16 <integral> Lemmih: I did at the time ;-)
05:16:45 * integral isn't reading the uppercase first letter naturally yet
05:18:42 <samc> no problem, nice article
05:19:23 <boegel> samc: thanks :)
05:20:53 <boegel> hey bourbaki
05:21:17 <bourbaki> hey :)
05:25:57 <metaperl> I want to use a booleanguard instead of list pattern matching to filter this list but it is failing
05:25:59 <metaperl> dups = [ v | (v:_:_) <- group $ sort mylis ]
05:25:59 <metaperl> dup2 = [ v | ((length v) > 1) <- group $ sort mylis ]
05:26:27 <metaperl> the "dups =" line works, but the "dup2 = " line fails
05:27:04 <lightstep> metaperl, you don't bind in this case, so you need , instead of ->
05:27:10 <boegel> " ((length v) > 1) <- " this looks weird
05:27:16 <TheHunter> metaperl, dups2 = [ vs | vs <- group $ sort mylis, length vs > 1 ]
05:27:41 <TheHunter> but note that this is worse than dups because it has to determine the lenght of the list
05:27:57 <metaperl> aaaahhh.. good point
05:28:19 <TheHunter> the best thing would be dups3 = [ vs | vs@(_:_:_) <- group ... ]
05:29:01 <metaperl> but he wants the first element of the list
05:29:21 <metaperl> out of (a:b:c), a becomes part of the generated list
05:29:23 <boegel> metaperl, you could use 'not $ null vs' instead of 'length vs > 1'
05:29:45 <TheHunter> then dups is perfectly fine.
05:29:49 <boegel> oh, wait, that replaces 'length vs > 0'
05:29:51 <tromp> not $ null $ tail vs
05:29:52 <metaperl> no we dont want lists of length 1 and a list of length 1 is not null boegel
05:29:59 <boegel> tromp: thanks :)
05:30:07 <metaperl> ah
05:30:26 <TheHunter> noo, not . null $ drop 1 vs
05:35:46 * metaperl wonders if GHC is smart enough to interpret (length list > 1) as not . null drop 1 list
05:35:57 * metaperl wonders if GHC is smart enough to interpret (length list > 1) as not . null $ drop 1 list
05:35:59 <TheHunter> no, that's semantically different.
05:36:29 <lightstep> how are they different (modulo termination)?
05:36:39 <metaperl> but from a functional viewpoint, they return True/False in the same cases...
05:36:41 <tromp> if you consider length (0:0:undefined)
05:36:48 <TheHunter> lenght [1..] > 1 === _|_, not $ null $ drop  1 [1..] === True.
05:37:21 <metaperl> oh, some tricky edge cases
05:37:21 <ibid> lightstep: termination is significant
05:37:36 <lightstep> why?
05:37:48 <ibid> lightstep: because it's a semantic difference
05:38:19 <tromp> cause you may want to see if a possibly infinite list is null
05:38:19 <lightstep> haskell isn't strict, it should strive to return a result in a finite amount of time
05:39:04 <ibid> lightstep: haskell is non-strict, which means that you can ignore a bottom, but it does not mean that 2 == Bottom
05:39:48 <lightstep> i see the point now, but it still seems wrong
05:39:56 <TheHunter> lightstep, also, as soon as you consider exception handling, you can catch an error that is lurking in the list.
05:41:22 <lightstep> the standard doesn't specify order of evaluation of list operations
05:41:45 <lightstep> in map f [error "a", error "b"] it's unpredictable which will fail first
05:41:55 <Darius> lightstep: Just think of termination as any other "semantic" property.  The compiler shouldn't change it.
05:42:33 <Darius> lightstep: (re map example) That's why Haskell 98 does not allow recovery from exceptions.
05:42:43 <lightstep> is there a formal termination semantics from haskell?
05:42:47 <ibid> lightstep: wouldn't that just produce [f (error "a"), f (error "b")], in which case "which will fail first" is not an interesting question
05:43:03 <ibid> (it depends, of course, on which is forced first)
05:43:12 <Darius> lightstep: There is no formal semantics for modern Haskell that I know of.  There used to be one for an earlier version though.
05:43:15 <ibid> (and whether f is strict or not)
05:45:54 <Itkovian> Anybody willing to help with some darcs questions?
05:46:01 <ibid> i believe haskell is rather well specified through the translation to the kernel, which is essentially the standard lambda calculus
05:46:10 <ibid> Itkovian: #darcs is down the hall :)
05:46:23 <Itkovian> ibid: people down there are usually awfully quiet.
05:46:32 <ibid> Itkovian: not in my experience
05:46:46 <ibid> Itkovian: now just happens to be a quiet moment
05:46:54 <ibid> but ask, don't ask for permission to ask :)
05:46:59 <Itkovian> :-)
05:49:27 <ibid> so?
05:49:29 <ibid> ;)
05:49:41 <Darius> There's a saying that doesn't apply to this situation, that "It is easier to ask for forgiveness than permission"
05:50:08 <ibid> actually, it applies rather well:)
05:52:53 <Darius> ibid: One shouldn't "ask, rather than ask for permission to ask" based upon that reasoning
05:53:09 <ibid> Darius: how so?
05:54:00 <Darius> Well, extensionally, I guess -I- don't really care.  ibid: Not so much that that shouldn't be the reason, but that there are more sensible, rational reasons.
05:54:15 <Darius> At least for this medium
05:54:50 <ibid> i'm not following :)
05:55:06 <kzm> "Professor, may I ask a question?"  "You already did."
05:55:26 <Darius> ibid: Which part are you not following?
05:55:36 <kzm> "I mean, may I ask two questions?"   "You already did that, too"
05:55:45 <ibid> Darius: i follow the parts but not how they fit in :)
05:55:55 <ibid> "May I ask a question after this one?"
05:56:20 <Darius> kzm: It's even worse with the Americanism of using "can" for "may".
05:56:49 <kzm> "No, I think it's somebody else's turn now"
05:56:55 <kzm> (or something like that) :-)
05:57:07 <kzm> (sorry)
05:57:12 <ibid> :)
05:57:20 <kzm> Was there a Darcs question somewhere?
05:57:26 <Darius> ibid: Assuming the parts are the parts before and after "ibid:", the first is simply my statement that I'd prefer one just asking no matter what their motivation was.
05:57:57 * ibid is about to go play professor for a few hours
05:58:20 <kzm> BTW: how do I write a function with a polymorphic result?  (I.e. foo 1 gives a Float, foo 2 returns an Int)  Is it possible?
05:58:21 <Darius> Though I guess the motivation of the saying is appropriate if the question is horribly inappropriate.
05:58:33 <kzm> (not f :: a -> a)
05:58:37 <samc> Darius, it is the opposite
05:58:57 <Darius> kzm: You can't with that specification.
05:59:05 <ibid> kzm: in fp, we don't usually call that polymorphism :)
05:59:31 <lightstep> i'm sure that is oleg sets out to solve this, it'll work
05:59:33 <xerox> 'lo
05:59:34 <ibid> kzm: you can have the function return a type that you have defined like data FloatRes Float | IntRes Int
05:59:57 <kzm> What I want is to select a different data structure depending on circumstances.  I guess I could
06:00:04 <lightstep> kzm, you can make the function return an unspecified Num
06:00:08 <Darius> lightstep: Oh I'm sure you can do it with simple type hackery, but it would change the usage of the function.
06:00:29 <kzm> define "do_work :: DS d => d -> result", and have
06:00:37 <TheHunter> kzm, are all possible results in one type class?
06:00:52 <kzm> "main cond = if cond then do_work (make_ds1) else do_work (make_ds2)"
06:00:57 <kzm> TheHunter: yes
06:01:07 <samc> you can return an either an Int or Float
06:01:30 <TheHunter> then you might want existentials (if, for some reason Either Int Float is not enough)
06:01:34 <kzm> Where make_dsX makes different data structures member of DS.
06:02:00 <TheHunter> @wiki ExistentialTypes
06:02:01 <lambdabot> http://www.haskell.org/hawiki/ExistentialTypes
06:02:06 <kzm> I tried toying with forall, but I don't really grok it deeply enough, I guess.  (Or is that universals?)
06:02:42 <TheHunter> kzm, that are universals, but you can also implement existentials in terms of universals...
06:03:22 <TheHunter> exists a. f a =~= forall r. (forall a. f a -> r)
06:06:02 <Darius> exists a.F a = forall r.(forall a.f a -> r) -> r
06:07:02 <TheHunter> oh, of course, sorry.
06:22:33 <CosmicRay> does anyone have the tex sources from TMR issue 1 anywhere?
06:23:31 <samc> on LtU "...our favorites: SICP, CTM, EOPL etc." I know the first but what are the other two?
06:24:19 <lightstep> Essentials of Programming Languages (2nd ed., usually)
06:24:36 <Darius> CTM is Peter Van Roy's relatively new book Concepts Techniques and Models(?) of Programming Languages
06:24:41 <samc> thanks
06:25:13 <samc> hmm I do know ctm, in fact I've read some of it :)
06:25:14 <Darius> CTM was (is?) available freely online earlier, I don't think it is anymore.
06:25:15 <lightstep> yes, models
06:26:32 <Darius> Does any book match SICP in the number of generally accepted ways of referring to it (it's title, SICP, the Purple Book, the Wizard book )?
06:29:13 <musasabi> CosmicRay: shapr should have them.
06:29:45 <CosmicRay> musasabi: ok
06:29:46 <CosmicRay> thanks
06:36:22 <boegel> CosmicRay: why ?
06:36:36 <boegel> CosmicRay: I think Itkovian has 'em too
06:40:19 <CosmicRay> boegel: I want to try to make a smaller PDF
06:42:38 <boegel> CosmicRay: ? the pdf is a lot smaller already ?
06:42:51 <CosmicRay> oh?
06:43:01 <CosmicRay> what happened to it?
06:43:19 <CosmicRay> wow, it sure is.
06:43:27 <boegel> @wiki TheMonadReader_2fIssueOne
06:43:27 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne
06:43:56 <boegel> 352 kb, why do you want it smaller ?
06:44:05 <CosmicRay> boegel: it was 18MB yesterday.
06:44:10 <CosmicRay> I didn't know somebody got it smaller.
06:44:12 <boegel> Itkovian did quit a nice job on that yesterday
06:44:20 <CosmicRay> Itkovian: how exactly did you do that?
06:44:34 <CosmicRay> also the navigation links are much nicer.
06:44:46 <lightstep> is there a source cross-linker for haskell?
06:45:50 <boegel> aaah, Rammstein, gotta love 'em
06:46:22 * Darius hasn't listened to Rammstein in a long long while.
06:47:52 <boegel> Darius: you should ! Ich hab keine lust ! :p
06:49:56 <CosmicRay> boegel: ahh, Bach, gotta love 'em :-)
06:52:15 <boegel> CosmicRay: I know what you're saying, but everytime when I hear Rammstein, I can't keep still
06:52:57 <CosmicRay> boegel: same thing happens to me.  I reach for the power button to cut out the damn noise :-)
06:53:11 <boegel> hehe
06:53:21 <CosmicRay> boegel: course, I know plenty of people that have the same impluse when they hear the opera I like to listen to :-)
06:53:27 <boegel> you learn to appreciate such music if you listen to it enough
06:53:33 <boegel> there you go
06:55:19 * Darius usually goes for Bad Religion, Offspring, or System of a Down for (psychologically) driving music.
06:55:46 <boegel> Darius: SOAD ! I love 'em too
06:55:54 <boegel> I hope to see them live one day
06:56:17 <Darius> Of course, part of the energy comes from playing heavy fast crunching power chords.
06:56:53 * CosmicRay goes for mozart
06:56:54 <CosmicRay> or beethoven.
06:57:12 <boegel> Darius: doesn't matter where it comes from, it's great
06:57:17 <boegel> Darius: how do you like Korn ?
06:57:27 <Darius> Segovia performing Georg Frederic Handel's Sarabande in Dm is amazing.
06:57:33 <Darius> boegel: No
06:57:46 <boegel> Darius: why not ?
06:57:49 <CosmicRay> who is segovia?
06:57:52 <Itkovian> CosmicRay: how did I do what? the size reduction? I catted all the tex into a single file, edited it and there you are :-)
06:58:07 <CosmicRay> Itkovian: ahh.  that's exactly what I was planning to attempt.  excellent.
06:58:07 <boegel> tuomov: ?
06:58:13 <Darius> boegel: It's been a while since I've listened to them, but I just wasn't into it.
06:58:24 <Darius> Andres Segovia, -the- classical guitarist.
06:58:59 <boegel> Darius: I think they're great, but it's a different kind of music from the other ones
06:59:27 <CosmicRay> dammit, die aix, die die die
06:59:52 <Itkovian> yeah!
06:59:57 <CosmicRay> I need a suggestion for operating system removal music :-)
07:00:10 <Itkovian> say CosmicRay, any idea on how to get a Power4 running faster, cos this disk is _slooooooow_
07:00:22 <CosmicRay> Itkovian: not really
07:00:38 <Darius> CosmicRay: Ride of the Valkyrie?
07:00:39 <CosmicRay> Itkovian: I'm still fairly new to the aix world (and the accompanying hardware)
07:00:43 <boegel> Itkovian: give it better food ?
07:00:46 <CosmicRay> Darius: nice.
07:01:08 <CosmicRay> Darius: with axes crashing into hard disks at appropriate climactic moments.  yes. :-)
07:02:47 <Itkovian> CosmicRay: so are we.
07:06:24 <CosmicRay> Itkovian: we are on power5 here (aix 5.1L)
07:06:36 <CosmicRay> Itkovian: which, I think, it half my trouble.  not many are using 64-bit aix, I guess
07:07:02 <Itkovian> well, we are, but boy, it's bloody slow
07:07:20 <Itkovian> we only have one machine, mainly for JikesRVM development work.
07:19:54 <boegel> hi vdrab , bye vdrab , hi vdrab
07:28:00 <nlv11757_> how exactly does the ShowS type work?
07:28:30 <boegel> @info ShowS
07:28:32 <lambdabot> -- ShowS is a type constructor
07:28:32 <lambdabot> type ShowS = String -> String
07:28:38 <nlv11757_> i know
07:28:44 <boegel> what about it then ?
07:28:51 <nlv11757_> but what does it mean when something if of type ShowS
07:28:51 <boegel> @type show
07:28:52 <lambdabot> show :: forall a. (Show a) => a -> String
07:29:10 <nlv11757_> i also know show
07:29:21 <boegel> it means you can represent it as a String ? (I think)
07:29:29 <boegel> @info Show
07:29:31 <lambdabot> -- Show is a class
07:29:31 <lambdabot> class Show a where {
07:29:31 <lambdabot>     showsPrec :: Int -> a -> String -> String {- has default method -};
07:29:31 <lambdabot>     show :: a -> String {- has default method -};
07:29:31 <lambdabot>     showList :: [a] -> String -> String {- has default method -};
07:29:32 <lambdabot>     }
07:29:43 <boegel> I'm not sure though
07:29:49 <nlv11757_> ok, im using this pretty printer library that output something of type ShowS, thus String -> String.....
07:30:04 <nlv11757_> so its not a string representation of the thing im pretty printing...but what is it exactly
07:30:28 <polli> nlv11757_: isn't it a function?
07:30:30 * polli checks
07:30:34 <nlv11757_> it is
07:30:38 <nlv11757_> String -> String
07:31:01 <nlv11757_> but what are the semantics of such a function representing a pretty printed document?
07:31:11 <boegel> does this help ? http://www.zvon.org/other/haskell/Outputprelude/shows_f.html
07:31:38 <boegel> it means it needs another string before it can give you the final result
07:31:38 <bringert> the string argument it takes is the rest of the output
07:31:51 <boegel> f :: a -> ShowS
07:32:12 <boegel> f a outputs "a <output of f>"
07:32:12 <bringert> apply it to en empty string if you just want a string representation of the thing you've pretty printed
07:32:28 <nlv11757_> im confused...the pretty printed document needs a string before it gives me the pretty printed document....
07:32:32 <nlv11757_> why is that?
07:32:48 <bringert> it's a trick to avoid left-associated concatenations
07:32:54 <nlv11757_> is that handy for sequencing?
07:32:55 <boegel> maybe because that way it allows you to add something you might need to?
07:33:10 <bringert> with ShowS you use function compositions as concatenation
07:33:36 <nlv11757_> ok then it makes sense
07:33:42 <nlv11757_> folding ShowS elements
07:33:44 <nlv11757_> thanx
07:33:46 <bringert> if you used plain strings and ++ you can get quadratic behaviour with left-associated concatenation sequences
07:33:59 <nlv11757_> ow of course, this is accumulator right?
07:34:24 <Darius> nlv11757_: The Gentle Introduction on haskell.org specifically goes over ShowS.
07:35:15 <nlv11757_> these gentle introductions usually dont present any new info, that's why i skipped it beforehand :)
07:36:56 <Darius> Most people don't consider the Gentle Introduction very gentle.  At any rate, it's reasonably comprehensive for its size.
07:46:58 <tromp> i may have found the cause of the space leak
07:47:15 <tromp> actually it looks like a bug in the ghc runtime
07:48:38 <tromp> if u allocate lots of modifiable arrays, then something is kept for each one
07:48:54 <tromp> no matter if you never use the arrays in the first place
07:59:19 <musasabi> why would you allocate arrays you won't use?
07:59:48 <tromp> to demonstrate a space leak?!
08:01:14 <Itkovian> I'm off ....
08:05:38 <musasabi> tromp: I get constant space usage with creating IOUArrays in a loop
08:06:05 <tromp> try this one:
08:06:06 <tromp> import Control.Monad
08:06:06 <tromp> import Data.Array.IO
08:06:06 <tromp> import Data.Array.MArray
08:06:06 <tromp>                                                                                 
08:06:07 <tromp> loop 0 = return 0
08:06:09 <tromp> loop (n+1) = do
08:06:11 <tromp>   bla <- newArray_ (0,1) :: IO (IOUArray Int Int)
08:06:13 <tromp>   x <- loop n
08:06:15 <tromp>   return x
08:06:17 <tromp>                                                                                 
08:06:19 <tromp> main = do x <- loop 10000000
08:06:21 <tromp>           print x
08:06:29 <musasabi> this works:
08:06:30 <musasabi> import Data.Array.IO
08:06:30 <musasabi> arr :: IO (IOUArray Int Int)
08:06:30 <musasabi> arr = newArray (0,10000) 0
08:06:31 <musasabi> main = sequence_ (replicate 100000 arr) >> putStrLn "done"
08:06:48 <tromp> i know
08:06:53 <tromp> but try mine
08:07:07 <musasabi> tromp: that does not work because loop is not tail-recursive.
08:07:14 <tromp> oops, right
08:08:23 <tromp> let me try to simulate tree behaviour
08:09:15 <lightstep> why is IO not defined as ST RealWorld in GHC?
08:10:02 <musasabi> lightstep: newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
08:10:26 <musasabi> but that is just an implementation detail.
08:11:35 <lightstep> yeah, and ST RealWorld is the same, but as another newtype. it seems like an excessive duplication of entities
08:18:01 <musasabi> Has anyone gotten GHC to work on opendarwin?
08:23:10 <nlv11757_> swiert: are you present for an uuag question?
08:24:18 <swiert> nlv11757_: sure
08:25:15 <nlv11757_> i should probably do it pm right?
08:25:28 <swiert> fine
08:25:47 <Lemmih> What about the rest of us?
08:37:26 <tromp> definition of deleteBy looks funny
08:37:45 <tromp> deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
08:37:45 <tromp> The deleteBy function behaves like delete, but takes a user-supplied equality predicate.
08:38:06 <tromp> why doesn't it simply take a predicate and a list, instead of 3 arguments?
08:39:16 <Philippa_> because then it'd be filter?
08:39:39 <nlv11757_> the equality function is general for all elements of type a, the element to delete is a *specific* element of that type
08:39:50 <tromp> no, it only deletes first occurance
08:41:03 <nlv11757_> you would skip the second argument?
08:41:35 <tromp> i wld define deletePred (a->Bool) -> [a] -> [a]
08:41:40 <Philippa_> yeah, that'd make sense
08:41:50 <tromp> which deletes the first element satisfying the pred
08:42:22 <nlv11757_> it's less general
08:42:22 <tromp> if you have that, then you can take deleteBy myeql x = deletePred (myeql x)
08:42:35 <tromp> so no, it's not less general
08:43:02 <tromp> if anything, it's more general
08:43:11 <nlv11757_> it's less funky
08:43:33 <Philippa_> less funked, too
08:44:12 <tromp> although you can also say deletePred pred = deleteBy (const pred) undefined
08:44:30 <tromp> which is definitely weirder than the other way:(
08:44:36 <nlv11757_> there you go :P
08:45:02 <tromp> so having only the simpler deletePred makes more sense:)
08:48:00 <nlv11757_> noooo, with power comes responsibility :P
08:59:22 <kosmikus> @seen Itkovian
08:59:23 <lambdabot> I saw Itkovian leaving #darcs 58 minutes 4 seconds ago.
09:01:26 <nlv11757_> @seen nlv11757_
09:01:27 <lambdabot> nlv11757_ is in #haskell.
09:01:35 <nlv11757_> :O
09:08:38 <boegel> kosmikus: why do you need Itkovian?
09:12:05 <boegel> @type flatten
09:12:06 <lambdabot> bzzt
09:12:54 <boegel_> @index flatten
09:12:55 <lambdabot> Data.Tree
09:13:21 <boegel_> @type Data.Tree.flatten
09:13:22 <lambdabot> Data.Tree.flatten :: forall a. Data.Tree.Tree a -> [a]
09:13:33 <boegel_> hmm, isn't there a 'flatten' function for lists ?
09:13:41 <boegel_> is in [[a]] -> [a] or so ?
09:13:45 <polli> boegel_: concat
09:14:07 <boegel_> @type concat
09:14:09 <lambdabot> concat :: forall a. [[a]] -> [a]
09:14:11 <TheHunter> aka join, msum.
09:14:20 <boegel_> polli: thx :)
09:14:29 <boegel_> @type join
09:14:30 <lambdabot> bzzt
09:14:35 <boegel_> @index join
09:14:36 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
09:14:36 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
09:14:36 <lambdabot> State,Control.Monad.Writer,Monad
09:14:50 <boegel_> TheHunter: what's the difference between them ?
09:15:01 <Darius> @type Control.Monad.join
09:15:02 <TheHunter> they're more general:
09:15:02 <lambdabot> Control.Monad.join :: forall a m. (Monad m) => m (m a) -> m a
09:15:06 <Darius> @type Control.Monad.msum
09:15:06 <TheHunter> @type Monad.msum
09:15:08 <lambdabot> Control.Monad.msum :: forall a m.
09:15:08 <lambdabot> 		      (Control.Monad.MonadPlus m) =>
09:15:08 <lambdabot> 		      [m a] -> m a
09:15:09 <lambdabot> Monad.msum :: forall a m.
09:15:09 <lambdabot> 	      (Control.Monad.MonadPlus m) =>
09:15:09 <lambdabot> 	      [m a] -> m a
09:15:15 <tromp> hi TheHunter
09:15:30 <TheHunter> hi tromp, how's connect4 going?
09:15:41 <tromp> still tracking down the leak:(
09:15:45 <boegel_> more general ? what's wrong with concat then ?
09:15:58 <tromp> just been deleting source while it keeps leaking
09:16:05 <tromp> it's down to this:
09:16:08 <Darius> join and msum just happen to specialize to concat in the list instances.
09:16:13 <tromp> alphabeta = negamax where
09:16:13 <tromp>   negamax GTLoss = return loss
09:16:13 <tromp>   negamax GTDraw = return draw
09:16:13 <tromp>   negamax (GTBranch [(_,gt)]) = liftM negate $ negamax gt
09:16:13 <tromp>   negamax (GTBranch movelist) = negaloop movelist
09:16:15 <tromp>   negaloop rest = if null rest then return 0 else do
09:16:17 <tromp>     v <- liftM negate $ negamax $ snd (head rest)
09:16:19 <tromp>     negaloop (tail rest)
09:16:48 <Darius> tromp: Why don't you use pattern matching in negaloop?
09:17:21 <tromp> that's my next change
09:17:36 <tromp>   negaloop [] = return 0
09:17:36 <tromp>   negaloop ((_,gt):gts) = do
09:17:36 <tromp>     v <- liftM negate $ negamax gt
09:17:36 <tromp>     negaloop gts
09:17:52 <tromp> that stops the leak
09:18:38 <tromp> can't say i understand why the former still leaks
09:19:07 <Darius> Why do you have 'v <- liftM negate $ negamax gt' if you don't use 'v'.
09:19:45 <tromp> cause i've just been deleting stuff to find the leak
09:19:57 <tromp> the code makes no more sense:(
09:20:42 <Darius> tromp: Are you looking for a stack leak or a memory leak?
09:20:49 <tromp> heap leak
09:21:03 <Darius> tromp: Have you tried profiling?
09:22:03 <tromp> yep
09:22:10 <Darius> And?
09:22:30 <tromp> shows that gametree is retained after having been searched
09:23:00 <tromp> doesn't tell you why it's being retained though
09:24:21 <Darius> It should point at what is retaining it.
09:25:17 <tromp> can you explain why pattern matching works while head/tail doesnt?
09:26:29 <Darius> tromp: It will force things earlier.
09:28:52 <tromp> can you predict if the following will leak:
09:28:53 <tromp>     let negaloop gs = if null gs then return 0 else do
09:28:53 <tromp>          let ((_,gt):gts) = gs
09:28:53 <tromp>          v <- negamax gt
09:28:53 <tromp>          negaloop gts
09:29:25 <Darius> patterns bound with let are lazy
09:30:09 <tromp> so you expect that one still leaks?
09:30:59 <Darius> But in any version, negamax immediately forces it's argument so they shouldn't really be different (modulo possible different compiler optimizations)
09:31:26 <Darius> tromp: But yes, the last version should be pretty much the same as the first.
09:31:59 <tromp> the last one doesn't leak
09:32:20 <tromp> now i'll try with tail gs instead of gts
09:32:28 <tromp> that leaks
09:33:32 <tromp> so it still has a reference to gs in tail gs
09:33:40 <tromp> that stops it from releasing head gs
09:34:54 <tromp> now i have to figure out how to fix my original program...
09:35:08 <nlv11757_> generate a patch with diff :P
09:35:13 <Darius> Well, if it made a thunk it would have that reference.  However, both negaloop and negamax are strict so either the compiler will not build the thunk or it will immediately force it, either way the reference to gs will be removed except...
09:35:37 <Darius> GHC might possibly be using a non-updateable thunk in some cases in which case it wouldn't.
09:36:15 <Darius> tromp: If you compile to core I think GHC marks updateable and non-updateable thunks and that might be the issue.
09:36:35 <Darius> At any rate, looking at the differences between them in core should be helpful to see what is going on.
09:37:21 <tromp> that is too deep for my taste
09:39:15 <Darius> That's the problem with memory leaks in garbage collected languages and especially lazy languages; the behavior is dependent on implementation details.
09:40:03 <Darius> tromp: Try retainer profiling on a leaking and non-leaking version and see what most changes.
09:42:41 <tromp> i feel more like trying to fix the real thing. anxious to see it work:)
09:44:42 <tromp> but i can send you the source of the cutdown version if you want to investigate
09:45:04 <Darius> tromp: Helping the strictness analyzer is probably the best thing to do in that case beyond other (somewhat) obvious things.
09:45:17 <Darius> tromp: Not right now, but maybe later.
09:49:49 <musasabi> tromp: "foo x = if null x then y else z" is lazy.. Use pattern matching.
09:50:33 <Igloo> It shouldn't be lazy
09:50:40 <tromp> yes, i have to get rid of the movelist reference earlier
09:50:54 <Igloo> Assuming by lazy you mean non-strict in x
09:53:53 <musasabi> doesn't that just create a thunk?
09:54:46 <tromp> afk to home. thx for the hints, guys
09:55:58 <Igloo> It creates a thunk in the same circumstances as a pattern matching implementation would
09:56:40 <Igloo> The pattern match will only be done if you need to know the RHS. If you need to know the RHS in this case then null x needs to be evaluated
10:00:40 <alexj> musasabi: I want to thank you for the discussion a few days ago.  As a result I cleaned up the ACID code to make sure there is a total order on callbacks.
10:01:16 <alexj> not published to the server yet.  but framework in place.
10:02:55 <Lemmih> @seen shapr
10:02:56 <lambdabot> I saw shapr leaving #webwitches 2 hours 19 minutes 36 seconds ago.
10:04:59 <musasabi> alexj: nice, I look forward to seing it when you publish the next version.
10:19:20 <CosmicRay> yo mr. ninja.
10:19:26 <Lemmih> G'morning, SyntaxNinja.
10:20:12 * araujo waves
10:22:23 <SyntaxNinja> hiya
11:26:58 <araujo> quiet.
11:29:16 <Lemmih> araujo: So, what are up to? Working on any spiffy Haskell projects?
11:40:40 <araujo> Hello Lemmih
11:40:55 <araujo> Lemmih, im cooperating at the moment with the haskell packages in gentoo
11:41:10 <araujo> Lemmih, patching at the moment hsshellscript btw
11:41:16 <metaperl_> i'm grateful for whoever did the Debian ones
11:41:34 <metaperl_> I was able to get ghci, parsec and the works from the Debian pkgs
11:41:45 <araujo> metaperl, with 6.4? 8)
11:41:55 <metaperl_> ghc6... I doubt 6.4
11:42:02 <araujo> Yes, i know 8)
11:42:05 <metaperl_> but I'm a newbie. I dont need all the greatest features
11:42:23 <metaperl_> but I am working on the Perl6 compilerproject so I might need an upgrade
11:46:38 <bringert> what's the story with that? you writing a perl6 compiler i haskell?
11:47:50 <araujo> Lemmih, btw, are you using ghc6.4?
11:49:04 <Oejet> bringert: pugscode.org
11:50:52 <musasabi> araujo: a cabal eclass would be nice...
11:51:19 <Si\> has anyone done any work on extensible Union types?
11:51:46 <PerlJam> bringert: essentially.
11:52:35 <bringert> what's the regular perl interpreter written in?
11:52:37 <bringert> perl?
11:52:43 <Lemmih> araujo: Yes.
11:53:11 <CosmicRay> bringert: C (for perl5)
11:54:09 <Lemmih> I'm dependent on TH so I don't have a choice.
11:54:21 <bringert> is there such a thing as an official perl6 interpreter?
11:54:41 <bringert> or at least de-facto standard? or is that you guys?
11:55:45 <PerlJam> bringert: There is no official perl6 anything yet (except official language designer (Larry Wall))
11:56:10 <bringert> so the language is still a moving target?
11:57:25 <bringert> I always thought perl would be a pain to implement (at least implement correctly). what do you guys think?
11:57:57 <PerlJam> bringert: The idea for bringing perl6 into existence is that we'll first implement something that understands the new perl6 "rule" syntax, then implement perl6 in perl6.  Pugs doesn't understand rules yet (but it understands a bunch of the rest of the language).  PGE is perl6 rules implemented in C and the "official" bootstrap so far.
11:58:26 <PerlJam> bringert: perl5 is a pain.  perl6 will be less so.
11:58:34 <bringert> so the "rule" stuff is a simple core language?
11:58:44 <bringert> or simpler anyway :-)
11:58:52 <PerlJam> bringert: rules are like a combination of grammars and regular expressions.
11:59:31 <bringert> and that's enough to bootstrap?
11:59:59 <PerlJam> yep.  We output parrot bytecode based on the "rules" parsing.
12:00:12 <PerlJam> or maybe even just parrot asm
12:00:29 <bringert> so there are semantic actions in rules?
12:00:30 <PerlJam> (there may be a couple of bootstraps before we're to the level "official perl6 implementation")
12:01:13 <PerlJam> bringert: http://dev.perl.org/perl6/synopsis/S05.html
12:01:18 <bringert> so pugs will not implement full perl6 in haskell?
12:01:25 <PerlJam> That'll be an easier read if you understand perl :)
12:01:47 <PerlJam> bringert: My hope is that pugs becomes the reference implementation if nothing else.
12:02:06 <PerlJam> bringert: Currently pugs does not implement all of perl6 but that's not to say it won't.
12:02:11 <PerlJam> :-)
12:02:35 <bringert> I know some perl5, but I'm a bit rusty
12:02:59 <bringert> so rules can have arbitrary perl expressions in them?
12:04:12 <PerlJam> bringert: sure. (for the bootstrap, we'll only implement a subset.  What's great is that pugs already has a reasonably powerful subset implemented)
12:04:31 <PerlJam> If you're really interested, read the docs at
12:04:35 <PerlJam> http://dev.perl.org/perl6/
12:05:21 <PerlJam> The Apocalypses are Larry's design docs, Exegeses are explanations of the new features, Synopses are quick overviews.
12:05:41 <PerlJam> And there's a link to pugs at the bottom of the page somewhere
12:05:45 <bringert> I guess I should try to keep up with perl6
12:06:00 * PerlJam has to go now 
12:06:04 * PerlJam *poof* &
12:06:37 <CosmicRay> bringert: yeah, isn't this an odd feeling? :-)
12:06:43 <CosmicRay> perl6 and haskell folks keeping an eye on each otehr
12:06:47 <bringert> :-)
12:06:51 <bringert> perl5 had map
12:06:56 <bringert> or has
12:07:04 <bringert> guess it's not dead
12:07:28 <Oejet> Hey, who would have thought that Apple would base their OS on BSD? :-P
12:07:52 <Muad_Dibber> what is perl6 going to look like?
12:08:00 <CosmicRay> Oejet: or that bill gates would be knighted :-)
12:08:04 <bringert> maybe we can get someone to write a haskell interpreter i perl6
12:08:13 <Muad_Dibber> like an object oriented perl5?
12:08:18 <Muad_Dibber> or a functional perl5?
12:08:19 <bringert> and get some nice pinog-pong bootstrapping going
12:08:30 <bringert> both afaict
12:08:58 <Oejet> bringert: Whoa, a meta mutually recursive circular interpretter.
12:09:03 <CosmicRay> hah
12:09:10 <Muad_Dibber> but we do have an object oriented perl already :P
12:09:14 <Muad_Dibber> its called python
12:09:15 <Muad_Dibber> :P
12:09:27 <Oejet> CosmicRay: Bah, anyone with money can be knighted in GB.
12:09:47 <CosmicRay> yeah, but geez.  doesn't the throne have *any* sense anymore?
12:10:15 <CosmicRay> "Here, you helped crush hundreds of companies and hold back innovation for years.  Great job."
12:10:20 <wagle> alternating tower of meta-circular interpreters
12:11:06 <wagle> just need to recognize tail-reflection
12:11:24 <Oejet> wagle: Abelson and Sussmann would love it!
12:11:49 <araujo> CosmicRay, the throne never has common sense imho
12:11:55 <araujo> s/has/hd
12:11:56 <Oejet> Anyone seen the taping of their lectures?
12:11:59 <araujo> had*
12:12:13 <CosmicRay> araujo: well they did manage to avoid getting invaded since 1066 :-)
12:12:23 <CosmicRay> araujo: otoh, they lost france to the french :-)
12:12:55 <CosmicRay> the us can't claim to avoid having been invaded since 1066..  hell, we were invaded by the british in 1812 :-)
12:13:03 <araujo> CosmicRay, invasors are required to avoid invasions 8)
12:15:14 <wagle> Oejet: Smith 82  Brian C. Smith: Reflection and Semantics in a Procedural Language, Ph.D. thesis, MIT/- LCS/TR-272, Cambridge, Massachusetts (January 1982)
12:15:22 <Muad_Dibber> he
12:15:22 <araujo> They should employ those castles and stuff to help people.. similar to the vatican
12:15:28 <Muad_Dibber> who would want to invade england?
12:15:31 <wagle> cant remember who his advisors were
12:15:43 <araujo> Muad_Dibber, haha
12:15:52 <CosmicRay> Muad_Dibber: well, the vikings and the scottish, mostly :-)
12:16:03 <Muad_Dibber> imagine you would be left with that shitty island :P
12:16:12 <Muad_Dibber> CosmicRay : those both classify as dumb barbarians :P
12:16:15 <CosmicRay> heh
12:16:27 <CosmicRay> and of course the germans.
12:16:32 <CosmicRay> (where the saxons came from)
12:16:58 <CosmicRay> I think also maybe some danish?
12:17:09 <CosmicRay> or maybe that's just where the vikings came from back then
12:18:35 <wagle> mmmm.. lightweight, but maybe interesting discussion on reflection: http://www2.parc.com/csl/groups/sda/projects/reflection96/docs/malenfant/ref96/node3.html
12:18:40 <araujo> i don't think kingdoms were/are good... you can't point to any kingdom in the mankind history where people were treated as decent human beings
12:18:54 <araujo> kingdoms == "The king and the rest"
12:18:59 <CosmicRay> araujo: I'm not arguing that they were good
12:19:07 <araujo> CosmicRay, yes i know
12:19:10 <wagle> when were people treated as decent human beings, ever?
12:19:13 <araujo> it was just my comment
12:19:14 <CosmicRay> oh, and of course there were the romans in england.
12:20:18 <araujo> wagle, we still have many problems.. but i wouldn't like to get back to the kingdom area, would you?
12:21:13 <Muad_Dibber> i would
12:21:18 <Muad_Dibber> it seems nice to me to be a king :)
12:21:28 <araujo> At least in this area i got less chances of being burned for expressing my ideas
12:22:35 <CosmicRay> araujo: perhaps "in this time" would be more accurate
12:22:47 <CosmicRay> since you stood a fair chance of being burned for your ideas in most areas in the past
12:22:48 <Muad_Dibber> right, you like Lisp? Fine, we burn you :P
12:22:57 <CosmicRay> heh
12:23:36 <araujo> haha
12:24:14 <bringert> the Royal Institute of Technology in Stockholm gave Bill Gates an honorary phd i CS, iirc
12:24:25 <CosmicRay> ugh
12:24:25 <bringert> at least they should know better
12:24:27 <CosmicRay> that's even worse
12:24:34 <CosmicRay> the guy wrote a BASIC interpreter
12:24:37 <bringert> but, of course, they're not Chalmers
12:24:41 <CosmicRay> 20 fscking years after it had been done before
12:24:52 <CosmicRay> I don't think he's coded since
12:24:54 <araujo> Geez... what is this?.. why we just don't name this the "Bill Gates week" and we save all the protocol
12:25:58 <bringert> well, the phd thing was 3 yrs ago
12:26:00 <wilx> C'mon, you deny him huge influence on whole IT industry.
12:26:07 <bringert> hehe
12:26:11 <bringert> influence sure
12:26:13 <CosmicRay> wilx: that's MIS, not CS!
12:26:39 <wilx> Anyway.
12:26:45 <wilx> I just wanted to ask something.
12:26:53 <CosmicRay> his influence on computer science has been mostly negative, for as much as it exists, imho
12:26:58 <araujo> yes
12:27:00 <wilx> Any examples of how to use Data.Array.ST arrays?
12:27:14 <CosmicRay> because now we have a whole generation of people that think they're smart computer scientists because they can write something in vb
12:27:22 <wilx> :)
12:27:48 <bringert> I've had a couple of those when trying to teach
12:28:24 <bringert> since they already are so cool, they think there's nothing new to learn
12:28:32 <araujo> haha
12:28:41 <araujo> That is sad imho
12:29:02 <araujo> I sometimes need to spend hours explaining to the people that there exist another OSes
12:29:49 <araujo> After you explain all the <insert os here> stuff, they ask "And.. what version of windows do i need to run that?"
12:29:58 <bringert> :-)
12:30:01 <bringert> let's try not get into the whole "bashing clueless people" thing though
12:30:04 <bringert> takes forever
12:31:00 <bringert> that's what nights in the pub are for
12:31:07 <wilx> test :: STArray () Int Int
12:31:07 <wilx> test = newListArray (0, 5) init
12:31:08 <bringert> or do I hang out in the wrong places?
12:31:23 <wilx> init is a list with initial values.
12:31:36 <wilx> But the signature doesn't seem to be what GHCi expects.
12:31:40 <wilx> What am I doing wrong?
12:32:02 <Oejet> araujo: I think Frederik VII of Denmark was a good king.  Even signed the constitution in June 5 1849.
12:32:04 <Lemmih> @index newListArray
12:32:04 <lambdabot> Data.Array.Base,Data.Array.IO,Data.Array.MArray,Data.Array.ST,Data.Array
12:32:04 <lambdabot> Storable
12:32:43 <wilx> Yeah, I have been staring at the docs of these modules over and over but I do not get it.
12:32:46 <araujo> Oejet, sorry, i didn't mean to generalize really, i bet there were a minority of decent kings out there
12:33:01 <Oejet> araujo: lol.
12:33:07 <araujo> 8)
12:33:42 <araujo> You know, that kind of people that at least need a good excuse to burn you
12:34:11 <bringert> the current swedish king is at least not indecent
12:34:34 <bringert> hmm, indecent is not a antonym for all senses of decent
12:35:01 <wilx> Well, they cannot be indecent.
12:35:16 <Oejet> bringert: Our king is strictly better than your king.
12:35:18 <CosmicRay> wilx: charles sure was, and he's not even king yet :-)
12:35:18 <wilx> That is about the last thing kings and queens in Europe have left.
12:35:23 <Lemmih> @index STArray
12:35:23 <lambdabot> Data.Array.ST,GHC.Arr,GHC.Arr
12:35:29 <CosmicRay> wilx: being indecent? :-)
12:35:38 <bringert> Oejet: I thought you had a queen?
12:35:39 <wilx> The decency :)
12:36:07 <Oejet> bringert: Hence the statement is true.
12:36:32 <bringert> Oejet: well, I'm not sure all semanticians would agree
12:37:26 <jhunZoa> is there a function which removes all double entries in a list?
12:37:34 <bringert> @type nub
12:37:36 <lambdabot> bzzt
12:37:39 <bringert> @type List.nub
12:37:41 <lambdabot> List.nub :: forall a. (Eq a) => [a] -> [a]
12:37:54 <jhunZoa> ah ok thx
12:37:57 <rjbs> what's the name "nub" supposed to suggest?
12:38:17 <wilx> Core, what is important :)
12:38:54 <rjbs> odd
12:38:56 <Oejet> rjbs: No dUBlicates.
12:39:05 <Oejet> rjbs: Although just my interpretation.
12:39:05 <rjbs> Oejet: nice
12:39:06 <wilx> @dict nub
12:39:06 <lambdabot> Supported dictionary-lookup commands:
12:39:06 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon
12:39:06 <lambdabot> @lojban @prelude @vera @web1913 @wn @world02
12:39:06 <lambdabot> Use "@dict-help [cmd...]" for more.
12:39:07 <Lemmih> haha.
12:39:19 <wilx> @all-dict nub
12:39:19 <lambdabot> Sorry, I don't know the command "all-dict", try "lambdabot: @listcommands
12:39:25 <wilx> @all-dicts nub
12:39:37 <bacorinho> hi ppl...
12:39:41 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
12:39:41 <lambdabot> Nub \Nub\, v. t. [Cf. {Knob}.]
12:39:41 <lambdabot>    To push; to nudge; also, to beckon. [Prov. Eng.]
12:39:42 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
12:39:44 <lambdabot> Nub \Nub\, n.
12:39:46 <lambdabot>    A jag, or snag; a knob; a protuberance; also, the point or
12:39:48 <lambdabot>    gist, as of a story. [Colloq.]
12:39:50 <lambdabot> [13 @more lines]
12:39:52 <bringert> Oejet: I guess you mean (!exists x. current_king_of_denmark(x) and (forall y. current_king_of_sweden(y) and better_than(x,y)))))
12:39:54 <rjbs> oh, jeez.  THAT WAS NOT NECESSARY.
12:39:54 <wilx> @wb1913 nub
12:39:54 <lambdabot> Sorry, I don't know the command "wb1913", try "lambdabot: @listcommands
12:40:02 <rjbs> I know what the word "nub" means.
12:40:03 <wilx> @web1913 nub
12:40:05 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
12:40:05 <lambdabot> Nub \Nub\, v. t. [Cf. {Knob}.]
12:40:05 <lambdabot>    To push; to nudge; also, to beckon. [Prov. Eng.]
12:40:05 <bacorinho> this might not be the right # to ask, but does any one know of a translator from haskell to some other language ?
12:40:06 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
12:40:08 <lambdabot> Nub \Nub\, n.
12:40:10 <lambdabot>    A jag, or snag; a knob; a protuberance; also, the point or
12:40:12 <lambdabot>    gist, as of a story. [Colloq.]
12:40:12 <rjbs> Oh, fuck this.
12:40:23 <wilx> Ooops.
12:40:31 <wilx> I guess I scared him off :/
12:40:36 <jhunZoa> bah i cant use nub
12:40:48 <bringert> why not?
12:40:56 <jhunZoa> my compiler doesnt recognize
12:41:06 <bringert> import Data.List
12:41:08 <wilx> Did you import the List module?
12:41:16 <jhunZoa> List is imported ye
12:41:27 <wilx> What compiler/interpreter?
12:41:32 <jhunZoa> helium
12:41:37 <jhunZoa> there is only nubBy
12:41:42 <jhunZoa> @type nubBy
12:41:43 <lambdabot> bzzt
12:41:47 <bringert> weird
12:41:55 <bringert> well nub = nubBy (==)
12:41:57 <wilx> @type Data.List.nubBy
12:41:59 <lambdabot> Data.List.nubBy :: forall a. (a -> a -> Bool) -> [a] -> [a]
12:42:14 <jhunZoa> whats the defenition of nub?
12:42:18 <SyntaxNinja> @type Data.List.nubBy (==)
12:42:20 <lambdabot> Data.List.nubBy (==) :: forall a. (Eq a) => [a] -> [a]
12:42:44 <Lemmih> bacorinho: Why would you want that?
12:42:47 <jhunZoa> thats nub?
12:43:24 <jhunZoa> ah ye i see
12:48:09 <bacorinho> i have so fix some code from an online game (yes that should been asked 1000's of times in this #) and i have no time to learn another language
12:48:47 <bacorinho> this haskell stuff seems a bit complicated to me...
12:49:05 <Lemmih> bacorinho: Then just compile it to C with GHC.
12:49:48 <bringert> bacorinho: you want to edit the generated code, right?
12:50:10 <bacorinho> Lemmih: my problem is that this stuff doesn't even load (i'm using hugs and when i enter :load filename it gives some error)
12:50:22 <bringert> did you try ghci?
12:50:24 <bacorinho> i've managed to fix one of them (quiet obvious)
12:50:34 <bringert> it might be using some extension
12:50:57 <Lemmih> The easiest way of fixing Haskell code is to learn Haskell first.
12:51:45 <bringert> bacorinho: I agree with Lemmih, don't think you can hope for translation into human-readable code in some other language
12:52:05 <bringert> maybe if the other language is also a lazy functional language
12:52:07 <bacorinho> yup, that's it....i should learn it first, but beside of having no time for that...i don't really see any benefit of learning it...
12:52:16 <bringert> hehe
12:52:34 <bringert> guess that's not the most popular opinion around here
12:52:49 <bringert> anyway, I see one immediate benefit: solving your problem
12:53:08 <bacorinho> humm...you r right....anyway i wouldn't be able to translate it 'cause it has bugs inside which prevent it from compiling...
12:53:12 <bacorinho> syntax errors...
12:53:32 <bringert> are you sure they are errors, and not unrecognized language extensions?
12:53:35 <Lemmih> Compiling it to C was actually a joke on my part.
12:53:37 <bacorinho> a little time to think, sometimes helprs...
12:53:40 <bacorinho> yup....
12:53:52 <bacorinho> bringert: they are syntax errors....
12:53:55 <bringert> which in a sense is an error, from the interpreter's point of view
12:54:03 <bringert> some extensions are syntactic
12:54:10 <bringert> such as pattern guards
12:54:33 <bringert> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
12:54:59 <bacorinho> i changed this sum [product (1..4), product (2..4), 1]) to this sum [product [1..4], product [2..4], 1]), cause every text i've seen about haskell uses [ for product and not (
12:55:06 <bacorinho> and it worked on this line
12:55:26 <bringert> that sounds right
12:55:50 <bringert> so, someone gave you code that doesn't parse to fix?
12:55:58 <bringert> has it ever worked?
12:56:05 <bacorinho> now i get this.... ERROR "C:\upyours.hs":25 - Last generator in do {...} must be an expression
12:56:15 <bacorinho> i dunno....as i said this is an online game
12:56:15 <Lemmih> Is it homework?
12:56:25 <bacorinho> and at one of its levels
12:56:38 <bringert> is the game to write haskell code? or is the game written in haskell?
12:56:52 <bacorinho> i have this code to fix/run on a series of codes do get the right one
12:56:58 <bacorinho> none
12:57:28 <bringert> so you are trying to win the game, not fix it?
12:57:37 <bacorinho> i just have this peace of code (which i found to be haskell, because of a line saying import ParseLib)
12:57:54 <bacorinho> and to get to the next level
12:58:04 <bacorinho> i have to fix this piece of code
12:58:22 <bacorinho> (or understand it to port to another language that i'm more confortable with)
12:58:27 <bacorinho> a crack the codes...
12:58:35 <bacorinho> and crack the codes...
12:58:48 <bringert> so the task in the game is to learn haskell well enough to fix or understand the code?
12:58:58 <bacorinho> yup, u got it
12:58:59 <bacorinho> :-)
12:59:13 <bringert> but you see no benefit to learning haskell?
12:59:52 <bacorinho> nope...i've seen that it's somewhat a popular language....
13:00:15 <bringert> why are you playing a game that forces you to do stuff you don't find interesting?
13:00:21 <bacorinho> but has nothing to do with my job...
13:00:34 <bacorinho> this is just one part of one level....
13:01:33 <bacorinho> ok, maybe interesting is somewhat not the right word....what i mean is that i see no application of this language in the business area i'm working on....
13:01:51 <bringert> why not take the opportunity to learn something new, even if you see not immediate application for it in your job
13:01:52 <bacorinho> and this game, i'm doing it only for fun...
13:01:59 <bringert> well, haskell is fun
13:02:16 <bringert> few people here do haskell for money, afaik
13:02:30 <bringert> or at least manily for money
13:02:35 <bringert> *mainly*
13:02:42 <bacorinho> every programming language is fun afaik :-)
13:02:45 <bringert> right
13:03:15 <bacorinho> same goes to assembly....who uses assembly (without being for fun or something specific) these days
13:03:39 <pipe> are there any experts in the house tonight?
13:03:40 <bacorinho> or used it, when i learned it, 14 years now
13:03:41 <bringert> anyway, if you haven't used haskell or something like before, it might teach you a some new things, which could make you a better programmer
13:04:05 <bringert> pipe: experts of some specific?
13:04:17 <pipe> PL theory and stuff
13:04:27 <bacorinho> besides the tutorials on haskell.org....any thing you would like to recomend ?
13:04:52 <bringert> pipe: I guess it's easiest to ask and see if someone answers
13:05:06 <pipe> it's sort of a loaded question though
13:05:12 <bringert> bacorinho: taking a course from John Hughes :-)
13:05:21 <bringert> you might have to go to Sweden though
13:05:27 <bacorinho> i think its going to take long for me to learn this....i've neve even touched the functional languages field....
13:05:31 <bacorinho> LOL
13:05:39 <bacorinho> i'm in europe already.... ;-)
13:06:17 <bacorinho> anyway, one of the tutorials/papers listed on haskell.org is from a portuguese university (uminho)
13:06:22 <bringert> I can't recommend anything specific, don't really know what's out there nowadays
13:06:42 <bringert> can anyone else recommend something to an FP beginner?
13:07:08 <bringert> pipe: trying to start a flame war or something? :-)
13:07:13 <Lemmih> www.haskell.org/complex/
13:07:37 <pipe> bringert: no
13:08:32 <bacorinho> bringert: the code it's not too long, if i send it to u, at least u could check it for those syntax errors ?
13:09:06 <bringert> bacorinho: nope, sorry. not to be rude, but I think that if you want to play the game, you should do the work yourself
13:09:25 <bringert> and learning haskell and functional programming is a good thing
13:09:56 <bringert> pipe: ask away already
13:10:01 * bringert is getting interested
13:10:44 <bringert> not that I know if I can help, but "loaded question" about programming languages sounds good
13:11:12 <bacorinho> you're right...so...here i go...wish me luck....anyway, at least i found a place with (as i've seen) some people capable to enlighten me...
13:11:13 <pipe> well, i basicly want to know if people consider haskell to be like the one and only true "ultimate language" or if there is use for other languages that have different philosophies and stuff. i am only talking about theory here, nothing practical at all
13:11:27 <bringert> bacorinho: good luck
13:11:37 <bacorinho> thnks
13:12:22 <bringert> pipe: I guess it's a matter of opinion, but I myself think that there cannot really be such a thing as an ultimate language
13:12:43 <gzl> there's always use for other languages
13:13:02 <bringert> it seems unreasonable that a single finite language would be optimal for all problems
13:13:06 <pipe> yeah, but if we look at math then there are some core concepts that will always be true for probably forever
13:13:18 <gzl> bringert: yes, and I don't think any reasonable person would suggest that
13:13:26 <Marios> hello im newbie im tryin to work out for a while now how the following function works:
13:13:32 <Marios> kll :: (Int -> Bool) -> Bool
13:13:33 <Marios> kll a = a 0
13:13:35 <bringert> or even to prove that a language is somehow optimal for a single problem
13:14:00 <gzl> Marios: ok, it takes a function from Int to Bool and evaluates the function at 0.
13:14:04 <bringert> pipe: but you could probably chose different axioms that would make some thing simpler
13:14:05 <Marios> im trying to run it in hugs but dont know wot to write for a and get errors
13:14:30 <bringert> pipe: in math that is
13:14:39 <bringert> not that I know anything about math
13:14:51 <bacorinho> btw anyone here can comment on this book: Haskell - The craft of functional programming - 2nd ed ?
13:15:01 <_timor> Marios, try (\x-> x+2)
13:15:05 <gzl> Marios: you need to find a function from Int to Bool
13:15:09 <gzl> _timor: that's not a function from Int to Bool
13:15:12 <_timor> sorry
13:15:20 * bringert gets the book from the shelf
13:15:22 <jhunZoa> wow haskell is quite powerfull
13:15:30 <jhunZoa> a join function in just 1 line of code
13:15:40 <Oejet> jhunZoa: Show us!
13:15:50 <jhunZoa> not yet
13:15:51 <Marios> yeh i know that is it somethin i can write in hugs to make it run, or do i have to redefine the function
13:15:52 <Marios> ?
13:15:54 <gzl> Marios: a stupid one is (kll (\_ -> True))
13:15:59 <_timor> (\x-> x>10)
13:16:00 <gzl> Marios: this will always give True
13:16:05 <jhunZoa> after i got my result back
13:16:15 <bringert> result?
13:16:17 <jhunZoa> ye
13:16:25 <jhunZoa> its for school
13:16:26 <bringert> exam or something? or a slow compiler?
13:16:28 <bringert> ah
13:16:37 <jhunZoa> mister swierstra gonna give me a -10 prolly
13:16:45 <bringert> bacorinho: I thought it was pretty good
13:16:48 <Marios> k thanx
13:16:53 <gzl> Marios: write that function into a file, load it into hugs, then type "kll (\_ -> True)" at the prompt
13:17:14 <bringert> @type concat
13:17:16 <lambdabot> concat :: forall a. [[a]] -> [a]
13:17:23 <bringert> jhunZoa: that what you want?
13:17:29 <bacorinho> bringert: humm....i'll order it and see 4 myself....maybe one of these days i can joing u guys here to help other in the same situation i'm right now....
13:17:35 <Oejet> jhunZoa: What
13:17:44 <Oejet> jhunZoa: is the scale?
13:18:10 <jhunZoa> 0-10
13:18:16 <jhunZoa> but mister swierstra is so evil
13:18:27 <jhunZoa> he gives negative points for each mistake u make
13:18:57 <bringert> jhunZoa: is that Doaitse Swierstra?
13:18:59 <Oejet> jhunZoa: Heh, good for you.  Motivates you to learn well.
13:19:19 <bringert> jhunZoa: so writing nothing is better than getting it wrong?
13:20:13 <jhunZoa> ye
13:20:22 <jhunZoa> doaitse swierstra ye
13:20:35 <jhunZoa> 110/150 just failed for his first exam
13:20:46 <bringert> doesn't seem right to penalize people for trying
13:20:46 <Oejet> lol.
13:20:47 <jhunZoa> i think he is very happy about that right now -.-
13:21:21 <Oejet> jhunZoa: Does he have a nick name among the students?
13:21:32 <jhunZoa> no idea
13:22:02 <Oejet> jhunZoa: What's the topic of the course?
13:22:11 <jhunZoa> he forces us to learn all type defenitions from our head
13:22:21 <jhunZoa> its called functional programming
13:22:54 <bringert> jhunZoa: what type definitions?
13:24:02 <Oejet> jhunZoa: Introductory programming or a later course?
13:24:27 <jhunZoa> first time functional
13:24:46 <jhunZoa> 1st years also
13:25:08 <jhunZoa> bringert: all type defenitions
13:25:16 <jhunZoa> we had to know the type of all functions
13:25:26 <Oejet> The horror.
13:25:30 <jhunZoa> thats pretty useless if u ask me
13:25:33 <gzl> I mean, it's not that hard to figure out most of them if you know what they do
13:25:41 <jhunZoa> well
13:25:48 <jhunZoa> the type of foldl
13:25:51 <jhunZoa> i have no idea
13:25:57 <jhunZoa> maybe u can
13:26:02 <bringert> do you know that it does?
13:26:03 <gzl> well just write down a sample line of foldl and see what you get
13:26:14 <lightstep> the custom (here) is that math formulas are given as reference in tests, and the students don't have to memorize them
13:26:20 <jhunZoa> our exams are on paper..
13:26:31 <gzl> yes, paper
13:26:40 <jhunZoa> lightstep thats our custom too
13:26:43 <jhunZoa> except for this
13:26:43 <bringert> jhunZoa: ours to, and we give students a prelude excerpt
13:27:00 <jhunZoa> i didnt got that
13:27:05 <jhunZoa> we had to memorize them all
13:27:12 <gzl> my course doesn't have exams at all ;p
13:27:21 <bringert> jhunZoa: it might seem tough, but it's the professor's right to decide how to run the course. just as it's your right to complain about it. but a more productive route would be to take the opportunity to really learn haskell
13:27:38 <bringert> sorry to sound so dull and patronizing
13:27:56 <Oejet> jhunZoa: For motivation you might read http://www.cse.unsw.edu.au/~chak/papers/CK02a.html .
13:28:12 <jhunZoa> well ye its his right
13:28:25 <bringert> what if you take th route of trying to understand what you learn, instead of memorizing? if you know how to use the functions, you can figure out the types
13:28:27 <jhunZoa> but its also my right to have proper and fun education
13:28:29 <boegel> can someone tell me why I can't profile with ghc when I use stuff from System or Char ?
13:28:34 <bringert> jhunZoa: true
13:28:46 <jhunZoa> i pay him
13:29:07 <jhunZoa> and u cant expect coders to memorize all function
13:29:14 <bringert> have you brought it up with the professor, or the student representatives or whatever you have?
13:29:30 <bringert> jhunZoa: I agree, and I wouldn't teach a course that way
13:29:33 <Oejet> jhunZoa: Like you can't expect doctors to memorize all bodyparts?
13:29:50 <bringert> Oejet: I've gotta say that's slightly different
13:29:54 <jhunZoa> ye
13:30:03 <pipe> Oejet: you are a haskell expert right?
13:30:16 <jhunZoa> coders usually need to learn alot more other then coding
13:30:34 <jhunZoa> anyway im gonna walk the dog
13:30:39 <Oejet> Programmers sometimes write software that peoples life depends on.
13:30:55 <Oejet> pipe: I'm no expert.
13:31:04 <pipe> but you are above average, right?
13:31:10 <Oejet> pipe: I only see things.
13:31:12 <lightstep> this doesn't have to do with knowing all the functions from Prelude
13:31:42 <bringert> exactly, being able to figure out which one to use would be a more sensible requirement
13:32:56 <Oejet> Typical, students today are not required to learn anything by heart.
13:34:22 <bringert> well, you can be expected to know some things by heart
13:34:35 <Oejet> Heck, they even stop teaching kids the small multiplication table (up to ten).  They only have to "understand" it.
13:34:54 <bringert> that seems to go a bit to far
13:35:14 <bringert> as with most things, there is probably some middle path
13:35:32 <Oejet> bringert: It's the spirit of the day in the educational system.
13:35:39 <bringert> but I would agree that we move from memorizing towards understanding. is that a bad thing?
13:36:20 <bringert> someone who has memorized lots of stuff, but doesn't understand it, couldn't really solve any new problems
13:37:02 <bringert> of course for some thing, notably natural languages, memorizing in some sens is required
13:37:47 <bringert> and a quick read of what one writes, before hitting return, is also beneficial
13:38:00 <Oejet> In the process of memorizing you naturally try to find some sence.
13:38:09 <pipe> Pseudonym: hi!
13:38:31 <bringert> so the question is then, should we test students by their understanding or what they have memorized?
13:38:33 <Oejet> It's much easier to connect distant pieces if you have them in your head at the same time.
13:39:08 <bringert> right, but that's just a means to an end. the memorization in itself is not important
13:39:11 <gzl> I think you have to memorize some stuff
13:39:18 <bringert> sure, I agree
13:39:34 <gzl> and I suck at memorizing things, so often I have to make a deliberate effort
13:39:39 <bringert> I guess it's a question of finding the right balance
13:40:00 <Pseudonym> G'day.
13:40:08 <Oejet> bringert: You should test if people can develop on their knowledge and some problems.  That requires both understanding and a good memory.
13:40:24 <Heffalump> does he actually expect you to produce the definitions in the sense of "what is the type of foldr?", or does he just set questions that you have to know the answer to solve?
13:40:43 <bringert> Oejet: sounds reasonable
13:40:48 * bringert is off to bed
13:41:08 <pipe> i think people should be able to give the type of foldr if they understand it. they also should be able to give the definition
13:42:07 <lightstep> there are many folds, so recalling them by name might be of secondary importance
13:42:32 <pipe> i think foldr and foldl are the two big ones
13:42:56 <lightstep> and therefore less useful
13:45:13 <jhunZoa> back
13:46:08 <jhunZoa> list comprehensions(?) are powerfull save me much work
13:46:27 <gzl> yes, list comprehensions
13:46:43 <jhunZoa> best thing ive seen till now in haskell
13:46:59 <boegel> I'll try and ask again :)
13:47:02 <boegel> can someone tell me why I can't profile with ghc when I use stuff from System or Char ?
13:47:04 <Oejet> Quote from TRaBoTPFPiFY: "However, the treatment of more advanced higher-order functions---even folds---is usually couterproductive, as it confuses even average students, and detracts from the main aims of the course."
13:47:28 <jhunZoa> mister swierstra is in love with fold
13:47:47 <gzl> who is this mister swierstra?
13:47:48 <jhunZoa> he claims every list function in haskell is rewritable with fold
13:47:58 <jhunZoa> my teacher
13:48:03 <gzl> ok
13:48:07 <jhunZoa> and apperently half this channel knows him
13:48:12 <gzl> ah, ok
13:48:32 <lightstep> he lies
13:48:43 <jhunZoa> my teacher?
13:48:54 <jhunZoa> prove him wrong
13:49:05 <Spherical`> What level are you on jhunZoa? High school,.. University?
13:49:06 <lightstep> well, x = foldl x undefined [], but that doesn't count
13:49:09 <jhunZoa> university
13:49:25 <lightstep> but seq is probably problematic
13:49:43 <jhunZoa> i think he can rewrite everything he seems smart
13:49:45 <Itkovian> don;t we have a swierstra on this channel?
13:49:50 <jhunZoa> ye
13:49:55 <jhunZoa> his nephew ~
13:49:56 <Itkovian> the same?
13:49:57 <Itkovian> ah
13:50:13 <Oejet> How about f lst = first lst + last lst?
13:50:22 <jhunZoa> i have no idea
13:50:27 <jhunZoa> my teacher knows
13:50:44 <jhunZoa> i think he has published several articles about fold
13:50:58 <Oejet> Heh, like Wadler.
13:51:01 <Lemmih> I think you have to limit the definition of a "list function".
13:51:23 <ibid> the basic bird fold
13:51:46 <Pseudonym> Get him to write something for TMR.
13:51:50 <Pseudonym> Then we'll have heard of him.
13:52:16 <jhunZoa> TMR
13:52:18 <jhunZoa> whats that?
13:52:28 <Pseudonym> @wiki TheMonadReader
13:52:29 <lightstep> @wiki TheMonadReader
13:52:29 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
13:52:29 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
13:52:37 <Pseudonym> Like lightstep said.
13:52:41 * lightstep lost
13:52:45 <Oejet> Heh.
13:52:49 <Pseudonym> Yeah, but you did it better.
13:52:56 <Lemmih> G'night #Haskell. I'm off for bed.
13:53:01 <Pseudonym> Night.
13:53:05 <lightstep> like when france loses in war?
13:53:20 <Oejet> lightstep: It's not about wining, it's about participating, right?
13:53:33 <boegel> bye Lemmih
13:54:15 <lightstep> this saying is so lame. i was already fed up with it in elementary school
13:54:24 <Pseudonym> France only lost because invading Russia was a REALLY bad idea.
13:54:45 <Oejet> Invading Russia is always a bad idea.
13:54:49 <lightstep> and the world wars?
13:55:07 <Pseudonym> I don't see them under German rule, do you?
13:55:26 <lightstep> exactly. they lost, but their culture has won
13:55:51 <Pseudonym> They didn't lose.  Though having people who hated the Germans even more helped.
13:55:52 <Oejet> lightstep: They lost a lot of battles, but won the war.
13:58:24 <lightstep> is there a syntax thingy in ghc that lets you use have a syntax for lisp's cond?
13:58:38 <wilx> Huh.
13:59:02 <Oejet> case with guards?
13:59:46 <lightstep> yes, but sugared
14:00:22 * boegel quits
14:00:25 <boegel> bye everyone
14:01:47 <Oejet> lightstep: Could you give an example?  (cond (null? a) (eq (length a) 4) (else 'foo)) ?
14:02:43 <lightstep> cond {foo x -> quux; bar y -> quuux; otherwise -> baz} or such
14:04:19 <Oejet> case x of | foo z -> quux | bar y -> quuux | otherwise -> baz.  Would that work almost?
14:06:04 <lightstep> it'll work, but lisp and ocaml have syntax-extensions mechanisms that let you define that, so why not haskell too?
14:06:55 <wilx> Hmm, Haskell has guards, why is that not enough?
14:07:12 <lightstep> 'cause they're not as pretty
14:07:24 <wilx> Err.
14:07:33 <wilx> I do _not_ consider Lisp pretty.
14:07:38 <wilx> Neither part of it.
14:07:44 <lightstep> it's the syntax tar pit, where everything is possible but most things are ugly
14:08:02 <Pseudonym> It's actually:
14:08:05 <Pseudonym> case x of
14:08:09 <Pseudonym>    _ | foo x -> quux
14:08:17 <Pseudonym>      | bar y -> quuux
14:08:17 <Pseudonym> etc
14:08:25 <Pseudonym> The underscore is important. :-)
14:09:04 <wilx> Well, I guess you can do your own cond :: [(Bool, a)] -> a or something
14:09:05 <lightstep> i'd also like the do syntax to support labels
14:09:14 <Pseudonym> I want gotos.
14:09:18 <Pseudonym> Oh, and pointer arithmetic.
14:09:27 <wilx> :)
14:09:32 <Heffalump> and to be using C, presumably.
14:09:38 <wilx> Pseudonym, it is already there.
14:09:42 <wilx> The Ptr a type :)
14:09:54 <Pseudonym> FFI gives me everything I need.
14:09:55 <wilx> poke and peek functions etc.
14:09:55 <ibid> where are my warm and fuzzy segfaults?!?!?!
14:10:05 <Heffalump> I got Haskell to segfault the other day.
14:10:06 <Pseudonym> My Haskell program just calls the C main() function.
14:10:23 <wilx> :)
14:10:25 <lightstep> recursively, that is?
14:11:01 <ibid> Heffalump: lucky you :)
14:11:42 <Heffalump> turned out to be gmp's fault.
14:11:58 <ibid> boring :)
14:12:07 <ibid> all good segfaults are the programmer's fault
14:12:23 <wilx> Good segaults? :D
14:13:13 <Pseudonym> The bad ones are caused by hardware failure.
14:13:44 <lightstep> i had hardware failure today, the motherboard smoked a little
14:13:45 <ibid> wilx: you know, those that let you know YOU are in control, not some freaking straightjacket of a compiler :)
14:15:11 <wilx> Heh.
14:15:23 <wilx> I never feel being in control when my apps segfault :D
14:15:44 <ibid> (neither do i, but don't tell me that)
14:15:48 <Pseudonym> lightstep: The magic smoke escaped?
14:15:49 <wilx> I usually feel like I am losing it "D
14:16:55 <lightstep> Pseudonym, no, it smelled like silicon. but a few hours later, it fixed itself
14:18:12 <ibid> well, it's bedtime in finland. sya, bbl :)
14:57:49 <Itkovian> @seen shapr
14:57:50 <lambdabot> I saw shapr leaving #webwitches 7 hours 14 minutes 30 seconds ago.
14:58:56 <Pseudonym> #webwitches?
14:59:06 <gzl> anybody played with Generic Haskell much?
14:59:17 <Pseudonym> I'm envisaging a bunch of neo-Pagans with laptops.
14:59:35 <SyntaxNinja> it's his company
14:59:39 <Pseudonym> Yeah, I know.
14:59:45 <Pseudonym> It's still an amusing mental image.
15:00:05 <Pseudonym> Dancing around the fire, casting spells, adding a blog entry...
15:00:38 <SyntaxNinja> they're very modern ;)
16:02:17 <Itkovian> night.
16:14:33 <Itkovian> hmm
16:14:59 <Itkovian> now I'm definitely off to sleep
16:54:06 <MachinShin> hey +
16:54:11 <SyntaxNinja> hi
18:26:37 <juhp> probably wxhaskell's "wxcore*.o" can be generated at package install time, no?
18:26:55 * juhp tries
18:31:06 <Igloo> Is that in reply to something?
18:38:00 <juhp> Igloo: nah, just the object files bloat packages :)
18:38:41 <juhp> well I hope ghc-pkg -u can take care of them
18:48:00 <KrispyKringle> hmm. I'm having some difficulty here...
18:48:44 <KrispyKringle> I'm using WASH, which defines some functions as text_S :: Monad m => String -> WithHTML x m (). And I'm trying to apply text_S across a list of strings using mapM.
18:49:09 <KrispyKringle> So I've done  mapM (text_S) splitDescr, but it doesn't typecheck (splitDescr is a [String]).
18:49:37 <KrispyKringle> or rather, I was going to do mapM (p $ do text_S) splitDescr, because I really want paragraphs areound each string in the list.
18:49:51 <KrispyKringle> Anyone familiar with Wash? Or odd uses of mapM? I'm kinda stuck. :)
18:50:43 <KrispyKringle> I get expected type as WithHTML x m a, inferred is String -> WithHTML x1 m1 ().
18:51:37 <juhp> hmm
18:51:47 <juhp> warning: can't find GHCi lib `wxcore.o'
18:51:48 <juhp> ...
18:54:28 <dons> KK: :t mapM text_S splitDescr :: Monad m => WithHTML x m [()], I think.
18:54:46 <dons> KK: what's the type of p?
18:55:09 <KrispyKringle> dons: p is the same as text_S, i believe. p_S certainly is, which i tried in place of p
18:55:17 <dons> :t p ?
18:55:39 <KrispyKringle> p, p_S, p_T :: Monad m => HTMLCons x y m a
18:55:48 <KrispyKringle> hmm
18:56:41 <KrispyKringle> oh, wait. WASH defines its own map function. maybe i can use that...
18:57:02 <KrispyKringle> let me search the docs a sec
18:59:30 <KrispyKringle> shit. can't remember; how do i import the module in a way that HTMLMonad.map doesn't mask Prelude.map?
18:59:53 <juhp> doh!  it would help if I actually passed -g to ghc-pkg...
19:00:33 <KrispyKringle> qualified
19:00:35 <KrispyKringle> ooh
19:01:42 <juhp> yay
19:03:18 <KrispyKringle> nevermind. im stupid.
19:03:27 <KrispyKringle> not that i fixed the problem. nevermind that i thought i might've solved.
19:03:29 <KrispyKringle> solved it.
19:06:53 <KrispyKringle> what does this mean? ...
19:06:53 <KrispyKringle>     Ambiguous type variable `m' in the top-level constraint:
19:06:54 <KrispyKringle>       `Monad m' arising from use of `text_S' at Adventure.hs:36
19:07:22 <gzl> you could do import HTMLMonad hiding map
19:07:37 <KrispyKringle> gzl: not what i wanted to do. i wanted to still be able to access map.
19:07:40 <KrispyKringle> hence, the use of qualified.
19:07:46 <KrispyKringle> gzl: did you solve this problem yet?
19:07:50 <gzl> oh, I thought you said that's not what you wanted
19:08:00 <gzl> the parsing thing? no
19:08:01 <KrispyKringle> map isn't what i wnated, but i didn't realize that because i misread the docs :P
19:08:09 <gzl> I haven't tried yet
19:08:31 <KrispyKringle> well, splitting the string is cake. but i can't figure out how to mapM (or whatever) across every string.
19:08:38 <KrispyKringle> driving me nuts.
19:08:48 <KrispyKringle> im also really annoyed because the vending machine is out of food.
19:09:16 <KrispyKringle> maybe ill go hit up the cappucino machine.
19:09:34 <gzl> cappuccino machine? where are you?
19:10:07 <KrispyKringle> hms
19:10:13 <KrispyKringle> there's a machine on the third floor.
19:10:17 <KrispyKringle> takes a dollar.
19:10:21 <KrispyKringle> makes a cappucino.
19:10:35 <KrispyKringle> it's not so bad. i've had better, but, you know, for a buck and two minutes at any hour, it's not bad.
19:11:27 <gzl> hms is pretty nice
19:12:17 <KrispyKringle> yeah. we're pimpin'.
19:12:32 <KrispyKringle> there's a new grad student here who sorta gets on my nerves, though.
19:12:42 <KrispyKringle> he works at lockheed and he loves to talk about his job. it's just irritating.
19:12:56 <gzl> haha
19:13:02 <gzl> is kanyuk annoying?
19:13:07 <KrispyKringle> no
19:13:08 <gzl> ok
19:13:08 <KrispyKringle> he's a nice guy
19:13:15 <Pseudonym> Lockheed is an annoying place, so I hear.
19:13:17 <KrispyKringle> used to bug me because he's such a know it all, but only because he really does know a whole lot.
19:13:25 <gzl> does he?
19:13:30 <KrispyKringle> i mean, he's a guru when it comes to maya and renderers.
19:13:35 <KrispyKringle> he's co-teaching CIS700.
19:13:40 <gzl> oh, maya, ok
19:13:42 <KrispyKringle> TA'ing, I guess, but he's still really good.
19:13:47 <KrispyKringle> yeah.
19:13:58 <gzl> i remember he was tutoring some java once
19:14:01 <KrispyKringle> he's quite narrowly focussed, but he's going to work at Pixar for christ sakes.
19:14:05 <gzl> and he seemed to not know the most trivial things
19:14:08 <KrispyKringle> yeah
19:14:12 <KrispyKringle> he doesn't know much about anything else :P
19:14:18 <Pseudonym> Sorry, who is this Maya/renderer guru?
19:14:33 <gzl> some common acquaintance, sorry. should we move to privmsg? :)
19:14:37 <KrispyKringle> haha
19:14:40 <Pseudonym> No, I'm just curious.
19:14:44 * Pseudonym used to work at DotC
19:14:53 <KrispyKringle> DotC?
19:14:54 <gzl> some guy we know at university
19:14:55 <Pseudonym> So I know a few people in the business.
19:14:58 <KrispyKringle> ah
19:15:04 <KrispyKringle> no, he's going to be at pixar in the spring.
19:15:07 <Pseudonym> www.dotcsw.com
19:15:07 <gzl> is it that hard to get hired at pixar?
19:15:08 <Pseudonym> Ah, OK.
19:15:14 <gzl> s/at/by/
19:15:18 <Pseudonym> I know a couple of people at Pixar and a couple of ex-Pixar.
19:15:34 <KrispyKringle> sounds like a cool place. nothing im remotely interested, but sounds cool.
19:15:41 <gzl> yeah, it does sound cool
19:15:48 <Pseudonym> Pixar _sounds_ like a cool place, but you definitely need an exit strategy worked out.
19:15:57 <KrispyKringle> (see, he's the kinda guy who would look at the cat on the dotc homepage and comment on the quality of the fur rendering ;)
19:16:00 <Pseudonym> It's got a very strong caste system.
19:16:05 <KrispyKringle> Pseudonym: how so? people don't stick around for long?
19:16:05 <KrispyKringle> ah
19:16:17 <Pseudonym> And did you hear about ExLuna?
19:16:20 <gzl> no
19:16:38 <Pseudonym> http://www.renderman.org/RMR/OtherLinks/blackSIGGRAPH.html
19:16:47 <Pseudonym> Read and weep.
19:18:17 <gzl> by caste system do you mean some people like to pull rank, or it's hard to move up?
19:18:22 <Pseudonym> The moral of the story: I ain't gonna work for Pixar.
19:18:33 <Pseudonym> I mean... OK, this is the impression that I get.
19:18:36 <KrispyKringle> yeah, that does kinda suck
19:18:38 <Pseudonym> I used to be a public servant.
19:18:58 <Pseudonym> I worked for the Director of PUblic Prosecutions, which... the US equivalent would be federal prosecutors.
19:18:59 <KrispyKringle> seems like you're walking a fine line at a lot of companies if you write an open source competitor of theirs, though. im hardly surprised pixar was pissed.
19:19:11 <Pseudonym> BMRT wasn't open source.
19:19:15 <Pseudonym> But I digress.
19:19:15 <KrispyKringle> oh, no?
19:19:28 <Pseudonym> Basically, if you weren't a lawyer at the DPP, you didn't exist.
19:19:46 <Pseudonym> Similarly, I suspect that if you're not doing "core business" at Pixar, i.e. directly working on a film, you don't exist.
19:19:59 <KrispyKringle> (gzl, this is what I've said about being a programmer at an ibank...seems like you're just going to be serving the investors)
19:20:01 <Pseudonym> And the animators are the highest caste.
19:20:10 <KrispyKringle> hmm
19:20:15 <Pseudonym> That's just the impression.
19:20:22 <KrispyKringle> it wouldn't surprise me a whole lot.
19:20:45 <gzl> yeah, i could see that
19:20:53 <Pseudonym> Anyway.
19:20:58 <KrispyKringle> on the other hand, i know a couple guys who're going to work for  EA. Joining up with a company being accused of screwing over their workers seems like an odd move... ;)
19:21:04 <Igloo> Ah crap, I forgot gtk2hs requires c2hs
19:21:13 <Pseudonym> It's the ExLuna thing which really got me.  I thought that was just plain evil.
19:21:22 <KrispyKringle> gzl: wanna look at this WASH stuff and lend me a hand?
19:21:24 <Pseudonym> Pixar make great films, but...
19:21:40 <KrispyKringle> I can't figure out how to map p across the different strings.
19:21:56 <Pseudonym> So now I'm working on an open source renderer project instead.
19:22:11 <Pseudonym> Which your common acquaintence has probably heard of.
19:22:19 <KrispyKringle> what's the name of it?
19:22:29 <Pseudonym> Aqsis
19:22:39 <KrispyKringle> hmm. i haven't, im afraid ;)
19:22:40 <Pseudonym> Probably not USED it, but probably heard of it.
19:22:49 <KrispyKringle> but that doesn't mean much. im pretty ignorant about this stuff.
19:22:52 <KrispyKringle> i can use maya. that's about it.
19:22:55 <gzl> i'm completely ignorant
19:23:05 <gzl> (about this stuff!)
19:23:07 <Pseudonym> I used to write plugins for Maya for a living.
19:23:10 <KrispyKringle> mayas fun, dude. but it takes a lot of time to get results.
19:23:15 <Pseudonym> Very nice piece of technology.
19:23:23 <KrispyKringle> Mel or C++?
19:23:29 <Pseudonym> C++, mostly.
19:23:29 <KrispyKringle> or both?
19:23:31 <KrispyKringle> ah
19:23:35 <gzl> well
19:23:39 <Pseudonym> But you need some MEL.
19:23:51 <Pseudonym> You can't really write a usable plugin in pure C++.
19:23:56 <KrispyKringle> it looks decent, for a built in scripting language
19:24:22 <Pseudonym> It's very ideosyncratic.
19:24:25 <KrispyKringle> 'course, blender has python, which is great.
19:24:34 <Pseudonym> The fact that you can't write a command in the scripting language is a bit odd.
19:24:43 <KrispyKringle> but compared to Macromedia's Lingo or ActionScript...
19:25:19 <Pseudonym> The thing I like most about Maya is the dependency engine model.
19:25:24 <Pseudonym> It's really well thought-out.
19:27:24 <Pseudonym> It's cleverly designed to be maximally flexible while using as little memory as possible.
19:44:13 <Sonarman> addNegs = foldr (\x xs -> x : (-x) : xs) []
19:44:50 <Sonarman> why does that have type  [Integer] -> [Integer]  instead of  Num a => [a] -> [a]  ?
19:49:41 <KrispyKringle> it shouldn't.
19:50:01 <Sonarman> that's what i thought, yet hugs and ghci say it does :)
19:50:07 <KrispyKringle> wait a sec
19:50:17 <KrispyKringle> well, so in hugs, the type of that lambda you have is foo :: Num a => a -> [a] -> [a]
19:50:24 <KrispyKringle> foo x xs = x : (-x) : xs
19:50:46 <redbluere1> hey haskellers hows life
19:51:00 <redbluere1> any new kick butt apps in the works?
19:51:04 <KrispyKringle> foldr foo [] :: Num a => [a] -> [a]
19:51:13 <mauke> (\x xs -> x : (-x) : xs) :: forall a. (Num a) => a -> [a] -> [a]
19:51:13 <KrispyKringle> looks fine for me in hugs, Sonarman
19:51:17 <mauke> ghci here
19:51:34 <KrispyKringle> foo :: forall a. (Num a) => a -> [a] -> [a]
19:51:36 <KrispyKringle> yeah
19:51:37 <KrispyKringle> works for me
19:51:54 <Sonarman> hrm, weird
19:51:54 <KrispyKringle> you must be mistaken, Sonarman :P
19:52:37 <Sonarman> it only happens in this specific file
19:52:54 <Sonarman> in a different file it's as it should
19:53:02 <Sonarman> or maybe i'm just going crazy
19:53:16 <Sonarman> which is entirely possible
19:53:55 <KrispyKringle> probably :P
19:54:58 <Sonarman> ah, sadly it's not me who's lost it
19:55:24 <Sonarman> for some reason, the identical definition gets the wrong type in this specific file
19:55:44 <KrispyKringle> shame
19:55:44 <Sonarman> time to Randomly Comment Stuff Out(TM)
19:55:49 <KrispyKringle> anything odd in that file?
19:55:50 <KrispyKringle> heh
19:56:23 <Sonarman> other than the fact that the code in it is mysteriously broken in multiple ways? nope
19:57:18 <Sonarman> well, i'll be diggly-damned
19:57:39 <Sonarman> i comment out all the other lines, and it still does this
19:58:08 <Sonarman> and i'm all out of goats to sacrifice :(
19:59:15 <Sonarman> WAIT A SECOND
20:00:11 <Sonarman> The type of  foldr (\x xs -> x : -x : xs)  is  Num a => [a] -> [a] -> [a]
20:00:26 <Sonarman> But the type of... oh wait
20:00:29 <Sonarman> hmm
20:02:24 <Sonarman> Prelude> :t foldr (\x xs -> x : -x : xs) []
20:02:24 <Sonarman> foldr (\x xs -> x : -x : xs) [] :: forall a. (Num a) => [a] -> [a]
20:02:24 <Sonarman> Prelude> let addNegs = foldr (\x xs -> x : -x : xs)
20:02:24 <Sonarman> Prelude> :t addNegs
20:02:24 <Sonarman> addNegs :: [Integer] -> [Integer] -> [Integer]
20:03:37 <Sonarman> as soon as i give the function a name, it enters the realm of WTF
20:03:44 <KrispyKringle> now THAT is weird.
20:05:37 <Sonarman> (correction: there should be a [] at the end of the definition, and the type is [Integer] -> [Integer])
20:06:35 <Sonarman> the same thing happens when i put the definition into a file and load it in hugs
20:08:19 <Sonarman> ok, i have to leave now. if anyone happens to see this while i'm gone and knows the answer, please give it. i'll check the logs. thanks. (and thanks, KrispyKringle)
20:08:38 <mauke> adding addNegs :: (Num a) => [a] -> [a] seems to work
20:53:28 <kzm> Hi.  Isn't Sonarman's question just the monomorphism restriction?
20:55:40 <kzm> I.e. that a top-level definition must be monomorphic (thus defaulting e.g. Num to Integer)
21:46:00 <Steve_p> Can you use ghc in interactive mode like hugs or is it a straight compiler?
21:46:32 <desrt> ghc --interactive
21:46:48 <Steve_p> Great!  Thanks desrt!
21:46:56 <desrt> 'ghci' is usually an installed alias for that
21:47:30 <Steve_p> No such alias for me :(
21:48:03 <desrt> ah well
21:48:10 <desrt> at least ghc --interactive works?
21:48:22 <desrt> just slightly more typing :)
21:50:06 * araujo looks around
21:54:18 * araujo looking for a vict.... user with ghc6.4
22:31:23 <Lemmih> Good morning, #haskell.
22:34:34 <araujo> Hello Lemmih
22:34:43 <araujo> just in time for one question 8)
22:34:48 <Lemmih> Sure.
22:35:04 <Lemmih> ^^wrong channel.
22:35:14 <araujo> Lemmih, just to know.. have you ecver had problems with ghc-pkg in g6.4?
22:35:42 <Lemmih> Nope.
22:35:54 <Lemmih> What kind of problems?
22:37:05 <Lemmih> I rarely use ghc-pkg directly.
22:37:38 * araujo looking for the log
22:39:07 <dons> how do you use it, if not directly?
22:39:23 <Lemmih> dons: Via cabal.
22:39:49 <dons> ah, of course.
22:39:54 <araujo> Lemmih, running something like: ghc-pkg -i lib/script.pkg --update-package --auto-ghci-libs
22:40:46 <Lemmih> araujo: You should use cabal for that.
22:41:13 <araujo> i get a syntax error (sorry, im recompiling again with latest to get the logs) on this file: http://pastebin.com/248710
22:41:50 <Lemmih> araujo: GHC 6.4 does only understand Cabal packages.
22:41:58 <araujo> mm.. well.. it is actually a makefile running it
22:42:45 <Lemmih> What are you trying to install? Maybe it has been cabalized already.
22:43:54 <araujo> hah.. sounds just funny.. hsshellscript
22:44:08 <araujo> no, it isn't cabalized yet
22:46:02 <araujo> Lemmih, i thought we at least could use .pkg yet
23:33:56 <Itkovian> meuning
23:53:51 <nlv11757_> meuning hardly sounds belgium, but top 'o the morning to ya
