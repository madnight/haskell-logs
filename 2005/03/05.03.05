00:06:39 <musasabi> morning
01:52:52 <rtega> anybody an idea why haskell is complaining here?
01:52:55 <rtega> ERROR "test.hs":143 - Type error in application
01:52:55 <rtega> *** Expression     : 1 / m * (compow m psi + exsum (m + 1))
01:52:55 <rtega> *** Term           : 1 / m
01:52:55 <rtega> *** Type           : Int
01:52:57 <rtega> *** Does not match : [a]
01:53:09 <rtega> why is 1/m typed as Int?
01:56:05 <Lemmih> That's because the type Int does not match the type [a].
01:57:13 <Lemmih> In other words, we need more info.
01:57:35 <Lemmih> lisppaste2: url
01:57:35 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
01:57:49 <Lemmih> Feel free to post the relevant code there.
01:58:21 <rtega> it's long, and probably i've been doing ugly things with the code involved
01:58:42 <rtega> i'm doing a coding of Karczmarczuk's ideas in "generating power of lazy semantics"
01:59:17 <rtega> the main problem being that I run into problems with Ints and Doubles
02:00:51 <lisppaste2> rtega pasted "Generating power" at http://paste.lisp.org/display/6308
02:01:09 <rtega> :D
02:01:51 <rtega> you should know that i've added some functions to make operations possible with lists
02:02:06 <rtega> so you can do [1,2]*[1,1]
02:02:57 <Lemmih> And 'm' is a list?
02:03:25 <rtega> no
02:03:45 <rtega> m is an integer
02:03:55 <rtega> so i suppose 1/m is a Double
02:04:20 <zxccv> http://www.tcpsecurity.com
02:04:26 <Lemmih> rtega: Can't use (/) for integer division.
02:04:42 <Lemmih> zxccv: Dirty spammer.
02:04:57 <rtega> Lemmih: so what can i do?
02:05:06 <Lemmih> @type div
02:05:13 <lambdabot> div :: forall a. (Integral a) => a -> a -> a
02:05:24 <rtega> mmm
02:05:43 <rtega> that's not exactly what I want there
02:06:13 <Lemmih> Then convert m to a Fractional with fromIntegral.
02:06:18 <rtega> 1 `div` m  is always going to be 0
02:10:34 <rtega> humz
02:22:49 <rtega> thanks
02:34:07 <rtega> humz
02:34:25 <rtega> can I do something like: instance (Integral a) => Num [(Ratio a)] where
02:57:12 <rtega> hello?
03:05:08 <Matt-W> hello
03:11:06 <rtega> I would like to define operations on lists of a ratio type
03:11:10 <rtega> how can I do that?
03:15:54 <rtega> please, can anybody help me on this?
03:16:16 <rtega> or point me to a thorough explanation on types and classes?
03:17:24 <cptchaos> rtega: sorry, on what? just logged in?
03:17:48 <rtega> well cptchaos, i want to define some operations on lists of Rationals
03:18:10 <rtega> I can't seem to figure out how to do that
03:19:13 <cptchaos> and how should the operation be called?
03:19:22 <rtega> + - * /
03:19:25 <xerox> Good afternoon.
03:20:08 <cptchaos> ah, ok
03:20:14 <rtega> damn, time for dinner
03:20:33 <cptchaos> I have to look at the prelude, whait a minute
03:23:46 <cptchaos> rtega: ok, the statdart classes you could youse are Num and Fractional
03:24:05 <cptchaos> @listcommand
03:24:05 <lambdabot> Sorry, I don't know the command "listcommand", try "lambdabot: @listcommands
03:24:10 <cptchaos> brr
03:24:14 <cptchaos> @listcommands
03:24:14 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
03:24:14 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
03:24:14 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
03:24:14 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
03:24:14 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
03:24:15 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
03:24:16 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
03:24:19 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
03:24:20 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
03:24:56 <cptchaos> @definitions Num
03:24:56 <lambdabot> []
03:25:01 <cptchaos> hm
03:25:35 <cptchaos> however the classes offer the following ops:
03:25:49 <cptchaos> Num((+), (-), (*), negate, abs, signum, fromInteger)
03:26:12 <cptchaos> Fractional((/), recip, fromRational)
03:28:49 <cptchaos> then you can define your ops by
03:29:40 <cptchaos> instance Num [MyRational] where
03:29:53 <cptchaos> (+) :: ...
03:29:56 <cptchaos> etc
03:31:09 <cptchaos> i hope, this helps
03:37:08 <Itkovian> @seen boegel
03:37:09 <lambdabot> I haven't seen boegel
03:50:19 <rtega> cptchaos: that doesn't seem to work
03:50:26 <rtega> instance Num  [Rational]  where
03:50:33 <rtega> ERROR "test3.hs":52 - Syntax error in instance head (variable expected)
03:52:29 <cptchaos> hm, I did not test that
03:57:25 <cptchaos> I guess that something I have yoused has a prarameter
03:59:35 <cptchaos> yes
04:07:12 * boegel says "Hi!"
04:08:03 <cptchaos> rtega: this seems not to be possible with a parametric types like lists ...
04:08:41 <rtega> mmm
04:09:01 <rtega> damn!
04:09:26 <rtega> the stupid thing is that I can do the following:
04:09:35 <rtega> instance Num a => Num [a] where etc.
04:09:40 <rtega> that's no problem at all
04:10:03 <cptchaos> this works for me:
04:10:07 <cptchaos> newtype T = T [Rational]
04:10:07 <cptchaos>  deriving (Eq,Show)
04:10:07 <cptchaos> instance Num T where
04:10:07 <cptchaos>   (+) (T xs) (T ys) = T (map (\(a,b)->a+b) (zip xs ys))
04:10:12 * pesco jump in happily.
04:10:20 <pesco> cptchaos: Hi!
04:10:32 <cptchaos> pesco: whats up?
04:10:54 <pesco> I just aquired two tickets to NIN in Berlin.
04:11:10 <cptchaos> NIN?
04:11:15 <Itkovian> eh? you lucky bastard
04:11:20 <Itkovian> Nine Inch Nails
04:11:22 * pesco grins evilly.
04:11:41 <cptchaos> hrm
04:11:56 <cptchaos> gratulations
04:12:08 <pesco> Thanks. It was an ordeal.
04:12:19 <Itkovian> how much did they cost?
04:12:38 <pesco> 38e
04:12:58 <cptchaos> rtega: ist that good enough?
04:13:26 <Itkovian> hmm ... a tad much
04:13:37 <pesco> Itkovian: I think it's OK.
04:13:38 <cptchaos> rtega: ok, it is not exactly what you wanted,
04:13:52 <Itkovian> well ... never seen them. willing to tho'
04:14:14 <pesco> cptchaos: map (\(a,b)->a+b) (zip xs ys) == zipWith (+) xs ys
04:15:08 <pesco> Itkovian: I've never seen them. Determined to though.
04:15:10 <cptchaos> pesco: right, has been a while, since I was really coding something
04:15:16 <pesco> cptchaos: I guessed.
04:15:58 <rtega> no cptchaos, it doesn't work :(
04:16:26 <cptchaos> sorry, what does not work?
04:16:54 <rtega> well, try to add two such lists
04:17:23 <pesco> rtega: You mean with (+)?
04:17:46 <rtega> pesco: indeed
04:18:09 <rtega> this is what I get:
04:18:10 <rtega> [1 % 3] + [1 % 6]
04:18:10 <rtega> ERROR - Cannot infer instance
04:18:10 <rtega> *** Instance   : Num [Ratio a]
04:18:10 <rtega> *** Expression : [1 % 3] + [1 % 6]
04:18:21 <pesco> rtega: For that you should hide Prelude.+ and make your own class.
04:18:33 <rtega> and how do I do that?
04:19:31 <pesco> (+) is a method of class Num. Since your lists are not in that class (i.e. there is no instance providing the method for them) it can't work.
04:20:49 <pesco> rtega:  class AddGrpd a where (+) :: a -> a -> a  for instance.
04:22:03 <pesco> rtega: Then you probably want  instance (Num a) => AddGrpd [a] where (+) = zipWith (Prelude.+)
04:22:25 <pesco> For that you have to  import qualified Prelude((+))
04:22:31 <rtega> wow
04:22:35 <pesco> rtega: Does that answer your question?
04:22:38 <rtega> yes
04:22:43 <pesco> :) Good.
04:22:47 <rtega> lot's of annoyances
04:23:11 <pesco> Yes, it is a pity the standard algebra classes aren't more flexible.
04:23:39 <pesco> Of course if you're just looking for a quick hack, you can circumvent the issue by defining a "dirty" Num instance:
04:23:59 <pesco> instance (Num a) => Num [a] where (+) = zipWith (+)
04:24:07 <pesco> i.e. leaving all other methods undefined.
04:24:08 <rtega> that's what i did previously
04:24:16 <rtega> that works nicely
04:24:22 <pesco> OK.
04:24:36 <rtega> but I can't seem to find a way to do the same thing with ratios
04:24:47 <rtega> except for all the class hassle of course
04:25:03 <pesco> What do you mean? Isn't  Ratio a  in class Num?
04:25:09 <rtega> yes it is
04:25:16 <rtega> ah second
04:25:38 <rtega> gni
04:25:42 <rtega> it works :D
04:25:50 * pesco shrugs.
04:25:54 <pesco> All the better!
04:26:27 <sorje> Why is the Num instance dirty?
04:26:46 <pesco> sorje: Because you rely on runtime checks to catch programming errors.
04:27:51 <cptchaos> pesco: he is right [1,2]+[2,3] works, but [1 % 3] + [1 % 6] not
04:28:58 <pesco> cptchaos: Huh? I thought it did after all. And if  Num (Ratio a)  , it must work!
04:29:45 <cptchaos> *rereding my code extremly carefully*
04:30:55 <cptchaos> hm now it does
04:30:57 <cptchaos> strage
04:31:06 <pesco> Hah, seems you were suffering from the same Heisenbug then.
04:31:56 <cptchaos> the only thing I changed was including import Ratio in the file, instaead of loading it manually in hugs
04:31:58 <cptchaos> hm
04:33:08 <cptchaos> haha
04:33:11 <pesco> Ah, and I already thought I had finally acquired the Aura of Dexterity which gives a +2 modifier on all code correctness checks.
04:33:15 <cptchaos> *eg*
04:33:37 <cptchaos> ROFL
04:33:52 <pesco> I could _use_ that item.
04:34:35 <cptchaos> the problem I had was, that I didnt' remember hugs commands correctly
04:34:56 * pesco giggles.
04:35:12 <cptchaos> if you do :load Ratio, it discads you current module, where the instance definition is ...
04:35:21 <pesco> Yup.
04:36:24 <cptchaos> ok, I will have breakfast ...
04:38:22 <pesco> Good eat.
04:38:42 <pesco> Sorry my english is deteriorating again.
05:59:44 <Xih> hi, so does anyone know of an open-source implementation of J?
05:59:52 <Xih> i know it's not #j but...
06:03:38 <Kevin> http://www.tcpsecurity.com/
06:17:05 <Xih> :|
06:21:09 <pipe> anyone happen to know what "fresh ones" are?
06:22:59 <roconnor> Anyone going to ``what the hack''?
06:25:16 <pesco> pipe: fresh ones? Maybe what [1,1..] is made of?
06:25:44 <pipe> no, i am serious :\
06:25:52 <pesco> pipe: Oh no, of course, those are old ones!
06:26:04 <pesco> roconnor: Yes, I am.
06:37:01 <samc_> “fresh ones” in what context?
06:39:45 <pipe> some kind of product
06:41:03 <pipe> i think it might be those moist paper towels that are packed in ketchup like plastics
06:41:30 <samc_> dunno
06:43:13 <pesco> Oh, this is not about programming. :)
09:40:05 <vegai> so, hey.
09:52:28 <maihem> If I have a name bound to a constructor, how do I use that to pattern match? ie fn1 foo bar = case bar of { foo -> True; _ -> False } this rebinds foo in the scope of the particular case match and the two cases overlap, but I want to get true if bar is bound to the same thing as foo. the type of foo is not an instance of Eq. Is this possible?
09:53:16 <pesco> No.
09:53:25 <maihem> bugger.
09:54:39 <pesco> You could define  fn1 Foo Foo = True; fn1 Bar Bar = True; fn1 _ _ = False  but then fn1 _is_ your Eq instance. See?
09:55:27 <maihem> Not quite, I'll have to think a while :)
09:55:45 <pesco> After all you _are_ asking about equality of foo and bar. Why not define (==)?
09:59:09 <maihem> Hm, I think I can do it without overburdening the user of my function since they already have to make Foo an instance of my class StateMachine, so I can make a default "shallow" (==) for that class
10:01:45 <wilx`> Bah, confusion. What is the difference between Control.Monad.ST and Control.Monad.State? Apparently Control.Monad.ST doesn't have get/put.
10:03:16 <pesco> maihem: Whatever suits your need. But if in the end it _is_ equality you need, I think you should require Eq.
10:05:29 <TheHunter> wilx`, State maintains a state of one single type s. ST allows you to make an arbitrary number of references (STRefs) or mutable arrays.
10:05:53 <wilx`> Oh.
10:06:06 <wilx`> *searches for STRef docs*
10:07:25 <maihem> pesco, I want a type like (this is slightly simplified for brevity) data T a = T a a {-value and endvalue-}; then fn1 (T v end) = {True if v is end, and false if v is not end} can I do this with pattern matching only if I do {fn1 (T end end) = True; fn1 (T _ _) = False} ?
10:08:38 <palomer> does GHC use CPSification?
10:10:05 <TheHunter> no, why should it?
10:10:05 <pesco> maihem: No, but I strongly suspect there is a way to do this pretty.
10:13:09 <maihem> pesco, I am doing a StateMachine compositing module, I think that I need to define a CompositableStateMachine, so I could put an isEnd function in it I suppose. That wouldn't be too overburdening, and should even enhance the interface with a little declarative style sanity checking at compile time too.
10:13:28 <maihem> so perhaps it won't be an issue after all
10:14:30 * maihem also wishes there was a way to define recursive data types if you specify a maximum recursion length
10:14:55 <wilx`> Huh.
10:15:40 <wilx`> Sounds like you want to make a clearly run time feature a compile time feature to me...
10:16:08 <wilx`> I.e. checking a depth of your data structure.
10:17:03 <TheHunter> fwiw,
10:17:06 <TheHunter> @wiki SimulatingDependentTypes
10:17:06 <lambdabot> http://www.haskell.org/hawiki/SimulatingDependentTypes
10:17:28 <wilx`> fwiw?
10:17:49 <TheHunter> for what it's worth.
10:18:40 <wilx`> I see.
10:21:10 <maihem> wilx` so you *have* to define an infinite repeating structure and you can force a listish thing that is like l = (Left a):(Right b):l, but without permitting l = (Left a):(Left a):(Right b):l, or l = []
10:21:42 <musasabi> wilx`: look at Data.STRef
10:22:11 <musasabi> maihem: you can do finitelength lists etc on the typelevel.
10:22:22 <musasabi> maihem: see e.g. haskelldb for one way of doing it.
10:24:50 <maihem> no, I mean so the datatype is defined in terms of itself. I used the wrong term "recursion length". I meant where you specify that the type will simply repeat before a certain depth of types are used, or terminate, otherwise the compiler can't determine whether it will complete the compile or not :)
10:25:50 <Keiven> http://www.tcpsecurity.com/
10:25:53 <musasabi> data Foo bar = Term | Foo bar (Foo bar)
10:26:18 <maihem> hm, so you *can* do it!?
10:26:29 * maihem slaps wimhelf with a hot battered haddock
10:26:33 <pesco> maihem: Even if the end states in your finite state machines are fixed at compile-time, if you're composing them at run-time, then that necessitates making end states a run-time thing, too.
10:26:34 <musasabi> maihem: isn't that more or less the same as the definition of a list?
10:27:02 <pesco> maihem: What is your representation of a finite state machine?
10:27:25 <maihem> pesco, so far not finished since I'm not very good with Haskell
10:27:42 <pesco> Do you have any basic idea?
10:27:43 <maihem> musasabi, I think I'm just being an idiot, forget I every thought of it :)
10:28:22 <maihem> pesco, here is a non working test file: http://maihem.org/sm.hs
10:36:00 <pesco> In your code you define a class StateMachine whose only method transit has nothing to say about end states at all.
10:36:35 <pesco> Wouldn't you agree that determining whether the machine is in an end state is a fundamental operation over all state machines?
10:36:38 <maihem> no, I am now changing that :)
10:36:45 <pesco> OK.
10:37:26 <pesco> Also what about failure? If a state does not have an exit for some input?
10:37:39 <pipe> anyone know epigram?
10:37:49 <maihem> pesco, a state machine does something on every input even if it just loops back to the same input
10:38:57 <pipe> what to do about "Haskell guilt"?
10:39:01 <ibid> if a state machine has no transition from a particular state for particular input, then if that situation happens, the machine is stuck
10:39:10 <pesco> pipe: What is Haskell guilt?!
10:39:36 <maihem> a composable state machine will have a sink on some input when in some state, that will lead to one of (possibly) several end states that require a noncomposable state machine to be attached to form a complete statemachine
10:39:59 <pipe> pesco: it's a consequence of prolonged exposure to dependently typed programming, the feeling that you're lying to the compiler just to get your program to work
10:40:33 <pesco> pipe: Interesting. Care to give an example? What kind of lies?
10:40:44 <ibid> pipe: don't you get that in any statically (non-dependently) typed language then?
10:40:50 <maihem> and yes a full state machine never terminates. it gives out events when it transits, it is the responsibility of the program using the state machine to see any important events and stop feeding triggers.
10:40:52 <pipe> ibid: yep
10:41:29 <pipe> ibid: i guess the fact that it's called "*Haskell* guilt" is a compliment for haskell, since haskell has one of the best non-dependant type systems
10:41:55 <ibid> maihem: isn't a state thingy that gives out events a transducer, not a state machine?
10:42:40 <maihem> ibid, only if a state machine is only useful for describing predicates
10:42:43 <pipe> pesco: like when you have to use unsafeCoerce
10:42:53 <ibid> maihem: that's what it is :)
10:43:02 <maihem> otherwise the only output a state machine has is whether it has terminated or not
10:43:25 <ibid> maihem: a state transducer, however, is essentially a predicate over sequences of input-output pairs
10:43:31 <ibid> maihem: that's what state machine is :)
10:43:39 <musasabi> what about modelling the state machine as a directed graph?
10:43:57 <maihem> ibid, then I am writing state transducers :)
10:44:00 <ibid> :)
10:44:05 <samc_> pipe, what dependently typed language have you had prolonged exposure to, and what sort of things did you write in it?
10:44:42 <pipe> samc_: i actually don't really understand what non dependant types mean really... i'm looking for someone who does :D
10:44:59 <pipe> samc_: in fact i barely even know haskell :P
10:44:59 <maihem> musasabi, I am doing. I make instances of (what is now) class StateTransducer :) which implement transit currstate trigger = (nextstate,[event]) for all possibly currstate and trigger combinations
10:45:17 <ibid> pipe: non-dependent types are essentially conservative estimates of the values that one can get :)
10:46:04 <pipe> hm...
10:46:20 <pipe> that's the part where my brain goes mish
10:46:28 <ibid> hm?
10:46:42 <pipe> indeed
10:46:51 <palomer> MISH
10:46:55 <maihem> um transit :: StateTransducer state trigger event => state {- currstate-} -> trigger -> (state {-nextstate-}, [event])
10:46:57 <ibid> a usual mental model is to think of types as sets from which the values will be found
10:47:13 <pipe> right
10:47:34 <samc_> pipe, so where does the term "haskell guilt" come from?
10:47:52 <ibid> pipe: can you now elaborate on the mishness?:)
10:47:53 <pipe> samc_: Conor McBride
10:48:04 <samc_> oh, ok
10:48:18 <pipe> ibid: ok, i guess i understand that sentance
10:51:02 <ibid> pipe: another point to remember is that the goal is to find as good conservative estimate as one can while still staying decidable
10:51:07 <musasabi> maihem: why do you need a class?
10:51:16 <ibid> pipe: and that's the basic tension of type system design :)
10:51:56 <pipe> so what are non-dependant types?
10:52:03 <musasabi> maihem: type StateTransducer input output = input -> (output,[Event])
10:52:04 <maihem> because of the functional dependency: class StateTransducer state trigger event | state trigger -> event
10:52:23 <ibid> pipe: dependant typing as i understand it break that by allowing undecidedness :)
10:52:42 * maihem caresses -fglasgow-exts
10:53:03 <ibid> pipe: but i'm not very well versed on dependant typing
10:53:50 <pipe> ibid: i'm trying to read this epigram paper but i don't understand anything at all
10:54:01 <ibid> which?
10:54:08 <pipe> http://www.dur.ac.uk/CARG/epigram/epigram-afpnotes.pdf
10:56:15 <ibid> you don't understand what about it?
10:56:21 <pipe> all of it
10:57:23 <ibid> blah :)
10:57:26 <ibid> can't help you then
10:57:40 <ibid> (unless you can analyze your non-understanding)
10:57:47 <ibid> (and maybe not even then:)
10:58:18 <pipe> is "Categories for Types" by Roy Crole a good book?
10:58:31 <ibid> never read
11:01:49 <pipe> haskell is out
11:01:52 <pipe> epigram is in
11:02:35 <samc_> if you want to program in an interactive theorem prover ;)
11:04:14 <maihem> epigram is in when I can use it from vim
11:04:24 <maihem> or ed :)
11:04:32 <gzl> how is epigram in already?
11:06:36 <palomer> pipe: I have that book in front of me
11:06:37 <palomer> pure crap
11:07:18 <pipe> palomer: hm... really?
11:07:23 <palomer> yes
11:07:27 <samc_> sounds harsh
11:07:29 <pipe> crap, i've started reading it
11:07:39 <palomer> pipe: and do you like it?
11:07:45 <palomer> I should write a bibliography on this stuff
11:07:48 <pipe> so far so good
11:07:48 <palomer> since it is in my field
11:07:52 <palomer> what do you want to know?
11:08:09 <pipe> just want to be a better programmer
11:08:23 <palomer> oh wait,  Iwas thinking Categories, Types, and Structures
11:08:26 <palomer> which is pure crap
11:08:41 <pipe> this book is from cambridge
11:09:12 <palomer> oh, this book looks yummy
11:09:23 <palomer> pipe: I recommend you first read "category theory for computer science"
11:09:32 <pipe> i want something hardcore
11:10:05 <palomer> do you know any category theory beforehand?
11:10:27 <pipe> not really
11:10:39 <pipe> don't really know any math
11:11:18 <palomer> righto
11:11:27 <palomer> so you might get a little confused when they start talking about categories
11:11:34 <palomer> category theory for computer science is hard core
11:11:39 <palomer> note, however, that it has no type theory in it
11:11:44 <pipe> i think i ordered benjamin pierce's other book also, but amazon screwed up my order
11:12:00 <pipe> can't bye any books in this country
11:12:18 <palomer> if you want REALLY hardcore
11:12:20 <palomer> get krivine's book
11:12:24 <samc_> from AoP "One does not so much learn category theory as absorb it over a period of time."
11:13:17 <samc_> there are quite a few category theory introductions online
11:13:28 <palomer> samc_: oooh, gimme
11:13:29 <pipe> i think i'll continue reading this book
11:13:47 <palomer> AoP?
11:14:15 <samc_> "Algebra of Programming" by Bird and De Moor
11:14:41 <palomer> any good?
11:17:34 <samc_> I haven't read much yet, but so far yes
11:19:41 <palomer> what's that well known book...
11:19:51 <palomer> it ends with "of programming languages"
11:20:14 <samc_> structure and interpretation of?
11:20:29 <palomer> are you thinking of the SICP?
11:20:37 <palomer> nono, it's written by friedman
11:20:49 <palomer> (who, incidently, teaches at my university)
11:21:08 <samc_> oh whoops
11:21:33 <_JusSx_> i wonna learn haskell but it seems it lacks of good tutorial manual or book online
11:22:08 <samc_> palomer, you wanted to know about category theory introductions available online?
11:22:16 <palomer> samc_: yes!
11:23:13 <Lemmih> _JusSx_: Have you seen YAHT?
11:23:20 <_JusSx_> yeah
11:23:23 <_JusSx_> i read it
11:23:31 <_JusSx_> it isnt so good
11:24:04 <Lemmih> How so?
11:24:55 <_JusSx_> i need a reference manual
11:25:00 <_JusSx_> too
11:25:11 <Lemmih> _JusSx_: For the Haskell standard libraries?
11:25:17 <_JusSx_> yeah
11:25:31 <tuomov> http://www.haskell.org/ghc/docs/latest/html/libraries/
11:25:32 <tuomov> ?
11:26:43 <dd> www.otomotivshow.com
11:27:03 <tuomov> where have all these spammers come from in the recent days?
11:28:41 <_JusSx_> what about haskell user guide?
11:32:29 <MachinShin> hey +
11:34:13 <palomer> anyone recall a long introduction to the curry howard isomorphism?
11:35:42 <_JusSx_> now it quite better
11:41:44 <_JusSx_> wow really great haskell
11:42:22 <Lemmih> Indeed (:
12:00:54 <samc_> palmomer, you have probably remembered but "essentials of ..."
12:01:06 <samc_> oops palomer
12:03:55 <jlouis> palomer: Pawel urcyczyn + Morten Heine B Soerensen: Lectures on the Curry-Howard isomorphism
12:04:23 <jlouis> I have it in a paper version somewhere. But maybe it is downloadable on the net
12:49:25 <dd> www.otomotivshow.com
13:15:56 <lightstep> if ghc says "Failed to load interface file for `Prelude'" when i tell it -prof, does it mean that i can't compile with profiling? if so, where can i get the missing interface files (on debian)?
13:16:50 <TheHunter> apt-get install ghc6-prof, iirc
13:16:50 <Lemmih> Install ghc-prof.
13:17:10 <lightstep> will it be able to compile without profiling, too?
13:17:20 <_JusSx_> where can i find haskell examples?
13:17:21 <TheHunter> sure.
13:17:43 <lightstep> 51MB?!
13:19:18 <lightstep> _JusSx_, pugs is full of them
13:19:31 <lightstep> or browse the wiki
13:19:53 <xerox> @wiki ShortExamples
13:19:53 <lambdabot> http://www.haskell.org/hawiki/ShortExamples
13:20:19 <Lemmih> Or search the web. (googling before asking is an unwritten rule)
13:25:30 <maihem> Can anybody help (ghc): I'm getting "sm.hs:6: Type variable not in scope: `e'", "sm.hs:6: Type variable not in scope: `i'", then the message about e again twice, and again about i. This is line 6: "data StateTransducer st t e i => Transit st t = [e] :-> st | [e] :| i"     StateTransducer is a class: "class StateTransducer s t e i | s t -> e, s t -> i"
13:26:43 <TheHunter> contexts in data declarations don't mean anything.
13:27:35 <maihem> ah, so the type must be Transit st e i = [e] :-> st | [e] :| i ?
13:28:00 <TheHunter> maybe you want existential quantification:
13:28:25 <TheHunter> data Transit st t = forall i e. StateTransducer st t e i => [e] :-> ...
13:29:32 <maihem> ooh.
14:01:18 <Oejet> Good evening, Haskell, Perl and Ruby people.
14:02:56 <Philippa_> and a really bad one to Java people?
14:03:14 <Philippa_> actually no, if they're using Java they're probably having a bad evening already
14:03:52 <Oejet> Philippa_: Yeah, I don't want to be an asshole.
14:05:04 * ibid is actually writing Java right now
14:05:08 <ibid> and it's evening :)
14:05:21 <ibid> hm, night, to be precise
14:06:57 <Oejet> And I haven't met anyone in here who said the were avid Java users interested checking this cool language Haskell out.
14:07:10 <Itkovian> Oejet: wel ...
14:07:25 <xerox> 'night folks.
14:07:37 <integral> java and python just seem to be able to communicate their badness subconsciously
14:07:54 <palomer> I'm an avid sml user interested in checking this cool language haskell out
14:08:33 <palomer> and I can breakdance
14:13:54 <Khisanth> Oejet: well it was between Haskell and Common Lisp :)
14:14:25 <Oejet> Khisanth: What is your experience with Common Lisp?
14:14:27 <gzl> what's so bad about python?
14:14:41 <Oejet> gzl: It sucks big time.
14:14:52 <Khisanth> Oejet: none!
14:14:59 <gzl> i asked why it was bad, not whether it was bad. :)
14:15:07 <Khisanth> Oejet: I was replying to "<Oejet> And I haven't met ..."
14:15:47 <palomer> python programmers eat babies
14:15:48 <Itkovian> Oejet: why exactly does python suck?
14:16:01 <Oejet> Khisanth: So you flipped a coin and tried Haskell?
14:17:09 <Khisanth> Oejet: didn't even consider Haskell but then pugs popped up :)
14:17:15 <mauke> "Haskell" > "Common Lisp", according to ghci
14:17:26 <gzl> haha
14:17:32 <Oejet> mauke: Point taken.
14:17:35 <Khisanth> hmm pythons have been known to swallow people
14:17:36 <palomer> "sml" > "haskell"
14:18:07 <gzl> "python" > "haskell" too
14:18:14 <lightstep> SML is an acronym, so it should be capitalized
14:18:28 <palomer> "SML" > "Haskell"
14:18:43 <gzl> Oejet: yeah, so what don't you like about it?
14:19:27 <TheHunter> "haskell" > "SML" > "python" > "java" :)
14:19:46 <palomer> "scheme" > "haskell"
14:19:53 <Oejet> TheHunter: "haskell" > "SML" > "python" >> "java"
14:19:56 <palomer> "shakespearelang" > "haskell"
14:20:50 <Oejet> gzl: Because they use __methodname__ names.
14:21:05 <TheHunter> nonono, "SML" > "scheme"
14:21:52 <gzl> Oejet: that's it?
14:22:36 <Itkovian> Oejet: ah, and therefore it sucks?
14:23:04 * TheHunter never understood how people can program in untyped languages.
14:23:11 <Oejet> It sucks.
14:23:26 <mauke> are there any untyped languages?
14:23:42 <Oejet> Everything sucks,...Java just sucks less.
14:23:47 <gzl> mauke: assembly.
14:23:51 <gzl> sort of.
14:24:16 <TheHunter> dynamically typed and untyped sounds the same to me.
14:24:23 <palomer> nonono
14:24:40 <palomer> untyped = C, where something doesn't know its own type
14:24:51 <mauke> no, dynamically typed means there is a runtime type system
14:25:00 <gzl> yeah, i was going to say C too.
14:25:05 <gzl> it's so loose.
14:25:05 <TheHunter> palomer, then haskell and sml are untyped, too.
14:25:13 <musasabi> evening.
14:25:14 <gzl> ?
14:25:16 <MachinShin> hey mauke, what're you doing here? :)
14:25:17 <Oejet> C is strongly typed.
14:25:18 <gzl> I thought Haskell was statically typed
14:25:26 <gzl> C is strongly typed?
14:25:31 <Oejet> Yes.
14:25:38 <mauke> "something knows its type" == there's runtime type information
14:25:43 <musasabi> haskell > sml ? ocaml > > ruby > python > java
14:25:48 <mauke> I'd say C is statically/weakly typed
14:25:51 <musasabi> grah. no.
14:25:58 <musasabi> haskell > sml ? ocaml > ruby > python > java.
14:26:16 <mauke> MachinShin: I'm learning a bit of haskell
14:26:21 <musasabi> depends how one defines weak typing.
14:26:27 <MachinShin> mauke: same here :P
14:26:29 <mauke> blame autrijus and pugs
14:26:39 <Oejet> Perl sucks.
14:26:55 <mauke> (... it just sucks less)
14:27:09 <Oejet> No, that was Java.
14:27:25 <mauke> hahaha
14:27:29 <gzl> Oejet: you need to give reasons. just saying stuff sucks is boring. :)
14:27:49 <palomer> unlambda uber alles
14:27:59 <Oejet> gzl: No, reasons suck.
14:28:06 <palomer> gzl:D
14:28:14 <TheHunter> gzl, for one, it's "dynamically typed".
14:29:03 <musasabi> What is a good definition of strong/weak typing?
14:29:08 <gzl> haha
14:29:56 <gzl> I would say a weakly typed language allows you to use values as different types
14:30:15 <musasabi> like haskell?
14:30:20 <musasabi> unsafeCoerce#
14:30:33 <gzl> I don't know about unsafeCoerce#, but I was thinking more along the lines of what C lets you do.
14:30:52 <Cale> unsafeCoerce# isn't part of the language spec, afaik
14:30:58 <Oejet> gzl: Like Java?
14:30:59 <musasabi> well most languages have in practise a such hole.
14:31:19 <gzl> i'd consider java strongly typed
14:31:44 <Oejet> gzl: Ah, and also every container type?
14:31:45 <musasabi> of course their standards may lack it but most implementations offer such hole - one way or another.
14:32:19 <gzl> in C there's no specific type violation mechanism; you just get segfaults or messed up behavior. in Java it whines about type mismatches
14:33:08 <gzl> I mean, there may be flaws in what I'm saying, I'm just making a suggestion
14:33:13 <tuomov> hmm.. strange..
14:33:28 <tuomov> I tried changing strong storage to PackedString in riot to keep memory consumption down
14:33:37 <musasabi> gzl: actually C just has documented ways of producing undefined behaviour.
14:33:46 <tuomov> but it appears that whenever I save the data, it starts wasting 20M of memory
14:33:52 <gzl> ...what's your point?
14:34:04 <tuomov> that it doesn't need until that point
14:34:06 <gzl> it doesn't really do type checking
14:34:15 <gzl> that's all i'm saying
14:34:42 <musasabi> gzl: it does. something like forth on the other hand would qualify I think. (and varargs for C)
14:35:20 <mauke> and the X * -> void * -> Y * conversion
14:35:39 <tuomov> is there some way to force GC?
14:35:57 <musasabi> point.
14:36:20 <gzl> musasabi: i think if you can do char *s = "foo"; char x = s; it's not really doing much in the way of typechecking.
14:36:21 <musasabi> System.Mem.performGC
14:36:21 <palomer> is the haskell grammar context free?
14:36:40 <mauke> gzl: you can't do that here
14:36:56 <gzl> it gives me a warning but goes ahead and compiles it.
14:37:22 <gzl> it does a little typechecking, yes, but it lets you switch around types in a way some of these other languages don't
14:37:47 <mauke> use -Werror then
14:37:51 <musasabi> gzl: hmm that is true, I didn't remember that those were only warnings not errors.
14:37:54 <mauke> (or equivalent)
14:38:08 <musasabi> then by all definitions C goes into the category.
14:38:21 <mauke> the C standard only specifies "diagnostics", not errors or warnings
14:38:44 <gzl> mauke: -Werror adds no extra information
14:38:46 <gzl> (here)
14:39:12 <mauke> but it refuses to compile
14:39:15 <gzl> mine compiles
14:39:39 <gzl> oh, wait. no it doesn't
14:40:10 <gzl> but i think you're splitting hairs
14:40:29 <tuomov> doesn't seem to help..
14:40:55 <cm> !
14:41:08 <Lemmih> tuomov: Try following it with a yield.
14:41:18 <mauke> this is about a specific implementation, not the C language itself
14:41:18 <tuomov> yield?
14:41:27 <Lemmih> @index yield
14:41:29 <lambdabot> Control.Concurrent,GHC.Conc
14:42:19 <gzl> I'm only talking about the language, and the point is just that C clearly does not enforce type rules as strongly as many other languages because it lets you futz with memory in a way many other languages don't.
14:42:37 <gzl> i think what i'm saying is common knowledge
14:44:04 <tuomov> doesn't help
14:44:19 <tuomov> I wonder if writeFile leaves some references
14:45:45 <Oejet> C++ is too complicated.
14:46:06 <gzl> i agree
14:46:10 <cm> nooo :)
14:46:54 <Philippa_> it's tempting to write an eager functional language with regions and no GC as a replacement for C++
14:47:25 <cm> it's challenging to write a replacement for C++ people will actually use :|
14:47:30 <palomer> :|
14:47:49 <Oejet> It's challenging even to implement C++.
14:47:50 <palomer> you may be a lover but you aint no dancer
14:48:07 <cm> \o/
14:48:16 <ibid> palomer: like cyclone? (well, not functional exactly, but...)
14:48:24 <ibid> sorry, meant Philippa_ :)
14:49:01 <Philippa_> ibid: may I add a less vomitworthy syntax to the requirements? :-)
14:49:28 <ibid> Philippa_: then it wouldn't fit the bill of a c++ replacement :)
14:49:38 <Philippa_> heh
14:50:11 <cm> but wouldn't that be one of the few reasons why one would want to switch away from C++ for C++-esque tasks?
14:50:11 <ibid> i mean, i have many times tried to design a clean c-like syntax... always ended up with something that looked more like haskell than c :)
14:50:57 <cm> at least you didn't end up at D
14:51:00 <ibid> cm: if you are willing to let go of the syntax, there are already other lajnguages :)
14:51:07 <integral> if you do invent a C++ replacement, please, please don't require a big fancy GC :-)
14:51:07 <cm> I don't think so
14:51:11 <ibid> cm: well, d looks like a rather boring language
14:51:19 <cm> O'caml doesn't even come close
14:51:23 <Philippa_> integral: this is why region-based
14:51:38 <integral> *nod*
14:51:48 <Oejet> integral: Why no GC?
14:51:52 <ibid> Philippa_: note how cyclone people originally had only regions but later added a gc region based on usage experience
14:52:13 <integral> Oejet: for very low-level systems programming
14:52:14 <Philippa_> ibid: yeah, I know
14:52:20 <Philippa_> they're not the only folks to do that either
14:52:30 <integral> Oejet: with C you can start using it just after the bootloader has setup the processor and given you just a stack
14:52:41 <integral> Oejet: you can then code the GC in C itself, and switch to it
14:52:58 <Philippa_> well yeah, but you can't write a good GC for C
14:53:23 <integral> well you also switch to Haskell at that point ;-)  But you still need that little glue of C to get there
14:53:39 <Oejet> Apple should have bought Be Inc.
14:53:49 <wagle> nah, its just really hard to write a good gc for C
14:54:05 <wagle> Oejet: o_O
14:54:08 <wagle> darn
14:54:30 <tuomov> there's probably some useless memoization going on
14:54:43 <tuomov> when does ghc do that?
14:54:59 <Philippa_> wagle: by the time you have system calls and stuff going on, and assuming values of good that collect all garbage, it's impossible AIUI
14:55:18 <wagle> AIUI?
14:55:22 <Philippa_> As I Understand It
14:56:19 <ibid> but actually for practical purposes you don't usually need to collect all of the garbage, as long as the size of the floating garbage is small and constant
14:56:29 <ibid> well, bounded
14:57:10 <cm> "GC'ed languages are egoistical!"
14:57:38 <ibid> even in state of the art "non-conservative" collectors, you end up with a fair amount of uncollected garbage
14:58:06 <ibid> because they tend to ease the pain of the pause by doing less of it more often :)
14:58:10 <wagle> Philippa_: i did say "hard"
14:58:45 <Philippa_> ibid: those are known to be able to bag the lot in case of dire heap shortage though
14:59:05 <Philippa_> wagle: and I said 'can't' which you disagreed with :-)
14:59:23 <ibid> Philippa_: well, if it matters, you will have designed the system so that you know that the heap is sufficient, in any case :)
15:00:11 <luqui> anybody know parsec pretty well?
15:00:41 <wagle> i've thought long and hard about adding memory layout awareness to gcc..  the fight is mostly against the size of the source (needing huge amounts of refactoring) and the gcc developers who really dont wanna add memory layout awareness to the optimization code
15:01:02 <maihem> Can anybody explain the compile-time error at the bottom of this: http://maihem.org/sm.hs --- I can't figure out why it's trying to unify the type variables like that.
15:01:04 <wagle> i would agree with "way way too painful"
15:01:54 * ibid wants user-space control of paging :)
15:02:10 <ibid> would make easier to make a gc that interacts well with gc
15:03:13 <wagle> sometimes i imagine ways to get gcc to rewrite itself into a language that you can actually write compilers in
15:03:44 * ibid is slowly writing a C compiler
15:04:07 <cm> ibid: ..why!? :)
15:04:25 <ibid> cm: because it's there? :)
15:04:39 <cm> :|
15:04:41 <ibid> cm: (why do people climb mountains)
15:04:54 <monochrom> because you can only do it slowly, you can't do it quickly.
15:05:07 <cm> ibid: because of the nice fresh air at the top ;)
15:05:10 <wagle> ibid: why do people make mountains out of molehills?
15:05:35 <monochrom> why do people study math?  *duck*
15:05:41 <ibid> by "slowly" i meant that it's not at the top of my priority list, so it gets processor time not so often :)
15:05:49 <luqui> *goose*
15:05:53 <wagle> monochrom: shopping is hard.  lets do math!
15:06:22 <Philippa_> Being brainwashed is hard, let's play with ourselves instead? ;-)
15:06:32 <ibid> wagle: a c compiler is a molehill?
15:06:37 <cm> lol :)
15:06:40 <TheHunter> maihem, try providing an explicit signature for `chain'
15:06:48 <maihem> k
15:08:32 <wagle> ibid: compilers are molehills.  gcc is a rube-goldberg machine the size of a mountain range.
15:08:39 <ibid> heh
15:08:48 <wagle> (can you tell that i have a love-hate thing with gcc?)
15:08:49 <ibid> rube-coldberg machine?
15:09:00 <luqui> coldberg?
15:09:06 <ibid> g
15:09:06 <luqui> ahh
15:09:40 * luqui ponders making a joke about icebergs...
15:09:46 * luqui but resists
15:10:33 <cm> :D
15:10:40 <ibid> seriously, i am a little bothered that there is not really any choice if you're choosing a free c compiler
15:10:52 <ibid> basically, it's either gcc or tcc
15:10:55 <wagle> UTGL (use the google, luke)
15:10:57 <ibid> and tcc is a dead end
15:11:03 <cm> free as in RMS?
15:11:12 <ibid> hackers, this is good :)
15:12:35 * esap thinks not many people want to write C compilers. HW vendors maybe, but I don't think there is much interest in writing compilers for languages where good compilers already exist.
15:13:15 <Khisanth> unless you have a sufficiently large ego :)
15:14:53 * ibid has a preprocessor already
15:15:13 * cm is scared enabling DMA on his server
15:15:31 <maihem> TheHunter, well, I got a *fuller* set of error message ;)
15:15:32 <wagle> starting C compilers is easy..  finishing and maintaining them is hard
15:15:36 <cm> (it is located about an ocean's width away from him, and last time he tried it messed up)
15:15:58 <esap> wagle: Starting anything is easy.
15:16:52 <esap> wagle: And maintenance is hard only because it needs lots of time, which most people can't afford.
15:16:59 <wagle> i was mostly reflecting on the number of "gcc replacement" c compilers that are either dead, or might as well be
15:17:59 <ibid> there are those?
15:18:40 <wagle> also in the context of trying to get grants..
15:18:44 <TheHunter> maihem, that is good, maybe one of them points you closer to the problem.
15:19:13 <wagle> i dont think i can get a grant to replace gcc.  i can get one to hack gcc..
15:19:29 <maihem> yeah, so I'm writing an explicit type signature for transit too
15:19:52 <TheHunter> maihem, sadly, that's not allowed.
15:20:05 <ibid> now, my cc project is just a hobby, an educational experience, but i try to make it in such a manner that it won't be stillborn if it ever gets finished
15:21:03 <wagle> most academic results are "we got it to compile this one fragment, sorta"
15:21:20 <ibid> :)
15:22:25 <wagle> i raised the bar with "we recompiled all of redhat, and here it is, running on my notebook and primary machine, which i'm doing my presentation from.  and it doesnt crash."
15:22:51 <ibid> you've written a c compiler?
15:23:06 <monochrom> does your build run faster?
15:23:12 <wagle> hacked gcc
15:23:24 <TheHunter> maihem, it often helps to replace parts of your code with `undefined' when chasing weird type errors.
15:23:40 <wagle> to detect stack smash attempts
15:23:54 <monochrom> Ah, it is more secure.
15:24:00 <wagle> then to detect integer wrap and pointer overwrites
15:24:01 <maihem> Oh, so that particular bit doesn't cause the problem ?
15:24:06 <maihem> thanks
15:25:08 <maihem> I've introduced a foo so transit = foo where foo :: blah; foo = etc... so I can get around the transit type sig not allowed thing.
15:25:45 <Oejet> Why do all the cool people hang out in #haskell?
15:25:52 <maihem> The error is unchanged, so the compiler is getting the type of transit correct
15:25:56 <ibid> #haskell is hip :)
15:26:13 <maihem> which I suppose is probably guaranteed by the class definition, so I just wasted a bunch of keystrokes :/
15:26:24 <Oejet> Way of the day.  It's fashion, baby.
15:26:34 <wagle> "clarity" > "keystrokes"
15:26:38 <wagle> 8)
15:27:03 <wagle> maihem: i dont understand the problem
15:27:04 <maihem> You haven't seen the tpe signature 8-o
15:27:31 <Oejet> GCC sucks.
15:27:37 <Pirate> is there a built in Int -> String function in haskell?
15:27:43 <maihem> wagle, the problem is I'm trying to write some haskell which is far beyond my current Haskell skill level.
15:27:43 <Oejet> Pirate: show
15:28:26 <Oejet> maihem: Using the FFI or STM?
15:29:02 <maihem> nope (STM -> State Transformer Monad ?)
15:29:43 <TheHunter> STM = concurrency stuff.
15:30:03 <cm> superduper transactional memory
15:30:16 <tuomov> hmm.. the AntiMemo code from darcs isn't of any help either
15:30:16 <TheHunter> maihem, if you update you signaturized code, i'll have a look at it again.
15:30:46 <maihem> I've taken out the transit sig, do you want it in there?
15:30:54 <maihem> undo is easy
15:31:04 <wagle> maihem: "transit = etc" doesnt work, but "transit = foo where foo :: blah; foo = etc'" does?
15:31:11 <maihem> yeah
15:31:14 <wagle> (and whats the relation between etc and etc'?
15:31:22 <TheHunter> probably easier with it.
15:31:25 <wagle> )
15:31:41 <wagle> irssi needs a paren bouncer..  8)
15:32:52 <maihem> TheHunter, okay at http://maihem.org/sm.hs
15:33:50 <TheHunter> okey
15:33:52 <maihem> wagle foo = etc means foo is given the definition that transit had, blah is the expected most general type of transit.
15:39:55 <TheHunter> maihem, there's something wrong with the `chains' definitions containing Done.
15:40:03 <TheHunter> if you uncomment them, the errors go away.
15:40:37 <wagle> oh..  transit is an instance
15:41:58 <wagle> you tried both hugs and ghc?  (they handle this differently)
15:42:53 <maihem> not tried hugs
15:43:35 <wagle> humm..
15:43:50 <wagle> what you have there works?
15:44:21 <Oejet> Is Apple using Adam and Eve (from Adobe) in MacOS X?
15:44:28 <maihem> blegh, was about to impress with smug comment about how synaptic was already installing it for me but the debian AMD64 archive has been updated and my package list shows an old version :(
15:46:13 <TheHunter> it's clear that you can't pattern match against Done, because there's no way to know that i is Done.
15:47:14 <maihem> yeah, I put Done in there instead of i, and the compiler told me I had to use -fuse-undecidable-instances or something, so I thought it was wrong.
15:48:17 <maihem> I also want to change the last chain to chain (es :| sink) = es :| sink. but the type needs to be different (just want the same constructor and arguments).
15:49:06 <monochrom> Gosh, :| should be an emoticon, not an operator
15:49:45 * monochrom writes a book "Point-free Emoticon-oriented programming using Haskell"
15:49:55 <maihem> TheHunter, what did you mean "if you uncomment them, the errors go away."
15:51:12 <TheHunter> the lines containing `Done'. And the second chain signature is  wrong.
15:51:31 <TheHunter> you wanted instance (StateTransducer a t e Done, StateTransducer b t e Done)
15:51:31 <TheHunter>     => StateTransducer (Chain a b) t e Done ?
15:52:21 <TheHunter> or something more general?
15:53:25 <maihem> more general  (ie the i' is how I wanted it)
15:53:48 <TheHunter> ah, ok.
15:53:59 <maihem> the StateTransducer that is formed by chaning b after a should have the same interface as b
15:54:03 <TheHunter> Just give him -fallow-undecidable-instances.
15:54:24 <wagle> aww, darn..  the foo trick doesnt evade the "Set Functor" problem..  (not surprising)
15:54:40 <maihem> I still got blasted errors
15:55:22 <TheHunter> "chain (es :| Done) = es :| Done" doesn't make sense now.
15:57:53 <maihem> I've got the interface parameterised on the st and the trigger, since those decide the types of any associated data that more complex interfaces might carry. but the last chain should be something sort of like chain (es :| sink) = es :| sink
15:59:26 <TheHunter> what's the correct sig of the second chain?
16:01:18 <maihem> uhh it should "probably" be chain :: (Transit b e (i' x)) -> (Transit (Chain a b) e (i' x)) where I have yet to work out what x really ought to be
16:01:52 <maihem> x should depend on the type of the state and the trigger (so needs to be in the class definition)
16:02:32 <maihem> but how you see it is the only way I could make the simpler StateTransducer instance (the substitute till next one)
16:02:40 <maihem> ... work...
16:04:12 <maihem> hm, so if I change that signature to what it "should" be, then I can work my way back ! :)
16:04:32 <TheHunter> ok, chain :: Transit a e (i a t) -> (Transit (Chain a b) e (i' (Chain a b) t))
16:05:59 <maihem> I though the i (with no tick) was supposed to be Done (since Done is required of the first in the chain)
16:06:54 <TheHunter> yes, it is.
16:07:36 <TheHunter> now "chain (es :| Done) = es :| Done" makes no sense, since (i' (Chain a b) t) doesn't have Done.
16:09:08 <maihem> no, that really ought to be chain (es :| sink) = es :| sink (the two :| would have to turn out with different types of course)
16:10:04 <maihem> since one the first is Transit b e i and the second is Transit (Chain a b) e i
16:10:11 <maihem> is this the cause of the problem
16:18:00 <TheHunter> you wanna fill the rest with "[] :| ... :| Done" in the second case of the second chain?
16:19:02 <maihem> not sure, but I think I may be making progress, let me put an updated version up
16:19:37 <maihem> http://maihem.org/sm2.hs
16:20:05 <maihem> when uncommenting the problematic instance, it doesn't compile, but the rest seems to make more sense now.
16:20:23 <maihem> ignore the errors at the bottom of the file, those are from the old version (just realised I left them in)
16:22:26 <maihem> oh forgot to convert on of the (i' (Chain a b) t) to (i' x). but still got errors. but getting there, I think :)
16:34:22 <maihem> ARSE!
16:34:49 <maihem> data Chain a b = Chain a b | Chained a should be data Chain a b = Chain a b | Chained b
16:35:04 * maihem hugs hugs
16:35:31 <maihem> still doesn't work, but at least it compiles :)
16:37:55 <maihem> nope, I left the simple version of the main state transducer (m) have uncomment the compound version and it works as expected. yippee!
16:38:12 <maihem> Thanks for the help TheHunter , and wagle for the hugs suggestion
16:38:23 <wagle> what did hugs do?
16:38:51 <wagle> (i've been otherwise occupied, and been unable to follow closely)
16:38:58 <maihem> it gave me clearer error messages that made me realise the complex instance was not the cause of the problem
16:39:15 <wagle> ah good..
16:40:08 <maihem> but TheHunter has taught me a lot about how haskell works, and my program is much better now.
16:45:57 <maihem> is there an undefined Type like there is an undefined value?
16:47:29 <maihem> since my new state transducers all have an interface (where they can terminate in any way that can be represented in the type of the interface), even an interface of type () means a state transducer may terminate. I want to use an "undefined" type to represent that a state transducer *will*not*terminate*
16:49:32 <TheHunter> if you declare Empty using just "data Empty", this type is only inhabitat by bottom.
16:49:54 <maihem> cool, didn't realise you could do that :) thanks
16:50:19 <TheHunter> another option would be forall a. a
16:50:31 <maihem> that's nicer
16:50:40 <heatsink> TheHunter: isn't that undefined?
16:50:54 <TheHunter> heatsink, what?
16:50:54 <maihem> perfect
16:50:59 <heatsink> @type undefined
16:51:06 <lambdabot> undefined :: forall a. a
16:51:11 <maihem> that's exactly what I want
16:51:24 <maihem> an undefined type
16:52:44 <maihem> I can use that as the parameter to the Done type too, which keeps my specifications nice and clean
16:53:49 <TheHunter> say uninhabited/empty/zero, not undefined.
16:56:11 <maihem> oh, okay. of course, they're sets
16:57:52 <bourbaki> moin
16:58:51 <maihem> moin
17:26:11 <cm> hum.
17:26:32 <cm> ghci gets killed on PAX/grsec machine, even tho chpax reports that all protections are disabled.
17:26:35 <cm> ideas?
20:42:10 <tomacorp> How can I learn about complex numbers in Haskell?  I am just learning Haskell and I would like to know if good complex number support is already available.
20:43:50 <Habs24> tomacorp:
20:43:51 <Habs24> http://www.haskell.org/tutorial/numbers.html
20:44:02 <Habs24> http://www.cs.sfu.ca/CC/SW/Haskell/hugs/haskell-library-1.4-html/complex.html
20:46:08 <tomacorp> Habs24:  Thanks!  That second one is just what I was looking for.  I had found the first one and it was a bit sketchy.
20:46:43 <Habs24> No problem dude.
20:59:00 <Cale> btw, the new Haskell Report is here: http://www.haskell.org/onlinereport/
20:59:12 <Cale> (That version of Haskell is out of date)
20:59:49 <Habs24> Really!??!  The Haskell report is out!?!?!
21:01:39 <Cale> uh, it's been out for quite some time :)
21:02:25 <heatsink> this says 2002
21:02:51 <Cale> Yeah, and before that, Haskell 98 I think was completed sometime near the beginning of 1999
21:03:13 <Habs24> No way!?  2002!!!?
21:03:19 <Habs24> Outrageous!
21:03:38 <Cale> Habs24: Is that sarcasm?
21:03:47 <Gahhh> it is totally unexpected
21:04:08 <Gahhh> heh
21:05:40 <Habs24> "Seeing as you are unfamiliar with sarcasm, I shall close the register at this point." - Comic Book Guy
21:06:25 <Cale> heh
21:06:46 <Habs24> So, why is this channel is dead?
21:06:51 <Habs24> *so
21:07:08 <Habs24> 115 people online, and 3 people talking.
21:07:22 <heatsink> because if everyone were talking, it would be chaos.
21:08:31 <Habs24> Good.
21:12:14 <Habs24> Who wants to annoy those aholes in #python?
21:12:18 <Habs24> I've got a bid that's gold.
21:12:29 <heatsink> what's your bid?
21:13:02 <Habs24> It's like a prank call...it varies.
21:46:12 <DarkEagle> hello
21:46:29 <heatsink> hello
21:46:37 <DarkEagle> oh, hi :) whats up
21:46:49 <DarkEagle> i dont need to ask specific questions here do i?
21:46:54 <heatsink> Sorry, I don't understand.  For a list of commands, type @help
21:47:08 <DarkEagle> @help
21:47:09 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
21:47:15 * heatsink is teasing
21:47:16 <DarkEagle> @listcommands
21:47:16 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
21:47:16 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
21:47:16 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
21:47:16 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
21:47:16 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
21:47:16 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
21:47:19 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
21:47:21 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
21:47:23 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
21:47:28 <heatsink> No, you don't need to ask specific questions here.
21:48:01 <DarkEagle> oh, thats good
21:48:09 <DarkEagle> well whats up?
21:48:20 * heatsink is making an interpreter
21:48:27 <DarkEagle> in haskell?
21:48:36 <heatsink> yea
21:49:03 <DarkEagle> i was gonna learn haskell, but then i figured it was too hard
21:49:37 <heatsink> what programming languages do you ahve experience with?
21:49:49 <DarkEagle> is there a haskell compiler with an interface more like notepad, rather than dos/unix?
21:50:05 <DarkEagle> i have experience with basic and thats it
21:50:09 <heatsink> notepad is not much of an interface.
21:50:12 <DarkEagle> and its not very much experience either
21:50:25 <gzl> haha notepad
21:50:29 <DarkEagle> yeah, well, i mean something like visual C++ or dev C++
21:50:43 <gzl> what about notepad do you want? the graphical part?
21:50:45 <DarkEagle> something that has error checking or whatever, but is more like typing out on a white doc...
21:50:54 <heatsink> google for haskell ide
21:50:58 <DarkEagle> yeah, the graphical part
21:51:02 <gzl> emacs could do that, but I dunno if it's what you want
21:51:10 <Lael> mmm emacs
21:51:45 <DarkEagle> can someone link me to emacs? my google is somehow broken, it crashes whenever i try to search for something
21:51:59 <gzl> http://www.gnu.org/software/emacs/
21:52:10 <DarkEagle> thanks
21:52:10 <Lael> o.o   and you are planning on coding ?
21:52:29 <DarkEagle> first of all if that means writing a program, yes
21:52:59 <DarkEagle> second of all, im not very good with jargon, so if you can put anything you plan on saying to me in REALLY simple terms, i might get you
21:54:20 <Lael> huh?
21:54:36 <DarkEagle> does it come in a windows version? i dont have linux...
21:54:45 * heatsink goes to sleep
21:55:01 <Lael> xemacs
21:55:37 <DarkEagle> www.google.com
21:55:44 <DarkEagle> (for me)
23:14:26 <musasabi> morning
