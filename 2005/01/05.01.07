00:29:40 * shapr boings
00:34:43 <Itkovian> we have this cat stalking our yard: http://www.elis.ugent.be/~ageorges/elias-2004_12_28-16_53_13-1280-960.jpg
00:34:49 <Itkovian> now way I'm letting him in
00:34:56 <Itkovian> s/now/no/
00:35:22 <shapr> cute cat, cuter child :-)
00:35:40 <shapr> hiya viirya 
00:35:46 <viirya> hi
00:35:49 <Itkovian> it's a fell beast ... likes to bite, for play, I'm sure, but it hurts nonetheless
00:35:50 <shapr> Looking for Haskell info?
00:36:01 <viirya> ya :)
00:36:51 <shapr> Are you learning Haskell? or do you have specific questions about using it?
00:37:03 <viirya> just have a first look for Haskell
00:37:11 <shapr> @wiki HaskellDemo
00:37:11 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
00:37:49 <viirya> don't have some sense about it.
00:38:06 <viirya> hmm
00:39:44 <Itkovian> anybody succeeded in compiling this: http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/hs-fltk/example/hirc_fltk.hs ?
00:39:44 * SamC_ has a working yi :)
00:41:15 * SamC_ doesn't like the look that cat is giving the baby
00:42:05 <Itkovian> heh, neither do we, but I thought it makes an awesome pic
00:43:05 <Itkovian> ghc -package-conf ~/.ghc-packages -package FLTK hirc_fltk.hs yields:
00:43:12 <Itkovian> hirc_fltk.hs:39: Variable not in scope: `wait'
00:43:17 <Itkovian> hirc_fltk.hs:78: Variable not in scope: `coords'
00:43:22 <Itkovian> am I missing something?
01:14:25 <shapr> Itkovian: are you using ghc 6.3?
01:15:50 <shapr> viirya: there's lots of good stuff on the learning Haskell page.
01:17:44 <Itkovian> shapr: ah, nope. 6.2 
01:18:07 <Itkovian> no ebuild for > 6.2 yet that are stable.
01:23:37 <Itkovian> shapr: is the latest 6.3 snapshot functional (no pun intended)?
01:35:46 <viirya> shapr: i see. i'm reading some documents.
01:54:36 <Calister> good morning!
01:58:10 <shapr> guten morgen Calister!
01:58:16 <Calister> guten morgen!
01:58:19 <Calister> :D
01:58:26 <Calister> Wie geht's?
01:58:52 <shapr> gut
01:59:03 <Calister> good to hear that :)
01:59:11 <shapr> I'm reading the STM paper and thinking about spoken programming languages.
01:59:34 <Calister> hey, do you know if there is a function in preload which turns decs into bins?
01:59:40 <Calister> stm?
01:59:57 <shapr> NumExts had a showBin
02:00:01 <shapr> I'm not sure if it's still around.
02:00:08 <shapr> memory transactions
02:00:24 <Calister> bummer, im sure its gone... or my prof woulda used that
02:00:37 <shapr> it's really easy to write yourself
02:00:37 <Calister> memory transactions? O.O
02:00:46 <Calister> i am writing it myself atm ;)
02:00:47 <shapr> showBin is something less than 50 chars to write
02:00:51 <Calister> wow
02:00:52 <Calister> ;o
02:01:14 <Calister> my dectobin will be longer i suppose but hey.. im a n00b ^_^
02:03:42 <musasabi> shapr: so what are you thinking?
02:03:48 <musasabi> (about stm)
02:03:56 <Lemmih> Huh? Time to unicycle already?
02:04:02 * Lemmih goes unicycling.
02:05:00 <Calister> seems to be a trend-sport ^_^
02:06:40 <Calister> hmmm... i must admit i like linear recursive progs more than "end-recursive" ones
02:07:21 <Calister> and just alone this fact is freaky... ;x i start to get a haskell programming style. thats weird.
02:18:57 <SamC> if I try to build the yi docs with 'make docs' I get '...Boot.raw-hs:1:1: Parse error'
02:40:34 <Calister> oh god, i really hate my prof for giving us homework including function he wrote which _AINT_ working
02:40:55 <Calister> "use this and that.." great.. =.= 
02:41:04 <Calister> why cant we let him fail this class?!?
02:41:04 <musasabi> nonworking functions are the nastiest in exams.
02:41:24 <Calister> he gave it us as "working" function
02:41:25 <Calister> >_<
02:41:30 <Calister> its evil
02:41:59 <Calister> bug finding is already hard enough with my own progs
02:42:03 <musasabi> Do x with the given function, which of course is buggy and cannot be used to do X.
02:42:11 <Calister> exactly!!
02:42:23 <Calister> :s
02:43:01 <Calister> who am i to fix his damn functions? then i rather write em myself >_<
02:43:54 <Calister> basically means: yay, ima code this function myself to understand it ^_^
02:44:11 <Calister> and ima ignore his "offer"
02:45:27 <Calister> bbl :)
02:45:29 * Calister waves
03:06:35 * SamC has no yi docs :(
03:11:55 <SamC> what do the numbers in the haddock parse error refer to?
03:20:24 <SamC> line num : char num?
03:27:31 <xkb> are there any hugs ports for pocketpc?
03:29:22 <xkb> ah there is
03:29:29 <xkb> http://www.comp.nus.edu.sg/~luzm/ppchugs/
03:30:38 <shapr> man I love unicycling...
03:31:02 <SamC> i hate pocketpc users
03:31:19 <SamC> ...?
03:33:01 <shapr> what's pocketpc? I've heard of PowerPC...
03:33:15 <xerox> microsoft tablets?
03:33:47 <SamC> I don't know
03:35:17 <SamC> but hey have stolen the ppc acronym
03:36:26 <SamC> google 'foo ppc' ooh lots of results, oh boy... wait pocket pc damn!
03:39:35 <SamC> Boot.raw-hs:1:1: Parse error from haddock, someone must know what the ones mean, I imagine they are in accordance with a unix idiom
03:40:44 <shapr> I'll look at it when I get back from more unicycling, I just came back to read some online tutorials for various tricks.
03:41:42 * SamC throws shapr some change ;)
03:41:54 <Lemmih> shapr: Url?
04:19:28 <shapr> SamC: we fear change...
04:19:43 <shapr> Lemmih: http://www.unicycle.2ya.com/
04:31:23 <Lemmih> You should try kickup mounts. The difficulty/coolness radio is good.
04:37:19 <desrt> shapr; did you even sleep?
04:41:48 * desrt receives a confusing ld error
04:42:12 <ozone> are there any non-cofusing ld errors?
04:42:14 <ozone> +n
04:42:33 <desrt> ya.. like "unresolved symbol, you suck"
04:51:37 <Maddas> Wow, rolling hops on unicycles look crazy :-)
05:11:07 <bluegods> can haskell be used instead of python?
05:11:30 <noj> it's a programming language, so, yes
05:11:58 <bluegods> is haskell useful for business programming and e commerce?
05:12:10 <noj> define what that is
05:12:23 <bluegods> would you reccomend haskell to someone who was first learning programming?
05:12:29 <bluegods> ok
05:12:32 <Lemmih> Most definitely.
05:12:49 <ozone> bluegods: haskell will increase your return on investment and employee productivity!
05:12:56 <bluegods> can haskell form a webserver and a database of some sort and publish dynamic content such as ebay
05:13:20 <Lemmih> bluegods: Yes.
05:13:32 <bluegods> would you prefer haskell to say python?
05:13:49 <bluegods> what about smalltalk?
05:17:24 <musasabi> yes.
05:17:33 * musasabi prefers haskell to them both
05:19:49 <Darius> bluegods: There is at least one Haskell webserver, several tools/libraries that talk to databases, and several tools/libraries that help with dynamic content.
05:21:04 <bluegods> are these tools fleshed out in such a way that one can use them without being a phd computer science?
05:21:15 <Darius> bluegods: On the topic of whether I'd recommend Haskell as a first language, I'm not sure, but it's certainly better than many alternatives.
05:22:42 <Darius> bluegods: Depends on what you're going for, I personally would say yes, but I don't have a PhD, don't find too many things particularly hard about Haskell so I (apparently) am not the best one to ask.
05:24:29 <ozone> bluegods: if you are asking such questions, i'd say either (a) be prepared to employ/contract a haskell expert, or (b) don't use haskell
05:24:38 <ozone> since it appears you are using it for a commercial project
05:27:25 <rtega> now the subject pops up
05:27:35 <rtega> is there anybody here who learned haskell as a first language?
05:27:40 <musasabi> ozone: isn't that true for any language.
05:28:25 <ozone> musasabi: yep
05:32:52 <bluegods> hmm
05:32:55 <bluegods> well
05:33:10 <bluegods> I want to learn to produce results with my computer and make money
05:33:17 <bluegods> I got a book on python
05:33:25 <bluegods> but its written rather poorly
05:33:54 <bluegods> and python claims superiority over perl in that you can read the code later, less errors, and object orientation
05:34:14 <bluegods> tcl is crap according to python since it also doesnt not scale
05:34:37 <bluegods> so I am left with python since ruby is too new ot have enough tools for e commerce in it yet
05:34:44 <tuomov> tcl code is almost as ugly as perl code
05:34:44 <bluegods> and php seems also somehow limited
05:34:49 <bluegods> then I read about lisp
05:34:55 <bluegods> which led me to haskell
05:35:05 <bluegods> lua also seems overspecialized
05:35:12 <bluegods> so here I am
05:35:15 <bluegods> in haskell
05:35:20 <bluegods> thinking god will this work
05:35:24 <tuomov> lua is neat, but it doesn't have a load of libraries
05:35:32 <bluegods> and I copy ebay or amazon.com using this stuff
05:35:36 <tuomov> mostly it is used for embedding
05:36:04 <bluegods> or should I go get an MBA and forget programming altogether
05:36:05 <bluegods> :(
05:36:24 <bluegods> haskell does seem interesting
05:36:35 <bluegods> do any of you serve a website using haskell?
05:37:10 <bluegods> ever use smalltalk?
05:40:24 <Darius> bluegods: I've used Squeak, but Smalltalk never really got me.
05:59:24 <shapr> bluegods: I run a website served with Haskell.
06:00:56 <Darius> shapr: HWS-WP?
06:01:19 <shapr> well, no...
06:01:41 <shapr> it's served by apache, but the darcs and Halipeto generate the content.
06:02:49 <Darius> shapr: I was (and just now) trying to connect to scannedinavian.org and .com for that reason, but I can't seem to get them.
06:02:53 <shapr> I'd like hws-plugins
06:03:00 * shapr checks
06:03:22 <shapr> works for me
06:03:28 <andersca> hmm, I wonder if this supports ipv6
06:03:36 <shapr> your mac?
06:05:25 <shapr> Darius: looking for anything in particular?
06:05:34 <shapr> Oh hey, I put a post about spoken programming on LtU
06:07:33 <andersca> looks like my version of colloquy doesn't support ipv6
06:07:37 <shapr> Darius: doh, you already replied =)
06:07:44 <andersca> shapr: do you have ipv6?
06:07:50 <shapr> yes! sort of...
06:08:19 <shapr> freenet6
06:08:24 <shapr> it's a tunnel provider
06:08:31 <andersca> can you ping luminoth.ipv6.csbnet.se ?
06:08:34 <shapr> But you can use 6to4 if you have a real public IP
06:09:13 * shapr tries tracepath
06:09:18 <Darius> shapr: I was going to get it as (another) site using Halipeto.
06:09:45 <shapr> andersca: seems to work
06:09:48 <andersca> cool
06:09:56 <andersca> shapr: we have real ipv6 here...
06:10:02 <shapr> awesome
06:10:25 <bourbaki> http://img25.exs.cx/img25/1654/unbenannt3og.jpg
06:10:25 <bourbaki>  if someone is interested in my game project ;)
06:10:28 <shapr> BBB says we can't get a static IP at home. 
06:10:32 * shapr is irritated
06:13:02 <noj> maybe that'll change since they bought bostream?
06:13:15 <noj> I had bostream for a while, with a static IP. That was sweet
06:13:37 <shapr> I want to run our own business servers at home.
06:14:11 <shapr> Darius: your post on 'navigating the stack' is inspirational
06:14:58 <shapr> I've been wondering for years how navigate spoken code, using Joy and navigating the stack is great
06:15:43 <shapr> It would probably require visible source
06:16:21 <shapr> Or maybe not, blind programmers seem to work with single-line 40 char displays and write code just fine.
06:16:56 <shapr> Max resolution these days is not really enough lines and cols to view much of a real program, you have to just know it all anyway.
06:17:34 <Darius> shapr: I admittedly haven't been thinking too hard about blind programmers.
06:17:38 <musasabi> bourbaki: hopengl ?
06:18:18 <Darius> Some aspects that I had intended, but never got around to mentioning though, are that concatenative languages oftn have small functions and compact code.
06:18:25 <shapr> Darius: there's one that shows up here on #haskell occasionally
06:18:33 <Darius> delYsid
06:18:35 <shapr> yup
06:18:58 <shapr> And he knows Haskell, so he'd probably be interested in a spoken Joy project.
06:19:16 <shapr> How to define a spoken charset?
06:19:39 <shapr> Look for the intersection of easy sounds that are easy to discern and produce for both computer and human?
06:20:18 <bourbaki> musasabi: no directx and c++
06:20:58 <bourbaki> i wish it was written with haskell though i wrote the whole stuff in haskell also
06:20:59 <shapr> Darius: would also be useful for quadraplegics
06:21:02 <bourbaki> but i cant render it
07:22:09 <Darius> shapr: In looking for a paper that gives some information on handling spoken lexical syntax I've come across Digital Clay which you may or may not find interesting.
07:32:21 <autrijus> what does this "donuts" in /topic mean?
07:32:51 <Lemmih> It probably means that we like donuts.
07:33:09 <autrijus> sometimes a cigar is just a cigar.
07:33:11 <autrijus> I see.
07:34:00 <Lemmih> What could a donut sombolize?
07:35:02 <autrijus> an anchor ring?
07:35:18 <autrijus> hamiltonian systems?
07:35:54 * autrijus has no idea
07:36:52 * Lemmih applies 's/typo/correction/g' to all his sentences.
07:37:42 <autrijus> hmm darcs replace
07:38:18 * autrijus finally begins designing Algorithm::Patchset bridge to SVK.
07:39:59 <Darius> Wow, this is the first research paper that I've read that seems to provide guidelines to setting up a con.
07:42:27 <Philippa> it's a paper on XP?
07:43:29 <Darius> On gathering information for designing a spoken programming language.
07:54:02 <Maddas> What do I need to import to use HaXml? ghc complains "Could not find interface file for `...'" for both Xml or HaXml
07:54:24 <Lemmih> Maddas: Text.XML.HaXml ?
07:54:42 <Maddas> OK, thanks. 
07:54:54 <Lemmih> Maddas: Plus -package HaXml.
07:54:55 <Maddas> (Maybe I should look at the reference documentation and not at the outdated paper :-)
07:55:00 <Maddas> Right, I did that.
07:56:23 <Maddas> Hm... Is the code in "Haskell and XML: Generic Combinators or Type-Based Translation?" still supposed to work?
07:56:48 <Maddas> I get "variable not in scope" errors for the functions processXMLwith, hcenter, hcola and hlist
08:01:05 <Maddas> (One error less with the HTML version which uses 'processXmlWith' instead of 'processXMLwith')
08:27:18 <shapr> Darius: wow, Digital Clay is coool
08:27:56 <shapr> Man, I need to work at PARC.
08:35:20 <Darius> shapr: That's the problem with hardware innovations.  You can't download them.
08:36:27 <autrijus> just wait until everyone has a personal circuit printer
08:38:09 <tuomov> replicators!
08:38:14 <tuomov> (stargåte)
08:38:30 <CosmicRay> ahh, another stargate fan.
08:38:32 <CosmicRay> excellent.
08:38:49 <CosmicRay> new atlantis episodes in a couple of weeks.
08:39:11 <wli> CosmicRay: Like Francis Bacon?
08:39:17 <tuomov> I've still to watch the latest (S1E16)
08:39:58 <CosmicRay> wli: who/what is that?
08:41:03 <wli> CosmicRay: Francis Bacon wrote a book whose title translates as "The New Atlantis". He lived and died in the 1200's AD.
08:41:12 <CosmicRay> hmm, interesting
08:42:11 <wli> feh
08:42:15 <wli> I'm thinking of Roger Bacon
08:42:21 <wli> Francis Baconwas the 1600's
08:47:05 <Lemmih> 'stargåte' sounds really lame in danish.
08:47:29 <tuomov> "staargootte"
08:48:08 <wli> CosmicRay: http://www.gutenberg.org/dirs/etext00/nwatl11.txt
09:41:35 <Lemmih> Yay. Hacanon now supports class inheritance.
09:42:23 <Lemmih> I totally cheated (-:
09:43:05 <ozone> Lemmih: do tell more
09:48:46 <Lemmih> One moment. Formulating english gets hard after 16 hours of coding without sleep.
09:50:08 <Lemmih> The system could already handle overloading and C++ classes with same method names.
09:53:09 <Lemmih> So I take a class and add the methods of its super classes to itself.
09:55:39 <Lemmih> It generates some superfluous code but it works nonetheless.
09:56:11 <ozone> cool!
09:56:57 <Lemmih> It took like 10 lines of code (-:
09:58:47 <Lemmih> But it is a very naive implementation and not very scalable.
09:59:27 <ozone> hey, for 10 lines of code, sounds all good :)
10:11:39 * stepcut whips out his lambda and waves it around
10:12:29 * autrijus waves a pi in return
10:13:00 * stepcut is the dominant lambda male of the pack
10:13:28 * autrijus smiles
10:13:49 * Oeje1 hits stepcut on his lambda with a smelly fish.
10:14:20 * stepcut counters with a hylomorphism
10:14:45 <Oeje1> :-P
10:20:02 * Lemmih has earned some sleep by now.
10:47:44 <stepcut> argh! hlist has permantly warped my brain
10:49:53 <basti_> :(
10:49:57 <autrijus> brain wrap speed II
10:50:02 <autrijus> I mean warp.
10:50:05 <autrijus> no, I do mean wrap.
11:08:39 * TheHunter is away: I'm busy
11:44:26 <CosmicRay> uhoh, the power outage seems to have damaged megamonad!
11:44:49 <ibid> it was saving while the power went out?
11:44:56 <CosmicRay> I suspect so
11:45:07 <CosmicRay> I don't think it uses any ACID-safe library
11:45:11 <CosmicRay> some binary format of its own design
11:45:19 <CosmicRay> fortunately I have a backup only a couple of days old
11:46:03 <thebug> it definitely does not do anything even remotely approaching ACID safe
11:47:18 <wagle> megaunsafemonadatanyspeed
11:48:08 <CosmicRay> heh
11:56:40 <ibid> CosmicRay: it still could dump the data into a temp file and semiatomically replace the actual db with the new temp file when ready
11:57:01 <CosmicRay> yup
11:57:05 <ibid> that should not be that hard to do, at least if it doesn't attempt an in-place update
11:57:09 <CosmicRay> though we're talking about half a gig of data in my case
12:09:21 <musasabi> Has anyone got RDF code in haskell?
12:09:47 <basti_> which dope do you need to smoke to come up with HLIST?
12:10:11 <musasabi> CosmicRay: how usable is your ftp library?
12:10:34 <CosmicRay> musasabi: client or server?
12:11:11 <musasabi> server.
12:11:40 <musasabi> mainly memory allocation.
12:12:08 <CosmicRay> It is full-featured for an anonymous FTP server.  Auth is not yet supported but can be added trivially.  It is probably vulnerable to DoS attacks from malicious clients that would send it extremely huge command lines
12:12:15 <CosmicRay> I have downloaded ISOs with it
12:12:20 <CosmicRay> used <5M RAM
12:12:37 <CosmicRay> I should say "auth other than anonymous"
12:12:53 <musasabi> so uploading files does not eat all the memory?
12:12:55 <CosmicRay> no
12:13:06 <musasabi> ok, I'll have to dig into it then.
12:13:09 <CosmicRay> if you find a case where it does, I would want to hear about it.
12:13:17 <CosmicRay> that would most certainly be a bug.
12:13:49 <CosmicRay> it also has an internal ls -l implementation, so it will appear as a Unix server on any OS.
12:15:12 <CosmicRay> cmd_stor is the function that would be interesting for you
12:16:00 <CosmicRay>                      case mode of
12:16:01 <CosmicRay>                       ASCII -> finally (hLineInteract readh fh datamap)
12:16:01 <CosmicRay>                                        (hClose readh)
12:16:01 <CosmicRay>                       Binary -> finally (do vSetBuffering fh (BlockBuffering (Ju
12:16:01 <CosmicRay> st 4096))
12:16:01 <CosmicRay>                                             hCopy readh fh
12:16:03 <CosmicRay>                                         ) (hClose readh)
12:16:33 <CosmicRay> that is, btw, almost identical to the code in cmd_retr
12:17:10 <CosmicRay> hLineInteract is in MissingH.IO and is basically \x -> interact (unlines . x . lines)
12:22:36 <jesse99>  hmm, i'm not seeing any standard way to write infinities or NANs, and hugs doesnt seem to support them at all
12:23:01 <jesse99> stuff like 1.0/0.0 just gives me an error
12:23:41 <jesse99> does ghc do better?
12:25:54 <musasabi> CosmicRay: I will read it (and possibly send patches) in a few days.
12:40:19 <jadrian> jesse99: Prelude> 1.0/0.0
12:40:20 <jadrian> Infinity
12:40:24 <jadrian> jesse99: that's ghc
12:40:28 <jadrian> jesse99: that's ghci
12:40:59 <jadrian> jesse99: and 
12:41:00 <jadrian> Prelude> sqrt(-4)
12:41:01 <jadrian> NaN
12:46:33 <jesse99> thanks jadrian
12:47:09 <jadrian> np ;)
13:33:08 <CoolPops> Can someone help a newbie understand: count2 p l = foldr (\x c -> if p x then c+1 else c) 0 1? I understand what it does, how functions are passed as values (p), and what foldr does, but "if p x" is confusing me. What exactly is "x"?
13:33:55 <Igloo> It's parsed as if (p x) then (c+1) else c
13:33:57 <Igloo> Does that help?
13:34:03 <CoolPops> "if p x" passes the value of "x" to the function I sent to count2 as p, I know.
13:34:03 <zamez> the first parameter of the lambda
13:34:47 <CoolPops> Igloo: I understand that, "x" is really confusing me.
13:34:58 <CoolPops> zamez: what is the first parameter to the lambda?
13:35:04 <zamez> x
13:35:29 * CoolPops will be honest, he has a very tiny grasp on lambda functions. \\x -> x+x makes sense, but beyond that it's confusing to him.
13:35:34 <musasabi> CoolPops: think about this function: count_if element count = if predicate element then count+1 else count
13:35:51 <zamez> (\x c -> ...) is a function taking x and c
13:36:05 <musasabi> CoolPops: then make it less readable like (\x c -> if p x then c+1 else c)
13:38:09 <zamez> it should be  count2 p l = foldr (...) 0 l
13:38:15 <zamez> ie. l at the end, not 1
13:43:43 <CoolPops> ah, I think it's actually the foldr I didn't understand. How \x and c were assigned.
13:44:17 <CoolPops> foldr (*) 1 [1,2,3] .... \x = 1, c=1 the first time through? then \x = 2, c=1 the 2nd time, etc...?
13:45:47 <musasabi> @type foldr
13:45:49 <lambdabot> foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
13:46:11 <musasabi> This is one reason type signatures are very good and it pays of to learn to read them.
13:47:01 <CoolPops> ok. I understand type sigs such as a -> a -> a, even (a -> b) but what is the forall?
13:47:22 <musasabi> foldr takes three arguments 1) a function taking two inputs of type 'a' and 'b' and produces a value of type 'b' 2) an initial value of type 'b' and a list of 'a'. foldr returns the last value returned by the function.
13:48:07 <musasabi> CoolPops: forall means just "forall types a and b" it is superfluous there and just something that the inferer adds.
13:53:25 <CoolPops> musasabi: ok. so "(a -> b -> b)" signifys the function, b the initial value, [a] the list and b the return value... What is the "b a." right after the forall mean?
13:54:56 <zamez> anyone want to help me debug my parser?
13:55:01 <zamez> for CSS
13:55:13 <CoolPops> musasabi: never mind, forgot about the post right before my last one.
13:55:16 <zamez> I can't figure out why it's not working correctly
13:57:18 * CoolPops is going home for the day, will continue on the tutorial this evening.
14:01:13 <wli> weird
14:02:27 <wli> interesting
14:02:34 <wli> missing MArray instances are hurting me
14:03:05 <wli> for STUArray
14:03:08 <wli> duh
14:03:16 <wli> (,) doesn't give unboxedness
14:06:12 <wagle> ohh..  a monadic versions of your pairing pattern is gonna be even hairier
14:10:26 <boegel> hello everybody
14:10:31 <boegel> is there some activity here?
14:10:53 <TheHunter> wli, you have to use (# , #), i think.
14:11:11 <wli> I don't really care about unboxedness, so I just used STArrays
14:12:21 <boegel> do you people know a good LaTeX distribution under Windows ?
14:12:31 <boegel> I know Miktex, but that's so damn big
14:13:46 <stepcut> does tetex support windows?
14:14:22 <stepcut> I think I installed some tex thing via cygwin once
14:15:21 <boegel> stepcut, I don't know
14:15:48 <boegel> don't any of you use LaTeX under Windows ? seems hard to believe you guys are all Linux-geeks :p
14:16:02 * SyntaxNinja notes that #haskell is the best place to ask debian, latex, and java questions
14:16:03 * stepcut is a linux/freebsd geek ;)
14:16:31 * SyntaxNinja is a linux geek. wli is a HUGE linux geek ;)
14:16:53 <wagle> TeXShop might have a windows version..  
14:17:12 <aj> hrm, anyone here know anything about Isabelle (the theorem prover)?
14:17:27 <wagle> also, you might want to install cygwin, and have a command line access to tex (and other things)
14:17:36 <wli> pretty much, yes
14:17:59 <tuomov> miktex is smaller than cygwin..
14:18:07 <SyntaxNinja> aj: I think there are people sitting nearby me who know about it
14:19:42 <wagle> never mind..  (geez..) texshop appears to be macosx only.  sorry
14:20:24 <stepcut> has anyone here ever seen an .ini style file (like smb.conf, kde config files, etc), that allowed a comment at the end of a key/value pair line?
14:20:27 <stepcut> like:
14:20:33 <stepcut>  key = value # just an example 
14:20:52 <wagle> i do my utmost to avoid windows os like the plague
14:21:17 <stepcut> its pretty easy to avoid the plague these days :)
14:21:53 <aj> SyntaxNinja: i'm playing with setting up some stuff to prove the correctness (or otherwise) of darcs merger stuff; but i can't seem to make isabelle prove simple theories like "f = take n f @ take m (drop n f) @ drop m (drop n f)"
14:23:10 <aj> SyntaxNinja: any hints would be appreciated, obviously :)
14:27:03 <wagle> prove x = take m x @ drop m x?
14:27:27 <boegel> wagle, you're right about avoiding Windows :)
14:27:52 <boegel> but Linux doesn't work properly on my desktop, because I have a shitty graphics card
14:28:17 <wagle> i think i never got over the "how do you get isabelle to take two steps of an induction" hump, though
14:28:26 <boegel> and the loading-thingie (don't know the correct word :) ) for my laptop is busted, so I can't work on that one for a while
14:28:36 <wagle> i keep meaning to get back to the isabelle tutorial
14:28:57 <SyntaxNinja> aj: when the theorem proving guy is back at his desk, I'll ask him :)
14:29:10 <wagle> ahh good.  real help
14:29:38 <boegel> @seen Itkovian
14:29:39 <lambdabot> I saw Itkovian leaving #haskell 7 hours 33 minutes 33 seconds ago.
14:29:45 <boegel> has anyone seen him talk ?
14:33:15 <wagle> boegel: i grew annoyed when xp literally self-destructed when it thought I (and others) were doing something bogus (when we werent)
14:36:16 <wagle> is aj's problem being solved?  i was wanting to know the answer
14:37:37 <aj> wagle: i proved that, but i just can't work out how to make it use it...
14:38:00 * aj tries out the xemacs binding
14:39:06 <wagle> aj: something about having only one induction variable, and not two
14:39:31 <wagle> the index is one induction var, and the list is the other
14:40:37 <wagle> i dont know how to handle that..  though people who did seemed to think it somewhat tricky
14:40:58 <aj> it shouldn't need induction though -- just substitution
14:41:15 <musasabi> Does haskell have a mapFst function like:
14:41:49 <wagle> need to find a subst tactic?
14:42:00 <musasabi> mapFst :: (a -> b) -> (a,c) -> (b,c)
14:42:20 <TheHunter> @type Control.Arrow.first
14:42:22 <lambdabot> Control.Arrow.first :: forall a d c b.
14:42:22 <lambdabot> 		       (Control.Arrow.Arrow a) =>
14:42:22 <lambdabot> 		       a b c -> a (b, d) (c, d)
14:42:22 <wagle> sigh..  SyntaxNinja 's friend whould be way more help than i
14:42:36 <jadrian> musasabi: nope
14:42:38 <musasabi> TheHunter: but that is for arrows.
14:42:42 <musasabi> ok.
14:42:48 <TheHunter> (->) is an arrow.
14:43:11 <jadrian> musasabi: if you don't need to pass it as an argument you can use list comprehension
14:44:13 <jadrian> musasabi: ah but why not use map and arrows?
14:44:22 <jadrian> musasabi: for the fst case works fine
14:45:10 <jadrian> musasabi: map (g *** id) 
14:45:21 <TheHunter> Those massively overloaded arrow functions are almost all useful: first, second, left, right, &&&, ***, |||, +++
14:45:31 <jadrian> yeap 
14:46:03 <TheHunter> s/almost//
14:46:32 <jadrian> TheHunter: are there other instances of Arrow besides -> that you find them usefull to use with?
14:46:59 <jadrian> TheHunter: I just use them for stuff like this, applying functions to pairs or Eithers
14:47:11 <TheHunter> ya, me too.
14:47:28 <jadrian> by the way, I also defined a "both" function
14:47:36 <jadrian> similar to first and second
14:47:43 <jadrian> I think it's really handy
14:49:10 <jadrian> one of my issues when using them is that sometimes you need uncurrying 
14:49:21 <jadrian> but typing "uncurry" is so damn ugly :-/
14:50:11 <wagle> "overloading"..  
14:50:28 <wagle> (i wonder if that would work)
14:50:34 <jadrian> ?
14:50:47 <TheHunter> hmm, apperently "pseudoconstant" typeclass functions are not shared.
14:51:11 <TheHunter> s/pseudoconstant/constant
14:51:16 <wagle> define the classes such that one instance is matched for either, and the other for pairs
14:54:19 <TheHunter> forget what i said, the function isn't even constant.
14:55:08 <musasabi> any easy way of getting a line in a network application without opening oneself up to dos attacks (long lines)
14:56:05 <musasabi> hGetShortLine? ;)
14:56:23 <musasabi> I would like to avoid looping with hGetChar as that is not very efficient.
14:57:36 <tromp> happy 2005, #haskell
14:57:49 <CrewdenX> musasabi: you've already verified that the function which you're currently using for retrieving lines is not already written in terms of hGetChar ?
15:05:16 <SyntaxNinja> sorry, the theorm proving guy disappeared
15:05:21 <SyntaxNinja> I'll try to get him back!
15:05:47 <musasabi> CrewdenX: yes, the source is in GHC.IO.
15:06:17 <CrewdenX> musasabi: i'm using hugs mostly.
15:06:43 <CrewdenX> musasabi: it's implemented in terms of hGetChar there.
15:09:54 <musasabi> CrewdenX: but isn't hGetChar simpler on hugs (as it should need fewer locking)
15:10:25 <CrewdenX> musasabi: i have no idea.
15:10:51 <CrewdenX> musasabi: i'm not a haskell expert. what i was considering that you might be worrying needlessly.  
15:12:10 <musasabi> then again I am used to using Ptrs for IO ;)
15:22:01 <stepcut> hey bringert!
15:22:22 <bringert> hi
15:22:58 <stepcut> i wrote a toy optimizer for haskelldb that optimizes sub-queries into joins :)
15:23:13 <stepcut> now my query takes 0.2 seconds instead of 10 =)
15:24:03 <bringert> sweet!
15:24:31 <stepcut> I will send an email about it tomorrow, I have the email mostly written but I need to consult a book I left at home
15:24:47 <bringert> sounds great
15:24:54 <Riastradh> Make it do constant-folding, so the whole query can be completed before it's actually run!
15:25:27 * stepcut only cares about sub-query elimination for the time being
15:25:42 <Riastradh> (That was a joke.)
15:26:27 <bringert> Riastradh: would the optimizaer then know all the data in the db?
15:26:42 <bringert> and assume it's constant?
15:28:13 <Riastradh> The joke was that the optimizer would fold queries by performing the query itself.  Then the query is all finished, so you have an answer instead of something you need to waste time sending to the database to process...
15:28:41 <bringert> hmm, that sounds like a neat TH + haskelldb trick
15:33:43 <SamC> I see that yi has a .tex file, unfortunately I don't have tex and it's non-trivial to get, could someone send me the .ps?
15:45:09 <jesse99> simple overloading question if anyone wants to help: http://rafb.net/paste/results/qspBCG76.html
15:47:41 <monochrom> \try (0 :: Int) and (24 :: Int) 
15:48:07 <musasabi> jesse99: number constants are polymorphic.
15:50:20 <jesse99> blech :-)
15:51:02 <musasabi> actually you want that most of the time.
15:51:42 <jesse99> no doubt, but it doesnt seem to interact very well with overloading
15:52:38 <monochrom> 0 is heavily overloaded itself.  It may be Int, Integer, Float, Double, Complex.
15:52:53 <wli> it'd be nice if they were interpreted as a literal "fromIntegral" instead of Num t => t
15:53:05 <wli> so that other numeric systems could easily be used
15:54:10 <musasabi> wli: but they are.
15:54:47 <monochrom> 0 stands for (fromIntegral 0).  The problem remains.  (fromIntegral 0) may be Int, Integer, Float, Doulbe, Complex.
15:55:01 <wli> in principle if I could figure out how to do anything in ghc I could fix it
15:55:16 <James_123> Anyone have a SciTe file for Haskell?
15:55:17 <wli> monochrom: try hiding the prelude and redefining fromIntegral in ghc
15:56:18 <wli> maybe other implementations are more well-behaved
15:56:48 <monochrom> Hrm.  Well, anyway, in any case you have an overloaded value passed to an overloaded function.  All overloading and no specialization makes 0 a general boy.
15:57:19 <jesse99> it works in c++ :-)
15:58:03 <wli> I think I heard a rumor that nhc98 expands integer literals in a macro-like fashion. My reading of ghc is that it nails down the type to a specific one defined in its internals/etc.
15:58:31 <musasabi> jesse99: in C++ you have a mess but it just fails silently behind the scenes.
15:58:57 <monochrom> c++ doesn't go as far as overloading 0
15:59:03 <jadrian> SyntaxNinja: may I ask who's the "theorem proving guy"?
15:59:19 <wli> it builds up some data structure describing an integer with a type qualifier derived from some strings and variables sitting around the compiler that represent types instead of an as-of-yet-untyped expression like fromIntegral 0 whose type depends on visible instances and the like.
15:59:42 <jesse99> 0 can be a pointer, any of 12 or so int types, or any of 3 floating point types
16:00:08 <musasabi> jesse99: yes and that is why nasty things happen..
16:00:11 <monochrom> Can you overload 0 yourself in c++?  You can in Haskell.
16:00:13 <musasabi> jesse99: e.g. 
16:00:17 <jesse99> and barring conversion operators I dont see c++ failing silently very often
16:00:24 <jesse99> no monochrom
16:00:26 <musasabi> void foo(int i);
16:00:36 <musasabi> void foo(void*p);
16:00:42 <monochrom> Then that is what I meant by "c++ doesn't go as far as overloading 0"
16:01:15 <musasabi> foo(0) will work silently and we will have to debug it. (add #define NULL 0 to make things nastu_
16:01:22 <musasabi> *nsaty)
16:01:26 <musasabi> *nasty
16:01:43 <musasabi> monochrom: it performs implicit conversions.
16:01:54 <jesse99> yeah it is, but most c++ problems arent due to such silent misbehavior
16:02:36 <musasabi> jesse99: no, but that behaviour leads to bugs.
16:02:52 <basti_>  /quit
16:02:55 <basti_> whoops
16:03:16 <eivuokko> It's not like most of quality c++ code uses pointers for anything like that.  If you go comparing worst of languages, of course no language with conversions can stand - but the relevance of such notions....
16:03:25 <jesse99> well hopefully null_ptr will make it into the next revision of the standard
16:03:28 <monochrom> My "overloading" means "user-extensible overloading".  If it is built-in overloading but not user-defined overloading it is not true overloading.  You may as well say "SML has overloading look at 0+0 and 0.0+0.0".
16:03:56 <jesse99> well, you can certainly overload on user defined types in c++
16:04:08 <jesse99> and add new overloads of existing functions
16:04:35 <monochrom> In Haskell the moment you make your own type T an instance of Num, (0 :: T) works.  Can you do a similar thing in C++?
16:05:04 <jesse99> yes
16:08:11 <monochrom> OK, then this is not a problem.
16:13:39 <TheHunter> wli, http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#REBINDABLE-SYNTAX. If 0 doesn't use your own fromInteger (which apperently should be able to be put in an arbitrary type class) und -fno-implicit-prelude, this is definitely a bug.
16:15:38 <SamC> if I ungraciously kill yi it starts eating all my comptrons
16:15:54 <SamC> computrons
16:16:14 <monochrom> How can it eat if it is dead?
16:20:34 <musasabi> Can someone point how to actually get Ashley Yakeley's code on haskell list working? (The monas's with constraints via GADTs  "Re: Rebindable syntax for monads and arrows")
16:25:07 <TheHunter> musasabi, which message is that?
16:28:02 <musasabi> http://www.haskell.org//pipermail/haskell/2005-January/015116.html
16:31:00 <TheHunter> ahh, should have thought of looking in haskell instead of just haskell-cafe...
16:32:31 <jesse99> another trivial problem, I can't use String with an instance: http://rafb.net/paste/results/1gPG7715.html
16:32:41 <jesse99> anyone know what's going on there?
16:33:09 <TheHunter> hmm, i'd say it's impossible even with GADTs, since the type of bind _must_ have a constraint (at least for the set monad).
16:33:42 <arjanb> jesse99: try [Char] instead of String
16:34:00 <jesse99> same thing
16:34:37 <TheHunter> musasabi, as of now, I guess what he's doing is impossible anyway: http://sourceforge.net/tracker/index.php?func=detail&aid=1097046&group_id=8032&atid=108032
16:35:11 <TheHunter> (i only have a hopelessly outdated ghc-cvs, so i can't say for sure)
16:37:34 <TheHunter> oh, sorry, i just saw he's pointed out that "bug" already in his mail.
16:39:53 <TheHunter> yah, it can't work anyway. (vreturn a) imposes the constraint FinSet on a, so return can't have type forall a. a -> MyVec a
16:42:29 <musasabi> TheHunter: yes, so it was just not my reasoning telling that it is impossible ^_^
16:50:19 <jesse99> anyone else want to take a crack at my (simple) bug? http://rafb.net/paste/results/1gPG7715.html
16:53:03 <musasabi> jesse99: add -fglasgow-exts
16:53:49 <musasabi> jesse99: the problem is that you want to define an instance for a type synonym.
16:53:52 <jesse99> hmm, well that worked
16:54:02 <jesse99> well [Char] also doesnt work
16:54:51 <jesse99> thanks for the help musasabi
16:55:37 <musasabi> [Char] is not of the form (T a b c) (yes, haskell98 is very limited in this respect(
16:58:38 <jesse99> has there been any talk of making String a real type?
17:00:02 <musasabi> yes, and some people oppose it vehemently.
17:00:26 <jesse99> because list functions would be problematic?
17:00:56 <musasabi> because they want to keep it conceptually a list of chars.
17:08:35 <aj> sigh
17:10:15 <aj> i have
17:10:16 <aj>   f = take n f @ drop n f
17:10:17 <aj>   drop n f = take m (drop n f) @ drop m (drop n f)
17:10:23 <aj> and i *still* can't prove
17:10:27 <aj>   f = take n f @ take m (drop n f) @ drop m (drop n f)
17:16:56 <SyntaxNinja> aj: my theorem-proving friend doesn't know this theorem prover as well as some others; he doesn't know what you're doing wrong. sorry.
17:17:32 <aj> is there a better one to be using?
17:17:41 <jadrian> aj: are you using coq?
17:17:50 <aj> "isabelle"
17:17:57 <aj> first google hit for "theorem prover" or so :)
17:18:03 <jadrian> aj: I've used isabelle
17:18:07 <jadrian> aj: I liked it a lot
17:18:22 <jadrian> let me look at that
17:18:45 <monochrom> is it because of the way you orient the equations?
17:19:05 <jadrian> @ = ++ right?
17:19:06 <lambdabot> Sorry, I don't know the command "", try "lambdabot: @listcommands"
17:19:08 <aj> if i try "simplify" it infinite loops because drop n f is expressed in terms of itself
17:19:14 <aj> yeah @ == ++
17:19:25 <monochrom> So I guessed right.
17:19:53 <aj> and i just can't find the thing to let me do plain simple substitutions
17:20:42 <SyntaxNinja> my friend knows coq
17:21:21 <jadrian> aj: do you have associativity for @?
17:21:28 <jadrian> aj: are you using it?
17:21:29 <monochrom> If you have take n f @ drop n f = f and take m (drop n f) @ drop m (drop n f) = drop n f, then probably you can simplify take n f @ take m (drop n f) @ drop m (drop n f) to get f
17:21:37 <aj> yeah, i happy to add the brackets myself anyway
17:22:11 <aj> monochrom: yeah, that's what i'm trying to do :)
17:35:10 <aj> yay, got it!
17:35:31 <aj> i needed to eq_commute my equation before subst'ing it
17:35:51 <jadrian> aj: what is that?
17:35:58 <jadrian> aj: I don't remember ever using that...
17:36:15 * jadrian hasn't played with isabelle for over 2 years though...
17:36:20 <aj> eq_commute let's me imply "b = a" given "a = b"
17:36:23 <jadrian> maybe 3...
17:36:39 <jadrian> ah right
17:36:40 <aj> this year they're going to introduce ">=" :)
17:36:45 <jadrian> but why do you need it there?
17:37:05 <jadrian> the equations are in the right order
17:37:39 <jadrian> IIRC "a = b" is meant to be used as "a -> b"
17:38:07 <waltz> neat
17:38:13 <aj> lemma doubletakedrop:
17:38:13 <aj>   "True --> f = (take n f)@(take m (drop n f))@(drop m (drop n f))"
17:38:13 <aj> proof
17:38:13 <aj>   assume True
17:38:13 <aj>   from takedrop have "(drop n f) = (take m (drop n f))@(drop m (drop n f))" .
17:38:15 <aj>   hence dnf: "(take m (drop n f))@(drop m (drop n f)) = (drop n f)"
17:38:18 <aj>     by (subst eq_commute)      
17:38:20 <aj>   from takedrop have "f = (take n f)@(drop n f)" .
17:38:23 <aj>   thus "f = (take n f)@(take m (drop n f))@(drop m (drop n f))" by (subst dnf)
17:38:26 <aj> qed
17:40:35 <waltz> Is that pseudo-code?
17:40:43 <aj> nope
17:40:53 <waltz> (I don't program in Haskell, sorry.)
17:41:19 <aj> that's not haskell, it's a, umm, new style HOL Isobelle theorem proof
17:41:51 <wagle> aj: it worked?
17:41:58 <aj> yup
17:43:16 <wagle> in that it let your original proof through?  what else did you need to do?  (and why was that needed?)
17:45:15 <aj> i had to add the "True -->" because i got effectively a syntax error otherwise, had to use subst instead of simp[lify], had to introduce the commuted equality in order to substitute it, otherwise it's pretty much what i wanted
17:45:23 * jadrian still didn't how the eq_commute was used
17:45:45 <jadrian> is this takedrop : "f = (take n f)@(drop n f)"
17:45:49 <wagle> thx
17:46:13 <aj>   thus thesis by (subst dnf)
17:46:16 <aj> bah
17:46:18 <jadrian> or is takedrop  "(take n f)@(drop n f) = f" ?
17:46:26 <aj> yeah, it's that
17:46:29 <jadrian> aj: eh
17:46:34 <aj> except f=(take...)
17:46:38 <jadrian> that's not what you originally said...
17:46:53 <jadrian> you said you had,  f = take n f @ drop n f
17:47:21 <monochrom> "thus thesis by (subst dnf)"... if only I can hand that in as my thesis :D
17:47:29 <aj> lemma takedrop [simp]: "f = (take n f)@(drop n f)"
17:47:41 <jadrian> ok so I'm lost :)
17:49:13 <aj> nah, i'm lost, i should have written if (take ..)@(drop ..) = f by the looks
17:58:15 <aj> lemma doubletakedrop: 
17:58:15 <aj>   "(take n f)@(take m (drop n f))@(drop m (drop n f)) = f"
17:58:15 <aj> proof (simp only: takedrop)
17:58:17 <aj> qed
17:58:36 <aj>   ^-- that's what it looks like when you've got your equations round the right way :)
18:00:38 <jadrian> right...
18:31:44 <bourbaki> moin
20:19:25 <desrt> Prelude> 1+1
20:19:25 <desrt> Ok.. you have 5 seconds
20:19:25 <desrt> 2
20:19:29 <desrt> :D
20:23:05 <Darius> Prelude> let True = False in 1 + 1
20:24:05 <Darius> Prelude> let 1 = 2 in 1 + 1
20:26:20 <CoolPops> what documentation tool is most popular for haskell?
20:30:24 <shapr> haddock
20:30:55 <shapr> or maybe literate Haskell and postscript output?
20:33:25 <wli> interesting
20:40:57 <desrt> there's a problem
20:41:01 <desrt> Prelude> let fib=1:1:zipWith (+) fib (tail fib)
20:41:03 <desrt> this is ok
20:41:10 <desrt> but.... when it gets to.... ,17167680177565,27777890035288,44945570212853,72723460248141,117669030460994,190392490709135,30Segmentation fault
20:41:13 <desrt> desrt@gorecki rts $
20:41:35 <Lemmih> Good morning, Haskell.
20:42:55 <shapr> good morning Lemmih!
20:48:12 <shapr> y0 isomer 
20:48:19 <isomer> hi shapr
20:48:21 <isomer> how goes?
20:48:44 <shapr> It's morning and I'm awake, looking forward to sunlight so I can unicycle.
20:48:48 <shapr> How goes with you?
20:49:09 <isomer> pretty good. took some much needed vacation last week
20:49:10 <desrt> do people give you odd looks when you unicycle around?
20:49:20 <shapr> yup, lots.
20:49:30 <isomer> now i'm starting to prepare for a triathalon in july
20:49:32 <isomer> :-)
20:49:54 <shapr> Yesterday some 14 year old said "hey I can ride that bike" so I held it out in his direction and said "show me" and he said "just joking"
20:50:11 <desrt> i can't imagine it's too difficult
20:50:17 <shapr> isomer: that's cool, do they have any triathalons that involve unicycling?
20:50:24 <desrt> just have to be coordinated enough to hold balance
20:50:30 <isomer> dunno
20:50:53 <isomer> have you seen the insane guy who unicycles down mountains and on the roofs of buildings?
20:51:08 <shapr> um, I do that.
20:51:26 <desrt> he's asking if you own a mirror :)
20:51:37 <isomer> seriously?
20:51:48 <shapr> though I haven't yet gone down a real mountain, more hills.
20:51:59 <isomer> wow
20:52:06 <shapr> I have a mountain unicycle.
20:53:32 <shapr> isomer: it's really fun, we have deep snow on the ground everywhere and I can unicyle through it, though I leave a small wake like a snow ship
20:54:02 <isomer> have any pictures? that sounds really neat
20:54:48 <shapr> I have pix of me jumping, and pix of mountain unicycles. http://www.krisholm.com/products/productpics/ http://www.scannedinavian.com/images/uni-hop.jpg
20:56:47 <shapr> isomer: I also have a decent collection of homemade unicycle films - http://thunderbird.scannedinavian.com/~shae/unifilms/
20:56:48 <isomer> too cool!
20:58:34 <shapr> It's great fun, worth learning.
20:58:55 <isomer> that you in the movies?
20:59:22 <isomer> looks like from the hair :-)
20:59:41 <shapr> Nah, I don't have any movies of me yet. Wait till I get a digital video camera.
21:00:15 <isomer> mind if i dl some of them? that's quite cool
21:00:25 <shapr> sure, go for it
21:00:29 <shapr> grab them all if you want.
21:00:34 <isomer> thanks
21:00:41 <wli> let's see, array-based linear algebra stuff
21:03:07 <shapr> parallel arrays?
21:04:34 <CoolPops> I've always been interested in literate programming, do you know of any well commented open source haskell projects that use literate (latex) that I can peek at?
21:05:07 * CoolPops can also see the direct benefit of haddock's cross referencing.
21:05:14 <shapr> darcs?
21:05:20 <bourbaki> http://img66.exs.cx/img66/9756/unbenannt3aq.jpg
21:05:28 <bourbaki> a shot of my game :)
21:05:32 <wli> shapr: no, I just need O(1) indexing because the algorithms do random access
21:05:44 <shapr> oh
21:06:20 <bourbaki> you can race over the surface with the little red object
21:07:20 <bourbaki> its a mixture of warheads, worms and the old top down shooter 
21:08:40 <dons> SamC: what's this about yi eating computrons?
21:09:41 <wli> wow
21:09:51 <wli> bourbaki: how the heck?
21:10:22 <wli> I couldn't get hopengl to do anything useful
21:10:34 <wli> and all I wanted was gnuplot-like functionality
21:11:04 <wli> (updated in realtime a la xload)
21:11:20 <bourbaki> its dx
21:11:26 <wli> dx?
21:11:36 <bourbaki> i am thinking of doing a dx wrapper for haskell
21:11:53 <wli> what's dx?
21:11:55 <bourbaki> thats a game i have coded in haskell already but i didnt have had a good renderer
21:11:59 <bourbaki> directx
21:12:00 <wli> besides a differential
21:12:46 <bourbaki> :)
21:12:56 <bourbaki> i use a lot of differentials in my game ;)
21:13:08 <wli> physical simulation?
21:13:19 <bourbaki> that will look so awesome once there is a 3d texture on the landscape
21:13:20 <bourbaki> yes
21:13:30 <bourbaki> the particles always stay on the surface
21:13:34 <wli> what kind of physical simulation are you doing?
21:13:36 <bourbaki> but move like in 3d
21:13:45 <bourbaki> potential fields
21:13:54 <wli> rolling on a curved surface?
21:13:56 <bourbaki> so particles slide down hills and such
21:13:59 <bourbaki> yep
21:14:10 <bourbaki> and you can srite spells or weapons
21:14:13 <wli> friction?
21:14:18 <bourbaki> with a particle system
21:14:21 <wli> elasticity?
21:14:22 <bourbaki> yes with friction
21:14:33 <wli> (i.e. the surface deforming)
21:14:36 <bourbaki> elasticity of the surface is included but very slow atm
21:14:49 <bourbaki> though i wonder why cause in my old workspace it was really fast
21:15:14 <bourbaki> there are some consttucts in my code that seem ok but cost me a lot of speed i need a profiler to get rid of that
21:15:32 <bourbaki> otherwise you can deform the surface and the potential field is updated
21:15:36 <bourbaki> its even part of the game
21:15:52 <bourbaki> besides particles you can use the force fields to battle each other
21:16:11 <bourbaki> you cant move particles you need to distort the gravity
21:16:16 <wli> bourbaki: okay, I have super-dumb hopengl questions for you, then
21:16:30 <bourbaki> the gravity looks like the surface but its not rendered
21:16:35 <bourbaki> ok shoot
21:16:36 <wli> bourbaki: I get stats from /proc/ periodically, and I want to do something like xload
21:16:41 <bourbaki> im no gl crack though
21:16:52 <bourbaki> ok
21:17:05 <wli> i.e. 2D curve in a rectangular window, moving forward through time, etc.
21:17:19 <bourbaki> ok
21:17:46 <wli> say, every second or so, I get a new data point, move the curve over one unit, and connect the dots with a cubic spline or something
21:18:11 <wli> vaguely like gkrellm except I'm looking to monitor a lot of crap it doesn't
21:18:31 <wli> (and have next to zero interest in the crap it does monitor)
21:18:43 <bourbaki> hm
21:18:51 <wli> more like xload, I'm fine with crude as long as it's visual
21:19:06 <bourbaki> i dont quite get it yet
21:19:14 <bourbaki> you want to load something point by point?
21:19:25 <bourbaki> and make it a spline surface?
21:19:37 <wli> bourbaki: not even a surface, a 2D curve -- no actual 3D content
21:19:50 <bourbaki> and you want to know how to do that?
21:19:53 <wli> bourbaki: yes
21:19:59 <bourbaki> i have some code here
21:20:00 <wli> bourbaki: have you ever seen xload?
21:20:01 <bourbaki> in haskell
21:20:08 <wli> bourbaki: great!
21:20:10 <bourbaki> that does splines
21:20:21 <bourbaki> codemages.sf.net/homotopy1.hs
21:20:30 <bourbaki> and renders it in hopengl
21:20:50 <bourbaki> you even get a pline alphabet with that code ;) and spline morphing
21:22:55 <CoolPops> if formatting, is it customary to do align with the = of a function def?
21:22:55 <CoolPops> showFactorials (x:xs) = do
21:22:55 <CoolPops> ........................putStrLn ... etc ?
21:23:53 <wli> bourbaki: are these control points or something?
21:24:19 <CoolPops> Just curious, it's the way emacs is indenting for me and it would seem to be much easier to read if it indented, say, 4 spaces.
21:24:30 <bourbaki> wli: yes you define the control points and the tangents at these points and you then can interpolate smoothly
21:24:44 <wli> bourbaki: different from knots?
21:24:53 <bourbaki> wli: what is a knot?
21:24:56 <wli> bourbaki: (i.e. points off the curve vs. points on them)
21:25:03 <bourbaki> ah
21:25:10 <bourbaki> you mean like bezier splines
21:25:15 <wli> bourbaki: are these points on the curve or off them?
21:25:23 <bourbaki> they are on teh curve
21:25:25 <bourbaki> the
21:25:27 <wli> yes, bezier splines use off-curve points
21:25:44 <bourbaki> usually that is preferable imho
21:26:03 <bourbaki> especially since i wanted to use if for surface approximation
21:26:13 <wli> usually I get points on the curve and I want to draw a curve through them
21:26:28 <bourbaki> you can do that with the code i gave you
21:26:31 <wli> which is rather at odds with random off-curve points
21:26:35 <bourbaki> its hermite splines
21:26:36 <wli> okay, sounds great
21:26:43 <bourbaki> they walk through the points
21:26:45 <wli> Hermite splines are odd
21:26:53 <bourbaki> why?
21:27:07 <wli> I don't have tangents to work with, just samples (collected in realtime)
21:27:35 <bourbaki> then make then 0
21:27:48 <bourbaki> you will then get a linear interpolation though
21:28:03 <bourbaki> or you could use x-1 and x+1 for the tangent of x
21:28:42 <bourbaki> to get another type of spline just wrtie your own spline function the code should be addaptable
21:28:43 <wli> is there a way to use a different kind of spline or do I have to guess a tangent?
21:29:01 <bourbaki> i have defined a type Spline = Float -> Point2D
21:29:04 <bourbaki> er 3D
21:29:06 <wli> weird, there's no spline primitive?
21:29:22 <bourbaki> its just a type
21:29:54 <wli> renderPrimitive LineStrip $ mapM_ vertex3f (buildVertexList (buildHomPts 0.01 (0.5 * (1 + (sin (pi*t*2/360)))) homotopy 0))
21:30:06 <bourbaki> yes
21:30:12 <bourbaki> that just collects all the points
21:30:32 <bourbaki> they are retrived by the homotopy thingy
21:32:31 <wli> okay, burning question, then: what connects the dots?
21:33:15 <bourbaki> buildVertexList converts the sample 3d points to these hgl vertexformat
21:33:17 <wli> renderPrimitive LineStrip?
21:33:28 <bourbaki> that renders the curve
21:33:54 <bourbaki> ant the samples are generated with buildHomPts
21:34:32 <wli> but if I assemble a list of points, and convert them to what's expected, renderPrimitive LineStrip will do spline -like stuff or brute-force connect-the-dots?
21:34:50 <bourbaki> the latter
21:35:00 <wli> i.e. do I take a buttload of samples of the spline I generate by hand, or does it do the splinework for me?
21:35:00 <bourbaki> but you generate the sample points with the spline
21:35:17 <bourbaki> cant you run the code?
21:35:17 <wli> okay, sounds like you've nailed it for me then, thanks
21:35:29 <wli> I ran the code, but running it didn't help me understand it much
21:35:33 <bourbaki> nailed?:)
21:35:51 <bourbaki> but you can see what it looks like
21:35:52 <wli> yes, your explanation of renderPrimitive LineStrip and the vertex list solved all my problems
21:35:59 <wli> Yes, I see what it looks like.
21:36:01 <bourbaki> :)
21:36:15 <bourbaki> you can use the code if you like
21:36:23 <wli> thansk
21:36:33 <bourbaki> i think form now own ill do all that with classes
21:36:37 <bourbaki> no more types
21:37:00 <bourbaki> then i can interpolate over all vector fields
21:37:03 <wli> I'm not sure how much it will help directly (my plotting task is a bit different and I need a different sort of spline) but the explanation and concrete example were rather crucial to getting me started.
21:37:13 <bourbaki> once i have fully understood how to model a ring with a class
21:37:24 <wli> What sort of ring?
21:37:39 <wli> abstract algebra ring?
21:37:42 <bourbaki> mathematical ring
21:37:43 <bourbaki> yep
21:37:51 <wli> I have a notion...
21:37:57 <bourbaki> in haskell?
21:38:18 <bourbaki> i have a problem with things like abelian groups and such
21:38:39 <bourbaki> cause i dont know how to represent the commutativity of the * operator in a class
21:38:57 <wli> generally one doesn't try
21:39:05 <bourbaki> why?
21:39:19 <wli> bourbaki: there's my take on it
21:39:28 <bourbaki> thx
21:40:13 <wli> bourbaki: there are some "wild" things
21:40:35 <bourbaki> nice
21:40:45 <bourbaki> hm
21:40:55 <bourbaki> but then there is no destinction in this
21:41:03 <bourbaki> and what about * in a vector field ie
21:41:08 <wli> bourbaki: like ($) being a method of an Applicative class, so that e.g. polynomials (univariate and multivariate alike, though only univariate is done up there) can be applied
21:41:27 <bourbaki> you want to be able to do scalar * vector as well as vector * scalar
21:41:38 <wli> bourbaki: vector fields insist that the ring of scalars be a division ring, that kind of invariant isn't enforced on general modules
21:42:20 <wli> I do have such niceties as:
21:42:21 <wli> instance Module t t' => Module t (t'' -> t') where
21:42:21 <wli>         k .*. f = \x -> k .*. (f x)
21:42:30 <bourbaki> ok but you can model the commutativity with two operators there
21:42:49 <wli> bourbaki: I'm not aware of how if so. I didn't attempt to model commutativity anywhere.
21:43:49 <bourbaki> it would be even cooler to combine all these classes with some structure thats able to derive and integrate
21:45:01 <bourbaki> oh and i have a problem with topologies
21:45:08 <wli> differential rings are another problem
21:45:08 <bourbaki> the class definition of it that is
21:45:43 <wli> the invariants of differential rings i.e. the Leibnizness of the derivation, are invariants that can't be adequately expressed
21:47:00 <bourbaki> maybe i need to change to casl or so
21:47:15 <bourbaki> isnt there something that converts casl things to haskell programs?
21:47:27 <wli> likewise antidifferentiation being a right inverse of differentiation isn't expressible
21:47:30 <wli> what's casl?
21:48:16 <bourbaki> http://www.brics.dk/Projects/CoFI/index.html
21:50:09 <wli> one of the troubles with trying to do real math is that not only do you end up on the ass end of the Barendregt cube you're also stuck with inexpressible invariants
21:52:02 <bourbaki> damn i cant make an exe file that runs elsewhere then here ...
21:53:19 <wli> it may also be worth investigating LMA's vs. VMA's
21:54:22 <bourbaki> lma vma?
21:54:32 <wli> Load Memory Address and Virtual Memory Address
21:54:52 <wli> A feature of the ELF executable format used by boatloaders.
21:57:40 <bourbaki> ah man this looks so cool and i can show it to no none :( i think im going to do the particle system now
21:58:29 <wli> what particle system?
21:59:57 <CoolPops> data Maybe a = Nothing | Just a
21:59:57 <CoolPops> firstEle :: [a] -> Maybe a
21:59:57 <CoolPops> firstEle [] = Nothing
21:59:57 <CoolPops> firstEle (x:xs) = Just x
22:00:19 <wli> an interesting simulation problem was posed to me
22:00:21 <bourbaki> for my game
22:00:32 <CoolPops> firstEle [1,2]     ----> Just 1, how would I say 10 * firstEle [1,2] ?
22:01:08 <Lemmih> @type Data.Maybe.fromJust
22:01:08 <wli> the problem is that in general there is no such thing as a rigid body
22:01:09 <bourbaki> the idea is that you can shoot a hell of a lot colourfull particles
22:01:10 <lambdabot> Data.Maybe.fromJust :: forall a. Maybe a -> a
22:01:31 <bourbaki> and they get distorted by potential fields
22:01:34 <bourbaki> like gravity
22:01:38 <wli> things act as clouds of particles some of which are connected by "springs" reflecting crystal structure
22:01:41 <Lemmih> CoolPops: fromJust (Just 10) => 10
22:01:49 <bourbaki> you cant see all the potential field functions 
22:02:01 <bourbaki> they will look as if you hava raised a shield
22:02:20 <bourbaki> yes right fluid dynamics
22:02:43 <wli> almost; these are things usually considered solids, e.g. steel beams
22:03:13 <bourbaki> yes but i want to write a fast paced action game :) and not a physics simulator ;)
22:03:48 <wli> true
22:04:04 <CoolPops> Lemmih: to learn, how is fromJust coded? is it simple enough to key into irc?
22:04:18 <wli> fromJust (Just x) = x
22:04:22 <bourbaki> it will look so cool when someone will cast a flamerhrower spell and you cast a force field shield and the flame lick over the shield
22:04:27 <wli> fromJust :: Maybe t -> t
22:04:29 <CoolPops> hm, yes, that was easy.
22:05:13 * CoolPops should have known that, just went through the Pair, Triplet, Quad part of the tutorial.
22:05:34 <Lemmih> shapr: Ping.
22:05:38 <wli> bourbaki: well, it does have various interesting implications, e.g. large metal objects under the influence of strong forces bending
22:05:58 <wli> e.g. gravitational forces
22:06:06 <bourbaki> hm good idea i could make soft bodies
22:06:11 <wli> or shocks from earthquakes
22:06:24 <bourbaki> when you build your object with particles you can do that
22:06:34 <bourbaki> thats possible already
22:06:48 <bourbaki> its just slow though i dont know why
22:07:05 <bourbaki> i build my particle system with a cool trick
22:07:13 <wli> well, what you're doing for objects built of particles is probably already what needs to happen for the "physical simulation"
22:07:23 <bourbaki> so you can apply any kind of force to them be it inter particle of force fields :)
22:07:45 <wli> connecting particles by springs
22:07:54 <bourbaki> yep thats possible
22:08:17 <bourbaki> did that for a cloth simulation once
22:08:34 <Lemmih> shapr: Feeling like hosting a Haskell binding to ClanLib?
22:08:35 <bourbaki> though for my game there will be little use for that
22:08:48 <bourbaki> or i cant at least think of a cool thing for the game with that yet
22:08:59 <wli> you're already doing something like it
22:09:37 <wli> which is the surface deformed by the weight of the objects it supports
22:09:42 <bourbaki> i could do ropes with it
22:10:13 <bourbaki> oh right i get that for free :)!!!
22:10:18 <bourbaki> man am i cool
22:10:25 <bourbaki> heh ;)
22:10:28 <wli> I feel pretty cool myself
22:10:37 <bourbaki> i dont even need to do a spring force
22:10:45 <bourbaki> we are so cool ;)
22:11:06 <wli> I sped up an internal simulator for a major audited benchmark to 347% of baseline.
22:11:20 <bourbaki> then you will be able to do a lot of spells with particles and the forces
22:11:21 <wli> with one rather simple kernel patch
22:11:27 <bourbaki> though they are limited to gaussian functions atm
22:11:47 <bourbaki> not bad at all :)
22:12:09 <wli> bourbaki: "major" improvements are generally considered to top out at 5%
22:12:19 <wli> bourbaki: or rather, 105% of baseline
22:12:39 <bourbaki> what kind of benchmark?
22:12:54 <wli> it simulates TPC-C
22:13:05 <bourbaki> whats that?
22:13:16 <wli> http://tpc.org/ has dirt on it
22:13:28 <bourbaki> maybe you could help me speeding up my code as well ;)
22:13:41 <wli> it's a big deal for database vendors and hardware vendors
22:13:55 <wli> doubtful; this stuff is all way too high-level for my direct experience to apply
22:14:30 <bourbaki> i think its something with c++ anyway
22:14:39 <bourbaki> i have a lot of exps i wont get around them though
22:14:58 <bourbaki> but i did some changes to my code that made it run a lot slower
22:15:15 <bourbaki> like this
22:15:16 <bourbaki> 				getsurfacepoint( &pos2d, surfacehills, &pVertices[2*i+0+j*(resy+2)].position );
22:15:16 <bourbaki> 				pVertices[2*i+0+j*(resy+2)].colour   = colour;
22:15:16 <bourbaki> 				getsurfacenormal( &pos2d, surfacehills, &pVertices[2*i+0+j*(resy+2)].normal);
22:15:20 <wli> The things I know most about are assembly language and TLB's and privileged system-level features of various architectures... apart from suggesting reorganizations for cache locality there's probably not much I'd have to say.
22:15:51 <bourbaki> the pointers of the vertices i put into the function where done by external allocated pointers before and it was faster ...
22:15:58 <wli> If you have adequate changelogs and/or revision control you should be able to carry out binary search to find the change causing performance and/or functional regressions.
22:16:47 <wli> bourbaki: okay, it smells like cache
22:16:50 <bourbaki> i think ill just use vtune and such
22:16:53 <Riastradh> I just tried to build Yi from Darcs.  As soon as GHC was invoked the first time, in order to build Boot.hs, I got a bunch of 'variable not in scope' or 'data constructor not in scope' errors (for makeAll, MakeSuccess, MakeFailure, LoadSuccess, LoadFailure, & unloadPackage).
22:17:05 <wli> bourbaki: what did it look like before?
22:17:06 <bourbaki> how can i get around that cacheing prob?
22:17:09 <bourbaki> like
22:17:17 <wli> changing the layout of data structures
22:17:20 <bourbaki> pseudocodewise
22:17:34 <bourbaki> vertex* = &pVertices[2*i+0+j*(resy+2)].position
22:17:46 <bourbaki> and then i plugged in the vertex instead of the vertex directly
22:18:13 <wli> bourbaki: the indirection could be hurting if I understood that properly
22:18:35 <bourbaki> so what is the best way to get around that?
22:18:43 <bourbaki> just doing as i did before?
22:18:49 <wli> vertex *= &pVertices[2*i+0+j*(resy+2)].position smells like a nonlinear access pattern
22:19:51 <bourbaki> hm
22:20:05 <wli> bourbaki: I'd say go to vtune. These things have non-obvious answers a lot of the time. The "naive" cache eyeballing says the first thing you showed me (which you said was slower) should probably be faster.
22:20:06 <bourbaki> but that way it was faster then the other line
22:20:09 <bourbaki> and its linear
22:20:27 <bourbaki> yeah some things are pretty strange there codewise
22:20:32 <wli> s/linear/sequential/
22:20:39 <bourbaki> maybe the compiler cant to some optimizations that way
22:20:42 <wli> forward sequential is good
22:20:50 <bourbaki> its sequential as well
22:21:07 <wli> but you really have to do consecutive cachelines
22:21:20 <wli> loop ordering can affect it greatly
22:22:17 <bourbaki> hm
22:22:32 <bourbaki> how would i do that?
22:22:50 <bourbaki> its 2 loops that do the same thing as running over pixels in an image
22:23:14 <wli> well, you're doing direct 2D array fiddling, so the order of the loops can hurt you
22:23:25 <bourbaki> it will be twice as fast once i use indexed triangle strips anyway
22:23:35 <wli> what's an indexed triangle strip?
22:23:55 <bourbaki> but the array is filled sequentially
22:24:01 <bourbaki> i render the sufrace as a list of a strip
22:24:05 <bourbaki> 1 2 3 4
22:24:08 <bourbaki> is 
22:24:26 <bourbaki> the first trianble is
22:24:26 <bourbaki> 1 2 3
22:24:26 <bourbaki> the next is
22:24:26 <bourbaki> 2 3 4
22:24:26 <bourbaki> and so om
22:24:28 <bourbaki> on
22:24:54 <bourbaki> no i do just that resulting in some vertices that are there twice
22:25:03 <bourbaki> all the points that are not boundary
22:25:20 <wli> well, one way to get around the questions here is to start the whole shebang from consecutive sequential access, e.g. for (k = 0; k < ...; ++k) { /* derive the "virtual" indices from k by division/whatever */ ... }
22:25:27 <bourbaki> so when i use an index buffer the vertices are there just once in one buffer
22:25:47 <bourbaki> ah good idea
22:25:56 <wli> but division isn't
22:26:01 <bourbaki> but wont make the division the loop slwer?
22:26:02 <wli> running counters for i and j
22:26:31 <wli> j++; if (j >= whatever_js_max_is) { j = 0; i++; }
22:26:58 <wli> instead of actually doing any division
22:27:47 <bourbaki> also i think ill get rid of the colour of the vertex buffer
22:27:48 <wli> unless whatever_js_max_is is always a power of 2, in which case shifting-and-masking gets rid of the conditional advantageously
22:27:54 <bourbaki> costs me time to fill aslp
22:27:56 <bourbaki> also
22:28:22 <wli> it's a weird tradeoff
22:28:29 <bourbaki> and once ive done the index thing i can to it with one loop
22:28:29 <wli> it's not the same on all cpus
22:28:48 <wli> division sucks on almost all of them except for a couple, x86-64 among them
22:28:59 <wli> division is slow on ia32 due to the register footprint
22:29:05 <bourbaki> hm
22:29:25 <bourbaki> it would be so cool to get if hyper fast
22:29:35 <bourbaki> cause i have a cool feature that i cant make use of atm
22:29:38 <wli> there's only one more exception I can't recall offhand
22:29:45 <bourbaki> the surface is virtually infinite
22:29:48 <SamC_> lo dons
22:30:02 <bourbaki> so i can move the rendered patch over the surface
22:30:13 <wli> bourbaki: I don't think the armchair advice will work. I think you're going to have to go through the vtune grinder. If it were eyeballable it would probably be much more obvious.
22:30:14 <bourbaki> so you could race over an infinite plane
22:30:25 <bourbaki> plus you can make the surface to a torus and a cylinder
22:30:52 <bourbaki> do you know if there is any good free to use profiler?
22:31:10 <dons> hey SamC. I think i've fixed your haddock issues, but what about this "computron eating" issue? :)
22:31:34 <bourbaki> since i use the same functions for the particle system its better be fast
22:31:48 <cm> g'evening
22:32:06 <wli> I don't know of anything easily useful. One of the most enlightening things for me was to log a few GB of instruction-by-instruction execution data from a simulator and see what's sucking. This will probably not help you since you're dealing with cache effects and possibly slow instructions.
22:32:07 <bourbaki> wli: if you dont mind i would send you my function header with all important functions and you could have a quick look with optimizations eyes ;)
22:32:24 <SamC_> in os x, if you close the terminal window with yi running it asks if you would like to 'terminate' it, this I did whereupon yi started hogging the processor
22:32:25 <dons> SamC: it will help if you can tell me the os and ghc you use, and how to reproduce the behaviour
22:32:34 <dons> sorry. ok.
22:32:52 <dons> what signal is being sent when you 'terminate' in os x, do you know?
22:33:00 <wli> bourbaki: userland code is of a radically different nature from the privileged code; I'm already riding on mere general knowledge for this discussion
22:33:03 <SamC_> ghc 6.2.1
22:33:09 <SamC_> no
22:33:26 <wli> bourbaki: I can look but I really don't believe it will help much.
22:33:29 <bourbaki> wli: its just two crucial points
22:33:37 <wli> send it on
22:33:40 <bourbaki> there is at most 2 lines that can be optimized anyway
22:33:57 <bourbaki> the rest of the code is pretty well already imho
22:34:23 <CoolPops> data List a = Nil | Cons a (List a) .... how do I construct a List ? let a = (List 1 2 3)?
22:34:32 <bourbaki> http://rafb.net/paste/results/ODUv1866.html
22:35:13 <wli> to give you an idea, the optimization I mentioned I did earlier had to do with some things about speculation vs. atomic operations, a bit of queueing theory, and some TLB flushing crud
22:35:23 <dons> SamC_: this seems to be an osx-specific problem (I've tested signal handling on other *bsd, and linux), but I do have access to os x, so I'll have a look.
22:36:00 <dons> if you could reproduce it by using kill, that would speed things up
22:36:31 <bourbaki> one thing that will give me a speed up i guess is getting rid of the optexp call
22:37:01 <wli> bourbaki: nothing in particular stands out there. the optexp call probably helps cut down on icache footprint and is likely to stay hot in the branch target buffer
22:37:37 <wli> bourbaki: I'd start looking for which of those things gets pounded hardest and do the inlining of optexp manually there only
22:37:44 <SamC_> kill seems to be ok
22:38:08 <wli> or other possibilities
22:38:23 <wli> wait a minute
22:38:25 <wli> return exp(x);
22:38:27 <wli> that's all it does
22:38:37 <wli> yes, dump optexp
22:38:43 <bourbaki> yep
22:38:53 <bourbaki> i tried to do a taylor polynomail there
22:39:00 <dons> SamC_: ok. that's good to know. 
22:39:08 <wli> it won't change the world but it's useless
22:39:10 <bourbaki> but my surface is to build of a small lookup
22:39:41 <wli> dgaussdx() and dgaussdy() are redundant
22:39:44 <bourbaki> i thougt about changeing to polynomails insted of the gauss
22:40:00 <bourbaki> one multiplies with x the other with y
22:40:08 <wli> 	float d = (mx-x)*(mx-x)+(my-y)*(my-y);
22:40:08 <wli> 	if( d==0.0f ) return 0.0f;
22:40:11 <wli> 	float c = -(1/((2*sigma*sigma)*scalewidth));
22:40:13 <SamC_> what was the haddock issue?
22:40:17 <wli> those 3 lines are duplicated in both
22:40:20 <bourbaki> yes
22:40:29 <bourbaki> if you want to query both you use another function
22:40:31 <SamC_> should I re-get?
22:40:35 <wli> okay
22:40:43 <bourbaki> its a bit downward
22:40:52 <dons> SamC: well, there was a problem with backslashes in Nano.hs. you can just 'darcs pull' the latest patch
22:41:03 <dons> I couldn't find a problem with Boot.hs though.
22:41:37 <wli> bourbaki: using inlines for the shared pieces helps sometimes
22:41:56 <bourbaki> hm
22:42:06 <wli> not for speed
22:42:10 <bourbaki> there is another difference also now that i think of it
22:42:13 <wli> just keeping them in synch
22:42:15 <wli> do tell
22:42:26 <bourbaki> i had the indices of the loops as defines in the beginning
22:42:31 <wli> ah
22:42:35 <wli> that can hurt
22:42:40 <bourbaki> mabye the compiler did unroll the loop then
22:42:43 <wli> they're variables now, aren't they?
22:42:52 <bourbaki> i dont have now and its slower now
22:42:56 <SamC_> dons: I also got this warning: Warning: Yi.Undo: the following names could not be resolved:
22:42:56 <bourbaki> yep
22:42:59 <SamC_>     Point Size ForeignPtr CChar Buffer IO Bool
22:43:12 <dons> that's fine. haddock is lazy
22:43:13 <wli> can you ram them back to being defines for expedience?
22:43:16 <bourbaki> all that stuff is in another file though
22:43:38 <bourbaki> yes i think i can do that for a test
22:43:47 <wli> give it a shot
22:44:09 <wli> a compiler flag or something to try to get it to unroll the things anyway could help
22:44:12 <bourbaki> the problem is that my performance is so low that i wont see any big differences but lets see
22:44:17 <wli> or a pragma
22:44:38 <wli> how low is the performance? what % of realtime?
22:44:47 <bourbaki> when you do matrix stuff with loops then its slower as if you write it out by hand
22:45:22 <bourbaki> when i dont update everyframe i have like at least 70 frames even with a million triangles
22:45:30 <bourbaki> or more 
22:46:14 <wli> I'm going to take a stab at my kernel monitoring xload
22:46:32 <wli> I wonder
22:46:41 <wli> is there a way to make beeps etc. when certain things happen?
22:46:41 <bourbaki> damn there are too much dependancies on this variable though
22:46:55 <bourbaki> things like what?
22:46:57 <wli> well, I guess that's beeping anyway
22:47:05 <wli> just something to beep
22:47:14 <bourbaki> like when the microwave is done ;)
22:47:18 <wli> I can figure out when things are happening
22:47:29 <SamC_> not limited to boot ... Yi/Curses/UI.raw-hs:1:1: Parse error
22:47:32 <bourbaki> here on irc on your program?
22:47:33 <wli> yes, PC speaker or other audio crud, no need for mp3's, just plain old beeping
22:47:41 <wli> bourbaki: no, hopengl/whatever programs
22:47:56 <bourbaki> you could cat a file do the sound card
22:48:09 <wli> that's a bit crude...
22:48:21 <wli> Nothing formalized, then, I take it?
22:48:23 <bourbaki> thats how i played files ;)
22:48:28 <bourbaki> wave
22:48:34 <bourbaki> .wav should do the job
22:49:02 <wli> I'll look around to see how xbiff does it
22:50:30 <wli> "danger, lowmem is getting low"
22:50:41 <wli> I could record myself saying that or some such.
22:52:13 <bourbaki> :)
22:52:52 <dons> SamC_: what version of haddock do you have?
22:53:13 <wli> probably more effective would be sending email to root or a configured email address
22:53:17 <SamC_> 0.6
22:54:21 <dons> SamC_: maybe you're source is out of date, somehow? hmm, or could it be cpp?
22:54:46 <wli> I guess a decent conecpt for it would be point it at a /proc/ file and specify which number out of it by e.g. leading field name or whatever to chart
22:55:23 <SamC_> my source for what?
22:55:37 <wli> maybe with a number saying the n-th difference or sum should be used instead
22:55:41 <dons> SamC_: what appears on line 1, column 1 of Yi/Curses/UI.raw-hs?
22:55:51 <dons> source for yi
22:59:46 <wli> bourbaki: speaking of splines, got any "nice" curve-fitting algorithms?
22:59:48 <SamC_> doesn't exists, oops :) ; for boot.raw-hs # ; I only got yi today
23:00:15 <dons> it doesn't exist? Yi/Curses/UI.* ?
23:00:32 <wli> bourbaki: e.g. schnazzier things than cubic splines like rational splines or something?
23:00:41 <SamC_> it doesn't exits Yi/Curses*
23:00:46 <bourbaki> wli: for what kind of curve?
23:01:12 <dons> SamC_: hmm.. is your yi very old? I'm a bit confused.
23:01:13 <bourbaki> wli: no sry cant help you there
23:01:15 <wli> bourbaki: basically one derived from sample points of kernel data... let me get a quick data dump
23:01:31 <SamC_> my yi is from today
23:01:33 <CoolPops> data List a = Nil | Cons a (List a) ... how do I construct a value of type List ?
23:01:39 <dons> SamC_: or is the raw-hs not being generated on 'make docs' ??/
23:02:15 <dons> it stops after Boot.hs, does it?
23:02:52 <dons> when you type 'make docs' you should see a lot of ghc ... -D__HADDOCK__ -E -optP-P Boot.hs .. lines, for all the files
23:03:01 <bourbaki> wli: are you familiar with wavelets?
23:03:02 <wli> 58 1345 1428 1667 1403 1342 1395 1356 1343 1341
23:03:06 <wli> vaguely
23:03:13 <SamC_> yes fo wait much apologies
23:03:24 <bourbaki> wavelets get you a good idea of general function approximation
23:03:52 <bourbaki> and all inerpolations i know base on orthogonal functions
23:03:53 <wli> could be; maybe I'm better off with filters
23:04:06 <wli> wiener filters etc.
23:04:15 <bourbaki> whats that :)?
23:04:29 <SamC_> Yi not yi, sorry, the first two lines of UI.raw-hs are #pragma GCC set_debug_pwd "/Users/sam/yi"
23:04:32 <SamC_> {-# OPTIONS -cpp -#include YiUtils.h -#include <signal.h> #-}
23:04:50 <dons> ah!
23:05:02 <dons> that #pragma line is completely bogus
23:05:13 <dons> it must have been inserted by osx cpp 
23:05:30 <dons> just delete it -- and if you know how to stop it being generated, that would be good too
23:05:44 <dons> the first line should be the {-# OPTIONS .. #-} line
23:05:55 <wli> I don't have a simple explanation. The idea is to convolve a signal with some other signal so that a random "noise" added to the signal will be eliminated
23:06:10 <SamC_> I'll look into it
23:06:31 <SamC_> must have food now, thanks for help
23:07:32 <dons> I see that in ghc, they use grep -v '^#pragma GCC' to strip those lines from package.confs
23:07:45 <dons> I could add that to raw-hs generation too
23:08:04 <wli> ultimately I want to look at these "kernel variables" etc. as something of a state vector evolving according to some law or other and try to discover correlations with fluctuating performance etc.
23:09:50 <wli> which is where the SVD comes in; the idea there is to find "directions" the things move in.
23:10:22 <ozone> dons: yeah, that #pragma line that the mac cpp puts in is a _real_ pain in the arse
23:10:27 <wli> where the largest singular values correspond to the strongest effect
23:10:45 <dons> ozone: does something like -traditional turn it off?
23:11:24 <dons> and why doesn't this break haddock on the mac, in general?
23:11:39 <wli> this is not really expected to be static but rather feeding into a least-squares based optimal control algorithm
23:12:16 <wli> a.k.a. "dynamic programming", unrelated to the memoization techniques from freshman/HS programming
23:12:35 <ozone> dons: yeeeah, hang on, lemme find out exactly what stupid commandline you need to use ...
23:12:57 <wli> (the usage there is archaic and of mathematical origin)
23:12:57 <ozone>   CPP="gcc3 -E -traditional-cpp" \
23:13:02 <ozone> that's it
23:13:13 <dons> cool! I'll try that out
23:14:00 <wli> it's expected to act on slow timescales (e.g. minutes between tuning decisions) so efficiency is not a large concern
23:14:58 <wli> but it can't be degenerate, e.g. list-based representations of matrices causing explosions in running times of linear algebra algorithms
23:15:25 <wli> its own resource footprint is also a concern, so heavy cpu burn is unacceptable
23:15:42 <wli> but it's only in terms of cpu share, not absolute consumption or speed
23:16:16 <wli> likewise with RAM, but that's hard to flub
23:16:45 <wli> this is something of a competing project to a recent "genetic algorithm" post
23:17:16 <wli> in two senses
23:17:37 <wli> the first is that it puts optimal control methods in competition with genetic algorithms
23:18:18 <wli> the second is that it puts userspace control of tuning parameters carried out on behalf of administrators by programs in competition with in-kernel execution of self-tuning policies
23:19:12 <wli> the SVD is a tiny step, just a subroutine for solving an intermediate least squares problem
23:21:40 <wli> if I can't get anywhere with it fast I have to drop it
23:22:46 <SamC_> oh good hurray for ozone
23:23:00 <ozone> SamC_: that fix you up?
23:23:27 <SamC_> I haven't tried it, but surely so
23:35:22 <Lemmih> shapr: ping.
