01:21:17 <wli> well, the thing I wanted a logic programming interpreter for was a move legality checker for user-definable chess variants
01:23:02 <wli> there's an important reason why uniqueness matters there
01:23:15 <wli> which is explosive combinatorial growth
01:24:02 <wli> just checking that a move doesn't result in check can get rather hairy with e.g. a bishop on a Klein bottle
01:24:43 <wli> making the Klein bottle user-definable is pretty hairy too
01:25:36 * Lemmih wonders who wli is talking to.
01:25:44 <wli> no idea
01:25:54 <wli> I'm just blabbing I guess.
01:28:43 <wli> You don't seem to like most of my ideas (e.g. dumping the built-in numeric hierarchy). Probably better if you paid no attention to it.
01:41:41 <Cale> He's talking to whoever he was talking to before, and given the people on this channel, whoever that is will probably get his messages.
01:44:31 <desrt> cale, for example, probably caught my messages about why his keyboard is not working
01:44:41 <Cale> yeah :)
02:04:25 <desrt> http://headlinehumor.com/images/signs/s57.jpg
02:04:26 <desrt> he he
02:10:16 <ibid> medbörjare
02:10:31 <desrt> ibid; your irc client appears to be broken
02:10:46 <ibid> how?
02:10:56 <Lemmih> ibid: "Fellow citizens"?
02:11:09 <ibid> Lemmih: an attempt at that, anyway :)
02:11:10 <desrt> ibid; it's sending invalid utf8 characters
02:11:13 <musasabi> desrt: he was just using iso-8859-1
02:11:22 <desrt> musasabi; sounds broken to me
02:11:22 <ibid> desrt: it's not sending any utf8
02:11:24 <musasabi> desrt: which is the correct way ;p
02:12:03 <musasabi> the main problem is that irc is broken from an i18n pov
02:12:19 <desrt> not if you use utf8 and ignore the bidi problem
02:12:20 <ibid> Lemmih: there is a long-standing finnish joke about a politician who pronounced medborgare 'fellow citizens' as medbörjare 'fellow beginners'
02:12:50 <musasabi> desrt: but using utf8 will get you yelled at on any finnish channels.
02:12:54 <ibid> desrt: there are channels where i'd be murdered for using utf-8 instead of latin-15
02:13:10 <desrt> musasabi/ibid; that's retardedly stupid
02:13:45 <musasabi> desrt: I think that that was originally used on irc ;)
02:13:55 <desrt> i think ascii was :)
02:14:01 <ibid> Lemmih: i was just reminded of it by listening to our president's new year speech
02:14:10 <ibid> neither was
02:14:41 <ibid> the original irc character set was ISO 646, Finnish variant
02:15:47 <desrt> 2.2 Character codes
02:15:47 <desrt> No specific character set is specified. The protocol is based on a a set of codes which are composed of eight (8) bits, making up an octet. Each message may be composed of any number of these octets; however, some octet values are used for control codes which act as message delimiters.
02:15:53 <ibid> desrt: anyway, your irc client seems to be broken if it cannot handle both utf-8 and latin-1
02:16:10 <desrt> ibid; utf8 and latin-1 are not disjoint
02:16:21 <desrt> and their union is ambiguous
02:16:39 <ibid> desrt: yes, and notice how { is considered a lower-case character
02:16:48 <musasabi> desrt: most local channels use country specific encodings and anyone using utf8 is killed off.
02:16:48 <ibid> desrt: my client handles it just fine
02:17:08 <tuomov> musasabi: unfortunately
02:17:29 <tuomov> I find it sad that people are opposed to switching to utf8 on many local channels
02:17:42 <ibid> if you can tell me how to make irssi send different character sets for different channels, please do so :)
02:17:47 <tuomov> easy
02:17:51 <musasabi> well that would involve switching all channels ;)
02:17:58 <ibid> tuomov: so tell me
02:18:03 <desrt> utf8 is nothing new
02:18:12 <desrt> every other sane corner of the world has switched to it
02:18:13 <tuomov> you need the charconv module or irssi from cvs
02:18:19 <musasabi> irc is older than utf8 in general use.
02:18:24 <desrt> why not strange scandinavian irc channels?
02:18:24 <tuomov> I don't know how to do this in the cvs irssi, but the charconv module has instructions
02:18:45 <tuomov> http://norpan.org/cvs/charconv/
02:18:47 <ibid> desrt: i'm not on any scandinativan channels
02:19:02 <desrt> scannedinavian ones?
02:19:14 <musasabi> installing irssi cvs on this sparc with a wicked perl sounds challenging.
02:19:17 <ibid> well, if this is one... :)
02:19:24 <tuomov> something like /charconv add * #channel network charset
02:19:33 <desrt> ibid; it has scannedinavian content....
02:19:49 <musasabi> canned scans?
02:19:59 <ibid> heh
02:20:05 <ibid> tuomov: is there a debian package?
02:20:15 <tuomov> the charconv module also understands latin1 if it fails to decode utf-8
02:20:20 <tuomov> ibid: I don't think so :(
02:20:35 <desrt> tuomov; i'd totally install that if i didn't actually *enjoy* being a charset nazi :)
02:20:48 <ibid> i'm currently using some perl module
02:20:57 <tuomov> yeah, there's that one too
02:21:01 <desrt> as far as i am concerned seeing [invalid character] markers is the only acceptable behaviour if someone sends latin-1 :)
02:21:26 <tuomov> charconv can also be configured for each nick
02:21:29 <tuomov> (the * in the above line)
02:21:32 <musasabi> on some channels sending utf8 sends an automated complain from a bot..
02:21:40 <tuomov> lame channels..
02:21:48 <tuomov> the world should switch to utf8!
02:21:56 <desrt> on come channels, sending non-utf8 results in a kick
02:22:02 <desrt> from a bot
02:22:12 <musasabi> lots  of people and admins too lazy to tell 50+ people how to upgrade their irc.
02:22:35 <tuomov> freenode could have /nickserv set charset or something..
02:23:05 <desrt> freenode's nickserv sucks too badly for that to work
02:23:08 <tuomov> er.. +msg
02:23:23 <musasabi> nickserv just works.
02:23:25 <desrt> you -might- be able to have it as a umode
02:23:49 <desrt> (that gets automatically set if the irc server detects you sending invalid utf8)
02:25:11 <tuomov> alternatively people could just move to silc
02:25:54 <desrt> the whole point of this would be to avoid people fixing/changing software on their own machines
02:28:14 <desrt> alternatively, the people running the channel could setup a relay bot between #channel and #channel-legacy
02:28:28 <tuomov> hmm... debian doesn't seem to have the irssi-like official silc client
02:28:34 <tuomov> only some crappy gtk one
02:28:34 <desrt> and kick people who say latin-1 stuff in #channel with a message directing them to go to #channel-legacy
02:28:51 <desrt> gtk1?
02:29:02 <musasabi> isn't there an irssi silc plugin?
02:29:13 <tuomov> I don't know which one. It's GUI; it's bad.
02:29:38 <desrt> musasabi; yes
02:29:43 <ibid> hmm, apparently recode.pl does have channel distinction capability, though only by editing the script
02:30:01 <ibid> network-level setting would be nice
02:30:09 <tuomov> well, can't seem to find such a thing either
02:30:27 <desrt> tuomov; use google
02:30:33 <tuomov> apt-cache search
02:30:49 <tuomov> I'm too lazy to start compiling stuff
02:30:58 <tuomov> or downloading a deb
02:31:01 <tuomov> manually
02:31:21 <desrt> http://penguin-breeder.org/silc/
02:31:32 <desrt> oh.  pfft.
02:41:23 <ibid> Ã¶Ã¤
02:41:26 <ibid> which charset?
02:42:48 <ibid> anybody? what charset am i sending now (hÃ¤)?
02:43:21 <tuomov> don't know; my irssi interprets it correctly in both cases
02:43:42 <ibid> i tried to set this up so that it'll use utf-8 on freenode
02:44:06 <ibid> desrt: hmm?
02:44:35 <vegai> you're sending utf-8 :P
02:44:42 <ibid> nice :)
02:45:41 <ibid> am i still sending utf-8 here? Ã¤Ã¶Ã¤?
02:47:35 <ibid> vegai: ?
02:50:39 <tuomov> sigh.
02:50:47 <ibid> hm*?
02:50:49 <tuomov> it would seem that silc-server and silc-client missing from debian is a patent issue
02:51:00 <tuomov> I wonder why they're not in non-us, though..
02:51:08 <tuomov> fsck patents
02:51:29 <tuomov> debian really needs a 'warezian' extensions with all the software in the world
02:51:49 <tuomov> move non-free there too and all the software there is
02:52:18 <tuomov> or soon there will be no debian packages at all
02:54:34 <tuomov> the nice thing about gentoo is that they don't care about these things
02:54:42 <tuomov> but I don't like a source-based distro
03:01:07 <vegai> ibid: yes, you are
03:01:21 <ibid> nice
04:56:45 <ned> http://hal.ccsd.cnrs.fr/ccsd-00003582
04:57:30 <Heffalump> bah, don't do things like that to me on a holiday!
04:57:43 <ned> :)
04:57:58 <ned> i don't do anything, i did not even read it :)
04:58:00 <Heffalump> actually, that looks interesting.
04:58:07 <Heffalump> oh, so you can't answer my question..
04:58:13 <ned> no :)
04:58:26 <Heffalump> fat lot of use you are then :-)
04:59:44 <zames> ERROR "/usr/lib/hugs/libraries/Hugs/ST.hs":50 - Syntax error in type expression (unexpected `.')
04:59:46 <zames> funky
05:00:37 <TheHunter> zames, you should use hugs -98.
05:01:20 <Heffalump> it's annoying, that.
05:01:33 <Heffalump> (that the error message is so confusing because the parser itself changes)
05:01:35 <zames> thanks, TheHunter 
05:02:14 <TheHunter> (actually, if you're beginning to need higher rank polymorphism, you'll soon find yourself using ghc)
05:02:37 <zames> it's not me that needs it, but alex
05:03:13 <Heffalump> ST is a self-contained module
06:29:03 <termol> hi
06:29:45 <termol> can i multiply an Int with a Float?
06:29:57 <esap> yes
06:30:07 <esap> by doing a conversion.
06:30:18 <termol> ok, how?
06:31:14 <esap> fromIntegral
06:31:40 <termol> @type fromIntegral
06:31:43 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
06:31:57 <termol> what does that mean?
06:32:35 <esap> it means if you have a number that provides 'Integral' interface, you can convert it to any number that provides Num interface.
06:34:08 <esap> Say, set a = Int and b = Float, then this function converts an Int to Float.
06:34:52 <termol> so if a=5 and b=0.34 then i would write fromIntegral a * b
06:35:40 <esap> yes. If you want to be explicit with the types, you might use something like (fromIntegral :: Int -> Float) a * b
06:37:00 <termol> when i'm at the hugs prompt i can type expressions like 5*0.34 without problems. why is that?
06:37:49 <esap> termol: there are some defaults for it.
06:38:20 <esap> termol: you can do that with ghc as well, but it says "Warning: Defaulting the following constraints..."
06:38:29 <esap> termol: I mean ghci
06:39:05 <termol> are the conversions necessary alson for + and - ?
06:39:12 <termol> also
06:40:13 <esap> normally all operations are overloaded so they work with multiple types of arguments. The problems occur when you have two different types for different arguments, then you need to convert both to same type.
06:41:27 <esap> so you can write '5.0 * 3.0' and '5 * 3', but should be writing '5.0 * fromIntegral 3'
06:41:53 <termol> explicitly i'm having problems with this expression y+size*h  where y and size are Int and h is Float
06:42:31 <esap> what should be the result type? Int or Float?
06:43:28 <termol> Int
06:44:46 <esap> termol: Then perhaps y + floor (fromIntegral size * h) does what you want.
06:45:04 <esap> or you could use 'ceil', or 'round'
06:45:11 <termol> or truncate?
06:45:26 <esap> right. Actually, ceiling, not ceil.
06:46:20 <samc_> MegaMonad: do you like hugs?
06:46:22 <MegaMonad> samc_: Hugs has some version of hugs that i should try to automate, even if it's actually nil.
06:47:15 <termol> ok i'll try that thx. these rules seem a bit annoying, but i guess they serve a good purpose...
06:48:01 <esap> yes, there are no automatic conversions. Yes, when you're doing numeric work, it's somewhat annoying.
06:48:37 <samc_> MegaMonad: do the rules serve a good purpose?
06:48:39 <MegaMonad> samc_: Because they serve a good purpose?
06:49:06 <termol> well in c++ you never know what type the result will have. the rules are complex.
06:50:11 <esap> termol: that's probably one reason why Haskell doesn't have automatic conversions. They're ugly. Sometimes such conversions are practical, though.
06:51:05 <termol> yes, i never liked automatic conversions anyway...
06:51:53 <esap> there is a hackish 'defaulting' mechanism that tries to make numeric work easier, but it has not been very successful.
06:52:40 <termol> you mean in haskell?
06:52:43 <esap> yes
06:52:55 * esap has never used it.
06:53:27 <esap> if you find the conversions annoying, you might look at it.
06:54:07 <termol> there annoying but the opposite is even more annoying in my opinion...
06:54:29 <esap> termol: see http://www.haskell.org/onlinereport/decls.html#default-decls
06:55:11 <termol> have you read the haskell report?
06:55:15 <esap> yes
06:55:39 * esap learned haskell from reading the report.
06:57:50 <samc_> MegaMonad: how did you learn haskell?
06:57:51 <MegaMonad> samc_: Maybe tuomov was forced to learn the concepts, but the haskell i have a builtin to make me do it, but that was to blame.
06:59:08 <aj> hrm, haskell's type safety is almost ruining python for me :(
06:59:46 <samc_> MegaMonad: surely such a builtin will revolutionise teaching
06:59:47 <MegaMonad> samc_: A few do, but they were teaching with a pullover is a serious performance hit) to make it a builtin?
07:00:27 <samc_> MegaMonad: I guess not then
07:00:28 <MegaMonad> samc_: I'm wondering if you have to prefix all the same (order of parts, then the end for you, i guess.
07:01:25 * samc_ gets back to work
07:20:03 <Heffalump> anyone know what the recommended way of using Cabal is for a package where one of the Haskell source files is auto-generated by custom means?
08:20:51 <autrijus> hi. in GHC is there an easy way to convert between Word16 and (Char:Char:Char:[])?
08:21:22 <autrijus> I've found Storable, but it seems to only do it with IO Ptr strings.
08:21:32 <autrijus> err, I mean (Char:Char:[]).
08:23:06 <musasabi> autrijus: yes.
08:23:57 <autrijus> thank you. may I inquire as of how? :)
08:24:18 <musasabi> w16ToChar w = let i = fromEnum w in [chr (i / 256), chr (i `mod` 256)]
08:24:45 <autrijus> oh. ok.
08:25:01 <musasabi> s/\//div
08:25:13 <autrijus> `div` ?
08:25:14 <waltz> Are there any IRC bots written in Haskell?
08:25:28 <ac_mac> waltz: yes
08:25:29 <ac_mac> lambdabot
08:25:30 <musasabi> w16ToChar w = let i = fromEnum w in [chr (i `div` 256), chr (i `mod` 256)]
08:25:31 <ac_mac> @arr
08:25:31 <lambdabot> Avast!
08:25:35 <waltz> ah
08:25:57 <ac_mac> waltz: do you really think we'd settle for anything less in #haskell? :)
08:25:58 <musasabi>  / is for fractionals, div for integer division
08:26:08 <waltz> heh
08:26:18 <waltz> Is the source code for lambdabot available?
08:26:22 <musasabi> yes.
08:26:41 <waltz> Link pls.
08:28:14 <musasabi> http://www.scannedinavian.org/repos/lambdabot/
08:28:29 <autrijus> so if I have various sized things, and I'd like to use the same toString and fromString function, should I make a new class and instantiate Word16 etc to it?
08:28:35 <musasabi> (had to google things)
08:28:51 <musasabi> you could do that.
08:29:10 <autrijus> or is it a better/easier way to parameterize the argument to toString?
08:29:10 <musasabi> but if you want to have fast binary io, you probably don't want that.
08:29:45 <autrijus> I see. I started out writing marshalling code for Hex16 and Hex24 etc
08:30:53 <autrijus> but the resulting toCStringLen is always monadic
08:31:16 <autrijus> I'll play with both and see if the type class way is slower. thanks for the help
08:31:23 <autrijus> s/slower/unbearably slower/
08:31:29 <waltz> hmm
08:31:42 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/dns contains code for the monadic way. (LoWire and HiWire.hs)
08:31:58 <autrijus> danke.
08:32:22 <musasabi> autrijus: but if you are doing "fast" binary io, you want to have ptrs (or efficient arrays)
08:32:38 <autrijus> musasabi: I'm writing the AFP filter processor
08:32:47 <autrijus> AFP is like PDF, but even more binary
08:33:05 <musasabi> I have some quite nice immutable nonmonadic binary code, but it is still too infantile to release.
08:33:07 <autrijus> the usual usage pattern is to only touch a few textual records in the input stream
08:33:32 <autrijus> so I try to only parse the interesting parts
08:33:46 <autrijus> with 
08:33:47 <autrijus> > type Chunk = (ChunkType, ChunkData)
08:33:47 <autrijus> > data ChunkData = Raw RawData | Record  (RecordItem, RecordMembers)
08:34:05 <autrijus> so most of the RawData will be in CStringLen if needed
08:34:21 <autrijus> I'm trying to keep the Record side to be nonmonadic.
08:34:46 <musasabi> the Binary module contained some code to skip over portions of the input stream nicely.
08:35:03 <musasabi> but that is kind of hackish.
08:35:23 <autrijus> there is a binary module?
08:35:28 * autrijus googles
08:35:39 <autrijus> MissingH.IO.Binary?
08:36:04 <mornfall> howdy autrijus 
08:36:10 <autrijus> hi mornfall.
08:36:20 <mornfall> i didn't notice you in #haskell? =)
08:37:20 <autrijus> mornfall: yeah, since I volunteered to port the darcs patch algorithm to svk, I now have to learn haskell :)
08:37:46 <mornfall> autrijus: uhm, it's not there already? o_O
08:37:49 <autrijus> "port", as in "annexing everything using Inline::Haskell"
08:37:50 <mornfall> still doing smerge?
08:37:59 <musasabi> no, the GHC binary module.
08:38:10 <autrijus> mornfall: the push/pull has been smarter but you can't easily revert a pull.
08:38:46 <mornfall> ahh
08:39:23 <autrijus>     Can't find module `Binary'
08:39:23 <autrijus>     Can't find module `GHC.Binary'
08:39:30 <autrijus> this is ghc 6.2.2
08:39:40 <autrijus> I think I'm missing something
08:40:37 <musasabi> autrijus: no it does exist - it is simply not packaged up in a nice way.
08:43:23 <autrijus> oh it's in the source tree.
08:43:27 <autrijus> I see. gack.
08:45:50 <autrijus> it looks like it's solving exactly the same problem.
08:47:26 <autrijus> pure lazy random access.
09:12:19 <samc_> MegaMonad: why am I so lazy?
09:49:18 <Heffalump> *GAH*
09:49:42 * Heffalump runs into the can't have a module both be a Main module and a library for something else problem
10:09:52 <Heffalump> ahah.
10:09:55 * Heffalump comes up with a cunning hack
10:17:43 <Asta> Heffalump: why can't it be both? I thought any name was ok for a main module has long as it has a main function defined...
10:18:27 <Heffalump> asta: you have to use -main-is with GHC, and then it compiles the module as if it was module Main
10:18:37 <Heffalump> and so then trying to use the .o file as a library for another application causes a clash
10:33:14 <zipper> if a cat sucks on it's foot is it bad for it's health?
10:34:48 <dottedmag> zipper: after reading man cat(1) still can't understand how cat(1) may suck and where is it's foot.
10:35:08 <Heffalump> cat | tail
10:36:02 <dottedmag> cat with the foot stick in pipe :)
10:37:07 <tuomov> paste | cat | head | tail
10:37:17 <juhp> lol
10:37:38 <zipper> :/ this is serious
10:39:08 <Asta> Heffalump: ah gotcha
10:39:48 <autrijus> is there a standard way to open a subfile?
10:39:55 <tuomov> subfile?
10:39:55 <autrijus> i.e. a section inside a file
10:40:05 <autrijus> and have it throw eof when then upper bound is reached
10:40:23 <autrijus> I'm using the GHC.Binary code right now
10:40:36 <autrijus> and it doesn't seem to easily support this
10:50:24 <juhp> autrijus: which os?
10:50:54 <autrijus> freebsd.
10:53:18 <autrijus> the data format I'm parsing is like
10:53:19 <autrijus> (Type,Len,{Data,[{MemberType,MemberLen,MemberData},...]},Type,Len,{Data}...)
10:53:40 <autrijus> where Len denotes the next Data group, which may in turn contain more member type/len/data data
10:57:31 <autrijus> never mind; I think I'll just implement my own Binary.get parameterized over the "Type" field
11:14:17 <Heffalump> why is package.conf not in /etc in Debian?
11:22:11 <autrijus> :r
11:22:18 <autrijus> oops.
11:23:56 <Igloo> You shouldn't be editting it
11:24:27 <Heffalump> oh, good point
11:25:21 <Igloo> Although changes won't be lost if you do
11:26:52 <Heffalump> what mechanism edits it?
11:26:59 <Igloo> ghc-pkg
11:27:22 <Heffalump> oh, I thought there was a common mechanism for all compilers now. But actually that's pointless, as binary packages will know what compiler they use.
11:27:36 <Igloo> cabal should call ghc-pkg for you
11:28:45 <Heffalump> right
11:29:07 <Heffalump> so how do I install a library without going via .deb without breaking your "shouldn't" above?
11:30:55 <Igloo> Any changes you make to packages.conf won't be removed (unless the GHC version changes from 6.2.2)
11:31:13 <Igloo> So whatever cabal or ghc-pkg does should work fine
11:31:33 <Heffalump> hmm.
11:31:36 <Heffalump> oh well.
11:32:13 <Igloo> ?
11:32:27 <Heffalump> well, you did say above I shouldn't be editing it, so why is it ok for a program I run to edit it?
11:32:45 <Igloo> ghc-pkg is allowed to edit it, it owns it
11:32:51 <Igloo> It knows what format it uses
11:32:55 <Heffalump> ah, true
11:35:52 <Heffalump> what's a good package to put a library that sends SMSes using one specific provider's API in?
11:41:19 <Heffalump> oh well, SMS. it is for now
12:11:17 <shapr> yow!
12:16:04 <waltz> woy!
12:16:22 <waltz> 'Afternoon Sir shapr.
12:17:33 <shapr> wassup waltz ?
12:17:43 <waltz> nm, doing some work, u?
12:18:28 <waltz> Are you one of those people who inserts a whitespace char before a question/exclamation mark?
12:18:38 <waltz> >:|
12:25:18 <shapr> no, my nickname completion did that for me.
12:27:30 <zipper> bitchx?
12:38:01 <shapr> nah, I'm using ERC
12:57:52 <zipper> haha, figures
12:58:15 <zipper> man, phantom types are scary shit
12:58:23 <ne1> yes
13:00:22 <zipper> you need to be a freaking math prof to understand this jizz
13:00:38 <ne1> not at all
13:00:47 <ne1> it is not cohomology
13:01:16 <zipper> it's worse
13:01:20 <ne1> (that's a higher way of saying "it is not rocket science")
13:14:39 <jesse_> hmmm, from what ive gathered, forall's are something like a kind contraint, if this is the case, how would i constrain some polymorphic type to the kind, * -> *?
13:16:59 <jesse_> and if it isnt, i give up
13:17:34 <Cale> zipper: http://www.informatik.uni-bonn.de/~ralf/talks/FOP.pdf
13:20:40 <zipper> Cale: thanks
13:23:02 <zipper> hm... those slides seem to be made from this paper that i just read
13:38:21 <redhatPT> hi everyone!
13:38:38 <redhatPT> plz tell me, is this badly idented? >test' x y  = [ not x, y || x, x && y ]
13:41:39 <Riastradh> Given that there is no indentation there, one cannot say.
13:42:48 <redhatPT> >test' :: Bool -> (Bool -> [Bool]
13:42:49 <redhatPT> >test' x y  = [ not x, y || x, x && y ]
13:43:05 <Riastradh> There is still no indentation there.
13:43:12 <redhatPT> *g*
13:43:14 <redhatPT> :S
13:43:26 <redhatPT> why does it give an error then?
13:43:26 <redhatPT> :|
13:44:05 <Riastradh> What error does it give?
13:44:32 <redhatPT> (possibly incorrect identation)
13:44:39 <Darius> redhatPT, if you copied that from your code, you do realize you have unbalanced parentheses
13:44:59 <redhatPT> ups :S
13:45:05 <redhatPT> ])
13:45:07 <redhatPT> thx
13:45:08 <Riastradh> '(possibly incorrect indentation)' is not an error message.  It is part of one of the error messages that GHC will give you.
13:45:33 <redhatPT> parse error :S
13:45:55 <redhatPT> g sorry m8s
13:57:56 <mflm> hi ppl
13:58:35 <mflm> does somebody know how to accomplish cantor's diagonalization in haskell?
13:58:50 <basti_> ?
13:59:50 <mflm> !
13:59:56 <mflm> don't get it?
14:00:05 * basti_ would love to help but doesn't get it.
14:00:38 <mflm> do you know cantor's diagonalization at all?
14:00:56 <basti_> that was how he proved that there are more real numbers than rational ones
14:01:00 <basti_> wasnt it?
14:01:47 <mflm> yes
14:02:04 <basti_> hmm well yes it might have some joke value
14:03:43 <Janni> Hi.
14:04:19 <ski> hi again Janni
14:04:39 <mflm> check this one: http://de.wikipedia.org/wiki/Cantor-Diagonalisierung
14:04:45 <mflm> look at the figures
14:05:26 <Janni> Can anybody give me a valid instance of the following class? I don't manage to crate one.
14:05:28 <Janni> class Class a where objects :: forall b. (Class b) => a -> [b]
14:05:59 <Janni> I mean, give me any data type with a instance definition of the class above
14:06:32 <ski> instance Class () where objects () = []
14:06:48 <Janni> NON-trivial examples please...
14:06:50 <ski> hm, maybe not so useful
14:06:56 <basti_> ahhh.
14:06:58 <basti_> now i get it
14:07:16 * ski misread above and missed the "(Class b) =>" qualification
14:07:51 <ac_mac> yo yo ski
14:07:53 <ski> instance Class a => Class [a] where objects = id
14:07:59 <ski> hiya ac_mac
14:08:27 <ski> Janni : i'm not sure what you are intending ..
14:08:38 <mflm> basti, finally :d
14:08:45 <ski> hm
14:08:48 <ski> nope
14:08:55 <ski> that is of course worng
14:09:01 <xerox> 'lo
14:09:10 <ski> Janni : forget that above
14:09:20 <basti_> mflm: well i would go by higher order analysis.
14:09:24 <ski> hi' xerox
14:09:35 <mflm> basti_: and this means?
14:09:51 <ski> Janni : what is the intended use of this class ?
14:09:53 <mflm> I am just a novice coder in haskell
14:10:16 <basti_> i mean, for example i am sure there is a way to find formulas for the sequence of numbers that appear along the "edge" of the diagram
14:10:36 <mflm> yes, this is true.
14:11:01 <basti_> then i would reverse this. as in "formula to compute the number of the 'cohort' a given number is in"
14:11:07 <mflm> my tutor told me, just do a google search, this would do.
14:11:09 <mflm> it didn't
14:11:15 <basti_> hm?
14:11:58 <mflm> I know the theory behind but not the first practical approach in haskel
14:11:59 <mflm> l
14:12:25 <basti_> what function do you want to implement exactly?
14:13:05 <mflm> some function which does:
14:13:14 <Janni> ski: I want to implement some kind of tree structure. I have for example "data Type1 = Type1 [TypeA]" and "Type2 = Type2 [TypeB". Now I want to have a function "children" (I called it "objects") which returns the contained list.
14:13:21 <mflm> cantor [1..] -> [(0,1),...]
14:13:23 <mflm> and so on
14:13:33 <basti_> as in, returning the coordinates?
14:14:10 <mflm> yes
14:14:16 <Janni> ski: So I would be able to cycle through that tree and call the functions defined in Class on every node.
14:14:24 <mflm> you see the table figure there
14:14:29 <basti_> can you implement this function in another language?
14:14:40 <Janni> ski: And it would not depend on how the tree is implemented.
14:15:10 <mflm> maybe with some hours if work in Java
14:15:18 <mflm> but there is no time to spend for
14:15:22 <basti_> yes.
14:15:30 <mflm> check this one: http://www.inf.fu-berlin.de/lehre/WS04/ALP1/uebungen/ueb6.pdf
14:15:38 <ski> Janni : ok
14:15:43 <mflm> Aufgabe 6.4
14:15:48 <mflm> the figure
14:15:51 <Janni> All I have to define is: "data Type1 = Type1 {as :: [TypeA}; instance Class Type1 where children = as"
14:16:03 <ski> Janni : so i think you want existential data types  (i think i've said this)
14:16:11 <basti_> yup
14:16:23 <ski> Janni : so your objects has worng type
14:16:45 <Janni> Just a moment, trying s.th. out.
14:17:05 <ski> Janni : i.e. your type class member "objects"
14:17:57 <ski> (children is probably a better name. methinks the class could be named better, too)
14:18:09 <Darius> mflm: The exercise just wants you to demonstrate that NxN is isomorphic to N
14:18:34 <mflm> Darius, yes this is it.
14:18:48 <Darius> mlfm: In Miranda it would be trivial [(x,y) \ n <- [0..]]
14:19:10 <Janni> ski: I generalised the names, because I thought it's not necessary for you to know what I intend
14:19:22 <Darius> er [(x,y) \ x <- [0..], y <- [0..]]
14:20:03 <autrijus> yay I finally did the afp parser correctly. :)
14:20:26 <autrijus> benchmarking shows for huge files it's just 2% slower than cp, and 5% faster than cat
14:20:44 <mflm> Darius, no those are just 2 for loops
14:20:54 <Janni> ski: OK, it worked with existential types. Thx.
14:21:17 <mflm> cantor isn't that trivial as it looks like
14:21:21 <ski> Janni : no prob with names
14:23:07 <ski> (Janni : essentially you wanted  children :: exists b. Class b => a -> [b] instead,  which have to be coded as  children :: a -> [SomeClassInstance]     with data SomeClassInstance = forall a. Class a => MkSCI {unSCI :: a})
14:23:08 <Darius> mflm: No, in Miranda, that does exactly what you want.
14:23:31 <mflm> Darius: but not haskell :D
14:23:42 <Darius> mflm: It's not even correct syntax in Haskell
14:24:14 <mflm> Darius, I corrected the syntax but the haskell line is different anyway
14:25:10 <Darius> mflm: The syntax wasn't wrong it's just not Haskell.  Miranda also has [(x,y) | x <- [0..], y <- [0..]] but that does what the Haskell version does which is the wrong thing
14:25:57 <mflm> Darius, yeah this one is just 2 nested for loops, no more, no less
14:37:58 * Darius thinks that a breadth-first non-determinism monad would give the diagonalization comprehension.
14:42:39 <Janni> OK. Now I'm using existential datatypes. But now the existential datatype is no instance of the class. There is no other way than instancing it and "unwrap" the function defined in the class?
14:43:34 <Janni> What I mean is "instance Class ClassWrapper where children (ClassWrapper x) = children"
14:43:48 <Janni> sorry. "children x".
14:44:03 <Janni> And the same with every function defined in Class.
14:48:05 <ski> yep
14:48:46 <ski> you prolly want to have the existential wrapper as instance (which doesn't happen automatically, of course)
14:49:43 <Janni> Err. Either I don't understand you or you just said the same as me...
14:50:23 <ski> yes
14:50:31 <ski> (the latter)
14:51:13 <ski> of course it's not always strictly necessary to have the wrapper be an instance
14:51:32 <basti_> mflm was not the brightest bulb in the pack
14:51:41 <ski> you could e.g. pass around values of type ClassWrapper directly
14:51:42 <TheHunter> Janni, there can't be another way. E.g. you can't define (+) for (exists a. Num a => a)
14:52:00 <basti_> he missed that the link on the bottom of the page he showed leads directly to a pascal sourcecode for his problem.
14:52:38 <ski> Janni : but if you wanna mix such already wrapped values with values of other instance types, or you want to use overloaded functions on then, you do need to instance the wrapper
14:55:01 <Janni> (How) can I create derivable type classes?
14:57:58 <ski> Janni : no, not that i know
14:58:21 <ski> Janni : but you can derive instance-ship for newtypes
14:58:44 <Lemmih> I think you can do it with Generic Haskell.
14:59:12 <TheHunter> Janni, and you can give a default implementation in a generic way: http://haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
15:00:46 <TheHunter> finally, you can derive Data and create appropriate instances with a scrap your boilerplate approach.
15:12:40 <Janni> "Can't combine named fields with locally-quantified type variables". (Why) is that necessary?
15:14:13 <ski> probably because there is no explicit existential quantification in the types
15:14:28 <ski> e.g.
15:14:53 <ski> data SomeC = forall a. C a => MkC {unC :: a}
15:15:09 <ski> here the constructor is typed like
15:15:25 <ski> MkC :: forall a. C a => a -> SomeC
15:15:43 <ski> or, which is roughly the same
15:15:52 <ski> MkC :: (exists a. C a => a) -> SomeC
15:16:03 <ski> so, the selector would have to be typed as
15:16:17 <ski> unC :: SomeC -> (exists a. C a => a)
15:16:18 <ski> or
15:16:28 <ski> unC :: exists a. C a => SomeC a
15:16:42 <ski> um
15:16:44 <ski> unC :: exists a. C a => SomeC -> a
15:17:18 <Janni> OK. Where's the problem?
15:17:20 <ski> and the normal trick of replacing the existentially quantified type variable 'a' with a existential wrapper type doesn't work here
15:17:32 <ski> because that would be
15:17:39 <ski> unC :: SomeC -> SomeC
15:17:41 <ski> or
15:17:44 <ski> unC :: SomeC -> SomeOtherC
15:17:48 <ski> or somesuch
15:17:51 <ski> see ?
15:18:19 <ski> in your above 'children' function you really wanted   exists b. Class b => a -> [b]
15:18:37 <ski> but changed that to    a -> [ClassWrapper]
15:19:35 <ski> so, to allow selectors one would have to admit explicit existential quantifiactions
15:20:17 <ski> instead of more or less getting the same effect with existential data types
15:20:26 <ski> Janni : ok ?
15:21:40 <Janni> ski: Not really. For now I just accept that it doesn't work. I think I'm not enough into that...
15:21:59 <Janni> But I'm sure I will learn that soon.
15:22:05 <ski> ok
15:22:23 <ski> hi Pyoko
15:23:06 <Janni> Anyway, thanks for your detailed explanation.
15:23:15 <Janni> (Still reading it up and down)
15:23:33 <ski> (not as much worth if i didn't expain clearly for you to understand ..)
15:23:41 <ski> ok
15:25:00 <TheHunter> thbot, @hello
15:25:31 <TheHunter> thbot: @hello
15:25:32 <thbot> Hello world. 
15:25:38 <TheHunter> thbot: @pointfree \x f z -> x ++ f =<< z
15:25:38 <thbot> ((=<<) .) . (++)
15:25:46 <ski> thbot: @whoareyou
15:25:46 <thbot> Sorry, I don't know the command "whoareyou", try "lambdabot: @listcommands
15:25:57 <ski> lambdabot: @listcommands
15:25:57 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
15:25:57 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
15:25:57 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
15:25:57 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
15:25:57 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
15:25:58 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
15:26:01 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
15:26:02 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
15:26:04 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
15:26:29 * ski see no @pointfree
15:26:49 <ski> hm
15:26:58 <ski> thbot: @listcommands
15:26:59 <thbot> I react to the following commands: ["all-dicts","arr","define","definitions
15:26:59 <thbot> ,"del-definition","devils","dict","dict-help","dummy","dump","dynamic-load
15:26:59 <thbot> ,"dynamic-reload","dynamic-unload","easton","echo","elements","eval","foldoc
15:26:59 <thbot> ,"fortune","gazetteer","get-definition","goodbye","hello","hitchcock","jargon
15:26:59 <thbot> ,"join","karma","karma+","karma-","leave","listchans","listcommands","listmodule
15:26:59 <thbot> ","lojban","more","msg","part","pointfree","prelude","quit","reconnect"
15:27:01 <thbot> "resume","seen","set-fuel","state","topic-cons","topic-init","topic-snoc
15:27:03 <thbot> ,"topic-tail","topic-tell","type","vera","web1913","wn","world02","yow"
15:29:04 <ski> thbot: @pointfree \x f -> f x
15:29:04 <thbot> flip id
15:29:24 <ski> thbot: @pointfree \f g h x -> f (g x) (h x)
15:29:24 <thbot> variables appearing more than once: "x"
15:29:36 <ski> bah :)
15:29:40 <TheHunter> yeah, that needs to be fixed.
15:30:41 <Darius> thbot: @pointfree (.)
15:30:41 <thbot> (.)
15:31:10 <ski> thbot: @pointfree \ma amb k -> ma (\a -> amb a (\b -> k b))
15:31:10 <thbot> flip (.) (flip (.) (flip id) . (.)) . (.)
15:32:05 <Darius> ski: Why \b -> k b? Why not just k.
15:32:22 <ski> it should replace "flip (.) A" with "(. A)"  and "(.) A" with "(A .)"
15:32:35 <arjanb> thbot: @pointfree \x y z -> f (g x y z)
15:32:35 <thbot> ((f .) .) . ((g .) .)
15:32:37 <ski> Darius : just to get an explicit b variable
15:32:40 <TheHunter> ski, i thought it did that
15:33:15 <ski> wb pyoko
15:34:16 <pyoko> ty
15:37:18 <ski> thbot: @pointfree (\t -> t t) (\g f x -> f (g g f) x)
15:37:18 <thbot> variables appearing more than once: "t","g","f"
15:37:29 <ski> (hm, right)
15:38:09 <TheHunter> any idea what combinator should I use to duplicate values?
15:38:47 <ski> dup x k = k x x   ?
15:39:02 <ski> s f g h x = f (g x) (h x)   ?
15:39:24 <ski> (possibly with dup flipped)
15:40:52 <TheHunter> yeah, i think i'm gonna use dup.
15:47:19 <TheHunter> @get-definition S
15:47:19 <thbot> S not defined
15:47:19 <lambdabot> S = \f g x.f x (g x)
15:47:30 <TheHunter> this one looks just right.
15:47:50 <ski> um
15:48:00 <ski> right
15:58:27 <TheHunter> hmm, the parser's still incorrect...
16:18:03 <musasabi> autrijus: no it does exist - it is simply not packaged up in a nice way.
16:18:07 <musasabi> sorry.
16:23:55 <magicuser> hey guys
16:24:03 <magicuser> does haskell run on windows?
16:24:19 <magicuser> anyone with a haskell powered website?
16:24:43 <Cale> Hello magicuser 
16:25:18 <Cale> There are a number of haskell compilers and interpreters, and yeah, most (all?) of them run on windows.
16:25:19 <Lemmih> magicuser: http://www.ScannedInAvian.org/cgi-bin/hackage/hackage is written in Haskell.
16:25:35 <Cale> (as well as unix, mac, etc.)
16:25:41 <Darius> Cale all the full Haskell implementations run on Windows.
16:26:14 <Darius> magicuser: What do you consider a "Haskell powered website"?
16:26:55 <Darius> magicuser: There is a Haskell webserver and there are various ways of making dynamic content with Haskell.
16:28:32 <zipper> there's a nice html module for haskell
16:30:10 <magicuser> kick azz
16:30:21 <magicuser> can you make something liek yahoo chess with ahskell
16:30:22 <magicuser> ?
16:30:24 <magicuser> haskell?
16:30:45 <Darius> magicuser: I don't know what Yahoo Chess is (like), but yes.
16:31:06 <zipper> hm... can you compile haskell code to run on the java platform?
16:31:32 <magicuser> so what about lisp v haskell
16:31:42 <magicuser> is haskell better in some areas?
16:31:59 <magicuser> do any of you make money from solving business problems with haskell?
16:32:42 <Darius> zipper: There were various things to do that, but I think most of them are no longer maintained.
16:33:38 <magicuser> do you like haskell over perl?
16:33:50 <tuomov> what kind of question is that?
16:34:34 <tuomov> perl is replacement for sed with a nicer regexp syntax, nothing more :)
16:35:12 <magicuser> lol
16:35:23 <magicuser> you thats a interesting statement
16:35:36 <magicuser> I read a web page saying that given any progamming language
16:35:41 <magicuser> for an AI class
16:35:49 <magicuser> the students with best results used AWK
16:36:03 <magicuser> is sed better than awk?
16:36:11 <magicuser> they are similar if I remmeber corectly
16:36:15 <tuomov> huh?
16:36:19 <tuomov> sed is not a programming language
16:36:20 <ski> language alone doesn't determine how well one succeeds
16:36:53 <tuomov> well, not a turing-complete one anyway
16:37:23 <dons> tuomov: sed is a programming language. there's an unlambda interpreter written in it :P
16:37:43 <dons> http://sed.sourceforge.net/
16:38:11 <dons> ftp://quatramaran.ens.fr/pub/madore/unlambda/contrib/unlambda.sed
16:38:53 <magicuser> ?
16:38:55 <tuomov> oh, well, it did have those pattern spaces and stuff
16:38:56 <magicuser> bu?
16:38:58 <magicuser> ba?
16:38:59 <tuomov> but nobody uses them :)
16:39:06 <magicuser> unlambda interpreter?
16:39:10 <dons> yep. hold space and pattern space makes all this possible.
16:39:16 <tuomov> essential sed: s/foo/bar/
16:39:22 <dons> it means you get 2 values to play with
16:40:22 <magicuser> hmm
16:40:23 <dons> and here's a turing machine: http://sed.sourceforge.net/grabbag/scripts/turing.sed
16:41:15 <magicuser> wow
16:41:29 <magicuser> so do you guys prefer haskell to say java?
16:41:34 <tuomov> toothpick insanity
16:41:47 <tuomov> does someone here like java?-)
16:41:55 <zipper> i imagine that most people here think that java is pretty bad
16:42:57 <jadrian> i don't
16:43:19 <jadrian> i don't know java at all...
16:44:47 <esap> Java has weak core, which means its libraries are also bad (even if huge and multi-purpose)
16:49:53 <tuomov> huge is bad
16:50:24 <Lemmih> It is?
16:50:34 <tuomov> small and comprehensive is good
16:50:45 <tuomov> I don't want to use an api with a zillion functions
16:51:56 <dons> sed has a small api ;)
16:52:01 <Cale> heheh
16:52:14 <dons> not very comprehensive though..
16:52:28 <esap> sed doesn't have an API (if you're not talking about command line parameteres?)
16:53:22 <dons> there are functions. you can call them. y// s// n N g G. that's an api
16:53:25 <magicuser> I though awk was the powerful one
16:53:27 <magicuser> not sed
16:53:34 <dons> hooray for sed!
16:55:20 <esap> dons: those are commands, but not an API.
16:56:06 <dons> it depends on what you mean by api.
16:56:32 <tuomov> an api is not part of the core language
16:56:41 <Igloo> What's incomprehensive about sed's API? It's Turing complete, isn't it?
16:56:58 <Igloo> Everything else is just syntactic sugar, man!
16:57:06 <dons> that's enough, I guess. very haskellish :)
16:57:22 <dons> and having just 1 variable is cute too
16:57:39 <Igloo> Note the use of a state monad to encapsulate the computations
16:57:39 <esap> sed has a protocol (which is not an API). There are commands in the protocol, but they have not been grouped as an API, only as a protocol.
16:58:48 <dons> Igloo: it's the worlds finest purely functional string processing language
16:59:33 <dons> though not having lambda abstractions is annoying
16:59:38 <Igloo> And string processing is one of Haskell's biggest weaknesses, right? So we just need a ghc-embedded-sed
17:00:04 * Igloo handwaves over the strict/lazy divide
17:00:15 <dons> we need \-sed!
17:00:55 <esap> true, string processing needs to be improved
17:01:33 <esap> maybe start from figuring a good string representation for functional programs. Lists are not good enough
17:02:30 <zipper> why?
17:02:46 <esap> because of the space usage
17:03:05 <zipper> that's an implementation detail :D
17:03:13 <tuomov> lists are a nice concept, they just need to be optimised internally
17:03:19 <zipper> smart compilers should chunk strings in memory blocks :)
17:03:37 <zipper> python seems to get this right
17:03:38 <esap> zipper: true. But until they do, we need something better.
17:05:43 <esap> Optimizations of space usage (or time usage) do not matter in small programs usually. But it prevents using it for big things, because you'll eventually run out of memory or time.
17:06:26 <esap> And strings are inefficient even in C++
17:07:41 <magicuser> money in haskell jobs now?
17:08:02 <tuomov> the all 5 of them?
17:08:52 <esap> I suppose for those people that designed Haskell, yes there is :-)
17:10:00 <jadrian> To me the root of the problem are not strings themselves
17:10:12 <Gahhh> is there money for o'caml jobs ?
17:10:19 <jadrian> but the fact that the operations on lists are not defined over a class of linear structures instead
17:11:01 <jadrian> if they were we could happily come up with a efficient string representation and still use folds, scanls and such
17:11:24 <wli> s/fold/crush/
17:11:25 <arjanb> hmm list and array as type classes..
17:11:39 <zipper> why have more then one linear structure?
17:11:46 <jadrian> wli: why? 
17:12:00 <jadrian> wli: if it's linear isn't it the same?
17:12:17 <wli> you cna already do it after a fashion with generic Haskell
17:12:46 <wli> crush is the fold analogue for the generic case
17:13:00 <jadrian> yeap I know
17:13:18 <ski> crush ?
17:13:41 <jadrian> ski: flattening of a tree for instance
17:13:46 * ski would think that'd be called cata
17:13:55 <jadrian> ski: it's differnce
17:13:58 <jadrian> ski: it's different
17:14:03 <ski> ko ?
17:14:05 <ski> ok ?
17:14:32 <jadrian> catamorphism and crush jsut happens to be the same in the linear case
17:14:59 <jadrian> a crush on a tree would be something like a foldling after flattening
17:15:08 <ski> aha
17:15:08 <jadrian> s/foldling/folding
17:17:09 <jadrian> I know generic haskell can do that, and much more. Still in this case defining many of the Data.List functions over a class of linear structures would be just fine I guess
17:18:12 <jadrian> efficient strings and [Char] could share a common API, and so could other functions
17:18:39 <jadrian> s/functions/datatypes
17:28:10 <jadrian> did you haver implemented in haskell some efficient variant of an algorithm described somewhere just to find out lazy evaluation would do exactly that for you...?
17:28:12 <jadrian> :-/
17:39:40 <wilx> Hmm.
17:39:56 <wilx> I have problems implementing any algorithms in Haskell.
17:40:13 <wilx> I always come up with something completely imperative. :/
17:40:44 <TheHunter> thbot: @pointfree (\t -> t t) (\g f x -> f (g g f) x)
17:40:44 <thbot> t (s id . g)
17:41:23 <TheHunter> dammit
17:44:50 <ski> bug ?
17:45:27 <TheHunter> ya, pretty obvious one \t -> t t ===> t
17:45:45 <TheHunter> thbot: @pointfree (\t -> t t) (\g f x -> f (g g f) x)
17:45:45 <thbot> s id id (s id . s id id)
17:47:34 <TheHunter> thbot: @pointfree flip id x . (+)
17:47:34 <thbot> (+ x)
17:50:07 * esap just realized flip (flip id) == ($)
17:50:24 <TheHunter> @thbot: @pointfree flip (flip id)
17:50:24 <lambdabot> Sorry, I don't know the command "thbot:", try "lambdabot: @listcommands
17:50:24 <thbot> Sorry, I don't know the command "thbot:", try "lambdabot: @listcommands
17:50:30 <TheHunter> thbot: @pointfree flip (flip id)
17:50:32 <thbot> id
17:50:44 <ski> TheHunter : i also tries to eliminate free vars, not just local vars ?
17:51:22 <ski> s/i/it/
17:51:29 <TheHunter> ski, it tries a few rewrite rules (pretty suboptimal algorithm though).
17:51:36 <ski> ok
17:51:49 * ski leaves keyboard
17:52:01 <TheHunter> thbot: @pointfree \f x y -> y x
17:52:01 <thbot> const (flip id)
17:52:08 <TheHunter> thbot: @pointfree \f x y -> f y x
17:52:09 <thbot> (. flip id) . flip (.)
17:52:27 <TheHunter> that's an obviously missing rule
17:53:40 <TheHunter> hmm, that's something i've been wanting to try:
17:54:00 <TheHunter> @define evil "@eval evil"
17:54:00 <lambdabot> evil defined
17:54:01 <thbot> evil defined
17:54:50 <TheHunter> @eval evil
17:54:50 <lambdabot> @eval evil
17:54:50 <thbot> @eval evil
17:54:51 <lambdabot> @eval evil
17:54:51 <thbot> @eval evil
17:54:51 <lambdabot> @eval evil
17:54:51 <thbot> @eval evil
17:54:52 <lambdabot> @eval evil
17:54:52 <thbot> @eval evil
17:54:52 <lambdabot> @eval evil
17:54:53 <thbot> @eval evil
17:54:53 <lambdabot> @eval evil
17:54:53 <thbot> @eval evil
17:54:53 <lambdabot> @eval evil
17:55:07 <esap> nice loop
17:56:36 <esap> maybe need to implement mutual recursion detection
18:07:10 <sunstinks> is haskell better than perl?
18:09:30 <thbot> In my opinion, yes, but i'm just a stupid bot.
18:18:22 <jesse_> better is awfully subjective, but yes, it is, way better
18:21:31 <Cale> There seem to be lots of people coming here and asking specifically if Haskell is better than Perl. I wonder if there is something influencing this.
18:23:30 <Cale> Also seems a strange thing to ask #x whether x is better than y. :)
18:25:02 <jesse__> i think the question is kindof moot anyhow, no matter where its asked
18:26:47 <Cale> yeah
18:46:51 <zipper> what's a y combinator?
18:48:22 <zipper> nm, gotta sleep... didn't realize how late it was
18:52:21 <Cale> zipper: y f = f (y f)
20:03:08 <bourbaki> moin
20:18:24 <Lemmih> Greetings, bourbaki.
20:55:02 <Heffalump> morning
20:55:17 <Nioate> hi
20:55:34 <jadrian> morning (kind of)
20:55:59 <jadrian> Heffalump: are you in the UK as usual?
20:56:54 * jadrian didn't expect to see people from his timezone in here at this time of the "day"...
21:10:31 <Heffalump> jadrian: yeah. Couldn't sleep. I should go back to bed now really.
22:31:02 <ski> good morning
22:32:22 <Svrog> morning (even though it's late afternoon here :)
22:33:03 <Riastradh> It's one in the morning here.  I suppose that is 'morning'...
22:44:32 <wagle> @seen shapr
22:44:32 <lambdabot> shapr is in #haskell.se, #haskell and #darcs.
22:44:58 <ski> @seen esap
22:44:58 <lambdabot> I saw esap leaving #haskell 3 hours 4 minutes 34 seconds ago.
22:45:41 <wagle> wasnt there a way tgo ask "when did they last show signs of life?"
22:46:24 <ski> maybe /whois ?
22:46:49 <Gahhh> you can check the irc logs I suppose
22:47:27 <ski> e.g. http://tunes.org/~nef/logs/haskell/
22:47:34 <wagle> ah..  that works
22:47:41 <wagle> (whois)
23:20:52 <themonk> hi
23:21:31 <themonk> prob : how to sort an infinite generated list ? any ideas?
23:22:00 <wagle> wait forever
23:22:10 <ski> heh
23:22:24 <wagle> actually people have come up with approaches
23:22:37 <ski> themonk : depends
23:22:38 <wagle> trying to remember what they did
23:23:26 <ski> themonk : if you know nothing of the data, i think it can't be done
23:24:33 <themonk> look, my function returns all possible numbers of this form : 2^i * 3^j * 5^k
23:24:53 <themonk> i,j,k in [0..infinite]
23:24:58 <wagle> that looks very familier
23:25:18 <themonk> yes, i dont remember how it is named
23:25:21 <wagle> must be homework assignment..  8)
23:25:36 <themonk> it is, i created the function, although it must be sorted
23:26:22 <wagle> i think wli has a contorization doodad that would emit them monotonically increasing
23:26:30 <wagle> cantorizations
23:26:34 <wagle> arghh
23:26:58 <wagle> i'm falling asleep / in denial that i am doing that
23:28:25 <wagle> my approach is to observe that is a sort of merge of three infinite lists
23:29:11 <ski> not exactly
23:29:11 <wagle> x * y * z * 2  < x * y * z * 2 * 2
23:29:32 <wagle> i did say "sort of"
23:29:58 <wagle> i'm probably using a larger value of "sort of" than you..  8-p
23:30:29 <themonk> do u know how these numbers are called ?
23:30:32 <ski> not exactly three infinite lists, i meant
23:31:00 <wagle> i was thinking 2.. 3.. and 5..
23:31:10 <wagle> themonk: dunno any names, sorry
23:31:15 <themonk> ok
23:31:50 * wagle goes to sleep
23:32:16 <themonk> gn
23:32:59 <ski> themonk : think you can solve it now ?
23:33:39 <themonk> not yet
23:33:48 <themonk> found it, its the hamming numbers
23:42:59 <shapr> good morning #haskell!
23:43:29 <jadrian> good morning shapr ;)
23:43:38 <Lemmih> Hey shapr.
23:43:53 <ski> morn' shapr
23:44:05 * shapr bounces cheerfully.
23:44:23 * Lemmih is revamping Hackage.
23:44:37 <shapr> ohh, I haven't even vamped Hackage.
23:44:53 * shapr checks the Hackage repo for updates
23:45:11 <shapr> Lemmih: where's Hemplate? Did I already ask you and forget the answer?
23:46:02 <Lemmih> darcs repo at http://212.242.49.100/repos/haskell/hemplate/
23:46:06 <shapr> Mmm, I feel like coding today.
23:46:17 <shapr> Lemmih: want me to put that one on ScannedInAvian also?
23:46:27 <Lemmih> Yes please (-:
23:46:38 <shapr> Ok!
23:47:53 <shapr> Sonarman: do people make ping jokes about your nickname?
23:48:01 <Lemmih> Cabal totally rocks but it has made GHC somewhat buggy.
23:48:17 <Sonarman> shapr: all too often :)
23:48:43 <Sonarman> sorry about the constant reconnects, btw
23:49:02 <themonk> [n | n <- func1] , when saying this n what values will take? all elements returned by "func1" ?
23:50:16 <Sonarman> if  func1 :: [a]  maybe?
23:50:48 <shapr> Lemmih: oh I had an idea last night about enhancing darcs-createrepo (at least in debian) so that it also automatically created a standard BIND structure. Basically darcs-createrepo hemplate would automagically setup hemplate.ScannedInAvian.org/ to point to repo/html and /repo would point to the repo.
23:51:26 <Lemmih> That would be neat.
23:51:59 <shapr> Yeah, I've been wondering how I can make darcs work more like sourceforge.
23:52:18 <shapr> Can you think of more ways to do that?
23:53:17 <Lemmih> I'm not very familiar with sourceforge.
23:54:08 <shapr> Basically, I want more ways for a single darcs repo to support whole project features.
23:54:28 <shapr> ski: good morning, written any cool code lately?
23:56:37 <shapr> Lemmih: ok, Hemplate repo is setup, it should work.
23:56:57 * Lemmih throws a shuriken at GHC.
23:57:51 <Lemmih> I have some code which loads fine with GHCi but GHC fails with "unknown package: HaXml-1.12"
23:58:08 * shapr whacks GHC with a naginata
23:58:19 <shapr> Are you using GHC head?
23:58:24 <Lemmih> But I'm using HaXml-1.0 and there's no references to HaXml-1.12 in any install package.
23:58:32 <themonk> [n | n <- func1] , when saying this n what values will take?
23:58:34 <Lemmih> shapr: Yes.
23:59:27 <shapr> themonk: n will take whatever values func1 produces, right?
23:59:31 <Sonarman> themonk: it will take the values of the list that func1 returns, i gues
23:59:49 <themonk> ok thanx
