00:00:33 <shapr> Lemmih: any other new projects you want hosted?
00:01:55 <Lemmih> shapr: Nope.
00:02:00 <shapr> ok
00:02:28 <Lemmih> Focusing on Hacanon and yi.
00:03:22 <Lemmih> I'm starting to grok the design of Proxima (-: Hoping to implement something similar in yi,
00:04:42 <Lemmih> shapr: How's code? Have you been hacking something spiffy lately?
00:05:08 <shapr> Nah, doing holiday social stuff the last few days.
00:06:20 <ski> shapr : no, been tired
00:08:34 <shapr> Lemmih: I got an irish flute for christmas, along with book and CD to learn how to play. I've been considering torturing the neighborhood by practicing flute and unicycling at the same time.
00:08:54 * shapr snickers
00:10:54 * Lemmih still haven't mastered idling without using his arms for balancing.
00:11:30 <shapr> I'm so close to real idling. I can go back and forth twice, but then I fall off.
00:12:36 <ski> idling ?
00:13:12 <shapr> Idling is a way to stay on a unicycle while staying in almost the same spot.
00:13:25 <ski> aha !
00:13:55 <shapr> The wheel repeats { one half revolution forward, then one half backward, ...}
00:14:35 * ski usually doesn't have to muster much effort to be idle .. :)
00:14:38 <shapr> It looks a little bit like your shoulders are holding up the unicycle and it's swinging underneath you like a watch on a chain.
00:14:42 <shapr> haha
00:19:20 <Lemmih> shapr: Hackage will be updated as soon as GHC gets stable.
00:19:26 <shapr> Cool
00:19:29 <shapr> is that soon?
00:19:36 <shapr> Btw, do I need 6.3 for Hemplate?
00:19:45 <Lemmih> Yes.
00:20:12 <shapr> ok
00:20:19 <Lemmih> (or 'no' if you add a little CPP magic)
00:21:14 <Lemmih> Oh wait. I did that myself. I think it will compile with GHC 6.2.1 also.
00:21:48 * Lemmih is getting senile.
00:22:32 * shapr doesn't remember if he's senile or not.
00:23:28 * shapr hops happily
00:43:08 <shapr> Lemmih: where's DBInfo ?
00:43:23 <shapr> er, DBInfo.Package that is
00:44:36 <Lemmih> It's created by DBSpec.create
00:45:10 <Lemmih> Did I record DBInfo?
00:45:22 <shapr> yes
00:45:57 <Lemmih> Ops.
00:46:18 <shapr> at least, I think so...
00:46:19 * shapr checks
00:46:57 <shapr> nifty, this 1.0.1 version of darcs has built-in rss!
00:47:47 <Lemmih> I've just mailed a Hackage patch with all the updates.
00:47:52 <shapr> ok
00:53:07 <shapr> good morning ac_mac !
00:53:14 <shapr> greetings mornfall 
00:53:19 <ac_mac> heyhey
00:54:01 <mornfall> hey shapr, *
00:56:46 <ac_mac> I subscribed to the gcc list
00:56:50 <ac_mac> it's kinda interesting
00:57:59 <shapr> Like what?
00:58:07 <shapr> Oh, I want to subscribe to the types list, anyone know where it is?
00:58:41 <Lemmih> Types list?
01:00:06 <shapr> It's been mentioned on lambda-the-ultimate.org several times.
01:26:58 <musasabi> morning
01:47:08 * shapr is now know as The Knight Who Said Ni 
01:52:18 <jadrian> question
01:52:22 <jadrian> if I do
01:52:38 <jadrian> xs = map id ys
01:52:55 <jadrian> then xs will share ys elements but not its stucture, right?
01:53:46 <jadrian> oh Knight Who Said Ni! do you know thy answer?
01:54:52 <Lemmih> Why is that important?
01:56:28 <tuomov> hmm.. that's how one would expect it to work in a strict language
01:56:35 <tuomov> but I wonder if lazyness does some funny things here
02:15:54 * Lemmih starts a poll: When will GHC 6.4 be released?
02:23:58 <vegai> hopefully not before it's ready
03:15:33 <tintin> .
03:41:53 <dblhelix> happy new year!
03:48:09 <Lemmih> You're lagging a bit.
03:50:27 <dblhelix> well, 'rond here it's pretty okay to wish people a happy new year until, say, Jan 15th; after that, it becomes pretty annoying ;)
03:53:44 <Lemmih> Happy new year, then!
03:53:58 <musasabi> happy new year ;)
03:54:41 <TheHunter> Happy new year from here, too!
04:14:57 <TheHunter> has anyone got a better idea for parsing sections using parsec's expressionParser than preprocessing the input?
04:16:31 <shapr> Lemmih: february 29th
04:30:31 <zipper> Happy GNU Year!
04:31:20 <dottedmag> zipper: year full of license issues? ;)
04:32:07 <zipper> every year is full of license issues
04:38:30 <Marvin--> GNU/2005?
04:43:41 <zipper> where is megam?
04:43:59 <zipper> are the details of his fate in the logs?
04:45:15 <Heffalump> shapr: you about
04:45:16 <Heffalump> ?
04:45:36 <zipper> and he hasn't come back since :'(
04:46:40 <ibid> when cosmicray comes back, i expect megamonad to follow
04:47:19 <Heffalump> shapr: the HaskellDbTutorial has been wikispammed; I'd revert it but I'm not sure how. One thing the wiki spammers did was fuck up the escaping so it's really hard to read the operators now.
04:47:31 <Heffalump> It's just the last two changes that need reverting
04:53:33 <ski> on hawiki ?
05:06:41 <Heffalump> no, scannedinavian
05:07:30 <ski> oki
05:23:23 <Janni> Hi
05:23:55 <ski> hello Janni
05:27:59 <shapr> Heffalump: thanks
05:28:53 <shapr> Heffalump: anyway, try the one on HaWiki
05:29:21 <Heffalump> oh, is there a copy there? I didn't realise.
06:08:39 <Spark> hmm anyone understand the unification algorithm for intersection types?
06:12:01 * ski_ has not seen it
06:13:28 <Spark> i would have thought it would unify 1 and 1->2 to be [1 & 1->2] but it appears instead to change them both to the empty intersection
06:13:53 <Spark> this is from the ronchi della rocca 88
06:14:02 <Spark> lets google
06:14:42 <ski_> what's 1 here ?
06:14:50 <ski_> unit type ?
06:14:54 <Spark> type variables
06:14:58 <ski_> aha
06:15:01 <Spark> so you can type xx
06:15:02 <ski_> hm
06:15:36 <ski_> maybe it has something to do with not allowing cyclic types ?
06:15:54 <Spark> thats the whole point though isnt it?
06:17:04 <ski_> point of what ?
06:17:11 <ski_> intersection types ??
06:17:11 <Spark> ok whats a cyclic type?
06:17:19 <ski_> (would think not ..)
06:17:44 <ski_> a type like    x where x = a -> x    e.g.
06:18:01 <ski_> i.e.   a -> (a -> (a -> ...))
06:18:23 <Spark> yeah
06:18:45 <ski> hm, more correctly, type expressions should be finite
06:18:59 <Spark> i thought the point was that these are not allowed with the curry type system, and intersection types is the extension to cover them as well
06:19:03 <ski> cyclic are just one case of infinite, of course
06:19:09 <ski> hm
06:19:15 <ski> it is ?
06:19:32 <Spark> mm
06:20:15 * ski haven't read much about intersection types
06:20:18 <Spark> yeah i mean you can think of [1 & 1->2] as 1->2 and also 1->2->2 and also 1->2->2->2 ... cant you
06:20:25 <Spark> i dont really know :)
06:20:31 <ski> you could try to explain, if you feel like ..
06:20:43 <ski> hm
06:20:50 <Spark> rdr's paper seem to lack the whole 'intuition' element of this, and just go for definition after definition
06:21:05 <ski> hm
06:21:41 <ski> if 1 and 2 are type variables there, then then probably should be able to stand for some concrete type
06:22:08 <ski> e.g. if universally quantified, we could choose whichever types we want
06:22:18 <ski> so, e.g. Int and Bool
06:22:37 <Spark> so x is both an int and a function from x's to bool
06:23:11 <Spark> how does that work? :0
06:23:14 <ski> thus [Int & Int -> Bool] could be interpreted as Int -> Bool as well as Int -> Bool -> Bool and Int -> Bool -> Bool -> Bool etc ...
06:23:22 <ski> hm
06:23:50 <ski> i think there it at least two fundamental intuitions/interpretations
06:25:11 <ski> a) the term actually has all types meaning here there is one term that when run in an implementation could act like any of the possibilities ("single proof of several propositions")
06:25:39 <Spark> overloading
06:26:45 <samc_> file paths for wx functions are relative to the bins directory?
06:27:15 <ski> b) the term is overloaded or uses (at least transitively finally) overloaded terms, meaning some processing will determine which overloaded one is wanted and exchange with/invoke that one ("one proof abbrev. that stands for several proofs of separate propositions")
06:27:23 <ski> Spark : yep
06:27:40 <Spark> those two are the same though arent they
06:27:50 <ski> i'm not totally sure
06:27:51 <ski> hm
06:27:55 <Spark> youre just looking at the term from two different angles - what it can supply and what can be required from it
06:28:04 <ski> for an example of b)
06:29:05 <ski> think of  (+) :: Int -> Int -> Int   (+) :: Int -> Int -> Float   (+) :: Int -> Float -> Float   (+) :: Float -> Float -> Float
06:29:12 <samc_> anyone know about wx on mac os x?
06:29:21 <ski> Spark : agree ?
06:29:31 <Spark> yeah ok the intersection of all of those
06:29:34 <ski> yep
06:30:10 <Spark> i think its easier if we assume no relationship between int and float there
06:30:17 <ski> here the intentions is to have separate machine code for each of those cases (possibly sharing some code)
06:30:21 <ski> right
06:30:27 <ski> no subtyping
06:30:35 <b0l0k> hi all
06:30:43 <ski> (and of course no implicit coercion)
06:30:47 <ski> hi b0l0k
06:31:00 <Spark> there are multiple derivations for the same term however
06:31:03 <ski> Spark : for an example of a)
06:31:04 <Spark> if you do 3+3
06:31:16 <ski> b0l0k : want info on haskell ?
06:31:41 <ski> b0l0k : or already salvaged ? ;)
06:32:14 <ski> Spark : yep, all those have to be congruent
06:32:37 <ski> Spark : i.e. if we indeed have implicit coercions/subtyping
06:32:50 <ski> Spark : for an example of a)
06:32:51 <b0l0k> already
06:32:58 <ski> b0l0k : ok
06:33:59 <ski> Spark : think of records (some syntax)  {a = 2,b = True,c = '!'} :: {a :: Int,b :: Bool,c :: Char}
06:34:36 <musasabi> implicit conversions are evil.
06:34:53 <ski> depends a bit on coherence, methinks
06:35:14 <ski> but there's also efficiency issues, mayhaps
06:35:24 <musasabi> true - C++ teaches how to not do it.
06:36:08 <Spark> implicit has the benefit that the programmer doesnt have to write (and maintain) something, but also the disadvantage that the programmer isnt made to verify something
06:36:51 <ski> (i mean like it's not transparent whether it's going to use this intended intermediate rep., which is efficient, or that one, which is needlessy inefficient in this case, even if the results will still be the same)
06:37:05 <ski> Spark : verify what ?
06:37:20 <musasabi> but adding code can break old code..
06:37:30 <Spark> to say 'i am aware that this is to be converted'
06:37:50 <musasabi> e.g. old code is built upon an automatic A->B->C conversion. Now add a A->D->C conversion...
06:37:51 <Spark> analogous to 'i am aware that this should be of this type'
06:38:41 <ski> Spark : anyway a)  now think of types  {a :: Int,b :: Bool}  and  {b :: Bool,c :: Char}, i would say that the original record could be considered to have these types also. now an intersection of these types would be {b :: Bool}, right ?
06:39:07 <Spark> hmm
06:39:27 <Spark> i think the intersection would be a ::Int&Bool  b::Bool&Char
06:39:29 <ski> musasabi : of course it must be guarranteed that the A->B->C and the A->D->C conversions are equivalent
06:40:03 <Spark> where it is not obvious that a specific datum is referred too, the compiler enforces the requirements of both?
06:40:06 <ski> Spark : hm
06:40:21 <musasabi> ski: but that cannot be done generally - and they rarely are.
06:40:34 <ski> Spark : what is the intersection of  a0 -> b0  and  a1 -> b1  ?
06:40:46 <Spark> literally that
06:41:12 <ski> Spark : it's not, say,  (a0 & a1) -> (b0 & b1)   or something ??
06:41:26 <Spark> no
06:41:27 <Spark> ok
06:41:33 <xerox> is it possible to have the first arg of a 3-arg function as the last, ``flip''-ing in some way?
06:41:42 <ski> Spark : ?  no or yes ?
06:41:57 <Spark> in the bcd system, a0 -> [b0 & b1] is equivelent to [a0->b0 & a0->b1]
06:42:09 <Spark> but in the strict system, everything is redefined to not allow the former
06:42:13 <musasabi> xerox: (\f a b c -> f c b a)
06:42:26 <ski> xerox : yes, e.g. if you define an appropriate version of flip for that case
06:42:42 <xerox> uhm..
06:42:42 <ski> xerox : e.g. called flip3  or  rot  or something
06:42:51 <Spark> where you have a1 as well, i believe: [a0->b & a1->b] is equivelent to [a0 || a1] -> b
06:43:07 <ski> ok
06:43:14 <ski> hmm
06:43:34 <xerox> The point is converting the following function into point-free style: foo f l = foldr (\x y -> f (y,x)) 0 l
06:43:46 <xerox> Uh, flip is enoght maybe
06:43:53 <Spark> the restriction in the strict system is enforced by carefully changing the type syntax, derivation rules, definition of substitution/expansion/lifting, etc
06:44:45 <ski> Spark : hm, think i was incorrect above...   would the intersection type of those to types be  {a :: Int,b :: Bool,c :: Char}  (a record with all three fields) ?
06:44:53 <ski> s/to/two/
06:44:59 <Spark> oh theres a c
06:45:26 <Spark> i suppose if you have a record without a given field, its type is the nullary intersection
06:45:38 <Spark> so even if you could reference that field, you couldnt use it anywhere
06:45:51 <Spark> but if you joined the records together, it'd get intersected with something sane to produce something sane
06:46:53 <ski> hm
06:47:18 <ski> Spark : what do you mean "without a given field" ?
06:47:37 <Spark> {a :: Int, b :: char} has no c field
06:48:43 <Spark> so yes {a :: Int,b :: Bool}  and  {b :: Bool,c :: Char} would be { a :: Int&Null, b :: Bool&Bool, c :: Null&Char }
06:49:08 <Spark> where Null & Tau ~ Tau    and    Tau & Tau ~ Tau
06:49:13 <ski> xerox : hmm, not sure if this is correct  "foo = (`foldr` 0) . ((. flip (,)) . (.))"
06:49:40 <musasabi> that is evil.
06:49:51 <ski> Spark : Tau ?
06:49:56 <Spark> an arbitrary type :)
06:50:02 <ski> top ??
06:50:09 <Spark> Null is top i think
06:50:13 <Spark> everything can be typed with null
06:50:23 <Spark> its sometimes written as the empty set symbol, or as omega
06:50:39 <TheHunter> xerox, watch out:
06:50:54 <Spark> i wouldnt mind representing [a] as the single intersection, [] as the nullary intersection, and [a,b,c ...] etc as the rest :)
06:50:56 <TheHunter> thbot: \f l -> foldr (\x y -> f (y,x)) 0 l
06:50:57 <thbot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
06:51:05 <TheHunter> thbot: @pointfree \f l -> foldr (\x y -> f (y,x)) 0 l
06:51:06 <thbot> flip foldr 0 . (. flip (,)) . (.)
06:51:08 <Spark> they seem more intuitively similar to sets than a binary operation
06:51:53 <xerox> TheHunter !!!!
06:51:54 <ski> Spark : hmm, in my (in this case) interpretation, a record of type {a :: Int,b :: Bool} has fields a,b. it's operational representation might have more fields (subtyping)
06:52:07 <xerox> TheHunter, How do you did that?
06:52:11 <ski> Spark : or should ine not mix intersection types with subtyping ?
06:52:25 <xerox> thbot, @pointfree filter f (map g l)
06:52:28 <TheHunter> xerox, i wrote a lambdabot plugin just yesterday.
06:52:36 <xerox> wow.
06:52:42 <TheHunter> thbot: @pointfree filter f (map g l)
06:52:43 <thbot> filter f (map g l)
06:52:55 <TheHunter> thbot: @pointfree \f g l -> filter f (map g l)
06:52:56 <thbot> (. map) . (.) . filter
06:53:03 <xerox> I did that as func2pf f g = filter f . map g
06:53:04 <ski> (xerox,TheHunter : oh, so it seems i was correct :)
06:53:07 <xerox> wops no.
06:53:51 <Spark> ski: in forsythe, there is a 'forgetting fields' part of the subsumption relation <=
06:53:52 <xerox> I'm stunned.. what does (. foo) means? and . (.) . ??
06:54:12 <TheHunter> sections: (. foo) === \x -> x . foo
06:54:17 <ski> Spark : yep, such a one i was thinking of ..
06:54:28 <Spark> so i.e. if a datum is used in a context that requires {a:: int} then the datum's actual type at runtime might be {a:: int, b:: char, ...}
06:54:55 <TheHunter> xerox, f . (.) . g composes the three functions f, (.), g
06:55:00 <Spark> i dont think you can lose the structure part though, you cant use a {a::int} where you need an int
06:55:16 <ski> right
06:55:21 <xerox> (\x -> x . foo) . (.) . filter
06:55:26 <b0l0k> ++ all
06:55:29 <TheHunter> (f.) sections are a real mess
06:55:32 <ski> Spark : not needed in this example
06:55:45 * TheHunter is away: brb
06:55:56 <Spark> yes true
06:56:24 * ski looks above to recall what the issue was before that ..
06:56:39 <Spark> xx? :)
06:56:54 <ski> hm
06:56:56 <ski> hm
06:56:57 <ski> fdg
06:57:01 <ski> bah
06:57:05 <ski> sorry
06:57:12 <ski> anyway
06:57:15 <Spark> :)
06:57:39 <ski> i think that this is an example of a)
06:57:41 <ski> because
06:58:00 <ski> i can't think of the record as overloaded in this case
06:58:07 <ac_mac> :)
06:58:34 <xerox> ski, can you explain to me (`foldr` 0) ?
06:58:46 <ski> e.g. {a = 2,b = True,c = '!'} :: [{a :: Int,b :: Bool} & {b :: Bool,c :: Char}]
06:59:43 <Spark> hmm yes i think it can be typed like that
06:59:53 <ski> Spark : the operational semantics/implemetation has a single "thing" for the above expression, not several that are chosen from (either at static or dynamic time)
07:00:18 <ski> so this *actually has* both types at the same time
07:00:23 <Spark> yeah
07:00:36 <ski> "a proof of two different propositions"
07:00:49 <Spark> i think if you transfer that logic to function spaces, and intersections of functions, you get the 'multiple definitions from which we choose'
07:00:53 <Spark> is that right?
07:01:10 <ski> though, in this case it depends on the previous subsumption, hmm, would be nice if could find example that didn't depend on that ..
07:01:21 <ski> xerox : hm, could you wait some, mayhaps ?
07:01:27 <Spark> heh
07:01:38 <ski> hm
07:02:06 <ski> you're saying it might be that for function types it more or less automatically becomes b) ?
07:02:14 <xerox> ski, sure (-:
07:02:18 <ski> :)
07:02:19 <Spark> yeah
07:02:24 <Spark> ok well
07:02:27 <ski> hm
07:02:35 <Spark> suppose you have a function double defined on ints and strings
07:02:43 <Spark> and for strings it does ab -> abab
07:02:53 <Spark> or moo -> moomoo etc :)
07:03:02 <ski> cat's meaowing, gotta check, be back in a moment ..
07:03:07 <Spark> then it is int->int & string->string
07:03:54 <Spark> the type int->int is the set of all functions from int->int, and the type string->string is the set of all functions from string->string, are they not disjoint?
07:04:00 <Spark> so if you intersect them, you get nothing
07:04:56 * ski back
07:05:03 <Spark> reynolds mentions in the forsyth design document paper that 'use of theo word intersection can be misleading'
07:05:10 <Spark> i think this might be what hes on about
07:05:16 <Spark> but im not sure i understand function spaces properly
07:05:32 <Darius> Spark: When this came up earlier, my response to that was that the language implementor can make any intersection type valid.
07:05:36 <Philippa> Spark: are int and string related?
07:05:39 <Philippa> this is important
07:05:48 <Spark> Philippa: no i think not
07:06:01 <Spark> Darius: what does that mean?
07:06:04 <Philippa> (I've been playing around a little, because it seems to me that intersection types coupled with ADTs are going to be either interesting or useless and I'd like to know which
07:06:06 <Philippa> )
07:06:26 <Darius> Spark: Either int->int is disjoint to string->string or it isn't.
07:06:37 <Darius> Whether it is or not depends on the language.
07:06:42 <Spark> right
07:06:56 <Spark> so is this where the intuition of intersections of sets of values end?
07:07:22 <Philippa> I would've thought the intuition ends when the sets become a bugger to define...
07:07:35 <Darius> That intuition is fine, the issue is what are the sets.
07:08:04 <ski> thing ZF-like, if strings are just a kind of set, and an int is just a kind of set, then, depending on representations, there might be nonempty intersection of those function spaces ..
07:08:10 <ski> s/thing/thinking/
07:08:19 <Darius> Spark: There are some things that seem (relatively) natural overlaps and some that seem "artificial".
07:08:53 <Darius> For example, different instantiations of the same polymorphic type or subtypes seem to lead to natural intersections.
07:09:25 <Spark> expansions? or more general instantiations?
07:09:26 <Darius> Forsythe's intersection of { length :: Int } & Int -> x seems artificial (to me)
07:09:48 <Spark> ok
07:09:51 * ski wonders if mercury's multiple predicate mode declarations (higher-order-insts) could be seen as a big intersection-inst (compiler converts to specific selection of inst)
07:10:13 <Spark> by artificial do you mean 'not defined to be congruent with an intuitive understanding' or something along those lines? :)
07:10:56 <ski> Darius : does & or -> bind more tightly there ?
07:11:09 <Darius> Spark: something like that
07:11:12 <Darius> ski: ->
07:11:20 <ski> m
07:11:55 <Spark> Darius: ok the biggest problem i have is with unification, i cant work out how it will unify xx to be anything other than the nullary intersection
07:12:32 <ski> xx ?
07:12:40 <Spark> self application
07:13:03 <Spark> you'd expect the principal pair {x:1 && 1->2 , 2} for that wouldnt you?
07:13:07 <Darius> Spark: I guess most "natural" cases are more than "natural", they imply an intersection.
07:14:06 <Spark> hm is the 'intersection' concept something that surfaces in the case of data types, but something that doesnt surface for other types (like functions)
07:14:15 <Spark> and is just a symptom of the deeper meaning
07:14:21 <Philippa> Spark: ISTR it's forall x.(x ^ x -> x) or your preferred variant thereof
07:14:35 <Philippa> where ^ is intersection not exponentiation :-)
07:15:02 <Spark> does 2 have to = 1?
07:15:30 <Philippa> I have to confess not being familiar with your notation - pretty much all I've read is bits of Pierce's thesis
07:15:55 <Philippa> and sadly I've got to get going - I'm meeting an ex-housemate in town for a few drinks and he's buying :-)
07:16:00 <Spark> it does if you apply it to the identity function i think
07:16:04 <Spark> rightoh
07:16:21 <Spark> i couldnt go out for new years because i was working :(
07:16:24 <Philippa> ouch
07:16:52 <Philippa> I just met up with a friend then came back to find Damien all but asleep
07:17:03 <ski> Spark : with what ?
07:18:19 <ski> (Philippa : i would think the reslt type would not be constrained ..)
07:18:44 <Spark> ski: the principal pair of the term "xx" is <B,2> where B = {x : (1 && 1->2)} i think?
07:19:01 <Spark> if you apply (\x.xx) to (\y.y)
07:19:25 <shapr> nsh: hi
07:19:37 <shapr> nsh: what's your nickname short for?
07:19:53 <ski> Spark : why apply to identity ??
07:20:00 <Spark> obviously \y.y is <{},3->3} and you expand and substitute that to get < {} , (1->1) && ((1->1)->(1->1)) >
07:20:31 <Spark> im thinking why she might have thought that the result was constrained
07:20:46 <nsh> shapr: Rollie Theodore Sakers
07:20:48 <Spark> if you apply it to identity, it it (because the result of identity is constrained)
07:21:17 <nsh> shapr: or nostupidhandle, whatever makes the most sense :-)
07:21:32 <Spark> s/it it/it is/
07:21:44 <shapr> nsh: sounds good to me :-)
07:21:55 <Spark> ski: expansion can convert (3->3) to (4->4)&&(5->5) if you didnt know :)
07:22:22 <samc_> from wx: bitmap :: FilePath -> Bitmap () would it be expected that filepath is realtive to the bins directory?
07:22:25 <shapr> Anyone know how I can convert difference in latitude to distance in kilometers?
07:22:29 <ski> hmm
07:22:38 <Spark> expansion preserves principal pairs since you can construct a derivation for the new type, from teh derivation for the old, in general
07:22:47 <shapr> samc_: should be relative to your startup dir, or it should be a full unambiguous path.
07:22:53 <Spark> you just duplicate a subtree and use the intersection rule to join them all together
07:22:56 <shapr> At least that's how FilePath works elsewhere.
07:23:15 <ski> Spark : hm i think i get why (though didn't exactly follow your expl. .. :)
07:23:27 <samc_> but then the app is bound to one computer?
07:23:49 <nsh> hmmm
07:23:51 <ski> Spark : what is principal pairs ?
07:23:54 <Darius> samc_: Create part of the filepath from a variable.
07:24:10 <shapr> Lemmih: I just got email from Kris Holm =)
07:24:13 <nsh> One degree of latitude is 60 nautical miles, 69 statute miles or 111 km. One minute of latitude is 1 nautical mile, 1.15 statute miles, or 1.85 km
07:24:16 <shapr> greetz Darius 
07:24:45 <shapr> nsh: wow, thanks for the detailed info. Should I assume your wikipedia hostname had something to do with that?
07:25:01 <samc_> then I would need a way to get the filepath of the bin, say, right?
07:25:16 <Spark> ski: there should be a principal pair for each term, which is a derivable pair, and should be able to be converted to any of the other derivable pairs through the operations of substitution, lifting and expansion
07:25:17 <nsh> obviously you that's only the parallel distance north/south, there could be a horizontal distance too
07:25:31 <nsh> shapr, :-)
07:25:39 <shapr> Right, but I'm trying to figure out *exactly* how close I am to the Arctic Circle.
07:25:40 <Darius> shapr: Heya
07:26:07 <nsh> shapr, ah, no problem then :-)
07:26:08 <Marvin--> shapr: sounds productive
07:26:16 <Darius> shapr, nsh: Likely, you could just have asked google.
07:26:21 <Spark> Darius: do you understand the unfification algorithm for any intersection type systems?
07:26:21 <ski> Spark : but what are these *pairs* ? :)
07:26:25 <ski> hello sh10151
07:26:40 <Spark> ski: a pair is a basis and a type, the basis a collection of types for all of the free variables in the term
07:26:45 <shapr> So I need to subtract 65.8 from 65.5 and then convert that from whole degrees of latitude to kilometers.
07:27:08 <sh10151> hi
07:27:13 <Darius> Spark: You mean the type-checking/inference algorithm?  Presumably any unification used in them would be standard.
07:27:22 <shapr> er, Arctic Circle is actually 66Â° 32" which is just about 66.5
07:27:27 <shapr> Marvin--: of course it is!
07:27:30 <ski> Spark : one type for each var ? or a coll. of types for each var ?
07:27:47 <nsh> 34 minutes according to my source 
07:27:58 <Spark> Darius: unification as used by the principal pair algorithm yeah, although i think it might change from system to system because the operations have to change
07:28:04 <Darius> samc_: Yes, but that pushes the problem somewhere else.
07:28:12 <Spark> the principal pair algorithm is type inference
07:28:31 <Spark> ski: one type, which may be an intersection type in this system :)
07:29:52 <ski> ok
07:30:12 <Spark> Darius: an inference alforithm should, for "xx", produce <{x : (1 && 1->2)},2>, where 1 and 2 are type variables, is that right?
07:31:42 <Darius> Spark: There are type-inference algorithms for intersection types that do produce that, yes.
07:32:37 <Darius> Spark: Actually, one property some (or all) intersection type systems have is principal typ-ings-
07:32:56 <Spark> the inference algorithm should produce the principal type though right?
07:33:15 <Spark> and from that type you can create the nullary intersection through a lifting
07:35:20 * ski wonders if nullary intersection is rougly = top
07:35:46 <Spark> it is i think
07:35:50 <Spark> since any type <= it
07:36:09 <Spark> and any term can be assigned it
07:36:25 <ski> ok
07:36:25 <Spark> in fact any term can be assigned the principal pair <{},nullary> i think
07:37:14 <ski> is the second part a type, and the first a collection of tyvar-to-type bindings ?
07:37:33 <samc_> Darius: then what?
07:37:33 <Spark> yeah
07:37:46 <Spark> term var to type, not type var!
07:38:16 <samc_> relative paths seem to work, but not for os x '.app's
07:38:31 <Spark> so if you say, a+a has type int, you also have to ensure that the a's are both int, for example
07:38:40 <Spark> so <{a:Int},Int>
07:39:10 <shapr> So, I think I live 77.69 kilometers south of the Arctic Circle.
07:39:15 <Darius> samc_: Then you check other libraries to get the information, or use an environment variable, or a compile-time setting etc.
07:40:27 <Spark> but if your a isnt free, \a.(a+a), then the basis does not have to refer to it, because the type itself does,  in fact if M has pair <B \cup {x:Tau},Rho> then \x.M has pair <B,Tau -> Rho>, do you see?
07:40:33 <samc_> and what of windows file paths with \?
07:41:07 * samc_ is used to classic mac files with uids
07:41:21 <Darius> samc_: Depending on your approach, either it's a non-issue or use an appropriate library to deal with those issues, I think there is at least one, but I don't remember the name.
07:41:32 <shapr> HFS in System 1 faked directories on a floppy.
07:42:00 <shapr> samc_: do you remember System 1?
07:42:25 <samc_> no but I dled .97 for fun
07:42:41 <shapr> I loved those tan mice with the really big buttons that made that ka-chunk! sound.
07:43:03 <shapr> those sleek grey mice started along with the SE/30 started.
07:44:10 <ski> Spark : aha, *term* var :)
07:44:19 <Spark> ski: :)
07:44:59 <shapr> samc_: speaking of System 1, I refused to drag my floppy icon to the trash to eject it, I used a paperclip. I was convinced that I would be throwing away all my files.
07:45:01 <ski> \cup ??
07:45:02 <samc_> yeah, I used to hate pc mice with their tinny clicking yuk
07:45:12 <Spark> ski: as in latex
07:45:15 <Spark> U
07:45:16 <ski> hm
07:45:26 <ski> Spark : yes
07:45:32 * ski still lags reading
07:45:41 * shapr lags thinking
07:45:48 <samc_> shapr, one of the few major ui design flaws
07:46:20 <ski> Spark : ok
07:47:07 <ski> Spark : so E with principal pair <B,Tau>  rougly ==>  B |- E : Tau   then ?
07:47:45 <Spark> Darius: are you familiar with a unification algorithm for an intersection type discipline that will unify 1 and 1->2 to be (1 && 1->2), and if so can you explain to me how it does this, since the only unification definition i have access to at the moment doesnt seem to do that at all
07:47:53 <Spark> ski: exactly that
07:48:06 <Spark> ski: thats an infix notation for E being derived to <B,Tau>
07:48:36 <ski> ok, so it's just a different notation ?
07:48:42 <Spark> they didnt used to deal with B explicitly, ive noticed, the rule for abstraction used to say 'and later on we type x to be Rho' or whatever
07:48:52 <ski> or, hm, maybe the first one also tells that it is principal ?
07:48:53 <Spark> but its much simpler to keep tabs on the basis explicitly as you go up
07:49:01 <Spark> no you derive a pair
07:49:08 <Spark> but there is also a priniciple pair that you can derive
07:49:25 <ski> Spark : who are "they" here ?
07:49:36 <Spark> hm let me see
07:49:54 <ski> ok
07:50:18 <Spark> people, around about before 1985 :)
07:50:18 <samc_> shapr didn't system 1 use mfs?
07:50:28 <Spark> my bath may be overflowing, one sec
07:50:36 <shapr> mfs?
07:50:38 <shapr> I don't think so.
07:50:42 <ski> Spark : mhm, ok
07:50:48 <shapr> I thought HFS was System 1, and everything after was HFS+
07:50:50 <samc_> mac file system
07:50:53 <shapr> but I could be wrong
07:51:13 <Spark> FUCK ME it was about half an inch from overflowing
07:51:15 * ski considers trying to find out what cat wants this time
07:51:15 <Spark> i have been engrossed
07:52:02 <samc_> I think hfs came about when you could put folders in folders
07:52:35 <samc_> pretty advanced ;)
07:52:57 <sh10151> HFS+ was the thing that made System 8 a major version bump
07:53:16 <sh10151> shapr: you are thinking of MFS vs. HFS
07:53:56 <samc_> sh10151, i thought it was the 3d look ;)
07:54:03 <Darius> Spark: It's not the unification algorithm that makes intersections but the inference algorithm.  The Church project page has several papers related to intersection type inference algorithms, with at least one essentially providing a full implementation.
08:00:37 <sh10151> no no, major version bumps have technical reasons
08:00:45 <sh10151> system 6 had multifinder
08:00:50 <sh10151> system 7 had ONLY multifinder
08:01:10 <sh10151> system 8 had a new file system and some copland changes rolled in
08:01:20 <sh10151> system 9 had a completely different kernel and more copland changes
08:01:29 <sh10151> etc etc
08:01:38 <sh10151> :)
08:03:02 <musasabi> I need to find a mac solution..
08:03:49 <sh10151> solution to what?
08:03:56 <musasabi> I am giving tech support to a person using mac os 8, and he refuses to move to os X as it doesn't support all programs (write now?) and fonts properly..
08:04:08 <sh10151> that person is a crackhead
08:04:14 <samc_> system X had no respect for basic ui principles pioneered by apple ;)
08:05:04 <musasabi> sh10151: hmm?
08:05:27 <musasabi> sh10151: special indian fonts + thousands of pages of text.
08:05:40 <sh10151> OS X includes OS < X support
08:06:00 <musasabi> sh10151: yes, but buggy.
08:06:35 <musasabi> (he uses os X at the uni and complains that his documents don't work there properly)
08:07:44 <sh10151> PEBKAC
08:08:36 <autrijus> hey. It seems that my parsing problem, where it needs a list of packed, mixed-type records, may be solved elegantly with GADT
08:09:13 <autrijus> is it considered ok (as in, not fragile) to use it in ghc now? also is ghc 6.4 coming in a couple months? :)
08:09:48 <musasabi> autrijus: ghc 6.4 should be out soon(tm). 
08:10:01 <autrijus> ok... :)
08:10:03 * autrijus grabs a snapshot
08:10:04 <sh10151> musasabi: the app he is trying to run was released in 1994ish
08:10:07 <musasabi> autrijus: and bugs in GADTs are resolved in a swift fashion.
08:10:20 <Spark> Darius: i see
08:10:46 <autrijus> musasabi: cool. it conveniently sidestepped many of the record bugs
08:10:48 <autrijus> since the selectors can "fix" on the type
08:10:55 <musasabi> sh10151: I know. But trying to argue reasons for upgrade is kind of fruitless.
08:11:23 <musasabi> sh10151: currently I just keep a bunch of older macs in line as replacements.
08:12:04 <sh10151> i hope you are pulling down big bucks :)
08:12:20 <Spark> Darius: i can only find papers that discuss type inference in wild and wacky systems though
08:12:31 <Spark> Darius: is that ok do you think?
08:13:07 <Darius> If you mean at the Church project page, most of the type systems seem more or less straight-up intersection (or intersection/union) systems.
08:13:23 <Spark> hm ok
08:14:05 <autrijus> is there a record library for ghc, that can let me to use singleton labels as keys over different type of records?
08:14:24 <autrijus> (this must be a faq; but I failed to find answers on the web)
08:14:24 <Spark> i was reading "Principality and type inference for intersection types using expansion variables" earlier, but it seemed to diverge from what im supposed to be studying
08:14:42 <sh10151> musasabi: this is why I don't do tech support 
08:14:51 <Darius> Spark: In what way?
08:15:03 * sh10151 is too blunt.
08:15:30 <Spark> let me refresh my memory
08:15:36 <Darius> autrijus: If I understand you right, HList should do what you want (and then some).
08:16:03 <musasabi> sh10151: ^_^
08:16:20 <Spark> Darius: i couldnt understand the new set of rules and types i think :(
08:16:28 <autrijus> # http://homepages.cwi.nl/~ralf/HList/code.html
08:16:39 <autrijus> ooh, last updated 2 days ago
08:16:40 <autrijus> Darius: thanks :)
08:17:03 <Spark> lets have another crack at that then
08:17:24 <Darius> autrijus: Well the library was only released like a couple months ago or something like that, so hopefully it hasn't gotten stale yet ;)
08:18:01 <autrijus> cool. I'll read the paper now
08:19:28 <Darius> Spark: Well there seems to be a recent paper, "Unification with expansion variables" that you may want to look at.
08:20:24 <Darius> Well, except that none of the links for it seem to work (for me at least).
08:20:35 <xerox> @type (. map)
08:20:36 <lambdabot> (. map) :: forall a b c. (([a] -> [b]) -> c) -> (a -> b) -> c
08:20:52 <xerox> What does it mean the first arg of that?
08:21:32 <Spark> Darius: heh yeah i noticed that one
08:23:45 <Heffalump> xerox which first arg?
08:23:53 <Darius> Spark: "Polar type inference with intersection types and omega" is I think mildly obsolete but fairly readable (if it's the paper I think it is).
08:24:14 <xerox> Heffalump, I can't undestand the whole (([a] -> [b]) -> c)
08:24:29 <Darius> @type map
08:24:30 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
08:24:33 <Heffalump> I don't think (. map) is a particularly interesting function
08:25:01 <Heffalump> but ([a] -> [b]) -> c is a function that takes a function from a list of 'a's to a list of 'b's, and produces a 'c'
08:25:06 <Darius> xerox: If you understand the type of map (or any other higher-order functio) then (. map)'s type is just an extrapolation of that.
08:25:23 <xerox> It's useful in this exercise, converting to point-free style this function:  foo f g l = filter f (map g l)
08:25:36 <xerox> that becomes: (. map) . (.) . filter
08:25:42 <xerox> but it's cryptic :-\
08:25:44 <Heffalump> s/point-free/pointless/
08:25:51 <xerox> Darius, I understand the type of map
08:25:55 <Heffalump> yes, and completely unhelpful
08:26:04 <xerox> Heffalump, it's just an exeercise
08:26:04 <Darius> As an exercise, I agree with Heffalump.
08:27:16 <xerox> Hm.
08:28:24 <Janni> Hi.
08:29:36 <samc_> do Thaller or Pang ever talk here?
08:30:20 <Janni> When I have "class A a where f :: a -> Whatever; class A a => B a where ..." can I somehow make a default definition of f in the definition of B?
08:30:42 <Janni> Like "class A a => B a where f x = Whatever".
08:30:56 <Darius> Andre Pang is ozone.
08:31:15 <Janni> I tried it and it doesn't work, but maybe there is some way to achieve it...
08:35:19 <Heffalump> why would running ghc this message about a library that isn't mentioned on the command line?:
08:35:23 <Heffalump> /usr/bin/ld: cannot find -lsqlite
08:35:27 <Heffalump> s/this/cause this/
08:35:45 <Marvin--> because it's mentioned in the packages.conf?
08:36:14 <Marvin--> that'd be my guess anyway
08:37:07 <ski> Janni : i'm not aware of any way of doing that
08:37:08 <Heffalump> ah, yes. thanks.
08:37:19 <ski> Janni : sorry
08:37:33 <ski> (Janni : think i've thought of that sometime, too)
08:43:43 <ski> hi esap
08:44:58 <esap> hi
08:45:12 <esap> what's up?
08:48:52 <ski> esap : looking at your hawiki/ControlOperation
08:49:19 <esap> ski: what do you like of it? do you think it'll ever work? :-)
08:49:30 <ski> well :)
08:49:42 <ski> i'm a little puzzled, maybe
08:49:49 <_Codex> that must be the least readable haskell code I've seen.
08:49:50 <xerox> ski! (-:
08:50:14 <ski> is there some papers that call this exact feature (the) control operation ?
08:50:16 <esap> codex: You probably didn't read IOHCC entries then?
08:50:22 <xerox> ski, I tried hardly to understand that piece of code.. :D
08:50:59 <ski> xerox : yes, hi (hm, forgot to help you with something related to pointless style above ..)
08:51:08 <xerox> point-free (-:
08:51:10 <esap> ski: hmm.. there are more than one control operation, for sure.
08:51:28 <esap> ski: The name I've used comes from Griffin: The Formulae-as-Types notion of control
08:51:28 * ski hasn't even looked much at the code at ControlOperation yet
08:52:12 <ski> esap : e.g. why you restrict to not scope inside lambdas ?
08:53:40 <esap> ski: There are problems with the operation if the variable being introduced is passed outside of the control operation. It's intended to be lexically scoped, not dynamically scoped
08:53:45 <ski> (esap : i have more questions, if you wanna peek at those first :)
08:53:56 <ski> mhm, ok
08:54:12 <ski> (just that no explanatoin was given on page, so i wondered)
08:54:30 <esap> ski: the explanation in the page says "it violates unsafePerformIO"
08:55:16 <ski> esap : hmm, actually i haven't read it though yet (ehhm), questions popped up when i was reading ..
08:55:19 <esap> ski: But that's part of my implementation, which is obviously not the only possible one.
08:55:35 <ski> (sorry if you actually answer such lower .)
08:55:42 <ski> yep
08:56:03 <ski> ok, next one :
08:57:15 <ski> you say type of "[x] 5" in example is "_|_". but that expr is given as right arg to "+" in bigger expr. so do you have some implicit converion from "_|_" to "Int" there ?
08:57:33 <esap> ski: yes.
08:57:40 <ski> ok
08:58:04 <ski> (so that discards the current continuation then ..)
08:58:08 <esap> ski: maybe should insert 'exit([x]5)'. That's not necessary for the other typing.
08:58:39 <ski> ok, so does this break ref.transp. ? :)
08:59:53 <esap> ski: Well in one sense, yes.
09:00:27 <ski> (maybe not if can't escape lexical scope and can't be used in sub-exprs across another "control extent boundary")
09:00:32 <ski> hm
09:00:36 <esap> ski: it's a control-flow construct. There is a specific effect, that is, the control operation evaluates the body to normal form (or until there is an exception)
09:00:56 <esap> ski: which is clearly dependent on the order of evaluation.
09:01:23 <esap> ski: However, I think the breakage is contained.
09:02:04 <esap> ski: That is, the control operation shouldn't break anything when you look it from outside.
09:03:44 <ski> hmm,   control x. Left ([x](Right False),[x](Right True))
09:04:05 <esap> ski: exactly, that's interesting example.
09:04:14 <ski> or maybe
09:04:42 <ski> control x. Left (exit [x](Right False) :: Int,exit [x](Right True) :: Char)
09:04:56 <ski> (to be explicit)
09:05:22 <ski> hmm
09:05:38 <ski> well, i think i was thinking of the first typing rules for control ...
09:05:46 <esap> ski: yes. The answer depends on the order of evaluation.
09:06:19 <ski> would think so
09:06:21 <ski> hm
09:06:52 <ski> it would seem that the first rule-pair enforces that the control variable is used locally
09:07:10 <ski> (because you don't have [E0]E1  but [x]E)
09:07:33 <ski> but, if it is just a variable with a special type, this wouldn't enforce that
09:08:00 <ski> anyway
09:08:07 <ski> this gets me to the next question
09:08:11 <esap> ski: yes true.
09:08:16 <ski> about the second pair of rules
09:08:25 <ski> (which i understand less)
09:08:45 <ski> the "\\", is it a meta-connective ?
09:09:11 <ski> (like "," to the left of "|-" is a meta-connective meaning (meta-)conjunction)
09:09:37 <ski> or is it to be regarded as just taking some kind of difference ?
09:09:45 <ski> do you understand my question ?
09:10:56 <esap> ski: yes. It's not a meta-connective, the subtraction is an operation on the types. Think of category theory. Both context and A are similar. \\ is just a combination operation that takes two objects and produces a new object.
09:11:26 <esap> ski: it's like function arrow, works similarly.
09:11:52 <_Codex> If control is based on duality with lambda abstraction, where is all the dual rules like currying or modus ponens for the control operation? :)
09:12:42 <esap> codex: those rules are dual to currying. I don't have the reduction rule in the page.
09:13:51 <TheHunter> hmm, esap, the control operation is a typed call/cc?
09:13:53 <esap> ski: though I'm not thinking of ',' as a meta-connective either, maybe I should write /\ instead of ','.
09:14:06 <esap> TheHunter: yes, at least very close to that.
09:14:18 <ski> esap : switching computer .. wait
09:14:53 <esap> TheHunter: I think the semantics is actually coroutines [see the Crolard's interpretation paper for details]
09:16:43 <esap> TheHunter: The difference to call/cc is that there are compile-time restrictions on the use of the bound variable.
09:17:36 <TheHunter> esap, I see.
09:19:15 <esap> My implementation tries to simulate those restrictions, but cannot do fully, it's not easy to subtract from an already-defined scope with current operations.
09:19:49 <ski_> hm
09:20:36 <esap> Crolard actually defines the scope of that variable to not include any lambda abstractions. My implementation allows those uses, but then if you pass it out of the operation, you'll get complaint about not having DeepSeq (a->b) instance.
09:21:50 <ski> mhm
09:22:06 <esap> Anyway, any support for that will not be efficient.
09:22:21 <ski> what i mean't with "meta" was rougly
09:22:58 <Riastradh> Is the control you're discussing the same control as in Matthias Felleisen's control & prompt?
09:23:24 <ski> fow a given specific instance of such a judgement, could "\\" appear in it (as "," can) ? (and i don't mean when it's redundant and can be "simplifired away")
09:23:32 <ski> Riastradh : i think not
09:24:11 <ski> (maybe restricted such, if would be)
09:24:24 <esap> ski: yes it could.
09:24:32 <ski> ok
09:24:39 <ski> could it contain many such ?
09:24:52 <esap> ski: yes.
09:24:57 <ski> what is the BNF / form of a judgement ?
09:25:26 <ski> are environments (i.e. the left of |-) trees build with inner nodes being "," and "\\" ?
09:26:34 <ski> ((a : A \\ b : B) , c : C) \\ ((d : D, e : E) \\ f : F) |- ...
09:26:35 <ski> e.g.g
09:26:46 <ski> to take a made-up suchone
09:26:48 <esap> ski: I'm not fixing any specific structure for the context, other than what can be done with the judgements. I mean, you might have some other judgements in the language that would extend the structure of the contexts. 
09:27:23 <ski> wb Cale
09:27:31 <ski> hm
09:27:36 <esap> ski: So I'm not assuming it's linear or anything like that.
09:28:20 <ski> ok,ty
09:28:33 <ski> wit your second pair
09:28:41 <ski> you have A \/ B as type
09:28:45 <esap> ski: yes
09:28:52 <ski> i.e. you more or less replace _|_ with B
09:28:55 <ski> correct ?
09:29:12 <esap> ski: well almost yes.
09:29:26 <ski> that seems in some way a bit similar to multiple-conclusioned sequent systems ..
09:29:58 <esap> ski: heh maybe. Maybe I should use one of those there.
09:30:23 * ski wonders if one could get both "or"-variants returned in a single use ..
09:31:27 <ski> (e.g. if this might correspond more to classical logic (e.g. in linear variant that would be multiplicative disj. :) )
09:31:40 <esap> ski: Just have an 'control x. [x](Left(if cond then [x](Left 10) else [x](Right 10))'
09:32:28 <ski> that would return one or the other, depending on what cond evals to
09:32:41 <ski> not the same
09:32:48 <esap> ski: ah you'd want both of them. hmm.. that might be hard.
09:33:16 <ski> think of  excluded_middle : unit -> ('a,') either
09:33:18 <ski> bah
09:33:24 <ski> think of  excluded_middle : unit -> ('a,'a cont) either
09:33:37 <ski> (codable in SML/NJ e.g.)
09:33:56 <ski> that would be what i think of as an multiplicative use
09:34:19 <ski> esap : maybe you wanna example of how that would work ?
09:34:25 <esap> I experimented once with a way of using the control operation to build variable records.
09:34:33 <ski> mhm ?
09:34:37 <esap> variable-length records
09:34:44 <ski> mhm ??
09:34:46 <esap> Maybe that has something like that.
09:34:59 <ski> variable-length how ?
09:35:06 <ski> same field-type ??
09:35:09 <ski> hmm
09:35:51 <esap> you could add new branches to the pair
09:36:02 <esap> via substitution
09:36:29 * ski thinks he might vaguely remember somesuch in TaPL ..
09:36:55 <ski> ok
09:37:28 <esap> hmm.. I just looked at how I did that, but it requires another primitive that I don't currently think should exist. Hmm..
09:37:39 <esap> but it did involve use of control operation
09:38:04 <ski> case excluded_middle () of Right k => throw k 7 | Left n => 6*n
09:38:55 <ski> (that would first enter the 'Right' branch, then jump to k with 7, which causes the cased expr to return again, just to enter the second branch, returning 42)
09:39:22 <ski> esap : ok, hmm
09:39:33 <esap> ski: I think that example can be done with the control operation.
09:39:48 <ski> maybe
09:39:55 <ski> hmm
09:41:07 <ski> fun excluded_middle () = callcc (fn top => Left (callcc (fn k => throw top (Right k))))  (* iirc *)
09:41:29 <andersca> fun!
09:41:36 <ski> top is duplicated, but k is not
09:41:43 <ski> andersca : you think ? :)
09:42:16 <andersca> ;)
09:42:27 <esap> ski: I think it involves 'control x. [x]id', maybe something like case (control x. [x]id) of { Left x -> x 1 ; Right k -> k * 10 }. Something along those lines
09:43:45 * ski has some sml files lying around with similar tricks, such as e.g. eliminate_double_negation : 'a cont cont -> 'a and contrapositive : ('a cont -> 'b cont) -> 'b -> 'a ...
09:44:18 <ski> esap : but that would not work with your current implementaion, right ?
09:44:56 <esap> ski: I haven't tested that. I'm trying to reconstruct it. I remember thinking about quite similar example.
09:45:15 <ski> esap : maybe s/Left x -> x 1/Left x -> [x]1/ ?
09:46:38 <ski> esap : (would not work because the value bound to the x control variable escapes the dynamic control extent of the "control" operation, i meant)
09:46:57 <esap> \x -> case (control id x) of { Left a -> a * 10 ; Right b -> 5 `label` b }
09:47:41 <esap> not quite correct yet :-)
09:49:08 <ski> why is x and overall argument ?
09:49:26 <esap> because control id :: x -> Either a (Subtract a x)
09:50:03 <ski> i don't seem what your x would correspond to in my example ?
09:50:05 <ski> sorry
09:50:05 <esap> (note that Subtract is flip (\\)
09:50:32 <ski> (yep, noted that. currying issues i guess ?)
09:50:47 <ski> s/seem/know/
09:50:49 <esap> yes
09:51:17 <esap> the other order did require some unnecessary exchange of type arguments
09:51:25 <ski> ok
09:52:22 <ski> hm, maybe i should first try to understand your intended interpretation of the formulation with \/ first :)
09:54:23 <ski> (hm, i would maybe write  Gamma \\ x : A |- [x]e : B  as  Gamma |- [x]e : B | x : A   iiuc)
09:55:30 <ski> ("|" being roughly (mult.) disj. if at the right of "|-", but with "focus" on "[x]e : B")
09:55:32 <esap> yea, could be done like that. Probably would be more like standard notation
09:55:46 <ski> possibly
09:56:21 <ski> though, interesting to see one could use a structural \\ on the other side ..
09:57:26 <ski> anyway, the second rule would, if e evals to a left value, jump away to x with that value, and if e evals to a right value, it would just return that value
09:57:30 <ski> is that correct ?
09:58:06 <esap> ski: yes. 'jump if Left'
09:59:07 <ski> Gamma |- e : B | x : A
09:59:13 <ski> ----------------------
09:59:42 <ski> Gamma |- mu x. e : A \/ B
09:59:52 <ski> (first rule, i.e.)
10:00:01 <ski> mhm
10:00:02 <ski> aha
10:00:12 <ski> interesting
10:00:17 <Calister[sick]> good evening
10:00:27 <esap> ski: exactly :-)
10:00:28 <ski> good evening Calister[sick]
10:01:12 <ski> esap : so, that rule is a nop-rule modulo proofs :)
10:01:14 <esap> ski: if you write it like that, the control operation just converts between '\/' and '|'....
10:01:34 <ski> (well, hm, the other too, i think)
10:01:45 <ski> yep, just that
10:02:13 <esap> ski: But still, it seems useful, because of the control flow behaviour.
10:02:47 <ski> now i wonder if the meta-disj to the right of the turstile behaves multiplicative or not ;)
10:03:07 <esap> ski: I'm not quite sure what you mean with multiplicative.
10:03:43 <ski> esap : it's not sure it does. e.g. there are actually multi-conclusioned sequent systems for intuitionistic logic, too
10:04:10 <Darius> If what ski is meta-disjunction, then it's exactly like many type theory related adjunctions
10:04:14 * ski currently thinks a lot in terms of linearity
10:04:39 <esap> I am thinking this in terms of adjunctions, so it should be like type theory related adjunctions.
10:04:45 <ski> Darius : was that a question ?
10:05:21 <esap> There should be adjunction _ \\ A -| A \/ _
10:05:23 <Darius> ski: No, unless the | symbol wasn't meta-disjunction.  It was mostly a response to "But still, it seems useful"
10:05:34 * ski hasn't exactly grasped adjunctions very good yet, though :/
10:06:55 <ski> Darius : ok (it was meta-disjunction ("structural"))
10:07:13 <ski> esap : yes, i think that could well be
10:07:36 <ski> (thinking very loosely about negation etc ..)
10:09:28 <ski> esap : what restrictions do you want (i.e. not impl. artefacts) ?
10:09:48 <ski> control var not visible inside sub-lambdas ?
10:09:54 <ski> more ?
10:09:59 <ski> hmm
10:10:02 <ski> hmmmm
10:10:07 <esap> ski: yes, that's one.
10:10:43 <ski> possibly not visible inside big-lambdas, too (for univ. quant. types) ?  :)
10:11:05 <esap> ski: I don't know about that one, haven't really thought about it. Good point.
10:11:05 * ski looks for a paper ..
10:11:41 <Darius> esap: Have you thought about implementing a (small) language with this feature to flesh everything out or just for control?
10:12:14 <esap> ski: Most of the restrictions are related to the interaction between lambda and control [which I base on the idea that lambda and control are duals, so therefore their interaction is somewhat limited]
10:13:01 <ski> mhm
10:13:47 <esap> ski: the reason why duals don't interact well is because duals are like 'min' and 'max'. You get to do ranges between them, but you can't combine min with max with very many different ways.
10:14:13 <ski> hm, not quite getting that
10:14:34 <esap> darius: That's a good idea, I could actually try to implement it to my current interpreter pretty quickly.
10:14:41 <ski> (trying to find a paper with citeseer which i have on another comp.)
10:15:18 <esap> darius: I've been playing with the Haskell implementation, but haven't got that far into my language that I would have implementation of it.
10:15:40 <esap> darius: But I suppose current situation is somewhat different, I could probably quite easily implement the control into it.
10:16:25 * esap has an arrow-based interpreter half done.
10:16:54 <ski> esap : i think this is the paper i was thinking about ..
10:18:02 <autrijus> HList looks cool and will no doubt be useful, but I'm having problem mapping it to my record requirements
10:18:34 <ski> if you wouldst look at page 4, there is a table of sequent rules for LM (multiple-conclusioned intuitionistic logic)
10:18:36 <autrijus> my keys has to be ordered; and each key guarantees a type; yet multiple keys may have values of the same type.
10:18:40 <Heffalump> HList is a nasty horrible hack.
10:19:08 <autrijus> and also the error messages rising from HList type errors are not easily comprehensible.
10:20:16 <ski> esap : note especially the right rule for ->, it discards any additional control vars visible, so they are not available in the lambda-body
10:20:29 <Marvin--> I keep seeing lots of posts on the lists how HList solves every type-related problem from a to z and how it can make coffee and stuff, but I never really looked at how it works
10:20:58 <esap> ski: yes, that's the compile-time constraint.
10:21:14 <ski> esap : yep, you could say
10:21:45 <Darius> autrijus: What do you mean by "each key guarantees a type"?
10:22:41 <ski> esap : also (right rules for) "not" and "forall" have similar restrictions, otherwise this is just (a formulation of) LK iirc
10:23:53 <ski> (esap : and i would say that LK's \/ behave multiplicative, while LM's prolly doesn't (haven't looked very closely, but think that if it did it would prolly be classical))
10:25:22 <ski> (also (shown is that) call/cc is implementable in LK but neither in LJ nor LM (for different reasons))
10:26:52 <Marvin--> oh good god, HList defines type classes for *everything*?
10:27:17 <Darius> Marvin--: My understanding is that HList uses type level programming...
10:29:08 * Darius can see Haskell 2013 with Kind Classes.
10:30:12 <ski> then we'd need kind polymorphism first
10:31:42 <Riastradh> Haskell in 2005: Turing-complete type system.  Haskell in 2010: kind polymorphism.  Haskell in 2013: kind classes.  Haskell in 2015: Turing-complete kind system.  Haskell in 2020: circular meta-type-kind-system.
10:32:51 <ski> Riastradh : 'tis lambda-calc-complete now ?
10:33:00 <Riastradh> Hmmm?
10:33:11 <ski> the type sys ?
10:33:22 <Riastradh> Type lambdas are supported already?
10:33:27 <Riastradh> ...oh, right, it's 2005 already.
10:33:27 <Riastradh> Oops.
10:33:29 <Riastradh> I forgot about that.
10:33:34 <Riastradh> Make that 2007.
10:33:35 <ski> yep, that
10:33:38 <ski> oki
10:33:58 <Darius> The type system (with -fallow-undecidable-instances) has been Turing-complete for a while.
10:34:04 <Riastradh> ...oh.
10:34:09 <Marvin--> yuck, type-level natural numbers
10:34:14 <Riastradh> Well, fine, move it back to 2003 or whenever.
10:34:35 <Darius> Marvin--: I believe it even has something akin to type level assoc lists.
10:35:03 <wilx> Heh.
10:53:53 <goron> Is there a polynomial algoritm for generating primes?
10:54:29 <goron> algorithm
11:12:10 <samc_> there's a polynomial time alg for prime determination
11:26:46 <goron>  This is an extremely slow method of generating primes - the running time is O(n^(3/2))
11:27:07 <goron> Hmm, this one not. 
11:27:34 <goron>  This algorithm is much faster than the previous; it has a running time of O(n log log n).
11:27:38 <goron> But this one is. 
11:32:29 <dan2> what does this mean
11:32:30 <dan2> (a:as)
11:32:34 <dan2> as a function argument
11:33:08 <musasabi> dan2: it pattern matches against a list.
11:33:20 <dan2> oh ok
11:33:30 <monochrom> it matches a non-empty list.
11:33:38 <musasabi> dan2: it matches a non-empty list binding "a" to the head and "as" to the tail.
11:33:49 <dan2> ahh I see
11:33:52 <monochrom> if you pass it [1,2,3,4], a becomes 1, as becomes [2,3,4]
11:33:57 <dan2> right
11:34:02 <dan2> thats like ocaml -- h::t
11:34:13 <monochrom> Oh you already know ocaml.
11:34:20 <dan2> monochrom: yeah
11:34:44 <monochrom> can take advantage of that.
11:35:06 <dan2> monochrom: trying to write a merge algorithm in ocaml to test scalability, there was an existing haskell example so I thought it'd be useful
11:35:35 <monochrom> neato
11:39:59 <dan2>      | a <= b = a : merge as (b:bs)
11:40:03 <dan2> what does that line mean
11:40:10 <dan2> more specifically after the colon
11:40:54 <musasabi> if a <= b then list of a :: merge as (b::bs)
11:41:06 <musasabi> (if :: is used in ocaml like it is in haskell)
11:41:29 <dan2> I don't know what :: like that means \
11:41:33 <musasabi> [a,b,c] == (a:b:c:[])
11:41:39 <dan2> what does the colon mean
11:41:47 <dan2> oh crap
11:41:49 <dan2> now I see
11:41:59 <Riastradh> : & :: in Haskell are the converse of what they are in OCaml.
11:42:15 <Riastradh> : is cons, :: is 'has type'; in OCaml, :: is cons, and : is 'has type.'
11:42:18 <dan2> a <= b = a::(merge as b::bs)
11:43:15 <monochrom> | is when
11:46:25 <dan2> ok
11:46:31 <Lemmih> shapr: Ping.
12:07:24 <dan2> Riastradh: whats the equivalent to splitAt inocaml
12:08:43 <Riastradh> Are you asking for what Haskell's splitAt would be in OCaml?
12:08:49 <dan2> Riastradh: yes
12:09:14 <Riastradh> I don't know.
12:10:13 <dan2> its obviously not List.split
12:53:22 <xerox> TheHunter, can you plug in your bot with reduction-plugin?
12:55:11 <thbot> it's an ugly hack, but i think i can parse sections now.
12:55:58 <xerox> just to see if I'm doing well
12:56:03 <xerox> foldrConcatMap f = foldr (\a b -> f a ++ b) []
12:56:03 <xerox> foldrConcatMapPF = (`foldr` []) . ((.) (++))
12:56:14 <xerox> what was the command?
12:56:25 <TheHunter> @pointfree foldr (\a b -> f a ++ b) nil
12:56:25 <thbot> foldr ((++) . f) nil
12:56:26 <lambdabot> Sorry, I don't know the command "pointfree", try "lambdabot: @listcommands
12:56:39 <TheHunter> thbot: @pointfree \f -> foldr (\a b -> f a ++ b) nil
12:56:39 <thbot> flip foldr nil . ((++) .)
12:56:58 <xerox> uh (-:
12:57:54 <xerox> I'm happy with my result, okay, thanks (-:
13:05:14 <Gahhh> whoa, the chinese natural language thread on LtU is absurd...
13:08:27 <xerox> Gahhh, what's LtU?
13:09:03 <Lemmih> http://lambda-the-ultimate.org/
13:12:31 <termol> can i do some system administrative work with hugs on windoze?
13:13:59 <termol> @type uncurry
13:14:00 <thbot> Sorry, I don't know the command "type", try "lambdabot: @listcommands"
13:14:01 <lambdabot> uncurry :: forall c b a. (a -> b -> c) -> (a, b) -> c
13:14:14 <Gahhh> termol, probably. mostly command line stuff ?
13:14:38 <termol> yes, i want to run a command on every file in a directory. 
13:15:01 <Gahhh> termol, that should be trivial.
13:15:26 <Gahhh> in fact, I've done something like that recently...
13:15:51 <termol> ok, the commmand is 'lame -b 32 infile.mp3 outfile.mp3'
13:16:11 <termol> of course the name of those files is what haskell has to substitute
13:17:20 <xerox> Do you know what CMS do LtU use?
13:17:42 <termol> Gahhh: do you have any idea on how to accomplish that?
13:18:09 <Gahhh> termol, have you done any IO in haskell ?
13:18:24 <termol> yes
13:18:35 <termol> but i don't know how to run system commands
13:18:48 <termol> from hugs
13:19:14 <Gahhh> oh, I used ghci for my script, and I used System.system and Directory.getDirectoryContents.
13:19:46 <termol> ok. maybe i should install ghci then...
13:19:53 <Gahhh> but hugs should have something similar
13:20:23 <Gahhh> ok, hugs has System, but it doesn't have Directory library
13:20:33 <termol> Gahhh: yes i has
13:20:36 <termol> it has
13:20:45 <arjanb> xerox: drupal
13:20:49 <termol> i just tried :l Directory
13:20:52 <xerox> arjanb, thanks much.
13:21:24 <Gahhh> oh. its help file says it does not. heh. ok then.
13:22:05 <termol> Gahhh: how to get the current directory?
13:22:32 <termol> Gahhh: or even better, were is this documented?
13:22:52 <Gahhh> it's in the haskell report
13:23:07 <termol> Gahhh: ok. i found a good reference on zvon.org
13:23:56 <termol> Gahhh: how would i write out the contents of the current directory?
13:24:06 <Gahhh> write out to the screen ?
13:24:39 <termol> yes
13:25:39 <termol> Gahhh: in a oneliner.
13:26:27 <Gahhh> do { cwd <- Directory.getCurrentDirectory; fyles <- Directory.getDirectoryContents cwd; sequence_ map putStrLn fyles }
13:26:31 <Gahhh> I think.
13:27:28 <termol> Gahhh: it's that much to write? can't you use >> or something?
13:29:29 <TheHunter> mapM_ putStrLn =<< getDirectoryContents =<< getCurrentDirectory
13:31:53 <termol> mapM_putStrLn, is that a standard function?
13:32:10 <TheHunter> @index mapM_
13:32:10 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
13:32:10 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
13:32:10 <lambdabot> State,Control.Monad.Writer,Prelude,Monad
13:32:27 <TheHunter> mapM_'s in the prelude
13:33:21 <termol> apparently not in hugs...
13:33:51 <Lemmih> I believe it is.
13:35:38 <Lemmih> termol: It's named 'mapM_', not 'mapM_putStrLn'.
13:35:43 <termol> ok i didn't see the space between mapM_  and putStrLn. sorry about that. maybe should get monospaced font in irc.
13:37:13 <monochrom> hehehe
13:37:36 <monochrom> can't imagine the logic of not using a monospace font in the first place, in a programming channel.
13:38:28 <Riastradh> Using variable width fonts for code is EVIL!  DIE!
13:38:33 * Riastradh froths.
13:39:21 <termol> yes well i apologize for my ignorance in this and other matters...
13:40:49 <ibid> blah
13:40:52 <ibid> numerics is a mess
13:47:23 <termol> TheHunter: now i would like to iterate the contents of the current directory and run command "lame -b 32' on each file. any clues?
13:53:30 <TheHunter> termol, replace putStrLn with (system . foo) where foo :: String -> String
13:54:26 <TheHunter> ah, foo = ("lame -b 32 " ++)
13:55:21 <termol> TheHunter: very interesting thank you...but i guess i need to brush up on monads to fully understand whats going on here...
13:56:08 <termol> TheHunter: is the dot between system and foo necessary?
13:59:13 <termol> termol: i guess so...
14:01:32 <termol> guys, whats the difference between mapM and mapM_
14:01:57 <musasabi> termol: mapM_ discards the resulting value.
14:03:53 <termol> musasabi: what would be the resulting value in this case:     mapM_ putStrLn =<< getDirectoryContents =<< getCurrentDirectory
14:05:39 <musasabi> IO ()
14:06:17 <termol> musasabi: and what was discarded?
14:06:34 <musasabi> the list of results.
14:06:46 <musasabi> with mapM you would have IO [()]
14:07:02 <termol> musasabi: so not a big difference then?
14:07:37 <Heffalump> if the IO monad was lazy, there might be
14:07:47 <Heffalump> you might find that some of the actions didn't happen until you actually evaluated the list
14:07:53 <Heffalump> but since it isn't, it shouldn't matter
14:08:20 <termol> is mapM a way to run actions in a list?
14:10:03 <Lemmih> Its type explains it all.
14:19:11 <Heffalump> anyone familiar with haskelldb around? (shapr?)
14:20:36 <Lemmih> Heffalump: I've used HDB quite a lot.
14:20:55 <Heffalump> does it make indexes?
14:23:16 <Lemmih> I've never used it to create tables.
14:26:05 <termol> TheHunter: what if i needed the file name twice in my command string?
14:27:39 <Marvin--> termol: just write foo differently?  foo fname = ... fname ... fname ...
14:28:37 <termol> Marvin--: but i don't think i have the filename....i'm using mapM
14:28:54 <Marvin--> termol: I thought the argument to foo was the file name?
14:29:17 <Marvin--> foo :: String -> String
14:29:26 <termol> Marvin--: yes, that is correct, but how can i get it from mapM?
14:29:37 <Marvin--> foo = ("something" ++)  is equivalent to  foo x = "something" ++ x
14:30:54 <termol> the expression is:   mapM_ (system . "foo " ++)  =<< getDirectoryContents =<< getCurrentDirectory
14:31:21 <Marvin--> you mean mapM_ (system . ("foo " ++)) =<< ... right?
14:31:37 <termol> Marvin--: yes, sorry
14:32:29 <Marvin--> termol: you could use a lambda abstraction, but it makes more sense to define a helper function
14:32:49 <termol> Marvin--: so i can extract the file name?
14:32:55 <Marvin--> if you define  cmdline fname = ... fname ... fname ...   you can use    mapM_ (system . cmdline) =<< ...
14:33:04 <Marvin--> it's not a question of extracting :)
14:33:37 <Marvin--> mapM_ takes a function and a list as arguments, and applies the function to all items in the list
14:34:03 <termol> but it's the list that holds the file names.
14:34:07 <Marvin--> right
14:34:47 <termol> Marvin--: ok, i think i get your point...
14:34:48 <Marvin--> but if you write the function  cmdline fname = ...   and use that in mapM_, then cmdline will be applied to all file names in the list
14:52:50 <zipper> "at Japanese the beard grows badly"
15:37:39 <musasabi> A
15:41:34 <heatsink> A what?
15:41:41 <heatsink> A beetle? A regime?
15:41:48 <ski> A 'A'
15:41:57 <ski> An 'A'
15:41:59 <Riastradh> No, that's 'an "A,"' so it can't be right.
15:42:31 <ski> maybe some course grade ??
15:42:55 <monochrom> maybe he was testing his keyboard
15:49:46 <musasabi> A
15:50:07 <musasabi> sorry.
15:50:44 <musasabi> ctrl is acting up again and alaggy screen.
15:53:51 <bourbaki> moin
15:54:22 <Lemmih> Hey bourbaki.
16:33:14 <Darius> esap: If you haven't noticed it already, I've just inadvertently stumbled on a paper, "A Theory of Classes: Proofs and Models" that seems to be what you wanted earlier; ironically at pretty much the same place as I got the "Computational Category Theory" link.
16:34:26 <Darius> esap: If you have an ACM account, there is also "Towards a Categorical Semantics of Type Classes"
16:34:53 <esap> darius: I don't have an ACM account.
16:35:27 <esap> darius: I need to look those when I have some time.
16:37:10 * esap is trying to implement control operation.
16:41:47 <vincenz> hi
16:43:30 <bourbaki> nighto
16:45:11 <Darius> esap: Luckily, for you and me, the former paper seems to be a "reformulation and extension" the theory described in the latter paper.
16:56:08 <wli> hmm
16:56:27 <wli> this seems to be a more faithful version of Euclid
16:56:28 <wli> unfoldr (\(p:xs) -> Just (p, filter (\x -> x `mod` p /= 0) xs)) [2..]
16:58:28 <ski> @seen thbot
16:58:29 <lambdabot> I saw thbot leaving #haskell 3 hours 43 minutes 41 seconds ago.
17:00:27 <monochrom> Data.Typeable.cast is sick sick sick.  I mean the implementation of it.  Sick sick sick.
17:00:44 <monochrom> Very evil.
17:01:24 <monochrom> Very clever, and evil.
17:03:47 <wagle> @info Data.Typeable.cast
17:03:48 <lambdabot> -- Data.Typeable.cast is a variable
17:03:48 <lambdabot> Data.Typeable.cast :: forall a b. (Data.Typeable.Typeable a, Data.Typeable
17:03:48 <lambdabot> Typeable b) =>
17:03:48 <lambdabot> 		      a -> Maybe b
17:04:51 <dons> hehe
17:04:59 <dons> cast x = r
17:04:59 <dons>        where
17:04:59 <dons>          r = if typeOf x == typeOf (fromJust r)
17:04:59 <dons>                then Just $ unsafeCoerce x
17:05:00 <dons>                else Nothing
17:06:58 <monochrom> Yes, the fixpoint equation there.  It works because typeOf (fromJust r) will never get to the point of evaluating fromJust r.
17:07:31 <dons> it's rather lovely :)
17:07:42 <Darius> monochrom: That's, I believe, a common trick for getting the type information of a result.
17:08:00 <monochrom> Right, now I see.
17:09:18 <Darius> monochrom: I'm pretty sure I've used it for something, but I don't remember what it was.
17:10:17 <Darius> I believe using scoped type variables you can avoid the trickery.
20:47:14 * autrijus gave up HList.TIP :-/
20:48:13 <autrijus> it works as documented but the type->natural mapping is weird; to make it work robustly I'll have to use template haskell to generate the sequencing code
20:48:23 <autrijus> it really feels like overkill for this project
21:05:20 * shapr yawns
21:05:26 <shapr> good morning #haskell!
21:11:37 <Lemmih> You're up early (or late perhaps?).
21:14:06 <shapr> Just woke up half an hour ago.
21:14:37 <Lemmih> shapr: I can't apply patches to the hackage repo. It mails me this: "Caught exception: user error (Error applying patch to recorded!)"
21:15:40 <shapr> Ok, I'll see if I can figure out what's wrong with it.
21:15:58 <shapr> can you send me directly a patch that gives you that error?
21:16:06 <shapr> I haven't gotten any bounces from that repo
21:26:51 <shapr> Lemmih: I get the same error, with no real explanation
21:30:09 <Lemmih> shapr: Hmm. The patch mainly consists of several deletions. Could that be a problem?
21:34:27 <shapr> I don't see how
21:34:48 <shapr> not unless they've already been deleted in the repo
21:37:29 <Lemmih> My attempts at coding a simple layered buffer has failed miserably.
21:38:09 <dons> layered yi buffer?
21:42:43 <Lemmih> dons: Moving the code to yi will probably be the final step.
21:43:20 <Lemmih> Right now I'm just trying to get the fundamental ideas right.
21:43:36 <dons> oh, ok :) I thought you might have been doing hard core yi redesign !
21:44:01 <dons> prototypes are very welcome
23:33:31 <shapr> yeehaa
23:33:44 <Lemmih> dons: I wonder if a system like Proxima is overkill for yi.
23:35:49 <Lemmih> Forcing the use of predefined indentation rules would make it a lot simpler.
23:36:22 <shapr> The original refactoring browser used pretty printing rules that you could change yourself.
23:36:32 <shapr> Sort of like emacs' multiple c-style settings.
23:38:57 <Gahhh> what is yi ?
23:39:12 <shapr> http://www.cse.unsw.edu.au/~dons/yi.html
23:40:19 <Gahhh> a terminal editor ?
23:40:29 <shapr> so far, it's terminal only
23:40:37 <shapr> but the UI will be pluggable
23:44:38 <Lemmih> shapr: Do you think forced/automatic indentation would be acceptable for Joe Hacker?
23:56:30 <shapr> I started on a refactoring browser once, I got a lot of negative feedback for the idea of allowing only one indentation setting.
23:56:57 <shapr> I think it would still be acceptable if you allow people to write their own indentations.
23:59:30 <Lemmih> Keeping such extra information is very hard.
