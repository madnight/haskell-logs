00:01:21 <wli> Fastest Fibonacci numbers in the West doesn't appear to be a popular subject.
00:02:05 <Lemmih> the_learner: Static typing is a guarding angle protecting you from yourself.
00:07:50 <Gahhh> wli, I have seen some dynamic programming examples that used Fibonacci number generators.
00:35:53 <Itkovian> wli: I'm just reading yr post.
00:36:09 * Itkovian will try not to make sumb comments
00:36:15 <Itkovian> s/sumb/dumb/
00:36:25 <Itkovian> that may have been the first one of today
00:37:11 <wli> Itkovian: no problem
00:41:47 <the_learner> CAN HASKELL BE USED NOW IN A STARTUP TO MAKE MONEY
00:42:47 <musasabi> can any language be used now in a startup to make money?
00:43:30 <wli> the_learner: haskell.org is indeed the root of all MAKE.MONEY.FAST methods
00:43:35 <the_learner> NICE
00:43:39 <the_learner> OK PERL OR HASKELL
00:43:43 <wli> the_learner: ISN'T IT?
00:43:45 <musasabi> I think that making money has little to do with technical quality or the lack of that ;)
00:43:49 <wli> the_learner: HASKELL OF COURSE
00:43:51 <the_learner> HASKELL SEEMS TO HAVE LOTS OF UNFINISHED SUPPORT LIBARY
00:43:54 <the_learner> OK
00:43:57 <the_learner> GNIGHT 4 NOW
00:44:08 <mflux> it's a darn shame I've sacrificed my caps lock for other purposes :-/
00:44:13 <wli> the_learner: HASKELL DOESN'T NEED THE SUPPORT LIBRARIES; ITS ABSTRACTIONS ARE HIGHER-LEVEL
00:44:24 <mflux> s/sacrificed/sacrified/
00:46:06 <Itkovian> indeed it is
00:46:20 * wli saw fit to fight fire with fire.
00:46:36 <Itkovian> burn burn, yes yr gonna burn ... etc. etc.
00:47:59 <Itkovian> wli: shouldn't you have a | in the fun unfold 0 = [] line?
00:48:17 <Itkovian> or am I missing something?
00:48:19 <Itkovian> hmm
01:02:58 <Itkovian> ignore my previous rant
01:03:08 <Itkovian> I'm still half asleep
01:04:54 <wli> Itkovian: I don't see anything yet.
01:15:43 <wli> Itkovian: still nothing
01:25:24 <Itkovian> wli: just ignore it :-)
01:47:19 <Itkovian> wli: on what machine did you run those fibonacci things?
02:27:47 <samc_> lo all, I'm writing a haskell syntax highlighting mode, and in the language report is defines a single line comment as starting with a '--' which does not form part of a legal lexeme, therefore I can define a new operator thereby changing what was once a comment into a non-comment, huh?
02:28:24 <samc_> wow incoherent even by my own standards
02:32:11 <Itkovian> I'm undere the impression that the ghc generated code for those fibonacci number show _very_ low IPC
02:32:53 <Itkovian> .09037594280068386373
02:33:01 <Itkovian> this is _very_ bad.
02:33:38 <Itkovian> it's measured on an Athlon XP 1GHz. Memory requirements are very small, so no problem there.
02:34:56 <lightstep> it the fran source code available for download? all i seem to find is fran116.exe
02:37:09 <Itkovian> hmm ... the OPC (retired ops per cycle) otoh is quite good.
02:38:04 <samc_> what legal lexemes besides '-->' and '|--' contain a '--'?
02:40:37 <lightstep> probably also --->
02:40:49 <earthy> and @--
02:40:51 <earthy> and --@
02:40:57 <earthy> and =--
02:41:00 <earthy> and so on
02:41:17 <earthy> see pages 8, 9 and 10 of the Haskell 98 report
02:41:36 <earthy> or even ----, if I read correctly
02:41:40 <samc_> I see, many, thanks I will
02:44:19 <magical1> sorry, but what does this mean?    Int->Int->[[Int]]
02:44:20 <earthy> hm. ---- does not parse
02:44:56 <earthy> magical1: in short, a function taking two integers and returning a list of lists of integers
02:45:28 <magical1> okay!
02:45:34 <magical1> ty
02:46:26 <lightstep> earthy: varsym cannot bereservedop or dashes
02:46:35 <lightstep> s/ber/be r/
02:47:14 * samc_ is dumb
02:49:53 <samc_> what is a 'unicode symbol'? and does anyone use more than utf-8?
02:51:18 <lightstep> utf-8 is an encoding format, it can represent any unicode codepoint
02:52:09 <earthy> lightstep: but doesn't the report state that it matches lexemes greedily?
02:52:24 <earthy> and dashes is only -- or ---, if I read correctly
02:52:41 <earthy> ah, no
02:52:45 <earthy> I read incorrectly
02:53:21 <lightstep> samc_: and the definition of unicode symbol (a long list of symbol types) is here: http://www.unicode.org/versions/Unicode4.0.0/ch14.pdf
02:56:01 <samc_> thanks lightstep, to rephrase my question then, does anyone use more than ascii
02:58:10 <musasabi> samc_: yes.
02:58:14 <musasabi> samc_: daily.
02:58:25 <lightstep> in source code?
02:59:01 <musasabi> lightstep: only if I need to print error messages in different languages.
02:59:21 <musasabi> btw does up-to-date cabal documentation exist somewhere?
03:00:46 <samc_> I think I'll get only the ascii characters working then move on to unicode
03:01:39 <magical1> @type fst
03:01:40 <lambdabot> fst :: forall a b. (a, b) -> a
03:02:11 <lightstep> @type wrapper
03:02:12 <lambdabot> bzzt
03:02:30 <musasabi> samc_: btw what I use is iso-8859-15 ;)
03:02:52 <magical1> so if there are more than two things in a list I have to use first?
03:03:00 <magical1> sorry I mean head
03:03:46 <magical1> hummmmm....
03:03:49 <lightstep> from what i seen, case is usually better
03:04:13 <lightstep> fst works with products, not lists
03:04:42 <magical1> @type first
03:04:43 <lambdabot> bzzt
03:04:49 <magical1> @type head
03:04:51 <lambdabot> head :: forall a. [a] -> a
03:04:58 <magical1> @type tail
03:04:59 <lambdabot> tail :: forall a. [a] -> [a]
03:05:06 <magical1> @type end
03:05:07 <lambdabot> bzzt
03:05:12 <magical1> @type last
03:05:13 <lambdabot> last :: forall a. [a] -> a
03:05:23 <magical1> okay
03:05:55 <magical1> what is the difference between (1,2,3) and [1,2,3]?
03:06:47 <lightstep> (1,2,3) is a tuple of type (Int,Int,Int), and [1,2,3] is a list of type [Int]
03:07:10 <magical1> okay, thanks
03:14:11 <musasabi> using cabal to pack executables is very nice :-)
03:25:30 * magical1 frowns
03:27:39 <magical1> okay so that was it, or will it happen again?
03:42:23 <samc__> is there anything which takes a regex and spits out strings it accepts, either randomly or systemstically?
03:42:56 <musasabi> Using Control.Exception in place of Control.Monad.Error yields a 30% speedup for me :-)
03:47:40 <jlouis> samc__: it could be a problem very fast. Take the regex a*b*. If you just deterministically start with a*, you'll never reach any string a...ab
03:49:22 <ozone> samc__: http://repetae.net/john/computer/haskell/RegexSyntax.hs
03:49:52 <ozone> ah, there's my original message
03:49:53 <ozone> http://www.haskell.org/pipermail/haskell-cafe/2004-February/005857.html
03:50:36 <ozone> samc_: in case you missed it ...
03:50:38 <ozone> samc__: http://repetae.net/john/computer/haskell/RegexSyntax.hs
03:50:40 <ozone> http://www.haskell.org/pipermail/haskell-cafe/2004-February/005857.html
03:50:45 <ozone> pick whatever's simpler for your purposes
03:51:21 <samc_> oh cool, (and I did)
03:52:19 <Itkovian> I'm looking for decent haskell benchmarks ....
03:52:23 <Itkovian> ghc is one ...
03:52:40 <Itkovian> I'll figure out why the IPC is so loooooow
03:52:50 <Itkovian> well, I want to anyway ...
04:01:40 <magical1> musasabi: is that correct?
04:06:05 <magical1> ;)
04:22:38 <syntax_syntax> I don't understand.
04:23:02 <syntax_syntax> Isn't the code you put in a _do_ block de facto imperative?
04:25:17 <aj> syntax_syntax: depends on what monad you're using; and some of the weird unsafeIO things make it non-imperative too. but you could argue either way
04:26:24 <syntax_syntax> hmm.
04:28:04 <aj> monads give you an ordering, but that's not necessarily imperative; and the unsafe stuff breaks the ordering anyway, basically :)
04:28:55 <Philippa> syntax_syntax: code in a do block is effectively in some language that isn't quite Haskell (yet nevertheless yields Haskell values). That language may or may not be imperative
04:29:00 <syntax_syntax> I think I don't understand monads yet. I went as far as understanding what are categoriers and morphisms, and doing some basic arrow proofs with coequalziers and equalizers and equivalence classes, but.
04:29:21 <syntax_syntax> oh. 
04:30:12 <syntax_syntax> so technically someone could write a module to import that could read from a CGI interface or an Excel spreadsheet in do blocks
04:31:23 <aj> sure, that's just using the IO monad
04:32:12 <aj> readExcelSpreadSheet :: FileName -> IO([[Cell]])   # or so
04:33:00 <magical1> I think I might be understanding this now :)))) thanks musasabi 
04:37:03 <syntax_syntax> aj hmm. they have made such a module already?
04:38:10 <aj> no idea
04:39:43 <syntax_syntax> grr. Layout hell.
04:39:58 <syntax_syntax> bah, why do I bother?
04:43:56 <Itkovian> how much work would it take to add something like -- arg1 arg2 arg3 to ghc, where the args are then args for the command line program, instead of for the compiler itself?
04:51:15 <magical1_> bbl
06:21:02 <shapr> yow!
06:29:50 * shapr hops
06:47:05 <tintin> hello shapr
06:50:33 <LittleDa1> could typeclasses work in a dynamically typed language?
06:51:33 <tuomov> in most dynamically typed languages I'm aware of you have implicit type classes
06:52:22 <tuomov> sort of
06:52:31 <LittleDa1> what do you mean?
06:52:53 <tuomov> function f(p) p:foobar() end
06:53:18 <tuomov> f expects p to have the field foobar; i.e. be in such a "typeclass" that implements foobar
06:53:45 <tuomov> (that particular example being in lua and p being a table)
06:54:09 <LittleDa1> hmm
06:54:13 <TheHunter> you can't get the full power of type classes in such languages.
06:54:35 <TheHunter> e.g. you couldn't implement something like quickcheck
06:54:35 <tuomov> of course not
06:54:46 <LittleDa1> I was just reading the Python "Monkey typing" proposal and I thought it looked like it would be much better solved with typeclasses, if only that were possible
06:54:52 <LittleDa1> TheHunter: what's that?
06:55:11 <TheHunter> it's a testing framework for haskell that is not quite unit-testing.
06:55:26 <LittleDa1> what do you mean?
06:55:48 <TheHunter> basically, you specify laws and qc tests if it holds in randomly generated test cases.
06:56:53 <LittleDa1> and it uses typeclasses to generate random data of the right type?
06:57:14 <LittleDa1> and to specify the laws?
06:57:18 <TheHunter> Prelude Debug.QuickCheck> test (\x y z -> (x::Int) + y + z == x + (y + z))
06:57:18 <TheHunter> Loading package QuickCheck ... linking ... done.
06:57:18 <TheHunter> OK, passed 100 tests.
06:57:18 <TheHunter> Prelude Debug.QuickCheck> test (\x y z -> (x::Double) + y + z == x + (y + z))
06:57:18 <TheHunter> Falsifiable, after 21 tests:
06:57:30 <TheHunter> LittleDa1, Right.
06:58:01 <LittleDa1> because you're dispatching on the return type there, right?
06:59:14 <TheHunter> yes.
07:01:36 <LittleDa1> do you think typeclasses are sufficient for all concievable type operations?
07:02:00 <LittleDa1> or is there anything they might leave out
07:03:26 <TheHunter> they're not the silver bullet. With ghc's extensions, they're quite powerful, but programming on the type level can become a real mess.
07:03:50 * kosmikus grins
07:04:29 <LittleDa1> can TH manipulate type stuff at compiletime with full Haskell?
07:07:13 <TheHunter> i'm not really familiar with TH, but I think it can.
07:12:49 <Philippa_> yes, it can
07:12:55 <Philippa_> you can even do IO in the Q monad
07:13:13 <Philippa_> which means that if you don't mind having haskell as an intermediate language, you can even write compilers for other languages with it
07:20:11 <LittleDa1> what's the Q monad, Philippa? Is that what you use in TH?
07:20:53 <Philippa_> yeah
07:21:59 <ozone> LittleDa1: Q == Quotation
07:22:16 <ozone> so-called because TH uses "quasi-quotes", which are the [| ... |] syntax
07:43:59 <MegaMonad> Thanks philipa. I'll try to borrow them (or, in some cases, steal them) they're welcome.
07:44:43 <CosmicRay> MegaMonad: telephones suck.
07:44:44 <MegaMonad> CosmicRay: Yeah, that does suck.
07:45:29 <CosmicRay> MegaMonad: what else sucks?
07:45:31 <MegaMonad> CosmicRay: Andersca sucks at exceptions, seeming how they're all doing.
07:45:50 <CosmicRay> MegaMonad: I didn't know that.
07:45:51 <MegaMonad> CosmicRay: 15 : ((A->a->b)->a->a.
07:45:53 <tromp> computers suck
07:46:05 <CosmicRay> MegaMonad: do bots suck?
07:46:07 <MegaMonad> CosmicRay: Ok, now you need structure for instance if you have noticed at times requires some other function calls, so you can suck a lot.
07:46:51 <CosmicRay> MegaMonad: thank you for the permission.
07:46:53 <MegaMonad> CosmicRay: I want a "proper" theoretical model for decades and i have write permission to /usr/share/dict/words"; writefile "test.hs" ("main = putstrln " ++ show x)    in ghci takes me all the characters are coming through the files in libghc6-foo-dev should register the wxhaskell mailing lists? I'm curious if the other thefts.
07:53:15 <Itkovian> I'm off. ttyl
07:59:57 * wli dredged up Word and Bit
08:00:02 <wli> the bit twiddling lost
08:29:44 <musasabi> getting those unboxed 
08:29:52 <musasabi> is going to be hard.
08:37:55 <TheHunter> hmm, is it possible to reify the definition of a top-level variable using TH?
08:38:15 <TheHunter> i only seem to have access to the type information.
08:39:20 <Igloo> I don't think so
08:39:45 <TheHunter> ok, thanks.
08:39:45 <Igloo> I'm sure Simon said no for other modules as he'd have to store it somewhere, and I don't recall a special case for the current module
08:43:54 <Lunar^> Igloo: I may need your help quite soon
08:44:13 <Lunar^> Igloo: I'm writing a binding for FUSE, and I think it could be Cabalized
08:44:42 <Igloo> Are you confusing me with Syntax?
08:44:58 * Lunar^ hides
08:44:58 <Lunar^> sorry
08:45:20 * Igloo is disappearing anyway
08:50:59 <magical1> @type int
08:51:00 <lambdabot> bzzt
08:51:05 <magical1> @type Int
08:51:06 <lambdabot> bzzt
08:51:21 <kosmikus> Int is not an expression
08:51:31 <magical1> @yow
08:51:31 <lambdabot> -- I can do ANYTHING ... I can even ... SHOPLIFT!!
08:52:04 <magical1> sorry, just trying to convince a friend to use this channel
08:53:01 <magical1> erm whats the unicycle channel
08:53:27 <kosmikus> #unicycling ?
08:53:48 <magical1> d'uh
08:53:54 <magical1> thanks kosmikus 
08:54:15 <kosmikus> np
08:57:23 <CosmicRay> @yow
08:57:23 <lambdabot> How's it going in those MODULAR LOVE UNITS??
08:58:33 <magical1> @yow
08:58:34 <lambdabot> Either CONFESS now or we go to ``PEOPLE'S COURT''!!
08:59:43 <CosmicRay> too bad megamonad ignores lambdabot.
08:59:48 <CosmicRay> this could be very interesting training.
09:01:20 <magical1> whats megamonad?
09:01:26 <CosmicRay> @wiki megamonad
09:01:26 <lambdabot> http://www.haskell.org/hawiki/megamonad
09:01:32 <CosmicRay> magical1: read that url.  it's fun.
09:01:35 <CosmicRay> err
09:01:37 <CosmicRay> @wiki MegaMonad
09:01:38 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
09:01:42 <CosmicRay> that's the correct URL.
09:03:22 <magical1> thats cool
09:45:55 * shapr cackles evilly
10:02:49 <shapr> hej alla
10:04:49 <stepcut> what?! no 'hello stepcut'!
10:04:59 <shapr> hello stepcut
10:05:04 <stepcut> hello shapr!
10:05:05 <shapr> how ah ya?
10:05:17 <stepcut> excellent!
10:05:22 <shapr> cool!
10:05:36 <stepcut> Did you see that patch I submitted to haskelldb ?
10:05:38 <shapr> yes
10:05:56 <shapr> I've been wondering if haskelldb can be incrementally switched to modular backends.
10:06:08 <stepcut> for the optimization and sql generation ?
10:06:38 <shapr> yeah.
10:07:04 <shapr> Also, I wonder if generating SQL is the best approach. I vaguely recall that PostgreSQL uses something of its own internally.
10:07:36 <stepcut> It should be pretty straight forward for SQL generation, basically any backend specific stuff (mysql, postgres) would go in the optimizer code
10:07:37 <shapr> If the custom backends part really works, you'd be able to generate 'native' output for each backend.
10:07:57 <shapr> Greetings Herr Zapf
10:07:58 <stepcut> so you just need different optimizer implementations and a way to select which one you want
10:08:07 <basti_> regreets
10:08:24 <stepcut> if you want to generate non-SQL that would be a little more work, but doable
10:08:35 <stepcut> instead of toSQl, you would just have toSomethingElse
10:08:38 <shapr> right
10:08:56 <stepcut> I kinda think the first step is to use a more powerful relation algebra 
10:09:05 <stepcut> (the one defined in that book I referenced perhaps)
10:10:36 <stepcut> Also, one of the Hlist papers had an interesting example of extensible records for database queries -- It would be nice to see how that compares to what is currently in haskelldb
10:11:30 <shapr> I'd be surprised if that's not related to the original HaskellDB, which used TRex in Hugs.
10:11:37 <stepcut> I don't think the switch to the more powerful relational algebra would be very difficult, though it would probably not be backwards compatable
10:12:04 <shapr> On the good side, wouldn't that give HDB a real semantic model?
10:12:32 <stepcut> what are you refering to by 'that' ?
10:12:41 <shapr> the more powerful relational algebra
10:13:09 <shapr> I think that would 'carve in stone' a lot of the behaviour of HDB, and allow for QuickCheck tests that would be the same for every backend.
10:13:14 <stepcut> yeah
10:13:40 <shapr> Right now I have to use ilike with the PostgreSQL backend, and like with everything else.
10:13:51 <shapr> Because there's no set behaviour.
10:13:58 <stepcut> right
10:14:45 <stepcut> speaking of which, sets are another problem, haskelldb uses sets, but this other algebra uses bags
10:14:50 * stepcut has to help the boss, bbiab 
10:43:01 <CosmicRay> are the hsql folks active anymore?
10:43:35 <magical1> hSQL? is that a combination of Haskell and SQL?
10:43:45 <CosmicRay> it's a generic haskell interface to sql databases
10:43:50 <CosmicRay> similar to jdbc in java or dbi in perl
10:44:27 <magical1> I remember the jdbc .....
10:44:41 <magical1> :((
10:45:32 <magical1> the project manager kept changing the passwords and not informing us, it made it an absolute nightmare
10:46:28 <CosmicRay> heh
10:49:59 <magical1> CosmicRay: did you get to look at that email I sent you?
10:52:40 <shapr> Yeah, HSQL is active.
10:52:45 <shapr> Krasimir Angelov
10:52:49 <CosmicRay> magical1: yes, looks like you have a good start.
10:52:54 <shapr> HaskellDB is a layer on top of HSQL
10:53:07 <CosmicRay> shapr: right.  Then I will send some patches to Krasimir.
10:53:18 <CosmicRay> hsql is missing a few features that I'd like to see
10:53:23 <CosmicRay> and which are fairly easily added
10:56:55 <shapr> I'm wondering if I should really respond to the most recent Alex Peake post. He says that the most limiting factor in the adoption of Oz, OCaml, Scheme, Lisp, Haskell, etc is that they lack good GUI, Database, Authentication, Message Queueing, and Report Design support.
10:57:13 <CosmicRay> uh
10:57:15 <CosmicRay> Report Design?
10:57:24 <CosmicRay> where is he coming from?
10:57:29 <CosmicRay> AS/400?
10:57:36 * shapr dunno
10:57:53 <CosmicRay> you can tel him that may be so, but at least we do support ASCII. :-)
10:57:59 <shapr> It's sort of hard to take him seriously.
10:58:14 <stepcut> The biggest limiting factor in the adoption of PHP is its lack of a good GUI, Database, Authentication, Message Queueing, and Report Design support
10:58:23 <CosmicRay> heh
10:58:33 <stepcut> well, maybe PHP has ok Database
10:58:47 <shapr> Not compared to HaskellDB
10:58:52 <CosmicRay> I'll grant that both haskell and lisp have database support that is not all that great
10:58:53 <shapr> or even SQLObject in Python
10:59:14 <CosmicRay> well it depends on what he is after.
10:59:18 <CosmicRay> s/lisp/ocaml/
10:59:21 <shapr> HaskellDB is pretty close to awesome.
10:59:27 <CosmicRay> haskell and ocaml both mainly supoprt mysql and postgresql
10:59:34 <CosmicRay> anything else is difficult.
10:59:35 <shapr> With a bit of work it will be the best thing I've ever seen.
10:59:53 <CosmicRay> it still is limited by what we support in hsql
10:59:55 <CosmicRay> y0 heffalump
10:59:58 <CosmicRay> just looking for ya
10:59:58 <Heffalump> hiya
11:00:01 <Heffalump> oh, ok :-)
11:00:05 <Heffalump> can you wait 10 mins?
11:00:06 <tuomov> the biggest limiting factor is people who are two stubborn to even try anything that is considered "academic wanking"
11:00:07 <CosmicRay> stuff's uploaded.
11:00:10 <CosmicRay> yes.
11:00:11 <tuomov> s/two/too/
11:00:14 <shapr> It has SQLite support courtesy of stepcut 
11:00:21 * Heffalump heads home
11:00:23 <CosmicRay> oh right, sqlite also, sorry.
11:00:26 <CosmicRay> and odbc.
11:00:36 <CosmicRay> which is how I managed to get it to talk to progress 9.1
11:00:47 <CosmicRay> but it's not pretty and involves hacking the C layer
11:00:54 <shapr> And Alistair Bayley and Oleg wrote a win32 Oracle to Haskll binding that would probably plug into HaskellDB
11:01:02 <CosmicRay> it's not the fault of the hsql fols
11:01:12 <CosmicRay> it's just that the haskell database community is smaller than java's or perl;s
11:01:30 <shapr> HaskellDB is way elegant.
11:01:48 <shapr> I've wanted higher order queries for more than a decade.
11:01:57 <CosmicRay> last time I lokoed at it, it sounded like I had to futz with precompiling something for my database layout, which wasn't what I wanted
11:02:05 <tuomov> I've never used a db..
11:02:24 <CosmicRay> if one doesn't know what the database layout is in advance, it's hard to precompile something to it.
11:02:54 <shapr> There's recent work to let you declare the layout and dynload it with hs-plugins.
11:03:11 <tuomov> but I've been thinkin of some improvements to riot, and a proper db might be the preferred back-end
11:04:02 <shapr> tuomov: If you find any flakey bits in the HaskellDB tutorial, tell me and I'll fix 'em.
11:04:54 <Oejet> What is the easiest way to get the command line arguments from a Haskell program?  E.g.: run.exe arg1 arg2
11:05:39 <shapr> System.getArgs ?
11:07:33 <Oejet> shapr: Not quite.  This is a bit overkill: getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
11:07:50 <CosmicRay> shapr: I can see the utility of systems like that
11:08:01 <CosmicRay> shapr: I used one with Java in a former life.  Enhydra, I think it was.
11:08:32 <CosmicRay> shapr: but they seem to break down when the database design isn't known in advance, or can vary
11:08:47 <CosmicRay> so that's why I go in with hsql directly
11:08:57 <CosmicRay> we have some 300 tables that I query against
11:09:06 <Oejet> shapr: Thanks, getArgs was in System.Environment
11:09:08 <CosmicRay> the manual describing their layout is about 500 pages
11:09:15 <CosmicRay> and the one describing their relationships is about 200
11:09:24 <CosmicRay> I say "no thanks" to modeling all that :-)
11:10:52 <shapr> you don't have t
11:10:53 <shapr> to
11:11:03 <shapr> HaskellDB can ask your database and build its own model.
11:11:07 <CosmicRay> ah.
11:11:24 <CosmicRay> but that requires hs-plugins?
11:11:26 <shapr> nope
11:11:27 * Heffalump arrives
11:11:28 <shapr> that's standard
11:11:33 <CosmicRay> shapr: ah. 
11:11:39 <CosmicRay> shapr: that may work after all, then
11:11:48 <CosmicRay> shapr: because the other annoying thing is that I'm running this stuff on aix
11:11:52 <Heffalump> it can build its own model, but you then need to compile your code with the model it built
11:11:55 <CosmicRay> shapr: where hs-plugins is nowhere near working
11:11:59 <shapr> yeah, sad
11:12:47 <shapr> Oejet: if you want getOpts stuff, pesco has a nice alternative version.
11:13:12 <shapr> It's Pesco.Cmdline - http://www.scannedinavian.org/~pesco/
11:13:38 <ikegami--> hmm
11:13:39 * CosmicRay immediately bookmarks
11:13:51 <CosmicRay> he has lots of stuff in there I would like to steal :-)
11:14:11 <ikegami--> have you herd a good news that hs-plugins works on MS-Windows?
11:14:15 <skuggi_> how do i do powers with bases and exponents that aren't integers?
11:14:29 <ikegami--> (I wish)
11:15:01 <CosmicRay> the built-in function supports non-integral bases
11:15:20 <basti_> skuggi: if not, logarithmic.
11:15:41 <skuggi> CosmicRay: and what's the function called?
11:15:43 <skuggi> basti_: ?
11:15:46 <CosmicRay> skuggi: (^)
11:15:51 <Oejet> shapr: Thanks for the link.
11:16:15 <skuggi> CosmicRay: oh.. but i need to have it in the exponent :/
11:16:22 <basti_> observe a^b = e^ln(a^b) = e^(b*(ln a))
11:16:52 <skuggi> oh
11:17:28 <skuggi> i don't quite see how that helps though.
11:17:33 <Heffalump> @type (**)
11:17:34 <lambdabot> (**) :: forall a. (Floating a) => a -> a -> a
11:17:43 <skuggi> ah
11:17:43 <Heffalump> @type (^)
11:17:44 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
11:17:45 <shapr> @type faster
11:17:46 <lambdabot> bzzt
11:17:54 <Heffalump> @type more than shapr does
11:17:55 <lambdabot> bzzt
11:18:01 <shapr> :-P
11:18:09 <shapr> that's gonna be hard! I'm up to 1.5 billion chars!
11:18:12 <basti_> there it is but nevertheless you can always do it that way
11:18:31 <shapr> and down to 1.5 wrists.
11:19:03 <ikegami--> hehe
11:19:19 <shapr> CosmicRay: I think I should post all my haskell source code links either in your direction, or to some shared spot.
11:19:22 <Oejet> MegaMonad: Who writes faster, shapr or Heffalump?
11:19:23 <MegaMonad> Oejet: Heffalump: you need to *do* something with a faster one.
11:19:30 * shapr snickers
11:19:41 <shapr> I have no idea what that means, but it was coherent for once.
11:20:33 <shapr> CosmicRay: I'm tempted to implement your suggestion of having all known repos on my server, but only for Haskell sources.
11:20:51 <shapr> InForM workbench is little known, but massive and powerful.
11:20:56 <shapr> LPS too
11:21:06 <shapr> Lots of good Haskell code out there that most people don't know about.
11:22:24 <basti_> link lists? :)
11:23:02 <shapr> basti_: very punny
11:24:14 <basti_> i mean, how about collecting links to good haskell wares on some kind of list?
11:24:18 * Heffalump would like to make it known that MegaMonad annoys him.
11:24:28 <shapr> basti_: yeah, that's what I mean.
11:24:45 <shapr> But I'd also like to collect cache copies of the sources.
11:24:48 <basti_> ohok.
11:24:55 * Heffalump tries to decide whether to implement his new project with haskelldb or hsql
11:25:01 <shapr> HaskellDB!
11:25:03 <shapr> it's coool!
11:25:12 <Heffalump> I've used both for different things now.
11:25:15 <Heffalump> And I'm not sure which I prefer.
11:25:38 <Heffalump> I like the principle behind haskelldb, but I'm not sure if the hassle is worth it, especially since my preferred database location doesn't support a recent enough mysql.
11:27:08 * shapr wonders if PolyStar can be used for his road traffic analysis type tricks.
11:31:43 <shapr> Wow, this is cool. I wonder if it can be used to analyse network protocols.
11:33:19 <basti_> o0 shapr do you mean poly*
11:34:03 <shapr> yeah, that one.
11:34:25 <shapr> Greetz Ninja Jones.
11:34:37 <CosmicRay> Heffalump: anyway
11:34:46 <CosmicRay> Heffalump: have you received any upload notifications for haskell-http?
11:34:51 <Heffalump> yes, several :-)
11:34:58 <CosmicRay> Heffalump: did any of them fail?
11:35:02 <Heffalump> the last one did.
11:35:05 <Heffalump> cos it was already there
11:35:11 <CosmicRay> ok, that means I did remember to upload it earlier.
11:35:17 <Heffalump> right :-)
11:35:22 <shapr> basti_: looks to me like this could also be used to model board games.
11:35:23 <CosmicRay> that also means that what I uploaded will fail to build on the autobuilders
11:35:32 <Heffalump> because of the lack of ITP?
11:35:39 <CosmicRay> because I just uploaded haskell-devscripts, which now looks for *.cabal instead of Setup.description due to the change in cabal 0.4
11:35:41 <basti_> uhm
11:35:50 <Heffalump> ah, bugger.
11:35:54 <basti_> i just heard that term the first time and googled it up
11:36:04 <CosmicRay> so when it hits sid, just mv Setup.description HTTP.cabal, upload the build-dep to haskell-devscripts 0.5.4, and upload a -2
11:36:07 <CosmicRay> the ITP is different
11:36:13 <Heffalump> ok.
11:36:16 <shapr> It would be fun to compare Seidler von Catan with something like monopoly.
11:36:21 <CosmicRay> whether or not that's a problem depends on how anal ftpmaster is feeling next month
11:36:29 <CosmicRay> or whenever they get around to looking at the new queue next
11:36:42 <Igloo> shapr: Compare in what sense?
11:37:05 <CosmicRay> Heffalump: would you like a copy of what I uploaded now?
11:37:10 <CosmicRay> (this includes the above fixes)
11:37:18 <shapr> Igloo: I suspect the properties of canons that you seen in GÃ¶del, Escher, Bach also show up in the best board games.
11:37:18 <CosmicRay> this would be for the second upload which failed
11:37:42 <CosmicRay> Seidler von Catan == Settlers of Cattan?
11:37:44 <shapr> A Poly* flow graph should show some of that.
11:37:47 <shapr> CosmicRay: yup
11:37:57 <shapr> We have the origina German version.
11:37:58 <CosmicRay> good game.
11:38:11 <CosmicRay> shapr: we don't own the board game, but gnocatan works :-)
11:38:38 <shapr> IceHouse is my game addiction lately. I've been trying to find some way of making peano arithmetic into a fun game.
11:39:01 <CosmicRay> what's peano arithmetic?
11:39:02 <Heffalump> cosmicray: yes please.
11:39:14 <CosmicRay> Heffalump: ok, one minute.
11:39:25 <Heffalump> do you use darcs at all? :-)
11:39:37 <shapr> CosmicRay: doesn't really have to be peano, operating on church numerals would be the same.
11:39:39 <shapr> hiya timbod 
11:40:00 <CosmicRay> occasionally but I've found it too buggy for most stuff
11:40:05 <CosmicRay> Heffalump: I still use arch
11:40:15 <CosmicRay> shapr: I'm confused.  what do you mean by "peano" or "church numerals"?
11:40:29 <shapr> church numerals are numbers represented in lambda calculus.
11:40:41 <CosmicRay> huh.  well my guess on that was way off :-)
11:40:51 <shapr> You have two combinators, zero, and one more.
11:40:57 <Heffalump> 5 is represented by the function \f x -> f (f (f (f (f x))))
11:41:09 <shapr> One more is 'successor' usually called 'succ'
11:41:10 <CosmicRay> I was wondering if that was some Swedish way of refering to what we call Roman numerals :-
11:41:33 <shapr> That's why the recent IOHCC was call the Succ Zeroth IOHCC
11:41:56 <shapr> hiya funkmando 
11:42:04 <funkmando> hi there
11:42:07 <CosmicRay> Heffalump: sent.  use your same orig.tar.gz
11:42:12 <Heffalump> thanks.
11:42:12 <funkmando> how do you print quotes in Haskell?
11:42:16 <CosmicRay> togehter with this dsc and diff.gz to unpack
11:42:18 <CosmicRay> funkmando: \'
11:42:20 <CosmicRay> and \"
11:42:25 <funkmando> ah
11:42:25 <CosmicRay> err
11:42:27 <CosmicRay> \"
11:42:29 <funkmando> thanks muchly
11:42:39 <funkmando> wow
11:42:44 <shapr> wow what?
11:42:45 <funkmando> this is a big haskell channel
11:42:51 <funkmando> i thought this lang was dead
11:42:51 <funkmando> lol
11:42:56 <CosmicRay> nah
11:42:56 <shapr> I thought C was dead.
11:43:08 <CosmicRay> we're just taking over the world.  one pythoner at a time.
11:43:08 <Heffalump> I thought they abolished Bristol University.
11:43:14 <funkmando> haha
11:43:15 <funkmando> :P
11:43:22 <CosmicRay> I thought half of Europe was old.
11:43:40 <basti_> thats not age, its called history
11:43:51 <shapr> funkmando: anyway, lotsa good stuff here. You want the tour?
11:43:51 <CosmicRay> guess that's what I get for listening to someone I voted against :-)
11:44:01 <funkmando> shapr : sure
11:44:04 <shapr> Awright!
11:44:11 <CosmicRay> basti_: I know, I'm just ragging on rumsfeld
11:44:19 <basti_> ;)
11:44:22 <shapr> First on your left you'll notice the everpresent channel bot, lambdabot
11:44:30 <shapr> many useful features there
11:44:45 <shapr> Second you'll see the useful urls in the channel topic, which include the channel logs and the learning page.
11:44:55 <funkmando> cool
11:45:03 <funkmando> learning page for haskell or the channel? ;)
11:45:07 <shapr> Last but not least there's the Haskell Wiki with much useful information for every occasion.
11:45:13 <shapr> @wiki FundamentalConcepts
11:45:14 <lambdabot> http://www.haskell.org/hawiki/FundamentalConcepts
11:45:28 <CosmicRay> funkmando: for learning about the channel, we have MegaMonad :-)
11:45:31 <CosmicRay> @wiki MegaMonad
11:45:31 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
11:45:37 <funkmando> ahh what doesn't wiki know indeed
11:45:43 <CosmicRay> one might say that megamonad embodies the very essence of #haskell
11:45:52 <shapr> Ain't that scary?
11:45:57 <Lunar^> shapr: I am making a binding for FUSE
11:45:59 <CosmicRay> indeed :-)
11:46:24 <CosmicRay> megamonad does seem to hate java and love unicycles, though, so it can't be all bad.
11:46:26 <shapr> funkmando: here on #haskell we get everything from fourteen year olds looking for a challenge to the occasional Haskell 98 standard author.
11:46:31 <Lunar^> shapr: I'll try to see if I could make a DarcsFS then
11:46:33 <timbod> hi shapr - just lurking for now
11:46:51 <funkmando> hehe
11:46:54 <CosmicRay> Lunar^: how about a DarcsFS module that implements HVFS?
11:46:56 <shapr> Oh right, we have several unicyclists on #haskell too.
11:47:03 <shapr> Lunar^: that'll rock!
11:47:16 <Lunar^> CosmicRay: What's HVFS ?
11:47:23 <CosmicRay> Lunar^: http://quux.org/devel/missingh/html/MissingH.IO.HVFS.html
11:47:54 <Lunar^> CosmicRay: uh... my point is too see if I could track a /etc transparently
11:48:00 <shapr> funkmando: subjects covered here include how to break out of the C mindset, Generalizing Monads to Arrows, and designing your own unicycle.
11:48:14 <funkmando> shapr: i just finished C
11:48:14 <CosmicRay> Lunar^: oh, you meant a kernel module, not a haskell module?
11:48:17 <funkmando> did 2.5 months of it
11:48:20 <funkmando> and pointers kicked my ass
11:48:22 <funkmando> badly
11:48:36 <CosmicRay> ah, university students are also popular 'round here
11:48:37 <Lunar^> CosmicRay: FUSE is filesystem by userland programs
11:48:38 <CosmicRay> :-)
11:48:46 <CosmicRay> Lunar^: oh ho, that is immensely interesting
11:48:47 <shapr> Well, I can explain pointers to you if you really want.
11:48:50 <funkmando> popular, or common?
11:48:54 <CosmicRay> Lunar^: does it export an NFS or something?
11:48:56 <Lunar^> CosmicRay: Description: Filesystem in USErspace (development files)
11:48:57 <funkmando> shapr : a million people explained them to me
11:49:10 <funkmando> the definition just doesn't go in my head right
11:49:12 <CosmicRay> funkmando: I better not answer that, lest I be mobbed :-)
11:49:14 <shapr> I could make that a million and one.
11:49:21 <funkmando> you can try
11:49:29 <Lunar^> CosmicRay: I hope too finish and publish this binding soon
11:49:31 <mattam> there's a video somewhere explaining it
11:49:34 <CosmicRay> it really is good to have an idea of pointers
11:49:38 <shapr> funkmando: awright, you ever sent a letter?
11:49:40 <CosmicRay> even in a pointer-free language like haskell
11:49:43 <funkmando> shapr sure
11:49:55 <shapr> You gotta know the address of the person, yeah?
11:49:58 <CosmicRay> it gives you an understanding of what is going on in your machine that can be helpful
11:50:08 <funkmando> yes
11:50:18 <funkmando> and then u have the person themselves
11:50:30 <shapr> Same idea in a warehouse, you put something down and you write down where you put it.
11:50:33 <shapr> That's a pointer.
11:50:48 <shapr> tada!
11:50:52 <shapr> Any other questions?
11:51:05 <funkmando> hmm
11:51:06 <CosmicRay> & means "address of"
11:51:16 <CosmicRay> * means "go to the thing at this address"
11:51:37 <shapr> Let's say you parked your bike at the school somewhere.
11:51:50 <Heffalump> *(1+&CosmicRay) means go to CosmicRay's neighbour
11:51:53 <CosmicRay> so &funkmando could be "12435 Somestreet, Bristol"
11:51:55 <wilx> Hmm...
11:52:01 <wilx> @type (.)
11:52:02 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
11:52:05 <wilx> @type ($)
11:52:06 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
11:52:09 <Heffalump> as does (&CosmicRay)[1]
11:52:10 <mattam> i recommend that to anybody, knowing pointers or not: http://cslibrary.stanford.edu/104/
11:52:16 <shapr> Then you write on your hand &bike so you'll know where you put it.
11:52:35 <shapr> And when you want to ride it home, you go get your bike with *bike
11:52:38 <funkmando> yes
11:52:53 <CosmicRay> pointers are closely related to strings in c.
11:53:02 <Heffalump> and if you want to be sure it exists, you do if(bike) { ... }
11:53:07 <shapr> GruÃŸgott shevegen 
11:53:10 <CosmicRay> what people often call a string in C is really a pointer to the first character
11:53:24 <funkmando> and that character points to the next one?
11:53:26 <funkmando> like an array
11:53:27 <shevegen> hehe servus, muss aber für 2 stunden weg... cya in 2 hours :)  (idling now)
11:53:42 <CosmicRay> nope, the next one is derived by adding 1 to the address of the first one
11:54:01 <funkmando> ok
11:54:03 <funkmando> gotcha
11:54:10 <shapr> The only way you find the end of the string in C is to look for \0
11:54:17 <shapr> C strings end with a null byte.
11:54:23 <mattam> hopefully :)
11:54:33 <shapr> C is error-prone.
11:54:35 <Igloo> I know nothing about any haskell-http package
11:54:40 <shapr> I think that's the nicest thing you can say about it.
11:54:42 <funkmando> i was fine with C
11:54:47 <funkmando> until pointers and linked lists came in
11:54:56 <funkmando> then i got really far behind and pissed off with programming
11:55:01 <shapr> C is *not* programming.
11:55:16 <Heffalump> igloo: but we'll CC you about it anyway.
11:55:18 <shapr> C is more like making sandcastles with a buncha bits.
11:55:28 <CosmicRay> Igloo: I don't know why you were cc'd in that
11:55:31 <mattam> shapr: nicest would be 'C is a very powerfull language'
11:55:40 <Heffalump> I continued to CC him because CosmicRay started it :-)
11:55:42 <shapr> mattam: in the same way that electrons are very useful.
11:55:46 <CosmicRay> Heffalump: I did?
11:55:47 <CosmicRay> huh
11:55:50 <CosmicRay> that was silly of me
11:55:51 <Igloo> I don't mind, just answering the question  :-)
11:55:54 <CosmicRay> why did I do that? :-)
11:56:00 <Heffalump> your original question about ITPing did.
11:56:01 <mattam> sort of
11:56:07 <CosmicRay> huh.
11:56:10 <CosmicRay> well ok then :-)
11:56:13 <shapr> funkmando: Anyway, Haskell is way different from C, you might like it.
11:56:14 <Igloo> As it happens I might want one soon, anyway
11:56:16 <funkmando> wow i've never met a more friendly room,
11:56:30 <CosmicRay> funkmando: haskell is extremely different frmo C.
11:56:34 <Heffalump> want one what?
11:56:34 <mattam> it reminds me of the strange and powerfull device in some bad teen movie
11:56:36 <shapr> Hah, wait till you try to get us to *stop* talking!
11:56:38 <funkmando> shapr : yeah i like it so far
11:56:38 <CosmicRay> funkmando: in fact, haskell is probably as different you can get from C
11:56:48 <funkmando> im doing java aswell
11:56:56 <CosmicRay> funkmando: you have my sympathy
11:57:04 <Heffalump> I'm not friendly! I don't think Bristol university exists!
11:57:34 <funkmando> what's wrong with java? lol
11:57:41 <funkmando> and bristol uni does exist!
11:57:42 <funkmando> :P
11:57:56 * CosmicRay wonders why so many brits dislike bristol and leeds
11:58:06 <funkmando> bristol is not very nice :(
11:58:47 <Igloo> want a haskell-http package
11:59:35 * Igloo tries to remember where that categorised Debian package thing is
11:59:54 <funkmando> i come from southwest though (Devon), that's a cool place
12:00:59 <shapr> poo
12:01:39 <shapr> Lunar^: a FUSE binding would be *perfect* for Fermat's Last Margin
12:01:45 <Heffalump> funkmando: which bit?
12:01:58 <funkmando> of Devon ? about 7 miles from Exeter
12:01:59 <shapr> maybe 8 || ?
12:02:14 * shapr gives up on the bitmask jokes
12:02:14 <Heffalump> oh, where? (my girlfriend lives just near St James' Park)
12:02:29 <funkmando> a village called sandford
12:02:34 <funkmando> which is 2 miles from a town called crediton
12:02:39 <funkmando> which is 7 miles from exeter
12:02:39 <Heffalump> ah, I know Crediton.
12:02:40 <funkmando> phew
12:02:46 <Heffalump> but not Sandford
12:02:50 <funkmando> wow, it's a small world
12:03:04 <shapr> Hey this sounds like the place I lived in Tennessee. You could only explain it by being several steps removed from Knoxville.
12:03:13 <Heffalump> well, I know of it. I'm not sure if I've even driven through it, actually.
12:04:48 <Lunar^> shapr: Cool, that's another motivation
12:04:58 <Lunar^> shapr: It'll be really slow though
12:04:58 <shapr> timbod: hey, Is that your post about "Haskell v. Java Unfair?" on LtU?
12:05:10 <shapr> Lunar^: I don't need speed.
12:05:11 <Lunar^> shapr: a lot of conversions between CString and String
12:05:15 <Lunar^> me neither
12:06:33 <shapr> I would like to figure out a way to keep the wiki interface and still commit a single patch for related edits.
12:09:22 <shapr> funkmando: I could tell you what's wrong with Java, but it might be painful to hear.
12:09:48 <shapr> Anyway, there isn't any perfect language. It's best to know a bunch of different languages so you can use what best fits the problem at hand.
12:10:34 <Heffalump> so go on, what is wrong with Java?
12:11:07 <shapr> lack of tail call optimization ;-)
12:11:55 <shapr> I wish it gave direct access to coroutine based threading and allowed you to subclass that to your liking.
12:12:29 <shapr> Java's type system is fragile, and people don't use it much anyway.
12:12:51 <Heffalump> Haskell doesn't offer any more guarantees of tail call optimization than Haskell, does it?
12:12:55 <Heffalump> s/Haskell/Java/2
12:13:19 <shapr> I don't know about TCO guarantees, but I do know that the JVM spec can't handle TCO.
12:13:45 <mattam> i've heard the last versions do
12:14:04 <Heffalump> the bytecode format can't, but JITs could optimise things to tail calls
12:14:11 <shapr> The Java standard libraries are have a lot of duplication, especially in J2EE.
12:15:05 * musasabi
12:15:16 <shapr> No first class functions, unless you wrap them up in an object.
12:16:10 <shapr> On the good side, Java has made GC common in the industry.
12:16:17 <shapr> Down with malloc and free!
12:17:31 <shapr> Heffalump: Shall I point out the flaws of Haskell for a balanced breakfast? 
12:17:33 * shapr grins
12:17:41 <Heffalump> s'ok :-)
12:20:42 <shapr> I really hope I can get this spoken concatenative programming language idea working soon.
12:20:50 <shapr> I think that would be a nifty new thing in PLs
12:22:29 <Heffalump> you what?
12:27:39 <timbod> shapr - yep that was my post
12:34:36 <shapr> timbod: have I already mentioned that Haskell does compile-time dynamic typing? :-)
12:36:35 <timbod> Do you mean Dynamic, Typeable, etc?
12:37:20 <shapr> Nah, I mean that you don't have to declare the types of your code ahead of time.
12:37:48 <shapr> Type inferencing acts like python's dynamic typing applied at compile-time.
12:38:07 <timbod> Of course. (I have written a moderate amount of haskell)
12:38:41 <Heffalump> oh, bugger. No haskell-hsql for woody.
12:38:55 <timbod> It's just dabbling mostly - I wrote an OpenGL viewer for the ant simulator as part of last years ICFP.
12:39:07 <CosmicRay> Heffalump: huh?
12:39:14 <shapr> neato
12:40:08 <Heffalump> I mean that it's only in sid..
12:41:47 <CosmicRay> of course
12:41:56 <CosmicRay> nothing has been added to woody since its release
12:42:03 <CosmicRay> it's the Debian Way
12:42:16 <Heffalump> well, the Debian Way sucks :-)
12:42:27 <Igloo> It could have been in Haskell-Unsafe, though
12:42:30 <Heffalump> but more to the point there's no backport, AFAIK.
12:43:06 <Heffalump> (I don't really mean that the policy of not adding to woody sucks, but the fact that woody is ancient does)
12:43:18 <CosmicRay> i agree
12:43:22 <pesco> Greetings.
12:44:04 <CosmicRay> pesco!
12:44:15 <CosmicRay> I have just been browsing your code.
12:44:40 <pesco> `:)
12:44:50 <CosmicRay> I almost grabbed your regexp module
12:45:01 <pesco> Why almost?!
12:45:02 <Igloo> Oh, what does it do?
12:45:04 <pesco> ;-P
12:45:11 <CosmicRay> pesco: because it still uses posix regexps
12:45:17 <CosmicRay> pesco: thus no support for \w \d etc
12:45:29 <CosmicRay> Igloo: perl-like operators for regexps
12:45:30 <pesco> CosmicRay: Oh, I see.
12:45:37 <CosmicRay> ie, no text.regexp.compile crap
12:45:56 <Igloo> Oh, so it's a preprocessor?
12:46:07 <pesco> Igloo: No, it's a wrapper.
12:46:14 <CosmicRay> no, he defines functions
12:46:31 <CosmicRay> (=~) and stuff
12:46:51 <Igloo> Ah, I see, so like (=~) :: String -> String -> [String]?
12:46:52 <CosmicRay> pesco: I will probably grab cmdline once I figure out how it works :-)
12:47:15 <pesco> Igloo: Kind of.
12:47:28 <Igloo> But wrapping Test.Regex?
12:47:32 <pesco> Yes.
12:47:45 <CosmicRay> Igloo: he makes string and the Re type members of a class, so that a string can be cmopiled on the fly, or one can use a precompiled re
12:48:18 <pesco> CosmicRay: man 3hs Pesco.Cmdline!
12:48:43 * Igloo will have to look at it some time
12:48:44 <CosmicRay> I know :-)
12:49:00 <CosmicRay> you are using some extensions I'm not familiar with, is all
12:49:12 <pesco> Ah, right.
12:49:32 <CosmicRay> pesco: btw there is also another regex thing at http://repetae.net/john/computer/haskell/hsregex/
12:49:36 <CosmicRay> you ever seen it?
12:49:42 <pesco> No.
12:50:10 <CosmicRay> he has his own binding to libpcre
12:50:33 <CosmicRay> but only some of the operators you define
12:50:54 * Igloo has a pure Haskell (probably high constant factor) implementation if you're interested
12:51:00 <CosmicRay> !
12:51:03 <pesco> Ah!
12:51:06 <CosmicRay> of perl-compatible regular expressions?
12:51:20 <pesco> Igloo: What do you mean by "high constant factor"?
12:51:25 <Igloo> Only BREs and EREs are complete I think
12:51:38 <Igloo> pesco: Slow, but not asymptotically slow
12:51:51 <pesco> CosmicRay: Damn, firefox keeps exploding!
12:51:55 <pesco> Igloo: oic
12:51:59 <CosmicRay> pesco: heh
12:52:05 * Igloo would like to complete PCREs, but needs more tuits
12:52:26 <Igloo> (and obviously leaving out things like the arbitrary code parentheses)
12:52:41 <Heffalump> go on, implement a perl interpeter in Haskell
12:52:48 <pesco> Haha!
12:52:49 <CosmicRay> hah
12:52:52 <bourbaki> moin
12:52:56 <Igloo> Am I allowed to use system?  :-)
12:53:08 <Igloo> Does libpcre just not support them, incidentally?
12:53:13 <CosmicRay> Igloo: only if you write it yourself using only a list of bools :-)
12:54:13 <Heffalump> gah, cabal in haskell-unsafe is 0.1
12:54:18 <CosmicRay> pesco: btw, you don't need <pre> to lay out your website.  you need Gopher!
12:54:28 <CosmicRay> Heffalump: perhaps that's because cabal is in sid? :-)
12:54:36 <Heffalump> not much use on woody :-)
12:54:49 <Heffalump> I'd build all these packages myself, but 'm actually trying to get something done here.
12:54:55 <pesco> CosmicRay: Good call! What do I do?! (Gopher was before me!)
12:55:46 <CosmicRay> pesco: quux.org/Software/Gopher, and/or apt-get install pygopherd
12:55:57 <Igloo> Someone should write something to autobackport a set of packages, with a script for each that can do things like fiddle the build-deps
12:56:05 <Heffalump> igloo: right.
12:56:17 <CosmicRay> pygopherd will conveniently render things as, basically, HTML that looks like your page, if accessed with a browser
12:56:23 <Heffalump> I think we (as Debian Haskell package maintainers, assuming I do become a DD) should do that for sarge once it releases.
12:56:30 <CosmicRay> pesco: you can create a .abstract file for every file in your directory, and it will show up as a description
12:56:45 <Heffalump> (actually properly maintain a up-to-date set of haskell packages that will run with sarge)
12:56:49 <CosmicRay> Heffalump: do I hear you volunteering? :-)
12:56:54 <Heffalump> probably, yes.
12:56:55 * Igloo thinks it should be done ASAP
12:57:01 <CosmicRay> Heffalump: in that case, good idea :-)
12:57:02 <Heffalump> that's possible too.
12:57:04 <Igloo> :-)
12:57:11 <Heffalump> but I'm not volunteering ASAP>
12:57:31 <pesco> Heffalump: Why not put that up as a challenge on the web? "Implement a Perl interpreter in Haskell. Maintain your sanity during the process."
12:57:37 <Igloo> I'd say as soon as sarge releases we won't need it for a bit except we might have a 6.2.2-6.4 divide
12:57:45 <pesco> CosmicRay: Wow, thanks! ;-P
12:58:12 <CosmicRay> pesco: you will have the pleasure of being indexed by Veronica-2, from gopher.floodgap.com!
12:58:28 <CosmicRay> pesco: there is also a gopher mailing list
12:58:37 <CosmicRay> pesco: gopher@complete.org, subscribe at gopher-request@complete.org
12:58:44 <pesco> Woo, I'm discovering the Internet!
12:58:45 <CosmicRay> and pygopherd is on my "things to port to haskell" list :-)
12:58:53 <CosmicRay> hehe
12:58:59 <shrimpx> hard to implement a perl interpreter when perl IS its implementation :)
12:59:03 <basti_> this poly* looks like kabbala to me
12:59:27 <pesco> basti_: ?
12:59:37 <basti_> http://www.cee.hw.ac.uk/DART/software/PolyStar/FAQ.html
12:59:44 <basti_> the examples are most bizarre
12:59:46 <CosmicRay> pesco: the pygopherd version up at quux.org is a little outdated due to my other lethargy, but you can get a current version usable on any OS from http://ftp.debian.org/debian/pool/main/p/pygopherd
13:00:03 <CosmicRay> pesco: pygopherd also automatically serves up data as WAP for mobile phones
13:00:14 <pesco> Neet.
13:00:33 <Heffalump> I was thinking of doing it for sarge on the basis that there'd then be some breathing room.
13:00:54 <Heffalump> who are the Haskell package maintainers? You, CosmicRay, Syntax?
13:01:06 <shapr> michaelw
13:01:12 <Heffalump> is he still active?
13:01:12 <shapr> he still has c2hs
13:01:15 <Heffalump> right
13:01:18 <CosmicRay> and is exntensible by writing small bits of python, or with a cgi-like mechanism
13:01:19 <shapr> not active though.
13:01:22 <Igloo> He's inactive AFAIK
13:01:28 <CosmicRay> pesco: also the slowness of quux.org is due to my dsl, not gopher
13:01:40 <Igloo> ibid maintains something written in Haskell I think
13:01:44 <Igloo> bnfc or something?
13:01:49 <shapr> yeah
13:02:03 <Igloo> Marvin was packaging gtk2hs a while ago, but haven't heard from him for a bit
13:02:55 <CosmicRay> pesco: try http://quux.org/pygfarm/dict.pyg
13:03:44 <shapr> hej cm_ 
13:04:45 <pesco> CosmicRay: Cool, many dictonaries?!
13:04:51 <CosmicRay> 4 dozen or so
13:04:59 <Heffalump> we should beat Duncan into submission and make him switch codes.
13:05:02 <CosmicRay> it uses my dictclient library to talk to a local dictd server
13:05:19 <pesco> Hmmm.
13:07:34 <shapr> basti_: I think Poly* r0xx
13:07:42 * ibid appears
13:07:53 <ibid> you called me? ;)
13:08:09 <CosmicRay> nah, they wanted ibot :-)
13:08:20 <ibid> what? :)
13:08:25 <CosmicRay> heh
13:08:36 <CosmicRay> just messin with ya
13:08:38 <shapr> Like I said, I want to try Poly* for modeling US traffic light vs Swedish roundabout and other kinds of vehicle traffic. I also want to see it's good for modeling boards games. Any other ideas?
13:08:39 <ibid> yaeh, bnfc
13:08:53 <ibid> used to maintain a lot of haskell stuff
13:09:02 <ibid> at least in the contemporary scale :)
13:09:28 <shapr> I wonder.. has capability security met pi-calculus already?
13:09:50 <shapr> Is there a separate calculus for capabilities?
13:11:37 <CosmicRay> dammit, why is pesco the only one that actually implements substitutions in regexps?
13:11:54 <CosmicRay> ok pesco, I'm taking yours :-)
13:12:13 <CosmicRay> pesco: oh, also pygopherd can serve up .zip files as filesystems
13:12:30 <CosmicRay> I intend to port that feature to HVFS in Haskell
13:12:34 <pesco> CosmicRay: My pleasure. :)
13:13:04 <CosmicRay> pesco: hmm, what license do you use?
13:13:26 <pesco> I don't do licensing.
13:13:35 <CosmicRay> ah.
13:13:45 <pesco> I publish. You use.
13:13:48 <CosmicRay> well that means I can't take yours, because it will be illegal for debian to distribute
13:14:17 <CosmicRay> it sounds like you want the BSD license :-)
13:14:22 <pesco> Poor Debian.
13:14:38 <CosmicRay> actually it is copyright law that does this
13:14:45 <CosmicRay> debian is just following it
13:15:16 <pesco> *shrug* Then Debian should "steal" my code if it really wants to and see if I sue them! Hah!
13:15:19 <CosmicRay> pesco: how's this: http://www.opensource.org/licenses/mit-license.html
13:15:21 <CosmicRay> heh
13:15:48 <pesco> Actually, MIT is pretty close to a "cleptocratic license" the way I'd like it.
13:15:59 <Heffalump> why don't you just say your stuff is PD?
13:16:10 * pesco shrugs.
13:16:13 <pesco> I don't feel like it.
13:17:13 <pesco> "It's mine, but if you manage to get your hands on it, keep it for Christ's sake!"
13:17:13 <CosmicRay> you realize that without saying that people can do tat, the only people that will use your software are: 1) w4r3z d00dz, and 2) people that don't care if they really are stealing code? :-)
13:17:21 <Heffalump> oh well, it's your stuff :-)
13:17:33 <pesco> CosmicRay: I've heard about that.
13:17:38 <CosmicRay> pesco: that's great
13:17:44 * Heffalump makes a mental note not to write anything he wants to release that relies on it, though.
13:18:14 <CosmicRay> pesco: if you just wrote "I hereby release this software into the public domain.  You are free to do whatever you like with this source code." in the file
13:18:19 <CosmicRay> that would do it.
13:18:51 <pesco> CosmicRay: What if I write what I quoted above on the webpage?
13:19:14 <Igloo> That might just about make it usable
13:19:20 <Igloo> It wouldn't make it distributable
13:19:25 <Igloo> Or modifiable
13:19:41 <CosmicRay> what igloo said.
13:19:47 <Heffalump> putting it on the web without explicitly stating conditions probably makes it usable in itself
13:20:33 <CosmicRay> I believe that something like this does it: I grant everyone everywhere unlimited irrevocable permission to
13:20:33 <CosmicRay> make and distribute complete and/or partial copies of this work
13:21:04 <pesco> But I don't want such an ugly sentence on my pretty webpage, let alone in my pretty code.
13:21:22 <CosmicRay> pesco: put it at the bottom of your file amidst some latex treachery :-)
13:21:25 <Igloo> Saying it on IRC would suffice, it's just harder to prove later (AIUI)
13:21:28 <pesco> I realize this is a problem. I'm looking forward to a solution.
13:21:30 <Heffalump> I'd expect "Thsi stuff is in the public domain" would do.
13:21:39 <Heffalump> on the web page, and preferably in each source file
13:21:49 <CosmicRay> Heffalump: I was just looking around about that, and the unfortunate reality is that public domain law is not globally standardized
13:22:01 <CosmicRay> pesco: you could create a file "please-use-me.txt" and put it in there
13:22:03 <Heffalump> I doubt that matters.
13:22:14 <CosmicRay> Heffalump: it does to debian, because we distribute globally
13:22:29 <Igloo> I'm sure there is PD stuff in Debian
13:22:40 <Heffalump> can you give an example of where "This is in the public domain" wouldn't be sufficient for one of us to take it and relicense it as BSD?
13:22:41 <pesco> You already said that putting the stuff up on a public webpage pretty much implies my consent in you using it.
13:22:43 <CosmicRay> Igloo: surprisingly little
13:22:54 <Igloo> >0, though
13:22:56 <Heffalump> pesco: yes, but not distributing it
13:23:03 <Heffalump> hence my unwillingness to create software I want to release with it
13:23:09 <pesco> Since the webpage is public, it would implies my consent with everyone using it.
13:23:13 <Heffalump> (and other IANALs might disagree with me on that)
13:23:15 <CosmicRay> Igloo: most of it was data files that were removed because nobody could prove they were legitimately PD's
13:23:26 <Heffalump> but you could, for example, withdraw that consent by taking the webpage down
13:23:27 <CosmicRay> pesco: using it, yes.  copying it?
13:24:38 <Heffalump> the key point is that we need documented and irrevocable consent to use and copy it.
13:25:02 <Heffalump> I believe that "This is in the public domain" is sufficient for this, but CosmicRay seems to disagree.
13:25:05 <pesco> Oh! Why didn't you say that. Of course you can copy it, feel free!
13:25:27 <Heffalump> ok. So in principle we now have IRC logs as evidence :-)
13:25:34 <pesco> Good!
13:25:37 <pesco> :-)
13:25:50 <CosmicRay> from someone on an anonymous dsl line claiming to be pesco... :-)
13:26:09 <pesco> Yeah, it's complicated...
13:26:34 <Heffalump> oh, and presumably we are allowed to modify it too, and to pass those rights on to othes?
13:26:34 <pesco> To use something posted on an anonymous webpage claiming to be Sven Moritz Hallberg.
13:26:37 <CosmicRay> http://en.wikipedia.org/wiki/Wikipedia:Public_domain_resources
13:26:39 <Heffalump> s/othes/others/
13:26:43 <CosmicRay> here is what the problem with "public domain" is
13:26:58 <CosmicRay> japan and those darn commonwealth countries
13:28:03 <Heffalump> I think you are misunderstanding what Crown copyright is about.
13:28:05 <pesco> Heffalump: If by modifying you don't mean flipping bits on my harddrive or the website, sure, why not?
13:28:12 <CosmicRay> Heffalump: probably.  I have no idea what it is.
13:28:22 <CosmicRay> I guess I'll have to ask on debian-legal about this.
13:28:30 <Heffalump> And since pesco is not in Japan, his declaration of public domainness should be fine, and should also apply in Japan.
13:28:40 * Igloo turns on the long-distance directional electromagnet
13:28:42 <Heffalump> (if he is declaring that, which actualy I don't thin khe is :-)
13:28:47 <Heffalump> s/is/was/
13:28:56 <CosmicRay> Heffalump: well the problem is that such a declaration holds no meaning in japan
13:29:02 <Heffalump> Crown copyright basically means "the government made it so the government ownsit"
13:29:10 <CosmicRay> however if he used that sentence I posted, it would be fine :-)
13:29:24 <Igloo> Cos: If you PD something, I take a copy and release it as GPL, is it considered GPL in Japan or am I considered a criminal?
13:29:33 <Heffalump> cosmicray: As I read it, something in Japan could be declared 'public domain' without granting the same rights as one would expect in the rest of the world.
13:30:02 <Heffalump> However, since he would be PDing it elsewhere, I don't think he can then claim commercial rights in Japan.
13:30:03 <CosmicRay> Heffalump: hmm, I guess that is possible.
13:30:15 <pesco> "This is all mine! Take it and your soul shall be damned forever. But you can keep it and do with it whatever you want."
13:30:15 <CosmicRay> Igloo: I guess it depends on which hunch is correct.
13:30:30 <CosmicRay> ahh, the License To Hell
13:30:30 <pesco> Is that good enough for debian?
13:30:34 <CosmicRay> heh
13:30:35 <pesco> Yeas!
13:30:38 <Igloo> I was talking about a country that had no concept of PD, which I thought existed
13:30:39 <Heffalump> I think that's good enough.
13:31:07 <pesco> Cool! I think we have a deal.
13:31:09 <Heffalump> unless damnation of souls is a violation of the social contract somehow.
13:31:12 <CosmicRay> heh
13:31:16 * CosmicRay e-mails debian-legal
13:31:17 * pesco laughs.
13:31:24 <Igloo> I was just wondering about discrimination against people with no soul
13:31:25 <Heffalump> discrimination against people who don't want damned souls, I guess.
13:31:26 <CosmicRay> I will paste one of his earlier statements that didn't include that 
13:31:30 <CosmicRay> :-)
13:31:35 <Heffalump> but, the damnation of souls isn't transitive.
13:31:49 <Heffalump> So I shall accept the damnation on myself, and then offer it on to everyone else, via the medium of pesco's website.
13:31:59 <Heffalump> (it being the code, not the damnation)
13:32:08 <Heffalump> the sacrifices I make for Debian...
13:32:13 <pesco> *g*
13:32:25 <Igloo> Don't be silly, your soul's been damned for /years/...
13:32:56 <Heffalump> igloo: bah. I was hoping you'd have forgotten that.
13:33:30 <pesco> Heffalump: Will it also suffice to include the notice on the webpage for now and only possibly in the next version of the code?
13:33:50 <Heffalump> the bit about damnation?
13:33:58 * CosmicRay e-mails
13:34:00 <pesco> Yes, including that.
13:34:02 <Heffalump> I think it's ok.
13:34:05 <CosmicRay> heh
13:34:12 <pesco> Wonderful!
13:34:23 <Heffalump> even if the damnation matters, the fact that it's not transitive offers an easy get out
13:34:52 <Heffalump> cos I could in principle take your stuff and distribute it myself without damning other people's souls.
13:34:54 <pesco> I fear that transitiveness of damnation might not fall under earthly jurisdiction.
13:35:10 <CosmicRay> pesco: if the notice disappears, then we stop having the legal right to use future versions of code, and thus we would have to either: 1) keep the old version, 2) fork it, or 3) drop the package
13:35:31 <pesco> CosmicRay: OK, I'll try to make sure it doesn't.
13:35:36 <CosmicRay> ok :-)
13:35:40 * CosmicRay hides rm from pesco
13:35:45 <CosmicRay> or C-k if he uses emacs.
13:36:03 <pesco> What if the notice says "good forever" and you made a backup?
13:36:03 * Heffalump suggests you vary what gets damned with each release.
13:36:15 <pesco> Heffalump: Very good suggestion.
13:36:18 <CosmicRay> haha
13:36:19 <Heffalump> I'm not sure you can legally sign away your rights over future works.
13:36:24 <Heffalump> s/sign/give/
13:36:30 <CosmicRay> pesco: it would be good forever for whatever was there then
13:36:34 <Heffalump> without there being some contract, which would require us to pay you.
13:36:38 <Heffalump> (in some way)
13:36:46 <pesco> Hm. I see.
13:36:49 <Heffalump> but you can certainly give away stuff that already exists.
13:37:15 <CosmicRay> I hereby grant you the right to distribute and use all future Microsoft source code.  This offer is good forever.
13:37:16 <CosmicRay> there.
13:37:42 <pesco> Goil.
13:37:50 <CosmicRay> and we now know that microsoft soruce code sucks because of the poor showing of people taking advantage of this offer :-)
13:37:55 <CosmicRay> hello nsh
13:38:21 <CosmicRay> doggone it
13:38:23 <CosmicRay> I hate phone companies
13:38:27 <CosmicRay> SBC trying to buy AT&T.
13:38:39 <Heffalump> aren't SBC a baby bell?
13:38:41 <CosmicRay> have we forgotten why SBC was created in the first place, people?!!!
13:38:43 <CosmicRay> yes!
13:38:48 <Heffalump> oh dear..
13:39:06 * nsh joins phone company hateage
13:39:48 <CosmicRay> there was a phone guy here today.  was all confused about why one particular number kept making calls that last about 2 minutes, right after another.
13:39:55 <CosmicRay> IT'S A FSCKING FAX MACHINE!  THAT'S WHAT IT DOES!
13:40:06 * Heffalump is confused about how to build HSQL manually.
13:40:07 <CosmicRay> argh.
13:40:15 <Heffalump> via the cabal description.
13:41:10 <CosmicRay> uh oh.
13:41:38 <CosmicRay> couldn't you just build it manually with the makefile? :-)
13:42:04 <Heffalump> I'm not sure how I'd cleanly register and unregister it with ghc then. And I'm having trouble persuading that to understand where mysql lives.
13:42:09 <Heffalump> But I think I'm making progress now.
13:42:15 <CosmicRay> ah
13:43:43 <Heffalump> wahey.
13:44:16 <SyntaxNinja> cabal?
13:44:19 <Heffalump> the fact that the Debian package requires all libraries is a pain.
13:44:44 <CosmicRay> Heffalump: patches accepted.
13:44:54 <Heffalump> SyntaxNinja: how does one pass options to hsc2hs with cabal?
13:45:03 <Heffalump> cosmicray: you'd accept a patch that made it into 5 binary packages?
13:45:07 <SyntaxNinja> Heffalump: not easily
13:45:17 <Heffalump> ok, so manually running hsc2hs was a good work around ;-)
13:45:20 <CosmicRay> Heffalump: if you can do it in a usable fashion, yes.
13:45:29 <CosmicRay> and it has to setill have one source package
13:45:33 <Heffalump> well, it'd be like libdbi-perl and libdbd-mysql-perl
13:45:34 <SyntaxNinja> but if there are options that make sense to pass through, which can be performed while keeping the description file the same, then that would be cool.
13:45:36 <Heffalump> yes, it would
13:45:53 <Heffalump> SyntaxNinja: well, it needed a -I option passed through. Which was already been given to ghc.
13:46:04 <Heffalump> so perhaps a general list of directories for includes would be helpful.
13:46:05 <SyntaxNinja> you can always just call it before you invoke main :)
13:46:15 <Heffalump> true :-)
13:46:35 * Heffalump isn't hugely familiar with the concept of just writing a program to do it rather than using the description file.
13:46:55 <SyntaxNinja> hopefully we can help out with hooks. what you SHOULD be able to do is override the hsc2hs preprocessor with one of your own
13:47:06 <SyntaxNinja> but if there are options we should be passing through that GHC is already getting, let me know
13:47:08 <SyntaxNinja> bbiab
13:47:10 <wolfman8k> hello
13:47:19 <Heffalump> well, this was in options-ghc
13:59:02 <wolfman8k> how important really is type inference?
13:59:08 <wolfman8k> to a programming language i mean
13:59:21 <CosmicRay> I think it's one of the nicest things about haskell
13:59:34 <CosmicRay> strong static typing without it is, well, java
13:59:36 <CosmicRay> and painful.
14:01:15 <SyntaxNinja> CosmicRay: I seldom use type inference myself.
14:01:42 <CosmicRay> I find it useful, even in things like literal numbers
14:02:12 <CosmicRay> it complements type classing and operators-as-functions nicely
14:02:35 * Heffalump thinks SyntaxNinja probably uses it a lot
14:02:39 <Heffalump> Just not for top-level declarations.
14:02:53 <Heffalump> if you really annotate every let binding and where clause with types, I'd be impressed
14:03:00 <CosmicRay> yeah, I only declare a type for those about 20% of the time
14:03:18 <CosmicRay> when I do, it's usually a reminder to myself because the type is non-obvious or weird
14:03:21 <CosmicRay> and debugging is tricky
14:05:23 <shapr> wolfman8k: another cool trick is to hack on your code till it works, then come back and add type sigs to your top level functions to convince yourself that you really understand your code.
14:05:38 <shapr> You'd be surprised how often the type signatures aren't what you expect.
14:05:38 <SyntaxNinja> Heffalump: right, for top-level bindings
14:06:46 <shapr> The exercise of adding top-level sigs taught me a lot about the type system. It also taught me that typeclasses can give code that dramatically change behaviour when type signatures are changed.
14:08:38 <shapr> wolfman8k: did you get Yampa Arcade built?
14:08:43 * musasabi
14:11:25 <wolfman8k> shapr: 
14:11:27 <wolfman8k> shapr: no
14:12:48 <shapr> musasabi: ?
14:13:30 <shapr> wolfman8k: at the latest I'll build it this weekend.
14:14:02 <wolfman8k> hehe, "rebooting" emacs :D
14:14:35 <wolfman8k> bbiab
14:47:40 <pesco> (Wow, I am _so_ good. My website _always_ validates!)
14:49:31 <wolfman8k> that still doesn't guarantee that it's correct :P
14:49:54 <Pseudonym> No, but it's like having your Haskell code type check cleanly.
14:50:00 <Pseudonym> It gets you most of the way there.
14:50:35 <monochrom> If your website validates, you know it won't crash a correct browser.
14:50:57 <Pseudonym> Right!
14:51:08 <monochrom> You probably also know that you haven't forgot an end tag leading to run-away table/comment/bold.
14:52:03 <monochrom> Then again my second last point is probably moot.  1. a correct browser crashes on nothing.  2. there is no correct browser.  :D
14:52:34 <wolfman8k> if a browser crashes on anything then it totally sucks the sausage
14:53:23 <pesco> Hah! Of course I do not rely on The Validator for correctness of my webpage, but on my superiour XHTML skills in the first place! Validation is merely a comforting assurance that the W3C has not changed specs!
14:55:11 <pesco> "sucks the sausage" :)
14:56:25 <pesco> My Firefox totally sucks the sausage, lately.
14:57:26 <monochrom> My firefox doesn't.
14:57:45 <Pseudonym> My firefox can beat up your firefox.
14:58:00 <pesco> I suspect my old GTK+ version.
14:58:34 <pesco> I wanted to run a big "upgrade firefox and all his dependencies" but X failed to build!
14:58:48 <CosmicRay> my konqueror can conqueror it
14:58:54 <monochrom> don't build. get binary packages.
14:58:58 * CosmicRay smells a bsd user in the vicinity
14:59:03 <CosmicRay> either that or gentoo
14:59:25 <pesco> monochrom: Bah! I want it to build. It has always worked.
14:59:33 <pesco> CosmicRay: Gentoo.
14:59:36 <CosmicRay> ah ha.
14:59:53 <CosmicRay> my apt-get can really beat up portage :-)
14:59:56 <monochrom> perhaps you need to upgrade to ghc 6.2.2 for building X.
15:00:03 <pesco> Haha! :)
15:00:05 <CosmicRay> upgrade firefox and all its dependencies takes about 20 seconds here :-)
15:00:13 <CosmicRay> monochrom: heh
15:00:46 <wolfman8k> someone should port mozilla to haskell
15:00:59 <wolfman8k> would probably run even faster then in c++ thanks to lazy evaluation
15:01:01 <wolfman8k> or not :)
15:01:26 <CosmicRay> wolfman8k: segfaults: fewer
15:01:30 <CosmicRay> wolfman8k: stack overflows: more
15:01:52 <CosmicRay> security: unchanged due to use of unsafePerformIO
15:02:05 <CosmicRay> :-)
15:02:05 <wolfman8k> why would you need unsafePerformIO?
15:02:13 <CosmicRay> wolfman8k:think about it.
15:02:22 <CosmicRay> wolfman8k: if there was one function that would be the favorite of mozilla developers
15:02:23 <pesco> The Web is unusable anyway, or so I've heard. ;-)
15:02:26 <CosmicRay> wolfman8k: that one has to be it.
15:02:53 <wolfman8k> hm... this must be some joke that requires intimate knowledge of the mozilla code in order to get :/
15:10:56 * boegel says 'hi'
15:11:03 * Pseudonym doesn't
15:11:25 * monochrom says 
15:11:41 * boegel laughs
15:11:47 * pesco leaves
15:13:05 * boegel scratches his head
15:13:19 <Pseudonym> Ah, another person who doesn't get (A -> B) <-> (not A \/ B)
15:13:34 <monochrom> Cool
15:14:47 <monochrom> Where is the root of his problem.  Does he accept (false->x) <-> true ?
15:16:11 <Pseudonym> I think it's an intuition thing.
15:16:36 <Pseudonym> I used my age old explanation, and he gets it now.
15:16:50 <Heffalump> you the man!
15:16:50 <monochrom> Intuition is the result of brainwashing.
15:16:57 <Pseudonym> Yes, I the man.
15:17:09 <Pseudonym> This is the way I remember it:
15:17:15 <Pseudonym> "If you keep talking, then I will hit you."
15:17:25 <Pseudonym> All threats of violence are for educational purposes only.
15:17:48 <Pseudonym> This is of the form T -> H
15:17:57 <Pseudonym> T: "You keep talking."
15:18:02 <Pseudonym> H: "I hit you."
15:18:09 <Pseudonym> There are three possible outcomes.
15:18:12 <Pseudonym> 1. You could stop talking.
15:18:17 <Pseudonym> 2. I could hit you.
15:18:25 <Pseudonym> 3. Possibly both, if I'm feeling especially violent.
15:18:28 <boegel> Pseudonym: it's quite easy really: if you start from something false, you can prove anything
15:18:32 <Pseudonym> Therefore: not T \/ H
15:20:10 <Heffalump> your outcomes are poorly stated.
15:20:17 <Heffalump> 1. You could stop talking and not get hit.
15:20:23 <Heffalump> 2. You could keep talking and get hit.
15:20:30 <Heffalump> 3. You could stop talking and get hit.
15:20:31 <Pseudonym> Right.
15:20:33 <Spark> that had to be proved for someone in a 4th year msc research pathway course the other day
15:20:38 <Pseudonym> I'm being brief because I hate typing.
15:20:49 <Pseudonym> Spark: That's a little disturbing.
15:21:05 <Pseudonym> But I sometimes wonder how much of this people _truly_ don't get.
15:21:12 <Spark> it all hinges on amount of practice
15:21:23 <Pseudonym> A lot of career engineers don't _truly_ understand why multiplying two negative numbers gets a positive number.
15:21:24 <Spark> that identity is rarely useful unless youre doing logic
15:21:33 <Pseudonym> They might understand it formally.
15:21:36 <Pseudonym> And know that it works.
15:21:41 <Pseudonym> But really not understand _why_.
15:21:58 <monochrom> I do logic and that identity is rarely useful as well.  Much easier to work with -> directly as a partial order.
15:22:22 <Heffalump> so why does it work that way?
15:22:28 <Spark> its useful in modal logic for converting things to sahqvist form, thats where it appeared the other day :)
15:22:31 <boegel> Pseudonym: so why ?
15:22:32 <wolfman8k> what about complex numbers?
15:22:32 <Heffalump> I could come up with lots of explanations of making things consistent.
15:23:27 <Heffalump> but they all come down to "it makes it simpler if we define it that way"
15:23:42 <Pseudonym> Right.
15:24:11 <Pseudonym> You can come up with intuition, like you film a car driving backwards, then play the film backwards.
15:24:19 <Pseudonym> Or something.
15:24:48 <esap> what are you talking about? double negation elimination?
15:24:55 <Heffalump> yes, fair enough
15:25:00 <Spark> (-m)(-n)=mn
15:25:40 <esap> ah ok
15:25:59 <Spark> isnt that double negation thing a bit dodgy?
15:26:13 <esap> dodgy?
15:26:26 <esap> why?
15:26:32 <Spark> i dunno ive never done maths
15:38:47 * esap just realized my implementation of integer multiplication can't handle multiplication of two negative numbers :-) :-) Hmm.. wonder why the type checking didn't catch that :-)
15:39:17 <lmbdwar> hi
15:39:23 <lmbdwar> whats an omega-regular langage ?
15:39:44 <lmbdwar> a langage for which all traces finishes ?
15:39:58 <lmbdwar> a language for which all traces finish
15:40:08 <lmbdwar> or something else 
15:42:59 <boegel> lmbdwar: http://www-cad.eecs.berkeley.edu/~tah/Publications/from_verification_to_control.pdf
15:43:09 <boegel> maybe this will help you ?
15:46:23 <monochrom> A language of infinite strings accepted by a certain Buchi automaton.
15:47:54 <lmbdwar> Im reading this paper : 'Its about time : real-time logic reviewed'
15:48:25 <lmbdwar> http://www.eecs.berkeley.edu/~tah/
15:48:32 <lmbdwar> :)
15:48:33 <Pseudonym> Is that where you have to be smart on a deadline.
15:48:54 <lmbdwar> boegel, from the same guy it seems 
15:50:46 <boegel> :)
15:53:30 <ral1> Somebody say something. 
15:53:36 <ral1> I'm demonstrating gaim to my friend
15:53:43 <ral1> I'm giving him a haskell lesson. 
15:53:51 <Pseudonym> Cardinal Richelieu died in 1642.
15:54:09 <ral1> Thanks Pseudonym.  Tell my friend Jon how great haskell is. 
15:54:19 <Pseudonym> Haskell is really great!
15:54:23 <ral1> Thanks
15:54:28 <Pseudonym> No prob.
15:54:46 <Pseudonym> If you need any more slogans, just ask.
15:56:15 <ral1> Pseudonym: Please give me another slogan. 
15:56:20 <boegel> It's now 0:57 CET
15:56:40 <Pseudonym> Haskell Adds Life.
15:56:41 <boegel> ral1, what does gaim have to do with Haskell?
15:57:01 <ral1> I just gave my friend Jon his first lesson and we already got through currying and higher order functions.  We left off by writing out the type signature for type. 
15:57:01 <Pseudonym> Things Go Better With Haskell.
15:57:11 <ral1> Next lesson, we will define map. 
15:57:24 <ral1> boegel: Well, I want him to be able to talk to us...
15:58:09 <Pseudonym> The way to get geeks to talk is to send wrong information.
15:58:12 <Pseudonym> So here goes.  *ahem*
15:58:17 <Spark> haha
15:58:19 <Spark> thats so true
15:58:28 <Spark> i got the most comments ever to a blog post when i fucked something up
15:58:34 <Pseudonym> Win32 is a very consistent and well-designed API.
15:58:45 <Spark> thats ok its all nicked from unix
15:58:49 <Pseudonym> Yeah.  If you ask a question, everyone will ignore you.
15:58:56 <Spark> except the "everything is a file" bit which promotes viruses and spam
15:58:59 <Pseudonym> Give a wrong answer, and everyone will rush to correct you.
15:59:12 <Pseudonym> Actually, everything in Win32 is a handle.
15:59:20 <Pseudonym> Even integers.
15:59:21 <wolfman8k> "everything is a value"
15:59:29 <wolfman8k> that's the best philosophy :D
15:59:40 <Pseudonym> No it's not!  Everything should be a thunk.
15:59:47 <Spark> everything is an abstraction
15:59:48 <Pseudonym> Or... everything should be bits.
15:59:51 <Spark> or a phenomenon
15:59:53 <Spark> or an entity
15:59:55 <Pseudonym> Abstractions are bad!
15:59:57 <Spark> or maybe some other things
16:00:20 <wolfman8k> how about, "Everything is a value, but some things are a value+context"
16:00:36 <esap> abstractions are great!
16:00:43 <Spark> all normal forms are values? :)
16:00:50 <Spark> values are the result of computation
16:00:53 * boegel goes to bed, sleep tight everyon
16:00:54 <Spark> what else
16:01:10 <wolfman8k> computation is a value
16:01:28 <Spark> computation is a relation from syntax to syntax
16:01:34 <Spark> i feel really weird
16:01:47 <esap> Computation is a relation from syntax to semantics, I'd say
16:01:52 <wolfman8k> yeah, but it's a value, like high order functions in a way
16:02:06 <Spark> s/relation/function really :)
16:02:46 <Spark> hmm can a program be aware of its own execution
16:02:47 <monochrom> COMMAND IS FUNCTION.  VARIABLE IS CONSTANT.  UNTYPEDNESS IS SLAVERY.
16:04:08 <Spark> another thing occured to me today - typing is just another form of computation - sufficiently precise types map directly to values and back, and the subject reduction property gives us the reduction as well
16:04:34 <Spark> thats not just a bizarre property of type system X, its actually spot on what we want
16:05:07 <esap> Data is function. Function is data. Functions and data are distinct.
16:05:47 <Spark> hmm i feel really fucked up
16:05:52 <Spark> i htink i shall have to sleep
16:06:03 <Spark> im actually hallucinating and stuff :)
16:08:16 <Spark> now i need to get up at 7:30
16:08:38 <wolfman8k> i need to wake up in 5 hours :'(
16:08:39 <Spark> so i could use atd to aumix -w 80 at 07:30 and leave music on overnight but volume set to 30%
16:08:51 <Spark> but i want to listen to radio stations
16:09:04 <Spark> however if there is network disconnection, the radio station will stop, and hence the alarm will make no sound
16:10:37 <wolfman8k> i use cat /dev/random > /dev/audio with max volume
16:10:55 <wolfman8k> white noise is the only thing that wakes me
16:11:07 <wolfman8k> music i sleep through. beeping i also sleep through
16:11:16 <Spark> oh ill do that too
16:11:23 <Spark> more likely to turn it off too
16:11:31 <Spark> rather than just lying there listening to it
16:11:50 <Spark> in the morning like stoned, "fuck it i dont care" attitude towards the day and what i want to do
16:11:55 <wolfman8k> yep, especially when you don't live alone and your alarm goes off on a weekend at 6 am :D
16:12:06 <Spark> haha
16:13:39 <stepcut> Spark: may I introduce you to the concept of a clock-radio ? Instead of ethernet, it uses plain old ether :)
16:14:18 <Spark> i could get one of htose
16:14:26 <Spark> it would decrease the amount of pain in my life
16:14:34 <Spark> at the same time i could get a heater and a hoover and stuff
16:15:03 <stepcut> I don't need a clock, my cat just starts knocking things over in the morning until i get up and feed him
16:15:16 <Spark> and stop borrowing hoovers from people and also stop being freezing cold
16:15:37 <Spark> i cant even look after myself let alone a cat
16:23:18 * stepcut tries to figure out which flash to get for his camera... :-/
16:36:58 <shevegen> can you recommend a little haskell tutorial ? 
16:38:02 <Lemmih> Yes, I'm fairly sure we can do that.
16:38:21 <shevegen> glad  to know that ;)
16:41:58 <Lunar^> shevegen: Yet another haskell tutorial
16:42:56 <Lemmih> Guess I took the question way too literal.
16:43:09 <monochrom> Mine is at http://www.cs.utoronto.ca/~trebla/fp/  short but insightful
16:44:16 <Lunar^> Is there anything like a "pokeCString" ?
16:46:12 <shevegen> thanks
16:47:22 <Lemmih> Lunar^: I don't see what it should do.
16:47:54 <Lunar^> Lemmih: pokeCString :: String -> CStringLen -> IO ()
16:48:36 <Lunar^> Lemmih: I get a buffer and its len, I would like to copy an Haskell string in it
16:49:13 <musasabi> pokeArray
16:50:37 <musasabi> a cstring is just a pointer to CChar.
16:53:18 <Lunar^> @type pokeArray
16:53:19 <lambdabot> bzzt
16:53:25 <Lunar^> @type Foreign.pokeArray
16:53:26 <lambdabot> Foreign.pokeArray :: forall a.
16:53:26 <lambdabot> 		     (Foreign.Storable.Storable a) =>
16:53:26 <lambdabot> 		     GHC.Ptr.Ptr a -> [a] -> IO ()
16:53:34 <Lunar^> cool
16:53:38 <Lunar^> musasabi: thanks ! :)
16:57:14 <Lunar^> musasabi: pokeArray pBuf $ take bufSize target
16:57:43 <Lunar^> musasabi: or minus one, maybe
16:58:18 <Lunar^> without '\0'
16:58:39 <Lunar^> musasabi: pokeArray0 '\0' pBuf $ take (bufSize - 1) target
16:58:42 <Lunar^> with it
16:58:46 <Lunar^> right ?
16:59:18 <Lemmih> Lunar^: Note the difference between Char's and CChar's.
16:59:42 <Lunar^> mhhh
17:00:03 <Lunar^> map castCCharToChar then
17:00:54 <Lemmih> Isn't 'target' of type [Char]?
17:01:30 <Lunar^> Lemmih: yes
17:01:40 <Lunar^> the other cast
18:18:17 <MegaMonad> Howdy all, im having troubles with was an ftbfs.
18:18:19 <CosmicRay> megamonad: I really need to add you to my startup script.
18:18:20 <MegaMonad> CosmicRay: How they add random accents and numeric expressions in the script you mean?
18:18:40 <Lunar^> MegaMonad: What about ducks ?
18:18:41 <MegaMonad> Lunar^: Oejet_ ducks in slowmotion like in ghc and hugs.
18:18:59 <Lunar^> MegaMonad: Hugs are surely sweet.
18:19:00 <MegaMonad> Lunar^: Sweet sweet emacs.
18:19:13 <Lunar^> MegaMonad: I like vim bitterness.
18:19:15 <MegaMonad> Lunar^: Shapr: ofcourse, the more you like vim bitterness.
18:19:22 <Lunar^> :)))
18:21:13 <shapr> paf: hiya
18:21:29 * shapr hops
18:24:00 <CosmicRay> yo shapr
18:24:03 <shapr> y0
18:24:21 <CosmicRay> <Lunar^> MegaMonad: What about ducks ?
18:24:21 <CosmicRay> <MegaMonad> Lunar^: Oejet_ ducks in slowmotion like in ghc and hugs.
18:24:21 <CosmicRay> <Lunar^> MegaMonad: Hugs are surely sweet.
18:24:21 <CosmicRay> <MegaMonad> Lunar^: Sweet sweet emacs.
18:24:21 <CosmicRay> <Lunar^> MegaMonad: I like vim bitterness.
18:24:21 <CosmicRay> <MegaMonad> Lunar^: Shapr: ofcourse, the more you like vim bitterness.
18:25:02 * shapr snickers
18:25:09 <shapr> ain't that the truth
18:25:25 <shapr> too bad hs-plugins doesn't work on AIX. You could try the vim bitterness that is Yi
18:25:40 <CosmicRay> heh
18:26:07 <shapr> It is the vim bitterness that is a sip of morning arabica
18:26:11 <CosmicRay> of course that is because: 1) dynamic linking is fscked on that platform, and 2) ghc barely manages to work
18:26:24 <shapr> How'd you get entangled with AIX anyway?
18:26:32 <shapr> What led you to this sorry fate? Do you blame society?
18:26:40 <CosmicRay> the Powers That Be decided it would be the new platform for our ERP software
18:26:57 <CosmicRay> mainly because it was 3x more expensive than the proposed Linux solution
18:27:32 <shapr> uh, yeah.
18:27:34 <shapr> ok then.
18:27:43 <CosmicRay> in truth, it is nice hardware
18:27:48 <CosmicRay> the os stinks though
18:27:50 <shapr> Could the hardware run Linux?
18:27:53 <CosmicRay> yes
18:28:01 <CosmicRay> but the application is not supported on linux powerpc
18:28:09 <CosmicRay> or power64
18:28:19 <CosmicRay> linux x86 only.
18:28:46 <CosmicRay> but anyway, the other finalist was.... drum roll please....
18:29:15 <CosmicRay> an as/400 / nt server hybrid deal, with the main data on the as/400 and some important features on a sql server platform
18:29:27 <CosmicRay> so really, I am lucky.
18:29:40 <CosmicRay> because that would have been an unimaginable horror
18:30:13 <CosmicRay> trying to meld a platform that doesn't yet grok ASCII with one that can't reliably grok anything... *shudder*
18:30:32 <shapr> That's nuts.
18:30:39 <shapr> Why can't you use Linux x86?
18:30:56 <CosmicRay> they were concerned about the scalability of the hardware
18:31:30 <rtega> CosmicRay: i've been told as/400 works as a charm
18:31:40 <CosmicRay> the old system was as/400-based, so the big-iron thought process seemed easier to understand ("just add a $2000 drive" vs. "just add a $2000 computer")
18:31:49 <shapr> CosmicRay: did they try it?
18:32:01 <CosmicRay> rtega: yes, it is quite as reliable as a refrigerator-size heap of bricks
18:32:12 <CosmicRay> rtega: otoh when something fails, it does so spectacularly
18:32:14 <shapr> Did they try scalability of the app on Linux x86?
18:32:18 <CosmicRay> shapr: no
18:32:29 <shapr> What was the price difference?
18:32:38 <shapr> I bet it was worth a Linux vendor demo.
18:32:45 <CosmicRay> shapr: there is no real way to ensure it's going to work until go-live, at which point it's a crisis if it's not good enough
18:32:48 <CosmicRay> shapr: $40k
18:33:05 <shapr> Well, that's not too bad.
18:33:07 <CosmicRay> shapr: actually the installation consulting company is an ibm reseller, so they were selling ibm kit either way
18:33:08 <CosmicRay> yeah
18:33:25 <CosmicRay> for a $2 million project, it makes sense if it buys some security
18:33:28 <CosmicRay> I can understand why they did it
18:33:29 <shapr> yeah, I can dig that.
18:33:37 <CosmicRay> the side effect, though, is that I must use AIX :-(
18:33:42 <shapr> :-(
18:33:58 <CosmicRay> this is the best part though.
18:34:07 <CosmicRay> we're very thorough about checking all the options.
18:34:11 <shapr> Last time I had access to an AIX box, I used it as an FPU for all my code.
18:34:20 <CosmicRay> so they went down the windows path with the vendor.  (the app does run on windows servers)
18:34:27 <CosmicRay> the vendor refused to even quote us a windows solution
18:34:30 <shapr> whoa
18:34:53 <CosmicRay> they said "it works fine with up to about 50 users, but after that it is just not stable enough.  we do not believe this is a good solution for you."
18:35:00 <shapr> wow
18:35:07 <rtega> gni
18:35:14 <rtega> good and earnest vendor
18:35:35 <CosmicRay> yeah, they would have made more money selling us the windows option than the linux one they proposed
18:35:52 <rtega> then you should definitely stick with the guys
18:36:19 <rtega> well, probably they would have a lot more trouble too ;)
18:36:25 <CosmicRay> yeah
18:36:37 <CosmicRay> they are mostly good and honest folks
18:36:37 <rtega> insert "had" in the right place there
18:36:47 <CosmicRay> who cut through corporate red tape with skill and finesse
18:37:09 <rtega> didn't know these type of people still exist
18:37:21 <rtega> s/these/this/
18:37:27 <rtega> s/exist/exists/
18:38:36 <CosmicRay> only problem is, their consultants keep getting hired away by their clients
18:38:43 <shapr> rough
18:49:13 <shapr> I want a zope replacement in Haskell.
18:51:33 <CosmicRay> ah yes, I too have long sought for something that stores filesystem-like data in a single fragile file that's difficult to back up and has a proprietary format... :-)
18:51:42 <CosmicRay> but that's probably not the part of zope that you seek to clone :-)
18:52:04 <CosmicRay> zope is a really cool idea
18:52:09 <CosmicRay> some of the execution is annoying though
18:52:36 <CosmicRay> that is chief among it, because it means, among other things, that it's difficult to use emacs to edit my pages
18:52:49 <CosmicRay> or (favorite vc system) to preserve them
18:57:39 <CosmicRay> shapr: what I'd like to see is hemacs really happen
19:05:19 <CosmicRay> shapr: do you use zope much?
19:05:38 <CosmicRay> didn't mean to rain on your parade there, soryr
19:05:48 <CosmicRay> just brought back some bad memoryies of mozilla's text entry widget :-)
19:07:21 <Pseudonym> @arr
19:07:21 <lambdabot> I'll keel haul ya fer that!
19:26:09 <CosmicRay> @arr
19:26:10 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
19:26:42 <heatsink> s/ya/ye/g
19:52:11 <shapr> CosmicRay: yes, way too much.
19:53:09 <jemfinch> is there anything about arrows that requires lazy evaluation?
19:53:24 <shapr> no
19:54:07 <shapr> CosmicRay: I agree, zope sucks butt. 
19:54:08 <shapr> dang
19:56:32 <Pseudonym> MegaMonad: What does zope suck?
19:56:33 <MegaMonad> Pseudonym: Zope for money, and you can suck a lot.
19:56:41 <Pseudonym> So I can.
19:56:59 * shapr laughs
19:57:10 <Lunar^> :)
19:57:11 <Lunar^> sudo cat /tmp/mnt/hello
19:57:11 <Lunar^> Hello World, HFuse!
19:57:20 <Lunar^> lunar@tsuki:~/Documents/Development/Haskell/Tools/hfuse$ sudo fusermount /tmp/mnt ./HelloFS
19:57:40 <Lunar^> IT WORKS! :)
19:57:45 <shapr> yay!
19:57:47 <jemfinch> shapr: is there anything about arrows that requires typeclasses?
19:57:58 <shapr> jemfinch: no, not that either.
19:58:06 <jemfinch> shapr: so what's the big deal about arrows?
19:58:08 <Lunar^> shapr: It still need some polishing, but basically, it works
19:58:09 * jemfinch doesn't get it.
19:58:19 <shapr> jemfinch: have you read the arrows papers?
19:58:23 <jemfinch> I've tried to.
19:58:24 <shapr> Lunar^: awesome!
19:58:37 <shapr> jemfinch: did you read Ross Paterson's Fun of Programming chapter?
19:58:38 <jemfinch> but I think I would need a good, understandable example to really "get" why arrows matter.
19:58:42 <jemfinch> to me, they just seem like functions.
19:58:56 <shapr> They are a lot like functions.
19:58:59 <jemfinch> (and yes, I know that all functions are arrows, but not all arrows are functions)
19:59:30 <shapr> Ross Paterson cleaned up the standard examples given in the Hughes paper.
19:59:48 <shapr> And they are good, understandable examples imho.
19:59:55 * jemfinch will look
20:00:12 <shapr> from one view, it's the next step up after monads.
20:00:21 <shapr> value, function, action, transform
20:00:41 <Lunar^> shapr: http://haskell.org/hawiki/HaskellIrcPastePage
20:00:48 <shapr> a monad is a first class action, like a party-popper with a string you can pull.
20:01:23 <shapr> An arrow is a first class transformation, it's more like nouning a verb so you can do more with it.
20:01:51 <shapr> Lunar^: nifty!
20:02:23 <Lunar^>   105 HelloFS.hs
20:02:24 <Lunar^>   495 HFuse.hsc
20:02:24 <Lunar^>   600 total
20:04:42 <Lunar^> shapr: Yeah :) I'm happy! :)
20:05:10 <Lunar^> Though, I've seen too late that the Debian package was not up-to-date
20:05:24 <Lunar^> but'll finish the binding for fuse 1.3 first
20:05:38 <shapr> My unicycles are named Haskell and Python.
20:06:25 <shapr> Lunar^: I look forward to it.
20:09:28 <jemfinch> this chapter just makes my eyes gloss over.
20:10:22 <shapr> Do you understand monads?
20:10:54 <jemfinch> I think so.
20:11:06 <shapr> Do you see how monads can't export static info?
20:11:19 <jemfinch> no.
20:11:29 <shapr> @type (>>=)
20:11:30 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
20:12:14 <shapr> Once you've filled the a into (a -> m b), you have one option. run it.
20:12:39 <shapr> @type (Control.Arrow.>>>)
20:12:40 <lambdabot> (Control.Arrow.>>>) :: forall a d b c.
20:12:40 <lambdabot> 		       (Control.Arrow.Arrow a) =>
20:12:40 <lambdabot> 		       a b c -> a c d -> a b d
20:13:30 <jemfinch> and >>> "exports" d.
20:13:32 <shapr> If you instead have a type 'a b c' where A is an arrow that transforms b values into c values, then you have a freeze-dried action that you can operate on.
20:13:52 <jemfinch> freeze-dried?
20:13:59 <shapr> The monadic interface is a cute version of CPS, right?
20:14:24 <shapr> I think there's a similar relation between arrows and serializable first class continuations.
20:14:54 <shapr> A nouned verb is like a freeze-dried action.
20:15:25 <shapr> First class continuations give you every control structure.
20:15:25 <jemfinch> so an arrow turns "computation" into a value.
20:16:19 <shapr> That's not all of arrows, but that's the part that's significant to understanding the advantage over monads.
20:16:50 <jemfinch> so, aside from syntax, why use monads when you have arrows?
20:17:05 <shapr> Monads are easier to deal with.
20:17:35 <shapr> They're a special case of arrows that allows simpler rules, and you can write do notation expansion by hand.
20:17:43 <shapr> You don't want to write arrow syntax expansion by hand.
20:18:12 <jemfinch> why not?
20:18:25 <shapr> It's just too much work.
20:18:35 <jemfinch> why would it be more work?
20:18:41 <shapr> read the arrows papers!
20:18:47 <jemfinch> I can't!
20:18:54 <shapr> sure you can.
20:18:59 <jemfinch> they make my eyes gloss over.  it's like they're *trying* to achieve unreadability.
20:19:05 <jemfinch> they might as well be written in binary.
20:19:32 <shapr> Think of the Blub paradox for motivation :-)
20:19:35 <jemfinch> anyway, here's a good question: you say you'd like to reimplement zope/plone in Haskell.  Presumably you'd use arrows.  What's an example of something you'd use an arrow for?
20:20:33 <shapr> I can't think of anything off the top of my head.
20:20:43 <shapr> What about the Patch arrow I've talked about on #darcs?
20:21:03 * jemfinch hasn't seen you talk about a patch arrow on #darcs.
20:21:09 <jemfinch> other than mentioning it.
20:21:19 <shapr> If you understand monadic parsers, arrow-style parsers are clearly more efficient.
20:21:38 <jemfinch> shapr: I've never looked into monadic parsers.
20:21:41 * jemfinch can do that.
20:22:08 <shapr> Arrows happened because there was a really powerful parser that could not fit into the monadic interface.
20:22:28 <shapr> It says that in the papers too.
20:24:34 <shapr> Quite a few of the Haskell research papers take me several reads to get anything at all. But once you get in there, there's a lot of content.
20:25:32 <shapr> I recommend writing a bunch of notes in the margins. I print single-side so that when the margins overflow, I can write on the back too.
20:26:36 <shapr> Maybe I should write the arrows sequel to the Nomaware tutorial.
20:47:25 <shapr> jemfinch: http://www.flightlab.com/~joe/hxml/arrows.html
20:51:01 <Pseudonym> shapr: Yes, you should definitely do that.
21:01:47 <jemfinch> shapr: that link definitely exemplifies why I hate Haskell's flexibility wrt to operators :)
22:04:08 <samc> Is there any way to match nested comments (for syntax colouring) with regular expressions, or do I have to kludge it and only allow for anything up to a specific (small) depth?
22:22:06 <Gahhh> my compiler book says regular expressions can't be used for balanced or nested constructs.
22:25:46 <samc> :( as I suspected
22:26:26 <Pseudonym> Your book is wrong.  Regular expressions can parse any language at all, so long as the symbols obey an appropriate algebra.
22:26:51 <shaleh> um, regex in general may not deal with some types of languages
22:27:11 <Pseudonym> Oh, a "regex" can't, if you meant POSIX regex.
22:27:24 <Pseudonym> But a "regular expression" can, given an appropriate algebra..
22:27:40 <shaleh> Pseudonym: right, a particular implementation MAY be able to, but it is not inherently true
22:28:15 <Pseudonym> It's got nothing to do with implementation.
22:28:38 <Pseudonym> A push-down automaton, for example, is just a finite automaton with stack operators which obey a spinor algebra.
22:28:39 <shaleh> either way, I came in to ask some newbie -eque questions
22:28:46 <samc> Pseudonym, what means you by 'appropriate'?
22:28:48 <Pseudonym> And a PDA can handle context-free languages.
22:29:00 <shaleh> like, how do I implement a 'generator' to use python terminology
22:29:15 <Pseudonym> shaleh: What's a generator?
22:29:22 <Pseudonym> Brief description?
22:29:30 <shaleh> a function say 'give :: a -> [a]' where it will return an infinite list of as
22:29:37 <Gahhh> shaleh, you can't
22:29:37 <samc> even a finite one, Pseudonym?
22:29:59 <Pseudonym> samc: Sure.
22:30:02 <Gahhh> well, you can. ugh. don't generators have state ?
22:30:08 <Pseudonym> samc: Want me to prove it?
22:30:16 <samc> sure
22:30:21 <Pseudonym> @type iterate
22:30:22 <lambdabot> iterate :: forall a. (a -> a) -> a -> [a]
22:30:22 <shaleh> ok, so to use a concrete example. zipWith (blah) listA thingB
22:30:32 <Pseudonym> So "iterate id" will do the trick.
22:30:59 <Pseudonym> samc: Let me show you.
22:31:03 <shaleh> Pseudonym: yep, thanks
22:31:14 <Pseudonym> Suppose you have elements <0| |0> <1| and |1>
22:31:25 <Pseudonym> They obey an orthonormality condition:
22:31:30 <Pseudonym> <0| |0> = 1
22:31:33 <Pseudonym> <1| |1> = 1
22:31:37 <Pseudonym> <0| |1> = 0
22:31:40 <Pseudonym> <1| |0> = 0
22:31:45 <wli> bra and ket?
22:31:52 <Pseudonym> Yes, bra and key.
22:31:54 <Pseudonym> ket
22:32:07 <Pseudonym> Where 0 is the null set and 1 is the empty string (sometimes known as epsilon or lambda).
22:32:17 <Pseudonym> And also the full basis rule:
22:32:27 <Pseudonym> |0> <0| + |1> <1| = 1
22:32:33 <Pseudonym> The "+" sign is set union.
22:32:52 <Pseudonym> In addition, the bras and kets commute with terminals:
22:32:57 <Pseudonym> a <1| = <1| a
22:33:18 <Pseudonym> Then this: <0| (a <1|)* (b |1>)* |0>
22:33:23 <Pseudonym> generates a^n b^n
22:33:28 <Pseudonym> It's a regular expression.
22:33:48 <Pseudonym> Semantically, you can think of the bras and kets as stack operations.,
22:33:58 <Pseudonym> <0| pushes 0 onto a stack, and |1> pops 1
22:34:05 <Pseudonym> Where 0 and 1 are stack symbols.
22:36:14 <Gahhh> So, what is the regex that matches balanced {}'s ?
22:36:56 <xerox> The regexp of your dreams
22:36:59 <Pseudonym> Then this: <0| ('{' <1| + '}' |1>)* |0>
22:37:05 <Pseudonym> That does the trick.
22:37:10 <xerox> Whoa.
22:37:41 <Pseudonym> POSIX regexp engines don't support the bras and kets, sadly.
22:38:23 <Pseudonym> Now if you have _two_ stacks, you have the full power of Turing machines at your disposal.
22:38:29 <xerox> Ah-ha!
22:38:57 <Pseudonym> wli: Did you see my other Fibonacci thingy?
22:39:31 <Pseudonym> Curious to know how well it stood up.
22:39:34 <samc> I see, very interesting, and entirely unhelpful ;)
22:39:53 <Pseudonym> Still, my point is that the book is wrong.
22:40:05 <Pseudonym> Now if the book said "regular languages", or "rational languages", it would be correct.
22:40:10 <Gahhh> How old are these bra's and ket's ?
22:40:13 <Pseudonym> But "expressions" can satisfy any algebra.
22:40:20 <Pseudonym> Well, Dirac invented them in the 1920s.
22:40:39 <Pseudonym> The spinor algebra, anyway.
22:40:42 <Pseudonym> Oh!  One more thing.
22:40:56 <Pseudonym> I used the notation 0 and 1 for null set and empty string.
22:41:13 <Gahhh> My book is Compilers: Principles, Techniques and Tools by Aho, Sethi and Ullman. 1988.
22:41:13 <Pseudonym> If you allow varying degrees of "scalar" between 0 and 1, this gives you a formal language model for quantum computers.
22:43:17 <Pseudonym> Hmmm.
22:43:42 <Gahhh> I cannot find which regexp's support bra and kets.
22:43:56 <Pseudonym> You're unlikely to. :-)
22:44:07 <Pseudonym> And definitely not in the dragon book.
22:44:46 <Pseudonym> Nobody can actually agree on what the term "regular expression" means.
22:45:03 <Pseudonym> A Perl regex is powerful enough to match only prime-length strings.
22:45:11 <Gahhh> well, in the context of samc's question, I think it has a rather definite meaning.
22:45:44 <Pseudonym> Yes, but I wanted to rant.
22:46:03 <Gahhh> I'll take a look at this bra & ket stuff anyways
22:46:06 <Pseudonym> There's a deeper problem here, namely that most people who write about this aren't careful about their terminology.
22:46:26 <Pseudonym> A "regular expression" is, surely, an expression in a regular algebra.
22:46:34 <Gahhh> people are careless about a ton of things.
22:47:30 <Gahhh> Today, my boss presents me with this totally mathematically unsound calculation. I respectfully ask if I should spend some time looking into this. He says "I'd rather you didn't. I spent enough time on this already and am pretty confident."
22:47:42 <Pseudonym> What they meant to say, I think, was the free regular algebra over some alphabet.
22:48:06 <Pseudonym> But I'm not so sure if contracting the bras and kets is a homomorphism or not.
22:48:26 <Pseudonym> Gahhh: Poor you.
22:48:34 <SyntaxNinja> MegaMonad: what do bras have to do with homomorphisms? 
22:48:35 <MegaMonad> SyntaxNinja: It's much just mirrors the gtk bindings if you could use sctp instead of the homomorphisms for a simple buffer for navigating text based adventure game, where trees are nice for interactive use and it's for "as.
22:48:55 <shaleh> bras, homos? cross dressers maybe?
22:48:55 * Gahhh reports that doing a google search on "regular expression bra ket" gives you some weird hits on some interesting perl scripts...
22:49:10 <Pseudonym> Look up Mark Johnson.
22:49:15 <Pseudonym> Might have misspelled the surname.
22:50:17 <Gahhh> MegaMonad, why are you not always online ?
22:50:18 <MegaMonad> Gahhh: I came from me not being online is that the decimal representations of logic programming, but i'd have to read it, not because something isn't _total_ security doesn't make coffee.
22:50:41 <Pseudonym> Ah, here's an old comp.compilers post:
22:50:51 <Pseudonym> http://compilers.iecc.com/comparch/article/94-02-110
22:50:59 <Pseudonym> And it's Mark Hopkins.
22:53:19 <Pseudonym> And I must go.
22:53:20 <Pseudonym> Nytol!
22:53:29 * shaleh is noticing his fingers want to type const whenever I try to type concat
22:54:56 <SyntaxNinja> const = concat
22:55:01 <SyntaxNinja> problem solved ;)
22:55:08 <shaleh> heh
22:55:10 <SyntaxNinja> although anyone reading your code will hate you
22:55:35 <Gahhh> that's not a problem for me.
22:55:35 * shaleh is working his way through Haskell: CFP
22:55:42 <shaleh> nice book
22:56:14 <shaleh> wish there were answers to at least some of the exercises, but the thread on the list explains why there are not
22:58:08 <SyntaxNinja> shaleh: yeah, it's a no-win situation.
22:58:32 <shaleh> I have seen math texts which give the solutions to the odd numbered problems
22:58:39 <shaleh> that would be nice
22:58:54 <shaleh> basically, some value greater than 0
22:58:56 <shaleh> (-:
22:59:23 <shaleh> however, he does a decent job of covering the excercises in later chapters if you pay attention
22:59:28 <SyntaxNinja> well, if I remember that book correctly, you can often tell whether your answers are right, since they are implementations to little code problems
22:59:38 <shaleh> still, some way to check my style, usage, etc would be nice
22:59:46 <SyntaxNinja> absolutely
23:00:07 <SyntaxNinja> but then you could think of a general way to formulate a question, a code example that's different from the book, and post it to the list.
23:00:08 <wli> volunteer graders...
23:00:11 <shaleh> I can answer the questions (mostly) but sometimes I wonder if there wasn't a better way
23:00:53 <shaleh> I was recently following a Lisp book (the CLisp book), my solutions were often not as graceful as those in the back of the book
23:00:58 <Gahhh> There's often a better way. But I'd say you're better off solving another problem. Soon after you yourself will realized what ways were better.
23:01:20 * Gahhh feels he spoke like MegaMonad
23:01:21 <shaleh> Gahhh: yeah, it just takes longer and potentially teaches the student poor habits
23:02:01 <SyntaxNinja> shaleh: the way around that is to spend some time reading some good code
23:02:07 <shaleh> true
23:04:20 <shaleh> so far the ones I have had problems with are ones where I want a temporary variable. I know about let, but have not got to it in the book. So clearly, the problem can be solved without it.
23:05:05 <shaleh> which boils down to thinking functionally and breaking my iterative, C learning
23:05:29 <Gahhh> let doesn't give you an iterative escape anyways
23:06:07 <shaleh> Gahhh: what I mean is, my initial solution would have me compute a value "too many" times
23:06:32 <shaleh> so I want an analogue of "n = foo(); use n; use n; use;"
23:06:56 <shaleh> which typically means I have not really thought the problem out correctly in Haskell
23:07:21 <Cale> shaleh: well, the trick is to recognise the patterns of how you'd be using n a little more carefully
23:07:56 <Cale> Most loops turn into some combination of map, filter and folding
23:08:00 <shaleh> Cale: yeah, working on that. As usual, the grasshopper is complaing because the process is taking too long (-:
23:08:19 <shaleh> Cale: right, but in the early section of the book those are not choices yet
23:08:24 <Cale> start with what you're trying to compute
23:08:31 <Cale> and work backwards from that
23:08:41 <Cale> what do you need in order to compute it?
23:09:19 <shaleh> I think that is the hardest habit for a C coder to pick up -- just make another tiny function
23:09:34 <shaleh> plus side is this is making my C(++) code better
23:09:36 <shaleh> (-:
23:09:39 <Cale> :)
23:10:13 <shaleh> I am thoroughly enjoying Thompson's book though
23:10:30 <shaleh> well thought out exercises and examples
23:10:42 <shaleh> definitely a must read for the newbie Haskell hacker
23:10:55 <shaleh> the back cover explicitly lies though
23:11:23 <shaleh> "List comprehensions and standard functions over lists are covered before recursion"
23:11:28 <shaleh> lies!
23:11:53 <shaleh> the section on recursion finishes on the same page where those topics are started
23:12:04 <Cale> heh
23:12:08 <shaleh> clearly the editor and the author did not sync up
23:12:40 <shaleh> so far, that is my only complaint though
23:13:00 * shaleh is hoping the upcoming section on Monads will help clear that mud puddle up some
23:13:10 <shaleh> don't ruin it for me
23:13:16 <shaleh> (if it doesn't)
23:13:21 <shaleh> let me dream a little longer
23:13:38 <Gahhh> monads are usually a personal experience.
23:14:13 <shaleh> well, off to pick the wife up from work
23:14:17 <shaleh> thanks for the chat all
23:14:29 <Gahhh> cheers
