00:47:17 <Lemmih> vdrab: GHCi is GHC.
00:52:45 <Oejet> Hello, Lemmih.
00:54:14 <Lemmih> Ohoj, Oejet.
01:14:56 <basti_> hi all
01:15:10 <Lemmih> Greetings.
02:24:19 <boegel> greetings earthlings
02:26:45 <TFK> Greetings horrible green/grey alien.
02:28:17 <boegel> TFK: blue ! I'm _blue_ !
02:28:22 <TFK> :O
02:28:25 * TFK apologizes
03:30:24 * shapr boings
03:34:29 * boegel bounces
03:55:04 <Lunar^> Is there anything like pokeCString ?
03:56:18 <Lunar^> something with type String -> CStringLen -> IO () ?
04:02:40 * shapr yowns
04:24:25 * magical1 looks in
04:26:05 * shapr looks out
04:32:40 <magical1> hi SamB 
04:32:48 <magical1> hi shapr even
04:33:10 <magical1> damn this auto complete thingemy howdua ma whatsit
04:39:35 <shapr> y0 magical1 
04:39:49 <shapr> You in Dublin?
04:40:20 <shapr> Ah, yes.
04:40:30 <shapr> Trinity
04:40:38 <shapr> Nice heraldry.
04:44:04 <magical1> hanks
04:44:10 <magical1> *thanks even
04:44:29 <shapr> I guess this is a bad time to try my Gaelic ;-)
04:44:56 <magical1> I have to say the advice I've been gien here so far has been extremely helpful
04:45:07 <shapr> Do you need more advice?
04:45:25 * magical1 cannot speak Gaelic to save his life
04:45:29 <magical1> I will do
04:46:03 <magical1> I'm still trying to get my head around all this recursive type stuff
04:49:06 <magical1> how is sweden shapr?
04:49:30 <shapr> Cold
04:49:50 <magical1> lol, it's better than wet
04:50:15 <shapr> cold + wet = too much snow
04:50:45 <shapr> The city gov't here is complaining that they've already exceeded their snow removal budget and the snow season is only half over.
04:51:58 <shapr> My solution is to buy a wider unicycle tire.
04:53:39 <magical1> lol
04:54:08 * magical1 is a magician and balloon sculptor part time so that is pretty funny
04:54:33 <shapr> nifty
04:55:08 <shapr> Do you unicycle as well?
04:58:24 <magical1> from time to time
04:58:33 <magical1> I need to get a new one though
04:58:52 <shapr> What kind do you have?
05:02:04 <magical1> I got it from the states it is a giraffe
05:02:17 <shapr> oh, nice.
05:02:21 <magical1> but the crank is f*&ked
05:03:24 <magical1> was using iton the street and some (insert really nasty comment about person you  don't think highly of here) came over and tried to shove me off of it
05:03:44 <shapr> I have a KH24 Mountain Unicycle. It's fun.
05:04:30 <shapr> You can buy new cranks without much expense.
05:04:42 <magical1> it sounds like it is
05:05:28 <magical1> yeah but I want to get a Smaller one anyway, cos it is difficult cycling nine miles into work on a giraffe
05:05:41 <Oeje1> This channel is filled with unicycling, go playing, java bashing, category theorising, functional programmers, it seems.
05:05:56 <magical1> yup
05:06:12 <magical1> and don't make me burst your balloon
05:06:16 <magical1> ;)
05:06:22 <Oeje1> :-P
05:06:43 <shapr> Oeje1: is that good or bad?
05:07:00 <shapr> I do wonder if I talk about unicycling too much here on #haskell. That's why I started #unicycling
05:07:56 <magical1> lol
05:08:33 * magical1 used to run a channel for magicians, back when he had time to do such things
05:10:38 <Oeje1> shapr: I like this channel.  I guess it's a neutral statement at best.
05:11:19 <shapr> That's nice to hear.
06:06:19 <xerox> hi
06:07:00 <TheHunter> hi
06:14:12 <magical1> in the array library is it column, row  or  row, column?
06:14:49 <shapr> Have you tried out this demo code? http://www.scannedinavian.org/~shae/ProtoArray.hs
06:15:37 <shapr> Oeje1: I wonder how this channel could be better.
06:15:56 * magical1 just notices the comment at the bottom of the page and slaps himself for being thick and not noticing it
06:16:02 <magical1> thanks shapr 
06:17:22 <Muad_Dibber> shapr : by having other users than always the same people ;)
06:17:42 <shapr> Muad_Dibber: good point, how to do that?
06:17:44 <xerox> Are there any other `learning' documents than YATH and the ``gentle'' introduction?
06:18:18 <shapr> There's the lambda complex by Sebastian Sylvan, I dunno if it's what you want.
06:18:23 <shapr> Have you looked at the stuff on the learning page?
06:18:35 <xerox> Let me re-read it.
06:18:48 <shapr> Muad_Dibber: does that mean I should talk less and encourage others to talk more? ;-)
06:19:07 <Muad_Dibber> well, depends on the goals of the channel eh :)
06:19:23 <xerox> I didn't have a look at the HaskellTutorial.pdf, I think I'll try it.
06:20:08 <shapr> I think the goals of the channel is to help people learn Haskell and encourage writing and sharing Haskell code.
06:21:22 <Muad_Dibber> shapr : then you might talk less...if the goal of the channel would be to have conversations of very high level you would come in ;)
06:22:52 <shapr> hm, ok.
06:23:29 <xerox> Who is saying "shut the fantastic up" to shapr ? ;-)
06:23:50 <shapr> maybe he's just saying "give others a chance to talk too!"
06:30:52 * xerox goes to make a tea.
06:36:34 <Muad_Dibber> hehe
06:43:18 <xerox> Any real difference in using GHCi instead of Hugs, going trought the HaskellTutorial.pdf, that you know?
06:43:55 <xerox> (It `recommends' Hughs in his first page)
06:43:57 <xerox> *its
06:44:42 <Muad_Dibber> well
06:45:05 <Muad_Dibber> at uni we used hughs, but i doubt wether there is a real diffirence besides some syntax issues maybe, but i'm not sure about those either
06:46:40 <Philippa_> most of the hugs commands're available in ghci
06:47:32 <xerox> Let's use hugs, okay :-)
06:48:15 <TheHunter> hugs' compilation time is faster, all other reasons favor ghci.
06:49:13 <TheHunter> ghci's biggest advantage is that you can define functions in the interpreter via let
06:49:34 <xerox> Ah, you can't do it in Hughs?
06:49:41 <xerox> :-\
06:49:47 <xerox> -h
06:50:12 <TheHunter> you always have to do "let foo x = x + x in foo 3".
06:50:55 <xerox> Any other big difference?
06:51:37 <magical1> is what is read from the keyboard if typed numerically a string or and int?
06:51:50 <magical1> do I have to type cast it?
06:53:06 <TheHunter> it's an Int (or an Integer/Double...)
06:53:19 <magical1> cool
06:53:29 <magical1> that will help somewhat, thanks
06:54:11 <magical1> how would I perform a check to see that it is an int?
06:54:22 <magical1> or a double ....
06:55:03 <TheHunter> i don't know if that's what you mean, but in the interpreter, you can do
06:55:19 <TheHunter> *Main> :t 10
06:55:19 <TheHunter> 10 :: forall t. (Num t) => t
06:55:30 <TheHunter> which tells you that 10 is something numerical
06:55:50 <boegel> magical1: how's Fibonacci going ?
06:56:22 <magical1> if a program asks some one to enter a number and they reply "spinach" is there anyway to distinguish it?
06:56:46 <magical1> boegel: did it in about 45 minutes 
06:56:59 <TheHunter> ah, you're not talking about an interactive session.
06:57:21 <magical1> nope, I want it to be a feature in my program
06:57:25 <boegel> magical1: nice
06:57:29 <TheHunter> in that case, you can only read Strings, but convert them easily using read.
06:57:37 <boegel> magical1: can I (we) see the code ?
06:57:40 <magical1> can I set a range in which the answer must be
06:57:43 <xerox> boegel, what about Fibonacci?
06:58:20 <boegel> xerox: magical1 asked me yesterday how he could learn some Haskell in practice, I told him to code Fibonacci as an exercise
06:58:56 <TheHunter> xerox, an endless discussion about ghc vs hugs: http://www.haskell.org/pipermail/haskell-cafe/2005-January/008273.html
06:59:34 <xerox> Prelude> let fib n | n < 2 = 1 | otherwise = fib(n-1) + fib(n-2)
06:59:34 <xerox> Prelude> map fib [1..12]
06:59:34 <xerox> [1,2,3,5,8,13,21,34,55,89,144,233]
06:59:35 <xerox> ^_^
06:59:40 <wli> fib = 0 : 1 : zipWith (+) fib (tail fib)
07:00:22 <wli> oh, there are O(lg(n)) pure integer methods
07:00:41 <xerox> Uh.
07:00:49 <wli> it's the fib (2*n) and fib (2*n+1) cases
07:01:25 <xerox> Prelude> take 10 fib
07:01:25 <xerox> [1*** Exception: <<loop>>
07:01:31 <xerox> Is it the right way to use it?
07:02:18 <xerox> Ah ok, np.
07:02:47 <xerox> But it gives 0, that isn't a Fibonacci number.  Btw, can you explain how does it work?
07:04:56 <magical1> tho only problem I had was handeling the base case of zero, since zero is the first fibonacci number I implemented similar to xerox, but then I discovered that it excluded the first two numbers in the fibonacci series which are 0 and 1 as the actual sequence should be [0,1,1,2,3,5,8,13,21,34,55,89,144,233 .....] 
07:05:47 <xerox> Doesn't the series start with 1,1,2,... ?
07:05:52 <magical1> no
07:06:01 <magical1> it starts with 0
07:06:08 <magical1> I checked
07:06:32 <xerox> Mathworld says 1
07:07:29 <magical1> http://goldennumber.net/fibonser.htm
07:08:31 <xerox> The On-Line Encyclopedia of Integer Sequences says 0,1,1,btw
07:08:42 <magical1> amogst many other sources sites and books state that it starts at 0
07:09:07 <xerox> I ever tought it started with 1! Good to know, thanks.
07:09:09 <magical1> email mathworld and tell them they are wrong xerox 
07:09:16 <xerox> magical1, I'll do
07:09:26 <magical1> anyway getting back to my question for the moment, can it be done?
07:10:09 <magical1> or can I set a range in which the answer must be found within, otherwise it prompts the user to try again .....?
07:13:00 <wli> Prelude> let { fib n | n <= 2 = q + r | n > 2 && r == 0 = let t = (fib q) in t*(2*(fib $ q + 1) - t) | otherwise = (fib q)^2 + (fib $ q + 1)^2 where (q, r) = n `divMod` 2 } in map fib [0..20]
07:13:00 <wli> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
07:13:33 <magical1> nicely done
07:13:53 <boegel> wli omg :)
07:14:18 <wli> O(lg(n))) Fibonacci numbers, pure integer algorithm
07:14:34 <boegel> nice
07:16:56 <wli> There are formulae for Fibonacci numbers of arbitrary integral multiples. You could in principle use that to carry out divide-and-conquer schemes with higher branching factors for small primes.
07:16:57 <magical1> can I use the toEnum method to check and see that the getLine is an int?
07:20:04 * magical1 .....
07:20:52 <wli> anyway, the way it goes is first you switch on the thing mod 30. If the thing has a gcd > 2 mod 30, use reduction rules for the larger number. Otherwise, use the duplication rules.
07:22:04 <wli> might even be feasible to do mod 210
07:23:20 <wli> hmm, actually, just gcd mod the first umpteen primes
07:24:59 <wli> the multiplication rule for even multiples is trivially generalizable. Might as well use the largest product of the first several primes representable as an integer in your wordsize.
07:25:27 <wli> If it's relatively prime to that, fall back to the case for odd numbers.
07:31:51 * boegel starts installing Thunderbird
07:32:37 <xerox> Good choice :-)
07:34:46 <boegel> I was using Evolution, but everyone screams out that Thunderbird rocks, so I've decided to give it a shot
07:34:53 <wli> okay, not so easily generalizable
07:35:01 <araujo> Hello.
07:35:15 <boegel> hey araujo 
07:35:25 <araujo> hi boegel , how you doing?
07:36:56 <wli> it also looks like the size of the rule explodes rapidly
07:37:03 <boegel> araujo: pretty good
07:37:09 <boegel> besides the sucky final I had tomorrow
07:37:25 <boegel> s/tomorrow/yesterday
07:37:35 <wli> there are also deforestation concerns
07:37:40 <boegel> and the sucky oral exam I'll have tomorrow (same prof)
07:38:22 <wli> q `div` 2 == (q+1) `div` 2
07:38:35 <wli> ergh
07:38:37 <wli> not always
07:38:52 <wli> but you can unwind the recursion early
07:40:49 <boegel> xerox: it's looking quite good already...
07:41:50 <boegel> only problem is my isp mailserver _really_ sucks
07:42:00 <boegel> sometimes it takes several hours for a mail to arrive
07:42:00 <boegel> :s
07:44:34 <xerox> boegel, I suggest you a theme, let me find the url.. it's *really* good looking.
07:45:00 <xerox> http://members.shaw.ca/lucx/
07:45:16 <wli> the right way to do it is forward
07:45:31 <wli> you can easily do the bitreverse checking when they're fixed-precision integers
07:45:43 <wli> and thereby do it fully-deforested
07:46:10 <magical1> boegel: get a gmail acount
07:48:36 <xerox> magical1, nah!!!
07:49:02 <jlouis> Do you know if Thunderbird has what is called: Virtual mailfolders?
07:49:19 <jlouis> (sorry for the non-haskellism in this, but we can discuss a logical language for searching if you want ;)
07:49:45 <Philippa_> "bung all the mails in a list, use the list monad" - HTH, HAND
07:57:18 <boegel> jlouis: no, I don't know
07:57:20 <boegel> what is it ?
07:58:01 * boegel = off
07:59:42 <jlouis> boegel: it has, I checked
08:01:53 <magical1> xerox: what was the "nah!!!" about, I'm lostalready
08:02:29 <xerox> magical1, did you read the conditions?
08:07:02 <wli> okay, there it is
08:08:16 <wli> List Prelude> let { divs n = if n == 0 then [] else let (q, r) = n `divMod` 2 in divs q ++ [r] ; fib' (f, g) (x:xs) | x == 0 = fib' (f^2+g^2, g*(2*f-g)) xs | x == 1 = fib' (f*(f+2*g), f^2 + g^2) xs ; fib' (f, g) [] = g ; fib n = fib' (1, 0) (divs n) } in map fib [0..20]
08:08:27 <wli> deforested
08:09:49 <wli> well, sort of
08:09:53 <wli> you get the idea
08:10:28 <xerox> Can you put it on a file, for better reading? (-: The complexity goes..
08:11:00 <wli> If you can get at a lower-level representation of the number and do bit extraction in bit-reverse order, you can do things a bit faster than this.
08:13:16 <magical1> for gmail xerox?
08:14:04 <xerox> magical1, Yep
08:14:12 <wli> http://holomorphy.com/~wli/Fib.hs
08:14:26 <xerox> Thank you
08:14:42 <magical1> Idon't care if they read my mail, trust me , all they will get is a good laugh .......
08:15:03 <xerox> magical1, I don't like their policy, I don't recommend it, let me find some url..
08:15:24 <xerox> http://www.google-watch.org/gmail.html
08:15:32 <xerox> In fact I don't send mail to gmail accounts.
08:16:08 <wli> I wanted to use unfoldr everywhere but it was backward for divs
08:16:43 <wli> it's right for fib' though
08:17:30 <wli> is there an unfoldl or otherwise something like unfoldr that builds the list in reverse order from what unfoldr does?
08:18:34 <xerox> What does divs do?
08:18:45 <wli> xerox: builds up the list of bits in reverse order
08:19:08 <xerox> Sort of decimal to binary conversion?
08:19:30 <wli> bitreversal
08:20:48 <xerox> I'll better read the tutorial
08:20:57 <wli> anyway there's some pretty serious whiz-bang to that Fibonacci stuff
08:21:08 <wli> The Haskell code there doesn't really do much of anything interesting.
08:21:31 <wli> Everything relevant about it is math done somewhere outside the code.
08:23:46 <magical1> xerox: shall I list the number of things that are complete nonesense based in that report for you?
08:23:50 <wli> Generally, when it comes down to computing functions efficiently, that's how it goes.
08:25:01 <xerox> magical1, do it please
08:25:50 <xerox> wli, in fact to program in Haskell you do need an algorithm, when I program in LISP, I mostry invent, try, experiment, etc.
08:26:44 <wli> xerox: no, mathematical functions, e.g. fib(n), sin(x), etc.
08:27:37 <xerox> wli, hmm, I think that way, that's my impression.
08:29:33 <wli> xerox: well, things involve continued fractions, asymptotic expansions, Pade approximants, Remez approximants, etc.
08:29:54 <wli> xerox: and fancy recurrences, functional equational properties, etc.
08:31:07 <wli> xerox: i.e. the programming is just writing down the equations; all the work is getting the equations
08:32:33 <xerox> Yep
08:36:24 <wli> improved
08:37:49 <wli> xerox: refresh
08:37:52 <xerox> Okay
08:38:22 <xerox> I have to understand the underneath algorithm before, btw :D
08:39:14 <wli> xerox: fib (2*n+1) = (fib n)^2 + (fib (n+1))^2
08:39:53 <wli> xerox: fib (2*n) = (fib n)*(2*(fib (n+1)) - (fib n))
08:41:38 <wli> xerox: this then bitreverses n and keeps (fib (k+1), fib k) in a pair as it reconstructs n by steps of k -> 2*k or k -> 2*k+1
08:45:41 <xerox> Hmm
08:46:07 <xerox> I see
08:47:24 <TheHunter> hmm, has anyone got a suggestion for a keyboard?
08:47:24 <wli> unfoldl f x = case f x of { Nothing -> [] ; Just (u, v) -> unfoldl f v ++ [u] } -- this seems to DTRT
08:50:08 <wli> fib 9999 --> (0.06 secs, 5026520 bytes)
08:50:58 <wli> xerox: refresh again
08:51:43 <xerox> wli, before it seemed more clear, sigh :D
09:04:32 <magical1> what does the // in ""a = bd // [(col, (bd ! col)]"" mean ?
09:07:45 <TheHunter> it's an array update. a is exactly like bd, but the element at position col is replaced with bd ! col.
09:08:30 <TheHunter> note that these array operations are more efficient for longer lists.
09:09:39 <magical1> TheHunter: how much longer?
09:10:55 <TheHunter> my statement was kind of confusing. such an operation usually has to copy the whole array and perform an update at the positions specified by the list.
09:11:46 <TheHunter> so if you find yourself frequently updating only one element of a long array, you're probably better of using a FiniteMap.
09:13:51 <wli> heh, 0.06s to do fib 9999 which beats the prior two O(lg(n)) implementations' speeds for map fib [0..20]
09:14:49 <wli> parity with let fib = 0 : 1 : zipWith (+) fib (tail fib) in take 21 fib
09:27:51 <atom-z> can I use matrices in haskell?
09:38:42 <musasabi> atom-z: yes, but there is no standardized fast matrix library.
09:51:39 <xerox> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf
09:52:02 <xerox> I think I saw that PI implementation on some link from here.. some obfuscated contest maybe?
10:08:22 <magical1> hello
10:16:57 <magical1> hi
10:17:32 <Nioate> magical1: hi
10:17:55 <magical1> Nioate: hi back
10:17:59 <magical1> ;)
10:19:04 <magical1>  @eval map (\x -> x + 1) [1,2,3]
10:19:34 <magical1> nope it must be turned off :((
10:20:41 <magical1> @yow
10:20:42 <lambdabot> I'm RELIGIOUS!!  I love a man with a HAIRPIECE!!
10:20:42 <lambdabot>  Equip me with MISSILES!!
10:20:47 <musasabi> @eval map (\x -> x + 1) [1,2,3]
10:20:47 <lambdabot> [2, 3, 4]
10:20:59 <musasabi> no spaces in the beginning of the line ;)
10:21:05 * magical1 forgot
10:21:12 <magical1> sorry
10:21:18 <magical1> @yow
10:21:18 <lambdabot> I pretend I'm living in a styrofoam packing crate, high in th'
10:21:18 <lambdabot>  SWISS ALPS, still unable to accept th' idea of TOUCH-TONE DIALING!!
10:21:50 <magical1> wb atom-z 
10:23:30 <atom-z> thanks
10:24:48 <magical1> np
10:26:26 <basti_> http://www.funpic.hu/swf/numanuma.html
10:26:29 <xerox> How does Int differ from Integer?
10:28:07 <MegaMonad> Tal: 2--3, tank: hello --- what's ..., binde: abe-kat.
10:28:22 <CosmicRay> MegaMonad: good afternoon.
10:28:24 <MegaMonad> CosmicRay: What if he continued working on a team.
10:28:30 <basti_> yes what if...
10:28:56 <magical1> hi CosmicRay, how are you today?
10:29:02 <Nioate> xerox: Integer is arbitrary-precision.
10:29:25 <xerox> Nioate, what does it mean?
10:30:00 <CosmicRay> hi magical1
10:30:11 <basti_> Integer would never overflow
10:30:13 <Nioate> Int has a fixed maximum and minimum value; Integer grows to fit as large an integer as you care to store in it
10:30:24 <Nioate> as long as you have enough memory
10:30:29 <basti_> (for small values of never)
10:30:32 <CosmicRay> try it
10:30:41 <CosmicRay> Prelude> 2 ^ 1024
10:30:41 <CosmicRay> 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
10:31:17 <xerox> Got it :D
10:31:30 <basti_> there was this guiness book entry about the largest number ever used in a mathematical proof
10:31:43 <xerox> What was it?
10:31:44 <Nioate> how large was it?
10:31:45 <basti_> it used five "arrows" i think
10:32:22 <basti_> where an arrow would be like the second parameter of the Ackermann Function
10:32:30 <basti_> raising the "grade" of the operation
10:32:38 <Nioate> http://mathworld.wolfram.com/ArrowNotation.html
10:33:10 <basti_> it was something looking harmless like 2 ^^^^^ 2 or so
10:33:50 <basti_> if you take its logarithm ,its still 2 ^^^^ 2 i think.
10:33:59 <basti_> which is a lot.
10:34:07 <Nioate> what kind of proof
10:34:14 <basti_> it was something about graph theory
10:34:27 <basti_> i didnt understand what it was about so i dont remember
10:34:41 <basti_> actually it was used as an upper bound.
10:35:13 <basti_> somebody else thinks the number in question is 6, what would make this number not only the largest ever used in a proof but also the most overestimated number ever.
10:36:27 <basti_> http://mathworld.wolfram.com/GrahamsNumber.html
10:36:31 <basti_> there it is
10:37:07 <basti_> oh actually its a lot more.
10:37:21 <Nioate> yes
10:37:23 <Nioate> a lot more
10:37:34 * basti_ nods
10:37:39 <basti_> bizarre thing.
10:37:51 <Nioate> that's unimaginably large
10:37:58 <Nioate> to me anyway
10:38:13 <basti_> it uses a special notation to make the arrow notation shorter
10:38:48 <basti_> its cool that you dont need to imagine this number.
10:52:05 <xerox> How was it called TheHunter's bot with @point-free thing?
10:52:33 <xerox> thbot, not online, sigh.
10:52:40 <CosmicRay> MegaMonad: thbot?
10:52:41 <MegaMonad> CosmicRay: Hmm, thbot not around?
10:52:48 <CosmicRay> MegaMonad: do you like thbot?
10:52:49 <MegaMonad> CosmicRay: Y i, pun on vi, and really start to see if i can do whatever you like thbot?
10:52:58 <thebug> MegaMonad: what's your view on wireless haskell robots of doom?
10:52:59 <MegaMonad> thebug: Oh my, i think haskell would make the problem you're solving is often used with industrial robots.
10:53:08 <CosmicRay> heh
10:53:43 <thebug> how big is MegaMonad's brain now?
10:53:51 <xerox> Is it possible to point-free something like f n = (g n, n) ?
10:54:14 <CosmicRay> lesse...
10:54:30 <CosmicRay> -rw-r--r--  1 jgoerzen jgoerzen 168M Jan 26 12:53 megahal.brn
10:54:40 <CosmicRay>   PID USER      PR  NI  VIRT  RES  SHR S PU %MEM    TIME+  COMMAND
10:54:40 <CosmicRay>  4282 jgoerzen  24   0  589m 588m 1480 S  0.0 66.5   0:43.66 megahal
10:55:23 <thebug> did you restart training it? I thought you said that you had something upwards of 1GB recently
10:55:41 <CosmicRay> thebug: my box has 1GB of ram
10:55:47 <CosmicRay> no, this is about where it's been.  slowly growing.
10:57:07 <thebug> ah, I see :)
10:57:15 <CosmicRay> MegaMonad: how big are you?
10:57:16 <MegaMonad> CosmicRay: But a i've got the idea of the entire set. The pairwise intersections must all be written piss-poor and run ghc -fno-code -fext-core on the head.
10:59:04 <lightstep> @eval 3 + 3
10:59:05 <lambdabot> 6
10:59:16 <CosmicRay> @eval 2 ^ 1024
10:59:16 <lambdabot> (line 1, column 3):
10:59:16 <lambdabot> unexpected "^"
10:59:16 <lambdabot> expecting operator, simple term or end of input
10:59:18 <lightstep> @eval (\f -> f f) (\f -> f f)
10:59:25 <xerox> bzzt
10:59:35 <lightstep> it didn't answer
10:59:38 <lambdabot> out of fuel - use @resume to continue
10:59:41 <CosmicRay> @eval foldr (*) [1..5]
10:59:42 <lambdabot> (line 1, column 8):
10:59:42 <lambdabot> unexpected "*"
10:59:42 <lambdabot> expecting simple term
10:59:43 <xerox> It will timeout or something
10:59:56 <xerox> @eval foldr1 (*) [1..5]
10:59:56 <lambdabot> (line 1, column 9):
10:59:56 <lambdabot> unexpected "*"
10:59:56 <lambdabot> expecting simple term
10:59:59 <CosmicRay> @eval foldr (*) 1 [1..5]
10:59:59 <lambdabot> (line 1, column 8):
10:59:59 <lambdabot> unexpected "*"
10:59:59 <lambdabot> expecting simple term
11:00:11 <xerox> @eval foldr1 (+) [1..5]
11:00:11 <lambdabot> (line 1, column 9):
11:00:11 <lambdabot> unexpected "+"
11:00:11 <lambdabot> expecting simple term
11:00:12 <lightstep> @type 1
11:00:13 <lambdabot> 1 :: forall t. (Num t) => t
11:00:21 <lightstep> @type foldr1
11:00:22 <lambdabot> foldr1 :: forall a. (a -> a -> a) -> [a] -> a
11:00:40 <lightstep> @eval foldr1 (*) [1..5]
11:00:40 <lambdabot> (line 1, column 9):
11:00:40 <lambdabot> unexpected "*"
11:00:40 <lambdabot> expecting simple term
11:01:07 <xerox> @eval foldr1 simple-term [1..5]
11:01:07 <lambdabot> (line 1, column 23):
11:01:07 <lambdabot> unexpected "."
11:01:07 <lambdabot> expecting simple term
11:01:11 <xerox> :P
11:01:29 <lightstep> @eval foldr1 simple term [1..5]
11:01:29 <lambdabot> (line 1, column 23):
11:01:29 <lambdabot> unexpected "."
11:01:29 <lambdabot> expecting simple term
11:01:51 <CosmicRay> heh
11:01:56 <CosmicRay> MegaMonad: do you like simple terms?
11:01:57 <MegaMonad> CosmicRay: Reminds me of a head and they kinda dislike alignment changes... It could be under the terms have been i had laying around.
11:02:29 <CosmicRay> MegaMonad: that was more difficult to understand than the documentation of arrows fed through the chef filter.
11:02:30 <MegaMonad> CosmicRay: (Ouch, by the lord of the arrows have to fight endlessly to get my head is spinning :) ill just write the painfully clear version, then show how the ct concept without having people make it difficult, but i don't try to be fed to the documentation. There's a tour of the code.
11:03:27 <xerox> Why is it called foldr1?
11:04:12 <lightstep> it's like foldr, but instead of allowing empty list and requiring right identity, it requires non-empty lists
11:04:29 <xerox> Why 1?
11:04:34 <lightstep> it's more like reduce (if it's on the library)
11:04:43 <xerox> I initially supposed that the identity was 1 in foldr1
11:04:47 <xerox> But it's not
11:04:55 <lightstep> the 1 is the naming convention for such things in PreludeList
11:05:05 <xerox> Ah okay
11:11:57 <xerox> dinnertime, later folks :D
11:18:38 <lightstep> what was the rationale of making the functions with more specific types have shorter names? like fmap vs. map or generic* from List?
11:19:13 <CosmicRay> just a guess: they probably existed first
11:29:43 <wolfman8k> hello
11:30:45 <humasect> hi
11:31:09 <wolfman8k> gotta go eat :D
11:31:24 <wolfman8k> maybe someone can help me with these HGL install problems when i come back =)
11:56:34 <balbo_> a question about types. what are the types of the operands in the expression 5+5.5 ?
11:57:01 <balbo_> or is that the wrong question?
11:57:30 <balbo_> @type (+)
11:57:31 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
11:57:44 <balbo_> says that they should have the same type, yes?
11:58:03 <lightstep> you can have (5 :: Float) + (5.5 :: Float)
11:58:22 <balbo_> @type (5+5.5)
11:58:23 <lambdabot> (5+5.5) :: forall a. (Fractional a) => a
11:58:33 <lightstep> but there is a special case for the reader+typechecker for numbers
11:58:45 <lightstep> with the keyword default
11:59:19 <balbo_> could i add anything that belongs to the num class?
11:59:55 <balbo_> i mean different types, as long as they both belong to the Num class. or is there some coersion that will take place?
12:00:16 <lightstep> there is fromInt or something
12:00:25 <balbo_> yes
12:01:25 <balbo_> but it seems that sometimes haskell can coerce the types anyway,
12:02:36 <musasabi> balbo_: yes you can define new types of numbers.
12:04:00 <lightstep> generally (that is, if the numbers aren't in the source), you have to coerce yourself: fromInteger, fromRational, 
12:04:12 <balbo_> musasabi: in hudaks book, there is an expression written 'time + 5' that works!
12:04:43 <musasabi> balbo_: yes. 
12:04:56 <balbo_> how can that be?
12:05:29 <lightstep> it's probably being read as time + (5::Time)
12:05:40 <lightstep> err, that is (fromInteger 5)
12:05:41 <balbo_> time is of type  time :: Behavior Time
12:05:44 <musasabi> balbo_: because int constants are actually a shorthand for "fromInteger :: Integer -> a"
12:06:24 <musasabi> balbo_: time + (fromInteger 5  :: Behavior Time)
12:06:34 <balbo_> and > newtype Behavior a = Beh (Time -> a)
12:06:52 <balbo_> > type Time = Float
12:07:23 <lightstep> it's represented like that? how can it handle dense events and so on?
12:07:41 <balbo_> dense events, what do you mean with that?
12:08:30 <lightstep> actually, the problem is with infinitely-changing behaviors. like taking the lowest bit
12:09:03 <lightstep> probably, if you try to observe such thing you'll fall into numerical inaccuracy
12:09:30 <balbo_> lightstep: who you talkin to?
12:09:54 <balbo_> you lost me..
12:10:20 <lightstep> (i didn't read the book) i'm talking to myself
12:10:33 <balbo_> oh, that's ok!
12:12:33 <balbo_> musasabi: but how can fromInteger 5 be coerced to Behavior Time?
12:22:42 <balbo_> @type 5
12:22:43 <lambdabot> 5 :: forall t. (Num t) => t
12:22:51 <balbo_> @type 5.5
12:22:52 <lambdabot> 5.5 :: forall t. (Fractional t) => t
12:23:23 <balbo_> how come i can add 5 + 5.5
12:23:26 <balbo_> ?
12:23:34 <balbo_> different types
12:26:10 <musasabi> balbo_: typeclass != type.
12:26:27 <musasabi> there are many types which are both Fractional and Num.
12:26:35 <musasabi> @type 5 + 5.5
12:26:36 <lambdabot> 5 + 5.5 :: forall a. (Fractional a) => a
12:26:56 <musasabi> and Fractional requires an Num instance too.
12:27:01 <balbo_> @type (+)
12:27:02 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
12:27:16 <balbo_> this says that the operands need to have the same type
12:29:08 <chutwig> Num is a typeclass, not a specific type
12:29:31 <balbo_> yes but 'a' is a type in that expression.
12:29:35 <chutwig> so it can accept any operands that fall under class Num
12:30:06 <balbo_> chutwig: that sound incredible
12:30:10 <magical1> @type Array
12:30:11 <lambdabot> bzzt
12:30:20 <magical1> gurrrr
12:30:31 <magical1> @yow
12:30:31 <lambdabot> These PRESERVES should be FORCE-FED to PENTAGON OFFICIALS!!
12:31:02 <magical1> @type Maybe
12:31:03 <lambdabot> bzzt
12:31:11 <musasabi> magical1: look under Data.Array for immutable arrays and Data.Array.{IO,ST} for mutable arrays.
12:31:35 <magical1> can someone explain what a Maybe is please?
12:31:39 <magical1> musasabi: thanks
12:32:00 <xerox> A monad, I think
12:32:18 <magical1> thanks
12:32:20 <chutwig> i'm trying to pick haskell up so i can use it for some automata kajiggery
12:32:22 <Heffalump> it's a monad, but that fact is usually not all that useful.
12:32:22 <musasabi> magical1: data Maybe a = Nothing | Just a
12:32:33 <Heffalump> it allows you to express the absence of a value.
12:32:53 <chutwig> it's a little different when you work with nothing but java and C#
12:33:56 <magical1> so I could use it define a place on a board where a peice might be or else it might be empty?
12:34:59 * magical1 only works with html php and just starting java, let alone getting to grips with Haskell
12:35:17 <chutwig> but i figured hey, if there's one thing functional languages are good at, it's list insanity
12:35:29 <balbo_> let's look at comparison. in the expression 5>4 there would be an integer comparison. what about 5>4.4 ?
12:35:29 <magical1> but I did start with Scheme when i was about 11 so I should be able to do this
12:35:41 <chutwig> these graphs i've been modelling look like they were just made to be represented in haskell
12:35:57 <magical1> lucky you
12:36:12 <magical1> I have to reinvent the wheel ..... :(
12:38:10 <chutwig> can somebody explain => as opposed to -> for me in types?
12:38:20 <chutwig> i see that the distribution isn't random, but i can't figure out the pattern
12:38:47 <xerox> chutwig, typeclass opposed to "returns"
12:39:02 <musasabi> chutwig: a type signature is expressed as name :: (possibly empty list of typeclasses) => type1 -> ... -> typeN
12:40:10 <magical1> mussabi may I pm you some code and ask for some pointers, I don't want to flood the channel?
12:40:29 <chutwig> so in reality a function like length that has a signature of length :: [a] -> Int
12:40:41 <chutwig> it's more like length :: [] => [a] -> int?
12:40:44 <xerox> @type length
12:40:45 <lambdabot> length :: forall a. [a] -> Int
12:41:21 <chutwig> and the [] => is being removed because it's unnecessary
12:42:09 <Heffalump> it would be () => 
12:42:10 <Heffalump> but yes
12:42:16 <chutwig> okay
12:42:25 <chutwig> i'll have to ruminate on that for a bit
12:43:07 <magical1> @type BitBoard
12:43:08 <lambdabot> bzzt
12:43:15 <xerox> @type bzzt
12:43:16 <lambdabot> bzzt
12:43:23 <magical1> argggghhhhhhhhhhh!!!!!!!!!!
12:43:26 <chutwig> what an adorable robutt
12:43:29 <xerox> ^_^
12:43:38 <wolfman8k> when i try to compile HGL it says
12:43:39 <wolfman8k> make[1]: *** No rule to make target `boot'.  Stop.
12:43:43 <chutwig> does it like botsnacks
12:43:48 * magical1 cuts open lambdabot witha pickle and pulls out its insides
12:44:32 <wolfman8k> MegaMonad: How do I install HGL?
12:44:33 <MegaMonad> wolfman8k: I should give you everything that is a graph that tells you when i install hgl?
12:44:46 <magical1> gurrrrr i was hoping it would be full of logic not lambda calculus  :(
12:45:40 <chutwig> if(query.issuer.equals(magical1)) return "bzzt";
12:46:25 * basti_ has an auflauf
12:46:36 * magical1 looks at the razor sharp pickle and then glances at chutwig ;)
12:47:14 <chutwig> auflÃ¤ufer are nasty in any language
12:47:35 <basti_> which language has auflaufs too?
12:47:40 <Oejet> MegaMonad: What is Kaper?
12:47:41 <MegaMonad> Oejet: I don't know kaptajn kaper i kattegat.
12:47:47 <Oejet> Ok.
12:47:48 <chutwig> i mean the concept of the auflauf
12:47:52 <chutwig> you mean casserole, right?
12:48:01 <basti_> yes
12:48:05 <chutwig> right
12:48:06 <basti_> thats the word
12:48:07 <chutwig> casseroles are gross
12:48:11 <basti_> hey.
12:48:42 <chutwig> haben wir jetzt 'nen leckeren tuna-auflauf
12:48:44 <basti_> not with garlic & ham & porridge (??) & onions
12:48:48 * magical1 realises this is a Mc Donalds hamburger pickle, instead of the swiss army variety ...... 
12:49:25 <basti_> oh mcd hamb pickles are fun
12:49:43 <basti_> you can use the mcd straws to flick them at the ceiling.
12:50:01 <magical1> if (query.issuer.equals(magical1)) boot user; ......... hummmmmmmm
12:50:08 <basti_> they'd soften the mcd styrofoam and stick there
12:50:25 <magical1> you can use them to glue people to their seats too
12:50:29 <basti_> yes.
12:50:33 <basti_> but thats not nics.
12:50:34 <basti_> e
12:50:59 <magical1> serves them right for flicking milkshake at me
12:51:23 <basti_> did you know you can suck a gradient into the mcd milkshake surface?
12:51:43 <basti_> i wonder how that stuff behaves in a microwave
12:51:52 <chutwig> mcdonald's milkshakes are neither milk nor shaken >:o
12:52:24 <basti_> probably they are bubbled agar agar with soy oil or something
12:53:11 <chutwig> now i want to go to wendy's and get a frosty, though
12:53:14 <basti_> the perl thingy in my haskore -> perl thingy -> csound arrangement sucks up all processor time left.
12:54:41 <basti_> i smell a connection
12:57:41 * magical1 wishes they had wendys here .......
12:58:21 <chutwig> i like making lunch out of a baked potato and caesar side salad there
12:58:30 <chutwig> 2 bucks goes pretty far at wendy's
12:58:30 * basti_ wishes he had already moved. He sees dark clouds rising
12:59:00 <shapr> d00d
12:59:10 <shapr> ich habe keine ahnung!
12:59:17 <basti_> auflauf?
12:59:22 <chutwig> i think that's about 0.15 euros 
12:59:35 <shapr> talar du svenska ocksÃ¥?
12:59:45 <chutwig> nobody likes the swedish :o
12:59:53 <shapr> spreichen Sie svenska auch?
12:59:54 <basti_> if the exchange rate has a good day you mean? :P
13:00:00 <shapr> dang, what's the word for swedish in german?
13:00:07 <basti_> schwedisch
13:00:17 <basti_> german is just like english.
13:00:20 <shapr> oh, thanks.
13:00:27 <chutwig> basti_: you could buy a mac mini for about 3 euros
13:00:28 <shapr> Except where it's different ;-)
13:00:53 <basti_> chutwig: you think?
13:01:20 <chutwig> travelling overseas sucks for me now, though :(
13:01:26 <shapr> Why?
13:01:29 <chutwig> i went back to england and felt ripped off everywhere i went, even more than usual
13:01:55 <Heffalump> it's not our fault the dollar isn't worth anything ;-)
13:01:59 <basti_> i was in australia and it was really cheap :)
13:02:12 <basti_> actually money is just an idea.
13:02:13 <shapr> I was in ... well. I haven't been anywhere.
13:02:17 <shapr> Never mind.
13:02:20 <chutwig> it's like, let's go to marks and sparks and buy a frozen dinner for Â£4
13:02:21 <basti_> =)
13:02:29 <basti_> -g-
13:02:32 <chutwig> Â£4 by itself seems reasonable enough to me, i know how much a pound is worth
13:02:34 <shapr> chutwig: hey, do you know Haskell?
13:02:45 <chutwig> shapr: no, i've never met him
13:02:54 <basti_> o0
13:02:55 <shapr> That's cuz he's dead.
13:03:04 <Heffalump> I don't shop at Marks and Sparks, but £4 might be a bit cheap for them.
13:03:08 * shapr throws an insensitive clod at chutwig 
13:03:20 <chutwig> Heffalump: so Â£4 is okay, but when i convert that back into USD, that's like 8 bucks
13:03:32 <shapr> There's an easy solution. Move outta the USA.
13:03:36 <chutwig> so i just got roundly ripped off
13:03:42 <basti_> australia is nice.
13:03:46 <basti_> really.
13:03:49 <chutwig> no, the easy solution is to stay here and pay a lot less
13:03:58 <basti_> <-                          o <- you are here               ->
13:04:02 <Heffalump> no, you didn't get ripped off, because that's what it costs to make it in the UK.
13:04:05 <shapr> Wel, ok then.
13:04:25 <shapr> chutwig: quick, how do I turn a datatype into an arrow?
13:04:32 <chutwig> i have no idea, ask somebody who
13:04:38 <chutwig> knows
13:04:46 <chutwig> i'm in the process of learning haskell
13:04:52 <Heffalump> make sure it takes at least two type arguments and implement the arrow operations for it.
13:04:53 <balbo_> how is overloading resolved in haskell?
13:04:53 <shapr> dang
13:05:03 <xerox> From the strange-links-department, the parametric function to draw the heart: http://mathworld.wolfram.com/himg1283.gif
13:05:25 <shapr> balbo_: you pass around a dictionary until the last minute when you have to figure it out.
13:05:42 <balbo_> i'm thinking about the expression 5>4.4
13:06:00 <Heffalump> that's complicated, because of the defaulting rules for literals
13:06:19 <shapr> Fractional is the most specific class there, I think.
13:06:25 <Heffalump> 5 > 4.4 gets parsed as fromIntegral 5>fromFloating 4.4, or something like that
13:07:11 <balbo_> i have created a little function 
13:07:17 <wolfman8k> shapr: hi, i can't get HGL installed :(
13:07:30 <shapr> you're using Debian/unstable?
13:07:34 <balbo_> comp1 x y = if x>y then x else y
13:07:52 <shapr> if so, install ghc-cvs, it comes with HGL
13:07:54 <chutwig> you know there's a function max that already does that
13:07:59 <wolfman8k> shapr: no
13:08:13 <balbo_> chutwig: well it's just for educational purposes.
13:08:18 <chutwig> fair enough
13:08:20 <shapr> right, typechecking is fun.
13:08:25 <wolfman8k> shapr: i downloaded HGL source but when i run make i get
13:08:25 <wolfman8k> make[1]: *** No rule to make target `boot'.  Stop.
13:08:42 <balbo_> so comp1 1 1.0 will return 1.0::Double
13:08:52 <balbo_> how come?
13:08:55 <shapr> wolfman8k: it's a real PITA to build HGL.
13:09:11 <shapr> @type 1.0
13:09:12 <wolfman8k> shapr: hm...
13:09:13 <lambdabot> 1.0 :: forall t. (Fractional t) => t
13:09:21 <Heffalump> @type 1
13:09:22 <lambdabot> 1 :: forall t. (Num t) => t
13:09:25 <chutwig> balbo_: probably because Int is being kicked up to Fractional because going the other way would result in a loss of precision
13:09:27 <basti_> balbo_: humm
13:09:34 <shapr> @type >
13:09:35 <lambdabot> bzzt
13:09:37 <Heffalump> presumably Double is the default for Fractional?
13:09:39 <shapr> @type (>)
13:09:40 <lambdabot> (>) :: forall a. (Ord a) => a -> a -> Bool
13:09:41 <wolfman8k> shapr: when i run make from a deeper dir i get:
13:09:42 <wolfman8k> ghc-6.2.1: unknown package name: X11
13:09:53 <balbo_> so there are som rules to this? where can i read about them?
13:09:56 <magical1> @type(==)
13:09:57 <lambdabot> Sorry, I don't know the command "type(==)", try "lambdabot: @listcommands
13:10:01 <magical1> @type (==)
13:10:02 <lambdabot> (==) :: forall a. (Eq a) => a -> a -> Bool
13:10:04 <basti_> balbo_: hmmmmmm
13:10:12 <Heffalump> wolfman8k: look up the defaulting rules in the report
13:10:15 <chutwig> balbo_: i don't know an exact list, but it's kind of common sense
13:10:15 <magical1> @type (!=)
13:10:16 <lambdabot> bzzt
13:10:30 <basti_> well what do we have
13:10:32 <Heffalump> sorry, s/wolfman7k/balbo_/
13:10:38 <basti_> we have Eq a
13:10:38 <chutwig> that if dealing with an integer and a double, make the integer a double, because making the double an integer would probably result in the truncation of something important
13:10:38 <shapr> balbo_: figure out typeclasses, then look at the typeclass hierarchy in the report. Then look at the papers on typeclasses.
13:10:40 <wolfman8k> Heffalump: ?
13:10:41 <shapr> That's what I would do at least.
13:10:42 <magical1> how do I do not equals?
13:10:42 <Heffalump> wolfman8k: do you have that installed?
13:10:48 <Heffalump> magical1: (/=)
13:11:03 <balbo_> shapr: that will teach me the defaulting rules?
13:11:05 <magical1> Heffalump: thanks 
13:11:06 <basti_> ah
13:11:17 <wolfman8k> Heffalump: i downloaded this HSX11-1.00 package but it won't compile either :(
13:11:20 <shapr> wolfman8k: HSX11 will require green-card next.. and they're a pain to build as well.
13:11:23 <basti_> hows > defined with different types on each side?
13:11:31 <shapr> It's not.
13:11:41 <basti_> see
13:11:46 <wolfman8k> doesn't ghc come with green-card?
13:11:56 <basti_> so the type system would force the other number to be interpreted as a floating point wouldnt it?
13:11:58 <shapr> I don't think so. It depends on your installation I think.
13:12:03 <balbo_> something has to be coerced.
13:12:06 <shapr> right
13:12:13 * shapr quickly coerces balbo_ 
13:12:30 <balbo_> and it seems to be that the integer becomes coerced into a Double.
13:12:35 <basti_> what would happen if you do "comp1 1::Int 0::Double"?
13:12:39 * wolfman8k installs green-card
13:12:49 <shapr> hej balbo_, gÃ¥r du till chalmers?
13:12:49 <Heffalump> that'd be a type error, if you used brackets appropriately.
13:12:50 <balbo_> basti_: there would be an error
13:12:51 <basti_> this would most probably result in a type error
13:13:04 * magical1 needs more caffine
13:13:08 <balbo_> shapr: no
13:13:09 <basti_> Heffalump: :)
13:13:10 <magical1> brb
13:13:11 <Heffalump> there isn't any coercion going on, except what always happens with literals.
13:13:13 <shapr> oh, ok.
13:13:15 <balbo_> shapr: do you?
13:13:25 <Heffalump> if you put 1 in a program, it is treated like (fromIntegral 1)
13:13:26 <basti_> yup
13:13:29 <Heffalump> :t fromIntegral 1
13:13:30 <shapr> Nope, I'm a self-employed programmer.
13:13:35 <Heffalump> @type fromIntegral 1
13:13:37 <lambdabot> fromIntegral 1 :: forall b. (Num b) => b
13:13:50 <shapr> Heffalump: I type @type into ghci :-)
13:13:55 <Heffalump> :-)
13:14:00 <shapr> balbo_: are you in school?
13:14:23 <balbo_> shapr: no i'm a working programmer. but not in haskell unfortunately....
13:14:56 <shapr> cool, where ya work?
13:15:42 <shapr> I'm half-owner of webwitches.com
13:15:45 <balbo_> shapr: well, i had my own firm but now i'm unemployed. do you have something for me maybe? preferably haskell...
13:16:01 <shapr> heh, I wish.
13:16:13 <shapr> I make most of my money with Python.
13:16:19 <shapr> But I'm slowly getting some Haskell biz.
13:16:56 <balbo_> are you a consultant?
13:17:12 <shapr> Not sure what consultant means really.
13:17:30 <shapr> I mostly make EU project websites, but I get all sorts of contract work.
13:18:01 <balbo_> shapr: ok so you do contract work. i guess that makes you a kind of consultant.
13:18:02 <shapr> Does that count as a consultant?
13:18:06 <shapr> Ok, cool.
13:18:24 <balbo_> how do you get those contracts?
13:18:43 <shapr> I have a record of saving people's butts at the last minute, no matter what they ask me to do.
13:18:58 <wolfman8k> i get an error when compiling greencard:
13:18:58 <wolfman8k> ghc-6.2.1: unrecognised flags: -fno-prune-tydecls
13:19:08 <shapr> So I end up with all sorts of weird requests, and some of them turn into regular work.
13:19:13 <shapr> wolfman8k: whack that out of the Makefile
13:19:18 <shapr> it's gone in 6.2
13:19:32 * wolfman8k whacks
13:19:47 <balbo_> that's good. do you make a lot of money or not?
13:20:37 <shapr> I usually make the same (small) amount of money every year, because I work until I have enough, and then I screw around and learn new stuff and write open source code.
13:20:45 <shapr> It's great :-)
13:20:55 <balbo_> are you running from a linux box now?
13:20:59 <shapr> yup
13:21:06 <balbo_> what distro?
13:21:07 <shapr> I don't have a copy of windows.
13:21:13 <shapr> debian/unstable
13:21:32 <balbo_> well i got windows with my computer so might as well use it
13:21:34 <Heffalump> how long does it take you to have enough? :-)
13:21:42 <shapr> That depends on the year.
13:21:47 <wolfman8k> alright, greencard compiled and installed
13:21:50 <shapr> balbo_: windows is not conducive to being a better programmer.
13:22:25 <shapr> This is my opinion, of course. I've heard that some people learned to be good programmers on windows.
13:22:32 <shapr> Anyone here learned programming on windows?
13:22:53 * basti_ learned programming on HP 41 C
13:22:56 * shapr honestly doesn't know
13:22:57 <balbo_> yes, you got all the tools so why not.
13:22:57 * Heffalump did
13:22:57 <boegel> shapr: how do you mean ?
13:23:12 <balbo_> i've got hugs, ghc, you name it.
13:23:20 <basti_> actually windows sucks where it should rule.
13:23:24 * boegel did to (pascal, java, c, now haskell)
13:23:30 <basti_> namely, i tried to develop a directx program
13:23:32 <shapr> I think shell scripting is something that windows misses out on .
13:23:47 <xerox> What about BATCH files? :-D
13:23:52 <boegel> shapr: they're planning that on the new version, longhorn
13:23:55 <balbo_> nobody in their right mind would create a shell script nowadays.
13:24:03 <boegel> it'll be heaven for virus writers
13:24:07 <shapr> balbo_: you must be joking!
13:24:11 <wolfman8k> windows sucks
13:24:13 <wolfman8k> unix sucks
13:24:13 <shapr> I write shell scripts all the time.
13:24:19 <shapr> They're really useful.
13:24:19 <balbo_> shapr: no man!
13:24:35 <shapr> I can write a minimal spellchecker in one line of shellscript
13:24:37 <balbo_> shapr: i would prefer to do it in ruby or even python.
13:24:51 <balbo_> shapr: that even makes it portable!
13:25:13 * shapr thinks about that
13:25:35 <balbo_> yepp, think about it man.
13:25:38 <shapr> Well, it's not portable to a computer that doesn't have python or ruby installed.
13:25:57 <balbo_> well you need to install a shell as well...
13:26:06 <shapr> Also, you can only work with code that's written in that language.
13:26:17 <Oejet> Yeah, go shapr, go shapr!
13:26:22 <shapr> I think there's an advantage to having a shareable format.
13:26:40 <shapr> I don't think unix' list of lines is the best choice, but it was a huge step forward when they came up with it.
13:27:05 <shapr> The shellscripting pipeline is a lot like a monad.
13:27:11 <balbo_> i don't follow you, but you're supporting my view i guess...
13:27:19 <shapr> Actually, I'm arguing against it.
13:27:23 <balbo_> that all scripts should be written i ruby...
13:27:38 <balbo_> very easy to read and a powerful language
13:27:42 <balbo_> as well
13:27:45 <shapr> My argument is that no single language is good enough to do everything.
13:27:55 <wolfman8k> not even lisp?
13:27:58 <mattam> especially not OO languages :)
13:28:01 <shapr> And that shellscripting is a powerful intermediate.
13:28:02 <balbo_> well shells are a very simple language
13:28:10 <shapr> but they can do a lot.
13:28:11 <boegel> mattam: I _hate_ OO since yesterday :)
13:28:14 <balbo_> ruby is a good choice for that kind of work
13:28:22 <balbo_> try it...you like it
13:28:27 <shapr> I have tried ruby.
13:28:38 <shapr> I wrote five or six pages of Ruby, but I didn't like it.
13:28:38 <balbo_> some people prefer to do their scripting in perl
13:28:45 * Oejet likes OO, when he rolls his own in Scheme.
13:29:06 <balbo_> shapr: not even as a replacement for shell scripts?
13:29:10 <shapr> I do like the OO model in Ruby, it's superior to Python. I don't like the lack of higher order functions, anonymous lambdas, and I really hate explicit END
13:29:29 <magical1> I have to give up for the moment my head hurts
13:29:31 <magical1> I'll try again at 8:30 tomorrow morning
13:29:31 <wolfman8k> help! when i try to compile HSX11 i get this error:
13:29:32 <wolfman8k> make: execvp: Graphics/X11/Types.gc: Permission denied
13:29:35 <shapr> No, I don't think ruby has a big advantage over zsh scripting for example.
13:29:35 <magical1> bye guys
13:29:46 <shapr> magical1: come back soon! :-)
13:29:55 <balbo_> zsh scripting sounds very esoteric.
13:30:00 <tuomov> zsh sucks
13:30:03 <xerox> But powerful
13:30:07 <shapr> just the first example that came to mind.
13:30:09 <xerox> Like sed & awk :D
13:30:31 <balbo_> yes i see...
13:30:34 <SyntaxNinja> hi all
13:30:55 <shapr> y0 SyntaxNinja 
13:30:59 * tuomov has bitter sentiments towards zsh as the people who administer this machine refuse to install bash and I'm forced to use zsh
13:31:02 <balbo_> well i still prefer to master one language really well and do all my scripting with it. i'n my case it's ruby.
13:31:09 <tuomov> and it just sucks
13:31:13 <shapr> I prefer to master a whole bunch of languages.
13:31:18 <balbo_> ruby= my scripting language of choice.
13:31:36 <xerox> what comes handy in that situation = my language of choice
13:31:52 <shapr> yeah, I like that choice.
13:31:54 <balbo_> shapr: well i'm talking about scripting here.
13:32:26 <shapr> Ok, if you like scripting with ruby, I think it's a good choice.
13:32:28 <balbo_> there are other situations where i would prefer to compile my code of course
13:32:45 <wolfman8k> i like php for scripting
13:32:46 <shapr> I've been playing with scripting in Haskell, it's suprisingly effective.
13:32:54 <balbo_> but as a substitute for shell scripts, i mean
13:33:10 <shapr> Yes, I've been trying Haskell in place of shell scripts.
13:33:13 <balbo_> yes i've been thinking about that too. but i'm not good enough in haskell
13:33:35 <balbo_> and io is a bit harder to learn in haskell
13:33:37 <shapr> There are some neat libraries around that make haskell shell scripting easier.
13:33:58 <balbo_> and that's about the whole point with scripting. a lot of io
13:33:58 <shapr> Monads are deceptively simple.
13:34:15 <balbo_> shapr: yes. but i haven't come to that chapter yet
13:34:23 <shapr> yeah, but shell scripting as it exists right now fits into the Haskell IO model.
13:34:30 <balbo_> i'm still trying to understand how 5>4.4 is handled...
13:34:43 <shapr> That is, you could declare a monad instance for unix pipes.
13:34:55 <wolfman8k> shapr: i've been letting the yampa stuff soak into my head. i like it
13:35:04 <shapr> yeah, yampa r0xx0rs
13:35:13 <shapr> I banged my head on it for months.
13:35:20 <balbo_> have to run away for a while...
13:35:33 <wolfman8k> shapr: i figure once i start coding with yampa i'll pick it up quickly enough
13:35:45 <shapr> Yeah, I think so too.
13:35:52 <shapr> But arrows really threw me for awhile.
13:36:08 <wolfman8k> hm.... HSX11 gave the strangest compile error
13:36:12 <shapr> I think I've got 'em now.
13:36:16 <shapr> I sure hope so.
13:36:49 <xerox> shapr, are you talking of >>= ?
13:37:11 <boegel> wolfman8k: are you root ?
13:37:18 <wolfman8k> boegel: not yet
13:37:23 <shapr> y0 Binkley, long time no see.
13:37:26 <boegel> try installing it as root
13:37:27 <Binkley> hey
13:37:35 <wolfman8k> boegel: i'm getting a different error now, not that permission one
13:37:45 <shapr> Binkley: which city are you in now?
13:37:52 <boegel> wolfman8k: oh ok
13:37:54 <shapr> Are you still at Bezerkely?
13:38:34 <wolfman8k> check this error:
13:38:35 <wolfman8k> ghc-split:Failed writing /tmp/ghc13413.split__1.s
13:38:35 <wolfman8k> <<ghc: 717937900 bytes, 278 GCs, 5166074/9405452 avg/max bytes residency (14 samples), 25M in use, 0.00 INIT (0.00 elapsed), 8.06 MUT (33.82 elapsed), 4.26 GC (5.29 elapsed) :ghc>>
13:38:35 <wolfman8k> make: *** [Graphics/X11/Types.o] Error 1
13:38:49 <boegel> wolfman8k: root ? :)
13:38:53 <wolfman8k> boegel: no
13:38:58 <Heffalump> hi Binkley
13:39:05 <boegel> wolfman8k: this seems like a permission error to, no ?
13:39:14 <Heffalump> wolfman8k: did you check for disk space?
13:39:25 <shapr> why wouldn't it be able to write to /tmp?
13:39:38 <boegel> shapr: yeah :) kinda weird :)
13:39:41 <Heffalump> because the disk was full?
13:40:01 <boegel> wolfman8k: yeah, what Heffalump said is more likely :)
13:40:13 <wolfman8k> Heffalump: i have 6 meg free
13:40:30 <wolfman8k> Heffalump: and i monitor it during that command execution and it doesn't drop below the 6
13:41:34 <Heffalump> can you reproduce the error by running the specific command that fails?
13:41:55 <Binkley> shapr: I'm still in Berkeley
13:42:14 <basti_> my mv juice tastes strange
13:42:58 <shapr> mv juice? is that like a unix geek's flavor of energy drink?
13:43:12 <shapr> Good name for it, in any case.
13:43:45 <wolfman8k> Heffalump: yeah
13:43:46 <wolfman8k> /usr/bin/ghc -H16m -O -cpp -fglasgow-exts -fffi -Iinclude -package-name X11 -O -Rghc-timing  -package greencard  -package haskell98 -split-objs    -c Graphics/X11/Types.hs -o Graphics/X11/Types.o  -ohi Graphics/X11/Types.hi
13:43:51 <basti_> uhm multi vitamin juice
13:43:54 <Heffalump> on linux, is this?
13:44:45 <shapr> Binkley: how's code?
13:44:45 <wolfman8k> Heffalump: yes
13:44:58 <Binkley> shapr: which code?
13:44:59 <Heffalump> do you know how to use strace?
13:45:13 <wolfman8k> Heffalump: sort of
13:45:42 <shapr> I dunno, what have you been working on lately?
13:46:54 <Binkley> shapr: trying to write livejournal toys in haskell, and finding wxhaskell inadequate :-D
13:47:01 <shapr> heh, ok then.
13:47:05 <shapr> Got any sources online?
13:47:11 <shapr> lj toys sound  cool.
13:47:29 <Heffalump> is that what your super sekrit project is? :-)
13:47:30 <Binkley> not yet
13:47:33 <Binkley> nothing releasable
13:47:38 <Binkley> yeah, that's my super sekrit project
13:47:56 <Binkley> However, I may switch to using the language that my new employer invented
13:48:00 <shapr> ?
13:48:04 <shapr> Who's your new employer?
13:48:07 <Binkley> http://www.openlaszlo.org/ if you're curious
13:48:09 <Binkley> Laszlo Systems
13:48:12 <shapr> ah, that one.
13:48:28 * Heffalump not very impressed with your super sekrit keeping skills :-)
13:49:12 <shapr> lambda-the-ultimate has mentioned Laszlo a few times.
13:49:37 <Binkley> well, i didn't say what kind of toy it was :-)
13:49:44 <Heffalump> true :-)
13:51:00 <wolfman8k> ok, i freed some space and now make goes a bit further
13:53:42 <stepcut> netflix should combine their knowledge of where you live, with their knowledge of what you like to watch to form a dating service, they can use the slogan "You may not like your date, but at least your like the movie" (ok, it needs a bit of refinement, but you get the idea...)
14:00:05 <wolfman8k> please help, i get this error now with HSX11: http://rafb.net/paste/results/DIvAJQ82.html
14:01:00 <shapr> oh I had that error.
14:01:06 <shapr> And I fixed it too.
14:01:08 * shapr thinks
14:03:11 <shapr> I *think* I just switched all the Ptr types to FinalizePtr, but I'm not sure about that.
14:04:46 <shapr> CosmicRay: Dominic Steinitz wrote an LDAP client
14:05:13 <shapr> CosmicRay: there are several ncurses libs. Written by Igloo, Richard Braakman, John Meacham
14:05:14 <wolfman8k> shapr: hm... so what exactly should i change?
14:05:41 <shapr> wolfman8k: I don't remember, I'm hoping I still have a local copy I modified.
14:05:47 <wolfman8k> ok thanks
14:06:26 <shapr> the sad part is that I can locate Region.hs but not Region.o :-(
14:06:31 <shapr> That's not a good sign.
14:07:07 <shapr> I can only find a compiled version of Region in Igloo's ghc-cvs 6.3 debs.
14:07:18 <wolfman8k> you installed HSX11 from source and not from apt?
14:07:28 <shapr> The first time, yes.
14:07:50 <shapr> At least, I think I ended up installing it. I know it was a royal pain and I switched to ghc-cvs debs.
14:08:17 <wolfman8k> maybe i should install debian :P
14:09:36 <shapr> Might be faster =)
14:10:00 <wolfman8k> :O
14:10:36 <wolfman8k> this is why i hate linux so so much. it's absolutely horrrrrible this shit :'(
14:11:04 <shapr> They talked about this problem on the Yampa list recently...
14:11:06 * shapr checks archives
14:12:32 <SyntaxNinja> so sometimes, I'm compiling a bunch of stuff...
14:12:37 <SyntaxNinja> and it says "Compilation not required"...
14:12:42 <SyntaxNinja> but then it just sits there for like, 20 seconds.
14:12:48 <shapr> coffee break?
14:12:51 <SyntaxNinja> so what's it doing? is this just Make taking a long time to figure out what to do next?
14:13:51 <wolfman8k> i recently heard that eclipse ide compiles your java code as you type. there should be a haskell ide that does this
14:14:01 * shapr thinks about that.
14:14:10 <SyntaxNinja> MegaMonad: any ideas about compilation time?
14:14:11 <MegaMonad> SyntaxNinja: Compilation of it is the time what i did... Sorry, didn't realise.
14:14:14 <shapr> wolfman8k: oh oh! I know how!
14:14:34 * CosmicRay looks back in
14:15:01 <CosmicRay> shapr: I found research papers on Dominic's LDAP client, but no code anywhere.  Just a request from 2001 wher ehe said there wasn't code yet
14:15:04 <shapr> CosmicRay: LDAP - Dominic Steinitz, ncurses - Igloo, Richard Braakman, John Meacham
14:15:08 <CosmicRay> shapr: do you happen to have a hint on that one?
14:15:10 <SyntaxNinja> Igloo: ideas?
14:15:35 <shapr> I have partial code from Dominic, I don't think I'm allowed to redistribute it.
14:15:36 <CosmicRay> thanks, I'll have to re-evaluate my searching algorithm having missed the ncurses stuff :-)
14:15:39 <CosmicRay> bummer.
14:15:44 * musasabi doesn't have that code either.
14:15:56 <shapr> I've emailed him a few times asking for updates, I'll email him again.
14:16:00 <musasabi> standardizing on a single ncurses interface would be nice.
14:16:03 <CosmicRay> shapr: thanks
14:16:10 <CosmicRay> musasabi: I am also considering packaging up cdk
14:16:15 <CosmicRay> with a haskell interface
14:16:19 <shapr> The ASN.1 LDAP code ended up in his recenty Codec package.
14:16:28 <wolfman8k> you could have the ide highlight new functions that you write in yello, then it compiles them in the background as you write your next functions. when the compilation of the function finished then the highlight color should change to green or red if it suceeded or not
14:16:32 <CosmicRay> shapr: what I really want is stuff that can talk to a ldap server though
14:16:40 <CosmicRay> shapr: I think I saw that ASN.1 stuff in haskell-libs
14:16:40 <shapr> I think that's why Codec only does BER
14:17:03 <CosmicRay> musasabi: I have written approximately 3 ncurses programs in my lifetime.
14:17:12 <shapr> Man, I gotta clean out haskell-libs, both cvs and darcs.
14:17:18 <CosmicRay> musasabi: that is approximately 4 more than any sane human can really handle. :-)
14:18:11 <musasabi> CosmicRay: yes, and it is too easy to write your own buggy wrapper...
14:18:14 <CosmicRay> cdk is, btw, a widget set resembling gui programs that is layered atop (n)curses
14:18:37 <shapr> huh, where's the Yampa list archived?
14:18:40 <CosmicRay> musasabi: for ncurses, you mean?
14:18:53 <CosmicRay> musasabi: it's not a task I want.  There are, what, some 300 functions or constants? :-)
14:19:32 <musasabi> CosmicRay: sounds nice.
14:19:43 <wolfman8k> http://mailman.cs.yale.edu/pipermail/yampa-users/
14:19:57 <musasabi> then again I think a good option would be to do a pure haskell library using ascii escapes only.
14:20:20 <CosmicRay> musasabi: it would be much less capable.
14:20:34 <shapr> wolfman8k: check december
14:20:41 * wolfman8k checks
14:20:45 <musasabi> CosmicRay: most of the time one wants a simple GUI only.
14:20:48 <CosmicRay> musasabi: that sort of thing provides no way to read, for instance, function key presses, meta key combos, change colors, change the cursor position, update parts of the screen, read arrow keys, etc
14:20:57 <CosmicRay> musasabi: most of the time, I don't want a GUI :-)
14:21:11 <musasabi> CosmicRay: then again users want it.
14:21:13 <CosmicRay> musasabi: readline is pretty much as far as one can get without using ncurses
14:21:32 <CosmicRay> musasabi: well then they can use wxhaskell
14:21:40 <shapr> or fltk?
14:21:52 <CosmicRay> shapr: two things bother me about that.
14:21:55 <CosmicRay> shapr: "tk"
14:21:56 <musasabi> fltk :-)
14:22:10 <musasabi> CosmicRay: fltk is not tk.
14:22:20 <CosmicRay> really?
14:22:26 <CosmicRay> not at all?
14:22:28 <musasabi> yes, see www.fltk.org
14:22:29 <shapr> musasabi: fltk screenies?
14:22:48 <CosmicRay> ah.  well I may have to reconsider it now.  I can't believe I've been thinking it was Yet Another TK Frontend all this time.  sigh.
14:22:50 <shapr> Specifically, do you have pretty screenshots of Haskell apps using fltk?
14:23:00 <CosmicRay> is fltk portable?
14:23:14 <musasabi> CosmicRay: windows and X11
14:23:34 <CosmicRay> hmm.
14:23:40 <CosmicRay> I presume it is easier to use than wxhaskell?
14:23:41 <musasabi> CosmicRay: I haven't got access to windows machines so no version of hs-fltk for windows currently.
14:24:01 <musasabi> CosmicRay: it is much simpler - but wxhaskell is more mature and full featured.
14:24:21 <shapr> g'day Pseudonym 
14:24:27 <Pseudonym> G'day.
14:24:30 <CosmicRay> musasabi: the "simpler" feature may be quite important, though
14:24:37 <shapr> Pseudonym: what's your opinion on the Tech Source graphics card?
14:24:46 <musasabi> shapr: I guess I should make those :-)
14:24:47 <CosmicRay> musasabi: I always get the feeling that I need to read about 200 pages of docs before I can write hello world in wxhaskell
14:24:55 <Pseudonym> Why does everyone always ask my opinion on stuff I don't know a damn thing about?
14:25:00 <CosmicRay> which makes it marginally better than AWT/Swing/OtherJavaCrap
14:25:05 <shapr> You know more about graphics than I do.
14:25:09 <Pseudonym> Why can't they ask my opinion on something I actually have an opinion on?
14:25:21 <musasabi> although we are harmonizing the interfaces to hs-fltk / gtk2hs / wxhaskell bit by bit.
14:25:28 <Pseudonym> "So, Pseudonym, what do you think about Haskell?"
14:25:29 <shapr> Pseudonym, hey what's your opinion on speculative evaluation in Haskell?
14:25:36 <Pseudonym> "Jolly good language, that."
14:25:37 <CosmicRay> Pseudonym: bush or kerry?
14:25:48 <CosmicRay> Pseudonym: ntfs or reiser?
14:25:54 <boegel> Pseudonym: boys or girls
14:25:56 <Pseudonym> CosmicRay: I know Kerry is a county in Ireland.  Where is Bush?
14:25:57 <shapr> lazy or strict?
14:26:02 <musasabi> I think there will be a new release of hs-fltk next week.
14:26:13 <CosmicRay> Pseudonym: guantanamo bay, if I had my way.
14:26:36 <Pseudonym> The Hague is slightly more likely.
14:26:50 <CosmicRay> Pseudonym: close enough :-)
14:26:54 <Pseudonym> Only slightly, though.
14:27:09 <Pseudonym> Anyway.
14:27:10 <boegel> CosmicRay: good one :)
14:27:14 <CosmicRay> thanks :-)
14:27:20 <boegel> CosmicRay: but they wouldn't torture him probably
14:27:25 <Pseudonym> I have no opinion on graphics cards.
14:27:33 <CosmicRay> boegel: I don't know, 10 years of meetings with lawyers... hmm...
14:27:44 <CosmicRay> Pseudonym: I prefer mine to have DVI outputs.
14:27:58 <Pseudonym> Except that they are interesting architectures to generate code for.
14:28:15 <CosmicRay> MegaMonad: do you have an opinion on graphics cards?
14:28:16 <MegaMonad> CosmicRay: Theres nothing like that for me i want done before 0.1, whic isn't on graphics cards.
14:28:23 <CosmicRay> MegaMonad: bush or kerry?
14:28:24 <MegaMonad> CosmicRay: Because kerry is a computer program that shapr is the definition of "necessary" may differ.
14:28:39 <shapr> !
14:28:41 <CosmicRay> haha
14:29:04 <CosmicRay> MegaMonad: unicycle, bicycle, tricycle, or motorcycle?
14:29:05 <MegaMonad> CosmicRay: A bicycle is a basic case... Returning (0,0,0]) whould cause a compile i only need 1 list of enums, i want my motorcycle.
14:29:25 <shapr> wolfman8k: maybe it'd be simpler to port Yampa Arcade to HOpenGL :-/
14:29:58 <shapr> Sure would be faster.
14:30:02 <wolfman8k> good idea :)
14:31:18 <shapr> alternatively, you could grab GHC from cvs and build it, or you could try the tar.gz they mention on the list.
14:31:52 <shapr> It's too bad HGL is so tough to install, since Hudak's Haskell book uses it lots.
14:32:40 <wolfman8k> i'll try that tar.gz from the list. i hope that dude uses intel :)
14:34:24 <CosmicRay> wolfman8k: probably PDP-11 :-)
14:35:30 <wolfman8k> CosmicRay: btw, i've been reading your blog. i think it's yorus
14:35:58 <CosmicRay> I build HGL?
14:36:05 <wolfman8k> hm?
14:36:18 <Pseudonym> "I build HGL" sounds like it should be an anagram of something.
14:36:23 <CosmicRay> s/build/built/
14:36:45 <CosmicRay> I'm just trying to figure out what "it" in "i think it's yours" is
14:36:59 <CosmicRay> hope my blog isn't too boring :-)
14:37:01 <wolfman8k> blog
14:37:09 * boegel goes to bed
14:37:12 <CosmicRay> ah.  changelog.complete.org is mine
14:37:15 <Pseudonym> Oooh!
14:37:19 <boegel> final tomorrow :(
14:37:25 <CosmicRay> good luck boegel
14:37:32 <wolfman8k> why do you call yourself jgoerzen?
14:37:33 <Pseudonym> "bug ill duh"
14:37:39 <Pseudonym> That's the best I can do.
14:37:49 <CosmicRay> wolfman8k: it's the username I use most places
14:37:53 <Pseudonym> "Ugh. ID Bill"
14:38:05 <SyntaxNinja> MegaMonad: I want my motorcycle too.
14:38:06 <MegaMonad> SyntaxNinja: Really, you should be the same subtree of the art of motorcycle maintenance, and i can't claim it isn't a scripting language of your libraries would need to propagate those changes for a sec before you asked about it...
14:38:20 <CosmicRay> haha
14:38:50 <CosmicRay> wolfman8k: my real name is John Goerzen, so there's wher the username comes in.
14:39:13 * Pseudonym laughs
14:39:18 <Pseudonym> I like yesterday's Spamusement.
14:39:21 <Pseudonym> http://www.spamusement.com/view.php?id=181
14:39:41 <wolfman8k> CosmicRay: i like the skunk entry
14:39:43 <CosmicRay> does anyone else here blog besides shapr and syntax?
14:39:52 <Pseudonym> Syntax blogs?
14:39:54 <CosmicRay> wolfman8k: thanks
14:40:09 <CosmicRay> Pseudonym: http://blog.syntaxpolice.org/isaac/index.cgi
14:40:12 <wolfman8k> CosmicRay: is your blog coded in haskell?
14:40:19 <CosmicRay> wolfman8k: no, it runs drupal, alas.
14:40:24 <Pseudonym> Anagram: "Lynx bag toss."
14:40:35 <CosmicRay> wolfman8k: though for php code, drupal is the most sane I've seen set.
14:40:37 <CosmicRay> s/set/yet/
14:40:43 <wolfman8k> php. eek
14:40:45 <Pseudonym> CosmicRay: Thanks.
14:41:19 <CosmicRay> wolfman8k: yeah I know.
14:41:30 <CosmicRay> wolfman8k: but it's really good php code :-)
14:41:57 <CosmicRay> definately not the *nuke crap that is so unfortunately popular
14:42:08 <Pseudonym> What should be my new language to learn this year?
14:42:09 <wolfman8k> i like how your blog is called changelog :D
14:42:16 <Pseudonym> I think it's gonna have to be Python.
14:42:17 <CosmicRay> CosmicRay's rule of system administration: anything with "nuke" in its name should be.
14:42:30 <CosmicRay> Pseudonym: what do you know already?
14:42:35 <CosmicRay> wolfman8k: thanks again :-)
14:42:43 <Pseudonym> CosmicRay: About 45 of them at last count.
14:42:45 <CosmicRay> wolfman8k: you should read about our kansas crime spree if you haven't already
14:42:56 <wolfman8k> CosmicRay: i read the beginning of the news article
14:42:57 <CosmicRay> Pseudonym: hmm.  apparently I am woefully behind on language count.
14:43:02 <CosmicRay> wolfman8k: ok, good 'nuf :-)
14:43:06 <Pseudonym> I think Python and Ruby are the two most "useful" that I don't know.
14:43:15 <CosmicRay> python is a good language.
14:43:21 <CosmicRay> it's the best practical OOP language out there, imho.
14:43:32 <CosmicRay> I spent several years working with python
14:43:38 <Pseudonym> Possibly Lua, but IMO unless you're trying to fit a linux distro on a floppy, Lua ain't so useful.
14:43:42 <CosmicRay> I almost learned ruby, but went to ocaml and then haskell instead
14:43:52 <Pseudonym> Not as useful as Python or Perl, anyway.
14:43:55 <CosmicRay> ruby was just not different enough from python to make it worthwhile
14:44:03 <wolfman8k> i just read that car hijackers are using new clever methods here, ones that invalidate the insurance :(
14:44:06 <CosmicRay> ruby seems like python + perl - awk
14:44:15 <CosmicRay> wolfman8k: ouch
14:44:23 <Pseudonym> Actually, closely related languages can be useful to know.
14:44:50 <Pseudonym> Though I'm still tripped up a bit by things which are subtly different between Haskell and Miranda, and I haven't used Miranda in 10 years.
14:44:58 <CosmicRay> perhaps, but if ruby offers only marginal improvements over python to me, then there is no point to putting in the effort to rewrite code in it and support another language
14:45:08 <tuomov> I wouldn't want to use an n-megabyte interpreter (like python) for a 200k program
14:45:10 <wolfman8k> they lure you out of your car by blocking your rear windshield or throwing stuff under your car so you think you ran over something. then when you get out to investigate they hijack your car. since you left your keys in the ignition the sleezy insurance companies won't cover you
14:45:25 <tuomov> lua otoh is very small
14:45:28 <CosmicRay> wolfman8k: that sucks
14:45:41 <tuomov> and I prefer it over the alternatives
14:45:51 <tuomov> much easier to embed too than at least python
14:45:51 <CosmicRay> -rwxr-xr-x  1 root root 1113768 Jan  5 19:36 /usr/bin/python2.3
14:45:56 <CosmicRay> -rwxr-xr-x  1 root root 773992 Jan 23 16:49 /bin/bash
14:46:02 <CosmicRay> not that much bigger than bash
14:46:06 <tuomov> haven't looked so much into embedded ruby, but not having first-class functions is a big minus
14:46:54 <Pseudonym> One of the reasons why I have so many languages on my CV is that I count closely related languages as different.  Example: Miranda, Miracula, Orwell and Haskell are different.
14:47:02 <Pseudonym> So are ML, SML and Caml.
14:47:10 <Pseudonym> Though I sadly have never tried O'Caml.
14:47:23 <CosmicRay> that's the only ML I've tried
14:47:26 <CosmicRay> it's interesting
14:47:36 <CosmicRay> though it just has that dated feel to it in some ways
14:47:57 <wilx> Hmm...
14:48:08 <wilx> I have never looke at ML or SML or Caml.
14:48:10 <CosmicRay> blindingly fast though.
14:48:23 <CosmicRay> ocaml outperforms g++ on the shootout on a fairly regular basis
14:48:25 <tuomov> -rwxr-xr-x  1 root staff 14476 Jan 18  2004 /usr/local/bin/lua
14:48:25 <wilx> How much are they different from Ocaml?
14:48:41 <tuomov> though that links to the shared libs
14:48:43 <Excedrin> I like SML over Ocaml, the object oriented stuff in Ocaml seems useless to me
14:48:45 <tuomov> with are in the order of 100k too
14:48:54 <Excedrin> and I prefer the syntax of SML
14:48:56 <tuomov> s/with/which/
14:49:06 <Pseudonym> There is one thing about SML which truly annoys me.
14:49:07 <CosmicRay> Excedrin: the OO stuff isn't useless, given that ocaml lacks typeclasses
14:49:17 <Pseudonym> It doesn't have forward references.
14:49:27 <Pseudonym> If you have mutually recursive functions, you need to declare them together.
14:49:35 <Binkley> yeah, that's annoying
14:49:39 <CosmicRay> ocaml shares that restriction
14:49:42 <Pseudonym> IMO it makes SML feel like you're programming an antique.
14:49:49 <Binkley> who wants to figure out your dependency graph by hand when the compiler can do it perfectly well?
14:49:52 <Pseudonym> Right.
14:49:59 <wilx> Yeah :)
14:50:03 * Pseudonym thinks there's no excuse in this day and age
14:50:13 <Pseudonym> Though I can live with forward references if necessary.
14:50:26 <Pseudonym> It's a bit of a pain, but at least it's usable.
14:50:26 <CosmicRay> Pseudonym: sadly, cobol programmers still find work.
14:51:12 <Pseudonym> The world needs a modern COBOL.
14:51:17 <tuomov> java!
14:51:22 <Pseudonym> Sadly, it's looking like VBA is filling that niche.
14:51:26 <Pseudonym> Which is possibly the worst choice.
14:51:36 <Pseudonym> Actually, Java is pretty close.
14:51:59 <Pseudonym> With some COBOL-oriented libraries, Java might do the job well.
14:52:30 <CosmicRay> that sentence contemplates unimaginable evilness
14:53:17 <tuomov> MegaMonad: is java the new cobol?
14:53:18 <Pseudonym> I mean it in the same sense that Ada or Modula {2,3} are good replacements for PL/I.
14:53:18 <MegaMonad> tuomov: Cobol must be new.
14:53:34 <wilx> Are they not? :)
14:53:43 <Pseudonym> Actually, Oberon was the first best replacement for PL/I.
14:53:44 <wilx> (Dunno PL/I.)
14:54:22 <Pseudonym> And Haskell is a better Miranda. :-)
15:00:30 <wilx> Hmm, is http://www.generic-haskell.org/ the same thing as Template Haskell?
15:01:59 <Heffalump> no
15:02:30 <Heffalump> Generic Haskell is essentially about polytypism, writing code that is parametric in the structure of a datatype
15:02:47 <Heffalump> so one function would work on all of [a], Maybe a, Tree a 
15:03:02 <wilx> Hmm, interesting.
15:03:05 <Heffalump> you could implement a lot of what you can do with GH using TH, but with more work
15:03:08 <wilx> Isn't that what type classes are for?
15:03:10 <Heffalump> and GH is much more type safe
15:03:32 <Heffalump> sort of, but you have to actually implement instances of the type classes
15:03:44 <Pseudonym> aka "boilerplate"
15:03:45 <Heffalump> GH is like being able to say deriving Show for any type class, not just Show, Read, Eq and Ord.
15:04:48 <Heffalump> (it's more powerful than just that, I'm just giving an idea of what it does that Haskell doesn't already do)
15:05:41 <wilx> Hmm...
16:07:44 <Igloo> SyntaxNinja: Did you want something?
16:21:13 <SyntaxNinja> Igloo: did you see my question about compilation times for things that don't need to be compiled?
16:21:34 <Igloo> No
16:21:48 <Igloo> It sounds like a very surreal question
16:22:30 <SyntaxNinja> it's a surreal situation...
16:22:37 <Pseudonym> What is the sound of uncompilable code compiling?
16:22:44 <SyntaxNinja> (14:13:27) SyntaxNinja: so sometimes, I'm compiling a bunch of stuff...
16:22:45 <SyntaxNinja> (14:13:31) SyntaxNinja: and it says "Compilation not required"...
16:22:45 <SyntaxNinja> (14:13:37) SyntaxNinja: but then it just sits there for like, 20 seconds.
16:22:47 <SyntaxNinja> (14:13:46) SyntaxNinja: so what's it doing? is this just Make taking a long time to figure out what to do next?
16:22:54 <Igloo> It's linking
16:23:21 <blackdog> linking is uber-slow. :(
16:23:22 <SyntaxNinja> linking the .a or executable you mean? I don't think it's gotten to that stage yet.
16:23:37 <Igloo> What does it say with -v?
16:24:11 <Pseudonym> if user == "Igloo" then sleep 1000 else return ()
16:26:20 <syntax_syntax> How would you write a "standard deviation" function in Haskell?
16:26:55 <SyntaxNinja> Igloo: I'll try that next
16:26:57 <syntax_syntax> My solution is pretty pretty slow and gets slower in a nonlinear fashion as lists grow.
16:27:02 <SyntaxNinja> syntax_syntax: I will ninja you!
16:27:17 <Pseudonym> Can you show us your solution?
16:27:18 <Igloo> syntax_syntax: What's your solution?
16:27:25 <syntax_syntax> just a min
16:27:33 * Pseudonym suspects that syntax_syntax is an Algol user in disguise
16:27:43 * Pseudonym shudders... two level grammars...
16:27:53 <syntax_syntax> http://pastebin.com/233920
16:28:00 <syntax_syntax> sans the php crap, of course :-)
16:28:11 <syntax_syntax> I'm not here to flame, I'm trying to learn.
16:28:45 <syntax_syntax> I knew Basic as a child, and then I did some PHP+MySQL work. I also do some Matlab, but that is hardly programming. 
16:28:51 <SyntaxNinja> syntax_syntax: just kidding with you ;)
16:28:54 <SyntaxNinja> because of yoiur nick
16:28:59 <syntax_syntax> ah yes
16:29:13 <Igloo> That looks like it ought to be linear to me
16:29:14 <syntax_syntax> well, I've been using *_syntax[_*] for ages.
16:29:38 <Pseudonym> Actually, no, it's quadratic.
16:29:43 * heatsink finds it amusing that the 'std' function uses 'sex'
16:29:49 <syntax_syntax> hehehe
16:29:54 <syntax_syntax> I didn't think about that, explicity.
16:30:08 <Pseudonym> BTW, x*x is usually better than x^2.
16:30:12 <Igloo> Pseudonym: What'm I missing?
16:30:24 <syntax_syntax> i used "e" for the summatory sign.
16:30:28 <syntax_syntax> s means "square".
16:30:31 <Pseudonym> At -O0 it's definitely quadratic, anyway.
16:30:33 <syntax_syntax> sum of the squares of x.
16:30:47 <Igloo> Oh, you mean if mean list isn't CSEd?
16:30:50 * shapr sighs
16:30:58 <Pseudonym> Right.
16:31:03 <shapr> It's so hard to restrain myself from nailing these people to the wall on lambda-the-ultimate.org
16:31:11 <syntax_syntax> maybe compilers "fix it".
16:31:15 <Pseudonym> shapr: Which one this time?
16:31:25 <syntax_syntax> but as it is, it repeats operations unnecessarily.
16:31:29 <shapr> Scott Johnson and "the debugging problem"
16:31:45 <Pseudonym> syntax_syntax: GHC does fix it at higher optimisation levels.
16:31:49 <Pseudonym> I _think_ that Hugs might not fix it.
16:31:57 <syntax_syntax> running through hugs. trying to std a list with 10 elements is already pretty slow.
16:32:02 <shapr> It's the "Popular vs Good" thread.
16:32:09 <Pseudonym> Basically, anything inside the map function which is loop-invariant could be usefully abstracted out.
16:32:11 <Pseudonym> Example:
16:32:17 <Pseudonym> norm list = map(x -> x / (std list)) (xex list)
16:32:19 <Pseudonym> Could be:
16:32:30 <Pseudonym> norm list = map (\x -> x / sd list) (xex list)
16:32:34 <Pseudonym> Sorry.
16:32:35 <shapr> I'm trying hard to address one facet at a time in my replies, and not reply more than once a day.
16:32:39 <Pseudonym> norm list = map (\x -> x / sd) (xex list)
16:32:45 <Pseudonym>           where sd = std list
16:32:45 <shapr> These people really don't know much about Haskell.
16:33:11 <shapr> Or software testing forthat matter.
16:33:27 <syntax_syntax> Pseudonym hmm. yes, but won't "sd" be executed everytime it's referred to, due to lazy evaluation?
16:33:58 <Pseudonym> Nope.
16:34:07 <syntax_syntax> oooh
16:34:15 <Pseudonym> It's full laziness which you want.
16:34:17 <syntax_syntax> I gotta try that :-D
16:34:52 <syntax_syntax> wow. It's like writing actual equations, you know.
16:35:32 * shapr agrees
16:35:35 <heatsink> Pseudonym: Would (std list) be reevaluated on every invocation in the other case?
16:36:02 <Pseudonym> It would if the compiler doesn't do let-floating or MFE abstraction.
16:36:12 <Pseudonym> Which I know GHC doesn't do at -O0.
16:36:16 <Pseudonym> Not sure about Hugs.
16:36:18 * heatsink looks up MFE
16:36:28 <Pseudonym> @wiki MaximalFreeExpression
16:36:28 <lambdabot> http://www.haskell.org/hawiki/MaximalFreeExpression
16:36:52 <heatsink> ah
16:37:25 <Pseudonym> The discussion in @wiki LambdaLifting might also be useful.
16:38:02 <shapr> man, I want @@wiki for inline commands.
16:38:09 <shapr> but not enough to hack it in.
16:39:39 <syntax_syntax> std [1...1000] takes over a minute. In Matlab it's less than two seconds.
16:40:00 * shapr beats up on Scott Johnson
16:41:11 <shapr> oh man, the first "4. Profit!" post on lambda-the-ultimate.org
16:41:21 <Pseudonym> LOL!
16:41:34 * shapr sighs
16:41:41 <shapr> slashdot infects everything.
16:42:11 <Pseudonym> No it doesn't, you insensitive clod.
16:42:34 * shapr snickers
16:42:41 * shapr throws an insensitive clod at Pseudonym 
16:43:02 <syntax_syntax> shapr it should be a "3. profit".
16:43:06 <Pseudonym> What a maroon.
16:43:16 * Pseudonym is reading his posts
16:43:21 <Pseudonym> He really doesn't get what you're saying.
16:43:28 <shapr> Yeah, but I'm trying.
16:43:38 <Pseudonym> For the record, I think he's right that tools are important.
16:43:42 <Pseudonym> And critical mass is important.
16:43:59 <shapr> But I think critical mass is a lot smaller than he implies.
16:44:12 <Pseudonym> It is for more modern languages.
16:44:17 <shapr> For example, I think Haskell has critical mass.
16:44:27 <Pseudonym> The thing about modern languages is that you can do it with fewer programmers.
16:44:27 <heatsink> oh no RUN!
16:44:40 <shapr> That's a good point.
16:44:50 * shapr lobs a critical lambda at heatsink 
16:44:55 <Pseudonym> And also, the tools aren't so necessary.
16:45:03 <shapr> One of us should mention that probably.
16:45:51 <shapr> I really do think that employees in general would push harder to be efficient if they got to go home when they were done for the day, no matter how little time that took them.
16:46:08 <shapr> Why is it you never get undertime?
16:47:38 <Pseudonym> One of the critical mass problems, BTW, is that the overwhelming majority of programmers are employed extending or customising existing applications.
16:47:43 <Pseudonym> Rather than writing new ones.
16:58:38 <syntax_syntax> Question: Hugs98 doesn't seem to have the built-in function Char.toUpper
16:58:52 <syntax_syntax> oooh of course
16:58:54 <syntax_syntax> sorry :-|
17:03:52 <shapr> oh, I already got a response to my "I've never needed a debugger." comment.
17:05:48 <Pseudonym> Real stack traces would be handy.
17:06:16 <shapr> true that
17:06:35 <Pseudonym> But as an example, when I'm hacking in C++ and I find a seg fault, my first step is to fire up purify or valgrind.
17:06:40 <Pseudonym> Not a debugger.
17:06:45 <SyntaxNinja> shapr: In cabal, i've never needed a debugger
17:06:57 <shapr> windows guys don't have the purify or valgrind option.
17:07:05 <Pseudonym> Their problem. :-)
17:07:09 <shapr> er sorry, just valgrind
17:07:14 <Pseudonym> Windows does have purify, yes.
17:07:22 <Pseudonym> If you have the dollars, they have the software.
17:08:17 <shapr> Last time I was soapboxing about software testing on #icculus.org, icculus said that when he's ported games to Linux valgrind turned up gobs of bugs the original authors didn't know they had.
17:08:45 <Pseudonym> Valgrind rocks.
17:08:58 <syntax_syntax> what is valgrind?
17:09:25 <shapr> It's a CPU emulator that keeps track of malloc and free calls.
17:09:33 <syntax_syntax> oh.
17:09:41 <shapr> It does more than that, but that feature alone is amazing.
17:09:46 <syntax_syntax> I never really understood pointers and/or mallocs 
17:09:55 <shapr> Of course, valgrind came about because of GHC :-)
17:10:23 <shapr> A point is just a location in memory.
17:10:28 <shapr> er "pointer"
17:11:28 <shapr> In C, your program has to manually request space for each value in memory. Then you have to manually put your value there, and when you're done, you have to call free to say that you're not using that memory anymore.
17:12:09 <shapr> Problem is, lots of code tries to use memory after it's been free'd, before it's been malloc'd, or does a variety of other stupid things.
17:13:58 <shapr> valgrind can catch many of those stupid things by pretending to be a CPU and watching for stupid moves.
17:14:14 <Heffalump> ARM seems to attract cool employees.
17:14:43 <Heffalump> (Julian Seward used to work there, and the author of PuTTy is still there)
17:16:08 <shapr> The FP world is pretty small. Isn't Mark Carrol at Aetion a friend of the PuTTy author?
17:16:27 <Heffalump> I guess he might be, since they are both chiark people.
17:17:33 <Heffalump> but Simon isn't an FP person
17:17:53 * shapr quickly substitutes "well-connected" for "small"
17:22:26 <Lemmih> Greetings, Sonarman.
17:22:49 <Sonarman> hi!
17:23:32 <Lemmih> Sonarman: Writing some spiffy Haskell code?
17:25:17 <Sonarman> nope, still getting my Haskell edumacation
17:28:33 * wli ponders a "fastest Fibonacci number function in the West" competition.
17:29:26 <wli> If I converted the thing to an array of Word64 I could probably do better.
17:29:30 <Lemmih> wli: Is TH allowed?
17:29:47 <wli> Lemmih: possibly
17:30:08 <Nioate> how is the speed measured?
17:30:11 <wli> Lemmih: actually I don't see why not
17:30:24 <wli> Lemmih: runtime for large Fibonacci numbers
17:30:48 <wli> Lemmih: e.g. fib 9999 == compute the 9999th Fibonacci number
17:31:30 <wli> I've got fib 9999 down to 0.06s thus far so it probably needs a bigger number.
17:31:31 <Igloo> Are we allowed a heap around 2^72 bytes?  :-)
17:31:47 <wli> Igloo: probably not
17:32:56 <wli> fib 99999 gets (2.72 secs, 127690148 bytes) in ghci here
17:34:02 <shapr> would be a lot faster with --make -fvia-C -O2
17:34:30 <wli> run it on 10^n - 1 until for progressively higher n until a significant difference in runtime or a failure to execute is seen or some such
17:34:49 <vdrab> wli: is there a ghci flag to get those stats quickly, or did you get them from the profiler?
17:34:55 <wli> :set +s
17:35:03 <vdrab> thanks
17:35:50 <Excedrin> 0.48s for fib 99999 in SML here
17:35:52 <wli> if I could pick apart Integer and get at the bits in highest-to-lowest order that would help me a lot.
17:35:59 <vdrab> I just came to the lab to find that my program, which I launched yesterday evening, is still running... :-(
17:36:02 <wli> Excedrin: implementation?
17:36:07 <Excedrin> MLton
17:36:44 <wli> Excedrin: arbitrary-precision arithemetic or are you wrapping? there should be several pages of output from printing the number (e.g. 24*80*3 or more characters)
17:37:24 <wli> 24*80*11 even
17:37:30 <Igloo> If you don't mind charging through 2 abstraction barriers you can
17:37:38 <wli> about 21120 characters
17:37:39 <Igloo> Although GMP's type is a bit complex IIRC
17:37:42 <wli> Igloo: I'm interested.
17:38:02 <Excedrin> 20900 characters here
17:38:06 <wli> Igloo: I don't have a very complex task to do; just walk over the thing bit-by-bit.
17:38:19 <Sonarman> hmm. my version takes... a long time to calculate fib 99999 :)
17:38:25 <Sonarman> wli: could you post yours/
17:38:36 <wli> http://holomorphy.com/~wli/Fib.hs
17:39:07 * Igloo doesn't have details to hand, but you basically need to get the MutableByteArray# or similar a J# really is, and then you can look at the GMP source to figure out what that means
17:41:10 <wli> $ time ~/tmp/fib 9999
17:41:14 <wli> ~/tmp/fib 9999  0.03s user 0.01s system 89% cpu 0.040 total
17:41:47 <wli> ~/tmp/fib 99999  2.04s user 0.03s system 82% cpu 2.513 total
17:41:49 <shapr> Is that with -fvia-C -O2 ?
17:41:51 <wli> strictness perhaps
17:41:56 <wli> shapr: yes
17:42:01 <shapr> neat
17:42:38 <wli> didn't help
17:42:42 <wli> Excedrin: implementation?
17:43:31 <Excedrin> one sec
17:43:53 <vdrab> can I ask all you optimization gurus a quick question?
17:44:46 <Igloo> Err, you can swap the order or u and v in unfoldl and get rid of the (uncurry (flip (,)) monstrosity
17:45:12 <wli> I wrote that to match unfoldr
17:45:18 <wli> so speed says do that yes
17:46:16 <Igloo> If you want speed you probably also want to avoid using list append
17:46:19 <wli> doesn't change anything though
17:46:22 <vdrab> I am working on a data mining app, and if have a graph algorithm that is killing me. runs for hours, and the end is not in sight. the bottleneck is building a huge list (think powerset operation on large data set). the question is, how would you optimize this, make it stricter or make it lazier?
17:46:26 <wli> Igloo: it has to come out in reverse
17:46:56 <Igloo> reverse $ unfoldl ... will be the easy way to make it faster
17:47:10 <wli> reverse $ unfoldr
17:47:16 <shapr> vdrab: already using the Haskell Graph Library?
17:47:21 <Igloo> huh?
17:47:22 <vdrab> no.
17:47:29 <shapr> I think it's faster for graph ops.
17:47:41 <Excedrin> http://lerp.com/~sic/sml/tailfib.sml
17:48:33 <shapr> vdrab: You won't know what's slow until you profile it.
17:48:36 <vdrab> shapr: walking and searching the graph works fine, using arrays and hashes.... it's just that I can't seem to build the graph itself for any non-trivial data set
17:48:40 <wli> Igloo: it's slower to do reverse $ unfoldr
17:49:18 <shapr> That could also be a missing base case somewhere where you reach an infinite loop.
17:49:31 <shapr> or try to show an infinite list, etc
17:50:30 <shapr> If you can build the graph at some point, find out exactly where you can't build the graph. But first, profile your code. There might be a really simple fix.
17:50:41 <vdrab> :shapr hm... could be, but I doubt it. profiling shows me that a couple of functions get called a zillion time, but there is no way to make the functions faster it seems... 
17:51:06 <vdrab> maybe try to find a way to avoid some calls
17:51:09 <shapr> Can you cache the results?
17:51:40 <vdrab> I can't build it in memory, insufficient heap even with -H256
17:51:48 <Igloo> wli: I meant reverse $ unfoldl with u: instead of ++[u]
17:52:18 <wli> Igloo: if unfoldl outputs it in order then it's just unfoldr
17:52:18 <Igloo> Oh, or do you mean with u: it is unfoldr?
17:52:45 <wli> ~/tmp/tailfib 99999  2.05s user 0.05s system 81% cpu 2.562 total
17:52:48 <vdrab> so I just want to print it to screen, and use it as a lazy list in my source code once it's computed. ... :-s
17:52:49 <shapr> Can you resculpt your algorithm into a lazy pipeline?
17:52:50 <wli> Igloo: yes
17:53:16 <wli> ~/tmp/fib 99999  2.03s user 0.03s system 83% cpu 2.476 total
17:53:19 <Igloo> BIAS
17:53:27 <vdrab> shapr: would love to, but I 'd have to hit the haskell books again to be able to do that
17:53:39 <wli> so the question is "why does the naive algorithm match the fancy one?"
17:53:52 <vdrab> I 'm still pretty new at this
17:54:30 <shapr> Laziness is more work than strictness, but it allows bigger payoffs.
17:54:51 <vdrab> what would be a general design pattern to do so?
17:54:53 <wli> well, tailfib.sml gets effective nontermination at 999999
17:55:36 <shapr> Make sure all your functions and algorithms can process partial input.
17:55:38 <wli> so does the fancy algorithm
17:55:56 <shapr> Obviously, it doesn't always work, some algorithms can't be lazy.
17:56:22 <Igloo> wli: How long is your list?
17:56:26 <vdrab> shapr: yeah... at some point I have to build arrays and hashes from that one list, for fast navigation
17:56:32 <wli> ~/tmp/tailfib $(( 2*99999 ))  10.08s user 0.15s system 84% cpu 12.065 total
17:56:50 <wli> Igloo: ceiling . log . fromIntegral $ n
17:56:53 <Igloo> Also, shouldn't you be able to use foldr, unfoldr, no reverse (possibly with other things flipped)?
17:56:58 <wli> ~/tmp/fib $(( 2*99999 ))  8.12s user 0.07s system 84% cpu 9.711 total
17:57:06 <wli> okay, it's already coming out there
17:57:10 <shapr> If your code is comfortably lazy, you can just ask for the first item in the list, and that's all that will be processed.
17:57:14 <wli> but it's vaguely shocking that the naive algorithm does so well
17:57:32 <shapr> That might give you some valuable information for profiling.
17:57:36 * Igloo vanishes
17:57:49 <wli> Igloo: i.e. tiny
17:57:56 <wli> ~/tmp/tailfib $(( 3*99999 ))  24.53s user 0.27s system 83% cpu 29.775 total
17:58:32 <vdrab> shapr: the list itself is not that horribly big, it's just that building it takes forever... computing each item in the list is a complicated operation
17:58:33 <wli> ~/tmp/fib $(( 3*99999 ))  18.17s user 0.13s system 85% cpu 21.404 total
17:58:52 <shapr> If you can do one list item at a time, you would only need a maximum of one list item worth of memory.
17:59:00 <wli> so at 99999 tailfib.sml and my Fib.hs perform equivalently, i.e. it's the breakeven point
17:59:07 <wli> above that I win
17:59:27 <vdrab> shapr: yes, that is what I'm aiming at... I just don't exactly know how to do it at this point.
17:59:48 <vdrab> shapr: well, maybe we'll learn something in the process :)
17:59:55 <shapr> Hopefully :-)
18:00:03 <wli> what's shocking to me is how on earth tailfib.sml pulls that off
18:00:19 <wli> there's no way it could be doing 100000 iterations
18:00:34 <shapr> Are you comfortable with structures like "fib = 1 : 2 : zipWith (+) foo (tail foo)" ?
18:00:35 <vdrab> shapr: anyways, thanks for the hints.
18:00:57 <vdrab> shapr: talking to me?
18:02:07 <shapr> yes
18:02:22 <wli> I suspect this one's a problem for language implementors.
18:02:39 <vdrab> I can see what they are intended to do I think, but never used them
18:03:53 <vdrab> shapr: what's the foo list?
18:04:08 <shapr> typo on my part
18:04:13 <shapr> foo = 1 : 2 : zipWith (+) foo (tail foo)
18:04:23 <wli> well
18:05:06 <Cale> that will give you a Lucas sequence, "1 : 1 :" starts the standard Fibonacci sequence
18:05:07 <vdrab> shapr: ooh, I get it
18:05:27 <Cale> Oh, I suppose that will give a tail :)
18:05:30 <wli> if you have f (n+1) = a*f n + b*f (n-1) ; f 0 = u ; f 1 = v ; then fs = u : v : zipWith (\x y -> a*x+b*y) (tail fs) fs
18:05:42 <shapr> Cale: a tail?
18:05:48 <wli> ~/tmp/tailfib $(( 4*99999 ))  46.71s user 1.27s system 77% cpu 1:02.13 total
18:06:10 <Cale> F(0) = 1, F(1) = 1, F(n+2) = F(n+1) + F(n)
18:06:18 <vdrab> shapr: it's a lazy fib series, rightL
18:06:39 <Cale> though starting it with 1,2 is fine, since you'll just get the same thing shifted
18:06:39 <shapr> yup
18:06:43 <wli> ~/tmp/fib $(( 4*99999 ))  33.03s user 0.21s system 85% cpu 38.718 total
18:06:48 <shapr> vdrab: you're using dvorak!
18:06:54 <vdrab> hahaha
18:07:01 <vdrab> damn'.... 
18:07:12 <shapr> right? -- rightL
18:07:28 <vdrab> you're pretty sharp, shapr
18:07:31 <wli> you can do general n-term linear recurrences
18:07:58 <shapr> I've been using dvorak since '92
18:08:10 <vdrab> that would explain it
18:09:09 <vdrab> shapr: my second haskell script was a program that prints out dvorak key scan codes and merges them into the windows registry
18:09:12 <wli> I wrote something for general n-term linear recurrences once.
18:09:32 <vdrab> shapr: except it never did the merging part.
18:09:35 <shapr> fib = 0 : 1 : zipWith (+) fib (tail fib)
18:09:45 <shapr> Cale: better? :-)
18:09:52 <Cale> :)
18:10:46 <Cale> 1:3: gives an interesting sequence
18:10:58 <shapr> I use a heavily modified dvorak layout on a kinesis contoured keyboard.
18:11:30 <shapr> My left wrist is still recovering from RSI. I'm angry at any input system that damages its users.
18:11:38 <Cale> which are the nearest integers to the powers of the golden ratio
18:11:58 <Lemmih> Arg! I've been slaving over the same 50 lines for three hours now and I still can't get it right ):
18:12:03 * Lemmih takes a unicycle break.
18:12:16 * wli lets 999999 spin
18:12:29 <vdrab> shapr: would you say this generates a lazy list ? (code following)
18:12:30 <vdrab> > powerList :: [a] -> [[a]]
18:12:31 <vdrab> > powerList [] = [[]]
18:12:31 <vdrab> > powerList (x:xs) = 
18:12:32 <vdrab> >     (map (x:) (powerList xs)) ++ (powerList xs)
18:12:32 <Cale> Lemmih: what does the code do?
18:13:37 <vdrab> it is used in a list comprehension (x <- prowerList list)
18:13:46 <wli> ~/tmp/tailfib $(( 999999 ))  318.24s user 2.50s system 81% cpu 6:33.62 total
18:14:10 <Cale> vdrab: seems lazy enough to me
18:14:38 <Lemmih> Cale: Eliminates unreachable objects and sorts the rest according to a dependency graph. Nothing fancy.
18:14:41 <vdrab> cale: I thought so too... the profiler doesn't seem to mind either
18:15:51 <shapr> looks lazy to me
18:16:51 <shapr> When I used to use Python, I found out that "foo" + "bar" + "baz" created a temporary string, and that got really expensive with big strings.
18:17:20 <shapr> Since ++ is lazy in Haskell, "foo" ++ "bar" ++ "baz" doesn't need optimizing.
18:18:05 <wli> What I really want is highestBit and testBit for Integer
18:18:29 <autrijus> greetings, lambdas.
18:18:41 <shapr> y0 autrijus 
18:18:49 <autrijus> yo. my books arrive today!
18:19:03 <shapr> spiffy! Which set of books did you decide on?
18:19:03 <autrijus> well, most of them, anyway. all except the two intro books (multimedia and craft)
18:19:34 <autrijus> let's see
18:20:02 <wli> ~/tmp/fib $(( 999999 ))  220.79s user 15.50s system 67% cpu 5:51.84 total
18:20:17 <wli> ~/tmp/tailfib $(( 999999 ))  318.24s user 2.50s system 81% cpu 6:33.62 total
18:20:24 <wli> needs scaling due to cpu activity
18:21:08 <autrijus> okasaki, purely functional data structures; pierce, basic category for comp scientists, advanced topics in types and prog. langs, types and prog. langs; lambek et al, intro to higher-order categorical logic; ribha, algorithms: a functional approach
18:21:09 <wli> 318.8322 vs. 235.7328
18:22:00 <wli> 26.063% faster
18:22:02 <autrijus> the "school of expression" and "craft of functional programming" are to arrive later, via non-UPS routes.
18:22:04 <wli> which is shameful
18:22:16 <shapr> Do you already have TaPL?
18:22:30 <autrijus> no; it's among the list
18:22:42 <shapr> oh, I see
18:22:57 <wli> My algorithm is O(lg(n)), and the naive one is O(n). My algorithm should be completely trouncing it.
18:23:14 <shapr> I really enjoyed Rabhi&Lapalme's "...Functional Approach"
18:23:45 <shapr> I'd like to read Okasaki and and the other two Pierce books.
18:24:02 <shapr> I just read the table of contents of the TaPL sequel. It's mouth-watering.
18:24:09 <autrijus> =))
18:24:35 <autrijus> I suspect I'll start from okasaki
18:24:48 <autrijus> I need to thoroughly unlearn my perl habits :)
18:24:53 <shapr> I recently realized that region allocation will be very valuable for automatically parallelized code.
18:25:07 <shapr> At least be able to switch them out when needed.
18:25:16 <autrijus> *nod*
18:25:42 <shapr> I've lost most of my Python habits. I blow the stack, I try to partially apply functions...
18:26:08 <autrijus> heh :)
18:26:32 <autrijus> also it is now plain to see haskell's influence on damian conway, and thus on perl6
18:26:42 <shapr> Do you read lambda-the-ultimate.org?
18:26:46 <autrijus> yes I do.
18:26:52 <shapr> Is he the guy who wrote the Parrot VM?
18:27:03 <autrijus> no, he is the codesigner of the perl6 language
18:27:05 <shapr> oh
18:27:07 <autrijus> having very little to do with parrot
18:27:09 * shapr googles
18:27:51 <autrijus> infinite lists, lazy-by-default consumers and producers, built in currying, combinator based grammar/macro rules, etc
18:28:12 <shapr> wow
18:28:30 <autrijus> honestly perl6 feels like oz with a more familiar syntax
18:28:31 <shapr> and he likes Self!
18:28:42 <autrijus> oh and junctions.
18:28:48 <shapr> what's junctions?
18:28:50 <autrijus> he introduced the whole partial contraints into perl6.
18:29:01 <autrijus> it's prolog-like stuff
18:29:02 * shapr has no clue
18:29:04 <shapr> oh, neat
18:29:35 <autrijus> it's alwasy available for perl5 as http://search.cpan.org/~lembark/Quantum-Superpositions-2.02/lib/Quantum/Superpositions.pm
18:30:08 <autrijus> sub is_prime { $^n % all(2..sqrt($^n)+1) }
18:30:11 <autrijus> that's how it looks like.
18:30:28 <autrijus> there's all() and any() and & and |
18:32:46 <shapr> I wonder if quantum programming languages will turn up anything cool.
18:33:15 <autrijus> well, if it does not have machine to run on...
18:33:37 * wli attempts to brush up on SML
18:33:43 <autrijus> all this junction stuff is merely nondet in disguise, when run on conventional hardware
18:34:08 <syntax_syntax> haskell interpretes tabbing?
18:34:25 <heatsink> syntax_syntax: whitespace is significant, yes
18:34:29 <shapr> indentation, tabs are bad!
18:34:34 <syntax_syntax> heh
18:34:39 <syntax_syntax> okay then :)
18:34:40 <shapr> at least tabs are bad if you want to share code with others.
18:34:52 <autrijus> syntax_syntax: http://haskell.org/tutorial/patterns.html#sect4.6
18:35:17 <shapr> I wonder if quantum programming languages will make it easier to design null-convention logic.
18:37:11 <autrijus> I'm reading damian's "Seven Deadly Sins of Introductory Programming Language Design" paper, and noticed that he priased haskell but bashed its I/O syntax.
18:37:27 <autrijus> I was briefly confused, but then I noticed it's published on 1996 :)
18:38:16 <shapr> Was that before monadic IO?
18:38:27 <syntax_syntax> autrijus so what are the sins of BASIC?
18:38:45 <autrijus> shapr: it was around or before 1.3
18:38:57 <autrijus> shapr: so I suspect it was before the do notation, but not neccessarily before monadic IO
18:39:40 <autrijus> syntax_syntax: Basic is not even mentioned.
18:39:57 <wilx`> Hm...
18:46:47 <wli> Now I have to remember what True and False are in SML
18:47:16 <wli> true and false it apperas
18:47:42 <shapr> Whats an organigramme?
18:48:41 * shapr thinks it's french for organization chart.
18:48:47 <wli> equivalent algorithm in SML now
18:49:30 <shapr> Does SVG support animation of any flavor?
18:49:40 <wli> Excedrin: http://holomorphy.com/~wli/fib.sml
18:50:19 <shapr> Wow, it does.
18:50:38 <shapr> Who wants to write a flash player in JavaScript?
18:50:49 * shapr snickers and goes back to work.
18:51:41 <wli> woops
18:51:48 <wli> didn't actually plug it in
18:51:56 <Excedrin> wli: I was doing the same thing, but mine's off by one, fib 3 = in mine
18:52:20 <Excedrin> er, fib 3 = 3
18:52:34 <wli> ~/tmp/smlfib $(( 999999 ))  1.08s user 0.13s system 63% cpu 1.914 total
18:53:09 <wli> Excedrin: fib 0 = 0; fib 1 = 1; fib 2 = 1; fib 3 = 2
18:53:22 <wli> Excedrin: fib 4 = 3
18:53:29 <wli> Excedrin: your implementation matches
18:53:32 <Excedrin> I know, that's why I haven't pasted a link
18:53:50 <wli> Excedrin: well, mlton appears to rock
18:54:04 <wli> Excedrin: 5 minutes vs. 1s
18:54:51 <Excedrin> yea, MLton rocks
18:55:06 <wli> Excedrin: let's see how fast bigger numbers go
18:55:16 <wli> Excedrin: ~/tmp/smlfib $(( 9999999 ))  26.44s user 1.38s system 52% cpu 52.601 total
18:55:30 <wli> Excedrin: I think the ghc runtime people have some work to do. =)
18:56:46 <wli> Excedrin: 10^6 - 1 is already a 5-6 minute operation with ghc and the O(lg(n)) algorithm; mlton with the same algorithm does 10^7-1 in under 60s.
18:57:11 <Excedrin> woah, it dumped core
18:57:49 <Excedrin> does 99999999 finish for you?
18:58:18 <wli> Excedrin: haven't tried 10^8 - 1
18:58:27 <Excedrin> it dumped core here
18:58:46 <wli> Excedrin: trying it now
18:59:10 <Excedrin> looks like a bug in libgmp
19:00:39 <wli> Excedrin: how's my fib.sml bench vs. tailfib.sml on your box?
19:00:49 <wli> Excedrin: dumps core here, too
19:01:06 <Excedrin> yours is way faster obviously ;)
19:03:22 <Excedrin> 0.40s for 999999
19:03:35 <wli> Excedrin: vs. how long for tailfib?
19:03:42 <Excedrin> 43 s
19:04:40 <wli> Excedrin: btw, exposing methods of finding the highest set bit in an integer and also testing arbitrary bits in an integer would speed this up a small bit
19:05:21 <wli> Lemmih: any news on the TH fib?
19:08:24 <Excedrin> wli: I'll report this core to the MLton guys, I suspect it's how they're calling gmp, and not an actual bug in gmp
19:08:36 <wli> Excedrin: great, thanks
19:08:52 <wli> wow, fib.sml exposed an issue =)
19:09:37 <wli> there's also no obvious reason fib.sml should be so much faster than Fib.hs when they use the same algorithm.
19:10:15 <Lemmih> wli: 'thfib = $([| yourFib 999999 |])'
19:15:11 <wli> Lemmih: I don't understand...
19:17:19 <wli> Lemmih: the closest approximation I can divine from that is running a command at compile-time to compute fib 999999 and returning a constant
19:17:39 <Lemmih> Exactly.
19:17:49 <wli> Lemmih: which can't be right, because it would need to pass the tests for other arguments
19:18:16 <Lemmih> Then change '99999' and recompile (:
19:18:41 <shapr> or build a lookup table
19:19:32 <wli> well, the way this works is testing it until it fails to run or exceeds some time limit
19:20:00 <wli> where "fails to run" includes "getting a wrong answer"
19:20:59 <Lemmih> wli: 'thfibs = $([| listArray (0,999999) (map yourFib [0..999999]) |])'
19:22:05 <wli> Lemmih: what ends up happening is the sequence is not bounded, so it eventually searches outside any finite table
19:23:25 <wli> then a wrong answer (as opposed to failing outright) disqualifies
19:23:27 <Lemmih> wli: 'thfibs = $([| listArray (0,1/0) (map yourFib [0..]) |])'
19:24:02 <wli> I think this particular abuse of TH is not going to help.
19:25:06 <Lemmih> If you don't wanna recompile then of course not.
19:26:21 <wli> It's just tabulating results from another implementation. It's not computing it ab initio.
19:26:31 <wli> The "ab initio" requirement needs clarification.
19:27:33 <shapr> I don't think TH can help in that case.
19:27:56 <shapr> Not unless you can find some pattern in the fibonacci computation that allows for accelerated addition.
19:28:19 <wli> shapr: It could in principle help by means of deriving the divide-by-n computations.
19:28:33 <shapr> Something like the common subexpression elimination SICP gives for fast multiplication.
19:30:21 <wli> shapr: my tactic would be gcd with the product of the first several primes (e.g. the largest such product that fits into the machine wordsize) and then using the rule for that on the fly.
19:31:27 <wli> first 9 primes
19:31:32 <wli> so 2^9 or 512 rules
19:31:45 <wli> you obviously don't want to write down 512 rules by hand
19:32:39 <wli> the 512th rule (for not divisible by any) is defaulting to the odd case of my odd/even recurrence
19:32:53 <wli> this is many fewer steps than my algorithm
19:33:08 <wli> the individual steps are more work for smaller numbers, though
19:34:41 <shapr> where's the break-even point?
19:34:50 <shapr> make a WorkerWrapper that chooses?
19:34:56 <wli> shapr: don't know, I don't know how to use TH to do this.
19:36:05 <wli> shapr: it doesn't matter anyway
19:36:13 <wli> shapr: we're getting massive overheads from other sources
19:37:11 <wli> shapr: until the runtime can get parity with mlton on the bitreversal algorithm we're toast
20:03:46 <Pseudonym> Sorry, are people looking for fast Fibonacci thingies here?
20:03:49 <Pseudonym> Or did I miss something?
20:04:02 <wli> Pseudonym: I wrote some stuff.
20:04:10 <wli> Pseudonym: http://holomorphy.com/~wli/Fib.hs
20:04:12 <wli> Pseudonym: http://holomorphy.com/~wli/fib.sml
20:04:29 <wli> Pseudonym: I think everyone gave up after declaring those undecipherable mathematical gibberish.
20:04:58 <wli> Pseudonym: It degenerated into some debate about the validity of using table lookup via TH.
20:05:18 <Pseudonym> It helps if you do x*x rather than x^2.
20:06:05 <wli> trying
20:06:53 <wli> doesn't appear to be helping
20:07:15 <Pseudonym> It is pretty indecipherable, I must admit.
20:07:41 <wli> Pseudonym: it's using a 2*n/2*n+1 recurrence via bitreversal
20:08:03 <Pseudonym> Any particular reason why you used this algorithm?
20:08:20 <wli> Pseudonym: It's O(lg(n)) iterations, and so vastly faster for large numbers.
20:08:33 <wli> Pseudonym: the bitreversal is deforestation-by-hand
20:10:29 <wli> Pseudonym: finding high bits of an Integer and testing arbitrary in-bounds bits of an Integer would be helpful
20:10:34 * jadrian just looked at Fib.hs...
20:10:37 <wli> Pseudonym: though not much so
20:10:42 <wli> jadrian: comments?
20:10:55 <jadrian> I have no idea how that works :)
20:10:56 <wli> Pseudonym: ~/tmp/fib 999999  211.45s user 1.21s system 85% cpu 4:08.07 total
20:10:56 <Pseudonym> http://andrew.bromage.org/Fib.hs
20:10:59 <Pseudonym> Try that.
20:11:05 <wli> Pseudonym: slight, but significant improvement
20:11:12 <jadrian> but I can't help but ask why is a fromIntegral there
20:11:19 <Pseudonym> Different algorithm, also log(N), no bit reversal.
20:11:24 <jadrian> what do you use beside ints?
20:11:46 <Pseudonym> I though also point out that _printing_ integers in Haskell is quite expensive.
20:12:02 <Pseudonym> Much more expensive than, say, adding them.
20:12:21 <Pseudonym> So if your test includes printing them... try not to.
20:12:50 <jadrian> do this algorithms have a name?
20:12:52 <wli> Pseudonym: it's equivalent to my own algorithm with bitreversal omitted
20:12:58 <Pseudonym> Ah, OK.
20:13:16 <Pseudonym> So why do you need the bit reversal?
20:14:00 <Pseudonym> OK, here's what I suggest.
20:14:21 <Pseudonym> If your test prints numbers, don't.  seq to force the number to be evaluated, then print a dot or something.
20:15:05 <wli> Pseudonym: bit reversal is to coalesce redundant computations
20:15:27 <wli> otherwise some things may be computed twice
20:15:38 <wli> (or more often)
20:16:58 <wli> Pseudonym: a function of F_n without a closed form for f(F_n) whose results have a very compact representation may also be meaningful
20:17:19 <Pseudonym> You're going to have to explain.  What is redundant?
20:17:47 <wli> Pseudonym: f(k) occurring multiple times in the call forest
20:17:54 <Pseudonym> Ah...
20:17:58 <Pseudonym> Uhm.
20:18:10 <Pseudonym> Where f is what in this case?  fib?
20:18:19 <wli> basically
20:18:42 <wli> not just that though, iteration functions etc. also count
20:19:02 <Pseudonym> So you also want to memo it?
20:19:24 <wli> the matrix may avoid it at the cost of 4 integers for state instead of 2
20:19:31 <wli> ./fib 999999  211.41s user 1.16s system 85% cpu 4:08.86 total
20:19:59 <wli> not significantly different
20:20:38 <wli> so it basically is equivalent to the bitreversal flavor but with 4 numbers for state variables instead of 2
20:21:24 <Pseudonym> Three, actually.
20:21:33 <wli> ~/tmp/smlfib 999999  1.08s user 0.10s system 59% cpu 1.992 total
20:21:43 <wli> Pseudonym: okay, sure, 1 is 0.
20:21:59 <wli> Pseudonym: that's the SML version
20:22:04 <Pseudonym> Still, I should point ou that mine is arguably a lo simpler.
20:22:18 <wli> Pseudonym: I'm not convinced it takes 3 minutes to print an integer.
20:22:28 <Pseudonym> What does the driver do?
20:22:33 <Pseudonym> For the Haskell version.
20:22:48 <wli> Pseudonym: main = getArgs >>= mapM_ (print . fib . read)
20:22:56 <Pseudonym> Right.
20:23:00 <Pseudonym> OK, hang on.
20:23:05 <Pseudonym> Let me think about this for a moment.
20:23:51 <Pseudonym> OK, I don't see how bit reversal helps to avoid calls to fib itself.
20:24:19 <shapr> Man, I give up on that LtU thread.
20:24:46 <shapr> Those people have their conclusions firmly seated.
20:24:52 <Gahhh> maybe so do you
20:25:02 <Gahhh> it's all subjective
20:25:14 <CosmicRay> which thread, shapr?
20:25:15 <shapr> I don't think my conclusions are very firmly seated, actually.
20:25:25 <shapr> the "Popular vs Good"
20:26:05 <CosmicRay> sounds dangerous
20:26:18 * shapr shrugs
20:26:19 <wli> Pseudonym: well, in the scalar recurrence form, you get fib n | r == 0 = g*(2*f-g) | r == 1 = f^2+g^2 where { (q,r) = n `divMod` 2 ; f = fib (q+1) ; g = fib q }
20:26:32 <shapr> CosmicRay: I'm not convinced it's worth the time you'll spend reading it.
20:26:45 <Pseudonym> Ah, I see.
20:26:51 <CosmicRay> shapr: I think you're right.
20:26:57 <CosmicRay> smells like a religious argument to me.
20:27:14 <CosmicRay> let me guess -- about half way through, there is an argument about which languages are popular and which are good? :-)
20:27:26 <Gahhh> there is no argument there
20:27:34 <Gahhh> the argument is if a lang can be bot good or popular, etc.
20:27:40 <Gahhh> bot = btoh
20:27:44 * Gahhh kills himself
20:27:47 <Pseudonym> First, let me edit my version to use only two state variables.
20:28:46 <shapr> CosmicRay: In essence, the C++ users want to stay that way.
20:29:04 <shapr> That's my conclusion.
20:29:07 <CosmicRay> heh
20:29:28 <Pseudonym> http://andrew.bromage.org/Fib.hs
20:29:34 <Pseudonym> See if that's an improvement.
20:30:20 <jdrake> who has done the shortest (useful) raytracer in haskell?
20:30:27 <Gahhh> shapr, eventually everybody changes. Look how long it took for garbage collection to become 'popular'.
20:30:32 <Pseudonym> Define "useful".
20:30:41 <Pseudonym> Generally speaking, short raytracers ain't so useful.
20:30:41 <jdrake> It works properly :p
20:30:57 <Gahhh> he means compact and minimal I suppose
20:31:02 <wli> This could get interesting.
20:31:06 <Pseudonym> minimal is the antithesis of useful, surely.
20:31:07 <wli> Maybe I'll even learn something. =)
20:31:18 <Pseudonym> For raytracers, anyway.
20:31:28 <shapr> jdrake: that guy who recently won the ICCC
20:31:31 <jdrake> Anyways, does anyone have any links to code?
20:31:35 <shapr> he wrote it first in Haskell
20:31:46 <wli> then transformed the code with a computer?
20:31:58 <shapr> Gahhh: you're right, I should just chill out and let it sink into the industry for a coupla decades.
20:32:09 <shapr> wli: nah, he just rewrote it in C
20:32:32 <Pseudonym> BTW, this isn't a race.
20:32:35 <Sonarman> what's the ICCC?
20:32:43 <Pseudonym> It's not "first language over the line wins".
20:32:43 <shapr> er, IOCCC
20:32:44 <shapr> sorry
20:32:50 <Sonarman> ah, ok
20:32:51 <Gahhh> sounds like a contest acronym
20:33:10 <shapr> obfuscated C
20:33:19 <Sonarman> Haskell in the IOCCC?
20:33:31 <Sonarman> how... interesting :)
20:33:34 <wli> Pseudonym: wouldn't bother me if it were
20:33:45 <shapr> The obfuscated Haskell contest was more fun.
20:33:57 <Pseudonym> wli: Have you tried my latest version?
20:33:59 <wli> I'm not ashamed of "losing". The answers are more important.
20:34:09 <wli> Pseudonym: It's still running.
20:34:10 <Pseudonym> No, I was talking to shapr specifically.
20:34:21 <Pseudonym> About convincing the C++-only weenies on LtU.
20:34:37 <shapr> I know, it's not a race. 
20:34:38 <Gahhh> shapr, have you read SICP or seen the movies ? Watching those I thought to myself "Wow, this stuff was there in the 80s and it went over a lot of people's heads." Same deal today.
20:34:49 <shapr> Gahhh: yeah, both. and I agree.
20:35:26 <shapr> I just get frustrated sometimes and try to nail people down to specifics and then squash their misconceptions.
20:35:43 <wli> ./fib 999999  213.79s user 1.34s system 83% cpu 4:17.20 total
20:36:01 <Pseudonym> So that's... what... about the same?
20:36:04 <wli> Pseudonym: looks like the 3rd state variable is needed to get rid of the duplicate calls
20:36:17 <wli> Pseudonym: about 1/16 slower
20:36:23 <Pseudonym> Hmmm.
20:36:31 <Pseudonym> Oh!
20:36:33 <Pseudonym> Duh!
20:36:35 <wli> Pseudonym: I think this is all doomed and we need to beat on the RTS
20:36:42 <Pseudonym> I see what the problem is.
20:36:44 <Gahhh> I haven't tried debugging haskell yet (<== newb). But I am thinking that it requires something different. Maybe a visual tool to check expressions, algebraic equivalence helpers, etc.
20:36:46 <Pseudonym> It's not tail recursive.
20:36:53 <wli> Pseudonym: go for it
20:37:06 <shapr> Gahhh: algebraic equivalence helpers == QuickCheck
20:37:12 <shapr> Like I posted in the thread.
20:37:17 <Gahhh> Ugh. Is that on the wiki ?
20:37:25 <shapr> What, QuickCheck?
20:37:28 <Gahhh> yes
20:37:38 <shapr> It's on its own website.
20:37:56 <shapr> It's the sexiest software testing tool I've ever seen.
20:37:57 <Gahhh> ok I found it
20:38:14 <Gahhh> "randomly generated cases"
20:38:27 <Gahhh> ok that's useful, but not exactly what I meant
20:38:55 <shapr> Read the QuickCheck papers, especially QuickCheckM
20:39:33 <shapr> I think that's what you mean by algebraic equivalence.
20:41:07 <Pseudonym> OK, I get the bit reversal now. :-)
20:43:52 <wli> heh
20:50:11 <wli> Pseudonym: I think I'll send a quick something to haskell-cafe and let others mull over this, too.
20:55:22 <Pseudonym> OK.
20:55:33 <Pseudonym> I'll keep going on and off.  (At w*rk, so can't concentrate too hard on it!)
20:56:17 <wli> tell me about it
21:01:07 <wli>  /last #debian-devel 999
22:10:20 <Pseudonym> wli: You there?
22:15:32 * Lemmih swears at bugs in other peoples code.
22:16:03 <wli> Lemmih: You would go insane after 3s in my job.
22:16:26 <xerox> hi, IntegerFibonacci guy ;-)
22:19:31 <Pseudonym> http://andrew.bromage.org/Fib.hs
22:19:33 <Pseudonym> Take a look.
22:21:04 <Pseudonym> The algorithm is quite pretty.
22:21:40 <Pseudonym> The memoing of values under 100 is just for fun.
22:22:16 <Pseudonym> Feel free to adjust that number, or use a faster fib to do the memoed base case.
22:22:19 <Pseudonym> base cases
22:23:16 <xerox> Bye folks, school tile.
22:23:18 <xerox> *time
22:24:50 <Pseudonym> Actually, look again.
22:24:51 <Pseudonym> That's better.,
22:27:13 <Pseudonym> Two integers per state, no redundancies to speak of.
22:29:11 <Nioate> Pseudonym: what's the name of the algorithm?
22:29:24 <Pseudonym> I dunno.  I made it up.
22:29:36 <Pseudonym> Pseudonym's Algorithm(tm)
22:29:43 <Pseudonym> But I can't be the first to think of it.
22:30:24 <Pseudonym> I got a couple of identities off MathWorld which seemed appropriate.
22:31:30 <Pseudonym> The rest was algebra.
22:37:21 <the_learner> do yall enjoy haskell over perl?
22:37:40 <Pseudonym> Yes.  I don't write my shell scripts in Perl any more.
22:37:51 <Pseudonym> :-)
22:39:45 <the_learner> hoe about kickass webapps?
22:39:51 <the_learner> and chat 
22:39:56 <Pseudonym> I don't write those things.
22:40:00 <the_learner> :(
22:40:43 <Lemmih> Several people have written IRC clients in Haskell.
22:42:24 <musasabi> a trivial irc client with a GUI is <100 lines of haskell.
22:43:29 <the_learner> wow
22:43:35 <ozone> musasabi: physical challenge :)
22:43:52 <the_learner> is haskell wider solution than perl?
22:44:03 <Lemmih> the_learner: And lambdabot is an IRC bot written in Haskell.
22:45:42 <Lemmih> Depends on your definition of "wider solution".
22:46:12 <Pseudonym> Got to go.
22:46:16 <Pseudonym> Nytol!
22:46:20 <wli> musasabi: example?
22:46:28 <wli> musasabi: oh, GUI
22:46:31 <wli> I hate GUI
22:46:44 <wli> I want text, and fancy-pants command-line editing
22:46:53 <the_learner> lambdabot works on windows?
22:47:38 <Lemmih> the_learner: I don't think so. It has some Posix dependencies, iirc.
22:47:47 <Lemmih> lambdabot: @hello
22:47:48 <lambdabot> Hello world. 
22:48:03 <Lemmih> lambdabot: @index putStrLn
22:48:03 <lambdabot> Prelude,System.IO,IO
22:48:18 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/hs-fltk/example/hirc_fltk.hs
22:48:23 <the_learner> doh
22:48:27 <musasabi> (for the example)
22:49:02 <musasabi> I like the irc parsing code, but the GUI code is quite cluttered.
22:49:03 <Lemmih> lambdabot: @type 10+20
22:49:05 <lambdabot> 10+20 :: forall a. (Num a) => a
22:49:16 <wli> I'm actually more concerned with the command-line editing than IRC protocol.
22:49:36 <wli> IRC protocol isn't hard. Almost all of it can be ignored.
22:50:09 <musasabi> wli: yes, still the lambdabot aproach is not pretty.
22:50:24 <wli> musasabi: lambdabot doesn't even have a command-line
22:50:37 <musasabi> to irc parsing that is.
22:51:25 <wli> There really isn't much to parsing computer -oriented languages... solved problem as of 1965 or thereabouts.
22:51:43 <Gahhh> any texmacs experts here ?
22:52:23 <the_learner> hmmm
22:52:34 <the_learner> so haskell not for web apps?
22:53:05 <Gahhh> why not ?
22:55:26 <Lemmih> the_learner: I've written a couple of Haskell powered web applications.
22:55:37 <the_learner> really
22:55:44 <the_learner> easier than perl etc?
22:56:07 <Lemmih> the_learner: eg. http://www.scannedinavian.org/cgi-bin/hackage/hackage
22:56:27 <Lemmih> the_learner: I'm unfamiliar with Perl so I wouldn't know.
22:57:23 <Lemmih> shapr: Around?
23:41:39 <the_learner> http://www.smalltalk.org/articles/article_20041002_a1.html
23:41:50 <the_learner> this bugger disses haskell as unscalible
23:47:34 <musasabi> the_learner: of course the writer fails to mention that in haskell one could have simply used Integer ;)
23:48:48 <musasabi> the_learner: and type signatures are much more like contracts than anything else.
23:49:17 <Lemmih> the_learner: It's not very surprising that the Smalltalk community thinks Smalltalk is generally better than Haskell.
23:49:38 <musasabi> the_learner: both good functional and oo programs are modular.
23:50:54 <musasabi> (starts to get windy here)
23:52:17 * Lemmih doesn't see how modules are an OO technique.
23:52:38 <musasabi> they aren't but OO people like to think they own them.
23:53:00 <musasabi> modules existed before OO and all modern languages seem to have them in one form or the other.
23:54:27 <musasabi> btw many people creating really large apps fancy lisp.
23:58:02 <sjanssen> I don't see what static typing has to with this airline example
23:58:35 <sjanssen> even a dynamic language that didn't use arbitrary precision integers would still have the same problem
