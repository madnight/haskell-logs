00:00:54 <musasabi> both get nice improvements if you do 64bit arithmetic.
00:01:15 <musasabi> otherwise you may even degrade performance in the worst case.
00:02:09 <Gahhh> I didnt know that it could get worse. Why, if you know ?
00:02:48 <musasabi> Gahhh: well you *are* making things wider which will translate to more cache misses.
00:04:03 <Gahhh> musasabi, that's not a fault of the ISA, though. I don't know if amd 64's have larger caches to compensate.
00:04:27 <musasabi> Gahhh: well that is a side effect of being 64bit.
00:04:48 <musasabi> (and think what the larger cache would do if you were 32bit)
00:05:16 <Gahhh> musasabi, that is true.
00:05:26 <musasabi> Of course x86-64 offers more registers than i386, which is good.
00:05:50 <Gahhh> I was curious if Haskell (or FP in general) had more to gain just because of its different nature.
00:07:03 <musasabi> well I don't think there is much to gain outside of 64bit ops to any language from the virtue of being 64bit - of course that allows one to map many things in memory but that is not language specific.
00:11:02 <Gahhh> is Clean faster than Haskell ?
00:11:16 <autrijus> is English faster than Spanish?
00:11:42 <Gahhh> I know jack about Clean so I don't understand your reply.
00:11:54 <autrijus> oh ok. I merely mean that you should qualify "faster".
00:12:39 <Gahhh> run time performance
00:12:43 <Gahhh> like SPEC
00:14:02 * autrijus nods, but has no idea about Clean either
00:17:59 <musasabi> Gahhh: both can be faster than the other.
00:18:56 <musasabi> Gahhh: writing fast code may be easier in clean if you can twink intuitively about uniqueness typing.
02:35:58 <boegel> any news in Haskell-land ?
02:48:29 <samc> the news is you can now buy a mini mac and port all your software to the mac so I can use it
02:48:47 <boegel> samc: is that Haskell news ? :p
02:51:08 <samc> port you _haskell_ related apps, there.
03:28:11 <TheHunter> hey boegel, how's your raytracer doing?
03:28:31 <bourbaki> moin
03:28:40 <TheHunter> moin
03:31:04 <bourbaki> TheHunter: do you think we could have a look at this homogenious graph thing this weekend?
03:38:58 <TheHunter> bourbaki, yeah, ok.
03:39:20 <bourbaki> TheHunter: cool thanks
03:53:54 <kowey> anyone here have experience timing stuff with haskell?
03:54:28 * Lunar^ has just been invited to give a talk on hOp for Libre Software Meeting 2005
03:55:34 <samc> what's hOp
03:56:24 <samc> nm
03:57:11 <musasabi> samc: a haskell os
03:58:58 <Lunar^> samc: GHC made the operating system
03:59:59 <samc> yea I found the site, why would you want to 'experiment with writing device drivers in Haskell'?
04:00:29 <samc> that is, why would one
04:02:31 <Lunar^> have you ever read a driver in C?
04:02:39 <Lunar^> there is so many repeating patterns
04:03:02 <Lunar^> and all types are mixed into int
04:05:24 <Lunar^> I strongly believe that to get new operating systems, with new ideas, we need a newer language than C
04:05:59 <samc> to show that even the ugliest lowest level things can be coded in a language like haskell?
04:07:03 <samc> Lunar^: I don't
04:07:04 <boegel> TheHunter: no progress, because I have other things on my mind right now (exaams, or how do you call the big tests every semester)
04:10:33 <Lunar^> samc: To see if maybe the ugliest lowel level things could become nice with the right language
04:12:04 <kowey> folks, i could use some of your insight here... i've got a program and a set of optimisations, and i'm trying to figure out how effective each optimisation is
04:12:18 <kowey> i have a batch processor and some timing code (http://www.haskell.org/hawiki/HaskellIrcPastePage)
04:12:21 <kowey> but...
04:12:41 <kowey> running things in different orders gives different results, which probably means i'm doing something wrong
04:12:44 <samc> Lunar^, I meant to say ...coded nicely :) Is your talk going to have a motivation section?
04:17:02 <samc> Lunar^, have you read spj's advice?
04:21:11 <samc> that is if you're not an old pro
04:47:27 <shapr> good morning #haskell!
04:47:41 <musasabi> morning shapr 
04:47:49 <cptchaos> morning shapr
04:47:53 <shapr> @yow !
04:47:54 <lambdabot> Today, THREE WINOS from DETROIT sold me a framed photo of
04:47:54 <lambdabot>  TAB HUNTER before his MAKEOVER!
04:48:05 <tromp> hi shapr
04:48:09 <samc> morn
04:51:22 <kowey> hmm... i'll try again now with more people awake :-)
04:51:41 <shapr> hoi tromp, how was christmas?
04:51:49 <shapr> bonjour kowey, long time no see
04:52:26 <kowey> hi shapr! yep yep i tend to hide away when i don't have questions to pester the room with
04:53:04 <kowey> anyway, so the question du jour
04:53:04 <tromp> xmas was very sunny in Miami
04:53:15 <musasabi> Does anyone know whether haskell xml toolbox support entity references inside attributes?
04:53:33 <tromp> and crowded with the 28 ppl my sister invited
04:53:55 <shapr> samc: Lunar^ is a young pro :-)
04:53:56 <kowey> http://www.haskell.org/hawiki/HaskellIrcPastePage could anyone provide some insight?
04:54:58 <adept> kowey: 1)ghc or ghci?
04:55:03 <kowey> ghc
04:55:34 <kowey> note that the batch processor is just more haskell code
04:56:13 <shapr> heippa _Codex 
04:56:16 <kowey> and also, note the use of length.show to trick haskell into evaluating stuff... if anyone has a more correct approach, i'd be happy
04:56:20 <adept> kowey: ... which probably do some io
04:56:44 <kowey> adept: yes
04:57:40 <kowey> adept: well actually... the idea is that "stuff" involves reading some huge file and the storing it in an IORef
04:57:52 <kowey> that's why i force evaluation so that it doesn't get counted in the timing code
04:58:08 <kowey> (and in future iterations, since it's stored in the IORef, we don't read the big file a second time)
05:02:13 <kowey> ok... i'll throw a hypothesis out to the room and see what you folks think
05:03:02 <kowey> these are pretty memory intensive things: maybe i have a "leak" somewhere 
05:03:23 <kowey> which is causing me to start swapping around the C'th optimisation or so... would that affect CPUTime?
05:04:01 <cptchaos> is the result reproduceable?
05:04:27 <kowey> well... rerunning the program produces similar results pretty consistently
05:04:51 <adept> kowey: "opt" == "time ms", that is - divided by 100000000 ?
05:05:21 <kowey> hmm... now i'm convinced i need to get this gpl'd and released asp so that i can show people code :-)
05:05:39 <kowey> adept: opt is just "optimisations"
05:05:49 <kowey> something like like opt = [A,B,C,D,E]
05:06:05 <kowey> map fn opt, where fn is from the paste page
05:06:32 <adept> kowey: i mean, code posted does not output time. Yet sample output includes time. I wonder, how time is computed.
05:07:11 <kowey> oh yes... time is the timediff
05:07:12 <kowey> sorry
05:08:38 <adept> kowey: Wild guest - all (or most) of A, B, C, D, E use some top-level forms. Who get called first (be it "A" or "E") has to evaluate those top-level forms. Hence difference.
05:08:45 <adept> ^guest^guess^
05:08:57 <cptchaos> maybe the garbage collector gets triggert at different times?
05:09:13 <kowey> can i force garbage collection in between optimisations?
05:09:17 <adept> kowey: is my idea clear?
05:09:30 <kowey> adept: what do you mean by top-level forms?
05:09:43 <adept> kowey: example:
05:09:50 <cptchaos> kowey: yes, you clould try perfromGC
05:09:56 <cptchaos> @index performGC
05:09:57 <lambdabot> System.Mem
05:10:09 <kowey> hmm... i'll give that a try
05:10:21 * kowey is woefully ignorant of how computers actually work
05:10:29 <adept> longlist = filter odd [1..10000000]
05:10:29 <adept> A = minimum longlist
05:10:29 <adept> E = maximum longlist
05:10:34 <Lemmih> Preferably followed by a 'yield'.
05:10:39 <cptchaos> however adept, might be right as well
05:11:03 <adept> kowey: i would not recommend to trigger GC because that would not be how you program will work in "production" environment.
05:11:09 <samc_> keep in mind I have no idea what I am talking about :P but are they independent? could there be some memoising going on?
05:11:31 <adept> kowey: you can force GC to output statistics to stderr to see how much time does GC take though.
05:11:52 <adept> kowey: is "longlist" example clear?
05:11:53 <kowey> samc_: they *should* be independent (not sure what memoising is)... the only shared stuff "stuff" is stored in an IORef
05:12:27 <kowey> adept: so... because of lazy evaluation, it would take a while to figure out what E was before actually running it
05:12:37 <kowey> adept: overhead not related to what i'm actually trying to test
05:13:19 <adept> kowey: I dont get you
05:13:41 <kowey> adept: my attempt at understanding the longlist example :-)
05:14:46 <kowey> adept: thinking very concretely, though, i don't think that is the case... A,B,C,D,E are really just sets of flags
05:14:59 <adept> kowey: if you call "A" first, it will evaluate longlist and time from "filter" will be attributed to "A". After that "E" will just use already-evaluated "longlist". If you call "E" first, it will hapen other way around
05:15:40 <kowey> right... i tried to prevent that by doing (length.show) stuff before doing clockBefore
05:15:44 <kowey> but maybe that wasn't enough?
05:15:49 <adept> kowey: try to compile with "-prof -auto-all", run with "+RTS -p" (or -P) and look at "binary.prof" for execution times
05:16:03 <kowey> k
05:16:19 <samc_> memoizing is cacheing of function call results
05:17:37 <kowey> samc_: i wouldn't think so, but i suppose... is there a way to clear this cache as well?
05:18:45 <adept> kowey: imo it is easier to just produce five binaries and measure their execution speeds
05:19:18 <samc_> I don't even know if ghc does it, hence the disclaimer. It was just a thought. Someone must know!
05:19:34 <adept> kowey: otherwise you'll end up turning haskell into C (first - force everything to be non-lazy, then - trigger GC often, then - reduce memoizing, then - ...)
05:19:34 <kowey> adepth: oi... you might be right... a bit annoying though because that means reading the big file in over and over again
05:19:43 <kowey> hmm... 
05:20:16 <kowey> on a side note, some people at my lab are thinking of taking up ML just because timing is easier to think about
05:20:33 <adept> kowey: premature optimization is a root of all evil
05:20:58 <kowey> noted... but here we're trying to compare algorithms
05:21:07 <adept> kowey: what you think about timing is very different from the _real_ timing
05:21:15 <adept> kowey: so compare
05:21:20 <kowey> like, does algo B give us polynomial time in practice for this exponential time pb?
05:21:22 <adept> kowey: another example ...
05:21:51 <kowey> and this is computational linguistics, so a bit "down to earth" in the sense of "we want to know what happens when we run this on real data"
05:22:39 <adept> data = map (*2) [1..100000000]
05:22:39 <adept> odd_elts [] = []
05:22:39 <adept> odd_elsts [a] = [a]
05:22:39 <adept> odd_elts (a:b:lst) = a : (odd_elts lst)
05:22:39 <adept> A = do_something $ odd_elts lst
05:22:39 <adept> B = do_something lst
05:23:32 <adept> Here, evaluation of A will force exactly half of "data" to be evaluated. Further evaluation of B wiil force other half of data to be evaluated. 
05:24:05 <adept> kowey: i understand that you try to evaluate stuff, but maybe something similar happens with things that operate on "stuff" further on
05:24:25 <kowey> hmm...
05:24:45 <kowey> and the only way to be really sure that something similar doesn't happen is to have no laziness at all?
05:25:08 <adept> kowey: if you do not prove that some algo B is polynomial mathematically, no amount of measurements will serve as a proof :)
05:25:29 <adept> kowey: the other way is to have five binaries :)
05:25:50 <adept> and leat each optimization evaluate input data as they see fit.
05:25:58 <kowey> :-D... i understand...
05:26:11 * kowey is feeling self conscious about his CS skillz
05:26:27 <adept> you should also stop forcing things, becase eager computation can allocate A LOT more memory than lazy one, which will affter timing as well....
05:27:01 <kowey> well... the forcing was just to avoid having timediff = 0
05:27:39 <adept> kowey: but timediff is the perfect case :)
05:28:02 <adept> but timediff=0 is the perfect case
05:28:14 <kowey> adept: what do you mean?
05:28:41 <adept> kowey: i mean the less timediff is the better, right? :)
05:28:56 <kowey> of course! i should publish that! :-)
05:30:19 <kowey> anyway, thanks all for the help and discussion, i'll see what i can do!
05:30:33 <kowey> (argh... excessive use of exclamation marks)
05:54:38 <Muad_Dibber> heh, thank god compiling ghc takes almost no time :P
06:05:07 <musasabi> Itse 
06:05:12 <musasabi> (sorry)
06:35:30 <tintin> can stuff be recompiled on the fly in yi ?
06:35:52 <adept> what's yi?
06:37:24 <tintin> @yi 
06:37:24 <lambdabot> Sorry, I don't know the command "yi", try "lambdabot: @listcommands"
06:37:48 <tintin> yi is a text editor written in Haskell iirc 
06:39:19 <Cale> tintin: I think the plan is to use hs-plugins, so it should be.
06:39:39 <Cale> but I haven't really looked at yi too closely
06:47:59 <musasabi> yi uses hs-plugins.
06:50:51 <tintin> ghc-6.2.2: unknown package name: plugins
06:50:52 <tintin> make: *** [Boot.o] Error 1
06:51:23 <tintin> thats what yi throws up what did i do wrong ? where are the plugins ?
06:52:03 <xerox> 'lo !
06:52:36 <tintin> helo xerox 
06:52:58 <Cale> http://www.cse.unsw.edu.au/~dons/hs-plugins/
06:54:33 <TheHunter> tintin, iirc, you'll need a cvs snapshot.
06:58:22 <tintin> oh tnx i will get a cvs snapshot 
07:10:43 <bourbaki> is there any embedable haskell?
07:17:50 <musasabi> you can have your main with C if that is what you mean.
07:29:44 <Darius> bourbaki: Embeddable as in "embedded processors" or embedded as in Lua/Guile/Tcl-like?
07:30:35 <bourbaki> Darius: the latter
07:30:51 <bourbaki> i mean as in interpreted in c
07:31:51 <bourbaki> i would love to use haskell for some geometrical calculations but use c++ for the rendering
07:33:22 <Darius> Then as musasabi said, you can call Haskell from C and unless you want the dynamic-feel of interpreted-embedded languages that should suffice.
07:33:52 <bourbaki> you mean by useing object files?
07:34:22 <Darius> More or less.
07:34:38 <bourbaki> ok im interested in the less thing ;)
07:35:32 <Darius> bourbaki: Do you want a more dynamic environment then? Otherwise, why is that a problem?
07:36:00 <bourbaki> Darius: its just that i think that useing object files is tedious
07:36:29 <bourbaki> importing it in haskell is quite nice though but im too lazy to map all the render stuff to haskell
07:36:41 <bourbaki> which was the thing i would love to have acrually
07:37:40 <Darius> bourbaki: If you use C++ as the host language, then you only have to map the Haskell geometrical calculations stuff to C.
07:38:57 <bourbaki> i think if you use make files and such thats a nice thing maybe but not in VC i guess
07:39:21 <Darius> bourbaki: There is no way of getting out of mapping one interface to another using an embedded language.  I.e. the problem there is not the use of object files.
07:39:47 <bourbaki> isnt there a tool that generates the interface file ?
07:40:03 <bourbaki> i have to use the object file in the linker options right?
07:40:33 <Darius> bourbaki: Presumably you can set that up to be added automatically somewhere.
07:41:29 <tintin> hmmz the cvs version of hs-plugin still dosnt solve the plugins problem 
07:41:49 <tintin> gcc still complians about unknown package name : plugins 
07:42:48 <Darius> bourbaki: Most of the tools for making interfaces are for making Haskell interfaces to foreign (usually C) code.  Of course, since you expressed that that would be preferable...
07:43:17 <bourbaki> hey boegel
07:43:26 <bourbaki> boegel: i have a paper for you
07:43:43 <boegel> ow? show me bourbaki :)
07:43:58 <Darius> tintin: What package did installing hs-plugins add?
07:44:00 * boegel meant oh instead of ow
07:45:08 <bourbaki> boegel: http://www.research.scea.com/gdc2003/spherical-harmonic-lighting.pdf
07:45:20 <Lemmih> tintin: Did you register hs-plugins?
07:45:53 <jadrian> musasabi: hmmm I don't think there is much to restructure here, I simply have many parameters to set... but maybe I am missing something about state monads..,
07:45:56 <Lemmih> The README should tell you how and why.
07:46:42 * Darius doesn't know what jadrian is talking about.
07:47:05 <bourbaki> boegel: for you lighting stuff :) and i have a game
07:47:09 <bourbaki> at least started one
07:48:14 <boegel> bourbaki: the paper is nice, but I think the contents are too advanced for my raytracer :)
07:48:24 <jadrian> Darius: we were talking about it before I went to sleep... :)
07:48:45 <jadrian> Darius: I was answering something musasabi said meanwhile...
07:48:47 <boegel> I'm not planning to add any new functionality, but to get some really good structure in my code, and to work around the code and the idea behind it
07:48:49 <bourbaki> boegel: a pitty its for rt use :) and im gonna use it in my game
07:49:01 <bourbaki> boegel: do you run windoze?
07:49:09 <boegel> bourbaki: windoze and linux :)
07:49:24 <boegel> I'm in linux now doh...
07:49:32 <bourbaki> boegel: codemages.sf.net/CompiledEffect.exe and .fxo
07:49:32 <jadrian> Darius: but it's about IO + StateT  vs implicit parameters IORefs
07:49:34 <boegel> why, you have something working already ?
07:49:51 <bourbaki> boegel: yep you need dx9c dec2004 though
07:49:57 <boegel> hmmm
07:50:11 <boegel> I will have to install that then... and I'm not sure my laptop will be able to handle it
07:50:17 <jadrian> There is something I don't like about state monads...
07:50:17 <boegel> I can try :)
07:50:43 <jadrian> if you have more than one kind of state, say, s1, s2, s3, s4...
07:50:59 <jadrian> and you want to combine them 
07:51:03 <bourbaki> what kind of gfx board has you nb?
07:51:14 <jadrian> everything gets messy...
07:51:25 <boegel> bourbaki: Intel Extreme Graphics
07:51:33 <jadrian> if at some point you need to have say, s1, s2, s3
07:51:45 <jadrian> you can use   State (s1,s2,s3)
07:51:59 * boegel is thinking of doing a Phd on Real Time OS's next year, formal proving and stuff like that...
07:52:00 <jadrian> but then how do you modify s3?
07:53:06 <jadrian> you need a function to update each position of the tuple and combine it with the function to update s3
07:53:55 <jadrian> now with IORefs as implicit parameters all I do is add one more implicit parameter to the context, and keep using the same update function
08:00:02 <Darius> jadrian: Use records instead of tuples and the update functions don't need to change.
08:00:52 <tintin> Lemmih: how do i register it ? 
08:01:28 <tintin> Darius: i just did a make install from the cvs snapshot 
08:01:59 <Lemmih> tintin: make register
08:02:34 <Lemmih> tintin: Read the README (-:
08:04:03 <tintin> sorry Lemmih 
08:04:22 <tintin> next time be sure to give me a RTFM
08:11:23 <tintin> Boot.hs:287: Variable not in scope: `unloadPackage'
08:11:25 <tintin> make: *** [Boot.o] Error 1 thats the new error ... 
08:38:14 <jadrian> Darius: maybe I didn't explain myself well...
08:38:40 <jadrian> Darius: In some cases I need only a state s1 (which may be itself a tuple)
08:38:59 <jadrian> Darius: in other cases I need other states, s2, s3, etc
08:39:53 <jadrian> Darius: so I'll need function to update states s1, s2, s3...
08:40:33 <Lunar^> shapr: there?
08:40:42 <jadrian> Darius: when I need more than one of those states, I need to group them in some tuple, record whatever
08:41:00 <Lemmih>  /whowas wilx
08:41:06 <Lemmih> D'oh.
08:41:35 <jadrian> Darius: and I cannot update a s1 state the same way in  State s1  and State (s1,s2) monads 
09:03:52 <Lemmih> How do you pass options to 'cpp' from GHC?
09:06:30 <Igloo> -optP
09:06:43 <Lemmih> Igloo: Thanks.
09:06:52 <musasabi> traditional cpp is quite nasty.
09:07:20 <Lemmih> Will it kill those '#stuff' lines?
09:16:05 <Lunar^> Have anyone seen bringert recently?
09:16:57 <andersca> I saw him the other da
09:16:58 <andersca> y
09:17:09 <Lemmih> lambdabot: @seen bringert
09:17:10 <lambdabot> I saw bringert leaving #haskell.se 3 days 17 hours 5 minutes 9 seconds ago
09:18:03 <tintin> why do i get Boot.hs:287: Variable not in scope: `unloadPackage'
09:18:03 <tintin> make: *** [Boot.o] Error 1  in yi when i run make ? 
09:24:25 <Lunar^> Lemmih: thanks
09:25:04 <shapr> Lunar^: salut
09:25:29 <Lunar^> shapr: I've been asked about a hOp talk for LSM2005
09:25:35 <shapr> kul!
09:25:37 <Lunar^> shapr: Now you have to come!
09:25:44 <Lemmih> tintin: You can ask dons when he gets here.
09:26:10 <shapr> Where is it? glasgow?
09:26:57 <tintin> ok tnx Lemmih i will ask him 
09:28:21 <shapr> Lunar^: ou est LSM2005?
09:29:20 <Igloo> Oh, interesting, I didn't realise it was so high-profile
09:29:54 <Lunar^> shapr: Dijon, I already told you about that, I think :)
09:30:05 <Lunar^> shapr: Libre Software Meeting
09:30:30 <shapr> oh, you did tell me about that.
09:31:05 <shapr> When is it?
09:31:37 <shapr> I can find - http://lsm.abul.org/rubrique2.html
09:31:54 <shapr> but I don't see dates for 2005
09:32:32 <Lunar^> 5-9 july
09:32:34 <Lunar^> Dijon
09:32:48 <Lunar^> (That's France :))
09:37:17 * shapr laughs
09:37:31 <shapr> I actually knew that Dijon is in France ;-)
09:39:41 <shapr> Is Dijon near Toulouse?
09:44:26 <Lunar^> shapr: not really :)
09:48:50 <shapr> Ok, just wondering if I could meet unicyclists at the same time :-)
09:53:41 <shapr> hiya edwinb
09:53:52 <edwinb> evening
09:55:18 <shapr> Lunar^: I'll see if I can make it, but I'm not sure how likely it is... ICFP, EuroPython/EuroHaskell, and FLUCK are all happening in July. I think I'll be able to do at most two of those.
09:55:30 <Lemmih> shapr: <insert rant about lambdabots buildsystem>
09:55:41 <shapr> so fix it :-)
09:57:02 <Lunar^> shapr: yeah
09:58:18 <shapr> y0 SyntaxNinja 
09:58:38 <Lemmih> shapr: My fix would be in moving to GHC 6.3 and hs-plugins so it would most likely break the current plugins.
09:59:07 <shapr> go for it
09:59:34 <Darius> Wow, EvalModule really was a long time ago.
10:00:06 <shapr> How long?
10:03:14 <Darius> I'm not sure exactly, I just know that I stopped doing 'foo bar = do something\n              someotherthing' quite a while ago.
10:03:58 <Darius> But it should be getting on two years
10:05:01 <Darius> shapr: Also, one reason @eval probably takes so much memory is that I never trim the environment.
10:05:08 * shapr shrugs
10:05:10 <shapr> it works :-)
10:06:14 <Darius> I actually wrote a rather large change that probably did that (though that wasn't the intent of the change) and I'd hope would speed it up.
10:06:30 <Darius> (Even if it didn't do that, it had the right information to do it)
10:06:58 <Darius> Unfortunately, it's likely lost in the winds of Time.
10:07:30 <shapr> if you find it, it'd be nice.
10:19:17 <Darius> Uh oh.  Someone is giving you beef on LtU shapr
10:19:28 <shapr> oh really?
10:19:29 * shapr checks
10:19:50 <SyntaxNinja> hi all
10:19:59 <Darius> heya SyntaxNinja
10:22:52 <shapr> bwaha
10:22:59 <shapr> Should I slice the guy to shreds? Or should I be nice?
10:23:44 <Darius> lambdabot: @flip-coin
10:23:45 <lambdabot> Sorry, I don't know the command "flip-coin", try "lambdabot: @listcommands
10:23:55 * shapr snickers
10:28:17 <SyntaxNinja> what's LtU?
10:28:45 <arjanb> http://lambda-the-ultimate.org/
10:32:15 * shapr finds the guys email address
10:32:48 <shapr> Seems he's used Perl, Ruby, and Python. I'm not convinced he's qualified to compare Haskell and Python.
10:33:11 <edwinb> ooh, language fight! where!
10:33:25 <shapr> on lambda-the-ultimate.org
10:33:39 <shapr> I said that when I learned Haskell I never wanted to go back to Python, because Python is too restrictive.
10:33:43 <edwinb> Presumably the post with lots of comments...
10:33:53 <shapr> yeah, six zillion and counting.
10:34:06 <Darius> edwinb: Actually, most of those comments are related to tail call optimization.
10:34:19 <shapr> and Darius features regularly in the TCO discussion :-)
10:34:29 <shapr> it's fun to read
10:34:37 <edwinb> that looks quite an interesting discussion
10:35:55 <jadrian> shapr: hmmm, I don't know python, but I don't think people can grasp Haskell in 8h either...
10:36:58 <shapr> I just said that Haskell is significantly less restrictive than Python.
10:37:04 <edwinb> I'm not sure what you mean by "restrictive" here. It even lets you run programs with type errors in them ;)
10:37:30 <jadrian> shapr: yeap, that I cannot comment since I don't know python :)
10:38:12 <shapr> Every time I used Python, I immediately wish for multi-line lambdas, partial application, pattern matching, decent TCO, etc etc
10:38:19 <jadrian> I thought about learning it but dynamic typing scares me :-/
10:38:33 <edwinb> I usually wish for type declarations
10:38:50 <edwinb> And algebraic data types.
10:38:53 <edwinb> Although I suppose you can pretend.
10:39:27 <jadrian> I thought python had ADTs...
10:40:16 <Darius> I wonder if rmalafaia knows where one of Python's "best features", list comprehensions, come from.
10:40:27 <jadrian> shapr: what's TCO?
10:40:53 <shapr> tail call optimization
10:40:54 <arjanb> tail call optimization?
10:40:57 <jadrian> ah
10:40:59 <jadrian> thanks
10:41:53 <jadrian> I' had only seen TCO in the context of Total Cost of Ownership :D
10:43:04 <shapr> nope, no ADTs in Python.
10:43:13 <shapr> I love ADTs, they're like semantic lego.
10:43:36 <jadrian> yeap
10:43:45 <xerox> ADT = ?
10:43:56 <jadrian> algebraic data type
10:45:28 <shapr> hiya divgrad 
10:45:43 <shapr> How's Belarus?
10:45:44 <divgrad> hi
10:45:54 <divgrad> bad, no snow
10:46:06 <shapr> Oh, I could send you some from Sweden :-)
10:46:43 <divgrad> and bears woke up in woods from that
10:46:47 <shapr> yikes!
10:47:13 <divgrad> tx, u care abt us much better than our government
10:47:18 <shapr> haha
10:47:45 <shapr> I also learned something new. I didn't know that bears hibernation sensors were temperature dependent.
10:48:03 <divgrad> i read abt that an hour ago
10:48:50 <divgrad> perhaps they think its time to have a breakfast and see no food around
10:49:10 <divgrad> they will come and eat ppl
10:49:25 <shapr> Time to buy bear traps!
10:49:26 <divgrad> ok, its offtopic
10:49:56 <shapr> Yes, are you looking for Haskell information?
10:50:26 <divgrad> im hunting for something mature
10:50:43 <divgrad> is Haskell a mature thing?
10:50:57 <shapr> I think so.
10:51:00 <divgrad> with good libs
10:51:05 <SyntaxNinja> it's rated PG-13 if that's what you mean
10:51:10 * shapr grins
10:51:21 <shapr> What sort of libraries do you need?
10:51:36 <divgrad> 13 years for prg lang is a long way
10:51:58 <divgrad> for code with comfort under windows
10:52:02 <divgrad> coding
10:52:54 <shapr> The most active Haskell implementation is partially funded by Microsoft.
10:53:16 <divgrad> really?
10:53:45 <shapr> Yup, Simon Peyton-Jones and Simon Marlow work for Microsoft in Cambridge.
10:53:45 <divgrad> i thought they base their F# on ML
10:54:09 <shapr> I think that's partially because tail call optimization on dot net sucks.
10:54:13 <divgrad> sorry, im not keen in big names
10:54:31 <divgrad> and in functional languages also
10:55:12 <divgrad> well, i need to serf some Haskel sites now
10:55:26 <Nioate> F# is based on ML
10:55:48 <shapr> There may not be enough Haskell libaries for comfortable coding on Windows, it depends on what you want to do.
10:55:56 <Darius> research.microsoft.com/~simonmar research.microsoft.com/~simonpj
10:56:31 <foldl> Hi everyone
10:56:50 <foldl> anyone here?
10:57:16 <foldl> ??
10:57:22 <Lemmih> Yes.
10:57:28 <foldl> i need some help...can anyone help me?
10:57:39 <Lemmih> Sure.
10:57:47 <foldl> can we talk in pvt?
10:57:49 <Maddas> Why don't you just ask your question and see?
10:57:55 <foldl> oh ok then
10:58:29 <foldl> im kind of noob in haskel
10:58:46 <foldl> and i am jammed in a few programs
10:59:13 <foldl> like one of them i cant stop the function
10:59:24 <foldl> it just keep giving me '0'
11:00:03 <shapr> What's the function?
11:00:15 <foldl> xElem :: String -> Char				        -- Tipo da função.
11:00:15 <foldl> xElem [] = ' '					        -- Esta paragem da erro, devido a isso não consegui avançar mais...
11:00:15 <foldl> xElem (x:xs) = x					-- Dá o primeiro elemento da String, um caracter.
11:00:18 <shapr> If it's less than three lines long, you can past it here.
11:00:23 <foldl> it does the same as head
11:00:43 <foldl> what sould i place instead of ' '? to stop it?
11:02:01 <shapr> What should the function do?
11:02:10 <shapr> should it be just like head?
11:02:15 <foldl> no
11:02:42 <foldl> i use it in another function, if i use head it gives me the same result, it asks for []
11:02:50 <foldl> xx :: [String] -> Int					-- Tipo da Função
11:02:50 <foldl> xx [] = 0						-- Paragem.
11:02:50 <foldl> xx (x:xs)				
11:02:50 <foldl> 	|xElem x == '1' = 1 + xx xs			-- Se o primeiro elemento for um '1', somatório 1 + o resto da lista...
11:02:50 <foldl> 	|otherwise = 0 + xx xs	
11:04:09 <jadrian> ok... so what is the prob with xElem as it is?
11:04:24 <foldl> when i run xx it doesnt stop....
11:04:53 <foldl> if i dont say that xElem [] = ' ' it will give error, asking for []
11:05:09 <foldl> if i put it, it keeps giving me 0...forever
11:05:10 <jadrian> it doesn't stop?
11:05:28 <jadrian> is the list you are using infinite?
11:05:37 <foldl> actually...wait
11:06:05 <shapr> You need to add a base case?
11:06:24 <jadrian> shapr: he has one:  <foldl> xx [] = 0 
11:06:54 <foldl> xElem :: String -> Char				        
11:06:54 <foldl> xElem [] = ' '					        
11:06:54 <foldl> xElem (x:xs) = x					
11:06:54 <foldl> xx :: [String] -> Int					
11:06:54 <foldl> xx [] = 0						
11:06:55 <foldl> xx (x:xs)				
11:06:57 <foldl> 	|xElem x == '1' = 1 + xx xs			
11:06:59 <foldl> 	|otherwise = 0 + xx xs				
11:07:01 <foldl> zz :: [String] -> [Int]					
11:07:03 <foldl> zz [] = []						
11:07:05 <foldl> zz (x:xs) = [xx (x:xs)] ++ zz (tt (x:xs))		
11:07:07 <foldl> tt :: [String] -> [String]				
11:07:09 <foldl> tt []= []						
11:07:11 <foldl> tt (x:xs) = [drop 1 x] ++ tt xs				
11:07:13 <foldl> im suposted to run zz
11:07:15 <foldl> and it doesnt stop
11:07:36 <shapr> too much pasting
11:07:42 <shapr> you should paste this code on the paste page
11:07:49 <shapr> @wiki HaskellIrcPastePage
11:07:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:08:21 <foldl> how does it work?
11:08:24 <shapr> wow, the OldPastePage is huge
11:08:33 <Darius> foldl: why are the functions named, "xx", "zz" and such?
11:08:35 <shapr> foldl: it's a wiki, click EditText at the bottom and put your code in.
11:09:02 <jadrian> Darius: former fortran student? :)
11:09:23 * shapr snickers
11:10:11 <foldl> i pasted it...now what?
11:10:12 <shapr> reminds of the time my boss asked me to help him find out why a spam filter was rejecting fortran code he was sending to a customer. I immediately spotted a bunch of variables named XXX and once he changed that, the spam filter let it go by.
11:10:26 <foldl> lol
11:10:36 <foldl> i named them xx and ff and so just temporarily
11:11:04 <foldl> but what should i do now?
11:11:15 <shapr> For one thing, it might be easier to look at the code if you give meaningful names to your functions and variables.
11:11:17 <jadrian> shapr: lol
11:11:42 <foldl> indeed....
11:14:02 <foldl> im working on thjis for soooooo long i think im about to colapse
11:14:12 <shapr> What should zz do?
11:14:35 <foldl> hmm, its like this:
11:14:55 <kosmikus> good evening ...
11:15:27 <foldl> im trying to make a [Str] -> [Str] -> [(Str,[Int])]
11:15:53 <shapr> hoi kosmikus 
11:15:58 <foldl> where the first [Str] is for example "A","B","C"
11:16:28 <foldl> and the second Str is "1", "3 1" ,"3 1 2","2"
11:16:33 <foldl> for example
11:17:14 <foldl> and i want to make a function that counts how many times 1 is the first number, the second, the third....etc and the same for the other numbers
11:17:42 <foldl> so then it would be "A",[1,2,0]
11:17:51 <foldl> being A -> 1
11:17:57 <foldl> its complicated....
11:18:40 <shapr> Oh, find out where each number is its own index?
11:18:58 <foldl> sry i dont understand....
11:19:05 <shapr> I'm not sure I understand the specification.
11:19:36 <foldl> A corrspods to 1, B to 2 etc....
11:19:54 <shapr> so, A turns into 1, then you count how many times 1 was in the first position, the second position, and etc
11:20:02 <foldl> exactly
11:20:11 <shapr> and if you get B, you look for only 2?
11:20:16 <foldl> yes
11:20:53 <foldl> so in the end it tells me how many times 1 is on the first position, on the second on the third etc...and for B how many times 2 is in the first position and the second...etc
11:21:13 <foldl> for no matter how many bariables i put
11:21:18 <foldl> variables*
11:21:41 <shapr> So, do you already have code that turns A into 1, B into 2, etc?
11:22:52 <foldl> no, and it doesnt "turn" into A or B its correspondent
11:23:21 <foldl> a means 1, b means 2....but its because of the order they show up in the [Str]
11:23:45 <shapr> ok
11:23:52 <foldl> if the [Str] is ["E","B","H"] E is 1
11:23:55 <foldl> B is 2 etc
11:24:49 <shapr> I'm confused
11:24:53 <foldl> lol
11:25:23 <foldl> if im bothering you...please, tell me!
11:25:30 <shapr> I just don't understand the question :-)
11:25:32 <foldl> im sure you have better things to do
11:25:46 <shapr> I could be writing a unicycling game...
11:25:49 * shapr grins
11:25:58 <foldl> lol
11:26:17 * edwinb tries to imagine
11:26:27 <edwinb> My girlfriend's uncle has randomly decided to buy a unicycle.
11:26:28 <foldl> can i try to explain to you once more?
11:26:32 <shapr> yes
11:26:45 <shapr> edwinb: give him my email address, I'll get him into the community :-)
11:26:53 <edwinb> hehe
11:26:53 <Darius> foldl: I'm just curious, but what is the whole program supposed to do when it works?
11:27:45 <edwinb> Is it - number of occurrences of each letter in a string?
11:27:52 <foldl> this function is suposed to give the answer to who wins an election, by giving it a Buletin with a list of contestants for example: ["foldl","edwinb",Darius"]
11:28:02 <edwinb> ah....
11:28:09 <foldl> and giving it a list of votes
11:28:20 <foldl> and the votes go like this:
11:28:57 <foldl> ["1 3 2","2 1 3","1","1 2"] for exmple
11:29:13 <foldl> it means, someone voted me as first choice 3 times
11:29:24 <foldl> and once as second...etc
11:29:29 <edwinb> That's an interesting representation for votes...
11:29:45 <foldl> understand now?
11:29:54 <edwinb> Is it necessarily that way? Seems a list of Int would be better.
11:30:00 <foldl> so, this function is suposed to do something like this:
11:30:13 <Darius> Yes I understand.
11:30:25 <foldl> ["A",[3,2,0]
11:30:37 <shapr> That's an easier question :-)
11:30:43 <foldl> ["B",[1,1,1]
11:30:50 <foldl> etc...for how many candidates i insert
11:31:03 <foldl> understand now?
11:31:06 <shapr> yes!
11:31:10 <foldl> AHA!
11:31:52 <foldl> im trying to do this for...
11:32:02 <foldl> 30 hours
11:32:18 <foldl> with 7 sleep in the midle
11:32:37 <shapr> wow
11:33:27 <foldl> im going nuts...so anyone has any ideas?
11:33:47 <shapr> so, what should the input look like again?
11:34:18 <shapr> ["alice","bob","charlie"] [[1,2,3],[3,2,1]] ?
11:34:26 <foldl> yes for example
11:34:37 <foldl> wait no
11:34:50 <foldl> the second is a list of Str too
11:35:05 <foldl> ["1,2,3","3,2,1"]
11:35:47 <kosmikus> that's a separate simple parsing problem to go from there to [Int]
11:35:50 <shapr> and the offset in the list of candidates and the input strings is the same?
11:36:39 <foldl> ???
11:37:20 <kosmikus> write [Str] -> [[Int]] -> [(Str,[Int])] first
11:37:52 <foldl> yes
11:38:38 <foldl> but its not [[Int]] but [str]
11:39:16 <shapr> but whether the votes are "1 2 3" or "1,2,3" you can easily write code to turn that into [Int]
11:39:24 <foldl> oh ok then sry
11:40:02 <Darius> foldl: What happens if 10 or more people are candidates?
11:40:36 <foldl> nothing...it works normaly
11:40:49 <foldl> its suposed to work for infinite ppl...
11:41:28 <Darius> foldl: How do you intend to return the count of infinite votes?
11:41:55 <foldl> well, it wll not work for infinite....
11:42:06 <shapr> I was just trying to think up a lazy version :-)
11:42:07 <foldl> but for any finite number
11:42:43 <foldl> any luck?
11:42:59 <shapr> I can't think of a way to make a lazy version that would fit into zipWith, not if you want to read the second vote too.
11:43:37 <foldl> damn...
11:44:00 <shapr> but that's only if you really want it to work with an infinite number of votes.
11:44:19 <foldl> can it work with 20 0000?
11:44:25 <foldl> 200 000
11:45:25 * shapr thinks
11:47:21 <shapr> I think there a very easy way.
11:47:43 <foldl> realy?
11:47:47 <shapr> yup
11:47:51 <foldl> how?
11:47:57 <shapr> strip, sort, split, length
11:48:07 <foldl> ?!
11:48:46 <shapr> the inputs are positional, so pull all the first items off all the input votes and put them into a single list.
11:49:02 <Darius> The problem intrinsically cannot work with an infinite number of candidates by the way.
11:49:30 <shapr> You could keep a running count of two infinite lists, the first vote and the list of candidates.
11:49:31 <shapr> But that's all.
11:50:07 <foldl> omg...i realy belive that sounds easy to you...but belive me when i say its not to me
11:50:25 <foldl> im still learning
11:51:53 <shapr> I don't like doing too much work, so I try to work on a bunch of the same thing at the same time.
11:52:08 <shapr> first you get all the votes for one person together into a single list.
11:52:24 <Darius> Actually, I made a mistake about what the problem was.  You could get a lazy list of results.
11:52:28 <shapr> then you sort the list to get all the same numbered votes together.
11:52:55 <shapr> then you split the list into sublists that have only the same number vote in each list.
11:53:00 <shapr> Then you get the length of each list.
11:53:20 <shapr> foldl: isn't that easy?
11:53:26 <foldl> hmm ill try that
11:53:41 <foldl> yeah it looks like it...ill see if i can make them work together
11:54:02 <shapr> Part of the secret is to unmix the problem parts.
11:54:19 <shapr> Then every problem is easier to solve.
11:54:58 <shapr> Darius: how?
11:55:35 <shapr> oh
11:55:46 <Darius> My problem was that for some reason I was thinking there were an infinite number of voters.
11:55:49 <shapr> you could have a list of vote lists, where each was infinite.
11:55:57 <shapr> there could be :_)
11:56:04 <foldl> ????
11:56:15 <Darius> shapr: With an infinite number of voters it wouldn't work.
11:56:29 <shapr> hm
11:56:31 <shapr> ok
11:56:42 <Darius> (Unless you consider map (\c -> (c,repeat undefined)) candidates working.
11:56:54 <shapr> right
11:59:22 <foldl> how do i assign the fist name to 1, the second to 2 etc?
12:07:15 <kosmikus> zip with [1..], do a lookup? but again, that's a separate problem, you could write a function of type [[Int]] -> [[Int]] first; that seems to be at the core of everything
12:07:32 <foldl> hmm
12:07:48 <foldl> ok thx!
12:27:14 * Darius doesn't understand why he is getting a 403 from c2.com/cgi/wiki
13:48:47 <Muad_Dibber> hmm
13:54:41 <tinus> an easy way to "flatten" a list of lists ([[a]] -> [a]), what would that be?
13:54:53 <tinus> without ignoring any elements, ofcourse :)
13:54:56 <Cale> tinus: concat
13:55:01 <Cale> or join
13:55:15 <tinus> oh right, that was it, thx :)
13:55:18 <Cale> (join is the general monad function to do this)
13:55:50 <tinus> hmm, monads, we didnt cover that
13:56:39 <tinus> concat works fine though, cheers :)
14:15:48 <joao> Hello
14:16:31 <Lemmih> Greetings.
14:16:56 <joao> What's up? :)
14:17:33 <SyntaxNinja> hihi Lemmih
14:17:40 <Lemmih> Tried to hack something like ocamlbrower for Haskell but wxHaskell is pretty unusable on Linux.
14:17:47 <Lemmih> SyntaxNinja: Hey (:
14:18:32 <musasabi> Lemmih: use hs-fltk ;p
14:18:51 <Lemmih> And I can't even make a doc lambdabot module since lambdabot can't compile with GHC 6.3 /-:
14:19:31 <Lemmih> musasabi: How complete is it?
14:20:19 <musasabi> Lemmih: it is quite good for basic "I want to get a quick GUI working" but not very fullfeatured.
14:21:18 <musasabi> of course if you need a feature you can just ask.
14:24:22 <Lemmih> musasabi: I need trees, lists, text fields and panels.
14:24:57 <Lemmih> Having :doc might be enough for now.
14:25:02 <joao> Lemmih, why do you say that it's unusable in Linux?
14:26:25 <Lemmih> joao: I haven't been able to load the package in GHCi.
14:26:40 <Lemmih> joao: It's a known bug, iirc.
14:27:08 <joao> Hmmm, but it's possible to do it, right?
14:28:17 <Lemmih> joao: I've seen the debian package work in GHCi.
14:28:48 <joao> I think I've installed wxHaskell from source and put it working, some time ago..
14:30:24 <Lemmih> joao: Really? Even if you can load the package, evaluating 'start' twice should segfault, I believe.
14:30:26 <musasabi> Lemmih: all but trees should work fine (adding trees from FLU would take me ~2 hours of work)
14:30:37 <joao> Lemmih, yes
14:30:45 <joao> Lemmih, I remember something like that
14:34:01 <CosmicRay> question.  could TH theoretically be used to output non-Haskell code, in the same way that camlp4 can output non-caml code from the caml AST?
14:34:47 <musasabi> CosmicRay: to external files certainly - it should be possible.
14:36:36 <Lemmih> Everything you can think of in the IO monad is possible from TH.
14:44:14 <Lemmih> musasabi: Any reason you dont prefix your module names with Graphics.UI.?
14:46:47 <Lemmih> musasabi: Oh. No GHCi, no go. /-:
14:50:10 <musasabi> Lemmih: well it is a problem in GHCI.
14:50:40 <joao> Lemmih, HTk doesn't work?
14:50:40 <musasabi> Lemmih: new code supports the Graphics.UI.FLTK - I am moving the code under it slowly.
14:51:05 <musasabi> that ghci dies if the library contains weak symbol references.
14:51:24 <Lemmih> joao: Has HTk been cabalized?
14:52:26 <joao> Lemmih, if I knew what cabalized means I would answer your question :-)
14:52:51 <musasabi> cabal is the new haskell package framework.
14:53:04 <Lemmih> joao: GHC 6.3+ only supports Cabal packages.
14:53:14 <musasabi> getting a stable cabal version out would be nice...
14:53:32 <joao> Oh, always learning :)
14:53:44 <musasabi> (now I have different ghc-cvs snapshots on different machines and they all support incompatible ways of doing things)
15:00:16 <Lemmih> I wonder how much work it would be to cabalize wxHaskell.
15:01:04 <musasabi> Lemmih: waiting for 6.4 might make sense.
15:01:45 <wilx> "A new STABLE branch will be forked in preparation for the 6.4 release shortly, and we plan to release 6.4 around October/Novermber."
15:01:54 <wilx> October 2005 or 2004?
15:03:15 <musasabi> wilx: 2004.
15:03:30 <musasabi> wilx: but they are still putting finishing touches on it.
15:04:03 <wilx> I see.
15:04:12 <SyntaxNinja> musasabi: a stable cabal will get released w/ the next GHC
15:04:14 <Lemmih> musasabi: I can't wait that long.
15:04:21 <SyntaxNinja> (and at the same time, a separate 1.0 will come out)
15:05:10 <musasabi> SyntaxNinja: yes, I am waiting for that.
15:05:39 <SyntaxNinja> I want to release a 0.3 before that, but I'm not such a dictator on the project anymore, and I have to wait for consensus about some stupid stuff like the name of Setup.description
15:06:12 <musasabi> Currently I have an old Cabal 0.2 installation, a ghc cvs with hidden-modules changed, and now I'd need to update to the *.cabal...
15:06:37 <musasabi> So I am just trying to wait until something semistable comes out again.
15:06:49 <SyntaxNinja> the 0.3 release of cabal, and the one in CVS and darcs, still allow Setup.description
15:07:08 <musasabi> ok..
15:07:34 <SyntaxNinja> just don't use the hooks, and you should be fine w/ the darcs version
15:09:08 <musasabi> I am thinking of switching to use the hooks so I am waiting.
15:09:26 <SyntaxNinja> I'll try to let these guys know that screwing around with the filename is delaying a release
15:09:40 <musasabi> btw the idea for the configuration hook to be PackageDescription -> IO PackageDescription was a nice one.
15:09:48 <SyntaxNinja> thanks :)
15:10:36 <SyntaxNinja> oh, krasimir's suggestion or whatever?
15:10:40 <SyntaxNinja> from today or yesterday?
15:11:01 <SyntaxNinja> yeah, I'll have to look at that.
15:11:04 <musasabi> well I remember I read the mail today (currently in bed with a text terminal)
15:11:29 <SyntaxNinja> if you want to help out w/ cabal stuff to speed it up, you could look at simon's list of things to do for the ./setup haddock command.
15:12:15 <musasabi> Personally I don't care much for the name of the Setup.description, just hope that if the answer is *.cabal then the semantics with multiple .cabal files are sensible.
15:12:46 <musasabi> hmm where is that list?
15:15:18 <SyntaxNinja> on cvs-libraries
15:15:35 <musasabi> one more list to read...
15:15:50 <musasabi> I'll check that up in the morning.
15:17:55 <Olev> is anyone bored and can help me with some haskell tasks? :)
15:18:53 <Lemmih> More annoyed than bored actually but go ahead and ask your question(s).
15:22:07 <Olev> they are basic but damn hard ... well the first one was a function natToBin :: Int -> [Int] that was not a horribly difficult task ... but the second one that i need some help with is bins :: Ints -> [String] ... where the function should show all binary strings length of Int ... for example bins 2 ==> ["00","01","10","11"]
15:24:16 <Lemmih> map showBin (2^n)
15:24:27 <Lemmih> showBin :: Int -> String
15:25:09 <SyntaxNinja> Olev: is that homework?
15:25:21 <Olev> SyntaxNinja, you could say so
15:27:38 <Lemmih> Olev: 'showBin' shouldn't be too hard to implement.
15:28:06 <Olev> well i was thinking in counting down the numbers and doing natToBin with every number
15:28:19 <Olev> then concatenating the natToBin answers
15:29:24 <Lemmih> Ahem. I meant: 'map showBin [1 .. 2^n]'
15:29:53 <Lemmih> Olev: Familiar with 'map'?
15:31:12 <Olev> it's an example in the gentle introduction
15:32:02 <Lemmih> *[0 .. 2^n-1]
15:32:26 * Lemmih is way too tired to think clearly.
15:32:31 <Lemmih> Good night, #haskell.
15:32:36 <musasabi> night.
15:32:43 <joao> Good night, Lemmih 
15:32:54 <SyntaxNinja> 'night Lemmih
15:34:33 <Olev> well map behaves not the way the problem is
16:18:07 <Olev> can anyone give me some pointers on that problem please?
16:21:44 <arjanb> solve the problem for n=1 and n=2 and then try to express n=2 using the function for n=1
16:22:35 <Olev> for n=1 it is easy, when n=2 it gets tiugh
16:22:37 <Olev> tough
16:23:02 <Pseudonym> That's why you're smart.
16:24:53 <Olev> well haskell is a thing I cannot define my smartness with.
16:27:16 <arjanb> what code do you have now?
16:33:46 <Cale> I like the solution using sequence
16:33:54 <Cale> but that's a bit obscure :)
16:35:57 <Olev> well my code is bad and only correct for 1 :)
16:36:50 <Cale> Olev: if foo is the list of all strings of length n-1, how can we use it to get the list of all strings we want of length n?
16:38:09 <Olev> some substrings function?
16:39:09 <Cale> well, wouldn't just taking those strings, and adding 0 or 1 to the front of them give us all the strings we want?
16:40:07 <Olev> might be
16:44:49 <ex_nor> 00
16:44:50 <ex_nor> 01
16:44:51 <ex_nor> 10
16:44:51 <ex_nor> 11
16:45:10 <ex_nor> now... the next ones are exactly the same, but with a 0 first, then with a 1 first
16:45:10 <ex_nor> 100
16:45:11 <ex_nor> 101
16:45:13 <ex_nor> 110
16:45:18 <ex_nor> 111
16:45:24 <ex_nor> errr, that's the last 4, but you get the idea
16:53:11 <ex_nor> ssssoooooo
16:54:07 <ex_nor> f n = (map ((++) "0") (f (n - 1))) ++ (map ((++) "1") (f (n - 1)))
16:54:45 <Olev> whoa
16:55:18 <ex_nor> doubt they're expecting you to do it like that though.
16:55:52 <Olev> damn, I can't even read that
16:56:03 <Cale> my favourite is f n = sequence (replicate n "01")
16:56:07 <ex_nor> it's messy
16:56:18 <ex_nor> Cale: well, if that works...
16:56:31 * ex_nor doesn't remember what sequence does
16:56:42 <arjanb> @type sequence
16:56:46 <lambdabot> sequence :: forall a m. (Monad m) => [m a] -> m [a]
16:56:47 <Cale> sequence on lists of lists takes the Cartesian product
16:58:26 <Olev> don't know if i'm allowed to use prelude functions so freely
16:58:56 <ex_nor> f n = (f (n - 1)) ++ (toBin n)
16:59:03 <ex_nor> errr, showBin
16:59:05 <ex_nor> or whatever
16:59:16 <ex_nor> something like that should also work
17:00:15 <jadrian> Cale: yeap sequence on lists is pretty handy :)
17:00:42 <jadrian> funny how much one can do with monadic functions
17:01:32 <aFlag> what's the difference between Int and Integer?
17:01:33 <dons> tintin: looks like you have an old version of hs-plugins installed
17:02:00 <ex_nor> Integer is a Big type... if I remember correctly
17:02:14 <jadrian> aFlag: Integers have no size limit
17:02:19 <dons> tintin: you need the "Nightly cvs src snapshot"
17:02:31 <ex_nor> which makes them slower
17:02:33 <ex_nor> of couse
17:02:49 <aFlag> oh
17:02:56 <ex_nor> but no overflows
17:15:16 <wli> Is there chess code floating around? I'm trying to throw a computer at a specific kind of chess problem.
17:18:27 <wli> (namely, I saw what I believed to be inferior play and think some particular endgame should have been won)
17:22:13 <ex_nor> I'm not convinced you'd want to do that in Haskell in any case...
17:22:17 <wli> (this being on the part of a computer using alpha-beta search, so I need a more rigorous proof of the thing being won, lost, or drawn)
17:22:54 <ex_nor> not that I know anything at all
17:23:05 <wli> ex_nor: well, it's a calculator-like affair and it's not particularly time-critical for results (e.g. it can spin for a few weeks to produce answers vs. needing to play in realtime)
17:23:38 <ex_nor> well... my guess with any real chess position it'd be more like months in Haskell
17:23:43 <ex_nor> but I could be wrong
17:23:59 <wli> it's not an arbitrary position, but a specific endgame
17:25:01 <wli> It's a 6-piece ending so it's only one step beyond normal endgame tables.
17:25:21 * ex_nor nods
17:25:23 <ex_nor> okay
17:25:40 <ex_nor> well I can't help you in any case
17:25:47 <wli> The thing I noticed was that the piece trap vulnerability seemed to cropping up.
17:25:51 <wli> Both gnuchess and crafty share it.
17:26:02 <wli> in this case, it happened in reverse
17:26:11 <wli> Piece traps were available but not understood
17:26:18 <wli> and so not exploited by the winner
17:27:11 <wli> It's the only way I can win against gnuchess (for some reason, crafty doesn't let them arise anywhere near as often, but when it does it's just as vulnerable).
17:43:45 <wli> it's kind of obvious why though
17:43:57 <wli> it takes a number of moves to capitalize on the piece trap
17:44:15 <wli> so while the thing can be kept there the final attacker moves in slowly
17:44:30 <wli> e.g. a king inching across the board
17:44:41 <wli> which can easily take 5-8 moves
17:45:24 <wli> which blows past the search horizons
17:51:52 <CosmicRay> good evening.
17:51:58 <CosmicRay> I have an extremely evil url to announce.
17:52:02 <CosmicRay> this is very scary.
17:52:21 <CosmicRay> you may have nightmares after visiting this url.
17:52:31 <CosmicRay> http://jnode.sourceforge.net/
17:56:54 <dons> argh!
17:57:10 <CosmicRay> I warned you! :-)
17:57:32 <Riastradh> You warned us of mere nightmares, not heart attacks or cardiac arrests!
17:57:33 <dons> "fast and secure"!
17:57:38 <CosmicRay> hehe
17:57:47 <CosmicRay> dons: their own benchmarks disprove the "fast" bit
17:57:56 <CosmicRay> dons: they're slow even compared to sun jdk :-)
17:58:17 <dons> that's what access to hardware does for you ;)
17:58:25 <CosmicRay> lol
18:04:07 <sh10151>  what the heck is jnode?
18:04:26 <CosmicRay> did you follow the url?
18:04:43 <CosmicRay> it's just as bad if I tell you :-)
18:04:49 <SyntaxNinja> CosmicRay: sfw? ;)
18:05:05 <CosmicRay> sh10151: it's a "Java operating system"
18:05:09 <SyntaxNinja> hahaha "I've added a "classpath" command to modify the classpath of the shell."
18:05:12 <SyntaxNinja> that's soooo java
18:05:15 <CosmicRay> most of the OS is written in JAva
18:05:17 <CosmicRay> heh
18:05:19 <SyntaxNinja> "of course the java OS needs a classpath command!!"
18:07:41 <Lunar^> CosmicRay: hOp started mostly because of JNode, you know
18:08:03 <CosmicRay> Lunar^: I didn't, but I guess at least we can say it inspired something non-evil :-)
18:08:34 <Lunar^> hOp is as evil as JNode, if you want my opinion
18:08:40 <CosmicRay> heh
18:08:48 <Lunar^> Using a lazy language for kernel programming?!
18:09:13 <CosmicRay> it introduces that sought-after unpredictability factor into the operating system
18:09:23 <CosmicRay> see, the problem with jnode is that it is too predictable
18:09:29 <Lunar^> lol
18:09:50 <CosmicRay> all you need to see is "java operating system" and you know it is: 1) slow, 2) bloated, 3) probably buggy, 4) having loads of features nobody needs, 5) having few useful features
18:09:50 <SyntaxNinja> sigHangOnATicImGarbageCollecting
18:09:54 <CosmicRay> oh yes
18:09:57 <wli> House?
18:10:05 <CosmicRay> and 6) introduces carpal tunel syndrome
18:10:10 <Lunar^> lol
18:10:26 <Lunar^> CosmicRay: though JNode is a very good documentation for device drivers impl.
18:10:51 <Lunar^> CosmicRay: because of carpal tunnel, they are really readable wrt linux ones
18:11:02 <sh10151> CosmicRay: but now Eclipse will autotype and autogenerate all those things to type!
18:11:09 <CosmicRay> haha
18:11:49 <SyntaxNinja> sigClassNotFoundException:edu.glasgow.readp
18:11:52 <Lunar^> sh10151: Pretty true, unfortunately... I want an IDE for Haskell so bad
18:12:24 <sh10151> i did a little hacking of haskell-mode
18:13:32 <sh10151> enough to talk to ghci and display the type of a function in the minibuffer
18:13:39 <sh10151> even if no type was in the buffer
18:13:46 <Lunar^> CosmicRay: Anyway, hOp and JNode share a lot of common problems : multi-threaded kernel, garbage collected languages...
18:14:05 <sh10151> hardly an IDE, but SLIME and the JDEE are pretty good examples of emacs-based IDEs :)
18:14:35 <Lunar^> CosmicRay: Their handling of IRQs is pretty hacky but more reliable than the one I've managed to do in hOp, for an example
18:15:08 <Lunar^> sh10151: That's far from Quick Fix feature for Java in Eclipse
18:15:53 <sh10151> ha
18:16:24 <sh10151> I don't think a quick fix feature for Haskell is very likely
18:17:00 <CosmicRay> what is this quick fix feature?
18:17:04 <sh10151> nor a refactoring
18:17:27 <Lunar^> sh10151: Select an expression, hit Ctrl+1, select "Name in where clause"
18:17:47 <Lunar^> sh10151: enter a name, woosh it has factorized out
18:18:28 <sh10151> that's not quick fix
18:18:30 <sh10151> that's refactor
18:18:31 <sh10151> :)
18:18:42 <Lunar^> Referential transparency would let us have far more interesting features like this
18:18:50 <sh10151> quick fix is "I forgot to import java.util.Iterator"
18:19:02 <Lunar^> sh10151: Isn't Ctrl+1 called Quick Fix?
18:19:26 <sh10151> i thought quick fix is what you get when you click on  an error line
18:19:33 <sh10151> I would check but eclipse takes too long to start :)
18:19:59 <Lunar^> sh10151: anyway, we both talk about the same thing
18:20:06 <sh10151> if Eclipse's editor were better I would like it more
18:20:15 <Lunar^> but I'm off to bed now
18:20:19 <sh10151> night :)
20:47:11 <tintin> dons: i have some trouble with compiling yi what am i doing wrong here 
20:47:33 <dons> what's the error message?
20:47:44 <dons> previously, you had the wrong version of hs-plugins
20:47:49 <tintin>  
20:47:50 <tintin> Boot.hs:287: Variable not in scope: `unloadPackage'
20:47:50 <tintin> make: *** [Boot.o] Error 1
20:47:50 <tintin>  
20:47:54 <dons> you need the _nightly_ snapshot
20:48:08 <tintin> i did put in the nightly snapshot 
20:48:12 <dons> unloadPackage was on implemented recently (around Nov 20)
20:48:55 <tintin> is there a hs-plugin version command ?
20:49:15 <dons> do you have the snapshot release, or the nightly cvs snapshot (they're different)?
20:49:48 <tintin> 20041014
20:49:48 <tintin> so it wont have whats needed ?
20:49:52 <dons> the proper version lives at: ftp://ftp.cse.unsw.edu.au/pub/users/dons/hs-plugins/snapshots/
20:50:32 <dons> 1014 is not the 'nightly cvs snapshot', it was a 'snapshot _release_' . sorry for the confusion
20:50:56 <dons> you need an hs-plugins later than 20041120
20:51:12 <tintin> oh sorry i should have checked 
20:57:12 <dons> did you get it to build?
20:57:57 <tintin> dons: i completed the hs-plugin install now trying yi 
20:58:14 <dons> make sure to 'make register' hs-plugins
20:58:21 <tintin> i did
21:02:22 <tintin> dons: tnx its completed 
21:03:51 <tintin> yi --as=emacs for emacs bindings ?
21:06:57 <dons> yep, but shapr hasn't finished the emacs binding yet
21:07:08 <dons> so nano is the closest you'll get
21:11:57 <tintin> woops 
21:12:03 <tintin> shapr: #$#%!@%#%
21:13:45 <dons> no no. emacs is the hardest binding to write.
21:14:49 <tintin> hmmz so rebinding keys will be harder once the binding is written ? 
21:15:07 <dons> no, why should it?
21:15:24 <tintin> where are the present bindings housed ?
21:15:37 <dons> Yi/Keymap/
21:16:10 <dons> examples/AddBind.hs illustrates how to add bindings in config files
21:16:23 <dons> in vi/vim mode, you can add  binds with :map
21:16:54 <tintin> there are some Emaces.hi and Emacs.hs files in there they are incomplete ?
21:17:50 <dons> they are old. they were written before we settled on a language for writing keymaps
21:18:03 <dons> hmm. also tuomov has a jed binding
21:23:23 <SyntaxNinja> anyone care to brainstorm about cabal?
21:23:29 <SyntaxNinja> musasabi around?
22:04:30 <SyntaxNinja> wli: still interested in that sun blade 100?
22:40:08 <weel> Does anyone know if there is a publicly available implementation of pH (a parallel Haskell dialect from MIT)?
22:40:35 <desrt> like GpH?
22:41:10 <weel> That's _Glasgow_ parallel Haskell, right? I think that's different, but correct me if I'm wrong.
22:41:27 <desrt> i wouldn't know.  i've merely heard of it :)
22:41:55 <weel> Hmm... the one I'm thinking of is the one in Implicit Parallel Programming in pH
22:41:55 <weel> by Rishiyur S. Nikhil, Arvind 
22:43:01 <shapr> I thought pH was an eager Haskell by Jan-Willem Maessan?
22:43:07 <dons> Nothing in the community report?
22:44:48 <dons> pH is mentioned in Maessan's work, but refers to Nikhil et al
22:44:51 <weel> It _is_ by Jan-Willem Maessen, although it is not the same as "Eager Haskell", which Maessen was apparently also involved with, I just read.
22:45:26 <weel> The links on csg.csail.mit.edu all refer to Maessen's personal site, which is down, presumably since he graduated.
22:45:33 <shapr> I think I saw pH available for download from Jan's page. If not, I think he'd send you a copy if you emailed him.
22:45:33 <dons> Maeseen wrote the paper  "Eager Haskell"
22:46:15 <weel> I think that's what I'll do then.
22:46:25 <shapr> I do know that Maessan did some work on distributed GC, and I know he worked with Arvind on something.
22:46:50 <dons> "Eager Haskell is an outgrowth of ld and pH"
22:46:55 <shapr> aha
22:47:09 <weel> ah, I found the links again: http://csg.csail.mit.edu/projects/?action=viewProject&projectID=4&projectGroup=Programming%20Languages
22:47:47 <weel> so I figure I ought to be able to get eager haskell and read the pH papers without getting to horrendously confused
22:48:03 <shapr> What are you doing?
22:48:18 <shapr> just idly curious...
22:48:35 <weel> trying to understand some older papers from Arvind's group on hardware languages
22:48:38 <dons> this isn't going to be H98 is it?
22:49:04 <dons> though Eager Haskell was
22:49:30 <shapr> weel: sounds interesting, any particular papers?
22:50:19 <weel> sure, i'm currently reading csg memo 403, which describes the basis for this thing called bluespec
22:51:27 <weel> which is a hardware description language that is (was) based on haskell, although it seems that the company that they spun off wants to at least syntactically make it more like verilog
22:51:29 <shapr> oh, that's Lennart Augustsson's project.
22:51:44 <shapr> I've heard a bit about it.
22:52:04 <weel> really? like what?
22:52:41 <shapr> Nothing I can remember at the moment, I've been more interested in Peter Gammie's Lustre/Lava successor he's been writing.
22:53:02 <shapr> Have you read about the various flavors of Lava and Hawk?
22:53:21 <shapr> That is, if you're looking for an overview of hardware design languages...
22:53:46 <weel> not much, I first read the various bluespec manuals
22:53:58 <shapr> I don't know if that sort of info will help you with bluespec specifically.
22:54:39 <weel> see, my issue is that I'd actually like to be able to _use_ one of these as well as learn about them; it seems, though, that they're all in the process of being commercialized and therefore pulled off the net
22:54:49 <shapr> Anyway, Lava the hardware design language had at least two flavors, from Chalmers and Xilinx.
22:54:56 <shapr> Yes, I agree :-(
22:55:21 <shapr> I swapped emails with Satnam Singh recently about Xilix Lava, I'd love to be able to write my own coprocessor using Haskell.
22:56:15 <shapr> He said that there's an open source version being written at Chalmers. I think he's talking about Peter Gammie's project. All the other versions of Lava appear to be shutdown or commercialized, as you said.
22:56:43 <shapr> I think Chalmers is still using their Lava version, but I don't think copies are available.
22:56:59 <weel> it says on their site that they pulled it because of "legal issues" or some such
22:57:31 <shapr> I don't believe it. Singh sounded like he really wanted to get a free or at least freely usable version out there.
22:57:45 <shapr> But hey, I'm not a big company, maybe they had a really good reason.
22:57:55 <desrt> does anyone know how to setup a ghc nightly build?
22:57:58 <weel> Hmmm... maybe I should talk to him then?
22:58:03 <desrt> (before i go and email the list about it)
22:58:35 <shapr> weel: I dunno, what's your goal here? learning about bluespec? writing your own HDL?
22:58:36 <weel> For what it's worth, often the individuals at big corp's are all in favor of free software, but some higher-up won't let them.
22:59:11 <shapr> Singh left Xilinx and joined Microsoft, I don't think he can affect the fate of Xilinx Lava much.
22:59:52 <shapr> There is a tutorialfor Xilinx Lava that was on their website, it might help you a bit.
22:59:56 * shapr searches for the link
22:59:58 <dons> desrt: yep
23:00:12 <desrt> dons; excellent.  what do i need to do?
23:00:33 <dons> check out $fptools/nightly
23:00:39 <weel> Well, I'd like to (1) learn about TRS based HDLs in general, because I think they're cool, and (2) use one, because I am working on a hardware project (which is kind of cool; it involves a processor that does computation on types as well as values).
23:00:39 <desrt> oh.  convenient
23:00:56 <shapr> weel: http://www.xilinx.com/labs/lava/
23:01:06 <dons> then edit nightly/site/* to your liking
23:01:22 <shapr> What's TRS?
23:01:24 <dons> have a look at nightly/site/defaults/README
23:01:29 <weel> term rewrite system, i'm sorry
23:01:32 <desrt> alex, happy, ghc, hslibs, libraries, testsuite, nightly?
23:01:43 <shapr> ah, ok.
23:01:51 <dons> desrt: yep - you'll need all those
23:01:57 <dons> ls
23:02:00 <desrt> oh.  i'll probably also need cvs installed :)
23:02:02 <shapr> sed is the ultimate TRS ;-)
23:02:47 <dons> desrt: a nightly build just involves setting some flags, and some vars in your local conf-* and exec-* files
23:02:52 * desrt finally installed his 2nd linux box at work today
23:03:08 <weel> well, thanks all, I guess I have some more reading to do
23:03:09 <desrt> dons; how does it check out the cvs?
23:03:29 <dons> you set the CVS var. so anoncvs works fine
23:03:41 <desrt> cool
23:03:46 <dons> update_source=YES
23:03:53 <dons> CVSROOT=:pserver:anoncvs@cvs.haskell.org:/cvs
23:04:00 <desrt> woh.  slow down dude :)
23:04:13 <dons> it's all in the nightly/site/*/* examples
23:04:27 <desrt> i should probably create a user for this, eh?
23:04:37 <dons> nah. no one else does
23:04:55 <dons> a good idea is to set the script to send results locally, till you get all the kinks sorted
23:04:59 <dons> NIGHTLY_MAILTO=dons
23:05:00 <dons> instead of cvs-ghc@
23:05:06 <desrt> good call
23:05:25 <shapr> weel: I'd also recommend you read about Peter Gammie's project - http://gungnir.csbnet.se/~peteg/blog/2004-12-14.html
23:05:37 <dons> desrt: it usually takes 5-6 attempts till all tools and paths and vars are correct
23:05:40 <shapr> doh
23:05:45 <shapr> he's gone.
23:05:54 <dons> what's pete up to?
23:06:03 <dons> he's always up to something
23:06:12 <desrt> what's the anoncvs pw?
23:06:19 <dons> cvs
23:06:28 <dons> or is it "login"??
23:06:31 <desrt> cvs
23:06:35 <dons> anyway, it's on the cvs faq
23:07:00 <dons> read it: http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
23:07:16 <desrt> nod.  i usually check out over ssh is the only diff
23:07:17 <dons> what arch are you going to test?
23:07:28 <desrt> powerpc32/linux and powerpc64/linux
23:07:37 <dons> cool.
23:07:48 <shapr> dons: He's doing a hardware simulation (and description?) dataflow language that's based on ideas from Lustre, among other influences.
23:08:04 <bourbaki> moin
23:08:17 <dons> shapr: sounds like he's under the influence of Koen
23:08:31 <dons> didn't know he'd ever done hardware stuff before
23:11:13 <shapr> heh, I'm sure he is.
23:13:17 <desrt> dons; so i make myself a new site?
23:13:40 <dons> yeah, that's a good idea
23:13:53 <desrt> what are all these conf- and exec- files?
23:14:08 <desrt> i take it i say like conf-HEAD-gabriel
23:14:14 <dons> for a build, you have 1 conf-* and one head-* file
23:14:26 <desrt> one exec- you mean
23:14:33 <dons> sorry, yep
23:14:43 <dons> the exec- contains global path vars and the like
23:14:50 <dons> the conf- contains ghc build settings
23:15:14 <dons> you need to set up your own conf- and exec- file
23:16:02 <dons> most of the available conf- vars are set in defaults/conf-DEFAULTS
23:16:17 <desrt> NIGHTLY_MAILTO=dons@cse.unsw.edu.au
23:16:19 <desrt> hmm :)
23:16:26 <dons> hey! ah, nightly/README is useful
23:17:04 <desrt> oh i get it
23:17:09 <desrt> exec is the script that actually gets run
23:17:26 <dons> yep. you call that from your crontab
23:17:54 * desrt isn't totally sure his box can send mail...
23:18:00 <dons> which in turn calls bin/nightly-main -> nightly-wrk -> new-build-stage1 ...
23:18:21 <dons> you could set up an ssh tunnel in the background to a machine that can
23:18:24 <dons> that's what I do
23:18:39 <desrt> does it try to invoke sendmail or does it use port 25?
23:19:27 <dons> it tries to use sendmail, so you have to edit bin/send-mail-msg
23:19:38 <dons> e.g. *openbsd*)   ssh pill00-s "/usr/sbin/sendmail $2" < $4 ;;
23:20:02 <dons> if you want to follow my idea. or you could just set  up mail locally
23:20:26 <desrt> i think i'll have it cat to a file for now
23:20:41 <dons> it's a good idea to set export  new_bootstrap=YES
23:20:44 <dons> in exec-
23:20:50 <dons> then you get the _fast_ nightly build
23:20:56 <desrt> what does it do?
23:20:57 <dons> instead of the old slow way
23:21:19 <dons> it just builds ghc the intuitive way, instead of an old tree-copying way
23:21:46 <desrt> it's not in your ia64 box's file :)
23:21:50 <dons> it uses the script in new-build-stage1 instead of build-compiler
23:21:57 <dons> oh, I haven't updated that for a long while
23:22:20 <desrt> ok.  so i run the script and it's quiet
23:22:26 <desrt> which means that it's working
23:22:48 <dons> it's creating logs files in your top dir. you could tail -f them
23:22:53 <desrt> where does it checkout to?
23:23:01 <dons> whereever you set it to...
23:23:06 <desrt> hm
23:23:17 <dons> TOP_DIR=/home/dons/head-gcc3
23:23:22 <dons> NIGHTLY_DIR=/home/dons/head-gcc3/nightly
23:23:31 <dons> TOP_DIR is where your fptools should be
23:23:56 <desrt> will it check everything out again except for nightly/ ?
23:24:18 <dons> if you have checkout_source=YES, it will try to check it out
23:24:23 <dons> if you have checkout_source=NO
23:24:23 <dons> update_source=YES
23:24:28 <dons> then you get a cvs up
23:24:34 <desrt> i prefer checkout
23:24:36 <desrt> cvs up misses stuff
23:24:57 <dons> you can control what gets checked out with: do_haddock="YES" omit_testsuite_tools=NO
23:25:01 <dons>  etc.
23:25:30 <desrt> oh
23:25:37 <desrt> so really all i needed to personally checkout was nightly
23:25:39 <desrt> it does the rest
23:26:06 <dons> yep. make sure you put nightly/ somewhere that won't get overwritten though
23:26:19 <desrt> like not inside the topdir
23:27:19 <desrt> ok
23:27:22 <desrt> it's going
23:27:34 <desrt> bed time for me :D
23:27:37 <desrt> thanks a bunch
23:35:43 <dons> that's fine :)
