01:34:45 <autrijus> yay, I've successfully finished the tree binary parsing/filter/dumping framework
01:35:12 <autrijus> for a 60mb file, the time is
01:35:12 <autrijus> 0.796u 0.213s 0:01.11 90.0%     563+532k 0+0io 0pf+0w
01:35:20 <autrijus> it was taking half an hour and 160mb of memory using perl.
01:35:30 * autrijus is firmly sold to haskell now
01:40:05 <Itkovian> good!
01:54:32 <Heffalump> autrijus: nice. How did you solve the last problem we were discussing?
02:05:33 <autrijus> which last problem?
02:05:42 <autrijus> oh and I did without generics
02:07:21 <autrijus> and wrote unfolder for records
02:07:22 <autrijus> _unfoldRec args =
02:07:22 <autrijus>     lamE [ conP (last args)
02:07:22 <autrijus>         [ varP $ "a" ++ (show n) | n <- [1..terms]] ] $
02:07:22 <autrijus>         foldl1 tup [ (varE $ "a" ++ (show n)) | n <- [1..terms] ]
02:07:25 <autrijus> that's the gist of it.
02:07:42 <autrijus> and the folding constructor is
02:07:43 <autrijus> _constrRec args = constr exp where
02:07:43 <autrijus>     constr  = \(Just r) -> appE r $ conE $ last args
02:07:43 <autrijus>     exp     = foldl1 (dot) $ replicate terms uncur
02:07:46 <autrijus>     uncur   = (Just [|uncurry|])
02:07:47 <autrijus> etc
02:08:48 <autrijus> TH is really much easier to grok than scheme macros.
02:10:58 <Heffalump> ah, so you did go with TH, fair enough.
02:11:05 <Heffalump> I was thinking of the uncurry.uncurry.uncurry thing
02:11:06 <autrijus> TH makes most sense.
02:11:24 <autrijus> because I can get
02:11:25 <autrijus>     args    = words . show $ typeOf x
02:11:40 <autrijus> and use it to basically count the terms required by 
02:11:41 <autrijus>     arrows  = filter (\r -> r == "->") args
02:11:47 <autrijus> sick but very fast.
02:12:37 <Heffalump> cool
02:12:41 * Heffalump is off
03:38:20 <autrijus> hey
03:38:26 <autrijus> anyone got a working example of instanceD?
03:39:55 <autrijus> for eg. "instance ClassName TypeName" I understand the [ExpQ] part is the "where" part, and "TypeQ" is probably (varT "TypeName")
03:40:03 <autrijus> but I can't seem to work out the CxtQ part
03:42:10 * autrijus silently hopes there's a -ddump-template-haskell
03:43:37 <musasabi> autrijus: if you get it working please tell me how it is done too ;)
03:43:48 <autrijus> okay.
03:43:58 * autrijus tries
03:46:38 <musasabi> Created a small irc "client" as fltk example. <100 lines ^_^
03:46:58 <autrijus> woot.
03:54:34 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/hs-fltk/example/hirc_fltk.hs
03:55:22 <musasabi> Now to do the same thing but properly and with curses.
04:04:08 <Itkovian> let me take a look
04:31:10 <autrijus> I've reduced it to this form
04:31:14 <autrijus> $( _BinaryInstance PGD [t|PGD|] )
04:32:53 <autrijus> _BinaryInstance con typ sequence = [ instanceD (cxt [])
04:32:53 <autrijus>     (conT "OpenAFP.Generics.Rec" `appT` typ)
04:32:53 <autrijus>     [ funD "recFuncs" [ clause [] (normalB $ _BinaryInstance con) [] ] ] ]
04:32:57 <autrijus> it works just fine
04:33:03 <autrijus> but I'd like to pass only con or only typ
04:33:11 <autrijus> and use one to deduce the other
04:33:15 <autrijus> that seems to be nontrivial.
04:33:26 <autrijus> probably needs to use mkTyCon
04:34:04 <autrijus> oops, type.
04:34:05 <autrijus> _RecInstance con typ = sequence [ instanceD (cxt [])
04:34:05 <autrijus>     (conT "OpenAFP.Generics.Rec" `appT` typ)
04:34:05 <autrijus>     [ funD "recFuncs" [ clause [] (normalB $ _BinaryInstance con) [] ] ] ]
04:34:10 <autrijus> this is the correct form.
04:39:11 <autrijus> working it out
04:41:53 <autrijus> it works!
04:43:23 <autrijus> _RecInstance con = sequence [ instanceD (cxt [])
04:43:23 <autrijus>     (conT "OpenAFP.Generics.Rec" `appT` typ)
04:43:23 <autrijus>     [ funD "recFuncs" [ clause [] (normalB $ _BinaryInstance con) [] ] ] ]
04:43:23 <autrijus>     where typ = returnQ . ConT . last . words . show . typeOf $ con
04:43:36 <autrijus> so "con" suffices to deduce the type
04:43:42 <autrijus> as long I name them consistently
04:44:56 * autrijus happily takes "-cpp" off the OPTIONS line
04:54:21 <autrijus> TH is really High Technology :)
04:55:48 <Lemmih> autrijus: Are you using GHC from CVS?
04:55:58 <autrijus> no, 6.2.2.
04:56:17 <autrijus> or rather 6.2.1 on AIX
04:56:19 <autrijus> I don't forsee easy compilation of GHC on AIX
04:56:33 <autrijus> so I took the version that has binary available
05:02:55 <musasabi> autrijus: just be aware that CVS TH is very different.
05:03:14 <autrijus> ok.
05:03:21 <autrijus> I'm prepared to relearn things. :)
05:03:44 <Lemmih> It's not that different.
05:04:02 <Lunar^> musasabi: GHC 6.4 should be called GHC 7.0 IMHO
05:07:35 <Igloo> Lemmih: Can't think of a good reason why not. Added to my list.
05:08:21 <autrijus> hmm programmatica looks sexy
05:09:57 <Igloo> If you want to see how TH datastructures are made up, do something like    do x <- runQ [d| foo = bar |]; print x   in ghci
05:10:13 <autrijus> ahhhh.
05:10:14 <autrijus> danke
05:11:10 <musasabi> Lunar^: true.
05:11:36 <musasabi> btw anyone know about Software Transactional Memory in GHC?
05:12:14 <musasabi> It is being noted as a large feature but no papers exist about it (in the haskell context)
05:16:10 <musasabi> found http://research.microsoft.com/~simonpj/papers/stm/index.htm ^_^
05:24:52 * shapr reads about STM
05:27:44 <Lemmih> Good morning, shapr.
05:27:49 <shapr> musasabi: readPaper orElse
05:28:02 <shapr> Lemmih: greetings
05:28:14 <shapr> still haven't fixed the wiki logins, but I'll get to it today.
05:28:33 <Lemmih> There's no rush.
05:29:11 <shapr> Depends on whether they're all broken or not.
05:30:41 <shapr> oh, STM fits into my thoughts on declarative concurrency in general. In short, threads suck.
05:32:09 <musasabi> shapr: I am in 3.4 and it looks quite nice.
05:32:10 <Si\> has anyone looked at SYB3 yet?
05:32:45 <shapr> I'm in 2.1 and the advertising claims are inspirational.
05:32:50 <shapr> Si\: what's that?
05:32:57 * shapr has forgotten what that stands for
05:33:06 <Si\> Scrap Your Boilerplate 3
05:33:06 <shapr> Sew Your Base 3?
05:33:07 <shapr> oh
05:33:14 <Si\> ;p
05:33:18 * shapr grins
05:33:47 <Si\> no, it's successor to Scrap More Boilerplate
05:34:26 <Si\> adds extensible modularity with the help of faking context parameterization
05:34:50 <Si\> as in Hughes paper on Restricted Types
05:35:02 <shapr> Er like what? Can I add add new constructors to a datatype in a separate module or something?
05:35:29 * shapr can't remember Restricted Types at the moment.
05:35:50 <shapr> I should really put up some book reviews, I've read too many books lately.
05:36:04 <Si\> well you can't do func :: ctx a => a -> b in Haskell, so you fake it with type-class Dictonaries
05:36:44 <shapr> a context typeclass?
05:37:01 <shapr> oh, we've discussed this before... I can almost remember the details.
05:37:16 <Si\> yes
05:37:26 <Si\> it's been around since '99
05:37:56 <Si\> http://www.cs.chalmers.se/~rjmh/Papers/restricted-datatypes.ps
05:38:07 <Si\> I'd just never read it until I saw SYB3
05:38:33 <Si\> the problem with SYB has always been you see that any modularity is always closed over your original function
05:38:36 <adept> re
05:39:39 <shapr> hiya adept 
05:40:01 <Si\> the only way to do extensible modularity is with type-classes, but you can't parameterize over them and Data was only parameterized over a single type
05:40:46 <Si\> well in the new version it is parameterized over two; a type-code system has been added to allow type-class access
05:40:50 <adept> shapr: hi there!
05:41:50 <musasabi> the select like stuff looks *very* nice.
05:41:55 * shapr agrees
05:42:18 <shapr> Si\: sounds interesting, I'll add that to my list
05:42:23 <shapr> greetz edwinb 
05:42:32 <Si\> how long is your list ;)
05:42:37 <edwinb> good $time_of_day all
05:42:59 <shapr> Very long, but I tend to read the most recent entry first.
05:43:48 <Si\> the downside is the optimum way to do it is with overlapping instances, since they allow for base case/specific models to be built easily
05:44:56 <Si\> and overlapping instances annoyingly do not support context based specificization
05:45:31 <Si\> which means you can't guarantee a base case of forall a
07:37:16 * CosmicRay stumbles into the channel
07:37:30 <CosmicRay> this is why I've been scarce lately: http://changelog.complete.org/articles/2005/01/06/no-power-lots-of-ice/
07:37:37 <CosmicRay> btw megamonad won't be back until our power is back
07:46:15 <musasabi> CosmicRay: that sounds very nasty.
07:47:35 * musasabi is glad we don't have much problems with electricity here.
07:52:32 <CosmicRay> musasabi: yeah, it stinks.
07:52:53 <CosmicRay> we've been at my parents place for the past 12 hours, but I've had to go back to our house twice to adjust portable heaters
07:56:12 <Itkovian> whoops.
07:56:22 <Itkovian> hang in there Cosmic. Spring is on its way ...
07:56:40 <CosmicRay> hopefully :-)
07:56:43 <CosmicRay> and thanks
07:57:19 <CosmicRay> it's supposed to be 50F on Saturday, but won't even get above freezing until tomorrow, so we've got at least another 24 hours
07:58:00 <CosmicRay> close to 100,000 people without power.
08:12:29 * musasabi goes to shut the windows.. 
08:22:07 * Igloo reads "it doesn't really make sense for --prefix not to be a prefix of --copy-prefix, as the value of --prefix [...]" and gets dizzy
08:26:17 * esap just solved all problems with implementing control operation using unsafeCoerce# :-)
08:49:35 <xti> hello
08:55:30 <shapr> xti: hi, are you learning Haskell?
08:55:55 <xti> shapr: I'm about to start learning it
08:56:16 <shapr> Are you learning for business or pleasure?
08:56:25 <xti> pleasure
08:56:46 <xti> what do you mean by business? :)
08:57:06 <shapr> Well, I make money with Haskell, and some people learn Haskell because their teachers say so.
08:57:25 <shapr> So I guess I'm asking whether you're learning Haskell on your own initiative.
08:57:32 <xti> yes
08:57:49 <shapr> Excellent, that's my preferred way to learn anything :-)
08:58:01 <shapr> Do you have prior experience with functional programming?
08:58:05 <Igloo> My favourite way is "both"
08:58:07 <xti> now that makes two of us :)
08:58:19 <shapr> Do you want the short tour of the #haskell channel and useful resources?
08:58:37 <shapr> Igloo: true, but my clients have rarely heard of FP.
08:58:49 <xti> shapr: I used Lisp before and Gofer a bit
08:58:59 <xti> shapr: yes, please
08:59:05 <shapr> ok then!
08:59:15 <xti> shapr: out of curiousity what do you do?
08:59:27 <shapr> Local scenic views include lambdabot, the Haskell wiki, and the learning page on haskell.org
08:59:39 <xti> what kinds of programs do you make in Haskell for a living?
08:59:49 <shapr> lambdabot can find functions in the standard libraries by name, and he can give type signatures too.
08:59:51 <shapr> @index anyChar
08:59:52 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
09:00:05 <shapr> @type Text.ParserCombinators.Parsec.anyChar
09:00:07 <lambdabot> Text.ParserCombinators.Parsec.anyChar :: forall st.
09:00:07 <lambdabot> 					 Text.ParserCombinators.Parsec.Char.CharParser st Char
09:00:18 <shapr> The Haskell wiki has lots of goodies...
09:00:21 <shapr> @wiki FundamentalConcepts
09:00:22 <lambdabot> http://www.haskell.org/hawiki/FundamentalConcepts
09:00:38 <shapr> The learning page is mentioned in the channel topic, along with the url to the channel logs.
09:00:53 <shapr> I'm a self-employed programmer. My fiancee and I have a company together.
09:01:44 <shapr> Since you've used Gofe and Lisp, I doubt you require the introduction to higher order functions, partial application, type inferencing and the like.
09:01:45 * dottedmag .oO(lucky one)
09:02:26 <shapr> dottedmag: It's hard work... We have either not enough time or not enough money. And our clients sometimes pay long after they originally said they would.
09:02:27 <shapr> too
09:02:29 <xti> shapr: yes, I know them
09:02:52 <shapr> I admit, it's better than working for some death march company.
09:03:08 <shapr> I get to say no to sufficiently stupid requests :-)
09:03:21 <shapr> xti: what do you do for a living?
09:03:58 <xti> I'm some kind of an architect
09:05:17 <shapr> xti: nearly all my paying work is websites, specifically Zope (written in Python). I once got paid for three days of XML work with Haskell.  Recently a client wanted a decent webapp for searching mailing list archives, and I already wrote one in Haskell, so I'm just improving it.
09:05:49 <xti> so you use Haskell for virtually anything. that's nice
09:05:54 <shapr> The UI is minimalistic, but so is the code - http://thunderbird.scannedinavian.com/cgi-bin/SearchML
09:06:19 <shapr> I haven't yet used Haskell to write device drivers, but it might actually be good for that.
09:06:53 <xti> does it have a FFI?
09:06:57 <shapr> xti: What sort of architect? Christopher Alexander type of architect?
09:07:04 <shapr> yes, Haskell's FFI is excellent.
09:07:13 <xti> I've also read about darcs and I though if one can write a nice versioning system with Haskell, that should be a great language
09:07:18 <shapr> And there are many tools to automate using the FFI
09:07:46 <shapr> Lemmih is writing an app to read C++ header files and automagically generate the binding.
09:07:59 <shapr> There are already apps that do that for C
09:08:04 <shapr> hej ski
09:08:31 <edwinb> Am I the only one who's ever wanted to call haskell from C then?
09:08:40 <ski> hej shapr !
09:08:53 <shapr> edwinb: nah, I've seen code to do that too
09:09:10 <edwinb> Oh, it's quite easily done... there's just not the tool support.
09:09:26 <edwinb> It was only because my machine didn't have enough memory to compile wxHaskell anyway...
09:09:34 <shapr> How would that work from the other direction?
09:09:50 <shapr> What sort of tool support do you miss?
09:09:59 <xti> shapr: I "build" houses that contain room for 4-6 families. I don't know what's the equivalent in english, it's called "mate houses" in hungary
09:10:03 <edwinb> I don't know, it doesn't exist ;).
09:10:33 <shapr> Oh, I know what you mean, but I don't remember the generic english word.
09:10:42 <shapr> duplex is two houses
09:11:03 <shapr> There's some word that means many several 'houses' in the same building.
09:11:58 <shapr> I've never met someone who can act as both architect and programmer, have you read Christopher Alexander's work on Design Patterns?
09:12:05 <desrt> townhouse? condo?
09:12:50 <xti> shapr: I'm not a programmer
09:12:58 <shapr> Oh, ok.
09:13:06 <xti> desrt: condo, yes
09:13:07 <shapr> But, you know Lisp and Gofer?
09:13:54 <xti> shapr: I can write programs in Lisp. my Gofer knowledge is very basic. it started with Jeroen Foekker's Functional programming book
09:15:51 <shapr> I've never tried to design a house.
09:15:54 <lispy> the people here live donuts, i guess that's good to know :)
09:16:45 <lispy> s/live/like/
09:17:11 * musasabi eats some rice with rice and plots what to use for testing STM
09:19:07 <lispy> i've been asked by my prof to help determine if we should recommend GHC or Huggs to the student just learning haskell.  I'm starting to develop an opinion, but i was wondering if anyone here would like to comment
09:20:04 <edwinb> We use WinHugs because it has pretty pictures...
09:20:10 <lispy> seems like most beginners are told to use haskell
09:20:17 <lispy> er...
09:20:21 <lispy> i meant huggs
09:20:27 <lispy> edwinb: cool
09:20:35 <shapr> Hugs is an interpreter written in C, GHC is a compiler written in Haskell.
09:20:36 <lispy> i guess it has one g
09:20:43 <shapr> Hugs is easy to build and run, but it doesn't do as much.
09:21:06 <edwinb> It causes problems because the lecturer leaves all the local libraries on the unix system. Oops.
09:21:13 <shapr> GHC does lots, and can be happily used for real commercial apps, but it can be a pain to build (since you need to have GHC to build GHC)
09:21:31 <lispy> shapr: what sort of things?  both seem to have enough features for an intro
09:21:47 <musasabi> If you have weird platforms - hugs - if your department has a quite standardised system then ghc.
09:22:01 <ski> hugs is a little faster with loading modules, it seems to me
09:22:08 <musasabi> ghc is better for most things but 1) harder to install 2) more resource hungry.
09:22:12 <shapr> In my opinion, GHC error messages are usually better.
09:22:16 <lispy> well, we want students to be able to use windows or solaris 8
09:23:02 <lispy> i should play around with errors then
09:23:15 <lispy> see which one is more helpful
09:23:32 <shapr> Helium promises to be the best Haskell learning tool, I don't know if it's ready for real use or not.
09:23:44 <ski> (you're not considering helium, then ? ..)
09:23:52 * ski grins
09:23:59 <shapr> Yay, BC Pierce is learning Haskell.
09:24:05 <lispy> no type classes may be a problem
09:24:10 * shapr does the frantastically happy dance.
09:24:43 <xti> shapr: you had a Sinclair? nice :)
09:24:49 <shapr> er yes
09:24:59 <shapr> Looking at the logs? or something I wrote?
09:25:13 <shapr> greetz Agent Goerzen
09:25:22 <TheHunter> lispy, definitely ghci
09:25:47 * edwin2 wonders how long before edwinb will ping out...
09:25:54 <shapr> edwin2: you could ghost it
09:25:57 <TheHunter> better error messages + let f x = x + x for quicker testing are the most important reasons.
09:26:14 <shapr> edwin2: try /msg nickserv help ghost
09:26:18 <xti> shapr: one of your web pages
09:26:19 * edwin2 wonders whether to ask what that means, or pretend to know...
09:26:22 <edwin2> ah, cheers.
09:26:24 <shapr> y0 stepcut, how waz ya holidays?
09:26:34 <lispy> TheHunter: thanks
09:26:52 <TheHunter> well, that's my opinion.
09:27:13 <lispy> TheHunter: well, that's what i'm looking for ;)
09:27:15 <TheHunter> advantages of hugs are faster startup and compile time and a shorter download...
09:27:40 <stepcut> shapr: good! I wrote a hack for the haskelldb optimizer for eliminating subqueries
09:27:45 <shapr> awesome!
09:28:02 <shapr> Oh, you probably know how big a task backend-specific SQL would be... what do you think?
09:28:03 <stepcut> I am preparing an email to the haskelldb list about it as time permits
09:28:36 <stepcut> It would depend on how different you wanted it
09:28:51 <shapr> And, what do you think is the best approach? HaskellDB 'Core' SQL and then transform to backend specific? or generate it directly?
09:28:58 <stepcut> in the current code, you would basically just write different optimizers 
09:29:09 * TheHunter thinks there should be a command in ghci which just invokes the typechecker and keeps the old environment.
09:29:26 <shapr> I do think a standard semantic and matching unit tests would be required for that.
09:29:39 <shapr> TheHunter: huh?
09:30:44 <TheHunter> shapr, a command like :tc that typechecks the code and doesn't compile it.
09:31:04 <shapr> oh
09:31:20 <TheHunter> two advantages: it's faster if you're just checking and not testing
09:31:30 <_Codex> its sometimes a pain with ghci that you :r things and you need to :m +FooModule to use anything in it.
09:31:30 <shapr> wouldn't it be easier to just push the current env?
09:31:53 <TheHunter> two: if you make a type error yuo can still use the functions from your code.
09:32:19 <TheHunter> shapr, is that possible now?
09:32:31 <shapr> I don't think so, but it doesn't sound hard...
09:32:35 <xti> have to go now. thanks for the pointers shapr 
09:32:43 <stepcut> shapr: internally, there are two data structures that haskelldb uses, one is the data structure that holds the 'relational algebra' tree, the toSql function maps that tree into a similar one based around the SqlSelect data-type, which is designed to be straight-forward to turn into a SQL queries. Currently, the easiest way to affect the actual SQL generated is to transform the SqlSelect datastructure (which is what the function
09:32:44 <stepcut> s in Optimize.hs are doing)
09:32:56 <shapr> xti: sure, feel free to ask more questions whenever.
09:33:12 <xti> I'm sure I'll have further questions :)
09:33:21 <shapr> excellent :-)
09:34:31 <shapr> stepcut: oh, neat. So, the optimizers just transform SqlSelect datastructures through known-good transforms to get more efficient code?
09:34:43 <TheHunter> i guess it'll be easy to implement your own ghci when we have -package ghc, anyway.
09:36:02 <shapr> It seems to me that there are already a bunch of known-good transforms for certains sets of semantics, I wonder when we'll get a generic optimizer that can take a semantics description and return both slowest brute-force and faster probably efficient optimizations.
09:36:38 <shapr> Are there already semantics complexity descriptions like algorithmic complexity?
09:37:28 <shapr> Can you calculate how hard it will be to optimize a 'system' and compare it to other comparable systems?
09:40:50 * shapr completely killed the conversation
09:41:03 <shapr> edwinb: how's Epigram?
09:41:21 <wli> I'm having trouble with arrays =(
09:41:45 <shapr> parallel arrays?
09:41:59 <wli> no
09:42:01 <wli> just ordinary ones
09:42:03 <edwinb> shapr: Ask me again on Wednesday...
09:42:11 <edwinb> Not much has happened recently, we've all been busy with other stuff.
09:42:11 <shapr> edwinb: ah, still on vacation?
09:42:32 <edwinb> We're getting lots of people together on Tuesday to make each other do stuff.
09:42:39 <shapr> heh, good idea.
09:42:44 <shapr> A sprint :-)
09:43:05 <edwinb> Yes, it's unusual that we're all in the same place, which is a shame.
09:43:44 <musasabi> wli: hmm?
09:45:02 <wli> I don't seem to be able to figure out how to initialize an array, extract a component, and then use it in non-ST-monad code.
09:46:00 <musasabi> well you need to freeze it if you want to use it in non-monadic code.
09:47:48 <musasabi> newArray (1,10) 'a'
09:47:54 <musasabi> newArray_ (1,10)
09:48:06 <wli> I'm trying this:
09:48:16 <musasabi> newListArray (1,10) ['a','b','c']
09:48:17 <wli> runST (do { a <- newArray ((1,1),(10,10)) 0 ; x <- readArray a (5,5) ; return x })
09:48:31 * shapr compares GHC to a hotrod compiler...
09:50:03 <shapr> y0 Maddas, wazzup?
09:51:17 <shapr> musasabi: is STM in ghc 6.2?
09:51:26 <Maddas> yow!
09:51:39 <Maddas> shapr: Not much, me and my hawgs hammin' around, chillin' the cold pen.
09:52:05 <lispy> M-x yow?
09:52:06 * shapr googles for an ebonics -> english translator
09:52:09 <shapr> @yow !
09:52:09 <lambdabot> Am I elected yet?
09:52:27 <shapr> @yow !
09:52:28 <lambdabot> Now I'm having INSIPID THOUGHTS about the beautiful, round
09:52:28 <lambdabot>  wives of HOLLYWOOD MOVIE MOGULS encased in PLEXIGLASS CARS
09:52:28 <lambdabot>  and being approached by SMALL BOYS selling FRUIT..
09:52:36 <Maddas> :-)
09:52:39 <lispy> Yow!!  It's LIBERACE and TUESDAY WELD!!  High on a HILL... driving a
09:52:39 <lispy>  LITTLE CAR...  I wanna be in that LITTLE CAR, too!!  I wanna drive off
09:52:39 <lispy>  with LIBBY and TUESDAY!
09:52:44 <musasabi> shapr: no.
09:52:48 <shapr> poo
09:53:13 <musasabi> wli: I would try adding type annotations till the error would be clear.
09:53:24 <musasabi> shapr: the cvs has a working version.
09:53:40 <Maddas> Oh, wait, it is "cold chillin' the pen", not "chillin' the cold pen". Man, I suck. :-)
09:55:12 <musasabi> (at at text terminal so no easy cut-and-paste examples)
10:00:45 <lispy> how was it that you turn on better error messages in ghci?
10:01:18 <shapr> -Wall ?
10:01:18 <lispy> or do they default to on?
10:01:58 <stepcut> shapr: (regard the sql optimizers) yep, that is all there is too it. I think most or maybe all queries that can be expressed in haskelldb right now can be transformed into an expression without subqueries
10:02:09 <lispy> hmmm....not sure if that did anything Z)
10:02:24 <shapr> stepcut: btw, your previous line got cut off
10:02:45 <stepcut> suck!
10:03:05 <stepcut> mst kep it shrt
10:03:43 <shapr> Currently, the easiest way to affect the actual SQL generated is to transform the SqlSelect datastructure (which is what the function
10:03:48 <shapr> What's the rest of the line?
10:03:54 <stepcut> s in Optimize.hs are doing)
10:04:21 <shapr> ah
10:09:34 <wli> some monad thing is going horribly wrong
10:18:54 <shapr> musasabi: hey, have you seen http://lambda-the-ultimate.org/node/view/464 ?
10:20:53 * shapr wishes there were a single app that handled both pdf and ps well
10:21:17 <shapr> Actually, I wish there were a completely open source document format that's not ms.doc, or Adobe postscript or Adobe PDF
10:21:59 <stepcut> dvi?
10:22:25 * shapr reads up on dvi
10:22:35 <stepcut> kghostview does an ok job at ps/pdf
10:22:54 <lispy> i don't know much haskell so bear with me, if I type data BTree a = EmptyBTree | Node a (BTree a) (BTree a) when using ghci interactively, i get parse error on `data', but it seem to work if i put that in a file
10:23:11 <wli> Data.Array.ST doesn't like actually using ST to all appearances
10:23:17 <shapr> lispy: right, GHCi is an incremental compiler.
10:24:01 <shapr> lispy: you can get a lot closer to a real repl with hs-plugins, but there's no fully interactive tool that I know of.
10:25:25 <lispy> shapr: okay, so how can i tell if a ghci can accept "something" interacitvely?
10:26:26 <lispy> eg. definitions are not allowed, but things that can be evaluated are?
10:26:36 <shapr> In general, you can call a function, or use let to define a value
10:26:53 <shapr> On the good side, functions are values too, so you can do let incr x = x + 1
10:27:25 <lispy> hmm...oskay
10:28:25 <shapr> I use emacs haskell-mode, then I can stick stuff into my file and do C-c C-l to dump it all into ghci in another buffer.
10:28:38 <shapr> that gives me the best of both worlds
10:29:01 <lispy> ah, okay, I need to get emacs setup on this machine.
10:29:18 <lispy> that would be a good reason to do it :)
10:30:21 <lispy> that and i can barely type on this keyboard
10:36:51 <shapr> Hi tom
10:37:31 <shapr> tomfool05: learning Haskell?
10:37:59 <tomfool05> yeah i was looking for some good online introductions
10:39:10 <wli> Okay, try this:
10:39:11 <wli> :type (runST (((newArray (1::Int,10::Int) (0::Double) :: ST () (STUArray () Int Double)) >>= (flip readArray (5::Int))) :: ST () Double)) :: Double
10:40:08 <shapr> tomfool05: there's the learning page url in the topic, that has a bunch of links. I recommend the "Yet Another Haskell Tutorial" if you're new to functional programming.
10:40:16 <shapr> Do you have any specific questions?
10:41:07 <tomfool05> well i have been looking through that and was looking for something that offered some problems to solve using haskell
10:43:22 <shapr> What do you mean?
10:44:00 <shapr> Maybe something like "Two Dozen Short Lessons in Haskell" ?
10:45:06 <lispy> tomfool05: you could impement some well known functions form math classes as practice
10:46:43 <lispy> for example, the binomial theorem
10:47:13 <tomfool05> yeah like the two dozen short lessons but with more IO types of problems
10:47:17 <lispy> write your own factorial, "n choose k" and so on
10:48:51 <tomfool05> yeah i have been looking into doing that sort of thing making my own versions of included functions
10:49:18 <tomfool05> but i can't seem to find much on basic interactive programs
10:49:29 <shapr> If you want IO stuff, have you read the nomaware monad tutorial?
10:49:45 <tomfool05> no i haven't
10:51:02 <musasabi> shapr: thanks for the link.
10:51:45 <musasabi> emacs makes ghci much nicer.
10:51:48 <autrijus> yay. the memory usage is down another 60% after judicious use of unsafePerformIO (one place) and unsafeInterleaveIO (two places)
10:52:04 * autrijus loves backdoors.
10:52:25 <shapr> tomfool05: www.nomaware.com/monads/html/
10:52:43 <lispy> what is the multiline comment sequence?  (like in C it is /* */)
10:52:53 <shapr> {- -}
10:52:58 <lispy> thanks
10:53:44 <tomfool05> thanks
10:54:56 <shapr> I'm impatiently waiting for GHC 6.4.
10:55:07 <shapr> So much good stuff requires 6.3 :-/
10:55:23 <autrijus> is there a tentative changelog somewhere?
10:55:30 <autrijus> s/changelog/relnotes/
10:55:40 <wolfman8k> is it possible to have a strict/lazy language with dynamic types?
10:55:54 <shapr> sure
10:56:05 <shapr> Every language is somewhat strict and somewhat lazy.
10:56:08 <autrijus> wolfman8k: Data.Dynamic works for me
10:56:18 <autrijus> uh oh.
10:56:18 <autrijus> ./OpenAFP/Macro.hs:22:
10:56:19 <autrijus>     Template Haskell bracket illegal in a stage-1 compiler
10:56:23 <autrijus>       [| uncurry |]
10:56:28 <autrijus> what does this mean?
10:56:43 <shapr> it sounds like you're using the first stage of a GHC build 
10:56:46 <shapr> rather than the second stage
10:56:57 <autrijus> so I need to recompile GHC on AIX
10:56:58 <autrijus> joy
10:57:05 <shapr> GHC builds itself twice when compiling a 'real' version.
10:57:22 <autrijus> apparently the AIX binary tarball is only stage1
10:57:36 <shapr> Yeah, CosmicRay recently ported GHC to AIX.
10:57:45 <autrijus> comsmicray++
10:57:45 <shapr> And it sounded like an epic tale.
10:58:04 <autrijus> that was why I'm suddenly getting paid for using haskell for production :)
10:58:16 <autrijus> instead of merely playing with the darcs alrogithm as I originally hoped.
10:58:31 <shapr> wow, spiffy!
10:58:34 <wolfman8k> did he also get paid for megamonad?
10:58:41 * shapr snickers
10:58:53 <musasabi> autrijus: http://www.haskell.org/hawiki/GHC_206_2e4 (changes for GHC 6.4)
10:58:58 <autrijus> musasabi: danke
11:00:09 <autrijus> oh, it will come with cabal. nice
11:00:38 <shapr> Yes, SyntaxNinja++
11:01:15 <autrijus> it's wonderful that haskell has gained Module::Install / MakeMaker style functionality :)
11:01:40 <Igloo> No, you'll need to get ghci working on AIX
11:01:42 <autrijus> has most of the haskell people adopted darcs as shared repo?
11:01:48 <Igloo> Recompiling it won't help
11:02:05 <autrijus> I gather that ghci hadn't been ported to aix
11:02:09 <autrijus> is it the case?
11:03:39 <Igloo> AFAIK, that is the case
11:04:20 <autrijus> reading "Secrets of building GHC for AIX 5.1L" now
11:04:41 <autrijus> he does not seem to document as of why GhcWithInterpreter = NO was chosen
11:06:26 <wli> no progress on figuring out why ST () Double can't be run
11:06:42 <Igloo> wli: Did you try without using $?
11:06:54 <Igloo> Oh, wait, ST ()? Where did that come from?
11:07:12 <Igloo> It should be ST s, surely?
11:07:23 <ski> wli : you can't run it if the first tyarg of ST is instantiated (in this case to ())
11:07:38 <wli> runST ((newArray (1::Int,10::Int) (0::Double) :: (forall t . ST t (STUArray t Int Double))) >>= (flip readArray (5::Int)))
11:08:43 <Igloo> That works for me
11:08:52 <wli> if I remove type annotations it pukes
11:09:36 <Igloo> That's because it's overloaded
11:09:53 <Igloo> Same as read . show
11:10:33 <wli> it seems I have to nail down the ST monad or it can't be inferred
11:10:35 <musasabi> wli: usually the best way is to make a function create the array and force the type there.
11:10:50 <musasabi> wli: the problem is the array not ST.
11:12:23 <wli> forall can't be used in type signatures...
11:12:54 <wli> or it's barfing on them anyway
11:13:18 <Igloo> You don't need the forall, but it ought to work if you have -fglasgow-exts
11:13:47 <Igloo> Oh, hmm, maybe you do if you have a function to creat it, actually
11:13:57 * Igloo heads homewards
11:14:01 <musasabi> wli: http://youzen.b2.fi/~musasabi/f.hs
11:20:06 <autrijus> ok. trying to hack a stage2 ghc622 binary together now.
11:20:12 <autrijus> bbiab. &
11:23:41 <shapr> y0 CosmicRay 
11:23:45 <TheHunter> newUDArray :: (Ix i) => (i, i) -> Double -> ST s (STUArray s i Double)
11:23:45 <TheHunter> newUDArray = newArray
11:23:45 <TheHunter> foo = runST (newUDArray (1::Int,10) 0 >>= flip readArray 5)
11:25:24 <shapr> hiya CoolPops 
11:26:09 <basti_> STFUArray?
11:26:19 <CoolPops> shapr: howdy.
11:27:04 <shapr>  how's code?
11:29:47 <CoolPops> I am curious of the recommended method of a 15+ year programmer who has not spent any quality time (only frustrating time) with any functional language proceed to learn Haskell. I have been to the learning page on haskell.org but there are many methods. Is there a favorite tutorial or book for someone in my shoes?
11:31:54 <shapr> Have you tried "Yet Another Haskell Tutorial" ? Hudak's hardcopy book might appeal to you also.
11:33:19 <CoolPops> shapr: I'll print YAHT if that's your recomendation. I would just like something that assumes I am not dumb but that I am very ignorant with haskell :-)
11:34:04 <CoolPops> shapr: what is the title of Hudak's book?
11:34:10 <shapr> Well, I think your best bet is to try to write a small but interesting program that uses nearly zero input/output. And while you're doing it, read the various online tutorials and ask questions here.
11:34:40 <CoolPops> How do I write a small but interesting program that uses nearly zero input/output?
11:34:44 * CoolPops lol!
11:34:52 <shapr> "The Haskell School Of Expression" - http://www.haskell.org/soe/
11:35:08 <shapr> I wrote a mandelbrot fractal with text output
11:35:30 <shapr> I had to get help from others to do the printing, but I wrote the rest myself.
11:36:05 <shapr> It took a lot of difficult brain twisting that first time, but it was worth every bit of work.
11:36:18 <CoolPops> shapr: that's what I am hoping.
11:36:43 <shapr> If you want, I can give you my impression of what makes FP unusual.
11:36:56 <CoolPops> shapr: yes.
11:37:42 <shapr> Have you worked with Scheme, Lisp, or other functional language?
11:38:09 <shapr> What languages have you used?
11:38:35 <CoolPops> shapr: I have hacked my way through a few extensions to emacs in elisp, that's all. C/C++, Python, PHP, Java, Ruby, Lua.
11:38:36 <shapr> For example, Python has reduce, map, and lambda. But, I'm not sure where to start...
11:38:46 <shapr> ah, ok.
11:39:19 <musasabi> CoolPops: after you get the basic hang of things the nomaware monad tutorial is quite nice.
11:39:34 <wli> the array-building function is not going so well
11:40:01 <musasabi> wli: hmm?
11:40:14 <shapr> I think functions as values is the biggest part.
11:40:28 <shapr> wow, we have both SamB and SamC on the channel.
11:40:30 <shapr> neat!
11:41:02 <SamC> now we need a SamA
11:41:19 <shapr> CoolPops: if functions are values you can do a lot of cool stuff.
11:41:46 <shapr> this is the anonymous function to add one to a number "\x -> x + 1"
11:41:50 <CoolPops> shapr: what's the difference of functions being values vs. a C function that always returns a value?
11:42:37 <shapr> because you can operate on the function, and you can use the function like a tool itself.
11:42:45 <musasabi> CoolPops: think of it as the distinction between the function as a pointer to function and the value of function when called.
11:43:27 <shapr> "(\x -> x + 1) 1" that adds one to the input, return two
11:44:00 <shapr> but the function "map" lets me apply one function to every item in a list and the 'return value' is the resulting list.
11:44:15 <shapr> map (\x -> x + 1) [1,2,3] evaluates to [2,3,4]
11:44:45 <shapr> from one viewpoint, map eliminates the redundancy of explicit loops.
11:45:03 <shapr> You know you have to loop, everybody does it. So why not simplify it down to its essence?
11:45:32 <CoolPops> shapr: I see.
11:45:54 <shapr> But, functions as values allows a lot more cool stuff.
11:46:05 <CoolPops> shapr: now, when I will really see is how I can take a complex loop that does 100 things and bust it down to a map() statement.
11:46:35 <shapr> Sometimes it's several map statements, and some other basic traversals.
11:47:03 <shapr> For example, fold is the essence of one pattern...
11:47:25 <shapr> If you want to add all the numbers in a list, the pattern is a two argument function that gives back a single result.
11:47:43 <shapr> you fold up the list using the function
11:47:53 <shapr> foldr1 (+) [1,1,1] gives 3
11:48:01 <wli> mkMatrix :: (Num t, Num t', Enum t, Ix t) => t -> t -> ((t,t) -> t') -> (forall t'' . ST t'' (STUArray t'' (t,t) t')) ; mkMatrix m n f = do { a <- newArray ((1,1),(m,n)) 0 ; foldM_ (\a idx -> writeArray a idx (f idx) >> return a) a [(i,j) | i <- [1..m], j <- [1..n]] ; return a }
11:48:49 <musasabi> wli: the language shootout has matrix code (shootout.alioth.debian.org -> ghc -> matrix)
11:49:24 <shapr> CoolPops: that's just standard functional behaviour, but Haskell does even more.
11:49:59 <wli> musasabi: I'm actually trying to use arrays...
11:50:22 <musasabi> wli: it actually uses a one dimensional array behind the scenes ;)
11:50:34 <shapr> partial application is where you fill in one argument to a function and get back the function as if it had been defined that way.
11:50:51 <shapr> It's a bit like setting a value on an object.
11:51:34 <wli> musasabi: it's operationally mportant to have O(1) indexing for my purposes, and it won't reduce into anything similar
11:52:22 <wli> so I can't do the list stuff
11:52:41 <shapr> Since operators are functions like any other, (+ 1) is the same as the earlier definition of a function that explicity adds 1 to a number.
11:52:47 <shapr> CoolPops: is this helping any?
11:52:58 <shapr> map (+ 1) [1,2,3]
11:53:59 <shapr> it's the same as for (int i=0;i++;thingy.length) { thingy[i] = thingy[i] + 1 }
11:54:06 <CoolPops> shapr: it's interesting but I think the real battle is going to be transfering a problem from my head into functional steps instead of python. The YAHT is almost done printing.
11:54:25 <shapr> ok
11:54:43 <CoolPops> currently I can transfer problems in my head into code rather quickly, but in Python, C or PHP. Haskell is going to take a different mindset.
11:55:21 <shapr> I warn you, Python was my favorite language when I started learning Haskell. Now I'm an FP addict =)
11:55:34 <musasabi> wli: sorry remembered wrong. http://shootout.alioth.debian.org/benchmark.php?test=nsieve&lang=ghc&id=0&sort=cpu should do.
11:55:48 <shapr> I really do think that the functional approach allows dramatically more concise and elegant code.
11:56:02 <shapr> I tend to write Python that looks like Haskell.
11:56:33 <goron> I want to have more than 10 levels of priorities. Is that defined that it can not be in the Haskell Standard?
11:56:45 <CoolPops> shapr: I am learning haskell for 2 reasons... to expand my knowledge and ... ``Haskell gives you: substantially increased programmer productivity; shorter, clearer, and more maintainable code; fewer errors; higher reliability; a smaller "semantic gap" between the programmer and the language; shorter lead times.'' - haskell.org
11:57:14 <shapr> Yeah, I totally agree.
11:57:32 <shapr> I wrote a minimalistic mailing list archive search webapp in three evenings of spare time.
11:57:53 <shapr> It was about 200 lines of code.
11:58:17 <shapr> I think 154 lines of code without comments and blank lines.
11:58:19 <andersca> I wrote a programming language in haskell
11:58:23 <andersca> it was a fun experience
11:58:49 <musasabi> I think one of the largest advantages is making effects visible and makes modifying code easy.
11:58:58 <CoolPops> I wrote a hello world app in haskell, does that count?
11:59:04 <shapr> hey that's a start :-)
12:00:00 <shapr> My code always ends up being a special or general case of fold, map, scan, etc. If I spend enough time massaging my code, it gets really really short, and is almost entirely Prelude functions.
12:00:52 <shapr> Haskell doesn't have many moving pieces (especially not compared to Java), but it's by far the deepest language I've seriously explored.
12:01:04 <shapr> (Epigram is possibly deeper, but I have seriously explored it yet)
12:01:10 <shapr> "have not"
12:05:05 <Philippa_> musasabi: visible side-effects are IMO one of the most useful bits - makes it so, so much easier to refactor, to trace...
12:06:59 <musasabi> Philippa_: true :-)
12:07:28 <Philippa_> in short, it makes it very easy to tell when what you're doing has the possibility to break something elsewhere, and when it doesn't
12:12:22 <wli> shapr: What's epigram?
12:12:40 <shapr> It's a research language - http://www.dur.ac.uk/CARG/epigram/
12:12:54 <shapr> It's not really production-quality.
12:12:59 <shapr> Not yet
12:14:29 <shapr> But it lets you express behavioural characteristics in types, which is difficult to do with Haskell.
12:23:43 * Lunar^ is just discovering STM
12:23:53 <Lunar^> That'll rocks for hOp !
12:25:04 <CosmicRay> hi shapr
12:25:15 <zamez> store multiple?
12:25:37 <Lunar^> http://www.research.microsoft.com/%7Esimonpj/papers/stm/index.htm
12:25:58 <CosmicRay> CoolPops: I second the YAHT recommendation.  Also, Haskell: The Craft of Functional PRogramming looks good.
12:26:32 <CosmicRay> shapr: I'd be interesting in your archive search webapp
12:26:38 <CosmicRay> shapr: I have a continual problem with those on my server
12:26:48 <shapr> what format do you use?
12:27:03 <CosmicRay> mbox files, named list-yyyy-mm
12:27:07 <shapr> I only handle mailman mbox inputs so far
12:27:09 <musasabi> Lunar^: yes, it is very very nice :-)
12:27:26 <musasabi> but away for an hour =>
12:27:29 <shapr> I haven't thought up a good way to incrementally input new mail archives.
12:27:40 <CosmicRay> shapr: though what I'd like it to do is link to the mhonarc html files
12:27:46 <shapr> Also, I don't really know what to do with the more pathological emails in the archive.
12:27:52 <shapr> mhonarc?
12:27:56 <CosmicRay> shapr: though what I'd *really* like to do is eliminate mhonarc and generate the html dynamically from the mbox files
12:28:05 <shapr> I can do that, I think.
12:28:12 <CosmicRay> shapr: renders mbox files as html
12:28:23 <shapr> but you have to point me to a pretty mhonarc html view first
12:28:36 <CosmicRay> lists.complete.org 
12:28:50 <CosmicRay> that's mhonarc + wrappers to make it useful for more stuff
12:28:59 <CosmicRay> freeciv general discussion is a good example
12:29:10 <CosmicRay> by "useful for more stuff", I mean things like splitting out by dates
12:29:28 <CosmicRay> shapr: anyway, here's what I've been up to: http://changelog.complete.org/articles/2005/01/06/no-power-lots-of-ice/
12:30:09 <shapr> I've also thought of a feature to follow a thread across archives
12:30:20 <shapr> like all the threads that go from haskell@ to haskell-cafe@
12:30:43 <shapr> I think I can generate a view like that from the database.
12:30:54 <CosmicRay> yeah
12:31:20 <CoolPops> CosmicRay: what a cool blog name!
12:31:25 <CosmicRay> my Master Plan was to either schlep the archives into an NNTP server ala gmane.org, or write an NNTP server that uses mbox archives as its backend
12:31:27 <CosmicRay> CoolPops: thanks :-)
12:31:59 <CosmicRay> because NNTP can do that, and it gives another feature for free (nntp client access)
12:33:20 <shapr> __doc__: python programmer?
12:33:25 <CosmicRay> CoolPops: http://changelog.complete.org/articles/2004/12/29/haskell-my-new-favorite-language/
12:33:42 <CosmicRay> that seems a fair guess
12:33:57 <CoolPops> CosmicRay: hheh. I'm reading the link you have to PythonVsHaskell right now.
12:34:58 <CosmicRay> it's a fair comparison, though the code examples suck
12:35:14 <CosmicRay> (really, the reason one chooses a high-level language shouldn't be solely based on how easily it works with C)
12:37:04 <__doc__> what's the link of pythonvshaskell?
12:37:18 <ski> http://www.python.org/cgi-bin/moinmoin/PythonVsHaskell
12:37:24 <CosmicRay> http://www.python.org/cgi-bin/moinmoin/PythonVsHaskell
12:37:27 <CosmicRay> bah
12:37:35 <__doc__> thx none the less ray :)=
12:37:39 <CosmicRay> :-)
12:38:00 <CosmicRay> FWIW, there seem to be quite a lot of people involved with Haskell that use Python
12:38:04 <CosmicRay> (or did previously)
12:39:46 <wolfman8k> that's because python is the only mainstream imperitave language that has lot's of functional features, map/filter high order functions and combinators
12:40:12 <wolfman8k> and a light syntax that writes as if there is type inference :)
12:40:18 <CosmicRay> some of my favorite Python features were things like the list comprehensions [x for x in y if z]
12:40:25 <CosmicRay> indeed
12:41:03 <CosmicRay> Haskell is, to me, the way Python would ultimately evolve if Guido would let it :-)
12:41:08 <CosmicRay> It's Python 3 :-)
12:41:24 <wolfman8k> nah, they are totally different languages
12:41:36 <wolfman8k> c# is closer to haskell in some ways :O
12:41:39 <CosmicRay> I know, but conceptually, guido has been trying to tone down the functional stuff
12:41:40 <__doc__> hm, I somewhat am interested if guido's going to make a whole new shiny python 3k with all good stuff (tm) from everywhere
12:41:56 <CosmicRay> __doc__: that's what perl is, isn't it? :-)
12:42:04 <wolfman8k> no, that's what merd is :D
12:42:12 <_Codex> pointfree associative composition is what we need in more languages.
12:42:18 <__doc__> hm, actually I think the parrot guys are one to something ( and be it only cream pie ) :)
12:42:18 <wolfman8k> too bad merd doesn't seem to have a working implementation yet
12:42:38 <__doc__> I'd really like to see starkiller
12:43:02 <CosmicRay> you guys coming from python would probably find these resources useful:
12:43:17 <CosmicRay> standard library reference ("global module index"): http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
12:43:18 <wolfman8k> only problem with haskell is that it takes mathematical research and discoveries to advance the language. other languages seem to evolve in an evolutionary way based on practical needs
12:43:29 <CosmicRay> wolfman8k: I'd dispute that
12:43:56 <CosmicRay> wolfman8k: Haskell, as a language, is years ahead of many other languages thanks to its heritage in research.
12:44:14 <wolfman8k> ok, i meant to say: problem/advantage :D
12:44:20 <CosmicRay> but there is a *lot* that can be done in Haskell without even touching the core language
12:44:29 <wolfman8k> right, that's part of what i mean
12:44:46 <wolfman8k> but if you look at c++, people *still* don't even really understand exceptions
12:44:51 <__doc__> advantage of python is that you can look at it, and you know what you get. 
12:45:06 <goron> I want to print a trace of an execution of a theorem prover I have written with another student. How can I do this in Haskell?
12:45:12 <CosmicRay> __doc__: the advantage of haskell is that that statement is actually true :-)
12:45:39 <CosmicRay> __doc__: for instance, in Python, you don't know if a function you call is mutating some global state
12:45:44 <CosmicRay> __doc__: that is, side effects can be hidden
12:45:59 <wolfman8k> that's what i was telling him in the other channel ;)
12:46:11 <Philippa_> goron: how cleanly do you want to do it?
12:46:14 <CosmicRay> goron: http://www.haskell.org/debugging/
12:46:29 <shapr> __doc__: ever tried to debug Zope or J2EE?
12:46:41 <__doc__> nope, I don't touch zope or java
12:47:35 <CosmicRay> __doc__: wise.
12:48:10 <__doc__> zope always scares me away with almost python and a bloated codebase--------
12:48:54 <CosmicRay> not to mention "nah, there's no problem storing the entire content of all of your websites in one single file..."
12:49:24 <goron> Philippa_: It should work within the hour, and the rest of the code should still work. 
12:49:48 <goron> Philippa_: So it does not need to be clean, but would be preferred. 
12:51:00 <Philippa_> how much of the code's monadic already?
12:51:29 <Philippa_> CosmicRay: christ. I mean, I figured Flippi's "the filesystem is the database" approach was crude...
12:52:07 <shapr> goron: have you looked at Hood or Buddha?
12:52:10 <mflux> but the filesystem _is_ the database..
12:52:16 <mflux> (or s/the/a/g)
12:52:43 <wolfman8k> aren't databases implemented in terms of (memory mapped) files?
12:52:55 <goron> shapr: Now looking at Hood. 
12:52:57 <mflux> maybe, or directly to the device
12:53:06 <Philippa_> mflux: a file for each field? :-)
12:53:12 <mflux> they may not be memory mapped either
12:53:19 <goron> shapr: Is it possible to just pass it a function, and then see the trace?
12:53:20 <mflux> otherwise >4G databases on 32bit systems would be difficult
12:53:28 <shapr> I don't know.
12:53:33 <CosmicRay> Philippa_: yeah, the infamous Data.fs
12:53:37 <mflux> philippa_, yes.. a file is the key, its contents, well, is the contents
12:53:51 <mflux> I've used that approach too
12:54:26 <mflux> philippa_, and ultimately there are many advantages (and some disadvantages) with doing so ;)
12:54:37 <Philippa_> one of them is being able to say "use a better OS" :-)
12:55:28 <CosmicRay> goron: I believe hugs may be able to help you too
12:55:41 <mflux> pros: 1) operating system propably keeps that structure sane in case of unclean shutdown 2) you can use symbolic links 3) user can easily browse and modify the data 4) allows mounting hierarchies from a remote system
12:55:47 <CosmicRay> maybe not though, hmm
12:56:00 <Philippa_> 3) also comes under cons :-)
12:56:17 <mflux> well if 1) happens then 3) can be a great pro ;)
12:56:28 <Philippa_> I'd add 5) somebody else gets to do all the caching work
12:56:39 <Philippa_> which is probably a good thing for a server-oriented app
12:56:41 <mflux> well that happens with big file-approach too?
12:56:57 <mflux> 5) incremental backups are actually useful
12:57:00 <Philippa_> not the same way though
12:57:02 <mflux> or 6, whatever ;)
12:57:20 <Philippa_> with big file, the OS has no clue how the data's organised, so it has to guess things like how much of it around a given read's likely to be relevant
12:57:26 <mflux> 7, related to 3, easy to write tools to manipulate the data
12:57:44 <CosmicRay> with the big file approach, emacs is useless.
12:57:46 <CosmicRay> vim is useless.
12:57:52 <mflux> philippa_, likewise os will not be able to read the 'next' key when the previous was just read
12:57:54 <CosmicRay> pico is even more useless than usual.
12:58:05 <CosmicRay> when a standard fs layout, people can use tools they already know
12:58:21 <Philippa_> mflux: you do have predefined precache instructions though
12:58:31 <Philippa_> you can open all the file handles before you start issuing reads, for example
12:59:32 <mflux> anyway, for the sake of completeness, some cons: 1) inefficient capacitywise 2) difficult to make atomic backups 3) hmm..
12:59:33 <shapr> hm, file formats as higher order functions... you just pass them to the OS
12:59:53 <Philippa_> atomic backups is easy, you just stick the entire db under a predefined directory
12:59:54 <mflux> I would like to see some useful 'file format'-library/toolset
12:59:56 <shapr> then the OS knows how the data is organized
13:00:04 <mflux> I have not yet determined what it would be like, though ;)
13:00:24 <Philippa_> the thing about file IO is that the cache requests happen at the same speed the cache runs at
13:00:45 <Philippa_> it's not like a small code cache where you're going to be pulling code in from main memory before you can even find out what it wants
13:00:47 <shapr> there are several common file format bits
13:01:17 <Philippa_> so it's practical to batch up your load requests and start processing as data comes in (indeed Haskell rather encourages this)
13:01:22 <shapr> magic number at the start of the file, header describing details, then data
13:02:31 <mflux> in any case, I though of this a long time ago, search google groups for "Linux Common Configuration File Format -- use the filesystem!" ;)
13:02:36 <mflux> +t
13:03:13 <Philippa_> mflux: I just implemented it on a "what the hell" basis :-)
13:04:13 <shapr> while thinking about a file format toolset, I wondered about how to make file formats that are easy to guess. Like, if an alien civilization found this file, how could it be easily delimited?
13:04:29 <Philippa_> one delimiter char is as good as another
13:04:47 <mflux> well, xml may have its downsides, but I would imagine 'xml' to be quite clear, if they discovered the ascii/unicode over it
13:05:32 <shapr> I was wondering about crazy stuff like nested fibonacci trees.
13:06:33 <_Codex> key trick with file formats is how to make it compatible with all other file formats. :)
13:07:00 <shapr> how to store and easily find large and small chunks in the same structure? make the offsets fib numbers, and nest the structure when needed
13:07:18 <tuomov> xml sucks for everything that one might want to edit
13:07:28 <tuomov> it's too verbose
13:07:32 <shapr> I prefer s-expressions over xml.
13:07:43 <tuomov> even they're better..
13:07:56 <shapr> I prefer significant whitespace for reading.
13:07:57 <mflux> I would propably like some standard binary-format with the same expressiveness as xml
13:08:02 <tuomov> for config a .ini style file is quite good and robust
13:08:04 <mflux> I think the wap-guys have one
13:08:09 <shapr> ASN.1 claims to be binary XML.
13:08:13 <mflux> and some other group was writing one other too
13:08:17 <shapr> It's not, but that's what it claims.
13:08:23 <mflux> and yes, asn.1 intriques me, but I haven't actually given a try
13:08:28 <shapr> it's a nightmare.
13:08:46 <Philippa_> pick a Haskell implementation's run-time representation of ADTs
13:08:47 <mflux> asn.1 has a language in which you can generate code to access the data or something, and it should be very space-efficient
13:08:48 <shapr> Maybe because I've only used it in Java...
13:08:52 <Philippa_> there, binary XML
13:09:01 <shapr> mflux: wait till you try it
13:09:04 <mflux> ;)
13:09:24 <mflux> but in java lots of things don't come easily.. maybe with haskell or some other fpl ;)
13:09:50 <mflux> philippa_, one would rather pick a format that isn't specific to some implementation of some language..
13:09:59 <shapr> Dominic Steinitz wrote some ASN.1 code in Haskell, it would be easier.
13:10:10 <Philippa_> mflux: once you've picked it, it isn't any more. But yeah
13:10:15 <tuomov> and one that isn't specific to the hardware
13:10:16 <mflux> philippa_, likewise I hope nobody is suggesting to use java's sequence formats for it ;)
13:10:29 <mflux> ..but even that would be more standard
13:10:44 <tuomov> hummm... no
13:10:45 <shapr> One major problem with ASN.1 is cultural, people use the ANY type where they should be using the correct spec for the structure in the spot.
13:10:55 <tuomov> java's seq formats afaik change between versions
13:11:07 <shapr> But, the specs cost money, anywhere from 50 to 500 euro just to get a copy of the format description for something like X.509
13:11:34 <shapr> So you end up using ANY and losing a lot of 'type safety'
13:11:48 <mflux> oh
13:12:06 <goron> I will just use Debug.trace for the tracing. 
13:12:15 <shapr> and each spec imports one to many library specs, and those cost money too.
13:12:31 <shapr> There are reverse engineered free specs, but they're not perfect.
13:12:55 <Philippa_> goron: fair enough. It's bloody icky - that's pretty much why I use it ;-)
13:13:21 <shapr> I did X.509 security certificate parsing for a few months.
13:14:19 <tuomov> great. some gv has decided to start dropping udp, and now dns doesn't work
13:14:48 <shapr> mflux: oh, and ASN.1 has many different encodings, though thankfully there's only two major, thirteen minor, and about thirty still-encountered-legacy encodings left.
13:15:04 <Philippa_> shapr: oh *nice*
13:15:12 <mflux> shapr, well, how about the idea of asn.1, do you like it?
13:15:17 <mflux> dismissing the implementation/documentation problems
13:15:18 <Philippa_> are the major ones big-endian and little-endian by any chance? :-)
13:15:58 <shapr> The goal is a great goal. I agree that binary XML is a neat idea. At least I'd like to have a DTD that I could read and generate a parser for the format.
13:16:16 <Philippa_> shapr: ADTs. data foo deriving Binary. :-)
13:16:48 <shapr> Yeah, now I want to go the other direction for things like PNG
13:17:21 <tuomov> just gzip the .xml :)
13:18:08 <Philippa_> shapr: that one's gonna be a bugger, expect to declare some new types with their own instances of Binary. But doable nevertheless, even if you're going to end up with intermediate values and stuff
13:22:11 <Lunar^> MChan ! so cool!
13:22:28 <Lunar^> A better select in Haskell, die POSIX, die Unix, die !
13:23:45 <Philippa_> we managed a better switch statement a long time ago, a better select was inevitable ;-)
13:25:06 <Philippa_> but yeah, concurrent haskell at the kernel level seems a sweet idea to me
13:25:08 <SamC> MChan?
13:25:16 <tuomov> nah. select is cooler.
13:29:54 <Lunar^> SamC: http://www.research.microsoft.com/%7Esimonpj/papers/stm/index.htm
13:30:26 <SamC> cheers
13:31:19 <SyntaxNinja> Philippa_: but you can configure GHC to give you an error for non-exhaustive patterns by a combination of "-fwarn-incomplete-patterns and -Werror"
13:31:39 <Lunar^> SyntaxNinja: hey :) That's an hostname :)
13:32:24 <SyntaxNinja> Lunar^: huh?
13:32:44 * Lunar^ is fan... atomic (readPort p1 `orElse` readPort p2) 
13:32:48 <Lunar^> SyntaxNinja: cvs.galois.com :)
13:33:08 <SyntaxNinja> oh, have they set up reverse DNS or something?
13:33:21 <Lunar^> SyntaxNinja: /whois yourself :)
13:34:09 <stepcut> hrm, this tong thing looks scary
13:34:12 <SyntaxNinja> well, I guess that's where I am... must be the router, that's not my client machine
13:34:19 <stepcut> http://www.nongnu.org/tong/
13:37:36 <Philippa_> SyntaxNinja: heh, talk about your apparent non-sequitur
13:37:59 <Philippa_> though for Haskell 98 that's a hard thing to do generally on account of pattern guards
13:48:01 <bourbaki> moin
13:48:13 <SamC> I'm setting up a news feed client, I can only think of LtU relating to FP, any suggestions?
13:53:54 <CosmicRay> hmm.
13:53:58 <CosmicRay> we do need a haskell news page.
13:54:01 <CosmicRay> or something.
13:54:08 <CosmicRay> drupal would be perfect for that
13:54:14 <Igloo> There are a few lines at the bottom of haskell.org
13:54:27 <SamC> there should be a Haskell feed
13:54:31 <CosmicRay> or even the kuro5hin code
13:55:09 <CosmicRay> Igloo: yes, well if news from last June passes as new, I shudder to think what old news is :-)
13:55:43 <Igloo> Well if there's no news we don't need a site for it  :-)
13:55:51 <CosmicRay> heh
13:55:53 <Igloo> What problem are you trying to solve?
13:56:06 <CosmicRay> Igloo: samc was looking for an rss feed of haskell stuff
13:56:14 <CosmicRay> or fp stuff, I guess
13:56:25 <CosmicRay> but there is stuff happening.
13:56:43 <CosmicRay> since june, we've had all sorts of new code out there, new ghc, cabal stuff, postfile, etc, etc.
13:56:58 <Lunar^> planet.haskell.org could be cool :)
13:57:18 <CosmicRay> yes, I was just thinking that.
13:58:29 <CoolPops> To solve the penny doubled each day for x days: penny a 1 = a
13:58:29 <CoolPops> penny a i = penny (a*2) (i-1)
13:58:42 <CoolPops> I'm happy! my first real function in haskell that works.
14:00:05 <CosmicRay> CoolPops: yup
14:00:17 <CosmicRay> @type penny a i = penny (a*2) (i-1)
14:00:18 <lambdabot> bzzt
14:00:23 <CosmicRay> er?
14:00:42 <CosmicRay> well pfft.
14:00:43 <ski> @type let penny a i = penny (a*2) (i-1) in penny
14:00:44 <lambdabot> let penny a i = penny (a*2) (i-1) in penny :: forall t a a1.
14:00:44 <lambdabot> 					      (Num a, Num a1) =>
14:00:44 <lambdabot> 					      a -> a1 -> t
14:01:12 <CosmicRay> CoolPops: that really works?
14:01:16 <CosmicRay> CoolPops: it has no exit case
14:01:25 <CosmicRay> CoolPops: looks like an infinite loop to me
14:01:33 <ski> yep
14:01:36 <CoolPops> CosmicRay: yeah it does, penny a 1 = a
14:01:44 <CosmicRay> ah.
14:01:49 <CosmicRay> you didn't paste that bit :-)
14:01:52 <ski> (singleton type variables are a warning signal)
14:02:00 <CoolPops> hm. I see it on my screen, that's strange.
14:02:05 <Igloo> Yes he did
14:02:07 <ski> @type let penny a 1 = a ; penny a i = penny (a*2) (i-1) in penny
14:02:08 <lambdabot> let penny a 1 = a ; penny a i = penny (a*2) (i-1) in penny :: forall a
14:02:08 <lambdabot> 								     a1.
14:02:08 <lambdabot> 							      (Num a, Num a1) =>
14:02:08 <lambdabot> 							      a -> a1 -> a
14:02:09 <CosmicRay> ah.
14:02:11 <CosmicRay> there it is
14:02:20 <CosmicRay> it was along with your text, sorry.
14:02:49 <CosmicRay> anyway, you can do some interesting stuff with this
14:03:03 <CosmicRay> CoolPops: load it up into hugs or ghci and try
14:03:07 <CosmicRay> :type penny 5
14:03:09 <CosmicRay> :type penny 5.0
14:03:32 <CosmicRay> that's a partially-applied function
14:04:10 <CosmicRay> that is: \x -> penny x      means the same as    \x y -> penny x y
14:04:15 <CoolPops> I think I will continue reading the tutorial... The stuff from lambdabot seems a little over my head right now.
14:04:23 <CosmicRay> (the backslash is the haskell version of "lambda" in python)
14:04:34 <CosmicRay> ahh, didn't know you were following the tutorial
14:04:37 <CosmicRay> yes, continue :-)
14:05:03 <CoolPops> actually I am going to go home (5pm) and continue the tutorial, cya all later... thanks for the help.
14:16:48 <musasabi> morning
14:19:53 <Philippa_> Binkley: 'lo
14:36:58 <TheHunter> can GHC core's @ somehow be used in haskell code, too?
14:38:36 <kosmikus> no
14:39:34 <TheHunter> thanks
14:40:05 <wolfman8k> what does it mean that haskell has garbage collection?
14:40:19 <wolfman8k> haskell programs can't allocate memory, so where does the garbage come from?
14:40:22 <Riastradh> Memory is automatically reclaimed.
14:40:23 <Pseudonym> It means you can have an extra bin in your office and it will be taken care of.
14:40:30 <Riastradh> What do you mean Haskell programs can't allocate memory?
14:40:37 <wolfman8k> there is no malloc :)
14:40:52 <Riastradh> So what does (:) do?
14:41:08 <esap> wolfman8k: The Haskell simulates infinite memory. All the operations can allocate memory. Since the system simulates infinite memory, it doesn't need to be controlled by the programmer [because there is always sufficient memory]
14:41:25 <wolfman8k> isn't (:) like a function call?
14:41:40 <esap> wolfman8k: The garbage collection is the simulation of infinite memory.
14:41:56 <wolfman8k> but when i program in haskell i don't even think about memory
14:42:03 <wolfman8k> it's only functions
14:42:06 <esap> wolfman8k: Exactly.
14:42:06 <Riastradh> 1:2 calls the function (:).  What does it _do_?
14:42:21 <esap> wolfman8k: You don't need to, because Haskell takes care of it for you.
14:42:35 <wolfman8k> but it's like saying that c has garbage collection via the stack
14:42:40 <Riastradh> It's not like Haskell programs magically work without requiring physical memory.
14:43:29 <esap> workman8k: no, stack is not infinite :-) And there is a fixed structure to the stack, which constraints where stack can be used.
14:44:18 <wolfman8k> the stack in c is just as infinite in theory as haskell's magical memory structure
14:44:38 <wolfman8k> and the stack in c is all you need if you don't use mutable variables
14:45:10 <Riastradh> Data is not persistent on the stack.  You cannot return stack-allocated data from a function.
14:45:15 <esap> wolfman8k: not all operations in C can work with the stack structure. So in C, stack is not the only memory management mechanism. GC can be the only memory management mechanism in most programs.
14:45:16 <Pseudonym> Riastradh: It gives you a type error.  Hope this helps!
14:45:41 <SamC> I see wolfman8k's point, it does seem odd to say that haskell automatically deallocates memory when it automatically handles memory usage
14:45:45 <monochrom> garbage collection = mimicking infinite memory assuming reachable data has compact support.
14:46:12 <Riastradh> Stack-allocated data have finite extent, terminated by returning.  Heap-allocated data have unlimited extent.
14:47:52 <kosmikus> data constructors like (:) don't compute, they allocate memory, even if the content is (in principle) immutable
14:48:17 <monochrom> There is a way of executing programs using heap instead of stack.  I use this way to manually execute small programs for educational purposes.
14:48:28 <Darius> kosmikus: What does mutability have to do with it?
14:48:59 <musasabi> actually one can use the stack like a heap ;)
14:49:06 <musasabi> The trick is not to return.
14:49:11 <Darius> Cheney on the MTA
14:49:12 <wolfman8k> i'm thinking that haskell's garbage collection has something to do with laziness
14:49:16 <kosmikus> nothing, sorry if the remark confused you
14:49:36 <Riastradh> Yes, musasabi, but that is not how C normally works.
14:49:40 <wolfman8k> since i have no idea how one would implement laziness so i figure that gc might have something to do with it
14:50:15 <Darius> wolfman8k: Laziness is not the reason Haskell has GC.
14:50:19 <kosmikus> Darius: but since I don't understand wolman8k's question, ...
14:50:30 <monochrom> gc and evaluation strategy are independent
14:50:32 <Riastradh> wolfman8k, where do you get the connection between garbage collection and laziness?
14:50:34 <kosmikus> many strict languages have gc
14:50:43 <kosmikus> Java is garbage-collected and doesn't have malloc
14:50:51 <zamez> and I'm lazy, but don't have garbage-collection :>
14:50:58 <wolfman8k> yeah, but java has a malloc operation
14:51:02 <monochrom> "I don't understand X, I don't understand Y, therefore X and Y are related"? :D
14:51:05 <Pseudonym> So does Haskell.
14:51:07 <Philippa> wolfman8k: laziness is easy - you return thunks instead of results
14:51:07 <wolfman8k> monochrom: exactly!
14:51:11 <kosmikus> huh, java has malloc?
14:51:18 <Pseudonym> Every time you call a constructor function, you implicitly call a malloc()-like operation.
14:51:20 <monochrom> That is a very coarse equivalent relation.
14:51:21 <Philippa> kosmikus: it has new, same difference
14:51:23 <Darius> wolfman8k: Think of it this way, writing Cons x xs in Haskell is like writing new Cons(x,xs) in Java.
14:51:32 <Pseudonym> That's why it's called a constructor function.
14:51:34 <Pseudonym> It constructs.
14:51:47 <Pseudonym> Like a constructor in an object-oriented language.
14:51:49 <monochrom> There is eager haskell and it also needs gc.
14:51:49 <kosmikus> Philippa: yeah, well, new is really like calling a data constructor in Haskell; that's what I was trying to say
14:51:52 <Philippa> I dunno, there's valid cause for separating construction from allocation sometimes
14:51:59 <wolfman8k> well, the name cons is a bit misleading then
14:52:01 <Pseudonym> Sometimes, yes.
14:52:12 <Pseudonym> wolfman8k: No more than it is in Lisp.
14:52:31 <monochrom> actually why bother with eager haskell.  lisp had gc.  gc is very old.
14:52:33 <wolfman8k> lisp was inspired by imperative languages :P
14:52:39 <Philippa> indeed as lisp predates OO, the OO folks can take their fancy new terminology and shove it ;-)
14:52:40 <Riastradh> wolfman8k, uh, wrong.
14:52:54 <Riastradh> Lisp was inspired by recursive equations and the lambda calculus.
14:52:58 <monochrom> lisp inspired by Backus's FP, also had gc.
14:53:39 <monochrom> I don't claim that it's the only inspiration.  Lisp got ideas from lots of origins.
14:53:53 <Pseudonym> Early lisps weren't modern functional languages, but that's like saying that Newtonian physics isn't like modern physics.
14:54:23 <Pseudonym> Or that Ancient Greek geometry isn't like modern geometry.
14:54:53 <zamez> surely there is nothing inherent in Haskell that requires GC?
14:55:03 <Philippa> nope. Given infinite memory you can run without it
14:55:10 <zamez> I mean that an interpreter should know when data is no longer required
14:55:16 <Philippa> it may be possible to do region inference instead
14:55:22 <Philippa> er, that's garbage collection again
14:55:25 <zamez> or reference counting
14:55:36 <Philippa> reference counting is just a particularly crappy way to do GC
14:55:39 <Darius> zamez: You can construct cycles in Haskell.
14:55:39 <esap> reference counting doesn't handle loops well
14:55:42 <Philippa> (which doesn't work for haskell)
14:55:47 <Pseudonym> Not necessarily.
14:55:48 <zamez> pfft, details :>
14:55:58 <Pseudonym> Reference counting has real-time guarantees, which are occasionally very handy.
14:55:59 <musasabi> SML like region inference would be kind of nice.
14:56:11 <musasabi> but I think lazyness makes that harder.
14:56:18 <Pseudonym> And you can do concurrent reference-counting of loops.  You just need a bit more information than a simple reference count.
14:56:20 <Philippa> musasabi: yeah, that's why I say may
14:56:21 <Pseudonym> And it's tricky.
14:56:27 <Darius> zamez: Between purity and HOFs, there are inherent things that make Haskell require GC.
14:56:33 <Pseudonym> Which doesn't mean it's a good idea.
14:57:04 <monochrom> You either need infinite memory or you must occasionally identify unreachable data.
14:57:23 <goron> How exactly does trace work anyway? I mean my intuition says, it's called in the order of how your expressions are evaluated. 
14:57:49 <monochrom> Your intuition sounds right.
14:57:53 <Philippa> the printout is a side-effect of its evaluation
14:58:39 <Pseudonym> Actually, you can do precise collection without tracing in a pure language which doesn't have closures.
14:58:39 <monochrom> I am not sure if you really want to know "how exactly".  It involves unsafePerformIO and a lot of details.  Too overwhelming for you, I'd suspect.
14:58:51 <Pseudonym> It turns out that closures are what makes GC proper necessary.
14:59:06 <wolfman8k> what are closures?
14:59:07 <Pseudonym> Lazy evaluation makes a lot of closures.
14:59:14 <wolfman8k> aha, so it *is* lazy eval! :D
14:59:22 <Pseudonym> No, ML makes closures, too.
14:59:38 <Pseudonym> See "Compiling With Continuations" for more detail.
14:59:46 <Philippa> closures are what you get when you need to evaluate the result of a (potentially partially applied) function later on
14:59:56 <Philippa> basically a code pointer and an environment dump
15:00:18 <_Codex> Is there some good reason why f . g cannot be used in pattern matching?
15:00:24 <Philippa> yes
15:00:25 <monochrom> SML example.  fun f () = let val n = ref 0 in x:=x+1; x end
15:00:30 <Philippa> there's no way to tell if two functions are equal
15:00:46 <_Codex> philippa: equalizers?
15:01:05 <Philippa> _Codex: being?
15:01:09 <Pseudonym> _Codex: How about I give you two Haskell functions, and you find their equaliser.
15:01:09 <monochrom> Hrm my example is not contorted enough.
15:01:10 <Pseudonym> Okay?
15:01:49 <Philippa> _Codex: it's just not doable. At best you can tag functions with an id or do structural equality on their terms, both of which can be expressed if you really really need it
15:01:56 <esap> Not all equalizers for all pairs of functions exist.
15:02:32 <Pseudonym> Here's one function:
15:02:41 <Pseudonym> f n = 2*n
15:02:44 <monochrom> You can compare two functions for extensional equality.  It will take quite a while.
15:02:46 <Pseudonym> And here's the other function:
15:02:55 <Darius> Pseudonym: You should only have to give one Haskell function, but one issue is that there are multiple ways of factoring it.
15:03:37 <goron> monochrom: I don't know, whether I would be overwhelmed. I have little experience with hardcore C programming (while I understand the semantics of pointers and stuff, I always need to think about them (because I program in Haskell and Java (and a six months of C++))). 
15:03:45 <Pseudonym> Darius: Isn't an equalizer of f and g, a morphism h such that f . h = g . h?
15:03:51 <Pseudonym> So don't you need to give both f and g?
15:04:37 <Pseudonym> (I didn't bother with the universal criterion for equalizers, blah blah blah.)
15:04:43 <Darius> Pseudonym: Yes, but I was referring to "pattern matching" with f . g
15:04:48 <Pseudonym> Ah, OK.
15:04:49 <Pseudonym> Yes.
15:04:59 <Pseudonym> I was talking about Philippa's assertion: there's no way to tell if two functions are equal
15:05:55 <Philippa> I'd narrow that down to no way that's guaranteed to terminate, as that's good enough for the purpose (non-terminating pattern matching would be a bit of a bugger)
15:06:09 <musasabi> actually thinking about haskell on the machine level helps me understand things sometimes.
15:06:29 <esap> I suppose equality of functions is possible if the domains of all the functions are finite? Because then you can list all the elements of the domain, and check if the values match.
15:06:44 <Philippa> esap: right
15:07:02 <goron> monochrom: If you would like to tell me, I am all ears.
15:07:17 <musasabi> Identity for functions does not make much sense in general in haskell.
15:07:21 <Pseudonym> esap: You can if the functions terminate.
15:08:08 <esap> of course, the comparison function takes the function in the form of [(a,b)]. compare_function :: [(a,b)] -> [(a,b)] -> Bool
15:08:10 <Philippa> musasabi: there's a nasty bit of hackage in the version of flippi in darcs atm as a result though, involving using a monad to spit out unique identities for parsers so they can name each other for removal from a list
15:09:23 <esap> pseudonym: And have it be strict on its arguments... Then you might argue it's not the comparison that doesn't terminate, but the mapping to strict version before that :-)
15:10:37 <Darius> esap: If bottom is one of the elements of the codomain, no.  You can't even compare Bool -> Bool functions for equality.
15:12:23 <esap> darius: ok, maybe need to restrict the codomain as well. So domain can't be infinite and codomain can't include _|_.
15:14:57 <esap> I guess if the codomain includes _|_, you might be better using natural transformations anyway :-)
15:16:53 <esap> actually, even that doesn't help :-(
15:16:53 <monochrom> http://www.google.ca/groups?selm=c4hmj0%245io%241%40camelot.ccs.neu.edu&output=gplain
15:17:13 <monochrom> (Joke)
15:19:25 <Philippa> The time needed for "down" to perform this calculation 
15:19:25 <Philippa> is not specified.
15:19:26 <Philippa> heh
15:19:55 <Itkovian_> shapr: did you write that FLTK irc thingie?
15:20:17 <esap> Well I can write a termination checker that will always terminate after a specified time (it can even be specified by the user!). However, then it will check whether the function will terminate within the specified time :-).
15:20:53 <monochrom> That's called the Rice theorem.
15:21:31 * Darius finds it interesting that a French language is named JoCaml.
15:22:38 <wolfman8k> did you see the joecamel internet video?
15:23:26 <jadrian> Ah, I've heard of that one
15:23:38 <wolfman8k> it's a good one
15:23:40 <arjanb> Itkovian_: no, musasabi did
15:23:40 <jadrian> it's either concurrent or parallel Caml...
15:25:19 <Itkovian_> ah
15:25:51 <Itkovian_> musasabi: shouldn't it compile using the -package FLTK option in ghc?
15:28:57 <Itkovian_> hmm, ah well, i'm off to bed ... I expect my kid to wake up screaming for food in about 26 minutes ...
15:29:01 <Itkovian_> gdnight all
15:29:09 <musasabi> Itkovian_: yes it does.
15:29:14 <musasabi> damn.
15:30:58 <musasabi> If Itkovian wakes up please tell him to use the darcs repository version.
15:31:48 <musasabi> btw the bug which kept hs-fltk working from december with the CVS ghc has been fixed today in ghc CVS :-)
15:38:40 <stepcut> anyone know of a comment *preserving* ini file reading/writing library ?
15:39:41 <musasabi> Should be 5 minutes with parsec.
15:43:28 <stepcut> musasabi: hahahaha
15:56:49 <SyntaxNinja> Philippa: pattern guards make the warnings bad?
15:57:43 <Philippa> SyntaxNinja: pattern guards mean you have to check a bunch of pretty much arbitrary conditions are exhaustive
15:58:25 <Pseudonym> Which reduces to the previous discussion on function equality.
15:59:40 <Philippa> without guards, it has to be expressed in terms of if/then or pattern-matching on the results of a function - in the latter case you can use the type system to check for totality again where relevant
16:00:22 <SyntaxNinja> right, but you weren't complaining about pattern guards, right? since that's not possible.
16:00:51 <Philippa> no, pattern guards are just something I've conveniently not introduced to Tyop for now :-)
16:04:48 <jadrian> Philippa: I sort of agree, 
16:05:08 <jadrian> Philippa: still there are cases where you know you won't need all the patterns (when pattern matching) 
16:05:32 <jadrian> Philippa: so in those cases you end up having to use a dummy "_" for completeness
16:05:32 <Lunar^> musasabi: what about CosmicRay's ?
16:05:44 <rtega> jesus, you guys sound like c++ engineers ;)
16:05:52 <rtega> pattern here, pattern there
16:06:04 <jadrian> Philippa: which is not that different from using a dummy "otherwise" too
16:08:12 <musasabi> Lunar^: that just disposes comments iirc
16:08:46 <Lunar^> musasabi: Maybe you could hack it a bit ?
16:10:45 * musasabi things you might mean stepcut
16:11:13 <Philippa> jadrian: my post was really about the idea that you could just take the union of the constructors involved as the type you check against the discriminant
16:11:27 <Philippa> doesn't quite make sense in Haskell, does in a close variant
16:14:22 * jadrian reads again
16:14:47 <jadrian> Philippa: isn't that what subtyping is meant to help you with? or maybe I am not understanding...
16:14:49 <Philippa> oh, I didn't /say/ that
16:14:58 <Philippa> well, it's exactly what it helps me with in Tyop, yeah
16:15:36 <jadrian> ah so you do use subtyping?
16:15:37 <Lunar^> musasabi: uhhh sure
16:15:41 <Philippa> you just check this union type to see if it matches the LUB of its components, if so then it's well typed
16:16:16 <Philippa> yeah. Type constructors are either data constructors or sums of type constructors (which become subtypes)
16:16:29 <jadrian> right 
16:16:32 <Philippa> in the latter case, the kinds must match
16:17:12 <Philippa> not really all that impressive an addition, but coupled with type classes you can do some really scary typing
16:17:40 <jadrian> have you looked at OBJ languages?
16:17:50 <Philippa> OBJ? (probably not)
16:17:54 <jadrian> like OBJ3, CafeOBJ, Maude...
16:18:17 <jadrian> Specification languages. They use subtyping a lot, and I really like the way it is done.
16:18:56 <Philippa> just googled, will look at tomorrow
16:19:01 <Philippa> for now, my b/f needs company :-)
16:19:17 * stepcut needs to read up on subtyping soon
16:19:21 <jadrian> k :)
16:19:37 <Philippa> FWIW, I do like the idea of ADTs/"supertyping" and typeclasses which have subtyping being in the same type system
16:19:54 <jadrian> With subtyping you can say things like
16:20:06 <jadrian> [EmptyList < List]
16:20:09 <Philippa> you get two very dual-looking type systems meshing together really quite nicely
16:20:39 <Philippa> or perhaps more usefully Cons < List, which lets you type functions that only take non-empty lists
16:20:42 <jadrian> and get type checking for operations that use those subtypes
16:20:44 <Philippa> anyway
16:20:52 <Philippa> 'night
16:20:56 <Pseudonym> Night.
16:20:58 <jadrian> g'night
16:21:06 <Pseudonym> Even more scarily, in Mercury, you can do this:
16:21:27 <Pseudonym> X :: EvenLengthList, Y :: MultipleOfThreeLengthList
16:21:39 <Pseudonym> And when you unify them, you get MultipleOfSixLengthList
16:21:41 <Pseudonym> More or les.
16:21:46 * Philippa blinks
16:21:52 <Philippa> damn, should've walked right then - how's it done?
16:22:00 <Pseudonym> It's in the mode system.
16:22:05 <Pseudonym> Not the type system.
16:22:10 <Pseudonym> Which helps a lot.
16:22:17 <Pseudonym> Basically, it's regular tree unification.
16:22:27 <Pseudonym> Which is like standard unification, only without the occur check.
16:22:35 <Philippa> ah, makes sense
16:22:47 <Pseudonym> Tricky to implement, but very cool.
16:23:03 <Pseudonym> Getting a nice way for the user to specify it... now THAT'S hard.
16:23:15 <Philippa> I can find a way to do it without that given the chance to introduce a self-referring type synonym TwoList a = Cons a (Cons a (TwoList a)) | Nil
16:23:29 <Philippa> well, not really a synonym, but YSWIM?
16:23:31 <Pseudonym> Right.
16:23:44 <Pseudonym> Pretty much what Mercury does, only in modes not types.
16:23:47 <Philippa> the non-recursive case I've already cooked up enough twisted uses for
16:23:48 <Pseudonym> Modes are like annotations on the type tree.
16:24:45 <Philippa> anyway, gone
16:25:06 <Pseudonym> Night.
16:34:07 <stepcut> writing a liberal EBNF for ini files is tricky
16:34:21 <stepcut> because you have to worry about silly things like, what if the last line is:
16:34:23 <stepcut> key=
16:34:27 <stepcut> with no trailing new line
16:34:29 <stepcut> :-/
16:35:28 <bourbaki> moin
16:38:00 <Pseudonym> @arr
16:38:00 <lambdabot> Smartly me lass
16:39:49 <bourbaki> Pseudonym: do you have a good knowledge of 3d textures that are generated ?
16:40:01 <Pseudonym> I know a few.
16:41:58 <bourbaki> Pseudonym: which are these?
16:42:07 <bourbaki> i want to write a shader for my 3d surface
16:42:16 <Pseudonym> http://www.renderman.org/RMR/Shaders/surface.html
16:42:21 <Pseudonym> Some of those are 3D, for example.
16:42:21 <bourbaki> so that there is no distorsion like in the planar mapping
16:42:34 <Pseudonym> wood is an interesting one if you have Perlin noise handy.
16:42:58 <bourbaki> yeah i am looking forward to do perlin noise per pixel
16:42:59 <wolfman8k> bourbaki: http://libnoise.sourceforge.net/examples/textures/index.html
16:43:35 <bourbaki> thx
17:35:56 <wagle> are mzero and mplus not supposed/required to have associativitty laws, or are they implied, or did the presentation space them out
17:36:00 <wagle> ?
17:36:48 <wagle> ok, mplus, i mean
17:37:06 <Cale> mplus ought to be associative, I'm fairly sure
17:37:59 <Pseudonym> I don't know if it's formally documented anywhere, but yes, I'd agree with that.
17:37:59 <wagle> only the four mzero laws were presented:
17:38:03 <desrt> but not necessarily commutative
17:38:11 <wagle> 1.  mzero >>= f == mzero
17:38:12 <wagle> 2.  m >>= (\x -> mzero) == mzero
17:38:12 <wagle> 3.  mzero `mplus` m == m
17:38:12 <wagle> 4.  m `mplus` mzero == m
17:38:19 <Cale> (but commutativity is nice if you can get it)
17:38:30 <wagle> yeah
17:38:39 <Pseudonym> Not necessarily.
17:39:01 <wagle> (store . cont) != (cont . store)
17:39:03 <Pseudonym> List concatenation isn't commutative, but I find it pretty useful without that property.
17:39:53 <Pseudonym> Oh, duh.
17:40:00 <Pseudonym> Tree monads aren't associative.
17:40:44 <Pseudonym> data Tree a = Leaf a | Cons (Tree a) (Tree a)
17:40:48 <Pseudonym> instance Monad Tree where
17:40:51 <Pseudonym>     return = Leaf
17:41:22 <Pseudonym>     (Leaf a) >>= k = k a
17:41:50 <Pseudonym>     (Cons l r) >>= k = Cons (l >>= k) (r >>= k)
17:42:06 <Pseudonym> Oh, you also need a nil for mzero.
17:42:16 <Pseudonym> And a smart constructor for Cons which removes nils.
17:42:25 <Pseudonym> But you get the idea.
17:43:00 <Darius> I was making a Tree monad, and was about to add a smart branch constructor but then wondered about strictness.
17:44:14 <Darius> Pseudonym: Also, if you make Tree abstract, then the run function can make it associative overall.
17:44:33 <Pseudonym> Yes, but they're not equal for strictness reasons, as you note.
17:44:36 <jadrian> nice, I had never thought of a tree as a monad
17:44:37 <Cale> Well, with rose trees, you can take mplus to identify the roots, concatenating the lists of subtrees
17:44:45 <Pseudonym> They might be (==) equal, but not (=) equal.
17:44:52 <Pseudonym> Where (==) can return bottom.
17:45:24 <Darius> Pseudonym: I was worried about infinite searches 
17:45:34 <Pseudonym> I _think_ it's true that for any reasonable monad, they should be equal under observation.
17:46:01 <Pseudonym> runMonad (m `mplus` (n `mplus` p)) = runMonad ((m `mplus` n) `mplus` p)
17:46:12 <Pseudonym> But observation is not part of the definition of what constitutes a monad.
17:46:20 <Pseudonym> Even a MonadPlus.
17:46:59 <Pseudonym> Darius: No different than with a list monad.
17:47:04 <Darius> Pseudonym: True, but the issue is how we define the "=" in the monad laws.
17:47:05 <Pseudonym> Infinite searches, that is.
17:47:25 <Pseudonym> Right.
17:47:34 <Pseudonym> I think it's strong equality, so that bottom = bottom is True.
17:47:52 <Pseudonym> And bottom = Leaf 2 is False.
17:48:02 <Darius> Pseudonym: The "=" remark was in response to the observation remark.
17:48:08 <Pseudonym> True.
17:48:33 <Pseudonym> Obviously, SomeMon a is not going to be defined on Eq if a is not defined on Eq, for example.
17:48:34 <Darius> Pseudonym: The infinite searches is in response to using a nil-removing cons.
17:48:54 <Pseudonym> cons Nil t = t
17:49:04 <Pseudonym> Oh, I see what you mean.
17:49:07 <Pseudonym> Hmmm.
17:50:16 <wagle> yeah, i was going to bring up the "the set monad" problem
17:50:46 <Pseudonym> Removing Nil from the left is no problem.
17:51:15 <Darius> jadrian: From most data types (sum of product ones) you can generate a related data type which can be instantiated as a monad.
17:51:28 <wagle> sure that doesnt violate a monad law?
17:51:49 <jadrian> Darius: you mean parameterized data types, right?
17:51:51 <Pseudonym> Actually, this monad law looks suspicious:
17:51:54 <Pseudonym> m >>= (\x -> mzero) == mzero
17:52:00 <Pseudonym> What if m doesn't terminate?
17:52:15 <Cale> Sets, lists, and trees are among the more fundamental examples of monads. It's too bad that sets can't be instances of Monad in Haskell, but I think that trees should get mentioned more often.
17:52:17 <Pseudonym> Can't be strong equality, then.
17:52:34 <Pseudonym> Cale: That's a limitation of the type system.
17:52:37 <wagle> Brian Huffman's been finding some problems with bottom vs the monad laws
17:52:44 <Cale> Pseudonym: yeah, I know
17:52:48 <Darius> jadrian: The resulting datatype will be parameterized, but the original doesn't really need to be.
17:52:49 <Pseudonym> In fact, the Simons should be working on that problem more than GADTs. :-)
17:53:27 <Pseudonym> People have been wanting set monads longer than they've been wanting templates.
17:53:43 <Pseudonym> Back to Phil Wadler, I think
17:53:50 <Darius> Cale: >>= is substitution.  So, for example, an AST is instantiable to a monad with return being Var and >>= being substitution.
17:54:06 <Cale> Darius: hm?
17:54:29 <Cale> Darius: was that intended to be directed at jadrian?
17:55:10 <Darius> Well, it's related to what I was saying to jadrian, but it generalizes tree monads as well.
17:55:22 <Cale> yeah
17:56:23 <Cale> Viewing monads as containers makes what to do with bind in many cases much more obvious I find.
17:56:55 <wagle> i'd rather have a tree monad be a list monad in tree form..  hmm..  i think i did that once..  i wonder where i put it
17:57:11 <Darius> I don't much like the "container" view as so few monads are (naturally) "container" types.
17:57:30 <Pseudonym> I'm not sure that I agree with that.
17:58:05 <Pseudonym> The Reader monad, for example, is a curried cartesian product container.
17:59:01 <Darius> 1) I added the "naturally" for a reason, 2) continuation monad, state monad, writer monad, parser monad?
17:59:10 <jadrian> Darius: I think I get the idea, but I'm somehow lost with "kinds"
17:59:41 <jadrian> Darius: so if you have TreeInt = LeafInt | Node TreeInt Int TreeInt
18:00:09 <jadrian> Darius: how would you declare that as a monad instace? instance Monad ? where 
18:00:42 <Darius> jadrian: I didn't say any data type can be declared as a monad, I said that you can generate (canonically) a data type that can be.
18:00:43 <jadrian> instance Monad TreeInt where  results in a kind error
18:00:50 <jadrian> Darius: ah
18:01:07 <Darius> jadrian: Some (many?) monads can be viewed as the result of this process.
18:02:46 <Darius> The tree monad can be considered the result of this applied to a signature describing a language with only a binary operation.
18:03:07 <Darius> Really, to be canonical, it needs to be applied to signatures.
18:04:08 <Pseudonym> For containers, I actually find the monad bases (concat, map and return) easier to grok than the Kleisli basis (bind, return).
18:04:29 <Pseudonym> s/bases/basis/
18:04:58 <Cale> Pseudonym: yeah
18:06:41 * jadrian thinks he should have probably parameterized some of is datastructures to have functor and monad instances
18:06:58 <Darius> Thinking about it now, when thinking of bind as substitution it's pretty clear how it relates to concat and map and so I don't find either to be particularly superior.
18:07:09 <jadrian> one of the problems though, is that there is that I could use more than one funcot/monad instance 
18:07:23 <jadrian> that is, there is more then one parameter I would like to abstract them over
18:07:50 <Darius> jadrian: There are some approaches you could take to resolving that.
18:08:04 <Cale> jadrian: well, you can pick one as dominant, and write other -map functions for the others, for example
18:08:21 <Pseudonym> But then you'd need other bind functions too.
18:08:50 <jadrian> not only that
18:08:51 <Cale> yeah, in the case of monads, you can spend/waste a lot of time :)
18:08:59 <Cale> actually
18:09:19 <jadrian> I'd need to rewrite all the functions that are based on Functors/Monads
18:09:21 <Pseudonym> You could use a newtype wrapper.
18:09:28 <Darius> jadrian: You could use phantom types or wrapper types to handle it.
18:09:30 <jadrian> Darius: what do you have in mind
18:09:30 <Pseudonym> Make it a different type and hence a different monad.
18:09:31 <jadrian> ?
18:09:32 <Cale> probably a decent way to handle it would be to have isomorphic types with maps to translate between them
18:09:33 <Pseudonym> Right.
18:09:42 <Pseudonym> Oooh.
18:09:45 <Pseudonym> I like the phantom types idea!
18:10:00 * jadrian hasn't studied phantom types yet
18:10:12 <Darius> jadrian: Using phantom types, you'd have MyMonad phantomtype a, and instance Monad (MyMonad ThisKind) ...
18:10:37 <Pseudonym> You're actually using the Monad instance as a traits typeclass.
18:10:46 <Pseudonym> Well, Monad as a traits typeclass.
18:10:47 <Darius> Pseudonym: Yes, exactly.
18:10:51 <Pseudonym> Nice.
18:11:08 <Pseudonym> Is that on the wiki anywhere?  If not, you should write a short article.
18:11:52 <Darius> jadrian: The wrappen type would look like, newtype ThisKind a = ThisKind (MyMonad a), instance Monad ThisKind ...
18:12:25 <Darius> Pseudonym: There's a traits typeclass page that I thought you added and rather weak phantom types page.
18:12:31 <Pseudonym> Yes.
18:12:50 <Pseudonym> But this idea of ASTs-as-monads, which I realise is an old idea, should get a write-up.
18:13:09 <Pseudonym> Hmmm.
18:13:17 <jadrian> Darius: MyKind is MyType right?
18:13:24 <Pseudonym> I wonder if you can say this:
18:13:47 <Darius> jadrian: I was using kind in the common sense.
18:13:50 <Pseudonym> newtype ThisKind a = ThisKind (MyMonad a) deriving (MonadPlus)
18:13:59 <jadrian> Darius: ok just wanted to make sure I was not confused
18:14:00 <Pseudonym> instance Monad ThisKind where {- ... -}
18:14:10 <Pseudonym> That is, derive MonadPlus automatically without deriving Monad automatically.
18:14:31 <Darius> Pseudonym: If the deriving mechanism can hack it, I don't see why not.
18:14:44 <Pseudonym> Yeah, I suspect if it can't, it's an implementation detail.
18:14:57 * Darius has been thinking about a much expanded PhantomTypes page
18:15:04 <Pseudonym> It certainly needs it.
18:15:16 <CoolPops> Anyone use emacs to write haskell code? I'm having a weird indent problem with a rather simple if construct.
18:15:22 <Pseudonym> Anyway, I need lunch.
18:15:22 <Pseudonym> BBL
18:15:41 <Darius> E.g. I believe Daan's approach to handling OO subtyping (for interfacing in his cases) is just a stylistic application of phantom types, which should probably be mentioned.
18:16:27 <Cale> CoolPops: I use emacs, but I got sick of the "smart" indenting, so I switched it to "simple"
18:16:54 <CoolPops> Cale: ok. Maybe I'll do some reading to figure out how to accomplish this.
18:17:03 * desrt hits cale until he stops using emacs
18:17:24 <CoolPops> desrt: and you use?
18:17:31 <desrt> CoolPops; as if you need to ask
18:17:32 <Cale> CoolPops: (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
18:17:47 <Cale> (rather than the corresponding one, in your .emacs)
18:17:51 <CoolPops> desrt: vim?
18:18:03 <desrt> right
18:18:13 <jadrian> is there any common case where  mplus /= fail ?
18:18:17 <desrt> soon, yi :)
18:18:19 <jadrian> opss
18:18:25 <jadrian> mzero /= fail 
18:18:57 <Darius> jadrian: When you can take advantage of the string provided by fail, but otherwise, I'd consider it ugly for them not to be equal.
18:19:01 <Cale> The STM paper is interesting
18:19:20 <CoolPops> I never quite got the hang of vim, it seemed that I was doing too many keystrokes for simple tasks, anyway, not starting a debate. I know this area is sensitive :)
18:19:29 <Darius> Cale: Depending on what parts you find interesting, read the paper "Practical Lock-Freedom" that I've been propounding of late.
18:19:30 <jadrian> right
18:19:41 <Cale> desrt: see what you think of this - http://research.microsoft.com/%7Esimonpj/papers/stm/index.htm
18:20:11 <Darius> Cale: Though the STM paper does definitely take it further.
18:21:32 <desrt> Cale; sounds expensive.
18:22:32 <CoolPops> Why indent like:
18:22:32 <CoolPops> if x < 0
18:22:32 <CoolPops>     then -1
18:22:32 <CoolPops>         else if x > 0
18:22:32 <CoolPops>         then 1
18:22:33 <CoolPops>             else 0
18:22:41 <CoolPops> hm, that didn't work right, sorry.
18:22:45 <Darius> desrt: Reading "Practical Lock-Freedom" gives a less expensive alternative for some cases and has benchmarking info.
18:23:18 <desrt> i want to go to school at cambridge
18:23:21 <desrt> :)
18:24:35 * desrt wonders if simon PJ is accepting students
18:24:53 <dons> there are summer research scholarships, desrt.
18:25:07 <dons> posted recently to haskell@haskell
18:25:55 * desrt checks that out
18:26:51 <dons> Don Syme posted it on Jan 2
18:26:58 <desrt> thanks.
18:27:24 <desrt> is your name name syme?
18:27:58 <dons> nope ;) "Stewart"
18:28:26 <desrt> ah.  you have to be a grad student for this.
18:28:43 <dons> yup
18:29:25 * desrt 3rdyear
18:29:48 <jadrian> dons: hmmm research during summer?
18:30:07 <jadrian> that could be fun...
18:30:16 <dons> why not? esp. if you live in the southern hemisphere ... then it is winter rsrch!
18:30:25 <desrt> now i have to go back to deciding where to accept a summerjob from :)
18:30:45 <jadrian> dons: oh but I like the idea, I didn't know about these... let me look up that mail, 
18:32:07 <wagle> yargggghh..  a4 paper.. 8]
18:33:03 <jadrian> dons: do you know the subject?
18:33:09 <jadrian> dons: I cannot find it anywhere...
18:33:58 <jadrian> dons: just found this "Summer school in software engineering" but it doesn't look like it
18:34:13 <dons> I think the idea is that you have someone in mind to work with, and they help give you a problem to work on.
18:34:29 <dons> So hacking something into GHC, and writing up a paper on it, for example
18:34:36 <jadrian> damn, I just found out this one is here in Portugal...
18:34:43 <jadrian> and it looks nice too
18:36:01 <jadrian> dons: right
18:37:20 <desrt> jadrian; it's something about 'internship'
18:37:35 <desrt> http://www.mail-archive.com/haskell@haskell.org/msg15848.html
18:39:13 <jadrian> desrt: thanks
18:53:10 <CoolPops> What is the proper method of indenting if statements?
18:53:11 <CoolPops> if x < 0
18:53:11 <CoolPops> ....then 0
18:53:11 <CoolPops> ....else if x > 0
18:53:11 <CoolPops> ........then 1
18:53:11 <CoolPops> ........else 0
18:53:33 <CoolPops> why do I see it like that most of the time? It would seem that too long of an if statement could get out of control.
18:54:30 <CoolPops> why not have the if/else if/else all start on the same column and the then's indented?
18:54:41 <Riastradh> You could just use guards.
18:54:49 <Riastradh> f x | x < 0 = 0
18:54:55 <Riastradh>     | x > 0 = 1
18:54:59 <Riastradh>     | otherwise = 0
18:58:13 <dons> (if .. then .. else ..) is a single expresion, and is subject to the layout rule
18:58:26 <dons> so you usually can't just line it up vertically
18:58:43 <dons> hence the 'then' and 'else' parts are indented 
19:01:41 <dons> you could use explicit { ; ; ; } syntax. but then it would be as ugly as perl
19:02:29 <CoolPops> dons: maybe the layout rule is later in my tutorial. I don't think I've read about it yet, but I'm sure I will run across it sooner or later.
19:04:16 <dons> essentially, the compiler inserts ';' for you, according to whether a code fragment is aligned vertically, or indented, with respect to the previous indentation level
19:04:51 <dons> so, in the case of if \n then \n else being aligned, you'd end up with if .. ; then .. ; etc. which is not valid haskell
19:04:57 <Lemmih> Haha. Template Haskell and wxHaskell can't coexists in the same module (-:
19:05:08 <dons> !?
19:05:21 <dons> why??
19:06:19 <Lemmih> dons: wxHaskell can't be dynloaded under Linux.
19:06:23 <Darius> CoolPops: I find I don't use if-then-else too often.
19:06:32 <dons> Lemmih:: ah, that's right. doh!
19:06:50 <CoolPops> ah, so haskell does not have a "else if" statement, it's actualy a if else ... then if the else is evaluated, it is another if/else statement?
19:07:00 <jdrake> Is there any image processor that allows filters to be written in haskell?
19:07:31 <dons> CoolPops: of course. if a then b else (if c then d else g)
19:07:46 <dons> but of often people with use guards instead
19:08:13 <Lemmih> jdrake: You could write a small haskell loader in C.
19:08:21 <dons> CoolPops: (the parens above are just for clarity)
19:08:28 <CoolPops> dons: ok.
19:08:55 <dons> jdrake: there is actually: panTHeon. it uses filters written in the  Pan language, implemented as a Haskell EDSL
19:09:17 <dons> they are dynloaded as scripts (then as plugins) into a viewer
19:09:40 <dons> like Config files in Yi
19:09:59 <CoolPops> dons: what is Yi?
19:10:37 <dons> panTHeon probably isn't a general-purpose image processor, though. but the filter-via-Haskell-plugins idea is reusable
19:10:55 <dons> CoolPops: http://www.cse.unsw.edu.au/~dons/yi.html
19:11:51 <dons> on the general topic of Haskell filters that are dynloaded, you could even read the hs-plugins paper: http://www.cse.unsw.edu.au/~dons/hs-plugins/paper
19:12:14 <jdrake> I don't know if what I need exists, but I need something that can take an image and make the number of colours less abundant as to make it possible to paint it in a 'paint by numbers' fashion
19:13:06 <dons> photoshop or gimp?
19:13:13 <autrijus> imagemagick.
19:16:42 <Lemmih> I wonder how hard it would be to fix wxHaskell.
19:17:32 <CoolPops> dons, I err'd out on compile, ghc-6.2.2: unknown package name: plugins .. do I need your hs-plugins too I sopose?
19:17:55 <dons> yup. to use yi
19:18:01 <dons> read the README ;)
19:18:10 <jdrake> autrijus, Does imagemagick have such filters that you are aware of?
19:18:11 <CoolPops> ah, README's are for wimps :)
19:18:38 <jdrake> CoolPops, no say it right, 'READMEs are for wimps and commies'
19:18:48 <dons> hmm. well, everyone who doesn't read the README, just ends up asking if they have to install hs-plugins too
19:18:59 <autrijus> jdrake: imagemagick iirc is just a bunch of such filters. 
19:19:03 <autrijus> bbl &
19:19:08 <dons> then they don't read the hs-plugins readme, and wonder why hs-plugins isn't registered by default
19:20:04 <dons> jdrake: what aspect was important: having the filters written in Haskell, or just having the transformation done somehow
19:20:49 <jdrake> the filter is just a tool, I just presumed something exactly like what I was wanting did not exist. I happen to be learning haskell right now however slowly.
19:21:08 <bourbaki> moin
19:21:16 <jdrake> blip
19:22:27 <jdrake> When one puts more importance on the construction of the tool than the function of the tool, the focus on the actual use of the tool is deemed less important and sight can be lost as to why you wanted such a tool to begin with.
19:23:01 <jdrake> I apologize for that awful sentence. It was much longer than anyone should make a sentence. 
19:23:49 <Pseudonym> Clearly you were more focussed on the construction of the sentence than the communicative purpose served by writing it.
19:24:21 <Gahhh> lol
19:24:59 <CoolPops> dons: Boot.hs:287: Variable not in scope: `unloadPackage'
19:27:45 <jdrake> How true, Pseudonym. I am heading in a scientific direction schooling-wise and must focus more on developing my english skills to more precision.
19:28:02 <jdrake> Pseudonym, if I might ask, what is your true name...
19:28:07 <dons> CoolPops: you didn't read the readme ;) you need a recent hs-plugins snapshot
19:28:09 <Gahhh> lol
19:28:37 <CoolPops> dons: hm, I got the hs-plugins snapshot, hs-plugins-20041014? no?
19:28:52 <CoolPops> Download the latest snapshot release: ftp://ftp.cse.unsw.edu.au/pub/users/dons/hs-plugins/hs-plugins-20041014-heatwave.tar.gz 
19:29:06 <SamC> don't tell him your true name he will gain power over you
19:29:38 <dons> that's too early. (in the readme it says) you need one from 20041120 >=
19:29:44 <jdrake> SamC, If he tells me, then I don't have to give up my firstborn.
19:30:06 <CoolPops> dons: arg. sorry. I don't read that often, I skim way too much.
19:30:10 <dons> CoolPops: they're in the nightly snapshots
19:30:38 <SamC> hehe
19:30:55 <Pseudonym> jdrake: Well it's not Pseudonym, but you probably guessed that.
19:33:12 <Pseudonym> My true name must not be uttered lest the terrible power be unleashed on the world.
19:34:20 <CoolPops> hm. reading the README made things compile correctly. that's strange.
19:34:20 <jdrake> If the **AA are to be believed, that terrible power will be freedom from our chains. Say your true name for our liberation!!!
19:34:36 <dons> yay :)
19:35:12 <dons> I really did try to put correct instructions in there :)
19:35:34 <jdrake> Hey do any of you guys do painting? (like on canvas)
19:36:09 <dons> canvas? is that a gui binding.. ?
19:36:23 <dons> :P
19:36:25 <Pseudonym> I think it's an output device.
19:37:03 <dons> ah yes, must be. though it isn't in /dev . hmm.
19:37:33 <dons> /dev/canvas: No such file or directory
19:37:46 <Pseudonym> You need to load the right kernel module.
19:39:17 <jdrake> Oh the Payne!
19:39:57 <Pseudonym> Or, if you're doing an installation piece, oh the pane.
19:40:05 <Cale> Payne-ting?
19:40:24 <dons> CoolPops: did you manage to build yi?
19:40:37 <CoolPops> dons: yup, trying to figure out some of the config stuff now :)
19:40:38 <Cale> jdrake: I used to paint more often
19:40:47 <Cale> It's been a few years since I've painted anything
19:41:09 <dons> CoolPops: what os/arch are you on, btw?
19:41:37 <CoolPops> When I use the examples/AddBind.hs I get a few errors when starting yi ...
19:41:41 <CoolPops> I am debian/i686
19:41:50 <jdrake> Cale, what did you use to paint? (material, paint-type, etc.)
19:41:58 <CoolPops> debian testing, ghc 6.2.2
19:42:13 <dons> AddBind.hs might be out of date. haven't checked in a while. I'll have a look
19:42:34 <Cale> Acrylic on canvas or wood, mostly
19:42:48 <jdrake> What made you choose acrylic?
19:43:04 <Cale> It was cheap and so provided for free by my school :)
19:43:22 <dons> CoolPops: the colour type has changed a couple of days ago. I didn't update the example
19:43:34 <Cale> and it worked relatively well, I enjoyed it
19:43:40 <CoolPops> dons: to what?
19:44:04 <dons> gimme sec..
19:44:15 <jdrake> I am looking to try out some painting, I want to try to take a picture and split it up into a grid and paint in sections. I specifically want to try to reproduce a photo (in a manner) of my grandmother.
19:45:00 <jdrake> Hey CoolPops, do you know what debian's 'SID' stands for? (I was wondering if it is Suck-it-In-Dude)
19:46:04 <Lemmih> jdrake: They use names from Toy Story.
19:46:06 <dons> CoolPops: the colours should be: Style blue darkBlue
19:46:13 <dons> they're defined in Yi/Style.hs
19:46:22 <jdrake> heh how original
19:47:10 <jdrake> "In other news, Debian Unstable-As-Hell was created today, to provide software that is less than 5 years old to those who like to take risks."
19:47:51 <dons> CoolPops: you can pull the patch if you wish
19:48:21 <CoolPops> jdrake: all the names in debian are named after Toy Story, Sid is the child who breaks things.
19:48:33 <Pseudonym> jdrake: That sounds like a good idea, but why not try drawing it in pencil using the same technique first?
19:48:52 <Pseudonym> Going to be easier than painting, and it will allow you to debug the technique.
19:48:58 <CoolPops> jdrake: haha. Actually I'm running unstable quite stably :) Kde 3.3, etc...
19:49:33 <Pseudonym> My wife, who is an art major, tells me that oil is a right pain to use.
19:49:37 <Pseudonym> Though it smells wonderful.
19:50:11 * Pseudonym thinks that acrylic smells like cheap rum
19:51:24 <jdrake> There is an oil paint that can be mixed with water now.
19:51:30 <jdrake> Supposed to be easier to use.
19:51:58 <Pseudonym> It also doubles as a salad dressing.
19:52:15 <Pseudonym> I believe it's the cleaning etc which is the pain.
19:52:17 <jdrake> Pseudonym, stop smoking that stuff - it will make you crazy
19:52:33 <jdrake> Yes, turpentine is not a good thing
19:52:41 <Pseudonym> Don't be silly.  I don't smoke.  I'm just high on life.
19:53:42 <jdrake> Have you tried visiting the IRC channel dedicated to suicide?
19:53:50 <Pseudonym> Uhm... no...
19:54:04 <Pseudonym> Why do you want me to go there?>
19:54:08 * Pseudonym gets paranoid
19:54:51 <jdrake> I am not talking about actual people doing it live, but just having suicide-leaning people present.
19:55:03 <Pseudonym> Ah, I see.
19:55:07 <jdrake> Weird story :-)
19:55:41 <jdrake> Which started with anime, continued into a suicide leaning mentality for about a week, and then got better some how.
19:56:04 <jdrake> That IRC channel is actually what you would call a god-sent
19:56:35 <jdrake> It can bring one back to enjoying life :-)
19:57:22 <Pseudonym> There you go.
19:57:31 <Pseudonym> Better Living Through Anime
19:57:45 <jdrake> The anime caused the suicidal thoughts
19:58:56 * Pseudonym must have been watching the wrong anime
19:59:09 <jdrake> Haibane Renmei 
19:59:18 <Pseudonym> Nope, haven't seen that.
19:59:36 <Pseudonym> The desk next to mine, in my honours year at uni, was occupied by the librarian for the Melbourne Anime Club.
19:59:45 * Pseudonym saw a lot of anime that year
20:00:12 <jdrake> I usually download it
20:00:25 <wli> foolishly, I buy it
20:00:30 <Pseudonym> But this was in 1995, so if it's been made since then, chances are good that I haven't seen it.
20:00:40 <jdrake> Planetes and Uninhabited Planet survive! were particularly good.
20:00:43 <Pseudonym> With a few exceptions.
20:00:57 <jdrake> Future Boy Conan (made like 25 years ago) was very well done too.
20:01:09 <jdrake> I am currently going through Legend of Galactic Heros.
20:01:29 <wli> going through inuyasha here
20:01:32 <Pseudonym> I just got a copy of Gatchaman.
20:01:38 <Pseudonym> Fond memories.
20:02:33 <jdrake> I still haven't watched 2 of the LoGH episodes that CA last released.
20:04:51 <jdrake> How does one possibly break the habit of news site surfing? Especially resisting the urge to goto /.
20:05:39 <Pseudonym> Have a deadline loom.
20:06:05 <wli> jdrake: realizing /. is pure crap suffices
20:06:19 <Pseudonym> Actually it's impure crap.
20:06:24 <jdrake> wli, it doesn't matter - I already realize that but I still go there
20:06:34 <Pseudonym> I use /. as a glorified RSS aggregator.
20:06:37 <wli> I tend to do more websurfing for stuff about the Roman and Ottoman empires.
20:06:55 <jdrake> wikipedia is just as bad
20:07:03 <Pseudonym> wli: You could get lost in the Perseus Project for years, I think.
20:07:14 <wli> Pseudonym: I already am.
20:07:18 <Pseudonym> :-)
20:08:50 <wli> Anyway, it's less depressing to read about people driven beyond madness to kill each other at all costs thousands of years ago than the being driven beyond madness to inflict fates worse than death upon others at any cost going on today.
20:10:56 <jdrake> I am trying to find things other than digital stimulation for myself. Reading fiction books for example, my venture into some simple art is another. Cmd-Q on safari could be considered another, but not sure if I am actually able to do it...
20:11:45 <jdrake> Its done!!!
20:12:57 <Pseudonym> You could start by leaving IRC.
20:13:03 <jdrake> May the Holy Lord Odin protect me as I attempt to turn the infernal machine off into slumber...
20:13:15 <jdrake> Pseudonym, IRC is evil yes
20:14:13 <Pseudonym> Fare well.
20:18:54 <CoolPops> what's the purpose of the id function?
20:19:32 <dons> it returns its argument.
20:19:44 <Pseudonym> It's the identity morphism for each Haskell object.
20:19:49 <mayhem> 'lo
20:19:57 <Pseudonym> G'day.
20:20:08 <CoolPops> how would that be usefull?
20:20:44 <Pseudonym> It's occasionally useful to pass it to other higher-order functions.
20:20:48 <CoolPops> sqrt 5 = 2.23606797749979, id (sqrt 5) = 2.23606797749979
20:22:53 <dons> I sometimes use it with Data.Either.either
20:23:01 <dons> @type (Data.Either.either)
20:23:02 <lambdabot> (Data.Either.either) :: forall c b a.
20:23:02 <lambdabot> 			(a -> c) -> (b -> c) -> Either a b -> c
20:24:12 <Pseudonym> Right, that's a special case of what I said. :-)
20:24:50 <dons> yep. I entirely agree with you :) I was providing a concrete example
20:26:19 <Gahhh> holy monad. it's philosophy night around here...
20:27:25 <shapr> hiya paroneayea 
20:27:51 <shapr> CoolPops: how's it's going? 
20:28:12 <CoolPops> shapr: howdy.
20:28:37 <paroneayea> hey shapr, i just came in here out of curiosity :)
20:28:54 <Pseudonym> Well you came to the right place.  It's a curious session.
20:32:43 <shapr> paroneayea: Want to know something about functional programming?
20:34:05 <paroneayea> shapr: sure
20:34:25 <shapr> Have you used C, Java, PHP, or other procedural language?
20:34:59 <paroneayea> a bit of C
20:34:59 <shapr> here's the Baskin-Robbins one-spoon tastetest - http://www.haskell.org/hawiki/HaskellDemo
20:35:19 <Pseudonym> I don't like Baskin-Robbins, you insensitive clod.
20:35:37 <shapr> Pseudonym: you've been reading too much slashdot!
20:36:00 <shapr> I have this morbid fascination with slashdot. They say the most flagrantly clueless things....
20:36:06 <Pseudonym> 1. Read slashdot.
20:36:07 <Pseudonym> 2. ???
20:36:09 <Pseudonym> 3. Profil!
20:36:12 <Pseudonym> Profit!
20:36:19 <Gahhh> heh
20:36:22 <Gahhh> First post !
20:36:36 <paroneayea> you know what would create hell on slashdot?
20:36:45 <Gahhh> In Soviet Russia, the monad transforms YOU !
20:36:53 <paroneayea> (because it happened to a forum I once ran, and had to shut down)
20:37:01 <Pseudonym> Oooh, do tell.
20:37:02 <paroneayea> when the trolls become obsessed with... not first post
20:37:02 <shapr> paroneayea: useful new technology with no flaws?
20:37:06 <paroneayea> but LAST post
20:37:27 <Pseudonym> Well on slashdot, the topic does close after a week or two.
20:37:28 <Gahhh> they lock the threads after a while
20:37:44 <paroneayea> that does not change the fact that it really creates heck
20:37:55 <Pseudonym> True.
20:38:03 <paroneayea> last post!
20:38:05 <paroneayea> last post!
20:38:07 <paroneayea> last post!
20:38:13 <paroneayea> lp!
20:38:18 <shapr> yow
20:38:59 <paroneayea> or sometimes they would just keep refuting each other.  The logic behind it?
20:39:03 <shapr> Anyway, Haskell is more like writing an equation instead of describing a bunch of different steps.
20:39:15 <paroneayea> "He who has the last word in an argument is right."
20:39:49 <paroneayea> hm, knteresting
20:39:51 <shapr> The way I see it, he who produces useful code that others enjoy is right.
20:39:59 <paroneayea> eep! I gotta get off IRC!
20:39:59 <Gahhh> lol
20:40:09 <paroneayea> my girlfriend is about to kill me for not getting my paper done C_C
20:40:13 <paroneayea> later people :)
20:40:15 <shapr> cya
20:42:40 <Pseudonym> Oh, shapr, I don't know if you heard this, but I discovered a way to solve homework problems automatically in Haskell.
20:43:03 <shapr> oh really?
20:43:19 <dons> I like this :)
20:43:21 <Pseudonym> You give it the homework question, and it produces the answer.
20:43:38 <shapr> How does it work?
20:43:46 <Pseudonym> Basically, it posts a message to haskell-cafe claiming that the following problem can't be solved in the type system: <<insert homework question>>
20:43:52 <shapr> oh, that's true.
20:43:56 <Pseudonym> It then scans the mailing list for responses by Oleg.
20:44:01 <shapr> depressing, but true.
20:44:16 <Pseudonym> Which it then translates back out of the type meta-level.
20:44:29 <dons> that's the tricky part, right? ;)
20:44:50 <Pseudonym> Yeah, unfortunately the resulting code isn't necessarily ideomatic.
20:44:59 <Gahhh> well, all professors should be on the haskell-cafe mailing list anyways.
20:46:38 <Pseudonym> Right.  So actually what you should do is translate into an equivalent problem first.
20:46:49 <Pseudonym> But I haven't worked out how to automate that part yet.
20:46:56 <Gahhh> denotational semantics ?
20:47:17 <Pseudonym> Sadly, few homework problems are posed in a formal language.
20:47:36 <Gahhh> math problems definately are. planetmath has a very active forum.
20:48:07 <Pseudonym> Unfortunately, my scheme can be defeated by a man-in-the-middle attack.
20:50:32 <Gahhh> What's the deal with Wadler's new stuff as discussed on LtU ?
20:51:07 <wli> What's Wadler's new stuff?
20:52:05 <Gahhh> Something called Links. see http://lambda-the-ultimate.org
20:52:10 <wli> hmm
20:52:24 <wli> it doesn't matter if I hoist it up to a new function
20:52:53 <wli> it looks like any time a function call indirectly creates a matrix I have to nail it down to completely monomorphic
20:56:10 <wli> well, fortunately I can do this all in completely monomorphic code anyway
20:57:40 <wli> runST (do { a <- mkMatrix 5 5 (\(i,j) -> recip . fromIntegral $ i + j - 1) :: (forall t . ST t (STUArray t (Int,Int) Double)); readArray a (3,3) })
20:57:42 <wli> that worked
20:58:12 <wli> now I have to go back to Golub and van Loan now that I've given myself several rather large headaches.
20:58:56 <shapr> Gahhh: if it works the way he claims, I'll use it.
20:59:20 <shapr> From what I can he see, he's trying to repeate the success of PHP with added sanity.
20:59:34 <wli> shapr: what's this?
21:00:14 <shapr> Wadler's Links is a domain specific language for web design that integrates databases, continuations, Haskell/ML FP-style, with PHP/C/etc syntax.
21:01:11 <shapr> It doesn't exist yet, but Wadler is the guy who pulled monads from Moggi's theories into Haskell's realities, so I'm willing to give him the benefit of the doubt.
21:01:28 <shapr> Gahhh: what's your username on LtU?
21:02:09 <Gahhh> I dont have one
21:02:29 <Gahhh> I know yours heh
21:02:45 <shapr> obvious, isn't it? :-)
21:03:05 <Gahhh> yeah
21:04:57 <shapr> I'm never sure how well my posts fit into the rest of the discussion there. It's hard drop into a discussion with all those big names and escape feeling small.
21:05:09 <Gahhh> heh
21:06:03 <Gahhh> it helps if you dont know any of those big names
21:06:15 <shapr> But I've read their papers :-)
21:06:55 <shapr> For example, I've been batting about a design for a spoken programming language, do I post it in the typing injury thread? Is that sufficiently interesting?
21:07:22 <Gahhh> heh. yeah why not
21:07:42 <Gahhh> I'd love to be able to talk trash to my compiler...
21:08:00 <shapr> heh
21:08:49 <Lemmih> Greetings, SyntaxNinja.
21:09:01 <SyntaxNinja> hey Lemmih how's code?
21:09:08 <shapr> y0 SyntaxNinja 
21:09:16 <shapr> man, I had a question for you... I wonder what it was.
21:09:21 <shapr> oh yeah! apt-secure!
21:09:28 <shapr> When do we get to rewrite apt in Haskell?
21:10:07 <SyntaxNinja> shapr: ssshh, aj is here
21:11:00 <SyntaxNinja> has anyone ever used gnomemeeting?
21:11:02 <Lemmih> SyntaxNinja: Great. Hacanon is starting to be useful (at least for me).
21:11:21 <SyntaxNinja> what's hacanon again?
21:12:04 <Lemmih> A template haskell library which reads C++ header files and generates the appropriate interfacing code.
21:12:38 <shapr> is aj the author of apt?
21:12:50 * shapr peers curiously at aj 
21:16:52 <SyntaxNinja> Lemmih: oh yeah.  that's cool!
21:18:10 <ozone> Lemmih: how are you mapping the C++ class hierarchy to haskell?
21:18:23 <Lemmih> ozone: It's on my TODO list.
21:18:50 <ozone> Lemmih: ah.  feel free to email me about it, i've done some research in that area
21:19:13 <Lemmih> Currently it can only handle overloading, templates, static methods and garbage collection out of the box.
21:19:24 <ozone> gee, that's all? :)
21:19:30 <ozone> quite an impressive list already
21:19:39 <ozone> what are you using to parse C++?
21:19:48 <Lemmih> gccxml.
21:20:39 <ozone> wow, impressive project
21:22:54 <Lemmih> And it's pretty small. 1.7kloc without the auto generated XML parsing code.
21:23:06 <ozone> that's impressive
21:29:24 <SyntaxNinja> Lemmih: maybe we could use your tool to translate apt from c++ into haskell ;)
21:29:51 <ozone> SyntaxNinja: yes, call the tool haskell-- ;)
21:30:09 <SyntaxNinja> heh
21:31:33 * shapr laughs
21:36:44 <shapr> lambdabot: @quit
21:36:47 * desrt wimpers
21:37:02 <desrt> Loading package base-1.0 ... linking ... done.
21:37:02 <desrt> ghc-6.3: internal error: stg_ap_v_ret
21:37:02 <desrt>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
21:37:02 <desrt>     or http://www.sourceforge.net/projects/ghc/
21:37:02 <shapr> ?
21:37:07 <shapr> neat!
21:37:13 <desrt> the rts gives really bad error messages :P
21:37:49 * SyntaxNinja shakes desrt's hand
21:37:52 <Gahhh> ghc needs a talkback app
21:37:54 <SyntaxNinja> why are you using 6.3?
21:38:01 <desrt> SyntaxNinja; i'm porting it
21:38:22 <desrt> i just finished the linker for ppc64... after fixing a few segfaults i'm left with this problem now
21:38:26 <desrt> gdb doesn't work so well for this one :)
21:38:40 <SyntaxNinja> desrt: carry on :)
21:39:06 <desrt> heh
21:39:16 <desrt> AutoApply.cmm:      foreign "C" barf("stg_ap_v_ret");
21:39:19 <desrt> this looks promising
21:39:22 <SyntaxNinja> heh
21:39:36 <shapr> Do I need to have portmap running?
21:39:43 <SyntaxNinja> grep -r "stg_ap_v_ret" /usr/local/src/fptools/ghc/rts
21:39:45 <SyntaxNinja> ;)
21:39:48 <desrt> shapr; do you use fam, by chance?
21:39:52 <shapr> nope
21:40:01 <desrt> any form of talkd, ntalkd, etc?
21:40:05 <shapr> nope
21:40:05 <desrt> or nfs...
21:40:11 <shapr> not at the moment
21:40:11 <desrt> those are the only things i know that use it...
21:40:49 <SyntaxNinja> my cat has gone insane. he ate my ipod headphones :(
21:40:53 <SyntaxNinja> well, killd then anyway
21:41:05 <shapr> that sucks
21:41:28 <desrt> ok.  it's line 92 of AutoApply.cmm... the default: branch of a switch.  great.
21:42:11 <SyntaxNinja> what's the device for audio input in linux usually?
21:42:20 <desrt> /dev/sound/dsp with OSS
21:43:16 <shapr> hiya SamC 
21:43:25 <SyntaxNinja> desrt: I sent you a msg :)
21:43:33 <SamC> hiya
21:43:38 <desrt> oh
21:44:01 <shapr> Does the COCONUT project work together with the Chalmers guys and Satnam Singh?
21:44:19 <shapr> Seems that signal and circuit simulation is a popular interest in the Haskell world.
21:44:38 <desrt> not as far as i know :)
21:44:47 <desrt> circuit sim would be an interesting use for coconut...
21:45:03 <desrt> although coconut is not designed for fast turn-around times....
21:45:31 <desrt> compiling [whatever you call it] to run on the cluster is planned to take hours-days
21:45:41 <SamC> why is Yi called Yi?
21:45:48 <desrt> with the idea being that you run it on the cluster for a long time...
21:47:42 <shapr> SamC: you know lambda calculus?
21:48:00 * desrt 's ears perk up
21:48:17 <SamC> I have learnt it and then forgotten it :)
21:48:35 <shapr> Y is the 'fork computation' combinator, and I is the 'execute' combinator.
21:49:11 <shapr> Yi is the ultimate recursive name for a piece of software.
21:49:34 <desrt> I as in id?
21:50:15 <shapr> @eval Y I
21:50:27 <lambdabot> out of fuel - use @resume to continue
21:50:28 <desrt> it's I, but it probably won't actually work...
21:50:37 <desrt> since it's an awful lot of I's
21:50:37 <shapr> @get-definition Y
21:50:38 <lambdabot> Y = \f.U(\g.f(U g))
21:50:41 <shapr> @get-definition I
21:50:42 <lambdabot> I = \x.x
21:50:46 <desrt> right.
21:50:55 <shapr> SamC: also, Yi is the name of the source of all righteousness in Confucianism
21:51:24 <desrt> @get-definition U
21:51:25 <lambdabot> U = \f. f f
21:51:26 <SamC> sounds like combinatory logic to me
21:52:02 <desrt> when you goggle "I combinator" it suggests "Y combinator"
21:52:25 <shapr> "I, Combinator" wasn't there a movie about that?
21:52:51 <desrt> Y robot?
21:53:02 <desrt> robot . robot . robot . robot . robot ...
21:53:06 * shapr snickers
21:53:22 <desrt> wait.  i got that wrong
21:53:30 <shapr> I've only seen the previews for "I, Robot" but it looks a lot like a shooting film, not like the I, Robot story
21:53:34 <desrt> it's robot $ robot $ robot...
21:53:36 <SamC> Confucius ruled
21:56:14 <SamC> The Master said, "The gentleman understands yi"
21:56:15 * SamC downloads yi
21:57:40 <desrt> the Y combinator will only "work" (like, in haskell) if you apply it to something that's tail-recursive, right?
21:58:35 <SyntaxNinja> shapr: yeah, i, robot doesn't look anything like the books
21:58:36 <desrt> like if you Y (\f \(x:xs) -> something x : f xs) you're ok
21:58:37 <autrijus> is there docs for this Yi thing?
21:58:45 <shapr> SyntaxNinja: just like starship troopers
21:58:50 <desrt> but the other way around and you're in trouble....
21:59:00 <shapr> I was thinking "metal gorilla powered suits, w00!" and then I saw the previews
21:59:19 <shapr> Anyway, I came up with a better design.
22:00:54 <desrt> IF_DEBUG(apply,  <-- does anyone know how i turn these on?
22:01:17 * SyntaxNinja never read starship troopers
22:01:28 <shapr> Look at the switch on your computer. Flip it from Magic to More Magic
22:01:41 <desrt> heh.
22:03:49 * desrt re#defines
22:04:01 <Pseudonym> Dammit, I really, really want newtype in C++.
22:05:12 <ozone> "Yi" also means text editor in chinese
22:05:14 <ozone> just kidding
22:05:26 * shapr snickers
22:07:49 <Pseudonym> I think all languages should have newtype, actually.
22:08:06 * desrt thinks pseudonym is insane
22:08:18 <ozone> agree.pseudonym
22:08:21 * Pseudonym thinks throat wobbler mangrove luxury yacht
22:08:21 <desrt> you're talking about anonymous types, right?
22:08:37 <Pseudonym> I'm talking about compiler-checked type synonyms.
22:08:47 <desrt> ohh
22:08:51 <desrt> like typedef
22:08:55 <desrt> but better
22:08:58 <Pseudonym> Right.
22:09:06 <desrt> i thought you meant on-the-spot creation of new datatypes
22:09:14 <Pseudonym> It has the performance guarantees of typedef.
22:09:20 <ozone> Pseudonym: you could probably write a template to do it in C++
22:09:22 <Pseudonym> So, say: newtype int my_type;
22:09:29 <Pseudonym> ozone: No you couldn't!
22:09:39 <Pseudonym> Because you could not have any guarantees about how efficient it would be to use.
22:09:46 <Pseudonym> If you newtype an int, you want to be able to store it in a register.
22:10:08 <Pseudonym> If you make a class or struct, you get the type safety, but you have no efficiency guarantees.
22:10:12 <ozone> even with today's C++ compilers?
22:10:22 <Pseudonym> No doubt with some of today's C++ compilers.
22:10:28 <Pseudonym> With GCC, for example.
22:10:32 <Pseudonym> But the language doesn't guarantee it.
22:11:05 <ozone> indeed
22:11:15 <ozone> if you're in a closed environment, you could do it.  but i understand your point
22:11:30 <Pseudonym> One of the very beautiful things about newtype in Haskell is that it's guaranteed.
22:11:42 <Pseudonym> I think.
22:11:52 * Pseudonym checks
22:12:05 <desrt> does newtype basically work like type?
22:12:24 <Pseudonym> More like data, with restructions.
22:12:37 <desrt> er
22:12:56 <Pseudonym> restrictions
22:12:57 <desrt> so it's like a low-overhead transparent data?
22:13:00 <Pseudonym> Here we are:
22:13:01 <Pseudonym> These coercions may be implemented without execution time overhead; newtype does not change the underlying representation of an object.
22:13:09 <Pseudonym> There you go.
22:13:23 <desrt> data Foo = Just Integer
22:13:30 <desrt> but you don't have to say 'Just' all the time
22:13:34 <desrt> and it's faster
22:13:43 <Pseudonym> Well, you do have to say "Just".
22:13:50 <Pseudonym> newtype Foo = Foo Integer
22:13:55 <desrt> oh
22:13:56 <Pseudonym> That's like: data Foo = Foo Integer
22:14:09 <desrt> so it's not transparent
22:14:09 <Pseudonym> Only when you actually construct a Foo, it's operationally a no-op.
22:14:21 <desrt> it's just a special-case of data that's guarenteed to be as fast as not doing it
22:14:25 <Pseudonym> Right.
22:14:29 <desrt> (with no ability to use | as the tradeoff)
22:14:38 <Pseudonym> And only one argument to the constructor.
22:14:48 <desrt> oh.  right.
22:14:57 <Pseudonym> And I think there are also restrictions on existential types in -fglasgow-exts.
22:15:02 <Pseudonym> But that's another topic.
22:15:19 <Pseudonym> It also means that Foo bottom is bottom.
22:15:37 <Pseudonym> If you used data instead, that wouldn't be true.
22:15:40 * desrt thinks about that for a moment
22:15:52 <ozone> Pseudonym: hmm, it only says "may"
22:15:55 <desrt> right.. since you could do certain ops on it without checking the inside
22:16:03 <Pseudonym> Right.
22:16:10 <desrt> well.. wait
22:16:20 <desrt> i was thinking <> but that only works without looking at the inside when you have |
22:16:26 <Pseudonym> ozone: Yes, I see that.
22:16:30 <desrt> but certainly, left-side matching....
22:16:40 <Pseudonym> The report also explicitly says: Unlike algebraic datatypes, the newtype constructor N is unlifted, so that N _|_ is the same as _|_.
22:16:43 <desrt> (which is actually a non-op in the case of a data type with only a single constructor)
22:17:19 * Pseudonym is trying to work out a way to implement it that doesn't turn the coercions into a no-op but does guarantee that N bottom is bottom.
22:17:26 <Pseudonym> Can't think of one.
22:17:50 <Pseudonym> I guess if the constructor were strict.
22:18:06 <Pseudonym> So actually, newtype Foo = Foo Integer
22:18:14 <Pseudonym> is equivalent (more or less) to: data Foo = Foo !Integer
22:19:08 <Pseudonym> Anyway, in summary: newtype rocks, and I want it in the other languages that I use.
22:21:38 * desrt hugs Pseudonym 
22:22:11 <Pseudonym> Awww, thanks.
22:24:16 <SyntaxNinja> is there a column-based diff tool? especially one built into emacs?
22:24:20 <SyntaxNinja> I have two long lines I want to diff
22:24:55 <Pseudonym> The latest tkdiff does that.
22:26:39 <shapr> M-x ediff
22:26:42 <shapr> then hit |
22:26:53 <shapr> oh, column based I don't know
22:32:10 <SamC> how long is darcs gonna take to build? shall I go get a cup of tea?
22:33:17 * SamC goes anyway
22:34:38 <desrt> s/darcs/stage1+2/
22:41:21 <Pseudonym> Nytol.
22:52:22 <SamC> darcs failed :(
22:53:59 <SyntaxNinja> parse (prettyPrint (parse p)) == parse p is a great unit test :)
22:56:01 <SyntaxNinja> I caught 3 bugs that way :)
22:56:05 <SyntaxNinja> SamC: won't build?
22:56:09 <ozone> SamC: why not just use a binary?
22:57:38 * SyntaxNinja builds darcs pretty often :)
22:58:11 <SamC> Failed to download URL
22:59:50 <SyntaxNinja> what error?
23:00:13 <SamC> if you just read the docs, it says make sure you have version 7.11.0 of libcurl installed
23:00:29 <SamC> libcurl error code: 52
23:00:44 <SyntaxNinja> SamC: what platform?
23:00:56 <SamC> Mac OS X
23:01:14 <ozone> oh
23:01:16 <SyntaxNinja> I actually got a libcurl error yesterday on a 'get' on debian
23:01:17 <ozone> yeah, i think i remember that
23:01:29 <ozone> SamC: it has something to do with curl, not darcs
23:01:29 <autrijus> SyntaxNinja: how is parse usable as unit testing?
23:01:41 <ozone> curl isn't configured right for mac os x, it has the wrong arch or something like that
23:01:58 <ozone> http://abridgegame.org/darcs/manual/node3.html#SECTION00320000000000000000
23:02:00 <ozone> there you go :)
23:02:17 <ozone> (and yeah, removing the -arch i386 in curl-config fixed it for me)
23:02:27 <SyntaxNinja> autrijus: checking that if you pretty print it and parse it again, you get the same value
23:02:33 <autrijus> ahhh.
23:06:02 <SamC> now I get:  darcs failed:  Invalid repository:  http://www.ScannedInAvian.org/repos/yi/
23:06:14 * shapr checks the repo
23:06:34 <shapr> I've just been doing some server admin, so I might have broken something.
23:07:04 <shapr> works for me
23:07:22 * SyntaxNinja checks too
23:07:33 <SamC> thanks for checking, I'll figure this out later, gotta go
23:08:12 <SyntaxNinja> wfm
23:08:17 <shapr> ?
23:08:32 <shapr> oh
23:24:54 <desrt> nite nite, functional people
23:25:00 <shapr> g'night ryan
23:46:41 <basti_> hi
23:46:41 <shapr> guten morgen basti_ 
23:46:59 <basti_> jaja.
23:47:17 <basti_> woke up cos my gf wanted me to encounter the plumbers "decently dressed"
23:47:30 <shapr> I woke up because our five cats were bored.
23:47:49 <shapr> That was 5:30am
23:47:56 <shapr> I wish they'd get bored in the evenings.
23:48:05 <basti_> i wont comment on this?
23:48:16 <SyntaxNinja> I forgot to put my clothes in the dryer, now I have to stay up another hour :(
23:48:36 <shapr> It's amazing to me that bea can sleep through five bored cats, but I can't
23:49:34 <SyntaxNinja> I can't believe my cat destroyed my headphones
23:49:56 <basti_> we had cats at home when i was young.
23:50:15 <basti_> taught me: no matter how cuddly and cute they are, they are little beasts.
23:50:19 <SyntaxNinja> now I feel that nothing is safe
23:50:45 <SyntaxNinja> basti_: yes indeed.  shapr has one cat in particular that is actually a rather large beast
23:50:47 <shapr> My office is a non-cat room because our oldest male cat was marking my computer with urine.
23:50:53 <SyntaxNinja> I tried to pet it sometimes, as a joke
23:50:54 <basti_> once our cat woke me by biting in my large toe
23:51:16 <shapr> SyntaxNinja: did the wounds heal cleanly? ;-)
23:51:26 <SyntaxNinja> shapr: I think I'm ok now
23:51:33 * shapr snickers
23:52:13 <shapr> SamC_: you're back! did you fix darcs?
23:52:35 <SamC_> It's working now
23:52:44 <SamC_> and no
23:53:06 * SamC_ shrugs
