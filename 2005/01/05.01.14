00:04:28 <Itkovian> meuning
01:56:56 <Matt-W> moin
01:59:32 <Matt-W> If I have a FiniteMap with some elements in it, and a list of keys, and I want to remove every element from the finiteMap which has a key in the list of keys, is there some sort of list sequencing function already defined I can use to do it?
01:59:50 <Matt-W> Something says to the back of my mind 'list monad, list monad'
02:00:11 <Matt-W> but I think it's lying to me
02:02:20 <Itkovian> maybe it should talk to the front of your mind, no?
02:02:35 <pesco> Matt-W: I think it is.
02:02:46 <Matt-W> Itkovian: this is a problem sometimes :-)
02:03:20 <pesco> @type Data.FiniteMap.delListFromFM
02:03:22 <lambdabot> Data.FiniteMap.delListFromFM :: forall elt key.
02:03:22 <lambdabot> 				(Ord key) =>
02:03:22 <lambdabot> 				Data.FiniteMap.FiniteMap key elt
02:03:22 <lambdabot> 				-> [key] -> Data.FiniteMap.FiniteMap key elt
02:03:28 <pesco> Is that what you're looking for?
02:03:32 * Matt-W blinks
02:03:36 <Matt-W> So how come I didn't notice that?
02:03:44 * pesco shrugs.
02:03:49 <Matt-W> thanks
02:03:52 <pesco> ;-)
02:03:52 * Matt-W feels very stupid now
02:03:57 <pesco> np.
02:04:38 <pesco> Matt-W: Where are you from, greeting with "moin"?
02:04:57 <Matt-W> pesco: England, but I spend too much time in another channel where it's commonplace
02:05:12 <pesco> I see. :) Which channel is that?!
02:06:40 * pesco shrugs.
02:07:33 <Itkovian> #how_english_soccer_players_sometimes_miss_penalties ?
02:07:38 <Itkovian> :-)
02:08:05 <pesco> ,:-)
02:09:12 <pesco> OK, I'm gone again. See you all.
02:10:42 <Itkovian> bye
02:10:54 <Itkovian> Matt-W: no offense intended!
02:11:17 <Matt-W> pesco: #SPORKS, the channel semi-officially-attached to User Friendly
02:11:24 <Matt-W> Itkovian: none taken, I can't stand soccer anyway
02:14:20 <joao> Good morning
02:16:03 <Itkovian> hehe
02:18:05 <Matt-W> My boss thinks I'm mad trying to write this in Haskell, but it's nothing he didn't already know
02:18:34 <Itkovian> at least he lets you have a go at it!
02:18:52 <Itkovian> I doubt many Belgian employers would allow such a thing ...
02:20:35 <juhp> 10th time lucky? (to self)
02:20:51 * juhp builds gtk2hs one more time...
02:24:02 <Matt-W> Itkovian: it's not for work, unfortunately
02:24:47 <joao> Matt-W, maybe if you do a good job he will consider using Haskell in the future :P
02:25:53 <Itkovian> idd
02:26:28 <Matt-W> joao: that seems unlikely
02:26:48 <Matt-W> woot, that works
02:26:55 <Matt-W> now for the next trick
02:54:44 <Itkovian> anybody knows any algorithms that allow tho detect when a characteristic, e.g. IPC has changed sufficiently over time? Change can both be gradual or abrupt ...
02:55:04 <Itkovian> time between measurements is about 1 - 10 ms ...
02:55:09 <Itkovian> atm, that is.
02:58:46 <adept> Itkovian: define "sufficiently" ?
03:48:27 <juhp> oh, hmm, ghc-pkg seem to allow removing pkgs which are required by another pkg...
03:49:03 <musasabi> juhp: that is good.
03:49:25 <musasabi> juhp: think about this. A depends on B. you want to upgrade B.
03:49:37 <musasabi> juhp: and upgrade == delete + install.
03:50:14 <juhp> well, true, though there is -u for that
03:50:54 <juhp> well it could print a warning or something I suppose... :)
03:52:05 <juhp> note that until the new B has been installed though, ghc can't be run
03:53:35 <musasabi> point
04:20:24 <juhp> phew
04:20:44 * juhp uploads gtk2hs-0.9.7pre-0.20050114 to Fedora Haskell
05:01:16 <Lunar^> Wolfgang did it!
05:01:34 <Lunar^> Position Independant GHC generated binary!
05:01:37 <Lunar^> so cool
05:04:13 <juhp> wow
05:04:48 <musasabi> Is this susceptible to a DOS attack (with long lines): ?
05:04:49 <musasabi> hGetLines h max = hGetContentents h >>= (\s -> return (map (take max) (lines s))
05:04:55 <juhp> so can we build shlibs soon too?
05:05:14 <arjanb> what does position independant mean?
05:06:38 <araujo> It means that it can be loaded in different addresses.
05:07:05 <Lunar^> arjanb: Currently, all GHC produced binary must be statically linked 
05:07:11 <araujo> well, it is at least the general idea behind the well-known concept :-)
05:07:27 <arjanb> i see
05:07:38 <Lunar^> arjanb: Because GHC RTS and libraries is quite big, a simple hello world produce a full 800k binary
05:07:52 <Lunar^> arjanb: With PIC, we could reduce that a *lot*
05:08:07 <Lunar^> arjanb: like libc for unix systems, finally
05:08:27 <Philippa> only having to load the RTS once for hOp seems a good thing to me
05:08:28 <Lunar^> juhp: What do you mean by shlibs?
05:08:32 <araujo> Lunar^, so, there is already support for PIC in GHC?
05:08:50 <araujo> Philippa, do you use hOp?
05:08:52 <juhp> Lunar^: sorry, shared libs
05:09:09 <Philippa> araujo: nope, I might have a play around once there're disk drivers etc
05:09:10 <Lunar^> Philippa: Yeah, though there is semantic and security problem because the RTS is the kernel
05:09:15 <araujo> juhp, yes, it helps doing that.
05:09:39 <Philippa> yeah, you end up with per-thread security settings and stuff I imagine
05:09:48 <Lunar^> araujo: Wolfgang finally made it possible, currently on Darwin/PPC and Linux/PPC
05:10:00 <araujo> Lunar^, ah ok.
05:10:00 <Philippa> seems to me you'd also have pretty good multithreaded IO though
05:10:15 <Darius> hOp?
05:10:20 <Lunar^> Philippa: Andrew Tolmach added separate binary space in House
05:10:28 <araujo> Philippa, ive read about it, ive been thinking to give a try.
05:10:36 <Lunar^> Philippa: but that currently allows to run C a.out code :)
05:10:53 <Lunar^> Philippa: btw, I'm truly waiting for GHC 6.4 to work on hOp again
05:11:02 <Lunar^> Philippa: switching all threaded stuff to use STM
05:11:21 <Lunar^> Philippa: One of the current design flaw is that you can't have a select with Chan
05:11:30 <araujo> You also hOp through qemu right?
05:11:30 <Lunar^> Philippa: STM made that possible :)
05:11:40 <araujo> s/also/use
05:11:49 <musasabi> Lunar^: how are you going to have timeouts with STM?
05:11:51 <Lunar^> araujo: Google for House + hOp + haskell, you'll find ready to run images
05:12:00 <araujo> Lunar^, interesting.
05:12:15 <Lunar^> musasabi: I've followed the thread on the lists... That's an interesting point
05:12:34 <musasabi> Lunar^: although I think I have a solution for that/
05:12:45 <Itkovian> how does one re-apply a darcs patch after undoing it?
05:12:56 <Lunar^> musasabi: Though an OS need high resolution timeout, thus I think that will need RTS hacking
05:12:58 <musasabi> Maybe I should just code it up and send to the list.
05:13:09 <Lunar^> Itkovian: there is a #darcs channel :)
05:13:20 <Itkovian> ah sorry
05:15:20 <Itkovian> hmm ... they're not very talkative :-)
05:16:04 <musasabi> Is there a priority queue implementation packaged with GHC?
05:16:12 <Lunar^> musasabi: If you want to think about it, I would gladly be your rubber chicken
05:16:36 <Lunar^> musasabi: They are in DData IIRC
05:16:57 <araujo> ''Operating System: An operating system is a collection of things that don't fit into a language. There shouldn't be one.'' â€“ Dan Ingalls, in an article in Byte Magazine, 1981.
05:17:10 <musasabi> Lunar^: I'll try to get some code today and post the link.
05:17:36 <Philippa> araujo: did he have experience with anything other than home micros at the time?
05:17:42 <Lunar^> araujo: do you have an URL for this?
05:27:06 <samc_> Itkovian, iirc, if you unrecorded a patch you can't rerecord it
05:27:18 <Itkovian> ah well, too bad.
05:27:24 <Itkovian> cvs update it shall be then :-)
05:27:37 <Itkovian> i rolled back ... 
05:27:50 <Darius> Dan Ingalls is close but not quite there: cooperation between independent programs isn't something a 'language feature' could fix, unless we require all programs to be written in the same language.
05:28:18 <Itkovian> heh, let me mail that to some of my colleagues in Brussels :-)
05:28:22 <Lunar^> Darius: That's hOp assumption :)
05:28:25 <samc_> then you can
05:28:27 <Lunar^> or one of :)
05:29:24 <araujo> Philippa, Lunar^  http://minnow.cc.gatech.edu/squeak/1762
05:29:45 <Darius> An operating system should provide safe multiplexing of the hardware at the lowest level possible and nothing more.
05:29:50 <samc_> rollback doesn't delete the patch
05:29:55 <araujo> Wow, House seesm going very well.. this haskell OS project seems going pretty well.
05:31:36 <Lunar^> araujo: neither House nor hOp should be practical to anything currently
05:31:50 <Lunar^> araujo: There's a lot of research to make before fixing anything, IMHO
05:32:00 <Lunar^> s/fixing/fixating/ ?
05:32:56 <Darius> Lunar^: For what I think you mean, fixing is the right word but it is also fairly ambiguous.  If I'm not mistaken, an American idiom would be "before anything is set in stone".
05:33:24 <Lunar^> Darius: thanks :)
05:34:24 <araujo> Lunar^, but i thought it was even more inmature than it is. only an ideamainly, but i see you already can test an image., i think i'll give a try to this.
05:34:48 <Lunar^> araujo: Haskell is a *very* powerfull language
05:35:01 <araujo> I highly agree.
05:35:08 <Lunar^> araujo: Once you really know what you want, there's nothing stopping you
05:35:16 <Lunar^> araujo: The whole mouse driver is 45 lines long
05:35:31 <araujo> hah, terrific
05:36:04 <Matt-W> Does anyone know anywhere I can get a ghc 5.04 or greater package for Debian Woody? The only place I've found through searching no longer exists
05:36:28 <samc_> Darius, I'm trying to remember a system which did just what you said an os should do, it had an 'x' in it I think, do you have any idea as to what I might be thinking of?
05:36:55 <Lunar^> araujo: So, we could all start writing bad and ugly code as I did, but if the idea is to use a fresh language to be able to think about new concepts, there's still a lot of things to think about before writing any code
05:37:04 <samc_> Lunar^, now I see the point!
05:37:23 <Lunar^> samc_: Please enlighten me, then :)
05:37:56 <Lunar^> I need to write S^2 to see if they think a thesis could be possible around hOp, and where...
05:38:57 <araujo> Lunar^, yes, that is why i thought there wasn't anything "yet" to test with hOp , not something like this.
05:39:01 <araujo> That usually takes time.
05:39:28 <araujo> Since when it has been going the hOp development?
05:39:53 <Darius> samc_: Exokernals, Xos.
05:40:13 <Lunar^> araujo: We already had the micro-kernel :) That was just a matter of realizing it
05:40:14 <samc_> yes, that's it, thanks
05:40:29 <araujo> Lunar^, are you hOpdeveloper?
05:40:41 <Philippa> Lunar^: it seems to me that if we can assume apps are GCed, funky things can be done with memory management more generally
05:40:54 <Lunar^> araujo: sebc had the idea since quite some time, though you can dig through the log I was writing when really working on it
05:41:31 <Lunar^> Philippa: Yes, but you need to tell the GC about security and paging at some points
05:41:48 <Lunar^> Philippa: This open a whole new field to explore on GC though
05:42:04 <Philippa> strictly speaking it's not /new/, the old lisp machines got there first - but yeah
05:42:18 <Darius> Well, Philippa got to it first.
05:42:32 <Lunar^> Philippa: thanks for pointing out 
05:43:01 <Darius> I imagine OSes with support for transparent persistency have similar issues.
05:43:15 <Lunar^> Matt-W: have you looked on HaWiki ?
05:43:26 <Lunar^> Darius: I've looked at EROS a bit
05:43:42 <araujo> yes, Lisp, Smalltalk were good projects exploring many areas, but i don't know what happened (hey, i haevn't been born by that time) everything was abandoned.
05:44:30 <Lunar^> Darius: which is implementing the really interesting idea that the whole memory addresses hard disk, and page faults actually just read and write it
05:44:31 <Philippa> Haskell does have the further advantage of static typing
05:45:09 <araujo> I got an interviwe somewhere, where Alan Kay says that it is amazing they needed to use a 70's language (smalltalk) to design innovative applications (opencroquet)
05:45:10 <Lunar^> Darius: like if your whole hard disk was a swap space
05:45:31 <Lunar^> Darius: but, GCing a 40 Gb harddisks? ... see?
05:45:42 <Philippa> A word comes to mind
05:45:43 <Itkovian> araujo: that sounds like his speech at OOPSLA this year ...
05:45:46 <Philippa> the word is "eww"
05:46:13 <Philippa> as in, "going to run slow as hell"
05:46:28 <Matt-W> Lunar^: no, I haven't, I shall go and poke around
05:46:31 <araujo> Itkovian, yes, he has been giving a similar speech in many ocassions.
05:46:36 <Philippa> maybe if you can keep whatever passes for your allocation tables cached in memory that's different
05:46:45 <Lunar^> Matt-W: http://haskell.org/hawiki/DebianUsers
05:47:01 <araujo> It is a big "concern".
05:47:08 <Philippa> but doing that for the entire HD seems a painful cost given that available HD space tends to grow faster than available RAM
05:47:59 <araujo> And i think it is true, we have been evolved better through hardware design, but not much about software design, we always end up with a layer over the hardware to abstract things in the old fashion ways.
05:48:24 <araujo> we keep using 60's 70's software design appraoachs.
05:48:25 <Philippa> the fact OO's still all the rage is pretty sad
05:48:55 <edwinb> OO is the holy grail of programming! Apparently.
05:49:07 <Lunar^> Philippa: key idea is that you don't need to *write* or *read* anything explicitely
05:49:28 <Lunar^> Philippa: And that'll be very well suited for a pure language 
05:49:46 <araujo> OO has been saddly abused also.
05:49:47 <Philippa> I would like explicit writes any time I want to guarantee persistency
05:49:53 <samc_> Lunar^, checked out Mungi, that would take some GC
05:49:59 <Philippa> unless you plan to do things the other way round?
05:50:00 <samc_> that approach
05:50:10 <Lunar^> Philippa: Another aspect is that you get very fast boot with the computer in the same state as you had turned it off
05:50:20 <Philippa> fair enough if that's what you're going for, I guess
05:50:27 * araujo goes and emerge qemu
05:50:30 <Philippa> what do I do when I have data that I know is very definitely transient?
05:51:18 <Lunar^> Philippa: good point. :) I'm not settled on anything, but it seems an interesting approach
05:51:20 <Darius> Philippa: Nothing.  The only issue I see is security (and performance but that's a gimme)
05:52:14 <Lunar^> Philippa: EROS was in C with malloc and free, so nothing like GC problems
05:55:53 <Darius> Philippa: For guaranteed persistence the OS exports a 'checkpoint' operation, for security or (manual) performance the OS exports some unbacked malloc.
05:56:36 <Philippa> so basically we have newIORef, possibly newTransientIORef and ioCheckpoint
05:58:21 <Philippa> I assume IORefs are owned by their threads? How about MVars or their equivalent?
05:59:04 <samc_> how do you folks organise papers you have downloaded (or kept references to)?
05:59:14 <Philippa> badly :-)
05:59:24 <musasabi> seems that the whole timeout mess is even more complicated than I thought.
05:59:26 <Philippa> (I have a directory full of papers, then subdirs full of shortcuts or symlinks)
05:59:33 <edwinb> Wait until I'm bored then print and file them.
05:59:55 <samc_> Philippa, me too and I'm getting sick of it
06:00:43 <Philippa> musasabi: oh *fun*
06:01:05 <Darius> samc_: Extremely badly.  I eventually downloaded a bunch of papers on DBs and text-indexing and made an inverted index of them.
06:01:56 <edwinb> Someone must have written a utility for this kind of thing...
06:02:19 <edwinb> if it could cross reference papers, conferences, journals, etc and spit out bibtex that'd be great...
06:02:53 <Darius> I want to know how citeseer works.
06:03:14 <musasabi> I think for an OS using something like L4 for protection and letting things mess with themselves inside the processes to be enough.
06:03:31 <Darius> And when Google Desktop supports PDFs and PSes, that should effectively solve the problem for me.
06:03:42 <samc_> you mean how it extracts authors, abstracts etc.?
06:03:49 <Darius> samc_: Yes.
06:04:57 <samc_> given that it makes mistakes, it musn't work in some easy way
06:05:00 <musasabi> GHC RTS is not very suitable for an OS core.
06:05:08 * samc_ found it hard to put that
06:05:26 <musasabi> I think e.g. mozart would do better.
06:05:42 <musasabi> But this is not specific to Haskell - just GHC.
06:05:44 <araujo> musasabi, so building Haskell servers on top of L4?
06:06:04 <samc_> os x indexes the contents of some pdf/ps files
06:06:06 <musasabi> araujo: yes.
06:06:17 <araujo> musasabi, definetly a good project.
06:07:02 <araujo> But ive noticed that L4 is something difficult to grasp at.
06:07:58 <musasabi> I had a system build from plan9 C libs doing quite nice stuff on top of it. (but nasty licensing issues make impossible to releasy anything)
06:08:08 <musasabi> *se
06:09:05 <musasabi> but yes, it can be nasty to debug. 
06:09:17 <araujo> Sounds cool.
06:09:31 <araujo> musasabi, was it a thesis or something, or just a hobby?
06:10:15 <araujo> musasabi, and, why plan 9 C libs?
06:10:41 <musasabi> araujo: it was to test certain concepts and whether they could be implemented on top of L4.
06:11:00 <Lunar^> edwinb: Isn't it scholar.google.com? :)
06:11:02 <musasabi> araujo: they were quite suitable for the purpose (and hacking them was quick)
06:11:16 <Lunar^> musasabi: Why do you they that?
06:11:31 <araujo> musasabi, really?, are they in some manner easy to hack than glibc or loibc?
06:11:34 <Lunar^> musasabi: GHC RTS lacks a good scheduler, but I might work on this for the next six months
06:11:43 <araujo> s/easy/easier
06:11:47 <Lunar^> musasabi: s/they/say
06:12:20 <musasabi> araujo: well I wasn't after *nix semantics and it was quite small.
06:12:35 <araujo> Ah ok.
06:12:36 <edwinb> lunar^: Fair point, I haven't played with that yet!
06:12:38 <musasabi> Lunar^: the lack of protection domains / containers.
06:12:53 <araujo> you were after something non-unix-bloated :-)
06:13:19 <araujo> musasabi, haven't you thought to do something similar with haskell?
06:13:54 <Lunar^> musasabi: Could you give me references on this, or explain a bit what it means?
06:14:18 <musasabi> araujo: if time would be an infinite resource.
06:15:30 <musasabi> Lunar^: Mainly I mean that we cannot run untrusted haskell inside the rts. 
06:15:46 <musasabi> of course one can argue that this is true for any nativecode system.
06:16:47 <Lunar^> musasabi: I don't know how far Andrew Tolmach went into this. But I'm sure he has some idea
06:16:57 <musasabi> so in effect to get trusted code we would need bytecode and then JIT for performance - which is a very large project.
06:17:30 <Darius> samc_: Citeseer does (now) export the metadata
06:17:38 <araujo> musasabi, hah, ok.
06:19:14 <musasabi> Lunar^: consider e.g. the function "fib :: Int -> Int" - can that be evaluated safely ?
06:21:17 <Lunar^> musasabi: It needs seperate adress space
06:22:57 <musasabi> Lunar^: yes.
06:23:06 <musasabi> but with that even C is safe.
06:23:37 <Lunar^> musasabi: I'm sure that Simon Marlow would be intersted in finding another cute solution for that problem :)
06:23:52 * Lunar^ is typing really bad today :(
06:24:21 <samc_> Darius, only for some (few) papers though ne?
06:25:40 <musasabi> of course there is a middle way.
06:25:58 <musasabi> trust that the compiler generates safe code and just check the external references made by the code.
06:26:13 <musasabi> and enforce resource limits.
06:27:25 <musasabi> but this may dictate slower code than with JIT.
06:27:54 <musasabi> although e.g. with array indexing branding creates safe solutions inside haskell.
06:28:13 <Lunar^> yes
06:31:36 <Lemmih> shapr: Ping.
06:55:21 <samc_> Darius, "The full source code of CiteSeer is available at no cost for non-commercial use."
06:55:28 <samc_> that's cool
06:57:54 <Philippa> it seems to me a reasonable solution might be to encrypt code verified by the local OS such that in the future it only needs to verify that it's already been verified
06:58:05 <Philippa> that way you don't JIT, you just do local codegen
07:03:08 <musasabi> Philippa: that does not address mobile code very well. (of course you can sign binary code)
07:12:17 <Philippa> musasabi: just type-check and interpret?
08:09:07 <shapr> Lemmih: pong
08:31:30 <shapr> suddenly I wonder if SPJ has seen all the great IRC quotes we've written up about him...
08:31:36 <shapr> I think I'll send him an email containing them.
08:33:25 <desrt> cc: me please :)
08:33:50 <Itkovian> I'm off ... ttyl
08:33:55 * edwinb wonders if he can find these on the web somewhere...
08:34:34 <Darius> shapr: Are you talking about just the ones in the QuotesPage or do you have some collection somewhere else?
08:34:46 <shapr> just the ones on the QuotesPage
08:36:24 <samc_> what quotes page?
08:36:35 <samc_> nm
08:40:28 <musasabi> @wiki QuotesPage
08:40:28 <lambdabot> http://www.haskell.org/hawiki/QuotesPage
08:40:54 <Lunar^> shapr: You should CC haskell-cafe :)
08:43:14 * Lunar^ didn't saw the one about Foundation :)
08:43:16 <Darius> Searching the QuotesPage for SPJ or Simon only turns up two quotes
08:44:55 <shapr> But what about the quote from Sarah Peyton Jones age 11?
08:45:03 <edwinb> There is a "Sarah Peyton Jones"...
08:45:07 <edwinb> heh
08:45:15 <edwinb> I'd love to know more of the context of that one...
08:45:29 <shapr> ask SyntaxNinja
08:45:35 <edwinb> (being a functional programming go player, that is...)
08:45:46 <shapr> He was trying to teach her how to play go.
08:45:47 <Lunar^> shapr: Have you seen Wolfgang's last commits ?
08:45:55 <Lunar^> shapr: -fPIC :)
08:46:01 <shapr> haha!
08:46:11 <shapr> It didn't end up being -fThaller?
08:46:13 * shapr grins
08:46:16 <desrt> no :P
08:46:25 <Lunar^> :))
08:46:44 <desrt> we also have support for shared libraries on a handfull of platforms now
08:47:10 <desrt> so you don't have to link all of HSbase and the RTS into your binary
08:50:17 <shapr> cool!
08:50:33 <shapr> does that work in cvs for linux/x86?
08:50:41 <Lunar^> shapr: buy a ppc :p
08:50:56 <desrt> only darwin and linux/ppc/ppc64, i think
08:50:57 <samc_> heh, I like the duel quote
08:51:18 <Lunar^> GHC 6.4 should be called 7.0
08:51:20 <desrt> ok.  no linux/ppc... only linux/ppc64
08:51:22 <Lunar^> really, really
08:51:25 <tromp>  hi, haskellers and go players
08:51:36 <Lunar^> desrt: It just a matter of a few #ifdefs, IMHO
08:51:38 * desrt is probably going to have to fix that
08:52:20 <desrt> half my now consists of wolfgang telling me "hey... we have this cool new feature on darwin... get your act together on the linux port"
08:52:27 <desrt> *half my life
08:53:00 <shapr> greetings tromp 
08:53:16 <Lunar^> desrt: I would be interested in doing that, at least for some time
08:53:23 <Lunar^> desrt: Wolfgang is truly amazing IMHO
08:53:28 <shapr> Lunar^: why 7.0?
08:53:31 <desrt> ya.  he's pretty smart
08:53:41 <shapr> He's really nice too.
08:53:42 <Lunar^> I learn lately that sebc and him met at IOI
08:53:48 <desrt> shapr; not really.  he's sort of evil
08:53:54 <shapr> I met him at ICFP03
08:53:56 <desrt> i'm convinced he's trying to kill me
08:53:56 <Lunar^> Wolfgang blasted everyone for two or three contests
08:54:30 <Lunar^> shapr: new back-end, GADT, STM, PIC and I'm sure that I forget things
08:54:53 <shapr> Wolfgang did STM?
08:54:59 <desrt> Lunar; some new ports
08:55:06 <shapr> neato
08:55:34 <desrt> shapr; he was listing what's new in 6.4
08:55:39 <shapr> ohh
08:55:46 * shapr tries to refocus
08:56:23 <MegaMonad> Of course, howdy isn't used for cgi and scripting go together...
08:56:35 <shapr> MegaMonad: Wolfgang Thaller?
08:56:36 <MegaMonad> shapr: Thaller uses th too.
08:56:41 * shapr laughs
08:56:44 <edwinb> MegaMonad, do you want to know the rules of go too?
08:56:45 <MegaMonad> edwinb: Or i should do a 'bayesian google' that night and i passed the code, send it to me (and it seems like it might be tempted to have clear rules about when you make a .deb somewhere?
08:56:51 <Lunar^> desrt: Anyway, if you happen to work on adapting Wolfgang last commits to Linux/PPC I'll be glad to do screen -x pair programming, if it's ok for you :)
08:57:10 <desrt> Lunar^; hm.  i've never done that before
08:57:17 <shapr> speaking of which, I want to do some virtual pair programming, but I can't find any good way to do it with emacs.
08:57:19 * shapr grumbles.
08:57:23 <Lunar^> shapr: screen -x
08:57:24 <shapr> I guess I should just fix Yi.
08:57:28 <CosmicRay> shapr: have you tried screen?
08:57:45 <shapr> yes, but I have the most bizarre configuration possible.
08:57:58 <desrt> Lunar; all of our dev boxes are pretty heavily firewalled :/
08:58:27 <CosmicRay> shapr: investigate ytalk then, if you can bypass a firewall
08:58:38 <CosmicRay> I *think* it can do what you want
08:59:00 <shapr> I'm still not completely sure what I want.
08:59:01 <Lunar^> desrt: We could work on poivron.org, or I don't know.. it's just that I know I will not be able to enter this part of the RTS alone
09:00:15 <Lunar^> desrt: and I'll be happy to watch over stupid mistakes we all do
09:01:29 <Lunar^> desrt: maybe it's a bad idea, I don't know...
09:01:54 <desrt> just sort of seems weird...
09:02:06 <desrt> i don't really code like that, i guess?
09:02:56 <desrt> i do a lot of headscratching and talking out loud... which only really works non-virtually
09:03:17 <Lunar^> I understand :)
09:04:25 <samc_> wuss
09:05:33 <Lunar^> desrt: Maybe I should just watch the diffs closer
09:08:11 * samc_ actually knows what you mean
09:08:12 <CosmicRay> shapr: you could also use vnc
09:08:39 <desrt> Lunar; hmm.  i started out by porting the rts....
09:09:37 <CosmicRay> shapr: check out apt-get install linuxvnc
09:12:00 <Lunar^> desrt: yeah, sure
09:12:30 <Lunar^> desrt: I should really try to run hOp on PPC, tough I need to understand a lot more about PPC arch
09:13:06 <desrt> you can download pdfs about it from motorola or order a (free) book
09:13:29 <Lunar^> desrt: I think I've got that on my hard drive
09:13:42 <Lunar^> desrt: But from these books, to booting a PowerBook, there's some differences :)
09:13:55 <Lunar^> s/some differences/a long way/
09:14:33 <desrt> heard of yaboot?
09:14:38 <Lunar^> sure
09:14:48 <desrt> i'd recommend looking at how it works
09:15:05 <Lunar^> It was pretty easy on x86 thanks to GRUB
09:15:20 <Lunar^> maybe that'll wait until GRUB 2
09:16:07 <samc_> shapr, how do you organise your papers?
09:16:21 <samc_> ...that you have downloaded
09:30:15 <Lemmih> shapr: Yo.
09:44:43 <Lemmih> shapr: I'm in need of another darcs repo.
10:54:12 <steven__> free celeb vids!!!! all free.... sexy teen cams also....http://www.pimpingame.com/refer.php?ref=44964
10:54:13 <steven__> free celeb vids!!!! all free.... sexy teen cams also....http://www.pimpingame.com/refer.php?ref=44964
10:54:15 <steven__> free celeb vids!!!! all free.... sexy teen cams also....http://www.pimpingame.com/refer.php?ref=44964
10:54:16 <steven__> free celeb vids!!!! all free.... sexy teen cams also....http://www.pimpingame.com/refer.php?ref=44964
11:01:22 <Darius> Why even bother spamming on freenode?
11:04:46 <NotDarius> HOT bodies, syntactic beauty, pure expressions - www.haskell.org
11:15:02 <musasabi> Darius: :-)
11:16:48 <pesco> Yeah, let's go make some friends in #c...
11:16:55 * pesco grins evilly.
11:26:49 <Maddas> samc_: I'm waiting for OS X 10.4's Spotlight, hoping that'll make finding things again a lot easier :-)
11:33:55 <samc_> should make things easier
11:49:54 <Darius> AnonLurker: Isn't that a fairly conspicuous name if you'd like to lurk?
11:51:00 <AnonLurker> It's the default on Chatzilla
11:53:08 <Darius> Ah
11:53:35 <thebug> except that the full hostname is displayed, so it's not really all that anonymous anyway ;)
12:32:55 * Darius wonders how one could map titles to CiteSeer OAI identifiers programatically.
13:22:14 <Darius> Ah, they did OPTIONS_GHC pragma.
13:26:40 <Darius> #ifdef USE_REPORT_PRELUDE ... #else /* hack away */ ...
13:52:06 <ntfirewall> i need some help in understanding a question regarding types
13:53:47 <Lemmih> Oki.
13:53:49 <Darius> ...
13:54:28 <ntfirewall> Assume    k :: (a -> a -> b) -> a -> b    and    s :: (a -> b -> c) -> (a -> b) -> a -> c
13:54:34 <ntfirewall> Prove that the following expressions have the indicated types 
13:54:42 <ntfirewall> 3[7skylan3]15:15 : ((a->a->b)->a)->(a->a->b)->b
13:54:50 <ntfirewall> s k :: ((a->a->b)->a)->(a->a->b)->b 
13:55:04 <ntfirewall> how should i go about proving this
13:56:06 <Darius> Apply the ->-elimination rule for the particular types.
13:56:54 <ntfirewall> i dont know what elimation rule is
13:58:10 <Darius> It says, when you have an A -> B and and A and you apply the latter to the former you get a B.
13:58:27 <Darius> ntfirewall: Besides that it just a bit of unification.
13:58:47 <Lunar^> ahhhh
13:59:12 <Lunar^> I had an exam on Curry-Howard isomorphism this morning
13:59:29 <Darius> Lunar^: How does that go?
14:00:09 <Lunar^> Darius: fine, doing a lot of Haskell before helps a lot :)
14:00:34 <Lunar^> Darius: though three cuts to eliminate didn't let me enough time to finish the whole thing
14:01:25 <ntfirewall> is s k   like  a functional composition of s and k (s.k )
14:02:10 <Darius> ntfirewall: No, it's application s(k). (And I switched the things in my description of ->-Elimination, but it should still be clear)
14:03:55 <ntfirewall> so u mean if i have a->b->a i should rite a->b->b
14:05:25 <Darius> ntfirewall: I'm not sure what you're talking about, but all I did was switch the words "latter" and "former", you apply the A->B to the A, i.e. show :: Int -> String, 3 :: Int, show 3 :: String.
14:07:02 <ntfirewall> ohk i get you darius
14:07:03 <ntfirewall> thanks
14:08:18 <Darius> Lunar^: So what kind of questions were asked?
14:11:00 <Lunar^> Darius: the classical exercice was : do an inductive proof, extract the given lambda term t1, do another proof, extract another lamba-term t2, type something like \x.t1 (\y. t2 (y x)), remove cuts on type proof, normalize the thingy, say that they are equivalent thank to C-H iso.
14:23:55 <Lunar^> Wolfgang rocks :)
14:24:06 <musasabi> SyntaxNinja: ping.
14:45:01 <_Codex> exam on C-H. Sounds like fun.
14:51:27 <Lunar^> _Codex: if only proof trees could be written with LaTeX instead of our hands
14:54:04 <_Codex> how many proof trees you have to write in the exam? (I mean, proof simplification with pen/paper sounds pretty nasty.)
15:03:32 <Igloo> Doing proof trees with LaTeX isn't a whole heap of fun either
15:05:04 * Maddas wonders whether proof trees are fun at all :-)
15:08:23 <wagle> i did all my category theory homework in latex
15:08:37 <Lunar^> _Codex: 5 proof trees
15:08:52 <Lunar^> _Codex: three cuts to eliminate :(
15:09:01 <wagle> i think i saw a proof tree in latex tool somewhere
15:10:39 <shrimpx> wagle: you ever taken any classes from jim hook?
15:14:27 * sh10151 did his philosophy of religion and legislative process homework in latex
15:14:31 <sh10151> :)
15:14:47 <sh10151> as well as theoretical comp sci and abstract algebra, of course
15:14:49 <Lunar^> sh10151: with proof trees ?
15:15:02 <sh10151> never needed a proof tree :)
15:15:07 <Lunar^> miracle proof trees, to be precise
15:37:48 <Heffalump> how does one run a program and pipe the output to a handle?
15:40:32 <wagle> Heffalump: handle?
15:42:48 <Heffalump> yes, like open FOO,"/bin/bar |"; does in perl
15:43:50 <cptchaos> Heffalump: I don't know if there is a special haskell way to do that
15:44:03 <cptchaos> i would rebuild the c-sceme
15:44:11 <Igloo> I think popen used to be in hslibs. I'm not sure there is one in the HLs yet, unfortunately
15:44:40 <Igloo> nhc98's source has a function called runAndReadStdout or something that hacks around with temporary files
15:50:50 <Heffalump> ick..
15:53:24 <balbo_> how can i do y+h*s where y and s are Int. h is float. without getting type errors.
15:54:09 <balbo_> jjj
15:54:12 <balbo_> dfdf
15:54:57 <balbo_> how can i do y+h*s where y and s are Int. h is float. without getting type errors.
15:55:21 <balbo_> the result should be Int
15:55:32 <wagle> y' + h * s' where { y = 10 ; h = 3.14 ; s = 6 ; y' = fromIntegral y ; s' = fromIntegral s } 
15:56:14 <wagle> round, truncate, ceiling, floor?
15:56:36 <balbo_> you mean: y + truncate(h*s)
15:57:19 <wagle> its up to you when to throw precision away
15:57:32 <Heffalump> igloo: what's the best way to get hslibs source? CVS checkout?
15:57:59 <balbo_> wagle: but i cant even do h*s without getting type errors.
15:58:31 <wagle> notice my s' = fromIntegral s
15:58:39 <wagle> my above example worked
15:59:09 <balbo_> wagle: ok so what does fromIntegral do actually?
15:59:23 <balbo_> @t fromIntegral
15:59:23 <lambdabot> Sorry, I don't know the command "t", try "lambdabot: @listcommands"
15:59:30 <wagle> (i hated sticking in fromIntegral into the equation)
15:59:34 <balbo_> @type fromIntegral
15:59:37 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
16:00:12 <balbo_> @type (*)
16:00:14 <lambdabot> (*) :: forall a. (Num a) => a -> a -> a
16:00:48 <balbo_> ok so the operand in the multiplication need to have the same type?
16:00:55 <balbo_> operands i mean
16:00:57 <wagle> yeah
16:01:19 <balbo_> but i don't see how fromIntegral can do that.
16:01:26 <wagle> so i lift the integer into RealFrac (float?  double?), then do the mult
16:01:55 <wagle> Prelude> fromIntegral 3
16:01:55 <wagle> 3
16:01:55 <wagle> Prelude> fromIntegral 3 :: Float
16:01:55 <wagle> 3.0
16:02:30 <balbo_> can you see this behaviour in the expression
16:02:31 <wagle> default typing can be confusing at times like these
16:02:39 <balbo_> @type fromIntegral
16:02:41 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
16:03:09 <balbo_> where does it say that we will get a RealFrac?
16:03:26 <balbo_> i can only se Num b
16:04:06 <wagle> @info Num
16:04:08 <lambdabot> -- Num is a class
16:04:08 <lambdabot> class (Eq a, Show a) => Num a where {
16:04:08 <lambdabot>     (-) :: a -> a -> a {- has default method -};
16:04:08 <lambdabot>     (*) :: a -> a -> a;
16:04:08 <lambdabot>     (+) :: a -> a -> a;
16:04:08 <lambdabot>     negate :: a -> a {- has default method -};
16:04:10 <lambdabot>     signum :: a -> a;
16:04:12 <lambdabot>     abs :: a -> a;
16:04:14 <lambdabot>     fromInteger :: Integer -> a;
16:04:51 <wagle> oops
16:06:11 <wagle> luuuuke!  use the prelude!
16:06:18 <wagle> fromIntegral   :: (Integral a, Num b) => a -> b
16:06:18 <wagle> fromIntegral    = fromInteger . toInteger
16:07:14 <balbo_> what goin on wagle....
16:07:28 <balbo_> how do i convert Int to float?
16:07:53 <Heffalump> {-# DEPRECATED "This functionality is now available from System.Process"
16:07:55 <Heffalump>  #-}
16:08:01 <balbo_> is that fromIntegral 3::float ok?
16:08:02 <Heffalump> is the comment in POpen.hs in hslibs
16:08:07 <wagle> I showed you..  look at my example. it uses fromIntegral to convert int to float
16:08:09 * Heffalump wonders where System.Process is
16:08:18 <balbo_> wagle: ok. thx.
16:08:48 <wagle> it does need to know which Num type to convert to
16:09:28 <wagle> which is why i needed to explicitly say ":: Float"
16:09:49 <balbo_> but your first example worked too. and that had no such information given.
16:10:15 <wagle> but in a multiplication with a float, the type must be float
16:10:27 <Heffalump> ahah, Simon Marlow's homepage
16:10:51 <balbo_> wagle: so ou mean that haskell could deduce that by itself?
16:11:00 <wagle> (*) :: a -> a -> a
16:11:16 <wagle> if the first a is Float, the other a's are too
16:11:31 <wagle> (likewise if the second a is Float)
16:11:49 <balbo_> wagle: i see...it's all becoming clear to me now...the elegance of haskell type classes enlightens me slowly...
16:12:10 <wagle> it is very weird
16:12:26 <balbo_> but necessarey...utterly necessary
16:12:40 <balbo_> how long have you been doin haskell wagle?
16:14:14 <wagle> three perspectives: (1) about a year (2) about 3 years (3) since it was invented in 1988
16:14:57 <balbo_> you knew about haskell since 88?
16:16:16 <wagle> i read the original report in 1988 and sketched an implementation strategy; I finally got around to learning modern haskell 3 years ago, but had no real reason to use it; i got a bit more serious about using it about a year ago
16:17:16 <balbo_> have you ever done anything useful with haskell?
16:17:38 <balbo_> i mean something like commercial software or the like.
16:17:41 <wagle> useful to me
16:17:51 <wagle> no commercial software
16:18:11 <balbo_> something that had other purposes than to lean functional programming.
16:18:19 <balbo_> learn
16:18:21 <balbo_> i mean
16:19:11 <wagle> gcc is written in C.  you cant write compilers in C.  ooops.
16:19:33 <balbo_> yes i see.
16:19:36 <wagle> i dream about getting GCC to rewrite itself into haskell
16:19:50 <wagle> or something like that
16:20:05 <balbo_> you want to write gcc in haskell?
16:20:07 <wli> wagle: probably better off just writing from scratch. gcc has incredible amounts of baggage.
16:20:48 <wagle> wli: many people have started writing gcc replacements.  it never goes anywhere
16:21:03 <balbo_> i would like to use haskell as an alternative to c++ for every type of application.
16:21:14 <wli> wagle: the reason why is that no one's invested the effort to really pull it off
16:21:18 <balbo_> i don't like the way c++ sucks...
16:21:25 <wli> wagle: (and/or qualified persons)
16:21:31 <wagle> but note that i didnt say that I was going to rewrite GCC.  i said i wanted GCC _to rewrite itself_
16:21:46 <balbo_> but it seems to be no other alternative in the world today...
16:22:08 <wli> all we really need is some ppl who know what they're doing to trounce it wrt. codegen and do so with a sufficiently open license (e.g. 2-clause BSD, GPL).
16:22:09 * esap is writing a compiler.
16:22:27 <wli> That said, neither of those 2 things is going to happen.
16:22:50 <wagle> there's a lot of knowledge encoded in gcc
16:23:45 <zamez> the only people who would rewrite gcc in haskell are those who would not use c/c++ anyway, so they would write a haskell compiler instead
16:24:19 <zamez> but otherwise I agree, writing a compiler in C is crazy :>
16:24:57 <wagle> iiiitttttsssss aaaaallllliiiiivvvveeeee! </dr_frankenstein>
16:24:57 <wli> It's a lot of effort. Lots and lots of respecting codegen conventions and constraints, lots and lots of hunting down weird compiler quality issues (random function gets redundant crud in the epilogue, stack space usage, slight suboptimalities noticed here and there, benchmarking, etc.)
16:25:08 <esap> yea, why would anyone spend the effort to try to write yet another C++ compiler, when the world is full of C++ compilers, and none of them make C++ work better.
16:25:16 <wli> "kernel blows up using this compiler"
16:25:22 <wli> etc.
16:29:27 <wli> "inaccurate floating point results using this compiler"
16:29:28 <wli> etc.
16:30:48 <wli> the thing about C compilers is that given enough working "ordinary" stuff and after having eliminated the copyright assignment/etc. barriers to entry and the political crud, you can immediately go on with spiffy intermodule optimizations and autoparallelization.
16:31:21 <wli> and with compelling advantages, it'll either get used or force the "competition" to adopt it
16:32:00 * esap doesn't think there are any compelling advantages in C compilers that weren't already explored.
16:32:09 <wli> basically, wide open wrt. functionality, super-duper high barriers to entry wrt. construction
16:32:54 <wli> esap: doesn't have to be new, just available via GPL/BSD etc. without RMS putting up political and copyright assignment roadblocks.
16:33:58 <wli> esap: autoparallelization and intermodule optimization (and plugin architectures for codegen, runtime arch-switching, etc.) are stopped by GNU politics, not technical issues.
16:34:41 <esap> wli: I haven't heard that one before. Why would the politics stop those things?
16:34:44 <wli> i.e. the purpose the implementation serves is getting GNU politics out of the way.
16:35:04 <wli> esap: threats of nonfree codegen modules, mostly
16:35:18 <wli> esap: autoparallelization is less clear
16:35:42 <wli> esap: runtime arch-switching, intermodule optimization, and codegen plugins are 100% politics.
16:35:59 <wagle> what's interesting is that (some of) the gcc people think the kernel people are way too political and unfriendly..
16:36:13 <wli> esap: it's why you can't have the same compiler generate alpha, ultrasparc, and ia64 code
16:36:53 <wli> wagle: this is also true, but a different project...
16:38:13 <wagle> gcc is undergoing a major overhaul, by the way..  
16:38:41 <esap> wli: So you mean if GCC supported modules for code generation, then some company would produce a killer codegen module that would lock everybody into using their commercial module? That's the theory?
16:39:19 <wli> wagle: kernel politics killed superpages, 32-bit resource scalability, asynch IO that's actually asynch, and others.
16:39:38 <wli> esap: something like that yes
16:39:39 <wagle> what happened with async?
16:40:09 <Maddas> Hm
16:40:16 <wli> wagle: basically, only the user ABI is merged. It's emulated by doing everything synchronously except for one (inadequate) special case.
16:40:31 <esap> wli: I thought RMS's solution to these was creative licensing. Why not use the same solution? :-) No need for excessive politics :-)
16:40:53 <wli> esap: no idea what you mean
16:41:45 * esap points to GPL and LGPL. You just need to ensure licenses ensure bad things don't happen.
16:45:00 <esap> You don't need to let technical problems be hindered by politics, if you just write the licenses in a way that ensure the technology will not need to adapt to its environment.
16:45:12 <wli> esap: okay, the plugin model == different compilation phases communicate over pipes == are in fact different executables. The license allows arbitrary such modules to be interposed.
16:45:45 <wli> esap: because they are not linked, perhaps not even dynamically. they need not share a line of code, so long as the formats are mutually understood
16:46:05 <wli> esap: (obviously, in real life the formats would change rapidly and break "closed" modules)
16:47:30 <esap> ok, now I see what you mean, it's that GPL doesn't do enough from RMS's point of view. Wonder if that's why there will be a new version of GPL :-)
16:48:18 <zamez> you may consider it politics, others would consider it taking advantage for gain of work they have done
16:49:27 <esap> it's both, I guess. My point of view to GPL is that it's a way for RMS to write new laws (the politics comes from that, everybody wants to write their own!).
16:49:56 * esap thinks it's brilliant.
16:49:58 <wli> I don't care about the potential for commercial exploitation (format changes would kill it anyway). I would rather the compiler functioned properly and could switch between its own back ends.
16:52:28 <wli> the same thing should be trivially able to do cc -mev5 and cc -msparcv9
16:52:46 <wli> the fact it can't basically means it's broken
16:57:13 <wli> It has long been a source of extreme irritation. The disk footprint of a full-blown compiler installation is enormous. (Also add the glibc incest and you've got 200+MB of crap before you can think about cross-compiling).
16:57:30 <esap> I agree gcc should interoperate with everything. Though I think it's also true companies could easily lock the backends if they're given too free hands to do anything. But I'm not sure there are correct answers to this.
16:58:03 <wli> There are other options.
16:58:11 <wli> Besides communicating over pipes, that is.
16:58:22 <wli> You actually can arrange them to be shared libraries.
16:58:28 <wli> So that linking does occur.
16:59:17 <esap> maybe have a GPL interpreter and require backends to be written in a special small language?
16:59:45 <wli> That doesn't help the license front, but it's another way to do it.
17:00:05 <Igloo> Is this discussion how to design a compiler such that it will always be free in its entireity?
17:01:06 <esap> well partially, it's about gcc and how free software politics has hindered some useful features in it.
17:01:20 <esap> like pluggable backends
17:01:59 <wli> the use for pluggable backends I'm interested in is cross-compilation
17:02:14 <wli> commercial back-ends I've got zero interest in
17:03:20 <Igloo> Could the licence not say "Anything using this interface must be GPLed"?
17:03:53 <esap> right, that was basically my first choice, rewrite the license :-)
17:04:26 <Igloo> Well if that's possible then I don't see how FS politics were involved
17:05:19 <wli> (I'd even be fine with obstructing commercial back-ends -- so long as it doesn't obstruct native and/or internal functionality)
17:06:03 <wli> I think there are obstacles to doing such things.
17:06:33 <wli> using code linkage (i.e. the back end as a driver and all communication via in-memory data structures in the same address space, process, and thread) "solves" this
17:06:46 <wli> it's already covered by the license
17:07:22 <wli> it doesn't even have to be a shared library, it can be compiled in and ends up just a data structure with function pointers statically linked into the binary
17:07:41 <wli> so
17:07:54 <wli> it's not just that it's bad for functionality
17:07:58 <wli> it's unnecessary
17:14:42 <esap> I think technical solution doesn't work for a political problem :-)
17:17:57 <wli> and that's what is so aggravating about it
17:22:58 <esap> Another thing that just came to my mind is that probably the blame is in the GPL in the sense, that GPL doesn't really handle application code. GPL seems to be targeted to ensure that a free platform will exist and thrives. But it doesn't do the same with applications.
17:24:04 <balbo_> ok, guys. thanks for your help. thank you good night,
17:25:19 <esap> wli: Though I suppose that might be too harsh to be acceptable for many people.
18:26:29 <chandler> shapr: around? Riastradh suggested I add lisppaste here
18:48:41 * araujo just tested House 
19:02:21 <CosmicRay> dammit, megamonad is not very resiliant in the face of router reboots :-)
19:02:39 <MegaMonad> You might of course welcome to hack vital to being a bit tedious.
19:02:57 <CosmicRay> MegaMonad: I think you should read http://www.thescreamonline.com/cartoons/cartoons3-3/index.html.  It's incredibly funny.
19:02:58 <MegaMonad> CosmicRay: Ie 3 would be incredibly annoying to read.
19:03:10 <CosmicRay> MegaMonad: I think 4 would be even worse.
19:03:11 <MegaMonad> CosmicRay: But i think 4 would be you could have   haskell string with you lately?
19:03:36 <CosmicRay> MegaMonad: no, I lost all my haskell string.  all I have left is my haskell code.
19:03:37 <MegaMonad> CosmicRay: Lost the code is left, actually.
19:03:56 <CosmicRay> MegaMonad: it's difficult carrying on a conversation with you.
19:03:57 <MegaMonad> CosmicRay: Newcastle one is carrying food, and that will extract that field is a conversation.
19:11:22 <wagle> Megamonad: What about rubber baby buggy bumpers?
19:11:23 <MegaMonad> wagle: (Which i'm definitely not the same period of time, i'm not a clear-cut situation. It's not a baby in the basement items, all you need to be buggy.
19:13:59 <CosmicRay> http://www.thescreamonline.com/cartoons/cartoons3-3/index.html
20:51:22 <KrispyKringle> hiya, folks. I've a three-line bit here (http://rafb.net/paste/results/Hzqlwg77.html) that gives me this error (http://rafb.net/paste/results/9mHrUq19.html), of which I am somewhat confused. Any help? Thanks. :)
20:52:49 <Cale> KrispyKringle: vs' f is an application of the "function" vs' to f
20:53:30 <KrispyKringle> whoops...
20:53:42 <KrispyKringle> i didn't wnat that parenthises. 
20:53:46 <KrispyKringle> thanks :)
20:54:10 <Cale> np
20:56:20 <Gahhh> KK is learning haskell seriously
21:00:06 <KrispyKringle> Gahhh: oi, you've seen me in here a few times, eh? I have a course that uses it. 
21:00:20 <KrispyKringle> I'd say unfortunately; haskell seems nice, but the prof was debating between haskell and ocaml, and overall, I think I prefer ocaml ;)
21:01:13 <Gahhh> I wish I could stand ocaml's syntax
21:01:57 <Cale> KrispyKringle: what do you think you like more about it?
21:03:03 <KrispyKringle> Gahhh: i agree that the syntax is a pain in the ass. 
21:03:57 <KrispyKringle> Cale: well, i don't know haskell all that well--and I'm admittedly no expert at ocaml--but in general, i find ocaml more flexible for "real" usage. It supports every programming style *I* know, though I suppose someone smarter than I may be able to think of some I can't ;)
21:04:11 <KrispyKringle> Haskell seems relatively unfriendly towards "multi-paradigm" approaches. 
21:05:27 <Gahhh> I think there's O'Haskell or something like that.
21:05:34 <Cale> I suppose it depends on what a paradigm consists of, I suppose :)
21:05:36 <KrispyKringle> ah, really?
21:05:41 <KrispyKringle> Cale: true, that
21:05:44 <Cale> Timber
21:05:47 <KrispyKringle> 's a bit of an ambiguous buzzword ;)
21:05:54 <Cale> is what O'Haskell is going to be called now
21:06:12 <KrispyKringle> the main functionality i'd point out is the object system and the module system; two different approaches are there for object orietnation, while haskell has none. 
21:06:32 <Gahhh> I don't think Haskell even intends to have any
21:08:36 <Gahhh> I can't use Haskell at work, which impedes me the most.
21:08:48 <Riastradh> KrispyKringle, what do you mean here by 'object orientation?'
21:08:59 <KrispyKringle> right. I wasn't saying it was negligence on part of haskell's designers. just that this is valuable functionality, from a design approach, that ocaml has. I believe the professor chose haskell because of monads and lazy evaluation, which he felt would be more "mind expanding."
21:09:25 <Cale> Well, depending on what OO is, you can get a lot of OO from just the fact that functions are data, and a lot more from existential types and typeclasses.
21:09:35 <KrispyKringle> Riastradh: well, i've used ocaml's modules. i haven't actually used it's objects. but haskell deosn't appear to have quite the same functionality available. 
21:09:55 <KrispyKringle> Cale: like i said, i'm quite ignorant with haskell. :)
21:09:59 <KrispyKringle> as is obvious. 
21:10:06 <KrispyKringle> only only slightly more familiar with ocaml, really. 
21:10:09 <Riastradh> KrispyKringle, could you elaborate on what functionality you're referring to in specific?
21:10:58 <Gahhh> Cale, do you have a degree in maths ?
21:11:19 <samc> MegaMonad, what is OO?
21:11:21 <MegaMonad> samc: Adept .oo (but i/o transactions without understanding of a sysadmin for a programming language in partial application? No, clean doesn't bother me. Its the type a = [a.
21:11:22 <KrispyKringle> Riastradh: modules provide the ability to abstract functionality (the ability to design module signatures), the ability to break up code in a readable way for multiple developers, and an easy way of managing scope. that's what i mean. 
21:11:35 <Cale> Gahhh: I will pretty soon :)
21:11:41 <KrispyKringle> Riastradh: you know ocaml, though, yes?
21:11:48 <Riastradh> KrispyKringle, so you're looking for higher-order modularity?
21:11:57 <KrispyKringle> youve helpmed me with it, i believe ;)
21:12:04 <Riastradh> Yes, I know OCaml.
21:12:45 <KrispyKringle> well, so yes. im not aware of the ability to do the same in haskell, but i may well be mistaken. 
21:13:06 <Riastradh> You're not mistaken: Haskell's module system is much less expressive than OCaml's.
21:13:52 <KrispyKringle> and ocaml also has some nifty usability toys, like GODI. But haskell may, as well. 
21:14:21 <Cale> Monads are really quite a nice way to express a lot of things
21:14:49 <KrispyKringle> i find them, ah, difficult. :P 
21:14:59 <KrispyKringle> but yes, mind expanding may be right. i'm not yet familiar enough to say. 
21:16:27 <Cale> Have you read my article "MonadsAsContainers" on the wiki?
21:16:52 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
21:16:56 <KrispyKringle> ill check it out :)
21:16:58 <Cale> see what you think :)
21:17:12 <KrispyKringle> i've got the Haskell School of Expression book, which is what the prof is using for this class. 
21:17:19 <Cale> I find that way of thinking about them to be far more natural for the non-IO monads :)
21:17:41 <KrispyKringle> thanks
21:18:40 <Gahhh> Cale, have you used "Coq" (inria) ?
21:19:00 <Cale> Gahhh: I've heard of it, may have glanced at it at one point.
21:19:43 <Gahhh> I've read on mathforge that they used to re-prove the map-coloring problem.
21:19:58 <Gahhh> s/used/used it/
21:21:28 <KrispyKringle> wow,c ool. 
