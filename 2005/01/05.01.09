01:02:40 * shapr wibbles
01:05:15 <jesse99> hmm, I cant find this in the docs or via google: which module do I need to include to get the template Expr type?
01:06:06 <Lemmih> Good morning, shapr.
01:06:29 <Lemmih> jesse99: Are you using GHC 6.3?
01:06:50 <jesse99> 6.2.2
01:07:02 <Lemmih> It's either Language.Haskell.THSyntax (pre GHC 6.3) or Language.Haskell.TH
01:07:34 <jesse99> I tried Language.Haskell.THSyntax and got the same error: Type constructor or class not in scope: `Expr'
01:07:38 <Lemmih> Template Haskell will change a little in the next stable release.
01:07:57 <Lemmih> It's called Exp, iirc.
01:09:02 <jesse99> hmm, i think you're right, they must have changed it from the paper
01:09:28 <jesse99> but, I see that reifyLocn isnt implemented...grr
01:13:32 <Lemmih> What are you working on?
01:15:17 <jesse99> 1) I wanted to use template haskell to do provide a better interface to my simple unit test framework 2) I wanted to use template haskell to deduce return types for a tuple space lib (although I'm not sure that's possible)
01:16:13 <jesse99> i have a c++ lib that does 2), works well but was a pita to write
01:19:48 <shapr> g'mornin Lemmih 
01:26:34 <Victor> Hi, i am stuck at a school assignment, pretty new to haskell, could someone help me out a little?
01:27:10 <Cale> Victor: sure
01:27:38 <Victor> ok, thanks :)
01:27:38 <Victor> type Automaat s i o  = s -> i -> (s, o)
01:27:38 <Victor> type BasAutomaat = Automaat Omgeving Opdracht String
01:27:38 <Victor> exec :: BasAutomaat
01:27:38 <Victor> exec env (Print nexp)    = (env, show (eval nexp env))
01:27:38 <Victor> exec env (Let naam nexp) = (assign env naam (eval nexp env),[])
01:27:49 <Victor> its these lines
01:28:08 <Victor> i have to add a new executino line, that evaluates an if statement
01:28:21 <Victor> its a really small interpreter :)
01:28:28 <Cale> :)
01:28:33 <Victor> so i wanted to do, something like this:
01:28:49 <Victor> exec env (If bexp opdr)
01:28:49 <Victor>  | bexp == True = exec (Automaat env opdr [])
01:29:00 <Victor> oef, crap
01:29:06 <Victor> thats the wrong code, give me a sec.
01:29:10 <Cale> okay
01:29:30 <Victor> exec env (If bexp opdr)
01:29:30 <Victor>  | (eval2 bexp env)  = exec (Automaat env opdr [])
01:29:35 <Victor> well, the point is
01:29:37 <Victor> at the eval2
01:29:44 <Victor> i evaluate the if statemtn
01:29:48 <Victor> and that works fine
01:30:07 <Victor> but after that, i have to execute the code in the if assignment if the if assignment is true
01:30:22 <Victor> but i dont really understand the lines i gave earlier
01:30:50 <Victor> on how to recall the exec function
01:31:00 <Victor> because it is not really clear to me what it takes as an input :)
01:31:21 <Victor> exec :: BasAutomaat would have me think it takes Automaat Omgeving Opdracht String
01:31:53 <Victor> but automaat is some sort of definition of how the data is transformed to a (s,o) tupel, if i understand correctly :)
01:32:07 <Victor> so i am kind of stuck :)
01:32:15 <Cale> Apparently it takes an "Omgeving" and a "Opdracht", and returns a pair (Omgeving, String)
01:32:37 <Cale> but I don't understand that lanuage :) Probably a state and input?
01:32:47 <Victor> oh, sorry, i will translate :)
01:32:53 <Victor> omgeving = environment
01:33:45 <Victor> data Opdracht = Let Varnaam Numexp |
01:33:45 <Victor> 		If Boolexp Opdracht |	
01:33:45 <Victor>                 Print Numexp
01:33:45 <Victor>                 deriving Show
01:33:54 <Victor> thats the opdracht
01:34:03 <Victor> its the type of commands the interpreter can handle
01:34:09 <Victor> like if, let, and show
01:34:52 <Victor> and after handling this input, the "opdracht" , the state of the program changes, and maybe it gives output, thats what the string in the pair is for
01:35:04 <Cale> so you want to take the environment and pass it to eval along with the "then" part of the if
01:35:07 <Cale> right?
01:35:40 <Victor> i want to execute the codeblock in the if statement when the if statement holds, but i dont know how to get the codeblock into the exec function :)
01:36:22 <Victor> the evaluation of if the if statement holds works, i just cant find a way to put the code to execute in the if statement back into the function
01:36:43 <Victor> so if we have If bexp opdr
01:36:54 <Victor> bexp is a boolean expression to evaluate
01:37:03 <Victor> when this holds true, we have to evaluate the opdr
01:37:26 <Victor> which can be anything, like a let statement, another if, or a print statement
01:38:34 <Victor> the exec function does these things, i think, but i just don't understand how to input the opdr and the environment back into this function, because i don't really know how to work with the typedefinitions automaat and basautomaat, to new to the language :(
01:39:40 <Cale> Well, given s, i, and o, a value of type "Automaat s i o" is a function which takes an s and an i and returns an (s,o)
01:39:56 <Victor> yeah, i did understand that much
01:40:25 <Victor> but why doesnt exec (Automaat env opdr []) work?
01:40:30 <Victor> is this line wrong?
01:40:45 <Cale> and BasAutomaat = Automaat Omgeving Opdracht String = Omgeving -> Opdracht -> (Omgeving, String)
01:40:46 <Victor> i build the type the wrong way i guess
01:41:24 <Cale> is (Automaat env opdr []) an environment?
01:41:57 <Victor> it was my way of trying to build a BasAutomaat type to put into the function exec :)
01:42:18 <Cale> exec is of type BasAutomaat
01:42:29 <Cale> that is, it's of type
01:42:33 <Cale> Omgeving -> Opdracht -> (Omgeving, String)
01:42:57 <Cale> so it takes an Omgeving and an Opdracht, and returns a pair (Omgeving, String)
01:43:00 <Victor> so, i have to put in exec env opdr?
01:43:18 <Cale> yeah
01:43:26 <Victor> But doesnt automaat ask for s i o?
01:43:54 <Cale> Automaat is a type constructor
01:44:09 <Cale> it's like a function which takes some types as parameters and returns a type
01:44:18 <Cale> type BasAutomaat = Automaat Omgeving Opdracht String
01:44:34 <Cale> here, it's applied to Omgeving, Opdracht and String
01:44:35 <Victor> ahh, ok , yeah, like a macro in C
01:46:22 <Cale> or a typedef with parameters, if you could have those :)
01:46:55 <Victor> ok, i think i understand now. :)
01:49:15 <Victor> well, i am going to try some things, thanks a lot for your help Cale!
01:49:24 <Cale> no problem
02:16:31 <musasabi> morning
02:16:34 <shapr> y0
02:17:26 <musasabi> I am stumbling upon small difficulties when trying to create a hashtable in STM
02:17:37 <musasabi> the basic functionality is trivial.
02:18:34 <musasabi> The problem is that I cannot maintain any counts in the hashtable => trying to figure out when resizing is needed becomes complex.
02:21:20 <musasabi> Local resizing (having a table of tables) was my next choice - then the user needed to supply a list of hashfunctions. But even this does not cause the load to be smaller in nasty buckets :-(
02:29:08 <bluegods> i heard haskell has trouble scaling
02:29:11 <bluegods> is this true
02:29:12 <bluegods> ?
02:30:31 <Cale> bluegods: depends on what you mean by scaling, I suppose
02:31:25 <Cale> I find that it's quite reasonable for any sort of ordinary user application
02:31:54 <mornfall> yow!
02:31:55 <mornfall> TheHunter: hmm, thbot not around?
02:32:22 <musasabi> bluegods: I haven't noticed that..
02:32:39 <musasabi> bluegods: What kind of application do you mean?
02:32:57 <musasabi> bluegods: e.g. the size of ghc is no problem ;)
02:36:42 <bluegods> ghc?
02:36:48 <bluegods> whats is that
02:36:53 <bluegods> on a smalltalk site
02:37:06 <bluegods> they say haskell becomes a function mess when u make large website
02:37:06 <Lemmih> The Glorious Haskell Compiler.
02:37:14 <bluegods> so use object oriented like smalltalk
02:37:26 <bluegods> i dunnno i program bash
02:37:43 <bluegods> im trying to learn programming so i can make money with a cmopany i start and become billionaire
02:38:55 <Lemmih> You don't get rich from programming.
02:40:28 <mornfall> TheHunter: thanks
02:41:48 <bluegods> realy?
02:41:51 <bluegods> fuck
02:41:54 <bluegods> god damn it
02:42:03 <bluegods> i have problems making money and getting laid
02:42:04 <musasabi> yes, if you want money, programming is not the best way.
02:42:07 <bluegods> im so sick of bullshit
02:42:17 <bluegods> i want pussy n cash
02:42:20 <bluegods> god damn it
02:42:21 <mornfall> haha @ bluegods 
02:42:25 <bluegods> im so frustrated
02:42:31 <bluegods> i hate my life
02:42:32 <mornfall> obviously
02:43:05 * mornfall has no problems getting laid, only making money... i have a job interview next week... maybe i fix the other half =)
02:43:20 <musasabi> bluegods: of course Smalltalk folks say "the haskell way is not good" and haskell folks say "the smalltalk way is not good", but in reality they are just different ways of doing things ;)
02:43:56 <mornfall> in fact, all programming languages are turing equivalent and everyone can hang themselves =)
02:44:06 <mornfall> it's all about infinite tapes
02:44:11 <musasabi> getting laid is easy. Getting money is either easy but boring jpb. or nice job and very little money.
02:44:33 <mornfall> musasabi: i'm in the very little money camp right now :/
02:44:35 <musasabi> *job
02:45:11 * musasabi is trying to figure a way to find something I can use haskell for in the summer.
02:45:40 <musasabi> Good side is I don't really need money.
02:46:04 <mornfall> tsss
02:46:16 <mornfall> i wish
02:46:30 <musasabi> But that is only because I am very used to living on a student budget.
02:49:17 <bluegods> ok
02:49:21 <bluegods> if getting laid is ez
02:49:24 <bluegods> how do i do it
02:49:28 <bluegods> im donefor
02:49:33 <bluegods> women tell me im too nice
02:49:37 <bluegods> bs like that
02:49:40 <bluegods> hell
02:49:44 <bluegods> los angeles is hell
02:50:28 * Lemmih wonder if bluegods is for real.
02:50:31 <mornfall> musasabi: i am living on student budget, uhm... i still do need money
02:50:47 <mornfall> musasabi: like, i need some money to fill in the student budget :p
02:51:37 <musasabi> mornfall: I already have plans to get the rent covered. That means that for the whole summer I need about 300e, which should not be a problem.
02:52:09 <bluegods> im not suicidal
02:52:13 <bluegods> but am fed up
02:52:24 <bluegods> my dick deserves some poon
02:52:44 <mornfall> bluegods: well, 1) get money 2) get hooker? =)
02:52:48 <musasabi> the key for getting things is sometimes not wanting things
02:52:53 <mornfall> reduces 2 problems into 1 :p
02:53:00 <musasabi> that is the cheapest way ;)
02:54:13 <bluegods> no idiot
02:54:18 <bluegods> idea is to not pay
02:54:23 <bluegods> other guys are not paying right
02:54:27 <bluegods> why should I
02:54:29 <bluegods> wtf
02:54:35 <Lemmih> shapr: What's the URL for that uUni-trick
02:54:47 <Lemmih> shapr: What's the URL for that uni-trick page, again?
02:56:40 <musasabi> bluegods: define paying.
02:57:11 <mornfall> well, getting laid "for free" is quite a bit of work, from my experience =)
02:57:28 <musasabi> bluegods: so it is not paying if you take a girl out and buy her food, drinks and gifts, but it is evil paying if you pay a hooker.
02:58:22 <mornfall> musasabi: well, OTOH, to be fair, i get food, drinks and gifts from my girlfriend, not only the other way around, too =)
02:58:23 <musasabi> currently it seems my gf keeps taking me out on dates (and paying) more frequently than I do.
02:58:46 <musasabi> mornfall: true, but I was talking outside a real relationship.
02:58:57 <mornfall> point
02:59:47 <shapr> Lemmih: http://unicycle.2ya.com/
02:59:55 <mornfall> yo shapr 
02:59:57 <musasabi> then again our gender roles are quite reversed ;)
03:00:11 <mornfall> musasabi: uhm, strap-on *hides*
03:00:12 <mornfall> ?
03:00:53 <bluegods> I DONT GET HOW TO GET LAID
03:00:57 <bluegods> I FUCKING SUCK AT IT
03:01:01 <bluegods> I NEVER GET LAID
03:01:04 <bluegods> ONLY DRUNK
03:01:04 <musasabi> on this channel on mornings, but I wouldn't say no ;P
03:01:06 <bluegods> PISSES ME OFF
03:01:08 <shapr> excuse me?
03:01:10 <mornfall> bluegods: get a girlfriend and STOP YELLING
03:01:14 <shapr> truly
03:01:17 <bluegods> LIKE YOU GOTTA BE ALMOST BUSIENSSLIEKWITH WOMEN
03:01:22 <bluegods> its hell
03:01:29 <bluegods> like no we are guna fuck now
03:01:36 <bluegods> b 4 i buy you 70 dollar dinner
03:01:38 <bluegods> u kunt
03:01:44 <bluegods> girl are crazy
03:01:53 <bluegods> do they like n ot like dick or somethign
03:01:59 <shapr> y0 mornfall
03:02:01 <musasabi> bluegods: Women are not a different species you know, they mop about the lack of decent men too ;)
03:02:20 <mornfall> musasabi: understandably
03:02:36 <shapr> yeah, women are looking for meaningful relationships in my experienc.
03:02:49 <shapr> Doesn't have to be commitment or anything, but at least content-ful
03:02:53 <mornfall> shapr: depends on where in their cycle they are *hides*
03:03:21 * mornfall should really go back to reading Foundations of Mathematics =)
03:03:48 * mornfall can probably hint at Sex Tips for Geeks by ESR
03:03:59 <mornfall> kinda worksforme
03:04:11 <mornfall> but nothing can beat you "getting it"
03:06:02 <TheHunter> man, in which parallel universe is tail recursion hard to explain?
03:07:17 <mornfall> TheHunter: hard to explain to whom?
03:07:34 <TheHunter> imperative (python) programmers, i guess.
03:07:45 <mornfall> hmh
03:07:54 <musasabi> recursion was hard for me but only in math.
03:07:59 <TheHunter> pretty weird discussion http://lambda-the-ultimate.org/node/view/472
03:08:00 <mornfall> TheHunter: every dork can "program"
03:08:09 * mornfall reads
03:08:20 <mornfall> fuck i should be learning maths... i suck
03:08:36 <mornfall> bluegods: learn maths if you want to get laid =)
03:09:02 <TheHunter> i mean as soon you're explaining to someone why stack overflows occur, you might as well tell him that in a properly implemented compiler, some statements don't cause the stack to grow.
03:09:35 <musasabi> my gf says from the back that "math causes horror".
03:09:47 <mornfall> musasabi: i was joking
03:10:09 <musasabi> but it *is* quite sexy.
03:10:14 * wli looks at the ghostbusters library scene -style piles of math books scattered around his apartment
03:10:37 <musasabi> Then again she is just traumatized by her own math exams.
03:10:42 <mornfall> musasabi: depends on your target group... getting shy geeky girls into bed may be more of a challenge =)
03:10:45 <wli> (supported on the sides by computers)
03:11:31 <musasabi> mornfall: but generally I like being able to explain stuff to people I go out with.. 
03:11:41 <mornfall> lol
03:11:59 <mornfall> lol as in the lambda-the-ultimate post
03:12:00 <TheHunter> yah, it's really a drag. You can't tell anybody you're studying math without being classified as weirdo.
03:12:03 <musasabi> mornfall: but shy geeky girls are usually fun, and I am usually not interested in getting them to bed, so that does not really matter.
03:12:31 <mornfall> musasabi: explain stuff as in?
03:12:57 <wli> TheHunter: Maybe it was the abstract algebra textbooks that scared them off.
03:13:02 <musasabi> mornfall: them understanding the answer when they ask me what I am doing.
03:13:04 <mornfall> TheHunter: well, i'm studying CS instead...
03:13:35 <mornfall> musasabi: heh, doing generally or doing right now?
03:14:12 <mornfall> "chasing this awful heisenbug honey, it disappears when i set a breakpoint there, *sigh*"
03:14:15 <TheHunter> i guess math is worse than cs although in that respect, although the cs guys look way more geeky
03:14:22 <musasabi> mornfall: both preferrably.
03:14:57 <mornfall> musasabi: i don't know many people who would understand generally what i do right now at any given moment
03:15:06 <mornfall> musasabi: fellow CS students included
03:15:10 <wli> I finished a bachelor's in both already, though I guess since it's a .us university that's about an 8th-grade education compared to the civilized world.
03:15:14 <musasabi> then again I try to understand what they are doing too (read a few books about rock mechanics for that very purpose)
03:15:18 <mornfall> and i don't want to date a male CS geek
03:15:47 <wli> I suppose one could call that going Greek.
03:16:14 <musasabi> mornfall: well of course one has to simplify things a little ;)
03:16:37 <mornfall> musasabi: okey then, i was wondering if you are very lucky or what :p
03:16:40 <wli> hmm, validating gpg signatures
03:17:02 <mornfall> so we stay with "quite a bit lucky" =)
03:17:45 <wli> finding partners one considers desirable in every way is difficult
03:18:51 * mornfall bets he can write python that this alleged "i can read all python code out there, wooh" guy wouldn't parse in a bunch of hours =)
03:19:06 <mornfall> wli: difficult?
03:19:21 <mornfall> wli: i think it approaches impossibility... very very fast
03:20:32 <wli> mornfall: the probability is nonzero to a degree a math geek would not consider extreme. For instance, the set is not of zero measure (counting measure).
03:21:02 <mornfall> wli: i'm afraid of the opposite... since i can't even imagine a person that i would find desirable in all respects
03:21:07 <wli> mornfall: The logarithm of the probability is not even very far out.
03:21:25 <wli> mornfall: barring logical impossibility for a given person, sure.
03:21:27 <mornfall> wli: i mean, there is probably a contradiction in my ideal, so =)
03:23:15 <mornfall> wli: well, i think the possibility that a random person fullfills all my criterion (accounting for the required changes in time happen all right) is far below 1/<number of people on earth>
03:24:03 <wli> mornfall: Supposing this probability is p, what would you estimate -ln(p) as?
03:24:35 <mornfall> i have no f****** idea... it just doesn't seem possible (nor right, for that matter)
03:24:48 <mornfall> so i stick with the "very low possibility" notion
03:25:09 <wli> mornfall: how about ln(-ln(p))?
03:25:19 <mornfall> but there's lunch waiting for me with probability p=~1 =)
03:25:27 <mornfall> so, brb
03:36:22 <wli> um, gpg: mpi too large (18077 bits)
03:36:28 <wli> wtf?
04:24:02 <adrianek> hi. when I do 'read "1a0"::Int' I get Exception. How should I handle it? Is there any 'readXXX :: String -> Maybe a' ???
04:24:36 <Lemmih> Try: 'read "0x1a0" :: Int'
04:24:56 <Lemmih> Oh. You don't wanna read hex.
04:25:06 <adrianek> I want to handle errorous cases. I put "1a0" on purpose
04:25:09 <Lemmih> Check out 'reads'
04:25:16 <Lemmih> @type reads
04:25:18 <lambdabot> reads :: forall a. (Read a) => String -> [(a, String)]
04:25:38 <adrianek> ok. i'll check it. thanks!
04:25:50 <adrianek> but, BTW. What is the way to catch the exception?
04:26:02 <Lemmih> Yes.
04:26:14 <Lemmih> @type Control.Concurrent.catch
04:26:15 <lambdabot> bzzt
04:26:22 <Lemmih> @type catch
04:26:24 <lambdabot> catch :: forall a. IO a -> (IOError -> IO a) -> IO a
04:26:41 <adrianek> but read is no IO
04:26:44 <Lemmih> @type Control.Excaption.catch
04:26:46 <lambdabot> bzzt
04:26:48 <adrianek> ok
04:26:50 <adrianek> thanks!
04:26:55 <Lemmih> @type Control.Exception.catch
04:26:56 <lambdabot> Control.Exception.catch :: forall a.
04:26:56 <lambdabot> 			   IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
04:49:53 <basti_> i would love to lazily generate sound output.
04:50:39 <basti_> permutate $_
04:52:18 <shapr> you can
04:52:27 <shapr> Haskore supports lazy generation of sound
04:53:35 <shapr> Though Henning Thielman hasn't yet figured out how to get CSound to take input from a unix pipe.
04:54:01 <basti_> hmmm. does it do playback? i was thinking sample data...
04:54:32 <shapr> it can output CSound or MIDI
04:55:00 <basti_> hmm.
04:55:10 <shapr> I'd like to listen to a lorenz fractal, and that would require an infinite lazy output.
04:55:55 <basti_> so how to do that?
04:56:14 <wli> replicator equations sound like fun
04:56:52 <shapr> If you can persuade CSound to take input from a pipe and render it 'lazily' then it'll work.
04:57:20 <basti_> using csound just because its there does not sound like a good idea. but actually i have witnessed csound doing that.
04:57:37 <basti_> but csound is an elephant.
04:57:47 <shapr> you're saying it remember everything? ;-)
04:58:02 <basti_> I'll install csound and see if i can.
04:58:40 <shapr> If you figure it out, I want to know how!
05:02:38 <kuribas> Do all values in Haskell have to be evaluated lazily?
05:04:32 <basti_> well if i set -o dac then it plays back through my soundcard.
05:04:39 <musasabi> kuribas: you have seq etc
05:04:49 <basti_> and it has midi input capability. so i suppose it renders "halflazy".
05:05:22 <kuribas> I wonder if a haskell implementation wouldn't be more efficient if it can choose wether to evaluate lazily or not.
05:05:44 <musasabi> kuribas: there was something that evaluated things eagerly.
05:06:04 <musasabi> kuribas: but eager evaluation can break some code ;)
05:06:14 <musasabi> kuribas: e.g. I like to return infinite lists.
05:06:37 <kuribas> musababi: what if the compiler could detect loops and recursion?
05:07:03 <basti_> it seems to read in score data lazily...
05:07:04 <wli> termination analysis
05:07:17 <kuribas> it could then use eager evaluation when it knows that it can do so
05:07:25 <basti_> now it should be possible to use a pipe to feed it data
05:07:25 <kuribas> wli: yes
05:07:49 <wli> kuribas: Turing says...
05:08:08 <kuribas> wli: what?
05:08:47 <musasabi> kuribas: but then again you can force evaluation with the lazy semantics also.
05:09:36 <kuribas> musasabi: yes, but perhaps the compiler could do more work.
05:10:33 <kuribas> wli: Turing doesn't say that it's impossible for all cases, does he?
05:11:02 <wli> It doesn't rule out being able to do it in some cases.
05:11:16 <wli> It does rule out being able to do it for all cases.
05:11:36 <kuribas> Then if the compiler is unsure, it can default to lazy evaluation
05:11:59 <kuribas> I think many programs should be deterministic
05:12:13 <kuribas> Or at least parts of the program
05:14:15 <basti_> shapr?
05:16:33 <shapr> what?
05:16:59 <basti_> csound does dsp playback of rt midi events
05:17:10 <shapr> Have a demo command line?
05:17:12 <basti_> thats not exactly what we were looking for though.
05:17:27 <basti_>  csound -odac -W techno_hymn.orc -M /dev/midi00
05:17:36 <basti_> replace techno_hymn with your fav orchestra =)
05:18:08 <basti_> i cant get midi events fed in atm though.
05:18:38 <basti_> but the manual claims it works.
05:21:28 <shapr> I'd love to know how...
05:21:43 <basti_> well i could attach a keyboard to my pc
05:22:13 <basti_> but i dont have place and i dont have a free outlet handy atm.
05:22:44 <basti_> hmm
05:23:40 <retardo> Why does Haskell string syntax allow \^@, \^[, \^_, etc., but not \^?  ?   Was this a deliberate omission, or an oversight?
05:24:10 <basti_> there should be a possibility to tinker it together with aconnect/aseqnet
05:25:12 <basti_> hmm
05:25:17 <basti_> okay.
05:25:23 * basti_ theory:
05:25:32 <basti_> - create named pipe
05:25:56 <basti_> - make aconnect believe it should output into that pipe
05:26:39 <basti_> hm.
05:28:13 <basti_> no. 1) create named pipe 2) have some midi thing output into named pipe 3) input csound from that.
05:28:31 <basti_> and replace 2) with asound if the data isnt "RT" but "file type"
05:28:59 <shapr> retardo: ask on the mailing list
05:31:21 <retardo> shapr: Thanks.
05:36:12 <basti_> modprobe snd-virmidi could be a thing.
05:38:53 * shapr grumbles
05:39:18 <basti_> i got midi events to route through.
05:39:23 <basti_> csound seems to have problems though.
05:39:41 <shapr> One of my friends has been borrowing movies from me and burning copies of movies/ps2 games/etc.
05:39:54 <shapr> What's the problem with CSound?
05:40:20 <basti_> gives errors
05:40:25 <basti_>   rtevent:         T150.395 TT150.395 M:      0.0      0.0
05:40:25 <basti_> WARNING: instr 1 p7 illegal for MIDI
05:40:25 <basti_> INIT ERROR in instr 1: ival2 is zero
05:41:05 <xerox> Is it possible to set an alias of an arg in the argument list?
05:41:24 <xerox> something like being able to refer a list as "lst" AND "x:xs"
05:41:53 <shapr> yup
05:42:05 <shapr> foo lst@(x:xs)
05:42:56 <xerox> nice!
06:04:04 <basti_> shapr: it should be possible. many people use csound to play rt midi events. I can hook up my csound to software midi playback.
06:04:17 <basti_> i'm just getting these errors for a reason i don't fully understand
08:40:40 <autrijus> so is "globalVar = unsafePerformIO $ newIORef 0" considered OK or not OK? :)
08:40:55 <autrijus> I've read the mailing list thread and I still can't grasp the idea.
08:41:01 <musasabi> autrijus: it is considered an evil hack, but we still use it.
08:41:26 <musasabi> autrijus: but give it a type signature, otherwise you are setting yourself up for suicide.
08:41:27 <autrijus> but the only alternative I see is to declare it in "main" and put all functions as "where" in main
08:41:32 <autrijus> oh sure.
08:41:40 <maihem> autrijus: What is it supposed to do?
08:41:54 <autrijus> maihem: it's supposed to declare a mutable variable reachable by all.
08:42:11 <musasabi> (otherwise it will become polymorphic and you will come here crying that your program segfaults (been there done that)
08:42:20 * autrijus nods solemnly
08:42:47 <autrijus> so I hear the main opposition is that ghc may inline it
08:42:52 <autrijus> and cause two newIORef to be called
08:43:04 <autrijus> is that a valid concern?
08:43:07 <maihem> hm, doesn't that mean your functions all become strict if they change it?
08:43:26 <autrijus> maihem: uhm, only IO functions change it, of course
08:43:59 <autrijus> and yes, for the functions involved it will be using strict semantic
08:44:26 <autrijus> that is true for IO Refs in general anyway.
08:44:48 <musasabi> no-inline for the function should be enough.
08:45:10 <musasabi> I keep hearing about people using no-cse in addition, but omitting that has not bitten me yet.
08:46:56 <autrijus> so just
08:47:07 <TheHunter> cse is evil anyway.
08:47:08 <autrijus> {-# NOINLINE globalEvilVariable #-}
08:47:36 <autrijus> I can't find a NOCSE / NO-CSE pragma.
08:47:55 <TheHunter> ghc -fno-cse iirc
08:48:02 <autrijus> oh ok
08:48:16 <maihem> so what if the first output of the program can be calculated with on function that modifies the data before the first read and leaves it non-zero, but the programs second output needs the result of another function that uses the IORef but assumes it starts at zero? If you use main = do (v' <- secondValue; (putStrLn . show) firstValue; (putStrLn . show) v')
08:48:36 <maihem> Can it work on one compiler and not on another (that does the computations in a different order
08:49:17 <autrijus> then the firstValue function is obviously misassuming things.
08:49:46 <maihem> It looks like secondValue should force the newIORef 0, but the compiler might not even consider secondValue until after firstValue since it v' unneeded till then.
08:49:48 <autrijus> and more over, what good is a pure function that depends on a IORef??
08:49:58 <autrijus> (firstValue is pure)
08:50:49 <autrijus> for it to use the global variable it must use unsafePerformIO too, which means all bets are off, iirc.
08:51:24 <maihem> who cares what good it is, it is a valid way to implement it. globalVar is asking for trouble whichever way you look at it. IMHO
08:51:46 <autrijus> not if you limit all access to globalVar in strict, IO functions
08:51:55 <autrijus> I fail to see why it can cause trouble that way.
08:52:12 <maihem> Can it not be done with a state monad where the names are defined class Monad MyStateMonad where globalVar :: Int
08:52:14 <maihem> or something
08:52:46 <autrijus> not sure I understand you.
08:53:28 <maihem> even do (v' <- secondValue; v <- firstValue; (putStrLn . show) v; (putStrLn . show) v') would exhibit the problem (all strict IO)
08:54:04 <autrijus> in that case, any imperative language user will easy spot the error :)
08:54:08 <maihem> because the unsafePerformIO removes the IO so the compiler could ignore it and pretend it didn't happen.
08:54:33 <autrijus> what didn't happen?
08:54:35 <musasabi> maihem: you should not use unsafePerformIO for reading the global var - only initialisation.
08:55:06 <musasabi> maihem: reading it is like reading from an external entity - you cannot be sure what you get.
08:56:21 <maihem> oh, but why not just use a state monad with defined functions "class Monad MyStateMonad where globalVar :: MyStateMonad Int -- made mistake above I think)
08:57:11 <maihem> or something like that
08:58:09 <maihem> so all use of globalVar puts the function into the MyStateMonad monad, and the name is available globally
08:58:27 <autrijus> that sounds good.
08:58:44 <autrijus> so I use it just like any other IO monads?
08:58:50 <autrijus> foo <- globalVar
08:58:57 <autrijus> how do I change it?
08:59:31 <maihem> yeah, I think it would work. If you wanted to mix IO in, then I don't know Offhand what you have to do.
09:00:11 <autrijus> sorry if the answer of how to construct a mutator is obvious but I'm really a newbie here :)
09:01:39 <maihem> but for pure imperative computation, you could do it trivially. You would have to create a MyStateMonad using withNewMyStateMonad (do { whatever }), then you could use withNewMyStateMonad again later, and get a completely new set of globals so no unexpected behaviour :)
09:01:52 <autrijus> oh.
09:01:58 <autrijus> I see what you mean.
09:02:02 <maihem> I'd have to sit and work out the details because I'm quite a novice too :)
09:02:16 <autrijus> hmm.
09:02:23 <autrijus> but that means I need to pass the state all around
09:02:37 <autrijus> since the original motivation is to 1)not pass things and 2)defeat lexical scoping
09:02:45 <autrijus> otherwise I'll just do
09:02:51 <autrijus> globalVar <- newIORef 0
09:02:54 <autrijus> let ...
09:03:00 <autrijus> and define all my functions lexically
09:03:17 <maihem> but you could easily do main = withNewMyStateMonad (do { allStateOperations })
09:03:29 <maihem> so you only have the one state, and everything is in that monad.
09:03:31 <autrijus> yeah but what about other functions?
09:03:40 <maihem> you just have to do the extra work to make IO work
09:03:51 <autrijus> I mean, what if I want to refactor out some state operations into another functions
09:03:56 <autrijus> then I'd have to pass the state explicitly
09:04:03 <autrijus> which is what I've been trying to avoid
09:04:47 <maihem> MyStateMonad is a functor, so I think things should just work, the outer function :: Int -> Int -> Int becomes :: Int -> Int -> MyStateMonad Int, which is just right, I think.
09:05:35 <autrijus> how would I modify the value of the Int in the monad? :)
09:05:46 <maihem> with just one withNewStateMonad as the outer scope (in main), things can be made to just work. You don't pass the state, because the monad means you return how to change the state, and withNewMyStateMonad follows those instructions
09:05:55 <autrijus> or rather, replace, in this case.
09:06:00 <autrijus> oh. gotcha.
09:06:03 <autrijus> thanks.
09:06:15 <maihem> You would define the monad with all the modification instructions
09:06:18 <autrijus> yup.
09:06:38 <autrijus> sounds good.
09:06:44 <maihem> so you get to set the interface. There are already state monads, so you could just start right off with that.
09:11:29 <autrijus> I think I still want the IO monad.
09:11:40 <autrijus> I'll probably bite the bullet and pass the state around as a record.
09:11:49 <autrijus> and instantiate the IORef as part of main.
09:12:18 <maihem> I think you can do it. but it needs practice. I am thinking about it as it is just at the edge of what I can do and it will be good training for me.
09:12:48 <autrijus> cool. but you see, I have a deadline here :)
09:12:59 <musasabi> Sometimes global variables are just what you want.
09:13:11 <musasabi> think about e.g. stdin/out/err ;)
09:13:17 <autrijus> heh. :)
09:17:13 * autrijus decides to sin completely and do
09:17:13 <autrijus> (=:) :: IORef a -> a -> IO ()
09:17:14 <autrijus> ref =: val = writeIORef ref val
09:17:40 <autrijus> mmm now I feel I'm writing BASIC.
09:21:11 <autrijus> #define global(var, type) \
09:21:12 <autrijus>     {-# NOINLINE globalVar #-} \
09:21:12 <autrijus>     var = unsafePerformIO $ newIORef ( undefined :: type )
09:21:14 <autrijus> ;)
09:24:03 <musasabi> autrijus: no. make it:
09:24:09 <musasabi> #define global(var, type) \
09:24:23 <musasabi>     {-# NOINLINE var #-}
09:24:35 <autrijus> yeah.
09:24:38 <musasabi>     var :: IORef (type) \
09:24:43 <autrijus> I just noticed that cpp doesn't like #
09:24:58 <musasabi> var = unsafePerformIO (newIORef undefined)
09:26:36 <autrijus> worked around it.
09:40:47 <autrijus> musasabi: the expansion you gave doesn't work.
09:40:51 <autrijus> #define global(var, type, initial, hash) \
09:40:51 <autrijus>     var = unsafePerformIO $ newIORef (initial :: type) \
09:40:51 <autrijus>     {-hash NOINLINE var hash-}
09:40:53 <autrijus> this works.
09:41:03 <autrijus> reason is cpp treats everything as one line
09:41:13 <autrijus> and type signatures can't work that way
09:42:26 <musasabi> hmm, point.
09:42:56 <autrijus> and now initial and type are together, so may be merged into a single param
09:43:02 <autrijus> the final version looks like:
09:43:02 <autrijus> global(_XPageSize, 0::Int, #)
09:43:03 <autrijus> global(_X,         0::Int, #)
09:43:03 <autrijus> global(_Y,         0::Int, #)
09:43:03 <autrijus> global(_IdToFont,  emptyFM::FiniteMap N1 String, #)
09:43:06 <autrijus> works for me. :)
10:08:25 <Victor`> @index isAlpha
10:08:25 <lambdabot> Data.Char,GHC.Unicode,Char
10:49:40 <Lemmih> Victor`: Making progress?
10:53:23 <Victor`> very slowly; i have to add functionality to a pre-made program, but the pre-made program's bugged, strangely enough
11:13:19 <Victor`> hm, i see
11:13:34 <Victor`> it's erroring because i haven't added the new functionality yet :p
11:41:50 <Lemmih> Has anyone experimented with handling C++ exceptions?
11:43:29 <mayhem> compilation of it you mean ?
11:44:52 <Lemmih> I wonder how someone would implement a binding to a C++ function which throws an exception.
11:48:28 <Lemmih>  :: IO (Exception1 [normal result] [type of thrown data])?
11:48:57 <Jon> hi all. I've been learning haskell on and off for 2 years, and I thought I'd return to it today. However hugs throws an error in it's own Maybe.hs when loading a previously fine script of mine (a simple lambda calculus). script avail on request. error was 'Undefined type constructor "Maybe"'. totally stumped!
11:49:01 <musasabi> Lemmih: or convert it to a haskell exception 
11:49:43 <musasabi> Jon: try adding "import Data.Maybe" perhaps (uploading the script somewhere would help)
11:50:37 <Jon> musasabi: http://jon.dowland.name/temp/simple.lhs , cheers I'll try sticking that in the top
11:51:28 <Jon> musasabi: no joy with the import; would you be so kind as to give that a brief look? :)
11:52:42 <Jon> hm peculiar
11:52:45 <Lemmih> musasabi: And how would you handle exceptions of different types?
11:53:10 <Jon> musasabi: works if I try loading it using a diff. method (was dragging and dropping)
11:53:50 <Jon> musasabi: guess it isn't a haskell-language problem after all...
11:53:57 <musasabi> ok.
11:54:25 <Jon> musasabi: thanks anyway.. if I hadn't check the URL I wouldn't have loaded it in a different way so.. ;)
11:55:27 <musasabi> Lemmih: you can use dynamic exceptions or just Either.
11:59:17 <Lemmih> musasabi: An exception in C++ can contain many different types.
11:59:50 <Lemmih> I would need to attach some type info in the Haskell exception.
12:01:02 <musasabi> doing it well is quite hard.
12:01:40 <musasabi> probably catch + typeid + either
12:02:08 <Lemmih> I'll leave exception handling to the user then.
12:03:17 <Victor`> @index alt
12:03:18 <lambdabot> Graphics.UI.GLUT,Graphics.UI.GLUT.Callbacks,Graphics.UI.GLUT.Callbacks.Window
12:03:18 <lambdabot> Text.Html
12:03:53 <musasabi> Lemmih: except that the haskell user can choose between 1) corrupt my stack 2) corrupt my stack ;p
12:04:27 <Victor`> hm, what does the `alt` do in: leesOpdracht = leesLet `alt` leesPrint
12:08:47 <Lemmih> musasabi: I don't follow... you can corrupt the stack with Haskell?
12:09:08 <musasabi> Lemmih: well if the C++ exception is not catched... it will try unwinding the stack...
12:11:48 <arjanb> Victor`: `alt` is an infix function  f a b == a `f` b
12:11:51 <Lemmih> And that's why the user would define her own function for handling the excetion. (:
12:12:01 <Lemmih> *exception
12:14:30 <Victor`> yea i know arjanb, thx, but it's a user defined function then?
12:14:37 <Victor`> cuz i dunno what it does
12:14:38 <Victor`> :P
12:15:02 <arjanb> @index alt
12:15:02 <lambdabot> Graphics.UI.GLUT,Graphics.UI.GLUT.Callbacks,Graphics.UI.GLUT.Callbacks.Window
12:15:02 <lambdabot> Text.Html
12:15:18 <Victor`> hmmm
12:15:30 <arjanb> i think it's user defined one then
12:15:49 <Victor`> ah yea i just found it
13:13:52 <Victor`> finished! thx guys, ttyl
13:21:43 <xerox> Anybody knows about a solution of the skyliner problem in Haskell?
13:24:39 <_Codex> we probably dont know what skyliner problem is. (nor does google.. :)
13:25:30 <xerox> Whoops, it's ``skyline problem'' :)
13:34:43 <_Codex> that gets solved by: generating points/lines + intersection of lines + classifying lines to horizontal and vertical lines + removal of unnecessary lines.
13:38:45 <xerox> _Codex, hm..
13:39:10 <mflux> that sounds quite complex, but maybe I just saw a simplified version of the problem
13:39:28 <xerox> _Codex, what do you mean by "generating points/lines" ?
13:40:12 <_Codex> mflux: I was thinking something like: skyline = rem . classify . intersect . gen :)
13:40:26 <_Codex> mflux: I dont think that's very complex.
13:40:32 <mflux> yes, but still, calculating actual intersections of that set of lines?
13:41:02 <xerox> Uh
13:41:05 <mflux> while you could just order the points by their x-coordinates and build a sky line by keeping track if the next point is a start or an end-point
13:42:11 <Cale> I suppose you could generalise the problem to arbitrary overlapping polygons in the plane in which case determining intersections would probably become necessary.
13:42:14 <mflux> basically evaluating 'max' at aeach point
13:42:19 <Cale> but yeah
13:42:24 <jesse99> hmm, my excursion into template haskell seems to be foundering on unimplemented features
13:42:31 <xerox> I thoung about making a "world" sufficiently big, and putting all the vertices there, then eliminating the unnecessary ones
13:42:52 <xerox> I think I need to sort the building list before, too.
13:43:13 <Cale> I would think build a function representing the skyline from the points, and evaluate it at each of the relevant x coordinates in sorted order, and determine things from that.
13:43:44 <Cale> (as a maximum of a bunch of other functions)
13:43:54 <Cale> almost feels like cheating :)
13:44:07 <xerox> So, sort the buildings, and then translate every bulding in skyline format and eliminate the unnecessary ones upon some condition?
13:44:45 <xerox> I think it would be nice to have a function that puts a building in a skyline, that will solve the problem
13:44:49 <Cale> oh you just leave them in
13:45:45 <xerox> hm..
13:47:31 <xerox> I can't really get it
13:47:33 <Cale> Small buildings which are covered by others will be ignored by the fact that foldr (\f g x -> max (f x) (g x)) over the list of building functions will throw away those values originating from them
13:49:06 <Cale> (foldr1)
13:49:13 <xerox> @type foldr1
13:49:15 <lambdabot> foldr1 :: forall a. (a -> a -> a) -> [a] -> a
13:49:33 <xerox> Cale, the *sorted* list of buildings, right?
13:49:55 <Cale> well, you'll want to sort the endpoints when regenerating the skyline
13:50:02 <xerox> yes
13:52:23 <xerox> Cale, I can't get your foldr1 working
13:52:51 <Cale> and you may want to check one to the left and one to the right of each to see whether each point is a rise, drop, or can be ignored entirely. If the space isn't discrete, then you'll need to get that information elsewhere
13:54:11 <xerox> doesn't the function passed to foldr take 2 arguments?
13:55:22 <Cale> use foldr1
13:55:27 <Cale> chi bs = foldr1 (\f g x -> max (f x) (g x)) (map chi' bs)
13:55:27 <Cale> chi' (l,h,r) | x < l     = 0
13:55:27 <Cale>              | x > r     = 0
13:55:27 <Cale>              | otherwise = h
13:55:39 <Cale> something like that
13:55:47 <xerox> Let me try
13:56:01 <Cale> oops :)
13:56:07 <xerox> no, it's ok!
13:56:19 <Cale> left an extra param out of chi'
13:56:21 <xerox> Let me try using it, I can't do it myself, it seems :-\
13:56:24 <Cale> needs an x :)
13:57:08 <xerox> hm?
13:57:11 <xerox> chi' too
13:57:33 <xerox> (And, what does "chi" means?)
13:57:56 <Cale> characteristic function :)
13:58:08 <Cale> chi is a greek letter
13:59:02 <Cale> you can call it something more descriptive if you like of course
13:59:09 <Cale> so if you call for example
13:59:15 <Cale> let f = chi [(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22), (23,13,29), (24,4,28)]
13:59:37 <Cale> then (f n) will tell you the height of the skyline at n
13:59:48 <Cale> then you just need to recompose things
14:00:49 <xerox> Are these "chi x bs" and "chi' x (l,h,r)" ?
14:01:12 <Cale> chi bs x
14:01:18 <Cale> er
14:01:24 <Cale> chi bs = foldr1 (\f g x -> max (f x) (g x)) (map chi' bs)
14:01:24 <Cale> chi' (l,h,r) x | x < l     = 0
14:01:24 <Cale>                | x > r     = 0
14:01:24 <Cale>                | otherwise = h
14:01:29 <Cale> that code works :)
14:01:43 <Cale> I missed the x in chi' last time
14:02:13 <xerox> Uh
14:02:16 <xerox> It really works
14:02:19 <Cale> :)
14:02:23 <xerox> I just have to understand HOW and WHY :D
14:02:27 <Cale> :)
14:02:30 <Cale> hehe
14:02:36 <xerox> hm hm hm hm hm
14:02:43 <Cale> okay so what happens when you evaluate chi bs 5 ?
14:03:41 <Cale> For each b in bs it applies chi' to b, and takes the max of the results
14:03:52 <xerox> It says 13
14:04:11 <xerox> There is some point-free argument there
14:04:18 <Cale> yeah
14:04:35 <Cale> the foldr1 is folding a list of functions into a new function which is their maximum
14:05:01 <xerox> (map chi' bs) is the first thing done, right?
14:05:07 <Cale> right
14:05:24 <Cale> that takes a building and makes a function out of it
14:05:30 <Cale> each*
14:05:31 <xerox> manually mapping chi' over a list doesn't work
14:05:44 <Cale> it should
14:05:47 <xerox> Err, I can't get it work.
14:05:51 <Cale> it will give you a list of functions
14:05:53 <xerox> That's different, I know eheh
14:06:05 <Cale> you'll have to extract one in order to apply it to a value
14:06:33 <Cale> you might have trouble printing such a list of course :)
14:06:39 <xerox> like (map chi' bs) 5
14:06:39 <xerox> ?
14:06:48 <xerox> Yes the problem is with Show
14:06:57 <Cale> map ($ 5) (map chi' bs)
14:07:18 <xerox> hmm..
14:07:31 <Cale> $ is function application
14:07:35 <xerox> so the result of mapping chi' are partial applications?
14:08:08 <Cale> yeah
14:08:14 <xerox> Interesting
14:08:30 <Cale> chi' takes a building and produces a function which takes a point and if the point is in the building, returns the height of the building, and 0 otherwise
14:08:47 <xerox> AH! That's smart.
14:09:47 <Cale> we then join those functions together using (\f g x -> max (f x) (g x))
14:10:05 <xerox> giving a point
14:10:14 <Cale> which is a function that takes two functions and gives a function which given a point, tests each of the functions at that point at returns the max
14:12:03 <xerox> I got it
14:12:34 <xerox> folding makes the max working on the entire list
14:12:42 <Cale> right
14:13:23 <xerox> Hmm
14:14:02 <xerox> How does it help knowing the highes point in some coord?
14:14:32 <Cale> well, those are what tell you your skyline
14:15:23 <Cale> if you test one to the left and one to the right of each endpoint, you'll have enough information to rebuild the skyline
14:15:49 <xerox> So I have to sort the buildings
14:15:59 <xerox> Sorry, misread
14:16:18 <xerox> each endpoint = each building?
14:17:26 <Cale> just do something like uniq $ sort (bs >>= \(l,h,r) -> [l-1,l,l+1,r-1,r,r+1])
14:17:46 <Cale> er
14:17:48 <Cale> nub :)
14:17:54 <xerox> UH
14:17:58 <Cale> :)
14:18:05 <Cale> I shouldn't be so harsh :)
14:18:09 <xerox> *clear* :D
14:18:29 <Cale> hehe
14:18:31 <xerox> @index uniq
14:18:32 <lambdabot> bzzt
14:18:36 <xerox> @index sort
14:18:37 <lambdabot> Data.List,List
14:18:38 <Cale> uniq doesn't exist :)
14:18:43 <Cale> @index nub
14:18:44 <lambdabot> Data.List,List
14:19:04 <xerox> HM
14:19:10 <xerox> Can you explain me that line of code?
14:19:32 <xerox> The output i see it's the same as [0..30]
14:19:40 <Cale> yeah
14:19:51 <xerox> argh, so why you did it that way? 
14:19:53 <xerox> ^__^
14:19:59 <Cale> well
14:20:05 <Cale> @type (>>=)
14:20:07 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
14:20:19 <Cale> okay, in the specific case of lists
14:20:39 <Cale> (>>=) :: [a] -> (a -> [b]) -> [b]
14:20:56 <xerox> Hm
14:20:59 <xerox> why not map ?
14:21:03 <xerox> @type map
14:21:04 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
14:21:21 <xerox> Is it a sort of (flip map) ?
14:21:30 <Cale> that is, it takes a box of apples, and a function from apples to boxes of blueberries, and turns each apple into a box of blueberries and pours the boxes together again :)
14:21:53 <xerox> ahah thanks for the language, i need simple explanation in fact :)
14:23:06 <xerox> Hm OK, I think I got iy
14:23:07 <xerox> *it
14:23:36 <Cale> try [(1,2,1), (50,3,55)] >>= (\(l,h,r) -> [l-1,l,l+1,r-1,r,r+1])
14:24:11 <xerox> [0,1,2,0,1,2,49,50,51,54,55,56]
14:24:19 <xerox> Ok..
14:25:08 <Cale> it takes the endpoints, and expands each endpoint into the 3 points centred on it
14:25:33 <Cale> there's possibly a better way to keep track of things, but this seems like it should work decently
14:25:45 <Cale> perhaps we just need the point and the point immediately before
14:25:56 <CosmicRay> MegaMonad: good afternoon
14:25:56 <MegaMonad> CosmicRay: Bash does suck at picking up sulphur from the test pic with three letters in different manners.
14:26:03 <xerox> Cale, I see
14:26:14 <xerox> That's the list of the "interesting" points
14:26:19 <Cale> yeah
14:26:27 <xerox> (the nubbed $ sorted one)
14:26:31 <Cale> yeah
14:26:32 <xerox> WOW.
14:26:39 <xerox> :)
14:27:19 <Cale> we might be able to be a little more direct
14:27:25 <Cale> hmm...
14:29:21 <xerox> map (chi bs) (points bs)
14:29:30 <xerox> It's more or less the solution, now
14:29:48 <Cale> yeah
14:29:56 <Cale> you just need to simplify
14:29:57 <xerox> That's terrific
14:30:08 <xerox> zipping, maybe
14:30:22 <Cale> and don't forget to keep track of the x coordinates -- you just lost them there :)
14:30:32 <xerox> oh, yes
14:30:38 <xerox> hmm..
14:31:25 <Cale> Haskell is almost the perfect language for contest type things. :)
14:31:38 <xerox> It's impressive
14:31:56 <xerox> Your speed in resolving the problem is impressive, too
14:32:20 <Cale> thanks :)
14:32:56 <xerox> map (\x -> (x,chi bs x)) (points bs)
14:32:56 <xerox> ?
14:33:19 <Cale> yeah, something like that
14:33:26 <xerox> Whoa
14:33:35 <xerox> Now the semplification
14:33:39 <xerox> hrmm
14:33:50 <xerox> folding again?
14:34:04 <Cale> you just need to take the first (x,y) pair with a particular y value in a given run
14:34:55 <Cale> hmm, depending on the way that your problem is stated, you might also need to add some points which you wouldn't otherwise see
14:35:07 <Cale> i.e. the lower left/right corners
14:35:26 <Cale> but everything you need is there
14:35:59 <xerox> I only need the variations
14:36:27 <xerox> for [(1,3,4)] I should get [(1,3),(4,0)]
14:36:54 <xerox> for [(1,3,4),(2,2,6] I should get [(1,3),(4,2),(6,0)]
14:37:08 <xerox> err, ) after 2,2,6 obviously
14:37:19 <Cale> ah
14:38:56 <Cale> hmm... :)
14:39:17 <xerox> eheh!
14:39:41 <Cale> so now just which transformations on the list we have
14:40:32 <Cale> I think we'll need to look at each triple of (x,y) coordinates and possibly write a new one
14:41:00 <strr> Hi 
14:41:04 <Cale> or possibly just each pair
14:41:09 <xerox> Hm 
14:41:18 <xerox> if snd x == snd y then x else ... ?
14:41:37 <Cale> something like that :)
14:41:56 <Cale> using guards and pattern matching is probably cleaner
14:42:01 <strr> The answer for this list a = [a*b | a <- [1..4], b <- [1..a]] is [1,2,4,3,6,9,4,8,12,16] can someone please help me explain how it came to this answer
14:42:04 <xerox> ah, okie
14:42:04 <Cale> (just syntax)
14:42:16 <strr> was it 1*1 etc
14:42:33 <Cale> strr: for each a in [1..4], for each b in [1..a], a*b
14:42:53 <Cale> you can also write that as
14:42:58 <Cale> do a <- [1..4]
14:43:03 <Cale>    b <- [1..a]
14:43:10 <Cale>    return (a * b)
14:43:26 <strr> Cale I understand that part but i dont understand [1..a] i think this is 1 to 10 right how dod it calculate the values
14:43:42 <xerox> strr, a goes from 1 to 4
14:43:55 <Cale> the b values in order are:
14:44:00 <Cale> 1,1,2,1,2,3,1,2,3,4
14:44:02 <joao> Hello
14:44:08 <Cale> hello
14:44:13 <xerox> hi!
14:44:17 <joao> Does anyone here has experience with hs-plugins? :9
14:44:19 <strr> sorry yeah 1 to 10 so it does 1*1 1*2 2*2 right?
14:44:37 <Cale> I don't have much direct experience with it, but I read the docs at one point
14:44:58 <strr> i mean 1 to 4
14:45:00 <Cale> 1 * 1, 2 * 1, 2 * 2, 3 * 1, 3 * 2, 3 * 3, 4 * 1, 4 * 2, 4 * 3, 4 * 4
14:45:50 <joao> I'm having a problem I can't understand... When I try to load another module dinamically, I get a message saying "Failed to load interface for `ByteArray':"
14:46:46 <Cale> hmm...
14:47:25 <strr> so it does 2 2 time and 3 3 times 4 4 times is that right cale
14:48:07 <Cale> strr: yeah, sort of
14:48:09 <xerox> Cale, four lines, doesn't work, can I paste it?
14:48:14 <Cale> xerox: okay
14:48:21 <xerox> skyline [] = []
14:48:21 <xerox> skyline (x:y:xs) = if snd x == snd y
14:48:21 <xerox> 		   then x:(skyline xs)
14:48:21 <xerox> 		   else x:y:(skyline xs)
14:49:00 <Cale> well, this will remove flat sections
14:49:11 <Cale> but you might not get exactly what you're looking for
14:49:17 <xerox> It raises: Non-exhaustive patterns in function skyline
14:49:19 <strr> cale is this the same b = [(x+y) | x <- [1..10], y <- [1..x]]
14:49:20 <Cale> oh
14:49:35 <Cale> right, you don't handle the case [x]
14:50:15 <Cale> strr: that will go through x from 1 to 10, and for each x, it will take y from 1 up to x, and give x + y
14:50:20 <xerox> Hm, okay
14:51:00 <xerox> It doesn't work well, btw
14:51:29 <Cale> you might need to do some funky things with decrementing the x coordinates
14:51:41 <xerox> skyline [(0,0),(1,11),(2,11),(3,13)] => [(0,0),(1,11),(2,11),(3,13)]
14:51:45 <xerox> uh
14:51:55 <xerox> funky thigs seems to be your sport (-;
14:52:14 <Cale> well, that's what it was told to do :)
14:52:35 <xerox> ^_^
14:52:37 <Cale> er
14:55:29 <Cale> currently you're only comparing even ones and odd ones
14:55:50 <Cale> well, (1,2), (3,4), (5,6) are being compared
14:55:59 <Cale> if you know what I mean
14:56:20 <xerox> HMM..
14:57:17 <Cale> the recursion is just a little off :)
14:57:42 <xerox> Okay :)
14:57:54 <xerox> I see that I'm not comparing all the pairs
14:58:17 <strr> cale what does this do foo list = [x | xs <- list, x <- xs]
14:58:32 <strr> i saw it in a example prog
14:59:09 <Cale> strr: try foo [[1,2,3],[4,5],[6,7,8]] in an interpreter
14:59:18 <strr> k thanks
14:59:35 <Cale> or even in your head :)
15:00:20 <xerox> HM..
15:04:55 <Cale> xerox: the recursion is a little tricky, and we actually still won't have it right :)
15:05:06 <Cale> but it's easily correctible :)
15:05:52 <Cale> do you want to see my code?
15:05:56 <xerox> Sure
15:06:02 <xerox> Hoping I'll understand :D
15:06:31 <strr> In simple terms does this take the head from each list and puts it into a new list foo list = [x | xs <- list, x <- xs] 
15:08:08 <Gahhh> no, why would it take the head ? 
15:08:27 <strr> because it has x written there ? how else would u read it 
15:08:41 <Gahhh> it doesn't have "head" written there/
15:09:00 <Gahhh> tell me the type of the functions argument.
15:09:14 <Cale> skyline' [] = []
15:09:14 <Cale> skyline' [x] = [x]
15:09:14 <Cale> skyline' (x:y:xs) | snd x == snd y = skyline' (x:xs)
15:09:14 <Cale>                   | otherwise      = x : skyline' (y:xs)
15:09:24 <Cale> however, there are at least 2 problems with this :)
15:09:32 <strr> foo :: [[a]] -> [a] 
15:10:03 <Cale> one is that when the skyline drops, we record the x coordinate too late
15:10:34 <Cale> the other is much more frustrating :)
15:10:40 <Cale> (well, not that much more)
15:10:44 <Gahhh> strr, correct type. Now, why would you think that the function would not take all the members of a list, instead of just the head ?
15:11:03 <Gahhh> Cale, is that the skyline problem at acm.uva.es ?
15:11:24 <Cale> Gahhh: yeah :)
15:11:24 <ski> strr : that flattens (i.e. concat) the input list
15:11:36 <strr> Gahhh how did you figure out the type of it - I got the type from the example prog - if that wasnt there how would i figure it out 
15:11:44 <xerox> Cale, hmmm..
15:11:44 <Cale> just working through it with xerox 
15:12:05 <Gahhh> Cale, I solved that one. Haskell makes possible a beautiful solution. I don't even wanna think about how to do it via iteration.
15:12:07 <Cale> xerox: consider what happens when there's a gap of one space between two buildings :)
15:12:37 <xerox> Let me try
15:13:10 <Gahhh> strr, well, your input arg is [xs], right ? and then you try to perform "<-" on "xs". That gives away that xs is a list, too.
15:14:12 <xerox> Cale, let bs = [(1,2,3),(5,2,3)] ; let foo = map (\x -> (x,chi bs x)) (points bs) ; skyline' foo ==> [(0,0),(1,2),(4,0)]
15:14:14 <xerox> hmmm!!
15:14:19 <Crikey> Trying to learn Haskell from "The Craft of Func Progammig" book is annoying. The book is full of errors
15:14:34 <Cale> xerox: so really, we need to sample a little tighter
15:14:54 <Cale> 1/2 off each endpoint will be enough, and we don't need to sample at the endpoints
15:14:56 <xerox> Cale, foo is [(0,0),(1,2),(2,2),(3,2),(4,0),(5,0),(6,0)] in this case, is it correct??
15:14:56 <Crikey> First it seems ord isn't in Prelude but Char. The book talks about fromInt, but that doesn't seem to exist. fromIntegral 
15:15:13 <xerox> uh sorry, I made a mistake
15:15:26 <Gahhh> Crikey, when was that book published ?
15:15:51 <Crikey> Gahhh, It's the 2nd Ed published in 99
15:16:11 <psi> Crikey: i've used that book too, and those were the only errors I found
15:16:36 <psi> i thought it was good in general
15:16:41 <Crikey> I gave up on the SOE book as the gaphics library is impossible to get working
15:16:54 <Crikey> with the latest versions of Haskell
15:17:36 <strr> 1 * 1, 2 * 1, 2 * 2, 3 * 1, 3 * 2, 3 * 3, 4 * 1, 4 * 2, 4 * 3, 4 * 4 why does 3 not do 3*4 ?
15:17:57 <Cale> strr: because 4 > 3
15:18:05 <Cale> so it's not in [1..3]
15:18:15 <Cale> i.e. not in [1..a]
15:18:41 <Cale> samples bs = map (\x -> (x, chi bs (x - 1/2), chi bs (x + 1/2))) (bs >>= \(l,h,r) -> [l,r])
15:18:52 <strr> cale why was 2*3 done then 
15:19:02 <Cale> It wasn't
15:19:07 <Cale> 3 * 2 was
15:19:23 <Gahhh> Crikey, have you seen the "Yet Another Haskell Tutorial" ?
15:19:35 <xerox> Cale, hmm ?
15:20:14 <Cale> xerox: that's the relevant information for constructing the skyline. If we sample the function only at integer values, then it will miss gaps like that
15:21:14 <xerox> Cale, right, I see it 
15:21:26 <xerox> Why the + and - 1/2 ?
15:21:47 <Cale> because we just want to know the height a little to the left and a little to the right of the corners
15:22:48 <Cale> this is also rather convenient for getting rid of irrelevant data
15:23:02 <Cale> (x, y, y') gets deleted if y == y'
15:24:21 <Cale> and we can now tell if there's a rise or a fall at x.
15:24:29 <Crikey> Gahhh, No where is this "Yet Another Haskell Tute"? 
15:24:33 <xerox> Cale: I'm little lost, sorry
15:24:37 <Cale> okay
15:24:46 <Cale> so we start off with our chi function
15:24:52 <Cale> for the skyline
15:24:59 <Crikey> I am trying to pick up Haskell so I can work on some Darcs code. It is truely a great source code contol system. 
15:25:00 <Gahhh> Crikey, it's online. Google it.
15:25:12 <Crikey> Though being written in Haskell it makes it a steep learnign curve to contribute
15:25:12 <Cale> at each x-coordinate, there might be a rise or a fall
15:25:17 <Gahhh> Oh, that's interesting.
15:25:24 <Cale> (bs >>= \(l,h,r) -> [l,r])
15:25:31 <xerox> Cale, ok
15:25:41 <Cale> that picks out all the x coords
15:26:07 <xerox> Yes
15:26:21 <Cale> now, for each one of those, we look at the value of our characteristic function, a little to the left and a little to the right of x
15:30:13 <xerox> ok
15:32:10 <xerox> why "a little" instead of "the previous and the next x coord" ?
15:33:37 <Cale> well, we want to catch things like 1-wide gaps between the buildings
15:33:57 <strr> can some one give me an idea how I would program the result :- interleave [1,3] [2,4,6,8] = [1,2,3,4,6,8]
15:35:20 <xerox> Cale, hmm ok
15:37:54 <whee> strr: looks like a merge sort?
15:38:26 <strr> whee is that hard to program
15:38:40 <whee> not at all
15:38:45 <strr> does it involve alot of programming
15:38:55 <strr> whee can u show me a quick examp,e
15:39:40 <xerox> Cale, any solution?
15:40:03 <Cale> well, what I have so far...
15:40:26 <xerox> Cale, hmpf, 00:39 and they want me to go to sleep :(
15:40:41 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show
15:41:49 <whee> strr: if the two arguments to interleave are always sorted, just grab the heads of both lists and take the smaller and keep recursing until you've gone through both lists
15:41:51 <Cale> then you just need to take each triple and split it up like ts >>= \(x,y,z) -> [(x,y),(x,z)]
15:42:02 <Cale> in fact, you could do this in samples
15:42:21 <whee> it's almost a merge sort :P
15:43:18 <Cale> hmmf, not quite :)
15:43:22 <xerox> Cale, map (\(x,y,z) -> [(x,y),(x,z)]) (samples bs) ??
15:45:51 <desrt> xerox; that will give you lists of lists
15:46:01 <desrt> cale's gives you a list
15:46:22 <Cale> desrt: yeah, it's not quite what we want anyway
15:46:55 <xerox> Thanks so much Cale
15:46:56 <Cale> the current irc paste page on the wiki has the solution :)
15:46:57 <xerox> goodnight folks
15:47:00 <Cale> no problem
15:47:21 <desrt> who is doing icfp this year?
15:47:50 <Cale> skyline problem in 11 lines :)
15:48:05 <Cale> and they're mostly short lines
15:50:33 <wagle> heh..  the only google for "firm typing" is shapr, here, wanting it..  8) 8/
16:02:06 <strr> Hi can someone tell me an easy way to work out types for lists i.e. foo list = [x | xs <- list, x <- xs]
16:04:12 <ski> asking your haskell implementation ?
16:04:32 <strr> yeah
16:04:39 <Philippa> for lists, or for list comprehensions?
16:04:57 <Philippa> for lists more generally, it's exactly the same as any other type - for list comprehensions it helps to know how the comprehension's translated
16:05:47 <strr> how would you figure out what the type of foo list = [x | xs <- list, x <- xs] is
16:05:49 <strr> foo list = [x | xs <- list, x <- xs]
16:06:06 <Philippa> by translating the comprehension into an ordinary expression and doing the usual H-M thing
16:06:32 <ski> for a generator such as "xs <- list" the RHS must be a list, and the LHS have the corresponding element type
16:07:12 <strr> the type for foo is foo :: [[a]] -> [a]   how did it come to foo :: [[a]] -> [a]  
16:07:19 <ski> so  list :: [a]  , for some type  a  and  xs :: a  for that same type  a
16:07:28 <strr> oh right 
16:07:39 <ski> then you do  "x <- xs"
16:07:56 <strr> why does the first arbitry type have more than one bracket [[a]]
16:08:07 <ski> so xs :: a  must actually be a list, i.e.  xs :: [b]   which implies a = [b]  and list :: [[b]]
16:08:38 <ski> understand ?
16:09:35 <strr> hold on 
16:09:38 <strr> please
16:09:38 <ski> mm
16:09:43 <ski> sure
16:11:45 <strr> ski is this the steps
16:11:56 <strr> we look at list we know it is a list of type a 
16:12:09 <strr> then there is another list called xs which is also of type a 
16:12:14 <strr> is that correct so far?
16:12:46 <ski> not quite
16:13:15 <ski> the "xs <- list" kind of construction inside a list comprehension is called a 'generator'
16:13:27 <ski> for such list comprehension generators
16:13:36 <strr> k
16:13:44 <ski> (if there is no type error)
16:14:29 <strr> so for this foo x ys = length [y | y <- ys, y == x] > 0
16:14:32 <strr> the type is
16:14:47 <ski> the right-hand-side, here "list", have type "[a]" and the left-hand-side, "xs" have type "a",  for some type "a"
16:15:20 <strr> oh i see
16:15:34 <strr> for above would it be [a] - > a
16:15:44 <ski> sorry ?
16:15:56 <strr> the type for this foo x ys = length [y | y <- ys, y == x] > 0
16:16:00 <strr> would it be 
16:16:06 <strr> [a] - > a
16:16:10 <ski> almost
16:16:14 <strr> oh 
16:16:18 <ski> foo has an "x" arg also
16:16:18 <strr> [a] - > a -> Bool
16:16:36 <ski> .. other order ..
16:16:47 <strr> oh i see
16:17:03 <strr> lastly for practise this one bar xs = [x | (x,n) <- zip xs [1..], odd n]
16:17:05 <strr> would it be 
16:17:08 <ski> and then one final detail
16:17:16 <ski> hm, continue
16:17:40 <strr> a -> [a] -> a
16:18:05 <ski> for (last) foo or for bar ?
16:18:16 <strr> for bar 
16:18:47 <strr> for foo it would be a -> [a] ->Bool
16:18:48 <ski> sorry, but no
16:18:57 <ski> bar has only one argument
16:19:30 <strr> oh so you should look at the left hand side for the input argu
16:19:35 <strr> so then it would be 
16:19:38 <ski> yep
16:19:44 <strr> [a] -> a
16:20:09 <ski> and it's still not correct
16:20:12 <strr> [a] -> [a]
16:20:22 <ski> better :)
16:20:30 <strr> got there at last
16:21:10 <strr> thanks for the help
16:21:15 <ski> (you have to wrap a final [ ] around the type of the expression to the left of the "|" in the list compr.)
16:21:19 <ski> np
16:21:36 <ski> but you're still missing a detail regarding foo
16:22:06 <ski> (==) doesn't have type   a -> a -> Bool
16:22:49 <strr> ski can you tell me what it would be so i can check where i went wrong
16:23:53 <ski> @type (==)
16:23:55 <lambdabot> (==) :: forall a. (Eq a) => a -> a -> Bool
16:24:10 <ski> it only works for types "a" in type class "Eq"
16:24:25 <ski> only those can be compared with (==)
16:24:34 <strr> oh right I understand - so if i see the sign == i should add an equality check 
16:24:50 <ski> so, if you add a final "Eq a =>" constraint at the top left of the type it should be correct
16:24:54 <ski> yep
16:25:06 <strr> I see
16:26:02 <ski> either add such a generic constraint, or, if it suits the problem, you could also specialize to a type already known to be in Eq (e.g. Int or whatever) (or mayhaps change to a constraint that implies Eq)
16:26:15 <strr> oh right 
16:26:29 <ski> same with (<),(<=),...  except then it'd be Ord
16:26:44 <ski> and so on
16:27:11 <ski> same with all things (type class) overloaded
16:29:34 <strr> why cant null tail [1,2,3,4] be done?
16:30:02 <ski> possibly because of missing parens ?
16:30:42 <strr> *** Expression     : null tail [1,2,3,4]
16:30:42 <strr> *** Term           : null
16:30:42 <strr> *** Type           : [d] -> Bool
16:30:42 <strr> *** Does not match : a -> b -> c 
16:31:27 <strr> is it because null is expecting just a list
16:31:58 <ski> the error msg says that null *one* argument, but you try to give it two args (a function and a list)
16:32:17 <ski> s/null/null wants/
16:32:53 <strr> oh right so it expect just one argument
16:32:59 <ski> yep
16:32:59 <strr> i mean just requires a list
16:33:05 <ski> yep
16:34:09 <ski> see your prob yet ?
16:34:18 <ski> wb strr/Mtta
16:34:36 <Mtta> comp crashed
16:34:40 <ski> oh
16:34:46 <Mtta> yeah i took of tail
16:35:53 <ski> ok ?
16:36:00 <Mtta> yeah it worked 
16:36:07 <Mtta> ski do you work in programming
16:36:26 * ski is a student
16:36:34 <ski> :)
16:36:38 <Mtta> oh i see 
16:36:44 <Mtta> what do you do>
16:36:59 <ski> ?
16:37:03 <Mtta> as in course
16:37:05 <ski> i study C.S.
16:37:12 <Mtta> ski can i pm?
16:37:13 <psi> Mtta: you do realize that you can still use tail there, right? you just need to do null (tail list)
16:37:44 <Mtta> oh right i see thanks psi
19:20:21 <wli> It was probably unanticipated and the lead time on pulling that off turned out to be too far out or some such crap. Who knows.
19:46:00 <SyntaxNinja> hi CosmicRay
19:46:19 <CosmicRay> good evening SyntaxNinja 
19:57:16 * SyntaxNinja hacks on ./setup haddock
20:08:03 * SyntaxNinja done
20:22:15 <Darius> Hey Pseudonym, look at WrapperTypes (on the wiki) 
20:23:02 <Darius> I'm leaving right now though
20:27:30 <Pseudonym> I did.  Very nice.
20:27:53 <Pseudonym> And I realise you've left.  Most people say bad things about people behind their backs.  I say nice things!
20:27:58 <Pseudonym> Well done Darius!
20:28:26 * SyntaxNinja likes Darius... when he leaves ;)
20:28:54 <SyntaxNinja> so the cabal Setup.description file is going to move :(
20:29:02 <SyntaxNinja> I'm going to allow Setup.description with a warning for a while now.
20:29:20 <SyntaxNinja> it'll now probablyi be <package>.cabal or <package>.hsproj, where <package> is actually anything whatsoever and it just looks for *.cabal
22:08:42 <musasabi> morning
22:09:15 <Lemmih> Good morning, musasabi.
22:15:11 <Oejet> Good morning.
22:16:40 <Lemmih> Oejet: You're up early. (late perhaps?)
22:17:25 <Oejet> He, I woke up over an hour ago by my self.  Really odd.  I must have had some nightmare.
22:19:38 <musasabi> We had some truck outside waking us up. And because it was 7:30 we decided to just make coffee.
22:19:55 <Gahhh> Does that mean you were alone when you woke up, or are you usually woken up by others ?
22:20:30 <Oejet> Gahhh: Me?
22:21:15 <musasabi> btw how should one do counters with STM?
22:21:24 <Gahhh> Oejet, yeah
22:23:11 <Oejet> Gahhh: Yes, I was quite alone.  And it's dark also.  It happens rarely to wake up and feel awake at 5:30 for no apparent reason.
22:24:16 <Gahhh> Oejet, I haven't felt awake in years... :)
22:24:42 <Oejet> musasabi: How about something like:
22:25:05 <Oejet> newCounter x = newTVar x
22:25:54 <musasabi> Oejet: that really kills the concurrency.
22:26:40 <musasabi> Oejet: e.g. I have a hashtable to which I perform inserts. Normally inserts to different parts of the table could occur concurrently - but I need to maintain a count how full the table is.
22:26:48 <Oejet> incCounter v = do { x <- readTVar; writeTVar v (x+1) }
22:27:02 <musasabi> Oejet: if inserts update that (shared) count, then their concurrency will go to hell.
22:27:37 <musasabi> Oejet: unsafeIoToSTM + IORef may do the deed, but I am not sure that is very good.
22:28:46 <Oejet> musasabi: Well, isn't the idea that atomic (incCounter v) in two threads are mutual exclusive?
22:29:29 <musasabi> Oejet: but without the counter two threads could do an insert concurrently 99% of the time.
22:30:01 <musasabi> Oejet: with the counter they have to be serialized allways.
22:30:22 <musasabi> *-l
22:30:58 <Oejet> So you want smaller "critical regions"?
22:31:22 <musasabi> yes, (or a well defined increase operation)
22:32:00 <Oejet> Could you come up with an example?
22:32:47 <musasabi> of smaller critical regions or the semantics of a STM increase operation?
22:34:05 <Oejet> I meant from your hashtable code with the increase operation.
22:34:56 <musasabi> data Hash k v = { ht :: Array Int [(k,v)], hfun :: k -> Int, count :: XXX }
22:35:25 <musasabi> type HashTable k v = TVar (Hash k v)
22:36:16 <musasabi> insert tv = do (Hash ht hfun count) <- readTVar tv 
22:37:35 <musasabi>                if count > loadFactor * tableSize ht then resize else increase_count_by_1
22:38:28 <musasabi> (that goes wrong - I'll paste just a link)
22:39:10 <Oejet> Hm, it looks ok from what I've understood from the article.
22:39:55 <Oejet> Thread 1: atomic (insert tv 3),  thread 2: atomic (insert tv 2).
22:40:27 <Oejet> Will be run mutual exclusively
22:40:41 <musasabi> http://youzen.b2.fi/~musasabi/a.hs
22:41:22 <musasabi> But I want to avoid mutual exclusion if they happen to different buckets
22:42:00 <Oejet> Ok, that is clear.
22:42:50 <Oejet> So is that code working correctly, but "slowly"?
22:43:08 <musasabi> because otherwise I could just have "data HashTable k v = MVar (FiniteMap k v)"
22:43:12 <musasabi> yes.
22:44:42 <Oejet> Ah, of course.  And MVar could just be implemented as in the article.
22:46:10 <Oejet> Maybe what you want is to have each bucket be in a TVar.
22:49:24 <Oejet> musasabi: Well, you have already it seems.
22:49:24 <musasabi> (see the link - that has each bucket as a tvar)
22:49:31 <Oejet> :-P
22:49:37 <musasabi> Oejet: but the count is shared.
22:49:46 <musasabi> and all inserts write to it.
22:49:55 <musasabi> so that kills of the concurrency.
22:50:29 <Oejet> I am beginning to understand the problem now.
22:50:49 <musasabi> Can I have hashtables without global counts or implement them without forcing serialization of all inserts.
22:52:37 <shapr> wagle: what are you doing with firm typing?
22:52:56 <musasabi> An increment operation for STM is well defined. When Inc is committed it is retried if there was a write (retry - decrease + retry transaction), Incs make reads and writes abort. Incs don't make other Incs abort.
22:53:18 <musasabi> but doing it within the current model would be much nicer.
22:54:12 <Oejet> Yes, it seems very clean that way.
22:55:50 <shapr> good morning #haskell!
22:55:52 <Oejet> Have you benchmarked it?
22:56:46 <musasabi> Oejet: I can produce real benchmarking data - just a few results currently.
22:57:44 <Oejet> My impression was that STM would have you worry less about critical regions.
22:58:41 <musasabi> yes it does. That is just suboptimal in this case.
23:04:20 <Oejet> Alternatively maybe: insert' tv key val = do { atomic(incCounter tv); atomic(insert tv key val) }
23:04:34 <Oejet> Hm, no.
23:05:14 <musasabi> Oejet: that would kill of the benefits of STM.
23:05:24 <Oejet> Indeed.
23:05:42 <musasabi> Oejet: mainly that you couldn't do multiple operations in a transactional way.
23:05:56 <musasabi> BTrees may be a solution.
23:11:20 <shapr> hiya e-nomad 
23:13:23 <shapr> g'bye!
23:23:57 <adept> hello there
23:24:25 <musasabi> hello
23:29:01 <Oejet> Bye.  Have a nice day.  (I
23:29:23 <Oejet> t's a nice problem that insert in STM.
23:52:26 <Itkovian> meuning.
