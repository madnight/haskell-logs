00:34:15 * araujo eating ponquesitos
00:40:06 * kristnjov throws an exception error at araujo
00:43:40 <araujo> :-P
00:47:06 * araujo should get two more ponquesitos
01:28:12 * Oejet likes Parsec.
01:36:13 <Oejet> What does "*14( SPACE middle )" in the context of EBNF?  I guess, if SM=( SPACE middle ), then it means zero or more of blocks of SM, each of which has a length of 14.
01:58:05 <Oejet> Hmm, is there a function "atMost1 s" in Parsec which parses a most one instance of "s", that is "[ s ]" ?
02:02:06 <balbo_> how can i flatten a list of lists into on big list?
02:03:52 <Oejet> @type flatten
02:03:53 <lambdabot> bzzt
02:04:04 <balbo_> nice try
02:04:10 <balbo_> @type concat
02:04:11 <lambdabot> concat :: forall a. [[a]] -> [a]
02:04:22 <balbo_> i think this may be the one...
02:35:38 <balbo_> anyone that know how to resolve  "garbage collection fails to reclaim sufficient space" in hugs?
02:36:15 <ski> maybe fix leakage bug ?
02:36:39 <ski> or start hugs with more heap memory (should be a cmd line flag, i think)
02:36:52 <ski> what are you trying to do ?
02:37:11 <balbo_> i'm trying to recursively draw some shapes on my screen.
02:38:08 <balbo_> how can there be leakage when hugs has garbage collection?
02:38:09 <kristnjov> have you made sure they stop drawing at some point?
02:38:11 * ski got busy atm
02:38:57 <balbo_> yes, i've set a minimum size. if i set i high enough then there is no error. but the shapes are not small enough.
02:40:58 <kristnjov> perhaps if you showed us some code?
02:41:15 <balbo_> where can i paste it?
02:41:19 <kristnjov> www.nomorepasting.com
02:41:21 <kristnjov> for example.
02:41:38 <balbo_> ok. i will try
02:41:58 <balbo_> is there a more specifik link?
02:42:19 <balbo_> there is no real haskell section
02:42:25 <balbo_> but i'll try anyway
02:42:42 <kristnjov> just try pasting it as plain text or something
02:42:46 <arjanb> lisppaste2: url?
02:42:47 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
02:43:30 <balbo_> ok. this is my pase. http://www.nomorepasting.com/paste.php?pasteID=29360
02:44:11 <balbo_> it's the snowflake fractal exercise from hudaks book
02:46:56 <balbo_> how can i give hugs a hint to start garbage collection?
02:47:33 <Heffalump> does it have performGC :: IO ()
02:47:34 <Heffalump> ?
02:48:38 <balbo_> let me see...
02:49:19 <balbo_> not in the prelude at least.
02:50:28 <balbo_> @index List
02:50:29 <lambdabot> bzzt
02:50:42 <balbo_> @type List
02:50:44 <lambdabot> bzzt
02:51:07 <balbo_> @infex performGC
02:51:07 <lambdabot> Sorry, I don't know the command "infex", try "lambdabot: @listcommands"
02:51:13 <balbo_> @infed performGC
02:51:14 <lambdabot> Sorry, I don't know the command "infed", try "lambdabot: @listcommands"
02:51:18 <balbo_> @index performGC
02:51:19 <lambdabot> System.Mem
02:53:42 <bourbaki> hey TheHunter :)
02:55:10 <TheHunter> moin bourbaki 
02:56:47 <bourbaki> TheHunter: did you think about that data problem a bit more?
03:00:07 <TheHunter> bourbaki, i think the most important decision is how to represent your graph and how parts of the graph are referenced "from within"
03:01:20 <balbo_> i got it working by increasing heap size. but probably my solution is terribly inefficient.
03:22:50 <ski> balbo_ : (re leakage and GC) there is a notion of leakage applicable to langs with GC, namely : when some object/value doesn't gets garage collected because there are still references to it (or at least the refs are held unnecessarily long) so the GC thinks the program might still need it even though it actually doesn't
03:37:26 <balbo_> ski: how can i release refs then?
03:38:53 <ski> balbo_ : just forget them :)
03:39:22 <ski> (which may not always be so easy ..)
03:39:37 <balbo_> ski: forget the refs?
03:39:52 <ski> yes
03:40:13 <balbo_> ski: how?
03:40:47 <ski> iirc an example of this problem was with composing alternative parsers
03:41:00 <ski> balbo_ : depends on your code
03:41:24 <balbo_> ski: ok
03:41:56 <ski> e.g. if you pass around something in e.g. a tuple, even some time after it isn't needed anymore, it will prolly not get collected
03:42:31 <ski> balbo_ : should i explain the parser issue as far as i recall ?
03:43:20 <balbo_> ski: another time. but thx anyway. i have to leave now. bye
03:43:25 <ski> oki
04:19:35 <Lemmih> shapr: Did you add me to wincrem's keyring?
05:31:43 <autrijus> greetings haskellers.
05:31:57 <kristnjov> ciao bella
05:32:11 <autrijus> I've finished delivering my first 20-day-long haskell project today
05:32:16 <autrijus> and it works! :)
05:32:21 <kristnjov> what does it do?
05:33:12 <autrijus> it turns documents encoded in IBM's AFP format into CJK bitmaps and print them out.
05:33:20 <autrijus> very trivial stuff.
05:33:26 <kristnjov> ouch, my shoulder started hurting.
05:33:41 <autrijus> the AFP, being a proprietary binary format and has no parser libraries, makes it tricky.
05:33:50 <dblhelix> any mac os users here who frequently build ghc from source?
05:34:11 <autrijus> oh and it needs to process 1mb/sec on a 266mhz machine.
05:34:49 <autrijus> so it was challenging to do in pure haskell, with lots of ForeignPtr and hGetBuf calls, but it finally worked.
05:35:11 <autrijus> thanks to a large part to CosmicRay's AIX port.
05:36:12 <Oejet> autrijus: How was the speed of e.g. hGetContents v.s. ForeighPtr & hGetBuf?
05:36:14 * autrijus also learned that unsafeInterleaveIO is even sneakier and evil than unsafePerformIO.
05:36:30 <autrijus> Oejet: one is not fast enough; one is.
05:36:32 <autrijus> :)
05:36:43 <Heffalump> autrijus: in what way?
05:36:46 <Oejet> :-P
05:36:53 <autrijus> because I'm only processing certain sections inside AFP file, and need to leave the rest intact
05:37:29 <autrijus> so for the most part it's just hGetBuf ==> hPutBuf
05:38:27 <autrijus> (the darcs repo is at http://wagner.elixus.org/~autrijus/darcs/afp/ )
05:39:32 <autrijus> Heffalump: I discovered that if I make a mistake with unsafePerformIO, it would coredump promptly, and it's always easy to use the type checker the locate the problem spot
05:40:18 <autrijus> on the other hand with unsafeInterleaveIO the coredump doesn't always happen, and it's very hard to know exactly at which time the memory become unavailable; tracing it will make the problem go away, etc.
05:40:26 <autrijus> so all in all very heisenbugish.
05:40:48 <autrijus> I finally got it correct by promoting all CString from hGetBuf right away into ForeignPtr.
05:41:44 <autrijus> and use "addFinalizer x $ Just touchForeignPtr" on all derived structures.
05:42:11 <autrijus> happily, doing so did not affect performance in any significant way. :)
05:42:36 <kristnjov> map (++) foo
05:42:37 <kristnjov> !
05:42:42 <xerox> 'lo
05:42:51 <kristnjov> i pity the foo :)
05:42:52 <kristnjov> :/
05:42:58 <kristnjov> not very funny but mostly disturbing
05:43:41 <Heffalump> autrijus: what kind of mistakes did you make?
05:44:04 <autrijus> Heffalump: you mean in this project?
05:44:13 <Heffalump> with unsafeInterleaveIO
05:44:20 <autrijus> ah. I started out as a completely haskell newbie so I made lots of mistakes.
05:44:48 <autrijus> Heffalump: the specific mistake is to make "instance Binary [a] where get bh :: lazyGet bh" 
05:45:25 <autrijus> i.e. to read a list from a binary handle, only read the first and read the rest using unsafeInterleaveIO
05:45:39 <Heffalump> why is that an error?
05:45:57 <Heffalump> oh, I could see problems if you then did another read from that handle
05:46:04 <autrijus> yes.
05:46:04 <Heffalump> but they ought not to cause core dumps
05:46:14 <autrijus> but anyway; it works just fine with file handles; however with memory handles 
05:46:27 <autrijus> the read may happen after the memory is deallocated
05:46:39 <Heffalump> oh, ick
05:46:44 <autrijus> (I was initially using CStringLen to represent the handle)
05:46:59 <autrijus> (CStringLen, FastMutInt), that is
05:47:10 <autrijus> and it's very hard to debug, because most of the time it works
05:47:20 <Oejet> autrijus:  "You don't have permission to access /~autrijus/darcs/afp/ on this server."
05:47:23 <autrijus> it only breaks when I use something I read outside the scope.
05:47:29 <autrijus> Oejet: a "darcs get" should get things just fine.
05:48:46 <autrijus> Oejet: I turned on the Indexes. thanks
05:48:54 <autrijus> web browsing should work now.
05:49:11 <autrijus> the main program is all contained in Main.hs.
05:49:56 <autrijus> I've eliminated a large amount of IORefs but there is still some lying around.
05:50:10 <autrijus> <- still very much brainwashed by the imperative mindset
05:51:37 <autrijus> I wrote the "split" on http://wagner.elixus.org/~autrijus/darcs/afp/Main.hs line 65 by hand; I didn't find anything like it in the standard libraries.
05:51:49 <autrijus> (which makes me think I must be missing something)
06:02:51 <TheHunter> split f === groupBy (const $ not . f) ?
06:08:21 <autrijus> whoa.
06:09:17 <autrijus> TheHunter++
06:13:23 <pesco> TheHunter: Thanks, why didn't I think of that when I last needed that split? Good to know!
06:16:48 <dblhelix> @type \f -> List.groupBy (const $ not . f)
06:16:49 <lambdabot> \f -> List.groupBy (const $ not . f) :: forall a.
06:16:49 <lambdabot> 					(a -> Bool) -> [a] -> [[a]]
06:19:16 <autrijus> @type const
06:19:17 <lambdabot> const :: forall a b. a -> b -> a
06:19:50 <Darius> @type curry fst
06:19:51 <lambdabot> curry fst :: forall a b. a -> b -> a
06:20:00 <autrijus> I see.
06:20:11 * autrijus bangs head against the functional wall some more.
06:21:11 <Darius> autrijus: That wasn't the clearest definition, I've just been dealing with categorical semantics of lambda-calculi a lot of late ;)
06:27:36 <TheHunter> Darius, just out of curiosity, which university are you at?
06:28:56 <Darius> TheHunter: None.
06:30:15 <TheHunter> interesting. so what do you do?
06:36:15 <Darius> Right now I'm unemployed and about to go around America
06:36:38 <shapr> on a unicycle?
06:37:17 <Darius> shapr: That'd be cool, but I don't (yet) know how to unicycle.
06:37:23 * shapr grins
06:37:49 <shapr> Next time we meet, I'll give you some lessons if you want.
06:38:36 <Darius> TheHunter: Programming has been something I've been doing since I was 12 or so and I've always had an interest in Mathematics, hence the interest in all this crazy math stuff.
06:39:09 <Darius> shapr: That'd be more like the "First time" we meet, but if I do meet you and have not yet learned to unicycle I'll take you up on it.
06:39:12 <shapr> Lemmih: yes, you're in the wincrem keyring
06:39:27 <shapr> Sure, first is a special case of next...
06:41:40 <Darius> Unfortunately, BASIC was one of my first languages and when I think about it I can see what Dijkstra means.
06:41:52 <TheHunter> Darius, i'm interested in this crazy math stuff (as a math student), too, but unfortunately there's no functional programming going on at our uni, that's way i was asking.
06:42:25 <TheHunter> my interesting in programming, however, has evolved only very recently.
06:43:55 <Lemmih> shapr: I can't commit patches.
06:44:39 <TheHunter> well, BASIC kinda was my first language, too. *shudder*
06:45:03 <kristnjov> well, addition and subtraction kinda was my first mathematical uses too. (?)
06:45:09 <kristnjov> everyone starts somewhere.
06:46:04 <Darius> kristnjov: using addition and subtraction doesn't "mentally mutilate you beyond hope of regeneration" in math
06:46:23 <kristnjov> ... you're still missing my point even though i said it out loud.
06:46:48 <TheHunter> kristnjov, ?
06:46:56 <kristnjov> what now? fuck off.
06:48:40 <shapr> hey be nice
06:48:44 * autrijus purrs.
06:48:46 <shapr> or get the boot of DOOM!
06:48:52 <andersca> indeed
06:48:56 <kristnjov> sometimes i just can't keep it in anymore.
06:49:06 <shapr> so let it out somewhere that it doesn't offend others.
06:49:25 <kristnjov> well i wanted him to hear it.
06:49:34 <shapr> it wasn't nice.
06:49:55 <kristnjov> i ddin't think it was nice of him to '?' me.
06:50:24 <shapr> From what I could tell it was just a request for clarification from him.
06:50:30 <Darius> kristnjov: I think he was agreeing with you that he is still missing your point and wanted you to elaborate.
06:50:32 <TheHunter> yep
06:50:42 <dblhelix> I interpreted "?" as "can you explain yourself some more"
06:50:48 <kristnjov> so then ask me instead of the '?'
06:51:08 <shapr> I think the single question mark is common usage on irc.
06:51:26 <autrijus> it's not like it's ???? ;)
06:51:28 <kristnjov> obviously you haven't seen it being used as i have
06:51:38 <shapr> If it offends you, there are other discussion formats that don't use the single question mark.
06:51:51 <shapr> Most things are interpreted in the context in which they are used.
06:52:13 <kristnjov> things such as this discussion p*ss me off
06:52:21 <kristnjov> (see i censored the 'bad' word)
06:52:41 <kristnjov> it makes me want to write "who cares" in the ceiling with cat blood
06:52:47 <shapr> You aren't required to continue this discussion.
06:52:51 <dblhelix> well, now that we have established that it was all a misunderstanding, can we continue acting like civilized grown-ups
06:53:05 <shapr> I was just saying that you gotta be nice on #haskell or get the boot of doom.
06:53:07 <Darius> kristnjov: It wasn't the word that shapr considered the problem
06:53:08 <kristnjov> shapr, i'm just saying...
06:53:31 <kristnjov> shapr, yeah, that's the spirit. that's what i want to see more of.
06:53:39 <shapr> Awright then!
06:53:46 * shapr waves his boots flagrantly
06:53:49 <kristnjov> instead of these elaborate novels about interpretation of question marks
06:54:06 <dblhelix> well, let's move on then! Darius: (how) did you recover from your BASIC trauma?
06:55:50 * autrijus was once a quickbasic / visual basic consultant. :-/
06:56:14 <Darius> dblhelix: I'd say yes, but I'm too close to myself to be an objective observer.
06:57:18 <dblhelix> Darius: which aspects of the language do you consider to be most damaging to one's further development as a programmer?
06:57:34 <kristnjov> i
06:57:56 <kristnjov> i'd say the goto loops, although i never used basic/qbasic very much
06:58:23 <dblhelix> "goto considered harmful" :) yes, indeed
06:58:33 <autrijus> gosub isn't much better :)
06:59:16 <Darius> dblhelix: kristnjov has the one most "traumatic" for me.  I had code that was the definition of spaghetti code: think subroutines implemented with goto and flags.
06:59:19 <shapr> I wish I'd been taught recursion and coroutines instead of loops and threads.
06:59:39 <Darius> dblhelix: Though a significant part of that was ignorance on my part.
06:59:52 <pesco> hoohoo
06:59:58 <shapr> y0 pesco 
06:59:58 * pesco waves to everyone
07:00:05 <pesco> 'ello shapr!
07:00:32 <pesco> How's code?!
07:00:43 <dblhelix> more generally, it makes you getting used to adapt the form in which you shape you creativeness to a form that makes the computer happy, i.e. staying close to the machine's memory model
07:00:51 <shapr> Haven't written any lately. But the sun is returning, and with it my energy.
07:00:55 <shapr> How's code for you?
07:01:10 <pesco> Wonderful, although I've not coded much lately, either.
07:01:24 <Darius> However, the lack of most real data structures or a way to define new ones, lack of dynamic memory management, a very low-level yet limiting imperative style, pretty much no encapsulation tools whatsoever, etc.
07:02:24 <Darius> Also, I used QBASIC some of the time, and the only "FFI" was poking machine code into arrays
07:02:49 <pesco> shapr: I wrote up all my coding and other "projects" as a set of quests, alike to those commonly found in computer RPGs.
07:03:01 <shapr> heh, neat :-)
07:04:13 <pesco> It was quite enlightening. It took away the anxiety that builds up when I leave one thing behind because I become more interested in something else.
07:04:19 <Lemmih> You've encountered the Maybe monad. (U)se, (I)gnore.
07:04:24 <pesco> This way I don't need to fear losing anything.
07:04:27 <pesco> Lemmih: *g*
07:05:05 <pesco> And when I'm bored I always have a handy collection of interesting tasks ready.
07:05:52 <edwinb> That sounds a great idea. I'm almost bored enough to try it...
07:06:24 <pesco> edwinb: :)
07:06:52 <edwinb> Setting up the list of quests in the first place is surely a big enough task ;)
07:07:18 <dblhelix> Lemmih: i'm quite slow today ... please explain the Maybe analogy to me
07:07:37 * aj wonders what a `programming quest' looks like
07:08:30 <pesco> edwinb: I'd recommend eagerly filling in the quest descriptions.
07:08:52 <Lemmih> dblhelix: Haskell programming as an RPG game. No deeper thoughts on my part.
07:09:14 * edwinb imagines the cover of the Dragon book as an example
07:09:14 <pesco> edwinb: My format is "The Foo Quest.\n\nTASKS\n\t* blahblah\n\t* otherblah\n\nLOG\n\t* moo\n\t*maeh"
07:10:13 <Lemmih> Defeat the type error and get the holy GADT.
07:10:57 <pesco> aj: Well, they're lacking the blood shed, but I'm sure you can make up for that with some creativity.
07:11:00 <shapr> hiya dude4545 
07:11:04 <dblhelix> Darius: I never used BASIC/QBASIC in a professional setting ... I did some Visual Basic programming for three years ... if you have enough focus, you won't even know that there's another world out there, filled with much nicer languages etc. ... kind of scary
07:11:12 <Lemmih> shapr: Got time to look at the wincrem repo?
07:11:26 <pesco> As Lemmih said, there are lots of enemies to defeat. ;)
07:11:27 <shapr> looking now
07:15:09 <Darius> dblhelix: Well, since BASIC was my first language by the time I learned other languages I had negative programming knowledge.  And yes, the perspective is very narrow from there, when you hear of other language(s) it's C because that's the "real" programming language (which compared to BASIC is true).
07:16:10 <pesco> My next quest will be The Markup Quest. It entails raiding the cities of Ex'emel, Asgji'emel, and Aedj'tiem'mel, looting anything of value, burning down the rest, and slaughtering the monks of Schemata in the process.
07:17:31 <pesco> aj: See?
07:21:26 * shapr laughs
07:23:46 <shapr> Lemmih: I can't find any record of emails received in the logs.
07:28:34 <Lemmih> Oh.
07:28:56 * Lemmih starts sendmail.
07:29:20 <Lemmih> shapr: Sorry for bothering you /-:
07:32:07 <Philippa> talking of mail, my inbox currently has 666 messages in it
07:33:43 <Darius> Hey shapr, is there a curryspondence demon link anymore?
07:39:19 <shapr> not since my ISP blocked all incoming connections :-(
07:40:02 <Darius> That sucks.
07:40:09 <shapr> I'm not sure if it's a router misconfig or if they've just decided their users don't need incoming connections.
07:40:54 <Darius> Have you emailed/called/mailed them about it?
07:40:57 <shapr> nah, not yet.
07:41:14 <shapr> I'll talk to them on Monday.
07:47:10 <Darius> TheHunter: I just recalled a question I wanted to ask you: Besides the obvious ;), what made you become interested in programming?
07:55:49 * ski got a programmable calculator at age 7
07:58:09 <Oejet> ski: Did your parents teach you to use it?
07:59:04 <ski> no
07:59:29 <ski> i got an instruction manual in english (which i didn't know)
07:59:50 <ski> but i looked at examples and an elder brother helped me some
08:02:56 * ski remembers coding a program for doing a alphabet-permutation crypto
08:03:15 <ski> it took most of the memory of the calc. ..
08:05:54 * Lemmih wonders where 'SHGetFolderPathA' is defined.
08:06:38 <Darius> (Where) in the Win32 API(?)
08:06:44 <CrewdenX> shlwapi.lib probably.
08:06:57 <aFlag> what's the better style? To put guards right in front of the first line or always indented under the function name?
08:07:03 <aFlag> foo x y
08:07:14 <aFlag>   | guard1 = x
08:07:22 <aFlag>   | otherwise = y
08:07:24 <aFlag> or
08:07:28 <aFlag> foo x y |
08:07:29 <Darius> aFlag: I use both depending on how deep they would be.
08:07:32 <aFlag>        |
08:07:53 <Lemmih> I'm trying to compile GHC from CVS on a windows box and it (ghc/lib/compat) complains about a undefined 'SHGetFolderPathA'.
08:08:07 <aFlag> you mean if it's a longer line you do it the first example way
08:08:15 <aFlag> and if it's shorter the second one?
08:08:18 <Darius> Yes
08:08:31 <CrewdenX> Lemmih: try linking with shlwapi.lib maybe?
08:37:31 <aFlag> fromInt is on the prelude, right?
08:37:38 <aFlag> so why can't i use it in my module?
08:37:44 <aFlag> it says the name doesn't exist
08:38:42 <Darius> I think it's some Hugs-ism (that might have used to be a Haskellism).  Use fromIntegral.
08:39:17 <Darius> @type fromIntegral (3 :: Int) :: Integer
08:39:18 <lambdabot> fromIntegral (3 :: Int) :: Integer :: Integer
08:40:33 <aFlag> but if i type fromInt in the interactive interpreter it works
08:44:12 <Darius> aFlag: Perhaps Hugs loads some libraries at the prompt that it doesn't in modules.
08:44:39 <aFlag> yeah, that's probably it
08:46:02 <aFlag> either way, i can't figure out how to do a function such as avarageThree :: Int -> Int -> Int -> Float avarageThree x y z = (x+y+z)/3 doesn't work
08:46:16 <aFlag> it says the result is Int not Float
08:47:53 <Darius> Use fromIntegral
08:47:57 <Darius> @type fromIntegral
08:47:58 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
08:48:05 <Darius> @type (/)
08:48:06 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
08:48:24 <Darius> So, fromIntegral (x+y+z) / 3 should work.
08:49:34 <aFlag> yeah, it does
08:49:54 <aFlag> i was trying fromInt instead
08:50:25 <aFlag> i thought i've tried fromIntegral and it didn't work, but i guess i've done something else wrong when i've tried it
08:51:47 <Darius> Well if you did fromIntegral ((x+y+z) / 3) that wouldn't work because x+y+z would be Int which isn't in Fractional.
08:54:07 <aFlag> i don't fully understand how fromIntegral works but i guess it will become more clear when i get futher on the book i'm reading
08:56:14 <dblhelix> aFlag the type of fromIntegral kind of tells the story: it takes a value from any source type to a value of any target type, as long as the source type is an instance of the Integral class and the target type is an instance of the Num class
08:57:01 <dblhelix> aFlag: of course, that might get you wondering what a class is; ehmm ... well for that, I guess you can best consult your book ;)
08:57:14 <dblhelix> aFlag: out of curiosity, what book are you
08:57:20 <dblhelix> using?
08:57:37 <aFlag> haskell - the craft of functional programming
08:57:50 <aFlag> i know some about classes
08:58:02 <aFlag> i kinda done some haskell programming without fully understanding it
08:58:31 <aFlag> and now i'm reading this book to understand it better
09:00:39 <aFlag> so fromIntegral gets something in a more general type and downcasts it to a more restrict one considering the context it's in?
09:00:47 <aFlag> why couldn't it be done automaticly?
09:03:31 <Darius> It could, but it would either be ad-hoc or require adding subtyping to Haskell and to some it's a feature not a bug.
09:05:23 <Darius> (to the remainder given the overloading of constants it's mostly a non-issue I'd imagine)
09:06:36 <aFlag> hum...
09:08:08 <aFlag> functions then can be overloaded on the respect of their return value? I mean, if you have foo :: Int -> Int, foo :: Int -> Float is a valid overload for foo?
09:08:33 <dblhelix> not quite
09:08:53 <dblhelix> overloading or ad-hoc polymorphism is obtained by means of type classes
09:09:11 <Darius> aFlag: Overloading is controlled through typeclasses.  You can have a typeclass, class Foo a where foo :: Int -> a which would determine the resolution by the return value.
09:09:25 <aFlag> oh, i get it
09:09:47 <dblhelix> (+) can have type Int -> Int -> Int, but it also has type Float -> Float -> Float, etc.
09:10:12 <dblhelix> in general, it has type a -> a -> a, for any type a that is an instance of class Num
09:10:28 <dblhelix> hence, (+)'s type is (Num a) => a -> a -> a
09:10:38 <dblhelix> @type (+)
09:10:39 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
09:10:42 <aFlag> hum... i think i'm understanding it better now
09:11:55 <aFlag> so when you have (+) being aplied to a int and a float it's actually using the Num definition, right?
09:12:26 <Oeje1> @eval 3+4.5
09:12:26 <lambdabot> type error
09:12:33 <dblhelix> so, just like (Num a) => a -> a -> a can be instantiated to Int -> Int -> Int because Int is an instance of Num, (Num b, Integral a) => a -> b can be instantiated to Int -> Float because Int is an instance of Integral and Float is an instance of Num
09:12:50 <aFlag> hum... but when i type in 2+3.5 it works
09:13:17 <aFlag> that's because 2 is also a float, right?
09:13:24 <dblhelix> yep
09:13:55 <dblhelix> that's actually done automagically, yes ... 2 get extended to fromIntegral 2
09:14:04 <Darius> aFlag: Constants are overloaded, when you write 2 in a module the implementation reads it as (fromInteger 2), so you have (fromInteger 2)+3.5 (which convert 2 to a Double then does the addition.
09:14:29 <aFlag> hum... i see
09:14:33 <Oeje1> (3::Int)+(5.6::Float)  will give a type error.
09:15:32 <dblhelix> fromIntegral (3 :: Int) + (5.6 :: Float) gets you up and running again
09:15:46 <dblhelix> aFlag: got the hang of it?
09:17:01 <aFlag> i think i kinda did
09:17:23 <tumm_> hi, does anyone here know a bit of haskelldb and if so, is willing to help me out a bit?
09:17:48 <aFlag> i was looking fromIntegral code and it's fromInteger . toInteger but both functions come from primitive one's, right? So it's not actually haskell code
09:18:33 <dblhelix> not quite, both are overloaded
09:18:38 <dblhelix> @type fromInteger
09:18:39 <lambdabot> fromInteger :: forall a. (Num a) => Integer -> a
09:18:42 <dblhelix> @toInteger
09:18:42 <lambdabot> Sorry, I don't know the command "toInteger", try "lambdabot: @listcommands
09:18:53 <dblhelix> @type toInteger
09:18:54 <lambdabot> toInteger :: forall a. (Integral a) => a -> Integer
09:19:28 <dblhelix> so, for each instance of Num there is a corresponding implementation of fromInteger
09:20:03 <dblhelix> and for each instance of Integram ther is a corresponding implementation of toInteger
09:20:42 <aFlag> hum, i get, things make more sense now :)
09:21:47 <Darius> aFlag: If you were making something to represent arithmetic expressions, i.e. data Exp = Num Int | Add Exp Exp | Mul Exp Exp and wanted to have 1+2 mean Add (Num 1) (Num 2) you could make your own instance of Num with fromInteger = Num, (+) = Add, etc. and things would work.  Of course, the instances of Num for the primitive types need to use primitives.
09:23:10 <aFlag> i see, thanks
09:25:36 <dblhelix> (although, fromInteger = Num would yield a type error, but well ... as long as the idea's clear)
09:26:05 <aFlag> yeah, i got what you're saying
09:27:06 <Darius> oh yeah, fromInteger = Num . fromInteger
09:27:37 <dblhelix> yep :)
09:43:22 <Darius> Wow, we're applied logicians according to this paper.
09:43:40 <dblhelix> which paper?
09:44:42 <dblhelix> I think it's a cool thing to put on a business card: "applied logician" :)
09:44:58 <Darius> Relating Categorical Semantics for Intuitionistic Linear Logic
09:44:59 <Cale> I've always thought that about type theory.
09:45:18 <xerox> hi Cale :-)
09:45:23 <Cale> hello
09:45:40 <Darius> Cale: Oh I agree with it.  I just think that many functional programmers wouldn't call themselves that (at first blush).
10:18:43 <Darius> @wn adumbratd
10:18:45 <lambdabot> No match for "adumbratd".
10:18:49 <Darius> @wn adumbrated
10:18:50 <lambdabot> No match for "adumbrated".
10:19:01 <Darius> @wn adumbrate
10:19:02 <lambdabot> *** "adumbrate" wn "WordNet (r) 2.0"
10:19:02 <lambdabot> adumbrate
10:19:02 <lambdabot>      v 1: describe roughly or briefly or give the main points or
10:19:02 <lambdabot>           summary of; "sketch the outline of the book"; "outline
10:19:03 <lambdabot>           his ideas" [syn: {sketch}, {outline}]
10:19:05 <lambdabot>      2: give to understand; "I insinuated that I did not like his
10:19:07 <lambdabot>         wife" [syn: {intimate}, {insinuate}]
10:26:56 <Oeje1> Where can I find an archive for this channel?
10:27:49 <TheHunter> Oeje1, http://meme.b9.com/
10:28:15 <TheHunter> (raw http://tunes.org/~nef/logs/haskell/)
10:29:11 <Oeje1> Thanks, TheHunter.
10:34:02 <TheHunter> Darius, don't know if that counts as obvious, but i guess the main reason i became interested in programming that i realized that it's much more "mathematical" than i had thought and what powerful abstractions are possible.
10:36:26 <TheHunter> anyway, gotta run.
11:02:26 <tungsten> anyone familiar with haskore?
11:02:44 <tungsten> anyone familiar with haskore on hugs?
11:05:46 <tungsten> I get the following error from Bitops.lhs      "./Bitops.lhs":16 - Undefined variable "fromInt"
11:06:45 <tungsten> I lloked the file Bitops.lhs and yes there is a variable fromint on line 16
11:07:12 <ibid> fromint or fromInt?
11:07:40 <Darius> tungsten: We were just talking about a similar thing a while back, I'd suggest changing all uses of fromInt to fromIntegral.
11:07:53 <Gahhh> that needs to be fromInteger I think
11:08:22 <Cale> fromInt is no longer around, iirc.
11:09:05 <Darius> Gahhh: fromInteger couldn't possibly work considering the current name is fromInt.
11:09:21 <tungsten> http://cvs.haskell.org/darcs/haskore/docs/html/Pitch.html
11:09:26 <Darius> (Well, if type inference decides the name...)
11:10:13 <Gahhh> fromIntegral = fromInteger . toInteger
11:10:22 <Cale> ah
11:10:26 <Darius> tungsten: Oh well never mind.
11:11:05 <Cale> fromInt is supposed to convert an absolute pitch to an (Octave, Class)
11:11:28 <Darius> Gahhh: fromInt :: Int -> a and fromInteger :: Integer -> a, (module constraints) they can't be used on the same things.
11:12:03 <Cale> (probably Absolute as relative to MIDI, but I
11:12:10 <Cale> I'd have to look)
11:12:58 <Darius> tungsten: If Bitops.lhs imports Pitch then the problem is something else, otherwise then change the uses of fromInt to fromIntegral in Bitops.lhs (or, less ideally, import Hugs.Prelude may work).
11:13:40 <Darius> tungsten: Bitops.lhs doesn't sound like it deals with the Music part.
11:15:18 <Cale> yes, that definitely should be a fromIntegral
11:15:25 <Cale> > bshiftr b n = truncate ((fromInt n)/2^b)
11:15:29 <tungsten> thanks I'll try it
11:15:51 <tungsten> called to lunch
11:22:37 <tungsten> Darius changing fromInt to fromIntegral worked thanks
11:23:23 <tungsten> Darius: changing fromInt to fromIntegral worked thanks
11:37:39 <Darius> I just found this paper (haven't read it yet) that some might find interesting, http://citeseer.ist.psu.edu/707486.html "A Formal Calculus for Categories"
11:41:48 <pesco> Wow, ChanServ just segfaulted! Maybe lambdabot should offer to take his job. ;-P
11:48:24 * Darius wonders what the impetus for the name "sinister morphism" is.
11:51:26 <shapr> lefthanded change?
11:52:31 <Cale> "Fubini" is a nice pun in that paper.
11:52:49 <Cale> (and the whole notation for Ends built up around it)
11:55:36 <Darius> Cale: The "formal calculus" paper?
11:55:48 <Cale> yeah
11:56:04 <Darius> Looking at it the Ends notation looks like the standard one.
11:56:17 <Cale> Probably is
11:56:40 <Cale> I haven't done anything with Ends
11:57:23 <Darius> I've only read about them, I'm not sure what the applications are that I'd be interested in and I don't have a just whip them about familiarity with them.
11:58:20 <shapr> SyntaxNinja: packages as patches?
11:58:50 <SyntaxNinja> :)
11:59:04 <shapr> or what about packages as repos?
11:59:26 <SyntaxNinja> I think packages represented by repos, rather than tarballs, would be really cool.
11:59:27 <shapr> something like BSD portage
11:59:43 <SyntaxNinja> I think that if a BSD person heard you call it portage, you would get hurt.
11:59:53 <SyntaxNinja> gentoo is for rice boys
11:59:57 <shapr> and, the ultimate in distributed bug reporting, just mail in a patch to the repo
12:00:07 <SyntaxNinja> but yeah, I agree with the concept
12:00:41 <SyntaxNinja> Heffalump: you've got mail
12:01:07 <shapr> it's interesting, each package would have its own 'apt' server, just the repo on the server.
12:02:33 <SyntaxNinja> you could have "unofficial" branches by people without commit access, who could still upload their stuff until upstream pulls it
12:04:14 * SyntaxNinja comments out hooks exports in preparation for release...
12:08:19 <Igloo> What does "repo" here mean, exactly?
12:08:43 <SyntaxNinja> Igloo: we're brainstorming about interesting ways darcs might interact with hackage
12:14:18 <tromp> repository
12:18:41 <WilX> Who is a rice boy?
12:19:47 <Lemmih> I am, apparently.
12:22:35 <SyntaxNinja> ricers: http://funroll-loops.org/
12:25:49 * Lemmih has found Gentoo a lot slower than Debian but easier to use.
12:27:09 * Oeje1 jumps in with an advertising sign saying "Try GoboLinux".  Then quickly jumps out again.
12:27:18 <Gahhh> heh
12:29:03 * SyntaxNinja shouts "Linux religious war!!" jumps on a table, and throws a lambda pie in shapr's face.
12:29:16 <Oeje1> Ups.
12:30:59 <Igloo> Lemmih: Slower when using it, or just slower to install things?
12:33:20 <Lemmih> Igloo: Programs are equally slow on both my machines.
12:36:54 <Igloo> And the glass is half empty, huh?  :-)
12:40:11 <Lemmih> I do actually have a Debian box which is slower than my 1.5Ghz Gentoo box with 1Gb DDR ram but I suspect it's because it's a 133Mhz Pentium with 32Mb SD ram. (:
12:41:10 <Oeje1> Lemmih: The 1,5GHz one is that a Pentium or Duron or what?
12:41:23 <Lemmih> AMD Athlon.
12:41:47 * andersca hugs his PPC G5
12:42:25 <Oeje1> I have changed from 800MHz Pentium III to 1200MHz AMD Duron.  The Pentium actually feels faster.
12:44:26 <Lemmih> Oeje1: The cache size also plays an important role.
12:51:43 <Lemmih> Packages as darcs repos?
13:08:17 <Lunar^> andersca: :)
13:08:31 * andersca also hugs his PPC G4
13:08:32 <andersca> ;)
13:08:33 <Lunar^> andersca: Have you tried -fPIC ?
13:08:39 <andersca> Lunar^: nope
13:08:52 <Oeje1> Lemmih: Pentium (64 KB L1, 256 KB L2),  Duron (128KB L1, 64KB L2), IIRC.
13:10:30 <SyntaxNinja> Lemmih: just brainstorming
13:16:34 <shapr> SyntaxNinja: lotsa neat tricks possible with cabal package as repo idea. You could automate pull, build, and email build errors back to the maintainer.
13:17:23 <resiak> Is there an Official #haskell Paste Site(TM)?
13:17:35 <shapr> two actually
13:17:37 <resiak> I see.
13:17:40 <Lemmih> @wiki HaskellIrcPastePage
13:17:40 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:17:44 <shapr> there's lisppaste2 and the wiki page
13:18:13 <SyntaxNinja> shapr: yeah :)
13:18:17 <resiak> So the way forward is to edit that wiki page and paste into it?
13:18:23 <shapr> yup, sure
13:21:37 <Darius> resiak: You can use {{{#!syntax haskell ... }}} around your code to have it look better.
13:21:42 <resiak> Okay, so I've pasted my data definitions and the function that is borken at the bottom of that wiki page. I'm being informed by HUGS that Just [] is ambiguous, since it could refer to Main.Just or Hugs.Prelude.Just . However, I explicitly typed the function...
13:21:48 <resiak> Darius: I'll do that. Thanks.
13:22:38 <Darius> resiak: You can't have two constructors with the same name.  In the standard Prelude there is a data type Maybe a = Nothing | Just a
13:22:51 <SyntaxNinja> resiak: use qualified imports :) 
13:23:06 <Darius> resiak: While changing the name is probably the best solution in this case, another is to hide or import Maybe's Just qualified.
13:23:28 * resiak kicks his question sheet for not anticipating this.
13:23:56 <resiak> That makes sense, I should have thought of that.
13:24:20 <resiak> Hmm. I'll make Just be Just
13:24:25 <resiak> Hmm. I'll make Just be Just' , even.
13:24:31 <resiak> Thanks all :)
13:26:55 <SyntaxNinja> I think everyone should always use qualified imports :)
13:27:20 <Darius> SyntaxNinja: Of the -Prelude- ?
13:27:36 <SyntaxNinja> Darius: OK, i'll draw the line at the prelude.
13:27:58 <SyntaxNinja> MegaMonad: do you use qualified imports for the prelude?
13:27:59 <MegaMonad> SyntaxNinja: It's still true, i'm not qualified in the prelude is a normal part of a well-trained chorus or in haskell, but enumerating all imports.
13:28:09 <Lemmih> Text.ParserCombinators.Parsec.char '?' Text.ParserCombinators.Parsec.<|> Text.ParserCombinators.Parsec.char '!'
13:28:48 <Darius> Even SyntaxNinja has to admit that qualified operators are ugly.
13:28:49 <SyntaxNinja> Lemmih: those don't look like import statements to me
13:29:19 <Lemmih> SyntaxNinja: Wouldn't qualified imports lead code like that?
13:29:27 <Darius> Then there was the fun one, Prelude..
13:29:46 <Darius> or Prelude...
13:29:53 <SyntaxNinja> er, I guess I meant what MegaMonad said, enumerating all imports.
13:29:57 <Oeje1> Lemmih: You can alias the package name: Text.ParserCombinators.Parsec = P, e.g.
13:30:00 * Darius forgot if that latter one was agreed to work or no.
13:30:33 <Darius> SyntaxNinja: Ah, I'll agree with that within reason.
13:30:48 <SyntaxNinja> Darius: reason is not a part of this discussion!
13:30:58 <SyntaxNinja> what is that called anyway, 'enumerated imports'?
13:30:59 * Darius apologizes.
13:34:14 <aFlag> what's wrong with this code http://rafb.net/paste/results/NQlkzM59.html ?
13:34:47 <aFlag> min 2.3 5.4 seems to work
13:35:25 <aFlag> but when i try to load it it says the type float y doesn't match Int
13:36:19 <Oeje1> @type (^)
13:36:19 <_Codex> aflag: comment out the type of the function and ask ghci what the type really is.
13:36:20 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
13:36:44 <Darius> presumably numberOfRoots returns an Int
13:37:04 <Darius> Actually, what is the whole type of numberOfRoots?
13:37:21 <aFlag> numberRoots :: Float -> Float -> Float -> Int
13:38:13 <aFlag> http://rafb.net/paste/results/HOh0XC78.html there they all are
13:38:58 <aFlag> i've tried commenting out the type annotation but it didn't work
13:39:08 <Riastradh> aFlag, you should use lisppaste, not rafb.net, here.
13:39:09 <Riastradh> lisppaste2: url
13:39:10 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:39:26 <Riastradh> (minor issue -- don't worry for now, of course)
13:39:53 <aFlag> i didn't know about lisppaste
13:40:24 <Riastradh> Yes: lisppaste was only recently put here.
13:40:37 <Darius> aFlag: Which implementation are you using, by the way?
13:40:39 <Darius> @type min
13:40:41 <lambdabot> min :: forall a. (Ord a) => a -> a -> a
13:40:43 <aFlag> hugs
13:41:06 <aFlag> but it didn't work with ghc either
13:43:06 <aFlag> is there some kind of debugger for haskell?
13:43:50 <aFlag> of course it wouldn't work here since it doesn't even compile
13:44:13 <Darius> aFlag: Actually, there is a type debugger
13:44:25 <aFlag> what's it called?
13:45:17 <Oeje1> aFlag: Actually your code compiles fine in my GHCi.
13:45:56 <Darius> http://www.comp.nus.edu.sg/~sulzmann/chameleon/
13:46:15 <Darius> aFlag: I'm with Oeje1 though I haven't compiled it.  Your code looks type correct to me.
13:46:46 <Darius> chameleon is a Haskell-like language.  The type debugger for it is supposed to work with both Haskell and Chameleon.
13:47:30 <Darius> aFlag: Do you use tabs?
13:48:35 <aFlag> hum... strange outside the module the function is working
13:48:50 <aFlag> oh, i know what it is now
13:49:01 <aFlag> tabs? What's that?
13:49:52 <Darius> Tabs instead of spaces for indentation, but unless you have some unfortuitous code elsewhere that'd unlikely be the problem upon further reflection.
13:50:09 <Darius> aFlag: What was the problem?
13:51:06 <aFlag> i was doing all exercices of the book on the same module, and i did one a while ago that was to implement min :-/
13:52:00 <aFlag> Darius, i've being using spaces because that's the recommended thing for python so i just used it
13:52:43 <aFlag> and i've seen emacs modes where if you didn't set it to use only spaces it would mix tabs and spaces
13:52:53 <aFlag> and i've always been told that mixing is bad
13:54:21 <Darius> aFlag: Well you'll get no argument from me.
13:56:35 <Riastradh> Tabs are evil.  Down with tabs!  (SETQ-DEFAULT INDENT-TABS-MODE NIL)!
13:56:43 <SyntaxNinja> word
13:57:46 <SyntaxNinja> we should write a virus that echos that to everyone's ~/.emacs file
13:58:13 <aFlag> hehe i have that on my .emacs
13:58:59 <Oeje1> Riastradh: Is  (SETQ-DEFAULT INDENT-TABS-MODE NIL)!  with or without the trailing '!'?
13:59:09 <Riastradh> Oeje1, the trailing '!' was for emphasis.
13:59:20 <Oeje1> :-P I know.
14:00:49 <SyntaxNinja> this is one situation where scheme's set! makes perfect sense.
14:26:04 <Darius> Dinatural transformations always present mildly impressive diagrams.
14:26:57 <_Codex> dinatural?
14:27:34 <Darius> A generalization of natural transformations that handles multivariant functors.
14:28:27 <_Codex> nice. If only I knew what multivariant means in context of functors.
14:29:14 <Darius> CopxC->D bifunctor
14:29:38 <Darius> I.e. both covariant and contravariant at the same time.
14:30:37 <_Codex> uhm, how does functor work if it at the same time reverses arrows and doesnt reverse arrows? (is that something like reverses every 2nd arrow? Or that all arrows could go either way? :)
14:32:20 <Darius> It doesn't reverse arrows, it accepts reversed arrows. And a simple example is Hom(-,=)
14:33:07 <Darius> (so to speak)
14:35:26 <KrispyKringle> hiya folks. 
14:35:34 <_Codex> ok, I dont understand that very well. But it doesnt matter.
14:36:42 <Darius> _Codex: Actually just forget about reverse arrows or reversing arrows.
14:36:44 <KrispyKringle> i've got a type error in this code (http://rafb.net/paste/results/jrTDQd74.html) on line 4; the error being that term vs of type [(Float, Float)] does not match type Shape. But it shouldn't; the resulting list from the cons operation should be a [(Float, Float)] that's given as the argument to the Polygon constructor. What gives?
14:36:50 <KrispyKringle> Thanks...
14:38:40 <KrispyKringle> oh, wait...
14:39:00 <ski> newArea (Polygon vs)  ?
14:39:07 <KrispyKringle> nevermind. 
14:39:08 <KrispyKringle> yeah. 
14:39:15 <KrispyKringle> i was looking at the previous line. :P
14:39:22 <Riastradh> lisppaste2: url
14:39:23 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:39:55 <KrispyKringle> thanks, Riastradh 
14:52:30 <wagle> g'afternoon
15:17:57 * Heffalump appears
18:18:37 <gzl> if I'm running a function on pairs of elements of a list as follows, what's a nice way to make sure I also get it for the pair (last, head) where last is the last element of the list and head is the head: f (x:y:xs) = (g x y) + (f (y:xs)) ?
18:19:07 <gzl> that works fine but I want it to do one more iteration than it's doing so it "wraps around"
18:20:54 <gzl> for example, f [1,2,3] should be g 1 2 + g 2 3 + g 3 1
18:21:20 <Cale> perhaps just tack the head of the list onto the tail
18:21:21 <Cale> ?
18:21:49 <gzl> yeah, but if I do that inside the recursive call, it keeps doing it
18:22:36 <gzl> e.g. (g x y) + (f ((y:xs) ++ [x])) is no good 
18:22:48 <Cale> like, call f [1,2,3,1] rather than f [1,2,3]
18:23:12 <gzl> I need a way of doing it inside the function
18:23:16 <Cale> you can always wrap the call to f in another f'
18:23:23 <gzl> hm
18:23:32 <gzl> yeah, I suppose htat's true
18:24:54 <gzl> so that's the way you'd recommend?
18:24:59 <Cale> perhaps
18:25:08 <Cale> I don't really know what you're doing
18:30:29 <gzl> thanks though, this works well enough
18:31:20 <Cale> you can use a where clause so that f is hidden and the rest of the program can only see f' if you like
18:31:27 <gzl> that's what I did
18:35:15 <gzl> can you have multiple 'where' clauses in one definition or is it impossible or frowned upon?
18:37:09 <Cale> a single where clause can make more than one definition
18:39:44 <gzl> ah, I see
22:47:26 <araujo> Has anyone compiled hOp here?
