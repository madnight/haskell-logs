00:25:30 <earthy> mogge swiert
00:25:42 <swiert> morning earthy
00:25:58 <earthy> how's life treating you?
00:26:06 <earthy> and could you send me a copy of your thesis? :)
00:26:25 <swiert> I'd be glad to send you one, once I've written more.
00:26:45 <swiert> I hope to have a draft ready in about two weeks.
00:27:17 <earthy> ;)
00:27:31 <earthy> well, Doaitse told me to read it :)
00:27:49 <earthy> as it would be applicable to what I'm doing
00:28:37 <pesco> Good morning, #haskell!3~
00:30:34 <swiert> earthy: aha - what was it you were doing?
00:30:46 <swiert> (I should probably know this)
00:31:05 <pesco> cptchaos: Moin Moin Eike!
00:31:19 <cptchaos> pesco: moin moin
00:31:51 <earthy> swiert: currently I'm trying to hack together semantics combinators
00:31:57 <pesco> cptchaos: How's code? ;-)
00:32:17 <earthy> so that I can easily build a programming language's semantics given an AST
00:32:32 <cptchaos> bad, don't have time at the moment
00:32:48 <pesco> :( What are you doing, maths or physics?
00:32:55 <swiert> earthy - ok sounds neat. I can imagine that you might want to read my thesis.
00:33:55 <pesco> cptchaos: I'm off for a minute, need to fetch breakfast.
00:34:24 <cptchaos> pesco: i will be off very soon, have to sort papers for my Lawyer
00:34:29 <swiert> earthy: you may want to take a look at my wiki page - it already has a slightly oudated and incomplete draft of my work up till now.
00:34:32 <swiert> http://catamaran.labs.cs.uu.nl/twiki/st-intra/bin/view/Thesis/MasterProjectOfWouterSwierstra#Implementation
00:35:44 <earthy> swiert: I had found that ;)
00:40:10 <pesco> cptchaos: Are you sueing someone? :-?
00:40:52 <cptchaos> pesco: yes the LAsD (Landesamt fÃ¼r sozilale dienste)
01:49:52 <dblhelix> how long will it take to build ghc from source (iBook G4, 1.33GHz)?
01:55:08 <bourbaki> moin
02:07:30 <araujo> Morning
02:07:44 <araujo> Anyone has succesfully compiled hOp here?
02:08:04 <autrijus> dblhelix: why would you want to do that? :)
02:08:07 <autrijus> dblhelix: about 4 hours.
02:08:11 * shapr hops
02:08:24 <shapr> araujo: I've built hOp a bunch of times.
02:08:29 <araujo> Hello shapr 
02:08:31 <araujo> Nice
02:08:31 <dblhelix> autrijus: tnx
02:09:11 <araujo> Look, im getting this error when i ssue "make all"
02:09:12 <araujo> http://pastebin.com/229907
02:10:01 <shapr> Hmm, that sounds familiar, but I don't remember the solution.
02:10:12 <shapr> hej bringert 
02:10:24 <bringert> dude, that's fast
02:10:27 <bringert> hej shapr
02:10:32 <shapr> araujo: best to ask Lunar^ since he's one of the main authors of hOp
02:10:47 <araujo> Ah, cool. i'll do that
02:19:44 * shapr hops
02:21:09 <autrijus> so I'm vastly confused by the OOHaskell paper
02:21:24 <shapr> really?
02:21:36 <autrijus> as in, I understand the implementations
02:21:42 <autrijus> and followed the code
02:21:53 <autrijus> but I'm not sure why would one want to do that.
02:22:30 <shapr> People often complain that Haskell can't do OO
02:23:02 <autrijus> or, more specifically, what is the gain of modeling the whole, bundled OO semantic when one can pick the relevant ones in haskell.
02:23:02 <shapr> On the other hand, the O'Haskell people wrote some really nifty code that required OO features
02:23:41 <shapr> I think some people have become stuck in the OO paradigm.
02:24:03 <shapr> Which is tactful for me saying that I don't understand it either.
02:24:08 <autrijus> okay. :)
02:24:58 <shapr> One advantage I see in Haskell with partial evaluation replacing full OO mutability is that there's always a narrowing of future possibilities that simplifies the usability.
02:25:32 <autrijus> right.
02:25:54 <autrijus> B&D has its merits when you don't have to do it yourself.
02:26:24 <autrijus> and haskell is a capable dominatrix. ;)
02:29:20 * shapr laughs
02:29:50 * shapr runs off to Swedish class
04:12:51 <|Fo|Ns> hi all
04:13:17 <Lemmih> Greetings.
04:13:27 <|Fo|Ns> Id like to now if anybody knows about a doog monat tutorial
04:13:46 <|Fo|Ns> good monad tutorial
04:14:08 <ozone> |Fo|Ns: http://www.nomaware.com/monads/html/
04:14:46 <|Fo|Ns> thanks ozone 
04:15:09 <|Fo|Ns> and can anyone point me to some CGI examples using Haskell?
04:15:29 <ozone> google for "haskell wash"
04:15:40 <ozone> and/or "haskell cgi"
04:15:56 <ozone> i'm sure there are a few libraries around
04:16:07 <|Fo|Ns> ozone, id like to use hugs
04:16:20 <|Fo|Ns> and it has a CGI library
04:16:31 <ozone> well, google for haskell hugs cgi then :)
04:16:36 <|Fo|Ns> but Im not able to find examples of how to use that library
04:16:38 <|Fo|Ns> ok thanks
04:16:42 <ozone> i don't do CGI in haskell, so i don't really know
04:18:18 <|Fo|Ns> ozone, is that monad guide aviable in pdf?
04:18:21 <|Fo|Ns> id like to print it
04:18:51 <kosmikus> why would you want to use hugs?
04:20:26 <|Fo|Ns> kosmikus, just to avoid recompiling each time
04:20:48 <|Fo|Ns> WHat I need to do is a practical college asignment
04:20:56 <|Fo|Ns> and I dont have much time
04:21:39 <kosmikus> ghci can interpret, if you don't want to compile
04:22:07 <|Fo|Ns> the other reason is that I'm used to hugs
04:37:27 <ozone> |Fo|Ns: http://www.cse.unsw.edu.au/~andrep/nomaware-monads.pdf
04:37:45 <ozone> i made that pdf quite a long time ago.  dunno if the tutorial's changed in that time (it probably has), but it should be good enough
04:50:29 * boegel says "hi!"
04:52:19 <Lemmih> Greetings, boegel.
05:06:31 <boegel> heya Lemmih
05:06:42 <boegel> do you know any cure against uni-stress ?
05:07:06 * wli bangs out a Gröbner basis solver.
05:08:05 * boegel goes back to his "Fuzzy set theory" syllabus
05:10:02 <Lemmih> boegel: As a pre-college kid, I'm afraid I dont.
05:20:17 <|Fo|Ns> Im new to fields inside types in haskell
05:20:29 <|Fo|Ns> I mean something like
05:20:44 <|Fo|Ns> HtmlTag {                   -- tag with internal markup
05:20:45 <|Fo|Ns>               markupTag      :: String,
05:20:45 <|Fo|Ns>               markupAttrs    :: [HtmlAttr],
05:20:45 <|Fo|Ns>               markupContent  :: Html
05:20:45 <|Fo|Ns>               }
05:40:37 <|Fo|Ns> Im getting an error with runhugs
05:40:41 <|Fo|Ns> runhugs: compileExpr: invalid module
05:49:01 <bourbaki> boegel: hey
05:52:44 <shapr> d00d
05:53:29 <bourbaki> sweet
05:56:12 <samc> shapr, now that you are here, I'll re-ask: how do you organise the papers you download (or keep references to)?
05:57:06 <ozone> samc: if you use windows/mac, itunes can actually store pdfs in its "music" library now ...
05:57:14 <ozone> quite a nice way to keep papers organised
05:57:35 <tromp> as long as you can grep the contents...
05:58:09 <samc> I found out about that yesterday, I thought maybe do a little doctoring...
05:58:22 <samc> tromp: I can't for all
05:59:29 <samc> actually I cant grep any, but I can search most
05:59:36 <shapr> samc: I'm working on Fermat's Last Margin
06:00:23 <samc> which is?
06:00:30 <tromp> why cant you grep them?
06:00:54 <shapr> It's a research paper annotation tool that uses a wiki and darcs.
06:01:55 <samc> tromp: ps/pdf files don't generally have human readable text inside
06:02:05 <samc> shapr: sounds cool
06:03:17 * ozone makes a second recommendation for itunes, and proceeds to idle again
06:03:51 <shapr> yeah it is
06:04:17 <shapr> samc: here's the rough mockup - http://www.scannedinavian.org/RandomWiki/AnnotationMockup
06:04:59 <shapr> I originally thought that more annotation slots would be better, three for each page side. But it doesn't need to be that complicated.
06:07:18 <ozone> shapr: there are currently tools out there which allow you to add annotation text to PDFs, btw
06:07:27 <ozone> you may wish to check them out to steal ideas from, etc
06:07:36 <ozone> (dunno if any are available for linux, but they're certainly available for windows/mac)
06:10:43 <tromp> google manages to search pdf files. isn't there a program rendering pdf as text?
06:13:30 <samc> then to grep contents you would still need to save a text copy of all papers
06:13:46 <samc> on-the-fly would be too slow
06:14:01 <ozone> does google desktop do pdfs?
06:14:42 <samc> dunno, apples content indexing only does some
06:15:04 <ozone> what content indexing?  that isn't due out until tiger
06:15:16 <ozone> (and apple's spotlight most definitely handles pdfs)
06:15:20 <samc> you can search content now
06:15:42 <samc> os9 had content indexing
06:15:57 <ozone> people still use os 9? :)
06:16:00 <tromp> so just put your pdf files on the web and search them with google targetted at your site
06:16:11 <ozone> tromp: laugh, not a bad idea at all :)
06:17:07 <samc> apart from being illegal
06:22:35 <boegel> hey bourbaki , shapr
06:23:25 <earthy> xpdf: /sw/bin/pdftotext
06:23:46 <earthy> (ie: install fink, install the fink package xpdf, convert the pdf's to text... grep as you like)
06:24:00 <earthy> (or use pdftotext as a converter for ht://Dig or somesuch)
06:26:01 <MegaMonad> Greetings agent goerzen.
06:26:38 <CosmicRay> shapr: look what you've done! :-)
06:28:00 <CosmicRay> MegaMonad: I know where zion is.
06:28:01 <MegaMonad> CosmicRay: Hmm i thought you meant a bug or not, it's a big project (with probably 10 modules) how can you use stack, you know where zion is.
06:33:54 <Cale> MegaMonad: but are the modules... on the bottom of the SEA?!
06:33:55 <MegaMonad> Cale: Bottom is a long night maybe.  The same in ml i don't think halipeto has to happen at sea.
06:34:35 <samc> earthy, what does "ht://Dig" mean?
06:34:44 <Cale> MegaMonad: Of course it has to happen at sea, man, I mean, if that's what the budget is for, that's what it's for.
06:34:44 <MegaMonad> Cale: Sea of partial compilation of the happen to use lor's middle name in the man about --make, see how it does add deps and threadsafety.
06:35:54 <Cale> MegaMonad: That's right, a sea, a teeming, thrashing sea of partial compilation.
06:35:55 <MegaMonad> Cale: Hurrah; 5 days of compilation is a haskell and is thrashing.
06:36:42 <Cale> MegaMonad: Have you ever lived in a drum?
06:36:43 <MegaMonad> Cale: Dons: this is me in a drum?
06:37:32 <Cale> MegaMonad: I find that drums are too noisy, and you've got no corners to hide in!
06:37:32 <MegaMonad> Cale: Boegel, you find that drums are too noisy, and you've already spent on the corners.
06:38:12 <Cale> MegaMonad: heh, that was nearly intelligible in a twisted sort of way
06:38:13 <MegaMonad> Cale: Cosmicray: twisted is a concept of changing but likely we would still be intelligible english.
06:41:22 * boegel doesn't remember this quote
06:49:02 <earthy> samc: that's a search engine
06:49:18 <earthy> http://www.htdig.org/
06:49:36 <samc> thanks
06:52:32 <CosmicRay> samc: see www.htdig.org
06:52:44 <CosmicRay> bah
06:53:29 <samc> thanks anyway :)
06:54:02 <CosmicRay> samc: it is, fwiw, the search engine I run at lists.complet.eorg
06:54:21 <araujo> Hello.
06:54:24 <araujo> :-)
06:54:33 <CosmicRay> hello araujo
06:54:48 <araujo> Hello CosmicRay , how you doing today?
06:55:05 <CosmicRay> good, how about you?
06:55:17 <araujo> Pretty wel, thanks, just go hom :-)
06:55:19 <CosmicRay> wow, you are on a lot of channels
06:55:23 <araujo> got home*
06:55:28 <araujo> hah :-)
06:55:36 <CosmicRay> 17 or so, it looks like
06:55:59 <CosmicRay> do you use ruby much?
06:56:01 <araujo> Yeah, well, i try to say a few words in each one from time to time ;-)
06:56:20 <araujo> Im just starting with ruby actually.
06:56:27 <araujo> you?
06:56:36 <CosmicRay> I almost started to learn it, but then learned ocaml instead, and that led me to haskell
06:56:43 <araujo> :-)
06:57:03 <araujo> Of course, Haskell is the choice.
06:57:21 <CosmicRay> ruby seems to be one of those languages that manages to arrive at something useful precisely by accumulating the opposite of useful things on other languages
06:57:24 <araujo> Just that im sort of Smalltalk refuge, and ive heard Ruby is pretty much like it.
06:57:42 <araujo> Indeed.
06:57:52 <CosmicRay> my initial feeling was "this looks too much like perl" but it did look better nuder the hood
06:58:11 <CosmicRay> the reason I chose ocaml in the end, though, was because ruby wasn't different enough from python to make it worth my while to switch
06:59:09 <araujo> Sometime i need to make sme scripts for administration, i don't like Perl (though i used it for a while), but i would like something powerful than shell, so i think Ruby would be great (considering i programm in smalltalk sometmes)
06:59:31 <|Fo|Ns> can anyone tell me if its possible to use ghci in the same manner as runhugs?
06:59:34 * musasabi used ruby before haskell
06:59:42 <CosmicRay> I'm finding haskell to be very slick for things like filters ans parsers
06:59:43 <araujo> CosmicRay, do you programm in python?
06:59:43 <tromp> me too
06:59:48 <|Fo|Ns> I get an error from runhugs
06:59:54 <Lemmih> |Fo|Ns: Checkout 'runghc'
06:59:55 <araujo> I realyl don't know it, ive barely read a little about it.
07:00:05 <dblhelix> |Fo|Ns : what error?
07:00:15 <CosmicRay> araujo: yes.  check out http://www.complete.org/jgoerzen/softindex.html
07:00:24 <araujo> CosmicRay, yes!, that is precisely the main reason im stuck with Haskell :-)
07:00:27 <|Fo|Ns> runhugs: compileExpr: invalid module
07:00:56 <araujo> CosmicRay, i chgeck, though i tell you, i got no idea about python
07:01:08 <Lemmih> |Fo|Ns: What's the name of the module?
07:01:15 <CosmicRay> araujo: I will probably wind up rewriting most of my Python code in Haskell.
07:01:31 <|Fo|Ns> Lemmih, HolaMundo
07:01:53 <araujo> CosmicRay, oh nice
07:01:53 <Lemmih> |Fo|Ns: Try naming it 'Main'.
07:02:01 <araujo> CosmicRay, what are tyhe advantages of python?
07:02:41 <CosmicRay> araujo: To me, Python is the most clean object-oriented language out there, while still being useful
07:02:44 <|Fo|Ns> Lemmih, it worked fine
07:02:47 <|Fo|Ns> thanks a lot
07:02:58 <CosmicRay> araujo: others would call it "perl done right" or "java done right", depending on where they come from.
07:03:00 <araujo> CosmicRay, i did some perl a few years ago, though i gotta admit i barely found my way around....
07:03:07 <Lemmih> |Fo|Ns: No problem (:
07:03:15 <CosmicRay> araujo: there are a lot of Haskell people that have switched to Haskell from Python.
07:03:22 <araujo> CosmicRay, Ah...
07:03:34 <araujo> I actually found Haskell through Lisp.
07:03:53 <CosmicRay> araujo: there is actually some sharing of features between the two languages.  for instance, python lifted list comprehensions from haskell
07:04:33 <CosmicRay> araujo: python has some features that resemble functional languages, but they are really just tack-ons to an imperative language.
07:04:41 <araujo> Ah...
07:04:54 <CosmicRay> araujo: yes, one could call Haskell "lisp done right", "ocaml done right", or of course, "perl done right" :-)
07:05:05 <araujo> haha
07:05:10 <musasabi> btw does lazy imply pure?
07:05:31 <tromp> no
07:05:35 <Igloo> lazy implies pure || insanity
07:05:35 <CosmicRay> musasabi: no
07:05:50 <CosmicRay> musasabi: ocaml, for instance, has a Stream, which is basically a lazy list
07:05:50 <araujo> CosmicRay, im actually interested on Haskell because seems to me like the best language for compiler design.
07:05:54 <musasabi> tromp: what semantics would a lazy impure language have.
07:05:58 <araujo> And i need to do some projects about it.
07:06:04 <CosmicRay> araujo: have you looked at parsec?
07:06:12 <araujo> CosmicRay, No.
07:06:18 <musasabi> CosmicRay: but most of the language *is* strict.
07:06:35 <CosmicRay> araujo: http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html
07:06:48 <tromp> a messy one, musasabi
07:06:49 <araujo> CosmicRay, im still reading Introduction to Functional programming Using Haskell :-)
07:06:52 <CosmicRay> araujo: it is, in my opinion, the best parser tool I've seen yet
07:06:56 <CosmicRay> araujo: ah ok :-)
07:06:59 <araujo> let me check.
07:07:49 <musasabi> tromp: so it is possible, just not possible to have sensible semantics? (which was more or less what I thougth)
07:09:01 <araujo> CosmicRay, seems like i got LOT of stuff to study :-)
07:09:08 <araujo> Thanks for the link.
07:09:08 <CosmicRay> heh
07:09:28 <CosmicRay> araujo: sure.  Parsec, BTW, is included as part of GHC and most other modern haskell compilers or interpreters as Text.Combinators.Parsec
07:09:44 <araujo> CosmicRay, nice, yeah, just read that
07:10:05 <tromp> u can give it simple semantics, but it will give many unexpected results
07:10:25 <tromp> when programmer makes assignments that turn out not to execute due to laziness
07:12:16 <tromp> but i think any impure functional lang has messy semantics
07:12:24 <Darius> tromp: The programmer can just code in CPS if expected results are wanted, but then one might as well use monads.
07:12:30 <tromp> like lisp and ocaml
07:13:02 <Darius> tromp: What are languages that you consider as having nice semantics?
07:13:18 <tromp> anything pure:)
07:14:02 <tromp> untyped lambda calculus has the nicest semantics:)
07:14:08 <samc> in my opinion assembler has nice semantics
07:14:26 <CosmicRay> samc: on which cpu? :-)
07:14:33 <tromp> turing machine have nice semantics too:)
07:14:47 <tromp> as do register machines
07:14:47 <CosmicRay> samc: and if you say x86, I have just lost all respect for you :-)
07:14:52 <tromp> with just 2 instructions
07:15:04 <samc> all of the cpus in the world, but not x86
07:15:19 <tromp> many are worse than x86
07:15:22 <CosmicRay> how about this language: http://en.wikipedia.org/wiki/Brainfuck
07:15:40 <CosmicRay> http://www.muppetlabs.com/~breadbox/bf/
07:15:56 <samc> yea, bf has nice semantics
07:16:00 <CosmicRay> <g>
07:16:03 <Lemmih> Igloo: Yo. Remember the problem I had with TH and variable types in FFI declarations?
07:16:45 <Igloo> I remember you had a problem, but not what it was exactly
07:17:47 <samc> nice in the sense that they aren't confusing (unlike say c), ugly in the sense of getting things done (like say c)
07:20:39 <Lemmih> Igloo: It complained about out of scope variable types. Adding 'forall' fixed it.
07:22:22 <Igloo> Oh, interesting
07:22:51 <Igloo> Thanks
07:38:47 * boegel pokes shapr with a stick
07:41:04 <boegel> that Brainfuck language is pretty neat
07:41:18 <boegel> maybe I should try writing a raytracer in it :D
07:43:18 <Igloo> Did you manage to fix that bug, incidentally?
07:43:31 <samc> boegel, seen unlambda? another perverse language but maybe more to the liking of Haskellers
07:43:46 <bourbaki> the coolest language of all is chef
07:44:10 <Lemmih> Dr. Jan Itor.
07:44:20 <Lemmih> Ops. Wrong channel. Sorry about that.
07:45:42 <Lemmih> Igloo: Me? What bug?
07:47:00 <Igloo> No, boegel. The raytracer one.
07:47:15 <samc> bourbaki, I hadn't heard of that one, how long has kraml's site been down?
07:47:15 <Igloo> Something about a black spot I think
07:49:23 <bourbaki> samc: kraml?
07:50:01 <samc> he had an esoteric languages database www.kraml.at/stupid I think
07:50:36 <bourbaki> ah samcknow that 99 bottles of beer site?
07:51:01 <bourbaki> http://www.dangermouse.net/esoteric/chef.html
07:53:46 <samc> mmm, hello world
07:53:52 <boegel> Igloo: no ? i didn't answer yet :p
07:54:04 <boegel> Igloo: I didn't, I still don't know what I'm doing wrong
07:54:29 <Igloo> :-(
07:54:34 <boegel> Igloo: I've removed the refraction part out of my code for now, and I won't have time in the next couple of days to work on it
07:55:03 <boegel> Igloo: I will work on my code (structure it even more) after 27/01
07:55:19 <boegel> Igloo: when I have time left, I'll recheck the refraction stuff
07:55:26 <samc> are you sure it's wrong, if it isn't recursive...
07:55:38 <boegel> samc: I haven't seen unlambda, no :)
07:55:50 <boegel> samc: ?
07:56:14 <tromp> unlambda is basically combinatory logixc
07:58:45 <boegel> l33t is nice too: http://en.wikipedia.org/wiki/L33t_programming_language
07:58:59 <boegel> especially the "Hello World' example :
07:59:00 <boegel> :)
07:59:35 <sorje> Haha
08:02:18 <edwinb> Oh, wonderful ;)
08:08:27 <samc> this is just a thought (and a dumb one) if you aren't bouncing your rays off surfaces recursively, maybe light can't get to some spots due to refraction from curved surfaces, and it looks unusual because it isn't global illumination
08:10:31 * TheHunter likes the idea of a lazy impure language.
08:11:23 <Philippa> monads, HTH HAND
08:15:38 <TheHunter> basically, i think it's almost impossible to statically check that a monad is commutative (and there are examples of noncommutative monads that are only observed in a commutative way). So if you take away impurity, you can't have a nice syntax for comm. monads.
08:16:41 <TheHunter> of course io effects are better handled in a eager sublanguage.
08:30:47 <samc> what does it mean for a datatype to be strong?
08:31:05 <tromp> that it can lift its own weight
08:32:22 <Darius> samc: What is the context?
08:32:31 <samc> charity
08:32:41 <edwinb> Depends on the context, but it *may* mean that recursive arguments are strictly smaller.
08:32:54 <samc> that'll be it
08:33:52 <samc> maybe, what about corecursion though
08:34:43 <edwinb> That would still work with corecursion wouldn't it?
08:35:28 * samc is unsure
08:35:44 <samc> I guess I'll just read more
08:37:57 <Matt-W> Stupid question: what's corecursion?
08:40:14 <edwinb> A corecursive function creates data, i.e., guarantees adding a constructor.
08:40:27 <edwinb> That's probably a bad explanation. David Turner's "Total Functional Programming" paper explains it well.
08:41:07 <Matt-W> hmm
08:41:12 <Matt-W> that's not what I was expecting at all
08:41:26 <Matt-W> moral: never guess what strange words mean in computer science :-)
08:41:29 <edwinb> heh
08:42:03 <sorje> Go for the generalisation: never guess what strange words mean in science ;-)
08:42:16 <Matt-W> or even better, never guess what strange words mean
08:42:48 <sorje> or never guess ;-)
08:43:00 <Philippa> nah, there're situations where you have no choice
08:43:21 <Matt-W> all rules have exceptions
08:43:37 * sorje 's usually solving his math assignments that way ;-)
08:44:06 <edwinb> I always did maths assignments using "Proof by doing something impossible over a page break"
08:44:24 <samc> hehe, I looked up what gibbons says "there is no standard definition for the notion of corecursion"
08:44:24 <sorje> Hehe, good idea ;-)
08:44:40 <bringert> Matt-W: even that one?
08:44:56 <Matt-W> bringert: yes
08:45:17 <bringert> so some rules don't have exceptions?
08:45:31 <bringert> is the rule about exceptions one of those rules?
08:45:37 <Lunar^> "Dynamically linked "Hello, world" now works on x86 Linux."
08:45:40 <Lunar^> waow!
08:46:09 <edwinb> ooh!
08:46:18 <Matt-W> bringert: no
08:46:30 <Matt-W> is that dynamically linked hello world in haskell?
08:46:40 <Lunar^> Matt-W: Wolfgang works
08:47:13 <Matt-W> <confused>
08:47:17 <Matt-W> or more likely, <ignorant>
08:55:19 <Lunar^> Matt-W: look at last messages on cvs-ghc ML
08:55:54 <Matt-W> Lunar^: I shall. It sounds interesting and useful
09:05:26 <samc> pdftotext ignores ligatures :(
09:06:40 <Oejet> samc: Drops the letters in the ligatures?
09:06:49 <samc> yep
09:07:39 <Oejet> He, "patches are welcome". ;-)
09:29:43 <evergree`> stepcut?
09:35:00 <stepcut> yes ?
09:36:32 * stepcut goes to work, back online in ~45mins
09:47:31 <evergree`> stepcut: Google tells me in Jul 2004 you noticed a problem using darcs inside of eshell.  I have persistent problems with eshell sending darcs HUPs.  Did you ever resolve the problem you experienced?
10:03:02 <WilX> Hmm...
10:03:09 <WilX> This is very interesting.
10:03:31 <WilX> I am reading about STG machine that is used to implement Haskell.
10:04:30 <WilX> I feel so...enligtened :)
10:09:50 <Oejet> WilX: Do you have a reference to the paper?
10:11:53 * Oejet read the generic Haskell paper and felt not very enlightened.
10:12:51 * ddarius read Bart Jacobs thesis and about the sixth time through felt enlightened.
10:13:50 <WilX> It is linked from GHC's Documentation page.
10:14:00 <WilX> Spineless Tagless G-machine
10:15:22 * Oejet got enlightenment and stopped being a gnome.
10:15:29 <WilX> Heh.
10:15:30 <WilX> http://research.microsoft.com/copyright/accept.asp?path=/users/simonpj/papers/spineless-tagless-gmachine.ps.gz#26pub=34
10:16:15 * ddarius hasn't been able to use Ion to the fullest yet, but seems to like it to the extent he has used it.
10:16:16 <shapr> ddarius: is that cuz bart jacobs wrote his thesis in Dutch?
10:17:47 <Darius> No, because it's about fibrations and comprehension categories and not exactly aimed at beginners.
10:18:06 <Darius> However, it does make me really want to read "Categorical Logic and Type Theory"
10:18:10 <evergree`> stepcut: Question for you up a ways.
10:18:28 <Darius> And the online prospectus is a fairly good advertisement as well.
10:18:31 <Symmetry_> hi haskell
10:18:47 <shapr> haskell says hello.
10:19:48 * stepcut looks in the logs
10:20:20 <evergree`> stepcut: Google tells me in Jul 2004 you noticed a problem using darcs inside of eshell.  I have persistent problems with eshell sending darcs HUPs.  Did you ever resolve the problem you experienced?
10:20:48 <stepcut> evergree`: I upgraded to a newer version, and I still get a warning about HUPs but it no longer seems fatal
10:21:26 <stepcut> darcs pull -a
10:21:26 <stepcut> Pulling from http://www.cse.unsw.edu.au/~dons/yi...
10:21:26 <stepcut> Couldn't handle HUP since darcs was in a sensitive job.
10:21:26 <stepcut> Finished pulling.
10:21:47 <evergree`> I have a repo (of darcs itself) that, whenever I "darcs pull --all", it prints "HUP" and then exits.
10:21:54 <evergree`> A newer version of darcs?
10:22:03 <stepcut> ii  darcs                            1.0.0.final-2                    an advanced revision control system
10:22:17 <evergree`> Hmm.  I'm using darcs 1.0.1.
10:22:31 <stepcut> when I was using something < 1.0 I got the HUP and then exit, now I get the above 
10:22:40 <evergree`> I think this is probably an eshell problem.
10:22:55 <stepcut> eshell has some strange interaction with haskell programs sometimes
10:23:03 <evergree`> Eshell had problems with gnumeric once upon a time too (sending it HUPs).
10:24:02 <evergree`> Hrm.  Well I'll keep digging.  I've been using darcs in bash for a few months because I'm afraid of corrupting a repository.
10:24:06 <evergree`> Thanks for the info!
10:24:49 <stepcut> As a hack, you could try making a built-in darcs command for eshell that runs darcs under bash...
10:25:44 <stepcut> It is unfortunate the eshell is not really maintained because it is very nice except for a few things
10:25:48 <musasabi> alias eshell="bash eshell" ?
10:26:00 <xerox> A question, can you suggest me a good representation of ``hereditary representation of a number'', in Haskell? (For reference of HR take a look at http://mathworld.wolfram.com/HereditaryRepresentation.html)
10:26:01 <musasabi> +-c 
10:26:55 <stepcut> musasabi: ??
10:27:11 <CosmicRay> data HNum = 
10:27:13 <CosmicRay> err
10:27:21 <CosmicRay> I guess you'd need to have a base and then a list of components
10:28:02 <evergree`> stepcut: I'll try that idea and let you know...
10:28:43 <xerox> CosmicRay, I think a list would be ok, maybe a list of nested tuples (base,exp) ?
10:29:10 <CosmicRay> in that example, the base was always the same...
10:29:42 <CosmicRay> so maybe data HNum = HNum Int [HNum]
10:29:47 <CosmicRay> hmm
10:29:54 <CosmicRay> nope, you're still duplicating the base.
10:33:07 <Darius> xerox: It might just be a rose tree.
10:33:28 <xerox> What's a rose tree?
10:33:29 <Darius> Which is pretty much what CosmicRay has.
10:35:16 <Darius> So, I think CosmicRay is right and just factor out the base, data HNum' = HNum' [HNum'] type HNum = (Int,HNum')
10:36:24 <xerox> And then how to use it?
10:36:26 <Darius> You may want an explicit One constructor.
10:36:55 <xerox> Hm, they call me for dinner, thanks for the help, bbl
10:37:00 <xerox> (Write, I'll read)
10:37:53 <Symmetry_> guys, really noobie Q: everyone goes on about Lisp this and that, is Haskell just as powerful?
10:39:09 <Lemmih> Symmetry_: Define 'powerful'.
10:39:34 <Symmetry_> um
10:39:51 <Darius> 2^(2^1+2^0) + 2 = (2,HNum [HNum [HNum [HNum []],HNum []],HNum [HNum []]]) (I think, or with a One constructor, (2,HNum [HNum [One],One],HNum One])
10:39:56 <Symmetry_> like, whatever Lisp can do, Haskell can do, and prettier
10:40:33 <Darius> Or maybe HNum should be (Int,[HNum']) for the base case, but the idea is that the HNum type simply represents the shape of the exponentials
10:40:35 <Lemmih> Symmetry_: Beauty is in the eye of the beholder.
10:41:44 <Lemmih> Symmetry_: But yes, Haskell is a general purpose programming languages.
10:42:02 <Symmetry_> OK. I guess I was just asking whether there is anything Lisp can do that Haskell can't
10:42:38 <mflux> I suppose the greatest difference in the expressiveness is that plain haskell cannot generate/modify haskell code?
10:43:03 <Symmetry_> aha. ok
10:43:16 <Lemmih> That's why we have Template Haskell.
10:43:36 <mflux> but even then, it can't do it dynamically?
10:43:45 <stepcut> Persistance can be tricky in haskell
10:44:51 <Lemmih> mflux: Is that desirable? I really like that a well typed program can't go wrong at runtime.
10:45:07 <mflux> lemmih, maybe not, but that's what lisp can do but haskell can't?-)
10:45:16 <mflux> otoh, haskell can check programs much better compile time
10:46:04 <stepcut> Lemmih: you can have both ... hs-plugins has a type-safe eval function
10:47:55 <Lemmih> Oh yeah.
10:48:28 <stepcut> lisp macros can be pretty powerful -- not sure how TH compares...
10:49:34 <Darius> stepcut: I'm not sure if you can use TH macros to make TH macros (it seems like it should just require adding the necessary syntax constructors) but otherwise you have the full power of Haskell with them
10:50:11 <Darius> stepcut: You also have the benefit of being able to get type information as well.
10:54:09 <stepcut> where is smerdykov when you need him ;)
10:56:59 <CosmicRay> stepcut: #ocaml? :-)
10:57:15 <CosmicRay> ah, indeed so :-)
11:02:08 <stepcut> heh
11:19:14 <Lemmih> Greetings, SyntaxNinja.
11:21:08 <SyntaxNinja> hi Lemmih
11:22:05 <SyntaxNinja> man... malcolm and simon want platform-dependent build-dependencies, where platform includes compiler, compiler version, os, and possibly os version
11:22:20 <stepcut> heh
11:23:34 <stepcut> Build-depends: ghc (>= 6.3) [i386] {>> linspire 5.0}
11:23:38 <stepcut> :p
11:24:59 <Igloo> Is cpphs not the answer?
11:25:16 <Igloo> Hmm, I suppose it means you need to iterate to satisfy deps
11:25:17 <SyntaxNinja> stepcut: something like that, yeah
11:25:39 <SyntaxNinja> stepcut: but conditional too! like since posix only exists on unix...
11:25:48 <SyntaxNinja> build-depends: if-not-os("mingw32",unix >= 1.0)
11:29:11 <Lemmih> Will it be like that in GHC 6.4?
11:30:04 <SyntaxNinja> no, they want to put it in cabal
11:30:32 <SyntaxNinja> I think that they can implement that if they want it...
11:30:44 <SyntaxNinja> I'm hoping that I can start hacking on hackage after the release
11:31:38 <Lemmih> Neat.
11:33:03 <SyntaxNinja> there are enough people familiar with the codebase these days.
11:34:35 <SyntaxNinja> cabal pre-pre release here: http://www.haskell.org/cabal/cabal-code.tgz
11:34:36 <Lemmih> What would you hack in hackage?
11:35:40 <SyntaxNinja> not sure where exactly yet.  I'd like to have people upload a tarball and have it unpack, build the API docs, suck out the description file, etc.
11:36:05 <SyntaxNinja> but we can't allow uploads from just anyone, I guess, since that would require running their code on the machine.
11:36:15 <SyntaxNinja> this is a job for... SELinux!
11:36:42 <xerox> Darius, okay, it gives me type error if I try to put into the fst of HNum the result of a floor, how can I fix it?
11:37:03 <SyntaxNinja> or just have the user give a URL to a tarball, then do all that
11:37:09 <xerox> Darius, type HNum = (RealFrac a, Num a) => (a,HNum') doesn't really works
11:37:22 <xerox> -s
11:37:45 <Lemmih> SyntaxNinja: It sounds dangerous.
11:37:55 <Darius> type HNum a = (a,HNum')
11:38:11 <SyntaxNinja> Lemmih: yeah
11:38:28 <stepcut> mmm, SELinux
11:38:35 <SyntaxNinja> but if we only let _some_ people upload, then that might work
11:38:37 <xerox> Darius, hmm
11:38:45 <SyntaxNinja> like... me & you :)
11:38:46 <stepcut> I hope to work on SELinspire someday (soon)
11:39:08 <SyntaxNinja> stepcut: cool!
11:39:08 <xerox> Darius, okay thanks.
11:39:54 <stepcut> SyntaxNinja: I hope it will be :)
11:41:06 <Lemmih> SyntaxNinja: Wait, would building Haddock documentation require running foreign code?
11:41:48 <SyntaxNinja> Lemmih: ./setup haddock :)
11:42:09 <Lemmih> Oh yeah.
11:42:50 * Lemmih was thinking about ignoring Setup.lhs and using Cabal directly.
11:42:58 <SyntaxNinja> but SELinux would be perfect, we could just tell it "you can only execute these programs, you can only write files here, you can only blah blah"
11:43:13 <SyntaxNinja> Lemmih: that might be a good idea if we let random people upload
11:43:37 <SyntaxNinja> but then it wouldn't be guarenteed to work
11:43:41 <Lemmih> SyntaxNinja: What about hooks and other Setup.lhs stuff like that?
11:44:02 <SyntaxNinja> what about them?
11:45:20 <Lemmih> Wouldn't they be ignored which is bad?
11:45:36 * Lemmih has been out of the Cabal loop for quite some time.
11:46:21 <SyntaxNinja> Lemmih: yeah, that would be bad. that's what I meant by "wouldn't be guarenteed to work"
11:47:13 <SyntaxNinja> so the right thing for now would be to have just a few people who could upload packages, probably not via the web or anything, but via ssh
11:53:49 <xerox> Darius, can you help me writing a "converting" function? I'm lost, with datatypes :-\
11:54:28 <Darius> xerox: Converting between what?
11:54:47 <xerox> Darius, from Integer to HNum, for example
11:58:02 <Darius> xerox: Well where are you so far?
11:58:24 <xerox> Trying to understand how does it work the recursive datatype
11:58:42 <SyntaxNinja> stepcut: get right on that SELinspire, OK?
12:01:43 <stepcut> SyntaxNinja: I'll try ...
12:02:09 <xerox> Darius, (2,One) is 2^1, right?
12:02:58 <SyntaxNinja> CosmicRay: alive?
12:03:12 <xerox> Darius, whoops, 2^0
12:03:21 <Darius> xerox: We can describe the hereditary representation as: "The hereditary representation with base, b, of a number is the sum of a list of powers of b with the hereditary representation with base b of exponents" 
12:03:49 <Darius> The data type follows the definition.  At first, it'll probably be better to ignore the parameterization with b.
12:05:03 <xerox> So data HNum' = HNum' [HNum'] | One deriving (Show)  type HNum a = (RealFrac a, Integral a) => (a,HNum')  okay?
12:05:18 <Darius> xerox: Making a pretty-print function for the data type is probably the first thing you want to do.
12:06:26 <Darius> xerox: Thinking more, a One constructor is probably less beneficial for understanding than working with the "raw" form.
12:06:55 <xerox> So, I'll get back to the "raw form"
12:07:16 <CosmicRay> hugs exists on every debian platform, yes?
12:07:18 <CosmicRay> SyntaxNinja: yes
12:07:32 <xerox> Darius, so I'll need something like instance Show HNum' where ... ?
12:08:15 <xerox> Maybe HNum
12:08:47 <SyntaxNinja> CosmicRay: not every debian platform, I think.
12:09:04 <SyntaxNinja> CosmicRay: got a chance to look at 0.3 prerelease?  I'm tweaking the .deb now
12:09:30 <CosmicRay> I haven't looked at it yet but it sounds like I should be able to adjust my tools very trivially
12:09:33 <Darius> xerox: To factor the data type better (for clarity) and to make what does what clearer, newtype SumOfTerms a = SumOfTerms [a] and newtype HNum = HNum [SumOfTerms [HNum]] might be useful.
12:09:37 <SyntaxNinja> CosmicRay: yeah
12:09:39 <CosmicRay> SyntaxNinja: could you send me the source stuff when you get it uploaded?
12:09:42 <SyntaxNinja> any problem with me uploading it?
12:09:55 <CosmicRay> cabal, you mean?  no, go ahead
12:09:58 <SyntaxNinja> CosmicRay:  sure. fwiw, you can 'debuild' in the darcs tree
12:10:00 <SyntaxNinja> CosmicRay: yeah
12:10:16 <SyntaxNinja> maybe I should jump to 0.4 and keep stable releases even
12:10:20 <CosmicRay> SyntaxNinja: do you have all your debian patches pushed into it?
12:10:33 <Darius> xerox: With that representation the HNum represents something of the form 'base^(sum of terms)'
12:10:42 <SyntaxNinja> CosmicRay: yeah; the only sticking point is that the repository is corrupted by the darcs 1.0.0 bug
12:11:01 <CosmicRay> "the" bug? :-)
12:11:01 <xerox> Darius, what exactly is newtype ?
12:11:03 <SyntaxNinja> I think I'm going to go ahead and jump to 0.4
12:11:26 <Darius> xerox: Writing a show instance for SumOfTerms that will display them as 2+3+1 etc. (for SumOfTerms Int) is easy (but make sure to cover the base case SumOfTerms [])
12:11:34 <SyntaxNinja> that way, if people build debian packages based on unstable snapshots, they will get the new version when it hits apt
12:11:37 <CosmicRay> SyntaxNinja: ok.  would you just ping me when it's in a state where I can do a pull and get what you uploaded, or send me the source stuff that you've uploaded?
12:11:45 <SyntaxNinja> CosmicRay: yeah
12:11:52 <CosmicRay> SyntaxNinja: thanks.  that'll be great.
12:12:29 <Darius> xerox: In C it would be called a 'strong typedef', it's a compiler checked type synonym.  But you can just use and think of it as 'data' for now.
12:13:41 <xerox> Darius, what is the a in newtype SumOfTerms a = SumOfTerms [a] ?
12:14:06 <CosmicRay> are there any platforms where hugs is not supported but other haskell stuff is?
12:15:00 <Darius> xerox: It represents the type of the "terms".  So SumOfTerms Int would pretty-print as 1+2+3, SumOfTerms HNum will then print as 2^(2^1+2^0) + 2^0
12:15:23 <Darius> xerox: I.e. the SumOfTerms data type represents the sum of anything.
12:15:25 <SyntaxNinja> CosmicRay: I take it back, it seems to build happily everywhere now
12:15:41 <CosmicRay> SyntaxNinja: excellent.  my grand plan is to eventually rewrite dh_haskell in haskell.
12:15:44 <Darius> xerox: The idea is to handle that aspect of the hereditary representation separately.
12:15:56 <CosmicRay> SyntaxNinja: if I make it a runhugs script, it shouldn't cause trouble for anyone
12:16:03 <Darius> xerox: So that it doesn't get confused with other issues.
12:16:27 <xerox> Darius, I have problem with the language and the syntax itself too, I can't really understand all of this
12:17:06 <SyntaxNinja> CosmicRay: I think it should be fine.
12:17:08 <xerox> Hm, not "all" btw
12:18:37 <SyntaxNinja> Igloo: alive? any interest in packaging up runghc separately from ghc 6.4?
12:20:01 <Igloo> How will that help?
12:20:09 <Darius> xerox: Are you reading a book or a tutorial on Haskell?
12:20:13 <Igloo> It would have to depend on ghc wouldn't it?
12:21:02 <xerox> Darius, I'm reading "Yet Another Haskell Tutorial"
12:23:45 <SyntaxNinja> Igloo: it would just be good to have
12:23:51 <Darius> xerox: I made a minor mistake earlier, I wanted newtype HNum = HNum (SumOfTerms [HNum]) as opposed to [SumOfTerms [HNum]]
12:24:01 <SyntaxNinja> then CosmicRay can write "runhaskell" :)
12:24:30 <Igloo> You're talking about when ghc6 is version 6.4, right? I just don't see what this gains us
12:24:36 <xerox> Darius, ah, okay
12:25:31 <CosmicRay> SyntaxNinja: since hugs is a lot more portable than ghci anyway, it probably wouldn't buy me much :-)
12:25:32 <SyntaxNinja> Igloo: no, I"m talking about packaging it now
12:25:57 <Igloo> Ah, in which case I'd be much more interested in putting a runhugs binary in ghc6 now
12:26:04 <Igloo> Err, runghc that is
12:26:52 <SyntaxNinja> whew. you scared me for a second there
12:27:13 <Darius> xerox: A final renaming of constructors should make it pretty clear what each thing represents: newtype SumOf a = SumOf [a]; newtype Exponent = BaseToThe (SumOf Exponent)
12:27:20 <SyntaxNinja> I think that runghc is just a little C program, it probably doesn't depend on 6.4 at all, but I don't know for sure. it would be nice to have.
12:27:57 <xerox> Darius, so it's newtype HNum = HNum (SumOf [HNum]) ?
12:27:57 * Igloo certainly isn't making a package just for runghc which is due to be obsoleted by the end of the month, anyway  :-)
12:28:55 <Darius> xerox: Exponent replaces HNum, a complete number in hereditary representation is a sum of exponents, so type HereditaryRep = SumOf Exponent
12:29:17 <SyntaxNinja> oh, it could be part of the ghc6 package, I don't see anything wrong with that
12:29:26 <Darius> xerox: Perhaps "power" or some other word might be a bit better than "exponent"
12:29:27 <SyntaxNinja> except for those poor autobuilders
12:30:21 <Igloo> Conveniently ghc6 isn't ported to those that are struggling  :-)
12:31:07 <xerox> Darius, I'm a bit lost with all this types, I'm not used to type definition
12:31:48 <xerox> I mean, it can be that those expression are "expressive" but not to me at the moment, sigh
12:33:14 * Igloo ponders the probability of 6.4 getting into sarge
12:35:26 <CosmicRay> Igloo: when is 6.4 supposed to release?
12:36:14 <Igloo> SPJ said January in the last few days, I think
12:36:26 <CosmicRay> is there a changelog somewhere?
12:36:44 <Igloo> Not sure
12:37:08 <SyntaxNinja> man. I hope that simonmar plans to do a lot of cabal hacking if he wants to release 6.4 with it
12:38:08 <Lemmih> I'm still not sure when "soon" is.
12:38:16 <xerox> Darius, is it what you meant? BaseToThe (SumOf []); BaseToThe (SumOf [BaseToThe (SumOf [])]); etc.. ?
12:42:59 <ralf> foo
12:43:41 <Darius> xerox: Those would be some elements, yes.  0 would be SumOf [], 1 BaseToThe (SumOf [])
12:44:20 <SyntaxNinja> hi ralf
12:44:28 <xerox> Darius, where's the base?
12:46:01 <Darius> xerox: It's irrelevant to that part, but when you want to print it or convert it to a number you'd provide a base and interpret BaseToThe exp as 'base^exp'.
12:47:33 <Darius> xerox: This does mean you can't make an instance of Show that pretty-prints the values unless you fix a base.  Instead you'll need to write a specific function, showHNumWithBase base hnum or some such.
12:48:57 <Lemmih> ralf: Baz.
12:50:22 <Darius> Lemmih: Bah! "bar"
12:50:36 <xerox> quux!
12:52:36 <ralf> SyntaxNinja: hi. 
12:52:37 <xerox> Darius, where can I read about it? I don't find YAHT helpful on this
12:52:48 <CosmicRay> xerox: yess? :-)
12:52:56 <SyntaxNinja> ralf speaks!
12:53:09 <ralf> Yeah, but I'm just leaving for the grocery store. 
12:53:14 <Riastradh> Not Ralf Hinze, I suppose?
12:53:16 <SyntaxNinja> of course
12:53:20 <SyntaxNinja> Riastradh: no
12:53:36 <ralf> I was supposed to go a half hour ago, but I got sucked into wikipedia
12:53:37 <Lemmih> Darius: Foobaz?
12:53:41 * ralf loves wikipedia.
12:54:28 <ralf> I read the article: "The Long And Winding Road."  About that song by the beatles.  Man, it was a good article.  Then I read about Bismarck and then Conservatism.  I just read about Polanyi, and now I am going to go buy ice cream. 
12:55:20 <ralf> http://en.wikipedia.org/wiki/The_Long_and_Winding_Road 
12:55:23 <ralf> Check it out. 
12:57:45 <SyntaxNinja> CosmicRay: I just pushed some stuff, cleaned up the repo (hopefuly no "the bug" bug) and made a "make deb" rule that does a bunch of stuff in /tmp
12:59:34 <Darius> http://www.haskell.org/tutorial/goodies.html and http://www.haskell.org/tutorial/moretypes.html cover algebraic data types
13:01:48 <xerox> Thanks
13:02:27 <CosmicRay> SyntaxNinja: is that the final version you're uploading?
13:02:47 <SyntaxNinja> CosmicRay: I think so, but I wont' be 100% sure until I do it ;)
13:02:50 <CosmicRay> ok
13:02:54 <CosmicRay> just let me know when you do :-)
13:05:06 <SyntaxNinja> okok
13:16:26 <balbo_> is there a function that returns both `div` and ` mod` as a pair?
13:18:33 <balbo_> yes there is!
13:18:49 <balbo_> it's in the prelude guys!
13:19:25 <zamez> what's it called?
13:19:29 <Darius> balbo: To an extent, there's two.
13:19:42 <balbo_> divMod is the one i found
13:20:33 <balbo_> Darius: which is the other one you were thinking of?
13:22:13 <Darius> Two similar but different functions are quot and rem which gives quotRem.
13:22:17 <Darius> @type quot
13:22:19 <lambdabot> quot :: forall a. (Integral a) => a -> a -> a
13:22:22 <Darius> @type quotRem
13:22:23 <lambdabot> quotRem :: forall a. (Integral a) => a -> a -> (a, a)
13:25:43 <balbo_> yes they are very similar. in fact i cannot see the practical difference.
13:27:25 <balbo_> @type divMod
13:27:26 <lambdabot> divMod :: forall a. (Integral a) => a -> a -> (a, a)
13:28:23 <Darius> balbo_: I believe divMod is "more correct" than quotRem, but quotRem can typically be implemented faster.  At any rate, they are different functions.
13:28:48 <balbo_> ok
13:30:18 <SyntaxNinja> CosmicRay: OK I've done it!
13:31:01 <SyntaxNinja> cabal 0.4 released: http://www.haskell.org/cabal/download.html
13:31:56 <CosmicRay> SyntaxNinja: sweet
13:32:26 <SyntaxNinja> man... releasing software is hard. there's an infinite number of tweaks I want to perform
13:32:54 <SyntaxNinja> I need a release engineer or something, a QA guy
13:33:50 <Igloo> Are you willing to pay him?  :-)
13:36:30 <SyntaxNinja> do yuo mean with money?
13:36:44 <xerox> Darius, was it: instance Show a => Show (SumOf a) where ?
13:36:56 <Darius> Yes.
13:37:04 <xerox> ooh :)
13:37:34 <Igloo> I could probably be persuaded to take gold, but money would be more conventinoal
13:39:02 <xerox> Darius, I didn't understand what can I do inside this instance declaration, btw
13:40:08 <Darius> xerox: You define show to output SumOf [a,b,c] as "a + b + c" or however you like.  Looking through the functions in the Prelude and in (Data.)List can make this really easy.
13:40:57 <WilX> You need either fixed goals of fixed time frame.
13:43:53 <xerox> Darius, using foldr?
13:45:31 <xerox> uhu.
13:53:39 <xerox> Darius, ta-da!
13:53:41 <xerox> *Goodstein> SumOf [1,2,3]
13:53:41 <xerox> 1+2+3
13:57:10 <balbo_> how to create a partial sum of a list of integers?
13:58:04 <xerox> balbo_, as (+2) ?
13:58:21 <balbo_> partialSum [1,1,1] = [1,2,3]
14:00:17 <xerox> balbo_, I think (+) (foldr1 (+) list)
14:00:48 <xerox> *Goodstein> let f = (+) . (foldr1 (+))
14:00:57 <balbo_> xerox: i don't know man..
14:01:06 <xerox> *Goodstein> let g = f [1..3]
14:01:06 <xerox> *Goodstein> g 4
14:01:06 <xerox> 10
14:02:27 <xerox> balbo_, ok?
14:03:22 <balbo_> xerox: i don't think so.
14:03:49 <xerox> g is the partial application of the sum of a list of integers
14:03:58 <xerox> whoops, misread your question, sorry.
14:04:02 <Igloo> Look at scanl1
14:04:11 <xerox> :(
14:06:15 <xerox> Darius, what's next?
14:08:18 <balbo_> Igloo: thx!
14:11:57 <Darius> xerox: Does show (SumOf []) do the right thing?
14:12:33 <xerox> Non-exhaustive patterns in function showSumOf
14:12:35 <xerox> :\
14:12:51 <Darius> Well, what do you think SumOf [] should be?
14:13:12 <xerox> 0 ?
14:14:00 <Darius> xerox: Yes.  The easiest way to do it would probably be by adding another pattern matching clause to the current function to explicitly handle the [] case.
14:14:07 <xerox> Yep, done.
14:19:03 <CosmicRay> argh
14:19:05 <CosmicRay> syntaxninja left
14:19:22 <CosmicRay> http://www.haskell.org/cabal/proposal/x611.html talks about the modules line, but it doesn't seem accepted anymore.
14:20:17 <Darius> Bye.
14:20:28 <xerox> byebye ^__^
14:20:58 <Igloo> It got replaced by exposed=modules and hidden-modules or similar I believe
14:21:07 <CosmicRay> yup, I see that now, looking at the source
14:22:20 * wli hunts for an SMTP client lib.
14:22:35 <CosmicRay> wli: 
14:22:36 <CosmicRay> hm.
14:23:00 <CosmicRay> I was about to say that I wrote one, but it appears I haven't gotten around to that yet :-)
14:23:07 <wli> I've written one.
14:23:10 <wli> But it was crusty.
14:23:12 <CosmicRay> ah.
14:23:18 <creichen> Hi! Does anyone here have any suggestions for provers/proof assistants that can handle \lambda 2- typed programs with potential nontermination?
14:23:59 <balbo_> what the opposite of zip?
14:24:08 <balbo_> @type unzip
14:24:09 <CosmicRay> unzip?
14:24:10 <lambdabot> unzip :: forall b a. [(a, b)] -> ([a], [b])
14:24:25 <balbo_> ok. thx
14:24:50 <wli> I wrote a crappy one-off Gröbner basis lib last night.
14:25:40 <Oejet> Is there a general opposite higher order function? E.g. "opposite zip = unzip".
14:25:56 <wli> nope
14:26:18 <wli> well, depends on generality
14:26:31 <wli> there's duality in some things
14:27:01 <wli> your specific example probably falls under that
14:27:16 <Oejet> Ah, and the md5sum function is a nice counter example.
14:27:31 <Oejet> Or just modulus.
14:27:33 <wli> try `mod` 2
14:27:44 <creichen> 'fold' in general would be a counterexample, or just the "head" function for lists.
14:28:13 <Oejet> Or p*p' where p and p' are very big primes.
14:28:16 <wli> (^2)
14:28:21 <balbo_> how to get the first in a tuple?
14:28:24 <wli> loses the minus sign
14:28:56 <Oejet> @type fst
14:28:57 <lambdabot> fst :: forall a b. (a, b) -> a
14:29:18 <balbo_> i knew it was something with first....
14:29:28 <balbo_> thx
14:37:33 <xerox> Is there any factor function somewhere in some lib?
14:43:04 <Heffalump> anyone know of any graphviz bindings?
14:43:46 <shapr> doesn't hIDE have something like that?
14:44:09 <shapr> for example - http://www.scannedinavian.org/~shae/hIDE.png
14:44:29 * Igloo wonders what Heffalump is writing
14:46:02 <Heffalump> visualiser for darcs repos
14:46:12 <Heffalump> take a bunch of darcs repos of the same project, draw graph showing relationships
14:46:43 <Heffalump> shapr: looks like it, where's the source?
14:49:10 * Heffalump jfgoogles it
14:50:45 <Heffalump> ah, it just executes graphviz.
14:51:49 <Igloo> Ah, interesting
14:52:23 <Igloo> What's the relationship? "has as last repo", "has in repos", "has subset of patches in"?
14:52:43 <Heffalump> it'll be to do with the patches each has or hasn't
14:52:51 <Heffalump> I haven't quite worked out precisely what yet.
14:53:02 <Igloo> *nod*
14:53:33 <Heffalump> right now I have it detecting trees of patchsets but not recovering graph structure
14:54:28 <Igloo> If you plan to have it go into darcs you might want to bear in mind that graphviz may not be Free, incidentally. The only alternative I can name OTTOMH (springgraph) looks like it is written in perl, though
14:55:49 <xerox> Is there some function to change the base of a number?
14:56:27 <Igloo> There is a function to show in an arbitrary (well, up to some number) base
14:56:41 <xerox> Interesting, what is it?
14:57:09 <Igloo> Can't remember. showInBase or something probably, in a standard module called something obvious if not Prelude
14:57:35 <Heffalump> I expect it would be a tool to be used by the side of darcs
15:00:26 <tromp> showIntAtBase
15:02:51 * Heffalump wonders why Syntax called the new Cabal release 0.4
15:03:27 * Heffalump reads the changelog and is ethingummied.
15:03:55 <jberg> ok, this is my first attempt at writing an haskell program.. http://www.rafb.net/paste/results/wmLtb478.html am i way off or have i done something right?
15:04:29 <Pseudonym> If you have done something right, you're going to have to be punished.  You know that, don't you.
15:04:42 <Heffalump> well, your program doesn't compile :-)
15:05:02 <xerox> Thanks.
15:05:18 <Heffalump> you should look carefully at (lack of) the brackets in the expression it is complaining about
15:05:26 <Heffalump> s/(lack of) the/the (lack of)/
15:05:30 <jberg> Heffalump, yeah.. but how i mean whats wrong? is everything wrong? :) have i "thought" in the "right" way
15:05:43 <Pseudonym> It helps if you look at which line it's complaining about.
15:05:59 <Heffalump> I think your definition of palindrome is a bit overly complicated
15:06:08 <Heffalump> and in general you should try to avoid using !!, which is inefficient
15:06:17 <Pseudonym> Heffalump: Yes, but that's a discussion for another time.
15:06:32 <Pseudonym> Though a few comments.
15:06:39 <Pseudonym> foo | x == y = something
15:06:48 <Pseudonym>     | x /= y = something_else
15:06:56 <Pseudonym> The second case can be replaced by "otherwise".
15:06:59 <Pseudonym> Second comment:
15:06:59 <Heffalump> jberg: would you like a version that most people would consider better, tha tyou can compare with?
15:07:05 <Pseudonym> foo | x == y = something
15:07:12 <Pseudonym>     | otherwise = False
15:07:17 <Pseudonym> This can always be replaced by:
15:07:19 <Pseudonym> foo = x == y
15:07:25 <jberg> heffalump, yeah later.. right now i just want to know whats wrong with my version :)
15:07:29 <Heffalump> no, foo = (x==y) && something
15:07:36 <Pseudonym> Ah, yes.
15:07:37 <Pseudonym> Duh.
15:07:45 <Pseudonym> Sorry, insufficient caffeine.
15:07:48 <jberg> i see
15:07:55 <Pseudonym> That should help a bit.
15:07:58 <xerox> Goodnight folks
15:08:07 <Heffalump> jberg: you sort of hammer on the problem when something a bit more subtle would be better
15:08:14 <Pseudonym> But it doesn't fix the problem that it's complaining about.
15:08:28 <Heffalump> but in general the idea of recursively walking through the string is a good principle to follow
15:08:28 <Lemmih> Bye xerox.
15:08:37 <jberg> Heffalump, yeah but i just want to learn the basic of haskell.. if its efficient or not i can care about later :)
15:08:41 <xerox> thanks all.
15:08:56 <Heffalump> it's not just an efficiency thing, it's a style thing :-)
15:09:01 <Pseudonym> Heffalump has a point, though.  If you want to learn the basics of Haskell, steering clear of (!!) is a good idea.
15:09:06 <Pseudonym> Because it's not "basic".
15:09:11 <jberg> ok
15:09:36 <Pseudonym> Lists are lists, and treating them as arrays should be done with extreme caution.
15:09:47 <Heffalump> if you want to understand why (!!) is a bad idea, write out a definition of it for yourself and see how much work it's doing
15:09:49 <jberg> but can someone explain if i have a list [1..10] how can i get lists in the order [2..9] [3..8] etc?
15:10:08 <jberg> Heffalump, i tried.. until i noticed !! :)
15:10:11 <Heffalump> the way you do it is about as good as it can be done
15:10:32 <Heffalump> i.e. drop the first element by pattern matching and use take for the rest
15:10:37 <Heffalump> though I think you may have an off-by-one bug
15:10:45 <Heffalump> have you fixed your type error yet?
15:10:49 <jberg> nope
15:10:58 <Heffalump> did you think about what I said about brackets?
15:11:08 <jberg> well i tried just (take m xs)
15:11:14 <jberg> but that didn't work either
15:11:19 <Heffalump> that should fix tha tparticular error
15:11:21 <Heffalump> what's the new one?
15:11:23 <Cale> let f x = take (length x `div` 2) (iterate (init . tail) x)
15:11:31 <heatsink> join #python
15:11:34 <heatsink> oops
15:11:37 <zamez> heh
15:11:42 <Riastradh> Certainly not, heretic!!
15:11:43 <Heffalump> cale: ICK!
15:11:44 <zamez> traitor! etc :>
15:11:45 <jberg> Heffalump, Cannot justify constraint
15:11:45 <jberg> s in explicitly typed binding                               
15:11:58 <Heffalump> jberg: ok, and what's the rest of it say?
15:12:32 <Heffalump> one suggestion when you have a type error about "explicitly typed binding"s is to comment out the explicit type declaration and see what type your functoin gets
15:12:36 <jberg> Heffalump, http://www.rafb.net/paste/results/bDtdE822.html
15:12:58 <Heffalump> right, so what it's saying is that it thinks you need the constraint Eq a.
15:13:01 <Heffalump> Do you know about type classes?
15:13:06 <jberg> no
15:13:20 <Heffalump> ok, I think now is not the time to learn.
15:13:29 <jberg> me too :)
15:13:44 <Heffalump> make your type declaration be palindrome:: Eq a => [a] -> Bool
15:13:50 <Heffalump> and your problem will magically go away
15:14:09 <jberg> what does Eq a => [a] -> Bool mean? :)
15:14:22 <Pseudonym> (Eq a) is a context for the type [a] -> Bool
15:14:29 <Heffalump> (the quick summary is that you are now saying that palindrome only works for any type a which has an equality test, not just any type a at all)
15:14:48 <Pseudonym> Some types don't have equality tests.
15:14:50 <Pseudonym> Functions, for example.
15:15:23 <jberg> ah i see
15:15:25 <Heffalump> and Heffalumps, cos they're unique
15:15:55 <jberg> well it "compiled" fine.. but when i try to do palindrom "2002" it says !! index too large :)
15:16:06 <Pseudonym> i thought Heffalumps can't be compared because they're impure.
15:16:19 <WilX> :)
15:16:48 <Pseudonym> Can you paste your code again?
15:16:54 <Pseudonym> With the changes so far.
15:17:19 <Heffalump> Syntax!
15:17:24 <jberg> http://www.rafb.net/paste/results/eoWsV663.html
15:18:08 <Pseudonym> If you give a Heffalump an argument, there's no telling what it will return.
15:18:13 <Heffalump> are you using ghci or hugs?
15:18:17 <Pseudonym> You never can tell with Heffalumps.
15:18:24 <jberg> hugs
15:18:38 <Heffalump> Igloo will tell you that the results of giving a Heffalump an argument are highly predictable.
15:18:57 <Heffalump> Prelude> []!!(-1)
15:18:58 <Heffalump> Program error: Prelude.!!: index too large
15:18:59 <Heffalump> silly hugs
15:19:24 <Heffalump> jberg: try with a simpler example, such as "2", and see if you can figure out what the problem is
15:19:37 <Heffalump> given that the above call results in the given error message ;-)
15:19:46 <Igloo> :-)
15:20:01 <SyntaxNinja> hihi Heffalump
15:20:16 <jberg> Heffalump, same error
15:20:26 <SyntaxNinja> Heffalump: heh
15:20:41 * SyntaxNinja is improving the haddock output of ./setup haddock even as we speak
15:20:56 <Pseudonym> jberg: Try tracing through execution of the code on that example.
15:21:04 <Pseudonym> jberg: See if you can work out what it's doing.
15:21:20 <Pseudonym> And by "tracing", I mean manually.
15:21:26 <jberg> oh :)
15:21:58 <Heffalump> SyntaxNinja: ooh, nice
15:22:24 <SyntaxNinja> Heffalump, Igloo, shapr, and other debianers, I've just uploaded haskell-cabal_0.4-1
15:22:40 <Heffalump> (a general haddock question) is it possible to point it at a haddock tree generated from some other package so that the hyperlinks work?
15:22:46 <Heffalump> SyntaxNinja: nice.
15:24:01 <Oejet> Apropos arrays, is there some implementation notes on Data.Array.MArray?
15:27:39 <wli> I could probably wing a clean SMTP client library relatively quickly.
15:29:14 <wli> I'm not convinced I should; I think there's probably something out there.
15:32:25 <jberg> http://www.rafb.net/paste/results/FyxpLF10.html what does throw _FAIL mean?
15:33:49 <Pseudonym> It means there's a pattern match or guard combination failing somewhere, with no other alternatives.
15:33:49 * Heffalump looks confused
15:33:54 <Heffalump> ahh
15:34:04 <Heffalump> m | n == 1 = 1
15:34:07 <Pseudonym> Right.
15:34:07 <Heffalump> is your problem
15:34:25 <jberg> oh right
15:52:35 <jberg> yay fixed it. thanks for your help :D
15:57:15 <Heffalump> shall I show you the elegant fast(ish) version now? :-)
15:57:40 <jberg> yes please :)
15:57:50 <Heffalump> palindrome xs = xs == reverse xs
15:57:58 <jberg> ah yeah i knew about that :)
15:58:08 <jberg> but i want to learn how to think "functional"
15:58:16 <Heffalump> that is functional
15:58:38 <Pseudonym> Did you mean that you wanted to think "recursively"?
15:58:48 <jberg> hmm yeah maybe :)
15:58:54 <Heffalump> if you want a nice challenge, make a version that looks like the above, but doesn't test everything twice and doesn't involve the length function
15:59:12 <Heffalump> (or involve something like a manual simulation of the length function)
15:59:16 <jberg> Heffalump, like my version or yours?
15:59:21 <Heffalump> like mine
15:59:32 <Heffalump> you'll notice that mine does redundant tests on the second half of the string
15:59:34 <jberg> what do you mean doesnt test everything twice?
15:59:38 <jberg> ah yes
16:00:13 <Heffalump> the solution I'm thinking of involves a fairly cunning trick, so it's not particularly easy
16:00:17 <jberg> i don't know how i would do that without the length function
16:00:34 <jberg> i just started learning haskell today
16:01:56 <jberg> seems like a really cool language though :)
16:02:27 <jberg> but is it not possible to define variables in the hugs interpreter? like pi = 3.14 etc?
16:02:51 <Heffalump> jberg: not in the REPL, no
16:03:02 <jberg> REPL?
16:03:08 <Heffalump> (the Read-Eval-Print-Loop you get with the interactive prompt)
16:03:14 <Heffalump> if you use ghci instead you can do it
16:03:18 <Heffalump> let pi = 3.14
16:03:22 <jberg> oh i see
16:04:38 <Heffalump> what platform are you on?
16:04:42 <jberg> windows
16:04:50 <Heffalump> should be easy enough to get ghci then
16:04:57 <jberg> yep
16:05:12 <jberg> im just too tired of reading and writing now :X
16:05:24 <Heffalump> I'm just off to bed
16:05:46 <jberg> me too
16:12:13 <Lemmih> SyntaxNinja: Yo.
16:13:33 <Lemmih> SyntaxNinja: Building Cabal (from the darcs repo) with GHC 6.3 fails because System.FilePath doesn't export dropAbsolutePrefix.
16:16:53 <Heffalump> did that change from 6.2 or something?
16:18:37 <Lemmih> Heffalump: There was a System.FilePath in 6.2?
16:21:05 <Heffalump> oh, err, no idea.
16:21:14 <Heffalump> I was asking my question about why it broke in ignorance of the specific facts.
16:30:18 <SyntaxNinja> Lemmih: is there a 6.3 "release" or does that just mean that this is from CVS?
16:34:48 <SyntaxNinja> Lemmih: if the answer to my question is "it's from CVS" then the solution to your problem is "cvs up"
16:40:37 <Lemmih> SyntaxNinja: I just pulled the latest changes from http://cvs.haskell.org/darcs/cabal
16:41:17 <SyntaxNinja> Lemmih: I mean cvs up of your ghc source tree
16:41:29 <SyntaxNinja> the version of FilePath in GHC's CVS exports that function.
16:41:39 <Lemmih> Oh.
17:38:13 * wli dies waiting for a 64-bit GHC
17:45:58 <Riastradh> 6.4 ought to support 64-bit architectures.
17:46:15 <wli> comforting news
17:46:22 <Riastradh> No, that wasn't news.
17:46:26 <Riastradh> It was a joke.
17:46:26 <wli> I need > 4GB datasets
17:46:29 <wli> it's news to me
17:46:48 <Riastradh> Move the decimal point one digit to the right.
17:47:01 <wli> I've not been keeping up with what's going on to be honest, so I really just don't know.
17:47:13 <Riastradh> I know probably less than you do about GHC 6.4
17:47:14 <Riastradh> .
17:47:40 <wli> I think ghc already does alpha but my alphas suck.
18:28:09 <wli> ghc-6.2.1: out of memory (requested 1048576 bytes)
19:28:26 <wli> hmm
19:28:41 <wli> I wonder if this thing's looping.
19:42:17 <wli> I have an issue
19:42:30 <wli> I believe a program of mine is terminating abnormally due to a space leak.
19:42:45 <wli> However, heap profiling is useless because it terminates abnormally.
19:48:16 <DUKE> .pass
19:48:25 <DUKE> hola
19:48:45 <monochrom> qwertyuiop
19:49:05 <DUKE> hi
19:49:15 <DUKE> alguno que hable español
19:50:05 <kristnjov> what did he say?
19:51:45 <Nioate> anyone speak spanish? I think
19:52:17 <kristnjov> he forgot the question marks
19:52:27 <Nioate> true
19:53:02 <isomer> i don't even know how to say "no" in spanish, now that i think about it
19:53:10 <Nioate> at least he didn't use crazy abbreviations like k for que
19:53:10 <kristnjov> no = no i think
19:53:20 <Nioate> I've seen that before
19:53:26 <kristnjov> hehe
20:03:55 <kristnjov> i'm off to watch a few old south parks
23:04:09 <autrijus> hmm
23:04:16 <Gahhh> hmm?
23:04:26 <autrijus> why is it that in record update, I can't use a locally bound function as the key?
23:04:53 <autrijus> storeInc k v = do
23:04:53 <autrijus>     st <- State.get
23:04:53 <autrijus>     State.put $ st { _Inc = addToFM (_Inc st) k v }
23:05:08 <autrijus> I'd like to move _Inc as a argument
23:05:18 <autrijus> store f k v = do
23:05:18 <autrijus>     st <- State.get
23:05:18 <autrijus>     State.put $ st { f = addToFM (f st) k v }
23:05:32 <autrijus> however it does not work; ghc complains that "f" in "f =" is not in scope.
23:05:36 <autrijus> any ideas?
23:06:40 <autrijus> the context here is type CacheState a = StateT Cache IO a
23:06:46 <autrijus> and the struct is data Cache = Cache {
23:06:46 <autrijus>     _Info   :: !(FiniteMap String FontInfo),
23:06:46 <autrijus>     _Inc    :: !(FiniteMap String N2) }
23:07:04 <SyntaxNinja> because we don't have Higher Order Field Accessors!
23:07:11 <autrijus> oh. we don't.
23:07:24 <autrijus> does that mean -cpp for me? :-/
23:07:31 <SyntaxNinja> I mentioned this the other day and someone mentioned that someone wrote an email or a paper about it or something. but that's all the info I have :)
23:07:43 <Lunar^> SyntaxNinja: cheers for Cabal
23:07:44 <autrijus> okay. I was hoping I don't have to go the HList route.
23:08:22 <dblhelix> SyntaxNinja, autrijus: I did, i.e. I mentioned that Daan Leijen did wrote a paper on it
23:08:39 <dblhelix> /s/wrote/write
23:09:10 <SyntaxNinja> autrijus: if you want to be condemned for all eternity for using the worst haskell abomination ever, go ahead and use cpp.
23:09:25 <autrijus> "First-class labels for extensible rows." ?
23:09:36 <autrijus> heh.
23:09:37 <dblhelix> autrijus: yes
23:09:44 <autrijus> what is the common idiom to solve this, though?
23:09:52 <autrijus> don't use record and use a FiniteMap for Cache?
23:10:04 <autrijus> data CacheKeys = Info | Inc
23:10:53 <autrijus> type Cache = FiniteMap CacheKey (FiniteMap String ...)
23:10:57 <autrijus> doesn't quite work.
23:12:06 <autrijus> or, horrors, type Cache = (FiniteMap String FontInfo, FiniteMap String N2)
23:12:16 <autrijus> _Info = fst ; _Inc = snd
23:12:41 <SyntaxNinja> so which is the worst abomination: mixing tabs and spaces in one file, cpp in haskell code, or unsafePerformIO... discuss.
23:13:11 * autrijus mumbles something about Inline::Haskell to mix haskell code with perl code.
23:13:20 <autrijus> (with all perl functions designated as pure by default, no less)
23:14:10 <Gahhh> unsafePerformIO at least has legitimate uses I think
23:14:23 <Gahhh> you mean the abuse of it maybe
23:16:55 <kristnjov> what's an abominatino?
23:19:26 <SyntaxNinja> "anything hateful, wicked, or shamefully vile; an object or state that excites disgust and hatred; a hateful or shameful vice; pollution"
23:20:36 <Gahhh> lambdabot: @wordweb abomination
23:20:37 <lambdabot> Sorry, I don't know the command "wordweb", try "lambdabot: @listcommands
23:20:40 <Gahhh> gah
23:20:47 <Gahhh> something like that works
23:20:58 <Lunar^> autrijus: have you look at HaRe? (I'm not sure of the name, it was regex style pattern matching added to Haskell)
23:21:49 <autrijus> Lunar^: no. how would it help?
23:21:56 * autrijus looks
23:23:54 <Lunar^> autrijus: Perl is mostly regex, isn't it ?
23:24:56 <Gahhh> Lunar^, what does that statement mean ?
23:25:40 <Lunar^> that I never did Perl
23:25:53 <Gahhh> heh ok
23:29:20 <autrijus> Lunar^: perl is mostly CPAN.
23:29:39 <autrijus> # http://search.cpan.org/recent
23:33:05 <autrijus> although writing code in haskell is fun and easy, "not having to write code in the first place" beats it everytime :)
