00:08:25 <WilX> Huh.
00:08:36 <WilX> Isn't the newer edition always better?
00:08:55 <tintin> WilX: not sure in this cars. 
00:09:00 <tintin> *case
00:09:25 <tintin> The whole approach of the book in different 
00:09:30 <tintin> Bottom up in the first edition 
00:10:00 <tintin> and the Second one is more usage oriented ... so i am not sure which one is better
00:48:13 <WilX> Hm.
00:59:37 <Itkovian> Morning.
01:02:33 <shapr> jiihaa
01:17:25 <shapr> hiya fsc2
01:17:37 <shapr> How's st looie?
01:18:08 * shapr burbles cheerfully.
01:18:20 <shapr> @jargon "System F"
01:18:22 <lambdabot> No match for ""System F"".
01:18:25 <shapr> @jargon System F
01:18:27 <lambdabot> *** "system" jargon "Jargon File (4.3.0, 30 APR 2001)"
01:18:27 <lambdabot> system n. 1. The supervisor program or OS on a computer. 2. The entire
01:18:27 <lambdabot>    computer system, including input/output devices, the supervisor program
01:18:27 <lambdabot>    or OS, and possibly other software. 3. Any large-scale program. 4. Any
01:18:27 <lambdabot>    method or algorithm. 5. `System hacker': one who hacks the system (in
01:18:29 <lambdabot>    senses 1 and 2 only; for sense 3 one mentions the particular program
01:18:33 <lambdabot>    e.g., `LISP hacker')
01:18:35 <lambdabot> [3 @more lines]
01:18:36 <shapr> hmm
01:18:43 <shapr> @all-dicts "system f"
01:18:44 <lambdabot> *** "system f" foldoc "The Free On-line Dictionary of Computing (27 SEP
01:18:44 <lambdabot> 03)"
01:18:44 <lambdabot> System F
01:18:45 <lambdabot>      
01:18:47 <lambdabot>         A {type system} by J-Y. Girard.  Also known as Lambda-2 or the
01:18:48 <shapr> aha
01:18:49 <lambdabot>         {polymorphic lambda-calculus}.
01:18:51 <lambdabot>      
01:18:53 <lambdabot>         ["Proofs and Types", J-Y. Girard, Cambridge U Press 1989].
01:18:55 <lambdabot> [4 @more lines]
01:19:51 <shapr> jlouis: hiya, long time no see
01:20:35 --- topic: set to '["Learning Haskell - http://www.haskell.org/learning.html","See logs @ http://tunes.org/~nef/logs/haskell/","related channels #haskell.se #haskelldb #darcs","http://www.haskell.org/cabal/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004","We put the Funk in Funktion","The people here like donuts"]' by shapr
01:58:52 <boegel> hey #haskell
01:58:59 <boegel> shapr: how's Haskell Monthly ?
01:59:34 <Itkovian> hi boegel
02:03:11 <boegel> hey Itkovian 
02:05:06 <shapr> boegel: Oh, I found a better name. The Monad.Reader
02:05:42 <boegel> and is it coming ? or do you just have a name ? :)
02:05:51 <shapr> It's coming if I can find enough authors, like I said.
02:06:02 <boegel> and you still hanve't found enough...
02:06:07 <shapr> nope, not yet.
02:06:08 <boegel> what about you Itkovian :D
02:06:24 <shapr> But I'll make another call for authors when my server moves to its new location.
02:06:30 <shapr> Which will probably be in two weeks or so.
02:11:00 <Itkovian> eh?
02:11:09 <shapr> Want to write for the Monad.Reader ?
02:11:12 <Itkovian> authors for what?
02:11:16 <Itkovian> hmm ...
02:11:30 <Itkovian> Do you honestly think I'm up to that? I think not.
02:11:37 <shapr> Do you think I'm up to that? :-)
02:11:41 <Itkovian> Yes.
02:12:04 <shapr> Then why wouldn't you be up to that?
02:12:14 <Itkovian> Monads ... I still have to wrap most of my head around them ... despite having read a lot lately
02:12:52 <shapr> If you write an article about them, you'll have a good chance to wrap your head around them.
02:12:52 <Itkovian> Maybe (no pun intended) it would not be a bad excercise.
02:12:54 <boegel> Itkovian: they even offered me to write for it :)
02:13:41 <Itkovian> as on http://www.cse.ogi.edu/~diatchki/monadLib/docs/Monad.Reader.html ?
02:14:00 <shapr> If you're interested in Haskell and you want to write about it, then I want to 'publish' it.
02:14:20 <shapr> There's a standard module named Monad.Reader
02:14:38 <boegel> Itkovian: it's not just on Monad's...
02:14:41 <shapr> In the USA in the past there have been a lot of magazines called "The Something Reader"
02:14:59 <shapr> So I thought it would be a neat name for a Haskell monthly wikizine, The Monad.Reader
02:15:06 <Itkovian> Ah, i grok it
02:15:14 <shapr> Also, månad means month in swedish, and monad is month in german, I think
02:15:21 <shapr> so it's a pun on "The Monthly Reader"
02:15:25 <Itkovian> Yes. I think
02:15:28 <Itkovian> .
02:15:35 <shapr> What's dutch for month?
02:15:39 <Itkovian> maand
02:15:57 <shapr> That's a bit farther away.
02:16:32 <boegel> shapr: doesn't publishing stuff like that cost a lot of money ?
02:16:45 <shapr> I'm planning on 'publishing' on a wiki!
02:17:15 <shapr> It's the kind of thing where only the authors will be able to modify the pages, but anyone will be able to read it.
02:17:15 <dons> hm, is 'monad' really 'month' in german? what was leibniz on about then?
02:17:20 <Itkovian> lol, that's nice.
02:17:29 <shapr> dons: I dunno
02:17:38 <boegel> shapr: oh :)
02:17:45 <shapr> salut ned 
02:18:14 <shapr> dons: Anyway, you know that Wolfram's "A New Kind of Science" is just Leibniz plagiarized?
02:18:36 <shapr> The cellular automata view of the universe is the same as Leibniz' monads as far as I can tell.
02:18:55 <dons> yep. sounds about right
02:19:32 <shapr> dons: want to write for The Monad.Reader in your mounds of spare time? ;-)
02:19:58 <swiert> shapr: do you have any timeline as to when submissions would be due?
02:20:15 <dons> i'm tempted, yes. i'm off to a south pacific island for a week, but i'll see what I can do when I get back.
02:20:20 <shapr> wow, nifty!
02:20:52 <dons> custom ghc hacks, might be one thing I'd write about
02:20:54 <boegel> shapr: more reaction than last time ;)
02:20:59 <swiert> I have a half-baked paper introducing attribute grammars and when/how they beat monads (imho)
02:21:45 <shapr> swiert: Once I have enough authors, I'll set a date for the first issue. Then I'd like to have a four week schedule of at most one week to decide a topic for a column/article/whatever, and then have the article submitted a week before 'publication'
02:22:28 <shapr> Of course, I've dealt with these sorts of projects enough to know that any schedule at all is tissue paper in a hurricane.
02:22:31 <swiert> ok - sounds good. I'd be willing to write something provided its due after Feb.
02:22:44 <shapr> That would be a very cool article.
02:22:54 <shapr> dons: which island? whatcha doin there? sounds cool!
02:23:09 <shapr> I'd like to know more about AGs myself, I still haven't gotten around to learning them.
02:23:53 <swiert> shapr: I admit that introductions to AGs are scarce. I think that's one of the reasons their not widespread.
02:24:28 <swiert> Currently, ags are taught in Utrecht by handing out the UUAG manual.
02:24:47 <swiert> as a result their not immediately appreciated.
02:31:05 <Itkovian> swiert: any recommended online docs about them?
02:31:13 <Itkovian> (yes, I'm lazy)
02:31:23 <Itkovian> (or rather, short on time)
02:31:27 <boegel> Itkovian: isn't everyone ?
02:31:35 <Itkovian> out here, maybe, yes.
02:32:30 <swiert> Itkovian: http://catamaran.labs.cs.uu.nl/twiki/st/bin/view/Center/AttributeGrammarSystem
02:32:56 <swiert> that's the uuag homepage - you should be able to find the manual and some slides there.
02:34:03 <swiert> the lecture notes on language implemention are also online: http://catamaran.labs.cs.uu.nl/twiki/st/pub/Ipt/CourseLiterature/ipt-20041103-dikt.pdf
02:34:29 <swiert> it has a short chapter on ags, but nothing too informative.
02:34:54 * boegel is out, doing some usefull stuff :)
02:35:16 <swiert> shapr: why publish on a wiki though?
02:35:56 <swiert> It shouldn't be too difficult to steal some standard LaTeX template and generate .pdf
02:44:52 <dons> shapr: new caledonia, holiday from hacking. just have to practice my french :)
02:45:48 <dons> have people seen www.scroogle.org - the google ad scraper. it's kinda fun
02:48:37 <shapr> c'est chouette, apprendre mieux français
02:49:02 <Itkovian> hmm
02:49:24 <shapr> swiert: because with a wiki I can always and immediately see the status, fix any mistakes, don't have to worry about version control, and I can still do LaTeX with something like WiXiTeX
02:49:29 <shapr> er wikiTeX?
02:49:48 <Itkovian> peut-etre ... mais j'aime bien l'anglais, donc pas de francais for moi
02:50:03 <Itkovian> or 'du francais', I've no clue after 10 years of non-use
02:54:05 <swiert> shapr: but are wikiTexed wikis as easy to print, read, and save as a pdf?
02:54:58 <shapr> I don't know, but I do think a wiki is much easier to edit and view.
02:55:06 <swiert> somehow I think people take a pdf a bit more seriously, but maybe this is just personal intuition.
02:55:32 <tintin> djvu is a better format than pdf ...
02:55:49 <swiert> yes - perhaps you could publish a wiki and provide a bundled pdf for offline reading.
02:55:53 <tintin> more support should be geared towards djvu ..
03:02:01 <shapr> swiert: I think that newbies and other interested people will take a wikizine seriously if it has good content. I do agree that the academic side of the Haskell world is more likely to take a PDF seriously.
03:02:36 <tintin> or a djvu :)
03:03:25 <swiert> shapr: too true. So let's try and gaurantee good content!
03:03:34 <shapr> yes!
03:09:30 <tintin> shapr: isn't there a wiki already ?
03:09:54 <shapr> The haskell wiki you mean? Yes. But a monthly magazine doesn't exist yet.
03:09:56 <tintin> oh you are talking about a ezine sorry didn't notic that 
03:10:05 <tintin> sorry about that
03:10:32 <shapr> Want to write an article or column for said wikizine? :-)
03:10:33 <tintin> Good luck with it shapr 
03:10:55 <tintin> shapr: i am such a noob i would bring you people down :(
03:11:12 <tintin> maybe i will write a noobs guide to get confused with haskell :)
03:11:17 <shapr> good idea!
03:11:26 <shapr> If you write something with nice content, it'll help!
03:12:21 <tintin> shapr: will do but i think you as an editor will pull your hair out :)
03:12:32 <shapr> maybe, but maybe not :-)
03:12:57 <tintin> oh you must be bald then :)
03:13:21 <shapr> http://www.scannedinavian.org/~shae/foto/need_haircut.jpg
03:13:26 <shapr> I just have a lot to pull...
03:13:50 <Itkovian> nah, yr hair looks fine shapr ...
03:33:12 <jlouis> oy shapr 
03:33:31 <shapr> Don't like my lack of haircut? ;-)
03:34:23 <tintin> your hair looks fine ... you just need a haircut 
03:34:25 <tintin> :)
03:34:39 <shapr> Yes, I agree. No haircut in five years.
03:34:45 <shapr> It's about time to change that.
03:35:18 <tintin> your gf dosn't like your hair by any chance ?
03:36:15 <shapr> She does, but she thinks I need a haircut.
03:37:05 <shapr> Even when I have my hair in a ponytail, the wind blows it into my face. That's too long.
03:39:04 <Itkovian> ouch ... yr may be in trouble ... gf's thinking you need a haircut is a bad sign :-)
03:39:16 <Itkovian> prepare to visit the barber every month or so ;-)
03:46:26 <tintin> shapr: trouble ahead ... go see your nearst barber :)
03:46:33 <shapr> :-)
03:46:40 <tintin> now its your hair tomorrow it could be you 
03:47:12 <shapr> <snip> !
03:49:34 <Itkovian> shapr: that your rabbit?
03:49:37 <Itkovian> kanin?
04:41:32 <Igloo> shapr: Why is a wiki better than a PDF if each article will have one author? Or is that not what you envisage?
04:42:32 <boegel> Igloo: because the author can adapt the article easily (errors, more information, ...)
04:42:54 <shapr> I like the idea of editing in the same place as publishing, I can easily do RSS on a wiki, I already know how to embed LaTeX, syntax highlighting, etc
04:43:05 <boegel> but I agree distributing a PDF wouldn't be a bad thing... I still think reading on paper is much easier than reading on screen
04:43:27 <shapr> I can also fix any errors in grammar and spelling as soon as I see them.
04:44:21 <shapr> And anyone can view a wiki on any terminal. *Everything* has a web browser, even those airport terminal that cost a dollar a minute.
04:44:29 <shapr> hiya timbod 
04:44:52 <timbod> hi shapr
04:45:11 <tuomov> it's virtually impossible to read anything that requires serious thinking on screen
04:45:15 <tuomov> or anything long
04:46:14 <timbod> perhaps it's a sign of my age, but any vaguely serious pao
04:46:23 <tuomov> not that I have access to a printer
04:46:31 <timbod> (papers) that I need to read have to be on paper
04:46:37 <shapr> how old are you?
04:46:58 <timbod> not old really (36)
04:47:01 <shapr> I'm 33, and I've decided that I can't afford to purchase $100+ books on a regular basis.
04:48:36 <timbod> how many books do you need to buy? Most of the interesting technical stuff is downloadably in pdf/ps form anyway. (or perhaps you are talking about some area other than PLs)
04:48:39 <boegel> shapr: but then again, not all books are available online, or are they ?
04:49:09 <shapr> Well, research papers are available online. 
04:49:27 <boegel> shapr: but research papers don't cost $100 :)
04:49:38 <timbod> that's what I meant - though I did but CTM a few months ago.
04:49:40 <tuomov> an e-ink pad thingy would be cool
04:49:55 <shapr> Thing is, I can't annotate a paper copy of a document and share the annotations online.
04:50:01 <shapr> I'd have to type them in again.
04:50:18 <Itkovian> there you have a point...
04:50:20 <tuomov> a book would probably still be much nicer to read (physical pages are a good ui except for searching)
04:50:33 <tuomov> but such a pad might be sufficient for reading papers and stuff
04:50:44 <shapr> I do wish for a full A4 size screen on a laptop that I could fold over like a notebook.
04:50:50 <Itkovian> I am wondering ... if the wiki's content is marked up decently, can't one parse the stuff, convert it to plain ol' latex and put out a pdf?
04:51:00 <boegel> those e-ink paper thingies can be a real revolution...
04:51:36 <shapr> Yes, I think the wiki output can be PDF without too much trouble, but the question was more why is a wiki better than PDF.
04:51:45 <Itkovian> I know ...
04:51:46 <timbod> tuomov, true, provided that the quality is as good or almost as good as a laser printer. Has anyone seen what e-ink looks like in real life?
04:52:05 <Itkovian> but if you can generate the pdf at some point, or have people generate it, then I think the question is answered ...
04:52:24 <tuomov> I haven't seen, but at least it shouldn't be flickery (crts) and highly luminous (crts+tfts)
04:52:26 <shapr> The MIT e-ink is better than 600dpi
04:52:54 <Itkovian> and how much does it cost?
04:53:01 <shapr> they use liquid filled spheres, inside the liquid there's another sphere that's half-black and half-white
04:53:08 <tuomov> e-ink is slow, but it doesn't matter in this application
04:53:36 <shapr> I haven't heard of any commercial e-ink products, so I'd guess it's very expensive.
04:53:58 <tuomov> wasn't there some sony (?) thing..
04:54:09 * shapr dunno
04:54:18 <tuomov> but it was bulky and small screened
04:54:25 <tuomov> http://news.com.com/2100-1041-5178854.html
04:54:43 <tuomov> only supported some properietary memory sticks or whatever and so on
04:54:57 <shapr> suck
04:55:03 <shapr> I just want a display.
04:55:39 <boegel> yeah, just 1 sheet op papers, and a 'trick' to browse through the pages
04:57:18 <shapr> like a clear touchscreen layer on top of the e-ink sheet and a browser interface
04:58:41 <tuomov> a few buttons on the side for some common actions (next page, previous page, a few bookmarks, a button to bring-up on screen menu)
04:58:41 <shapr> Another thing, a wiki will let me embed the original article in another page that allows comments.
04:58:41 <boegel> I think these things will start be become quite commercial in a few years
04:58:50 <boegel> I see a time when there's no plain paper anymore
04:58:53 <shapr> me too
04:58:58 <shapr> plain paper is *expensive*
04:59:13 <tuomov> boegel: but how drm encumbered and limited?
04:59:25 <boegel> drm ?
04:59:35 <tuomov> digital restrictions management
04:59:37 <shapr> I read something like 80 books in november and december from baen.com/library . I'd read that much all the time if I could afford the books.
04:59:50 <shapr> tuomov: heh, it's usually digital rights management, but I like yours better.
05:00:13 <tuomov> yeah, that's the official version
05:00:29 <shapr> I think drm sucks mightily.
05:01:05 <timbod> I'm writing a mini-language in which I need to be able to express 2D array literals in expressions. haskell style nested list syntax [[v1,v2],[v3,v4]] seems a bit verbose for 2D. Any more concise alternatives from other languages?
05:01:52 <boegel> tuomov: I don't know what drm means :)
05:02:09 <shapr> drm == digital restrictions management
05:02:30 <timbod> I think it's actually "digital rights management"
05:02:44 <shapr> That's what the proponents call it...
05:03:03 <timbod> got you :-)
05:03:06 <shapr> I've decided to use the more correct expansion, "digital restrictions management"
05:03:17 <boegel> shapr: yeah ok, but how does that relate to the disappearing of plain paper ?
05:03:43 <tuomov> boegel: the devices only supporting texts in some proprietary format with heavy drm
05:03:50 <shapr> There's a bunch of laws in the US that are trying to get copy-restriction checking into every piece of hardware capable of reproducing media
05:04:07 <shapr> Those laws are also trying to spread to the EU
05:04:29 <shapr> look at the region encoding as an example. There's no law that says regions have to be in place, it's just there so that we can't share DVDs around the world.
05:04:31 <tuomov> without much luck so far..
05:04:59 <tuomov> the eu directive still hasn't passed as a law in finland
05:05:16 <tuomov> and I suppose many other countries as well
05:05:58 <boegel> shapr: I believe you can get around the region code on DVD's easily... 
05:06:03 <shapr> The moral of this story is that big media companies want DRM in everything. E-ink the company is partially owned by philips. Philips wants software patents in the EU.
05:06:16 <shapr> boegel: yes, but we still buy DVD that have region encoding. Why is that?
05:06:45 <tuomov> EUCD makes it illegal to sell region-free players or crack them
05:06:56 <shapr> What about the new Blu-Ray format? It has better copy protection than the competing formats and because of that the game companies are pushing for it.
05:07:16 <tuomov> in the latest proposal for the finnish law corresponding to it region code circumvention is stated as a special case that is legal
05:07:33 <tuomov> but I think it is still illegal to distribute information howto crack the players
05:07:40 <boegel> shapr: I have no idea :)
05:08:07 <shapr> I don't buy music CDs with copy protection, I won't pay for Sony to disallow me to read a CD on my computer.
05:08:36 <shapr> Actually, I don't buy CDs from any of the big companies who are pushing stronger anti-consumer laws in the US.
05:09:05 <boegel> shapr: I don't buy any cd's :)
05:09:08 <shapr> smart
05:09:19 <boegel> unless I really want them, and that doesn't happen too often
05:09:20 <Itkovian> I buy'em
05:09:29 <Itkovian> but not as much as I used to.
05:09:32 <shapr> There's a lot of gratis and legal music available online. Check out legaltorrents.com for example.
05:09:40 <tuomov> I haven't bought any in a long time
05:09:41 <boegel> I listen to the radio all the time, and when I'm on the road, I have an iPod with music I ripped off the cd's I did buy
05:09:58 <tuomov> and I have never bought a dvd. I don't even have dvd player or drive
05:10:00 * Itkovian drools .... Ipod ...
05:10:13 <Itkovian> heh, I have a dvd player.
05:10:18 <shapr> There's even a lot of libre and gratis quality music online, check out bradsucks.net for example.
05:11:15 <shapr> Personally I'd prefer a society where we follow all the laws, and get rid of the stupid laws when we notice them.
05:11:36 <Itkovian> I could live with that
05:12:17 <boegel> shapr: I understand the people who produce the music.. they're used to have HUGE profits, and now they see those fading away
05:12:27 <boegel> I wouldn't be happy with that either
05:12:37 <shapr> Hey, I was used to living at home for free.
05:12:38 <tuomov> no, they're not used to huge _profits, they're used to huge _growth_
05:12:53 <timbod> shapr - you could say that we already have that, it's just that agreement on what is stupid is hard
05:13:38 <shapr> timbod: I read somewhere that more than 50% of US Citizens have downloaded music via one of the P2P services. Last time more than 50% of the population did something that was illegal was the Prohibition.
05:14:12 <boegel> shapr: Prohibition ? 
05:14:16 * boegel feels stupid again
05:14:28 <Itkovian> I doubt > 50% of US citizens have an internet connection
05:14:30 <shapr> Drinking any alcohol was illegal in the USA in the early 1900s
05:14:46 <Itkovian> boegel: see Al Capone ...
05:15:04 <boegel> oh, that situation :)
05:15:09 <boegel> "drooglegging" :)
05:15:16 <shapr> bootlegging
05:15:21 <shapr> What's droog?
05:15:36 <timbod> shapr: I agree that IP laws are becoming a tool for the 
05:15:54 <boegel> shapr: dry
05:16:00 <shapr> ah
05:16:12 <boegel> leggen = to lay
05:16:14 <timbod> big corps, rather than the actual IP producers.
05:16:18 <shapr> There are still 'dry' counties in Alabama.
05:16:18 <boegel> so drooglegging = to lay dry
05:16:24 <boegel> or something like that
05:16:57 <timbod> (sorry - laptop has dump return key position)
05:16:58 <shapr> timbod: and, whenever a system is more interested in continuing itself rather than functioning usefully for its 'sources' it's broken
05:17:19 <boegel> Itkovian: is there such a big digital gap between citizens in the US ?
05:18:59 <shapr> there's a big gap between the sellers of music and the producers of music.
05:19:02 <Itkovian> boegel: I think over half cannot afford a computer, no?
05:19:23 <shapr> I think more than 50% has a computer in the US, but I could be wrong.
05:19:27 <Itkovian> ok.
05:19:30 <Itkovian> my mistake.
05:19:31 <shapr> I would be surprised if it's less than 75%
05:19:33 <boegel> Itkovian: hmm, that could be right
05:19:36 <shapr> well, I don't know for sure..
05:19:38 * shapr asks google
05:19:46 <boegel> but maybe they just use really old computers
05:19:48 <boegel> 2nd hand
05:19:58 <shapr> yeah, still enough to pirate music
05:20:11 <shapr> even a 386 can pirate music!
05:20:21 <shapr> can't play it ;-)
05:20:22 <timbod> shapr: "the system" is definitely in need of some repair. My previous comment to you was merely trying to point out that getting even sensible people to agree can be hard
05:20:47 <shapr> true
05:20:52 <Itkovian> I've got a number of lines of the format : VM_Threads -> 10 -- 5
05:20:57 <tuomov> because they've been told by the system all their lives that property is an inalienable "right" etc.
05:20:59 <Itkovian> then VM_Threads -> 5 -- 4
05:21:03 <Itkovian> and so on ...
05:21:35 <Itkovian> I'm looking for a neat way to check if the first thread number of the 'next' line is the same as the last of the 'former' line.
05:21:35 <shapr> what does it do?
05:22:05 <shapr> With what? shellscript? Haskell?
05:22:09 <Itkovian> Normally i'd typ in a perl oneliner, but I'm anxious to get my haskell one-liners going so ...
05:22:13 <shapr> ah!
05:22:14 <Itkovian> help wanted :-)
05:22:26 <Itkovian> I'd thought of using lines and then map words
05:22:38 <Itkovian> then filter out the numbers using !!
05:22:57 <Itkovian> which would essentially give me a [(Int, Int)] list.
05:23:00 <boegel> Itkovian: isn't !! really slow ?
05:23:11 <Itkovian> I could use head and last ...
05:23:20 <Itkovian> I'm open for suggestions
05:23:30 <Itkovian> the list is only 5 long, eh.
05:23:39 <Itkovian> speed doesn't matter ...
05:23:43 <Itkovian> yet
05:24:06 <Itkovian> there has to be a really cool way to let haskell do this on the ghc -e command line
05:24:29 <Itkovian> maybe I need to check the std libs ...
05:26:37 <boegel> Itkovian: I think a lot depends on the way you'll 'read in' the lines...
05:28:50 <Itkovian> getContents?
05:28:58 <boegel> @type getContents
05:29:03 <lambdabot> getContents :: IO String
05:29:29 <boegel> that gives you 1 long string, doesn't seem quite handy
05:29:34 <boegel> @index readLines
05:29:36 <lambdabot> bzzt
05:29:46 <boegel> hmm, isn't there something like that ?
05:29:54 <Oeje1> How was the emacs option for making tab always insert spaces?
05:29:57 <boegel> having a [IO String] would help
05:31:12 <Oeje1> How about getContents >>= lines?
05:31:23 <boegel> arrows ?
05:31:33 <Oeje1> @type getContents >>= lines
05:31:34 <lambdabot> bzzt
05:31:45 <Oeje1> @type lines
05:31:46 <lambdabot> lines :: String -> [String]
05:32:34 <Oeje1> boegel: No, monad composition.  The same as do{ cs <- getContents; return (lines cs) }
05:34:23 <boegel> oh okay :)
05:34:32 <boegel> I'm out, taking a bath :)
05:34:33 <boegel> bye
05:37:24 <Itkovian> well, I followed wli's example you can find in thursday or friday's logs
05:40:15 <timbod> bye
06:23:56 <shapr> whoa, I just found the most whacked out darcs error in my logs
06:25:09 <shapr> someone is trying to pull from a darcs repo, and the error message response is being printed one character per line
06:26:52 <shapr> for each file that failed.
06:27:02 <basti_> hmm ive seen that
06:27:08 <xerox> yo
06:27:11 <shapr> y0
06:27:26 <basti_> i remember vaguely it has something to do with unicode output of python or something
06:27:44 <shapr> really?
06:28:01 <basti_> im not 100% sure
06:28:19 <shapr> I do have a python unicode problem already so that seems likely, but I want to hear more.
06:28:41 <basti_> i remember seeing that sort of wacko error and tried to reconstruct
06:37:02 <shapr> ah, this seems to be msnbot
06:37:08 <shapr> That bot eats half my bandwidth!
06:40:13 <basti_> thats bad.
06:41:13 <Itkovian> shoot it
06:41:36 <shapr> I did
06:41:48 <shapr> I just denied it acces to my server.
06:44:12 <Itkovian> way to go!
06:50:55 <Itkovian> is there a function like fst but for triples?
06:55:06 <basti_> \(x,y,z)->x maybe.
07:00:30 <Itkovian> sure
07:00:34 <Itkovian> but a named one
07:01:42 <Itkovian> ok, how about this for parsing my lines ... (see higher)
07:01:44 <Itkovian> cat | ghc -e 'do { cs <- getContents; putStrLn $ show $ filter ((==True) . \(x,y,z)->x) $ (\(x,y) -> zip3 (zipWith (==) (tail x) y) (tail x) y ) $ unzip $ (map (\(a:b:c:d:e:[]) -> (c,e))) $ (map words) . lines $ cs;}'
07:02:02 <Itkovian> actually, I'm more interested in ==False, but it amounts to the same
07:03:16 <Itkovian> I'd love asimpler way
07:05:19 <shapr> I'd probably cut it off at the column offset, delete the " -- " between the number, and then work with them directly.
07:05:26 <Itkovian> yeah :-)
07:05:40 <Itkovian> that's a good idea.
07:05:41 <Itkovian> lol
07:05:55 <Itkovian> I'm so focussed on haskell that I seem to forget the obvious stuff.
07:06:11 <shapr> Well, as long as you're having fun :-)
07:07:10 <Itkovian> I am!
07:10:21 <boegel> aaaaaaah, a 1.5 hour bad feels SO good :)
07:10:29 <boegel> s/bad/bath
07:12:39 <Itkovian> eh? you prolly look like a raisin now ...
07:12:59 <Itkovian> if that's what it's called in English ...
07:14:14 <boegel> Itkovian: naah :p
07:14:34 <boegel> I started watching Futurama when in the tub, and I couldn't stop :)
07:14:37 <boegel> it's addictive
07:15:35 <Itkovian> how can I process a list two items at a time?
07:16:47 <boegel> x1:x2:xs ?
07:16:58 <boegel> I'm not sure what you mean :
07:16:59 <boegel> :)
07:17:07 <Itkovian> yeah, but I want it done as in a fold ...
07:17:18 <shapr> Itkovian: what about creating a list of lists, and putting the last item of the one line and the first item of the next line into the sublist?
07:17:43 <Itkovian> sure ...
07:18:00 <Itkovian> but how do I get the last item on line 2 and the first on line 2?
07:18:02 <shapr> it's a raisin, yes.
07:18:11 <shapr> huh?
07:18:13 <boegel> you mean line 3 ? :)
07:18:22 <Itkovian> recall, I want to do this on the command line, i.e. no script files
07:18:25 <shapr> right
07:18:26 <Itkovian> no I meant line 1 :-)
07:18:50 <boegel> last on line 2, first on line 3 ;)
07:19:02 <Itkovian> boegel: I've got a list, say [4,4,10,10,5,5,6,6]
07:19:16 <shapr> If you snip them into a list of number by cutting off everything else but the numbers, you'll be able to drop the first one and compare all the rest in pairs.
07:19:24 <Itkovian> and I want to make certain that every 'pair' (not exactly) of subsequent elemtns is the same
07:19:37 <Itkovian> thus 4 == 4, 10 == 10, 5==5, and 6 == 6
07:20:14 <boegel> hmm... that seems quite easy in a small program, but on the command line...
07:20:25 <Itkovian> idd
07:20:51 <boegel> and my haskell is a bit rusty at the moment :s
07:20:52 <Itkovian> It can't be _that_ hard ...
07:20:58 <boegel> no, it can't
07:21:03 <boegel> *starting hugs
07:21:14 <Itkovian> it seems like a nice fp program
07:22:15 <basti_> boegel: i would match 2 heads off the list
07:22:38 <boegel> basti_: so would I
07:22:53 <basti_> its not hard at all.
07:25:10 <boegel> Itkovian: why do you want it on the command line?
07:27:28 <Itkovian> because it is cool
07:27:32 <boegel> :D
07:28:48 <Itkovian> and it increases my leetness here :-)
07:28:49 <Itkovian> lol
07:28:54 <boegel> heh
07:29:08 <boegel> oh, _that's_ why :p
07:30:44 <boegel> @type filter
07:30:45 <lambdabot> filter :: forall a. (a -> Bool) -> [a] -> [a]
07:33:41 <boegel> Itkovian: do you build that list yourself ?
07:34:22 <boegel> can't you make like this: [(x,y)]
07:46:01 <Itkovian> with x and y what? the item of the first line and the item of the next line?
07:47:05 <boegel> Itkovian: yes
07:47:25 <boegel> that would make things a lot easier I think :)
07:51:36 <shapr> How do you say trout in Dutch?
07:52:31 <Muad_Dibber> forel?
07:52:42 <shapr> ah, nifty.
07:52:48 <Muad_Dibber> :)
07:52:57 <shapr> Swedish has two l, it's forell
07:53:10 <Muad_Dibber> well, thats just a waste of ink :P
07:53:27 <shapr> I won't even start on that discussion :-)
07:53:36 <Muad_Dibber> hehe :)
07:57:16 <Itkovian> I'm off.
07:57:19 <Itkovian> ttyl
07:57:40 <Muad_Dibber> ciao
08:04:42 <Cale> Itkovian: how should it take the input list?
08:08:04 <Cale> ghc -e 'getLine >>= (print . and . Data.List.unfoldr (\ xs -> case xs of { (x:y:xs2) -> Just (x == y, xs2); [x] -> Just (False, []); [] -> Nothing }) . read)'
08:08:42 <Cale> there you o
08:08:43 <Cale> go*
08:08:58 <Cale> it even checks that the list is of even length, returning False if it is odd
08:09:29 <Cale> Now I must return to my measure theory assignment.
08:09:44 <Cale> (and noncommutative algebra too)
08:11:03 <Cale> ghc -e 'readLn >>= (print . and . Data.List.unfoldr (\ xs -> case xs of { (x:y:xs2) -> Just (x == y, xs2); [x] -> Just (False, []); [] -> Nothing }))'
08:11:08 <Cale> slightly shortened
08:14:02 <Cale> Itkovian: feedback? :)
08:14:30 <desrt> ghc -e ?!?
08:14:35 <desrt> sexy :)
08:18:57 <WilX> @_@
08:18:57 <lambdabot> Sorry, I don't know the command "_@", try "lambdabot: @listcommands"
08:19:03 <WilX> TH is...too complicated.
08:20:14 <Cale> Well, you use it for doing complicated things. Like Hacanon, which translates C/C++ header files into appropriate Haskell FFI imports at compile time.
08:20:59 <Cale> (and takes care of object marshalling, etc.)
08:21:20 <WilX> I guess so :)
08:21:36 <Philippa> is there a Hacanon release yet?
08:22:05 <Cale> I'm not sure. I was taking a look through the code, and it's interesting.
08:22:33 <Cale> I'm sure if you check the #haskell logs the link has been posted.
08:22:57 <Philippa> Google is my friend, as ever
08:25:23 <shapr> Oh, this is nice - http://www.paulgraham.com/hs.html
08:25:45 <shapr> I think it's the same lesson I got out of "A Beautiful Mind"
08:27:07 <shapr> Basically, life doesn't ever get any easier, you just get better at dealing with it.
08:27:26 <shapr> WilX: what's complicated about TH?
08:29:10 <WilX> Well...
08:29:15 <WilX> Not enough docs maybe?
08:32:14 <shapr> already tried http://www.haskell.org/hawiki/TemplateHaskellTutorial ?
08:32:29 <WilX> Nope, missed that one.
08:32:33 <shapr> It's incomplete, and I suspect I wrote it.
08:32:38 <WilX> Hehe.
08:32:41 <shapr> Not that I remember writing it.
08:32:49 <shapr> But the vocabulary and style appears to be mine.
08:33:21 <shapr> spammers really piss me off. Especially wiki spammers.
08:33:27 <shapr> I wish I could find some permanent solution for them.
08:33:39 <shapr> emasculation possibly.
08:34:44 <Philippa> cut off their pipe?
08:34:59 <shapr> Philippa: yes, exactly :-)
08:35:06 <CosmicRay> good morning shapr
08:35:07 <shapr> greetings Agent Ray
08:36:21 <Philippa> anyway, 'mheading out, ttyl
08:36:45 <shapr> cya!
09:26:02 <CosmicRay> ahh a, I see igloo was foolish enough to log on to irc today :-)
09:28:27 <CosmicRay> Igloo: I've made zero progress tracking down the arm issues, so if you have a sec to talk to me about it, that'd be gerat
09:33:32 <Igloo> I have a C file that shows the problem
09:33:52 <CosmicRay> is it a problem with gcc then?
09:34:58 <Igloo> http://urchin.earth.li/~ian/arm.txt  (i386 are, I assume, the IEEE answers in LE and BE)
09:35:22 <magical1> erm hello
09:35:26 <Igloo> s/i386/i386 and sparc/
09:35:31 <Igloo> hi
09:35:38 <CosmicRay> hello magical1 
09:35:43 <magical1> I need some advice
09:35:51 <magical1> hi Igloo , CosmicRay 
09:35:54 <CosmicRay> Igloo: hmm, what am I looking at here (it looks different between i386 and sparc)
09:36:21 <Igloo> CosmicRay: i386 == reverse sparc  (modulo some zeroes because I picked random numbers of bytes to look at)
09:36:35 <Igloo> See the f.c URL for what it does
09:36:49 <CosmicRay> oh you're dumping the bytes of the float...
09:36:50 <CosmicRay> 404
09:37:11 <Igloo> 404?
09:37:11 <magical1> I won't lie to anyone I am a college student and I am not looking for someone to do my assignment for me, I am just looking for a pointer in the right direction .......
09:37:13 <CosmicRay> magical1: go ahead with your question
09:37:22 <CosmicRay> Igloo: file not found with http://urchin.earth.li/~ian/f.c
09:37:39 <Igloo> Right, the URL in arm.txt  :-)
09:37:43 <CosmicRay> magical1: thanks, we can try to point
09:37:47 <Igloo> But yeah, dumping the bytes of a float and double
09:37:54 <CosmicRay> Igloo: oh foo, I'm an idiot
09:38:22 <Igloo> It can be fixed either by waiting (I was told - not sure if sarge will have it fixed) or by fixing the float code in GHC
09:38:26 <magical1> I need to design Tic Tac Toe using a functional programming language of my choice and I have chosen Haskell, where should I start looking for info? 
09:38:43 <CosmicRay> magical1: www.haskell.org is a good starting point
09:38:47 <Igloo> It was decode_float in a C file or something IIRC that looked the obvious suspect
09:38:50 <CosmicRay> (shapr, you could do your tutorial)
09:38:58 <magical1> okay will have a look, thanks
09:39:01 <CosmicRay> magical1: There is also Yet Another Haskell Tutorial, http://www.isi.edu/%7Ehdaume/htut/
09:39:12 <CosmicRay> magical1: there are some reports that it's down, I can e-mail you a copy if so
09:39:21 <magical1> yes please
09:39:21 <CosmicRay> magical1: there is also the Haskell wiki
09:39:22 <CosmicRay> @wiki
09:39:22 <lambdabot> http://www.haskell.org/hawiki/
09:39:28 <CosmicRay> magical1: what's your address
09:39:50 <magical1> CosmicRay: themagical1@gmail.com
09:40:04 <CosmicRay> sent
09:40:07 <magical1> ty
09:40:09 <CosmicRay> that is probably the best place to start.
09:40:26 <CosmicRay> there is also the GHC library reference at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
09:41:01 <CosmicRay> also, if you have time to buy a book, I recommend Haskell: The Craft of Functional Programming
09:41:10 <CosmicRay> by Simon Thompson
09:41:48 <CosmicRay> it will be good whether or not you already understand functional programming
09:42:00 <CosmicRay> finallly...
09:42:17 <CosmicRay> there is this: "Learning OCaml for C, C++, Perl and Java programmers" http://merjis.com/developers/ocaml_tutorial/
09:42:25 <CosmicRay> that is actualyl for a different functional language, OCaml.
09:42:59 <CosmicRay> while there are significant differences, the languages have quite a bit in common
09:43:06 <CosmicRay> though I would say Haskell is the more modern of them
09:43:24 <CosmicRay> some people choose to learn a bit about ocaml on the way to learnign haskell
09:43:34 <CosmicRay> ocaml is probably less different than what you're used to.
09:43:40 <CosmicRay> magical1: that should give you enough to start with :-)
09:45:00 <CosmicRay> Igloo: so ghc is doing something weird internally with the floats?
09:45:17 <CosmicRay> Igloo: that is, if you printed it with %f on arm, it would be fine, but the internal representation is different?
09:45:57 <Gahhh> you wanna print with %1.20e to be really certain
09:46:08 <Igloo> I can't remember the details, but it ends up thinking pi is -Inf and the assembler complaining when compiling Prelude.Num or whatever it is
09:46:19 <CosmicRay> heh
09:46:50 <Igloo> If it had though pi was 186.4 I'd probably have just shipped it without noticing, of course  :-)
09:47:12 <Gahhh> That 's going to piss Archimedes off
09:47:17 <CosmicRay> haha
09:47:30 <magical1> thanks I'm just reading through it thanks CosmicRay 
09:48:02 <Igloo> Do let me know if you decide to fix ghc in the near future as I need to do an upload for a few other minor issues soon
09:48:16 <CosmicRay> I'm not sure yet, igloo
09:48:21 <CosmicRay> it depends on whether I have enough free time
09:48:24 <CosmicRay> dno't wait for me
09:48:38 <Igloo> Rightyho  :-)
09:48:46 <Igloo> I have some other bits to look at before than anyway
09:51:44 <magical1> CosmicRay: may I pm you?
09:53:50 <CosmicRay> sure
10:05:00 <Oeje1> How do one separate the clause of a case expression?  E.g.  case x of [] -> 3 {?} (x:xs) -> 4.
10:05:41 <xerox> ; ?
10:06:49 <Igloo> ; or layout
10:07:13 <Oeje1> (case pfx of (Nothing) -> ""; (Just s) -> s)++ " "++command++" "++unwords params  gives an error.
10:07:36 <Oeje1> Wait...
10:08:23 <Oeje1> Hm.
10:09:55 <Oeje1> Ok, it only gives a type error.  Correct syntax, though.  Thanks!
10:19:32 * CosmicRay goes away for lunch
10:30:26 <Oeje1> What does "Varying number of arguments for function `fortolk'" mean?
10:32:03 <Oeje1> Oh, just found it on the haskell-cafe.
10:56:26 <akemp> cvs-HEAD and ghc-pkg: does anyone have a good way to use existing Haskell packages with the new package code?
10:57:02 <akemp> In particular, I'm running into problems building c2hs and gtk2hs
11:05:30 <magical1> sorry, but nope, I'm a newbie..... :(
11:14:33 <stepcut> ack, I forget to update my email address, and now my message is stuck in the haskelldb moderator queue :(
11:14:56 <stepcut> *sniff*
11:15:07 <magical1> poor you
11:15:36 <stepcut> if only I had the forsight to keep a copy in my sent-mail or cc myself :)
11:46:48 * magical1 looks around
11:47:26 * basti_ is invisible though
11:47:57 <magical1> thats why I couldn't see you
11:47:59 <magical1> ;)
11:48:33 <magical1> Is it just me, or is Haskell dificult to get used to?
11:48:40 <basti_> oh no it isnt
11:48:56 <basti_> your thoughts have been spoiled since birth through pascal-ike languages
11:49:10 <arjanb> haskell isn't harder than learning programming for the first time
11:49:20 <johs> magical1: It's not just you.
11:50:25 <Oeje1> magical1: Ok, maybe it's just you and johs.
11:52:54 <basti_> actually i found learning programming hard just the first time
11:53:41 <Oeje1> I think we were just more patient as children.
11:53:50 <basti_> aww im still patient.
11:53:53 <basti_> and wide awake.
11:54:13 <basti_> just a little stoned now and then.
11:59:51 <Philippa> evenin'
11:59:55 <Binkley> hey
12:01:58 <CosmicRay> y0
12:12:52 <Heffalump> perlsupport.com? Isn't that the work of the devil? :-)
12:14:16 <CosmicRay> Heffalump: only if he can be parsed by a regular expression and stored in implied variables :-)
12:15:10 <Heffalump> which are then conveniently clobbered by the next command to come along? cool.
12:15:35 <CosmicRay> chip: have you had a chance to look at YAHT much?
12:15:36 <Heffalump> btw, did you ever reply to my stuff about the HTTP package? If so, I never got it or lost it.
12:15:51 <CosmicRay> Heffalump: no, I think I got confused about how to get an actual source package and then forgot about it
12:15:57 <CosmicRay> sorry about that
12:16:07 <Heffalump> no problem. Consider yourself prodded :-)
12:16:21 <Heffalump> would you like some more explanation of the source package thing?
12:19:31 <Itkovian_> evenink
12:19:41 <Heffalump> 'lo
12:19:43 <Itkovian_> how do I get the data out of the jar when using getContents/
12:19:44 <Itkovian_> ?
12:19:52 <Heffalump> out of the what?
12:20:06 <Itkovian_> the jar, the box, the monad, the whatever it is in
12:20:13 <Heffalump> you don't
12:20:25 <Itkovian_> (i thought so ) 
12:20:27 <Heffalump> you work with operations that can reach their hand inside the jar temporarily
12:20:46 <Heffalump> s/ temporarily//
12:21:07 <Itkovian_> as in ghc -e 'do { cs <- getContents; ls <- (map words) . lines . DATA_FROM_CS; }
12:21:14 <chip> CosmicRay: I've been reading the tutorial first, and I'm currently stuck that hugs won't execute the data examples
12:21:20 <chip> data Color = Red | Blue  for example
12:21:32 <Itkovian_> chup derive from Show
12:21:42 <Itkovian_> as in data Color = Red | Blue deriving (Show)
12:21:43 <Heffalump> chip: put them in a file and tell hugs to load that file
12:21:58 <Heffalump> you can't type in declarations at the hugs prompt, that's just for evaluating expressions
12:22:01 <Itkovian_> s/chup/chip/
12:22:17 <Itkovian_> ah, I misunderstood. as usual.
12:22:27 <chip> So not everything is an expression.  I see.
12:22:43 <Heffalump> right
12:22:48 <Itkovian_> so, any suggestions on how to get that cs thing going I put up there?
12:23:14 <Itkovian_> I need that ls thing, as I need to manipulate it in two different ways ...
12:23:25 <Itkovian_> And I'm too bloody lazy to retype the whole thing
12:23:44 <Heffalump> itkovian: inside the do { ... } cs will contain your data, without the IO
12:23:47 <chip> I've been pondering the conflict between OO and type inference.  Does Haskell (ghc6, for sake of argument) allow runtime class loading?
12:23:51 <chip> s/class/module/ of course
12:24:08 <Heffalump> you should have said 'let ls = map words (lines cs)'
12:24:26 <Heffalump> except I think that's not type-correct either, but it's closer to being type correct than your code is :-)
12:24:29 <Lemmih> chip: With hs-plugins, yes.
12:25:02 <Heffalump> chip: there are more elegant ways of doing many OO-style things than using runtime loading
12:25:10 <Heffalump> can you give an example of what you want to do?
12:25:14 <Itkovian_> Heffalump ... ok.
12:25:33 <Itkovian_> yeah ... can u see the logs from around 16.00 CET this afternoon?
12:25:35 <Itkovian_> :-)
12:25:52 <Heffalump> I could in principle, but I'm in the middle of something else so I'd rather not.
12:25:53 <Itkovian_> breifly I want to verify that in a list of lines with two number on it say
12:25:53 <chip> Heffalump: Runtime loading isn't optional for some programming styles I value.  For example, a system that runs for a while then decides to load plugins based on user identity and activity ("oh, you want the foo behaviors, I'll load the module for that")
12:25:55 <Itkovian_> a b
12:25:56 <Itkovian_> c d
12:26:00 <Itkovian_> b == c
12:26:05 <Itkovian_> d == ...
12:26:07 <Itkovian_> for the next lines
12:26:15 <Heffalump> chip: yes, fair enough.
12:26:26 <Itkovian_> and I'm tired of perling my command lines, I'm looking for something hip.
12:26:30 <Itkovian_> :-)
12:26:31 <Heffalump> I thought you were proposing runtime loading as a solution to the conflict, which is probably isn't.
12:27:05 <chip> Ah, no, rather I'm observing that it complicates type inference.  Inferences must be drawn based on incomplete information.
12:27:09 <Heffalump> chip: lambdabot, the IRC bot written in Haskell on this channel, does pretty much exactly what you describe
12:27:10 <Lemmih> chip: I would do that with higher order functions instead.
12:27:21 <Itkovian_> this works though: ghc -e 'do { cs <- getContents; putStrLn $ show . (map words) . lines $ cs }'
12:27:46 <Heffalump> chip: you end up having to specify an interface to the runtime loaded elements.
12:27:58 <Itkovian_> Any other way to read stuff into ghc on the command line is fine too ...
12:27:59 <Heffalump> so you lose type inference at the boundary
12:28:10 <Heffalump> but type *checking* is still possible
12:28:12 <chip> Heffalump: Not surprising.
12:28:33 <chip> Of course, then you've moved (descended?  been banished to? :-) OO, or at least ADT, style
12:28:41 <Heffalump> (the buzzword to look out for is 'existential types')
12:28:43 <Heffalump> right.
12:30:25 <chip> What a sophisticated language, it even gets existential angst
12:31:06 <Itkovian_> ah well ...
12:31:10 <Itkovian_> I'm off 
12:32:35 <chip> I have the bot source now, I can check that out
12:33:11 <Heffalump> it doesn't use the latest framework for runtime loading
12:33:17 <Heffalump> but you should get the idea of what's possible
12:34:41 <chip> Haskell looks even more like pseudocode than Python does
12:36:32 <Heffalump> well, it tends to allow the construction of powerful libraries that mean that application code can look that way
12:39:23 <chip> It seems to me that the authors of the C++ template rules learned Haskell, then got drunk and added it to C++
12:40:06 <chip>     process _ _ target "dict" _ = do
12:40:18 <chip>     process _ _ target "dict-help" rest = do
12:40:24 <chip>     process _ _ target cmd rest = do
12:41:01 <chip> I could spell that in about a screen of C++ templates.  Except for the string part.  It'd have to be basic values like integers, or enums, or something else that's known and comparable at compile time.
13:41:35 <CosmicRay> Heffalump: are you going to send me an orig.tar.gz+dsc+diff.gz?
13:42:11 <Heffalump> sure. I think I asked you what means of sending was best (out of email, putting it on the web somewhere and making an apt repo)
13:43:52 <CosmicRay> ah, you could just attach it to an e-mail
13:44:47 <Heffalump> ok.
13:52:59 <Heffalump> sent
14:02:51 <boegel> go Poland :)
14:05:44 <xerox> Hi asmodai
14:19:25 <boegel> has anyone heard about the stunt Poland pulled with the voting on Software pattents ?
14:19:35 <Heffalump> a few weeks ago?
14:20:54 <arjanb> and again today
14:36:10 <WilX> A stunt?
14:38:25 <boegel> they used their veto to get the Parlement to re-vote on the subject (if I'm not mistaking)
14:41:13 <Oeje1> WilX: In a bureaucracy like the EU parlament it is quite a stunt.
14:42:16 <WilX> I see.
14:42:44 <WilX> Looks like they have good guts :)
14:47:12 <arjanb> i think it's strange that was put back on the agenda just friday and that the agricultural secretaries decide about adopting it or not
14:55:57 <CosmicRay> arjanb: I couldn't figure that one out either
14:56:14 <CosmicRay> arjanb: what does an agency that regulates ag and fisheries have to do with software patents?
14:56:37 <CosmicRay> but then I am just an american observer and the arcane mechanications of the eu parliament are beyond my understanding at the moment
15:10:46 <toomasr> i have a defintion of averageOfThree :: Int -> Int -> Int -> Float, and averageOfThree x y z = (x+y+z)/3, but this int/int will produce an int and i'm getting an error, i java i would just substitute 3 to 3d or 3.0 to get the required result, how is this done in haskell?
15:11:13 <toomasr> well 3f, not 3d
15:12:26 <Lemmih> It's done automatically but that's not your problem here.
15:12:42 <Lemmih> @type (/)
15:12:43 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
15:13:30 <Lemmih> (x+y+z) has type Int.
15:13:45 <toomasr> yup, but (x+y+z) divided by int produces a fractional int
15:14:09 <oom> try what means of sending was best (out of email, putting it on the web somewhere and making an apt repo)
15:14:10 <oom> [23:45:05] <CosmicRay> ah, you could just attach it to an e-mail
15:14:10 <oom> [23:45:24] pyoko [~pyo@82-39-131-19.cable.ubr05.newy.blueyonder.co.uk] has joined #haskell
15:14:10 <oom> [23:46:00] <Heffalump> ok.
15:14:10 <oom> [23:51:22] maihem [~maihem@host81-156-199-214.range81-156.btcentralplus.co
15:14:12 <oom> er, sorry
15:14:18 <Lemmih> An int is not fractional.
15:14:41 <toomasr> how do i intrepret this (Fractional a) => a -> a -> a, does it mean that all the a's in this expression are of type Fractional a?
15:15:04 <Lemmih> Fractional is a typeclass.
15:15:11 <Lemmih> @info Fractional
15:15:12 <lambdabot> -- Fractional is a class
15:15:12 <lambdabot> class (Num a) => Fractional a where {
15:15:12 <lambdabot>     (/) :: a -> a -> a {- has default method -};
15:15:12 <lambdabot>     recip :: a -> a {- has default method -};
15:15:12 <lambdabot>     fromRational :: Rational -> a;
15:15:13 <lambdabot>     }
15:15:38 <toomasr> seems way above my level
15:16:21 <Lemmih> toomasr: You have to convert (x+y+z) to a Float.
15:17:04 <toomasr> Lemmih: oh, i found something called fromInt which should do the trick, i think
15:17:19 <Lemmih> toomasr: Use 'fromIntegral' instead.
15:17:28 <toomasr> Lemmih: oh, okay, i'll give it a try
15:18:06 <toomasr> Lemmih: it worked thx
15:18:16 <toomasr> @info fromInt
15:19:01 <toomasr> i just started wondering if fromInt was undefined variable,  maybe it is located in a module somehwere and lambdabot can tell me in which
15:19:09 <Lemmih> toomasr: There is no 'fromInt' anymore.
15:19:12 <toomasr> i'm still using fromIntegral though, just was interested
15:19:21 <toomasr> oh, okay
15:20:50 <toomasr> just out of curiosity, isn't the name fromIntegral misleading, as it converts from type Int but the name doesn't say anything about to which type it converts? i checked with lambdabot, it converts to Num
15:21:13 <Lemmih> @type fromIntegral
15:21:15 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
15:21:49 <Lemmih> Notice the typeclasses.
15:22:00 <toomasr> Num and Integral?
15:22:47 <Lemmih> Yep. I can't just convert Ints to Floats but also any instance of Integral to any instance of Num.
15:23:44 <toomasr> true
15:25:48 <Itkovian_> Can I do this any simpler? 
15:25:49 <Itkovian_> ghc -e 'do { cs <- getContents; putStrLn $ (let list = (map words) (lines cs) in show ( let ls = tail (map (\(x:y:[]) -> x) list) in let rs = map (\(x:y:[]) -> y) list  in filter (\(x,y) -> x /= y) (zip ls rs) )  ) ; }'
15:26:03 <Itkovian_> Compared to my solution of this aftnoon ... it's a major improvement ...
15:26:20 <Itkovian_> whta it does:
15:26:22 <Itkovian_> cat | cut -d" " -f3,5 | ghc -e 'do { cs <- getContents; putStrLn $ (let list = (map words) (lines cs) in show ( let ls = tail (map (\(x:y:[]) -> x) list) in let rs = map (\(x:y:[]) -> y) list  in filter (\(x,y) -> x /= y) (zip ls rs) )  ) ; }'
15:26:37 <Itkovian_> VM_Threads -> 10 -- 4
15:26:37 <Itkovian_> VM_Threads -> 4 -- 10
15:26:37 <Itkovian_> VM_Threads -> 10 -- 10
15:26:37 <Itkovian_> VM_Threads -> 10 -- 5
15:26:37 <Itkovian_> []
15:26:51 <Itkovian_> it checks if the thread switches are consistent without any holes ...
15:27:20 <Itkovian_> the let ... in let ... in let ... bothers me a bit.
15:29:58 <doojin> I need a help
15:30:12 <doojin> hello
15:30:41 <toomasr> hello
15:30:41 <Lemmih> Greetings doojin.
15:31:05 <doojin> hmm
15:31:18 <doojin> I burned a cd from an iso, but the cd didn't work at all....
15:31:28 <doojin> I choosed track at once option...
15:31:37 <Lemmih> And how is this related to Haskell?
15:31:39 <doojin> did I have to choose disk at once write method?
15:31:48 <doojin> no relation to
15:32:03 <doojin> just I didn't find proper place
15:32:03 <Lemmih> Then why are you asking for help in #Haskell?
15:32:22 <doojin> because I like the name, haskell hehehe
15:32:47 <toomasr> doojin: what linux distro are you using, #debian, #gentoo are on this server for example
15:33:27 <doojin> mine is
15:33:29 <doojin> fc2
15:34:02 <toomasr> try #fedora
15:34:27 <toomasr> or look for a channel of your writing software
15:34:41 <church> How long does it take to compile the goddamn GHC? My laptop's been at it for half a day already. 
15:34:47 <Itkovian_> glad we are such a nice crowd
15:35:06 <Itkovian_> what cpu/how much RAM do ya have?
15:35:30 <church> 2 Gig P4, 256MB
15:36:19 <Itkovian_> hmmm that 256 is perhaps the culprit ... is the machine trashing?
15:36:31 <church> not really.
15:36:44 <Itkovian_> hmmm ... do you already have a working ghc on it?
15:37:43 <church> i don't think so (at least i didn't)
15:38:14 <Itkovian_> then the bootstrapping may take a while iirc
15:38:25 <Itkovian_> consider it an excercise in patience
15:38:53 <church> God, I want patience, and I want it now!
15:39:40 <church> I think it spent most of its time compiling itself
15:40:05 <church> ... i.e. in the second phase of the bootstrapping
15:41:02 <church> it also hogged an incredible chunk of disk space. close to a gig as of now.
15:41:50 <boegel> church: wait until it stops compiling and produces some strange error:)
15:42:28 <church> arghh...
15:43:21 <church> RAM is not a problem, btw. I'm using Linux. I have 70MB free right now, and only using 100MB of swap (probably populated by a bunch of other programs I have open)
15:43:26 <Lemmih> church: Why are you compiling GHC?
15:43:40 * toomasr bets he is a gentoo user
15:43:52 <church> toomasr: yes
15:44:15 <WilX> :))
15:44:42 <boegel> hehe
15:44:50 <Itkovian_> well well ...
15:44:53 <boegel> toomasr: tell us how you did it ;)
15:45:03 * boegel knows Itkovian_ uses gentoo too :D
15:45:17 <church> all linux distros suck, without exceptions. Gentoo just appears to suck less. (I spent years trying others, debian more than others)
15:45:22 <Itkovian_> church, maybe you want the emerge the ghc-bin first :-)
15:45:28 <Itkovian_> s/the/to/
15:45:58 <Itkovian_> church: then why do you use Linux if you think they suck? Maybe try FreeBSD?
15:45:59 <toomasr> boegel: i remember typing apt-get install ghc6 or smthing like that :)
15:46:15 <boegel> :)
15:46:24 <Itkovian_> I did emerge ghc-bin.
15:46:44 <church> Itkovian_: I didn't say Linux sucked, just the distros. FreeBSD sucks even worse (it's like a poor man's gentoo, IMHO)
15:46:53 <toomasr> in gentoo the if the package has -bin suffix it means it won't compile but use the binary one?
15:46:54 <Itkovian_> no time to wait for a compilation, my machine's got Java stuff to run, VM's to compile, and some such
15:47:05 <Itkovian_> cmon, FreeBSD is just great.
15:47:06 <church> toomasr: thanks. I missed that.
15:47:21 <Itkovian_> toomasr: generally, yes.
15:47:36 <toomasr> i think most of the operating systems are great :)
15:47:48 <toomasr> emacs sux though
15:47:49 <Itkovian_> I used FreeBSD for four years. It rocked.
15:47:51 <church> toomasr: I think they are all brain dead.
15:48:02 <Itkovian_> church: then design yr own?
15:48:14 <Itkovian_> toomasr: I agree with that last statement
15:48:16 <church> Itkovian_: I have more interesting things to do than tinker with OSes
15:48:27 <Itkovian_> fair enough.
15:49:05 <Itkovian_> now what don't you like about the Linux distros?
15:49:26 <toomasr> learning curve i bet
15:49:59 <church> toomasr: I've used Linuxi longer than Itkovian_ used FreeBSD :)
15:50:34 <toomasr> very good
15:51:24 <Itkovian_> then what's wrong with them?
15:51:43 <Itkovian_> I agree that most can use some improvement, but overall, e.g. Gentoo is very good.
15:51:48 <Itkovian_> No bloat on this machine.
15:52:16 * boegel mentions Fedora
15:52:43 <boegel> ... and then goes to bed
15:52:47 <boegel> g'night everyone
15:52:53 <toomasr> well it always depends how you configure the machine, allthough i can't imagine configuring lets say mandrake to be withouth bloat
15:52:56 <church> Itkovian_: each has terrible flaws. Mind you, I think Gentoo is the best possible solution for me (given the sorry state of OSes).  Too many to list each
15:54:45 <Itkovian_> Well, arguing is useless I think so ...
15:55:25 <toomasr> yup
15:55:46 <church> Itkovian_: anyway :-)  Redhat isn't really there any more; Mandrake has terrible quality. Debian is too stale and religious. Gentoo is too young and you often have to jump though hoops to do things that could be very easily automated. I could rant forever, as memories flow back, but it's not really the topic I'm interested in.
15:56:14 <Pseudonym> Clearly you must roll your own distro.
15:57:47 <church> Pseudonym: if I had spare slaves, then I would.
15:57:54 * Oeje1 is brewing on a Haskell distro.
16:00:13 <Oeje1> Actually it's the GoboLinux LiveCD (also for installation) tweaked with settings and packages for Haskell.
16:00:17 <church> Is anyone familiar with "type systems" paper by Luca Cardelli? I'd like to read something similar but Haskell-specific, i.e. talking about type classes, and inference algorithms.
16:00:56 <church> .. any suggestions?
16:04:21 <toomasr> i'm trying to implement certain exercises give in a haskell book, and i just implemented howManyAboveAverage, and i ended up defining 5 functions for it :)
16:04:28 <toomasr> *given
16:08:44 <church> wow, ghc finally finished compiling, and all i had to do is complain on #haskell !
16:09:13 <Pseudonym> There's a good paper on the design space of type classes.
16:09:15 <Pseudonym> Let me find it.
16:09:23 <Pseudonym> Yeah, GHC reads #haskell.
16:09:36 <Pseudonym> http://research.microsoft.com/Users/simonpj/papers/type-class-design-space/
16:09:55 <Pseudonym> The one on higher-ranked types is good, too.
16:10:29 <Pseudonym> http://research.microsoft.com/Users/simonpj/papers/putting/index.htm
16:14:26 <church> Pseudonym: thanks
16:15:44 <church> I'm curious if there are languages with first-class types. (without inference). Inference is just conveniece, while first-class types would be a fundamental feature.
16:15:45 <Pseudonym> NP
16:16:13 <Pseudonym> I don't know of any static languages with that feature offhand.
16:16:27 <Pseudonym> But there are a few OO languages which support classes as first-class objects.
16:16:30 <Pseudonym> e.g. smalltalk
16:22:33 <toomasr> http://eugeneciurana.com/pastebin/pastebin.php?show=5000 <- can someone take a look, i don't understand exactly what i am doing wrong
16:25:59 <Lemmih> toomasr: 'f a-1' is parsed as '(f a) - 1'.
16:26:15 <Lemmih> toomasr: Change 'b-1' to '(b-1)'.
16:26:26 <toomasr> thx, it worked
16:26:48 <toomasr> i'm supposed to take an exam today in haskell class, things are not looking well
16:32:02 <church> toomasr: my haskell knowledge is rusty and it got mixed up with prolog. I thought the order was important (not). and _ were illegal in identifiers (no); and I totally missed the precedence.
16:32:21 <toomasr> :)
16:32:55 <toomasr> i don't have anything to mix haskell up with, just that when i have to write the programs on paper without being able to test everything i write is gonna be a problem
16:33:06 <CrewdenX> wouldn't being required to have all monad work at the top-level of a program cause problems in designing a program?  seems awkward to me.
16:34:44 <Lemmih> CrewdenX: Monads aren't limited to the entry point of your program.
16:36:11 <CrewdenX> Lemmih: something i read a while back indicated that they were.
16:37:02 <CrewdenX> Lemmih: monadic code can be invoked by non-monadic code?
16:37:37 <Lemmih> CrewdenX: Of course.
16:37:59 <CrewdenX> Lemmih: how?
16:38:25 <Lemmih> CrewdenX: Let's take a simple monad like Maybe.
16:38:47 <Lemmih> monadicCode = do { a <- Just 'c'; return c }
16:39:37 <Lemmih> nonMonadicCode = case monadicCode of Nothing -> False ; Just _ -> True
16:41:26 <Lemmih> CrewdenX: Do you understand?
16:41:38 <CrewdenX> Lemmih: nope, but i barely understand haskell.
16:41:48 <CrewdenX> Lemmih: probably it would be best to stick with the io monad.
16:43:09 <Heffalump> the point is that any type constructor that satisfies certain rules can be a monad
16:43:18 <CrewdenX> Lemmih: i'm leaning haskell on my own, and haven't used in much largely because i run into trouble and then end up just writing it in a different language.  there are a few things i wanted to clear up before spending much more time on the language.  one was this issue.
16:43:29 <Heffalump> but IO is special, because it's introduced by the entry point to your program, and non-monadic code can't invoke it.
16:46:05 <CrewdenX> i'll have to take your word for it.
16:48:37 <Lemmih> s/return c/return a/
16:51:21 <CrewdenX> Lemmih: hmm, isn't that an example of monadic code calling non-monadic code?
16:53:30 <Lemmih> CrewdenX: No. 'nonMonadicCode' has type Bool (which isn't a monad) and 'monadicMode' has type Maybe Char (which is a monad).
16:55:32 <CrewdenX> Lemmih: hehe, ok.  thanks for your time anyways.
16:56:31 <Lemmih> CrewdenX: No problem.
17:50:24 <araujo> Helo sh10151 
17:50:26 <araujo> mm
17:50:28 <araujo> shapr, *
17:50:35 <shapr> hiya araujo 
17:50:40 <shapr> I heard about this great language called Haskell.
17:50:49 <araujo> haha
17:51:00 <shapr> :-)
17:52:48 <shapr> The more I use Haskell, the more I dislike procedural code.
17:53:04 <shapr> Fighting with Zope and Plone is painful.
17:55:10 <shapr> OOP is getting a real beat down on that LtU thread.
17:56:18 <shapr> I have this theory that companies of the future will hire four heavy duty programmers instead of ten lightweights. It's cheaper, and you get better code.
17:56:51 <araujo> hey, wait a minute, but...
17:57:04 <araujo> they don't need to use functional programming for that? 
17:57:04 <CrewdenX> shapr: why in the future?
17:57:06 <araujo> ;-)
17:57:14 <shapr> CrewdenX: they sure aren't doing it now.
17:57:26 <CrewdenX> shapr: exactly.
17:57:43 <shapr> A few companies do it, I think they'll survive.
17:58:09 <shapr> araujo: yes, I think they'll need FP and everything else to be heavy duty.
17:58:31 <araujo> OOP is nice theoretically. OO Languages implementations is the problem.
17:58:41 <toomasr> one of my expan questions is gonna be like follows : "(((+4).) . (.(*3))) (+2) 1" and i have to calculate what i produces, can i somehow tell hugs to explain this line to me?
17:58:47 <toomasr> *expan = exam
17:59:10 <araujo> As long as we keep getting java-like languages., i think OOP will be hopeless and of no relevant progress technologically.
17:59:32 <shapr> Better OOP languages have been available. Sun dumped Self for Java.
17:59:46 <araujo> shapr, something i still don't understand.
18:00:06 <araujo> But ironically, those crappy OO languages are the most popular, please don't ask me why.
18:00:16 <shapr> I think it's because they have a flat learning curve.
18:00:29 <shapr> toomasr: I don't think hugs can explain it to you directly.
18:00:29 <toomasr> java doesn't have a flat learning curve
18:00:43 <araujo> shapr, i think it's because people is just too _procedural_ yet.
18:00:45 <shapr> toomasr: why not?
18:00:58 <toomasr> shapr: but when i miss lets say the last "1" it will explain what it tried to do
18:01:01 <araujo> you can program in java without a shit of OOP
18:01:26 <toomasr> araujo: no you can't :)
18:01:37 <araujo> I actually know people who just don't have idea what OOP is all about, and they make a living with a java.
18:01:38 <shapr> Java may not have a flat learning curve, but Java is designed for managers, not programmers.
18:01:46 <shapr> toomasr: yes, you can. I worked with people who did it.
18:01:54 <araujo> toomasr, read my previous statement
18:02:03 <shapr> All methods were static, instances were not used.
18:02:11 <araujo> that is disgusting
18:02:19 <sh10151> i have seen it
18:02:32 <toomasr> i haven't
18:02:44 <shapr> It goes on like that. These people always wrote else {} clauses for their Java code because they didn't know you could leave it off.
18:02:50 <araujo> i see it everyday, with my co-students
18:02:56 <araujo> and teachers
18:03:17 <sh10151> I just showed a cow orker a jython script and asked him what it would be like in java
18:03:27 <shapr> what did he say?
18:03:31 <toomasr> hmm, well it doesn't count, i'm learning for haskell exam and writing the easiest stuff defining 5-6 subfunctions for it just because i don't know haskell
18:03:46 <sh10151> this is after debating the merits of the examples on the ziclix site
18:03:57 <toomasr> these java noobs aren't working anywhere, they are producing crappy code cos they are in the process of learning it
18:04:00 <sh10151> i sent it to him before leaving for the day
18:04:11 <shapr> toomasr: I worked with twenty five of them.
18:04:23 <sh10151> apparently he "never uses" Lists or Maps in Java, nor does he read things in a line at a time
18:04:23 <toomasr> shapr: at a company, where workers were actually screened first?
18:04:27 <shapr> Yup.
18:04:33 <toomasr> bad management
18:04:42 <shapr> Pretty standard management, sadly.
18:04:48 <toomasr> at school i also see crappy java
18:04:50 <sh10151> toomasr: employers don't know how to screen, interview, and evaluate
18:04:55 <sh10151> I see the same thing
18:05:00 <araujo> toomasr, mm.. let me see how i make this point, 
18:05:00 <toomasr> sh10151: they have professionals for that
18:05:05 <shapr> I've worked in Seattle, Washington, Birmingham, Alabama, and Tornio, Finland.
18:05:14 <sh10151> toomasr: the professionals are at least as clueless
18:05:17 <sh10151> i am telling you
18:05:20 <toomasr> shapr:  wow, how old are you?
18:05:23 <shapr> I'm 33
18:05:37 <shapr> I've been programming since I was 11.
18:05:38 <sh10151> I work for a major user of IT and they don't know wtf they are doing
18:05:54 <toomasr> i've mostly worked for small companies, and on 2 occasions i've seen crappy OO design when using java, thats it
18:06:07 <shapr> toomasr: The major problem is that managers make technical decisions.
18:06:07 <toomasr> sh10151: how do they survive?
18:06:33 <sh10151> toomasr: ha
18:06:40 <toomasr> shapr: its fine as long as they get their decision by calculating what the professionals have said
18:06:48 <sh10151> toomasr: global finance is shady shady stuff
18:07:07 <shapr> I always tell my bosses that I get to make accounting and payroll decisions if they decide what technology I use.
18:07:36 <araujo> toomasr, Java doesn't require you to have any OOP knowledge
18:07:54 <toomasr> araujo: if you write really simple programs
18:08:44 <araujo> toomasr, no
18:09:01 <araujo> toomasr, you also can write complex programs withgout knowing about oop
18:09:08 <shapr> As for programmer quality, there are two generally two types. Those who improve themselves continously and those who do as little as they can do to keep their job.
18:09:09 <araujo> using java.
18:09:34 <araujo> shapr, mm.. i think the java programmers belong to the second category
18:09:48 <sh10151> "those who do as little as they can do to keep their job using java"
18:09:51 <sh10151> that is little indeed
18:10:00 <araujo> Probably that is another reason why you find so much bad written code in java nowaday.
18:10:12 <shapr> I have seen a few java programmers who improved themselves right out of Java.
18:10:40 <araujo> Of course.
18:10:46 <toomasr> araujo: but when using java you _have to_ use certain keywords (class Y extends Blah, class X implements blah, Interface foo, etc.), so they don't understand what they are doing exactly? if thats true then it means that they are programming by coincidence and thats it
18:10:47 <araujo> Im not saying that's not possible
18:11:03 <shapr> I think the greatest risk lies in stagnation, no matter what the language, paradigm, or whatever.
18:11:29 <araujo> toomasr, they programm in java like in C.
18:11:33 <toomasr> there was a paragraph in pragmatic programmer about programming coincidence, the bottom line is it doesn't depend on a language
18:11:39 <shapr> Yes, I agree.
18:11:40 <araujo> And they treat classes as sort of structures
18:11:52 <araujo> And they lead a happy life making a living with java.
18:12:01 <shapr> toomasr: if you read pragmatic programmer, you're doing great!
18:12:18 <toomasr> :)
18:12:33 <araujo> toomasr, something that you can't surely do with... smalltalk?
18:12:37 <shapr> Are you on the mailing list too?
18:12:45 <araujo> or even haskell
18:12:53 <toomasr> okay, i don't know anything about smalltalk
18:12:58 <toomasr> shapr: which one
18:13:08 <shapr> The Pragmatic Programmers mailing list.
18:13:13 <araujo> toomasr, well, even for write "hello world" you have to deal with OOP
18:13:15 <shapr> It's worthwhile.
18:13:34 <toomasr> shapr: i'll check it out, i remember i was blown away by the book
18:13:39 <shapr> Yeah, me too.
18:14:01 <shapr> I'm on my second copy. My first tPP got loaned out and never came back.
18:14:07 <shapr> Have you read SICP also?
18:14:25 <toomasr> SICP?
18:14:26 <araujo> a smalltak programmer told me once: "There are only two kinds of java programmers, those who programms in smalltalk and those who just don't get it"
18:14:39 <shapr> "Structure and Interpretation of Computer Programs"
18:14:45 <araujo> shapr, excellent
18:14:48 <shapr> I recommend two books to all new programmers, SICP and tPP
18:14:56 <araujo> Good Books.
18:15:00 <toomasr> hmm, i'll make a note
18:15:13 <araujo> toomasr, SICP is online.
18:15:30 <shapr> http://mitpress.mit.edu/sicp/
18:15:47 <araujo> Haskell is just a beautiful language
18:15:47 <toomasr> got it
18:16:31 <araujo> I think you would find more quality code in a language like Haskell or Lisp, than in a language like java.
18:16:37 <toomasr> i dislike it, if i didn't have to take this class i think i would have never written a single line of haskell
18:16:57 <shapr> Even if you don't like Haskell, it has some neat ideas that are worth learning.
18:17:07 <araujo> Indeed.
18:17:24 <shapr> I think it was Perlis who said that any language worth learning changes the way you think about programming.
18:17:31 <araujo> And if you grasp at them, they could be of big help many times.
18:17:43 <toomasr> thats true
18:18:41 <toomasr> i think with lisp and haskell the learning curve is more drastic
18:19:15 <shapr> I think the viewpoint is just very different from procedural.
18:19:18 <toomasr> i just read a chapter about list comprehension, and you really have to keep coding to fully understand the value of it, so you can grasp so little at a time
18:19:24 <toomasr> true
18:19:48 <shapr> Haskell thinks like an equation.
18:19:51 <toomasr> but haskell is a very powerful language
18:20:19 <shapr> You don't do step by step, you evaluate an expression to result.
18:22:16 <shapr> Have you used first class functions?
18:22:58 <shapr> Haskell is based on lambda calculus, so it allows partial evaluation. If take this example again - "(((+4).) . (.(*3))) (+2) 1"
18:22:58 <toomasr> shapr: i thought that too until i saw the constructs where there were conditional checks done on variables that were actually defined/initialized after the conditions, it looked so weird to mee
18:23:30 <shapr> toomasr: what do you mean? do you have an example?
18:23:39 <Lemmih> Eek. shapr has been coding for longer than I have lived.
18:23:48 <toomasr> shapr: i'm searching the book, can't remember if it was switch or smthing like that, give me a second
18:24:08 <shapr> Lemmih: are you surprised? :-)
18:25:25 <shapr> toomasr: lazy evaluation means that a Haskell program works a bit like pulling a loose string out of a sweater. You only get as much thread as you actually pull.
18:26:37 <Lemmih> shapr: Yeah actually.
18:27:16 <toomasr> is the only point of lazy evaluation that it doesn't evaluate things that it won't need?
18:27:36 <shapr> No, it has more points than that.
18:27:53 <shapr> you can also use it to 'lump' the evaluation completely differently.
18:28:20 <toomasr> okay, what does lump mean
18:28:28 <Nioate> it won't evaluate things until they are needed
18:28:54 <shapr> I wrote a mailing list archive search webapp, and I used a lazy pipeline to import the emails.
18:29:59 <shapr> That meant that the text for an email would get slurped into the parser until there was a whole email available, then the email datastructure got stuck into the database, all the memory for the email and the text got freed, and then the next chunk of text was read in.
18:30:28 <toomasr> Nioate: well right now the only thing that i can deduct from this is that a) you'll save some evaluation time b) you can write code that takes advantage of this but you can also write code in other programming languages that takes advantage of that's type of evaluation
18:30:33 <shapr> That's really handy with 300mb archives. It means I can still keep ram usage down to a max of 30mb or so
18:31:30 <shapr> Sure, you can write lazy and eager code in any language.
18:31:43 <toomasr> shapr: but then the action of the program was "lazy", this can be achieved with almost any language
18:32:02 <CrewdenX> sh10151: "eager code" ?
18:32:19 <CrewdenX> s/sh10151/sharp/
18:32:44 <toomasr> the book i'm reading brought out a point in the lazy evaluation part, that it doesn't evaluate any expression twice like if you have (2+3) + (2+3), (2+3) will get evaluated once
18:32:47 <shapr> CrewdenX: in some cases it's more efficient to evaluate something ahead of item.
18:33:13 <CrewdenX> shapr: that is what you mean by eager?
18:33:22 <toomasr> i don't see this as anything good either because it needs to somehow know what has been evaluated and whats not
18:33:25 <shapr> toomasr: that's also partially because Haskell works like an equation. You can't do that in Java because each execution of a function or method can have side-effects.
18:34:38 <shapr> CrewdenX: take Joy for example, instead of pushing 1 1 + onto the stack, it's more efficient to eagerly evaluate it to 2
18:35:01 <CrewdenX> shapr: you're reading into the question to much.
18:35:16 <shapr> ?
18:35:23 <shapr> Probably because I'm sleepy.
18:35:43 <CrewdenX> shapr: the question was about your meaning of the the term "eager code", nothing more.
18:35:50 <shapr> That was an example.
18:36:22 <shapr> Sometimes you can do stuff ahead of time to make life easier in the future.
18:38:38 <shapr> toomasr: in my opinion, lazy evaluation is more work than strict eval, but it allows a lot more elegance in code.
18:39:45 <shapr> anyway, time for sleep
18:39:49 <toomasr> yeah i guess so, my though is that most probably you can take more advantage of lazy than strict
18:39:56 <toomasr> *thought
18:40:23 <shapr> Yes, and that's always been my choice, I'm willing to put in more work for more power in return.
18:42:59 <Pseudonym> http://spamusement.com/ <- Start at the bottom and work your way up.
18:43:30 <toomasr> okay, someone please explain this (((+4).) . (.(*3)) (+2) 1, if . means that the a.b the output of b will be the input of a, then ((+4).) doesn't make sense
18:43:44 <Pseudonym> Aaargh!  Run away!
18:43:49 <Pseudonym> PLEASE INSERT SOME POINTS!
18:46:15 <heatsink> mashed potatoes what the
18:52:33 <toomasr> hmm, if function composition (a . b) x means a(b(x)), then how does ((+4).) make sense as nothing is following the .?
18:52:59 <toomasr> i'm gonna have a cigaret and coffee, its 5AM here already
18:54:14 <Pseudonym> ((+4).) = \f -> (+4) . g = \f x -> (+4) (g x) = \f x -> g x + 4
18:54:22 <Pseudonym> Ujm.
18:54:27 <Pseudonym> Make that \g throughout.
19:05:27 <toomasr> Pseudonym: make that \q throughout meaning i should substitue every \f with \g?
19:05:55 <toomasr> or not
19:08:39 <toomasr> damn i didn't understand
19:08:41 <Pseudonym> I mean:
19:08:52 <Pseudonym> ((+4).) = \g -> (+4) . g = \g x -> (+4) (g x) = \g x -> g x + 4
19:29:09 <juhp> can someone give me a clue about this:
19:29:33 <juhp> % ghc -V
19:29:33 <juhp> The Glorious Glasgow Haskell Compilation System, version 6.3.20050121
19:29:48 <juhp> % ghc -V |grep vers
19:29:48 <juhp> %
19:30:50 <juhp> whereas:
19:31:31 <aj> works here (version 6.2.1); what's "ghc -V | cat" say?
19:31:32 <juhp> % ghc-6.2.2 -V | sed -e "s/[a-zA-Z ,]*\([0-9.]*\)[a-zA-Z ]*/\1/"
19:31:32 <juhp> 6.2.2
19:31:51 <juhp> aj: nothing
19:32:15 <aj> it'll be noticing stdout's not a terminal and doing stupid things because of it
19:32:27 <juhp> ah
19:32:33 <aj> maybe -v5, --version, or some other option will help
19:33:29 <juhp> perhaps it is bug in cvs?
19:33:51 <aj> i'd call it a bug, certainly
19:33:57 <juhp> yeah
19:54:51 <cm> hello
19:56:24 <juhp> ok, filed a bug
20:00:19 <SyntaxNinja> hi cm
20:00:25 <cm> hello SyntaxNinja 
20:03:14 <juhp> oh, good, my ghc-6.3.20050121 can't even compile the first file of gtk2hs... sigh
20:22:13 * Lemmih is back.
20:24:07 <Lemmih> I had to walk about 100m to find the switch which had been turned off.
20:58:32 <toomasr> hmm, i have k :: a -> b -> a, k x y = x, now i run ((k 2) 4), how does it produce 2? i understand that k is a function that accepts 2 arguments, but ((k 2) 4) is not calling k with 2 parameters, just one, 2, maybe someone can explain?
20:59:34 <toomasr> i guess i have misunderstood what ((f a) b) means, but i understand that to call a function with 2 arguments you have to use the format (f a b) and ((f a) b) doesn't make sense to me
20:59:39 <SyntaxNinja> toomasr: well (k 2) is a function from b -> a
21:00:08 <SyntaxNinja> k is a function from a -> b -> a, (k 2) is a function from b -> a and (k 2 b) is a function of 'a'
21:01:25 <toomasr> so when i call k with one parameter it is actually calling k with the first argument from the definition dismissed?, resulting in b -> a?
21:01:44 <SyntaxNinja> nope, it just gives you a "new" function that sorta wraps up that 2
21:02:08 <SyntaxNinja> in Haskell, you can "partially apply" functions in this way.
21:02:20 <toomasr> so (k 2) is like a function of k, that already has got the second argument, correct?
21:02:47 <SyntaxNinja> it already has the first argument
21:02:56 <toomasr> wow, it sounds cool, so i can already give the function some data when i have it and give the rest when i get it
21:02:58 <toomasr> yeah, first
21:03:25 <toomasr> thanks a lot
21:03:41 <toomasr> this is exactly what i needed to know, now i understand how this ((+4).) is possible
21:03:43 <SyntaxNinja> yeah, that is exactly right. it's very useful.
21:03:50 <SyntaxNinja> that's the example I was going to give ;)
21:04:00 <toomasr> :)
21:04:37 <Pseudonym> (+4) is actually a little different, because it's an operator section.
21:04:39 <Gahhh> because of haskell, I use more lambda functions and map/reduce in python. heh.
21:04:43 <Pseudonym> (+4) = \x -> x + 4
21:04:49 <Pseudonym> but (4+) = \x -> 4 + x
21:04:57 <toomasr> i don't get the \x thingy
21:04:59 <Pseudonym> But it amounts to the same thing.
21:05:05 <Pseudonym> Oh, that's an anonymous function.
21:05:11 <Pseudonym> The \ is pronounced "lambda".
21:05:11 <SyntaxNinja> Gahhh: I can't tell you how many times I cry to myself, "If only I had map!" in java or something
21:05:33 <toomasr> Pseudonym: okay
21:05:37 <Pseudonym> \x -> x + 4 is the same as: let f x = x + 4 in f
21:05:51 <Pseudonym> Except you don't have to give the function a name.  i.e. it's anonymous
21:05:59 <Pseudonym> a.k.a. "lambda expression"
21:06:00 <toomasr> so (4+) is like a halfway function, that it just need one more parameter
21:06:05 <Pseudonym> Right.
21:06:30 <toomasr> wow, i can now do 2 more exam exercises, thx a lot guys
21:07:15 <Gahhh> I read some of Backus' "Can Programming be liberated..." paper today. Interesting and historical.
21:08:08 <Pseudonym> Have you read the "lambda the ultimate" papers yet?
21:08:16 <Pseudonym> Also interesting and historical.
21:08:18 <Gahhh> The receommended reading posts ?
21:08:42 <Pseudonym> One day, someone is going to have to write "Lambda: The Ultimate Objective".
21:09:04 <Gahhh> I probably will read them, but that's a lot of reading. I'm also trying to study some maths on my own nowadays.
21:09:23 <Pseudonym> At the risk of stating the obvious, though, the paper names are incorrect.  "Ultimate" means "final", and clearly nothing is final about lambda.
21:09:52 <Gahhh> I think you need to excuse them for the coolness factor
21:09:52 <toomasr> is lambda expr something more than an anonymous function?
21:10:12 <SyntaxNinja> toomasr: not really
21:11:22 <Gahhh> Pseudonym, does the new Cell arch of Sony/IBM represent a new potential for FP ?
21:15:49 <Pseudonym> Don't know.
21:16:23 <Gahhh> The whole thing looked like "we welcome our new hand-written assembly overlords" to me.
21:17:13 <Pseudonym> They said that about the Itanium, too.
21:17:19 <Pseudonym> Mind you, they were probably right there.
21:17:44 * Pseudonym is reminded of the SufficientlySmartCompiler page on c2.com for some reason
21:18:00 <Gahhh> Yes
21:18:19 <cm> Gahhh, from PS2 to PS3 it's a small step only
21:18:24 <Gahhh> My MS thesis was on a certain architecture that was awaiting its "saviour" compiler as well.
21:23:26 <Gahhh> for some reason, bitstream vera sans looks awful on win2k with antialiasing...
21:25:22 <toomasr> its cool that ((+4).) actually has 2 pending functions which need one more argument, if im correct it is a **** powerful construct
21:25:55 <toomasr> now i wish i had attended classes
21:27:45 <SyntaxNinja> heh, well you seem to catch on pretty fast.
21:28:12 <SyntaxNinja> I might change my tune if you suddenly start complaining that you only have 2 hours to turn in your 100 line lab and you haven't learned anything whatsoever about haskell.  not that that has ever happened in this channel before ;)
21:31:31 <Nioate> it's called partial function application (right?)
21:34:58 <Pseudonym> Yes, or "currying".
21:36:27 <musasabi> morning
21:37:05 <toomasr> my book has a chapter about it, i still have 2 more hours till the exam
21:38:23 * musasabi has an exam about SML today - the only problem is that my SML is from reading language specs and Okasaki.
21:38:30 * Pseudonym has no exams
21:38:39 <toomasr> but during taking the shower i started thinking that ((+4).) can be written in java too, just syntactically will be different
21:39:14 <toomasr> musasabi: SML?
21:39:21 <musasabi> toomasr: Standard ML
21:39:32 <toomasr> musasabi: ML?
21:39:40 <musasabi> an eager functional language with nice module system.
21:39:49 <toomasr> oh
21:40:09 <Gahhh> how can (+4) be written in java ?
21:40:11 <toomasr> wow, there is actually #sml on this server too
21:40:22 <SyntaxNinja> and #ocaml
21:40:29 <Gahhh> I'm ion #ocaml
21:40:49 * musasabi likes haskell better ;)
21:40:58 <Gahhh> So do I
21:41:28 <Gahhh> I was looking at "wc" example in ocaml, and it looks like perl because they use globals and imperative stuff all over.
21:41:49 <Pseudonym> You can actually write (+4) in C++ more or less.
21:41:51 <toomasr> Gahhh: well in java + is strictly an operator, but in haskell it seems to be a function(and you can overload it, if i understood correctly), so lets say java has a function of Math.sum then one would write Math.sum(4, hereisthependingpart)
21:41:53 <SyntaxNinja> bah. stupid ocaml
21:42:16 <Pseudonym> In that you can have objects which act as functions.
21:42:30 <Pseudonym> Boost.Lambda is about as good as it gets, which isn't great.
21:44:28 <Gahhh> when I need lambda functions in C++, I usually declare them like "lambdaFunc1, lambdafunc2" in an anon namespace (which possibly confuses my coworkers. wtf is lambda...)
21:46:34 <SyntaxNinja> heh
21:47:00 <SyntaxNinja> so I think that the last time I was seriously programming in C++, gcc didn't yet implement namespaces correctly.  i assume that this is no longer the case?
21:47:03 <Pseudonym> I had a piece of code a couple of months ago which almost didn't pass review because it only made sense when you translated it back into the original Haskell.
21:47:31 <ozone> SyntaxNinja: g++ >= 3.3 is pretty decent
21:47:47 <Gahhh> Pseudonym, do you prototype in haskell ?
21:48:01 <SyntaxNinja> ozone: I see
21:48:03 <ozone> i haven't had any major problems compiling C++ stuff with it, except possibly for const stuff in templates (which is dicey with all the C++ compilers i've used)
21:48:04 <Pseudonym> Sometimes.
21:48:06 <musasabi> Pseudonym: keep the haskell code as a comment and say "this is pseudocode describing how it works"
21:48:35 <Pseudonym> The purpose of the code was to compute the "intersection" of a number of ASN.1 data structures.
21:48:46 <Pseudonym> It was much, MUCH easier to write using algebraic data types.
21:48:48 <Gahhh> I am scared of prototyping in haskell because it's very unlike C++. So I use python...
21:50:45 <SyntaxNinja> but if you're prototyping something that you yourself are going to write, then what does it matter how close the implementation language is to the prototype language?
21:51:13 <SyntaxNinja> because you should translate it into an ideom that makes sense for the implementation language, and not copy code line-for-line anyway :) no offense, Pseudonym ;)
21:54:12 <Pseudonym> :-)
21:55:08 <Gahhh> if they are closer, the hairy stuff like sensitive while loops are line by line copies.
21:57:52 <SyntaxNinja> the advantage to coding it in Haskell is that it will be frustrating and sad to translate it to C++, so you'll say to your boss, "Or... we could just make the Haskell version into a product" and everyone wins
21:58:43 <Gahhh> hah
21:58:53 <Pseudonym> If only 'twer so.
21:58:58 <Gahhh> maybe if I was working for google or something
21:59:11 <Gahhh> but where I work, people are already shaken that I write in python heh
21:59:24 * Pseudonym really wishes Google would open an office here
21:59:38 <Gahhh> Hey, you could always be an H1B slave like me
21:59:44 <juhp> google uses haskell?
21:59:55 <Gahhh> no, google use python afaik
22:00:06 <Gahhh> among others
22:00:14 <juhp> ah, nm
22:00:21 <Pseudonym> Google uses whatever they want to.
22:00:24 <toomasr> juhp: at google they let you be more creative afaik
22:00:32 <Gahhh> but they are more likely to let you be more creative
22:00:45 <Pseudonym> If you wrote a working prototype in Haskell, they might not use it in production, but they'd love you for getting it working.
22:00:57 <juhp> ah, ok
22:01:05 <Gahhh> They'd love me for using it as a reference, a test harness driver, etc.
22:01:12 <Gahhh> or even documentation lol
22:01:26 <Gahhh> "design documentation is in haskell, not word"
22:02:41 <SyntaxNinja> Gahhh: there's something to be said for writing a prototype in literate haskell, with the design in the comment bits where you can produce the latex document directly from the source
22:02:46 <SyntaxNinja> in fact, that would rule. please do that.
22:04:13 <Gahhh> is that sarcasm ? I mean, isnt there lhs files already ?
22:04:33 <SyntaxNinja> I'm being serious :)
22:04:58 <SyntaxNinja> hi Philippa
22:05:09 <Gahhh> I am not too keen on literate programming. I tried it before (with Leo), was not too impressed.
22:06:05 <SyntaxNinja> yeah, I've never quite gotten into it, but I think it might make sense in conjunction with prototyping like that.
22:07:34 <Gahhh> also, latex is a no-no here as well. We are MS WORD only.
22:07:53 * Gahhh hates Microsoft Equation Editor 3.0 and NO he doesn't wanna upgrade...
22:08:17 <SyntaxNinja> Gahhh: you must be here for solace.
22:08:45 <SyntaxNinja> what's H1B?
22:09:00 <Gahhh> It's a temporary work visa for foreigners.
22:10:55 <SyntaxNinja> ahh
22:11:10 <SyntaxNinja> I misread and thought you worked at a place called "H1B"
22:12:06 <Gahhh> heh
22:13:56 <xerox> 'morning
22:15:30 <Pseudonym> Nice try on the H1B but I really, REALLY do not want to relocate.
22:15:39 <Pseudonym> And that goes double for relocating to the US.
22:16:49 <Gahhh> I know. I was teasing you.
22:17:16 * Gahhh is a secret human resources worker for NVIDIA
22:17:54 <Pseudonym> Too late, I turned them down.
22:18:05 <Pseudonym> You probably think I'm joking about that.
22:19:18 <Gahhh> no, you told me that and that's why I am teasing you lol
22:19:31 <Gahhh> about the Cg compiler stuff
22:19:58 <Pseudonym> :-)
22:19:59 <Pseudonym> Yeah.
22:24:31 <Pseudonym> Must away.
22:24:38 <Pseudonym> Public holiday tomorrow, too.
22:24:40 <Pseudonym> Nytol!
22:51:32 <toomasr> bye
23:49:40 <Itkovian> meuning
