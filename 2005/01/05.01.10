00:20:00 <bourbaki> moin
01:09:50 <adept> are there any MArray users available? :)
01:24:43 <xerox> hi!
01:33:26 <balkan> a question about type classes. are they really necessary. couldn't there just be overloaded functions instead?
01:33:51 <ibid> type classes are a form of overloading
01:35:02 <balkan> yes, but why do you have to declare a type class. i mean why not just go ahead and declare the overloaded function directly?
01:36:38 <Si\> how would you do that?
01:37:24 <adept> balkan: question -- "add vodka to martini" and "add one to ten" - are they instances of single overloaded "add" or not? :)
01:38:15 <balkan> let say you want to define additon for Integer. the just declare (+) :: Integer a -> Integer a -> Integer a
01:38:29 <Si\> yes, but how define what an Integer is?
01:38:32 <balkan> the same for float and so on.
01:38:50 <Si\> oh you're talking about ad-hoc overloading
01:39:02 <balkan> ok. is that what it's called.
01:39:51 <bluegods> damn
01:39:52 <Si\> type-class do just that essentially, except you declare them within an instance for the particular type you are working on
01:39:56 <bluegods> im banned from perl
01:39:59 <bluegods> and python
01:40:42 <bluegods> :(
01:40:52 <bluegods> can haskell scle well?
01:40:57 <balkan> Si\: but it seems like you could do without the type classes entirely.
01:41:02 <bluegods> and handle web based databses for business
01:41:06 <bluegods> like php n what not
01:41:25 <balkan> bluegods: i like to think so.
01:41:26 <Si\> no you can't, I work extensively with type-classes to enable modular customization
01:42:01 <balkan> Si\: in c++ you can use ad-hoc overloading. it seems to work there.
01:42:09 <adept> balkan: and what would be an analog for "f :: Num a => a -> a" with ad-hoc overloading?
01:42:32 <Si\> type-classes allow one to scale a system by declaring the types of method available to potential candidate types, without actually declaring what those candidate types are
01:42:36 <balkan> adept: you're talking about default methods?
01:42:44 <adept> balkan: seems like without type clasess you will get type signatures that will be next to useless because they will be too generic.
01:42:49 <Si\> believe me balkan, C++ is not a good bench-mark for a well implemented type system
01:43:16 <adept> balkan: no, i'm not talking about default methods
01:43:43 <adept> balkan: let take typeclass Ord. It consists of all types that could be compared (ordered).
01:43:58 <balkan> adept: go on...
01:47:05 <Si\> So you declare the types of all the methods available to ordered types
01:47:46 * adept . o O (damn. untimely network disconnect)
01:48:16 <balkan> if i wanted to be able to compare types i could just declare the (==) for that specific type. no need for a type class here.
01:48:56 <Si\> yes there is because without type-classes you cannot declare how particular types should be tested for equality
01:49:23 <balkan> can you give an example?
01:49:32 <adept> balkan: ok. so let's say you "just declared" (==) and (<) for several classes and wrote "quicksort :: [a]->[a]". ok?
01:49:50 <balkan> ok
01:50:19 <adept> balkan: then you called "quicksort list_of_some_type_that_does_not_have_equality_declared_for_it". What will happen, in your opinion?
01:50:31 <adept> balkan: runtime error? compile-time error? something else?
01:50:34 <balkan> compile time error.
01:51:00 <adept> balkan: why? type of quicksort is "[a]->[a]", which means that it sorts _any_ lists.
01:51:36 <adept> balkan: in order to constraint quicksort applicability to certain _class_ _of_ _type_ you need .. what? right! you need a typeclass :)
01:52:25 <adept> typeclass, by definition, is a way to describe a class of types by enumerating features (or functions) declared for them
01:52:32 <balkan> ok. i can see the beauty of this approach.
01:53:02 <Si\> plus they allow for modelling inheritance and other cool stuff :D
01:53:12 <balkan> but my approach is in fact used by many other languages.
01:53:41 <adept> balkan: and, unlike C++, instances of typeclass does not have to descend from common parent
01:54:16 <adept> balkan: yes, it is used by other langauges, and looks like it did not do them that many good :)
01:55:15 <balkan> adept: yes, the type system seems more developed in haskell.
01:55:22 <adept> balkan: if you take a closer look, you will find out that languages with ad-hoc overloading usually lack a usable type system
01:55:34 <Si\> and I wouldn't use C++, Java etc. as benchmarks for a type system, their type system design has many flaws
01:56:35 <balkan> well i wouldn't really compare java and c++.
01:57:05 <bourbak1> does someone know if there is a module out there that features graphs with homogenous data?
01:58:34 <balkan> adept: i see the elegance in haskells approach. but if you just want compile time safety. ad hoc overloading would do the job in my opinion.
01:59:09 <ibid> bourbak1: unline Data.Graph?
01:59:13 <ibid> unlike
02:00:15 <bourbak1> ibid: oh data graph can do that? let me describe what i want to have a little closer and you maybe tell me if i can do it with that graph
02:00:38 <bourbak1> i want to build graphs that have tokens these tokens can be of different types like a petrinet 
02:00:54 <bourbak1> and these types need to be dynamic in some sense that is
02:01:09 <bourbak1> i need to be able to merge two nodes of the network and get a new type 
02:01:31 <bourbak1> and still need to be able to access the types seperatly
02:01:37 <ibid> i don't follow
02:01:49 <bourbak1> you know what a petri net is?
02:01:58 <ibid> by name only
02:04:41 <bourbak1> its a graph that has nodes that can hold tokens
02:04:51 <adept> bourbak1: it's seems to me that this will be heterogenous data, not homodenous :)
02:04:55 <ibid> but Data.Graph should be able to handle homogenous data in graph (though i'm not sure that what you described is such a thing)
02:04:59 <bourbak1> and a process is done only when there are all required tokens
02:05:08 <bourbak1> and no on the outputside of that edge 
02:05:24 <bourbak1> adept: yes sry typo
02:06:00 <bourbak1> and what i need is that these tokens have types and that these types are not necessarily the same
02:06:04 <ibid> anyway, is there a reason why you cannot represent tokens as an algebraic type
02:06:32 <bourbak1> no the idea is to make the graph something like an array but also with connections
02:06:57 <ibid> i'm not following
02:07:02 <bourbak1> and i think its doable i did something like with arrows to achive that you can 
02:07:23 <bourbak1> .. i want to transfer tokens along the edges that are functions
02:07:24 <adept> bourbak1: actually google for "haskell petri net" turns up some meaningfull links ...
02:07:32 <bourbak1> yes
02:07:39 <bourbak1> the edges are functions
02:07:51 <bourbak1> and the nodes are data storages
02:08:04 <bourbak1> that way i can have concurrency
02:08:25 <bourbak1> and i need to be able to put two nodes together to "complie" the program
02:08:33 <adept> bourbak1: http://www.cs.kent.ac.uk/people/staff/cr3/HCPN/ ?
02:08:33 <bourbak1> to a single function useing arrows
02:09:27 <bourbak1> something like that yes
02:09:41 <bourbak1> but it needs to feature the functions of a graph
02:09:53 <bourbak1> so i can add nets together and the like
02:10:35 <bourbak1> oh heh but yes thats kind of what i want to do
02:10:53 <adept> bourbak1: does this mean that you've seen a link that I supplied?
02:10:54 <bourbak1> there are some new papers to read and but into the thesis then ;) and get new infos on pitfalls thanks
02:11:18 <bourbak1> yes actually i have but i didnt notice that its what i want to have :)
02:11:37 <bourbak1> i think with reading the code i might be able to figure out how to do it for my stuff maybe use that code
02:16:28 <adept> ok, i'll try to ask my question: what is a good way to "force" evaluation of MArray? I have code with is essentially a heavy numerical algorithm, which does a lot of "x <- readArray arr idx; writeArray arr idx (f (x))". Shortly, all array elements become a closures "linked" to "older" version of elements. I quickly run out of stack space. To prevent this, i do "e <- getElems arr; putStrLn $ show $ sum e" after each algo iteration, which forces evaluation o
02:18:56 <ibid> you're cut off at "forces evaluation o"
02:20:47 <adept> To prevent this, i do "e <- getElems arr; putStrLn $ show $ sum e" after each algo iteration, which forces evaluation of all array elements. This is kind of ugly. Anybody have better idea?
02:22:24 <adept> ibid: in other words, I (probably) want MArray to be strict in it's elemens
02:24:10 <ibid> which instance of MArray?
02:24:19 <ibid> and what are the elements?
02:25:24 <ibid> STUArray would probably work if it can be used in your context
02:25:45 <ibid> IOUArray too
04:32:32 <autrijus> yeah.
04:32:36 <autrijus> oops, mischan.
04:32:46 * autrijus idly watches ghc stage2 builds on aix scrolling by
04:32:59 <autrijus> it's 48th hour into this porting task.
04:35:32 <wolfman8k> i had to port this app to an sgi irix yesterday and by the end of the day when it finally compiled and ran it ran slow as shit :'(
04:36:51 <autrijus> is it affected by registerised/nonregisterisedness?
04:37:15 <autrijus> I'm building this because the only AIX binary I downloaded is stage1
04:37:20 <autrijus> and my code uses THaskell
04:37:58 <wolfman8k> it's not haskell
04:38:09 <autrijus> oh. sorry
04:39:24 <wolfman8k> and after hearing about your troubles, i'm apparently lucky that it is not :)
04:39:45 <autrijus> :)
05:15:12 <shapr> how do I force overwriting with apt-get?
05:16:08 <shapr> aha, use dpkg
05:17:02 <Lemmih> Greetings, shapr.
05:17:10 <shapr> y0 Lemmih, wazzup?
05:17:46 <shapr> Zope is my greatest example of OOP done badly.
05:17:58 * Lemmih is now 18 years, 5 hours and 20 minutes old.
05:18:15 <shapr> happy birthday Lemmih!
05:18:34 <Lemmih> Thanks.
05:18:46 <Maddas> Happy birthday indeed :-)
05:18:59 <rtega> happy birth Lemmih 
05:19:20 <Lemmih> (:
05:22:20 <Lemmih> My childhood was a lot shorter than I had hoped.
05:23:00 <shapr> heh
05:23:06 <shapr> I know that feeling.
05:26:27 <wolfman8k> you can still choose to be a child at heart
05:27:57 <xerox> hello!
05:28:07 <Lemmih> Hallo, xerox.
05:50:16 <musasabi> shapr: --reinstall ?
05:51:22 <shapr> nah, dpkg --force-overwrite -i <name>.deb
06:00:45 <marcot> Hello.
06:00:53 <Lemmih> Greetings, marcot.
06:00:58 <marcot> I'm having an error in ghc that I can't understand very well.
06:01:13 <marcot> the code is - 2 lines:
06:01:21 <marcot> liftQ :: TDBs d o t => (Snapshot o t -> x) -> d o t -> x
06:01:28 <marcot> liftQ f = f . head . getSnapshots
06:01:40 <marcot> The TDBs d o t  is needed because of getSnapshots.
06:01:47 <marcot> But ghc gives me this error:
06:02:07 <marcot> All of the type variables in the constraint `TDBs d o t' are already in scope
06:02:15 <marcot> (at least one must be universally quantified here)
06:02:38 <marcot> In the type: forall x.  TDBs d o t => (Snapshot o t -> x) -> d o t -> x
06:02:46 <marcot> While checking the type signature for `liftQ'
06:03:43 <Lemmih> Guess he figured it out by himself.
06:04:29 <marcot> Sorry..
06:04:33 <marcot> mozilla crashed here.
06:04:40 <marcot> But that's the error.
06:04:47 <marcot> When I change the type to something like:
06:05:06 <marcot> liftQ :: TDBs d o t => (Snapshot o t -> t) -> d o t -> t
06:05:09 <marcot> It works.
06:05:31 <marcot> I've just changed from x - general - to t .
06:06:17 <marcot> Why is this happening, if the second function is just something that's applied in the end, and do not change the behaviour of the rest of the code?
06:07:25 <autrijus> it works!
06:07:26 <marcot> In hugs I don't have this problem.
06:07:31 <Darius> marcot: I've never seen that error.
06:07:33 * autrijus has a working AIX ghc 6.2.2 stage2 now
06:07:50 <balkan> anyone know were the latest version of the haskell report is at?
06:07:55 <marcot> Darius: ok...
06:08:10 <Darius> marcot: What's the first line of the TDBs class declaration?
06:08:29 <autrijus> balkan: http://www.haskell.org/onlinereport/ ?
06:08:36 <autrijus> and http://www.haskell.org/definition/
06:08:41 <Lemmih> What about omitting the type signature and letting GHC figure it out?
06:08:50 <balkan> autrijus: thx
06:09:10 <marcot> Lemmih: let me try that here.
06:10:03 <marcot> Database.hs:90: Variable not in scope: `liftQ'
06:10:37 <marcot> Lemmih: maybe that happened because I'm in a class definition.
06:11:27 <Darius> liftQ is a method of a class?
06:11:35 <marcot> Darius: yes.
06:11:47 <Lemmih> marcot: That shouldn't matter.
06:12:05 <marcot> Strange..
06:12:07 <Lemmih> @type show
06:12:13 <lambdabot> show :: forall a. (Show a) => a -> String
06:12:42 <Darius> Lemmih: It does matter and would've been useful information to begin with.
06:14:24 <Lemmih> Darius: The function should still be in scope even if it's a method of a type class.
06:14:50 <Darius> marcot: I don't believe in Standard Haskell you can have a method with a type like foo :: (AnotherClass a) => x -> y
06:15:35 <ibid> sounds like a useless constraint in any case
06:18:06 <Darius> Lemmih: well, one issue is he has to give the type of the class method if he is to declare it in a class
06:20:25 <autrijus> :-/
06:20:25 <autrijus> ghc-6.2.2: internal error: loadObj: not implemented on this platform
06:20:26 <Lemmih> Darius: Indeed. But then he would have gotten a different error message.
06:20:32 <autrijus> do I need to make stage3?
06:21:56 <xerox> Hm!
06:22:23 <xerox> A question, I have a list of triples like, how can I order those upon the first memeber?
06:22:28 <Darius> Lemmih: If he omitted liftQ from the class declaration and then tried to do, say ':t liftQ' he would've gotten exatly that error.
06:24:02 <TheHunter> xerox, http://www.haskell.org/hawiki/LicensedPreludeExts, look for comparing.
06:24:03 <Lemmih> Darius: You shouldn't be able to compile a class with a defaulted method without a type signature.
06:24:24 <Cale> xerox: sort should do that
06:24:36 <Cale> It's in the list module
06:24:47 <Darius> Cale: sort would do more than that though
06:25:01 <Cale> ah, okay
06:25:25 <xerox> Thanks both
06:25:30 <Cale> yeah, if you just want the first member, use sortBy (comparing (\(x,y,z) -> x))
06:25:40 <Darius> Lemmih: That's not the scenario I was describing, the scenario I was describing is somewhat ridiculous.
06:25:43 <xerox> Cale, I was having problem inputting something to samples, then I found your trick ;)
06:26:24 <Cale> xerox: there are some type casting issues there, and I wanted to finish it before you had to go :)
06:27:14 <Lemmih> Isn't 'liftQ' a method which defaults to '\f -> f . head . getSnapshots'?
06:28:36 <Lemmih> marcot: What are you working on?
06:30:26 <xerox> Cale, eheh thank you again
06:30:53 <xerox> Cale, Is it possible to input data in sample, without explicitly putting the type in the .hs ?
06:31:03 <xerox> Cale, to do some test "on the fly"
06:31:25 <Cale> yeah, just passing literals really should work
06:31:57 <xerox> Cale, yep, naming with let doesn't work
06:32:10 <xerox> It gets [(Integer,Integer,Integer)]
06:33:16 <Cale> really, what we ought to do is fix the type of samples so it's a bit saner
06:34:55 <xerox> hm
06:50:17 <xerox> Cale, any clue?
06:50:28 <Cale> yeah :) check pm
06:50:33 <xerox> whoops :)
06:51:07 <wolfman8k> shit this matrix shit is killing me
06:52:08 <Itkovian> anybody in the mood to give a little hand compiling yi?
06:52:26 <Itkovian> wolfman8k the matrix has you?
06:52:37 <wolfman8k> affirmative
06:54:21 <Itkovian> poor man
06:54:50 <Itkovian> when I configure ... all seems well, when I start compiling ...
06:55:10 <Itkovian> the hsc2hs stuffis ok, but the first ghc command fails with (among others) Boot.hs:171: Variable not in scope: `makeAll'
06:55:13 <Itkovian> eek?
06:55:45 <Itkovian> is my installation missing certain important stuff, do I need ghc 6.3 for this as well?
07:10:04 <Cale> wolfman8k: working on the raytracer?
07:10:51 <wolfman8k> Cale: no, something else
07:11:21 <Cale> there's a free book on linear algebra here: http://joshua.smcvt.edu/linearalgebra/
07:11:45 <wolfman8k> thanks
07:36:17 <autrijus> hey
07:36:21 <autrijus> my prog needs -fcontext-stack60 to run
07:36:32 <autrijus> is it somehow possible to set it in env or in source file?
07:39:46 <Darius> {-# OPTIONS -fcontext-stack60 #-}
07:40:40 <Darius> autrijus: Just curious, but what are you doing that requires a (presumably) relatively large context stack?
07:41:14 <autrijus>     unknown flags in  {-# OPTIONS #-} pragma: -fcontext-stack60
07:41:34 <autrijus> Darius: as I said, I'm using records that has up to 40 named fields
07:46:12 <Darius> Unless you are using Hugs, having that at the top of your source file should work.
07:46:22 <Darius> (or NHC)
07:46:53 <marcot> Sorry, I was lunching.
07:47:53 <autrijus> I'm using ghc.
07:47:57 <Darius> autrijus: But why would a (normal Haskell) record have anything to do with the context stack?
07:48:00 <autrijus> 6.2.2, freebsd.
07:48:18 <autrijus> Darius: that may be that I'm instanciating them as Binary instances
07:48:29 <autrijus> and thus will need to implement their get and put_
07:48:40 <autrijus> which will require currying and uncurrying the 40 element
07:48:57 <autrijus> into ((((f1,(f2,(f3,(f4,(f5))))) etc
07:48:57 <marcot> My problem persists... I think that this could maybe even be a ghc bug.
07:49:10 <marcot> Cause it's having a very strange behaviour.
07:49:17 <autrijus> I did it using a reasonably clever THaskell macro.
07:49:54 <autrijus> of course I could probably also implement it using separate get() calls
07:50:08 <autrijus> if the context stack proves to be a large performance setback
07:50:11 <Darius> autrijus: http://www.haskell.org/ghc/docs/latest/html/users_guide/using-ghc.html#SOURCE-FILE-OPTIONS is the documentation on the OPTIONS pragma
07:50:15 <autrijus> looks okay though.
07:56:06 <xerox> foldr1 uses 1 as "second argument of foldr" or just skips it?
07:56:23 <Darius> foldr1 only works on non-empty lists
07:56:48 <Darius> I guess the 1 is for 1 or more elements.
07:56:53 <adept> xerox: it uses "head" as second arg of foldr
07:57:12 <Darius> marcot: You still haven't provided the whole declaration for the class.
07:57:52 <xerox> adept, hmm?
07:58:56 <Darius> foldr1 c (x:xs) = foldr c x xs
07:59:14 <adept> xerox: imo, foldr1 op (l:lst) = foldr op l lst
07:59:30 <xerox> ah! thanks.
08:00:55 <Darius> Actually, it doesn't, that's foldl1's definition (only with foldl instead of foldr).
08:01:21 <marcot_> Darius: I'll try to put it somewhere..
08:01:31 <Darius> @wiki HaskellIrcPastePage
08:01:31 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:01:52 <Darius> xerox: But the idea is the same, just the other way around.
08:02:27 <marcot_> Darius: thanks.
08:04:09 <xerox> hello TheHunter
08:04:13 <marcot_> Darius: it's there.
08:04:37 <marcot_> Now I've changed it a little bit, but I have the same problem.
08:05:54 <marcot_> Darius: what a strange thing. when I change the type, it works fine.
08:06:08 <TheHunter> hey xerox 
08:07:50 <marcot_> And when I put this method out of the class it also work fine.
08:08:55 <Darius> marcot: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#MULTI-PARAM-TYPE-CLASSES (see section 7.4.3.1)
08:11:59 <Darius> marcot: Raising the constraint to a superclass constraint is probably the thing to do.
08:12:23 <autrijus> ugh. it was because of XCOFF.
08:12:28 <autrijus> ghc doesn't have xcoff loader.
08:12:58 <bourbaki> moin
08:14:42 <marcot_> Darius: sorry, I didn't understando all of it.
08:14:52 <marcot_> Darius: is constraint -> x ?
08:16:58 <marcot_> Darius: what's a superclass constanint?
08:17:05 <Darius> Have class (TDBs d o t, Snapshots d o t) => Databases d o t instead of what you have currently and remove the uses of 'TDBs d o t =>'
08:17:05 <marcot_> constraint?
08:18:34 <marcot_> Why do I need Snapshots d o t there?
08:19:30 <marcot_> With     liftQ :: forall d o t x. (TDBs d o t)  => (Snapshot o t -> x) -> d o t -> x it works.
08:20:22 <marcot_> liftQ :: forall d o t x. (Databases d o t, TDBs d o t)  => (Snapshot o t -> x) -> d o t -> x
08:20:26 <marcot_> This also works.
08:20:33 <Darius> marcot_: I don't know why you need Snapshots d o t there, it's what you had there before.
08:20:43 <marcot_> but what's the difference between that and..
08:20:46 <autrijus> hmm. so failing dynamic linker
08:20:59 <autrijus> can I somehow let ghc output the after-macro-splicing source?
08:21:06 <marcot_> liftQ :: forall x. TDBs d o t => (Snapshot o t -> x) -> d o t -> x
08:21:07 <autrijus> preferably as another .hs
08:21:23 <Darius> autrijus: You should be able to, but I've forgotten how.
08:21:57 <marcot_> What's the difference between these last two?
08:22:46 <Darius> marcot_: If you have the forall's explicitly in the source, than the once quantifying d, o, and t are shadowing the type class variables.
08:23:27 <marcot_> Darius: but when I say Databases d o t in the context, I'm saying it again.
08:23:31 <marcot_> Isn't it the same?
08:24:37 <Darius> marcot_: With the explicit foralls over d o t, those methods don't use any of the variables bound by the type class, i.e. they are independent of the instantiations.
08:25:23 <marcot_> Darius: but if I do Databases d o t, I'm saying that this method needs an instance of Databases for the types d o t.
08:25:39 <marcot_> Darius: So, in both cases, there must be an instance of Databases d o t.
08:29:14 <marcot_> Darius: no?
08:29:16 <Darius> marcot_: The d o and t are -different- than the class variables.  With the version quantifying d o and t, liftQ just needs its argument to be -anything- that is in Database, without the quantification it (well doesn't make much sense but it) requires the instance being defined.
08:31:51 <marcot_> b
08:31:54 <marcot_> sorry.
08:33:14 <Darius> When you instantiate the class to say A B C, with the quantifying definition, liftQ will have type forall d o t x.(Databases d o t,TDBs d o t) => (Snapshot o t -> x) -> d o t -> x, which doesn't mention A, B, or C at all. 
08:33:52 <Darius> Without the quantification you'd get, liftQ :: forall x. TDBS A B C => (Snapshot B C -> x) -> A B C -> x
08:34:06 <Darius> but TDBS A B C doesn't make sense.
08:34:12 <Darius> (as a constraint)
08:34:23 <marcot_> why?
08:34:39 <Darius> marcot_: Because it's not constraining anything.
08:34:46 <marcot_> What's the difference between TDBs a b c and Eq a?
08:35:14 <Darius> marcot_: Eq Int => ... is the same problem
08:35:35 <marcot_> Darius: But a b c is generic.
08:35:40 <Darius> marcot_: A B C are concrete types not type variables.
08:35:59 <marcot_> Darius: hum..
08:36:52 <Darius> When you do 'instance Eq Int where ...' you replace all the a's in 'class Eq a where (==) :: a -> a -> Bool; ...' with Int.
08:37:19 <marcot_> Darius: this I know.
08:37:37 <marcot_> Darius: but I thought that in the class definition I could have something like this...
08:37:47 <Darius> I was using A B C as concrete types for a hypothetical, instance Databases A B C
08:39:29 <marcot_> class Zeros a where
08:39:32 <marcot_>     isZero :: Eq a => a -> Bool
08:39:36 <marcot_>     isZero = (== zero)
08:39:44 <marcot_>     zero :: a
08:39:53 <marcot_> Isn't this the same situation?
08:40:03 <bourbaki> if someone wants to see my game :) codemages.sf.net/CompiledEffect.exe, codemages.sf.net/CompiledEffect.fxo
08:40:22 <marcot_> When I do an instance, this will be Eq Int, for example of instance Zeros Int
08:41:14 <marcot_> Darius: And here this code works ok!
08:41:26 <Oejet> musasabi: Are you here?
08:42:27 <marcot_> Darius: aren't the situations just the same?
08:47:01 <Darius> marcot_: Well, to begin, standard Haskell doesn't allow that situation.  They seem similar superficially, but I'd have to think about the consequences with multi-parameter type classes.  At any rate, either can just lift the constraint up to a class constraint.
08:48:43 <marcot_> Darius: This I can't.
08:48:52 <marcot_> Darius: I think I'll put these functions out of the class.
08:50:15 <Darius> Why can't you lift the constraint to a class constraint?  It essentially says the same thing.
08:50:15 <Darius> Of course, it may be that the constraint is unnecessary anyways.
08:50:55 <marcot_> Darius: because there's an instance of this class that is not an instance of TDBs.
08:51:12 <marcot_> Darius: so I cannot put the TDBs d o t as a context of the whole class.
08:51:24 <marcot_> Darius: but I still don't understand why this is not working.
08:51:31 <Darius> Then how were you intending on defining liftQ? (Also, it looks as if it is unnecessary assuming getSnapshots isn't in it)
08:52:13 <marcot_> getSnapshots is in liftQ.
08:52:29 <Darius> I was wondering which -class- it was a method of.
08:53:29 <Darius> If getSnapshots isn't in TDBs there is no reason to have the constraint on liftQ' and therefore no reason to have the constraint on liftQ.
08:53:52 <MegaMonad> Musasabi: you're welcome.
08:54:49 <marcot_> getSnapshots is in TDBs.
08:55:34 <marcot_> Darius: that's why I must put it there.
08:55:37 <Darius> Of course, if you can define liftQ(') without using other methods of Databases, then, except for optimizing purposes (or, but this is ugly, if the default method is not always correct).
08:55:50 <Darius> you might as well take them out of the class.
08:56:21 <marcot_> Darius: ok.
08:56:28 <marcot_> I think it's a good idea too.
08:56:31 <Darius> marcot_: If you wanted to keep them in the class you could simply omit the default definition of liftQ' and the constraint on liftQ(') and it would work.
08:56:49 <musasabi> Oejet: pong.
08:57:09 <Darius> (well, "should work")
09:06:06 <pyoko> where's the wiki at again?
09:06:15 <marcot_> Darius: hum.. but I still don't get the difference between this and that Zeros example.
09:06:30 <musasabi> @wiki RecentChanges
09:06:30 <lambdabot> http://www.haskell.org/hawiki/RecentChanges
09:06:35 <marcot_> Darius: what implies that I don't understand why ghc is not accepting that.
09:06:53 <marcot_> Darius: cause Hugs accepts it.
09:07:13 <Darius> marcot_: I'm playing with (simplified) variations of the problem and GHC accepts all the examples I've given it so far.
09:07:33 <Darius> marcot_: GHC may be stricter about certain things, this is not a standardized area.
09:07:49 <marcot_> Darius: I'll do it too.
09:07:55 <marcot_> Darius: ok.
09:10:04 <Darius> Well I think I've figured out the "problem" or at least I have a simple example which illustrates it.
09:10:45 <Darius> The difference between Hugs and GHC likely boils down to the topic in section 7.4.3.1 in the User Guide that I mentioned before.
09:16:03 <autrijus> hey
09:16:08 <autrijus> AIX doesn't like hugs C files.
09:16:12 <autrijus> namely, one iwht lines > 65k
09:16:23 <autrijus> even with -O0 it ghc still produces such a big file
09:16:31 <CosmicRay> how did you manage to make hugs work on aix?
09:16:33 <autrijus> is there a way to instruct ghc to split its c files or something?
09:16:45 <CosmicRay> which compiler are you using?
09:16:49 <CosmicRay> and are you on power64?
09:16:57 <Igloo> hugs or ghc?
09:16:59 <autrijus> I did not; I did ghc stage3.
09:17:09 <autrijus> I don't know anything about hugs.
09:17:14 <CosmicRay> <autrijus> AIX doesn't like hugs C files.
09:17:19 <autrijus> huge.
09:17:21 <autrijus> typo.
09:17:23 <xerox> How does something like this work?: samples bs = do { (l,h,r) <- bs; x <- [l,r]; if .... }
09:17:23 <CosmicRay> ah.
09:17:24 <Igloo> ah, heh
09:17:25 <CosmicRay> which compiler?
09:17:30 <autrijus> gcc 333
09:17:33 <CosmicRay> hm.
09:17:35 <CosmicRay> same here
09:17:39 <CosmicRay> which version of aix?
09:17:40 <autrijus> c/738: The displacement must be greater than or equal to -32768
09:17:45 <autrijus> 5.2l
09:17:47 <xerox> I mean, what does <- do in this case?
09:17:48 <CosmicRay> hm.
09:17:51 <CosmicRay> 5.1 here.
09:17:55 <CosmicRay> that doesn't sound like a gcc error message
09:17:57 <musasabi> autrijus: that sounds like a gcc problem..
09:17:59 <autrijus> it's the assembler.
09:18:01 <CosmicRay> are you sure that it's actually...
09:18:02 <CosmicRay> ahh.
09:18:05 <musasabi> ahh.
09:18:08 <autrijus> /bin/as
09:18:10 <CosmicRay> that doesn't sound like gnu binutils then.
09:18:21 <Igloo> What CPU is this?
09:18:22 <musasabi> autrijus: can you the GNU assembler?
09:18:23 <autrijus> gnu has as for aix?
09:18:35 <CosmicRay> autrijus: btw, have you looked at: http://gopher.quux.org:70/devel/AIX/ghc
09:18:41 <autrijus> yes.
09:18:51 <CosmicRay> autrijus: yes
09:18:55 <autrijus> but I can't get loadobj to run.
09:19:01 <CosmicRay> /usr/local/bin$ as --version
09:19:02 <CosmicRay> GNU assembler 2.14 20030612
09:19:11 <CosmicRay> what's that?
09:19:17 <autrijus> ghci.
09:19:20 <CosmicRay> ah.
09:19:37 <CosmicRay> you will have to write coff support for ghci before it will work.
09:19:41 <CosmicRay> ghci is not working here
09:20:23 <autrijus> it's xcoff here.
09:20:25 <autrijus> okay. I'm willing to do that
09:20:32 <CosmicRay> that would be Really Awesome.
09:20:32 <autrijus> just hack Loader.*?
09:20:37 <CosmicRay> I lack the expertise to do that
09:20:48 <CosmicRay> I don't recall exactly, but that sounds approximately right
09:22:43 <Darius> xerox: It translates to the >>= for the [a] instance of Monad which is concatMap.  So in effect it works like a similar looking list comprehension.
09:23:21 <xerox> Darius, can you show me the >>= and concatMap version? I think it's more understandable for me
09:23:21 * shapr bites lambdabot on the ankle
09:23:48 <xerox> poor lambdabot :(
09:24:05 <lambdabot> It's just a flesh wound!
09:24:11 <xerox> Darius, I'll show you the complete code
09:24:46 <Darius> >>= = concatMap for the [a] instance of Monad, the code using >>= is just the standard translation for any monad, samples bs = bs >>= \(l,h,r) -> [l,r] >>= \x -> if ...
09:25:51 <CosmicRay> MegaMonad: I bet you could patch up lambdabot.
09:25:52 <MegaMonad> CosmicRay: But when i get you a patch.
09:26:01 <CosmicRay> MegaMonad: do you have any bandages or anything?
09:26:02 <MegaMonad> CosmicRay: I heard about the sort that out in the log for hop. We'll see if we're going to email me if i don't have any bandages or anything?
09:26:49 <xerox> Darius, hm, thanks, It's diffincult in any case eheh
09:27:18 <xerox> @type (>>=)
09:27:21 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
09:27:26 <shapr> MegaMonad: agent goerzen?
09:27:27 <bourbaki> @seen boegel
09:27:27 <MegaMonad> shapr: Xah lee has something to do this in a nutshell' by john goerzen.
09:27:27 <lambdabot> I saw boegel leaving #Haskell 2 days 18 hours 17 minutes 46 seconds ago
09:27:40 <CosmicRay> hey shapr :-)
09:27:43 * shapr grins
09:27:43 <CosmicRay> shapr: you need a blog.
09:27:46 <shapr> I've got one.
09:27:49 <CosmicRay> oh.
09:28:11 <Darius> shapr, I'm pretty sure you have more than one.
09:28:12 <CosmicRay> shapr: so is it english, work, fun, random, about, or svenska? :-)
09:28:16 <shapr> CosmicRay: http://www.scannedinavian.com/
09:28:33 <CosmicRay> shapr: yes, I did get that far :-)
09:28:42 <shapr> Darius: yeah, I should rip all my entries off LJ and archive them.
09:29:15 <shapr> CosmicRay: nah, you're looking at dot org
09:29:36 <CosmicRay> ah.
09:29:37 <CosmicRay> imagine that.
09:30:20 * CosmicRay adds this rss feed and link his blog
09:30:31 <shapr> I have several entries I've not sync'd yet.
09:30:40 <CosmicRay> what's the deal with haskellers having comments disabled in their blogs? :-)
09:30:59 <shapr> they're immutable entries =)
09:31:11 <shapr> greetinsg humasect 
09:31:12 <CosmicRay> shapr: drupal.org :-)
09:31:34 <shapr> Actually, my blog uses Haskell too. So does scannedinavian.org
09:31:58 <shapr> but dot org was a fast ugly hack of the standard Halipeto site. I want to look at stepcut's site sources.
09:35:58 * shapr updates his blog
09:37:07 * CosmicRay presses reload
09:37:22 <shapr> look CosmicRay is mentioned in my blog!
09:37:26 * shapr bounces
09:37:34 <shapr> Darius: if you ever get a blog ... :-)
09:37:42 <CosmicRay> :-)
09:38:54 <shapr> CosmicRay: you can click on the small images to get larger versions.
09:40:14 <CosmicRay> shapr: so, does MissingH fall into code you've written, code you don't understand, or code that needs fixing? :-)
09:40:20 <CosmicRay> I have a pretty good hunch which it is :-)
09:41:10 <shapr> I haven't read through it myself, but I'm pretty sure it fits into code I would have written myself.
09:41:34 <CosmicRay> heh
09:41:59 <CosmicRay> that's not where I expected it would go :-)
09:42:02 <shapr> really?
09:42:17 <CosmicRay> well, considering I'm pretty much a haskell newbie, I'd expect it's code that needs fixing
09:42:45 <shapr> The point of MissingH is to fill in the cracks, trying to make a nice flat foundation to build on.
09:42:51 <CosmicRay> yup
09:43:31 <CosmicRay> shapr: your rss doesn't parse (mismatched tag on line 7)
09:44:14 <CosmicRay> err
09:44:17 <CosmicRay> ignore me, I'm an idiot.
09:44:19 <CosmicRay> pasted the wrong link.
09:45:30 <CosmicRay> ok it works now but it's not the most useful
09:45:37 <CosmicRay> everything says "day's entry" and that's it
09:45:53 <shapr> The point I'm trying to make is that the value of library code is 1. that you can understand it well enough to use it or immediately modify it for your purposes, or 2. it's extremely fast, don't expect to understand or modify it at all
09:46:25 <shapr> or 3. It's J2EE, duplication abounds, and all the pieces are almost compatible with each other
09:46:36 <CosmicRay> haha
09:47:46 <shapr> I learned J2EE by reading descriptions of the libraries first, and I immediately assumed that several of the pieces were just different interfaces to the same code. Sadly, they were reimplementations.
09:49:34 <shapr> Anyway, I've decided that I always prefer library code I can understand, because I value the ability to modify anything.
10:04:34 <autrijus> will my binary ghc-6.2.2/ be of interest to anyone?
10:04:38 <autrijus> on aix.
10:18:19 <shapr> probably to CosmicRay 
10:19:20 <musasabi> Doing an Array of TVars is too slow for anything.
10:20:07 <musasabi> Maybe I should just go the tree route.
10:26:11 <CosmicRay> autrijus: I am quite interested
10:26:27 <autrijus> CosmicRay: so do I just tar the produced /usr/local/lib/ghc-6.2.2 ?
10:26:37 <CosmicRay> autrijus: no... let me get the command...
10:27:02 <CosmicRay> autrijus: make binary-dist in your source tree
10:27:06 <autrijus> ok.
10:27:20 <CosmicRay> autrijus: that will generate something that is also suitable for posting on haskell.org/ghc
10:27:35 <autrijus> roger.
10:27:54 <CosmicRay> autrijus: I'm curious: did you bootstrap this yourself or did you use my 6.2.1 package to get started?
10:28:14 <autrijus> I used your 6.2.1.
10:28:20 <autrijus> and did stage3 just for fun :)
10:28:48 <CosmicRay> heh, well I'm glad it was useful.  I was begnining to think that I was the only one out there using haskell on aix5
10:29:15 <autrijus> actually your build was the reason why I'm hacking haskell now :)
10:29:24 <autrijus> instead of merely playing with it
10:29:30 <Igloo> When you were talking about making a tarball available I was thinking "Does no harm, but no-one's ever going to use it"  :-)
10:29:47 <autrijus> $client uses aix and is willing to fund me working with haskell on aix
10:30:39 <CosmicRay> Igloo: heh
10:30:40 <autrijus> I replaced the TH Macro.hs I spent 2 hours on with a simple perl script I came up in 20 minutes. :-/
10:31:04 <autrijus> since no ghci == no TH
10:31:10 <CosmicRay> ah
10:33:01 <autrijus> so I need to deploy the product on thursday, which is 3 days from now; if it works well I may have time to work on COFF
10:33:08 <Igloo> It might be useful if you sent a message to the template-haskell list saying that lack of portability forced you to give up on it
10:33:28 <autrijus> Igloo: but I don't think it's TH's problem, really.
10:33:34 <autrijus> no dynamic loading of libraries is really bad.
10:34:10 <Igloo> autrijus: Yes, but I want it fixed, and the more voices there are the sooner it will happen
10:34:31 <autrijus> you want what fixed?
10:34:46 <autrijus> to make TH not relying on dyld?
10:35:15 <Igloo> Lack of portability of TH (I don't care about the technical side of the solution used)
10:35:33 <autrijus> ahh.
10:37:23 <Igloo> What's the difference between .s and .S files?
10:38:34 <CosmicRay> Igloo: afaik, capitalization.
10:38:43 <musasabi> Asm+Cpp and Asm without cpp (don't remember which way though)
10:38:55 <CosmicRay> hm, ok so I stand corrected.
10:38:59 <Igloo> ah, ta
10:39:07 <CosmicRay> I have never quite been able to wrap my head around why th requires ghci
10:39:25 <CosmicRay> camlp4 can be run as a straight pre-processor, spitting out ocaml (or scheme, or whatever) code out the back end
10:39:35 <CosmicRay> I haven't understood why th can't be that also
10:40:07 <Igloo> It compiles the TH code to bytecode, which is executed in the same way as ghci executes code
10:40:13 <autrijus> yup.
10:40:33 <autrijus> I thought it was for type safety or something.
10:40:41 <CosmicRay> why couldn't it spit out haskell on its backend?
10:41:00 <autrijus> because ghc does not have eval()? 
10:41:07 <autrijus> -- just a wild guess
10:41:14 <Igloo> TH code can reify earlier structures
10:41:27 <Igloo> So you really want to be inside the compiler
10:41:51 <autrijus> Mechanical and super-natty! Inspect the result and *if* happy; freeze, sell and get some sleep!
10:41:54 <CosmicRay> so th is mucking with the type system to such an extent that it is impossible (or, at least, impractical) to express its output in ordinary haskell?
10:41:54 <autrijus> ...
10:42:26 <Igloo> It could output ordinary Haskell
10:42:35 <Igloo> The problem is in generating that ordinary Haskell
10:42:47 <stepcut> th is actually evaluating haskell code at compile time, whereas camlp4 is just rearranging syntax (or something like that ...)
10:43:05 <CosmicRay> so TH is something of an interpreter?
10:43:17 <CosmicRay> of a language that happens to mostly resemble haskell?
10:43:33 <musasabi> of a language that is haskell.
10:43:40 <CosmicRay> hm.
10:44:43 <CosmicRay> in that case, I'm back to the original question, of why it couldn't be compiled.
10:44:44 <shapr> I had the crazy idea to use that for dynamic loading. You would run your entire program inside "ghc --make"
10:44:44 <CosmicRay> sigh.
10:44:53 <CosmicRay> heh
10:45:30 <musasabi> Anyone having looked at STM more?
10:45:44 <Igloo> In TH, at compile time, you can say "foo <- reify 'Maybe". foo is then an abstract syntax tree representing "data Maybe a = Just a | Nothing"
10:46:04 <Igloo> It's easier to do that when you are interpreting it in the compiler than when it is compiled to a standalone program
10:46:44 <CosmicRay> Igloo: ack on the first part....  I assume then that one would manipulate foo in various ways.  But there's already code in fptools to generate valid haskell code out of the ast....
10:47:18 <CosmicRay> couldn't it use that to spit out whatever foo turns out to be?
10:47:19 <musasabi> I am trying to find out an efficient concurrent map like structure that can be implemented with it - and it seems quite challenging.
10:52:28 <shapr> CosmicRay: what about - foo <- reify "Just" ; foo Nothing
10:52:59 <autrijus> hey.
10:53:01 <shapr> I don't remember the TH syntax... but if the result of some TH code will generate the code in the next step
10:53:01 <autrijus> CosmicRay: http://openafp.org/ghc-6.2.2-powerpc-ibm-aix-bindist.tar.gz
10:53:19 <autrijus> CosmicRay: feel free to arrange with powers that be to have it posted on the website
10:55:40 <autrijus> finally installed the gnu toolchain. retrying --make...
10:56:20 <CosmicRay> autrijus: sweet
10:56:25 * CosmicRay starts downloading
10:56:48 <autrijus> CosmicRay++ # thanks for the heroic stage0
10:57:00 <CosmicRay> autrijus: glad to help
10:57:09 <CosmicRay> autrijus: btw did you need to apply my patch to ancilData?
10:57:14 <autrijus> no, it just worked
10:57:21 <autrijus> I had to disable pthread though
10:57:46 <autrijus> CosmicRay: if you happen to come to Taiwan some day I'll buy you beer :)
10:58:09 <CosmicRay> autrijus: thanks, I'll try to do that :-)
11:04:03 <autrijus> /tmp/ghc12652.s:575301: Error: operand out of range (0000000000008acc not between -32768 and 32767)
11:04:45 <autrijus> this is I believe with gnu as.
11:04:48 <CosmicRay> autrijus: did that occur in gmp?
11:04:49 <CosmicRay> hm.
11:04:55 <autrijus> it's in
11:04:56 <autrijus>  25412  pts/0 A     0:46 as -u -mppc -o ./OpenAFP/Data/AFP.o /tmp/ghc12652.s
11:05:05 <CosmicRay> is -mppc correct?
11:05:09 <autrijus> it is.
11:05:11 <CosmicRay> are you making a 32-bit build then?
11:05:15 <autrijus> I'll probably try to reduce AFP.hs's size.
11:05:17 <autrijus> yes.
11:05:20 <CosmicRay> hm.
11:05:28 <CosmicRay> that is new ground for me.  I made a 64-bit build
11:05:41 <CosmicRay> err, no I didn't.
11:05:45 <autrijus> you did not.
11:05:47 <autrijus> :)
11:05:49 <CosmicRay> I used -mpowerpc -maix32 -mminimal-toc
11:05:56 <autrijus> nod. 
11:06:02 <autrijus> -mppc == -mpower-pc I think
11:06:31 <CosmicRay> not necessarily
11:06:33 <CosmicRay> I'll check
11:06:49 <autrijus> oh and it's for "as"
11:06:53 <autrijus> the -mppc I mean
11:07:02 <CosmicRay> right
11:08:36 <CosmicRay> looks like -mppc is equiv to -mppc32 -m603 or -m604 for as, so I guess that's correct.
11:08:36 <CosmicRay> hm.
11:08:45 <autrijus> hm.
11:09:29 <musasabi> Does ghc(i) work on alpha?
11:09:40 * CosmicRay checks
11:09:45 <CosmicRay> ghc yes
11:09:59 <CosmicRay> ghci no
11:10:19 <musasabi> What is making GHCI unportable?
11:10:32 <CosmicRay> dynamic linking iirc
11:11:17 <musasabi> why not use the OS dl* for that on *nix ?
11:11:23 <CosmicRay> I don't know.
11:11:25 <CosmicRay> I have wondered that myself.
11:12:10 <CosmicRay> I should state that those answers were for linux on alpha
11:12:13 <CosmicRay> I don't know about tru64
11:12:48 <musasabi> I am thinking NetBSD - although I have an account on a Tru64 alpha too.
11:13:04 <CosmicRay> I would imagine netbsd would be in approximately the same condition as linux
11:13:24 <CosmicRay> I don't know if anyone has taken the time to make a netbsd port of it
11:13:28 <CosmicRay> though if not it shouldn't be that hard
11:14:14 <musasabi> true
11:15:52 <CosmicRay> I think even fewer people care bout tru64 than aix :-)
11:22:52 <xerox> Cale, hi! :)
12:09:05 <Oejet> musasabi: I have thought about the hash table insert with STM problem.  Thought of no solution though.
12:16:53 <musasabi> Oejet: thanks, I haven't found anything good either...
12:17:17 <musasabi> but maybe one should just consentrate on tree structures..
12:27:23 <Oejet> musasabi: Well, in a hash table a small konstant factor is what matters.  How slow is the array solution?
12:50:45 <autrijus> yay. after splitting out a .hs into 130 small .hs files my program finally compiled on aix
13:06:31 <bourbaki> moin
13:08:11 <basti_> huhu b
13:08:27 <bourbaki> grandmaster b ;)
13:08:45 <Nioate> hi
13:08:50 <basti_> can you find a rhyme on thyme?
13:09:17 <bourbaki> what does thyme mean :)?
13:10:05 <bourbaki> but time would do
13:10:08 <basti_> thymian
13:10:22 <bourbaki> ah
13:10:28 <basti_> are you going to scarborough fair, parsley sage rosmary and thyme
13:13:44 <bourbaki> basti_: got a gfx board that can do pixel shader 1.1? and dx 9c dec2004 sdk?
13:14:17 <basti_> directx? i run linux atm
13:14:31 <bourbaki> oh ok :)
13:14:45 <bourbaki> then you cant have a look at the game i am writeing
13:14:52 <basti_> aw.
13:14:56 <basti_> what kind is it?
13:15:23 <bourbaki> its not much of a game yet but i want to make it a mixture of lemmings, worms, pikmin and chu chu rocket
13:15:30 <bourbaki> so some kind of puzzle game
13:15:31 <basti_> ah.
13:16:20 * Darius hasn't heard of pikmin.
13:16:32 * basti_ hasn't too
13:16:35 <bourbaki> thats a gamecube game
13:16:48 <bourbaki> released with the GC actually
13:18:59 <bourbaki> http://images.google.de/imgres?imgurl=http://image.com.com/gamespot/images/2001/gamecube/pikmin/110501/pikmin_screen002.jpg&imgrefurl=http://www.gamespot.com/gamecube/strategy/pikmin/screens_2822512.html%3Fpage%3D2&h=480&w=640&sz=49&tbnid=c49SdVrb4oYJ:&tbnh=101&tbnw=134&start=46&prev=/images%3Fq%3Dpikmin%26start%3D40%26hl%3Dde%26lr%3D%26sa%3DN
13:19:58 <bourbaki> ah here are some good shots of the sequal
13:20:00 <bourbaki> http://www.nintendo.com/gamemini?gameid=m-Game-0000-1727
13:23:44 <bourbaki> night
13:34:35 <Calister> good evening
13:35:19 <musasabi> evening
13:35:22 <Calister> :)
13:37:34 <Nioate> hey
13:38:17 * boegel slaps Itkovian around a bit with a large trout
13:38:27 <wagle> shapr: i invented the term "firm typing", and discovered you using it..  what do YOU think it means?
13:39:37 <wagle> soft-timers are to firm-timers as soft-types are to _____?
13:47:25 <Darius> soft-timer?
13:50:36 * Darius looks at old logs and realizes that shapr hasn't bounced in a while.
13:51:12 * boegel suggest we all call him together
13:51:26 * Calister pokes shapr with a stick
13:51:58 * boegel takes Calisters stick, and hits shapr on the head with it
13:52:20 <Calister> lol
13:52:21 <Calister> ouch
13:52:22 <Calister> ;p
14:33:59 <araujo> Hello haskell
14:35:48 <musasabi> hello
14:51:56 * araujo eats platanitos
14:53:15 * stepcut reads about Modular generic function customisation 
14:58:29 <musasabi> that paper was quite nice.
15:02:06 <stepcut> musasabi: I am hoping it will have the answer to my wash/cgi problem
15:03:57 <musasabi> stepcut: hmm?
15:03:59 <stepcut> yikes, this paper is brand spanking new, no wonder I didn't see it before =)
15:04:09 <musasabi> serialization?
15:04:18 <stepcut> yeah
15:05:02 * musasabi is wondering whether the "typeclass limited instances of GADTs" will come true (from haskell list) that would be very good for serialization.
15:05:34 <stepcut> I have not had time to read that thread yet :-/
15:06:35 <musasabi> well there is a message which says 1) it should work 2) references a bug report about it not working.
15:06:43 <musasabi> but if that is possible...
15:07:41 <stepcut> I wonder how far we are from serializing/deserializing that includes partially evaluated functions  :)
15:09:29 <stepcut> data MyDream = MyDream (a -> b) (b -> c) deriving Serialize
15:09:32 <stepcut> :)
15:10:01 <musasabi> stepcut: well those have to be done outside the language.
15:10:19 <musasabi> stepcut: serializing functions needs bytecode.
15:10:29 <stepcut> indeed
15:10:32 <musasabi> but ghc already has that.
15:10:53 <musasabi> but not for arbitary compiled thunks.
15:11:13 <stepcut> I know its already been done in Clean
15:12:19 <derelm> hi, can someone tell me how to get the first row of an 2dimensional-array, please
15:12:34 * stepcut falls over
15:14:06 <musasabi> derelm: depends on how you represent the matrix ;)
15:14:16 <derelm> hmm...
15:14:56 <derelm> i have a matrix ((1,1),(5,5)) and i do want to print out the first row as a n-tuple
15:15:52 <derelm> musasabi: i don't know what you're "asking" for
15:15:58 <Darius> @type Data.Array.ixmap
15:16:00 <lambdabot> Data.Array.ixmap :: forall e i j.
15:16:00 <lambdabot> 		    (GHC.Arr.Ix j, GHC.Arr.Ix i) =>
15:16:00 <lambdabot> 		    (i, i) -> (i -> j) -> GHC.Arr.Array j e -> GHC.Arr.Array i e
15:16:36 <derelm> Darius: sorry, still no light-bulb over my head :(
15:16:53 <Darius> That was more for my benefit.
15:17:13 <derelm> ah ok :)
15:17:30 <Darius> But actually, I'm wondering the same question as musasabi.  You're representing matrices as nested tuples?
15:18:04 <derelm> err ... sorry, i am not quite sure what you mean ... 
15:18:23 <arjanb> what is the type of your matrix?
15:18:52 <derelm> :: Array (Integer, Integer) Double
15:20:45 <Darius> Okay.  (anArray!(0,0),anArray!(1,0))  
15:21:09 <derelm> is there no way to get the first row as a list?
15:21:35 <musasabi> derelm: you want to s/Integer/Int/
15:22:16 <derelm> musasabi:  would that make a difference?
15:22:21 <musasabi> derelm: and if you want to make it really fast you would use a linear Array indexed by int in ST and map your matrix representation over to that.
15:22:25 <musasabi> derelm: yes.
15:23:00 <derelm> hmm, but i am bound to that representation as it's a given problem in my course
15:23:58 <musasabi> ok.
15:24:24 <Darius> derelm: Simply make a loop that indexes each component of the row and makes a list.
15:24:33 <derelm> ah, i'll probably use list comprehensions
15:25:28 <Darius> derelm: Look at the functions in (Data.)Array if you haven't already, there are some useful ones.
15:26:10 <musasabi> [ e | ((1,_),e) <- assocs mymatrix ]
15:26:45 <derelm> ah
15:26:59 <derelm> yes thats what i had in mind
15:27:17 <musasabi> that is not very efficient (and whether that is a row or column) but should give the general idea.
15:27:34 <derelm> yes thanks
15:31:38 <Darius> let ((_,l),(_,h)) = bounds anArray in map (\c -> anArray!(0,c)) (range bounds)
15:31:52 <Darius> er replace the second bounds with (l,h)
15:34:42 <derelm> thanks a lot!
15:46:47 <esap> Hmm... how do you normally express joins of (omega-)chains in Haskell? Recursive algebraic data types?
15:51:39 <Darius> lubs?
15:52:53 * esap nods.
15:53:26 <esap> I just noticed that the control operation that I've been thinking about a lot has lots of connections to domain theory... :-)
15:54:47 <esap> Which isn't really surprising, but it does clarify several things in my formalism.
15:56:38 <Darius> At what level are the chains you're refering to?
15:56:46 <esap> What do you mean with level?
15:57:53 <esap> The chain is a kind of way to approximate data types with successive recursions
15:59:22 <Darius> esap:I was wondering if you are representing chains some way or are refereing to the ones underlying a denotational semantics of Haskell.
16:00:09 <Darius> For the mathematical ones, the lub of -a- omega-chain is usually the least fixpoint, in Haskell that'd just be a recursive function.
16:00:46 <esap> Right, exactly what I thought.
16:01:08 <esap> The control operation I think will provide some semantics for the chains.
16:02:03 <esap> The ordinary rule for the control operation, Ctx \ A |- f : B  ==> Ctx |- control x. f : A \/ B  that I've been thinking about is just a special case of the more general version.
16:02:51 <esap> Which is something like:  \/{d_i \in Ctx | i \in A} |- f : B  ==>  d_i \in Ctx |- control (i : A). f_i : B_i   or something along those lines.
16:04:47 <Darius> That specializes to the first version?
16:05:04 <esap> Heh, not quite.
16:08:27 <esap> The idea is that instead of Ctx \ A, you would have the join of a chain. This is based on duality with lambda abstraction, in that you could think of a function type as a meet of a set (of all codomains indexed by the domain). Dualize that and you get the interpretation for Ctx \ B, the subtraction. Then that would be a join of a chain of succesively more accurate approximations of a datatype
16:10:28 <esap> Plug that in to the control operation, and then figure out what's the interpretation of the thing below the line in the rule. It has to express _how_ the chain converges to that join.
16:11:30 <esap> I don't yet fully understand how this is exactly related to coroutines (it has to be), it sounds like GADTs more than coroutines, but I need to think that connection in more detail.
16:17:22 <Darius> Wouldn't the glb of the set of all codomains indexed by the domain be _|_.
16:17:57 <esap> hmmm.. why?
16:18:56 <esap> Think of Bool -> A. You can write that as (A,A).
16:18:57 <Darius> _|_ is in the codomain and it would seem to be the -only- lower bound
16:20:26 <esap> Then Integer -> A would be like an infinite sequence of A's.
16:20:39 <Pseudonym> Such as [A].
16:21:11 <esap> I'm assuming there is exactly one element of the codomain for every element of the domain, e.g. that the functions are total.
16:22:20 <Darius> esap: If the functions are total and the codomain is Bool then the problem is worse there isn't even a lower bound in the set.
16:23:36 <Darius> The glb doesn't need to be in the set I don't believe, but then I'm not sure how to interpret that element... except as bottom.
16:25:33 <esap> as a product, I'd expect, where there is one element for the product for every element of the domain. E.g.  the link between Bool -> a and (a,a) defined by \f -> (f True, f False)
16:26:45 <Darius> esap: Yes, but how do you compare them?
16:27:55 <Darius> There are four total functions from Bool -> Bool, which is the lower bound?
16:30:41 <esap> I think const False is the lower bound. I'm not exactly sure, but first guess is I would just compare pointwise for every element of the domain.
16:32:12 <Darius> esap: That's the problem I mentioned before, there is no comparison between True and False.  But I'm a little off of what you said, you said a codomain indexed by the domain (presumably by the function) but still it boils down to the same problem.
16:32:14 <esap> That is, f <= g iff x <= y => f x <= g y
16:36:50 <esap> I haven't really thought any of this through in all detail  :-)
16:38:31 <esap> darius: I'm wondering why you wouldn't make False <= True?
16:40:13 <Darius> Why should it be?
16:40:54 <Pseudonym> From a denotational semantics point of view, True and False contain exactly the same information.
16:41:17 <Pseudonym> So if your partial order is "contains less information than", False <= True isn't correct.
16:41:41 <esap> let me think of that a second.
16:42:59 <Pseudonym> Think about it from the point of view of someone writing a compiler.
16:43:12 <Pseudonym> Suppose you want to know what the value of some (Boolean) variable is.
16:43:39 <Pseudonym> case b of { False -> f }
16:43:51 <Pseudonym> Outside the case expression, you have no information about b.
16:43:58 <Pseudonym> Inside f, you know that b must be False.
16:44:06 <esap> right
16:44:16 <Pseudonym> Now consider this:
16:44:26 <Pseudonym> case b of { False -> case b of { True -> g } }
16:44:59 <Pseudonym> If, using the denotational semantic information-content partial order, False <= True, then in g, b would be True.
16:45:19 <Pseudonym> Whereas, in fact, in g, b has the value "top", i.e. "inconsistent information".
16:45:49 <esap> well that branch would never be executed.
16:45:54 <Pseudonym> Correct.
16:45:58 <Pseudonym> But that's a dynamic property.
16:46:00 <Pseudonym> Not a static property.
16:46:20 <esap> I'm more thinking about case b of { False -> throw (True) ; True -> 10 }
16:47:14 <esap> and an extension to case where it catches the exception and re-evaluates the condition.
16:47:21 <esap> with the new value thrown.
16:47:26 <Darius> esap: Even so, case b of True -> throw False; False -> 10 is no less privileged, no?
16:48:35 <esap> something along the lines of case b `catch` id of { False -> throw True ; True -> 10 }
16:48:48 <dons> Itkovian: looks like you have an old hs-plugins
16:51:25 * esap is trying to understand the control operation, which in a way is like this 'x `catch` id' thing, but with compile-time guarantees.
16:52:36 <esap> ok, it might not still be enough to have False <= True.
16:58:49 <Darius> esap: Well beyond that, unless you're going to add elements, the only thing you can add is True <= False, but the PO in (p)CPO would then make True = False.
17:01:14 <esap> hmm.. that's actually interesting. That might be exactly what I want. I mean _within_ the case branches :-)
17:02:19 <esap> Of course, when you get a contradiction, then the semantics must be that the control never gets there...
17:02:30 <esap> ... which brings me to coroutines...
17:03:17 <Pseudonym> That's not _entirely_ true.  There are some languages which allow nasal demons.
17:03:31 <Pseudonym> And they can happen as a result of a semantic contradiction.
17:03:43 <Pseudonym> e.g. using an uninitialised variable in C
17:04:19 <esap> well I'm assuming I do have a type checking that prevents those.
17:04:26 <Pseudonym> Sure.
17:04:34 <Pseudonym> I'm not saying this applies to your languag.
20:07:15 <esap> darius, pseudonym: I just realized I had confused meets and joins in the previous discussion. The interpretation of A\B should be based on meet, not join of the set.
21:15:45 <shapr> Good morning #haskell
21:28:57 <Pseudonym> Greetings.
21:29:47 <musasabi> morning
21:40:59 <Crikey> Why does replicate 3 "Foo" work whereas a function I have which does [replicate n c | c <- line] not work where line is [String]???
21:42:59 <Pseudonym> Works fine for me.
21:43:10 <Pseudonym> What did you expect it to do?
21:43:27 <Pseudonym> And what do you see?
21:44:59 <Crikey> Pseudonym, Sorry my bad. Worked out what is wrong with the hugs error message. The ghci one was very cryptic
21:45:17 <Crikey> Going to be a while before I can make head or tail of the darcs code base at this rate
21:51:28 <wagle> shapr: what do _you_ think firm types are?
21:55:45 <wagle> hrrrmrrrph.  good nigh #haskell  |)
22:32:15 * juhp thinks, "There should be a space after each comma in the topic."
