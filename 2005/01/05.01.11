01:34:07 <Itkovian> @seen boegel
01:34:08 <lambdabot> I saw boegel leaving #Haskell 10 hours 50 minutes 4 seconds ago.
01:34:33 <Itkovian> don't these students work during the days?
01:35:30 <Muad_Dibber> no
01:35:36 <Muad_Dibber> students are allowed to sleep all day
01:35:47 <Muad_Dibber> and only work after dinner before party time :P
01:37:50 <Itkovian> ah. ic. in my days 'twas differnet
01:46:59 <Matt-W> Does anybody know if there's a library function in GHC which splits a list of things into a list of lists, preserving order and using the result of a function (a -> Bool) to determine where the separators are? My brain says 'splitBy' to me but I can't find it in the docs...
01:49:03 <Lemmih> @type break
01:49:04 <ozone> Matt-W: search for splitBy in http://www.haskell.org/hawiki/LicensedPreludeExts
01:49:05 <lambdabot> break :: forall a. (a -> Bool) -> [a] -> ([a], [a])
01:49:24 <Lemmih> Oh. "List of lists" doh.
01:49:38 <Matt-W> I think I'm going to have to write my own
01:49:39 <ozone> looks like your brain was right, too :)
01:49:50 <ozone> Matt-W: hey, see what i wrote above!
01:49:55 <ozone> tis been written for you :)
01:50:01 <Matt-W> oh yes
01:50:02 <Matt-W> woooo
01:50:05 <Matt-W> thanks
01:50:28 <Matt-W> just a wrapper around break, very cool
01:51:51 <Matt-W> gotta love Haskell
02:01:02 <bourbaki> moin
02:01:16 <Matt-W> moin
02:03:29 <ex_nor> I don't think I'd include break if I was to write that myself...
02:04:02 <Matt-W> all I'm worried about now is making it work
02:04:10 <Matt-W> I can worry about efficiency and such things later
02:04:26 <ex_nor> it's just easier to write without worrying about tuples
02:37:50 <shapr> shaboing
02:40:13 <bourbaki> shapr: did you start my game yet :)?
02:40:54 <shapr> Is it written in Haskell? Does it run on Linux?
02:41:13 <bourbaki> nono :) heh
02:41:34 <bourbaki> i have wirtten that game in haskell already but had no renderer
02:42:00 <shapr> I haven't had a copy of windows in several years, and I doubt I'll ever have another copy.
02:42:16 <bourbaki> :)
02:42:53 <shapr> Could you use the OpenGL canvas in wxHaskell?
02:43:04 <Itkovian> damn zombies
02:43:06 <shapr> hoi Itkovian 
02:43:13 <shapr> did you get zombied?
02:43:26 <Itkovian> well, acrobat reader got zombied and took my mouse with it
02:43:32 <shapr> suck
02:43:42 <bourbaki> maybe but its too uncomfortable to do the low level ogl in haskell
02:43:47 <Itkovian> idd
02:43:57 <bourbaki> id like to have something like a render engine in haskell
02:43:57 <Itkovian> X went down ... well, I shot it actually
02:44:01 <shapr> vincenz: hoi
02:50:37 <musasabi> bourbaki: the haskell opengl interface is not nice?
02:50:50 <bourbaki> no not at all
02:51:00 <bourbaki> its directly mapped and it always changes
02:51:13 <bourbaki> there needs to be more abstraction in order to use it
02:51:34 <bourbaki> and i want a render class and a definition of a mesh and such
02:54:17 <musasabi> but don't people use the C interface in C?
02:55:00 <bourbaki> that why i just get sample frameworks and add what i need
02:55:29 <bourbaki> alot of these interfaces even in engine are badly desingned imho
02:56:08 <bourbaki> i was just thinking about exporting something like a rendergraph to haskell form dx
02:56:54 <bourbaki> and use the nodes as functions in hakell and do something like these s expressions in lisp so you have a head node thats a function and some argument nodes that wasy its easy to use in haskell
02:59:17 * shapr wonders if he can put ":def <cmd> <expr>" ghci commands into his ~/.ghci
02:59:18 * shapr tries
03:00:58 <shapr> looks like I can ...
03:01:15 <shapr> In that case, I think I can easily port @index and other useful lambdabot commands to ghci
03:02:01 <shapr> ah, it needs to be a command of String -> IO String
03:24:39 <shapr> g'day iainm 
03:24:59 <iainm> hello.
03:30:42 * shapr viciously slanders Python on lambda-the-ultimate.org
03:30:57 <shapr> ok, it's not really slander.... but it's not complimentary either.
03:31:24 <musasabi> btw localizing haskell apps seems quite hard.
03:31:55 <shapr> Yes, I agree.
03:32:06 <shapr> Any suggested solutions?
03:32:13 <shapr> ResourceBundles? gettext binding?
03:33:26 <shapr> I'll need localization soon.
03:33:41 <shapr> iainm: why the extra I in your nickname?
03:34:10 <musasabi> well printf with positional argument support is nice.
03:34:33 <musasabi> without that using gettext is quite worthless.
03:35:34 <iainm> what extra I? My name as is on my birth certificate, passport, etc, is spelt Iain
03:36:02 <shapr> oh
03:36:04 <shapr> neat
03:36:13 <musasabi> "Foobar "++show x++" baz." is an enemy of localization.
03:36:33 <shapr> iainm: I misread your /whois info
03:37:01 <shapr> musasabi: halipeto does that with identifiers
03:37:12 <iainm> oh, okay.
03:37:40 <shapr> iainm: Can you idle?
03:39:11 <musasabi> shapr: how?
03:39:12 <shapr> I can only idle for about two backward/forward cycles and then I fall over. I can't ride backwards either.
03:39:59 <iainm> shapr, we're talking unicycling now?
03:40:01 <shapr> musasabi: it keeps a dictionary of identifier + language to result.
03:40:04 <shapr> iainm: yup
03:40:22 <iainm> yeah, I can idle. It was a bastard of a thing to learn, though.
03:40:28 <samc_> does unicycling improve haskell coding abilities or something?
03:40:34 <shapr> samc_: I suspect so =)
03:40:44 <iainm> samc_, sure. Unicycling improves everything.
03:41:05 <shapr> Speaking of which, it's beautiful day, I should practice idling and backwards riding.
03:41:27 <shapr> iainm: how long did it take you to learn idling? Can you juggling while idling?
03:41:30 <iainm> the neat thing about idling is that once you can idle reasonably well, you can just hold a pole, put one foot on the fork, and idle one-footed.
03:41:46 <musasabi> shapr: so how does it handle the dynamic parts?
03:42:12 <iainm> I think it was a few weeks to be able to idle for a little while, and a few months to get to the point of being able to idle more or less forever.
03:42:12 <shapr> it assumes that you show identifiers to be localized
03:42:20 <iainm> yeah, I can juggle while idling.
03:42:28 <shapr> Wow, I want to do that.
03:43:01 <shapr> musasabi: but you could beat that by returning a localize dictionary instead...
03:43:52 <iainm> it's not very interesting, it's basically just a matter of getting your idling solid enough that you don't need to wave your arms around to maintain balance.
03:44:52 <shapr> so instead of show "kirjakauppa" you could do 'lFM [En "bookstore",Fi "kirjakauppa"]'
03:45:48 <shapr> It seems very interesting since I can't yet do it.
03:46:07 <shapr> I can freemount and hop. That's pretty much it.
03:46:48 <shapr> And I can power my way through six inche deep snow for short distances :-)
03:46:49 <musasabi> shapr: hmm, is that really working?
03:46:58 <iainm> travel to australia and join us on one of our crazy 30 km rides
03:47:03 <iainm> on 20 inch wheels :)
03:47:24 <shapr> musasabi: I just made up the whole idea of returning a localize dictionary. I can't think of a better idea at least.
03:48:31 <shapr> iainm: do you post on rec.sport.unicycling? I post there occasionally. I'd love to show up and ride with you, but I dunno when I'll next be in .au
03:49:01 <iainm> shapr, I only post occasionally.
03:49:01 <shapr> I do regular 7km rides on my KH24 mountain unicycle, that's great fun.
03:49:32 <shapr> I do that about four times a week. I'm trying to work up to longer distances.
03:50:01 * shapr considers creating a unicycling channel
03:50:18 <musasabi> hmm
03:50:46 <shapr> musasabi: at least that would let you do 'localized show'
03:51:24 <shapr> gee, who else unicycles on freenode?
03:52:26 <musasabi> shapr: think about code like 'when foo $ throw ("Invalid packet received from "++show peer++", aborting.")'.
03:52:47 <iainm> there must be at least a few.
03:53:06 <musasabi> if there are multiple dynamic parts then positions can change between languages.
03:53:18 <musasabi> and translators don't want to touch haskell.
03:53:19 <shapr> oh, you need something like ShowS then
03:53:37 <shapr> I see what you're saying
03:54:30 <shapr> so you really need 'when foo $ throw (invalidPacketMsg peer)'
03:54:56 <musasabi> shapr: but translators don't want to touch haskell source.
03:55:17 <musasabi> and having all the strings away from the source location is not nice either.
03:55:43 <shapr> hmm
03:56:02 <shapr> I think you can make a gettext-like structure that allows parameters/arguments.
03:56:14 <shapr> and something that's simple enough that translators could use it.
03:56:28 <shapr> But maybe I'm not the best person to estimate simplicity...
03:56:40 <musasabi> shapr: sprintf ;)
03:57:02 <musasabi> one could just manipulate the source to make it do a dictionary lookup on the format string.
03:57:17 <shapr> yeah, I think that's the best approach.
04:16:38 <shapr> iainm: kind of learning Haskell for university?
04:17:34 <iainm> I'm currently at monash uni, which doesn't have haskell in the curriculum, but I want to move to melbourne uni, where there is a semester of haskell in the second semester of first year.
04:18:00 <shapr> Ah, so you're planning ahead?
04:18:14 <iainm> while the university doesn't state any need for haskell knowledge, I suspect it will be useful
04:18:27 <shapr> I think it's useful for programming.
04:19:01 <iainm> and am sufficiently nerdy to think "maybe I should learn haskell for university" and then promptly decide I should just generally learn haskell
04:19:24 <shapr> Yeah, I understand that.
04:20:01 <shapr> Most people here learned Haskell by themselves, without external motivation like job or professor.
04:22:00 <Itkovian> a prof can make a nice intro though and encourage you to get under the hood of things
04:26:24 <shapr> Man, the Python vs recursion thread on lambda-the-ultimate.org is huge.
04:27:33 * musasabi wishes that he can use haskell for things this semester at the uni
04:27:58 <shapr> What things?
04:28:55 <Itkovian> anybody any idea how i can convert an A3 size ps to a A3 size pdf? ps2pdf fouls up
04:29:03 <musasabi> we have a quite large compilers course and I will try to make projects in haskell if I can get the lecturer to agree at least.
04:29:14 <Itkovian> musasabi: good luck!
04:29:21 <shapr> yeah, I hope it works out.
04:30:33 <musasabi> I suspect they will be using java for the examples, but given that it is a quite small course I think I have some chances in getting aproval for doing my stuff in a sane way.
04:31:14 <musasabi> (that is large in course units, small number of participants)
04:31:39 <adept> Itkovian: what do you mean "fouls up" ?
04:31:58 <Itkovian> well, I end up with a A4 size piece ... the bottom left corner
04:32:16 <Itkovian> the original ps is qcad generated
04:32:50 <adept> Itkovian: maybe, ps lacks proper paper size specification and needs to be fixed with, f.e., ps2ps ?
04:34:52 <Itkovian> yeah, fouls up too ...
04:34:55 <Itkovian> aargh
04:35:06 <samc_> Itkovian, if it's not too big I could try osx's conversion
04:35:07 <Itkovian> and I do not know any postscript ...
04:35:17 <Itkovian> samc_: I'll dcc it?
04:35:28 <Itkovian> the local osx dude is out for an extended lunch :-)
04:35:42 <samc_> ok, I hope I can figure out how to accept with this client :)
04:35:54 <Itkovian> now, careful not to send any porn :-)
04:36:08 <Itkovian> samc_ take yr time :-)
04:36:27 <samc_> yes very slooow today
04:38:22 <Itkovian> hmm it seems so ...
04:38:29 <Itkovian> i'll leave the offer open, ok?
04:40:24 <samc_> hmm, maybe I should switch to a nonbeta client
04:40:28 <Itkovian> :-)
04:41:01 * musasabi waits eagerly for GHC 6.4 to get released.
04:41:41 <musasabi> but it is probably a few weeks still at least :-(
04:41:42 <samc__> try this one
04:43:50 <musasabi> How obsolete is hugs 2001 ?
04:46:26 <Itkovian> very?
04:46:35 <samc__> DCC RECV connect attempt to Itkovian failed (err=Invalid argument)
04:49:36 <Itkovian> hmm
04:49:38 <Itkovian> sorry
04:49:49 <Itkovian> I'll fiddle some more, thx for the offer anyway
04:55:17 <samc__> np
04:58:48 <samc_> MegaMonad: what do you think of unicycling?
04:58:49 <MegaMonad> samc_: Curryspondence is definitely worth me getting the person that uses the same abroad. This makes me think of unicycling?
04:59:33 <samc_> MegaMonad: I don't know, doe it make you think of unicycling?
04:59:33 <MegaMonad> samc_: Me trying to think of unicycling?
05:00:31 <samc_> MegaMonad, Yes, you trying to think of unicycling.
05:00:31 <MegaMonad> samc_: I've been unicycling just a little bit more, the prelude, where there is some language with automatic prosperity. It means freedom from the same think the only i could just have to reconsider.
05:11:58 <adept> who can help me with http://rafb.net/paste/results/YkbAM362.html ? :)
05:13:59 <Lemmih> Error message?
05:14:41 <adept> nope. code eats stack, unless you uncomment lines marked with 'UNCOMMENT HERE'.
05:17:46 <Lemmih> Did it blow the stack?
05:17:52 <adept> yep
05:18:22 <adept> unless I print array contents after each iteration of "do_something", effectively forcing evaluation of array memebers
05:18:49 <adept> otherwise, array members become closures referencing "old selves" and eat the stack
05:19:32 <adept> it's like famous "putStrLn $ foldl (+) 0 [0..10000000]" problem, except that I dont know how to force strictness of array memebers...
05:20:23 <Lemmih> adept: Compiling with -O should fix it.
05:20:43 <adept> nope
05:20:49 <adept> (i compile with -O2)
05:21:42 <Lemmih> It ran successfully when I compiled it with -O.
05:21:53 <ozone> adept: in general, use -O
05:22:23 <ozone> iirc, -O2 is not really supported.  at least, all the ghc hackers i know never use it
05:23:33 <adept> `--> ghc6 --make -O -o arr-test arr-test.hs
05:23:33 <adept> Chasing modules from: arr-test.hs
05:23:33 <adept> Compiling Main             ( arr-test.hs, arr-test.o )
05:23:33 <adept> Linking ...
05:23:33 <adept> .-(~/devel/haskell/code/n-bodies)---------------------------------------------------------------------------------------------------------------(adept@dimail)-
05:23:35 <adept> `--> ./arr-test
05:23:37 <adept> Stack space overflow: current size 1048576 bytes.
05:23:39 <adept> Use `+RTS -Ksize' to increase it.
05:23:56 <adept> oops. sorry for Long Lines :)
05:24:28 <ozone> adept: tried adding !s in front of the Doubles in Body?
05:26:21 * Lemmih is working on a Haddock lambdabot module.
05:26:22 <adept> arr-test.hs:4: parse error on input `::!'
05:26:42 <Lemmih> adept: Put a space between :: and !
05:27:09 <ozone> adept: oh, if yuo didn't know, putting ! in front makes that field strict
05:27:10 * adept look stunned
05:27:43 <adept> ozone: I know about making field string, it just never crossed my mind that space is significant here ...
05:28:02 <ozone> adept: *shrug* i have no clue either, but it might help
05:28:47 <adept> well, it still overflows, even with '!'
05:30:44 <ozone> oh well, sorry, dunno what then
05:31:54 <autrijus> rehi folks.
05:36:40 <Lemmih> Greetings, autrijus.
05:52:12 <Lemmih> shapr: Ping.
05:53:24 <Lemmih> shapr: Has lambdabot been compiled with GHC 6.3?
06:00:04 <shapr> EvalModule doesn't work with 6.3, though I forget the details.
06:01:25 <Lemmih> shapr: Is it fixable or is hs-plugins the next step?
06:02:17 <shapr> I don't remember..
06:02:29 <shapr> hs-plugins is the best approach in any case.
06:07:01 <Lemmih> shapr: The Hackage and BotDock module would both greatly benefit from a 6.3 compliant lambdabot.
06:12:36 * adept beats himself with cluestick
06:12:58 <samc_> pass it here when you're done
06:13:22 <adept> :)))
06:13:46 <adept> not in the nearest future, unfortunately :(
06:14:45 <samc_> :(
06:26:06 <adept> who can do "cd /devel/haskell; rgrep -i 'import.*array' *" and send me something worth taking look at? :)
06:33:27 <bens> can anyone help me with suppressing laziness in a function? I'm trying to write a function that recurses indefinately, without running out of memory.
06:35:05 <Cale> bens: your other option is to increase the laziness, so that prefixes of the input correspond with prefixes of the output
06:35:29 <adept> bens: what kind of function?
06:35:34 <Cale> but have a look at seq, and putting ! in data types
06:36:05 <Cale> (if the problem is, for example with expressions not getting evaluated while collapsing something large
06:38:44 <bens> adept: i'm playing around with a game, and i need a game loop. it takes a gamestate variable and returns the same. I get the problem if with the termination condition i return a value computed (like a frame count) over the course of the calculation, whereas i don't when returning a constant.
06:39:20 <Cale> bens: yes, you need to make that cell strict
06:39:35 <bens> Cale: I'm not sure how i can implement your suggestion, i'm still fairly new to all this laziness stuff
06:39:40 <Cale> put a ! before it in the data type which you're returning
06:39:47 <bens> ok, cool then
06:40:02 <TheHunter> adept, try @a_i' `seq` writeArray arr i a_i'@ (with strict Body)
06:41:53 <TheHunter> or rather writeArray arr i $! a_i'
06:43:02 <adept> TheHunter: works like a charm, thanks :)
06:43:35 <adept> TheHunter: hmm... my _full_ code has lists as parts of 'Body', wonder wether this trick will help with them ...
06:44:12 <TheHunter> you should make a DeepSeq instance of Body, then.
06:44:36 <adept> TheHunter: seems so ....
06:44:38 * adept is trying DeepSeq
06:45:57 <bens> cale: thanks for that, it's gone from 1mb to 16b used (over the test period) :)
06:46:14 <bens> woops, i mean 160b
06:50:50 <adept> TheHunter: you know, after I eliminated a typo, it work even _without_ DeepSeq :)
06:51:06 <adept> TheHunter: albeit slowly ...
06:51:15 * adept is really trying DeepSeq this time
06:54:34 <adept> strange, DeepSeq'd version uses more memory then version with 'seq's :)
06:59:31 <Lunar^> adept: with more strictness, there is oftern more live data
07:03:47 * adept tries to code a benchmark for "language shootout"
07:12:40 <musasabi> adept: if you need help, just tell me (I can commit that too if you want ;)
07:21:36 <adept> musasabi: great :) I need help, definitely... Can you take a look at http://rafb.net/paste/results/OjoqXS18.html ? It's the n-bodies benchmark, which runs, but awfully slow - 67 seconds on iP IV 2 mHz .
07:23:55 <musasabi> adept: you want to use STUArrays instead of Vectors probably 
07:25:54 <adept> musasabi: you mean, make Body an STUarray instead of "data Body" ?
07:26:17 <musasabi> that would be evil and efficient, not sure about fairness.
07:27:40 <adept> musasabi: but wouldn't accesses to array of arrays be alwfully-looking? :)
07:29:59 <musasabi> adept: you would define the accessors.
07:30:06 <musasabi> wait a moment, I'll modify that.
07:30:42 * adept eagerly waits
07:33:15 <CosmicRay> good morning, entropic unicyclers.
07:33:23 <CosmicRay> let's see what megamonad can do with that. :-)
07:35:03 <tromp> what kind of benchmark are you writing, adept?
07:36:25 <Maddas> tromp: An entry for http://shootout.alioth.debian.org/benchmark.php?test=nbody&lang=all&sort=cpu (sounds like that, at least)
07:36:35 <adept> tromp: n-bodies
07:36:47 <adept> yep, URL form Maddas is correct
07:37:09 <adept> i'm interested is using arrays in haskell, that's why i picked that one
07:39:59 <tromp> i'm also porting a benchmark that uses arrays
07:41:44 <tromp> it's not on shootout list yet
07:46:16 <musasabi> youzen.b2.fi/~musasabi/a.hs - startings of the STUArray way.
07:50:33 <musasabi> (updated them all to use newBody - now the real code)
08:04:44 <adept> have I missed something? :)
08:05:20 <CosmicRay> we determined that 42 was not the correct answer in your absence.
08:05:26 <CosmicRay> the correct answer was 42.3.
08:07:07 <adept> is it dec, hex or oct? :)
08:07:26 <CosmicRay> sorry, you weren't here, you missed out ;-)
08:07:34 <adept> argh ....
08:07:34 <CosmicRay> (have you ever read douglas adams?)
08:07:54 <adept> in fact i'm re-reading "hitchhiker's huide..." now :)
08:08:05 <CosmicRay> oh, then I really *should* shut up right this moment.
08:08:08 <adept> ^hui^gui^
08:08:21 <desrt> re-reading
08:08:26 <CosmicRay> oh.
08:08:27 <desrt> he already knows about the suprise ending :P
08:08:27 <CosmicRay> right.
08:08:30 <CosmicRay> heh
08:08:43 <CosmicRay> have you read the rest of the "trilogy" too?
08:08:45 <Igloo> I don't think that could really count as a spoiler these days. It's in the same net as "I am your father"
08:09:01 <CosmicRay> Igloo: dammit, I always wondered about that! :-)
08:09:18 <bourbaki> adept: you popinted me to that coloured petri net thing right?
08:09:34 <bourbaki> esap: are you there?
08:09:54 <adept> bourbaki: em.. is it a question or what? :)
08:09:56 * CosmicRay figures it's finally time to delete these 2.0 and 2.2 kernel images, netscape 4.7, and the x86 emulator from his machine.
08:10:12 <bourbaki> adept: yes im not able to remember if it was really you :)
08:10:54 <bourbaki> adept: just wanted to point out that its quite good but not really what i need cause they generate the code for haskell what i need is a system in haskell directly never leaveing it
08:11:37 <adept> bourbaki: try to look up FGL as well (functional graph library). Or was it incrorporated as Data.Graph? ...
08:16:45 <adept> musasabi: it turned out to be a little bit tricky? :)
08:17:00 <Igloo> Hints should now be in place for a mass Debian Haskell migration, BTW
08:17:31 <basti_> ?
08:17:34 <adept> ?
08:17:44 <Igloo> Migration from unstable to testing
08:17:52 <basti_> oh =)
08:17:53 * adept . o O (and those hints are 42 and 42.3)
08:18:21 <musasabi> adept: hmm? 
08:19:28 <adept> musasabi: before I got disconnected, you said "<musasabi> wait a moment, I'll modify that." ...
08:19:33 <Igloo> Hmm, shouldn't haskell-hsql be libhaskell-hsql and missingh libhaskell-missingh?
08:20:04 <Igloo> (policy doesn't have the "haskell-", but I think that's an error)
08:21:53 <CosmicRay> Igloo: are you speaking of source or binary packages
08:22:01 <Igloo> Source
08:22:08 <CosmicRay> Igloo: for binary packages, we already have libghc6-missingh-dev, etc.
08:22:25 <CosmicRay> no, I don't think we've generally renamed upstream stuff for source packages
08:22:39 <CosmicRay> ie, you might have libcurses-perl generated from perl-curses
08:23:15 <Igloo> Hmm, fair enough. I guess source package names aren't as important anyway
08:23:32 <CosmicRay> right
08:23:40 * Igloo disappears
10:25:38 <shapr> Lemmih: y0 come to #unicycling!
10:25:55 <stepcut> heh
10:26:07 <shapr> ulf is on #unicycling =)
10:26:55 <Maddas> heh :-)
11:12:19 <wli> $ who|grep micro    
11:12:20 <wli> simonmar pts/58       Jan 11 04:45 (tide71.microsoft.com)
11:12:34 <Lemmih> Woot.
11:13:39 <Oejet> What does that mean, wli?
11:13:53 <Oejet> And also what does that mean, Lemmih?
11:14:26 <nalexand> Could someone provide a reference for when I would want to use 'foreign import "&foo" ' vs 'foreign import dynamic' vs 'foreign import'?
11:14:47 <wli> sparc64 bogon soon to get smacked down
11:14:51 <Lemmih> Oejet: I can't remember exactly what Simon should do on wli's machine but it was something nice.
11:15:14 <Oejet> Lemmih: I was thinking about "woot".
11:16:59 <Darius> nalexand: The FFI addendum
11:17:30 <nalexand> Darius: Read most of it, and it really doesn't motivate the different options.
11:18:00 <Lemmih> Oejet: neat/nice/cool. But 'Woot' is very ambiguous.
11:18:02 <nalexand> Darius: I don't believe I need dynamic, nor do I want an address, but I do have a question about why I would ever import a static FunPtr.
11:24:31 <Darius> nalexand: What do you mean "import a static FunPtr"?
11:25:41 <nalexand> Darius: well, I can do something like 'foreign import ccall unsafe "c_foo" hs_foo :: FunPtr (IO ())
11:25:52 <nalexand> Darius: but it's unclear why I would do so.
11:26:02 <nalexand> Darius: perhaps something to do with the callback system?
11:26:19 <nalexand> Darius: but if that's true, I think there are other (better) methods designed for doing that, like the 'wrapper' import.
11:26:49 <nalexand> Darius: so I'm looking for some experience...
11:29:13 <Heffalump> anyone have any experience of using setjmp/longjmp in C code called from the FFI?
11:32:37 <nalexand> Well, it appears my problem can be solved without understanding, so thanks for the ref Darius.
11:32:45 <Darius> nalexand: You'd presumably do that when you just wanted a C function that returns C functions that you were going to pass to some other C function.
11:33:00 <stepcut> should I create an encrypted partition on my usb key drive or just an encrypted loopback file...
11:33:23 <Darius> nalexand: Unless you are dealing with callbacks, you should typically only need foreign import
11:33:42 <autrijus> yay!
11:33:50 <autrijus> I finally elegantly solved my typing problem
11:34:01 <autrijus> I thought it was unsolvable (linking a container type and a containee type together)
11:34:12 <autrijus> but after much thought it's happily implemented with fundeps
11:34:13 <autrijus> fundeps++
11:34:17 <musasabi> functional dependencies?
11:34:23 <musasabi> :-)
11:36:18 <autrijus> yup.
11:36:25 <autrijus> -- | The RecChunk class unifies a Rec (parent) with its contained
11:36:25 <autrijus> --   chunk types (children).
11:36:25 <autrijus> class (Rec a, Chunk b) => RecChunk a b | a -> b where
11:36:25 <autrijus>     readChunks :: a -> Chunks b
11:36:25 <autrijus>     writeChunks :: a -> [b] -> a
11:36:28 <autrijus> very very simple.
11:36:55 <autrijus> so I just call readChunks and writeChunks
11:37:02 <autrijus> and it determines the children type automagically
11:37:03 <autrijus> magic!
11:59:38 <autrijus> fundeps is really teh r0x0r.
12:02:47 <Darius> autrijus: Multiparameter type classes and functional dependencies are one of the things that are practically guaranteed to be in Haskell II.
12:02:56 <autrijus> cool.
12:03:09 <autrijus> because without it I can't imagine writing delegation/composition patterns
12:15:01 <Lemmih> Why can haddock dump interfaces?
12:16:13 <Lemmih> Coding a :doc would be trivial if it didn't strip the documentation information from the dumped interface.
12:28:49 <Maddas> the mini mac looks nifty
12:30:29 <musasabi> yes, quite tasty.
12:30:34 <musasabi> but will it run ghci ;)
12:33:19 <Maddas> Sure, why not? :-)
12:34:14 <yrlnry>   /topic
12:37:32 <wilx> Huh.
12:37:45 <wilx> Sounds too advanced.
12:37:48 <wilx> Fundep that is.
12:37:57 <Igloo> I've only just realised the haskell.org frontpage no longer mentions lazy/non-strict
12:38:10 <wilx> Is there any tutorial that covers that?
12:39:45 <monochrom> they should at least mention non-strict.  no need to say lazy because there is eager haskell, still non-strict IIRC
12:50:54 <wilx> Whee.
12:51:13 <wilx> Found wiki page about fundeps.
12:51:17 <wilx> Interesting stuff.
12:52:30 <Igloo> "Functional programming language with higher order functions" is a redundancy, right?
12:53:07 <musasabi> No.
12:53:17 <musasabi> or yes.
12:53:29 <Heffalump> 'Functional programming' is not well defined.
12:53:33 <monochrom> TLX is a first-order functional programming language
12:53:44 <musasabi> e.g. erlang lacked funs for a long time.
12:54:21 <Heffalump> TLX?
12:54:38 <Darius> sac, sisal
12:54:41 <monochrom> TXL I mean
12:54:56 <monochrom> http://www.txl.ca/
12:56:05 <Darius> wilx: If you use multi-parameter type classes, functional dependencies are pretty much required, and eventually one wants multi-parameter type classes.
12:56:25 <Heffalump> ah, right
12:57:42 <Igloo> Hmm, ta
13:08:09 <Igloo> What's the word (in the same family as "scalar") for things like integers and arrays but not functions?
13:08:30 <zamez> data?
13:08:40 <basti_> consequent values? :P
13:08:50 <basti_> as in "precedent/consequent"
13:08:58 <basti_> (functions are implications)
13:09:20 <_Codex> modus ponens.
13:11:13 <Igloo> Hmm, think I'll go for "data values". Thanks
13:11:38 <ski> non-code-values ?
13:12:14 <Darius> first-order values
13:13:53 <basti_> i think consequent values is nice :P
13:14:28 <_Codex> objects?
13:14:30 * shapr yawns
13:16:15 <_Codex> though, I dont really see the difference between arrays and functions.
13:16:49 <_Codex> fmap/ixmap works for both arrays and functions => so they're the same. :)
13:17:06 <Lemmih> shapr: Good night, then.
13:17:18 <shapr> yes, soon.
13:17:18 <musasabi> _Codex: but then again so are lists.
13:17:59 <Igloo> id works for everything, therefore all values are equal!
13:19:58 <ski> equal values for all !!
13:20:01 <_Codex> igloo: yes, that's why I picked fmap/ixmap/.
13:21:13 * ski mutters thus to _Codex : except arrays have a more 'multiplicative' feel, which functions have an 'additive' ditto
13:22:46 <_Codex> ski: sorry, I couldnt understand that. Where does the multiplicative feel come from?
13:23:01 <ski> um
13:23:41 <ski> because one most often uses all or most of the elements of the array, while mostly not calling a function on all possible inputs ..
13:37:15 * _Codex reads "sets for mathematics"... page 199: The operator => has many properties...
13:38:30 <ski> mhm ?
13:39:07 <Darius> I find "Sets for Mathematics" an odd title in some vague incoherent way.
13:41:27 <_Codex> That one page (199) has everything you want to know about functions.
15:57:44 <aFlag> i don't get why sieve (h:t) = h : crivo [x | x <- t, x `mod` h /= 0]
15:57:48 <aFlag> returns [1]
15:57:56 <aFlag> with a list [1..10]
15:58:05 <aFlag> shouldn't it loop infinitly?
15:58:57 <Heffalump> what does 'crivo' mean?
15:59:13 <Heffalump> are you sure it's not 'sieve'?
16:00:21 <aFlag> sieve (h:t) = h : sieve [x | x <- t, x `mod` h /= 0]
16:00:21 <aFlag> my bad
16:00:40 <Heffalump> do you understand that Haskell evaluation is lazy?
16:01:17 <aFlag> yes
16:01:19 <aFlag> i know that
16:01:41 <aFlag> and that was what i thought the explanation would be
16:02:13 <aFlag> but i don't get it enough i can determin a result like that
16:05:41 <ski> aFlag : because you start with 1
16:05:56 <ski> all integers are divisible by 1
16:06:11 <ski> try [2..10] instead, e.g.
16:08:40 <aFlag> ski, yeah, i know [2..10] works
16:08:55 <aFlag> i'm just wondering why [1..10] gives me [1]
16:09:03 <aFlag> instead of a stack overflow
16:09:13 <ski> x `mod` 1  is always 0
16:09:25 <aFlag> oh, duh
16:09:33 <aFlag> i was thinking mod would never be 0
16:09:35 <aFlag> :(
16:09:38 <ski> why would you think it should stack overflow ?
16:09:58 <aFlag> nah, i was thinking crap :(
16:10:11 <Lemmih> Igloo: Around? I got a question about 'reify'.
16:10:11 <ski> np, flag
16:10:19 <Igloo> yup
16:11:26 <aFlag> and instead of rethinking the mod part i was wondering about haskell laziness hehe
16:12:01 <Lemmih> Igloo: 'reify' should also get information about type constructors, right?
16:12:23 <Igloo> Right
16:12:37 <ski> aFlag : laziness shouldn't affect what result you get ..
16:17:15 <Lemmih> Igloo: Weird. I tried to reify 'Bool' but it failed with "'Bool' is not in scope at a reify".
16:17:51 <Igloo> You want reify ''Bool
16:18:22 <Lemmih> Igloo: I don't follow.
16:18:47 * stepcut ponders which command-line argument parsing library to use
16:19:00 <Igloo>       x <- reify ''Bool
16:19:01 <Igloo>       runIO $ putStrLn $ pprint x
16:19:23 <Lemmih> Igloo: Oh. Neat.
16:21:16 <ski> Igloo : what is that reify ?
16:21:54 <Igloo> The type Bool
16:22:10 <Igloo> I think there are some things you can't reify with that syntax if there's a name collision
16:23:06 <ski> runnable in current impl. ?
16:23:12 <ski> or your own ??
16:23:18 <Igloo> CVS at least
16:24:23 <ski> m
16:26:16 <stepcut> m
16:27:18 <Lemmih> Greetings, Sonarman.
16:29:26 <Sonarman> hello
16:32:07 <ski> hi there, Sonarman
16:46:25 <ski> MegaMonad: Mandelkaka !
16:46:26 <MegaMonad> ski: Haskells type system to be changed from  `ok req -> do print "oholobalah"` to just `ok req -> do print "oholobalah"` to just `ok req -> do print "oholobalah"` to just `ok req -> do print "oholobalah"` to just `ok req -> do` (i forgot to bring up interesting topics that we'd ditch the two-element base case definition of scaleandbutton is on my laptop is a state machine -like affair.
16:47:37 <ski> MegaMonad: Almond cake !
16:47:38 <MegaMonad> ski: Bringert: no, i don't know that they might well change the code on the cake.
18:04:44 <Lunar^> http://portal.acm.org/citation.cfm?id=968196 <- did anyone notice this?
18:06:04 <dons> ah! I knew those guys were working on the backend, but I didn't seee this
18:11:57 <Lunar^> that's not an easy-reading paper
18:13:58 <Igloo> It had categorical in the title didn't it? There's the first clue  :-)
18:14:23 <dons> hehe
18:14:42 <dons> and the paper starts with a greek letter .. clue #2
18:17:08 <Lunar^> :)
18:17:19 <Lunar^> Igloo: there's RC bug for you btw :)
18:17:42 <Lunar^> That's where you realize how good SPJ papers are
18:17:57 <Igloo> Lunar?
18:19:34 <Lunar^> http://packages.qa.debian.org/n/nhc98.html
18:19:54 <dons> why do they compare against such old versions of ghc, I wonder?
18:21:20 <Lunar^> Igloo: currently most Haskell packages are maintened by you and SyntaxPolice?
18:21:22 <Igloo> Oh, I know. Please feel fre to provide patches for them  :-)
18:21:40 <Lunar^> Igloo: I don't have access to sparc hardware, unfortunately
18:21:41 * Igloo won't be fixing either problem in the near future, unfortunately
18:22:09 <Igloo> The other one, which is both more important and easier to fix, doesn't need a particular platform
18:23:00 <Igloo> Syn and I have the implementations between us. CosmicRay, Marvin-- and ibid at least are other DDs who might have Haskell packages now or in the future
18:24:21 <Lunar^> k. It might be intersted in giving a hand, if needed.
18:25:07 <Lunar^> dons: tests on Debian 2.1.. :)
18:25:13 <Igloo> I think basically what is needed is to introduce a new boolean element of the struct and use that for what the top bit of the pointer is currently used for
18:25:53 <Igloo> Most of the changes are probably in node.h and whatever generates .hc files
18:26:42 <Lunar^> That's quite some work
18:27:05 <Igloo> There's a reason I won't be doing it in the near future  :-)
18:27:44 <Lunar^> Igloo: could sarge be released without nhc98 on m68k?
18:27:47 <Igloo> It's actually straightforward once you locate all the places you need to change. What's putting me off is if you miss one you end up with a nasty bug to track down
18:27:55 <Igloo> Yes
18:29:01 * Igloo should probably get the old sparc binaries removed and tag the sparc bug sid
18:54:05 <lmbdwr> hello
19:01:33 <lmbdwr> is there an extension in haskell that use a synchronized communication-based calculus such as pi-calculus or join-calculus ?
19:45:58 <sh10151> lmbdwr: not that I know of, but that would rock
20:05:49 * Pseudonym must be bored
20:06:10 <Pseudonym> I'm looking through the patents which IBM has pledged to the open source community looking for interesting things to implement.
20:06:40 <dons> I saw a few interesting sounding (by their titles) compiler-related ones
20:07:21 <dons> http://www.ibm.com/ibm/licensing/patents/pledgedpatents.pdf
20:07:26 <Pseudonym> Yeah.
20:07:32 <Pseudonym> http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=/netahtml/search-adv.htm&r=1&f=G&l=50&d=ptxt&S1=6324631.WKU.&OS=PN/6324631&RS=PN/6324631
20:07:36 <Pseudonym> That one looks kinda interesting.,
20:07:44 <Pseudonym> It's a tweak to a mark/sweep collector.
20:08:38 <dons> it's bizarre that you can patent tweaks
20:08:43 <Pseudonym> Yeah.
20:08:56 <Pseudonym> It reminds me of an old thing that Prolog GCs used to do.
20:09:16 <Pseudonym> Basically, you use a separate bitmap to hold the "marks".
20:09:34 <bourbaki> moin
20:09:52 <Pseudonym> Then when you scan, you only need to scan the bitmap, not the heap.
20:10:07 <Pseudonym> I don't think it helps if your collector is compacting.
20:11:22 <bourbaki> hey Pseudonym
20:11:26 <Pseudonym> There's another one which I'm certain MUST have prior art.
20:11:27 <Sonarman> so basically a bitmap replaces a linked list?
20:11:29 <Pseudonym> G'day.
20:11:37 <Pseudonym> Sonarman: No, a bitmap replaces a "mark" bit in each object.
20:11:47 <Sonarman> aj,o k
20:11:49 <Sonarman> aj, ok
20:11:50 <bourbaki> Pseudonym: youre into rendering and raytraceing right?
20:11:50 <Sonarman> ah, ok
20:12:11 * Pseudonym is more into rendering than raytracing
20:12:15 <Pseudonym> But yes.
20:12:47 <Pseudonym> "Method for heap management of fixed sized objects using pages"
20:12:51 <bourbaki> Pseudonym: do you own windoze?
20:12:57 <Pseudonym> I'm sure the Boehm collector was doing that before 1997.
20:13:06 <Pseudonym> bourbaki: No, Microsoft does.
20:13:14 <Pseudonym> But I'm thinking of launching a takeover bid.
20:13:19 <dons> yeah!
20:13:45 <dons> all the haskell billionaires can chip in
20:13:50 <Pseudonym> Exactly!
20:14:02 <Pseudonym> Though the Cambridge guys might have split loyalties.
20:14:11 <Pseudonym> Though I think they may welcome their new Pseudonym overlords.
20:14:26 <dons> hehe
20:15:13 <bourbaki> i just need a good lighting function for my game :)
20:15:53 <Gahhh> why, is it too playable already ?
20:15:58 <Pseudonym> What problem do you need to solve, apart from "good"?
20:16:37 <bourbaki> Pseudonym: i want to make it look more real
20:16:56 <bourbaki> codemages.sf.net/CompiledEffect.exe
20:16:58 <bourbaki> codemages.sf.net/CompiledEffect.fxo
20:17:04 <Pseudonym> Do you have any screenshots?
20:17:12 <bourbaki> yes sec
20:17:13 * Pseudonym doesn't want to download binaries
20:17:50 <bourbaki> yeah reasonable but its a pitty cause nonoe has a look at it then :(
20:18:15 <Pseudonym> "System and method for reducing research time through a lock wait matrix"
20:18:23 <Pseudonym> Postgraduate students of the world, rejoice!
20:18:51 <Pseudonym> Postgraduate students of the world, rejoice!
20:19:22 <dons> that sounds very useful :/ I'm glad they've solved such practical problems, and patented the result.
20:19:40 <bourbaki> http://img93.exs.cx/img93/5373/unbenannt0gc.jpg
20:19:50 <dons> ah, help. I must be stuck in the lock wait matrix
20:20:40 <Pseudonym> Well your first problem is that there aren't many real-world objects which are red/green chess boards.
20:20:55 <Pseudonym> But you probably knew that.
20:21:05 <bourbaki> Pseudonym: heh yes but you see the distorsion quite good
20:21:11 <Pseudonym> You know about inverse-squared falloff, right?
20:21:30 <bourbaki> there is just directional lighting atm
20:21:58 <Pseudonym> http://www.ronenbarzel.org/publications.html
20:22:11 <Pseudonym> There's a paper there called "Lighting Controls for Computer Cinematography".
20:22:14 <Pseudonym> Might want to read that.
20:22:37 <bourbaki> ah thx
20:22:52 <monochrom> A colour-blind person probably won't mind playing chess on a red/green chess board.
20:22:56 <Pseudonym> Don't know if it would be of any help.
20:23:02 <Pseudonym> But it's a start, anyway.
20:23:21 <Pseudonym> There's RenderMan source for it, too, if you want.
20:23:33 <bourbaki> the red and green is cool
20:23:46 <bourbaki> cause on an lcd monitor you have the illusion of blur on that surface :)
20:23:56 <metawar> anyone played with the M-calculus ?
20:27:07 <bourbaki> metawar: whats m calc?
20:27:24 <metawar> a distributed communication-based process calculus
20:27:41 <bourbaki> oh sounds interesting
20:27:46 <metawar> with synchronisation ala join-calculus
20:27:48 <bourbaki> can you give me a quick glimpse?
20:28:03 <metawar> glimpse = ? :)
20:28:56 <bourbaki> a quick intro
20:29:06 <bourbaki> whats the basic formulas and whats the idea
20:31:09 <metawar> I dont know much about it unfortunately. It allows to distribute process and to formalize communications and synchronization between them, not that far from ambiant calculus but with slight modifications to the naming scheme, as far as I understood
20:34:47 <sh10151> wow
20:35:04 <sh10151> now if only the rank and file could grasp this stuff :)
20:35:28 * sh10151 has to patiently explain the difference between bandwidth and latency to coworkers
20:36:07 <sh10151> and why assuming bandwidth will increase is a terrible place to start one's design when latency is the bottleneck
20:38:00 <aFlag> i'm reading a book about haskell and there's an exercice where i should draw a chessboard using the list of strings white (which is something like ["........","........"] only with more dots and more strings) and the list of strings black (which is the same only "########" istead of dots). Now i the best i can think of is having 2 extra parameters calling the function recursively with while passing the parameter-1 each time would give me
20:38:05 <aFlag>  a behavior such as for(i; i<par1; i++) { for(j; j<par1; j++) {...}}, of course that's no functional thinking. So any ideas?
20:44:07 <monochrom> a person who doesn't know bandwidth vs latency --- I would call such a person "theoretician of abstract nonsense" rather than "rank and file".
20:45:32 <monochrom> "rank and file" is supposed to know all the low-level stuff: bandwidth, latency, voltage drop, impedence matching, standing waves in wires, ethernet collision.
20:59:12 <sh10151> monochrom: a good point
20:59:27 <sh10151> monochrom: this person is a java wanker
20:59:41 <sh10151> monochrom: he programs very procedurally and thinks he is doing OO
21:33:06 <musasabi> morning
21:33:16 <araujo> morning musasabi 
21:48:26 <jadrian> hello
21:49:21 <musasabi> hello
21:49:26 <jadrian> hi musasabi 
21:53:09 <jadrian> would it make sense to wish for implicit parameters in the context of "ghci IO monad"?
21:54:01 <jadrian> let ?b=1
21:54:33 <musasabi> implicit parameters are a good way of shooting yourself in the foot.
21:55:30 <jadrian> yes... but so damn useful sometimes :-/
21:55:41 <monochrom> Oh come on all Turing-complete programming languages are good ways of shooting yourself in the foot.
21:55:56 <jadrian> well... I could be using IO + State Transformer...
21:56:48 <Pseudonym> Nah, some are more useful than others.
21:57:32 <jadrian> I'm just using them for defining some options of the interactive part of my algorithm...
21:57:42 <jadrian> like kind of feedback I get etc...
21:58:14 <jadrian> not using them would probably make my code much more complicated and error prone...
21:58:58 <jadrian> state monads would be messier
21:59:06 <jadrian> I'd have to consider different states
21:59:20 <jadrian> and different ways of upgarding
21:59:22 <jadrian> for instance
21:59:52 <jadrian> if I have one record for feedback, and one record for rules, and in one place use on of them, another place the other, and in a third place the three
22:00:05 <jadrian> err s/the three/both of them
22:01:09 <jadrian> In the 3rd case I'd have to use a pair with both states and extra functions to update each of the pair positions
22:01:46 <jadrian> I got 5 records already :-/
22:02:13 <jadrian> with implicit parameters I can just add one more record to the context and keep the same update functions
22:02:29 <Pseudonym> Must away.
22:02:30 <Pseudonym> Nytol!
22:02:38 <jadrian> (they're records of IORefs)
22:02:42 * jadrian is off to bed
22:03:06 <KrispyKringle> heya, folks. Having a syntax error with these lines (http://rafb.net/paste/results/bZmFXF64.html). "ERROR "test.hs":2 - Syntax error in type expression (unexpected symbol ":")
22:03:09 <KrispyKringle> any help? thank. 
22:03:11 <KrispyKringle> thanks, even. 
22:09:39 <monochrom> don't indent there.
22:10:39 <musasabi> jadrian: StateT + IO is quite nice.
22:11:10 <musasabi> jadrian: but that sounds like you would want to restructure things a bit.
22:11:23 <monochrom> Also in general try not to use tabs.  I do not understand how tabs are processed.
22:11:46 <wli> expanded to 8 spaces
22:12:05 <Riastradh> Tabs are evil.
22:12:28 <monochrom> http://rafb.net/paste/results/NYuiUM19.html is the correction
22:13:50 <monochrom> If you know how tabs are processed and you are sure it reflects what you mean, no problem with me.
23:12:36 <KrispyKringle> damn, i'm still confused on this code. function is here: http://rafb.net/paste/results/PHhOIL22.html. indentation looks right. any help?
23:12:39 <KrispyKringle> thanks. 
23:16:34 <KrispyKringle> nevermind. 
23:17:31 <adept> morning
23:19:53 <KrispyKringle> oh, jesus. so the problem is vim's tabs or something. 
23:20:15 <KrispyKringle> damn. 
23:25:22 <adept> :set expandtab=yes or something
23:25:32 * adept forgot almost all of his vim
23:36:33 <KrispyKringle> yeah, i got that. 
23:36:36 <KrispyKringle> thanks, adept :)
23:36:44 <KrispyKringle> i figured it out as soon as i stopped bitching ;)
23:48:43 <wli> are there native x86-64 packages (even unregisterized) yet?
23:49:08 <wli> msg #debian-devel Pangaea was interesting
23:49:50 <Gahhh> you mean ghc ?
23:50:10 <Gahhh> or did you accidentally sent that to #haskell
23:50:35 <autrijus> ghc also doesn't run on my freebsd-amd64 :-/
23:51:23 <Gahhh> in 32 bit mode ?
23:51:36 <wli> in 64-bit mode I was hoping
23:51:42 <autrijus> I don't want it in 32-bit mode :)
23:51:52 <autrijus> that means I'll have to compile and maintain two kernellib trees
23:56:43 <Gahhh> does haskell have more to gain (relatively) from going ia32 to x86-64 than does C ?
