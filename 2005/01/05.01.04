00:40:06 <autrijus> :r
00:40:08 <autrijus> oops.
00:52:17 <autrijus> (uncurry . uncurry . uncurry $ func)
00:52:32 <autrijus> is there a way to rewrite this using fold and 3 ?
01:00:26 <Heffalump> not very easily
01:00:37 <Heffalump> the problem is that each of those uncurrys has a different type
01:01:02 <Heffalump> so you can't trivially stick them in a list of length 3
01:01:08 <autrijus> right.
01:01:24 <Heffalump> and each of the (.)s also has a different type, giving the same problem if you try to make it an argument to foldr1
01:02:31 <autrijus> exactly.
01:03:12 <Heffalump> it ought to be possible to play some tricks with existential types, but it's hardly worth the effort for 3 repetitions
01:03:31 <autrijus> oh. the 3 is just an example.
01:03:36 <autrijus> it's actually glength.
01:03:41 <autrijus> so I don't know the number.
01:03:44 <Heffalump> ahh.
01:03:46 <autrijus> (still deep inside generics land)
01:03:47 <Heffalump> then it may be worthwhile.
01:03:55 <Heffalump> s/may/will/ :-)
01:03:59 <autrijus> right.
01:04:13 * Heffalump plays
01:04:19 <autrijus> thanks so much.
01:06:49 <Heffalump> hmm.
01:07:13 <Heffalump> I can wrap multiple uncurrys up in a list this way. I'm not quite sure how to handle the result type, though.
01:07:26 <autrijus>     get bh = do
01:07:26 <autrijus>         a <- get bh
01:07:26 <autrijus>         return $ (u.u.u.u.u.u.u.u.u.u $ t) a -- Here glength = 11
01:07:26 <autrijus>         where u = uncurry
01:07:27 <autrijus>               t = PGD
01:07:46 <autrijus> the "t" can go once it's genericized
01:08:01 <autrijus> it's currently the u.u.u.u.u.u.u.u.u.u, repeated glength-1 times, that's blocking it
01:08:11 <Heffalump> actually, this can't work in any obvious way, because it's not statically typable :-(
01:08:27 <Heffalump> oh, but a MPTC might help. (Multi-parameter type class)
01:08:43 <Heffalump> however, I really should go to work, so I can't play more now.
01:09:07 <autrijus> okay, thanks.
01:09:11 * autrijus googles MPTC
01:09:26 <autrijus> however at least with this I can THaskell it :)
01:15:09 <autrijus> not seeing how it helps.
01:18:29 <Heffalump> does the exact type you get from uncurry.uncurry matter?
01:18:54 <Heffalump> Could you do it if the type you got was (a -> b -> c -> d) -> (a, (b, c)) -> d ?
01:19:18 <autrijus> t here is a record
01:19:24 <autrijus> data PGD = PGD {
01:19:24 <autrijus>     pgdType                :: !Bytes3,
01:19:24 <autrijus>     pgd_                   :: !Bytes3,
01:19:28 <autrijus>     pgdXUnitBase           :: !Word8,
01:19:28 <autrijus> etc
01:19:32 <autrijus> so I imagine the types matter
01:19:51 <autrijus> since the "get bh" calls are parameterized over Data.Binary instances
01:20:15 <Heffalump> oh, but get bh will take on whatever type it can that's needed
01:20:17 <Heffalump> so I think it's ok.
01:20:21 <autrijus> ok.
01:20:30 <autrijus> this usage is abusing the "instance Binary (a,b)" interface
01:20:50 <autrijus> in that it will call a and b's "get" separately, depending on their types
01:20:52 <Heffalump> are you already using -fallow-overlapping-instances ?
01:21:01 <autrijus> no; I can easily use it
01:21:13 <autrijus> I mean, I was using it but is currently not needed
01:23:52 * Heffalump gets a bit confused
01:24:05 <Heffalump> class Uncurry_ func tup res {- | tup res -> func -} where 
01:24:05 <Heffalump>   uncurry_ :: func -> tup -> res
01:24:05 <Heffalump> instance Uncurry_ (a->b->c) (a,b) c where
01:24:05 <Heffalump>   uncurry_ = uncurry
01:24:05 <Heffalump> instance Uncurry_ func tup res => Uncurry_ (a->func) (a,tup) res where
01:24:07 <Heffalump>   uncurry_ f (a,rest) = uncurry_ (f a) rest
01:24:21 <Heffalump> is the right sort of idea, but I can't get the fundep right, and I can't actually get anything that uses it to work.
01:24:31 * Heffalump disappears, mostly.
01:24:36 <autrijus> ok. thanks for the help
01:25:13 <Heffalump> I should admit to being rather out of my depth and just trying things in hope, if that's not already obvious :-)
01:25:35 <autrijus> it's not obvious from this newbie's viewpoint :)
01:46:22 <mornfall> moin moin
01:46:47 <autrijus> hey.
01:47:10 <mornfall> i need a little help with (.) :P
01:48:35 <mornfall> (not right now... i'll make up my mind on some question in a minute)
01:49:59 * morbidi is back from sleeping after 9 hrs 8 mins
01:54:25 <mornfall> uhm... how does this f = (x.) . y work?
01:56:40 <autrijus> (f.) means (\x -> (\g -> f (g x)))
01:57:14 <musasabi> morning
01:58:53 <mornfall> (f.) = (.) f, right?
01:58:59 <mornfall> and (.f) = flip (.) f
01:59:01 <mornfall> hmm
01:59:31 <mornfall> so, (f.) g = f . g
01:59:43 <mornfall> and (.f) g = g . f? *puzzles*
02:00:13 <autrijus> that looks correct.
02:00:32 <autrijus> so your definition f looks like it's simply (x . y)
02:00:39 <autrijus> but don't trust me, my brain's fried
02:01:04 <mornfall> autrijus: mine's too :p
02:01:46 <autrijus> fair :p
02:23:01 <bourbaki> hi TheHunter
02:23:28 <TheHunter> moin bourbaki 
02:32:26 <mornfall> wibble
02:34:20 <mornfall> i'm unable to wrap my head around all those dots :/
02:35:07 <mornfall> can someone tell me the rules on how to transform say f u v w x = u v (w x) into a bunch of dots?
02:35:52 <mornfall> i went like (u v) . (w x), then ((u v) . w) x, then (.) (u v) w
02:35:59 <mornfall> but i'm suspecting i'm not right here
02:36:07 <mornfall> and dunnow what to do from (.) (u v)
02:36:17 <musasabi> thbot was able to do that..
02:36:38 <mornfall> doesn't seem to be here
02:37:46 <musasabi> died 11 hours ago.
02:37:55 * mornfall is lost
02:38:49 <musasabi> What is the preferred curses binding at the moment?
02:39:38 <TheHunter> thbot: @pointless f u v w x = u v (w x)
02:39:39 <thbot> f u v w x = u v (w x)
02:39:50 <TheHunter> thbot: @pointless \u v w x -> u v (w x)
02:39:50 <thbot> ((.) .)
02:40:17 <mornfall> ah, cool... now i need to learn how to do it, it's a part of my exam :/
02:41:04 <TheHunter> \u v w x  -> u v $ w x ==> \u v w -> u v . w ==> \u v w -> (.) (u v) $ w ==> \i v -> (.) (u v)
02:42:39 <TheHunter> ==> \u v -> (.) . u $ v ==> \u -> (.) . u ==> \u -> (.) (.) u ==> (.) (.) ==> ((.) .)
02:43:53 <mornfall> hmm!
02:44:44 <mornfall> TheHunter: thanks so far, i think i get it... i'll try another one
02:47:30 <Lemmih> shapr: ping.
02:57:46 <musasabi> Does happy support parsing a stream of messages from network in an efficient fashion? (and acting whenever a complete message has been parsed).
02:58:54 <Si\> Where can I find out how the strategy for overlapping instance selection works?
02:59:21 <musasabi> Si\: generally the most specific instance is selected.
03:00:01 <Si\> yes, but is there a formal semantics for it?
03:04:11 <musasabi> I don't remember - but probably there is a paper about that.
03:04:34 * TheHunter needs QuickCheck 2
03:04:53 <Si\> yes that's what I'm looking for, I really don't know much about how they work but suddenly I need to use them :D
03:50:22 <mornfall> wibble
04:22:29 <TheHunter> mornfall, if you need thbot, just pm him. I don't like to have two lambdabots in the channel.
04:23:32 <mornfall> TheHunter: okey, thanks
04:34:01 <musasabi> What is the best way of performing computations with a timeout?
04:35:30 <musasabi> The only robust way seems to be:
04:38:23 <musasabi> doWithTimeout time fun = do { mv <- newEmptyMVar; tid <- forkIO (fun >>= tryPutMVar mv . Just); forkIO (threadDelay time >> killThread tid >> tryPutMvar mv Nothing); takeMVar mv }
05:14:47 <marcot> Hello, I'm having a doubt in a error I get from ghc. The code works well on hugs, but with ghc -fglasgow-exts it give's me this:
05:15:01 <marcot> Non-type variables in constraint: Show (o t)
05:15:14 <marcot> (Use -fallow-undecidable-instances to permit this)
05:15:38 <marcot> instance (Show (o t), Snapshots Snapshot o t) => Show (Snapshot o t) where
05:15:42 <marcot> in this code..
05:16:05 <marcot> What does it mean?
05:17:22 <marcot> I thought that in the context we could use non-type variables.
05:24:59 <Igloo> Show (o t) isn't Haskell 98
05:28:32 <marcot> data Tipo a = T a
05:28:55 <marcot> data Tipo2 a b = T2 a b
05:28:59 <marcot>     show (T a) = show a
05:29:07 <marcot> instance Show a => Show (Tipo a) where
05:29:15 <marcot>      show (T a) = show a
05:29:25 <marcot> instance (Show b,Show (Tipo a)) => Show (Tipo2 (a -> Tipo a) b) where
05:29:33 <marcot>     show (T2 T a) = show a
05:29:35 <marcot> Same error.
05:30:26 <marcot>     show (T2 T a) = show (T a)
05:31:32 <Igloo> Show (Tipo2 (a -> Tipo a) b)   isn't H98 either
05:32:04 <marcot> Igloo: ok, but I'm using -fglasgow-exts.
05:32:26 <marcot> What I don't want is that ghc complain about -fallow-undecidable-instances.
05:32:34 * Igloo doesn't know what the rules are with extensions enabled
05:32:37 <marcot> I don't want to use this...
05:33:47 <Lemmih> marcot: I think you have to.
05:34:29 <marcot> Lemmih: why? Just because of Show (o t) ?
05:37:11 <Lemmih> marcot: It looks like undeciable instances aren't covered with -fglasgow-exts since it has its own flag...
05:38:16 <marcot> Lemmih: but where are the undecidable instances in this case?
05:38:44 <marcot> Lemmih: I thought that this was when you do two instances for the same type.
05:58:05 <kosmikus> no, that's overlapping instances
06:20:20 <Si\> has there ever been talk of overlapping instance selection based on constraints, so that for example you could have instance Cons a => #Something a as well as instance Something a?
06:27:15 <musasabi> hmm Viktoria Zsok will be holding a short course on parallel functional programming this spring here :-)
06:38:28 <kosmikus> Si\: not sure, but maybe CHRs can be used to express such things (Chameleon)
06:43:36 <Si\> I found something on the mailing about it from 2000...
07:06:35 <shapr> Lemmih: pong
07:07:05 <Lemmih> shapr: Heya.
07:07:14 <shapr> y0
07:07:43 <shapr> musasabi: how short?
07:07:45 <Lemmih> shapr: I actually just pinged you to brag about Hacanon (-:
07:07:55 <shapr> oh, go for it!
07:08:48 <Lemmih> It can now handle C++ templates! Demo at: http://haskell.org/hawiki/HaCanon
07:09:22 <shapr> ooh aah :-)
07:09:24 <shapr> nifty!
07:10:52 <Lemmih> It's almost so complete that I dare port ClanLib with it.
07:10:54 <wilx> Hmm.
07:10:57 <wilx> What does it do?
07:11:27 <Lemmih> wilx: Scans C++ header files and generates appropriate interfacing code.
07:12:06 <Lemmih> It handles the nasty stuff like marshaling, overloading and templates.
07:12:12 <wilx> oH.
07:12:17 <musasabi> shapr: 582477 Parallel Functional Programming (1 ov) Luennot: Prof. Viktoria Zsok 23.05.-26.05. MA, TI, KE, TO 10-12 D122
07:12:50 <musasabi> shapr: ov = course unit, luennot = lectures, (ma,ti,ke,to) = mon - thur
07:16:54 <musasabi> shapr: I think it is http://people.inf.elte.hu/zsv/TUT/ - but there is no real info on the course contents yet.
07:31:26 <basti_> hi
07:32:41 * earthy laughs at http://khason.biz/blog/2004/12/why-microsoft-can-blow-off-with-c.html
07:36:24 <basti_> lol
07:37:02 <vegai> "One sight at Stroustrup's face is enough to understand, that C++ much more successful then other languages" -- uh?
07:37:19 <ibid> vegai: note the facial hair, or lack thereof :)
07:37:27 <vegai> ah =)
07:37:35 <ibid> that's wanha, btw :)
07:37:45 <vegai> should RTF whole A before commenting...
07:41:04 <ibid> hm, are there any isas in current use that use anything other than two's complement for signed integers?
08:13:06 <shapr> does anyone else here use type signatures in their poetry?
08:13:48 <Lemmih> shapr: eh?
08:14:55 <shapr> I write chunks of poetry when I feel inspired, and I've noticed that pseudocode is often the most poignant way to discuss some subjects.
08:16:35 <basti_> o0
08:18:19 <shapr> basti_: for example, one row from a made-up medical database:
08:18:29 <shapr>  Egosuction   | 419562573 | Mr Erisson's ego was large enough to cause him medical problems, so we slurped some of it away
08:18:44 <basti_> uhm.
08:19:26 <shapr> Have you met people whose ego size should be classed as a health hazard? :-)
08:20:10 <basti_> sometimes.
08:20:49 <tuomov> yes
08:21:39 <Calister> good evening
08:21:46 <Lemmih> Greetings.
08:21:55 <Calister> :)
08:22:10 <basti_> hi Calister 
08:22:16 <TheHunter> wee, flip === flip (flip flip) (flip flip)
08:22:20 <Calister> hi basti_ :)
08:22:31 <shapr> So I wrote an ascii art printout of the results of a SQL query to see what medical operations I had... that entertained me. I just wonder if other people here mix the computer stuff into their prose or poetry as well.
08:22:38 <shapr> Guten Abend Calister
08:22:45 <shapr> Wie geht es?
08:22:50 <Calister> Guten Abend shapr!
08:22:55 <Calister> Gut, und selber?
08:23:13 <shapr> Gut
08:23:31 <Calister> ^_^
08:23:40 <Calister> can ya maybe send some snow here?
08:23:40 <shapr> I'm in the mood to write poetry
08:23:50 <shapr> I wish, we have enough for several cities.
08:24:15 <mornfall> yoyo *
08:24:22 <shapr> "The energy enthusiastic, the movements bombastic, the slapdance dashingly spastic" mmm, that's crunchy
08:24:23 <Calister> welp, this here is a big city, so we will take snow for two ^_^
08:24:29 <Calister> hi mornfall
08:24:31 * mornfall just finished functional programming (w/ haskell) exam
08:24:37 <shapr> mornfall: how'd you do?
08:25:04 <mornfall> shapr: if i'm a bit lucky, i could get A :)
08:25:08 <shapr> w00!
08:25:29 <TheHunter> mornfall, any "pointless" exercise in it?
08:25:37 <Calister> omigod
08:25:40 <mornfall> shapr: i have a very weird (and obscure) definition of splice which doesn't happen to work on infinite lists... but i hope i get more than 0 points (out of 8) for it :P
08:25:51 <Calister> do you wanna take my next exam, mornfall?
08:26:26 <mornfall> TheHunter: yep, repl n x = take n (repeat x), write pointfree version
08:26:51 <TheHunter> thbot: \n x -> take n (repeat x)
08:26:51 <thbot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
08:26:58 <TheHunter> thbot: @pointless \n x -> take n (repeat x)
08:26:59 <thbot> flip ((.) . take) ((,) . repeat)
08:27:14 <TheHunter> wtf?
08:27:14 <mornfall> o_O
08:27:24 <TheHunter> thbot: @pointless \n x -> take n $ repeat x
08:27:24 <thbot> flip ((.) . ($) . take) repeat
08:27:28 <mornfall> say what?
08:27:31 <TheHunter> thbot: @pointless \n x -> take n `id` repeat x
08:27:32 <thbot> flip ((.) . take) repeat
08:27:42 <TheHunter> that's it.
08:28:19 <autrijus> it works!
08:28:30 <mornfall> hmm
08:28:39 <TheHunter> note to self: always run test before putting the bot online.
08:28:41 <autrijus> finally I've done a constructor for all records
08:29:00 <autrijus> instance Binary PGD where
08:29:02 <autrijus>     get bh = do a <- get bh ; return $ $(constrRecord PGD) a 
08:29:07 <mornfall> (.repeat) . take :p
08:30:16 <MegaMonad> G'day sazzle, when do we know *what* you do with monomorphism.
08:30:28 <mornfall> btw, we were allowed to use hand-written "formula" sheet... i happened to have a poem on the reverse of mine :p
08:30:37 <shapr> neat!
08:30:50 <mornfall> had to rewrite it on a scrap and then show the scrap that it contains nothing related to exam :p
08:30:55 <shapr> haha
08:31:18 <mornfall> cus i didn't have the last stanza rewritten anywhere yet
08:31:25 <autrijus> probably should wiki it under the THaskell page.
08:31:38 <shapr> yeah, I tend to write poetry snippets on everything
08:31:52 <CosmicRay> MegaMonad: poetry?
08:31:53 <MegaMonad> CosmicRay: But i'm wondering about packages and the length of the ghc that expands the power into the parse example in ghc's rts dyn linker, which uses caml to generate postmodern poetry.
08:32:04 <CosmicRay> haha
08:32:11 <shapr> that's cool :-)
08:32:44 <mornfall> haha
08:34:50 * mornfall recovers the scrap with that stanza and rewrites it
08:39:07 <autrijus> done wiki'ing :)
08:39:18 <autrijus> @wiki TemplateHaskell
08:39:18 <lambdabot> http://www.haskell.org/hawiki/TemplateHaskell
08:40:54 <shapr> neat
08:41:51 <mornfall> shapr is all neats today
08:42:17 * shapr writes poetry furiously
08:42:32 * mornfall just finished :)
08:42:35 * mornfall posts on his blog
08:42:43 <CosmicRay> http://megahal.alioth.debian.org/Poetry.html
08:42:59 <shapr> here's something cute - http://thunderbird.scannedinavian.com/~shae/blog/2005-01-04.html
08:43:12 <CosmicRay> also search for "man walk down" on http://megahal.alioth.debian.org/Classic.html
08:43:20 <autrijus> hey, is there a way to reify the expected type inside a functino?
08:43:31 <ozone> shapr: hey, haven't seen any spam on the hawiki for a while.  did you put in some bayesian filters or something?
08:43:32 <autrijus> I've asked it yesterday but still can't find it after a day's search
08:43:38 <ozone> (and happy new year to you :)
08:43:55 <shapr> ozone: nah, there's now a global antispam solution for MoinMoin wikis.
08:43:56 <CosmicRay> I got my first trackback spam today.  Sigh.
08:44:04 <CosmicRay> oh?
08:44:05 <ozone> shapr: oh, much nicer
08:44:21 <mornfall> shapr: neat :)
08:44:23 <musasabi> sounds tasty - how does it work?
08:44:28 <Igloo> trackback?
08:44:29 <shapr> The solution is really great, if a submission has any content that matches a spam pattern, it's refused.
08:44:56 <shapr> Whenever we get new spam on HaWiki, that means it doesn't match the global list, so it goes on LocalBadContent
08:45:02 <CosmicRay> Igloo: it's a way to notify someone's blog that you have linked to it on yours
08:45:08 <shapr> http://www.haskell.org/hawiki/LocalBadContent
08:45:13 <Igloo> Ah
08:45:58 <shapr> At the moment, Cale, TheHunter, and me are the people who can add to LocalBadContent (we're all in the Admin user class) If someone else wants to join in, just tell me.
08:47:29 <mornfall> shapr: http://www.gljs.sk/~mornfall/pyblosxom.cgi/personal/poetry/waking-up <-- longish and possibly boring, read on your own risk :p (that's what i just finished)
08:48:20 <shapr> I think I'll start adding poetry to my blog.
08:51:42 <mornfall> shapr: well, i'm wondering when i get kicked from planetkde.org for that... or at least reduced to tech/ branch of my blog :p
08:51:46 <andersca> blogetry
08:51:55 <mornfall> andersca: awww!
08:53:01 <mornfall> Calister: what's your exam about? .P
08:59:30 <mornfall> uhm, i actually don't believe 'HOW MANY ROADS MUST A MAN WALK DOWN' thing on http://megahal.alioth.debian.org/Classic.html is megahal product... is it?
09:00:52 <CosmicRay> @index setFileSize
09:00:53 <lambdabot> System.Posix,System.Posix.Files
09:03:42 <CosmicRay> mornfall: as far as I know, yes.
09:04:05 <CosmicRay> mornfall: I was laughing for about 10 minutes after I read it
09:04:08 <mornfall> CosmicRay: interesting :)
09:04:08 <CosmicRay> me wife was concerned.
09:04:32 <mornfall> hehe
09:04:34 <mornfall> i can imagine
09:04:42 <CosmicRay> I suspect somebody typed the poem to it previously (all the lines except the last are in a popular american folk tune)
09:05:09 <CosmicRay> from that it would just have to associate "answer" with "42", which, being a geeky project, is not too much of a leap
09:05:19 <CosmicRay> :-)
09:05:48 <vegai>  "MegaHAL CHESS IS A FUN SPORT, WHEN PLAYED WITH SHOT GUNS."
09:07:26 * vegai is amazed.
09:07:30 <CosmicRay> hehe
09:09:14 <vegai> "MegaHAL THERE IS NO SCIENTIFIC EVIDENCE"
09:12:04 <CosmicRay> MegaHAL  	YOU ARE THE VILLAGE PEOPLE?
09:12:04 <CosmicRay> User 	Dear God, I hope not
09:13:11 <CosmicRay> MegaHAL	 TIME. TIME. WHAT IS TIME? SWISS MANUFACTURE IT. FRENCH HORDE IT. ITALIANS WANT IT, HUH? WELL, I MUST BE THURSDAY. I NEVER COULD GET THE HANG OF THURSDAYS.
09:13:29 <CosmicRay> megahal could write the next douglas adams book.
09:16:12 <Calister> lol
09:16:25 <TheHunter> mornfall, i finally found the reason for the thbot weirdness: "flip ((.) . take) repeat" and "(.repeat) . take" both have the same "size".
09:16:57 <mornfall> TheHunter: as in, score?
09:17:23 <TheHunter> yep
09:20:01 <TheHunter> if i use the length of the uglyprint, it finds your representation.
09:23:56 <TheHunter> now it's defnitely time to stop wasting my time with this bot.
09:24:25 <TheHunter> thbot: @pointless \\n x -> take n $ repeat x
09:24:25 <thbot> (line 1, column 2):
09:24:25 <thbot> unexpected "\\\\"
09:24:25 <thbot> expecting white space or identifier
09:24:29 <TheHunter> thbot: @pointless \n x -> take n $ repeat x
09:24:30 <thbot> (. repeat) . take
09:26:06 <mornfall> yay
09:36:44 <Igloo> Brent A. Fulgham doesn't hang out here does he?
09:42:47 <jadrian> Off-Topic: is there a special name for 0 arity connectives? like  _|_  and  T...
09:42:56 <jadrian> I think "truth values" is only used for  v(_|_) and v(T), that is, their valuation...
09:47:31 <Philippa> in a \calc I would've just called them values, being that subset of expressions that isn't reducible and means something
09:47:47 <Calister> hi Philippa :) *waves*
09:48:06 <jadrian> Philippa: right...
09:49:38 <Philippa> 'lo Calister
09:50:13 <Philippa> jadrian: I've no idea WTF to call them in a logic, sorry
09:56:10 <jadrian> Philippa: I just found some authors that call them propositional symbols. I had thought about that, but I have a book that includes variables in propositional symbols too. Anyway now a source I can cite if anyone complains.
09:58:27 <Philippa> I need to do more maths in general, sadly
10:03:46 * jadrian has a huge  "math to learn" list
10:05:18 <tintin> .
10:06:40 <Itkovian> @seen boegel
10:06:40 <lambdabot> I saw boegel leaving #Haskell 8 hours 37 minutes 16 seconds ago.
10:06:44 <Itkovian> dang
10:07:05 <hashwolf> hi.... is haskell a 4gl?
10:08:21 <hashwolf> ok, that's a no
10:08:48 <TheHunter> 4gl?
10:14:18 <TheHunter> @foldoc 4gl
10:14:19 <lambdabot> *** "4gl" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
10:14:19 <lambdabot> 4GL
10:14:19 <lambdabot>      
10:14:19 <lambdabot>         {fourth generation language}
10:14:21 <lambdabot>      
10:14:23 <lambdabot>      
10:15:08 <TheHunter> @foldoc "fourth generation language"
10:15:10 <lambdabot> *** "fourth generation language" foldoc "The Free On-line Dictionary of
10:15:10 <lambdabot> Computing (27 SEP 03)"
10:15:10 <lambdabot> fourth generation language
10:15:10 <lambdabot>      
10:15:11 <lambdabot>         <language> (4GL) An "application specific" language, one with
10:15:13 <lambdabot>         built-in knowledge of an application domain, in the way that
10:15:15 <lambdabot>         {SQL} has built-in knowledge of the database domain.  Pure
10:15:16 <lambdabot>         4GLs do not contain conditionals (if-then-else) and loops
10:15:19 <lambdabot> [29 @more lines]
10:15:32 <TheHunter> ok, no.
10:16:06 <TheHunter> @foldoc generation
10:16:07 <lambdabot> *** "generation" foldoc "The Free On-line Dictionary of Computing (27 SEP
10:16:07 <lambdabot> 03)"
10:16:07 <lambdabot> generation
10:16:07 <lambdabot>      
10:16:07 <lambdabot>         An attempt to classify the degree of sophistication of
10:16:10 <lambdabot>         programming languages.
10:16:12 <lambdabot>      
10:16:14 <lambdabot>         See {First generation language} -- {Fifth generation
10:16:16 <lambdabot> [5 @more lines]
10:17:11 <TheHunter> that's nonsense! why would a application specification language would necesarily be more sophisticated?
10:18:08 <SyntaxNinja> heh
10:18:32 <SyntaxNinja> what about an embedded DSL... I wonder which generation that is!
10:18:52 <Philippa> TheHunter: it's clearly bollocks /now/
10:19:14 <Philippa> unfortunately it was largely cooked up by folks who, for example, completely ignored lisp and FP until they decided they liked SQL as a vague derivative
10:19:43 <Philippa> (but eg note where FORTH's name came from)
10:20:18 <TheHunter> and they apperently thought the closer a language is to natural language the better it is.
10:20:37 <Philippa> *cough*COBOL
10:20:37 <Philippa> yeah
10:20:59 <Philippa> thing is, at the time COBOL wasn't bad...
10:33:13 <earthy> it still isn't, for some applications
11:13:40 <bourbaki> moin
11:13:58 <basti_> hi bourbaki
11:26:24 <SyntaxNinja> MegaMonad: how's it going?
11:26:25 <MegaMonad> SyntaxNinja: I don't need user privs, can i ask how's code, then it's nice to refactor some code to xanalogtv.
11:35:15 <Igloo> SyntaxNinja: H-U should have an unstable ghc6 now
11:35:37 <Igloo> IM stable
11:46:53 <SyntaxNinja> OK.  now who wanted that? heff?
11:47:42 <Igloo> Well, I was hoping you'd jump up and say "Cool, now I can make a stable darcs!", but if you'd prefer I can do one  :-)
11:48:28 <SyntaxNinja> oh yeah...
11:48:39 <SyntaxNinja> yeah, you should do one... I don't have a woody box
11:48:47 <Igloo> Rightyho
11:49:02 <SyntaxNinja> and no room on my laptop to make one. gotta get my tunes off of there, but I want to back them up
11:49:08 <SyntaxNinja> so I need to buy an external hard drive, but i'm lazy.
11:49:48 <Igloo> My desire for shinyness overcomes laziness - poorness is my problem  :-)
11:51:33 <SyntaxNinja> I'm a lazy miser
11:52:50 <Igloo> Hmm, do you know if libcurl3 (as opposed to 2) is really needed?
11:55:44 * CosmicRay returns
11:56:09 <CosmicRay> Igloo: couldn't you have just passed -static to ghc to build a darcs for stable? :-)
11:58:12 <Igloo> Possibly, but backporting ghc is mainly CPU cycles and very little effort, plus a few people use GHC itself on stable
11:58:58 <musasabi> getting a new stable would be much nicer ;)
11:59:10 * Igloo can't do that, unfortunately
12:00:28 * Igloo gets "Cannot find zlib.h" from darcs and wonders why it works in unstable
12:02:12 <SyntaxNinja> Igloo: libcurl2 should be fine
12:03:13 <SyntaxNinja> don't tell me I'm missing another build depends on zlib?
12:04:51 <basti_> @type singleton
12:04:53 <lambdabot> bzzt
12:06:25 <musasabi> CosmicRay: you had the ftp server implementation in MissingH?
12:06:51 <musasabi> CosmicRay: is that suitable for real work - or does it eat up all memory?
12:07:44 <Igloo> Oh, that reminds me, have you tested deflate, Cos? Just curious if it works properly or not  :-)
12:08:47 <Igloo> Bah, docs don't build
12:10:01 <musasabi> Igloo: from ghc snapshot?
12:10:14 <musasabi> Igloo: you need to take them out from the Makefile..
12:10:19 <Igloo> darcs docs
12:10:27 <musasabi> ah.
12:59:46 <lmbdwr> yop
13:09:31 <SyntaxNinja> y0
14:03:57 <Pseudonym> @yow
14:03:57 <lambdabot> Imagine--a WORLD without POODLES...
14:04:50 * Pseudonym checks back the last week of logs to see what he missed
14:06:00 <Pseudonym> jadrian: If you're still here, 0-arity connectives are called "CAFs".
14:06:42 <Pseudonym> Though that includes 0-arity connectives that are both reducible and irreducible.
14:41:59 <Calister> is there a command to remove last element of a list of chars?
14:42:23 <TheHunter> reverse . tail . reverse
14:42:44 <Calister> humm ^_^ thanks
14:42:51 <zamez> init
14:43:29 <Calister> oh!
14:43:35 <Calister> THANKS :D
14:43:35 <TheHunter> note that this is already as efficient as it can get because doing things at the end of lists is always inefficient.
14:43:37 <zamez> :>
14:44:50 <Calister> one day ima know all those commands myself ^_^
14:45:14 <TheHunter> wow, i didn't know such a function existed.
14:45:51 <Pseudonym> The Prelude is handy to know more or less by heart.
14:46:11 <Pseudonym> Even if you can't list all of the functions in it, knowing where to find them is a useful skill.
14:46:12 <TheHunter> don't tell me it's in the Prelude!
14:46:25 <TheHunter> @index init
14:46:25 <lambdabot> Data.List,GHC.List,Prelude,List
14:46:31 <Pseudonym> OK, I won't.
14:46:40 <zamez> hehe
14:47:22 <TheHunter> i really thought i knew all prelude functions heart.
14:47:39 <TheHunter> s/heart//
14:48:27 <Calister> i know i dont know em all.. i actually know that i know only a very lil
14:48:38 * TheHunter checks
14:48:55 <zamez> I admit I cheated
14:48:57 * SyntaxNinja cheers for Calister
14:49:01 <zamez> I knew the function existed
14:49:05 <zamez> but couldn't remember the name
14:49:10 <zamez> :)
14:49:33 <Pseudonym> I was using init before they sold out.
14:49:35 <zamez> head, tail, init, last
14:49:37 * zamez recites
14:49:53 <TheHunter> here's another one i didn't know: subtract
14:50:33 <monochrom> Oh haha wicked
14:54:33 * Calister thanks SyntaxNinja
14:54:39 <Calister> i told ya i would ask some stuff today
14:54:47 <Calister> ;)
14:55:36 <Calister> could someone tell me now what i was going to do next? O.o
14:57:09 <SyntaxNinja> Calister: write a Go playing AI engine in Template Haskell?
14:57:38 <monochrom> read some Richard Bird lectures or papers on init
14:57:41 <Marvin--> man I suck at administrating my computer
14:58:21 <Calister> welllllll... it was something with my homework... it somehow needs to be done still
14:58:26 <monochrom> init can be defined in terms of scanl or scanr (I forgot which). try it yourself.
14:58:59 <zamez> scanr snd  or so
14:59:01 <Calister> i like init.. i should make a top 10 of my fav commands
14:59:08 <Calister> some day
14:59:20 <monochrom> You will expand it to top 100 in no time.
14:59:24 <Calister> ^_^
14:59:28 <TheHunter> no, you shouldn't, it's evil.
14:59:32 <Calister> you think i will ever know 100 commands?
14:59:52 <SyntaxNinja> Marvin--: gimmy root, I'll fix it up
15:00:08 <monochrom> I know over a thousand Chinese characters and over several hundred English words.
15:00:20 <Pseudonym> Confusingly, list subtraction was spelled (--) in Miranda, analogous to (++).
15:00:24 <Pseudonym> Unfortunately, -- is a comment in Haskell.
15:00:25 <SyntaxNinja> oh, now I suddenly have to go to a meeting.
15:00:28 <Calister> how the heck do you store em all in your brain?
15:00:39 <Pseudonym> One of the few things which Miranda did a little more elegantly, IMO.
15:00:43 <Marvin--> hah
15:00:44 <SyntaxNinja> @type inits
15:00:45 <lambdabot> bzzt
15:00:45 <SyntaxNinja> @type init
15:00:46 <lambdabot> init :: forall a. [a] -> [a]
15:00:49 <Igloo> Why's that confusing?
15:00:49 * SyntaxNinja never uses init
15:00:53 <Marvin--> I gotta learn pam one of these days
15:01:00 <monochrom> I use over a billion neurons for that.  I think they are still under-used.
15:01:03 * SyntaxNinja meeting &
15:01:04 <Marvin--> for some reason su works but logging in on tty1 doesn't
15:01:05 <Pseudonym> It's confusing if you had to know both languages.
15:01:08 <Pseudonym> Which I did, for a while.
15:01:15 <Igloo> Ah, right
15:01:20 <Pseudonym> I did coursework in Miranda, but private project stuff in Gofer.
15:01:29 <Pseudonym> Which was close enough to Haskell 1.3.
15:04:42 <Darius> Pseudonym: The sick, but convenient thing, is -- is a comment --> is an operator.
15:05:00 <Pseudonym> Yup.
15:05:07 <Pseudonym> Mind you, in Miranda, || was a comment.
15:05:08 <wli> heh
15:05:11 <Philippa_> is it by default, or only when the operator's declared?
15:05:12 <Pseudonym> I'd rather have it as or.
15:05:23 <Pseudonym> Philippa_: By default.
15:05:35 <Darius> Philippa_: If it were only when an operator is declared, it'd be even more sick.
15:05:48 <Pseudonym> There is no feedback between the semantic analyser and the lexical analyser in Haskell.
15:05:59 <Pseudonym> (Not like in C.)
15:07:07 <zamez> tsk, don't you write all your scripts as .lhs ?
15:08:04 <Pseudonym> Nope.
15:08:12 <zamez> :>
15:08:27 <Pseudonym> Only some of them.
15:08:41 <Pseudonym> Though I do think that TeX-style literate scripts are evil.
15:09:02 <Pseudonym> It's like Lisp.  It _looks_ like literate programming, but it's not even close.
15:09:14 <Pseudonym> Lisp looks like functional programming. :-)
15:10:34 <Pseudonym> Actually, that's unfair.
15:10:46 <Pseudonym> Lisp is functional programming, but it _looks_ like lambda calculus.
15:10:49 <Marvin--> lisp looks like lots of .... parentheses
15:14:51 * Marvin-- swears
15:15:07 * Calister yawns
15:15:44 <Calister> someone please code a proggy which codes proggies for me
15:16:42 <Cale> Calister: There are lots of those. They're called compilers.
15:17:21 <Calister> well.. i thought of an advanced version ;)
15:17:42 <Calister> i feed it with the homework paper and it spits out the answers
15:18:31 <Pseudonym> Calister: I have one of those.  There is some manual work required.
15:18:42 <Pseudonym> It's called a rootkit.  Oh, you also need access to the lecturer's machine.
15:18:53 <monochrom> I am working on that, slowly.  Will take some decades.
15:19:11 <Calister> lol
15:19:15 <monochrom> meanwhile read some Richard Bird papers.  Some ideas come from there.
15:19:43 <Calister> Pseudonym: the prob is that my prof makes nearly as many mistakes as i do.. and his examples aint always working either
15:20:01 <monochrom> He has a method of identifying optimization problems that are susceptible to greedy solutions, and then generating the solutions.
15:20:32 <Calister> monochrom: if you ever finish the prog, millions of students will worship you
15:20:51 <monochrom> I know.  But if they have half a brain, they should not.
15:21:14 <monochrom> Such a program means the end of their careers.
15:21:30 <Pseudonym> Personally, I think most CS exams should contain only one question.
15:21:41 <monochrom> of course, that is precisely my motivation.
15:21:52 <Pseudonym> Q1.  What languages should you learn to get a good job?
15:21:57 <Pseudonym> Anyone who answers the question fails.
15:22:10 <Marvin--> :)
15:22:15 <monochrom> I answer "the language of mathematics".  Do I fail?
15:22:25 <Pseudonym> OK, let me rephrase.
15:22:38 <Marvin--> monochrom: yes, with extra credits for being silly!
15:22:43 <Pseudonym> monochrom: Yes, because your answer is incomplete.
15:23:05 <Pseudonym> Besides, there is no one language of mathematics.
15:23:32 <Calister> could someone tell me why the heck i didnt give up with this homework yet?
15:23:44 <Pseudonym> Calister: Because you're too smart to know when to quit.
15:23:48 <monochrom> because it is just the beginning of the term
15:23:52 <Calister> lol
15:24:10 <Calister> i like yer answer Pseudonym ;) makes me try harder to get it working
15:24:16 <monochrom> if you give up this early, you may as well go to Switzerland and ski for three months
15:24:21 <Calister> monochrom: its middle of term for me
15:24:25 <Calister> :o
15:24:38 <Calister> hey, that idea sounds very sweet
15:25:14 <Calister> hmm.. okay.. stupid question: how do i get my prog to read out a textfile?
15:25:17 <ozone> Pseudonym: "The language of love"?
15:25:48 <Pseudonym> ozone: That depends whether or not you consider the resulting career options "good" or not.
15:26:23 <Calister> "sex" .. mostly helps with career if you are female
15:26:27 * Pseudonym notes that the previous sentence was developed with the assistance of the Department of Redundancy Department.
15:26:44 <Calister> but ermm thats not the way i wanna start my career
15:26:53 <monochrom> main = do { s <- readFile "my_text_file"; putStrLn s }
15:28:07 <Calister> hmmm
15:28:55 <monochrom> Talking about redundancy.  We all know that people say "ATM machines".  Well at least that is not as bad as "ATM teller machines", and I thought no one would ever do something that bad.
15:29:26 <Philippa_> wait 'til it's automatic ATM teller machines
15:29:32 <monochrom> But I was wrong.  Some lambda calculus folk writes, "the SOS operational semantics".  (SOS = structured operational semantics)
15:29:43 <ozone> this is why you should just say "atoms"
15:29:50 <ozone> totally unambiguous++
15:30:04 * Calister ponders
15:30:08 <Calister> thanks monochrom
15:30:31 <Calister> i think you just managed to help my brain link some infos ^_^
15:32:17 <Pseudonym> ozone: Actually, saying "atoms" is not ambiguous, it's inconsistent.
15:32:39 <Pseudonym> Neither real-world atoms, nor Lisp/Prolog-style atoms, are actually atomic.
15:32:47 <Marvin--> *gasp*
15:33:20 <Pseudonym> Even Lisp has getprop and putprop.
15:34:33 <monochrom> My computer has all the Prelude functions memorized.  She's my trusty secretary.
15:34:46 <Pseudonym> You should get yourself a memex.
15:35:29 <ozone> Pseudonym: i bet ATMs aren't atomic either
15:35:39 <ozone> must be plenty o' folks who've been robbed by them
15:36:10 <Darius> Hmm, good quote, "Refering to the typed lambda calculus as 'plain ol' code' may be a sign that I need to re-examine some of my prejudices about formalisms" - Luke Gorrie
15:37:52 <Riastradh> Pseudonym, only old, crufty Lisps still use symbol property lists.
15:39:05 <Darius> Riastradh: Doesn't Common Lisp still have them?
15:39:20 <Riastradh> Yes.  That doesn't contradict what I said.
15:39:51 <Darius> Is "old, crufty" supposed to be interpretted as a conjunction or a disjunction?
15:40:04 <Riastradh> There are some much more modernized aspects of Common Lisp, of course, but much of the language is still based mostly on Maclisp.
15:40:08 <Riastradh> Conjunction.
15:40:52 <Darius> What's a newer (widely used) Lisp that CL (except for ISO Lisp for some definition of widely-used)?
15:41:35 <Riastradh> Scheme
15:41:42 <Darius> Scheme is older than CL.
15:42:53 <Riastradh> Yes, but my answer to your previous question was 'conjunction.'
15:43:53 <Pseudonym> I did say "Lisp-style atoms".
15:44:07 <Darius> Yes, I didn't disagree.  But your answer to my latest question is simply false.
15:44:23 <Pseudonym> Though Scheme atoms are still not atomic.
15:44:26 <Pseudonym> You can break them apart.
15:44:30 <Riastradh> Oh, sorry, I missed the 'newer.'
15:44:46 <Pseudonym> Free cakes.  BBIAB
15:44:55 <Riastradh> Pseudonym, wrong: you can convert them to strings, & strings to them, but there's no EXPLODE or IMPLODE like in Maclisp.
15:48:02 <SyntaxNinja> Calister: want to see my "cat" example in Haskell?
15:49:56 <Marvin--> SyntaxNinja: so assume that you did have root on my computer, how would you fix it? ;)
15:52:30 <Calister> "cat" example?
15:52:41 <Darius> inFile =^.-= outFile = readFile inFile >>= writeFile outFile
15:53:03 <Calister> O.O
15:53:09 <Marvin--> ah, the meow operators
15:53:26 <Darius> @type let a =^.^= b = a in =^.^=
15:53:27 <lambdabot> bzzt
15:53:57 <Darius> @type let a -^.^- = b = a in -^.^-
15:53:59 <lambdabot> bzzt
15:54:11 <Darius> @type let a -^.^- b = a in -^.^-
15:54:12 <lambdabot> bzzt
15:54:43 <Marvin--> @type let a -^.^- b = a in (-^.^-)
15:54:44 <lambdabot> let a -^.^- b = a in (-^.^-) :: forall t t1. t -> t1 -> t
15:54:45 <Darius> Damn heirarchical modules extension.
15:54:49 <Marvin--> you need parentheses
15:54:55 <Darius> Damn me not remembering parens.
15:54:59 <Marvin--> :)
15:55:09 <Calister> ;o
15:55:10 <Darius> @type let a =^.^= b = a in (=^.^=)
15:55:11 <lambdabot> let a =^.^= b = a in (=^.^=) :: forall t t1. t -> t1 -> t
15:55:54 <Calister> you think my prof will let me pass class if i draw cats all over the exam paper next time? ^_^  
15:56:25 * Marvin-- gives up and wanders off to dream nightmares of broken pam settings
15:56:34 <Calister> ni ni Marvin--
15:56:45 * Calister aint giving up yet
15:56:55 <Darius> Calister: If they define the correct functions for the problem, probably.
15:57:50 <musasabi> A
15:57:53 <Calister> i needa hand in homework in 9 hours. my first class starts in 7 hours. i need one hour to go to university. So i still have 6 hours to get smart, get this homework done, sleep, eat breakfast and shower
15:59:04 <Calister> Darius: also depends if prof really means what he writes or even knows the correct answers
16:00:14 <SyntaxNinja> Calister: do you know the unix command 'cat'?
16:00:19 <SyntaxNinja> marvin disappeared
16:00:59 * Darius wonders how many cryptography students return zero-knowledge proofs that they have the correct answer to a question.
16:01:13 <Calister> yep
16:01:41 <SyntaxNinja> Calister: so I recently decided that "cat" is a great example of how to do practical stuff in Haskell, and just posted about it to my blog: http://blog.syntaxpolice.org/isaac/index.cgi
16:01:47 <SyntaxNinja> </shamelessPlug>
16:01:56 <SyntaxNinja> because everyone wants to know how to use getArgs and readFile
16:02:19 <SyntaxNinja> and for extra "points" you should send me the points-free version ;)
16:02:28 <Calister> our prof is funny - in a no good way. he aint able to hand out a paper which is free from bugs, but overloads us with questions in exam (and there were 2 bugs in it too)
16:03:35 * Calister bookmarks
16:04:30 <Darius> SyntaxNinja: Wasn't Haskell pragprog's recommendation for the language to learn for the year last year.
16:05:03 <Darius> Now that's a preposition phrase to be proud of.
16:05:04 <SyntaxNinja> Darius: really? I didn't konw they did that.
16:05:14 <Igloo> We had an influx of PPers
16:05:38 <SyntaxNinja> I just read the book, and am not involved w/ the PP community
16:05:54 <Darius> http://www.pragmaticprogrammer.com/loty/
16:06:36 <Igloo> I'm not involved with them beyond having been in here when they invaded  :-)
16:07:01 <Igloo> Do you know epigram? That is worth a look, although don't expect it to be usable
16:07:39 <SyntaxNinja> ie 2002 before I knew haskell or tPP ;)
16:07:50 <SyntaxNinja> epigram? no, I don't.
16:08:09 <SyntaxNinja> so far I only got a 'ruby' recommendation
16:09:31 <Calister> i heard bout Ruby
16:09:37 <Calister> someone told me its easy to learn
16:11:23 <Igloo> AFAIK Ruby won't teach you anything particularly new unless you are new to OOP
16:11:55 <Calister> hmm
16:12:01 <Calister> maybe i should learn it then
16:12:10 * Calister has quite some troubles with OOP
16:12:30 <Philippa_> which languages've you been subjected to OOP in?
16:12:48 <Philippa_> 'cos some of them do a really awful job of teaching it
16:13:04 <Calister> i gotta understand java
16:13:06 <Igloo> I just learnt XSLT, which was an interesting experience
16:13:11 <Calister> and its my hate-language
16:13:14 <Philippa_> you too, huh?
16:13:19 <ozone> Igloo: :}
16:13:27 <ozone> Igloo: "the world's most mediocre language"
16:13:30 <Philippa_> I mean, I can code in it, but it finds a new way to piss me off about once every ten lines I write
16:13:44 <Igloo> It's almost quite nice, until you try to do anything complicated when you realise there just aren't /quite/ enough features/flexibility
16:13:44 <Calister> yes!!
16:13:46 <jdrake> where can I find information about making a C extension for haskell? (ghc)
16:13:55 <Calister> esp the msgs >_>
16:14:04 <Calister> "error - no such error"
16:14:09 <Calister> fuck you too java!
16:14:11 <Igloo> XSLT 2 will fix some of the problems, but I think fundamentally you need to be able to do higher order things that AFAIK it won't address
16:14:30 <Philippa_> Calister: that a run-time error or a compile-time one?
16:14:35 <Igloo> The attraction for me was an entirely portable (server-wise) dynamic webpage
16:14:45 <Lemmih> jdrake: You want to call C functions from Haskell?
16:14:54 <jdrake> that is correct
16:15:00 <Darius> Philippa_: Every ten lines?  Why almost every line is painful for me in Java.
16:15:09 <jdrake> I would prefer as a dynamically loadable library
16:15:12 <Darius> Well, I guess, the empty line is okay.
16:15:23 <Philippa_> maybe { and } lines, too
16:15:26 <Calister> Philippa_: luckily it happened ages ago.. and i forgot it as fast as possible.. but i think it was compile-time one
16:15:48 <Philippa_> Darius: the big thing is that it finds /new/ ways to be painful every ten lines
16:15:48 <ozone> jdrake: see the GHC documentation, and http://www.reid-consulting-uk.ltd.uk/docs/ffi.html
16:15:54 <Philippa_> I really, really don't like Java :-)
16:16:04 <Lemmih> jdrake: I would suggest that you use a preprocessor like GreenCard, c2hs or hDirect.
16:16:06 <Calister> i was able to get along with basics of PROLOG, i am able to cope with Haskell, but Java.. no thanks
16:16:13 <Darius> Philippa_: Okay, I'm not sure whether I beat that or not.
16:16:17 <Philippa_> I think the fact it was the chosen language for our compiler implementation course didn't help
16:16:17 <Lemmih> jdrake: But it's also possible to use the Haskell FFI directly.
16:16:18 <ozone> jdrake: you should be able to dynload too, just import the dlopen() call and call that ...
16:16:19 <Calister> i just can agree.. Java is a pain
16:16:43 <Darius> Philippa_: Often I find I'm writing the samething on the 10th line that I have on the previous lines so I haven't yet gotten to something new ;)
16:16:58 <Philippa_> Calister: do you know which parts about it bug you? I know of many, many inconsistencies and things that only make sense if you think somewhat twistedly in a subjected-to-too-many-C-likes kinda way
16:17:32 * Philippa_ has a fundamental issue with the separation between the intrinsic types and objects-that-are-also-reference-types, for example
16:17:35 <Darius> Lemmih: So far, I've actually preferred the "raw" FFI interface.
16:17:55 <Philippa_> by comparison, I actually quite liked the look of smalltalk though I CBA to actually code in it
16:18:14 <Lemmih> Darius: I've found it bug prone and overly verbose.
16:18:23 <Calister> Philippa_: i started with pascal - never really understood much of it, then i had C - and suddenly i saw how much i actually understood pascal, and then they try to make me understand OOP by teaching me java. and that somehow didnt work.
16:18:29 <Philippa_> I suspect it depends on what you're interfacing to
16:18:32 <Calister> java has too many commands
16:18:40 <Calister> its like.. overloaded
16:18:47 <Philippa_> yep
16:18:47 * ozone humbly suggests LOTY be objective-c
16:19:04 <ozone> boring language, but its libraries are just so, so nice
16:19:29 <Philippa_> Calister: do you have a good reference on Java-the-language (as opposed to Java + standard libraries)?
16:19:32 <Philippa_> that helps somewhat
16:19:38 <Lemmih> Darius: But yes, they leave something to be desired which is why I made Hacanon.
16:19:44 <Calister> Philippa_: not really
16:20:07 <jdrake> ozone, that page does not seem to tell me anything. I need an actual example too. I have tried to compile GreenCard before but no success.
16:20:20 <Philippa_> Java in a Nutshell is good for that, and ignoring all the library stuff to kick off with'll help keep the number of concepts you need to think in Java reasonably small
16:20:35 <ozone> jdrake: did you see the ghc docs?
16:21:41 <Calister> Philippa_: Thanks :) Ima try it that way next term
16:21:58 <ozone> jdrake: otherwise, just see the actual FFI spec, which is fairly easygoing
16:21:59 <ozone> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
16:22:10 <ozone> (i learnt from that + GHC docs, and i grokked it, so it can't be that bad ;)
16:22:35 * Philippa_ dislikes "everything is an object"-style thinking taken too far, in that it tends to blur all the useful concepts into a big bess
16:22:36 <Philippa_> *mess
16:22:57 <Philippa_> but yeah. I should get off my arse and implement Tyop so I can show people a reasonable alternative :-)
16:23:29 <jdrake> I will try the stuff they have there. Almost all of the stuff for haskell that I have tried to compile has been extremely biased towards linux or windows and crashes and burns on osx.
16:23:31 <Calister> its funny.. i get used to everything but OOP
16:23:42 <Calister> i thought i would never be able to write progs in haskell
16:23:52 <Calister> but woohoo.. i can do it
16:24:13 <Calister> wb igloo
16:24:24 <Philippa_> Calister: taking a really, really pure approach to OOP might help - Smalltalk, perhaps
16:24:52 <Philippa_> one of the problems with Java is that it's too busy trying to be FP-that-looks-like-purist-OO-that-reads-like-C
16:25:11 <ozone> objective-c is basically smalltalk with C
16:25:13 <SyntaxNinja> heh
16:25:14 <Darius> Philippa_: Well it depends on how object is defined.  But yes class/object are massively overloaded in the concepts the represent (modules, subtyping, subclassing, namespaces, etc.)
16:25:24 <jdrake> Am I looking for stuff on foreign import?
16:25:27 <Darius> (in most languages)
16:25:32 <ozone> jdrake: yes
16:26:34 <Darius> Philippa_: In what way is Java "FP" anything (or trying to be that)+
16:26:35 <Philippa_> Darius: I may have Tyop support a concept of "object" as a bit of syntactic sugar if I can't implement it reasonably as a library sitting in the IO monad or equivalent - I suspect it'll turn out to be little more than exposing some-but-not-all field selectors on a record though
16:26:44 <Philippa_> Darius: anonymous classes
16:26:56 <Philippa_> aka the most painfully verbose lambdas I've ever used
16:27:10 <Darius> Philippa_: Besides that? and that isn't unreasonable for a OOP language.
16:27:21 <Darius> And yes, they are extraordinarily painful.
16:27:23 <Philippa_> it is when you can just have block objects :-)
16:28:16 <Philippa_> and yeah, it's not that much otherwise aside from eg the fashion for immutable objects
16:32:18 * Darius has also decided that any decent language needs a lambda-like construct that closes over free variables.
16:34:54 <fragbot> is there anyway to have hugs accept function definitions *in* the toplevel?
16:35:31 <musasabi> Is there a performance penalty associated of using combinators like liftM4 instead of do blocks?
16:35:39 <Igloo> Darius: "closes over"?
16:36:26 <dons> musasabi: look at the generated Core code (-ddump-simpl or -fext-core)
16:37:27 <dons> fragbot: you could use ghci instead
16:37:53 <fragbot> okay, thanks
16:38:26 <Darius> musasabi: Since GHC is very keen about inlining, very likely no. (with GHC).
16:38:52 <Darius> Igloo: Respects lexical scope.
16:39:28 <Darius> As in 'let a = 4 in \b -> a + b' \b -> a+b closes over 'a'.
16:39:38 <Igloo> *nod*
16:43:43 <musasabi> seems that works fine..
16:43:44 <Pseudonym> Cakes are like sex.  Better when they're free.
16:44:41 <Igloo> Where as free variables are a venemous horror poised to bite you when you least expect it
16:45:00 <musasabi> Is there a preludefunction like append :: [a] -> a -> [a], append l e = l ++ [e] ?
16:45:32 <Calister> and where is my piece of cake?
16:45:34 <Darius> Pseudonym: It's an axiom of human nature that free food is reason enough to go to any social occasion.
16:45:40 <Pseudonym> Indeed.
16:45:50 <Pseudonym> My mother taught me: Never pass up free music or free food.
16:46:00 <Pseudonym> She's a musician, so she's kind of biassed on the first point.
16:46:08 <Igloo> musasabi: It would hardly seem worthwhile
16:46:29 <Igloo> And in the wrong hands will lead to inefficiency, of course
16:48:10 <dons> musasabi: you could use difference lists for O(1) append, providing snoc.
16:48:16 <dons> there's a lib in yi.
16:48:37 <Pseudonym> Difference lists in Haskell are spelled differently.
16:49:04 <Pseudonym> The type of a difference list in Haskell is [a] -> [a]
16:49:06 <musasabi> true - but these lists should be <15 elements so it shouldn't matter too much.
16:50:03 * Igloo tries to remember what features I wanted from a list-like structure while sensible people to ask are around
16:50:18 <Pseudonym> Igloo: Yes, do tell.
16:50:29 <Darius> Igloo; According to Hinze, you should look at Finger Trees.
16:50:39 <Pseudonym> According to Hinze, you should derive your own.
16:51:05 <Igloo> Oh, I remember. I want to be able to do cons, init and iterate down the list
16:51:21 <Pseudonym> You mean you want queues.
16:51:54 <Igloo> Yes, but the queue made of 2 lists where you occassionally reverse one doesn't give you the iteration property does it?
16:52:09 <wagle> doesnt okasaki define queues
16:52:10 <wagle> ?
16:52:18 <Pseudonym> Igloo: Sure it does.
16:52:23 <jdrake> Does anyone know of a software package that is a (small) C extension to haskell using standard FFI that I can try to get working? I have looked over everything linked from this # and still can't get a complete idea of how to do things.
16:52:37 <Pseudonym> Popping an element off a queue is an O(1) operation (amortised).
16:52:44 <Pseudonym> So repeatedly popping gives you iteration.
16:52:50 <Igloo> When I iterate I'm not taking things off
16:53:09 <Pseudonym> Well, no, you're not.  But do you care?
16:53:13 <Lemmih> jdrake: Take a look at the FFI documentation.
16:53:23 <Igloo> Do I care what?
16:53:25 <Pseudonym> It's a declarative data structure.  You take elements off and you can still keep the original data structure.
16:53:52 <jdrake> Lemmih, I just did
16:54:33 <Darius> Well, with the 2-lists version of queues (or at least the simplest way) persistent use will lead to inefficiency. (if I remember correctly).
16:54:43 <Pseudonym> Darius: Sort of.
16:54:54 <Pseudonym> It depends what operations you are doing.
16:54:54 <Lemmih> jdrake: Then what's the problem?
16:55:01 <musasabi> jdrake: http://www.cs.helsinki.fi/u/ekarttun/haskell/qdbm/Depot.hs
16:55:09 <Pseudonym> The set of operations that Igloo wants are fine, AFAIK.
16:55:52 <musasabi> The inefficiency occurs iirc bacause it has a boundary.
16:56:08 * Calister yawns
16:56:20 <Igloo> But the wrong sequence of operations will give you the same performance as just appending to a list
16:56:53 <Igloo> (or worse performance depending on how you do it)
16:57:19 <Igloo> push, iterate, repeat I think
16:57:37 <jdrake> Lemmih, the problem is that I don't see how it all fits together. I will try with this depot.hs thing
17:09:54 <musasabi> Has anyone got example code for parsing a continuous stream of data with parsec from a handle (tcp socket in this case)
17:12:07 <Nioate> hGetContents, then parse it like a normal string?
17:12:41 <musasabi> Nioate: but how do I act on each message before the whole stream is parsed?
17:13:07 * Pseudonym makes a note: Nobody wins a game of "let's try to stump Oleg"f.  Except for Oleg.
17:13:49 <Darius> Yeah, I was pretty surprised you tried.
17:14:05 <Pseudonym> I was actually more interested in what Conor had to say.
17:14:19 <Darius> Though I was interested in what kind of things that were perceived (or may be) an issue.
17:14:26 <Pseudonym> Right.
17:14:29 <Pseudonym> That's why I raised it.
17:14:42 <Pseudonym> I actually wasn't trying to stump Oleg.  I was trying to understand where Conor saw a problem.
17:15:49 <Nioate> musasabi: hm
17:16:31 <monochrom> There is a way to make sure parsec gives you stuff as soon as it sees the necessary part of the stream.
17:17:24 <musasabi> Basically I have "many message" and want to perform an IO action for each message.
17:17:34 <musasabi> monochrom: hmm?
17:20:14 <monochrom> "many" has that property, IIRC.
17:24:17 <musasabi> but the parser functions produce "Either ParserError a" so they need to evaluate the whole stream to detect whether the parse fails or not.
17:26:40 <monochrom> Right.  Now let me try an experiment.
17:30:37 <monochrom> I guess you will not use "many".
17:30:55 <Darius> musasabi: Perhaps returning the rest of the input with the result and repeatedly calling runParser (or whatever).
17:31:27 <Darius> Though you may still have an issue with lookahead.
17:31:54 <musasabi> Darius: but the interface does not support a notion of the "rest of the input not parsed" does it?
17:32:13 <Nioate> getInput
17:32:51 <Nioate> more like do {msg <- message; input <- getInput; return (msg,input)}
17:33:02 <musasabi> hmm nice.
17:33:16 <Darius> liftM2 (,) message getInput
17:33:29 <monochrom> Hahaha
17:35:15 <Nioate> yes. that is pretty cool
17:36:05 <wli> ghci is bust on alpha now too
17:36:22 <wli> I've set up simonmar to log in on these boxen
17:37:22 <monochrom> neato
17:38:49 <wli> I shelled out money for these boxen so they could be used to make stuff work on linux, including userspace, so it's great that I've been able to set up accts for ppl
17:39:12 <wli> there was some mlton problem one of the mlton ppl fixed that way
18:03:52 <musasabi> Parsec works except for one tiny detaul - getInput blocks waiting for the first byte of the next packet. I think I can build something to overcome that too...
18:04:14 <Darius> Yes, that was the look ahead issue I was talking about.
18:04:57 <Darius> The issue is whether you can know the end of the message without reading the byte beyond it (though I don't know if Parsec will look ahead anyways, but I doubt it).
18:06:15 <Darius> For example, if you were matching space separated words, matching "foobar" would require checking that there is a space following it, not a 't' for example, but something with syntax &#602;Flike "(foobar)" seems like it would work.
18:06:37 <musasabi> I don't need that - so it should be possible to actually do that.
18:08:28 <Darius> musasabi: Note that many Char parsers remove either leading or trailing whitespace, if it's the latter than that will be an issue.
18:13:18 <musasabi> using getInput before the last char works (and then using tail to get to the correct position)
18:13:30 <Pseudonym> Well, I just finished the "do homework" program.
18:13:37 <Pseudonym> It was actually fairly easy to write.
18:14:05 <Pseudonym> What it does is composes an email to haskell-cafe claiming that the following problem can't be solved at the type level: <<insert homework problem>>
18:14:14 <Pseudonym> It then scans the list for posts by Oleg which reply to that.
18:14:29 <arjanb> lol
18:14:41 <Pseudonym> Finally, it extracts the resulting Haskell code and translates it from the meta-level into actual Haskell.
18:14:42 <morbidi> does somebody use runhugs?
18:15:11 <Lemmih> Yes.
18:16:00 <morbidi> Lemmih: how do you use runhugs? 
18:16:06 <morbidi> like bash?
18:17:08 <Lemmih> Oh wait. I misread 'runhugs' to 'runghc'.
18:18:01 <morbidi> ok
18:18:01 <Darius> Pseudonym: How is the type-level to term-level translation accomplished seeing as the type level is a logic language.
18:18:18 <musasabi> Thanks for help. Now => sleep.
18:19:35 <Pseudonym> Darius: Well first it checks for fundeps.
18:19:47 <Pseudonym> But the thing is, Oleg's meta-programs tend to be strongly moded.
18:20:00 <Pseudonym> So a little trivial in/out mode analysis is usually all you need.
18:20:24 <Pseudonym> So it's not perfect.  If he discovers a new technique which _isn't_ strongly moded, I'll need to write an untyped Mercury interpreter.
18:58:11 <Darius> What's a good way to get a link to the anchor of a comment in a LtU thread?
19:04:43 <Pseudonym> Darius: Easiest way I can think of is to search for it.
19:11:23 <bourbaki> moin
19:15:46 <Darius> Pseudonym: I may post on site discussions about making the comment titles links (that just go to themselves, but I'd find it convenient).
19:18:28 <Pseudonym> Right.
19:18:33 <Pseudonym> I'd find that convenient too.
19:18:43 <Pseudonym> Or even a little icon.
19:21:24 <Calister> ni ni
19:21:30 <Calister> two hours of sleep
19:21:31 <Calister> weeee
19:21:32 <Calister> :s
19:22:52 <Pseudonym> Oh, what sad times are these when passing ruffians can se "ni ni" at will to Haskell programmers.
19:23:11 <Calister> ;o
19:24:26 <Calister> i like "ni ni".. i say it >_<
19:24:31 <Calister> narf
19:24:32 <Calister> :x
19:24:35 <Calister> g'nite!
19:30:01 <jdrake> how does one get information for file permissions that covers the range of unix permissions when Permissions seems to only accept readable, writable, executable, and searchable? 
19:50:17 <dons> jdrake: -packagee unix, see System.Posix.Files
19:56:41 <sunstinks> hey
19:56:48 <sunstinks> can haskell handle business websites?
19:56:48 <Lemmih> Greetings.
19:57:27 <Lemmih> I haven't seen it done before but it should be possible.
19:58:35 <Darius> Hell, if Perl can do it ;)
19:59:29 <Darius> sunstknis: Why wouldn't Haskell be able to do it?
20:00:25 <Darius> Lemmih will answer, bye.
20:01:44 <Lemmih> sunstinks: You can take a look at WASH and Hemplate.
20:09:22 <jdrake> Posix.Files doesn't seem to have much documentation in its data types. Such as "data CMode", which says absolutely nothing to me as to what that is. I see there is a fileMode that I should be able to get the permissions from, but it returns a FileMode that leads to the CMode. I don't see any information on what I do with that.
20:11:31 <autrijus> ugh.
20:11:31 <autrijus>     Illegal overloaded type signature(s)
20:11:32 <autrijus>         in a binding group for lookupSize, lengthOf, memberSize
20:11:32 <autrijus>         that falls under the monomorphism restriction
20:12:06 * autrijus reads about this mythinc monoporphism restriction
20:12:15 <autrijus> mythic, even
20:12:48 <Pseudonym> @wiki MonomorphismRestriction
20:12:48 <lambdabot> http://www.haskell.org/hawiki/MonomorphismRestriction
20:13:33 <wagle> @wiki Monomorphism
20:13:34 <lambdabot> http://www.haskell.org/hawiki/Monomorphism
20:13:37 <wagle> hm
20:14:09 <autrijus> oh.
20:14:11 * autrijus discovers -fno-monomorphism-restriction
20:16:21 <autrijus> hmm with that flag it spews some even more bizzare "cannot unify" errors
20:16:27 <autrijus> oh well. I'll just inline the function twice.
20:16:41 <Pseudonym> Another option is: supply a type signature.
20:16:49 <autrijus> I can't seem to work out the signature.
20:17:02 <Lemmih> jdrake: CMode is just an unsigned 32 bit int.
20:17:05 <autrijus> this is inside a (Data a) => context
20:17:10 <Pseudonym> Then you shouldn't be writing Haskell code.  Back to #scheme with you!
20:17:16 <autrijus> and the inner context is (Data a, Typeable [a]) =>
20:17:26 <autrijus> heh.
20:17:32 <autrijus> I can work out the signature in my head just fine
20:17:36 <autrijus> I just can't explain it to haskell.
20:17:49 <sunstinks> hey
20:17:58 <sunstinks> do you guys use haskell in place of say perl?
20:18:22 * autrijus is rewriting a huge chunk of perl library in 200 lines of haskell.
20:18:27 <Pseudonym> No.  If the evil mangler was written in Haskell it'd be less evil.
20:18:39 <Pseudonym> To preserve evilness, we use Perl/
20:18:41 <autrijus> it will be the Good Preacher, or something.
20:19:37 <jdrake> Where might I find the information on this CMode values?
20:21:40 <jdrake> chmod(2) refers to a sys/stat.h with values in it
20:26:29 <shapr> Warning: memory in use exceeds lisp pointer size \n Killing some buffers may delay running out of memory. \n However, certainly by the time you receive the 95% warning, \n you should clean up, kill this Emacs, and start a new one.
20:26:30 * shapr grumbles
20:27:01 <Gahhh> wow
20:27:27 <Gahhh> and I thought I was a heavy duty emacs user. I never got that warning.
20:28:05 <shapr> I had the #emacs record for number highest of loaded elisp libraries for at least a year :-)
20:28:21 <ozone> shapr: 640K should be enough for anybody
20:28:29 <shapr> 640K petabytes?
20:28:47 <autrijus> 640 kilograms of DRAM
20:29:08 <jdrake> 640 metric tons of EEPROM
20:29:39 <autrijus> I like nonvolatile nanotube rams better.
20:32:45 <sunstinks> hmm
20:32:47 <sunstinks> hey
20:32:58 <sunstinks> do you guys have a web page written in haskell handy?
20:33:11 <sunstinks> is haskell usible for business apps like ebay?
20:33:24 <shapr> yup
20:33:31 <wagle> i have a friend who writes CGI in fortran..
20:34:11 <shapr> http://www.scannedinavian.org/cgi-bin/hackage/hackage, http://www.acooke.org/, and  http://www.scannedinavian.org/output/index.html use Haskell.
20:34:15 <wagle> galois connections does web stuff in haskell
20:37:52 <wagle> shapr: ipv6 got any facility for restoring tcp connections after one end reboots?
20:38:07 <wagle> .. that you already know of?
20:39:04 <shapr> I vaguely recally reading about that sort of thing, but I'm not sure if was restore across reboot or restore across ifdown/ifup
20:39:22 <shapr> I do think you can migrate connections to another interface.
20:39:23 <wagle> (as a minor challenge, i'm seeing how persistant i can make my irc session)
20:40:05 <shapr> sounds like fun
20:40:09 <wagle> well, you'd have to do something like authenticate yourself to the other end to find out what sequence numbers to use, etc
20:41:02 <wagle> else you'd have to checkpoint your tcp state to disk or something
20:41:26 <Pseudonym> shapr: You should use Yi.
20:41:29 <Pseudonym> :-)
20:41:31 <wagle> dont wanna make this a way for someone to hijack your connection..
20:41:38 <shapr> Pseudonym: no kidding :-)
20:41:53 <wagle> is Yi big enough?
20:42:07 <wagle> 640 metric tons of eeprom is a lot...
20:42:30 * shapr reads about three dimensional penrose tiles
20:43:16 <wagle> want 11 dimensional?  (who you reading?)
20:43:52 <shapr> Nah, I'm looking for various ways to tile three dimensional shapes.
20:44:41 <shapr> there are thirteen three dimensional shapes that with only themselves, and there are penrose tiles using squashed cubes. Is there already a way to find tiling pairs, triples, etc of shapes?
20:45:20 <shapr> It's just an idle interest, but I'd like it if computers of the future were tiled chunks so I'd never run out of PCI slots.
20:46:54 <shapr> I've thought about using the asymmetric multiprocessing support in Linux for such a system, would be neat to recompile at runtime for a new CPU and hotplug it. I wonder if smalltalk-style image based systems would act like sourdough cultures where you bud your system and send the bud to your friends :-)
20:48:31 * SamC_ suspects shapr has lost it
20:48:33 <shapr> I wonder if one set of tiled shapes has advantages over others for communication among components or other advantages.
20:48:46 <shapr> SamC_: whaddya mean? :-P
20:49:10 * ozone reckons shapr should build a meta-box based on SGI's HyperCube and make $$$$$
20:49:12 <SamC_> that sounded like megamonad to me ;-)
20:49:59 <shapr> SamC_: well, if Wal-Mart sold computer components as cubes, then whenever you need more CPU power or more RAM, or another drive, you just buy a cube and plug it into your existing system.
20:50:41 * wagle tries to imagine tilings of fractal shapes
20:50:52 <shapr> cubes are kinda boring though, no unexplored properties
20:51:31 <desrt> shapr; a few with cuboids, though
20:51:54 <shapr> hotplug CPUs is just starting to happen, so tiled components would be really handy.
20:51:58 <wagle> how many fractal 1 foot cubes can you put in a cubic foot?
20:52:26 <SamC_> the computers could be bendy for a great variety of topologies
20:52:37 <wagle> imagine the space efficiency!
20:53:05 <wagle> hmm..  playdoh computers
20:53:18 <shapr> SamC_: asymmetric multiprocessing could let you use an Alpha for FPU spiffiness, and an x86 for integer speed, and maybe add an Itanic for VLIW SIMD power.
20:53:47 <shapr> SamC_: does it sound more worthwhile now? less like megamonad? :-)
20:55:14 <wagle> megamonad: is shapr onto something?
20:55:23 <desrt> shapr; writing a scheduler for that would be extra interesting
20:55:34 * SamC_ is reminded of transputers
20:55:41 <wagle> darn, cant remember the incantation
20:55:56 <wagle> transputer?
20:56:04 <shapr> Yeah, lots of fun challenges with asymmetric multi-arch computing. Too bad there's no hardware to support it.
20:57:16 <shapr> transputers are single intsruction multiple data setups
20:57:59 <shapr> The only transputer setups I've read about were a bunch of small cpus in a grid, you passed the data in via the grid and did one op on all of it at the same time.
20:58:13 <SamC_> cheap simple chips which would could work alone but designed to be wired together
20:58:35 <shapr> That's the next step in grid computing.
20:58:38 <wagle> ixp2400 has a strong arm core cpu, and bunches of "microengine" (io processors) all on the same chip
20:58:51 <shapr> ooh, sounds neat
20:58:52 * shapr googles
20:59:11 <SamC_> from the wikipaedia: "The idea in this case was to allow the Transputers to be connected together as easily as possible, without the requirement for a complex bus (or motherboard). Instead you simply supplied power and a simple clock signal. You did not have to provide RAM, a RAM controller, bus support or even an RTOS—these were all built in"
20:59:30 <Philippa> shapr: x86+PCI bus seems pretty asymmetric to me, but mebbe only somebody doing modern consumer-level graphics would think of that?
20:59:57 <Philippa> (a common xbox hack is to let the graphics hardware do your physics calculations for you, as it's a UMA setup)
21:00:02 <desrt> Philippa; that's like saying that having an external FPU is assymetric...
21:00:15 <SamC_> I think Hoare designed them
21:00:16 <shapr> from some viewpoint that's true
21:00:19 <desrt> (which it actually is, i think) :)
21:00:22 <wagle> i know people who use graphics cards as (somewhat) general computing devices
21:00:33 <Philippa> wagle: same here
21:00:57 <shapr> yeah, nvidia's Cg SDK allows heavy duty SIMD with the GeForce FX 5200 and later.
21:01:00 * desrt remembers back in the day when people wanted to run distributed.net on their graphics cards
21:01:27 <shapr> too bad the whole Cg thing is so deeply proprietary :-(
21:02:03 <Pseudonym> Is it?
21:02:05 <desrt> shapr; is the card actually a general purpose cpu?
21:02:18 <Pseudonym> I thought Cg itself was fairly open, and it's only the card details which are proprietary.
21:02:20 <shapr> nah, you have to cast your inputs as textures :-)
21:02:22 <Gahhh> desrt: it is not.
21:02:32 <desrt> so... turing incomplete?
21:03:05 <Pseudonym> desrt: Correct, but it can be driven by the host CPU.
21:03:05 <Gahhh> desrt, as far as I know. There's pressure for turing-completeness tho. See posts/interviews by Tim Sweeney of Epic in particular.
21:03:10 <desrt> sort of reminds me of the emu10k1 (audigy..) it has this weird instruction list
21:03:28 <desrt> it has normal instructions, registers, etc.... but no jump instruction
21:03:36 <desrt> each sample is passed through 512 instructions (or whatever) linearly
21:03:43 <Pseudonym> NVIDIA tried to hire me to work on this, BTW/
21:03:55 <Gahhh> desrt, HLSL is not turning-complete for sure.
21:03:56 <shapr> Pseudonym: why didn't you?
21:04:13 <Pseudonym> shapr: Work in silicon valley?  You must be kidding.
21:04:23 * Gahhh works in Silicon Valley, 10 mins from nvidia
21:04:23 <shapr> Too many geeks in one place?
21:04:33 <desrt> Gahhh; this is interesting
21:05:01 <Pseudonym> High cost of living or long commute.  Pick one.
21:05:11 <Gahhh> desrt: afaik, there is a library developed by Stanford for general purpose use of GPU's, I believe.
21:05:19 <Pseudonym> Besides, becoming an H1B indentured servant doesn't sound like fun.
21:05:29 * Gahhh is an H1b servant
21:05:31 <SamC_> wouldn't turing completeness take-away their advantage?
21:05:40 <desrt> plus... he'd have to release the source code to their drivers
21:05:46 <desrt> and that would get him fired and probably sued
21:05:53 <Gahhh> SamC_, it's extra hardware that they could have used for other things
21:05:54 * SamC_ has no idea how that hyphen got there :P
21:06:24 <Pseudonym> I'm guessing they wanted me because I'm one of the 10 or so people who has written a compiler for a Cg-like language before.
21:06:40 <shapr> I think nvidia will lose  big if someone else releases a heavy duty parallel coprocessor that just happens to have a basic open source  OpenGL implementation.
21:06:47 * desrt is one of the 1000000 or so people who have written a C compiler :(
21:06:50 <desrt> what is Cg like?
21:06:58 <Gahhh> shapr, why opengl ?
21:06:59 <SamC_> as in introduce pipelining issues etc
21:07:16 <Pseudonym> Cg (like RenderMan SL) is a SIMD language.
21:07:27 <Gahhh> SamC_, not just that. It's silicon real estate that they don't have an immediate use for.
21:07:30 <Pseudonym> SIMD architectures have all sorts of issues.
21:07:46 <desrt> Pseudonym; this interests me.  i'm working on a compiler for a SIMD-ish language right now too
21:07:50 <shapr> Gahhh: because people like me will buy the card to integrate it with my favorite language, and also so I can have fast open source OpenGL in Linux.
21:07:56 <Pseudonym> Oh?  Which one?
21:07:58 <desrt> it's really a declarative language that produces SIMD code....
21:08:04 <desrt> so i don't know if that qualifies
21:08:11 <shapr> when my nvidia drivers wipeout, there's nothing I can do to fix them.
21:08:11 <Pseudonym> What's your target platform?
21:08:15 <desrt> powerpc
21:08:16 <Pseudonym> Software simulation?
21:08:23 <Gahhh> shapr, unfortunately it is neither that simple nor that open-source friendly.
21:08:41 <Pseudonym> Ah, so you're simulating the SIMD architecture on stock SISD hardware?
21:08:49 <desrt> ..
21:08:55 <desrt> powerpc has altivec....
21:08:57 <Pseudonym> Or are you using the SIMD extensions?
21:09:00 <Pseudonym> Ah, gotcha.
21:09:01 <desrt> yes.  that.
21:09:17 <shapr> Gahhh: I think it could be
21:09:27 <Pseudonym> As a matter of interest, does PPC have predicated execution for the SIMD bit?
21:09:30 <desrt> anyway.  it's probably only -vaguely- similar to what you're talking about
21:09:41 <Pseudonym> Yes, only vaguely.
21:09:58 <desrt> Pseudonym; just normal instruction pipelining.... it will predict jumps to simd code.....
21:10:04 <Pseudonym> Right.
21:10:13 <desrt> i'm not really sure how you could predict the result of something :)
21:10:17 <Pseudonym> Predicated execution is vital on a massively-parallel SIMD machine.
21:10:20 <shapr> Gahhh: how different is Itanium's VLIW EPIC and  Nvidia chips?
21:10:25 <Gahhh> desrt, is that for your work ?
21:10:31 <desrt> Gahhh; ya
21:10:37 <desrt> supervisor = insane :)
21:10:47 <SamC_> Pseudonym, did you see Oleg's article on Zuse?
21:10:53 <desrt> (insane defined == "too smart")
21:10:58 <Gahhh> shapr, nvidia chips are more like ASIC's than CPU's (at the moment)
21:11:04 <Pseudonym> Much like the Itanium's predicate registers, only you can make the bit different for each processor.
21:11:08 <SamC_> well not article
21:11:11 <Pseudonym> SamC_: No, I didn't.
21:11:34 <desrt> Pseudonym; ah.  with altivec you only get instructions that work on (at most) 16 pieces of data at a time (and in that case, only if the 'piece' is a byte)
21:11:46 <desrt> if you have floats, you only get 4 datas per instruction :/
21:11:59 <Pseudonym> Right.
21:12:17 <Gahhh> desrt, that's nothing to sneeze at
21:12:23 <desrt> what is massively parallel?
21:12:44 <Pseudonym> My question is: Can you only operation on 0, 1 and 3, skipping 2?
21:12:45 <desrt> Gahhh; certainly not when you can schedule and execute 4 instructions per clock...
21:12:49 <Pseudonym> For the 4 data items.
21:12:54 <desrt> Pseudonym; no
21:13:00 <Pseudonym> Massively parallel is 256.
21:13:07 <Pseudonym> Though I suspect that's simulated.
21:13:07 <desrt> but there's a select operator.....
21:13:11 <shapr> Gahhh: hmm, I suspect that (affordable) Itanium-style CPUs would give 'software rendering' close to Nvidia performance, but I could be terribly mistaken.
21:13:31 <desrt> so you could do the op, then select between the source register and the result into the real target
21:13:45 <Pseudonym> desrt: Which does what?
21:13:52 <desrt> well... like
21:13:56 <desrt> source <- something
21:13:58 <SamC_> Pseudonym, http://okmij.org/ftp/Computation/Zuse-accolades.txt  you might find a little interesting
21:14:02 <desrt> result <- op source
21:14:14 <desrt> partresult <- sel mask, result, source
21:14:19 <Pseudonym> Right.
21:14:24 <desrt> any "1" in the mask will give you the 'result' and a 0 gives you the original source
21:14:25 <Pseudonym> So if the op does a division by zero...
21:14:32 <desrt> it can't.
21:14:40 <Gahhh> shapr, modern GPU's today boast insane amounts of transistors for a very specific kind of computations. Unless you throw more silicon at your turing-complete CPU, you're not gonna get that kinda perf.
21:15:01 <desrt> no integer divsion in altivec... and floating point division will just give you Inf (which you can ignore)
21:15:10 <Pseudonym> Ah, I see.
21:15:22 <Pseudonym> In a Cg-esque language, you can do this:
21:15:31 <Pseudonym> varying float x = something();
21:15:40 <desrt> (not even 100% sure you get floating point divide... but you do get 'calculate reciprocal')
21:15:46 <Pseudonym> if (x > 0) { x = 1.0 / x; }
21:15:53 <Pseudonym> And it just works.
21:16:02 <desrt> that's nice.
21:16:25 <Gahhh> why if x > 0 ? you mean x != 0.0 ?
21:16:35 <desrt> it was just a sample :P
21:16:38 <Pseudonym> Gahhh: That also works, but I did what I meant for a reason.
21:16:44 <Gahhh> I thought it was purposeful.
21:17:00 <desrt> does the C in Cg stand for C?
21:17:15 <Pseudonym> The code that I wrote is not easily expressible on a stock CPU's SIMD instruction set, typically.
21:17:46 <desrt> you could do that on altivec in 4 or 5 insns
21:17:50 <shapr> Gahhh: The IBM/Sony/Toshiba Cell/Grid multi-core design claims to aim for just that, starting with 2 cpus on-core, and plans to scale up to 64 on a single core. The bug design claims to be designed for parallel processing, and the new PlayStation claims to use Cell/Grid without specific GPU hardware.
21:17:59 <shapr> Sounds nice at least.
21:18:03 <desrt> but they'd be heavily serially dependent... so they'd take a long time to execute
21:18:21 <Pseudonym> Right.
21:18:26 <desrt> (like, 20ish clocks...)
21:18:30 <shapr> desrt: I think it's C for graphics or something equally creative.
21:18:34 <Pseudonym> On a modern GPU, the OpenGL stencil buffer is just a big predicate register.
21:18:42 <Pseudonym> Conceptually.
21:18:59 <desrt> i know ~0 about opengl
21:19:13 <Pseudonym> Ah, OK.
21:19:18 <desrt> "it makes doom 3 look pretty"
21:19:30 <ozone> Pseudonym/shapr: have you seen Conal Elliot's HW2004 paper?
21:19:32 <ozone> lemme dig up a URL
21:19:49 <ozone> vertigo, that's it
21:19:50 <ozone> http://conal.net/papers/Vertigo/
21:19:56 <desrt> so what's a predicate register?
21:19:58 <ozone> a functional language for GPUs
21:20:03 <desrt> data or code?
21:20:18 <Pseudonym> A predicate register on the Itanium is a register which is one bit long.
21:20:31 <Pseudonym> Conceptually.
21:20:50 <Pseudonym> The Itanium lets you run code conditionally to avoid pipeline hazards.
21:20:57 <Pseudonym> So, for example, you could write this:
21:21:03 <Pseudonym> p1 <- x > 0
21:21:06 <desrt> i wrote an arch like that once...
21:21:17 <Pseudonym> (p1) x <- 1.0 / x
21:21:17 <shapr> nifty, too bad it generates C#
21:21:22 <Pseudonym> To implement the above code.
21:21:30 <desrt> that's nice.
21:21:46 <Pseudonym> Note that there are no jumps.
21:21:47 <desrt> i had 2 bits in the instruction word... set/cond
21:22:06 <desrt> if you had the "set" bit on an instruction, then a flag inside the cpu got set to 1/0 if the result of the instruction was non-0/0
21:22:10 <Pseudonym> On SIMD architectures, they are critical, because each processing element receives the same instructions.
21:22:17 <desrt> and instructions with "cond" set would only execute if the flag was set
21:22:34 <Pseudonym> So if you wanted to implement if-then-else, you'd have to run both the "then" part and the "else" part, and use the predicate register to determine who runs what.
21:22:42 <Pseudonym> Right.
21:22:52 <desrt> yes.  this is a powerful concept
21:23:00 <desrt> it's like fsel and cmov
21:23:08 <desrt> "branching is bad"
21:23:13 <Pseudonym> Right.
21:23:31 <Pseudonym> It's tricky to generate good code for.
21:23:42 <desrt> you're telling me :)
21:23:52 <Pseudonym> But it's nice from the compiler writer's point of view once you've identified opportunities.
21:24:05 <Pseudonym> Because control dependencies become data dependencies.
21:24:10 <desrt> oh.  you mean SIMD is difficult to generate code for.
21:24:20 <Pseudonym> I mean predicated code.
21:24:35 <Pseudonym> SIMD isn't too hard to generate code for if the source language is aware of it.
21:24:39 <Pseudonym> e.g. Cg :-)
21:24:43 <desrt> so....
21:24:52 <desrt> graphics cards are not turing complete.... fine
21:25:08 <desrt> but they can run (i imagine, reasonably long) predicate programs
21:25:21 <Pseudonym> THey are driven from the host CPU, which _is_ Turing-complete.
21:25:34 <Pseudonym> It's like saying that a floating-point unit isn't Turing-complete.
21:25:36 <Pseudonym> It's not.
21:25:42 <desrt> just wondering, though... is it really worth it to move data into the card, have it do something and then move it back out?
21:25:42 <Gahhh> desrt, if you know what you wanna do, you can drive a lot of data over the PCIE bus to use them for some stuff.
21:25:53 <desrt> (assuming you kept the host CPU busy in the meantime)
21:25:56 <Pseudonym> desrt: Yes, it is.
21:26:00 <Pseudonym> Depending on what you want to do.
21:26:02 <desrt> ok.  that's awesome
21:26:15 <desrt> signal processing :)
21:26:28 <desrt> radeon 9800 i think
21:26:29 <Pseudonym> Some of the world's most powerful single-machine supercomputers suck if you're trying to process text.
21:26:31 <Gahhh> yeah. PCIE is bi-directional as well.
21:26:40 <Gahhh> I mean, balanced
21:26:41 <desrt> we have AGP.
21:26:43 <Pseudonym> Your desktop is probably faster at that job.
21:27:00 <Pseudonym> Anything which uses BLAS, on the other hand...
21:27:02 <desrt> this is exciting
21:27:37 <Pseudonym> SamC_: Interesting paper.
21:27:44 * Gahhh matches regexps with his 9800 pro ;)
21:27:49 <desrt> oh pfft.
21:27:51 <desrt> it's a 9600
21:28:05 <desrt> how does memory access work? (or does it)
21:28:13 <desrt> can you do something like
21:28:20 <desrt> datas <- load (indices)
21:28:24 * Pseudonym is unsure of that
21:28:29 <Pseudonym> My compiler wasn't for a GPU as such.
21:28:32 <Gahhh> you have to move the data back to the main memory if you wanna do something. You can use on-board memory I believe.
21:28:41 <Pseudonym> It was actually for a software simulation of a SIMD machine.
21:28:46 <desrt> Gahhh; ya.. AGP lets you bus master with ease
21:28:52 <Pseudonym> Which was necessary for various reasons.
21:29:18 <desrt> the simulator must have been pretty wasteful (in terms of branch misprediction)
21:29:27 <Pseudonym> Not necessarily.
21:29:45 <Pseudonym> If the source language is SIMD-aware, you can generate better code for a stock CPU doing it this way.
21:29:50 <Pseudonym> Consider this:
21:30:02 <Pseudonym> Hmmm.
21:30:07 <Pseudonym> OK, consider a large "basic block".
21:30:17 <Pseudonym> The naive way to do this on a stock CPU is like this:
21:30:24 <Pseudonym> for (each processing element e)
21:30:27 <Pseudonym> {
21:30:37 <Pseudonym>     e.x = 1.0 / e.x;
21:30:37 <Pseudonym> }
21:30:43 <Pseudonym> for (each processing element e)
21:30:44 <Pseudonym> {
21:30:49 <Pseudonym>     e.y += e.x;
21:30:49 <Pseudonym> }
21:31:11 <Pseudonym> A smart compiler can combine the two loops, increasing the size of each basic block.
21:31:15 <SamC_> what's the Moore's law analogue for GPUs called, or isn't there one?
21:31:34 <Gahhh> SamC_, there is none that I am aware of
21:31:59 <desrt> Pseudonym; but you don't get treatment of conditionals there
21:32:11 <desrt> for(i...)
21:32:11 <desrt> {
21:32:15 <Pseudonym> For that, you need a predicate register.
21:32:17 * SamC_ thinks it will be difficult to google for
21:32:17 <desrt>   if( e[i].pred )
21:32:20 <Pseudonym> for (each processing element e)
21:32:20 <desrt>     do_stuff();
21:32:21 <desrt> }
21:32:21 <Pseudonym> {
21:32:28 <Pseudonym>     if (e.pred)
21:32:30 <desrt> ^ this will execute an if statement that behaves randomly a lot of times
21:32:31 <Pseudonym>     {
21:32:33 <Pseudonym> etc etc
21:32:44 <Pseudonym> Though it's cheaper to store them as bit vectors.
21:33:12 <Pseudonym> And give each PE a number.
21:33:20 <Pseudonym> So you can just look the PE up in the bit vector.
21:33:24 * desrt does a little test
21:33:37 <Pseudonym> The reason is how you implement control flow operations.
21:34:13 <Pseudonym> If your program has a reducible flow graph (and it had better, otherwise you're really stuffed), you can think of the predicate registers as being stored in a stack.
21:34:39 <Pseudonym> if (c) { foo(); } else { bar(); }  gets translated to something like this:
21:34:40 <SamC_> they must be getting faster quicker than CPUs  right?
21:35:19 <Pseudonym> bit_vector p1 = stack.top();
21:35:32 <Pseudonym> for (each element e such that e \in p1)
21:35:34 <Pseudonym> {
21:35:37 <Gahhh> SamC_, it is difficult to compare, but I'd go out on a limb and say that they have been at least as bullish as the CPU's.
21:35:46 <Pseudonym>     if (c) { p1.reset(e); }
21:35:47 <Pseudonym> }
21:36:05 <Pseudonym> stack.push(p1);
21:36:11 <Pseudonym> foo();
21:36:24 <Gahhh> Pseudonym, it is amazing how you can type this stuff up on irc.
21:36:39 <Pseudonym> stack.top() = stack.second_element_down() & ~stack.top();
21:36:41 <Pseudonym> bar();
21:36:43 <Pseudonym> stack.pop();
21:36:51 <Pseudonym> Soemthing like that.
21:36:57 <Gahhh> ...unless you are pasting from somewhere...
21:36:59 <desrt> cool.
21:37:01 <Pseudonym> The key bit is between fo() and bar().  That's a bit vector operation.
21:37:10 <Pseudonym> So it's cheaper to do it a word at a time.
21:37:11 <desrt> gcc -O9 on a dumb little test i wrote generates branches
21:37:23 <desrt> gcc -O9 -march=pentium4 generates 'cmovne'
21:37:29 <Gahhh> Is -O9 a valid flag ???
21:37:30 <Pseudonym> Gahhh: It reminds me of a story about Woz.
21:37:36 <desrt> Gahhh; it's == -O3
21:37:43 <Gahhh> ah ok
21:37:58 <Pseudonym> Woz was a member of the homebrew computer club.
21:38:20 <Pseudonym> The story goes that he would code in entire programs via keyswitches without using any paper.
21:38:25 <Pseudonym> Occasionally he'd pause for a moment.
21:38:34 <Pseudonym> When asked why he paused, he'd say "forward branch".
21:38:40 <Gahhh> Heh
21:38:50 <desrt> Pseudonym; i see
21:38:59 <Gahhh> forward branches remind me of my 68000 days
21:39:07 <Pseudonym> :-)
21:39:14 <desrt> hahah
21:39:16 <Pseudonym> My compiler didn't use an actual stack, BTW.
21:39:30 <desrt> my compiler used the stack.  extensively.  ridiculously.
21:39:32 <Pseudonym> But it's useful to think of it that way.
21:40:26 <desrt> a++; was like (counts) uh... a lot of pushs and pops
21:40:33 <Pseudonym> :-)
21:40:52 <Pseudonym> Oh, one other thing.
21:41:01 <Pseudonym> Cg (and RenderMan SL) doesn't support recursion.
21:41:20 <Pseudonym> All user function calls are inlined.
21:41:29 <desrt> well... when you call a function it just instantiates it, right?
21:41:32 <desrt> ya
21:41:40 <desrt> like vhdl :)
21:42:14 <Pseudonym> Right.
21:42:42 <desrt> so no jumps at all, then
21:43:23 <desrt> well... with emu10k1 at least you got forward jumps.... (although, really, it just 'did nothing' for the next N clock ticks instead of executing code)
21:43:39 <Pseudonym> Yes, it supports loops.
21:43:48 <Pseudonym> They're jumps.
21:44:03 <Pseudonym> I believe loops are driven from the host CPU, though.
21:44:31 <desrt> how you keep talking about this makes it seem like the cpu and the gpu are very tightly coupled
21:44:40 <desrt> more than i would have thought
21:44:54 <Pseudonym> I think they have to be, because different GPUs have different capabilities.
21:44:56 <desrt> that's sort of cool :)
21:45:03 <Pseudonym> SO the tradeoff is different between different cards.
21:45:16 <Pseudonym> At least that's how I understand it.
21:45:24 <desrt> do you get cross-element transfers?
21:45:31 <Pseudonym> Kind of.
21:45:41 <Pseudonym> In RenderMan SL, you get "area operatins".
21:45:47 <Pseudonym> operations
21:45:51 <desrt> gaussian blur across all of the elements would be useful, for example
21:46:27 <Pseudonym> For example, if you have a varying vector, you can compute its normal.
21:46:38 <Pseudonym> Which requires accessing derivative information.
21:46:41 <desrt> is varying varying in length?
21:47:03 <Pseudonym> No, "varying" means there is one value per processing element.  The antonym is "uniform".
21:47:11 <Gahhh> You may lke reading this inteview with Tim Sweeney: http://www.beyond3d.com/interviews/sweeneyue3/index.php?p=2
21:47:13 <desrt> right
21:47:16 <Pseudonym> No sense doing computation on all processing elements when you don't need to.
21:47:20 <desrt> what you call uniform we call "splatted" :)
21:47:25 <Pseudonym> Right.
21:47:39 <ozone> tim sweeney is a gun
21:47:58 <ozone> i have no idea how on earth he does as much as he does while keeping up with serious programming language and type theory
21:48:10 <Gahhh> yeah he's into FP and all
21:50:07 <desrt> games are really amazing
21:50:46 <Gahhh> industry worth $ billions, baby
21:51:11 <Pseudonym> And the actual developers are treated worse than slaves.
21:51:16 <desrt> our school is considering a 'software engineering and games' programme
21:51:26 <desrt> and knee-jerk reaction is "how immature"
21:51:31 <Gahhh> Pseudonym, are you referring to the EA incidents ?
21:51:37 <Pseudonym> Not just that, but yes.
21:51:38 <desrt> but when you realise how much there is to it... and the fact that it *is* a $bil industry.....
21:52:21 <Gahhh> Management science does have to play catch-up when it comes to game development, methinks..
21:52:52 <ozone> Gahhh: it won't need to unless the developers revolt
21:52:57 <ozone> which they won't, because they love their craft
21:53:04 <desrt> games are strange.  no matter how hard you try to stop it, everyone is going to pirate your product
21:53:10 <ozone> (spoken by someone who has far too many friends in the games industry)
21:53:28 <desrt> whenever a new game is released (ut2k4, doom3, whatever) more people i know buy new video cards than actually buy the game itself
21:53:32 <Gahhh> ozone, well, it's going to be the market that forces them to do it. It's the bland games that bother me.
21:54:36 <ozone> Gahhh: management won't need to change unless they actually lose craploads of money
21:54:50 <ozone> which they won't, because the publishing houses make enough money
21:54:59 <ozone> and that's not going to change for the forseeable future
21:54:59 <desrt> heh.  game devs will always do "i'm taking my ball home" spin-offs that start out as idealistic great places to work until they eventually become just as evil
21:55:04 <desrt> rinse wash repeat
21:55:07 <Gahhh> ozone, they will start losing money when the next FPS stops being a sure thing if people are fed up enough.
21:55:47 <ozone> Gahhh: people don't get fed up, that's the problem
21:56:00 <ozone> why do people care that developers get treated like crap, when they have a game to play with at the end of the day?
21:56:22 <Gahhh> ozone, people don't care.
21:56:51 <ozone> right, my point exactly
21:56:53 <Gahhh> But right now, you can't make me buy another team based tactical shooter. You need to point an actual MP40 to my head.
21:57:18 <desrt> Gahhh; what's your take on valve?
21:57:36 <Gahhh> valve in general or about steam ?
21:57:40 <desrt> hahahah
21:57:45 <desrt> good answer :)
21:58:32 <Gahhh> Well, all I know is that their main press guy, who is responsible for the vulnerability that caused the leak, is not the brightest bulb...
21:59:50 <Gahhh> But they made a good game. And nowadays steam is gaining more acceptance from the dev camps. Everybody wants to get rid of the middleman.
22:00:40 <desrt> i haven't played it (it doesn't run on linux) but everyone i know seems to think it sucks
22:01:06 <Gahhh> HL2 ?
22:01:09 <desrt> ya
22:01:25 <desrt> my one friend was like "i pirated this and i still feel like i deserve a refund"
22:01:29 <Gahhh> haha
22:01:36 <ozone> desrt: i like it
22:01:46 <ozone> (i liked it so much, i bought two more copies as xmas gifts)
22:01:49 * desrt thinks doom3 is positivley brilliant
22:02:08 <Gahhh> I played neither.
22:03:01 <Gahhh> But I think people are in general disappointed in both of them since they were hyped to the heavens...
22:03:08 <desrt> doom3 is so good that i bought it
22:03:16 <desrt> which is unfortunately, 'cause the multiplayer sort of seriously sucks
22:03:45 <Gahhh> Well, Carmack is a brilliant mind who said in advance he didn't give a flying vertex about MP, which is sad.
22:04:19 <desrt> i traded in my dual amd 1800+ for a p4 3.4 just before doom came out :)
22:04:48 <Gahhh> You were ready then if you have nvidia hardware as well...
22:06:27 <Gahhh> It's sad that MegaMonad is not here.
22:09:34 <SamC_> who's its keeper?
22:10:33 <desrt> ati
22:10:53 <desrt> shae, i bet
22:11:06 <Gahhh> no
22:11:16 <Gahhh> Goerzen ?
22:22:49 <SamC_> ozone, hoc-users archive link broken, how many hoc-users are there?
22:24:04 <ozone> SamC_: bugger all.  about three, i think ;)
22:24:15 <ozone> oh, and it's broken because there's no messages posted there yet ...
22:25:43 <SamC_> hoc looks cool, I hope to have enough time to play with it soon :)
22:26:35 <ozone> cheers
22:26:40 <ozone> though wolfgang did all the hard work
22:26:43 <ozone> i was just the slavedriver ;)
22:34:02 <SamC_> gotta have some dinner, keep up the good work (or slavedriving)
22:34:31 <Pseudonym> Must away myself.  Nytol!
23:51:55 * autrijus thinks unsafeInterleaveIO is the best thing since sliced bread.
