00:16:55 <autrijus> rehi.
00:17:22 <autrijus> <- just finished lapalme's "Algorithms" in one day, working on the exercises now and reading TaPL
00:17:43 <autrijus> it seems that TaPL can't be read with the same speed though. :-/
00:54:26 <boegel> pff
00:54:55 <Lemmih> Indeed.
00:54:55 <boegel> I want tickets for the U2 concert in June, but apparently everyone else does too
00:57:01 * Lemmih is amazed by GHCs optimizer.
00:57:25 <Lemmih> Greetings, fellow countryman.
00:57:25 * boegel hits his phone for not connecting with the ticket service
00:57:34 <Oejet> Can you elaborate, Lemmih?
00:57:43 <Oejet> Hej.
00:58:45 <Lemmih> Guess he didn't wanna talk. /-:
00:59:27 <boegel> Lemmih, probably something with his connection
01:03:14 <Itkovian> hi boegel ...
01:04:58 * Itkovian is off to wash his car.
01:05:16 <boegel> hi Itkovian
01:05:37 <boegel> i saw you on Thursay :)
01:18:10 <Lemmih> wb Oeje1.
01:18:38 <Oeje1> Lemmih: Sorry, Gaim died on me.  Did you elaborate on the GHC optimizer?
01:18:59 <Lemmih> Oeje1: I was amazed that the code Hacanon generates is just as fast as hand written code.
01:19:37 <Oeje1> Oh.  I want to try that also.  How do I get started?
01:20:55 <Lemmih> Oeje1: Using Hacanon or watching optimized haskell code?
01:21:57 <Oeje1> Well, both. :-)  In that order.
01:22:13 <Oeje1> Haconen is a C++ binding library, right?
01:24:03 <Lemmih> Yeah, but it's somewhat incomplete.
01:24:52 <Lemmih> I'm gonna send 5 days of patches now.
01:25:10 <Lemmih> Oeje1: http://www.scannedinavian.org/repos/hacanon/
01:25:11 <Oeje1> I want to have a binding for Enlightenment Foundation Libraries.
01:26:27 <Lemmih> Check the ThingsIveNotYetDealtWith.txt file.
01:26:40 <Oeje1> Just looked at it.
01:28:15 <Oeje1> darcs get ...haconen/
01:29:55 <Lemmih> I've just sent the last couple of patches. Make sure you got them.
01:30:01 <Oeje1> How do I build?
01:30:22 <Lemmih> Oh yeah. The cabal package is alittle old.
01:30:38 <Lemmih> Go to examples and 'make hacanon'.
01:31:29 <Lemmih> Oeje1: Oh and you need gccxml from CVS.
01:31:56 <Oeje1> And GHC 6.3?
01:32:06 <Lemmih> Of course.
01:32:50 <Lemmih> It's a template haskell library.
01:34:40 <Oeje1> gccxml-0.6.0.tar.gz is too old?
01:34:48 <Lemmih> Yes.
01:36:29 * Oeje1 makes a GCC-XML CVS package for GoboLinux.
01:49:37 <Lemmih> Oeje1: Making progress?
01:49:50 <Oeje1> Yes, just installing CMake.
01:59:30 <Oeje1> He, CMake needs to bootstrap itself.
02:12:05 * Oeje1 yarns.
02:12:35 <Oeje1> Doh.
02:31:51 <Oeje1> Ups.
02:40:59 <Oeje1> CMake build.
03:06:13 <Oeje1> GCC-XML build.
03:08:39 <Oeje1> Arg. Needs HaXml.
03:10:14 <Heffalump> that's fairly easy to install.
03:10:23 <Heffalump> I have a .deb kicking about if that would help
03:10:34 <Heffalump> (needs some kicking into shape before it goes into Debian, but it's usable)
03:11:01 <Oeje1> Heffalump: Thanks, but I don't know how to install .deb's on GoboLinux. :-)
03:12:12 * wli turbo2deb
03:12:14 <Oeje1> Does Haconen need the dev. version of HaXml?
03:12:25 <wli> (similar to rh2deb)
03:31:22 <Oeje1> I get this error compiling HaXml with GHC 6.3:
03:31:40 <Oeje1> `cat ghcpkgcmd` --add-package <pkg.conf
03:31:40 <Oeje1> Reading package info from stdin...
03:31:40 <Oeje1> Fail: Line 1: Invalid syntax (no colon after field name)
03:31:40 <Oeje1> make[1]: *** [install-ghc] Error 1
03:31:40 <Oeje1> make[1]: Leaving directory `/Files/Compile/Sources/HaXml-1.12/obj/ghc'
03:31:40 <Oeje1> make: *** [install-ghc] Error 2
03:33:04 <Oeje1> It seems to be a Cabal error.
03:37:18 <Oeje1> Ah, I need the CVS version of HaXml to go with GHC 6.3
03:45:34 <Lemmih> "< Oeje1> Does Haconen need the dev. version of HaXml?" No, but I haven't tested it with other versions than 1.12.
03:47:08 <Oeje1> I just have problems installing HaXml.
03:47:57 <Lemmih> The one in fptools/libraries/HaXml/ should do fine.
03:47:57 <Oeje1> Well, same error for the CVS version of HaXml, when compiled with ghc-6.3.20041116.
03:51:04 <Heffalump> is there any work known of on debifying hs-plugins?
03:55:16 <Lemmih> Oeje1: Still having problems?
03:58:38 <Oeje1> Very much so.
03:59:02 <Oeje1> I get the error from above, and I don't know what it means.
03:59:23 <Oeje1> Googling comes back with something about Cabal packing only.
04:04:26 <Lemmih> Oeje1: You're using './Setup.lhs build' instead of 'make', right?
04:05:27 <Oeje1> Well, no.  Not in HaXml or Hacanon.
04:06:55 <Lemmih> Cabal packages are build with the Setup.lhs script.
04:07:06 <Oeje1> Hm, ok.
04:08:10 <Heffalump> @seen dons
04:08:10 <lambdabot> dons is in #haskell.
04:11:25 <Lemmih> Oeje1: However, you should not try to build the Hacanon cabal package.
04:14:33 <Oeje1> Lemmih: I guess I must have the Cabal package also?
04:19:45 <Lemmih> Oeje1: It's distributed with GHC.
04:21:24 <Oeje1> What are the steps of compiling and installing a Cabal package after ./Setup.lds build?
04:21:45 <wli> Setup.lds? Sounds like a linker script.
04:21:54 <Lemmih> ./Setup.lhs install
04:22:05 <wli> Setup.lhs is more like it =)
04:23:37 <Lemmih> Oeje1: './Setup.lhs --help' or even 'runghc Setup.lhs --help' should show you some options.
04:25:24 <Oeje1> HaXml does not have a Setup.lhs
04:30:47 <wli> heh
05:51:44 * boegel sings
06:42:10 <setre> has anyone else had trouble with ghc-bin on gentoo? I can't even build hello world
06:42:56 <boegel> setre: did you have any problems installing it ?
06:42:59 <setre> no
06:43:13 <boegel> and which errors do you get when building hello world?
06:43:42 <setre> Failed: gcc -I. -I. -c /tmp/ghc6684.s -o hello.orawSystem: interrupted (Interrupted system call)
06:44:22 <boegel> strange
06:44:30 <boegel> I can't help you there...
06:44:45 <setre> ok. 
06:59:59 * shapr yawns
07:00:04 <shapr> good morning #haskell !
07:01:44 <esap> good afternoon.
07:04:47 <shapr> hei esap 
07:05:32 * shapr is trying to fit dars' Patch type into an arrow
07:07:26 * autrijus is still reeling from the heaviness of the brick book.
07:08:00 <autrijus> only made 100 pages of progress today
07:08:28 <autrijus> shapr: what do you gain if you makes Patch into an arrow?
07:10:37 <shapr> I think the gain will be static caching of commute properties, sorting according to properties, and much less recursive checking required.
07:11:06 <shapr> Truly, the brick book is an excellent self defense weapon.
07:11:50 <esap> the brick book? which one is that?
07:11:53 <autrijus> TaPL.
07:12:00 <autrijus> shapr: ooh.
07:12:01 <shapr> I'm relatively certain that I can speed up darcs by a big factor.
07:12:08 <autrijus> shapr: I'm greatly interested :)
07:12:24 <autrijus> I don't quite see how arrowification relates to caching though.
07:12:29 <CosmicRay> shapr: can you also make it reliable?
07:12:40 <autrijus> I mean, you can memoize the commute properties regardless of whether it's an arrow or not, no?
07:12:41 <shapr> Well, I'm trying to clarify my understand of patch theory and arrows to the point that I can start writing code.
07:12:47 <shapr> sure
07:12:52 <CosmicRay> woohoo :-)
07:12:59 <shapr> er, memoize, yes
07:13:23 <CosmicRay> ah :-)
07:13:26 <autrijus> darcs needs to be sped up by a big factor to be useful for nontrivial teams :)
07:13:28 <shapr> I do think turning patch into an arrow will clarify semantics, which might make testing easier.
07:13:54 <CosmicRay> autrijus: you mean things like not taking 10 hours to commit a 10k change against a 50k repository? :-)
07:14:16 <autrijus> CosmicRay: right. which is why I plan to stick with svk for $real_work in forseeable future :)
07:14:19 <shapr> there's some neat mail about speeding up darcs today on darcsdevel
07:14:37 <CosmicRay> autrijus: I'm still using arch, though svk did look quite interesting
07:14:48 <CosmicRay> i did use subversion for awhile, but switched to tla a year or two ago
07:14:58 <CosmicRay> once darcs becomes more usable, I'll use it
07:15:06 <autrijus> *nod* I think it's all about the UI.
07:15:13 <autrijus> I can't force myself into accepting tla's UI.
07:15:21 <CosmicRay> autrijus: for the record, the 10 hours was david's estimate of how long it would take.  I maintained that it was spinning.
07:15:41 <CosmicRay> autrijus: it doesn't suck, except for the fact that the command names are long.
07:15:57 <CosmicRay> I think tom lord gets kickbacks from carpal tunnel surgeries.
07:16:04 <autrijus> hehe.
07:16:24 <Igloo> CosmicRay: If by spinning you mean would never terminate it would be nice if you gave some evidence that that was the case...
07:16:47 <CosmicRay> Igloo: he convinced me
07:16:57 <CosmicRay> I never did let it run for the full 10 hours
07:18:21 <autrijus> mmm patch domains.
07:19:02 <autrijus> <- surprised that darcs doesn't have any sort of collision algorithm
07:19:13 <autrijus> no wonder it's slow :)
07:25:04 <Lemmih> Good evening, shapr.
07:33:18 <shapr> greetz Lemmih 
07:33:27 <basti_> hi all
07:33:42 <shapr> guten morgen basti_ 
07:34:35 <basti_> actually its not morning.
07:34:42 <shapr> It is for me!
07:34:45 <shapr> I just woke up!
07:34:54 <basti_> uhm
07:35:01 <shapr> I've always thought morning was a state of mind.
07:35:23 <edwinb> It's morning until after lunch, whenever that might be...
07:35:36 <shapr> I haven't had breakfast yet.
07:35:59 <basti_> i had a bit of choclate
07:36:21 <shapr> I'm going to order pizza.
07:36:51 <shapr> tuna and peppers.
07:36:53 <shapr> mmmm
07:36:57 <basti_> i have lasagna going in the oven
07:37:04 <basti_> deepfrozen lasagna though
07:37:06 <shapr> Oh, nice. I can't cook.
07:37:15 <shapr> I can probably cook frozen lasagna.
07:37:29 <basti_> i can cook lasagna even without buying frozen one.
07:37:34 <shapr> Wow.
07:41:17 <shapr> y0 Maddas 
07:42:05 <Maddas> yow!
07:43:54 <Maddas> What's up?
07:44:07 <shapr> um, arrows.
07:44:38 <Maddas> Hah :-)
07:45:21 * Lemmih wonders how to type an upwards arrow.
07:46:26 <basti_> uhm ^
07:46:32 <Lor> The C64 had an upwards arrow character.
07:46:43 <basti_> ^ was an upwards arrow before some big switch
07:47:33 <basti_> or did Lemmih mean "type" as in "Inductive Type"?
07:50:25 <i_of_k5> if you dig utf-8, then ↑ is an upwards arrow
07:50:26 <autrijus> (Arrow a, Arrow c) => a b c -- like this? :)
08:24:36 * Lemmih goes to sleep.
08:32:36 <shapr> autrijus: yeah like that!
08:46:37 <Oejet> Hello.  Am I the only one having trouble installing GHC from the snapshots?
09:10:31 * shapr throws lambdas
09:18:01 * araujo catches one
09:21:09 * TheHunter destroys the lambdas using thbot
09:21:26 <TheHunter> thbot: @pointless foo (x,y) = 2*x + 3*y
09:21:26 <thbot> foo = uncurry ((. (3 *)) . (+) . (2 *))
09:22:30 <Igloo> thbot: @pointless foo x = (length x, reverse x)
09:22:30 <thbot> foo = ap ((,) . length) reverse
09:26:44 <shapr> thbot: @pointless elegant_merge (p1, p2) = case commute (p1, invert p2) of Just (_,p1') -> case commute (p1', p2) of Nothing -> Nothing; Just (_,p1o) -> if really_eq_patches p1o p1 then Just p1' else Nothing; Nothing -> Nothing
09:26:44 <thbot> (line 1, column 8):
09:26:44 <thbot> unexpected "_"
09:26:44 <thbot> expecting digit, letter, white space, variable, "(", operator or end of
09:26:44 <thbot> input
09:27:53 <jemfinch> what's with the focus on point-free style?
09:27:56 <shapr> thbot: @pointless elegant_merge (p1, p2) = case commute (p1, invert p2) of Just (x1,p1') -> case commute (p1', p2) of Nothing -> Nothing; Just (x2,p1o) -> if really_eq_patches p1o p1 then Just p1' else Nothing; Nothing -> Nothing
09:27:57 <thbot> (line 1, column 8):
09:27:57 <thbot> unexpected "_"
09:27:57 <thbot> expecting digit, letter, white space, variable, "(", operator or end of
09:27:57 <thbot> input
09:28:13 <thbot> i don't no case and if.
09:28:15 <shapr> aha, it doesn't like underscores in names?
09:28:25 <thbot> s/no/know/
09:29:11 <TheHunter> the _ problem can easily be fixed. The problem with case is more fundamental.
09:35:10 <CosmicRay> shapr: perhaps we should have the next haskell conference here: http://www.haskell.edu/haskell/ :-)
09:35:15 <TheHunter> thbot: @pointless hylo f (n,c) = either (const n) (c . pair (id, hylo f (c,n))) . f
09:35:41 <thbot> hylo = fix (((flip ap snd . (. fst)) .) . ap ((.) . flip flip) . (((((.
09:35:41 <thbot>  .) .) . ap ((.) . either . const) . (ap (.) .) . ((pair .) .) . (((,) id
09:35:41 <thbot> .) .) . (. flip (,)) . (.)) .))
09:35:52 <shapr> CosmicRay: that would be cool.
09:36:13 <shapr> TheHunter: scary
09:39:07 <shapr> hiya maihem 
09:39:17 <maihem> yo shapr.
09:39:21 <maihem> hows code?
09:39:22 <shapr> how's code?
09:39:23 <shapr> doh
09:39:31 <shapr> I'm coding Python at the moment.
09:39:33 <jemfinch> no one ever answered my question :)
09:39:38 <maihem> haha, no Haskell recently here either
09:39:46 <CosmicRay> MegaMonad: please answer jemfinch's question.
09:39:46 <maihem> low-level OS stuff
09:39:46 <MegaMonad> CosmicRay: You immediately see how that kind of question to be the point of view - jemfinch's "threading something through the scrollback?
09:39:51 <jemfinch> What's the point of point-free style?
09:40:18 <shapr> I think it's that you can use it as a combinator.
09:40:24 <TheHunter> it's pointless. but fun...
09:40:31 <shapr> I don't think you can do that with imperative code.
09:40:38 <Cale> jemfinch: *sometimes* it's clearer, usually in fairly small cases
09:41:28 <TheHunter> you don't have to invent names for variables!
09:41:44 <shapr> Right, Joy is the ultimate points-free language.
09:41:47 <Cale> Like if I have a function which is clearly the composite of two others, I might just write f = g . h rather than putting an extra variable in.
09:42:18 <shapr> I think the power of point-free really is the same as the power of Joy.
09:42:43 <shapr> Variables don't need renaming, there's no real 'state' to worry about. Everything active in that code happens 'right here'
09:43:38 <shapr> TheHunter: how does @pointless work anyway?
09:43:59 <shapr> jemfinch: can you do points-free code in Python?
09:44:36 <jemfinch> shapr: it wouldn't look at pretty.
09:44:45 <shapr> Can you do it?
09:45:45 <TheHunter> shapr, it parses the definition, then transforms it to pointfree style (this step is really simple, less than 40 loc) and finally tries a lot of rewrite rules to make the term shorter.
09:47:12 <TheHunter> e.g "foo (x,y) = x + y" get transformed to "foo = fix (const (ap ((+) . fst) snd))" which is then simplified to "uncurry (+)" in 4 steps.
09:48:02 <shapr> neato
09:48:19 <shapr> Can you use the same code for type comparisons?
09:48:55 <shapr> I'd like to be able to search a list of type signatures.
09:49:16 <shapr> It sounds like that code could simplify types as well.
09:50:41 <TheHunter> yeah, i though about writing something that produces a function given a type signature some time ago, but that's even "more undecidable" than the rewrite process of pointless.
09:51:20 <TheHunter> but sure sounds like fun.
09:51:24 <shapr> yeah it does.
09:51:43 <TheHunter> (I even wrote some code to parse type signatures then...)
09:51:44 <shapr> I know there's been research papers on searching by type, maybe whatever they do can help pointless as well.
09:52:00 <xerox> 'evening
09:52:06 <shapr> y0
09:53:08 <xerox> oh oh, @pointless!
09:53:32 <xerox> I'm also looking foward to read the code. :-)
09:55:33 <TheHunter> i can send it to you, but there are still some changes that need to be done...
09:56:13 <xerox> It would be very nice, thanks.
10:00:11 <autrijus> TheHunter: may I ask for a copy too? :)
10:00:19 <shapr> oh me too!
10:00:21 <autrijus> autrijus at autrijus dot org
10:00:28 <shapr> shae at scannedinavian dot com
10:00:38 <xerox> xerox at neuralnoise dot com
10:00:46 <TheHunter> you don't wanna read it yet!
10:00:54 <shapr> ok, if you say so :-)
10:01:42 <xerox> In the meanwhile, let's buy one of this: http://macmini.purestatic.com/
10:02:46 <Heffalump> shapr: you know anything about debs or cabalization of hs-plugins?
10:02:51 <Heffalump> (or anyone else for that matter)
10:02:51 <shapr> I want some of these instead - http://www2.parc.com/spl/projects/modrobots/lattice/digitalclay/
10:03:10 <shapr> dons is on a south pacific island.
10:03:28 <Heffalump> oh?
10:03:31 <TheHunter> anyway, here it goes...
10:04:26 <xerox> shapr, what is it?
10:04:45 <shapr> Computer building blocks.
10:07:11 <Maddas> How's Yi coming along?
10:07:31 <shapr> nothing in the last week or so.
10:07:45 <shapr> dons is on sabbatical studying the syntax highlighting problem.
10:07:55 <Maddas> cool
10:12:42 <TheHunter> oh, to compile it, you'll have to change import PfModule to import PFModule in StaticModules.hs (i haven't yet made a proper module).
10:17:10 <bourbaki> moin
10:19:07 <shapr> y0
10:37:57 * shapr hops
10:38:36 * autrijus houses
10:48:11 <xerox> A friend of mine is saying that using (++) for list concatenation is improper, because + is commutative, list concatenating it's not. Does it have any meaning?
10:50:14 <Heffalump> xerox: well, the facts are true. The opinion is up to him/her :-)
10:50:26 <xerox> Heffalump, okay :-)
10:52:17 <bourbaki> hey TheHunter
10:53:04 <TheHunter> hey bourbaki 
10:53:17 <autrijus> :r
10:53:28 <xerox> hey hey!
10:53:36 <autrijus> oops. :)
10:54:34 <bourbaki> TheHunter: would you be able to help me lets say next weekend with the type mixing thingy? not desing wise but actually helping me on the implementation part it would surfice if you would help me setting up the type and one function
10:54:43 <xerox> What does it mean ``Lists are isomorph to natural numbers and recursion is applied in the same manner'' ?
10:56:04 <TheHunter> bourbaki, yah, ok
10:56:11 <bourbaki> TheHunter: cool thanks
10:56:18 <TheHunter> xerox, that doesn't make sense
10:56:37 <bourbaki> it doesnt?
10:57:02 <TheHunter> i guess you could say  [forall a. a] ~= [Empty] ~= Nat
10:57:02 <bourbaki> isnt recursion like induction? such that it needs to be mappable to natural numbers
10:57:11 <bourbaki> in a sense that it has a succ and a pred?
10:57:14 <TheHunter> oh no!
10:57:22 <TheHunter> [()] ~= Nat
10:57:46 <bourbaki> but empty ~ 0 ?
10:57:59 <bourbaki> i mean there is a strong connection up to an isomorphism
10:58:06 <bourbaki> you can map the nats to the elements of the list
10:58:34 <xerox> TheHunter, it's in an Haskell tutorial!
10:58:50 <TheHunter> there is an isomorphism between the list of units and the naturals.
10:59:04 <bourbaki> but to ask again in order to use recustion you need to be able to be isomorph to nat right?
10:59:19 <bourbaki> TheHunter: i think thats what they mean its just a bit lax
10:59:22 <Maddas> Couldn't one argue that using + for floating points is wrong too since it isn't associative?
10:59:54 <bourbaki> ?
10:59:57 <TheHunter> "isomorphic" has a pretty well-defined meaning.
11:00:47 <TheHunter> data Nat = Zero | Succ Nat
11:01:01 <TheHunter> data List a = Nil | Cons a
11:01:16 <TheHunter> it's similar, but it's not the same.
11:01:24 <bourbaki> its not bijective
11:01:35 <bourbaki> cause you cant map a list element to nat
11:01:49 <TheHunter> and List () is even more similar to Nat, but still not really the same in the presence of seq.
11:02:02 <bourbaki> like in a a string where you have more then one element  wich is not unambigious right?
11:02:39 <bourbaki> dang
11:03:13 <Heffalump> how can seq make List () not be Nat?
11:04:01 <TheHunter> hmm, data List a = Nil | Cons a (List a)
11:05:05 <TheHunter> Cons _|_ Nil ==> Succ Zero ==> Cons () Nil
11:05:43 <bourbaki> ?
11:06:02 <bourbaki> so Cons _|_ Nil = 1?
11:06:21 <TheHunter> _|_ = bottom = undefined = error "foo"
11:06:43 <TheHunter> it depends on how you define the mapping from List () to Nil
11:06:55 <bourbaki> isnt that just the definition of 0? and empty set?
11:07:32 <TheHunter> don't understand.
11:07:52 <bourbaki> i mean the buttom element is just an element that you can define for a sturcture
11:08:10 <bourbaki> like in a lattice where its for example the empty set if you deal with the powerset of a set as a lattice
11:08:25 <TheHunter> ok, it's like that.
11:08:28 <Cale> bourbaki: Bottom here means nontermination, which is an element of every type
11:08:33 <bourbaki> so _|_ = {} and the top is the setitself
11:09:35 <bourbaki> so buttom is of course outside the typeset of the thing you want to describe right?
11:09:54 <bourbaki> and in a lattice its the neural element for one of the operations
11:10:08 <bourbaki> so its like the 0 in a field
11:11:24 <xerox> I didn't have understand, btw :D
11:11:38 <bourbaki> and the buttom element is the termination symbol for a recursion and the start for induction
11:11:45 <Cale> bourbaki: Well, the reason why List () and Nat are not quite isomorphic is that List () has more elements in some sense, for instance [_|_, (), (), _|_, ()]
11:11:45 <bourbaki> or a possible at least
11:11:48 <jadrian> why do you say bottom is like the 0 of a field?
11:12:03 <jadrian> what are would be the field operations in this case
11:12:10 <TheHunter> xerox, ok, we have an "isomorphism" between List and Nat:
11:12:18 <TheHunter> err, List ()
11:12:24 <bourbaki> jadrian: cup and cap
11:12:32 <bourbaki> uninon and intersection
11:12:35 <xerox> TheHunter, What's List () ?
11:12:39 <jadrian> bourbaki: of lists?
11:12:49 <Heffalump> oh, cos () has a _|_ element, right.
11:12:50 <TheHunter> listToNat Nil = Zero; listToNat (():xs) = Succ (listToNat xs)
11:13:11 <TheHunter> xerox, it's a list of ()'s
11:13:16 <xerox> Aah, okay!
11:13:17 <jadrian> bourbaki: that would be []
11:13:19 <bourbaki> jadrian: in a lattice so in any poset
11:13:31 <TheHunter> xerox, that is you don't have much choice what to put into the list, only the length matters.
11:13:39 <xerox> TheHunter, I think I got it.
11:13:42 <jadrian> bourbaki: [] is neutral towards cup and absorvent towards cap
11:13:49 <jadrian> bourbaki: not _|_
11:13:49 <xerox> TheHunter, thank you.
11:13:54 <bourbaki> TheHunter: isnt that list to nat thing just an embedding?
11:14:18 <bourbaki> jadrian: _|_ is the infimum of all elements that is the empty set in sets
11:14:27 <TheHunter> bourbaki, i didn't care about nondetermination in that example
11:14:53 <TheHunter> let's say data List a = Nil | Cons !a (List a)
11:15:08 <jadrian> bourbaki: I don't understand what is your relation order/lattice here...
11:15:15 <bourbaki> TheHunter: all i thought was that it surfices to have an embedding in order to use recursion and induction
11:15:55 <bourbaki> jadrian: just the usual definition
11:16:18 <jadrian> bourbaki: I mean I don't know what the ellements of that lattice are
11:16:24 <bourbaki> look on mathworld for the thingy thats what i mean once you have a <= relation on a set you can build a lattice
11:16:29 <TheHunter> jadrian, the poweset lattice.
11:16:37 <jadrian> bourbaki: yes that I know :)
11:16:56 <bourbaki> the pwoerset thingy was just an example to show that _|_ is [] in that case
11:17:12 <bourbaki> but _|_ is also the neural element of one of the operations
11:17:37 <jadrian> cup?
11:17:42 <TheHunter> _|_ \/ a = a, _|_ /\ a = _|_
11:17:46 <bourbaki> union and intersection
11:17:51 <bourbaki> cup and cap
11:18:12 <bourbaki> we once had to proof the soundness and completness of boolean algebra
11:18:31 * jadrian can't see how _|_ \/ a = a  :-/
11:18:44 <jadrian> maybe i should just read the log
11:18:48 <bourbaki> jadrian: a is always a valid thingy
11:18:49 <jadrian> I'm probably missing something
11:19:15 <bourbaki> and since _|_ is false you bet_ |_in the and case
11:19:16 <jadrian> but if a is an element of a powerset, then a is a set
11:19:26 <bourbaki> say a was a logical expression
11:19:36 <jadrian> and the union of a set a, with _|_ is not a
11:19:42 <bourbaki> and _|_ is just false
11:19:47 <jadrian> ah yes
11:20:01 <jadrian> but
11:20:02 <jadrian> even then
11:20:22 <jadrian> sure _|_ would be false?
11:20:28 <jadrian> not in haskell it wouldn't
11:20:33 <TheHunter> in the powerset case, _|_ is the empty set, so _|_ `union` a = a
11:20:54 <jadrian> that's what I'm missing here
11:20:55 <bourbaki> well in logic thats the case at least from what i have had in my classes
11:21:04 <jadrian> are you talking about the usual logical _|_
11:21:06 <jadrian> or haskells?
11:21:16 <jadrian> because for instance, in a three valued logic
11:21:22 <bourbaki> im talking about the real logic stuff :)
11:21:23 <jadrian> _|_ would denote false
11:21:38 <jadrian> but in haskell _|_ would denote the undefined value
11:21:44 <jadrian> ah
11:21:48 <jadrian> ok then
11:21:49 <bourbaki> in lisp its nil
11:22:00 <bourbaki> and nil i guess its its own type
11:22:02 <jadrian> I thought you meant haskells _|_
11:22:08 <bourbaki> but you use it also for list termination and such
11:22:14 <jadrian> yes
11:22:28 <bourbaki> i think thats closer to _|_ im no math man though :)
11:22:46 <jadrian> depends...
11:23:08 <jadrian> I've seen _|_ with all kinds of different meanings
11:23:17 <jadrian> yes in logic it's usually  _|_ and T
11:23:21 <bourbaki> i guess its context dependant of course
11:23:30 <bourbaki> but for Nat its 0 imho
11:23:44 <jadrian> yeap
11:23:54 <shapr> y0 SyntaxNinja 
11:24:00 <jadrian> but _|_ in haskell doesn't follow that 
11:24:00 <bourbaki> because its the infimum of all elements
11:24:12 <jadrian> because all types are lifted
11:24:21 <bourbaki> :)
11:24:26 <jadrian> so you get to have your 0 and _|_
11:24:35 <bourbaki> i wish i had courses on these things here
11:24:39 <bourbaki> but we dont
11:24:57 <bourbaki> im thinking about starting a 4th study :) math this time not sure yet though
11:25:12 * jadrian likes math :)
11:25:32 <bourbaki> my problem is i need the right ppl around me
11:25:43 <jadrian> I know what you mean
11:25:51 <bourbaki> when i do math i need to talk alot with others to see whats the thing in what i read
11:25:52 <jadrian> I learned that the hard way :-/
11:26:02 <shapr> I've never had that luxury.
11:26:03 <bourbaki> i just read mathbooks out of interest
11:26:06 <shapr> but I have IRC!
11:26:16 <jadrian> I like IRC but it screws my wrists
11:26:20 <shapr> yeah, true
11:26:24 <shapr> We need VoIP
11:26:28 <jadrian> yeap
11:26:32 <shapr> video conferencing
11:26:38 <shapr> some sort of shared whiteboard
11:27:03 <bourbaki> does anyone of you happen to know a database with 3d scans of faces?
11:27:05 <shapr> An avatar system like OpenCroquet might work too
11:27:09 <SyntaxNinja> y0
11:27:17 <shapr> hey dude4545 
11:27:30 * shapr sings "hey dude, don't be afraid"
11:27:56 <SyntaxNinja> shapr: don't quit your day job ;)
11:28:01 * shapr snickers
11:28:15 <bourbaki> why hasnt anyone yet ever written a mix of these no post/ latex/ imageshack and irc?
11:28:29 <shapr> whah?
11:28:51 <shapr> post latex?
11:29:00 <bourbaki> i want to post fomrulas
11:29:04 <shapr> oh
11:29:11 <bourbaki> but not in the normal text but in a side window
11:29:20 <shapr> yeah, I agree.
11:29:21 <bourbaki> so you can think about it while you talk and make corrections
11:29:27 <shapr> SILCnet could do it.
11:29:28 <Heffalump> moinmoin can handle LaTeX, can't it?
11:29:34 <bourbaki> like a mulituser edit window
11:29:47 <shapr> right, I've wanted that, but IRC is a crap protocol.
11:29:57 <shapr> SILCnet is a much better system all'round
11:30:00 <bourbaki> shapr: it is?
11:30:13 * Maddas didn't have any wrist problems for quite a long time (luckily)
11:30:16 <shapr> utf-8-only, encrypt-only, MIME messages, netsplit resistant, etc
11:30:36 <SyntaxNinja> so who owns the brick book? should I get it?
11:30:37 <shapr> MIME messages mean you could easily do shared editing while doing text chat, voice chat, or whatever.
11:30:47 <bourbaki> well i can live with simple text :)
11:30:48 <shapr> SyntaxNinja: BC Pierce, and yes if you like type theory.
11:30:59 <bourbaki> that surfices to transmit anything
11:31:13 <SyntaxNinja> I want to learn some type theory. all the guys at GC have no advice about books, presumably they all learned in school.
11:31:15 <shapr> bourbaki: I've learned that voice chat + editing of whatever is best for me.
11:31:24 <shapr> get TaPL
11:31:34 <shapr> It's da bomb.
11:31:39 <bourbaki> voice chat ....
11:31:40 <shapr> It's also heavy enough to be used for self-defense.
11:31:48 <bourbaki> that so sucks imho text is the best thing 
11:31:49 <shapr> bourbaki: it's an out of band signal.
11:31:57 <bourbaki> cause i can scroll and reread
11:32:05 <bourbaki> and do that with more ppl then just one
11:32:07 <shapr> You can't do irc and source code editing at the same time, you lose flow.
11:32:09 <shapr> true
11:32:33 <bourbaki> you dont write code you just look at it and think
11:32:46 <SyntaxNinja> TaPL?
11:32:50 <bourbaki> its like posting to one of these no paste sites just that its in the asme app
11:33:11 <shapr> Types and Programming Languages
11:34:03 <SyntaxNinja> oh, tbb ;)
11:34:11 <shapr> ?
11:34:14 <shapr> ah, yes
11:34:17 <shapr> The Brick Book.
11:34:21 <SyntaxNinja> I just emailed him about an idea for a problem wrt type classes
11:34:45 <shapr> I had some ideas, but I don't really have time to sit down and think them through. This website must be ready by Monday.
11:37:17 * SyntaxNinja smiles at ross for hacking on the cabal
11:38:28 * Heffalump ought to try to contribute something to it rather than just complaining about bugs or missing features all the time
11:38:42 <SyntaxNinja> heh at Powells.com they keep having a picture of a pretty attractive female author on the left side of the web page, and whenever I look up a book, I say to myself, "That's Benjamin Pierce?!" or "That's Daniel Quinn?!"
11:38:50 <SyntaxNinja> Heffalump: your complaining has been very helpful
11:38:53 <SyntaxNinja> but yes, please hack.
11:54:45 <syntax_syntax> hello.
11:54:50 <xerox> hi!
11:54:50 <shapr> greetz
11:55:03 <syntax_syntax> i just noticed http://paste.lisp.org has a "#haskell" syntax highlighting mode.
11:55:09 <syntax_syntax> are you aware/behind of that?
11:55:12 <xerox> It has :D
11:55:42 <shapr> lisppaste2: url
11:55:43 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:56:45 <syntax_syntax> fun.
11:56:53 <syntax_syntax> I've been using pastebin.com with this channel forever
11:57:07 <syntax_syntax> and it always inserts random php crap.
11:57:08 <shapr> most people use the Haskell Wiki
11:57:20 <syntax_syntax> for collective development?
11:57:31 <lisppaste2> TheHunter pasted "test" at http://paste.lisp.org/display/5365
11:57:37 <xerox> @paste
11:57:37 <lambdabot> Sorry, I don't know the command "paste", try "lambdabot: @listcommands"
11:57:42 <syntax_syntax> ohhh
11:57:48 <xerox> Hm.. 
11:57:59 <xerox> syntax_syntax, no no, I mean, the wiki has a paste page.
11:58:01 <syntax_syntax> I usually come here with the stupidest  questions. People are amazingly patient when they're passionate about fringe programming languages.
11:58:02 <shapr> TheHunter: is that using the #haskell syntax highlighting?
11:58:11 <shapr> syntax_syntax: FRINGE?
11:58:18 <shapr> I have never seen a programmable fringe!
11:58:25 <lisppaste2> syntax_syntax pasted "I hate space-sensitiveness" at http://paste.lisp.org/display/5366
11:58:26 <shapr> Maybe you meant fridge?
11:58:30 <TheHunter> shapr, i was testing if it was, but it appears not.
11:58:40 <shapr> @wiki HaskellIrcPastePage
11:58:40 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:58:43 <syntax_syntax> oh :)
11:58:46 <TheHunter> actually, i didn't expect that to show up in the channel.
11:58:51 <syntax_syntax> so, what's wrong with that snippet?
11:59:00 <syntax_syntax> I can't seem to get the formatting rules right with Haskell.
11:59:23 <shapr> syntax_syntax: Parlez vous français?
12:00:01 <shapr> habitez vous en Quebec? :-)
12:00:04 <syntax_syntax> shapr heh. j'essaye.
12:00:08 <syntax_syntax> nah, I live in Rio.
12:00:09 <syntax_syntax> de Janeiro.
12:00:12 <shapr> nifty
12:00:26 <shapr> j'habite en Suede(?)
12:00:37 <syntax_syntax> so what could I be possibly doing wrong with my indentation in that snippet? :-(
12:00:39 <shapr> c'est chouette
12:01:02 <shapr> syntax_syntax: throw your else in one more space
12:01:18 <syntax_syntax> ohhh
12:01:20 <shapr> case is easier when you have nested ifs like that.
12:01:30 <shapr> hej hram 
12:01:41 <shapr> kör du enhjuling?
12:01:46 <hram> nope
12:01:55 <shapr> tyvärr...
12:02:01 <syntax_syntax> yes! :)
12:02:13 <syntax_syntax> I spent 20 minutes in frustration messing around with that.
12:02:23 <syntax_syntax> {'s and }'s are so more reasonable.
12:02:27 <shapr> finns en ny svensk enhjuling webbsidan...
12:02:31 <shapr> syntax_syntax: no they're not.
12:02:53 <shapr> They're only reasonable if you don't use indentation at all, and you don't use \n
12:03:09 <syntax_syntax> well, I use indentation, but I don't want it to get in my way.
12:03:21 <syntax_syntax> Anyway, when in foreign lands, learn their ways.
12:03:24 <shapr> First of all, Haskell accepts both.
12:03:47 <shapr> Second of all, indentation in place of {}; means that program structure is immediately obvious.
12:03:59 <Cale> syntax_syntax: think of the "then" and "else" parts as being "inside" the if, and you should find that things make more sense
12:04:12 <shapr> It might take a bit of time to get used to it, but it's much easier to read once you know it.
12:04:30 <hram> as long as people stop using TAB...
12:04:31 <shapr> syntax_syntax: right, if is actually a function in Haskell.
12:04:37 <shapr> yes, TAB suxx
12:04:43 <syntax_syntax> why does tab suck?
12:04:53 <shapr> because it can be interpreted differently
12:04:54 * syntax_syntax goes find out how to make is tab key do spaces in vim
12:05:06 <hram> because most people think it is equvalent to 8 spaces...
12:05:09 <shapr> because email programs expand or eat tabs differently..
12:05:10 <desrt> expandtabs
12:05:21 <hram> s/equvalent/equivalent/
12:05:22 <shapr> hiya lypanov 
12:05:26 <shapr> What can we do for ya?
12:05:29 <desrt> ie:   :set expandtab
12:05:32 <lypanov> yoyo shapr
12:05:38 <lypanov> shapr: just looking around :)
12:05:39 <shapr> lypanov: You want the short Haskell intro?
12:05:46 <shapr> I can give ya tha tour.
12:05:50 <shapr> if'n ya want
12:06:03 <syntax_syntax> ogh. thanks.,
12:06:08 * shapr switches into Southern American
12:06:12 <lypanov> hehe
12:06:14 <shapr> how y'all doin?
12:06:25 <desrt> isn't that southern northern american?
12:06:41 <syntax_syntax> you should say something like "redneck"
12:06:43 <shapr> Ah'm frum Selma, Alabayumuh boy!
12:06:59 <syntax_syntax> Red Hat, for one, recognizes Redneck as an official dialect. if Ebonics is, why not?
12:07:05 * shapr snickers
12:07:08 <shapr> truly
12:07:15 <desrt> export LANG=en_REDNECK ?
12:07:19 <shapr> I learned both redneck and ebonics while growing up.
12:07:31 <lypanov> shapr: probably not today though maybe next week interest is certainly increasing :)
12:07:38 <shapr> Though these days I do export LANG=se_CHEF
12:07:43 <lypanov> shapr: thanks for the offer :)
12:07:50 <desrt> shapr; only supported on google
12:08:05 <shapr> lypanov: you want to look at the baskin-robbins Haskell taster?
12:08:17 <shapr> I dunno if they do that in ice cream stores in .nl
12:08:28 <shapr> Where you can take a tiny spoon of ice cream to see if you like what they're selling.
12:08:48 <lypanov> hehe
12:08:51 <lypanov> sure ;)
12:08:56 <shapr> @wiki HaskellDemo
12:08:56 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
12:09:09 <lypanov> as long as it involves hugs and ice cream i'm happy :P
12:09:12 <shapr> haha
12:09:41 <edwinb> Bah, nobody ever gave me ice cream.
12:09:45 <edwinb> I must have learned from the wrong place.
12:09:48 * shapr grins
12:09:52 <syntax_syntax> hehehe that's cool.
12:10:05 <syntax_syntax> I should explore the hawiki some more. I'm learning from htut
12:10:15 <shapr> htut is nice.
12:10:18 <shapr> HaWiki is nice too.
12:10:46 <shapr> I wrote most of the HaskellDemo, so if you see something that's not clear, or something you don't like, tell me!
12:10:50 <shapr> I want to improve it!
12:11:18 <syntax_syntax> I like htut better than the Gentle Introduction.
12:11:49 <shapr> me too
12:12:08 <shapr> htut got started because I complained bitterly about the Gentle Intro being the intellectual equivalent of a brickbat.
12:12:39 <shapr> er, htut == YAHT?
12:12:48 <SyntaxNinja> do they still use SICP at MIT?
12:12:52 <shapr> I think so.
12:13:03 <xerox> Maybe it's referring to HaskellTutorial.pdf
12:13:09 <xerox> *he's sorry.
12:13:22 <syntax_syntax> shapr what IS a brickbat?
12:13:29 <syntax_syntax> htut = htut.
12:13:40 <bourbaki> afaik scip is used at quite some places
12:13:46 <shapr> @wn brickbat
12:13:47 <lambdabot> *** "brickbat" wn "WordNet (r) 2.0"
12:13:47 <lambdabot> brickbat
12:13:47 <lambdabot>      n 1: a fragment of brick used as a weapon
12:13:48 <lambdabot>      2: blunt criticism
12:14:02 <bourbaki> if im not mistaken they also say it on the website which unis are useing it
12:14:03 <syntax_syntax> http://www.isi.edu/~hdaume/htut/
12:14:12 <syntax_syntax> oh.
12:14:52 <syntax_syntax> @wn emotional vampire
12:14:54 <lambdabot> *** "emotional" wn "WordNet (r) 2.0"
12:14:54 <lambdabot> emotional
12:14:54 <lambdabot>      adj 1: determined or actuated by emotion rather than reason; "it
12:14:54 <lambdabot>             was an emotional judgment" [ant: {cerebral}]
12:14:55 <lambdabot>      2: of more than usual emotion; "his behavior was highly
12:14:57 <lambdabot>         emotional" [ant: {unemotional}]
12:14:59 <lambdabot>      3: of or pertaining to emotion; "emotional health"; "an
12:15:01 <lambdabot>         emotional crisis"
12:15:03 <lambdabot> [13 @more lines]
12:15:06 <syntax_syntax> I promise not to do that anymore :-D
12:15:15 <xerox> Okay, it's YAHT.
12:15:47 <syntax_syntax> "Htut" has the virtue of not begin YAOA, unlike YAHT.
12:15:59 <syntax_syntax> It sounds like an african word.
12:16:03 <syntax_syntax> Hutus, Tutsis and Htuts
12:16:21 <shapr> hottentots?
12:16:36 <SyntaxNinja> meh I saw Hotel Rwanda last night
12:16:41 <shapr> wassat?
12:17:00 * shapr asks google
12:17:08 <shapr> lypanov: what do you think of the Haskell Demo?
12:17:19 <lypanov> shapr: pretty neat :)
12:17:35 <shapr> Any suggestions for improvement?
12:18:40 * lypanov doesn't know what Show is
12:19:00 <shapr> It means "automatically give me a way to display this type as a string"
12:19:05 <shapr> that's "derive Show"
12:19:17 <lypanov> k. assumed that but a short explanation -> example would be good :)
12:19:24 <shapr> ah, good point.
12:19:46 <lypanov> also the 'can't be sensibly defined for anything other than char' doesn't really make all that much sense to me
12:20:03 <shapr> Just that vowels are only defined for the alphabet.
12:20:09 <shapr> You can't really make vowels out of numbers.
12:20:39 <lypanov> ok. but you could make xml out of it?
12:20:41 <shapr> sure
12:20:49 <shapr> you can turn both letters and numbers into xml
12:20:49 <lypanov> maybe an example would be useful :)
12:20:53 <shapr> good point
12:21:06 <lypanov> also, the guard bit should have a little example. as the usage is non apparent
12:21:16 <shapr> ah yes
12:21:32 <lypanov> in fact, for most of them, it would be nice to see a small snippet that can be pasted into hugs, and see the output you'd get
12:21:54 <shapr> excellent point, I'll add those.
12:23:27 <lypanov> also in the mylength example, change it to say 'above means that if a list is passed to mylength'
12:23:34 <lypanov> rather than saying mylength, just say 'the function'
12:24:02 <shapr> ok
12:24:29 <lypanov> by the point i got to that i was confused as to the name of the function and with blinding ignorance missed the recursion point ;)
12:24:44 <shapr> I need to make way to show what is typed into hugs and what should be returned
12:24:47 <shapr> What do you mean?
12:25:32 <lypanov> well. by saying mylength rather than 'the function' i misunderstood
12:25:44 <lypanov> but i guess thats just cus i'm insanely stupid and other people wouldn't have the same problem :p
12:27:03 <shapr> recursion is a difficult step if you're used to procedural languages
12:27:09 <shapr> It was hard for me, at least.
12:27:30 <edwinb> People often find recursion and pattern matching hard.
12:27:37 <edwinb> I wonder if an example of pattern amtching on trees would be useful
12:27:53 <SyntaxNinja> people often find people who often find recursion and pattern matching hard hard.
12:28:03 <lypanov> hehe
12:28:40 <edwinb> you can say that again.
12:28:47 <lypanov> anything that can prove to me that this can do stuff than ruby could never do. is good :)
12:28:58 <SyntaxNinja> edwinb: no, I can't. that would be imperative.
12:29:02 <lypanov> and lazy evaluation without real examples. doesn't really show it off :/
12:30:07 <shapr> lypanov: at some level, all languages are equal. It's just that they make different tasks easier.
12:31:18 <lypanov> shapr: the main problem i've always had with more or less anything but for ruby comes really down to one thing: how many compile-edit cycles does it take before the code i wrote compiles, and how efficient the test cycle is
12:31:52 <shapr> I believe that the test cycle in many languages can be as small as what you have with Ruby.
12:32:05 <xerox> Let's say LISP!
12:32:07 <CosmicRay> syntax_syntax: areya here?
12:32:11 <lypanov> test cycle yes, agreed, exception: c++
12:32:17 <shapr> lypanov: but, let me prove it to ya :-)
12:32:20 <lypanov> but
12:32:23 <shapr> @wiki HaskellMode
12:32:24 <lambdabot> http://www.haskell.org/hawiki/HaskellMode
12:32:28 <CosmicRay> what do you recommend for infrastructure to interface to C?  Basic ffi?  hdirect? c2hs?  hsc2hs?  greencard?
12:32:30 <lypanov> shapr: not the second point but the first was the most important one
12:32:34 <CosmicRay> I am a little baffled by all the choices
12:32:44 <SyntaxNinja> hey CosmicRay; thanks for packing hunit, btw :)
12:32:49 <Cale> lypanov: One of the things I like about Haskell is that the type checking is strong enough to not let you compile code with obvious bugs in it.
12:32:52 <lypanov> shapr: basically. how good are the error messages when compiling?
12:32:54 <CosmicRay> SyntaxNinja: no problem :-)
12:33:04 <CosmicRay> SyntaxNinja: speaking of which, I have some cabal questions
12:33:07 <Cale> (More subtle bugs of course won't be caught)
12:33:10 <Maddas> Cale: I don't think all obvious bugs cause type errors :-)
12:33:11 <SyntaxNinja> CosmicRay: shoot
12:33:16 <shapr> lypanov: most of the time they're excellent, if you use some of the more advanced features, they can be scary.
12:33:16 <CosmicRay> SyntaxNinja: which, if any, of the above C interfaces do you support in cabal?
12:33:26 <lypanov> Cale / shapr: so i imagine that the error messages are sane, the killer with c++/templating is without a doubt the problems with error reporting in c++
12:33:32 <shapr> lypanov: but, the types that you use greatly affect the error messages. You choose how much information you encode into your typees.
12:33:45 <SyntaxNinja> I think ffi is supported pretty directly
12:33:47 <lypanov> shapr: can it report more than one error at any given time?
12:33:51 <shapr> yes
12:34:02 <CosmicRay> SyntaxNinja: right, and I think you do hsc2hs also
12:34:11 <CosmicRay> SyntaxNinja: which is a fairly thin layer.
12:34:12 <Cale> Maddas: Well, by "obvious" I basically mean "not-algorithm-level"
12:34:14 <lypanov> and messages aren't cryptic with references to ansi standards? ;) (gcc)
12:34:17 <shapr> but some errors it can't see past. Type checking can depends on much of the program.
12:34:24 <SyntaxNinja> CosmicRay: there are hsc2hs, and c2hs preprocessors, and no one has complained about them :)
12:34:35 <shapr> It gives a line number, the error, and in some cases a proposed fix.
12:34:41 <lypanov> nice
12:34:41 <CosmicRay> SyntaxNinja: cabal suports both directly?
12:34:58 <lypanov> is there a standard lib reference?
12:35:02 <SyntaxNinja> CosmicRay: yeah, if you have a module "Foo.chs" then it'll run the preprocessor on it to get Foo.hs, then compile that
12:35:13 <SyntaxNinja> that is, if you have a module "Foo" in you rmodules list.
12:35:16 <CosmicRay> SyntaxNinja: great.
12:35:16 <lypanov> how is the support for e.g, regexps, http, templating etc?
12:35:18 <shapr> lypanov: yes, there is. The Prelude stdlib is part of the standard.
12:35:31 <CosmicRay> syntaxninja: ok, next question.  let me lay out what I'm planning to do.
12:35:38 <shapr> regexp support is decent, http support is good, what sort of templating ?
12:35:44 <lypanov> html templating
12:35:48 <SyntaxNinja> but I think that the FFI stuff is used by turning on the "ForeignFunctionInterface" extension.
12:35:54 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- there's the reference for the libraries that come with GHC
12:35:57 <CosmicRay> SyntaxNinja: I want to have a package of fairly simple -- but important -- C bindings that are missing from common Haskell.  Call it MissingExts maybe.
12:36:03 <shapr> Halipeto is a way cool html templating system for Haskell.
12:36:07 <shapr> I'm using it for my personal website.
12:36:09 <lypanov> i have one app that i wanted to write in the coming weeks, and i guess i could go the route of haskell rather than ruby for a first time :)
12:36:16 <CosmicRay> SyntaxNinja: Things like zlib, openssl, bz2lib, pcre, etc.  all in one place, and working with modern compilers.
12:36:24 <shapr> lypanov: it's at least worth trying.
12:36:30 <SyntaxNinja> CosmicRay: sounds nice :)
12:36:47 <CosmicRay> SyntaxNinja: Now, I think I already know how to generate multiple ghc packages out of a source tarball with Cabal.
12:36:52 <SyntaxNinja> sometimes I think I should just spend my time making things easy for CosmicRay and david roundy
12:36:56 <shapr> lypanov: the input/output model of Haskell is surprising, but very cool once you get it.
12:37:00 <shapr> haha
12:37:02 <shapr> SyntaxNinja: yes!
12:37:11 <CosmicRay> SyntaxNinja: what I'm wondering is: does cabal have features to turn on or off the building of individual packages?
12:37:24 <lypanov> shapr: and long as i can see an example with input and output there'll be no real problem :)
12:37:38 <shapr> lypanov: we'll see ;-)
12:37:51 <lypanov> shapr: i read the spec years back
12:37:56 <CosmicRay> syntaxninja: so, for instance, someone could get zlib and ncurses even if they don't have openssl
12:37:56 <shapr> lypanov: anyway, lots of helpful people here on #haskell, anytime you have any questions...
12:37:58 <SyntaxNinja> CosmicRay: hmm. how are you planning to build multiple ghc packages?
12:38:06 <lypanov> shapr: just never got around to programming in it :)
12:38:15 <SyntaxNinja> CosmicRay: you mean debian ghc packages?
12:38:17 <CosmicRay> SyntaxNinja: IIRC, I could just have multiple sections in my .cabal file
12:38:25 <shapr> You can of course ask me, since I dragged you into the channel in the first place ;-)
12:38:27 <CosmicRay> syntaxninja: no, I mean straight ghc packages
12:38:31 <SyntaxNinja> CosmicRay: you can only have one library in a single .cabal file
12:38:35 <CosmicRay> hmm.
12:38:43 <CosmicRay> what does cabal do with multiple .cabal files these days?
12:38:51 <CosmicRay> if I run setup build, would it scan and process them all?
12:38:56 <SyntaxNinja> it'll kick you in the shins
12:39:04 <SyntaxNinja> but I'm thinking of having it process them all instead ;)
12:39:10 <CosmicRay> hah
12:39:11 * shapr finishes the lypanov suggested changes for HaskellDemo
12:39:14 <SyntaxNinja> but that sorta depends on what we decide to do with multiple executables and stuff
12:39:33 <CosmicRay> SyntaxNinja: well I know you can already do multiple executables, but I'm going to have zero executables
12:39:35 <SyntaxNinja> so there's a movement to 'nix multiple executables, and just have a single exe OR a single library in a single .cabal file
12:39:46 <lypanov> shapr: say bing when i can reload :)
12:40:02 <CosmicRay> SyntaxNinja: that could make some sense, so if I've got a package with a lib and an exe, I make the exe dep on the lib... 
12:40:11 <SyntaxNinja> CosmicRay: there's a one-to-one relationship between "cabal packages" and "haskell packages". so you can't have more than one library in a cabal package
12:40:12 <CosmicRay> SyntaxNinja: you would just have to know to look in a .cabal file to resolve that dep.
12:40:50 <SyntaxNinja> CosmicRay: yeah, but it doesn't make anything much easier, to tell the truth, because it's necessary to install the library before building the executable! which sucks.
12:41:04 <syntax_syntax> oh
12:41:08 <syntax_syntax> I'm back, finally.
12:41:12 <CosmicRay> SyntaxNinja: couldn't you hack around that by adjusting include paths?
12:41:25 <SyntaxNinja> CosmicRay: that's what we do now, basically, but not in the general case
12:41:54 <SyntaxNinja> CosmicRay: let's say that the library MUST sit in /usr/lib to work, or must do some final post-install step in order to work or to do the right thing when compiling the executable
12:42:00 <shapr> lypanov: check it
12:42:05 <CosmicRay> hm.
12:42:09 <CosmicRay> nasty.
12:42:17 <SyntaxNinja> yeah. but for simple libraries, it's simple.
12:42:19 <shapr> lypanov: not everything is in, what do you think about the improvements so far?
12:42:52 <SyntaxNinja> CosmicRay: so one idea is to have it install itself temporarily under dist/tmp or something, with a temporary packages.conf file, and use a -package foo flag and everything
12:43:05 <SyntaxNinja> which is probably about as good as one can reasonably expect.
12:43:11 <xerox> shapr, talking about suggestion, can you make an example of using defined datatypes (like the season one, or maybe the People one)?
12:43:22 <lypanov> shapr: perfect :)
12:43:29 <shapr> xerox: what about mTree ?
12:43:31 <shapr> myTree?
12:43:44 <xerox> shapr, I can't understand it completely, I think
12:43:47 <shapr> ah, ok
12:44:58 <shapr> Cale: how old are you?
12:45:06 <Cale> 21
12:45:08 <shapr> ok
12:45:34 <Cale> why do you ask?
12:45:43 <shapr> you're an example to the rest of us now ;-)
12:45:57 <SyntaxNinja> CosmicRay: can't reach pakcages.d.o, is HUnit there for ppc?
12:46:35 <CosmicRay> SyntaxNinja: should be, check http://ftp.debian.org/debian/pool/main/h/hunit
12:46:43 <CosmicRay> packages.d.o is down due to the hp power outage
12:46:53 <SyntaxNinja> ahh
12:46:55 <shapr> outstanding requests are.. more examples, more general typeclass demo, and more lazy evaluation demos.
12:46:57 <Cale> shapr: ah, heheh
12:47:32 * shapr grins
12:47:55 <CosmicRay> SyntaxNinja: it's there for alpha, hppa, i386, ia64, m68k, powerpc, s390, sparc, and amd64.
12:48:03 <CosmicRay> and hugs.
12:48:27 <shapr> xerox: what do you think of the Person examples?
12:48:43 <SyntaxNinja> CosmicRay: cool. thanks.
12:49:03 <SyntaxNinja> I want to be able to use cabal to build packages for hugs, but ross paterson isn't too concerned w/ making it work with Hugs Nov '03
12:49:25 <CosmicRay> SyntaxNinja: I already use it to build stuff for hugs
12:49:32 <xerox> I understand (I hope correctly) that Person is a data constructor that needs two arguments of types Name and Age, that are aliases for, respectively, String and Int.  But I can't think of how to use it.
12:49:33 <CosmicRay> that's how the hugs hunit appears, for instance
12:50:08 <shapr> xerox: authors = [author1,author2]
12:50:23 <SyntaxNinja> CosmicRay: really? It's possible that it's now broken. have you tried it w/ 0.4?
12:50:45 <xerox> C-x 2 C-x C-f foo.hs RET okay, let's try.
12:50:46 <CosmicRay> yes, I built MissingH with it recently
12:50:51 <CosmicRay> though I guess I didn't test the result.
12:51:22 <SyntaxNinja> OK so maybe he left my original hacks in place.  well, that's good :) cabal does more than I thought :)
12:51:37 <CosmicRay> hugs support is a Good Thing to have
12:51:48 <CosmicRay> that is the only way I can hack haskell on my Zaurus :-)
12:51:49 <xerox> shapr, also, why isn't it data People Name Age = Person .. ?
12:52:15 <SyntaxNinja> CosmicRay: tell me that you're using cabal on your zaurus?
12:52:30 <shapr> xerox: you only see types after the type name if they're parameters.
12:52:44 <CosmicRay> SyntaxNinja: well it's not grunty enough to run ghc, so though I probably could run cabal with hugs, I'm not
12:52:54 <SyntaxNinja> :(
12:53:03 <CosmicRay> SyntaxNinja: though I do have a debian environment, so I can install stuff that was built with cabal on higher-end arm machines :-)
12:53:08 <xerox> shapr, what does it mean? Aren't they parameters in this case? (of the constructor?)
12:53:09 <CosmicRay> SyntaxNinja: this thing has 64M RAM
12:53:13 <SyntaxNinja> yeah
12:53:27 <shapr> xerox: constructor is on the right hand side. Type name is on the left hand side.
12:53:49 <SyntaxNinja> you might be able to get cabal working w/ hugs; it used to, I think that's actually what I had trouble with using hugs nov '03
12:54:01 <SyntaxNinja> it won't bootstrap w/ hugs anymore, though that should be too hard maybe
12:54:02 <shapr> if you had "data Person a = Person String a" then you could substitute any type for the a
12:54:06 <CosmicRay> oh, you mean run cabal itself with hugs.
12:54:09 <CosmicRay> that I haven't tried.
12:54:12 <xerox> shapr, Ah! I see
12:54:13 <SyntaxNinja> isn't that what you meant?
12:54:20 <CosmicRay> I have build cabal with ghc, and used that cabal to build hugs packages.
12:54:26 <CosmicRay> I thought that's what you meant, sorry
12:54:26 <SyntaxNinja> ahh
12:54:32 <shapr> xerox: that's what the Tree does later in the demo. It lets you build trees that hold any type.
12:54:57 <SyntaxNinja> I'd better go hack on cabal. yell if you need anything
12:55:11 <CosmicRay> ok, have fun
12:55:19 <shapr> xerox: The C++ equivalent to paramaterized datatypes is more work. I'm not sure if Java can do it at all.
12:55:48 <xerox> shapr, I'd like to see some functions actually using / modifing / creating data of defined types
12:55:58 <xerox> If it could be possible
12:56:06 <SyntaxNinja> ta
12:56:12 <shapr> author1 and author2 are values of type Person that get created.
12:56:23 <shapr> sure, I'll put in a modify function.
12:56:31 <xerox> Great.
12:57:10 * Cale added makeOlder :)
12:57:13 <shapr> ah
12:57:17 <shapr> I was just doing birthday :-)
12:57:23 <shapr> birthday (Person n a) = Person n (a+1)
12:57:28 <Cale> yeah
12:57:34 <Cale> that's a better name for it
12:57:57 <xerox> I see, that's clear, pattern matching!
12:58:01 <shapr> yup
12:58:48 <xerox> That's a big ah-ha! I did have some big problem in thinking howt o recognize those things in some function I wanted to make.
12:59:12 <shapr> I wonder if birthday should go under the pattern matching section as an example there.
13:00:32 <xerox> Leave it there! Helful example, at least for me :-)
13:01:02 <shapr> moving it down a few lines would show that it's using pattern matching to get those values out of the Person value
13:01:20 <xerox> Okay.
13:01:55 <shapr> let's see, what else was missing...
13:02:07 <shapr> I could define a cheesy XML typeclass.
13:02:10 <xerox> Could it be possible to have something different than sum of numbers in the leaf of the Tree as example for the polymorphic datatype?
13:02:37 <shapr> myOtherTree has Seasons in the leaves.
13:03:02 <xerox> I should probably try myself.
13:04:59 <Cale> shapr: how poetic
13:05:05 <shapr> :-)
13:05:34 <shapr> I thought it was nice at the time.
13:05:48 <shapr> Or just very silly. Sometimes they're the same.
13:06:20 <xerox> mylength = sum . map (const 1)
13:06:34 <xerox> Is that because of function like this that const exists?
13:07:00 <shapr> yes
13:07:10 <xerox> Interesting.
13:07:35 <shapr> where'd you find that version of length?
13:07:47 * xerox produced it
13:07:57 <xerox> my alter ego is saying "liar!"
13:07:58 <shapr> I've seen it a few times. It's a good demo of const.
13:08:12 <xerox> I found it in HaskellTutorial.pdf
13:08:17 <shapr> ah, ok
13:08:49 <shapr> I wonder if the cute lazy list version of fibonacci series is a good example of lazy eval.
13:08:57 <xerox> Can you suggest me some function I can try to make, working with the Tree Season datatype?
13:08:57 <shapr> or if it's too complicated.
13:09:11 <shapr> xerox: nextSeason
13:09:44 <xerox> shapr, a function returing an isomorphic Tree with the next seasons in place of the old ones?
13:10:07 <shapr> If you really wanna stretch your brain, you can make a nextSeason that will work for Tree Season, [Season], and other collections of Season very simply.
13:10:19 <shapr> yup
13:10:40 <xerox> Hmm
13:10:59 <shapr> I'd start with a function that can just go to the next season.
13:11:06 <xerox> Yep.
13:11:23 <xerox> something like deriving Ord could help?
13:11:28 <shapr> The easiest solution would require Season to be an instance of Enum
13:11:40 <xerox> enum, not ord!
13:11:53 <shapr> but close :-)
13:12:04 <xerox> :D
13:14:27 <xerox> *Foo> map nextSeason [Winter, Spring, Summer, Fall]
13:14:27 <xerox> [Spring,Summer,Fall,Winter]
13:14:30 <xerox> yay
13:14:43 <shapr> yay
13:15:05 <xerox> Now Season derives Show, Enum and Eq
13:15:14 <shapr> spiffy
13:15:22 <xerox> Does it mean "bad" ?
13:15:28 <shapr> spiffy means good
13:15:36 <xerox> whoa.
13:16:55 * shapr bounces cheerfully
13:20:19 <xerox> *Foo> myTree
13:20:19 <xerox> Node Nil Winter (Node Nil Summer Nil)
13:20:19 <xerox> *Foo> foo myTree
13:20:19 <xerox> Node Nil Spring (Node Nil Fall Nil)
13:20:22 <xerox> yay^2 ?
13:20:28 <shapr> yay!
13:21:09 <shapr> did you use the methods from the Enum typeclass?
13:21:25 <shapr> @info Enum
13:21:25 <xerox> shapr, I used succ
13:21:26 <lambdabot> -- Enum is a class
13:21:26 <lambdabot> class Enum a where {
13:21:26 <lambdabot>     pred :: a -> a {- has default method -};
13:21:26 <lambdabot>     succ :: a -> a {- has default method -};
13:21:26 <lambdabot>     toEnum :: Int -> a;
13:21:26 <lambdabot>     fromEnum :: a -> Int;
13:21:29 <lambdabot>     enumFrom :: a -> [a] {- has default method -};
13:21:30 <lambdabot>     enumFromThen :: a -> a -> [a] {- has default method -};
13:21:31 <shapr> right, that's the best choice.
13:21:32 <xerox> So, yes
13:21:33 <lambdabot>     enumFromTo :: a -> a -> [a] {- has default method -};
13:21:34 <lambdabot> [2 @more lines]
13:21:39 <shapr> gee, that was a bit too much info
13:21:43 <shapr> Thank Mr Data!
13:21:46 <xerox> I did a quick lookup on http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
13:21:48 <shapr> er "Thank You Mr Data!"
13:22:16 <xerox> Eheh, is there something like the lambdabot output?
13:23:09 <shapr> it comes from ghc
13:23:12 <shapr> :i Enum
13:23:28 <xerox> That's even greater.
13:24:59 <shapr> ok, extra credit question....
13:25:09 <xerox> Sure!
13:26:09 <shapr> How can you use the Functor typeclass to get the same nextSeason function to work on [Season], myTree, and other collections?
13:26:20 * xerox hides
13:26:29 <xerox> Let me read about Functors first
13:26:32 <shapr> :-)
13:27:25 <SyntaxNinja> Functors are fun and easy!
13:28:04 <xerox> When you know what a functor is, perhaps :-)
13:28:22 <SyntaxNinja> xerox: if you understand map, then you understand the Functor class
13:28:30 <jadrian> just think of it as stuff that can be mapped
13:33:23 <xerox> The most important thing is the distinction between the type name (Polynom)
13:33:23 <xerox> and the type constructor (Poly). The type name comes always in lines con-
13:33:23 <xerox> cerning the type information (containing `::'), and the type constructors in lines concerning application (containing `='). Type constructors are the only func-
13:33:23 <xerox> tions starting with a capital letter, and the only functions that can appear on
13:33:23 <xerox> the left-hand side of an expression.
13:33:41 <shapr> ?
13:33:44 <xerox> Does it mean that type names can compare in the right-hand side?
13:34:37 <shapr> ?
13:35:14 <shapr> try it, cuz I don't know what you mean
13:35:31 <xerox> It doesn't make so much sense
13:35:55 <xerox> It says "Type constructors are the only functions that can appear on the left-hand side of an expression"
13:36:48 <xerox> the type name isn't a function at all, right? So what does that sentence mean?
13:37:03 <Heffalump> I think it means data constructors.
13:37:12 <Heffalump> which are functions
13:37:45 <lightstep> i think it's refers to pattern matching
13:37:51 <Heffalump> yes
13:38:58 <xerox> They can appear everywhere in expression. But it is saying that only them can appear on the left hand side, okay, does it subintend that the other (data constructor) can appear on the right hand side?
13:39:14 <lightstep> and it's not even true
13:40:11 <xerox> lightstep, okay.
13:40:39 <lightstep> it wasn't in relation with what you said, my client just delayed it
13:40:54 <xerox> ah :-)
13:42:12 <lightstep> in an expression you can have any function, including data constructors. but in pattern matching, you can only use data constructors
13:42:25 <xerox> Btw I think I got it, the possibility to have data and type constructor as sinonyms makes it somewhat clear.
13:43:05 <xerox> lightstep, yes, okay, it wasn't referring (in the text) to type constructors, I misunderstood.
13:44:35 <SyntaxNinja> what do you guys think about allowing executables with the same name as the library in cabal description files?
13:44:46 <Heffalump> I think you should.
13:44:49 <Heffalump> unless it's a real pain
13:45:56 <SyntaxNinja> I'm trying to decide what to do about hooks. there was an diea that they should return [(String, BuildInfo)] where the string maps either to a library or an executable
13:46:20 <SyntaxNinja> btw, did you have any outstanding cabal problems?
13:46:55 <Heffalump> not that I can think of.
13:47:07 <Heffalump> how about Library String | Executable String ?
13:47:35 <SyntaxNinja> yeah, I was thinking about that
13:48:31 <SyntaxNinja> could possibly use the Library and Executable types that already exist, which both include BuildInfo, plus some other stuff
13:50:15 <lightstep> are there monad comprehensions in haskell?
13:50:54 <shapr> not anymore
13:50:55 <Heffalump> you can't use monads in list comprehension syntax
13:51:11 <Heffalump> but do notation is kind of comprehensions
13:51:47 <lightstep> yeah, but it's a pain if i want to have one-line do with guards
13:52:00 <Heffalump> you can use when for guards
13:52:34 * Heffalump goes to find the code he wrote that did it
13:52:56 * shapr bounces cheerfully
13:53:00 <lightstep> [x | x <- m, p x] is easier than do {x <- m; guard (p x); return x}
13:53:11 <Heffalump> yes, true.
13:53:56 <Heffalump> I think they wanted to make the type errors better.
13:54:05 <shapr> That's what I've heard too.
13:54:14 <xerox> There were no errors.
13:54:28 <xerox> GHCi eats my code, ihih!
13:58:02 <shapr> I heard that monad comprehensions caused a lot of complaints on the mailing lists, because no one understood error messages.
14:19:31 <xerox> When you do press C-c C-l from an Haskell buffer, the *ghci* or *hugs* buffer is completely scrolled down or it shows only the last lines at the top?
14:22:58 <Oejet> xerox: Try scrolling up.  It just scrolls down.
14:23:25 <xerox> Oejet, I know, I was asking if it's common or due to some my misconfiguration :-)
14:25:08 <Oejet> It may be both. ;-)
14:25:43 <xerox> Hmpf :-)
14:31:08 <Oejet> xerox: Do you use Haskell-mode 1.45 or 2.0?
14:31:48 <xerox> Oejet, let me check
14:32:06 * Heffalump grumbles at not being able to make a heterogenous list and then apply an overloaded function to it
14:32:30 <xerox> 1.45 !!
14:34:06 * xerox *wants* 2.0 ...
14:34:14 <SyntaxNinja> Heffalump: you can do that with extensions, right?
14:34:23 <SyntaxNinja> xerox: not using Debian, I take it?
14:34:34 <xerox> Yep, not using Debian
14:34:47 <Heffalump> SyntaxNinja: yeah, and some hassle with a datatype.
14:34:55 <Heffalump> and wrapping and unwrapping it.
14:35:14 <SyntaxNinja> so for some unknown reason, no one has updated the haskell-mode web site to include the 2.0 version
14:35:32 <SyntaxNinja> I emailed both the old and new maintainers, offering to do that, and neither bothered to mail me back, if I recall.
14:36:07 <xerox> A CVS would be good enough
14:36:26 <SyntaxNinja> or maybe I didn't do that yet
14:36:31 <SyntaxNinja> xerox: there's a tarball out there somewhere
14:37:09 <SyntaxNinja> but of course, if you google for haskell-mode 2.0 you see info about my debian package :)
14:37:17 <xerox> Yep :-\
14:37:32 <SyntaxNinja> http://www-perso.iro.umontreal.ca/~monnier/elisp/
14:37:51 <xerox> ta-da!
14:38:44 <xerox> I hope indentation improved in some way
14:39:41 <SyntaxNinja> it did
14:40:11 <SyntaxNinja> damn, haskell-mode/index.html is modd'd 644 :(
14:41:00 <xerox> Thanks much, time to sleep, skateboard is fun but hard.. :-)
14:41:04 <xerox> 'night folks
14:42:49 <SyntaxNinja> 'night
14:43:23 <Cale> How is Emacs at drawing things? I've seen it inline TeX, so could one do things like add little lines that descend below code to show blocks as defined by the offside rule? (Which might work well together with folding)
14:46:41 <syntax_syntax> just get TeXMacs :)
14:50:33 <Cale> syntax_syntax: For editing Haskell code?
14:50:40 <CosmicRay> am I correct that a Haskell string is UTF-16 internally?
14:51:43 <Cale> hmm
14:51:45 <Cale> Prelude> fromEnum (maxBound::Char)
14:51:45 <Cale> 1114111
14:52:05 <Oejet> Wow, nice number.
14:54:46 <Heffalump> what's that in hex?
14:55:45 <syntax_syntax> I use vim.
14:57:48 <Cale> 10ffff
14:58:08 <syntax_syntax> My dad wants to be a web designer.
14:58:20 <syntax_syntax> So he asks me how he picks a color from a picture to  use in his BGCOLOR or whatever.
14:59:06 <syntax_syntax> I go around teaching him about picking a color in Corel Photo Paint, writing down the R, G and B channels, then converting them on the windows calculator -- something he already has.
14:59:21 <syntax_syntax> And he can't grok that. I mean, what is wrong about these people?
14:59:57 <Heffalump> cale: right, so that's the last defined Unicode code point, AIUI.
15:15:43 <shapr> d00d
15:17:03 <shapr> syntax_syntax: just takes time to learn.
15:17:25 <shapr> syntax_syntax: My mother taught me much of what I know about databases, so sometimes it goes the other way too.
15:19:04 <syntax_syntax> I mean, there is no 'concept' involved. It's just some clicking.
15:19:32 <shapr> Well, there are concepts involved. Alternate number bases, how web pages use it, etc
15:19:46 <shapr> hiya cm
15:20:12 <shapr> syntax_syntax: Everybody knows something I don't know, everybody can do something better than me, that I would like to do better.
15:20:33 <cm> hi shapr
15:20:42 <Cale> syntax_syntax: btw, it's easier to use one of the millions of little colour picker tools http://inetis.com/freeware.asp has one (googled)
15:21:01 <cm> windows has a color picker common dialog ;)
15:21:26 <Cale> cm: for picking colours based on pixels on the screen?
15:22:04 <cm> for a subset of the screen, yes :)
15:22:16 <Cale> heh
15:22:20 <cm> (namely the subset displaying a color gradient + color table :)
15:22:24 <Cale> :)
15:22:36 <syntax_syntax> shapr maybe. This is supposed to be pretty simple, though.
15:23:02 <shapr> Simple is different for different people.
15:23:22 <cm> i think you can use WM_NCMOUSEDOWN (or WM_NCLBUTTONDOWN or something) + GetDC(0)
15:23:36 <shapr> I can't remember appointments to save my life, but I can reinvent the wheel and improve it :-)
15:23:42 <cm> ..although it's gonna change the focus
15:23:56 <syntax_syntax> the color gradient + color table dialog = an HSV picker.
15:24:00 * CosmicRay spies the sickly sight of the windows api
15:24:31 <syntax_syntax> yes, I guess I'm just frustrated with all the free support.
15:24:43 <shapr> Yeah, that I understand.
15:24:44 <syntax_syntax> then again, I take a lot of free support from other people :-D
15:24:49 <shapr> heh, true.
15:24:53 <syntax_syntax> But I am, like, willing to learn.
15:24:56 <shapr> All of humanity is a big support net.
15:25:04 <shapr> Maybe you're willing to teach yourself?
15:25:08 <shapr> Very few people can do that.
15:25:27 <syntax_syntax> I can teach myself some things better than others.
15:25:36 <syntax_syntax> I taught myself PHP, but Haskell is being a rough one on me :)
15:25:36 <shapr> I've tried to teach people autodidactism, but I've realized they have to learn it for themselves.
15:26:05 <Cale> shapr: heh
15:26:11 * shapr grins
15:26:41 <syntax_syntax> damn. I am almost joining the freeminimacs.com Ponzi scheme.
15:27:04 <syntax_syntax> don't you get really annoyed with how people call the mac mini a minimac?
15:27:34 <Igloo> Ooo, does that annoy mac obsessees? *makes a note*  :-)
15:27:35 <shapr> I just want cheap powerful hardware with well documented open specifications.
15:27:53 <shapr> Even better, I'd like to be able to design and produce my own hardware.
15:28:07 <syntax_syntax> cheap powerful hardware with well documented open specifications = cd player.
15:28:16 <cm> hah
15:28:39 <shapr> cd players are powerful?
15:28:58 <syntax_syntax> it plays 80-odd minutes of music on a very small pastic disc.
15:29:05 <syntax_syntax> It was quite amazing when it came out
15:29:12 <shapr> Hasn't that been awhile?
15:29:18 <tuomov> it came out in the 70's
15:30:30 <syntax_syntax> hey tuomov.
15:30:44 <syntax_syntax> are you the ion3 tuomov?
15:30:49 <tuomov> yes
15:30:55 <syntax_syntax> nice :-D
15:31:43 <jadrian> cds came out in the 70s???
15:32:18 <jadrian> "The compact disc was developed in 1979"
15:32:19 <jadrian> damn
15:32:28 <jadrian> I was born in 79...
15:32:30 <shapr> Of the new standards that want to be the next CD, Blu-Ray looks like it's winning because it has built-in copy protection.
15:32:36 <shapr> I was born in 71
15:32:39 <syntax_syntax> probably from 20 to 28 december of 1979, just enough to qualify :)
15:32:55 <jadrian> and I didn't hear of CDs until I was about 13 years old
15:33:02 <tuomov> I was born in 79 too..
15:33:03 <shapr> I wish consumers would stop paying to have themselves screwed over.
15:33:04 <maihem> The winner is whatever gets adopted by the porn industry. Same as Betamax vs VHS
15:33:10 <shapr> maihem: could be
15:33:11 <syntax_syntax> CDs were popular in the classical music community in the 80's.
15:33:19 <shapr> yes, DDD was the best.
15:33:20 <syntax_syntax> They picked it up way before the mainstream music market.
15:33:29 <jadrian> right
15:33:50 <shapr> My parents were classical music buffs, the difference between DDD and anything else is really noticeable.
15:33:55 <syntax_syntax> I  never understood what the DDD/ADD labels were.
15:34:05 <shapr> it meant recorded, mastered, media
15:34:18 <shapr> obviously the last D was there because you had a CD in your hand.
15:34:18 <syntax_syntax> so most modern music s DDD anyway.
15:34:23 <syntax_syntax> Stuff recorded in Pro Tools, etc.
15:34:32 <jadrian> technology that last 25 years...
15:34:39 <jadrian> not bad...
15:34:50 <shapr> digital audio recording was rare and expensive in the 80s
15:34:59 <shapr> same for digital mastering
15:35:03 <syntax_syntax> shapr I see. 
15:35:26 <Igloo> Digital violins must be rare too. Not sure I've ever seen one
15:35:43 <shapr> speaking of which, soundcards need help.
15:36:10 <shapr> Most of the soundcards I've used, you can always hear the CPU as a quiet background buzz. You can tell how busy your CPU is, if you listen carefully.
15:36:10 <syntax_syntax> there are violins like electric guitars. You could link one of those to a MIDI guitar synth.
15:36:22 <shapr> I want digital headphones!
15:36:24 <jadrian> Igloo: hmm theres a pretty famous girls that plays one, who's name I cannot recall...
15:36:32 <Igloo> Hmm, with digital instruments and suitable brain implants can we get digital end-to-end?
15:36:40 <syntax_syntax> shapr My cheap onboardie has that. But it disappears if I mute the CD track.
15:36:57 <shapr> oh, then it's the cdrom to soundcard wire
15:37:00 <shapr> hm, I gotta try that.
15:37:00 <syntax_syntax> Believe it or not. With the cd track unmuted, I can hear my mouse movements IN the sound. If I mute the cd track, perfect.
15:37:18 <shapr> that wire is acting as an antenna
15:37:19 <jadrian> ah Vanessa-Mae
15:37:21 * shapr tries
15:37:21 <jadrian> brb
15:37:49 * shapr starts a kernel compile
15:39:03 <shapr> syntax_syntax: awesome!
15:39:12 <cm> :)
15:39:31 <shapr> that's the fix!
15:39:43 <syntax_syntax> it's all in a day's work in tinkerland (H)
15:40:11 <shapr> Gee, that was a simple way to improve my sound quality.
15:40:37 <syntax_syntax> I wonder if the macmini has a sound input.
15:41:19 <syntax_syntax> hmm
15:41:21 <syntax_syntax> it doesn't.
15:41:26 <syntax_syntax> how ironic. Why ship GarageBand at all?
15:41:58 <shapr> Oh btw, I found a wonderful music player in debian. It's in the mpd and mpc packages.
15:42:19 <shapr> Once I realized how great it was, it took me about thirty seconds to write an emacs binding.
15:42:53 <syntax_syntax> hmm. why would one need something other than sox?
15:43:18 <syntax_syntax> when I used Linux, I had a few scripts that looked for strings before or after the "-" in a filename and played them.
15:43:34 <shapr> mp{c,d} does all that and more.
15:43:41 <syntax_syntax> So I typed "listen_to by" and listened to all my Coil and Recoil music.
15:43:47 <shapr> yup, does taht.
15:43:58 <syntax_syntax> I had a permanently open "run" field in the KDE toolbar. Oh, those times were fun.
15:44:08 <syntax_syntax> er, "listen_by coil"
15:44:12 <shapr> it's also the only flac player I've seen that uses less than 1% of my CPUs
15:44:27 <syntax_syntax> heh. Man, I miss using Linux.
15:44:45 <shapr> mpd is designed for a living room music player, as weenie as a P75
15:44:54 <shapr> mpc is the client, and works via tcp/ip
15:45:34 <shapr> I'll have a spare 600mhz box in a week or so, I think I'll build a living room media box.
15:46:25 <syntax_syntax> shapr is it good enough for you to operate drunk?
15:46:32 <shapr> excuse me?
15:46:34 <syntax_syntax> I was a DJ in an apartment party in new years' eve.
15:46:38 <shapr> oh
15:46:48 <syntax_syntax> After my fifth smirnoff ice, I couldn't use WMP anymore. I wish I had known itunes back then.
15:47:08 <shapr> I rarely drink. I think it's happiness embezzlement.
15:47:10 <syntax_syntax> if you're going to use a computer as a media machine, you have to make sure you can operate it drunk.
15:47:21 <syntax_syntax> I drink twice a year.
15:47:32 <shapr> About the same for me.
15:47:40 <syntax_syntax> I don't even enjoy it that much. The headache and all suck. But I have to live at least some of my youth. 
15:47:47 <shapr> I got the pictures for this last new year's party....
15:48:00 <syntax_syntax> It's kinda fun while I'm drunk, but I don't feel the need to be drunk more often.
15:53:12 <CosmicRay> is there a way to register a function that gets called when a haskell program terminates?
15:53:18 <CosmicRay> like atexit() in c?
15:53:46 <shapr> syntax_syntax: Do I look like someone who should drink? ;-) http://www.scannedinavian.org/~shae/newyear.png
15:53:50 <Heffalump> you could register an atexit handler?
15:54:28 <CosmicRay> there's atexit() in haskell?
15:54:33 <CosmicRay> @find atexit
15:54:33 <lambdabot> Sorry, I don't know the command "find", try "lambdabot: @listcommands"
15:54:39 <CosmicRay> @index atexit
15:54:39 <lambdabot> bzzt
15:54:49 <shapr> @index atExit
15:54:49 <lambdabot> bzzt
15:55:01 <shapr> it exists, Simon Marlow added it, I think.
15:55:11 <shapr> I know darcs uses it. See AtExit.lhs
15:55:20 <CosmicRay> ok, I'll look
15:55:21 <CosmicRay> thanks
15:55:36 <Heffalump> cosmicray: I actually meant that you could hook the C atexit handler.
15:55:58 <CosmicRay> no AtExit.lhs in darcs 1.0.1
15:56:01 <Heffalump> though I guess by the point your atexit actually ran the Haskell RTS might have shut down, which would be bad..
15:56:02 * shapr blinks
15:56:26 <shapr> oh, 1.0.2rc*
15:56:30 <CosmicRay> Heffalump: actually that may be acceptable here, though less than ideal
15:58:27 <Heffalump> is there a standard datatype to represent partial orders?
15:58:34 <Heffalump> (LessThan, GreaterThan, Equal, Incomparable)
15:59:01 <Igloo> Maybe Ordering?
15:59:13 <shapr> Ordering doesn't have Incomparable
15:59:20 <Igloo> Maybe ORdering does
15:59:26 <Heffalump> igloo: cunning.
15:59:28 <Heffalump> ta
15:59:45 <shapr> @info Ordering
15:59:46 <lambdabot> -- Ordering is a type constructor
15:59:46 <lambdabot> data Ordering = LT | EQ | GT
16:00:04 <shapr> oh, duh
16:00:11 * shapr smacks himself
16:15:52 <shapr> Heffalump: working on cool code?
16:16:00 <Heffalump> yes
16:16:37 <shapr> ok then
16:22:14 * desrt wonders if Ordering has Ord
16:22:28 <desrt> heh.
16:22:33 <desrt> that's cute
16:22:42 <desrt> LT < GT :)
16:27:08 <jadrian> is Ord supposed to be a total or partial order?
16:27:40 <desrt> total
16:28:14 <desrt> (compare a b) is always Eq Lt or Gt
16:28:43 <CosmicRay> stupid question time.
16:28:44 <CosmicRay> I have this:
16:28:49 <CosmicRay> class PyObjectConv a where
16:28:49 <CosmicRay>     toPyObject :: a -> IO PyObject
16:28:54 <jadrian> desrt: ah of course
16:28:57 <CosmicRay> This works:
16:29:01 <CosmicRay> instance PyObjectConv CInt where
16:29:02 <CosmicRay> but
16:29:06 <CosmicRay> instance PyObjectConv String where
16:29:07 <CosmicRay> gives:
16:29:13 <CosmicRay> ./Python/Instances.hs:38:
16:29:13 <CosmicRay>     Illegal instance declaration for `PyObjectConv String'
16:29:13 <CosmicRay>         (The instance type must be of form (T a b c)
16:29:13 <CosmicRay>          where T is not a synonym, and a,b,c are distinct type variables)
16:29:14 <CosmicRay>     In the instance declaration for `PyObjectConv String'
16:29:17 <CosmicRay> wtf is going on?
16:29:36 <tuomov> the usual String=[Char] problem?
16:29:41 <CosmicRay> also CString does not work, but CFloat does.
16:29:55 <CosmicRay> tuomov: hmm, a list can't be a member of a class?
16:30:19 <CosmicRay> a CString is a Ptr CChar...
16:30:19 <jadrian> list can
16:30:25 <jadrian> but you have [Char]
16:30:27 <tuomov> just not particular lists
16:30:34 <CosmicRay> hrm.
16:30:38 <jadrian> you need a *->* type constructor
16:30:41 <jadrian> [] will work
16:30:49 <jadrian> [Something] won't
16:31:12 <jadrian> nevermind
16:31:13 <jadrian> argh
16:31:22 <jadrian> just use fglasgow-exts
16:31:44 <jadrian> to allow type synonyms in instance declarations
16:31:49 <jadrian> or use [Char]
16:32:21 <CosmicRay> that got it.
16:32:25 <CosmicRay> (glasgow-exts)
16:32:28 <jadrian> yeap
16:32:31 <CosmicRay> thanks
16:32:40 <jadrian> yw ;)
17:07:41 <jadrian> hmm is there no "isSorted" function?
17:30:49 <cm> does yi work with ghc/Win32?
17:31:33 <cm> dons, *
17:33:50 <Lemmih> No.
17:34:04 <Lemmih> I don't think hs-plugins has been ported to win32 yet.
17:34:15 <cm> :(
17:34:17 <Lemmih> Good morning, #haskell!
17:34:23 <cm> hey Lemmih 
17:34:55 <Lemmih> jadrian: xs == sort xs ?
17:52:55 <jadrian> Lemmih: yes that would work and it's readable, but I think I rather just implement my own :)
17:57:31 <Cale> isSorted xs = and $ zipWith (<=) xs (tail xs)
17:57:42 <jadrian> yeap
17:57:51 <jadrian> that's how I implemented it too
17:58:04 <jadrian> I was just wondering if I was missing it...
18:00:06 * Lemmih mumbles something about premature optimizations. (:
18:01:58 <Cale> It would be interesting if somehow the compiler did manage to optimise "xs == sort xs" into linear time.
18:04:06 <jadrian> it should, no?
18:04:20 <jadrian> I mean
18:04:26 <jadrian> it should already be linear
18:04:36 <jadrian> it will fail in the 1st different elem
18:04:48 <Cale> hmm...
18:05:11 <jadrian> so it fails in the 1st that is not in the proper position
18:05:30 <jadrian> I don't think it is using linear insertion
18:05:30 <Cale> but in order to determine the first element of sort xs it will have to finish sorting at least to some extent
18:05:40 <jadrian> but I wouldn't exepct it to be worst with sorted lists...
18:05:46 <jadrian> Cale: depends
18:05:54 <Cale> yeah
18:05:55 <jadrian> Cale: hmm wait
18:06:37 <araujo> Hello.
18:06:40 <jadrian> well...
18:07:06 <jadrian> if it was using insertion sort, it would be linear no?
18:07:32 <cm> The Merchant of Venice, The Phantom of the Opera, Attack on Precinct 13 or Alone in the Dark?
18:07:32 <jadrian> no never mind
18:07:38 <jadrian> you're right
18:07:49 <Excedrin> The Phantom of the Opera
18:08:05 <jadrian> and insertion sort was also a terrible example...
18:08:16 <Gahhh> ... or see a fine Van Damma movie.
18:08:43 <cm> hm there's also Ocean 12
18:08:45 <cm> 's
18:10:27 * jadrian wishes there was a nice notation for curry and uncurry...
18:10:40 <jadrian> it would make point free style so more pleasing
18:10:41 <araujo> Ocean 12 is nice.
18:10:51 <jadrian> typing "uncurry" is just ugly
18:11:00 <Cale> currying and uncurrying could almost be inferred
18:11:58 <cm> how is White Noise?
18:11:58 <jadrian> I wouldn't like that though
18:12:38 <Excedrin> have you seen the previews for White Noise?
18:12:48 <cm> no
18:12:53 <Cale> yeah, that's a little extreme perhaps, because certainly some bugs would be permitted
18:13:09 <jadrian> yeap, and they would be harder to catch
18:13:20 <Excedrin> it got 5.2 out of 10 on imdb
18:13:49 <Cale> but Jacques Carette (on the mailing list) is right that it is sometimes nice to have natural transformations found and applied automatically
18:13:58 <cm> Now if you'll excuse me, I'm gonna take a closer listen to this static coming from the radio. Let's see. Sounds like Uncle Jack! I can just make it out... "Johnny. Reviews. Not funny. Quit. Now." Um, yeah, just as I thought - nothing but a little cross modulation!
18:14:06 <cm> haha, maybe it's a bad idea ;)
18:14:18 <Cale> i.e. to have (f,g) automatically lifted to the obvious map on pairs
18:15:12 <jadrian> but also how would  f :: ClassX a => a -> a  would work with 3 and (3,3) if both are members of ClassX
18:15:49 <jadrian> opss 
18:15:50 <Cale> well, you have an output type that needs to be satisfied
18:15:51 <jadrian> I meant
18:15:58 <jadrian> f :: ClassX a => a -> a -> a
18:16:09 <jadrian> Cale: not necessarily
18:16:16 <jadrian> Cale: you can have a module with
18:16:25 <jadrian> g = f (3,3)
18:16:39 <jadrian> and you can compile that module separately
18:17:10 <Cale> Separate compilation seems to be the cause of a lot of problems :)
18:17:29 <cm> so? :)
18:17:33 <Cale> heh
18:18:03 <cm> well, can't you generically type it?
18:18:06 <jadrian> well
18:18:17 <jadrian> it doesn't make sense to need a main to compile it
18:18:23 <Cale> What if application was made a typeclass?
18:18:34 <jadrian> how would binary libs be distributed ;)
18:18:53 <cm> Cale, see the haskell mailing list for an example of that, IIRC
18:18:56 <Cale> yeah
18:20:14 <Cale> hmm... I should look into how modules and classes presently interact
18:20:27 <jadrian> you can make application a typeclass, no?
18:20:38 <jadrian> you just need to use a symbol...
18:20:43 <jadrian> not just whitespace :-|
18:20:56 <cm> yup
18:21:54 <jadrian> But I've seen people complaining about "$"
18:22:12 <jadrian> they would probably hate that idea :)
18:22:20 <Cale> jadrian: complaining about $ ?
18:22:23 <jadrian> yeap
18:22:26 <jadrian> ($)
18:22:27 <Cale> $ is nice :)
18:23:42 <jadrian> I know it cannot be used in every situation
18:23:55 <Cale> well it is just a function
18:23:56 <jadrian> IIRC the example was with state monads...
18:24:11 <jadrian> yes and function application is not a function
18:25:01 <Cale> It's the funcification of application :)
18:25:08 <jadrian> :)
18:25:20 <Cale> That sounds like a good album title
18:28:31 <jadrian> it was in that tread that I first realized that ($) was a special case of id
18:28:42 <jadrian> @eval zipWith id [(+1)] [2] 
18:28:42 <lambdabot> (line 1, column 14):
18:28:42 <lambdabot> unexpected "+"
18:28:42 <lambdabot> expecting simple term
18:28:57 <jadrian> huh?
18:29:02 <jadrian> @eval 1+2
18:29:03 <lambdabot> 3
18:29:08 <jadrian> ok
18:29:16 <jadrian> @eval zipWith ($) [(+1)] [2] 
18:29:17 <lambdabot> (line 1, column 10):
18:29:17 <lambdabot> unexpected "$"
18:29:17 <lambdabot> expecting simple term
18:29:17 <Cale> it's not a Haskell interpreter
18:29:22 <jadrian> oh
18:29:41 <jadrian> so what can it evaluate?
18:29:51 <jadrian> @eval map (+1) [1]
18:29:52 <lambdabot> (line 1, column 6):
18:29:52 <lambdabot> unexpected "+"
18:29:52 <lambdabot> expecting simple term
18:30:05 <Cale> a simple functional language that's not quite Haskell
18:30:10 <jadrian> right...
18:30:17 <cm> @eval 1+2
18:30:17 <lambdabot> 3
18:30:18 <cm> !
18:30:31 <jadrian> @eval map (\x->x+1) [1]
18:30:32 <lambdabot> [2]
18:30:34 <jadrian> :)
18:30:44 <jadrian> @eval zipWith (id) [(\x->x+1)] [2] 
18:30:44 <lambdabot> [3]
18:31:10 <Cale> @eval [n | n <- [1,2,3]]
18:31:10 <lambdabot> (line 1, column 4):
18:31:10 <lambdabot> unexpected "|"
18:31:10 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string
18:31:10 <lambdabot>  "(", operator, simple term, "," or "]"
18:31:18 <Cale> no list comprehension
18:31:22 <cm> @eval comprehend my lists
18:31:23 <lambdabot> unbound variable: comprehend
18:31:44 <shapr> @listcommands eval
18:31:44 <lambdabot> Module eval provides the following commands: ["eval","define","get-definition
18:31:44 <lambdabot> ,"definitions","del-definition","dump","set-fuel","resume"]
18:31:52 <shapr> @definitions F
18:31:52 <lambdabot> ["False","Forall"]
18:31:59 <shapr> @get-definition Forall
18:31:59 <lambdabot> Forall = \vs t v a q.q vs t
18:41:23 <Lemmih> Hey shapr (:
18:42:25 <shapr> hiya Lemmih 
18:43:56 * Lemmih is hacking a really flashy webpage for hclanlib.
18:44:40 <Cale> hclanlib? :)
18:45:14 <Cale> ah, a HaCanon app?
18:45:16 <shapr> What does message queueing mean?
18:45:38 <shapr> Something more than the literal description?
18:45:45 <Lemmih> Cale: Yep. A Clanlib binding created with Hacanon.
18:50:04 <Cale> nice :)
19:27:26 <jadrian> are there any possible single operator symbols that aren't defined?
19:28:23 <heatsink> ?
19:29:13 <jadrian> > < * +  !
19:29:16 <jadrian> and so on...
19:29:24 <heatsink> Is ? defined?
19:29:54 <jadrian> kind of
19:29:58 <jadrian> implicit parameters
19:30:03 <jadrian> ghc extension
19:30:23 <Lemmih> #?
19:30:44 <jadrian> kind of... not really an operator but it's used for unboxed types...
19:30:52 <jadrian> not sure if it is a good idea...
19:31:00 <jadrian> & <-- is not defined?
19:31:02 <Lemmih> It's a part of the identifier.
19:31:12 <shapr> # is used in WASH, I think.
19:31:31 <jadrian> wash wouldn't be a problem, I won't be using it for sure
19:31:48 <jadrian> #part of the identifer... I thought it worked as a constructor
19:32:02 <jadrian> oh wait
19:32:25 <jadrian> let me get that straight
19:34:01 <jadrian> ok it's I# C# and so on...
20:19:35 <Lemmih> 5:20am. Time to unicycle!
20:20:00 <shapr> w00
20:36:52 <CosmicRay_> yo KrispyKringle 
20:37:16 <KrispyKringle> hey
20:38:10 <KrispyKringle> taking a quick break from work while i absorb some caffein :P
20:44:47 * shapr gives in to sleep
22:24:08 <NYRanger> hey guys do you want to read a very interesting article, kinda like a beginning Haskell tutorial thingamagic?
22:25:25 <araujo> Boring here.
22:25:28 <araujo> send it off
22:25:34 <NYRanger> http://comsci.liu.edu/courses/151/lab/hs/hs1.php
22:25:45 <NYRanger> it doesnt look good in Internet Explorer, but looks perfect in Mozilla Firefox.
22:28:53 <NYRanger> it was done as a lab practice for us.
22:53:54 <NYRanger> araujo: what do you think?
23:11:09 <autrijus> greetings lambdians.
23:50:21 <tintin> NYRanger: how far does it go  ?
23:50:48 <NYRanger> tintin: what do you mean?
23:51:11 <tintin> the tutorial i.e.
23:51:42 <tintin> atm it looks like just two lab sessions ? 
23:51:46 <NYRanger> it basically talks about how Haskell uses Values and Types.  The course itself is about Programming Languages in general, not just Haskell.
23:52:09 <tintin> so not too much of Haskell to be expected ?
23:52:15 <NYRanger> http://comsci.liu.edu/courses/151/
23:53:39 <NYRanger> my school for some reason is really crazy about C.  This teacher is crazy about functional programming (he is the smartest teacher in the school too) so he introduced this course to teach people that there is a world outside of C.
23:54:14 <tintin> nice of him :)
23:54:19 <NYRanger> as you can tell, lab #4 will be: Haskell functions and pattern matching
23:54:25 <NYRanger> t will be: Higher-order functions and laziness in Haskell
23:55:18 <NYRanger> tintin: I hate most professors in my school because of their incompetency. 
