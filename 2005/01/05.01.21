00:00:18 <Gahhh> lol. "irc is just multiplayer notepad".
00:02:32 <sorje> It's true, I often paste random stuff if I might need it later ;-)
00:03:10 <bluegods> ever try to keep an archive email of liek important links n stuff then delete it?
00:04:44 <bluegods> ok would u use haskell over perl for web stuff like an amazon dot com
00:04:51 <bluegods> does it have like way more power?
00:06:34 <Gahhh> I dont think amazon uses perl. But that's a question fishing for way too speculative answers.
00:07:37 <bluegods> perl says amazon is perl on its site
00:07:41 <bluegods> same in perl book
00:07:43 <bluegods> :)
00:08:18 <bluegods> ok good night i gotta rest up to learn for my new selling auto insurance job tomorrow
00:16:45 <Itkovian> afaik, Amazon uses a lot of Java ... no?
00:16:51 <Itkovian> I don;t know about perl ...
00:17:58 <Itkovian> iirc, Alan Vermeulen told at OOPSLA 2004 that they were moving to all-out Java stuff, so maybe there's some perl lingering ...
00:18:12 <Itkovian> anybody here using mod_haskell?
00:19:03 <Gahhh> I was under the impression that they were heavy java users as well
01:36:53 * Matt-W got his copy of Purely Functional Data Structures
01:50:26 <shrimpx> sweet me too
01:55:10 * Itkovian has got it in his bag ...
01:55:50 <Matt-W> tis a very interesting book
01:56:05 <Matt-W> shame I can't spend all day reading it
01:59:37 <Itkovian> heh
03:35:39 <shapr> yow!
03:38:43 <Itkovian> hi shapr
03:40:40 <Itkovian> seems quiet in here ...
03:42:59 <musasabi> morning
03:43:59 <Itkovian> so, any answer yet to my question on the arguments to a ghc -e oneliner?
03:44:25 <Itkovian> the question was: how do I provide ghc -e '<script>' with arguments on the command line?
04:06:24 <shapr> hoi Itkovian 
04:23:46 <ikegami--> happy Friday!
04:56:00 <Lemmih> karingo: Greetings. Learning Haskell?
04:57:01 <karingo> I think you already asked this question.
04:58:11 <Lemmih> Really? What did you answer?
05:00:31 <karingo> I think it was that I am but just very slowly, but I already know enough to read most snippets.
05:03:27 <pesco> Greetings everyone.
05:04:02 <pesco> Hello Lemmih, hello karingo. What are you up to?
05:05:21 <Lemmih> pesco: Trying to make my C++ <-> C marshalling system more expressive.
05:05:34 <pesco> Expressive?
05:05:57 <pesco> marshalling as in FFI?
05:05:59 <Lemmih> I totally hit the wall of my own design /-:
05:06:02 <Lemmih> pesco: Yes.
05:06:08 <pesco> Heh.
05:06:39 <pesco> A much too frequent experience!
05:07:02 <pesco> What are you going to use it for?
05:07:25 <pesco> If anything in particular, that is...
05:08:29 <Lemmih> I've already made a simple ClanLib binding but any C++ library is possible.
05:09:15 <ozone> Lemmih: what wall have you hit?
05:09:27 <ozone> a C++ binding would be great for the haskell community, i think
05:09:31 <karingo> All I am doing is folding the universe. But it's difficult to get ahold of both sides of the universe so you can fold it in half.
05:10:25 <pesco> kargingo: Maybe you should try to start with a local fold.
05:11:42 <Lemmih> ozone: Currently it can't handle functions which return a local class (ie. not a pointer to a class).
05:12:50 <ozone> a stack-allocated class?
05:13:18 <Lemmih> Yes.
05:13:40 <karingo> Yes, a series of local folds is equivalent to a series of global folds, because in the end the universe would be the same size.
05:13:40 <ozone> is there something fundamental in your binding which doesn't permit that?
05:16:09 <Lemmih> Yes. I've represented classes as pointers in Haskell (but that's not the thing I wanna change).
05:16:51 <ozone> what's wrong with a pointer to something on the stack? ;)
05:18:55 <Lemmih> I'm pretty sure that will be very bad.
05:19:28 <ozone> heheh, most likely
05:22:42 <Lemmih> But all classes have a constructor which takes a 'const [class]&' as argument.
05:25:35 <Itkovian> well, it make might for some 'interesting' results, no? :-)
05:39:35 <Lemmih> But the ClanLib binding has renewed my hope in hacanon's success.
06:56:24 <Itkovian> i'm going home. have a fine weekend!
07:21:53 * shapr bounces
07:22:00 <kuribas> what wrong with this: "mylist = aux 1 where aux n = take n [1..] : aux n+1"?
07:22:27 <Cale> aux n+1 is parsed (aux n) + 1
07:22:55 <kuribas> ah, I see.  Thanks!
07:24:08 <Cale> you can also write that as  tail (inits [1..])  if you load the List library
07:30:44 <kuribas> what does inits do?
07:32:46 <arjanb> inits [1,2,3] == [[],[1],[1,2],[1,2,3]]
07:33:20 <kuribas> so it's just like "mylist" but starting from 0
07:42:14 <jadrian> kuribas: you function is doing to much work though, you could have linear complexity if you didn't have to re-take all the elements in each step
07:45:52 <kuribas> jadrian: that's true
07:49:23 <jadrian> hmm are there any common examples of Functors that are not "containers", besides (a->) ?
07:58:52 <kuribas> This should be the right definition: 
07:58:56 <kuribas> myinits [] = [[]]
07:59:00 <kuribas> myinits (x : xs) = [] : map (\l -> x : l) (myinits xs)
07:59:38 <kuribas> though it's not tail recursive
08:00:03 <jadrian>  (\l -> x : l)  ===  (x:)
08:00:47 <kuribas> jadrian: great!  I learn a lot in this channel :)
08:01:01 <Lemmih> (x:) === insert x
08:01:13 <jadrian> ?
08:01:58 <Lemmih> 'insert x' may be easier to read for some.
08:02:10 <jadrian> but it's not the same...
08:02:34 <jadrian> @Data.List.insert
08:02:34 <lambdabot> Sorry, I don't know the command "Data.List.insert", try "lambdabot: @listcommand
08:02:34 <lambdabot> "
08:02:44 <jadrian> @t Data.List.insert
08:02:44 <lambdabot> Sorry, I don't know the command "t", try "lambdabot: @listcommands"
08:02:49 <jadrian> @listcommands
08:02:49 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
08:02:49 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
08:02:49 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
08:02:49 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
08:02:49 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
08:02:50 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
08:02:52 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
08:02:54 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
08:02:56 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
08:03:09 <Lemmih> @type Data.List.insert
08:03:10 <lambdabot> Data.List.insert :: forall a. (Ord a) => a -> [a] -> [a]
08:03:19 <jadrian> taht was it, thanks :)
08:03:20 <Lemmih> Oh, right.
08:03:23 <Lemmih> D'oh.
08:17:04 <kuribas> is there a shortcut for tail(tail x) ?
08:18:12 <kuribas> like nth (lisp) or list-ref (scheme)
08:18:19 <Oejet> kuribas: Define "ttail = tail . tail" yourself?
08:18:57 <Lemmih> drop 2?
08:19:31 <kuribas> Lemmih: that's it
08:19:41 <Oejet> Lemmih: He, what was I thinking about?
08:22:43 <kuribas> I am trying to write a program to generate the following sequens:
08:22:47 <kuribas> 1 3 7 12 18 26 35 45 56 69 83 98 114 ...
08:24:17 <tintin> n1 + n2 = n3 ...
08:24:25 <tintin> oh no 
08:24:39 <Philippa> kuribas: do you have a formula describing the sequence?
08:25:27 <tintin> n(n+1)+n
08:25:30 <xerox> Sequence and first differences include all numbers exactly once. ?
08:25:35 <xerox> ugh
08:25:46 <tintin> no  no thats not it ...
08:26:19 <kuribas> Philippa: add to each number the next integer, but exclude numbers in the sequens
08:26:22 <tintin> n1n2+1
08:26:42 <xerox> a(n) = a(n-1) + c(n-1) for n >= 2, where a(1)=1, a( ) increasing, c( ) = complement of a( )
08:26:43 <xerox> ?
08:26:56 <kuribas> so +2, +4, +5, +6, +8, etc
08:27:00 <xerox> ^__^
08:29:11 <tintin> hmmz test for divisible by 2 and elimintate them ?
08:29:30 <tintin> exactly divisble by 2 ...
08:45:13 <kuribas> here's what I have:
08:45:30 <kuribas> row :: [int]
08:45:37 <kuribas> row = 1 : [ a+b | a <- row, b <- compl]
08:45:44 <kuribas> where compl = 2 : 4 : 5 : 6 : concat [ [a+1..b-1] | a <- drop 2 row, b <- drop 3 row]
08:45:57 <kuribas> it doesn't work :(
08:46:59 <kuribas> ERROR "test.hs":2 - Cannot justify constraints in explicitly typed binding
08:47:03 <Cale-csc> first, you ought to make "int" be "Int" -- type and data constructors are denoted by uppercase.
08:47:35 <Cale-csc> "int" would be a type variable -- basically equivalent to "a"
08:52:32 <kuribas> this is more like it:
08:52:39 <kuribas> row :: [Int]
08:52:43 <kuribas> row = 1 : [ a+b | (a, b) <- zip row compl]
08:52:49 <kuribas>  where compl = 2 : 4 : 5 : 6 : concat [ [a+1..b-1] | a <- drop 2 row, b <- drop 3 row]
08:55:50 <Cale-csc> what are you computing?
08:57:48 <shapr> Cale-csc: what's the CSC for?
08:57:54 <shapr> computer science center?
08:57:57 <Cale-csc> I'm in the computer science club
08:58:05 <Cale-csc> at waterloo
08:58:19 <shapr> oh
08:59:33 <shapr> oh hey - http://www.blachford.info/computer/Cells/Cell0.html
09:00:01 <shapr> I think any discussion of the Cell CPU is on-topic here, since I think Cell will encourage the popularity of Haskell.
09:01:59 <kuribas> Cale-csc: I wanted to generate the following sequens: 1 3 7 12 18 26 35 45 56 69 83 98 114 ...
09:02:19 <kuribas> As an exercise. I am new to haskell
09:03:19 * kuribas thinks the future of computing is fpga's
09:03:21 <edwinb> That Cell thing looks interesting. You might expect functional languages to take good advantage of such a thing...
09:06:02 <Cale-csc> Ah, the sequence and its first differences include all naturals exactly once.
09:08:58 <stratocaster> kuribas: How about "row = row' 0 [1..] where row' n (x:xs) = (n+x) : row' (n+x) (filter (\y -> y /= (n+x)) xs)". Or "import List (delete)" to replace that filter.
09:16:12 <kuribas> stratocaster: nice
09:16:57 <shapr> edwinb: yeah, I've been writing about Haskell + Cell on lambda-the-ultimate.org and the Haskell mailing list.
09:17:25 <edwinb> I look forward to the first Haskell game on Playstation 3 ;)
09:17:59 <shapr> Did you see my ramble about applying Moscow ML region allocation to CPU-local distributed garbage collection?
09:18:20 <edwinb> Was that on the haskell list? I haven't been following the last couple of days...
09:18:26 <shapr> yeah, on the Haskell list.
09:18:32 <shapr> The big thread that Satnam Singh started.
09:18:33 <edwinb> I'll catch up over the weekend!
09:18:41 <shapr> ok
09:18:54 <shapr> I doubt it's terribly important to Epigram, but it might be interesting.
09:19:05 <edwinb> Well, no, but it's always fun to read...
09:19:31 <shapr> I sort of wish I could get paid to think up and write this sort of software. Web development isn't nearly as much fun.
09:19:52 <edwinb> Yeah, it's a shame such jobs are so hard to get.
09:20:48 <edwinb> I've ended up taking a software development job for the next few months, which will be fun, but not as much fun as inventing strange new languages...
09:24:06 <shapr> What sort of job?
09:25:16 <edwinb> Writing gadgets for some local mathematicians, who've come up with a clever way of doing better software testing by statistical methods.
09:25:20 <CosmicRay> greetings, shapr.  I have detected an anomoly in the matrix.
09:25:31 <shapr> y0 Coz
09:25:52 <CosmicRay> shapr: the other day when I connected MegaMonad, it said: "greetings, agent goerzen" :-)
09:25:55 <Philippa> 'lo
09:26:20 <shapr> heh
09:26:27 <shapr> hiya Philippa 
09:26:35 <shapr> edwinb: sounds like QuickCheck
09:26:48 <CosmicRay> in other news, time handling is haskell is most definately not da bomb
09:27:23 <edwinb> Yeah, it's not so much the tests themselves though, but how they relate to each other.
09:27:25 * CosmicRay has a rant a little bit when he encounters something like that :-)
09:27:54 <wli> e.g. chess, where you have to stop doing things before the time runs out and make a move?
09:28:59 * edwinb heads for home
09:34:06 <wli> Hmm, which was that huge thread? I can't find a huge thread.
09:36:22 <shapr> fifteen posts or so? I count that as a big thread on the announcements list.
10:31:33 <jadrian> is there a more friendly name for type constructors of kind *
10:31:45 <jadrian> would primitive types be ok?
10:32:05 <ibid> what's wrong with "types"?
10:32:52 <jadrian> nothing, I just messed up, let me rephrase that...
10:33:35 <jadrian> I want separate between types like  Int  and types like  Con Int 
10:33:52 <jadrian> that is, the first is simply a type constructor of kind *
10:33:59 <jadrian> the 2nd is of kind * too
10:34:11 <ibid> what about type Foo = Con Int?
10:34:21 <ibid> is Foo like Int or Con Int?
10:34:24 <jadrian> but it's the result of a constructor of kind *->* applyed to Int
10:34:39 <jadrian> I know that even Int is a type constructor applyed to an unboxed type
10:34:48 <jadrian> but I want to keep it simple...
10:35:07 <jadrian> the whole idea is just to separate "simple" types like Char and Int
10:35:20 <ibid> what about Foo?
10:35:30 <jadrian> from other types that are built over these by application of type constructors
10:35:34 * Oejet thought that patents were a way of communicating the technical insight of an invention.  That so people could learn and be more inventious.  I'm thinking about the Cell patent.
10:35:43 <jadrian> Foo is like Con Int
10:35:47 <ibid> jadrian: ok
10:36:02 <jadrian> I won't refer to "type" just "data"
10:36:18 <ibid> jadrian: i think the usual term is atomic type
10:36:21 <jadrian> right
10:36:26 <jadrian> ibid: thanks ibid 
10:37:07 <jadrian> I don't know why didn't I think of it. I'm actually using Atomic for Terms and Formulas already...
10:37:19 <jadrian> and now I couldn't come up with the term... 
10:38:12 <shapr> Oejet: yeah, I agree.
10:40:19 <Oejet> It's like a deal between the state and the inventor saying "alright, we'll give you a monopoly and in return you get to document your work so others can build on that nowledge".
10:43:50 <ibid> Oejet: you're preaching to the choir
10:46:01 <Oejet> ibid: He, I was more arguing with myself, hoping someone agreed. Guess it's very off-topic.
10:46:47 <ibid> that too, but at least i have grown tired of the debate (i do agree with you) :)
11:11:20 <musasabi> The rails framework (for ruby) looks very nice for webapps.
11:11:52 <musasabi> and sadly I cannot think how it could be done nicer in haskell.. :-(
11:13:55 <_Codex> musasabi: function composition would do it nicer and easier.
11:15:33 <musasabi> _Codex: reflection is quite hard to do.
11:16:26 <_Codex> well, the haskell solution is not the same as ruby solution.
11:16:58 <_Codex> you cant map the ruby solution directly to haskell.
11:17:42 <_Codex> (and even if you did figure out a way to do reflection in haskell, it wouldnt be better than the ruby solution; probably much worse.)
11:18:06 <musasabi> yes.
11:18:35 <musasabi> but getting things work as easy in haskell seems to involve quite much currently.
11:18:53 <musasabi> although haskelldb + templates are on the way to better things.
11:20:59 <CosmicRay> to whomever posted the url for lambda the ultimate: thanks.
11:21:00 <CosmicRay> great site.
11:21:12 <_Codex> a good haskell solution for the webapps problem would probably involve a monad implementation where you pass through whole web pages ; and then you would have operations for transforming web pages to other web pages :-)
11:21:26 <CosmicRay> _Codex: isn't this what haxml does?
11:21:40 <_Codex> dunno
11:21:51 <CosmicRay> _Codex: well, it is :-)
11:21:54 <musasabi> _Codex: isn't that what Wash does? and that is not pretty.
11:22:06 <CosmicRay> _Codex: Haxml is a framework for filtering xml or html documents, and is very pretty.
11:23:07 <stepcut> musasabi: Technically, yes, but I not in the way that I think Codex means
11:23:24 <stepcut> s/but I not/but not/
11:24:27 <_Codex> I think both of those (wash and haxml) are a little too low level for what I was thinking.
11:31:37 <_Codex> at least the wash documentation is too concerned about html/xml tags etc. While webapp program should be concerned about the web pages :-)
11:44:44 <CosmicRay> I have never been impresssed with wash really
11:44:52 <CosmicRay> from what little I've read of it, though
11:45:03 <CosmicRay> personally, my preference is to avoid ever having to write a webapp.
11:45:05 <CosmicRay> they all suck
11:48:17 <Oejet> CosmicRay: How about a widget language which compiled to a CGI enginge producing html/javascript/css/forms.
11:49:28 <CosmicRay> Oejet: that would be cool, especially if it could also compile a curses and wxhaskell interface :-)
11:49:43 <CosmicRay> that would almsot make writing webapps fun again ;-)
11:49:48 <_Codex> well, best webapps are things like google; it has just 2 or 3 pages which people regularly use.
11:50:09 <Oejet> CosmicRay:  Exactly what I was thinking.
11:50:39 <_Codex> but the key is usually in what it's doing behind the fancy interface.
11:50:39 <CosmicRay> Oejet: when can you have it ready? :-)
11:51:09 <CosmicRay> _Codex: I have no problem with that part.  but putting the interface on it always seems to take more time than the fun part.
11:51:28 <CosmicRay> dealing with cookies or credentials or whatever, plus designs, etc.
11:51:32 <CosmicRay> it all just sucks
11:55:27 <Oejet> There is just a small consideration; when should computation be done in the browser (javascript), and when should it be sent to the server (forms)?
11:58:52 <CosmicRay> javascript annoys me.
11:58:59 <CosmicRay> makes it hard to work with lynx
12:00:30 * _Codex dont like lynx too much. (though, screen + lynx + emacs is probably all you're ever going to need. Oh and nethack :-)
12:00:59 <Oejet> (and ghc/hugs)
12:01:13 <_Codex> oejet: that's part of emacs.
12:01:22 <_Codex> :-)
12:02:43 <CosmicRay> oh, someone ported ghc to elisp? :-)
12:06:49 <monochrom> Horror
12:29:46 <wli> hmm
12:29:52 <wli> I don't see select() in the libs
12:30:17 <wli> epoll() might be nice since I don't need to do real disk access
12:31:03 <wli> epoll_wait() I guess
12:33:10 <CosmicRay> wli: select() in the ghc library, you mean?
12:33:18 <CosmicRay> wli: you don't need it.
12:33:24 <CosmicRay> wli: forkIO uses it internally
12:33:57 <wli> multiplexing IO needs it
12:34:13 <wli> e.g. threads/processes communicating
12:34:19 <CosmicRay> wli: I understand what it's used for
12:34:27 <CosmicRay> what I'm saying is that you don't need a direct interface to it in haskell
12:34:32 <CosmicRay> because that's what forkIO does for you
12:34:49 <CosmicRay> when you use forkIO, you're not creating a new process or OS thread
12:35:01 <CosmicRay> it's jsut using select under the hood with your I/O operations
12:35:04 <wli> I'm using forkOS because I want concurrent IO
12:35:04 <CosmicRay> very very slick, IMHO
12:35:27 <wli> hmm
12:35:36 <Oejet> wli: Can you elaborate on the context?  I don't think, that I have seen select either.
12:36:07 <CosmicRay> wli: in my opinion, that is one of the nicest things about haskell.  normally select is a total pain to work with, keeping track of the state of each fd and all that
12:38:08 <wli> CosmicRay: i.e. the multiplexor does mapM_ (forkIO . serviceInternalThreads) threadStuff
12:38:31 <CosmicRay> looks reasonable
12:38:40 <wli> well, that's random winged whatever
12:38:46 <CosmicRay> hm/
12:38:49 <CosmicRay> random winged?
12:39:02 <wli> random as in having no correlation to what I'm doing
12:39:11 <CosmicRay> why not?
12:39:15 <wli> winged as in made up for the purposes of an example
12:40:12 <wli> CosmicRay: well, there's nothing wrong with using that as an example of how to go about it (presuming, that is, that serviceInternalThreads understands how to punt things around with MVars etc. internally)
12:42:52 <wli> CosmicRay: There is one issue that is not relevant to me that may come up.
12:43:00 <wli> CosmicRay: (well, relevant to what I'm doing)
12:43:36 <wli> CosmicRay: select()/poll() etc. suck with large numbers of fd's
12:44:17 <CosmicRay> especially select
12:44:20 <wli> CosmicRay: a guy I work with is going to fix up linux kernel aio networking so things may get better wrt. disk io etc.
12:44:24 <CosmicRay> but you said specifically that yuo want select
12:44:34 <CosmicRay> nice
12:44:37 <wli> CosmicRay: I mentioned that epoll_wait() would be fine
12:45:32 <CosmicRay> I don't realy know what ghc uses internally
12:45:42 <CosmicRay> presumably it wouldn't be too hard to optimize it for specific platforms like that
12:46:20 <wli> well, once the kernel aio stuff gets good enough the kernel aio stuff can crush the current scheme performancewise
12:46:52 <wli> There are numbers on this.
12:50:04 <wli> the big hangup with the kernel aio stuff is limited repertoire
12:51:43 <wli> atm. kernel aio stuff does disk, epoll does net, and mixing the 2 entails busywait
12:52:15 <wli> this will not be allowed to persist for long
12:56:14 <Oejet> wli: Could you implement a select function?
13:42:38 <Lor> Evening, folks.
13:43:55 <aleator>  /whois MegaMonad
13:44:03 <xerox>  /whoknows.
13:44:26 <aleator> Stupid spacebar :)
14:00:28 <musasabi> evening
14:02:29 * musasabi feels dirty after delving into pthreads - now I remember why STM seemed so nice, pure and lovely.
14:02:54 <Lor> pthreads is icky.
14:03:32 <Lor> whenever I see pthreads being used, I think "here's another program that's full of race conditions and mysterious breakage and is impossible to debug"
14:03:59 <musasabi> I think I managed to get most of the deadlock conditions away.
14:04:00 <Lor> And is most likely bloody expensive, too.
14:04:39 <Lor> Well, it has been claimed that nptl is actually reasonably efficient. haven't checked whether it's true.
14:04:45 <musasabi> but it is not very modular as every module has to know what locks all functions need :-(
14:07:31 <Muad_Dibber> is there a haskell db system like postgresql already?
14:08:31 <musasabi> Muad_Dibber: there is a nice interface to sql databases which hides the SQL away. (haskelldb)
14:08:50 <Muad_Dibber> yeah :P
14:08:59 <musasabi> Muad_Dibber: I have transactional trees with serialization support ;)
14:21:09 <chip> hiding the SQL doesn't seem so friendly to me
14:22:59 <musasabi> chip: hmm?
14:28:44 <chip> SQL is crufty but powerful, and various platforms implement different dialects.  Hiding the SQL means abstracting away things that could be significant in RL deployment
14:32:59 <musasabi> chip: true - then again with most SQL engines you can hide that logic into a view.
14:33:16 <musasabi> chip: and having to write the SQL by hand is quite errorprone.
14:35:01 <chip> musasabi: I find that argument unpersuasive; that something is error-prone does not necessarily imply that it can be avoided
14:35:51 <musasabi> chip: it *can* be avoided for a large number of apps.
14:36:04 <musasabi> chip: and for those apps that you want to use raw sql you can do that.
14:36:56 <_Codex> I wonder whether we should design something nice to replace sql (and databases :)
14:37:01 <chip> Oh, the SQL is not hidden, as it is done for you in many cases?
14:37:21 <Lor> I think databases should be object-oriented.
14:37:31 * chip grins and wanders off
14:37:38 <Lor> In the sense that there are objects with identifiers and attributes and perhaps subtyping.
14:38:00 <_Codex> lor: I heard the mapping between databases and objects is pretty tricky.
14:38:02 <wli> subtyping and attributes != OO
14:38:09 <Lor> Objects are good for modelling stateful... objects. And databases are intended to store mutable state.
14:38:14 <chip> foo != OO for all foo, pretty much
14:38:24 <Lor> Sorry, object-based, how about that?
14:39:01 <wli> Almost certainly better done with logic languages (I werk for Oracle, the bossman believes that Prolog et al would be fantastic procedural languages to use instead of SQL, etc.)
14:39:05 <chip> "object-based" is a weasel term that somebody came up with once because his pet language was not considered "object-oriented".  Null meaning, pretty much.
14:40:09 <chip> OO is a bag of tricks.  No one trick is OO, take out one and it's still a good bag
14:43:59 <chip> if only somebody could make polymorphism work well with type inference
14:44:09 <chip> (and/or rid me of this meddlesome priest)
14:44:19 <Lunar^> chip: union or inter types
14:45:32 <chip> Well, the thing I'm really interested in is polymorphism that works for dynamically loaded classes.  Any compilation system that depends on having all the source available before execution begins is a problem.  (That's the main problem with Eiffel for me, for example.)
14:46:35 <Lor> What is a good name for a thing with identity and state?
14:46:44 <chip> Lor: IRC troll
14:47:53 <Lor> Oh, I thought that trolls were often anonymous and never change their habits. :)
14:48:24 <chip> touché ... and with that, I must hie to hearth and home
14:48:53 <_Codex> lor: "struct".
14:49:04 <_Codex> (from C/C++) :]
14:50:40 <Lor> Hm, are structs always lvalues?
14:51:03 <monochrom> A dog has an identity and a state.
14:52:19 <Spark> and a tail
14:58:04 <_Codex> lor: id + composition is more interesting combination.
14:58:47 <Lor> Identity without state?
14:59:12 <Lor> What kind of composition do you mean?
14:59:47 <_Codex> lor: from category theory.
15:00:00 <_Codex> id = identity function.
15:00:22 <Lor> Uh, all right. I take it this doesn't directly relate to databases any more.
15:03:10 <_Codex> oh, this was about databases?
15:03:36 <Lor> If the topic changed at some point, I didn't notice it.
15:03:53 <_Codex> now, how do i turn composition to database terminology -- something like join?
15:04:30 <Lor> A join _is_ a composition of finite maps.
15:05:16 <_Codex> id would be empty record?
15:06:54 <Lor> No, the empty record would be a function with a void range.
15:27:30 <autrijus> hey.
15:27:39 <autrijus> question: I have
15:27:40 <autrijus> class (Show c, Typeable c, Buf b) => ChunkBuf c b | c -> b where
15:27:49 <autrijus> and
15:27:50 <autrijus> class (Rec r, ChunkBuf c b) => RecChunk r c b | r -> c where
15:27:59 <autrijus> now the "b" is really not used in RecChunk
15:28:05 <autrijus> so I'd like to say
15:28:09 <autrijus> class (Rec r, ChunkBuf c b) => RecChunk r c | r -> c where
15:28:22 <autrijus> however that gives
15:28:25 <autrijus> ./OpenAFP/Types/Chunk.hs:131: Type variable not in scope: `b'
15:28:54 <autrijus> is there a way out of this? for "data" I can use existential quantification
15:29:04 <autrijus> but I can't seem to get the "forall" in class declaration right.
15:37:11 <jadrian> autrijus: class (Rec r, ChunkBuf c b) => RecChunk r c b| r -> c where   <--- ?
15:37:28 <jadrian> autrijus: why don't you want to list the b?
15:38:02 <autrijus> well
15:38:06 <autrijus> the "where" part is
15:38:06 <autrijus>     readChunks :: r -> [c]
15:38:09 <autrijus>     writeChunks :: (MonadIO m) => r -> m [c] -> m r
15:38:15 <autrijus> so you can see that "b" does not appear.
15:38:39 <jadrian> autrijus: well, if you don't list it, how is it supposed to know the ChunkBuf c b it is supposed to use??
15:38:53 <autrijus> because in ChunkBuf there's a fundep
15:38:59 <autrijus> that's how it works on data declarations.
15:39:05 <autrijus> so 'b' is always reachable
15:39:20 <jadrian> right
15:39:26 <_Codex> maybe that should be r -> b?
15:39:40 <_Codex> the fun dep I mean
15:39:43 <jadrian> or maybe both
15:39:48 <autrijus> class (Rec r, ChunkBuf c b) => RecChunk r c | r -> c, r -> b where
15:39:53 <autrijus> ./OpenAFP/Types/Chunk.hs:131: Type variable not in scope: `b'
15:39:55 <autrijus> doesn't quite help.
15:40:11 <_Codex> autrijus: you still need to have b in RecChunk
15:40:23 <autrijus> _Codex: right, but I don't see the reason :)
15:40:30 <jadrian> but he does have a point 
15:40:44 <jadrian> it would be nice if the fun dep took care of it...
15:40:55 <autrijus> so there's no known way to e.g.
15:40:56 <jadrian> autrijus: still
15:41:03 <shrimpx> attapl should have been released before christmas
15:41:12 <jadrian> autrijus: if what you were saying were ok, then you could do stuff like:
15:41:21 <autrijus> class (Rec r, (forall b. ChunkBuf c b)) => ...
15:41:39 <_Codex> fun dep cannot take care of that I think. Reason is that how would you make instances of the class if you dont have all 3 parameters for it?
15:41:58 <autrijus> instance RecChunk SomeRec SomeChunk
15:42:07 <autrijus> like this
15:42:26 <jadrian> autrijus: so you think you should be able to write:
15:42:30 <jadrian> class ChunkBuf c b | c-> b where          
15:42:31 <autrijus> since the class methods does not mention the Buf part, there's no need for an instance 
15:42:32 <jadrian> class ChunkBuf c b=> ChunkBuf2 c where 
15:42:36 <jadrian> ?
15:42:43 <autrijus> yes.
15:42:47 <autrijus> selective subtyping
15:43:06 <_Codex> autrijus: but how does the fundep work? From SomeRec + the instance, the system must infer some type for the b. What type is it? Its not SomeRec, nor it is SomeChunk.
15:43:07 <autrijus> that will be very convenient. as I don't have, yes, 
15:43:11 <jadrian> so you could redefine any multiparameter class with 2 args and a fun dep and a single parameter class...
15:43:14 <autrijus> class (ChunkBuf c b) => Chunk c
15:43:46 <autrijus> _Codex: it is inferred from SomeChunk.
15:44:04 <autrijus> instance ChunkBuf SomeChunk SomeBuf
15:44:13 <autrijus> it must exist before the RecChunk instance
15:44:19 <autrijus> which is already the case anyway.
15:44:36 <autrijus> jadrian: right. that sounds useful.
15:45:38 <_Codex> I wonder if you can also use: class ChunkBuf c Integer => ChunkBuf2 c where? But is that valid? :)
15:46:40 <autrijus> that gives ./OpenAFP/Types/Chunk.hs:131: Type found where type variable expected
15:46:48 <autrijus> oh wait. it's in the context side
15:47:19 <autrijus> hrmph. it actually works.
15:47:29 <autrijus> class (Rec r, ChunkBuf c Buffer0) => RecChunk r c | r -> c where
15:47:53 <autrijus> but then I'd have to create one RecChunkX class for each BufferX
15:48:01 <autrijus> which defeats the purpose
15:48:35 <_Codex> so you want it to magically choose the buffer to use, but you dont want to provide it in the instances? :)
15:48:51 <autrijus> I'd like to indirectly provide the instance via fundep.
15:49:13 <autrijus> because my fundep works something like
15:49:48 <autrijus> Rec -> Chunk -> Buf -> Data -> Rec ... (recursive)
15:50:10 <autrijus> so curently the DataRec class needs to have 5 parameters
15:50:18 <autrijus> whereas 2 would suffice really
15:50:31 <autrijus> because all preceding ones can be derived via fundep in RecChunk, ChunkBuf, BufData
15:52:08 * autrijus wonders if it can be solved by making Buffer into a type with existentially quantified constructors, instead of a class
15:53:30 <autrijus> since that would eliminate the ChunkBuf layer. I just need to pack two functions into the Buffer data type
15:54:38 <autrijus> data Buffer = forall b. b (forall r. (Rec r) => r -> b) (forall d. (Data d) => b -> d)
15:55:09 <autrijus> but it feel really klugy, compared to the elegance of fundep
15:55:43 <_Codex> that looks nasty.
15:55:47 <autrijus> verily.
15:56:07 <autrijus> it essentially simulates class with type constructors
15:56:13 <autrijus> and rolls fundep by hand
15:57:47 <autrijus> data Buffer = forall b. Buffer { buf :: b, recToBuf :: (Rec r) => r -> b, bufToData :: (Data d) => b -> d }
15:57:51 <autrijus> a bit better
15:58:20 * jadrian still has way to many doubts about existencial types...
15:58:36 <autrijus> hmm?
15:58:53 <jadrian> don't worry, just talking about me
15:59:08 <autrijus> ok.
15:59:19 <jadrian> I still haven't used them for real, just played a little with them
15:59:25 <autrijus> the way above with records does look like OOP.
15:59:25 <jadrian> welcome shapr  
15:59:31 <autrijus> hi shapr.
15:59:38 <shapr> hiya jadrian, I heard about this cool language called Haskell!
15:59:43 <jadrian> lol
15:59:48 * shapr grins
16:00:11 <shapr> Can Haskell be used for real world applications?
16:00:17 <_Codex> shapr: you're in the right place. (but need to learn category theory first thing :)
16:00:23 <shapr> aiee
16:00:26 <jadrian> shapr: yes but it is not scalable
16:00:32 <shapr> really?
16:00:36 <shapr> I've never wanted to program scales.
16:00:42 <shapr> So I guess that's okay.
16:01:12 <jadrian> shapr: I think so, that's what someone was saying yestarday... in CAPS
16:01:20 <shapr> seriously?
16:01:26 <jadrian> let me search
16:01:28 <shapr> Man I should read the logs
16:01:59 <jadrian> ah he came from the python channel to :)
16:02:22 <shapr> ah, I see.
16:02:32 <shapr> I came from the Python channel also.
16:02:38 <autrijus> this week I'm trying to find accessible materials on general nonsense.
16:02:55 <shapr> autrijus: oh, reading about Category Theory?
16:03:04 <autrijus> today I'm going back to my parent's place to find my brother, who is a math major, so maybe he can help me.
16:03:12 <jadrian> shapr: just search scalable http://tunes.org/~nef/logs/haskell/05.01.20
16:03:17 <shapr> yeah, I found it.
16:03:41 <autrijus> shapr: yeah. it seems that every time I want to do something serious with the Class system I find myself outsmarted by the compiler.
16:04:08 <shapr> type classes?
16:04:10 <autrijus> and I've heard that the only way to keep sanity in the long term is to learn abstracted general nonsense
16:04:13 <autrijus> yeah.
16:04:25 <shapr> Type classes are more about passed dictionaries.
16:04:42 <shapr> It's good stuff.
16:04:46 <autrijus> shapr: oh. I've just brought up a type class question. maybe you can help.
16:04:52 <shapr> go for it!
16:05:11 <autrijus> class (Show c, Typeable c, Buf b) => ChunkBuf c b | c -> b
16:05:16 <autrijus> and
16:05:17 <autrijus> class (Rec r, ChunkBuf c b) => RecChunk r c b | r -> c where
16:05:17 <autrijus>     readChunks :: r -> [c]
16:05:20 <shapr> oy
16:05:20 <autrijus>     writeChunks :: (MonadIO m) => r -> m [c] -> m r
16:05:31 <autrijus> the 'b' in redundant in RecChunk.
16:05:42 <autrijus> I'd like to write
16:05:43 <autrijus> class (Rec r, ChunkBuf c b) => RecChunk r c | r -> c, r -> b where
16:05:46 <shapr> um, it appears you've mixed in fundeps.
16:05:48 <autrijus> but haskell won't let me.
16:06:06 <autrijus> this is a problem because the fundep carries on 4 levels.
16:06:13 <autrijus> with ChunkBuf being the first.
16:06:29 <autrijus> so as it stands the lowest level has to carry four unneccessary extra parameters.
16:06:45 <shapr> You don't need category theory, you need BC Pierce's 'Types and Programming Languages'
16:07:08 <autrijus> a related idea is to selectively subclass:
16:07:15 <autrijus> class (ChunkBuf c b) => Chunk c where ...
16:07:57 <shapr> I'd have to think about that.
16:08:05 <shapr> I never did thoroughly learn fundeps.
16:08:10 <shapr> I probably should :-)
16:08:18 <autrijus> a way out of this is not using a class for "Buf", but use something liek data Buffer = forall b. Buffer { buf :: b, recToBuf :: (Rec r) => r -> b, bufToData :: (Data d) => b -> d }
16:08:34 <autrijus> that is, embed the fundep in existentially quantified constructor records
16:08:44 <autrijus> but it looks messy. that's the gist of my problem :)
16:09:03 <shapr> fun problem.
16:09:16 <shapr> How are you liking Haskell so far?
16:09:19 <dons> woo. make -jN works on ghc now
16:09:24 <shapr> yay!
16:09:26 <autrijus> shapr: it r0x0rz.
16:09:32 <shapr> excellent :-)
16:09:45 <wli> w00t
16:09:46 <shapr> Do you see any opportunities for improvement?
16:09:54 <autrijus> I'm inching bit by bit with the pet Inline::Haskell project
16:10:28 <autrijus> shapr: mostly on the infrastructure side.
16:10:42 <autrijus> I'm so used to the huge supporting maching that is *.cpan.org.
16:10:45 <shapr> Yeah, I agree with that.
16:10:57 <shapr> Cabal plus darcs should for that in Haskell.
16:11:11 <shapr> I've been thinking about repo as package.
16:11:13 <autrijus> by supporting I mean ticketing, smoke testing, browsing, weekly reports
16:11:24 <shapr> What's smoke testing?
16:11:26 <autrijus> various annotation and aggregators, etc.
16:11:39 <shapr> Hm, I could do that with darcs and Cabal.
16:11:40 * shapr thinks
16:11:42 <autrijus> shapr: oh. it's an old project of mine. hang on
16:11:50 <shapr> Is smoke testing like nightly builds?
16:11:55 <autrijus> # http://www.perl.com/pub/a/2002/04/30/cpants.html
16:12:02 <shapr> Btw, did you get chip here?
16:12:18 <autrijus> hm? no
16:12:29 <shapr> great name... see pants!
16:12:30 <autrijus> shapr: any author uploading a module to cpan receives smoke testing reports on various platforms.
16:12:37 <shapr> that is excellent
16:12:52 <autrijus> right. makes any nonportable bugs obvious
16:13:11 <autrijus> oh, and svk is really faster than darcs :)
16:13:25 <autrijus> although darcs has many nice UI touches which I'm going to steal.
16:13:28 <shapr> heh
16:13:55 <shapr> I think you've already heard about all my neat ideas for darcs. Most of them involve exploring its connection with refactoring.
16:14:10 <autrijus> I've heard something but certainly not all.
16:14:21 <shapr> There's a rumor that a separate community.haskell.org might become available.
16:14:33 <autrijus> cool.
16:14:41 <shapr> If that happens I'm sure it'll offer those CPAN features.
16:14:49 <autrijus> that'd rock.
16:15:13 <autrijus> I've got numerous past and upcoming TPF grants on reworking CPAN
16:15:18 <shapr> TPF?
16:15:22 <autrijus> the perl foundation.
16:15:24 <shapr> ah
16:15:47 <autrijus> and one important direction is to tie the service with version control more closely.
16:15:51 <shapr> I never got into the Perl community, the #perl guys pissed me off long years back and I went to #python instead.
16:15:57 <autrijus> so I suspect we've be thinking similar ideas.
16:16:03 <shapr> Yes, I agree.
16:16:11 <autrijus> the canonical #perl is on irc.perl.org :)
16:16:17 <shapr> Right, I was just on EFNet.
16:16:24 <autrijus> ah. *shudder*
16:16:29 <shapr> But I didn't know any better at the time.
16:16:36 <autrijus> nod.
16:16:55 <shapr> darcs test is a good step in that direction.
16:16:58 <Philippa> shapr: you got/getting the sequel to the brick book?
16:17:08 <shapr> I don't have it yet.
16:17:18 <Philippa> me either, placed the order though
16:17:31 <Philippa> going to be a bit harder to nickname, mind
16:17:48 <shapr> Did you see what I said to BC Pierce about that? :-)
16:18:13 <shapr> He said that everyone just calls it "TaPL" but that the sequel was coming out...
16:18:20 * Philippa nods
16:18:35 <Philippa> "the brick book" is far more usable in speech IMO
16:18:36 <shapr> He seems like a nice guy. I wonder if he'll be at ICFP05
16:18:36 <jadrian> how do you type >>= in LaTeX?
16:18:39 <jadrian> any nice symbols?
16:18:53 <shapr> I could buy him a beer and get my TaPL autographed.
16:18:57 <Philippa> heh
16:18:57 * shapr grins
16:19:12 <autrijus> mmm amazon.com wants me to buy TaPL with  Basic Category Theory for Computer Scientists.
16:19:13 <shapr> You coming to ICFP05?
16:19:15 <jadrian> for >> I got \gg
16:19:21 <autrijus> do I want it?
16:19:26 <shapr> Which authors?
16:19:41 <autrijus> same author
16:19:46 <shapr> the Lawvere(sp?) and Schanuel(sp?) book is nice, but I've heard ..
16:20:02 <shapr> I haven't read that one yet, but I very much want to.
16:20:09 <shapr> I really enjoyed TaPL.
16:20:19 <shapr> Pierce has a lovely writing style.
16:20:43 <shapr> Not as good as SICP, but still very nice.
16:20:55 <Philippa> I'm hoping to convince Damien to work through some of TaPL with me
16:21:05 <shapr> I'd suggest something a bit lighter ;-)
16:21:21 <shapr> I dunno though, different people have different interests.
16:21:28 * autrijus wonders if ghc can be made to generate parrot assembly.
16:21:46 <Philippa> yeah. Though Damien's going to be changing courses to do compsci next year
16:21:48 <shapr> I had a blast going from the austere lambda cal interpreter up to something real.
16:21:54 <shapr> Ah, neat.
16:22:18 <shapr> I'd suggest SICP first.
16:22:23 <Philippa> was going to go pretty slow through TaPL with him, and skip all the proofs
16:22:42 <Philippa> tempting
16:22:50 <shapr> I think it's more about 'programming'
16:22:58 <shapr> type systems aren't everything
16:23:05 * shapr hopes he won't get lynched
16:23:07 <Philippa> only I'd have to learn scheme properly so I could read his code that way :-)
16:23:09 <Philippa> heh, no
16:23:25 <shapr> Actually, SICP teaches Scheme along the way, but you never really notice it happening.
16:23:34 <Philippa> yeah, but if he reads ahead I'll be in trouble
16:23:49 <Philippa> well, prolly not /too/ much, I've read the R5RS
16:23:49 <shapr> You'll just have to keep up ;-)
16:23:57 <shapr> SICP is really fun.
16:24:14 <autrijus> right. I enjoyed it immensely.
16:24:23 <Philippa> I'm still trying to decide what I want to do when he decides he wants to do GUI stuff though
16:24:23 <autrijus> sadly I did not enjoy programming scheme.
16:24:43 <Philippa> I'm tempted to just let him do the Java module on his course, but Swing might put him off for life :-)
16:24:47 <shapr> Philippa: oh hey! did you see my post about moscow ml region allocation used to generate CPU-local code?
16:24:50 <_Codex> I never understood sicp. (the book I have went broken before I learned it :-)
16:25:00 <shapr> _Codex: it's free in html format.
16:25:00 <Philippa> er, maybe
16:25:10 <Philippa> I've not been reading much on the lists the last few days
16:25:56 <shapr> Bjorn Lisper said that future multi-core dies will most likely have core-local memory, and migration and shared locking will be high-cost.
16:26:15 <shapr> That would make distributed garbage collection very difficult.
16:26:54 <shapr> So I had the idea to use region allocation to generate a cpu-local program that's the equivalent of a thunk fill-in or something.
16:27:03 <shapr> I dunno if that's a good idea or not, but it sounds nifty.
16:28:41 <shapr> How's thing with Flippi?
16:28:50 <shapr> I really will get FLM done at some point.
16:29:03 <Philippa> I've not touched Flippi for a while now
16:29:09 <Philippa> been playing around with lang stuff
16:29:10 <Oejet> shapr: Maybe that idea will be more obvious with Cell.
16:29:25 <shapr> Speaking of which...
16:29:28 <shapr> what was that url again?
16:30:11 <shapr> I was going to post about that to both LtU and the parallel haskell thread.
16:31:10 <shapr> ah, it's on slashdot.
16:40:34 <dons> how can you lose respect for unsafeCoerce# :}
16:43:28 * autrijus starts adding books to shopping cart
16:44:46 <autrijus> currently: <<Algorithms: A Functional Programming Approach>>, <<Haskell: The Craft of Functional Programming>>, <<Introduction to Higher-Order Categorical Logic>>, <<Types and Programming Languages>>, <<Basic Category Theory for Computer Scientists>>, <<Purely Functional Data Structures>>
16:44:55 <autrijus> what ones should I add / take away?
16:45:13 <dons> what about the successor to "Types and Programming Languages"?
16:45:39 <autrijus> <<Advanced Topics in Types and Programming Languages>> ?
16:45:44 <desrt> purely functional data structures?
16:45:59 <dons> that's the one
16:46:14 <autrijus> dons: you think it's grokkable? :)
16:46:34 <dons> yeah, sure. if the first one is.
16:46:37 * autrijus throws it in.
16:47:15 <autrijus> desrt: http://www.amazon.com/exec/obidos/tg/detail/-/0521663504
16:47:18 <desrt> are these like trees without explicitly talking about pointers?
16:47:35 <autrijus> desrt: I believe the idea is "non-destructive update"
16:47:50 <desrt> ah.  i see
16:49:20 <shapr> autrijus: I have and enjoyed that first one. I have and read the second one, it was okay. Dunno about the third. Enjoyed the fourth. Dunno the fifth. Want the sixth!
16:49:23 <shapr> Okasaki rocks!
16:49:36 <desrt> so like replacing a node (and subnodes) in a tree without having to copy the entire thing and without having an update operation
16:50:59 <autrijus> yeah.
16:51:03 <autrijus> gah. no used books for me.
16:51:06 <autrijus> bad amazon.
16:51:30 * autrijus mumbles something about the inconvenience of shipping to .tw
16:52:11 <shapr> suck :-(
16:52:26 <autrijus> :/
16:52:44 <shapr> Ya know, I'm surprised no one does a remailing service.
16:52:51 <autrijus> shapr: so is there a better introductory text than Craft 2e?
16:53:15 <shapr> If you're doing fundeps, you don't need Thompson's book.
16:53:36 <shapr> But if you want to introduce others, I'd probably suggest Hudak's book first.
16:53:40 <autrijus> it's probably not for myself :)
16:54:02 <shapr> Hudak has more math, but I think it's a better intro all around.
16:54:03 <autrijus> I usually learn a thing by translating its best introductory book.
16:54:17 <shapr> I tend to learn a think by writing a tutorial for it.
16:54:25 <shapr> "thing"
16:54:37 <autrijus> <- translated llama and organized the camel translation team
16:54:42 <shapr> wow
16:54:55 <shapr> when do you sleep??
16:55:05 <autrijus> so maybe I'll sell haskell to Taipei.pm. we'll see
16:55:15 <autrijus> heh. I sleep 10 hours a day :)
16:55:29 <shapr> Have you tried Ritalin? =)
16:55:34 <autrijus> no. =)
16:55:41 <shapr> it's tasty.
16:55:54 <autrijus> I'm also heavily ADD
16:56:05 <shapr> as if I hadn't noticed...
16:56:21 <autrijus> case in point: I've neglected all perl work for @clients for the past 21 days
16:56:27 <autrijus> thanks to this haskell thing :)
16:56:44 <shapr> I truly hope I can spend a few days with you in person, when I can afford to not take any meds.
16:57:07 <autrijus> hm, why are you taking meds?
16:57:30 <shapr> Because I tend to ignore all python work for clients for days on end and do Haskell instead?
16:57:40 <autrijus> so. and ritalin fixes that?
16:57:45 <shapr> It does.
16:57:46 <autrijus> I may want it.
16:57:51 <shapr> For some definition of fix.
16:57:58 <shapr> It's a two thirds fix.
16:58:06 <autrijus> so it's not like a mfix? ;)
16:58:10 * shapr sniggers
16:58:17 <shapr> Have you seen what I've written about Ritalin?
16:58:22 <autrijus> no. url?
16:58:40 <shapr> http://c2.com/cgi-bin/wiki?RitalinDrug
16:58:59 <shapr> I haven't checked that content recently, my opinions may have changed.
16:59:24 <shapr> But I will say that if you've been diagnosed by a doc as ADD, drugs are worth trying.
16:59:49 <shapr> I've tried Ritalin, ADDeral, Concerta, Dextroamphetamines, and something else I forget.
17:00:28 <autrijus> on the other hand I've reduced (length clients) to 1
17:00:37 <autrijus> so maybe I should finish this one and enter sabbatical
17:00:42 <shapr> They each have their good and bad points, but for my current situation I've chosen Concerta.
17:00:56 <autrijus> so I'd not need any drugs and can hyperfocus for a month or something :)
17:01:03 <shapr> Drugs let you do things you hate to do.
17:01:16 <autrijus> I spent my life ignoring those things. hmm.
17:01:20 <shapr> I know the feeling.
17:01:54 <shapr> I'd suggest a balance, take meds four days out of seven.
17:02:08 <autrijus> maybe that's why I translated http://www.amazon.com/exec/obidos/ASIN/0471295809/  too.
17:02:25 <shapr> Yup
17:02:27 <autrijus> I was going to translate GEB but the publisher declined :-/
17:02:34 <shapr> suck
17:02:47 <shapr> I'm surprised ... did you talk to Hofstadter?
17:02:50 <autrijus> verily. and I can't do that one for free yet :)
17:03:06 <autrijus> shapr: yeah, and he mentioned the excellent .cn translation
17:03:10 <autrijus> so the .tw demand is not that high
17:03:13 <shapr> ah.
17:03:47 <autrijus> but I translated <<Chickadee>> for him, which seem to made him happy.
17:04:32 <shapr> Le Ton Beau De Marot?
17:04:46 <autrijus> that's the one.
17:04:51 <autrijus> not the whole book :)
17:05:11 <shapr> Parlez vous franÃ§ais aussi?
17:05:22 <autrijus> Nein.
17:05:27 <shapr> quelle dommage :-)
17:05:36 <autrijus> "Chickadee" is his late wife's english rendering.
17:06:23 <shapr> I really like Hofstadter.
17:06:47 <autrijus> yup.
17:07:03 <shapr> What do you think of a concatenative spoken programming language?
17:07:13 <autrijus> oh. I'm considering, in a few years maybe, to move to scandavinia
17:07:20 <shapr> Which part?
17:07:52 <shapr> It's a nice place.
17:07:52 <autrijus> .fi probably, but the other three ain't ruled out
17:07:59 <shapr> Lots of niftiness here.
17:08:39 <autrijus> so is .se niftier than .fi?
17:08:58 <shapr> Depends on what you like.
17:09:13 <shapr> Finland has a much higher pressure society than Sweden.
17:09:23 <autrijus> hmm.
17:09:37 <autrijus> as in, more accelerated?
17:09:44 <autrijus> quicker pace and all
17:09:56 <shapr> No, just more ... 
17:10:08 <shapr> More like Japan I think.
17:10:15 <autrijus> aha.
17:10:18 * autrijus got it.
17:10:23 <shapr> There's a pressure to be the very best at whatever you do.
17:10:30 <autrijus> so. I've learned lojban a bit but never really got a hang of it
17:10:36 <shapr> lojban is nifty.
17:10:44 <autrijus> I also think camera works better than a microphone
17:10:58 <shapr> ?
17:11:01 <autrijus> s/microphone/microphone alone/
17:11:07 <autrijus> about spoken programming.
17:11:16 <shapr> oh
17:12:16 <autrijus> because you can use gestures to annotate the linear verbal input.
17:12:23 <shapr> yes, I agree.
17:12:40 <shapr> I thought of a spell casting paradigm long ago.
17:12:46 <shapr> I still think it's the best.
17:12:56 <autrijus> I like the computer in <<Minority report>>.
17:13:04 <autrijus> it's all gesture and verbal.
17:13:08 <shapr> Take something like Alan Kay's latest OpenCroquet, add glove input..
17:13:16 <shapr> I think that was cheesy, it's still two dimensional
17:13:31 <autrijus> you don't know if they are wearing 3d contact lenses.
17:13:32 <autrijus> ;)
17:13:35 <shapr> I'd like something more like a single cell view with internal 'organs'
17:14:09 <shapr> At the time I only knew about OOP, so I visualized each object as a cell, and you could build multicellular critters by packing in other objects and connecting them.
17:15:05 <shapr> I was thinking that you'd flip a cell inside out to work on the internals, then when you close it up again you can connect its inputs and outputs to others.
17:15:13 <shapr> I think it'd be more like writing Self 
17:15:41 <shapr> persistent instances
17:15:45 <autrijus> I heard that Self has a SubEthaEdit-like collaborative editor.
17:15:51 <autrijus> never really saw it in action.
17:16:05 <autrijus> but face to face SEE rocks.
17:16:30 <shapr> It's way cool. Self has a big flat 2D canvas, and you create visual things that can have behaviour.
17:16:39 <autrijus> although SEE is but multiplayer notepad, it's still miles better than the multiplayer /bin/cat that is IRC.
17:16:47 <autrijus> ooh.
17:17:02 <shapr> lemme find the url to the demo pic for Self.
17:17:32 <autrijus> weird, I'm tested as InFp.
17:18:15 <shapr> So did I two weeks ago
17:18:31 <autrijus> so it's a bipolar thing too? :)
17:18:42 <autrijus> my brother is on med because severe bipolar
17:18:46 <shapr> scary.
17:19:08 <shapr> I just watched the first part of A Beautiful Mind...
17:19:20 <shapr> but it got too stressful and I had to take a break to finish it tomorrow.
17:19:30 <autrijus> although in the manic part he can really grok abstract math like it's concrete objects.
17:19:34 <autrijus> *nod*
17:20:12 <autrijus> hmm you're almost 10 years older than me :)
17:20:19 <shapr> yup
17:20:30 <shapr> We talked about that on #darcs some time back.
17:20:40 <autrijus> right.
17:22:44 <autrijus> hmm I managed to crash amazon's mason app.
17:22:49 <shapr> cool!
17:22:50 <autrijus> so much for rapid development.
17:23:13 <shapr> How long can you count the seconds on a watch?
17:23:23 <shapr> (Discounting hyperfocus)
17:23:25 <autrijus> <- doing mason as a day job
17:23:32 <autrijus> heh. was about to mention that
17:23:59 <autrijus> discounting hyperfocus, maybe 20 seconds
17:24:09 <shapr> That's decent as ADD goes.
17:24:15 <autrijus> yeah.
17:24:30 <autrijus> I'm within control provided that I sleep enough and takes no caffeine.
17:24:55 <autrijus> both are however invalidated for the past few week s of learning haskell.
17:25:13 <shapr> I have other requirements as well, regular sleep schedule, regular exercise, regular amounts of the right food, and no alcohol.
17:25:29 <autrijus> sure.
17:25:37 <shapr> I can skip any one of those and do okay, but if I skip two I spiral out of control.
17:25:54 <autrijus> seems I'm skipping all right now.
17:26:23 <shapr> One of the things I wrote in my blog is that I learn faster/better, and I write my best code when I have all of those in balance.
17:26:37 <shapr> So purely for my own selfish interest I try to keep it all in balance.
17:26:47 <shapr> Because I like to learn.
17:27:20 <autrijus> that sadly is not the case for me :)
17:27:26 <shapr> heh
17:27:32 <autrijus> I can only truly learn things during hyperfocus
17:27:40 <autrijus> which is not triggered unless I skip most of those.
17:28:08 <shapr> I hope we can get together in person and learn something new sometime, I learn fastest in that sort of situation.
17:28:16 <autrijus> ditto.
17:29:02 <shapr> well, time to play a game for a bit and then sleep...
17:29:09 <autrijus> 'nite :)
17:29:14 <shapr> :-)
