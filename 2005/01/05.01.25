00:31:39 <vdrab> has anyone ever played around with Clean? 
00:32:05 <vdrab> it looks a lot like haskell, except they tackled the IO / side effects problem differently
00:32:48 <Lemmih> Indeed.
00:33:06 <vdrab> so I was curious about any Clean war stories.... the language looks tight and crisp, it seems they are doing something right.
00:33:39 <Itkovian> I have at one point tried a few toy things ... nothing serious ...
00:33:56 <Itkovian> It's supposed to be quite fast ...
00:34:11 <vdrab> I'm a bit put off by the apparent lack of libraries for the moment, but conceptually it looks pretty cool
00:34:32 <vdrab> always wanted to write function sigs like *World -> *World :-)
00:39:28 <vdrab> for one, the language allows you more flexible control about the strict / lazy parts of a program. Can't give any real decent info as I haven't touched it yet, just reading around a bit, working up an appetite.
00:39:50 <vdrab> anyways, no Cleaners on #haskell?
00:48:43 <Lemmih> ozone: I'm thinking about releasing version 0.1 of Hacanon soon.
02:08:13 * magical1 yawns
02:26:16 <boegel> hey #haskell
03:21:20 <samc_> shapr, http://arstechnica.com/news.ars/post/20050124-4551.html
03:22:09 <samc_> those who read the cell analysis for which shapr provided a link may be interested
03:24:16 <Itkovian> ah back at last
03:24:19 <Itkovian> bloody split
03:36:31 <musasabi> can anyone install the current binary snapshot on linux?
03:50:09 <Itkovian> musasabi: haven't tried yet ... no machine available :-(
03:53:44 <musasabi> I nuked my old ghc @ uni, but cannot get a new one installed and don't currently have ssh to home..
03:54:06 <TFK> Trying to compile GHC on gentoo, I get this error: configure: error: GHC is required unless bootstrapping from .hc files. <--- looks rather strange, since this happens while compiling GHC itself!
03:55:38 <musasabi> creating dummy documentation seems to help.
03:55:42 <Itkovian> TFK ... I am in te process of compiling ghc on gentoo ...
03:55:46 <Itkovian> ... /var/tmp/portage/ghc-6.2.2/work/ghc-6.2.2/ghc/rts ...
03:56:31 <TFK> Got load of files there. What do I do with them?
03:56:33 <Itkovian> high time somebody cleans up the gcc warnings ...
03:56:59 <Itkovian> TFK ... cd to the work dir and try to do some stuff manually ...
03:57:09 <TFK> I wouldn't know how :-/
03:57:12 <musasabi> now I have a corrupted package.conf - that I can fix, but then it complains that the libraries are missing.
03:57:14 <Itkovian> :-)
03:57:28 <TFK> Very clueless in all this compiling business, was hoping emerge would do it for me :-\
03:57:28 <Itkovian> :-(
03:57:29 <musasabi> TFK: Compiling ghc from the ebuild worked fine on gentoo.
03:57:39 <Itkovian> TFK: try the ghc-bin
03:57:50 <TFK> Will do
03:57:55 <Itkovian> it won't be 'optimized' but it should definitely work just fine.
03:58:09 <Itkovian> then try again if you have the time/patience.
03:58:12 <kosmikus> Gentoo should bootstrap from ghc-bin automatically
03:58:46 <TFK> Yeah, but I didn't have that while compiling GHC. And I only have hugs, I noticed it looked for other compilers, too.
03:59:11 <TFK> But if ghc-bin works, it's all good :-)
04:00:08 <Itkovian> kosmikus: yr the haskell guy on the gentoo fora?
04:00:17 <Itkovian> (I assume yr male)
04:00:22 <Itkovian> (shoot me if not)
04:01:13 <kosmikus> I'm rarely present on the Gentoo fora, but yes
04:02:06 <Itkovian> is there something like perl's split(regex, string)?
04:02:43 <Itkovian> if not, I ask again: how does one import stuff on the command line?
04:03:55 <kosmikus> Itkovian: I think you can't
04:04:19 <kosmikus> TFK: the point is that emerge should have automatically installed ghc-bin before ghc ...
04:04:28 <kosmikus> TFK: if it hasn't, there seems to be something wrong
04:04:48 <musasabi> ghc snapshot 050117 works fine.
04:05:53 <Itkovian> nice
04:06:11 <Itkovian> any ghc developers around here?
04:06:14 <TFK> Nope, it hasn't. I tried emerging 6.2.2.
04:06:27 <Itkovian> TFK: and if you emerge 6.2?
04:06:32 <Itkovian> does it emerge the bin then?
04:06:51 <TFK> Haven't tried that, tbh, already grabbed ghc-bin :-)
04:07:03 <Itkovian> :-)
04:07:46 <TFK> Yay, seems to have worked!
04:09:08 <Itkovian> way to go!
04:09:18 <Itkovian> and fast too :-)
04:09:54 * TFK nods
04:09:58 <TFK> And now, to the tutorials!
04:10:10 <Itkovian> it would be neat if one could import stuff on the command line, e.g. one's own library of useful stuff
04:11:15 <TFK> Can't you import stuff from within hugs?
04:11:17 <kosmikus> if it's a package, you can just use qualified names
04:19:13 <Itkovian> kosmikus, what if the stuff is my own ... and not neatly organised in a package and written doen in the package config file?
04:21:11 <kosmikus> you can still make it a package ...
04:21:40 <Itkovian> I could ... but it would be a collection of random stuff, not very nice ...
04:21:42 <kosmikus> grr, portage behaviour seems to have been changed without notice w.r.t. ghc/ghc-bin
04:21:56 <Itkovian> ouch
04:30:36 <shapr> jiihaa
04:30:45 * shapr hops
04:31:26 <Itkovian> hi shapr.
04:31:32 <Itkovian> checks this out:
04:31:43 <shapr> hoi Itkovian 
04:31:44 <Itkovian> cat | cut -d" " -f3,5 | ghc -e 'do { cs <- getContents; putStrLn $ let list = 
04:31:44 <Itkovian> (map words) (lines cs); ls = tail (map (\(x:y:[]) -> x) list); rs = map 
04:31:44 <Itkovian> (\(x:y:[]) -> y) list  in show (foldl (&&) True (zipWith (==) ls rs)   ) ; }'
04:31:49 <shapr> hoe gaat het met jou?
04:31:56 <Itkovian> way better than that crap I produced yesterday, eh :-)
04:32:02 <Itkovian> goed, dank u
04:32:47 <shapr> you can probably save a few more chars by using >>= instead of do notation. I'm not sure that'll increase readability any though.
04:32:55 <shapr> In fact, it'll probably make it harder to  read.
04:33:45 <shapr> Actually, I really like the way you've used the bunch of lets with the in.
04:33:54 <shapr> That's quite readable
04:34:39 <shapr> Well, to a capable Haskell programmer :_)
04:34:46 <shapr> I wonder what a perl -e guy would say about it.
04:35:03 <Itkovian> I'll let you now if I can say what it does in a month or two ...
04:35:50 <shapr> You probably want to grab the hsshellscript library, the LicensedPreludeExts and some of the other util libraries people on #haskell have written
04:35:58 <shapr> Then you'll be 'loaded for bear' as the saying goes.
04:36:18 <shapr> hoi reffie 
04:36:48 * shapr digs around for more utility libraries.
04:40:38 <Itkovian> cool shapr, but how do I use those on the command line? Afaik atm, the only option is to include them in my ~/.ghc-package config file, no?
04:41:16 <Itkovian> I _was_ looking for this: splitRegex
04:41:17 <Itkovian> :-)
04:41:19 <Itkovian> wooot!
04:49:45 <magical1> right so I have gone through the tutorial, now what should I do?
04:50:00 <sorje_> produce code ;-)
04:51:42 <magical1> okay, I've installed hugs and tested some of the examples and it seems to work
04:58:34 <shapr> y0 jmob 
04:58:44 <shapr> jmob: you learning Haskell?
05:00:01 * shapr hops around randomly
05:00:33 <Itkovian> on yr cycle?
05:00:38 <shapr> Actually yes.
05:00:41 <Itkovian> lol
05:00:42 <shapr> I'm about to go unicycling.
05:00:52 <Itkovian> How hard is it to learnt hat?
05:01:04 <shapr> Oh, I emailed Surly Bikes, and their new 65mm rim will be shipping in less than two months!
05:01:20 <shapr> Man, I think I'm gonna buy two rims so I can have two unicycles with wide load tires.
05:01:38 <shapr> Itkovian: not too hard, it took me about ten days of learning one hour a day.
05:01:58 <Itkovian> if you have two unicycles, your almost have a real bike. way to go!
05:02:18 <shapr> I have a 20" and a 24" right now, one for learning and one for mountain unicycling.
05:02:42 <Itkovian> cool.
05:03:10 <shapr> This new rim is will be nearly double the width of my current extrawide downhill rim.
05:05:01 <shapr> Nowadays I'm trying to learn the cool tricks like idling, riding backwards, riding one footed, etc
05:06:10 <shapr> idling is neat, it's a weird pendulum pattern where your shoulders stay in the same place and your wheel rolls slightly less than half a revolution backwards and forwards. You're both moving and staying in the same place.
05:08:08 <shapr> tromp: hoi!
05:08:16 <desrt> how much do you have to move back and forth in order to not fall over?
05:08:48 <shapr> If you're skilled, only a few inches.
05:09:30 <shapr> Like, three inches or so for experienced idlers. If you're not skilled like me, I have to move about six inches, and I can only roll back and forth about four times before I fall over.
05:09:36 <desrt> that was non-generic you :)
05:09:57 <desrt> although i'm glad i have a basis for comparison
05:11:56 <shapr> I'm looking forward to this new rim that's made for 'adventure cyclists'. My unicycle will look even more like a tractor.
05:12:54 <desrt> now.... i'm just an amateur at all this unicycle stuff
05:13:05 <desrt> but i think i'd at least like to be able to tell the difference between one and a tractor :)
05:13:52 <shapr> Wait till you see some of the mountain unicycle setups... http://gallery.unicyclist.com/albux14/gazzilla_marge_008
05:15:52 <Itkovian> that is one huge thing!
05:15:55 <tromp> hoi, shapr
05:16:06 <shapr> hoi tromp, how's code?
05:16:26 <tromp> just about to start writing some
05:16:38 <tromp> to count the number of quzzle configurations
05:16:42 <shapr> err
05:16:46 * shapr asks google
05:17:05 <shapr> oh
05:17:12 <tromp> right on
05:17:30 <shapr> Have you seen IceHouse?
05:17:39 <tromp> the movie:-?
05:17:50 <shapr> Er, no.. the game construction set.
05:17:58 <tromp> not yet
05:18:16 <shapr> I've been thinking about a zero-one-more setup using IceHouse pieces.
05:18:30 <shapr> IceHouse - http://wunderland.com/icehouse/Default.html
05:19:06 <tromp> what's a zero-one-more setup?
05:19:14 <tromp> is that glue they use?
05:19:37 <shapr> We played Blockade for the first time recently, it's a neat game that integrates elements of tower of hanoi, the old icebreaker game ,nd a bunch of other stuff.
05:20:21 <jmob> shapr: learning sml actually
05:20:47 <shapr> I have a very general idea that I'd like to emulate computation with physical pieces. Some of my candidates have been refrigerator poetry magnets, go pieces on a go board, and IceHouse pieces.
05:21:02 <shapr> jmob: ah, cool
05:21:18 <tromp> like making a cpu in the game of life?
05:21:47 <shapr> One of my strategies for integrating algebraic datatypes has been the Hoare(?) comment that only three numbers are significant, zero, one, and infinity.
05:21:55 <shapr> Yes, like making a cpu in the game of life.
05:22:06 <jmob> unfortunately smlnj doesn't seem to be 64-bit clean
05:22:15 <shapr> Neumann's first self-reproductive critter took something like 90 squares in a 188 state space.
05:23:14 <tromp> sliding block puzzles can emulate circuits
05:23:40 <shapr> IceHouse pieces come in three sizes, so I've been trying to make them act like zero, one, and more. Sort of like LISP lists.
05:23:53 <shapr> Or peano arithmetic I guess.
05:24:06 <reffie> hoi
05:24:45 <shapr> of course the next two questions are, how to make that useful in a game? and how to write a multiplayer IceHouse client in Haskell? ;-)
05:24:48 <shapr> hoi reffie 
05:25:09 <tromp> i see no lack of ambition:)
05:25:12 <reffie> :)
05:26:54 <magical1> sorry to bother you, but I was wondering does anyone know where I can find an example of a game written in Haskell to have a look at?
05:27:48 <shapr> tromp: what do you use to look for quzzles?
05:27:48 <tromp> didn't you find any on the haskell home page?
05:28:10 * magical1 slaps his forehead
05:28:13 <Oeje1> magical1: Do you want a GUI game or an AI or a console game?
05:28:25 <desrt> i can only assume that that kid does not ride that thing :)
05:28:25 <tromp> what do you mean, shapr?
05:29:11 <shapr> hiya chip 
05:29:16 <shapr> tromp: what language, what sort of setup?
05:30:00 <tromp> a colleague told me he counted some 27000 states using perl
05:30:19 <tromp> which seems ridiculously low to me, so i'm gonna write a haskell program to count em
05:30:42 <tromp> number of ways to fill 4x5 area with the quzzle pieces
05:30:42 <shapr> ah, neat
05:32:45 <kuribas> Itkovian: what does that oneliner do?
05:33:08 <desrt> is a quzzle piece like tetris?
05:33:22 <shapr> tromp: sounds perfect for a list monad
05:33:27 <kuribas>  
05:33:27 <kuribas> ERC> 
05:33:27 <kuribas> Itkovian: test if column 3 and 5 are the same?
05:33:55 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with GNU Emacs 21.3.1 (i386-pc-linux-gnu, X toolkit, Xaw3d scroll bars, built 2004-10-16)!
05:33:57 <shapr> w00
05:34:11 <shapr> now I want a YiRC client.
05:34:14 <shapr> :-/
05:34:34 <kuribas> shapr: sorry
05:36:00 <kuribas> unexpected behaviour...
05:36:16 <shapr> yeah, well. ERC still has some bugs.
05:37:05 <jmob> shapr: why is living inside your editor cool, I don't get it :(
05:38:01 <shapr> Because I can do a lot more that way. I can associate emails with an irc nickname, I can jump to an url pasted into irc or email with a single keypress. Stuff like that.
05:38:12 <kuribas> jmob: you mean emacs is an editor? :-)
05:38:18 <shapr> On #emacs, I can directly execute code others have pasted.
05:39:37 <jmob> shapr: you can do most of that with a ``normal'' windowing environment.
05:40:34 <kuribas> jmob: emacs is good at handling text.  If the extensions are written well...
05:41:16 <shapr> eshell gives you a command line where you can pipe to and from buffers, elisp code, and shell commands.
05:42:29 <shapr> jmob: yes, I think it can all be done in a normal windowing environment, but it's a lot harder there.
05:46:25 <Itkovian> kuribas: not exactly ... well, yes if you move the left column up one line :-)
05:46:43 <kuribas> Itkovian: ah yes, I see
05:47:24 <kuribas> Itkovian: "foldl (&&) True" is the same as "all", isn't it?
05:48:35 <tromp> not quite
05:49:07 <tromp> same as all id
05:49:41 <kuribas> same as "and"?
05:49:42 <tromp> all expects a predicate
05:50:04 <tromp> yep, that's easier:)
05:50:11 <Igloo> Not the same if you give it an infinite list containing a False, either
05:50:44 <Itkovian> ah ... 
05:50:46 <Itkovian> @type all
05:51:02 <Itkovian> lambdabot?
05:51:14 <tromp> uh, igloo?
05:51:15 <Igloo> foldr (&&) True   is the same as and/all id, though
05:51:18 <Igloo> tromp?
05:51:32 <tromp> which one fails on infinite list of Falses?
05:51:40 <Igloo> foldl (&&) True
05:51:56 <Igloo> Try   foldl (&&) True (False:undefined)
05:52:38 <Itkovian> ic
05:52:42 <tromp> ah, yes
05:53:00 <tromp> foldr should work though
05:53:54 <Itkovian> eh?
05:54:03 <Itkovian> why?
05:54:18 <tromp> igloo, you meant; foldl (&&) True (repeat False)
05:55:16 <Igloo> Well, I really meant something too complex to bother writing instead of "infinite list"
05:55:46 <tromp> foldr (&&) True (repeat False)   works fine
05:57:46 <Itkovian> that it does.
06:00:32 <magical1> Oeje1: I want a console game that uses Ai
06:02:30 <Oeje1> magical1: I can give you an AI for connect-four.  It's just the AI: http://www.student.dtu.dk/~s022018/temporary/OlinkaII.hs
06:03:10 <magical1> thats a brilliant start thanks
06:04:10 <Oeje1> magical1: It's not very well documented, but please ask.
06:05:28 <magical1> just reading it now .....
06:06:01 <Oeje1> You might want to follow the link in the top.
06:08:04 <magical1> just went there, which structure is the Ai using an array or a list, or an array of lists?
06:08:58 <Oeje1> No, this is the board: data Game = G BitBoard BitBoard Player, and type BitBoard = Int64.
06:09:27 <tromp> there's an easier way to test for 4-in-a-row
06:09:43 <magical1> okay?
06:11:08 <magical1> hey Oeje1 what does the declaration "BitBoard = Int64" mean? an integer from 1 upto 64?
06:11:17 <tromp> a 64 bit int
06:11:24 <magical1> okay
06:11:45 <Oeje1> So I have the same representation as in the linked article.
06:11:59 <magical1> yes I see
06:12:33 <Oeje1> Bit 1 to 42 is the positions of the board.  One Int64 for each colour.
06:13:03 <magical1> okay
06:13:43 <Oeje1> Boy it needs to be documented.
06:14:05 <tromp> also see http://homepages.cwi.nl/~tromp/c4/Connect4.java
06:14:26 <magical1> okay
06:15:46 <xerox> 'lo
06:45:13 * shapr hops cheerfully
06:45:17 <shapr> Man I love unicycling!
06:45:28 <basti_> did i mention that i got that csound thing running?
06:45:34 <TFK> Is it just me or is this tutorial http://www-106.ibm.com/developerworks/edu/os-dw-linuxhask-i.html <--- kinda screwed up? It has dots where all kinds of interesting names should be O_O
06:45:38 <shapr> yeah, you mentioned, but I haven't had time try it yet.
06:45:41 <basti_> -g-
06:46:13 <shapr> Anyway, David Roundy seems semi-interested in a prototype of Patches as arrows from me, so ...
06:46:23 <basti_> o0
06:46:34 <basti_> mind to expand?
06:46:41 <shapr> I will get back to sticking Haskore into csound, but probably not in the next two weeks.
06:47:22 <shapr> dang, what's my IBM login?
06:47:31 <TFK> Use BugMeNot.com
06:47:44 <TFK> Or rather, ask it
06:47:49 <CosmicRay> hah, they do ibm too?
06:47:55 * CosmicRay already has an ibm login, sigh
06:48:08 <magical1> hi CosmicRay 
06:48:10 <shapr> whoa, spiffy
06:48:15 <shapr> TFK: thanks!
06:48:17 <CosmicRay> morning magical1
06:48:24 <TFK> They do everything that they do... tautological, but...
06:48:33 <CosmicRay> magical1: I'm only here for 5 minutes then I have to run for awhile...
06:49:06 <TFK> O_O
06:49:10 <TFK> It's just me, apparently!
06:49:16 <TFK> The fonts are tiny... it looked like dots to me
06:49:32 <magical1> I will catch you later theb
06:49:37 <magical1> thanks CosmicRay 
06:49:39 <TFK> Why are they so small?
06:49:47 <CosmicRay> magical1: you can also ask other people in the channel :-)
06:50:01 <magical1> I am doing so
06:50:07 <CosmicRay> super
06:50:07 <magical1> thanks :)
06:50:30 <Itkovian> dang, I can;t get hsshellscript to emerge decently
06:50:59 <shapr> TFK: not enough bits in your computer ;-)
06:51:12 <shapr> Your browser had to economize.
06:51:49 <TFK> :-/
06:54:16 <Itkovian> gotta go ...
06:54:18 <Itkovian> ttyl
06:54:57 <shapr> so um, who can help me with Arrows?
06:55:03 <shapr> Where's Darius when I need him! aiee!
06:55:19 <CosmicRay> shapr: well, they're pointy.   that's about all I know.
06:55:24 * shapr snickers
06:55:44 <shapr> CosmicRay: I sent an email to David Roundy describing my idea for Patches as arrows, he's interested.
06:55:45 <CosmicRay> http://images.google.com/images?q=arrows&hl=en&lr=&client=firefox&rls=org.mozilla:en-US:unofficial&sa=N&tab=wi
06:55:49 <shapr> Now I gotta hack up a prototype to show him.
06:56:24 <tromp> argh! Quzzle.hs:6: parse error (possibly incorrect indentation)
06:56:28 <CosmicRay> does he grok arrows?
06:56:31 <shapr> nope
06:56:42 <roybattius> is there an IDE for Haskell
06:56:42 <shapr> That's probably why my last two emails slid past him.
06:56:43 <CosmicRay> is it just me, or are there about 3 people that do? :-)
06:56:46 <TFK> Whoa... hugs doesn't like infinite lists o.o;
06:56:51 <shapr> CosmicRay: I think four..
06:57:01 <CosmicRay> roybattius: emacs works as well as it does for anything else
06:57:06 <CosmicRay> shapr: haha
06:57:15 <roybattius> CosmicRay: ahh, so that means not well
06:57:23 <shapr> I like emacs!
06:57:24 <CosmicRay> roybattius: depends on whether or not you like emacs
06:57:27 <shapr> sometimes
06:57:39 <CosmicRay> roybattius: I believe that there is a haskell editing mode for emacs as well as frontends for ghc[i] and hugs
06:58:03 <shapr> Yeah, I wish more people understood arrows. I'm sure I can hack up something that will dramatically improve the speed and efficiency of darcs. But who will maintain it?
06:58:08 <roybattius> CosmicRay: i guess nothing like Dolphin or VW for smalltalk. something that isn't set back in the 70s
06:58:22 <shapr> Er, isn't smalltalk set in the 70s?
06:58:26 <CosmicRay> roybattius: I think you have some misconceptions about emacs
06:58:26 * shapr grins
06:58:29 <araujo> shapr, yes.
06:58:30 <roybattius> shapr: not the environments
06:58:32 <CosmicRay> anyway, I have a meeting and must run
06:58:34 <CosmicRay> bbl
06:58:47 <roybattius> CosmicRay: i've used emacs enough to have too many conceptions
06:59:11 <shapr> There are IDEs for Haskell. There isn't something like Morphic
06:59:36 <shapr> I would really love to have something like Self's Kansas for Haskell. mmmm!
07:00:01 <roybattius> shapr: i'm more interested in live environments these days.  my days of 70s vi/emacs editors are over
07:01:26 <shapr> In that case, you have a few choices... If you want to learn Haskell you could use Yi and hs-plugins.
07:01:38 <roybattius> actually, i could deal with vim, but it as well as the emacs infrasctucture are so crippled they are pretty much hopless
07:01:58 <shapr> Well, fix 'em , it's an open source world.
07:02:19 <roybattius> shapr: first you need to start with an eclipse model without the java
07:02:34 <shapr> How would you describe the eclipse model?
07:02:46 <roybattius> shapr: plugins galore
07:03:03 <shapr> That's not much detail :-) How does it work?
07:03:24 <roybattius> shapr: there are entire books written on eclipse
07:03:30 <shapr> So what's the basic model?
07:03:34 <roybattius> shapr: plugins
07:03:38 <roybattius> shapr: as much as possible
07:03:50 <shapr> That's emacs too, what makes eclipse different from emacs?
07:03:54 <roybattius> everything is a plugin
07:04:06 <shapr> That's still emacs.
07:04:07 <roybattius> shapr: as i said, emacs and vim are console programs
07:04:13 <TFK> Is Eclipse a plugin in itself, then?
07:04:18 <roybattius> no matter how much retrofitting goes on
07:04:20 <shapr> emacs is not a console program.
07:04:24 * Cale checks his emacs window... no
07:04:26 <shapr> That's just one of its views
07:04:40 <roybattius> emacs is a console program retrofitted to use a gui
07:04:54 <shapr> no, it's not a console or gui program.
07:05:04 <shapr> It's actually a language interpreter.
07:05:12 <Cale> It's a text editor -- so what if it's a console program anyway? You're editing text!
07:05:20 <tuomov> it's an operating system!
07:05:25 <roybattius> not exactly
07:05:32 <roybattius> well, it tries to be an OS
07:05:48 <shapr> It's just an elisp interpreter written in C. It has plugins that allow you to show things graphically or textually.
07:05:59 <roybattius> in any case, so emacs is the only option for haskell?
07:06:04 <shapr> So does smalltalk and Java
07:06:05 <xerox> roybattius, it is a language interpreter, as shapr said, which default mode is text-editing
07:06:20 <roybattius> it's elisp with c. yeah, i know
07:06:30 <shapr> So, how is eclipse better or different?
07:06:42 <Cale> roybattius: For editing Haskell I've used vim and emacs, and I find them both quite pleasant.
07:06:55 <tuomov> it's not "eight megabytes and constantly swapping", but "eight hundred megabytes and costantly swapping"
07:07:28 <Cale> really, you could use whatever text editor you like
07:07:37 <tuomov> from my limited experience debugging some strange behaviour under ion
07:08:12 <roybattius> so nobody has done a modern environment for haskell?
07:08:27 <Cale> modern?
07:08:31 <tuomov> if "modern" means a wimp gui, no thanks
07:09:02 <Cale> people have written various tools for managing projects
07:09:05 * basti_ thinks the haskell environments are very very modern
07:09:15 <basti_> i would wish a better :n for hugs though
07:09:15 <Cale> but they'll just call your favourite text editor
07:09:22 <basti_> or maybe something bells and whistles there
07:09:47 <basti_> tab completion and the like
07:09:55 <tuomov> the first thing when one starts writing some kind of special ide would be to figure out a way to embed one's favourite editor in it
07:10:03 <basti_> or faint type annotation on the cli
07:10:48 <tuomov> the problem I have with all these "modern" IDEs, word processors, etc. is that their editors are horribly inadequate
07:11:11 <roybattius> i guess i just find it humourous that so many people see emacs as the end-all to development environments. maybe it's the unix mentality. funny
07:11:12 <tuomov> all the control keys are wasted on things that you need maybe once a year
07:11:28 <shapr> roybattius: like who?
07:11:32 <TFK> roybattius, don't tell us you're using Windows too :-/
07:11:41 <tuomov> I don't like emacs. I use jed.
07:11:46 <basti_> roybattius: you dont see the whole environment when you look at the editor.
07:11:52 <tuomov> unfortunately it's syntax highlighting engine is inadequate for haskell
07:12:07 <tuomov> (can't have primes and character literals at the same time)
07:12:11 <shapr> I dearly love some parts of emacs, and despise some others. I still think it's the best editor for me so far.
07:12:15 <Cale> roybattius: well, I can't really think of what else you need - you have an interpreter/debugger, a compiler, a web browser for documentation, Emacs has just about everything else
07:12:46 <shapr> roybattius: I believe Haskell has many concepts and ideas worth learning.
07:13:15 <roybattius> Cale: and hopelessly locked into the console world no matter what gui is retrofitted onto it
07:13:17 <shapr> Try it, you might like it.
07:13:32 <shapr> roybattius: dude, give it up. If you want to flame, do it elsewhere.
07:13:41 <basti_> -g-
07:13:45 <roybattius> shapr: oh, this is #emacs?
07:13:51 * basti_ gives roybattius a pat on the back
07:13:51 <Cale> roybattius: why does it have to be all that graphical? You're mostly using it to edit text. Text is textual.
07:13:52 <roybattius> shapr: i thought i was on #haskell
07:14:02 --- mode: ChanServ set +o shapr
07:14:21 <shapr> roybattius: yes, and that means you often have to leave your preconceptions at the door.
07:14:34 <shapr> lamdba calculus does not require a gui.
07:14:42 <shapr> nor a console for that matter.
07:14:56 <roybattius> shapr: but i guess it requires emacs or vi
07:15:03 <xerox> Pen and paper? :D
07:15:03 <basti_> -?_
07:15:11 <basti_> roybattius: what world are you living in?
07:15:14 <Cale> Hear hear for pen and paper!
07:16:08 <TFK> roybattius, you can just use any text editor you like, I guess.
07:16:15 <shapr> It sounds to me like you're more interesting in expounding your viewpoints than in learning what is here to learn.
07:16:16 <basti_> you can even go without any editor.
07:16:45 <tuomov> 'cat' is enough!
07:16:53 <roybattius> shapr: no, i'm listening(lurking). i asked a question and all i got was "this is all you need"
07:16:53 <tuomov> real coders don't make mistakes
07:17:01 <Cale> you could use gedit
07:17:02 <basti_> echo!
07:17:10 <basti_> hugs!
07:17:12 <Cale> if you want something graphical
07:17:48 <roybattius> what's hugs?
07:17:57 <basti_> an haskell interpreter
07:18:03 <shapr> roybattius: listening and lurking don't involve emotional statements such as "something that isn't set back in the 70s"
07:18:03 <TFK> roybattius, hugs is an interactive interperter.
07:18:05 <basti_> you can conduct a live haskell conversation
07:18:09 <tuomov> I must agree that starting to use more advanced ideish features of emacs is not very user friendly...
07:18:16 <TFK> Much like Python's interactive interperter.
07:18:39 <tuomov> but I've never really needed such things, so jed is mostly enough for my editing
07:18:46 <Cale> roybattius: I don't really understand why you want a graphical text editor in the first place. Could you explain what graphical information you could possibly want there?
07:19:21 <roybattius> Cale: to see project flow
07:19:21 <shapr> words like "crippled" don't fit into listening and lurking either.
07:19:24 <Cale> I suppose you could do tricks like formatting mathematical expressions using TeX or something
07:19:35 <basti_> project flow???
07:19:40 <Cale> project flow?
07:20:11 <roybattius> your structures of your code
07:20:19 <basti_> the structure of the code!
07:20:20 <basti_> yes
07:20:26 <basti_> well you can see that without graphics
07:20:34 <basti_> though alignment and effects do help
07:20:42 <tuomov> many terminals support line-drawing characters
07:20:52 <shapr> There's also a nice haskell IDE that integrates vim or emacs and shows code flow via graphviz.
07:21:07 <roybattius> don't need graphics for that. i love vim. i just claim that emacs and vim are crippled in many respects
07:21:09 <basti_> shapr: whats its name?
07:21:10 <xerox> shapr, how's it called? (any url?)
07:21:17 <edwinb> crippled? *boggle*
07:21:21 <roybattius> shapr: there we go
07:21:27 <shapr> http://www.scannedinavian.org/~shae/hIDE.png
07:21:31 <tuomov> all the ides I've come across are even more crippled - the _editor_ sucks
07:21:38 <Cale> roybattius: Wolfram Kahl wrote a nice little program to turn your module structure into a dot graph
07:21:41 <shapr> It's hIDE/haIDE
07:21:49 <roybattius> all ides suck in some respect when they don't have vi mode:)
07:21:54 <edwinb> They're only meant to be text editors... emacs just happens to be a way of life too ;)
07:22:01 <basti_> lol
07:22:02 <roybattius> Cale: now we're getting some where
07:22:22 <Cale> but I don't see how that fits into your text editor
07:22:36 <tuomov> no, ides are not meant to be text editors
07:22:46 <tuomov> they don't have what I'd call an usable text editor
07:22:51 <Cale> http://www.cas.mcmaster.ca/~kahl/Haskell/
07:23:18 <tuomov> ides are packages that do everything but nothing well
07:23:33 <shapr> roybattius: don't flame again, it's not nice.
07:23:34 <roybattius> unless the editor supports vi mode
07:23:48 <tuomov> unless the editor supports joe mode
07:23:55 <roybattius> shapr: you misread. i didn't flame haskell. i flamed emacs
07:24:08 <tuomov> there you see - ides should be structured around everyone's favourite text editor
07:24:26 <shapr> roybattius: I didn't specify a target.
07:24:38 <shapr> Feel free to flame elsewhere, but not here.
07:24:45 <roybattius> shapr: ok, can i flame Visual Basic?
07:24:52 <shapr> No, it has good points too.
07:25:00 <shapr> :-P
07:25:03 <roybattius> ok, hitler
07:25:14 <edwinb> now there's no need for that...
07:25:26 <shapr> Flaming involves emotional persuasive comments that contain little to no facts.
07:25:28 <Cale> IDE's should not include a text editor, because there will be large collections of people who aren't happy with it.
07:25:29 <xerox> shapr, VB has good points?!
07:25:35 <edwinb> It draws pretty pictures.
07:25:41 <shapr> xerox: yes, it does.
07:25:48 <TFK> I thought IDEs are all about emotional flame-wars? :-P
07:25:50 <roybattius> shapr: you flamed by praising VB. hehe
07:26:06 <xerox> shapr, I can't find it good for making GUIs as people say, it's frustrating, but maybe because I don't like basic and so..
07:26:30 <tuomov> guis should not be designed by drawing widgets
07:26:35 <shapr> xerox: One of the nice VB good points is that it has the beginning of the implicit traversals that end up in fold/map/etc
07:26:42 <tuomov> programs should not be written around a gui
07:27:03 <Cale> roybattius: okay, so you have a graph of your modules. Turns out the same guy worked on term graph programming http://www.cas.mcmaster.ca/~kahl/HOPS/
07:27:04 <roybattius> tuomov: so you advocate writing guis by hand?
07:27:10 <roybattius> Cale: thanks
07:27:12 <shapr> The For Next loop in VB does not require explicit iteration, so it cuts down on programmer mistakes that come from explicit loops as in C or Java.
07:27:15 <Cale> but that's another language altogether
07:27:30 <tuomov> I advocate separating the ui from the rest of the program, and in many cases automagically generating the ui
07:27:40 <tuomov> (http://iki.fi/tuomov/vis/)
07:27:40 <roybattius> Cale: that's all i want really. i don't care about editor choice per se, just a way to visualize code
07:28:04 <basti_> roybattius: welcome to the *nix world.
07:28:12 <Cale> visualising pure functional code is complicated
07:28:15 <roybattius> basti_: i'm too used to the nix world
07:28:22 <Cale> because you code is not a tree
07:28:25 <Cale> your*
07:28:38 <basti_> yup... the textual representation is pretty good
07:28:38 <roybattius> Cale: yeah, the functional world...
07:28:42 <Cale> it's an almost arbitrary graph
07:28:46 <basti_> although there are "graphical" languages
07:29:03 <roybattius> why couldn't the functional world be visualized?
07:29:06 <Cale> It's easier not to visualise it
07:29:07 <basti_> which are basically the same just with pretty pictures
07:29:25 <basti_> labview
07:29:29 <shapr> graph reduction was one of the early approaches.
07:29:37 <shapr> It's still used in dataflow languages, I think.
07:30:00 <basti_> dataflow is an important view of code too, btw.
07:30:17 <roybattius> that's what i'm getting at
07:30:38 <roybattius> you've got a view, and you click on something and goto the flow
07:30:50 <basti_> well you can do most of that sort of "visualisation" in your head
07:30:56 <basti_> uhm thats a link actually
07:31:09 <basti_> (which forms a graph with all the other links)
07:31:20 <roybattius> but why your 'head'? if it's in your head, it should be visual?
07:31:24 <Cale> http://www.cs.kent.ac.uk/projects/vital/ is something graphical. Doesn't have a full haskell implementation but it's fun to look at
07:31:36 <roybattius> i'm not flaming. i'm just a newbie and questioning
07:31:56 <roybattius> i hear good things about functional languages and ask questions
07:32:11 <shapr> I think it's partially because category theory covers the changes better than a graphical view would.
07:32:35 <roybattius> well, not really GUI, but cateogrized maybe
07:32:40 <roybattius> or whatever you want to call it
07:32:51 <roybattius> i mean...you guys have large code bases right?
07:33:22 <roybattius> modules and such
07:33:27 * shapr wonders if all the category theory stuff can be equally well expressed graphically.
07:33:30 <basti_> http://www.upscale.utoronto.ca/GeneralInterest/LabView.html <
07:33:31 <Cale> I wrote a pipeline scheduler for powerpc in about 700 lines of code.
07:33:37 <Cale> (Haskell code)
07:33:44 <shapr> I wrote a mailing list archive search webapp in 200 lines of code.
07:33:46 <roybattius> this isn't all academic right?
07:33:56 <basti_> this is the most elaborated graphical language i know
07:34:01 <shapr> I get paid to write Haskell occasionally.
07:34:05 <shapr> I'm self-employed.
07:34:06 <tromp> ok, counted all the quzzles
07:34:12 <basti_> roybattius: uhm actually i let my haskelle play music
07:34:27 <basti_> in realtime.
07:34:34 <shapr> tromp: was it more than the Perl solution?
07:34:36 <tromp> my friend was right, there are much fewer than i expected:)
07:34:42 <shapr> neat
07:34:50 <tromp> 25728
07:35:08 <tromp> unless we both wrote the same bug:)
07:35:11 <shapr> heh
07:35:12 <basti_> roybattius: i dont know what youre expecting
07:35:16 <Cale> I was paid to write the pipeline scheduler, but it was for a research project which hopes to produce something practical
07:35:31 <basti_> roybattius: i say hop and my system jumps, so wheres the problem? :)
07:35:46 <jmob> why can't someone implement an emacs that doesn't look like ass, and implement more of vim's functionality in viper
07:35:50 <tromp> so if you ever need to count ways of sticking rectangles into a bigger one...
07:35:53 <shapr> jmob: you need Yi!
07:35:55 <jmob> I mean, I'd do it, if I had time.
07:35:56 <roybattius> basti_: probably not much. seems like haskell is all the rage so i decided to check out the hype
07:36:02 <Cale> We have vectorised sine/cosine code which does about 2.5 clocks/result on a G4.
07:36:08 <shapr> roybattius: it's all the rage??
07:36:11 <basti_> roybattius: ? :)
07:36:16 <basti_> roybattius: we're peaceful.
07:36:22 <shapr> Where is it all the rage?
07:36:28 <roybattius> basti_: if lambda-the-ultimate.org had the say
07:36:29 <basti_> http://www.students.uni-marburg.de/~Zapf/platwonk.ogg
07:36:36 <basti_> ah it hasnt
07:36:37 <roybattius> oh dudes
07:36:41 <roybattius> you being sarcastic
07:36:50 <Cale> hehe
07:37:03 <basti_> whats the problem? ;)
07:37:17 <shapr> lambda-the-ultimate.org is a programming language theory forum.
07:37:18 <roybattius> i'm enraged because of Haskell damnit! :)
07:37:33 <basti_> because of a programming language??
07:37:52 <basti_> because of haskell or because strange people talk strange things that you dont understand? ;)
07:37:57 <roybattius> i'm damn enraged, because lambda-the-ultimate says its all the rage!
07:38:02 <basti_> oh
07:38:07 <Cale> roybattius: anyway, the best way to find out about Haskell is writing some code.
07:38:09 <basti_> didnt know it was a headline or something
07:38:11 <basti_> yup
07:38:13 <shapr> It is all the rage on LtU.
07:38:24 <basti_> roybattius: you could start with some simple one liners.
07:38:31 <basti_> roybattius: you can even use that bot here
07:38:31 <roybattius> ok
07:38:31 <shapr> @wiki HaskellDemo
07:38:32 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
07:38:45 <basti_> @eval + 3 4 
07:38:46 <lambdabot> (line 1, column 1):
07:38:46 <lambdabot> unexpected "+"
07:38:46 <lambdabot> expecting white space or simple term
07:38:48 <basti_> hm
07:38:53 <basti_> @eval (+ 3 4)
07:38:53 <lambdabot> (line 1, column 2):
07:38:53 <lambdabot> unexpected "+"
07:38:53 <lambdabot> expecting simple term
07:38:56 <basti_> okay.
07:38:57 <shapr> eval isn't real Haskell :-)
07:39:00 <basti_> it cant add cant it?
07:39:00 <basti_> ;)
07:39:05 <roybattius> i'm assuming haskell has a developer friendly license
07:39:11 <shapr> it's free.
07:39:15 <WilX>  @eval ((+) 3 4)
07:39:21 <TheHunter> @eval 3 + 3
07:39:21 <lambdabot> 6
07:39:22 <shapr> GHC is BSD licensed.
07:39:34 <roybattius> shapr: ok, BSD is developer friendly
07:39:38 <basti_> how could a language have a license?
07:39:44 <shapr> Look at Java :-)
07:39:45 <basti_> its implementations have maybe
07:39:58 <basti_> well i think "java" is free
07:40:03 <basti_> not the jvm, but the language is.
07:40:09 <basti_> as free as a thought can be.
07:40:16 * Oeje1 laughs evily at Java.
07:40:26 <shapr> Thoughts aren't that free lately.
07:40:26 <basti_> its caged in by nazis
07:40:28 <dottedmag> basti_: Debian team think different
07:40:31 <basti_> poor language.
07:40:36 <roybattius> libraries
07:40:41 <basti_> well i think thats a matter of philosophy
07:40:52 <basti_> but i'm living my personal philosophy.
07:40:57 <shapr> Software patents in the US mean that there are things you are not allowed to think.
07:40:58 <basti_> noone has put me to jail yet luckily
07:41:02 <basti_> i know
07:41:05 <Oeje1> basti_: There is a reason the free Java implementations only has the old standard libraries.
07:41:14 * Cale needs to figure out how to type annotate lisp code. There seems to be a type system and apparently CMU lisp can do static checking.
07:41:24 <basti_> Oeje1: basically, i acknowledge that there is debate going on about that.
07:41:27 <Cale> I don't know how people get by without static type checking
07:41:34 <roybattius> ok, without busting balls. what's the big deal about haskell? say over Lisp? no, i don't want people straining fingers typing furiously:)
07:41:36 <shapr> Cale: it's just atool!
07:41:46 <basti_> Oeje1: but i challenge any try to do so.
07:41:50 <shapr> roybattius: higher order functions, monads, arrows..
07:42:04 <basti_> the type system is cool.
07:42:05 <shapr> Haskell has a few small pieces that do a whole lotta stuff.
07:42:07 <basti_> mondo cool.
07:42:24 <roybattius> yeah, i hear about this monad stuff. sounds like a 80s teen flick:)
07:42:25 <basti_> bascially its the art of swiss watches carried on to programs.
07:42:28 <shapr> Java has a whole buncha pieces that don't do much without each other.
07:42:53 <Cale> shapr: Yes, but it's so much harder to write code that works without some guarantees made by the compiler.
07:42:55 <shapr> Algebraic Datatypes are the Lego of structure.
07:43:03 <roybattius> arggh, i'm done with java/C++/C#, that's why i'm exploring smalltalk, dylan, lisp, Slate
07:43:04 <shapr> Cale: true that
07:43:10 <roybattius> and haskell
07:43:10 * Cale is overly used to Haskell :)
07:43:27 <roybattius> please don't tell me i have to be Knuth to use this stuff
07:43:29 <basti_> roybattius: and all of these dont have haskells type system
07:43:34 <basti_> you dont have to be
07:43:39 <basti_> actually its pretty intuitive
07:43:48 * Oeje1 also likes Common Lisp and Scheme, each for different reasons.
07:43:49 <shapr> roybattius: nah, you just gotta sit down and learn it. It's no harder than learning to program in the first place.
07:43:55 <basti_> you dont need to understand a monads insides to use one.
07:43:57 <roybattius> no side effects. i get that
07:44:01 <Cale> roybattius: In some sense it makes you Knuth, so you don't have to think about it :)
07:44:05 <shapr> haha
07:44:06 <jmob> roybattius: checked out Python? It's not as painful as java/c++/c# and is probably more likely to make money
07:44:09 <shapr> that's quotable
07:44:15 <roybattius> yeah, i know python
07:44:20 <shapr> Python is worth learning.
07:44:33 <xerox> LISP is worth learning.
07:44:42 <basti_> almost any language is worth learning.
07:44:48 <basti_> heck even Prolog!
07:44:50 <basti_> =)
07:44:51 <roybattius> VB
07:44:53 <WilX> Huh, I have serious doubts about Python :)
07:44:54 <roybattius> muwhaah
07:44:57 <WilX> ...or Prolog.
07:45:08 * WilX pours some more oil into the fire
07:45:20 <Nioate> python is great
07:45:30 <tuomov> cobol!
07:45:34 <Nioate> except some of the latest additions seem crazy
07:45:36 <basti_> various assemblers are not worth mentioning.
07:45:37 <TFK> 'Tis
07:45:37 <WilX> Sure, untill you get to know Perl.
07:45:38 <goron> Can anyone tell me the difference between a monomorphic type variable and a polymorphic type variable? 
07:45:40 <basti_> Oz is cool.
07:45:40 <jmob> WilX: Prolog was good for figuring out what order our servers needed to start up in.
07:45:41 <roybattius> i really like prototype languages and multi-methods
07:45:45 <roybattius> seems natural to me
07:45:52 <basti_> Perl is....
07:45:54 <TFK> WilX, I think ti's the other way around.
07:45:57 <TFK> *it's
07:45:59 <basti_> uhm... a border case... like brainfuck
07:46:00 <Cale> roybattius: Do you know what coroutines are?
07:46:01 <jmob> WilX: since they're all heavily interdependant
07:46:07 <roybattius> Cale: lua?
07:46:15 <TFK> basti_, lol
07:46:20 <Cale> lua might have some partial support for them
07:46:33 <roybattius> Cale: as in i don't have to bust my stack?
07:46:37 <basti_> but actually it might be good to learn just to see how bizarre a language can be
07:46:40 <Cale> yeah
07:46:43 <basti_> perl is DIFFERENT.
07:46:46 <roybattius> Cale: i don't really know, but kindof i guess. i call 
07:46:59 <jmob> Perl is a religion, not a language.
07:47:12 <basti_> perl is plain bizarre.
07:47:16 <Cale> Haskell basically gives you coroutine like computation without having to think about coroutines.
07:47:22 <xerox> @get-definition Y
07:47:23 <lambdabot> Y = \f.U(\g.f(U g))
07:47:24 <xerox> @get-definition I
07:47:25 <lambdabot> I = \x.x
07:47:25 <basti_> <#@$a\B[->{\\}}}}>
07:48:07 <roybattius> Cale: yeah, i took a look at lua with its coroutines and it seemed very natural. you just call off to anybody you want without worrying about some big switch or something
07:48:14 <basti_> roybattius: think about askell as about lisp on acid.
07:48:28 <roybattius> never been a fan of prefix though
07:48:38 <basti_> well actually
07:48:38 <roybattius> prefix is not natural no matter what the smug lisp weenies say
07:48:46 <basti_> haskell lets you define infix operators
07:48:48 <basti_> if you want them
07:49:00 <roybattius> peel the onion...yeah, yeah
07:49:03 <basti_> it has to have a parser that understands this addition
07:49:14 <basti_> and they look like all the other infix operators
07:49:21 <basti_> you can make a special + just for your use
07:49:30 <basti_> or a *** or whatever
07:49:46 <Cale> roybattius: check http://www.haskell.org/hawiki/HaskellNewbie search for "combinatorially", to see a comment that I made regarding the benefits of lazy computation and monads.
07:50:01 <tuomov> in theory you could have all kinds of unicode symbols as infix ops
07:50:10 <tuomov> the compilers just don't support them atm
07:50:11 <roybattius> Cale: don't get me all confused with mondads and crazy shit like that:)
07:50:34 <basti_> roybattius: actually youd be surprised when you understand what a monad is and where they did hide
07:50:37 <basti_> and how.
07:51:01 <basti_> and where there were none
07:51:18 <Cale> I've taught how monads work to elementary school students.
07:51:20 <roybattius> Cale: i'll check it out. lazy computation
07:51:30 <basti_> bascially its just a more elaborated way to talk about what happens inside your computer
07:51:31 <roybattius> Cale: i'm in pre-school
07:51:37 <Cale> hehe :)
07:52:28 <basti_> did i mention i like the concept of HOpenGL?
07:54:29 <Cale> I think the trouble with monads is that they're a lot *less* complicated than the language commonly used to discuss them, and even some very smart people get confused.
07:54:50 <basti_> the problem is the binocularity.
07:55:02 <basti_> if you try to think both monad and "old" you get confused
07:55:14 <basti_> thats like having different glasses for each eye
07:55:21 <basti_> i think.
07:55:56 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers explains how I like to think about monads. They're just an interface to certain kinds of containers. The containers can be complicated, but the interface isn't all that hard to grasp.
07:56:06 <goron> Can somebody explain me something about monomorphic type variables? I don't understand how something can be monomorphic and "variable" at the same time. 
07:56:36 <basti_> goron: well its "monomorphing" in that it wont change in a given "subprogram"
07:56:38 <basti_> c
07:57:05 <goron> basti_: With subprogram you mean sub AST. 
07:57:08 <basti_> goron: if you have "x" twice in a (big) expression you know that the second x is the same as the first
07:57:25 <basti_> well if you introduce it
07:57:29 <basti_> blah x = ...
07:57:33 <roybattius> Cale: throw me the wiki to the history of haskell
07:57:36 <basti_> in "..." x would be monomorphic
07:57:57 <basti_> (if its not overloaded or some other otherworldly bizarre thing)
07:58:45 <basti_> (im not telling yet what is happening with blah ;P)
07:59:13 <Cale> hmm... I'm not sure if there's any historical info on the wiki... perhaps I could find something...
07:59:16 <goron> you mean \x-> let a=x*2;y=x; in 5*5? Or do you mean \x->let a=x+....+x in 5
07:59:26 <jmob> Anyone running ghc on a 64 bit machine?
07:59:31 <desrt> jmob; hello.
07:59:32 <Cale> http://haskell.org/haskell-history.html
07:59:35 <Cale> there's that
07:59:41 <roybattius> thanks
07:59:58 <desrt> jmob; what's up?
08:00:00 <jmob> desrt: anything special needed to get it to compile?
08:00:08 <Cale> it seems like someone started writing it and stopped somewhere, but hey, history :)
08:00:16 <desrt> what sort of 64bit machine is it?
08:00:20 <jmob> desrt: AMD
08:00:39 <desrt> jmob; i've heard various reports that AMD64 is supported registerised/unregisterised
08:00:51 <desrt> you can definitely get it to work unregisterised... just add the option to build.mk
08:01:09 <desrt> and ghci almost definitly doesn't work... so you'll want to not build the interpreter
08:01:18 <desrt> *definitely
08:01:28 <jmob> desrt: ok, I'll try to build it then, my distro doesn't have a package for ghc
08:01:39 <desrt> lemme get you some build.mk options
08:02:23 <desrt> GhcWithInterpreter=NO
08:02:23 <desrt> GhcWithNativeCodeGen=NO
08:02:23 <desrt> SplitObjs=NO
08:02:23 <desrt> GhcLibWays=
08:02:23 <desrt> GhcUnregisterised=YES
08:02:41 <desrt> after you run ./configure, add those 5 lines to mk/build.mk (which should be a new file)
08:03:18 <desrt> unregisterised may or may not be required.  saying YES is safer, but somewhat slower
08:04:00 <jmob> ok, cool, thank you
08:04:03 <desrt> gotta run.  good luck
08:04:40 <desrt> ((for the record: running a 32bit version of ghc will almost definitely be much faster than running a native amd64 version))
08:05:05 <jmob> Oh, okay, I guess there's no point in compiling it then. :)
08:05:15 <jmob> I already have it working in a chroot.
08:09:47 <Cale> roybattius: for a cute toy example of what sort of communication you can get with lazy evaluation:
08:09:51 <Cale> odds = 1 : map (+1) evens
08:09:51 <Cale> evens = map (+1) odds
08:10:32 <Cale> these are lists defined in a mutually recursive way. The path of execution will bounce back and forth to compute any given element of them
08:11:22 <goron> I still don't understand the concept of monomorphic type variables. Could someone past an example to the wiki? I can inference a type of some Haskell expression, but I can't find any examples that explain this concept. 
08:11:25 <Cale> that says "the list of odd numbers starts with 1 and is followed by the list of even numbers where 1 has been added to each
08:11:41 <Cale> and the even numbers are just the odd numbers where 1 has been added to each"
08:12:50 <Cale> goron: I'm not sure what those would be. Perhaps they refer to type variables of kind * ?
08:13:21 <Cale> as opposed to type constructors, or type constructor variables.
08:14:23 <goron> Cale: The i in let i = (\x->x) in i i is polymorphic according to my book. 
08:14:51 <goron> Cale: He only does not say what it means to be monomorphic. 
08:15:11 <Cale> I normally think of monomorphic as "completely specified"
08:15:26 <Cale> So you could have monomorphic types
08:15:32 <goron> Cale: I would say Int is monomorphic. 
08:15:42 <Cale> And I'd say you're right :)
08:15:53 <goron> Cale: But how can something "variable" can be monomorphic?
08:16:34 <Cale> Could you give an example of a type variable considered to be monomorphic by him?
08:16:49 <kosmikus> there's a difference between something which can be many things (polymorphic, universally quantified variables) and something which is one thing but you don't know what it is (free variable)
08:16:51 <goron> Cale: No, that's the problem. 
08:17:12 <goron> kosmikus: UU is here :)
08:17:28 <Cale> ah, is that the distinction. I haven't picked up all the language regarding types. I should do that at some point.
08:18:15 <goron> kosmikus: Do you mean that you don't know what something is at a particular point in time, or that you can not kwow what it's type is?
08:18:35 <kosmikus> a type variable that is introduced for a lambda-bound variable during type inference is "monomorphic" in the sense that it can only be instantiated once
08:18:39 <Cale> goron: you see, the x in the type of i in the "in" part of the let is allowed to be different things in each instance
08:19:17 <Cale> the a in the type of i, which is of type a -> a rather :)
08:19:29 <Cale> let's keep the variables separate :)
08:19:56 <Cale> the "let" gives you this kind of abstraction
08:20:05 <Cale> Note that if you wrote
08:20:09 <Cale> (\x -> x) 5
08:20:37 <Cale> the (\x -> x) in some sense has type a -> a, but we know that a must be int, and it can't be anything else.
08:20:56 <kosmikus> one important thing to notice is that *any* type variable that can actually be seen by the programmer, i.e., that appear in a Haskell 98 type expression, is universally quantified, and thus polymorphic
08:21:04 <Cale> (The Num class notwithstanding)
08:21:55 <kosmikus> "monomorphic" type variables are an implementation detail of the type inference process
08:23:24 * esap wouldn't call monomorphic type variables an implementation detail.
08:23:34 <goron> So when I use a variable that's introduced by a lambda more than once, their types should be the same, while when I would introduce variables(and hence types) in a let, this would not be the case? 
08:23:50 <Cale> yeah
08:28:15 <goron> If I understand it correct,  a monomorphic type could also be "polymorphic". For example:
08:28:34 <goron> f = blaat id
08:29:09 <goron> blaat = (\x-> (x 5, x "hi")
08:30:28 <kosmikus> try it, won't work
08:30:39 <goron> So the only difference is a variable introduced by a lambda can be instantiated only once(as said by kosmikus), and in let, they can have more.  
08:30:49 <goron> I forgot a parenthese. 
08:30:56 <kosmikus> even then
08:31:06 <kosmikus> you'd need to give a rank-2 type to blaat
08:31:15 <kosmikus> you can do that in GHC, but it's not Haskell 98
08:31:57 <goron> kosmikus: Ok, I thought I understood it, but obviously I don't. 
08:32:07 <goron> Another example:
08:32:22 <goron> blaat = (\x->(x 3, x 5))
08:32:28 <goron> This should work then?
08:32:34 <kosmikus> yes
08:33:07 <goron> Ok, so instantiate means "instantiate to a concrete (non-polymorphic) type".
08:33:54 <goron> kosmikus: Is this understanding correct? 
08:35:57 <kosmikus> I'd say yes, but there's still a certain vagueness to your phrase, and it could be interpreted falsely
08:38:25 <goron> A concrete type is:Int, Bool, etc. or a function type, or a tuple type. I mean by non-polymorphic that only the herefore mentioned types are present. 
08:41:46 <goron> It seems ghc is being nicer to it's users: It does not say: monomorphism restriction. yadayada. It simply states that the types don't match. 
08:42:35 <kosmikus> the monomorphism restriction is only marginally related to this issue
08:43:08 <kosmikus> it's correct that a lambda-bound variable can only be used monomorphically
08:43:33 <kosmikus> that's why  \x -> (x 5, x "hi") won't work
08:44:22 <kosmikus> however, it is instantiated to a "monorphic type variable" by the compiler, and as long as the body of the function doesn't force it to be a concrete type, it can be generalised later, at a let
08:45:38 <kosmikus> example: id = \x -> x is inferred to have "a -> a"
08:50:27 <goron> So during type inference, in the example above, it would find in some environment that x is of "a->a", and then it's instantiated in the environment, and then passed on. So "a->a" is not available anymore for the (x "hi") (and therefor the error). 
08:52:13 <goron> And this instantiation is valid for all children in the AST. 
09:10:03 * CosmicRay returns.
09:10:40 * CosmicRay copies xerox
09:11:10 * xerox refuses to be copied by a non-xerox machine
09:11:21 <CosmicRay> how did you know it was a canon?
09:11:33 <xerox> I can feel it
09:11:36 <CosmicRay> heh
09:11:44 <xerox> (-;
09:17:58 <xerox> In Haskell, IF is something like a special operator or a function?
09:18:53 <tromp> IF is just like any function
09:19:10 <tromp> with special syntax
09:19:14 <xerox> Great, because Haskell is lazy, right?
09:19:48 <tromp> myif False x y = x
09:20:01 <tromp> oops, myuf True x y = x
09:20:10 <tromp> myif False x y = y
09:21:17 <tromp> myif :: Bool -> a -> a -> a
09:25:53 <tromp> hmm, there is no library function for not.null ?
09:26:32 <xerox> I want partial application in lisp :(
09:26:33 <WilX> Why a a a?
09:26:46 <WilX> Hmm...
09:26:54 <WilX> Never mind.
09:27:07 <xerox> (In an Haskell style, eheh)
09:35:53 <wolfman8k> anyone familiar with fruit?
09:43:14 <wolfman8k> boegel: hey
09:44:47 <magical1> erm can someone help me, or has everyone gone home?
09:46:10 <boegel> hey wolfman8k 
09:46:17 <boegel> magical1: pls repeat your question :)
09:48:39 <magical1> <-- is newbie, I've read the YAHT tutorial, and have a book on the subject, but I'm still lost what should Ido, I have a little experience programming in Java, but thats it...... I want to try creating a game of some description that would use Haskell for AI and run in a console
09:49:05 <wolfman8k> magical1: write a raytracer!!! :D :P
09:49:22 <wolfman8k> magical1: i wrote a raytracer as my first haskell program, worked awesome...
09:49:25 <wolfman8k> http://benny.kramekweb.com/hrayt
09:49:36 <magical1> what is a raytracer?
09:50:30 <boegel> magical1: this is a raytracer: http://studwww.ugent.be/~kehoste/thesisPublic/website/
09:50:58 <boegel> magical1: what's stopping you from creating a game in Haskell ?
09:51:29 <boegel> magical1: where are you from ?
09:51:33 <magical1> I'm not sure how to write in it (not used to recursive stuff)
09:51:36 <magical1> Ireland
09:52:12 <boegel> well, then you should try and find some simple exercises
09:52:16 <boegel> do you know Fibonacci ?
09:52:39 <magical1> Fibonacci Series, or Fibonacci Numbers?
09:53:22 <boegel> numbers
09:53:31 <boegel> so you know the definition ?
09:54:12 <magical1> hummmm it's been a while since I dealt with those .......
09:54:39 <boegel> look for their definition on the net, try it yourself in Haskell for a while, an hour or so
09:54:45 <boegel> and then look on the net for solutions in Haskell
09:55:01 <boegel> you'll find a lot of them, and maybe that's a good place to start...
09:55:05 <magical1> okay
09:57:12 <magical1> 0,1,1,2,3,5,8,13,21 ........... you add the new one to the previouse one to get the next number in the sequence no?
09:58:49 <TFK> That's the series, I believe
09:59:25 <magical1> so I will need a base case for the first one which is to the base zero, and then a case that applies to every one there after .....
10:02:29 <boegel> magical1: right
10:02:54 <shapr> d00d
10:02:55 <boegel> you should be able to do this with your tuts
10:03:01 <boegel> y0
10:03:08 <magical1> sorry boegel, is the algorithm to compute the nth number in the Fibonacci Series or to produce a list of fibonacci numbers from one up to n? 
10:03:19 <boegel> magical1: choose :)
10:03:32 <magical1> sorry I meant zero up to n
10:03:34 <boegel> maybe you can try both
10:03:37 <magical1> okay
10:03:55 <boegel> but you should really try some stuff to ask some stuff in a certain direction
10:03:58 <boegel> I have to go now
10:04:03 <shapr> wolfman8k: wxFruit r0xx!
10:04:13 <magical1> I have no idea how to handle input and output, but I'll have a go
10:04:17 <wolfman8k> shapr: i have a question about the design of the original fruit
10:04:45 <shapr> er, dunno if I can help you, but I'll try.
10:04:52 * Lemmih wonders why shapr has ops.
10:05:14 <shapr> because roybattius nearly got kicked
10:05:23 <wolfman8k> shapr: if i remember correctly then Signal a = time -> a, right?
10:05:29 --- mode: shapr set -o shapr
10:05:58 <shapr> wolfman8k: I'm not sure. I remember the Yampa definition of that.
10:06:09 <shapr> it's more like a series of time -> a
10:06:38 <wolfman8k> shapr: ok, the question is, why is time a continuous gradient(real number) instead of discrete steps(integer) ?
10:06:55 <wolfman8k> it seems that in a gui environment you would want to update the gui in discrete steps
10:06:56 <shapr> For yampa, it is discrete.
10:07:20 <shapr> John Hughes recently tried to make a system that works with continuous time, and it had a lot of problems.
10:07:24 <wolfman8k> i think that internally it's discrete in fruit too, but why not have the Signal function explicitly discrete?
10:07:32 <shapr> I don't remember whether Fruit uses that or not.
10:07:38 <shapr> How so explicitly discrete?
10:07:47 <TFK> err, is there something I need to do in hugs for it to evaluate code? I have the 'Prelude>' prompt and it complains about examples from the tutorial.
10:08:03 <shapr> How would the type signature be different for discrete or continuous time?
10:08:22 <shapr> I would think they would look the same. For each time that is put in, you get a signal back out.
10:08:25 <WilX> TFK, put it into a file and load it using :l 
10:08:27 <sorje_> TFK, don't try to declare stuff ;-)
10:08:45 <TFK> Ah, but isn't the point of the interperter is that I don't load files?
10:08:57 <shapr> wolfman8k: I haven't read that much about Fruit lately, so I may be missing some stuff.
10:09:00 <TFK> Well... I'm trying to tell it that fib 0 = 1
10:09:08 <TFK> That should work, according to the tutorial
10:09:09 <wolfman8k> shapr: hm..
10:09:30 <shapr> wolfman8k: I do think wxFruit is the future of GUIs, in both theory and practice :-)
10:09:41 <araujo> mmm...
10:09:46 <wolfman8k> shapr: i want to write my own fruit-like gui :D
10:09:49 <sorje_> TFK, try foldr (+) 0 [1,2,3]
10:09:49 <araujo> shapr, what's that?
10:10:07 <wolfman8k> shapr: but i don't know where to start
10:10:07 <shapr> wolfman8k: sounds awesome
10:10:13 <shapr> do you understand arrows?
10:10:17 <TFK> sorje_, that looks cryptic. Should I just read on the tutorial, then?
10:10:20 <wolfman8k> sort of i guess
10:10:31 <shapr> Have you read up on Yampa? Have you read Antony Courtney's wxFruit PhD thesis?
10:10:33 <sorje_> TFK, paste it into hugs and press enter ;-9
10:10:38 <wolfman8k> yes and yes
10:10:43 <shapr> Have you looked at O'Haskell and Fudgets?
10:10:43 <wolfman8k> but i need to read them still a few more times :)
10:10:48 <wolfman8k> yes and yes
10:10:52 <wolfman8k> need to read those still a few more times :)
10:10:52 <shapr> I'm impressed :-)
10:11:06 <wolfman8k> each time i read these articles i understand a little bit more
10:11:06 <TFK> sorje_, yay, that works. But why doesn't the other thing?
10:11:12 <shapr> same for me!
10:11:16 <wolfman8k> the knowledge is slowly seeping in
10:11:19 <araujo> hello?!
10:11:21 <shapr> hiya araujo
10:11:27 <wolfman8k> but i need some hands on experience now to really get it
10:11:32 <araujo> :-P
10:11:36 <sorje_> TFK, hugs only wants "expressions" they say
10:11:38 <shapr> can you build and run wxFruit?
10:11:42 <wolfman8k> haven't tried
10:11:49 <shapr> sounds like a good next step?
10:11:54 <wolfman8k> yep =]
10:11:58 <TFK> sorje_, I thought everything in Haskell is an expression?
10:12:16 <shapr> Also, you may want to read the archives of the Yampa mailing list, and look at other applications of arrows.
10:13:02 <wolfman8k> i think i sort of understand arrows when i see them layed out graphically, but i don't get the do proc syntax
10:13:25 <shapr> Have you looked at Ross Paterson's arrow examples that come with GHC as tests?
10:13:37 <Excedrin> shapr: do people use O'Haskell?
10:13:38 <wolfman8k> don't think so
10:13:48 <shapr> Excedrin: no, not really.
10:13:55 <shapr> Excedrin: not that I'm the expert...
10:14:53 <shapr> At least, I have only seen one or two people show up here who were actually using O'Haskell for anything.
10:15:11 <shapr> iirc, O'Haskell is a modified Hugs interpreter, so it's not very fast.
10:15:38 <WilX> Hmm, I remember that when I once looked at it it was confusing.
10:15:44 <wolfman8k> hm... i think i actually didn't read about O'Haskell. i read this other paper where they build an OOP system using regular haskell
10:15:52 <WilX> Like...it didn't make any sense to me at all :)
10:15:58 <shapr> Excedrin: Are you new here? Learning Haskell?
10:16:21 <shapr> Yeah, the OOHaskell paper beat out most of the good points of O'Haskell
10:16:40 <shapr> The other good point of O'Haskell was 'objects that run in their own thread'
10:16:54 <araujo> Interesting.
10:16:58 <shapr> That's why Dave Menendez suggested OOHaskell + Yampa as a complete O'Haskell replacement.
10:17:04 <shapr> I totally agree with him.
10:17:51 <wolfman8k> the cool thing i like about OOHaskell is that you make your own custom OOP system that fits your needs better. you aren't stuck with some language designer's fixed philoshophy
10:18:00 <Excedrin> shapr: yes
10:18:02 <shapr> Yeah, it rocks.
10:18:11 <shapr> Excedrin: cool, any questions? Anything I can help you with?
10:18:31 <Excedrin> not really, thanks for being so helpful though
10:18:42 <shapr> Sure, feel free to ask if you find some questions.
10:18:53 <shapr> I wonder if Dave Menendez shows up here.
10:19:00 <shapr> I'll send him an email...
10:19:53 <shapr> wolfman8k: I've really wanted to use Yampa in an RTS game. I think it could handle ten thousand units each being their own arrow.
10:20:03 <wolfman8k> sweet!
10:20:13 <shapr> I've wondered whether you could use wxFruit to give them each their own GUI also.
10:20:18 <wolfman8k> the thing i don't get about yambda though
10:20:24 <wolfman8k> er yampa
10:20:48 <wolfman8k> is that your robot brain is meant to run on a real robot computer, right?
10:21:42 <shapr> y0 edwinb 
10:21:49 <shapr> wolfman8k: I think you're mixing parts.
10:22:15 <wolfman8k> that may be the case, if so then i am talking about the robot brain part of yampa :)
10:22:24 <edwinb> hello
10:23:42 <magical1> how do I clear the garbage?
10:24:16 <magical1> ERROR - Garbage collection fails to reclaim sufficient space
10:28:42 <shapr> ohh, nice hostname.
10:29:07 <shapr> wolfman8k: sorry, I got distracted... pre-Yampa was the robot soccer demo. 
10:29:25 <SyntaxNinja> howdy
10:29:26 <shapr> That was more a demonstration of functional reactive programming
10:29:32 <wolfman8k> right
10:30:02 <Lemmih> Greetings, SyntaxNinja.
10:30:05 <shapr> Hudak et al did make a hacked up flavor of Haskell that runs on real robot brains.
10:30:06 <wolfman8k> well, the thing is, you write your robot brain in a way that doesn't require you to think in terms of the internal loop that runs the robot brain. or something
10:30:32 <shapr> But it's not that close to Haskell as we know it.
10:30:55 <wolfman8k> right
10:31:19 <wolfman8k> anyway, my point is that your haskell code is sort of abstracted too far from the hardware. or something
10:31:24 <SyntaxNinja> hi Lemmih
10:31:28 <SyntaxNinja> shapr: how's life?
10:31:34 <shapr> life is good!
10:32:02 <shapr> Have you seen the Yampa space invaders game?
10:32:11 <shapr> I still need to apply SyntaxNinja's patch to that game.
10:32:30 <SyntaxNinja> it used to be a game... now it's a battle!
10:32:34 <wolfman8k> hm... i think i might have seem it
10:32:45 <wolfman8k> maybe i will write a game in haskell
10:32:53 <wolfman8k> i'm thinking of porting ODE library(http://ode.org) to haskell
10:32:59 <wolfman8k> it might be fun :)
10:36:54 <shapr> yeah, that would be neat
10:37:18 <wolfman8k> you know ode?
10:37:34 <shapr> Since you mentioned on #icculus.org, yes.
10:38:08 <CosmicRay> magical1: ok, so you're needing some help getting started with your code?
10:38:12 <wolfman8k> hm... what's #icculus.org to you? :)
10:38:21 <wolfman8k> CosmicRay: hi! where is mega?
10:38:31 <CosmicRay> wolfman8k: a commented out perl line? :-)
10:38:34 <CosmicRay> wolfman8k: ah oops!
10:38:36 <magical1> yeah I was just trying fibonacci numbers as someone suggested
10:38:48 <CosmicRay> magical1: as a first experiment, you mean?
10:38:57 <magical1> yeah
10:39:04 <CosmicRay> ok.
10:39:08 <shapr> wolfman8k: it's where I first met you, remember?
10:39:12 <magical1> someone in here suggested it
10:39:13 <CosmicRay> do you have a working ghc or hugs on your box/
10:39:14 <MegaMonad> Heffalump : be welcome, oh thou big lump elephant-like thing.
10:39:18 <wolfman8k> shapr: hm....
10:39:20 <magical1> hugs
10:39:24 <CosmicRay> super.
10:39:30 <wolfman8k> shapr: don't remember, what were you doing there?
10:39:32 * wolfman8k checks logs
10:39:33 <CosmicRay> magical1: where are you stuck?
10:39:37 <magical1> :)
10:39:55 <shapr> I was hanging around complaining about America's Army, railroad tycoon II, and that sort of stuff.
10:40:06 <shapr> I've been there off and on for a long time.
10:40:08 <CosmicRay> complaining about RT2!  treason!
10:40:21 <wolfman8k> hm... my #icculus.org log is gone. i must have deleted it since i'm low on disk lately :(
10:40:22 <shapr> Yeah, I was complaining that they hadn't ported RT3!!
10:40:24 <Lemmih> wolfman8k: Do you plan to write the binding by hand or use a preprocessor?
10:40:27 <CosmicRay> I will transport my troops to your station, sir, and be off with you!
10:40:32 <wolfman8k> Lemmih: i plan on doing a complete port
10:40:33 <CosmicRay> shapr: ahh.  well then, that's OK :-0
10:40:35 <magical1> well I'm tyring to come up with a simple game like maybe tic tac toe or connect4 or something like that, I wrote High Low last night
10:40:42 <SyntaxNinja> howdy CosmicRay
10:40:46 <wolfman8k> shapr: what did i say? :)
10:41:01 <CosmicRay> magical1: I'm confused... are you writing a fibonnaci-based game?
10:41:08 <CosmicRay> SyntaxNinja: good afternoon
10:41:17 <CosmicRay> SyntaxNinja: fwiw the new haskell-devscripts is up
10:41:25 <shapr> wolfman8k: you said, "I'm working on a game. I'm using ODE, OGRE .." and you said some other stuff. And I made a bunch of smart-ass comments about software testing and Haskell around the same time.
10:41:32 <magical1> no no , someone in here suggested I should look at fibonacci numbers as a startin gpoint
10:41:37 <SyntaxNinja> CosmicRay: cool!
10:41:40 <Lemmih> wolfman8k: I don't understand how that answers my question.
10:41:42 <wolfman8k> shapr: hm.. must have been years ago
10:41:45 <CosmicRay> SyntaxNinja: do you have an updated proposal page covering the new syntax of the file formerly known as Setup.description? :-)
10:41:48 <CosmicRay> magical1: ok.
10:41:55 <shapr> wolfman8k: seven months maybe?
10:41:59 <CosmicRay> magical1: so you are trying to write a fibonacci number calculator?
10:42:01 <wolfman8k> shapr: perhaps
10:42:03 <magical1> my project has nothing to do with fibonacci numbers
10:42:06 <CosmicRay> ok
10:42:12 <SyntaxNinja> CosmicRay: no, I'm going to write the documentation Real Soon Now
10:42:18 <wolfman8k> Lemmih: i will code my own version of ode in haskell and i will use ode's source as a reference
10:42:19 <SyntaxNinja> and scrap the "proposal" format
10:42:19 <CosmicRay> SyntaxNinja: excellent.
10:42:37 <CosmicRay> I don't care what format it is, as long as it's not Word :-)
10:42:42 <shapr> wolfman8k: wow, that would rock. ODE done with Yampa?
10:42:45 <Lemmih> wolfman8k: Oh.
10:42:50 <SyntaxNinja> CosmicRay: you have nothing to worry about there
10:42:51 <CosmicRay> magical1: so you need help starting your fib program?
10:42:55 <CosmicRay> SyntaxNinja: I know :-)
10:42:58 <magical1> no
10:43:10 <wolfman8k> shapr: can i ask you some questions about design?
10:43:14 <magical1> I need help starting my game 
10:43:18 <shapr> Sure, I'll try to help.
10:43:21 <CosmicRay> magical1: ah.
10:43:23 <CosmicRay> magical1: sorry.
10:43:43 <magical1> I thought for connect4 I could use a BitBoard = Word64
10:43:48 <shapr> But I think you'll learn more if you dissect the Yampa Space Invaders example.
10:44:00 <wolfman8k> ok, well, the way ode works is: you make a world, you insert some bodies into it. you step the world inside a loop where you also apply forces and stuff and you also pull the results out of ode for rendering/logging/whatever
10:44:13 <SyntaxNinja> and dissecting yampa space invaders might help you get a job sometime ;)
10:44:14 <wolfman8k> well, i'm thinking that a haskell ode would basicly just have a function
10:44:18 <CosmicRay> magical1: would a 2-dimensional array be easier?
10:44:23 <magical1> that should easily give me a 7*6 grid to work off of
10:44:29 <wolfman8k> worldStep :: [Body] -> [Body]
10:44:46 <shapr> wolfman8k: whoa wait! You gotta read the Yampa papers.
10:44:46 <wolfman8k> actually, worldStep :: [Body] -> Double -> [Body]
10:44:48 <CosmicRay> magical1: there are Bit functions in Data.Bits but it's probably not the easiest way to go
10:45:00 <CosmicRay> magical1: so any spot could have three states, right?  Empty, red, or yellow?
10:45:10 <wolfman8k> shapr: thing is, i feel that it's necessary for there to be an explicit "step" function
10:45:10 <magical1> yeah
10:45:11 <shapr> You know Yampa doesn't let you access the signals directly, right?
10:45:17 <shapr> Why an explicit function?
10:45:31 <CosmicRay> magical1: that would be difficult to represent in a bit array, since a bit would represent only two states
10:45:41 <CosmicRay> magical1: you have at least three options.
10:46:15 <shapr> Yampa only gives you signal transformers. That way you don't end up with space or time leaks that are problems with Yampa itself.
10:46:17 <wolfman8k> shapr: if i were making a game-of-life program then i would have a funtion, step :: [Grid] -> [Grid]. stepping a physics simulation is the same as stepping game-of-life i feel :)
10:46:49 <shapr> But you could instead write a transition,  and have the framework do the stepping.
10:47:06 <wolfman8k> can't you build a framework on top of this step function?
10:47:42 <shapr> Probably so, but I think the yampa framework already does a lot of what you want.
10:47:57 <wolfman8k> i guess i should read about yampa a few more times
10:48:28 <shapr> Try hacking the Yampa Space Invaders source. Add more aliens, add teamwork to the aliens, add obstacles...
10:48:41 <wolfman8k> ok! thanks!
10:48:53 <wolfman8k> brb
10:48:53 <shapr> alien teamwork wouldn't be too hard to do, and it would give you lotsa geek points.
10:50:10 <shapr> SyntaxNinja: oh hey! David Roundy is interested in Patches as arrows, I think it'll fix a lot of the complexity probs with darcs.
10:50:41 <shapr> Now I just gotta find time to code up a prototype.
10:51:45 <shapr> wolfman8k: I think a game of life expressed as arrows is a neat idea, I may have to try that.
10:52:38 <wolfman8k> hm...
10:52:45 <wolfman8k> too many things to do not enough time
10:52:53 <shapr> yeah, totally.
10:53:07 <wolfman8k> and i was hoping to go to sleep early tonight :\
10:53:14 * shapr laughs
10:55:48 <wolfman8k> shapr: ok, let's say i go with the yampa way, there's still the issue of what sort of datatype to use for the world and bodies and joints
10:56:23 <CosmicRay> wolfman8k: going to sleep early rarely works in my experience.
10:56:34 <shapr> "The Yampa Arcade" paper is more a tutorial for designing your own Yampa programs than anything else. It will answer most of your questions.
10:56:41 <CosmicRay> I was going to do that last night, then I got caught up in Alpha Centauri
10:56:44 * wolfman8k searches
10:56:59 <wolfman8k> that's why i run GNU: no games :D
10:56:59 <shapr> Heffalump: you missed MegaMonad's greeting.
10:57:13 <CosmicRay> <MegaMonad> Heffalump : be welcome, oh thou big lump elephant-like thing.
10:57:49 <CosmicRay> wolfman8k: yeah
10:58:07 <CosmicRay> wolfman8k: that's why I have only one machine that has any redmond operating systems on it
10:58:31 <CosmicRay> wolfman8k: and I make sure it can't get on the internet, because I don't trust it to do so safely
10:58:38 <shapr> smart
10:58:41 <wolfman8k> shapr: hm.. i think i read that paper
10:58:55 <shapr> So, follow the steps in the paper for designing ODE
10:58:56 * wolfman8k just has a gameboy advance :)
10:59:05 <wolfman8k> shapr: ok will do man thanks
10:59:15 <wolfman8k> but there is still the issue of how the data should be stored
10:59:21 <shapr> That's described in the paper.
10:59:32 <wolfman8k> i mean in the specific case of ode
11:00:18 <wolfman8k> a world is a collection of bodies and joints, and each joint is connected to 1 or 2 bodies
11:00:43 <shapr> Right, an arrow is a collection of data and transitions
11:01:06 <wolfman8k> ok this is where my head starts to hurt
11:01:09 <shapr> Actually, that was a bad description.
11:02:23 <shapr> Do you have the paper open in front of you?
11:02:53 <wolfman8k> yeah, i'm reading it
11:02:59 <wolfman8k> "gentle taunting" =D
11:03:22 <Heffalump> :-)
11:03:22 <shapr> section 4 is the important part
11:03:24 <Heffalump> how'd I miss it?
11:03:27 <Heffalump> if it was welcoming me
11:03:59 * Heffalump grumbles at John Gill for making CGI.lhs less functional when turning it into Network.CGI
11:04:21 <CosmicRay> heh
11:04:30 * CosmicRay grumbles at System.Time
11:04:40 <CosmicRay> festering piece of .... java.
11:04:46 <shapr> ouch!
11:04:53 <CosmicRay> that's a Haskeller's insult :-)
11:05:06 <shapr> vicious too
11:05:34 <SyntaxNinja> CosmicRay: did you see the recent thread about Time on libraries@?
11:06:01 <CosmicRay> SyntaxNinja: I don't think so, I don't follow that list very close
11:06:29 <shapr> wolfman8k: section 4 describes the data and model for simpleGun. if you follow that process you can get the same data and models for ODE-type entities.
11:06:30 <CosmicRay> SyntaxNinja: Simon keeps telling me to use TimeExts.   I think though that the best that can be said for it is that "it's less crappy than timeDiff" :-)
11:06:39 <Heffalump> if I want to override Network.CGI with my own version, but still use the package it's in (network), is there a reliable way to do that?
11:06:41 <CosmicRay> though I think Simon knows this
11:06:51 <CosmicRay> Heffalump: name yours Heffalump.CIG?
11:06:54 <CosmicRay> err CGI
11:07:17 <wolfman8k> shapr: ok reading...
11:07:54 <shapr> Heffalump: hey! I think I can use arrows both for the TCP/IP stack I described before, and for darcs Patch type to speed it up.
11:08:15 <SyntaxNinja> CosmicRay: the first article in the tread is a nice summary of all the problems.
11:08:18 <Heffalump> well, the hope would be that I could get the change accepted into the original Network.CGI.
11:08:23 <CosmicRay> shapr: an arrows-based TCP stack?  Problem is, I don't know enough to know if that's evil or cool :-)
11:08:23 <SyntaxNinja> this was from like a week ago
11:08:33 <Heffalump> so then I could just stop using the overriding one by removing it from the build
11:08:34 <shapr> CosmicRay: both, I think.
11:08:35 <CosmicRay> SyntaxNinja: checking...
11:08:38 <CosmicRay> shapr: heh
11:08:43 <Heffalump> shapr: my initial reaction is that you're cracked in the head, but feel free to explain..
11:08:58 <shapr> You had that reaction the last time I told you this. So I've been reading a bit...
11:08:59 <CosmicRay> Heffalump: ssh, unicycle acident.  he's sensitive about it.
11:09:01 * shapr laughs
11:09:16 <Heffalump> shapr: s/is that/is still that/ :-p
11:09:30 <SyntaxNinja> a very good article, really about the Time issues: http://www.haskell.org//pipermail/libraries/2005-January/002908.html
11:09:43 <CosmicRay> ho I remember this thread.
11:09:49 <shapr> The dynamic collection arrows will let you use the same arrow for input and output, so my proposed TCP/IP layer design would be workable.
11:09:58 <CosmicRay> most of it devolved in to arguments about leap seconds
11:10:03 <SyntaxNinja> no, this is a new thread
11:10:07 <CosmicRay> oh.
11:10:09 * CosmicRay keeps reading then
11:10:13 <Heffalump> I can't actually remember the original suggestion, so you'll have to start from scratch.
11:10:20 <Igloo> How did CGI regress?
11:10:23 <Heffalump> or point me at logs. I'm too lazy to search for myself.
11:10:36 <SyntaxNinja> although I just leaped a second, hope you don't mind.
11:11:40 <Heffalump> CGI> :t wrapper
11:11:41 <Heffalump> wrapper :: Show a => ([(Name,Value)] -> IO a) -> IO ()
11:11:45 <Heffalump> Network.CGI> :t wrapper
11:11:45 <Heffalump> wrapper :: ([(String,String)] -> IO Html) -> IO ()
11:11:58 <shapr> something like "in = udp >> tcp >> smtp; out = smtp >> tcp >> udp"
11:12:17 <shapr> It could work because the Yampa dynamic collections would allow the same arrows to keep state that way.
11:12:19 <Heffalump> where >> is actually >>> or whatever the arrow sequencing operator is?
11:12:25 <shapr> yeah, that one
11:12:40 <Heffalump> what is a Yampa dynamic collection?
11:12:49 <Heffalump> and is this arrow going to embed IO somehow?
11:13:49 <shapr> a Yampa dynamic collection is a flavor of arrow that has several pieces: a bunch of arrows that it holds, a function to tell it when to switch to another collection, and a function to change the collection
11:14:43 <Heffalump> and what is it useful for?
11:15:11 <Heffalump> and what are the types of udp, tcp and smtp?
11:15:20 <shapr> some sensible arrow type :-)
11:15:25 <shapr> I don't know exactly
11:15:31 <Heffalump> be precise, or I shall continue to believe you are cracked in the head :-p
11:15:36 <shapr> heh fair enough
11:15:52 <shapr> I suspect that precision will require a prototype.
11:16:05 <Heffalump> (giving types would both make the idea concrete and discussable, and make it obvious if it makes no sense at all)
11:16:07 <shapr> But I'm now thoroughly convinced that it'll work.
11:16:21 <Heffalump> and how would it make darcs patches better?
11:16:29 <shapr> it would speed up comparisons.
11:16:44 <shapr> First you'd be able to group patches into chunks that could be commuted themselves.
11:17:22 <shapr> For example, if half the patches you want to commute don't affect a certain file, they obviously commute with a patch that does affect that file.
11:17:44 <Heffalump> what does that have to do with arrows?
11:17:47 <shapr> Since you can regroup patch arrows like that according to any criteria, you'd be able to speed up comparisons.
11:18:44 <shapr> It's a straightforward derivative of the efficient pre-checking arrow-style parsers that John Hughes talked about.
11:19:06 <Heffalump> what pre-checking is being done here? What is the static data?
11:19:23 <shapr> Patch properties that might cause a collision, or disallow commutation.
11:19:57 <Heffalump> how are those known statically?
11:20:12 <shapr> They're part of the arrow when you construct it from a patch.
11:20:22 <Heffalump> the point about a parser is that there are two inputs to a combinator library; the grammar (bunch of combinators) which is known at one stage, and the actual input, which is known later.
11:20:26 <shapr> Just like the parser arrows statically export what they can parse.
11:20:48 <Heffalump> ok, if the patch is the static input, what's the dynamic input?
11:21:00 <shapr> ?
11:21:12 <shapr> What to commute where?
11:21:32 * Heffalump gives up and asks for types again
11:21:43 <wolfman8k> shapr: i am slowly starting to understand
11:21:47 <shapr> wolfman8k: yay!
11:21:58 <wolfman8k> this stuff would make a totally killer game engine design
11:22:00 <shapr> Heffalump: what slows down darcs?
11:22:06 <shapr> wolfman8k: yes I think so too!
11:22:33 <shapr> afaik, it's repeated recursive checks.
11:23:13 <Heffalump> if you can provide a clear explanation of what the precise problem is, or a link to one, I'd love to hear it
11:23:27 <shapr> you can beat that by turning a patch type into something that can be collected together with other values of that type such that many of the properties are statically exported. Then you don't have to do those comparisons.
11:23:38 <Heffalump> give me types ;-)
11:23:59 <shapr> I don't have types :-) But I did tell David I'd write up a prototype.
11:24:37 <shapr> I'll get back to you then!
11:25:10 <Heffalump> how about that explanation?
11:25:33 <shapr> About the darcs complexity problem?
11:26:52 <Heffalump> yes
11:27:11 <shapr> Here's part of what David said when I suggested Patches as arrows - http://www.scannedinavian.org/~shae/david.email
11:27:34 <shapr> 'group patches together according to their coarse-grained commutation behavior'
11:28:42 <Heffalump> so he's suggesting an algorithm change, essentially.
11:28:58 <Heffalump> I thought the merging problem was exponential.
11:29:52 <shapr> patch arrows values would combine to give new patch arrows that have all the properties of the original patches. Then it's faster to commute them.
11:30:17 * arjanb wants to see real code instead of silver arrows flying around shapr head ;-)
11:30:21 * shapr grins
11:31:42 <Heffalump> it's clear that some kind of summary or aggregation information is required, but why are arrows the right way to express that?
11:32:22 <shapr> They may not be, but they sure make it easy to express that.
11:32:50 <shapr> And they're easily extensible to other info later.
11:32:56 <Heffalump> show me the types! :-)
11:33:13 <shapr> Also, they're the same sort of 'automatic' that monads are.
11:33:48 <shapr> As soon as I have them, I will.
11:33:54 <shapr> But it won't be today.
11:37:27 <Igloo> David's mail is assuming a patch comparison is O(1) I think
11:37:49 <CosmicRay> SyntaxNinja: what is the new way of stating either: 1) every executable listed in this cabal file depends on a particular package, or 2) this particular executable needs to be built with -package foo
11:37:53 <Igloo> And normally(nlogn), not O(nlogn)
11:38:03 <Heffalump> how would it not being O(1) make O(n^2) into O(e^n) ?
11:38:48 <Igloo> It's O(e^n). If it was O(1) then sorting would be O(n^2), but could normally be O(n log n)
11:39:16 * Igloo could be wrong - hard to tell without more context  :-)
11:39:25 <Heffalump> that email is about sorting, not commutation stuff?
11:39:45 <Igloo> I suspect so. Sorting involves commutation, of course.
11:40:11 <Heffalump> ah, ok.
11:40:21 <Heffalump> what is the aim of the sorting?
11:41:13 <Igloo> When prompting for changes to be recorded you want to do it in a sensible order
11:41:30 <Heffalump> what does that have to do with ordering patches?
11:41:39 <Heffalump> s/ordering/sorting/
11:41:46 <Igloo> Oh, in that case you ought to read them i a sensible order too
11:42:03 <Heffalump> recording changes is just a file-by-file thing, surely.
11:42:12 <Heffalump> with add before contents change before remove
11:42:44 <Igloo> Yeah. I can't remember what sorting is used for now
11:49:12 <shapr> I can put the whole email online if it'll help you.
11:49:20 <Heffalump> yes
11:50:12 <shapr> http://www.scannedinavian.org/~shae/david.email.2
11:50:31 <shapr> I left out the part about wiki admin, where I live in Sweden, and other disconnected stuff :-)
11:52:19 <Heffalump> it definitely seems to be about merging.
11:54:58 <shapr> I'm not convinced I can make the code both arrow-style and comprehensible to those who don't understand arrows.
11:55:37 <shapr> I think I can make it work, but I'm not sure I'll understand it either ;-)
11:56:16 <shapr> Anyway, I gotta do more work. I'd like to hear more of your thoughts on the matter if you have time/interest.
11:57:44 <Heffalump> if I understood the problem properly, I'd be in a better position to comment.
12:02:42 <SyntaxNinja> CosmicRay: the executables and libraries all depend on the same thing and use the same -package flags.
12:03:16 <SyntaxNinja> so just "build-depends"
12:23:44 <CosmicRay> SyntaxNinja: it doesn't seem to be working for the executables
12:24:24 <CosmicRay> ... or maybe it is.
12:24:25 <CosmicRay> hm.
12:24:34 <CosmicRay> I don't know what happened, but I must have fscked something up.
12:24:39 <CosmicRay> it's working now
12:28:57 <SyntaxNinja> heh
12:29:03 <SyntaxNinja> well, if you see a bug, be sure to let me know!
12:29:11 <SyntaxNinja> this version might actually have some verbosity working, fwiw.
12:32:20 * SyntaxNinja lunch &
12:37:43 * Lemmih wonders why he can cast a (void*) to (class&) but not (class&) to a (void*).
12:39:46 <Heffalump> in C++?
12:39:56 <Heffalump> and by class you mean some specific class?
12:39:58 <Lemmih> Yes.
12:40:13 <Lemmih> I mean any class.
12:40:34 <Heffalump> can you caset (class*) to (class&) ?
12:40:38 <Heffalump> s/caset/cast/
12:43:52 <Lemmih> Yes.
12:44:22 <Heffalump> but not vice-versa?
12:44:26 <Heffalump> of course, that's why.
12:44:33 <Heffalump> You're not supposed to be able to do arithmetic with references.
12:44:39 <Heffalump> If you could turn them into pointers, you could.
12:45:39 <Lemmih> lisppaste2: url
12:45:39 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:47:25 <lisppaste2> Lemmih pasted "C++ weirdness" at http://paste.lisp.org/display/5255
12:50:17 <xerox> 'night
12:50:47 <Heffalump> that's not weird, it's refusing to cast a reference to a pointer, and is doing everything else.
12:51:07 <musasabi> Got my own copy of Okasaki yesterday :-)
12:51:08 <Heffalump> both samples are almost certainly not what you intended because you throw away the result of the expression rather than 'return'ing it
12:52:11 <esap> the getRef is an identity function on references.
12:52:37 <esap> or maybe rather a projection to second argument :-)
12:53:00 <esap> (due to the 'this' pointer)
12:54:13 <Heffalump> I also wonder what that code actually means. Does it try to treat the pointer as a Test object and make a reference?
12:54:31 <Heffalump> (rather than making a reference that points to the same Test object that the pointer does)
12:54:42 <Heffalump> I guess it probably does the latter.
12:54:59 <basti_> c is evil.
12:55:40 * esap would like to have a strongly-typed C without the tweaks
12:56:57 <basti_> strongly typed? as in no void pointers?
12:57:26 <basti_> or with JUST void pointers?
12:58:19 <Heffalump> no implicit conversions would be a good start.
12:58:36 <esap> yes, and as in no casts, no implicit unsafe conversions. Void pointers are ok, as long as you are not able to think they're char pointers, you can't think they can't be null, or that you can't cast them to arbitrary pointer types without a proper check that the cast is valid. 
12:58:47 <Lemmih> Erhm. Yes. I've mistakenly omitted the 'return' statement.
12:58:53 <Heffalump> no implicit conversions includes between typedef'd values
12:58:58 <Heffalump> s/values/types/
12:59:07 <Heffalump> lemmih: I suspect that when you put it in neither will compile.
12:59:21 <basti_> you would come up with something different then.
12:59:41 <mflux> esap, add type inferring and a templates and you're set?-)
12:59:52 <mflux> (well, it wouldn't be much like C anymore)
13:00:08 <basti_> actually you could thrash almost everything of C.
13:00:13 <basti_> except maybe the {}
13:00:28 <basti_> or ?:
13:01:02 <esap> Well it's not supposed to be actually C, but something that you can use to do similar low-level things than C, but without danger of breaking the world.
13:01:31 <mflux> now that sounds a lot betteter
13:01:45 <liquidengineer> hello
13:01:58 <liquidengineer> are there any geometry aces here?
13:02:09 <liquidengineer> I'm having a bit of a conceptual problem
13:02:29 <mflux> esap, if it was similar enough to C, it could be compiled to C, thus being automatically very useful..
13:02:37 <mflux> (platform-wise)
13:02:58 <mflux> well, it could be efficiently compiled to C that resembles the original code ;)
13:03:08 <esap> mflux: Yea. I've been thinking of combining that kind of thing with a Haskell-like language (avoiding overlap, of course).
13:03:21 <liquidengineer> I need to represent the eight rigid motions of a plane
13:03:41 <esap> mflux: Of course, target language can be anything, including C :-)
13:03:43 <liquidengineer> which is no problem, except I can only come up with six rigid motions...
13:03:44 <gzl> boy, doing haskell and assembly at the same time really blows.
13:04:14 <esap> gzl: why?
13:04:39 <gzl> because assembly blows, and it's annoying how much harder everything is in it compared to a higher-level language.
13:04:45 <gzl> and i'm writing some of the same routines in both.
13:05:06 <liquidengineer> gzl: is there a reason you have to write in assembly?
13:05:12 <esap> gzl: Well low level things cannot be as easy to use than high-level things.
13:05:24 <gzl> esap, i understand that, but that doesn't make it any less irritating. :)
13:05:31 <esap> gzl: And I think something is wrong if you need to make things twice.
13:05:35 <gzl> liquidengineer: required course.
13:05:54 <gzl> it's not my fault. they're two different courses. the assignments aren't under my control.
13:06:17 * esap suggest make a single program that satisfies the requirements of both courses, then reuse the code :-)
13:07:14 <gzl> the assignments aren't identical, but they both have stuff on futzing around with binary trees
13:07:40 <gzl> liquidengineer: believe me, i wouldn't do it if i didn't have to. :)
13:09:58 <liquidengineer> gzl: I don't suppose you know the eight rigid motions of a plane that don't actually move the plane anywhere
13:10:11 <liquidengineer> I never thought not taking real geometry would be such a pain in CS...
13:10:31 <esap> gzl: ok, binary trees are normally part of a library you get for free anyway. Having to implement them in multiple languages seems like a good way to learn both binary trees and those languages.
13:25:07 <liquidengineer> what assembler are you using, out of curiousity?
13:27:29 <Oejet> Good evening.
13:27:29 * boegel says hello
13:35:34 <Lemmih> Greetings, Oejet,
13:36:05 <Oejet> Greetings, Lemmih.
13:36:34 <Oejet> Lemmih: I am puzzled that you don't know Kaptajn Kaper i Kattegat.
13:38:45 <Lemmih> Where should I have heard of it before?
13:43:35 <gzl> esap: i don't dispute that, i'm just whining about assembly.
13:43:48 <gzl> liquidengineer: a slightly simplified MIPS
13:44:01 <gzl> liquidengineer: what do you mean by "real geometry"?
13:44:17 <Oejet> Hm, it's Danish computer game history.  The first PC game in Danish.
13:45:21 <liquidengineer> gzl: as in real, analytical geometry
13:45:36 <liquidengineer> with proofs and stuff
13:45:57 <liquidengineer> I ended up with this useless computer based geometry course
13:45:59 <gzl> liquidengineer: i was wondering whether you meant differential geometry
13:45:59 <liquidengineer> it's like
13:46:11 <gzl> i'm familiar with proofs :)
13:46:24 <liquidengineer> I never had to do one proof
13:46:25 <liquidengineer> not one
13:46:28 <gzl> that's a shame
13:46:35 <liquidengineer> no rules or theorems, either
13:46:43 <liquidengineer> so basically, I never had real geometry
13:47:15 <gzl> there's a course here in the CS dept on "adv geometric methods in CS" that covers pretty fancy geometry
13:47:32 <gzl> was wondering if you meant stuff like that ("Group Actions, Manifolds, Lie Groups, Lie Algebras, Riemannian Manifolds, with Applications to Computer Vision and Robotics")
13:48:02 <liquidengineer> no
13:48:12 <liquidengineer> I just want to know what the EIGHT rigid motions of a plane are
13:48:43 <SyntaxNinja> CosmicRay: success?
13:49:30 <liquidengineer> I originally guessed (after much research on google as to what rigid motions are): reflect vertical, reflect horiz., rotate 90/180/270/360, translate, and g\lide reflection
13:49:37 <liquidengineer> which is eight
13:49:56 <liquidengineer> except the requirements say the figure isn't supposed to be moved
13:50:34 <gzl> actually, maybe I should take this course
13:51:12 * boegel yawns
13:59:27 <CosmicRay> SyntaxNinja: with cabal?
13:59:46 <CosmicRay> boegel: yeah.  wish it was friday.
13:59:51 <CosmicRay> MegaMonad: yawn.
13:59:52 <MegaMonad> CosmicRay: Pat1(pat2) <--yawn!
14:01:10 <boegel> CosmicRay: it's all the same to me :p
14:01:26 <boegel> but I had a real lousy final today :(
14:05:26 <CosmicRay> is there a haskell interpreter anywhere that is written in haskell?
14:05:30 <CosmicRay> or are they all written in C?
14:05:54 <CosmicRay> (ghc doesn't qualify because it is tied so closely to platform internals)
14:07:46 <tromp> will you settle for a lambda calculus interpreter written in lambda calculus:-?
14:07:47 <Heffalump> I believe the only implementations are ghc, hugs, nhc and maybe hbc.
14:07:55 <Heffalump> so no
14:08:13 <Heffalump> do you want one for a reason, OOI?
14:08:40 <CosmicRay> Heffalump: yes
14:08:54 <CosmicRay> Heffalump: I want a niceish hugs binding to java or python or .net
14:08:59 <CosmicRay> s/hugs/haskell/
14:09:09 <CosmicRay> btw got your e-mail, hope to look at it this evening
14:09:22 <Heffalump> okay, no major rush
14:09:29 <CosmicRay> there is hugs dotnet, but it requires a compiler that can compile C to .net clr
14:09:30 <Heffalump> how would a haskell-in-haskell interpreter help?
14:09:36 <CosmicRay> which exists only with microsoft
14:10:20 <CosmicRay> Heffalump: then I would have to bootstrap only what's necessary to support the interpreter (plus fptools, I guess) in the native language
14:10:42 <Heffalump> why do you think the interpreter would use less than it provided?
14:11:00 <Heffalump> and don't you think the extra layer of overhead would make it intolerably slow?
14:12:08 <CosmicRay> I don't care
14:12:18 <CosmicRay> it would save me quite a bit of time having to write an interpreter from scratch
14:13:58 <Igloo> I'm confused - how would a Haskell interpreter written in Haskell be more useful than one written in C (e.g. hugs)?
14:14:42 <CosmicRay> Perhaps I am confused too :-)
14:14:58 <CosmicRay> one written in C would not help me with something that would be pure Java or Python or .net or whatever
14:15:07 <CosmicRay> I would still have to have a system-dependant component
14:15:35 <Igloo> If you want pure Java you need a Haskell interpreter written in Java
14:15:43 <CosmicRay> right
14:15:55 <Igloo> Otherwise it's more portable to require a C compiler than a Haskell implementation
14:16:07 <CosmicRay> I was hoping I could salvage bits of one written in Haskell.
14:16:11 <CosmicRay> true
14:16:39 <Igloo> UHC might be written in Haskell
14:16:44 <Igloo> Oh, that's the old name
14:17:01 <Igloo> But I've no idea what the new one is
14:17:37 <Heffalump> it doesn't have a backend, does it?
14:17:53 <Igloo> No idea, never looked at it
14:20:15 <CosmicRay> bwahaha http://cs-www.cs.yale.edu/homes/nilsson/HIM/Slides/Swierstra-UHC.pdf
14:20:25 <CosmicRay> the slide on page 16 is titled "For Simon only"
14:24:48 * boegel yawns again
14:25:33 <CosmicRay> MegaMonad: boegel needs caffeine
14:25:34 <MegaMonad> CosmicRay: Then it needs is the same caffeine.
14:25:42 <CosmicRay> MegaMonad: give boegel some coffee.
14:25:43 <MegaMonad> CosmicRay: Coffee on the wiki?
14:25:57 <CosmicRay> MegaMonad: or maybe some mt. dew.
14:25:58 <MegaMonad> CosmicRay: Dew on the integer pairs.
14:26:02 <boegel> CosmicRay: no, I'm not tired (well, not really), but I'm bored
14:26:10 <CosmicRay> boegel: I'm both
14:26:16 <boegel> CosmicRay: yaay
14:26:20 <CosmicRay> :-)
14:26:24 <SyntaxNinja> CosmicRay: I saw him give that talk.
14:26:30 <CosmicRay> SyntaxNinja: heh
14:26:37 <CosmicRay> SyntaxNinja: I hope simon was in the audience -)
14:26:39 <SyntaxNinja> when he said that, simon took his bare feet off the desk in front of him and said, "Oh, I well!! Let me see then!"
14:26:56 <SyntaxNinja> </spj imitation>
14:27:13 <CosmicRay> haha
14:27:41 <SyntaxNinja> I think I've seen at least three talks where the speakers took a little break to address simon directly
14:28:18 <CosmicRay> heh
14:28:26 <boegel> SyntaxNinja: why ? (I don't know Simon)
14:28:58 <boegel> heh, msn messenger is down again
14:29:02 <SyntaxNinja> boegel: he's the author of a lot of GHC, and he's the types guy and such on that project, so if someone thinks that something would be an improvement for GHC, then they'd want to get his attention
14:29:22 <boegel> oh, I see :)
14:29:32 <boegel> and he's always on his bare feet ? :
14:29:34 <SyntaxNinja> I saw an OCaml guy make fun of him for stealing the C-- name, though he claims to have asked for permission
14:29:42 <SyntaxNinja> he wears sandles a lot of the time, and then takes them off
14:30:01 <boegel> SyntaxNinja: probably because his feet are too hot all the time
14:30:07 <boegel> I have the same problem
14:30:17 <SyntaxNinja> the taught me how to punt cambridge style, and Igloo taught me how to punt oxford style
14:30:20 <boegel> in class I always take off my shoes
14:30:34 <boegel> SyntaxNinja: punt ?
14:30:44 <SyntaxNinja> operate a boat with a long poll
14:30:55 <boegel> on the thames ? :)
14:30:55 <Heffalump> Igloo is of course right.
14:31:04 <Heffalump> the Thames is too deep really.
14:31:15 <Heffalump> Cam in Cambridge and Cherwell in Oxford are the traditional places.
14:31:20 <CosmicRay> you brits, always mucking with the language as if you invented it.
14:31:35 <SyntaxNinja> Heffalump:   :)
14:31:40 <SyntaxNinja> and I missed Heffalump during my visit, sadly
14:31:47 <boegel> Heffalump: are you talking about the annual boat race ?
14:31:51 <Heffalump> boegel: no.
14:31:54 <boegel> oh
14:31:57 <CosmicRay> Heffalump: you live in UK?
14:32:01 <Heffalump> punting is using a long pole that you push against the bottom of the river
14:32:05 <Heffalump> CosmicRay: yes
14:32:10 <boegel> I used to go on boat trips on the thames every year with school
14:32:17 * CosmicRay is planning a trip to eu.int for later this year
14:32:19 <Heffalump> boegel: which bit?
14:32:24 <boegel> strangely enough, I learned to drink in the UK, wilst being a minor :)
14:32:25 <CosmicRay> might have to look you up.
14:32:29 <CosmicRay> hope I've read your email by then :-)
14:32:32 <Heffalump> ;-)
14:32:32 <boegel> Heffalump: *uhm
14:32:40 * Heffalump is slumming it in Cambridge at the moment.
14:32:43 <CosmicRay> ah.
14:32:52 <boegel> Heffalump: Oxford, Abington (small town), ..
14:32:56 <Heffalump> and Igloo is in Oxford.
14:32:56 <boegel> Windsor
14:32:56 <CosmicRay> that was one of the places on my "possible places to go" list
14:33:00 <SyntaxNinja> Heffalump: do you still operate the punt from the cambridge side?
14:33:02 <Heffalump> boegel: you sur eyou don't mean Abingdom?
14:33:04 <Heffalump> s/dom/don/
14:33:05 <CosmicRay> Heffalump: that one was also :-)
14:33:08 <SyntaxNinja> er oxford side
14:33:12 <boegel> Heffalump: could be
14:33:16 <boegel> it's a small town
14:33:29 <Heffalump> SyntaxNinja: I've only been punting once in Cambridge and that was before I moved here. And yes, I did then :-)
14:33:34 <Heffalump> boegel: about 5 miles from Oxford?
14:33:34 <boegel> with punk kids running around (potheads, metal heads, ...)
14:33:48 <boegel> Heffalump: no idea, I can't remember anymore
14:34:06 <SyntaxNinja> I gotta go pair, bb later
14:34:08 * SyntaxNinja &
14:34:08 <boegel> but we use to put our boats there at night, so it close to the Thames
14:34:16 <CosmicRay> Heffalump: we were going to only do .de, but my wife wanted to spend at least part of the trip in a place where we can understand the language.
14:34:18 <boegel> bye SyntaxNinja 
14:34:20 <Heffalump> probably Abingdon.
14:34:25 <CosmicRay> Heffalump: then I pointed out how I translate Are You Being Served for her.
14:34:29 <Heffalump> :-)
14:34:38 <boegel> Heffalump: we had quite some fun their
14:34:52 <boegel> we met some guys, looked cool (punk hair, nasty look)
14:34:56 <boegel> we got to know them
14:35:03 <boegel> they showed us a few places in town
14:35:19 <Heffalump> Igloo lives quite close to the Thames, and I used to at one point when I was in Oxford
14:35:33 <boegel> and then we dove into the bushes with them, because the cops were passing along, and they didn't want be arrested for the stuff they stole last night
14:35:38 <boegel> that's when we took off :)
14:35:45 <Heffalump> (it's called the Isis as it goes through Oxford, for reasons I don't entirely know about)
14:36:25 <Heffalump> #haskell UK residents cover at least Cambridge, Oxford and Nottingham
14:36:48 * boegel wants to go back and take a boat trip on the Thames, for old times sake
14:37:06 <boegel> I almost was crushed once when I fell of a boat in a ..
14:37:14 <CosmicRay> boegel: heh
14:37:14 <boegel> damn, how do you called that thing again :)
14:37:37 <boegel> when you have to change level
14:37:43 <boegel> damn, my English really sucks :)
14:38:10 <CosmicRay> boegel: whenever I think of the Thames, I remember the biography I once read of Thomas Crapper, said to be the inventor of the indoor toilet.  There was aparently an incident shortly after the adoptation of indoor plumbing where the queen asked what all the pieces of paper floating down the river were.
14:38:12 <boegel> the thing where your boat is in when the water rises
14:38:37 <boegel> CosmicRay: mwoeha :)
14:38:48 <Heffalump> a lock
14:38:56 <boegel> when we did our trips, the toilets were chemical ones
14:39:03 <boegel> Heffalump: YES, how could i forget that
14:39:04 <boegel> damn
14:39:06 <boegel> I need sleep :)
14:39:13 <boegel> so...
14:39:34 <boegel> I almost got crushed once in a lock, when I fell of the boat partially
14:39:48 <boegel> I was hanging on the front of it, and the wall came dangerously close
14:40:05 <boegel> that was fun :p
14:42:37 <CosmicRay> boegel: apparently the person told the queen that it was just discarded copies of day-old London Times :-)
14:43:14 <boegel> CosmicRay: evil :)
14:43:18 <CosmicRay> hehe
14:43:35 <boegel> hmm, I really loved those times
14:43:59 <boegel> sneaking out of the boat at night to meet some chicks :p
14:52:51 * boegel goes to bed
14:52:55 <boegel> g'night everyone
14:55:38 <CosmicRay> boegel: told ya you need caffeine :-)
14:55:40 <CosmicRay> bah
14:56:05 <basti_> wanna have a laugh? www.students.uni-marburg.de/~Zapf/attempt.ogg
14:57:13 <CosmicRay> what was that?
14:57:50 <basti_> uhm haskore + csound
14:58:01 <basti_> an attempt at fuguality
14:58:12 <CosmicRay> ah
14:58:23 <CosmicRay> cool.
14:58:28 <CosmicRay> I'm going to have to investigate this.
14:58:34 <CosmicRay> csound is a synthesizer?
14:58:57 <basti_> yes
14:59:09 <basti_> its like the LaTeX for music
14:59:15 <basti_> you write a program that makes music
14:59:27 <CosmicRay> hmm.
14:59:38 <CosmicRay> I wonder if I could make it synthesize my lilypond scores.
14:59:49 <basti_> can you output them midi?
15:00:05 <CosmicRay> I don't know, really.  I wrote them all back in 2000 and 2001
15:00:22 <CosmicRay> if I could, that would be good enough for me
15:00:35 <basti_> well csound reads midi readily
15:00:41 <CosmicRay> ah, sweet.
15:00:53 <CosmicRay> anyway, gotta go
15:00:55 <basti_> just needs some tweaks to get non-midi instruments working.
15:00:56 <basti_> k
15:00:56 <CosmicRay> cyall later
15:00:57 <basti_> cu
15:07:52 <stepcut> agh! dpkg-buildpackage failed because I did not have an .orig.tar.gz and the debian maintainer added code to explicitly check for it :(
15:09:53 <Oejet> stepcut: Squashed by the bureaucracy and nitpicking attention of a Debian maintainer.
15:10:29 <stepcut> hehe
15:20:44 * flaw foo
15:21:18 <Lemmih> Bar.
15:21:31 <Oejet> PING
15:30:21 <Lemmih> Tekhne: Satan, eh? (:
15:30:51 <Tekhne> well, of course =]
15:31:11 <Tekhne> i came to #haskell didn't i?
15:32:03 <Tekhne> i want to learn a new language this year... either erlang, lisp, or haskell. which do you think is the best choice and why?
15:32:26 <Tekhne> (i know perl, python, c/c++)
15:32:42 <Lemmih> Haskell, and because I don't know the other two.
15:32:47 <Tekhne> =]
15:32:59 <Tekhne> what do you use haskell for?
15:33:21 <Lemmih> Virtually everything.
15:33:47 <Tekhne> cool. database work, web programming, networking, text processing?
15:34:03 <Lemmih> Yes, yes, yes and yes.
15:34:26 <Tekhne> are the "libraries" available for each fairly stable/mature?
15:35:43 <Lemmih> More or less.
15:36:21 <WilX> Hmm, I would strip Erlang from your list. IIRC it is rather specialised for telcom stuff.
15:36:23 <Heffalump> I use libraries for all those things myself without real problems.
15:36:45 <Heffalump> but I don't think I'd call them completely stable/mature.
15:36:55 <Heffalump> But good enough if you don't want industrial-grade reliability.
15:37:25 <Tekhne> well, i would like to be able to use the language in my regular job (sysadmin)
15:37:37 <Tekhne> so that i can get real-world experience with it
15:37:38 <WilX> With Lisp and Haskell to choose you have to decide whether you want a language with type system or one with none (that I know about).
15:38:03 <Tekhne> the reason i put erlang in the list was because i thought the concurrency stuff sounded cool
15:38:27 <Tekhne> and i'd heard that someone wrote a very nice web server that beat out apache 
15:38:40 <Tekhne> in erlang
15:39:37 <Tekhne> WilX: well, i have enough languages under my belt that i don't "need" anything, i'm just trying to expand my horizons
15:39:51 <Heffalump> do you use c/c++ as a sysadmin?
15:39:57 <Tekhne> yes
15:40:12 <Tekhne> but not a lot these days
15:40:25 <Heffalump> Haskell is generally compiled, but you can use it interpreted too
15:40:35 <Tekhne> ok
15:40:45 <Tekhne> how does the speed compare to say, c?
15:40:52 <Tekhne> compiled
15:41:04 <Excedrin> speed of development is much higher
15:41:11 <WilX> I do not like Lisp because it is just too inconsisten for me.
15:41:11 <Tekhne> ok, that's very cool
15:41:24 <Excedrin> runtime speed is less, but acceptable for most stuff
15:41:40 <Tekhne> WilX: yea, i'm leaning against lisp because i don't want to learn emacs, and because there seems to be too much in the core
15:41:44 <WilX> Maybe Scheme would be a better choice but it is a bit more limited in what the language itself can do.
15:41:54 <WilX> Hehehe.
15:41:58 <WilX> Emacs rocks.
15:42:04 <Excedrin> faster than perl and python at least (is that correct?)
15:42:15 <Tekhne> oh, i'm not saying that emacs is bad or good, i just don't want to have to learn two things at once
15:42:35 <Heffalump> compiled speed is probably 2-4 times slower than C
15:42:40 <Heffalump> depending a lot on the application
15:43:00 <Heffalump> I would expect it to be generally faster than perl or python, but I don't know for sure.
15:43:02 <Tekhne> ok, well that's comparible to lisp i think, and far better than python
15:43:18 <Tekhne> and python is adequate speed for most of my needs
15:43:23 <Tekhne> so that's good
15:43:31 <Heffalump> compilation time is quite high, though
15:43:38 <Tekhne> that's fine
15:43:58 <Tekhne> i'm assuming it gets compiled to binary that i can move around with needing haskell infrastructure, yes?
15:44:08 <Tekhne> like a c program
15:44:14 <Excedrin> I hate to start a bunch of flames, but have you considered ML (ocaml or SML)?
15:44:18 <Heffalump> correct
15:44:27 <Heffalump> though binaries tend to require libgmp
15:44:33 <WilX> Right, Ocaml is good too.
15:44:34 <Tekhne> Excedrin: yes, i looked at ocaml, but was told that haskell had all ocaml's features and more
15:44:37 <WilX> I liked it.
15:44:43 <Excedrin> yes, I'd agree with that
15:44:45 <WilX> The basics I've seen anyway.
15:44:57 <Heffalump> apart from default strict evaluation :-)
15:45:54 <Tekhne> hmm, this is hard. everyone i'm talking to is making good points for each language. it's hard to pick which one.
15:46:30 <Excedrin> Tekhne: I'm in the same boat, sysadmin, used to imperative programming, wanted to learn FP.. I picked up ocaml, then SML, now I'm looking at Haskell (and it's easier because of the time I spent with the other two)
15:46:42 <WilX> Hm.
15:46:43 <Tekhne> sure
15:46:56 <WilX> Haskell is different, strict. pure, lazy.
15:47:08 <WilX> There is no other language like this that I know about.
15:47:16 <Tekhne> what about free learning materials? would you say that haskell has a lot?
15:47:32 <Tekhne> erlang doesn't seem to have a lot
15:47:35 <Tekhne> lisp kind of does
15:47:40 <Excedrin> Clean is similar
15:47:47 <Excedrin> in that it's also lazy and pure
15:47:56 <Excedrin> but I think it's strict by default
15:48:03 <WilX> Clean seamed to be just a flavour of Haskell :)
15:48:28 <Excedrin> Alice is also lazy, but not pure
15:49:07 <Heffalump> Haskell has a few online tutorials, I think.
15:49:33 <Tekhne> hmm, well, if i were to get a book, which one is the best?
15:49:38 <Lemmih> Quite a few, I would say.
15:50:05 <Tekhne> i know there's a free ocaml book out there, which makes me reconsider ocaml, but i'm starting to like the idea of haskell
15:50:16 <Tekhne> if i can find the resources to learn it
15:50:48 <Excedrin> start at the url in the topic
15:50:57 <WilX> ...I was about to say that.
15:51:31 <Tekhne> yea, i was just looking at that
15:52:02 <Tekhne> okay, time to go... thanks for the input... i'll be back
16:08:31 <SyntaxNinja> lalal
16:11:22 <Lemmih> tralalal.
16:50:10 <jadrian> hmm I don't want to get into language wars here, but in my experience, if the haskell program is just about 5x slower then C, it most probably wasn't "developed fast"
16:51:22 <Heffalump> you think 2-4 times is too low, then?
16:51:28 <jadrian> but then again, maybe I just need get experient in the whole optimization techniques
16:51:48 <jadrian> Heffalump: well, I haven't been that lucky
16:51:56 <Heffalump> I have to admit I was guessing wildly.
16:52:22 <jadrian> it's just that problems seem to arise in many places...
16:53:22 <jadrian> for instance Haskell arrays seem dog slow to update, if I remember correctly Manuel Cha. paper on that, he mentioned some like 100x slower?
16:53:28 <jadrian> not saying haskell is 100x slower
16:53:56 <jadrian> just that you end up having to deal with many little problems
16:54:17 <jadrian> if you need fast arrays, I think you're doomed to ST or IO which isn't trivial
16:54:38 <jadrian> as you can see by the mailing list FiniteMap isn't that great 
16:54:54 <Heffalump> but Data.Map is ;-)
16:55:08 <jadrian> someone seems to be complaining about space issues, at least
16:55:17 <jadrian> but yeah I think Data.Map is better
16:55:33 <jadrian> still it's a jump from O(1) to O(log n) right?
16:55:43 <Lemmih> Why isn't arrays in the ST or IO monad trivial?
16:57:14 <jadrian> because you have to change your whole algorithm to live inside those monads...
16:57:59 <jadrian> and resource to monadic libraries to manipulate them
17:01:25 <jadrian> for instance, can you use things like  iterateM  in IO
17:01:34 <jadrian> (that would be a monadic version of iterate)
17:02:28 <jadrian> let a = interate f  array
17:02:52 <jadrian> takeWhile p a 
17:02:54 <jadrian> --
17:03:22 <jadrian> how is this done in with IOArrays?
17:05:33 * Lemmih thinks people with speed fetishes are more common than people with an actual need.
17:05:59 <jadrian> yeap, probably, I haven't need it that much :)
17:06:16 <SyntaxNinja> Lemmih: but the same could be said of most fetishes ;)
17:06:42 * SyntaxNinja tries to wake up Philippa
17:07:04 <Lemmih> haha
17:07:06 <jadrian> SyntaxNinja: just great
17:09:11 <Lemmih> *sob* I'm having serious problems understanding C++.
17:10:13 <Spark> mm fetish
17:15:22 <stepcut> hrm, i think i'll retire from computer engineering and shoot photos for a fetish magazine instead
17:15:42 <shrimpx> speed fetish, tho, right?
17:16:35 <shrimpx> which means you'll just take screenshots of #haskell periodically
17:16:50 <stepcut> well, I was think more like latex or elegant gothic lolitas...
17:19:25 <shrimpx> i can't think of a way to make a LaTeX followup without sounding stupid
17:20:39 <sh10151> shrimpx: everyone has that problem at first
17:42:58 <SyntaxNinja> Lemmih: what's your c++ problem?
17:49:08 <Lemmih> SyntaxNinja: It's apparently possible to define opaque structs and classes.
17:51:45 <SyntaxNinja> what do you mean by opaque?
17:53:04 <Lemmih> 'class CL_Resource_Generic;'
17:53:21 * jadrian hasn't coded C++ in ages...
17:53:31 * Lemmih has never coded C++.
17:54:01 <SyntaxNinja> Lemmih: so you want to declare the class in the .h file or something and implement it in the .cpp file?
17:54:06 <Lemmih> Which is kinda bad since I'm the only developer of Hacanon.
17:54:20 <Lemmih> SyntaxNinja: There is no implementation.
17:55:00 <SyntaxNinja> Lemmih: so do you want it to be abstract so that subclasses have to override it?
17:56:13 <jadrian> My very 1st C++ assignment was to code an address book, and the underlying cointainer should be implemented using generics. The 2nd assignment, was to implemente a Complex Numbers ADT...
17:56:27 <Lemmih> SyntaxNinja: I don't know (: It's not my code.
17:56:45 <jadrian> Don't ask why because I have no freaking idea...
17:57:34 <SyntaxNinja> Lemmih: so there are abstract and virtual classes, you might want to read up on those :)
17:58:31 <Lemmih> Will do.
17:59:04 <SyntaxNinja> but that declaration you pasted doesn't mention either; I have no idea what youre trying to figure out, though.
18:04:24 <jadrian> I really don't understand the way we are supposed to deal with subclassing 
18:04:35 <jadrian> there are 2 ways to do it,
18:04:49 <jadrian> class A a => B a where 
18:04:52 <jadrian> ...
18:04:55 <jadrian> or
18:05:00 <jadrian> class B a where
18:05:18 <jadrian> instance B a => A a where
18:05:27 <jadrian> ...
18:05:38 <jadrian> the 1st is used in Eq and Ord
18:05:50 <jadrian> the 2nd is used in Functor and Monad
18:06:04 <jadrian> ...
18:06:44 <jadrian> They are slightly different, but in many cases both can be used. It all seems to depend on what's easier to define
18:06:49 <jadrian> A from B or B from A
18:07:29 <jadrian> And if there is in deed a generic way to define all Bs from A...
18:08:02 <jadrian> using the 1st might not be great because you might end up having to write more code
18:08:13 <jadrian> with the 2nd you just need to define instances for one of the classes
18:08:39 <jadrian> but the 2nd can lead to some nasty problems
18:08:41 <jadrian> for instance
18:08:58 <jadrian> I realized functions could be Functors with fmap = (.)
18:09:05 <jadrian> I implemented and used that
18:09:46 <jadrian> now if I wanted to use the Reader Monad I'd be in serious trouble because it defined Monad instance for (->) a 
18:10:12 <jadrian> from which a Functor instance is derived too
18:10:23 <jadrian> and instance declarations cannot even be hidden I think
18:11:45 <jadrian> hmm wait
18:12:18 <jadrian> nevermind, maybe I'm talking garbage, because in the source Functor (->) a is defined too... :-/
18:12:26 <jadrian> eh, this means I should go to sleep
18:15:07 <SyntaxNinja> jadrian was marked, then swept.
18:18:18 <Lemmih> Watching Hacanon generate thousands of lines of code gives me a tingling sentation.
18:19:52 <Cale> Lemmih: heh
18:20:49 <Lemmih> Hey shapr.
18:21:11 <shapr> y0
18:21:18 <Cale> how close is Hacanon to being in a release state?
18:22:18 <Cale> Or is it released?
18:23:48 * shapr stares at darcs sources
18:23:49 <Lemmih> Cale: Pretty close. It can correctly handle classes (even with static methods), structs and enums. But you still have to write your own marshalling rules in some cases.
18:24:49 <Lemmih> Cale: And translating strucs to Haskell is currently broken if the struct is templated.
18:25:50 * Lemmih is now working on transparent handling of vectors, lists and arrays.
18:28:18 <Lemmih> 3:30 am! Time for a unicycle break.
18:28:38 <shapr> yay!
18:28:55 <shapr> hey Lemmih, I'm getting a 65mm rim in one or two months!
18:29:17 <Lemmih> You're buying yet another unicycle?
18:29:35 <shapr> Er, no. I'm building a new wheel that's nearly twice as wide as my current wheel.
18:30:00 <shapr> It should perform better on the mounds of soft snow we  have around here.
18:30:00 <Lemmih> And it's fit in your current frame?
18:30:10 <Lemmih> s/it's/it'll/
18:30:12 <shapr> Yup, the Kris Holm Mountain unicycles have lots of room.
18:30:32 <shapr> I've never built a wheel before, it should be interesting.
18:30:42 <shapr> spokes, hub, rim, nipples..
18:31:11 <shapr> Anyway, have fun :-)
18:31:30 <Excedrin> are there lots of unicycle riding Haskell coders?
18:31:45 <shapr> Um, I don't know. At least three.
18:32:02 <Excedrin> just curious
18:32:14 <shapr> That's me at the end of the summer --> http://www.scannedinavian.com/images/uni-hop.jpg
18:34:28 <shapr> y0 Philippa 
18:36:18 <SyntaxNinja> shapr: sweet photo
18:36:28 <shapr> :-)
18:36:57 <shapr> Hey, did you have coffee with more interesting people lately?
18:40:05 <SyntaxNinja> well, I can't say 'no', but no one new in particular
18:40:18 <SyntaxNinja> I have seen Linus twice now, not sure if i mentioned that
18:40:43 <SyntaxNinja> (i think)
18:42:24 <shapr> spiffy!
19:02:26 * Lemmih has returned with a bloody shin.
19:04:40 <Lemmih> Perhaps I would invest in some shinarmor before attempting a unispin again.
19:04:49 <shapr> could be
19:31:47 <shapr> it's oh so quiet...
19:33:15 <SyntaxNinja> sshhhh
19:36:23 <Gahhh> I went to a seminar where Linus spoke
19:42:06 <shapr> What did he say?
19:44:23 <Gahhh> not much
19:44:52 <Gahhh> I dont give a rat's ass about OS' anyway
19:45:41 <shapr> They can be interesting - http://www.cse.ogi.edu/~hallgren/House/
21:48:30 <musasabi> morning
22:04:12 <Gahhh> damn. I can finally write obnoxious looking haskell...
22:23:14 <Gahhh> Whoa, I just witnessed an artifact of ghc not memoizing.
22:44:55 <wolf|z> anyone use yampa?
23:04:46 <wolf|z> i can't get HGL to compile
23:39:06 <vdrab> does anyone know how to increase the heap for a GHCI session? 
23:40:05 <vdrab> I have this one function that runs fine but slows down considerably halfway through, so I think the GC is killing it.
23:40:11 <Lemmih> vdrab: You can check the documentation.
23:40:48 <vdrab> the documentation mentions flags for GHC, but I'm not sure how to transfer that to a GHCI session
23:43:04 <wolf|z> anyone know how to compile HGL? i get
23:43:05 <wolf|z> make[1]: *** No rule to make target `boot'.  Stop
23:45:16 <Itkovian> meuning
