00:02:44 <wli> Continuity requirements for rational splines appear to suck.
00:02:55 <wli> Quadratic equations etc.
00:03:37 <wli> Existence is even questionable.
00:04:11 <wli> I suppose that's not the usual notion of rational spline.
00:18:47 <wli> Looks like the quick and dirty rational spline stuff I cooked up involves solving high-degree Lagrange multiplier equations to boot... better stick to cubic splines which are nice and band diagonal
00:26:56 <musasabi> ,prmomg
00:33:26 <Lemmih> musasabi: You wrote hs-fltk, right?
00:34:19 * Lemmih has a question about representing a const C++ class method in Haskell.
00:34:37 <autrijus> greetings.
00:35:40 <musasabi> Lemmih: yes.
00:36:17 <musasabi> Lemmih: it still needs to be within IO, most of the time :-(
00:38:34 <Lemmih> musasabi: get_front_buffer has two implementation; one prefixed with 'const' and one without. (http://clanlib.org/docs/Reference/html/CL_DisplayWindow__get_front_buffer.html)
00:41:18 <shapr> Lemmih: pong
00:41:21 <Lemmih> Should I just ignore one of the definitions?
00:41:32 <musasabi> Lemmih: if you don't have a constness representation then just use the non-const one.
00:41:34 <shapr> Lemmih: sure, I'd be happy to host a ClanLib binding
00:42:19 <shapr> mmmm! --> http://research.microsoft.com/%7Esimonpj/papers/slpj-book-1987/index.htm
00:43:04 * shapr grabs
00:43:26 <Lemmih> shapr: http://212.242.49.100/repos/haskell/HClanLib
00:46:36 <shapr> Lemmih: done
00:48:17 <Lemmih> Thanks.
00:49:03 <Lemmih> I wonder if it's safe/wise to ignore all const methods.
00:50:38 <musasabi> it really depends on the method.
00:50:44 * shapr hops cheerfully
00:51:03 <musasabi> the non-const versions are usually safe to use but they might be slower.
00:51:24 <musasabi> the const version become unsafe if you discard the constness and mutate them.
00:54:40 <shapr> ooh aah - http://wadler.blogspot.com/
00:55:37 <Gahhh> lol
00:58:18 <shapr> anyway, time for some long distance unicycling...
01:04:33 <SamC_> lol?
01:17:32 <bourbaki> http://img78.exs.cx/img78/5025/unbenannt5xh.jpg
01:36:16 <Lemmih> Gretings Philippa.
01:37:12 <bourbaki> what kind of game would you like better something like lemmings + chuchu rocket
01:37:31 <andersca> shapr: ulf made a video!
01:37:31 <bourbaki> or something like warheads and 2d action game like alien towers
01:37:53 <musasabi> bourbaki: chuchu... Seen Utena?
01:38:07 <Lemmih> bourbaki: MicroMachines.
01:38:25 <bourbaki> musasabi: no got an url handy?
01:38:44 <bourbaki> Lemmih: hm also a good idea i can do that easily on the surface :)
01:38:45 <bourbaki> http://img78.exs.cx/img78/5025/unbenannt5xh.jpg
01:38:51 <bourbaki> the latest shot btw
01:39:05 <musasabi> ok, that was just a character (small monkey used for comic relief) in the series (a japanese animation).
01:39:09 <bourbaki> and its really hypnotic to race over the checkers structure :)
01:39:25 <bourbaki> then no :)
01:40:08 <bourbaki> i think its the logic game though cause then i can get rid of network stuff :)
01:42:46 <bourbaki> and the whole game has to fit on a 3.5" disk :)
01:43:23 <Lemmih> Foo! Arguments of a C++ function can't be used to determine the type of the result /-:
01:44:42 <musasabi> Lemmih: yes, that is quite sad.
01:45:12 <musasabi> Lemmih: this is where my own binding efforts hit a stone.
01:54:58 <Lemmih> Yay. I can model it with typeclasses (-:
01:56:30 <musasabi> class MyFun arg res :: myFun :: arg -> IO res ?
01:58:05 <joao> Hello
01:58:16 <musasabi> hello
01:58:58 <joao> Is it possible to create a function that receives a String (which is the name of a function + arguments, eg. "f 1 2") and then call the function correspondent to that String?
01:59:22 <Lemmih> musasabi: data [object] [template] [const].
01:59:44 <Lemmih> data Const; data NoConst
02:00:35 <TheHunter> joao, no. (You might be able to do that in ghc using hs-plugins, though.)
02:01:16 <Lemmih> class OverloadNew self args result | self args -> result, result args -> self where new :: args -> IO result
02:01:56 <Lemmih> joao: But you can parse functions as variables.
02:02:46 <joao> Lemmih, what do you mean?
02:05:14 <SamC_> joao, see http://www.haskell.org/th/
02:05:23 <Lemmih> func :: (Int -> Int -> Int) -> Int
02:06:47 <joao> Lemmih, how can that help me if I want to do a getLine, read a String, and "execute" the correspondent function? I'm not understanding, sorry
02:06:54 <joao> SamC_, thank you
02:07:04 <joao> I'm taking a look at hs-plugins now :)
02:08:10 <Lemmih> joao: Why would you do that?
02:15:39 <joao> Because I want to do some kind of meta-interpreter which is defined in the same file where the functions I want to execute are. And then, there is a main function which works on state and never ends (unless you quit), in order to get persistence..
02:15:48 <joao> I'm testing possibilities :)
02:16:04 <ozone> Lemmih: ah, now you're at the fun part
02:16:50 <Lemmih> joao: Using GHCi and an IORef would be a lot simpler.
02:17:38 <ozone> Lemmih: using the typeclass technique from my paper then, or another one?
02:17:50 <joao> I have to take a look at that then.. I've never used IORef
02:19:20 <Lemmih> ozone: I'm doing exactly the same as I did to handle templates.
02:23:35 <Lemmih> Not sure if I've stolen any ideas. (:
02:24:12 <ozone> :}
02:25:17 <joao> ozone, which paper? About this subject I'm talking or something else? 
02:28:01 <Lemmih> joao: "Interfacing Haskell to Object-Oriented Languages" and it's about something else. (-:
02:38:30 <joao> Be back later. Thank you :)
02:39:47 <basti_> hi
02:40:09 <musasabi> hello
02:40:47 <Lemmih> Greetings, basti_.
03:29:10 <Lemmih> Igloo: Ping.
03:31:21 <Lemmih> Igloo: I can't declare a foreign function with a variable type from TH?
04:27:13 <Victor> hi, i'm getting "undefined variable isAlpha", what do i have to import for it to work?
04:30:42 <Maddas> Riastradh: Yi (got the archive just now) builds without any problems for me. Do you have a recent version of hs-plugins installed?
04:31:51 <Lemmih> @index isAlpha
04:31:51 <lambdabot> Data.Char,GHC.Unicode,Char
04:32:40 <Maddas> make html and make docs, however, give me 'no such rule to make foo' errors :-)
04:37:34 <Maddas> (Oh, making them manually works fine)
04:55:40 <Victor> thx
05:01:35 <shapr> man I love unicycling
05:01:45 <shapr> Darius: any new thoughts on spoken programming
05:01:46 <shapr> ?
05:03:04 <shapr> andersca: where's Ulf's video?
05:04:07 <Igloo> Lemmih: You can't splice types in, but you can construct one
05:18:13 <shapr> @yow !
05:18:15 <lambdabot> I'm having a BIG BANG THEORY!!
05:19:33 <Lemmih> Igloo: It fails with: "Not in scope: type variable `a'"
05:19:58 <Lemmih> On a (varT (mkName "a")).
05:20:43 <SamC_> anyone willing to send me the yi .ps file?
05:20:44 <Igloo> Are you using CVS?
05:22:36 <Lemmih> Yes. I think it's a week or two old.
05:23:10 <arauko> Hello Haskell Community.
05:23:18 <zamez> hi
05:23:37 <basti_> hopengl fails me with:  undefined reference to `glutSwapBuffers'
05:23:41 <arauko> I don't get in here since last year :-)
05:24:00 <basti_> i tried googling it, and fixing my package.conf since this is auto packages
05:24:10 <Maddas> SamC_: Sure, hold on.
05:24:18 <basti_> package.conf associates HOPENGL with -lGLU which should be enough to link glut.
05:24:32 <basti_> i wonder why a linker error happens anyway.
05:25:22 <Igloo> Hmm, looks like a bug
05:25:28 <Maddas> SamC_: http://people.ee.ethz.ch/~zieglerm/yi.ps
05:25:31 <basti_> a packaging bug maybe
05:26:04 <basti_> how do i find out if ghc6 was compiled --enable-hopengl?
05:26:34 <SamC_> Maddas, thank you very much
05:27:37 <Maddas> No problem
05:28:19 <Maddas> I just did cd docs && make
05:28:25 <Maddas> Not sure how to get the haddock documentation :-)
05:30:08 <Igloo> basti: ghc-pkg -l | grep OpenGL
05:30:37 <basti_>     readline, OpenGL, GLUT, unix, lang, concurrent, posix, util, data,
05:31:28 <basti_> hmm. seems okay.
05:32:16 <Darius> shapr: Not too many new thoughts, though there are some things I haven't said and some things I'm mulling over in relation to Spoken Joy.
05:35:55 <basti_> I'll try compiling ghc
05:55:14 <shapr> Darius: ok, I'll be patient until your mulling produces results :-)
05:57:56 <Darius> shapr: The issue is whether the fact that joy is almost completely irredundant and practically anything parses is a benefit or a detriment.
05:59:21 <SamC_> what is Spoken Joy?
06:01:16 <Darius> SamC_: What a spoken version of the Joy programming language might be called.  Though it looks like Joy needs little or no changes to do a great job.
06:03:10 <SamC_> why are you interested in this? speaking the bracketing would be the only awkward bit no?
06:04:21 <shapr> I'd say it's a benefit unless proven otherwise.
06:05:52 <shapr> There's no way to know for sure until we've used it a bit.
06:06:36 <shapr> I'm not really sure how to approach the speech recog part, hack up existing Viterbi code in fptools?
06:07:33 <Darius> SamC_: There a few more than that and the bracketing isn't that bad, but that Joy has so few awkward bits is what makes it interesting.
06:09:02 <Darius> SamC_: It seems like it would be much much easier to implement and more usable (given less than perfect implementations of the speech handling parts).
06:14:38 * SamC_ is surprised at how much attention joy garners
06:15:17 <basti_> can you make a circular graph in haskell? i'd bet!
06:16:25 <Darius> basti_: Yes
06:16:40 * basti_ just never thought about it before.
06:17:20 <Darius> basti_: There are several levels at which you could do it.
06:17:38 <basti_> circular type graphs?
06:20:55 <Darius> Well technically yes to that too, but I meant different ways of implementing a graph and how it would be circular, for example, in any Turing-complete language you can make a representation of a circular graph without having a cycle in the reference graph.
06:21:17 <Darius> (with extensions though with regards to a type graph)
06:21:42 <Darius> Hmm, overloaded use of the word "graph" in the last but one response.
06:21:57 <SamC_> basti_ check out http://web.comlab.ox.ac.uk/oucl/work/duncan.coutts/papers/recursive_data_structures_in_haskell.pdf
06:22:16 <SamC_> (slides)
06:24:23 <basti_> hmmm i was thinking like a datatype...
06:25:24 <basti_> oh wow yes.
06:26:46 * basti_ is pondering doing sound synthesis in haskell.
06:27:11 <TheHunter> @wiki TyingTheKnot
06:27:12 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot
06:27:27 <basti_> i know that yes.
06:29:02 <musasabi> Cyclic structures are nasty in Haskell because there is no pointer equality. Of course one can use a table of stablenames though.
06:37:52 <bourbaki> hey TheHunter
06:37:58 <bourbaki> @seen boegel
06:37:59 <lambdabot> I saw boegel leaving #Haskell 15 hours 28 minutes 17 seconds ago.
06:42:14 <TheHunter> hey bourbaki 
06:42:47 <bourbaki> TheHunter: wanna see a shot of my latest math application :)?
06:44:08 <bourbaki> TheHunter: http://img78.exs.cx/img78/5025/unbenannt5xh.jpg
06:45:14 <TheHunter> nice
06:45:35 <bourbaki> yep what you see there is a potential field
06:45:53 <bourbaki> and the ball moves along the mouse and the vector field
06:47:24 <bourbaki> im just in need of a good polynomial for my surfaces
07:32:16 <joao> Hello
07:32:53 <Lemmih> Greetings.
07:40:15 <joao> Lemmih, how can I create a state where I can add the variables I want (some kind of heterogeneous list)?
07:44:47 <TheHunter> joao, how long have you been using haskell?
07:45:38 <autrijus> ghc is utterly not happy with freebsd-amd64
07:45:41 <autrijus> neither is darcs :-/
07:47:23 <TheHunter> ok, either [Dynamic] or use the HList library.
07:48:52 <TheHunter> depends on what you wanna do and on how experienced you are (it might even be possible that both approaches aren't the right solution at all).
07:50:25 <joao> TheHunter, I don't have much practice indeed :P
07:53:10 <TheHunter> forget HList then. Dynamics are not really an innocent topic either, as you need to understand type classes and existentials.
07:53:43 <joao> HList is type programming, right? I've read something about it
07:54:11 <Darius> TheHunter: You don't need to understand the implementation of a library to use it
07:55:23 <TheHunter> ok, "replace" understand with "have an idea what it is"
07:55:52 <joao> Actually, I've started to read HList paper.. but for another issue. Now, I'd like to have something like a "variable space" (of different types) :-)
07:57:14 <Darius> TheHunter: You don't really need to know anything about existentials to use Dynamics, but if you're using Haskell it would make sense to have an idea what type classes are.
07:57:44 <Darius> joao: What are you trying to do or why do you want this (right now)?
07:58:12 <TheHunter> Darius, you're right, I just checked the Dynamic interface, there's indeed nothing about existentials you need to know to use it.
08:00:02 <joao> Darius, I'm trying to do some kind of "eval" function, which, depending on some state does different things. For instance, "eval push(1,[])" will push 1 into the empty stack if x==0. If x==1 it will return error, for instance. And then I need a space to hold the stacks (and values of other types too).
08:01:37 <TheHunter> joao, eval takes a string?
08:02:26 <TheHunter> and you want to write an interpreter for a mini language?
08:02:33 <joao> TheHunter, yes, kinda
08:02:50 <joao> Well, yes :)
08:03:18 <joao> eval f(x) will call f(x) haskell function if certain conditions are available
08:03:44 <TheHunter> so you want to use hs-plugins.
08:04:23 <MegaMonad> Greetings mr. Goerzen.
08:04:31 <CosmicRay> heh
08:04:35 <wli> I need an interpreter for a mini-language too.
08:04:41 <CosmicRay> MegaMonad: Greetings, Agent Monad.
08:04:42 <MegaMonad> CosmicRay: It's at least 3 papers submitted to icfp i knew what a monad the way changing one type of an agent.
08:04:58 <autrijus> MegaMonad: ia ia, cthulhu fhtagn
08:04:59 <MegaMonad> autrijus: Www.cthulhu.
08:05:39 <TheHunter> joao, I don't think HList will help you, then because you're forced to use dynamics for hs-plugins anyway.
08:05:45 <autrijus> MegaMonad: thiswordnoverb thisverbnoword
08:05:46 <MegaMonad> autrijus: "Därför utvecklar jag gratis" - intervju med mikael hallendal på imendio.
08:07:23 <basti__> re
08:08:12 <basti_> sheesh
08:08:29 <basti_> seen majic
08:08:32 <basti_> @seen majic
08:08:33 <lambdabot> I haven't seen majic
09:05:44 <basti_> rebuilding ghc solved my library issue
09:09:42 <autrijus> hey hcchien. you mentioned you had some problem with looping?
09:10:53 <hcchien> autrijus: yes, a little confuse. how can I just implement a loop which doesn't do anything?
09:11:01 <autrijus> loop = loop
09:11:06 <autrijus> :p
09:11:24 <autrijus> what kind of loop do you have in mind?
09:12:03 <hcchien> I mean, just like for [1..10], and I get the index
09:12:23 <hcchien> it should be for (x:xs) = x; for xs
09:12:45 <autrijus> except that you need to define "for [] = []" as well
09:12:56 <autrijus> but that doesn't buy you anything --- you get back the same list
09:13:11 <autrijus> you can try list comprehension
09:13:12 <autrijus>  print [n | n <- [1..10]]
09:13:20 <autrijus> print [n*2 | n <- [1..10]]
09:13:26 <autrijus> it should be closer to what you have in mind
09:13:37 <Darius> hcchien: You use monads to do what (I think) you want.
09:13:41 <hcchien> seems so, it looks better. :D
09:15:15 <Darius> hcchien: The mapM_ function does what I think you were trying to get at with the 'for' definition.
09:16:17 <autrijus> hcchien: mapM_ is probably closest to perl's foreach() :)
09:16:31 <hcchien> Darius: thanks, I will check it later. and the way autrijus said works well. :)
09:16:59 <autrijus> hcchien: more examples about listcomprehension are at http://www.zvon.org/other/haskell/Outputsyntax/listQcomprehension_reference.html
09:20:41 <Oejet> Hmm, it's a bit windy at my place.
09:21:05 <Riastradh> Maddas, I have 0.9.6; does that qualify as 'recent?'
09:23:23 <autrijus> hmm hsregex isn't easily installable
09:23:40 <autrijus> the syntax looks very friendly though
09:45:58 <wli> nice: unfoldr (Just . dup (flip (dup ((.) ((.) ((.) (flip ((,) . head))) (flip (.) tail . filter)) (((.) (((.) ((.) (/=0))) (flip mod)) head)))))) [2..]
09:46:06 <wli> piont-free
09:46:12 <wli> feh, point-free even
09:47:47 <autrijus> I miss using -> as part of identifier :-(
09:47:55 <TheHunter> wli, what's the original?
09:49:57 <desrt> what's the name of the map that allows passing of a state between each of its parameters (non-monadic...)
09:50:05 <desrt> it has a name like 'scan' or something but scan isn't in prelude...
09:50:37 <TheHunter> @type scanl
09:50:39 <TheHunter> @type scanr
09:50:39 <lambdabot> scanl :: forall a b. (a -> b -> a) -> a -> [b] -> [a]
09:50:40 <lambdabot> scanr :: forall b a. (a -> b -> b) -> b -> [a] -> [b]
09:50:47 <desrt> i see.
09:50:52 <desrt> thx.
09:52:10 <desrt> hm.  not quite what i need
09:52:27 <desrt> but i think i can bolt a very small piece of code onto it to make it right
09:52:42 <Darius> desrt: There is mapAccumL/R
09:52:43 <jadrian> desrt: mapAccumR and mapAccumL
09:52:51 <jadrian> @type mapAccumR
09:52:53 <lambdabot> bzzt
09:52:59 <Darius> @type Data.List.mapAccumL
09:53:00 <lambdabot> Data.List.mapAccumL :: forall y acc x.
09:53:00 <lambdabot> 		       (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:53:13 <jadrian> Darius: thanks :)
09:53:45 <jadrian> oh you even said it before me...
09:53:51 <jadrian> eh...
09:56:38 <wli> TheHunter: oh
09:56:44 <Darius> wli: Point-free code isn't just about eliminating all references to bound variables.  Compiling to combinators is very old hat.
09:57:25 <wli> TheHunter: unfoldr (\(x:xs) -> Just (x, filter ((/=0) . (`mod` x)) xs)) [2..]
09:57:48 <wli> Darius: it's just exercise of some kind to do it by hand
09:58:04 <TheHunter> unfoldr (\xxs -> Just (head xxs, filter ((/=0) . (`mod` head xxs)) tail xxs)) (fromEnum 2)
09:58:11 <TheHunter> thbot: @pointfree unfoldr (\xxs -> Just (head xxs, filter ((/=0) . (`mod` head xxs)) tail xxs)) (fromEnum 2)
09:58:11 <thbot> Sorry, I don't know the command "pointfree", try "lambdabot: @listcommands
09:58:19 <TheHunter> thbot: @pointless unfoldr (\xxs -> Just (head xxs, filter ((/=0) . (`mod` head xxs)) tail xxs)) (fromEnum 2)
09:58:19 <thbot> (line 1, column 32):
09:58:19 <thbot> unexpected ","
09:58:19 <thbot> expecting variable, "(", operator or ")"
10:03:10 <TheHunter> thbot: @pointless unfoldr (\xxs -> Just (head xxs, filter ((/=0) . (flip mod $ head xxs)) tail xxs)) $ fromEnum 2
10:03:11 <thbot> unfoldr (Just . s ((,,) . head) (s (flip filter tail . ((/= 0) .) . flip
10:03:11 <thbot> mod . head) id)) $ fromEnum 2
10:03:56 <wli> apparently a much simpler one than I devised by hand is available
10:04:45 <TheHunter> i think s is more powerful than dup in that respect.
10:04:48 <Darius> wli: Well it depends on the basis you use.
10:06:23 <wli> true
10:15:45 <joao> @listcommands
10:15:46 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
10:15:46 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
10:15:46 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
10:15:46 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
10:15:46 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
10:15:47 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
10:15:49 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
10:15:51 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
10:15:53 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
10:15:59 <joao> ooops, sorry :(
10:16:49 <tintin> lambdabot must reply to @ list via a private message it would make more sense ?
10:18:05 <autrijus> gah.
10:18:19 * autrijus has a hate-hate relationship with monomorphism restriction by now
10:18:40 <autrijus> I think I'll just apply the magic flag and forget about changing my program :-/
10:22:52 <jadrian> isn't providing signatures all you need?
10:26:08 <TheHunter> @pointless unfoldr (\xxs -> Just (head xxs, filter ((/=0) . (`mod` head xxs)) $ tail xxs)) $ enumFrom 2
10:26:09 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
10:26:09 <thbot> unfoldr (Just . ap ((,) . head) (ap (filter . ((/= 0) .) . flip mod . head
10:26:09 <thbot>  tail)) $ enumFrom 2
10:26:24 <TheHunter> this one's correct.
10:27:47 <joao> pointless is alcino's lib?
10:28:40 <autrijus> jadrian: a signature for each inlined lambda?
10:28:46 <autrijus> jadrian: thanks I'll pass, I think
10:28:58 <jadrian> autrijus: ouch
10:29:04 <TheHunter> joao, no i wrote that.
10:29:07 <jadrian> autrijus: I hadn't thought about that one
10:29:13 * TheHunter googles for alcino's lib
10:29:54 <jadrian> joao: from Braga?
10:30:59 * jadrian met alcino in a haskell summer school once
10:34:16 <jesse99> what do Inl and Inr mean in the context of generics?
10:35:17 <autrijus> I thought they are deprecated now in favor of Data.Generics?
10:35:25 <autrijus> at least that's what Basics.hs seems to say
10:35:26 <Darius> jesse99: They are like Left and Right of Either.
10:35:52 <autrijus> err, Generics.hs.
10:36:05 <jesse99> are they deprecated Darius?
10:36:37 <autrijus> my Generics.hs says
10:36:37 <autrijus> -- Data types for the sum-of-products type encoding;
10:36:37 <autrijus> -- included for backwards compatibility; maybe obsolete.
10:36:38 <autrijus> (:*:)(..), (:+:)(..), Unit(..)
10:36:45 <autrijus> but I know nothing about the two, so I'm not sure
10:38:30 <TheHunter> why do they want to delete that? because of SYB?
10:39:22 <Darius> TheHunter: That and it didn't seem like anyone was using it.
10:40:39 <Darius> TheHunter: Ralf Hinze, I believe, recently published a paper that implements roughly that as a library.
10:40:40 <TheHunter> i found about it just lately and i liked it. It should be trivial to change it from "instance Foo" to "deriving Foo".
10:41:09 <autrijus> user-defined derivables?
10:41:10 <autrijus> nice
10:43:52 <Darius> Also Template Haskell allows similar more powerful derivations.
10:47:08 <TheHunter> i'm still not convinced. I guess nobody is using it because noone knows about it. And the syntax is probably nicer than any library or TH stuff can ever get.
10:47:36 <wli> TheHunter: what's this?
10:47:46 <TheHunter> http://haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
10:47:50 <joao> jadrian, yes, from Braga
10:50:48 <Philippa_> woo!
10:51:10 <Philippa_> would be nice if TH gained syntactic sugar for things like new derivable types so you didn't have to splice manually
10:53:02 * autrijus mumbles something about syntactic aspartame
10:54:47 <Philippa_> I can live with a clear marker than the derivable type was done via TH - deriving Show, Read, $Foo...
10:54:49 * Riastradh mumbles something about syntactic overcomplexity.
10:56:10 <autrijus> refactoring in haskell is addictive.
10:56:23 <autrijus> I've done nothing but refactoring for the past two hours :-/
10:56:30 <Philippa_> Riastradh: the alternative's a little awkward to read, certainly doesn't provide as much context
10:57:10 <Riastradh> What alternative are you referring to?
10:57:22 <Philippa_> the one where you splice in an instance declaration
10:58:22 <autrijus> data Baz a = Baz a deriving (Show, Read, $(Foo))
10:59:25 <Philippa_> autrijus: that's what I'm proposing, yes
10:59:52 <autrijus> and $(Foo) will get an implicit argument "Baz"?
10:59:56 <Philippa_> yeah
11:00:00 <Philippa_> or rather, Baz a
11:00:01 <autrijus> but what about constructors?
11:00:12 <autrijus> it needs a list of constructors as well
11:00:19 <Philippa_> so it gets those too
11:00:24 <autrijus> ok then.
11:00:31 <autrijus> not opposing it. it's just not very obvious :)
11:00:52 <Philippa_> (can't remember if you can get the constructors for a type in TH, if so that'll do)
11:01:22 <autrijus> you can get a type from a constructor I think
11:01:30 <autrijus> I don't know about the reverse
11:24:18 <SyntaxNinja> I'm adding more licenses to cabal's Distribution.License module.  I've got BSD3, BSD4, GPL, LGPL, PublicDomain, and AllRightsReserved (and "other") any other biggies I should add?
11:26:45 <Igloo> GPL and LGPL at least should probably have a version
11:27:30 <SyntaxNinja> hmm
11:27:34 <Igloo> If the licence is AllRightsReserved then it can't be distributed. While this does make sense I'd prefer a name like Undistributable
11:28:10 <SyntaxNinja> Hm. That's a good idea...
11:28:11 <Igloo> Or Private
11:28:22 <Igloo> Something to stop people using it for things they release, anyway  :-)
11:28:27 <SyntaxNinja> right.
11:28:31 <autrijus> there is this "Artistic" thing and the "Apache" thing, and "Mozilla".
11:28:32 <SyntaxNinja> it's the default, btw.
11:28:45 <Igloo> I thought it was a required field?
11:28:58 <autrijus> artistic comes in 1 and 2; apache in 1 and 2; mozilla in 1.0 and 1.1
11:29:20 <autrijus> but virtually mpl means 1.1 now and artistic means 1.0 now
11:29:26 <SyntaxNinja> can't I put comments on constructors in haddock
11:29:26 <Igloo> We probably have some X11 licenced stuff in fptools
11:29:39 <autrijus> yeah, MIT/X11 too.
11:29:48 <SyntaxNinja> man. license version numbers is a pain, maybe I should just add a version field
11:30:01 <autrijus> that'd be a good idea.
11:30:15 <SyntaxNinja> Igloo: yeah, it's a required field, but there's also defaultPackageDescription if they're doing something complicated
11:30:15 <Igloo> autrijus: The objective is not to list every licence, but those that are useful. The fewer there are, the less bewildered people will be
11:30:47 <autrijus> Igloo: sure; I list the three only because there are large existing codebase with them as license
11:30:54 <SyntaxNinja> and also, I don't think marking the Setup.description file with a license is enough to release something under that license :)
11:30:55 <Igloo> SyntaxNinja: So someone following Angela's cookbook will get whined at if they don't specify a licence?
11:31:04 <Calister> ello ello
11:31:05 <autrijus> Igloo: but if noone use them in the haskell community I'll shut up :)
11:31:39 <Igloo> I think if you release a Haskell package with licence: foo then that is sufficient for at least all the Haskell files
11:32:17 <SyntaxNinja> Igloo: Angela's cookbook will tell them to put a license in
11:32:41 <Igloo> SyntaxNinja: But what happens if they don't?
11:32:47 <SyntaxNinja> it probably parses fine right now, but once we straighten out what fields are required, the parser will spit at them
11:32:53 <Igloo> OK, cool
11:32:57 <SyntaxNinja> but right now the parser is very forgiving
11:34:50 <SyntaxNinja> and maybe "make sdist" should warn them if they are using AllRightsReserved :)
11:35:16 <Igloo> I thought about that, but it'll just be filtered out before it hits the brain pretty soon
11:35:45 <Igloo> And in a company, say, you probably want to use it in case you accidentally put it on your FTP server or something
11:35:52 <SyntaxNinja> yeah, just a warning
11:36:17 <SyntaxNinja> presumably, hackage will reject it
11:37:11 <Igloo> There should ideally be a simple "What licence do I want?" section too. Probably suggesting one of PD, GPL and BSD, and pointing out we're not lawyers etc etc
11:38:02 <Igloo> I'm thinking just a couple of lines to differentiate the main features. With any luck we can steal it from somewhere else
11:38:36 <Philippa_> I assume there's Homebrew/RTFL as one of the options?
11:39:01 <SyntaxNinja> Philippa_: yeah use the "OtherLicense FilePath" constructor :)
11:39:06 <Philippa_> fair enough
11:40:23 <SyntaxNinja> I'm just going to refer people to opensource.org
11:41:25 <SyntaxNinja> so is there some legal reason that people say IANAL?
11:41:48 <Igloo> Presumably you can be sued for providing bad legal advice if you don't and someone gets taken advantage of
11:41:59 <Igloo> At the very least it's polite to point it out
11:42:03 <Philippa_> right
11:42:30 <Philippa_> the disclaimer amounts to "do not consider this as solid legal advice, I am not qualified to give it"
11:43:29 <Darius> Oh. Great.  You have to be a lawyer just to not be a lawyer.
11:43:59 <SyntaxNinja> heh
11:44:20 <SyntaxNinja> IANAL, but I think it's legal to smoke pot while driving in texas
11:44:49 <SyntaxNinja> actually, I really do think it's legal to drink alcohol while driving in texas
11:45:49 <SyntaxNinja> oh, I'm wrong.
11:46:23 <SyntaxNinja> but I think it was legal until 2001
11:47:15 <Igloo> I can't think why it would be more illegal than drinking non-alcohol in the UK
11:47:54 <Igloo> You'd probably need to be doing it through a straw in order to not be driving dangerously, not being in control of the vehicle or somesuch
11:48:01 <norpan> i hope it's legal to drink alcohol while driving my computer
11:48:17 <SyntaxNinja> norpan: as long as you're not deriving!
11:48:18 <Igloo> Actually, maybe not even that. The law for mobile phones is specific to them IIRC
11:48:23 <norpan> yeah
11:48:26 <Calister> there is no law which makes having sex while driving in germany
11:48:33 <SyntaxNinja> this whole conversation has been an elaborate setup for that lame joke
11:48:44 <Calister> lotsa stuff aint allowed by law while driving
11:49:52 <SyntaxNinja> OK here's the haddock for the license doc: http://www.syntaxpolice.org/tmp/Distribution.License.html
11:50:15 <SyntaxNinja> should I add Artisitc, apache, and mozilla? I don't even know what those do, except I think that the apache license is kinda like lgpl?
11:51:01 <musasabi> evening
11:51:12 <Igloo> I'd suggest not adding anything you don't find code using
11:52:00 <Calister> good evening musasabi
11:52:16 * Igloo wonders how long until we get haskell-legal@haskell.org  :-)
11:52:50 <musasabi> mozilla license contained some nasty stuff iirc.
11:53:17 <musasabi> Something like LGPL but simpler would be nice.
11:53:20 <SyntaxNinja> hi musasabi, hi Calister
11:53:55 <Igloo> Oh, that's a point, MPL is considered non-free I believe
11:55:06 <SyntaxNinja> yeah, LGPL is strange too, because it's unclear what to do if you release DLLs or something, there's some clause that says that the derivatives have to be able to link without the source code blah blah. 
11:55:17 <esap> Hmm.. where can I find documentation for Control.Concurrent.STM?
11:55:41 <musasabi> esap: there is a paper on that.
11:56:20 <SyntaxNinja> I think I'll leave it as AllRightsReserved, and just leave the comment in there about it being undistributable
11:56:23 <musasabi> SyntaxNinja: yes, I would actually like to license stuff under LGPL if I could understand it (and think other people could understand it too)
11:56:52 <Igloo> LGPL allows at least as much as GPL, right?
11:56:55 <SyntaxNinja> musasabi: something that just says "you can use it and link with it, but if you alter it, you have to release the alterations" I think is a very nice license for a library.
11:56:59 * TheHunter wonders if the $gtoFoo stuff ghc generates has something to do with generic classes.
11:57:02 <Igloo> So if the alternative is GPL you could do that anyway
11:58:04 * Igloo suggests running any self-penned licences past debian-legal or somesuch before using them to save major hassle in the future
11:58:17 <SyntaxNinja> yeah
11:58:18 <musasabi> esap: research.microsoft.com/%7esimonpj/papers/stm/{index.htm,stm.ps}
11:58:29 <esap> musasabi: Thanks.
11:59:07 <musasabi> SyntaxNinja: rather "the alterations are under the same license" + providing source.
11:59:16 * SyntaxNinja goes to ask on #debian-devel...
12:00:45 <musasabi> Igloo: using self-penned license is evil as people have to read it and think about it..
12:00:47 <SyntaxNinja> it'll probably start a flame war... if so, is that my faault?
12:14:47 <SyntaxNinja> does anyone know if you can use two -package-conf files w/ ghc?
12:15:31 <Igloo> It only adds them to the global ones, so I assume so
12:20:28 <SyntaxNinja> seems like it...
12:23:20 <adrianek> hi. is there any function in ghc which would convert String to Int?
12:23:30 <adrianek> or do I have to write it myself?
12:23:50 <SyntaxNinja> read will do it
12:23:51 <musasabi> adrianek: read?
12:24:05 <adrianek> oh
12:24:07 <musasabi> @type read
12:24:09 <lambdabot> read :: forall a. (Read a) => String -> a
12:24:21 <adrianek> thanks! it works 
12:25:13 <SyntaxNinja> Lemmih: alive?
13:36:25 <adept> hello everybody
13:36:38 <maihem> 'owdo
13:37:36 <CoolPops> does a function ending in ' mean anything special?
13:38:02 <adept> CoolPops: no, nothing at all
13:38:16 <maihem> no, it is commonly used to mean alternative, or the afterward-version
13:38:25 * adept is looking for somebody doing heavy numerics in Haskell
13:38:33 <adept> anybody? :)
13:38:35 <CoolPops> maihem: ah, that was going to be my next question, why do it... thanks.
13:38:39 <maihem> ie let a' = a + 1 in ...
13:39:49 <adept> CoolPops: in other languages people prepend '1' or '_' in similar situations ...
13:40:21 <CoolPops> adept: ok, just making sure I am fully understanding what I am reading.
13:44:54 <adept> CoolPops: and what are you reading (just curious)?
13:45:08 <CoolPops> adept: Yet Another Haskell Tutorial
13:45:21 <CoolPops> adept: by Hal Daume III
13:45:50 * CoolPops is toward the end of chap 4, Type Basics
13:48:52 <adept> CoolPops: ah, good one.
13:57:51 * Oejet thinks that Composable Memory Transactions is a nice idea for use in concurrent programming.
13:59:43 <Oejet> Anyone read the article http://research.microsoft.com/~simonpj/papers/stm/stm.ps ?
14:00:58 <maihem> Is there a way to tell the compiler that a computation should not be done unless all the memory needed can be certainly obtained (ie, up front allocation for a computation or bust)
14:01:39 <musasabi> Oejet: yes, seems very nice.
14:02:14 <adept> maihem: how compiler could know how much memory would be needed without actually doing a computation? :)
14:02:16 <musasabi> Oejet: but currently that is quite limited.
14:03:15 <maihem> Is there a way for me the programmer to calculate how much memory would be used, then force the allocation? I can't see any way. This is need for many systems programming tasks, especially realtime.
14:03:15 <musasabi> not to say you cannot do very nice stuff with it ;)
14:03:36 <musasabi> maihem: you cannot do that in general in C either ;)
14:03:38 <Oejet> musasabi: How is it limited?
14:03:51 <musasabi> Oejet: too much usefull things live in IO land.
14:03:58 <maihem> No, but I can do it for anything for which it can be done ;), and it must be done for many things.
14:04:09 <musasabi> btw I am thinking of coding a hashtable in STM tomorrow.
14:04:31 <adept> maihem: for automatic memory management needs, you should use C. Otherwise, GC will get in the way ...
14:04:54 <Oejet> musasabi: So you want to make a hashtable which is thread safe?
14:05:01 <musasabi> maihem: well you can maintain memory by hand in haskell by using Ptrs and stuff.
14:05:04 <musasabi> Oejet: yes.
14:05:19 <maihem> adept, there is no reason for GC to be used for everything in haskell, strictness can be determined for many things, and malloc/free type behaviour gets used.
14:05:24 <musasabi> and in particular in which you can perform multiple operations in a thread safe way.
14:05:33 <maihem> musasabi: yuch, oh well
14:05:38 <musasabi> Oejet: I can give you a link to the implementation in a few days.
14:06:26 <musasabi> maihem: You could have a modified garbage collector with a routine like IsNBytesTriviallyAllocatable :: Int -> IO Bool
14:06:50 <SyntaxNinja> Lemmih: I added the fix for cabal executables that depend on the library itself, with the hs-source-dirs
14:06:53 <Oejet> musasabi: Great.  Maybe I will even give you a link before then? :-P
14:06:58 <maihem> musasabi: but I don't know how many bytes haskell needs for each iteration of a computation, but the compiler does.
14:07:00 <musasabi> but that is not really worth is unless you have thread local heaps.
14:07:18 <maihem> ineed, noe should I have to know.
14:07:20 <musasabi> Oejet: hmm?
14:08:34 <Oejet> musasabi: Do Concurrent Haskell's threads (forkIO) not have local heaps?
14:09:42 <Oejet> musasabi: Or what do you mean?
14:09:52 <musasabi> Oejet: I don't remember, but I haven't read that they would have.
14:10:15 <musasabi> Oejet: and thread switches could still kill your real time guarantee.
14:10:52 <musasabi> Oejet: you know erlang does not offer these either and still soft real time erlang apps exist.
14:11:06 <adept> question: what is the easiest way to make MArray strict in it's elements?
14:11:27 <Oejet> musasabi: Hm, I didn't think about real time guarantees.
14:11:33 <musasabi> although in erlang there are thread local heaps, but that is not really required.
14:11:46 <musasabi> Oejet: then you should just profile ;)
14:12:25 <Oejet> musasabi: That is what I usually do. :)
14:15:33 <Oejet> musasabi: I'm currious.  Is there a similar implementation in some other languages?
14:19:33 <maihem> musasabi: if haskell had failNowForLackOfMemory :: a -> IO a and the compiler warned if the memory couldn't be determined based on the argument to which it is applied, would that be capable of doing what I'm looking for do you think. If so, then I am not concerned as I'm sure it will happen sometime and I don't need it for anything yet.
14:23:55 <musasabi> Oejet: not really such that I would know it, with C++ operator new you could preallocate memory etc, but that is true for a specific GC too.
14:25:14 <musasabi> maihem: failures for lacking memory are very hard on modern machines.
14:25:25 <musasabi> maihem: as trashing will usually get to you first.
14:26:49 <_Codex> sometimes it would be nice to know that your program's memory/space/time consumption is in some reasonable limits.
14:27:39 <maihem> musasabi: only if you are using the swapped out memory, and only if you have swap
14:28:03 <musasabi> true
14:28:21 <musasabi> _Codex: yes, limited space/time containers would be quite nice.
14:28:47 <musasabi> _Codex: but given the unsafe nature of haskell code that would not be enough for a sandbox.
14:29:03 <maihem> These things would make Haskell super efficient.
14:29:05 <maihem> unsafe ?
14:29:11 <_Codex> oh, certainly not enough for a sandbox.
14:29:44 <arauko> Hello.
14:29:53 <arauko> Is there any shell written in Haskell?
14:30:05 <maihem> ghci?
14:30:34 <wli> hash
14:30:45 <arauko> Oh, well.. can i run commands from there?, though i was thinking,,, oh that one wli
14:30:53 <wli> hash yes
14:31:07 <arauko> think it'd be nice to look at its source 
14:32:39 <musasabi> maihem: e.g. unsafe array operations, pointer stuff and so on.
14:33:51 <maihem> ah
14:56:56 <patanisca> hello haskellers! does anyone know how to get the projection matrix from hopengl?
14:58:47 * CoolPops wonders why emacs indent support has to be so goofy for haskell.
14:59:29 <jadrian> CoolPops: s/has to/is    :)
14:59:38 <jadrian> actually
14:59:44 <jadrian> CoolPops: s/has to be/is    :)
14:59:59 <CoolPops> jadrian: yes, that's a good correction.
15:03:02 <adrianek> hi. is there a way to catch exception thrown by "[] !! 2"?
15:03:53 <Igloo> Yes, but it would be better to write your own function that returns a Maybe a instead of an a
15:04:26 <adrianek> so 'catch' is intended for IO only?
15:04:51 <musasabi> adrianek: catch can be performed only in IO but exceptions can be thrown in pure code.
15:05:10 <musasabi> adrianek: see the paper "tackling the akward squad"
15:05:37 <adrianek> ok. i'm downloading it
15:06:26 <adrianek> but you're saying, that i should write my own '!!' function, which would return Maybe a. Is there no such function already available in GHC, or Prelude?
15:06:33 <Darius> musasabi: Not in Haskell 98.
15:06:50 <jadrian> I wrote a !!? function ages ago
15:07:06 <jadrian> and I always wondered why this was not in the Prelude...
15:07:12 <jadrian> or at least in Data.List
15:07:16 <adrianek> i guess it would be too time consuming
15:07:22 <jadrian> seems like everyones using it anyway
15:07:28 <adrianek> i mean, in basic !!
15:07:33 <Igloo> Just wait until we can write a ‽ function  :-)
15:07:34 <Darius> jadrian: I've never wanted.
15:07:40 <Darius> it.
15:07:59 <jadrian> ok... guess I'm wrong :)
15:08:49 <jadrian> Darius: I'll  ask you again in a couple of months just to make sure  :)
15:08:52 <Darius> jadrian: I will agree though, that it should have been defined returning Maybe (or better an arbitrary value in class Monad or MonadPlus)
15:09:09 <adrianek> Darius: so how do you deal with this situation? Or do you write your code such that the problem with !! never occur?
15:09:47 <monochrom> I write code such that I seldom use !!
15:09:58 <jadrian> monochrom: me too...
15:10:05 <jadrian> actually it's funny
15:10:22 <jadrian> in my recent program I avoided !! and anything like it
15:10:32 <jadrian> I wanted no chance of errors
15:10:49 <jadrian> I ended up giving in and used it on a place that seemed perfectly safe
15:10:54 <Darius> adrianek: I find I typically want to process lists as a whole or following the structure of the list, the few times I have used (!!) I usually either new it would succeed or was happy with it raising an exception if it didn't.
15:11:11 <monochrom> If I access a list sequentially, I don't need !!, and probably it is more readable with the usual lazy-sequential-list idioms instead of !!
15:11:21 <jadrian> there was the only occurence!
15:11:26 <jadrian> aof !!
15:11:27 <monochrom> OTOH if I access a list randomly, I make it an array.
15:11:30 <jadrian> of !! 
15:11:53 <jadrian> and about a week later a got a  error head of empty list
15:12:32 <Darius> Is jadrian going to become a convert of strong functional programming? Tune in next week to find out.
15:12:49 <jadrian> Darius: not sure what it means, but maybe I already am
15:13:38 <Darius> jadrian: It's where you limit yourself to total functions, always handle all cases in a case analysis, that kind of thing.
15:14:03 <Darius> or at least that's what it seems to be, I'm not sure how far it goes.
15:15:16 <_Codex> fmap and ixmap are pretty nice in haskell arrays.
15:15:32 <jadrian> Darius: kind of... for instance, in that case !! should never fail. It did because there was a bug, so if it returned Nothing what would I do with it?
15:15:35 <monochrom> YES!
15:16:15 <jadrian> Darius: the difference is that I reather get a Nothing and return my own error message, then just get a cryptic  "error head of empty list" that doesn't help me much
15:17:37 <Darius> jadrian: I imagine strong functional programmers would propagate the Nothing to where it would be better handled, of course, with the extensions to exceptions I'm not sure how all that would pan out.
15:18:12 <jadrian> Darius: yes, but I don't want to handle it at all, because it is wrong
15:18:30 <jadrian> Darius: If I want it to crash right there so I can fix my code
15:18:34 <TheHunter> do "strong functional programmers" really exist?
15:18:37 <_Codex> jadrian: why you need to use !! in the first place? Are you doing something for the individual elements?
15:19:03 <monochrom> Moreover haskell arrays permit the same laziness as the rest of the language.  f = array (0,10) ([(0,0),(1,1)] ++ [ (n+2, f!n + f!(n+1)) | n<-[0..8] ])
15:19:59 <jadrian> _Codex: not sure what to answer, besides tell you the algorithm (it's quite simple)
15:20:47 <Darius> TheHunter: Probably some, yes.  And certainly there are languages that enforce such things.
15:20:58 <jadrian> _Codex: I had a formula with Bruijn numbers for bounded variables (do you know what they are)?
15:21:30 <_Codex> jadrian: not well enough.
15:22:03 <Darius> "de Bruijn" and "bound variables" you mean ?
15:22:25 <_Codex> but usually the solution for !! is to try to handle whole lists at the same time and trying to avoid conversions from lists to individual elements.
15:22:57 <jadrian> _Codex: not sure how to do that here...
15:23:19 <TheHunter> an example where !! is justified might be the zipWith - style fibonacci implementation.
15:24:31 <Darius> TheHunter: Yes, but you can be pretty sure !! is total on an infinite list ;)
15:24:42 <jadrian> ok so give me an example for this, I wanted to print -->   F x (F y ( 0 * 1))  as --->  F x (F y ( y * x)) 
15:24:53 <TheHunter> Darius, good point.
15:25:00 <jadrian> see what the numebers mean?
15:25:06 <jadrian> numbers mean
15:25:23 <jadrian> they just tell you how far the corresponding letter is...
15:25:35 <Darius> jadrian: Shouldn't it just be F (F (0 * 1))?
15:26:11 <jadrian> Darius: yes but in this case I have letters in each of the Fs that I want to associate with the numbers
15:26:17 <monochrom> 0 refers to "the 0th bound variable (look back at the quantifiers)"
15:26:41 <jadrian> I'm using them in the context of First Order Logic expressions
15:26:49 <_Codex> jadrian: oh, it jumps over n bindings?
15:26:59 <jadrian> _Codex: yes
15:27:13 <monochrom> de Bruijn numbering means whenever you want to store F x (F y ( y * x)) in the computer you store F x (F y ( 0 * 1)) instead.
15:27:23 <monochrom> where F is a quantifier
15:27:28 <jadrian> exactly
15:27:46 <_Codex> jadrian: now you're using a list to store the current context?
15:28:09 <jadrian> I would use a list to store the letters as I traversed the expression downwards
15:28:33 <jadrian> and whenever I got to a de Bruijn number, say n,  I'd get the nth element of the list
15:28:52 <monochrom> !! is a valid use for this. also there should be no chance of []!!0 if you prove everything correct.
15:29:05 <jadrian> monochrom: exactly! :)
15:29:21 <jadrian> monochrom: so I ended up using it 
15:29:26 <monochrom> would be more efficient to use an extensible array, if there is one.
15:29:28 <arauko> what is !! for?
15:29:44 <monochrom> [hey,you,dude]!!1 is you
15:29:45 <_Codex> arauko: indexing array
15:29:52 <_Codex> err, list
15:29:55 <arauko> Oh, like, ++ ?
15:29:59 <TheHunter> pah, the only valid implementation for that uses type level naturals ;)
15:30:11 <jadrian> monochrom: but then I used the formula  printing function in the middle of the algorithm for debuging... where the formulas were not closed...
15:30:15 <monochrom> No, like (nth 1 '(hey you dude))
15:30:17 <Darius> jadrian: One way you could have gotten the error message you wanted (though at a later part) is using an infinite list of error thunks as the initial environment.
15:30:36 <arauko> oh, sorry
15:30:38 <arauko> thanks 
15:30:41 <monochrom> Oh haha I see.
15:31:05 <monochrom> Premature debugging is more evil than premature optimization!
15:31:38 <monochrom> Darius is clever
15:31:45 <Darius> Actually, it doesn't seem unreasonable to have (repeat (error "unbound variable")) as the initial environment.
15:31:47 <jadrian> Darius: hmmm nice trick :)
15:32:27 <jadrian> yes, yes you are right... it didn't cross my mind
15:32:41 <_Codex> that's very nice trick.
15:33:39 <monochrom> ie = e 0 where e n = "you are screwed over " ++ show n ++ " times" : e (n+1)
15:34:48 <jadrian> Darius: that is in did a very nice trick, and even simpler to code than the Maybe variant, but it doesn't delay the error as much as I would like
15:34:51 <monochrom> F z (you are screwed over 0 times * you are screwed over 1 times * z)
15:35:12 <jadrian> Darius: I'd only know that there had been an error when trying to acess de Bruijn numbers
15:35:31 <jadrian> Darius: using that maybe, I'll know where I was trying to access them
15:36:28 <jadrian> so it would be much better then just and head of empty list error
15:37:13 <jadrian> but not has good as it could be
15:37:38 <jadrian> hmm or maybe not...
15:37:54 <jadrian> nah never mind
15:40:34 <Darius> You could also seq the result of !! to get the error earlier.  That doesn't help for other context accessing functions, but neither does !! returning Maybe.  Anyways, I just pointed it out as a different way of looking at it, I imagine it's too late now.
15:42:44 <jadrian> Darius: at least in my case, the important part was not getting the error later or sooner, in terms of stoping the computation. 
15:43:05 <jadrian> Darius: I said I wanted it later, to have a better, more descriptive, error message
15:43:38 <jadrian> Darius: controling the evaluation of the list would give me the same error message
15:45:01 <jadrian> Darius: but yeah, in your case your idea would work just fine. I could control the error message by deciding when to append the infinite error list 
15:47:56 <jadrian> now I have my code changed to return a default string on error... so I could just initialize it with an infinite list with the default string...
15:51:37 <Darius> jadrian: Well, for some more twisted thinking (God I love Haskell), you could initialize the list with an infinite list of Nothing, except that you'd have to add Just values (which should be doable only modifying the implementation of one or a few functions), (!!) would then return Maybe values at the appropriate times.
15:52:31 <jadrian> Darius: :D
15:52:36 <jadrian> Darius: nice one too :)
15:52:59 <Darius> jadrian: I probably wouldn't do that one, but it's entertaining to think it up.
15:53:25 <jadrian> Darius: yeap
15:53:28 <jadrian> agree
15:55:31 <bourbaki> moin
15:59:30 <jadrian> Darius: I do prefer your infinite list idea, there is only one point in favour of the Maybe implementation right now. Which is that if by accident I mess up and do not that the infinite list or something, I'll still get a cryptic "head of empty list" error which doesn't help much. With the Maybe approach that never happens, it will return Nothing, and even if I forget check the Nothing case, I'll get a pattern error where I messed up.
16:17:20 <CoolPops> Is their a meaning to the "h" in front of IO functions such as hClose, hPutStr? If so, why readFile, writeFile and not hReadFile, hWriteFile?
16:17:51 <Gahhh> Hclose takes a handle
16:18:18 <Gahhh> but yeah, why not hReadFile heh
16:18:37 <CoolPops> Gahhh: because it does not take a handle, right?
16:19:13 <Gahhh> CoolPops, I myself am not that satisfied with the names of things in haskell
16:19:14 <CoolPops> Gahhh: you answered a curious question. Only functions that require a handle are prefixed with 'h'.
16:20:13 <CoolPops> Gahhh: I can understand their purpose, putChar, hPutChar but it does seem a bit awkward.
16:20:25 * CoolPops understands now that you clarified 'h'
16:22:54 <Gahhh> CoolPops, in haskell, Directory.getDirectoryContents also returns "." and "..". Why ? I don't know. Python doesn't.
16:24:13 <musasabi> Gahhh: well they are entries in the directory.
16:24:56 <musasabi> Gahhh: you can allways filter them out if you don't want them. (but then you probably want to filter dotfiles too)
16:25:22 <CoolPops> In python it sounds like you would have to do a specific catch for '/' ... how do I know I can't go back further? ;-)
16:25:54 <Gahhh> musasabi, no, the dotfiles are regular files. I usually do a "drop 2".
16:26:20 <musasabi> e.g. myDirContents s = do { l <- getDirectoryContents s ; return (filter (\ss -> head ss == '.') l) }
16:26:21 <Gahhh> CoolPops, you can also go back. "/" has a parent "..", which is itself.
16:27:55 <Gahhh> Oops I misunderstood you
16:31:55 <jadrian> ok, maybe I'm becoming obcessed with it, but I look at (\ss -> head ss == '.') and I think, what if I got a dir with an empty name...
16:32:08 <jadrian> I know that in theory it does never happen
16:32:28 <jadrian> but I've bitten by things that never happen in theory one to many times
16:33:02 <partimpim> hi! does anyone know how to obtain the projection matrix from hopengl? in C it is very easy -- using glGetFloatv but the fun is not present in haskell. been searching on the net for a few hours, found nothing... :-(
16:33:21 <jadrian> and in this case, I'd just know that somewhere, somehow, a head [] was performed...
16:34:37 <musasabi> jadrian: which throws an exception which is catched at an higher level using Control.Exception.
16:34:49 <monochrom> I can write "/usr//monochrom/hey" and it will mean /usr/monochrom/hey will that cause you a problem?
16:35:44 <jadrian> musasabi: yes I could catch it, but I wouldn't know where it happened
16:35:49 <monochrom> /usr//monochrom/hey is some valid user input but the computer will never generate such things on its own.
16:37:06 <monochrom> except... on windows a file on a network drive is called something like \\\usr\monochrom\hey and some haskell implementations may convert it to ///usr/monochrom/hey for you.
16:37:25 <jadrian> in many cases you don't want to catch it at a later time, you want to know where it failed to fix it because you have a bug in your code
16:38:33 <musasabi> jadrian: I think that that is going to cause lots of other more severe issues.
16:40:15 <jadrian> musasabi: hmm what is?
16:41:04 <musasabi> jadrian: like that file doing nasty things to all standard file tools ;)
16:41:19 <jadrian> ah
16:41:48 <jadrian> musasabi: yes but it could be something like a bug on getDirectoryContents
16:42:01 <jadrian> musasabi: say problems with encoding...
16:42:33 <jadrian> musasabi: like I said, I've been bitten by impossible things one to many times...
16:43:54 <musasabi> true.
16:44:07 <musasabi> but a such file could not be opened anyways.
16:45:00 <Darius> return [entry | ('.':_) <- l]
16:46:11 <jadrian> musasabi: no, I mean it could be a getDirectoryContents bug, say not handeling correctly non isolatin chars...
16:48:10 <musasabi> jadrian: one reason more to just ignore encoding in filenames.
16:48:40 <jadrian> Darius: nice... 
16:48:56 <jadrian> Darius: (entry@('.':_)) right?
16:51:52 <Darius> jadrian: Yes, but unfortunately that would return only those that -did- start with '.'
16:52:17 * Darius is ever confusing the two ways of reading filter, though in this case I don't have much of an excuse.
16:53:16 <Darius> return [e | e@(c:_) <- l, c /= '.']
16:56:23 <jadrian> opss yes of course
16:56:38 <musasabi> return [e | e <- l, e /= [], head e /= '.']
16:57:09 <Darius> musasabi: The version I presented handles the empty list case.
16:57:22 <musasabi> Darius: that appears to handle it as well
16:57:47 <jadrian> I think musasabi version handles it too, because that is translated as && which is lazy, I think
16:58:07 <jadrian> hmm wait what I said makes no sense
16:58:14 * jadrian is getting tired
16:58:15 <musasabi> let l = ["aa","","bb",".cc","dd"] in [e | e <- l, e /= [], head e /= '.']
16:58:19 <musasabi> ["aa","bb","dd"]
16:58:24 <musasabi> in ghci.
16:58:39 <Darius> musasabi: I wasn't saying that yours didn't handle it.
16:58:44 <musasabi> ok ^_^
16:58:51 <Darius> Also, I wonder if just e would work instead of e /= []
16:58:56 <jadrian> nah it makes sense... :)
16:59:18 <musasabi> Darius: but I was considering my to be more readable (without the '@')
16:59:18 <jadrian> Darius: ?
16:59:41 <jadrian> Darius: I don't think that would work
17:00:01 <Darius> (which would better be written (not (null e)) while it makes no difference here makes a difference in other cases)
17:00:23 <Darius> jadrian: Put it in GHCi and see what happens
17:01:23 <jadrian> Darius: Prelude> [e | e <- l,  head e /= '.']
17:01:23 <jadrian> ["a"*** Exception: Prelude.head: empty list
17:01:40 <Darius> No, [e | e <- l, e, head e /= '.']
17:02:26 <Darius> Not that I'm recommending this, I'm just curious.
17:02:27 <jadrian> hmm that doesn't typecheck
17:02:34 <jadrian> it has to be Bool
17:03:32 <jadrian> it takes  e  and then  performs an "and" on the list of restrictions
17:09:07 <Darius> ah, [e | e <- l, _ <- e, head e /= '.']
17:10:33 <Darius> Anyways, bye.
17:27:42 <monochrom> _ <- e  I am not sure what it accomplishes
17:32:23 <jadrian> monochrom: maybe this equivalent version will make it clear 
17:32:33 <jadrian> [e | e <- l, c <- e, c /= '.']
17:33:04 <jadrian> it's the same, but more readable IMO
17:33:19 <monochrom> you mean equivalent to [e | e <- l, _ <- e, head e /= '.'] ?
17:33:26 <jadrian> yeap
17:33:49 <jadrian> wait
17:33:51 <jadrian> no 
17:33:58 <monochrom> See?
17:34:00 <jadrian> nevermind
17:34:19 <jadrian> this does it... I should really go to bed
17:34:24 <monochrom> heh
17:38:53 <jadrian> monochrom: anyway... Darius version doesn't work either
17:40:03 <jadrian> monochrom: it does prevents an error from occurring (not really sure how) but it returns the string e  (length e) times
17:40:38 <jadrian> monochrom: just like mine...
17:40:50 <jadrian> monochrom: so yeah they are equivalent after all
17:41:24 <jadrian> ok this means I'm might be able to work a few more minutes
17:46:59 <monochrom> This is most amusing.
18:00:02 <monochrom> [e | e<-["", "hello"], not (null e), head e /= '.']
18:00:08 <monochrom> this will work
18:01:12 <monochrom> [e | e<-["", "hello"], (_:_) <- [e], head e /= '.']  another version
18:02:43 <monochrom> now we have a million working versions
18:16:20 <retardo> Why does the haskell string syntax allow \^@, \^[, \^^, \^], and \^_, but not \^?   ?  An oversight?  Or a design decision?
18:18:09 <dons> \^ is used for specifying control characters, like \^C 
18:18:21 <retardo> Yes.
18:18:28 <retardo> And?
18:18:44 <musasabi> What is \^?
18:18:55 <retardo> character #127.
18:19:06 <retardo> Or rather, that is what I would expect it to be.
18:19:07 <musasabi> so say \127
18:19:15 <dons> \^?
18:19:15 <retardo> That was not my question.
18:21:30 <musasabi> retardo: well it is already defined as \ESC
18:21:42 <retardo> No.ESC is \^[.
18:21:48 <dons> \DEL
18:22:14 <musasabi> yes, DEL it is.
18:22:20 <retardo> None of this has anything to do with my question.
18:22:35 <musasabi> 2.6 of the haskell report has the stuff on character literals.
18:22:40 <retardo> And \^@ is \000 is \NUL.   So what?
18:28:42 <retardo> Why isn't "Maybe" an instance of "Monad"?
18:30:01 <dons> it is
18:30:03 <retardo> Oh, it is.  Never mind.
18:30:20 <Gahhh> Btw, what made you think it should be ?
18:30:48 <retardo> One would think that the haskell standard section on "Maybe" would mention that.
18:30:57 <retardo> Seems strange to me that it doesn't.
18:31:44 <Gahhh> retardo, it does. 
18:32:10 <retardo> I must be missing that.  Where does it say so?
18:32:11 <Gahhh> index of haskell 98 prelude says: instance of functor, monad
18:32:38 <retardo> Well, that's not in the section on "Maybe", is it now?
18:32:56 <Gahhh> Which one is the section on Maybe ?
18:33:13 <Gahhh> I am talking about the Haskell 98 report btw
18:33:18 <retardo> http://www.haskell.org/onlinereport/maybe.html
18:34:08 <Gahhh> That is "Maybe Utilities". Maybe is defined in the Prelude
18:34:20 <arauko> Hello.
18:34:33 <retardo> Aha.  Thanks.
18:35:04 <retardo> So I should have been looking at section 6.1.8.
18:35:34 <Gahhh> Yes. Or Section 8
18:37:00 <Gahhh> Oh my God. There is a function named "maybe".
18:37:18 <retardo> Sure. It's like fold, but for maybes instead of for lists.
18:37:43 <retardo> Whenever you have a synthetic datatype you want to have a foldlike operator.
18:37:55 <Gahhh> I am just appalled that it is called "maybe".
18:38:13 <dons> we don't have "list", right ;)
18:38:17 <dons> but we do have "either"
18:38:37 <retardo> I was about to mention "either".
18:39:03 <Gahhh> I dont think you understand what I am getting at.
18:39:51 <retardo> I guess not.
18:39:56 <retardo> What are you getting at?
18:40:02 <Gahhh> The English word is being abused to represent two different (albeit related) things.
18:40:11 <dons> it's interesting finding these little, rarely-used naming conventions
18:40:32 <retardo> Gahhh: How so?
18:41:08 <Gahhh> retardo, I don't know about you, but I tend to try to relate the names of things to what they do/represent.
18:42:00 <retardo> Naming the Maybe folding function "maybe" seemed like a reasonable choice to me.
18:42:28 <Gahhh> Where do you get the "folding" concept from just "maybe". It could be any function that works on Data Maybe.
18:42:58 <retardo> But it's not.  It's *the* function that works on Data Maybe. 
18:43:11 <retardo> Any other maybe function can be defined in terms of it.
18:43:30 <Gahhh> retardo, this conversation is over. I am sorry to have started it.
18:43:41 <retardo> I'm sorry you're sorry.
18:52:23 <retardo> Where in the report is the definition of >>= for lists?
18:54:23 <retardo> Never mind,  I found it.
18:55:11 <retardo> I really need to print out a copy of the 98 report.  Mine is from 94 and they added all sorts of good stuff
18:58:06 <retardo> I see they decided not to get rid of the n+k patterns.   I was wondering about that.
18:58:57 <Gahhh> retardo, are you getting back to Haskell after 10 years or something ?
18:59:44 <retardo> It's more like I'm finally starting to think about it seriously after 10 years of putterng.
19:01:00 <Gahhh> Wow. And I've been thinking that I'd been puttering too long. It's been 5-6 months for me.
19:01:18 <retardo> I was busy with other things for a while.  :)
19:24:37 <CoolPops> Is there a pastebin that this channel uses?
19:25:31 <Gahhh> there's a paste page at the haskell wiki I believe. no rule, though.
19:32:38 <CoolPops> http://haskell.org/hawiki/HaskellIrcPastePage ... I answered a tutorial exercise, the code works but I would like any comments. It's my first "app" of any size (41 lines, but I'm a 3 day newbie!)
19:36:40 <Gahhh> CoolPops, which one is yours ?
19:36:44 <CoolPops> With the completion of that exercise I am now on chapter 6 of YAHT :-)
19:36:51 <CoolPops> Gahhh: the top one, sorry.
19:40:03 <Gahhh> CoolPops, that looks ok to me. Well done after just three days.
19:41:01 <CoolPops> Gahhh: nothing you would change?
19:41:43 * CoolPops would be very happy if your answer is no ;-)
19:42:18 <Gahhh> CoolPops, if there's something that can be improved, I don't see it.
19:44:20 * wli attempts to bang out an SVD
19:44:35 <wli> (again)
19:45:29 <monochrom> It's quite alright
19:46:16 <CoolPops> It may not be much, but with the completion of that exercise I feel I am getting somewhere... I tackled Haskell one other time in the past and kept running into brickwalls and other things came around that seemed more important. I'm way past the point I quit last time.
19:46:41 <wli> the trouble with this stuff is that you can get things that kinda-sorta work
19:46:46 <Gahhh> CoolPops, I can relate.
19:47:00 <wli> but you have to fight endlessly to get results
19:47:32 <Gahhh> What are you saying ?
19:47:55 <CoolPops> Gahhh: I think he's talking about SVD, whatever that is.
19:47:56 <wli> and sit around nitpicking and poring over things looking for some microscopic tweak that gets numerical stability back or something
19:48:07 <wli> Singular Value Decomposition
19:48:26 <wli> numerical linear algebra in general
19:54:09 <Gahhh> wli, ah, you're still struggling with that eh
20:19:55 <wli> yes
20:20:04 <wli> garbage answers
20:20:12 <wli> no clear signs of bugs
20:23:34 <wli> I think I've narrowed it down to some bug in the Householder crap
20:23:47 <Gahhh> Householder ?
20:24:19 <wli> special kind of orthogonal matrix used for elimination strategies; in SVD's, reduction to bidiagonal form.
20:26:42 <wli> The bidiagonal matrix B implicitly represents the tridiagonal B^t*B (which in turns corresponds to the normal equations), and the further transformations of it are implicit diagonalization of B^t*B
20:27:09 <wli> In the Golub-Kahan algorithm anyway.
20:27:45 <arauko> Hello.
20:28:05 * arauko reading IFPUH yet
20:58:01 <wli> (frankly, if the code didn't make it over the K&R hump, they've already lost)
21:06:16 <arauko> Question, if i develop a program in GNU/Linux using haskell, it will run on windows?
21:07:04 <autrijus> yup.
21:07:13 <autrijus> provided that you don't use platform-specific libraries of course
21:07:18 <autrijus> otherwise it should run just fine.
21:09:22 <arauko> Ok, thanks
23:07:53 <desrt> god how i hate householder
23:40:08 <autrijus> how do I test if something is undefined?
23:41:20 <Cale> desrt: Householder's method for the finding of roots?
23:42:11 <Cale> desrt: Or the matrices?
23:42:18 <Gahhh> matrices
23:42:36 <Gahhh> I mean, wli is messing around with SVD
23:43:28 <Gahhh> Cale, do you have a maths degree ?
23:48:48 <Lemmih> autrijus: You can catch the exception with 'catch' but it may be wiser to refactor so it wont be necessary.
23:56:11 <autrijus> indeed. already refactored thusly.
23:56:12 <autrijus> thanks
23:56:27 * autrijus just realized Maybe is the canonical solution here
23:57:32 <autrijus> is there a concatMapM_ ?
23:57:39 <autrijus> I mean concatMapM
23:59:50 <Lemmih> There's no such function in the standard libraries.
