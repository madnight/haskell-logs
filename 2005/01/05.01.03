00:00:07 <shapr> just keep an AST
00:00:22 <shapr> and pretty-print it when you want human-consumable output
00:00:24 <Lemmih> Atlantic Standard Time?
00:00:31 <shapr> abstract syntax tree
00:01:44 <Lemmih> But then you'll lose the indentation information.
00:01:59 <Lemmih> " x+y" => Plus "x" "y" => "x+y"
00:02:12 <shapr> yup, you will.
00:02:37 <Lemmih> I wanna keep that information.
00:02:48 <shapr> I don't know a good way to do that.
00:03:43 <shapr> How does Proxima handle that whole problem?
00:03:46 <Lemmih> That's why I asked you if you thought it was worth the extra work.
00:03:51 <Lemmih> shapr: Yes.
00:05:57 <shapr> ?
00:11:46 <Lemmih> Struture editing is relatively easy if you just overwrite what the user wrote. Modifying the AST while keeping indentation information is harder. So do you think it's worth the extra work? In other words, how much to you appreciate your freedom of style in Haskell?
00:30:36 <mikael> hi!
00:31:44 <Lemmih> Hey phubuh.
00:32:18 <mikael> hey Lemmih.  how's your DC client coming along?  :-)
00:32:19 <Svrog> hi
00:33:39 <Lemmih> I've been kinda distracted lately.
00:34:55 <mikael> ditto.  winter does horrors to my productivity.  that and re-learning to type to use dvorak
00:36:00 <Svrog> im usually worse during summer - anything over 22 degrees C and my brain just melts
00:37:26 <mikael> air conditioning and cool beverages help :-)
00:38:18 <Svrog> hehe yeah - but proper a/c is too expensive.. can't afford it right now
01:14:37 <Lemmih> mikael: Written any spiffy Haskell code lately?
01:14:48 <mikael> nope :-(
01:51:42 <cali[uni]> ello
01:52:10 <musasabi> hello
01:52:58 <cali[uni]> sup?
01:53:51 <musasabi> trying to get into work mode after the holidays mostly.
01:54:12 <rtega> copy
01:55:13 <rtega> \lg .be
01:55:17 <rtega> oups
01:55:26 <cali[uni]> lol
01:55:38 <cali[uni]> holidays were a pain :s
01:55:45 <rtega> for me they weren't
01:56:14 <cali[uni]> lucky :)
01:57:14 <rtega> yup
01:58:35 <cali[uni]> next will be better hopefully :)
02:03:35 <autrijus> in ghc is there an easy way to open a string or a CStringLen as a handle?
02:03:47 <autrijus> to "fake" a file, so to speak
02:04:21 <musasabi> not really
02:04:30 <autrijus> :-/
02:08:45 <cali[uni]> i cant help either, sorry ;x
02:20:04 <cali[uni]> hi xerox
02:35:31 <xerox> hi cali[uni]
03:11:41 <musasabi> How much memory does parsing a 200kb file with happy take?
03:14:01 <musasabi> and is haskelldb safe to use with arbitary strings?
03:17:14 <Lemmih> musasabi: I think there has been some issues about that.
03:21:14 <musasabi> the mailing list archive seems to contain problems with that but no fixes.
03:22:29 <musasabi> 0.9 claims to have fixed some of those.
03:28:43 <musasabi> But is http://cvs.sourceforge.net/viewcvs.py/haskelldb/haskelldb/src/Database/HaskellDB/Query.hs?r1=1.51&r2=1.52&sortby=date enough.
03:29:30 <zipper> anyone know if hopengl supports opengl 2.0?
04:00:22 <vincenz>  I HOPEngl so
04:16:23 <MegaMonad> Shapr: hmm. What do you think it meant "howdy" => "how dy" => "how are you doing.
04:18:19 <Heffalump> hiya
04:23:55 <vincenz> hello
04:24:19 <CosmicRay> morning vincenz, heffalump
04:25:26 <Heffalump> did you get my email a couple of weeks ago about having haskell-http ready, btw?
04:26:02 <vincenz> no :/
04:26:23 <Heffalump> not you :-)
04:26:31 <CosmicRay> Heffalump: yes
04:26:46 <CosmicRay> Heffalump: I will probably get to it within 48 hours (back from vacation and all that)
04:26:57 <Heffalump> cool, no major rush
04:27:04 <Heffalump> just checking stuff didn't get lost
04:27:08 <CosmicRay> Heffalump: I read it once while I was sleepy, was confused by the whole orig.tar.gz thing, so I went to bed :-)
04:27:14 <CosmicRay> Heffalump: that never hurts with me :-)
04:27:33 <Heffalump> heh :-)
04:27:45 <Heffalump> I wish tar was repeatable.
04:27:56 <CosmicRay> gzip too, eh?
04:28:06 <CosmicRay> gzip embeds a timestamp in its headers
04:28:38 <Heffalump> ah
04:28:40 <Heffalump> annoying
04:28:50 <Heffalump> it might be gzip then
04:28:51 <zipper> MegaMonad is back!
04:29:10 <CosmicRay> zipper: yep, that means CosmicRay is done playing Railroad Tycoon 3 for awhile :-)
04:29:38 <zipper> that game was coded in part in lisp
04:29:47 <CosmicRay> my main desktop machine is the only one with half a gig of RAM to spare to run that megahal installation
04:29:48 <CosmicRay> really
04:29:52 <CosmicRay> I never knew that
04:31:44 <zipper> what other tasks require you to have half gig ram on your desktop?
04:32:10 <musasabi> ghc seems to require me to get more than a half giga of ram for my desktop.
04:32:44 <CosmicRay> zipper: building certain MissingH modules with ghc, for one :-)
04:32:57 <CosmicRay> my desktop actually has 1GB ram
04:33:19 <CosmicRay> so I can usually run megamonad without really noticing it
04:33:40 <CosmicRay> though I occasionally kill it when generating DVD-video discs, as the added cache really helps things
04:33:53 <zipper> just watch out for megamonad dos attacks from me :P
04:34:00 <CosmicRay> heh
04:34:13 <zipper> i once crashed fsbot here in freenode :D
04:34:34 <CosmicRay> what does fsbot do?
04:34:37 <zipper> i think i had him evaluate 10000! or something
04:34:51 <CosmicRay> heh
04:34:52 <zipper> he can evaluate lisp exressions and he does some other chat related stuff
04:35:01 <CosmicRay> lambdabot was too smart to crash on that
04:35:12 <CosmicRay> though I did crash it once, but I forget how
04:36:20 <zipper> they should just put a time limit for fsbot for calculations
04:37:04 <CosmicRay> that appears to be what lambdabot does
04:37:22 <CosmicRay> I think the problem was quick calculations that produce huge output
04:37:34 <CosmicRay> hello lordmetroid
04:39:47 <musasabi> like "let xs = '0':xs in xs"
04:41:21 <zipper> just put a limit on memory allocation then :)
04:41:57 <CosmicRay> zipper: Yes, that already exists.  The default action is to terminate the process :-)
04:42:26 <zipper> so how could you crash it then? :)
04:42:54 <CosmicRay> its process terminated, of course :-)
04:43:06 <zipper> oh
04:43:32 <zipper> you should do the calculations in a sub process then :)
04:43:40 <CosmicRay> tell shapr :-)
04:44:09 <CosmicRay> actually, he knows... he was around when it crashed
04:45:17 <zipper> lambdabot: 1 + 1
04:45:18 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
04:45:24 <CosmicRay> @eval 1+1
04:45:25 <lambdabot> 2
04:45:32 <CosmicRay> @type repeat
04:45:36 <lambdabot> repeat :: forall a. a -> [a]
04:45:41 <CosmicRay> hm.
04:45:43 <CosmicRay> @type replicate
04:45:44 <lambdabot> replicate :: forall a. Int -> a -> [a]
04:45:53 <CosmicRay> replicate 10 ["Hello", "Lambdabot"]
04:46:02 <CosmicRay> @eval replicate 10 ["Hello", "Lambdabot"]
04:46:03 <lambdabot> [[Hello, Lambdabot], [Hello, Lambdabot], [Hello, Lambdabot], [Hello, Lambdabot
04:46:03 <lambdabot> , [Hello, Lambdabot], [Hello, Lambdabot], [Hello, Lambdabot], [Hello, Lambdabot
04:46:03 <lambdabot> , [Hello, Lambdabot], [Hello, Lambdabot]]
04:46:10 <CosmicRay> you get the idea... ;-)
04:46:47 <zipper> hm... kickflood...
05:03:48 <Heffalump> oh yeah, CosmicRay: did you see the bug I raised against haskell-hsql? Does it seem reasonable? (about needing to depend on all the database -dev packages)
05:11:02 <CosmicRay> Heffalump: yes
05:11:23 <CosmicRay> Heffalump: I saw that, didn't put it together that it was you.
05:11:26 <CosmicRay> I'll do some testing
05:11:40 <CosmicRay> I had assumed the -dev packages would not be necessary since it would only need the .so at link time
05:11:44 <CosmicRay> but perhaps I was mistaken
05:12:00 <CosmicRay> unfortunately there is no clean way to depend on the correct version of the -dev packages, sigh.
05:12:04 <Heffalump> well, you didn't depend even on the non -dev packages
05:12:10 <CosmicRay> ah.
05:12:16 <CosmicRay> that is certainly an oversight then
05:12:19 <Heffalump> it's possible I'm wrong about needing the -dev packages, actually
05:12:25 <Heffalump> so you should try the non -dev ones first
05:14:28 <Heffalump> I suspect shlib:Depends can't work out what to do even for the non -dev packages
05:14:34 <Heffalump> cos there's no .so
05:14:38 <CosmicRay> that's right
05:18:56 <Heffalump> I think ghci probably just needs the .so, but ld (invoked by ghc) will demand the .a
05:20:34 <CosmicRay> the database libs are dynamically linked in
05:21:36 <Heffalump> right, but actually linking programs that will be dynamically linked, requires the .a files, IIRC
05:21:51 <Heffalump> and ghc passes the -l flags for the libraries listed in packages.conf to ld when linking things
05:23:34 <CosmicRay> hmm.
05:23:39 <musasabi> Is there a way to get ghci to work with libraries containing weak symbols?
05:23:43 <CosmicRay> I didn't know that it required the .a files.
06:37:19 * pyoko gone: shower
06:37:31 * Heffalump fumes at HaskellDB
06:48:44 <termol> are >>= and =<< similar commands?
06:48:57 <termol> @type >>=
06:48:58 <lambdabot> bzzt
06:49:03 <Heffalump> @type (>>=)
06:49:04 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
06:49:09 <Heffalump> @type (=<<)
06:49:10 <lambdabot> (=<<) :: forall b m a. (Monad m) => (a -> m b) -> m a -> m b
06:49:25 <Heffalump> looks like (=<<) = flip (>>=)
06:49:40 <termol> so it's just a matter of taste which one you use?
06:49:58 <termol> @type (<<)
06:49:59 <lambdabot> bzzt
06:50:10 <termol> @type (>>)
06:50:11 <lambdabot> (>>) :: forall m b a. (Monad m) => m a -> m b -> m b
06:50:47 <termol> maybe not...
06:52:58 <autrijus> hmm no sqlite3 support :-/
06:54:26 <autrijus> will it make more sense to hack hsql or to write a native binding?
06:54:53 <wli> Can HSQL talk to Oracle yet?
06:55:23 <autrijus> doesn't seem like so
06:55:46 * wli =(
06:56:02 <autrijus> you can always use odbc
06:56:05 <autrijus> and suffer the penalty
06:56:19 <wli> Well, I wanted to do stuff on Linux.
06:56:57 <autrijus> there's unixodbc.
06:58:01 <wli> hmm, that could be useful then
07:18:27 <TheHunter> hmm, no instance Functor ((,) a) anywhere in the libraries? weird.
07:35:41 <autrijus> when compiling the example in hsql it says
07:35:42 <autrijus> : undefined reference to `__stginit_DatabaseziHSQL_'
07:35:52 <autrijus> the command line was
07:35:53 <autrijus> ghc -package hsql --make Main.hs
07:35:56 <autrijus> what could be the problem?
07:52:23 <autrijus> gah.
07:52:24 * autrijus gives up hsql
07:52:32 <autrijus> I'll write the hsc myself :-/
08:02:25 <Heffalump> autrijus: what OS are you using?
08:04:40 <autrijus> freebsd
08:04:58 <zipper> how much did you donate?
08:05:36 <autrijus> to freebsd foundation?
08:05:56 <zipper> yes
08:06:08 <autrijus> I didn't hear about it until they said they no longer urgently need it
08:06:09 <autrijus> so $0
08:06:27 <Heffalump> why'd they need it?
08:06:54 <autrijus> because they have too much large donations and need enough small ones to retain their 501c3 status
08:06:57 <autrijus> iirc
08:07:51 <autrijus> how do I allocate a void pointer?
08:07:56 <autrijus> I tried
08:07:57 <autrijus>                 sqlite <- mallocBytes (sizeOf nullPtr)
08:08:11 <autrijus> but apparently it doesn't like me
08:08:34 <Heffalump> yeah, I just read the page
08:08:40 <Heffalump> kind of odd that they had too much money :-)
08:08:54 <Heffalump> and even more odd that they therefore needed more to sort it out
08:09:07 <autrijus> typedef struct sqlite3 sqlite3;
08:09:14 <autrijus> that's the C struct in question
08:09:33 <autrijus> (<- alloc) complains that () is not Storable
08:24:41 * TheHunter is playing with Ashley Yakeley's GADT code.
08:27:09 <Philippa> I skipped to the paper Conor mentioned, which is currently damaging my brain while I try to figure something out
08:27:27 <Philippa> though I really ought to just grab hold of Conor for a chat one of these days
08:46:37 <TheHunter> @eval (\x -> x x) id 1
08:46:38 <lambdabot> 1
08:49:10 * autrijus misses CPAN :-/
08:51:43 <Heffalump> I think a Haskell equivalent should appear once the LIP (Cabal) is more mature
08:54:37 <termol> how to strip the whitespace from a string in haskell?
08:55:19 <TheHunter> @type filter
08:55:20 <lambdabot> filter :: forall a. (a -> Bool) -> [a] -> [a]
08:55:31 <musasabi> @type isSpace
08:55:33 <lambdabot> bzzt
08:55:39 <musasabi> @type Char.isSpace
08:55:40 <lambdabot> Char.isSpace :: Char -> Bool
08:55:49 <termol> thx!
08:58:00 <termol> so filter (not . isSpace) "this is a string"           is a good solution?
08:58:13 <CosmicRay> if you want "thisisastring", sure.
08:58:27 <termol> that is what i want.
08:58:38 <CosmicRay> @eval filter (not . isSpace) "this is a string"
08:58:38 <lambdabot> thisisastring
08:58:45 <CosmicRay> termol: lambdabot is helpful
08:58:48 <CosmicRay> MegaMonad: are you helpful?
08:58:49 <MegaMonad> CosmicRay: I could use the lexer split it into cvs? I still get email from me trying to write and release it so helpful. I'd like to see how stuff works.
08:59:00 <termol> can i be even more compact than this?
08:59:26 <CosmicRay> well you could put that in a function :-)
08:59:32 <CosmicRay> or you could maybe use some regex stuff
08:59:37 <CosmicRay> but really, that's about as compact as it gets
08:59:45 <CosmicRay> let removews = filter (not . isSpace)
08:59:55 <musasabi> trim = filter (== ' ')
09:00:27 <musasabi> of course that only removes ' ', if you want to strip other whitespace characters you should use isSpace.
09:00:44 <termol> is regex included in hugs?
09:01:20 <musasabi> make that trim = filter (/= ' ')
09:01:23 <musasabi> (c
09:08:23 <autrijus> yay!
09:08:27 * autrijus finished hsql port to SQLite3
09:11:11 <CosmicRay> sweet
09:11:41 <CosmicRay> are you going to get that integrated with the sf hsql distribution?
09:12:11 <musasabi> nice. please do integrate it.
09:12:29 <autrijus> who do I mail to?
09:12:55 <autrijus> oh, Krasimir
09:13:25 <autrijus> doing pointer arithmetic in haskell is addictive.
09:13:35 <autrijus> although utterly devoid of productivity
09:29:58 <SyntaxNinja> can anyone refer me to case studies that demonstrate that Haskell is better for faster development or more relyable code?
09:30:08 <SyntaxNinja> I'd also like to know about other functional languages, I guess.
09:32:02 <musasabi> I don't think such case studies can be done very well.
09:35:05 <SyntaxNinja> musasabi: why? because there are too many variables in any development task?
09:35:31 <TheHunter> this one's kinda old and you probably know it: http://www.cs.chalmers.se/ComputingScience/Research/Functional/Fudgets/haskell-vs-ada-abstract.html
09:35:37 <CosmicRay> SyntaxNinja: not a case study per se, but: http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
09:36:32 <SyntaxNinja> CosmicRay: yeah, that's the one I know about :) does anyone have the original paper he refers to?
09:37:17 <CosmicRay> SyntaxNinja: my understanding is that it is very lightly modified from it
09:37:23 <SyntaxNinja> OK
09:37:38 <CosmicRay> you could always e-mail Hughes and ask, I suppose
09:37:40 <SyntaxNinja> I wonder why he apologizes for the examples not being in Haskell? because no one knows Miranda?
09:38:06 <CosmicRay> SyntaxNinja: he seems to be a haskell fan
09:38:23 <CosmicRay> he wrote QuickCheck, for example
09:39:52 <SyntaxNinja> yeah
09:40:13 <musasabi> SyntaxNinja: because there are too many variables and humans..
09:40:29 <arjanb> and Miranda isn't freely available
09:40:30 <SyntaxNinja> I guess he's saying, "If I were to write the paper today, the examples would be in haskell"
09:40:48 <SyntaxNinja> TheHunter: thanks for that one
09:41:06 <CosmicRay> SyntaxNinja: I bet there is some good erlang stuff out there
09:43:25 <musasabi> That paper points one of the problems - "the largest of the prototypes was only 1200 lines of code".
09:48:06 <SyntaxNinja> musasabi: yeah
09:48:16 <SyntaxNinja> yeeeha!
09:48:23 <rtega> split the net!
09:49:04 <musasabi> And those papers are usually written when the authors design a program and notice the haskell solution is ncie, short and elegant.
09:49:30 <musasabi> *nice
09:49:49 <rtega> anybody an idea if there are still people working on quantumcomputing in haskell btw?
09:50:27 <musasabi> I think someone referred to some quantum computation stuff on the list recently - but I don't really have any idea.
09:50:53 <rtega> where a lot of things turn out to be rather trivial with comparison to imperative langs
09:51:13 <rtega> musasabi: which list?
09:52:32 <musasabi> rtega: haskell-cafe "Problems with fundeps"
09:52:35 <SyntaxNinja> rtega: there were a bunch of talks on quantum computing at ICFP '03
09:53:04 <rtega> aha
09:53:38 <rtega> cause it's supposed to be part of my thesis which deals with a comparison of language for scientific computing
09:54:42 <rtega> does somebody know other applications of haskell in that context?
10:08:12 <termol> how can i strip away all the whitespace AND the alphanumerical characters from a string?
10:08:33 <musasabi> filter
10:08:53 <termol> yes. but what should the predicate look like?
10:09:26 <musasabi> depends on your definition of alphanumeric..
10:09:58 <termol> isAlpha
10:09:59 <musasabi> filter (\c -> not (isAlphaNum c || isSpace c))
10:10:05 <musasabi> s/Num//
10:11:05 <termol> not with no dot after?
10:11:26 <musasabi> @type (.)
10:11:27 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
10:11:28 <Heffalump> pardon?
10:12:03 <termol> musasabi: your solution seems to work
10:12:22 <termol> i had a dot after not. that didn't work
10:12:54 <musasabi> (.) is for function composition.
10:13:20 <Heffalump> before what you had was filter (not . isSpace)
10:13:28 <Heffalump> which is shorthand for filter (\c -> not (isSpace c))
10:13:43 <Heffalump> but it doesn't extend to the more complicated case above
10:13:57 <termol> Heffalump: yes, i realize that now. have to keep that in mind.
10:14:27 <musasabi> Heffalump: you could probably do that in the pointless style but that would be horrible.
10:14:42 <Heffalump> best would be to define a lifted combinator
10:14:53 <Heffalump> (f .|| g) c = f c || g c
10:15:11 <Heffalump> then you could write filter (not . (isAlpha .|| isSpace))
10:15:29 <wli> I have a typeclass thing that generalizes to function lattices etc.
10:29:27 <SyntaxNinja> ha! this channel has twice as many people as #ocaml!
10:30:35 <Heffalump> perhaps Haskell is twice as hard to use
10:30:46 <SyntaxNinja> hmm
10:30:49 <SyntaxNinja> mabye we're just more friendly
10:31:15 <SyntaxNinja> I just jumped on there, and smerdyakov says "Wow.  SyntaxNinja descends from the ivory tower! ;)" but he's just being funny
10:31:36 <rtega> lol Heffalump 
10:31:38 <Heffalump> it's that kind of funniness that got shapr to ban him from here :-)
10:32:37 <jadrian> hello
10:32:41 <musasabi> hello
10:32:52 <SyntaxNinja> hi jadrian
10:32:56 <jadrian> hi SyntaxNinja 
10:33:00 <jadrian> hi musasabi  
10:33:17 <musasabi> seems that #haskell is 1/3 #c approximately.
10:33:28 <SyntaxNinja> we should get smerd to join #c ;)
10:35:16 <jadrian> I got a container that needs fast access using type K as a key
10:35:39 * SyntaxNinja is still looking for papers "proving" how much better FP is than regular programming, if anyone kows of some, let me know.
10:36:01 <jadrian> after a successful search that returns "k" I know it's ok to remove all the elements that were inserted before "k"
10:36:30 <jadrian> are there any common purely functional structures for that?
10:36:32 <ski> what for ?
10:36:48 <jadrian> ski: what do I needs this for?
10:36:59 <jadrian> ski: or why do I need to remove them?
10:37:30 <ski> sorry ?
10:37:30 * ski doesn't understand the question
10:37:44 <ski> jadrian : it may be you tried to refer to SyntaxNinja ?
10:38:10 <jadrian> ski: I thought you were questioning me...
10:38:15 <jadrian> <ski> what for ?
10:38:28 <autrijus> http://aut.dyndns.org/sqlite3.diff # in case people want it
10:38:45 <SyntaxNinja> MegaMonad: is ski talking to me, or to jadrian?
10:38:46 <MegaMonad> SyntaxNinja: Jadrian is interested in talking to you and then quotenting is something other than hbc?
10:39:12 <jadrian> SyntaxNinja: I'm confused enough without MegaMonad in the conversation! :)
10:39:17 <SyntaxNinja> jadrian: hah
10:39:31 <musasabi> SyntaxNinja: I don't think good comparisons exist for any given language.
10:39:54 * jadrian will just keep using a finiteMap and will not remove any elements
10:39:56 <SyntaxNinja> musasabi: I know. I want them anyway, sorry :)
10:40:18 <musasabi> or they do exist but are FUD.
10:41:50 <ski> (SyntaxNinja : you, fwiw)
10:42:21 <SyntaxNinja> ski: something for management types like, "Give FP a chance"
10:42:44 <ski> huh ?
10:43:00 * ski was wondering about the #c and smerd ..
10:43:03 <SyntaxNinja> ski: oh
10:43:13 <SyntaxNinja> man.
10:43:29 <ski> fragbot: who are you ?
10:43:47 <fragbot> not a bot if that's what you're asking
10:43:49 * ski wonders if fragbot is a bot
10:44:03 <SyntaxNinja> ski: it was a joke; the idea is that #haskell has more people than #ocaml because it's more friendly.
10:44:29 <SyntaxNinja> ski: someone pointed out that #c has more people than #haskell, so I was wondering what would happen if smerd joined #c
10:44:42 <TheHunter> hey ski, i just realized the S combinator is in the haskell libs...
10:44:46 <ski> SyntaxNinja : you want to evacuate #c ?
10:44:51 <Heffalump> what's the name of operator with type Monad m => m (m a) -> m a
10:44:51 <TheHunter> it's called ap
10:44:51 <Heffalump> ?
10:44:56 <musasabi> SyntaxNinja: well I don't think that you can convince management with scientific papers.. But FUD for convincing them might be nice...
10:45:00 <TheHunter> Heffalump, join
10:45:02 <Heffalump> ta
10:45:06 <musasabi> join
10:45:07 <ski> TheHunter : more or less, yah
10:45:19 <SyntaxNinja> fragbot: what does a sunset sound like?
10:45:22 <SyntaxNinja> ;)
10:46:10 <fragbot> when I lived in Philadelphia, it mainly sounded like sirens. . .of course, so did sunrises
10:46:15 <SyntaxNinja> ski: not particularly, just as an experiment to test my thesis
10:46:23 * SyntaxNinja is convinced that fragbot is human
10:47:11 <fragbot> I guess I should've answered, "why do you want to know what a sunset sounds like?". . .or something
10:47:26 <Heffalump> hmm. A module whose main function writes out some of the files that the module depends on.
10:47:31 <Heffalump> A tad dangerous, perchance?
10:49:12 <SyntaxNinja> Heffalump: huh? are you talking about cabal?
10:50:37 <Heffalump> nono, something I'm writing
10:50:40 <Heffalump> uses haskelldb
10:51:03 <SyntaxNinja> musasabi: I'm OK with FUD
10:51:25 <SyntaxNinja> Heffalump: OK good :)
10:54:40 <SyntaxNinja> fragbot: got Haskell questions? I see you're on #ocaml. they're lame over there, you should leave ;)
10:55:16 <CosmicRay> fragbot: yes, MegaMonad thinks ML users are weenies :-)
10:55:22 <autrijus> instance Binary PGD where
10:55:22 <autrijus>     put_ bh (PGD a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11) = do
10:55:22 <autrijus>         put_ bh a1
10:55:32 <autrijus>         put_ bh a2  -- and so on
10:55:39 <autrijus> please tell me there's a better way to do this :-/
10:55:42 <autrijus> (PGD is a record.)
10:56:14 <autrijus> i.e. iterate over all record elements
10:56:27 <ski> MegaMonad: Do you really think ML users are weenies ?
10:56:29 <MegaMonad> ski: Ist says that it would allow me to the ml in the users are an equal opportunities language.
10:56:56 <autrijus> MegaMonad: how do I iterate over record elements?
10:56:57 <MegaMonad> autrijus: I'll give you a list of elements is a record.
10:57:15 <autrijus> MegaMonad: but how to iterate over them?
10:57:16 <MegaMonad> autrijus: I know for sure, though, i'm still trying to iterate the list hasn't been a conflicting old .hi file.
10:57:17 <CosmicRay> @wiki MegaMonad
10:57:18 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
10:57:19 <ski> CosmicRay : hmm, that could maybe be interpreted as a contrary claim by it
10:57:27 <CosmicRay> autrijus: you may want to read that before asking him too much
10:57:33 <autrijus> I know what MegaMonad is :)
10:57:38 <CosmicRay> autrijus: oh ok :-)
10:57:51 <CosmicRay> autrijus: just making sure, given http://www.haskell.org/hawiki/MegaMonad_2fPassingTuringTest :-)
10:58:06 <ski> hehe
10:58:19 <autrijus> I also wrote harvesting chatterbots and MegaMonad looks quite good
10:58:28 <CosmicRay> autrijus: oh?
10:59:01 <Heffalump> does the Turing test cover pretending to be a stoned human?
10:59:18 <autrijus> CosmicRay: yeah. mine's in chinese though.
10:59:38 <CosmicRay> autrijus: MegaMonad is just a MegaHAL (megahal.alioth.debian.org) trained on the logs from this channel
10:59:41 <CosmicRay> Heffalump: grin
10:59:52 <CosmicRay> autrijus: did you write your own ai engine or use someone else's?
10:59:54 <autrijus> but there's reallly no way to iterate over a record?
10:59:56 <autrijus> CosmicRay: I wrote my own
10:59:58 <CosmicRay> autrijus: correct
11:00:14 <CosmicRay> autrijus: is it tied to chinese or could it work with english with a little hacking?
11:00:27 <ski> autrijus : maybe "put_ bh (PGD a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11) = do mapM_ (put_ bh) [a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11]" ? (if they are same type)
11:00:31 <CosmicRay> I'm not all that pleased with megahal but it seems the best I could find that 1) works with linux and 2) has source
11:00:38 <autrijus> ski: they of course are not
11:00:42 <srid> just started learning common lisp .. so far it is not pleasing
11:00:45 <autrijus> CosmicRay: it's built over a fuzzy reverse index search engine
11:00:51 * srid thinks he must switch to haskell
11:00:57 <autrijus> CosmicRay: and really depends on the fact that chinese has no spaces :)
11:00:58 <Heffalump> from what?
11:01:12 <srid> from list-n00b
11:01:12 <CosmicRay> srid: yes, feel the anger in you.  Join the, erm, light side. 
11:01:14 <srid> *lisp
11:01:29 <srid> light side?
11:01:30 <CosmicRay> srid: what other languages do you know?
11:01:31 * autrijus reasoned that only THaskell can come to rescue
11:01:36 * autrijus plunges in
11:01:37 <CosmicRay> srid: sorry, Star Wars reference...
11:01:39 <srid> python
11:01:41 <SyntaxNinja> srid: haskell is great :)
11:01:42 <srid> c,java before that
11:01:47 <SyntaxNinja> autrijus: I was just about to suggest that :)
11:01:59 <autrijus> SyntaxNinja: I'd appreciate if there's an example of that :)
11:01:59 <CosmicRay> srid: ah ha.  you will *love* haskell.
11:02:00 <CosmicRay> :-)
11:02:05 <autrijus> SyntaxNinja: the paper is way way over my head. :)
11:02:11 <CosmicRay> srid: what sorts of problems do you tend to solve with your programs?
11:02:25 <autrijus> SyntaxNinja: oh nvm, I found one in the user guide just one
11:02:26 <srid> what new skills will one gaim through lisp?
11:02:28 <SyntaxNinja> srid: if you like python, you'll love Haskel, but you might want to pick up the new FilePath module if you're going to be working with the filesystem a lot
11:02:35 <CosmicRay> srid: there are an astonishingly large number of PYthon converts here
11:02:35 <SyntaxNinja> @wiki TemplateHaskell
11:02:36 <lambdabot> http://www.haskell.org/hawiki/TemplateHaskell
11:02:39 <autrijus> there's a new filepath module?
11:02:52 <SyntaxNinja> autrijus: I put some examples there, or I updated them or something
11:02:56 <SyntaxNinja> autrijus: yeah, finally :)
11:02:57 <CosmicRay> srid: with lisp, the ability to replace the ( and ) keys on your keyboard.
11:02:59 <ski> (autrijus : well, it wasn't obvious, i think ..)
11:03:01 <srid> i am learning langauges to develop my programming skills
11:03:13 <CosmicRay> srid: let me giev you some links.
11:03:14 <autrijus> ski: ok, sorry. otherwise I'd have used a list as the representation
11:03:21 <autrijus> or a finitemap
11:03:24 <srid> ok
11:03:26 <CosmicRay> srid: this is, imho, the best haskell tutorial: http://www.isi.edu/%7Ehdaume/htut/
11:03:35 <srid> YAHT?
11:03:36 <CosmicRay> srid: here is the standard library reference: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
11:03:44 <CosmicRay> srid: Yet Another Haskell Tutorial, yes.
11:03:52 <SyntaxNinja> autr: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/System/FilePath.hs
11:04:11 <ski> (autrijus : not necessarily if wanted to enforce exactly 11 elems ..)
11:04:14 <CosmicRay> srid: if you do much with IO, you may be interested in this library: http://quux.org/devel/MissingH
11:04:22 <CosmicRay> srid: it also has some happy little pythonisms :-)
11:04:22 <srid> does haskell have python like namespaces (module)?
11:04:23 <autrijus> ski: indeed. sorry
11:04:26 <CosmicRay> srid: yes
11:04:39 <CosmicRay> srid: including equivolents of import and from x import y
11:04:43 <srid> not like c++,java namespaces
11:04:50 <srid> module.attribute
11:05:02 <CosmicRay> yes, although a module is not an object in Haskell.
11:05:12 <CosmicRay> haskell can also be compiled or interpreted.
11:05:23 <srid> hmm ..
11:05:24 <CosmicRay> the most common compiler is ghc and the most common interpreter is hugs.
11:05:26 <autrijus> I wonder if anything is an object in haskell.
11:05:52 * SyntaxNinja passes autrijus a function
11:06:03 * autrijus notes that a function only has the "apply" method
11:06:14 <Heffalump> I'd suggest existentially quantified datatypes
11:06:28 <Heffalump> (exists a . Foo a => a)
11:06:33 <CosmicRay> autrijus: it depends on what you mean by an object.
11:06:41 <autrijus> CosmicRay: in the OO sense :)
11:06:45 <CosmicRay> autrijus: definately not in the OOP sense.  Haskell has no objects in that sense.
11:06:51 * autrijus nods
11:06:56 <autrijus> strangely I don't miss it.
11:07:00 <CosmicRay> autrijus: on the other hand, in Haskell, almost everything is a function.  Which, imho, is even more powerful.
11:07:10 <Heffalump> I'd say that the thing I mentioned is an object in the OOP sense.
11:07:10 * SyntaxNinja takes his function back from autrijus, then
11:07:15 <CosmicRay> autrijus: exactly.  It doesn't have OOP because it doesn't need to.  (Though typeclasses start to blur that line)
11:07:28 <Heffalump> cos it's data together with some methods that act on it
11:07:40 <Heffalump> and you can downcast if there's some class Bar a => Foo a
11:07:52 <Heffalump> maybe I mean upcast. The type-safe one, anyway.
11:08:03 <CosmicRay> the thing is, in Haskell, a function can be data together with some methods.
11:08:05 <CosmicRay> Or not. 
11:08:08 <CosmicRay> whatever you like.
11:08:13 <srid> arrow syntax sux
11:08:20 <Heffalump> a single function doesn't have much of an interface
11:08:23 <SyntaxNinja> I should write a case study on "using the right tool for the job" :)
11:08:29 <Heffalump> srid: if you're new to Haskell, playing with arrow syntax isn't a good idea.
11:08:30 <CosmicRay> heh
11:08:46 * SyntaxNinja hopes that srid didn't jump straight into Arrows
11:08:59 <CosmicRay> yes, arrows are not for the newbie.
11:09:00 * srid is just looking at the examples
11:09:05 <autrijus> <- ... -<
11:09:08 <CosmicRay> actually I'm no longer a Haskell newbie and I still can't figure 'em out
11:09:22 <CosmicRay> srid: there are a lot of things about haskell that will probably be surprising from your background.
11:09:26 * SyntaxNinja thought it was cute
11:09:30 <srid> only thing that attracts me to haskell is 'less bugs'
11:09:39 <autrijus> another is "much faster code"
11:09:43 <srid> i mean i saw this in website
11:09:44 <CosmicRay> srid: for instance, haskell has no notion of a for or while loop, because it doesn't need it.
11:09:51 <autrijus> oh and "shorter programs" too
11:10:05 <CosmicRay> srid: it's easier to "think" in Haskell than in inperitive languages
11:10:06 * SyntaxNinja finds Haskell code much easier to reason about.
11:10:24 <CosmicRay> srid: meaning it takes less time to write or modify programs.
11:10:31 <zippy> doesn't haskell have for and while loops in the IO monad?
11:10:37 <CosmicRay> zippy: no
11:10:39 * autrijus shuts up and works on bringing cpan to haskell for real
11:10:42 <CosmicRay> zippy: though one could write one.
11:10:51 <CosmicRay> autrijus: you are aware of hackage, right?
11:11:05 <autrijus> CosmicRay: yes. but I mean the real cpan.
11:11:10 <CosmicRay> but again, there's little point, since recursion works in the IO monad too.
11:11:10 <autrijus> the one with 8000 modules on it :)
11:11:13 <autrijus> <- writing Inline::Haskell
11:11:14 * srid downloads darcs
11:11:16 <Heffalump> why would haskell want the real cpan?
11:11:17 <Heffalump> oh.
11:11:20 <CosmicRay> autrijus: ah.
11:11:22 <CosmicRay> autrijus: evil.
11:11:22 <Heffalump> I considered that once.
11:11:31 <Heffalump> and then I woke up from my nightmare.
11:11:42 <CosmicRay> autrijus: so you are saying one could call Haskell from Perl?  Or Perl from Haskell?
11:11:45 <autrijus> Heffalump: I want my http://search.cpan.org/~autrijus/
11:11:47 <autrijus> CosmicRay: both ways.
11:11:52 <autrijus> CosmicRay: I did it with Inline::MzScheme
11:11:53 <CosmicRay> autrijus: ok well that is slick.
11:11:55 <autrijus> and ghc looks easier.
11:12:11 <CosmicRay> autrijus: you may be itnerested in perl4caml and pycaml, Perl and Python interfaces to ocaml
11:12:18 <autrijus> yup, I've surveyed both
11:12:28 <autrijus> Inline::MzScheme comes with this cute "mzperl" thing that lets you do continuations in perl.
11:12:33 <CosmicRay> autrijus: personally I would be most interested in a python interface to ocaml, followed closely by a java or .net interface
11:12:35 <srid> what is .lhs file?
11:12:49 <CosmicRay> srid: it is a different way of mixing comments with code
11:12:55 <CosmicRay> srid: instead of comments being "special", code is.
11:13:03 <srid> hmm
11:13:07 <SyntaxNinja> autrijus: what are you working on wrt cpan?
11:13:12 <CosmicRay> srid: the code will be in lines that start with > or between \begin{code} and \end{code} blocks.
11:13:35 <CosmicRay> srid: haskell compilers/interpreters can handle them directly, or you can use the unlit tool to transform them to .hs files
11:13:37 <autrijus> SyntaxNinja: wrt cpan?
11:13:56 <autrijus> SyntaxNinja: I have lots of code on cpan and I'd like to use them in haskell and vice versa.
11:14:00 <SyntaxNinja> autrijus: oh, you're working on a call-between-haskell-and-perl tool?
11:14:04 <CosmicRay> srid: btw http://www.python.org/cgi-bin/moinmoin/PythonVsHaskell
11:14:09 <autrijus> SyntaxNinja: yeah.
11:14:21 <srid> thanks for that link
11:14:22 <CosmicRay> SyntaxNinja: I think he should  perform his computations in the Evil monad.
11:14:25 <srid> i missed that
11:14:29 <SyntaxNinja> this reminds me of a paper on haskell & dot-net called "calling heaven from Hell and vice-versa" or something
11:14:38 <autrijus> right. that paper is very enlightening
11:14:44 <CosmicRay> what is the deal about haskell and .net anyway.
11:14:53 <Heffalump> the Daan Leijein and Erik Meijer paper?
11:14:55 <CosmicRay> I keep seeing rumblings of things happennig, but can never track down working code
11:14:58 <Heffalump> Leijen
11:15:06 <Heffalump> CosmicRay: I don't think there's anything active.
11:15:06 * SyntaxNinja noticed CosmicRay's email asking same question
11:15:10 <CosmicRay> hugs supposedly works with .net but doesn't come with enough to do it.
11:15:18 <Heffalump> GHC started developing a backend to do it, but never finished it.
11:15:21 <CosmicRay> and MS Cambridge supposedly was porting ghc (and we all know who that means...)
11:15:27 <autrijus> CosmicRay: on the contrary, I'm implementing ways to call mark perl functions as pure functions
11:15:33 <Heffalump> And hugs did release something, but if you can't make it work then there's probably noone making it work
11:15:38 <autrijus> using Unsafe in the backend of course
11:15:39 <CosmicRay> autrijus: interesting
11:16:12 <CosmicRay> Heffalump: I don't recall just now what the problem was, but I believe it was that they wrote their glue code in Visual Basic, which of course is useless to me on a Mono platform
11:16:37 <autrijus> actually I thought VB.Net can run on mono?
11:16:41 <CosmicRay> there've also been Java rumblings, and there was some actual code there, but it was several years old...  it was a JNI bridge deal.
11:16:42 <CosmicRay> hmm.
11:16:47 <CosmicRay> autrijus: it can once compiled.
11:16:54 <autrijus> right, which is all you need
11:16:55 <CosmicRay> autrijus: afaik there is no VB compiler for mono
11:17:00 <CosmicRay> autrijus: I don't have windows
11:17:02 <autrijus> there's VB itself.
11:17:03 <autrijus> ah.
11:17:08 <autrijus> well then
11:17:13 * autrijus suggests wine
11:17:15 <CosmicRay> autrijus: let alone whatever megabucks microsoft wants for that beast
11:17:16 <CosmicRay> heh
11:17:23 <CosmicRay> wine and a fine bittorrent client near me? :-)
11:17:33 <autrijus> I didn't say that :)
11:17:39 <Heffalump> can't you just get someone to compile the VB for you once and use the compiled version?
11:17:47 <Heffalump> Perhaps even decompile it to C# for future use ;-)
11:17:54 <autrijus> sounds good.
11:18:12 <CosmicRay> well the other problem is that it's not useful to me even if I did do that, because that compilation would not be reproducable with Free software, and thus the result couldn't go into Debian
11:18:39 <Heffalump> would be if you decompiled to C# and then declared that the canonical version for making modifications
11:18:43 <SyntaxNinja> hm. that python-v-haskell page isn't editable unless you log in or something?
11:18:46 <Heffalump> which it would be if you cleaned it up a bit
11:19:05 <autrijus> yeah. code produced by nonfree software may be free.
11:19:15 <Heffalump> or indeed just rewrote the VB in C#, which might not be that hard
11:19:36 <Nioate> SyntaxNinja: apparently
11:19:44 <CosmicRay> Heffalump: mono has a project to do that
11:19:46 <SyntaxNinja> Heffalump: i'm pretty sure that would be VeryUnFree software, and CosmicRay would rather punch himself in the face than do something like that ;)
11:19:59 <Heffalump> SyntaxNinja: what would?
11:20:01 <SyntaxNinja> er, the former
11:20:09 <Nioate> SyntaxNinja: you can click on UserPreferences to create an account
11:20:11 <SyntaxNinja> decompiling it and putting it in debian
11:20:12 <Heffalump> if the VB was under a free licence, any of what I suggested would be fine
11:20:25 <Heffalump> if it's not, then Hugs.NET probably isn't either and you're screwed anyway
11:20:31 <SyntaxNinja> Nioate: not worth it, I just wanted to point out that there are two interpreters for Haskell
11:20:39 <Nioate> SyntaxNinja: what's the other one?
11:20:42 <SyntaxNinja> ghci
11:20:51 <Nioate> I thought that was an interactive compiler
11:21:06 <Heffalump> no, it does interpret a bytecode
11:21:23 <Heffalump> but in practice it's even less portable than ghc itself, so loses one of the standard benefits of having an interpreter
11:29:48 <autrijus> what does "LamE" stand for?
11:31:46 <ski> (guessing) possibly a constructor for abstract syntax of an expression (the 'E') of the lambda form (the 'Lam')
11:32:14 <ski> autrijus : is that from THaskell or from some interpreter or something ?
11:32:33 <autrijus> yeah, THaskell.
11:36:18 * Calister waves
11:37:03 * SyntaxNinja waves to Calister
11:37:10 <Calister> :)
11:37:12 <Calister> heya
11:37:13 * ski rocks chair
11:37:19 * xerox boings
11:37:20 <basti_> hi cali
11:38:09 <Calister> ^_^
11:38:26 <ski> Calister : nick related to calista ?
11:38:56 <basti_> wasnt there a cat in "cats" called mac alister or something?
11:39:28 <Calister> hmm.. actually.. i just hadda think of a nick.. and somehow this came up. no clue how so
11:42:04 <Calister> ^_^
11:42:13 <Calister> im female.. i dont need reasons ;d
11:42:21 <autrijus> on the wiki there is an example of THaskell that converts a list to a tuple
11:42:28 <autrijus> is there a way to convert a tuple to a list?
11:42:40 <autrijus> $(listFromTuple 3) (a,b,c) ==> [a,b,c]
11:43:07 <bourbaki> moin
11:43:13 <Calister> ello
11:43:59 <musasabi> autrijus: yes that is possible.
11:44:18 <musasabi> autrijus: you can do it without TH for small tuples ;)
11:44:46 <SyntaxNinja> Calister: have haskell questions?
11:45:00 <musasabi> class TupleToList a b | a -> b where tupleToList :: a -> b
11:45:09 <autrijus> musasabi: I know :)
11:45:21 <autrijus> musasabi: however the structs are up to 100 fields.
11:45:29 <autrijus> musasabi: and I don't quite look forward to it
11:45:38 <musasabi> instance TupleToList (a,a) [a] where tupleToList (a,b) = [a,b]
11:45:41 <autrijus> so if it can be done in TH i'd be much happier
11:45:58 <musasabi> autrijus: you should be able to do that in TH.
11:46:17 <ski> musasabi : not "class TupleToList a b | a -> b where tupleToList :: a -> [b]" then ?
11:46:24 <musasabi> are you sure that is a sane list representation.
11:46:39 <musasabi> ski: you could do that also.
11:46:56 <Calister> SyntaxNinja: i will have tons tomorrow. But atm I'm bugging someone with some other comp science questions (bout physical electronical basics)
11:47:06 <musasabi> ski: that seems to be better.
11:47:07 <autrijus> musasabi: I merely wish to map a function over an arbitary record
11:47:12 <autrijus> in the element order
11:47:28 <musasabi> autrijus: boilerplate is the answer.
11:47:38 <autrijus> boilerplate?
11:47:41 <SyntaxNinja> Calister: cool. we'll be here
11:47:53 <musasabi> autrijus: google for "boilerplate haskell" (cannot paste links from text terminal)
11:47:55 <autrijus> generics?
11:48:06 <musasabi> yes.
11:48:07 <SyntaxNinja> autrijus: do you realize that TH isn't stable or portable? :)
11:48:28 <autrijus> SyntaxNinja: I don't care about portability really
11:48:36 * autrijus comes from a perl background :)
11:48:42 <Calister> SyntaxNinja: thanks ^_^
11:48:46 <musasabi> 6.4 TH is very different from 6.2 TH.
11:48:58 <SyntaxNinja> musasabi: oh really?  I can't wait.
11:50:42 * jadrian doesn't really feel particulary attracted to template haskell 
11:50:55 <musasabi> th seems too complex currently.
11:51:10 <jadrian> I mean the template approach itself
11:51:14 <musasabi> when it has stabilized and tutorials exist...
11:51:26 <jadrian> not saying it isn't useful...
11:51:40 <Heffalump> I like the idea, but the design of TH seems like a nasty mess to me.
11:52:15 <autrijus> hrm I'm not sure how generics can help to call a function to each element in a record.
11:52:41 <jadrian> I feel more inclined to play with the generic approaches and the like
11:52:46 <musasabi> autrijus: have you looked at the page?
11:53:00 <autrijus> yeah, reading the paper and examples.
11:53:02 <Heffalump> generic approaches are much more principled, but less powerful
11:53:31 <musasabi> gmap/fold do exist ;)
11:53:46 <jadrian> Heffalump: I like to say it like generic approaches are less powerful, but much more principled :D
11:53:50 <autrijus> I need to derive Data then
11:54:36 <musasabi> deriving (Data, Typeable)
11:55:09 <autrijus> ahh.
11:55:11 <autrijus>  No instance for `Data Word16'
11:55:14 <autrijus> I was confused about it
11:55:24 <autrijus> so I should merely instantiate Word16 as Data
11:56:20 <autrijus> which seems to be nontrivial
11:56:24 <autrijus> hrm
11:56:33 * autrijus tries
11:56:51 <tintin> .
11:56:53 <tintin> .
11:56:53 <ski> (hm, "freebot" ?)
12:00:07 <TheHunter> parsec question: Is there a function acceptFirst :: Parser a -> Parser a which discards all backtracking information?
12:03:51 <termol> how do i go about to use regexp functionality in ghci?
12:06:58 <shapr> d00d
12:07:16 <SyntaxNinja> y0 shapr!
12:07:23 <SyntaxNinja> shapr did you see my blog?
12:07:25 <Calister> sup shapr!
12:08:23 <shapr> y0 SyntaxNinja, I haven't looked at your blog today, but I'll check it out now.
12:08:25 <shapr> greetz Calister
12:08:45 <Calister> how is it going up there in the cold n dark?
12:09:15 <SyntaxNinja> shapr knows Calister... shapr knows everyone
12:09:30 <Calister> lol
12:09:41 <Calister> he was one of the first ppl here i spoke to ;)
12:09:53 <SyntaxNinja> that's the normal course of things
12:10:00 <Heffalump> hmm. I'm sure I used to have a LJ feed of Syntax's blog.
12:10:16 <ski> LJ ?
12:10:29 <Calister> ^_^
12:10:33 <Heffalump> LiveJournal
12:10:47 <Calister> you are pretty often here tho too, SyntaxNinja
12:11:03 * ski was thinking gentzen sequent system for intuitionistic logic ..
12:11:49 <autrijus> instantiating Word16 for Data seems to require basically overriding Data.Generics.Basics.
12:11:53 * autrijus shudders
12:12:16 <shapr> Calister: pretty good today, lots of unicycling lately.
12:12:27 <SyntaxNinja> Heffalump: http://www.livejournal.com/users/syntaxpolice/
12:12:35 <SyntaxNinja> though my blog isn't LJ
12:12:59 <SyntaxNinja> oh, my RSS is broken, that's why
12:13:11 <SyntaxNinja> or my old RSS feed links are broken because of a braindead redirect that I implemented
12:13:37 <Heffalump> SyntaxNinja: yeah, I thought I was subscribed to that, hence wondering why I hadn't seen the posts being referred to.
12:13:44 <Heffalump> or indeed any for ages
12:14:33 <Calister> shapr: i wonder how you can do that. i would so fall on my nose every 5 seconds
12:14:35 <SyntaxNinja> Heffalump: here's the new feed: http://blog.syntaxpolice.org/isaac/index.cgi?flav=rss
12:14:38 <SyntaxNinja> I wonder how to fix that...
12:14:58 <shapr> Calister: I started out that way. A few hours of practice fixed that.
12:15:20 <SyntaxNinja> Calister: :)
12:15:50 <Maddas> How much did your unicycles cost?
12:16:13 <Heffalump> LJ normally respond to requests to change a feed URL.
12:16:33 <Heffalump> there's no automatic means I know of
12:16:38 <Calister> shapr: i fear a few hours of practuze would just fix my tan to a nice blue shade all over body
12:16:42 <SyntaxNinja> Heffalump: I didn't create that feed... do I just email them and ask them to change it?
12:16:46 <Heffalump> I could do that.
12:16:55 <SyntaxNinja> Heffalump: would you? :)
12:16:57 <Heffalump> or you could, probably.
12:17:01 <Heffalump> sure.
12:17:20 <Heffalump> http://blog.syntaxpolice.org/isaac/?flav=rss is what it claims to be using now
12:17:48 <SyntaxNinja> right, the problem is that the new web server wasn't looking at index.cgi for some reason
12:17:56 <SyntaxNinja> and it's SELinux so I hardly understand such things
12:18:48 <Calister> SELinux?
12:20:04 <SyntaxNinja> Security Enhanced Linux
12:20:26 <Calister> oh
12:20:37 <wilx> Why don't they ship the enhancements in "ordinary Linux"? :)
12:21:40 <SyntaxNinja> wilx: because out of the box it breaks most programs :)
12:21:48 <Nioate> being secure involves a certain amount of inconvenience usually?
12:22:13 <SyntaxNinja> you have to basically write information about what each program is permitted to do
12:22:30 <SyntaxNinja> redhat has done some work to make it easier to use out of the box, and less secure.
12:22:50 <wilx> Hm.
12:22:58 <wilx> Interesting.
12:23:25 <termol> @type mkRegex
12:23:26 <lambdabot> bzzt
12:23:32 <termol> @type Text.mkRegex
12:23:33 <lambdabot> bzzt
12:23:48 <termol> @type Regex
12:23:49 <lambdabot> bzzt
12:23:54 <termol> @type Text.Regex
12:23:55 <lambdabot> bzzt
12:24:00 <termol> what is this??
12:24:07 <termol> how can i finx Regex?
12:24:07 <Heffalump> it probably doesn't have the package loaded
12:24:25 <SyntaxNinja> on selinux: http://www.nsa.gov/selinux
12:24:25 <termol> how can i load it into ghci?
12:24:32 <Heffalump> ghci -package regex ?
12:24:35 <Heffalump> (at a guess)
12:24:59 <termol> Heffalump: when i'm already inside ghci i mean.
12:25:45 <Heffalump> :t Text.mkRegex, then?
12:26:14 <SyntaxNinja> @type Text.Regex.mkRegex
12:26:15 <lambdabot> Text.Regex.mkRegex :: String -> Text.Regex.Posix.Regex
12:26:40 <Heffalump> ah :-)
12:27:00 <termol> Heffalump: ok, what about loading packages into ghci when i'm already in ghci?
12:27:07 <Heffalump> I don't think you can. ICBW.
12:27:59 <termol> Heffalump: ok. everything seems to be loaded already. i just had to type that long expression that SyntaxNinja kindly provided.
12:28:31 <termol> SyntaxNinja: is there a way to skip the whole qualified name and just use mkRegex in ghci?
12:28:54 <Heffalump> :m +Text.Regex
12:29:42 <termol> Heffalump: what does 'm' stand for?
12:29:48 <Heffalump> 'module'
12:29:54 <Heffalump> :module +Text.Regex
12:30:34 <termol> Heffalump: ok. thx. i think i'm gonna go ahead and play a bit with regular expressions in ghci...
12:31:01 <SyntaxNinja> termol: typically, I don't deal directly with the interpreter for experiments, I write a little program that I load into the interpreter
12:31:17 <SyntaxNinja> termol: if you import that module in your little program, then it'll be available to the interpreter
12:31:17 <Heffalump> I do deal directly with the interpreter for experiments :-)
12:31:35 <SyntaxNinja> so I didn't even know about Heffalump's little trick ;)
12:31:55 <Heffalump> sometimes writing a dummy module that just imports other modules can be easier, if you find yourself doing a string of :m +Foo a lot.
12:32:19 * SyntaxNinja never writes "Dummy" modules!
12:32:29 <termol> SyntaxNinja: well for oneliners the interpreter is nice. but for most programs your aproach works better of course.
12:33:09 <termol> SyntaxNinja: so if i import the module in my script i don't have to use the qualified name then?
12:33:20 <Heffalump> termol: correct
12:38:32 <viyyer> hi.. learning haskell from haskell98-report .. expressions, layouts bindings.. are a lot.. is there a way.. any tutorials, where I can just get started on haskell with some basid structures.. and continue learning.. ?
12:38:56 <viyyer> *d/basid/basic
12:39:02 <tintin> YAST
12:39:14 <tintin> yet another haskell tutorial 
12:39:26 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
12:39:54 <SyntaxNinja> @learning
12:39:54 <lambdabot> Sorry, I don't know the command "learning", try "lambdabot: @listcommands
12:39:58 <SyntaxNinja> @listcommands
12:39:58 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
12:39:58 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
12:39:58 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
12:39:58 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
12:39:58 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
12:39:58 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
12:40:00 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
12:40:02 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
12:40:04 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
12:40:16 <SyntaxNinja> @wiki LearningHaskell
12:40:16 <lambdabot> http://www.haskell.org/hawiki/LearningHaskell
12:41:34 * SyntaxNinja lunch
12:44:11 <autrijus> ok. generics solved the "put" problem via gmapM
12:44:24 <autrijus> now to implement "get"...
12:48:23 <Heffalump> anyone know off the top of their head the best way/library to look at to turn '03/01/2005 20:46:33' into a unixtime?
12:48:56 <shapr> bringert's ParseDate can turn that into CalendarTime
12:49:54 <Heffalump> hmm, this entire project is going to end up based on bringert's code :-)
12:52:49 <autrijus> ./OpenAFP/Types.hs:144:
12:52:49 <autrijus>     Could not deduce (Binary a) from the context (Data a)
12:52:50 <autrijus>       arising from use of `put_' at ./OpenAFP/Types.hs:144
12:53:12 <autrijus> this arises apaprently because of the gmapM singature:
12:53:12 <autrijus> gmapM :: Monad m => (forall a. (Data a) => a -> m a) -> a -> m a
12:53:18 <autrijus> so this works:
12:53:18 <autrijus> gmapM' :: Monad m => (forall a. (Binary a, Data a, Storable a) => a -> m a) -> a -> m a
12:53:32 <autrijus> but is there a way to modify the expected type?
12:53:39 <autrijus> ghc suggests: Add (Binary a) to the expected type of an expression
12:53:46 <autrijus> but not sure what I can do from the caller's side
12:54:18 <Heffalump> what are you trying to write with gmap?
12:54:52 <Heffalump> what's wrong with just using gmapM' as you suggest?
12:55:02 <autrijus> because that involves gfoldl'
12:55:05 <ski> Heffalump : hm, this seems to work in 6.2 "Prelude> :set -package util"
12:55:06 <autrijus> gmapQ'
12:55:13 <autrijus> and basically all related .Basic things
12:55:32 <wli> What on earth? gmapM'? gmapQ'?
12:56:30 <autrijus> wli: generic maps
12:56:32 <Heffalump> ski: work for what?
12:57:09 <pesco> Good day, #haskell.
12:58:33 <Calister> good day, pesco
12:58:59 * autrijus gives up and reimplements .Basics
12:59:25 <Heffalump> autrijus: I'm still confused by what the actual problem is.
12:59:47 <Heffalump> If you just invoke gmapM from a context where Binary a is true, there shouldn't be any, should there?
13:00:31 <pesco> Hello Calister, are you new to #haskell?
13:00:39 <autrijus> it apparently cannot unify the two types.
13:00:53 <Heffalump> can you put some code online I can try this with?
13:01:03 <autrijus> of course. sec
13:01:14 <Calister> pesco: welp, its not my first time here ^_^ but its not like im already inventory. ^_^
13:01:26 <pesco> Calister: Ok.
13:01:47 <Calister> :)
13:02:04 <autrijus> Heffalump: http://aut.dyndns.org/v3.tgz
13:02:13 <autrijus> Heffalump: simply run v3.hs and you'll see
13:02:17 <autrijus> ghc 6.2.2
13:02:32 <autrijus> OpenAFP/Types.hs line 154
13:02:35 <autrijus>         -- gmapM' (\r -> do put_ bh r; return r) a
13:02:35 <autrijus>         gmapM (\r -> do put_ bh r; return r) a
13:02:41 <autrijus> gmapM' works; gmapM does not.
13:03:52 <ski> Heffalump : sorry. for loading new packages from within GHCi
13:04:02 <Heffalump> oh, cool
13:04:14 <Heffalump> sorry, I misread what you said, or I'd have figured that out for myself
13:04:31 <ski> np
13:05:52 <pesco> autrijus: What are you doing?
13:06:14 * Heffalump looks at the nested quantification and starts to see the problem more clearly.
13:06:25 <autrijus> pesco: trying to read and write arbitary records.
13:06:33 <pesco> Ah.
13:06:47 <autrijus> I started using TH but was talked into using Generics :)
13:06:54 <autrijus> which does seem to be more robust
13:07:41 <Heffalump> ok. I don't think you have a choice. Sorry.. :-/
13:07:52 <autrijus> hlagh.
13:07:55 <Heffalump> it's because the constraints are nested inside the type signature of gmap.
13:07:59 <Heffalump> IM gmapM
13:08:03 <autrijus> okay...
13:08:10 <autrijus> so the constraint can't be unified
13:08:17 <autrijus> even if one is strict superset of another
13:08:27 <Heffalump> the thing is that the superset-ness goes the wrong way.
13:08:39 <autrijus> yeah but I imagine I can do it
13:08:45 <autrijus> with (gmapQ :: ...)
13:08:50 <autrijus> but apparently it can't be done that way either
13:08:51 <Heffalump> gmapM is a function that, given any function of a certain type, can produce one of type a -> m a
13:09:04 <autrijus> because initial declaration is more narrow.
13:09:05 <Heffalump> actually, I think your type of gmapM' is wrong. I wonder why it works.
13:09:12 <Heffalump> or rather, passes the type checker.
13:09:19 <autrijus> why should it not pass?
13:09:27 <Heffalump> (I think the outer 'a' should be forced to be Binary too)
13:09:47 <autrijus> but gmapM does not do that either
13:09:56 <autrijus> it doesn't scope Binary over to the outer 'a'
13:10:00 <autrijus> I mean DAta
13:10:09 <Heffalump> but Data is 'special'
13:10:16 <Heffalump> it's what gmapM is defined in to begin with
13:10:18 <autrijus> the compiler groks it in a special way?
13:10:22 <Heffalump> no, not that special
13:10:26 <autrijus> k
13:10:28 <Heffalump> but it's special for gmapM
13:10:34 <Heffalump> I'm still trying to get this all clear in my own head
13:10:55 <autrijus> it's special because gmapM uses gfoldl
13:11:09 <autrijus> so I had to redefine it as well
13:11:12 <Heffalump> oh
13:11:23 <Heffalump> your definition of gfoldl' in the file you sent me is just a stub.
13:11:37 <autrijus> no it's the whole gfoldl'
13:11:41 <autrijus> unless I'm missing something
13:11:41 <Heffalump> I have a suspicion that when you actually implement it properly, you'll find you need to add Binary a and Storable a to the outer constraints.
13:11:48 <Heffalump> gfoldl' _ z = z
13:12:08 <autrijus> nono
13:12:09 <Heffalump> is all I can see here
13:12:28 <autrijus> right
13:12:33 <autrijus> that's what Basics.hs says too
13:12:38 <Heffalump> oh.
13:12:48 <autrijus> it works because I'm merely serializing noncomposite types
13:12:52 <Heffalump> umm. Anyone around that actually understands how Data.Generics works? :-)
13:12:53 <autrijus> it won't work if it's recursive
13:13:03 <autrijus> but Word16 etc isn't composite
13:13:07 <Heffalump> oh, right.
13:13:08 <autrijus> so is safe to foldl over
13:13:15 <Heffalump> oh, hangon
13:13:19 <Heffalump> you copied the default implementation.
13:13:23 <autrijus> I did.
13:13:34 <Heffalump> rather than the specific one given in specific instances of Data for more complex types.
13:13:42 <autrijus> right since I reasoned I won't need them.
13:14:03 <autrijus> so yes, once I need to dump composite types
13:14:06 <Heffalump> so your instance Binary PGD works, but only because the constituent types are non-composite.
13:14:07 <autrijus> this will become a real problem
13:14:17 <autrijus> so I may need to subclass Data or something
13:14:19 <autrijus> which is PITA
13:14:25 <Heffalump> yeah, I think you'll have to :-(
13:14:40 <Heffalump> and duplicate all its methods, with (Binary, Storable) constraints too.
13:14:43 <autrijus> class (Binary a, Data a, Storable a) => Thing a where
13:14:45 <autrijus>   ...
13:14:50 <autrijus> and use Thing as my Data
13:14:51 <autrijus> right?
13:14:55 <Heffalump> something like that, yes.
13:15:02 <autrijus> gawd.
13:15:06 <Heffalump> and the nested signatures will have that too.
13:15:13 <Heffalump> Sounds like something you should ask about on the haskell list.
13:15:18 * autrijus wonders if THaskell or Eval.Haskell will make more sense.
13:15:26 <Heffalump> More knowledgeable people than I might be able to help.
13:15:36 <autrijus> k, thank you
13:18:16 <TheHunter> @quit
13:18:16 <lambdabot> not enough privileges
13:18:20 <TheHunter> sorry
13:18:44 <ski> @boing
13:18:44 <lambdabot> Sorry, I don't know the command "boing", try "lambdabot: @listcommands"
13:19:11 <autrijus> I win!
13:19:14 <autrijus> instance Thing PGD
13:19:18 <autrijus> class (Binary a, Data a, Storable a) => Thing a where
13:19:18 <autrijus>     gmapM :: Monad m => (forall a. (Thing a) => a -> m a) -> a -> m a
13:19:23 <autrijus> and
13:19:24 <autrijus> import Data.Generics hiding (gmapM)
13:19:28 <autrijus> that's all I had to do
13:19:38 <Heffalump> don't you need to implement gmapM too??
13:19:47 <autrijus> eh sure. it's a straight copy of gmapM
13:19:53 <Heffalump> ok :-)
13:20:01 <autrijus> but there's no this pesky '
13:20:10 <Heffalump> the annoying thing is that you'll need to make instances of Thing for everything else.
13:20:23 <autrijus> for all my data types, yes
13:20:24 <autrijus> which is okay
13:20:33 <Heffalump> oh, btw, the reason you didn't see Data in the outer context for the original gmapM was that it's defined in Data, and so that's implied
13:20:49 <autrijus> ahhh.
13:20:50 <Heffalump> if you do :t gmapM in the interpreter etc, you do see it
13:20:53 <autrijus> gotcha.
13:33:25 <autrijus> Heffalump: while you are at it, can you look at PGD.get ?
13:33:25 <autrijus> instance Binary PGD where
13:33:25 <autrijus>     put_ = putR
13:33:26 <autrijus>     get bh = do
13:33:39 <autrijus> I still have no clue how to genericize the "get bh" call
13:34:13 <musasabi> autrijus: there is no good way for serialization
13:34:30 <autrijus> you mean, the problem in general?
13:34:35 <musasabi> yes.
13:34:46 <musasabi> and haskell in particular.
13:34:50 <autrijus> then maybe I'll hack this thing toward it :)
13:34:59 <autrijus> I had written Parse::Binary in perl that does exactly that.
13:35:56 <musasabi> autrijus: does it manage cyclic structures, efficient lists (strings), and versioning?
13:36:27 <Heffalump> generalise it in what sense?
13:36:31 <Heffalump> sorting out the type?
13:37:52 <autrijus> musasabi: yes, except the efficient bit.
13:38:04 <autrijus> it leaks constantly and is taking exponential time in worst cases.
13:38:12 <autrijus> Heffalump: genericize it
13:38:18 <autrijus> rewrite it using gmap etc
13:38:24 <autrijus> instead of repating 11 lines
13:38:35 <musasabi> autrijus: and in haskell a String is a list of Char.
13:38:38 <Heffalump> what happens when you try using your new gmapM?
13:38:44 <autrijus> musasabi: this was the second reason why I switched to haskell
13:38:53 <autrijus> Heffalump: I had no idea how to use gmapM to tackle it
13:39:14 <autrijus> gmapM assumes the same type for input and output, no?
13:39:23 <Heffalump> oh, right, sorry
13:40:33 <autrijus> oh well. in the worst case I'll just generate Types.hs from a perl script ;)
13:40:50 <Heffalump> at a guess you'll need some kind of unfold
13:41:08 <autrijus> thanks to all for the help. it's 5:39am here and I really need to sleep
13:41:12 * autrijus sleeps &
13:41:16 <Heffalump> night.
13:41:20 * Heffalump wonders where autrijus is
13:41:24 <autrijus> Taipei, Taiwan
13:41:30 <Heffalump> ah
13:43:09 <musasabi> night.
14:04:15 <jadrian> just to make sure
14:04:36 <jadrian> if I do  ys = map id xs
14:04:55 <jadrian> then ys will share the contents of xs, but not the list structure right?
14:05:18 <jadrian> it's different from doing  ys = id xs
14:05:30 <jadrian> which would result in "full sharing"
14:06:23 <arjanb> yes depending on how smart the compiler is
14:06:42 <jadrian> any idea how smart ghc -O2 is?
14:07:10 <morbidi> how do I transform "13" into 13?
14:07:34 <arjanb> read "13" :: Int
14:07:40 <ski> (mayhaps  fmap id  would share ?)
14:07:58 <jadrian> ski: ?
14:08:03 <morbidi> 10x
14:08:05 <morbidi> :)
14:08:10 <jadrian> ski: why?
14:09:24 <jadrian> map is just fmap on lists...
14:09:29 <TheHunter> jadrian, i don't think it's so easy
14:09:30 <morbidi> is there other function to do taht?
14:09:32 <morbidi> that
14:09:48 <jadrian> TheHunter: "so easy for the compiler to optimize" right?
14:09:55 <ski> jadrian : well,  fmap id = id  is one of the Functor laws ..
14:10:04 <TheHunter> everything is shared
14:10:45 * ski doesn't even know if some opt. in ghc depends on monad laws ..
14:10:52 <jadrian> ski: right... 
14:11:03 <TheHunter> wait a sec
14:11:26 <jadrian> ski: it wouldn't work in my case since the functions are neither fmap nor id :)
14:11:56 <TheHunter> i thought about preventing sharing once, too, but after I found out even
14:12:01 <TheHunter> newtype CList a = CL {   runCL :: forall r. r -> (a -> CList a -> r) -> r}
14:12:10 <TheHunter> causes the list to be shared.
14:12:11 <arjanb> morbidi: why do you want a more complex way to do that?
14:12:31 <jadrian> hmmm
14:12:39 <morbidi> arjanb: because I don't know what the :: operator does
14:12:48 <jadrian> in my case sharing would be good
14:12:49 <morbidi> in top of that I wanna a function
14:13:30 <jadrian> TheHunter: maybe it shares in my case to then... (even though I now fail to understand when it does and doesn't)
14:14:20 <TheHunter> if you have xs = [1..] and you use xs twice, you almost certainly have a big space leak.
14:14:26 <ski> (jadrian : hm, what "are the functions" in your case, then ?)
14:14:32 <TheHunter> and i think there's no way around it.
14:14:45 <jadrian> well I'm performing substitutions on terms (on it's variables)
14:14:45 <arjanb> morbidi: you can leave the ':: Int' part away mostly
14:15:11 <morbidi> arjanb: but I just want a function that does the same has atoi
14:15:31 <morbidi> transforming the string "13" into the number 13
14:15:49 <ski> jadrian : wouldn't the tree structure only be shared if mutating the mem ?
14:15:49 <jadrian> after substituting a variable I substitute what was returned too
14:16:06 <jadrian> not really...
14:16:42 <bourbaki> hey TheHunter
14:16:51 <TheHunter> hey bourbaki
14:17:01 <jadrian> ski: at least in theory, the common parts should be shared in memory
14:17:09 <TheHunter> bourbaki, check out my pointless lambdabot plugin
14:17:19 <bourbaki> TheHunter: do you have a good idea how to resolve raycasting on gaussian surfaces?
14:17:23 <jadrian> ski: I don't mean shared in the sense that if you change one the other changes too... because you cannot even change them
14:17:25 <arjanb> morbidi: atoi :: String -> Int    atoi = read
14:17:32 <bourbaki> TheHunter: what is it?:)
14:17:39 <TheHunter> bourbaki, not the slightest idea
14:17:52 * ski was thinking about parts on paths down to changed parts (at least)
14:17:54 <morbidi> arjanb: ahahah
14:17:56 <TheHunter> thbot: @pointless \f g -> f =<< g g
14:17:57 <thbot> (. s id id) . (=<<)
14:18:24 <ski> morbidi : "::" is not an expression-level operator, like e.g. "+" is
14:18:25 <bourbaki> TheHunter: whats your plugin?
14:18:37 <jadrian> ski: exactly, that's what I was wondering about... 
14:18:49 <morbidi> ski: what is "::"?
14:18:55 <jadrian> ski: if I could keep them or not... but most probably not...
14:18:56 <TheHunter> transforms lambda expressions into pointfree^H^H^H^Hless style
14:19:10 <ski> morbidi : depends a little on context (i.e. *where* it is used)
14:19:11 <TheHunter> thbot: @pointless \x y z -> x z y y
14:19:11 <thbot> s (flip flip) . (. flip id) . flip (.)
14:19:16 <bourbaki> TheHunter: basically its just solveing f(x)=mx+b, g(x) = gauss, h(x) g(x) - f(x) = 0
14:19:37 <jadrian> ski: still after what TheHunter said I'm not so sure...   
14:19:48 <bourbaki> TheHunter: whats pointless?
14:19:55 <ski> morbidi : in this case it constrains an expression to have a certain type. generally "E :: T" is an expression, if E is an expression and T is a type
14:20:03 <TheHunter> f x = x + x is pointful
14:20:19 <TheHunter> thbot: @pointless \x -> x + x
14:20:19 <thbot> s (+) id
14:20:23 <TheHunter> this is pointless
14:20:31 <morbidi> ski: it's like a cast?
14:21:01 <bourbaki> TheHunter: whats s in that equation?
14:21:08 * ski lags reading
14:21:20 <TheHunter> lambdabot: @get-definition S
14:21:20 <lambdabot> S = \f g x.f x (g x)
14:21:21 <ski> morbidi : not exactly
14:21:22 <jadrian> TheHunter: dumb question, is "pointless" also a valid technical term, or used just for fun?
14:21:41 <TheHunter> the technical term is point(-)free
14:22:02 <ski> morbidi : i'd maybe call it a type constraining   (possible other name is type ascription)
14:22:09 <jadrian> yeap that I know, but I've seen "pointless" used so many times that I was beginning to wonder...
14:22:27 <bourbaki> and whats that good for?
14:22:45 <TheHunter> well, it'll make me ruler of the universe sometime.
14:23:02 <TheHunter> apart from that, it has no use.
14:23:21 <jadrian> bourbaki: it's good to get annoyed by the monomorphism restriction
14:23:37 <jadrian> joke, I like point free definitions :)
14:23:41 <ski> morbidi : in my understanding of the word 'cast' it (potentially) changes the type of the expression
14:24:05 <morbidi> ski: that's right
14:24:48 <ski> morbidi : e.g. C :  "(double)5"  whole expr. have type double, while sub-expr. have some integer type (e.g. int)
14:25:00 <TheHunter> monomorphism restriction, what's that?
14:25:09 * TheHunter points to -fno-monomorphism-restriction
14:25:32 <morbidi> ski: that's C?
14:25:52 <ski> yup (said so)
14:26:17 <ski> (same with C++ and Java, methinks, though)
14:27:05 <morbidi> ski: it seemed some error msg
14:27:09 <morbidi> but's not
14:27:10 <morbidi> sorry
14:27:23 <morbidi> ski: got the point
14:27:27 <ski> but, in "read s :: Int" both whole expr and the subexpr "read s" have type Int
14:27:46 <ski> mm
14:28:15 <morbidi> ooooohhhh
14:30:10 <ski> got it ? ;)
14:33:19 <TheHunter> thbot: @part
14:33:33 <TheHunter> thbot: @part #haskell
14:49:26 <SyntaxNinja> what's thbot?
14:50:09 <thbot> i'm basically lambdabot with a pointless plugin.
14:50:40 <Igloo> Psychic.hs, apparently  :-)
14:52:43 <ski> it prolly uses an oracle ..
14:53:08 <TheHunter> @pointless \f -> ((f.).)
14:53:09 <lambdabot> Sorry, I don't know the command "pointless", try "lambdabot: @listcommands
14:53:09 <thbot> (.) . (.)
14:54:05 <esap> thbot: @pointless (\f -> f f) (\g -> g g)
14:54:05 <thbot> s id id (s id id)
14:54:08 <ski> thbot: @pointless \f g a b c d -> f (g a b c d)
14:54:08 <thbot> (.) . (.) . (.) . (.)
14:54:12 <ski> thbot: @pointless \f g a b c -> f (g a b c)
14:54:13 <thbot> (.) . (.) . (.)
14:54:18 <ski> thbot: @pointless \f g a b -> f (g a b)
14:54:18 <thbot> (.) . (.)
14:55:13 <ski> thbot: @pointless (\t -> t t) (\g f x -> f (g g f) x)
14:55:13 <thbot> s id id (s id . s id id)
14:55:50 <xerox> O_o
14:56:19 <esap> thbot: @pointless \f x y -> fmap (\a -> fmap (f a) y) x
14:56:19 <thbot> (. flip flip) . flip id . (fmap .) . (. flip flip) . flip id . (fmap .)
14:57:01 <musasabi> thbot: @pointless (\c -> not (or (foo c) (bar c)))
14:57:01 <thbot> not . s (or . foo) bar
14:59:35 <esap> thbot: @pointless \f g -> zip [0..] [a| (a,c) <- [(i,f i) | i <- minBound .. maxBound]], g a == c]
14:59:35 <thbot> (line 1, column 13):
14:59:35 <thbot> unexpected "["
14:59:35 <thbot> expecting space, variable, "(", operator or end of input
15:04:23 <ski> esap : seems to be unmatched ']' ..
15:04:45 <TheHunter> ski, the parser doesn't support lists.
15:04:49 <esap> ski: from the message, I figured it doesn't support lists
15:05:24 <esap> it would have complained about ']' not '[' if it did support it.
15:06:33 * ski understood that it didn't supported lists. just tried to understand what it meant
15:06:57 <esap> my code? or the error message?
15:07:02 <ski> your code, yes
15:07:43 <ski> 3 '['m while 4 ']' is present
15:07:49 <ski> s/m/,/
15:08:18 <esap> ski: I took it from an instance declaration for DeepSeq (a -> b). See http://haskell.org/hawiki/ControlOperation
15:08:30 <esap> almost that
15:09:00 <esap> actually, no, it tries to implement equalizers :-)
15:10:47 <ski> heh
15:10:51 <esap> The function, in full is: equalizer f g = make_function $ zip [0..] [a| (a,c) <- eval_function f, g a == c ], make_function lst x | Just y <- lookup x lst = y | otherwise = undefined ; eval_function f = [(i,fi) | i <- [minBound .. maxBound]]. I tried to cut-and-paste from that, which explains the missing []
15:12:16 <ski> mhm (missing '[')
15:12:28 <esap> right :-)
15:47:06 <termol> does anyone know how to match the part before the dot in this string "this.mp3" with Text.Regex?
15:49:21 <termol> do you know how to match the part before the dot in this string "this.mp3" with Text.Regex?
15:53:15 <SyntaxNinja> I don't know Text.Regex, but there are easier ways to do that, fwiw.
15:53:44 <SyntaxNinja> for instance, you can use the new FilePath module, which just has a function for doing such things
15:53:56 <SyntaxNinja> so if you're writing some code to manage your MP3s, that's probably the way to go
15:54:02 <SyntaxNinja> or you could lookat the "break" function in Data.List.
15:59:48 <termol> SyntaxNinja: freakin mkRegex doesn't seem to handle things like \w to match a word
16:00:02 <zippy> anyone here use advertise with google?
16:01:17 <Igloo> It uses one of POSIX basic and extended regexps - I forget which
16:01:37 <zippy> oops wrong chan
16:01:52 <termol> Igloo: so how do i match a word in it?
16:02:33 <termol> i get  "lexical error in string/character literal" when i try...
16:04:04 * ski guesses it might be fixed by using "..\\w.." instead of "..\w.." (if indeed you do that now)
16:04:08 <Igloo> I don't know what you want exactly, but some combination of character classes, \< and \> should do it
16:08:08 <termol> well \\w didn't solve it...
16:09:20 <Lemmih> termol: What about "[^.]*"?
16:09:49 <termol> Lemmih: yes. the dot approach works.
16:09:52 <Lemmih> Prelude Text.Regex> matchRegexAll x "hello.mp3" => Just ("","hello",".mp3",[])
16:10:45 <termol> Lemmih: i'm using the subexpression one      mkRegex "(\w)\.(mp3)"    is one example
16:11:18 <termol> the first pair of parentheses should match the word before the dot.
16:11:29 <termol> in "this.mp3"
16:11:52 <musasabi> filenames are a poor way of determining filetypes.
16:12:02 <musasabi> file(1) is better.
16:12:42 <Riastradh> Unix has no good way to annotate files with types.  file(1) is a collection of hacks & crocks.
16:12:52 <musasabi> of course.
16:13:09 <musasabi> but better than coding the hacks from scratch
16:13:52 <termol> yes, but i want to do much more. for instance i may have a file name pattern that looks like   "Artist-Title.mp3"   and i want to create a list of all artists. this is were regex comes in very handy...if it had worked...
16:15:01 <termol> but maybe things like \w are not posix...what do i know...
16:15:16 <termol> i could try to live without them
16:17:49 <termol> it's a bit bothersome that i have to escape every instance of \ by typing \\   but i think it's that way in java too.
16:18:38 <Lemmih> Isn't it like that in most languages?
16:20:17 <termol> Lemmih: not in Ruby...i think...
16:22:04 <termol> ok guys...time to call it a day...happy hacking holidays...
16:22:16 * Lemmih puts consistency over convenience.
16:41:47 * morbidi is gone: sleeping
17:20:16 <sh10151> does anyone use ghc on OS X?
17:21:00 <dons> what's the problem?
17:21:26 <sh10151> used ./configure; make; make install on HaXml
17:21:29 <sh10151> OS X, ghc from fink
17:21:47 <sh10151> ghc -package HaXml runs for a bit
17:21:51 <sh10151> then
17:22:32 <sh10151> Loading package HaXml ... ghc-6.2: can't load .so/.DLL for: HSHaXml (dlcompat: file "libHSHaXml.dylib" not found)
17:22:59 <sh10151> I see a libHSHaXml.a in the lib directory
17:23:03 <sh10151> but not this dylib
17:23:51 <dons> you may be able to create libHSHaXml.dylib from the .a version
17:24:21 <dons> are you using ghci, or just ghc?
17:24:42 <sh10151> ghci, sorry
17:25:00 <dons> well, it should work in ghc, which doesn't need dynamic loading.
17:25:18 <SyntaxNinja> does the Makefile use --auto-ghci-libs in the ghc-pkg line?
17:25:25 <SyntaxNinja> I assume it should
17:26:23 <dons> yeah, looks like it didn't run. you can use: ld -r -x -o libHSHaXml.dylib libHSHaXml.a
17:26:44 <dons> (maybe, untested on macosx)
17:28:33 <sh10151> well, here goes nothing :)
17:30:41 <sh10151> not gnu ld :)
17:31:05 <dons> so you don't have -x maybe?
17:31:18 <sh10151> looking into it
17:31:22 <sh10151> cut and paste got
17:31:44 <sh10151> steve$ sudo ld -r -x -o libHSHaXml.dylib libHSHaXml.a
17:31:44 <sh10151> ld: no object files loaded
17:32:09 <dons> is libHSHaXml.a in the current directory?
17:32:43 <sh10151> yep
17:34:14 <dons> ok, you need an osx person, then :)
17:35:36 <sh10151> thanks anyway, i was worried it would be an ld thing
17:41:07 <dons> a mac user suggests: ld -r -x -all_load foo.a -o foo.o 
17:41:16 <dons> as the correct way to create .o libs for ghci on the mac
17:41:26 <dons> so then what is the .dylib dlcompat stuff?
18:15:21 <jdrake> Friends! Pray with Me Please, Pray to the Holy Divine Lambda
18:27:32 <jdrake> Does haskell have a value 'undefined' for values which are?
18:27:59 <dons> @type undefined
18:28:00 <lambdabot> undefined :: forall a. a
19:23:03 <bourbaki> moin
19:23:26 <jdrake> bork bork
19:24:51 <bourbaki> :)
19:25:42 <jdrake> I think I could use a nice reference page that quickly gets the monads across to me
19:26:05 <bourbaki> have you seen that all about monads page?
19:26:31 <bourbaki> www.nomaware.com/monads/html/
19:27:49 <jdrake> I will have to look at that :-)
19:28:18 <monochrom> Mine are at http://www.cs.utoronto.ca/~trebla/fp/lecture-11.pdf (IO) and http://www.cs.utoronto.ca/~trebla/fp/lecture-12.pdf (roll your own monad)
19:28:28 <monochrom> They are shorter.
19:28:49 <jdrake> I think I need to actually do something (make something that works) tonight
19:29:03 <jdrake> I wouldn't mind making a directory lister, as it sounds simple
19:36:48 <Darius> jdrake: A directory lister may be too simple, the meaningful code for a primitive one is about a 2-liner.
19:37:26 <jdrake> Darius, can I see this '2-liner' then? I perceive it as a little bit more difficult than that
19:38:58 <Darius> jdrake: Well, to be clear, what do you consider a directory lister?  Something like 'ls' essentially?
19:39:05 <jdrake> yes
19:39:13 <monochrom> Hahahahaha I see why it's 2 lines.
19:39:39 <monochrom> Hint: it's also 2 lines in all other languages.
19:40:09 <Darius> liftM head getArgs >>= getDirectoryContents >>= mapM_ putStrLn 
19:40:43 <Darius> Maybe with a getCurrentDirectory interposed if getDirectoryContents doesn't like relative paths (and you care about implementing them).
19:41:18 <monochrom> I had system("ls") in mind
19:41:25 <Darius> monochrom: I figured.
19:41:51 <Darius> getArgs >>= system . ("ls "++) . concat
19:42:12 <jdrake> Darius, how does that initial line actually work
19:42:21 <monochrom> But without using system it's still 2 lines, that's neat.
19:42:37 <Lemmih> Darius: Using 'intersperse' would make it a lot more useful.
19:43:01 <Darius> It gets the first commandline argument, passes that to getDirectoryContents, then prints out each element of the list on a line.
19:43:43 <Darius> Using do-notation, it'd be, do (a:_) <- getArgs; dirs <- getDirectoryContents a; mapM_ putStrLn dirs
19:46:18 <jdrake> that makes much more sense to me
19:46:29 <jdrake> i haven't actually done anything with do yet though
19:51:26 <jdrake> http://b3ta.jinxx.co.uk/submissions/spot.jpg
20:08:41 <Gahhh> talking about getDirectoryContents, why does it also list "." and ".." ?
20:09:47 <Darius> Gahhh: Why shouldn't it?
20:11:05 <Gahhh> well, I don't know why unix does it either, i.e. "I am a directory and I contain myself: '.'".
20:12:35 <Darius> Gahhh: The 'why' is presumably so one can refer to the current directory and parent directory.
20:12:51 <Gahhh> I just did this: "cd /", "ls -la" lists ".." as well. if you do "cd ..", you dont actually go up.
20:13:19 <monochrom> self-reference is always good
20:13:19 <Darius> Gahhh: That's because the parent of / is presumably /.
20:13:31 <Gahhh> Yes, they are ways to refer to this directory and its parent. But the directory doesn't really contain them.
20:15:07 <Darius> Gahhh, my understanding is that at the harddisk level, there are entries for them.  Conceptually, though, you can either think of the directories as containing them (they're there aren't they), or you can think of the entries of a directory as containing references to things not actually the things themselves.
20:15:48 <Gahhh> Ok, but if even "/" is guaranteed to have ".." and ".", then they are redundant when returned. One does not need these two tokens to be returned from getDirectoryContents in order to use them.
20:19:03 <Darius> Gahhh: getDirectoryContents is just doing it's job, it has no care about what you intend to use the results for.
20:22:15 <Gahhh> Did you really mean to say that ?
20:24:11 <Darius> Well, modulo a grammatical error I didn't feel like fixing, yes.
20:25:59 <autrijus> hi
20:26:27 <Gahhh> Because it sounded like a library routine does not care about what a user may want to do with it. As if it's been employed by someone else to do "a job" so it doesn't care about what users may wanna do.
20:26:29 <autrijus> a question; I'm now using the "Record" type defined thus:
20:26:37 <autrijus> class (Show a, Binary a, Data a, Storable a) => Record a where
20:26:38 <autrijus>     putR :: BinHandle -> a -> IO ()
20:26:59 <autrijus> now I'd like all instance of it to automatically get an implementation of "Binary" too
20:27:03 <autrijus> instance (Record a) => Binary a where
20:27:05 <autrijus>     put_ = putR
20:27:14 <autrijus> this passes type checking if I add  -fallow-undecidable-instances -fallow-overlapping-instances
20:27:21 <autrijus> but when run it goes into an infinite loop.
20:27:41 <autrijus> is this kind of thing a Bad Idea, or I'm missing something trivial?
20:28:46 <Riastradh> It's a Bad Idea.
20:28:55 <Riastradh> I think.
20:29:04 <autrijus> what is the recommended way then?
20:29:10 <Darius> Gahhh: It does what it does no matter what you want it to do.  Choosing (or making) the functions that do what you want them to do is your job as a programmer. (,) makes pairs no matter how convenient it'd be for it do something else.
20:29:27 <autrijus> to do OO-style inheritence that is
20:29:28 <Riastradh> -fallow-undecidable-instances & -fallow-overlapping-instances are, if I remember correctly, somewhat like caesium & water.
20:29:37 <Riastradh> Only not quite as fun.
20:30:07 <autrijus> I got the idea.
20:30:40 <Riastradh> I could be wrong -- though I do have a vague inkling about that in my memory --, but I just wanted to make use of that metaphor.
20:31:15 <Darius> Haskell, unfortunately, does not allow instance (Record a) => Binary a.
20:31:55 <Darius> There is no (immediate) way to get all instances of one type class to have instances of another.
20:32:31 <autrijus> this is quite inconvenient for generics programming.
20:32:45 <Darius> autrijus: However, in this case, why do you want it?  You require something to already be in Binary for it to be in Record.
20:33:00 <autrijus> Darius: because the implementation is done at the Record level.
20:33:09 <autrijus> since it's a Data, it can make use of generics
20:33:18 <autrijus> the putR implementation is like
20:33:19 <autrijus>         f <- gmapM (\r -> do put_ bh r; return r) a
20:33:20 <autrijus> etc
20:33:43 <autrijus> now of course I can do
20:33:44 <autrijus> instance Binary PGD where
20:33:44 <autrijus>     put_ = putR
20:33:50 <autrijus> instance Binary PTX where
20:33:54 <autrijus>     put_ = putR
20:33:55 <autrijus> etc etc.
20:34:05 <autrijus> but repeated lines seems like a sin
20:34:11 <Darius> autrijus: Actually, you can't as your Record class is currently declared.
20:34:31 <Darius> (Or can you?)
20:34:33 <autrijus> I can.
20:34:35 <autrijus>     gmapM :: Monad m => (forall a. (Record a) => a -> m a) -> a -> m a
20:34:41 <autrijus> I have my own gmapM.
20:35:30 <Darius> Well, my point was that PGD (for example) would already have a Binary instance to be in Record and it would conflict, but I guess this sort of mutual recursion would work.
20:37:07 <autrijus> ghc 6.2.2 seems to like it.
20:37:37 <Darius> autrijus: When I thought more, defining a functor instance as liftM works I'm pretty sure, so...
20:38:37 <autrijus> elaborate please?
20:38:47 <autrijus> <- have only learned haskell for 5 days
20:40:28 <Darius> The archetypical case that the problem comes up is that all Monads are Functors (theoretically), instance Monad a => Functor a where fmap = liftM would cover all monads, but Haskell doesn't allow it.
20:40:56 <autrijus> so the workaround is.. ?
20:41:57 <Darius> autrijus: There are various ways, one way would be to make a newtype HasRecord that has a Binary instance that uses putR on the wrapped type.
20:42:34 <Darius> This would allow you to "coerce" instances of Record to instances of Binary.
20:42:40 <autrijus> so instead of saying "instance Binary PGD" I say
20:42:56 <autrijus> instance Binary HasRecord where ...
20:43:28 <autrijus> and replace the PGD const calls into HasRecordConstr PGD calls
20:43:30 <autrijus> something like that?
20:43:37 <Darius> autrijus: instance Record a => Binary (HasRecord a) where put_ (HasRecord a) = putR a
20:43:40 <Darius> Yes
20:43:48 <Lemmih> That doesn't make sense since you can't be an instance of Record without being an instance of Binary.
20:43:53 <Lemmih> Or did I misinterpret something?
20:44:01 <autrijus> it doesn't make sense to me either.
20:44:38 <Darius> autrijus: Well, you would remove the Binary declaration for Record (if possible).
20:45:23 * autrijus hacks and see
20:46:15 <Darius> autrijus: I imagine the most commonly used "solution" is simply to define each instance declaration.  Since Haskell lets you define them wherever you want and they are trivial (if repetitive) it isn't too much of a problem.
20:46:41 <autrijus> Darius: *nod* in the worst case I'll just machine generate them
20:46:44 <autrijus> or use THaskell
20:46:50 <autrijus> but I'm merely exploring the haskell space
20:47:32 <Darius> autrijus: Searching the Haskell mailing list for this issue should turn up various discussions about it and ways of dealing with it.
20:47:40 <Darius> Not sure what would make the best search terms though.
20:47:44 <autrijus> data Record a = HasRecord a
20:47:54 <autrijus> this can't be a newtype can it?
20:48:00 <Darius> Sure it can.
20:48:34 <autrijus> newtype HasRecord = (Binary a) => HasRecord a
20:48:37 <Darius> Well, unless you are worried about definedness issues, but that wouldn't make much sense.  The wrapper is intended purely for the type system.
20:48:50 <autrijus> that doesn't seem to like me
20:49:21 <Darius> autrijus: Written that way, that means something else.  I'm not sure if written the other way would work with newtypes, but simply don't bother.
20:49:21 <autrijus> I don't get it; a newtype has to stand on an existing type
20:49:31 <autrijus> there's no existing types
20:49:43 <Darius> newtype HasRecord a = HasRecord a
20:49:51 <autrijus> ahhhhh
20:49:53 <Darius> We are just telling the type system something.
20:50:00 <autrijus> ok.
20:50:11 <autrijus> is this called phantom types?
20:50:50 <Darius> No, a phantom type is where we have a type variable that we don't use, e.g. newtype Foo a = X.
20:51:26 <autrijus> ok.
20:51:32 <autrijus> so this is a.. ?
20:51:44 <autrijus> tautological type? label type? hint type?
20:51:57 <Darius> autrijus: Something like, Wrapper type or type wrapper is probably one of the more common terms.
20:52:04 <autrijus> thanks so much.
20:52:48 * autrijus continues unlearning much OO crufts
20:53:03 <Darius> For example, there is
20:53:07 <Darius> @wiki TypeclassWrapper
20:53:07 <lambdabot> http://www.haskell.org/hawiki/TypeclassWrapper
20:54:44 <autrijus> newtype Record a = Record a deriving (...pretty much everything...)
20:54:45 <autrijus> cool
20:56:18 <autrijus> so for all the reads like
20:56:26 <autrijus>    foo <- get bh
20:56:29 <autrijus> I'll have to say
20:56:37 <autrijus>   (Record foo) <- get bh
20:56:40 <autrijus> hmm not a big deal.
20:56:54 <autrijus> actually it makes the program easier to read.
20:57:38 <autrijus> The lyf so short the craft so longe to lerne.
23:12:29 <autrijus> yay. I finally grokked the problem.
23:12:34 <autrijus> Data.Generics.Reify is da bomb.
23:36:20 <autrijus> is it possible to reify the expected return type inside a function, before calculating the return value?
23:37:02 <autrijus> currently I have
23:37:03 <autrijus>     get bh = do
23:37:03 <autrijus>         a <- get bh
23:37:03 <autrijus>         return $ trace (show $ glength a) $ Record a
23:37:21 <autrijus> now I'd like to pass "glength a" as an argument to something at the position of "get bh"
23:37:33 <autrijus> that will complete the genericification of my data types
23:41:47 <autrijus> hmm maybe something based on gunfoldr.
23:57:38 <shapr> @yow !
23:57:39 <lambdabot> An Italian is COMBING his hair in suburban DES MOINES!
23:57:50 <Lemmih> Good morning, shapr.
23:58:04 <shapr> good morning Lemmih !
23:58:10 * Lemmih is having C++ problems.
23:58:32 <shapr> I'm going off to the town of psi to be social.
23:58:37 <shapr> though I dunno if psi is there.
23:58:42 <shapr> psi: where are you today?
