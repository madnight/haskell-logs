00:00:14 <dons> (today is my last day in europe, so I'll be back at work soon i promise ;)
00:00:32 <basti_> magnus--: that restriction comes from generalized abstracted nonsense. You can override it with -fno-monomorphism-restriction. That will invite demons, though.
00:00:47 <dons> demons?
00:00:56 <Lemmih> dons: Good. Finished the Haskell plugin for CommonSense. (it doesn't work as well as I had hoped, though)
00:01:06 <dons> ah, how so?
00:01:25 <dons> and do you seen room to improve it?
00:02:00 <magnus--> basti_: I'll just use explicit arguments for now
00:02:12 <magnus--> unless I hit this problem more times
00:02:16 <Lemmih> It's not reponsive enough when running the typechecker in a Haskell thread. Especially when we use a idle handle in Gtk to tricker execution of the threads.
00:02:27 <Lemmih> *use an idle
00:02:40 <basti_> magnus--: yes thats perfectly possible
00:02:41 <dons> hmm. so typechecking the whole buffer takes a little time?
00:02:49 <dons> can we type check fragments, I wonder?
00:02:57 <basti_> magnus--: in some cases, it's not applicable, so you need that compiler option
00:03:05 <dons> or on typecheck when nothing else is running?
00:03:09 <dons> only
00:03:23 <Lemmih> dons: Running it in the background would be better.
00:03:23 <dons> I wonder how VH does it
00:03:29 <dons> yep.
00:03:34 <dons> oh, you're not doing that?
00:03:47 <dons> you're passing control over to the tc, and it takes too long?
00:04:00 <Lemmih> I'm using Haskell threads.
00:04:31 <dons> so yeah, can we run it in the background and have it write to an MVar when done?
00:04:43 <Lemmih> We hand over control to Gtk which will run 'yield' every 20msec.
00:04:55 <dons> can we set priorites on threads?
00:05:04 <dons> I'm not sure i've ever done that.
00:05:27 <dons> they run the syn hl in the background in VH, according to JaffaCake.
00:05:40 <dons> and I assume the tc too.
00:05:43 <Lemmih> They do?
00:06:03 <dons> well, that's what he said at last year's HW. Maybe something has changed since then.
00:06:28 <dons> sounds tricky, doesn't it? when interacting with the UI
00:08:18 <Lemmih> I would love to get my hands on Babel/vs.
00:17:07 <metaperl> who was on the (http://shootout.alioth.debwho was on the (http://shootout.aso the 1st and 3rd place ICFP 2005 teams are not #haskell regulars I take it?
00:17:11 <metaperl> oops
00:17:25 <metaperl> who was on the (http://shootouso the 1st and 3rd place ICFP 2005 teams are not #haskell regulars I take it?
00:17:29 <metaperl> oops again
00:17:51 <metaperl> so the 1st and 3rd place ICFP 2005 teams are not #haskell regulars I take it?
00:17:55 <metaperl> there we go
00:19:01 <dons> yep. that's right. though the 1st team does contain a regular ghc hacker
00:20:13 <dons> the best #haskell team came in 11th, I think.
00:24:56 <fnord123> hi dons
00:25:32 <dons> hello fnord123, long time no chat
00:26:02 <metaperl> no, Heffalump et all placed 7th and 2 teams above them had non-working programs
00:26:21 <metaperl> dons: did your program work correctly for ICFP?
00:27:05 <dons> it didn't fail, but it didn't run the way it ran during testing.
00:27:09 <dons> :/
00:27:16 <metaperl> heh
00:27:35 <dons> which is sad, since we put so much into testing. we had 20 instances running in parallel on a cluster.
00:27:42 <dons> this is probably why we didn't fail.
00:27:59 <dons> haven't yet gone over the logs to find out why the behaviour was so bizarro though
00:28:29 <metaperl> hmm, so it may have been an issue with how theytested things
00:28:37 <dons> yes, I suspect so.
00:29:00 <dons> we must have implicitly relied on something that was missing or different in their env.
00:29:12 <metaperl> fascinating
00:29:14 <dons> though i don't know what that could be.
00:29:19 <fnord123> I hax0red you.
00:29:25 <dons> really?
00:29:27 <dons> how so?
00:29:36 <fnord123> by stealing your megahurtz
00:29:49 <dons> more information..
00:30:30 <metaperl> @type uncurry
00:30:32 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
00:30:35 <fnord123> i didnt want you to win, so i sent a multi method despatch packet to your NAT Punch through routine which overloaded the array buffer and corrupted the ml compiler output
00:30:36 <dons> fnord123, are you talking about the icfp contest, or something other way you've haxored me? ;)
00:30:49 <dons> great! thanks :)
00:30:56 <fnord123> which was impressive since you werent using ml
00:31:03 <dons> yeah, quite impressive
00:31:19 <fnord123> i talk like in the movies!
00:31:51 <dons> so at least we were able to confirm that haskell is good for robust, no crashing software. we used HUnit to test the protocol, which was a good idea
00:31:57 <dons> though perhaps I'd use QC next year
00:32:05 <dons> or a combination of the two.
00:32:36 <dons> but more careful performance statistics may be in order
00:33:44 <dons> it would be interesting to know the devel practices of the other haskell teams
00:39:31 <xerox> Good morning, #haskell!
00:42:16 * dons teleports back to .au -- pity teleportation takes 24 hours
00:49:39 <xerox> Enjoy the trip, dons :-D
00:53:42 <Oejet> xerox: Good morning.
01:25:30 <rep> moin
01:26:25 <xerox> Oi!
01:39:49 <Trinsic> i recall when this room was only like 40 people in it. man haskell is catching on!
01:39:58 <Trinsic> tha was only like 3 years ago too.
01:40:08 <lispy> haskel?
01:40:10 <lispy> what's that?
01:40:32 * lispy falls asleep
01:53:26 <Trinsic> llisp always trying to market itself to newbies in the promise that new slaves will be had.
01:56:07 <Pistahh> seems like in irssi /wc is not /who + count people on the channel, but /window close
02:01:45 <Pistahh> "Indeed, you can ask a bot on #haskell to turn programs to its most abstracted form for you"
02:01:53 <Pistahh> which is this bot and how to use it?
02:02:00 <integral> @pl \x -> f x
02:02:00 <lambdabot> f
02:02:07 <integral> @pl \x y -> f y x
02:02:08 <lambdabot> flip f
02:02:28 <integral> @pl \x -> f $ f x
02:02:29 <lambdabot> f . f
02:02:31 <Pistahh> and how does it work? :)
02:02:39 <integral> reasonably well :-P
02:02:44 <Pistahh> @pl \x ->  2*x
02:02:45 <lambdabot> (2 *)
02:02:57 <Pistahh> @pl \x ->  2*x+4
02:02:58 <lambdabot> (4 +) . (2 *)
02:03:23 <Pistahh> @pl let foo x = 2*x in 4
02:03:24 <lambdabot> 4
02:24:15 <shapr> Good morning #haskell!
02:24:35 <Lemmih> Hi shapr.
02:25:10 <shapr> Lemmih: Hey, those hIDE typechecking screenshots are spiffy, can I stick them onto YiWiki?
02:26:12 <Lemmih> Sure.
02:50:57 <xerox> shapr: where where!
03:18:03 <shapr> xerox: http://www.scannedinavian.org/YiWiki/ScreenShots
03:18:47 <xerox> W O W.
03:18:55 <Lemmih> Arg. Too big (:
03:19:34 <xerox> @karma+ Lemmih
03:19:36 <lambdabot> Lemmih's karma raised to 5.
03:21:24 <shapr> Lemmih: Can you make smaller sized images?
03:21:27 <Lemmih> Hi dcoutts.
03:22:36 <xerox> Hiya Duncan.
03:23:40 <dcoutts> hi folks
03:24:25 <dcoutts> Lemmih, comitted any of your code :-)
03:24:37 * dcoutts is eager to run it
03:24:46 <shapr> me too!
03:25:02 <Lemmih> It's not quite ready.
03:25:20 <dcoutts> ok :-)
03:25:59 <Lemmih> I can commit it if you promise not to give me any bug reports or feature requests (:
03:26:45 <Lemmih> shapr: http://212.242.49.100/typechecking.png is now 800x600
03:27:42 <dcoutts> Lemmih, that's ok, we promise, we'll only send patches not bug reports
03:28:13 <nothingmuch> in the article "Basic Polymorphic Typechecking" i see mention of extensions to Milner's algorithm... Could someone priefly enumerate the kinds of extensions that were made?
03:39:08 <dcoutts> shapr, the scannedinavian.org -> 213.242.136.207; while scannedinavian.com -> 194.23.215.164
03:39:54 * dcoutts switches his hIDE & Yi repos from scannedinavian.org to scannedinavian.com
03:45:29 <dcoutts> @where fps
03:45:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
03:48:31 <Lemmih> shapr, dcoutts: pushed.
03:48:47 * jyp claps
03:49:03 <dcoutts> Lemmih, just in time, I've just managed to build the main CommonSense plugin
03:50:30 <Lemmih> Don't type too fast or it will crash (:
03:51:10 <dcoutts> hIDE: unknown exception
03:51:15 <dcoutts> on startup
03:51:35 <Lemmih> Did you rebuild CommonSense?
03:51:51 <dcoutts> let me make clean
03:53:00 <dcoutts> same
03:53:06 <Lemmih> urk.
03:53:13 <dcoutts> it's when loading the haskellsense plugin
03:53:22 <dcoutts> with just the CommonSense one it loads
03:53:56 <Lemmih> Oh yeah. You probably have to fix a path in HaskellSense.
03:54:04 <dcoutts> ok, where?
03:54:24 <Lemmih> Hide.CommonSense.Haskell
03:54:42 <dcoutts> haskellSense = do GHC.init ["-B/usr/lib/ghc-6.4.1"] -- FIXME.
03:54:43 <dcoutts> got it
03:56:03 <dcoutts> ooh it loads
03:56:15 <dcoutts> oh it gives underlined errors :-)
03:56:41 <dcoutts> I know this one's not accurate because of a temp hack, but still it's nice to see it working:
03:56:42 <dcoutts> TempModule.hs:1:7: file name does not match module name `Main'
03:56:55 <dcoutts> so that's not a bug report! :-)
03:57:08 <dcoutts> and it underlines the main in "module Main where"
03:57:10 <dcoutts> yay
03:58:04 <Lemmih> Latency is a severe problem.
03:58:44 <dcoutts> where's the latency?
03:59:36 <Lemmih> The parser isn't run in a background thread so the editor feels very sluggish.
04:00:22 <davve> mornin'
04:00:27 <dcoutts> Lemmih, ah ok I see
04:00:30 <Lemmih> Hi davve.
04:00:44 <dcoutts> davve, if you build hIDE today you'll be impressed :-)
04:00:58 * dcoutts is impressed
04:01:07 <davve> dcoutts, I just tried to. I lack the fps package it sais
04:01:17 <davve> but I don't know what that is
04:01:20 <dcoutts> @where fps
04:01:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
04:01:36 <davve> ah
04:02:15 <Lemmih> Maybe strings are fast enough.
04:02:36 <ndm> does Cabal build under Windows?
04:02:43 <dcoutts> ndm, yep
04:02:52 <ndm> how?
04:02:59 <ndm> i downloaded cabal
04:03:07 <ndm> ghc --make Setup
04:03:17 <ndm> then Setup configure and it complains it can't find ghc
04:05:10 <MarcWeber> Cale, basti_ I've still problems using randoms. It's of type  randoms :: RandomGen g => g -> [a]
04:05:31 <dcoutts> ndm, perhaps ghc is not on your path
04:05:40 <MarcWeber> So it takes an argument which is of type RandomGen which is class.
04:05:47 <ndm> its not on my global path, but it is on my local path
04:05:51 <dcoutts> though cabal ought to be able to find it anyway by looking in the registry
04:05:59 <ndm> hmm, grr
04:06:05 <MarcWeber> Am I right that I can get this class using mkStdGen?
04:06:15 <ndm> will try putting it on my global path...
04:06:15 <dcoutts> ndm, report it as a bug
04:06:42 <ndm> dcoutts, will do
04:07:09 <ndm> dcoutts, by emailing SyntaxNinja?
04:07:38 <ndm> ah, i know exactly the bug cause :)
04:07:41 <sylvan> MarcWeber, yes "mkStdGen 10", say will generate an StdGen for you
04:07:58 <sylvan> however you should use newStdGen in the IO monad somewhere to get a "more random" random generator
04:07:59 <ndm> i have "c:\ghc\..." in my path, with quotes surrounding it
04:08:33 <sylvan> A random generator will always generate the same sequence of random numbers, so you need to generate it with a seed that varies, which newStdGen does (using time or something probably)
04:08:34 <MarcWeber> sylvan: Where is my error? numbers <- randoms $ mkStdGen 2 ;  putStrLn  $ show numbers
04:09:35 <sylvan> randoms isn't of IO type
04:10:02 <sylvan> @eval take 2 $ randoms (mkStdGen 2)
04:10:08 <lambdabot> <irc>:1:9:
04:10:08 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:10:08 <lambdabot>   `Random a' arising from use of `randoms' at <irc>:1:9-15
04:10:08 <lambdabot>   `Show a' arising from use of `show' at <irc>:1:45-48
04:10:08 <lambdabot>   Probable fix: add a type signature that fixes these type variable(
04:10:10 <lambdabot> s)
04:10:20 <sylvan> @eval take 2 $ randoms (mkStdGen (2::Int))
04:10:21 <lambdabot> <irc>:1:9:
04:10:21 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:10:21 <lambdabot>   `Random a' arising from use of `randoms' at <irc>:1:9-15
04:10:21 <lambdabot>   `Show a' arising from use of `show' at <irc>:1:52-55
04:10:21 <lambdabot>   Probable fix: add a type signature that fixes these type variable(
04:10:23 <lambdabot> s)
04:10:27 <sylvan> wth? =)
04:11:17 <sylvan> @eval take 2 $ randoms (mkStdGen 2) :: [Int]
04:11:19 <lambdabot> [-1154341369,688281713]
04:11:33 <sylvan> there!
04:12:06 <MarcWeber> sylvan: Wow! thanks.. That's the point.. And using ::[Int] you also specify the range?
04:12:31 <sylvan> Well [Int] was just to specify the type of the random list since it could be lots of different things..
04:12:50 <sylvan> you could do map (`mod` 4) or something like that to specify range
04:12:57 <sylvan> @eval take 2 $ randoms (mkStdGen 2) :: [Double]
04:13:00 <lambdabot> [0.23123395599686403,0.6602530742902898]
04:13:31 <sylvan> @eval take 2 $ randoms (mkStdGen 2) :: [Bool]
04:13:33 <lambdabot> [True,True]
04:14:44 <sylvan> randomR allows you to generate a single random value with range (it also returns a new generator that you use for the next value)
04:15:31 <MarcWeber> sylvan: I've understood that part of documentation ;) But can you help me again and tell me why I get the error Could'nt match `[Int]' against `IO ()'  here:
04:15:38 <MarcWeber> putStrLn  $ show $ randoms (mkStdGen 2) :: [Int]
04:16:25 <sylvan> it thinks you mean that putStrLn :: [Int]
04:17:02 <MarcWeber> Thanks!
04:17:06 <sylvan> putStrLn ( show ( randoms (mkStdGen 2) :: [Int]))
04:17:22 <MarcWeber>  putStrLn  $ show (randoms (mkStdGen 2) :: [Int])     is sufficient
04:17:40 <sylvan> in real applications you probably don't have to use "::[Int]" since it will figure out the type of the random list by how you use it
04:18:32 <Trinsic> what are advantages of haskell over lisp?
04:18:34 <shapr> hoi boegel
04:18:38 <sylvan> less paranthesis =)
04:18:44 <MarcWeber> @eval genRange (mkStdGen 2)
04:18:45 <shapr> more types
04:18:46 <lambdabot> (-2147483648,2147483647)
04:18:49 <sylvan> more purity
04:18:55 <sylvan> more laziness
04:19:05 <shapr> typeclasses
04:19:43 <MarcWeber> bigger output ;) Try making a C compiler output that 50kb when only printing "Hello World" :)
04:19:58 <sylvan> use nhc!
04:20:00 <sylvan> or jhc!
04:20:15 <boegel|home> y0 shapr
04:20:20 <boegel|home> shapr: TMR5 out yet ?
04:21:01 <Trinsic> slyan, how about less code per functionality?
04:21:17 <Trinsic> I think that types is the big loss with lisp.
04:21:50 <Trinsic> having none makes implementing standards across people makes it defunct.
04:22:09 <sylvan> Haskell has nicer syntax, IMO, and is also a lot "safer". Increased correctness, meaning increased productivity..
04:22:14 <dcoutts> ndm, yep email SyntaxNinja
04:23:20 <Trinsic> slyan, so the word isn't out is if it's less code than a similtanous lisp implementation is or not?
04:24:30 * Lemmih failed to parse that sentence.
04:27:29 <MarcWeber> sylvan: Can you tell me how to tell ghci to import Random? I want to check some types without bothering lambdabot and therefore everyone listening in here
04:27:35 <sylvan> :m Random
04:27:44 <sylvan> Trinsic, I'm not sure what you mean...
04:28:38 <MarcWeber> sylvan: exaclty.. I've missed that option.. I've only tried -package and :l without success ;(
04:29:30 <sylvan> MarcWeber, the m is for module
04:32:16 <Trinsic> slyan, less typed (or duplicated code, or administrative code) than lisp.
04:32:26 <Trinsic> also, where is a good baby tutorial on haskell?
04:32:48 <sylvan> I would think that Haskell is slightly more concise than Lisp.. but I wouldn't expect the difference to be as noticable as with, say, Java
04:33:03 <sylvan> Yet Another Haskell Tutorial is quite good
04:33:56 <Trinsic> k
04:33:58 <Trinsic> thx.
04:33:59 <MarcWeber> What do you know after specifying data StdGen? All you know that there is data type called StdGen.. Do you know anything more?
04:34:24 <sylvan> MarcWeber, what do you mean?
04:34:57 <MarcWeber> sylvan: Reading the documentation of the module Random I don't know exaclty what data StdGen means..
04:35:16 <sylvan> It's abstract, don't worry about it. It means "here's something which makes random numbers"
04:35:24 <sylvan> you don't need to know the implementation
04:35:25 <MarcWeber> I know data Bool= TRUE | FALSE or something like this which means Bool is either TRUE or FALSE.. But
04:35:53 <sylvan> Well that's sort of the point with data encapsulation, you know that it's there, and what to do with it (passing it to randoms, say) but you don't know how it's implemented
04:36:05 <MarcWeber> sylvan: That's the point. Why do I know that it makes random numbers? Because it has got this name?
04:36:33 <sylvan> Because it's defined in Random and the functions that use it return random numbers
04:36:36 <MarcWeber> Or because it's used in some other functions dealing with random numbers?
04:37:15 <sylvan> so you only need to know "in order to use randoms, I must create a value of type RandomGen, for example an StdGen)
04:37:22 * boegel|home pokes shapr with his baseball bat
04:38:36 <MarcWeber> sylvan: Now I want to have list containing random numbers within the range of [0..10::Int]. So I need something like randoms $ randomR (0,10) StdGen ?
04:39:04 <MarcWeber> @type randomR
04:39:06 <lambdabot> bzzt
04:39:56 <sylvan> yes, randomR would do the trick, so you'd need to create a function called randomsR or something which takes a range and an RandomGen and produces an infinite list of random numbers
04:40:19 <sylvan> there's no such function defined as far as I know, but it's quite simple to write one yourself
04:41:13 <sylvan> randomsR :: (Random a, RandomGen g) => (a,a) -> g -> [a]
04:41:17 <sylvan> that should be its type
04:42:46 <sylvan> @eval let randomsR (a,b) g = let (x,g') = randomR (a,b) g in x : randomsR (a,b) g' in take 5 (randomsR (1,5::Int) (mkStdGen 54))
04:42:49 <lambdabot> [5,2,4,4,1]
04:42:49 <MarcWeber> sylvan: Thanks.. I think I must use . to concat the functions.. wait
04:43:09 <sylvan> that works.. however it's slightly ugly due to having to use let's instead of where's, IMO
04:46:47 <shapr> boegel|home: No, but I'm working on it right now.
04:48:10 <shapr> boegel|home: Hey, want to proofread? http://www.haskell.org/tmrwiki/IssueFive
04:48:23 <shapr> boegel|home: I'm converting CosmicRay's article right now.
04:52:59 <boegel|home> shapr: sorry, no time to proofread, I'm working...
04:53:29 <shapr> ok
04:53:33 <shapr> Man it's sunday!
04:53:44 <shapr> boegel|home: Check out the braincandy - http://www.scannedinavian.org/YiWiki/ScreenShots
04:55:13 <wagerlabs> hello
04:55:21 <boegel|home> shapr: nice
04:55:23 <boegel|home> hey wagerlabs
04:55:26 <wagerlabs> is there a paste bot here?
04:55:37 <wagerlabs> or do i just paste code snippets right into the window?
04:55:49 <boegel|home> wagerlabs: no, use the wiki
04:55:52 <boegel|home> @paste
04:55:53 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:56:04 <wagerlabs> looking
04:56:36 <manulito> shapr: what editor is that?
04:56:47 <sylvan> hIDE!
04:57:27 <manulito> not in gentoo portage =(
04:58:06 <sylvan> nah it's pre-pre-pre-alpha right now.. =)
04:58:24 <sylvan> @where hIDE
04:58:25 <lambdabot> http://www.haskell.org/hawiki/hIDE
04:58:49 <manulito> so i might wait with it then, since im kinda new to haskell =)
04:59:08 <MarcWeber> manulito: Which editor?
04:59:55 <manulito> @where hIDE
04:59:56 <lambdabot> http://www.haskell.org/hawiki/hIDE
05:00:04 <wagerlabs> folks, i'm having newbie problem. pasted to the wiki
05:00:12 <sylvan> @paste
05:00:13 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:00:26 <MarcWeber> sylvan: When is randomR used? you have to specify the range, it returns one value within that range and a new RandomGen .. ?
05:00:33 <wagerlabs> did i paste it wrong? :)
05:00:54 <sylvan> MarcWeber, yes. So you generate one value, and then use the new generator for the next value...
05:01:16 <sylvan> so you need to thread the new generators to subsequent calls to randomR
05:01:49 <sylvan> a function will always return the same value given the same parameters, thus if you pass the same RandomGen to a random function you will always get the same random value
05:01:59 <wagerlabs> could someone give me a helping hand, please? it's the packet stuff at the end of the wiki page
05:03:15 <Lemmih> wagerlabs: You need -fglasgow-exts if you want type synonyms to be instances of classes.
05:03:21 <sylvan> wagerlabs, seems pretty difficult that.. being that a string can be of infinite length
05:03:21 <wagerlabs> ah
05:03:39 <Lemmih> wagerlabs: And the type of splitAt is: splitAt :: Int -> [a] -> ([a], [a])
05:03:41 <wagerlabs> sylvan: what do you mean?
05:03:55 <wagerlabs> i'm just strying to parse a pascal-style string
05:03:59 <wagerlabs> where the length is the first byte
05:04:12 <sylvan> well if you want to read a packet of type String you will always read every single byte since it won't know when the next packet begins
05:04:19 <sylvan> ah.. sorry
05:05:07 <manulito> i have a list with functions, and a list with values, i would like to use each function on the corresponding value in the value-list if the value passes some preducate, like [pred,pred,succ] [10,15,5] on values >5, so it would yield [9,14]. Is there smart way to do this? best way i found out is zipWith and then a generator that creates a new list tho only takes the "ok" values.
05:05:22 <sylvan> zipWith ($) funs vals
05:05:42 <wagerlabs> Lemmih: that worked but i'm now getting an error since i'm passing a Word8 as an argument to splitAt which takes an Int
05:05:43 <sylvan> ah or maybe not
05:05:51 <Lemmih> wagerlabs: How about making FastString an instance of Packet instance of String?
05:06:09 <Lemmih> wagerlabs: That's because the type of splitAt is: splitAt :: Int -> [a] -> ([a], [a])
05:06:18 <wagerlabs> Lemmih: that would be swell but what would it give me?
05:06:19 <manulito> i could write a similar funktion like $ and then let it skip uncorrect values, then extract a new list with generators. but seems like a bad way
05:06:31 <Lemmih> wagerlabs: It would be faster.
05:07:01 <sylvan> manulito, something like: f p funs vals = map (\(a,b) -> a b) (filter (\(a,b) -> p b) (zip funs vals))
05:07:10 <wagerlabs> Lemmih: ok, how would i do that? instance FastString Packet String?
05:07:12 <sylvan> where p is the predicate
05:07:29 <Lemmih> wagerlabs: instance Packet FastString where ...
05:07:36 <wagerlabs> Lemmih: oh, i see now
05:07:54 <wagerlabs> Lemmih: i suppose i could lazily convert the fps when i need to do it
05:08:05 <Lemmih> wagerlabs: So remove the unpack and apply 'formIntegral' to 'x'.
05:08:16 <wagerlabs> trying...
05:08:24 <Lemmih> *fromIntegral
05:08:30 <manulito> thanks sylvan, gonna try to understand that line
05:08:57 <wagerlabs> i'm learning something new with every minute
05:09:20 <wagerlabs> how to do type-casting for example :-)
05:09:29 <sylvan> manulito, first you group each function with its value, then you filter out only the legal ones, then you apply the function
05:09:56 <paolino> hello everyone, why max (1,2) fails in ghci ?
05:10:24 <Lemmih> paolino: Because 'max' doesn't take a tuple as its first argument.
05:10:28 <Lemmih> @eval max 1 2
05:10:33 <lambdabot> 2
05:10:42 <paolino> :/
05:10:42 <Lemmih> @eval fst (1,2)
05:10:43 <lambdabot> 1
05:11:41 <sylvan> @eval uncurry max (1,2)
05:11:42 <lambdabot> 2
05:12:38 <wagerlabs> Lemmih: i'm importing FPS like this import qualified Data.FastPackedString as FPS but when i try to do various permutations of instance Packet FPS.FastPackedString where ... it doesn't work
05:12:48 <paolino> sylvan ,what is that ?
05:13:05 <Lemmih> wagerlabs: The type is called FastString.
05:13:06 <sylvan> paolino, uncurry takes a function of two parameters and makes it a function that takes a tuple
05:13:13 <sylvan> @type uncurry
05:13:14 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
05:13:15 <wagerlabs> i'm an idiot, it's FastString
05:13:16 <wagerlabs> yes
05:14:25 * shapr boings cheerfully
05:14:55 <wagerlabs> Lemmih: right now i plan to read a FastString from a socket and then unpack it into a [Word8] so that I would apply the packet functions. Cale suggested that I just use FastString but I can't figure how to read a Word16 from a FS, for example. any pointers?
05:15:03 <shapr> Lemmih: Man, these CommonSense screenshots are awesome :-)
05:15:55 <Lemmih> wagerlabs: There's a library called NewBinary which does what you want.
05:16:08 <wagerlabs> looking
05:17:48 <Lemmih> shapr: Did you checkout the code?
05:17:49 <shapr> @where NewBinary
05:17:50 <lambdabot> I know nothing about newbinary.
05:18:03 <shapr> Lemmih: Not yet, when I finish TMR5.
05:18:10 <wagerlabs> i got NewBinary, trying to figure out how to open a BinHandle into a FPS
05:18:24 <shapr> I'm collecting hIDE screenshots and info for my editorial.
05:19:00 <shapr> wagerlabs: hey! Want to write for TMR?
05:19:10 <wagerlabs> shapr: what's TMR?
05:19:16 <shapr> The Monad.Reader
05:19:28 <Lemmih> wagerlabs: You can avoid the FastString completely.
05:19:42 <wagerlabs> shapr: hmm... i won't have a lot to contribute at this point, i'm afraid :-) i'm just learning haskell
05:19:42 <shapr> Since you're coming from Erlang, Java, and OpenPoker, I think you'd have a neat perspective.
05:19:52 <wagerlabs> shapr: i do but i'm a n00b
05:19:54 <shapr> wagerlabs: Ah, but that's what I want you to write about :-)
05:20:00 <wagerlabs> shapr: oh
05:20:07 <shapr> For example, see Graham Klyne's Learning Haskell Notes...
05:20:10 <wagerlabs> shapr: hmm... i can try
05:20:16 <wagerlabs> shapr: where are these notes?
05:20:29 <shapr> wagerlabs: http://www.haskell.org/tmrwiki/IssueThree
05:20:44 <wagerlabs> shapr: will look in a second
05:20:46 <shapr> ok
05:21:19 <wagerlabs> Lemmih: but if i avoid it then i would need to figure out how to get a [Word8] array using NewBinary :-)
05:21:43 <Lemmih> Where do you get the [Word8] from?
05:21:57 <wagerlabs> let me dig up the link for you...
05:22:22 <wagerlabs> Lemmih: http://www.mail-archive.com/haskell-cafe@haskell.org/msg09413.html
05:22:39 <wagerlabs> Lemmih: i like cale's idea of composing packet structures
05:22:54 <wagerlabs> Lemmih: and he does it from [Word8]
05:23:00 * shapr hugs Cale 
05:23:20 <wagerlabs> hmm... cale is lemmih? :D
05:23:36 <Lemmih> Nope.
05:23:42 <wagerlabs> hey, i don't know anyone here yet. except for shapr being ScandInAvian of course
05:23:57 <shapr> cale is Cale
05:23:58 <Lemmih> wagerlabs: You can use NewBinary to read data from a socket.
05:24:38 <Lemmih> (atleast I think you can)
05:24:46 <shapr> wagerlabs: I own and admin the ScannedInAvian box, but most of the code there is written by other people who have accounts there.
05:24:54 <wagerlabs> Lemmih: but how would i describe the packet structure then? i still like the way cale is doing it. he suggested just using FPS as the underlying instead of [Word8]
05:25:20 <wagerlabs> i figure that if i can open a BinHandle (from NewBinary) into the FPS then I get the best of both worlds
05:25:26 <Lemmih> wagerlabs: NewBinary has a Binary class with looks a lot like your Packet class.
05:25:58 <shapr> wagerlabs: I'm also the editor of TMR, the maintainer of the Haskell Wiki, and the maintainer of the #haskell channel.
05:26:18 <wagerlabs> Lemmih: my packets have the size at the beginning so i figured i could just read the whole packet into a FPS
05:26:27 <wagerlabs> Lemmih: looking at the binary structure...
05:27:07 <shapr> There are still lots of people here who are smarter and write more code.
05:27:08 <wagerlabs> shapr: ok :-)
05:27:35 <shapr> I'm a self-employed webdeveloper, so I don't do as much as I'd like.
05:27:45 <shapr> wagerlabs: Hey, where are you from anyway? US? UK?
05:27:56 <wagerlabs> shapr: i'm self-employed too. i'm russian/cuban :)
05:28:00 <shapr> oh nifty!
05:28:11 <wagerlabs> shapr: currently in stockholm
05:28:15 <shapr> That's a really cool combination, must be a fascinating story behind that.
05:28:27 <wagerlabs> shapr: surely ;)
05:28:30 <shapr> Yeah, I know you're self-employed and in stockholm. That info is on your blog.
05:28:41 <wagerlabs> where's my story...
05:28:48 <shapr> I haven't looked at OpenPoker yet though.
05:29:24 <shapr> I was really surprised to hear that companies wouldn't use your obviously superior software only because it's not written in Java!
05:29:51 <wagerlabs> http://wagerlabs.com/uptick/2005/08/worse-is-better.html, look below --Aaron :)
05:30:23 <wagerlabs> shapr: well, i can understand them. superiority does not always win the day. basic marketing.
05:30:47 <shapr> I can't understand them. It seems like sticking with horses because you don't have any mechanics.
05:31:24 <Oejet> shapr: Mechanics had it tough too the first many, many years.
05:31:41 <shapr> wagerlabs: By the way, I've thought deeply on WiB, and I think I've found a solution...
05:32:07 <wagerlabs> shapr: actually, they do have mechanics, they are just more complicated to use
05:32:12 <wagerlabs> shapr: and the solution is?
05:32:18 <shapr> Oleg Kiselyov has a recent paper where he uses Scheme to generate optimal math code in a single pass.
05:32:30 <shapr> I think the solution is "Simplicity is Better"
05:33:01 <shapr> Speed of change is the most important part of software, and software engineering.
05:33:19 <wagerlabs> Lemmih: i think i'll try designing my packets around NewBinary and see what happens
05:34:12 <wagerlabs> shapr: simplicity is better, yes but... sometimes we are our own worst enemies. the simplest way to do what i'm trying to do now (write a protocol adapter in haskell) would be to do it in erlang but
05:34:15 <dons> so did you out how to use Data.Bits to build aa Word16 from two Word8's ?
05:34:31 <wagerlabs> shapr: i also want to learn haskell so i'm taking the more complex route
05:34:34 <shapr> dons: Are you teleported now, or en route?
05:34:39 <wagerlabs> dons: Lemmih suggested that i skip fps entirely
05:34:45 <dons> waiting for the plane
05:34:58 <dons> wagerlabs, perhaps you should.
05:35:07 <dons> only use it if youu have a serious performance issue
05:35:11 <wagerlabs> dons: so i decided to try building the packets around the Binary typeclass from NewBinary since they have read/write for basic types already
05:35:33 <dons> right. ok.
05:35:49 <dons> but you'll need to write the glue code to hook in FastStrings.
05:36:03 <dons> Lemmih, cheerrs
05:36:22 <wagerlabs> dons: i don't intrinsically need fast strings, that's the thing. i need strings, yes, but that's it
05:36:27 * dons has 2 thunkified fps patches sitting in my inbox now
05:36:44 <dons> so why all the concern about FastStrings?
05:36:44 <wagerlabs> dons: i have pascal-style strings in my packets where i have to read the length and then the string itself
05:36:58 <dons> sure, ok.
05:37:10 <dons> still don't get why you need to use FastStrings
05:37:12 <wagerlabs> dons: dunnno, i'm a newbie with haskell so i thought fast strings were a good idea
05:37:19 <wagerlabs> dons: i really don't need to use them
05:37:22 <dons> oh, the name is good advertising.
05:37:43 <dons> but perhaps it misleads beginners into thinking they're `better' than String.
05:38:16 <dons> they solve a problem that somtimes arises in some large applicatoins, but should not be used for every program.
05:38:29 <dons> lazy Strings are fine for many (most?) applications
05:38:55 <wagerlabs> so ... how would i build a pascal-style string with NewBinary? I suppose I would first read a Word8, then read a ByteArray of that size
05:39:08 <wagerlabs> then how do I convert that byte array to a String?
05:39:11 <Lemmih> dons: Are you familiar with ByteArray#'s, btw?
05:39:15 <dons> yep
05:39:19 <dons> yi used to use them for buffers
05:39:33 <dons> FastString in GHC uses them, iirc?
05:39:39 <wagerlabs> getByteArray :: BinHandle -> Int -> IO ByteArray
05:40:01 <Lemmih> dons: Yeah, they're also used in StringBuffer's which GHC uses for parsing and lexing.
05:40:16 <dons> ah, right.
05:40:21 <Lemmih> dons: How easy would it be to convert a CString to a ByteArray#?
05:40:26 <dons> easy.
05:40:31 <dons> unsafeCoerce# I think
05:40:47 * dons seems to recall doing tihs magic in the old Yi Buffer code.
05:40:53 <dons> shapr might remember that trick
05:40:54 <Lemmih> I tried that and it went pretty bad. (:
05:41:00 <wagerlabs> so what about ByteArray back into a [Char]?
05:41:00 * Lemmih will try again.
05:41:16 <dons> hmm. maybe there's some other primop you need.
05:41:34 <dons> you sure you don't want a MutableByteArray?
05:41:40 <wagerlabs> dons: there's nothing in NewBinary re that
05:41:40 <dons> #
05:41:45 <Lemmih> dons: Yeah.
05:41:49 <wagerlabs> dons: i just need to display a string
05:42:02 <wagerlabs> dons: like a user name or a location or something along those lines
05:42:02 <dons> can you show a ByteArray?
05:42:21 <wagerlabs> dons: no idea yet
05:42:34 <wagerlabs> dons: i suppose i can convert it into a FPS :D
05:42:43 <wagerlabs> dons: maybe
05:42:44 <dons> you probably could, yes.
05:42:56 <dons> though maybe it would be better if I wrote a function to do this
05:43:09 <dons> more constructors and destructors for fastStrings are still needed
05:45:15 <wagerlabs> dons: there's code in Binary.hs for FPS but it's commented out for some reason
05:45:24 <dons> there is??
05:45:34 <dons> oh, you probably mean Data.PackedString?
05:45:55 <shapr> wagerlabs: I think you can have both a high level language and performance, see http://lambda-the-ultimate.org/node/view/652
05:45:57 <wagerlabs> dons: one bit of particular interest is that the size of a ByteArray is not the same as the size of a FastString since the former is rounded up to a word
05:46:06 <shapr> "Oleg points out that the point isn't that they managed to reproduced the FFTW results. The crucial point is that we know exactly which identities (i.e., axioms) contributed to the optimum. The search was principled rather heuristic, and the code is generated in only one pass. There are no manipulations on the code: it is generated just right."
05:46:45 <wagerlabs> dons: no, take a look at the end of Binary.hs
05:46:51 <wagerlabs> it's FastString stuff
05:46:56 <wagerlabs> but commented out for some reason
05:47:47 <wagerlabs> shapr: i agree with you. some people produce c for FFT from ocaml
05:48:05 <shapr> I suspect the best speed comes from higher level languages, because they allow more optimizations.
05:48:17 <wagerlabs> dons: see it?
05:48:31 <dons> sorry, busy getting ready for a 24 hr plane flight
05:48:37 <wagerlabs> dons: oops
05:48:43 <wagerlabs> dons: australia :-)
05:48:44 <dons> i'm surprised, since FPS was only realeased a couple of weeks ago
05:49:06 <dons> so Mr. NewBinary (who's that?) must be using FPS.
05:49:10 <Lemmih> dons: http://212.242.49.100/unsafeCoerce-gone-bad.png
05:49:23 * dons gets ready for fun..
05:49:38 <shapr> dons: stepcut, Jeremy Shaw
05:49:50 <dons> oopps. Lemmih
05:50:10 <dons> well, at least the bytes are still there.
05:50:15 <shapr> He's hosting the NewBinary repo, he updated Hal Daume's NewBinary (and Hal got it from .. GHC? who got it from nhc98, I think)
05:50:15 <dons> shapr, thanks.
05:50:27 <dons> that sounds right to me.
05:50:43 <dons> I also stole Binary from GHC (who stole it from NHC) for use in hs-plugins .hi file parsing
05:50:55 <dons> and then syntaxNinja stole that code, for purposes unknown.
05:50:59 <shapr> Sounds like it desperately needs to be a standard lib.
05:51:10 <dons> yes!
05:51:16 <Lemmih> dons: This is how it should look: http://212.242.49.100/normal.png
05:52:01 <dons> oh, much nicer
05:52:24 <dons> hmm.
05:55:03 <dons> Joel, you should just mail the author directly
05:55:18 <sylvan_> damn.. compiling ghc sure takes a long time...
05:55:30 <dons> it's not big issue, but your questions are a bit too specific for haskell-cafe@ I think.
05:57:22 <wagerlabs> dons: oops. i still haven't gotten the differences between haskell and haskell-cafe.
05:57:40 <wagerlabs> dons: but i'll keep it in mind, thanks
05:57:42 <shapr> sort of like "announcements" and "discussion"
05:57:45 <sylvan_> haskell-cafe is more of a high-frequency list, whereas haskell is for people who don't have time to read long discussions
05:58:21 <wagerlabs> so my question did not seem like an announcement and i thought i would ask everyone. maybe someone else knows and the author could be busy
05:58:56 <shapr> What's your question exactly? How to read a PS from a Socket?
05:58:57 <dons> haskell-cafe is better than haskell, but asking "why is this line commented out" is even too specifc for haskell-cafe@. Only the author is going to know
05:59:14 <wagerlabs> dons: you are probably right
05:59:27 <dons> anyway, no harm done :)
05:59:34 <wagerlabs> shapr: my question is why the code at the end of Binary.hs (NewBinary) that reads and writes FastStrings is commented otu
05:59:38 <wagerlabs> out
05:59:50 <dons> does it live in a darcs repo?
05:59:56 <wagerlabs> dons: yes
06:00:02 <dons> you could check the change log.
06:00:07 <dons> darcs changes -v
06:00:09 <wagerlabs> Pulling from "http://www.n-heptane.com/nhlab/repos/NewBinary"...
06:00:31 <dons> or is it darcs annotate ? /me can never remember
06:02:44 <shapr> hiya Philippa
06:03:45 <wagerlabs> mmm... NewBinary is probably big-endian. any conversion code for haskell?
06:04:49 <dons> probably big-endian?
06:05:06 <dons> it doesn't just use the native word endianess?
06:06:24 <jyp> @where fps
06:06:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
06:06:25 <wagerlabs> hmm... probably does but the kind people who wrote the original poker client for me assumed that their server will be delphi also. and run on intel. so they are not only dumping huge nexted delphi object trees, they are also doing everything little-endian :(
06:06:54 <wagerlabs> whereas openpoker is big-endian
06:07:30 <wagerlabs> so i need to convert back and forth. i think they are also dumping floats (argh!) so i'll need to figure out how to read a float in haskell
06:08:08 <dons> well, you hvae Datta.Bits, so you can do anything
06:08:11 <dons> :)
06:08:12 <shapr> If you can pull in the bits, encodeFloat/decodeFloat are available for IEEE754 floats.
06:08:18 <dons> also that :)
06:08:29 <Lemmih> CFloat is an instance of Storable.
06:08:41 <wagerlabs> shapr: what is "pull in the bits"? i'll be using NewBinary
06:08:43 <shapr> The mantissa, and the other part... (what's the name again?)
06:09:15 <wagerlabs> shapr: decodeFloat would probably work...
06:09:15 * dons disappears till Singapore..
06:09:27 <wagerlabs> have a good flight dons
06:09:29 <sylvan_> shapr, exponent?
06:09:50 * wagerlabs is digging through NewBinary trying to figure out how to pull in the bits
06:09:56 <shapr> dons: have fun!
06:10:01 <shapr> sylvan_: Yeah, that one.
06:10:11 <shapr> wagerlabs: Minä en tieda.
06:10:17 <wagerlabs> there's getBits
06:11:15 <wagerlabs> getBits :: BinHandle -> Int -> IO Word8
06:11:25 <wagerlabs> does it mean i can only read in 8 bits at a time?
06:11:26 <shapr> Puhutko suomea?
06:11:32 <wagerlabs> haha
06:11:36 * Lemmih wonders why bittornado thinks it's necessary to use 20% of my mem and 10% of my CPU when downloading three files.
06:11:42 * wagerlabs kind of hates finnish
06:12:01 <shapr> Lemmih: imho, all Python implementations of BT suck.
06:12:04 <shapr> wagerlabs: Aw, I like it.
06:12:35 <Lemmih> shapr: Ping me when your client is ready (:
06:12:50 <shapr> It'll be awhile, I've promised myself that FLM is the next thing I'll finish.
06:13:24 <wagerlabs> shapr: decodeFloat needs a RealFloat to start with but what do i do if i have 4 bytes that represent the float?
06:14:06 <jyp> @where ghc-api
06:14:07 <lambdabot> I know nothing about ghc-api.
06:14:11 <shapr> @eval decodeFloat 5.2
06:14:12 <lambdabot> (5854679515581645,-50)
06:14:21 <jyp> Anyone does?
06:14:26 <Lemmih> @where+ ghc-api http://scannedinavian.com/~lemmih/ghc-api
06:14:27 <wagerlabs> shapr: what does that give me?
06:14:27 <lambdabot> ghc-api ~> http://scannedinavian.com/~lemmih/ghc-api
06:14:33 <Lemmih> jyp: Building hIDE?
06:14:47 <wagerlabs> shapr: say delphi dumped a float into a packet and sent over to me
06:14:53 <jyp> You are very clairvoyant :)
06:14:55 <shapr> Ok, how does it dump a float?
06:14:58 <wagerlabs> shapr: i need to convert that to a float
06:15:10 <wagerlabs> shapr: let me look it up but i think it's the standard format
06:15:35 <shapr> If it's a standard IEEE754 float, then you can probably suck it up with something like Storable.
06:15:39 <sylvan> let (a,b) = decodeFloat x in a * (2**b)...
06:15:42 <sylvan> or something like that
06:15:49 <shapr> Grab it as a CFloat as Lemmih suggested.
06:16:02 <jyp> I'll be a happy man when all these become debian packages ;p
06:16:27 <shapr> jyp: start making packages!
06:16:38 <wagerlabs> shapr: don't know how to grab it as a CFloat using NewBinary. looking
06:16:46 <jyp> shapr: good plan
06:16:59 <jyp> I've started reading the debian docs
06:17:34 <shapr> Man, I want the @info command back.
06:17:46 <jyp> Though I guess there is a big master plan about that somewhere
06:18:14 <shapr> jyp: To debianize everything? No master plan that I've heard of...
06:18:20 <shapr> jyp: You want to write the plan?
06:18:42 <shapr> wagerlabs: If you have ghci handy, :m + Foreign and then :info Storable
06:19:11 <wagerlabs> shapr: doing
06:19:34 <jyp> For some reason I thought igloo was on it already... In any case I need more knowledge before starting doing so
06:19:35 <shapr> wagerlabs: I've not used it before, but I think you'll be able to turn a pointer into a CFloat with peek
06:20:03 <shapr> jyp: You could ask about packaging status on debian-haskell
06:20:18 <wagerlabs> shapr: i'm going bonkers
06:20:24 <wagerlabs> shapr: too much new info
06:20:28 <shapr> sorry :-)
06:20:40 <jyp> shapr: I should
06:20:42 <jyp> :)
06:20:52 <shapr> wagerlabs: My suggestion is to write SpikeSolution for each new library/solution. Then you know vaguely what they cover and how they do things.
06:21:03 <wagerlabs> shapr: and the connections aren't all clear. i.e. i would need to go from ByteArray to a Ptr now
06:21:08 <wagerlabs> shapr: i'll try
06:21:43 <shapr> I write simple prototypes for each new library I encounter, then when I forget what they do, I can check my homebuilt reference manual.
06:22:00 <wagerlabs> shapr: ok
06:23:02 <wagerlabs> shapr: any endian conversion code in haskell?
06:23:17 <shapr> Probably, but I don't know.
06:23:29 <shapr> I've never delved into that part of the libs.
06:27:02 <jyp> Building ghc-api-0.1...
06:27:02 <jyp> ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
06:27:12 * jyp sobs
06:27:45 <Lemmih> Unknown exception?
06:27:54 <jyp> Unknown exception, yes
06:29:46 <Lemmih> Using FreeBSD?
06:29:59 <jyp> linux/amd64
06:30:50 <boegel|home> any C people in here, I'm getting a compilation error which I don't understand
06:31:11 <jyp> feel free boegel
06:39:36 <sylvan> Trying to build hs-plugins: src/AltData/Typeable.hs:452:0: parse error (possibly incorrect indentation)
06:40:17 <jyp> source probably need preprocessing
06:40:26 <sylvan> yeah, but how?
06:40:31 <jyp> did you build with Setup.hs ?
06:40:33 <sylvan> runhaskell Setup.hs build
06:41:06 <jyp> runhaskell Setup.hs configure?
06:41:18 <sylvan> yeah
06:41:48 <jyp> with no error whatsoever ?
06:42:04 <Lemmih> sylvan: Add the path to the GHC include dir.
06:42:06 <sylvan> warnings, but no errors
06:42:36 <sylvan> Lemmih, what?
06:43:12 <Lemmih> GHC-Options: -I/usr/lib/ghc-6.4.{something}/include/
06:45:20 <sylvan> in plugins.cabal right?
06:45:26 <Lemmih> Yeah
06:45:30 <sylvan> Now I get: The field "hs-source-dir" is deprecated, please use hs-source-dirs.
06:45:30 <sylvan> Setup.hs: plugins.cabal:39: 'Executable' stanza starting with field 'hs-source-dirs'
06:46:19 <Lemmih> Be careful with newlines.
06:46:38 <sylvan> I haven't added any newlines...
06:46:53 <sylvan> just -I/usr/local/lib/ghc-6.5.20051001/include/
06:47:33 <Lemmih> And there's no newline before hs-source-dirs?
06:47:41 <sylvan> nope
06:48:09 <sylvan> The field "hs-source-dir" is deprecated, please use hs-source-dirs.
06:48:09 <sylvan> Setup.hs: plugins.cabal:1: Unknown field 'in pname'
06:48:18 <sylvan> ?
06:49:57 <sylvan> "in p" had worked itself into the first part of the file.. after I remove it it doesn't complain about the cabal-packagge, but I still get the "posibly incorrect indentation" error
06:50:16 <Lemmih> Touch the file.
06:51:13 <sylvan> hmm.. when i included the 6.4 includes that file worked, but now I get errors in other places.. /tmp/ghc24730_0.hc: In function ‘scHv_ret’:
06:51:13 <sylvan> /tmp/ghc24730_0.hc:6670: error: ‘stg_MUT_ARR_PTRS_FROZEN0_info’ undeclared (first use in this function)
06:52:35 <sylvan> with the 6.5.20051001 includes Typeable doesn't work
06:52:47 <Lemmih> Hm.
06:55:25 <sylvan> hmm.. compling with the 6.4 includes and as root worked, but I had to be root
06:56:11 <sylvan> or maybe it didn't work...
06:56:13 * Lemmih thinks AltData should be gutted.
06:56:35 <sylvan> nope, it didn't... no errors but when loading the package I get unknown symbols
06:59:11 <sylvan> *sigh*
07:03:52 <lisppaste2> paolino pasted "Binary Tree Exercise" at http://paste.lisp.org/display/12138
07:04:21 <paolino> help appreciated
07:05:41 <Lemmih> paolino: 'leaves leaf' is wrong.
07:05:43 <sylvan> paulino, change to (leaves left)++[leaf]++(leaves right)
07:08:57 <paolino> right ,one more question why I can't change data def in data BinaryTree leaf = Leaf leaf|Branch (BinaryTree leaf) (Leaf leaf) (BinaryTree leaf)
07:09:22 <sylvan> why would you?
07:09:48 <sylvan> I think the type variable "leaf" is confusing, it's not a leaf, it's the type of the values in each of the nodes
07:09:51 <Lemmih> Leaf is a data constructor, not a type constructor.
07:09:56 <sylvan> call it "a" or something
07:11:05 <paolino> shouldn't it be tha same as first occurrence of 'Leaf' in that line ?
07:11:35 <sylvan> No, Leaf is a construcor which constructs a leaf, but in the node you don't want a leaf, you just want the value
07:11:51 <sylvan> as I said, that type variable shouldn't be called "leaf"...
07:11:57 <sylvan> "value" or just "a" is better
07:12:41 <Philippa> I do find properly-named type variables help sometimes - but "leaf" isn't an accurate name
07:12:57 <sylvan> BinaryTree v = Leaf v | Branch (BinaryTree v) v (BinaryTree v)
07:12:59 <sylvan> much clearer
07:13:13 <sylvan> So in a Branch you store two trees and a value, and in a leaf you just store a value
07:13:30 <paolino> I'm not interested actually in symbols
07:14:13 <paolino> but now I can see Lemmih point .second Leaf is a type referent
07:14:21 <paolino> is this right?
07:15:00 <sylvan> I think the misnamed type variable is confusing you. The type variable has nothing to do with leaves, other than the fact that the Leaf stores a value of that type (but branches do too!)
07:15:17 <paolino> I got that thanks,it was
07:16:09 <paolino> leaftype should be appropriate
07:16:29 <paolino> ?
07:16:31 <sylvan> no not really, because it's not specific to leaves, it's stored in branches too
07:16:50 <paolino> than value
07:17:04 <sylvan> Every Branch in the tree stores a value, and every leaf in the tree stores a value. The type variable represents the type of these values
07:17:15 <sylvan> So "value" is a better descriptive name
07:17:36 <sylvan> Because if you call it "leaf" or "leaftype" you imply that it is only used in the leaves, and not the branches
07:18:06 <Philippa> "label" might be appropriate (as in "labelled graph")
07:19:03 <paolino> ok ,good for the name, but explain the error of abusing Leaf in that scope please
07:19:16 <sylvan> Well just think about what a branch is...
07:19:24 <sylvan> It has two children, and it stores a value
07:19:26 <sylvan> right?
07:19:41 <paolino> perfect
07:19:42 <sylvan> So you simply say Branch (type-of-child) (type-of-value) (type-of-child)
07:19:59 <sylvan> => Branch (BinaryTree value) value (BinaryTree value)
07:20:14 <paolino> yes
07:20:37 <sylvan> And similarily, a Leaf just stores a value, so it becomes: Leaf (type-of-value) => Leav value
07:20:42 <sylvan> Leaf value
07:22:49 <paolino> BynaryTree, Leaf are same class things
07:23:03 <paolino> and Branch?
07:23:09 <paolino> no
07:23:11 <shapr> Dang, jyp left :-/
07:23:19 <sylvan> A BinaryTree is either a Leaf or a Branch
07:24:44 <paolino> which of them is a data constructor
07:24:45 <paolino> ?
07:24:57 <sylvan> Leaf and Branch
07:25:27 <paolino> BinaryTree is type contructor?
07:25:35 <sylvan> Yes
07:25:47 <shapr> Hey, other than my article, which isn't finished.. are there any obvious bugs in TMR5? --> http://www.haskell.org/tmrwiki/IssueFive
07:25:51 <paolino> and I declare it with data?
07:26:16 <sylvan> with data you describe how to create a value of type "BinaryTree value"
07:26:23 <sylvan> which is by either construcing a Leaf or a Branch
07:34:45 <sylvan> Yay! JHC works.. My god it takes its sweet time to compile anyting though =)
07:35:00 <shapr> What about the resulting binaries? small? fast?
07:35:30 <sylvan> about 1/10 the size so far (I suspect the difference is smaller for larger projects)
07:36:04 <sylvan> It doesn't have a huge RTS like GHC
07:36:56 <sylvan> I'm trying out computing large fibs and facs right now.. I should try to find some better benchmark =)
07:38:31 <shapr> Can I get some people to look for problems in TMR5? --> http://www.haskell.org/tmrwiki/IssueFive
07:38:39 <sylvan> I looked, didn't find any
07:38:44 <shapr> Ok, thanks.
07:38:58 <sylvan> Not that I actively tried to find something, just browsed a bit
07:39:17 <shapr> I'd like active looking if you have time.
07:39:38 <shapr> I have to finish my own testing article, and then it'll be good to go.
07:42:25 <sylvan> I wonder if jhc compiled with jhc would be much faster.. god this is taking time
07:44:07 <sylvan> the executables are WAAAY slower than GHC... =(
07:44:14 <sylvan> at least for this simple example
07:46:13 <sylvan> Hmm.. Now it's slightly faster
07:46:22 <sylvan> I guess something crashed or something earlier
07:55:42 <ndm> sylvan, is that 1/10th the size on windows or linux?
07:55:55 <ndm> i'm wondering about cpphs specifically, i need a build of that for winhugs
07:56:02 <sylvan> ndm, linux
07:56:03 <ndm> and the smaller the better
07:56:40 <ndm> shapr, i will take a close look at some of them
08:01:57 <Oejet> It seems to me that many, many online research papers lack page numbers, date of publication or both.
08:06:51 <ibid> that's because they're often just the author's final version
08:07:03 <ibid> which often lacks those because the publisher adds them later
08:08:12 <Oejet> I see.
08:08:33 <Oejet> The internet is great.
08:09:03 * ibid usually likes to get the publisher's version where i have the required access
08:10:10 <ibid> working at a university helps in this :)
08:11:23 <shapr> ndm: thanks!
08:12:04 <ndm> shapr, they're pretty big - i should be able to make it through the graph handling one
08:12:10 <shapr> spiffy
08:12:13 <ndm> when were you hoping to release?
08:12:19 <shapr> Yesterday :-)
08:12:25 <shapr> But it's going out today instead.
08:12:43 <ndm> cool, well i'll shout if i spot anything bad
08:12:50 <shapr> So if you can find any bugs/typos/etc that I can fix before the release, I'd appreciate it.
08:29:08 <shapr> I'm surprised TMR gets so little feedback.
08:32:45 <humasect> tmr = monthly? HWN seems to be advertised somehow.
08:33:22 <shapr> Monthly was the idea... it's every two months in practice.
08:33:41 <ndm> shapr, Notice that it foldG can work on a graph without node labels
08:33:50 <ndm> that sentance is wrong, i guess
08:33:56 * shapr looks
08:34:04 <ndm> i guess it shouldn't be there
08:34:23 <shapr> ah, get rid of "it" ?
08:34:46 <shapr> spiffy
08:35:16 <Lemmih> What's the best way to sleep indefinitely in a OS thread?
08:35:25 <Lemmih> Create an empty MVar and read it?
08:35:32 <shapr> That'll probably work.
08:36:25 <ndm> shapr, the syntax colouring in haskell mode is also a bit wrong
08:36:31 <ndm> vertices (LabGraph gr _) = indices gr
08:36:39 <ndm> the _) is purple, and it shouldn't be
08:36:55 <shapr> I'm not brave enough to fix enscript's regexes.
08:37:10 <shapr> Oleg wants to switch to lhs2TeX for future issues, I think he's right.
08:37:39 <davve> hmm.. i'm getting a panic error message from ghc 6.4.1 when installing ghc-api.. does anyone know why?
08:37:41 * Lemmih is glad hIDE doesn't use regex based syntax-highlighting.
08:37:57 <humasect> hmm. i still have to submit "Haskell For Real" columns
08:38:10 <Lemmih> davve: Using amd64 or FreeBSD?
08:38:10 <shapr> humasect: Yes! When?
08:38:16 <davve> lemmih, nope
08:38:29 <ndm> personally, i like the wiki approach
08:39:09 <Lemmih> Hm, I have no idea why some can't build ghc-api *sigh*
08:39:12 <shapr> I plan on keeping the wiki approach, but lhs2TeX for output will give several advantages.
08:39:28 <humasect> hm i think since i got inspired yesterday to write docs, perhaps today
08:39:58 <humasect> wiki -> tex ?
08:40:09 <shapr> Some of the academics want pretty postscript output, and I want literate Haskell submissions myself.
08:40:17 <Lemmih> davve: It fails with 'unknown exception', right?
08:40:26 <davve> lemmih, yep
08:41:09 <humasect> ok, i'll go figure out how to use italic and stuff
08:41:56 <sethk> that's the same problem I saw.
08:42:01 <sethk> just restart the compilation, it will finish
08:42:04 <shapr> I had that problem too.
08:42:08 <sethk> keep restarting it if it happens again
08:42:49 <sethk> it _seems_ to have gone away when I upgraded gcc, but since it's intermittent, I can't be sure of that
09:01:35 <paolino> I don't understand what a fold function for a binary tree should do
09:02:30 <xerox> paolino: reduce it to a value
09:02:37 * basti_ nodnods
09:02:42 <basti_> what else!?
09:03:03 <[Blownose]> how do i type convert from an int to string ?
09:03:29 <basti_> [Blownose]: do you mean, displaying the number, or generating the ascii char for a number?
09:03:36 <paolino> Right,but then how do I write a function that returns all nodes in terms of it ?
09:03:37 <[Blownose]> yes
09:03:49 <basti_> [Blownose]: which of thse two?
09:03:52 <[Blownose]> displaying the number
09:03:57 <basti_> [Blownose]: "show"
09:04:03 <[Blownose]> ok
09:04:07 <basti_> paolino: ?
09:04:11 <xerox> paolino: like flatten :: Tree a -> [a]  ?
09:04:43 <paolino> I'm doing exercise 4.10 of YAHT
09:04:50 <[Blownose]> hmm basti but i want to add it to a string so then show wiont work
09:05:21 <[Blownose]> ascii char then :)
09:05:27 <basti_> [Blownose]: "add it to a string"? concatenate the strings, or add two numbers, one of which is represented as a string?
09:05:32 <paolino> xerox ,that is the nodes function
09:05:48 <[Blownose]> like this  "hi " ++ length(b) ++ "hefe"
09:06:13 <basti_> length (b) might not do what you intend to do, first.
09:06:20 <xerox> paolino: did you write the 'elements' function?
09:06:27 <paolino> yep
09:06:31 <basti_> otoh, it might.
09:06:53 <basti_> but the notation shows that you do not know what haskell does with parens, and what not
09:06:59 <xerox> paolino: cool, how does it look like?
09:07:26 <[Blownose]> ah sorry  (length b)
09:07:27 <paolino> elements (Leaf leaf)=[leaf]
09:07:28 <paolino> elements (Branch left leaf right)=(elements left)++leaf++(elements right)
09:07:47 <basti_> [Blownose]: so what do you do then to show that?
09:08:15 <xerox> paolino: exactly.
09:08:22 <paolino> foldl function from (BinaryTree tree)=foldl function from (elements tree)
09:09:00 <paolino> but exercise ask the opposite
09:09:07 <[Blownose]> ah sorry basti i used Show instead of show .. :
09:09:20 <shapr> Any heavy duty HUnit users here? I just discovered I've been using HUnit incorrectly...
09:09:28 <xerox> paolino: hmm, it's more  elements :: BTree a  ===  elementsByFolding :: BTree a
09:10:02 <shapr> I'm trying to test computations :: IO a, but Assertions are IO (), so I'm not sure how to produce Assertion from an IO a
09:10:15 <paolino> what did you write xerox?
09:10:15 <xerox> paolino: that is, your exercise is to write foldBT - elementsBT is something we can think afterwards.
09:10:35 <xerox> paolino: would you like to go private or #haskell-it and talk italian?
09:10:42 <Lemmih> shapr: action >> return ()?
09:10:43 <paolino> vai
09:11:19 <shapr> Lemmih: I dunno.. I'm confused.
09:21:09 <basti_> how do i find out the current working directory=
09:21:11 <basti_> ?
09:21:24 <Lemmih> pwd.
09:21:33 <Lemmih> print working directory.
09:21:41 <basti_> i mean, inside a haskell program
09:21:54 <Lemmih> runCommand "pwd"?
09:22:05 <basti_> ohh
09:22:08 <Lemmih> @index getWorkingDirectory
09:22:09 <lambdabot> System.Posix.Directory, System.Posix
09:22:26 <basti_> yup
09:22:27 <basti_> thanks
09:22:30 <Korollary> @index getCurrentDirectory
09:22:31 <lambdabot> System.Directory, Distribution.Compat.Directory
09:22:47 <Lemmih> That might be better (:
09:23:04 <basti_> :P
09:24:15 <dons> greetings from the crippled free inet terminal in tallinn int. airport ;)
09:24:28 <Lemmih> Hi dons.
09:24:52 <dons> lucky it runs java, so i can get ssh up
09:25:15 <dons> but no ctrl key on the virtual kbd
09:26:05 <goron> Does "v is bound in a dictionary abstraction" mean "we have some name v and this is stored in an implementation of a dictionary"?
09:26:12 <dons> good thing i use vi ;)
09:26:41 <Korollary> dons: what the heck is a virtual keyboard ?
09:27:04 <dons> touch screen java   dooley
09:27:20 <dons> in software
09:27:29 <Korollary> ah. I was imagining Johnny Mnemonic style goggles and gloves...
09:27:50 <dons> hmm. lucky they don,t filter ssh port
09:28:03 <dons> oh, no apostrope either
09:28:15 <shapr> bizarre.
09:29:13 <goron> Does anyone know what is meant by a "dictionary abstraction"?
09:29:26 * dons continues quest to have maximum inet uptime from .ee to .auu
09:30:02 <dons> thouh in the air over kabul migt be hard
09:30:12 <dons> grr. stupid kd
09:30:17 <dons> kbd
09:30:26 <Korollary> goron: I have no idea.
09:30:44 <dons> goron, needs more context
09:31:06 * Korollary gives dons the "relentless irc'er" award
09:31:20 <dons> yay!
09:31:24 <goron> dons: It's used in "A static semanctics for Haskell" by Faxen.
09:31:28 <goron> er semantics
09:31:50 <dons> i just saw igloo and heffalump fly out
09:32:01 <dons> goon, ah ok. hmm
09:32:10 <araujo> Hello here.
09:32:14 <goron> Instances of classes are saved in it, among references to other dictionaries of super classes.
09:32:46 <goron> But I don't understand why anyone would call it a "dictionary abstraction".
09:33:01 <dons> oh, is t just how the describe dictionaries
09:33:27 <dons> hmm. no questionmark either
09:33:30 <goron> Almost nobody uses that word. It seems to be a "cool" way to say "something that implements a dictionary ADT.
09:34:02 <goron> dons: Would you agree with my interpretation?
09:34:09 <dons> oh. well that could be an ,abstraction, yeah
09:34:30 <dons> (no quote keys ;)
09:34:50 <goron> Well, I know it *could* be an abstraction. But I don't know whether that's what really meant.
09:34:56 <dons> how,s code Lemmih
09:35:36 <goron> I guess I will just assume my initial interpretation, which seems to be consistent with the rest of the paper.
09:36:00 <dons> goron, do they have some greek symbols for it?
09:36:15 <Lemmih> dons: I'm trying to figure out how to fix the multitasking problems in CommonSense.
09:36:29 <goron> dons: They use e.g. x: <insert Gamma> <insert alpha>
09:36:44 <goron> er, make that x a v.
09:36:58 <goron> Gamma stands for a class name.
09:37:01 <dons> goron, seems normal
09:37:28 <dons> i suspect your guess is right
09:37:50 <dons> lemmih, need any help?
09:37:52 <goron> dons: Ok, thanks for your precious terminal time :)
09:37:57 <dons> hehe
09:38:29 * dons notes that it,s starting to hurt touch typing on the screen
09:38:36 <Lemmih> dons: It would be really nice if you could fix the CString -> StringBuffer function.
09:39:16 <dons> fix it? i thougt i had to write it in the fst pllace
09:39:53 <Lemmih> It currently peeks the CString and then calls stringToStringBuffer.
09:40:03 <Oejet> I've read the GRIN project paper.  Is that framework being integrated into GHC or JHC or has it been surpassed by something better?
09:40:25 <dons> lemmih, ah! bad
09:41:15 <shapr> Oejet: I think JHC is based on Boquist's thesis.
09:41:33 * dons further notes that info keyosks suck for irc, and most other things
09:41:59 <shapr> From what I've seen John and Philippa say, GRIN can optimize much more than GHC's internals (what does GHC use anyway?).
09:42:17 <dons> core
09:42:20 <shapr> ah, right
09:42:24 <dons> and cmm
09:42:36 <shapr> JHC goes to GRIN, and the asm, yes?
09:42:39 * shapr looks
09:42:44 <dons> isnt grinloer level?
09:42:49 <Lemmih> Got an url to the GRIN paper?
09:42:50 <dons> lower
09:42:58 <xerox> GRIN compiles to C  IIRC
09:43:03 <dons> more like cmm
09:43:11 <pejo> shapr, Boquist talks about using SSA as IR somewhere around page 195 in his thesis. The main reason he didn't swtich seems to have been time constraints.
09:43:27 <shapr> IR?
09:43:32 <pejo> Intermediate representation
09:43:36 <shapr> ah, neat.
09:44:03 <shapr> Having JHC output SSA to gcc would be pretty weird.
09:44:28 <Korollary> does gcc accept ssa from external programs ?
09:44:36 <shapr> Boquist's Thesis - http://www.cs.chalmers.se/~boquist/phd/
09:44:44 <dons> i think so, K
09:45:00 <dons> prob.poorly tho
09:45:26 * dons can type no more. ciao!
09:45:32 <shapr> cya dons!
09:45:34 <Korollary> have a nice flight
09:48:23 <pejo> Kor, and its SSA representation seems to be adjusted for the gcc frontends.
09:49:01 <shapr> pejo: Ah, GRIN is Static Single Assignment, page 193
09:49:42 <Oejet> Lemmih: The paper I read is http://www.cs.chalmers.se/~boquist/ifl96-abstract.html
09:50:34 <shapr> pejo: Oh I see what you mean, the RISC asm output from GRIN isn't SSA.
09:51:08 <shapr> He doesn't say what benefits SSA gives at the machine code level. Any ideas?
09:54:08 <pejo> shapr, isn't GRIN just hte name of his intermediate language? (and by the time the output is asm it shoudl effectively not be SSA since registers are allocated and such).
09:54:28 <shapr> SSA at the machine code level would allow for use of NUMA without cache coherence, for one thing.
09:55:05 <pejo> shapr, SSA in general makes a bunch of classical optimization algorithms simpler iirc.
09:55:19 <pejo> classical. Well. The usual stuff. Dead code elimination, constant propagation, etc.
09:55:31 <shapr> pejo: Yeah, but he says "but too much work had been done (designed and implemented) before we realized the real benefits of SSA also at the machine code level."
09:57:45 <pejo> shapr, hm. Good question.
09:58:15 <pejo> First time i raed it i interpreted it as he had run out of time and come too far into the programming.
09:58:53 <Oejet> Wow, that's a nice ph.d.
10:00:07 <shapr> I think that P193 says that values and live ranges would be the same thing if the generated RISC code were SSA.
10:01:30 <shapr> What's the advantage of having values being the same as live ranges?
10:01:39 <xerox> What is SSA?
10:03:22 <shapr> Static Single Assignment
10:09:47 <sylvan> shapr, it should make it easier for register allocation, maybe?
10:11:02 <raver> evening
10:11:11 <shapr> sylvan: I don't know.
10:11:36 <shapr> I get the impression that the advantage should be totally obvious to anyone who's read the thesis up to that point, so I'll have to do that.
10:13:07 <sylvan> It was a looooong time since I read it, but I seem to remember that there was a great deal of trouble involved with register allocation due to overlapping live ranges for various values
10:37:40 <praseodym> what are the disadvantages of haskell?
10:39:39 <araujo> praseodym, it might be too addictive
10:40:50 <praseodym> a friend of mine says haskell, or any functional language, is not very useful for office suites and things like drupal, because they arent using lots of mathematics
10:41:07 <shapr> From the viewpoint of a C programmer, lazy evaluation is slow and uses lots of memory. That's not really true, but when you apply C-style programming to Haskell, it is true.
10:41:18 <shapr> praseodym: That's gezeik.
10:42:04 <praseodym> shapr: thats what I thought as well :)
10:42:36 <sieni> also from the viewpoint of a Lisp programmer, the syntax is weird ;-)
10:42:40 <shapr> praseodym: From my viewpoint, the major disadvantage of Haskell (and purely functional languages in general) is that they haven't had billions of dollars of research that you find behind Intel's C compiler for example.
10:43:00 <dcoutts> yes
10:43:56 <praseodym> I see
10:44:05 <shapr> On the cultural side, I view monads as simpler than objects. But, it's easy to find someone to explain OOP to you, and hard to find someone to explain monads.
10:44:56 <praseodym> hey I'm just on page 18 of this 195 page counting book ;-)
10:45:32 <dcoutts> shapr, I reckon modern imperitive languages would be much better if they had proper closures
10:45:48 <dcoutts> but they don't add closures since they're tied up with the OOP idea
10:45:54 <shapr> Purely functional languages have the potential to be faster than procedural languages. In fact, gcc uses a purely functional intermediate structure.
10:46:06 <dcoutts> and OOP allows you to do closures in a clunky way
10:46:13 <praseodym> what are closures?
10:46:47 <dcoutts> in Haskell we might say they are values with type (IO ())
10:47:03 <dcoutts> they're just functions
10:47:12 <dcoutts> but often namless and/or partially applied ones
10:47:31 <dcoutts> in particular they inherit the context in which they were defined
10:47:44 <dcoutts> so eg in a Haskell GUI we can say:
10:48:00 <dcoutts> onButtonClicked button $ do ...
10:48:23 <dcoutts> and that action/callback we pass as the 2nd arg of onButtonClicked is a closure
10:48:27 <ski> prolog
10:48:29 <ski> mercury
10:48:34 <dcoutts> and it can access all the variables cirrently in scope
10:48:41 <ski> (oop)
10:48:54 <dcoutts> but take a look at the equivalent code to the above in Java! it's horrible.
10:49:14 <dcoutts> OOP gives a massive syntactic overhead
10:49:20 <dcoutts> in that example anyway
10:49:35 <praseodym> probably.. I'm too used to oop to tell really
10:49:57 <dcoutts> in Java you'd have to define a local class that implementes the command class and defined an perform method
10:50:11 <Lemmih> dons, dcoutts: I'm setting up a weblog (wordpress) at http://haskell.org/hide/. Objections?
10:50:20 <dcoutts> and all variables that you wanted to use from the environment would need to be copied into the local class as members
10:50:35 <dcoutts> Lemmih, sure, go for it, just give me an account :-)
10:51:02 <dcoutts> Lemmih, I know a little about WP, we use it for the http://haskell.org/gtk2hs/ site
10:51:04 <praseodym> Lemmih: why not use drupal
10:51:40 <dcoutts> Lemmih, and gour is an WP expert so you can ask him for help in customising it
10:52:12 <Lemmih> praseodym: What's drupal?
10:52:16 <praseodym> www.drupal.org
10:52:22 <dcoutts> Lemmih, another content management system
10:52:25 <shapr> lambda-the-ultimate.org uses drupal.
10:52:47 <praseodym> Lemmih: a content management platform.
10:52:49 * dcoutts thinks WP is nice & simple & suitable for smallish websites
10:53:19 <dcoutts> Lemmih, I've already got MySQL up and running on haskell.org
10:53:32 <dcoutts> I'll make you a db
10:53:49 <xerox> @version
10:53:50 <lambdabot> lambdabot 3p97, GHC 6.5 (OpenBSD i386)
10:53:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:53:50 <Lemmih> dcoutts: I know. I've already installed wordpress once for haskell.org/hsp/
10:54:00 <dcoutts> Lemmih, oh ok
10:54:01 <praseodym> I haven't use wp though
10:54:05 <praseodym> but drupal works really nice
10:54:30 <Lemmih> Drupal looks bit too complex.
10:54:57 <dcoutts> that was my impression too
10:55:13 <dcoutts> it's probably more sutable for larger sites with more complex needs
10:55:49 <praseodym> Lemmih: you can just disable lots of modules
10:56:13 <praseodym> thats really nice, you just check some checkboxes to create the site you want
10:56:46 <xerox> @pl \a b -> f (map (>a) b)
10:56:47 <lambdabot> (f .) . map . flip (>)
10:58:44 <TheHunter> i'll have to fix that sometime.
10:58:57 <Flawless> Hi All. How can I set a name for a value? (like "val x = foo" in SML)
10:59:05 <TheHunter> @pl flip (==)
10:59:06 <lambdabot> (==)
10:59:15 <TheHunter> @pl flip (>=)
10:59:16 <lambdabot> flip (>=)
11:00:00 <TheHunter> just leave out 'val', eg. x = foo on the top-level
11:00:18 <TheHunter> ...or in a where clause.
11:00:23 <Flawless> TheHunter: I get syntax error on e.g. "x = 42"
11:00:36 <Flawless> TheHunter: maybe I shouldn't be using the HUGS interpreter?
11:00:50 <Korollary> let x = 42 in x
11:01:02 <Flawless> Korollary: good nick for that kind of advise :D
11:01:03 <TheHunter> if you write that in a file and load it, it should work fine.
11:01:18 <Flawless> Korollary: hey, that works. Thanks
11:01:22 <Flawless> TheHunter: ok, thanks
11:01:36 <TheHunter> ghci can also bind via "let x = 42".
11:01:51 <Flawless> but WhyTF not on the "command line"
11:02:23 <TheHunter> because that would require "state".
11:02:41 <Flawless> TheHunter: oh
11:02:47 <TheHunter> ghci acts like it is inside a do-block.
11:02:55 <Flawless> makes perfect sense, actually
11:04:08 <Flawless> TheHunter: ok, ghci is logical, I'll stick to that :)
11:04:31 <Flawless> Many thanks to all
11:04:37 <basti_> is it possible to declare several modules in one file?
11:05:27 <TheHunter> no
11:06:01 <basti_> hmh :/
11:06:31 <TheHunter> maybe you could do something evil with cpp and symlinks...
11:06:55 <wilx> Yo!
11:07:07 <basti_> oh no. Not like that.
11:07:10 <basti_> I'll find another way
11:07:29 <wilx> OT: What do you use to show #haskell IRC logs?
11:07:30 <wilx> @logs
11:07:31 <lambdabot> Maybe you meant: docs plugs
11:07:35 <basti_> (it'd just had become a workaround for a strange behaviour of a preprepre-version of hasprs)
11:07:38 <Flawless> what's the traditional haskell source file extension? .has?
11:07:42 <basti_> wilx: a web browser.
11:07:51 <basti_> Flawless: .hs normally, .lhs for literate style
11:08:01 <Flawless> basti_: litarate style?
11:08:06 <wilx> Err, I mean the sw that chews the logs into HTML :)
11:08:08 <Flawless> eh, literate* :)
11:08:32 <basti_> writing only comments and marking up code lines with > in front
11:08:52 <Flawless> basti_: I see. What's that good for?
11:09:02 <basti_> usually, there's more commentary/documentation than code
11:09:07 <Flawless> ok
11:09:16 <basti_> and also, you can easily process that to both code and documentation
11:09:17 <Lemmih> shapr: Haha. Not one minute after the activation (:
11:09:24 <Flawless> basti_: oh, yes
11:09:27 <TheHunter> not many people use it, since they rather write code than comments.
11:09:31 <basti_> (where the code actually is copied in documentation, possibly)
11:09:38 <Flawless> TheHunter: tell me about it ;)
11:09:52 <TheHunter> and type signatures contain much documentation already.
11:09:58 <basti_> yes
11:11:40 <Flawless> much like ML, I guess
11:11:59 <basti_> better, actually.
11:12:16 <Flawless> yes of course, we're in #haskell ;-)
11:12:30 * basti_ nodnodnods
11:13:31 <praseodym> another stupid question.. can haskell solve equations for me
11:14:12 <Flawless> praseodym: yes. It was used to show that there are no non-trivial solutions to x^n + y^n = z^n, among other achievements
11:14:13 <shapr> What sort of equations?
11:14:23 * basti_ .o° ( ?) 
11:14:26 <Flawless> praseodym: no, no it cannot ;)
11:14:45 <praseodym> shapr: those in my mathematics book
11:14:55 <shapr> Sure, yeah.
11:14:58 <basti_> "solving equations" is pretty hard
11:15:04 <shapr> For some definition of mathematics book...
11:15:14 <basti_> the ones in head normal form
11:15:48 <praseodym> shapr: its wiskunde b 1,2 for vwo5.. lol
11:16:04 <basti_> actually equations in presburger arithmetic are decideable
11:16:07 <basti_> hyperexponentially
11:16:35 <shapr> praseodym: ik veit het neit... I'm just a poor boy from Alabama.
11:16:58 <praseodym> shapr: lol ok
11:17:04 <basti_> "greensborough alabama!"?
11:17:21 <praseodym> but there must be some people knowing what I'm talking about
11:17:21 <shapr> Nah, born in Selma, grew up in Birmingham.
11:17:37 <basti_> mmk
11:17:54 <basti_> praseodym: solving equations is very hard in the general case
11:18:28 <shapr> praseodym: What do your equations look like?
11:18:39 <praseodym> one moment
11:19:20 <sieni> for example, are you solving some algebraic equation or constructing a fluid mechanics simulation? :-)
11:19:44 <praseodym> algebraic equations (hell its just highschool lol)
11:20:09 <basti_> praseodym: you might want to have a look into "axiom" (preferrably with texmacs)
11:21:20 <praseodym> shapr: like 2^x - 5 = 3 * 0.5^(x-2) - 1
11:23:34 <praseodym> shapr: and I need to know x, of course
11:23:54 <shapr> You could write your own solver in Haskell for that sort of equation.
11:24:11 <shapr> It'd be fun too.
11:24:32 <basti_> of course thats possible numerically
11:24:46 <basti_> but, numerically is not thought to be a solution by most people
11:26:04 <praseodym> best would be a programing which gives me the answer with intermediate steps ;-)
11:26:23 <praseodym> s/a programing/a program/
11:26:32 <magnus--_> x = 2? :)
11:26:33 <Korollary> praseodym: you would figure out the solution yourself much sooner
11:26:59 <praseodym> magagr: x^2 = -2 so thats not possible
11:27:13 <praseodym> magagr: answer is x = 2log6
11:27:19 <basti_> praseodym: try computational algebra.
11:27:21 <praseodym> Korollary: probably
11:27:22 <shapr> I prefer to write a program to find the solutions for stuff like that.
11:27:26 <basti_> axiom, for example
11:27:34 <praseodym> basti_: url
11:27:39 <paolino> trying to understand fmap and functors .Any simple phrasing is welcome
11:27:40 <basti_> thats like a calculator for equations
11:27:44 <magnus--_> praseodym: I guess I got some intermediate step wrong
11:27:52 <magnus--_> yes, I did
11:28:05 <Korollary> express 0.5^(yadda) as 1/(2^yadda)
11:29:00 <sieni> praseodym: It's a hidden second order equation
11:29:15 <basti_> http://savannah.nongnu.org/projects/axiom
11:29:31 <basti_> http://page.axiom-developer.org/
11:29:44 <praseodym> sieni: ?
11:30:09 <basti_> paolino: uhm
11:30:23 <Korollary> he means substitute 2^x with y and you will see
11:30:26 <basti_> paolino: i tend to call functors "metatypes"
11:30:56 <TheHunter> paolino, think of a functor as of a container. Ie. if f is a functor, then f a is a container of a's. All fmap f (f :: a -> b) does is replace every occurrence of an a in the container with a b using the function f, so you get a container of b's.
11:30:59 <basti_> that is, types that need another type to become a "proper type" (one which actually holds normal values)
11:31:34 <praseodym> Korollary: I see.. I'm getting mathematics in dutch now
11:32:09 <magnus--_> log2 6 and 1+(2n+1)*Pi*i
11:33:36 <praseodym> magagr: thats another 'uhmm?' for me
11:33:39 <magnus--_> log2 6 + 2n*Pi*i and 1+(2n+1)*Pi*i
11:34:02 <paolino> My head is not a functor
11:34:06 <magnus--_> if you only want real answers then there's only log2 6
11:34:29 <TheHunter> eg. list ([]) is functor, so if you have a list of apples (of type [Apple]) and a function f that gives you an orange for each apple (of type Apple -> Orange) fmap f listOfApples will give you a listOfOranges.
11:34:43 <praseodym> magnus--_: how did you get to the second one
11:35:06 <paolino> that is map!
11:35:20 <magnus--_> praseodym: there are two solutions to the quadratic equation
11:35:26 <magnus--_> praseodym: 6 and -2
11:35:40 <basti_> paolino: fmap == map for lists
11:35:52 <praseodym> magnus--_: yup
11:35:52 <basti_> fmap is the generalized version in the class Functor
11:36:15 <magnus--_> so 2^x = -2... this has the solution (2n+1)Pi*i + log2 2
11:36:32 <paolino> a real example on non-list please
11:37:38 <basti_> how about IO?
11:37:40 <praseodym> magnus--_: which is what I dont really understand
11:37:51 <paolino> no oooo
11:37:51 <TheHunter> ok, fmap f :: Maybe Apple -> Maybe Orange will give you an orange if your container contains an apple and Nothing if your container contains Nothing.
11:37:57 <praseodym> magnus--_: do you by any chance know some url where its explained
11:38:23 <magnus--_> praseodym: Complex exponential and logarithm is what you need to learn about
11:39:56 <magnus--_> basically: log a+bi has a real part which describes the magnitude of this number, and an imaginary part which describes the polar angle of this number
11:39:59 <TheHunter> will give you *Just an orange if your container contains *Just an apple
11:40:06 <TheHunter> @eval fmap (+1) Nothing
11:40:10 <TheHunter> @eval fmap (+1) 4
11:40:12 <lambdabot> Nothing
11:40:12 <lambdabot> <irc>:1:10:
11:40:12 <lambdabot>   No instance for (Num (f a))
11:40:12 <lambdabot>   arising from the literal `4' at <irc>:1:10
11:40:12 <lambdabot>   Probable fix: add an instance declaration for (Num (f a))
11:40:14 <lambdabot>   In the second argument of `fmap', namely `4'
11:40:16 <lambdabot>   In the definition of `xxxx': xxxx = fmap ((+ 1)) 4
11:40:18 <lambdabot>   In the definition of `v': v = let xxxx = fmap ((+ 1)) 4 in take
11:40:18 <TheHunter> @eval fmap (+1) (Just 4)
11:40:20 <lambdabot> 2048 (show xxxx)
11:40:22 <lambdabot> Just 5
11:40:37 <magnus--_> praseodym: a positive number has polar angle 0+2n*Pi, a negative number has polar angle of Pi+2n*Pi
11:41:03 <magnus--_> 2n*Pi just means that it doesn't matter how many times we go around the circle
11:41:20 <praseodym> I see
11:42:26 <Lemmih> @seen gour
11:42:27 <lambdabot> I saw gour leaving #haskell 4 days, 9 hours, 26 minutes and 10
11:42:27 <lambdabot> seconds ago, and I have missed 51 seconds since then.
11:42:40 <magnus--_> praseodym: and exp (a+bi) = exp a*(cos b + i*sin b)
11:42:50 <basti_> "2048 (show xxxx)"? that looks like a bug to me
11:42:52 <basti_> brb though
11:43:49 <TheHunter> we just need a regexp that filters out the last two lines.
11:44:17 <praseodym> magnus--_: I guess I'll learn that in the future :) but brb
11:44:32 <tempest1> why do that with regexp, just populate an array and pop off the last two elements...
11:45:44 <TheHunter> because it need not be exactly two lines.
11:46:19 <tempest1> you can still use string manipulation....
11:47:13 <TheHunter> that part of the code uses regexps already.
11:48:03 <tempest1> so you can do regexp and then string manipulation
11:48:56 <humasect> haskell-mode isn't very nice with literate files
11:49:12 <TheHunter> i don't understand what you're saying.
11:49:17 <tempest1> ok
11:49:37 <tempest1> you have regexp right, to split a string into parts
11:49:42 <tempest1> thats what regular expressions do
11:49:48 <tempest1> so after you split them into parts and get this array
11:49:58 <tempest1> and you have to remove some stuff from the results? correct?
11:50:02 <TheHunter> no i basically want to filter away all lines that contain 'xxxx'.
11:50:10 <tempest1> oh
11:50:20 <tempest1> isn't there a function that does something like strstr in C?
11:51:12 <TheHunter> there is isPrefixOf and tails, but that is about as painful as regexps.
11:51:35 <tempest1> ah
11:51:40 <tempest1> well, i don't know haskell
11:51:42 <tempest1> only the basics
11:51:45 <tempest1> i just started yesterday
11:52:01 <Korollary> regexps are not that painful if you only need to check for an xxxx
11:52:01 <syntaxfree> is there a predefined or defined in the prelude function equivalent to nth n l = head (drop (n-1) l) ?
11:52:41 <TheHunter> @eval any ("xxxx" `isPrefixOf`) "2048 (show xxxx)"
11:52:43 <lambdabot> <irc>:1:26:
11:52:43 <lambdabot>   Couldn't match `[Char]' against `Char'
11:52:43 <lambdabot>   Expected type: [[Char]]
11:52:43 <lambdabot>   Inferred type: [Char]
11:52:43 <lambdabot>   In the second argument of `any', namely `"2048 (show xxxx)"'
11:52:45 <lambdabot>   In the definition of `xxxx':
11:52:47 <lambdabot>    xxxx = any (("xxxx" `isPrefixOf`)) "2048 (show xxxx)"
11:53:04 <Korollary> syntaxfree: would l ! n work for you ?
11:53:15 <syntaxfree> I think so.
11:53:17 <syntaxfree> thanks.
11:53:19 <tempest1> @eval print "cool"
11:53:20 <lambdabot> No IO allowed
11:53:23 * shapr boings cheerfully
11:53:35 * basti_ boingboings
11:53:47 * Korollary throws non-drm'd lambdas at shapr
11:54:14 <syntaxfree> @eval let a=[[1,2,3],[4,5,6],[7,8,9]] in a ! 2
11:54:15 * shapr catches them!
11:54:15 <lambdabot> <irc>:1:37: Not in scope: `!'
11:54:23 <syntaxfree> that so didn't work.
11:54:40 <basti_> uhm
11:54:40 <basti_> !!
11:54:45 <basti_> ! is for arrays
11:54:45 <syntaxfree> oh.
11:54:48 <syntaxfree> let a=[[1,2,3],[4,5,6],[7,8,9]] in a !! 2
11:54:52 <Korollary> sorry for the typo
11:55:00 <syntaxfree> @eval let a=[[1,2,3],[4,5,6],[7,8,9]] in a ! 2
11:55:01 <lambdabot> <irc>:1:37: Not in scope: `!'
11:55:05 <syntaxfree> hmm. sorry.
11:55:06 <basti_> :D
11:55:08 <syntaxfree> @eval let a=[[1,2,3],[4,5,6],[7,8,9]] in a !! 2
11:55:10 <lambdabot> [7,8,9]
11:55:15 <TheHunter> @eval any ("xxxx" `isPrefixOf`) $ tails "2048 (show xxxx)"
11:55:15 <TheHunter> @eval any ("xxxx" `isPrefixOf`) $ tails "2048 (show xxx)"
11:55:16 <lambdabot> True
11:55:17 <lambdabot> False
11:55:22 * basti_ knocks syntaxfree's head: hello mcfly, anybody home?
11:55:29 <basti_> ;)
11:55:30 <syntaxfree> let a=[[1,2,3],[4,5,6],[7,8,9]] in a !! 2 !! 1
11:55:42 <TheHunter> wow, a 2-minutes lag.
11:55:52 <syntaxfree> @eval let a=[[1,2,3],[4,5,6],[7,8,9]] in a !! 2 !! 1
11:55:53 <lambdabot> 8
11:56:19 <Pistahh> in this expression:
11:56:23 <Pistahh> let x ~~ y = x+y in 2 ~~ 3
11:56:25 <syntaxfree> hmm. !! counts from 0.
11:56:33 <Pistahh> (idea taken from autrijus's interview
11:56:41 <syntaxfree> also it's right-associative.
11:56:45 <Pistahh> what is ~~ ? (i.e. how can I use it?)
11:57:00 <basti_> Pistahh: a function that defaults to being infix
11:57:01 <syntaxfree> @eval let a=[[1,2,3],[4,5,6],[7,8,9]] in (a !! 1 )!! 0
11:57:02 <lambdabot> 4
11:57:26 <Pistahh> basti_: are there other functions such that?
11:57:30 <basti_> uhm yes
11:57:37 <basti_> any whose name is built from special characters
11:57:48 <basti_> like #><()=-+*~/
11:57:51 <int-e> .
11:57:52 <basti_> maybe some more
11:57:54 <int-e> $
11:57:58 <basti_> oh yes
11:58:17 <int-e> are you sure about #?  \ is another one.
11:58:24 <basti_> hmm pretty sure yes
11:58:35 <int-e> ok. not () though.
11:58:39 <basti_> but i'm certainly not reputated as having a very good memory
11:58:40 <basti_> oh right
11:58:48 * basti_ donkdonks
11:58:51 <basti_> not ()
11:58:59 <int-e> I guess we should all look at the haskell report for this *g*
11:59:02 <Korollary> TheHunter: How about let pat = mkRegex ".*xxxx.*" in filter (\str -> Nothing == matchRegex pat str) ["yay", "aola xxx", "yay xxxx boom", "done"]
11:59:04 <basti_> yes.
11:59:14 <basti_> or just postpone that until we care.
11:59:15 <basti_> :P
11:59:47 <TheHunter> Korollary, that is "just as painful" as isPrefixOf + tails.
12:00:06 <paolino> is CPS chapter on YAHT for human beings ?
12:00:19 <int-e> !#$%&*+./<=>?@\^|-~
12:00:25 * Korollary keels over in pain and dies
12:00:26 <xerox> paolino: sure it is!
12:00:30 <TheHunter> paolino, skip it.
12:00:42 <xerox> I told you.
12:01:26 <TheHunter> you hardly ever need to write CPS in haskell.
12:01:43 <xerox> Indeed.
12:01:50 <TheHunter> Plus, the kind of CPS yaht uses is a little strange.
12:01:58 <paolino> the sad thing is I switched from python to ruby for continuations also
12:02:47 <xerox> What about http://www.nomaware.com/monads/html/contmonad.html ?
12:05:29 <paolino> I hope you are not asking it to me
12:05:44 <xerox> ^_^
12:06:52 <TheHunter> That page is only useful if you already know what contiuations are and what call/cc does.
12:14:47 <xerox> What was that distributed computing program someone wrote (for TMR maybe) ?
12:15:03 <shapr> musasabi
12:15:09 <shapr> join-hs
12:15:33 <tempest1> noob question: is haskell an interpretted or compiled language?
12:15:35 <xerox> shapr: paolino was searching for something like xml-rpc, to do Remote Procedure Calls.  Does it count as answer?
12:15:42 <integral> tempest1: it can be either.
12:15:44 <xerox> tempest1: both.
12:15:47 <tempest1> ok, thanks
12:16:03 <integral> tempest1: but I believe that most "interpreters" just compile to bytecode, rather than directly interpreting the source
12:16:14 <Pistahh> basti_: thx. :)
12:18:44 <xerox> STM does not implement distributed computing as now.. I don't know of any other possibility.
12:20:02 <paolino> STM is the diamod point of haskell is it?
12:20:32 <xerox> STM is very cool, but Haskell has many other cool libraries.
12:21:17 <xerox> The point being that the language is used to do research, so one gets this bleeding-edge research topics implemented in GHC to try :D
12:21:32 <paolino> reading that docs gives honor to Monads, or that's what they sell
12:21:57 <xerox> I'd say they reserve it :)
12:27:28 <shapr> xerox: There's already an XmlRpc lib by Bringert.
12:27:42 <xerox> Didn't know!
12:28:18 <xerox> @where haxr
12:28:19 <lambdabot> I know nothing about haxr.
12:28:29 <xerox> @where+ haxr http://www.haskell.org/haxr/
12:28:30 <lambdabot> haxr ~> http://www.haskell.org/haxr/
12:28:36 <xerox> Thanks shapr :-)
12:30:12 <Pistahh> @where whores
12:30:13 <lambdabot> I know nothing about whores.
12:30:59 <xerox> Expectable.
12:31:19 <Pistahh> @where safe sex
12:31:19 <lambdabot> I know nothing about safe.
12:35:57 <Pistahh> :)
12:36:17 * Pistahh could write autrijus's hamming number generator without peeking into other documents / solutions
12:36:31 <xerox> Cool!
12:37:26 <Pistahh> maybe sometimes I will also be able to understand what monads are. :)
12:37:45 <basti_> just always substitute "cute little fuzzy things" for monads
12:37:45 <Pistahh> s/etimes/e time/
12:37:51 <basti_> that won't make it simpler, but not as scary
12:38:25 <Pistahh> :)
12:40:21 <Korollary> Pistahh: Have you read http://haskell.cs.yale.edu/hawiki/MonadsAsContainers ?
12:40:55 <Pistahh> Korollary: no, will do now.
12:41:01 <basti_> i found that a little misleading
12:41:35 <xerox> basti_: I think it's pretty nice.  What could be misleading of that article?
12:42:03 <basti_> for example, whats the "container" metaphor for IO? a bag that contains a single apple?
12:42:26 <basti_> a bag that serves no purpose but making life harder? ;)
12:42:56 <Korollary> if all you want is to do i/o, you don't even need to understand monads fully.
12:43:08 <basti_> of course
12:43:17 <int-e> basti_: a bag that contains one of many possible states of the world.
12:43:42 <basti_> int-e: no, a bag that contains something, and then has a state written on it
12:44:53 <Korollary> an "IO Int" contains an Int as far as you or the compiler is the concerned. The library implementation hides the side effect details from you.
12:44:57 <shapr> Aren't both viewpoints 'correct' ?
12:45:21 <basti_> shapr: the state wouldnt be IN the bag. you can't access it.
12:45:43 <shapr> No, but the bag itself is a state, in some sense.
12:45:49 <Korollary> The state is not in the bag (for IO Int)
12:45:59 <basti_> yes
12:46:29 <basti_> so i rather like to think of it as a processing tag
12:46:48 <basti_> or a kind of puzzle piece "nose" that only fits in similar puzzle pieces
12:46:54 <Korollary> if you MUST think about the implementation, maybe.
12:46:56 <shapr> I like to think of it as pure universes with one way wormholes that 'wind forward'
12:47:25 <shapr> Yeah, the 'puzzle piece' viewpoint is sort of like a physical zipper.
12:47:41 <Korollary> basti_: but there are state monads for which the state *is* in the bag. i/o is just slightly different.
12:47:48 <shapr> And in fact, that's why I claim that Haskell is even better than Smalltalk at being late-bound.
12:48:21 <basti_> i think we all agree on what a monad -is-, though we use different metaphors
12:49:02 <Korollary> your nose metaphor fits types in general, not just monads, methinks.
12:49:35 <shapr> Monads are simple and powerful, but they sure don't lend themselves to descriptions in English.
12:49:44 * Korollary announces that he's hungry
12:49:57 <basti_> that lends itself to descriptions in english
12:50:16 <xerox> shapr: I'd love to grok the Zipper!  Hmpf.
12:50:43 <basti_> never grok the zipper when there are still things hanging... uhm wait...
12:51:13 <TheHunter> basti_, IO is a container that contains for each old state of the world a new state and a corresponding value.
12:51:19 <shapr> xerox: Zipper is a rubik's cube with a window.
12:51:34 * xerox clears his eyes
12:51:56 <shapr> xerox: It's like those tile puzzles with fifteen squares, and one missing.
12:51:57 <basti_> TheHunter: but you can't see the state. So it isnt in the container. But anyway, this is only about semantics and metaphors. I do not think it makes a very rewarding discussion theme
12:52:14 <shapr> The Zipper is a datastructure that you can rotate around to get the 'active piece' on top.
12:53:28 <xerox> shapr: Okay.  I don't get how is it used.
12:53:34 <TheHunter> basti_, you can perfectly formalize the notion of 'container', in this case, IO is a container Cont r isn't.
12:53:42 <TheHunter> *but
12:53:48 <basti_> hmm.
12:54:08 <basti_> what is this formalisation called?
12:54:34 <TheHunter> i don't think it has a name.
12:54:39 <basti_> oh
12:54:46 <TheHunter> *i don't know if it has a name.
12:55:39 <TheHunter> I would call a set X, together with a function X -> Integer a "container".
12:55:53 <basti_> hmmm
12:55:56 <TheHunter> no,
12:56:21 <TheHunter> a set X and a function X -> Set.
12:56:46 <basti_> Set as in "Category of Sets"?
12:56:47 <TheHunter> where the function maps each possible state of the container to an index set needed to access its elements.
12:57:05 <TheHunter> Set as in "Class of Sets"
12:57:07 <basti_> ah
12:57:20 <basti_> hmm so IO would be a container over index set "1+1"?
12:58:01 <basti_> (unit + unit)
12:58:04 <basti_> ah no
12:58:06 <basti_> 1+a
12:58:12 <basti_> or
12:58:13 <basti_> uhm
12:58:13 <TheHunter> in the IO case, X is the set of states of the world, and the function maps each state to a singleton set.
12:58:30 <TheHunter> maybe function isn't the right word, but you get the idea.
12:58:45 <basti_> hmmm yup
13:07:02 <Oejet> Hello.
13:07:38 <basti_> hey oe
13:10:25 <xerox> Oi, Oejet!
13:11:21 * Oejet writes from OpenBSD freshly installed.
13:21:01 <syntaxfree> what platform?
13:21:17 <Oejet> syntaxfree: i386
13:43:38 <shapr> hiya fnord123
13:44:12 <shapr> TheHunter: Any clue how to use Test.QuickCheck.Poly ?
13:48:14 <fnord123> hey shapr
13:48:44 <shapr> Ok, anyone know how to use Test.QuickCheck.Poly ?
13:48:48 <shapr> fnord123: How's code?
13:48:52 <fnord123> weird how my computer woke up as i came downstairs. magic apples!
13:49:19 <shapr> It's happy to see you!
13:49:32 <fnord123> work code is too easy. play code is in languages i dont know
13:50:31 <shapr> I like to learn new stuff.
13:51:13 <syntaxfree> downstairs?
13:51:20 <syntaxfree> why were you upstairs?
13:54:37 <fnord123> by bedroom is upstairs
13:54:45 <fnord123> i went to bed at 9am and woke up at 9.30 pm
13:54:48 <shapr> wow.
13:54:49 <fnord123> because im hardcore.
13:55:04 <syntaxfree> must be nice to be heavy metal hamsters, as the germans would say.
13:56:47 <fnord123> ?
13:56:53 <fnord123> why would they say that?
13:57:59 <fnord123> q4u
13:58:18 * shapr tries to figure out Test.QuickCheck.Poly
13:58:27 <fnord123> if haskell is side effect free apart from monads, then isn't it automatically threadsafe apart from monads?
14:01:45 <Pistahh> good nite
14:03:09 <syntaxfree> fnord123: it's a dumb Helloween song.
14:03:45 <dcoutts> fnord123, yep non-IO code is automaticaly thread safe
14:05:10 <dcoutts> fnord123, but actually the run time system at the moment doesn't run multiple Haskell threads at the same time
14:05:26 <fnord123> why
14:05:27 <alar> why should it?
14:05:38 <dcoutts> however that feature is in development. There's a paper on it.
14:06:02 <dcoutts> http://www.haskell.org/~simonmar/papers/multiproc.pdf
14:06:21 <fnord123> im mainly concerned with programming on supercomputers and large servers so my questions come from that context.
14:06:37 <fnord123> parallelism and such are important for me. :)
14:07:30 <dcoutts> that paper describes the issues in evaluating pure code in parallel
14:07:54 <dcoutts> it does take some tweaks to the run-time system to do it safely
14:08:32 <fnord123> erf, shared memory :-/
14:09:16 <dcoutts> yep
14:09:38 <dcoutts> there are other projects that use ghc as a basis for distributed memory parallel evaluation
14:09:53 <dcoutts> see gph & gdh
14:10:15 <shapr> Any comments on my article? --> http://www.haskell.org/tmrwiki/SoftwareTestingWithHaskell
14:10:41 <dcoutts> fnord123, http://www.macs.hw.ac.uk/~dsg/gdh/ and http://www.macs.hw.ac.uk/~dsg/gph/
14:11:17 <fnord123> oh nice. i would prefer this to erlang.
14:11:55 <Korollary> I suppose there is no id3 tag library in haskell ? libid3 is horrid.
14:12:22 <fnord123> do you lot use any databases? im wondering about speeds. at my work they pupport that relational databases aren't quick enough. im skeptical of that claim. im thinking they cut it up incorrectly
14:12:41 <shapr> Fast enough for what?
14:13:28 <fnord123> billion writes a day
14:13:28 <shapr> For most of what I do, a text file 'database' is fine. For other stuff, I use PostgreSQL.
14:13:52 * dcoutts too
14:15:48 * Heffalump appears
14:15:56 <shapr> Hm, eleven million writes a second... I'd probably use a distributed cluster setup for that.
14:16:34 <fnord123> yeah
14:16:36 <shapr> fnord123: What sort of work needs that many writes a second?
14:16:59 <fnord123> financial data providers plugged into almost every stock market in the world
14:17:24 <basti_> they do 11 million transactions a second???
14:17:40 <fnord123> that includes the even bigger bond markets
14:17:57 <basti_> or are they abusing a rdbs as a temporary storage for marginal data? ;)
14:18:00 <xerox> @plugs [1,10,100] >>= \x -> [x-1,x,x+1]
14:18:02 <lambdabot> [0,1,2,9,10,11,99,100,101]
14:18:13 <fnord123> no theres no rdbs. its a ffdbs
14:18:39 <fnord123> hm, when i think about it maybe its only 30k / secon
14:18:41 <fnord123> second
14:19:07 <basti_> that sounds more reasonable
14:19:20 <shapr> Hm, my article feels rather naked..
14:19:36 <davve> but to the point
14:19:38 <fnord123> yeah im thinking of global volume of trades :)
14:19:47 <shapr> I think I'll expand on this article next month.
14:19:48 <fnord123> rather than # of trades :-/
14:19:56 <shapr> davve: Yeah, it does have everything you need to get started.
14:20:46 <fnord123> hm so would rdbs clusters handle 30k/s??
14:21:05 <fnord123> f'ing mac keyboards and their doubletype
14:22:55 <xerox> $ ./runplugs
14:22:55 <xerox> 1+1
14:22:55 <xerox> ghc: failed with error code 1
14:23:10 <xerox> Hmpf! :!
14:23:49 <xerox> plugs works, tough.
14:25:17 <shapr> hoi boegel|home!
14:25:32 <shapr> boegel|home: I'm about to announce TMR5, want to look at the articles for errors?
14:27:10 <xerox> {run}plugs code is _really simple, whoa.
14:29:23 <boegel|home> shapr: you mean typo's ?
14:29:45 <boegel|home> shapr: I'm planning to go to bed in the next 10 minutes, but I'm willing to glance at it
14:30:39 <shapr> boegel|home: Sure, glance around for anything obviously broken.
14:32:04 * xerox boings furiously for TMR5
14:32:10 * shapr writes furiously...
14:32:26 <xerox> boi-boboin-boboing
14:32:58 <fnord123> so how many transactions are you guys doing with postgres?
14:33:22 <boegel|home> shapr: everything seems to be working fine...
14:33:24 <shapr> spiffy!
14:33:36 <boegel|home> I'll be watching my netstat tomorrow :D
14:34:00 <shapr> yay!
14:34:17 <shapr> Ok then, I'll send out the announcements.
14:34:20 <boegel|home> be sure to make people warm for writing an article in TMR
14:34:25 <shapr> warm?
14:34:46 <humasect> lhs format?
14:35:04 <shapr> humasect: That's for next month.
14:35:13 <humasect> kk, when is this month's due >
14:35:14 <shapr> Next month we switch to lhs2TeX
14:35:22 <xerox> Woo!
14:35:23 <cakoose> I'm using Parsec.  I'm trying to mix parsers with and without state, but can't figure out how.  Any pointers?
14:35:24 <boegel|home> shapr: heh, maybe that's translated too literally from Dutch.. 'to make people warm for something' :P
14:35:41 <Muad_Dibber> well boegel, i understand what you mean :P
14:35:56 <shapr> humasect: It's due by the first of next month, but I'd like to see some content before then :-)
14:35:59 <boegel|home> Muad_Dibber: yeah, I know you can, but how do you say it in proper English ? :D
14:36:08 <humasect> shapr: ok, yeah =)
14:36:22 <boegel|home> xerox: you should write something on your Cairo adventure !
14:36:27 <cakoose> My top level parser, has no state.  It creates an initial state and then delegates to lower-level parsers that have state.  Those parsers eventually use sub-parsers that don't have state.
14:36:42 <boegel|home> it doesn't have to involve any code stuff, just some stuff you learn, some kind of short column
14:36:42 <Muad_Dibber> make them enthusiastic? :P
14:37:00 <boegel|home> I think a lot of people would like to know what you went through
14:37:03 <boegel|home> Muad_Dibber: yeah :P
14:37:29 <xerox> boegel|home: I've an article for DDJ in the mailbox I can't finish :-|  Anyway, I should, I think :-)
14:37:57 <boegel|home> xerox: yeah, you should
14:38:09 <boegel|home> xerox: heard anything from the Google-people yet ?
14:38:33 <fnord123> no metrics? :-(
14:38:34 <xerox> boegel|home: I've to get that weird ITIN thing from US, so I'm waiting.
14:39:10 <shapr> ITIN?
14:39:13 <boegel|home> xerox: I hope everything works out well
14:39:21 <xerox> boegel|home: But maybe you want to know if the mentor was happy with my work, and if I get payed eventually :D
14:39:21 <shapr> Oh right
14:39:23 <boegel|home> @seen Itkovian
14:39:24 <lambdabot> I saw Itkovian leaving #haskell-blah and #haskell 53 minutes and 1
14:39:24 <lambdabot> second ago.
14:39:36 <xerox> The answer is 'yes', modulo ITIN.
14:39:37 <boegel|home> xerox: yeah, how about that ?
14:39:58 <Heffalump> @seen autrijus
14:39:59 <lambdabot> autrijus is in #haskell. Last spoke 1 day, 3 hours, 8 minutes and 8
14:39:59 <lambdabot> seconds ago.
14:40:21 <xerox> In the case I can't get it, I have a -30% of taxes to pay in the US, and the possibility of asking for that sum next year, or something.
14:41:48 <boegel|home> sound complicated
14:42:16 <xerox> Indeed.  That's why I hope in getting an ITIN, but it's said to take from 1 to 3 months, or something.
14:42:48 <xerox> ...and Google posed a deadline for tax paperwork submission at 31 Oct.
14:43:53 <boegel|home> tssk
14:44:33 <xerox> I'm a bit angry that they didn't even posted a list of the projects out there yet.
14:45:02 <boegel|home> yeah, it's like they don't want the projects to succeed
14:45:04 <xerox> Last news on http://code.google.com/ is 'Pencils Down!'.
14:45:47 <xerox> On the mailinglist they were saying something about a page in preparation, we'll see. :)
14:49:24 <fnord123> no, its hacking mas on xml.com
14:49:28 <fnord123> maps
14:50:18 <shapr> cakoose: I don't know how to do it, but have you seen the section about 'user state' in the Parsec tutorial?
14:52:43 * boegel|home goes to bed
14:54:32 <shapr> boegel|home: It's online and announced!
14:54:47 <Muad_Dibber> night all
14:55:06 <cakoose> shapr: I took a look at that, but couldn't find what I needed.  The problem might be that I'm not yet "fluent" with monadic programming.
14:55:14 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20050927"]' by shapr
14:55:52 <cakoose> shapr: I'm currently threading a generic state variable through all my parsers, but only using the state where needed.  Hopefully that'll work.
14:58:53 <boegel|home> shapr: yeah, I was, nice ! :)
14:58:58 <boegel|home> but now I really need sleep
14:59:00 <boegel|home> bye everyone !
14:59:11 <shapr> cya!
14:59:32 <shapr> w00, I got TMR5 online less than 24 hours late.
14:59:49 <shapr> 23 hours and 58 minutes admittedly, but hey....
15:01:13 * xerox hugs shapr
15:01:45 <alar> is it possible to install lambdabot on my irc channel?
15:01:58 <shapr> alar: Yes.
15:02:14 <shapr> xerox: thanks :-)
15:02:15 <alar> is it very difficult?
15:02:23 <Heffalump> shapr++
15:02:27 <Heffalump> @karma+ shapr
15:02:28 <lambdabot> shapr's karma raised to 10.
15:02:32 * shapr grins
15:02:37 <alar> =)
15:02:48 <alar> @karma shapr
15:02:49 <lambdabot> shapr has a karma of 10
15:02:52 <shapr> alar: Nope, grab the lambdabot source and look at the Config file.
15:02:54 * shapr cheers
15:02:58 <alar> @karma Heffalump
15:02:59 <lambdabot> Heffalump has a karma of 0
15:03:05 <shapr> @karma+ Heffalump
15:03:06 <lambdabot> Heffalump's karma raised to 1.
15:03:14 <Heffalump> have I done anything useful lately? :-)
15:03:24 <shapr> Very much so, work on the darcs GADT implementation.
15:03:26 <alar> @where lambdabot
15:03:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:03:33 <Heffalump> oh, how'd you know about that?
15:03:42 <Heffalump> not that it was a big secret
15:03:49 <xerox> Goodnight!
15:03:49 <Heffalump> but I didn't know it had been advertised already
15:04:00 <shapr> Someone mentioned it, and I just tend to remember stuff.
15:04:25 <araujo> H:e:l:l:o[]
15:04:39 * Heffalump fails to find this in #haskell scrollback
15:04:47 <Heffalump> but maybe my lastlog is only for one day.
15:04:57 * alar going along dependency chain: lambdabot -> darcs
15:05:12 <Heffalump> apt-get install darcs ;-)
15:05:57 <alar> @where darcs
15:05:58 <lambdabot> http://darcs.net/
15:07:13 <alar> oh, there is darcs port!
15:07:48 <shapr> What do you(plural) think about describing websites as a Data.Graph value that holds instances of the Haskell2Xml typeclass?
15:08:21 <tempest1> I think the plural of you is you all...
15:08:31 <Heffalump> only in American.
15:08:38 <mauke> all y'all
15:08:53 <astrolabe> It's yous in northern ireland
15:08:55 <fnord123> no the plural of you is you
15:09:06 <basti_> shapr: yes. although i do not know yet why you'd need a general graph structure for that.
15:09:07 <fnord123> the singular is ye
15:09:19 <fnord123> and thou
15:09:26 <Heffalump> the Northern Irish are all nutters, though.
15:09:36 <tempest1> there is a difference between old english and traditional english
15:09:37 <tempest1> that's old english
15:09:44 <fnord123> northern republic of ireland it sounds like yis
15:10:01 <shapr> basti_: For autogenerated navigation.
15:10:02 <basti_> shapr: i was thinking about specifying the graph manually for my forum thingie
15:10:09 <basti_> hmmmh
15:10:24 <fnord123> it holds in traditional english, though ye and thou are deprecated so you takes all second person pronouns
15:10:36 <basti_> it could really make sense, yes.
15:10:52 <basti_> for example, evaluating the structure lazily from a database
15:11:10 <shapr> On the downside, that's just for a static website. I don't know how to make it more dynamic.
15:11:17 * dcoutts notes that TMR 5 is out and the editorial advertises hIDE
15:11:18 <dcoutts> :-)
15:11:20 <tempest1> no it doesnt http://dictionary.reference.com/search?r=2&q=you-all
15:11:26 <basti_> hmh.
15:11:33 <fnord123> wikipedia has a fair article on the usbject
15:11:41 <basti_> actually it could be dynamic, via a state monad, or STM or whatever
15:11:56 <shapr> dcoutts: I thought about linking to the sexy screenshots directly...
15:13:10 <dcoutts> shapr, heh that'd be cool
15:13:29 <dcoutts> shapr, I'm not sure we've got any sexy screeshots linked from anywhere yet
15:13:46 <dcoutts> we should add them to the wiki
15:13:51 <shapr> http://www.scannedinavian.org/YiWiki/ScreenShots
15:14:16 <fnord123> thats a big ol' font
15:14:33 <dcoutts> btw the scannedinavian.org dns is still screwed for me
15:14:35 <alar> darcs failed:  Invalid repository:  http://www.cse.unsw.edu.au/~dons/lambdabot
15:14:43 <cakoose> I want to define a shorthand notation for my parser functions:  type P a = GenParser Char st a
15:14:43 <shapr> dcoutts: I don't know what's wrong with it :-(
15:14:45 <alar> possibly a bug in error checking
15:15:02 <alar> it should say: "you have no rights"
15:15:18 <cakoose> But I get a compiler error saying "st" isn't in scope
15:15:22 <Heffalump> alar: did you try adding a trailing slash? </guess>
15:15:32 <Heffalump> cakoose: st, or ST?
15:15:35 <shapr> cakoose: I think there's already a shorthand, 'Parser' I think.
15:15:41 <Heffalump> oh, you want ST, I think.
15:15:50 <cakoose> Heffalump: it's lowercase, I want it to be a type variable
15:15:50 <alar> Heffalump, I said su root - and it worked
15:16:02 <Heffalump> alar: oh, so it was a local permissions problem
15:16:06 <cakoose> shapr: The 'Parser' type has a state of (), which is not what I want
15:16:10 <mauke> cakoose: do you mean type P st a = GenParser st a?
15:16:10 <Heffalump> cakoose: well, you should make it be in scope, then :-)
15:16:11 <alar> yes
15:16:11 <shapr> Ah, ok.
15:16:16 <Heffalump> what type variable do you want it to be?
15:16:21 <cakoose> Heffalump: I tried adding a "forall st." in the front, but that doesn't work either
15:16:26 <alar> but darcs said wrong error description
15:16:28 <shapr> cakoose: Can you copy'n'paste'n'fix the Parser definition then?
15:16:33 <Heffalump> *why* do you want it to be a type variable?
15:16:47 <Heffalump> if it is one, you have to explain why to get the value from somehow
15:16:59 <cakoose> Heffalump: All my parser functions have the signature :: GenParser Char st MyDataType
15:17:14 <cakoose> Heffalump: They take a generic "st" so that they can be easily plugged into other parsers.
15:17:40 <cakoose> Heffalump: I just wanted a shorthand way of writing down their signatures, since its so repetetive.
15:17:45 <Heffalump> I think you mean what mauke said.
15:17:54 <astrolabe> Ah, excellent, another issue http://www.haskell.org/tmrwiki/IssueFive
15:18:14 <Heffalump> like with normal variables, you can't leave type variables out of scope.
15:18:33 <Heffalump> hello
15:18:50 <cakoose> Is there any way to just write "P MyData" for my function signatures and have it expand to "GenParser Char st MyData"?
15:18:57 <Heffalump> not without using CPP
15:19:07 <cakoose> Haha, really?
15:19:11 <Heffalump> yes, really.
15:19:12 <shapr> hei wolverian
15:19:23 <Heffalump> See what I said above about things being in scope.
15:19:29 <wolverian> hello, shapr :)
15:19:37 <SamB> @index MonadIO
15:19:38 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
15:19:38 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
15:19:38 <lambdabot> Monad.Error, Control.Monad.List
15:19:50 <cakoose> Heffalump: I think I understand the error, but was hoping there was some way to do what I want; perhaps some GHC extension?
15:20:05 <Heffalump> What you want is dynamic binding of type variables, and I can't see you getting it.
15:20:30 <Heffalump> Because if P MyData expanded to that, then st would end up binding to any random st in the scope you use P.
15:20:32 <cakoose> Heffalump: Ok, thanks.  At least now I wont waste time trying to get it to work.
15:20:46 <Heffalump> (or bein universally quantified if there isn't one in scope, cos that's what happens with function signatures)
15:20:57 <cakoose> Heffalump: But that's what I want, right?
15:21:06 <cakoose> Heffalump: Universal quantification
15:21:08 <Heffalump> I guess so, but it's not a very principled language feature.
15:21:14 <Heffalump> no, dynamic binding isn't.
15:21:17 <cakoose> I tried: forall st. [blah, blah]
15:21:26 <Heffalump> Universal quantification is, but the scope of what you tried to do is wrong.
15:21:36 <cakoose> Heffalump: ok. :(
15:22:34 <Heffalump> let me try to justify this some more... :-)
15:22:43 <Heffalump> Suppose someone else came along and wrote Q MyData
15:23:01 <Heffalump> that may or may not use 'st' inside it like your P definition does.
15:23:11 <cakoose> Heffalump: Well, I wouldn't want it to bind to whatever is in scope, but I do want it to be universally quantified.
15:23:23 <cakoose> And I think I want the "forall" immediately surrounding it.
15:23:25 <Heffalump> Then the behaviour of the signature P MyData -> Q MyData will depend entirely on whether you and the Q author happened to pick the same name or not.
15:23:44 <Heffalump> no, you want the forall surrounding the entire function signature you use P in.
15:23:58 <Heffalump> if you'll only ever write foo :: P MyData, then something might be doable.
15:24:12 <Heffalump> or in fact if you'll only ever write foo :: .... -> P MyData, it might still be doable.
15:24:25 <cakoose> How else could it be used?
15:24:28 <Heffalump> but you'd need to use a newtype, which would be an extra layer of constructor to handle
15:24:32 <Heffalump> as an argument to something?
15:24:36 <Heffalump> this is what combinators do
15:24:40 <Heffalump> e.g. 'many'
15:24:50 <cakoose> But "forall" can be put anywhere, right?
15:25:38 <Heffalump> not in argument position
15:25:49 <Heffalump> look at the type of runST to see why it means something different there
15:26:02 <cakoose> Oh, crap.  I think I see now.  If I had "Parser -> String -> Parser", then each parser would have its own "forall" instead of using the same type var
15:26:45 <Heffalump> yes
15:26:54 <cakoose> Would that be compilable, though?
15:27:01 <Heffalump> sort of
15:27:05 <Heffalump> but it's probably not what you want
15:27:23 <Heffalump> and the definition of the function with that type might be hard to write
15:27:31 <cakoose> No it isn't...  But as long as it has a defined behavior, it would be nice if it were allowed.
15:27:33 <Heffalump> no, sorry, the definition would be easy
15:27:37 <Heffalump> but using it would be hard
15:27:38 <cakoose> err
15:27:54 <Heffalump> you can do that kind of thing using data to define P
15:28:16 <Heffalump> you can't do it with type, because type is just for simple type aliases. It messes up type inference if it can do more clever stuff.
15:28:37 <Heffalump> (though I can't say for sure that this particular example wouldn't work)
15:28:52 <Heffalump> if you have (forall st . Parser st) -> String -> (forall st . Parser st)
15:28:59 <Heffalump> then you have to pass in a parser that can be used with *any* st.
15:29:02 <Heffalump> whereas what you want is
15:29:09 <Heffalump> forall st . Parser st -> String -> Parser st
15:29:14 <cakoose> Heffalump: right
15:29:24 <Heffalump> which means you can pick an st, pass in a Parser, and get one of the same type back
15:29:27 <Heffalump> which is much nicer for users :-)
15:30:14 <cakoose> Heffalump: But most of the time I just want "forall st . Parser st".  I realize that type inference is complicated, though.  Could barely follow all the twists and turns in TaPL.
15:30:39 <Heffalump> well, as we've established, you don't actually want that in argument position :-)
15:31:25 <cakoose> Do we not want it in an argument position, or do we just not want it to appear more than once?
15:32:03 <Heffalump> it appearing more than once has the problem of someone else writing Q as I described above
15:32:19 <Heffalump> it appearing in argument position imposes the constraint on the user that I described about having to supply a Parser that can handle *any* st.
15:32:55 <cakoose> Ok, I see.
15:32:58 <Heffalump> (forall a . Foo a) -> Bar is very different to forall a . (Foo a -> Bar)
15:33:17 <Heffalump> for a good explanation of this, take a look at the paper about the ST monad.
15:33:30 <cakoose> ok
15:33:42 <cakoose> Heffalump: thanks, man.
15:40:19 <araujo> newtype is different than data because it doesn't create a new bottom value?
15:42:07 <Heffalump> araujo: correct
15:42:21 <araujo> Thanks Heffalump
15:43:28 <Heffalump> more karma is of course always welcome ;-)
15:43:47 <araujo> @karma+ Heffalump
15:43:48 <lambdabot> Heffalump's karma raised to 2.
15:43:50 <araujo> :-]
15:43:53 <Heffalump> :-D
15:44:04 <metaperl> @karma+ Heffalump
15:44:05 <lambdabot> Heffalump's karma raised to 3.
15:44:23 <Heffalump> metaperl: there should be a good reason, though :-)
15:44:28 <metaperl> now if someone would just tell me what a "Heffalump" is...
15:44:49 <Heffalump> a bouncy thing.
15:44:59 <metaperl> well, I never congratulated you on participating in ICFP. and I appreciate having someone to answer tought questions like data versus newtype
15:45:05 <alar> what is bottom value?
15:45:12 * metaperl goes to make apple juice for himself
15:45:25 <Heffalump> alar: is that "I don't understand what bottom values are", or something deeper?
15:45:43 <alar> yes, right that
15:46:10 <alar> what bottom values are?
15:46:21 <Heffalump> errm, it's a bit subtle. The basic point is that every type has the values it represents, e.g. Char has 'a', 'b', 'c' etc.
15:46:42 <Heffalump> But types also have an extra value, called "bottom", sometimes written "_|_", or in a Haskell program "undefined"
15:46:50 <alar> 'a','b','c' can be viewed as constructors
15:47:04 <Heffalump> The purpose of this value is to signify when an error or non-termination happens when evaluating a value of that type.
15:47:07 <Heffalump> alar: right.
15:47:23 <alar> every type has bottom value?
15:47:26 <Philippa> yup
15:47:29 <Heffalump> If I ignore unboxed types (which are not part of Haskell itself, just a GHC extension) for now, then every type has a bottom value.
15:47:32 <dcoutts> metaperl, http://winnie-the-pooh.ru/stories/english/heffalump/
15:47:55 <Philippa> in practice the unboxed types have a notion of bottom - you'd consider a function to evaluate to it if it didn't terminate, for example
15:48:14 <alar> or maybe there is one bottom value of type () that is compatible with every type?
15:48:20 <Philippa> that reminds me: is it possible to check a record field isn't undefined before using it (for purposes other than that check)?
15:48:30 <Heffalump> Philippa: but anything passed an unboxed value has to be strict in it
15:48:49 <Philippa> which just means that the whole damn computation is going to fail, no?
15:49:08 <dcoutts> Philippa, the point is that strict types share the bottom value with the containing value
15:49:13 <ski> Philippa : not a bottom *value*, i'd say .. just bottom *expressions* (including function result)
15:49:23 <Philippa> dcoutts: sure
15:50:11 <Philippa> it's still meaningful to say that bottom came from the strict value though
15:51:23 <wagle> there is something wrong with viewing bottom as a value..  of course, I havent provided a desirable alternative yet..
15:51:24 <ski> (which ?)
15:51:43 <Philippa> wagle: depends on the context in which you're calling it a value, no?
15:52:17 <dcoutts> for a non-strict data constructor (say data T a = T a), T _|_ /= _|_, but for a strict data constructor (say data T' a = T !a), T _|_ = _|_
15:52:19 <ski> value could be defined as equivalence class of expression ..
15:52:28 <wagle> if v == _|_ then FieldsAward else Nada
15:53:17 <ski> wagle : the result of that comparision is _|_, and so is the result of the if-then-else, :)
15:53:25 <wagle> _|_ :: Int == _|_ :: Char
15:53:44 <ski> wagle : i think not
15:53:47 <dcoutts> wagle, I would disagree
15:53:48 <Heffalump> alar: in practice all bottom values behave the same, but semantically each type has its own bottom value
15:53:58 <wagle> that was a question, sorry
15:54:16 <dcoutts> that'sa key difference between a typed and untyped view of things
15:54:21 <wagle> if v == ack 10000 1000000 then ...
15:54:35 <alar> Heffalump, is there a reason for it or just the developers choice?
15:54:52 <Heffalump> it's just what makes sense, semantically.
15:54:53 <ski> alar : Occams Razor
15:54:59 <wagle> bottom is a behavior not a value [?]
15:55:18 <ski> wagle : one could possibly say so ..
15:55:27 <wagle> einstein said "make things as simple as possible, but no simpler"
15:55:31 <alar> ski: most of OO-languages would be split by that razor in pieces =)
15:55:37 <Heffalump> alar: there is no subtyping of () to anything else in Haskell.
15:55:41 <dcoutts> alar, it makes sense in a typed setting. In an untyped language you would view all bottom values as the same
15:55:50 <Heffalump> so it doesn't make sense for ()'s _|_ to belong to any other type.
15:55:56 <ski> (alar : i know ..  orthogonality and all ..)
15:55:58 <fnord123> im looking at one of those language graphs for the history of programming languauges. i think it's weird how none of them show oak/java coming right out of module3
15:56:25 <fnord123> afaik, oak is modula3 with {} style syntax
15:56:43 <wagle> what is the truth value of the sentence "This sentence is false"
15:56:51 <alar> dcoutts: what do you mean by "untyped languages"?
15:56:58 <dcoutts> alar, eg lisp
15:57:02 <fnord123> in trinary logic, it's "doesnt matter"
15:57:22 <ski> wagle : one possible way is saying : type error :)
15:57:23 <alar> I don't know lisp sufficiently to understand
15:58:32 <wagle> if v == 1 then ...
15:58:37 <alar> wagle: bottom or "the setntence is irreducible to terminal"
15:58:42 <wagle> nm..
15:59:27 <wagle> how do i distinguish between bottom and ack 10000 10000?
15:59:36 <wagle> you have 5 seconds to answer
16:00:10 <cakoose> I'd appreciate any help with my Parsec problem:  A sub-parser needs some state, but the top level parser doesn't.  I'm having problems calling the sub parser.
16:00:55 <wagle> .. but as i said: "I havent provided a desirable alternative yet.."
16:00:59 <cakoose> I think I'm looking for a function that looks like :: newSt -> Parser (newSt, st) -> Parser st
16:01:02 * wagle sighs
16:01:40 <dcoutts> wagle, so what's your point about "long running computation ~~ non-terminating computation"
16:01:41 <wagle> fnord123: i prefer "I dont know"
16:01:47 <Heffalump> cakoose: you've looked through the Parsec documentation for something that can change the state?
16:02:00 * Heffalump 's web browsing is broken atm or I'd take a look
16:02:04 <cakoose> Heffalump: I've seen 'setState' and 'getState'
16:02:08 <fnord123> oh maybe im thinking of quadrary logic
16:02:11 <Heffalump> but those don't change type?
16:02:14 <cakoose> Heffalump: But those seem to change the state values.  I need to change the state types.
16:02:15 <fnord123> w/ dont know and dont care
16:02:23 <Philippa> ah. That doesn't work
16:02:32 <cakoose> Heffalump: Err...do they change the state types as well?
16:02:32 <Philippa> If the top-level bit doesn't touch state, it merely doesn't touch it
16:02:47 <cakoose> Heffalump: I didn't even try that because I didn't think it would work.
16:02:54 <Heffalump> cakoose: I doubt they do
16:02:59 <wagle> dcoutts: if i could say, i'd have a paper
16:03:01 <Heffalump> I just fixed my web browsing, I think.
16:03:05 <Heffalump> Hang on and I'll see if I really did
16:03:31 <Philippa> you can type "doesn't care about state", but if a parser calls other parsers that do care (without having been passed them) then it also cares itself
16:04:24 * wagle wanders off into the sun & rain for a bit
16:04:27 <cakoose> Philippa: I was hoping to write sub-parsers that keep track of the parent state as the second in a tuple.
16:04:42 <cakoose> Philippa: And then pass around their own state in the first of that tuple.
16:04:52 <Philippa> er, why do they need to do that?
16:05:06 <Philippa> why can't the one parser that got called by the parent hang on to it then put it back when it's done?
16:05:08 <rep> is it me or is template haskell much harder to use compared to lisp macros?
16:05:14 <Philippa> rep: yes, it is
16:05:16 <cakoose> Philippa: Will that work?
16:05:21 <rep> Philippa oh ok
16:05:24 <Philippa> cakoose: yup, I'm doing that in my own code
16:05:30 <cakoose> Philippa: Doesn't the stuff have to be passed through the entire chain?
16:05:44 <cakoose> Philippa: OMG!  That's what I wanted to do at first but I couldn't figure out how.
16:05:50 <Heffalump> cakoose: it looks to me like the only way you could do it is to actually call runParser
16:05:56 <Heffalump> oh, right, Philippa sorted it out
16:06:08 <Philippa> do temp <- getState; otherParsers; putState temp; return whatever
16:06:09 <ski> hm .. there is an 'updateState :: (st -> st) -> GenParser tok st ()' ..
16:06:12 <Heffalump> I should have thought more about what you were asking for :-)
16:06:15 <Heffalump> ski: yes
16:06:23 <Heffalump> with precisely that name and type
16:06:25 <Philippa> or yes, you could use updateState :-)
16:06:30 <ski> (but that doesn't work for this)
16:06:53 <cakoose> Philippa: But the state types are different.
16:06:57 <Philippa> myself I'm keeping a structure full of parsers in the state, but you probably don't want to think about that right now...
16:07:01 <Philippa> ah. That does screw you somewhat
16:07:32 <cakoose> Heffalump: runParser seems to be the only way to "start" a parser
16:07:34 <Heffalump> how about a record?
16:07:39 <Philippa> you'll have to yank the data being parsed out of the monad, fire off a new instance and return the remaining info
16:07:39 <Heffalump> cakoose: yes
16:07:47 <Philippa> there're ways of doing that
16:08:28 <cakoose> How do I get the remaining string out of the monad?
16:08:41 <ski> one would perhaps want something of type '(st0 -> st1,st1 -> st0) -> (GenParser tok st1 a -> GenParser tok st0 a)'
16:08:52 <Philippa> RTFM, the combinators're in the basic module
16:08:59 <Philippa> I can look it up, but you can find it just as fast as I can
16:09:04 <cakoose> I have the page open...
16:09:20 <Philippa> or maybe not:
16:09:20 <Philippa> getInput  :: GenParser tok st [tok]
16:09:20 <Philippa>     Returns the current input
16:09:20 <Philippa> setInput :: [tok] -> GenParser tok st ()
16:09:20 <Philippa>     setInput input continues parsing with input. The getInput and setInput functions can for example be used to deal with #include files.
16:10:07 <Philippa> sometimes I can't help thinking there should be a Parsec monad transformer as well so that you could easily layer it on top of the ST or IO monads...
16:10:54 * ski wonders if that would be less lazy
16:11:06 <Philippa> potentially, yes
16:11:13 <Philippa> depends on the underlying monad
16:11:13 <ski> (if put over Id monad, i.e.)
16:13:19 <Philippa> assuming Id's accurately named it shouldn't
16:25:16 <alar> is there a library of regexp parsers/combinators?
16:26:23 <syntaxfree> what are monads?
16:27:37 <cakoose> Phillipa: Is there an easy way to do the "new parser launch" thing I'm trying to do?
16:28:07 <dcoutts> @hoogle [a] -> Bool
16:28:09 <lambdabot> Prelude.null :: [a] -> Bool
16:28:09 <lambdabot> Prelude.or :: [Bool] -> Bool
16:28:09 <lambdabot> Prelude.and :: [Bool] -> Bool
16:28:44 <cakoose> Philippa: I'm writing the code and it seems pretty tedious.  I have to save and restore the input and position, and then process the possible ParseError and forward it back up...
16:29:07 <Philippa> yup, sucks :-(
16:29:22 <Philippa> best you can do is wrap it all up in the one function so you only ever have to write it once
16:29:56 <cakoose> Phillipa: Ok.  The one problem I've hit is that I don't know how to forward a ParseError from the child up to the parent.
16:30:36 <cakoose> Phillipa: I think I can inject a String that has the message, but I don't want to the line number information.
16:31:11 <cakoose> Philippa: err... "don't want to **lose** the line number information"
16:31:14 <Philippa> you can get and set the source positions as well as the input?
16:31:28 <ski> syntaxfree : monads are a way of hiding "effects" .. it's a kind of way of structuring programs
16:31:33 <cakoose> Philippa: Yes.
16:31:51 <TheHunter> cakoose, with ghc's extensions: type P a = forall st. GenParser Char st a
16:32:09 <cakoose> TheHunter: I tried that, but it didn't work either.
16:32:12 <Philippa> ski: "hiding effects" is... misleading, IMO
16:32:18 <Philippa> if anything they do quite the opposite
16:32:22 <cakoose> TheHunter: The type definition went through, but I couldn't use it.
16:32:37 <ski> Philippa : you're right, i was a bit sloppy/unclear in wording
16:33:26 <TheHunter> it should work.
16:33:36 <cakoose> syntaxfree: The best tutorial for monads I've seen so far is: http://www.nomaware.com/monads/html/
16:34:39 <ski> syntaxfree : e.g. to have state, you can pass around a value in and out of all parts of program that needs the state .. what the monad hides in this case is the tedious code for explicitely threading around this value
16:35:15 <sh10151> my monads are nomads
16:35:27 <cakoose> syntaxfree: And in the case of functions that might return "Nothing", the monad takes care of putting the "if (Nothing) return" after every function call.
16:35:28 <Philippa> I'm off, good luck to everyone in need of answers
16:35:53 <Heffalump> TheHunter: it won't do what cakoose wants, for the reasons I explained
16:36:27 <ski> syntaxfree : another monad deals with things that can fail .. you could want to do a series of operations after eachother .. each of them can fail .. if any one fails the rest should not be performed .... here the monad hides checking the "error code" for every operation and possibly skipping rest of operations
16:36:43 <ski> syntaxfree : but look at that tutorial ..
16:36:58 <TheHunter> didn't he want to expand "P MyData" to "GenParser Char st MyData" ?
16:37:18 <cakoose> TheHunter: Yes, but for some reason the "forall" didn't work for me.
16:37:46 <cakoose> TheHunter: I was using it to define a function:  "parseRule :: P Rule"
16:38:18 <TheHunter> unless i'm missing something obvious, that should really work.
16:39:19 <Heffalump> were you compileing with -fglasgow-exts ?
16:39:35 <cakoose> Yes I was
16:39:36 <Heffalump> TheHunter: it won't do what he wants if he uses P Rule in argument position of a function
16:39:45 <Heffalump> or uses it twice in a function
16:39:56 <Heffalump> the quantification will be all wron
16:39:57 <Heffalump> gg
16:40:57 <cakoose> Hmm...it worked in a very minimal test case.
16:41:05 <cakoose> I don't know why it died when I first tried to use it.
16:42:56 <TheHunter> Heffalump, but it will cover the "first-order-cases" and that should be most of the cases.
16:48:05 <Heffalump> true.
16:48:22 <Heffalump> but it'll be confusing to anyone reading the source why it couldn't be used elsewhere.
16:50:34 <shapr> g'day Pseudonym
16:50:42 <Pseudonym> G'day.
16:50:50 <Pseudonym> Just read your mail about TMR. :-)
16:50:52 <shapr> Ah, spiffy
16:50:54 <Pseudonym> No, I can't finish it in time.
16:50:55 <Pseudonym> Sorry. :-)
16:51:00 <shapr> Heh, it's okay :-)
16:51:58 <shapr> Man, I want TMR feedback. What sucks? What's nifty?
16:52:44 <wagle> TMR?  The Medieval Review?  8)
16:52:54 <Pseudonym> TMR is nifty!
16:52:59 <Pseudonym> Consider this feedback.
16:53:05 <wagle> Transmyocardial revascularization?
16:53:27 <wagle> duh,.,..
16:53:29 <wagle> nm
16:53:38 <wagle> i thought it sounded familier
16:54:19 <Pseudonym> Transient Memory Record
16:57:21 <Pseudonym> Triple Modular Redundancy
16:57:25 * Pseudonym wonders what that means
16:57:42 <Pseudonym> Oooh, cool.
16:57:49 <Pseudonym> That makes sense.
16:58:06 <Pseudonym> Oh, of course!
16:58:11 <Pseudonym> TMR == The Matrix Reloaded
16:58:21 <wagle> bingo!
17:06:14 <rep> omfg new monad reader!?
17:07:35 <shapr> shock!
17:08:02 <wagle> Nuclear Magnetic Resonance..
17:27:22 <shapr> Pseudonym: Hey, think you can have that article ready for the next TMR?
17:29:43 <Pseudonym> That's looking more likely, thanks to the Good Free Time Fairy.
17:42:24 <syntaxfree> I can't quite understand why make a zine a wiki.
17:43:09 <shapr> syntaxfree: How else would you do it?
17:43:33 <Pseudonym> It's code that doesn't have to be written.
17:45:45 <shapr> syntaxfree: If you have better/easiers suggestions, I'm very interested. I don't enjoy the boring organizational bits of TMR.
17:54:52 <syntaxfree> shapr: WordPress?
17:55:20 <syntaxfree> just a thought. I don't know what TMR is really like, so.
17:55:56 <syntaxfree> @eval let double = (*2) in (double $ double $ double $ double 8) - 1
17:56:03 <lambdabot> 127
17:56:36 <syntaxfree> hmm. so $ will restrict its action inside the parenthesis, right?
17:57:05 <alar> what's the difference between @eval and @plugs?
17:57:06 <shapr> syntaxfree: Why WordPress?
17:57:32 <syntaxfree> well, because it's not a wiki. Because vandals can't vandalize your wiki.
17:57:50 <syntaxfree> it's a simple one-button-publishing blog system.
17:58:51 <syntaxfree> question. Does $ have more or less precedence than parens?
17:59:19 <ski> parens doesn't have precedence in the normal way .. they group
18:00:10 <alar> parens are not operator
18:00:18 <syntaxfree> hmm.
18:00:21 <alar> how can they have precedence?
18:00:29 <ski> f x $ g (h a b $ i d) y $ j z   is the same as f x (g (h a b (i d)) y (j z))
18:01:36 <syntaxfree> ok. thanks :)
18:10:55 <shapr> syntaxfree: TMR wiki is not editable by default, only for TMR authors.
18:23:59 <dcoutts> anyone know of some simple min/max ai code in Haskell?
18:24:12 <dcoutts> i'm coding a little simple board game
18:24:53 <dcoutts> I've got the game rules & GUI done
18:25:01 <dcoutts> now I want an AI to play against :-)
18:25:15 <dcoutts> and to make the GUI a bit more flashy :-)
18:25:23 <alar> I tried to write checkers and borrowed main ideas from some tutorial
18:26:04 <dcoutts> got a url for that tutorial?
18:26:35 <alar> probably this http://www.md.chalmers.se/~rjmh/Papers/whyfp.pdf
18:26:48 <dcoutts> oh ok ta
18:27:00 <alar> there are no code, but  handful of hints
18:28:09 <dcoutts> yep
18:41:19 <syntaxfree> aalar: thats a cool pdf.
18:44:55 <syntaxfree> shapr: TMR is composed in latex, right?
20:57:17 <SamB> @index even
20:57:19 <lambdabot> Prelude
21:03:58 <onstage> Hi channel
21:04:38 <ptolomy> hello.
21:04:55 <ptolomy> I'm not the channel.. but.. y'know.
21:05:55 <onstage> well i just found this place
21:06:24 <onstage> does haskel require a compiler?
21:11:14 <int-e> it may require a bit more patience than that.
21:12:52 <Pseudonym> The compiler isn't THAT slow.
21:14:36 <int-e> Heh, I was more thinking about learning the language or getting questions answered. For compiler speed, I've seen worse from C++.
21:15:06 <Pseudonym> Indeed.  Especially when you have Boost.
21:15:16 <Pseudonym> Having a Turing-complete language in the type system doesn't help compiler performance.
21:15:20 <int-e> or sigc++ + gtkmm (+STL of course)
21:15:24 <int-e> hehe
21:17:14 <int-e> Having side effects in include files (well, *having* include files instead of module signature descriptions) doesn't help either.
21:24:39 <SamB> @pl (+1)
21:24:40 <lambdabot> (1 +)
21:24:44 <SamB> @pl (1+)
21:24:45 <lambdabot> (1 +)
21:33:14 <int-e> @pl (\f g h i -> i h g f)
21:33:15 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
21:37:22 <int-e> @pl (\a b c d -> a $ b $ c $ d)
21:37:23 <lambdabot> (. (.)) . (.) . (.)
21:46:14 <KrispyKringle> @pl (\f g h i -> i h g f)
21:46:15 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
21:46:24 <KrispyKringle> huh.
21:59:17 <int-e> @help pl
21:59:18 <lambdabot>  @pointless <expr> - play with pointfree code
22:00:16 <sieni> Argh, the pointfree madness has propagated from algebraic geometry to programming
22:00:29 <int-e> if you dislike lambdas ver much, you can use that term with many flips instead of the lambda expression. I'd prefer the lambda expression. (\x y.y x) = flip id is cute though.
22:00:43 <int-e> sieni: SK combinator calculus has existed for a while *g*
22:02:59 <gzl> why is pointfree interesting?
22:04:45 * int-e thinks there's a reason the command is called 'pointless' and not 'pointfree' :)
22:05:50 <sieni> gzl: well, at least in noncommutative geometry they want to express all constructions using just functions instead of points, since many of the noncommutative spaces do not have any points, but the proofs might still go through if done using the function notation
22:06:34 <gzl> how can a space have *no* points?
22:07:45 <int-e> gzl I think that isn't the point - you just don't mention them in your calculation. (at least that's what @pl seems to do if you think in terms of functions from spaces to spaces)
22:08:49 * int-e has no clue what noncommutative spaces are.
22:09:38 <gzl> they're simply noncommutative algebraic structures with some topological structure, afaik
22:10:12 <gzl> oh, no, disgusting
22:10:23 <gzl> they're spaces whose rings of functions are noncommutative
22:10:23 <sieni> http://en.wikipedia.org/wiki/Noncommutative_geometry
22:10:25 <gzl> so foul
22:10:30 <gzl> yeah, I just looked that up
22:10:32 <int-e> google is helpful. "An Introduction to Noncommutative Spaces and their Geometry". now to decide if I want to read that. Hehe.
22:11:56 <gzl> probably not
22:12:02 <gzl> noncommutative things are bad =\
22:12:38 <Cale> gzl: well, "ring of functions" is a bit loosely applied there :)
22:14:10 <int-e> hrm, if I read 'ring of functions' I want to make the multiplication the function application - is it even possible to have rings of that sort (I guess yes, but are there common examples?)
22:14:51 <int-e> uhm. linear maps (matrices). duh.
22:15:04 <Cale> or a group ring
22:15:18 <gzl> yeah.
22:15:32 <Cale> and I think quivers also sort of have that sort of idea
22:16:02 <Pseudonym> The space we live in doesn't really have "points", for the record.
22:16:15 <int-e> Pseudonym: is it a space?
22:16:16 <Pseudonym> All that's important is where you are relative to an agreed-upon origin.
22:16:23 <Pseudonym> I hope it is!
22:16:33 <Cale> Pseudonym: that's up to interpretation
22:16:41 <gzl> int-e: another standard example is the set of endomorphisms of a fixed R-module M (called the endomorphism ring of M)
22:16:51 <Cale> The space we live in has points if the model we use for it defines "points".
22:17:01 <Pseudonym> True.
22:17:10 <gzl> int-e: then the multiplication is application as well
22:17:44 <Pseudonym> From a practical point of view, point-free code is usually easier to manipulate.
22:17:49 <int-e> gzl: let's just pretend I never asked that question, ok?
22:17:51 <Cale> http://en.wikipedia.org/wiki/Quiver_%28mathematics%29 -- check out the quiver algebra.
22:17:54 <Pseudonym> You don't have to rename variables 'cause there aren't any.
22:17:55 <gzl> int-e: ok. :)
22:18:18 <gzl> int-e: I wasn't sure how much algebra you might be familiar with
22:19:31 <int-e> gzl: enough to know that semigroups can be thought of as function maps (to good effect in some areas) - which makes the question stupid.
22:19:43 <int-e> gzl: err, the elements of those
22:20:11 <gzl> well, you've at least heard the word 'ring', which puts you in the top .00001% or whatever. :P
22:27:53 <int-e> gzl: ok, I now know 'R-module' as well.
22:28:10 <gzl> so fast? :)
22:28:23 <int-e> well I know what a vector space is :P
22:29:51 <Cale> yeah, and an R-module is not that different in definition from a vector space, but they're a good deal more irritating to have to work with :)
22:33:08 <int-e> Cale: btw I've made a generic linear recurrences evaluator (given a linear recurrence and the first n elements of a sequence; find the k-th element) - it works for arbritrary rings and uses O(n^2 log(k)) operations; it beats my previous fibonacci number evaluator in speed. I was surprised *g*.
22:33:21 <Cale> :)
22:33:40 <int-e> (btw because working with matrices over rings means I was actually dealing with a module there)
22:33:54 <Cale> yeah
22:34:34 <sieni> int-e: so you wrote a module module for that?
22:34:57 <int-e> [note that the naive implementation of exponentiation of the generator matrix uses O(n^3 log(k)) operations)
22:35:02 <int-e> sieni: yes.
22:37:25 <int-e> http://www.inf.tu-dresden.de/~bf3/haskell/LinRec.hs <-- that's the one; I still need to add some comments explaining the math though.
22:37:32 <sieni> argh, fsm has eaten all my clean socks
22:38:42 <int-e> (suggestions for the function names are welcome - the ones I used are very generic)
22:42:03 <int-e> but then that's what modules are good for.
22:43:11 <int-e> (Haskell modules. Not ring modules.)
22:51:33 <int-e> sieni: err. no, no module module. sorry. I just read 'module' once.
22:51:49 <sieni> :-)
22:52:35 <int-e> sieni: I exploited the fact that the module I worked with has a basis anyway.
22:58:21 * boegel boings
22:59:43 <int-e> does that hurt?
22:59:44 <int-e> hehe
23:16:33 <boegel> yo Itkovian
23:17:18 <Itkovian> meuning
23:40:47 <Oejet> boegel: Hello.
23:41:29 <boegel> hey Oejet
23:48:40 <Pseudonym> Nytol!
23:50:06 <JohnMeacham> howdy
23:50:33 <Oejet> JohnMeacham: Hello.
23:59:59 <Oejet> JohnMeacham: Does jhc use ideas from the GRIN project paper/ph.d?
