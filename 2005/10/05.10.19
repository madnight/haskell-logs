00:00:04 <basti_> I think the best way to learn about new languages is to uhm... actually go and learn them... and probably the best way to do that is writing little things in them, until you're able to write "big stuff"
00:00:07 <Cale> and for other programs related to the project
00:00:27 <basti_> I'd certainly judge a 3d game lib binding to be "big stuff"
00:00:30 <Megzl> Cale, there actually is no game logic that's hard coded. It's only an engine, with entities created by the players.
00:00:34 <Cale> sethk: sorry :)
00:00:46 <sethk> Cale, about what?
00:00:49 <Megzl> My original interest in Haskell was using it as the language that those users write the entities in.
00:00:53 <Cale> sethk: not answering
00:01:10 <sethk> Cale, hey, you have spent a ton of time with me.
00:01:22 <Cale> Your combined monad might look something like ReaderT Integer (StateT [String] IO) a
00:01:31 <skew> Megzl: if you are having this much trouble learning the language, do you think that's a good idea?
00:01:47 <Cale> sethk: this quickly gets unwieldy, so I recommend newtypes
00:01:55 <Cale> you can derive the instances of Monad
00:01:58 <Cale> and such
00:01:58 <Megzl> Skew, I'd learn Haskell extremeley fast.
00:02:06 <skew> Megzl: but that sort of stuff is probably the easiest way to mix Haskell into a program like this
00:02:24 <Megzl> Who ever said anything about having trouble learning Haskell?
00:02:25 <skew> if you've got lots of C++ to talk to, write some C++ to talk to it, and just worry about getting Haskell to talk to that code
00:02:35 <sethk> Cale, at the moment I'm just trying to sketch an architecture.
00:02:36 <Megzl> We're talking about another topic besides learning Haskell.
00:02:54 <Megzl> Skew, you're the only person who said I have trouble learning Haskell -- but that's rather an arbitrary assertion.
00:03:09 <sethk> Cale, do you understand my question?  I have liftIO in StateT to access IO functions.  In your type, are the functions that do the same thing?
00:03:15 <integral> Megzl: I don't understand where you're having trouble with this.  Can't you just call hs-plugins via FFI to use haskell as scripting?
00:03:28 <basti_> please guys, do not heat this up artificially...
00:03:28 <skew> Okay, you seem to be going through a very long process of arguing that Haskell is impractical for your problem before you settle down to actually learning the langauge
00:03:34 <Cale> liftIO always lifts the IO layer that's on the bottom
00:03:43 <Cale> lift always lifts things one layer up
00:03:45 <Megzl> I'm not having any trouble with Haskell. I'm not even using Haskell.
00:03:50 <Megzl> I've never used it.
00:04:01 <integral> Megzl: I thought you wanted to use Haskell?   Have you seen hs-plugins?
00:04:09 <basti_> certainly that would pose a problem for understanding it.
00:04:11 <sethk> Cale, so I use lift, it's generic enough to use in this situation?  Must be.
00:04:18 <Cale> yeah
00:04:26 <Megzl> The topic isn't understanding Haskell.
00:04:31 <Megzl> I'm not sure where that came from.
00:04:34 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.Trans.html
00:04:46 <Megzl> If the heat was understanding Haskell, I'd be here asking 500 questions a day and talking to Cale nonstop.
00:05:00 <Megzl> Anyways,
00:05:16 <Cale> Megzl: why is it that you want to use Haskell if you've never used it?
00:05:18 <Megzl> My original question was about using Haskell *completely*
00:05:27 <gzl> it seems like you've been going on about these bindings for nearly a week
00:05:35 <Cale> Using Haskell completely is a sensible choice for many projects
00:05:36 <Megzl> gzl: Pardon?
00:05:40 <Cale> maybe not for yours
00:05:55 <Megzl> gzl: I've never before mentioned bindings.
00:06:03 <Cale> I'd even guess that it's a sensible choice for most projects.
00:06:35 <Cale> most of the apps that get written don't use heavy duty 3D libraries.
00:06:36 <Megzl> Is hs-plugins sandboxed?
00:06:45 <Cale> Megzl: yes, via the type system
00:06:56 <Megzl> What is the memory footprint per state?
00:06:57 <skew> oh, dazzle calls out to some C++, doesn't it?
00:07:08 <Cale> Megzl: per state?
00:07:14 <integral> Megzl: what's a state?
00:07:41 <skew> I said before, I don't think you need lots of copies of the runtime because there's actually a type system and stuff
00:07:53 <Megzl> A state being a chunk of code which is run, can indepentently start/stop/crash without affecting any of the other world objects.
00:08:02 <skew> A thread costs 300 bytes, I think (though I might be thinking of erlang)
00:08:17 <Cale> @eval product [1..10]
00:08:17 <sethk> Cale, I'll use lift and try to find a way of running from a three level monad
00:08:31 <skew> sethk: what's your code doing?
00:08:32 <lambdabot> 3628800
00:08:34 <Megzl> Can those threads independently crash?
00:08:34 <integral> would you need haskell's own threads if you're driving it via your own code though?
00:08:51 <integral> Megzl: I'm not sure what you mean by "crash"
00:09:02 <Megzl> integral: User writes completely wrong code. The code dies.
00:09:05 <skew> integral: if you want to avoid nontermination
00:09:13 <boegel> integral: the new movie with Sandra Bullock ? :P
00:09:16 <sethk> skew, I'm coding the low level file abstraction for my SQL server
00:09:24 <integral> skew: true!
00:09:33 <integral> Megzl: completely wrong code?   How would that get compiled?
00:09:45 <integral> if it's a user-level error, like an exception from your own code, that's all ok
00:09:46 <Itkovian> lol
00:09:47 <Megzl> integral: Logic errors, not syntax errors.
00:10:06 <integral> Megzl: Well a logic error would just get an exception thrown, or you'd get bottom returned
00:10:15 <Itkovian> in C++, apparently, you can write completely wrong code, that compiles and then crashes
00:10:17 <skew> sethk: you might be happier writing the lifted version once rather than scattering lift throughout the code
00:10:35 <skew> integral: wow! how quaint.
00:10:37 <integral> golly, you'd have thought they'd have developed compilers that prove your code correct by now!
00:10:40 <Megzl> Can hs-plugins stuff be easily compiled at runtime?
00:10:44 <sethk> skew, not sure what you mean.
00:10:51 <Cale> skew: Itkovian?
00:10:51 <integral> Megzl: well that's sort of the whole point...
00:10:57 <Megzl> Ok.
00:11:01 <Megzl> And lastly;
00:11:23 <Megzl> I have a bunch of classes/functions in C++. I need them to be accessible in the Haskell environment.
00:11:26 <sethk> Itkovian, oh, of course.  As long as it is synactically correct.
00:11:34 <Megzl> How would I bind them?
00:11:39 <Itkovian> with rope
00:11:42 <Itkovian> (sorry)
00:11:45 <Megzl> For use with hs-plugins
00:11:48 <skew> sethk: say you want to get at "get" from state, insteast of saying lift (lift get), maybe you say getDBHandle = lift (lift get) once
00:11:54 <Itkovian> Megzl: use FFI?
00:11:56 <skew> sethk: it's worked for me
00:11:57 <Megzl> I don't simply mean binding function calls.
00:11:58 <integral> hmm, I seem to remember a paper (spj?) about using C# objects in haskell's type system
00:12:00 <Megzl> Sorry...
00:12:04 <Megzl> I'm not talking about binding an API.
00:12:08 <Megzl> I'm talking about actually binding objects.
00:12:12 <Itkovian> hmm.
00:12:17 <skew> Megzl: you should look at wxHaskell
00:12:19 <skew> it does that
00:12:20 <integral> Megzl: that is an API, surely?
00:12:21 <sethk> skew, oh, yes, in some cases I can do that.  not in all
00:12:24 <skew> that is, they bind some objects
00:12:32 <sethk> skew, right, I see it now.
00:12:33 <skew> it's not a generic binding generator
00:12:51 <skew> sethk: I don't see why you should ever need to use lift
00:12:54 <Cale> mbot: @listcommands
00:12:55 <mbot> use listcommands [module|command], please. Modules are:
00:12:55 <mbot> base dynamic help math more pl plugs seen system type version
00:13:15 <Cale> mbot: @dynamic-load dice
00:13:15 <mbot> module loaded
00:13:25 <Cale> mbot: @dice 3d12
00:13:25 <mbot> 3d12 => 22
00:13:29 <sethk> skew, according to the discussion here earlier, to use IO functions from within the StateT monad, I need to use liftIO
00:13:34 <sethk> skew, is that not true?
00:13:49 <Megzl> Say for instance: I have a class in C++. I need to be able to instanciate objects of that type, into Haskell -- call member functions on that object, and then delete that object and have its destructor called just as if I'd used it in C++.
00:14:00 <Megzl> That's how luabind works.
00:14:09 <Megzl> luabind also supports all the operators of a class.
00:14:17 <Cale> Megzl: the bot there just loaded some haskell code.
00:14:25 <integral> you just bind each method to a haskell function, and the class becomes an ADT (or possibly a typeclass to do inheritance)
00:14:39 <skew> sethk: ah, that's kind of a special case because there are so many IO functions that you don't want to wrap them individually
00:14:53 <skew> sethk: building a monad is kind of like building up a data type out of sums and products
00:15:01 <Megzl> I'll bet a lot more people would use Haskell if it could be bound into C++ and have C++ classes reflected into it.
00:15:08 <Megzl> In a simple way.
00:15:10 <Megzl> As simple as this:
00:15:17 <skew> sethk: data Tree a = Leaf | Node (Tree a) a (Tree a)
00:15:20 <Megzl> http://www.rafb.net/paste/results/rz4NBk34.html
00:15:43 <Cale> Megzl: Haskell doesn't use subtype polymorphism
00:16:02 <Cale> It uses (typeclass restricted) parametric polymorphism
00:16:08 <sethk> skew, the wrapper functions still use lift, right?
00:16:13 <skew> sethk: is equivalent to something like Tree a = 1 + (Tree a x (a x Tree a))
00:16:17 <skew> sethk: yeah, those do
00:16:36 <Megzl> Someone needs to make Haskellbind.
00:16:39 <skew> sethk: but you really want to say Leaf, not inl
00:16:44 <sethk> skew, ok, I understand.  as in   let x = (lift whatever)    in
00:16:48 <Megzl> luabind is like boost::python
00:16:51 <Megzl> almost exact same template code
00:16:56 <Megzl> python can be bound into C++ in the same way.
00:17:06 <Megzl> It's a dualistic binding.
00:17:23 <Megzl> C++ objects/classes/functions bound to Python, and Python VM setup in C++
00:17:32 <Cale> Megzl: why don't you write it?
00:17:34 <integral> bother, I can't find this paper :-/
00:17:36 <skew> Megzl: sounds like a good project for learning the the FFI bits of Haskell
00:17:53 <skew> and templates and stuff, plus you'd end up with something you could use
00:18:52 <Cale> Probably easier than John Meacham's learning Haskell project
00:18:58 <sethk> skew, you lost me on one thing.  "but you really want to say Leaf, not inl"
00:19:08 <Megzl> I'd create Haskellbind if I could be locked in a dark jailcell for 75 years with nothing but a console terminal; inside of which time did not flow forward and I would not age.
00:19:10 <sethk> skew, Leaf I see in the Data statement.
00:19:30 <Megzl> Well, if the 75-years ever expired that would mean time was flowing forward and I was aging.
00:19:35 <Megzl> But, just, nonlinearly.
00:20:03 <Cale> Megzl: it couldn't take more than a few months to get something reasonable going
00:20:09 <Itkovian> seems like I have to refresh my C++ syntax knowlegde
00:20:23 <skew> sethk: I'm trying to say, building a monad from transformers and writing code with lift is like building up a data type out of sums and products and writing code directly in terms of inl,inr,fst,snd
00:20:42 <skew> sethk: it works, but it's not the nicest - you want to talk about the abstract type
00:21:06 <skew> sethk: plus, wrapping stuff up insulates your code if the monad definition ever changes
00:21:22 <Megzl> Cale: I'd help on Haskellbind.
00:21:24 <integral> http://research.microsoft.com/Users/simonpj/Papers/oo-haskell/ I think I was thinking of this
00:21:26 <Megzl> Someone setup the project, I'll put code in.
00:21:29 <basti_> hmm what happens to ()'s at runtime? do they exist in running code (take space, need processing time etc.)?
00:21:55 <skew> Megzl: heck, I got something similar for Python to the point where it worked some and segfaulted some in about a week
00:21:59 <Cale> sethk: skew is right -- you should wrap your transformed monad in a newtype and define the operations you want on it directly (probably making use of lift and such)
00:22:31 <skew> basti_: they can still loop or raise exceptions, right?
00:22:42 <basti_> i do not mean IO ()
00:22:46 <basti_> i really mean () values
00:22:50 <Megzl> Guys, take a look at boost::python.
00:22:52 <basti_> hmm
00:22:54 <basti_> ah
00:22:56 <Megzl> Python gets a lot of users cause of it.
00:23:03 <skew> x :: ();  x = error "hah, I raise an exception"
00:23:05 <basti_> yes right
00:23:06 * basti_ nods
00:23:07 <basti_> okay
00:23:12 <basti_> that answers this...
00:23:14 <integral> Megzl: a haskell version ain't just going to appear overnight just because it would be handy :)
00:23:16 <Megzl> http://www.boost.org/libs/python/doc/index.html
00:23:21 <skew> but I think strict ones get optimized out
00:23:31 <skew> and all the worker wrapper stuff might make them get stricter...
00:23:38 <basti_> hmmh
00:23:38 <skew> also, dead code elimination probably gets some
00:23:49 <integral> Megzl: out of interested, why didn't you pick python as your scripting language?  It's also got a very simple syntax like haskell
00:24:13 <skew> perhaps Megzl should have his users write their programs in epigram, then you don't have to worry about them running forever :)
00:24:14 <Megzl> integral: because, well, Psyco isn't exactly mature.
00:24:18 <Megzl> And python has a big memory footprint.
00:24:22 <Megzl> And a monolithic VM.
00:24:27 <Cale> skew: :)
00:24:28 <skew> Megzl: premature optimization is the root of all evil
00:24:30 <basti_> because i'm planning on doing some state computation, that is going to maybe return a load of tuples, lots of which would be (). I'm not totally sure my solution makes a lot of sense, though ;)
00:24:36 <skew> python seemed to work ok for EVE
00:24:40 <Megzl> skew: dude, I gotta run hundreds of these game objects
00:24:45 <integral> Megzl: But I thought those boost::python was what haskell needed?   Surely you don't want the haskell version to be just like that, if it's not right?
00:24:52 <Megzl> skew: loading 7mb python on each one isnt an option
00:24:56 <Megzl> 100k lua is an option.
00:24:59 <skew> they run hundreds of thousands of objects
00:25:03 <sethk> skew, Cale, so better practice is to create aliases and use lift/liftIO/whatever once
00:25:06 <skew> they paid the stackless guy for a while
00:25:07 <integral> Megzl: why do you need a whole new VM per object?
00:25:17 <Cale> Megzl: skew's idea is good -- have the users provide machine-checkable termination proofs before the server will run their code :)
00:25:22 <Megzl> skew: Ah. the stackless guy. Well that explains it.
00:25:33 <Megzl> Cale: noo.
00:25:35 <skew> Megzl: but the stackless guy has been pair...
00:25:36 <Cale> heh
00:25:44 <skew> Megzl: so you can just use his stuff
00:25:45 <Cale> sethk: yeah
00:26:00 <skew> Cale: sound like fun! We'd play it, I bet
00:26:08 <Megzl> integral: I don't need a whole VM per object, if each thread can be 100% safe/sandboxed/crashable.
00:26:09 <Cale> heh, yeah, I'd play that
00:26:33 <Megzl> Point is, lua doesn't even really have VM's -- each VM is a thread.
00:26:34 <skew> at least, as long as the logic for writing proofs is decently expressive (say, undecidably expressive?)
00:26:36 <integral> Megzl: well, surely python has exception handling?  I hope a VM can't crash any way other than throwing a catchable exception at least
00:26:39 <Megzl> lua doesn't even really have threads I meant.
00:26:56 <basti_> did we mention that haskell code crashes extraordinarily rare?
00:27:10 <integral> Megzl: hmm?  Doesn't that mean lua has to marshall things if you pass them between threads?
00:27:27 <basti_> for example, there are no type errors, as long as you avoid easily visible stupidities
00:27:30 <Megzl> integral: You use coroutines.
00:27:51 <integral> Megzl: hmm?  threads are implemented with coroutines?  I thought you just said they were VMs?
00:27:51 <Megzl> I'm not sure what you mean by Marshall.
00:27:59 <integral> I mean, you have to copy it from one heap to another
00:28:13 <integral> rather than just pass a pointer (or you use some kind of proxy)
00:28:19 <Megzl> Yes, the threads are done with coroutines.
00:28:30 <integral> But I thought each was a VM?
00:28:40 <Megzl> integral: That's how a lot of people use Lua.
00:28:44 <Megzl> integral: Each one a vm.
00:28:47 <skew> so then you need to run seprate VMs if you are afraid code will just loop
00:28:58 <skew> Cale:
00:29:01 <Megzl> What skew just said explains it.
00:29:15 <skew> Cale: I've thought an RTS with a strategy language would be cool
00:29:25 <Cale> :)
00:29:34 <Cale> skew: did you hear my idea for an RTS?
00:30:21 <Megzl> Coroutines isn't a very good option for unpredictable code.
00:30:41 <Megzl> Hence the use of multiple VM's.
00:30:44 <Megzl> Is what I meant.
00:32:34 <Cale> sethk: You get some idea of the operations/effects that you'd like to provide in a domain specific language inside Haskell, and then you can usually work out some combination of monad transformers that "overdoes" it (though sometimes it comes down to writing your own monads/monad transformers my hand).
00:32:43 <Cale> sethk: You then restrict those operations
00:33:12 <skew> Cale: no. I think shapr had some ideas along those lines too
00:33:32 <Cale> sethk: What you do is have a module defining that new type, and you hide the constructor (don't export it), so the only operations available are those which you expose.
00:34:01 <Cale> (this includes the instance of Monad and Functor, together with the operations specific to your DSL)
00:34:12 <skew> hence the quote "Function Ractive Arrows with Monadic cavariance, HOW CAN MY RTS FAIL"
00:34:15 <Cale> Then you have a language which is perfectly suited to your problem.
00:35:19 <Cale> skew: I want to do an RTS where you have one unit type which is essentially a blob of liquid, which you can direct the flow of, and it merges and splits as necessary.
00:36:07 <skew> (sic)
00:36:22 <Cale> spelling?
00:36:26 <Cale> oh
00:36:30 <Cale> in your quote
00:36:54 <Cale> The poor spelling is actually quite funny there :)
00:37:06 <basti_> cavariance yes? ^^
00:37:23 <basti_> when the blob-of-liquid type fails it gives a cavitation error huh?
00:37:24 <Cale> Sort of like they're so enthusiastic that they can't be bothered to type correctly at all.
00:37:38 <skew> oh, cavariance was my error
00:37:42 <basti_> .)
00:38:06 <Cale> oh
00:38:07 <skew> but
00:38:09 <Itkovian> JRegex seems like kinda very cool
00:38:13 <Cale> still
00:38:16 <Itkovian> but why the 'J'?
00:38:19 <skew> "Function Ractive Arrows" was original
00:38:22 <Cale> John
00:38:38 <dons> why "JHC" ?
00:38:43 <dons> J always stands for John!
00:38:47 <dons> hhehe
00:39:08 <Cale> heh
00:39:39 <Itkovian> ok, obviously.
00:39:50 <Itkovian> dumb question
00:40:18 <skew> I'm trying to design a distributed system library, but I'm not sure how to handle distributed databases
00:40:20 <Cale> why must every Haskell site use the same lambda favicon?
00:40:33 <skew> Cale: so you know it's a Haskell site
00:40:37 <Cale> hehe, hard to tell my tabs apart though
00:41:31 <sethk> Cale, skew thanks for the suggestions.  I'll play with it for a while and see what falls out.
00:41:51 <Cale> sethk: for a simplistic example, look at MonadRandom on the wiki
00:41:58 <Cale> that's a very restricted case
00:42:05 <skew> I've got a list of nodes, which processes run on which nodes, and how processes are connected
00:43:04 <sethk> Cale, skew I know precisely what has to be exported and how it should lay out.  My difficulty has been with figuring out how to use more than one monad at a time.
00:43:41 <sethk> skew, Tomorrow I'll be ready to start coding the bottom level.
00:43:55 <sethk> Cale, skew so thanks again.
00:44:08 <skew> the process types are wrappers around Haskell functions which take some Chans and do IO
00:44:26 <sethk> integral, sorry about mishandling the troller.
00:46:04 <skew> I've got code to go in your main that instantiates the right processes for your node, and builds marshalling processes to get data across the network if a link goes between nodes
00:47:03 <skew> any big problems so far?
00:47:48 <Cale> skew: um, nothing obvious :)
00:48:01 <skew> I want to be able to do distributed databases in this, where you call some function saying "I want a database holding this type, partitioned between these nodes, according to this hash function", and then it makes the infrastructure for you
00:48:38 <skew> making the process types and processes to implement the database is not to hard, the question is how to connect it up to anything else
00:49:45 <Cale> connect in what sense?
00:49:59 <skew> let a process make queries to the database
00:50:08 <skew> which means having channels to all the parts, in my framework
00:50:42 <skew> I'm thinking of having a process to manage the interface, which would be connected to all the instances, and take care of dividing up requests and reassembling results
00:51:57 <Cale> That would work... how many nodes are there and what does it involve to have a channel?
00:52:17 <skew> and having a special kind of process which is instantiated on each node where it is mentioned
00:52:22 <Cale> Presumably you're actually describing something with a hardware realisation?
00:52:28 <skew> so the dividing and rejoining is handled locally
00:52:34 <skew> nodes are supposed to map to actual boxes
00:52:51 <skew> but that's as close to hardware as it gets
00:53:15 <Cale> okay
00:53:17 <skew> I'm doing channels as TCP connections
00:53:26 <Cale> so channels aren't ethernet cables :)
00:53:42 <Cale> (not directly)
00:53:50 <glguy> anyone drinking?
00:53:59 <skew> the processes just see their Chan, the framework makes some extra threads to read from the Chan and serialize to the network at one end, and deserialize onto the Chan at the other end
00:54:22 <skew> I think I'll need to replace the Chan with some kind of bounded buffer eventually
00:54:35 <skew> but that's orthogonal
00:54:47 <Cale> okay
00:55:09 <skew> The easiest thing might be dropping the fixed communication topology
00:55:54 <Megzl> sethk, you're rather disrespectful, referring to me as 'the troller.'
00:56:32 <Cale> though the fixed communication topology thing is nice for some things
00:56:38 <skew> I did that in the first place for two reasons, to have an explicit description of the entire system somewhere rather than having connection information buried in code
00:56:40 <glguy> Megzl:  i agree, you troll
00:57:14 <skew> and on the other hand to have a simple model, talking over Chan, for the code to the processes
00:57:50 <Megzl> I think I stated my concerns in a straightforward way -- if having a particular set of concerns/considerations makes someone into a troll...
00:58:16 <Cale> Megzl: the way that you were posing the concerns was somewhat less than reasonable
00:58:20 <skew> Megzl: I think you are not entirely here in good faith, or a bit obtuse
00:58:22 <Megzl> Why, Cale?
00:59:30 <Cale> Regardless of whether you were aware of it, you were projecting a pretty sarcastic tone, and didn't seem to be considering people's ideas very carefully.
01:01:34 <skew> you went on a bit about luabind and boost::python, but it's easy to mistake the "yeah, I got it, move on" silence for the "huh? what? explain more" silence
01:02:32 <Cale> The fact that you claim to have no Haskell experience doesn't help either.
01:02:56 <ProfTeggy> Morning.
01:03:00 <dons> oh, this is very nice work: http://www.eff.org/Privacy/printers/docucolor/
01:03:03 <Cale> Morning
01:04:11 <Cale> Megzl: You're somewhat right, in that it would be nice to have better tools for constructing bindings to other languages. But if you write code in Haskell, you come to realise that this is not so straightforward. Bindings between imperative languages are trivial because they're largely all the same.
01:04:23 <Cale> Haskell is a different kind of language altogether.
01:05:18 <Cale> People are developing automated tools to write bindings, but I don't think an automatic result will ever be completely satisfactory to a Haskell user.
01:05:38 <dons> luckily we do have decent automated tools, and an excellent (is there any better?) FFI. so life is swishy
01:06:25 <Cale> anyway, I should get some sleep :)
01:06:55 <dons> Cale has spent all day awake in .. umm ... .au time..
01:07:14 <Cale> dons: heh, I've spent the last 2 days awake in .ca time.
01:07:21 <Cale> well, save a 2 hour nap
01:07:30 <dons> this can't be good
01:08:28 <Cale> I seem to be in this mode where I stay up for 2 days punctuated with a nap, and then have a long sleep
01:08:35 <Cale> and wake up in the afternoon
01:09:00 <dons> i've noticed a lot of really weird sleeping habits amongst the #haskellers
01:09:18 <dons> along with all the guys who go to sleep at 5..7am each day
01:09:20 <Cale> well, I have nothing regulating my hours right now
01:09:27 <Cale> it's 4am
01:09:36 <dons> nothing? you don't see the sun anymore?
01:09:46 <dons> or no classes and such?
01:09:51 <Cale> no classes
01:09:52 <skew> Cale: you're in ca?
01:09:54 <Cale> I'm done :)
01:09:56 <Cale> yeah
01:09:59 <dons> yeah!
01:10:13 <dons> so what now? 3 more years of phd or somesuch?
01:10:16 <skew> huh, my clock says it's 1am
01:10:21 <dons> @localtime skew
01:10:21 <mbot> Unknown command, try @listcommands.
01:10:24 <lambdabot> Local time for skew is Wed Oct 19 01:10:05 2005
01:10:28 <Cale> I should be looking at graduate schools and maybe some work in the interim
01:10:37 <skew> @localtime Cale
01:10:38 <mbot> Unknown command, try @listcommands.
01:10:40 <lambdabot> Local time for Cale is Wed Oct 19 04:10:16
01:10:50 <pesco> mbot: @shutup
01:10:51 <mbot> Unknown command, try @listcommands.
01:10:54 <pesco> :)
01:10:56 <dons> mbot, @quit
01:10:57 <mbot> not enough privileges
01:11:01 <Cale> mbot: @part #haskell
01:11:03 <dons> Cale :p
01:11:09 <skew> made a localtime instead of using @timein for people?
01:11:25 <dons> Cale, I give you lambdabot privs, it's only fair to return the favour ;)
01:11:40 <dons> skew, yeah :)
01:11:42 <Cale> oh, you did? Cool, sure.
01:11:54 <skew> I thought it was kind of cute
01:12:32 <dons> we considered the highly technical @localtime solns, and decided on something that *just works* :)
01:13:23 <integral> except when your IRC client doesn't know your real timezone ;)
01:13:34 <Cale> I haven't found any good parametric maps of the timezones in the world.
01:14:48 <Cale> It would be fun to write some code which gave the timezone at a given location by using that geometry
01:15:07 <musasabi> Is there a reason that Cabal's haddock command does not read package.buildinfo files?
01:15:08 <dons> yes, i agree. nice haskell code is to be expected
01:15:23 <dons> lomeX, hi!
01:15:27 <dons> learning haskell?
01:15:34 <Cale> <Cale> @dynamic-unload dice
01:15:34 <Cale> <mbot> module "dynamic" screwed up: unknown or static module
01:15:40 <Cale> why do I get that?
01:15:50 <Cale> (dice loads fine)
01:15:55 <dons> hmm.
01:15:59 <boegel> Cale: because it's srewed up ? ::)
01:16:01 <Cale> heh
01:17:26 <dons> works for me Cale
01:17:40 <dons> though I notice the debug output is doubled up atm
01:17:50 <dons> but that's a different bug
01:22:10 <Megzl> Hey, Skew.
01:22:15 <Megzl> Still there?
01:22:36 <Megzl> You asked why I can't use Python.
01:23:14 <Megzl> Python nor Stackless Python nor Psyco -- provide a sandboxes/protected VM
01:23:31 <Megzl> Since my users write the scripts, it *must* be protected. Lua is.
01:24:32 <Lemmih> Sounds great. So why do you wanna learn Haskell?
01:24:58 <Megzl> As for a sandboxed runtime VM, lua is the only option I'm aware of.
01:25:06 <Cale> dons: okay, it works now after distcleaning and recompiling
01:25:17 <Megzl> Besides C# on mono's vm.
01:25:25 <dons> ah, the .hi file must have been tweaked somehow
01:28:34 <Cale> Megzl: note that lambdabot's @eval can evaluate Haskell expressions, and we don't have to worry, because if the type is IO or something which could examine the system, then that's prevented from executing by the type system, and the general way in which IO is handled.
01:28:52 <Cale> @eval print "Hello"
01:29:14 <Cale> What is the machine that lambdabot is on doing right now? :)
01:29:16 <lambdabot> No IO allowed
01:29:22 <musasabi> But the Haskell way of doing it feels hacky.
01:29:23 <dons> linking 2 ghc's :)
01:29:30 <Cale> ah :)
01:29:31 <dons> musasabi?
01:29:51 <musasabi> dons: One has to check each library module included by hand in order to decide whether it is safe.
01:30:05 <dons> ah, good point
01:30:21 <dons> restricting to a safe H98 subset is nicer
01:30:38 <dons> but the libs get compiled with glasgow-exts, which breaks things
01:31:16 <musasabi> Also bounding space and time would be nice, but very hard.
01:31:32 <dons> well, time and space *are* bound
01:31:33 <musasabi> (the separate process trick of course works, but that is again a hack)
01:31:43 <dons> well, yes, ok :)
01:32:07 <dons> adapting this to run inside the ghc rts is left as an exercise ;)
01:33:41 <goron> @eval undefined
01:33:47 <lambdabot>  add a type signature that fixes these type variable(s)
01:33:50 <dons> oh no! don't!
01:34:04 <dons> @eval let f () = f () in f () :: ()
01:34:14 <lambdabot> Terminated
01:34:19 <dons> manzano$ uptime
01:34:19 <dons>  6:28PM  up 42 days,  2:36, 1 user, load averages: 3.91, 3.50, 3.01
01:34:37 <Cale> @eval undefined :: String
01:34:39 <lambdabot> Undefined
01:34:42 <eivuokko> lambdabot eval doesn't have access to unsafePerformIO, either?
01:34:49 <Cale> right
01:36:08 <musasabi> eivuokko: A more scary scenario is eval providing access to some lib which does unsafe ffi/unsafe array access/... (I don't think it currently does) and then using that for a hole.
01:36:26 <dons> @eval scanr (*) 1 [1..]
01:36:31 <lambdabot> Stack overflow
01:36:34 <goron> Still it runs on OpenBSD. What's the problem :D
01:36:35 <eivuokko> Yeah.  I am just not sure how eval is implemented.
01:37:03 <dons> hmm, did I write it up somewhere? not the sandboxing stuff.
01:37:18 <dons> maybe I should write a little thingy about sandboxing haskell code using hs-plugins
01:37:38 <dons> eivuokko, the basic eval idea is discussed in the paper "Plugging Haskell In"
01:37:54 <dons> and you can find the code in hs-plugins, with the lambdabot wrapper at:
01:37:55 <eivuokko> Was hs-plugins gpl'd?
01:37:55 <dons> @version
01:37:56 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
01:37:56 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:38:03 <dons> sure thing
01:38:05 <eivuokko> Yeah, I am just being lazy, sorry :o
01:38:10 <dons> @where hs-plugins
01:38:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
01:38:45 <dons> @eval  product [1..]
01:38:58 <lambdabot> Terminated
01:39:06 <eivuokko> Yeah, well, I am actually thinking I could provide way to write plugins with haskell at work.  (Dynamically linked)
01:39:06 <dons> @eval unsafePerformIO (return 42)
01:39:08 <lambdabot>  Not in scope: `unsafePerformIO'
01:39:26 <dons> eivuokko, ah! any more details?
01:39:29 <eivuokko> I did it via socket/stream but that was just too slow.
01:39:44 <dons> write plugins via a socket?
01:40:14 <eivuokko> dons, Well, it is work - commercial code.  It is messaging sort of framework written in C++.  Most of stuff is written as dynamically linked plugins.
01:40:30 <eivuokko> Via stream really :)
01:40:46 <eivuokko> Doesn't matter via subprocess or networked or windows ntfs streams etc.
01:40:46 <dons> ah, not haskell plugins though?
01:40:53 <eivuokko> Not at the moment ;)
01:41:25 <dons> yep, you can certainly use haskell plugins in foreign language apps
01:41:35 <eivuokko> So, there is hs-plugins style approach and just additional c+haskell wrapper for writing dynamic libraries.
01:41:35 <dons> we talk about this in detail in the above paper
01:41:40 <dons> (it was the main focus of the paper, in fact)
01:41:44 <eivuokko> Ah
01:42:10 <dons> you just need the ffi to call into haskell, which uses hs-plugins to load and eval the plugin, giving you back values to the app
01:42:33 <eivuokko> Ah, it is LGPL, so it would be doable.
01:42:44 <dons> here's a full example:
01:42:45 <dons>   hs_init(&argc, &argv);
01:42:45 <dons>   p = hs_eval_i("let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20 :: Int");
01:42:48 <dons>   if (p == NULL)
01:42:51 <dons>           printf("failed!\n");
01:42:53 <dons>   else
01:42:56 <dons>           printf("%d\n",*p);
01:43:00 <dons>   hs_exit();
01:43:04 <dons> even fancier than what you want, as the plugin is written at runtime :)
01:43:09 <eivuokko> Yeah
01:43:15 <eivuokko> That'd actually be much better.
01:43:22 <dons> that's a C program which does a bit of computation in haskell
01:43:31 <eivuokko> So it could be used to write semi-efficient scripts.
01:43:44 <dons> semi-efficient?
01:44:12 <eivuokko> Interfacing C++ classes conviently from Haskell will be a bit slower than native.
01:44:29 <dons> oh, there's an indirection or two, I guess
01:44:33 <eivuokko> (Yes, there is a reason why I don't want to use lue/python etc)
01:44:42 <dons> but the Haskell code is native code
01:44:43 <araujo> Hello!
01:44:46 <dons> so it runs at full speed
01:44:47 <eivuokko> I know :)
01:45:03 <eivuokko> Optimising haskell is as hard as writing in it C++ for us, tho.
01:45:15 <eivuokko> (or me, rather, others donät know haskell yet)
01:45:18 <araujo> Question here, ghc is written in Haskell only right?
01:45:27 <dons> ah, you mean writing fast haskell from the start, eivuokko?
01:45:28 <Heffalump> and the RTS uses a bit of C
01:45:41 <araujo> Ok
01:45:44 <dons> araujo, basically, yes.
01:45:45 <eivuokko> dons, No.
01:46:01 <eivuokko> dons, I want to write some simple stuff that is incredibly nice in haskell vs c++
01:46:18 <eivuokko> dons, but it still must be much faster than lua/python etc
01:46:20 <Heffalump> where is the inefficiency in interfacing with C++, OOI?
01:46:34 <dons> ghc -O should almost always be faster than lua and pythong
01:46:41 <Heffalump> I can sort of see that needing to make C wrappers won't help, but I can't see a specific problem.
01:46:44 <eivuokko> dons, But haskell written that way is not as efficient as clean C++.  And maybe not debate about this...just my opinion.
01:47:04 <eivuokko> Yes, the point is, I am considering lua and python for these easy tasks as well, scripting.
01:47:42 <eivuokko> Yeah, I suppose not directly, but it is hard to beat template expresisonss that are optimised via c++ type system
01:48:13 <eivuokko> And I just won't do that for haskell, it's not worth it in short notice, and I don't know yet if haskell is worth it in the long run.
01:48:24 <eivuokko> But this is quality engineering...
01:48:26 <Heffalump> C++ template expression are basically Haskell type classes.
01:48:30 <eivuokko> lol
01:48:34 <eivuokko> No they are not.
01:48:37 <goron> Why would template expressions make it any faster?
01:48:58 <Heffalump> I won't dispute that you're likely to get much better runtimes from C++, cos of other factors, and the fact that most Haskell implementations don't duplicate code.
01:49:05 <Heffalump> But in terms of expressivity, they are roughly the same.
01:49:15 <dons> hi kmg!
01:49:18 <dons> learning haskell?
01:49:18 <Heffalump> goron: cos they all get instantiated and specialised at compile time
01:49:23 <kmg> yup !
01:49:32 <dons> welcome :)
01:49:36 <Megzl> And don't forget the expressivility of C++ templates + booost::mpl.
01:49:37 <goron> Heffalump: Couldn't Haskell do the same thing?
01:49:46 <kmg> is their any zlib and bzip2 bindings for haskell ?
01:49:50 <dons> yep
01:49:52 <kmg> thx !
01:49:54 <dons> two or 3
01:49:57 <Megzl> boost::mpl is a template programming language - it implements turing complete (plus much more) in pure compile-time code.
01:49:58 <Heffalump> yes, but apart from jhc+pragmas, no implementation does
01:50:00 <goron> Heffalump: Well, you just said so. Never mind.
01:50:07 <kmg> url ?
01:50:08 <eivuokko> Ok, see: exercise.  Use haskelldb, make query like this one guy had few days ago, where one of the fields can be null.  Make query with restrict notNull, not make type match that field cannot be null.  With haskell.
01:50:09 <Megzl> You can write all kinds of compile time type-programming code.
01:50:16 <dons> kmg, let me see..
01:50:30 <Heffalump> Megzl: and hopes that the C++ implementation doesn't impose the rule about 17 levels of unwinding :-)
01:50:32 <goron> You can do the same in Lisp too.
01:50:41 <Megzl> Heff,
01:50:42 <goron> But I don't see the advantage of Lisp over Haskell.
01:50:57 <eivuokko> Heffalump, it is just a guideline...
01:51:01 <skew> Heffalump: you can do stuff with pragmas in GHC too, I think
01:51:02 <dons> what's the canonical zlib binding guys? Heffalump?
01:51:06 <dons> there's one in FPS
01:51:08 <Megzl> -ftemplate-depth-100
01:51:09 <dons> @where fps
01:51:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
01:51:11 * Heffalump dunno, sorry
01:51:13 <eivuokko> Heffalump, if you adhered those guidelines of C and C++ it would insane :o
01:51:17 <Heffalump> Megzl: that's a GHC option too..
01:51:22 <Heffalump> s/GHC/gcc/
01:51:26 <Megzl> yeah.
01:51:28 <Heffalump> and I didn't mean "too".
01:51:49 <Heffalump> goron: so how would you restrict it to be non-null in C++?
01:51:54 <skew> goron: for the macros, I think
01:52:50 <dons> kmg, but there's also http://www.sourceforge.net/projects/qforeign/
01:53:14 <dons> @where+ qforeign http://www.sourceforge.net/projects/qforeign/
01:53:15 <lambdabot> qforeign ~> http://www.sourceforge.net/projects/qforeign/
01:53:27 <dons> now, also, there's Igloo's native haskell zlib
01:53:45 <skew> Heffalump: I was talking to somebody about this the other day - I think you can almost model it with some fancy classes
01:53:51 <dons> and also a gzip binding in MissingH
01:53:54 <dons> @where MissingH
01:53:55 <lambdabot> http://quux.org/devel/missingh
01:54:37 <shapr> Megzl: Do you want to learn Haskell? I can point you to lots of introductory information.
01:55:16 <Heffalump> skew: well, you could also model it by cloning the Haskell type and making them both instances of the same type class.
01:55:20 <kmg> wow, thx ! thats a lot of libs - hv 2 do some r&d on it ;)
01:55:45 <dons> kmg: btw, you might be interested in:
01:55:46 <dons> @map
01:55:46 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
01:55:48 <dons> :)
01:56:08 <dons> feel free to add your coords ;)
01:56:15 <dons> anyone else too, while I'm at it
01:56:38 * Heffalump needs moving to Cambridge on that.
01:56:46 <Heffalump> and you should do a Google maps thing for it :-)
01:56:57 <dons> Heffa, yeah we have an EVIL PLAN!
01:57:05 <Heffalump> looking up lat/long is a real pain otherwise
01:57:06 <dons> in true google style
01:58:59 <kmg> hmmm only one other person from india
01:59:11 <kmg> show the lack of FP in CS courses
01:59:50 <dons> yeah :/ how did you come to learn haskell?
02:00:56 <kmg> i was trying to write a MIME parser -> ... -> pugs -> haskell :)
02:01:14 <dcoutts> yay, another convert via pugs!
02:01:29 <dons> @karma+ autrijus
02:01:30 <lambdabot> autrijus's karma raised to 4.
02:01:48 <autrijus> :)
02:02:47 <tromp> @karma+ autrijus
02:02:47 <lambdabot> autrijus's karma raised to 5.
02:02:53 <tromp> morning, folks:)
02:05:50 <autrijus> yo tromp.
02:06:43 <kmg> hi ramkris
02:09:49 <ramkrsna> hi kmg
02:09:59 <kmg> u from blr ?
02:10:07 <ramkrsna> yeap
02:10:10 <kmg> i m from chennai !
02:10:15 <ramkrsna> cool
02:12:22 <tromp> how do i get added to HaskellUserLocations?
02:13:11 <tromp> i dont have permission to edit the wiki
02:13:20 <musasabi> tromp: anyone can edit the wiki.
02:13:30 <boegel> tromp: add ?action=edit
02:13:49 <tromp> You are not allowed to edit this page.
02:14:24 <kmg> go to UserPreferences
02:14:28 <kmg> and create a profile
02:14:30 <boegel> tromp: log in then
02:15:01 <tromp> oh, ok:)
02:18:08 <tromp> hmm, getting edit conflicts
02:22:01 <tromp> ok, i seem to be added now, but my name is not visible on the map?!
02:22:49 <dons> after you add your details, the image gets updated once every 3 hrs, or earlier if you ask me
02:23:05 <dons> tromp, so you just added your details?
02:23:21 <dons> bbk
02:23:35 <tromp> oops, i put myself out of order:(
02:24:56 <tromp> will have to wait till page is editable again
02:30:13 <araujo> The IO action only can be called from main?
02:31:19 <dons> no, you can have values of IO type anywhere (as long as the types match)
02:32:28 <araujo> mm...
02:32:40 <araujo> I must be mis-interpreting the dos then.....
02:33:07 <araujo> There is really only one way to "perform" an I/O action: bind it to Main.main in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the IO monad and called at some point, directly or indirectly, from Main.main.
02:33:25 <araujo> What exactly means that?
02:33:27 <musasabi> @type unsafePerformIO
02:33:32 <lambdabot> bzzt
02:33:44 <musasabi> (that is an another way of running IO)
02:34:06 <musasabi> and then there is unsafeIoTo{St, STM, ...}
02:35:03 * araujo afraid of using a function with the 'unsafe' word on it
02:35:11 <dons> :)
02:35:25 <dons> it's a good naming convention, isn't it :)
02:35:35 <dons> even if you use it safely, people still want to remove it
02:35:51 <luqui> what are the unsafe functions?
02:36:52 <dons> ones where there are extra constraints you need to satisfy, beyond just the type, for the function to behave sanely
02:37:03 <araujo> dons, such as?
02:37:23 <dons> well, we have unsafeCoerce for example
02:37:44 <dons> that is only safe is you know somehow that the underlying data types have the same representation
02:37:58 <araujo> I see
02:38:01 <dons> so you need to have a proof of that somehow, to safely use unsafeCoerce
02:38:58 <dons> for unsafePerformIO, the constraints are that the action is free from side effects, and independent of its environment
02:39:18 <araujo> But according to what i pasted here, so is it true or what? , or i am missing something....
02:39:45 <dons> what you pasted was the newbie story, where we pretned there is no unsafePerformIO :)
02:39:58 <musasabi> unsafeCoerce seems to be the most evil of them all.
02:40:17 <musasabi> but it has nice uses (to coerce phantom types).
02:40:23 <dons> musasab -- but you can write coerce with unsafePerformIO!
02:40:25 <araujo> Ohh... and... is it good to pretend there is no unsafePerformIO? :-)
02:40:27 * luqui nightmares of reinterpret_cast
02:40:43 <MarcWeber> Is anyone familiar with fptools?
02:40:46 <dons> it is good to pretend, yes araujo, then you don't have to worry about the extra proofs
02:40:52 <araujo> *nods*
02:40:55 <musasabi> dons: the polymorphic IORef trick?
02:41:01 <dons> yeah
02:41:28 <Lemmih> MarcWeber: Somewhat.
02:41:32 * musasabi has gotten too many segfaults with them
02:41:40 <dons> yeah, they're evil
02:41:48 <dons> MarcWeber, yeah, I haev too
02:42:22 <eivuokko> Erm, maybe I am blind, but where are the licenses for libraries that come with ghc?
02:42:38 <MarcWeber> Lemmih, dons: running the configure script causes the error: config.status: error: cannot find input file: mk/config.h.in
02:42:39 <dons> in the src, they're BSD
02:42:46 <eivuokko> :-(
02:42:52 <eivuokko> Major pain to check that.
02:43:08 <dons> find . -type f -exec head -10 | less :)
02:44:01 <Lemmih> MarcWeber: The you pull the repos correctly?
02:44:01 <eivuokko> Hehe
02:44:04 <dons> the ghc libs are used in many commercial projects
02:44:36 <eivuokko> That is hardly valid argument for licenses being valid.
02:44:43 <eivuokko> Sorry ;)
02:44:47 <MarcWeber> Where does this belongs to? You are right that I'm still trying to compile hdirect. Sigbjorn Finne told me to download the whole thing..
02:45:01 <eivuokko> I am just checking around a bit that there is no suddeen annoyances.
02:45:10 <MarcWeber> Lemmih: I think so. I did cvs co fptools
02:45:18 <dons> sure, but other's have checked the src, and they had the same concerns :)
02:46:08 <Lemmih> MarcWeber: You probably want to checkout fpconfig and then hdirect.
02:46:11 <dons> oh, did you check fptools/libraries/base/LICENSE ??
02:46:28 <eivuokko> dons, no, I am reading documentation.
02:47:01 <MarcWeber> Lemmih: hdirect is a subdirectory of fptools
02:47:10 <dons> each package has a LICENSE file
02:47:27 <dons> which you can check, but they should all be BSD
02:47:31 <eivuokko> Hmmm, cool.
02:47:35 <Lemmih> MarcWeber: Yeah.
02:47:38 <eivuokko> Thanks a lot, I will check that now.
02:49:26 <eivuokko> I will probably not use hs-plugins btw.  I need to link with ms c++ compiler, and at first phase hs-plugins brings zero advantages.  If I get few pieces of beautifull haskell into production environment, maybe check situation again :)
02:50:19 <dons> sure, it's non-typical problems that need hs-plugins
02:50:37 <Lemmih> MarcWeber: http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
02:51:02 <Lemmih> (pulling hdirect inst
02:51:17 <skew> dons: how clever can hs-plugins be about reloading code?
02:51:21 <Lemmih> (just pull hdirect instead of ghc and the libraries)
02:52:13 <dons> skew, how clever would you like it to be?
02:52:47 <skew> can you do something like the Erlang system where you bring in new definitions, and after a while kill off anything still using the old definitions?
02:53:23 <skew> without keeping track yourself, that is
02:53:53 <musasabi> I can replicate the sparc error I had yesterday even with GCC 2.95.3.
02:54:18 <skew> though keeping track yourself and dlopen is enough for dealing with something like a server that spawns lots of short-lived request handlers
02:54:53 * shapr boings crazily
02:55:03 <dons> it's totally user code, no rts support. so you can't automatically kill off stuff
02:55:32 <skew> rts support would be a bit tricky
02:56:00 <skew> I suppose the best place would be in gc, turn pointers to code in the library you want to kill into pointers to functiosn that just raise error
02:56:02 <dons> it would be interesting to attch unload' finazliers to regions of memory, and when the GC says that code is no longer referenced, the finalizer gets run.
02:56:17 <shapr> Does region allocation work like that?
02:56:23 <dons> oleg suggested suuch a scheme at the haskell workshop
02:56:31 <dons> no, i overloaded the term 'region'
02:56:50 <dons> you don't need a GC at all with region allocation
02:56:56 <shapr> oh
02:56:57 <skew> I'm thinking more of turning thunks that depend on the code to be unloaded into thunks that raise an error
02:57:08 <skew> rather than waiting until they are all forced
02:57:15 <dons> ah, that's interesting.
02:57:32 <eivuokko> That sounds dangerous
02:57:44 <dons> another way it to make data types strict in plugins, then you know they're eval'd
02:57:49 <skew> but I guess a few extra copies of a library wouldn't take up too much memory
02:58:10 <dons> no one has noticed issues yet, but it may be eventually a problem for someone
02:58:16 <dons> in which case we'll have to think more about it.
02:58:16 <skew> dons: I don't think that stops you from building thunks whose evaluation will call plugin-loaded functions
02:58:33 <skew> I'm thinking long-running server here
02:58:36 <dons> ah, sorry, I misunderstood your point
02:58:53 <skew> what were you thinking?
02:58:53 <kosmikus> earthy: is johan away?
02:58:56 <dons> i was thinking about the problem of unloading code, where data created by that code isn't yet evald
02:59:11 <skew> yeah, that's the problem I'm talking about
02:59:12 <earthy> kosmikus: not that I know of
02:59:13 <dons> so you throw away code before you've actually run it
02:59:23 <earthy> he might not be in his office, but the lights were on when I got in this morning
02:59:30 <skew> but you can still have thunks that will use the plugin functions, even if the data is all strict
02:59:36 <dons> right.
02:59:41 <dons> partial apps and such
03:00:22 <musasabi> dons: If one uses fork & exec in the upgrade (and passes the state via a pipe or temporary file) won't that solve the problem?
03:00:35 <dons> unsafeUnload , skew *
03:00:37 <dons> ;)
03:01:09 <dons> musasabi, yeah. you somehow eval the state, right? and wipe all code
03:01:15 <skew> if you have a server with lots of reliability, it pretty much has to have versions running on several computers anyways, so you could probably just restart them one at a time if you've accumulated enough runtime changes that the memory adds up
03:01:23 <dons> that's the yi paper strategy, anyway.
03:01:34 <shapr> Hm, I should start asking for TMR articles... who's up for writing something?
03:01:44 <shapr> Megzl: Want to write a TMR article about C++ vs Haskell?
03:01:54 <musasabi> dons: does Yi do this?
03:02:11 <skew> except if you're using something like continuous migration under Xen it might be more confused
03:02:16 <shapr> Lor: Want to write about proof carrying code in Haskell?
03:02:18 <dons> well, we have a trick to serialise the state, and throw it over to the static core
03:02:24 <dons> which sounds like your idea (?)
03:02:43 <Lemmih> shapr: I don't think he has ever written a single line of Haskell.
03:02:44 <shapr> metaperl: Want to write about Haskell Nifty Tricks?
03:02:49 <skew> not that Xen does continous migration, but it's an obvious tweak to the live migration stuff
03:02:52 <shapr> Lemmih: Yes, but this should help motivate him :-)
03:03:04 <shapr> Lemmih: Hey, you want to write something?
03:03:20 <dons> ah, though you want to totally tear down the addr spacce, musasabi!
03:03:24 * shapr looks around for authors to pick on...
03:03:33 <dons> sorry, I missed the fork&exec bit
03:03:34 <shapr> I think I'll write part 2 of Software Testing in Haskell
03:04:00 <dons> so take the state, Yi-style, and tear down and reset the addr space, then inject the state back in.
03:04:10 <dons> then all should be fine and swooshy :)
03:04:54 <dons> kind of like running the ap over @eval, but with a typeful state pipe between the two processes
03:05:10 <shapr> Sounds like a monad.
03:05:23 <dons> hmm
03:05:53 <dons> maybe it is
03:06:08 <dons> with the whole addr space as state :)
03:06:21 <Lemmih> shapr: I'm not much of a writer. Even the HCAR entries are causing me problems (:
03:06:37 <dons> oh, reminds me, when was the deadline on that?
03:06:41 <dons> and who's writing the hIDE entry?
03:08:02 <skew> dons: hs-plugins will let you load multiple versions of a library, right?
03:08:08 <musasabi> dons: The idea is 1) serialize the state to the static core, 2) fork and exec a new static core, 3) pass the state to the new static core, 4) worry about file descriptors, 5) load plugins, 6) only new plugins are loaded.
03:08:28 <shapr> Lemmih: You definitely can produce content. If you write stuff, I can improve the grammer/spelling/whatever.
03:08:37 <skew> musasabi: what's the fork and exec for?
03:08:46 <dons> wiping all the old code
03:08:50 <musasabi> skew: to get rid of the old plugins code.
03:08:55 <dons> since the ghc rts won't do it for us
03:09:02 <dons> but we know it is safe, so hack away!
03:09:05 <skew> oh, that's how Yi works now?
03:09:08 <dons> yeah, musasabi, I like this :)
03:09:12 <shapr> w00, real Erlang hot upgrading!
03:09:12 <dons> skew, not quite.
03:09:15 <dons> no fork&exec
03:09:23 <dons> you get the hot update, but the old code sticks around unused
03:09:59 <skew> so the old code hangs around even though you restart the whole system
03:10:14 <musasabi> yes.
03:10:15 <dons> what do you mean "the whole system??
03:10:24 <dons> the whole userland system, yes.
03:10:28 <skew> yes
03:10:31 <dons> the rts, no. we don't restart it :)
03:10:40 <musasabi> ELF does not support a dlunload functionality so it would have to be hacked...
03:10:52 <musasabi> *undynload
03:11:04 <skew> I was thinking that old code sticking around would only be an issue if you wanted to incrementally upgrade the user code
03:11:24 <dons> nah, the old code is unlinked, but still takes up space
03:11:35 <skew> so some processes that are running the old code finish handling their client, but new processes get the new code
03:11:51 <dons> yes, you can do that now if you like
03:11:59 <skew> which makes it obviously tough to decide when to unload the old code (if that's possible with ELF and all)
03:11:59 <dons> but it's not very clean
03:12:19 <skew> more difficult, less downtime
03:13:00 <skew> but you could probaly make it relatively clean with a call by name function, that looks up a function from the symbol name again
03:13:09 <skew> and just make sure to recurse through that every so often
03:13:16 <skew> much like it works in erlang
03:16:17 <dcoutts> Lemmih, I can help review & improve an hIDE HCAR entry if you start writing it :-)
03:16:54 <skew> well, erlang looks for new code when you make a call that's fully qualified by module name
03:17:06 * kosmikus is pleased to see that people are working on their HCAR entries ...
03:17:31 <goron_> Anyone with a clue of how I can add text in a math mode in Latex?
03:17:51 <MarcWeber> same result. Will have lunch now
03:17:51 * dcoutts is also trying to get Gtk2Hs 0.9.10 out before HCAR
03:18:09 <skew> goron_: normal text inside math stuff? \mbox{text}
03:18:12 <musasabi> Got 6.2.1 working on the same Solaris machine.
03:18:35 <int-e> goron_: \mbox{text} works for me
03:18:49 <goron_> skew: Well, actually I want an equation with text above it, that explains why a certain operation can be done.
03:19:26 <goron_> If I use multiple \begin{equation} the numbers don't increment.
03:19:39 <skew> I think it's time to go looking for a style that already does it, then
03:19:53 <skew> though the full generality of the theorem enviroment might cover your case
03:20:10 <goron_> Or shouldn't I explain it in that location?
03:20:34 <sieni> goron_: also \text{foo bar baz} works
03:20:44 <sowhat> does anyone know if template haskell works in ghc-6.4.1? ":t reifyDecl" doesnt work if i start ghci -fth -fglasgow-exts
03:21:01 <skew> reifyDecl isn't really a function, I think
03:21:08 <goron_> sieni: It doesn't in \begin equation. Where does it work with a number of equations?
03:21:10 <shapr> @index reifyDecl
03:21:11 <lambdabot> bzzt
03:21:19 <skew> It's like a piece of syntax
03:21:23 <Lemmih> @type Language.Haskell.TH.reify
03:21:29 <lambdabot> Language.Haskell.TH.Syntax.Name
03:21:29 <lambdabot> -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Info
03:21:29 <tromp> http://www.haskell.org/hawiki/HaskellUserLocations takes forever to become editable...
03:21:55 <skew> hmm
03:22:03 <goron_> sieni: Well, it does, but it places it inline.
03:22:06 <skew> I guess it is.
03:22:15 <goron_> sieni: I want it to be above the formula.
03:22:25 <sieni> goron_: ahh
03:22:39 <goron_> sieni: And newlines don't seem to work in \text inside equation.
03:24:24 <sieni> hmm... i've done some stacking thingies, but can't remember how they worked...
03:25:14 <shapr> tromp: huh?
03:25:15 <sieni> Do you want the text above some specific part of the equation or "just above"
03:25:40 <goron_> sieni: the center would be nice.
03:25:44 <shapr> ohh
03:26:33 <sieni> goron_: A moment
03:27:49 <goron_> Ideally I would like to be able to do: <text><equation with number on the right><text><equation with number on the right> etc.
03:27:51 <sowhat> TH: yes, but it returns <interactive>:1:0: Not in scope: `reifyDecl' even if i load the TH module (:m + Language.Haskell.TH.Syntax)
03:28:06 <goron_> With text the line above <equation>
03:28:38 <bourbaki> moin
03:29:05 <Lemmih> sowhat: There is no 'reifyDecl' anymore.
03:30:29 <sowhat> Lemmih: unlike it is written in http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html ?
03:30:59 <Lemmih> sowhat: That information is way old (:
03:32:43 <sowhat> Lemmih: like most info on templ haskell i believe :( :( But reifyDecl does work on 6.2.2
03:33:11 <Lemmih> 'reifyDecl' has been replaced with the more general 'reify'.
03:34:34 <musasabi> It seems that it is impossible to compile Cabal with GHC 6.2.1 (panics with rename/RnSource.lhs:213: Non-exhaustive patterns in function checkModDeprec)
03:34:38 <musasabi> next 6.2.2
03:36:39 <shapr> autrijus: Your Visual Basic talk is way cool!
03:37:05 <shapr> Lemmih: Want to write a short Template Haskell tutorial/doc for the next TMR? :-)
03:37:57 <sieni> goron_: use "gather" environment in amsmath package
03:38:35 <sieni> goron_: \documentclass{article} \usepackage{amsmath} \begin{document} \begin{gather} \text{foo bar baz}\notag \\ x = \frac 52 \end{gather} \end{document}
03:39:43 <sieni> (I just got a copy of Latex Companion today from Amazon :-)
03:41:04 <goron_> sieni: I assume it's a good book?
03:41:47 <goron_> sieni: thanks, it works.
03:41:48 <sieni> goron_: Yes, and a new edition came out last year
03:42:22 <sieni> goron_: if you are planning of using latex heavily, I would recommend obtaining a copy
03:42:42 <Marios> hello, im trying to configure hat but im not doin a good job can u give me some help? im using ghc
03:45:00 <Lemmih> Does Hat work with GHC?
03:45:43 <pesco> Isn't hat backend-neutral?
03:45:59 <pesco> I.e. just a language transformation?
03:46:16 <pesco> So IIRC, it should work as long as you don't rely on language extensions it doesn't support.
03:47:59 <Marios> yes it works with ghc, trying to follow the instruction from webpage but they r not very clear
03:51:26 * SamB wonders how you would run things in a particular thread. envisions sending imperatives across a channel or something like that...
03:53:56 <SamB> hmm, if the program really terminates when the main thread exits, why does GHCi not seem to do that...
03:54:21 <dcoutts> SamB, does it not?
03:54:53 <dcoutts> SamB, and yes, you can use techniques like posting IO actions to a channel that is being read by another thread.
03:55:08 <dcoutts> I use that technique in the hIDE gui
03:55:41 <Lemmih> @type \c -> Control.Concurrent.forkIO $ Control.Concurrent.getChanContents c >>= sequence_
03:55:51 <lambdabot> forall a.
03:55:51 <lambdabot> Control.Concurrent.Chan.Chan (IO a) -> IO GHC.Conc.ThreadId
03:57:41 <SamB> dcoutts: which file should I look in to see it?
03:58:38 <dcoutts> SamB, hIDE/plugins/ideShell/src/Hide/IdeShell/MainWindow.hs, see the CmdQueue abstraction
04:00:42 <sowhat> how would i get the same result as reifyDecl? reify needs a Name value. For instance i would like to see the strucutre of the Maybe datatype.
04:04:19 <SamB> hmm, not bad...
04:04:46 <SamB> though for some reason I am so blind that I needed to use GHCi just to find the definition of CmdQueue...
04:06:03 <Igloo> sowhat: reify ''Maybe or something IIRC
04:06:35 <Igloo> Or reify (mkName "Maybe") ought to work too
04:07:36 <tromp> shapr, can you edit that page?
04:07:46 * SamB wonders how to send back answers...
04:08:05 <tromp> oh, wait, there's an edit link at the bottom too
04:10:05 <SamB> dcoutts: so, do I have to LGPL my code if I steal that?
04:12:52 * SamB changes newCmdQueue to have type (IO st) -> IO (CmdQueue st)
04:17:09 <dcoutts> SamB, I don't think those 4 functions + 1 type could qualify for copyright protection on their own.
04:17:27 <SamB> ok, cool ;-)
04:17:38 <dcoutts> there's only a limited number of ways of doing what that code does
04:20:53 <dcoutts> dons, ping
04:21:25 <SamB> does it seem woefully inefficient to create an MVar to use just once?
04:25:35 <dcoutts> SamB, no that's ok
04:27:36 <Igloo> Depending on what you mean by "once" you might just want an IORef, though
04:27:44 <SamB> @pl (\st -> (cmd st >>= putMVar var x))
04:27:45 <lambdabot> (putMVar var x =<<) . cmd
04:28:04 <SamB> Igloo: well, I want the blocking
04:36:16 <SamB> hmm, whats this service_loop thing in GHC.Conc?
04:37:10 <musasabi> It is used for select(2) and timeouts with -threaded on unix.
04:37:27 <musasabi> (and select is used for IO)
04:40:18 <Lemmih> Good night, #haskell.
04:40:26 <dcoutts> @localtime Lemmih
04:40:29 <lambdabot> Local time for Lemmih is Wed Oct 19 13:42:50 2005
04:40:46 <SamB> huh?
04:40:50 * dcoutts doesn't understand Lemmih's sleep patterns
04:41:07 <SamB> why does he call it night if it is 1 in the afternoon?
04:41:24 <dcoutts> maybe he's working the night shift :-)
04:42:01 <SamB> hmm, well I see that GHC.Conc uses throw-away MVars ;-)
04:43:33 <Lemmih> My sleep habits are completely free of external stimuli. (:
04:46:09 <SamB> musasabi: how much of this stuff gets used without -threaded?
04:49:23 <musasabi> SamB: not at all.
04:49:47 <musasabi> Then a different scheduler is used (that is written in C).
04:50:02 <musasabi> (and that is not the same thing as the RTS thread scheduler)
04:51:05 <musasabi> And on win32 different code is used...
04:51:48 <musasabi> The service_loop is quite bad from performance point of view - that was one of the reasons for network-alt.
05:11:12 <tromp> does linux provide a way to query available memory?
05:11:39 <musasabi> cat /proc/meminfo
05:13:51 <tromp> i mean, what's the best way to find out from a running program? is there a library call or syscall for that?
05:14:30 <tromp> reading and parsing such a file seems expensive if i'm gonna query it millions of times
05:17:43 <SamB> tromp: try it first!
05:18:07 <adept> tromp: "available memory" under most moder *nices is a very tricky subject.
05:18:37 <adept> tromp: on normal non-broken sustem, no memory should be available. Well, perhaps not more than 2-4-6 megabytes.
05:18:50 <adept> "available" == "free" here
05:18:55 <basti_> there is some thing to get advice about how to use memory
05:19:20 <adept> basti_: easy. free it up as soon as you can.
05:19:22 <tromp> i mean available as in: can be alloced without causing excessive swapping
05:19:37 <basti_> ^^
05:19:53 <adept> tromp: it is next to impossible to estimate this with any usefull degree of correctness.
05:20:37 <tromp> well, is there any way to check if the system is swapping badly?
05:21:28 <pejo> basti, madvise()?
05:21:31 <adept> tromp: start from thinking about other processes in the system which allocate memory too and can cause swapping on their own. Then add VM-level cache into picture. Then -sharing of the code segments. If your are not done at this point, consider various swapping and allocation strategies and allow for SMP systems. If you still want to think about memory at this point, you should probably join the kernel team :)
05:21:40 <basti_> pejo:
05:21:42 <basti_> whoops
05:22:01 <basti_> pejo: yes i thought thats what it was for. turned out not to, though
05:22:01 <basti_> ;)
05:22:07 <adept> tromp: one can observe "vmstat 1" and try to make guesses on the basis of "si"/"so" values
05:22:21 <pejo> basti, "madvise - provide advice to VM system"?
05:23:14 <adept> pejo: if one thinks that it could manage memory better than OS - why use OS in the first place? :)
05:23:16 <basti_> pejo: ?
05:23:43 <pejo> basti, hm, you want it the other way around, get advice from the system?
05:23:55 <neologism> madvise is fo wiring memory etc.
05:24:20 <basti_> pejo: i don't. tromp wants to, yes.
05:24:43 <pejo> adept, I agree with what you're saying.
05:24:55 <dons> dcoutts, pong
05:25:17 <dcoutts> dons, src/Yi/UTF8.hs:117:1: lexical error
05:25:17 <tromp> is there a simple call that can tell me the system is swapping significantly?
05:25:27 <adept> tromp: define "significantly"
05:25:39 <dcoutts> dons, I was having trouble building yi. That one looks like a missing -cpp somehwere
05:26:06 <dcoutts> dons, we've made some incompatbile changes to gtk2hs in recent days and I was updating yi
05:26:37 <adept> tromp: consider, that such system call should probably collect stats over the internal VM structures, causing them to update and causing more swapping in the process :)
05:26:38 <tromp> i mean, the cpu spends at least half the time waiting for swaps
05:26:38 <dons> the lexical error  I think I fixed
05:26:47 <dons> missing Cpp in .cabal for yi-static
05:26:48 <dcoutts> dons, the event record names are no longer short forms like "x", "y" but "eventX", "eventY". The former clashed with too many things.
05:27:01 <dons> right, someone reported this earlier.
05:27:04 <dons> Cale.
05:27:06 <dons> i'll update
05:27:14 <tromp> maybe i can tell from getrusage()?
05:27:18 * dcoutts prepares to darcs pull
05:27:37 <adept> tromp: CPU does not spend time waiting for IO nowadays, DMA transfers take care of that.
05:27:53 <adept> tromp: what is the task you are trying to solve?
05:28:27 <tromp> see http://homepages.cwi.nl/~tromp/go/legal.html
05:29:22 <tromp> i'm processing 200Gb of statespace divided over many files
05:29:56 <shapr> hoi goron
05:30:12 <shapr> tromp: What about building a lazy pipeline?
05:30:25 <shapr> Then you just keep as little in memory as possible, right?
05:30:25 <adept> tromp: yeah, what about a pipeline?
05:30:49 <tromp> the program needs memory to sort the data
05:31:28 <adept> tromp: the way i see it, you are building a looong list (no, i havent seen the sources) and then do "length" on it? good generator + foldr/build decomposition could probably transfer this into ... ah, you need sort.
05:31:31 <tromp> it reads in data, transforms it, and when memory is full, writes it out sorted
05:31:59 <adept> tromp: why sorted? :)
05:32:02 <tromp> currently i give maxsize as commandline argument
05:32:39 <tromp> because input records with same key need to be merged
05:33:35 <ndm> tromp, bucket sort?
05:33:37 <mflux_> funny, the seems to follow equation log(legal positions)/(n^2) =~ 1
05:33:45 <shapr> Sounds like an accumulating Data.Map, but you want it be only partially loaded because it's really big, right?
05:33:56 <mflux_> bucket sort, is it the same as radix sort?
05:33:56 <ndm> it might allow you to do it more efficiently, without the whole thing required for a sort
05:34:02 <ndm> mflux_: yeah
05:34:03 <tromp> i can only keep a few % of all state in memory
05:34:22 <ndm> you can always do bucket sort with temporary output files
05:34:28 <ndm> to reduce the in-memory size at any point
05:34:30 <tromp> i sort by using an ordered tree data structure
05:34:46 <shapr> You could build the tree on the filesystem.
05:34:56 <adept> tromp: but if you are going to allocate more than 1.5 x phys. RAM, then you are definitely in trouble.
05:35:16 <tromp> i'm using both cpus of a dual cpu system
05:35:17 <shapr> Is there some way to deal with partially loaded values in Haskell?
05:35:39 <tromp> but together they don't make good use of memory
05:35:47 <adept> shapr: yeah, tree fs structure like squid cache could help.
05:38:59 <adept> tromp: you said "because input records with same key need to be merged". so, how about having a dir/file structure, where dirname - somehash(key)?
05:39:29 <shapr> Yeah, that's what I'd suggest.
05:39:39 <shapr> It's a cheesy way to keep from loading the whole thing into memory at once.
05:40:57 <boegel> shapr: y0
05:41:06 <boegel> shapr: planning a new TMR for next month ?
05:41:11 <JohnMeacham> hmm.. I think always unboxing strict values in constructors is a good idea... at least in jhc. probably not as important in ghc though..
05:42:18 <shapr> If you're worried about the overhead of loading large files just to do a sorted insert of a few keys, you could have incremental moves. For example, keep unsorted key/value pairs in an inbox file, and either move the pairs one step down in the tree (or all the way if it's just as cheap) or pick up the inbox and do a whole bunch of sorted inserts.
05:42:26 <shapr> You could trigger on the size of the inbox, for example.
05:43:14 <shapr> boegel: I'd love to have another TMR, but I don't have any authors yet.
05:44:01 <tromp> there's billions of keys
05:44:06 <boegel> shapr: oh, too bad: (
05:44:15 <boegel> I guess everyone's busy as hell
05:44:23 <boegel> shapr: what have you been working on lately
05:44:37 <shapr> Paying work and FLM.
05:46:03 <tromp> hashing keys doesn't solve the sorting problem
05:47:44 <shapr> What about an inverted index or one of those other heavy duty terabyte database lookup structures?
05:48:33 <shapr> hiya CosmicRay, have you seen Frank Debussy's programming challenges?
05:48:34 <tromp> only way to sort huge files is by merging sorted files...
05:49:15 <CosmicRay> morning shapr, no I haven't
05:49:17 <shapr> tromp: Or you could cut the files into directories on the drive, put the keys into the right directories, and then build the sorted file in a single step.
05:51:02 <shapr> CosmicRay: http://www.frank-buss.de/challenge/ has a really nice Haskell solution.
05:51:23 <shapr> tromp: Would that not work?
05:53:04 <tromp> i don't understand what you propose. i have 200GB of data, currently stored as between 100 and 200 sorted files of 1GB-2GB each
05:53:14 <CosmicRay> shapr: oh btw, looks like someone beat me to it: http://shootin.sourceforge.net/
05:53:45 <CosmicRay> shapr: hmm, I have seen that somewhere before...
05:53:47 <tromp> i can read all files together and merge the data
05:54:52 <shapr> CosmicRay: Nah, that's not the Computer Language Beauty Contest, it doesn't focus on communication and elegance.
05:55:09 <CosmicRay> true
05:55:25 <shapr> tromp: As I understand it, you have all the entries starting with 'a' spread across all of those files, right?
05:55:44 <xerox> @Yow!
05:55:45 <lambdabot> This PORCUPINE knows his ZIPCODE ... And he has "VISA"!!
05:56:14 <tomaszz> tromp: what is the problem with merging? not enough disk space?
05:56:27 <shapr> tromp: If that's true, then I suggest moving all the entries starting with 'a' into their own directory, maybe entries/a/
05:57:45 <autrijus> shapr: thanks!
05:58:19 <shapr> tromp: Then all entries starting with 'b' move to entries/b/  ... if you need to load even fewer into memory, entries starting with "aa" go into entries/a/a/ ... then when all the entries are in the correct directories/file, you don't merge, you just concatenate in dir/file name order.
05:58:51 <shapr> tromp: Will that work?
05:59:49 * autrijus continues working on the Learning Haskell slides for tomorrow
06:00:33 <adept> tromp: and if the key ('a' in shapr's example) is too big, you could use "md5(key)" instead
06:01:23 <shapr> autrijus: Your presentations had me cackling with laughter last night, they're great!
06:01:34 <CosmicRay> shapr: got a url?
06:01:43 <shapr> @whereis autrijus
06:01:43 <lambdabot> Maybe you meant: where where+
06:01:47 <shapr> @where autrijus
06:01:48 <lambdabot> I know nothing about autrijus.
06:02:11 <shapr> @where+ autrijus http://use.perl.org/~autrijus/journal/
06:02:12 <lambdabot> autrijus ~> http://use.perl.org/~autrijus/journal/
06:02:34 <tomaszz> @help where
06:02:35 <lambdabot>  @where <key>, return element associated with key
06:02:43 <shapr> @where shapr
06:02:43 <lambdabot> I know nothing about shapr.
06:02:52 <shapr> @where+ shapr http://www.ScannedInAvian.com/
06:02:53 <tomaszz> @where lambdabot
06:02:53 <lambdabot> shapr ~> http://www.ScannedInAvian.com/
06:02:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
06:03:48 <shapr> CosmicRay: In the most recent entry on autrijus' journal.
06:05:02 <xerox> shapr: I do afree completely !!!
06:05:19 <xerox> *g, even
06:06:07 <CosmicRay> shapr: what does he use to publish those slides?
06:06:24 <xerox> CosmicRay: it is a XUL app, it does all your browser!
06:06:45 <CosmicRay> right, but does he just hand-edit it then?
06:06:58 <shapr> Click on the Edit button and look at the source
06:07:04 <xerox> Move the mouse upwards
06:07:07 <xerox> :D
06:07:57 <CosmicRay> xerox: thanks, I did discover that ;-)
06:13:06 <autrijus> shapr: thanks! :)
06:13:24 <autrijus> shapr: the "evolve or die" message got across -- I wasn't booed off stage -- so I'm happy :)
06:14:26 <CosmicRay> autrijus: that's really slick how pugs has multiple backends.  so it can really convert perl6 to javascript?
06:14:39 <CosmicRay> autrijus: how practical would it be to have multiple frontends?  say, a haskell frontend?
06:16:06 <autrijus> CosmicRay: it can really, yes.
06:16:10 <CosmicRay> or a python frontend?
06:16:14 <autrijus> CosmicRay: Haskell->PIL is probably not much fun
06:16:20 <autrijus> I'd rather Grin->ParrotPIR
06:16:20 <CosmicRay> heh
06:16:37 <autrijus> since Parrot is CPS and perfect for lazy
06:16:44 <CosmicRay> probably not, indeed.  though haskell->anything is probably not much fun ;-)
06:16:58 <autrijus> a ruby or python frontend would be a lot of fun yes.
06:17:28 <CosmicRay> I was just musing last week about the annoying lack of something akin to "eval" in haskell
06:17:42 <CosmicRay> unless one uses hs-plugins (not very portable) or pipes from hugs (annoying)
06:17:43 <shapr> hs-plugins has eval
06:17:43 * autrijus hands CosmicRay hs-plugins
06:17:54 <autrijus> not portable how?
06:17:57 <autrijus> it should be made core GHC ;)
06:17:58 <tromp> shapr: i wldn't want more than a million files, since the overhead wld become too large
06:18:09 <autrijus> or core cabal -- I suggested that to dons
06:18:10 <CosmicRay> autrijus: it only runs on platforms that have a registerized ghc build
06:18:18 <CosmicRay> autrijus: that is, only on platforms where ghci works.
06:18:20 <autrijus> yeah, there's that.
06:18:31 <CosmicRay> autrijus: so, for instance, it doesn't work on powerpc, alpha, sparclinux, etc, etc.
06:18:33 <autrijus> which reminds me I need to relook at wolfgang's powerpc code
06:18:42 <autrijus> and see if it's portable to aix
06:18:43 <CosmicRay> I happen to use powerpc and alpha
06:18:48 <CosmicRay> autrijus: that would be nice.
06:18:50 <shapr> tromp: Some filesystems have almost no overhead for small files, I think reiser4 is one of those.
06:18:54 <CosmicRay> I also happen to use that platform.
06:19:05 <CosmicRay> shapr: you are correct sir!
06:19:08 <autrijus> CosmicRay: yeah. but Haskell RTS is not really a VM
06:19:16 <CosmicRay> right
06:19:17 <autrijus> so we can't script it the way IronPython people do
06:19:19 <Igloo> CosmicRay: Can you easily try a (fairly long running) build on Debian/powerpc?
06:19:22 <shapr> tromp: In any case, the general idea is to incrementally merge your files rather than loading them entirely into memory.
06:19:40 <tromp> i never load a whole file in memory
06:19:46 <CosmicRay> Igloo: presently my only powerpc box has macos x on it only, I'm afraid
06:19:51 <Igloo> OK
06:20:14 <tromp> the merging of a 100 files is not what takes memory
06:20:27 <xerox> CosmicRay: ghci does not work on ppc ?!
06:21:00 <CosmicRay> ppc/linux.  that's my understanding anyway.  I haven't tried that one personally so I can't say for sure.
06:21:06 <CosmicRay> I think ghci is supported on os x.
06:21:17 <CosmicRay> I *have* tried alpha and aix personally ;-)
06:21:28 <tromp> the prob with the nested directories is that the files still need to have a few K records
06:21:43 <CosmicRay> tromp: what are you trying to do?
06:21:57 <tromp> and then adding records puts them out of order
06:22:14 <tromp> cosmicray, see http://homepages.cwi.nl/~tromp/go/legal.html
06:22:51 <earthy> ghci works on os x
06:22:55 <earthy> I regularly use it
06:23:02 <CosmicRay> tromp: so you're trying to store....   legal postions?
06:23:04 <tromp> another reason to keep files sorted is to save space
06:23:07 <shapr> tromp: Ok, I don't understand the problem then, what takes all the memory?
06:23:22 <CosmicRay> tromp: this may be a naive suggestion, but would sqlite3 fit here?
06:23:58 <tromp> keeping transformed data in a sorted tree takes memory
06:24:37 <tromp> maybe you want to read the paper on that webpage
06:25:46 <tromp> they keys are logically 64 bit
06:26:03 <tromp> but because i keep files sorted, i only have to store increments
06:26:10 <tromp> which average about 9 bits
06:26:59 <tromp> i don't have enough diskspace to store all 64 bits of the key:(
06:33:58 <shapr> Maybe you could setup GFS (the cluster filesystem) on all your handy Linux boxes?
06:34:30 <shapr> Then you could mooch drivespace off of them.
06:38:36 * adept tried to read source of "legal" and was drowned in C.
06:38:45 <shapr> legal?
06:38:46 <shapr> oh
06:41:30 <adept> shapr: that's what you were talking about for the last hour or so ;)
06:41:38 <shapr> CosmicRay: Silly question, when I put a query into isql on top of unixODBC, would the SQL need to match SqlRelay, FreeTDS, or the MS SQL Server endpoint?
06:43:39 <sethk> ODBC has its own SQL spec, presumably that's the one to use through an ODBC interface
06:46:36 <rep> morning
06:46:46 <tromp> each machine has to use its local disks or performance goes south:(
06:47:52 <tromp> actually our nfs is broken for 100GB+ files; we see occasional bit errors:(
06:47:57 <shapr> yow
07:02:27 <rep> 100GB files, heh
07:10:26 <JohnMeacham> woot. signifigant speedups with better argument unboxing in jhc.
07:11:18 <ndm> JohnMeacham: how much %?
07:25:30 <xerox> Who was playing with fib the other day?
07:36:57 <shapr> it's oh so quiet...
07:39:08 <ValarQ> it sure is
07:39:42 <arjanb> more people and less talk, that can only mean more code
07:40:10 <neologism> or wanking ;)
07:40:19 <neologism> or any other leisure activity ;)
07:40:47 <neologism> what do you think about ruby language?
07:44:09 <sylvan> neologism, I think it's untyped =(
07:44:23 <neologism> I mean - do you like the language ?
07:44:28 <neologism> I just discovered it and it seems fine
07:44:32 <neologism> (for an imperative language : ))
07:48:58 <autrijus> @pl \x -> x - 3
07:48:59 <lambdabot> subtract 3
07:49:05 <autrijus> lambdabot: thank you!
07:49:12 <autrijus> @pl \x -> x + 3
07:49:13 <lambdabot> (3 +)
07:49:34 <Igloo> Technically that should be (+ 3)
07:50:02 * Igloo wishes that would be fixed
07:50:02 <shapr> neologism: I think Ruby has better OO than Python, but the explicit END statements are painful. I *really* like significant whitespace.
07:50:20 <neologism> yes
07:50:26 <shapr> Igloo: fix it and submit a patch!
07:50:29 <neologism> but I really like it has (some) ho functions
07:50:50 <shapr> Yeah, but no real lambda.
07:51:03 <neologism> the most real you can get in an impretive language I think
07:51:27 <shapr> Well, Haskell seems like a fine imperative language to me :-)
07:51:41 <autrijus> haskell doesn't have "option strict off" :)
07:52:29 <neologism> what is imperative about language?
07:52:45 <autrijus> neologism: we have peek and poke
07:52:49 <Igloo> Presumably the author thinks it's a good idea, though. Anyway, it'd be easier for someone familiar with it to do it
07:52:51 <autrijus> just like GW-BASIC!
07:52:52 <neologism> hehe
07:52:56 <shapr> Is it good or bad to not have "option strict off" ?
07:53:06 <shapr> Igloo: author is TheHunter.
07:53:24 <autrijus> shapr: it's bad if you don't have any idea about your problem space until runtime.
07:53:39 <autrijus> which is admittedly not often, but sometimes.
07:53:43 <shapr> Can you give me an example?
07:54:27 <earthy> GW Basic
07:54:32 <earthy> man, that brings back memories
07:55:13 <autrijus> shapr: let's see... scripting a DOM tree interactively?
07:55:44 <autrijus> (aka Mozilla Venkman / DOM inspector)
07:56:51 <shapr> I still don't get it, but that's probably because I don't remember what option strict off does.
07:57:02 <autrijus> in Visual Basic, it turns all types into Dynamic.
07:57:04 <shapr> Too many years since I used it.
07:57:09 <autrijus> and coerce whenever needed
07:57:31 <autrijus> and raise (catchable/fix-and-continuable) exceptions when type error happens
07:58:31 <shapr> Could you do that with hs-plugins?
07:59:06 <shapr> ie. if your dynloaded code fails the check against the given signature, stop the program, popup an editor, fix the code, and ask hs-plugins to reload?
07:59:14 <autrijus> can you modify classes using hsplugins?
07:59:24 <autrijus> add more interfaces to Value (or Eq) at runtime?
07:59:38 <autrijus> add new variants to data declarations?
07:59:48 <autrijus> (as that's what dynamic language is all about)
07:59:48 <shapr> You could do that with the Yi bootloader trick.
08:00:00 <autrijus> which requires a save-world-and-restart
08:00:04 <shapr> yeah
08:00:05 <autrijus> which is generally nontrivial.
08:00:08 <shapr> true
08:00:36 <autrijus> but yes, if the bootloader trick, along with a nice robust freezer is is common use
08:00:46 <autrijus> that will go a long way toward makign haskell the finest dynamic lanugage.
08:01:06 <shapr> SerTH is a good freezer, but it's limited to Show => a
08:01:11 <autrijus> nod.
08:01:12 <autrijus> and TH.
08:01:19 <shapr> Yeah, that too.
08:01:30 <shapr> I have no idea how to serialize values outside of Show.
08:01:30 <autrijus> (which means it runs where hsplugins would run, which is okay)
08:02:44 <shapr> I've often wished I could connect hs-plugins and a network socket to get a distributed processing thingy.
08:02:49 <autrijus> aye.
08:03:24 <shapr> The biggest problem is transporting values outside of Show though. How do you transport a type? or a thunk?
08:07:03 * dcoutts_ feels dirty
08:07:09 * dcoutts_ has been teaching ocaml
08:07:35 * dcoutts_ goes for a cup of tea
08:07:45 <JohnMeacham> ndm: 5-10%
08:07:51 <integral> the garbage collecting would get painful too
08:08:08 <JohnMeacham> but instance methods are getting incomplete strictness info for some reason.. I will have to look into that.
08:10:08 <autrijus> shapr: there's a paper in ocaml setting in icfp proceeding that tackles that
08:10:56 <dcoutts_> JohnMeacham, it must be fun adding optimisations to your complier which make the complier optimise faster
08:13:07 <shapr> ooh, is it online?
08:13:36 <dcoutts_> xerox, you about?
08:15:32 <ValarQ> hello dcoutts_
08:15:49 <dcoutts_> hia
08:16:20 <dcoutts_> any windows gtk2hs users about? I've got a question about how you'd like the gtk2hs installer to work on windows
08:16:35 <ValarQ> dcoutts_: i got problems with my new gtk+ version
08:16:43 <dcoutts_> ValarQ, oh yes?
08:17:18 <ValarQ> dcoutts_: i installed 2.8.6, and now none of the gtk demo apps works
08:18:09 <dcoutts_> ValarQ, did you recompile anything else?
08:18:38 <dcoutts_> what is the error?
08:18:56 <ValarQ> dcoutts_: yes, glib, pango, gtk and then gtk2hs
08:19:14 <ValarQ> dcoutts_: "Could not find module `Graphics.UI.Gtk':"
08:19:59 <dcoutts_> ValarQ, and you're doing ghc --make {Demo}.hs -o {demo}
08:20:36 <dcoutts_> ValarQ, and running "ghc-pkg list gtk" shows that gtk is there?
08:20:37 <ValarQ> dcoutts_: yes
08:21:22 <ValarQ> dcoutts_: it does
08:21:25 <dcoutts_> what does this give: ghc-pkg describe gtk depends
08:21:31 <dcoutts_> oops
08:21:34 <dcoutts_> I mean...
08:21:37 <dcoutts_> what does this give: ghc-pkg field gtk depends
08:22:23 <ValarQ> dcoutts_: "depends: glib-0.9.9.5 cairo"
08:22:28 <dcoutts_> ah ha!
08:22:35 <dcoutts_> this is a problem
08:22:40 <ValarQ> ?
08:22:47 * dcoutts_ wonders how it ended up that way
08:23:02 <ValarQ> maybe i did something funny (shouldn't surprise me)
08:23:05 <dcoutts_> the "cairo" should be "cairo-0.9.9.5"
08:23:10 <dcoutts_> it's probably my fault
08:23:23 <dcoutts_> it's because the gtk package got registered before the cairo package
08:23:33 <dcoutts_> (that's the bit that is probably my fault)
08:23:47 <dcoutts_> and ghc-pkg does not complain, though it should
08:24:00 <dcoutts_> because when it's in that state it doesn't work :-(
08:24:22 <dcoutts_> so let me go check the build system to see why that might be happening
08:24:28 <ValarQ> nope, it doesn't complain
08:24:48 <dcoutts_> ValarQ, you can fix it on your pachine by re-registering the gtk package
08:25:01 <dcoutts_> ValarQ, assuming you installed to the default location you'd jsut do this:
08:25:02 <ValarQ> dcoutts_: which should be first?
08:25:20 <dcoutts_> ghc-pkg update /usr/local/lib/gtk2hs/gtk/package.conf
08:25:27 <dcoutts_> oh no,
08:25:30 <dcoutts_> ghc-pkg update /usr/local/lib/gtk2hs/gtk.package.conf
08:25:57 <ValarQ> dcoutts_: http://arda.no-ip.org/gtk2hs-0.9.9.5.ebuild
08:26:14 <ValarQ> dcoutts_: src_install() -> ghc-setup-pkg ...
08:26:15 <dcoutts_> ok...
08:26:26 <dcoutts_> ghc-pkg update /usr/lib/gtk2hs/gtk.package.conf
08:26:30 <ValarQ> dcoutts_: have i inserted them in wrong order?
08:26:31 <dcoutts_> as root
08:26:38 <dcoutts_> ValarQ, oh right, hmmm
08:26:48 <beelsebob_> everyone... what does this say? http://www.cs.kent.ac.uk/people/rpg/tatd2/yhcsb32.png
08:26:51 <dcoutts_> ValarQ, good point, mabe it's not my fault :-)
08:27:30 <dcoutts_> ValarQ, yes sadly you have. :-(
08:27:46 * dcoutts_ is relieved that it was not his fault
08:28:02 <dcoutts_> ValarQ, you need to register cairo after glib but before gtk
08:28:09 <thedward> beelsebob_: Yhc ?
08:28:15 <beelsebob_> good :)
08:28:17 <ValarQ> dcoutts_: ok
08:28:26 <thedward> it is awful tiny though
08:28:26 <dcoutts_> ValarQ, sorry, it's an easy mistake to make since ghc-pkg does not complain when it really should do so.
08:28:55 <beelsebob_> thedward: yeh... testing it for sucky windows icons
08:29:08 <dcoutts_> ValarQ, but you don't need to reemerge, just re-register the package
08:29:13 <ValarQ> dcoutts_: now the ghc-pkg describe gtk command works better
08:29:26 <dcoutts_> ValarQ, great, see if the demos work now
08:29:27 <ValarQ> dcoutts_: lists all kinds of funny stuff
08:29:33 <ValarQ> dcoutts_: it doesn't
08:29:43 <ValarQ> dcoutts_: Drawing.hs:12:10: Not in scope: `cairoCreateContext'
08:29:50 <dcoutts_> ValarQ,  ghc-pkg field gtk depends
08:30:06 <ValarQ> dcoutts_: depends: glib-0.9.9.5 cairo-0.9.9.5
08:30:14 <joelr> howdy
08:30:14 <beelsebob_> http://www.cs.kent.ac.uk/people/rpg/tatd2/yhcsb.pdf that's the vector version
08:30:46 <joelr> i have a silly windows issue
08:30:47 <joelr> Loading package network-1.0 ... linking ... done.
08:30:47 <joelr> *** Exception: getServiceEntry: does not exist (no such service entry)
08:30:52 <joelr> i connect thusly
08:31:31 <joelr> connect :: HostName -> Int -> IO Handle
08:31:31 <joelr> connect h p = connectTo h $ PortNumber $ fromIntegral p
08:31:31 <joelr> main = withSocketsDo $ do
08:31:31 <joelr> 	connect "10.0.0.1" 15667
08:31:31 <joelr> 	
08:31:33 <dcoutts_> ValarQ, so you re-emerged gtk2hs after updating gtk+ right?
08:31:39 <ValarQ> dcoutts_: yes
08:32:23 <dcoutts_> ValarQ, what does this give: echo ":b Graphics.UI.Gtk.Cairo" | ghci
08:32:36 <joelr> i don't see myself using any services
08:32:45 <ValarQ> dcoutts_: not much
08:33:24 <ValarQ> dcoutts_: no output from the :b command it seems
08:34:13 <dcoutts_> ValarQ, well for some reason it's not building the gtk/cairo integration stuff. That's usually because Gtk+ 2.8 is not installed.
08:34:23 <dcoutts_> ValarQ, but you said it is, so that's odd.
08:35:00 <dcoutts_> ValarQ, what does this give: pkg-config --modversion gtk+-2.0
08:35:12 <ValarQ> dcoutts_: 2.8.6
08:35:49 <dcoutts_> ValarQ, try building normally, without the ebuild.
08:35:58 <ValarQ> dcoutts_: ok
08:35:59 <shapr> dons: You've become DonS on the mailing lists, cool :-)
08:36:08 <dcoutts_> ValarQ, darcs pull; make maintainer-clean
08:36:40 <dcoutts_> autoreconf && ./configure --with-hcflags=-O0
08:37:02 <dcoutts_> ValarQ, then we can check exactly what it thinks it's doing
08:38:32 <ValarQ> dcoutts_: well, it finds the right gtk library and cairo library
08:38:45 <joelr> anyone on windows?
08:38:56 <ValarQ> dcoutts_: whats -O0 ?
08:40:26 <dcoutts_> ValarQ, that turns off optimisations, makes the build quicker
08:40:30 <dcoutts_> ok try this:
08:40:31 <dcoutts_> make gtk/Graphics/UI/Gtk/Cairo.chs
08:40:33 * joelr is going bonkers
08:41:25 <dcoutts_> ValarQ, if you did make clean that will do quite a bit of stuff and take a couple minutes
08:41:42 <shapr> Huh, tomaszz wrote a Transact-SQL parser?
08:45:43 <ValarQ> dcoutts_: ok, thats done
08:46:15 <dcoutts_> ValarQ, ok look at gtk/Graphics/UI/Gtk/Cairo.chs in an editor
08:46:23 <joelr> @index getProtocolNumber
08:46:24 <lambdabot> Network.BSD
08:46:24 <dcoutts_> ValarQ, ignore all the blank lines at the top
08:46:46 <dcoutts_> ValarQ, is the module exporing anything? or is it's export list blank?
08:47:32 <ValarQ> dcoutts_: there is no line containing the string "export"
08:48:07 <dcoutts_> ValarQ, that's because Haskell doesn't use the word export in it's export list :-)
08:48:27 <beelsebob_> how's this as a remake of the hat logo? http://www.cs.kent.ac.uk/people/rpg/tatd2/hat.pdf
08:48:33 <ValarQ> dcoutts_: ok, what am i looking for then?
08:48:35 <dcoutts_> ValarQ, the bit after: module Graphics.UI.Gtk.Cairo (
08:49:12 <ValarQ> dcoutts_: seems to be some lines
08:49:21 <ValarQ> dcoutts_: renderWithDrawable, etc...
08:49:22 <dcoutts_> beelsebob_, nice, except it looks like "mat" :-)
08:49:27 <dcoutts_> ValarQ, ok good
08:49:37 <sethk> whats the inverse to hPrint?  which class specifies methods for it?  that is, the inverse of show?
08:49:41 <beelsebob_> dcoutts: yeh... I have a problem with that... except that the original looks like mat too
08:49:50 <humasect> read
08:49:54 <beelsebob_> http://www.haskell.org/hat/
08:50:02 <sethk> humasect, so hRead for the handle version?
08:50:16 <humasect> hmm
08:50:30 <dcoutts_> ValarQ, then try to carry on with the build: make && sudo make install && make installcheck
08:50:58 <dcoutts_> ValarQ, or if you don't use sudo then use su and do that bit manually
08:51:07 <ValarQ> dcoutts_: should i uninstall the ebuild-installed version?
08:51:15 <dcoutts_> ValarQ, probably
08:51:26 <dcoutts_> probably a good idea
08:51:33 <xerox> dcoutts_: howdy :)
08:51:39 <dcoutts_> xerox!
08:51:42 <sethk> humasect, no hRead.  ?
08:51:48 <dcoutts_> xerox, so this win32 installer...
08:52:07 <dcoutts_> xerox, I was thinking it might be nicer to just bundle Gtk+ with the Gtk2Hs installer.
08:52:28 <dcoutts_> xerox, that way it's one less thing for people to download and much less to go wrong :-)
08:52:44 <beelsebob_> and who likes/hates this http://www.cs.kent.ac.uk/people/rpg/tatd2/yhchat.pdf
08:52:49 <dcoutts_> xerox, it'd probably end up as a 10Mb download or so
08:53:18 <ValarQ> dcoutts_: ok, now it works
08:53:28 <humasect> there is hShow so the inverse of hPrint is ...
08:53:39 <dcoutts_> ValarQ, yay! I dunno what's going wrong with your ebuild.
08:53:54 <dcoutts_> ValarQ, so the make installcheck works ok? all the demos build?
08:53:54 <xerox> dcoutts_: mumble.
08:53:56 <ValarQ> dcoutts_: i must have done something stupid i guess
08:54:10 <ValarQ> dcoutts_: yeah, all demos compiles
08:54:17 <xerox> dcoutts_: the Gtk2Hs win32 build will work only with a specific Gtk, wouldn't it?
08:54:22 <dcoutts_> ValarQ, well there will be a new gentoo ebuild out once 0.9.10 is out
08:54:37 <humasect> read + hGetContents
08:54:49 <dcoutts_> xerox, it'll work with one major version, eg it'l work with all 2.8.x or all 2.6.x
08:54:52 <humasect> (or read + hGetLine)
08:55:01 <xerox> dcoutts_: so, I'd say, not bundle!
08:55:36 <xerox> dcoutts_: thinking about it again, hmm.. I think the Gtk installer is smart enough to ask you to replace the current Gtk installation, if it finds any.. doesn't it?
08:55:46 <xerox> In that case, bundling wouldn't be a problem.
08:55:48 <sethk> humasect, hGetContents says it gets all available data.  Not generally what you would want.
08:56:15 <dcoutts_> xerox, that's because I made it complain if the current gtk isntallation was not good :-)
08:56:28 <humasect> but read uses all passed data
08:56:36 <dcoutts_> xerox, I had to write "pascal script" to make it do that. and it's a bit fragile
08:56:44 <xerox> dcoutts_: for the _gtk_ installer?
08:56:56 <joelr> any windows folks?
08:57:00 <dcoutts_> xerox, the 0.9.8 installer had 4 copies of the Gtk2Hs libs, (ghc-6.2.2+gtk-2.4, ghc-6.2.2+gtk2.6, ghc-6.4+gtk-2.4, ghc-6.4-gtk2.6)
08:57:14 <humasect> yes joelr
08:57:23 <xerox> Oh, I thought you would publish four different installer, woot.
08:57:34 <dcoutts_> xerox, so we can do the same thing again, or bundle a specific version of gtk
08:57:39 <sethk> humasect, ok.  then read isn't what I want either.  Let me think about this.  I'm trying to read/write fields.
08:57:43 <joelr> humasect: can you run something at your ghci prompt? Network.BSD.getProtocolByNumber "tcp"
08:57:47 <humasect> sethk: ok
08:58:31 <xerox> dcoutts_: so what happens in either cases if one updates gtk to a new minor release?
08:58:38 <joelr> getProtocolNumber, sorry
08:58:48 <sethk> humasect, I can use things in Storable and Foreign to do it, but perhaps I can avoid that.
08:58:56 <humasect> Couldn't match `Network.Socket.ProtocolNumber' against `[Char]'
08:59:01 <humasect> ok
08:59:10 <dcoutts_> xerox, well it'd get installed in parallel. and which ever version appeared on the $PATH first would get used.
08:59:21 <humasect> joelr: it = 6
08:59:28 <joelr> hmm
08:59:30 <joelr> fails for me
08:59:37 <humasect> just 6.4 here
08:59:40 <humasect> not .1
08:59:50 <joelr> humasect: i got 6.4.1 :(
08:59:55 <dcoutts_> xerox, which means it probably would not get used since the earler version would appear on the path first.
08:59:56 <xerox> dcoutts_: what's the point in bundling the gtk installer, apart from ease of installation (i.e. downloading just one installer) ?
09:00:03 <humasect> joelr: which windows? x64 here
09:00:11 <joelr> humasect: i have xp
09:00:16 <humasect> ok strange
09:00:18 <dcoutts_> xerox, it means we don't have to support various gtk versions
09:00:38 <dcoutts_> xerox, and we can get an overall smaller download
09:00:46 <xerox> dcoutts_: so if one updates (destructively) gtk, she needs a new gtk2hs build.
09:01:13 <dcoutts_> xerox, you couldn't update destructively, they're installed in different directories
09:01:31 <xerox> dcoutts_: as in "delete & install a new version"
09:01:33 <dcoutts_> xerox, the gtk bundled with gtk2hs would be installed in the same dir as gtk2hs
09:01:43 <xerox> Ah.
09:02:15 <dcoutts_> xerox, well if you deleted gtk2hs and reinstalled then it'd still use it's bundled one
09:02:34 <humasect> all ghc packages under windows get installed to \Program Files\ directly by default. giggle
09:02:37 <xerox> OK, now the case in which Gtk2Hs does not bundle them...
09:02:59 <xerox> You need to put a Gtk2Hs build for every major version?
09:03:17 <xerox> (which you want to support, for each ghc too)
09:03:17 <dcoutts_> xerox, yes.
09:03:47 <xerox> ...more pain, but it would work smoothly when upgrading Gtk to a new minor release.
09:03:51 <dcoutts_> xerox, we can build against an older version and run with a newer version but then you only get the features of the older version
09:04:10 <dcoutts_> xerox, yes it should deal with a minor version upgrade of gtk
09:04:12 <xerox> I wonder if it's worth it - say, the user has Gaim, which installs Gtk too..
09:04:31 <dcoutts_> xerox, do you know what gaim does with the $PATH on windows?
09:04:40 <xerox> Nope.
09:04:57 <dcoutts_> xerox, I suspect gaim installes a private version of gtk and does not add it to the path.
09:05:12 <dcoutts_> I should try it and see
09:05:17 <xerox> Everybody do that?  Groan.
09:05:33 <dcoutts_> xerox, windows is a real pain when it comes to sharing .dll files
09:06:06 <dcoutts_> you can't have the .exe in one directory and the .dlls in another without putting the .dll dir on the $PATH
09:06:16 <dcoutts_> and the $PATH is global, anyone can fiddle with it
09:06:21 <xerox> C:\Program Files\Gaim does contain just "libgtkspell.dll" as files matching the "*gtk*" pattern.
09:06:34 <dcoutts_> xerox, that's interesting
09:06:48 <dcoutts_> open a terminal and > echo %PATH%
09:06:52 <xerox> Gtk itself seem to be in Common Files\GTK\...
09:07:01 <dcoutts_> xerox, ok right
09:07:02 <xerox> I'm not on windows, I'm mounting it on linux :-)
09:07:06 <dcoutts_> ah
09:07:17 * dcoutts_ goes to install gaim on win32
09:07:24 <xerox> :-D
09:09:28 * ValarQ goes to hack some cairo programs
09:09:38 * xerox bounces happily
09:09:44 <xerox> ValarQ: what program? :-D
09:10:13 <xerox> Howdy SyntaxNinja
09:11:07 <ValarQ> xerox: i'm thinking about doing some quadtree tests
09:11:38 <ValarQ> xerox: will do some more basic stuff now and then work my way up
09:14:29 <dcoutts_> ValarQ, yes I'm interested in using quadtrees to help with redrawing scene graphs with cairo
09:15:48 <xerox> I was trying something about that graph idea, yesterday... but it needs more pondering.
09:16:58 <dcoutts_> xerox, so supposing one is scrolling about a large graph, cairo will obviously clip all drawing to the current clip window, however it'd be more effecient not to draw it at all if it's outside the bounding box of the scene
09:17:16 <dcoutts_> xerox, same thing goes for redrawing after expose events
09:17:53 <xerox> I was pondering about how to make use of the fact that we can zoom without quality loss...
09:17:55 <dcoutts_> so you want a fast way of finding only the objects that intersect the exposed region
09:18:18 <dcoutts_> xerox, yes it'd be nice to be able to zoom in and out
09:19:09 <dcoutts_> xerox, perhaps using keyboard keys or using toolbar buttons, or right menu things
09:19:19 <resiak> dcoutts_: You mean to say you didn't enjoy teaching us ocaml?
09:19:34 <xerox> I was thinking about "farthest nodes being more little" or something... we need to think some kind of cool way to show the resources.
09:19:36 <dcoutts_> resiak, well of course I do :-)
09:19:52 <dcoutts_> resiak, I just prefer to code in Haskell than ocaml :-)
09:20:08 <xerox> resiak: you lucky boy!  What a teacher you've got :-D
09:20:19 <resiak> xerox: I'm still not sure he knows which one I am ;)
09:20:26 <xerox> resiak: is it better?  ;-)
09:20:43 * dcoutts_ looks up resiak in the student database...
09:21:00 <resiak> dcoutts_: I was the one who asked about reference types.
09:21:07 <dcoutts_> resiak, ah ok
09:21:11 <xerox> * dcoutts_ changes some votes in the student database...
09:21:22 <dcoutts_> xerox!
09:21:26 <xerox> Uh.
09:21:56 <dcoutts_> xerox, I'm not open to corruption :-)
09:22:06 <xerox> I need a 'Structure and Interpretation of Electro Magnetism' or something...
09:22:25 * xerox hands dcoutts_ a new-shiny-BIG-wheeled-unicycle blinking
09:22:43 * dcoutts_ already has the largest unicycle one can buy
09:23:19 <xerox> So, physics...  later boys & girls!
09:23:28 <dcoutts_> by xerox
09:23:36 <dcoutts_> by/bye
09:28:16 <SyntaxNinja> hiya xerox
09:28:26 * SyntaxNinja has a headache
09:28:34 <SyntaxNinja> it's so hard to tell if it's too much coffee, or not enough...
09:30:42 <araujo> Hello!
09:31:12 <SyntaxNinja> hi araujo
09:31:31 <araujo> Hello SyntaxNinja !
09:31:43 <araujo> How you doing?
09:32:02 <SyntaxNinja> araujo: except for my headache, I'm pretty good.
09:33:24 <araujo> Put an ice-bag on top of your head
09:34:28 <SyntaxNinja> that would look silly
09:35:03 <araujo> But it works :-]
09:35:18 * araujo prefers it instead of drinking drugs
09:35:42 * SyntaxNinja nods
09:36:00 <SyntaxNinja> I never take asperin or anything, but I do drink coffee and water, and usually that helps.
09:36:36 <araujo> Ah, good, tea helps too
09:38:06 * araujo 's been lucky today
09:38:17 <araujo> gto back from univ. without headaches.....
09:38:44 <araujo> Though hungry and tired....
09:39:52 <shapr> man I love unicycling!
09:40:32 <SyntaxNinja> shapr: do you juggle while you unicycle?
09:40:44 <shapr> Haven't tried it.
09:40:54 <shapr> I can sort of juggle, but definitely not while riding down a mountain.
09:41:00 * SyntaxNinja nods
09:42:13 <araujo> And you ride down a mountain with an unicycle?
09:46:49 <tromp> rowingbiking is fun too
09:47:59 <shapr> araujo: sure yeah.
09:48:05 <shapr> tromp: I want to get a recumbent trike!
09:48:21 <dcoutts_> shapr, I've got 2 :-)
09:48:41 <dcoutts_> well 2 recumbent bikes, not trikes
09:49:43 <tromp> i'll see your 2 and raise you 1, dcoutts:)
09:50:10 <tromp> an open or faired one, shapr?
09:50:25 <dcoutts_> I've got an open and a partially faired one
09:50:43 <shapr> I'd like one of the Swifts, sort they're half and half.
09:51:04 <tromp> do you like the Quest?
09:51:44 <shapr> Is that the one you have?
09:51:48 * araujo wonders if shapr was unicycling in the video he saw
09:52:11 <tromp> no, i dont have a trike
09:52:59 <tromp> http://mrrecumbenttrikes.com/ is down:(
09:53:47 <tromp> Quests are very popular here. they currently have a 2year waiting list:)
09:54:45 <tromp> a friend of mine has one, plus 2 more on order
09:55:07 <thedward> I was about to jokingly suggest there should be a recumbent unicycle, but then a quick google search found this: http://www.unicycling.com/garage/recumben.htm
09:55:07 <tromp> when they deliver a new one, he can sell the old one at above cost:)
09:56:30 <tromp> it's not particularly reclined though:(
09:57:58 <tromp> not like http://www.biketcba.org/TRICORR/misc/donsmith.jpg
10:01:28 <tromp> http://www.wisil.recumbents.com/wisil/misc/nocom/nocomside.jpg is also pretty reclined:)
10:09:10 <araujo> Hello here
10:09:18 <araujo> How do i add a quote on lambdabot?
10:09:39 <tromp> this bike is also very cool: http://www.bentrideronline.com/STP/nmebig.jpg
10:09:52 <kolmodin> it says that @quote-add is an unknown command
10:17:01 <shapr> @help quote
10:17:02 <lambdabot>  @quote <nick>/@quote-add <nick> <quote>
10:17:02 <lambdabot> Quote somebody, or a random person, or save a memorable quote
10:17:08 <shapr> @help remember
10:17:08 <lambdabot>  @quote <nick>/@quote-add <nick> <quote>
10:17:08 <lambdabot> Quote somebody, or a random person, or save a memorable quote
10:17:55 <araujo> @quote-add kolmodin "i.e. I would rather lose my left arm than write it in Java"
10:17:56 <lambdabot> Unknown command, try @listcommands.
10:18:13 <araujo> Doesn't work
10:19:04 <shapr> Try using @remember
10:19:12 <shapr> @remember kolmodin i.e. I would rather lose my left arm than write it in Java
10:19:17 <shapr> @quote kolmodin
10:19:18 <lambdabot>  i.e. I would rather lose my left arm than write it in Java
10:19:23 <araujo> Oh, i see
10:19:26 <shapr> @quote araujo
10:19:27 <araujo> hah
10:19:27 <lambdabot> araujo hasn't said anything memorable
10:19:46 <pesco> @quote shapr
10:19:47 <lambdabot>  Anyway, I'm just a walking index into the Haskell world. I can tell
10:19:47 <lambdabot> you a little bit about many things, but I will quickly forward you
10:19:47 <lambdabot> to the experts for more detail.
10:20:42 <xerox> s/walking/unicycling/
10:20:43 <shapr> heh, boegel saved that.
10:29:32 <bourbaki> nighto
10:31:27 <pesco> It would be cool if lambdabot recognized "someone: thanks" and automatically increase that someone's karma.
10:32:25 <gzl> who really uses karma?
10:33:17 <pesco> Also interesting would be auto-acronym-expansion. If someone says "abcd?", i.e single word of no more than some n characters followed by '?', and it recognizes the acronym, it could automatically provide the correct expansion.
10:33:37 <dcoutts_> aaaarg! I hate windows!
10:33:38 <pesco> gzl: Nobody, I think. Sadly.
10:34:10 <dcoutts_> xerox, you would not believe the lengths people have to go to on windows to load the right versions of dlls.
10:34:38 <dcoutts_> xerox, the thing is that windows has a totally bonkers dll search system
10:34:51 <dcoutts_> it's like dynamic scoping rather than static scoping
10:35:31 <dcoutts_> an exe is never able to know where it's dlls will be loaded from
10:36:01 <dcoutts_> they just get searched for in the current directory and on the system path
10:36:24 <dcoutts_> on unix one can 'bake' into an executable the search path for the shared libs
10:36:32 <dcoutts_> in windows you can't do that
10:36:50 <dcoutts_> you can set some flakey registry setting but that breakes if you rename your .exe file
10:37:07 <dcoutts_> so the gaim folk have a very cunning hack
10:37:15 <kolmodin> pesco: a perhaps unexpected side effect would be when someone asks "wtf?"
10:37:16 <dcoutts_> sadly it will not work for gtk2hs
10:38:59 <kolmodin> dcoutts_: that sounds very crappy, indeed
10:39:02 <dcoutts_> xerox, so yeah, I guess we just have to have Gtk installed on the PATH. Which means we have to play nicely with any other installation of gtk
10:39:12 <pesco> kolmodin: True.
10:39:16 <dcoutts_> kolmodin, yeah.
10:39:29 <ski_> @wtf imo
10:39:31 <lambdabot> *** "IMO" wn "WordNet (r) 2.0"
10:39:31 <lambdabot> IMO
10:39:31 <lambdabot>   n : the United Nations agency concerned with international
10:39:31 <lambdabot>    maritime activities [syn: {International Maritime
10:39:31 <lambdabot>    Organization}]
10:39:33 <eivuokko> On windows 2000 and forward, dll is first searched next to exe.
10:40:16 <dcoutts_> eivuokko, and on win 2003 it's searched in the system folders and then the .exe dir
10:40:29 <eivuokko> gtk is one of the crappiest distributions, they have zillion builds which have dll:s that are no interchangeable and stupid setup puts the dlls in path.
10:40:52 <eivuokko> Which practically always breaks one gtk application if you need new gtk for another.
10:41:01 <dcoutts_> eivuokko, unforunately there's no other way to share the gtk installation between apps without having it on the PATH
10:41:19 <dcoutts_> each app could install gtk in its own dir. that'd work.
10:41:34 <eivuokko> I am not sure if delayed loading and some system call could be used.
10:41:38 <dcoutts_> however that's not very helpful for something like gtk2hs. Since it's not an app.
10:41:41 <eivuokko> Who wants to share gtk distro anyway
10:41:55 <dcoutts_> eivuokko, yes it does help. that's exacly what the gaim people do.
10:41:56 <xerox> dcoutts_: great!
10:41:57 <eivuokko> All the programs are compatible with diffrent builds of gtk
10:42:37 <dcoutts_> the problem for gtk2hs is that it is not an app. An exe generated with ghc using gtk2hs will not be in the same directory as the gtk dlls.
10:42:55 <dcoutts_> so there must be some way for that exe to find the dlls
10:43:08 <xerox> dcoutts_: I read it wrongly, it's not so great..
10:43:38 <eivuokko> dcoutts, maybe you don't realise how often windows developers copy dlls next to their exe anyway?
10:43:41 <dcoutts_> one can set an "app path" in the registry for each .exe, however that's silly and we can't get ghc to do that for every .exe it generates that uses gtk2hs
10:43:45 <eivuokko> At least that's what I do when I develop.
10:44:02 <eivuokko> That's menat for installed apps :o
10:44:06 <eivuokko> *meant
10:44:19 <dcoutts_> eivuokko, that's fine for developing "Applications" but for example we've got dozens of demo programs. How are they meant to work?
10:44:39 <eivuokko> lol :)
10:44:55 <eivuokko> No idea, sorry.
10:44:55 <dcoutts_> you have to be able to do: ghc --make WinGtkPog.hs; main.exe
10:44:58 <dcoutts_> and have it work
10:45:06 <eivuokko> Hmh
10:45:09 <dcoutts_> the only way seems to be to put gtk on the PATH
10:45:20 <dcoutts_> which as you note is a major pain in the back side
10:45:29 <eivuokko> Forcing something into path is gonna cost users.
10:45:45 <dcoutts_> MS cheats and installs mfc.dll in the windows system dir.
10:45:47 <sethk> can you do the equivalent of building a static exe?  Does windows allow that?
10:45:57 <dcoutts_> wxHaskell does the same thing with it's .dll
10:46:27 <dcoutts_> sethk, it's possible but then every app would be 10 mb large since it'd include all of gtk
10:46:36 <dcoutts_> and gtk is not really built for static linking
10:46:43 <eivuokko> dcoutts, there is a big diffrence with mfc.dll and gtk.  First mfc.dll with same name are almost totally compatible (module bugs), and they rename it on major version changes.
10:46:49 <sethk> dcoutts, it's ugly, I was just wondering if it is even possible
10:47:07 <dcoutts_> eivuokko, well actually gtk is upwards binary compatible
10:47:27 <dcoutts_> sethk, static builds are not really a supported gtk configuration
10:47:39 <eivuokko> That simply isn't true.  I have had problems with gtk so many times.
10:48:21 <dcoutts_> eivuokko, so have I. on win32. But that's probably because an app is using features from a newer version of gtk than the one that happens to be on the search path
10:49:02 <dcoutts_> and the other thing that causes problems is all the dlls that gtk uses. eg intl.dll if one of those is installed on the path before the one that comes with gtk then it gets used in preference
10:49:14 <dcoutts_> or zlib, that's a common one
10:49:43 <eivuokko> Yeah, zlib is mildly annoying because there exists gcc and msvc builds
10:49:46 <dcoutts_> it often gets installed in the windows or system dir which means it gets used in preference to the one that comes with gtk
10:50:00 <eivuokko> And they have defaultly iffrent calling ocnvetions iirc
10:50:38 <eivuokko> Anyway, normal people dont have any such dlls in system directory because they cannot install them there.
10:50:42 <dcoutts_> yes, MS compilers do bitfileds differently to gcc, though gcc can use the MS convention if you ask it to
10:51:33 <dcoutts_> later versions of windows have a SetDllPath function
10:51:52 <eivuokko> (SetDllDirectory)
10:52:03 <dcoutts_> err, yeah
10:52:10 <dcoutts_> but that only helps when you're explicitly loading dlls, not ones that you've linked to
10:52:21 <dcoutts_> so it doesn't help for the ghc case
10:52:23 <eivuokko> Not even with delayed loading?
10:52:31 <dcoutts_> it is the trick that gaim uses
10:52:40 <thedward> maybe someone should write a better dynamic linker for windows
10:52:50 <eivuokko> Can gcc/ghc link delayedly?  I am not sure how it is expressed in dll/exe.
10:53:22 <dcoutts_> the gaim.exe is a stub that changes directory to the gtk dir and then loads the gaim.dll which can then find the gtk dlls because they are then in the current dir.
10:53:28 <eivuokko> What is the real diffrence in unix?  Nothing much really.
10:54:17 <dcoutts_> eivuokko, in unix if an app links to .so files that are not on the default search path then one can embed extra search directories into the executable (or a .so librariy itself)
10:54:31 <thedward> also, the major/minor versioning is nice
10:54:36 <dcoutts_> and the .so search path is very simple
10:54:36 <CosmicRay> it is also possible to dlopen() so files at run time
10:54:43 <CosmicRay> however this is rarely used in practice and not entirely portable
10:54:51 <eivuokko> CosmicRay, that is possible in windows as well
10:55:04 <dcoutts_> none of this current directory/systemdir/PATH stuff
10:55:30 <dcoutts_> eivuokko, I'm interested by the delayed loading. Does windows do that?
10:55:46 <eivuokko> There are flags for it in msvc iirc
10:56:23 <eivuokko> I don't really see how that matters in unix, from my experience it isnt any better, just that typically you use much more distribution provided or self-compiled programs in unix.
10:57:33 <thedward> yeah, better package management does make a huge difference too
10:58:18 <dcoutts_> eivuokko, the cruical difference is that the unix elf loader can use search paths that are baked into the exe or .so files themselves.
10:58:46 <dcoutts_> so each exe or shared library can have a private search directory for it's dependent libs
10:59:14 <thedward> someone should make a version of zero-install for windows
10:59:24 <eivuokko> Seem minor developer feature to me.
10:59:45 <thedward> can windows have different versions of the same dll installed, that are shared between different apps?
11:00:05 <eivuokko> In many diffrent ways.
11:00:11 <dcoutts_> if we could do that on win32 then Gtk2Hs could come bundled with a copy of Gtk+ installed in a private directory, and all Haskell programs that use gtk2hs could have that private path baked into them so that they could find the gtk dlls without having to use the global windows PATH
11:01:44 <eivuokko> Yeah, I understood that problem.  What I am just answering to windows dynamic linker vs linux/elf dynamic linker.
11:02:31 <eivuokko> Sorry, I just find it disgusting to go on and blame windows for all the problems you have while using it.  I'll shut up now.
11:03:43 * xerox yummys some chestnuts
11:03:51 <thedward> Its easier to blame stuff on windows, because if you start complaining about Linux someone will expect you to fix it yourself. ;)
11:05:50 <SyntaxNinja> heh
11:05:54 <eivuokko> Only thing I can find about delayd loading is msvc linker.
11:05:54 <dcoutts_> eivuokko, I guess the problem is that I'm doing something in the unix style (that is makeing everything a library with complex dependencies between them) while the common windows style is to have distinct apps each with all their dependencies distributed with them.
11:06:12 <dcoutts_> eivuokko, ok thanks, i'll google for that
11:06:36 <eivuokko> I am not sure whetever it is dll-header option or requires some import lib magic.
11:07:11 <eivuokko> In latter case it is rather unlikely gcc/ld knows about it, I think.
11:12:24 <eivuokko> Reading those gaim tricks...lol.
11:17:52 <dcoutts_> eivuokko, the delayed loading looks interesting
11:18:00 <eivuokko> I wonder if those application paths work for dlls
11:18:05 <eivuokko> (in registry)
11:18:43 <dcoutts_> eivuokko, that would really help
11:18:45 <eivuokko> So that you could in theory have one stub dll through which to load others.  Requires of course rather drastic work on loading and arhitecure/design of big libraries.
11:19:27 <dcoutts_> that'd be possible with gtk2hs since it could provide a stub dll
11:19:49 <dcoutts_> howver I've not seen anywhere that app paths can work for dlls
11:19:53 <dcoutts_> it'd be great if it did
11:20:23 * dcoutts_ tries to figure out if delayed loading will help
11:20:37 <eivuokko> I also wonder if forcing \ or / in executable in dll name helps.
11:20:51 <eivuokko> Rather lot of stuff I don't know about this :-|
11:20:58 * dcoutts_ too!
11:25:57 * SamB wonders why Google are worried about people decompiling, disassembling, or reverse-engineering the Google Maps imagery...
11:26:38 * SamB also wonders why Google is confused about the name
11:33:18 <eivuokko> Erm, *very* fast testing with hex editor shows actually you can put absolute path in .exe binary np...it's nothing special
11:34:23 <dcoutts_> eivuokko, oooh, how?
11:34:45 * dcoutts_ wonders if I can do that with gcc
11:35:43 <SamB> dcoutts: wouldn't that be more of an ld kind of thing?
11:36:40 <eivuokko> dcoutts, Well, as I said, I used hex editor.
11:37:28 <eivuokko> The real problem is probably that dlls are likely to depend on each other and have same problem on dependencies between them.
11:37:37 <cjb> I've used vim to relink files.  :)
11:39:03 <dcoutts_> SamB, yes it would
11:39:31 <dcoutts_> eivuokko, yes good point
11:39:51 <CosmicRay> cjb: there are at least two things evil about that sentence ;-)
11:40:43 <eivuokko> dcoutts, I am rather tired, so I'll drop that for now, hope you find at least adequate solution.
11:46:44 <dcoutts_> eivuokko, thanks for the help
11:49:52 <SamB> does GTK have something in the registry to tell where it is?
11:52:47 * syntaxfree enters the room bouncing around to the fast music.
11:53:56 <SamB> I demand to hear this music!
11:54:03 <SamB> And I demand to hear it NOW!
11:54:07 <syntaxfree> too ... much ... caffeine ..
11:54:28 <SamB> ... even though I have only a 56k dialup connection!
11:55:16 <syntaxfree> damn. I am a prototypical meth junkie. I'm glad that stuff is verboten and hard to get.
11:56:34 <syntaxfree> is caffeine the drug of choice for discriminating hackers?
11:57:06 <sethk> syntaxfree, heroine, because haskell is so stable you don't have to do anything
11:57:11 <SamB> nah, I'm pretty sure its gotta be sleep! or coding!
11:57:35 <dcoutts_> SamB, yes we can find the Gtk installation from the registry
11:57:52 <syntaxfree> I'm  sleeping 14-16 hours  a day and am sleepy most of the day.
11:58:21 <syntaxfree> Today I gave in to the urge and binged on caffeine. I love the bzzzzzzzzzzzzt feeling of it.
11:58:32 <SamB> can you get windows to load the GTK dlls lazily?
11:58:55 <dcoutts_> SamB, that's what I've been trying to investigate
11:59:15 <dcoutts_> it looks like it's possible
11:59:16 <syntaxfree> many open source apps for Windows transparently install gtk.
11:59:30 <dcoutts_> syntaxfree, yes, that's part of the problem :-)
11:59:48 <syntaxfree> why? what is the problem?
12:00:09 <dcoutts_> actually I should ask JaffaCake, since this will be a problem when ghc uses .dlls for Haskell packages
12:00:18 <Rene> Why would
12:00:21 <dcoutts_> he might have some ideas for how to solve it
12:00:21 <Rene> board_piece_at_loc (Board board) (Location location) = board!location
12:00:32 <Rene> not be so fast?
12:00:46 <Rene> Board and Location are both newtype's of Int
12:01:05 <dcoutts_> syntaxfree, the problem is that gtk ends up needing to be on the windows PATH for gtk progs to pick up the dlls. Gtk being on the path is rather fragile.
12:02:47 <syntaxfree> dcoutts: if I recall correctly, Gretl expected the GTK path to be in some kind of  configuration textfile..
12:04:04 <syntaxfree> the windows register is fragile itself, anyway.
12:15:29 <dcoutts_> syntaxfree, gtrtl justs puts all the gtk dlls in the gretl directory where the gretlw32.exe lives
12:15:35 * dcoutts_ has to go now
12:16:19 <dcoutts_> thanks to the people who've tolerated me complaing about dlls
12:17:42 <xerox> Bye dcoutts :-D
12:21:45 <kolmodin> hi davve
12:22:19 <davve> hi!
12:22:19 <sethk> I don't find methods in the library for reading that are analgous to show + hPrint.  I should be able to get the same results I think using parsec and a lexer, with the lexer reading from a file rather than stdin?  Sound reasonable?
12:23:12 <kolmodin> davve: you didn't use GADT's in your compiler in the end?
12:23:31 <davve> davve, yes I did
12:23:44 <davve> err.. kolmodin
12:24:00 <kolmodin> ah, not using the annotated type expressions then?
12:24:11 <kolmodin> btw, have you had your oral exam yet?
12:24:23 <davve> kolmodin, ehm.. I had that aswell.. nothing to do with the part of the code that uses GADT's
12:24:35 <davve> kolmodin, we had ours today
12:24:37 <kolmodin> ok
12:24:58 <kolmodin> davve: me too, claimed 36 points which I also got
12:25:37 <davve> kolmodin, we got that aswell :) we just have to fix a bug one of the extensions
12:25:49 <kolmodin> apperently most people with 36 points had done both jvm and quadruples
12:26:24 <davve> kolmodin, oh.. that seems like much work
12:26:27 <kolmodin> but I was tired of writing backends by the time I'd done the JVM :)
12:27:19 <skar> hi all, i read haskell gives as good a performance as any, does it mean that i can use haskell to write something which involves a lot of regex and text, say spamassassin?
12:27:21 <kolmodin> did you use the GADT's to return a type checked tree?
12:27:33 <davve> kolmodin, no
12:27:57 <davve> kolmodin, that's impossible
12:28:00 <kolmodin> davve: me neither. firstly I'd already written that part when you came up with the idea
12:28:38 <kolmodin> second, how can you return checkExp :: Exp -> GADT_EXP a    <-- a differs
12:28:48 <kolmodin> ?
12:29:24 <davve> that's why there's no point.. Exp would have be a GADT, and that would put typechecking in the parser
12:30:08 <ski_> (one could possibly use existential types ..)
12:30:34 <skar> or is perl a better alternative for text processing?
12:31:13 <sethk> skar, that's very general.  I don't think that question has such a broad answer
12:31:14 <davve> ski_, then the translation functions for GADT_EXP's would be in type classes? :)
12:31:29 <ski_> which translation functions ?
12:31:32 <kolmodin> skar: I would still do it in haskell, but look if I could use Fast Packed Strings or perhaps some other library if it would do much list manipulation
12:31:35 <sethk> skar, it really depends on exactly what you need to do
12:31:59 <davve> ski, GADT_EXP a is the typechecked expression that  needs to be translated in the backend
12:32:07 <davve> ski, in our compilers
12:32:23 <skar> sethk: if i need to implement stuff like SA in haskell, would it be as fast as in perl, while taking far less amount of code?
12:32:33 <ski_> i don't think translation would have to be in type classes ..
12:32:48 <ski_> (davve : why did you mention type classes, btw ?)
12:33:09 <skar> sethk: bcoz haskell seems concise and it would be a good way for me to learn haskell too, not to mention the coolness factor of haskell
12:33:56 <davve> ski, no you don't have to use type classes.. so just forget what I said =)
12:34:08 <sethk> skar, the performance depends a lot on how you write.  haskell certainly has the capability to do that, and if you wish to learn haskell you might as well jump in there as anywhere else
12:34:27 <sethk> skar, there is a learning curve there.
12:34:43 <ski_> (possibly you could constrain by Typable, though .. but i don't think this would be needed for translation ..)
12:35:00 <sethk> skar, if your main aim is learning haskell then I would say, try it.
12:35:03 <davve> kolmodin, my idea was never to typecheck with GADT's :)
12:35:31 <davve> kolmodin, only to typecheck the assembler language
12:35:35 <skar> sethk: yup, if i thought perl was cryptic, haskell just seems to need a complete reprogramming of my brain ;)
12:35:45 <CosmicRay> skar: isn't it great? ;-)
12:35:45 <kolmodin> davve: not to type check, no, just to make sure that you don't do ary errors while writing the new AST
12:36:00 <CosmicRay> skar: I think it has that effect on many of us
12:37:03 <kolmodin> davve: so how did you do it?
12:37:11 <skar> CosmicRay: yup  its real great to have a lang like haskell
12:37:30 <CosmicRay> skar: have you found some good introductory resources already?
12:37:38 <davve> kolmodin, like I said, I didn't use GADT's in the typechecker
12:37:55 <davve> kolmodin, I only used it in the backend
12:38:14 <skar> CosmicRay: http://perlcabal.org/~autrijus/tmp/haskell3.xul is what i'm looking at now
12:38:30 <skar> CosmicRay: what do you suggest?
12:38:54 <CosmicRay> skar: this is good: http://www.isi.edu/%7Ehdaume/htut/
12:38:55 <ski_> @where YAHT
12:38:56 <lambdabot> I know nothing about yaht.
12:39:02 <ski_> @learn
12:39:03 <lambdabot> http://www.haskell.org/learning.html
12:39:34 <CosmicRay> skar: for a much shorter, whet-your-appetite sort of thing, there's my article at http://www.freesoftwaremagazine.com/free_issues/issue_05/haskell/
12:39:44 <CosmicRay> there are also some good dead-tree books.
12:39:49 <ski_> (possibly the short "Haskell Tutorial for C Programmers" http://www.haskell.org/~pairwise/intro/intro.html, too)
12:40:08 <CosmicRay> ski_: oo, that's interesting, I've never heard of that.
12:40:38 <CosmicRay> skar: my little article develops several points by implementing a trivial grep in haskell
12:41:24 <syntaxfree> htut/yaht rules!
12:41:28 <ski_> CosmicRay : ?
12:41:40 <ski_> CosmicRay : that tutorial ?
12:41:41 <CosmicRay> ski_: that link you posted.  looks nice.  I hadn't heard of it before.
12:41:42 <syntaxfree> if you're bored  with the Gnetle Introduction, go for htut!
12:41:43 <CosmicRay> right.
12:41:55 <CosmicRay> syntaxfree: I found the gentle introduction to fail to live up to both words in its title ;-)
12:43:02 <syntaxfree> I'm working on a My First Five Minutes with Haskell thing.
12:43:16 <syntaxfree> I might post it to the wiki at some point, even unfinished.
12:43:30 <kolmodin> davve: so you generate new annoted AST in the typechecker, translate that into quadruples using GADT to make sure it is correct?
12:43:46 <davve> kolmodin, yep..
12:44:50 <syntaxfree> skar: also, don't be afraid to ask questions. I've never seen a kinder-to-newbies community than the Haskell one.
12:45:04 <syntaxfree> my theory is that's due to the academic background of many Haskell gurus.
12:45:40 <kolmodin> davve: don't you get the same problem when you generate the assembler tree, or do you use it before it actually gets translated?
12:45:47 <mflux_> another reason might be that haskell may not be the kind of language that attracts people Who Want Everything And Right Now
12:45:56 <CosmicRay> yes.  I have asked plenty of stupid questions and received plenty of polite, lucid answers.
12:45:57 <davve> kolmodin, no.. because we don't type registers
12:46:29 <davve> kolmodin, and registers are what the translation function returns
12:46:52 <syntaxfree> syntaxfree's_stupid_questions = [ x + more_stupidity | x<-cosmicray's_stupid_questions]
12:47:06 <CosmicRay> heh
12:47:17 <xerox> Which evaluates to []  ;-)
12:47:34 <kolmodin> davve: ah. so the GADT tree is pretty much built and used at once
12:48:37 * Bobl is just installing GHC
12:48:39 <syntaxfree> @eval let syntaxfree's_stupid_questions = [ x + more_stupidity | x<-cosmicray's_stupid_questions] in syntaxfree's_stupid_questions
12:48:40 <lambdabot>  Not in scope: `cosmicray's_stupid_questions'
12:48:51 <skar> syntaxfree: ok sure i'll ask my questions
12:48:54 <CosmicRay> haha
12:49:01 <CosmicRay> Bobl: nice
12:49:03 <syntaxfree> CosmicRay never asks stupid questions, apparently ;-)
12:49:05 <SyntaxNinja> w00t
12:49:06 <SyntaxNinja> hi CosmicRay
12:49:22 <CosmicRay> syntaxfree: that is certainly news to me ;-)
12:49:25 <SyntaxNinja> man. we got a manual espresso maker here.  it makes awesome coffee
12:49:26 <CosmicRay> hiya syntaxninja
12:49:29 <CosmicRay> heh
12:49:32 <syntaxfree> hey, Ninja.
12:49:38 <Bobl> CosmicRay, as a newb, is haskell hard to learn, if you already have done simple functional programming
12:49:47 <SyntaxNinja> hi syntaxfree
12:49:57 <CosmicRay> Bobl: you will definately have an advantage over others.  what functional languages do you have experience with?
12:50:05 <syntaxfree> the basics of Haskell shouldn't be hard if you know Scheme.
12:50:12 <Bobl> it was called amanda
12:50:15 <davve> kolmodn, well.. it's not a tree. it's a list of existentials.. GADT's are only used for operand types really, and it's rather silly but a fun exercise =)
12:50:20 <CosmicRay> SyntaxNinja: are you happy with your placement in this week's HWN, finally? ;-)
12:50:30 <CosmicRay> Bobl: hmm.  haven't heard of that one.  is it similar to anything I may have heard of? ;-)
12:50:44 <syntaxfree> Haskell >> Scheme. But you'll find yourself doing the things you prolly did with Scheme fast'enuff,
12:50:48 <Bobl> CosmicRay, possibly similar to miranda
12:50:54 <SyntaxNinja> CosmicRay: a one-liner about the most important event the community has ever witnessed?
12:50:56 <SyntaxNinja> ;)
12:50:58 <Bobl> it definately looks a lot like haskell
12:51:07 <CosmicRay> Bobl: oh, ok.  you should be fairly well at ease then.
12:51:10 * syntaxfree plugs his The Same Code in Scheme And Haskell page @ http://www.haskell.org/hawiki/DiegoNavarro
12:51:29 <CosmicRay> SyntaxNinja: don't tell me that a Simon got hit by a bus at a workshop?!!! ;-)
12:52:20 <CosmicRay> Bobl: If memory serves, Miranda was one of the languages that served as inspiration for Haskell way back when
12:52:28 <ski_> (Bobl : any link for 'amanda' ?)
12:52:34 * Bobl is looking
12:52:45 <CosmicRay> ski_: I can tell you it's not amanda.org, because we use that here ;-)
12:52:59 <CosmicRay> unless your language has built in tape-backup features ;-)
12:53:26 <Frederick> hi folks im back
12:53:45 <CosmicRay> aw man, my program just segfaulted.
12:54:02 <SyntaxNinja> CosmicRay: are you involved w/ the amanda project?
12:54:02 <Bobl> http://www.engin.umd.umich.edu/CIS/course.des/cis400/miranda/miranda.html
12:54:13 <CosmicRay> SyntaxNinja: only as an end-user
12:54:21 <CosmicRay> though I did hack bzip2 support into it in the dim dark past
12:55:10 <Bobl> ski_, but like i said its only small time i think, only for academic purposes
12:55:17 <malcolm> bzip2 was written by Julian Seward, a ghc hacker
12:55:25 <CosmicRay> really
12:55:28 <CosmicRay> that is interesting.
12:55:33 <syntaxfree> bzip2 support for Amanda, or bzip2 bzip2?
12:55:40 <CosmicRay> bzip2 support for amanda
12:56:01 <ski_> (Bobl : is amanda a miranda variant ?)
12:56:12 <CosmicRay> I am nowhere near brilliant enough to come up with some compression scheme that beats gzip *and* has better data integrity protection ;-)
12:56:15 <Bobl> ski_, i think so, for windows guis :S
12:56:33 <syntaxfree> bzip2 is an open source data compression algorithm and program developed by Julian Seward. Seward made the first public release of bzip2, version 0.15, in July 1996.
12:56:38 <syntaxfree> hmm.
12:56:44 <Bobl> ski_, it was not very impressive
12:56:59 <CosmicRay> yay, my gopherbot has cached almost 50,000 files ;-)
12:57:23 <CosmicRay> syntaxfree: were you trying to teach lambdabot about that?  ;-)
12:57:36 <syntaxfree> not a bad idea.
12:57:38 <malcolm> IIRC Julian wrote large chunks of ghci, and the Sparc native code generator
12:57:51 <CosmicRay> is he still active?
12:58:28 <malcolm> his current project is valgrind, a v cool memory profiler, bug finder, and cache profiler
12:58:41 <CosmicRay> ah, I have heard of that.
12:58:42 <gzl> valgrind is really good
12:58:58 <malcolm> prototypes of valgrind were written in haskell I think
12:59:54 <gzl> the only problem is that you'd generally use it to debug some C program you're writing, which probably isn't much fun. :P
13:00:10 <syntaxfree> @fact bzip2
13:00:11 <lambdabot> bzip2: bzip2 is an open source data compression algorithm and
13:00:11 <lambdabot> program developed by Julian Seward. Seward made the first public
13:00:11 <lambdabot> release of bzip2, version 0.15, in July 1996. He's also known as a
13:00:11 <lambdabot> GHC hacker..
13:00:59 <Frederick> guys I was reading here about using monads in http://www.haskell.org/tutorial/monads.html it talks about a state machine, an automata in fact, can I create a program that generates such strutures in run time or I need to define all states before?
13:01:48 <syntaxfree> @vixen
13:01:54 <lambdabot> You should add me to your buddy list!
13:02:27 <xerox> Will do.
13:03:08 <syntaxfree> @yow
13:03:09 <lambdabot> Frivolity is a stern taskmaster.
13:03:18 <syntaxfree> @arr
13:03:19 <lambdabot> Arrr!
13:04:33 <CosmicRay> are there any resources on doing a postmortem on a haskell program that is coredumping?
13:04:52 <malcolm> strace?
13:04:59 <CosmicRay> the stack appears smashed so I can't get a good deal of info there
13:05:15 <CosmicRay> malcolm: this program is very I/O-intensive so it is not the most practical tool
13:05:21 <kolmodin> Frederick: you have to say what type the state should be at compile time
13:05:29 <xerox> hat-delta?
13:05:33 <sylvan> CosmicRay, what on earth did you do to make a haskell-program core dump?
13:05:38 <CosmicRay> sylvan: I have no idea.
13:05:55 <Frederick> kolmodin, sure
13:06:00 <sylvan> CosmicRay, calling C? Using primitve byte-level functions? UnsafePerformIO? =)
13:06:10 <malcolm> the hat tools aren't too good with core-dumps.  The trace doesn't get finalised properly
13:06:17 <CosmicRay> no, no, no.  I am using HSQL with sqlite3 so I am slightly suspicious of that.
13:06:23 <kolmodin> sylvan: I would bet my money on a call to C
13:06:26 <Frederick> oki Ive just finished reading a gentle introduction to haskell but I couldnt figure out yet with structure I need to us
13:06:34 <adept> CosmicRay: are you aware of -e option for strace?
13:06:39 <sylvan> I'd suspect that sqlite3 is crashing
13:06:45 <malcolm> have you used gdb already?
13:06:45 <Frederick> I want a grammar manipulator, but I could find no for to manipulate a grammar in haskell
13:06:56 <syntaxfree> What is a grammar?
13:06:57 <CosmicRay> malcolm: yes, and bt showed me over 1000 frames of nothing
13:06:58 <adept> CosmicRay: and ltrace, likewise
13:07:00 <syntaxfree> @fact grammar
13:07:01 <lambdabot> I know nothing about grammar.
13:07:08 <malcolm> oh, come to think of it, what about valgrind :-)
13:07:12 <CosmicRay> heh
13:07:32 * CosmicRay tries strace.  I do have 40G free so it ought to be OK for a few minutes ;-)
13:07:35 <eivuokko> Can ghc cross-compile?
13:08:00 <malcolm> eivuokko: with difficulty.
13:08:06 <syntaxfree> @dict grammar
13:08:07 <lambdabot> Supported dictionary-lookup commands:
13:08:07 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
13:08:07 <lambdabot> jargon @lojban @prelude @vera @web1913 @wn @world02
13:08:07 <lambdabot> Use "@dict-help [cmd...]" for more.
13:08:12 <eivuokko> Translation: Don't try. ? ;)
13:08:14 <adept> CosmicRay: time is more of consideration than disk space. I suggest you excule file ops from trace using -e
13:08:18 <syntaxfree> @web1913 grammar
13:08:19 <lambdabot> *** "Grammar" web1913 "Webster's Revised Unabridged Dictionary (1913)
13:08:19 <lambdabot> "
13:08:19 <lambdabot> Grammar \Gram"mar\, n. [OE. gramere, OF. gramaire, F. grammaire
13:08:19 <lambdabot>  Prob. fr. L. gramatica Gr ?, fem. of ? skilled in grammar,
13:08:19 <lambdabot>  fr. ? letter. See {Gramme}, {Graphic}, and cf. {Grammatical},
13:08:21 <lambdabot>  {Gramarye}.]
13:08:22 <malcolm> eivuokko: there was a post about it on the ghc list today
13:08:24 <lambdabot>  1. The science which treats of the principles of language;
13:08:25 <lambdabot> [51 @more lines]
13:09:06 <eivuokko> malcolm, I am not following mailinglists, checking..thanks :)  (I was just wondering if colinuxing mingw toolchain would be nicer than native)
13:10:02 <vina> syntaxfree: I'm no t very used to IRc, but I think that lambdabot is a bot. What kind of functionality does it provides? Is there any docs?
13:10:18 <syntaxfree> vina: open a private message with it and type @listcommands
13:10:43 <syntaxfree> when you're tired of its silence, type @listofcommands and you shall get a list of commands.
13:11:06 <vina> syntaxfree: thanks!
13:12:14 <Frederick> guys ive found a paper about context free grammars an haskel, but it abuses haskel notation a bit, as Im new to the language can anyone please kindly take a look on page 2 of http://www.cs.chalmers.se/~peb/pubs/p04-chart-pearl.pdf and help me doing the basics?
13:13:10 <CosmicRay> Frederick: hmm, that table doesn't really even look like psuedocode to me
13:13:27 <CosmicRay> it looks more like a BNF spec
13:14:04 <Frederick> CosmicRay, yes but right after it the paper says it is defining the types into a haskell style
13:14:59 <xerox> That is a grammar, yeah.
13:15:08 <xerox> data S = NP VP
13:15:15 <CosmicRay> hmm, I'm afraid that I'm not well-versed enough in this style to know what to say
13:15:24 <xerox> data VP = Verb | Verb NP | VP PP
13:15:24 <kolmodin> xerox: exactly
13:15:31 <Frederick> xerox, can you help me on the basics translation?
13:15:37 <xerox> data NP = Noun | Det Noun | NP PP
13:15:39 <xerox> etc..
13:15:46 <Frederick> xerox, Im workig with context free grammars
13:15:49 <Frederick> lemme start
13:16:03 <ski_> (vina: also try like '@help eval' for specific commands ..)
13:16:05 <xerox> Frederick: I worked with them too ;-)
13:16:07 <Frederick> VP would be my set of productions right?
13:16:22 <syntaxfree> @fact haskell
13:16:23 <lambdabot> I know nothing about haskell.
13:16:31 <CosmicRay> hah
13:16:51 <xerox> Howdy poetix
13:16:55 <xerox> Frederick: lemme see
13:17:02 <poetix> Hi xerox
13:17:11 <xerox> Frederick: that approach is very, very formal.
13:18:22 <Frederick> xerox, what do you mean?
13:18:47 <xerox> Frederick: I started out with strings substitutions, keeping productions in a list of tuples.
13:19:09 <xerox> ...the axiom being a Char, and the productions (Char,String)
13:19:31 <Frederick> xerox, http://www.informatics.sussex.ac.uk/courses/funcprog/Handouts/casestudy-2-solution.pdf
13:19:31 <xerox> Generalizing, it went to multiple levels until reaching monads.
13:20:08 <xerox> ah!  Cool!
13:20:42 <Frederick> xerox, this is almost what I need
13:20:45 <xerox> It is using Parsec :D
13:21:28 <CosmicRay> Frederick: you will be interested in http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html
13:22:33 <CosmicRay> very slick parser, imho
13:23:35 <Frederick> CosmicRay, will I need that?
13:23:49 <xerox> Frederick: there are some things to learn in order to understand the code of the second pdf... I'm going to bed... keep making your way through it :-)
13:23:55 <CosmicRay> Frederick: need, no.  want, quite possibly.  ;-)
13:24:22 <Frederick> xerox, sure I will bug you later
13:24:24 <Frederick> :D
13:24:41 <Frederick> my goal for the next 30 minutes is describe a grammar
13:24:43 <xerox> You're welcome :-)  Goodnight folks!
13:24:58 <ski_> xerox : 'import ParseLib' ..
13:25:26 <xerox> ski_: module ParseLib (module Parsec) where import Parsec  ;-)
13:25:51 <ski_> ah
13:26:04 <xerox> (At least that's my guess, more or less)
13:26:05 * ski_ thought it was the old small one in e.g. hugs
13:26:17 <xerox> (It is indeed possible)
13:26:40 <ski_> (Parsec being that one's bigger sister, so to speak)
13:27:20 <Frederick> hi ski!
13:27:35 <JKnecht> @fact Cyc
13:27:36 <lambdabot> I know nothing about cyc.
13:27:41 <ski_> hi Frederick ..
13:30:44 <Frederick> @fact cyk
13:30:45 <lambdabot> I know nothing about cyk.
13:34:23 <Frederick> guys can I write something like figure 2 straightly in haskell? http://img274.imageshack.us/img274/3616/desktop14kf.jpg
13:35:01 <boegel|home> Frederick: you might want to take a look at HaskLS
13:35:30 <ski_> Frederick : you need some way of transliterating the set expressions
13:36:07 <ski_> look at Data.Set, e.g.
13:36:15 <Frederick> ski_, lemme check
13:36:49 <ski_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
13:38:04 <ski_> possibly you could use Data.Set.fromList and use pass a list [ ... ] to that instead of doing { ... } as in the figure
13:38:55 <Frederick> k
13:42:07 <Frederick> guy gtg thx a lot
13:42:19 <ski_> m
14:03:05 <vina> hi guys... have someone here tried programatica tools?
14:03:52 <vina>  http://www.cse.ogi.edu/PacSoft/projects/programatica/
14:06:14 * ski_ thinks it's been discussed before here, some ..
14:06:56 <vina> ski_: thanks, i'll see the logs
14:12:32 <boegel|home> vina: is it like some IDE ?
14:13:06 <ski_> it's refactoring-related, iirc (haven't looked at it)
14:16:23 <lisppaste2> int80_h pasted "hugs error" at http://paste.lisp.org/display/12681
14:18:29 <poetix> http://codepoetics.com/poetix/index.php?p=164 <- Does Haskell have a good story for service component architectures?
14:18:43 <int80_h> hi guys, can anyone check out the problem I posted?
14:19:43 <ski_> i think (at least in hugs) 'isDigit' was in module Prelude before .. now otoh
14:19:46 <boegel|home> @index isDigit
14:19:47 <lambdabot> Data.Char
14:19:47 <ski_> @index isDigit
14:19:48 <lambdabot> Data.Char
14:19:51 <ski_> :)
14:20:17 <ski_> so, just remove 'isDigit' from the  'import Prelude hiding ( ... isDigit, ...)'
14:20:33 <boegel|home> int80_h: maybe the isDigit function has moved, you should adjust Chapter3.lhs so it doesn't hide isDigit anymore... should be fairly easy
14:21:46 <int80_h> ERROR "Chapter3.lhs" - Unknown entity "toUpper" hidden from module "Prelude"
14:21:53 <int80_h> now I get this
14:22:08 <int80_h> I had no trouble using this code on another machine
14:22:48 <ski_> import Char (toUpper)
14:22:50 <vina> boegel|home: I think it's more like a Haskell browser
14:22:51 <int80_h> hmm this computer seems screwy
14:23:01 <ski_> possibly earlier version of hugs ?
14:23:22 <ski_> (s/Char/Data.Char/ for hierachical libs)
14:23:24 <int80_h> ah yes on another machine with earlier version it works okay
14:23:33 <int80_h> Nov 2003 is the one giving trouble
14:25:45 <rafl> SyntaxNinja: Can you tell me why ghc-pkg accesses all dirs that are listed in the include-dirs line of the .installed-pkg-config when registering a new package? is that really needed? If yes: Is there a way for cabal files to declare dirs for include headers without using include-dirs?
14:25:56 * boegel|home leaves for bed, g'night everyone !
14:26:31 <int80_h> well I think the solution here is to just use the server with the hugs version that is not giving me problems
14:35:34 <cinema> int80_h, hugs & ghc have been unified (and will stay so), so correct your sources & use the most recent version of hugs
14:44:01 <int80_h> hmmm
14:44:12 <int80_h> well I can't explain why the newer version gave me that trouble
14:44:28 <int80_h> these are binaries
14:44:32 <int80_h> installed by my admin
14:45:12 <int80_h> so would you suggest I recompile with new source?
14:46:56 <int80_h> I'm using the latest at home but I'd like to have a good install on this server
14:56:05 <ski_> which are binaries ?
14:56:14 <ski_> is Chapter3.lhs compiled ?
14:56:48 <int80_h> hugs is compiled
14:57:07 <int80_h> I mean is was pre-compiled
14:57:17 <int80_h> not installed from source
14:57:23 <ski_> ok .. the trouble here was that the source in Chapter3.lhs was incompatible ..
14:57:51 <ski_> (depending on old hugs quirks ..)
14:57:58 <int80_h> ah
14:58:17 <ski_> so, the proper fix is to change Chapter3.lhs ..
14:58:26 <int80_h> indeed. thank you
14:58:33 <int80_h> this will be a lesson for me
14:58:37 <int80_h> where do I begin?
14:58:44 <ski_> fix the imports
14:59:37 <int80_h> I'm inporting the Prelude
14:59:41 <ski_> like removing the hiding of toUpper from Prelude .. and importing isDigit from Data.Char instead
14:59:55 <int80_h> ah
15:00:10 <ski_> (possibly some more things like this, too)
15:03:27 <int80_h> Reading file "Data.Char":
15:03:27 <int80_h> ERROR "Data.Char" - Unable to open file "Data.Char"
15:03:40 <int80_h> I'm a total newbie
15:03:59 <ski_> hm, possibly you don't have it set to use hierarchical libs
15:04:10 <ski_> in that case you could use 'import Char'
15:04:14 <int80_h> cool
15:04:33 <ski_> (hierarchical libs are the new nested instead of flat library structure)
15:05:20 * ski_ doesn't remember exactly now how to set it to hierachical libs ..
15:06:57 <int80_h> ERROR "Chapter3.lhs":81 - Definition of variable "toUpper" clashes with import
15:07:09 <int80_h> I tried hiding this, seemed to not work
15:07:20 <ski_> import Char hiding (toUpper)
15:07:31 <ski_> import Char (isDigit) hiding (toUpper)
15:07:41 <ski_> if you want to do both ..
15:08:39 <int80_h> still getting the error
15:08:49 <int80_h> >       import Char hiding (toUpper)
15:08:54 <int80_h> did that
15:09:15 <ski_> try 'import Char (isDigit) hiding (toUpper)' instead ..
15:09:39 <int80_h> that's odd that I wouldn't have to use quotes for the other import
15:09:42 <int80_h> but I'll try
15:09:47 <ski_> sorry
15:09:53 <ski_> no quotes in file
15:10:06 <Cale> hiding is only necessary if you don't declare which things you want to import, isn't it?
15:10:30 <ski_> hm, right
15:10:43 <int80_h> yeah what would specifying isDigit have to do with the conflict I'm having with toUpper?
15:10:45 * ski_ is too tired
15:10:52 <int80_h> no worries, I appreciate your help
15:11:07 <int80_h> thanks to you I'll get it working right
15:11:10 <ski_> i was just thinking you might have two (or more) lines for importing Char ..
15:11:19 <int80_h> no just the one
15:11:21 <sethk> int80_h, he was saying, I think, import just isDigit
15:11:22 <ski_> ok
15:11:29 <sethk> ?
15:12:10 <Cale> what's the actual problem?
15:12:14 <ski_> and you use new hugs version ?  (and toUpper is not exported from Prelude in that ?)
15:12:15 <int80_h> yes sethk, I understand that part. But I'm trying to fix the clash error. I was wondering what the importing of just isDigit would fix the clash with toUpper
15:12:36 <sethk> int80_h, perhaps everything is being imported from Char, including the clash
15:12:46 <int80_h> you tell me ski, I tried hiding it from Prelude as well. Let me go check the prelude and see :)
15:12:50 <sethk> int80_h, so if you import just one thing from Char, then nothing _else_ is imported from Char
15:13:03 <ski_> Cale : http://paste.lisp.org/display/12681   he's trying to convert old hugs idiosyncrastic code to more compatible ..
15:13:03 <int80_h> but seth, I need other things from char
15:13:24 <sethk> int80_h, ok, I was just saying that mentioning isDigit is necessarily irrelevant
15:13:25 <int80_h> oh is this just a troubleshooting step?
15:13:28 <int80_h> I get it hold on
15:13:31 <Cale> Oh, the problem is likely that things which used to be in the hugs prelude are now in Char
15:13:42 <ski_> right
15:13:44 <int80_h> and I learned a new thing :)
15:13:46 <Cale> can I see Chapter3.lhs?
15:13:52 <int80_h> yeah I will post it
15:14:38 <Cale> Somewhere you'll probably see import Prelude hiding ...
15:14:55 <Cale> and if it lists isDigit, you'll have to remove that from the list
15:15:51 * ski_ is not here
15:15:56 <int80_h> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/Code/Chapter3.lhs
15:16:15 <int80_h> okay I need to work on these programming tasks and fix this later
15:16:33 <ski_> >	import Prelude hiding (max,toUpper,isDigit)
15:16:38 <ski_> should be changed to
15:16:49 <ski_> >	import Prelude hiding (max)
15:16:53 <int80_h> I did that
15:17:27 <ski_> ah
15:17:53 <ski_> it defined toUpper as well (instead of importing it originally from Prelude and using it)
15:18:26 <int80_h> okay I keep getting errors when I try what you tell me to try
15:18:42 <int80_h> and I want to work out these chapter assignments
15:18:53 <int80_h> but thank you for your help
15:18:58 <int80_h> I'll work it out
15:28:06 <JohnMeacham> dcoutts_: yup. that is part of my motivation for writing a compiler. all my work is doubly efficient.
15:28:33 <JohnMeacham> dcoutts_: it also forced me to learn Haskell twice as fast as I would otherwise.
15:28:51 <ndm> JohnMeacham: and the obscure bits as well
15:29:02 <sethk> there sure are some temporally disjointed conversations here
15:29:07 <ndm> i heard that from the guy that wrote hacle, he had to learn everything in haskell - even the bits no one uses
15:29:43 <JohnMeacham> sethk: yeah.. IRC needs threading..
15:30:10 <TheHunter> ndm, there are no things as "bits no one uses".
15:30:27 <JohnMeacham> except for implicit linear parameters...
15:30:43 <int80_h> what about the bit that turns your haskell into java?
15:30:56 * int80_h hears naught but crickets
15:31:03 <int80_h> ouch, tough crowd
15:31:47 <TheHunter> even those are used, although I'm not aware of any "serious" use.
15:32:16 <sethk> they aren't used, they are previously coded
15:33:07 <JohnMeacham> The design is quite inherently broken (for implicit parameters in general) making them tricky to actually use. I'd like to see linear parameters seperated from implicit ones though...
15:34:46 <sethk> separated
15:34:47 <TheHunter> Linear implicit parameters are totally broken (arguably, they could be less broken, but they still would be broken). There are also implicit parameter-quirks that should be fixed.
15:36:37 <ndm> TheHunter: default() ?
15:37:09 <TheHunter> Implicit paramters could be quite well-behaved (after all, they are just a provably commutative monad in direct style).
15:38:10 <TheHunter> ndm, the biggest issue is that recursive functions using linear implicit parameters without type signatures don't do the right thing (I would suggest just to reject them).
15:38:24 <JohnMeacham> Yeah, but I think they are not really a good idea. haskell has better ways to solve this sort of problem and they arn't very clean.
15:40:59 <TheHunter> I'm off to dinner, if you're interested, I'll elaborate in an hour or so on why I think they are a good idea (they are, however, not implemented in a perfect way right now).
15:43:48 <JohnMeacham> Mainly, I just think we would be better served by a different extension.. like a monad syntax for monads where order doesn't matter. (like a reader monad, or commutative writer monad). that would act more or less the same as implicit parameters but with much clearer semantics and be more generally useful.
15:44:37 <JohnMeacham> Is there a name for that sort of monad by the way? commutative monad?  where a >> b >> c == b >> a >> c? (perhaps there is a better way to say it)
15:45:16 <ski_> ma >>= \a -> mb >>= \b -> return (a,b)   =   mb >>= \b -> ma >>= \a -> return (a,b)
15:46:43 <ski_> hm .. how to express that in CT-speak .. ?
15:50:15 <ski_> mu . M (strength . (A * g)) . flip_strength . (f * B)  =  mu . M (flip_strength . (f * B)) . strength . (A * g)     ?
15:51:13 <ski_> (in the kleisli category i think it becomes     (A * g) . (f * B)  =  (f * B) . (A * g)   ..)
15:51:41 <ski_> hm
15:52:03 <ski_> mu . M (strength . (C * g)) . flip_strength . (f * B)  =  mu . M (flip_strength . (f * D)) . strength . (A * g)     ?
15:52:24 <ski_> in kleisli :   (C * g) . (f * B)  =  (f * D) . (A * g)
15:52:34 <ski_> given    f : A -> M C    g : B -> M D
15:54:04 * ski_ wonders if this isn't just that the product is a bifunctor in the kleisli category ..
15:55:24 <yaarg> yeah
15:59:22 <ski_> (and of course   forall A,B. strength : (A * M B) -> M (A * B)   flip_strength = M flip . strength . flip)
16:07:07 <syntaxfree> can I compile Haskell-produced C files in a computer that has no GHC?
16:07:41 <ndm> syntaxfree: yes
16:08:00 <ndm> with appropriate libraries etc.
16:08:04 <syntaxfree> I uploaded all the .h files in /sw/lib/ghc-6.2/include, but I couldn't' :~
16:08:19 <ndm> the runtime will be somwhere
16:08:27 <ndm> it will need that, as a library
16:08:54 <syntaxfree> well, the machine I'm running is a Mac. The other box is running Gentoo on a x86-64.
16:09:16 <ndm> i'm not sure, ghc might go platform specific in the code...
16:09:23 <syntaxfree> :(
16:09:29 <ndm> you'll need to ask someone with deeper ghc internals knowledge
16:09:58 <Igloo> It will be easier to just install ghc and compile it on the other one
16:10:00 <syntaxfree> I see. Thanks, anyway.
16:10:02 <ndm> or just install ghc...
16:10:11 <syntaxfree> I have a limited  account there, and the owner is unreachable.
16:11:20 <syntaxfree> syntax@box ~ $ cat cobras.c | grep "#include"
16:11:20 <syntaxfree> #include "Stg.h"
16:11:20 <syntaxfree> #include "HsBase.h"
16:11:40 <syntaxfree> syntax@box ~ $ ls *.h | wc -l
16:11:40 <syntaxfree> 63
16:11:40 <syntaxfree> oh me :~
16:49:57 <syntaxfree> @ping
16:49:59 <lambdabot> bzzt
16:50:11 <syntaxfree> @bzzt
16:50:12 <lambdabot> Unknown command, try @listcommands.
16:58:16 <TheHunter> Reader monads have properties which go beyond those of just commutative monads. For example, m (a -> b) and a -> m b are isomorphic and so are m (a,b) and (m a, m b). When you are using implicit parameters, you are exploiting these properties all the time, and it's really cumbersome to do the same thing explicitely.
16:59:27 <syntaxfree> @fact-set reader-monads Reader monads have properties which go beyond those of just commutative monads. For example, m (a -> b) and a -> m b are isomorphic and so are m (a,b) and (m a, m b). When you are using implicit parameters, you are exploiting these properties all the time, and it's really cumbersome to do the same thing explicitely.
16:59:28 <lambdabot> Fact recorded.
16:59:29 <TheHunter> That's reason I introduced the lbIO :: ((forall a. LB a -> IO a) -> IO b) -> LB b function in lambdabot.
17:00:21 <TheHunter> heh.
17:10:15 <syntaxfree> Wilma.
17:17:50 <syntaxfree> I insist. Wilma.
17:24:39 <aqua_scummm> is there any forum for haskell users?
17:24:43 <aqua_scummm> google came up with nothing
17:24:55 <syntaxfree> start with haskell.org?
17:25:10 <aqua_scummm> theres a forum there?
17:25:30 <syntaxfree> there's the Hawiki. It's a forum.
17:29:06 <aqua_scummm> when you access a list, does haskell check if the list will ever change, and if not, store it in memory?
17:29:19 <aqua_scummm> or does it compute the values everytime
17:29:38 <aqua_scummm> and if the latter, how can one keep one in memory for fast access?
17:30:01 <mauke> what do you mean by "will ever change"?
17:30:21 <aqua_scummm> like athe list [1,2,3,4] is always going to be that
17:30:57 <aqua_scummm> but if you define a listfilled with variables that may change
17:31:04 <mauke> variables don't change
17:31:21 <aqua_scummm> oh even list elements?
17:31:44 <aqua_scummm> ok
17:31:51 <aqua_scummm> so does it store it in memory for fast access?
17:31:53 <mauke> how would you change them?
17:32:00 <mauke> with an assignment operator?
17:32:03 <syntaxfree> Wilma Wilma.
17:32:21 <aqua_scummm> i was thinking if you defined a list, based on a function that reads input or something
17:32:36 <aqua_scummm> i dunno, thought there might be a way to
17:32:55 <mauke> it won't recompute known values
17:33:13 <aqua_scummm> ok, good, thats what iwas hoping
17:33:14 <aqua_scummm> thanks
17:33:30 <TheHunter> Wilma?
17:40:58 <syntaxfree> Wilma :(
17:41:17 <ski_> TheHunter : LB ?
17:47:57 <ski_> TheHunter : what does 'lbIO' do ?   (i suppose i could go RTFS .. sometime)
18:01:33 <dons> @seen CosmicRay
18:01:34 <lambdabot> I saw CosmicRay leaving #haskell 4 hours, 6 minutes and 4 seconds
18:01:34 <lambdabot> ago.
18:01:51 <dons> CosmicRay, hs-plugins doesn't depend on a registerised ghc, it depends on a working Linker.c
18:02:02 <dons> so it does work on sparc-*, powerpc-* etc.
18:02:14 <dons> ghci works on alpha, so so should hs-plugins
18:02:36 <dons> the archs that hs-plugins won't run on are basically the weird ones that don't have ghci either, like mips64
18:03:38 <dons> I'm concerned you over-estimated the platforms hs-plugins doesn't run on :}
18:04:01 <ski_> (hm, possibly a @tell or @later-tell would be nice ..)
18:04:20 <dons> ski_, some  kind of Map that people can look up later?
18:04:25 <ski_> no
18:04:48 <DonS> hehe
18:05:11 <ski_> one can store notes and lambdabot will tell them later when the person joins channel and/or speaks on channel
18:05:20 <ski_> sarahbot in #scheme does this
18:05:30 <DonS> ah. interesting.
18:05:39 <DonS> so it *is* a Map User String
18:05:50 <DonS> connected to the join notice code
18:05:54 <DonS> this is a good idea
18:06:02 <ski_> so, one doesn't look up oneself, it itself looks up and tells when person comes online and/or becomes active
18:06:06 <ski_> yes
18:06:12 <DonS> @todo-add sarahbot style @tell
18:06:15 <lambdabot> Entry added to the todo list
18:06:34 <DonS> that's twice now people have wanted sarahbot features in lambdabot
18:06:41 <ski_> iirc 'tell' in sarahbot works on join, while 'later tell' works on action on channel  (icbw, though)
18:06:46 <ski_> :)
18:06:52 <ski_> what was the other one ?
18:07:31 <ski_> (maybe .. a private version, which uses /msg would be good, too ..)
18:08:46 <dons> btw, what's this 'memo' function when you register with freenode?
18:09:20 <Dibrom> memoserv?
18:09:42 <dons> ah, yes.
18:09:48 <dons> and I see I have a memo. let me see..
18:09:55 <Igloo> Essentially never used IME
18:10:11 * ski_ has used memoserv
18:10:13 <Igloo> But maybe lightweights who aren't online 24/7 use it more  :-)
18:11:20 <Dibrom> dons: you are one of the guys working on hIDE, right?
18:11:26 <dons> yep
18:11:31 <Dibrom> is it usable?
18:11:38 <dons> for what purpose?
18:12:01 <Dibrom> usable as in stable enough to do some basic development stuff in haskell :)
18:12:05 <dons> no
18:12:23 <dons> it's usable for further hacking of hIDE :)
18:12:55 <TheHunter> ski_, LB is a wrapped ReaderT r IO. lbIO encapsulates the common pattern (which is REALLY painful to implement otherwise) that we sometimes need exploit the isomorphisms I stated. For example, you usually can't use forkIO in ReaderT r IO. lbIO allows you to do lbIO (\conv -> forkIO (conv m1) >> conv m2).
18:12:59 <dons> ski_, does @tell do the same thing, rougly, as MemoServ?
18:13:00 <Dibrom> I was trying to compile it the other day but had problems accessing one of the repositories.. maybe I will try again
18:13:54 <dons> it's fun to play with, and does some cool thing, but is still just getting hacked together
18:14:11 <ski_> dons : .. well it displays the message immediately .. (upon join resp. activity  on channel)
18:14:39 <TheHunter> ski_, I could have done lbIO' :: LB (IO a -> IO a), but unfortunately not lbIO' :: LB (forall a. LB a -> IO a), so I decided to use CPS.
18:14:39 <ski_> dons : people how 24/7 use it much too, from what i've seen
18:14:45 <ski_> s/how/who/
18:16:16 <dons> yeah, upon join, not just connect
18:16:50 <TheHunter> maybe upon the person saying something in the channel?
18:17:28 <dons> TheHunter, good idea. hmm. do we have that information?
18:17:36 <ski_> dons : or even just when the wake up and says something on channel (or do some other action)
18:17:44 <dons> oh, @seen has roughly that data
18:17:55 <ski_> (right)
18:17:55 <TheHunter> we have callbacks for that.
18:18:56 <ski_> (TheHunter : i will have to think about lbIO later .. too tired now)
18:20:15 <ski_> night #haskell
18:20:22 <dons> nigh ski
18:20:22 <TheHunter> 'night
18:20:24 * ski_ leaves
18:27:58 <Dibrom> @where ghc-api
18:27:59 <lambdabot> I know nothing about ghc-api.
18:28:09 <Dibrom> :)
18:28:13 <dons> doh
18:28:19 <dons> hmm :/
18:28:36 <dons> @google Lemmih ghc-apii
18:28:38 <lambdabot> No result found.
18:28:38 <dons> @google Lemmih ghc-api
18:28:39 <tony2> Anyone know ghc phase options well here? (and care to spend a minute helping out with a quick question)
18:28:40 <lambdabot> http://scannedinavian.org/~lemmih/ghc-api/
18:28:51 <dons> tony2, go for it
18:28:57 <Cale> http://www.scannedinavian.org/~lemmih/ghc-api/
18:29:00 <Cale> yep
18:29:15 <dons> @where+ ghc-api http://www.scannedinavian.org/~lemmih/ghc-api/
18:29:16 <lambdabot> ghc-api ~> http://www.scannedinavian.org/~lemmih/ghc-api/
18:29:32 <tony2> well, I've had to edit an intermediate .hc file, but don't know how to restart compilation after that.
18:29:47 <dons> just pass it to ghc on the command line
18:29:54 <dons> ghc will pick the phase based on the .hc suffic
18:29:59 <tony2> that easy?
18:30:05 <dons> should be, yes :)
18:30:10 <dons> you can compile .c files this way too
18:30:22 <tony2> well, cheers.
18:31:33 <dons> tony2, you're editing .hc files!?
18:31:39 <dons> bit of hacker fun?
18:32:58 <tony2> I'm learning about hdirect,
18:33:18 <tony2> and trying to bind to apache module api
18:33:36 <dons> ah!
18:33:43 <dons> didn't we have a couple of such bindings?
18:33:50 <dons> Lemmih worked on one, I think
18:33:52 <tony2> there is a mod_haskell
18:34:08 <tony2> which embeds ghci ala mod_perl
18:34:23 <tony2> but not a binding as far as I'm aware
18:35:12 <tony2> if there is one however I'd be most interested to have a look.
18:38:07 <tony2> I'm going via -fvia-C so as to pass -fpic to gcc. I haven't a clue if that'll work though! or if I'll have to build on a OSX box with -fPIC
18:39:02 <dons> right. it'll be a bit tricky.
18:39:18 <dons> you may have to consult glasgow-haskell-users@
18:42:16 <tony2> well it's only a bit of fun, I'll keep hacking away for now. It's only my second real Haskell project and it's mostly for learning purposes.
18:42:39 <dons> ah, cool. you're jumping into the deep end I see :)
18:43:01 <tony2> always :)
18:43:11 <dons> tony2, have you been on the #haskell tour yet?
18:43:23 <tony2> #haskell tour?
18:43:43 <dons> have you met lambdabot?
18:43:47 <dons> @version
18:43:47 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
18:43:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:43:56 <dons> lambdabot answers all our problems
18:44:03 <dons> @eval map (\x -> x + 1) [1..10]
18:44:10 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
18:44:14 <dons> @type map
18:44:16 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
18:44:21 <tony2> very clever
18:44:22 <dons> @kind Maybe
18:44:24 <lambdabot> * -> *
18:44:37 <dons> @google mod_haskell
18:44:39 <lambdabot> http://losser.st-lab.cs.uu.nl/mod_haskell/
18:44:50 <dons> and dozens of other interesting things
18:44:56 <dons> then we also have a wiki full of cool stuff
18:44:59 <dons> @hawiki
18:45:00 <lambdabot> http://www.haskell.org/hawiki/
18:45:07 <dons> possibly there's mod_haskell docs up there
18:45:21 <dons> if you want to know who you're talking to, check out :
18:45:22 <dons> @map
18:45:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
18:45:24 <tony2> I've stumbled across the wiki before I think.
18:45:34 <dons> then we have logs (check the /topic)
18:45:41 <int80_h> Here's the problem, U
18:45:45 <int80_h> eep sorry
18:46:10 <dons> now, what else, stuff we talk about sometimes filters through to the haskell weekly news,
18:46:16 <int80_h> Okay I have a function averageThree, using that I want to write this function howManyAboveAverage
18:46:27 <dons> and a lot of The Monad Reader gets planned here
18:46:40 <dons> so if you're doing some tricksy haskell hacking, feel free to hang out and ask questions
18:46:47 <int80_h> the model in my head is convoluted as hell, I know there must be an easier way. Anyone interested in helping me sort this out by being my sounding board?
18:47:16 <Cale> int80_h: I'd translate the problem to lists
18:47:19 <tony2> thanks for the tour, is that a mailing list, the haskell weekly news?
18:47:26 <int80_h> oops, here's the function howManyAboveAverage :: Int -> Int -> Int -> Int
18:47:30 <dons> it's published on haskell@haskell.org
18:47:32 <int80_h> Cale, can't use lists yet
18:47:38 <Cale> tony2: no, but it takes stuff from the mailing lists
18:47:41 <dons> ther's some other mailing lists, you'll find linked on the haskell.org site
18:47:54 <int80_h> This is from chapter three of this book I checked out The Craft of Functional Programming
18:48:01 <dons> I recommend haskell@haskell.org, haskell-cafe and glasgow-haskell-users@
18:48:04 <int80_h> I'm doing the self study thing
18:48:26 <Cale> int80_h: okay
18:48:38 <Cale> int80_h: so it's going to likely break up into cases
18:48:49 <int80_h> Cale, right now I have an idea of using logical operators, but I would have to test for every permutation
18:49:12 <Cale> int80_h: do you have a sortThree function?
18:49:12 <int80_h> Cale, I want to reduce the number of cases I have in my head
18:49:24 <int80_h> is that in the Prelude for hugs?
18:49:27 <Cale> no
18:49:45 <Cale> But sorting them first would reduce the number of cases
18:49:48 <int80_h> well I could probably write it, but it's cheating you know
18:49:49 <tony2> very good, I'll subscribe to one I think. I wrote a project in haskell for my thesis and it kinda spoilt Java programming for me.
18:50:00 <int80_h> I want to limit myself to what
18:50:07 <int80_h> to what's been covered in the book so far
18:50:25 <Cale> There's only 2^3 = 8 cases
18:50:32 <int80_h> well let me tell you how many cases I'm looking at. I suspect I'm thinking about this entirely wrong
18:50:42 <int80_h> Cale, yeah that's it 8
18:50:49 <int80_h> for some reason I thought it was getting out of hand
18:51:10 <Cale> It is a little out of hand. You wouldn't tend to do something like that directly
18:51:10 <int80_h> 2^3, not 3^3?
18:51:36 <Cale> each position is either over the average, or not
18:51:42 <int80_h> ah right
18:52:05 <Cale> Now, if that's strictly greater than, you only have 7 cases
18:52:07 <Dibrom> int80_h: you're just averaging 3 numbers and determining which of each is above the average?
18:52:12 <int80_h> so I was thinking in terms of doing a logical operator
18:52:15 <int80_h> right, exactly
18:52:47 <Dibrom> well
18:52:58 <int80_h> Cale like this | x<Above(x y z) && y<(Above x y z) z<(Above x y z) = 3
18:53:06 <Dibrom> why not: f x y z = let { avg = (x+y+z)/3; x' = if x > avg then 1 else 0; y' = if y > avg then 1 else 0; z' = if z > avg then 1 else 0 } in x'+y'+z'?
18:53:15 <Dibrom> unless I'm misreading something
18:53:34 <Cale> ah, that's a nice way to do it :)
18:53:48 <Dibrom> :)
18:53:52 <Julian> Hi folks
18:53:54 <int80_h> trhe way I read that either 1 or 0 is getting returned
18:53:58 <dons> afternoon Julian :)
18:54:07 <dons> @localtime Julian
18:54:08 <Cale> int80_h: for each of x', y' or z'
18:54:09 <lambdabot> Local time for Julian is Wed Oct 19 23:11:23 2005
18:54:10 <dons> or is it night?
18:54:19 <Julian> night
18:54:22 <Dibrom> no, x', y', z' is getting bound to 0 or 1 if each one is above average, then you just sum it at the end and get your answer
18:54:26 <dons> ah, much later :) the pacific is *big*
18:54:26 <Julian> ;)
18:54:28 <nuffer> is it possible to implement a parser generator in haskell without any metaprogramming extensions?
18:54:32 <int80_h> Dibrom I can do that, but it's outside the parameters of the book I'm using
18:54:36 <Julian> Rosario, Argentina
18:54:39 <Cale> nuffer: yes
18:54:45 <int80_h> meaning, this is just chapter 3, and I haven't gotten to that notation yet
18:54:49 <Dibrom> int80_h: why? that's about as basic as you can get
18:54:54 <Dibrom> no lists, nothing real fancy
18:55:00 <dons> nuffer, of course. requiring metaprogramming would be weird!
18:55:01 <nuffer> like, one that would give a haskell function that could do the parsing, not write out a source file for a haskell parser
18:55:02 <int80_h> hmm okay maybe I missed it let me go look for it
18:55:03 <cjs> Does Haskell have anything like SML/NJ's quote/antiquote stuff?
18:55:03 <Dibrom> only let statements and if then else
18:55:15 <int80_h> x', that looks new to me
18:55:23 <Dibrom> x' is just a variable name
18:55:26 <Cale> nuffer: well, do you mind the parser being generated at runtime?
18:55:29 <Dibrom> you could calle it foo if you want
18:55:38 <int80_h> oh I thought it meant "for each"
18:55:39 <Cale> nuffer: and have you looked at Parsec?
18:55:42 <nuffer> well, it would be nice if it were generated at compile time, honestly
18:55:43 <nuffer> no
18:55:46 <Dibrom> x' is a good name though because it shows some relation to the previous x :)
18:56:18 <int80_h> although the let look new too
18:56:19 <dons> you want compile time generated? but without a two-stage generator, a la happy?
18:56:19 <Cale> nuffer: well, you'd need template haskell to do something like that at compile time, I'd think, unless you could rig something up with the typesystem
18:56:39 <nuffer> and template haskell is metaprogramming =/
18:56:40 <Cale> but look at Parsec
18:56:43 <Cale> right
18:57:00 <Cale> well, if you're talking about compile time generation of code, that's metaprogramming
18:57:02 <int80_h> oh yeah, let isn't covered yet
18:57:04 <dons> nuffer, you're asking explicitly for the metaprogramming way of solving the problem though.
18:57:13 <Cale> int80_h: how about "where"?
18:57:19 <int80_h> so given I shouldn't use let are we looking at the form I gave earlier?
18:57:21 <nuffer> well, what's a good alternative solution?
18:57:25 <Cale> Parsec
18:57:25 <int80_h> yeah I can use where
18:57:28 <dons> use happy or parsec
18:57:32 <Dibrom> hrmm
18:57:35 <Cale> Or ReadP
18:57:39 <nuffer> alright, let me read up on parsec
18:57:40 <Dibrom> that problem is hard to solve without let or where methinks
18:57:45 <Cale> @where parsec
18:57:46 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
18:57:46 <int80_h> I can use where
18:57:48 <dons> nuffer, happy is also good...
18:57:48 <nuffer> what does parsec even do?
18:57:54 <dons> parsing!
18:57:58 <Cale> It's a parser combinator library
18:58:07 <dons> it's the defacto standard for haskell, i would say
18:58:16 <Cale> Parsers are values, and you stick them together in various ways with combinators
18:58:28 <Dibrom> int80_h: then do "f x y z = x'+y'+z'", with where avg, x', y', z' are defined as I showed
18:58:31 <Julian> daan leijen
18:58:32 <Dibrom> that will work the same
18:58:43 <dons> @where happy
18:58:44 <lambdabot> http://www.haskell.org/happy/
18:58:54 <nuffer> okay, let me have a look
18:58:55 <nuffer> thanks
18:58:57 <Julian> @where bnfc
18:58:58 <lambdabot> I know nothing about bnfc.
18:59:39 <dons> what's bnfc?
18:59:48 <Julian> BNF Converter
18:59:56 <dons> ah, do you have a url?
19:00:00 <Julian> parser, pretty printer, etc generator
19:00:07 <Julian> yea
19:00:09 <dons> yeah, I'd forgotten the name
19:00:18 <dons> this is the utrecht thingy?
19:00:21 <dons> or no chalmers
19:00:26 <Julian> Chalmers
19:00:29 <Julian> yes
19:00:57 <Julian> http://www.cs.chalmers.se/~markus/BNFC/
19:01:26 <dons> @where+ bnfc http://www.cs.chalmers.se/~markus/BNFC/
19:01:27 <lambdabot> bnfc ~> http://www.cs.chalmers.se/~markus/BNFC/
19:03:13 <Julian> wow, ctrl + alt + backspace
19:03:19 <Julian> ;)
19:03:37 <Julian> @where bnfc
19:03:37 <lambdabot> http://www.cs.chalmers.se/~markus/BNFC/
19:09:36 <nuffer> what's a good haskell IDE for windows?
19:10:08 <Dibrom> supposed to be some haskell thing for visual studio I think, and there's one for eclipse
19:10:09 <nuffer> is the eclipse support good?
19:10:11 <Dibrom> if you use either of those
19:10:15 <Dibrom> it's decent
19:10:33 <Cale> I'd probably just use emacs :)
19:10:40 <Dibrom> I tried it once, not all that bad.. I'm spoiled with the indentation support on the emacs mode though.. eclipse doesn't have something similar AFAICT
19:10:40 <Julian> ;)
19:10:54 <Julian> just vi
19:10:58 <Dibrom> yeah, if you can use emacs, it's pretty good
19:12:38 <Dibrom> nuffer: if you try out emacs, and you need project management stuff, you can use ecb with it too, which works alright
19:15:31 <Cale> Yeah gvim runs on windows too I'm fairly sure
19:16:12 <Cale> Usually, I need emacs on windows, because it's the only decent easily installed shell
19:16:56 <Cale> (one could install cygwin, but last time I did, it was annoying enough that I might as well have created another partition and installed debian)
19:17:10 <dfgp> gvim runs well on windows
19:17:18 <dons> I think debian provides a nice shell, and debian is easily installed on (top of) windows ;)0
19:17:53 <Cale> dons: dual booting, or do you mean something else?
19:18:06 <dons> rm -rf * -style
19:18:15 <Cale> heh
19:18:25 <syntaxfree> I don't understand why people are so fond of IDEs.
19:18:51 <Cale> syntaxfree: neither do I, though some of the features of hIDE sound cool :)
19:18:56 <dons> syntaxfree, now you can update your coordinates!
19:18:58 <dfgp> There's always colinux, I suppose.
19:19:20 <syntaxfree> I would, but Im kinda sad. Quarrelled with the lady.
19:19:21 <Cale> dons: usually the people who have these windows machines wouldn't like it if I did that.
19:20:13 <dfgp> People like IDEs because they make them more productive at whatever it is they do.
19:20:59 <dfgp> I don't think people sit around and look at them because they're pretty.
19:21:09 <dfgp> "Oooh ahhh"
19:21:17 <Cale> Do they really though?
19:21:25 <Cale> Or do they look at the pretty things?
19:21:27 <dfgp> Probably.
19:21:37 <syntaxfree> what does ghci's :def do?
19:21:51 <dons> maybe if you don't like the shell/unix ide, then some custom ide is useful
19:22:14 <syntaxfree> I'd like a Scheme-like REPL for Haskell
19:22:24 <Cale> Most IDEs seem to exist simply because the OSs that they run on are deficient in various ways
19:22:46 <dons> I agree Cale. luckily hIDE can also just be seen as an emacs
19:22:49 <syntaxfree> what's wrong with Screen & vim?
19:23:07 <dons> editors sufficiently featurefull are indistinguishable from ides
19:23:12 <Cale> syntaxfree: in ghci, you can use let to define things, but you can't make general declarations
19:23:15 <ozone> Cale: have you ever used visual studio?
19:23:20 <ozone> for serious work?
19:23:20 <Cale> ozone: yeah
19:23:24 <syntaxfree> cale: I know :)
19:23:26 <dfgp> Well given that there are IDEs for all major desktop platforms, I'll leave you to fill in the blanks.
19:23:27 <tony2> In my opinion IDE's are invaluble for OO programming (dot complete) but not Functional programming.
19:23:28 <ozone> checked out its awesome debugger?
19:23:37 <Cale> ozone: moderately serious
19:23:47 <syntaxfree> @eval let myfunction x = x ++ "knows" in myfunction "syntaxfree "
19:23:54 <lambdabot> "syntaxfree knows"
19:23:56 <ozone> fair enough then
19:24:11 <Cale> It has a decent debugger, but one with features that would only be needed when using a language like C or C++
19:24:26 <ozone> i beg to differ
19:24:28 <Julian> syntaxfree: burned!
19:24:31 <Julian> ;)
19:25:42 <dons> ozone, and obj C too I guess. but not Haskell surely
19:25:46 <Cale> ozone: like, I'm not going to care about setting breakpoints in Haskell code, that isn't really even meaningful
19:26:29 <syntaxfree> how good is obj c as compared to c++?
19:26:30 <ozone> i'd love to be able to set breakpoints in haskell code
19:26:40 <Cale> If I stop the program, change a declaration and then let it continue, then I might just end up with inconsistently defined values
19:26:42 <dfgp> 'good' is relative
19:26:51 <ozone> the stuff that robert ennals showed with hdb and optimistic haskell was rather nice, pity it'll never get merged
19:26:53 <Cale> ozone: what would it even mean?
19:26:54 <dons> ozone, you have that many bugs in your .hs ??
19:26:54 <Dibrom> sometimes graphical/ide-ish things can be sort of neat though.. like the inspector in alice ml, or explorer in oz
19:26:59 <syntaxfree> if you could use just one language for everything?
19:27:00 <ozone> dons :P
19:27:05 <Dibrom> though those aren't probably what most people would think of as ide per se
19:27:20 <ozone> dons: i think that even you would value something along the lines of an interactive profiler
19:27:39 <ozone> stop a process, take snapshots, observe memory usage, continue, etc
19:27:43 <Cale> I'd like a tool which could show a dependecy graph of functions in a module
19:28:04 <dfgp> If I could use language for everything it wouldn't be any member of the C family.
19:28:05 <dons> maybe maybe ozone
19:28:07 <Cale> Something like HOPS for Haskell would also be really cool.
19:28:59 <Dibrom> obj c and c++ are way different.. serve mostly different purposes
19:29:17 <Dibrom> c++ is more "powerful" than obj c though if you take template metaprogramming into account
19:29:32 <Dibrom> otherwise you can do most interesting stuff in c++ pretty well in obj c
19:30:20 <Cale> They're both OO imperative languages :)
19:30:29 <Dibrom> yeah
19:30:35 <Dibrom> but those have their places :)
19:30:46 <syntaxfree> different purposes?
19:30:51 <Cale> But it means that they could only be so different.
19:30:52 <syntaxfree> what is obj c good for?
19:31:00 <Dibrom> syntaxfree: GUI stuff
19:31:05 <Dibrom> objc is dynamically typed
19:31:11 <Dibrom> it's a lot different than C++ just cause of that
19:31:21 <dfgp> Sort of.
19:31:24 <Dibrom> inheritance type stuff in C++ is almost always done differently in obj c
19:31:29 <Dibrom> because of different models
19:31:47 <Dibrom> dfgp: well, yeah, only when dealing with objects.. but if you're using obj c, you're probably doing that
19:31:51 <EdLin> obj c is a sort of cross between smalltalk and c
19:32:09 <dfgp> If you fed Smalltalk lead until it became retarded. ;)
19:32:17 <syntaxfree> obj c is dynamically typed?
19:32:19 <Cale> heheh
19:32:26 <syntaxfree> hmm. it's beginning to sound good.
19:32:28 <Dibrom> syntaxfree: obj c objects are, yes
19:32:40 <syntaxfree> I thought it was another superset of C like C++.
19:32:44 <Cale> Dynamically typed doesn't sound all that good to me :)
19:32:47 <syntaxfree> easier to learn, would you figure?
19:32:52 <Dibrom> it is.. it's C with smalltalk like objects
19:32:59 <dfgp> It's far less complicated than C++.
19:33:03 <Dibrom> but the extension is very conservative as compared to c++
19:33:14 <Cale> Yeah, it did have simplicity going for it
19:33:29 <Dibrom> no templates, no operator overloading, etc.
19:33:55 <syntaxfree> I don't know much C.
19:34:03 <syntaxfree> I did learn the syntax, but I never figured pointers out.
19:34:16 <Dibrom> going from C to obj c is probably easier than going from c to c++ for most people
19:34:53 <syntaxfree> do you need to use mallocs and pointers and stuff in obj c?
19:35:06 <Dibrom> you use retain, release, autorelease stuff
19:35:06 <dfgp> Yes, basically.
19:35:24 <EdLin> syntaxfree: I vaguely recall that openstep/gnustep has library functions that take care of stuff like Malloc
19:35:26 <Dibrom> it can be easier than C mem management, but if you don't know C mem management, you're screwed
19:35:55 <dfgp> NeXT's API has a reference-counting framework.
19:35:57 <EdLin> yeah, retain, release, etc.
19:35:58 <Dibrom> no garbage collector or anything like that
19:36:01 <tony2> --enable-objc-gc.
19:36:04 <syntaxfree> I see.
19:36:20 <syntaxfree> I'm better off with Scheme and Haskell, then ;-)
19:36:27 <dfgp> Using Boehm can break things, though.
19:36:37 <Dibrom> tony2: that's a real option?
19:36:49 <syntaxfree> question: in Fortran, Pascal, etc., do you need to do your own memory management?
19:36:55 <tony2> yes, for the Boehm-Demers-Weiser conservative garbage collector.
19:37:01 <Dibrom> syntaxfree: depends on what you're doing.. low level stuff can be good somtimes
19:37:09 <Dibrom> tony2: wow.. didn't know that one
19:37:16 <Dibrom> been programming obj c for awhile too
19:37:31 <dfgp> POC has a similar option, but I don't know how well it works.
19:37:55 <Dibrom> probably wouldn't be good to rely on that though
19:37:58 <Dibrom> esp for learning
19:38:00 <syntaxfree> Your typical Fortran program will be using low level facilities?
19:38:17 <Dibrom> it's a lower level programming model
19:38:23 <Dibrom> but I don't know fortran, so I can't say much
19:38:32 <syntaxfree> Fortran and Pascal look very high-level to me.
19:38:34 <Julian> MacOS X are implemented en obj c
19:38:37 <stepcut> Any used FunPtr's for callbacks from C? I keep getting the error, schedule: re-entered unsafely. Perhaps a 'foreign import unsafe' should be 'safe'?
19:38:50 <syntaxfree> But I know they've been used at Adobe for big app development, for instance.
19:38:53 <Dibrom> syntaxfree: it's relative.. high level compared to asm? sure.. compared to haskell? naa :)
19:39:08 <syntaxfree> compared to C...
19:39:17 <Dibrom> hrmm
19:39:31 <Dibrom> I don't think fortran or pascal are really "high level" compared to C
19:39:48 <Dibrom> do either even have the concept of a function pointer?
19:39:55 <dfgp> You should perhaps look at wikipedia or something.
19:39:59 <syntaxfree> I always thought of Pascal as higher level than C.
19:40:02 <EdLin> fortran has computed gotos. :-)
19:40:04 <Cale> Pascal seems very slightly higher level than C
19:40:20 <syntaxfree> I was surprised to find out how much serious development has been done in Pascal before C took over as the dominant language.
19:40:26 <Julian> Cale: yea
19:40:34 <Dibrom> Well, maybe I'm wrong.. *shrug*
19:40:48 <Cale> but it might just be crippled
19:40:52 <syntaxfree> parts of the original MacOS were written in Pascal.
19:40:54 <Cale> rather than higher level :)
19:40:58 <sethk> stepcut, that's a recursive call to a function that is not thread safe
19:41:10 <Dibrom> everything in Pascal I've ever been exposed to seemed pretty archaic to me
19:41:19 <Cale> though, there were versions of Pascal with an object system
19:41:19 <syntaxfree> TeX was originally written in Pascal.
19:41:35 <syntaxfree> Adobe Photoshop was originially written in Pascal.
19:42:30 <Cale> TeX was originally written in SAIL
19:42:51 <JKnecht> wasn't Occam a concurrent Pascal?
19:42:51 <tony2> If I had a pound for every time I've said "no no, not pascal, HA-skell"....
19:43:01 <Cale> and then in WEB which produces Pascal code
19:43:36 <sethk> UNIX itself of course was written in C
19:43:38 <JKnecht> if I did an hIDE, I'd call it Eddie.
19:43:41 <syntaxfree> I thought WEB: Pascal :: Literate Haskell : Haskell
19:44:01 <EdLin> CWEB is what Knuth uses / wrote now.
19:44:18 <EdLin> (C version of WEB)
19:48:17 <stepcut> sethk: how do I make my recursive call thread-safe ? write now the recursive function is, loop = loop
19:48:21 <EdLin> Dylan, which supports functional programming, looks a lot like Pascal
19:48:46 <Cale> stepcut: hm?
19:49:01 <stepcut> r, where is that paste page?
19:49:06 <Cale> @paste
19:49:07 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:49:08 <syntaxfree> I thought Dylan was a Lisp dialect.
19:49:21 <Cale> I didn't think so
19:49:46 <Dibrom> I thought it was related somehow too.. I hear a lot of lisp people talk about it.
19:49:49 <EdLin> syntaxfree: it's not a lisp dialect syntatically
19:49:49 <dons> yeah, it's got something to do with lisp, with objects
19:50:07 <Cale> oh, apparently it started out with a lisp-like syntax
19:50:23 <Cale> but now it looks like Algol
19:50:43 <EdLin> Cale: maybe it did when it was an internel Apple project.
19:51:33 <JKnecht> I loved Algol on Burroughs.
19:51:40 <Cale> The wikipedia page says that it's essentially a cleaned up version of CLOS
19:54:47 <dfgp> The object system is a bit less complicated than clos.
19:55:11 <dfgp> I've always thought of it as a scheme dialect with multimethods that adopted a Wirth-like syntax.
19:55:14 <JKnecht> that article makes it look like corporate CLOS.
19:56:29 <JKnecht> Quick read of it didn't make clear in what what it was 'cleaned up' relative to ANSI CLOS.
19:56:48 <Julian> obj c have a garbage collector
19:56:57 <Julian> i'm reading
19:58:48 <stepcut> Cale,sethk, dons: I put my code on the paste page -- anyone know why it dies? Thanks!
19:59:20 <Cale> stepcut: I'll have a look
20:01:44 <sethk> stepcut, overflowing the stack, I think
20:01:59 <Cale> stepcut: hmm... the evaluation of loop should cause your program to stop
20:02:13 <Cale> let me try something...
20:02:41 <Cale> hmm, perhaps not
20:03:05 <Cale> and it shouldn't overflow the stack because it's tail recursive
20:03:56 <Cale> though, my program which consists of:
20:03:59 <Cale> main = loop
20:04:01 <Cale> loop = loop
20:04:31 <Cale> uses 0% cpu in ghci and 100% when compiled
20:05:04 <Cale> when compiled with optimizations, it dies correctly
20:05:15 <Cale> printing loop: <<loop>>
20:05:38 <sethk> Cale, optimizes away the tail call?
20:06:03 <Cale> yeah
20:06:14 <Cale> you shouldn
20:06:26 <sethk> yes, that is a bit of an understatement
20:06:32 <Cale> er
20:06:43 <Cale> you shouldn't write infinite loops like that anyway :)
20:07:04 <sethk> but it looks so much like C
20:07:10 <stepcut> well, the real loop did other stuff, but I wanted to simplify to the essential
20:07:21 <Cale> oh okay
20:08:20 <stepcut> I am wondering if the bug is in my code (using FunPtr some invalid way), or if it is a ghc bug
20:08:38 <dons> could be ghc
20:09:16 <stepcut> a google search shows that the last time this error happen, Simon claimed it was a bug he had fixed in cvs (for ghc 6.2)
20:09:57 <stepcut> well, I am going to run out for a bit, I guess I will send an email to the ghc bugs list and see what they say ;)
20:14:09 <Cale> stepcut: writing audio software in Haskell?
20:14:52 <Dibrom> speaking of that, anyone know how well the openal stuff works?
20:15:15 <stepcut> Cale: yep. Next step is to get the oxygen 8 working with linux+haskell
20:16:00 <Cale> Dibrom: I saw OpenAL mentioned in the GHC 6.4 release notes, but I didn't see it in the libraries
20:16:02 <stepcut> I am going to make a little real-time virtual synth using yampa+opengl+SDL+jack+midi
20:16:14 <Cale> stepcut: cool :)
20:16:48 <Dibrom> it's listed in the library stuff.. I was starting to build ghc earlier and it seemed to recognize all the openal stuff I'd setup.  I didn't feel like waiting forever for a compile to try it out though :)
20:17:02 <Cale> http://www.haskell.org/HOpenGL/newAPI/
20:17:06 <Cale> hmm... :)
20:17:22 <Dibrom> stepcut: that sounds pretty cool
20:17:33 <stepcut>  Dibrom: only if it works :p
20:17:37 <Dibrom> yampa seems to be a little bit out of date though
20:17:44 <Dibrom> I was trying to play with it the other day
20:17:48 <Dibrom> to learn arrows
20:17:58 <stepcut> I have the OpenGL, SDL, stuff working. I am now trying to get the jack stuff up.
20:18:01 <Dibrom> but it's probably workable
20:18:26 <stepcut> Yeah, the yampa stuff is a bit dated -- but I think they may have something new, because they wrote a paper about Yampa+GADT
20:18:45 <stepcut> so, I was going to email me them and see  -- they indicated that they website is not keep especially up to date
20:19:08 <Dibrom> hrmm.. I would be very interested if that was the case
20:19:12 <stepcut> I want to use yampa for both the openGL UI and for the synthesis stuff
20:19:13 <Dibrom> (that they have something new)
20:19:22 <Dibrom> yeah
20:19:30 <Dibrom> I was going to try and write a little opengl game thingy with it
20:20:00 * stepcut is off to the cafe for a bit
20:28:38 <sethk> in ghci, can I use a type signature for a function I declare (at the command line) with let, as in let f x y = x+y   ?
20:28:56 <Dibrom> yeah
20:29:18 <Dibrom> let { f :: foo -> foo; f = bar }
20:29:37 <Dibrom> just put the type sig on a separate line
20:30:02 <Dibrom> oh, in ghci.. well that way would work on one line :)
20:30:27 <sethk> Dibrom, I know how to do it in ghc
20:30:30 <sethk> :)
20:30:40 <sethk> but I forgot the one line form, thanks
20:30:47 <Dibrom> np
20:31:22 <Dibrom> you might be able to do it some otherway, inline maybe
20:31:31 <Dibrom> not sure.. but you can do that with variables
20:31:40 <Dibrom> probably depends on how you want to define it
20:35:23 <Cale> in fact, you don't even need the braces
20:35:31 <Cale> since it's all on one line anyway
20:35:46 <Dibrom> how?
20:35:55 <Cale> let f :: foo -> foo; f = bar
20:36:02 <Dibrom> oh.. I didn't know you could do it like that
20:36:10 <Dibrom> does that work for do also?
20:36:18 <Cale> yes
20:36:21 <Dibrom> nice
20:47:38 <sethk> I'm writing to disk/reading from disk values for types declared with data.  What approaches come to mind?  I have found several but I want opinions on the best approach, if someone has an opinion they would like to share
20:49:20 <dons> so there's Read/Show, then the Binary, and newBinary classes, and also SerTH
20:49:53 <dons> if the're flat you could suck them in with mmap, and rebuild them with a parser perhaps
20:51:40 <sethk> dons, I thought about using parsec with a lexer.  I didn't see, though, how read would help me.  show is obvious.
20:52:02 <sethk> dons, but if I'm reading data in from the disk, I don't know how to tell read how much to read
20:52:07 <sethk> or to read a particular type,
20:52:09 <sethk> etc.
20:52:51 <dons> you provide a type annotation :)
20:53:57 <sethk> dons, actually I can do that probably.  But say I wrote an Int, using show.  It isn't obvious to me that read would reverse that process even if it knows that it is dealing with an Int
20:54:24 <dons> why?
20:54:48 <sethk> well, suppose I have two Int values back to back,   123   456
20:54:57 <sethk> how will it know that this isn't:  123456?
20:55:03 <Dibrom> you have to provide a way to differentiate them for it
20:55:04 <dons> but they won't be in that form
20:55:10 <dons> they'll be in a Show'd form
20:55:14 <sethk> yes, I know
20:55:18 <dons> i.e. [123,456] for example
20:55:25 <dons> so you just read :: [Int]
20:55:27 <Dibrom> yeah
20:55:31 <sethk> the point is, is the form unique?
20:55:43 <dons> when you provide a type annotation, it is
20:55:48 <sethk> ok,
20:55:53 <sethk> that would work, then.
20:56:03 <sethk> I'll play with it.  Thanks
20:56:19 <dons> so your file contains something like X { x = 123, y = "some string", ... }
20:56:24 <dons> and you read :: X
20:56:34 <dons> which parses the whole thing and builds an X value for you
20:57:00 <dons> it's slow, but it works simply. lambdabot uses this for persistent state
20:57:09 <sethk> dons, do you mean that read always reads a block of data surrounded by {} ?
20:57:37 <dons> no, it reads whatever corresponds to the 'show' instance for the type you have
20:57:56 <dons> for data, this usually has { }
20:58:12 <Cale> given that you're using record syntax
20:58:15 <sethk> oh, if I use show on the data record, rather than writing out each piece
20:58:21 <sethk> that's better
20:58:31 <dons> just show the whole state value in one go
20:58:33 <sethk> how slow is it?
20:58:42 <sethk> because this is an operation that will happen often
20:58:49 <dons> hmm. bit slower than a readFile? try it.
20:59:02 <sethk> readFile is not an option  :)
20:59:02 <dons> if that is an issue you then switch to Binary/packed versions of the same idea
20:59:31 <dons> but the principle is the same. Binary uses get/put instead of read/show
20:59:43 <sethk> ok.  so you think the overhead of converting to binary/packed is lower than the overhead associated with the formatted read
20:59:43 <dons> and you defined packed representations, rather than Strings
21:00:00 <dons> definitely. which is why ghc uses this for .hi files
21:00:50 <sethk> with ghci, at least, if a is type Int with value 100, show a produces "100".  If a is type Integer value 100, show produces "100"
21:01:24 <dons> luckily you know what type you're reading back in :)
21:01:46 <sethk> except for a few cases, yes.
21:01:49 <dons> so the appropriate instances of show/red get used
21:02:00 <dons> except for a few cases? so the type isn't statically known?
21:02:03 <sethk> I should probably do some testing of the performance of binary vs. show/read
21:02:23 <sethk> dons, the type is known, but the reason the type is known is that the schema is in my dictionary, and I have to read that first.
21:03:59 <dons> ah, interesting. so there's a fixed set of possible types?
21:04:48 <dons> perhapstag the possible options with a magic byte, then switch based on that byte
21:04:52 <sethk> dons, initially, yes, the ANSI/ODBC types.
21:05:18 <sethk> dons, yes, that's more or less what I do in the c++ version, although there are further complications
21:05:44 <sethk> dons, which I can handle by making the record type more complex, or monkeying around with the binary data before write/after read
21:06:03 <fworp> Hi, im playing around with wxhaskell, and i dont have any idea how to update the display of a 'Frame' or any contained control without either moving or resizing the window. I change the text attribute of a frame, and of a static text control, from within the command event of a timer, and i would like to somehow tell wx to go ahead and display the values accordingly.
21:06:51 <fworp> otherwise, i have to resize or move the windows for the new values of the text attributes to be displayed
21:07:16 <sethk> fworp, you can redisplay.  I worked with wx only a little bit, so I'm looking for the answer
21:07:23 <sethk> fworp, but there definitely is one.  :)
21:07:41 <fworp> ok, i tried repaint, stab in the dark, it didnt seem to do the trick
21:07:52 <sethk> fworp, I'm pretty sure at least one of the sample apps does it.
21:10:06 <Cale> hmm, repaint should work
21:10:13 <Cale> are you sure you're actually updating it?
21:10:28 <fworp> ill paste my code to a pastebin
21:10:32 <Cale> oh, it gets updated when you do a resize?
21:11:32 <sethk> Cale, he says move or resize updates
21:11:58 <sethk> Cale, I'm trying to find where I put wxhaskell here.  I'm sure it has at least one sample prog that does this.
21:12:06 <sethk> Cale, I only played with it for a couple of hours, though.
21:12:17 <Cale> the bouncing balls example does repaints
21:12:22 <Cale> which is on the webpage
21:13:38 <wchogg> Okay, I have a dumb question:  if I'm doing things with random numbers, the function type becomes ("blah" -> "blah" IO) right?  Then is there a way to compose this function with something that doesn't take in the IO type?
21:13:59 <Cale> blah -> IO blah
21:14:22 <Cale> @type (>>=)
21:14:32 <Cale> @type return
21:14:40 <Cale> lambdabot: you here?
21:14:43 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m
21:14:43 <lambdabot> b
21:14:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
21:15:23 <wchogg> Oh!  Okay, I think I get it now.
21:15:50 <Cale> wchogg: of course, you want to write as much of your program in terms of pure functions as possible
21:16:09 <Cale> and only collect random numbers and print results in IO
21:16:14 <dons> it's the lambdabot vs ghc time of day: load averages: 3.01, 2.92, 2.90
21:16:17 <sethk> I have a record with two fields.  One is a String, and the other is an enumeration.  I've defined show for the enumeration.  Do I use "deriving show" in the data statement?
21:16:43 <Cale> sure, that should work
21:18:53 <Cale> deriving (Eq, Show) -- might as well derive Eq while you're at it :)
21:19:03 <fworp> http://www.rafb.net/paste/results/257iIa39.html ok, theres my example, i just tested it again to make sure im not looney, and it still doesnt repaint
21:21:28 <sethk> Cale, then I would have to define Eq for my enumeration?
21:22:19 <Cale> that's derivable
21:22:35 <Cale> fworp: okay, I'll take a look
21:22:40 <fworp> thanks
21:26:08 * Cale compiles wxHaskell
21:28:39 <sethk> what is the function used to display the record in the pretty format?
21:29:19 <Cale> show?
21:29:53 <sethk> no, show doesn't.  But when I print out my Map, which means ghci prints each thing in the map, I get the right format.
21:30:20 <Cale> can I see the record definition?
21:30:47 <sethk> data TransactionLogMessage
21:30:47 <sethk>     = LogEntry LogCommand FileName
21:30:47 <sethk>     deriving (Show)
21:30:53 <sethk> LogCommand is an enumeration
21:31:08 <sethk> show LogCommand returns a string for a LogCommand value
21:31:17 <Cale> = LogEntry { leCommand :: LogCommand, leFileName :: FileName }
21:31:25 <Cale> try that
21:31:49 <Cale> it won't print the thing in record syntax if you didn't use record syntax when defining it
21:33:01 <sethk> that did it, thanks.
21:33:14 <sethk> is that a real change, or something that only affects the display format?
21:33:38 <wchogg> Okay, I still feel dumb.  I have a function whose signature is Float -> IO Bool .  I'm trying to figure out if I can easily compose this with a "not" operator, because that seems so easy, but I'm just not getting it.  Sorry.
21:34:19 <Cale> Call that function f. Then you can write:   do { b <- f; return (not b) }
21:34:25 <Dibrom> you have to do all of your stuff inside the IO monad.. so you'd need to put the not there
21:34:29 <Dibrom> yeah
21:34:36 <Cale> or just  fmap not f
21:34:39 <Dibrom> you can use lift also
21:34:39 <dons> @type (\b -> return b :: IO Bool)
21:34:55 <lambdabot> Bool -> IO Bool
21:36:48 <wchogg> Okay, now I've got it.  Thanks alot.
21:37:05 <fworp> cale: the strange thing is, it does infact redraw if you update the value from the idle event (which also behaves eratically). but if there is any delay involved, by (for instance) using threadDelay, it behaves similarly to the timer version.
21:37:43 <sethk> fworp, if the event loop can't run, it can't update.  Is the timer preventing the event loop from running?
21:39:02 <fworp> sethk, the event loop is running fine, i can still resize the window, and its still actually 'repainting' the window, just not with the new values supplied for the text property of the window
21:39:23 <sethk> fworp, yes, that's true, if you can resize.  not thinking.:)
21:39:36 <fworp> if i print from the event handler to the console, it acts as expected
21:41:51 <fworp> the bouncing balls example uses a device context, and supplies its own handlers for the onpaint event, so i was thinking maybe that wasnt even the right thing to be doing. It may just be scheduling a repaint event for the next iteration of the event loop, but not doing anything, since there is no handler
21:42:39 <palomer> damnit, where did delysid go?
21:44:54 <Cale> wow wxHaskell is annoying to compile
21:45:19 * fworp just grabbed the binaries
21:45:41 <Cale> is there a debian package, I wonder
21:47:54 <fworp> all i see are windows, osx, and redhat packages
21:48:39 <mcnster> hello
21:49:23 <Cale> hello
21:49:31 <mcnster> hi cale :)
21:57:32 <Cale> hmm
21:57:46 <sethk> Cale, does that record format actually change internal representation?  Or does it only affect the way the data is printed?
21:58:05 <Cale> doesn't affect the internal representation
21:58:10 <sethk> k, thanks
21:58:11 <Cale> but it does define accessor functions
21:58:19 <Cale> like we discussed before
21:58:55 <sethk> yes
21:59:19 <sethk> That's pretty much pounded into my brain by now.  :)
21:59:43 <Cale> it also lets you do updates like if p :: TransactionLogMessage and it's a LogEntry, then you can write p { leFileName = "something else" } to give the TransactionLogMessage which is just like p, but has that field changed
22:00:33 <sethk> Cale, that will be useful
22:04:04 <mcnster> hmm.  bbl
22:14:51 <sethk> Cale, now I get to do the hard part, which is converting the concurrency control algorithm from page level locking to record level locking.  Once I do that, I will have something up and running fairly soon.  This is moving along better than I had anticipated.
22:15:12 <sethk> the fact that several of the data structures I had to code in C++ are already available is a big help.  :)
22:17:14 <sethk> of course we'll have to see how it performs with real life sized databases.
22:30:40 <Cale> fworp: I don't get the same problem as you here
22:31:01 <Cale> It might have something to do with the window manager, as the only visible change is to the title string
22:31:35 <Cale> If your WM doesn't update the title string immediately every time it changes, then you won't see that
22:31:57 <sethk> how does that fit in with his case where he does see it?
22:32:13 <sethk> I'm not sure I understand the data paths here.
22:32:17 <Cale> well, he sees it change when he moves or resizes the window, right?
22:32:35 <Cale> so perhaps the WM won't repaint the border until one of those happens
22:33:03 <sethk> wasn't there a changed behavior associated with a timer?
22:33:04 <Cale> repaint is only going to invalidate the contents of the window, not of the entire screen
22:33:08 <sethk> right
22:33:13 <Cale> It only changes the titlebar string
22:33:25 <Cale> nothing actually inside the window
22:33:28 <sethk> do we know that a change in the window is updated?
22:33:48 <sethk> we have a problem in the title bar, but do we know that it only happens there?
22:33:54 <Cale> yeah
22:34:00 <Cale> that's all the program does
22:34:05 <Cale> is update the titlebar
22:34:21 <sethk> right, so until the program does something else, we don't know that it is limited to the title bar?
22:34:32 <Cale> oh, that's what you mean :) yeah
22:34:34 <sethk> nor do we know that it isn't, we just don't know.
22:34:57 <Cale> I'm fairly sure that it does actually work if you update the contents of the window, because I've done it before in other apps
22:35:11 <sethk> yes, but the title bar works on your box
22:35:16 <sethk> so that doesn't really prove much
22:35:24 <sethk> although I agree with you that the odds are high
22:35:40 <fworp> cale, im on windows, maybe its a windows thing
22:35:48 <Cale> fworp: quite possibly
22:35:56 <fworp> that stinks
22:36:00 <sethk> I always blame things on windows.  :)
22:36:06 <sethk> fworp, but we should test it.
22:36:17 <sethk> fworp, do some other updates, make sure that they actually are reflected
22:36:32 <sethk> fworp, maybe tweaking a look and feel thing would change it?
22:36:36 <Cale> fworp: why not just update a textbox or label or something?
22:36:36 <fworp> ive tried it in a static text control
22:36:47 <Cale> oh?
22:36:59 <fworp> yes, ill give it another go
22:37:13 <sethk> wasn't that the original problem?  with the text control?
22:37:20 <sethk> I think that's where we started.
22:44:31 <fworp> nope not working
22:45:17 <fworp> oh well ill make a formal gripe on the mailing list, thanks for the help
22:46:00 <sethk> fworp, must be something strange on your box (although I hate it when someone says that to me, once in a while it is true).  I can't imagine a problem like this being unknown
22:46:10 <sethk> fworp, unless it is some sort of regression.
22:46:28 <fworp> sethk: does the same thing on my work computer
22:46:46 <Cale> fworp: hmm
22:46:48 <sethk> fworp, I haven't run it on windows
22:46:57 <Cale> you say you have it editing a text control?
22:47:11 <fworp> i have it trying  to
22:47:11 <sethk> fworp, but wxwindow's claim to fame is that they run in both windows and non-windows with native look and feel
22:47:26 <sethk> fworp, well, we shall see.
22:48:02 <fworp> sethk it maybe a ghc thing, its the introduction of the delay that is doing it, seems very magical
22:48:02 <Cale> fworp: I have a program like that which works
22:48:14 <Cale> you don't even have to call repaint
22:48:26 <fworp> paste it somewhere
22:48:31 <sethk> Cale, it would be interesting it he can try your program in windows.
22:48:37 <sethk> fworp, two minds with half a thought
22:48:37 <fworp> ill try it verbatim
22:48:49 <fworp> lol
22:49:34 <Cale> @paste
22:49:36 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:49:41 <fworp> k
22:51:31 <fworp> still needs me to change the position and size of the window
22:52:17 <Cale> odd - have you tried the bouncing balls demo?
22:52:54 <fworp> not yet, think i had at some point in the past
22:53:35 <Cale> try adding  interval := 20
22:53:39 <Cale> to the properties of the timer
22:53:46 <Cale> and see if it works any better
22:53:56 <Cale> that speeds it up considerably on my machine
22:56:35 <fworp> yeah, bouncing balls works
22:57:02 <fworp> ill try changing the interval
22:57:06 <sethk> fworp, that's interesting.  cale?
22:57:08 <moonfish> how do I resolve errors of the form "Couldn't match the rigid variable `b' against the rigid variable `b1'"?
22:57:28 <Cale> sethk: well, the default interval is pretty high
22:57:40 <Cale> and 20 is the interval used in bouncing balls
22:57:44 <sethk> moonfish, can you put some code on the pastebot ?
22:58:01 <moonfish> sethk: how do I do that?
22:58:03 <Cale> @paste
22:58:04 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:58:11 <Cale> edit that wiki page
22:58:25 <Cale> put your code between triple braces {{{  }}}
22:58:59 <moonfish> ok, will do
22:59:21 <fworp> haha,nope
23:00:18 <fworp> it, but it did just spontaneously update
23:00:29 <Cale> fworp: okay, now add "repaint label" to the end of the timer action
23:00:40 <fworp> maybe....its the source
23:00:43 <fworp> cputime
23:01:00 <Cale> try that anyway
23:01:02 <fworp> ok
23:02:38 <Cale> somehow I doubt that the windows CPU timer is quite that bad, you could ask for the resolution with cpuTimePrecision
23:02:55 <fworp> ok
23:03:24 <fworp> still nothing
23:03:49 <fworp> whats another source of discernable noise
23:04:26 <fworp> id use posix.time, but im on windows
23:04:31 <Cale> Try: let printTime = System.CPUTime.getCPUTime >>= print >> printTime in printTime
23:04:46 <Cale> in ghci
23:05:06 <moonfish> sethk: ok, done. top entry. Clearly this is a silly newbie problem, but I have been stuck on it for a while now.
23:05:22 <Cale> if that number doesn't change too often, then that's definitely your problem
23:05:29 <Cale> you could try a counter
23:06:07 <fworp> ok,i will try a counter
23:08:03 <Cale> moonfish: okay
23:08:49 <Cale> moonfish: well, the type you have to bar is too general
23:08:53 <Cale> gave*
23:09:26 <Cale> that says that for *any type whatsoever* b, it takes values of type b to values of type a
23:10:14 <moonfish> but doesn't the instance def of bar do that too?
23:10:26 <Cale> no
23:11:25 <Cale> It only takes values of type b to values of type Baz b, so if you want it to produce a value of type Baz b, you can't pass it something of any type at all.
23:11:57 <fworp> the counter  did work, it was cputime going nowhere while the program was idle
23:12:06 <Cale> fworp: ah, okay
23:12:23 <Cale> moonfish: so probably you want something like this:
23:12:33 <Cale> class Foo f where
23:12:40 <Cale>    bar :: a -> f a
23:12:52 <Cale> instance Foo Baz where
23:13:03 <Cale>    bar x = Baz x
23:13:34 <shapr> Goood morning #haskell!
23:13:39 <Cale> morning shapr
23:13:51 <shapr> Howza?
23:14:06 <Cale> I'm well :)
23:14:08 <moonfish> Hmm. I still don't understand why my existing instance declaration is more constrained than the class def.
23:14:15 <shapr> Cale: Finally have enough sleep?
23:14:20 <Cale> yep
23:14:23 <shapr> Shocking.
23:14:39 <Cale> though I really should go to bed about now, rather than in 4 hours or so which is what I'll probably do :)
23:15:00 <fworp> that was awfully silly, thanks a bunch cale & sethk
23:15:01 <Cale> I'd miss the European crowd if I did that
23:15:08 <shapr> We are cool. :-)
23:15:20 <sethk> fworp, most errors (at least most of mine) turn out that way.
23:15:29 <shapr> Neat, a sudden influx of new users.
23:15:38 <moonfish> ah, I think I get it now
23:16:00 <moonfish> the b in the instance declaration is a *specific* b.
23:16:04 <sethk> Cale, I just realized something looking at my data structures.  The infinite lists will allow me to implement purely relational data.
23:16:10 <Cale> moonfish: yes
23:16:21 <Cale> moonfish: the instance has to work for every specific b
23:16:38 <Cale> sethk: cool :)
23:17:05 <moonfish> Cale: ok, thanks for your help. much appreciated.
23:17:14 <sethk> Cale, I wanted to ask you actually about this same type thing.
23:17:18 <shapr> Good morning basti_ !
23:17:34 <sethk> Cale, is the forall quantifier necessary when there are free type variable on the RHS?
23:17:55 <sethk> because to me any old b means some type.
23:18:43 <Cale> sethk: the type variables in signatures in Haskell automatically all get forall'd out front if they're not bound explicitly
23:18:50 <Cale> for example
23:18:55 <Cale> a -> [a]
23:19:00 <Cale> is the same as
23:19:05 <Cale> forall a. a -> [a]
23:19:09 <sethk> right.
23:19:21 <sethk> so do I ever need forall explicitly?  I think at one time you did.
23:19:21 <Cale> which is different from (forall a. a) -> [a]
23:19:24 <Cale> er
23:19:34 <Cale> which would be silly
23:19:43 <Cale> because it's the same as (forall a. a) -> [b]
23:20:19 <Cale> There are points at which it's useful
23:20:24 <Cale> it's an extension to H98
23:20:26 <sethk> on that subject.  when it says a -> b (with no further constraints) that should be interpreted as "b is a type, possibly but not necessarily different than a"?
23:20:34 <Cale> right
23:20:41 * shapr boings cheerfully
23:20:54 <sethk> Cale, right, I remember that it wasn't there in one doc I read and I checked and it is an extension.
23:21:13 <Cale> It usually won't be there if it's not necessary
23:21:34 <sethk> Cale, do you use it explicitly so that you can code a type signature?
23:21:34 <Cale> ghci reports them as there if you turn on glasgow-exts
23:21:43 <Cale> you can do things like
23:21:56 <aleator> shapr: You might know (doing webstuff and all). What is best way of  doing templating or generating tex(t) with haskell?
23:21:57 <sethk> Cale, in other words, if you want to make the type more specific say, so you give the signature, do you need it them?  Or is that irrelevant?
23:22:18 <Cale> sethk: that's a separate issue
23:22:35 <Cale> Well, the types that get inferred will tend not to include foralls
23:22:55 <Cale> so you will have to write signatures for places where foralls are actually necessary
23:23:13 <Cale> you can use it to enforce that functions occurring as parameters are polymorphic
23:23:18 <Cale> for example...
23:23:46 <sethk> to make the type more general than the inferred type, you are saying.
23:23:48 <shapr> aleator: There are several options depending on what you want. HaXml, HXmlToolbox, HSP, boring ShowS, various pretty printing libs, and the still-in-design Schvung framework.
23:24:14 <Cale> f :: ([a] -> [a]) -> ([Char] -> [Char])
23:24:23 <Cale> this in general won't work
23:24:52 <aleator> shapr: I'm doing tex. Any favourites or suggestions?
23:24:54 <Cale> because if the user passes some function [Int] -> [Int], what do you do?
23:25:04 <Cale> f :: (forall a. [a] -> [a]) -> ([Char] -> [Char])
23:25:17 <Cale> this means that the function passed must be polymorphic
23:25:33 <Cale> (say, like reverse)
23:25:48 <shapr> aleator: I know almost nothing about TeX so I can't help you much. kosmikus is the expert in that area.
23:25:49 <sethk> so it says, even if you think you can infer the type of a, don't do it.
23:26:06 <sethk> even if it "thinks" it can infer it.  :)
23:26:18 <Cale> sethk: I suppose so, yeah :)
23:26:21 <shapr> aleator: In fact, you may want to check out lhs2TeX since it does some TeX generation already, I think.
23:27:16 <sethk> I probably should convert my data dictionary to XML, but I really don't feel like it at the moment.  :)
23:27:40 <aleator> shapr: Ok. Thanks.
23:29:45 <Cale> sethk: in this case, it's sort of silly, because you'd expect that the function would just be applied to the incoming [Char], but note that there are things which a function [Char] -> [Char] can do which a function [a] -> [a] can't.
23:30:28 <Cale> also, if we needed to apply the polymorphic function at multiple specialisations, it would be absolutely necessary that it be forall'd.
23:35:17 <sethk> Cale, because the compiler would narrow the type on one application and then fail the type check on the other?
23:35:29 <sethk> one specialization, that is
23:36:15 * shapr boings cheerfully
23:36:56 <shapr> boegel: Goedemorgen!
23:37:07 <Cale> sethk: yes
