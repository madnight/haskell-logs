00:06:53 <araujo> Hello!
00:07:11 <newsham> hi
00:07:13 <ValarQ> hello
00:08:24 <newsham> I'm looking for feedback on some code:  http://lava.net/~newsham/x/stock.lhs.txt
00:08:46 <newsham> first I was wondering if there is a builtin "split" function, or if not, a better way to code the one I wrote
00:09:03 <newsham> split "this is a test" -> ["this", "is", "a", "test"]
00:09:29 <ValarQ> newsham: words in the Prelude
00:10:00 <newsham> cool.  is there any related functions for arbitrary lists?  (I dont need it, just curious)
00:10:27 <ValarQ> newsham: take the tour ;)  http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
00:12:05 <aleator> newsham: there is "groupBy (const (/=',')) "This,and,that,for,what"".
00:12:08 <newsham> i've been reading through the prelude stuff on haskell.org
00:12:36 <newsham> aleator: ahh.. great.. thanks.. I didnt understand the "by" version of group
00:13:00 <basti_> aleator: this might not do exactly what people expect, though.
00:13:11 <basti_> (it's comparing each two adjacent letters)
00:13:40 <newsham> sounds about righ tto me, basti.
00:13:44 <aleator> Hmm.. yes. add const and it compares only one. But not really nice, I agree.
00:13:57 <ski> @eval List.groupBy (const (/=',')) "This,and,that,for,what"
00:14:00 <lambdabot> ["This",",and",",that",",for",",what"]
00:14:24 <newsham> ahh
00:17:34 <newsham> any other comments for: http://lava.net/~newsham/x/stock.lhs.txt ?
00:17:41 <newsham> (changed to use "word")
00:18:09 <ValarQ> is there any words implementation that leaves the isSpace open as an arguemnt?
00:18:36 <sethk> ValarQ, I believe so, yes
00:20:50 <newsham> valarq: groupBy (not . isspace) followed by a trim of spaces from the start of each component?
00:21:21 <ValarQ> newsham: but not from the first
00:21:27 <newsham> man, an open invitation to tell me why my code sucks and how it coudl be better, and no takers?
00:21:28 <ValarQ> there must be a better way
00:21:56 <ValarQ> even copying the words implementation from the url i gave you is cleaner (in my eyes anyway)
00:22:41 <ValarQ> newsham: there are two possible explanations: your code doesn't suck or we don't understand it ;)
00:22:56 <sethk> newsham, sorry, nothing screamingly wrong with it.
00:23:48 <psi> ValarQ: i don't think there's a standard function that does that
00:23:59 <ValarQ> psi: :(
00:24:16 <sethk> newsham, write a longer program, and put in mistakes, and come back.  :)
00:24:17 <psi> but it's easy to implement in terms of 'break'
00:24:50 <ski> newsham : first, outer parens is not needed for the pattern in the case
00:25:26 <newsham> spethk: doesnt have to be wrong.  open to suggestions on better
00:25:41 <ski> newsham : secondly, '[date,open,high,low,close,volue,adjClose]' work fine as a pattern, in this case
00:25:41 <sethk> newsham, I wasn't being serious
00:30:32 <ibid> dcoutts: JyuGraphics has now a simple animation capability
00:31:06 <dcoutts> ibid, nice
00:31:17 <newsham> ok, now a question -- using the Time or CalendarTime is it possible to convert a constructed date into an integer representing some count since epoch (ie. seconds or days or hours)
00:31:18 <dcoutts> ibid, I've just finnished adding ioWatchAdd
00:31:19 <ski> newsham : thirdly, 'mapM_ putStr (map (\x -> show x ++ "\n") lins)' is better written 'mapM_ print lins'
00:31:33 <newsham> print is like putstr with a newline?
00:31:58 <ski> newsham : fourthly, your main does not just print the first line .. it prints all of them
00:32:03 <ski> @type putStr
00:32:06 <lambdabot> String -> IO ()
00:32:08 <ski> @type putStrLn
00:32:09 <lambdabot> String -> IO ()
00:32:10 <ski> @type print
00:32:12 <lambdabot> forall a. (Show a) => a -> IO ()
00:32:20 <newsham> ski: ahh, i changed my definition of main without updating the comment
00:32:44 <ibid> dcoutts: thanks
00:32:45 <ski> putStrLn s = putStr (s ++ "\n")
00:32:55 <ibid> dcoutts: would be nice to use it in JyuGraphics, but i cannot assume a
00:32:57 <ski> print = putStrLn . show
00:33:08 <ibid> dcoutts: up-to-date gtk2hs on the machines where it's going to be used :)
00:33:09 <araujo> What is a good option for an if but without an else clause?
00:33:09 <newsham> I dont understand your "secondly" point.
00:33:17 <araujo> Hi btw.
00:33:23 <ibid> araujo: in monadic code, Monad.when
00:33:33 <araujo> ibid, got nothing else?
00:33:52 <ibid> araujo: in non-monadic code, an if without an else makes no sense
00:34:00 <newsham> oh.. instead of the a:b:c:d:[] notation
00:34:25 <ski> in your function 'fields', you can use '[..,..,....]' as pattern instead of '(..:..:....:[])' or '..:..:....:[]'
00:34:45 <newsham> danke.  updated
00:34:50 <araujo> ibid, ok, i see what you mean, what i want is something like: if ... then ... else False
00:34:51 <ski> (the latter works too, as i said the parens aren't needed there)
00:35:02 <araujo> I just wanted to know if there was some syntactic sugar for it.
00:35:33 <dcoutts> ibid, you can copy'n'paste the code if you need
00:35:41 <ibid> yeah
00:35:42 <ski> araujo : '... && ...' ?
00:35:46 <ibid> where can i find it? :)
00:36:05 <araujo> ski, yeah, i tried that.. but.. i must be doing something wrong because it isn't workin....
00:36:06 <ibid> araujo: then you can write myIf test then_ = if test then then_ else False
00:36:16 <dcoutts> ibid, it'll have this type ok? ioWatchAdd :: System.Posix.Types.Fd -> [IOCondition] -> Int -> IO Bool -> IO HandlerId
00:36:36 <araujo> ibid, yeah i know, i just wanted to be sure i am not re-inventing the wheel :-)
00:36:45 <ski> ibid : myIf = (&&)
00:36:45 <ibid> dcoutts: Int is the priority?
00:36:51 <dcoutts> ibid, yep
00:37:17 <ibid> dcoutts: right, actually, i still can't use it here, because it needs to run in windows too ;) but it's a good addition, thanks
00:37:30 <ski> (araujo : precedence or indenting problem ?)
00:37:51 <dcoutts> ibid, mm, it's not clear to me if the g_io_channel_unix_new is ok on win32, it may just take a handle
00:38:11 <ibid> dcoutts: yeah, don't worry about it :)
00:38:20 <ibid> dcoutts: it'll help me in that other project that i'm planning
00:38:47 <ibid> i just need to figure out how to make the timer code in jyugraphics not eat all the cpu
00:38:58 <aleator> Argh. how do you get size of pointer in c? ibid?
00:38:58 <ibid> that addition would have helped
00:39:03 <ibid> but i think i know now...
00:39:09 <ibid> aleator: sizeof?
00:39:22 <araujo> ski, i think i got some clauses returning non-Bool values :-/
00:39:33 <aleator> I have a brainblock. sizeof(what?)
00:39:40 <Speck> can't load .so/.DLL for: readline.5 (dlopen(libreadline.5.dylib, 10): image not found)    while trying to use cabal for anything
00:39:49 <Speck> any ideas?
00:40:06 <ibid> aleator: what's your pointer?
00:40:20 <ski> araujo : types of then and else branch must agree
00:40:23 <ibid> aleator: what is it that you want to get the size of?
00:41:07 <ski> (araujo : maybe you wanted Maybe ?)
00:41:26 <aleator> Ah. Sorry. sizeof(funnystruct*). silly me
00:41:28 <araujo> ski, yes, i was just mistaking some return values by Bool
00:42:19 <ibid> aleator: or sizeof funnypointervariable
00:43:04 <aleator> Yah. C is hard. After few years of not using it..
00:47:17 <dcoutts> ibid, it'll work on win32 with the emulated Unix-like file descriptors MSVCRT provides.
00:47:36 <JohnMeacham> I love it when I realize some complicated bit of code generalizes and I have been solving similar problems multiple times. Because then I just come up with a typeclass or data structure to abstract it and replace hundreds of lines of code with tens of lines and am happy.
00:47:53 <JohnMeacham> it happens in haskell a lot.
00:50:34 <aleator> JohnMeacham: did you have cabal for hsASA?
00:50:45 <ibid> dcoutts: will it work out of the box on the standard ghc win packaging?
00:51:15 <dcoutts> ibid, should do. System.Posix.Types is part of the base package
00:51:35 <dcoutts> though I'm not sure how you get the file descriptor
00:51:53 <kzm> JohnMeacham, what is the status on jhc?  It looks really interesting from your postings, but is it complete enough to use (or try out) on production code yet?
00:52:22 <kzm> Or is it more of a research vehicle?
00:55:20 <JohnMeacham> aleator: no. I have not used it since cabal came out.
00:55:54 <JohnMeacham> aleator: plus, it works best when you tweak the #defines for your particular problem (but has pretty good defaults) when compiling the C code.
00:56:50 <JohnMeacham> kzm: I am working on it at this moment :). no, I wouldn't say it is ready to use for production code yet. but it is getting closer.
01:00:44 <ibid> dcoutts: well, i have an idea how i can avoid that altogether :)
01:01:00 <dcoutts> ibid, handleToFd?
01:01:56 <ibid> i mean, without using the fd monitoring stuff at all
01:02:07 <ibid> (as i said, it'll be very useful in that other project, but..:)
01:06:37 <JohnMeacham> can one easily create cabal packages with hsc files? will it know how to call hsc2hs?
01:07:42 <aleator> JohnMeacham: I did experimental cabal on hsAsa (simpler to include it in my project like that). Worked there (I guess).
01:08:56 <newsham> how do you list multiple constraints in a signature?
01:09:04 <newsham> ie. Enum a and Eq b in a -> b
01:09:26 <ski> (Enum a,Eq b) => a -> b
01:10:08 <ski> @type (^)
01:10:10 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
01:11:52 <aleator> JohnMeacham: Anyhow. Thing like HsASA would be so great as hs-plugin. you could compile the optimizer on the fly.
01:15:36 <basti_> ski: I'm getting List' a = (Either (List a) (a,List' a)).
01:15:50 <basti_> thats looking good isn't it?
01:16:36 <skew> basti_: what is that for?
01:16:52 <basti_> the derivative of list
01:17:11 <skew> with respect to what?
01:17:34 <basti_> uhm there is a notion of "the derivative" of a type.
01:17:50 <basti_> its similar to the derivative in analysis.
01:17:53 <skew> yes, with resepct to what?
01:17:55 <basti_> (formally)
01:17:57 <skew> a?
01:17:57 <basti_> with respect to a
01:18:01 * basti_ nods
01:18:13 <ski> skew : with respect to the element type
01:18:52 <basti_> there's not much sense in deriving a list to a different type is it? ;)
01:19:22 <skew> well, you can do it with respect to recursive occurances of itself
01:19:32 <ski> basti_ : yes that List' is correct .. and List' a is iso to (List a,List a)
01:19:43 <skew> but it makes more sense with trees
01:19:46 <basti_> i figured that now, yes!
01:19:54 <basti_> hmmm
01:20:12 <basti_> in trees that gives the trees-with-subtrees-as-holes type?
01:20:15 <skew> yes
01:20:30 <basti_> i see
01:20:45 <ski> skew : yes, but to be stringent, you have to work directly over the functor generating the type by least-fixedpoint, if you want to do it with respect to recursive occurances of itself
01:21:09 <skew> yeah
01:21:19 <skew> but how else do you work with recursive types?
01:21:23 <ski> (or greatest-fixedpoint, for coinductive types)
01:21:33 <Itkovian> meuning
01:21:35 <Itkovian> hi ski
01:22:13 <ski> just pointing out that it seems one can't uniquely determine the functor from the type
01:22:22 <ski> hiya Itkovian
01:23:20 <newsham> *sigh* anyone know how to use the Time class to get an Integer representing some unit of time from epoch till a date?
01:23:44 <newsham> fromatCalendarTime defaultTimeLocal "%s" <CalendarTimeHere>    doesnt seem to do the trick
01:23:53 <newsham> even though %s is traditionally seconds since epoch
01:28:19 * basti_ would like to implement derivatives in Coq.
01:36:26 <newsham> > split :: Eq a => (a -> Bool) -> [a] -> [[a]]
01:36:26 <newsham> > split f l| skip == []= []
01:36:26 <newsham> > | otherwise= first : split f rest where
01:36:26 <newsham> >(first,rest) = break f skip
01:36:26 <newsham> >skip = dropWhile f l
01:36:37 <newsham> ugh, tabs really messed that up... sorry
01:36:50 <newsham> anyway, generic splitting (based on a boolean)
01:38:21 <{Arias}> hi!
01:39:01 <{Arias}> one question
01:39:14 <{Arias}> i'm trying to connect to a server using this:
01:39:15 <{Arias}> handler <- connectTo server port
01:39:31 <{Arias}> but that throws an exception
01:39:45 <{Arias}> getServiceEntry: no such service entry
01:40:13 <ski> newsham : where's 'skip' defined ?
01:40:23 <ski> (bah, ignore me)
01:41:34 <ski> newsham : hm, wouldn't rest = skip ?
01:42:21 <ski> newsham : anyway, 'skip == []' is better written 'null skip'  (so you don't need the 'Eq a =>' constraint)
01:42:33 <{Arias}> can somebody haelp me?
01:43:02 <newsham> ski: some of the code is adapted from the prelude's "word" implementation
01:43:14 <newsham> skip = dropWhile f l
01:44:39 <newsham> made change to use null.  danke.
01:45:32 <newsham> i'm a little perturbed that stock.py (same location) is shorter than stock.lhs.txt
01:45:34 <ski> hm, yes,   dropWhile f = snd . break f
01:45:51 <ski> so, skip your 'skip = ...' and replace 'skip' with 'rest'
01:46:07 <newsham> (granted I had to implement my own skip, but I still havent figured out how to get an integer for dates)
01:46:22 <araujo> it'd be not better, ... where skip = dropWhile f l  ?
01:46:37 <araujo> *ignore now ot me*
01:47:04 <newsham> ski: I dont see how snd . break f   is anything like dropwWhile f
01:47:05 <ski> hmm
01:47:11 <araujo> i was seeing 'f' and 'l' as free variables....
01:47:24 <ski> hm
01:47:34 <{Arias}> hi araujo :D
01:47:41 <ski> @type \f -> snd . break f
01:47:44 <newsham> Stock> (snd . break isSpace) "this   test"
01:47:44 <newsham> "   test"
01:47:44 <newsham> Stock> dropWhile isSpace "this   test"
01:47:44 <newsham> "this   test"
01:47:49 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:47:56 <ski> @type \f -> dropWhile f
01:47:58 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:48:00 <ibid> {Arias}: sounds like you're using a port that's not defined
01:48:04 <araujo> heya {Arias}
01:48:22 <{Arias}> i'm trying to connect to local host, port 8080
01:48:38 <{Arias}> i have the apache on this port
01:48:39 <newsham> Stock> (snd . break isSpace) "  test"
01:48:39 <newsham> "  test"
01:48:39 <newsham> Stock> dropWhile isSpace "  test"
01:48:39 <newsham> "test"
01:48:44 <ski> @eval snd . break odd $ [1,3,5,2,4,6,7,9,8]
01:48:47 <lambdabot> [1,3,5,2,4,6,7,9,8]
01:49:04 <ski> @eval snd . break even $ [1,3,5,2,4,6,7,9,8]
01:49:06 <lambdabot> [2,4,6,7,9,8]
01:49:12 <ski> @eval dropWhile even $ [1,3,5,2,4,6,7,9,8]
01:49:14 <lambdabot> [1,3,5,2,4,6,7,9,8]
01:49:18 <ski> bah
01:49:35 * ski is prolly wrong
01:49:47 <newsham> @eval snd . break isSpace "    hi"
01:49:49 <lambdabot>   Expecting a function type, but found `([a], [a])'
01:49:49 <lambdabot>   Expected type: a1 -> (a, b)
01:49:49 <lambdabot>   Inferred type: ([a2], [a2])
01:49:58 <newsham> @eval snd . break isSpace $ "    hi"
01:50:00 <lambdabot> "    hi"
01:50:08 <newsham> @eval dropWhile isSpace "   hi"
01:50:11 <lambdabot> "hi"
01:50:17 <ski> @eval snd . span isSpace $ "    hi"
01:50:20 <newsham> not the same
01:50:20 <lambdabot> "hi"
01:50:44 <ski> newsham : right .. i often confuse span and break ..
01:51:00 <araujo> Two functions with two equal specifications but different implementations.
01:51:18 <newsham> arujo: like +,-,* and friends?
01:52:04 <newsham> so nobody knows how to count the number of seconds between two dates?
01:52:07 <araujo> yes, like that
01:52:17 <newsham> araujo: hopefully you dont confuse those :)
01:52:22 <araujo> :-]
01:52:25 <dons> newsham, wait a sec, i've got some code herre somewhere..
01:52:39 <ski> (araujo : you didn't mean different impl. but same semantics ?)
01:52:43 <newsham> dons: with leap years, leap seconds, etc, i hope.
01:53:27 <dons> oh, hang on, you can't use import System.Time
01:53:28 <dons>  ?
01:54:01 <araujo> ski, yes, different semantics
01:54:02 <dons> or take a value from getCPUTime, and pack it into a Calendar TDime?
01:54:05 <newsham> dons: i was trying to figure out a way to use Time
01:54:15 <newsham> dons: my dates arent from the system (or cpu) clock
01:54:18 <newsham> they're from strings
01:54:48 <dons> oh, you may need to construct your CalendarTime by hand then
01:54:53 <newsham> I did.
01:54:54 <newsham> now what :)
01:55:05 <dons> what do you want to do with it?
01:55:18 <newsham> I want to know the number of <some unit of time> since epoch
01:55:31 <newsham> I can make a second epoch CalendarTiem if it helps
01:55:55 <araujo> ski, Ok, forget what i say, i think we can use both specification and semantic well here.
01:55:56 <newsham> ie. if I have two CalendarTimes can I find the number of seconds between them?
01:56:15 <dons> yes, you can. now, let me recall how..
01:56:26 <dons> oh, with TimeDiffs
01:56:34 <dons> diffClockTimes  :: ClockTime -> ClockTime -> TimeDiff
01:56:47 <newsham> yah, but TimeDiffs are in years+months+days+...
01:57:18 <dons> oh, then you want to multiply it all out to the number of seconds, for example?
01:57:33 <newsham> will that accurately reflect things like leap years and leap seconds?
01:58:17 <dons> a TimeDiff does, I think, yes.but check the src.
01:59:04 <newsham> so if I TimeDiff Jan 1 1985 and Jan 1 1984 I'll not get exactly 1 year?
01:59:12 <dons> it's all calling time.h underneath
01:59:32 <araujo> off-topic: what is a good synonymous for 'causality' ?
01:59:54 <dons> at this point I encourage you to try the code out newsham, and complain to the haskell-cafe@ if it desont' work the way you think it should :)
02:00:05 <dons> araujo, hmm. dependency?
02:00:19 <newsham> there's no way to get a TimeDiff on two CalendarTimes
02:00:23 <araujo> mm.. that might work, thanks dons
02:00:48 <newsham> I dont understand why there's no way to just get a "time since epoch" out of one of these things
02:00:53 <newsham> as is traditionally done elsewhere
02:01:12 <dons> ah, newsham, so I see toCalendarTime :: ClockTime -> IO CalendarTime
02:01:15 <dons> but not the otherway ?
02:01:49 <dons> oh, toClockTime :: CalendarTime -> ClockTime
02:02:07 <dons> and then you have your diffClockTimes  :: ClockTime -> ClockTime -> TimeDiff
02:02:19 <dons> so you can certainly diff two CalendarTimes
02:04:04 <newsham> Stock> diffClockTimes (toClockTime (makeDate "10-Oct-05")) (toClockTime epoch)
02:04:04 <newsham> TimeDiff {tdYear = 0, tdMonth = 0, tdDay = 0, tdHour = 0, tdMin = 0, tdSec = 1128945600, tdPicosec = 0}
02:04:28 <newsham> I guess that will work (assuming other implementations also behave in this way)
02:04:29 <dons> so it just gives you the seconds :)
02:05:12 <newsham> seems like a whole lot of hand waving to get at what is almost certainly the internal implementation anyway
02:06:01 <dons> yeah, most people who use it say it is difficult to use.
02:06:38 <newsham> they should add a simple method to convert a ClockTime into an number
02:07:54 <dons> if you want to make notes on a better api. or perhaps rip out System.Time and start working on it, that would be cool.
02:08:16 <dons> also, check that SimonM didn't post a better Time lib last year. i have a feeling there was some proposal
02:08:53 <newsham> dons: I'm somewhat of a newbie.  I am not invested enough to get into that :)
02:09:53 <dons> ah ha! I have a hi resolution earth map working in xplanet. yay :)
02:10:33 <dons> nothing like getting 16G of ram under the bonnet
02:10:50 <Itkovian> dons: is it up yet? is it? is it?
02:11:23 <dons> not yet... first test worked nicely. very sharp view of western europe. it'll be up soon...
02:14:22 <newsham> http://lava.net/~newsham/x/stock.lhs.txt   -- here's the monstrosity.  it works though
02:14:47 <newsham> compared to http://lava.net/~newsham/x/stock.py its a bit scary.  but partly due to having to implement some things that are builtin to python
02:16:52 <newsham> ugh, toCalendarTime is in the IO monad?  why?
02:17:30 * kosmikus sets out to spam the Haskell community once more ...
02:17:43 <dons> go for it kosmikus!
02:17:53 * dons gets spammed 
02:26:13 <musasabi> back at last.
02:26:46 <MarcWeber> Does anybody use haskell direct on windows?
02:27:02 <newsham> > epoch = makeDate 1970 January 1
02:27:02 <newsham> > clockToSec c = tdSec $ diffClockTimes c epoch
02:27:02 <newsham> > clockFromSec s = addToClockTime (TimeDiff 0 0 0 0 0 s 0) epoch
02:27:13 <musasabi> Any new fun code recently?
02:27:18 <newsham> works but kinda sick :\
02:27:26 <ski> hi musasabi
02:27:37 <ski> (been on vacation ?)
02:28:29 <newsham> ok enough of that for now.  g'night all and thanks
02:29:10 <musasabi> ski: EUCD related demonstrations and other such stuff have kept me very busy for the past few weeks.
02:30:03 * ski wonders what EUCD is
02:31:04 <dons> musasabi: add your coords! http://www.haskell.org/hawiki/HaskellUserLocations :)
02:32:00 <ski> musasabi : me and TheHunter thinks   wa .>> wb = fmap (const (extract wb)) wa
02:32:29 <musasabi> ski: European copyright directive in this case the implementation into finnish law (some DMCA like stuff and a legal text that is >300 pages with all the description that noone wholly understands)
02:33:19 * shapr yawns
02:34:37 <ski> musasabi : also, the one in the paper has type  (.>>) :: Comonad w => w a -> b -> w b  and i think  wa .>> b = fmap (const b) wa  for that one, so that is possible for any functor, no special use of the comonad
02:35:20 <ski> musasabi : ah, that :(
02:37:53 <ski> musasabi : i also are not sure why you are trying to have monad-like operations for comonads (coreturn,(>>--),(>>-)) ..
02:38:22 <musasabi> ski: yes, that is true, making one ask whether using comonads is sensible in the context or whether general functors are enough.
02:38:37 <musasabi> fmap is very underused.
02:39:34 <ski> (i think one can show, using comonad laws that your implementation (and kieburtz') are the same as the ones i showed above)
02:40:06 <araujo> what this error exactly means:  Pattern bindings (except simple variables) not allowed in instance declarations
02:40:40 <ski> hm, what piece of code is it complaining about ?
02:40:48 <araujo> let's see
02:46:40 <dons> ah, finally :) much shaper maps (particularly the western europe one): http://www.haskell.org/hawiki/HaskellUserLocations
02:46:53 * dons is now a .tif/gimp/.pnm/.jpg guru :S
02:47:09 <dons> sharper? shapr?
02:47:21 <MarcWeber> Anz idea what IHC might be or where to find it? That's my problem when compiling hdirect. I can find the characters ihc in ghc-6.2.2/libHSbase.a
03:04:16 <basti_> MarcWeber: what was that about concatenating music!?
03:05:12 <azuroth> hi all
03:06:45 <azuroth> simple stuff: function takes an array of strings (i.e. [[Char]]) and prints each string on a separate line.  can you do it without monads?
03:07:07 <ski> hi azuroth
03:07:10 <ski> yes
03:07:27 <ski> @type mapM_ putStrLn
03:07:33 <lambdabot> [String] -> IO ()
03:07:48 <ski> (azuroth : though, you have a list of strings, there, not an array of strings)
03:07:55 <ski> hm
03:08:02 * ski discovers he misread
03:08:02 <azuroth> errr. silly me, yeah
03:08:10 <ski> i didn't see the 'out'
03:08:32 <ski> you can't do this without the IO monad, since you're doing output from the program
03:08:55 <tromp> you require an IO () output, so that's a monad right there:(
03:09:33 <tromp> heck, you require an [a] input, which is also a Monad:)
03:09:45 <tromp> monads are everywhere!
03:09:50 <azuroth> okay. I'm just wondering, because this textbook hasn't discussed monads yet except putStr, but it's asking me to write that function. I did it using "do", but no idea how I'm _supposed_ to do it
03:10:13 <aleator> hmm.. You should build a multiline string?
03:10:49 <azuroth> ahh
03:11:56 <azuroth> so something like " = putStr (zipWith (++) [x+"\n" | x <- xs])" maybe..?
03:12:07 <azuroth> that's ugly, but shows the idea
03:12:22 <azuroth> erm not zipwith
03:12:34 <MarcWeber> Hi basti_ : In Src/Basics.lhs: data Music = Note Pitch Dur [NoteAttribute] | [...]
03:12:41 <int-e> @eval unlines ["a", "bc", "d"]
03:12:44 <lambdabot> "a\nbc\nd\n"
03:12:54 <MarcWeber> type Pitch      = (PitchClass, Octave)
03:13:19 <azuroth> ohh. cool
03:13:26 <ski> tromp : he doesn't use [] as a monad there, though
03:13:37 <basti_> MarcWeber: ....? ;)
03:13:50 <MarcWeber> So what is wrong here: melodie = Note (C, 2) 1  :=: Note (Cs, 2) 1
03:14:17 <basti_> hmmm
03:14:34 <basti_> the note attributes are missing?
03:14:49 <ski> azuroth : that will work if you s/+/++/ and s/zipWith (++)/concat/
03:15:28 <azuroth> ahh
03:15:38 <azuroth> haskell is fun. :D
03:15:41 <ski> azuroth : hm, what int-e said ..  unlines is standard
03:15:49 <ski> indeed :)
03:16:42 * int-e had a lot of fun with programs of the form main = interact (unlines.process_line.line)
03:17:10 <int-e> s/\.line/.lines/
03:17:39 * azuroth notices that lambdacamels are taking over
03:17:48 <dons> oh no!
03:17:58 <MarcWeber> basti_: Thanks a lot.. I had in mind that [] might mean optional. But that would have been maybe or the like.. Have you ever used hdirect on win? Can't compile because I don't find ihc and don't know what that is.
03:18:02 <dons> well, as long as the types are correct, it's ok :)
03:18:26 <basti_> no.
03:23:00 <ibid> dcoutts: the animation stuff works like charm now on JyuGraphics
03:24:55 <dcoutts> ibid, nice
03:25:10 <dcoutts> how are you doing that then?
03:25:22 <dcoutts> timer + drawInWindow ?
03:26:08 <z0d> is WHO-CALLS unimplemented for SBCL in CVS SLIME?
03:26:54 <shapr> z0d: ECHAN ?
03:28:02 <Cale> heh, that would make a good addition to @yow
03:28:30 <z0d> shapr: oops. yes, sorry
03:28:47 <Cale> MarcWeber: there's no way to have optional function parameters (not quite true, but essentially). Even with Maybe, you'd still be writing "Nothing".
03:29:05 <ibid> dcoutts: timer and setGraphic :)
03:29:21 <ibid> dcoutts: it could still be better but the timer problems i had no longer exist
03:29:38 <ibid> dcoutts: it's in the darcs repo if you want to see, BouncingBall.hs
03:30:31 <dcoutts> @yow+ is WHO-CALLS unimplemented for SBCL in CVS SLIME?
03:30:31 <int-e> @yow
03:30:31 <dcoutts> @botsnack
03:30:31 <dcoutts> lambdabot?
03:30:32 <lambdabot> Finally, Zippy drives his 1958 RAMBLER METROPOLITAN into the
03:30:32 <lambdabot> faculty
03:30:32 <lambdabot> dining room.
03:30:32 <lambdabot> Is this going to involve RAW human ecstasy?
03:30:32 <lambdabot> :)
03:30:46 <dons> no @yow+ :/
03:30:56 <earthy> @pity
03:30:57 <lambdabot> Unknown command, try @listcommands.
03:30:59 <earthy> :)
03:31:38 <dons> @todo-add Add @yow+
03:31:39 <lambdabot> Entry added to the todo list
03:32:11 <azuroth> :x
03:32:21 <ibid> add @pity too? :)
03:32:35 <int-e> @arr
03:32:35 <lambdabot> This is the END for you, you gutter-crawling cur!
03:32:45 * int-e loved that game.
03:32:58 <int-e> "And I have a little TIP for you, get the POINT?"
03:33:02 <earthy> :)
03:33:07 <ski> And I've got a little POINT for you, get the TIP?
03:33:15 <earthy> yeah, that's good game
03:33:18 <ski> ehh, .. right :)
03:33:18 <earthy> +a
03:33:39 * ski 's fingers typed too fast for his brain
03:33:47 <earthy> I've met monkeys smarter than you!
03:34:09 <Muad_Dib> in the apenheul i guess earthy ;p
03:34:18 <int-e> I'm glad to hear you've attended the family reunion?
03:34:19 * ski only knows the ones in the original, well
03:34:20 * int-e thinks
03:34:24 * earthy grinz
03:34:42 <dcoutts> ibid, the code looks ok
03:34:42 <int-e> something like that, I believe.
03:34:58 <earthy> muaddib: sicko :P
03:35:06 <ski> hm .. mh
03:35:12 <Muad_Dib> what?
03:40:13 <Cale> a referentially transparent filesystem with transactional semantics in 540 lines of Haskell
03:40:25 <Cale> Nice :)
03:46:33 <Lunar^> #seen SyntaxPolice
03:46:36 <Lunar^> @seen SyntaxPolice
03:46:38 <lambdabot> I haven't seen SyntaxPolice.
03:46:42 <Lunar^> @seen SyntaxNinja
03:46:43 <lambdabot> I saw SyntaxNinja leaving #haskell 10 hours, 14 minutes and 31
03:46:43 <lambdabot> seconds ago.
03:47:32 <musasabi> Cale: but how many people understand it ;)
03:49:09 <MarcWeber> basti_: Where is allseq defined from your tutorial?
03:51:52 <Cale> musasabi: well, it's only 540 lines, how hard could it be? ;)
03:52:25 <musasabi> delimited continuations are pure evil.
03:55:20 <earthy> why?
03:55:24 <earthy> they're cool
03:56:49 <musasabi> GADTs seem simple and easy to understand as compared to them.
03:57:09 <musasabi> and it seems that all implementations use unsafe tricks...
03:58:17 <basti_> MarcWeber: hmm
03:59:23 <MarcWeber> It would be really cool to be able to export to lilypond ;-)
03:59:58 <basti_> MarcWeber: allseq = foldr1 (:+:)
04:00:14 <basti_> then export to midi, and convert that to lilypond
04:08:11 <dblhelix> musasabi: GADTs *are* simple and easy ;)
04:08:24 <aleator> What is the right way of doing Double -> CDouble and vs?
04:11:26 <musasabi> dblhelix: getting the details right and using them to e.g. enforce type and shape constraints can be nontrivial.
04:14:23 <Itkovian> OT - anybody any xp with Keynote?
04:15:13 <Oejet> Itkovian: That's a strange sentence.
04:15:19 <MarcWeber> basti_: is midiout meant to be abstract? Its obvious what it should do so I don't mind.
04:15:29 <sylvan> aleator, fromRational . toRational, would work
04:15:34 <Itkovian> it's Off Topic :-)
04:16:03 * shapr boings
04:16:24 <Oejet> Itkovian: No, I mean, the sentence doesn't make sence to me.  I knew what OT means. ;-)
04:16:47 <Itkovian> Oejet: well, the rest stands for experience and Keynote is an application
04:16:55 <shapr> musasabi: I understand it, except for the delimited continuations part.
04:16:57 <aleator> sylvan: It does not seem to be rational.
04:16:58 <shapr> f
04:17:04 <shapr> whoops EWIN
04:17:21 <Oejet> Itkovian: Ah, I get it now.
04:18:43 <Itkovian> Oejet: prolly one of the best presentation apps out there, except for the importing of bloody OpenOffice spreadsheet values into the chart-thingie
04:22:13 <MarcWeber> Will have lunch now.
04:23:42 <shapr> I want to have BREAKFAST with a MARSUPIAL!
04:23:50 * Igloo uploads ghc 6.4.1 to haskell-unsafe i386 stable
04:25:09 <shapr> yay!
04:31:57 <rep> i wonder if there's a channel where one can ask linux kernel questions
04:32:14 <Itkovian> rep:  #linux ?
04:32:55 <rep> i'm not sure the people there really are kernel hackers
04:33:07 <Itkovian> rep: #Kernel
04:33:19 <Itkovian> #linux-kernel
04:33:38 <rep> thanks
04:34:06 * boegel returns
04:42:47 <musasabi> shapr: yes the continuation part is the hard one for me too.
05:01:03 * shapr kerblibbles
05:01:24 <LFH> hi shapr
05:01:35 <paolino> morning , monads are like event-callback framework instances?
05:01:57 <shapr> hiya LFH, how's code?
05:02:18 <LFH> I was looking at Fibonacci benchmarks at http://cubbi.org/serious/fibonacci/haskell.html
05:02:25 <shapr> paolino: Not really, I'd say monads are more like metaclasses.
05:02:36 <paolino> dang
05:02:41 <LFH> It seems that ALGORITHM 3B there is the fastest implementation of Fibonacci in Haskell.
05:03:47 <shapr> paolino: A monad is a way to put two actions together in a predictable manner.
05:04:05 <shapr> LFH: ok?
05:04:07 <paolino> two callbacks
05:04:16 <shapr> paolino: have you read http://www.nomaware.com/monads/ ?
05:04:35 <paolino> yes, but nothing got me :(
05:04:51 <LFH> I am trying to get the ALGROTHM 3C there to work. It gives the wrong answer from Fibonacci 31 afterwards.
05:04:57 <shapr> Ok, one viewpoint is that a monad is a way to turn the significance of a datatype into a pipeline.
05:05:01 <LFH> I guess ALGROITHM 3C should be faster
05:05:15 <shapr> paolino: Do you know the Maybe type?
05:05:15 <Cale> paolino: have you read MonadsAsContainers?
05:05:26 <paolino> Cale yes
05:05:33 <LFH> But due to roundup error it gives the wrong answer
05:05:52 <paolino> less than nothing got me (well I read it first)
05:06:42 <paolino> shapr significance ?
05:07:02 <paolino> pipeline ok
05:07:04 <LFH> Wondering if anybody here has seen any *correct* implementation of Fibonacci faster than the Algorithm 3B there.
05:07:52 <shapr> LFH: wli probably knows it.
05:08:03 <shapr> If anyone does.
05:08:20 <shapr> paolino: Do you understand how the Maybe type signifies failure?
05:08:39 <paolino> it's an event ?
05:09:08 <Cale> There are no events here, just values and evaluation.
05:09:10 <shapr> er, huh? data Maybe a = Nothing | Just a
05:09:19 <paolino> evenience ?
05:09:22 <Oejet> LFH: Maybe if you put the n>2 test first, that would be a bit faster. ;-)
05:10:20 <paolino> Mavbe could be two two things
05:10:30 <Cale> A function f :: String -> Maybe Integer  is a function which may return an integer (wrapped in Just), but may also fail (returning the value "Nothing")
05:10:43 <paolino> ok
05:11:07 <Cale> Suppose that we had a bunch of such functions, which may succeed or fail when applied.
05:11:20 <paolino> right
05:11:46 <Cale> and we wanted to chain them together
05:11:54 <Cale> applying one after the other
05:11:59 <paolino> callbacks
05:12:05 <ski> no
05:12:06 <Cale> no, composition
05:12:07 <paolino> synchronized
05:12:10 <paolino> ah
05:12:35 <Cale> We'd have to check after applying each whether the result was success (Just x) or failure (Nothing)
05:13:31 <Cale> and if it was Nothing, give Nothing, and it was Just x, give (g x), where g is the next function in the chain
05:13:38 <Cale> but this is awkward
05:13:40 <ski> case f0 a of Nothing -> Nothing; Just b -> case f1 b of Nothing -> Nothing; Just c -> case f2 c of Nothing -> Nothing; Just d -> f3 d
05:13:50 <LFH> Oejet: tried that. The difference is minumum (less than .1 seconds for fib 10^7)
05:14:14 <Cale> it would be a lot nicer if there was an operator which chained functions together like that for us
05:14:44 <paolino> Cale right
05:14:55 <Cale> @type (>>=)
05:15:00 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m
05:15:00 <lambdabot> b
05:15:08 <Cale> Replace m with Maybe
05:15:23 <ski> Maybe a -> (a -> Maybe b) -> Maybe b
05:15:23 <Cale> (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
05:16:55 <Cale> This does basically the only nonstupid thing it could do. If the first parameter is Nothing, it returns Nothing, if it's Just x, then it returns f x, where f is the second parameter.
05:17:44 <paolino> I am reaching the "so what?" :(
05:17:52 <ski> (and f can also return either Nothing or Just y,  so we can use result of this function as first argument to a new application of the function)
05:17:57 <Cale> This lets us write something like (Just x) >>= f >>= g >>= h
05:18:19 <ski> (ma >>= f0) >>= f1
05:18:28 <Cale> right, it's left associative
05:18:50 <Cale> Which is a whole lot cleaner than all that checking
05:18:58 <Cale> It's taken care of for us.
05:19:21 <ski> lambda !
05:19:54 <Cale> You might say "so what" at this point, because the Maybe monad isn't anything spectacular, but it's a simple example at least.
05:20:17 <paolino>  (Just x) >>= f >>= g >>= h is function composition with multiple exit ?
05:20:26 <Cale> yeah, sorta
05:20:48 <ski> yes, each function might return Nothing, and then the whole chain just stops and returns Nothing
05:20:50 <Cale> If any of f,g, or h returns Nothing, the whole computation returns Nothing
05:20:58 <Cale> heh
05:22:04 <ski> foo x >>= \y -> bar y >>= \z -> baz z
05:22:15 <ski> can also be written
05:22:21 <ski> foo x >>= \y ->
05:22:26 <ski> bar y >>= \z ->
05:22:27 <ski> baz z
05:22:36 <ski> this is parsed as
05:22:42 <paolino> alt
05:22:48 <ski> foo x >>= (\y -> bar y >>= (\z -> baz z))
05:22:54 <paolino> where is the monad ?
05:23:03 <Cale> the monad is Maybe
05:23:08 <Cale> (the type)
05:23:08 <paolino> x ?
05:23:16 <ski> monad /= monadic action
05:23:36 <ski> 'foo x','bar y','baz z' are examples of monadic actions, here
05:23:51 <paolino> x what is x ?
05:24:03 <ski> x is just an argument to foo
05:24:04 <Cale> I have trouble calling things like  "Just 5" an action, but I suppose it's coherent with naming the values of certain other monads
05:24:19 <paolino> it's a Maybe ?
05:24:35 <ski> y is the monadic result of 'foo x', here i happen to use it as argument to bar, but i could just as well used it as argument to baz (or both)
05:25:01 <ski> foo :: X -> Maybe Y
05:25:07 <ski> bar :: Y -> Maybe Z
05:25:09 <sheriff> http://nopaste.snit.ch:8001/4563 -- could someone tell me what the error listed there means, in relation to that code?
05:25:14 <ski> baz :: Z -> Maybe W
05:25:25 <Oejet> LFH: An iterative solution might be faster.
05:25:43 <ski> paolino : x could be of any type .. it could be Maybe but also something else
05:27:04 <Cale> sheriff: the more important one is the error which should have come before that -- you wrote show getNumbers
05:27:05 <paolino> ski  Cale thank you  I need mumbling now
05:27:19 <LFH> Oejet: that is why I was looking into ALGROITHM 3C which uses the strict formula for fib n
05:27:19 <ski> sheriff : getNumbers :: Num a => IO [a]
05:27:20 <Cale> sheriff: show takes a string, but getNumbers is not a string
05:27:27 <Cale> er
05:27:30 <ski> sheriff : getNumbers is not a list of numbers
05:27:33 <sheriff> Cale: ok
05:27:36 <Cale> takes a showable walue
05:27:38 <Cale> value*
05:27:40 <sheriff> ski: What do you mean?
05:27:47 <ski> you have to run the action
05:27:50 <Cale> and produces a string
05:27:51 <ski> do ...
05:28:00 <ski>    numbers <- getNumbers
05:28:04 <Cale> you want print, not show
05:28:05 <sheriff> Cale: I'll deal with that in a minute, when I've found out what this error means
05:28:09 <ski>    putStrLn (show numbers)
05:28:39 <paolino> but if you have a little spare time have a look at python twisted reactor, maybe it's a monad, I'd like to know thamks again, see you later
05:29:01 <Cale> sheriff: it means that it expected an IO a, and inferred a type of [[b]]
05:29:16 <ski> (sheriff : show just converts to a string .. putStrLn writes the string .. you could call just print instead of putStrLn and show, because that both converts to string and writes)
05:29:31 <LFH> Oejet: this doesn't explain why the Ocaml version of the same ALRGORITHM 3B is so much faster than the haskell version (see http://cubbi.org/serious/fibonacci/bench.html)
05:29:40 <sheriff> hrm, ok
05:29:53 <nibro> sheriff: the error that you get is from (number : getNumbers)
05:30:12 <nibro> sheriff: you treat getNumbers as a list, when it is in fact an IO action returning a list
05:30:15 <ski> m, right
05:30:24 <Cale> sheriff: you can't use an IO action returning a value in the place of the value
05:30:25 <sheriff> nibro: ok, that makes sense
05:30:38 <ski> you run getNumbers calling the result rest, but you don't use rest then
05:30:56 <sheriff> AH
05:30:58 <sheriff> ok, got it :)
05:31:42 <sheriff> Yep, ok, I understand now
05:31:53 <LFH> Oejet; by the I was talking about fib 10^6 (I should learn to count zeros better)
05:31:55 <sheriff> Thanks :-) It's humbling to be a beginner programmer again :-P
05:32:02 <Oejet> LFH: You could take a look at the generated C/assemply.
05:33:33 <Cale> sheriff: It's worth it though :)
05:34:32 <Cale> hmm... I wonder what paolino meant about twisted reactor even possibly being a monad
05:34:44 <Cale> It looks like a library to me.
05:35:02 * ski wonders what twisted reactor is ..
05:36:07 * ValarQ knows what twisted reactor is
05:36:30 <ValarQ> or rather, i think i know
05:37:22 <dons> nibro, add your details! http://www.haskell.org/hawiki/HaskellUserLocations :)
05:39:01 <shapr> I'm still the northernmost Haskeller!
05:39:22 <sheriff> oooh, first feeling of getting it
05:39:40 * sheriff speeds up
05:39:51 <sheriff> And to think I'm only doing this to hack on Perl6 :P
05:42:27 <sheriff> http://nopaste.snit.ch:8001/4564 -- I don't understand why this is doing nothing when I load it.
05:42:30 <sheriff> Suggestions?
05:42:53 <nocte__> this link is dead
05:43:14 <nocte__> oh, np
05:43:47 <basti_> sheriff: works for me
05:43:53 <basti_> sheriff: how do you "load it"?
05:43:56 <mauke> maybe you have to run main manually
05:44:27 <sheriff> oh wait
05:44:33 <sheriff> Maybe I'm being retarded
05:44:34 <sheriff> hey mauke
05:44:53 <sheriff> If I explicity run main() it works
05:44:58 <sheriff> I just thought it'd do that automatically
05:45:00 <basti_> ()?
05:45:12 <basti_> it would for a compiled and linked program.
05:45:39 <sheriff> fair enough
05:45:46 <sheriff> basti_: uh, just my way of expressing a function :P
05:45:53 <basti_> no () here.
05:45:55 <mauke> main is a value, not a function
05:46:04 <basti_> there is a (), but its something different.
05:46:18 <basti_> () in haskell is the "unit type" that just has one value (which is also called ())
05:46:24 <basti_> think of it as "void"
05:50:10 <Cale> looking up dons' coordinates in google maps gives a somewhat odd result
05:51:21 <dons> oh, really?
05:51:37 <dons> it should be a train station, I think. but I haven't checked in google maps
05:51:48 <dons> do you have a link, Cale?
05:53:58 <Cale> http://maps.google.com/maps?q=-33.536466,151.093514&t=k&iwloc=A&hl=en
05:54:17 <boegel> Cale: wahahahaha :)
05:54:31 <boegel> dons: cool place to live :)
05:55:56 <dons> oh, that's kinda wrong :S
05:56:16 * dons tries computing slightly more accurate coords
05:57:21 <dons> at least lambdabot's is exactly the right spot :)
05:59:17 <Cale> you can get coordinates for the centre of a view using the "Link to this page" link.
05:59:29 <dons> yep :)
06:08:59 <xerox> Hi.
06:09:28 <Cale> hello
06:09:28 * aleator Comes to a conclusion that there is clear similarity with C and fish-liver-oil. 
06:09:56 <int-e> it's ugly but healthy?
06:10:30 <earthy> it used to be good for you but has now gone the way of the dodo? :)
06:10:50 <int-e> C is a great high level assembler.
06:10:51 <aleator> Heh
06:11:06 <earthy> um. no, it is *not* a great high level assembler
06:11:12 <sheriff> http://nopaste.snit.ch:8001/4565 -- I don't understand again. Could anyone help?
06:11:16 <earthy> it's a decent high level assembler
06:11:17 <int-e> (although I'm increasingly using C++ for that, because it has templates.)
06:11:38 <aleator> I've been hacking c all day. And now I seem to have somekind of (might even work) binding for libsvm. Thought it would be very simple..
06:12:22 <earthy> sheriff: the result of foldr (+) numlist is not in IO
06:12:29 <earthy> it is a static list
06:12:50 <sheriff> What am I doing that makes it think I mean IO there?
06:12:58 <ski> also, foldr takes 3 arguments
06:13:01 <ski> @type foldr
06:13:03 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
06:13:07 <ski> @type foldr1
06:13:07 <earthy> what you probably want is   let sumOf = foldr (+) 0 numlist
06:13:09 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:13:12 <int-e> @type sum
06:13:13 <lambdabot> forall a. (Num a) => [a] -> a
06:13:14 <sheriff> ah
06:13:17 <xerox> sumOf = sum,
06:13:19 <mauke> actually, let sumOf = sum numlist
06:13:24 <xerox> Without ","
06:13:35 <earthy> yeah, but the question he was asking had to do with the IO monad :)
06:14:01 <Cale> sheriff: In the notation x <- y you can only put values in the type of the monad you're using (IO in this case) as y.
06:14:08 <earthy> there were other probable errors underlying that
06:14:43 <sheriff> ok
06:14:47 * sheriff goes back to hacking on this
06:16:21 <sheriff> This might be a silly question, but how do I convert a string into an IO string that I can output?
06:16:32 <earthy> putStr
06:16:36 <earthy> oh, wait
06:16:45 <earthy> that converts an string into an IO () :)
06:17:23 <rep> return ?
06:17:36 <earthy> rep: that'd work :)
06:17:38 <sheriff> putStrLn show( sumOf ) -- is giving me an error, where sumOf was a number
06:17:56 <rep> putStrLn $ show sumOf ?
06:17:57 <earthy> sheriff: wrong bracketing
06:17:59 <mauke> sheriff: hehe, rewire your code parser
06:17:59 <ski> putStrLn (show sumOf)
06:18:05 <mauke> (in your brain, I mean)
06:18:13 <sheriff> ooops
06:18:15 <sheriff> I see
06:18:24 <mauke> (foo) is always foo
06:18:24 <xerox> print sumOf
06:18:31 <xerox> print = putStrLn . show
06:18:57 <earthy> which does something slightly weird with strings ;)
06:19:05 <earthy> if you don't expect it
06:19:45 <ski> @eval show (show "foo\nbar")
06:19:48 <lambdabot> "\"\\\"foo\\\\nbar\\\"\""
06:20:06 <ski> @eval show "foo\nbar"
06:20:08 <lambdabot> "\"foo\\nbar\""
06:20:17 <earthy> @eval print "foo\nbar"
06:20:18 <lambdabot> No IO allowed
06:20:21 <xerox> I like TheHunter's idea of a safe IO monad for lamdbdabot.
06:20:29 <earthy> @eval "foo\nbar"
06:20:31 <lambdabot> "foo\nbar"
06:20:34 <xerox> lambdabot, even.
06:28:04 <Cale> There should be ways to put finer grained controls on IO through the type system
06:28:34 <int-e> hmm
06:28:53 <ski> making a submonad .. maybe
06:29:43 <xerox> Cale: what kind of controls?
06:29:44 * ski comes to think of O'Haskell
06:30:06 <ski> presumably for making a safe version for e.g. lambdabot
06:30:22 <xerox> Isn't making one rather simple?
06:30:54 <Cale> xerox: Permission to read/write to specific Handles I suppose.
06:31:49 <xerox> Cale: you didn't see the conversation about deriving types, did you?
06:31:50 <dons> lambdabot isn't safe?
06:32:10 <xerox> dons: TheHunter proposed a safe IO monad for lambdabot, it would be handy.
06:32:11 <ski> lambdabot doesn't support IO in @eval
06:32:23 <liyang> Or maybe a replacement that behaved like IO.
06:32:29 <dons> no, I disable it :) so it's safe :)
06:32:40 <Cale> xerox: which one?
06:32:49 <xerox> Cale: the #haskell-overflow one
06:33:01 <Cale> #haskell-overflow?
06:33:26 <xerox> Sometimes two or more discussions overlaps making it difficult to chase, and understand.  Hence, #haskell-overflow.
06:33:41 <xerox> We aim to get the best ones there, too ;-)
06:33:59 <dons> when did TheHunter propose this safe IO?  sounds interesting
06:34:11 <ski> (too bad it's not logged (yet))
06:34:30 <xerox> I see putStrLn = show or something
06:34:51 <rafl> Any Cabal people here? I have some questions about the usage of include-dirs.
06:35:01 <Cale> Oh, differentiating types :) I've seen that in various papers.
06:35:15 <rafl> The application I currently want to package has some directories relative to the src dir in include-dirs.
06:35:38 <Cale> I'll have to look into how it relates to differentiation of sets of combinatorial objects.
06:35:38 <rafl> That works fine for building and also registering with ghc-pkg if registering is done from the top-level src dir.
06:35:55 <ski> Cale : more than Conor's ?
06:36:06 <rafl> It doesn't if it's done from an other directory where the relative include-dirs could not be found. What is a large problem for packagers.
06:36:52 <rafl> I think the relative paths in include-dirs should be installed with the application at least. Oppinions?
06:37:05 <Cale> ski: differentiation in the sense of Jackson and Goulden
06:38:00 <ski> Cale : uri ?
06:38:54 <Cale> hmm...
06:39:39 <Cale> http://shop.store.yahoo.com/doverpublications/0486435970.html
06:40:03 <Cale> if you have access to a library
06:40:16 <Cale> It's most likely in that book
06:40:20 <Cale> I could explain it :)
06:40:54 <paolino> getSomeInts more = do
06:40:55 <paolino>   n <- promptForInt $ show more
06:40:55 <paolino>   ns <- getSomeInts (more-1)
06:40:55 <paolino>   return (n:ns)
06:41:13 <Cale> Basically, it corresponds to removal of a subobject in each possible way, from every combinatorial object in the set.
06:41:26 <Cale> Are you familiar with generating series?
06:41:26 <paolino> what is of the first action that goes in the second ?
06:41:56 <Cale> actually, now that I think about it - it should correspond exactly.
06:42:38 <dons> shelarcy, hey! add your details! http://www.haskell.org/hawiki/HaskellUserLocations :)
06:43:19 <Cale> yes, looking at the results, that's precisely it
06:44:50 <Cale> You're just removing a subobject in each possible way.
06:45:27 <Cale> A cute little example is that the derivative of x^3 = x * x * x is 3 x^2 because there are 3 ways to remove an x, and each way results in x^2.
06:45:31 <xerox> Howdy JaffaCake
06:45:41 <JaffaCake> afternoon
06:45:49 <int-e> Cale: the generating function of the result is the derivative of the generating.... err. yes.
06:46:05 <int-e> Cale: I was just gonna ask ;)
06:46:28 <xerox> paolino: what's the question exactly?
06:46:42 <paolino> ciao xerox
06:46:44 <xerox> Cale: it's indeed cute.
06:46:47 <xerox> Ciao paolino!
06:46:54 <dcoutts> hia JaffaCake, you're quite right about the bike shed :-) sorry about that.
06:47:06 <paolino> I'm fighting with my self and monads today also :/
06:47:29 <xerox> paolino: you're doing well so far
06:47:41 <Cale> Now, one neat thing is the construction x * d/dx
06:47:44 <rep> i think the bikeshed should be painted blue.
06:47:46 <Cale> (the operator)
06:47:49 <JaffaCake> dcoutts: heh, not a problem
06:48:02 <xerox> Cale: what is it in Haskell?
06:48:09 <Cale> What this does is to paint a particular subobject a distinguished colour.
06:49:01 <ski> Cale : subobject ?
06:49:09 <ski> (as in topos ?)
06:49:13 <paolino> a monad is a pipline of actions with a direction of execution and every do is an atomic sequence of actions, a piece of pipe
06:49:32 <Cale> as in something which contributes to weight :)
06:49:37 <Cale> heh
06:50:09 <Cale> basically, in Haskell, this corresponds to a place where the type parameter gets used
06:50:18 <Cale> So the leaves of a binary tree, say
06:50:23 <ski> paolino : that's a good basic intuition .. except that the pipeline of actions is itself one big action .. the monad is the type itself and the implementation of 'return' and '>>=' that makes the pipelining possible
06:50:53 <Cale> of the elements of a list
06:50:56 <Cale> or*
06:51:04 <ski> Cale : exactly, it marks an element
06:51:31 <ski> (Cale : are you familiar with elaciticity of demand ?)
06:51:37 <Cale> so x * d/dx removes some element, and then adds it back, but in a distinguished fashion
06:51:44 <ski> exactly
06:52:06 <ski> E f x = x * D f x / f x
06:52:18 <ski> E f x * f x = x * D f x
06:52:22 <xerox> Uh.
06:52:24 <paolino> is it true that I can't execute an action without all the others inside a do ? (I think not: only the previous ones in the do and ..)
06:52:29 <ski> (E f x is the elaciticity of demand)
06:52:58 <xerox> paolino: a monad enforces order of evaluation in a functional language.
06:52:59 <ski> paolino : what do you mean by 'without all the others' ?
06:53:06 <Cale> heh, you have strange names for things :)
06:53:24 * xerox asks for understandable names too!
06:53:27 <ski> Cale : the term 'elaciticity of demand' is from economics
06:53:45 <paolino> ski see my paste there
06:53:50 <ski> in this application, a better name could be 'path' or 'address' or 'index'
06:54:10 * ski looks around .. where, where ?
06:54:24 <xerox> paolino: you force the order of evaluation (functionally) with bind.
06:54:35 <int-e> @paste
06:54:36 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:54:53 * ski always feels that statement is a bit wrong ..
06:55:07 <xerox> ski: how so?
06:55:19 <xerox> I always find your opinions interesting :)
06:56:20 <ski> (xerox : have you heard about the backwards-state monad, e.g. where state is passed backwards .. Jerzy karczmarczuk has e.g. used that)
06:56:26 <sheriff> putStrLn ( "The product is " ++ (show (foldr (*) numlist)) -- ERROR "counter.hs":13 - Syntax error in expression (unexpected `}', possibly due to bad layout)
06:56:29 <sheriff> I don't understand
06:56:40 <sheriff> ah wait
06:56:43 <sheriff> indentation problem
06:56:48 * sheriff tries to deal with this
06:56:49 <xerox> ski: I should have added "in the IO monad"
06:56:50 <sheriff> I understand now
06:57:05 <ski> sheriff : and you need another argument to foldr .. what it sshould return for an empty list
06:57:08 <int-e> Lisp! missing )
06:57:11 <int-e> and that
06:57:12 <xerox> sheriff: foldr thakes three arguments
06:57:19 <sheriff> oh
06:57:21 <mauke> sheriff: you want "product"
06:57:26 <int-e> but that's a type error :)
06:57:26 <xerox> @type product
06:57:28 <lambdabot> forall a. (Num a) => [a] -> a
07:00:13 <Cale> btw log doesn't correspond to anything on its own, but one can check that -log(1-x) corresponds with cycles rather easily
07:00:19 <ski> Cale : e.g.   E (a ->) b = a  (this is the power rule)    i.e. a path into a 'Stream a' is a 'Nat'
07:00:28 <ski> cycles ?
07:00:34 <lisppaste2> paolino pasted "monads events" at http://paste.lisp.org/display/12440
07:00:49 <ski> (i think e^ corresponds to Bag)
07:00:56 <xerox> sheriff: There also is:
07:00:56 <xerox> foldl1 _ _ [] = error "Empty list."
07:00:56 <xerox> foldl1 f k (x:xs) = foldr f x xs
07:01:03 <xerox> foldl, even.
07:01:20 <Cale> ski: yes
07:01:25 <sheriff> ok
07:01:35 <xerox> ski, Cale: what are you talking about? :-)
07:01:58 <paolino> is the sequence of actions in getSomeInts atomic ?
07:01:59 <Cale> ski: cycles in the sense of a data structure which doesn't have a marked beginning, but which is cyclically ordered
07:02:07 <xerox> sheriff: sorry, no 'k' in the arguments list.
07:02:12 <int-e> @hoogle [IO a] -> IO [a]
07:02:13 <lambdabot> Prelude.sequence :: Monad a => [a b] -> a [b]
07:02:19 <xerox> paolino: what do you mean by atomic?
07:02:54 <Cale> e^x corresponds with canonical unordered sets
07:03:13 <paolino> calling getsomeints implies at least to steps in the IO monad
07:03:18 <ski> xerox : type derivatives and Structure types (Espces de Structure, Andre Joyal), i think
07:03:21 <paolino> two
07:03:24 <sheriff> While I realise I should be using 'product', why doesn't (foldr (*) 1 numlist) work?
07:03:44 <paolino> (if more >1)
07:03:48 <mauke> @eval foldr (*) 1 [1 .. 6]
07:03:50 <lambdabot> 720
07:03:51 <xerox> sheriff: it does
07:03:52 <int-e> getSomeInts i = seqence [promptForInt (show i) | i <- [1..n]] ?
07:03:53 <mauke> works
07:04:00 <sheriff> ahhhh
07:04:03 <sheriff> I see the problem then
07:04:05 <sheriff> ok
07:05:25 <xerox> paolino: I lost the question again.  getSomeInts is recursive, if that helps.
07:07:50 <int-e> paolino: you can't split those actions apart again once you've constructed the IO monad, you can only sequence it with others
07:08:28 <xerox> Ah, atomic in that sense.
07:08:30 <paolino> int-e ok
07:08:36 <int-e> paolino: but if you have multiple threads, then they could be interleaved ...
07:08:38 <xerox> int-e: modulo ContT
07:09:00 <int-e> xerox: hmm, need to look at that
07:11:03 <paolino> say I return (n) instead of (n:ns) would second action be executed ?
07:11:15 <xerox> paolino: yep.
07:11:58 <sheriff> Is there a better way (not using product) to write: (foldr (*) 1 (filter (> 1) numlist))
07:12:11 <xerox> paolino: do print/putStrLn actions get executed if you don't eval their "ret <-" ?
07:12:31 <integral> sheriff: "better"?  I'd use $ to it didn't have to many () personally
07:12:41 <dcoutts> hia dcoutts_shIRC
07:12:43 <integral> foldr (*) 1 $ filter (> 1) xs
07:12:43 <sheriff> integral: example?
07:12:52 <dcoutts_shIRC> hi duncan
07:13:02 <sheriff> Hrm, I reckon my tutorial will come to that soon
07:13:03 <sheriff> ok, thanks
07:13:08 <xerox> sheriff: product [x | x <- ns, n > 1] ?  But it uses product.
07:13:24 <dcoutts_shIRC> /me notes that the gtk2hs signal handler marshalig bug seems to be fixed
07:13:47 <dcoutts> ha, shIRC doesn't implement /me stuff :-)
07:13:54 <paolino> so  getSomeInts "event" pushes a (n:ns) in the monad value triggering a couple of other events on the way (promptForInt and getSomeInts)
07:14:14 <paolino> ans waiting for them
07:14:17 <xerox> paolino: it is bind to trigger the actions to be ran
07:14:24 <paolino> and
07:14:34 <paolino> or do sugar
07:14:47 <xerox> paolino: yep, not lazy evaluation of bindings
07:16:49 <paolino> so a monad can only hold one value at time
07:17:53 <xerox> paolino: in what sense?
07:18:23 <sheriff> Is there a factorial operator in Haskell?
07:18:34 <mflux> no.
07:18:37 <tromp> fac n = product [1..n]
07:18:38 <sheriff> ok
07:18:39 <mflux> because it's the hello world of haskell ;)
07:18:47 <basti_> :P
07:18:50 <rep> hehe
07:18:53 <basti_> i thought there's "fact" somewhere?
07:18:57 <basti_> @hoogle fact
07:19:03 <tromp> get your facts straight:)
07:19:51 <basti_> lambdabot: hello?
07:20:54 <sheriff> This is hard :(
07:21:18 * paolino is confused
07:21:51 <paolino> must all the actions in a do struct return values under the same monad ?
07:22:11 <basti_> sheriff: what?
07:22:16 <basti_> paolino: yes
07:22:35 <paolino> return is not the right word
07:22:52 <basti_> hmmm i'd say it is
07:23:03 <xerox> paolino: they should work in the same monad.
07:23:30 <sheriff> basti_: Learning a language different from anything I've worked with before :)
07:23:38 <sheriff> http://nopaste.snit.ch:8001/4568 -- what am I doing wrong *this* time?
07:23:45 <basti_> heh
07:24:10 <int-e> show $ facnum num
07:24:21 <int-e> err fac num
07:24:35 <int-e> I mean, which factorial is it supposed to print? *g*
07:25:10 <basti_> sheriff: uhm it looks like you misunderstand how sequentiality is enforced in haskell
07:25:18 <sheriff> basti_: ok
07:25:28 <basti_> "showFactorials" doesn't look right
07:25:29 <sheriff> Specifically how am I misunderstanding?
07:25:38 <earthy> sheriff: what do you intend to do?
07:25:45 * shapr shoots the sheriff, but not the deputy.
07:25:57 * int-e shoots himself
07:26:02 <sheriff> Having passed showFactorials a list, I'd like it to print "The fac of x is y" for each number
07:26:05 <shapr> int-e: In the foot?
07:26:11 <basti_> first, only notating things like that (with the same indentation) doesn't let things happen sequentially
07:26:17 <earthy> ah, but showFactorials returns a list!
07:26:33 <earthy> as is obvious from the first line defining showFactorials
07:26:39 <basti_> what haskell reads there is a whole long application with showFactorials being the 3rd parameter of displayFact
07:26:39 <sheriff> earthy: Does it matter what it returns?
07:26:44 * int-e is wrong of course - the program is only missing a 'do'
07:26:45 <mauke> sheriff: writing explicit type annotations helps
07:26:53 <earthy> so, let's assume that you want to return a list of IO actions that each print "the fac of x is y"
07:26:54 <sheriff> My tutorial hasn't gotten to that yet...
07:26:58 <basti_> hence the error message
07:27:02 <mauke> sheriff: if it doesn't return IO something, it can't print anything
07:27:05 <earthy> where x changes
07:27:06 <sheriff> ah
07:27:14 <paolino> can I make a continuation between actions of a do struct ?
07:27:33 <earthy> then you can perform those IO actions each after the other
07:27:38 <earthy> but you'd have to first build the list
07:27:53 <earthy> i.e. add a ++ between displayFact x (fac x)  and  showFactorials xs
07:28:23 <earthy> but normally you'd do it slightly differently
07:28:35 <int-e> earthy: no, it's not a list *g*
07:28:48 <int-e> earthy: there's a do missing after the = above
07:29:01 <earthy> int-e: no, there is not. read the very first line. :P
07:29:13 <int-e> uhm
07:29:16 <mauke> that should have been return ()
07:29:25 <int-e> but then it's :, not ++
07:29:37 <earthy> um, yes, true
07:29:47 * earthy should've slept more than 5 hours last night
07:30:28 <basti_> sheriff: as you see, IO scripts have a special type in haskell, but that is convenient.
07:33:07 <shapr> earthy: I feel the same way. But at least I was awakened by a gorgeous woman.
07:33:07 <ProfTeggy> Enugh lambada calculus for today.  See you all.
07:33:10 <ProfTeggy> +o
07:33:21 <shapr> lambada, yeah :-)
07:33:25 <shapr> cya ProfTeggy
07:33:25 <ProfTeggy> ;-)
07:33:26 <xerox> Bye bye ProfTeggy!
07:33:29 <basti_> sheriff: [x] proof pics
07:33:32 <basti_> erhm
07:33:33 <earthy> shapr: that helps. a bit.
07:33:33 <basti_> shapr:
07:33:58 <shapr> Yeah, it meant that it was worth skipping that last 1.5 hours to spend it with her.
07:34:00 <earthy> (I was awakened by the friggin' radio and *her* mobile set to go off at 05:00)
07:34:10 <xerox> Ok, delimited continuations factorial!
07:34:21 <xerox> let f n = reset ((*) (shift g) n) where g k | n <= 0 = 1 | otherwise = k (f $ n - 1)
07:34:59 <shapr> earthy: ouch
07:35:09 <xerox> > let f n = reset ((*) (shift g) n) where g k | n <= 0 = 1 | otherwise = k (f $ n - 1) :: Int
07:35:09 <xerox> > map (f) [1..10] :: [Int]
07:35:09 <xerox> [1,2,6,24,120,720,5040,40320,362880,3628800]
07:35:20 <earthy> she had to be at the airport at like 07:30 or somesuch
07:35:37 <earthy> xerox, you're sick. :)
07:35:47 <xerox> I'm having much fun.
07:35:57 <basti_> :-o
07:35:57 <xerox> Yay to composable continuations.
07:36:14 <basti_> youre good!
07:37:04 <sjanssen_> hello, can anyone point me to the webpage for PLog?  Google and I can't seem to find it
07:37:16 <shapr> It's gone, but I can give you the source.
07:37:17 <xerox> Thanks basti_, I do appreciate it very much!
07:37:23 <shapr> I'm using PLog 0.0.6
07:37:25 <sjanssen_> shapr: that would be excellent
07:37:53 <shapr> sjanssen_: http://www.scannedinavian.org/~shae/plog-0.0.6.tar.gz
07:38:25 <xerox> I have to find more code to write with delimited continuations.  Suggestions are welcome!
07:39:16 <shapr> Can you send k across the wire?
07:39:22 <sjanssen_> shapr: so it's gone, do you know whether there are plans to bring it back?
07:39:45 <earthy> xerox: try building a parser for ambiguous context-free grammars
07:39:46 <shapr> I don't know, I haven't heard anything from Peter Gammie lately.
07:40:02 <xerox> earthy: fly dooooown - hehe.
07:40:09 <xerox> earthy: anyway, that's a cool idea.
07:40:10 <shapr> sjanssen_: Why do you want it? What are you looking for?
07:40:27 <earthy> yeah, and it is *very* suited for writing with continuations
07:40:51 <xerox> earthy: I think I see what you mean.  I think I'd like to try with context-sensitive ones this time.
07:41:04 <sjanssen_> shapr: I was looking for blogging software, and if I need to hack it at all, I'd much prefer Haskell
07:41:23 <shapr> Have you seen bringert's BloB?
07:41:31 <sjanssen_> shapr: nope
07:42:04 <basti_> xerox: "undo" stuff maybe.
07:42:05 <shapr> sjanssen_: http://www.cs.chalmers.se/~bringert/projects.html
07:42:08 <earthy> oh, context sensitive parsing is *definitely* helped by doing it with continuations
07:42:26 * arjanb would like to see an explanation of various kinds of continuations that uses haskell
07:42:36 <earthy> I've seen a method for implementing affix grammars that depended on continuations
07:43:10 <shapr> salut Lunar^
07:43:38 <xerox> basti_: in what context?
07:43:50 <Lunar^> shapr: coucou
07:44:16 <basti_> xerox: hmm, like, typing stuff inside an editor (or something)... you type things, and when you "undo", just a former continuation is "invoked" (or what you'd call it)
07:44:41 <basti_> because every significant step leaves a continuation in a log
07:44:43 <shapr> xerox: What about using it for shared editing?
07:45:05 * xerox runs around in circle screaming
07:45:14 * shapr grins
07:45:55 <xerox> Continuations are not serializable, are they?  (and is serializable the right term?)
07:46:10 <musasabi> no they are not.
07:46:17 <earthy> not in Haskell
07:46:20 <musasabi> But keeping them in memory is enough.
07:46:28 <earthy> Clean does have some serialization support for arbitrary thunks
07:46:33 <musasabi> or even "not with GHC".
07:46:51 <earthy> but that is only under the closed world assumption
08:01:23 <shapr> Argh, I hate it when I get extremely cool information that I'm not allowed to publically broadcast :-/
08:03:08 <Maddas> earthy: Various Scheme implementations can serialize continuations, too
08:03:26 <earthy> maddas: it's not impossible, it's just hard
08:03:27 <Maddas> (Except for references to ports etc.)
08:03:30 <Maddas> Yup
08:04:15 <earthy> I'd say anything that is not under IO should be serializable given enough work
08:04:30 <earthy> anything under IO should *not* be. :)
08:04:46 <Maddas> :-)
08:05:03 <earthy> in that case we haskellers have it easier than them schemers :)
08:05:04 * Maddas reads up on Parsec
08:05:31 <xerox> Maddas: good move
08:06:00 <Maddas> I hope it doesn't turn out to be a trap! (With the effect of making my brain explode yet again :-)
08:06:02 <xerox> earthy: so you're going to provide an extension for G
08:06:05 <Oejet> shapr: You can privmsg me. ;-)
08:06:07 <xerox> HC, aren't you?
08:06:08 <xerox> :-D
08:06:27 <Maddas> hm
08:06:39 <Maddas> If you just extended Show sufficiently.. :-P
08:07:42 <earthy> xerox: I will not. :P
08:07:55 <xerox> :-(
08:08:12 <earthy> well, maybe, after I've done my PhD, that might be a worthwile project
08:08:31 <Maddas> Cool, are you doing your PhD now/do you know what you're going to do?
08:08:58 * earthy is doing it now
08:09:06 <earthy> and yes, I think I know what I'm doing. :P
08:09:12 <Maddas> :-P
08:09:15 <Maddas> What is it?
08:09:18 <moorenc> hi, i'm having a problem building gtk2hs:
08:09:21 <xerox> "Doing a PhD!"
08:09:24 <Maddas> haha
08:09:24 <earthy> semantics combinators
08:09:27 <moorenc> ghc-6.4: can't find file `glib/System/Glib/GTypeConstants.hs'
08:09:29 <earthy> think parsec but for logics
08:09:30 <Maddas> earthy: Sounds funky :-)
08:09:46 <earthy> hard too
08:09:46 <moorenc> the file glib/System/Glib/GTypeConstants.hsc exists
08:10:04 <xerox> earthy: will it have any practical implementation/importance? (I don't mean to sound harsh in any way)
08:10:26 <sheriff> Anyone know if there are any RTF tokenizers written in Haskell?
08:10:57 <xerox> sheriff: RTF as in Microsoft's format for Rich Text Files?
08:11:00 <sheriff> Yes
08:11:05 <xerox> Brr.  I do not.
08:11:24 <sheriff> Nowt wrong with RTF :-) This strikes me as a good consolidating project for learning about Haskell then
08:11:27 <sheriff> I know about RTF
08:11:37 <sheriff> And I know about writing RTF tokenizers
08:11:38 <xerox> Yeah, it does.
08:11:49 <xerox> ...and Haskell is very, very good at parsing!
08:11:57 <sheriff> Better than Perl
08:11:58 <sheriff> ?
08:12:02 * cjb doesn't see how writing a state machine teaches you about RTF.  :)
08:12:05 <sheriff> Because that's what I wrote the last one in
08:12:07 <cjb> Uh.  Haskell.
08:12:22 <xerox> If you mean Perl as in 'parsing by regexps', yeah, I think so.
08:12:23 <earthy> xerox: the idea is to make formal reasoning over dsl's simpler to implement
08:12:57 <earthy> i.e.: you design a language and alongside that it's semantics, and you get an intepreter (or even compiler) *and* a logic for free
08:13:16 <xerox> Woot.  It sounds _really_ nifty.
08:13:40 <Maddas> Indeed
08:13:45 <musasabi> could that be used to describe protocols?
08:13:46 <earthy> yah. if I can get it to work for more than the toys I've been toying with up till now ;)
08:13:54 <earthy> musasabi: maybe
08:14:57 <earthy> not sure
08:18:01 <musasabi> earthy: do you have something online?
08:19:32 <earthy> musasabi: not yet
08:19:43 <earthy> but it's in the same vein as the stuff by Sheng Liang
08:20:03 <earthy> cf. http://www.cs.yale.edu/users/liang-sheng/thesis.ps.gz
08:21:21 <earthy> and ofcourse David Espinosa's Semantic Lego
08:21:53 <earthy> and Jose Labra Gayo's language prototyping stuff
08:27:06 <Maddas> is ($) left- or right-associative? (I googled but only found lists of operator precedences  without ($))
08:27:26 <Maddas> Er, right-associative I guess
08:29:55 <thedward> http://www.haskell.org/onlinereport/decls.html
08:30:01 <thedward> you are correct
08:30:10 <xerox> Not just an edward, The Edward!
08:30:46 <thedward> precisely
08:31:24 <Maddas> Ah, thanks for that link.
08:32:11 <thedward> no problem. I had just been reading through that.
08:34:22 <bergrotf> what is the best way to get all subsets of a list? like with [1,2,3] I want [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]?
08:35:54 <mauke> hmm
08:36:20 <mauke> @hoogle [a] -> [[a]]
08:36:21 <lambdabot> List.tails :: [a] -> [[a]]
08:36:21 <lambdabot> List.group :: Eq a => [a] -> [[a]]
08:36:21 <lambdabot> List.inits :: [a] -> [[a]]
08:36:51 <lisppaste2> b01gg1e pasted "subsets" at http://paste.lisp.org/display/12442
08:37:21 <bergrotf> allright
08:37:24 <b0gg1e> this code is for sets, though.
08:37:38 * Igloo thinks this smells like a homework problem
08:37:46 <b0gg1e> ah drawAny is missing
08:37:46 <moorenc> does anyone know how i can use hsc2hs to turn an hsc into an hs file? it seems to fail silently when i run it
08:37:47 <bergrotf> nah.. doing old exams
08:37:56 <b0gg1e> well guess its obvious.
08:38:09 <b0gg1e> i wonder why there is no such thing in the libraries.
08:41:33 <shapr> moorenc: hsc2hs --help ?
08:43:32 <moorenc> shapr: i've had a look at it and i can't see what i'm doing wrong
08:44:25 <shapr> What command do you run?
08:44:37 <shapr> Hm, sf.net appears to be toast.
08:44:46 * shapr wants to download a game.
08:44:53 * shapr is working hard.
08:45:18 <cjb> Which one?  :)
08:45:47 * cjb has forsaken all inferior games in favour of The Game.  :)
08:45:48 <cjb> (Go.)
08:46:13 <shapr> I'm tempted to try Go, but I suspect I won't get any software written for months after I start.
08:46:19 <shapr> hola joelr
08:46:28 <moorenc> shapr: /usr/lib/ghc-6.4/hsc2hs-bin -o GTypeConstants.hs GTypeConstants.hsc
08:46:32 <earthy> I actually did try go for a sec or two
08:46:47 <xerox> shapr: it's something you ought to do.
08:46:49 <earthy> it didn't entrap me
08:47:08 <joelr> hello good folks of #haskell
08:47:21 <joelr> @index timeout
08:47:22 <lambdabot> bzzt
08:47:23 <shapr> moorenc: Do you get any output at all? Have you tried it with -v ?
08:47:59 <moorenc> shapr: now it says "Executing: ghc -c GTypeConstants_hsc_make.c -o GTypeConstants_hsc_make.o"
08:48:00 <cjb> shapr: Oh, you'll get some software written, it'll just be Go software.  cf.  http://www.inference.phy.cam.ac.uk/cjb/image2sgf.html
08:48:13 <joelr> does anywone know if there's a Util module?
08:48:31 <joelr> the high performance haskell web server refers to it
08:49:09 <rep> httpd.hs > hws :P
08:49:24 <joelr> rep: what do you mean?
08:49:35 <rep> my httpd is cooler :P
08:49:40 <joelr> rep: rather, where do i get httpd.hs if it's newer?
08:49:54 <joelr> rep: i'm trying to deal with timeouts and timers
08:49:59 <joelr> no idea how they do it in haskell
08:50:10 <rep> no idea
08:50:23 <rep> well, my httpd is still not finished
08:50:44 <rep> so you're probably better off with hws
09:00:10 * joelr has moved to the canary islands
09:04:49 <earthy> bark bark
09:05:03 <earthy> probably nice weather though
09:05:16 <ValarQ> bork bork
09:05:21 <joelr> 30C :-) it was only 12C in stockholm, although that was quite nice too
09:05:22 <beschmi> joelr: are you looking for http://www.scannedinavian.org/repos/hlibs/hws-wp/hws-wp/src/Util.hs
09:05:34 <joelr> beschmi: i think so
09:05:40 <joelr> beschmi: thank you!
09:05:46 * beschmi is doing some network server programming ATM too
09:06:00 <earthy> ATM?! eewwwww....
09:06:14 <earthy> 53 bytes should be large enough for any packet
09:06:26 * Igloo suspects he had a different expansion of ATM in mind  :-)
09:06:27 <beschmi> earthy: i just meant at the moment ;)
09:06:31 <earthy> ah ;)
09:06:43 <Maddas> :-)
09:06:49 * earthy is too much of a nerd 
09:06:51 <joelr> beschmi: ehe
09:06:54 <rep> lol.
09:06:59 <joelr> beschmi: what are you programming?
09:07:20 <joelr> is anyone here on mac osx?
09:07:28 * earthy is
09:07:45 <b0gg1e> yes
09:07:46 <beschmi> joelr: i'm doing some experiments with tcp NAT traversal
09:07:50 <joelr> earthy: is your postcript fuzzy when converted to PDF?
09:07:56 <earthy> yes
09:08:01 <earthy> not all of it, but some of it
09:08:01 <joelr> earthy: reading these haskell papers drives me nuts :(
09:08:13 <joelr> beschmi: interesting
09:08:19 <earthy> that's due to the ps containing pre-renderded 300 or 600 dpi fonts
09:08:27 <earthy> and not actual postscript outlines
09:08:50 <joelr> earthy: interesting. most of the haskell papers in PS seem to be doing that
09:09:02 * earthy noticed that as well
09:09:12 <earthy> there's only one way around it that I've found
09:09:14 <earthy> print it.
09:09:22 <earthy> on print it'll look nice and sharp
09:09:58 <earthy> it may actually have more to do with the postscript font outlines in the ps files not being hinted for low-dpi output
09:10:15 <SamB> joelr: its because the Computer Modern fonts do things that cannot be expressed in postscript
09:10:25 <earthy> samb: that is simply untrue. ;)
09:10:49 <musasabi> Is there any good service offering mac os x test accounts (with the possiblity of GHC) - want to make network-alt work there...
09:10:59 <SamB> in particular, the polynomials that you would have to use to describe the outlines are of higher degree than postcript font outlines...
09:11:08 <earthy> (as you can seen when zooming in on the converted files: plenty crispy at higher zoomlevels)
09:11:09 <joelr> folks, how do you keep thread state with haskell?
09:11:17 <SamB> s/than/than those in/
09:11:48 <earthy> samb: that's why there's approximations as type 1 files
09:12:05 <earthy> and that's also why many installations of e.g. dvips include rendered fonts in the ps
09:12:08 <musasabi> joelr: we don't - or we use our own abstraction. (there are also ugly hacks to do it)
09:12:13 <SamB> earthy: if that is untrue, than why isn't there a version of METAFONT that outputs postcript fonts?
09:12:28 * SamB trips over the homonyms
09:12:45 <joelr> hmm
09:12:48 <earthy> because it has never been necessary to have one...
09:12:56 <joelr> what i mean is ... say i'm modelling a bot
09:13:08 <joelr> new thread and private state
09:13:31 <joelr> how do i do that with haskell? make state into a record and pass it into the thread?
09:13:49 <earthy> but see also http://www.inf.bme.hu/~pts/textrace/
09:14:17 <musasabi> joelr: maybe separate threading and the state?
09:14:42 <joelr> musasabi: well, umm.. i think they will be separated by default, no?
09:14:48 <musasabi> depends a lot what kind of a bot it is and how you do things.
09:14:56 <joelr> a thread is a thread and a data type is not a thread
09:15:10 <musasabi> Why not pass the state then?
09:15:11 <SamB> joelr: just forget you ever heard of TLS
09:15:24 <joelr> i just need to launch a thread the reads from a socket in a loop and uupdates internal state
09:15:25 <SamB> joelr: it will probably be easier that way
09:15:35 <joelr> SamB: what's tls? oh, thread-local state
09:16:07 <musasabi> So you have a thread which reads messages and sends events or mutates global state?
09:16:07 <joelr> so i would need to have a global list of thread state records that include a thread id, or something like that?
09:16:12 <joelr> so that i could communicate with threads
09:16:19 <SamB> joelr: maybe also forget you ever heard about state ;-)
09:16:28 <joelr> musasabi: since we forgot about tls then yes, it mutates global state :D
09:17:32 <musasabi> "Concurrent Haskell, SL Peyton Jones, A Gordon, S Finne" and "Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell" are your friends.
09:17:40 <joelr> i'm modelling poker players/clients. they need to connect to a poker server and then poke around
09:17:47 <SamB> joelr: try on MVars for size?
09:17:49 <joelr> they also need a list of instructions for example
09:17:55 <joelr> SamB: yes, i thought about that
09:17:59 <dcoutts> now who was it who reported the onEntryActivate bog with ghc-6.4.1 ? anyway it's now fixed in cvs.
09:18:04 <dcoutts> bog/bug
09:18:05 <musasabi> Control.Concurrent.MVar and Control.Concurrent.Chan are good solutions.
09:18:10 <joelr> gotta go read through the awkward squad again
09:18:37 <beschmi> dcoutts: thats was me. thanks
09:19:10 <dcoutts> beschmi, ah yes. if you use the darcs mirror, that'll update early tomorrow morning.
09:19:59 <joelr> musasabi: Chat... is that implemented on top of STM?
09:20:10 * SamB is again reminded that he is not a normal user ;-)
09:20:27 <joelr> what's the state of shared transaction memory these days? is it built into ghc?
09:20:55 <dcoutts> @index STM
09:20:56 <lambdabot> GHC.Conc, Control.Concurrent.STM
09:21:11 <musasabi> joelr: no, STM is a "new" thing. They could be implemented with STM and STM can be implemented with them, but for efficiency reasons the implementations are separate.
09:21:36 <joelr> aha, cool
09:21:41 <joelr> do{ x <- p' # l_get_x; c <- p' # l_color; print (x,c) }
09:21:52 <SamB> joelr: that GHC.Conc in the result would be a "yes"
09:22:16 <joelr> any reason why people put do { ... } instead of do \n \t foo \n\t bar, etc.
09:22:32 <SamB> I mean, if it wasn't built in, it wouldn't be in GHC.*... it would just be in Control.Concurrent
09:22:41 <joelr> SamB: not sure what you mean re: a yes, too little sleep today with all the flying
09:22:55 <joelr> SamB: understood now
09:23:20 <SamB> joelr: well, it saves on newlines, an expensive comodity on IRC
09:23:36 <joelr> SamB: i see
09:24:16 * joelr thinks there's nothing like tackling the awkward squad after 2-3 hours of sleep in 30C hea
09:24:20 <joelr> heat
09:24:35 <joelr> slee, in 30C heat :D
09:24:42 <joelr> damn
09:25:08 <SamB> in a real program you wouldn't usually do that
09:25:21 <shapr> dcoutts: There's a darcs mirror of fptools?
09:25:38 <joelr> SamB: why not?
09:26:10 * SamB is shamefully on the F scale
09:26:31 <joelr> SamB: ?
09:26:47 <SamB> joelr: well, the indentation looks nicer mostly
09:27:36 <shapr> If we all switched to SILCnet, we could paste files into the channel, and you'd see a  little button where you could expand the file to look at it.
09:27:38 <joelr> true
09:27:47 <kolmodin> is there a way to make darcs tell me which files that are _not_ in my repo?
09:27:55 <shapr> cjb: That's really cool Go software
09:28:02 * SamB fears he is not sure what joelr is confused about
09:28:03 <musasabi> kolmodin: darcs whatsnew -ls
09:28:22 <kolmodin> musasabi: great! thanks
09:28:33 * SamB is rather lagged
09:28:37 <joelr> SamB: no longer, everything is clear
09:28:54 <shapr> Man, I want David B. Held's email address.
09:29:13 * SamB wonders what he would call a custom CPU arch if he made one...
09:29:49 <SamB> shapr: what is SILCnet?
09:30:30 <dcoutts> shapr, I was talking about a darcs mirror of Gtk2Hs
09:30:37 <shapr> oh ok
09:30:49 <dcoutts> dars get http://haskell.org/gtk2hs/darcs/gtk2hs
09:33:54 <shapr> hiya SyntaxNinja
09:34:24 <shapr> SamB: http://www.silcnet.org/
09:35:24 <SamB> dcoutts: did I mention that using the darcs version of Gtk2hs fixed my problem as expected?
09:35:42 <SyntaxNinja> hiya
09:35:59 <dcoutts> SamB, oh good
09:36:36 <dcoutts> we're going to try and release 0.9.10 before the next HCAR
09:36:46 <dcoutts> ie before Nov 1st
09:43:26 <BlurredWe> quick question, what does a tick mark after a function mean?  like function'
09:43:44 <basti_> nothing special
09:43:48 <basti_> its part of the name
09:43:49 <CosmicRay> BlurredWe: nothing in particular
09:44:03 <cjb> shapr: Thanks.  :)  It's very naive Go software.  I keep asking machine learning researchers how they find edges, and getting answers like "Oh.. yeah, that's really hard.."
09:44:07 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051011"]' by CosmicRay
09:44:18 <BlurredWe> ok, so just a useful way of having two functions with almost identical names?  (like helpers)
09:44:35 <Philippa> foo, foo', foo''
09:44:40 <Philippa> yeah
09:44:50 <BlurredWe> cool...makes it a little easier to understand then :)
09:45:04 <Philippa> it's derived from a mathematical notation, for better or worse
09:45:15 <BlurredWe> ya, the prime notation :)
09:45:17 * SamB lies in wait for Lemmih, waiting to pounce on him and ask when the ghc-api-less hIDE will be ready
09:45:51 <BlurredWe> where do I find API docs, specifically I need to read about the 'Observe' module
09:46:23 <BlurredWe> nevermind, I think I found it right off the main page
09:46:30 <SamB> BlurredWe: well, you could read the source
09:46:34 <SamB> or you could try
09:46:41 <SamB> @docs Observe
09:46:42 <lambdabot> Observe not available
09:47:02 <CosmicRay> BlurredWe: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
09:47:16 <CosmicRay> however I'm not aware of an Observe module either.
09:47:57 * SamB found the source
09:48:07 <SamB> module Observe
09:48:13 <SamB>         {-# DEPRECATED "This module is unmaintained, and will disappear soon" #-
09:48:13 <SamB> }
09:48:19 <dcoutts> SamB, you don't need to build the hIDE plugins that use the ghc-api
09:48:34 <CosmicRay> heh
09:48:52 <dcoutts> SamB, you can just leave them out.
09:49:21 <SamB> dcoutts: well, yes, I know, but what about haskellSense!
09:49:33 <kosmikus> CosmicRay: thanks for mentioning HCAR
09:50:01 <CosmicRay> kosmikus: no problem, it's a good project.  now I need to gather up some things to send to you.
09:50:27 <kosmikus> yes :)
09:50:46 <kosmikus> now that I read the entry again, it maybe reads a bit too restrictive even ...
09:50:51 <dcoutts> SamB, well yes that plugin needs the ghc-api. You can't build it?
09:51:10 <CosmicRay> kosmikus: yeah, probably does.  I was trying to make the point that lots of different things are covered.
09:51:20 <CosmicRay> kosmikus: if you post a reminder in a week or two, I'll include it in HWN again ;-)
09:51:29 <SamB> dcoutts: the ghc-api?
09:51:29 <kosmikus> "has published code, has written books, ..." I don't want to give the impression that the authors must be advanced before they can participate ...
09:51:36 <kosmikus> CosmicRay: ok
09:51:56 <CosmicRay> kosmikus: true.  You could also just reply to the e-mail on haskell@h.o and clarify it there too.
09:51:58 <SamB> I can build ghc-api, but I have ghc6.4 and it doesn't like for me to actually install it...
09:52:21 <dcoutts> SamB, ah it needs 6.4.1
09:52:25 <kosmikus> CosmicRay: btw, has it ever been brought up to merge the Sequence with haskell.org?
09:52:48 <CosmicRay> kosmikus: yes.  actually I probably ought to check in on that again.
09:52:51 <paolino> how do I import Monad in ghci ?
09:53:07 <CosmicRay> the haskell.org server was moving when I checked last
09:53:08 <kosmikus> CosmicRay: I mean, not just making it sequence.haskell.org, but really making it the main page?
09:53:12 <CosmicRay> paolino: :m Monad, if memory serves
09:53:24 <CosmicRay> kosmikus: ahh.  that's a novel idea.  I like it.
09:53:44 <SamB> dcoutts: apparantly!
09:53:45 <CosmicRay> improve the links on the side and top a bit.  yup, I could see that.
09:53:47 <kosmikus> that'd require that some of the other content goes to the side bars etc.
09:53:55 <kosmikus> yes, exactly
09:54:08 <kosmikus> but I'd think it'd be a major improvement over the current haskell.org main page
09:54:20 <BlurredWe> heh, the observe module is just something I found online, no worries if it's something old/broken
09:54:20 <SamB> not for any real reason except that 6.4 doesn't properly implement package hiding...
09:54:39 <CosmicRay> SamB: eh?  what do you mean/
09:55:05 <SamB> BlurredWe: just read through the sourcefile
09:55:39 <SamB> CosmicRay: it complains when multiple packages define the same module, regardless of the hidden/shown status of those packages
09:55:55 <paolino> what is it the 'it' in the YAHT code on monads ?
09:56:52 <paolino> 'it' function ,it is not anything regarding monads, right ?
09:57:44 <paolino> jumping around in a tutorial is not a good idea :/
09:58:45 <kosmikus> paolino: I don't know YAHT, but "it" is how you can access the value that's been computed last in an interactive ghci session ...
10:00:06 <paolino> ah, nothing to do with YAHT and monads ://
10:00:37 <CosmicRay> SamB: ah.
10:00:45 <CosmicRay> SamB: I always thought I was doing something wrong there.
10:00:49 <CosmicRay> SamB: does 6.4.1 fix that?
10:01:07 <Cale> paolino: which page?
10:01:41 <SamB> CosmicRay: so I am told!
10:01:53 <beschmi> shapr: someone implemented the darcs push via CGI idea, http://www.djm.co.za/cgi-bin/darcs_cgi.pl
10:01:55 <C-Keen> re.
10:02:02 <shapr> beschmi: nifty
10:02:20 <paolino> 146, and on but kosmikus gave the right indications
10:02:37 <cm_> hoohoo
10:08:19 <shapr> The next revolution will be copy controlled.
10:08:51 <Cale> heh
10:08:59 <benmos> Anyone know anything about the history / future plans for Bulk types in Haskell? ....the current stuff in GHC seems very different from the "Bulk types with class" SPJ paper.... just wondering if there's any info anywhere on why that is....
10:09:28 <shapr> beschmi: Hm, that's too manual. I want darcs send to submit via curl.
10:11:34 <musasabi> Bulk types?
10:11:44 <Cale> http://research.microsoft.com/Users/simonpj/Papers/collections.ps.gz
10:11:45 <benmos> hi  - sorry - aka collection types
10:12:35 <benmos> actually - just noticed that paper is referenced under the "Collections" heading on http://www.haskell.org/bookshelf/
10:13:21 <benmos> ...but that doesn't really give any indication about whether that approach is generally accepted, fallen-out-of-favour ... yet to gain widespread  approval etc...
10:13:44 <benmos> ....or how that relates to things like "Data.Set" in GHC...
10:14:29 <musasabi> I think it is mostly due to such libraries lacking popularity for whatever reasons.
10:15:09 <benmos> How do you mean? .... is it just that noone has yet got round to adapting GHC to the approach described in that paper then?
10:15:25 <benmos> (ie writing a library in that style)
10:16:23 <musasabi> benmos: none of the collection library things (e.g. edison) took much wind which is a pity.
10:16:38 <benmos> (I haven't been able to track down any community discussions about the issue anywhere either...)
10:16:42 <benmos> ah...
10:16:52 <benmos> ...is edison somewhat 'dead' now then?
10:17:32 <musasabi> Well it is stable and works. Just not very widely used.
10:17:35 <benmos> anyway, I'd be v.grateful if anyone can point me to any discussions etc that I've missed that are archived anywhere
10:18:00 <benmos> interesting.... it seems a bit odd really - I'd have thought that they would be very widely used...
10:18:14 <benmos> ...or are people still using Lists for everything? ;-)
10:19:02 <CosmicRay> benmos: uhm, maybe... ;-)
10:21:14 <Cale> benmos: Well, we have decent data types now, but there isn't a standard typeclass interface to the operations on them
10:21:36 <SamB> benmos: no, we use Map and Set various IArrays and MArrays now too ;-)
10:21:39 <Cale> for instance, see Data.Set, Data.Map, Data.Array.*
10:22:12 <benmos> Ok. So it's just that there's not been much requirement to abstract the commonality I guess?
10:23:03 <SamB> but in terms of concatenable sequences, yeah we use lists for those still ;-)
10:23:05 <Cale> Well, to do it the really slick way involves some changes to the type system, and people haven't generally agreed on things yet.
10:23:41 <benmos> I see - what things in particular? I thought that most of the things in the B.T.W.C. paper were generally agreed on now (in terms of the type system)
10:23:42 <SamB> benmos: that, and the difficulty of coming up with something that will work with much
10:23:43 <Cale> It would be nice, for example, if Set specialised to IntSet automatically, when applied to Int.
10:27:19 <benmos> ah... ok (just had to go look up what IntSet was... ;-)
10:27:58 <benmos> Aren't multiparameter type classes fairly accepted now?
10:28:47 <SamB> yes
10:28:52 <SamB> but they aren't enough
10:29:14 <benmos> oh - what else is really needed?
10:30:01 <SamB> Believe me, I tried it once! I couldn't come up with anything general enough to work for me! I even asked for help on the mailing list, but apparantly its quite difficult!
10:30:29 <SamB> @google collections Samuel Bronson haskell
10:30:31 <lambdabot> http://www.amazon.com/exec/obidos/tg/detail/-/B0007O38YY?v=glance
10:30:33 <benmos> I'm quite happy to believe you...
10:30:35 <shapr> ??
10:30:40 <SamB> what?
10:30:45 <BlurredWe> still learning, trying to understand this (primes...) sieve (h:t) = h : sieve [x | x <- t, x `mod` h /= 0]  does that mean for every element in t check that it isn't a multiple and only then does it get sent to the next iteration of sieve?
10:30:50 <shapr> SamB: You wrote a book about it? ;-)
10:30:51 <yaarg> , /topic
10:31:00 <SamB> @google collections Samuel Bronson naesten haskell
10:31:03 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2005-May/010216.html
10:31:09 <SamB> no, I didn't write a book about it!
10:31:12 * shapr grins
10:33:37 * SamB goes to search Google Groups
10:33:44 <SamB> @todo-add Google Groups support
10:33:45 <lambdabot> Entry added to the todo list
10:33:56 <Cale> that book is called "The Steve McQueen Collection"
10:34:13 <benmos> ....I was a bit puzzled by that I have to confess....
10:34:22 <SamB> I didn't even write a review of it!
10:35:01 <Cale> heh, It's probably matching Samuel with Samurai and Bronson with Charles Bronson
10:35:53 <Cale> BlurredWe: yes
10:35:58 * SamB remembers that the haskell lists aren't on usenet
10:36:32 <benmos> seems to be something here: http://www.archivum.info/haskell-cafe@haskell.org/
10:36:38 <benmos> ....don't know if that helps
10:37:06 * SamB goes to gmane
10:39:47 <BlurredWe> cale, I'm just getting tripped up by the "x <- t" where t is a list and x is a Num (I think..)  Does it just do it for every element in t?
10:41:26 <Cale> yes
10:42:05 <Cale> if you've ever seen set comprehensions in mathematics {x : x in R, x^2 < 10}, it's a similar idea
10:42:42 <BlurredWe> yup, in the CS dept...lots of sets, I understand the whole thing now I think :)  thanks
10:45:02 <Cale> :)
10:48:22 <SamB> http://thread.gmane.org/gmane.comp.lang.haskell.libraries/3271
10:49:21 <shelarcy> dons, I added my detail.$B!!(B http://www.haskell.org/hawiki/HaskellUserLocations
10:59:29 <Cale> http://www.irregularwebcomic.net/ -- auuuggghh... such terrible puns!
11:02:23 <benmos> SamB: thx
11:10:38 <shapr> It's pretty weird to see myself quoted in other people's .sig files.
11:11:04 <earthy> ;)
11:12:21 <C-Keen> indeed
11:13:08 <araujo> @index (>>=)
11:13:09 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
11:13:09 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
11:13:09 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:13:28 <araujo> What is the command to get the definition?
11:16:37 <Lemmih> araujo: (>>=) is a function from the Monad typeclass.
11:17:00 <araujo> yeah Lemmih
11:17:58 <Lemmih> That means that every instance of Monad give their own defition of (>>=).
11:18:25 <kosmikus> hi Lemmih; with all your recent work, I expect a HCAR submission from you this time ;)
11:18:48 <SyntaxNinja> hi kosmikus
11:18:52 <SyntaxNinja> hi Lemmih
11:19:08 <kosmikus> hi SyntaxNinja
11:19:12 <kosmikus> how is/was Berlin?
11:20:24 <SyntaxNinja> kosmikus: it was great. I had a nice time.
11:20:29 <SyntaxNinja> it's a very cool city.
11:20:43 <kosmikus> good to hear
11:22:37 <SyntaxNinja> did you have a good time at icfp?
11:22:49 <SyntaxNinja> there was a lot of positive reaction to the future of haskell discussion. nice job there.
11:22:58 <SyntaxNinja> sorry for drifting into technical stuff w/ autrijus. nice catch :)
11:23:04 <kosmikus> thanks
11:23:09 <kosmikus> well, and sorry for interrupting
11:23:26 <kosmikus> but I could see the faces of the others, you couldn't ;)
11:23:57 <SyntaxNinja> no need to apologize, you were right :)
11:24:12 <SyntaxNinja> I can well immagine the faces of the others.
11:25:20 <kosmikus> and, yes, I enjoyed icfp a lot
11:26:03 <Lemmih> Hi SyntaxNinja and kosmikus.
11:28:41 <shapr> hiya franka, is this your first time here?
11:28:47 <franka> Yes, why?
11:29:12 <shapr> Because, I know you well enough from your online writings that I don't remember if you've been to #haskell before or not.
11:29:31 <franka> Oh.  Yeah, I just wanted to see what it was like.
11:29:41 <shapr> I'd still like to know why you think dependent types might lead to a lack of modularity.
11:30:03 <kosmikus> hi franka. I've heard you're at cwi now?
11:30:13 <franka> Because they encourage code which depends on implementations rather than interfaces.
11:30:22 <shapr> hm
11:30:23 <franka> Yeah, I will be.  I haven't started yet.
11:30:26 <shapr> I'll think about that, thanks.
11:30:42 <franka> Do I know you, kosmikus?
11:30:51 <kosmikus> franka: andres loeh
11:30:58 <franka> Oh, heya, Andres.
11:31:19 <franka> Where are you now?
11:31:27 <kosmikus> franka: bonn
11:31:34 <franka> Ah, with Ralf?
11:31:36 <kosmikus> yes
11:31:56 <franka> Good luck to you.
11:32:07 <kosmikus> Bruno Oliveira is visiting at the moment; it's a lot of fun so far ;)
11:32:17 <kosmikus> franka: what will you be doing at CWI?
11:32:22 <franka> I met Bruno at a conference the other year.
11:32:36 <franka> I'll be working on the Trust4all project.
11:33:14 <franka> It's to do with attaching trust metrics and ensurers to dynamic components.
11:33:41 <franka> For example, to make sure when you add a component to a mobile phone that it doesn't hog all the resources.
11:33:53 <kosmikus> yeah, I'm just reading the project summary ...
11:33:57 <franka> They want to use the Reo stuff that Dave talked about.
11:34:21 <kosmikus> are you working with Dave?
11:34:32 <earthy> sounds like capabilities and 'A Security Kernel Based on the Lambda-Calculus' might apply
11:34:39 <franka> Not on that project, but he's in the same group, yeah.
11:34:51 <kosmikus> oh, nice
11:35:14 <franka> Oh, hi, Arthur.
11:35:29 <earthy> hiya Frank. :)
11:35:46 <franka> I'm not familiar with that paper, but I'm guessing it might not apply very much.
11:35:57 <franka> My sense is that they don't want to do program analysis, but rather dynamic monitoring.
11:36:18 <SyntaxNinja> CosmicRay: "concerns about spreading information on IRC... received some discussoin on #haskell" that's funny
11:36:39 <franka> Anyway, I will be more of an implementor drone than a research contributor, I think.
11:36:45 <Korollary> hah I was just reading that mail
11:37:03 <earthy> franka: that is exactly why I think it might in fact apply
11:37:04 <Korollary> pretty ironic
11:37:05 <earthy> ;)
11:37:12 <cm> dons, I get this while configure'ing hs-plugins (latest darcs): *** Exception: sh: runProcess: does not exist (No such file or directory)
11:37:16 <cm> dons, any idea?
11:37:19 <earthy> and it's not a paper, but a PhD thesis
11:37:20 <franka> OK, I'll look into it.  Thanks, Arthur.
11:37:27 <earthy> it's based on the KeyKOS ideas
11:37:38 <earthy> but forms a cleaner explanation
11:38:03 <earthy> especially if you want to describe 'ensurers'
11:38:29 <franka> But an additional concern is that their formalism has nothing to do with lambda-calculus.  It will probably be based on Reo, which is kind of an asynchronous relational calculus.
11:38:40 <earthy> ah, yes.
11:38:53 <franka> Actually, it's not even a calculus.  It's more a semantics with a diagrammatic form.
11:39:16 <earthy> the base idea in that thesis is that of a 'capability'
11:39:47 <earthy> a capability can be e.g. the possibility of using the processor
11:40:48 <franka> I see.  Yeah, the trust stuff might described in a capability sort of way.
11:41:03 <franka> But I still don't know enough details to say anything concrete about it.
11:41:29 <earthy> good luck with the project though! it sounds like an interesting one
11:41:43 <franka> Thanks, Arthur.
11:42:33 <kosmikus> yes, good luck franka
11:42:39 <kosmikus> still working on your thesis, too ?
11:42:42 <franka> Thanks, Andres.
11:42:48 <franka> Yes, yes, the never-ending thesis.
11:43:03 <franka> It's a pain in the ass.
11:44:03 <franka> I'm working on it. But the past two weeks I haven't had much of a chance to do work because of personal reasons.
11:44:58 <franka> I'm going to try to get in a full day's work tomorrow.
11:45:35 <shapr> franka: I suspect you don't need the short tour of #haskell.
11:45:54 <franka> What is there to tour on an IRC channel?
11:46:05 <C-Keen> franka: tour?
11:46:05 <shapr> Ah, I'm glad you asked :-)
11:46:23 <earthy> well, there's lambdabot
11:46:26 <C-Keen> .o(hi btw)
11:46:29 <earthy> with the ever useful
11:46:29 <shapr> There's the ever useful lambdabot, the channel logs url in the topic, and the Haskell Wiki.
11:46:36 <earthy> @hoogle a -> a -> Bool
11:46:37 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
11:46:37 <lambdabot> Prelude.(>) :: Ord a => a -> a -> Bool
11:46:37 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
11:46:40 <shapr> earthy: Are you reading my mind again?
11:46:51 <earthy> and
11:47:01 <earthy> @eval foldr (+) 0 [1..10]
11:47:02 <lambdabot> 55
11:47:03 <franka> Oh, interesting.  Does it do only show exact matches?
11:47:25 <astrolabe> Show him @pl!
11:47:27 <shapr> @index fmap
11:47:28 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
11:47:28 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
11:47:28 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:47:48 <franka> Hm, neat.
11:48:09 <earthy> well, it will also do
11:48:28 <earthy> @hoogle (Int -> Bool) -> [Int] -> [Bool]
11:48:29 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
11:48:29 <lambdabot> Prelude.fmap :: Functor a => (b -> c) -> a b -> a c
11:48:29 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
11:48:36 <shapr> lambdabot has a bunch of useful tools. They were originally written to assist in teaching newbies, but now they're useful for everyday Haskell tasks.
11:48:38 <franka> What if the output is infinite?
11:48:43 <shapr> try it
11:48:50 <franka> @eval [1,..]
11:48:51 <lambdabot>  parse error on input `..'
11:48:55 <franka> Oops.
11:49:00 <Cale> @eval [1..]
11:49:01 <franka> @eval [1,..]
11:49:02 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
11:49:02 <lambdabot> 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
11:49:02 <lambdabot> 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
11:49:02 <lambdabot> 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,
11:49:02 <lambdabot> 95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
11:49:04 <lambdabot> 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,
11:49:06 <lambdabot> 130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,
11:49:08 <lambdabot> [24 @more lines]
11:49:10 <lambdabot>  parse error on input `..'
11:49:14 * basti_ laughs
11:49:18 <basti_> it's too tempting.
11:49:30 <franka> So much for my Haskell. :/
11:49:46 <Cale> @pl \f g x y -> f (g x) (g y)
11:49:47 <lambdabot> join . ((flip . ((.) .)) .) . (.)
11:49:51 <earthy> heck, you fully grok category theory. :P
11:50:07 <franka> No, only the tip of the iceberg, I'm afraid.
11:50:19 <shapr> @listmodules
11:50:20 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
11:50:20 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
11:50:20 <lambdabot> spell state system todo topic type version vixen where
11:50:42 <franka> So @pl eliminates variables and outputs a point-free form?
11:50:49 <Cale> yep
11:50:55 <kosmikus> shapr: what's darcsPatchWatch? is there something like a #darcs-commits channel?
11:51:02 <franka> Is there an inverse?
11:51:17 <shapr> lambdabot uses dons hs-plugins for dynamic reloading. dons wrote a paper about hs-plugins that discusses lambdabot and Yi.
11:51:34 <Cale> franka: there really ought to be, but I don't think so at the moment
11:51:43 <franka> Oh, right, that's on my reading list.
11:52:02 <thedward> @hoogle ( a -> bool ) -> [a] -> [a]
11:52:03 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
11:52:03 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
11:52:03 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
11:52:18 <franka> And if the computation doesn't terminate, it sets a time limit, I suppose.
11:52:26 <shapr> kosmikus: Yes, but darcsPatchWatch only works for a single hardcoded repo and channel at the moment. I think stefan and dons use it for a private lambdabot instance at unsw. Feel free to generalize it.
11:52:28 <kosmikus> franka: for @eval, yes
11:52:32 <luqui> hi.  I have a type Foo a b, and I want to make it a functor in a
11:52:47 <luqui> like "instance Functor (flip Foo b)"
11:52:54 <luqui> how do I do that?
11:53:01 <kosmikus> shapr: ok, thanks
11:53:16 <basti_> switch places of a and b? ;)
11:53:32 <luqui> that doesn't work because of my other constraints
11:53:35 <manulito> i just learned how to change a simple value using a lambda notation, tho im not able to change a tuple, cant figure how to write the lambdafunction, to change for example the inttuple, (a,b) to (a+1,b+2)
11:53:54 <luqui> (I'm trying to implement a List using the Rec type)
11:53:57 <basti_> luqui: i'm curious about that as well.
11:54:04 <franka> I dunno if you can do it in GHC now, but you can define a type synonym with args in the other order.
11:54:27 <franka> type RFoo b a = Foo a b
11:54:28 <Cale> however, you must fully apply that synonym wherever it is used
11:54:29 <psi> manulito: \(a,b) -> (a+1, b+2)
11:54:29 <luqui> like "type FooFlip a b = Foo b a"?
11:54:30 <basti_> @plugs (\(a,b)->a) (5,7)
11:54:32 <lambdabot> 5
11:54:39 <Cale> so that doesn't work
11:54:45 <basti_> luqui: see franka's response!
11:54:45 <Cale> but you could use a newtype
11:54:48 <basti_> that will work
11:54:53 <franka> Cale Yeah, that's why I'm not sure if GHC will accept it.
11:54:59 <luqui> Cale, example?
11:55:03 <franka> But GHC does so many things nowadays I don't know.
11:55:16 <manulito> psi: thanks
11:55:24 <Cale> newtype RFoo b a = RFoo (Foo a b)
11:55:40 <luqui> hmmmm
11:56:12 <Cale> I've had that problem before too.
11:56:16 <Cale> It would be nice to have type lambdas :)
11:57:27 <basti_> yes.
11:58:12 <shapr> hi Kernel-Kris, learning Haskell?
11:58:28 <shapr> Kernel-Kris: Are you KrispyKringle?
11:58:41 <Kernel-Kris> thinking about it why?
11:58:43 <franka> Is there a way to do the @ commands without spewing it out in public?
11:59:01 <Cale>  /msg lambdabot @whatever
11:59:03 <shapr> Kernel-Kris: Because, I like to give short introductions to people who are considering Haskell.
11:59:05 <basti_> franka: yes per /query
11:59:15 <franka> Thanks.
11:59:28 <shapr> Kernel-Kris: Do you want the short tour of #haskell and Haskell?
11:59:36 <Kernel-Kris> well yes im considering it
11:59:39 <Kernel-Kris> sure
12:00:11 <shapr> Ok! First on the tour is the famous lambdabot, with many useful tools both Haskell-related and other...
12:00:29 <shapr> Next is the url to the channel logs in the topic...
12:00:48 <shapr> After that there's the Haskell Wiki - http://www.haskell.org/hawiki/
12:00:56 <shapr> @learn And the always useful "Learning Haskell" page.
12:00:57 <lambdabot> http://www.haskell.org/learning.html
12:01:25 <shapr> @wiki HaskellDemo The last stop on the tour is the HaskellDemo page, the syntax introduction for impatient people.
12:01:26 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo The last stop on the tour is the HaskellDemo page, the syntax introduction for impatient people.
12:01:50 <shapr> Kernel-Kris: Tadah! Have any specific questions? Or would you like to read some promotional literature first? ;-)
12:02:39 <shapr> Saying "promotional literature" always makes me feel like a marketroid.
12:04:49 <Korollary> but you are a marketroid
12:05:01 <Cale> written in Haskell :)
12:05:02 <shapr> Marketroids don't write code!
12:05:05 <shapr> aiee!
12:05:22 <shapr> Someone recently asked me if I had ever failed the Turing test. I wasn't sure how to answer.
12:05:40 <Korollary> shapr, could you talk to me more about the haskell solutions and what haskell can do for me ?
12:05:41 <franka> How about: SYNTAX ERROR
12:05:47 <kolmodin> :D
12:05:57 <Kernel-Kris> well im just looking into diffrent languages to start with as ive never dont any coding
12:06:03 <shapr> Korollary: phbtt!
12:06:30 <shapr> franka: I'll use that response next time.
12:06:30 <Korollary> omg, what an opportunity to put to the test the claim that nonprogrammers were more comfortable learning haskell...
12:06:46 <earthy> kernel-kris: then go ahead and try to learn programming using haskell
12:06:51 * shapr is already teaching Haskell to his formerly non-programmer girlfriend.
12:07:06 <Philippa> how long's that been going on, anyway?
12:07:17 <Kernel-Kris> well im also looking for someone to teach me as well........
12:07:26 <Korollary> dates back to the ancient egypt, iirc
12:07:29 <shapr> Philippa: I put an hour into it, she said I need to take classes on being a teacher :-)
12:07:41 <earthy> Kernel-Kris: right place for it. :)
12:07:48 * Philippa sniggers
12:07:54 <Philippa> which way did she mean that? ;-)
12:08:11 <Korollary> Philippa: you are asking a man to interpret what a woman means by what she says...
12:08:25 <shapr> But she's been writing her own ADTs and functions that typecheck successfully since then.
12:08:37 <Kernel-Kris> are there any apps that youll have written that i can take a look at
12:08:41 <Philippa> Korollary: or he could've had the sense to just ask if he wasn't sure?
12:08:46 <Philippa> shapr: cool
12:08:56 <Philippa> I might teach Damien a little for use as a scripting-type language sometime
12:09:02 <Philippa> he keeps doing tedious things with text
12:09:10 <shapr> I did ask, she said that I treat her like she's already a programmer who is newly learning Haskell.
12:09:23 <Philippa> ah, that figures
12:09:44 <earthy> yup, it does
12:09:50 <shapr> Kernel-Kris: Pugs and darcs are two decent sized Haskell applications.
12:09:58 <earthy> it's hard to explain programming to people that can't program
12:10:13 <shapr> I disagree, it's easy to explain, but it's hard to teach.
12:10:21 <shapr> Er, lemme clarify that...
12:10:30 <Philippa> it's hard to transmit intuition?
12:10:35 <shapr> It's easy to explain the process, but it's hard to teach others how to do that process.
12:11:13 <shapr> Kernel-Kris: http://www.pugscode.org/ and http://www.darcs.net/DarcsWiki/CategoryBinaries
12:13:30 <Kernel-Kris> so if i wanted to get started what would i need.......like a tool kit or something
12:13:30 <Kernel-Kris> ?
12:13:31 <franka> Wow.  pugscode recommends reading TAPL.
12:13:56 <franka> Sounds like a good vector for the PLT virus.
12:14:11 <shapr> Pugs was started as applied homework for TaPL.
12:14:18 <Cale> Kernel-Kris: Get ghc -- what platform are you on?
12:14:31 <shapr> well maybe not homework, attempt to apply TaPL to the real world?
12:14:49 <Kernel-Kris> im on windows now....cause im at work but normailly im on FreeBSD
12:15:21 <micket> GHC is buggy on windows, or at least, was for me.
12:15:26 <Philippa> TaPL + a nice monad will get you a long, long way
12:15:55 <franka> What a missed opportunity for Ocaml, though.  Pugs is really good press for Haskell.
12:16:27 <shapr> Well, I prefer Haskell, so...
12:16:32 <Philippa> Pugs wouldn't have happened as easily in ocaml though
12:16:35 <Cale> I don't know about FreeBSD, but this looks useful http://www.freebsd.org/ports/lang.html#ghc-6.4_2
12:16:36 <franka> Yeah, me too.
12:16:42 <Philippa> not without retaining a strong haskell influence, at the very least
12:16:57 <Cale> For windows, and lots of other operating systems: http://www.haskell.org/ghc/download_ghc_641.html
12:16:59 <shapr> OCaml has their own "faster than C" publicity.
12:17:16 <shapr> Lemme clarify that...
12:17:23 <Philippa> which probably backfires even more than the "no mutable variables!" publicity
12:17:31 <franka> I'm curious how Haskellish the Pugs code is, though.  Not curious enough to actually look, but... :)
12:17:35 <Philippa> faster than some C compilers in some specific situations :-)
12:17:47 <shapr> OCaml has "executes faster than C" publicity. Haskell has "writes faster than *" publicity.
12:17:51 <Philippa> franka: loads of monadic work and a parsec-based parser, IIRC
12:18:22 <shapr> franka: Pugs uses GADTs and Oleg's delimited continuation transformer monad as well.
12:18:43 <Philippa> when I say loads, autrijus turned it into a compiler in the space of a day without even touching the evaluation code by replacing the underlying monad and using template haskell...
12:18:43 <franka> Oh?  That sounds pretty state-of-the-art, then.
12:19:54 <franka> That's pretty impressive.
12:20:44 <Philippa> yeah. Better yet, he did it /before/ I published my little article writing a compiler for a toy language with TH without a pre-existing interpreter...
12:20:53 <Philippa> (but while I was writing it)
12:21:14 <shapr> franka: Speaking of which, in your copious spare time while writing your thesis, want to write an article for The Monad.Reader?
12:21:25 * shapr is mostly joking.
12:21:34 <franka> Hah.  No way.  Sorry. :)
12:22:00 <shapr> Well, I gotta ask. Sometimes people even say yes!
12:22:09 <shapr> Speaking of which, I want to switch to lhs2TeX for the next issue.
12:23:55 <Kernel-Kris> ok i have GHC installed now what
12:24:46 <shapr> You probably want to start by looking at the HaskellDemo, and then continue by reading Hal Daume's "Yet Another Haskell Tutorial"
12:26:28 <SamB> shapr: if you don't like saying "promotional literature", you could say "propaganda"...
12:26:41 <shapr> Kernel-Kris: I'd appreciate any feedback on the HaskellDemo, I wrote most of it and I'd like suggestions for improvement.
12:27:20 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
12:28:21 <shapr> hiya stepcut, how's code?
12:28:24 <stepcut> good!
12:29:03 <stepcut> I am about to annouce a new (alpha-level) library, and I can't decide if I should cross-post to libraries@haskell.org and haskell-cafe@haskell.org or not
12:29:32 <franka> Hm, there should be a Bifunctor class.
12:29:34 <Igloo> I'm not a fan of cross-posting to mailing lists
12:29:58 <shapr> franka: btw, do you have an audioscrobbler account?
12:29:59 <stepcut> I need peoples' feedback on some questions, so I think I definately want to mail to haskell-cafe
12:30:10 <stepcut> people's
12:30:21 <Igloo> If you can set a reply-to that thee list server won't eat then that'd be fine as far as I'm concerned
12:30:32 <franka> shapr: I think not.
12:30:55 <franka> shapr: Which is to say that, I remember looking at it, and probably had one at some point, but it's probably gone now.
12:31:01 <shapr> ah well
12:31:02 <stepcut> shapr: I think I finally squashed the last bug in my pipes code, so now I am cleaning it up and documenting it for TMR  :p
12:31:36 <shapr> yay!
12:31:43 <franka> Why, you want to know what I listen to?
12:32:00 <shapr> I think FLM 0.1 will be released before TMR
12:32:14 <shapr> franka: Yes, in more detail than your music page on cs.uu
12:32:20 <stepcut> shapr: nice
12:32:42 <franka> Oh, yeah, that page is way out of date, anyway.
12:33:13 <franka> Right now I'm listening to Jeff Buckley.
12:33:29 <shapr> Do you know Dillinger Escape Plan, and if so, anything similar?
12:33:41 <franka> No, dunno that one, I'm afraid.
12:33:57 <micket> I AM SO HAPPY!!!
12:34:07 <micket> i finally killed the last bug in my program!
12:34:20 <micket> (to a degree that it works at all now)
12:34:21 <stepcut> micket: sweet!
12:34:34 <franka> The last one you know of. :)
12:34:58 <micket> yeah well compared to crashing it every run it now gives me results that are correct
12:35:01 <franka> Yeah, I'm a bastard.
12:35:12 <micket> thats why i added that last part :D
12:35:19 <micket> this is a breakthrough for me though :)
12:35:30 <franka> Congrats, then.
12:35:52 <micket> time to optimize it
12:36:05 <Cale> micket: what are you writing?
12:36:39 <micket> i have a bunch of timetables for a network of trams, and i'm writing a program to find the fastest way to a destination
12:36:47 <micket> given by the user
12:36:55 <micket> (along with a time for departure)
12:36:57 <Cale> cool :)
12:37:16 <micket> It's still roughly O(n^2) though
12:39:22 <earthy> micket: that's pretty impressive
12:39:24 <franka> Cale You're right; the manual still says type synonyms must be fully applied.
12:39:31 <{Arias}> hi!
12:39:53 <franka> I thought I read somewhere that they'd lifted that restriction in a recent release, but I guess I was wrong.
12:40:16 <franka> Hi, Arias.
12:40:21 <earthy> I've not seen it lifted (unfortunately)
12:40:43 <franka> It says, though: his design decision is independent of all the others, and easily reversed, but it makes sense to me.
12:40:47 <franka> his=This
12:41:01 <micket> ok then i'm probably beeing a bit to hopefull earthy, O(nn^3) :)
12:41:31 <earthy> micket: O(2^n) would be more believable. :)
12:41:38 * CosmicRay returns
12:41:42 <franka> This is for instance heads.  Presumably lifting it would require overlapping instances enabled.
12:41:44 <earthy> as it sounds to me like a traveling salesman problem ;)
12:42:10 <Cale> I asked autrijus about lifting that restriction a little while ago. It's probably not so bad to do some things, but the type-lambda style uses have problems, iirc.
12:42:39 <Cale> I think he said he'd talk to Simon about it.
12:43:08 <franka> Yeah, type-lambda creates a ton of ambiguities.
12:43:08 <micket> earthy, unless i got that problem completely wrong its not very much like it. Isn't that the shortest route to visit all nodes?
12:43:24 * earthy nods
12:43:24 <autrijus> and Heffalump iirc pointed out that it leads to impredictive and ambiguous situations
12:43:27 <earthy> that's one formulation
12:43:55 <autrijus> and also, because you can overapply a synonym, in practice (as for monads) you can just omit the type params
12:44:02 * earthy nods
12:44:04 <earthy> I can imagine
12:44:05 <Oejet> earthy: This is obviously the shortest path. O(n^2).  Dynamic programming, ya know? ;-)
12:44:11 <earthy> oejet: :)
12:44:14 <franka> earthy I think it's a shortest path problem. Dijkstra had an efficient solution for it.
12:44:49 <earthy> yeah, but that depends on mutable state
12:44:50 <micket> I'm trusting Oejet on this one, i suck at calculating O(n?)
12:44:50 <earthy> ;)
12:45:09 <franka> It's a relaxation technique, right?
12:45:12 <Oejet> Or diff arrays. :-D
12:45:17 <Cale> Diff arrays!
12:45:19 <Sonderblade> is there any way to make ghc run faster? its very slow even for a "Hello, world" program
12:45:33 * ValarQ dances and sings the Diff array song
12:45:49 <ValarQ> Sonderblade: you can compile it ;)
12:45:57 <micket> its a bit different from shortest path though, shortesst time, which varies (and sometime not having a connection at all etc)
12:46:02 <earthy> franka: yup, dijkstra's algorithm is like that
12:46:58 <Cale> Sonderblade: What are you running it on? There's a noticeable constant term in the length of time ghc takes to run, but I don't find it all that slow.
12:47:38 <Cale> (and how long is it taking?)
12:47:53 <micket> I have never noticed any slowness on windows or linux myself... only alot of crashes on windows
12:47:56 <Sonderblade> roughly 3-4 seconds on a one-line program
12:48:20 <micket> just for running main with a purStrLn in?
12:48:31 <ValarQ> thats pretty slow...
12:48:31 <micket> *putStrLn
12:48:36 <Cale> micket: he's referring to the time taken to compile
12:48:48 <micket> ah doh. nm me
12:48:49 <Cale> it's the linking that takes all the time
12:49:03 <dcoutts> which is due to the static linking
12:49:27 * dcoutts hopes forward to ghc packages being .so files
12:51:57 <Cale> Sonderblade: There's a (nearly?) constant hit you'll take for linking, but you don't need to worry about things getting too much slower on larger inputs. It generally compiles a reasonably sized source file within a few seconds.
12:53:01 <Cale> for testing, using ghci is probably faster
12:53:17 <Sonderblade> ill try that thanks
12:54:55 <franka> The other day I read somebody's weblog entry which said that "enumerating badness" is a bad approach to security.
12:55:12 <franka> It occurs to me that this is a good argument (if you accept it) for typed languages over untyped.
12:55:42 <dcoutts> it's a good argument for eliminating general recursion :-)
12:55:51 <Cale> heh
12:55:53 <franka> Since untyped languages basically deal with bad inputs by rejecting them explicitly, or passing them to the runtime, which always has a default security policy, which might be different from yours.
12:56:15 <franka> dcoutts: That is a very astute observation.
12:56:21 <dcoutts> "if you can't prove it works then you've no right to have it compile!"
12:56:32 <dcoutts> see eppigram :-)
12:56:35 <micket> ouch
12:56:39 <dcoutts> @where eppigram
12:56:40 <lambdabot> I know nothing about eppigram.
12:56:48 <franka> Yes.  I was thinking of constructivism and induction.
12:56:48 <Cale> epigram
12:56:54 <dcoutts> @where epigram
12:56:55 <lambdabot> http://sneezy.cs.nott.ac.uk/epigram/
12:57:22 <franka> Also the greater prevalance of defining abstract datatypes for input/output formats.
12:57:28 <franka> In typed languages, I mean.
12:57:46 <franka> In Python, they generally deal with HTML as text, for example, but in Haskell that is kind of unthinkable.
12:58:17 <franka> So they end up filtering I/O to prevent injection attacks, while Haskell code rejects it by default, since it's untypeable.
13:01:02 <franka> So, perhaps one could form a slogan: "Haskell enumerates goodness."
13:02:01 <gubatron> does Haskell support OO functionalities, such as encapsulation and inheritance?
13:02:19 <franka> Not directly.  You need to emulate them.
13:02:42 <gubatron> thanks
13:02:52 <xerox> @quote+ franka <franka> So, perhaps one could form a slogan: "Haskell enumerates goodness."
13:02:53 <lambdabot> franka <franka> So, perhaps one could form a slogan: "Haskell
13:02:53 <lambdabot> enumerates goodness." hasn't said anything memorable
13:03:06 <Cale> gubatron: the module system provides some kinds of encapsulation
13:03:20 <franka> Rude lambdabot.
13:03:43 <Cale> wha?
13:03:49 <Cale> oh
13:03:51 <gubatron> thanks!
13:03:59 <Cale> gubatron: Most other kinds are largely made irrelevant by lack of mutable state.
13:05:13 <Cale> Any mutable state in Haskell is controlled by the type system through the use of various monads.
13:06:23 <kolmodin> @where love
13:06:24 <lambdabot> I know nothing about love.
13:06:31 <kolmodin> lambdabot: Yeah, right, you are just a bot.
13:06:58 <psi> @vixen love
13:06:58 <lambdabot> People think I'm weird...   do you?
13:12:23 <HeverClev> A question about polymorphism: I'm writing a foldTree function for a custom kind of tree
13:12:47 <HeverClev> it's the Node / Leaf variant but with two parameter types: data Tree a b = Leaf a | Node b ...
13:13:02 <Cale> okay
13:13:22 <HeverClev> I don't know how to write the type declaration for the foldTree  parameter  function
13:13:43 <HeverClev> since it should accept a and b types
13:13:52 <franka> Tree a b -> (a -> c) -> (b -> c) -> c
13:14:20 <franka> Is this homework?
13:14:36 <franka> That's not a tree, anyway.
13:14:37 <HeverClev> no, it's voluntary Haskell learning
13:15:01 <franka> data Tree a b = Leaf a | Node (Tree a b) (Tree a b)
13:15:28 <shapr> #haskell is a good resource for voluntary Haskell learning.
13:15:35 <franka> data Tree a b = Leaf a | Node (Tree a b) b (Tree a b)
13:15:37 <ski> data Tree a b = Leaf a | Node b (Tree a b) (Tree a b)  -- use b, too
13:15:40 <franka> I meant.
13:15:43 <shapr> and involuntary if someone hangs around long enough...
13:15:51 <HeverClev> that's fine for the tree, but what about foldTree
13:15:55 <HeverClev> foldtree :: (?) -> c -> Tree a b -> c
13:15:58 <ski> (a -> r) -> (r -> b -> r -> r) -> Tree a b -> r
13:16:03 * shapr beats an innocent bystander with a lambda
13:16:05 <earthy> foldTree will need to take 2 functions
13:16:16 <earthy> as there are two alternatives in the adt
13:16:22 <HeverClev> Is there any way to use this kind of polymorphism in Haskell ?
13:16:23 <ValarQ> shapr: ow!
13:16:30 <shapr> ValarQ: That's what you get for being innocent!
13:16:30 <franka> shapr: I listened to Dillinger Escape Plan.  It looks like hardcore, which is not my area.
13:16:36 <boegel|home> shapr: 184 in #haskell, it seems like more and more people are finding their way to #haskell
13:16:36 <ValarQ> shapr: :(
13:16:37 <shapr> franka: ok, just curious.
13:16:38 <earthy> hmmm... chocolate lambda's
13:16:39 <HeverClev> I mean, which is the elegant way to do it with a func.
13:16:45 <shapr> boegel|home: Yeah, we hit 188 a few days back.
13:16:51 <boegel|home> shapr: w00 !
13:16:59 <boegel|home> shapr: I say we go for the 200 !
13:17:05 * boegel|home practices guitar
13:17:30 * shapr practices Haskell
13:18:02 * earthy studies tony and the chocolate factory
13:18:18 <ski> HeverClev : elegant way to define the foleTree, you mean ?
13:18:36 <HeverClev> to have only a function for this foldTree, which accepts a and b types
13:18:50 <HeverClev> i.e. a kind of polymorphism
13:18:54 <ski> um
13:18:57 <Cale> HeverClev: you want foldTree :: (a -> c) -> (b -> c -> c -> c) -> Tree a b -> c
13:19:11 <ski> not really, just higher-order function
13:19:14 <Cale> You pass foldTree replacements for the constructors of the tree.
13:19:32 <ski> HeverClev : did you want to merge the two type arguments ?
13:19:36 <ski> bah
13:19:43 <HeverClev> ok, I accept the two func. way,  just checking if I was missing something
13:19:44 <ski> s/type/function/
13:19:54 <franka> HeverClev: The point is you use one function, no matter what the node or leaf types are.
13:20:02 <Cale> that is, passing Leaf and Node to foldTree should give the identity function on trees.
13:20:17 <ski> HeverClev : you could do  (Either a (b,c,c) -> c) -> Tree a b -> c
13:20:48 <HeverClev> ok ski, that looks more like I was looking for
13:20:57 <HeverClev> what I was looking for *
13:21:29 <Cale> HeverClev: it's somewhat nicer the other way though :)
13:21:41 <HeverClev> thank you all, Cale, ski, franka, etc. the Haskell community is great!
13:21:41 <ski> (or .. even   (TreeF a b c -> c) -> Tree a b -> c     with   data TreeF a b c = LeafF a | NodeF c b c    :)
13:21:58 <Cale> hehe :)
13:22:05 <HeverClev> last time I tried something like this in some other community, I got a ban dude..
13:22:18 <Cale> whoa
13:22:18 <ValarQ> what is (a -> c)  ?
13:22:20 <earthy> what, for asking??
13:22:30 <HeverClev> usually ban comes for free with the first question
13:22:33 <Cale> ValarQ: the type of functions from some type a to some type c
13:22:39 <ski> ValarQ : the type of functions from the type a to the type c
13:22:39 <earthy> valarq: a function taking things of type a and returning things of type c
13:22:46 <earthy> ouch. :)
13:22:51 <Cale> hehe
13:22:54 * ski grins evilly
13:23:03 <shapr> HeverClev: What community was it?
13:23:06 <ValarQ> the function type type of fu... ok then
13:23:17 <Cale> hehe
13:23:31 <Cale> yeah, we each interpreted (a -> c) in a subtly different way
13:23:37 <HeverClev> ski can you elaborate on that TreeF thing ?
13:23:45 <HeverClev> shapr it was #java on EFnet
13:24:02 <shapr> Oh, I am unsurprised.
13:24:12 <ski> ValarQ : e.g. if  a = Int   and  b = String   then this is the type of functions taking integers and returning strings  (one example is a standard decimal conversion to string)
13:24:15 <earthy> EFnet. *and* java. :)
13:24:16 <ski> HeverClev  : sure
13:24:17 <shapr> #java here on freenode used to be nice, but no longer.
13:24:22 <HeverClev> shapr a two or three years ago
13:24:48 <Cale> shapr: what happened to it?
13:24:57 <ski> HeverClev : really,  TreeF a b c   is just more or less the same as  Either a (c,b,c)
13:25:00 <ValarQ> ski: i think i got it...
13:25:23 <shapr> Cale: Overrun by inconsiderate newbies who flooded the nice oldbies until bans and irritation became common.
13:25:28 <HeverClev> I'm sorry, I've seen either mentioned in a paper but I'm not sure
13:25:32 <earthy> btw, if you like chocolate, have a look at http://cgi.omroep.nl/cgi-bin/streams?/rvu/keuringsdienst/tony_english1.rm
13:25:39 <ski> HeverClev : data TreeF a b c = LeafF a | NodeF c b c     seee, it's either an 'a'  or  a 'c' a 'b' and a 'c' again
13:25:58 <ValarQ> shapr: sad, i can see how it could happen thought
13:26:00 <franka> Java'ers wear suits and have serious business to do.  They can't be bothered with questions.
13:26:19 <earthy> they don't optimise for fun
13:26:24 <earthy> they optimise for money earned
13:26:33 <shapr> right, #haskell is -Ofun
13:26:57 <Philippa> free lube on the way in and everything ;-)
13:27:38 <franka> Martin Fowler wrote an article the other day about how the Ruby community is very friendly.
13:27:43 * earthy kicks philippa
13:27:52 <ski> HeverClev : if you'd want to use this foldTree to do something over a tree .. hm, say the 'b's are strings and the 'a's are numbers, and we want to sum numbers and concatenate strings ..
13:27:55 <earthy> and slips on the lube :P
13:27:57 <franka> Perhaps you should invite him here.
13:29:05 <Cale> HeverClev: In general, folding functions just take the datatype constructors and replace them with other functions (or values in the case of nullary constructors)
13:29:08 <ski> HeverClev : foldTree (\foo -> case foo of LeafF n -> (n,""); NodeF (n0,s0) s (n1,s1) -> (n0+n1,s0++s++s1)) myTree
13:29:15 <Lor> Hey, I'm quite sure that there is some Haskell (or other typed language) EDSL library that's meant to be used interactively from the toplevel loop. But I cannot think of any offhand. Any ideas?
13:30:05 <Philippa> earthy: you had that tongue out for a purpose?
13:30:26 <earthy> well, you're almost as far from me as my gf is currently, so, yeah. :P
13:30:31 <franka> What does EDSL stand for?
13:30:35 <Philippa> Lor: hmm, good question
13:30:42 <ski> embedded domain specific language ?
13:30:48 <Philippa> yeah
13:30:57 <Philippa> earthy: ouch
13:31:28 <shapr> Lor: Haskore is great fun in GHCi
13:31:29 <earthy> ah, not ouch. she went to london this morning for work
13:31:44 <franka> Maybe he means camlp4.
13:31:50 <Philippa> where're you atm?
13:31:56 <earthy> Utrecht, .nl
13:32:06 <franka> What a coincidence.  Me too!
13:32:12 <franka> :)
13:32:22 <franka> Oops, no, actually, Zeist.
13:32:28 <Muad_Dib> i'd never guessed that for the both of you :P
13:32:30 * Muad_Dib out
13:32:36 * earthy grins
13:32:49 <shapr> ik begrijp het niet!
13:32:54 <Philippa> Lor: Fran?
13:33:46 <franka> Ik weet er geen reet van.
13:34:03 <Philippa> you could probably use FRP fed into just about anything from a REPL if you really wanted to
13:34:09 <shapr> Lor: Check out various of Paul Hudak's EDSLs.
13:34:17 <shapr> Is the source for Dance online?
13:34:26 <earthy> not that I know of, shapr
13:34:29 <Philippa> in fact, that's be a really cool use for concurrency in haskell if ghci can be talked into working that way
13:34:44 <earthy> I've looked
13:35:06 <shapr> I'll email Paul Hudak.
13:36:44 <xerox> Happy happy, joy joy.
13:38:24 <Lor> What would really be a prime example would be an interactive shell EDSL. But is there one?
13:39:01 <shapr> What about HSshelscript?
13:39:18 <shapr> hiya tmoertel, I like your delimited continuations blog entry, when will you write more?
13:39:38 <ski> uri ?
13:39:43 <tmoertel> I'll start writing again, now that I'm back from holiday.
13:40:10 <Philippa> Lor: I've done scripting-type stuff bit-by-bit in ghci once in a while - I guess that doesn't count though?
13:40:47 <tmoertel> ski: http://blog.moertel.com/articles/2005/09/13/scope-herding-with-delimited-continuations
13:41:01 <ski> vielen danke schn
13:41:13 <marcot> Why isn't gtk2hs in debian? Is there a reason for it?
13:41:18 <marcot> I was wondering about packaging it.
13:42:08 <franka> What's GIML?
13:42:16 <Speck> if it's cabalized, isn't there (or won't there be) some kind of way to automate the repackaging?
13:42:26 <Igloo> There's no good reason. You might want to check with the list that no-one is actively working on it, but I don't think anyone is
13:42:57 <tmoertel> franka: it's the working name for the Genetics Information Manipulation Language (and, since the initialism "GIML" is apparently quite overloaded, a lot of other things, too ;-)
13:43:23 <franka> Yes, I noticed the overloading bit in my web search. :)
13:43:43 <dcoutts> marcot, that'd be nice :-)
13:43:57 <marcot> Speck: not while cabel in sid be so old.
13:44:00 <marcot> dcoutts: then I'll do it.
13:44:16 <marcot> Igloo: =)
13:46:30 <dcoutts> marcot, try packaging 0.9.9, if you have any comments on packaging tell me and I'll fix it for 0.9.10 which will be out by the end of the month.
13:46:41 <Cale> tmoertel: if it's your acronym, think about sticking an E in there to get GIMEL, which is also a hebrew letter. :)
13:49:08 <marcot> dcoutts: are you the developer? I like it a lot, man..
13:49:16 * shapr randomly stumbles across CosmicRay in wikipedia
13:49:29 <tmoertel> Cale: If I append an "i" to "GIML", I get "Gimli" which happens to be the name of the dwarf from JRRT's Lord of the Rings.  (In fact, the interactive shell for GIMLI is called Gimli.)
13:49:50 <Cale> tmoertel: ah, nice :)
13:51:03 <dcoutts> marcot, I'm one of the developers and I package it for Gentoo so I'm sympathetic to packaging issues. :-)
13:51:52 <marcot> dcoutts: is the developing team very big? I'm on the list, but it doesn't seem to be very active.
13:53:25 <dcoutts> marcot, there are two core devs & a couple other contributers & a few packagers for various distros
13:53:50 <marcot> dcoutts: are you one of the core?
13:53:51 <dcoutts> marcot, but you're right the lists have been a little quiet recently. I have been accumulating bug fixes however.
13:53:55 <dcoutts> marcot, yep
13:54:22 <marcot> dcoutts: hum.. and how is the best way for strat helping?
13:54:32 <dcoutts> and we've got the cairo bindings to get out
13:54:57 <dcoutts> marcot, just express an interest in some area, or ask which bits need attention
13:55:18 <marcot> dcoutts: are you developing the cairo bindings too?
13:55:37 <dcoutts> marcot, xerox wrote the cairo bindings as part of a Google Summer of Code project
13:55:54 <dcoutts> we did a pre-release with the cairo bindings in it
13:56:07 <dcoutts> but we've not had an official release with them in yet
13:56:22 <dcoutts> but several people are elareay using the cairo bindings
13:56:30 <dcoutts> elareay/already
13:56:46 <Speck> yi is, right?
13:56:51 <marcot> dcoutts: what is the Goolgle Summer of Code?
13:57:05 <dcoutts> @google Google Summer of Code
13:57:07 <lambdabot> http://code.google.com/summerofcode.html
13:57:29 <shapr> boegel|home: Hey, first working version without darcs support or pretty formatting - http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=TestMargin
13:58:04 <Speck> ooh, flippi
13:59:00 <dcoutts> marcot, are you interested in OpenGL? There is some Gtk+/OpenGL integration bindings work to do.
13:59:22 <Philippa> Speck: better, FLM
13:59:40 <marcot> dcoutts: not nowadays. I'm planning to study it next year.
13:59:41 <Speck> FLM?
13:59:44 <marcot> In school.
13:59:45 <shapr> Fermat's Last Margin
13:59:50 <dcoutts> marcot, right
14:00:11 * Speck half-gets the joke
14:00:11 <marcot> dcoutts: did xerox won the prize of google?
14:00:25 <dcoutts> marcot, I've not heard actually.
14:00:27 <dcoutts> xerox, ping
14:00:41 <marcot> This google thing is nice.
14:00:47 <dcoutts> yes
14:00:51 <Sonderblade> i have a function like this foo a b = [a, b], why do i need type declarations for it? it should be polymorphic
14:00:55 <marcot> But strange, cause google's software aren't free.
14:01:26 <ski> Sonderblade : you shouldn't need type signature for that
14:01:35 <shapr> Speck: What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
14:01:39 <Cale> Sonderblade: that will automatically infer the type a -> a -> [a]
14:01:43 <shapr> How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs.
14:02:13 <Cale> er, haskell will infer the type foo :: a -> a -> [a]
14:02:16 <marcot> Isn't it kind of controversy?
14:02:24 <Speck> shapr: I guess I'd need to see it to believe it
14:02:34 <shapr> Speck: That's the url.
14:03:00 <shapr> I haven't added darcs support yet, and it's missing a bunch of fiddly features, but it works for the most part.
14:03:24 <Speck> I'm having trouble comprehending it
14:03:48 <shapr> I write lots of notes in the margins of my research papers.
14:03:49 <Speck> like I go to the FrontPage, and I see a bunch of stuff that looks like a wiki and buttons
14:03:57 <shapr> Well, that's testing stuff.
14:04:13 <shapr> It's not ready for full use yet, gimme a few days.
14:04:27 <Speck> I'm sure it will all come to light
14:04:30 <tmoertel> shapr: that's cool
14:04:41 <Cale> Are the pages automatically loaded from the postscript file?
14:04:44 <shapr> But the idea is that we can all share our margin notes with each other. And grep them, and more.
14:04:47 <shapr> Cale: yes
14:04:57 <shapr> you just put in the pdf/ps url and imagemagick does the rest.
14:05:04 <Cale> cool
14:05:11 <shapr> Well, the script also generates per-image wikipages and attaches the images.
14:05:22 <Sonderblade> Cale: calling print(foo(1, 2)) gives me a strange error
14:05:46 <Cale> Sonderblade: try  print (foo 1 2)
14:05:52 <shapr> Spark: Haven't you ever written informative or question notes in the margin of a book or research paper you own?
14:05:56 <Cale> (1,2) is a tuple
14:06:01 <ski> Sonderblade : you are trying to pass a pair, pass two args as Cale shows, instead
14:06:34 <shapr> Speck: opps
14:06:40 * shapr is getting sleepy
14:06:47 * Maddas too
14:06:49 <shapr> Speck: Haven't you ever written informative or question notes in the margin of a book or research paper you own?
14:06:54 <Maddas> Good night in advance :-)
14:06:55 <Cale> or   print (uncurry foo (1,2))
14:06:57 * ski has
14:07:07 <Sonderblade> thanks!
14:07:12 * boegel|home is back from practice
14:07:18 <ski> print (foo `uncurry` (1,2))
14:07:19 <Cale> and you don't need the print, if you're at the ghci/hugs prompt
14:07:24 <boegel|home> I think I'm getting RSI from playing guitar, is that possible ? :s
14:07:33 <shapr> The joke is, "If Fermat had this margin, we'd know his proof. This is the last margin Fermat would ever need."
14:09:19 <shapr> tmoertel: Thanks, hopefully it'll be ready for a 0.1 release in a few days.
14:09:38 <boegel|home> shapr: looks cool
14:09:41 * tmoertel will be looking forward to it
14:10:06 * boegel|home wonders where he left his 20-side dice
14:10:23 <boegel|home> I need it for practicing with my guitar :(
14:10:29 <Cale> hm?
14:10:48 <Cale> Why would you use an icosahedron to play the guitar?
14:10:48 <earthy> why's that?
14:11:20 <Cale> @dice 1d20
14:11:21 <lambdabot> 1d20 => 13
14:11:32 <boegel|home> well, I've only just started, so we've seen about 20 chords (is that the right term) and 16 tempo's
14:11:34 <ski> (hm, isn't there some solid with rhombic 20 surfaces)
14:11:41 <boegel|home> and I want to choose 'em random
14:11:46 <shapr> ski: Oh I want to know!
14:11:47 <xerox> I was about to ask :D
14:11:54 <Cale> Use @dice !
14:12:06 <boegel|home> Cale: yeah, @dice works, but that's quite distracting when practising :)
14:12:08 <ski> shapr : about rhobic ?
14:12:15 <boegel|home> I have a real one
14:12:18 <boegel|home> somewhere...
14:12:24 <earthy> over the rainbow
14:12:25 <Philippa> @dice 1d0
14:12:26 <lambdabot> 1d0 => 0
14:12:35 <Cale> heh
14:12:53 <shapr> ski: yeah
14:13:03 <Maddas> So many papers, so little time (:
14:13:35 <earthy> http://mathworld.wolfram.com/RhombicIcosahedron.html
14:13:37 <boegel|home> y0 ndm
14:13:38 <kosmikus> @dice 3d17
14:13:39 <lambdabot> 3d17 => 38
14:13:51 <kosmikus> close ...
14:13:51 <boegel|home> what does the number before d do ?
14:14:04 <ndm> yo boegel|home, am slightly drunk...
14:14:15 <earthy> boegel: the number of dice
14:14:17 <Cale> @dice 100d0
14:14:18 <lambdabot> 100d0 => 49
14:14:24 <Cale> what?
14:14:24 <boegel|home> ndm: look behind you !
14:14:25 <kosmikus> ha!
14:14:30 <boegel|home> earthy: oh, I see :)
14:14:34 <earthy> that's broken!
14:14:40 <boegel|home> Cale: makes sense :P
14:14:42 <ndm> boegel|home: what?
14:14:45 <earthy> hm. whiskey!
14:14:54 <boegel|home> ndm: hehe, just f*cking with your mind
14:14:56 <ndm> no, beer (bitter)
14:14:57 <kosmikus> @dice 200d0
14:14:58 <lambdabot> 200d0 => 0
14:15:00 <boegel|home> ndm: how many beers have you had ?
14:15:03 <ndm> not that drunk..., just slightly merry
14:15:09 <ndm> about 6, then a cycle ride home
14:15:23 <ndm> the cycle ride increases the heart rate and blood circulation, so makes you more drunk
14:15:23 <kosmikus> @dice -1d6
14:15:24 <lambdabot> "dice" (line 1, column 1):
14:15:24 <lambdabot> unexpected "-"
14:15:24 <lambdabot> expecting digit
14:15:25 <boegel|home> ndm: oh no, you went outside ?
14:15:35 <boegel|home> drunk people take crazy risks, unbelievable
14:15:36 <ndm> don't worry, it was already dark
14:15:45 <ski> shapr : some pics here, it seems
14:16:03 <boegel|home> ndm: oh, so that's why I'm always more drunk when I get home... makes perfect sense now :)
14:16:26 <ndm> its true, any exercise does it
14:16:27 <Cale> 100d0 seems to give results which are close to 50
14:16:31 <ndm> drink 1 pint, then go for a run - you will come back drunk
14:16:32 * boegel|home waves at Itkovian (check pm)
14:16:46 <ski> shapr : http://torina.fe.uni-lj.si/~izidor/ElekRevija2/IntrodRhombic.html
14:16:53 <kosmikus> can you have +?
14:16:58 <boegel|home> ndm: that's really cheap ! :)
14:16:59 <kosmikus> @dice 3d6+17
14:17:00 <lambdabot> 3d6+17 => 24
14:17:02 <ski> (shapr : forgot to paste link .. :)
14:17:05 <kosmikus> nice ...
14:17:25 <JoslGr0s> @dice 2d12
14:17:26 <lambdabot> 2d12 => 21
14:17:35 <shapr> ski: nifty!
14:17:39 <Cale> @dice 1d4 + 1d6 + 1d8 + 1d10 + 1d12 + 1d20
14:17:40 <lambdabot> 1d4 + 1d6 + 1d8 + 1d10 + 1d12 + 1d20 => 28
14:17:51 <boegel|home> Cale: cool
14:18:04 <ski> rhombic hexahedron = cube
14:18:14 <ski> rhombic dodecahedron
14:18:14 <JoslGr0s> sounds like ad&d 4 me
14:18:19 <ski> rhombic icosahedron
14:19:07 <shapr> That's cool, it has connections with Penrose tiles.
14:19:16 <ski> m
14:19:22 <Cale> SmallRhombicuboctahedron := CayleyGraph(SymmetricGroup(4),[(1,2,3,4),(1,2,3)]);
14:20:06 <kosmikus> I'll certainly bring lambdabot to my next roleplaying session ...
14:20:27 <dolmen> Hi
14:20:47 * ski wonders what race lambdabot would play
14:20:50 <shapr> Cale: Do you have a DSL like that?
14:20:57 <Cale> shapr: GAP
14:21:02 <Cale> +Grape
14:21:17 <boegel|home> have you people seen the Daily WTF on the Dexia Bank in Belgium ? I _used_ to be a customer there
14:21:20 <boegel|home> glad I'm gone...
14:21:38 <dolmen> @paste
14:21:39 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:22:04 <shapr> Cale: debs?
14:22:21 <shapr> aha
14:22:30 <Cale> http://www-gap.mcs.st-and.ac.uk/
14:22:36 <Cale> and yeah, it's in debian
14:22:53 * shapr boings cheerfully
14:22:54 <Cale> though I think you'll have to get grape separately
14:23:20 <Cale> http://www-gap.mcs.st-and.ac.uk/Packages/grape.html
14:24:09 <Cale> shapr: the documentation is frightening if you aren't a combinatorial group theorist though... perhaps even if you are.
14:24:37 <shapr> Bah, frightening is for other people.
14:25:03 <shapr> I went from Python to Arrows in ... two years?
14:25:15 <Cale> :)
14:26:16 <astrolabe> Good attitude Shapr!  Who knows what in the next two.
14:26:21 <Cale> load gap and type H<tab><tab>
14:26:51 * boegel|home leaves
14:27:03 <boegel|home> checking out Lost ep 6 (or something like that)
14:27:06 <boegel|home> bye !
14:27:07 <xerox> haha Cale.
14:27:11 <xerox> Bye bye boegel|home
14:27:25 <xerox> marcot: I did.
14:29:01 <Cale> xerox: did you try that?
14:29:39 <xerox> What?
14:30:05 <marcot> xerox: for cairo bindings for haskell?
14:30:16 <xerox> marcot: y, and integration in Gtk2Hs
14:31:22 <dolmen> I have written a small function (showOp) at
14:31:24 <dolmen> @paste
14:31:25 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:31:36 <dolmen> I don't understand what 's wrong
14:31:58 <Cale> dolmen: you can't pattern match on functions...
14:32:17 <dolmen> can i use == ?
14:32:24 <Cale> there's no way of checking that the operator you pass is equal to + or -
14:32:28 <dolmen> for a if statement
14:32:34 <Cale> because it would have to try all inputs
14:32:39 <Cale> which is generally impossible
14:32:51 <Cale> (if there are infinitely many values in the type a)
14:32:57 <xerox> By using symbols :D
14:33:43 <franka> Actually it is because of primitives.
14:33:56 <franka> In the pure lambda-calculus, function equality is decidable.
14:34:07 <franka> Pure meaning no prims.
14:34:19 <Cale> for example, what if you pass the function \x y -> (x + 1) + (y - 2) + 1
14:34:25 <franka> Or extra rewrite rules for prims.
14:35:04 <dolmen> ok
14:35:07 <dolmen> thx
14:35:38 <Cale> dolmen: So you probably want some other datatype to represent the operators in order to be able to print them later.
14:36:26 <shapr> Cale: I installed all the gap accessories, that is a lot of stuff.
14:36:59 <Cale> :)
14:38:05 <earthy> the trouble with that whole dexia bank thingy is that it just reeks to hell and back of being a hoax
14:38:51 <dcoutts> xerox, did you hear back from google about the winings?
14:39:48 <dolmen> Cale: ok, I will use a char. I'm already writing an "evalOp" that do the opposite
14:40:14 <xerox> dcoutts being not said the opposite sesm to be enough
14:40:34 <xerox> an italian did not get paid instead :-\
14:40:47 <dcoutts> huh?
14:41:33 <Cale> dolmen: if you're trying to represent expressions in Haskell, a good datatype for it would look something like data Expr = Const Integer | Add Expr Expr | Multiply Expr Expr ...
14:42:49 <dolmen> Cale: I only have one kind of expression: Integer Operator Integer
14:43:29 <Cale> then perhaps  data Expr = Add Integer Integer | Multiply Integer Integer | ...
14:43:35 <dolmen> Cale, previously I was using: ((+), 3, 2) which is not useful If I want to print it
14:43:40 <Cale> right
14:44:25 <dolmen> Cale, I have not yet explored data types in the Haskell tutorial...
14:44:31 <marcot> What name is better for the gtk2hs package in debian? libghc6-gtk2-dev, or gtk2hs?
14:44:43 <marcot> or even libghc6-gtk2hs-dev?
14:44:46 <marcot> dcoutts: any idea?
14:45:19 <dolmen> Cale, one I have a data type such as what you suggested, what is the syntax to instantiate one ?
14:45:36 <Cale> Add 5 7
14:45:50 <Cale> and you can pattern match against the constructors:
14:45:56 <Cale> eval (Add 5 7) = 5 + 7
14:46:01 <Cale> eval (Add x y) = x + y
14:46:21 <Cale> (of course, you only need the second line :)
14:46:42 <Cale> eval (Multiply x y) = x * y
14:46:44 <Cale> etc.
14:47:34 <dolmen> @eval data Op = Add Int Int | Sub Int Int
14:47:36 <lambdabot>  parse error on input `data'
14:47:52 <Cale> you can't evaluate data declarations, as they're not expressions
14:47:59 <dolmen> ok
14:48:06 <shapr> hiya dash, long time no see
14:48:59 <dash> shapr: the fit has taken me once again
14:49:34 <shapr> You'll fit right in.
14:49:42 <dash> python is great when i think i don't know what i'm doing, which is most of the time
14:50:13 <dash> but occasionally i think i know exactly how my software ought to behave... and i start thinking about haskell again :)
14:50:28 <dash> this time it's accounting! has anyone done a general ledger in haskell?
14:50:39 <dcoutts> marcot, I can't help there. I'm not a debian expert. Ask Igloo.
14:51:09 <shapr> dash: The zipper might be good for transactions.
14:51:51 <dash> shapr: Hmmm
14:52:02 <marcot> Igloo: are you there?
14:52:17 <marcot> SyntaxNinja: are you there?
14:52:26 <dash> shapr: in which particulars?
14:53:05 <shapr> http://www.haskell.org/hawiki/TheZipper
14:54:04 <dash> shapr: ah, thought you were referring to http://okmij.org/ftp/Computation/Continuations.html#zipper-fs
14:54:31 <dash> shapr: anyway. how does that strike you as useful for transactions?
14:54:33 <shapr> I do like ZFS, it's true.
14:54:41 <shapr> In the same way that ZFS is good for transactions.
14:55:01 <dash> not sure i get it :)
14:55:15 <shapr> Well, read the wiki page, it explains it.
14:55:54 <dash> i see things about manipulating locations in a tree
14:56:16 <dash> i don't grasp the relevance immediately
14:56:52 <basti_> try it without, then :D
14:57:00 <dash> basti_: "it"?
14:57:01 <shapr> Yeah, maybe it's not helpful, I'm not sure.
14:57:16 <basti_> manipulating trees
14:57:36 <dash> basti_: i don't really know what tree have to do with general ledgers, is the main problem
14:58:24 <basti_> whats a ledger?
14:58:32 <shapr> accounting
14:59:18 <basti_> i don't know what trees have to do with accounting either.
14:59:33 <dash> a ledger is a data structure, composed of a set of transactions, a set of agents, and a set of assets
14:59:40 <basti_> ah
15:00:00 <franka> What constitutes an agent?
15:00:18 <dash> franka: well ok, 'agent' was the wrong word
15:00:18 <basti_> afaics the tree-ness doesnt interfere lots with the transactionality
15:00:37 <basti_> that would make the relation unimportant
15:00:38 <dash> 'account' is closer. the last implementation i was working with used the word "book"
15:00:53 <basti_> "transaction log"?
15:01:01 <dash> basti_: in a sense
15:01:15 <dash> it's not directly related to the database concept of transactions
15:01:46 <franka> I would implement it as a stream of transactions, if I understand correctly.
15:01:57 <dash> franka: mmm, ok
15:02:05 <dash> i am not sure what a stream entails in haskell
15:02:09 <marcot> Who do I put as the copyright holder for gtk2hs? Axel Simon?
15:02:15 <marcot> dcoutts: any ideas?
15:02:44 <franka> An existential type, with a hidden state, and functions which act on the state.
15:02:54 <dash> franka: ah, OK
15:03:03 <dcoutts> marcot, there are about 7 copyright holders
15:03:12 <dash> franka: i was thinking of things like java streams. ;)
15:03:26 <franka> Not too far off.
15:03:37 <franka> I was really thinking of the prototypical BankAccount OO example.
15:03:46 <dash> franka: heh heh
15:04:13 <dcoutts> marcot, you can attribute it to the "Gtk2Hs Team" if you don't want to list all of them (or perhaps the 3 major contributers)
15:04:30 <franka> Which is actually an infinite tree, and would support the zipper.
15:04:48 <marcot> dcoutts: I think I'll put them all.
15:04:55 <marcot> I've greped Copyright.
15:05:00 <dash> franka: Hmm
15:05:15 <dash> franka: so how do haskell people deal with disk storage
15:05:31 <Philippa> via the IO monad
15:05:33 <franka> The Zipper would let you cursor through parts of the ledger and change the part in the focus.  But I dunno if you need that functionality.
15:05:42 <dash> Philippa: hahaha
15:05:56 <dash> Philippa: i was looking for a more specific and useful answer :)
15:06:14 <Philippa> beyond that, it's pretty much as per everywhere else - you have the usual bunch of actions for opening files, reading, writing etc etc
15:06:26 <Igloo> marcot: Binary packages should be libghc6-cabalpackagename-dev
15:06:29 <dash> Philippa: mmm
15:06:36 <shapr> dash: You could use SerTH
15:06:39 <shapr> @were SerTH
15:06:40 <lambdabot> I know nothing about serth.
15:06:45 <shapr> @where SerTH
15:06:46 <lambdabot> I know nothing about serth.
15:06:49 <marcot> Igloo: is libghc6-gtk2-dev a good name? Or libghc6-gtk2hs-dev better?
15:06:53 <Igloo> marcot: gtk2hs is probably best for the source package name
15:06:57 <SamB> dash: System.IO?
15:07:04 <marcot> Igloo: yes, the source has this name.
15:07:06 <Igloo> marcot: What package name does it register with ghc?
15:07:15 <dcoutts> marcot, the first 7 people listed in the AUTHORS file are the main copyright holders
15:07:29 <dash> SamB: not exactly a helpful response
15:07:38 <Igloo> You want that (I think there are actually about 4 of them. I'd recommend separate binary packages, but if not you need to Provide: the others)
15:07:38 <marcot> Igloo: gtk
15:07:39 <shapr> @where+ SerTH http://www.cs.helsinki.fi/u/ekarttun/serth
15:07:40 <lambdabot> serth ~> http://www.cs.helsinki.fi/u/ekarttun/serth
15:07:50 <Igloo> libghc6-gtk-dev then
15:07:52 <SamB> also:
15:07:52 <SamB> @type readFile
15:07:54 <lambdabot> FilePath -> IO String
15:07:58 <SamB> @type writeFile
15:07:58 <marcot> Igloo: thanks.
15:07:59 <dash> SamB: if i were asking this question about python, the answer i'd be looking for is "axiom"
15:07:59 <lambdabot> FilePath -> String -> IO ()
15:08:18 <dcoutts> marcot, Igloo: it registers glib, gtk, mogul, and optinally glade, gconf, sourceview and mozembed
15:08:39 <marcot> dcoutts: ok, this is easy to see in debian.
15:08:40 <marcot> =D
15:09:12 <SamB> dash: a variety of ways! sometimes Read/Show are enough, sometimes we need more...
15:09:22 <dash> SamB: they aren't enough
15:09:40 <marcot> dcoutts: what description of the package are you using in gentoo?
15:10:07 <SamB> dash: what are you dealing with?
15:10:18 <franka> He's looking for something like this: http://moxn.net/~mesozoic/axiom-howto/
15:10:19 <shapr> dash: SerTH is roughly pickle.
15:10:25 <dash> shapr: Meh.
15:10:48 <dash> franka: 'cause that's what we wrote at work :)
15:11:35 <dcoutts> marcot, "GTK+-2.x bindings for Haskell"
15:11:40 <franka> OK.  I had not heard of Axiom, so I just did a websearch.
15:11:49 <dash> franka: yeah, it's very new
15:12:14 <dcoutts> marcot, or you can use the tag line from the website "A GUI Library for Haskell based on Gtk+"
15:13:05 <marcot> dcoutts: I was using the second one. What about the big description? Isn't there such a thing in gentoo?
15:13:51 <aFlag> gentoo sucks
15:14:12 <franka> Maybe consider HaskellDB?  I don't really know much about database programming.
15:14:29 <dash> yeah, that's what i figured
15:14:58 <aFlag> does haskelldb offers a api for all other databases to use or something like that?
15:15:18 <marcot> aFlag: I think hsql does.
15:15:24 <franka> http://www.haskell.org/libraries/#interfacingDataBases
15:15:48 <aFlag> shouldn't be too hard to interface with databases with haskell
15:15:49 <shapr> HaskellDB kicks butt.
15:16:02 <aFlag> haskelldb is a database itself?
15:16:21 <franka> No, it's kind of a DSL for DBs.
15:16:30 <dcoutts> marcot, no, there is no long description
15:16:49 <shapr> HaskellDB is a database unwrapper, it exposes the set theory behind databases.
15:16:53 <dcoutts> marcot, you can use the longer description from the web page: http://haskell.org/gtk2hs/overview/
15:18:22 <aFlag> oh, i see
15:18:25 <aFlag> good
15:19:21 <marcot> dcoutts: I'm using it, it's not that good cause it's in topics, but I think it's good enough.
15:19:58 <dolmen> Cale, I defined: data Operation = Add Int Int | Sub Int Int
15:20:20 <Cale> dolmen: okay
15:20:28 <dolmen> Cale, I want to define showOperation :: Opetation -> [Char]
15:20:48 * shapr yodels cheerfully
15:20:53 <Cale> showOperation (Add x y) = (show x) ++ "+" ++ (show y)
15:20:58 <Cale> something like that?
15:21:12 <dolmen> Cale, exactly
15:21:44 <aFlag> eheh
15:21:46 <dolmen> can I "factorize" the 2 definitions into one with a "case of" ?
15:21:56 <Cale> well, you could, if you wanted
15:22:06 <dolmen> how?
15:22:12 <aFlag> you can do it with guard
15:22:12 <aFlag> s
15:22:17 <aFlag> if i understanded it
15:22:27 <dolmen> @type guard
15:22:28 <lambdabot> bzzt
15:22:34 <dolmen> ??
15:22:35 <Cale> showOperation u = case u of Add x y -> ...; Sub x y -> ...
15:22:43 <aFlag> guards are those | things
15:22:49 <dolmen> ok
15:22:52 <Cale> you wouldn't use guards here
15:22:58 <aFlag> why not?
15:23:19 <Cale> well, unless you had functions to test whether one of the constructors applied
15:23:24 <Cale> and unwrappers
15:23:28 <franka> A guard is just a shorthand for an if-expression.
15:23:48 <aFlag> i thought it did pattern matching, though
15:23:50 <Cale> multiple declarations are shorthand for case expressions
15:24:32 <aFlag> yeah, ignore me ehhe
15:24:55 <aFlag> i don't know much haskell and i don't use it for a long time heh
15:24:55 <Cale> there are pattern guards, I suppose, but they're an extension, and you'd only be able to use them in a trivial way here
15:25:21 <aFlag> now i saw what i was thinking wrongly
15:25:27 <Cale> dolmen: If you want, you can make Operation an instance of Show
15:25:33 <Cale> instance Show Operation where
15:25:40 <Cale>    show (Add x y) = ...
15:26:21 <dolmen> cool ;)
15:28:46 <vina> hi all... does anybody here have time for a newbie question?
15:28:52 <Cale> sure
15:28:55 <franka> Hm, @pl doesn't handle curly braces?
15:29:13 <Cale> @pl does its own parsing, so it might not get everything
15:29:14 <lambdabot> (line 1, column 21):
15:29:14 <lambdabot> unexpected ","
15:29:14 <lambdabot> expecting variable, "(", operator or end of input
15:29:20 <Cale> heh
15:30:18 <shapr> vina: ask!
15:30:21 <Cale> vina: what's your question?
15:30:38 <Cale> (the "sure" was a reply to you)
15:30:46 <vina> Cale and shapr: When you have an algebraic user datatype, with disjoint constructors, you don't automagically have an == function?
15:31:17 <Cale> if all the parts can be tested for equality, then you can stick "deriving Eq" on the end
15:31:22 <vina> like data Test = A | B | C
15:31:24 <Cale> and it will make one
15:31:30 <Cale> but in general, you can't
15:31:57 <Cale> for instance,  data Foo a b = A a | B b | F (a -> b)
15:32:35 <Cale> even if the parameters can be tested for equality, the functions in the case of F can't be
15:33:42 <Cale> in your case, you can just do:
15:33:50 <Cale> data Test = A | B | C deriving Eq
15:34:12 <vina> Cale: thank
15:34:17 <Cale> and while we're at it, data Test = A | B | C deriving (Eq, Show)
15:34:41 <Cale> assuming that you don't care to write your own Show instance
15:35:09 <vina> Cale: how do the interpreter define the default operation in this case????
15:35:28 <vina> Cale: Is some kind of primitive?
15:35:44 <vina> Cale: or can it be done in plain haskell?
15:35:45 <Cale> That's described in the Haskell Report. For Show, it will print out something approximating the Haskell code you'd use to build the values.
15:36:14 <Cale> At present, you can't add your own classes to the deriving clause.
15:36:25 <vina> Cale: I see...
15:36:45 <Cale> (except in the case of newtype)
15:37:13 <vina> Cale: I think for it to work with user datatypes, it would involve some metaprogramming feature...
15:37:21 <Cale> yes
15:37:32 <Cale> there are some papers about various methods to do it
15:37:44 <Cale> you can get similar constructions using template Haskell
15:37:52 <Cale> (though not with that syntax)
15:38:03 <vina> Cale: template Haskell would be my next guess...
15:38:19 <dolmen> Cale, can I use a let ... in at the top level of an instance Show Operation declaration such as :
15:38:40 <vina> Cale: Thanks a lot!!!
15:40:03 <dolmen> instance Show Operation where let toto opChar opFunc a b = show a ++ opChar ++ show b ++ show (opFunc a b)
15:40:32 <dolmen> in show (Add ab) = toto a b "+" (+)
15:40:46 <dolmen> in show (Sub ab) = toto a b "-" (-)
15:42:12 <Cale> well, that let isn't valid syntax, no
15:43:04 <Cale> perhaps you would be better off using a case together with a where clause
15:43:12 <Cale> (or a let inside the definition of show)
15:46:03 <Cale> @paste
15:46:04 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:46:09 <Cale> oops
15:46:38 <Cale> refresh :)
15:46:57 <Cale> just rearranging your code slightly
15:47:50 <Cale> refresh again, that's perhaps cleaner than using all the ++'s
15:47:52 <dolmen> oh well, thank you
15:48:10 <Cale> that makes sense, right?
15:50:37 <dolmen> exactly what I want !!
15:50:48 <dolmen> @type join
15:50:49 <lambdabot> bzzt
15:51:02 <Lemmih> @type Monad.join
15:51:04 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:51:29 <Cale> really ought to be in the Prelude :)
15:52:05 <dolmen> I'm looking for a [[Char]] -> [Char], a bit like concat but that insert a string between each element
15:52:16 <franka> Hey, The Colbert Report is premiering on October 17th after the Daily Show.  I can't wait.
15:52:26 <Cale> @type List.intersperse
15:52:27 <lambdabot> forall a. a -> [a] -> [a]
15:53:00 <Cale> @eval List.intersperse " " ["Hello", "World"]
15:53:02 <lambdabot> ["Hello"," ","World"]
15:53:07 <Cale> @eval concat $ List.intersperse " " ["Hello", "World"]
15:53:09 <lambdabot> "Hello World"
15:53:15 <dolmen> ;)
15:53:16 <Cale> import List
15:53:27 <Lemmih> @eval unwords ["Hello", "World"]
15:53:29 <lambdabot> "Hello World"
15:53:49 <dolmen> better !
15:54:10 <Cale> yeah, if you just want spaces, unwords does the trick :)
15:54:15 <humasect> how long has everyone present been working with Haskell?
15:54:46 <Cale> hmm... 2, 2.5 years or so
15:54:55 <Cale> I think
15:54:58 <franka> Nine years or so.
15:55:10 <Lemmih> Two years in a couple of months.
15:55:32 <micket> 5 weeks
15:56:35 <humasect> cool
15:56:37 <shapr> four years
15:56:54 <dolmen> @type eval
15:56:55 <lambdabot> bzzt
15:56:59 <humasect> and Haskell 1.4 is just before '98? or 1.5?
15:57:11 <vina> 5 days :-P
15:57:15 <humasect> =D
15:57:23 <Pseudonym> Ten years, plus about three more of other languages like it before that.
15:57:30 <aFlag> no years :(
15:57:54 <Cale> dolmen: Haskell doesn't have eval, though there is a library which adds it, called hs-plugins.
15:57:58 <dolmen> humasect, started to read the Yet Another Haskell Tutorial 5 months ago. Stopped.
15:58:14 <dolmen> humasect, started again on saturday
15:58:22 <humasect> @type unsafeEval_
15:58:23 <lambdabot> bzzt
15:58:56 <dolmen> Cale, I just wanted to check if it was a reserved word
15:58:57 <Lemmih> @type System.Eval.eval
15:58:58 <lambdabot> forall a.
15:58:58 <lambdabot> (AltData.Typeable.Typeable a) =>
15:58:58 <lambdabot> String -> [System.Eval.Utils.Import] -> IO (Maybe a)
15:59:08 <humasect> ohh. when i started it was similar. stopped after just evaluating it, then came back to it for "good[ness]"
15:59:11 <Lor> This pretty much summarizes the point of my ms thesis :) "<dolmen> @type eval  <lambdabot> bzzt"
15:59:46 <humasect> i'm just over 1 month total haskell use
16:00:14 <dolmen> humasect, what language did you learn before ?
16:00:36 <humasect> everything else
16:00:56 <dolmen> COBOL ?
16:00:57 <Cale> If you change the question to "how long have you been employed writing Haskell for money", the numbers change a bit :) I'd be at 3 and a half months
16:01:02 <Lor> K, lambda-prolog and SNOBOL, that is?
16:01:14 <humasect> heh cale.
16:01:34 <humasect> mostly C/c++/objc/smalltalk/<misc langs like python>/scheme since early 90s
16:01:36 <Cale> and that was a while ago
16:01:51 <dolmen> Cale, good to know that some people are payed for writing Haskell code
16:01:55 <humasect> cale, oh it stopped?
16:02:04 <Cale> humasect: it was only for a summer
16:02:07 <dolmen> Cale, private company ?
16:02:08 <Lemmih> SyntaxNinja: how long have you been employed writing Haskell for money?
16:02:12 <aFlag> good to know some people are getting payed
16:02:20 <humasect> i was developing a website in WASH on contract for a month (unfinished, on break) if that counts
16:02:45 <dolmen> what is WASH?
16:03:05 <dolmen> Washington ?
16:03:11 <Cale> dolmen: I worked as a research assistant at a university. I wrote a pipeline scheduler and register allocator for PPC+Altivec.
16:03:46 <dolmen> I wrote one a long time ago in C for Alpha
16:03:47 <Cale> They're designing a high level language for signal processing, and I wrote part of the compiler.
16:03:53 <humasect> Websites A Stuff Haskell ?
16:04:10 <Cale> (that part)
16:04:11 <humasect> it's a CGI app library
16:04:18 <dolmen> url?
16:04:23 <humasect> @google WASH cgi
16:04:26 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
16:04:30 <humasect> that should be it
16:05:02 <dolmen> Web authoring System Shell
16:05:04 <humasect> ...then i got sidetracked and wanted to use HSP instead but i woudn't have permissions on client's the chosen host server
16:05:16 <humasect> WASS? =) sHell
16:06:55 <humasect> (in that month i was able to process other haskell uses into the bill.. somehow)
16:07:08 <dolmen> Web Authoring System Haskell
16:07:14 <dolmen> ;)
16:07:19 <humasect> =D
16:08:18 <dolmen> anyone using darcs here ?
16:08:24 <Lemmih> Yep.
16:08:27 <Cale> I've used it
16:08:57 <humasect> 9 and 10 years of haskell... how does it feel?
16:09:04 <dolmen> I'm beginning in Darcs as in Haskell ;)
16:09:07 <Cale> actually, I am using it for nymphaea -- have to prod xerox to work on it more so as to keep my own motivation up :)
16:10:00 <dolmen> I'm surprised to have only the patch name to address a patch
16:10:24 <dolmen> Isn't there any sequence number for each patch ?
16:10:32 <Cale> there is a sequence number
16:10:43 <Cale> I'm not sure whether it's exposed in the UI
16:11:45 <Cale> bbiab, dinner
16:11:56 <dolmen> "darcs changes" only show date, author and patch name
16:12:36 <shapr> patches are not in a set sequence.
16:13:44 <Pseudonym> Ten years of Haskell has made my other programming much better.
16:14:36 <Pseudonym> I can often write a version of some algorithm in Haskell followed by the same thing in C++ faster than I could if I started in C++.
16:14:47 <Pseudonym> (That's when you take debugging time into account.)
16:15:16 <dolmen> 30 hours of Caml 7 years ago has made my other programming much better. Learning Haskell now.
16:15:26 <Pseudonym> Definitely.
16:15:41 <franka> Haskell was what got me interested in doing PL research.
16:15:43 <Pseudonym> A decent Milner-esque type system does wonders for your productivity.
16:16:37 <franka> It taught me that programming can be approached mathematically rather than only artistically.
16:16:39 <dolmen> franka, too bad I didn't discover Haskell at University time...
16:17:28 <gzl> they offered a Haskell course here last year. lot of fun.
16:17:30 <franka> I discovered it after uni, when I was working at a company.  Then we went to do my Ph.D.
16:17:36 <franka> we=I
16:17:40 <dolmen> whenever I see C or Java, I'm asking : why do I have to write the type of this variable ? He knows what it is !
16:17:46 <dolmen> He = the compiler
16:18:10 <gzl> is it harder to program when you anthropomorphize your compiler?
16:18:24 <franka> Also Haskell has made me much more critical of other programming languages.
16:18:54 <Pseudonym> gzl: Blaming the compiler is easier if you anthropomorphise it.
16:19:02 <dolmen> well, I'm french, so using "He" instead of "it" is not so important from my point of view
16:19:06 <Pseudonym> And blaming your tools gives you psychological plausible deniability.
16:19:23 <gzl> I should try that out then
16:19:27 <franka> Even if you don't know any PLT, it can serve as a universal language.  To understand something in another language, you translate it to Haskell, see what it means there, and then translate back.
16:19:30 * Pseudonym invents a new kind of bracket for anthropomorphisms
16:19:48 <Pseudonym> I call them "strait jackets".
16:20:10 <Pseudonym> They fit in well with being behind barbed wire and going bananas.
16:20:24 <dolmen> franka, learning one more programming language make you always more critical of other PL
16:20:43 <shapr> Pseudonym: Hey, check out the FLM pre-release http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=TestMargin
16:20:49 <Pseudonym> Woohoo!
16:20:57 <shapr> Not ready yet, but getting closer.
16:21:08 <humasect> pseudonym, franka, well spoken
16:22:09 <franka> Have you seen the TurboGears demo?
16:22:35 <franka> shapr
16:23:17 <shapr> franka: The Python framework?
16:23:22 <franka> Yes.
16:23:31 <stepcut> shapr: sweet! (re, FLM)
16:23:39 <Pseudonym> Very nice.
16:23:48 <shapr> No, but I'll check it out.
16:24:19 <shapr> I do have a Haskell framework in mind to work on after FLM.
16:24:21 <franka> When you watch it, note how when they add CamelCase linking the word "SQLObject" gets linked.
16:24:27 * dolmen must solve how to view quicktimes under Ubuntu to view TurboGears demo
16:24:47 * Pseudonym tries adding a comment in FLM
16:24:49 <franka> I think it's because the way they do the DB interface using reflection pollutes the namespace.
16:24:57 <Pseudonym> Cool.  What else needs to be done?
16:25:09 <franka> Enumerating badness.
16:25:44 <shapr> Still needed is darcs integration, and picky UI details like telling imagemagick how big you want your images, not overwriting existing wiki pages, etc
16:25:49 <Pseudonym> Right.
16:26:20 <shapr> But the button really does download the pdf/ps, create wiki pages and images, and sew them together.
16:26:59 <Pseudonym> Excellent.
16:28:27 <franka> That's kinda neat.
16:29:13 <shapr> The goal is to be able to share margin notes.
16:33:16 <shapr> I do prefer enumerating goodness.
16:33:46 <Pseudonym> 1. Puppies.
16:33:49 <Pseudonym> 2. Candy.
16:33:55 <Pseudonym> 3. Warm hugs.
16:34:01 * Pseudonym thinks
16:34:06 <Pseudonym> 4. World peace.
16:34:12 <Pseudonym> This could take a while...
16:34:26 <stepcut> 5. ghc7
16:34:30 <Pseudonym> True!
16:40:49 <wagle> haskell without the warts
16:41:13 <Pseudonym> By "the warts", I assume you mean linear implicit arguments.
16:41:28 <Pseudonym> Or did you mean .hi-boot files?
16:42:18 <wagle> sdsdsdsall of them
16:42:28 * shapr removes another .hi-boot from his repo
16:42:46 <wagle> wirex
16:42:47 <wagle> wireless is flaking out..  byeee
16:43:10 <humasect> .ghci conflict with cabal
16:43:39 <shapr> hm, hack or sleep?
16:44:19 <Pseudonym> What do you have to do tomorrow?
16:44:23 <Pseudonym> And are you on a roll?
16:44:30 <humasect> i need to flesh out a design, but in text or documents isn't enough. haskell doesn't like type signatures without definition, either... i am taking the wrong approach?
16:44:47 <Philippa> you can fill in trivial definitions at first?
16:44:56 <Pseudonym> foo :: Complex -> (Type -> Signature) -> With -> IO Detail
16:44:57 <Philippa> foo :: ...; foo = undefined
16:44:57 <humasect> yeah.
16:44:58 <Pseudonym> foo = undefined
16:45:02 <Pseudonym> Right.
16:45:02 <humasect> ah
16:45:15 <Philippa> or better yet, error "foo has not been implemented yet"
16:45:18 <Pseudonym> Right.
16:45:30 <Pseudonym> In C++ that would be:
16:45:31 <humasect> for non-monadic as well?
16:45:44 <humasect> (like trace)
16:45:45 <Pseudonym> complex_type foo(more_complex arguments) { throw 0; }
16:45:49 <Pseudonym> I do that a lot. :-)
16:46:33 <Philippa> humasect: works fine for non-monadic code, error and undefined both evaluate to _|_ (ie serious big-time failure)
16:46:42 <Philippa> monads have fail
16:47:58 <Philippa> error also tends to print out the message you give it, but that's sort of a nicety
16:48:09 <Philippa> the program's still fallen over, it's just the RTS doing you a favour
16:48:23 <humasect> i have the overall concept and several implementation ideas for a large project in haskell for my free time. i can take it all at once, but unsure where to start. i have confidence in composing complicated programs with no previous programming language experience hindering me, but it's the design and evolution where i am lost.
16:48:35 <humasect> okay great
16:48:52 <Pseudonym> humasect: Your saving grace, in this case, is GHCi.
16:49:05 <Pseudonym> You can play with algorithms without having real driver code around it.
16:49:13 <humasect> that forms the root of developing on this project =) oh is ee.
16:49:40 <Pseudonym> So you can develop from the inside out.
16:49:56 <humasect> imperative; you kind of write an API along with an application of using it to form a program. functional; a little more opposite, starting from the end points
16:49:58 <Pseudonym> It's kind of like test-driven development, except that your tests can be as ad-hoc as you like in the early stages.
16:50:04 <humasect> ohhh
16:50:25 <humasect> "inside out", that sounds really well. i fell in love with TDD after smalltalk
16:50:36 <Pseudonym> I find that having a command-line interpreter admits all sorts of development methodologies that compile-only languages don't.
16:50:40 <Philippa> I tend to do a spike solution and then build on it inside-out
16:51:09 <Pseudonym> ad-hoc development is actually practical in Haskell.
16:51:15 <Philippa> that is, I get something very, very basic with bugger all actual functionality running (flippi started off as a hello world CGI, then a query despatcher)
16:51:24 <Philippa> definitely
16:51:37 <Philippa> being able to fire up any pure function and test it anytime with no required setup is great
16:51:50 <humasect> i am mentally aroused.
16:52:09 <Cale> It's really the datatypes which take all the design.
16:52:14 <Pseudonym> Lambdabot started life as two threads which just responded to PINGs.
16:52:24 <Pseudonym> The two threads are still here, I'm proud to say.
16:52:32 <humasect> i have caught myself designing datatypes, which i know is wrong.
16:52:39 <Pseudonym> Actually, that's NOT wrong.
16:52:42 <Cale> It's not wrong.
16:52:46 <Pseudonym> That's the RIGHT thing to do.
16:52:46 <Cale> You want to do that.
16:52:54 <shapr> in stereo...
16:53:03 <Pseudonym> Getting your datatypes right first focusses your thinking early.
16:53:08 <Philippa> nonono, it's wrong! Your punishment is to do it the "right" way... ;-)
16:53:14 <Cale> If you think/know you'll need to change them, write typeclasses around them.
16:53:16 <Pseudonym> It gets you set up with a data structure that you can really use.
16:53:36 <Philippa> it's doubly good when the datatypes effectively represent protocols
16:53:40 <franka> I don't think it's right.
16:53:41 <Pseudonym> Yes.,
16:53:51 <franka> It's a way to get started, though.
16:53:51 <Pseudonym> That was actually the first thing I did in lambdabot, too.
16:53:52 <Philippa> then you're starting to think in terms of WTF kinds of things you're going to have to deal with, straight off the bat
16:53:58 <Pseudonym> I wrote a data structure to represent IRC messages.
16:54:15 <Pseudonym> And then I wrote a monad transformer which dumped IRC messages down communication channels.
16:54:20 <Pseudonym> And then I wrote the two threads.
16:54:33 <humasect> but it is exactly how i would start on a C app.
16:54:52 <franka> When you start by designing the datatype, though, you get locked into the syntax rather than the semantics of what you're doing, though.
16:54:54 <Pseudonym> The difference with the C app is that you'd have less confidence that the data structure was usable.
16:55:20 <humasect> but now that i remember, there were often times i had to edit functions to change their parameters and types. maybe frequently
16:55:21 <Philippa> depends. You might decide to leave the datatype known-unstable
16:55:40 <Philippa> in which case you now have a clear idea what else is made unstable by that because you can follow the typechecker...
16:55:46 <franka> It's better to think in terms of combinator languages.  Think of the laws you need.  And then you can implement some of the combinators as constructors.
16:55:53 <Pseudonym> Actually, in many respects, I think that designing functional data structures is harder for imperative programmers coming to Haskell than writing functional algorithms.
16:56:03 <Philippa> yeah
16:56:12 <humasect> it is./
16:56:15 <humasect> *it is.
16:56:22 <Pseudonym> franka has a good point.  If your data structure has a nice algebra, you should definitely concentrate on that.
16:56:31 <Pseudonym> And don't be afraid to use abstraction at the micro-level.
16:56:46 <Pseudonym> Abstraction, in Haskell, is cheap.
16:56:50 <Pseudonym> So spend it freely.
16:56:58 <franka> The prettyprinting papers are a really nice example of what I'm talking about.
16:57:13 <Pseudonym> Also the Ralf Hinze paper on deleting from binary search trees.
16:57:16 <humasect> in the golden era of C i was using recursion and many many things that were "functional". finding haskell felt comfortable, it's the stuff "around" it now.
16:57:21 <Pseudonym> There is a real zen moment in that paper.
16:57:56 <franka> Pseudonym: What is the name of it?
16:58:08 <Pseudonym> @google "a fresh look at binary trees"
16:58:11 <lambdabot> No result found.
16:58:14 <Pseudonym> Hmm.
16:58:15 <Pseudonym> Not that, then.
16:58:30 <Pseudonym> @google "a fresh look at binary search trees"
16:58:32 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications.html
16:58:37 <humasect> now i think it is much more clear
16:58:37 <Pseudonym> That's it.
16:58:55 <franka> Ralf Hinze. Functional Pearl: A fresh look at binary search trees. Journal of Functional Programming, 12(6):601-607, November 2002.
16:59:06 <Cale> humasect: one of the things to be aware of is that the data structures that you use often shape the flow of your computation
16:59:24 <Cale> This is often expressed explicitly with instances of Monad :)
16:59:31 <Pseudonym> Oh, Dijkstra would be proud of that.
17:00:31 <humasect> i must have been afraid to write "micro" functions (the inside), where in C-etal, writing them would be bad for trying to "course" from the high level down to use those functions.
17:00:52 <humasect> does that make sense?
17:01:38 <Pseudonym> Right.
17:01:42 <Pseudonym> Yes, it does.
17:01:46 <humasect> i took a mental gander at some ambitions i started in haskell, and now i notice right away that they start high up there in "controllers" and stuff like that.
17:01:58 <Pseudonym> The problem is that you may end up writing more scaffold code than you need.
17:02:02 <franka> You are talking about top-down vs. bottom-up design?
17:02:15 <humasect> franka, i think so.
17:02:31 <humasect> i feel much relief so far
17:02:49 <Pseudonym> The nice thing about Haskell is that scaffold code is less necessary, and cheaper to write.
17:03:09 <Pseudonym> So writing some then throwing it away doesn't cost you much, and gains you understanding of the problem.
17:04:27 <franka> Yeah, that's what makes bottom-up programming feasible.
17:04:53 <humasect> ah yes. and i've never come across that term before. tiny tiny functions can show up and disappear sans-mourne
17:06:17 * franka is fiddling around with GarageBand.
17:06:38 <humasect> "whole-program composition, bottom-up, tdd, not writing what you don't need, etc"
17:07:11 <Philippa> heard the term "spike solution" before?
17:07:13 <humasect> my last 24 hours of preparation.
17:07:16 <humasect> i haven't
17:07:43 <Philippa> imagine driving a line straight through the pyramid that "top-down, bottom-up" is based on...
17:07:50 <Philippa> minimal solution, doesn't mess around, just does it
17:07:55 <Philippa> sod all scaffolding, but it runs
17:08:06 <Cale> Haskell is also a nice enough language that I can code reasonably effectively even while away from the machine. The code is usually short, so easy to remember :)
17:08:08 <humasect> vertically downward?
17:08:10 <Philippa> very useful things in Haskell, because you can refactor them like crazy
17:08:12 <Philippa> yep
17:08:24 <humasect> ooo nice image
17:08:41 <Cale> It's somewhat more like mathematics.
17:09:13 <Philippa> the term comes from the XP community btw
17:09:24 <Philippa> I just happened to find it fits something I do
17:09:43 <shapr> http://c2.com/cgi/wiki?SpikeSolution
17:09:51 <humasect> XP surely has to be more than picturing 2 coders on one keyboard. it's time to research on c2 wiki
17:09:56 <humasect> aha.
17:10:22 <shapr> http://c2.com/cgi/wiki?ExtremeProgrammingSummary
17:10:27 <shapr> from http://c2.com/cgi/wiki?ExtremeProgrammingRoadmap
17:10:35 <Pseudonym> The idea of XP, in a nutshell, is that anything which is good should be done a lot.
17:10:44 <Pseudonym> Testing is good, so write tests first.
17:10:58 <Pseudonym> Code reviews are good, so do it while actually programming.
17:11:12 <Pseudonym> Customer reviews are good, so get the customer to sit with your dev team.
17:11:15 <Pseudonym> That sort of thing.
17:11:24 <dons> moin
17:11:30 * shapr yawns
17:11:31 <Pseudonym> G'day.
17:11:32 <shapr> g'day dons
17:11:36 <humasect> i'm grateful to have found haskell, even if only for the channel. =)
17:11:36 <BlurredWe> whoo! I actually wrote something myself! that worked! (not that any of you care..but I'm happy)
17:11:47 <Cale> BlurredWe: what was it? :)
17:11:51 <shapr> BlurredWe: of course we care!
17:11:58 <humasect> pseud, is this why you were enumerating the good earlier?
17:12:06 <BlurredWe> just one line: divisors n = [x | x <- [1..n+1], n >= x, n `mod` x == 0]
17:12:10 <Cale> :)
17:12:34 <Pseudonym> No, shapr said that he likes enumerating goodness.
17:12:44 <mauke> why n+1?
17:12:54 <Cale> you can change the n + 1 to n and get rid of the test
17:12:56 <BlurredWe> mauke dunno, didn't know if it was inclusive :)
17:13:02 <Cale> ah
17:13:06 <mauke> @eval [1..5]
17:13:06 <Cale> @eval [1..5]
17:13:09 <Cale> heh
17:13:10 <mauke> haha
17:13:13 <lambdabot> [1,2,3,4,5]
17:13:14 <lambdabot> [1,2,3,4,5]
17:13:34 <BlurredWe> ok, so now: divisors n = [x | x <- [1..n],  n `mod` x == 0]
17:13:36 <BlurredWe> much cleaner
17:13:42 <humasect> thanks guys. i've got what feels like the confidence of a whole team now.
17:13:55 <shapr> I was enumerating because franka was enumerating.
17:14:01 <humasect> (for haskell =)
17:14:23 <mauke> @pl \n -> filter (\x -> n `mod` x == 0) [1 .. n]
17:14:25 <lambdabot> ap (filter . flip flip 0 . ((==) .) . mod) (enumFromTo 1)
17:14:30 <Cale> haha
17:14:51 <Cale> flip flip
17:14:53 <mauke> flip flip 0?
17:15:07 * shapr falls over asleep
17:15:29 <dons> yay, finally fully automated the map generation :}
17:15:56 <dons> mauke, Pseudonym, anyone: add your details http://www.haskell.org/hawiki/HaskellUserLocations :D
17:17:09 <Lemmih> dons: Cool.
17:20:24 <Pseudonym> Done.
17:21:54 <dons> you're on the map! :)
17:22:18 <Pseudonym> Woohoo.
17:22:55 <Pseudonym> We seem to be a little short of Africans.
17:23:05 <Pseudonym> And Russians.
17:23:30 <Pseudonym> Maybe our world domination plans should focus some attention on those regions.
17:24:01 <Pseudonym> I do appear to be the most Southern person so far.
17:24:13 <Pseudonym> We do get the odd New Zealander turn up in here, though.
17:26:08 <franka> I'm gone. Seeya, all.
17:29:24 <BlurredWe> cool, and from the divisor thing, I wrote a perfect number checker...I'm almost as advanced as ancient greece...
17:29:31 <dons> yah, Vivian McPhail is in Christchurch I think
17:29:56 * Pseudonym nods
17:30:00 <dons> there's a bit of a bias towards english speaking countries
17:30:07 <dons> oh, and europe
17:30:38 <Pseudonym> Given that the dominant language of the channel is English, I'm not shocked about that.
17:32:04 <dons> no. hmm. we do get some argentians every now and then also.
17:32:11 <dons> -tinians
17:32:18 <Pseudonym> Oh, that's true.
17:32:33 <dons> but yes, russia is a big empty space. which seems unlikely
17:33:38 <sethk> I've seen folks here from eastern european countries
17:33:55 <Pseudonym> Australia is a big empty space too.
17:34:00 <dons> very true
17:34:03 <Pseudonym> Admittedly it's a little smaller than Russia.
17:34:20 <Pseudonym> Though not as much as the Mercator projection would have you believe.
17:34:52 <dons> right. though all the other projections xplanet does look weird to me :)
17:35:00 <Pseudonym> :-)
17:37:27 * dolmen is registered on the map: http://www.haskell.org/hawiki/HaskellUserLocations
17:38:59 <dolmen> France is very empty too.
17:39:20 <dolmen> Probably due to the fact that O'Caml is born in France.
17:39:46 <humasect> =o
17:40:04 <humasect> types cannot be introduced into ghci? and code entered cannot be "retrieved", right?
17:40:13 <Cale> humasect: right
17:40:17 <humasect> ok
17:40:41 <Cale> you should keep two windows open, one with your source, and one with ghci. Save your file and type :re in ghci to reload
17:41:36 <humasect> that's what i've been doing so far. navigating namespaces i wonder if it can be simplified
17:41:55 <humasect> like an "able to see all :loaded code"
17:41:57 <humasect> mode.
17:42:02 <wagle> ghci does have a script history
17:42:18 <Cale> if your program imports libraries then they'll be seen by ghci
17:42:23 <humasect> :show bindings?
17:42:27 <Cale> also you can :m + Library
17:42:52 <humasect> cale, that's what i mean. it must be my initial confusion of working what i've already wrote.
17:43:19 * dolmen is going too sleep...
17:43:22 <dolmen> bye
17:43:37 <dolmen> and thank you very much Cale
17:44:25 * Speck continues installing packages on his slow-slow computer to get hIDE running
17:45:48 <micket> Cale: thanks, i've been retyping :l Filename.hs until now :P
17:45:57 <dons> Speck, add your details: http://www.haskell.org/hawiki/HaskellUserLocations :)
17:46:11 <Speck> How do I find my details?
17:46:14 <Speck> Baltimore, MD?
17:46:35 <Cale> Speck: use google maps
17:46:52 <Speck> isn't it google local now?
17:46:53 <Cale> The "Link to this page" link has the coordinates
17:46:58 <Cale> sure :)
17:48:07 <mauke> http://www.getty.edu/vow/TGNFullDisplay?find=baltimore&place=&nation=&prev_page=1&english=Y&subjectid=7013352
17:48:39 <Speck> spn=0.019016,0.039343
17:48:44 <sethk> I don't find a function to return the current directory.  Anyone know of a function like this?  I checked System.Directory - is there another module to check?
17:49:19 <Speck> is that what I'm supposed to be using?
17:49:24 <likens> Posix ?
17:49:37 <sethk> wait
17:49:45 <sethk> it is in System.Directory
17:49:52 <sethk> sorry I missed it somehow the first time I looked
17:50:05 <dons> Speck, you need the latitude and longitude
17:50:14 <sjanssen_> how do you use Google Maps to get lattitude and longitude?
17:50:31 <dons> center the map on your address, then click on 'link to this page'
17:50:32 <wagle> why do people write html manuals as a big pile of single pages?
17:50:37 <dons> the link thhe contains the lat and long.
17:50:49 <wagle> </rhetorical>
17:50:59 <dons> which you can type back into the search bar, and it will recenter you, and give you a marker, iirc
17:51:16 <dons> Oleg says:  How to zip folds
17:51:29 <wagle> zip . fold
17:51:30 <Speck> degrees minutes or decimal degrees?
17:51:44 <dons> nono. he means zip fold1 fold2
17:51:45 * Speck knows nothing about this kind of thing
17:51:47 <sethk> decimal
17:52:10 <wagle> zip [fold1 ..]
17:53:15 <dons> I think it's harder than that wagle ;)
17:53:29 <wagle> really?
17:54:09 <dons> "We show how to merge two folds into another fold `elementwise'."
17:54:25 <Speck> well I edited the page; the map is automated, right dons?
17:54:43 <dons> Speck, yes. every 3 hours. unless you ping me, in which case, on demand!
17:55:30 <dons> done.
17:55:44 <wagle> use the @dons interface?
17:55:45 <Speck> you should set it so the link to the image is a haskell cgi script
17:55:58 <Speck> whee I'm on the map!
17:56:10 <dons> Speck, yes. that's a good idea.
17:56:24 <Speck> caching would reduce the overhead
17:56:43 <dons> also, I really want to try out the 5km resolution maps (300M) nasa has. currently I'mm using 20km I think (32M).
17:57:17 <Speck> ooh, or toy with the google maps api, and make each person a bookmark
17:57:25 <dons> yes, though that's a bit scary.
17:57:29 <Speck> that could get kind of creepy though, zooming in on people's houses
17:57:35 <Speck> haha
17:57:39 <dons> the api's really easy though.
17:57:41 <Cale> You can easily just type the coordinates into a search
17:57:45 * sethk lowers his shades
17:58:08 <dons> right. it's not like the data isn't out there now. too late!
17:58:16 <Speck> haha
17:58:28 * sethk points bazooka at GPS satellites
17:59:06 <Cale> In fact, my coordinates are exact
17:59:13 <Cale> (at least wrt google maps)
18:00:32 <Speck> maybe I'll write a simple example cgi that consumes that information to make a google map
18:00:57 <dons> Speck, do you know the api? there's some nice examples out there
18:01:05 <Speck> I haven't looked at it yet
18:01:06 <sethk> There is a class, Fractional a, which starts       class Fractional a => Floating a where    and then has a bunch of functions including sin and asin.
18:01:08 <Speck> it would be a good excuse
18:01:13 <sethk> sin and asin have the signature a -> a
18:01:28 <dons> http://www.google.com/apis/maps/documentation/#The_Hello_World_of_Google_Maps
18:01:33 <sethk> does that mean that sin actually has the signature    Floating -> Floating    ?
18:01:42 <Speck> thanks
18:01:57 * Lemmih looks down at Cale's neighborhood.
18:02:14 <dons> also, xerox had a link to a the google SoC meetup site, which had another nice exapmle, with code
18:02:37 <dons> mine should be accurate now, and the lambdabot's is too :)
18:02:53 <wagle> would you like to play a game?
18:02:58 <dons> or is it?? mwhahahaha
18:04:07 <dons> I think in fact a binding to the google maps api would be of general utility
18:04:15 <sethk> in ghci, why does     acos 3.14159        print         NaN    ?
18:04:23 <dons> since writing javaScript directly sucks
18:04:27 <wagle> whoa..  i moved about 20 miles
18:04:48 <Speck> yeah... hmm
18:05:15 <sethk> does that mean argument out of range?
18:05:33 <Cale> sethk: acos has domain [-1,1]
18:05:53 <sethk> Cale, right, so does ghci printing NaN   mean argument out of range?
18:06:23 <Cale> yes
18:07:13 <dons> marcot! add your details: http://www.haskell.org/hawiki/HaskellUserLocations :D
18:07:49 <dons> we need to fill in your continent :)
18:08:48 <marcot> dons: there's no one from South America?
18:08:52 <marcot> )=
18:08:56 <Cale> only one so far
18:09:09 <dons> but I know there's many more than that
18:09:57 <marcot> dons: You can be sure of that.
18:10:02 <marcot> I know 3! =D
18:11:28 <dons> cool. I know there's a couple of guys from Argentina, but any others from Brasil?
18:12:36 <wagle> how'd my coords get corrupted?
18:12:58 <dons> hmm :/
18:13:08 <wagle> i entered something pretty close to 45.5391   -122.86655, but now its 45.4504    -122.669
18:13:22 <dons> is that an older version?
18:13:45 <sethk> hmm, that actually looks like someone converted from h:m:s to decimal
18:13:53 <sethk> the differences are about the right magnitude
18:14:00 <sethk> except of course that it wasn't h:m:s
18:14:09 <dons> sometimes I'm suspicious about the handling of conflicts by the wiki
18:14:22 <humasect> i realise that i am not good at all with designing datatypes in haskell.
18:14:26 <wagle> i was off by about 20 miles
18:14:29 <dons> someone might have had a conflict, but picked the wrong version of your entry
18:14:58 <wagle> noone else is that close..  the seattle people are 100-150 miles away
18:15:05 <humasect> the ratio of thought and work should probably be the same as datatypes to functions.
18:15:17 <wagle> i only entered it once (iirc)
18:15:21 <sethk> dons, for that to happen, someone at some point would have had to enter the wrong coordinates
18:15:31 <sethk> dons, it can't pick the wrong version unless it has at least two versions
18:15:41 <dons> yes, I'm wondering if wagle himself had an older, less accurate version?
18:15:56 <dons> which has been common
18:16:02 <wagle> not that i remember..  butg it was a year ago or so
18:16:09 <dons> oh, well then it is a mystery
18:16:21 <dons> marcot, have you seen hIDE? http://www.haskell.org/hawiki/hIDE
18:16:33 <dons> the successor to Yi, in a way.
18:16:45 <marcot> dons: not yet.
18:16:58 <marcot> dons: no more than 3 from Brasil... =(
18:17:34 <dons> oh, but isn't there a functional programming research group (or 2) in Brasil?
18:17:37 <dons> maybe they don't use Haskell
18:19:18 <marcot> dons: sorry, there're a lot of haskell programmers in brasil.
18:19:21 <marcot> I just remembered.
18:19:36 <marcot> There're some universities that has a 6 month Haskell course.
18:19:45 <dons> ah, cool :D
18:20:16 <dons> I suspected as much. I have read several Haskell-related papers from Brasillians, and there's a Sth. American functional programming conference
18:20:17 <Cale> we just need to suck more haskell programmers into the IRC channel so that their locations can be noted :)
18:20:24 <dons> hehe
18:20:33 <dons> blackdog, new maps! http://www.haskell.org/hawiki/HaskellUserLocations
18:21:06 <dons> Cale, I suggest we start spamming Nigeria, and the rest of Africa for FP converts
18:21:47 <Cale> heh
18:26:41 <wagle> spamming nigeria?  "HELLO!  I AM HASKELL CURRY, OFFICER OF THE PROGRAMMING LANGUAGE, AND IF YOU GIVE US YOUR COMPUTER ACCOUNT NUMBER, WE CAN TRANSACT SOME VERY PROFITABLE PROGRAMMING...."
18:27:11 <dons> hehehe!
18:29:42 <marcot> dons: I added my name there.
18:30:55 <dons> updated :)
18:32:08 <dons> wagle, I recall an amusing April 1 msg to haskell@ along these lines, from a couple of years ago
18:32:27 <marcot> dons: nice!
18:32:46 <marcot>  Distributed development using darcs (again like lambdabot)
18:32:51 <marcot> I didn't get this.
18:33:42 <dons> oh, that just means we'll have lots of separate repositories that individual developers work on, which we merge to some central place that users can download from
18:34:00 <dons> i.e. no centralised cvs machine, that you need an account on
18:34:08 <marcot> dons: ok.
18:34:16 <marcot> dons: Is it intended to be only for haskell?
18:34:43 <dons> no. already it handles html, for example.
18:38:40 <wagle> hmm..  the avian seems to not have been scanned in
18:39:37 <humasect> what is the center of that map? where most of the locations are
18:40:36 <araujo> Hello!
18:40:47 <araujo> I am not alone anymore in the sub-continent!
18:42:26 <dons> :)
18:42:49 <araujo> dons!
18:42:56 <marcot> araujo: =D
18:43:02 <dons> still, that's only about a 1/4 of the #haskell people
18:43:22 <dons> less than that even
18:43:47 <araujo> marcot, hey!
18:44:37 <araujo> dons, fear us!!
18:44:54 <dons> oh no!!
18:45:01 <dons> @seen xinming_Beijing
18:45:02 <araujo> marcot, How haskell goes down there?
18:45:02 <lambdabot> xinming_Beijing is in #haskell. I don't know when xinming_Beijing
18:45:02 <lambdabot> last spoke.
18:45:28 <dons> xinming_Beijing, you should add your location to the map :) http://www.haskell.org/hawiki/HaskellUserLocations
18:45:33 <wagle> dons: time to break out south america into its own image
18:45:38 <dons> yep
18:46:10 <dons> also, east asia
18:48:05 <marcot> araujo: as I was saying some time ago, it's becoming teached at universities.
18:48:12 <humasect> i want to make a page on the wiki for this project to include other minds on it, as well as linking to others and related projects.
18:48:13 <marcot> dons: nice this hIDE thing.
18:49:08 <dons> yes. Lemmih and dcoutts have done a lot of good work on hIDE. I still need to do more to get Yi nicely integrated. it's a bit rough at the moment.
18:49:25 <araujo> marcot, nice,
18:49:48 <araujo> Ive also heard some univ. in the country using Haskell
18:50:24 <araujo> dons, what's the difference between Yi , hIDE?
18:51:31 <dons> yi is a plugin to hIDE. hIDE does a lot more than just text editing. for example, file browsing and html rendering.
18:51:41 <dons> hIDE is a proper IDE, whereas Yi is a text editor.
18:51:47 <araujo> Ah ok.
18:52:09 <dons> so hIDE reuses Yi as its internal text  editor, which is good, I think
18:52:27 <araujo> That's good indeed
18:54:06 * araujo can't remenber when he installed the python mode for emacs
18:58:06 <sethk> what's the difference between htell and gGetPosn   ?
18:59:40 <araujo> regcomp "*.*" regExtended
18:59:50 <wagle> araujo: my xemacs came with haskell mode "right out of the box"
18:59:50 <araujo> Can i do something like that for computing a regular expression?
19:00:10 <araujo> wagle, not mine, though i just need to emerge haskell-mode
19:00:18 <marcot> dons: I'll take a look at them sometime... after packaging gtk2hs
19:00:24 <araujo> never had problem, just sometimes some where indenting brokes
19:01:06 <sethk> araujo, that would be any string of at least one character
19:01:12 <sethk> araujo, is that what you mean?
19:01:30 <sethk> anybody know the answer to  what's the difference between htell and getGetPosn   ?
19:02:01 <araujo> sethk, i want to match things like: foo.txt , foo.ps etc etc
19:02:09 <wagle> @type htell
19:02:10 <lambdabot> bzzt
19:02:18 <wagle> @index htell
19:02:19 <sethk> araujo, you mean  *\.*   then
19:02:19 <lambdabot> bzzt
19:02:26 <sethk> I know the types
19:02:31 <wagle> @index hTell
19:02:32 <lambdabot> System.IO
19:02:41 <wagle> i dont know the types
19:02:57 <wagle> @index System.IO.hTell
19:02:58 <lambdabot> bzzt
19:03:15 <araujo> Prelude Text.Regex.Posix> regcomp "*\.*" regExtended
19:03:15 <araujo> <interactive>:1:12: lexical error in string/character literal
19:03:34 <araujo> sethk, i keep getting that error with all the combinations i try,
19:03:39 <sethk> wagle, they return a different type but if you trace it you'll find it is the same type
19:03:43 * araujo must be doing something wrong
19:03:51 <sethk> araujo, might need \\
19:04:05 <sethk> araujo, because the string processing will remove one
19:04:24 <humasect> another thing. it's probably true that if you don't work bottom-up, you'll end up having to write anything before it is useable.
19:04:28 <sethk> hGetPosn returns a data type which is specific to file positions
19:04:39 <sethk> but I still don't see why there are separate functions
19:04:55 <sethk> humasect, I always end up having to write something
19:05:00 <araujo> *** Exception: Text.Regex.Posix.regcomp: error in pattern
19:05:04 <sethk> humasect, but I doubt that's what you mean to say
19:05:05 <araujo> With \\
19:05:06 <mauke> glob2regex ('?' : p) = '.' : glob2regex p; glob2regex ('*' : p) = ".*" ++ glob2regex p; glob2regex (c : p) = c : glob2regex p; glob2regex [] = []
19:05:09 <sethk> araujo, hmm.
19:05:14 <wagle> @index getGetPosn
19:05:16 <lambdabot> bzzt
19:05:28 <humasect> sethk: about test-first working from the inside out
19:05:28 <sethk> mauke, he wants a literal dot
19:05:38 <araujo> yeah
19:05:41 <sethk> humasect, I know, but what you typed is not what you wanted to say
19:05:41 <mauke> ah, forget the escaping part
19:05:47 <araujo> Thansk mauke anyway
19:05:52 <mauke> anyway, it's ".*\\..*"
19:06:01 <sethk> right
19:06:03 <mauke> possibly with ^ and $ around it
19:06:10 <sethk> the old shell regex vs real regex trick
19:06:25 <sethk> * in the shell is always .* in a regex
19:06:29 <sethk> forgot about that
19:06:46 <wagle> how is getGetPosn spelled?
19:06:49 <sethk> humasect, you meant rewrite but you typed write
19:06:56 <sethk> hGetPosn
19:06:56 <araujo> That made it
19:07:02 <araujo> Thanks mauke sethk
19:07:13 <sethk> type IO GHC.Handle.HandlePosn
19:07:25 <sethk> that is, that's the return type
19:07:31 <sethk> takes a handle argument, of course
19:07:43 <sethk> hTell is IO Integer
19:07:47 <araujo> mauke, Don't you know some good regex tutorial in Haskell?
19:07:50 <sethk> I think I see my own answer
19:08:03 <mauke> araujo: no, only perl
19:08:06 <sethk> GHC.Handle.HandlePosn is a binary form specific to an environment
19:08:19 <sethk> IO Integer is the usual Haskell unbounded integer type
19:08:24 <marcot> Why don't you use a wiki written in haskell?
19:08:31 <sethk> so hGetPosn doesn't need to convert
19:08:39 <humasect> sethk: i meant to say... if you start to design even a type that way (top-down) you will have to fill in everything below it before you realise it. often without finishing the type, leading to probably a big mess
19:08:54 <sethk> humasect, yes, I know, I was just telling you that you mistyped
19:09:32 <sethk> humasect, and, I always plan to write something twice, at least, a prototype effort of at the very least a sketch of functionality
19:09:55 <sethk> humasect, so I agree with you, it is foolish to try to get it right in one pass
19:10:02 <humasect> okay. but i meant write. needing to put in much more scaffolding than needed,
19:10:30 <sethk> humasect, no, you didn't.  You said that you will have to write it, when you meant to say that you would have to rewrite it
19:10:39 <sethk> humasect, you said that no matter what you have to write it onc
19:10:40 <sethk> once
19:10:47 <wagle> Prelude System.IO> hTell stdin >>= (putStrLn . show)
19:10:47 <humasect> okay. i still hope that wouldn't need to be true. i wrote most things later on in my C life that were 1-pass
19:10:47 <wagle> 1435925
19:10:47 <wagle> Prelude System.IO> hGetPosn stdin >>= (putStrLn . show)
19:10:47 <wagle> {handle: <stdin>} at position 1436125
19:10:48 <sethk> humasect, but you meant no matter what you have to write it twice
19:11:05 <marcot> And the haskell web server!
19:11:06 <marcot> =DF
19:11:19 <sethk> wagle, I think I know why there are two
19:11:27 <sethk> wagle, hGetPosn is more efficient
19:11:29 <humasect> sethk: well.. like building a roof before the floors. you need some floor to build the roof... wah
19:11:34 <sethk> wagle, hTell converts to Integer
19:11:55 <wagle> i think hTell is the raw interface to the underlying syscall
19:11:59 <sethk> wagle, so if you use Integer positions you are going to have to convert for a seek, and also to convert any time you return
19:12:05 <sethk> wagle, no, I think the other way around
19:12:21 <sethk> because hTell is IO Integer
19:12:32 <sethk> and hGetPosn is IO GHC.Handle.HandlePosn
19:12:38 <wagle> the raw syscall returns an integer
19:13:02 <sethk> wagle, a Haskell unbounded integer?  the system call returns a 32 bit integer
19:13:17 <wagle> 64 bit
19:13:23 <sethk> wagle, either way, not Integer
19:13:33 <sethk> wagle, whether it is 32 or 64 is obviously implementation dependent
19:13:41 <sethk> wagle, at least at the o/s call level
19:13:42 <wagle> does haskell have a 64 bit int?
19:13:51 <sethk> wagle, I think so, yes
19:14:37 <wagle> called what?
19:14:38 <wagle> Prelude System.IO> 3746374623 :: Int
19:14:38 <wagle> -548592673
19:14:41 <araujo> marcot, it is well explained in the wiki
19:14:53 <araujo> The Haskell wiki still needs some work.
19:15:07 <araujo> Meanwhile we use a pythn wiki
19:15:11 <araujo> python*
19:15:25 <sethk> wagle, Int by default is 32 bit, but there is a 64 bit also
19:15:56 <humasect> how well does GHCi handle threading? may i :reload code, stuff that into an MVar, which the thread processes as IO () once per yield?
19:16:19 <wagle> but Int isnt 64 bit..  hence it has to use Integer
19:16:21 <Cale> wagle: why not use Integer?
19:16:37 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Int.html
19:16:46 <Cale> there's a type Int64 that gets defined there
19:17:04 <sethk> wagle, no.  that's no more valid than saying, Char isn't 64 bit, hence it has to use Integer
19:17:11 <wagle> hahaha..  i tried Int64, but not hard enough
19:17:14 <sethk> wagle, it is not true that the choices are Int and Integer
19:17:22 <sethk> wagle, :)
19:17:34 <wagle> when was it written?
19:17:40 <sethk> wagle, but the point is gGetPosn returns the position in the native format
19:18:06 <wagle> the native format is a 64 bit unsigned int
19:18:16 <Cale> humasect: I'm not sure what you mean
19:18:23 <sethk> wagle, on at least one system the native format is 64 bit unsigned int
19:18:34 <sethk> wagle, it is _not_ true that on all systems the native format is 64 bit unsigned int
19:18:59 <wagle> ok, you are a moving target
19:19:05 <Cale> Int means "something with range at least [-2^29 .. 2^29 - 1]"
19:19:26 <sethk> wagle, on current machines 32 bit is much more common
19:19:29 <Cale> It's usually a machine integer
19:19:40 <sethk> Cale, right, which is what hGetPosn returns
19:19:48 <Cale> hm?
19:19:50 <humasect> Cale: while a thread is forkIO'd from the repl, and it is calling an IO () from an MVar while it loops with yield. i think it will work if i can reload code in the replthen  putMVar. trying it now
19:19:57 <Cale> minBound and maxBound give the bounds
19:20:00 <sethk> Cale, hGetPosn returns the file position in the native format
19:20:12 <Cale> humasect: try it :)
19:20:17 <humasect> =)
19:20:32 <wagle> except on those system where it does not return it in the native format
19:20:33 <sethk> Cale, which is GHC.Handle.HandlePosn
19:20:40 <sethk> wagle, no, there are no such systems
19:20:52 <sethk> wagle, you seem to be missing the point, unless you are joking
19:21:16 <sethk> GHC.Handle.HandlePosn is the native format on whatever machine you are running on
19:21:21 <Cale> Well, it returns a HandlePosn, but its implementation is not exposed
19:21:23 <sethk> which means it is different, on different machines
19:21:31 <sethk> Cale, that doesn't matter
19:21:35 <Cale> so I'll assume that the implementation of GHC does something sane
19:21:45 <sethk> Cale, the point is that using hGetPosn and hSetPosn there aren't conversions to/from Integer
19:21:47 <Cale> It could e a string
19:21:52 <Cale> be*
19:21:57 <Cale> heh
19:22:10 <Cale> It probably isn't, but it could be :)
19:22:15 <sethk> Cale, well, that's the drawback of looking at things from an academic perspective.  You say something that tends to have you make the wrong decision
19:22:26 <sethk> Cale, if in fact I believed that it could be a string, then I shouldn't use it
19:22:30 <wagle>      long
19:22:30 <wagle>      ftell(FILE *stream);
19:22:31 <Cale> Well, what decision are you going to make?
19:22:49 <sethk> Cale, I'm going to use hGetPosn instead of hTell to avoid converting from the native format to Integer
19:22:56 <sethk> Cale, and converting back on a seek
19:23:15 <Cale> Sounds like you're optimising too early -- is the performance of that code a problem?
19:23:44 <sethk> Cale, I don't know, but the whole reason they put GHC.Handle.HandlePosn in is to allow you to avoid the conversions
19:23:56 <sethk> Cale, and since it is guaranteed to be available, not using it is clearly the wrong decision
19:24:06 <sethk> Cale, you either gain a little performance that you may not care about
19:24:12 <sethk> or you gain a little performance that you do care about
19:24:18 <Cale> @index hTell
19:24:19 <lambdabot> System.IO
19:24:22 <sethk> so whether or not you care doesn't matter
19:24:44 <Cale> ah, yeah
19:24:56 <araujo> mauke, still figuring out the regex, what if i want to mach ony *.foo ?
19:24:59 <Cale> hTell is only in the new System.IO anyway
19:25:13 <Cale> (It's not H98)
19:25:24 <wagle> "{handle: <stdin>} at position 1436125" is not a native format
19:25:26 <mauke> araujo: * becomes .* and . becomes \.
19:25:27 <araujo> 7me thought he knew regexp because of shell
19:25:36 <Cale> not that that usually stops me, but it's probably safer to use hGetPosn I agree
19:25:39 <mauke> and because of string syntax you have to turn \ into \\
19:25:39 * araujo thought he knew regexp because of shell
19:25:40 <sethk> wagle, no, that's a printed string
19:25:58 <araujo> mauke, oh, i see
19:26:03 <araujo> Thanks
19:26:04 <sethk> wagle, you have no way of knowing whether the string was created using the native format
19:26:06 <sethk> wagle, or not
19:26:35 <wagle> huh?
19:27:21 <wagle> thats how it printed.  the thing it printed was not a native format int64
19:27:23 <araujo> mauke, worked now!
19:27:30 <sethk> wagle, you cannot know that.
19:27:33 <sethk> wagle, it's just a number
19:27:37 <Cale> wagle: the position number was -- you're seeing an instance of Show
19:27:46 <sethk> wagle, it would print identically regardless of the internal format
19:27:51 <Cale> right
19:28:23 <wagle> how was "{handle: <stdin>}" encoded in the native format?
19:28:34 * araujo feels enlightened
19:28:49 <Cale> it's a HandlePosn record
19:28:54 <sethk> wagle, that part of the string is irrelevant, it has nothing whatsoever to do with the format of the file size/position
19:29:02 <Cale> data HandlePosn = HandlePosn Handle GHC.Handle.HandlePosition
19:29:09 <wagle> a HandlePosn record is a native format?
19:29:12 <Cale> no
19:29:15 <sethk> sure it is
19:29:17 <wagle> bingo
19:29:19 <sethk> look at the code
19:29:20 <sethk> I did
19:29:24 <sethk> wagle, not bingo, wrong
19:29:31 <sethk> HandlePosn absolutely is a native format
19:29:40 <sethk> that's its reason for existance
19:29:48 <Cale> sethk: I'm pretty sure that my processor doesn't have native support for tagged algebraic data structures :)
19:29:48 <wagle> the sky is pink
19:29:52 <wagle> war is peace
19:29:56 <wagle> black is white
19:30:22 <sethk> Cale, those are constructors.  you know they aren't actually stored, they are transformed away by the compiler
19:30:29 <Cale> no, they're stored
19:30:34 <mauke> perl is haskell
19:30:39 <Cale> If it was a newtype, it'd have gone away
19:30:59 <sethk> Cale, it goes away much earlier if it is a newtype
19:31:01 <Cale> but the data constructor will produce a record with pointers to closures.
19:31:10 <sethk> Cale, or, more correctly, it is guaranteed to go away if it is a newtype
19:31:11 <Cale> and a tag number
19:31:25 <sethk> Cale, so what?  The point is that the closure contains the file position in native format
19:31:33 <Cale> well, it may
19:31:34 <sethk> Cale, that's why the type was created in the first place
19:31:37 <Cale> no
19:31:44 <sethk> yes
19:31:56 <Cale> the type was created so that you could have an abstract representation of a position in some handle
19:32:07 <sethk> Cale, why do you think that?
19:32:10 <Cale> It packages the handle together with a location
19:32:20 <sethk> yes, ok, that's true
19:32:27 <Cale> which is nice and convenient
19:32:31 <sethk> but my point about the native representation of the position is still correct
19:32:53 <Cale> the HandlePosition type does abstract that
19:32:53 <sethk> and what I said was that GHC.Handle.HandlePosition
19:33:00 <sethk> is the native format, not the entire data thing
19:33:03 <Cale> ah, okay
19:33:04 <Cale> yeah
19:33:08 <Cale> that's probably true
19:33:16 <Cale> at least, it's something which is guaranteed to work
19:33:20 <marcot> Good night all.
19:33:36 <Cale> if your platform needs 2-dimensional handle pointers, it will still work
19:33:40 <sethk> Cale, yes, but so is the return value of hTell.  However they didn't store the handle with Integer here
19:33:54 <sethk> Cale, yes, but in fact the platforms we run on do not need 2-dimensional handle pointers
19:34:24 <Cale> sure, but it's nice not to have to care
19:34:43 <sethk> now I have to figure out how this thing does it's error processing.  That's combining the IO monad with the error monad
19:34:56 <sethk> so now I get to see if I really do understand monads better this week than last week.  :)
19:35:20 <Cale> reading code or writing it?
19:35:51 <sethk> writing it
19:36:11 <sethk> specifically I'm writing code to open a file if it exists, otherwise create it
19:36:46 <sethk> there is an error (IO Error instance, I think is the terminology) for file does not exist
19:36:57 <sethk> isDoesNotExistError
19:37:06 <sethk> although there might be better ways of handling it than using that
19:37:28 <sethk> IOError, not IO Error
19:41:23 * wagle is looking at a haskell implementation where
19:41:24 <wagle> hGetPosn :: Handle -> IO HandlePosn
19:41:24 <wagle> hGetPosn handle = do
19:41:24 <wagle>     posn <- hTell handle
19:41:24 <wagle>     return (HandlePosn handle posn)
19:41:50 <wagle> i also looked at once where the conversion went the other way, like sethk said
19:42:33 <sethk> but the type is not Handle Integer
19:43:36 <sethk> it's GHC.IOBase.Handle GHC.Handle.HandlePosition
19:43:47 <wagle> hTell :: Handle -> IO Integer
19:43:47 <wagle> hTell handle =
19:43:47 <wagle>     wantSeekableHandle "hGetPosn" handle $ \ handle_ -> do
19:43:49 <sethk> and they don't appear to be synonyms
19:43:50 <wagle> ...
19:44:33 <sethk> I'll look through it again, but it doesn't appear to me that GHC.Handle.HandlePosition resolves to Integer
19:45:04 <wagle> this isnt the haskell implementation you are looking at..  neither is definitive
19:45:12 <wagle> its implementation dependent
19:45:21 <sethk> oh, ok
19:45:26 <sethk> that's certainly true
19:46:01 <sethk> I'm saying that the implementation chosen is that the position in the abstract type uses the internal representation that is the same as the native format of the file position
19:46:24 <humasect> ahh now i remember why i severely dislike the OpenGL binding.
19:46:28 <wagle>       posn <- fromIntegral `liftM`
19:46:28 <wagle>                 throwErrnoIfMinus1Retry "hGetPosn"
19:46:28 <wagle>                    (c_lseek fd 0 sEEK_CUR)
19:46:57 <wagle> c_lseek is pretty close to the native syscall
19:47:02 <sethk> yes, precisely
19:47:21 <wagle> the native syscall returns an int64
19:47:31 <wagle> and nothing else
19:47:36 <sethk> depends whether you are on a 32 bit or a 64 bit machine
19:48:02 <wagle> no, it depends on whether your file system supports 32 or 64 bit seeks
19:48:07 <sethk> same thing
19:48:16 <sethk> in fact
19:48:32 <sethk> it just happens to be true that 32 bit machines support 32 bit seek, and 64 bit machines support 64 bit seek
19:48:40 <sethk> which you have to admit is rather logical
19:48:47 <wagle> no its not.  my 32 bit machine has a file system with 64 bit seeks, and a file system with 32 bit seeks on it
19:49:05 <sethk> wagle, that's unrelated to the syscall level seek
19:49:45 <wagle> 32 bits is about 2 gigs..  i have files bigger than that on my 32 bit machine
19:50:01 <sethk> wagle, they are aggregated, then
19:50:06 <sethk> wagle, by the file system
19:50:13 <wagle> aggregated?
19:50:21 <sethk> but I didn't say you can't build a file system that looks like 64 bits on a 32 bit machine
19:50:32 <sethk> wagle, aggregated.  That means comprised of smaller pieces
19:50:59 <sethk> although of course what the o/s provides at the syscall level is arbitrary
19:51:01 <wagle> not in any different way than files of length 40000
19:51:54 <sethk> when I've written at the device driver level the seek size has always been the same as the native machine word size
19:52:04 <sethk> although I agree that's not a requirement
19:52:14 <sethk> but it is what usually happens
19:53:32 <wagle> i cant get a dvd image (4 gigs or so) on a solaris machine, but i can on a linux machine
19:53:43 <sethk> wagle, yes, that's true
19:53:53 <sethk> wagle, because of the internal representations of the file system
19:54:22 <sethk> wagle, but down close to the hardware, the size of a seek is the same as the size of the machines word
19:55:23 <wagle> the disk does not care what the size of the machines word is
19:55:48 <sethk> wagle, no, that's true.  However, things work a lot better if they are the same
19:55:50 <wagle> the layout of data on the disk does not care either
19:56:08 <sethk> wagle, that's true also, because the seek size is built into the hardware
19:56:21 <sethk> but you can see that if they match, things go a lot faster
19:56:33 <sethk> but we don't really disagree, we are just talking about different o/s levels
19:56:41 <wagle> i can use the same disk on a 16 bit machine, a 24 bit machine, a 32 bit machine, a 60 bit machine, a 64 bit machine, etc etc
19:57:11 <sethk> wagle, yes, that's true.  And it will take twice as many machine cycles to transfer the file position on a 16 bit machine, compared to a 32
19:57:27 <sethk> wagle, so there are advantages (in terms of efficiency) when they match
19:57:42 <sethk> but it's true, the disk doesn't care.  It doesn't care how fast or slow things are at the o/s level
19:58:33 <sethk> is the normal thing to run, say, IO.openBinaryFile with IOError::try?
19:58:47 <sethk> to catch the isDoesNotExistErrorType  error?
19:58:55 <wagle> the seek position doesnt get sent directly to the disk..  its a sort of index into a data structure
19:59:16 <sethk> wagle, that's a decision made by the file system designer.  In your Solaris example, they are in fact the same
19:59:24 <sethk> wagle, in your linux example, they happen to be different
19:59:31 <sethk> wagle, for the same hardware
19:59:37 <sethk> so yes, you are correct at one level
19:59:52 <sethk> but the performance is better when they happen to match
19:59:56 <sethk> is all I'm saying
19:59:57 <wagle> umm.. solaris does unix file systems
20:00:08 <sethk> wagle, solaris does several different types of file systems
20:00:12 <sethk> but so what?
20:00:25 <sethk> it really doesn't matter to what I was saying and/or asking.
20:00:30 <wagle> this place is closing, gotta go
20:00:43 <sethk> wagle, ok, thanks for your help.  talk to you tomorrow, I hope
20:00:58 <sethk> sometimes my device driver level thinking intrudes on my design engine.  :)
20:01:31 <sethk> anyway ...
20:02:20 <sethk> to use isDoesNotExistErrorType used with IOError::try, or IOError.catch?  Or both perhaps (not at the same time, I presume)
20:04:16 <sethk> It looks like if I call the function within IOError::try, then I pattern match on the return value
20:04:18 <sethk> is that correct?
20:17:43 <mwc> In GHCI, does the last value I calculated get bound to some build in variable?
20:17:58 <humasect> 'it'
20:18:12 <mwc> it? Thanks, couldn't remember what it swas called
20:22:25 <Cale> mwc: writing a group theory library for Haskell? :)
20:22:50 <sethk> Cale, do you know the answer to my question about IO.Error.try
20:24:54 <mwc> Cale, yeah, using haskell to play around with a finite group
20:25:56 <Cale> IO.Error.try x where x is an (IO a) computation which may throw an exception, will return a value of type IO (Either IOError a), which if an exception is thrown is of the form Left e, where e is the exception, and otherwise is of the form Right v where v is the ordinary return value.
20:26:06 <Cale> mwc: have you seen GAP?
20:26:39 <Cale> it's not Haskell, but it's pretty impressive for group theory
20:27:53 <Cale> sethk: sorry, since it's wrapped in IO, it's not of the form Left .. or Right .. directly, but you can bind it to get those out.
20:28:18 <sethk> try makes it return Either
20:28:23 <Cale> right
20:28:25 <sethk> which would make it Left and Right?
20:28:36 <Cale> right
20:28:48 <Cale> note that non-IO exceptions aren't caught by System.IO.Error.try
20:28:51 <sethk> ok, I'll try that.  I also found a method to check whether a file exists
20:28:54 <sethk> in System.Directory
20:28:58 <sethk> which is a bit strange
20:29:01 <Cale> yeah
20:29:07 <Cale> that's not strange
20:29:07 <Cale> :)
20:29:16 <sethk> yes, I saw that note about not catching non-IO exceptions
20:29:26 <sethk> thanks
20:29:37 <Cale> where else would you find stuff to examine directories?
20:29:39 <sethk> I think I'll get that working, and then try it with catch as a second pass
20:29:56 <sethk> Cale, I would expect to find a query about whether a file exists where I open and create files
20:30:10 <sethk> Cale, although I see your point
20:30:15 <sethk> in a sense it is a directory operation
20:30:46 <Cale> I suppose we could make IO import and reexport Directory
20:31:06 <sethk> a note in the documentation is all that's needed (if anything is needed)
20:31:11 <Cale> yeah
20:31:21 <mwc> Cale, never seen Gap
20:31:56 <Cale> mwc: http://www-gap.mcs.st-and.ac.uk/
20:32:19 <Cale> It's a bit hairy to learn, but treat it like it's a programming language and it's okay
20:32:51 <Cale> It can determine lots of things about groups
20:34:23 <Cale> gap> StructureDescription(Group((1,2,3),(2,3,4)));
20:34:23 <Cale> "A4"
20:35:12 <Cale> gap> List(SubgroupsSolvableGroup(Group((1,2,3),(2,3,4))), x -> StructureDescription(x));
20:35:12 <Cale> [ "1", "C2", "C2 x C2", "A4", "C3" ]
20:35:56 <Cale> lots of fun, once you know some basic things :)
20:37:08 <Cale> (It also has constructions for particular groups, I could have typed AlternatingGroup(4))
20:37:21 <Cale> and of course, tab completion :)
20:38:17 <Cale> with identifiers in the library like HasAugmentedCosetTableNormalClosureInWholeGroup, you really need tab completion :)
20:38:42 <Cale> HasCanonicalRepresentativeDeterminatorOfExternalSet, heh
20:39:24 <mauke> just use perl, it has wonderfully short variables like $|, $* or $]
20:39:35 <Cale> :)
20:39:40 <Cale> Or dc
20:39:48 <Cale> its variables are all one character
20:40:16 <Cale> you can even use newline as a variable, or the bell character
20:40:33 <mauke> yeah, same as in perl
20:40:45 <mauke> $^H is reserved for internal stuff, though
20:41:40 <mwc> Cool, take a look at Gap
20:46:27 <Cale> I just wish Gap was written on top of Haskell (perhaps with a nonstandard prelude)
20:48:45 <palomer> anyone know any papers describing the complexity of algorithms on lambda terms?
20:50:31 <Cale> mwc: if you're interested, I have a little library of functions which I wrote while working with gap
20:53:27 <mwc> Nah, I'm just doing something simple. Need to find a way to generate S_n given (1 2 ... n) and (1 2) permutations
20:54:33 <mwc> since any permuation can be decomposed into transpositions, I'm just wokring at arbitrary transpositions
20:55:20 <Cale> mwc: well, consider (1 2)^((1 2 ... n)^k) = (1 2 ... n)^(-k) (1 2) (1 2 ... n)^k
20:55:49 <mwc> that's where I am :P
20:56:13 <Cale> can you express that as disjoint cycles?
20:56:51 <mwc> I might be able to
20:56:59 <mwc> I'm trying to get some intuition for the problem first
20:57:59 <Cale> imagine a little puzzle with n dots in a circle which you can slide around, and at one point on the circle, you can swap two of them
20:58:43 <mwc> yeah, so now I have some haskell code to let me experiement with that
20:59:08 <Cale> (1 2 ... n)^k will rotate the circle k times
20:59:24 <Cale> then (1 2) will swap the pair in positions {1,2}
20:59:25 <mwc> Yeah, got it
20:59:30 <Cale> then put them back
20:59:51 <Cale> so the end result should be (k k+1)
21:00:20 * int-e would work with (1 2 3 .. n) (1 2), then build (1 k) and then the rest ;)
21:00:48 <mwc> int-e, that's my approach actually
21:02:24 <mwc> well, my first approach was to cut  a deal with Satan, but he isn't answering
21:06:35 <Cale> note that if you have a permutation p in disjoint cycle form, and you do p^q = q^(-1) p q where q is some other permutation, what you get is the permutation obtained from p by permuting the labels on the cycles in p, but leaving the cycles themselves structurally the same.
21:07:26 <Cale> that is, if p is something like (2 3 4) (1 5), then p^q = (q(2) q(3) q(4)) (q(1) q(5))
21:07:43 <Cale> okay, I'll be back in a bit
21:07:49 <mwc> ah, ^ is function composition
21:07:57 <Cale> ^ is conjugation
21:08:09 <mwc> yeah, I'll be here for a while :P
21:08:11 <Cale> p^q = q^(-1) p q
21:08:17 <Cale> multiplication is composition
21:14:57 <sethk> Cale, I want to return a tuple of size 3.  In one case I don't care what the first two members are, and in the second I don't care what the third is.
21:15:02 <sethk> Cale, I tried this (which didn't work)
21:15:07 <sethk> return (h, ep, _)
21:15:16 <sethk> I can see why that doesn't work
21:15:20 <sethk> but is there a syntax for that?
21:17:45 <cjs> What's wrong with just (h, ep, 0) or (h, ep, []) or something like that?
21:17:56 <sethk> cjs, not necessarily anything
21:18:03 <sethk> I can use 0 for any scalar type?
21:18:38 <cjs> Do both tuples have the same type? Presumably they could. Just put in any value of the type of the third element as returned in the other case.
21:19:02 <cjs> But something smells a bit odd about such a need, really. Are you sure you shouldn't be using one of those "or"-type types?
21:19:28 <sethk> cjs, of course I'll force both tuples to have the same type
21:19:38 <cjs> Retval = (a, b) | c     or something like that?
21:19:57 <sethk> cjs, probably there is a better way to structure it, yes
21:20:08 <sethk> cjs, but the question came up and I wondered in general what was allowed
21:20:18 <sethk> cjs, I guess I would have to construct values of the appropriate type
21:20:42 <cjs> Well, "don't care" is behavior in the caller, not the callee, so it doesn't make sense for a calee to return "don't care".
21:20:51 <sethk> cjs, yes, I see that
21:21:11 <cjs> So you're asking for the answer to a question that ought not be asked. :-)
21:21:16 <sethk> cjs, I was looking for some short cut where the compiler would take something (like 0, perhaps) and construct the appropriate type
21:21:32 <cjs> Oh, I see.
21:21:37 <sethk> the way you can use the value null in some languages
21:21:44 <sethk> empty, nothing, whatever.  :)
21:22:02 <cjs> I don't know of any language where you can do that, really.
21:22:42 <sethk> cjs, in c++ you can use 0 just about anywhere
21:22:46 <cjs> The ones that claim that there can be a "null" actually have one or both of two types available: "all these values" and "all these values and NULL", and those are distinct types.
21:22:53 <cjs> Sure, but 0 is a real value, with real meanings.
21:23:04 <sethk> cjs, yes, and in C++, _all_ types can assume the value 0
21:23:14 <sethk> cjs, so you can use 0 as a placeholder for _any_ type
21:23:27 <sethk> cjs, I'm not saying that's a good thing  :)
21:23:28 <cjs> Think about the SQL case. You can have "foo int NULL" and "foo int NOT NULL" as possible column types, but those are two distinct types, though SQL folks often try to pretend that they're not.
21:24:02 <mauke> sethk: not true
21:24:04 <sethk> cjs, NULL is a special value in SQL
21:24:09 <sethk> mauke, yes, true
21:24:11 <sethk> mauke, try it
21:24:16 <mauke> struct foo {}; foo x = 0; // error
21:24:29 <sethk> mauke, I didn't say you can use it as an initializer
21:24:34 <sethk> mauke, I said you can return it
21:24:38 <sethk> mauke, which is different
21:24:42 <mauke> how is it different?
21:24:44 <sethk> mauke, it might not work for a reference
21:25:07 <sethk> mauke, because the compiler will construct a reference or a pointer out of it
21:25:20 <sethk> mauke, I would have to check though for a reference
21:25:25 <mauke> struct foo {}; foo bar() { return 0; } // error
21:25:31 <mauke> no pointers/references involved
21:25:43 <cjs> I believe (though possibly I'm wrong--I'd be interested in a proof that I am) that use of NULL in SQL can be treated consistently within a type system, and doesn't need to be considered anything special.
21:25:56 <sethk> mauke, yes, ok, but you are forcing the error there to make your point.  That isn't a useful thing to do.
21:26:02 <cjs> Essentially, my theory is that "int NULL" is simply another type, albeit a very poorly designed one.
21:26:04 <sethk> mauke, but let's not waste time on that, it doesn't matter to haskell
21:26:10 <mauke> 0 can be used with arithmetic types, pointers and anything that defines an implicit conversion operator
21:26:30 <sethk> cjs, no, I happen to have written a complete ANSI SQL server, and that is one thing I've studied extensively.
21:26:38 <sethk> cjs, in SQL, NULL means "never assigned a value"
21:26:46 <sethk> cjs, which is semantically quite different.
21:27:02 <cjs> Huh? Wow, interesting comment....
21:27:09 <sethk> cjs, and NOT NULL means, of course, that it isn't true that something was "never assigned a value"
21:27:27 <sethk> cjs, the only way a value gets to be NULL is to insert a row into a table and not specify the value
21:27:30 <cjs> Can we open up another channel and discuss this in a bit more detail? I'm still on #yagni right now....
21:27:43 <sethk> cjs, sure, if you like.
21:27:53 <palomer> what's the complexity of doing a million reductions on a lambda term?
21:28:25 <cjs> Join #yagni, then.
21:29:10 <pnou> palomer: O(1) with a big constant ;-)
21:29:28 <palomer> pnou: I'm not so sure
21:29:43 <palomer> the complexity of doing a reduction is not O(1)
21:31:00 <palomer> or, rather, what's the complexity to check if u[v/t] = w with inputs u,v,w?
21:31:11 <palomer> syntactically equal
21:31:37 <pnou> i was joking, i guess you are talking about n reductions not a million
21:31:44 <palomer> nonono, a single reduction
21:31:58 <palomer> though I prefer my second phrasing
21:32:42 <pnou> i would say linear
21:33:13 <palomer> hrm, this is a very interesting question
21:33:19 <palomer> why hasn't anyone asked themselves this question?
21:33:50 <pnou> because it's trivial?
21:34:21 <palomer> I think it's O(u)*O(v) + O(w)
21:34:34 <palomer> who says there isn't a quicker method than doing the syntactic substitution though?
21:35:45 <gord> Is anybody out there familiar with the Zipper filesystem (ZFS, http://lambda-the-ultimate.org//node/view/1036) ?
22:17:07 <araujo> @index fromJust
22:17:08 <lambdabot> Data.Maybe
22:32:03 <araujo> @index filter
22:32:04 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
22:44:08 <araujo> mmm....
22:44:10 <araujo> ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
22:44:10 <araujo>         tyThingDataCon Identifier `HDL.ZCzp{d r3WO}'
23:04:28 <dons> mm. 5km resolution maps of HaskellUserLocations (needs a 200M earth.jpg though :)
23:04:44 <dons> araujo gets the ghc-bug-of-the-day prize!
23:05:18 * araujo raises hands
23:05:30 <Pseudonym> @karma+ araujo
23:05:31 <lambdabot> araujo's karma raised to 1.
23:05:33 <araujo> I finally won something
23:05:41 <Pseudonym> Yes, one karma point.
23:06:03 <araujo> haha
23:06:59 <araujo> I wonder if i am doing something too much stupid.....
23:08:02 <Pseudonym> Well, the impossible should never happen.
23:08:24 <Pseudonym> Even stupid people are incapable of breaking the laws of nature.
23:08:27 <dons> this is a good axiom
23:08:33 <Pseudonym> Indeed.
23:08:46 <Pseudonym> I'm not sure if it stands up to experimental scrutiny, though.
23:08:53 <Pseudonym> But I think it's a safe null hypothesis.
23:11:15 <araujo> @help lisppaste2
23:11:16 <lambdabot>  @help <command> - ask for help for <command>
23:11:24 <araujo> lambdabot, help
23:11:33 <araujo> @help
23:11:34 <lambdabot>  @help <command> - ask for help for <command>
23:11:44 <int-e> lisppaste2: help
23:11:45 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:11:51 <araujo> Thanks int-e
23:12:03 <int-e> they're two different bots you know :)
23:12:24 <lisppaste2> araujo pasted "ghc panic" at http://paste.lisp.org/display/12465
23:12:40 <araujo> In case someone wants to see the lines panic ghc
23:13:17 <int-e> aww cute.
23:14:05 <skew> wierd
23:14:16 <int-e> well, :+ should be a data constructor
23:14:56 <skew> that should be rejected by the parser
23:15:32 <skew> the instance is maybe a bit trickier because you could be pattern matching an argument against :+ or something
23:15:43 <TheHunter>     Pattern bindings (except simple variables) not allowed in instance declarations
23:15:43 <TheHunter>       x :+ y = (x + y)
23:15:43 <TheHunter> Failed, modules loaded: none.
23:15:49 <TheHunter> this is what ghc-6.5 says.
23:16:03 <TheHunter> so i guess it's been fixed.
23:16:53 <lisppaste2> int-e annotated #12465 with "same effect without infix 'operator'" at http://paste.lisp.org/display/12465#1
23:17:15 <araujo> TheHunter, did you indent the instance definition?
23:17:32 <araujo> the weird thng is that the panic just happens when i don't indent the code
23:17:44 <TheHunter> yes, i indented it...
23:17:50 <araujo> Don't indent it
23:17:55 <TheHunter> so I get a panic too here.
23:18:00 <int-e> ah!
23:18:02 <araujo> yeah
23:18:07 <int-e> it happens without the instance line, too
23:18:09 <TheHunter> but it's a fairly old 6.5.
23:20:20 <araujo> int-e, yeah
23:20:31 <int-e> uh, this can't be good. data A = X Int Int; X x y = X (x + y) 1 ... compiles!
23:21:51 <TheHunter> ouch!
23:23:27 <skew> I think that's fine
23:23:46 <skew> (f,g) = (\x -> x+1, \y -> y-1) is perfectly valid at the top level, iirc
23:23:52 <skew> it's just a pattern binding
23:24:21 <skew> now if X x y = x + y compiles, and X starts acting like +, then worry
23:24:28 <TheHunter> you're right.
23:25:15 <skew> a few versions back, at least, you run into problems when you try to match a list of more than 97 items like that, because GHC tries to optimize and unbox, and it's only coded for tuples up to that size
23:25:41 <int-e> ah. so that line defines functions x and y. okay ...
23:25:46 <int-e> 'functions'
23:25:58 <TheHunter> it is less clear what that should do: data A = X; X = undefined
23:26:46 <int-e> heh, that compiles, too.
23:27:09 <TheHunter> the behavior is sensible, i guess.
23:27:26 <int-e> for that matter, so does data A = X | Y; X = Y. Counter-intuitive.
23:27:54 <int-e> but probably ok, right.
23:28:06 <TheHunter> @eval let () = undefined in ()
23:28:10 <lambdabot> ()
23:29:32 <int-e> @eval let Left () = Right () in Left () == Right ()
23:29:35 <lambdabot> False
23:30:35 <TheHunter> @eval case undefined of () in ()
23:30:36 <lambdabot>  parse error on input `in'
23:30:41 <TheHunter> @eval case undefined of () -> ()
23:30:43 <lambdabot> Undefined
23:31:01 <skew> Is there any particular reason coordinates on HaskellUserLocations report various places of accuracy?
23:31:08 <TheHunter> everything makes perfect sense, so I can go to bed.
23:31:36 <skew> say, xearth drops trailing zeros when the file is run, or something
23:34:49 <skew> if all those digits are accurate, lispy lives under a tree in the hills east of San Jose
23:35:01 <Speck> oh, that must be pretty!
23:35:15 <Speck> sigh. I miss california
23:36:14 <basti_> I noticed that i'm ~ 1 km to far south, too.
23:36:23 <sethk> Speck, where are you?
23:36:44 <skew> you can use google maps to get exact coordinates
23:36:55 <araujo> wikipedia is also very good too.
23:36:55 <basti_> The maps are pretty fuzzy there :(
23:36:59 <Speck> sethk: atm in Baltimore, but I'm from near San Fran
23:37:07 <basti_> i got my coordinates from wikipedia
23:37:12 <sethk> Speck, I'm in NY
23:37:14 <skew> for your town?
23:37:19 <sethk> basti_, well, no wonder they are wrong
23:37:29 <basti_> I'd better look for -real- maps, I bet there's some in our library
23:37:46 * araujo got the right coordinates for his town in wikipedia
23:37:59 <skew> I can pretty nearly pick out my front door with the satellite pictures
23:38:11 <araujo> That might not be the case for other people i suppose
23:38:33 <skew> well, the pictures of the trees at lispy's coordinates are pretty clear
23:39:26 <Speck> how do I get the exact coordinates from google maps? I click "link to this page" and I don't see them
23:39:45 <basti_> the resolution for germany lacks a bit :(
23:39:46 <skew> it's in the url
23:40:04 <basti_> i can barely make out my town, but i recognized it by the form of the river
23:40:16 <Speck> http://maps.google.com/maps?q=310+E.+University+Pkwy,+Baltimore+MD,+21218&t=h&iwloc=A&hl=en
23:40:16 <skew> then if you type it in the location box like xx.xxxNyy.yyyW it puts a marker there
23:40:34 <Speck> gets my house exactly
23:40:57 <Speck> but I don't see the coordinates
23:41:29 <dons> btw, I'm now using 5km resolution maps for the hawiki page. takes a bit of time (~20mins) to generate all the images though :S
23:41:44 <Speck> zomg... why so long?
23:41:49 <dons> looks nicer than google's maps though
23:41:52 * araujo should get the uncle's GPS to get the exact coordinates of his room
23:42:12 <dons> well, the data file is 200M, which xplanet then spends 1G of ram projecting and plotting on
23:42:20 <Speck> ouch
23:42:25 <skew> see the ll= thing in the link, those are the gps
23:42:33 <skew> or, latitude and longitude
23:42:57 <dons> it's worth it though, for example the zoom in on western europe is *much* sharper
23:43:13 <Speck> skew: I must be blind... I don't see it
23:44:27 <skew> Speck: go to your url, then click "link to this page"
23:44:41 <skew> at least for me I then get http://maps.google.com/maps?q=310+E.+University+Pkwy,+Baltimore+MD,+21218&ll=39.330314,-76.612859&spn=0.014380,0.041014&t=h&hl=en
23:45:00 <Speck> yeah... I don't get that in mine
23:45:12 <skew> so you're at 39.330314 north by 76.612859 west
23:45:25 <skew> maybe you need to move the map around a tiny bit?
23:46:21 <skew> yeah, my numbers are a bit off
23:47:02 <Speck> ok thanks. I updated
23:49:31 * dons tries to parallise image generation
23:51:55 <araujo> With xplanet you can also have it as screenshot and updated like xearth?
23:52:00 <skew> are the images building right now?
23:52:21 <dons> you can have it as a screenshot, yep
23:52:37 <dons> skew, yes, i'm attempting to regenerate them in parallel
23:52:52 <dons> would you guys like to see the automated script? i should post a link on the wiki
23:53:00 <araujo> yeah
23:53:10 <Speck> definitely
23:53:49 * Speck feels like dons distracting himself from yi :-X
23:53:52 <skew> doesn't that put you dangerously close to running out of RAM?
23:54:31 <dons> skew: yes!
23:54:43 <dons> luckily I have some 16G servers to play around with
23:54:54 <dons> but it was impossible on my laptop
23:55:03 <dons> (with hi-res earth maps)
23:55:25 <dons> http://www.cse.unsw.edu.au/~dons/haskell-planet
23:55:40 <skew> oh, if you have servers like that then you should be fine
23:55:50 <dons> that's all there is to it, once you've got xplanet, got an earth map of decent quality (though you can use the low-res one that comes with xplanet) and set up a config file
23:56:11 <dons> the wiki goes in to more detail on what you need to do
23:56:38 <skew> I was thinking you could ask John Meacham, considering the first memory reclamation strategy he used in jhc
23:58:58 <kzm> dons, sorry if I wasn't paying attention, but is the wiki page about to be updated?  I just get gray images (with locations on them)
23:59:54 <dons> oh. hmm. let me see..
