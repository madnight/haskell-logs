00:02:31 <pesco> Okay, I've added myself.
00:02:35 <pesco> Time to take a shower.
00:03:12 <Pseudonym> Yeah, I felt dirty after adding myself too.
00:05:24 <dons> hehe
00:05:49 <dons> Pseudonym, did you see @localtime? any opinions?
00:05:54 <Pseudonym> @localtime
00:06:01 <Pseudonym> No, I didn't see it.
00:06:02 <dons> @localtime Pseudonym
00:06:04 <lambdabot> Local time for Pseudonym is Mon Oct  17 17:05:41 2005
00:06:07 <Pseudonym> Ah, cool.
00:06:13 <Pseudonym> @localtime dons
00:06:17 <lambdabot> Local time for dons is Mon Oct 17 17:10:01 2005
00:06:22 <dons> oh my!
00:06:31 <Pseudonym> Hey, I know!
00:06:39 <Pseudonym> I could spam people and nobody would know it was me!
00:06:49 <dons> yeah! :D
00:07:07 <dons> evil lambdabot-the-ctcp-spammer
00:07:11 * Pseudonym stops now
00:07:33 * dons notices 20-odd ctcp time requests from lambdabot. hmm
00:07:42 <Pseudonym> Half of them were me.
00:07:44 <Pseudonym> Sorry.
00:07:52 <dons> :p
00:14:20 <boegel> @localtime
00:14:29 <boegel> @localtime boegel
00:14:39 <boegel> @localtime boegel
00:14:42 <boegel> ?
00:16:12 <Lemmih> Local time for boegel is Mon Oct 17 09:18:20 2005
00:16:59 <dons> boegel, maybe your client won't respond to ctcp time pings?
00:17:03 <boegel> Lemmih: why does that come from you ?
00:17:06 <boegel> dons: maybe
00:17:10 <dons> do you see any debug output in your client?
00:17:13 <boegel> Received a CTCP TIME from lambdabot
00:17:34 <dons> hey adept! i'll try again... you should add yourself to:
00:17:35 <dons> @map
00:17:36 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
00:19:30 <adept> dons: hi
00:19:35 <dons> hey :)
00:19:51 <Pseudonym> @localtime lambdabot
00:20:21 <adept> dons: i was absent most thursday, and gave up scrolling back more than 1500+ messages looking for that particular one :)
00:20:39 <dons> nah, lambdabot doesn't know how to respond to: "PRIVMSG", msgParams = ["lambdabot",":\SOHTIME\SOH"]
00:20:51 <dons> hehe. ok adept, that's cool.
00:20:51 <Pseudonym> Right.
00:21:05 <dons> adept, the logs are much better for searching for pings
00:21:09 <Pseudonym> The ctcpDecode stuff is in there.  It just doesl't look for the \SOH.
00:21:22 <Pseudonym> Which it probably should some day.
00:21:23 <dons> Pseudonym, ah! didn't see that.
00:21:37 <Pseudonym> That's one of the earliest bits of code I wrote!
00:21:44 <Pseudonym> And didn't do anything with. :-)
00:21:53 <adept> dons: I know, but i had 37.5C at the moment and was unable to think straight :)
00:22:02 <Pseudonym> Oh, hang on.
00:22:05 <dons> looks like ctcp* disappered from lambdabot at some point..
00:22:13 <Pseudonym> So how does lambdabot handle CTCP responses?
00:22:23 <dons> reponses?
00:22:34 <dons> it's dropping the PRIVMSGs that don't look like @commands
00:22:39 <Pseudonym> How does the CTCP TIME response come back?
00:22:43 <dons> and doesn't respond with a NOTICE
00:23:01 <dons> it takes the NOTICE, maps it to a PRIVMSG, which the @localtime plugin handles as a conventional privmsg
00:23:19 <Pseudonym> Ah, it's a NOTICE.
00:23:19 <dons> 'twould be easy to extend the notice handling code though
00:23:32 <dons> yeah, odd really :/
00:23:51 <dons> so if I PRIVMSG "\^ATIME\^A" you, you NOTICE me back "\^ATIME ... \^A"'
00:24:25 <dons> in fact, if you tcpdump your network dev, it's easy to watch these msgs bounce back and forth
00:24:38 <cjs> tcpflow is your friend.
00:24:49 <dons> tcpdump | less works rather well too..
00:25:42 <dons> how does tcpflow work?
00:26:34 <adept> dons: and how exactly could I add myself?
00:27:15 <dons> you can either log in to the wiki (click UserPreferences, set a name and passwd) or /msg me your coords, and I'll add them
00:27:25 <dons> either way, the wiki page gets edited
00:29:17 <frederik> doesn't the notation in the implicit configurations paper seem backwards? they use "reify" to go from values to types and "reflect" to go from types to values... i would think it'd be the opposite
00:30:32 <dons> I use to think so too, same in the TH paper, iirc
00:30:49 <Pseudonym> Must away.  Nytol!
00:30:56 <dons> but they seem to use 'reification' for values -> types in a few such papers
00:31:22 <dons> @wikipeida reification
00:31:23 <lambdabot> http://en.wikipedia.org/wiki/Reification
00:31:43 <dons> "treating an abstract concept as if it were a real"
00:31:49 <dons> i.e. types -> values!
00:31:57 <dons> but it's a metaphor, I guess
00:32:08 <dons> (the use in TH, implicit configuration and so on)
00:32:39 <frederik> metaphor?
00:33:21 <dons> the use of the term "reify" is borrowed from philosophy, it's used as a metaphor to describe what they're doing.
00:33:29 <JohnMeacham> Howdy.
00:33:31 <dons> so the meaning isn't necessarily the same
00:33:49 <dons> they seem to use it just for it's "lift"ing meaning
00:35:07 <Lor> Yeah, occasionally the words are used with inverted meaning.
00:35:13 <Lor> It's reeaally confusing.
00:35:46 <frederik> JohnMeacham: howdy
00:36:00 <Lor> I actually asked Mitchell Wand at ICFP about where he got the word "reify".
00:36:08 <dons> ah! and he said?/
00:36:21 <frederik> i'd like to see their justification for inverting things
00:36:23 <Lor> Well, logic, mostly.
00:37:05 <dons> but it's quite an obscure term. although philosphers use it a lot. i first learnt about "reification" in some metaphysics course
00:37:31 <JohnMeacham> it makes sense though. "To regard (something abstract) as a material thing."
00:37:59 <frederik> JohnMeacham: so that would be types->values or values->types?
00:38:11 <Lor> The inverted meaning is used e.g. in the ocaml and alice sources.
00:38:23 <frederik> also, the code that comes with the papers is incomplete. that's annoying
00:38:31 <frederik> some of the tests just loop infinitely
00:38:35 <dons> and in the TH paper, I think. unless you view the abstract syntax as the concrete form..
00:38:40 <dons> which is confusing.
00:38:47 <Lor> frederik, which paper are you talking about
00:38:58 <JohnMeacham> Usually I think it means being able to look into things that are usually abstract, like objects, types, treating programs as data.
00:38:58 <frederik> the Implicit Configurations paper - prepose.lhs
00:39:32 <JohnMeacham> But. I think it is a pretty vauge term without some context...
00:39:39 <dons> ah, JohnMeacham, so reflecting a value into an (abstract!) syntax tree representing that value
00:40:02 <frederik> JohnMeacham: what i'm saying is that it sounds like it should mean types->values. but they're using it in the opposite way. you haven't explained yourself
00:40:10 <dons> so that's ok, but the uses where values are lifted to types is less clearly a reification
00:40:38 <frederik> prepose.lhs leaves out an implementation of the chinese remainder theorem
00:40:51 <dons> frederik, John's talking about a value -> data representing that value, which is also "reification"
00:41:10 <dons> however, value -> type, sometimes called reification, seems to invert the sense
00:41:29 <dons> but it's really used as a metaphor, borrowing from the value -> data structure use, I think
00:41:35 <khaladan> isn't reification more like treating a representation as real data?
00:41:44 <dons> right.
00:41:59 <dons> but sometimes it is used to describe lifting values into types
00:42:03 <JohnMeacham> Yeah.
00:42:15 <frederik> holy shit, my window is a solid sheet of gray. i should look out that more often
00:42:27 <dons> which as several people have pointed out, would appear to invert the sense of the word
00:43:18 <Lor> No, in prepose.pdf, at least in section 4, the words are used correctly.
00:43:24 <khaladan> being able to operate on types means types are behaving like values, so it's like the other way around again :)
00:43:36 <frederik> i get it. it's kind of an implementor-oriented terminology that they used in the API
00:44:03 <dons> khaladan, but these aren't types at runtime, these are real static types
00:44:05 <frederik> Lor: what? they use reify to mean "going from types to values". i'm looking at it
00:44:34 <dons> khaladan, the types don't behave like values, the values behave like types
00:45:20 <Lor> Right, that's what it's supposed to mean.
00:46:21 <frederik> Lor: ? we've been discussing *why* it's used that way
00:47:10 <dons> I think Lor is quite clear, frederik. what's the issue?
00:47:31 <dons> lrrr, hey! learning haskell?
00:48:24 <Lor> Hm, now that I look at it, I don't think this has much to do with either reflection or reification.
00:48:48 <Lor> It's just moving stuff between the type and value levels.
00:49:09 <dons> just lift?
00:49:28 <dons> a la `lift' in twelf and friends?
00:49:36 <Lor> I don't know twelf.
00:49:56 <Lor> It looks like the singleton type trick.
00:50:12 <dons> e.g. lifting a normal value into a (dependent) type with that value
00:50:28 <dons> with that value in the type
00:50:37 <dons> like a singleton type trick, yeah
00:51:03 <musasabi> For each value define a new type which is an instance of a typeclass with the dictionary containing the value?
00:51:24 <frederik> dons: Lor said "No, in prepose..." and I didn't understand what "No" was referring to
00:51:37 <dons> ah, ok.
00:51:56 <dons> musasabi, are you sitting an exam? ;)
00:52:43 <musasabi> I don't think there are any exams with Haskell here :-(
00:52:57 <frederik> my question is whether the type->value or value->type meaning for reification makes more sense. i understand how it's used in the paper (the latter form), that's not the question
00:53:19 <frederik> but i think we've already come up with a justification and now i'm going
00:53:44 <dons> :)
00:54:05 <dons> frederik <- reifies himself
00:54:34 <Lor> I don't think it's just a question of sorts.
00:55:08 <Lor> Reification means to take something into a form where it's easier to manipulate.
00:55:35 <Lor> And reflection (or absorption, as I like to call it) is putting something manipulated back into place where it actually has some effect on something.
00:56:21 <dons> hmm. easier to manipulate, or more `concrete'?
00:56:39 <JohnMeacham> Yikes. thunder and lightening. I didn't even know it was raining.
00:56:42 <JKnecht> Actually, reification simply means to make an object of an abstraction.
00:57:16 <dons> object and abstraction are heavily overloaded terms here
00:57:38 <JohnMeacham> JKnecht: well, to make it concrete, not necessarily an object. but, as was said, sometimes it seems to be used backwards..
00:57:48 <cjs> I object to abstraction. Or do I abstract my objections? I forget.
00:57:52 <dons> so, Lor, are you arguing that type/value shifts shouldn't use this metaprogramming terminology?
00:57:58 <dons> (which would seem reasonable)
00:58:24 <JohnMeacham> so. perhaps we can just think of a 'reification' as a relationship between an abstract and contrete thing, and to 'reify' means to apply a 'reification' in either direction.
00:58:28 <dons> unless you are reifying a value into a type whose structure represents the values structure, perhaps
00:58:36 <Lor> It depends on the intention.
00:59:34 <dons> John, reify should always go from abstract to concrete, though, I think.
00:59:53 <JohnMeacham> dons: yeah, I agree. but I have seen it used both ways.
01:00:01 <Lor> Sure you can do type-level computation and then move the result to value level, but that's just compile-time preprocessing, not "reflection".
01:00:10 <JohnMeacham> dons: lets come up with a word for the other direction and try to popularize it.
01:00:22 <dons> ah! Lor, good point.
01:00:58 <beelsebob_> gyah, it would appear JaffaCake hasn't updated my public key :(
01:01:06 <Lor> And now that I look at prepose.pdf, it doesn't really do much with _types_, it just uses types to name dictionaries.
01:02:48 <Lor> If I gather right from a quick look, the idea in the paper is just to encode all kinds of values as dictionaries and then make use of the implicitness of dictionary passing.
01:24:25 <Lor> Golly, the sigplan notices version of icfp proceedings came _fast_.
01:24:38 <Lor> Usually they take a couple of months, now just two weeks.
01:25:03 <JKnecht> hmmm, is lazy evaluation the reification of non-strictness?
01:25:07 <wilx> !seen pesco
01:25:14 <wilx> @seen pesco
01:25:15 <lambdabot> I saw pesco leaving #haskell 34 minutes and 16 seconds ago.
01:25:37 <dons> in fact, you could already get the papers from the acm site during the conference
01:26:06 <dons> so they were generally nice and efficient all round this year :)
01:30:58 <Lor> Sigplan has tightened its purse strings. There are not nearly as many proceedings in sp notices this year.
01:31:18 <ProfTeggy> Morning.
01:31:44 <Akshaal> morning
01:36:35 <araujo> Morning!
01:38:41 <araujo> @index Pipe
01:38:42 <lambdabot> bzzt
01:43:06 <kowey> hi haskellers, i think i need tactical advice dealing with laziness and IO
01:43:17 <kowey> perhaps the results of this could be useful on hawiki
01:43:41 <kowey> so it goes like this: i'm building a GUI.  It's got a main window and a parameters window
01:43:44 <beelsebob_> kowey: how do you mean?  Using interact?
01:44:09 <kowey> maybe, i'll tell my story and see what hints pop up... laziness is still something i haven't fully wrapped my head around :-(
01:44:45 <kowey> the idea is that you call the params window, load some files, and click load
01:44:55 <kowey> when that happens, the main window refreshes, telling the user what files you have loaded
01:45:27 <kowey> so the main window has code like this:
01:45:39 <kowey> set loadMenIt [ on command := do openParamsWindow
01:45:57 <kowey> (indentation)          updateMainWindow ]
01:46:12 <kowey> (i'm simplifying a bit... the information passed around using an IORef)
01:46:29 <kowey> now... what *really* happens is that
01:46:42 <kowey> 1. the user calls the parameters window, loads his files, and clicks load
01:46:44 <kowey> 2. nothing happens
01:46:51 <kowey> 3. the user calls the params window
01:47:02 <kowey> 4. NOW the main window updates with the results from (1)
01:48:44 <beelsebob_> doesn't sound like an issue with lazyness
01:48:45 <kowey> i guess the first question here is: is the cause of my plight laziness, as i'm guessing?
01:48:57 <beelsebob_> sounds like an issue with a lack of demand
01:49:15 <kowey> one thing is that if i trace the updateMainWindow bit
01:49:17 <beelsebob_> if the main window demands it's contents it will be evaluated
01:49:21 <beelsebob_> if it doesn't it won't be
01:49:22 <kowey> it seems like that gets called before the gui gets loaded
01:52:45 <kowey> beelsebob_: you're saying that the main window should be asking for the results of the params window?
01:52:53 <kowey> the new configuration settings?
01:52:56 <beelsebob_> yes
01:53:08 <kowey> one thing i tried is return an new IORef from the params window
01:53:14 <beelsebob_> if it doesn't they'll never be evaluated
01:53:15 <kowey> and passing that as an argument to the updateMainWindow stuff
01:53:20 <kowey> still no luck
01:53:52 <beelsebob_> I can't claim to know how gui stuff works anyway
01:54:10 <beelsebob_> but I'm guessing that updateMainWindow should be calling a function to grab the contents
01:54:11 <kowey> well... i was hoping this was a general Haskell IO style problem
01:54:49 <beelsebob_> nope, it's a gui problem
01:54:55 <beelsebob_> the gui isn't asking for the data
01:55:06 <beelsebob_> because if it asks, it will get it
01:56:32 <kowey> would you mind looking at some code? i'll go create a darcs repo online and you can load the relevant file in a browser
02:02:04 <kowey> the Gui code lives here: http://www.loria.fr/~kow/darcs/BrokenGeni/src/geni/Gui.lhs
02:02:20 <kowey> and the repository is  http://www.loria.fr/~kow/darcs/BrokenGeni
02:02:34 * araujo finds interesting to think over monads like UNIX pipes
02:02:54 <shapr> @yow !
02:02:54 <lambdabot> I'm having an EMOTIONAL OUTBURST!!  But, uh, WHY is there a WAFFLE
02:02:54 <lambdabot> in
02:02:54 <lambdabot> my PAJAMA POCKET??
02:03:22 <kowey> so the bit tha calls up the params window is loadMenIt (line 98)
02:04:04 <kowey> the params window is configGui (line 324) and the update main window thing is readConfig (line 251)
02:04:42 <araujo> So, its like (as far as i am understanding), the IO monad is a way to force computation passing implicitly the state of each process from one computation to another?
02:05:39 <shapr> That's one way of looking at it.
02:05:42 <araujo> Hence it keeps the transparential reference for IO?
02:07:04 * araujo wonders why all people stopped talking
02:07:44 <JKnecht> For 2 min.?
02:07:53 <rasterfar> perhaps because the only place it's a decent hour is Atlantis?
02:08:31 <sieni> @localtime sieni
02:08:32 <JKnecht> Or respectful silence for ' transparential '.
02:08:35 <lambdabot> Local time for sieni is Mon Oct 17 12:08:10 2005
02:08:40 <shapr> Or maybe because it's time for unicycling?
02:08:51 <kowey> well, maybe to stir some discussion (besides asking for gui help) is to show two examples of common things which seem really hard for the avg programmer to do in haskell
02:08:55 <kowey> some controversy?
02:08:59 <araujo> mm....
02:09:17 <shapr> kowey: strictness analysis
02:09:20 <rasterfar> debugging would be one
02:09:22 <kowey> example 1. do putStr "Loading file..."; loadTheFile; putStr "done!"
02:09:38 <kowey> oooh, i was thinking more in terms of programming tasks
02:09:38 <araujo> shapr, what is other way to look at monads
02:09:39 <araujo> ?
02:09:58 <kowey> example 2. timeBefore <- getCPUTime; someLongThing; timeAfter <- getCPUTime
02:11:05 <kowey> i suppose everyone sees why 1 and 2 are bad...
02:11:26 <araujo> Ive also read that they are like containers, but i don't see that definition at all
02:11:57 <shapr> araujo: IO is only one monad. Have you read about the List monad or the Maybe monad?
02:12:21 <araujo> shapr, not yet
02:12:27 <kowey> aruojo: the Maybe monad is a very useful way to get that mental click, the ah-hah! of comprehension
02:12:28 <araujo> moving slowly towards it
02:12:32 <kowey> (for me, anyway)
02:13:05 <shapr> Your description of the IO monad is accurate, from one viewpoint.
02:13:12 <araujo> Ok, i'll check that out, thanks for the piece of advice kowey
02:13:33 <shapr> araujo: http://www.nomaware.com/monads/html/index.html
02:13:36 <araujo> Happy to know i am not so lost
02:13:38 <kowey> (but i suspect you understand more deeply than i do; i'm just a user)
02:13:49 <araujo> shapr, Thanks
02:14:12 <sieni> btw, what's the Right Way to implement backtracking for an NFA regex engine in Haskell? Some monad stuff or just magically somehow creating a list of all matches and evaluating the head?
02:14:12 * araujo bookmark it for reading it after univ.
02:14:50 <JKnecht> I'm a Haskell n00b but I presume a Haskell monad is supposed to be a computation realization of : http://en.wikipedia.org/wiki/Monad_%28category_theory%29
02:14:55 <shapr> The list monad is one easy approach to backtracking.
02:15:14 <JKnecht> s/computation/computational/
02:15:25 <shapr> On the good side, you don't have to understand category theory to use and understand monads.
02:15:45 <shapr> Both monads and objects are abstractions. Objects are more complicated though :-)
02:16:09 <JKnecht> Real ones I suppose you mean :)
02:16:42 <shapr> I mean like instances, inheritance, etc, it's a lot more complicated than the monadic abstraction.
02:16:56 <araujo> Interesting.
02:17:54 <JKnecht> Well the 3 defining characteristics of OOP are only complicated in (some) language implementations.
02:18:20 <sieni> I would tend to say that one should understand cohomology of abelian categories, before starting coding in haskell
02:18:23 <sieni> (not)
02:18:23 <kowey> beelsebob_: ok... i think i see where the problem is, but i'll still have to figure out how to solve it
02:18:35 <JKnecht> Pretty straightforward in Smalltalk for example.
02:19:59 <dcoutts> JKnecht, I think Haskell smeantics is moer based on domain theory than category theory.
02:20:22 <rasterfar> Except for the monads.
02:20:54 <JKnecht> Domain theory? You mean higher order set theory/logics?
02:21:34 <musasabi> Is "modifyIORef ior (+1)" if all other threads are only reading the value (and it is an Int) ?
02:21:49 <musasabi> That is - is it safe.
02:22:02 <Heffalump> and you don't mind which value they get?
02:22:21 <JKnecht> Wiki says that's the new name of denotational semantics. Good to know :)
02:22:47 <musasabi> Heffalump: not really (either n or n+1 is fine).
02:22:55 <Heffalump> musasabi: I think it's ok.
02:23:00 <dcoutts> musasabi, there's also atomicModifyIORef
02:23:11 <dcoutts> http://en.wikipedia.org/wiki/Domain_theory
02:23:18 * beelsebob_ wonders why cvs update is taking so long
02:23:47 <musasabi> dcoutts: yes, and it is quite expensive - I am wondering whether I really need it.
02:26:40 <dcoutts> musasabi, or use MVars
02:26:52 <dcoutts> MVars are prefered when working with threads
02:29:34 <beelsebob_> Alduruch:~/Documents/Work/hat tatd2$ cvs tag "Old Hat Detect Ends Here"
02:29:35 <beelsebob_> cvs [tag aborted]: tag `Old Hat Detect Ends Here' has non-visible graphic characters
02:29:38 <beelsebob_> buh?
02:29:55 <arekm> hi, did anyone try to compile ghc 6.4{,.1} on linux-sparc? http://buildlogs.pld-linux.org/index.php?dist=ac&arch=sparc&ok=0&id=1b72a2d5310ac17d683b79fee247580c
02:32:12 * shapr boings
02:32:14 <shapr> jiihaa
02:32:35 * beelsebob_ prods shapr with a stick
02:32:47 * shapr explodes
02:33:30 <shapr>  /etc/init.d/pantsd restart
02:34:04 <shapr> Hiya pantsd, learning Haskell?
02:34:38 <beelsebob_> how goes the world shapr
02:34:51 <shapr> Into and out of the monad as usual, how's yours?
02:35:18 <shapr> Actually, life is good.
02:35:24 <beelsebob_> good... I'm just commiting my changes to hat
02:36:03 <beelsebob_> now I'm checking I haven't broken it
02:36:28 <beelsebob_> if you want to try hat-delta, it's now in CVS
02:48:39 <dcoutts> arekm, yes ghc-6.4{.1} is available for sparc in Gentoo
02:51:26 <tomaszz> dcoutts: unfortunately, arekm has already quit
03:00:02 <cjb> Hum.  Anyone know how to make emacs remember its find-file history between invocations, so I can `C-x f up' to see the last file I was working on?
03:13:13 <beelsebob_> to anyone who's bored: hat-delta is now in cvs, feel free to try and break it
03:47:14 <kowey> beelsebob_: thanks for your help! i think i've solved my GUI problems
03:47:23 <beelsebob_> good stuff :)
03:47:27 <kowey> i passed the params window a function which updates the main window
03:47:30 <beelsebob_> not that I helped really, but he
03:47:32 <beelsebob_> hey*
03:47:37 <kowey> but talking it out was useful
03:47:38 <kowey> :-)
03:48:20 <adept> cjb: regarding your emacs q: maybe recent-file is what you are looking for
03:48:23 <beelsebob_> neil: if you check out hat, do you get my changes?
03:50:04 <cjb> adept: Mmm, perhaps.  Thanks.
03:54:56 <shapr> ValarQ: Hey, do you have all the various versions of nmarkov lying around? I'd like to use them to demonstrate monadic refactoring.
03:59:07 <paolino> hello, I'm trying to rewrite map and filter in term of continuation passing style with no success, any help appreciated
04:01:46 <paolino> should be trivial as an exercise from chapter 4 of YAHT ;)
04:08:24 <ndm> beelsebob_: just about to
04:08:41 <ndm> and type ndm if you want me to notice :)
04:10:07 <ndm> checking out hat now...
04:11:32 * shapr wears the black-hat 
04:11:34 <Megzl> hi.
04:11:40 <shapr> hiya Megzl, you're back!
04:11:49 <shapr> How's C++ treating you?
04:12:09 <Megzl> Funny you should remember, but I guess that's because people on #Haskell are rather intelligent, have good memories, and are extremely nerdy.
04:12:26 <shapr> Megzl: I am not nerdy!
04:12:56 <shapr> Megzl: Do I look nerdy to you? - http://www.scannedinavian.org/~shae/unicycle/PICT3226.smaller.JPG
04:13:03 <Megzl> shapr: C++ is treating me well. I constantly find new possibilities for programming syntaxes in C++.
04:13:18 <adept> Megzl: shapr is vicious and have faulty memory. He teases you, forgets about it, and then teases you again :)
04:13:21 * adept hides
04:13:38 <shapr> My girlfriend says that yellow just isn't my color. Ok, other than that, I am not nerdy!
04:13:47 <shapr> adept: Hah! Um, who are you again? ;-)
04:13:54 * shapr pretends to have a faulty memory.
04:13:57 <Megzl> http://www.rafb.net/paste/results/mbfKSY67.html
04:14:31 <shapr> Hm, doesn't look like Haskell code to me.
04:14:51 <cjs_> So who here uses unit testing in Haskell? What's the role of it, as compared to XP-type OO programming?
04:14:56 <Megzl> shapr, can haskell do this?
04:15:07 <sieni> I heard that unicycling is dangerous for juggling, since if one gets too much into it, juggling training will suffer from lack of time
04:15:15 <Megzl> (easily)
04:15:39 <Megzl> btw, Haskell users are expected to already be masters of C++
04:16:02 <Megzl> Haskell users are supposed to know multiple languages, and coder in C++ better cause of knowing Haskell.
04:16:14 <shapr> cjs_: I use unit testing in Haskell. Did you read my TMR article?
04:16:37 <cjs_> Eww. I've not written any C++ for more than ten years, and I hope never to touch it again.
04:16:44 <Megzl> I know how Haskell could get a big boom.
04:16:51 <shapr> gunpowder?
04:16:54 <Megzl> Blow up haskell.
04:16:59 <ndm> a debugger....
04:17:01 <Megzl> No.
04:17:10 <shapr> um, nuclear wessels?
04:17:12 <cjs_> TMR? No....
04:17:26 <Megzl> Make Haskell into VM with a C/C++ api that you can drop into anything, like how Lua works.
04:17:31 <shapr> cjs_: http://www.haskell.org/tmrwiki/IssueFive
04:17:35 <UnderDawg> XP-type OOP?
04:17:39 <ndm> Microsoft buying up all the core haskell developers?
04:17:44 <Megzl> a fast VM that executes haskell code.
04:17:46 <Megzl> sandboxed.
04:17:55 <shapr> Megzl: That's funny, I think Haskell already has excellent FFI support.
04:17:55 <ndm> Megzl, we already have that - yhc
04:18:01 <b0gg1e> wouldnt a backend to parrot or mono be sufficient for that?
04:18:07 <b0gg1e> morning, btw :-)
04:18:12 <ndm> b0gg1e: they are not designed for lazy langauges
04:18:12 <Megzl> I want to use Haskell as a scripting language in my app.
04:18:18 <shapr> Megzl: You can do that already.
04:18:25 <Megzl> shapr, is it sandboxed?
04:18:28 <ndm> hs-plugins does that
04:18:33 <ndm> and it has sandboxing
04:18:42 <ndm> @eval removeFile "file.txt"
04:18:45 <lambdabot>  Not in scope: `removeFile'
04:18:48 <Megzl> Only if I can easily drop Haskell into C++ is it a serious consideration for me.
04:18:57 <ndm> showing an example of the sandboxing stopping me removing files
04:19:01 <Megzl> And write/execute Haskell code from strings
04:19:02 <b0gg1e> ndm, is it really that impossible to wrap haskell into this?  i heard that the CLR has at least support for tail recursion.
04:19:06 <dcoutts> Megzl, GHC has a C api that you can use
04:19:14 <ndm> its possible, but not efficient
04:19:19 <shapr> Time for workfocus, bbl
04:19:22 <ndm> constructing continuations at every point is slow
04:19:33 <Megzl> GHC or YHC?
04:19:34 <ndm> because its not native to the lagnuage
04:20:24 <cjs_> Ooo! I just discovered The Haskell Sequence!
04:21:00 <adept> shapr: actually, you DO look nerdy. I mean, unicycling on walls does that that to one's image. Then, those horizontal flowerbeds ..
04:21:00 * adept hides even deeper
04:21:52 <Megzl> the thing is... I use Lua now.
04:22:01 <Megzl> Lua's VM takes 100K.
04:22:07 <cjs_> UnderDawg: Extreme Programming. If you look it up on the web, you'll find plenty of stuff.
04:22:07 <Megzl> I can start up 75 VM's if I want.
04:22:23 <Megzl> In 1 line of code I can create a new VM.
04:23:22 <Megzl> each of these VM's supports coroutines, which is like minimal multithreading
04:24:40 <ndm> Megzl: yhc's takes 125kb
04:25:01 <ndm> plus a heap and stack, of about 8kb
04:25:26 <ndm> since the 125kb data is shared, i reckon you could easily start several 1000 yhc VM's on any computer
04:26:50 <Megzl> YHC doesn't show up on google
04:26:52 <Megzl> only GHC
04:27:04 <dcoutts> it's a bit new
04:27:07 <dcoutts> @where yhc
04:27:07 <lambdabot> I know nothing about yhc.
04:27:13 <Megzl> Got a link?
04:27:25 <dcoutts> ndm, care to @where-add yhc
04:27:43 <dcoutts> hi dons
04:34:38 <Megzl> Is GHC programmed in Haskell?
04:34:47 <shapr> yup
04:37:37 <shapr> I'm writing a 'webapp' in Haskell for wiki-style markup of pdf or ps documents, want to see?
04:38:32 <Megzl> Yes.
04:38:44 <shapr> cjs_: Hey, did you check out that Haskell software testing article?
04:39:07 <shapr> Here's the demo page - http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=TestMargin
04:40:53 <sieni> anybody got a link to yhc?
04:41:29 <cjs_> I did. Pretty short. :-)
04:41:35 <shapr> But it covers the essentials.
04:42:04 <shapr> Though I did leave out my test-driven-development fork of QuickCheck, and various unreleased QuickCheck extensions.
04:42:10 <cjs_> Yes. It's enough to get you to the existing documentation about it, and show you the two contrasting styles.
04:42:24 <cjs_> I'd already read a bunch of the hUnit docs before I read your article, though. :-)
04:43:25 <cjs_> But I'm currently struggling through The Haskell School of Expression, and after years of doing test-driven development, this throws me back into a very uncomfortable place.
04:44:18 <cjs_> But flipping through it a bit, I get the feeling that testing is not as important in Haskell as it is in OO programming; Haskell is more proof-oriented.
04:49:07 <cjs_> But, very sad to say, the biggest problem with HSE is that it goes way beyond my geometry. I need to go back and learn trig. again.
04:53:42 <cjs_> BTW, shapr, I'm *very* interested in web stuff using Haskell.
04:54:57 <paolino> map' function result [] = []
04:54:58 <paolino> map' function result (head:tail) = function head result (\result -> map' function result tail)
04:54:58 <paolino> map'' function list = map' (\head result continuation -> function head : continuation result) list
04:55:13 <paolino> can someone review this ?
04:58:20 <paolino> oops last line is
04:58:22 <paolino> map'' function list = map' (\head result continuation -> function head : continuation result) [] list
04:58:34 <paolino> but it lloks no clever code at all
04:59:40 <beelsebob_> @where lambdabot
04:59:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
05:00:08 <beelsebob_> @where darcs
05:00:09 <lambdabot> http://darcs.net/
05:03:28 <paolino> is there a noobie haskell channel somewhere else ?
05:04:33 <basti_> more noob than #haskell? ;)
05:05:11 <basti_> paolino: maybe you want foldr?
05:05:14 <shapr> cjs_: I'm also quite interested in web dev with Haskell. Have you heard of the web dev framework that poetix and I are designing?
05:05:28 <shapr> Megzl: What do you think of my nifty bit of software?
05:06:03 <beelsebob_> paolino: if you know how to write hello world, you're a #haskell white belt
05:06:42 <beelsebob_> hmm, I appear to be somewhere between a blue belt and a 5th dan
05:06:49 <beelsebob_> somehow I don't think I'm that high up
05:07:19 <paolino> basti_ it's the tutorial YAHT exercise asking for something which I can't really guess :)
05:07:19 <shapr> beelsebob_: You do write Haskell for a living, don't you?
05:07:36 <beelsebob_> shapr: well... I don't have to write haskell... but yeh
05:07:38 <basti_> paolino: can you give me a link so i see what you're trying to do ?
05:08:29 <paolino> YAHT chapter 4 : Write map and filter using CPS
05:09:36 <paolino> pag 67 , don't know if there is an online version of it
05:10:44 <cjs_> shapr: well, I saw a note on your blog about it.
05:11:25 <cjs_> Oh, don't say the answer here! I'm just starting chapter 4 as we speak!
05:12:35 <paolino> ther is the google translation
05:12:47 <basti_> ah
05:12:49 <basti_> hmm
05:13:43 * beelsebob_ tries to figure out how to write a man page
05:15:49 <Megzl> hey shapr.
05:16:00 <Megzl> Why is there a paper about LISP loops there?
05:17:37 <ndm> dcoutts, sorry but yhc is still not publically available
05:22:18 <Megzl> ndm, why mention it if it's vapor!
05:22:32 <ndm> Megzl: its not vapour, i have a working copy of it
05:22:39 <ndm> and it will be released soon
05:23:08 <Megzl> Is YHC specifically made for being a VM?
05:23:32 <ndm> it has a portable haskell bytecode + a virtual machine
05:23:37 <ndm> so yes, and no
05:23:41 <Megzl> Has, or is?
05:24:07 <Megzl> is that YHC's primary focus, or is it also a compiler and just happens to have a VM?
05:24:08 <ndm> yhc is a compiler that generates portable bytecode, and a runtime that runs it, and a spec as to what the bytecode is
05:24:16 <Megzl> Ok.
05:24:19 <ndm> its two entirely separate parts
05:24:24 <ndm> compiler = haskell, runtime = c
05:24:31 <Megzl> runtime?
05:24:43 <Megzl> the VM is written in C, you mean...
05:24:44 <Megzl> ?
05:25:29 <ndm> yes
05:25:51 <ndm> I guess all VM's are runtimes, but only some runtimes are VM's
05:26:05 <ndm> the VM has to be C to get the performance required
05:26:17 <ndm> although there may be a reference implementation in haskell
05:28:05 <humasect> haskell compiles to C anyway =(
05:28:37 <ndm> yes, but a C program will be faster than a haskell one
05:28:46 <ndm> if they are both written properly
05:28:58 <humasect> yeah. theory doesn't always work out
05:29:14 <humasect> was Cabal ever planned to be similar to darwinports/apt-get ?
05:29:28 <humasect> it seems quite that way by the .cabal files
05:29:29 <ndm> thats more a hackage goal, i think
05:29:35 <humasect> different?
05:29:53 <ndm> hackage uses cabal, but cabal is to setup packages, hackage is to distribute them
05:29:55 <ndm> i think...
05:30:04 <humasect> ah, right on.
05:30:28 <humasect> the meaning of "Cabal" might have foreshadowed.. if i looked it up
05:31:07 <marcot> Hello.
05:31:40 <marcot> dcoutts: I'm wondering about changing the *.package.conf.in in the source before building gtk2hs in the debian package.
05:32:13 <marcot> dcoutts: and putting there explicity the debian package name.
05:32:43 <cjs_> Ouch, that just blew my mind.
05:34:10 <shapr> Megzl: I just happened to be reading that paper on control flow.
05:34:20 <cjs_> "head []" has a type.
05:34:32 <shapr> Megzl: Would you prefer to see a paper about Haskell? :-)
05:35:21 <ndm> cjs_, of course it does
05:35:33 <ndm> it also has a return value, _|_
05:36:10 <cjs_> Yes, but *what* type is it?
05:36:23 <ndm> _|_ :: [a]
05:36:30 <ndm> no, actually _|_ :: a
05:36:36 <cjs_> Right. But what's a?
05:36:45 <ndm> polymorphic
05:36:59 <cjs_> I mean, I get it eventually, but it just struck me as a bit weird at first.
05:37:03 <ndm> if you do (head ([] :: [Int]))
05:37:14 <ndm> then (head []) :: Int
05:37:17 <cjs_> "It has a type, but I'm too lazy to tell you what it is." :-)
05:37:41 <ndm> it has a type, but because you haven't created any additional constraints on it, i'm not going to do that
05:37:56 <cjs_> That's just too cool for words.
05:38:36 <ndm> if you want to see a language where head [] is typed differently, see dependantly typed languages
05:46:36 <humasect> port of ghc-6.4 really needs perl?
05:47:04 <earthy> yes
05:47:11 <earthy> the evil mangler is written in perl
05:47:17 <b0gg1e> isnt that nice? perl6 and ghc mutually bootstrapping each other :-)
05:47:17 <earthy> and somewhat essential
05:47:59 <humasect> hmm =) ok
05:49:14 <xerox> Yow!
05:49:26 * beelsebob_ wonders how hat builds its man pages
05:49:37 <beelsebob_> it's grabbing them from somewhere other than what I just edited
05:50:18 <ndm> beelsebob_: the man folder?
05:50:36 <beelsebob_> that's what I edited, if you fiddle, those files get recreated when you make
05:50:44 <beelsebob_> I'm trying to find where they're sourced from
05:51:10 <ndm> if they are regenerated, they should not be committed
05:51:15 <Igloo> The mangler isn't essential, it's just for higher performance
05:51:28 <beelsebob_> that's true
05:51:40 <beelsebob_> oh... no... I edited ones in a different version
05:51:43 <beelsebob_> damn... deleted that
05:51:45 <beelsebob_> silly bob
05:57:30 <humasect> alright, ghc and ghc-devel both failing from darwinports. time to hack.
05:58:43 <bourbaki> moin
05:59:18 <beelsebob_> mmm... another hat-delta update
05:59:27 <xerox> @where hat
05:59:28 <lambdabot> http://www.cs.york.ac.uk/fp/hat
05:59:32 <beelsebob_> so instead of malcolm getting periodic monolithic updates
05:59:41 <beelsebob_> he now gets 6 spams a day as I commit changes
05:59:56 <beelsebob_> xerox: you'll have to use cvs to get hat-delta
06:13:16 <Megzl> shapr: How can you even understand this paper. Do you code in LISP and Scheme?
06:14:05 * cjb is reminded of a write-up from the LL1 conference.
06:14:20 <cjb>  Them: Pshaw. We solved [parrot's current] problems thirty years ago.
06:14:36 <cjb>  Us: Yes, but your solutions are unpublished, unadvertised, impossible to comprehend and applied solely to ML or Scheme.
06:14:42 <cjb>  Them: So?
06:14:46 <cjb> :)
06:15:13 <Megzl> You guys, I just can't get into Haskell -- I might if I could use it as a drop in VM for C++
06:15:25 <Megzl> but, I like C++ cause I can take it seriously
06:15:33 <shapr> I can't take C++ seriously.
06:15:58 <shapr> Programming shouldn't be that complicated. There's too much accidental difficuty in C++ for me to want to use it.
06:16:15 <Megzl> Shapr what's hard about C++ ?
06:16:16 <cjb> I take C++ seriously in the ".. and now I have *two* problems." sense.
06:16:17 <shapr> Megzl: Sure, I code in LISP and Scheme. I picked 'em up a few years ago.
06:16:42 <shapr> Megzl: Have you seen the C++ language standard?
06:16:51 <shapr> Have you ever tried to write a C++ compiler?
06:16:57 <Megzl> Sure, shapr, but it doesn't matter much to me, the standard.
06:17:21 <Megzl> No, shapr, but have you ever tried to write a Haskell compiler?
06:17:40 <musasabi> Has anyone written an utility to find some type synonyms to nicely describe the type signatures inside a module?
06:17:41 <shapr> Sure, I've made tiny emulations with lambda calculus. It's simpler than you think.
06:18:01 <Megzl> Haskell shoulda been called F
06:18:19 <xerox> GHC uses System F internally, iirc :!
06:18:23 <shapr> Look at the interpreter in lambdabot for example, it's close enough to Haskell that it fools regular users.
06:18:47 <musasabi> Inventing them by hand is quite messy as there are typically >5 free type variables and the signatures are quite long...
06:18:53 <shapr> Actually, I have a neat language I want to implement someday when I get the free time.
06:19:00 <xerox> @lambda map (+2) [1,2,3]
06:19:00 <lambdabot> (line 1, column 6):
06:19:00 <lambdabot> unexpected "+"
06:19:00 <lambdabot> expecting simple term
06:19:05 <xerox> ^_^
06:19:20 <JKnecht> lambdabot doesn't embed a Haskell compiler/interpreter?
06:19:24 <musasabi> @lambda map (\x -> x + 2) [1,2,3]
06:19:25 <lambdabot> [3, 4, 5]
06:19:27 <xerox> @lambda map (\x -> x + 2) [1,2,3]
06:19:28 <lambdabot> [3, 4, 5]
06:19:29 <xerox> Yeah.
06:19:44 <xerox> @eval map (\x -> x + 2) [1,2,3]
06:19:46 <lambdabot> [3,4,5]
06:19:56 <shapr> musasabi: Could you use the "searching type signatures by unification" papers? It sounds like you want automated type sig refactoring of some sort.
06:20:58 <musasabi> shapr: that sounds like what I am looking for. Do you know whether hare or any other tool included such functionality?
06:21:00 <xerox> @lambda S K I 1
06:21:01 <lambdabot> 1
06:21:22 <shapr> JKnecht: Yes, it does, but it also has @lambda, a lambda calculus interpreter. If you look at the definition of lambda and its defined code, you'll see how close Haskell is to pure lambda calculus.
06:22:40 <JKnecht> was in process of looking at Shea's site.
06:22:57 <shapr> Megzl: Anyway, I'd like to show you how cool Haskell can be, and how much fun you can have using it, but I don't have time right now... maybe later?
06:23:00 <shapr> Shea?
06:23:07 <xerox> Flea
06:23:15 <shapr> JKnecht: You mean that Shae Erisson guy?
06:23:20 <shapr> I've heard of him.
06:23:25 <xerox> Ah, that!  Boo.
06:23:51 <JKnecht> soryr :)
06:23:57 * xerox claps the hands after shapr
06:24:45 * shapr runs around like a scared chicken
06:24:54 <shapr> bawk bawk!
06:26:14 <JKnecht> BTW, I used to think C++ was too complex, but reviewing it earlier this year changed mind. Just right for the mature OO C.
06:26:49 <beelsebob_> shapr: yeh, I've heard he's a bit of a twat
06:26:56 <beelsebob_> *g*
06:27:01 <musasabi> C++ is nice for non-OO features. For OO things it is not very nice.
06:27:11 <musasabi> Even Haskell is a better OO language ;)
06:27:26 <shapr> beelsebob_: I've heard he just wishes for such on a regular basis.
06:27:35 <tomaszz> JKnecht: it is too complex
06:27:56 <JKnecht> twat or twit?
06:28:05 <shapr> I think the easy way to understand something is to implement it yourself!
06:28:10 <shapr> hoi goron, hoe gaat het?
06:28:19 <xerox> The Sussman's way
06:28:28 <tomaszz> JKnecht: I mean C++ is too complex IMO
06:28:45 <JKnecht> I'm agin that. Don't wanna implement no langs no mo.
06:28:47 <xerox> Later, folks.
06:29:24 <goron> shapr: hey, I am doing ok. You?
06:29:30 <shapr> Life is good!
06:29:34 * shapr bounces cheerfully
06:29:34 <beelsebob_> shapr: lol
06:29:48 * beelsebob_ bounces cheerfully with shapr
06:30:06 <shapr> Oh hey, I discovered that tennish shoes are much better for unicycling than timberlands.
06:30:20 <beelsebob_> uhhuh? I use DMs
06:30:36 <beelsebob_> the sole of any other shoe gets destroyed by my pedals
06:30:51 <shapr> DMs? wassat?
06:31:01 <shapr> Megzl: Hey, do you still think I'm nerdy? :-P
06:31:05 <beelsebob_> DocMartins
06:31:23 <shapr> Interesting idea.
06:31:32 <beelsebob_> why are you bouncing today shapr?
06:32:13 <shapr> Well, because... life is good. I'm not starving, I don't have any overdue bills, I still have some paying work to do, and I've been writing fun Haskell code the last few evenings.
06:32:36 <beelsebob_> excellent
06:32:44 <shapr> Why are you bouncing?
06:32:47 * beelsebob_ is bouncing because hat-delta is in cvs and working
06:32:51 <shapr> w00!
06:33:04 <beelsebob_> available here http://www.haskell.org/hat/cvs.html
06:33:05 <shapr> You could make the logo one of those Delta Force berets.
06:33:14 <beelsebob_> hehe... that's a stunning idea
06:33:28 <cjb> What's hat-delta?
06:33:43 <beelsebob_> cjb: it's an intelligent algorithmic debugger
06:33:51 <shapr> oooh, big words
06:33:54 <beelsebob_> it predicts where the bug is based on prior experience
06:34:01 <beelsebob_> and directs the user towards it
06:34:18 <beelsebob_> cjb: http://www.cs.kent.ac.uk/people/rpg/tatd2/ifl05.pdf
06:34:28 <beelsebob_> or... check it out of cvs and give it a try
06:35:15 * beelsebob_ wishes he had illustrator on this mac
06:35:21 <beelsebob_> then I could do the hat-delta logo
06:39:02 * goron just discovers the simplicity of nautilus :)
06:39:03 <cjb> beelsebob_: Aww, it makes you tell it where the bug is, that's no fun.
06:39:17 <beelsebob_> haha, no, it tells you where the bug is
06:39:24 <beelsebob_> you tell it if something's right or not
06:39:30 <JKnecht> does it require a correct version of an algorithm to find the bug in the erroneous one?
06:40:15 <beelsebob_> jKnecht: no
06:42:41 <JKnecht> your version includes the programmer directed navigation?
06:45:09 <beelsebob_> jKnecht: no... hat-explore does
06:45:19 <beelsebob_> the point of hat-delta is that it directs the programmer
06:52:32 <JKnecht> doesn't seem like 'cvs' is the password anymore.
06:57:21 <ndm> JKnecht: it was last week
06:58:24 <JKnecht> "Concurrent Versions System (CVS) 1.11.15"; tried case variant, different locations, etc.
06:58:52 <ndm> whats your CVS root?
07:00:17 <JKnecht> that could be it, on a new machine I haven't configured cvs for. But did try on one that was.
07:01:08 <JKnecht> on the latter it's /usr/src/cvs
07:02:30 <ndm> JKnecht: i meant your CVSROOT variable
07:04:07 <JKnecht> the same. get: 'cvs [login aborted]: connect to glass.cse.ogi.edu(129.95.44.145):2401 failed: Connection refused'
07:04:20 <ndm> JKnecht: thats easy
07:04:26 <ndm> cvs is no longer at glass.cse
07:04:35 <ndm> the server should be cvs.haskell.org
07:04:39 <ndm> it moved
07:04:46 <ndm> change your CVSROOT and it will work again
07:05:00 <JKnecht> got it. http://www.haskell.org/hat/cvs.html should be updated.
07:08:00 <ndm> beelsebob_: you have commit rights :)
07:08:05 <ndm> go fix!
07:08:14 <beelsebob_> ndm: what?
07:08:21 <ndm> http://www.haskell.org/hat/cvs.html
07:08:26 <beelsebob_> oh... I see
07:08:51 <beelsebob_> I'm not sure what repo the hat web page is in
07:08:55 <ndm> site:haskell.org glass.cse.ogi.edu -pipermail
07:09:06 <ndm> that gives 103 hits for the old cvs address!!!!
07:09:21 <beelsebob_> huh?
07:09:30 <beelsebob_> oh, I see
07:09:57 <beelsebob_> you know what repo the web page is in?
07:10:08 <ndm> @google site:haskell.org glass.cse.ogi.edu -pipermail -cvsweb
07:10:10 <lambdabot> http://www.haskell.org/nhc98/cvs.html
07:10:19 <ndm> there are about 20
07:10:28 <ndm> no idea what repo for the web page
07:10:33 <beelsebob_> ah... got it in the hat one
07:12:15 <beelsebob_> I've just commited a new version... you'll have to prod malcolm to put it online
07:16:28 <ndm> Cale: http://haskell.org/hawiki/FptoolsWithDarcs
07:16:39 <ndm> that has the wrong CVS server, and is an immutable wiki page
07:17:37 <beelsebob_> I wish they'd hurry up and update to darcs
07:18:01 <ndm> i like cvs...
07:18:18 <neologism> ndm: what do you like about cvs?
07:19:47 <ndm> neologism: tortoise cvs :)
07:20:22 <neologism> havent seen it
07:21:06 <ndm> windows only, and perfect
07:21:30 <beelsebob_> ndm: it's updated now :)
07:21:34 <neologism> I think that cvs is weak backend
07:21:45 <neologism> beelsebob_: you scared him away :)
07:21:54 <beelsebob_> :)
07:22:05 <beelsebob_> now... everyone.. check out hat
07:25:39 <Igloo> beelsebob_: Do your updates add support for things like MPTCs?
07:25:49 <beelsebob_> mptcs?????
07:26:01 <Igloo> Multi-parameter type classes
07:26:20 <beelsebob_> the hat team has a policy of not supporting non-standard haskell
07:26:57 <Igloo> A *policy* of it? Wow
07:27:11 <beelsebob_> well... everyone agrees that it's a stupid idea
07:27:28 <ValarQ> shapr: i only got two versions
07:27:29 <beelsebob_> on the grounds that we have not a clue what we're gonna have to support next
07:27:36 <syntaxfree> the syntax highlighting both in vim and the hawiki are extremely limited.
07:28:03 <beelsebob_> limited syntax highlighting is usually good syntax highlighting
07:28:05 <syntaxfree> I'd like to see at least "=" colored.
07:28:12 <beelsebob_> ... just enough to tell what's what
07:28:33 <syntaxfree> this one essentially changes colors in type definitions.
07:28:48 <syntaxfree> looky. it's over-minimal: http://www.haskell.org/hawiki/DiegoNavarro
07:29:15 <beelsebob_> yeh, that is a bit over minimal
07:29:27 <syntaxfree> I'd like equal signs colored.
07:29:33 <syntaxfree> they're the single most important symbol in Haskell.
07:29:58 <beelsebob_> this is what my highlighter does: http://www.cs.kent.ac.uk/people/rpg/tatd2/highlight.png
07:30:05 <syntaxfree> 'nyway, some input from the trenches.
07:30:28 <syntaxfree> hmm. nice.
07:30:41 <syntaxfree> I'm an os x user too. What's that editor?
07:30:48 <beelsebob_> SubEthaEdit
07:30:49 <xerox> beelsebob_: maybe you could highlight the types too?
07:31:00 <beelsebob_> xerox: only built in ones
07:31:06 <tomaszz> syntaxfree: did you set any hs_highlight_* flags?
07:31:17 <xerox> beelsebob_: it is not extensible?
07:31:18 <beelsebob_> it's a single pass regexp, so anything that needs gathering info is out
07:31:49 <xerox> Words starting with a capital letter?
07:32:03 <beelsebob_> syntaxfree: editor here http://www.codingmonkeys.de/ my highlight mode here http://www.dusoft.co.uk/freebies.php
07:32:09 <beelsebob_> xerox: probably
07:32:13 <beelsebob_> let me play a second
07:32:21 * beelsebob_ wonders what colour
07:33:01 <syntaxfree> beelsebob: thanks :)
07:33:10 <beelsebob_> np
07:34:05 <syntaxfree> oh. free for noncommercial use too :)
07:34:18 <xerox> Emacs?
07:35:10 <beelsebob_> no... SEE
07:35:21 <beelsebob_> what colour should types be by default?
07:35:23 <xerox> hIDE!
07:35:27 <xerox> @where hIDE
07:35:28 <lambdabot> http://www.haskell.org/hawiki/hIDE
07:35:37 <syntaxfree> I'm a vimmie.
07:35:46 <syntaxfree> But really, the Mac way of doing things is addictive.
07:35:54 <syntaxfree> I do all my text editing with TeXShop nowadays.
07:36:07 <syntaxfree> It's the only way to live :)
07:36:30 <beelsebob_> syntaxFree: I use SEE for TeX too
07:36:52 <Maddas> I switched to using Emacs for editing and TeXShop for 'compiling' TeX since TeXShop got annoying for editing :-)
07:36:55 <xerox> OSX weenies ;)
07:37:08 * Maddas should try SEE someday
07:37:14 <syntaxfree> why is TeXShop annoying?
07:37:31 <Maddas> It isn't, I just found it annoying to use TeXShop to edit things
07:38:01 <Maddas> I also didn't manage to get it look as nice as I find my Emacs layout (fonts, etc.).
07:38:13 <syntaxfree> I just use Futura.
07:38:16 <Maddas> And all the editing shortcuts which make things easier :-)
07:38:42 <Maddas> Although TeXShop certainly is very nifty.
07:39:45 <ValarQ> oh, Megzl is back
07:39:45 * beelsebob_ wonders why this isn't highlighting anything
07:39:50 * ValarQ waves at Megzl 
07:41:44 <Maddas> syntaxfree: I think it may be the antialiasing done that I don't like, not the fonts themselves. I never figured out what exactly it is, but something annoys me :-)
07:42:59 <syntaxfree> oh, goody.
07:43:15 <syntaxfree> SubEthaEdit seems a lot faster than TextWrangler too.
07:44:30 <cjb> syntaxfree: seen Gobby?
07:45:03 <syntaxfree> nope.
07:45:26 <syntaxfree> the little widget on top that's supposed to be telling you what function you're editing in SEE is broken by Haskell.
07:45:26 <cjb> http://gobby.0x539.de/
07:45:35 <syntaxfree> But that isn't at all important :)
07:45:48 <beelsebob_> xerox: give me a regexp that won't match against the second half of doSomething
07:46:59 <syntaxfree> cjb: one word: GTK.
07:47:09 <beelsebob_> syntax: how is it broken?
07:47:11 <beelsebob_> it works for me
07:47:27 <beelsebob_> oh... it's broken if you don't have type definitions
07:47:32 <syntaxfree> beelsebob: it reflects the immediately-before type declaration.
07:47:39 <syntaxfree> not the function itself.
07:47:44 <beelsebob_> yes... which *should* be the function
07:48:04 <syntaxfree> I declare all my types at the beginning of the program, or in blocks.
07:48:15 <syntaxfree> I usually think of type before I think of how to write the function.
07:48:22 <beelsebob_> it can't find the function, because the patern [a-zA-Z-0-9]*[:whitespace:]*= appears all over the place
07:48:40 <beelsebob_> but declaring types at the beginning makes ghc have a fit
07:48:54 <beelsebob_> you have to declare it immediately before the function, or ghc baulks
07:49:03 <syntaxfree> I haven't had any problems yet. But I haven't written > 100 LOC stuff yet either.
07:49:34 <beelsebob_> fair enough
07:49:43 <xerox> [A-Z]\w+ ?
07:50:25 <beelsebob_> xerox: that'll highlight as do<highlight Starts>Something<highlight ends> for the function doSomething
07:50:40 <xerox> \S[A->]\w+
07:50:46 <beelsebob_> what does \S do?
07:50:50 <syntaxfree> hmm. annoying. after a while, a watermark saying "Licensed noncommerciall" appears on the SEE window.
07:50:55 <syntaxfree> That makes reading harder.
07:51:03 <beelsebob_> syntaxfree: yeh... you need to click the window
07:51:04 <xerox> Non-string connecting piece?
07:51:18 <beelsebob_> xerox: indeed... what's the grep for that
07:51:19 <xerox> Or whatever is called.
07:51:33 <xerox> grep?
07:51:38 <beelsebob_> and also... that'll do <highlight>(Int</highlight>)
07:51:45 <beelsebob_> which looks dumb
07:52:07 <xerox> Nope, it will not match the paren
07:52:17 <beelsebob_> yes it will... I just did it
07:52:25 <xerox> Hmm.
07:52:29 <beelsebob_> the parenthesis is part of the patern
07:52:39 <beelsebob_> it's part of the non string connecting piece
07:52:43 <xerox> Using \( \) ?
07:52:55 <beelsebob_> it'll still be part of the match
07:53:23 <xerox> It doesn't make sense to not be able to match things in some context, without match the context itself.
07:53:38 <beelsebob_> yeh, I know... I've filed a bug report to let you do it
07:53:42 <syntaxfree> regexps :P
07:54:34 <syntaxfree> Regular expressions correspond to the type 3 grammars of the Chomsky hierarchy and may be used to describe a regular language.
07:55:06 <neologism> syntaxfree: I am just studying this stuff... having headache from it :0
07:55:27 <rep> :0
07:55:28 <syntaxfree> formal linguistics?
07:55:46 <neologism> kind of
07:55:49 <neologism> theoretical informatics
07:55:54 <neologism> and this is part of it
07:56:04 <neologism> just trying to remember what is the funcking kleen's algebra
07:56:06 <syntaxfree> my gf studied theoretical linguistics
07:56:22 <neologism> did it affect her sexual performance? :)
07:56:27 <syntaxfree> haha.
07:56:28 <rep> heehee
07:56:42 <neologism> I am worried about mine :)
07:56:45 <neologism> this course is going to kill me
07:56:52 <syntaxfree> I'm very happy in  that department, thank you very much :)
07:56:56 <Maddas> being dead sure is bad for your sexual performance :-)
07:57:16 <neologism> what makes you think so? :)
07:57:18 <xerox> It's even more difficult than just that regexp.
07:57:22 <xerox> Ah, he has gone.
07:58:19 <xerox> Regexps-based highlighting sucks.
07:58:36 <Maddas> Yup
07:58:50 * syntaxfree is going for lunch.
07:58:54 * boegel leaves for home
07:59:43 <neologism> xerox: how can you do syntax highlighting otherwise?
08:00:02 <xerox> neologism: semantically!
08:00:23 <neologism> it also requires lexical analyse
08:00:28 <xerox> hIDE does it, via ghc-api, yeah.
08:00:29 <neologism> (ie. regexp macthing)
08:01:08 <xerox> Stateful parsers (which many people said more or less everything about) are kinda better than regexps.
08:01:42 <neologism> chomsky2 is a superset of chomsky3
08:01:52 <neologism> anyway - time to go back to studying math
08:02:08 <xerox> What does it mean?
08:02:19 <rep> gl hf neologism
08:02:19 <neologism> what?
08:02:31 <xerox> The chomskyN sentence
08:02:33 <neologism> rep: its not funny (axiomatic base of logic)
08:02:43 <rep> well gl then
08:02:52 <neologism> xerox: that chomsky2 languages includes chomsky3 languages
08:03:22 <xerox> Is that an argument about the regexp discussion?
08:03:30 <neologism> should have been ;)
08:04:31 <xerox> I think doing synhl the Right Way it's like Maddas' problem.
08:08:10 <Maddas> huh? I'm innocent!
08:08:49 <xerox> How's the Chess Monad going?
08:08:58 * Maddas whistles
08:09:03 <xerox> !
08:09:33 <Maddas> fine, but I'm procastrinating instead of doing the final parts to get a viewer program :-)
08:09:53 <Maddas> (apart from the UI)
08:10:02 <xerox> What does remain?
08:10:10 * dcoutts_ is pleased to see that xerox is advertising hIDE
08:10:19 * dcoutts_ goes to get some tea
08:10:20 * xerox wants hIDE now!
08:10:27 <xerox> ah-ha, just got it here :-D
08:12:15 <dcoutts_> xerox, oh you got hIDE to build?
08:12:18 <Maddas> :-)
08:12:30 * dcoutts_ wants to release Gtk2Hs 0.9.10 by the end of the month
08:12:33 <xerox> last time I couldn't make it starting
08:12:43 <xerox> Ah, dcoutts, many things to ask you have I!
08:13:18 <dcoutts_> xerox, notice you speaking like yoda have I
08:13:36 <xerox> Intentional was it, yound padawan
08:13:38 <xerox> *g
08:13:51 <dcoutts_> yes master
08:13:56 <xerox> ^_^
08:14:04 <xerox> I saw the discussion about names in cairo.
08:14:09 <dcoutts_> ah yes
08:14:19 <xerox> It's ok now, about rectangle?
08:14:28 <dcoutts_> do you think we're doing the right thing?
08:14:41 <dcoutts_> it's for the gtk/cairo integration functions
08:15:01 <dcoutts_> one of them clashes with the cairo version when we use the short form
08:15:08 <xerox> Yeah :-\
08:15:15 <dcoutts_> cairo_rectangle() vs gdk_cairo_rectangle()
08:15:36 <xerox> So gdk will be commented out?
08:15:36 <dcoutts_> but gdk_cairo_rectangle is so simple as to be pointless, so we can just leave it out
08:15:45 <xerox> Good enough
08:15:49 <dcoutts_> yep, that's what we'll do
08:15:57 <dcoutts_> we want to keep the unprefix form for cairo functions.
08:15:59 <ValarQ> dcoutts_: is there functions specifik to the gdk backend?
08:16:10 <xerox> I'd like to unprefix them too
08:16:38 <dcoutts_> ValarQ, gdk/gtk provides some functions to make integrating with cairo easier
08:16:48 <ValarQ> dcoutts_: ok
08:16:57 <xerox> dcoutts, talking about hide, I can't compile ghc-api :-\
08:17:02 <dcoutts_> ValarQ, in this case the rectangle thing is to convert a GdkRectangle struct to the form used by cairo.
08:17:14 <dcoutts_> xerox, you get unknown exception?
08:17:15 <ValarQ> dcoutts_: shouldn't that be handled similar to opengl in gtk?
08:17:22 <xerox> dcoutts_: right :-(
08:17:28 <dcoutts_> ValarQ, how do you mean?
08:18:06 <dcoutts_> xerox, you need to hack cabal to not depend on the util package
08:18:12 <ValarQ> dcoutts_: well, making as little platform specific code as possible
08:18:23 <ValarQ> dcoutts_: (maybe it's as good as it gets...)
08:18:25 <xerox> Oh.
08:18:30 <xerox> cd ../cabal
08:18:33 <xerox> oops :)
08:18:39 <dcoutts_> xerox, ie re-install cabal but edit the cabal.cabal file to remove the build-depends on util
08:18:47 <xerox> Yeah
08:18:57 <xerox> Should I do any modifications to the sources?
08:18:59 <ValarQ> btw, where is the cairo bindings located?
08:19:06 <dcoutts_> xerox, you'll need to do "./Setup.lhs configure" again after editing the .cabal file
08:19:19 * ValarQ would like to use cairo in a program of his
08:19:22 <dcoutts_> ValarQ, darcs get http://haskell.org/gtk2hs/darcs/gtk2hs/
08:19:57 <dcoutts_> ValarQ, that's the latest versin, there have been some changes lately so if oy uhave any problems building it then ask me
08:20:21 <dcoutts_> ValarQ, the gdk/cairo functions are not platform specific
08:20:25 * xerox builds cabal (-util)
08:20:32 <ValarQ> dcoutts_: thanks
08:20:42 <xerox> ValarQ: which program is yours?
08:20:58 <ValarQ> dcoutts_: is there cairo functions that could (practicaly or theoriticaly) be used for say the pdf backend?
08:21:07 <ValarQ> xerox: a g-code generator
08:21:39 <dcoutts_> xerox, what's going on with the ps/pdf cairo backends?
08:21:47 * xerox checks
08:21:49 <dcoutts_> xerox, we should get them working
08:22:23 <dcoutts_> xerox, it depends of course if the cairo on the users machine has the pd/pdf backends enabled
08:22:34 <ValarQ> dcoutts_: thats why i was curious about the function naming
08:22:46 <ValarQ> dcoutts_: ("rectangle" can sound quite general)
08:22:56 <xerox> dcoutts_: yeah.  I think my cairo isn't built with ps/pdf support, or it's still not functional.
08:23:14 <xerox> Do you see it in cairo-features.h ?
08:25:21 * xerox hugs dcoutts
08:25:32 <xerox> ghc-api is building!  How did you find 'util' was the problem?
08:25:53 <dcoutts_> xerox, JaffaCake found it
08:26:08 <xerox> hail to the masters
08:26:21 <dcoutts_> xerox, it was a bug in ghc that made it throw an exception when printing the error message
08:26:54 <dcoutts_> and then once we found the propper error message then we found it was cabal depending on the old util package that was causing problems
08:27:00 <ValarQ> dcoutts_: does autoconf/make work good for haskell programs?
08:27:03 <xerox> Ah-ha!
08:27:54 <dcoutts_> ValarQ, autoconf is not too bad. automake is terrible for Haskell (though Gtk2Hs uses both)
08:28:02 <kolmodin> hey guys, I got a few lines of code from a friend and I can't find what's going wrong. http://www.dtek.chalmers.se/~lidholm/haskell.hs
08:28:03 <dcoutts_> ValarQ, try Cabal.
08:28:38 <kolmodin> the 'showHex' function yeilds a *** Exception: divide by zero
08:28:45 <xerox> heh
08:29:06 <ValarQ> dcoutts_: oh, i'm not in the need of any, i was just curious :)
08:30:31 <xerox> dcoutts_: we'll get (hopefully) ps/pdf backends in cairo 1.2
08:31:11 <xerox> ghc-api compiled and installed.  hIDE building.
08:31:38 <xerox> mozembed-any...
08:31:42 <xerox> Is it really needed?
08:32:58 <dcoutts_> xerox, the mozembed is only needed by the hIDE html viewer component
08:33:21 <dcoutts_> xerox, if you don't want to install gtk2hs with mozembed then don't build the html viewer plugin
08:33:36 <dcoutts_> kolmodin, I can't figure out what's going on
08:34:15 <kolmodin> dcoutts_: me neither :(
08:34:32 <dcoutts_> kolmodin, it makes a difference if it's Int vs. Integer
08:34:49 <xerox> In the end, is hIDE usable, as now?
08:35:00 <dcoutts_> xerox, hmm, probably not yet
08:35:16 <{Arias}> hello
08:35:23 <xerox> Howdy {Arias}
08:35:23 <ValarQ> {Arias}: hi
08:35:29 <xerox> dcoutts_: what does remain to do?
08:35:31 <{Arias}> :)
08:36:16 <dcoutts_> xerox, quite a bit I expect. I've not tried dons's latest Yi patches though
08:36:26 <dcoutts_> kolmodin, look at this...
08:36:30 <kolmodin> dcoutts_: I've typed everything to be Int, still doesn't work
08:36:30 <dcoutts_> @eval [((mod 4 (16 ^ i)) `div` (16 ^ (i-1))) :: Integer | i <- [8,7..1]]
08:36:46 <lambdabot> [0,0,0,0,0,0,0,4]
08:36:52 <dcoutts_> @eval [((mod 4 (16 ^ i)) `div` (16 ^ (i-1))) :: Int | i <- [8,7..1]]
08:37:05 <lambdabot> divide by zero
08:37:05 <lambdabot>  
08:37:20 <dcoutts_> kolmodin, it'll be because you're getting overflow with (16 ^ (i-1))
08:37:33 <dcoutts_> and so you end up dividing by 0
08:37:41 <xerox> @eval pow 16 8 :: Int
08:37:46 <lambdabot>  Not in scope: `pow'
08:37:55 <xerox> @eval 16^8 :: Int
08:37:57 <lambdabot> 0
08:38:00 <xerox> @eval 16^8 :: Integer
08:38:01 <lambdabot> 4294967296
08:38:08 <kolmodin> right
08:38:11 <xerox> @karma+ dcoutts
08:38:12 <lambdabot> dcoutts's karma raised to 4.
08:38:16 <kolmodin> :D
08:38:59 <kolmodin> dcoutts_: ok, thanks a lot, I'll tell him
08:39:16 <xerox> @eval 16^7 :: Int
08:39:17 <lambdabot> 268435456
08:40:24 <dcoutts_> @eval 16^8 :: Int
08:40:25 <lambdabot> 0
08:40:38 <dcoutts_> there's your div by 0 error
08:40:56 <dcoutts_> hi SyntaxNinja
08:42:37 <glguy> Out of curiosity, if I compile a program with GHC, can I execute said program on a different machine without having GHC installed (same platform of course)
08:42:53 <Lor> Yeah.
08:43:06 <glguy> Because it translates to C first?
08:43:15 <Lor> E.g. you can install the darcs binary on a debian machine without having any haskell development packages.
08:43:27 <SyntaxNinja> 'morning
08:43:28 <glguy> sweet
08:43:54 <SyntaxNinja> glguy: no, because the binary doesn't require any source code.
08:48:47 <glguy> I'd like to specify some parameters on my output (floating precision, line breaks) any suggestions on what I should be reading to learn how to do this?
08:50:54 <syntaxfree> any standard prelude function that will take two floating-point numbers and return the integer part of their division?
08:51:47 <thedward> @pl round (5.6 / 2.75 )
08:51:48 <lambdabot> round (5 . 6 / 2 . 75)
08:51:53 <dcoutts_> @eval floor (7.3 / 2.1)
08:51:54 <lambdabot> 3
08:51:54 <thedward> @eval round (5.6 / 2.75 )
08:51:56 <lambdabot> 2
08:51:59 <syntaxfree> that does it.
08:51:59 <xerox> 1
08:52:02 <xerox> *boom*
08:52:02 <syntaxfree> thanks :)
08:52:09 <thedward> what he said
08:52:20 <syntaxfree> @eval ceiling ((log 129)/(log 2))
08:52:22 <lambdabot> 8
08:52:26 <syntaxfree> goodie!
08:52:32 <syntaxfree> @type celing
08:52:33 <lambdabot> bzzt
08:52:36 <glguy> right, but I want 1.1234 instead of 1.12341424352342342, or example
08:52:52 <xerox> glguy: why?
08:52:56 <syntaxfree> glguy multiply by 10.000, take the integer part, then divide.
08:53:39 <syntaxfree> roundto n precision = (floor (10**precision * n))/precision
08:53:55 <syntaxfree> @eval (floor (10**5 * pi))/5
08:53:56 <glguy> xerox: Because when I'm trying to display a matrix of size 5x5, and the approximation of 0 that I return is ten characters long
08:53:56 <lambdabot> 1:1-5
08:53:56 <lambdabot>   Probable fix: add a type signature that fixes these type variable(
08:53:56 <lambdabot> s)
08:54:00 <glguy> it gets ugly
08:54:13 <glguy> but I don't care that the number is 0.342414434251435213541234e-19
08:54:21 <syntaxfree> @eval pi
08:54:23 <lambdabot> 3.141592653589793
08:54:38 <syntaxfree> @eval (floor (10^5 * pi))/10^5
08:54:39 <lambdabot> Ambiguous type variable `a' in the constraints
08:54:56 <syntaxfree> @eval (floor (100 * pi))/100
08:54:57 <lambdabot> 1:1-5
08:54:57 <lambdabot>   Probable fix: add a type signature that fixes these type variable(
08:54:57 <lambdabot> s)
08:55:01 <syntaxfree> help!
08:55:02 <thedward> ( read ( take 5 ( show ((log 129)/(log 2)) ) ) ) :: Double
08:55:07 <thedward> @eval ( read ( take 5 ( show ((log 129)/(log 2)) ) ) ) :: Double
08:55:08 <lambdabot> 7.011
08:55:17 <syntaxfree> good one.
08:55:21 <xerox> Slow one?
08:55:28 <syntaxfree> I still wanna use floor, though.
08:55:31 <syntaxfree> :t floor
08:55:35 <xerox> bzzt
08:55:47 <syntaxfree> ah.
08:55:49 <syntaxfree> @type floor
08:55:50 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:56:01 <thedward> floor will only give an integer though
08:56:04 <syntaxfree> @eval floor (314.5)
08:56:06 <lambdabot> 314
08:56:08 <syntaxfree> ahh, yes.
08:56:23 <syntaxfree> @eval fromIntegral((floor (10^5 * pi)))/10^5
08:56:25 <lambdabot> 3.14159
08:56:32 <syntaxfree> there you are,glguy.
08:56:56 <syntaxfree> roundto number precision = fromIntegral(floor(10^precision * number)) / (10^precision)
08:57:04 <shapr> ValarQ: Can I see your versions?
08:57:06 <xerox> @pl \n x -> fromIntegral $ floor (n * x) / n
08:57:07 <lambdabot> (fromIntegral .) . (flip =<< (((/) . floor) .) . (*))
08:57:11 <xerox> @pl \x n -> fromIntegral $ floor (n * x) / n
08:57:12 <lambdabot> (fromIntegral .) . join . (((/) . floor) .) . (*)
08:57:17 <xerox> Bah :D
08:57:58 <syntaxfree> @let roundto number precision = fromIntegral(floor(10^precision * number)) / (10^precision) in roundto pi 3
08:57:59 <lambdabot> Unknown command, try @listcommands.
08:58:11 <syntaxfree> @eval let roundto number precision = fromIntegral(floor(10^precision * number)) / (10^precision) in roundto pi 3
08:58:12 <lambdabot> 3.141
08:58:14 <ValarQ> shapr: sure
08:58:27 <syntaxfree> glguy: there you are :)
08:58:44 <ValarQ> shapr: should i fix the other issues with the first version?
08:58:53 <glguy> cool, thnx
08:59:11 <glguy> I imagine that I'd have been able to do that myself, I was just trying not to duplicate work if it was in a library somewhere :)
08:59:12 <ValarQ> shapr: so that only the randomfunction differs
08:59:23 <glguy> but I do appreciate the assistance :)
09:04:07 <syntaxfree> @type f x = x+1
09:04:08 <lambdabot> bzzt
09:04:27 <glguy> @eval 2**4
09:04:28 <lambdabot> 16.0
09:04:29 <glguy> @eval 2^4
09:04:31 <lambdabot> 16
09:04:33 <thedward> @type (\x -> x + 1 )
09:04:34 <lambdabot> forall a. (Num a) => a -> a
09:04:38 <syntaxfree> hmm sure.
09:04:40 <syntaxfree> idiot :)
09:04:54 <syntaxfree> now I forgot how to do a lambda expression with two variables.
09:05:00 <syntaxfree> @type (\a b->a+b)
09:05:01 <xerox> Don't insult lambdabot! :(
09:05:01 <lambdabot> forall a. (Num a) => a -> a -> a
09:05:02 <xerox> @botsnack
09:05:03 <lambdabot> :)
09:05:03 <thedward> @type (\x y -> x + y )
09:05:04 <lambdabot> forall a. (Num a) => a -> a -> a
09:05:14 <syntaxfree> ok.
09:05:29 <syntaxfree> @type (\n b->let s = ceiling((log n)/(log b)) in [mod n (b^i) `div` (b^(i-1)) | i<-[s,s-1..1]])
09:05:30 <lambdabot> forall a. (RealFrac a, Integral a, Floating a) => a -> a -> [a]
09:05:47 <ValarQ> shapr: http://arda.no-ip.org/markov.hs http://arda.no-ip.org/nmarkov.hs
09:05:52 <syntaxfree> @eval let rebaser = (\n b->let s = ceiling((log n)/(log b)) in [mod n (b^i) `div` (b^(i-1)) | i<-[s,s-1..1]]) in rebaser 7 2
09:05:53 <lambdabot> Ambiguous type variable `a' in the constraints
09:06:04 <shapr> ValarQ: spiffy, thanks.
09:06:16 <syntaxfree> @type log
09:06:17 <lambdabot> forall a. (Floating a) => a -> a
09:06:35 <syntaxfree> hmm. Is log not defined for integrals somehow, or does Floating contain Integral?
09:07:14 <ValarQ> shapr: maybe the makeText in the first version could have been done better, i learned quite a lot while writing the second
09:08:16 * beelsebob_ touts hat-delta some more
09:10:26 <xerox> toout tooout
09:12:07 <syntaxfree> grrrrr
09:12:26 <ndm> beelsebob_: but does it have a gui ;)
09:12:46 <beelsebob_> ndm: no... why on eorth would you want one of them for a simple question and answer process
09:13:11 <ndm> does it have a window at the bottom that shows the source code?
09:13:28 <beelsebob_> no... why would you want one when you can just load it in your fravourite editor?
09:13:44 <ndm> so it really *is* just a simple question answer thing
09:13:55 <ndm> not an olaf super-tool
09:14:07 <beelsebob_> no... olaf's super tool lets you chose where to go
09:14:19 <beelsebob_> mine enforces a rigid dictatorship
09:14:26 <ndm> how hard would it be to slap a gui on it then
09:14:29 <ndm> if its really that simple
09:14:41 <ndm> i was going to start with hat-cover
09:15:10 <beelsebob_> but... what would the gui do that the text interface didn't?
09:15:22 <xerox> "please ndm"
09:15:58 <ndm> nothing
09:16:00 <xerox> ;)
09:16:02 <ndm> but it would be nice
09:16:21 <ndm> what does haskell do that c doesn't?
09:16:38 <xerox> Avoid making your head hurt in many cases
09:16:48 <ndm> exactly, and the same with console tools
09:16:49 <spiffy> id go for some ;-)
09:16:59 <xerox> heh.
09:17:13 * xerox got pwned
09:17:29 <ndm> beelsebob_: since no one else wants to, i guess i'm going to have to gui-ify the tools myself
09:17:35 <ndm> hat-cover first
09:17:40 <ndm> then your one possibly
09:17:49 <xerox> ndm: which toolkit are you gonna use?
09:17:53 <beelsebob_> ndm: make sure you put a generic gui layer inbetween
09:18:02 <beelsebob_> so that different toolkits can be used
09:18:06 <ndm> beelsebob_: i will, hopefully i'll abstract as much as possible
09:18:11 <beelsebob_> :)
09:18:16 <ndm> and make console just one gui toolkit
09:18:22 <ndm> xerox, gtkhs or wxhaskell
09:18:30 <ndm> (and i know which one you're going to pimp)
09:18:38 * xerox boings happily
09:18:49 <ndm> whichever one has a yhc port first :)
09:18:53 <beelsebob_> ndm: what do you think of "Two rights do make a wrong" as a title for my paper?
09:19:07 <ndm> clever
09:19:15 <xerox> beelsebob_: what's the paper about?
09:19:18 <ndm> although isn't it one right and one wrong makes a diagnosis
09:19:23 <beelsebob_> xerox: delta debugging
09:19:32 <beelsebob_> ndm: it's one right makes a wrong really isn't it
09:19:40 <beelsebob_> I did have a clever idea for an extension though
09:19:49 <ndm> which is?
09:19:50 <beelsebob_> that would get me the paper "Two wrongs do make a right"
09:19:59 <beelsebob_> which would rock
09:20:18 <ndm> beelsebob_: how well written is hat-cover?
09:20:27 <beelsebob_> ndm: ask Colin
09:20:28 <ndm> i mean hat-delta
09:20:38 <beelsebob_> it's absolutely fucking beautiful
09:20:43 <ndm> :)
09:20:46 <beelsebob_> :)
09:20:56 <beelsebob_> as is hat-detect now
09:21:04 <beelsebob_> it's not well commented though
09:21:07 <beelsebob_> I'm working on that
09:21:15 <ndm> comments are for people who can't write nice code :)
09:21:16 <beelsebob_> which is why I want haddock and hmake to play nice
09:21:23 <ndm> cabal....
09:21:26 <ndm> and we can kill hmake
09:21:29 <paolino> sorry, why return 1 is legal ?Which monad gets it ?
09:21:36 <beelsebob_> yeh... but then I have to rewrite the makefiles
09:21:39 <beelsebob_> and I'm shit at that
09:21:41 <ValarQ> ndm: damn, i forgot the comments then :(
09:21:57 <ndm> paolino: return is polymorphic, depends what monad you are in
09:22:02 <xerox> Hi paolino!
09:22:06 <xerox> paolino: whatever!
09:22:12 <xerox> @type return
09:22:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
09:22:21 <paolino> I'm in the interpreter
09:22:27 <paolino> command line of ghci
09:22:41 <lisppaste2> syntaxfree pasted "help?" at http://paste.lisp.org/display/12610
09:22:45 <xerox> paolino: ...and?
09:22:59 <paolino> where I am ?
09:23:03 <ndm> Hugs> :t return 1
09:23:06 <ndm> return 1 :: (Monad a, Num b) => a b
09:24:02 <paolino> :t
09:24:46 <xerox> The monad to use is inferred from the context
09:24:48 <ndm> ask for the type of something
09:27:15 <paolino> why is :t (return 1) so different from :t (return 1::Int) ?
09:27:15 <paolino> [Int] I should write sorry
09:27:53 <xerox> @type return 1 :: [Int]
09:27:54 <lambdabot> [Int] :: [Int]
09:28:03 <syntaxfree> :~
09:28:11 <xerox> Here, m = list.
09:29:09 <Igloo> You can write [Int] as [] Int
09:30:02 <xerox> @type [1..] :: [] Integer
09:30:03 <lambdabot> [] Integer :: [Integer]
09:30:07 <xerox> Right on!
09:30:39 <paolino_> :/
09:30:54 <xerox> paolino_ did you read the answers?
09:31:00 <paolino_> nothing
09:31:05 <Igloo> You can write [Int] as [] Int
09:31:25 <xerox> So the list, [], is the monad used, in return 1 :: [Int]
09:31:31 <Igloo> i.e. a -> [], b -> Int
09:32:25 <paolino_> mmhh
09:32:26 <xerox> (It's more sane to use 'm' as the monad type-variable, usually)
09:32:47 <araujo> Hello!
09:32:49 <paolino_> Prelude> :t (return 1::[Int])
09:32:54 <paolino_> (return 1::[Int]) :: [Int]
09:33:00 <xerox> Hi, araujo!
09:33:04 <araujo> Hello xerox !
09:33:06 <ndm> paolino_: are you a complete beginner?
09:33:08 <xerox> paolino_: yeah, what's wrong with that?
09:33:09 <araujo> How things go?
09:33:17 <ndm> if so, you probably want just 1, not return 1
09:33:20 <xerox> araujo: pretty well, what about you?
09:33:26 <marcot> dcoutts: are you there?
09:33:27 <paolino_> ndm yes
09:33:39 <paolino_> on monads specially
09:33:44 <ndm> paolino_, haskell is unlike C/Java/Javascript, no need to put return
09:33:47 <araujo> xerox, very fine, just got back from univ and very hungry :-]
09:33:50 <ndm> and no need to use monads most of the time
09:34:00 <ndm> just 1 is a function which returns 1
09:34:02 * araujo next to read a bit about monads too
09:34:22 <paolino_> ndm, my question is really about return 1 :)
09:34:32 <paolino_> Prelude> :t (return 1)
09:34:33 <xerox> paolino_: what's the question?
09:34:33 <paolino_> (return 1) :: (Monad m, Num a) => m a
09:34:46 <paolino_> I see type inference here
09:34:54 <paolino_> or I'm wrong
09:34:59 <xerox> It is a polymorphic type.
09:35:01 <dcoutts_> marcot, hello
09:35:09 <basti_> paolino_: when you say return 1::[Int], then you already gave the whole type.
09:35:23 <xerox> Right.
09:35:35 <paolino_> why didn't tell me [] is a monad ?
09:35:58 <basti_> uhm. well. i was just beginning .)
09:36:00 <marcot> dcoutts_: Hi! Have you read my messages for you sometime ago?
09:36:05 <xerox> paolino_: that's what Oejet meant before.
09:36:10 <xerox> paolino_: think m = [].
09:36:17 <marcot> dcoutts_: I'm dividing gtk2hs in some packages, one for each ghc package.
09:36:18 <xerox> @type return 1 :: [] Int
09:36:19 <lambdabot> [] Int :: [Int]
09:36:36 <xerox> Oops, it was Igloo, not Oejet :D
09:36:39 <xerox> (Sorry)
09:36:56 <marcot> dcoutts_: so I'll install it in a lot of different directories, such as /usr/lib/libghc6-gtk-dev/ /usr/lib/libghc6-glib-dev
09:37:17 <marcot> dcoutts_: The way I find to do this is a patch in the .package.conf.in files, with:
09:37:41 <marcot> +import-dirs: $libdir/libghc6-sourceview-dev/imports
09:37:41 <marcot> +library-dirs: $libdir/libghc6-sourceview-dev
09:37:53 <marcot> In each file with the respective package name.
09:38:16 <dcoutts_> seems reasonable
09:38:17 <paolino_> basti_ I was meaning  'he' the type inferrer not you ://
09:38:47 <basti_> ah
09:39:04 <dcoutts_> marcot, I'm sorry we don't make that easier
09:39:14 <paolino_> I should start using 'it' sooner or later
09:39:20 <basti_> well the inferrer does, in certain situations, just very subtle, as it is his way
09:39:36 <basti_> "it"?
09:39:41 <basti_> the inferrer?
09:39:44 <paolino_> the inferrer
09:39:47 <paolino_> :)
09:39:56 <dcoutts_> marcot, are there any other problems?
09:40:04 <basti_> its about understanding error messages. thats the harder, the harder the message is, obviously
09:40:12 <marcot> dcoutts_: no, this is the only one..
09:40:13 <basti_> haskell error messages can be very hard
09:40:25 <sethk> the inferred is like the shadow
09:40:34 <marcot> dcoutts_: I don't know if there's a way of the upstream be better for debian packaging.
09:40:46 <marcot> dcoutts_: but if you have any ideas, please talk to me.
09:40:48 <basti_> i always refer to verse 11 of the tao te king concerning that...
09:41:07 <paolino_> ?
09:41:33 <basti_> "Take advantage of what is, turn existing into a great advantage: just make as much as you can out of it here.
09:41:37 <basti_> Feel free to recognise the possible usefulness of whats not yet here. Prosper by clever use of something not yet."
09:41:42 <basti_> http://home.pages.at/onkellotus/TTK/English_Byrn_TTK.html#Kap11
09:42:07 <dcoutts_> marcot, hopefully it'll be better when we move to using cabal
09:42:12 <basti_> [more a #h-blah topic though]
09:42:33 <dcoutts_> marcot, I hadn't anticipated you wanting to have that kind of directory layout
09:42:55 <dcoutts_> marcot, I'd assumed $libdir/gtk2hs/{glib,gtk,etc}
09:42:58 * paolino_ is laughing in spite his situation
09:43:46 <xerox> paolino_: feel free to ask any kind of question, at any rate :D
09:44:03 <marcot> dcoutts_: that layout is the debian standard for ghc packages.
09:44:53 <paolino_> getChar >>= print this is my first monadic program
09:45:26 <basti_> woah :D
09:45:33 <basti_> now in do layout
09:45:50 <xerox> Good!
09:46:39 <paolino_> do {x <- getChar;print x}
09:46:48 <xerox> Right on
09:47:06 <xerox> Try writing cat.hs ?
09:47:24 <paolino_> not really
09:47:38 <paolino_> I'm alone with the type inferrer
09:47:49 <basti_> is it cuddly at least?
09:47:55 <xerox> 3.. 2.. 1.. fight!
09:48:30 <xerox> Ahah.
09:50:09 <dcoutts_> marcot, I'll bear that in mind
09:50:24 <paolino_> basti_ cuddly not found
09:50:36 <basti_> :/
09:51:03 <marcot> dcoutts_: anyway, I don't think that the upstream version should handle it. It would be good to have a nice way to change the /usr/lib/name directory for each package.
09:52:07 <dcoutts_> marcot, well the problem is that upstream in this case considers gtk2hs to be one pagkage (sortof) and so sticks everything under one prefix. But you consider it to be many packages.
09:52:25 <dcoutts_> marcot, I'll be better wehn we use cabal. Since then it really will be seperate packages.
09:54:26 <marcot> dcoutts_: you're right. When will it move to cabal?
09:55:04 <dcoutts_> marcot, it depends on when cabal is ready, it's missing some features I need.
09:56:03 <dcoutts_> I might experimentally try using cabal after the 0.9.10 release and then send patches to SyntaxNinja to add any needed features
09:56:50 <marcot> dcoutts_: hum.. ok.
10:01:27 <SyntaxNinja> yes. patches are gooood
10:01:48 <SyntaxNinja> btw, who was asking for support for configure to find programs for you?
10:01:51 <SyntaxNinja> was that you, dcoutts?
10:01:56 <xerox> @seen dons
10:01:57 <lambdabot> dons is in #haskell-blah and #haskell. I don't know when dons last
10:01:57 <lambdabot> spoke.
10:03:37 <xerox> Yi is cool!
10:05:54 <dcoutts_> SyntaxNinja, no, not me.
10:06:18 <neologism> what is cabal?
10:06:20 <dcoutts_> SyntaxNinja, I want cabal to support register inplace and to install .chi files
10:06:32 <dcoutts_> @where Cabal
10:06:33 <lambdabot> http://www.haskell.org/cabal
10:11:46 <xerox> http://haskell.galois.com/~paolo/yi-1910-171005.png
10:13:08 <Cale> xerox :)
10:13:27 <xerox> The font is Gtk2-cairo-rendered/antialiased, woot :D
10:13:36 <Cale> :)
10:14:08 <xerox> I'd love to try CommonSense!
10:15:03 <xerox> Do you know anything about those errors, when building hIDE?
10:15:03 <xerox> src/Hide/Yi.hs:25:37: Module `Yi.Window' does not export `newWindow'
10:15:03 <xerox> src/Hide/Yi.hs:26:37: Module `Yi.UI' does not export `handleInput'
10:15:03 <xerox> src/Hide/Yi.hs:26:50: Module `Yi.UI' does not export `setFont'
10:15:06 <xerox> src/Hide/Yi.hs:29:65: Module `Yi.Editor' does not export `setWindow'
10:17:53 <Cale> xerox: hmm, no. I haven't tried hIDE yet
10:18:27 <xerox> @get-dons :D
10:18:28 <lambdabot> Unknown command, try @listcommands.
10:18:34 <Cale> so, the syntax is coloured using ghc?
10:19:01 <xerox> In hIDE it is, in the standalone Yi (in the shot) it's made by GtkSourceView
10:19:08 <Cale> ah, okay
10:19:20 <xerox> The ghc-api synhl is even nicer
10:19:32 <Cale> I figure it would be :)
10:19:51 <xerox> http://scannedinavian.org/YiWiki/ScreenShots
10:20:05 <xerox> I mean, wee!
10:20:17 <Cale> I've seen some shots where type errors are underlined
10:20:27 <xerox> Yeah!
10:32:49 <Cale> hrm, I can't connect to scannedinavian.org
10:33:40 <Cale> oh, .com works though
10:33:49 <xerox> Trying to grab the lot? :D
10:33:54 <int-e> same old problem I assume
10:33:57 <Cale> yeah
10:34:54 <Cale> int-e: which?
10:35:09 <xerox> The DNS issues :-\
10:36:03 <int-e> yup, scannedinavian.org DNS problems - the .org servers still think they know the IP address and it's the wrong one.
10:43:29 <wolverian> what would the easiest method be to try hIDE on Debian or Ubuntu?
10:43:45 <wolverian> (erm, move that 'be' to the left a bit)
10:44:42 <Cale> wolverian: probably darcs get all the required stuff and build them
10:45:05 <wolverian> Cale, ah, thanks. I'll probably wait for an easier method, then.
10:45:35 <neologism> wolverian: I think that asking someone to provide you a binary is not a bad idea
10:46:24 <wolverian> right. maybe someone has a Debian repository for it? :)
10:52:06 <dcoutts_> wolverian, it's not ready for general consumption
10:52:22 <dcoutts_> wolverian, when it's ready for users we'll make it easier to install
10:52:32 <dcoutts_> at the moment we want hIDE contributers
10:52:57 * xerox boings
10:53:04 <Cale> ghc-6.4: unknown package: Cabal-1.1.3 -- what could this mean, if ghc-pkg tells me that Cabal-1.1.3 is installed?
10:53:41 <dcoutts_> Cale, it means that Cabal depends on util but util and everything that depends upon it is hidden
10:53:43 <xerox> Cale: I think it would be better to use the latest Cabal, kicking 'util' out of the deps in the Cabal.cabal file (in order to make it possible to compile ghc-api)
10:54:02 <dcoutts_> Cale, yes, the right thing to do is to remove the util dep from Cabal
10:54:25 <Cale> xerox: by latest, do you mean darcs?
10:54:29 * dcoutts_ wonders if SyntaxNinja has made that change in the latest darcs version of Cabal
10:54:34 <xerox> Cale: yep!
10:54:43 <xerox> (It's 1.1.4)
10:57:11 <dcoutts_> Cale, you need to hack the Cabal.cabal file to remove util from build-depends
10:57:24 <Cale> okay
10:57:26 <dcoutts_> then configure build and install cabal again
10:57:28 <Speck> I also had to remove a dep from ghc-api
10:57:35 <dcoutts_> Speck, oh?
10:57:45 <Speck> err, I had to do something else I forget
10:57:57 <Speck> I should check before I say anything
10:58:05 <xerox> It went smoothly here, without touching ghc-api's cabal file.
10:58:21 <Speck> maybe it was unnecessary then, but it built
10:58:27 <Speck> whatever it was that I changed
10:59:06 <xerox> Use darcs to check the diff?
10:59:27 <Speck> yeah apparently it's the same
10:59:38 <Speck> this all went down at like 5am so maybe I'm confused
11:00:27 <Speck> oh now I remember I removed "-ignore-package lang"
11:10:39 <Cale> Speck: it seems I also have to add an extra ignored parameter to the cppParser function in Setup.lhs for ghc-api
11:11:05 <Speck> oh?
11:11:53 <Cale> the type of the postConf field has changed apparently
11:14:05 <wolverian> dcoutts_, right, sounds reasonable. thanks.
11:17:17 <Cale> heh ./Setup.lhs: /home/dons/bin/runhaskell: bad interpreter: No such file or directory
11:17:39 <Speck> uh oh
11:19:11 <Igloo> :-)
11:21:28 <dcoutts_> Speck, hmm that -ignore-package lang is there for a reason
11:21:46 <Cale> ghc-6.4: Error: module 'Generics' is exposed by package lang-1.0 and package ghc-api-0.2
11:22:26 <Speck> oh well it built for me :-/
11:24:33 <dcoutts_> Cale, the ghc-api needs to be installed hidden
11:25:02 <dcoutts_> Speck, it was peobably because of another problem on your system (rg Cabal depending on util)
11:25:24 <dcoutts_> Cale, ghc-pkg hide ghc-api-0.2
11:29:32 <Cale> yep
11:31:13 * SamB catches GCC rewriting printf() to puts()
11:32:12 <xerox> Ah!
11:33:29 <xerox> Where/how? :-)
11:35:13 <SamB> well, it calls itself: "gcc.real (GCC) 4.0.1 (Debian 4.0.1-2)"
11:35:45 <SamB> and the printf looks like: 'printf("heap overflow!\n");'
11:35:52 <SamB> and I compiled with -O
11:36:11 <xerox> Hm?
11:37:09 <xerox> @seen dons
11:37:10 <lambdabot> dons is in #haskell-blah and #haskell. I don't know when dons last
11:37:10 <lambdabot> spoke.
11:37:15 <xerox> Cale: any luck?
11:38:14 <Heffalump> yo
11:40:22 <Cale> xerox: downloading gtksourceview and about 100 other packages (I really need to do a proper upgrade)
11:40:35 <xerox> hah.
11:40:40 <xerox> Greetings Heffalump!
11:41:14 <Cale> "apt-get install libgtksourceview-dev" -- this upgrades samba
11:41:37 <xerox> Woot..
11:42:17 <Cale> well, I'd hate to do something like this by hand :)
11:42:21 * Heffalump comes in search of mathematical advice
11:42:52 <Cale> what kind of mathematical advice?
11:42:54 <Heffalump> I have a relation that is defined inductively.
11:43:36 <Heffalump> e.g. x + y = 3 => x R y, x R y ^ y R z => x R z
11:44:04 <Cale> okay, so it's the transitive closure of that other relation
11:44:16 <Heffalump> yes, though that's not particularly relevant. I'm just giving an example.
11:44:28 <Cale> okay
11:44:35 <Heffalump> The point is that I want to prove things about x R y, based on induction over this structure.
11:45:12 <Heffalump> (so if my first precondition was really x - y = 3, then I could prove that x R y => 3 | y - x)
11:45:39 <Cale> okay
11:45:49 <Heffalump> The problem is that one might reach x R y for given x and y by many possible routes.
11:46:25 <Heffalump> And sometimes my proofs (which are more complicated than the above) rely on some details of the route.
11:46:51 <Heffalump> So really what I'd like to do is not have R be a relation, but somehow explicitly represent the structure by which it was built up.
11:47:23 <Heffalump> (obviously it would induce a relation, but the point is I want to be able to take a statement x R y and assume that it was built up in a unique way)
11:47:30 <Heffalump> is there a good notational way of saying that?
11:48:22 <Cale> Well, I think you could invent some structure which encodes that building
11:48:24 <Igloo> You want something not entirely unlike associativity, don't you?
11:48:40 <Cale> perhaps a tree structure of sorts
11:48:44 <Heffalump> cale: sure. But I want to hide it notationally.
11:49:04 <Heffalump> I guess I could have some kind of explicit tree.
11:51:53 * beelsebob_ prods people with stick
11:51:55 <Cale> I suppose it just depends on how you want to think about it.
11:51:56 <beelsebob_> s
11:52:19 * Cale sticks people with prods
11:52:30 * beelsebob_ pokes cale in the ribs
11:52:34 <Cale> heh
11:52:46 <Heffalump> I know how I think about it, but I need to express it clearly to others :-)
11:53:41 <beelsebob_> mmmm... hat-delta
11:53:49 * beelsebob_ is still gloating that it's all worky
11:53:52 <Philippa> is it some flavour of unfold?
11:54:07 <beelsebob_> philippa: huh?
11:54:17 <beelsebob_> oh... and you wanted to prod hat-delta didn't you?
11:55:17 <Philippa> er, was talking to Heffalump. And wouldn't mind a look at it sometime, certainly - though I'm not sure I've got anything much worth running through it atm
11:55:31 <labra> lambdabot: @putStrLn "Hola"
11:55:32 <lambdabot> Unknown command, try @listcommands.
11:55:33 <beelsebob_> heh
11:55:39 <Heffalump> Philippa: is what some flavour of unfold?
11:55:42 <labra> lambdabot: @listCommands
11:55:43 <lambdabot> use listcommands [module|command], please. Modules are:
11:55:43 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
11:55:43 <lambdabot> haddock help hoogle karma lambda localtime more pl plugs quote
11:55:43 <lambdabot> search seen spell state system todo topic type version vixen
11:55:43 <lambdabot> where
11:55:50 <beelsebob_> well then http://www.haskell.org/hat/cvs.html
11:55:51 <Heffalump> I'm writing a proof, not a Haskell program :-)
11:56:30 * xerox is bored
11:56:46 <Philippa> yeah, I mean the structure that yields the relation - which'd give you the route
11:57:07 <thedward> @listCommands lambda
11:57:07 <lambdabot> lambda provides: lambda define get-definition definitions resume
11:57:17 <xerox> Anybody knows what were newWindow, handleInput, setFont, and setWindow for in Yi, and why they aren't in Yi's sources anymore?
11:57:29 <xerox> @get-definition Y
11:57:30 <lambdabot> Y = \f.U(\g.f(U g))
11:58:13 <Heffalump> Philippa: I don't follow
12:00:39 <xerox> @lambda fact 10
12:00:40 <lambdabot> 3628800
12:00:57 <Philippa> I'm just wondering if working with specific anamorphisms'd give you enough structure while letting you 'hide' most of it
12:01:19 <Philippa> but quite possibly not as this is just one of my dodgy intuition-driven stabs in the dark
12:01:57 <Heffalump> hmm :-)
12:02:00 <xerox> Hi paolino__
12:02:35 <Heffalump> really my problem starts with defining it. I can't use implication to define the preconditions, for example.
12:03:13 <Heffalump> I guess I need to define some kind of object.
12:03:40 <Philippa> do you have a more specific example than above yet? Or is pinning that down half the problem?
12:05:07 <Heffalump> the real thing is to do with commutation in darcs patch theory
12:05:29 <Heffalump> darcs get http://urchin.earth.li/darcs/ganesh/darcs-patch-theory if you want
12:05:38 <Philippa> ah, I've not really followed enough of that so far - I'm strictly an end-luser atm
12:05:55 <Heffalump> well, I hope to explain it to mathematical types with what I'm doing now (as well as proving some results)
12:06:22 <Heffalump> I'm not very happy with the current machinery I've set up, partly for the above reason and partly because it's all rather verbose, but you're welcome to look
12:06:53 * xerox boings and re-boings
12:08:01 <Philippa> sure. Any idea where I am in relation to your target audience?
12:08:19 <Philippa> aside from having a nasty tendency to leave out all the working, that is?
12:08:55 <Heffalump> My main goal is to come up with rigorous proofs that someone with mathematical aptitude and training can verify.
12:09:05 <Heffalump> My secondary goal is to make it all as understandable to as many people as possible.
12:09:20 <Philippa> 'k. Having got two years through a compsci degree count as sufficient training?
12:09:56 <Heffalump> s/ and training/ and a basic understanding of "standard" notation/
12:10:10 <Heffalump> (i.e. yes. And I don't want to get all elitist about it. I just have to assume _something_)
12:10:16 * dcoutts_ starts to build Gtk2Hs 0.9.10-rc with Gtk+2.8.x and cairo on win32
12:10:18 * Philippa nods
12:10:50 <Philippa> similarly, aptitude = smart enough to be discussing the subject at all rather than needing to be particularly good beyond that, I assume?
12:11:03 * xerox woots in dcoutts' direction
12:11:10 <Heffalump> yes.
12:11:25 <dcoutts_> xerox, I'll tell you tomorrow if it built ok
12:11:28 * dcoutts_ goes home
12:11:28 <Philippa> not sure I have an appropriate toolset to build it :-(
12:11:40 <xerox> Great!  Have fun, Duncan!
12:11:52 * xerox chases dons in the darkness
12:12:06 <Philippa> a year or so back I'd have dumped it onto much and tried there, but I've been suspended long enough that my CSIT accounts've gone bye-bye
12:15:49 <paolino__> xerox :)
12:16:27 <Heffalump> Philippa: build what, the tex?
12:16:36 * Heffalump belatedly realises you might have been talking to me there
12:18:24 <Frederick> does anyone know a language to describe automatas?
12:18:40 <paolino__> what is wrong with this : getLine >>= print >>= getLine ?
12:18:52 <Heffalump> getLine doesn't take an argument
12:18:57 <Heffalump> try getLine >>= print >> getLine
12:19:47 <Cale> two Paolos?
12:20:14 <xerox> Yeah :)
12:20:15 <Heffalump> Philippa: I've made .ps and .pdf files in that repo now (not for pulling, but should be http downloadable)
12:20:17 <Philippa> Heffalump: yeah
12:20:24 <xerox> paolino__: check out (>>)
12:20:32 <Philippa> thanks
12:23:09 <paolino__> >> doesn't eat functions
12:23:12 * xerox yawns
12:23:37 <xerox> paolino__: (>>) sequences actions without feeding the right one with the result of the left one
12:24:09 <sieni> OT, but might be of interest to someone: http://www.ssh.com/company/careers/engineer-scheme.html
12:24:15 <xerox> It's used to express things like  do {print "Hello\n"; print "World!"}
12:24:47 <xerox> (Which becomes print "Hello\n" >> print "World!")
12:24:59 <tic> isn't >> like >>=, but with \_ instead of \x ?
12:25:06 <xerox> Exactly.
12:25:29 <paolino__> (>>) :: m a -> m b -> m b
12:25:44 <paolino__> where is the function parameter ?
12:25:49 <xerox> Where the second argument to (>>=) is (a -> m b)
12:25:56 <int-e> a >> b = a >>= \_ -> b
12:25:59 <Heffalump> getLine isn't a function, so why do you need a function parameter?
12:26:03 <int-e> it's being ignored.
12:26:21 <Frederick> anyone can help me?
12:26:46 <paolino__> int-e ignored by the inferrer ?
12:27:42 <xerox> paolino__: ignored during evaluation (i.e. not used)
12:28:21 <int-e> paolino__: >> does two things: first, build a function from the second argument that takes one argument, ignores it and returns the second argument; secondly, it uses >>= with the first argument and its modified second argument.
12:29:56 * int-e wonders if what he just wrote helps or only adds to the confusion, with it's overuse of 'argument'.
12:30:05 <int-e> its.
12:31:01 <paolino__> brains are like stomachs , cannot take too much
12:31:25 <xerox> That's nothing difficult about >>, if you understood >>= (and it seems you have)
12:31:53 <paolino__> (>>) :: m a -> (_ ->m b) -> m b
12:32:13 <sethk> right.  _ ->  is equivalent to (throw away the argument)
12:33:35 <paolino__> kpk, I go study the state monad now
12:33:35 <Igloo> Huh? That's not the type of (>>)
12:34:07 <paolino__> Igloo that what I was expecting
12:34:15 <sethk> Igloo, it is shown that way in some docs
12:34:26 <Igloo> In what docs?
12:34:55 <sethk> Igloo, one of the monad tutorials
12:35:03 <sethk> Igloo, I'll have to dig it up, but it is definitely there
12:36:18 <paolino__> Well I invented it anyway,it looks coherent to me, but I miss something basic probably
12:36:39 <sethk> paolino__, no, the _ -> is indeed shown in one of the tutorials.  I'll find it.
12:37:02 <Frederick> can I use haskell to express automatas easily?
12:37:36 <xerox> paolino__: I see what you mean.  It's (>>) that ignores the return value of the first action, not the action itself.  I.e. you do not have to pass an action "doFoo _ = ...".
12:39:46 <Philippa> Frederick: yup
12:40:02 <xerox> Howdy bojohan :-)
12:40:05 <Frederick> Philippa, I want abstrations like dtats and transitions
12:40:17 <Frederick> Philippa, can you give me a link for that?
12:40:26 <Heffalump> the only issue is that an automaton is a graph, and haskell doesn't do graphs very well
12:40:28 <bojohan> hi
12:40:49 <Philippa> I'd say it doesn't do completely general graphs very well
12:41:02 <Philippa> a lot of the specialisations work out rather nicely
12:41:14 <Philippa> Frederick: nope, sorry :-(
12:41:19 <Heffalump> well, there's the Launchbury and King paper, which is always a good read
12:41:24 <Frederick> Philippa, http://www.di.uminho.pt/~jas/Research/HaLeX/HaLeX.html
12:41:26 <Frederick> ownage
12:41:26 <Heffalump> "Structuring Depth-First Search in Haskell"
12:41:38 <Philippa> and I guess life's always easier if you don't mind using the ST monad or something similar
12:42:21 <Frederick> Philippa, are you talking to me?
12:42:36 <paolino__> Heffalump, which language does graphs very well ?
12:42:55 <Heffalump> Dunno. Some kind of ML is probably better than Haskell.
12:42:57 <Philippa> that part was a comment on Heffalump's that haskell doesn't do graphs very well
12:43:09 <Philippa> Heffalump: on grounds of references, or something else?
12:43:16 <Heffalump> references
12:43:59 * Heffalump goes shopping
12:44:00 <Philippa> I tend to be on the willing to use monads when I feel like it side of things like this
12:44:35 <Heffalump> finding the syntactic machinery invading your entire program can be annoying, though
12:44:40 * Heffalump really goes shopping
12:47:49 <Frederick> Philippa, can I use haskell to implement and handle context free grammars?
12:48:03 <Philippa> yes
12:48:16 <Philippa> me, I tend to just use Parsec instead, but hey
12:49:05 <xerox> Frederick: yeah, and it's very, very nice.
12:49:11 <xerox> @where nymphaea
12:49:11 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
12:49:22 <xerox> ^- context free grammars in action (Lindenmayer Systems)
12:49:33 <xerox> (Cairo-rendered woot woot!)
12:49:53 <Frederick> Philippa, xerox I need to implement a program that given a set of variables and terminals and productions, validates the grammar, than simpleifies it
12:50:19 <Frederick> removes useless symbols, removes empty productions, generates Chomsky and greibach forms
12:50:52 <Frederick> I know the algorithms but Im not eager to freak coding it in c
12:51:03 <xerox> Sounds like nymphaea core + Plugins/Pointless + some hacking :-D
12:51:04 <Philippa> Haskell'll be more suitable than most languages for that so long as you're willing to work in the ST monad or similar any time you really need mutability
12:51:33 <Frederick> Philippa, I didnt understood
12:51:36 <Frederick> *and
12:52:10 <Frederick> I need something liike this -> http://www.di.uminho.pt/~jas/Research/HaLeX/HaLeX.html#capitulo6 but this crap is almostperfect cause doesnt includes grammar forms
12:52:29 <Philippa> Frederick: how much Haskell do you know?
12:53:13 <Frederick> Philippa, no at all, but ive coded once in ML and Im eager to do this job asap, I will dive on it
12:55:13 <Frederick> why?
12:55:15 <Philippa> OK. In Haskell we use things called monads to manage side-effects. Haskell itself doesn't have references, or any kind of mutable ("updatable", if you like) data
12:55:32 <Philippa> there are several monads that do support them, the ST monad being one of the best known
12:56:52 <Frederick> Philippa, does it has an official link?
12:56:59 <Philippa> effectively it's a smart trick for hiding the big map of references to values that's being passed around under the covers...
12:57:10 <Philippa> there're quickie docs on the ST monad that come with GHC
12:57:17 <Philippa> if you get monads generally, it's fairly easy to pick up
12:57:40 <Philippa> although it uses a trick with the type system that you'll have to quietly ignore until you understand it
12:57:53 <Frederick> what do I need to run haskell?
12:58:00 <Philippa> GHC's probably your best bet
12:58:05 <Philippa> (the Glasgow Haskell Compiler)
12:58:20 <Frederick> he Glasgow Haskell Compiler
12:58:24 <Frederick> I will install it
12:58:29 <Philippa> you may be better off using an ML variant just for this though, it'll probably take you a few days to get up to scratch even if monads do click straight away
12:59:03 <Philippa> btw, if the layout rule starts biting you the easiest way to understand it in practice is to read the definition in The Haskell 98 Report IMO :-)
12:59:28 <Frederick> Philippa, ML stinks, it has problems with crossed references and stuff also very bad docummented
12:59:57 * int-e thinks reading that report is quite a good idea for every Haskell coder - it's quite concise when compared to other language specifications.
13:00:27 <Philippa> Frederick: *which* ML stinks? There's an entire family of 'em...
13:00:29 <JKnecht> Now anyway. What was Haskell, 7 or 8 years ago?
13:00:47 <Frederick> Philippa, Moscow ml
13:01:20 <Philippa> you might be more comfortable picking up something like SML/NJ or OCaml
13:01:39 <Philippa> if only because there'd be less learning to do
13:01:42 <Frederick> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
13:02:04 <Philippa> don't recognise that URL, there's a lot of stuff on them out there...
13:02:06 <Frederick> Philippa, I will need haskell anyway forthe next semster
13:02:16 <Frederick> huh?
13:02:26 <Philippa> fair enough, go learn then
13:02:36 <Philippa> there's a lot of intro-to-monads material out there now
13:02:47 <Philippa> mostly because they're the single most confusing thing about Haskell98
13:03:01 <Philippa> they're also arguably the best thing about it, but hey
13:03:08 <Philippa> (type classes'd be the other candidate IMO)
13:03:34 <Philippa> if you've done some ML you might find the Gentle Introduction is actually gentle enough for once btw
13:03:51 <Philippa> (A Gentle Introduction to Haskell, it's on haskell.org somewhere)
13:04:33 <Frederick> Philippa, Im downloading it thx
13:04:53 <Frederick> Philippa, did you see that lib (not sure you call it a lib) Ive showed you?
13:05:05 <Frederick> do you believe I can find such a thing for normal forms?
13:05:09 <xerox> Is there a difference between "strongly" and "strictly" typed?
13:05:24 <Frederick> xerox, I believe it does
13:05:32 <xerox> What is it about?
13:05:41 <Philippa> Frederick: I don't know. That said, if you have a big pile of standard algorithms it shouldn't take you too long to transcribe them
13:05:42 <xerox> I always get the terms wrongly
13:05:54 <Philippa> I've not seen "strictly" typed before
13:06:08 <Philippa> my first guess would be to give it the same meaning as on the term level...
13:06:28 <Frederick> xerox, Strictly you cant cast whatever it is, you can have data beeing atribued to another kind, like float x = int a
13:06:56 <Frederick> strong will warn, scream and try to hit you but will let you do the job
13:07:26 <Philippa> that's not my understanding of strong typing
13:07:49 * xerox is all eyes
13:08:03 <JohnMeacham> ack. ML and Ocaml are what turn people off to FP. it is lot at the oppositive of the sweet spot when it comes to strong typing.. okay. not that bad. but pretty bad.
13:08:04 <Frederick> Philippa, my teacher of this subject was lets say, unskilled so I might have get lots of wrong concepts
13:08:06 <Philippa> at least, my understanding is that it only lets you do that when there's an explicit coercion mechanism in the type system
13:08:30 <Philippa> JohnMeacham: yeah, I only suggested them because Frederick's got existing experience and something to do right now
13:08:53 <Frederick> Philippa, I got 1 month to do it but I have also a kernel to write
13:08:57 <Frederick> so I must better hurry
13:11:25 <Frederick> this also might help -> http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter
13:12:08 <Philippa> or it might not, because attribute grammars aren't haskell
13:13:22 <Frederick> how not?
13:13:44 <Frederick> it is in haskell.org :p
13:15:31 <Philippa> they're not part of the haskell language, and I'm not aware of any attribute grammar project for haskell that doesn't involve a preprocessor
13:15:42 <Philippa> (which is how UUAG works)
13:16:47 <Frederick> can you translate it to newbanese please?
13:16:52 <Frederick> I dint get a word
13:18:10 <JKnecht> is UUAG comparable to AUG?
13:18:30 <Philippa> JKnecht: no idea, what's AUG? UUAG is the Utrecht University Attribute Grammars project
13:18:50 <Philippa> Frederick: in newbiespeak, ignore attribute grammars. They are not part of haskell, you just found an article about them aimed at haskell users
13:19:31 <Frederick> Philippa, roger that
13:19:42 <labra> I have a question about lambdabot
13:20:12 <labra> I have compiled it and I wanted to try it in another channel
13:20:21 <labra> how can I do it?
13:20:52 <Cale> edit Config.hs
13:20:57 <JKnecht> Mark P. Jones, Paul Hudak, Sebastian Shaumyan, "Using Types to Parse NLP" describe a Haskell parser of Applicative Universal Grammar.
13:21:04 <Cale> which sets the starting channels
13:21:19 <Cale> You can also tell it to @join and @part various channels
13:21:34 <Frederick> Philippa, do you know what are the normal forms like Chomsky and greibach right?
13:22:39 * Heffalump wonders if anyone who looked at my repo had any deep notational insights
13:22:53 <Philippa> Frederick: nope, I'd have to go look up definitions quickly
13:23:09 <glguy> reading lambdabot's source code might be a good way to learn more Haskell techniques and practices... time to download it's code
13:23:16 <Frederick> Philippa, do you now what is a context free grammar?
13:23:16 <Philippa> Heffalump: nope, but it'd be nice if you gave pronunciations for the two operators you define after commutation (as far as I've got in so far)
13:23:17 <glguy> @version
13:23:18 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
13:23:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:23:21 <Philippa> Frederick: yes
13:23:22 <glguy> lambdabot: @version
13:23:22 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
13:23:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:23:45 <Frederick> Philippa, normal forms are special forms with some restrictions over the production rules this is what I need
13:24:05 <Philippa> and you need code to normalise arbitrary CFGs?
13:24:18 <Heffalump> they're written \commutelift and \commutestar in LaTeX, which is how I've been pronouncing them so far.
13:24:25 <Heffalump> But those are the operators I want to structure as trees.
13:24:40 <Philippa> yeah. What's commutelift lifted over?
13:24:50 <Philippa> (I'm not getting a good intuition for it staring at the definition)
13:24:51 <labra> Why don't use command line arguments instead Config.hs ?
13:25:00 <xerox> @seen dons
13:25:01 <lambdabot> dons is in #haskell-blah and #haskell. I don't know when dons last
13:25:01 <lambdabot> spoke.
13:25:02 <Philippa> commutestar's just the transitive closure of commutelift, right?
13:25:08 <beelsebob_> bah... why doesn't this work
13:25:17 <labra> because now, I have to recompile it just to change the channel
13:25:32 <Frederick> Philippa,  I need to code a program that given a set of non terminal, terminals, an start simbols and productions checks if it is a valid grammar, and make some transformatios over it
13:25:34 <arjanb> commutelift is commutation of sequences?
13:26:05 <Heffalump> Philippa: yes
13:26:13 <Frederick> Philippa, I basically need to manipulate a grammar the transformations I will handle my self anyway
13:26:18 <Heffalump> Philippa: lifting from commutation of pairs to commutation of a single pair inside a sequence
13:27:05 <Philippa> Frederik: OK. What is worrying you about this? Why can't you pick your own representation of the grammar, as you've practically got one from the mathematical definition already?
13:27:31 <labra> I have compiled lambdabot and then I run lambdabot but i don't see anything happening
13:27:43 <labra> I just changed the channel to #weso
13:27:55 <Heffalump> labra: that's because lambdabot works in deep and mysterious ways
13:28:03 <beelsebob_> oh why the fuck doesn't this work!
13:28:22 <Philippa> beelsebob_: what doesn't work?
13:28:31 <beelsebob_> philippa: trying to load another app
13:28:40 <beelsebob_> it closes too soon to see any error
13:29:33 <labra> I just wanted to try lambdabot in another channel
13:29:55 <labra> by the way, does lambdabot provide some kind of log?
13:30:10 <Frederick> Philippa, cause I dont know haskell, so I think I need something that allow me  to write something like tjis http://rafb.net/paste/results/Z93Eem95.html
13:30:34 <labra> after some time...lambdabot says: runIRC: caught exception...connect: timeout...
13:30:41 <JKnecht> hmmm, must be AMS TeX or other package, doesn't seem to be in LaTeX nor TeX (i.e. \commuteX).
13:30:59 <Philippa> Frederick: Haskell's datatypes are similar to ML's. It has lists and tuples, so you should be able to translate the definition. You should probably go learn more haskell and then come back to your task
13:31:18 <glguy> who wrote lambdabot?
13:31:19 <Cale> labra: how have you configured the bot with Config.hs?
13:31:20 <glguy> dons :)
13:31:24 <glguy> (just looked at the URL)
13:31:24 <Frederick> Philippa, sure all I want is a pointerr :p
13:31:42 <Frederick> glguy, my url?
13:31:43 <labra> I just changed the channel field
13:31:56 <labra> instead of #haskell I put #weso
13:32:03 <glguy> dons: are you around?
13:32:12 <int-e> @fact hsu
13:32:12 <lambdabot> hsu: I know nothing about Haskell Secret Underground..
13:32:13 <Philippa> Frederick: I just gave you a big one. Go translate the mathematical definition into plain Haskell, using lists to represent sets
13:32:14 <Cale> and you'll have to change the nick to something else
13:32:24 <Heffalump> glguy: I think several other people were involved before dons.
13:32:33 <Cale> the "name" field
13:32:34 <Heffalump> He's doing most of the work on it now, though.
13:33:52 <glguy> Anyway, would someone confirm the following statement (or tell me I'm wrong), when I execute : words "this is a test" !! 0, lazy evaluation says that the words function will stop parsing when the first word is found
13:34:04 <Cale> glguy: yep
13:34:06 <labra> maybe...I should also have to change the proxy...
13:34:45 <Cale> @eval take 30 $ concat (repeat "hello ")
13:34:47 <lambdabot> "hello hello hello hello hello "
13:34:57 <Igloo> glguy: As confirmed by:
13:35:01 <Igloo> @eval words ("this is a test" ++ undefined) !! 0
13:35:02 <lambdabot> "this"
13:35:03 <Cale> @eval (words $ concat (repeat "hello ")) !! 0
13:35:04 <lambdabot> "hello"
13:35:04 <labra> @eval 3+4
13:35:06 <lambdabot> 7
13:35:45 <glguy> Alright, just checking because of something I saw while reading lambdabot's code
13:35:56 <Frederick> Philippa, think Ive found the structure I will use I will need an evaluating system like this -> http://rafb.net/paste/results/jUwrOR13.html
13:36:05 <glguy> Just making sure my preception of lazy eval was correct
13:36:59 <Philippa> Frederick: that would be what we call a plain ol' function...
13:37:04 <Philippa> albeit defined by pattern-matching
13:37:14 <Philippa> really, go read some tuts and see what you can hack up
13:37:23 <Philippa> Haskell is a natural fit for the kinds of things you're doing
13:38:12 <Frederick> thx a lot I got  my pointer
13:38:25 <basti_> what do you need a pointer for?
13:39:22 <cjb> Yeah, this is Haskell, we don't need no steenkin' pointers.
13:39:37 <xerox> basti_: to point!
13:39:53 <basti_> can you point a pointer at itself?
13:39:54 <ValarQ> cjb: good point
13:39:57 <basti_> will it be bottom then?
13:40:01 <Cale> @type Foreign.Ptr.nullPtr
13:40:04 <lambdabot> forall a. GHC.Ptr.Ptr a
13:40:08 <xerox> basti_: it's like matrix, the pointer doesn't exist, you are the one benting.
13:40:24 <Cale> @index malloc
13:40:25 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
13:40:36 <basti_> thats too complicated.
13:40:38 <Cale> @type Foreign.malloc
13:40:39 <basti_> i need to go to bed now
13:40:40 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO (GHC.Ptr.Ptr a)
13:40:41 <xerox> pfft.
13:40:47 <xerox> Goodnight basti!
13:40:55 <basti_> night
13:43:15 <pesco> kosmikus: Quick reply. :)
13:44:17 <glguy> so... I can use { and } to define blocks of code in haskell, or I can just use identing, but either way it's the same thing?
13:44:25 <tic> Yes.
13:44:38 <tic> do { foo; bar } ->
13:44:40 <tic> do
13:44:45 <tic>     foo
13:44:47 <tic>     bar
13:45:03 <glguy> or...
13:45:05 <glguy> do foo
13:45:09 <glguy>    bar
13:45:09 <glguy> ?
13:45:49 <sylvan> yes
13:46:27 <labra> @eval map (\x -> if x =='a' then 'b' else x) "labra")
13:46:28 <lambdabot>  parse error on input `)'
13:46:35 <labra> @eval map (\x -> if x =='a' then 'b' else x) "labra"
13:46:36 <lambdabot> "lbbrb"
13:48:50 <int-e> @pl map (\x -> if x =='a' then 'b' else x)
13:48:51 <lambdabot> map (flip if' 'b' =<< ('a' ==))
13:49:44 <xerox> @index if'
13:49:44 <lambdabot> bzzt
13:49:51 <xerox> @type if'
13:49:51 <glguy> flip f a b = f b a, right?
13:49:52 <lambdabot> bzzt
13:50:05 <Frederick> guys does haskell has an interpreted mode like python or I need to compile it?
13:50:18 <Heffalump> ghci / hugs
13:50:19 <int-e> 'No instance for (Monad ((->) Char))' (after defining if' a b c = if a then b else c)
13:50:23 <xerox> Frederiit has!
13:50:49 <xerox> Frederick: it has.  Check 'ghci' (and hugs, maybe..)
13:50:51 <Frederick> xerox, ?
13:50:55 <Frederick> thx
13:51:07 <Frederick> xerox, I got ghci docs now
13:51:41 <glguy> @type flip
13:51:43 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
13:52:11 <xerox> glguy: yep.
13:52:17 <tic> why not (...) -> (...) ?
13:52:48 <xerox> tic: because  a -> b -> c  ===  a -> (b -> c)
13:53:04 <tic> ah right.
13:53:11 <Frederick> I use gentoo ghc is taking an ice age to compile
13:54:38 <Heffalump> it would. This is what binary packages are for.
13:57:04 <TheHunter> int-e, you need to import Control.Monad.Reader
13:58:08 <int-e> TheHunter: interesting, thanks.
13:59:18 <TheHunter> @eval map (flip if' 'b' =<< ('a' ==)) "abcde" where if' a b c = if a then b else c
13:59:20 <lambdabot> "bbcde"
13:59:45 <int-e> heh, when did lambdabot learn to deal with 'where'?
14:00:33 <TheHunter> it's a dirty trick:
14:00:39 <TheHunter> s <- unsafeEval ("take 1024 $ show $ reset ("++s++")" context
14:00:54 <TheHunter> noo, that's not what it is.
14:00:55 * TheHunter reverts
14:02:01 <TheHunter> unsafeEval ("let { xxxx = \n# 1 \"<irc>\"\n"++s++"} in take 2048 (show xxxx)")
14:02:23 <TheHunter> inside let, where is allowed.
14:02:45 <int-e> I see.
14:03:51 <xerox> What's the |# 1 "<irc>"| part for?
14:03:59 <int-e> xerox: better error messages
14:04:26 <xerox> @eval x where x = (
14:04:27 <lambdabot>  parse error on input `}'
14:04:47 <TheHunter> @eval 'a'++'b'
14:04:48 <int-e> they used to be a bit more verbose than that for a while.
14:04:48 <lambdabot> Couldn't match `[a]' against `Char'
14:05:17 <xerox> @eval let a = () in a + 1
14:05:18 <lambdabot>  add an instance declaration for (Num ())
14:05:31 <xerox> @eval +
14:05:31 <TheHunter> what a stupid error message.
14:05:32 <lambdabot>  parse error on input `+'
14:05:38 <xerox> TheHunter: haha.
14:06:37 <int-e> @eval let Left () = Right () in Left () == Right ()
14:06:38 <lambdabot> False
14:07:34 <Philippa> um, how the hell does that evaluate at all?
14:07:42 <Heffalump> cos the let isn't evaluated
14:07:50 <Heffalump> the binding isn't, that is.
14:07:53 <Igloo> I'm sure it shouldn't be accepted as there are no variables on the LHS of the binding
14:07:53 * Philippa blinks
14:07:57 <int-e> Philippa: let Left () = Right ()  does not bind anything.
14:08:13 <Igloo> Philippa: Remember you can say   liet Just x = my_function in x
14:08:17 <Philippa> yeah, I can see how that's happening
14:08:26 <Philippa> Igloo: yes, I'm expecting pattern-match failure I guess
14:08:36 <int-e> @eval let Left a = Right () in a
14:08:37 <lambdabot>  add a type signature that fixes these type variable(s)
14:08:43 <int-e> @eval let Left a = Right () in a::Int
14:08:44 <lambdabot>  Irrefutable pattern failed for pattern Data.Either.Left a
14:08:44 <lambdabot>  
14:08:50 <xerox> @ghc
14:08:51 <lambdabot>  GHC stack-space overflow
14:08:53 * xerox wins
14:09:09 <Lor> @eval let True = False in ()
14:09:11 <lambdabot> ()
14:09:23 <Lor> Ah, let-patterns are non-strict.
14:09:30 <int-e> of course
14:09:46 <Philippa> yep. Just results in the one rather weird piece of behaviour
14:09:59 <int-e> (but heh, it confused me two days ago ... so ... it might not be too obvious)
14:10:37 <Lor> @eval let a@True = False in a
14:10:39 <lambdabot>  Irrefutable pattern failed for pattern (a@GHC.Base.True)
14:10:39 <lambdabot>  
14:10:39 <Philippa> yeah, part of me still isn't seeing when the pattern-match actually takes place but hey
14:11:57 <dcoutts> @eval let a@~True = False in a
14:11:59 <lambdabot>  Not in scope: `a'
14:12:02 <Philippa> a = <pattern-match here> of course, d'oh. Wonder if you get any sharing-of-matching when there're multiple variables in the same pattern?
14:12:18 <Lor> I don't think let's default non-strictness is a good idea.
14:12:24 <Philippa> though that feels like the sort of thing JHC might figure out and most other implementations won't
14:12:26 <bojohan> @eval let 1 = 2 in 1
14:12:27 <lambdabot> 1
14:12:36 <Philippa> it does break my brain given that I'm used to pattern-match = forcing
14:12:56 <Philippa> in that I tend to read that on a more syntactic level IYSWIM
14:13:10 <dcoutts> Philippa, that's because function pattern matching is actually 'case'
14:13:16 <Lor> Ah, of course let must be non-strict. Recursion wouldn't work otherwise.
14:13:25 <dcoutts> Lor, yep
14:13:27 <Philippa> dcoutts: yeah, I know
14:13:39 <dcoutts> Lor, err, actually that's not the case
14:13:40 <xerox> let True = f False; f ~x = x in ()
14:13:46 <xerox> @eval let True = f False; f ~x = x in ()
14:13:48 <lambdabot> ()
14:13:53 <dcoutts> Lor, ML has strict let rec
14:14:01 <Lor> ML has no value recursion.
14:14:06 <dcoutts> Lor, it prevents some other recursive lazy tricks
14:14:15 <dcoutts> yes, value recusion
14:14:28 <xerox> @eval do { let True = False; return () } :: Maybe Int
14:14:29 <lambdabot>  parse error on input `}'
14:14:34 <dcoutts> let array = .... array !! n ...
14:14:35 <Lor> Personally, I think that futures are the right way to do laziness.
14:14:52 <dcoutts> tricks like that only work with lazyness
14:15:23 <xerox> Hiya dcoutts!
14:15:31 <dcoutts> hi xerox
14:15:47 <dcoutts> xerox, are you/we ever going to bind the cairo svg lib?
14:16:16 <xerox> It is possible, I don't think it's fully funcional atm
14:24:06 <dcoutts> xerox, I'm moving the definition of the Render monad from Types to Internal.
14:24:24 <dcoutts> xerox, that way the newtype stuff doesn't get seen by Haddock.
14:25:02 <xerox> Hmm.
14:25:09 <xerox> Okay.
14:26:33 <dcoutts> and it allows us to keep using the newtype deriving
14:28:23 <xerox> I need sleep :-)  Goodnight Duncan (and folks!)
14:32:48 <kosmikus> pesco: :)
14:39:33 <int-e> libsvg(-cairo) appears to be abandoned in favour of librsvg-cairo (see http://sourceforge.net/mailarchive/message.php?msg_id=13464332 , for example)
14:50:23 <Micket> A little offtopic, but any chalmers students around? From Dtek to be specifik
14:52:49 <Heffalump> I think quite a few hang around here. Dunno about right now.
14:53:02 <musasabi> At least some people from Chalmers are here, no idea whether awake or from dtek.
14:53:38 <goron> Where can I find permutation and combination functions?
14:54:35 <glguy> can someone tell me what this does...: stuff <- liftIO $ readFile "stuff"
14:54:53 <glguy> (specifically I'm trying to understand the liftIO
14:54:57 <Heffalump> it does a readFile from "stuff", but in a monad that is layered on top of IO
14:55:03 <Heffalump> look up "monad transformers"
14:55:32 <goron> @index combs
14:55:33 <lambdabot> bzzt
14:56:50 <gzl> dons: around?
14:57:18 <thedward> I can't seem to get the ffi example on the wiki ( http://haskell.org/hawiki/FfiTutorial) to work, it seg faults. Any suggestions?
15:01:10 <Lemmih> thedward: The strfry example?
15:01:37 <thedward> yeah
15:02:56 <thedward> ghc 6.4
15:03:18 <Lemmih> Windows?
15:03:24 <thedward> debian linux
15:03:32 <Cale> strfry isn't an actual function
15:03:36 <goron> Is there a function combs::Int->Int->Int or something like that?
15:03:42 <Cale> it's a joke
15:03:56 <goron> string FRY
15:03:58 <int-e> Cale: it exists
15:04:01 * Lemmih got strfry on his system.
15:04:06 <dcoutts> Cale, Linux Programmer's Manual                 STRFRY(3)
15:04:09 <int-e> the example works here
15:04:15 <dcoutts> DESCRIPTION
15:04:15 <thedward> yeah, it is real
15:04:15 <dcoutts>        The  strfry()  function  randomizes  the  contents  of  string by using
15:04:15 <dcoutts>        rand(3) to randomly swap characters in the string.  The  result  is  an
15:04:15 <dcoutts>        anagram of string.
15:04:27 <thedward> I can do a test c program that works with it fine.
15:04:29 <Cale> SEE ALSO
15:04:29 <Cale>        memfrob(3)
15:04:38 <Lemmih> thedward: Do you get any warnings if you compile with -fvia-c?
15:04:45 <Cale> it's seriously implemented?
15:04:45 <JohnMeacham> if let were not lazy, it would break a whole lot of nice properties. like adding bindings could change program behavior. which is bad. both ghc and jhc will turn lets into cases where they can prove they are strict.
15:05:09 <Cale> goron: what would it do?
15:05:11 <int-e> Cale: yes
15:05:21 <Cale> heh
15:05:31 <int-e> CONFORMING TO "The  strfry()  function  is  unique  to  the  Linux C Library and GNU C Library"
15:06:01 <goron> Cale: It should calculate the number of ways you can pick k objects from n.
15:06:31 <goron> Cale: I could write it myself, but I assume there already is such a function.
15:06:59 <JohnMeacham> jhc and ghc actually have pretty much the exact same algorithm for figuring out strictness, but do slightly different things with the info (but mostly the same)
15:07:00 <int-e> @eval let combs n 0 = 1; combs n m = n*combs (n-1) (m-1) `div` m in combs 4 2
15:07:01 <lambdabot> 6
15:08:35 <int-e> well, there isn't even a factorial function in the standard libs (that I know of) ...
15:09:10 <Cale> yeah, you can just write it with product
15:09:25 <goron> If you have a bitstring with the first and last being one and zero respectively. It's length is 2n. The number of zero's is equal to the number of ones. How many configurations are there?
15:09:54 <sethk> goron, algorithms class?
15:10:03 <sethk> goron, or just idle curiousity?
15:10:05 <goron> sethk: Well, I am reading a paper on O-trees.
15:10:06 <cjb> n!?
15:10:12 <sethk> goron, ok.
15:10:16 <sethk> goron, that makes sense.
15:10:29 <goron> sethk: I already prooved that two things are equivalent.
15:10:31 <Cale> (2n - 2; n-1), I'd say
15:10:35 <int-e> well, drop the first one and the last zero.
15:10:42 * int-e agrees with Cale
15:10:53 <goron> Cale: Me too, but the paper says that term multiplied by 1/n.
15:11:13 <int-e> then they have some balancing property
15:11:23 <goron> Thus 1/n(2n-2;n-1)
15:11:32 <goron> int-e: ?
15:11:37 <Cale> there's some symmetry being considered probably
15:11:41 <int-e> the number of binary trees with n leafs is 1/(n+1) (2n;n)
15:11:47 <int-e> this looks very much like that.
15:12:31 <goron> Anyone wants to take a look on the actual paper?
15:13:38 <Cale> sure
15:13:43 <int-e> another characterization replaces every 1 by ( and every 0 by ) and then requires that the parentheses are properly balanced.
15:14:07 <int-e> (in a string of length 2n, total)
15:14:09 <goron> "Floorplanning using a tree representation" @ google
15:14:23 <goron> Cale: I could also dcc it to you.
15:14:44 <Cale> combs n k = product [n-k+1..n] `div` product [1..k] -- I think I like that version :)
15:15:08 <Cale> found it
15:15:36 <goron> Cale: There are different versions of the paper. It should be on page 283.
15:17:57 <int-e> goron: there are some other strings that do not represent a tree, like 011...
15:18:19 <Cale> um
15:18:43 <Cale> Shouldn't it be Catalan numbers?
15:19:43 <goron> Cale: I don't see where they call it any specific type of number. What do you mean?
15:19:56 <Cale> http://en.wikipedia.org/wiki/Catalan_number
15:20:09 <Cale> 1/(n+1) (2n;n)
15:21:45 * int-e was wondering about that offset 1, too.
15:22:01 <goron> It is supposedly proved in TAOCP.
15:22:22 <goron> But I don't have access to that book.
15:22:28 <Cale> Are there any other conditions on O trees?
15:23:11 <int-e> how do you encode it in a binary tree ... you remove the root node and put all children of it in a linked list ...
15:23:19 <SamB> goron: which one?
15:23:29 <int-e> (with the second link pointing to the corresponding subtree.
15:23:47 <int-e> that removal of the root node accounts for using (n-1) instead of n.
15:23:47 <goron> SamB: Vol 1
15:23:57 <int-e> Val 1. Lying in front of me right now.
15:23:59 <SamB> goron: where?
15:24:08 <Cale> C_n is the number of rooted ordered binary trees with n+1 leaves
15:24:13 <int-e> 2.3.4.4
15:24:17 <goron> 385-395
15:25:31 <goron> int-e: What does it say? Or better: do you have access to a scanner :D
15:25:36 <int-e> Cale: as I said, the root node of the O-tree is not represented as a node in the corresponding binary tree, but the n in the paper counts it.
15:26:19 <int-e> 'The number of ordered trees with n vertices is the number of binary trees with n-1 vertices' plus the formula that Cale and I quoted.
15:26:31 <Cale> yes
15:26:32 <Cale> okay
15:26:32 <int-e> page 389.
15:26:58 * SamB goes back to exercise 33 in section 2.5 (and its answer)...
15:27:14 <glguy> so Maybe is a Monad because (or thus) once you can never guarentee that you can get a specific value out of it
15:27:17 <glguy> ?
15:27:18 <Cale> Which binary tree are you referring to though? I'd just represent them as matched brackets :)
15:27:29 * SamB is solving exercise 34(c)
15:27:45 <Cale> I suppose there's a whole lot of things one could relate it to
15:27:59 <Cale> polygons with noncrossing diagonals added :)
15:28:47 <int-e> Ordered binary trees ...
15:28:48 <goron> int-e: Does it also say why The number of ordered trees with n vertices is the number of binary trees with n-1 vertices'?
15:29:27 <int-e> goron: I guess. I gave a reason above though. I can elaborate on that if you wish.
15:29:28 * SamB made up exercise 34(c): it is to program the algorithm in C. no idea what 34(b) is ;-)
15:29:39 <goron> int-e: Please do.
15:31:07 <int-e> goron: an internal node of a binary tree has two links, a left link and a right link. We want to map the ordered trees to a binary trees.
15:32:02 <Cale> goron: you see that encoding of the tree in the paper as a {0,1}-string?
15:32:19 <goron> Cale: yes
15:32:27 <int-e> We do this as follows: we represent a tree that only has a root node as a binary tree consisting only of a leaf node.
15:32:51 <Cale> Replace 0 with ( and 1 with )
15:33:05 <Cale> and you'll see that these trees correspond to matched brackets
15:33:28 <goron> Cale: Well, that part I do understand it's only the 1/n term I don't understand.
15:33:47 <Cale> goron: it comes from counting matched brackets, etc.
15:33:58 <Cale> http://en.wikipedia.org/wiki/Catalan_number
15:34:09 <int-e> In general we represent a tree rooted at n as a linked list of nodes (using the Left link as the 'next pointer') where the Right pointer of the n-th list element points to the representation of the n-th subtree.
15:34:21 <goron> Cale: And what was that about the 1/(n+1) mismatch?
15:34:33 <goron> Cale: Was that an error?
15:34:44 <Cale> goron: it's that your paper counts the root node
15:35:14 <goron> Cale: And the formula on wikipedia doesn't?
15:35:19 <int-e> the resulting tree will have a leaf for every node in the original tree, except for the root.
15:35:43 <Cale> goron: well, it's an off-by-1 thing, your paper is showing f(n-1)
15:40:36 * int-e makes stupid off-by-one errors, too.
15:41:03 <Cale> goron: so the paper is right, it's just counting differently
15:41:40 <goron> Is there also a more simple way to understand why I have to divide by n?
15:41:47 <int-e> that should be 'a leaf for every node including the root node (obviously, look at what happens for the empty tree)', and thus one fewer internal nodes.
15:42:12 <Cale> goron: there are two proofs on that page
15:42:27 <Cale> er 3
15:43:12 <int-e> the second proof is nice, and fairly easy to understand.
15:43:48 <int-e> And it can be applied directly to the paper, without resorting to binary trees.
15:45:24 <int-e> (interpret 0 in those strings as 'right' and 1 as 'up')
15:47:16 <goron> Can't it be explained like: for the first position there are 2n-2 possibilities, etc. And then incorporate the 1/n term?
15:47:18 <int-e> ok, there's a slight off-by-one confusion in that paper ... the string should have (n-1) ones and (n-1) zeros for that formula to be correct; which is consistent with the remark right after A Tree encoding with (T,\pi)
15:51:55 <goron> int-e: The first and last number are always the same (being one and zero resp.) So there's nothing wrong with that.
15:52:07 <goron> They don't store that, so they need (2n-2)
15:52:24 <goron> int-e: But maybe that's what you said?
15:55:15 <int-e> goron: look at figure 3; that tree has 8 nodes; the corresponding string, 00110100011011 has 14 digits.
15:56:33 <int-e> goron: there are 2 digits for every node (one (0) coming in from above and one (1) leaving upwards) except for the root.
15:57:59 <int-e> goron: these are still subject to the condition that the first bit is always 0 and the last is always 1.
16:00:23 <goron> int-e: yes, but what does this have to do with the 1/n term? I really don't see why the answer isn't 2n-2;n-1.
16:00:46 <goron> E.g. when you move away from trees, and only consider the bitstring.
16:01:04 <goron> The bitstring being 0--somenumbers--1
16:01:30 <int-e> goron: 2n-2;n-1 would include 1111111000000, 1100111000, 0001111010 and many more strings that don't correspond to a tree like in that construction
16:02:07 <goron> int-e: Oh, ok. So a complete linear tree would be illegal?
16:02:27 <int-e> goron: a complete linear tree would be 00000001111111
16:02:45 <int-e> goron: a one level tree would be 01010101010101
16:02:51 <goron> int-e: Oh, ok the point is that you first have to use the 0000.
16:02:58 <goron> And that's the Catalan property.
16:03:12 <goron> You have to use a zero before you can use a one.
16:03:13 <int-e> goron: but no prefix of the string can contain more 1s than 0s.
16:03:30 <int-e> right
16:04:25 <int-e> [reversing the construction for the string, that would require moving up from the root node]
16:05:00 <goron> Is there an expression in English to say that you finally understand something?
16:05:35 <stepcut> eureka!
16:05:38 <stepcut> :p
16:06:01 <goron> Isn't that Greek?
16:06:09 <int-e> 'I got it now'?
16:06:12 <stepcut> I believe so
16:06:15 * int-e isn't a native speaker either ;)
16:06:22 <stepcut> Archimedies or something...
16:06:45 <goron> Archimedes, yes,
16:07:23 <goron> When he discovered that the water level rised when he got in the bath proportionally to the volume.
16:07:50 <goron> He ran naked through town towards the king, or something like that.
16:07:53 <SamB> oh, I see now!
16:08:08 <SamB> or what int-e said
16:08:11 <int-e> It's all clear now!
16:08:28 <SamB> or maybe "now I get it!"
16:08:44 <goron> There's a lot of hidden information in papers.
16:08:45 <stepcut> there is also, 'The light dawns or marblehead', but that is usually used to refer to others, not yourself
16:08:58 <stepcut> *on* marblehead
16:09:09 <goron> In Dutch we have "The quarter has fallen".
16:09:45 <int-e> Is it 'Groschen' or something similar in Dutch, too?
16:10:14 <SamB> goron: is it hidden between the lines?
16:10:14 <stepcut> 'marblehead' being the east most point in massachusettes
16:10:20 <stepcut> (or something like that)
16:10:23 <goron> Groschen? It's a 0.25 guilders coin.
16:10:48 <Heffalump> was :-)
16:10:51 <goron> SamB: You are being funny?
16:10:54 <int-e> Interesting.
16:11:00 <Heffalump> you have nice fluffy euros now ;-)
16:11:16 <goron> rofl "fluffy"
16:11:33 <SamB> goron: I hope so ;-)
16:11:51 <goron> SamB: Well, that joke wasn't that good. Try again.
16:11:51 <int-e> we used to call the 10-Pfennig coins 'Groschen'.
16:12:25 <SamB> goron: yeah, well, I pride myself on my awful jokes ;-)
16:12:36 <goron> int-e: You had those gigantic coins IIRC.
16:13:05 <Cale> JRegex is cute
16:14:08 <goron> Hmm, I don't know. It has this evil letter J inside it.
16:14:41 <goron> no nonsense webpage though.
16:14:43 <goron> :)
16:15:01 <Cale> Well, as long as it stands for John and not Java :)
16:15:12 <StevenG> Hey all, i am having trouble compiling a haskell program on a different unix box
16:15:34 <Cale> what's the error?
16:15:38 <StevenG> Its importing Data.Map ok here but there, it says it cant find it
16:15:40 <StevenG> ?
16:15:49 <goron> Copyright 2000-2002 S. A. Samokhodkin
16:15:53 <Cale> what version of GHC is on the box?
16:15:58 <goron> Or maybe that's only the webpage.
16:16:01 <StevenG> 6.4 here
16:16:06 <StevenG> 6.2.1 there
16:16:13 <int-e> goron: hmm. The 50 Pfennig coin was actually smaller than the 10 Pfennig one, so yeah.
16:16:23 <Lemmih> StevenG: Data.Map is new in 6.4
16:16:27 <Cale> StevenG: yeah, Data.Map is new
16:16:33 <Cale> heh
16:16:37 <StevenG> shite
16:16:46 <goron> int-e: I do recall something like that yes. We found it stupid that the bigger coins had less value.
16:16:48 <StevenG> what can i do then hehe
16:16:54 <Cale> so if you can, just get a new binary
16:17:21 <int-e> goron: http://www.bundesbank.de/bargeld/bargeld_faq_dmmuenzabbildungen.en.php?print=no
16:17:21 <StevenG> not possible as this is for an assignment
16:17:31 <StevenG> where the guy compiles on 6.2.1 hehe
16:17:32 <StevenG> :S
16:17:37 <goron> Binary compatibility is non-existent in GHC.
16:17:42 <Cale> if not, and if the program is sufficiently small, you could rewrite it to use Data.FiniteMap
16:17:49 <Lemmih> StevenG: http://www.cs.uu.nl/~daan/ddata.html
16:18:19 <Cale> ah, that will likely do the trick :)
16:18:39 <Lemmih> Did Daan Leijen attend ICFP'5?
16:18:45 <Heffalump> yes
16:18:47 <Heffalump> he was HW chair..
16:18:59 <Lemmih> ah.
16:20:32 <goron> Any irssi user among you?
16:20:38 <Heffalump> me
16:20:42 <Lemmih> And me.
16:20:49 <goron> How can I leave with a message?
16:21:02 <Heffalump> leave the channel or leave IRC?
16:21:11 <Heffalump> "/part foo" or "/quit foo" respectively.
16:21:29 <goron> Hmm, I always did /leave
16:21:32 <Heffalump> or "/disconnect foo" if you just want to disconnect from this server
16:22:12 <goron> Ok, that worked.
16:47:51 <dons> moin
16:49:03 <Lemmih> 'morning, dons.
16:50:54 <araujo> Hello dons!
16:57:34 <dcoutts> dons, Lemmih, good morning hIDE hackers!
16:59:22 <dons> morning dcoutts!
16:59:28 <dons> @localtime dcoutts
16:59:31 <lambdabot> Local time for dcoutts is Tue Oct 18 01:00:27
17:00:01 <dcoutts> dons, well technically it's morning :-)
17:00:06 <dons> indeed!
17:00:37 <dons> btw guys, as paolo pointed out in an email to me, the yi plugin is broken because yi changed its interface. busy hacking this now though..
17:00:45 * dcoutts is working late on some graph algorithms
17:01:14 <dcoutts> dons, ok good good
17:06:05 * Lemmih wonders what to hack next in hIDE.
17:06:40 <dons> Lemmih, we have a todo list ;)
17:07:13 <Lemmih> We do?
17:07:14 <dons> a nice interface to the abstract syntax tree of the buffer?/
17:07:25 <Speck> hey, I'd like to help hacking on hIDE, but I think it would be nice for me to start out by hunting bugs... is there any kind of bug tracking system for hIDE?
17:07:36 <dons> with support for generic/SYB-style traversals to find various bits of info
17:07:51 <dcoutts> gour wanted to set up Trac for us
17:07:58 <Speck> I think it's a good idea
17:08:01 <dcoutts> it's a bug tracking thingy
17:08:01 <dons> in that way, the underlying parser framework could be reused for multiple interesting plugins, just by writing an SYB traversal
17:08:10 <dons> oh, what about bark?
17:08:10 <Speck> I like Trac
17:08:19 <Speck> but yeah, bark would be more haskell-y
17:08:26 <dcoutts> dons, I don't really mide, so long as something works
17:08:29 <dons> well, as long as something is set up I don't mind so much
17:08:37 <dcoutts> Trac uses darcs :-)
17:08:50 <dons> ok, that's good enough :)
17:09:09 <dcoutts> Speck, Lemmih, you could start hacking on project/build management
17:09:19 <dons> Lemmih, well, we have a list of plugins todo : http://www.haskell.org/hawiki/hIDE_2fDesign
17:09:23 <dcoutts> I've got some ideas about how that should work
17:09:25 <dons> and more ideas should be added
17:09:39 <Lemmih> dons: I still haven't been able to run hIDE with GHC-6.5
17:09:55 <Speck> dcoutts: I'm actually having trouble still getting everything to compile, but you can run it by me say later this week?
17:10:03 <dons> haven't been able to run it at all?
17:10:08 <dcoutts> Speck, sure, just prod me
17:10:26 <dons> I run it with paprika$ ls -sal `which ghc-6.5`
17:10:26 <dons> 4 -rwxr-xr-x  1 dons  dons  298 Aug 19 11:14 /home/dons/bin/ghc-6.5
17:10:38 <Lemmih> dons: hs-plugins segfault when it tries to grab the global pkg config.
17:10:46 <dons> oh that bug. hmm.
17:10:59 <dcoutts> Lemmih, we ought to be able to do jump to definition or jump to documentation quite easily now, using the info from ghc-api (ie without having to make a hoogle-like index).
17:11:00 <dons> i'd forgotten about that. we need a bug tracker!
17:11:20 <dons> dcoutts, yes.
17:11:29 <Lemmih> I'm building a more recent version of 6.5 now. Maybe it was just a glitch.
17:11:34 <dcoutts> Lemmih, I'll need to add a function to the ide shell to allow you to jump to a new page url.
17:11:40 <dons> Lemmih, is the abstract syntax and other ghc data structures easily available to other plugins?
17:11:48 <Lemmih> dons: Nope.
17:11:52 <dcoutts> jump to definition should be very useful
17:11:57 <Lemmih> dcoutts: ghc-api is pure evil (:
17:12:03 <dcoutts> Lemmih, heh
17:12:14 <dons> hehe
17:12:25 * Lemmih wants to play with Cabal and the bytecode compiler/interpreter.
17:12:46 <dcoutts> I've nearly finnished implementing page history so then we'll be able to jump to definition and jump back really easily/quickly.
17:12:55 <dons> ideally, I'd like to be able to access the abstract syn as easily as the buffer itself
17:13:07 <dons> just grabbing an MVar would be nice
17:13:23 <dons> Lemmih, a ghci plugin would be really cool
17:13:38 * dcoutts is somewhat sceptical about a ghci plugin
17:13:42 <dons> an interface to the bytecode interpreter, as you say.
17:13:49 <dons> dcoutts, elisp for haskell!
17:14:01 <dcoutts> I think the linker scope issues are more complicated than it looks
17:14:06 <dons> true.
17:14:34 <dcoutts> I think building via cabal is more important than ghci features
17:14:40 <dcoutts> but that's just my opinion
17:14:42 <Lemmih> We should still be able to run Setup script without problems.
17:15:51 <dons> I see Lemmih's todo list is empty on http://www.haskell.org/hawiki/hIDE_2fDesign :)
17:15:53 <StevenG> Anyone in here know what the main difference between the type system in haskell is and java 1.5's use of generics?
17:16:08 <dons> StevenG, there's a paper on this! let me see...
17:16:38 <dons> "A Comparative Study of Language Support for Generic Programming"
17:17:01 <dons> Garcia, Jarvi, Lumsdaine, Siek, Willcock
17:17:10 <dons> OOPSLA 2003
17:17:30 <dons> this is quite a good paper for exactly the question you ask. they have tables!
17:18:03 <StevenG> hehe
17:18:08 <StevenG> how would u sum it up dons?
17:20:34 <StevenG> the main difference between java and haskell for generics
17:20:35 <StevenG> ?
17:21:00 <dons> check the paper! ;)
17:21:22 <dons> haskell does more things, iirc
17:21:34 * dcoutts is not suprised by that
17:25:57 <dons> http://www.css.tayloru.edu/~btoll/f03/310/res/r/p115-garcia.pdf
17:26:34 <dons> page 3 has fun tables, StevenG, showing the different features and which languages support them
17:26:59 <JKnecht> Actually SIGPLAN Notices ("A Comparative Study of Language Support for Generic Programming")
17:27:00 <dons> they then implement a generic graph library in all the languages they study, and show the code
17:28:45 <JKnecht> And doesn't appear to compare CLOS, a glaring oversight.
17:30:57 <dons> is it widely used?
17:32:32 <JKnecht> does that matter. C# over CLOS?
17:32:52 <JKnecht> s/matter./matter?/
17:33:44 <JKnecht> Especially as the OO mechanism in CLOS is based on generic functions a sharp distinction from other OOP.
17:34:15 <dons> are these generic functions in the haskell sense, or the parametric polymorphic sense some other languages use for the term "generic"
17:34:52 <JKnecht> I'm not familiar enough w Haskell to answer that yet.
17:35:08 <dons> I think the term 'generic' is widely overloaded
17:35:32 <dons> often it is used just to mean what haskeller's would call parametric polymorphism, which is old news :)
17:36:38 <dons> so i'm wondering if CLOS generic functions are in fact (just) polymorphic functions
17:37:37 <dons> in Java, for example, a (boring ;) polymorphic function is called a 'generic method'
17:37:50 <dons> though it has nothing to do with the 'generics' of the paper I cited
17:38:04 <JKnecht> No it's definitely not like that.
17:38:46 <JKnecht> In fact with the MOP, I suppose the CLOS programmer could claim to be able to implement any OO scheme whatever.
17:39:05 <mauke> I think it's like this
17:39:33 <mauke> in java, obj1.foo(obj2) looks at the dynamic type of obj1 and the static type of obj2 to resolve the call to foo
17:40:11 <mauke> in lisp, (foo obj1 obj2) uses both objects because methods aren't part of any class
17:41:49 <dons> now though, 'generic programming' in the sense of the paper, is code where you have *type* arguments to data structures and functions
17:42:16 <Heffalump> it's quite funny how differently 'generic' is used in a functional and in an OO context
17:42:22 <dons> usually realised with some hard type hackery
17:43:08 <Heffalump> In OO, it just means parametric polymorphism which FP just sort of treats as obvious, reserving generic for the scary polytypic stuff.
17:43:30 <dons> right.
17:43:57 <StevenG> The second convenience issue is that clients of a polymorphic
17:43:57 <StevenG> function must declare their types to be instances of the type classes
17:43:57 <StevenG> used as constraints on the polymorphic function.
17:43:57 <dons> this is one of the funnier points of the above paper actually :)
17:44:02 <StevenG> what does this mean?
17:44:30 <dons> hehe
17:45:35 <StevenG> ??
17:45:38 <StevenG> im confused
17:45:39 <StevenG> hehe
17:46:09 <dons> well, there's about 5 different distinct concepts in that sentence you'll need to understand before you can plug them all together :)
17:46:17 <StevenG> what does it mean by clients of polymorphic function ?
17:46:29 <StevenG> what is a client of a function hehe
17:46:30 <StevenG> :P
17:46:32 <dons> callers, I imagine
17:46:33 <mauke> callers of a function
17:46:44 <dons> @karma+ mauke
17:46:45 <lambdabot> mauke's karma raised to 1.
17:46:46 <dons> ;)
17:46:48 <mauke> e.g. something like find
17:46:54 <mauke> @type find
17:46:59 <lambdabot> bzzt
17:47:08 <mauke> @type List.find
17:47:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:47:16 <mauke> ah, no
17:47:30 <mauke> what's a good example?
17:48:18 <dons> length?
17:48:22 <dons> id?
17:48:32 <mauke> @type List.elemIndex
17:48:34 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
17:48:52 <mauke> Eq is a type class, (Eq a) => is a constraint
17:49:04 <dons> ah, I see what you're doing
17:50:14 <mauke> elemIndex val list returns the index of the first occurrence, if any, of val in list
17:50:39 <mauke> to use elemIndex with a list of your own type, you have to implement the Eq interface
17:53:26 <JKnecht> "Generics for the Masses" seems to be the right medicine :)
17:53:50 <Frederick> Philippa, Ive advanced a bit :D
17:54:42 <Frederick> guys how do I stop ghc?
17:55:06 <Lemmih> C-c
17:56:37 <dons> unplug your machine, it's the only way to stop it!
17:56:40 <Frederick> didnt work
17:56:42 <Frederick> dons, sure
17:56:45 <dons> otherwise, it will breed and take over the world!
17:57:01 <dons> pkill ghc ?
17:57:03 <Lemmih> killall ghc-[your-version]
17:57:13 <dons> oh, maybe pkill == killall on linux
17:57:23 <mauke> try C-z or C-\
17:57:24 <Frederick> dons, im on user account
17:57:28 <SyntaxNinja> it's using bits while we waste our time debating between killall and pkill!
17:57:41 <dons> oh no! QUICK!
17:57:41 <SyntaxNinja> quick, what's your root password?! :)
17:57:56 <JKnecht> you should still be able to kill process. Try top.
17:58:06 <Lemmih> Hi SyntaxNinja.
17:58:08 <Frederick> I want to stop ghci in fact
17:58:15 <SyntaxNinja> hi Lemmih
17:58:21 <Lemmih> ghci == ghc.
17:58:27 <SyntaxNinja> Frederick: did you try control-c?
17:58:40 <Frederick> SyntaxNinja, I belive there is an elegant way
17:58:49 <SyntaxNinja> control-d?
17:59:16 <Frederick> does ghc has manpages?
17:59:33 <SyntaxNinja> it does, but the online manual has much more info
17:59:39 <JKnecht> I want to believe.
17:59:54 <Frederick> :quit
18:00:11 <JKnecht> same as Hugs?
18:00:13 <mauke> :wq
18:00:29 <SyntaxNinja> control-d works too.  I think if you had said, "how do I quit from ghci" you might have gotten a better answer :)
18:01:11 <SyntaxNinja> Lemmih: how's it going?
18:04:27 <Lemmih> SyntaxNinja: Great. Been working a lot on an old project I digged up lately (:
18:05:08 <SyntaxNinja> cool
18:05:14 <Frederick> does anyone here uses gentoo?
18:05:17 <dons> Lemmih, what's that then?
18:05:33 <dons> triple_, hi! learning haskell?
18:06:05 * dons is trying to extend the .au haskell community, with hopes for AuHaskell one day :)
18:06:19 <triple_> in between studies for the last couple of weeks, yeah
18:06:26 <dons> where are you studying?
18:06:39 <triple_> swinburne, hawthorn
18:06:57 <triple_> melbourne
18:06:57 <dons> ah, cool. do they teach haskell there, or are you picking it up in your spare time?
18:07:03 <triple_> spare time
18:07:13 <dons> doubly cool :)
18:07:18 <triple_> i think they still teach haskell at monash though
18:07:32 <dons> yep, I think so. and several other places in .au
18:07:46 <Lemmih> dons: A DirectConnect client.
18:08:00 <triple_> ah cool
18:08:17 <Pseudonym> Woohoo, Melbourne!
18:08:27 <dons> triple_, have you been in #haskell before? would you like the tour
18:08:30 * Pseudonym works at RMIT
18:08:42 <triple_> i've been idling for the last 10 days or so
18:09:05 <dons> ah, so you know all about the world famous (and australian ;) lambdabot?
18:09:15 <dons> hehe
18:09:17 <triple_> indeed i do :)
18:09:25 <dons> also, the haskell wiki?
18:09:27 <dons> @hawiki
18:09:28 <lambdabot> http://www.haskell.org/hawiki/
18:09:43 <dons> also, as you can see in the topic, we have logs of this channel
18:09:56 <triple_> ah, nice
18:10:10 <dons> quite a lot of the harder discussion that takes place here ends written up on the wiki
18:10:28 <dons> now, what else is in the official tour. hmm, did I miss anything?
18:10:45 <dons> oh, I guess we also have:
18:10:46 <dons> @map
18:10:47 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
18:10:56 <dons> so you can see you're not alone down south ;)
18:11:29 <triple_> heh, good to know :) seems a rare thing around freenode
18:12:25 <dons> so feel free to just hang out, or ask any questions :)
18:12:39 <dons> the wiki has lots of good material if you're just learning haskell, too
18:12:42 <triple_> will do, thank you
18:33:14 <dons> @seen dcoutts
18:33:14 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-blah and #haskell. Last
18:33:14 <lambdabot> spoke 1 hour, 11 minutes and 39 seconds ago.
18:36:05 <dcoutts> dons, pong
18:36:51 <dons> just wondering a bit about the EditorPage api.
18:36:55 <dons> 1) why not make it a class?
18:37:09 <dcoutts> because of the forall buisness
18:37:27 <dons> do we need type hackery to create such a class? or is it not even possible?
18:37:51 <dcoutts> I need to have collections of EditorPages from different sources
18:38:16 <dons> right, i understand the need to locally quantify the state types, but you say we can't do this in a class at all?
18:38:30 <dons> ah, maybe we associated types or functional deps
18:38:50 <dcoutts> possible with some different kind of type hackery :-)
18:38:51 <dons> it looks like how we use functional deps with existential wrappings on the MODULE type in lambdabot, in fact
18:38:55 <dons> right.
18:39:03 <dons> ok, that's cool. this is the lightweight option
18:39:11 <dcoutts> it actually doesn't need to be a data type at all
18:39:30 <dcoutts> it can just be a function for constructing some opaque thing
18:39:39 <dcoutts> and then we can easily provide variants
18:39:43 <dons> 2) is there any requirement that I let hIDE know about Yi's use of TextView's as buffers?
18:39:45 <dcoutts> eg simpler versions
18:39:54 <dons> can yiBase have a unit openPage, for example?
18:40:27 <dons> openPageView should definitely be a proper value for the yiBase plugin, but I wonder about openPage, since yi already manages its own buffers
18:40:43 <dcoutts> oh I see
18:41:36 * dcoutts consults source
18:41:52 <dons> oh, possibly I could just pass BufferRef's to the EditorPage api
18:42:05 <dons> then closePage,  hidePage and so on would work nicely
18:42:17 <dons> but yi can still actually hold the real Buffer type itself
18:42:34 <dcoutts> I imagine you'll need some per-page state
18:43:06 <dons> ah, in the localState param?
18:43:21 <dcoutts> you could instead use an IORef that the openPageView knows about
18:43:22 * dons grizzles about documentation ;)
18:43:34 <dcoutts> in whihc case the globalState could be ()
18:44:16 <dcoutts> I think the right thing to do with the EditorPage api is to provide EditorPage constructor functions
18:44:30 <dcoutts> so we can provide more/less general versions
18:44:54 <dons> oh, so what's the intention of this `globalState' value returned on openPage?
18:45:04 <dons> that's really plugin-global state?
18:45:11 * dcoutts thinks a sec
18:45:31 <dcoutts> the globalState is per-page state
18:45:40 <dcoutts> perhaps a misnomer :-)
18:45:41 <dons> ah, or am I forgetting that the EditorPage only applies to one PageView?
18:46:00 <dcoutts> right, there is an EditorPage at the end of each PageURL
18:46:01 <dons> one Window onto possibly multiple buffers?
18:46:05 <dons> ah, yes.
18:46:09 <dons> I forgot this detail.
18:46:34 <dcoutts> on top level ide shell window can browse multiple views
18:46:36 * dons quickly notes  this down
18:46:51 <dcoutts> several top level windows can look into the same buffer at once
18:47:12 <dcoutts> so for each page url there is one page 'model' and possibly several 'views'
18:47:19 <sethk> it appears that for Data.Map, show is a function that displays each element in the map.  Does that sound right?
18:48:01 <dons> @eval show (M.insert 1 'x' M.empty :: M.Map Int Char)
18:48:08 <lambdabot> "{1:='x'}"
18:48:58 <dcoutts> dons, in a sense the local/global state buisness is just there as a convenience. Internally it all gets turned into MVars and interfaces that just do IO rather than passing around state values.
18:49:02 <dons> @eval show (M.insert 2 '*' (M.insert 1 'x' M.empty) :: M.Map Int Char)
18:49:04 <lambdabot> "{1:='x',2:='*'}"
18:49:28 <dcoutts> So the most general interface is that latter stuff. The other interface is there because it is probably more convenient
18:49:35 <dons> ah, ok. it's just not clear to me yet what the localState is local to
18:49:59 <dcoutts> dons, see the Factory type & mkFactory
18:50:08 <dcoutts> dons, right sorry that wasn't very clear
18:50:18 <dcoutts> dons, I'll try to improve the names/docs
18:50:31 <dons> oh, this is the underlying code, I see.
18:50:39 <dons> I'm commenting it as I work it out :)
18:50:52 <dcoutts> dons, summary: the global is per-open-page, the local is per-open-page-view
18:51:24 <dcoutts> and pages are disting things found on the end of PageURLs
18:51:34 <dcoutts> disting/distinct
18:52:02 <dcoutts> dons, the thing I'm currently missing is a notion of the handler in these various state transitions
18:52:07 <dons> ok. cool. so per open page I probably have :: BufferRef for now (a ptr back to yi's larger state value for the page), but per-open page view i'll have a bit more state, since views are managed entirely by hIDe
18:52:20 <dcoutts> ok
18:52:48 <dons> sethk, was that what you meant?
18:53:17 <dcoutts> we want the handler/page-supplier to get told the first time it has any of the pages it supplies opened in a new window.
18:53:26 <sethk> dons, I'm trying to remember.  :)
18:53:32 <sethk> dons, let me scroll up and find what you said.
18:53:41 <dons> I asked lambdabot
18:53:51 <dcoutts> so the handler can have a per-window cache (eg the html viewer only needs on mozilla widget per-window)
18:53:57 <dons> right.
18:54:18 <dcoutts> and yi can recycle GtkTextBuffer/GtkTextViews
18:54:49 <sethk> dons, ah, yes.  I see it.  thanks
18:55:13 <dons> dcoutts, definitely.
18:55:42 <dcoutts> dons, so improving that api is on my todo list right after the page history stuff
18:55:53 <dons> ok, that's fine. no rush on this.
18:56:12 <sethk> dons, dcoutts where is the code you've been discussing?  I've been working with IORef for the past day and it sounds like there are some things you are doing that are relevant.
18:56:16 * dons goes back to splicing yi's ui into the hIDE page api
18:56:21 <sethk> I like working examples.  :)
18:56:41 <dons> sethk, there's some fairly complete IORef code in ncurses Yi
18:56:44 <dons> @where yi
18:56:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
18:56:48 <dcoutts> sethk, actually we're mostly using MVars here (due to the presence of concurrency)
18:56:50 <dons> have a look in the file Yi/Editor.hs
18:56:56 <sethk> dons, thanks, I'll look at those
18:57:01 <dcoutts> (at least I'm using MVars :-) )
18:57:08 <sethk> dcoutts, I thought MVar was strictly for concurrency control
18:57:16 <sethk> dcoutts, let me reread the library doc for it...
18:57:23 <dons> for some reason, ncurses Yi gets cited on haskell@ as some kind of canonical example of imperative programming in haskell
18:57:28 <dons> which is a bit weird, I feel. oh well
18:57:39 <dcoutts> sethk, yes, and using shared mutable state when it might get accesed from multiple threads
18:57:55 <dcoutts> actually I've been trying to eliminate may uses of MVars
18:58:14 <dcoutts> I've got a nice pattern using threads and Chan(nels)
18:58:20 <sethk> dcoutts, eventually my state will be shared so I'd be interested to see what you did.  Sounds like it might be good also for a before/after on MVars
18:59:20 <sethk> dons, got the yi source, thanks again
18:59:22 <dons> sethk, definitely have a look at yi then, shared mutable state, multiple threads attemptign to read and write. fun all day long :)
18:59:37 <dcoutts> the thread+Chan style means that you don't need MVars in lots of other structs, just the local state of a thread in an command processing loop, more like a state monad
18:59:56 <dons> well, you've got an MVar under that Chan
19:00:01 <dcoutts> yes
19:00:06 <dcoutts> but I've only got one
19:00:18 <dcoutts> rather than MVars in structs all over the place
19:00:27 <dcoutts> the code became much cleaner when I did that
19:00:45 <sethk> dons, 7295 lines in the yi .hs files
19:00:52 * SamB rearranges his (dir) node
19:00:53 <dons> crikey!
19:01:06 <sethk> probably a few comments and blanks in there, but still
19:01:21 <sethk> but don't worry, 37 lines are in examples   :)
19:01:42 <dcoutts> sloccount claims Yi is 3213 lines
19:01:56 <dons> do you count the .hsc files?
19:02:00 <dons> they contain real code
19:02:16 <dcoutts> ah, slocout probably doesn't know about .hsc
19:02:21 <dons> I thought it was more about ~5k
19:02:25 <dcoutts> it still values it at $92,444
19:02:27 <dons> ~4k comments
19:02:33 <dons> oh boy
19:02:46 <dons> I got paid about 1/8th of that to write Yi :S
19:02:54 <dcoutts> that assumes that someone would want to pay for the thing :-)
19:03:18 <dons> good point
19:03:59 <dons> huh, Curses.hsc is > 2k
19:04:01 <SamB> isn't that the maintenance bill?
19:04:32 <dcoutts> dons, and apparently you should have been getting paid $56,286 a year :-)
19:04:46 <dons> I'll raise this with my supervisor
19:04:54 <dcoutts> heh
19:05:34 <Lemmih> Development cost of GHC: $ 3,210,325
19:06:01 <SamB> does that count all the strange files?
19:06:16 <sethk> 2872 lines of .hsc
19:06:21 <sethk> that's just raw line count
19:07:35 <dons> in Yi?
19:11:52 <lispy> SamB: define strange file
19:12:08 <lispy> SamB: is that xml?
19:12:33 <SamB> lispy: well, there are a bunch of unusual source files in GHC, aren't there?
19:12:34 <dcoutts> lispy, .cmm, various prim .txt files that need preprocessing
19:12:45 <lispy> ah
19:12:52 * lispy is ignorant of GHC internals
19:12:56 <SamB> yeah, those ones!
19:13:00 * SamB is lagged
19:13:16 * SamB too, but he looked at some stuff about them once or twice
19:13:35 <Lemmih> Heh. It estimates the hIDE effort to three person-months (:
19:14:06 <dons> so 1 month for 3 of us?
19:14:22 <dcoutts> that's not bad going for 3 people working on and off for 2 weeks :-)
19:14:33 <lispy> dons: don't you have to double it when you have more than 1 person? ;)
19:14:38 <Lemmih> It's pretty acuate (:
19:15:52 <Lemmih> *accurate
19:27:50 <dons> nothingmuch, have you seen:
19:27:52 <dons> @map
19:27:53 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
19:27:58 <dons> perhaps you should add your details?
19:28:08 <nothingmuch> sure
19:28:15 <dons> inline lambdabot calls would be nice, methinks.
19:28:21 <dons> what syntax did we propose? anyone remember?
19:28:28 <dons> was it @@foo ? or @foo@ ?
19:28:35 * nothingmuch didn't know he counted as a #haskell user... i would think you'd have to talk more often ;-)
19:28:53 <dons> nothingmuch, I see you around fairly often though
19:29:18 <dons> it seems around 45% of users talk enough for me to notice them, which leaves 55% who idle
19:29:27 <dons> that's my impression after chasing up these details
19:29:38 <Speck> dons: I think there should be something on either side because lambdabot calls can take arguments
19:29:43 <dons> I know shapr's previously guesstimated 1/3 to 2/3
19:29:43 <nothingmuch> so I just add myself to the wiki?
19:29:56 <dons> nothingmuch, yes!
19:30:02 <dons> it'll update the map automagically
19:30:09 <dons> Speck, good point
19:30:21 <nothingmuch> moinmoin's buttons are so unexplanatory
19:30:34 <nothingmuch> i have to mouse over them each time and go to the status bar to see what the resulting URL will be
19:30:49 <dons> something like @foo x y z@ ? with no nesting.
19:31:07 <dons> otherwise we'd be restricted to -- style
19:31:12 <dons> rather than {- -} style
19:31:25 <nothingmuch> the clock seems to be off on the server
19:31:43 <dons> @localtime nothingmuch
19:31:46 <lambdabot> Local time for nothingmuch is Tue Oct 18 04:31:22 2005
19:31:50 <dons> @localtime dons
19:31:58 <lambdabot> Local time for dons is Tue Oct 18 12:35:45 2005
19:32:02 <nothingmuch> gmt + 3 is 05:11 on the server
19:32:11 <Lemmih> @localtime Lemmih
19:32:15 <lambdabot> Local time for Lemmih is Tue Oct 18 04:34:26 2005
19:32:20 <dcoutts> @localtime dcoutts
19:32:23 <lambdabot> Local time for dcoutts is Tue Oct 18 03:33:19
19:32:29 <dcoutts> yep
19:32:40 <dons> Lemmih's drifting slightly too
19:32:50 <dons> hmm. maybe we need ntpd-irc :)
19:33:06 <dons> lambdabot can adjust your clock, over ctcp pings
19:33:13 <dcoutts> heh heh
19:33:33 <nothingmuch> what math does ntpd use?
19:33:45 <dons> a lot of math, iirc. check the spec. it's huge
19:35:14 <nothingmuch> done
19:35:20 <nothingmuch> no thanks ;-)
19:35:59 <dons> the map will update in 4 minutes
19:36:07 <nothingmuch> huraah
19:38:34 <dons> nothingmuch, we'll see if the degrees/minutes notation works..
19:38:52 <dons> I think it does, but we may have to rephrase it as decimal
19:38:54 <nothingmuch> oops, i didn't realize i did that
19:39:08 <dons> should be ok, no parse error yet
19:39:46 <nothingmuch> oh fsck, i misaligned it
19:40:02 <nothingmuch> woo! it worked!
19:41:08 <dons> oh, you're in israel?!
19:42:02 <dons> why is your local time the same as Lemmih's?
19:43:15 <dons> but this is cool, we further extend the reaches of #haskell :D
19:43:33 * nothingmuch can't find Lemmih on the map
19:43:44 <nothingmuch> too dyslexic
19:43:54 <nothingmuch> oh! is that Denemark?
19:44:03 <Lemmih> Yep.
19:44:05 <nothingmuch> anyway, israel has completely fucked up DST poilicy
19:44:06 <nothingmuch> ies.
19:44:10 <dons> ah!
19:44:19 <dons> now it makes sense
19:44:36 <dons> i'll tweak the .eu map slightly so the eastern mediterranean fits in
19:44:36 <nothingmuch> they finally fixed it now
19:44:57 <nothingmuch> it used to be so that it's decided on every year on a case by case basis
19:45:04 <nothingmuch> but i think starting this april it won't be
19:45:06 <dons> hehe
19:45:25 <nothingmuch> all the geeks here always joke that the GNU zone info file should have a neural net to emulate our parliament
19:45:40 <dons> ah, so this also means that degrees/mins/secs notation works
19:45:43 <nothingmuch> Israel adopts Daylight Saving Time on the last Friday before April 2 at 02:00, and returns to standard time at 02:00 of the Sunday of the month of Tishrei between Rosh Hashanah and Yom Kippur
19:45:45 <dons> hehe
19:45:47 <nothingmuch> http://en.wikipedia.org/wiki/Daylight_Saving_Time
19:45:59 <nothingmuch> http://en.wikipedia.org/wiki/Israeli_Daylight_Savings_Law
19:46:26 <sethk> nothingmuch, which of the five books has the daylight savings calendar?
19:46:36 <nothingmuch> sethk: five books?
19:47:31 <sethk> nothingmuch, a joke.  You know, where the kosher laws are?
19:47:43 <nothingmuch> oh
19:47:46 <nothingmuch> nope =)
19:47:53 * nothingmuch is not really in touch with judaism
19:48:11 <nothingmuch> i had about enough at my bar mitzva
19:48:49 <JKnecht> is the map supposed to show everybody on this channel?
19:50:53 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051011"]'
19:50:53 --- topic: set by CosmicRay on [Tue Oct 11 09:43:45 2005]
19:51:32 <JKnecht> just wanted to know if something was reading the ip addresses thru freenode to update the index.
19:51:39 <nothingmuch> darnit, i keep running out of HD space on my perfectly legal downloads disk
19:51:57 <Julian> Hi folks
19:52:01 <nothingmuch> hi Julian
19:52:02 <JKnecht> with geocodes from the ip addresses.
19:52:05 <dons> JKnecht, no nothing that evil :)
19:52:21 <nothingmuch> that wouldn't be very accurate
19:52:29 <dons> Julian, another .ar person!
19:52:30 <dons> @map
19:52:31 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
19:52:35 <dons> :D
19:53:48 <Julian> yea
19:53:51 <Julian> Argentina
19:53:55 <nothingmuch> crap, LVM can't extend a stripped LV unless data PEs are available on both physical disks
19:54:25 <dons> Julian, if you like, you may want to add your details to the map page above
19:54:58 <Julian> Rosario
19:55:00 <Julian> Argentina
19:55:15 <Julian> ok
19:55:30 <dons> just add the latitude and longitude to the wiki page
19:56:03 <dons> there's quite a few from .ar, I didn't realise till we started working on the map
19:56:05 <nothingmuch> dons: if you like, perlmonks had a project that would also guess based on the city
19:56:17 <dons> guess based on a city?
19:56:23 <nothingmuch> long/lat
19:56:26 <dons> guess the what?
19:56:38 <dons> why guess? you can use maporama or google maps
19:56:43 <nothingmuch> http://desert-island.dynodns.net/perl/pmplanet.html
19:56:44 <Julian> Nomius??
19:56:47 <dons> guess the city from the ip addr, that would be fun
19:56:49 <Julian> I know him
19:56:56 <dons> ah!
19:57:00 <Julian> lol
19:57:04 <dons> @seen Nomius
19:57:05 <lambdabot> Nomius is in #Haskell. I don't know when Nomius last spoke.
19:57:33 <Nomius> I spoke here on sunday :)
19:57:33 * nothingmuch wonders where the nearest router is
19:57:41 <nothingmuch> a few years ago it was in Rehovot, which is 80km away
19:57:50 <Julian> Che Nomius
19:57:52 <Julian> te conozco
19:58:03 <Nomius> Or Saturday? Can't remember very well :P
19:58:04 <nothingmuch> hah
19:58:09 <Nomius> Julian, ok
19:58:13 <nothingmuch> now it's Carmiel, which is around 300KM away
19:58:16 <Julian> de la facu che
19:58:30 <Nomius> Ah, Julian
19:58:31 <Nomius> Hola
19:58:38 <Julian> lol
19:58:54 <Julian> supongo que con el espanol aca se van a cortar
19:59:19 <Julian> @seen Julian
19:59:20 <lambdabot> You are in #haskell. Last spoke just now.
19:59:22 <Nomius> Aha
19:59:31 <Julian> buaz
20:00:16 <Nomius> You should speak english here :)
20:00:26 <dons> @babel es en supongo que con el espanol aca se van a cortar
20:00:27 <lambdabot>  I suppose that with espanol aca is going away to cut
20:00:33 <dons> hehe
20:00:45 <Nomius> dons, last time I spoke here was with you :-P
20:00:56 <dons> true :)
20:01:01 <Nomius> We talk about the xplanet in haskell.org :D
20:01:12 <Julian> lol
20:01:13 <dons> on no!
20:01:26 <dons> i do talk about other things :)
20:01:29 <nothingmuch> dons: btw, theorbtwo and castaway, who operate pmplanet lurk in #perl6
20:01:42 <nothingmuch> IIRC they shared the code, but I have no idea where now
20:01:44 <dons> ah, i've seen theorbtwo here as well
20:01:47 <Nomius> dons, you should :-P
20:01:54 <nothingmuch> the link to the script is forbidden right now
20:02:17 <JKnecht> @babel Dong Bu Dong Zhong Wen, Pu Tong Hua?
20:02:18 <lambdabot> module "babel" screwed up: Error: Language Dong not supported
20:02:32 <dons> JKnect, you have to add the two language paramaters first
20:02:34 <dons> @help babel
20:02:35 <lambdabot> usage: babel lang lang phrase
20:02:44 <dons> but it's quite a restricted set of languages
20:03:03 <dons> @babel
20:03:04 <lambdabot>  bzzt.
20:03:05 <dons> @babel help
20:03:06 <lambdabot>  usage: babel lang lang phrase
20:03:11 <dons> bah
20:03:12 <JKnecht> @babel zh en Dong Bu Dong Zhong Wen, Pu Tong Hua?
20:03:14 <lambdabot>  Dong Bu Dong Zhong Wen, Pu Tong Hua?
20:03:24 <Julian> @babel lambda C (\x.x)
20:03:25 <lambdabot> module "babel" screwed up: Error: Language lambda not supported
20:03:28 <Julian> hehehehe
20:03:32 <dons> zh is supposedly supported, but we've never been able to make it work
20:03:37 <Speck> JKnecht: why would you say "zhong wen" and "pu tong hua"?
20:03:40 <sethk> all, in an instance declaration where you are defining a function on a type with constructors, you use patterns as you would in a function or case?
20:03:40 <dons> Julian, lol!
20:03:56 <Julian> dons: burned
20:04:19 <JKnecht> Because my Mandarin is about as advanced as my Haskell at this moment :)
20:05:00 <Speck> wo kan le
20:08:23 <sethk> hmm, Pattern bindings (except simple variables) not allowed in instance declarations
20:08:30 <sethk> how do I get around that
20:08:39 <Julian> Nomius: I'm working now in a interactive theorem assistant, based on type theory
20:08:40 <dons> bind on the right hand side?
20:09:06 <sethk> dons, no, left.  It's an enumeration (constructors with no args like False and True for boolean)
20:09:21 <sethk> data ThingType = Permanent | Temporary
20:09:22 <dons> no, I'm saying work around it by binding on the rhs.
20:09:24 <dons> or use case
20:09:35 <dons> f x = case x of A -> ; B -> ...  ...
20:09:57 <Julian> curry-howard isomorphism more indeed
20:10:01 <dons> pattern matching all compiles to case anyway
20:10:04 <sethk> case I understand.  I don't know what you mean, though, about binding on the right side
20:10:09 <dons> Julian, like twelf?
20:10:23 <Julian> i dont know twelf
20:10:27 <dons> oh, sorry sethk, maybe I misunderstand. do you have an example?
20:10:37 <dons> twelf is a theorem prover based on type theory
20:10:44 <Julian> let me see
20:10:47 <dons> for proving properties of languages and logics
20:10:52 <sethk> dons, actually, I had done something dumber than that, so I have it working right now.  But I'm sure I'll have a problem shortly.
20:10:55 <sethk> :)
20:11:00 <dons> from the guys who brought you ML :)
20:11:30 <dons> hi pitecus!
20:11:30 <sethk> twelf sounds like a speech impediment.  :)
20:12:04 <dons> well, it's based on LF metatheory. whose first implementatoin was ELF, iirc
20:12:09 <dons> so LF -> ELF -> Twelf
20:12:13 <dons> makes sense to me :)
20:12:54 <Julian> this its only a functional language with two data types, Either and And...
20:12:57 <dons> pitecus, I think you may be the only .ie person in all of #haskell :) welcome!
20:13:18 <sethk> dons, just because he is new, you don't have to insult him.  :)
20:13:38 <Julian> the correspondence between this language and the propositional logic
20:13:44 <dons> oh, sethk :p
20:13:46 <Julian> very simple
20:13:52 <Julian> dons: =)
20:24:36 <sethk> what's wrong with this?  I put in a "quoted string" to make sure of the type on the RHS:
20:24:42 <sethk>     show TableFile handle ttype = "hello"
20:24:46 <sethk> the type is:
20:24:52 <sethk> data CqlFile = TableFile Handle TableType
20:25:00 <sethk> and TableType has a defined show function
20:25:01 <Lemmih> show (TableFile handle ttype) = ...
20:25:07 <sethk> ok ...
20:25:34 <Megzl> Is there any cool C++ alternative besides Haskell?
20:25:42 <sethk> Megzl, cobol
20:26:02 <Megzl> no
20:26:18 <sethk> Megzl, rpg II?
20:26:20 <Lemmih> Megzl: Caml, SML
20:26:30 <Megzl> Caml or OCaml?
20:27:49 <sieni> common lisp, scheme ;-)
20:28:06 <sieni> Megzl: probably ocaml
20:28:25 <Megzl> Lisp is terrible
20:28:39 <sethk> Megzl, terrible for what?  why?
20:29:26 <Megzl> Terrible for syntax and power.
20:29:42 <Megzl> Haskell is cool cause it does things completely different from C++
20:29:50 <Megzl> Lisp isn't like that.
20:30:14 <sethk> Megzl, what I meant is that without context, your statement is meaningless
20:30:34 <sethk> Megzl, power to do what?
20:31:36 <sethk> Megzl, I agree that the function names in the usual lisp libraries are poor, but that's not a characteristic of the language itself
20:32:13 <rasterfar> Can anyone suggest a source of info on using the "higher-order fold" technique?
20:33:32 <sieni> s-expressions <3<3<3
20:36:56 <rasterfar> For instance, reverse lst = (foldr (\a f y -> f(a:y)) (\x->x) lst) []
20:38:39 <Megzl> <yome> Scheme is dynamically typed, while Haskell is statically typed.
20:38:41 <Megzl> is that true
20:38:43 <Megzl> ?
20:39:25 <rasterfar> Can anyone give takeWhile expressed as a fold?
20:39:45 <sethk> Megzl, I'm not a scheme expert.  Haskell is type safe, yes
20:40:01 <sethk> I'm not a haskell expert either, but I know the answer to that question  :)
20:40:31 <Megzl> I thought Haskell was dynamically typed.
20:40:47 <sethk> Megzl, you just said it is staticallyl typed.  Make up your mind.
20:40:56 <Megzl> No, I was quoting someone.
20:41:08 <Megzl> <yome>
20:41:13 <sethk> Megzl, sometimes people confuse the fact that types are inferred
20:41:20 <sethk> Megzl, with whether or not they are dynamic
20:41:48 <nothingmuch> good night
20:49:09 <Cale> Megzl: the difference is that Haskell determines all the types at compile time, and ensures that they are consistent. It's able to infer types, but if you add type signatures, it will check that they are appropriate.
20:52:01 <JKnecht> tries Haskelll emacs mode on Generics For The Masses code ...
20:52:20 <JKnecht> it works!
20:53:10 <JKnecht> spoke too soon.
20:54:50 <Cale> JKnecht: what counts as working?
20:55:17 <Cale> It should be able to colour it reasonably (with a few glitches)
20:55:42 <JKnecht> No it does work. I just opened the elisp sources first. When open the Masses stuff, the Haskell functionality enabled.
21:00:02 <Cale> rasterfar: sure
21:00:09 <Cale> takeWhile' p xs = foldr (\x y -> if p x then (x:) . y else y) id xs $ []
21:00:24 <Cale> same trick as above
21:00:35 <rasterfar> Ah, thanks.  I also just found dropWhile in http://www.cs.nott.ac.uk/~gmh/bib.html#fold
21:01:00 <rasterfar> (I suspected the same trick would apply; groking it is another thing...)
21:01:48 <rasterfar> Can you suggest a good tutorial on these beasts?
21:04:38 <rasterfar> Actually these two examples ought to suffice...
21:04:44 <JKnecht> I guess you need to use Stefan Monniers (el) package though if you want to run GHC or Hugs as inferior processes.
21:07:42 <rasterfar> Cale: Actually, the takeWhile' you give is filter!  How to get it to terminate early??
21:07:56 <Cale> uh, oops :)
21:07:58 <Cale> hehe
21:08:21 <Cale> you pass const [] instead, I suppose
21:09:05 <Cale> takeWhile' p xs =  foldr (\x y -> if p x then (x:) . y else const []) id xs $ []
21:09:14 <skew> takeWhile doesn't need to use higher order functions like that
21:09:15 <Cale> the lifting seems unnecessary here
21:09:19 <Cale> yes
21:09:35 <Cale> takeWhile' p xs =  foldr (\x y -> if p x then x:y else []) [] xs
21:09:41 <skew> it just makes it stricter than necessary
21:09:53 <myavuzselim> (:) :: a -> (Int -> a) -> Int -> a
21:09:55 <myavuzselim> (:) elem f = \i -> if i==0 then elem else f (i+1)
21:10:12 <rasterfar> skew: Okay, give takeWhile *as a fold* so that it doesn't!
21:10:27 <Cale> rasterfar: I just did
21:10:47 <rasterfar> oh
21:10:47 <myavuzselim> It fails saying: Type signature given for an expression
21:11:27 <Cale> myavuzselim: did you hide (:) from the prelude?
21:11:45 <skew> any operator that starts with : is a constructor anyway
21:11:47 <myavuzselim> hmm, should I?
21:11:54 <Cale> yeah, that's not going to work
21:11:56 <Cale> rename it
21:12:04 <Cale> to something not starting with :
21:12:12 <myavuzselim> I tried it with another name too.
21:12:24 <sethk> myavuzselim, no, you don't want to hide something from the Prelude unintentionally
21:13:01 <sethk> Cale, the thing I was working on yesterday with the State monad I have working now with an IORef.  I'm not sure whether I need a monad as well ...
21:13:03 <skew> for example, let {(++++) :: Int -> Int -> Int; (++++) x y = x + y} is accepted
21:13:15 <myavuzselim> can't I hold the two implementations at the same time?
21:14:00 <Cale> myavuzselim: it's actually a lexical error, because normal infix functions can't start with :
21:14:04 <skew> apparently "type signature given for an expression" is the error you get if you try to redefine an infix constructor
21:14:09 <Cale> those are reserved for data constructors
21:14:32 * rasterfar bows thanks to Cale and skew
21:14:59 <Cale> skew: you'll get it when you give a type signature for any expression at the top level
21:15:18 <Julian> @lambda (\x -> x) (\x y -> y)
21:15:19 <lambdabot> <<Plugins.Lambda.LMEngine.EvalMonad Dynamic -> Plugins.Lambda.
21:15:19 <lambdabot> LMEngine.EvalMonad Dynamic>>
21:15:24 <myavuzselim> But it's my task to make it work. I should change the language such that [a] and Int -> a are equivalent.
21:15:48 <Cale> myavuzselim: and you can't overload names arbitrarily like that in Haskell.
21:16:02 <skew> then you need to hide the built in definition
21:16:17 <glguy> Any recommendations on common books on Haskell I should search my library for?
21:16:26 <myavuzselim> I know, but if I can make it work, [a] and Int -> a will be the same
21:16:34 <Julian> Richar Bird....
21:16:36 <Cale> myavuzselim: You won't be able to define an infix function named (:) which isn't a data constructor.
21:16:46 <Julian> Introduction to Functional Programming
21:16:46 <sethk> glguy, the books by Hudak is good
21:16:49 <Cale> Richard*
21:16:52 <sethk> glguy, also...
21:16:59 <Julian> Cale: yea yea dude
21:17:02 <Julian> Cale: =)
21:17:12 <sethk> glguy, also the Thompson book.
21:17:22 <sethk> glguy, the Hudak is a bit newer; I like both
21:17:26 <glguy> There are many Hudak's , do you know the first name?
21:17:29 <gzl> glguy: Haskell School of Expression (Hudak) is good. dunno any others
21:17:34 <gzl> Paul Hudak
21:18:13 <glguy> Alrighty, they have that book at another library in the system, I'll have to request it
21:18:23 <Cale> There's a book called "The Haskell Road" which is good though it might be tiresome if you already know logic and basic things in mathematics.
21:19:04 <Cale> (But it's interesting example of pedagogical technique)
21:19:18 <gzl> there are also some good papers
21:19:36 <skew> myavuzselim: according to the GHC user's guide (sections 7.1 and 7.3.5), the list syntax always referes to the type in the Prelude
21:20:31 <Julian> Wadler Paper's
21:20:53 <myavuzselim> I will look at this. But what do you mean?
21:21:10 <Cale> So you'd need a replacement prelude. But there's a syntactical reason why you can't do it, and that's that your list representation type doesn't have (:) as a constructor, and you can't define (:) as an ordinary function, so you just can't use (:) for that at all.
21:21:21 <rasterfar> And Hutton's papers too, by the look of it...
21:21:31 <Cale> So I suggest using another name :)
21:21:43 <myavuzselim> Yes, I understand that I can't do it in plain haskell.
21:21:43 <Cale> You can make a typeclass, something like:
21:21:53 <Cale> class List a where
21:22:03 <Julian> rasterfar: yes
21:22:06 <myavuzselim> But I will be trying the language
21:22:17 <myavuzselim> But I will be trying _to change_ the language
21:22:21 <Cale>    cons :: t -> a t -> a t
21:22:27 <Cale>     nil :: a t
21:22:46 <Cale> myavuzselim: Are you prepared to hack on the compiler?
21:23:11 <myavuzselim> I know it's difficult, but it is my final year thesis, so I should :(
21:23:29 <Cale> hmm
21:23:35 <sethk> does the emacs mode do a good job on identation?
21:23:42 <Cale> why are you trying to get these to be syntactically the same?
21:24:59 <Cale> sethk: not wonderful, but not terrible. I like the simple indent mode better (which makes some guesses at where you'll want to put it based on the previous line, but otherwise doesn't get in your way)
21:25:31 <sethk> Cale, ok.  there is only syntax highlighting but no auto indent for vim?  Is that still correct?
21:25:37 <myavuzselim> The data should be a function too. The list also. so "foo" 1 = 'o', "bar" 0 == 'b'
21:25:40 <sethk> and is yi considered ready for use?
21:25:43 <Cale> sethk: essentially
21:26:05 <Cale> sethk: yi is perhaps usable, but hide isn't for general consumption
21:26:16 <myavuzselim> And some other data that will be considered as functions
21:26:27 <sethk> yes, I know about hide.  That's why I was asking separately about yi
21:27:18 <myavuzselim> The best way to accomplish this will probably be to cosider [a] === Int -> a
21:27:34 <Cale> yeah, I'm not sure if the version of yi with the syntax highlighting is ready for consumption either... though from what I understand it uses gtk sourceview to highlight when you don't have hide
21:27:56 <Cale> myavuzselim: okay, hmm
21:28:16 <glguy> Alrighty, Haskell school of expression is on hold and "on it's way" :)
21:28:22 <Cale> What about (Branch (Leaf 5) (Branch (Leaf 4) (Leaf 6))) ?
21:28:46 <sethk> dons, is hs-plugins (for use with yi) only available through darcs?  Or is there a tarball I can download?  I haven't used darcs before, not that I expect a problem.
21:29:06 <Cale> myavuzselim: have you looked into Data.Generics?
21:29:18 <myavuzselim> no, I haven't
21:29:27 <Cale> http://www.cs.vu.nl/boilerplate/
21:30:05 <myavuzselim> Thanks for that.
21:30:29 <Cale> Also, my List class would work
21:30:57 <sethk> Cale, don't tease us, where is your List class?
21:31:03 <glguy> Was the Thompson book that was recommended titled "Haskell: the craft of functional programming" ?
21:31:09 <Cale> sethk: above
21:31:32 <sethk> Cale, must be way above  :)
21:31:37 <sethk> glguy, yes
21:31:41 <sethk> glguy, excellent book
21:31:54 <sethk> glguy, as is the other.  You won't go wrong with either (the other being Hudak)
21:32:10 <glguy> Is the Thompson book worth $42
21:32:20 <sethk> glguy, yes
21:32:30 <myavuzselim> Yesterday I looked if template haskell could help me, but it enforces me the $ syntax (I didn't have time to look further at it, maybe there is some other way).
21:32:56 <myavuzselim> And I am not sure if it will let me to do such a change.
21:34:00 <Cale> @paste
21:34:01 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
21:34:06 <Cale> one sec, I'll paste it
21:36:48 <sethk> Cale, if it isn't handy don't worry about it, I can save the irc buffer and search for it
21:37:12 <Cale> there, it's up
21:37:26 <Cale> myavuzselim: have a look
21:38:38 <TheHunter> unfortunately, you can't have real fun since "view"s have never been implemented (why, again?).
21:39:19 <Cale> updated the wiki with an obvious useful function
21:39:35 <Cale> genList :: (List list) => [a] -> list a
21:40:31 <Cale> genList = foldr cons nil
21:41:24 <TheHunter> how bout a method deconstruct :: list a -> Maybe (a, list a) ?
21:41:46 <skew> myavuzselim: what's the point of your work? speed?
21:42:04 <Cale> TheHunter: good idea :)
21:42:22 <Cale> presently it's somewhat one-way
21:42:47 * TheHunter just noticed that $42 could be valid template haskell.
21:42:51 <myavuzselim> No. In fact, I don't yet have the papers.
21:43:03 <Cale> the problem is that his function type doesn't have deconstruct
21:43:15 <Cale> I suppose if you'll allow for _|_
21:43:41 <myavuzselim> I mean, I have yet a very limited source, so I'm not sure what I will do too :)
21:43:46 <skew> myavuzselim: nicer theory? (though initial algebras are a pretty nice theory already)
21:43:55 <myavuzselim> Yes
21:43:58 <TheHunter> deconstruct f = Just (f 0, \x -> f (x + 1)) ?
21:44:13 <myavuzselim> It's somthing theoretic (or theric, my english is bad)
21:44:27 <Cale> TheHunter: I suppose, it just can't make use of Maybe very well
21:44:56 <skew> Nat -> a only really models infinite lists, I think
21:45:04 <sethk> data Maybe = VeryWell | InYourDreams
21:45:24 <TheHunter> ah, we can't model nil.
21:45:30 <sethk> VeryWell sounds like it ought to mean something
21:46:27 <skew> at least, total functions from Nat -> a are like infinite lists
21:49:17 <myavuzselim> It is the simple part. The difficult part is to make the tuples a function. ('a',1) 0 == 'a' and ('a',1) 1 = 1. I find it a bad thing. Maybe I misunderstood the requirement, so I will thinking about it when I get more detailed papers :)
21:49:50 <Cale> myavuzselim: well, you can do the same trick
21:50:08 <Cale> but it's not terribly pretty
21:50:19 <Cale> I suppose it comes down to wrapping syntax sugar around that
21:50:24 <myavuzselim> But the resulting type?
21:50:30 <sethk> myavuzselim, your english is quite good, actually
21:50:33 <myavuzselim> It can be a char or an int
21:50:45 <Cale> ah, okay
21:50:46 <Cale> right
21:50:55 <Cale> You'd need something like Either
21:50:55 <Julian> bye guys
21:51:01 <Cale> Julian: later
21:51:05 <Julian> c u!
21:51:17 <myavuzselim> And I don't know a generic way to get the nth element of a tuple.
21:51:23 <Cale> because as it is, that's not a function of any existing type
21:51:38 <Julian> yes
21:52:03 <Julian> just think the type of this function...
21:52:24 <Cale> It's like f : Int -> (a union b), but we don't have untagged unions in Haskell
21:53:31 <Cale> However, you could define a suitable type:
21:53:45 <Cale> data PairPart a b = Fst a | Snd b
21:54:36 <Cale> then you could define a function f :: (a,b) -> Int -> PairPart a b
21:54:41 <Cale> but that's not so useful
21:54:45 <myavuzselim> I need a way that shouldn't disturb the existing libraries of haskell.
21:54:58 <Cale> then it's basically not possible
21:55:10 <myavuzselim> I think that also
21:55:29 <Cale> There's no way to really do what you want that doesn't disturb the type system of Haskell.
21:55:32 <myavuzselim> If you are interseted, that is my main source (at the moment :))
21:55:35 <myavuzselim> http://web.comlab.ox.ac.uk/oucl/research/pdt/ap/ssgp/slides/boute.pdf
21:57:05 <glguy> In the statement "old <- liftIO $ readIORef ref" liftIO is used because the containing do-block was for a different Monad?
21:57:28 <Cale> glguy: right
21:57:49 <Cale> one which was built on top of the IO monad
21:58:31 <Cale> There are these things called monad transformers, which add features of various kinds to other existing monads.
21:58:38 <glguy> so the IO Monad called a different Monad, and this allows you to do more IO without dropping back to the original IO block first
21:58:39 <myavuzselim> I must leave. bye. And thank you for the poiters...
21:58:44 <myavuzselim> pointers...
21:58:55 <Cale> myavuzselim: you're quite welcome
21:59:04 <glguy> I'm reading all about the transformers and so on right now, and reading over lambdabot to try to apply what I think I'm learning
21:59:25 <Cale> glguy: yeah, it's something like that
21:59:53 <glguy> if I'm slightly off, tell me I'm wrong
22:00:01 <glguy> I'd rather learn than be right
22:00:34 <Cale> Well, the monad is being transformed at the type level
22:00:54 <glguy> the monad being the one that is layered on top of the IO monad?
22:01:01 <glguy> or:
22:01:04 <Cale> for example, there's this monad transformer called ListT
22:01:10 <glguy> listening
22:01:22 <TheHunter> "monad transformer"
22:01:23 <Cale> newtype ListT m a = ListT {runListT :: m [a]}
22:02:05 <Cale> TheHunter: just like any other, thought I'd pick something easy :)
22:02:45 <TheHunter> it's not strictly speaking a monad transformer, but certainly good enough as an example :)
22:03:06 <Cale> TheHunter: is there a law which fails somehow?
22:03:07 <Megzl> What's Monad?
22:03:28 <TheHunter> yes, I have QuickCheck tests for that.
22:03:36 <Cale> what is it?
22:03:46 <TheHunter> i guess associativity, checking.
22:03:48 <sethk> Megzl, start with the wiki introduction to nomads
22:04:10 <glguy> Megzl: the title of the language should be: Haskell^H^H^H^H^H^H^HMonads?
22:04:23 <sethk> Megzl, http://www.haskell.org/hawiki/MonadsAsContainers
22:04:36 <sethk> also stuff in
22:04:37 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
22:04:39 <Cale> yeah
22:04:40 <sethk> http://www.nomaware.com/monads/html
22:04:49 <Cale> okay
22:05:27 <TheHunter> man, these tests are running slowly...
22:05:42 <Megzl> Just tell me, what is a Monad.
22:05:45 <Megzl> Is it like a Nomad?
22:05:52 <Cale> anyway glguy, a monad transformer takes a monad, and returns another monad. Since a monad is represented in Haskell as a type constructor, this is something which is done at the type level, and instances of (>>=) and return are given for values of the new type
22:05:54 <sethk> TheHunter, what are you building?
22:05:59 <sethk> TheHunter, testing?
22:06:11 <Cale> which hopefully use the definitions of >>= and return on the old monad
22:06:14 <TheHunter> running my monadish laws quickcheck test suite.
22:06:26 <TheHunter> still running...
22:07:08 <sethk> Cale, with a transformer, is the monad that the computation is performed in one of the arguments to the transformer monad type constructor?
22:07:14 <TheHunter> geez, what does one have to do to change the wiki these days?
22:07:21 <Megzl> Is Haskell a function?
22:07:28 <Cale> sethk: yeah, the monad that's being transformed
22:07:37 <Cale> Megzl: Haskell is a category
22:08:11 <Cale> :)
22:08:45 <sethk> Cale, so I can use StateT to "stay" (I'm calling from main) in the IO monad and have access to state monad methods?
22:08:49 <Cale> Anyway, unless TheHunter has something to say about it, StateT is a monad transformer which adds a piece of state to be carried around
22:08:49 <glguy> so I'm reading about Monads at nomaware.com, and the example code is in boxes of a ugly brown / orange color, and my brain is telling me to click on the text to make the selection box go away
22:08:54 <glguy> and I'm clicking
22:08:59 <Cale> hehe
22:09:01 <glguy> and it's not going away :)
22:09:07 <sethk> glguy, there is a downloadable version
22:09:24 <sethk> glguy, I think it will eliminate that problem, although my memory is a bit hazy on this (I saw it last week)  :)
22:09:35 <glguy> yeah, I knew how to fix it...
22:09:41 <glguy> I was just casually reading the example
22:09:42 <TheHunter> StateT is a monad transformer alright.
22:09:47 <glguy> and my mind was in that mode
22:10:49 <sethk> Cale, I'm calling from main, so how do I refer to the IO monad that I am in?  the return function?
22:10:51 <Cale> glguy: So, for example, StateT Integer [] is a new monad which is like the list monad, in that it carries out nondeterministic computations, but which in addition to the lists of values, also carries a piece of state
22:10:54 <TheHunter> ListT doesn't satisfy associativity, but I apparently only test ListT (Cont Int).
22:10:59 <Cale> (of type Integer)
22:11:01 <sethk> TheHunter, also  :)
22:11:30 <TheHunter> It also doesn't satisfy the Right Zero and Left Distribution MonadPlus laws.
22:11:53 <glguy> which makes it not really a monad at all
22:11:54 <Cale> sethk: you need something of type  M a -> IO a for your monad M.
22:11:55 <glguy> :-p
22:12:34 <Cale> TheHunter: that sucks, I'll have to think about that
22:12:49 <sethk> Cale, my monad M being what?  I'm in main.
22:12:52 <TheHunter> my ListT type fixes that.
22:13:06 <Cale> TheHunter: oh, you should submit it
22:13:14 <Cale> sethk: you mentioned another monad?
22:13:19 <TheHunter> the Right Zero property still fails, though.
22:13:24 <TheHunter> Cale, it's on the wiki.
22:13:33 <TheHunter> @wiki ListTDoneRight
22:13:34 <lambdabot> http://www.haskell.org/hawiki/ListTDoneRight
22:13:46 <sethk> Cale, I'm going to create a StateT monad (that might not be the one, but it shouldn't matter to the template)
22:13:50 <Cale> cool, yeah, now that you mention it, I did see that at some point
22:13:53 <sethk> Cale, I mean to the question
22:14:18 <sethk> Cale, I'm in main, and I'm going to use runStateT I presume
22:14:32 <Cale> sethk: yes, runStateT :: StateT s m a -> (s -> m (a, s))
22:14:36 <sethk> Cale, so how does StateT know that the inner monad I want to use is IO?
22:14:45 <sethk> right, so where do I get M from?
22:14:48 <sethk> m, sorry
22:14:59 <Cale> m should be IO if you're transforming IO
22:15:13 <sethk> Cale, but is it implied, or do I have to code something to tell it?
22:15:29 <Cale> and it will be inferred if you use the m (a,s) which you get back as an action to run from main
22:15:51 <TheHunter> explicit type signatures will help, though.
22:15:56 <sethk> Cale, when you say "get back", do you mean I call something?
22:16:05 <Cale> runStateT, yeah
22:16:35 <sethk> Cale, don't the computations happen within runStateT (  ... )  ?
22:17:10 <sethk> I do a computation in the State monad by using runState (  whatever.it.is.that.I.want.to.do )
22:17:10 <Cale> runStateT :: StateT s m a -> (s -> m (a, s)) -- let's look at that carefully
22:17:16 <sethk> Cale, ok
22:17:17 <Cale> right
22:17:47 <Cale> So you pass it your thing which is of type StateT MyState IO MyReturnType
22:18:07 <Cale> and it gives you a function from MyState -> IO (MyReturnType, MyState)
22:18:19 <Cale> so you pass that an initial state
22:18:25 <Cale> and you have something which is an IO action
22:18:53 <sethk> Cale, yes, and within runStateT( ...)  I can, for example, say        xxx <- get    ?
22:19:00 <Cale> the IO type there will get inferred if you use the monad transformer in a way that ever lifts IO actions
22:19:02 <dons> sethk, just in darcs atm
22:19:05 <sethk> Cale, which refers to the StateT monad get?
22:19:15 <sethk> dons, thanks, I'm installing darcs
22:19:17 <Cale> yeah
22:19:53 <Cale> because you're in that new monad, which is an instance of MonadState
22:19:57 <sethk> Cale, so I can use, say,  hGetLine as well as put and get within runStateT(...), and everything is smart enough to do the right thing.
22:20:05 <sethk> Cale, well, it seems I'm also "in" IO
22:20:16 <sethk> Cale, which is what makes it a bit confusing
22:20:19 <Cale> to use hGetLine, you have to lift
22:20:31 <Cale> or better yet, liftIO
22:20:45 <sethk> Cale, let me look at the signature for liftIO
22:20:47 <Cale> which helps if you decide to transform some more
22:21:25 <Cale> it'll always drop right back to the IO level (which is always on the bottom of the transformer stack, if it's there at all), whereas lift only moves one level up
22:21:42 <Cale> er, I should say that it lifts from the IO level
22:22:56 <Cale> @type liftIO
22:23:11 <sethk> hmm, the index lists liftIO in various places, such as Control.Monad.State, but it does not appear in Control.Monad.State, and ghci doesn't know about it
22:23:17 <lambdabot> bzzt
22:23:22 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.Trans.html
22:23:31 <Cale> @type Control.Monad.Trans.liftIO
22:23:33 <lambdabot> forall (m :: * -> *) a.
22:23:33 <lambdabot> (Control.Monad.Trans.MonadIO m) =>
22:23:33 <lambdabot> IO a -> m a
22:23:54 <Cale> MonadIO is a typeclass for transformed IO monads
22:24:02 <Cale> and IO is in there, trivially
22:24:12 <sethk> do they index it for Control.Monad.State because State is an instance?
22:24:19 <Cale> probably
22:24:44 <Cale> all the documentation there is autogenerated
22:24:47 <sethk> but that seems backwards.  I'm in runStateT( ... ) so don't I need to specify IO, not lift from IO?
22:24:50 <Cale> from the source code :)
22:25:12 <glguy> @type StdGen
22:25:14 <lambdabot> bzzt
22:25:20 <Cale> you're writing something of type StateT s IO a
22:25:30 <sethk> ok
22:25:41 <Cale> so to use something of type IO a, you need a function IO a -> StateT s IO a
22:25:51 <Cale> which is how liftIO specialises here
22:25:57 <sethk> and since the signatures of runState and runStateT are the same, I assume I write a function that has the type s -> (s, a)
22:26:05 <sethk> (or (a,s), let's not quibble  :)  )
22:26:21 <Cale> runStateT makes the return trip (excuse the pun)
22:26:42 <sethk> Cale, that doesn't compute.  I'm coding this function that will be run with runStateT.  I don't have a StateT to use with a function
22:27:13 <TheHunter> something as simple as return () will give you a StateT.
22:27:27 <Cale> liftIO :: IO a -> StateT s IO a
22:27:39 <sethk> TheHunter, so I refer to the current StateT monad using return within runStateT( ... )   ?
22:27:50 <Cale> runStateT :: StateT s IO a -> ... -> IO a
22:27:57 <TheHunter> runStateT (return ()) will work, but won't do anything interesting.
22:28:04 <sethk> Cale, You mean I doi something like:    liftIO (abc <- hGetLine)   ?
22:28:15 <Cale> abc <- liftIO getLine
22:28:20 <sethk> right
22:28:26 <sethk> makes no sense the other way  :)
22:28:58 <Cale> glguy: heh, are you catching this discussion?
22:29:05 <glguy> I'm giving it a shot
22:29:07 <glguy> :)
22:29:41 <Cale> sethk: now, you could also use lift to lift things from IO to your StateT monad
22:29:57 <Cale> but let's say you decide to transform the monad again
22:30:10 <sethk> ok
22:30:11 <glguy> so... the lift function transforms my Monad into an IO monad, does my IO function on it, and the ntransfroms it back to my Monad?
22:30:44 <Cale> glguy: liftIO transforms an IO action into an action in your transformed monad
22:31:10 <glguy> alright: the lift function modifies the function, and not the Monad that is being passed around
22:31:30 <Cale> glguy: the Monad is the *type*, so it's not being passed around :)
22:31:45 <glguy> the instance of the Monad
22:31:51 <Cale> yeah
22:31:55 <sethk> glguy, that's what kept hanging me up.
22:32:05 <Cale> though you should perhaps also be careful with the word "instance" :)
22:32:09 <Cale> hehe
22:32:13 <sethk> glguy, to us recovering imperative programmers, it seems like it ought to be an argument to something
22:32:14 <glguy> When I say "the Monad" is being passed around, I mean the instance of
22:32:28 <sethk> glguy, no, you don't pass anything, not the instance either
22:32:28 <Cale> the value whose type is in the monad
22:33:08 <glguy> Feels like saying "the object whose type is apple"
22:33:13 <Cale> the lift modifies the IO container into a transformed kind of container
22:33:37 <glguy> so that it can be bound inside the current do block
22:33:44 <glguy> "bind"ed
22:33:49 <glguy> ">>=" ed
22:34:00 <glguy> ?
22:34:04 <Cale> yes
22:34:08 <Cale> exactly :)
22:34:51 <Cale> It's like the containers in your new monad have the old monad structure as part of them, plus some additional frobs
22:35:10 <glguy> and the point of all of this was to have a functional language with sequencial aspects
22:35:23 <Cale> glguy: at this point it's getting beyond that :)
22:35:29 <glguy> bah
22:35:49 <Cale> Now it's getting to the point where we realise, hey, this is more powerful than a language with just sequencing
22:36:27 <Cale> this is a language where we can build machines to run generic code in, and the code will do different things based on which machine it's put into
22:37:36 <Cale> Or, perhaps you look at things the opposite way, and we're building generic code to run machines through :)
22:37:39 <Cale> hehe
22:38:02 <Cale> but to understand this, you're going to need at least an example (and probably some experience too)
22:38:10 <glguy> True
22:38:14 <Cale> let me get some code
22:38:33 * glguy prepares to get out his compass
22:39:21 <glguy> So I'm looking at the 6-cell maglite sitting standing on end next to my laptop, and I think... that's going to leave a big mark
22:40:01 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:40:25 <Cale> okay, that's stolen from Nymphaea's source code
22:40:44 <Cale> which is an LSystem drawing program which xerox and I have been working on
22:41:27 <Cale> perhaps don't try to understand everything that's going on there right at once, but have a look at the type of "result"
22:41:47 <Cale> It's the code that drives the LSystem
22:42:10 <glguy> the 6 lines including the "result :: ..."
22:42:11 <glguy> ?
22:42:23 <Cale> if you'd like :)
22:42:32 <Cale> the 4 lines which are the type, mostly
22:42:56 <Cale> For any monad m, it takes an Int, and an LSystem m, and it returns an m String
22:43:33 <Cale> the Int is the number of iterations
22:43:50 <Cale> the LSystem m is a description of the axiom/rules of the LSystem
22:44:34 <Cale> you take the axiom and apply the rules to it as many times at the iteration count says
22:45:12 <Cale> the axiom is an (m String)
22:45:19 <Cale> think of m as a container type
22:45:33 <Cale> If it's the identity monad, this is just a simple String
22:46:02 <Cale> each of the rules are mappings from characters to (m String)s
22:46:37 <glguy> (still listening)
22:46:43 <Cale> what happens is that when the L-System runs, the characters are replaced by the strings given by rules
22:46:56 <Cale> but there's this monad in the way, what is it doing?
22:47:05 <Cale> let's take the list monad as an example
22:47:14 <Cale> your axiom is a [String]
22:47:28 <Cale> and your rules are essentially Char -> [String]
22:48:09 <Cale> how to interpret that is that the lists are all the possibilities for the String we're manipulating
22:48:46 <Cale> the axiom is nondeterministic -- it's a superposition of all of those strings, in a sense
22:48:55 <Cale> and the rules are too
22:49:14 <Cale> they take a character and give a list of possible substitutions
22:49:29 <Cale> and the end result of the algorithm is that you get a list of all possible expansions
22:49:54 <Cale> the WL monad I have there is a Weighted List monad
22:50:22 <Cale> the only difference between this and the list monad is that "probabilities" are carried around
22:51:01 <Cale> that is, each element of the weighted list carries with it a probability, and the result is a list of all the results, together with their probabilities
22:51:19 <Cale> another monad, which is the one we actually use in Nymphaea and not pictured here
22:51:26 <Cale> is MonadRandom
22:51:37 <Cale> it's just a state monad which keeps track of a StdGen
22:51:46 <Cale> so that random numbers can be generated
22:52:09 <Cale> This allows us to give an axiom which is random and rules which select things randomly
22:52:29 <glguy> which allows...
22:52:29 <Cale> (with given probabilities, the way we do it)
22:52:51 <Cale> which allows us to add a bit of randomness to the way that the trees and flowers grow :)
22:53:20 <Cale> the result is just a computation in the Random monad, which we run to extract a random result
22:53:36 <Cale> and it's the same code in all the cases that does the L-System expansion
22:53:45 <sethk> Cale, that's one problem with all these monads.  All the easy cases now have their own monad.  :)
22:53:45 <Cale> only the data we put in is changing
22:53:57 <Cale> :)
22:54:19 <Cale> sethk: yeah, the monad template library kind of covers a lot of the useful examples
22:54:40 <sethk> that's not really true, of course, you can still use the examples.  :)
22:54:54 <Cale> I think maybe the only reason they don't put an instance of Monad for Tree in there is so that there are exercises left for students :)
22:55:30 <Cale> I can also think of ways to turn various types of graphs into monads
22:55:42 <Cale> none of which I've implemented simply because it's awkward
22:55:53 <Cale> I should do it at some point though.
22:56:22 <Cale> glguy: so do you see the big picture here?
22:56:27 <Cale> sorta?
22:56:36 <glguy> to a degree
22:56:44 <glguy> im not giving up tho :)
22:56:51 <Cale> we get incredibly reusable code
22:57:27 <glguy> because you define operations on containers in general
22:57:32 <Cale> right
22:57:53 <Cale> and they're just the right operations so that very strange things can be thought of as containers still :)
22:58:06 <Cale> (like state transformers)
22:58:31 <sethk> Cale, to people like me learning this stuff, one naturally has the idea that a container contains something
22:58:58 <Cale> the picture is that a value of type m a contains values of type a
22:59:08 <Cale> but it might do so in a rather abstract way
22:59:13 <sethk> Cale, yes, I know, but you abstract the notion of contains
22:59:19 <Cale> right
22:59:31 <sethk> too much category theory.  a function is a function even when it isn't a function
22:59:34 <Cale> it's not "contains" in the sense that those things can ever come out again
23:00:00 <Cale> (necessarily)
23:00:03 <sethk> Cale, it also is not contain in the sense that something is always put in there
23:00:22 <Cale> well, that's sort of what return does
23:01:12 <sethk> to me we need a word that does not have a meaning that doesn't compute, even if only for marginal cases
23:01:24 <sethk> and the choice of "return" for the function name is very unfortunate
23:01:51 <Cale> not really, if you think of them as computations
23:02:01 <Cale> though unit might be better
23:02:22 <Cale> but it's not a control flow operation
23:02:27 <Cale> and that gets some people
23:02:30 <sethk> Cale, yes, really, because the word has a generally accepted meaning in the context of software engineering, and it is not the same meaning.
23:02:40 <sethk> Cale, right, it isn't return as we know and love it
23:02:46 <sethk> Cale, unit would have been much much better
23:02:56 <Cale> It's a sensible name though, because it takes an "x" and produces the computation which returns x
23:02:58 <sethk> it's only an issue while learning, but still
23:03:09 <sethk> Cale, it may produce it, but it doesn't return it.
23:03:29 <Cale> well, the computation notionally returns it again
23:03:33 <sethk> I don't have a problem with it, now that I know what it means
23:03:39 <Cale> that is, if there's a way to run the computation at all
23:03:41 <sethk> that's the problem, notionally
23:03:46 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
23:03:52 <sethk> just from an understanding perspective,
23:03:53 <Cale> there's a stupid example of a monad too
23:04:04 <sethk> it makes life easier to not use a word with a different meaning
23:04:11 <Cale> hehe
23:04:17 <Cale> We could also call it eta
23:04:24 <sethk> even though I understand this, I go back and forth between haskll and C++ and java and other languages, and I have to shift gears constantly
23:04:28 <Cale> but I think beginners might hate that
23:04:34 <sethk> I don't think they would
23:04:40 <Cale> it might also be better
23:04:42 <sethk> it would say to them:  this is a _new_ concept
23:04:49 <sethk> not the one you are familiar with
23:04:56 <Cale> class Monad m where
23:05:05 <Cale>    eta :: a -> m a
23:05:12 <Cale>    mu :: m (m a) -> m a
23:05:17 <sethk> just in general it would be nice to avoid things that are keywords in many other languages
23:05:20 <C-Keen> moin.
23:05:25 <sethk> you see, I like those names
23:05:36 <sethk> because it gives me a hint of where to look, where they came from
23:05:41 <Cale> they're so unsuggestive :)
23:05:48 <sethk> except of course that I can't remember which greek letter is eta  :)
23:05:54 <Cale> η
23:05:56 <sethk> Cale, yes, that's the point
23:06:03 <sethk> better to be unsuggestive than misleading
23:06:10 <Cale> maybe "singleton"
23:06:18 <glguy> and so Haskell 05 was born
23:06:27 <sethk> to me, the "natural" meaning of "return" would be exactly the opposite, take the monad and return the value
23:06:34 <Cale> class Monad τ where
23:06:35 <sethk> now, I realize that's dumb
23:06:38 <sethk> we don't want to do that,
23:06:44 <Cale>    η :: α -> τ α
23:06:45 <sethk> but I'm only talking about the suggestiveness of the name
23:06:47 <sethk> :)
23:06:54 <sethk> greek letter name dropper.  :)
23:06:56 <Cale>    μ :: τ (τ α) -> τ α
23:07:13 <eivuokko> Cale, your text is control characters for some of us :-S
23:07:19 <sethk> but, you see, I've spent a lot of time lately saying  "that's return but it isn't return"
23:07:21 <Cale> eivuokko: I'm aware of that
23:07:30 <Cale> eivuokko: It's greek encoded in UTF-8
23:07:34 <sethk> Cale, and a lot of time saying "why didn't that compile" in another language because I didn't use return.
23:07:35 <eivuokko> Yeah.
23:07:37 <sethk> :)
23:08:21 <Cale> sethk: which is why I always recommend to beginners that they try to set aside everything that they know about programming when they come to Haskell
23:08:41 <Cale> because it largely only applies in non-obvious ways
23:09:00 <Cale> did everyone see my nice trivial monad?
23:09:05 <sethk> Cale, but I can't do that.  I live in the real world.
23:09:11 <sethk> Cale, oh, is it there now?  Let me look
23:09:33 <sethk> Cale, if something is broken in C++ code, I have to fix it or satellites will start de-orbiting in 36 hours
23:09:40 <glguy> great, there are Monoids and Monads
23:09:55 <Cale> glguy: monoids are simpler :)
23:10:04 <glguy> sethk: so you are saying that it's irresponsible for you to be learning Haskell? ;)
23:10:06 <Cale> Monad = Monoid + Triad
23:10:37 <Cale> sethk: remember, this is only until they have a basic understanding
23:10:38 <sethk> Cale, by the way, I didn't find a definition of Triad in any of the category theory books I looked at
23:10:46 <sethk> Cale, which is only two, but still
23:10:56 <sethk> I can only find two without ordering
23:10:57 <eivuokko> Cale, why not start from mathematics and go historical way through lambda calculus (as a teaching method)?  It doesn't seem that long way.
23:11:00 <Cale> sethk: Monads used to be referred to as triples, or triads
23:11:10 <glguy> Cale: and I don't see how telling me that ther eis a thing called a Triad makes the fact that there is a monoid less daunting
23:11:23 <Cale> (T,η,μ)
23:11:30 <Cale> that's the "triple"
23:11:43 <Cale> terrible name, which is why it was changed
23:11:52 <glguy> well if it was garbage letters, I can see why they tossed it
23:11:58 <Cale> that is (m,eta,mu)
23:12:09 <Cale> where m is a monad
23:12:11 <sethk> Cale, now here we are with:  a monad is a modoid + a triad, and a triad is a monoid
23:12:14 <Cale> er
23:12:14 <sethk> something wrong there
23:12:16 <Cale> functor
23:12:30 <Cale> sethk: I only explained the etymology
23:12:38 <sethk> I know.  can you explain the concept?
23:12:49 <sethk> because, intersting as the etymology might be .... :)
23:13:08 <Cale> Okay, so a monoid is normally just a set with a single operation on it, such that
23:13:15 <sethk> Cale, hey, you didn't define >> for Trivial.  I know it will use the default, but ... :)
23:13:24 <sethk> Cale, yes, I did find out what a monoid is
23:13:27 <Cale> let's call the operation * : AxA -> A
23:13:28 <sethk> but keep going
23:13:36 <Cale> (a * b) * c = a * (b * c)
23:13:42 <sethk> Cale, this is the operation associated with the monoid?
23:13:46 <Cale> yes
23:13:49 <Cale> and such that there is a special element 1
23:13:54 <sethk> Cale, right, use + and 1 or * and zero
23:13:55 <Cale> such that 1 * a = a * 1 = a
23:14:06 <sethk> + and 0 or * and 1, sorry  :)
23:14:18 <Cale> note that there's no assumption that there are inverses
23:14:23 <sethk> ok
23:14:33 <Cale> if for every a, there is some b so that a * b = b * a = 1
23:14:37 <Cale> then we call it a group
23:14:52 <Cale> groups are important throughout mathematics and are used to measure symmetry
23:15:10 <Cale> Groups also represent many puzzles
23:15:18 <Cale> The Rubik's cube is a group
23:15:47 <Cale> where the elements are all the possible ways of twisting the cube, up to equivalence by the stickers being in the same spots
23:16:12 <Cale> and the operation is  a * b  means to do a first then to do b
23:16:35 <Cale> it's a group because presumably, you can always get back to where you started
23:16:43 <Cale> (though it might be tricky)
23:17:24 <Cale> If a group is like a puzzle, a monoid is a puzzle that you can break if you move the wrong way.
23:17:38 <Cale> hehe, that is, you might not be able to get back to the starting position anymore
23:17:52 <sethk> Cale, that's implied by your comment about inverses
23:17:55 <Cale> right
23:18:16 <basti_> are monadic interpreters of lambda calculus based languages always eager?
23:18:44 <basti_> (that is, computing the whole result before they return)
23:19:01 <Cale> basti_: I'm not sure, but I somehow doubt it
23:19:09 <basti_> hmm ok
23:19:13 <sethk> Cale, ok, we're rolling now, but we are still on monoid and haven't yet talked about triad
23:19:20 <sethk> Cale, so don't disappear on us now.  :)
23:19:29 <Cale> okay, well there's an analogy going on
23:19:54 <Cale> eta and mu are what are called natural transformations
23:20:16 <Cale> do you know what a functor is in the category theory sense?
23:20:46 <sethk> Cale, no.  I've seen the definition, but I don't see the implications
23:20:49 <Cale> okay
23:21:33 <Cale> so a functor is sort of like a way to sketch your category which usually in mathematics (but certainly not always), loses some of the structure of your original category
23:22:03 <Cale> in Haskell, you tend not to really lose much structure
23:22:18 <Cale> but functors in Haskell are of a special sort
23:23:54 <Cale> If functors are like ways of sketching categories into other categories,
23:24:17 <Cale> then natural transformations are like ways of turning sketches into other sketches
23:24:32 <Cale> They transform one functor into another
23:25:04 <Cale> I'm finding myself with a lack of examples, because I don't know exactly what I can assume :)
23:25:39 <Cale> But, for example, if you know some linear algebra
23:26:35 <Cale> So we're in the category of vector spaces over a specific field
23:27:23 <sethk> Cale, I'm afraid that _you_ are in the category of vector spaces over a specified field.
23:27:27 <Cale> heh
23:27:28 <Cale> okay
23:27:33 <Cale> maybe not a good example
23:27:35 <sethk> Cale, the kinds of fields I know about are a different thing altogether
23:27:46 <sethk> they are the things that supposedly make the cows die when they sleep under the wires
23:27:50 <Cale> heh
23:27:56 <Cale> Not that kind
23:28:21 <Cale> those are just functions from a vector space to another vector space :)
23:28:28 <Cale> heh
23:28:30 <basti_> x.x
23:28:50 <Cale> (with a given physical interpretation)
23:28:55 <JKnecht> I got an A in Linear Alg (actually was grading papers for a math statistics course during the class a lot) so please continue.
23:29:04 <Cale> okay
23:30:10 <Cale> so GL_n is a functor from the category of vector spaces to the category of groups.
23:30:20 <Cale> It takes a vector space V
23:30:28 <Cale> and gives a group GL_n(V)
23:30:42 <Cale> which consists of all the invertible linear transformations (matrices) on V
23:31:29 <Cale> and it sends a linear map f : V -> W
23:31:57 <sethk> Ah, now I see it all.   :)  Actually I do know a bit of matrix theory
23:32:11 <Cale> to GL_n(f), an appropriate group homomorphism GL_n(f) : GL_n(V) -> GL_n(W)
23:32:21 <Cale> actually, the n's shouldn't be there
23:32:25 <Cale> they're the dimensions
23:32:52 <Cale> GL(V) and GL(f) perhaps is better notation
23:33:00 <JKnecht> BTW: the rubiks cube solution is the same as that of Thue'w Word Problem, wouldn't be surprised to see a Haskell program for that Maybe.
23:33:49 <JKnecht> s/same/related/
23:33:55 <Cale> now, the field that these vector spaces are over, it has a group of multiplicative units
23:33:58 <Cale> er
23:34:03 <Cale> which is everything nonzero :)
23:35:01 <Cale> It's given by a functor ( )* on the category of fields
23:35:12 <Cale> taking each field to its multiplicative group
23:35:43 <Cale> and field morphisms to group morphisms (though I didn't really explain those or group morphisms)
23:35:58 <Cale> now, you remember the determinant?
23:36:14 <Cale> It's a natural transformation GL -> ( )*
23:36:49 <Cale> It takes invertible linear maps and gives elements of the multiplicative group of units of the field.
23:37:01 <Cale> But it does this for every vector space
23:38:08 <JKnecht> Is Haskell every actually used for X programming, X = linear, integer, dynamic, etc?
23:38:33 <Cale> I haven't seen it used for that too much directly.
23:38:56 <JKnecht> Everything I've seen is either in Lin/Scalapack ....
23:38:57 <Cale> Though it would make a wonderful interface to an optimisation library
23:39:28 <Cale> I did a discrete optimisation problem in Haskell as a summer job
23:39:30 <JKnecht> or the newer algorithms tend to be in Java, C++, whatever.
23:39:58 <Cale> I wrote a pipeline scheduler for PPC + Altivec, if I haven't already mentioned that a million times :)
23:40:24 <JKnecht> Well math programming at least :)
23:40:25 <Cale> and it performed quite well and made good use of lazy evaluation and monads :)
23:40:44 <Cale> Take a look at DoCon perhaps
23:40:47 <Cale> I should too :)
23:40:56 <Cale> it looks like a Haskell library for algebra
23:41:08 <Cale> but anyway
23:41:20 <Cale> I was discussing natural transformations, and working up to monads
23:41:32 <Cale> so a monad is three things
23:41:43 <Cale> T : a functor from a category C to itself
23:42:01 <Cale> eta : a natural transformation from the identity functor on C to the functor T
23:42:22 <Cale> mu : a natural transformation from T^2 (the composition of T with itself) to T
23:42:37 <Cale> these were written (T, eta, mu)
23:42:41 <Cale> as a triple
23:42:54 <Cale> and so came to be known initially as "triples"
23:43:23 <Cale> context giving it away that since we're talking about category theory, we mean those particular special kinds of triples
23:43:35 <Cale> (of course, they also have to satisfy extra laws)
23:44:13 <Cale> how is it related to a monoid?
23:44:24 <Cale> well, look at the types of these transformations:
23:44:32 <Cale> mu : T . T -> T
23:44:47 <Cale> this is in an abstract way, a kind of "multiplication"
23:44:59 <Cale> if you replace composition with Cartesian product
23:45:18 <Cale> it will look more like the usual:
23:45:22 <Cale> * : A x A -> A
23:45:30 <Cale> and eta : 1 -> T
23:46:13 <Cale> well, if you think of 1 as a set containing one element, and that arrow as a function, and T as a set, that's a function picking out an element
23:46:24 <Cale> there's a pretty broad analogy going on here
23:46:38 <Cale> and it can be better formalised than what I'm doing :)
23:47:03 <Cale> eta picks out the "1" of your "monoid" where "multiplication" is mu
23:47:17 <Cale> and the laws reflect that somewhat
23:48:53 <Cale> they correspond to the associativity of that operation
23:49:00 <Cale> and the identity element
23:50:57 <sethk> emacs mode works reasonably well
23:51:16 <Cale> Well, I hope that if I haven't been too informative, I've at least been mildly interesting :) (or vice versa)
23:51:22 <sethk> Cale, the problem with that explanation, is that there is nothing there that I can see that doesn't apply equally to a regular old multiplication function
23:51:34 <Cale> okay
23:51:35 <sethk> I understand the idea
23:51:48 <Cale> so mu in Haskell is called join
23:51:54 <Cale> and eta is called return
23:52:07 <sethk> you are saying that the change in semantics when executing monadic code amounts to a change in these properties
23:52:21 <sethk> I think
23:52:35 <sethk> and the semantics are different
23:52:51 <sethk> but it seems to me that an essential characteristic is how they are kept separated
23:53:30 <sethk> the barriers between them seem to be the crux of the matter
23:53:35 <Cale> Well, yeah, if you can write code which applies to any monad (at least over your one category), then you're doing a lot
23:54:07 <sethk> Let me turn that over in my mind a bit
23:54:10 <Cale> but that whole explanation there was really getting at why it's called a "Monad" in the first place
23:54:27 <sethk> yes, and thanks for that
23:54:29 <sethk> it does help
23:54:49 <Cale> it's not really all that profound a name when you get right down to it, but perhaps it helps a little.
23:55:15 <sethk> In my own mind I have to develop some sort of a concept of how the little bit of information in the monad definition, a few types and operations, imply some known semantic behavior
23:56:11 <JKnecht> I'm just hoping to find that Haskell is based on a category theoretic denotational semantics, practically realized in a solid implemenation plus support and evanglistic community, which would appear at this point to be the case.
23:56:52 <Lor> No one really knows Haskell's semantics.
23:56:55 <sethk> Cale, the emacs mode needs to ignore blank lines
23:57:10 <sethk> Cale, if you leave a blank line it won't indent according to the line preceding the blank line
23:57:34 <Cale> JKnecht: For previous versions of Haskell, someone had gone to the trouble of writing out the formal semantics
23:57:38 <JKnecht> that almost make be change my nick to 'Data', Lor.
23:58:09 <sethk> Cale, hm, emacs isn't too swift with the do notation either.  :)
23:58:15 <Cale> sethk: yeah, sometimes that would be good
23:58:24 <Cale> actually, just about always
23:58:34 <Cale> sethk: which indent mode?
23:58:47 <sethk> Cale, I was doing simple.  I'm going to try the other now
23:59:07 <Cale> I like simple because I can understand how it works
23:59:11 <Cale> heh
23:59:22 * boegel streches
23:59:29 <sethk> Cale, well, you understand category theory, I understand emacs.  :)
23:59:37 <Cale> :)
