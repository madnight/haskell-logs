00:00:03 <dons> yes, I see that too.
00:00:13 <dons> something funny must have happened on the last run
00:00:17 <dons> trying again..
00:01:00 <skew> I just put my location in, and then on the update the images were wierd
00:01:05 <dons> it takes about 20 mins to generate all 5 images.
00:01:12 <skew> maybe it caught the file in an inconsistent state?
00:01:18 <dons> yes, I aborted a render. maybe I shouldn't have done that.
00:03:10 <Itkovian> good meuning
00:03:25 <dons> ok, the big image is done..
00:03:48 <dons> it'll get cropped in 5 mins or so, while the others get finished
00:03:51 <dons> hehe this is fun :)
00:04:33 <basti_> my pc is making noises when it's working.
00:04:55 <dons> does it have a sound card ? ;)
00:05:25 <basti_> that must be rather electromagnetic... the sound changes pitch when the CPU is busy
00:05:44 <basti_> I'm used to hear that sort of stuff, but never had it that loud.
00:08:22 <kzm> Whee!  I'm in, I'm in!
00:08:25 <basti_> why doesnt the north pole ice cap show up in the picture? is that colored radar data?
00:08:31 <basti_> kzm?
00:08:46 <kzm> it's an image from the future - it has melted
00:08:54 <dons> I switched to a hi-res map (down to 5km) but it doesn't come with ice data
00:09:02 <basti_> i see
00:09:25 <basti_> kzm: other than the south pole, there is not a continent under the north pole
00:09:25 <kzm> basti_, near the top, to the left :-)
00:09:34 <basti_> thats canada
00:09:39 <kzm> ...of europe.
00:09:40 <kzm> :-)
00:09:40 <dons> the benefit is that zooming in is much better. i.e. we can see the fjords
00:09:45 <basti_> thats greenland
00:10:09 <basti_> (exaggerated)
00:10:28 <Speck> how do you zoom?
00:10:57 <dons> the -radius flag to xplanet. (no interactive zooming -- try google for that ;)
00:11:12 <Speck> oh. yeah I'll stick to Google Earth :-)
00:11:28 <dons> they have a lot more computational resources than me :)
00:11:53 <Speck> I wonder if it's possible to feed Google Earth a file and have it set up bookmarks for you
00:12:08 <Speck> so I can really stalk haskellers
00:12:11 <dons> yes, it is
00:12:23 <dons> check the logs, we talked about this with xerox yesterday
00:12:27 <dons> it's quite easy in fact
00:12:32 <basti_> except for me.
00:12:35 <Speck> oh ok
00:12:42 <dons> you just generate appropriate javaScript calls to the google maps api
00:12:44 <kzm> Is Google Earth available for anything but Windows yet?
00:12:46 <basti_> you'd stalk an unnamed hill instead ;)
00:12:48 <dons> i.e. marker(21,42)
00:12:50 <Speck> kzm: nope
00:12:59 <dons> but you can run it in a web page!
00:13:07 <MarcWeber> Is anyone using hdirect and is willing to help me?
00:13:12 <Speck> dons: I'm not talking about google maps, google earth the program; it has waaay more features
00:13:15 <dons> oh, not google earth. google maps is scriptable at lesat
00:13:17 <dons> yes.
00:13:40 <Speck> MarcWeber: interfacing with COM?
00:14:07 <MarcWeber> Speck: Yes.
00:14:25 <MarcWeber> Speck: But I even didn't manage to compile
00:15:01 <MarcWeber> Speck: If you use it, which version (ghc and hdirect)?
00:15:07 <Speck> Hmm.. the visual haskell paper talks about interfacing with COM, and how hdirect is problematic, but I never used it :(
00:15:38 <dons> ok, rendering done :)
00:15:42 <dons> 16 mins
00:16:15 <MarcWeber> Speck: Where can I find this document?
00:17:21 <Speck> I read it off the acm portal... but I think it's publicly available somewhere... note though, it doesn't really get technical about interfacing with com at all
00:18:27 <Speck> http://www.haskell.org/~simonmar/papers/vshaskell.pdf   section 5
00:20:48 <MarcWeber> Speck: Thanks a lot!
00:22:12 <Speck> MarcWeber: I can point you to papers all day, it doesn't change the fact that I really have no way of helping you. You can however, appeal to the more knowledgeable members of the channel for Real Help(tm).
00:23:22 <Maddas> Cale: oh, I think it was a very good idea to use a monad to hide the chess board (state). Since I'll have to interleave parsing with simulating anyway,
00:24:07 <Maddas> Cale: I can just switch to using the Parsec monad to encapsulate state, if I understood the docs correctly. And all done transparently by changing one type signature :-)
00:25:22 <MarcWeber> Speck: I know got the idea to search for mailinglists on haskell.org. There is hdirect-cvs. I'll ask there.
00:26:22 <aleator> Anyone know if c2hs {#set#} hook can be made to work with non-typedef'd structs?
00:26:53 <ProfTeggy> Moin
00:27:45 <skew> Maddas: you could parse the list of entries into some more usable format, and do the simulation separately
00:29:18 <boegel|home> y0 ProfTeggy
00:32:29 <kosmikus> moin
00:33:38 <Oejet> Hello.
00:34:52 <C-Keen> moin.
00:35:49 <boegel|home> hey Oejet
00:36:08 <skew> has anyone around here looked at Perfect Developer (www.eschertech.com)?
00:40:46 <Oejet> boegel|home: Hey, why aren't you in school?
00:42:01 <boegel|home> Oejet: first of all, I'm working already :)
00:42:22 <boegel|home> and second, because my gf needs to film a child doing stuff for school, and she needs help with that
00:42:23 <Oejet> Ups. :-[
00:42:36 <boegel|home> Oejet: but I'm working at uni, hence the confusion maybe :)
00:42:51 <Oejet> What kind of job?
00:43:11 <Oejet> Dean?
00:43:18 <Oejet> Principal?
00:43:29 <Muad_Dibler> nah
00:43:30 <Muad_Dibler> cleaner
00:43:46 <Oejet> :-P
00:43:57 <basti_> janitor :P
00:44:10 <boegel|home> Oejet: toilet cleaning, why do you ask ?
00:44:24 <boegel|home> Oejet: no, I started a Phd
00:44:37 <Oejet> Uh.
00:46:32 <Oejet> Hm, I got the impression that you just finished you bachelor, sorry.
00:46:38 <Maddas> skew: I'm not sure that's possible with PGN
00:49:26 <skew> Maddas: you could parse it into something like [(Maybe Rank, Maybe File, Piece, Rank, File, Extras)]
00:49:50 <skew> probably some record type would be best
00:49:54 <earthy> oejet: he's european
00:49:59 <earthy> mainland european
00:50:09 <Muad_Dibler> hmm
00:50:09 <Maddas> skew: Heh, yeah, I could parse it into multiple possibilities. Hmm.
00:50:10 <earthy> there isn't really such a thing as a bachelor in mainland europe
00:50:22 <earthy> but for that silly little country .nl
00:50:22 <Muad_Dibler> are belgians actually considered europeans?
00:50:36 <skew> Maddas: I just mean piece, destination rank and file, and the source if they were given
00:50:54 <Maddas> skew: No, not without simulation -- it's ambiguous if you don't simulate the board.
00:50:55 <ProfTeggy> earthy, not true
00:51:12 <skew> Maddas: there are some letters written on the paper
00:51:30 <Maddas> skew: Yes, but those are ambiguous without simulation, if I understood it correctly.
00:51:32 <earthy> profteggy: okay, what is the bachelor's in germany?
00:51:38 <skew> sure, if you are thinking of chess
00:51:40 <ProfTeggy> According to the "Bologna process", virtually European countries have switched over to a BSc/MSc education scheme
00:51:43 <Maddas> Right :-)
00:51:45 <Oejet> earthy: Someone isn't from mainland Europe at least. ;-)
00:51:47 <skew> you can build up an AST for the stuff written on the page, though
00:51:51 <ProfTeggy> s/virtually/virtually all/
00:51:57 <Maddas> skew: Oh, right.
00:52:02 <earthy> ah. yes. that's the 'formal' process
00:52:09 * Oejet agrees with ProfTeggy.
00:52:12 <earthy> I only know of .nl having implemented it in practice. :)
00:52:16 <ProfTeggy> earthy, and it's implemented quite widely already
00:52:20 <Maddas> skew: I'm planning to do that pretty much as you said
00:52:30 <ProfTeggy> earthy, get an update then ;-)
00:52:43 <earthy> so, how is it implemented in .de? you should know...
00:52:52 <skew> Maddas: oh, it sounded like you were planning on mixing the computation into the parsec parsing, which might make things more confusing
00:52:57 <Maddas> skew: I see what you mean, though. Hmm. Now that the simulation part is already written, though.. wouldn't it be easier to intersperse the things?
00:53:03 <Maddas> Right, I was planning that ;-)
00:53:11 <skew> intersperse?
00:53:16 <Maddas> Computation and parsing
00:53:17 <ProfTeggy> Of course I know.  At TU Munich (m univ), there's no diploma anymore.  Only BSc/MSc.  The same at my old univ (Konstanz)
00:53:18 <skew> if you mean in runtime, lazy evaluation should handle that
00:53:19 <Oejet> earthy: The university of Copenhagen had it for a while, the Technical University of Denmark just got it two years ago.
00:53:24 <ProfTeggy> And these are not exceptions
00:53:28 <skew> though I don't know the details of what parsec does
00:53:36 <ProfTeggy> Konstanz offers the BSc of Information Science for 4 years now
00:53:41 <Maddas> Me neither, it's my first Parsec program :-)
00:53:53 <boegel|home> Oejet: I just finished my Master study, but it was a Master before the BaMa changes in our uni
00:53:54 <Maddas> I think it should work OK, though. But I'll keep your concerns in mind :)
00:54:28 <Oejet> boegel|home: So four years master?
00:54:30 <Maddas> And I didn't think of lazy evaluation -- that really might make the seperate parsing/computing approach work just fine
00:54:34 <boegel|home> Oejet: yeah
00:54:55 <Maddas> skew: Thanks a lot for the input :)
00:54:56 <Oejet> boegel|home: I think you told me that already then. :-)
00:54:59 <skew> Maddas: also, it's not like building up an intermediate list in total wastes much RAM, and I doubt the computation time is significant compared to the IO cost anyway
00:55:16 <Maddas> skew: Right, the computation time should be neglible.
00:55:17 <boegel|home> Oejet: could be :) I tend to forget things like that too from other people, it so confusing :)
00:55:44 <basti_> ProfTeggy: the problem is that the MSc/BSc transition is used as an excuse for radical monetary cuts
00:56:14 <Oejet> boegel|home: That's nice, so I guess the old master was more specialized?
00:56:24 <ProfTeggy> basti, I have heard more and other excuses for these cuts... but you're right to some degree
00:56:28 <earthy> okay, the situation has changed *considerably* since 3 years ago then
00:56:29 <Maddas> skew: It's just that if I don't compute, the intermediate list might branch at certain moves, and that might lead to an explosion of possible "next states"
00:56:42 <boegel|home> Oejet: don't know much about the new master actually :) and I don't care either :)
00:57:07 <skew> Maddas: that's why I'm suggesting that you don't try to produce a tree of boards as the parse result
00:57:09 <basti_> ProfTeggy: basically, here the situation is like "go msc/bsc and lose 2 professors and a lot of money too, or don't move an inch and keep everything as it is". not hard to pick then.
00:57:20 <Maddas> skew: Aah, d'oh, *now* I understand.
00:57:24 <boegel|home> anyway, I have to go, my gf needs me
00:58:04 <Maddas> skew: I might just do it that way indeed! Good idea. Thanks :-)
00:58:12 <Oejet> boegel|home: Of course, you can't be apart. ;-)
00:58:14 <ProfTeggy> basti, maintaining the status quo is not an option anymore for .de universities
00:58:25 <Maddas> Need to leave for the hairdresser now :-) Later
00:58:33 <ProfTeggy> basti, they're legally forced to move on no later than 2010
00:58:34 <Muad_Dibler> meaning he's going to do the dishes :P
00:58:37 <basti_> how cool :D
00:59:22 <basti_> so basically we're cutting scientific quality and selling that as standardisation.
00:59:35 <earthy> um. in a sense
00:59:43 <basti_> thats great too, as we can complain later that there's not enough science.
00:59:55 <earthy> the base idea of the bologna process is to homogenize the educational market in .eu
01:00:14 <Oejet> basti_: Yay!  We need more engineer politicians like in the Soviet.
01:00:23 <earthy> so that students can e.g. get their master's in Munich after having gotten their bachelor's in Maastricht
01:00:24 <basti_> thats great, we'll get romanias scientific quality and transparency :D
01:00:43 <basti_> i mean i also fail to see the importance of degrees being standard.
01:00:48 <basti_> isnt quality about being not standard?
01:01:06 <earthy> um. no. ;)
01:01:12 <basti_> not?
01:01:34 <earthy> quality is being perfectly up to standard
01:01:44 <earthy> without losing in other aspects
01:01:46 <basti_> but what if the standard is too low?
01:02:13 <earthy> then you shouldn't go for hookers.
01:02:28 * basti_ feels being made fun out of
01:03:43 <earthy> ;)
01:03:46 * Oejet pads basti_ on the head.
01:04:50 <earthy> if the standard is too low, it is easy for a good quality education to be up to that standard
01:05:02 <basti_> yes but it's bad for quality.
01:05:12 <earthy> overall quality, and maybe
01:06:30 <Oejet> Well, the thing politicians wants the best universities in the world for free.
01:06:46 <earthy> wouldn't you want that too?
01:06:55 * Oejet is dropping too many words today. :-(
01:07:02 <earthy> it's unrealistic, but a nice wish, isn't it?
01:07:07 <basti_> what they'll get is mediocre education for too much money
01:07:10 <kosmikus> free for politicians, not free for students, right?
01:07:52 <basti_> basically, I'm getting most of my education off the 'net anyway...
01:07:59 <Oejet> kosmikus: Hm, that's not the Danish system, but the principle still apply.  ;-)
01:08:01 <eivuokko> No, they want, what politicians always want, power - over universities :)
01:08:36 <Oejet> eivuokko: Yeah, my uni got a politically appointed board recently.
01:08:40 <eivuokko> At least here in Finland universities are not technically under government's jurisdiction, so that is being used as a lever now, I think.
01:09:04 <basti_> they're not controlled directly in germany either, but the government decides about the money (of course)
01:09:08 <basti_> so the lever is: no money.
01:09:15 <earthy> yes and no
01:09:28 <basti_> if someone complains: less money.
01:09:40 <earthy> universities are perfectly allowed to obtain funds from other places
01:10:00 <eivuokko> Well, of course money and such is controlled by government, but the negative publicity about cutting money for education is a high cost...
01:10:00 <basti_> yes but thats not really feasible for mathematical stuff usually.
01:10:09 <Oejet> earthy: That's the dream of politicians. :-)
01:10:12 <basti_> no its near to zero in germany.
01:10:24 <basti_> there is no problem with cutting education spendings anymore
01:11:11 * earthy e.g. knows about Nijenrode University, which is definitely *not* government-funded but an accredited university nonetheless
01:11:42 <earthy> ofcourse, they only do law, business and accounting
01:11:43 <earthy> but still
01:11:46 <eivuokko> :)
01:11:54 <basti_> what a strange coincidence... ;)
01:14:30 <basti_> so basically, "useful science" (engineering) and "greedy idiots accumulation" (law, buisiness etc.) can of course suistain themselves
01:14:37 <basti_> nobody is going to pay for computer science.
01:15:26 <Oejet> basti_: Ah, but if you mix in a bit of "computer engineering", that might work. ;-)
01:15:46 <eivuokko> Well, CS often has (almost) direct practical uses.  Consider history, philosophy etc....
01:16:10 <basti_> people fail to see even *those* uses. the situation in history etc. is -far- worse
01:16:31 <Oejet> eivuokko: CS is unproven!  It only has a history of about 50 years.
01:16:55 <basti_> people don't realize what good CS could do
01:17:08 <Oejet> basti_: Hehe.
01:17:14 <eivuokko> It might be a bit cultural thing, I think in Finland a lot of CS is actually engineering, even at the universities.
01:17:14 <earthy> people don't use CS
01:17:16 <basti_> theyre happy with their windows, their SQL databases and the 3 crashes a day
01:18:06 <Oejet> Denmark pays the most in the world per capita to Microsoft. :-P
01:26:15 <earthy> so you make ghc possible, in a sense. :P
01:57:32 <mcnster> hi
01:57:59 <dcoutts> hello
01:58:07 <shapr> yow!
01:58:10 <mcnster> hello dcoutts :)
01:58:22 <shapr> skew: Is Perfect Developer like Programatica/
01:58:51 <bortzmeyer> I do not find in Haskell a way to prefix functions by the name of the module they come from.
01:58:56 * mcnster just spent an hour playing with Mathematica.  way cool
01:59:02 <bortzmeyer> For instance, somthing like IO.openFile
01:59:33 <bortzmeyer> Because, if I import a lot of modules, it can be difficult to find out where does a function come from
02:00:04 <int-e> bortzmeyer: import qualified Module [as Shortcut]
02:00:07 <mcnster> bortnmeyer, try System.IO.openFile
02:00:21 <skew> shapr: it's some kind of theorem prover / code extractor
02:00:43 <int-e> bortzmeyer: for example, import System.IO as IO
02:00:46 <int-e> err
02:00:48 <bortzmeyer> Yes, but I wanted  a way to make it *mandatory*
02:00:51 <int-e> import qualified
02:00:54 <shapr> int-e: or import qualified
02:01:14 <skew> like design by contract, but deriving implementation from the contracts, and proving consistency
02:01:24 <int-e> import qualified System.IO as IO .... there.
02:01:29 <bortzmeyer> import qualified works, many thanks, I don't know why I missed it in the report
02:01:33 <skew> bortzmeyer: I think there is a GHC option that will clean up your import list, which is mostly what you want
02:01:34 <dcoutts> ibid, since you inspired mw with your JyuGraphics, I've started writing an implementation of Graphics.SOE using Gtk+ and cairo. I'm trying to be strictly conforming to the SOE API.
02:01:54 <skew> bortzmeyer: er, if what you want is to figure out where functions are coming from in a big piece of somebody else's code
02:02:33 <skew> bortzmeyer: by "clean up" I mean keep the minimal set of imports, and explicitly list what things you get from each of them
02:02:40 <bortzmeyer> skew: yes, that would be useful. import qualified is fine for new code but nt for reverse-engineering. (A good IDE may help here.)
02:02:52 <shapr> kazehakase is a nice browser, small memory footprint and very configurable.
02:03:07 <bortzmeyer> BTW, IMHO, "qualified" should be the default for import (like it is in Python or Ada)
02:03:33 <skew> why?
02:03:50 <bortzmeyer> skew: because the default should be to make thinsg explicit
02:04:08 <skew> please don't suggest that for the type system...
02:04:40 <eivuokko> Hmmm.
02:04:42 <mcnster> i like brevity.  it was hard to write.  it should be hard to read
02:04:54 <mcnster> ;)
02:04:59 <dcoutts> mcnster, hah :-)
02:05:03 <C-Keen> not the right was imho
02:06:50 * mcnster shudders at the thought of reading formulae with verbosity turned on
02:08:00 <mcnster> or verbosity with formulae turned off
02:08:11 <mcnster> or something
02:08:29 <skew> (fac :: Int -> Int) (x :: Int) = (((((*) :: Int -> Int -> Int) (n::Int) :: Int->Int) ((fac :: Int -> Int) ((dec :: Int -> Int) (x :: Int) :: Int) :: Int)
02:08:35 <skew> yep, explicit is better than implicit
02:09:02 <mcnster> eyes glaze over, nodding
02:09:13 <basti_> :-O
02:09:21 <skew> seriously, the compiler tells you if some name you refer to is ambigous between different modules you've imported, so why worry?
02:09:33 <int-e> skew: do you think it's wise to rely on the associativity of -> like that?
02:09:44 <skew> it's either that or more parens
02:09:50 <skew> but I guess explicit is better...
02:09:57 * skew types away
02:10:02 <skew> maybe not
02:10:03 <dcoutts> skew, sometimes it's useful for the reader to see which module a name is from.
02:10:14 <mcnster> BEGIN HASKELL DIVISION MODULE START
02:10:29 <dcoutts> skew, I often import qualified Graphics.UI.Gtk as Gtk
02:11:28 <dcoutts> skew, so long as we can give all modules 3 or 4 char nicknames it's ok :-) Map, Gtk, Set, etc..
02:11:34 <skew> have the programmatica people released their web page generator?
02:11:55 <skew> ... Zqp , Tgk, LmW ...
02:12:23 <skew> import X as Y is nice
02:12:44 * earthy kicks mcnstr
02:12:47 <earthy> +e
02:13:23 <skew> I don't know if the qualified is always a good idea
02:13:34 * dcoutts kicks letter out of arthy's name  +e
02:13:54 <earthy> ey, he started with the cobol
02:14:06 <earthy> that deserves a kick in my opinion
02:14:37 <skew> even, rather, especially if you are doing something using the graphics heavily, I think it could be clearer to throw in the GTK only once
02:14:52 <dcoutts> arthy, "y, h startd with th cobol that dsrvs a kick in my opinion"
02:15:30 <skew> GTK.buildWindow (menuBar [item "x"]) (hsplit (label "type") (textinput 10)
02:15:41 <dcoutts> skew, right, it's when it's mixed in with other things that you want to distinguish GUI operations from other bits
02:15:44 <skew> )or whatever, vs. tossing the GTK on everywhere
02:15:48 * earthy laughs
02:16:05 <skew> so I don't think I agree with the "qualified"
02:16:56 <skew> programmatica/hIDE/yi is supposed to fix this all anyway with handy metadata, right?
02:17:05 <MarcWeber> Does anybody have some simple program using happy to learn how to use happy?
02:17:25 <dcoutts> skew, what kind of metadata?
02:17:36 <dcoutts> skew, it should make refactoring easier.
02:19:07 <skew> check out http://www.cse.ogi.edu/~hallgren/Programatica/tools/pfe.cgi
02:19:36 <skew> the little pop ups like "this has type forall a b . a -> b, it came from GHC.Prim"
02:23:43 <ibid> dcoutts: nice
02:24:19 <dcoutts> ibid, the lines etc are nice and smothe :-)
02:24:50 <xerox> 'morning!
02:28:22 <kolmodin> morning
02:33:53 <Oejet> In Java it seems you can have either fast ugly lines or slow anti-aliased lines.
02:34:02 <musasabi> "A Monadic Framework for Subcontinuations" looks interesting.
02:34:25 <xerox> musasabi: did you read it?
02:34:26 <dcoutts> Oejet, hopefully cairo is better optimised than the Java 2D api
02:35:50 <musasabi> xerox: Glanced over it and now reading it with more time.
02:36:48 <xerox> musasabi: I'm very interested in composable continuations - but I see that the paper starts with prompts, which are some other operators than the ones I know
02:37:15 <xerox> I think I need some preparatory lecture before
02:37:27 <xerox> @seen skew
02:37:28 <lambdabot> skew is in #haskell. Last spoke 17 minutes and 50 seconds ago.
02:37:54 <musasabi> xerox: prompts are quite simple, but I all implementations I know in Haskell are hacks. (and I think they could be implemented with shift/reset if I understand things correctly - just no idea how)
02:38:48 <musasabi> xerox: e.g. the ZFS from oleg includes a very simple prompt based delimeted continuation implementation (which seems to be analoguous if not the same as the paper).
02:38:57 <xerox> My understanding of shift/reset stops at being able to write delimited-continuations-{fibonacci,factorial}, as now
02:39:47 <xerox> (which was fun)
02:42:41 <musasabi> Would wxhaskell or gtk2hs make for easier graph editing software? (I just want to prototype things - so something very simple would be nice)
02:44:59 <shapr> musasabi: Can you steal Dazzle?
02:45:04 <sylvan> musasabi, I don't think it matters much, unless you can find a specific component in either that would make it easier
02:45:17 <sylvan> Like "GraphEditComponent" =)
02:46:08 <dons> sylvan: add your details! http://www.haskell.org/hawiki/HaskellUserLocations
02:46:20 <shapr> Hm, is the source for Dazzle available? http://www.cs.uu.nl/dazzle/images/screenshot.jpg
02:46:45 <dcoutts> musasabi, I'm looking at doing some graph stuff with Gtk+ and cairo for hIDE - the module dep graph.
02:47:22 <dcoutts> musasabi, the idea is that it'll be a way of browsing the modules in a project (ina ddition to the normal boring tree views)
02:47:49 <dcoutts> so I'm not planning on graph editing as such, but it'l be scrolling around and selecting nodes in a graph.
02:50:19 <shapr> hm, dazzle doesn't seem to be open source.
02:52:19 <astrx> just a question: is it possible to convert a "Gen a" to an "a"?
02:52:39 <shapr> er, yes
02:53:12 <Sonderblade> can haskell handle utf8?
02:53:35 <shapr> Isn't arjan van IJzendoorn on #haskell?
02:53:36 <musasabi> Sonderblade: yes, but the standard libraries don't do it very well.
02:53:46 <astrx> how do i do this? i got a generator for a world wich returns a Gen World, and i want the handle the output as a World.
02:54:01 <Sonderblade> musasabi: so if i want to print utf8 strings on the console what do i do?
02:54:06 <astrx> i mean they look the same, but i got a type error
02:54:33 <dons> Sonderblade, ah, that's harder, since the standard IO functions write bytes at the lowest level
02:54:53 <dons> s/assume chars are bytes/ as musasabi pointed out
02:55:37 <astrx> i want to get a world p√• typing world <- genWorld in my main funciton main :: IO ()
02:55:55 <astrx> but that cant be done since the genWorld returns a Gen World
02:56:06 <astrx> and not a World
02:56:12 <astrx> any easy way to solve this?
02:56:16 <dons> (Gen world) <- genWorld ?
02:56:25 <shapr> musasabi: I'll mail the dazzle guys and see if their graph editing code will be released at some point.
02:56:38 <Sonderblade> dons: ok but what's the solution?
02:56:51 <musasabi> shapr: I think they were talking something about releasing it "soon".
02:56:57 <astrx> dons: hehe sound good.
02:57:00 <shapr> Cool, good to hear.
02:57:09 <Sonderblade> dons: or isn't it possible?
02:58:18 <astrx> dons: "Undefined constructor function Gen"
02:58:20 <dons> Sonderblade, Simon Marlow has some recent code for reading and writing unicode to handles, so maybe that would work. haven't tried it though. let me see..
02:59:16 <ibid> i also have some utf-8 file handling code, probably won't compile with modern compilers :)
02:59:18 <musasabi> Handling encodings correctly is very hard.
02:59:30 <astrx> dons: any ideas?
02:59:47 <musasabi> As many times one has to preprocess the file before decoding and different parts of the stream are encoded in different ways.
02:59:57 <dons> astrx, not sure, I'd need to seee more code to work out the problem. is Gen not imported? or is it abstract?
03:00:03 <xerox> If Gen is a Monad, world >>= (f :: World -> ..) ?
03:00:42 <dons> ah, maybe. /me is sleepy
03:00:47 <musasabi> A stackable IO framework could solve many of the problems.
03:02:10 <astrx> dons: Gen is not imported. but it shouldnt have to be? its a standard constructor, right?
03:03:02 <astrx> xerox: I don understand what you mean?
03:07:39 <shapr> Man, I really like kazekahase browser, low memory usage and fast rendering.
03:18:47 <{Arias}> hi, can somebody help me?
03:19:20 <{Arias}> i'm trying to connect with a server
03:19:27 <{Arias}> and i use something like this:
03:19:35 <{Arias}> server = "localhost"
03:19:35 <{Arias}> port = PortNumber 8080
03:19:35 <{Arias}> handler <- connectTo server port
03:19:46 <Maddas> shapr: Cool, got any screenshots about Kazekahase?
03:19:48 <{Arias}> bute the connectTo thorws a exception:
03:20:09 <{Arias}> getSErviceEntry: no such service entry
03:20:12 <{Arias}> :(
03:20:58 <Maddas> shapr: Ah found one
03:21:11 <shapr> It looks boring, but it sure is fast.
03:22:10 <Maddas> Nifty :-)
03:22:15 * Maddas never heard about it before
03:22:27 <shapr> I just heard about it yesterday.
03:25:08 <shapr> greetz HeverClev, how's code?
03:25:49 <{Arias}> 8-)
03:30:53 <shapr> ah, it's "kazehakase" I misspelled it earlier.
03:31:58 <shapr> hiya basbom, learning Haskell?
03:32:05 <basbom> yes, always learning
03:32:20 <HeverClev> A question about names. I'm experimenting with Java-like interfaces using types (as seen in hs-plugins), but I have problems with name classes
03:32:21 <shapr> Have you been to #haskell before, or is this your first time?
03:32:46 <basbom> first visit for basbom
03:32:48 <HeverClev> suppose I have data HuffEncoder = HuffEncoder { initialize :: HuffTreeMaker, ... }
03:33:00 <HeverClev> and then I have data HuffDecoder which also needs a initialize step
03:33:08 <basbom> what is the url to this group?
03:33:28 <HeverClev> what trick can I use to avoid changing the name of the second initialize ø?
03:33:37 <shapr> basbom: The channel logs are in the topic.
03:33:39 <HeverClev> greetz shapr!
03:33:46 <shapr> hej igen astrx
03:33:57 <astrx> shapr: tjo
03:34:00 <HeverClev> * name clashes I meant
03:34:18 <shapr> HeverClev: maybe use a typeclass instead?
03:34:20 <astrx> shapr: har du n√•n l√∂sning p√• mitt lilla problem?
03:34:42 <HeverClev> that aint swedish..
03:34:42 <shapr> nej, inte riktig... but I know I've done it before last time I hacked on QuickCheck.
03:34:53 <shapr> Looks like Swedish to me.
03:35:01 <basbom> let's say I have a type    data State s a = ST(s -> (s,a))           is there a logical meaning of a type    State s ?
03:35:17 <HeverClev> I've spent one year in Stockholm, lovely place
03:35:34 <shapr> HeverClev: Om du talar svenska ocks√•, finns det #haskell.se
03:35:36 <astrx> yep...hmmm..have to get it working. one solution would be to replace all occurances of World with Gen World? right?
03:35:45 <shapr> HeverClev: Oh maybe your encoding is set to latin-1 rather than utf-8?
03:35:48 <HeverClev> shapr ja tala inte svenska....
03:35:56 <shapr> Well, neither do I, really.
03:36:06 <HeverClev> shapr right
03:36:12 <shapr> I do live in Sweden though.
03:36:25 <shapr> astrx: What's the problem exactly? Why are you trying to turn Gen a into a?
03:36:30 <HeverClev> well, then you'd better learn or you'll regret it
03:36:35 <shapr> Yes, I agree.
03:36:37 <basbom> like a kind of partial type application so to speak...
03:37:27 <shapr> basbom: I've seen it used, I think it means "This parameterization of State holds a state specifically of type s"
03:38:16 <basbom> This is something I saw in a tutorial for monads. So I don't think it's anything advanced.
03:38:44 <basbom> where the monad class was State s
03:39:13 <basbom> but the declaration of State was
03:39:13 <basbom> data State s a = ST(s->(s,a))
03:39:53 <HeverClev> shapr elaborating on classes. I thought on using classes before, but then I thought .... there must be some good reason for not doing so, since hsplugins does not and these guys sure know better than me
03:40:16 <HeverClev> would there be any negative implications that you can think of ?
03:43:30 <shapr> I'm not sure.
03:43:54 <shapr> Record types sometimes get used for cheesy OO implementations, if that's all you need.
03:44:12 <xerox> ...it comes Oleg at mind again.
03:44:16 <shapr> Typeclasses aren't quite the same thing... I'll get you a useful url instead.
03:44:42 <xerox> shapr: cheesy, as in, with holes? :)
03:44:59 <shapr> HeverClev: Check out Graham Klyne and Alistar Bayley's articles - http://www.haskell.org/tmrwiki/IssueThree
03:45:04 <shapr> xerox: haha, cheesy zippers :-)
03:47:02 <xerox> shapr: I should point to you again that the discussion about deriving types was very interesting :)
03:47:37 <xerox> I'll not spoil the fun, I think basti_ has the log
03:50:09 <shapr> Sure, I'd like to see it.
04:03:47 <shapr> basti_: Can I get a copy of the log?
04:04:05 <basti_> shapr: the differential types log?
04:04:22 <basti_> http://deimos.dynalias.org/derivatives-of-types.txt
04:04:24 <basti_> there
04:05:06 <shapr> basbom: If you want an introduction to monads, read http://www.nomaware.com/monads/
04:08:13 <Sonderblade> how do i do to print a random number from 1 to 100 on the console?
04:09:42 <basti_> in ghci, like:
04:09:44 <basti_> :m Random
04:09:48 <basti_>  a<-newStdGen
04:09:51 <basti_> (random a)::(Int,StdGen)
04:10:28 <Sonderblade> and how do you do it in ghc?
04:10:36 <Maddas> basti_: that is just.. wow :)
04:10:42 <basti_> Maddas: what?
04:11:01 <Maddas> The thing in the log
04:11:04 <basti_> Maddas: yes ;)
04:11:12 <Maddas> (Cool, dynalias.org still exists? :)
04:11:27 <basti_> Sonderblade: just like that... just, if you want to get more than one number, you have to take a little care
04:11:30 <basti_> apparently!?
04:13:07 <Sonderblade> basti_: i don't understand, is there not like a function that returns a random number in an interval?
04:13:46 <basti_> yes there it, it is called randomR
04:15:04 <Sonderblade> basti_: do i need to import some module?
04:15:14 <basti_> yes, "Random"
04:16:37 <Sonderblade> thanks.. and how do i get it out on the console?
04:17:16 * Sonderblade is a haskell noob
04:17:50 <basti_> ":m Random"
04:18:15 <shapr> astrx: Do you get an error trying to use wxHaskell?
04:18:46 <kolmodin> in a IO function there are many calls to IO functions and if any of them returns True I want the top level function to return True as well. I thoght that I might simplify the code by using the Lazy ST monad
04:18:57 <kolmodin> however, it doesn't work as I want
04:19:04 <kolmodin>       4 b = stToIO $ do
04:19:04 <kolmodin>       5       exist <- unsafeIOToST $ doesFileExist ".bashrc"
04:19:04 <kolmodin>       6       unsafeIOToST $ putStrLn "don't print this"
04:19:04 <kolmodin>       7       return exist
04:19:20 <kolmodin> run that and it will print "don't print this"
04:20:26 <kolmodin> is that the correct use of the ST monad?
04:20:45 <kolmodin> if I change stToIO to runST it will not print anything
04:21:13 <kolmodin> any hints?
04:25:22 <xerox> Yow
04:25:32 <boegel> @y0w
04:25:33 <lambdabot> Now I think I just reached the state of HYPERTENSION that comes
04:25:33 <lambdabot> JUST
04:25:33 <lambdabot> BEFORE you see the TOTAL at the SAFEWAY CHECKOUT COUNTER!
04:25:55 <xerox> Maddas: it is at least surprising!
04:26:01 <Maddas> Hello, my name is Maddas and I have a problem. I can't stop thinking of and in Haskell, and I only just started using it!
04:26:26 <Maddas> xerox: Indeed :-)
04:26:40 <xerox> @type and
04:26:47 <kolmodin> Maddas: welcome to the club
04:26:48 <lambdabot> [Bool] -> Bool
04:26:49 <xerox> This one?
04:27:02 <Maddas> haha
04:27:14 <xerox> @plugs let xs = [True,True,True] in all xs == and xs
04:27:17 <lambdabot>   Expecting a function type, but found `[Bool]'
04:27:17 <lambdabot>   Expected type: a -> Bool
04:27:17 <lambdabot>   Inferred type: [Bool]
04:27:22 <Maddas> xerox: You didn't direct that to me, did you?
04:27:26 <xerox> Maddas: I did
04:27:40 <Maddas> Very funny, I see how you parsed my sentence, very amusing indeed :-)
04:27:55 <xerox> It had another meaning?  Urgh :D
04:27:58 <Maddas> I meant "can't stop thinking of [Haskell] and in Haskell"
04:28:08 <xerox> Woot :D
04:28:11 <Maddas> er, "thinking of [Haskell] and [thinking] in Haskell"
04:28:17 <xerox> I got it this time :-)
04:28:28 <Maddas> But on second reading, the ambiguity is amusing :-)
04:28:40 <Maddas> (Did I mention that I am easily amused? ;-)
04:29:32 <xerox> How's going the Chessy code?
04:29:48 <shapr> Why do my clients persist in sending me html email that's not even legal html?? yargh!
04:30:04 <Maddas> shapr: Eek.
04:30:29 <Maddas> xerox: I'm being annoyed by en passant capturing. Playing with them is fun, but correctly validating them requires keeping more state around, boo!
04:30:30 <xerox> They need to see The Light
04:30:48 <xerox> Maddas: and what's the problem with it?
04:31:03 <Maddas> xerox: Nothing, but the way I implement things now, I can't detect it elegantly.
04:31:14 <xerox> The Chess Monad idea convinced me profoundly :)
04:31:34 <Maddas> Ah, hmm. Maybe I could extend the monad to keep around all previous moves.. That would make a few things easier
04:31:54 <Maddas> Hmm, funny how fast one can go from barely understanding monads to liking them a lot :-)
04:32:06 <Maddas> (Or even getting there while only barely understanding tehm :-P)
04:32:29 <xerox> I look forward to see your code :-)
04:32:36 <Maddas> Them, even. Anyway, lunch time now. xerox: If you want to see the little code I have just say so, I'm sure you'll find nice ways to improve on it :-)
04:32:41 <Maddas> Heh, ok, I'll put it up somewhere in a bit.
04:34:34 <xerox> This method in p6/pugs stupefied me:
04:34:36 <xerox> pugs> sub ($x,$y) { $x+$y }
04:34:37 <xerox> sub {...}
04:34:37 <xerox> pugs> $_.arity
04:34:37 <xerox> 2
04:36:49 <shapr> JohnMeacham: I think there would be lots of research paper caches except for scary copyright issues.
04:40:36 <Sonderblade> are programs in haskell easier to understand than in other languages?
04:41:29 <shapr> Often, yes. I think it's because higher order functions let you factor out patterns effectively.
04:42:54 <Oejet> Well, in the beginning I'd say, it's more difficult to read exactly because of that.
04:44:42 <Sonderblade> so a haskell program is generally shorter than the same one in an imperative language?
04:45:08 <HeverClev> should be. But often for me it's shorter BUT more cryptic
04:45:25 <HeverClev> I guess it's just I'm more used to imperative code
04:45:45 <shapr> Yes, Haskell programs are usually much shorter.
04:46:21 <Oejet> shapr: Which means there is more room for comments. ;-)
04:46:59 <musasabi> Added a fake getaddrinfo implementation for buggy platforms (e.g. Mac OS X) to network-alt - now it should work there better.
04:47:24 <Sonderblade> even shorter than Python?
04:47:43 <xerox> Sonderblade: ever shorter than Python
04:47:46 <shapr> Sonderblade: That also explains why single letter names are sometimes best for Haskell code. Because, in some cases it's not the variable, but the pattern of the code that is important.
04:51:06 <Sonderblade> i see thanks
05:04:50 <Maddas> Hmm, I wonder why very short variable names often don't (but occasionally do) bug me in Haskell where they would in other languages.
05:06:46 <musasabi> My guess would be because you don't mut(il)ate them.
05:06:54 <Lor> Because the code is so concise anyway that the size of variable names affects it significantly.
05:07:27 <Lor> In C, you need so much crud that using properly named variables doesn't really make it longer.
05:08:11 <ibid> and variables tend to have very small scopes
05:08:22 <Maddas> Right, and I think chaining/composing functions reduces the amount of times you explicitly address the variables.
05:08:22 <ibid> which, even in C, is a criterion for allowing short names
05:08:25 <Maddas> (Visibly)
05:08:56 <Maddas> That would explain why 0-letter variable names are no problem in point-free programming ;-)
05:09:15 <ibid> :)
05:09:46 <ibid> even in Haskell, toplevel names tend to be longer
05:10:06 <Maddas> Right, I noticed that bindings introduced in do-blocks tend to have longer names too.
05:12:07 <xerox> Things that deserve naming deserve proper naming.
05:13:44 <dons> ibid, Maddas, Lor: add your details :) http://www.haskell.org/hawiki/HaskellUserLocations
05:15:50 <dcoutts> hey dons, how's they yi/hIDE work going?
05:16:18 <Maddas> dons: I'm not registered yet, I'll keep it in mind though :)
05:16:27 <ibid> dons: just editing that should work, yes?
05:16:32 * dcoutts is looking forward to seeing some patches
05:16:45 <dons> editing is enough. or just /msg me the coords, and I'll add them.
05:16:57 <Maddas> Hm, ok. Time to fire up google maps.
05:17:07 <dons> dcoutts, a little bit more on getting multiple windows to work in yi.
05:17:20 <dons> but i have the next 3 days free, so ..
05:17:39 <dcoutts> dons, ok cool
05:17:50 <dcoutts> hi Lemmih_
05:17:53 <dons> dcoutts, now, a question, if the user switches focus to another yi window, can I get gtk to call yi back so yi knows which window has focus?
05:18:04 <dons> i assume: yes.
05:18:23 <dcoutts> dons, depends on what sort of window you're talking about exactly
05:18:32 <dons> ah, i'm talking about sourceviews
05:19:03 <dons> so if yi pops up a couple of TextViews on to some Yi buffers, and the user uses the mouse to shift focus
05:19:20 <dons> Yi will need to know that focus has changed, in order to, eg. switch keymaps
05:19:36 <Lemmih> Hi.
05:19:37 <dcoutts> dons, so when (within a single top level window) the user switches from one EditorPage to another, then the old one gets notified that it has been hidden, and the new one is told it is being shown.
05:19:41 <ibid> dons:
05:19:41 <ibid> Lat:
05:19:41 <ibid>     62:13:47N (62.2297)
05:19:41 <ibid> Lon:
05:19:42 <ibid>     25:40:57E (25.6826)
05:20:05 <dons> dcoutts, ah. cool.
05:20:08 <dons> ibid, thanks.
05:20:41 <dons> ibid, that's a long way North, but not quite first place ;)
05:20:43 <dcoutts> dons, if you are talking about multiple top level windows then the answer is no. You don't currently get notified when one window is focused and the other loses focus.
05:20:47 <ibid> http://www.multimap.com/map/browse.cgi?lat=62.2297&lon=25.6826&scale=5000&icon=x :)
05:20:57 <dcoutts> dons, since from our point ov view they are both open at the same time.
05:21:01 <ibid> dons: i was the northernmost debian developer for a couple of years :)
05:22:02 <dcoutts> dons, the current UI scheme is that only one EditorPage is shown per toplevel window at once. But that may change.
05:22:36 <dons> dcoutts, ah. so what if I want to split my yi view, and view to buffers in half of the yi widget each?
05:22:42 <dons> i.e. :split ?
05:22:50 <dons> any thoughts on this?
05:22:51 <dcoutts> dons, so eg if you had a split view between two pages shown in the same top level window, would you want to know when focus moves from one to the other?
05:23:15 <dons> yep, yi might have to switch keymaps
05:23:22 <dcoutts> you can get gtk to tell you when a widget recieves or looses the input focus
05:23:33 <dons> ok. good.
05:23:41 <dcoutts> when/why do you need to switch keymaps?
05:24:17 <dons> one might be running in, say, default mode, the other might be in 'insert' mode in vim, or say, contain haskell-specific bindings
05:25:27 <dcoutts> oh, I though each input buffer had it's own input processing thread which is attached to one SourceView widget
05:25:39 <dons> no, but that's a good idea!
05:25:51 <dcoutts> in that case there's no switching needed
05:25:52 <dons> esp. since all the state is locked up nicely already
05:26:05 <dcoutts> since a window just stops getting keystrokes when it looses focus
05:26:10 <dcoutts> window/widget
05:26:23 <dons> yeah, I like that better. the old model really also comes from ncurses, where yi has to manage all the focus switching
05:26:25 <dcoutts> how does it work at the moment?
05:26:31 <Maddas> dons: Oh, eek, I guess I should register my nickname too..
05:26:58 <dons> Maddas, I think you just click on "userPreferences" . add a name and passwd, refresh, and away you go
05:27:39 <Maddas> There we go
05:28:47 <Maddas> Oh, so easy? Fair enough
05:37:19 <bourbaki> moin
05:38:59 <xerox> Howdy bourbaki
05:40:20 <dons> bourbaki, noclouds: add your details :) http://www.haskell.org/hawiki/HaskellUserLocations
05:41:13 * dons promises to stop hassling people once we get 50% of the high-water mark nicks
05:44:29 <xerox> We need this:
05:44:31 <xerox> pugs> "„ÅîËá™Áî±„Å´".chars
05:44:31 <xerox> 4
05:44:32 <xerox> hehe.
05:46:28 <dons> oh my. is that healthy?
05:46:44 <xerox> pugs> "„ÅîËá™Áî±„Å´".bytes
05:46:44 <xerox> 12
05:47:01 * dcoutts doesn't understand
05:47:16 <xerox> Do you see the unicode text?
05:47:21 <dcoutts> nope
05:47:26 <dcoutts> "".chars
05:47:35 <dcoutts> is what it looks like to me
05:47:40 <marcot> dcoutts: Morning.
05:47:45 <dcoutts> hi marcot
05:47:50 <xerox> There is some oriental glyphs or something between the quotes
05:47:51 <marcot> dcoutts: I got a problem building the debian package.
05:47:52 <xerox> *are
05:47:52 * dcoutts curses X-Chat
05:47:55 <marcot> make install runs ghc-pkg?
05:48:01 <xerox> That's why it's cool :-)
05:48:08 <dcoutts> marcot, use ./configure --enable-packager-mode
05:48:11 <bourbaki> nice thingy with the map
05:48:14 <xerox> This is also very cool:
05:48:25 <xerox> pugs> [+] 1..10
05:48:25 <xerox> 55
05:48:49 <dcoutts> marcot, that mode switches off the package registration phase and makes all dependency decision manual rather than automatic
05:48:51 <xerox> The [ .. ] meta operator applies the function element-wise, i.e. fold.
05:48:55 <ProfTeggy> foldl1 in disguise
05:49:01 <xerox> :D
05:49:02 <ProfTeggy> Nice, nice
05:49:10 <xerox> Indeed!  I want to hack something on pugs now.
05:49:14 <xerox> Check this out:
05:49:18 <marcot> dcoutts: ok, nice.
05:49:22 <dcoutts> marcot, so then if you want libglade (and you do) you need to ./configure --enable-packager-mode --enable-libglade
05:49:45 <dcoutts> marcot, and the smae goes for the other optional packages, gconf, mozembed, sourceview
05:49:47 <marcot> dcoutts: ok... I'll take a look at configure options better.
05:50:00 <dcoutts> ./configure --help is your friend
05:50:10 <xerox> pugs> sub function ($x,$y) { $x * 2 + $y }
05:50:10 <xerox> pugs> &function.arity
05:50:10 <xerox> 2
05:50:18 <marcot> dcoutts: and what about registering it after? What packages must I register?
05:50:38 <dcoutts> marcot, it installs the package files that you must register
05:50:43 <ProfTeggy> xerox, smells like reflection
05:50:56 <xerox> ProfTeggy: exactly.  It made me download pugs.
05:51:00 <ProfTeggy> xerox, is there an overview of which aspects of the language may be inspected?
05:51:01 <marcot> dcoutts: ok..
05:51:27 <ProfTeggy> Which characteristics of the languages' objects may be queried, that is
05:51:28 <dcoutts> marcot, the gentoo ebuild might help you: http://haskell.org/~gentoo/gentoo-haskell/portage/dev-haskell/gtk2hs/gtk2hs-0.9.9.ebuild
05:51:46 <ProfTeggy> .chars  .bytes  .arity, ... what else?
05:51:54 <xerox> ProfTeggy: you'd better ask in #perl6 - I'm going through the quickref at the moment, I don't know enough syntax to play with it smoothly :)
05:52:05 <ProfTeggy> xerox, I see, thanks
05:52:12 <xerox> Oh, for those, check the docs/quickref/ files!
05:52:15 <dcoutts> marcot, we've got it to build on x86, amd64 (with ghc-6.4.1), ppc, ppc64 and sparc64
05:53:20 <marcot> dcoutts: nice, I'll take a look at that.
05:53:48 <xerox> ProfTeggy: http://perlcabal.org/~autrijus/darcs/pugs/docs/quickref/
05:54:09 <ProfTeggy> [<]                    # monotony
05:54:12 <ProfTeggy> nice
05:54:18 <ProfTeggy> Tahnks xerox, I'm looking at it
05:55:06 <xerox> pugs> [<] [1,2,5,3,4,6]
05:55:06 <xerox> bool::true
05:55:06 <xerox> ?!
05:55:31 <ProfTeggy> hmm
05:55:56 <ProfTeggy> Are they using the 'or' instead of 'and' there?
05:56:00 <ProfTeggy> s/the//
05:56:14 <xerox> '[' and ']' aren't used for lists it seems
05:56:31 <xerox> pugs> [<] (1,2,5,3,4,6)
05:56:31 <xerox> bool::false
05:56:31 <xerox> pugs> [<] 1..6
05:56:31 <xerox> bool::true
05:56:34 <marcot> Is --enable-packager-mode --enable-libglade \
05:56:37 <marcot> --enable-gconf --enable-sourceview --enable-mozilla --enable-docs
05:56:39 <ProfTeggy> heh
05:56:52 <marcot> The same as --without-pkgreg?
05:57:06 <xerox> :D
05:57:53 <marcot> dcoutts: are they the same?
05:58:27 <xerox> Ah, ProfTeggy '[' and ']' delimits arrays.
05:58:35 <dcoutts> marcot, --enable-packager-mode implies --without-pkgreg
05:59:05 <marcot> hum.. but are this --enable-sourceview, moziila, gconf, libglade default?
05:59:07 <ProfTeggy> xerox, I see
05:59:44 <dcoutts> marcot, by default all the enable-PACKAGE things are in 'auto' mode which means they will be built if the required deps exist.
06:00:16 <marcot> dcoutts: hum.. ok.
06:00:49 <dcoutts> marcot, in --enable-packager-mode the default becomes "no" rather than "auto". And so in that case each optinal package that you want must be explictly asked for.
06:01:20 <marcot> dcoutts: So after installing I'll have to do the registration in hand, right?
06:01:20 <dcoutts> picking up deps accidentally would be a bad thing when building a distro package
06:01:27 <dcoutts> marcot, yep
06:01:32 <marcot> rm -f /usr/local/lib/gtk2hs/HSglib.o; /usr/bin/ghc-pkg  --auto-ghci-libs update /usr/local/lib/gtk2hs/glib.package.conf;  rm -f /usr/local/lib/gtk2hs/HSgtk.o; /usr/bin/ghc-pkg  --auto-ghci-libs update /usr/local/lib/gtk2hs/gtk.package.conf;  rm -f /usr/local/lib/gtk2hs/HSmogul.o; /usr/bin/ghc-pkg  --auto-ghci-libs update /usr/local/lib/gtk2hs/mogul.package.conf;  rm -f /usr/local/lib/gtk2hs/HSglade.o; /usr/bin/ghc-pkg  --auto-ghci-libs update /usr/loc
06:01:39 <marcot> All this?
06:02:03 <marcot> Shouldn't register be better?
06:02:10 <dcoutts> marcot, just like you have to register packages for other Haskell packages. Ask Igloo how you normally do that.
06:02:15 <marcot> And why all these rms?
06:02:39 <dcoutts> marcot, the rm is because otherwise ghc doesn't update the ghci .o files when you use --auto-ghci-libs
06:02:53 <dcoutts> marcot, but that might not be a problem for a distro package
06:03:10 <dcoutts> marcot, ask Igloo how you normally deal with registering Haskell libs
06:03:34 <Igloo> I think we'd rather you didn't use --auto-ghci-libs
06:04:24 <dcoutts> Igloo, what cabal version do you use in debain at the moment?
06:04:27 <Igloo> If gtk2hs isn't cabalised then you probably do need a list of ghc-pkg adds in postinst (and removes in prerm)
06:04:29 <marcot> Igloo: and ghc-pkg register?
06:04:40 <marcot> Igloo: that's how I do with c2hs.
06:04:52 <Igloo> dcoutts: Whatever is in ghc6
06:04:57 <dcoutts> c2hs doesn't have any packages/libs any more
06:05:05 <dcoutts> Igloo, in that case you use --auto-ghci-libs
06:05:26 <Igloo> dcoutts: I don't  :-)
06:05:38 * Igloo doesn't know if anyone else does
06:05:45 <marcot> dcoutts: I'm using c2hs 0.13.6
06:05:46 <dcoutts> Igloo, you don't use the register script that cabal produces?
06:05:58 <Igloo> I haven't packaged anything that's cabalised yet
06:06:18 <dcoutts> marcot, yep there's no longer any package for c2hs in 0.14.x
06:06:43 <marcot> dcoutts: but it requires a cabal version that is not in debian yet.
06:07:10 <dcoutts> Igloo, oh ok. Well Cabal-1.0 uses --auto-ghci-libs and I sent in a patch thats included in Cabal-1.1.3 that makes it build the GHCi .o files without using --auto-ghci-libs
06:07:11 <marcot> what's this --auto-ghci-libs? And option for ./configure?
06:07:16 <marcot> An
06:07:19 <dcoutts> marcot, no for ghc-pkg
06:07:22 <CosmicRay> do the hsql hackers ever hang out here?
06:07:31 * CosmicRay found a fairly serious design flaw
06:07:40 <marcot> dcoutts: What does it changes?
06:08:11 <dcoutts> Igloo, marcot you'll find that the Cabal shipped with ghc is not very helpful for you. In Gentoo we require cabal 1.1.3 for all our cabalised packages.
06:08:13 <Igloo> CosmicRay: What, OOI?
06:08:25 <CosmicRay> Igloo: it uses a single string escaping function for all databases
06:08:47 <marcot> dcoutts: I'm waiting a newer version of cabal in debian for packaging c2hs 0.14
06:08:48 <Igloo> Ah. I decideed against using it for similar reasons (I wanted to be bale to prepare queries with ?s)
06:08:51 <CosmicRay> Igloo: and that escaping function is part of the definition for "instance SqlBind String", which means it pretty much *has* to be generic.
06:08:53 <dcoutts> marcot, ghc-pkg --auto-ghci-libs makes ghc-pkg produce the GHCi .o files from the .a lib.
06:09:08 <CosmicRay> Igloo: yeah, I wish it would support that.
06:09:11 <CosmicRay> Igloo: what did you use instead?
06:09:20 <Igloo> Wrote sqlite3 bindings
06:09:37 <marcot> Igloo: so you think I shouldn't use --auto-ghci-libs?
06:09:40 <CosmicRay> Igloo: ah.  I am using sqlite3 now.  are they up anywhere?
06:10:03 <dcoutts> marcot, in the Gentoo ebuild for gtk2hs you'llnotice that we do not use ghc-pkg --auto-ghci-libs
06:10:22 <marcot> dcoutts: why?
06:10:24 <dcoutts> marcot, we generate the .o files ourselves and then include them in the package.
06:10:24 <Igloo> http://urchin.earth.li/darcs/ian/bts/Database/SQLite3.hsc
06:10:54 <dcoutts> marcot, since otherwise the .o files no not get managed properly. They ought to be part of the package. --auto-ghci-libs is a pain for packaging.
06:10:57 <Igloo> I haven't split them out into a package yet, but they're probably the next target on my list
06:11:09 <marcot> dcoutts: but why don't you to this in the usual compilation?
06:11:37 * Igloo has a vague feeling that --auto-ghci-libs wasn't entirely portable, but I don't remember details
06:11:42 <dcoutts> marcot, I don't think any packages do that (except ghc's libs itself). Up 'til now everyone uses --auto-ghci-libs
06:11:56 <dcoutts> Igloo, that's correct. It doesn't work with solars ld.
06:19:42 * autrijus starts working on "Learning Haskell" slides
06:20:42 <earthy> ah, you're going to do EurOSCon
06:20:46 <earthy> pity it's so expensive
06:21:09 <autrijus> I have some syntax and basic feature demos; for the "killer apps" I list QuickCheck, Parsec, STM, FFI.
06:21:35 <autrijus> I think GADT is way over people's head so I won't demo the Darcs dependent typing trick
06:21:39 <earthy> wxHaskell or gtk2hs?
06:21:43 <autrijus> anything else you folks like me to demo?
06:22:11 <autrijus> well, the XTC (or whatever it's called) on top of wx may be worth demoing
06:22:13 <dcoutts> I've got some nice Gtk2Hs demos
06:22:20 <autrijus> but straight conversion from C bindings is not sexy
06:22:31 <earthy> yeah, XTC is pretty schweet
06:22:32 <autrijus> dcoutts: url?
06:22:38 <autrijus> is the code of XTC available?
06:22:41 <dcoutts> which I showed off at a recent department open day.
06:22:52 <earthy> not sure, I could ask Martijn tomorrow
06:22:57 <Sonderblade> why is print [3] ok but not print [] ?
06:22:57 <autrijus> 'k
06:23:09 <autrijus> @plugs print []
06:23:13 <dcoutts> autrijus, there's xerox's nimphea, or I've got a simpler version which I demoed. I can send you the code if you like.
06:23:14 <lambdabot> No IO allowed
06:23:19 <autrijus> Sonderblade: it worksforme
06:23:19 <autrijus> Prelude> print []
06:23:19 <autrijus> []
06:23:28 <autrijus> dcoutts: please do, autrijus at autrijus dot org
06:23:36 <autrijus> because I just got 45 mins
06:23:43 <autrijus> I can't really teach any haskell beyond the bare basic
06:23:45 <dcoutts> autrijus, oh actually it here: http://haskell.org/~duncan/cairo/lsystem-demo2/
06:23:57 <autrijus> so instead I'll bombard the audience with Sufficiently Advanced Technologies
06:24:00 <dcoutts> autrijus, it needs the latest version of gtk2hs with the cairo bindings
06:24:40 <dcoutts> autrijus, I've got another version of it which doesn't need the latest gtk2hs version (that uses the older less pretty gfx libs)
06:25:03 <dcoutts> @where nimphea
06:25:04 <lambdabot> I know nothing about nimphea.
06:25:11 <dcoutts> hmm who was the spelled
06:25:18 <dcoutts> who/how
06:25:36 <dcoutts> http://haskell.galois.com/~paolo/nymphaea/
06:25:44 <dcoutts> http://haskell.galois.com/~paolo/nymphaea/porn/musk.png
06:26:24 <autrijus> wow.
06:26:56 <dcoutts> here's an early shot of the GUI: http://haskell.org/~duncan/cairo/Screenshot-six.png
06:27:03 <sieni> and the sad fact is that only a geek can see any porn in that picture ;-)
06:27:07 <Sonderblade> autrijus: main = do print [] gives "Ambiguous type variable `a' in the top-level constraint:" main = do print[3] compiles
06:27:43 <earthy> Sonderblade: that's logical
06:27:47 <earthy> as [] is of type [a]
06:27:48 <autrijus> Sonderblade: try
06:27:52 <autrijus> main = print ([] :: [Char])
06:27:53 <autrijus> vs
06:27:55 <autrijus> main = print ([] :: [Int])
06:28:00 <autrijus> and see that they print differently.
06:28:06 * sheriff waves to autrijus 
06:28:16 <earthy> whereas [3] is of type Numeric a => [a] and therefore prone to defaulting
06:28:19 <autrijus> hey sheriff!
06:28:54 <sheriff> autrijus: I've been learning haskell and browsing pugs/src
06:28:55 <sheriff> go me
06:28:55 <sheriff> :)
06:29:01 <autrijus> go sheriff
06:29:05 <autrijus> you should be in #perl6 :)
06:29:16 <Sonderblade> i see
06:29:21 <Sonderblade> types suck
06:29:30 <autrijus> yup.
06:29:45 <dcoutts> Sonderblade, because in a sense there is not a single [] value, there is one per type.
06:30:07 <dcoutts> Sonderblade, that's an advantage sometimes, but this is not one of those times :-)
06:30:19 <autrijus> Sonderblade: you can remedy this though.
06:30:21 <xerox> autrijus!
06:30:24 <xerox> @where nymphaea
06:30:26 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
06:30:42 <autrijus> instance Show a => Show [a] where show [] = "[]"
06:30:49 <autrijus> and turn on -fallow-overlapping-instances
06:31:05 <autrijus> that will "solve" your problem.
06:31:16 * dcoutts disaproves of that "solution"
06:31:19 <autrijus> xerox: merci
06:31:35 * earthy is with dcoutts
06:32:00 <autrijus> ...and it doesn't work anyway. hmm
06:32:03 * autrijus ponders
06:33:22 <autrijus> hm.
06:33:29 <autrijus> it sucks that the defaulting is not user overriable.
06:33:47 <dcoutts> it is overridable
06:33:59 <boegel> Trixsey|Laptop: having problems ?
06:34:21 <dcoutts> autrijus, you can change the default type for the built in classes on a per-module basis
06:34:41 <Trixsey|Laptop> yes
06:34:46 <autrijus> right, but if I'd like to change defaulting for "a"
06:34:55 <autrijus> or add defaulting to userdefined classes
06:35:18 <boegel> Trixsey|Laptop: how come ? what's up ?
06:35:33 <Trixsey|Laptop> boegel: Its fine now, thanks for asking :-)
06:35:39 <boegel> np
06:35:59 <JaffaCake> autrijus: we might be able to use cvs.haskell.org for RT
06:36:10 <JaffaCake> either that or haskell.org itself
06:36:10 <xerox> RT
06:36:16 <xerox> ?
06:36:24 <JaffaCake> request tracker
06:36:24 <autrijus> also, "default" does not work for non-Num builtin classes
06:36:30 <autrijus> so it works not for "Show" here
06:36:33 <autrijus> JaffaCake: yay!
06:36:35 <dcoutts> autrijus, true
06:36:50 <JaffaCake> xerox: autrijus has offered to set it up as a replacement for the crappy sourceforge bug tracker
06:36:54 <autrijus> JaffaCake: bestpractical offers free support for the GHC team.
06:37:01 <xerox> JaffaCake: ah, way cool
06:37:07 <beelsebob_> @google Miserable Failure
06:37:08 <lambdabot> http://www.whitehouse.gov/president/gwbbio.html
06:37:10 <autrijus> (I talked to their head, jesse@bestpractical)
06:37:10 <beelsebob_> :)
06:37:26 <JaffaCake> bestpractical?
06:37:33 <boegel> beelsebob_: heh
06:37:41 <autrijus> JaffaCake: bestpractical : RT :: mysql_ab :: MySQL
06:37:41 <boegel> a political statement from lambdabot
06:37:46 <JaffaCake> ah right
06:38:03 <xerox> Bye!
06:38:12 <dcoutts> JaffaCake, I was wondering... is ghc-6.6 going to use native .so's/.dll's for packages?
06:38:12 <autrijus> JaffaCake: cool. that's a linux or a bsd?
06:38:26 <JaffaCake> autrijus: linux
06:38:59 <autrijus> JaffaCake: okay. if you'd be so kind to mail me and/or jesse@bestpractical.com account info on that box, we can get it set up next week during the conference
06:38:59 <JaffaCake> autrijus: what does the server need? httpd... what else?
06:39:09 <autrijus> JaffaCake: httpd, perl 5.8.3+, that's all
06:39:15 <JaffaCake> right
06:39:24 <autrijus> preferably one of fastcgi or modperl, but that we can install by hand
06:40:14 <JaffaCake> probably haskell.org itself is the easiest, I'll talk to the admins (they give out accounts to pretty much anyone who asks :))
06:40:49 <autrijus> okay :) we'd need cgi privs; sudo access will much simplify things but setting it up on a private account is possible too
06:41:04 <JaffaCake> dcoutts: I'm not sure yet... hopefully .so's
06:41:06 <dcoutts> JaffaCake, if not can I make a small feature request? :-) we have a problem with gtk2hs on win32 because the lib files do not match the .dll files exactly. The native linker handles this fine but ghci/ghc assumes the same name for the .lib files and the .so files. So at the moment we can either make it work with ghc or with ghci. But not both at the same time.
06:41:39 <dcoutts> err .dll I mean (this is only a win32 problem)
06:42:24 <dcoutts> since hIDE needs gtk2hs to work with ghci stlye loading I'd like to make sure it'll work when ghc-6.6 comes out
06:42:47 <JaffaCake> dcoutts: not sure I understand the problem exactly... but perhaps you just need to tell me what to do :)
06:43:41 <autrijus> JaffaCake: I'll need to be offline a bit to get this "Learning Haskell" talk written
06:44:00 <JaffaCake> autrijus: sure, I'll cc you on the email I send
06:44:03 <autrijus> JaffaCake: we'll keep each other posted via email :)
06:44:04 <autrijus> cool!
06:44:22 <dcoutts> if it uses .dlls it should "just work". Otherwise we'd need a "ghci-extra-libraries: " entry in the package file which would list the .dlls to load. And it would be used in preference to the "extra-libraries: " entry.
06:45:06 <JaffaCake> dcoutts: i see, you want to load different libs when running under GHCi
06:45:11 <dcoutts> JaffaCake, so if the "ghci-extra-libraries: " entry were present in the package file then ghci would use that and ghc would use the "extra-libraries: " entry.
06:45:16 <dcoutts> JaffaCake, yes.
06:45:30 <sieni> ARGH, the grep on Debian is STILL broken
06:45:36 <JaffaCake> what are the entries going to look like in your case?
06:46:11 <dcoutts> JaffaCake, usually they'd be the same. But in some cases we want to load fewer libs in ghci (eg because they are gnu ld scripts not proper .sos at all) or because the names are different between the .lib and .dll.
06:46:54 <dcoutts> JaffaCake, they'd look like "extra-libraries: "gtk-x11-2.0","gdk-x11-2.0", ... " but "ghci-extra-libraries: "gtk-x11-2.0-0","gdk-x11-2.0-0", ..."
06:47:14 <dcoutts> JaffaCake, since the gtk dlls have an extra component to their file name (I think they are versioned)
06:47:21 * JaffaCake finally understands
06:47:36 <dcoutts> JaffaCake, and the .lib files point to the right .dll but obviously ghci can't know about that.
06:47:54 <dcoutts> so that's why it works with ghc since it uses the native linker
06:48:11 <dcoutts> the apprpriate .dll names get baked into the exe
06:48:32 <Sonderblade> i have code like this: do number <- getNumber \n print number, is there a way i can get rid of the intermediate step "number <- getNumber"?
06:48:42 <dcoutts> JaffaCake, sorry, that was a rather roundabout explanation :-)
06:49:29 <JaffaCake> no that's fine... I'm just thinking about whether ghci-extra-libraries is the right solution
06:52:43 <JaffaCake> dcoutts: I guess it's the simplest thing
06:53:42 <dcoutts> JaffaCake, well whichever solution you think is best.
06:56:13 <davve> hi
06:56:23 <kolmodin> hi davve
07:26:57 <Igloo> CosmicRay: Do those sqlite3 bindings look useful to you, BTW?
07:33:37 <autrijus> Haskell: "Hard things / made easy"  "Infinite loops / made fast"
07:36:40 <Philippa> heh
07:37:56 <davve> can I paste three lines of code that I have some questions about?
07:38:20 <dcoutts> go ahead
07:38:25 <davve> data Wrap a = S | C a
07:38:35 <davve> data Ext = forall a. Show a => Mk (Wrap a)
07:38:42 <davve> hej = [Mk (C 3), Mk (C True), Mk (S::Wrap Int)]
07:39:19 <davve> I have to add a signature to S, but I'd like to not have to do that
07:40:05 <davve> is it possible to declare the data structures that fixes that?
07:40:39 <davve> insert "in a way" in the last sentence
07:41:01 <Philippa> GADTs could do it, I guess - otherwise the type system wants an instance of show for the parameter though
07:41:17 <Philippa> it doesn't know statically that it's an S and thus it'll never be used...
07:41:34 <dcoutts> davve, in ghci it works because they tweak the defaulting rules
07:41:42 <davve> dcouts, heh
07:41:49 <davve> Philippa, ah.. right
07:42:20 <Philippa> if the existential stuff's on C rather than a separate Mk constructor then all's cool though
07:42:22 <davve> Philippa, is it Wrap that should be gadt:ized?
07:42:44 <Philippa> (which is easier than fixing the type parm for S)
07:42:48 <dcoutts> davve, no I think you're basically stuck there. Usually there's enought context so that it's not ambiguous. But in this case there is not enough context.
07:43:15 <Philippa> davve: do you have control over Wrap, or is it someone/something else's type?
07:43:26 <Philippa> if it's someone else's, you're stuck
07:43:51 <davve> I have full control of everything :)
07:44:13 <Philippa> will you ever need a Wrap a where a isn't in Show?
07:44:31 <davve> philippa, no
07:44:53 <Philippa> will you ever need to know that two Wraps have a common type parameter?
07:44:59 <davve> yep!
07:45:04 <davve> that's the thing.
07:45:45 * Philippa nods
07:45:58 <davve> (I should have stated a different Ext to illustrate that)
07:46:49 <Philippa> does Wrap actually have that structure (a Maybe clone), or is it complicated enough that it very definitely has to stay as-is rather than Maybe ExistentialThingy sometimes and Maybe ConcreteThingy other times?
07:47:13 <Philippa> what's wrong with Wrap ExistentialThingy as the thing you shove in lists?
07:47:19 <autrijus> what is a better way to express the fact that a variable is never destructively updated?
07:47:25 <autrijus> "Variables never change"?
07:47:52 <Philippa> mk wrap = case wrap of {S -> S; C a -> C (Mk a)}
07:48:01 <autrijus> "= means ="?
07:48:06 <Philippa> both are good
07:48:12 <Philippa> "immutable" works for some people
07:48:19 * earthy is reminded of 'Constants aren't and variables don't'
07:48:27 <Philippa> but it's too much like jargon for some people
07:48:28 <Philippa> heh
07:48:28 <autrijus> "Variables don't"
07:48:32 <autrijus> I like that
07:48:45 <kolmodin> autrijus: they are not variables but definitions?
07:48:55 <autrijus> kolmodin: well they _are_ variables
07:49:01 <autrijus> it's just they can only be rebound, not reassigned
07:49:09 <earthy> 'Variables don't' vary within one call to a function
07:50:28 <davve> Philippa, Wrap has that structure. Hmm.. I'll try to rewrite it as you propose and see if it works (The code is a little bit more complicated)
07:52:07 <davve> Philippa, wait.. no.. I can't just use wrap directly
07:53:13 <davve> so.. you said this could be solved with gadts perhaps?
07:55:46 <Philippa> how come you can't just use wrap directly?
07:56:07 <Philippa> and yeah, you'd use GADTs to fix the type parm for S
07:56:28 <davve> well.. Wrap a = Operand a, Ext = Instruction
07:58:08 <davve> eg. data Instruction = forall a. Show a => Add (Operand a) (Operand b)
07:58:18 <davve> oops.. a=b there
07:59:33 <davve> Operand a = R Reg | Const a
08:00:10 <davve> I'd like to just store Instructions in lists
08:02:38 <davve> Ok, I solved it with gadts.
08:04:34 <davve> Or, hmm.. don't know if it counts as a gadt
08:06:17 <CosmicRay> Igloo: They look good, but it would take awhile to adapt my code to use them.  I wrote a custom escaping function for my own use for now.
08:06:40 <Igloo> OK
08:07:14 <CosmicRay> I like the idea of a generalized layer
08:07:25 <CosmicRay> but there are a number of things about hsql I dislike.
08:07:35 <CosmicRay> perhaps I ought to prepare some patches.
08:07:46 <CosmicRay> one other thing is the inability to refer to columns in the result set by number.
08:10:32 <shapr> I sure like HaskellDB.
08:11:08 <shapr> HSQL does get on my nerves sometimes though.
08:11:33 <shapr> CosmicRay: What are you doing with HSQL? Nifty stuff?
08:11:58 <CosmicRay> shapr: A worldwide gopher spidering/caching bot.
08:12:06 <CosmicRay> shapr: I'm using a sqlite3 db to store state information.
08:12:13 <CosmicRay> so, nifty to some. ;-)
08:12:27 <CosmicRay> the basic problem is that nobody such as archive.org is storing the information on gopher
08:12:45 <CosmicRay> there's a lot of information out there from the earlier days of the 'net, and it just disappears when machines get turned off and stuff.
08:12:58 <CosmicRay> so I'm doing something about it.
08:13:54 <shapr> That is cool.
08:14:17 <CosmicRay> the basic spider is here and working already.
08:14:25 <CosmicRay> so my next task is to make this multithreaded.
08:15:04 <CosmicRay> gopher stuff really shows off parsec, too ;-)
09:04:58 <CosmicRay> ok.  I have a ghc program that's using forkIO and at several times it calls putStrLn.
09:05:05 <CosmicRay> the call to putStrLn does not appear to be atomic
09:05:08 <CosmicRay> (I am using stdout here)
09:07:21 <basti_> CosmicRay: did anyone say it should be? ;)
09:07:38 <araujo> Hello.
09:07:41 <CosmicRay> basti_: no ;-)
09:07:51 <CosmicRay> basti_: is there a way I can make it be?  something with hSetBuffering perhaps?
09:08:16 <basti_> explicitely, maybe
09:08:17 <CosmicRay> I don't want to have to mess with acquring a lock every time I write to stdout ;-)
09:08:34 <dcoutts> CosmicRay, oh, that's exaclty what I was about to suggest :-)
09:08:34 <CosmicRay> basti_: well, it appears that stdout defaults to NoBuffering in GHC
09:08:40 * beelsebob_ wonders why haskell.org doesn't use darcs
09:08:43 <CosmicRay> so I would have thought it would flush immediately
09:08:56 <CosmicRay> beelsebob_: discussions for converting over are in the works right now
09:09:03 <beelsebob_> ahhhh... cool fun beans :)
09:09:12 <Igloo> It's probably sending multiple write syscalls, don't forget
09:09:15 <dcoutts> CosmicRay, it's not the fluching that's the problem, it's the writing into the Handle buffer
09:09:19 <basti_> maybe you just use a function that does the locking and printing for you?
09:09:41 <basti_> you could even hide putStrLn
09:09:46 <CosmicRay> dcoutts: but why would there be a buffer (or multiple syscalls) when I'm using NoBuffering?
09:09:53 <dcoutts> CosmicRay, afterall all of those putStrLn calls are sharing the same stdout Handle
09:10:34 <dcoutts> CosmicRay, the buffer doesn't matter. The reason you get interleaving when using multiple threads is that you don't lock the handle when doing a putStrLn
09:10:36 <CosmicRay> basti_: it would be rather ugly to pass a lock to every place I do that
09:11:07 <basti_> it could be global? or am I missing something?
09:11:13 <CosmicRay> dcoutts: well, what I'm saying is that in C, I don't have this problem with write(), and with NoBuffering in Haskell, I would expect putStrLn to be a very thin wrapper over write()
09:11:18 <basti_> lock = IOVar Bool (or something along that line)
09:11:23 <CosmicRay> basti_: well you have to initialize an MVar to have a lock
09:11:36 <CosmicRay> oh, what's this IOVar thing? ;-)
09:11:44 <basti_> MVar then
09:11:46 <rep> two parrots are sitting on a perch. one asks the other "do you smell fish?".
09:11:55 <Igloo> CosmicRay: To see why there may be multiple syscalls, consider what happens with putStrLn ('x':if long_running_computation then "y" else "z")
09:11:58 <dcoutts> CosmicRay, the difference with C is that their PutStrLn is not for lazy lists so it can lock the FILE for the course of the write
09:11:58 <basti_> hmm right you'd have to pass it :/
09:12:01 <basti_> now that you're saying it
09:12:05 <CosmicRay> I could do the ugly unsafePerformIO thing for setting a global
09:12:19 <dcoutts> CosmicRay, you could use a different primitive to putStrLn, one that does the write all in one go rather than writing lazily
09:12:23 <CosmicRay> Igloo: oh, so we are back to the lazy discussion about putStrLn eh?
09:12:26 <basti_> or do you? -ponder-
09:12:56 <CosmicRay> Igloo: so if I did something like: log m = seq m (putStrLn m), that may solve it?
09:13:10 <Igloo> That certainly wouldn't solve it
09:13:32 <dcoutts> CosmicRay, eg write out an array of chars. I bet that holds the Handle lock for the duration. In that case you'd not get any interleaving within chunks.
09:14:35 <CosmicRay> dcoutts: I guess I'd have to use something from System.Posix then?
09:14:40 <CosmicRay> dcoutts: that's a good suggestion.
09:14:44 <dcoutts> CosmicRay, Handles do have a lock to prevent concurrent writers. However putStrLn does not hold that lock for the whole time, it just locks on a per-char basis since putStrLn has to work with lazy lists.
09:14:51 <Igloo> The surest way would probably be to put itin a Ptr CChar and use hPutBuf
09:15:05 <CosmicRay> Igloo: ah, that makes sense too.
09:15:27 <Igloo> Is write itself guaranteed to not interleave with other calls?
09:15:45 <dcoutts> CosmicRay, or hPutArray
09:16:22 <CosmicRay> Igloo: it is guaranteed that whatever portion of the output was sent, was not interleaved.  write() is not guaranteed to always send all of the output.  however, with terminals, in practice, it does.
09:16:49 <Igloo> OK
09:17:07 <dcoutts> CosmicRay, or just wrap the Handle in another MVar.
09:48:06 <marcot> Hello, I've done a package in which the prerm and the postinst scripts are always exiting with an error.
09:48:14 <marcot> How can i force my system to remove it?
09:48:50 <Igloo> One way is to put "exit 0" at the top of /var/lib/dpkg/info/foo.prerm/postinst
09:49:23 <marcot> Igloo: thanks.
10:20:29 <goron> shapr: ping
10:20:51 <xerox> Happy happy, joy joy.
10:20:58 <marcot> I'm getting an strange error message:
10:21:07 <shapr> goron: pong
10:21:07 <marcot> GpcHs.chs:103:8: parse error on input `import'
10:21:14 <marcot> My imports seem to be right:
10:21:20 <marcot> module GpcHs(Verto, VertaListo, Plurangulo, kunigo, komunigo, diferenco,
10:21:23 <marcot>              ekskluzivaAux) where
10:21:23 <marcot> import C2HS(cIntConv, cFloatConv)
10:21:23 <marcot> import Foreign.Marshal.Array(peekArray, newArray)
10:21:38 <marcot> What's the problem here?
10:21:43 <goron> shapr: What language do you want to support in hIDE? Elisp or "just like Elisp" (i.e. somewhat Haskell like)?
10:21:47 <malcolm> line 103 looks a long way from the top of the file
10:21:50 <xerox> JaffaCake: is the :set +s code in GHCi complex?  Could you point me to its source file, if it's doable?
10:22:29 <shapr> goron: neither, I think hIDE should be scripted with Haskell. hs-plugins gives Haskell all the advantages of elisp.
10:22:53 <malcolm> marcot: maybe you used 'import' as a parameter name to a function?
10:23:01 <autrijus> xerox: ghc/ghc/compiler/ghci/InteractiveUI.hs
10:23:17 <marcot> malcolm: these are the only two imports in the whole code.
10:23:23 <shapr> goron: Before hs-plugins, I was thinking of a concurrent Joy with syntactic sugar on top, now I don't have to worry about it.
10:23:37 <autrijus> xerox: in the same file, timeIt etc
10:23:55 <shapr> goron: Anyway, dons, dcoutts, and Lemmih have done all the code for hIDE so far. They're the people to talk to.
10:24:23 <goron> shapr: Ok, since I thought you wanted ELisp support since there is a lot elisp floating around. But in my experience all the emacs modes are hacked up/buggy and do not raise usability.
10:24:27 <malcolm> marcot: so what is on line 103 at char position 8 (which the error message referred to)
10:24:30 <xerox> autrijus: noo, you shouldn't knew that I was searching that code ;-)
10:24:33 <shapr> goron: I agree.
10:24:42 <goron> shapr: :)
10:24:50 <marcot> malcolm: eof
10:25:24 <xerox> autrijus: j/k, heh. thanks.
10:26:42 <malcolm> marcot: are you sure you are looking at the right file?  It often fools me, when I don't read the error message carefully enough.
10:27:03 <autrijus> :)
10:27:09 <marcot> malcolm: I'm sure, but as you see, this is a c2hs file.
10:27:14 <marcot> ( .chs)
10:27:27 <marcot> and sometimes c2hs messes up the line numbers.
10:27:36 <malcolm> marcot: and has c2hs already pre-processed it before the haskell compiler sees it?
10:28:28 <marcot> malcolm: yes.
10:28:40 <marcot> But anyway, this is the only import in the whole code.
10:28:49 <marcot> I mean, those two.
10:29:11 <malcolm> marcot: so are you looking at the pre-processed output of c2hs, or just the original .chs source?
10:29:15 <dcoutts> goron, the point with hIDE is that it can be extended in Haskell. We want to avoid people having to write elisp.
10:29:23 <marcot> malcolm: I'm looking at both.
10:29:30 <marcot> huh.
10:29:40 <marcot> there're more imports in the preprocessed file.
10:30:54 <goron> dcoutts: I think another thing you would want as a side-effect of Haskell is plugins that actually are not somewhat correct, but really work (unlike e.g. the multimode crap with HTML/PHP/CSS in emacs).
10:31:42 <marcot> malcolm: =D There's the problem. The point is that it seems to be in c2hs generated code.
10:32:18 <malcolm> marcot: now you just need to work out how to fix either your input, or c2hs...
10:32:31 <goron> I am sure there are elisp scripts which do function 100%. I only never saw a non-trivial one.
10:32:58 <dcoutts> goron, well I'm sure you'll help out when we get up to that stage :-)
10:34:04 <goron> dcoutts: Quite possible.
10:34:54 <dcoutts> goron, oh good
10:36:13 <autrijus> is there are way to say, very concisely:
10:36:22 <autrijus> "functions always return the same thing, given the same input"?
10:36:28 <autrijus> (in a way that is accessible to novices)
10:36:33 <Maddas> predictable? ;-)
10:37:24 <Oejet> Stateless, referential transparent.
10:37:35 <arjanb> isn't that just the mathematical definition of function?
10:37:59 <autrijus> I wonder if "repeatable" works
10:40:16 <malcolm> "principle of least surprise"
10:41:03 <sethk> arjanb, there are several competing definitions of function in various branches of math
10:41:37 <Oejet> A black box where you get the same out if you put the same in?
10:41:46 <autrijus> fyi: http://perlcabal.org/~autrijus/tmp/haskell.xul
10:41:50 <goron> Any two programs given the same input will return the same. It just depends on whether you label something as being "input" or not.
10:41:55 <goron> er give
10:42:04 <goron> er given
10:42:22 <autrijus> just starting, but that's the context for "concise" :)
10:42:55 <goron> A global variable is just input to every function (the same holds for other stuff).
10:42:57 <autrijus> ("view source" is fun, too)
10:43:49 <sethk> autrijus, a key concept of functional programming is that we don't use the map definition of function, primarily.  Intrinsic equality is important, not just extrinsic.  (Map is the extrinsic definition of function)
10:44:49 <autrijus> sethk: I understand that concept. what I'm banging my head on is to express it in ten words or less.
10:45:52 <Philippa> "functions don't change their minds about inputs"
10:45:58 <goron> autrijus: How about saying that it works like Excel?
10:46:52 <autrijus> *nod*
10:47:23 <Philippa> (coupled with an example of a piece of highly indecisive C code - example call run first, /then/ what's going on inside)
10:47:49 <sethk> I agree with Philippa about an example, it helps a lot
10:48:10 <shapr> autrijus: You could look over FpVsOO and NotesOnLearningHaskell in http://www.haskell.org/tmrwiki/IssueThree
10:48:21 <autrijus> shapr: yeah, have them in the tabs
10:48:22 <shapr> ok
10:49:06 <autrijus> it's the takahashification process that's hard... it's just 45min, can't go into anything detail
10:51:50 <goron> Opened: 2005-08-03 12:07 PDT Closed: 2005-10-12 06:03 PDT and I INCLUDED THE FIX. (this is Mozilla). How can they be this unbelievably slow?
10:52:24 <Philippa> autrijus: you can go from there to "how IO might work" pretty quickly?
10:52:46 <Philippa> (if you intend to do that, the "win the lottery" function is always useful)
10:52:53 <autrijus> Philippa: I'm thinking about showing lists before IO
10:53:07 <autrijus> what win the lottery function?
10:54:22 <Philippa> \world -> let future1 = waitAWeek world; numbers = watchTVForLotteryNumbers future1; future2 = buyLotteryTicketsAndClaimPrizes numbers world; in future2
10:54:37 <Philippa> (formatted better, of course)
10:54:43 <Oejet> autrijus: I don't think "Functions are repeatable" gives the right meaning at that place.
10:54:51 <Oejet> autrijus: How did you make those presentations?
10:54:57 <autrijus> Oejet: view source
10:55:02 <autrijus> it's just that one page, plus a css.
10:55:11 <autrijus> you are looking at the source code :)
10:56:02 <Philippa> autrijus: it's a neat example of why monadic IO, essentially
10:56:09 <Oejet> autrijus: Nice.
10:56:17 <Philippa> ("so we stick the world in another black box that stops us doing that")
10:56:37 <autrijus> Philippa: nod
10:57:00 <Philippa> then you just hit 'em with a bunch of code using do notation and you're sorted - no more people shitting themselves about IO
10:57:34 <autrijus> Oejet: I changed it to
10:57:40 <autrijus> Functions
10:57:40 <autrijus> given the same
10:57:40 <autrijus> return the same
10:57:40 <autrijus> (think Math)
10:57:45 <autrijus> and then, nex slide:
10:57:45 <autrijus> let a = f x
10:57:45 <autrijus>     a' = f x
10:58:01 <sheriff> What does the trailing apostrophe mean?
10:58:08 <autrijus> sheriff: what it means in math
10:58:13 <sheriff> What does the trailing apostrophe mean?
10:58:14 <sheriff> :)
10:58:17 <xerox> Derivative ;)
10:58:24 <sheriff> I'm only two weeks into my correspondence Maths course
10:58:33 <sheriff> Thankee :)
10:58:40 <autrijus> ah. it is what other people would use "a2" for
10:58:52 <autrijus> "somewhat related to a"
10:59:47 <Sonderblade> i have an action that returns an int-list, how do i output the result of that action?
11:00:08 <dcoutts> foo >>= print
11:00:10 <xerox> print it
11:00:28 <xerox> do it <- action
11:00:28 <xerox>    print it
11:01:25 <Sonderblade> ghc says it couldn't match [] against IO
11:04:53 <dcoutts> what is the type of your action?
11:05:14 <Sonderblade> :: [Int]
11:05:23 <Philippa> that's not an "action"
11:05:25 <Philippa> that's just a list
11:05:36 <Philippa> so you can just do print foo
11:05:53 <Philippa> (lists are also a monad, which is a great way to shoot yourself in the foot - return is your friend)
11:06:38 <dcoutts> Sonderblade, when you said "i have an action that returns an int-list" we assumed that meant you had something with type IO [Int]
11:07:03 <dcoutts> we'd say "a value with type int-list" to mean just [Int]
11:07:09 <Sonderblade> how should i know :)
11:07:20 <dcoutts> we often take "action" to mean something in the IO monad
11:07:40 <dcoutts> everything else is just a value rather than an action
11:07:42 <Philippa> more generally, an action is "doing something" - functions don't
11:08:17 <dcoutts> it comes from the notion that one doesn't "run" functions, one evaluates them.
11:08:24 <Sonderblade> changing the type from [Int] to IO [Int] made it work
11:08:46 <dcoutts> Sonderblade, you can leave it as [Int] and say:
11:08:55 <dcoutts> do let it = action
11:08:59 <dcoutts>    print it
11:09:58 <dcoutts> it's best to avoid IO if it's not really necessary
11:10:09 <Sonderblade> i think it is an action because it reads from the keyboard
11:10:16 <xerox> Good thought.
11:11:42 <dcoutts> with IO in Haskell it's best to try to seperate the IO layer of your program from the 'calculation' layer
11:11:44 <pnou> are there usefull examples of functions that would not type without the Mycroft rule?
11:12:02 * dcoutts wonders what the Mycroft rule is
11:13:44 <pnou> the fact that the let rec are polymorphic
11:14:35 <pnou> which is not the case in ML
11:14:57 <pnou> because typing with this rule is undecidable
11:17:02 <dcoutts> pnou, are you talking about polymorphic recursion?
11:17:22 <dcoutts> pnou, ie using a function at different types within it's own definition?
11:17:30 <dcoutts> definition/body
11:17:53 <supermule> Hi. Anybody know if it is possible to compile multiple executables with a single invocation of GHC? I want to speed up compilation by not invoking GHC multiple times.
11:17:55 <pnou> yep
11:18:17 <SyntaxNinja> good morning
11:18:22 <dcoutts> pnou, infering with that rule is undecidable, which is why Haskell requires you to specify a type signature if you're using polymorphic recursion.
11:19:06 <dcoutts> pnou, but it doesn't come up very often since people don't tend to write functions which need it. I can't think of any off hand.
11:19:54 <dcoutts> pnou, I'd guess that the HList stuff needs it. But it's only a guess.
11:21:54 <pnou> is this rule the only rule which makes haskell typing undecidable?
11:22:13 <CosmicRay> shapr: gopherbot is now successfully running multithreaded.
11:22:17 <CosmicRay> :-)
11:22:36 <CosmicRay> and I've assembled 43383 selectors to visit so far.
11:22:59 <dcoutts> pnou, it doesn't make haskell typing undecidable.
11:24:03 <pnou> dcoutts: what i call typing is inference, not type checking
11:24:14 <dcoutts> pnou, because the Haskell report specifes that polymorphic types are not infered. However they can be explicitly suppled and in that case they can be checked ok.
11:24:18 <autrijus> what was said as a better word for monad that is neither "action" nor "container"?
11:24:21 <autrijus> "computation"?
11:24:30 <Oejet> Argh, referential transparency has a great potential for optimization, but functional programmers throw that away by using the hammer called lists. :-(
11:25:30 <Oejet> autrijus: Computation could be taken to mean what goes on in the body of a C-procedure.
11:25:53 <autrijus> "sequence"?
11:26:02 <dcoutts> pnou, so if an ordinary type cannot be infered then it's a type error. No attempt is made it infer a type that uses polymorphic recursion.
11:26:35 <Oejet> "sequence of computations"?
11:26:36 <dcoutts> pnou, so Haskell98 type inference is decidable.
11:26:38 <autrijus> "effect"?
11:26:54 <autrijus> Oejet: my slide is:
11:27:02 <autrijus> "Effect =/= Value"
11:27:19 <SyntaxNinja> hi autrijus!
11:27:22 <autrijus> hi SyntaxNinja
11:27:34 <autrijus> Oejet: so I'm looking for a better word than "effect" there
11:27:54 <autrijus> (the next two slides demos the "IO effects" and "Parser effects")
11:29:11 <Oejet> Your slide is "Action /= value".  That might work as is.
11:29:20 <autrijus> okay.
11:29:32 <autrijus> (yeah, hadn't uploaded the current version)
11:29:55 <autrijus> monad-as-container is probably something I can't cover in depth anyway.
11:30:35 <syntaxfree> I need the simplest I/O code snippet.
11:30:41 <syntaxfree> I want to print the result of a computation.
11:31:01 <syntaxfree> "main = do putStr 2+2 " is no good.
11:31:09 <syntaxfree> @eval do putStr "Haha\n"
11:31:14 <lambdabot> No IO allowed
11:31:20 <autrijus> syntaxfree: print (2+2)
11:31:27 <SyntaxNinja> main = putStrLn (show (2+2))
11:31:35 <SyntaxNinja> @type show
11:31:35 <syntaxfree> oh, "show". Sure.
11:31:37 <syntaxfree> thanks.
11:31:37 <lambdabot> forall a. (Show a) => a -> String
11:31:41 <autrijus> @type print
11:31:42 <lambdabot> forall a. (Show a) => a -> IO ()
11:32:19 <syntaxfree> thanks.
11:32:21 <syntaxfree> gotta run.
11:32:32 * SyntaxNinja ninjas his "free" ass
11:32:41 <autrijus> heh
11:32:57 * autrijus decides type coercion still has merits
11:33:18 <Sonderblade> how do you do to print all items in a list?
11:33:26 <pnou> mmm connection problem
11:33:35 <autrijus> Sonderblade: just print that list
11:33:59 <{Arias}> print list :S
11:34:09 <autrijus> ...exactly
11:34:30 <Sonderblade> autrijus: i want to print each item of the list on its own line
11:34:44 <SyntaxNinja> mapM putStrLn l
11:34:47 <SyntaxNinja> @type mapM
11:34:49 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
11:35:02 <SyntaxNinja> @type mapM . putStrLn
11:35:04 <lambdabot> bzzt
11:35:10 <SyntaxNinja> @type (mapM . putStrLn)
11:35:12 <lambdabot> bzzt
11:35:31 <autrijus> Sonderblade: on. in that case
11:35:38 <autrijus> @pl mapM print [1,2,3,4]
11:35:39 <lambdabot> mapM print [1, 2, 3, 4]
11:35:42 <autrijus> heh
11:35:53 <{Arias}> error
11:35:53 <pnou> so, if i remove recursive polymorphism, does the haskell type system become decidable (i.e. inference is decidable)?
11:36:13 <{Arias}> mapM print list is ok
11:36:22 <paolino> is print a strict operation ?
11:36:34 <autrijus> I sure hope so.
11:36:50 <basti_> paolino: it forces it's result when the print happens.
11:36:55 <basti_> err parameter
11:37:11 <basti_> *its
11:37:18 <Igloo> It's not strict in it's argument, only in the result of show applied to its argument
11:37:46 <basti_> ahh
11:38:26 <SyntaxNinja> bubblesort: you are kinda inefficient.
11:38:47 <paolino> igloo but IO happens right now or I'm wrong ?
11:39:05 <Sonderblade> thanks, mapM worked
11:39:05 <Igloo> IO happens immediately, yes
11:39:41 <SyntaxNinja> mapM rulz.
11:39:44 <autrijus> ...at least in this real world
11:40:05 <SyntaxNinja> autrijus: how'd cabal hacking go?
11:40:11 <SyntaxNinja> autrijus: haven't gotten any patches from you :)
11:40:19 <autrijus> SyntaxNinja: right because we kept working around bugs.
11:40:21 <autrijus> ;)
11:40:47 <autrijus> SyntaxNinja: I'm doing slide hacking right now...
11:40:56 <autrijus> won't have free time till until next week
11:41:28 <paolino> is "p q n m a" a valid type ?
11:41:44 <Igloo> SyntaxNinja: cabal isn't urgent for Debian transition reasons, BTW
11:41:50 <autrijus> @type undefined :: (p q n m a)
11:41:52 <lambdabot> (p q n m a) :: forall (p :: * -> * -> * -> * -> *) q n m a. p q n m
11:41:52 <lambdabot> a
11:41:57 <autrijus> paolino: it is.
11:42:23 <SyntaxNinja> autrijus: ok
11:42:30 <SyntaxNinja> Igloo: ok
11:42:56 <Igloo> What does @type do exactly?
11:43:15 <Igloo> Ah, -fglasgow-exts is what I was missing
11:43:22 <Igloo> @type 5
11:43:24 <lambdabot> forall t. (Num t) => t
11:43:35 <Igloo> Aha, and it's chopping at the wrong ::
11:45:06 <paolino> without entering Monads concept, what are parametrized types ?
11:46:35 <paolino> are Monad instances  parametrized types right ?
11:49:58 <xerox> Sonderblade: you probably want mapM (print) list
11:50:05 <xerox> err, mapM_ (print) list
11:50:42 <xerox> paolino: 'Maybe a' is a parametrized type
11:50:45 <Speck> 'lo channel
11:52:11 <paolino> sera xerox,what they represent, generally ?
11:52:13 <xerox> @type Control.Monad.mapM
11:52:15 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
11:52:16 <xerox> @type Control.Monad.mapM_
11:52:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
11:53:37 <Sonderblade> xerox: mapM worked, why would i want mapM_?
11:53:49 <xerox> paolino: you use parametrized type to type-name things, for example - or to implement some semantics: for example, 'Maybe a' models a computation which either gives a result 'Just a' or fails with 'Nothing'.
11:54:15 <xerox> Sonderblade: because mapM does collect a list of the results of the actions.
11:54:45 <xerox> Sonderblade: note the ending  mapM :: .. -> m [b]  versus  mapM_ :: .. -> m ()
11:55:19 <SyntaxNinja> Sonderblade: if you're ging to ignore the return value, like for putStrLn, then use mapM_
11:56:07 <Sonderblade> but mapM is one character shorter :)
11:56:21 <Speck> but mapM is more efficient if you don't want the return value(s)
11:56:25 <Speck> err, mapM_
11:58:31 <marcot> Igloo: ping
11:58:43 <xerox> paolino_: connection problems?
11:58:53 <paolino_> sorry,GPRS
11:59:25 <paolino_> did I get answers ?
11:59:33 <xerox> paolino: you use parametrized type to type-name things, for example - or to implement some semantics: for example, 'Maybe a' models a computation which either gives a result 'Just a' or fails with 'Nothing'.
11:59:34 <marcot> dcoutts: I'm trying to install it on /usr/lib/lighc6-gtk-dev instead of /usr/lib/gtk2hs.
12:00:17 <marcot> dcoutts: but the gconf dirs are not being atualized.
12:00:26 <paolino_> Monads are implementing a semantics as well ?
12:00:58 <xerox> paolino, in Haskell Monad is a type class.  It does have a meaning, for sure, that's its point :-)
12:03:04 <Speck> introducing the concept of semantics into any explanation immediately makes it abstracted beyong comprehension
12:03:34 <Speck> don't you see? it's the meaning of... _meaning_
12:03:42 <paolino_> can I see a parametrized type as a shell ?
12:03:55 <paolino_> on the parameter ?
12:03:59 <xerox> paolino_: yep, in the sense of IO it perfectly matches
12:04:17 <paolino_> with Maybe ?
12:04:20 <xerox> You can't extract the pearl anymore, without going into there
12:04:35 <Speck> kind of like a variadic type container
12:04:42 <Speck> or exactly like one
12:04:52 <xerox> Maybe is a shell which can be opened, and could have two shapes.
12:05:11 <dcoutts> marcot, atualized?
12:05:21 <xerox> You could have no fun, and find the Nothing shell, which is a shell of type Maybe.
12:05:24 <Speck> Maybe is like a wish bone
12:05:56 <xerox> Or you can be lucky, and find the Just 'a' shell, which is a shell you could open to grab the 'a' and run away with.
12:06:08 <dcoutts> xerox, http://haskell.org/~duncan/gtk2hs/SOE-cairo.png
12:06:12 <TFK> Guys, what's the latest-and-greatest Haskell repo for Ubuntu?
12:06:28 <TFK> (I reinstalled Ubuntu, and lost the link)
12:06:33 <xerox> TFK: deb http://haskell-unsafe.alioth.debian.org/archive/i386 . unstable testing stable
12:06:43 <TFK> thanks!
12:06:44 * xerox shakes dcoutts
12:06:46 <dcoutts> ibid, here's a pic of my cairo based SOE lib. http://haskell.org/~duncan/gtk2hs/SOE-cairo.png
12:06:47 <xerox> That's cool !!!!
12:07:08 <xerox> That's zoomed, too :-)
12:07:09 <dcoutts> ibid, the left one is the orgianal Graphics.SOE, the right one is my cairo based implementation.
12:07:09 <Speck> ooh, antialiased
12:07:32 <dcoutts> xerox, yep 2x zoom
12:07:41 <xerox> @karma+ dcoutts -- you were pretty fast in implementing it :D
12:07:42 <lambdabot> dcoutts's karma raised to 3.
12:07:56 <marcot> dcoutts: I want it to be configured to run in /usr/lib/libghc6-gtk-dev
12:07:59 <dcoutts> xerox, I've not implemented regions yet, or timers
12:08:11 <syntaxfree> Is there a standard prelude function that will count the occurences of a given element in a list?
12:08:30 <syntaxfree> Writing one is trivial, but it's bound to be slower than a built-in word.
12:08:35 <xerox> dcoutts, is it still in doubt how to model regions operations?
12:08:46 <dcoutts> xerox, yeah
12:08:56 <dcoutts> marcot, I've got to buzz off right now. If you're around later we can look into it.
12:09:12 <xerox> syntaxfree: I think you could safely go with find x = length . filter (==x)
12:09:19 <syntaxfree> oh. true.
12:09:29 <marcot> dcoutts: ok..
12:09:38 * dcoutts buzzes off
12:09:50 * xerox waves back
12:10:39 <syntaxfree> oh.
12:10:43 <syntaxfree> is this valid?
12:10:44 <syntaxfree> showList lm 	= map (\x->do putStrLn (show x)) lm
12:10:52 <syntaxfree> I want to print the elements of a list, one per line.
12:11:03 <xerox> nope
12:11:28 <syntaxfree> hmm.
12:11:39 <xerox> @hoogle (a -> IO ()) -> [a] -> ()
12:11:40 <lambdabot> No matches, try a more general search
12:11:47 <xerox> @hoogle (a -> IO ()) -> m a -> ()
12:11:48 <lambdabot> No matches, try a more general search
12:11:50 <xerox> ops
12:11:52 <xerox> @hoogle (a -> IO ()) -> m a -> m ()
12:11:53 <lambdabot> Prelude.(=<<) :: Monad a => (b -> a c) -> a b -> a c
12:11:53 <lambdabot> Prelude.(>>=) :: Monad a => a b -> (b -> a c) -> a c
12:11:53 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:11:54 <Speck> sequence_?
12:12:13 <xerox> syntaxfree: anyway, print = putStrLn . show
12:12:36 <xerox> syntaxfree: and you need to use mapM_ to map an action
12:12:38 <syntaxfree> I see.
12:12:45 <syntaxfree> mapM_ ?
12:12:46 <paolino_> anyway just to state IO () is not a fuction call . right ?
12:12:59 <xerox> syntaxfree: more specifically, mapM does map an action and collect the results, mapM_ does discard them
12:13:17 <xerox> paolino_: IO () is a value
12:13:21 <syntaxfree> hmm. Thanks.
12:13:31 <xerox> syntaxfree: check the types:
12:13:36 <xerox> @type Control.Monad.mapM
12:13:38 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
12:13:39 <xerox> @type Control.Monad.mapM_
12:13:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
12:14:12 <syntaxfree> so,
12:14:17 <xerox> syntaxfree: notice they differ in the last part, .. -> m [b] (collect the results in a list, and .. -> m () (the unit type, no value is kept)
12:14:27 <syntaxfree>  showList lm = mapM_ (\x->do putStrLn (show x)) lm
12:14:32 <syntaxfree> is that valid, then? :~
12:14:48 <xerox> You don't need the do, but it seems so.
12:14:57 <paolino_> xerox how you call "m ()"  ?
12:15:07 <xerox> @pl \lm -> mapM_ (\x -> do putStrLn (show x)) lm
12:15:09 <lambdabot> mapM_ (do putStrLn . show)
12:15:17 <xerox> @pl \lm -> mapM_ (\x -> putStrLn (show x)) lm
12:15:18 <lambdabot> mapM_ (putStrLn . show)
12:15:40 <xerox> paolino_: Monad m => m ()  is a value (the unit) contained in whatever monad.
12:16:01 <syntaxfree> when calling showList  in my "main" function, should I do "main = do shoList yadda yadda", or just "main = showList"?
12:16:15 <paolino_> generic contained value ?
12:16:35 <xerox> syntaxfree: you need the do to sequence actions, if it's the only one, you can skip it.
12:16:49 <syntaxfree> ok. thanks :)
12:17:00 <syntaxfree> I'm producing numerical data, and need to feed them to gnuplot.
12:17:09 <syntaxfree> that's why I need specially formatted lists. Thanks.
12:17:10 <xerox> paolino_: Monad m => .. -> m ()  is an action which doesn't return anything, i.e. it's only useful for its side-effects
12:17:44 <xerox> syntaxfree: as dcoutts stated previously, it's usually a good idea to separate the IO-using level of the app from the purely functional (i.e. calculating) one.
12:18:13 <xerox> syntaxfree: it's just an idea, I don't mean you're doing anything wrongly, just keep it in mind :-)
12:19:12 <syntaxfree> xerox: yes, I'm doing so.
12:19:13 <xerox> paolino_: i.e. print/putStr/putStr/etc are all ... -> IO ().
12:19:43 <syntaxfree> I just needed a thin wrapper that printed the list that results from my purely functional calculations into something gnuplot can read.
12:20:16 <paolino_> @type Maybe
12:20:18 <lambdabot> bzzt
12:20:34 <xerox> paolino_: Maybe is not a type until you fill its parameter
12:20:57 <paolino_> @type Maybe 0
12:20:59 <lambdabot> bzzt
12:21:15 <xerox> The 'a' in 'Maybe a' is a type-variable!
12:21:27 <paolino_> @type Maybe Integer
12:21:28 <lambdabot> bzzt
12:21:37 <xerox> @type Just 2
12:21:39 <lambdabot> forall a. (Num a) => Maybe a
12:21:46 <xerox> @type Just (2 :: Integer)
12:21:47 <lambdabot> Maybe Integer
12:21:56 <xerox> @type Nothing :: Integer
12:21:58 <lambdabot> bzzt
12:22:02 <xerox> Oops.
12:22:04 <xerox> @type Nothing :: Maybe Integer
12:22:06 <lambdabot> Maybe Integer :: Maybe Integer
12:22:20 <xerox> Here are the two possible shape of a Maybe Integer, you get it?
12:22:37 <xerox> It can be either a 'Just value' or a 'Nothing'.
12:23:03 <syntaxfree> in case anyone wonders what the hell I was doing: http://www.rafb.net/paste/results/M4zULB95.html
12:24:16 <syntaxfree> gotta run.
12:25:29 <paolino_> Maybe Integer is a type just like IO () ?
12:25:37 <xerox> Yep.
12:25:54 <paolino_> but you said IO () is a value
12:26:30 <xerox> I did?  Sorry.
12:26:36 <xerox> @eval ()
12:26:38 <lambdabot> ()
12:26:41 <xerox> This is the unit value.
12:27:10 <xerox> @type return () :: IO ()
12:27:12 <lambdabot> IO () :: IO ()
12:27:20 <xerox> This is an action which returns nothing.
12:28:17 <paolino_> and you induced the return of the IO monad ?
12:28:24 <paolino_> :: IO ?
12:29:00 <paolino_> @type (return::IO ) ()
12:29:01 <lambdabot> bzzt
12:29:28 <paolino_> sgrunt
12:31:01 <Igloo> marcot: ?
12:32:40 <marcot> Igloo: I was wondering about how do I change the library dir field in the .conf files of the package?
12:36:15 <Igloo> No idea OTTOMH
12:39:06 <dolmen> @type sequence
12:39:07 <marcot> I'm trying to understand an error here for a time, but I have no idea:
12:39:08 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
12:39:13 <dolmen> @type for
12:39:15 <lambdabot> bzzt
12:39:17 <marcot>    Couldn't match `[]' against `IO'
12:39:18 <marcot>       Expected type: []
12:39:18 <marcot>       Inferred type: IO
12:39:18 <marcot>     In a 'do' expression: cp <- pluranguloAlCPlurangulo p
12:39:42 <dolmen> @type sequence_
12:39:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
12:39:56 <dolmen> hi Lemmih
12:40:04 <Lemmih> Hi.
12:40:14 <marcot> where pluranguloAlCPlurangulo :: Plurangulo -> CPlurangulo
12:40:18 <marcot> p :: Plurangulo
12:40:44 <marcot> type Plurangulo = [(Bool, VertaListo)]
12:41:58 <dolmen> @paste
12:41:59 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:42:07 <dolmen> -> marcot
12:44:58 <marcot> dolmen: ok...
12:49:11 <marcot> I pasted it there.
12:49:27 <marcot> Is a very simple code, with a good error message.
12:49:34 <marcot> But I can't understand why this is happening.
12:53:43 <xerox> @eval let fibs = [ x+y | x <- fibs | y <- tail fibs ] in take 10 fibs
12:53:45 <lambdabot>  Illegal parallel list comprehension: use -fglasgow-exts
12:53:48 <xerox> :-)
12:55:33 <CosmicRay> can anyone tell me how to use setSocketOption in Haskell?  The C SO_RCVTIMEO version wants a struct timeval as the parameter
12:55:40 <CosmicRay> haskell seems only to permit passing an Int
12:55:54 <CosmicRay> and, from reading the source, passes a len that is directly related to that int
12:56:09 <CosmicRay> (that is, a len of the int)
12:56:20 <CosmicRay> so that seems to preclude any way of passing a true struct timeval
13:04:06 <CosmicRay> hmm.  it also appears that there is no way to get a fd from a socket.
13:04:39 <CosmicRay> or, never mind, there is MkSocket.
13:04:48 <frederik> hi everybody!
13:04:51 <Lemmih> @type Network.Socket.fdSocket
13:04:52 <lambdabot> Network.Socket.Socket -> Foreign.C.Types.CInt
13:04:57 <Lemmih> Hi frederik!
13:05:05 <CosmicRay> thanks lemmih.
13:05:09 * CosmicRay codes up a setsockopt call ni C
13:05:17 <xerox> CosmicRay: http://haskell.org/ghc/docs/latest/html/libraries/network/Network.Socket.html#v%3AsocketToHandle
13:05:36 <frederik> i'm in london now, living on the 9th floor of a run-down flat complex, attending UCL's Intelligent Systems master's program
13:05:46 <frederik> we got DSL yesterday
13:05:51 <CosmicRay> xerox: that's not quite what I was after -- I needed the file descriptor of it to pass to a C setsockopt call
13:05:55 <Igloo> Woo, we just got promoted a place in the ICFPC rankings  :-)
13:06:02 <xerox> ah!
13:06:15 <frederik> has that guy from imperial been around?
13:06:16 <CosmicRay> Igloo: at first I read that as ICFP, and thought, "up from first?" ;-)
13:06:22 <CosmicRay> what is ICFPC?
13:06:28 <Igloo> ICFP Contest
13:06:32 <CosmicRay> oh.
13:06:36 <CosmicRay> in that case, "up from first?"
13:06:43 <Igloo> Wolfgang was first
13:06:56 <CosmicRay> ah, you were on the team that came in 3rd?
13:06:57 <Igloo> We wree 7th or 9th, depending on how you count. Now 7th or 8th.
13:07:01 <CosmicRay> ah.
13:07:08 <CosmicRay> nice.  didn't know you participated.
13:07:11 <CosmicRay> congrats ;-)
13:07:29 <Igloo> Thanks  :-)
13:08:21 <SyntaxNinja> Igloo: nice work.
13:10:59 <frederik> does "bayesian" sound like an over-hyped buzzword?
13:11:54 <sethk> frederik, well, the claims for it (w.r.t. spam filtering) are very much exagurated
13:12:58 <frederik> hee
13:13:02 <frederik> what do other people think?
13:14:05 <frederik> i'm trying to imagine the process by which names for interesting things in CS go from exciting research areas to dead buzzwords.
13:14:08 <frederik> AI, OOP, etc.
13:14:12 <Oejet> Well, it made me collect a lot of spam to use as training.  Fortunately the spam rate almost dissapered, so I haven't gotten further. :-)
13:14:40 <sethk> Oejet, If you lack for data, I have thousands of saved up spam messages.  :)
13:14:57 <Oejet> sethk: Hey, we can swap. :-P
13:15:06 <cjb> I think "Bayesian" as a way to do inference can't really go out of fashion, 'cause it's the right way to do inference.  :)
13:15:06 <frederik> "bayesian" refers to a class of methods based on a certain interpretation of probability theory which is much more general than anything which has been put into popular spam filtering software
13:15:42 <frederik> but see how people don't even know what it is
13:15:52 <frederik> no offense!
13:16:09 <cjb> People in not understanding science shocker.
13:16:34 <frederik> there is a lot of interesting OOP research, i believe, which i never thought to look at because i was like "hype"
13:16:48 <frederik> i think
13:18:08 <Cale> http://www.bayesian.org/
13:18:15 <frederik> and like as i understand it, "machine learning" gave itself a new name largely to distance itself from the extravagant hopes of early AI research
13:20:34 <frederik> when will "functional programming" be a lame buzzword?
13:22:08 <marcot> dcoutts: are you there?
13:25:00 <sethk> frederik, I don't think you have to worry about functional programming.  For better or worse it is at the moment not endangered
13:26:42 <Cale> http://nitro.biosci.arizona.edu/courses/EEB596/handouts/Bayesian.pdf looks like a decent intro. The idea is simple enough.
13:26:56 <xerox> Goodnight folks.
13:27:28 <shapr> yow!
13:27:44 <SyntaxNinja> shapr!!
13:28:50 <Cale> 'night xerox
13:29:52 <Cale> I don't understand why there's this big "split" between "classical" and "Bayesian" statistics. afaict, it doesn't even require any additional axioms.
13:30:34 <Cale> frederik: do you happen to know?
13:33:16 <Cale> I suppose it's just a change in mindset that you don't want to throw away information you have about the distribution by taking point estimators.
13:33:51 <shapr> SyntaxNinja!
13:34:13 <Cale> But I don't really see Bayesian statistics dying from overexposure. It's just a bunch of theorems.
13:36:17 * SyntaxNinja hands shapr a cookie
13:37:44 * shapr eats the cookie, mmm.
13:37:54 <kzm_> O the frustration!  O the woe!  Is there enlightenment to be found, as I fumble in the deep darkness of my tormented soul?
13:38:02 <shapr> Maybe, whatcha need?
13:38:15 <sethk> kzm_, no, you are doomed to eternal frustration
13:38:50 <kzm_> If so, I shall sue you all for false advertising - making me drop C++ in favor of Haskell, and all.
13:39:08 <sethk> kzm_, no, we can't have that.  So what is your problem?
13:39:45 <Oejet> kzm_: Hehe, people are so easy to fool.
13:40:01 <kzm_> I posted a question on the ghc-user's list, and, as always, I'm probably wrong.
13:40:01 <frederik> Cale: i think your description is good. mostly it seems to be a change in point of view though. i don't really get the details either.
13:40:15 <kzm_> But I am unable to see why and how.
13:40:33 <sethk> kzm_, I'm sure I'm wrong more often than you are.  :)
13:40:48 <kzm_> If I want to use Data.Set/Map etc, I have to use them all qualified, apparently.
13:41:04 <Cale> kzm: yeah
13:41:10 <kzm_> So what then is the advantage over the Set.map naming instead of mapSet or something like that?
13:41:56 <Cale> Well, it's more structural. Not much really.
13:41:57 <kzm_> I like the short names, but it seems to me there is no real gain if I either have to munge the imports, or always qualify them (they clash with imports from the Prelude)
13:42:35 <kosmikus> what's the problem with hiding names from the prelude?
13:42:41 <kzm_> And sethk, I'm wrong, not only on the mailing list, but at work, and at home, and, and...
13:42:41 <sethk> kzm_, I'm strange; I actually prefer to use qualified names because I don't like implicit choices by the compiler
13:42:57 <sethk> kosmikus, that's a good point also
13:43:14 <kzm_> kosmikus, it's not a problem, except that I have to add an extra import, and take care what to hide from which module.
13:43:29 <Cale> There's not all that much difference between Set.map S.map and mapSet.
13:43:37 <kzm_> IMO it is bad form to reuse Prelude names.  Or it should be.
13:43:54 <kosmikus> I disagree.
13:44:10 <Cale> I think that map in particular shouldn't be a reuse here.
13:44:16 <kzm_> In fact, I think crucifiction is too good for them.
13:44:33 <Cale> Set should be (and is) an instance of Functor
13:44:55 <kzm_> Cale, that would be nice.  (Also a recent discussion of course)
13:45:02 <kosmikus> is?
13:45:10 <Cale> oh
13:45:11 <sethk> kzm_, As I said, by using fully qualified names, any such problem disappears completely.
13:45:12 <kzm_> is not.
13:45:12 <Cale> perhaps not
13:45:16 <sethk> not that I really think it is a problem.
13:45:24 <Cale> It ought to be
13:45:36 <Cale> But yeah, the same problem applies as with Monad
13:45:44 <Cale> Which is upsetting
13:45:48 <ski_> m
13:46:00 <kzm_> Yes, but then there's no point.  You just get the advantage of one more character to type all the time, and confusion with function composition, and what not.
13:46:20 <Cale> one more?
13:46:23 <kzm_> Cale - monad?
13:46:28 <Cale> Set is a monad
13:46:43 <kzm_> The dot.  mapSet (or whatever) as opposed to Set.map
13:46:45 <Cale> just on a subcategory of the category of Haskell types
13:46:58 <Cale> you could use S.map :)
13:47:08 <kzm_> Are you trying to out-category-theorize me, Cale?
13:47:11 <Cale> hehe
13:47:19 <sethk> kzm_, arguments about typing letters don't carry much weight with me.  I would much rather type a few extra characters than invite ambiguity
13:47:23 <Cale> okay, I'll give return and join -- map does the obvious thing
13:47:31 <kzm_> Me just hummel programma, man.  No grok tham thar category thingy.
13:47:32 <Cale> return creates a singleton set
13:47:35 <ski_> return is singleton
13:47:43 <Cale> and join takes the union
13:48:22 <Cale> xs >>= f = join (map f xs)
13:48:47 <Cale> It's the most fundamental example of a monad
13:49:24 <Cale> but it can't be an instance of monad in Haskell, because the implementation requires the type parameter to be in Ord
13:49:30 <ski_> (a -> Set b    is more or less the same as a binary relation between a and b .. so (>>=) more or less gives us composition of such relations)
13:49:31 <kosmikus> I think no one is arguing agains Set being a Monad. There just isn't a way in current Haskell to do it.
13:49:52 <kzm_> I must admit I don't quite get it - join is union, yet you "join (map f xs)" where xs is a (one) set?
13:49:55 <Cale> kosmikus: I know - kzm was confused about how it's a monad
13:50:00 <sethk> Cale, I think it is unfortunate that the monad class and the monad idea use the same word
13:50:11 <Cale> f :: a -> Set b
13:50:29 <ski_> map f xs :: Set (Set b)
13:50:30 <Cale> sethk: the idea is that monads in Haskell should be in that class
13:50:36 <sethk> Cale, I know that
13:50:36 <marcot> @type
13:50:38 <lambdabot> bzzt
13:50:48 <sethk> Cale, but, as you pointed out, in practice it doesn't work out that way
13:50:48 <Cale> The concept is obviously more general
13:50:50 <gzl> is it possible to fork off a process and then switch that process from the foreground to the background (as it might in a shell)?
13:51:03 <Cale> It applies to other categories altogether
13:51:20 <sethk> Cale, I know.  It makes it confusing in a discussion.  Are we talking about the concept of monad, or the specific haskell class monad?
13:51:30 <ski_> both
13:51:39 <sethk> Cale, Of course we can use Control.Monad and avoid the ambiguity
13:51:43 <Cale> But I'd like to see the Monad class extended at least to typeclass restricted subcategories of the category of haskell types.
13:51:48 <sethk> ski_, in this case, yes, both.  But not always
13:52:13 <sethk> Cale, sure, but I don't think you will ever get 100% of monadic types part of Control.Monad
13:52:20 <sethk> Cale, even if you improve it from the current situation
13:52:41 <Oejet> gzl: System.Process.runProcess?  Then forkIO and let one thread go on and the other one handle the process.
13:53:57 <Cale> Well, if you added the additional qualifier to the Set data declaration that says the type parameter has to be in Ord, then the instance declaration for Monad could be suitably restricted as well.
13:53:57 <gzl> Oejet: yeah, I saw that, but I wasn't sure if there was any equivalent to tcsetpgrp() in C where you switch control of stdin from one process to another
13:54:25 <Cale> (as obviously, you're not trying to define it to be a Functor or Monad on objects outside of its domain)
13:54:54 <Oejet> gzl: Process as in Unix process?
13:55:02 <gzl> yes
13:55:28 <Oejet> @type runInteractiveCommand
13:55:30 <lambdabot> bzzt
13:55:40 <Oejet> @type System.Process.runInteractiveCommand
13:55:42 <lambdabot> String
13:55:42 <lambdabot> -> IO (GHC.IOBase.Handle,
13:55:42 <lambdabot> GHC.IOBase.Handle,
13:55:42 <lambdabot> GHC.IOBase.Handle,
13:55:42 <lambdabot> System.Process.Internals.ProcessHandle)
13:55:47 <Cale> That would basically get rid of the problem. There may be extra engineering issues with separate compilation or something, which I don't see.
13:55:48 <ski_> problem is that the monad class head doesn't mention the type argument to the monad
13:55:49 <gzl> say I'm writing a shell and I want to implement running commands as "foo" or "foo &" as well as having bg/fg builtins
13:56:31 <ski_> class Monad (m :: * -> *) where ...
13:56:40 <Cale> ski_: Right, but why can't we have typeclass restricted instances?
13:56:54 <xerox> fundeps?
13:56:57 <Oejet> gzl: System.Process.runInteractiveCommand runs in the background I think.
13:57:04 <ski_> maybe with some kind of constraint polymorphism ?
13:57:18 <gzl> Oejet: I thought the "interactive" part implied foreground
13:57:29 <xerox> @docs System.Process
13:57:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.Process.html
13:57:35 <Cale> well, the usual typeclass polymorphism, as far as I can see...
13:57:47 <ski_> how ?
13:58:05 <Oejet> gzl: I'm using it right now actually, may I pm you?
13:58:18 <ski_> 'class Monad (m :: * -> *) where ...' is enssentially making a promise that m can be applied to any type expression in *
13:58:24 <ski_> s/n//
13:58:48 <Cale> Right, I'd like to have that claim be weaker.
13:58:55 <ski_> indeed
13:59:00 <ski_> but how to express that ?
13:59:09 <gzl> Oejet: sure
13:59:22 <Cale> Well, that's the most general kind that m can have.
13:59:28 <ski_> yes
13:59:47 <ski_> we sure want the possibility of m to have that kind and still be in class Monad
13:59:56 <Cale> yes
14:00:15 <Cale> but I'd like the class Monad to apply to less polymorphic kinds as well
14:00:18 <ski_> so i would think we'd need to change the monad class to be parametric in how general arguments ca be passed to m
14:00:44 <ski_> class Monad k (m :: k -> *)    ?
14:01:11 * malcolm wonders how to get people to read his blog
14:01:26 <Cale> Perhaps typeclass contexts should be allowed as kinds.
14:01:28 <ski_> (malcolm : mention it ? :))
14:01:43 <ski_> as kinds ?
14:01:47 <malcolm> ski_: I was hoping someone would ask...
14:01:48 <ski_> or as having kinds ?
14:02:15 <ski_> (current) Monad :: (* -> *) -> instance   ?
14:02:30 * Igloo reads cvs-nhc98@; that's gotta be a pretty good approximation  :-)
14:02:31 <Cale> Well, in this case, we want to restrict (* -> *) to (Ord -> *)
14:02:39 <malcolm> http://nhc98.blogspot.com/  I'm new to blogging, so only a few posts so far.
14:02:48 <Cale> when making an instance
14:02:59 <Cale> * is more polymorphic than Ord
14:03:01 <ski_> Cale : we'd also want this to play nicely, if possible, with multi-arg typeclasses
14:03:17 <Cale> ah, yeah, that's an issue of course
14:03:55 <Cale> Well, how about, this is a little rough,  (Ord a) => a -> *
14:04:06 <ski_> not quite i think
14:04:08 <ski_> hm
14:04:26 <Cale> It's a bit awkward because the meaning of 'a' there is different than usual
14:04:52 <Cale> well, we really want the entire set of types 'a'
14:05:21 <ski_> (a :: * *> Ord a) -> *  ?
14:05:33 <Cale> *> ?
14:05:52 <ski_> =>  is a bit like  ->   *>  is a bit like (,)
14:06:04 <Cale> {a : Ord a}
14:06:42 <ski_> *> could e.g. be used normally as    Foo -> exists x. x *> Show x
14:07:05 <ski_> basically, it's an "output" constriant, instead of input
14:07:21 <Cale> hmm
14:07:22 <ski_> (Mercury, e.g. has this ..)
14:07:47 <ski_> though, of course, in my case i was trying ot use it in a kind instead of in a type
14:08:01 <ski_> s/ot/to/
14:08:47 <ski_> (though, because it's in the argument it really is input anyway, so it should be the same as    (a :: *) -> Ord a => *)
14:08:50 <Cale> I want to have kind variables, and basically, to be able to restrict a kind by comprehension on typeclass constraints.
14:09:16 <ski_> (the "(a :: *) ->" part is dependent kinds, btw)
14:10:23 <Cale> I want kinds like {a : a in *, Ord a} -> *
14:10:40 <Cale> (not necessarily with that syntax)
14:10:44 <ski_> "a : a in *" ?
14:10:48 <Cale> a such that
14:10:55 <Cale> a is a type
14:10:55 <ski_> ah
14:10:59 <ski_> dependent
14:11:15 <ski_> you know about dependent types ?
14:11:20 <Cale> not deeply
14:11:33 <ski_> should i explain some ?
14:11:36 <Cale> and I've never used a language which had them
14:11:37 <Cale> okay
14:11:59 * ski_ hasn't used them much in a lang, either, but i've got the basic idea
14:12:08 <ski_> ok
14:12:11 <Cale> It looks like we sort of need them to prevent stupid applications of the Set constructor
14:12:19 <ski_> m
14:12:49 <ski_> Set ((Bool -> Integer) -> String)   maybe ..
14:12:51 <ski_> e.g.
14:12:59 <Cale> yeah
14:13:02 <ski_> anyway
14:13:28 <ski_> in dependent types, we "blur" the distinction between types and values, in a way
14:13:38 <Cale> hmm
14:13:43 <ski_> we can have
14:13:45 <Cale> I didn't think I was above :)
14:13:54 <ski_> Vector :: Nat -> * -> *
14:14:04 <ski_> ok ?
14:14:05 <Cale> yeah
14:14:15 <Cale> I'm familiar with that picture of dependent types
14:14:19 <ski_> then to use this, we can have functions like
14:14:50 <ski_> replicateV :: forall n :: Nat. a -> Vector n a
14:14:54 <ski_> ok ?
14:14:57 <Cale> right
14:15:02 <ski_> this is the same as
14:15:11 <ski_> replicateV :: (n :: Nat) -> a -> Vector n a
14:15:13 <Cale> But that's not at all what I'm looking for, I don't think :)
14:15:45 <ski_> forall type and function type are both instance of the more general dependent function type
14:15:50 <ski_> ok ?
14:16:02 <Cale> okay
14:16:12 <ski_> n is in a binding occurance in "(n :: Nat) ->", there
14:16:39 <Cale> yeah
14:16:59 <ski_> so, the *type* of the result of the function can depend on the actual *argument* passed to the function
14:17:07 <ski_> this is why it is called 'dependent'
14:17:07 <Cale> right
14:17:29 <ski_> ok, back to Set and monad
14:17:41 <ski_> we want approximately the kind  * -> *
14:17:52 <ski_> which is the same as   (a :: *) -> *
14:17:59 <Cale> I'm thinking of kinds as sets of types.
14:18:19 <ski_> kinds are to types what types are to ordinary values
14:18:23 <Cale> right
14:18:29 <Cale> I think of types as sets of values
14:18:30 <ski_> but we want to ensure that a is in Ord
14:18:52 <ski_> so, we want the type constructor to not just take the type a as argument
14:19:13 <ski_> but also evidence/proof that that a argument is indeed in class Ord
14:19:26 <Cale> ah, okay
14:19:29 <ski_> now, if we didn't have classes but instead something like
14:19:52 <ski_> data Ord a = MkOrd {(<=) :: a -> a -> Bool, ...}
14:20:19 <ski_> which means that we'd pass around instances / method records explicitely
14:20:31 <ski_> then
14:20:48 <ski_> we could just have our kind be    (a :: *,Ord a) -> *
14:20:51 <ski_> ok ?
14:21:08 <Cale> , means such that?
14:21:15 <ski_> , is product kind, there
14:21:41 <Cale> ah, hmm... how is the product of kinds defined?
14:21:54 <Cale> I'm thinking along the lines of Cartesian product.
14:21:56 <ski_> just like  , in [(a,b)] -> ([a],[b])  is product type
14:22:00 <ski_> yes, like that
14:22:28 <Cale> oh
14:22:32 <Cale> yes, of course :)
14:22:36 <ski_> (actually, here it's unfortunate that haskell uses same syntax for pairs of values as for product of types)
14:22:48 <ski_> it can confuse things a bit ..
14:23:01 <ski_> (especially when thinking about dependent types)
14:23:04 <Cale> You want the singleton kind Ord a
14:23:18 <ski_> i do ?
14:23:43 <Cale> well, hmm... this isn't exactly a product
14:24:08 <ski_> in (a :: *,Ord a) -> *  , this is supposed to be the kind of type constructors, that take a *pair* of a type 'a' as argument and of a proof that *that* 'a' has an Ord instance
14:24:36 <ski_> (except that i expressed this with a *type-constuctor* here, instead of a class)
14:24:39 <ski_> so, e.g.
14:24:48 <ski_> boolOrd :: Ord Bool
14:24:58 <Cale> it's just that codependence on 'a' between the factors that's making me think 'not a product'
14:25:01 <Cale> but okay
14:25:02 <ski_> boolOrd = MkOrd {(<=) = ...}
14:25:06 <Cale> I understand what you mean :)
14:25:20 <ski_> then we can form the type    Set (Bool,boolOrd)
14:25:42 <ski_> see how we use the *value* boolOrd, inside the type here !   typical of dependent-types
14:25:48 <Cale> right
14:26:25 <ski_> but
14:26:40 <ski_> we might not want to introduce full dependent-types in haskell
14:27:00 <Cale> right - in fact, we hardly want that at all
14:27:19 <Cale> I just want kinds which are less polymorphic than *
14:27:24 <ski_> also, we'd like this to operate on type-classes, instead of them being simulated by types like Ord :: * -> *  together with method records of such types
14:27:50 <ski_> i'm here just using dependent types to try to think more clearly what we want
14:28:39 <ski_> one possibly option would maybe be to start with
14:28:43 <Oejet> boegel: ping
14:28:47 <ski_> class C (a :: *)
14:29:01 <ski_> and say that all such classes C induces a sub-kind of *
14:29:09 <Cale> yes
14:29:11 <Cale> each
14:29:24 <ski_> yes, right
14:29:29 <Cale> and subsets of them
14:29:33 <ski_> ?
14:29:40 <Cale> (Ord a, Eq a)
14:29:57 <ski_> hm, yes, right
14:30:16 <ski_> (actually, i'd say 'conjunctions' rather than 'subsets' :)
14:30:27 <Cale> well, yes
14:30:39 <Cale> We want type-comprehensions in some sense.
14:30:45 <ski_> hm
14:30:55 <ski_> but, hm
14:30:55 <Cale> Where the only valid constraints are typeclasses
14:31:02 <ski_> assume we have a type 'a'
14:31:08 <ski_> and we know
14:31:14 <ski_> instance C a b
14:31:16 <ski_> for some b
14:31:22 <ski_> um, no
14:31:24 <ski_> rather
14:31:37 <ski_> we'd want to subkind of * of all types b such that C a b
14:31:45 <ski_> we'd possibly want that too
14:31:49 <ski_> s/to/the/
14:31:59 <Cale> I'd also like to be able to say { a -> b : Ord a, Eq b } < * -> *
14:32:07 <ski_> hm
14:32:19 <Cale> or even
14:32:25 <Cale> I'd also like to be able to say { a -> b : Foo a b } < * -> *
14:32:27 <ski_> so the type argument there must be a function type ?
14:32:59 <Cale> ah, hmm
14:33:06 <Cale> actually that syntax is confusing :)
14:33:24 <Cale> very confusing :)
14:33:27 <ski_> yes ... is your { : } supposed to be comprehension ?
14:33:30 <Cale> yes
14:33:38 <Cale> but I said something I didn't want to
14:34:00 <ski_> i'd think it would be a bit odd to make a type constructor that only accepts function types
14:34:15 <Cale> right, it wasn't exactly intended in that way
14:34:24 <Cale> hmm
14:34:26 <ski_> one could instead take two type arguments, corresponding to the domain and codomain of that function
14:34:29 <Cale> how to express this :)
14:34:52 <Cale> I want a subkind of * -> *
14:35:02 <ski_> i'm also not sure about your intended meaning of "<" there ..
14:35:05 <Cale> where the types involved are always restricted
14:35:16 <ski_> {... : ...} was supposed to be a kind, yes ?
14:35:21 <Cale> yes
14:35:34 <Cale> sorry, scratch that notation for now
14:35:36 <ski_> so why not just   {... : ...} -> ...   in that case ?
14:35:41 <ski_> ok :)
14:35:57 <Lemmih> Is there a nice way to group several tests with QuickCheck?
14:36:21 <ski_> (you know,   a :: *,b :: * |- a -> b :: *)
14:36:35 <ski_> hm
14:36:40 <ski_> (but .. ?)
14:37:03 <Cale> actually, I'm not so sure we need to restrict the codomain of the kind arrow.
14:37:17 <Cale> That's baing done anyway
14:37:22 <Cale> being*
14:37:30 <ski_> i think we don't need that here (but not fully sure)
14:37:35 <Cale> okay
14:37:43 <ski_> (i.e. i agree with you :)=
14:37:50 <Cale> okay
14:38:01 <Cale> so, really, we just need restrictions of *
14:38:14 <Cale> and not complicated restrictions of * -> *
14:38:22 <ski_> hm ..
14:38:32 <ski_> aha
14:38:58 <ski_> you meant your example to be parsed as   { a -> b : Ord a, Eq b } < (* -> *)   ?
14:39:04 <Cale> yes
14:39:05 <Sonderblade> i have a function that makes a list of a binary tree like this elements (Branch left x right) = (elements left):x:(elements right):[] haskell complains that it cannot construct the inifinite type??
14:39:17 <ski_> i parsed it as   ({ a -> b : Ord a, Eq b } < *) -> *   :)
14:39:29 <ski_> ok, that explains some
14:39:37 <Cale> ah
14:39:39 <Cale> okay
14:40:23 <ski_> Sonderblade : replace the first and third ':' with ++
14:40:37 <ski_> (and then possibly remove the useless "++[]")
14:41:02 <Cale> It would be nice to be able to put complicated restrictions on * -> * such that the types in the domain are restricted and we get an additional guarantee about the result.
14:41:11 <ski_> (if you want you can also change 'x:' into '[x]++'  if you want)
14:41:19 <Cale> But I don't think it's really going to solve anything extra at this point.
14:41:27 <Sonderblade> ski: thanks but it still complains about the "infinite type: a = [a]"
14:41:50 <ski_> Sonderblade : the issue is that 'elements left' and 'elements right' are not two elements but two *lists of* elements, so you need ++
14:42:17 <ski_> Sonderblade : you have what def. now ?
14:42:21 <Cale> elements (Branch left x right) = (elements left) ++ [x] ++ (elements right)
14:42:30 <ski_> Cale : yes
14:42:36 <Sonderblade> alright now i understand
14:42:40 <ski_> good :)
14:43:08 <Cale> (:) always takes a single element on the left and a list on the right
14:43:09 <ski_> but i'm not sure we need to get back restrictions of the codomain, right now
14:43:50 <ski_> (:) also is right associative so '(elements left):x:(elements right):[]' means '(elements left):(x:((elements right):[]))'
14:44:17 <Sonderblade> why can't (:) be polymorphic so it works with both a and [a]?
14:44:24 <ski_> @type (:)
14:44:26 <lambdabot> forall a. a -> [a] -> [a]
14:44:44 <Cale> Sonderblade: it's a data constructor, which makes it special
14:44:44 <ski_> it is used for adding one element in front of a list
14:45:17 <Cale> It would be possible to make a typeclass to handle that polymorphism, but (:) would still be needed in its present form :)
14:45:31 <Cale> because : can take apart lists, as well as put them togethrer
14:45:34 <Cale> together*
14:45:50 <Cale> f (x:xs) = ...
14:45:58 <Sonderblade> i see
14:46:32 <ski_> the kind of overloading with coercion you envisages does not play so well together with type-inference, i think
14:47:08 <Oejet> I'm getting this error, and I don't know why or how to fix it: *** Exception: Can't find the glade file "memory.glade" in the current directory.  Please help me. :-)
14:47:26 <Cale> Oejet: you need that file :)
14:47:43 <Cale> it's the UI template for the program
14:47:53 <Oejet> Cale: I have that file.
14:48:07 <Cale> odd
14:48:16 <Spark> strace
14:48:31 <Spark> strace -e 'trace=open'
14:49:13 <Oejet> Spark: For me?
14:49:22 <Spark> yep
14:49:26 <Cale> ski_: so now the issue is whether we want structural control over the types in a subkind or not. We don't need it to solve the Functor/Monad problem
14:49:28 <Cale> that is
14:49:50 <ski_> hm
14:49:57 <Cale> Do we want {a -> b : Foo a b} < *  (that's a function arrow) to be a kind?
14:50:15 <Cale> The kind of functions from a to b where Foo a b
14:50:18 <Cale> er
14:50:19 <ski_> i'm not fully convinced sub-kinds is the "right" way, anyway, though
14:50:27 <Cale> of function types
14:50:32 <ski_> hm
14:50:39 <ski_> why not just
14:51:18 <ski_> {(a , b) : Foo a b} < * x *   the kind of pairs of types a and b, for which Foo a b holds
14:51:38 <ski_> (here i wrote product kind with 'x' instead)
14:51:55 <Cale> however, we'll need projections
14:52:03 <ski_> yes
14:52:04 <Cale> at the kind level
14:52:08 <ski_> hm
14:52:20 <ski_> type level, i think
14:52:57 <Cale> ah... hmm...
14:53:03 <ski_> Fst :: forall k0,k1 :: kind. k0 x k1 -> k0
14:53:21 <Cale> okay, how do you envisage forming the kind consisting of all function types a -> b where Foo a b?
14:53:42 <ski_> i was not sure we needed that
14:53:47 <Cale> I'm not sure either
14:53:49 <ski_> but maybe we do
14:54:15 <Cale> If we don't, the solution is reduced to specifying a bunch of single parameter typeclasses
14:54:27 <ski_> hm
14:54:33 <Cale> (or at least, typeclasses with all but one of their parameters filled in)
14:54:34 <shapr> malcolm: I know an excellent solution... canvas for a planet.haskell.org aggregator.
14:54:48 <ski_> i didn't mean to say i wasn't sure we needed multi-arg type-class constraints, here
14:55:07 <drakioned> Hello?
14:55:10 <Cale> hi
14:55:11 <ski_> just that i wasn't sure we needed a subkind what only contained (some) function types
14:55:14 <ski_> hi drakioned
14:55:16 <drakioned> ahhh it works
14:55:19 <Cale> oh
14:55:20 <ski_> :)
14:55:28 <Cale> I was using the function type as an example
14:55:45 <Cale> You can replace that constructor with any constructor taking multiple type parameters
14:56:04 <drakioned> who?
14:56:18 <malcolm> shapr: where is planet.haskell.org?
14:56:19 <Cale> {Bar a b : Foo a b} where Bar : * -> * and Foo is a 2 parameter-typeclass
14:56:29 <shapr> malcolm: It does not exist, ergo we must create it.
14:57:04 <malcolm> shapr: and how do i draw on its canvas :-)
14:57:05 <Cale> er
14:57:09 * shapr grins
14:57:11 <ski_> rather  Bar :: * -> * -> *  ?
14:57:11 <Cale> Bar : * -> * -> *
14:57:13 <Cale> yes
14:57:14 <ski_> :)
14:57:22 <drakioned> ski -> who?
14:57:48 <drakioned> ah
14:58:35 <dolmen> How can I debug a <<loop>> with ghc?
14:59:14 <Cale> dolmen: try each of your definitions
14:59:23 <malcolm> dolmen: use Hat ?  (black-hat detects the program cycle causing a black hole)
14:59:31 <Cale> dolmen: If <<loop>> is occurring, it'll basically always occur.
14:59:45 <Cale> at least, in most cases
15:00:37 <ski_> (depends on IO input and nondeterminism)
15:00:38 <dolmen> my function is not recursive, so I don't understand how there can be a loop...
15:00:40 <Oejet> Spark: It shows nothing about trying to open this file.  Thanks for the command I didn't know it.
15:00:48 <dolmen> @type Hat
15:00:49 <lambdabot> bzzt
15:00:59 <ski_> dolmen : Hat is a tool
15:01:07 <ski_> (for dubugging)
15:01:10 <ski_> de*
15:01:14 <Cale> dolmen: how large is the code -- we could look at it
15:01:21 <ski_> @paste
15:01:22 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:01:28 <dolmen> OK, I will paste it
15:01:34 <ski_> just add it at top
15:02:07 <malcolm> dolmen: even if your fn is not recursive, maybe you are using a data value circularly
15:02:34 <ski_> (e.g.   let x = x+1 in ...   is recursive/circular)
15:04:44 <Cale> Should we need kinds where multiple type parameters are restricted at the same time? It seems we need them for aesthetics of the language at least, as it seems very strange to only allow single parameter restrictions :)
15:05:15 <ski_> yes, i was thinking somthing along that line
15:05:33 <ski_> closure and orthogonality and all that
15:05:34 <Cale> otoh, perhaps this gives too much structural control over the types in a kind
15:05:59 <ski_> let me think about your {a -> b : ...}  again
15:06:25 <autrijus> hm, I wonder this makes more sense:
15:06:26 <autrijus> data [a] = [] | (:) a [a]
15:06:40 <ski_> (makes more sense than what ?)
15:06:47 <autrijus> or this:
15:06:48 <autrijus> data [a] where
15:06:48 <autrijus>     [] :: [a]
15:06:48 <autrijus>     (:) :: a -> [a] -> [a]
15:06:57 <ski_> heh
15:07:09 <autrijus> for my slide to haskell beginners
15:07:13 <dolmen> ski, pasted
15:07:27 <autrijus> I think the GADT form is a bit stronger
15:07:43 <ski_> the former more easily reminds of BNF, though
15:07:46 <sethk> autrijus, to me, definitely the data [a] where     form
15:08:02 <sethk> less dense, more clear
15:08:02 <autrijus> ski_: yeah, though that is quite misleading in a way
15:08:05 <ski_> (and is not as verbose)
15:08:09 <dolmen> autrijus, I'm an Haskell beginner
15:08:11 <ski_> seafood : :)
15:08:14 <dolmen> :)
15:08:28 <ski_> autrijus : in which way ?
15:08:35 <autrijus> dolmen: good. what you think?
15:08:40 <sethk> I like it because it is verbose, and ski_ dislikes it for the same reason.  :)
15:09:00 * ski_ thought he didn't say whether he disliked it or not :)
15:09:37 <ndm> i hate GADT's, but the second one is definately more clear
15:09:52 <autrijus> ski_: BNF focuses on the syntax/pattern part
15:09:53 <ndm> less knowledge of how haskell works, and more explicit representation
15:10:11 <ski_> autrijus : and ?
15:10:25 <Cale> ski_: I'm going to eat dinner. I'll be back :)
15:10:26 <autrijus> while the list is imho more defined by the two constructors's types
15:10:46 <Spark> Oejet: are there any wrapper scripts / interpreters involved? you may need -f
15:11:05 <dolmen> autrijus, I prefer the first one
15:11:11 <Oejet> dcoutts: I have problems convincing Gtk2Hs that I do infact have a memory.glade in the current directory.  Do you have any ideas?
15:11:19 <Oejet> Spark: No, just a.out.
15:11:40 <dolmen> autrijus, to understand the second you must understand complex data types
15:11:59 <malcolm> For beginners, the GADT definition may be better.  It makes the constructors seem more like functions (which they are, in a way), and is quite similar to class Foo where  foo :: ...
15:12:00 <ski_> dolmen : in beginning of 'find'  'let best = best_solution aim best (result, (Add a b):operations) in ...' is recursive .. i think you possibly did not intend this
15:12:06 <kosmikus> autrijus: if you'd go for the first, I'd use "data [a] = [] | a : [a]", but I also prefer the second
15:12:07 <ski_> Cale : ok, np
15:12:44 * TheHunter prefers the first.
15:12:55 <dolmen> ski_: "let best = ... best ..." is recursivity ?
15:12:56 * ski_ thinks both can be good :)
15:13:03 <ski_> dolmen : yes
15:13:23 <autrijus> ok, I'll put both.
15:13:58 <ski_> you can mention how the first form corresponds to labelled BNF
15:14:10 <TheHunter> what I dislike about gadt notation for normal adts is that existentials can sneak in easily and that is definitely going to confuse newbies.
15:14:19 <dolmen> ski, I thought it would be considered as a different one
15:14:50 * malcolm thinks using both is a good idea too
15:14:52 <ski_> no, 'let' and 'where' in haskell always introduces (possibly) recursive bindings
15:15:04 <dolmen> ski_, if I do 'let best2 = ... best ...', it should solve the problem, isn't it?
15:15:05 <ski_> in e.g. SML and OCaml, this is not so
15:15:08 <ski_> yes
15:15:34 <ski_> (in Scheme you also have nonrecursive 'let' .. and recursive 'letrec')
15:16:11 <Oejet> Good night all.
15:16:43 <TheHunter> Come to think of it, I probably would even normal adt-notation with type-equality annotations over gadt-syntax.
15:17:11 <ski_> type-equality annotations ?
15:17:18 <JohnMeacham> there is no need for the distinction in haskell since let never evaluates anything.
15:17:33 <ski_> TheHunter : ah, you meant algebraic datatype by adt ..)(
15:17:45 <dolmen> ski_, I have multiple "let best = ". Do I have to use another symbol for each to avoid recursion?
15:17:50 <ski_> JohnMeacham : ?
15:17:50 <sethk> JohnMeacham, although I noticed in SPJ's books (or at least the older one) he does show a separate let and letrec
15:18:48 <TheHunter> ski, instead of |data Foo :: * -> * -> * where a -> Foo a a|: |data Foo a b = Foo (a =:= b) a
15:18:50 <ski_> dolmen : if you have a variable best, then you can do    'let best2 = ..best.. in ... let best = ..best2.. in ...'  and the inner best will be different from the outer one
15:19:30 <ski_> dolmen : but, possibly, it's be less confusing to have different names for them all, anyway
15:20:31 <dolmen> ski_: I wanted to show the common parts. Using 2 "variable" breaks that.
15:20:56 <dolmen> s/common/similar/
15:21:10 <JohnMeacham> yeah, it is often useful for implementations of haskell to make the distinction internally, since you can treat let's in a simpler way. but there is no observable distinction in haskell, so the source language need not make the distinction. it is trivial for the compiler to decompose your lets to lets and letrecs3
15:21:25 <ski_> dolmen : if you have  'let a = ...; b = ...; ... in ...' then all the variables bound in this let (i.e. 'a','b',...) will be mutually recursive with each other (so each mention of any of 'a','b',... in those bindings will refer to that variable as defined in that 'let' even if present as another varible outside) ... otoh, any let inside the last '...' will not be mutually recursive with this
15:22:09 <JohnMeacham> too many uses of the word 'distinction'. I not good prose.
15:22:36 <ski_> TheHunter : ah, but that's a different (though possibly isomorphic) type, rather than just another form of definition for it ..
15:24:00 <ndm> and also in ghc core, there is a separate let and letrec
15:24:30 <ski_> JohnMeacham : i was not talking of implementation and optimisation, here .. but of how the variables scope and where the recursion is available (wheher one uses it or not)
15:24:35 <dolmen> ski_: ok. I have to comletely redesign the function
15:25:05 <ski_> in haskell,  in 'let x = E0 in E1' the 'x' scopes *both* over 'E0' and 'E1'
15:25:30 <dolmen> yes, I understand now
15:25:54 <ski_> similarly 'let f ... = E0; g ... = E1 in E2' both 'f' and 'g' scopes over all of 'E0','E1','E2'
15:26:55 <JohnMeacham> ski_: yeah. I was just saying why other languages feel the need to distinguish the two types of lets and haskell doesn't. I have seen it trip up people coming from ML before... mostly I just ramble.
15:27:32 <ski_> imo, haskell doesn't 'not distinguish' the two kinds, rather, it only provides the recursive variant
15:29:20 <ski_> (how this is possible and how it can often be implemented as non-recursive let of course is related with laziness)
15:29:38 <JohnMeacham> ski_: but in a lazy language there _is no_ difference. in a strict one, let and letrec actually mean different things.
15:29:54 <ski_> sure there is a difference
15:30:22 <Sonderblade> are there any indentation rules for haskell?
15:30:31 <ski_> hm, lets see if i can formulate it ..
15:30:34 <JohnMeacham> ski_: it is perfectly possible for a haskell compiler to treat everything as a letrec always. if a strict compiler did that, nothing would get evaluated.
15:30:37 <ski_> Sonderblade : yes
15:31:22 <Sonderblade> ski_: i meant like coding style guide
15:31:29 <dolmen> ski, If I replace "let best = ... best ... in ... best ..." with  "let oldBest = ... best ... in let best = oldBest in ... best ..." it should solve my problem, isn't it?
15:31:32 <ski_> in a strict language 'let x = x + 1 in ..." mean a different thing that it means in haskell
15:32:11 <kosmikus> TheHunter: you really dislike GADT syntax? I think the fact that it hides existentials is a nice thing, actually ...
15:32:15 <astrolabe> A style guide would be useful
15:32:17 <ski_> dolmen : possibly http://www.haskell.org/hawiki/HaskellStyle can help you some
15:32:39 <ski_> bah
15:32:45 <dolmen> yes thank you
15:32:45 <ski_> s/dolmen/Sonderblade/
15:32:52 <JohnMeacham> Oh. I am not talking about scoping rules, I am talking about the operational semantics of how they are evaluated. strict languages need two rules, lazy ones only need one.
15:32:54 <ski_> dolmen : sorry
15:32:56 <dolmen> it will help me too ;)
15:32:59 <ski_> :)
15:33:08 <Sonderblade> ski_: great
15:33:30 <ski_> dolmen : yes, that would be a possible way of solving it
15:33:43 <sethk> JohnMeacham, what about the fact that you can have things in haskell that are explicitly strict
15:34:06 * ski_ are talking about the scoping and recursivness or not of a 'let'
15:34:11 <ski_> s/are/is/ :)
15:34:30 <ski_> sethk : i think that's not related
15:34:45 <JohnMeacham> sethk: that doesn't affect this because you can never make a 'let' explicitly strict. there is nothing you can do to make let x = .. in e strict in x other than evaluating x in e.
15:35:31 <sethk> JohnMeacham, ok
15:35:42 <sethk> JohnMeacham, I think I understand.  :)
15:35:59 <ski_> with a non-recursive let, we have
15:36:04 <JohnMeacham> Yeah, The operational rules are why haskell can get away with just letrecs and ML needs lets and letrecs.
15:37:07 <sylvan> Those of you who know your way around haskell compiilers (*cough*), how wrong am I in thinking that GHC SMP along with some more eager evaluation method (lenient evaluation? optimistic evaluation?) would make it possible to get implicit parallellism by simply placing everything to be evaluated on a queue and having worker threads evaluating it?
15:37:13 <ski_> Gamma |- e0 :: t0   Gamma,x :: t0 |- e1 :: t1
15:37:13 <ski_> ---------------------------------------------
15:37:13 <ski_> Gamma |- let x = e0 in e1 :: t1
15:37:25 <ski_> with a recursive we have
15:37:26 <ski_> Gamma,x :: t0 |- e0 :: t0   Gamma,x :: t0 |- e1 :: t1
15:37:26 <ski_> -----------------------------------------------------
15:37:26 <ski_> Gamma |- let x = e0 in e1 :: t1
15:37:40 <Heffalump> JohnMeacham: I thought it was the fact that Haskell specifies SCC analysis to find binding groups
15:37:51 <ski_> JohnMeacham : agree
15:38:13 <sethk> sylvan, have you seen the parallel haskell thing?
15:38:19 <sylvan> pH?
15:38:43 <sylvan> or the `par` thing?
15:38:52 <JohnMeacham> Heffalump: but haskell need not do that analysis if it doesn't want to. in ML they would be forced too. (and it would be very confusing because it would reorder your side effects)
15:39:33 <ski_> (you can program without side-effects, to some degree, in ML)
15:39:40 <JohnMeacham> Heffalump: more importantly, that analysis can never change the meaning of a program. with strict languages it can change the meaning.
15:39:46 <sylvan> sethk, I'm trying to figure out if a Haskell compiler could be written so that the programmer only needs to write his program as if it was to be run on a single processor, and then have it automatically use as many cores as availalbe
15:39:48 <ski_> (it would still be problematic because of strictness)
15:40:12 <sethk> sylvan, interesting question, definitely
15:40:18 * SyntaxNinja just sent a mail to haskell@haskell.org, but...
15:40:19 <sethk> sylvan, non-trivial answer, I'm sure
15:40:38 <SyntaxNinja> if you were involved in the Future of Haskell discussion at ICFP and raised your hand about contributng to the standard, email john@galois.com.
15:40:39 <Heffalump> JohnMeacham: doesn't laziness only help with value recursion, though?
15:40:51 <ski_> (sylvan : hm .. have you looked at nesl and nepal ?)
15:41:00 <sethk> sylvan, I wonder how it relates to strictness analysis in the compiler
15:41:07 <sylvan> yeah, I *think* the main issue is deciding weather a thunk is big enough to warrant being computed on another core
15:41:17 <Heffalump> whereas ML needs let vs letrec to get the right behaviour with function recursion too
15:41:27 <SyntaxNinja> or also if you think you'll have time to dedicate to a new standard.  see the email for more details: http://www.haskell.org//pipermail/haskell/2005-October/016587.html
15:41:39 <Heffalump> where "right behaviour" = most general type schemes possible
15:41:56 <sylvan> ski, yeah I saw those... interesting to be sure, but that only deals with data-parallelism right? I was wondering if _everything_ could be parallelised (which has sortof the poster-child benefit of pure languages for the last 20 years =))
15:42:29 <JohnMeacham> Heffalump: lazyness means value recursion is possible :)
15:43:05 <ski_> (sylvan : m, just thought i'd mention it)
15:43:43 <sylvan> ski_, I do think GHC should be able to take a compiletime flag which would make it sort of analyze all map's and list comprehensions etc. and try to paralellize it
15:43:46 <Heffalump> JohnMeacham: yeah.
15:44:42 <ski_> (sylvan : the hard part is analyzing where it's worth it .. shouldn't parallelize too fine-grained, then startup costs will kill it)
15:45:34 <frederik> sylvan, ski: wouldn't optimistic evaluation be a good place to put the parallelism?
15:45:44 <ski_> possibly, yes
15:46:15 <frederik> then you could gather runtime statistics to alert you to situations where all of a long list is being evaluated, and do it optimistically on several processors
15:46:27 <ski_> m
15:47:03 <sethk> you also have to predict the order of evaluation
15:47:12 <sethk> you care not only about whether it make sense to do something in parallel
15:47:18 <sethk> but whether it makes sense to do it at all
15:47:39 <ski_> hm, ..  is it ok with haskell semantics to have   False && error "foo"  to raise an error ?
15:47:57 <ski_> or is it specified to not do that, in that case ?
15:48:08 <sethk> if you aren't the only process running on the box, you can't just use all cpu and not care whether you are evaluating something you never use
15:48:26 <sylvan> you could keep running tabs on functions which were overly (or not enough) parallelised the last time they were called in hopes of repeated calls to the same function converging on some optimal value. And like fredrik said, all the "possibly needed values" could be computed on spare cores
15:49:09 <sylvan> (up to a point, obviously once a value is determined to not be needed its evaluation would be killed etc.)
15:49:52 <sethk> sylvan, what's a spare core?  Assuming you aren't the only process running at any given time.
15:50:46 <sylvan> well low-priority OS-threads kept on as workers
15:51:18 <frederik> read the optimistic evaluation paper, if you haven't...
15:51:22 <sylvan> I did
15:51:42 <sylvan> sadly it's not in GHC anymore as far as I understand
15:52:08 <frederik> really!?
15:52:46 <sylvan> yeah, it included to many changes so it's not in the ghc base and probably won't be
15:53:04 <sylvan> if I understand the reasoning behind it correctly
15:56:10 <frederik> suck
15:56:42 <sylvan> I'm sure that if someone with the know-how took the time to integrate it, it would get included though!
15:57:14 <SyntaxNinja> galois has a lot of interest in doing that. we're thinking of organizing a hackathon for next year's icfp revolving around that + a debugger
15:57:18 <frederik> heh. i don't think rob's ghc-hacking experience was a fond one for him
15:59:58 <sylvan> SyntaxNinja, what's your opinion about the feasability of using transparent parallelism (without programmer-annotations) in GHC?
16:01:54 <SyntaxNinja> I don't have much opinion. I have the feeling that it's been tried and not been very successful in the past, but I'm not sure of that.
16:02:18 <SyntaxNinja> we're interested in the eager haskell stuff because of the hsdebug tool.
16:02:30 <sylvan> ah
16:03:07 <sylvan> I've been trying to find old discussions about it and one that I found seem to give the general impression that the biggest hurdle was getting concurrent evaluation of thunks, which is now solved with the SMP stuff in GHC
16:04:30 <sylvan> Anyway, it's an interesting topic, and I'm sure it would be an extremly big selling point for haskell in the near future if it could be solved (what with trend towards multi-core systems).. I'm off to bed!
16:06:52 <Heffalump> I thought the optimistic evaluation branch was never merged into core GHC because it wasn't that much of a win overall.
16:11:18 <MarcWeber> Is anyone using hdirect on windows?
16:14:50 <dolmen> does GHC handle UTF-8 ?
16:14:58 <dolmen> maybe in a library ?
16:16:18 <MarcWeber> dolmen: Don't know much but yi is using it I think
16:16:26 * Itkovian watches tha apple special event
16:16:58 <rep> Itkovian url?
16:17:11 <Itkovian> http://stream.apple.akadns.net/
16:17:24 <musasabi> GHC can handle utf8, but the standard libraries don't help things.
16:17:31 <MarcWeber> \url
16:17:35 <MarcWeber> \url
16:17:48 <MarcWeber> ups. sorry.. It's to late.
16:17:58 <Itkovian> new iMac
16:21:43 <dcoutts> marcot, pong
16:22:03 <dcoutts> @seen Oejet
16:22:04 <lambdabot> I saw Oejet leaving #haskell 1 hour, 5 minutes and 38 seconds ago.
16:22:24 <marcot> dcoutts: =D
16:22:39 <dcoutts> marcot, so where were we?
16:22:58 <marcot> dcoutts: I was intending to change the directory of gtk2hs from /usr/lib/gtk2hs for /usr/lib/libghc6-gtk-dev, to match the name of the package.
16:23:13 <dcoutts> ah right
16:23:17 <marcot> dcoutts: I've searched and I saw that this gtk2hs is from the name of the package in the header of configure.ac
16:23:30 <dcoutts> yes, it appends the package name
16:23:30 <marcot> dcoutts: So I left it as it is.
16:23:31 <marcot> =D
16:23:59 <marcot> dcoutts: there's not an elegant way of changing it.
16:24:42 <dcoutts> you could override pkglibdir during make install
16:25:17 <dcoutts> try: make install pkglibdir=/usr/lib/libghc6-gtk-dev
16:25:46 <dcoutts> or rather: make install pkglibdir=/usr/lib/libghc6-gtk-dev DESTDIR=$BUILD_TMP
16:30:21 <marcot> dcoutts: no, it must be before configure.
16:30:41 <marcot> dcoutts: cause it's substituted in the .conf.in files.
16:30:41 <dcoutts> really?
16:30:47 <dcoutts> oh yes
16:31:47 <dcoutts> that can be overriden with ./configure --with-hidir=
16:32:43 <SyntaxNinja> @wiki FutureOfHaskellDiscussionDiscussion
16:32:44 <lambdabot> http://www.haskell.org/hawiki/FutureOfHaskellDiscussionDiscussion
16:34:20 <JohnMeacham> hello. sorry for disapearing. I realized I was 7 hours late for work.
16:35:24 <JohnMeacham> I am going to post this to the list shortly. any comments before I do? http://repetae.net/classalias.txt
16:36:34 <JohnMeacham> it is a proposed extension which will allow us to abstract over class hierarchys much as we can over functions and datatypes now. incidentally it allows us to replace the preludes numeric hierarchy while retaining 100% backwards compatability.
16:44:36 <Igloo> SyntaxNinja: Please do stop CCing both lists
16:44:48 <ski_> JohnMeacham : is that related to your idea about "super-"classing ?
16:44:52 <arjanb> at first read it looks good to me
16:45:01 <ski_> (which is an interesting idea)
16:45:07 <musasabi> JohnMeacham: how should the typeclass constraints be inferred - most wide aliases?
16:46:26 <Heffalump> JohnMeacham: did you miss out an 'alias' keyword in the new definition of Num?
16:47:47 <Heffalump> JohnMeacham: also, have you considered how defaults would work? (I think it's ok, but it does need checking)
16:48:34 <arjanb> i think the ability to instance multiple classes in one is useful even without class alias
16:49:07 <JohnMeacham> I did. thanks.
16:49:39 <JohnMeacham> arjanb: yeah, that is what I meant by it 'incidentally' adds some nice to have capabilities. namely the ability to instantiate a class and all its superclasses with one declaration.
16:50:22 * Heffalump goes to bed
16:50:37 <JohnMeacham> musasabi: what do you mean? it does not change inference at all, it can be thought of as a (fancy) macro replacement in a way.
16:50:46 <marcot> dcoutts: can that?
16:50:50 <JohnMeacham> ski_: the last note at the bottom addresses that.
16:51:15 <ski_> JohnMeacham : ah, you propose to instance many (super-)classes at the same time .. i've wanted that for some time
16:51:16 <JohnMeacham> ski_: this is better than my superclassing idea. and is much simpler to implement as it doesn't require changing the run-time model.
16:51:28 <dcoutts> marcot, huh?
16:51:56 <ski_> one thing that'd be nice also is having a default in one class for a method in a super-class
16:51:58 <musasabi> JohnMeacham: whether "foo x = x + 0" is inferred as "foo :: Num a => a -> a" or "foo :: (Additive a, FromInteger a) => a -> a".
16:52:02 <ski_> if it can be made to work
16:52:20 <marcot> dcoutts: even the GLIB_LIBDIR part will be overriden by changing hidir/
16:52:21 <JohnMeacham> ski_: yeah, but they are not superclasses, they are members of the alias.
16:52:48 <ski_> (JohnMeacham : i have not read the link you just pasted ..)
16:52:52 <JohnMeacham> musasabi: it doesn't matter. it is the difference between "hello" being infered as String or [Char]
16:52:53 <musasabi> JohnMeacham: if the first one is true then all types need to implement whole Num. On the other hand if the second is true then type signatures can get overly complex.
16:53:14 <dcoutts> marcot, actually you don't need to override it during configure
16:53:25 <franka> Pseudonym, I enjoyed the binary trees paper; it's very tidy.
16:53:29 <dcoutts> marcot, run configure and look at the gtk/gtk.package.conf for example
16:53:45 <dcoutts> marcot, the ${pkglibdir} substitution is done later
16:53:52 <JohnMeacham> musasabi: ah, I see what you mean. it would infer the second.
16:53:56 <Pseudonym> Yeah, I thought you might.
16:53:58 <dcoutts> marcot, at make install time I think
16:54:21 <Pseudonym> I think it's really instructive.  The point is: Don't be afraid of abstraction, even to abstract five lines of code.
16:54:22 <JohnMeacham> musasabi: error messages would not be compatable with haskell 98.. but typesafe source would be :)
16:54:25 <franka> I might work that into my thesis.
16:54:45 <Pseudonym> Good abstraction encourages clear thinking.
16:54:53 <franka> The paper, I mean.
16:54:56 <Pseudonym> Yes.
16:55:03 <musasabi> JohnMeacham: I am more conserned with types that are larger than code. (My haskelldb code already manages to do that in hswebforms)
16:55:17 <marcot> dcoutts: hum.. nice!
16:55:29 <dons> moin
16:55:34 <franka> One wonders what other sort of common data structures can be handled similarly.
16:55:34 <JohnMeacham> musasabi: well, this solves that, because you would just create an alias for anything complicated and use that.
16:55:39 <marcot> dcoutts: but I'm still wondering it it's really necessary.
16:55:56 <Pseudonym> Indeed.
16:56:02 <franka> Sequences, surely, and I guess priority queues, as he notes.
16:56:03 <Lemmih> Hi dons.
16:56:06 <Pseudonym> I think it's going to be most useful if it's something LIKE binary trees.
16:56:16 <Pseudonym> In that, insertion is easy, but deletion seems more difficult.
16:56:19 <dcoutts> morning dons
16:56:33 <Pseudonym> Any time you have that kind of asymmetry, you're probably working at the wrong level of abstraction.
16:56:41 <ski_> Pseudonym : uri ?
16:56:50 <Pseudonym> @google "a fresh look at binary search trees"
16:56:52 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications.html
16:56:56 <JohnMeacham> musasabi: at least, it doesn't make anything worse. but it potentially makes them a lot better. since class aliases are just synonyms, you can declare as many as you like as shorthand, just like you do with type synonyms now.
16:56:59 <marcot> Igloo: do you think that it's good that the installed directory be /usr/lib/libgch6-gtk-dev instead of /usr/lib/gtk2hs
16:57:03 <musasabi> JohnMeacham: good point. Creating aliases outside the library would be very nifty.
16:57:09 <dons> JohnMeacham, arjanb, SyntaxNinja: add your details :) http://www.haskell.org/hawiki/HaskellUserLocations
16:57:14 <JohnMeacham> musasabi: that is definitly the idea.
16:57:46 <franka> However, I'm not sure of how much practical use it is at present, given there is no views feature in GHC.
16:57:50 <JohnMeacham> another one of those 'incidental' but not earth shattering benefits. :)
16:57:51 <Pseudonym> There are some situations, of course, where it won't help.  At work we had tremendous trouble with deleting from B-trees.
16:57:54 <franka> Perhaps it could be hacked up in TH.
16:58:00 <Pseudonym> franka: You can implement views yourself.
16:58:06 <marcot> Igloo: hum... and there's something else. You asked me what was the name of the registered package in ghc, I said gtk, but it register not only gtk, but glade, gconf, sourceview, and others.
16:58:06 <Pseudonym> @wiki ConcreteView
16:58:08 <lambdabot> http://www.haskell.org/hawiki/ConcreteView
16:58:08 <Igloo> marcot: Not sure OTTOMH
16:58:31 <marcot> Igloo: but the main on is still gtk. Do you think it's ok that gtk name of package?
16:58:36 <Igloo> marcot: Right, you either need n binary packages (prefered), or to Provide: the other package names
16:58:53 <Pseudonym> ConcreteView doesn't give you all of the syntactic sugar, but it's close enough.
16:59:11 <JohnMeacham> okay. I will go ahead and post it with the minor tweaks mentioned.
16:59:44 <franka> The idea is to write the iso and convert back and forth as necessary?
16:59:49 <Pseudonym> Yes.
17:00:13 <franka> Mm.  My thesis is all about this topic.
17:00:21 <dcoutts> marcot, the advantage of having several binary packages is that the deps become more granular. It means you don't need to have mozilla instaled just to use gtk with glade say. (since of course the mozembed package depends on mozilla or firefox)
17:00:25 <Pseudonym> Cool.
17:00:36 <Pseudonym> I'd be interested in knowing more about what you're doing.  Have you done any papers yet>
17:00:37 <Pseudonym> ?
17:01:24 <marcot> dcoutts: sure it is.
17:01:25 <franka> I have two published.  The second deals with automating the insertion of isos using Generic Haskell.
17:01:39 <Pseudonym> uri?
17:01:52 <franka> I am still working on the third, which is a more comprehensive approach to the whole topic, and not particularly Haskell-related.
17:02:03 * Pseudonym nods
17:02:04 <marcot> dcoutts: but there's no an way of changing ${pkglibdir} for each package... )=
17:02:08 <franka> http://www.cs.uu.nl/~franka/pub
17:02:18 <Pseudonym> Thanks.
17:02:32 <Pseudonym> Sounds like useful stuff.
17:02:58 <marcot> dcoutts: And what about internal deps? I mean, glade and sourceview depends on gtk, is there any other?
17:03:21 <franka> The inferring isos stuff in GH is rather impractical, but the idea has broad application, I think.
17:03:33 * Pseudonym nods
17:03:52 <Pseudonym> Even if it needs programmer help, it still sounds like a useful design tool.
17:04:00 <marcot> Igloo: I think I'll do n packages.
17:04:10 <Pseudonym> I'm always on the lookout for clever ways to design functional data structures.
17:04:26 <Pseudonym> Because I think that's the biggest impediment for programmers used to imperative languages.
17:04:47 <Pseudonym> Most programmers can grok recursion, and most can get the hang of monads by using them a few times.
17:04:54 <Pseudonym> But not many want to do without pointers.
17:05:14 <Pseudonym> pointer : data strucutre :: goto : program structure
17:05:16 * franka nods.
17:05:41 <dcoutts> marcot, you can check the package files for the precise inter-package deps
17:05:56 <franka> The Zipper is a nice way to handle the "reverse the link pointers" trick.
17:06:02 <Pseudonym> Definitely.
17:06:05 <dcoutts> marcot, but yet the optional packages all depend on gtk (which depends on the glib package)
17:06:41 <marcot> dcoutts: hum, ok.
17:07:23 <franka> That's an interesting analogy, though.  I'll keep it in mind.
17:08:41 <Pseudonym> One thing that I think the world really needs is a book on API design.
17:09:02 <Pseudonym> Programmers are taught how to write algorithms, but few are taught how to expose them to other programmers.
17:09:17 <marcot> dcoutts: what's this mogul thing?
17:09:34 <Pseudonym> The trouble is, I don't know anyone who is qualified to write it.
17:10:04 <Pseudonym> Maybe Alex Stepanov.
17:10:09 <dons> oh, great idea Pseudonym
17:10:15 <franka> Yes, the approach to teaching algorithms is usually untyped, too, so they don't get the benefit of being able to look at it from a more abstract level.
17:10:21 <Pseudonym> Right.
17:10:31 <Pseudonym> And there would be a whole section on how to understand data structures./
17:11:07 <franka> How about Chris Okasaki?
17:11:18 <Pseudonym> Have you SEEN the Edison interface?
17:11:23 <franka> haha
17:11:25 <dons> hehe
17:11:33 <Pseudonym> :-)
17:11:36 <franka> I am thinking more of the data structure design.
17:11:40 <Pseudonym> True.
17:11:51 <Pseudonym> But I think he comes from the point of view of analysing data structures.
17:11:55 <Pseudonym> Which isn't wrong at all.
17:12:23 <Pseudonym> But there are some data structures where any design is as good as any other, from an algorithmic complexity point of view.
17:12:38 <franka> One thing I really liked in his book was the bit on using numeral systems to motivate data structure design.
17:13:00 <Pseudonym> My boss thinks there should be a book called "Algorithms, Data Structures and Tradeoffs".
17:13:05 <Pseudonym> And he reckons he could write it, too.
17:13:23 <franka> Who's your boss?
17:13:27 <Pseudonym> Neil Sharman
17:14:39 <franka> You reckon he's got good ideas for it, or are you being skeptical?
17:14:42 <Pseudonym> The point being that you might want to use a data structure even if it has poor complexity or large constant factors.
17:14:46 <Pseudonym> I think he does have good ideas.
17:14:50 <Pseudonym> Take hash tables, for example.
17:15:07 <Pseudonym> Hash tables are usually inferior to tries, all other things being equal.
17:15:23 <Pseudonym> However, hash tables have the feature that they're easy to make concurrent.
17:15:29 <Pseudonym> Because you can "lock" a hash chain.
17:15:39 <marcot> dcoutts: any ideas about how to change the /usr/lib/pkgname in each package?
17:15:51 <dons> dcoutts, any hIDE news I should be aware of? latest code, api changes?
17:15:53 * franka nods.
17:15:54 <JohnMeacham> But hash tables have much better memory locality.
17:16:05 <Pseudonym> Well, they CAN have much better memory locality.
17:16:22 <Pseudonym> Most naive ways of implementing chained hash tables can have quite poor locality.
17:16:26 <dcoutts> marcot, that should happen automatically when you make install pkglibdir=/usr/lib/foobar
17:16:47 <dcoutts> marcot, the package files get substituted into during make install
17:17:10 <JohnMeacham> balanced trees do horribly in kernel development... of course, most haskell runtimes pretty much ruin cache locality to begin with..
17:17:14 <franka> So what does this have to do with API design?
17:17:41 <dcoutts> dons, I've not changed any code in the last few days. I'll be interested to see if the exising EditorPage api is an ok fit for Yi.
17:17:47 <dons> JohnM, as the kernel guys in my research group continually remind me :S
17:17:54 <Pseudonym> It has a bit to do with API design, kind of.
17:18:03 <Pseudonym> Because a lot of these tradeoffs need to be exposed in APIs.
17:18:07 <dons> dcoutts, ok. /me begins 3 day hIDE hackathon..
17:18:23 <Lemmih> yay (:
17:18:33 * dons <= coffee
17:18:37 <dcoutts> dons, I'm planning to make the EditorPage provider aware of when it has been opened for the first time in each top level window, so it can keep per-window state.
17:18:58 <franka> Yes, that's always the problem.  You're either hiding too much or not enough.
17:19:07 <dcoutts> dons, eg the htmlviewer component should keep only one widget per window and just load a new url when  you switch pages.
17:19:32 <JohnMeacham> I always thought we should provide this as a library in haskell http://judy.sf.net they are damn fast... I mean friggen amazingly fast.
17:19:35 <dons> oh, that sounds good dcoutts. there may be interesting things we need to tag to windows.
17:20:07 <JohnMeacham> as in a binding to those libraries is what I mean. the algorithms wouldn't translate to haskell as they depend on memory access behavior.
17:20:11 <marcot> dcoutts: but I want it to change to one value for each package, without running more than one make isntall. I think I'll have to change it directly after building.
17:20:33 <dcoutts> dons, and Yi might want to use that per-window state feature to keep a limited cache of source buffers & source view widgets around.
17:20:36 <marcot> dcoutts: what's mogul?
17:21:12 <dcoutts> marcot, it's a higher level library implemented on top of gtk. However it's obsolete. We're going to junk it soon. Well, before 1.0 anyway.
17:21:31 <marcot> dcoutts: ok. =D
17:21:32 <dons> hmm. possibly dcoutts.
17:21:50 <dons> as an aside, I'm really happy with how much code I can chuck out now by using gtk :D
17:21:58 <dcoutts> dons, to allow Yi to scale to having hundreds of Yi "windows".
17:22:04 <dcoutts> dons, nice :-)
17:22:08 <dons> ah, good point
17:22:36 <JohnMeacham> I forget, does fptools take LGPL licensed libraries?
17:24:03 <dcoutts> dons, I imageine that the Yi Window abstraction keeps the important state about a window and can save and restore any expensive state to disk. Then when a window is actually visible to the user it can be attached to a GtkSourceBuffer and GtkSourceView. But while it should be fine to have hundereds of Yi Window things around, it's too expensive to have hundereds of GtkSourceBuffer/GtkSourceViews around.
17:25:14 <dons> ah, ok.
17:25:25 <dons> and just when I was thinking of moving more things over to gtk to handle
17:25:33 <dcoutts> :-)
17:25:57 <dcoutts> I think that kind of scaling is important though
17:26:13 <dons> yes, I agree.
17:26:24 <dcoutts> it means we can get away with the UI design of all files being 'open' from the users point of view
17:26:50 <dcoutts> rather than having open files in tabs and making the user close tabs to keep resource usage down.
17:27:29 <dcoutts> since once we implement features like jump to definition one can quickly end up with lots of files open
17:27:54 <dcoutts> which would become a pain from a UI point of view
17:28:08 <dcoutts> and it confuses the point of the file browser
17:28:39 <dcoutts> having tabs of open files and a file/module browser is a confusing duplication
17:30:17 <dcoutts> One of the good features of MS VS is that it does encourage you to have lots of files open at once. It's UI doesn't make that too much of a pain (mainly since it doesn't use tabs for that)
17:30:50 * dcoutts will now stop his UI design monologue
17:37:01 <franka> I was enjoying it. :)
17:37:41 <franka> Tell me more about your philosophy of UI design... he said nonchalantly.
17:39:18 <dons> dcoutts, sorry ,got distracted. keep up the UI design, anyway, since Lemmih and I don't want to do it :)
17:41:04 <dcoutts> dons, :-)
17:47:42 <wagle> could cache file handles
17:47:54 <wagle> weak pointers, or whatever
17:48:13 <wagle> i've seen people say that file open/close stuff needs to go
17:48:33 <JohnMeacham> dcoutts yeah, that sounds good. the tab proliferation always bugged me. how do you show which buffers have been changed in memory but not commited to disk yet?
17:48:42 <wagle> everything you do should be persistent but undoable
17:49:26 <skew> designing hIDE?
17:53:57 <dcoutts> JohnMeacham, I was thinking of having a "recent" tab in the collection of module browsers. It'd have the recently viewed files and all unsaved ones highlited in some manner (eg in red or with a *)
17:54:17 <dcoutts> http://haskell.org/~duncan/hIDE/hIDE2.png
17:54:34 <dcoutts> so in that picture you can see there are a number of file/module browser views open
17:55:04 <dcoutts> "Files 1" etc and "Open". Though as I said I'm thinking of renaming that "Recent"
17:55:42 <JohnMeacham> this is a very good paper on undo algorithms. very interestingly, he derived almost exactly the darcs algorithm of patch commutation in parallel. http://citeseer.ist.psu.edu/4839.html
17:55:56 <JohnMeacham> AFAIK neither knew of the others work.
17:56:10 <dcoutts> Unsaved open files would also be marked in the same manner in the normal file/module browser view. But the recent tab will prevent unsaved ones from getting lost in a big source tree.
17:57:06 <dcoutts> wagle, that's an interesting idea. Talk to dons about that one. It'd need the editor to support it.
17:57:52 <JohnMeacham> but he applies the ideas of patch commutation to undoing actions in an editor, so you can make a change, make another change in the same place and undo the first change without undoing the second. just like unpulling a patch in darcs that wasn't the last one applied.
17:58:06 <dcoutts> interesting
17:59:16 <dcoutts> dons, I guess the idea there would be to have the undo state saved to disk and restored when Yi is restarted. So you could leave files open and "unsaved" so long as the undo/redo history is kept.
17:59:38 <dcoutts> So one doesn't loose any work if you close without saving.
18:00:31 <dons> yes, I like this, and it's certainly possible.
18:00:32 <JohnMeacham> heh. I like the idea of having a darcs repo where every change becomes a patch and 'undo' means 'unpull' and explicitly saving does a 'unrecord' then a 'record' to turn all your little edits into one big one.
18:00:38 <dons> it was a question during my HW talk, in fact
18:00:44 <dons> (becaues VH can't do it.. )
18:00:54 <dcoutts> dons, heh :-)
18:01:18 <dcoutts> I'm sure we'll be able to have quite a list of things VH can't do :-)
18:04:00 <JohnMeacham> ooh. you can have  a mode, like 'highlight everything I can 'undo' on this screen' and you choose what you want to undo. so you don't have to undo through history to find a change you made a  while ago. you could do the same for 'redo' that would really rock.
18:04:56 <dons> oh, that's a nice idea
18:05:13 <dons> a visual non-linear undo
18:05:29 <dcoutts> sounds like a darcs patch browser
18:05:31 <JohnMeacham> that would make 'yi' pretty fundamentally better than other editors IMHO. also, tessa lau's editing by example stuff is neat too. I am sure she would be pleased if her stuff got used in a real editor.
18:05:46 <marcot> Good night all.
18:05:56 <dcoutts> g'night marcot
18:06:08 <dons> it would be a fancy version of one of the undo techniques described in T. Berlage, "A selective undo mechanism for graphical user interfaces based on command objects"
18:06:35 <JohnMeacham> dcoutts: it would effectivly be one, but at a much finer granularity than one tends to use darcs for. I imagine it would use the same algorithm internally though. just like the one mentioned in that paper.
18:06:35 <dcoutts> however we should make sure that Yi/hIDE becomes usable for the basics before going into the cool experimental features
18:06:40 <dons> as you're describing a selective, non-linear (i.e. you don't have to undo in order) undo
18:06:47 <dons> darcs is a bit like this. hmm..
18:07:12 <dcoutts> dons, so the things on my TODO list are 1. implement forward/back history of pages that the user has looked at. 2. look at the issue of menu toolbar items + popup menus in the browser views.
18:07:33 <JohnMeacham> dons: see that paper i posted not long ago. he derived the darcs algorithm in parallel as an attempt to create a sane non-linear undo operation.
18:07:44 <dons> oh, cool!
18:08:17 <dons> dcoutts, sounds good. mine is:(1) get Yi working.
18:08:19 <JohnMeacham> I also found the darcs algorithm much easier to understand when I saw it presented from a different point of view.
18:08:28 <dcoutts> I've already got the "browse history" thing mostly working.
18:10:59 <JohnMeacham> mine is: (1) get Jhc working.
18:12:04 <dcoutts> JohnMeacham, and then (2) send in patches for cabal to support jhc, so that then hIDE will support jhc :-)
18:13:43 <JohnMeacham> dcoutts: heh. I would much rather cabal publish a spec on an interface that compilers and preprocessors should follow and then I can conform jhc and DrIFT to that. it would make much more sense because then people can write their own preprocessors and compilers and distribute them and have them work with cabal immediatly rather than waiting for everyone to upgrade their cabals.
18:15:02 <JohnMeacham> a single spec for preprocessors should be straightforward. I imagine you would need a couple options when it came to compilers whether it was hmake-like (follows dependencies itself) or ghc-like (you must call it on each source file in turn). but that should cover most everything.
18:16:08 <JohnMeacham> It would also be nice if the language extensions were just strings rather than an algebraic datatype so jhc (and each compiler) can come with a mapping of strings -> options and make up their own extensions without having to teach cabal about them first.
18:32:54 <ski_> (hm, a graph of changes to a file, etc .. ?)
18:58:38 <dons> Lemmih, I get this message: Could not find module `Hide.SystemEnv':
18:58:39 <dons>   use -v to see a list of the files searched for((26,7),(26,21))
19:00:18 <JohnMeacham> holy frijoles. just by changing a  Map.fromAscList . map f . Map.toAscList  to a Map.map f I cut jhcs compile time by 25%! both are O(n). gosh those constant factors matter. a lot. a whole lot. there really needs to be methods of converting between Set and Map that preserve the structure. of the tree. I convert between them a whole lot.
19:00:46 <dons> huh. very interesant
19:01:05 <dons> is this compiling via jhc or ghc?
19:01:16 <ski_> (latter, i assume)
19:01:40 <dons> "jhc's compile time" means what here? the time to compile jhc with ghc? or the time to compile haskell with jhc?
19:02:01 <dons> or the time to compile jhc with jhc (is this possible)?
19:02:15 <ski_> (i think not, at this time)
19:02:45 <ski_> hm, probably he meant compiling haskell source with jhc
19:03:13 <ski_> (i was thinking he meant compiling jhc with ghc, but that entails changing ghc, in this case)
19:03:42 <dons> does it? unless ghc is compiling that construct poorly, which is what I assumed he meant
19:03:52 <dons> but perhaps  that doesn't make sense
19:04:00 <dons> or isn't reasonable to assume
19:04:02 <Lemmih> dons: When you compile CommonSense?
19:04:10 <dons> when I run hIDE
19:04:21 <dons> open up a haskell file, those msgs go to stdout
19:04:23 <Cale> JohnMeacham: I very much agree with that!
19:04:32 <skew> typeclasses don't like foralls much, do they
19:04:49 <JohnMeacham> time to compile haskell with jhc.
19:04:53 <dons> Lemmih, maybe my ghc-api is old (?)
19:05:08 <Cale> JohnMeacham: We need things like domain :: (Ord a) => Map a b -> Set a, and things to build maps from sets and functions
19:05:08 <dons> ah, so it improves the performance of jhc muchly
19:05:19 <Cale> and to restrict the domain of a map by a set
19:05:24 <Lemmih> dons: ghc-api doesn't load anything.
19:05:38 <dons> it's not looking for .hi files?
19:05:39 <Lemmih> (except for the hi files of the installed libraries)
19:05:51 <JohnMeacham> I mean. I knew it was not that efficient.. but oh crap. I guess this is a good example of why O(..) isn't the only thing to consider. there is a keysSet in Data.Map. but it is not very efficient.
19:05:52 <dons> not those in 'import' stmts?
19:05:53 <skew> eg, class Match a b; instance Match a a, ghc can't get an instance Match (forall a . a) (forall a . a)
19:06:04 <Lemmih> Hide.SystemEnv is a part of the static core.
19:06:14 <dons> yes, but I was editing Main.hs :)
19:06:20 <Lemmih> Ah.
19:06:31 <dons> so it could be trying to find the import Hide.SystemEnv import?
19:06:35 <dons> .hi, I mean
19:06:46 <Lemmih> Yeah.
19:06:53 <dons> ok, no worries then. trivial issue.
19:06:59 <JohnMeacham> if that were fast, and we had a setToMap :: (a -> b) -> Set a -> Map a b , those would so speed up jhc. I do those conversions all the time in my substitution routines.
19:07:38 <skew> that doesn't sound very hard
19:07:39 <exe> Hello.
19:07:44 <Cale> JohnMeacham: I've asked for that on the libraries list, and nobody really gave me a straight reply
19:08:00 <skew> just grab the file out of fptools and add the function in
19:08:09 <skew> I did the same with Data.Dynamic the other day
19:08:20 <dons> Lemmih, also I guess I have the wrong ghc: Failed to load interface for `Prelude':
19:08:23 <dons>     Bad interface file: /home/dons/lib/ghc-6.5/imports/Prelude.hi
19:08:24 <exe> Main> :t f | f :: Integer -> Integer | Main> :t g | g :: Integer -> Integer -> Integer | Main> :t f . g | ERROR - Type error in application
19:08:26 <exe> Why?
19:08:30 <dons> (also printed to stdout when editing).
19:08:34 <dons> which ghc are you using?
19:08:59 <Lemmih> ghc-api is hacked to load interface files from 6.4
19:09:09 <Cale> exe: f wants an Integer, but g gives an Integer -> Integer
19:09:21 <dons> Lemmih, and you are developing with ghc 6.4.1?
19:09:23 <dons> or 6.4?
19:09:36 <Lemmih> 6.4.1
19:09:47 <skew> JohnMeacham: the Data.Map API even includes that valid :: Map a b -> Bool function for testing "internal structure" (presumably the balance condition), so you could just assume they are balanced the same way
19:09:50 <JohnMeacham> Cale: I think the reason is that it would require making Map or Set non abstract. what should be done is to move the datatypes for both into their own internal module, and have Data.Set and Data.Map only export the abstract versions
19:10:01 <Cale> yeah
19:10:05 <dons> ok. I'll use that too then, for best results :) so hIDE is using haskellSense by default? it looks really nice :)
19:10:08 <Cale> I agree with that
19:10:37 <Cale> they should be integrated, since apparently their representations are similar, and they are important types.
19:10:41 <dons> @timein Lemmih
19:10:44 <lambdabot>  Sorry, don't know this city
19:10:57 <autrijus> dons: On December I'll arrive to Sydney on 10th and spend night of 10th and 11th there, flying away at 12th.
19:11:00 <dons> now, @timein should use the coords registerred on HaskellUserLocations for nick.
19:11:10 <dons> autrijus, great. let me see..
19:11:13 <Lemmih> dons: I'm trying to move to 6.5
19:11:16 <musasabi> JohnMeacham: what about using a "newtype MySet a = Map.Map a ()" and Map.map instead of the conversion routines?
19:11:22 <Lemmih> @timein Copenhagen
19:11:24 <lambdabot>  Thursday, October 13, 2005 at 4:11:01 AM CEST
19:11:42 <Lemmih> Kinda late.
19:11:45 <dons> autrijus, so Saturday 10th->Monday 12th?
19:11:52 <autrijus> dons: yes
19:11:53 <JohnMeacham> musasabi: I am considering that for some critical sections.
19:12:04 <dons> what time Monday do you fly?
19:12:19 <autrijus> not sure, the sponsors are working on that
19:12:20 <exe> Cale I want to do a function like h = f . g , wouldn't the type of h be Integer -> Integer -> Integer?
19:12:24 <JohnMeacham> musasabi: anyone know how much faster IntSet and IntMap are than Set and Map? I don't want to use those unless it is a really substantial benefit.
19:12:26 <dons> (trying to work out if there's time to give a school talk on Monday)
19:12:30 <Cale> exe: no
19:12:31 <autrijus> that'd rock
19:12:49 <dons> yeah, it's usual for visitors to give a talk, and I'm sure there'd be lots of interest
19:12:52 <autrijus> dons: ok, I'll let you know when I know :)
19:12:52 <Cale> f :: Integer -> Integer, g :: Integer -> (Integer -> Integer)
19:13:02 <autrijus> dons: yeah, I'd be happy to
19:13:11 <dons> if you can talk in the morning, and leave later in the afternoon, then that would fit in nicely
19:13:11 <musasabi> JohnMeacham: quite a lot faster in some scenarios, but depends heavily on the benchmark.
19:13:17 <autrijus> yup
19:13:28 <exe> Cale, the only way to define h would be like h x y = f ( g x y )?
19:13:40 <Cale> yep
19:13:48 <musasabi> at least for IntMap (I haven't tested the set variants much).
19:13:53 <Cale> @pl \x y -> f (g x y)
19:13:54 <lambdabot> (f .) . g
19:14:00 <Cale> or you could use that
19:14:08 <exe> Because I tried h = f.g, h x = f . (g x) and h x y = (f . g) x y and I didn't have success
19:14:23 <exe> Thank you so much.
19:15:18 <exe> How does that work?
19:15:20 <exe> The last one
19:15:54 <Cale> (f .) is really \k -> f . k
19:16:12 <Cale> (\k -> f . k) . g
19:16:53 <Cale> = \x -> (\k -> f . k) (g x)
19:18:00 <Cale> = \x -> f . (g x)
19:18:27 <Cale> hmm...
19:18:56 <Cale> yeah
19:19:02 <exe> I didn't get it, but I think I will get it later.
19:19:07 <exe> Thank you.
19:19:17 <Cale> = \x -> \y -> f (g x y)
19:19:30 <Cale> unwrapping the definition of composition
19:19:32 <Cale> it's odd
19:19:40 <Cale> and you probably shouldn't use that form
19:19:46 <Cale> but @pl will give things like that to you
19:20:04 <exe> I don't know what \ means
19:20:52 <Cale> lambda
19:21:02 <Cale> it makes a function
19:21:07 <Cale> @eval (\x -> x + 1) 5
19:21:16 <lambdabot> 6
19:21:31 <Cale> @eval map (\x -> x + 1) [1..5]
19:21:33 <lambdabot> [2,3,4,5,6]
19:21:38 <exe> Ohhh, I see
19:21:41 <Cale> @eval map (\x -> x * 2) [1..5]
19:21:43 <lambdabot> [2,4,6,8,10]
19:22:18 <Cale> @eval map (* 2) [1..5]
19:22:21 <lambdabot> [2,4,6,8,10]
19:28:04 <JohnMeacham> shaved another few percent making the same change somewhere else...
19:28:47 <JohnMeacham> also replacing Map.fromAscList . filter f . Map.toAscList with Map.filter f helps a lot (but not as dramatic) too.
19:30:51 <JohnMeacham> applySubst went from 20.7% of runtime to 2.3% unfriggenbelievable.
19:31:29 <sethk> that's amazing
19:31:45 <sethk> JohnMeacham, I wasn't here; what's the main change you made?  (I just got back)
19:34:27 <JohnMeacham> I just sent a mail to libraries@haskell.org but it was changing  Map.fromAscList . map f . Map.toAscList  to Map.map f
19:35:21 <sethk> you eliminated two calls, but didn't change the amount of real work much I guess.
19:35:37 <JohnMeacham> they are both O(n) so "in theory" are the same speed.
19:35:37 <sethk> hmm., you did save real work
19:35:47 <autrijus> dons: unfortunately it was a noon plane
19:35:52 <sethk> as someone said before, a big O(n)
19:35:53 <autrijus> dons: fortunately I rescheded it
19:36:07 <autrijus> dons: so I'll stay at nights of: [11, 12, 13]
19:36:16 <autrijus> flying away at 14th. that should be time plenty
19:36:59 <skew> JohnMeacham: are you using sets and maps of integers already (re IntMap)?
19:37:01 <sethk> JohnMeacham, O(n) is the upper bound, right?  What about the average running time.  Still the same order of magnitude, but I wonder if the calculation would reflect reality any better.
19:37:08 <dons> autrijus, excellent!
19:37:18 <autrijus> now I sleep. *wave* :)
19:37:22 <dons> ciao!
19:38:32 <JohnMeacham> sethk: no, I used to, but it was anoying to switch back and forth... I might switch back to the Int versions in inner loops though if it proves worth it.
19:39:13 <dons> StevenG, hi! doing some Haskell hacking?
19:39:16 <musasabi> I wonder whether it is possible to select an implementation automagically.
19:39:45 <skew> JohnMeacham: are you using Set Int now?
19:39:57 <StevenG> dons, what is haskell hacking exactly?
19:40:03 <skew> or did you have to modify the code to change the index type?
19:40:25 <dons> StevenG, general Haskell coding, I presume :)
19:40:37 <dons> it's always good to see more .au people here :)
19:40:39 <JohnMeacham> skew: in some places. but it is more like Set of a newtype of Int, so it would require some anoying un
19:40:52 <JohnMeacham> newtyping and renewtyping to use IntSet directly.
19:41:26 <musasabi> class Ord k => MapImpl k impl, and then have "Int IntMap" and "a Map" instances (with per-instance functional dependencies and TypeEq from Oleg's stuff)
19:41:32 <skew> ok, I'm thinking of a few ways to make it easier to switch out
19:42:56 <skew> but I don't have anything really nice
19:43:52 <JohnMeacham> yeah. I still need to do some tests to see if IntSets and IntMaps are worth it. of course, an interface to judy.sf.net would be ideal :)
19:44:14 <skew> probably the most evil is to put in specialize rules like Set.empty :: Set Int --> unsafeCoerce# IntSet.empty :: Set Int
19:44:23 <dons> oh, that's bad skew
19:44:31 <Cale> haha
19:44:45 <dons> type unsafety *and* specialise pragmas. doubleplus ungood
19:45:15 <skew> hmm, not so good if any of your code is polymorphic in the index of the map
19:46:17 <StevenG> Anyone in here ever tried to create a makeFile program, in haskell?
19:46:20 <skew> another is to make a module that exports a synonmy type Set a = IntSet and all the IntSet functions
19:47:04 <dons> StevenG, a Haskell program that behaves like make?
19:47:05 <JohnMeacham> skew: well the real solution is http://research.microsoft.com/Users/simonpj/papers/assoc%2Dtypes/
19:47:06 <skew> StevenG: is that a Haskell program that writes a Makefile, a program for making some file, or a haskell program that acts like make (= Cabal)
19:47:13 <skew> yes
19:48:03 <skew> I am devising hacks for you to test the performance with minimal effort
19:48:20 <skew> how is performance of the generated code doing?
19:49:51 <Cale> JohnMeacham: In the associated types paper he mentions that no language would want both associated types and functional dependencies, but I'm not so sure :)
19:52:41 <JohnMeacham> I didn't think it said that, they solve many of the same problems, but I don't think either subsumes the other.
19:53:24 <Cale> "There is clearly a big overlap between functional dependencies and associated type synonyms, and no language would want both."
19:54:28 <sethk> don't you guys know that every time you paste a URL to a paper, I lose two hours of my life?    :)
19:54:35 <JohnMeacham> Hmm.. will have to go reread it.
19:54:54 <JohnMeacham> all the time I spend not reading papers is wasted...
19:55:21 <sethk> I definitely have to read it, because based on what I know about type synonyms that doesn't make sense to me.
19:55:39 <sethk> a synonym is just that, I thought, more or less a readability thing
19:58:26 <Cale> sethk: this is something different
19:58:34 <Cale> involving type system magic :)
19:58:48 <sethk> Cale, ok, not the type statement at the haskell language level then
19:59:09 <sethk> Cale, that's good, because at least it means that I didn't totally misunderstand the type I was thinking about
19:59:14 <Cale> It basically give you type synonyms which instances of a class will define what they correspond to.
20:00:17 <Cale> class Collects c where
20:00:21 <Cale>    type Elem c
20:00:25 <Cale>    empty :: c
20:00:34 <Cale>    insert :: Elem c -> c -> c
20:00:39 <Cale>   ...
20:01:07 <Cale> then you could do something like:
20:01:27 <Cale> instance Eq e => Collects [e] where type Elem [e] = e ...
20:01:42 <skew> ... type Elem e = [e]
20:02:20 <Cale> no
20:02:32 <sethk> Cale, somewhat like a c++ template?
20:02:49 <Cale> hmm...
20:03:04 <Cale> possibly
20:03:54 <skew> specifically, like how you can provide a specialized instance at certain types
20:04:44 <dons> StevenG, are you at UQ? Do they teach Haskell there now?
20:04:59 <StevenG> yeh
20:05:23 <dons> cool
20:06:02 <seafood> StevenG: Cool! I used to go there.  Who is teaching the subject nowadays?
20:06:05 <seafood> Is it Paul Bailes?
20:06:10 <seafood> Or Peter Robinson?
20:06:38 * seafood learnt Haskell in Peter Robinson's class.
20:07:39 <StevenG> ahhh
20:07:40 <StevenG> :)
20:07:46 <StevenG> how long ago were u there hehe
20:08:17 <seafood> I graduated in 2001.
20:08:23 <StevenG> ah not too long back for u hehe
20:08:26 <StevenG> what do u work as now :P
20:08:48 <seafood> PhD
20:09:22 <StevenG> wow
20:09:25 <StevenG> very nice
20:20:25 <shocker> seafood: where r u doing your phd
20:20:57 <seafood> shocker: UNSW
20:21:04 <shocker> lk
20:29:40 <dons> ramkrsna, hi! learning haskell?
20:30:22 <ramkrsna> Not exactly, haskell but gofer
20:30:29 <dons> gofer!
20:30:42 <dons> why gofer?
20:31:13 <dons> it's really an pre-1998 version of haskell, isn't it? I remember using gofer in my first year course :)
20:31:48 <dons> ramrksna, you should add your details: http://www.haskell.org/hawiki/HaskellUserLocations
20:32:02 <dons> we're missing people from the subcontinent (I'm assuming you're there :)
20:32:21 <ramkrsna> yeap very much from Sub continent
20:32:43 <stefanw> dons: when did you do your first year course??
20:32:56 <dons> '99 ;) but on a mac68k
20:32:57 <JohnMeacham> antarctica?
20:33:07 <dons> so the only haskell that worked at the time was Gofer
20:33:20 <dons> I had to write all my Num instances by hand :S
20:35:37 <dons> JohnMecaham, I think India is the usual subcontinent ;)
20:36:32 <stefanw> some Haskell hacker at antarctica would be cool, though :-)
20:37:19 <ramkrsna> I just know 3 haskell coders from India, only 2 of us hang out here
20:37:45 <dons> oh, you guys should add your latitude/longitude details then to the above wiki page then :)
20:37:56 <dons> help build the community :)
20:39:46 <dons> stefanw, I think you can get commerical boat journeys from perth now... if you have a month spare..
20:39:56 <dons> just take your laptop and ping us when you arrive :)
20:40:12 <tismith> I learnt haskell in Peter Robinson's class also :)
20:40:28 <dons> oh no, there's a UQ conspiracy!
20:43:45 <tismith> It would have been 2002 (IIRC) when I sat for Peter's class
20:44:19 <Pseudonym> One of us should do a term in Antarctica just so they can be on the map.
20:45:10 <dons> I nominate Pseudonym, since he's closest
20:45:27 <sethk> what's the url for the pastebot this channel uses?  I know I've seen it on haskell.org, but I'm not finding it at the moment.
20:45:28 <JohnMeacham> I am going to duplicate my free variables finding code, once for sets and once for maps.
20:45:37 <dons> unless I can think up some way to get research funding for FP and Antartica research. hmm.
20:45:52 <Pseudonym> Hang on, there are some in New Zealand.
20:45:59 <dons> ah yes, but they're not on the map!
20:46:07 <dons> @seen VivianMcPhail
20:46:08 <lambdabot> I haven't seen VivianMcPhail.
20:46:09 <Pseudonym> Well even more reason to use them.
20:46:20 <Pseudonym> You'd add more people to the map at the same time.  Two Birds, one Wadler.
20:46:25 <wagle> dons:  i want to see how fp works in zero-g
20:46:37 <dons> wagle, this is a very good question!
20:47:17 <dons> does referential transparency still hold -- we must find out!
20:48:45 <Pseudonym> More theorems should be tested under different geographic conditions.
20:49:05 <Pseudonym> Does the Yoneda lemma still hold underwater?
20:50:23 <dons> hehe or on a beach in Fiji? I wonder..
20:50:32 <Pseudonym> Indeed!
20:50:59 <Pseudonym> Those with smaller travel budgets could simply test if the results still hold while drunk.
20:51:15 <dons> hah!
21:09:40 <sethk> all, can you look at the hawiki HaskellIrc paste page and help me with a type question?
21:09:51 <sethk> I pasted my function at the beginning of the paste area
21:09:51 <Cale> @paste
21:09:53 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
21:10:10 <sethk> I wasn't sure whether I was supposed to delete the preceding paste, so I just pasted in front of it.
21:10:27 <palomer> heh
21:10:32 <palomer> did anyone help that stevenG fellow?
21:10:55 <Pseudonym> He's still here, you know.
21:11:41 <palomer> yeah, but did anyone help him?
21:12:16 <palomer> StevenG: it's not a good idea to mass message people
21:12:23 <palomer> (I don't know if anyone told him)
21:12:58 * Pseudonym did point him to @wiki HomeworkHelp
21:13:36 <Cale> sethk: um
21:14:22 <Cale> sethk: look at the thing and see about inferring its type yourself -- you should end up with GHC's answer
21:14:42 <Cale> you return (Right (...,...,...))
21:14:42 <sethk> Cale, yes, obviously   :)   But I (also obviously) didn't
21:14:59 <sethk> oh, sorry
21:15:04 <sethk> dumb
21:15:08 <sethk> I thought I had edited that out.
21:15:17 <sethk> sorry about that.
21:15:20 <Cale> no problem :)
21:16:09 <sethk> Cale, but then, why wasn't the return (Left (h, ep))   an error?
21:16:34 <sethk> oh, never mind
21:16:39 <sethk> not thinking at all tonight
21:16:49 <sethk> probably because I'm in the wrong hemisphere.  :)
21:16:55 <dons> ramkrsna: you're on the map! http://www.haskell.org/hawiki/HaskellUserLocations
21:16:56 <dons> :)
21:17:14 <sethk> that's the way Either works.  That's why I used it.  Have to wake up here.
21:17:20 <ramkrsna> :)
21:18:16 <dons> still no russians or anyone at all in africa, but not even half the #haskell nicks are on there yet..
21:20:32 <dons> only 1/3 of the high water mark of #haskell users is on the map (maybe that's a decent result)
21:20:58 <dons> palomer: your coords! http://www.haskell.org/hawiki/HaskellUserLocations
21:21:12 <dons> oh, and we missed exe, who's in .ar
21:21:12 <Cale> most of the people who I actually recall talking on #haskell are there
21:21:20 <dons> most of them, yes
21:21:24 <dons> so it's ok.
21:22:30 <skew> I wrote some kind of Map over multiple indices, but I'm having trouble defining the empty set. Does anybody want to help with some type hackery?
21:22:58 <sethk> Cale:  in my function, where I used does
21:23:39 <palomer> I actually live a bastion of haskellness
21:23:59 <sethk> Cale:  in my function, where I used    doesFileExist filename >>= \fileExists ->             Can that be done using   let       ........     in            or          where .......
21:24:10 <sethk> Cale, that is, I want to move the call to a preceding let
21:24:11 <Cale> It can be done using do
21:24:15 <sethk> or a subsequent where
21:24:22 <Cale> hm?
21:24:35 <sethk> Cale, ok.  When I tried that, I got "last thing must be an expression"
21:24:46 <sethk> Cale, because I can't figure out how to code that
21:24:52 <Cale> do fileExists <- doesFileExist nm
21:25:00 <Cale>    case fileExists of
21:25:00 <sethk> Cale, no, I know how to do that
21:25:11 <Cale> hmm
21:25:13 <sethk> Cale, although it seemed to barf on it but let me try again
21:25:32 <sethk> Cale, the answer may be that I can't use a monadic thing in   let    in
21:25:37 <Cale> also, case can be reduced to if
21:25:39 <sethk> Cale,   or  ............   where    .....
21:25:50 <sethk> Cale, yes, I know that also, although I couldn't convince the compiler to accept that either
21:25:53 <sethk> but one thing at a time
21:25:56 <Cale> hmm...
21:26:01 <sethk> isn't if just converted to case anyway?
21:26:09 <Cale> I don't know
21:26:17 <Cale> could be
21:27:21 <sethk> Cale, when I replace the first line with     do fileExists <- doesFileExist nm          I get the "the last statement in a 'do' construct must be an expression
21:27:26 <sethk> Cale, do I need parens somewhere?
21:27:32 <sethk> Cale, wait
21:27:40 <sethk> Cale, let me make sure my indentation is correct first
21:27:50 <Cale> indentation
21:27:51 <Cale> yeah
21:27:52 <sethk> I had case under do, that's wrong
21:28:20 <sethk> ok, that was the problem.
21:28:41 <sethk> Cale, do you prefer if/then/else for readability?
21:29:54 <Cale> yeah
21:30:26 <Cale> Usually I only use case if there's no other convenient way to do it.
21:30:54 <Cale> Well, it works well with things like Either
21:31:28 <Cale> but if you find yourself using case a lot, it's usually that you should be using a monad somewhere :)
21:32:28 <sethk> In this case I should probably be using catch instead of Either, I think
21:33:55 <Cale> you shouldn't have to explicitly form the error and return it
21:34:04 <skew> I've got a type data DB b ixs where DBNil :: DB b () ; DBCons :: (Ord a) => Index a b -> DB b as -> DB b (a,as)
21:34:16 <Cale> it's an exception which can be caught if the file doesn't exist
21:34:18 <skew> where data Index a b = Index (b -> a) (Map a b)
21:34:22 <sethk> Cale, I did that so I could control the error string
21:34:29 <Cale> ah
21:34:35 <sethk> Cale, but, yes, that's the reason for my comment about I should be using catch
21:34:43 <sethk> Cale, but it's defensible this way.  :)
21:35:25 <Cale> perhaps write a value  fileNotFoundError  and then just throw it when the file doesn't exist.
21:39:34 <sethk> Cale, yes, that would be cleaner, definitely
21:42:37 <sethk> Cale, that also gets rid of Either
21:42:51 <sethk> I can just do         else ioError (mkIOError   ..... )
21:45:46 <Speck> What's the deal with Oleg's fold transformers?
21:46:13 <Speck> I can't read Haskell well enough to figure it out.
21:47:40 <Cale> read the message it was a reply to
21:47:57 <Cale> They're about representing lists as folds
21:51:13 <Speck> oh I see
22:02:46 <sethk> Cale  hGetPos returns the abstract type that is a handle and a position.  It isn't a tuple, though.  Is there a way to put the value of hGetPosn into two values, one for the handle and one for the position?  I tried (a,b) <- hGetPosn myHandle      but as I said it isn't a tuple
22:02:51 <sethk> Cale, it's an ADT
22:03:21 <sethk> Cale, does the question make sense ?
22:04:27 <Cale> The constructor for HandlePosn is obscured
22:04:38 <sethk> yes, I saw that.
22:04:45 <sethk> does that mean you aren't allow to look inside it?
22:04:51 <Cale> right
22:04:58 <sethk> it's an implementation detail that isn't exposed
22:05:01 <sethk> ok
22:05:01 <Cale> exactly
22:05:17 <Cale> oh
22:05:26 <sethk> oh?
22:05:27 <Cale> perhaps it's not
22:05:39 <Cale> HandlePosn occurs in the documentation
22:05:54 <sethk> as data HandlePosn     but not defined
22:06:10 <sethk> whereas others like IOMode are defined
22:06:19 <Cale> do { hp <- hGetPosn myHandle; let HandlePosn a b = hp; return (a,b) }
22:06:55 <Cale> oh
22:06:55 <sethk> I had tried    a b <- hGetPosn myHandle
22:07:06 <Cale> no, I'm looking at the docs for GHC.Handle :)
22:07:21 <sethk> Cale, but, if you use IO.Handle       ghci actually uses GHC.Handle
22:07:34 <sethk> If I code System.IO.Handle
22:07:35 <Cale> right, but that's hidden
22:07:45 <sethk> and I ask ghci for the type, it says GHC.IOBase.Handle
22:08:00 <sethk> Cale, so I'm allowed to do it?  Or not?  :)
22:08:01 <Cale> right
22:08:03 <Cale> no
22:08:06 <sethk> ok,
22:08:20 <sethk> again an implementation detail that isn't guaranteed to be the same in the future
22:08:25 <sethk> not part of the interface contract
22:08:36 <Cale> right
22:08:57 <sethk> so I can only use a HandlePosn value with other System.IO methods that take a HandlePosn argument
22:09:13 <Cale> right
22:09:36 <sethk> ok.  thanks again.
22:09:44 <Cale> which basically means you can only set and get the position
22:09:52 <sethk> right
22:10:28 <sethk> essential hGetPosn extracts the position from IO.Handle
22:10:33 <sethk> essentially that is
22:10:55 <Cale> yeah, probably :)
22:11:13 <sethk> so I can't be lazy and discard the handle.  :)
22:11:33 <Cale> hSeek and hTell seem more capable in this regard
22:12:12 <sethk> the same functionality, no?  here is a handle, get me the position,  or,   here is a handle and a position, seek the handle to the position
22:12:24 <Cale> but the position is an Integer
22:12:31 <Cale> which you can examine and modify
22:12:56 <Cale> and hSeek lets you move around relative to the current location, or in an absolute sense
22:12:59 <sethk> right.  with HandlePosn I can only seek to a position that I retrieved earlier with hGetPosn
22:13:04 <Cale> right
22:13:06 <sethk> got it
22:13:26 <sethk> there may be hope for me yet
22:13:37 <sethk> I've only been writing code for 30 years, I ought to figure this stuff out sooner or later
22:13:41 <Cale> :)
22:14:19 <sethk> I was proud of myself, I knew that with the tuple the type would be   IO (a,b)  instead of (IO a, IO b)     :)
22:14:32 <Cale> :)
22:15:22 <Cale> Haskell may even be more bewildering now than when I first started learning it a couple years ago. The libraries have exploded in size. Then again, the tutorials and information available seems nicer.
22:15:28 <sethk> I changed my function to return  IO (Handle, Integer)
22:33:46 <dons> yay. the rewrite of Yi compiles, existential ui's and all :D
22:35:35 <Cale> where is it?
22:35:44 <dons> not pushed yet. coming soon
22:35:50 <Cale> :)
22:35:58 <dons> all this stuff is taking placce on the repos on scannedinavian.com, btw
22:36:02 <dons> hide, and new gtk Yi.
22:36:09 <Cale> ah
22:36:28 <Cale> It seems my copy is from http://www.cse.unsw.edu.au/~dons/yi
22:37:08 <skew> existential ui?
22:37:16 <sethk> Cale, are you asking people to try hide for development, or just for testing?
22:37:46 <Cale> me?
22:37:57 <sethk> Cale, no, sorry
22:38:01 <sethk> Cale, who?  :)
22:38:10 <sethk> Cale, I think I should definitely think about sleep
22:38:12 <Cale> hehe, dons is working on yi
22:38:26 <sethk> right, and yi is the default editor for hide, right ?
22:38:26 <Cale> I can't remember who all the hIDE people are
22:38:29 <Cale> yeah
22:38:36 <skew> widgets brooding about the impending termination of the program?
22:38:39 <sethk> ok, I'm only 90% crazy the, not 100%
22:38:51 <Cale> heh
22:39:03 <Cale> like skew here
22:39:07 <Cale> :)
22:39:07 <sieni> is yi+hide trying to be a replacement of emacs for haskell or are people going to incorporate all standard ide suckiness to hide as well?
22:39:29 <sethk> sieni, that's a rather loaded question  :)
22:39:36 <dons> emacs for haskell, yes
22:39:45 <dons> suckiness is an optional plugin
22:39:46 <sethk> sieni, as I imagine most people would define "suckiness" as "the stuff I think should be left out"
22:39:50 <dons> you'll need to download that first
22:40:00 <Cale> hehe
22:40:02 <skew> I thought we were trying to invent our own mindending ide suckiness to include
22:40:13 <dons> since it's entirely a plugin architecture, you can pick and choose how much suckiness, and what flavour of suckiness
22:40:24 <JohnMeacham> hmm... go out drinking or program some more... the eternal question.
22:40:33 <skew> like interactive fiddling with the typechecker and stuff
22:40:44 <sethk> JohnMeacham, hook up an IV and pound those keys
22:41:00 <sieni> JohnMeacham: well coding + underwear drunkenness is also a good choice
22:41:03 <dons> yes,, we already do in-the-background type checking and syntax highlighting based on ghc's lexer
22:41:13 <dons> Lemmih coded this all up with ghc-api
22:41:31 <skew> I've gotten behind the times on cool ghc stuff
22:41:58 <dons> so, for example, if you import a module that's not in scope, it gets underlined in red
22:42:09 <dons> check out the screenshots on the yi wiki and the hIDE page
22:42:11 <dons> @where hIDe
22:42:13 <lambdabot> http://www.haskell.org/hawiki/hIDE
22:42:16 <Cale> dons: awesome :)
22:42:23 <sethk> hey, if it is that smart, why doesn't it just put the qualified name in?  :)
22:42:26 <dons> and of course, if there's a type error, that gets underlined too
22:42:51 <dons> oh it could do that easily enough
22:43:04 <dons> it has access to all the modules ghc knows about
22:43:15 <dons> so picking  the cloest match wouldn't be hard
22:43:18 <sethk> I'm always yelling at the phone to stop telling me to dial 1, and just dial 1 for me, goddamnit
22:43:37 <skew> sethk: have you ever tried to use the Sprint automated phone system?
22:43:59 <sethk> skew, no, I had a sprint cell phone several years ago and now you would have to torture me to get me to use _anything_ from sprint
22:44:00 <skew> they ripped out the old touch-tone system and put in a new one based on the latest voice misrecognition technology
22:44:46 <Cale> hahaha
22:45:04 <skew> so you are supposed to yell at it to push one for you, and then it goes on and pushes star, just like you asked it to
22:45:05 <Cale> even worse
22:45:18 <Cale> haha
22:46:24 <Cale> I wouldn't have it add it automatically, but popping up a list of matches in the libraries seems sane.
22:46:39 <skew> oh, fancy autocomplete
22:46:49 <skew> I've been using the stuff in emacs
22:46:53 <Cale> (those which fulfill type requirements)
22:46:53 <sethk> Cale, yes, that would be good too.
22:47:07 <Cale> yes, fancy autocomplete would be insanely cool
22:47:14 <skew> but pick up some probabilities
22:47:17 <sethk> Cale, but if there is only one thing on the list, don't give me a one line popup
22:47:20 <skew> have you looked at dasher?
22:47:30 <sethk> no, what is dasher?
22:47:49 <Cale> sethk: sure, but don't type all over the document without any interaction at all either
22:48:02 <skew> http://www.inference.phy.cam.ac.uk/dasher
22:48:13 <Cale> maybe an underline is better in some cases, because I'll just want to import the library
22:48:34 <Cale> Oh, yeah, I've played with that :)
22:48:52 <skew> have you trained it on a big source tree?
22:48:53 <sethk> I'll have to try it.  see if it will work on my palm
22:49:26 <sethk> no palm support.  too bad.
22:49:55 <Cale> no, I've trained it on stupid things written semi randomly while playing with it when bored.
22:50:28 <skew> It's interesting to train it on a big program, and see what it picks up
22:51:05 <dons> I imagine a context sentistive ^P (a la vim)
22:51:13 <skew> what's ^P?
22:51:15 <dons> so if you're completing a type name, it searches valid types
22:51:24 <dons> autocompletion of identifiers
22:51:29 <dons> but we'd have context
22:51:35 <sethk> what eclipse does with java is what I want for haskell
22:51:37 <skew> dasher uses a 5th order PPM model or something
22:51:39 <dons> so you'd get types that match, or module names that match and so on
22:52:10 <skew> ordering the matches by probability model would help a lot
22:52:32 <skew> based on the size of the different boxes when I was playing with the dasher trained on our source
22:52:34 <dons> adept, you should add your details :) http://www.haskell.org/hawiki/HaskellUserLocations
22:55:45 <mflux> dons, I've really missed the tuareg's (emacs mode for ocaml) capability to retrieve type information (generated by the compiler) about the item under the cursor
22:56:09 <dons> ah, interesting reference. cheerrs. maybe i should check out what it does
22:56:20 <dons> but yes, this is definitely where we're headed
22:56:27 <dons> types for the masses
22:56:33 <mflux> (it can retrieve type for anything, float_of_int (4 + 3) +. 4.0 could return 'int -> float', 'int', 'float' depending where the cursor is)
22:57:02 <dons> mflux, you should add your details to the wiki map page too :) (another member of the .fi conspiracy..)
22:57:09 <mflux> obviously more useful in more complex scenarios ;)
22:57:28 <dons> yeah
22:58:21 <dons> i have a little sed script that inserts top level types, so i'd like at least that behaviour
22:58:26 <mflux> maybe sometime, it doesn't yet have a section for these kinds of little thing ;)
22:58:52 <dons> ?
22:59:41 <mflux> the hawiki page seems to be mostly focused on higher level concepts
23:00:01 <dons> ah, I think you misunderstand: i meant http://www.haskell.org/hawiki/HaskellUserLocations :D
23:00:20 <mflux> oh, that
23:00:27 <dons> hence ".fi conspiracy" (there's lots!)
23:00:34 <sethk> mflux, that's a neat feature, but as a practical matter I would be extremely happy to see potential matches from the libraries
23:01:00 <dons> on the Design page is a list of plugins we'd like
23:01:05 <dons> you can add stuff this like to that list
23:01:18 <dons> grep for "Design" on the top level page
23:01:34 <dons> the Design page is where all the low-level details will be sorted out
23:02:43 <mflux> I'll write my details to the user locations -page when I've actually written something as complex in Haskell as I've written in ie. ocaml or c++ ;)
23:03:05 <dons> hehe, ok :) it's really more about #haskell people though, not "haskell people" :)
23:03:25 * dons disappears to teach Makefile hacking
23:19:21 <skew> Is there any good reason there is no Eq Chan?
23:19:29 <JohnMeacham> I was foolish in my earlier decisions in jhc. I am glad haskell is very forgiving of foolishness.
23:25:12 <Speck> dons: the hIDE/Design page, it is written "I don't expect that plugability would extend to the basic graphical toolkit that is used." Why not?
23:26:21 <Speck> If plugins are cabal packages anyway, couldn't hIDE plugin interfaces for gtk or wxwindows or fruit (!)
23:29:18 <sethk> Speck, there are just too many details associated with the available gui toolkits.
23:29:40 <sethk> Speck, take a bit of code and look at implementing it in wxhaskell.  You'll be convinced within a few minutes.
23:29:54 <sethk> if you stuck only to portable things, your performance and functionality would be sub-standard
23:30:04 <sethk> well, unacceptable is a better way to put it.
23:52:47 <Speck> sethk: I'm thinking some kind of abstract interface to UI which can have their implementations in specific toolkits using plugins
23:53:28 <sethk> Speck, I know, but I don't see it.  It's been tried many many times in many contexts
23:53:42 <sethk> Speck, usually the conclusion is the same, that you can't get where you need to go that way
23:53:52 <Speck> perhaps
23:54:00 <sethk> Speck, I'm not saying not to try
23:54:07 <Speck> of course
23:54:15 <sethk> Speck, but it is extremely non-trivial
23:54:22 <Speck> I agree
23:54:28 <Speck> anyway. I should shove off to bed
23:54:30 <Speck> night all
23:54:33 <sethk> 'nith5
23:54:35 <sethk> 'night
23:54:39 <sethk> can't even type night tonight
23:54:41 <boegel> @yo
23:54:42 <lambdabot> I believe in wash fulfillment.
23:55:27 <Cale> @yow
23:55:28 <lambdabot> Did I say I was a sardine?  Or a bus???
23:55:35 <Cale> @yow
23:55:36 <lambdabot> I'm definitely not in Omaha!
23:56:24 <sethk> @yow
23:56:25 <lambdabot> Today, THREE WINOS from DETROIT sold me a framed photo of TAB
23:56:25 <lambdabot> HUNTER
23:56:25 <lambdabot> before his MAKEOVER!
23:56:34 <sethk> hmm ???
23:56:42 <sethk> that's so old even I don't get it.
