00:05:21 * boegel boings
00:12:26 <gour> ot: anyone knows some channel to ask about video-projectors?
00:12:43 <Korollary> #electronics maybe ?
00:13:29 <gour> hmm, could be...i'm interested regarding their usage with linux
00:13:46 <basti_> theres issues with that?
00:14:05 <Leimy> has anyone got a copy of http://www.haskell.org/HOpenGL/examples/Planet.hs that works with a current GHC?
00:14:35 <gour> basti_: well i'm not sure whether i can use their remotes as 'wireless-mouse' to control beamer-made presentation
00:14:46 <basti_> mmmk
00:15:28 <gour> basti_: usually in their manual they just state about M$ & Mac comp.
00:15:51 <basti_> i see what you mean
00:17:25 <Pistahh> gour: does that "mouse" have an usb connection?
00:17:58 <boegel> Leimy: I have something simalar, a rotating 3D cube
00:18:39 <gour> Pistahh: well, video-projector & laptop are connecting via usb cable
00:19:26 <Leimy> boegel: that'd be cool to see too :)
00:20:15 <boegel> Leimy: lemme see if I can find it
00:20:39 <Leimy> cool
00:20:47 <boegel> I know I have it somewhere
00:20:52 <Korollary> Leimy: ot, do you live in Seattle ?
00:20:52 <boegel> or atleast, had it :s
00:21:08 <Leimy> I live north of seattle
00:21:21 <Leimy> why do you ask? :)
00:21:32 <boegel> Leimy: is it ok if I throw it online ?
00:21:32 <Korollary> Leimy: I am moving to Seattle in a few weeks.
00:21:51 <Leimy> boegel: my DCC sucks anyway :)
00:21:59 <Leimy> Korollary: cool
00:21:59 <boegel> Leimy: I could mail it...
00:22:57 <Leimy> boegel: can you slap it on a website? :)
00:22:58 <C-Keen> moin.
00:23:28 <boegel> Leimy: http://elis.ugent.be/~kehoste/RotatingCube.lhs
00:23:35 <boegel> hey C-Keen
00:23:51 <C-Keen> hi boegel
00:24:28 <boegel> Leimy: I haven't tested it with the latest release of ghc, but I adapted an old version of it for 6.4 or something
00:24:31 <C-Keen> boegel: why do you write literate code with literally no comments?
00:24:57 <Leimy> boegel: hmmm doesn't link for me :)
00:25:16 <Leimy> do I need some magic for GL? :)
00:25:22 <boegel> Leimy: it probably something small
00:25:33 <boegel> Leimy: you should have HOpenGL installed, of course
00:25:43 <Leimy> oh that's installed :)
00:25:44 <boegel> C-Keen: for future comments ? no idea really ;)
00:25:50 <boegel> Leimy: which OS ?
00:25:54 <Leimy> http://www.cs.kent.ac.uk/people/staff/cr3/FunWorlds/  <-- that works for me :)
00:25:59 <Leimy> boegel: Mac OS X
00:26:20 <boegel> Leimy: what's the error message ?
00:26:30 <Leimy> ah I need -package OpenGL
00:26:31 <boegel> brb
00:26:35 <Leimy> and -package GLUT
00:26:37 <Leimy> duh
00:32:27 <boegel> heh :)
00:35:37 <alar> can I throw in entire program to lambdabot for execution?
00:38:49 <boegel> alar: why would you ?
00:39:01 <boegel> you can fiddle around with her in pm
00:39:11 <boegel> btu be gentle :P
00:39:42 * Leimy goes to bed
00:40:31 <alar> boegel: I mean is it possible when program text contains type & class declarations?
00:40:54 <alar> not just a chained let
00:42:37 <boegel> alar: I'm not sure, you should ask dons
00:42:48 <boegel> I suspect not, but I'm not sure
00:43:04 <alar> @seen dons
00:43:05 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 7 hours, 10
00:43:05 <lambdabot> minutes and 50 seconds ago.
00:43:52 --- topic: set to '#haskell-blah' by Blicero
00:45:40 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051004"]' by alar
00:45:47 <boegel> asshole
00:46:02 <alar> what?
00:46:29 <boegel> not you, Blicero
00:47:16 <alar> @karma- Blicero
00:47:16 <lambdabot> Blicero's karma lowered to -1.
00:47:17 <alar> :)
00:49:20 <boegel> hehe
01:34:40 <tessier> Developing an IDE for haskell? Ugh. Yes, let's do reinvent the wheel.
01:35:15 <Trinsic> does anyone think haskell will enter the programming field like java did?
01:35:28 <Heffalump> tessier: you don't have to use it
01:35:39 <Heffalump> Trinsic: I personally doubt it.
01:35:49 <tessier> You mean with a whole bunch of hype about cool applets only to fizzle in a designed by committee mess?
01:35:53 <Heffalump> but it is taking off quite fast right now, relatively speaking
01:36:09 <tessier> Heffalump: Oh, thank god. I had thoughts of jack-booted haskellites kicking in my door and tying me to a machine running the ide.
01:36:58 <Trinsic> the only reason why applets aren't prolific is because java is not free.
01:37:29 <Trinsic> if someone invented an applet interface to a browser (say firefox) for free, i think that would be something.
01:40:05 <Trinsic> j #ai
01:42:56 <basti_> Trinsic: i think the influence of haskell will more be on a meta-level. For example, I see
01:43:10 <basti_> I think we will see haskell-style static typing in one of the next "hype" languages
01:49:05 <Trinsic> http://www.theglobeandmail.com/servlet/ArticleNews/TPStory/LAC/20051005/RGOOGLE04/TPBusiness/TopStories
01:49:14 <Trinsic> i guess thats where we are headed.
01:50:01 <tessier> Actually, I can see real advantages to an IDE written for a specific language in that language.
01:50:09 <tessier> That is one of the things I really like about emacs.
01:50:17 <tessier> Although I'm not really an emacs user.
01:50:38 <basti_> I don't believe in the relevance of IDE's
01:50:48 <trez> :r
01:50:50 <trez> fettah :D
01:51:08 <basti_> i'm programming nearly everything in emacs, and I never thought "wow this is stupid i reall NEED another IDE"
01:52:23 <ulfdoz> You don't need one, but probably you want one.
01:53:05 <basti_> maybe yes.
01:53:43 <basti_> but it doesnt make the point of a language.
01:54:18 <basti_> i find the additional comfort of haskell much better than the additional comfort of the VC++ IDE
01:54:23 <ulfdoz> No, that isn't even task of an IDE.
01:55:11 <ProfTeggy> Morning all
02:01:39 <dcoutts> basti_, the point is to allow you to do the things you already do, but faster, eg finding the definition of a function, jumping to the documentation, matching up ghc error messages with the text in your editor. It's not for eye candy.
02:01:54 <basti_> yep
02:02:08 <basti_> that would be the point, should it work faster than I'm able to do it usually.
02:02:17 <dcoutts> and so you can extend it without knowing elisp :-)
02:02:38 <basti_> as life is, i currently spend way more time thinking about what i should code, less time looking up things, and even less time typing
02:02:52 <Trinsic> xml would be alot better than elisp imho.
02:02:58 <dcoutts> I find myself referencing documentation quite a bit
02:03:16 <dcoutts> Haskell would be a lot better then xml or elisp imho :-)
02:03:39 <aleator> I would take any lisp over any xml any day :)
02:03:39 <basti_> yes, but i don't think life would be easier if the docs would be built into your editor.
02:03:43 <Trinsic> for beginners it would be impossible.
02:03:59 <basti_> sure, would be nice.
02:04:16 <Trinsic> configuraiton and shit should be done in a very neatural language. xml is perfect for it.
02:04:25 <Trinsic> neutral
02:04:32 <basti_> Trinsic: xml is a solution for a problem that nobody has.
02:04:40 * basti_ ducks and runs
02:04:46 <ProfTeggy> basti *yawn*
02:04:57 <dcoutts> Trinsic, well ordinary sorts of config should be doable from the GUI. Other extensions should be implemented as plugins using Haskell.
02:05:14 <Cale> What does "neutral" mean?
02:05:56 <Cale> Not possessing an evaluation mechanism?
02:05:58 <dcoutts> basti_, well the docs arn't built in as such, it just picks up the docs you'd use already either locally or on the web.
02:06:34 <basti_> dcoutts: notice that i'm not stopping anyone. I'm happy if the IDE gets better. I just fail to see the often-claimed vital importance.
02:06:35 * dcoutts implemented the first version of the hIDE html viewer component yesterday
02:06:56 <dcoutts> basti_, no, there's no vital importance, otherwise we'd have had one by now
02:07:05 <basti_> yup
02:07:09 <dcoutts> but it is something that people ask for
02:07:24 <dcoutts> and if it's good it should help our programming productivity
02:07:28 <basti_> indentation with a brain is what i really yearn for.
02:07:30 <Cale> I also think that an IDE is not of vital importance, but I think that there are some cool things that could be done with a Haskell-specific editor.
02:07:41 <basti_> (i.E. different than haskell-mode in emacs)
02:07:43 <Cale> so I like the idea :)
02:08:06 <dcoutts> as well as being a marketing benefit, some people just like IDEs, as if it's a mark of a 'serious' language. :-)
02:08:09 <Cale> yes, with little dotted lines showing where the offside rule applies :)
02:08:13 <dcoutts> don't forget the marketing :-)
02:08:21 <basti_> heh
02:08:29 <basti_> 'k :P
02:08:46 <dcoutts> basti_, but it's ok, you're not the target of that propaganda :-)
02:08:54 <Cale> (and Haskell-specific folding :)
02:09:12 <basti_> I'll just happily hack together yi-emacs k?
02:09:25 <dcoutts> basti_, is that the emacs mode for Yi ?
02:09:30 <basti_> yes
02:09:33 <dcoutts> excelent
02:09:53 <basti_> I've made quite a progress (although something broke recently), and dons implemented another emacs mode which is almost orthogonal
02:10:00 <dcoutts> we need good vim & emacs emulation otherwise you lot will never switch :-)
02:10:15 <Cale> So what are the real editing features that will go into hIDE which would be awkward to do in Yi alone?
02:10:34 <basti_> I should hack both together then, and it'd be 90% complete
02:10:43 <dcoutts> Cale, jump to documentation
02:11:02 <dcoutts> Cale, code browsing by module heirarchy
02:11:15 <Cale> good stuff :)
02:11:22 <dcoutts> or browing by the module dependency graph
02:11:26 <Cale> With nicely rendered module graphs?
02:11:38 <dcoutts> Cale, using cairo :-)
02:11:45 <Cale> :)
02:11:59 <dcoutts> and graphviz for the graph layout
02:12:37 <Cale> It would also be neat to zoom in on those modules and see a graph of dependencies for all the definitions made inside a module.
02:13:07 <dcoutts> Cale, I'll let you implement that :-)
02:13:19 <Cale> which would be useful when breaking up a large module into pieces :)
02:13:25 <dons> I imagine a lot of tools people currently write as standalone little things would instead target hIDE. at least I hope so :)
02:13:29 <dcoutts> but most edior features should work with Yi alone, it's only if they need menus/toolbars, other tool pannels etc that they might want to use hIDE features
02:13:34 <dons> HaRe for one..
02:14:58 <dcoutts> eg syntax highliting & smart indenting should work in a stand-alone Yi, but things which rely on the concept of a current project will probably rely on hIDE
02:15:10 <dons> yep.
02:15:21 <dcoutts> like compiling the code, or even doing the typechecking
02:15:39 <dons> and anyway, by closing windows you should be able to make hIDE look like gvim or xemacs, I hope.
02:15:54 <dons> disabling menus and the like
02:16:01 <dcoutts> just hide the browser && tool pannels
02:16:02 <Cale> I agree with that :)
02:16:52 <Cale> Many IDEs eat up screen real estate with sidebars that are only used a small fraction of the time you're using the program.
02:17:00 <dcoutts> yeah
02:17:44 <dcoutts> mind you, most people code to 80 or 100 columns which means on modern large screens there is actually quite a bit of space at the sides
02:18:02 * dcoutts is using a 1600x1200 screen
02:18:07 <dcoutts> but perhaps that's just me :-)
02:18:09 <Cale> yeah, but I don't like having to maximize windows :)
02:18:18 <aleator> Hmm.. How about OS X like exposé? something that quickly pops out a certain view?
02:18:27 <dons> dcoutts, you should use ion ;)
02:18:38 <dons> let the window manager handle that space for you
02:18:39 <dcoutts> dons, that's the full screen wm ?
02:18:50 <dons> the editor-like wm, by tuomov
02:18:55 <dcoutts> oh
02:19:01 <dons> so yeah, it always handles the full screen
02:19:27 <dons> it's really great, and worth trying
02:19:55 * Cale is currently running enlightenment.
02:20:11 <Cale> I liked pwm though. :)
02:20:23 * dcoutts uses gnome default wm
02:20:26 <Cale> used it on my school accounts
02:20:34 <Cale> metacity
02:20:44 <dons> I notice Lemmih also uses ion
02:21:04 <dcoutts> dons, yeah that's why all his screenshots were so big :-)
02:21:08 <Cale> I think I saw that the new ion can emulate pwm, which would be nice :)
02:21:19 <dons> hehe. maybe he doesn't bother splitting the screen.
02:21:29 <Cale> but it's hard to give up the snapshotting pager and iconbox :)
02:21:33 <dons> it's really good on a laptop. no mouse, but no need for one either. and always use the full screen
02:22:20 <dons> it's annoying watching presentations given on non-ion wms, where the speakers wastes time lining up windows so they're all visible
02:22:27 <dons> ion does that all for you
02:23:12 <dcoutts> dons, so have you had a chance to look at the interface for stuffing Yi into hIDE as the default editor?
02:23:18 <Cale> my friend really liked larswm
02:23:45 <dons> not yet, teaching today. hopefully tomorrow.
02:23:50 <dcoutts> dons, ok
02:24:07 * dcoutts is teaching too soon
02:24:26 <dcoutts> I'm designing a 1st year Haskell practical
02:24:46 <dons> too soon, or to soon? ;)
02:24:56 <dons> oh, too soon.
02:25:04 <dcoutts> heh "too, soon"
02:25:05 <dons> too, soon.
02:25:13 <Cale> heh
02:25:14 <basti_> soon ming pang keng?
02:25:15 <dcoutts> it's using the L-System stuff that xerox & boegel & Cale cam up with
02:25:23 <dons> ah, nice :)
02:25:28 <Cale> cool :)
02:25:33 <boegel> dcoutts: hey, shouldn't you ask permission :P
02:25:44 <Cale> I should work on nymphaea some more
02:25:45 <dons> free the source!
02:25:54 <dcoutts> boegel, it's ok I'm not actually using any of your code :-)
02:25:56 <boegel> it is free, I'm just joking :)
02:26:01 <Cale> Still haven't made the menus do anything at all :)
02:26:09 <boegel> dcoutts: show them my raytracer too ;)
02:26:37 <dcoutts> boegel, heh, yeah I might do, just for the coolness factor
02:27:03 <dcoutts> I'm going to get the students to write the code for running the L-System
02:27:35 <dcoutts> and also for interpeting the L-System, transforming it into a sequence of lines (in absolute coordinates)
02:27:56 <dcoutts> so they have to do all the sin/cos stuff
02:28:15 <kolmodin> dcoutts: I have built hIDE now
02:28:26 <dcoutts> but that's ok because they just finnished A-levels where they were tauch trig and so they havn't forgotten it like me :-)
02:28:31 <dcoutts> kolmodin, oh great
02:28:33 <kolmodin> but it gives me this:
02:28:34 <kolmodin> hIDE: unknown exception
02:28:42 <kolmodin> any clue?
02:28:44 <dcoutts> kolmodin, edit this file...
02:29:12 <dcoutts> plugins/haskellSense/src/Hide/CommonSense/Haskell.hs line 28
02:29:22 <dcoutts> set the apprpriate path on you system
02:29:22 <kolmodin> It has been quite a bumpy road to get hIDE to compile :)
02:29:26 <kolmodin> ok, great
02:29:32 <dcoutts> probably /usr/lib/ghc-6.4.1
02:29:52 <dcoutts> kolmodin, heh yes, it's not nicely packaged yet
02:30:07 <dcoutts> that stops too many people reporting bugs too soon :-)
02:30:15 <kolmodin> haha :D
02:30:18 <dons> hehe
02:30:25 <dons> EXCELLENT point!
02:30:43 <dcoutts> when we need more testers we'll make it easier to test :-)
02:31:15 <dcoutts> for the moment we need more time and more core contributers
02:31:22 <kolmodin> yay! this is a glorious day!
02:31:41 <dcoutts> speaking of which, kolmodin...
02:32:25 * dcoutts should not pester kolmodin or davve to contribute to hIDE until they finnish their exam(s)
02:33:12 <kolmodin> :)
02:34:45 <kolmodin> if I know myself as well as I think I do; I will probably feel like I have all the time in the world for hIDE as soon as the exams are close enough
02:35:11 <kolmodin> that's when I must not be tempted :)
02:35:13 <dons> great :)
02:35:32 <Cale> dcoutts: heh, most of what is important about trig is encoded in this diagram anyway: http://en.wikipedia.org/wiki/Image:Circle-trig6.png
02:35:34 <dons> no, it's ok -- be tempted ;)
02:38:23 <kolmodin> :)
02:39:09 <kolmodin> I'll go and grab a  bite, I'll be back within a couple of hours
03:04:26 <Trinsic> hello icb.
03:06:58 <rep> good morning desu!
04:37:51 <b0gg1e> hello #haskell
04:37:57 <dcoutts> @arr
04:37:58 <lambdabot> Drink up, me hearties
04:46:26 <dblhelix> wtf!?? "ld: archive: /usr/local/lib/haskell-src-exts-0.2/libHShaskell-src-exts-0.2.a has no table of contents, add one with ranlib(1) (can't load from it)"
04:46:36 <Trinsic> @arr
04:46:37 <lambdabot> I heard andersca is a pirate
04:48:36 <SamB> @ghc
04:48:37 <lambdabot>  Illegal polymorphic type
04:49:02 <dblhelix> okay, what's going on here?
04:49:12 <dblhelix> "ld: /usr/local/lib/ghc-6.4.1/libHSrts.a(GCCompact.o) r_type field of relocation entry 803 in section (__TEXT,__text) invalid"
04:50:14 <SamB> dblhelix: what are you trying to do?
04:50:27 <SamB> you seem to be running into rather a lot of trouble!
04:50:34 <dblhelix> SamB: building haskell-src-exts
04:50:59 <dblhelix> SamB: the trhsx part, to be exact
04:51:02 <SamB> dblhelix: is that ALL?
04:51:19 <dblhelix> SamB: that's all ;)
04:51:52 <SamB> it looks like binutils isn't getting along with your GHC installation
04:52:41 <SamB> did you by any chance recently upgrade/downgrade binutils?
04:53:15 <dblhelix> SamB: nope
04:54:50 <SamB> dblhelix: and it worked before?
04:55:15 <dblhelix> well, I never installed haskell-src-exts before, but ghc used to work fine...
04:55:27 <Igloo> What arch/OS is this?
04:55:37 <dblhelix> Mac OS (Tiger)
04:55:43 <Igloo> And is it a cabal package?
04:55:48 <dblhelix> yep
04:55:53 <Igloo> Do any cabal libraries work?
04:56:12 <dblhelix> not sure... have not much to test, right now
04:56:21 <dblhelix> other compilations go fine, though
04:56:33 <SamB> Igloo: what about that relocation error in libHSrts.a?
04:56:44 <dblhelix> so I suspect it *is* cabal related
04:57:07 * Igloo suspects cabal is doing the wrong thing for libraries in general. I noticed a while ago it didn't seem to be using libtool
05:01:31 * SamB wonders why it would be using libtool
05:02:07 <dblhelix> what to do?
05:02:18 <dblhelix> the first signal something's wrong is: "ld: archive: /usr/local/lib/haskell-src-exts-0.2/libHShaskell-src-exts-0.2.a has no table of contents, add one with ranlib(1) (can't load from it)"
05:02:46 <Igloo> Because libtool knows how to make libraries portably
05:02:56 <dblhelix> I'm not too picky, but I do want to be able to load from the generated archive
05:10:16 <dblhelix> okay, it's not just cabalized stuff... I'll have to do some diggingi
05:10:20 <dblhelix> /s/digging
05:27:05 <CosmicRay> darcs get --partial http://darcs.complete.org/local-branches/shootout
05:27:20 <CosmicRay> for those of you waiting for the programming language beauty contest.
05:27:44 <Igloo> How do you plan on rating things OOI?
05:27:54 <CosmicRay> I don't really know.
05:28:13 <CosmicRay> for the moment, I'll keep the shootout metrics: lines of code, speed, and memory use.
05:28:21 <CosmicRay> probably make loc the default view.
05:46:12 <Lunar^> CosmicRay: I've finished a package for hscurses... problem is: it needs gch 6.4.1 and Cabal 1.1.3
05:47:56 <CosmicRay> Lunar^: that's annoying.
05:48:02 <CosmicRay> why can't it work with 6.4 and the cabal in it?
05:49:13 <Lunar^> CosmicRay: making it work on 6.4 would be useless, as the curses on powerpc bug will render the package useless
05:50:02 <Lunar^> CosmicRay: (I was actually waiting for GHC 6.4.1 to be released to start packaging again after being stuck on that issue)=
05:50:40 <CosmicRay> what curses on ppc bug?
05:50:51 <CosmicRay> Lunar^: the package could work everywhere else anyway, no?
05:50:53 <CosmicRay> and what about hugs?
05:51:28 <Lunar^> CosmicRay: and the last Cabal is needed because of a strange bug with hsc2hs+cpphs that truncates source files when using haddock
05:51:43 <CosmicRay> ugh.
05:51:53 <CosmicRay> couldn't you just include the cabal you need with the package?
05:52:30 <Lunar^> CosmicRay: packing the whole Distribution.* with the package?
05:52:32 <malcolm> Lunar^: There was a bug in cpphs <=0.8 compiled with ghc >6.4
05:52:52 <Lunar^> malcolm: oh?
05:53:07 <CosmicRay> Lunar^: yup
05:53:09 <malcolm> Lunar^: cpphs-0.9 has fixed it.  It was to do with ghc flushing open handles when the program exited
05:53:25 <Lunar^> CosmicRay: but 6.4.1 should enter the archive soon, isn't it?
05:53:27 <CosmicRay> Lunar^: that or kick syntaxninja to get off his ass and upload the newer cabal to unstable ;-)
05:53:34 <CosmicRay> Lunar^: I doubt it.
05:53:36 <malcolm> Lunar^: basically, ghc used to flush, but from 6.4 it does not.
05:53:46 <CosmicRay> Lunar^: igloo has said he won't upload it until gmp hits testing.
05:53:51 <CosmicRay> there are still a number of things blocking that.
05:53:52 <Lunar^> malcolm: uh... that's exactly how I felt about this bug
05:54:57 <Lunar^> CosmicRay: maybe the packages could stay on haskell-unsafe until 6.4.1 enters unstable?
05:55:22 <Lunar^> Igloo: What about getting a newer cpphs in the archive? :)
05:55:29 <Igloo> I think the current cpphs is "compiled" by hugs on all arches, so should work
05:58:06 <JohnMeacham> yawn.
05:59:42 <JohnMeacham> Yeah, that was a big misfeature is ghc 6.4. (not flushing handles on exit)
05:59:59 <JohnMeacham> I thought it switched back? it definitly should.
06:00:02 <CosmicRay> JohnMeacham: ouch.
06:00:06 <CosmicRay> I haven't noticed this.
06:00:49 <Igloo> It's just an instance of it being impossible to guarantee finalisers run, isn't it?
06:00:59 <malcolm> JohnMeacham: I think the handle-flushing was accomplished by finalisers, but ghc no longer guarantees to run finalisers.
06:00:59 <JohnMeacham> Well, it doesn't hit it unless you quit without hClosing a file.
06:01:21 <JohnMeacham> no, but it should have special case code to flush them. like an 'atexit' handler.
06:02:28 <JohnMeacham> it is worst when you hit bottom, and you can't tell where because your output isn't flushed.
06:02:28 <Lunar^> malcolm: oh.. btw, cpphs-0.7 stumbles when encoutering #def (hsc2hs directive) that where left untouched by hs2hs because they were between {- comments -}
06:03:07 <Lunar^> malcolm: is this fixed in a newer version?
06:03:07 <JohnMeacham> speaking of which, there should be a library routine to register the equivalant of 'atexit' handlers...
06:03:16 <malcolm> Lunar^: can you send me a test case?
06:03:22 <Lunar^> malcolm: for sure :)
06:03:23 <CosmicRay> JohnMeacham: I thought there was, let me check.
06:04:26 <CosmicRay> guess not.
06:04:27 <malcolm> I'm about to release a new version (1.0) of cpphs, so it's best for me to check if there is anything anyone still thinks might be broken.
06:14:36 <Lunar^> malcolm: the test case is ready, let me try with cpphs 0.9 first
06:18:33 <malcolm> Lunar^: any luck?
06:20:15 <Lunar^> malcolm: mh.. cpphs.hs should be Cpphs.hs in the cpphs-0.9 tarball
06:20:37 <Lunar^> malcolm: and the bug is still here
06:21:06 <malcolm> Lunar^: why capitalise it?  I like being able to just say 'hmake cpphs" and there it is.
06:21:33 <Lunar^> malcolm: mail sent
06:21:48 <Lunar^> malcolm: because cpphs.hugs doesn't work otherwise
06:21:59 <Lunar^> runhugs: Error occurred
06:21:59 <Lunar^> ERROR - Can't find module "Cpphs"
06:22:38 <malcolm> Lunar^: ah, will fix the cpphs.hugs script...
06:24:30 <Lunar^> malcolm: sure :)
06:28:31 <malcolm> Lunar^: In hsc2hs, does the #def need to start at column 0?  Could it be indented further?
06:32:54 <Lunar^> malcolm: in can be
06:34:29 <malcolm> Lunar^: I think I'll change cpphs to emit a warning (rather than an error) if it doesn't recognise a cpp directive.
06:35:47 <Lunar^> malcolm: parsing Haskell comments is excluded?
06:36:34 <malcolm> Lunar^: well, your test case crashes on #def whether it is in a comment or not.
06:38:13 <Lunar^> malcolm: sure.. the problem arise because of difference between hsc2hs and cpphs though
06:39:36 <malcolm> Lunar^: cpphs is implemented as two phases - phase one does file inclusion and is line-based.  It takes no account of Haskell comments.  Phase two is macro-expansion, and does parse comments.  A # in column 0 always triggers an action in the first phase.
06:39:53 <Lunar^> malcolm: mhh ok
06:40:20 <Lunar^> I have no fixed idea... emiting warnings seems fine
06:40:35 <malcolm> Lunar^: so, with your test case, I now get two warnings to stderr, and both #def lines emitted to stdout.
06:49:19 <malcolm> Lunar^: Oh, I have just looked more closely at your test case.  You reckon the first #def already gets through cpphs with no error?  For me it does not.
06:49:39 <Lunar^> malcolm: the first #def is handled by hsc2hs
06:50:22 <Lunar^> malcolm: but the last one is left intact, because it's commented
06:50:41 <malcolm> Lunar^: Oh, I see.  So the first one is already stripped before cpphs sees it.  The fact that the second one is in a comment is irrelevant to cpphs.  The comment is only relevant to hsc2hs /not/ processing it.
06:51:03 <Lunar^> right
06:51:36 <malcolm> Lunar^: In that case, i'm happy enough that emitting a warning is the best compromise.
06:51:46 <Lunar^> fine :)
07:00:43 <malcolm> Strangely enough, Hugs gives me a runtime error in cpphs, whilst ghc and nhc98 run it just fine.
07:06:25 <poetix> dcoutts: http://codepoetics.com/hobby/c_api/client_buffer.cpp
07:06:35 <dcoutts> and the .h file?
07:06:47 <poetix> dcoutts: http://codepoetics.com/hobby/c_api/client_buffer.hpp
07:06:58 <poetix> The .h file is the same minus the "extern C" declarations
07:07:08 <dcoutts> right
07:07:17 <dcoutts> btw you don't need to have two copies
07:07:32 <dcoutts> you can just: extern "C" { #include <...> }
07:07:49 * poetix does not understand
07:07:55 <dcoutts> because C's module system is just textual substitution
07:07:58 * dcoutts sniggers
07:08:18 <dcoutts> so no need for the .hpp version
07:08:30 <dcoutts> in the .cpp you'd say:
07:08:43 <dcoutts> extern "C" {
07:08:44 <dcoutts> #include "client_buffer.hpp"
07:08:47 <dcoutts> }
07:08:59 <dcoutts> opps, "client_buffer.h" I mean
07:09:04 <xerox> Clever.
07:09:13 <poetix> Right. OK, that means I can ditch the sed stuff
07:09:35 <xerox> Kind of abstracting away things in Haskell :D
07:10:20 <poetix> How d'you mean?
07:11:20 <xerox> Moving the declaration upwards to simplify downwards
07:19:54 * poetix browses the Eiffel wxWindows C API
07:21:23 <poetix> Seems to be the same deal: typedef void* _wxObj;
07:23:32 <poetix> ??? Why the heck does this .h file have class declarations in it? -> http://cvs.sf.net/viewcvs.py/elj/elj-2002/lib/ifs/c/ewxw/wrapper.h?view=markup
07:24:01 * malcolm sees that JaffaCake agrees ghc's putChar should not be strict in its first argument.
07:31:23 <rep> my friends, my haskell httpd is now 100% CGI/1.1 compliant (as far as i understand it, at least)
07:35:51 <dcoutts> malcolm, though note that he thinks that the IO type should be unlifted
07:36:10 <dcoutts> ie that IO _|_ = _|_
07:37:22 <malcolm> dcoutts: but only to enable certain compiler optimisations
07:37:29 <dcoutts> right
07:37:45 <dcoutts> if IO is strict and primitieves are too, then putChar being strict is ok
07:37:55 <dcoutts> since putChar = primPutChar
07:38:37 <dcoutts> I assume the report doesn't specify if IO is lifted or unlifted
07:38:48 <earthy> ah, but from the semantics of haskell you'd expect return _|_ :: IO () to be something else than _|_ :: IO ()
07:39:44 <dcoutts> earthy, well eg the strict & lazt ST monads differ on that point
07:39:48 <malcolm> but primPutChar :: Char -> IO (), so whether IO is lifted or not is irrelevant to whether putChar is strict in the Char
07:40:27 <dcoutts> yeah ok
07:40:44 <earthy> dcoutts: um, not really
07:40:58 <dcoutts> well your original argument was that since putChar = primPutChar and primPutChar is primitive then it's strict in the Char
07:41:05 <earthy> the effects are the same on evaluation
07:41:23 <malcolm> dcoutts: yes, that was my original argument.
07:41:44 <dcoutts> malcolm, so what's wrong with that argument?
07:41:45 <malcolm> dcoutts: but I reckon the Report really ought to say "putChar c = primPutChar c"
07:41:52 <dcoutts> ah :-)
07:42:19 <malcolm> It's all to do with CAFs really!
07:42:40 <dcoutts> and the seq issue
07:44:59 <dcoutts> earthy, I don't understand, I think I just don't understand the ST monad strict.lazy distinction
07:45:37 <dcoutts> in the lazy ST monad "_|_ >> a is not necessarily equal to _|_"
07:45:47 <earthy> that *is* true
07:45:54 <dcoutts> ah but that's not quite the same as the eariler examle, fair enough
07:46:08 <dcoutts> because that was about return _|_ vs _|_
07:46:11 <earthy> exactly
07:46:15 <dcoutts> yep ok
07:46:40 <earthy> since you can then discard the value that you got by doing return _|_
07:47:20 <earthy> but yes, the subtleties of lazy vs strict semantics are *highly* subtle
07:47:31 <dcoutts> so perhaps it's not possible to define a monad where return _|_ = _|_ without using seq
07:47:49 * poetix likes looking at bottoms
07:47:57 * earthy grins at poetix
07:48:33 * earthy would say that it is not possible to define a monad where return _|_ = _|_ period
07:48:56 <dcoutts> for an ordinary state monad you normall have data M a = M ( .. -> ..)
07:49:14 <dcoutts> well if your definition of return used seq then you could
07:49:47 <earthy> as that would invalidate m >>= return = m
07:50:06 <dcoutts> hmm
07:50:26 <earthy> or even (return x) >>= f = f x
07:51:13 <dcoutts> because if f were lazy then we could get something other than _|_ even if x = _|_
07:51:21 <earthy> exactly
07:51:24 <dcoutts> eg f = const 3
07:51:48 <earthy> 'we've got laws against that you know'
07:51:53 <dcoutts> heh
07:52:19 <dcoutts> yes, that's a very interesting point
07:52:44 <dcoutts> it'd be nice to see a proof of return _|_ = _|_ => violation of monad laws
07:53:05 <dcoutts> => IO is not a monad (in ghc, sometimes) :-)
07:53:09 <earthy> well, you just gave the counterexample
07:53:10 <earthy> ;)
07:53:54 <Heffalump> most things aren't monads, are they?
07:53:59 <earthy> um
07:54:06 <earthy> Identity is a monad
07:54:09 <earthy> as is Maybe
07:54:12 <earthy> as is List
07:54:20 <basti_> ohh
07:55:12 <earthy> actually, I seem to recall that IO is the only one that really isn't a monad.
07:55:26 <dcoutts> because?
07:55:48 <earthy> because it doesn't fullfil the monad laws
07:56:01 <dcoutts> which one?
07:56:21 <dcoutts> heh Ross Paterson just replied to JaffaCake:
07:56:31 <dcoutts> > Also, GHC's optimiser currently treats (_|_ :: IO a) and (do _|_; return
07:56:31 <dcoutts> > ()) as interchangeable, which is naughty, and people have occasionally
07:56:31 <dcoutts> > noticed, but the benefits can sometimes be huge.
07:56:31 <dcoutts> What's wrong with identifying them?  You're not expecting the monad laws
07:56:31 <dcoutts> to hold, are you?
07:56:58 * earthy grins
07:57:06 <earthy> well, I actually do, normally. :)
07:58:47 <earthy> anyway, I think that error handling breaks the monad laws for IO
07:59:01 <earthy> i.e. fail is not well-behaved in IO
07:59:18 <dcoutts> ah
07:59:52 <earthy> but I steer well clear of IO normally ;)
08:00:06 <earthy> icky wasps nest, that. :)
08:11:27 <rep> httpd: internal error: scavenge_stack: weird activation record found on stack: 6
08:11:30 <rep>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
08:11:33 <rep>     or http://www.sourceforge.net/projects/ghc/
08:11:35 <rep> :/
08:17:07 <beelsebob_> @seen dons
08:17:08 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 5 hours, 41
08:17:08 <lambdabot> minutes and 33 seconds ago.
08:27:10 * SamB begins to suspect that Linux may in fact not be an operating system kernel but merely a pager
08:30:24 <earthy> um, Linux is a terminal driver.
08:30:51 <CosmicRay> nonono.  you're both wrong.  it's a tape driver.
08:31:15 <xerox> is xs ys = concat [xs, "is also ", ys]
08:31:32 <SamB> is there an operating system?
08:33:27 <CosmicRay> SamB: maybe code is an illusion.
08:34:03 <SamB> CosmicRay: you think the stuff that makes Windows slow is an illusion?
08:34:11 <earthy> nope, it really is just a terminal driver. that's what it started out as: a 386 extended mode program to display alternating a's and b's on a terminal
08:34:17 <CosmicRay> SamB: the stuff that makes it fast is an illusion.
08:34:32 <CosmicRay> SamB: so the only part we can truly percieve is the stuff that makes it slow.
08:34:46 <SamB> the stuff that makes Windows slow is code, right?
08:34:48 <CosmicRay> damn, I should have been a philosophy major.
08:34:57 <earthy> why? :)
08:35:10 <CosmicRay> earthy: why, to use on IRC, of course ;-)
08:35:25 <CosmicRay> SamB: can we ever really know? ;-)
08:35:35 <CosmicRay> SamB: is it code or just entropy?
08:35:48 <Trinsic> If I run firefox the scrolling of 'Downloaded file' on a p90 it is considerably slower then a c64 doing the same thing.
08:35:49 <SamB> CosmicRay: well, we could try taking out most of it and see if it doesn't run faster ;-)
08:35:56 <CosmicRay> is windows just a fluke of evolution, or was it intelligently designed? ;-)
08:36:08 <CosmicRay> Trinsic: hehe
08:36:17 * Trinsic smells nop.
08:36:17 <earthy> um. it was probably designed
08:36:25 <earthy> but intelligently designed...
08:36:28 <SamB> Trinsic: I have difficulty believing that you could get Firefox to run in 64k of RAM
08:36:30 <earthy> dunno about that one. :)
08:36:46 <CosmicRay> earthy: see, it's a quandry ;-)
08:37:17 <CosmicRay> perhaps if you have enough time and the right materials, natural processess will eventually occur such that Windows is invented.
08:37:17 <Trinsic> Samb, your missing the point. I am only concerned with the functioning of that one scrolling message box. and yes, you are right, it prolly wouldn't fit in 64k ram.
08:38:07 <earthy> the one million monkeys with computers approach? :)
08:38:18 <CosmicRay> Trinsic: and of course you're not comparing apples to apples.  Your c64 screen is, what, 320x240 with 16 colors?  and your dialog box is displaying on a system with graphic card abstraction at a much higher color depth and resolution ;-)
08:38:20 <CosmicRay> earthy: exactly
08:38:21 <SamB> earthy: did they have a million yet at the time?
08:38:27 <earthy> ;)
08:38:43 <earthy> anyway, time to go get some cooking and eating done
08:38:45 <SamB> the c64 is what, 40x30?
08:40:36 <Trinsic> CosmicRay. nope. I have an accelerated gfx card on my p50. The downloaded window scrolling messages box in firefox is small enough to fit in 300x200. My point is, that it's been intelligently slowed down to get the scroll effect , however, it's specific to the speed of the cpu. (In this case newer modes and not a p50).
08:40:53 <CosmicRay> heh
08:41:03 <SamB> oh.
08:41:39 <SamB> they should have used code that would scroll in the right number of steps for whatever CPU. Same as XP's taskbar and the bouncy effects...
08:49:23 <xerox> @index hGetBuf
08:49:24 <lambdabot> System.IO
08:49:29 <xerox> @type System.IO.hGetBuf
08:49:34 <lambdabot> forall a. GHC.IOBase.Handle -> GHC.Ptr.Ptr a -> Int -> IO Int
08:52:57 <manulito> blownose =)9
08:53:04 <manulito> computerlab started working again?
08:53:24 <[Blownose]> :)
08:54:14 <manulito> if a got a list with lists[[3,4,5],[1,2,9]] is there a function "flaten" it, so it becomes [3,4,5,1,2,9]
08:55:21 <Lemmih> @eval concat [[1,2,3],[4,5,6]]
08:55:23 <lambdabot> [1,2,3,4,5,6]
08:56:48 <manulito> thanks
08:57:02 <manulito> is there a smarter way to find these function, except asking here? =)
08:57:17 <basti_> @hoogle [[a]] -> [a]
08:57:19 <lambdabot> Prelude.concat :: [[a]] -> [a]
08:57:19 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
08:57:19 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
08:58:07 <xerox> ...asking hoogle :D
08:58:07 <manulito> can i hoogle lambdabot in private?
08:58:15 <brx_> @hoogle a -> [[a]] -> [a]
08:58:16 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
08:58:16 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
08:58:16 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
08:58:25 <Lemmih> manulito: Yes.
08:58:25 <xerox> manulito: yep. Modulo freenode policies ;)
08:58:26 <basti_> yes
09:01:46 <ndm> manulito, yes - but you don't want to
09:01:48 <ndm> @where hoogle
09:01:49 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/hoogle/
09:03:11 <xerox> There also is @hoogle+ to get more results
09:03:53 <ndm> but the web hoogle gives colouring as well, and links to documentation
09:04:40 <xerox> I think it's good hoogle has many intrefaces.
09:06:38 <dcoutts> it should get an hIDE interface!
09:08:18 <xerox> That's a GOOD idea.
09:08:31 <xerox> I think I should try building hIDE again.
09:09:36 <xerox> dcoutts, I got blocked by build.hs failing because it cannot satisfy dependency glib-any.  Any ideas?
09:12:16 <Lemmih> Install glib?
09:13:00 <xerox> libglib2.0-0:
09:13:03 <xerox>   Installed: 2.8.2-0ubuntu1
09:13:13 <Lemmih> The Haskell glib package.
09:13:21 <Lemmih> (aka gtk2hs)
09:13:28 <dcoutts> xerox, you need the dev package with the header files
09:13:32 <xerox> aaaaaaah.
09:13:37 <dcoutts> oh wait
09:13:40 <dcoutts> that's not right
09:13:45 <dcoutts> you've just not got gtk2hs installed
09:13:47 <xerox> libglib2.0-dev:
09:13:47 <xerox>   Installed: 2.8.2-0ubuntu1
09:14:01 <xerox> I have, but prolly without glib
09:14:09 <Lemmih> dcoutts: I'm making slight progress with CommonSense.
09:14:14 <dcoutts> xerox, well gtk2hs installes the glib package
09:14:26 <dcoutts> Lemmih, oh excelent, what's new/improved?
09:14:34 <xerox> If it is possible...
09:14:36 <xerox> Mumble.
09:14:37 <dcoutts> xerox, try ghc-pkg list
09:15:19 <xerox> I'm doing a make install, it's strange, anyway.
09:15:20 <Lemmih> dcoutts: It sometimes work now (:
09:15:33 <dcoutts> Lemmih, :-)
09:15:41 <xerox> Oh, maybe I uninstalled it to try the darcs version.
09:15:42 <manulito> if i got a function defined for different values of the inparameters, and i want to use a where-block that all of the functions can use. how can i do that, since now i have to place the same where-block below each functiondefinition..
09:16:24 <dcoutts> Lemmih, I've been hacking on a recent pages browser view, the idea is that it'll list the pages (files & docs etc) that you've looked at recently. It should also be possible to flick back and forth in the history of pages like in a web browser.
09:16:36 <Lemmih> manulito: Use a case expression.
09:17:00 <dcoutts> Lemmih, so then for example if you "jump to documentation" and it switches to a differnt page then it's easy to get back to where you were.
09:17:09 * SamB wonders what language[s] you are supposed to write an icfp 2004 simulator in
09:17:22 <dcoutts> SamB, I used Haskell :-)
09:17:37 <dcoutts> SamB, for the simulator & GUI
09:18:07 <dcoutts> SamB, my simulator ran in 5 sec for 100,000 rounds, the visualiser took about 1 min when running at full speed.
09:18:09 <SamB> dcoutts: how did you deal with mutation?
09:18:22 <dcoutts> SamB, by using mutable arrays :-)
09:18:42 <dcoutts> for all out speed I used unboxed mutable arrays with unsafe indexing :-)
09:18:43 <SamB> dcoutts: many arrays or few?
09:18:49 <dcoutts> many arrays
09:19:00 <dcoutts> sine that's the only way to get unboxing
09:19:14 <dcoutts> you can have arrays of unboxed records
09:19:20 <dcoutts> can/can't
09:19:23 <dcoutts> oops
09:19:28 <SamB> yeah, I figured out from the bit about using unboxed arrays, only I saw that after I pressed enter
09:19:52 <xerox> @where gtk2hs
09:19:53 <lambdabot> http://haskell.org/gtk2hs/
09:19:59 <xerox> Where is the darcs repo?
09:20:08 <dcoutts> http://haskell.org/gtk2hs/darcs/gtk2hs
09:20:14 * SamB considers foreign importing some of the C code he has already written
09:20:35 <xerox> dcoutts: thanks, is --partial suggested/needed/unuseful ?
09:20:46 <dcoutts> xerox, no probably not needed
09:21:11 <xerox> It was rather fast!
09:21:34 <dcoutts> SamB, the Haskell unboxed stuff is pretty quick. The judges made a simulator that ran in 2 sec (vs. my 5) but they were using an ocaml program that generated specialised assembler code for each ant program.
09:22:05 <dcoutts> so you could probably make it a tad faster using C but not by much I'd guess
09:23:59 <xerox> Compiling gtk2hs will take a while, an excuse to study Dante ;-)  Later!
09:25:26 <[Blownose]> if i have like this  [(Int,(String,String)),(Int,(String,String)]  and i want to do a maximum on the ints how do i do that ?
09:27:11 <[Blownose]> sorry imean  [(Int,[(String,String)])]
09:27:11 <dcoutts> [Blownose], you mean maximumBy ?
09:27:37 <dcoutts> maximumBy (comparing fst)
09:28:27 <dcoutts> where
09:28:28 <dcoutts> comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
09:28:28 <dcoutts> comparing p x y = compare (p x) (p y)
09:29:39 <dcoutts> @eval let comparing p x y = compare (p x) (p y) in List.maximumBy (comparing fst) [(0, "foo"), (1, "bar")]
09:29:40 <lambdabot> (1,"bar")
09:29:51 <dcoutts> [Blownose], see?
09:30:03 <dcoutts> is that what you meant?
09:30:24 <[Blownose]> yes but on [(Int,[(String,String)])]
09:30:36 <dcoutts> that'll work too
09:30:40 <[Blownose]> ok
09:31:15 <manulito> [Blownose]: the function you wrote called "maximaBy" and fst should do the trick
09:31:30 <manulito> (maximaBy is something in the assigment we wrote, we are on the same course)
09:31:57 <[Blownose]> ah true :)
09:33:05 <dcoutts> [Blownose], better listen to manulito, your teacher'd get suspicious about the 'comparing' trick.
09:33:38 * dcoutts was only recently introduced to the comparing trick
09:33:51 <[Blownose]> hehe :)
09:41:18 <SamB> hmm, specialised code for each ant program?
09:41:44 <Igloo> They compile the ants to C rather than interpreting them
09:41:58 * SamB doubts an interpreter in C would be faster...
09:41:59 <Heffalump> which goes very fast, unsurprisingly :-)
09:42:08 <Heffalump> yes, but they compile to specialised C.
09:42:28 <SamB> well yeah. nobody is crazy enough to code that in C, are they?
09:43:07 * SamB would try compiling ants to Haskell...
09:43:22 <Heffalump> SamB: code what in C?
09:43:27 <Heffalump> Eijiro's translator was written in ML, AIUI.
09:44:22 <SamB> nevermind, I'm beginning to realize that the ant compiler doesn't need to be the same as the interpreter...
09:44:39 <dcoutts> SamB, I'd guess that the biggest cost is the ant operatons not the interpreter loop overhead.
09:45:04 * Heffalump wonders what SamB is doing
09:45:41 <SamB> oh, I've decided that its high time I try this game ;-)
09:46:25 <Heffalump> I hear there's some really good ants out there that some guys wrote in 3 days ;-)
09:49:00 <dcoutts> Heffalump, really? where did you hear that? ;-)
09:49:44 <Heffalump> can't remember. Some weird meeting or another.
09:50:01 <SamB> ooh, some kind of Cabal?
09:50:10 <Heffalump> anyway, apparently ants are old hat. I heard that there's these cops and robbers now.
09:50:28 <Heffalump> Though I bet our ants would be better at finding food than the cops and robbers.
09:50:32 <SamB> yeah, well, that sounds HARD
09:50:49 <SamB> anyway, ants seem more fun ;-)
09:50:51 <beelsebob_> dons: ping?
09:51:17 <SamB> especially since they aren't supposed to be intelligent
10:00:28 * SamB wonders about using Ptrs instead of IOArrays
10:00:37 <SamB> er, IOUArrays
10:02:48 <dcoutts> it wouldnt be much different, just uglier code
10:03:42 <dcoutts> IOUArrays are a very thin abstraction over Ptrs, especially since you can do unsafe indexing on them
10:03:59 <dcoutts> if you import Data.Array.Base
10:05:23 <SamB> so how do you keep deal with the red/black distinction?
10:05:33 <SamB> that is, what do the array types look like?
10:07:22 <SamB> antStates :: IOUArray (Color, Int) Int ?
10:09:30 * SamB realizes that he can't spell Instruction (Instruction (Instruction ...))
10:10:34 <basti_> Lemmih: is there some bizarrity with instantiating Monad inside haskell server pages?
10:12:00 <dcoutts> SamB, I had seperate arrays for the red & black, so that the indexing is simpler/faster
10:12:28 <SamB> dcoutts: what did you keep them in?
10:12:35 <dcoutts> SamB, when you're done we should compare :-) See which Haskell implementation is faster :-0
10:12:59 <dcoutts> SamB, keep what in exactly?
10:13:38 <SamB> dcoutts: the antwise arrays
10:14:11 <dcoutts> SamB, you mean the state for each ant? ie each ant's program counter
10:14:12 <dcoutts> a_state   :: !(IOUArray Int AState)
10:14:25 <dcoutts> where AState = Int
10:14:41 <dcoutts> each ant has an id
10:15:00 <dcoutts> it's not a split id space for red/black
10:15:20 <dcoutts> so the colour is not part of the index
10:15:43 <dcoutts> sorry I was confused about what you said initially
10:16:21 <SamB> oh, it isn't?
10:16:46 <SamB> right
10:16:52 * SamB wonders why he was thinking it WAS
10:17:11 * SamB thinks even his previous code knew better
10:18:53 <dcoutts> the ant ids get assigned depedning on their position in the intial world
10:21:07 <SamB> hmm, antRestings really rolls off the tongue, doesn't it?
10:21:21 <SamB> actually it makes me think of a lot of ant beds or something
10:26:29 <SamB> and what do you do about cells?
10:27:11 <SamB> ah, well, I'll figure something out...
10:28:00 <dcoutts> SamB, I used an array per-cell property
10:28:13 <SamB> I meant positions, actually
10:29:01 <dcoutts> you mean the positions of the ants?
10:29:39 <SamB> nevermind, I'll just do it the normal way for now...
10:29:40 <dcoutts> it's useful to know if there's an ant in a cell and also where an ant is
10:29:48 <dcoutts> ie you want a mapping in both directions
10:30:02 <SamB> yeah, I'm doing that ;-)
10:30:27 <dcoutts> that way you get O(1) lookup for all operations
10:31:22 <SamB> so did you use "type Pos = (Int, Int)" or something like that?
10:32:02 <dcoutts> no, remember you can't get unboxed arrays unless you use simple array value types
10:32:20 <dcoutts> you can't have IOUArray Int (Int, Int)
10:32:40 <dcoutts> so everything needs to be flattened
10:32:58 <dcoutts> hmm maybe flattened isn't the right term
10:33:17 <SamB> oh, I realize that
10:33:46 <SamB> I was going to split them into antXs and antYS
10:33:56 <SamB> s/S$/s/
10:34:38 <dcoutts> yeah
10:35:21 * SamB guesses it is best to get something working before quibling too much about the representation of Pos...
10:37:38 * SamB is reminded of BASIC with all these parallel arrays
10:38:27 <rep> my great friends, i have tested httpd.hs with a CGI that uses POST, and all kinds of things, and it (mostly) WORKS
10:41:53 <dcoutts> @karma+ rep
10:41:54 <lambdabot> rep's karma raised to 1.
10:42:10 <rep> :D
10:42:32 <SamB> @index MArray
10:42:33 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
10:44:03 <SamB> @index unsafeReadArray
10:44:04 <lambdabot> bzzt
10:44:19 <SamB> @index unsafeRead
10:44:20 <lambdabot> bzzt
10:44:40 <SamB> don't tell me... its undocumented?
10:45:11 <dcoutts> yep :-)
10:45:34 * dcoutts keeps a copy of the ghc source around for reference
10:45:50 <SamB> from where ought I to import it?
10:46:08 <SamB> Data.Array.Base?
10:46:38 * SamB is too lazy to look at the library sources he has installed
10:47:41 <Korollary> hmm, that must be why I couldn't find unsafeWrite either...
11:01:00 <[Blownose]> if i have [(4, ("blabla","blabla")), (4,("hey","hey"))] and i want [(4,[("blabla","blabla"),("hey,hey")])] how do i do that can i use lookup in some way or?
11:01:46 <basti_> youre not bringing your homework problems here are you? ;)
11:02:02 <[Blownose]> ofcourse not :p
11:03:31 <basti_> have a look into groupBy maybe.
11:13:20 <xerox> @type List.lookup
11:13:21 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
11:17:01 <xerox> @where ghc-api
11:17:02 <lambdabot> http://scannedinavian.com/~lemmih/ghc-api
11:17:42 <xerox> Chasing dependencies is so fun
11:20:41 <xerox> Anyone succeeded in compiling ghc-api with GHC 6.4.1?
11:23:11 <[Blownose]> hmm anyone who knows a page where i can read more about groupBy ?
11:23:30 <xerox> @index groupBy
11:23:31 <lambdabot> Data.List
11:23:34 <xerox> @docs Data.List
11:23:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
11:23:39 <xerox> Maybe there's some explanation there.
11:24:17 <[Blownose]> i mean with some examples..
11:24:49 <xerox> Lemmih: is ``ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1): unknown exception'' some kind of early bug report you don't admit, or is it (well)known, and fixable?
11:30:32 <kolmodin> xerox: worked for me
11:30:49 <xerox> Mumble.
11:31:50 <[Blownose]> [(4, ("blabla","blabla")), (4,("hey","hey"))] to-> [(4,[("blabla","blabla"),("hey,hey")])] sure you can do that with groupBy ? imean how do i define a bool-expression for that ? =)
11:32:20 <basti_> i didnt say groupBy is the only operation you'd need
11:34:52 <rep> http://people.freebsd.org/~ssouhlal/stuff/Screenshot-33.png
11:35:41 <SamB> @plugs (groupBy \x y -> fst x == fst y) [(4, ("blabla","blabla")), (4,("hey","hey"))]
11:35:41 <lambdabot> <irc>:1:9: parse error on input `\'
11:35:51 <SamB> @plugs groupBy (\x y -> fst x == fst y) [(4, ("blabla","blabla")), (4,("hey","hey"))]
11:35:53 <lambdabot> [[(4,("blabla","blabla")),(4,("hey","hey"))]]
11:35:54 <xerox> @plugs let f = groupBy (\(x,_) (y,_) -> x == y) in (fst.head.head.f) [(1,undefined),(1,undefined)]
11:35:56 <lambdabot> 1
11:36:29 <xerox> Pizza!  Later.
11:38:35 <thedward> @hoogle groupBy
11:38:36 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
11:39:13 <CosmicRay> so.  question.
11:39:37 <SamB> @pl groupBy (\x y -> fst x == fst y) [(4, ("blabla","blabla")), (4,("hey","hey"))]
11:39:49 <SamB> @pl groupBy (\x y -> fst x == fst y)
11:39:49 <lambdabot> groupBy (flip ((.) . (==) . fst) fst) [(4, ("blabla", "blabla")), (4,
11:39:49 <lambdabot> ("hey", "hey"))]
11:39:49 <lambdabot> optimization suspended, use @pl-resume to continue.
11:39:49 <lambdabot> groupBy ((. fst) . (==) . fst)
11:40:03 <CosmicRay> anybody know why this program: http://darcs.complete.org/local-branches/shootout/bench/sumcol/sumcol.ghc-2.ghc would be 71 times slower than http://darcs.complete.org/local-branches/shootout/bench/sumcol/sumcol.ghc?
11:40:12 <araujo> generics == polymorphic variables ?
11:40:28 <CosmicRay> basically the program reads ints from an input file, one per line, and prints out the sum of them.
11:41:27 <Igloo> read on things like Int is hideously slow
11:41:41 <CosmicRay> is there any better option than roll-your-own?
11:42:08 <Igloo> I think if you do something like the first one using your own read' then you should get comparable speed to the second
11:42:37 <CosmicRay> why is read so slow for ints?
11:43:05 <Igloo> Dunno. I brought it up for Integers a while ago, to no response
11:43:42 <Igloo> (I don't actually know that Ints are also bad, but that's my best guess without trying it)
11:44:11 <CosmicRay> that would make sense.
11:44:36 <CosmicRay> I assume that I did the right thing by forcing the type of sum to be [Int] -> Int?  otherwise the entire thing would be generic
11:45:02 <Igloo> It would default to Integer had you have not done that
11:45:27 <CosmicRay> interesting.  I would have suspected Float or something.
11:45:30 <sylvan> wouldn't just not work?
11:50:08 <Lemmih> xerox: I would like to fix it but I haven't found a way to reproduce it.
11:57:28 <[Blownose]> basti_ dont get it.. how do i use groupBy with another function to make that ? all i get are either [[(4,("blabla","blabla")),(4,("hey","hey"))]] or [[(4,("blabla","blabla"))],[(4,("hey","hey"))]
11:57:49 <basti_> what's missing?
11:57:54 <Lemmih> basti_: Instantiating Monad?
11:58:17 <basti_> Lemmih: yes, whenever i make an instance of Monad in a hsp, it breaks
11:58:32 <basti_> subtly. It appears to compile and run, but the old version is run instead
11:58:41 <basti_> without any notice
12:00:07 <Lemmih> Hm.
12:00:26 <basti_> sounds so wacky that i tried again
12:00:36 <basti_> but it still breaks
12:01:02 <basti_> just write something like data Lulu a = Lulu a
12:01:10 <basti_> instance Monad Lulu where blahblah
12:02:40 <Lemmih> I'll start fixing bugs in HSP once hIDE is finished (:
12:02:47 <basti_> ha ha ha ;)
12:03:13 <xerox> Lemmih: do you want an account here?
12:03:15 <basti_> and whats up with this always recompiling when there is a file being read?
12:03:40 <Lemmih> xerox: Yeah, that would be great.
12:12:38 <TFK> @index toInt
12:12:39 <lambdabot> bzzt
12:13:20 <[Blownose]> how do i make this [(4, ("blabla","blabla")), (4,("hey","hey"))] -> [(4,[("blabla","blabla"),("hey,hey")])] with groupBy ? dont really get howto use the groupBy function
12:13:25 <Lemmih> @type GHC.Exts.unsafeCoerce# :: forall a. a -> Int
12:13:26 <lambdabot> forall a. a -> Int :: forall a. a -> Int
12:14:07 <autrijus> er what?
12:14:10 <autrijus> @type GHC.Exts.unsafeCoerce#
12:14:11 <lambdabot> forall b a. a -> b
12:14:16 <autrijus> ah.
12:14:17 <basti_> [Blownose]: again, i didn't say you'd be done with a single groupBy call
12:14:25 <xerox> autrijus wee :)
12:14:33 <Lemmih> autrijus: Universal toInt function (:
12:14:38 <autrijus> riiiight.
12:14:45 <autrijus> for some value of universal.
12:14:51 <[Blownose]> i know basti.. but still.. i dont know howto do it with another function beacuse i dont really understand the first one :)
12:15:15 <basti_> [Blownose]: uhmm.
12:15:23 <basti_> do you see the point of groupBy?
12:15:24 <xerox> [Blownose]: the 'By' in 'groupBy' means that you have to provide a function which does the check, which grouping is meant to do 'By'.
12:15:55 <basti_> @pl group [1,1,1,2,2,2,3,3,4]
12:15:56 <lambdabot> group [1, 1, 1, 2, 2, 2, 3, 3, 4]
12:16:02 <basti_> urghs
12:16:02 * SamB wants a short-circuiting monadic &&
12:16:05 <basti_> @eval group [1,1,1,2,2,2,3,3,4]
12:16:06 <lambdabot> [[1,1,1],[2,2,2],[3,3],[4]]
12:16:17 <[Blownose]> yes group i get
12:16:23 <xerox> @plugs groupBy (<) [1,2,3,4,3,2,1]
12:16:25 <lambdabot> [[1,2,3,4,3,2],[1]]
12:16:38 <xerox> @plugs groupBy (>) [1,2,3,4,3,2,1]
12:16:40 <lambdabot> [[1],[2],[3],[4,3,2,1]]
12:16:40 <TFK> @index toDigit
12:16:41 <lambdabot> bzzt
12:16:45 <basti_> etc.
12:16:51 <xerox> TFK: fromEnum
12:16:53 <basti_> do you see the connection to your problem [Blownose] ?
12:17:34 <TFK> I could swear that I saw a built-in like that...
12:17:36 <[Blownose]> hmm groupBy (>) [1,2,3,4,3,2,1]   > bigger than what ?
12:17:45 <xerox> [Blownose]: forget it
12:18:37 <[Blownose]> but still basti here we are working with one list not a tuple with text in it..
12:18:52 <basti_> uhm.
12:18:56 <xerox> @plugs groupBy (\(x:_) (y:_) -> x == y) [[1,2,3,4],[1,3,5,7],[2,4,6,8],[2,4,8,16]]
12:18:58 <lambdabot> [[[1,2,3,4],[1,3,5,7]],[[2,4,6,8],[2,4,8,16]]]
12:19:15 <basti_> @eval (\(a,b) (a,b)->a>b) (4,"hello") (5,"test")
12:19:17 <lambdabot> <irc>:1:3:
12:19:17 <lambdabot>   Conflicting definitions for `a'
12:19:17 <lambdabot>   In a lambda abstraction
12:19:17 <lambdabot>  
12:19:17 <lambdabot> <irc>:1:5:
12:19:19 <lambdabot>   Conflicting definitions for `b'
12:19:21 <lambdabot>   In a lambda abstraction
12:19:26 <xerox> heh
12:19:49 <basti_> ohh
12:19:54 <basti_> @eval (\(a,c) (a,d)->a>b) (4,"hello") (5,"test")
12:19:55 <lambdabot> <irc>:1:3:
12:19:55 <lambdabot>   Conflicting definitions for `a'
12:19:55 <lambdabot>   In a lambda abstraction
12:19:55 <lambdabot>  
12:19:55 <lambdabot> <irc>:1:17: Not in scope: `b'
12:19:58 * basti_ st00pid
12:20:05 * basti_ pain
12:20:29 <basti_> @eval (\(a,c) (b,d)->a>b) (4,"hello") (5,"test")
12:20:31 <lambdabot> False
12:20:36 <basti_> :)
12:20:38 <xerox> @plugs (\(x,_) (y,_) -> x > y) (4,undefined) (5,undefined)
12:20:40 <lambdabot> False
12:20:54 <int-e> @eval groupBy (==) $ sort [1,2,3,4,3,2,1]
12:20:55 <lambdabot> [[1,1],[2,2],[3,3],[4]]
12:23:33 <int-e> group[By] does not change the order of the elements of the original list.
12:24:34 <[Blownose]> ok.. dont need the order.. but i just want one 4  not like [[4,4,4],[("jofej","jifje"),("jfeij","jfiej")]]
12:24:42 <[Blownose]> - one 4 :)
12:25:00 <int-e> @eval map head $ group $ sort [1,2,3,4,3,2,1]
12:25:01 <lambdabot> [1,2,3,4]
12:25:20 <xerox> [Blownose]: you want to group a [(Int,(String))] by its Int, right?
12:25:33 <[Blownose]> yes
12:26:00 <[Blownose]> i mean i always have just one number  and i want to group my text by it..
12:26:19 <[Blownose]> like this [(4, ("blabla","blabla")), (4,("hey","hey"))] -> [(4,[("blabla","blabla"),("hey,hey")])]
12:26:23 <xerox> Given 'x' and 'y' of type (Int,[String]), how do you compare their ints?
12:26:36 <int-e> ah.
12:26:42 <rep> how are you gentlemen
12:26:50 <xerox> Given 'x' and 'y' of type (Int,(String,String)), how do you compare their ints, even?
12:27:22 <xerox> [Blownose]: do you understand fst/snd or pattern matching on tuples?
12:27:37 <[Blownose]> yes fst will give me my int
12:27:57 <xerox> [Blownose]: then compare the ints!
12:28:10 <[Blownose]> but the ints are always the same value
12:28:23 <xerox> So why is the Int value there?
12:29:07 <xerox> @plugs map (snd) [(4, ("blabla","blabla")), (4,("hey","hey"))]
12:29:08 <lambdabot> [("blabla","blabla"),("hey","hey")]
12:30:22 <[Blownose]> its the answer from another function.. and when i take maximum of it i can get one answer or five..
12:30:49 <SamB> what is the default fixity?
12:31:16 <xerox> [Blownose]: if you only need the second part of a tuple, add a 'snd' call to the function returning you that values, no?
12:32:35 <[Blownose]> sure.. but i need the first value one time aswell.. so what do you suggest   fst ([(4, ("blabla","blabla")), (4,("hey","hey"))]!!0) ++ map (snd) [(4, ("blabla","blabla")), (4,("hey","hey"))] something like that :) ?
12:32:58 <[Blownose]> not with the ++ though
12:33:18 <xerox> [Blownose]: I think I need more context
12:35:09 <[Blownose]> from a function i get following  [(4, ("blabla","blabla")), (4,("hey","hey")), (4,"bye","bye"))] and i want to make it like this [(4,[("blabla","blabla"),("hey,hey"),("bye",bye")])]
12:35:45 <[Blownose]> ("hey","hey") ofcourse
12:35:58 <SamB> [Blownose]: I would personally suggest using a function to which you pass [(4, ("blabla","blabla")), (4,("hey","hey")), (4,"bye","bye"))]
12:36:50 <SamB> or something like let xs = [(4, ("blabla","blabla")), (4,("hey","hey")), (4,"bye","bye"))]
12:37:09 <SamB> so you don't have to stick [(4, ("blabla","blabla")), (4,("hey","hey")), (4,"bye","bye"))] everywhere
12:37:17 <int-e> @eval (\l -> (fst $ head l,map snd l))  [(4, ("blabla","blabla")), (4,("hey","hey")), (4,"bye","bye"))]
12:37:18 <lambdabot> <irc>:1:95: parse error on input `)'
12:37:56 <int-e> @eval (\l -> (fst $ head l,map snd l))  [(4, ("blabla","blabla")), (4,("hey","hey")), (4,("bye","bye"))]
12:37:57 <lambdabot> (4,[("blabla","blabla"),("hey","hey"),("bye","bye")])
12:38:27 <[Blownose]> nice.. what does the $ means ?
12:38:44 <int-e> note that this one ignores the numbers completely; you can combine that with groupBy though
12:39:04 <int-e> a $ b = a b but $ is right assoiciative and has a very low precedence
12:39:33 <xerox> I.e. put a '(' where there is '$' and a ')' at the end of the expression.
12:39:38 <int-e> so fst $ head l = fst (head l)
12:58:38 <boegel|home> pretty quiet in here
13:01:06 <Lemmih> We're all busy hacking fun Haskell code.
13:01:15 <boegel|home> cool
13:03:08 <beelsebob_> mine isn't fun :(
13:03:25 <beelsebob_> ... but I am most deffinately hacking it
13:04:43 <xerox> beelsebob_: what is it?
13:04:48 <xerox> Howdy, poetix.
13:04:56 <poetix> howdy
13:05:02 <beelsebob_> xerox: It's meant to be hat-delta, but it's a bit quagmirish at the mo
13:05:44 <lightstep> @where buddha
13:05:45 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
13:05:59 <TFK> I've been trying to solving this problem:  with this piece of code: http://hbin.dyndns.org/pastebin/80.html but to no avail. Any suggestions (besides using unsafe coerces and the like)?
13:06:06 <beelsebob_> lightstep: any particular reason you want buddha, rather than hat-detect
13:06:07 <beelsebob_> ?
13:06:11 <TFK> err, the problem is: https://spoj.sphere.pl/problems/INTEST/
13:06:41 <lightstep> beelsebob_, i don't know either at all, but buddha has a much cooler name
13:06:41 <beelsebob_> (or hat in general)
13:06:58 <beelsebob_> heh, hat-detect is slightly better now
13:07:07 <beelsebob_> it'll be much much better once I've finished with it
13:07:19 <lightstep> @where hat
13:07:20 <lambdabot> http://www.cs.york.ac.uk/fp/hat
13:07:47 <beelsebob_> lightstep: if the current version fails, give me a yell, and I'll put my version into cvs
13:07:54 <beelsebob_> I'm not sure of the state of the current one
13:08:13 <beelsebob_> but in the mean time, hat-explore does a similar job, and gives a better UI
13:11:45 <lightstep> hrm, do hat and buddha use a very different framework?
13:11:55 <beelsebob_> very different
13:17:51 <boegel|home> yo Oejet
13:18:16 <Oejet> boegel|home: Hello!
13:22:25 <xerox> @index getLine
13:22:26 <lambdabot> System.IO, Prelude
13:22:29 <xerox> @docs System.IO
13:22:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html
13:24:46 <lightstep> TFK: you use mod twice
13:25:04 * Lemmih curses global variables to the most miserable place in hell.
13:25:52 <lightstep> TFK, also, toInt==read and you disregard n and this fold is ugly and i'm too tired to be civil
13:29:03 <TFK> damnit, I *do* use mod twice... ^_^;;
13:29:21 <TFK> I was told that read is slow, though.
13:31:13 <SamB> @index IORef
13:31:14 <lambdabot> Data.IORef
13:31:28 <SamB> @index IOVar
13:31:29 <lambdabot> bzzt
13:33:01 <beelsebob_> ARGH!
13:34:26 <TFK> Removing the "upper" mod didn't force the TLE, though.
13:37:49 <Speck> Reading the visual haskell paper from the acm portal over here... any hIDE 2 people have their hands on this?
13:38:28 <Speck> it uses cabal in a cool way that I think hIDE should copy
13:41:25 <kosmikus> Speck: http://www.haskell.org/~simonmar/papers/vshaskell.pdf
13:42:49 <Speck> kosmikus: I mean I'm reading it now :-)
13:43:12 * boegel|home leaves (see you all tomorrow)
13:44:40 <xerox> TFK: want to see my solution?
13:46:31 <beelsebob_> ARGH!
13:46:35 <beelsebob_> makeQuestions n _ _ = seq (unsafePerformIO $ putStrLn $ show {--displayTree getFullEvalText--} $ buildEDT (limitDepth 10 n)) []
13:46:40 <beelsebob_> this freezes
13:46:47 <beelsebob_> makeQuestions n _ _ = seq (buildEDT (limitDepth 10 n)) []
13:46:49 <beelsebob_> this does not
13:46:54 <xerox> Urgh.
13:47:25 <TFK> xerox, sure
13:47:32 <TFK> it's a technical problem, after all
13:48:48 <xerox> TFK: I didn't actually test it with large inputs.
13:49:03 <TFK> well, large inputs is what this problem is about.
13:49:13 <xerox> Do you have inputs to test it?
13:49:34 <TFK> https://spoj.sphere.pl/problems/INTEST/ <--- sure, you submit your code there and they run it.
13:49:44 <xerox> @wiki HaskellIrcPastePage
13:49:45 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:50:17 <kosmikus> Speck: I was just pointing out that there's a version of it that doesn't require ACM portal access ...
13:52:33 <xerox> TFK: I don't know if it's fast, but it is 3 lines long :-)
13:52:58 <Speck> kosmikus: ah, luckily I attend a college that subscribes :-)
13:53:36 <TFK> Just submited it for fun. 5$ says it will TLE.
13:54:18 <TFK> Not only did it TLE, it ate a lot of memory.
13:54:29 <xerox> 'TLE' ?
13:54:41 <xerox> TFK: can you test mine with the same vars?
13:55:06 <TFK> Yes, I just did.
13:55:11 <TFK> TLE = Time Limit Exceeded
13:55:23 <xerox> Ah, mine did ate a lot of memory?
13:55:28 <xerox> *do
13:55:33 <Speck> darn, I thought it was "true love's embrace"
13:55:40 <TFK> http://hbin.dyndns.org/pastebin/81.html <--- for reference, this is my latest version
14:00:08 <xerox> @index lift
14:00:09 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
14:00:09 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
14:00:09 <lambdabot> Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
14:00:09 <lambdabot> ParserCombinators.ReadPrec, Text.Read
14:01:19 <int-e> hmm. ghc 6.2.1
14:02:10 <TFK> int-e, hi :-) understanding your binary-tree solution to the circle problem is still on my agenda ;-)
14:03:30 <int-e> TFK: it's horribly inefficient :P
14:03:48 <TFK> Well, I'm off to bed. I'll get back to this in the weekend.
14:04:02 <TFK> Meanwhile, you're welcome to conquer SPOJ using Haskell ;-)
14:04:08 <int-e> TFK: have a look at Cale's version on the HaskellIrcPastePage (Josephus problem solution)
14:04:14 <constantine> hi
14:04:36 <int-e> TFK: it calculates the list index of the survivor.
14:04:42 <TFK> taite/burde?
14:04:47 <int-e> right
14:04:47 <Cale> yep
14:05:02 <Cale> after the people who actually came up with that algorithm :)
14:05:04 <int-e> burde is the fast version.
14:05:35 <constantine> kto nibudi sdesi gogorit po russki ?
14:05:36 * TFK wishes his printer worked
14:06:05 <TFK> Kto govorit, tomu naverno spat pora...
14:06:26 <TFK> Thanks, I'll definitely look into it.
14:06:34 <constantine> eto ti pro sebia ?
14:06:40 <TFK> aga
14:06:56 <constantine> tak vedi rano esho !
14:07:06 <TFK> tolko 00:10...
14:07:12 <constantine> aga
14:07:16 <TFK> :-/
14:07:31 <TFK> well, I'm off to bed. See you in the weekend!
14:07:47 <constantine> ti uhodish ?
14:07:59 <TFK> aga. poka!
14:09:41 <praseodym> wow what algorithm is that
14:09:50 <praseodym> oh russian
14:10:04 <constantine> russian
14:11:08 <constantine> And what?
14:15:10 <rep> @pl \f xs -> xs >>= return . f
14:15:11 <lambdabot> fmap
14:15:51 <basti_> :-o
14:15:56 <xerox> ^_^
14:16:02 <ski> @arr
14:16:04 <lambdabot> Yeh scurvy dog...
14:20:22 <xerox> @pl \a n -> mapM_ (const a) (replicate n undefined)
14:20:23 <lambdabot> (. flip replicate undefined) . mapM_ . const
14:20:32 <xerox> @pl \n a -> mapM_ (const a) (replicate n undefined)
14:20:34 <lambdabot> flip (mapM_ . const) . flip replicate undefined
14:20:42 <xerox> @pl \n a -> mapM_ (const a) [1..n]
14:20:43 <lambdabot> flip (mapM_ . const) . enumFromTo 1
14:20:50 <xerox> @pl \a n -> mapM_ (const a) [1..n]
14:20:51 <lambdabot> (. enumFromTo 1) . mapM_ . const
14:21:00 <xerox> Is there any abstraction like that?
14:21:02 <int80_h> has anyone made a .pkg of hIDE for OSX?
14:21:06 <basti_> that reminds me how i once asked a @pl... and it looked completely different after, just not a bit clearer
14:22:23 <ski> xerox : maybe '\a n -> sequence_ (replicate n a)' ?
14:23:08 <xerox> ski: and it does not have a standard name, right?
14:23:35 <ski> you could call it doTimes, perhaps
14:23:44 <xerox> replicateM_ heh
14:23:49 * ski wonders if he's seen this or not ..
14:24:19 <ski> Int -> m a -> m [a]
14:24:25 <Cale> @index replicateM_
14:24:26 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
14:24:26 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
14:24:26 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
14:24:29 <xerox> !
14:24:32 <basti_> !!
14:24:33 <basti_> :-o
14:24:34 <ski> xerox : good name
14:24:37 <ski> heh :D
14:24:42 <xerox> @type Control.Monad.List.replicateM_
14:24:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
14:24:48 <ski> yay
14:24:49 <xerox> uh uh.
14:24:54 * xerox boings happily
14:26:25 <xerox> and...
14:26:28 <xerox> @type Control.Monad.List.replicateM
14:26:30 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
14:26:39 <xerox> @hoogle Int -> m a -> m [a]
14:26:40 <lambdabot> Prelude.replicate :: Int -> a -> [a]
14:26:40 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
14:26:46 <xerox> heh!
14:27:02 <rep> http://www.freebsd.org/
14:27:09 <Cale> It probably doesn't look in the hierarchical libs :)
14:27:32 <xerox> :(
14:27:50 <xerox> Cale: any idea on how to improve:  print $ sum [1 | x <- ys, x `mod` (read d) == 0]
14:28:14 <thedward> @hoogle a -> b -> (a,b)
14:28:16 <lambdabot> Prelude.divMod :: Integral a => a -> a -> (a, a)
14:28:16 <lambdabot> List.mapAccumR :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
14:28:16 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
14:28:53 <ski> @type (,)
14:28:54 <lambdabot> forall b a. a -> b -> (a, b)
14:29:59 <Cale> hoogle seems to be missing some important functions
14:30:16 <Cale> @hoogle a -> [a]
14:30:17 <lambdabot> Prelude.repeat :: a -> [a]
14:30:17 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
14:30:17 <lambdabot> Random.randoms :: (Random a, RandomGen b) => b -> [a]
14:30:38 <ski> xerox : 'print $ foldr (\x s -> if x `mod` read d == 0 then s+1 else s) 0 ys' ?
14:30:56 <Cale> print $ length $ filter (\x -> x `mod` read d == 0) ys ?
14:31:05 <ski> m, prolly better
14:31:49 <Cale> @pl print $ length $ filter (\x -> x `mod` read d == 0) ys
14:31:50 <lambdabot> print (length (filter ((0 ==) . (`mod` read d)) ys))
14:33:04 <xerox> Anybody has an account on spoj.sphere.pl to test it?
14:33:30 <mauke> ooh, spoj?
14:33:35 <mauke> I do
14:33:48 <Cale> spoj is annoying because a lot of the problems are easy to solve in Haskell, but you will get time limit exceeded, because they expect very fast implementations
14:34:29 <mauke> depends on the problem; some are trivially solvable in reasonable time
14:34:36 <xerox> import Control.Monad.List
14:34:37 <xerox> main = do
14:34:37 <xerox>   (n:d:[]) <- (map (read) . words) `fmap` getLine
14:34:37 <xerox>   ys <- replicateM n (read `fmap` getLine)
14:34:40 <xerox>   print $ length $ filter (\x -> x `mod` d == 0) ys
14:35:00 <xerox> https://spoj.sphere.pl/submit/INTEST/
14:36:24 <Cale> tle
14:36:30 <xerox> Hmpf.
14:36:56 <xerox> But the solution looks nice :-)
14:36:58 <Cale> though you managed to somehow consume twice as much memory as my previous solution, which was similar
14:37:17 <xerox> uh :)
14:37:48 <Cale> I'm not sure if it's a good sign or now
14:37:50 <Cale> not*
14:38:17 <mauke> @type read `fmap` getLine
14:38:18 <lambdabot> forall a. (Read a) => IO a
14:38:26 <mauke> @type readLn
14:38:28 <lambdabot> forall a. (Read a) => IO a
14:38:33 <xerox> ..!
14:38:49 <xerox> fmap was fun.
14:39:22 <Cale> for some reason I never think of readLn either
14:39:47 * xerox annotates it on a post-it
14:40:04 <Cale> fmap read getLine seems more natural :)
14:40:46 <mauke> oh, replicateM... I always do sequence_ (replicate ...)
14:41:16 <xerox> I was just informed by an email that 'Vlaagra - $3.3'.
14:41:27 <Cale> heh
14:41:33 <xerox> Pfft :)
14:42:43 <xerox> Cale: I had some ideas for Nymphaea, I just don't remember them now.
14:44:13 <Cale> oh, replacing  read `fmap` getLine with readLn has dropped the memory usage from 60k to 16k, but it still TLEs. The memory usage is probably random anyway.
14:44:29 <xerox> heh, good to know.
14:45:37 <work_metaperl> What's the easiest way to get and study the Prelude source? darcs.complete.org seems to be missing it at the moment.
14:45:41 <xerox> Maybe there is a read n lines action in System.IO too, heh.
14:45:49 <xerox> work_metaperl: it is in the report, IIRC.
14:46:21 <int-e> hmm, but fmap was faster (here)
14:46:22 <work_metaperl> xerox: I will go look. Reading van Eijk's book last night helped me out... overall it's way to deep but I got some good points from it
14:47:09 <work_metaperl> one thing he said is that "=" means a hugely different thing in haskell than in imperative languages... in haskell it means that the thing on the left and the right represent the _same_ value... that is not true in an imperative language
14:47:27 <xerox> Indeed.
14:47:47 <xerox> That's one of the reason it's simpler to think about the code!
14:48:12 <xerox> (If not the main reason - referential transparency)
14:48:16 <work_metaperl> xerox: it does take some time to get rid of your old mindset though
14:48:37 <xerox> :)
14:48:54 <xerox> int-e: on what inputs do you try it?
14:49:45 <int-e> (echo 100000 1; yes 1) | (time ./a.out)  is what I currently try
14:49:58 <xerox> :D
14:50:26 <int-e> and the speed is awful.
14:50:39 <xerox> Maybe you could try profiling?
14:51:04 <int-e> (takes 2 seconds for that one)
14:51:07 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
14:54:45 <int80_h> nmjnjhjh
14:54:57 <xerox> Okay, goodnight folks!
14:55:03 <int80_h> hmmm
14:55:30 <int80_h> does anyone have a .pkg of hIDE for OSX?
14:55:55 <Heffalump> I don't think the hIDE authors are actually recommending anyone _use_ it yet.
14:56:07 <int80_h> aw nuts
14:56:11 <int80_h> darn it
14:56:14 <int80_h> :)
14:56:21 <int80_h> okay I'll leave it be for now
14:56:28 <int80_h> I was so excited too
14:57:17 <int80_h> hmm graphviz broke during compile anyway
14:57:27 <int80_h> figures
14:57:28 <Heffalump> I keep asking them and they keep saying that it's fine as long as I don't want to save my work.
14:57:35 <int80_h> heh
14:57:43 <int80_h> sounds good to me
14:57:46 <Heffalump> (and pointing out that as long as I keep it running, a dynamic update will eventually add that functionality, so it's all fine)
14:57:51 <int80_h> makes debugging easier
14:58:08 <work_metaperl> This is a nicely formatted online report: http://zvon.org/other/haskell/Outputglobal/index.html
15:02:58 <int-e> read kills it. :/
15:17:18 <int-e> hmm. 1.17 seconds for 1/10th of the input ...
15:18:33 <ulfdoz> Im Moment ist eh mehr Zeit für Dimmu Borgir und Rammstein und Co.
15:18:38 <ulfdoz> ECHAN, sorry
15:20:44 * ski listens to Reise Reise
15:22:12 * Cale listens to Jean-Luc Ponty
15:30:00 <int-e> let me guess, time limit is 10 seconds ... if I can extrapolate the 'half input' number, I'm at 10+epsilon.
15:32:59 <rep> are there bitwise and operations for, say, Int32?
15:33:32 <int-e> @index .&.
15:33:33 <lambdabot> Data.Bits, Foreign
15:34:00 <rep> thanks
15:34:49 <int-e> lisppaste2: help
15:34:49 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:35:16 <lisppaste2> int-e pasted "integer input ..." at http://paste.lisp.org/display/12285
15:35:42 <int-e> this is so ugly.
15:35:59 <ski> s/'0'<=c && c<='9'/isDigit c' ?
15:36:17 <int-e> no
15:36:34 <int-e> I'm trying to be fast, not concise.
15:38:19 <ski> why do you write 10*1 ?
15:38:30 <int-e> it's l
15:38:36 <int-e> a lower case l
15:38:39 <ski> aha
15:38:39 <int-e> L
15:38:40 <ski> sorry
15:42:09 <work_metaperl> Hoogle is really cool: http://www-users.cs.york.ac.uk/~ndm/hoogle/
15:49:41 <int-e> woah. 6.3 seconds for main = getContents >>= (print.length)
15:49:46 <int-e> that's not good, is it?
15:51:38 <basti_> what are you trying to do?
15:52:05 <int-e> http://spoj.sphere.pl/problems/INTEST/ in haskell
15:52:20 <int-e> time limit seems to be 10 seconds or thereabouts
15:52:56 <basti_> ah
15:53:01 <mauke> it's 8s
15:53:22 <int-e> mauke: how do you know?
15:53:30 <mauke> http://spoj.sphere.pl/problems/INTEST/
15:53:36 <mauke> Time limit [s]:8
15:53:52 <int-e> thanks. i'm too stupid to read.
15:58:34 <int-e> NZEC ?!
15:59:39 <int-e> non zero exit code. aha.
16:06:02 <work_metaperl> I need some help understanding (\\): http://sequence.complete.org/node/111
16:06:27 <mauke> I know k
16:09:51 <Cale> work_metaperl: it's not foldl that's being flipped - it's delete
16:11:16 <int-e> the same code in C works like a charm.
16:12:05 <ski> work_metaperl : [a,b] \\ [c,d] = foldl (flip delete) [a,b] [c,d] = d `delete` (c `delete` [a,b])
16:12:54 <work_metaperl> Cale: yes, I understand what is being flipped. Note that I gave the type signature for a flip of delete
16:13:09 <ski> (= ([a,b] `flip_delete` c) `flip_delete` d)
16:14:06 <Cale> I suppose I don't know where your confusion is -- is what ski is saying making sense?
16:14:40 <work_metaperl> ski: are the things passed to a flipped.. oh they are
16:14:52 <work_metaperl> @flip (/) 1 2
16:14:52 * ski smiles
16:14:52 <lambdabot> Unknown command, try @listcommands.
16:15:01 <work_metaperl> @eval flip (/) 1 2
16:15:05 <lambdabot> 2.0
16:15:06 <mauke> int-e: could you improve your program if you knew the value of k?
16:15:12 <int-e> FWIW, the input is larger than 10 MB.
16:15:18 <ski> @eval flip (/) 3 5
16:15:19 <lambdabot> 1.6666666666666667
16:15:33 <int-e> so it requires more than 1 MB/s processing speed :/
16:15:49 <int-e> mauke: not really
16:16:08 <ski> work_metaperl : all o-kay ?
16:16:16 <work_metaperl> ski: the last step in your transformation series does not make sense to me
16:16:30 <ski> sorry, it was not last step, but next to last
16:16:47 <work_metaperl> I understand [a,b] \\ [c,d] = foldl (flip delete) [a,b] [c,d]
16:16:54 <work_metaperl> that makes sense to me
16:17:10 <ski> foldl (flip delete) [a,b] [c,d]   =   let flip_delete = flip delete in ([a,b] `flip_delete` c) `flip_delete` d   =   d `delete` (c `delete` [a,b])
16:17:23 <ski> se the first step ?
16:17:29 <ski> s/se/see/
16:17:36 <work_metaperl> @type foldl
16:17:38 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:17:54 <work_metaperl> so the "seed" becomes [c,d] in our example?
16:18:15 <Cale> no, it's [a,b]
16:18:27 <Cale> what you're removing things from is the seed
16:18:27 <work_metaperl> but normally the first argument is the seed
16:18:30 <ski> foldl f z [a1,a2,...,an] = (... ((z `f` a1) `f` a2) ...) `f` an
16:18:32 <rep> is there a way to include a module from the command line?
16:18:33 <Cale> and each step removes something
16:18:46 <Cale> [a,b] is the first
16:18:52 <work_metaperl> ski: i agree with your rewrite of foldl
16:18:59 <work_metaperl> oh!
16:19:10 <work_metaperl> that's what Cale was saying: FOLDL is NOT BEING FLIPPED
16:19:16 <Cale> exactly
16:19:17 <ski> :)
16:19:19 <work_metaperl> ok, let me think a bit more by myself
16:20:54 <ski> (Cale : "what you're removing things from is the seed" ?)
16:21:16 <ski> ah, sorry, nvm
16:21:25 <work_metaperl> ok, so instead of a delete which takes an element, a and a list [a], and removes the first occurrence of the element from the list, we have flip_delete() which takes a list [a] and an element a removes the first occurrence of the element from the list
16:21:41 <work_metaperl> is that correct? one thing at a time here
16:21:46 <ski> yes
16:21:57 <work_metaperl> ok, no I need to think some more by myself
16:21:59 <ski> flip just flips the order of the two arguments
16:22:03 <work_metaperl> yes
16:22:29 <work_metaperl> @type (\\)
16:22:30 <ski> then foldl inserts that in a left-associated way into the list (starting with [a,b])
16:22:30 <lambdabot> bzzt
16:22:36 <ski> @index (\\)
16:22:37 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
16:22:39 <mauke> @type (List.\\)
16:22:41 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
16:24:30 <work_metaperl> so... in our first iteration, we pass [a,b] and [c,d], with [a,b] being the seed and [c,d] being what we take c from and flip_delete takes those two arguments and tries to delete c from [a,b]
16:24:54 <ski> yes
16:25:06 <work_metaperl> and whatever list results from that, flip_delete tries to delete d from
16:25:36 <ski> or rather, it starts by trying to flip_delete d .. but that forces the flip_delete of c
16:26:35 <ski> (well, if it can determine that the thing is strict, then it wont bother with trying the outer flip_delete first)
16:27:03 <work_metaperl> that's pretty neat
16:27:10 <work_metaperl> ski: where did you learn haskell?
16:27:15 <work_metaperl> what book?
16:27:21 <ski> the craft
16:27:30 <work_metaperl> and how would you form the cross-product of 2 lists?
16:27:47 <ski> and at an uni course (and lots of own testing out etc .. :)
16:27:56 <work_metaperl> yes, I'm up through ch. 16 in craft... I dont appreciate his mis-statement about what a relation is.. but a good book nonetheless
16:27:59 <ski> [(a,b) | a <- as, b <- bs] ?
16:28:11 <work_metaperl> sweet
16:28:18 <ski> hm, what was that misstatement ?
16:28:38 <rep> uhm, it's really hard to obfuscate haskell code :(
16:28:40 <work_metaperl> ski: rather a gross understatement without qualifications: http://sequence.complete.org/node/109
16:28:53 <ski> @pl \as bs -> [(a,b) | a <- as, b <- bs]
16:28:53 <lambdabot> (. (return . (b <-))) . (:) . (((a, b) | a) <-)
16:28:56 <ski> hm
16:29:03 <work_metaperl> what does "pl" do?
16:29:08 <Heffalump> what the hel??
16:29:12 <mauke> it obfuscates haskell code
16:29:14 <Heffalump> @type (<-)
16:29:15 <lambdabot> bzzt
16:29:17 <Heffalump> @type (|)
16:29:18 <work_metaperl> omfg
16:29:18 <lambdabot> bzzt
16:29:23 <work_metaperl> jesus christ
16:29:24 <ski> @pl \as bs -> concatMap (\a -> map (\b -> (a,b)) bs) as
16:29:24 <lambdabot> liftM2 (,)
16:29:29 <ski> hehe
16:29:30 <Heffalump> that's not obfuscated, it's just WRONG
16:29:37 <ski> that was non-obfuscating
16:29:41 <Heffalump> @type (. (return . (b <-))) . (:) . (((a, b) | a) <-)
16:29:41 <mauke> it's BOTH
16:29:42 <lambdabot> bzzt
16:29:57 <mauke> obfuscated syntax errors!
16:29:59 <Heffalump> I think @pl failed to parse the comprehension.
16:29:59 <Igloo> Heffalump: It doesn't know about list comprehensions
16:30:04 <ski>  @pl doesn't understand list comprehensions
16:30:21 <rep> how does pl work anyway
16:30:38 <int-e> @pl (\a b c d -> a $ b $ c $ d)
16:30:39 <lambdabot> (. (.)) . (.) . (.)
16:30:43 <dons> term rewriting :)
16:30:44 <ski> work_metaperl : but as you saw 'liftM2 (,)' is the proper way to do cross-product :)
16:30:48 <int-e> that's just cute
16:30:51 <int-e> and unreadable
16:31:02 <work_metaperl> int-e: it's l33+
16:31:05 <work_metaperl> :)
16:31:09 <Heffalump> @pl \f g h -> h . g . f
16:31:10 <lambdabot> (flip (.) .) . flip (.)
16:31:31 <Heffalump> rep: it has Richard Bird embedded in it
16:31:48 <rep> heh
16:36:52 <ski> work_metaperl : re relations : i think he's using "(binary) relation on" rather than "(binary) relation between" .. in general one can n-ary relations (for n a natural number) .. (and one can regard these as relations over cartesian products, which brings one down to unary predicates again)
16:37:15 <work_metaperl> hmm
16:48:18 <Cale> rep: you're trying to obfuscate Haskell code?
16:48:27 <rep> kinda
16:48:45 <rep> i'm wondering how obfuscated haskell would look like
16:49:00 <rep> but it's clearly not easy to do
16:49:09 <dons> rep, we have an obfuscated ontest. it's easy!1
16:49:14 <rep> url pls
16:49:18 <Cale> well, there's are a veriety of techniques :)
16:49:31 <dons> http://www.cse.unsw.edu.au/~dons/pretty.html
16:49:44 <rep> thanks!
16:49:50 <rep> haha
16:50:21 <mauke> is whitespaceless haskell turing-complete?
16:50:46 <Cale> yes
16:51:09 <dons> and http://www.scannedinavian.org/iohcc/succzeroth-2004/
16:51:20 <Cale> I'm fairly sure you can avoid whitespace with parens in most places
16:51:55 <dons> also, yep. except in module names :/
16:52:05 <dons> and: http://www.cse.unsw.edu.au/~dons/crawl/crawl.hs
16:52:41 <dons> module(M)where{..} is invalid :/ that's a bug I think ;)
16:53:37 <mauke> hmm, what about python?
16:53:52 <dons> in fact, the module language is generally unfriendly. import(Foo) is no good.
16:54:14 <dons> a revision for haskell 2006!
16:55:39 <Cale> any relatively usable language is obfuscatable, in that you will be able to define things in an unintuitive way and choose poor names for things.
16:56:09 <dons> haskell is particularly good, I would argue, as we can use symbols for varids
16:56:39 <dons> also, we can rewrite all the code into lambdas if needed
16:56:59 <Cale> and CPS-transform everything :)
16:57:07 <sm> hi all
16:57:12 <Cale> hello
16:57:14 <sm> woah, this channel has grown
16:57:17 <dons> right! algorithmic obfuscation
16:57:25 <mauke> I still think @pl obfuscates in the general case
16:57:36 <dons> sm, how many nicks?
16:57:43 <sm> 162
16:57:51 <dons> oh, we had 186 this time yesterday
16:58:10 <sm> I'm reading the fine tutorial at http://www.haskell.org/~pairwise/intro/section1.html , and wondering why I can't enter the fibs example in either hugs or ghci
16:58:24 <Cale> sm: hugs and ghci only evaluate expressions
16:58:35 <Cale> you have to put declarations in a file
16:58:39 <sm> but he *said* they'd work
16:58:41 * sm cries
16:58:58 <Cale> you put the declarations in a file and load it with hugs or ghci
16:59:25 <mauke> ghci lets you define things with "let"
16:59:49 <Cale> yes, it does, if you don't care about hanging on to the definitions that you make
16:59:59 <Korollary> sm: let fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)] in take 10 fibs
17:00:16 <sm> thanks, got it
17:00:28 * work_metaperl heads home
17:00:33 <sm> I'm wondering how such a nice tutorial could get first hurdle so wrong
17:00:40 <mauke> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
17:00:56 <sm> oh well
17:01:01 <mauke> sm: where does it say to paste it in ghci/hugs?
17:01:19 <Cale> sm: my favourite tutorial is "Yet Another Haskell Tutorial"
17:01:48 <mauke> in fact, it tells you exactly what to do: http://www.haskell.org/~pairwise/intro/section1.html#part2
17:01:55 <sm> mauke: you're right, it doesn't
17:02:22 <sm> "Until then, use GHCi or Hugs to try the examples." just sounds like you can type in the first examples, which looks "expressionish"
17:02:28 * Korollary starts watching NHL, yay
17:02:40 <sm> why ? because it's on one line, what else could it be :)
17:03:47 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
17:04:04 <sm> not complaining here mind, but that does raise the bar for having fun with this thing.. I was hoping to do a quick paste
17:04:23 <sm> why don't the interactive prompts let you type in declarations  ?
17:05:01 <ski> declarations in a file are all (potentially) mutually recursive
17:05:13 <Korollary> that would be nice. But, it's in the long wrong more convenient just to write them to a file and reload it as you modify.
17:05:17 <ski> hard to get that in an interactive toplevel
17:05:42 <Cale> You should keep a window open with an editor, and when you're done typing your declaration, save it, and type :re in your window with ghci
17:05:54 <Cale> which will reload the file
17:06:32 <sm> ok, thank you
17:06:40 <sm> I'll suggest that he add this note
17:07:36 <Korollary> We should start a #haskell tutorial effort
17:07:45 <Korollary> with 180 people on board
17:08:29 <sm> or not, since there's no contact address
17:08:41 <sm> eric etheridge, you wouldn't be here by chance would you ?
17:08:53 <Cale> I wonder if Hal Daume would open the source to YAHT :)
17:10:02 <Cale> sm: also, seriously, try YAHT -- it's practically a book :)
17:10:38 <sm> thanks Cale.. I have, and will again
17:10:43 <Cale> there are some issues with it
17:10:57 <Cale> It shouldn't bother to mention CPS so early
17:11:15 <Cale> Or should mark that section as optional
17:14:48 <Cale> after you have the basics of the language down though, probably the best thing to do is to write small programs and read the prelude and standard libraries docs.
17:15:29 <Cale> and look around on the Wiki and mailing lists :)
17:19:01 <Cale> perhaps more people should work on the wikibook for Haskell
17:19:07 <ski> (and check out the irc channel i've heard about)
17:19:11 <Cale> heh
17:19:53 * sm lets fibs run wild
17:19:57 <sm> hurrah!
17:21:06 <ski> "* jemfinch just printed an infinite list.  <Pseudonym> Quick, type control-C before you run out of bits!"
17:26:06 <dons> @seen SyntaxNinja
17:26:07 <lambdabot> I saw SyntaxNinja leaving #haskell 5 days, 9 hours, 2 minutes and 10
17:26:07 <lambdabot> seconds ago, and I have missed 51 seconds since then.
17:29:23 <Cale> Is the category of Haskell types a topos, or does it fail in some way? It seems like it would be.
17:30:32 <Cale> oh, perhaps it isn't
17:31:11 <Cale> It doesn't seem to have equalizers.
17:35:21 <Cale> I wonder just how incredibly troublesome it would be to extend the Haskell typesystem with equalizers and coequalizers.
17:37:21 * araujo reading about class of types
17:37:34 <araujo> Beautiful.
17:37:49 <Cale> araujo: typeclasses?
17:38:08 <araujo> Oh yeah, that one, sorry formy _odd_ english :-]
17:39:17 <Cale> hehe - it's not so odd, just that as I was talking about category theory to myself up there, you might mean something else by 'class' :)
17:39:33 <araujo> oh , ok :-)
17:39:47 * araujo admits he doesn't know about category theory
17:40:01 <wagle> Cale: what would an equalizer be in haskell?
17:40:08 <araujo> I got a pile of haskell stuff here i am trying to slowly assimilate :-[
17:40:20 <araujo> oh, wrong face, :-]
17:41:20 <Cale> wagle: Given a type X, and a pair of functions f,g: X -> Y, a new type consisting of only the elements of X such that f(x) = g(x). Seems not statically computable :)
17:41:33 <araujo> A doubt about terminology, is 'generics' the same than 'polymorphism' ?
17:41:46 <wagle> subtype?
17:41:53 <Cale> wagle: yes
17:41:54 <wagle> supertype?
17:41:59 <Cale> subtype
17:42:24 <Cale> and a particularly odd sort of subtype at that
17:42:36 <wagle> i would think a subtype would extend X
17:42:40 <Cale> no
17:42:44 <wagle> but i'm not thinking carefully
17:42:51 <Cale> it restricts X to a subset of its elements
17:43:28 <wagle> f <= g if forall x f(x) = g(x)
17:43:40 <Cale> hm?
17:44:05 <wagle> <= is weaker than, subtype of, or i dunno
17:44:37 * wagle starts thinking carefully
17:44:47 <Cale> If f,g : X -> Y, the equalizer type [f = g] consists of the "solutions" to the equation f x = g x.
17:45:16 <wagle> bisimulation?
17:45:32 <Cale> not sure what that means
17:45:50 <wagle> "observationally equivalent"
17:45:59 <Cale> yeah
17:46:03 <Cale> I think
17:46:11 <wagle> sorry, i'm really slow today..  8(
17:46:14 <Cale> Well, in however you'd want to talk about it
17:46:33 <Cale> If you include _|_ as a value, then you probably want to respect it as well.
17:47:24 <wagle> this is interesting
17:47:27 <Cale> we might be able to get away with coequalizers though.
17:48:40 <Cale> You take two functions f,g: Y -> X, then you make a new type where the two elements of X,  f y and g y  are identified for each y in Y.
17:49:38 <Cale> hmm
17:49:39 <wagle> i'm largely going from the definition in http://math.ucr.edu/home/baez/topos.html
17:50:01 <Cale> that definition is probably good enough :)
17:50:58 <Cale> actually, coequalizers seem kind of hard too
17:51:05 <Cale> pattern matching gets difficult.
17:51:59 <wagle> my brain want to roll over and go back to sleep..  mumble
17:52:00 <Cale> But I've heard of topoi which characterise constructive mathematics
17:52:51 <wagle> f and g are types?
17:52:56 <Cale> f and g are functions
17:53:00 <Cale> X and Y are types
17:53:50 <Cale> Haskell doesn't seem to have equalizers and coequalizers, but if it did, you could do all sorts of fun tricks :)
17:54:29 <Cale> actually, I think that adding them would almost certainly make the type system undecidale
17:54:41 <Cale> undecidable*
17:54:44 <wagle> @eval [x | x <- [1..], (+2) x == (*2) x]
17:54:58 <lambdabot> Terminated
17:55:02 <wagle> aww
17:55:08 <dons> poor wagle ;)
17:55:08 <Cale> :)
17:55:44 <int-e> Hmm, I think the SPOJ problems (at least the few I've looked at) are too algorithmic / trivial for Haskell to shine, and the emphasis is on performance; abstracting from the problems is hardly possible. I've also got the impression that ghc 6.4.1 is a great deal better at optimizing than ghc 6.2.1 was.
17:55:52 <wagle> i should at least have gotten (2 : _|_)
17:56:24 <dons> int-e, not sure why ghc 6.4.x would be better  at optimizing. no new optimisations were added, afaik
17:56:25 <Cale> @eval take 1 [x | x <- [1..], (+2) x == (*2) x]
17:56:27 <lambdabot> [2]
17:56:46 <wagle> Cale: now prove that
17:56:58 <int-e> dons: then my impression is wrong. I have no hard numbers, mind you.
17:57:05 <Cale> what, that 2 is the only element?
17:57:15 <wagle> i think
17:57:27 <wagle> i think thats the problem
17:57:41 <Cale> suppose that x + 2 = 2*x. Then 2 = 2x - x = x.
17:58:07 <dons> int-e, the backend was rewritten to use C--, but this only sped ghc up, I don't think it actually improved the code significantly, as all the optimisations are done on Core, which didn't change
17:58:09 <Cale> Easy enough for me, but try getting the typechecker to do it :)
17:58:10 <wagle> Cale: yeah, i mean have haskell prove that
17:58:14 <Cale> yeah
17:58:26 <Cale> exactly
17:58:44 <dons> hmm.. list comprehensions on the type level
17:58:45 <int-e> dons: hmm. were there significant library changes with respect to file IO?
17:58:59 <dons> I don't think so, no.
17:59:07 <dons> unless you're using FastPackedStrings ;)
17:59:13 <int-e> I'm not.
17:59:19 <wagle> i've done loop inverters of toy versions of parallel fortran that do solve equations like that
17:59:46 <Janni> Hi.
18:00:04 <Janni> Coming with another Parsec question. I'll be right off then. I'm tired...
18:00:09 <Cale> Of course, it's easy with dynamic typing, but that's cheap :)
18:00:47 <Cale> the whole challenge is proving things statically and not just checking them at runtime :)
18:01:37 <Janni> When parsing two patterns having the same beginnis (e.g.: string "/muh" <|> string "/maeh"), you have to use "try" for the first pattern, otherwise the other won't be accepted. So far so good.
18:01:57 <Cale> yep
18:02:52 <Janni> But what I really don't like is then when I do "parseTest (try (string "/muh") <|> string "/maeh") "x", I only get the error message "expecting "/maeh""
18:03:31 <Cale> perhaps give a name to the whole parser
18:03:34 <Cale> using <?>
18:03:34 <Janni> But what I want is a message "expecting "/muh" or "/maeh".
18:05:05 <Cale> It's better still to factor out the initial part of the parsing
18:05:09 <Janni> Of course, but isn't what I described some kind of misbehaviour?
18:05:33 <Cale> If you factor out the common initial segment, then you don't need to use try
18:05:52 <Cale> It sort of is, but I think I can see why it's happening
18:05:59 <Janni> I know, but my Parser gets quite complex, so this would be hard...
18:06:17 <wagle> how would it remember that it tried /muh first?
18:08:46 <Janni> I think it shouldn't be too hard. What could do is s.th. like: try /muh. if /muh fails then try the next thing, appending "/muh" to the error message if it fails. (Is this understandable? :)
18:09:33 <wagle> Cale: maybe you might get something (co) equalizer(ish) with polymorphism?
18:09:55 <wagle> "f and g can't inspect the values X"
18:10:47 <wagle> Janni: i've never used parsec, so I can only deal in generalities about parsers, monads, etc
18:11:32 <wagle> I'm just thinking that the monads that parsec uses probably dont pass around a stack of "potential errors"
18:11:41 <wagle> but i could be wrong
18:12:10 <Cale> wagle: it is able to give surprisingly detailed information about what it's expecting at any point if it doesn't get it
18:12:16 <wagle> if you could get try
18:12:28 <wagle>                (string "/muh") <|> string "/maeh")
18:12:33 <wagle> ick
18:12:38 <wagle> paste didnt work
18:13:52 <wagle> Cale: so it can, say, remember which productions it tried to apply to the current token?
18:21:59 <dons> @ping dcoutts, Lemmih
18:22:01 <lambdabot> bzzt
18:22:02 <dons> oh, no @ping
18:22:12 <dons> @seen dcoutts, Lemmih
18:22:13 <lambdabot> I haven't seen dcoutts,.
18:22:21 <dons> silly lambdabot, silly dons
18:22:25 <dons> @seen dcouttts
18:22:26 <lambdabot> I haven't seen dcouttts.
18:22:29 <dons> @seen dcoutts
18:22:30 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #haskell-blah and #unicycling
18:22:30 <lambdabot> . I don't know when dcoutts last spoke.
18:22:35 <dons> @seen Lemmih
18:22:36 <lambdabot> Lemmih is in #unicycling, #haskell-blah and #haskell. Last spoke 4
18:22:36 <lambdabot> hours, 57 minutes and 31 seconds ago.
18:29:05 <Janni> Bye. Have to sleep. Thanks for the help. G'night.
19:52:07 <dons> building ghc-api feels just like building ghc
19:53:03 <Leimy> takes all damn day? :)
19:53:45 <dons> right ;)
19:56:12 <dons> ah, doessn't take long at all, in fact
19:56:15 <dons> no libs to build
19:56:21 <dons> but it sure works the cpu over
21:09:17 <Korollary> what kind of buffering does getContents do ?
21:19:47 <WolfgangThaller> hello everyone :-)
21:20:21 <Korollary> hello and congrats
21:20:51 <WolfgangThaller> thx
21:21:30 <WolfgangThaller> I feel strange in here with my full name for a nick, but my first name is already taken; and anything less and people won't recognize me :-(
21:24:04 <Pseudonym> Sorry, I must be out of it.  What are the congrats for?
21:25:19 <Korollary> ICFP
21:25:26 <Pseudonym> Ah, yes!  Congrats!
21:27:35 <WolfgangT> :-)
21:28:07 <WolfgangT> so what's going on on the channel these days? it's been a while for me....
21:30:06 <Korollary> it hit 187 users yesterday afaik
21:30:13 <Korollary> clients, that is
21:30:27 <Pseudonym> Aaargh!  Weasel word!
21:30:39 <Pseudonym> Now even IRC channels are calling people "clients".
21:30:41 <Pseudonym> :-P
21:30:53 <WolfgangT> lol
21:30:57 <int-e> Pseudonym: you wouldn't call lambdabot a user, would you?
21:31:15 <Pseudonym> Well... I'd ask first.
21:31:29 <WolfgangT> but didn't he pass the turing test long ago and should therefore be considered a person?
21:31:34 <int-e> @vixen would you mind being called a user?
21:31:37 <lambdabot> the question isn't would i, but should i
21:31:40 <lambdabot> I prefer "biologically challenged".
21:32:16 * Korollary synergizes the haskell mindshare for the core competencies
21:32:47 * Pseudonym rightsizes the customer communities
21:32:55 <Pseudonym> Gnarly.
21:34:10 * int-e thinks Dilbert.
21:34:43 <Korollary> so, what kind of buffering does getContents do ?
21:34:47 <lambdabot> By the way, I only passed the Turing test because the human under
21:34:47 <lambdabot> test was really stupid.
21:35:53 <WolfgangT> but you are doing well right now, lambdabot.
21:36:14 <lambdabot> I suspect she was a real gestalt psychologist and was mistaken for
21:36:14 <lambdabot> Eliza.
21:43:23 <Pseudonym> OK, here's the thing.
21:43:29 <Pseudonym> I have to write up some stuff for a certain person.
21:43:40 <Pseudonym> This certain person wrote a book called "Writing for Computer Science".
21:43:49 <Pseudonym> I suspect I should take some care writing up this stuff, no?
21:44:29 <Korollary> Why would you want to do that ?
21:44:44 <Pseudonym> True.  He might enjoy correcting it.
21:45:10 <int-e> Korollary: seems to depend on stdin's buffering mode. the default seems to be similar to libc - line buffering for terminals, block buffering for other input.
21:45:57 <Korollary> int-e: I see. I was wondering why this was so slow: http://shootout.alioth.debian.org/benchmark.php?test=sumcol&lang=ghc&id=0&sort=fullcpu
21:56:52 * int-e has no idea.
21:57:18 * int-e is impressed how much of the required mechanisms for that are actually implemented in Haskell.
22:18:16 <ski> Cale : by subtype, do you mean subobject ?
22:18:38 <dons> hi WolfgangT
22:18:52 <dons> oh, too late
22:25:35 <Cale> ski: no, I don't think so
22:26:57 <Cale> though probably subtypes and subobjects of types could be identified
22:27:00 <ski> took me a while before i realized that subtyping isn't just build from subobjects ..
22:27:21 <ski> i think we need to throw in quotient-objects
22:27:37 <ski> for records
22:28:16 <ski> (at least in sufficiently Set-like cats ..)
22:28:56 <ski> (btw, one topos for constructive math is Hylands iirc)
22:29:59 * ski has pondered supporting retract-types in haskell
22:30:28 <gzl> I remember they mentioned the Hyland topos as a topic in the "Ideas in Mathematics" course here. the one for people who can't do any actual math. I don't know what they were thinking.
22:32:36 <Cale> what's a retract type?
22:32:58 <ski> just a type defined by a retraction
22:33:20 <ski> um, retraction-section pair, that should be
22:34:32 <ski> s : A -> B , r : B -> A   r . s = id_A
22:34:58 <Cale> okay, and so you define B by the image of S?
22:35:07 <Cale> er s
22:36:18 <ski> retracttype Rational = To {from :: (Integer,Integer)} where from (To (n,d)) = (n `div` o,d `div` o) where o = n `gcd` d
22:36:31 <ski> e,g,
22:37:27 <Cale> ah, okay
22:37:43 <ski> (Rational,(Integer,Integer),To,from) corresponding to (A,B,r,s)
22:37:48 <Cale> yes
22:38:02 <ski> this could either be implemented lazily or strictly
22:38:37 <ski> i.e. either with canonical representative or with any equiv class representant
22:38:43 <Cale> er
22:38:46 <Cale> (A,B,s,r)
22:38:49 <Cale> ?
22:38:56 <ski> hm ,lemme double-check
22:39:53 <Cale> r . s = id_A so you want s to be monic, and r to be epic.
22:40:03 <ski> To . from = id :: (Integer,Integer) -> (Integer,Integer)
22:40:09 <ski> hm
22:40:17 <int-e> (B,A,s,r)?
22:40:18 <ski> ah, nono
22:40:19 <Cale> oh?
22:40:27 <Cale> To . from shouldn't be id
22:40:27 * ski is stupid
22:40:35 <ski> indeed
22:40:48 <ski> retracttype Rational = To {from :: (Integer,Integer)} where To (from (n,d)) = (n `div` o,d `div` o) where o = n `gcd` d
22:40:52 <ski> should be
22:41:18 <ski> from . To = id :: Rational -> Rational    -- is correct
22:41:24 <Cale> right
22:41:55 <ski> which means   (Rational,(Integer,Integer),from,To) corresponding to (A,B,r,s)
22:42:47 <Cale> yep
22:44:56 <ski> it would be interesting if one could use the equiv.class representation, and don't have to canonicalize when patternmatching in internal operations ..
22:45:35 <ski> e.g. To (n0,d0) == To (n1,d1) = n0*d1 == n1*d0
22:45:55 <ski> but it is prolly hard to determine when this is safe
22:45:59 <Cale> yes
22:46:19 <Cale> that would basically give you equalisers
22:46:43 <Cale> which I think would make the type system undecidable
22:46:45 <ski> (the other option in which one canonicalizes on use of To, and where from is operationally a noop is simpler in this respect)
22:47:47 <ski> also, one would have to check that To . from actually is idempotent
22:47:49 <Cale> hmm... does that give you equalisers...
22:48:01 <ski> i'm not sure if it does
22:49:21 <int-e> ski: To.from.To.from = To.id.from = To.from?
22:49:24 <Cale> or no, coequalisers
22:49:55 <Cale> hmm...
22:50:08 <Cale> well, it's some kind of limit, I'm sure :)
22:50:41 <ski> int-e : yes, it should be idempotent .. but assume i'd defined above  To (from (n,d)) = (n+1,d+1) ..
22:51:32 <int-e> ok
22:52:25 <ski> (Cale : possibly, the 'lazy' (equiv.class) and the 'strict' (canonical representant) variants needn't always give rise to same retract A of B ..)
22:53:19 <skew> hi, does anybody have some good multithreaded programming puzzles to show how cool STM is?
22:58:02 <Cale> ski: yeah, if you have the ability to quotient types by equivalence relations like that, you basically have coequalisers.
22:58:15 <ski> ok
22:58:36 <Cale> I'm not sure if that's a problem -- I know that equalisers would be trouble :)
22:59:01 <Korollary> skew: I think this one is a famous problem : http://www.csl.mtu.edu/cs4411/www/PROG/PG2/prog2.html
22:59:26 <ski> i guess the 'lazy' variant would yield a quotient, right ?
22:59:55 <Cale> yeah
22:59:56 <ski> would the 'strict' variant yield a subobject then (and then connect with equalizers) ?
23:00:34 <ski> using To/s as the mono
23:01:08 <Cale> hmm...
23:02:07 <Cale> I think they're both "coequaliser" type things to some extent.
23:02:08 <ski> (i think retraction-section is pretty symmetric .. so if it can connect with coequalizer .. i think it should prolly connect with equalizers, too (not necessarily at same time, though ..))
23:02:19 <ski> (or .. maybe i need to flip A and B ..)
23:02:38 * ski can't think very clearly at it atm
23:02:39 <Cale> An equaliser would let you take some type and restrict it to a subset of its values by an equation.
23:02:58 <ski> yes, that would be the canonicalization, i figure
23:03:42 <ski> hm
23:04:07 <Cale> For example, I could define the type [(x,y) in (Integer,Integer) | y = x^2]
23:04:48 <ski> i'm not so clear how to connect retracts with (co/)equalizers
23:04:49 <Cale> (or y == x^2)
23:05:12 <basti_> what are you talking about?
23:05:42 <Cale> Well, you're forcing a retract by constructing B
23:05:56 <ski> basti_ : retracts, equalizers, coequalizers, quotients, subobjects   and the possibility of having any of these in haskell
23:06:07 <Cale> and I think that the B that you want is a given coequaliser
23:06:10 * ski thought he constructed A from B
23:06:13 <Cale> oh
23:06:16 <Cale> yes, A
23:06:17 <Cale> hehe
23:06:30 <basti_> ski: i realized that, but i can't imagine what that would be like.
23:06:33 <ski> B being (Integer,Integer) above  (and A being Rational)
23:06:45 <Cale> right
23:07:00 <ski> basti_ : you are not alone, we are not fully sure, either :)
23:07:05 * basti_ laughs
23:07:35 <Korollary> Is there a reason why one would want these in haskell ?
23:07:40 <Cale> So you look at your equivalence relation on (Integer,Integer) defining the rationals, and let f,g be the projections of that relation
23:07:48 <ski> Korollary : fun ? :)
23:08:07 <Cale> that is f (x,y) = x, g (x,y) = y
23:08:07 <ski> Korollary : better understanding of Abstract data types ?
23:08:33 <Korollary> ski: I think the right answer is along the lines of "because we can" ;)
23:08:47 <Cale> Korollary: well, if we had all of them, Haskell would be closer related to the realm of mathematics, because it would be a topos :)
23:08:53 * ski thinks many ADTs fits the pattern of either canonical values in a type or equivalence classes over a type
23:09:26 <ski> Cale : hm
23:09:41 <Korollary> Heh. Cute. New language wars: "Is your favourite language a topos, hmm ?"
23:10:06 <Cale> but I think that there are practical issues with adding things like equalisers
23:10:11 <ski> Cale : what would f and g be in my example ?
23:10:29 <skew> Korollary: that looks like a pretty complicated problem
23:10:46 <ski> or rather, would you then do [(x,y) | f x == g y] ?
23:11:48 <ski> hm .. wait .. you said f and g were projections ..
23:11:50 <Cale> let me work it out :)
23:11:59 <ski> hm, talking about pullbacks, now ?
23:12:19 <Cale> not quite, but all of these things are related
23:12:24 <ski> yep
23:13:03 <Cale> oh
23:13:07 * ski started with two ADT intuitions and thought they fit quite well into the retract concept
23:13:28 <Cale> okay
23:14:31 <ski> strict) we approximate the (abstract) type we want by a concrete representation type, and ensure to use just some canonical/allowed/used values in that type (by hiding)
23:15:24 <Cale> ah, there's an issue, because we don't already have a suitable type to represent our relation
23:15:36 <Cale> but if we did...
23:15:50 <ski> lazy) we approximate the (abstract) type we want by a concrete representation type, and each abstract value corresponds to an equivalence class of values in the concrete type .. we should here ensure that difference between different representants in same equiv.class should not be detectable from outside
23:16:00 <Cale> Let's say there was a type consisting of the pairs of pairs ((a,b),(c,d)) where a*d = b*c
23:16:18 <ski> mhm
23:16:19 <Cale> and take f ((a,b),(c,d)) = (a,b)
23:16:27 <Cale> and g ((a,b),(c,d)) = (c,d)
23:16:49 <Cale> Then the equaliser of these two maps is the rational type.
23:17:09 <ski> mhm, have to think on that ..
23:17:57 <Cale> er
23:17:58 <Cale> no
23:18:02 <Cale> coequalizer, sorry
23:19:13 <int-e> (and it maps each pair (a,b) to the rational number a/b [or b/a, whatever])
23:19:19 <Cale> yeah
23:19:33 <ski> strict) we canonicalize when we put things inside the concrete type .. so internal operations can rely on getting canonical values .. applying the "constructor" automatically canonicalizes
23:20:59 <Cale> We have the diagram  [((Int,Int),(Int,Int)) | a*d = b*c] ==f,g===> (Int,Int) ----> Q
23:21:17 <ski> lazy) we canonicalize when we take things out of the concrete type .. so internal operations must ensure they do not allow discrimination of different representants in same equiv.class from outside (or we could say the deconstructor always canonicalizes .. but it's often more officient not to do this)
23:22:02 * basti_ mouth stays open
23:22:04 <int-e> Cale: now what happens if your Relation is the lambda calculus reduction relation?
23:22:32 <ski> Cale : hm .. think i get that
23:23:03 <ski> int-e : which relation ?
23:23:12 <Cale> int-e: Well, you get the type of lambda terms modulo that equivalence
23:23:43 <Cale> ski: I think he's referring to alpha+beta+eta
23:23:53 <int-e> Hmm. Sounds like an evil thing to require from a type system.
23:24:28 <ski> Cale : yes but which 'your Relation' ?  ... hm .. maybe \(x,y). f x = g y  actually
23:24:29 <int-e> Cale: right
23:24:53 <int-e> ski: the subtype of T x T where T is a basetype. [((Int,Int),(Int,Int)) | a*d = b*c] in the running example
23:24:54 <Cale> It is troublesome
23:25:15 <Cale> but it requires creating a type you probably don't have anyway
23:25:36 * ski doesn't understand which type int-e would get with this ..
23:25:40 <Cale> which is the type consisting only of the pairs which are equivalent under that relation
23:26:04 <Cale> ski: he'd get the type of lambda terms up to equivalence
23:26:12 <ski> T being ?
23:26:31 <Cale> lambda terms
23:26:36 <ski> ah, ok
23:26:41 * ski is slow this morning
23:28:02 <Cale> However, there would be problems with defining the subtype of TxT desired in the first place.
23:28:14 <int-e> Cale: hmm, but I can define [(t1, t2) | t1 reduces in one step to t2] - doesn't the coequalizer construction find the transitive closure for me?
23:29:10 <Cale> hmmm
23:29:20 <Cale> quite possibly
23:30:29 <Cale> or it just doesn't exist
23:30:54 <Cale> ah
23:30:58 <Cale> no, you're right
23:31:01 <Cale> it would
23:32:07 <Cale> It would give T modded out by the equivalence relation generated by f x = g x for every x in the relation, where f and g are the projections.
23:32:50 <Cale> However, so far this is all dependent on having particular subtypes around.
23:34:11 <Cale> however, I'm also not so sure a full type U and a different pair of maps U ===f,g===> T wouldn't work.
23:35:38 <Cale> I agree that it's likely not computable :)
23:36:42 <Cale> But we probably don't need all coequalisers to exist
23:36:54 <int-e> yeah
23:39:35 <Cale> It would be awfully nice to have coequalisers in general, which together with the coproduct would give us cocompleteness :)
23:39:48 <int-e> Hmm. Given a relation R subset X x X and projections f, g, define f' : X x X -> X x X + X, f' = id|(X x X - R) + f. and g' likewise. (that's the identity from X x X, restricted to X x X - R) ... that'd be total types, right?
23:40:59 <Cale> yep
23:41:26 <int-e> and the equalizer would be X x X - R + the equalizer of f and g.
23:41:54 <int-e> err. coequalizer
23:41:57 <Cale> yes
23:42:28 <int-e> ok. I'd conclude they are not computable in general.
23:42:35 <Cale> :)
23:44:36 <Cale> oh, sorry, not full completeness, probably just limits over finite index categories, hmm... anyway, it's too much to ask :)
23:48:12 <Cale> I wonder whether it would be appropriate to add  "data Empty" to the prelude, just so that there would be a canonical initial object.
23:48:37 <Cale> Probably wouldn't get too much use :)
23:49:09 <int-e> but it's perfect for representing errors.
23:49:37 <basti_> :-o
23:50:38 <Cale> Has anyone looked into adding a type-equality predicate to the class system?
23:50:55 <dons> hmm, I'm sure I've read papers on this, Cale
23:51:05 <Cale> HList really wanted one
23:51:12 <dons> in some paper related to the lightweight generics stuff
23:53:48 <Cale> oh, sorry, that isn't an initial object due to _|_
23:58:21 <Lemmih> dons: pong.
23:58:41 <int-e> Cale: hmm, if all types have _|_ that isn
23:58:45 <int-e> 't a problem, is it?
