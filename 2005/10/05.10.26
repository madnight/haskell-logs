00:00:08 <Cale> okay
00:01:22 <Cale> so when we're working out the type, let's say we have some desired state type S and some desired return type A, and we want the type of runState (do {...; return x}) initialState to be (A,S)
00:01:48 <sethk> Cale, I understand completely about how it works
00:01:59 <sethk> Cale, I'm just trying to make that fit with the types in the documentation
00:03:04 <Cale> I'm getting to it :)
00:03:34 <Cale> so, assuming that initialState is of type S, we get that runState (do {...; return x}) :: S -> (A,S)
00:04:17 <Cale> so since runState :: State s a -> s -> (a,s), we get that (do {...; return x}) :: State S A
00:04:39 <Cale> now, we want to know what type x must be
00:05:54 <sethk> ok...
00:06:53 <Cale> the type of a do-block is the same as the type of its last line
00:07:29 <Cale> so return x :: State S A
00:07:40 <Cale> now, our monad is State S
00:07:58 <Cale> and given a monad m and type a,  return :: a -> m a
00:08:49 <Cale> so return :: A -> State S A, and we can deduce that x must be of type A
00:09:24 <Cale> (and not (A,S))
00:09:28 <sethk> Cale, yes, obviously, if the monad is State s then there are no mysteries
00:09:39 <Cale> okay :)
00:09:41 <sethk> Cale, I thought the newtype was defining the monad
00:09:54 <Cale> it is, somewhat, but it's sort of doing more than that
00:10:06 <Cale> It's defining a whole family of related monads
00:10:32 <sethk> Cale, ok, that's fine.  If the monad is State s then everything is quite clear
00:10:43 <Cale> that's what it means by "parametrised"
00:11:46 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS.html -- here's a crazier example
00:12:35 <Cale> I've never actually seen it used for anything.
00:13:08 <Cale> (it's a reader, a writer, and a state monad, all in one)
00:13:25 <boegel> did we ever reach the 200 border last night ?
00:14:23 <eivuokko> I dunno, but < shapr> Neat, we had 204 earlier.
00:15:27 <Cale> I wonder what percentage of Haskell users come here :)
00:15:34 <eivuokko> Hehe
00:16:36 <Cale> I actually know a bunch who don't
00:17:38 <dons> a fair few don't come here. several thousands at least :)
00:18:12 <dons> considering a few hundred are taught each year at unsw, and only 6 or so of them are online :}
00:18:15 <dons> counting lambdabot
00:19:07 <eivuokko> Is haskell teaching language there?
00:19:07 <glguy> my solver works when no guessing is needed...
00:19:13 <glguy> I didn't think about needing guessing at first
00:19:21 <glguy> I was pulling my hair out trying to figure out what I did wrong
00:19:22 <glguy> :)
00:19:29 <dons> eivuokko, entry level language, yep.
00:19:40 <eivuokko> Cool.
00:19:45 <dons> and in some higher courses too. similar to chalmers, utrecht etc
00:19:52 <Cale> glguy: sudoku?
00:20:23 <glguy> yeah
00:23:09 <C-Keen> re
00:24:17 <vegai> 7how many of those hundreds per year like the language?
00:29:31 <eivuokko> Uhm, trying to read State-discussion before, what's the meaning of "| m->s" in "class Monad m => MonadState s m | m -> s"?  I can't find it quickly in report either :o
00:30:36 <Cale> eivuokko: it's a functional dependency -- the reason you can't find it in the Report is that it's not Haskell 98
00:30:43 <eivuokko> Grrr.
00:30:44 <Cale> it means that m determines s
00:31:02 <Cale> that is, for a given monad m, there can be only one state type s
00:31:09 <Cale> this aids type inference a lot
00:31:11 <eivuokko> Thanks.
00:31:18 <gour> dcoutts_: ping
00:31:21 <Cale> and also creates some guarantees :)
00:31:38 <eivuokko> Does ghc allow it for instances?
00:31:49 <Cale> It's a class declaration thing
00:31:56 <eivuokko> Hmm.
00:32:16 <eivuokko> I need to read up then, I don't see why :)
00:32:22 <Cale> though actually, that's a good point
00:32:58 <dons> for a particular instance you define an 's'. it's like getting extra types with your classes
00:33:19 <gour> dons: hi
00:33:25 <dons> we use it in lambdabot for example, to have each instance of a plugin have its own internal state type
00:33:28 <dons> hey gour
00:33:33 <eivuokko> Hmmm.
00:33:48 <gour> dons: dcoutts is not online, can you do me a favour?
00:33:54 <dons> maybe.. :)
00:34:12 <Cale> eivuokko: you might write something like class VectorSpace f v | v -> f where { scalarMult :: f -> v -> v ; ... }
00:34:14 <eivuokko> Ok, I already support this technique.  I had problem of describing some types used inside plugin-alike inteface.
00:34:28 <gour> dons: :-)  soon i have to go out and won't be online
00:34:46 <gour> dons: and i just noticed that gconfdemo in gtk2hs segfaults
00:34:58 <gour> dons: so maybe he would be interested to know it
00:35:02 <dons> oh. hmm. what OS? what ghc?
00:35:12 <dons> he definitely will want to know
00:35:26 <gour> gentoo, ghc-6.4.1, amd64
00:35:53 <dons> better tell him then. or even post a bug report on gtk2hs-users@
00:35:56 <gour> can i paste you error?
00:36:13 <dons> sure, but i don't know much about gtk2hs
00:36:27 <Cale> dons: I think he wants you to relay the message
00:36:41 <dons> ah, I see. sorry :)
00:36:41 <gour> well, just present it to him, irc is probably quicker
00:36:45 * dons is sleepy
00:36:52 <eivuokko> Cale, thanks.  Unfortuntely this doesn't mean much to me as my math's are not up to speed to get your example.  I'm gonna find some paper to read about this stuff :)
00:36:53 <Cale> gour: I could probably get you his email address
00:37:02 <eivuokko> Thanks to dons, too :)
00:37:02 <dons> yep. ok. got a link to the bug log?
00:37:16 <gour> Cale: i have it, but he is quicker with irc :-)
00:37:20 <Cale> ah
00:37:20 <ibid> gour: why don't you just do a "dcoutts: ..." and let him read it from the away log? :)
00:37:28 <dons> eivuokko, check the ghc user's guide
00:37:40 <dons> there's a section on type system extensions.
00:37:42 <gour> ibid: ok, will do
00:37:47 <dons> which should have examples and such like
00:38:02 <gour> dcoutts: something for you - gconfdemo on amd64
00:38:05 <eivuokko> Oh, I should really stop underestimating ghc guide.  /me considers printing it
00:38:12 <gour> gour@gaura-nitai ~/tmp/gtk2hs-0.9.9.7/demo/gconf $ ./gconfdemo
00:38:12 <gour> (process:31535): GLib-GObject-CRITICAL **: gtype.c:2254: initialization assertion failed, use IA__g_type_init() prior to this function
00:38:12 <gour> (process:31535): GLib-GObject-CRITICAL **: g_object_new: assertion `G_TYPE_IS_OBJECT (object_type)' failed
00:38:12 <gour> (process:31535): GLib-GObject-CRITICAL **: g_object_ref: assertion `G_IS_OBJECT (object)' failed
00:38:13 <gour> Segmentation fault
00:38:24 <dons> nice bug gour :)
00:38:34 <gour> dcoutts:  :-)
00:38:42 <ibid> that sounds like initGUI is not being called
00:39:04 <gour> dons: greet him when he gets online, now i have to go
00:39:16 <gour> ibid: all other demos work :-{}
00:39:22 <gour> by folks, see u later
00:39:33 <dons> eivuokko, you don't need to print it, it's online! http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies
00:39:41 <boegel> CosmicRay: no HWN yet ?
00:40:34 <eivuokko> dons, for some reason I read paper versions much faster.  (And I have that pdf open already btw)
00:40:43 * ibid wonders if it'd be worth it to write a section on my course to HCAR
00:41:15 <dons> ah, but .pdf's aren't greppable without difficulty ;)
00:41:27 <ibid> depends on the viewer
00:41:35 <ibid> and the method of pdf production
00:41:43 <eivuokko> No, I mean the pdf the functional dependencies on ghc are based on
00:41:44 <dons> hence "difficulty"
00:42:11 <dons> eivuokko, oh, MP Jones paper?
00:42:14 <eivuokko> Yea
00:42:39 <ibid> dons: the same applies to any document format :)
00:43:12 <dons> except text, where difficulty=0
00:43:13 <boegel> @seen CosmicRay
00:43:15 <lambdabot> CosmicRay is in #haskell-blah and #haskell. I don't know when
00:43:15 <lambdabot> CosmicRay last spoke.
00:43:18 <boegel> hmm
00:43:44 <boegel> how come there's no 'idle' part anymore in whois ? did they change that ?
00:44:07 <dons> i still see 'idle'
00:44:09 <dons> some people disable it
00:44:14 <dons> in their client
00:44:43 <ibid> dons: is the manual in text format anywhere?:)
00:44:52 <dons> yep :)
00:45:01 <ibid> where?
00:45:08 <boegel> dons: I see
00:45:18 <dons> inside w3m, the text-based html viewer :) or as the output of w3m -dump
00:45:58 <eivuokko> You get grep on most such things by using google, so it's kinda moot imo :)
00:46:07 <dons> slower though
00:46:13 <ibid> well, in that case, pdftotext will work fine as well :)
00:46:22 <dons> indeed!
00:46:34 <ibid> in which case, pdf is no problem :)
00:46:56 <dons> ok. pdf forever!
00:47:02 <ibid> gah, is there a point in reporting on haskell courses in HCAR?
00:47:12 <dons> not sure ibid.
00:47:19 <dons> research groups normally get an entry though
00:47:30 <dons> but courses, not sure. i don't think we've done it before
00:47:55 <ibid> there's an entry on the use of haskell in a school curriculum
00:48:11 <ibid> but yeah, it seems like a gray area to me. hence the question :)
00:48:13 <dons> ah! well, that sounds like an invitation
00:48:26 <ibid> i mean, in the last report, there was one
00:48:29 <dons> or is it a high-schoole curriculum?
00:48:35 <dons> a la dr. scheme
00:49:19 <ibid> uni
00:49:32 <ibid> c
00:49:58 <ibid> actually, there are two entries, one is about the use of haskell in a uni program, the other is about using haskell in schools
00:50:44 <ibid> gah, the latter is also about uni
00:50:54 <ibid> http://haskell.org/communities/05-2005/html/report.html#sect7.2
00:52:04 <ibid> bah, the original statement was correct
00:52:05 <ibid> gaah
01:44:09 <xah> basic question: is Pt a keyword in haskell?
01:44:40 <dblhelix> xah: no
01:45:11 <thaldyron> no
01:45:40 <xah> while “Point” is, right?
01:45:46 <dblhelix> xah: no
01:45:55 <thaldyron> xah no again
01:46:20 <dblhelix> xah: for one thing, there are no keywords with an initial upper-case letter
01:46:28 <thaldyron> xah: Point is either a data constructor or a type class
01:46:46 <dblhelix> thaldyron, xah: or a type constructor
01:47:00 <thaldyron> dblhelix: true :-)
01:47:02 <xah> i mean, so it is built in in the language?
01:47:09 <dblhelix> xah: no
01:47:55 <thaldyron> xah: it's part of the HGL and OpenGL library see
01:47:56 <dblhelix> xah: type and data constructors are defined by type declarations, type classes by type-class declarations
01:48:16 <xah> i'm reading the Gentle Intro..., am trying to make sense of “data Point a            = Pt a a”, just exactly which token is part of the language, and which is arbitrary variable/names.
01:48:20 <dblhelix> xah: they can also be imported from libraries
01:48:38 <dblhelix> xah: data is a keyword
01:48:50 <dblhelix> xah: it indicates a certain form of type declaration
01:49:03 <dblhelix> xah: Point is the type being declared
01:49:10 <xah> what is the Pt on the right side?
01:49:15 <dblhelix> xah: i.e. a type constructor
01:49:21 <dblhelix> xah: Pt is a data constructor
01:49:33 <dblhelix> xah: a is a type parameter
01:49:59 <xah> but if Pt is not in the language (i.e. not a keyword), where is Pt defined?
01:50:06 <dblhelix> xah: i.e. Point is parameterized over a single type parameter and has one data constructor
01:50:19 <dblhelix> xah: Pt is defined right here, in the declaration
01:50:47 <dblhelix> xah: the declaration simultaneously introduces the type constructor (Point) and its data constructors (Pt)
01:51:05 <xah> ok... seems to get it. Will think. :) thanks.
01:51:15 <dblhelix> xah: you're welcome
02:09:33 <boegel> I have a shell (bash) question
02:10:00 <boegel> suppose I have a variable test=just_a_little_test, and I want the part before the "_a", how can I do that ?
02:10:19 <boegel> now I use ${test#*_a}, but that gives me the part after the '_a'
02:14:35 <MarcWeber>  foldr1 (:+:) [ Note x 1%1 [Volume 50], x <- pitchlist]
02:14:53 <MarcWeber> What might be the error here? msg : parse error on input <-
02:17:00 <kolmodin> MarcWeber: change the "," to a |
02:17:25 <MarcWeber> Oh, thx
02:22:28 <JohnMeacham> I am about to post this to the list... I sumarized the issues I found with ghc's code generator I mentioned earlier: http://repetae.net/jhc-vs-ghc-assembly.txt
02:24:17 <JohnMeacham> let me know if it is silly...
02:24:41 * dcoutts reads
02:27:46 <eivuokko> I am not compiler developer, but it looks good to me.
02:32:13 <JohnMeacham> even with -O3, gcc doesn't see that indirect jump isn't needed.
02:33:17 <JohnMeacham> do you think it should just go the ghc list? or one of the haskell ones too.
02:33:26 <JohnMeacham> probably just the ghc one actuallyp
02:35:18 <eivuokko> I have no idea how big part of haskell community care.  But presentation is imo good enough for quick browsing to show that haskell compilers actually do optimise (atleast they soon will) :)
02:38:16 <tromp> hi John
02:40:03 <boegel> JohnMeacham: gcc sucks big time, compared to 'dedicated' compilers, that what I've learned the past few weeks
02:40:09 <JohnMeacham> hello.
02:40:22 <JohnMeacham> what do you mean by dedicated?
02:40:28 <tromp> i see that jhc can target x86_64
02:40:49 <JohnMeacham> tromp: jhc spits out portable ISO C, it targets everything with a c compiler.
02:40:55 <tromp> how does it deal with Word64 types?
02:41:22 <JohnMeacham> uint64_t , ISO C99 I should say.
02:41:45 <tromp> so that will be a plain long on x86_64?
02:41:56 <tromp> or unsigned long
02:42:22 <tromp> i'm curious what jhc dose with code like this:
02:42:25 <tromp> isWon bb = any ((/= 0) . dir) [1,height,height',height''] where
02:42:25 <tromp>   dir d = let t = bb .&. (bb `shiftR` d) in t .&. (t `shiftR` (2*d))
02:42:30 <JohnMeacham> tromp: it will be whatever is the unsigned 64 bit type.
02:42:37 <tromp> because ghc makes a horrible mess of it
02:43:05 <JohnMeacham> you can try it and see. I think it should work. actually, not sure if I implemented shiftR, but I think I did.
02:43:11 <tromp> in particular, when the argument is of type Word64
02:43:39 <dcoutts> JohnMeacham, nice ghc/jhc gcc/asm analysis. I enjoyed reading it.
02:43:50 <JohnMeacham> you might need to add a seq or two, jhc's strictness analyzer isn't as good at ghc's yet.
02:48:04 <dcoutts> JohnMeacham, so gcc does recognise your tail calls correctly? I recall that it does have some support for that these days. Just wondering if you'd found it up to the task.
02:49:15 <JohnMeacham> Yeah, it is actually quite good. whatever they did, it is much better than it used to be. I mean, that generated assembly quite literally couldn't be written better :)
02:49:24 <dcoutts> nice
02:49:39 <JohnMeacham> it can even do a little bit of code rearrangement to expose tailcalls I didn't realize were there.
02:50:00 <kolmodin> wohaa
02:51:52 <MarcWeber> JohnMeacham: What a great pleasure meeting you ;)
02:55:19 <JohnMeacham> MarcWeber: nice to meet you too :)
02:56:01 <JohnMeacham> MarcWeber: I am glad this RealNames thing is catching on. I can talk to people here for a while before realizing I am talking to the same person from the list.
02:57:33 <AnttiJuhaniKaija> no can do :)
02:59:29 <eivuokko> ;)
02:59:54 <dcoutts> JohnMeacham, and the C code output is really nice. I'vestruggled trying to understand ghc C output too :-)
03:00:31 <JohnMeacham> yeah, once I read the STG doc and realized the global register trick, it made a lot more sense.
03:02:09 <dcoutts> JohnMeacham, you don't use global registers then?
03:02:27 <MarcWeber> I've been really impressed by the idea of mirroring the keyboard.
03:04:07 <JohnMeacham> dcoutts: nope. straight ISO C, each haskell function turns into a C function that is called just like any other C function.
03:04:44 <tromp> that's the way god meant it:)
03:05:00 <JohnMeacham> dcoutts: which is why so much of the original haskell is preserved in the C code. the only oddness comes from evaluation of thunks, which turn into big switch statements.
03:05:51 <pejo> JohnMeacham, is that URL stable?
03:06:16 <bringert> Igloo: I followed your instructions and built a registerised GHC 6.4.1 package on unbuntu, it seems to work fine
03:06:28 <JohnMeacham> um. probably not. I will add the doc to the jhc repo so it will be.
03:06:38 <vegai> JohnMeacham: perhaps you would like Ginsu
03:06:55 <vegai> ;)
03:07:03 <JohnMeacham> vegai: I do!
03:07:30 <pejo> JohnMeacham, nice. Thanks.
03:07:54 <vegai> there actually was a second or two there when I didn't remember who wrote it...
03:08:12 <JohnMeacham> vegai: are you on gale?
03:08:28 <vegai> No, not right now
03:08:43 <MarcWeber> which hasktags options do you use for vim? with --ctags I get the error that the tags file isn't sorted.
03:08:51 <JohnMeacham> vegai: oh, I highly recommend it. I have been trying to migrate people from here over there with limited success.
03:08:55 <vegai> unfortunately, many of my friends use other things for communication
03:09:13 <vegai> chicken and egg...
03:09:22 <vegai> I did try it once. It was nice.
03:09:35 <JohnMeacham> vegai: yeah, I was thinking of adding basic support for a few other protocols to ginsu, enough to just keep in touch with people on other nets.
03:09:56 <JohnMeacham> shapr was also on it for a mit.
03:09:57 <JohnMeacham> bit.
03:10:10 <vegai> good idea. Will it be hard to implement?
03:12:00 <kombinator> bringert: does it (and programs compiled with it) use less memory now?
03:12:10 <JohnMeacham> this should be stable http://repetae.net/repos/jhc/docs/jhc-vs-ghc-assembly.txt
03:12:54 <JohnMeacham> not basic support. I was thinking jabber and AIM would be my first targets. of course, if there were haskell code sitting around to talk those, that would help if anyone known of any.
03:16:07 <eyck> Microsoft SQL Server 2000 Performance Optimization and Tuning Handbook (Butterworth-Heinemann - 2001).pdf
03:16:10 <eyck> argh
03:16:13 <eyck> O'Reilly - SQL Tuning 2003 [LiB].chm
03:16:41 <eyck> sorry
03:20:43 * JohnMeacham yearns for a good c-- compiler
03:20:54 <aleator> Hi. concerning arrows. What would be good and illustrative beginner excercise?
03:22:50 <kolmodin> JohnMeacham: how well does Quick C-- perform?
03:25:19 <JohnMeacham> kolmodin: not sure actually. I wouldn't want to rely on a c-- compiler being available though until there was a gcc front end.
03:26:10 <kolmodin> ok
03:38:22 <dcoutts> JohnMeacham, yes a c-- front end for gcc would be ideal
03:39:09 <JohnMeacham> perhaps a front end for lcc would be an easier initial task.
03:39:24 <JohnMeacham> lcc has the neat idea of a code-generator generator.
03:40:57 <pejo> The hardest part about making a C-- frontend for gcc would probably be the social aspects of getting it integrated into the official tree.
03:42:29 <sheriff> What's C--?
03:42:59 <JohnMeacham> SPJ's other project.
03:43:18 <tic> pejo, really, why?
03:44:33 <sheriff> I figure it's going to be challenging to google for more information...
03:45:57 <pejo> tic, signing of papers, convincing people that C-- is a good idea, someone needs to maintain it, etc etc.
03:46:04 <tic> pejo, hrm, true.
03:46:05 <arjanb> sheriff: http://www.cminusminus.org/
03:52:50 <sheriff> arjanb: thanks
03:53:38 <arjanb> i wonder why the c-- website hasn't been updated for so long
03:55:29 <jklm> ghc is almost ready for producing obfuscated c contest entries
04:18:42 <bringert> kombinator: no, they don't use less memoty, but they are much faster
04:18:56 <bringert> almost as fast at programs compiled for i386
04:19:42 <bringert> I'm guessing that the remaining slow-down is caused by having to shuffle more data around, and it taking more space in the cache
04:21:16 <kombinator> bringert: that's also nice;)
04:25:41 <kzm> Hi!
04:25:59 <kzm> I'm still struggling with space efficiency and frequency counts.
04:26:36 <kzm> I'm getting Data.Map (and IntMap) memory consumption of approx 35 bytes per key - is that reasonable?
04:27:45 <tromp> depends on what you compare with
04:28:32 <tromp> judy trees take under 24 bytes per key when mapping to 64 bit values
04:28:39 * kzm meant to ask: am I doing something wrong with regards to laziness etc.
04:29:21 <kzm> That includes the value as well, right?
04:29:27 <tromp> right
04:29:47 <tromp> and those are 64 bit keys too
04:29:58 <kzm> So where is the FFI binding that I need? :-)
04:30:16 <kzm> I haven't done any FFI before, perhaps this is a good time to start...
04:30:17 <tromp> it's not ported to haskell i'm afraid:(
04:30:28 <roconnor> I can't edit the wiki. :'(
04:30:37 <kzm> It would - I suppose - have to reside in IO?
04:30:40 <bourbaki> moin
04:30:45 <tromp> google for judy.arrays
04:30:55 <kzm> I've read some of the docs, yes.
04:34:07 <kzm> I suppose Adrian Hey's AVL trees are similar to Data.Map?
04:35:59 <tromp> prolly with a richer interface
04:37:19 * boegel pokes CosmicRay 
04:37:26 <bourbaki> hey bourbaki
04:37:32 <boegel> how come there's n onew HWN issue yet ?
04:37:35 <boegel> hey boegel
04:37:36 <boegel> :|
04:37:39 <bourbaki> heh
04:37:47 <boegel> ;-)
04:43:26 <bringert> kzm: how come you can't use arrays? is it that you care about unicode?
04:43:42 <kzm> no unicode.
04:44:01 <kzm> But I store integers with a big range, yes.
04:44:01 <roconnor> Data.Map uses red-black trees?
04:44:06 <bringert> kzm: so an array for the characters 0-255 is enough?
04:44:12 <bringert> ah
04:44:23 <bringert> I thought you wanted to count characters
04:44:27 <kzm> no, I count words.  Ideally, arbitrary lenghts.
04:44:31 <kzm> That was somebody else :-)
04:44:46 <bringert> ok
04:44:54 <bringert> you could use a trie I guess
04:45:11 <kzm> too much space wastage, I expect.
04:45:12 <bringert> maybe I should just scroll back and read about your problem before saying stuff...
04:46:22 <kzm> With Data.Map (and IntMap), I get 35 bytes / key.  Since I would like to handle something like 100M keys (at least), the memory requirement is a problem.
04:46:37 <bringert> you have 100M different words?
04:46:49 <bringert> I'm guessing this is not natural language then
04:46:53 <JohnMeacham> Haskell needs a standard extension language... i will go write it.
04:46:54 <kzm> Not all different, no.
04:47:01 <kzm> No, it's nucleotide sequences. :-)
04:47:15 <bringert> how many different ones do you have?
04:47:33 <bringert> the 35 bytes / key only matters for different words, right?
04:47:40 <kzm> Well - I don't know that until I've counted, do I? :-)
04:47:45 <bringert> since duplicates aren't inserted
04:47:50 <bringert> true :-)
04:48:05 <bringert> what is the average word length?
04:48:20 <kzm> Probably - I tried to insert mod n to get more duplicates, but it doesn't seem to make a big difference.  I'll try smaller mod.
04:48:29 <bringert> do you only have A, C, G, T as letters then (I don't know much about bioinformatics)
04:48:45 <kzm> (slow down, will you? :-)
04:49:02 <kzm> Word length should be in the range 16-35 or so, I guess.
04:49:15 <kzm> I'll settle for 32, encoded as Word64, if it helps.
04:49:39 <kzm> Yes, only four letters (for my purposes - there are wildcards etc, but I ignore them)
04:51:06 <kzm> Test code is at: http://www.ii.uib.no/~ketil/mapbench.hs
04:51:12 <kzm> Feel free to take a look! :-)
04:53:36 <kzm> With 10 expected duplicates (take n ... randomRs (1,n `div` 10)), I get about 20% reduction in space.  Maybe a bit more.
04:55:47 * kzm enjoys the peace and quiet, and sighs audibly.
04:59:59 <bringert> kzm: did you try Data.HashTable?
05:02:23 <bringert> other than that, it seems to me like a trie could work. mayve based on UArrays or something
05:10:45 <kzm> Didn't try hashtable yet.  Will do.
05:11:05 <kzm> I was thinking of a trie of Word8 size.  (Similar to Judy?)
05:11:43 <kzm> I.e. when things get dense, I use a direct table with one byte index, for sparse pieces, something storing key,value pairs.
05:11:55 <kzm> I used this approach with HTs, but HTs mess up GC.
05:12:41 <Igloo> bringert: Cool, thanks. Has it reduced memory usage?
05:15:48 <bringert> it made the program 2-3 times faster than unregisterised amd64. it is still slightly slower than in my i386 chroot. memory use is still about twice as large for amd64, compared to i386. I guess is because pointers are twice as wide.
05:16:50 <bringert> conclusions: registerized amd64 works, and makes the programs much faster, but amd 64 memory use is still a problem.
05:17:17 <bringert> conclusions from that: buy more memory when buying amd64
05:17:37 <bringert> or don't use the 64-bit mode
05:19:20 <flux__> maybe we should have two kinds of pointers. we could call them 'near' and 'far'!
05:19:23 <flux__> ;)
05:19:30 <bringert> :-)
05:19:54 <eivuokko> Hehe :)
05:20:21 <bringert> I'm starting to see why that seemed like a good idea at the time
05:20:48 <syntaxfree> my heuristics exhibit pseudosmart behaviour.
05:22:00 <syntaxfree> hmm. that wasn't meant for here.
05:22:10 <syntaxfree> anyway, what's the simplest way of getting one pseudorandom number?
05:23:04 <CosmicRay> syntaxfree: there's something in the IO monad in System.Random
05:23:31 <syntaxfree> do I have to do the <- stuff somehow?
05:23:38 <syntaxfree> well, will do.
05:23:43 <syntaxfree> read into it, too.
05:23:54 <bringert> @type System.Random.randomIO
05:23:56 <lambdabot> forall a. (System.Random.Random a) => IO a
05:23:58 <CosmicRay> syntaxfree: there is also Random stuf not in the IO monad
05:27:05 <kzm> Re AMD64 - isn't it limited to 40-something actual bits in addresses?
05:27:40 <kzm> At least GHC tends to use a lot of space for flags and whatnot, couldn't this be packed with the pointers?
05:27:53 <dcoutts_> kzm, in physical addresses yes, it's virtual addresses are 64bit
05:28:10 <kzm> I did the HT rewrite, btw, both memory usage and time seems to be similar to Data.Map...
05:28:50 <kzm> dcoutts_, does that mean programs mustn't mangle any unused bits, then?
05:28:57 <dcoutts_> gour, I saw your bug report
05:29:10 <gour> dcoutts: i'm glad
05:29:49 <dcoutts_> gour, it's almost certainly because the glib GType system is not getting initialised. I had thought that was not required, it worked for me before. I'll fix the demo.
05:30:25 <gour> dcoutts_: fine, let me know when you're ready
05:30:28 <dcoutts_> kzm, right, there are no unused bits. The kernel can give you memory from anywhere in that 64bit address space
05:31:11 <kzm> :-(
05:31:17 <syntaxfree> How annoying.
05:31:27 <dcoutts_> kzm, and with security memory randomisation features it really will give you memory randomly scattered throughout the address space.
05:31:38 <dcoutts_> it's a feature :-)
05:32:27 <kzm> ...for C programs with buffer overruns.
05:32:35 <dcoutts_> gour, I waned to avoid calling initGUI since that makes gconf dependent on Gtk when it's not really. I'll provide a function for just initialising the glib GType system.
05:33:03 <kzm> Perhaps Haskell programs, being safer, could be allocated memory from the virtual lower end? :-)
05:34:28 <dcoutts_> kzm, on linux you can request memory from the first 4GB, but that's mainly for code, since then ti allows you to use 32bit function pointers.
05:34:38 <gour> dcoutts_: is it the standard to do in such a way?
05:34:52 <dcoutts_> gour, I'm not sure, I'll have to take a look.
05:35:13 <gour> dcoutts: fine
05:35:26 <kombinator> gour: gconf demo worked for me on amd64
05:35:32 <dcoutts_> JaffaCake, have you seen JohnMeacham's analysis of ghc/jhc assembly output?
05:35:38 <dcoutts_> kombinator, hmm, interesting.
05:35:48 <JaffaCake> dcoutts_: no?
05:35:55 <dcoutts_> JaffaCake, http://www.haskell.org//pipermail/glasgow-haskell-users/2005-October/009174.html
05:36:27 * dcoutts_ is interested to know what JaffaCake thinks about it
05:36:59 * JaffaCake is reading...
05:37:09 <gour> kombinator: really?
05:37:26 <gour> kombinator: 64bit mode?
05:37:35 <kombinator> gour: yes
05:37:46 * dcoutts_ looks up GConf documentation
05:37:58 <gour> kombinator: strange...
05:38:46 <dcoutts_> gour, the docs say: "It's important to call g_type_init() before using this GObject, to initialize the type system."
05:38:55 <dcoutts_> gour, so I guess I'd better do that :-)
05:39:04 <kombinator> gour, dcoutts_: I'm using ghc 6.4.1 from debian, which is an unregistered build
05:39:37 <kombinator> gour: which version of gtk do you have?
05:42:22 <gour> kombinator: gtk+-2.8.6
05:42:35 <kombinator> gour: I use 2.6.10
05:42:58 <gour> kombinator: so you don't have cairo
05:43:09 <kombinator> gour: correct
05:43:13 <CosmicRay> JaffaCake: were you able to grab that executable and core file?
05:43:34 <JaffaCake> CosmicRay: yes, haven't had a chance to debug it yet though
05:43:44 <CosmicRay> ok, thanks
05:45:49 <dcoutts_> gour, kombinator, it should now be fixed in cvs. It'll be in the next release candidate.
05:47:29 <gour> dcoutts_: fine. will give you feedback
05:47:33 <JaffaCake> dcoutts_: that message from JohnMeacham is v. interesting
05:48:07 <JaffaCake> I was aware of some of the bogosity, but there are some suggestions we might be able to use
05:48:24 <dcoutts_> gour, thanks
05:48:27 <dcoutts_> JaffaCake, great
05:48:46 <JaffaCake> I'm sceptical whether it's going to make a big difference on "real" programs, tho
05:49:10 <dcoutts_> JaffaCake, but it might help with the shootout micro-benchmarks :-)
05:49:26 <dcoutts_> JaffaCake, it's interesting that JohnMeacham spent quite a bit of time maing the C code readable
05:49:31 <JaffaCake> maybe, we'll see
05:49:56 <Igloo> Removing the temptation to write inner loops in C and FFI them is also worthwhile IMO, but you probably already knew that  :-)
05:50:36 <JaffaCake> yes, he uses quite a different approach, using much more of C than we do, whereas we just use C as an assembler
05:50:41 <dcoutts_> Igloo can probably apreciate the value of more readableC code output after all the ghc C code he's been looking at :-)
05:51:48 <dcoutts_> JaffaCake, yes it'd be interesting to compare the ghc C backend with the c-- backend on that example
05:52:13 <JaffaCake> I imagine c-- will do a lot better (when it finally works)
05:52:33 <dcoutts_> JaffaCake, I thought it already worked
05:52:57 <JaffaCake> not the C-- back end, that's still in development
05:53:20 <dcoutts_> right but you've got the c-- to asm in ghc already
05:53:30 <Igloo> Does the C-- backend compile to C or to assembly?
05:53:36 <dcoutts_> but that's not there for performance of course
05:53:43 <dcoutts_> Igloo, both I think
05:54:03 <dcoutts_> c-- is the intermediate representation in the backend
05:54:04 <JaffaCake> ah, I see what you mean
05:54:14 <JaffaCake> you mean the C-- -> asm back end
05:54:26 <JaffaCake> all the back-ends go via C-- internally
05:54:50 <dcoutts_> JaffaCake, right and you mean the "c-- to c-- as text output for a c-- compiler" backend
05:55:02 <JaffaCake> yes
05:55:32 <JaffaCake> so actually the -fasm results will be slightly better than the -fvia-C code for JohnMeacham's example
05:56:01 <dcoutts_> JaffaCake, could the register/stack pusing/poping optimisation that JohnMeacham was talking about be done in the intermediate c-- representation?
05:56:16 * JaffaCake thinks
05:56:22 <dcoutts_> rather than the c-- -> C translation as JohnMeacham suggested
05:56:47 <JaffaCake> it could
05:57:00 <dcoutts_> then it benefits all the backends
05:57:16 <JaffaCake> GHC's back end is designed with register parameters in mind... unfortunately there aren't any registers available on x86
05:57:30 <dcoutts_> yes
05:57:34 <JaffaCake> if there were, then there wouldn't be this stack nonsense in that example
05:57:51 <JaffaCake> (there might still be some re-loading of regs, though)
05:59:30 <xinming> hmm, where is the map for haskell user please
05:59:55 <vegai> @type map
05:59:56 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
06:00:00 <dcoutts_> JaffaCake, the cmm abstraction hides the register file right? so the cmm compiler does the register allocation
06:00:51 <marcot> i'm trying to define a typedef in a #c #endc declaration inside a .chs file, which is:
06:00:54 <JaffaCake> it will do... there needs to be some changes to our internal C-- rep first (which doesn't currently have fully fledged C-- calls with parameters)
06:01:20 <marcot> typedef gpc_vertex *verto;
06:01:44 <marcot> When I run c2hs GpcHs.chs I got:b
06:01:59 <dcoutts_> JaffaCake, ah ok. Because in JohnMeacham's example he's using C local variables rather than an explicit stack. That way the C (or c--) compiler could decide if things need to be spilled to the stack, and so it this example they would not.
06:02:47 <JaffaCake> we could still do internall C-- -> C-- optimisations to achieve the same result
06:03:05 <JaffaCake> only really on simple recursive functions, tho
06:03:08 <dcoutts_> right
06:03:12 <dcoutts_> JaffaCake, if I understand correctly, ghc is generating code to explicitly push/pop things off of the ghc-managed stack.
06:03:27 <JaffaCake> yes
06:03:36 <dcoutts_> that's the *Sp amd Sp[n] stuff.
06:03:47 <JaffaCake> yes
06:04:21 <xerox> Howdy, folks.
06:04:26 <dcoutts_> hi xerox
06:06:06 <xerox> dcoutts_: I was thinking about mailing them to change the description/url, what do you think?
06:08:10 <dcoutts_> xerox, oh on the google SoC results page?
06:08:33 <xerox> Yeah
06:10:26 <dcoutts_> xerox, what url would you use?
06:10:50 <xerox> The Gtk2Hs one?
06:11:02 <xerox> Maybe referring to the final article, specifically?
06:13:27 <dcoutts_> xerox, yeah, I guess they just want to make sure they've got a link to the source
06:13:53 <xerox> That's what the final form asked for, that's also why I did put that url :)
06:18:44 <syntaxfree> what is a good reference on type constructor syntax?
06:19:31 <Philippa_> for haskell 98 you might want to try the haskell 98 report
06:19:38 <Philippa_> it's at least authoritative
06:19:47 <syntaxfree> it's also perfectly opaque, for me :)
06:20:10 <syntaxfree> in stuff like Data Maybe a = Just a | Nothing or Data Nat  = Nat | Succ Nat, are "Just", "Succ" predefined words, or are they types themselves?
06:21:20 <dcoutts_> syntaxfree, they are just ordinary data constructors, but predefined in the Prelude module
06:21:30 <syntaxfree> ah, I see.
06:21:51 <syntaxfree> Yes, it eventually goes back to studying the Prelude. That's what got me started in first place.
06:25:43 <Philippa_> you never see a type used in place of a data constructor in haskell
06:25:50 <Philippa_> data constructors are emphatically not type constructors
06:27:11 <Philippa_> (and nor are type constructors data constructors)
06:28:47 * syntaxfree goes back to the "Functional programming with overloading" paper to clear up the ideas.
06:29:09 <syntaxfree> I'm still confused in this chance matter of the type system.  I tend to represent everything as lists, tuples and combinations thereof.
06:29:12 <SamB> what do you think this is, cayenne?
06:29:56 <integral> makes generic programming easier?
06:30:11 <SamB> then I guess you don't think this is cayenne
06:30:37 <roconnor> Sum types are a bit strange if you come from the untyped world.
06:31:07 <roconnor> they are vaguely like union in records in C.
06:31:23 <kombinator> I think that a big deal of confusion among people learning Haskell comes from the fact that many types have constructors that look the same as their names
06:31:40 <syntaxfree> like Nat?
06:31:44 <roconnor> probably
06:31:44 <kombinator> e.g. [1] :: [Integer]
06:31:45 <SamB> especially the ones in the official unlambda interpreter
06:31:55 <kombinator> (2, 'a') :: (Int, Char)
06:32:04 <kombinator> () :: ()
06:32:12 <kombinator> and several more
06:32:14 <roconnor> Data Nat = Zero | Succ Nat is what would typically be defined.
06:32:38 <syntaxfree> Zero is a data constructor. Or am I _that_ messed up?
06:32:51 <roconnor> in this case there constructors and type names are different.
06:32:56 <roconnor> yes
06:33:00 <roconnor> Nat is the type
06:33:07 <roconnor> Zero and Succ are two type constructors.
06:33:20 <xerox> Data constructors
06:33:26 <SamB> roconnor: uh, no
06:33:35 <roconnor> oh right, data constructors.
06:34:29 <syntaxfree> Data constructors that happen to be defined in the Prelude, mostly.
06:34:51 <syntaxfree> the second "Nat" in Data Nat = Zero | Succ Nat is another data constructor, though one we define, or?
06:35:08 <ProfTeggy> Hi all.
06:35:11 <SamB> really, data Nat = Zero :: Nat | Succ :: Nat -> Nat would be easier to understand...
06:36:13 <roconnor> Everything after a data constructor in the type definition are the types of the parameters of the data constructor.
06:36:24 <roconnor> Zero has no parameters
06:36:34 <roconnor> Succ has one parameter, of type Nat.
06:37:51 <roconnor> does ghc do intermodule optimisations?
06:38:11 <Philippa_> yes
06:38:26 <roconnor> does it do it with -O2?
06:38:44 <syntaxfree> Last time I checked, ghc had just one -O.  But it was 6.2.2
06:39:09 <roconnor> maybe.  I just write -O2 for no good reason.
06:39:51 <syntaxfree> subliminar imprinting. Watching a Gentoo installation fly by can do that to you.
06:41:05 <Igloo> ghc's had -O2 for ages, but it's not significantly better than -O and is slower
06:41:16 <roconnor> slower?
06:41:18 <roconnor> that's no good
06:41:24 <xerox> wrt compiling time
06:41:28 <syntaxfree> I think he meens slower in compile time.
06:41:33 <roconnor> oh, compile type
06:41:36 <roconnor> time
06:41:38 <roconnor> yes
06:42:00 <roconnor> well, my code complies really fast, so I'll keep with -O2 I guess.
06:42:24 <gour> dcoutts: you're suggesting to use gtk2hs+hsql approach for db stuff..
06:42:58 <kombinator> gour: what do you want to do?
06:43:04 <gour> dcoutts: and you plan to introduce some combiantors to make gtk2hs more haskellish?
06:43:44 <gour> kombinator: i'm thinking about application to have its database of documents
06:43:57 <kombinator> gour: with gtk2hs+hsql you will have to do some tricks with threads if you want to have non-blocking io
06:44:14 <syntaxfree> anyone ever tried compiling ghc-produced C code with gcc?
06:44:43 <syntaxfree> I'm on a Mac and I want to run some code at an Opteron box I have a limited account in.
06:44:47 <gour> kombinator: so i'm thinking about embedding sqlite database where user can store his/her records which are used in the calc-engine
06:44:51 <dcoutts_> gour, yes and yes
06:45:30 <gour> dcoutts_: so i think that then libgda & libgnome stuff could take the same advantage
06:45:51 <dcoutts_> gour, I'm not quite sure what you mean
06:46:06 <gour> dcoutts_: i.e. db stuff can be also made more similar like the hsql approach
06:46:23 <dcoutts_> gour, the gtk2hs+hsql will work now, the libgda + libgnome will take more work initially to bind them
06:46:56 <dcoutts_> gour, I'm still not quite sure what you mean :-)
06:47:16 <gour> dcoutts_: sure, more work now, but then we would have more complete framework for even wider application of gtk/gnome toolkit
06:47:40 <dcoutts_> yes, but the hsql api is probably nicer than the libgda one
06:48:02 <kzm> In case anybody's still paying attention, I added a bit of strictness to the count increment, and apparently, I was building up thunks of additions.  Memory usage is now about half.
06:48:12 <gour> dcoutts_: but another (higher) layer on libgda can solve this problem?
06:48:45 <gour> dcoutts_: and lift both libgda & gtk2hs on a higher level
06:49:33 <defcon8> why isnt C a functional language?
06:49:33 <kzm> (Shouldn't Data.Map & friends have a strict interface as well?  Usually, this is what I want)
06:49:49 <gour> dcoutts_: i assume that having (more) complete gtk2hs framework, i.e. including widgets & bindings for db stuff would make the whole gtk2hs project even more interested for wider adoption of haskell & gtk toolkit
06:50:12 <syntaxfree> C doesn't support higher-order functions, for one.
06:50:19 <defcon8> what are they?
06:50:20 <syntaxfree> @wikipedia Functional programming
06:50:22 <dcoutts_> gour, yeah possibly, but it's quite a bit of work. We'll have to consider it along with the other priorities.
06:50:29 <lambdabot> http://en.wikipedia.org/wiki/Functional_programming
06:50:31 <Igloo> It does technically
06:50:32 <defcon8> ok
06:50:41 <syntaxfree> Igloo: does it?
06:50:44 <dcoutts_> defcon8, because C 'functions' are not functions :-)
06:50:57 <kombinator> gour: I think that creating a high-level gui library for haskell is a non-trivial task
06:51:06 <gour> dcoutts_: i.e. the need for doing dbstuff (and having those nice widgets) is not a niche market :-)
06:51:07 <dcoutts_> kombinator, indeed
06:51:07 <Igloo> It's the same reason a Ford isn't an F1 car, even though they can both go round a track
06:51:15 <ProfTeggy> syntaxfree, he's referring to function pointers I suppose.
06:51:22 <syntaxfree> hmm.
06:51:27 <dcoutts_> gour, well I hope it's a project that you will help us with then :-)
06:51:29 * basti_ is back
06:51:59 <ProfTeggy> f(e) and (*f)(e) is the very same in C
06:52:09 <ProfTeggy> This gives the "illusion"
06:52:13 <gour> kombinator: i agree with that
06:52:50 <syntaxfree> so I can write a function, that say, gives the derivative of another function?
06:52:50 <gour> dcoutts_: yes, i'll try to build using the shoulders of the giants
06:53:20 <ProfTeggy> syntaxfree, you can return a function (pointer) or embed a function (pointer) in a data structure
06:53:29 <ProfTeggy> But you cannot compose new functions at runtime, no
06:53:30 <syntaxfree> hmm.
06:53:30 <dcoutts_> gour, kombinator, the first thing I'd like to do with the higher level stuff is to get the modules/naming isssue sorted out. Then there are things like useing classes to get shorter names and implementing layout combinators.
06:53:36 <syntaxfree> Oh. Ok.
06:54:05 <gour> dcoutts_: but before jumping into i would like to be sure it is project which is a desired-child in gtkwhs family :-)
06:54:25 <syntaxfree> the "Prof" there really makes you sound more authoritative.
06:54:36 <ProfTeggy> syntaxfree, I apologize.
06:54:40 <ProfTeggy> It's just a nick
06:54:48 <Oejet> Hehe.
06:55:00 <ProfTeggy> (although I'm a professpr,  hehehe)
06:55:06 <ProfTeggy> s/spr/sor/
06:55:11 <syntaxfree> authoritative != authoritarian.
06:55:16 <ProfTeggy> But on the Internet nobody knows you're a dog
06:55:18 <dcoutts_> gour, oh well if you get a libgda binding working then we'll have it.
06:55:21 <syntaxfree> Authoritative = "I reeeally know what I'm talking about"
06:56:18 <gour> dcoutts_: i'm still have a lot to do with learning haskell, but i'm seriously considering to make libgda bindings happen
06:56:25 <dcoutts_> gour, cool
06:56:29 <Teggy> :-)
06:56:37 <xerox> What is libgda?
06:56:38 <syntaxfree> Teggy sounds vaguely jamaican.
06:56:57 <syntaxfree> or maybe british-obsessed-with-Jamaica-ish.
06:57:05 <Teggy> It does?  I'm from a Jamaica anti-thesis, called Germany
06:57:14 <gour> dcoutts_: especially after your work on the gtk2hs bindings, cairo bindings...lot of experience is available
06:57:15 <dcoutts_> xerox, it's a glib/GObject based database access library
06:57:33 <gour> xerox: http://www.gnome-db.org/
06:57:34 <xerox> Another attribute API?
06:57:41 <dcoutts_> heh, not sure
06:58:11 <dcoutts_> xerox, oh yes there is still that attribute api to sort out isn't there.
06:58:25 <syntaxfree> well, do you have drum-and-bass music in Germany?
06:58:37 <Teggy> syntaxfree, of course we do.
06:58:51 * dcoutts_ goes to make another cup of tea
06:59:09 <syntaxfree> so. dnb <- jungle <- ragga <- reggae ;-)
06:59:23 * xerox wants tea too
06:59:50 <Philippa_> except dnb's pretty much thrown away all the cultural associations with reggae unless it's doing it on purpose
07:00:13 * gour wonders what are their preferred taste of tea
07:00:43 * dcoutts_ likes assam tea
07:00:43 * gour goes to take a short nap
07:00:51 <bourbaki> Philippa_: did you hear about the thetre play of pratchett?
07:00:56 <Philippa_> which one?
07:01:03 <bourbaki> there are more then one?
07:01:08 <Philippa_> I mean, I went to one in York with a bunch of afpers a while back (mid-meet)...
07:01:17 <bourbaki> uh
07:01:43 * gour like hibiscus
07:01:56 <bourbaki> this one http://www.turtlesalltheway.com/
07:02:26 <Philippa_> ah. I'd probably heard some mention of it on afp, but thanks for the heads up regardless
07:03:09 <bourbaki> a pitty that there arent any shows over here
07:03:23 <bourbaki> i also have seen that there are two movies
07:05:17 <sheriff> Hrm, my favourite Pratchett book has to be Good Omens
07:05:25 <Philippa_> in production (theoretically) that is, no? Good Omens has been theoretically going to happen for god knows how long
07:05:36 <sheriff> or maybe the one about the cats and the rat
07:05:49 <bourbaki> my fave is wee free men
07:06:02 <Philippa_> mine depends on my mood
07:06:11 <Philippa_> I mean, small gods was great, night watch was in a completely different kind of way...
07:06:26 <bourbaki> but can anyone confirm the existence of a comic movie with death in this rock star book?
07:07:00 <Philippa_> um...?
07:07:07 <Philippa_> you mean as per Soul Music?
07:07:11 <bourbaki> yes
07:07:17 <Philippa_> (I mean, my first thought was Bill&Ted's Bogus Journey ;-)
07:07:44 <bourbaki> heh
07:08:31 <bourbaki> the later books are better imho in a literatical way
07:08:31 <ValarQ> is there a strict version of (:) ?
07:09:02 <Philippa_> you can build one with seq
07:11:44 <integral> x `strictCons` y = seq x $ seq y (x:y) ? seq seems quite awkward to use, is there a monadic interface to it?  x `strictCons` y = runSomething $ do { x' <- return x; y' <- return y; return (x':y') } ?
07:12:06 <kosmikus> there's $!
07:12:25 <Philippa_> (:) $! item $! list
07:12:32 <integral> ah!
07:14:05 <lisppaste2> kombinator pasted ""Ambiguous type variable" error" at http://paste.lisp.org/display/12884
07:14:43 <kombinator> guys - I'm getting na error message on ebind = fmap . const
07:15:06 <kombinator> It used to compile well before iirc...
07:17:23 <bourbaki> @seen esap
07:17:23 <lambdabot> I saw esap leaving #haskell 5 days, 17 hours, 19 minutes and 43
07:17:23 <lambdabot> seconds ago, and I have missed 21 hours, 36 minutes and 18
07:17:23 <lambdabot> seconds since then.
07:19:24 <ValarQ> Philippa_: that seems to do that
07:20:14 <ValarQ> didn't quite solve my problem thought
07:22:32 <ValarQ> can i make my (:) function eat less stackspace?
07:23:50 <Philippa_> I don't know
07:23:56 <Philippa_> (and there're many reasons why)
07:28:13 <ValarQ> it's almost a  foo (x:xs) = (x,x) : foo xs  function which recieves quite a lot of data
07:28:52 <Philippa_> so it's a fold of some sort?
07:29:47 <xerox> @pl foldl (\xs x -> (x,x) : xs) []
07:29:47 <lambdabot> foldl (flip ((:) . join (,))) []
07:30:39 <ValarQ> well, to be perfectly honest it looks like this:  markovb (a : xs@(b:c:_)) = (a,b,c) : markovb xs
07:35:55 <Philippa_> so grouping everything into 3-tuples and then something else? hmm
07:37:35 <xerox> markovb [] = []; markovb (x:y) = error "?!"; markovb = uncurry (:) . (take 3 *** markovb . drop 3)  -- maybe :)
07:38:08 <ValarQ> Philippa_: yeah
07:38:27 <ValarQ> xerox: *** ?
07:38:35 <xerox> err, &&&.
07:39:13 <boegel> @seen Itkovian
07:39:14 <lambdabot> Last time I saw Itkovian was when I left #gentoo-haskell, #
07:39:14 <lambdabot> haskell, #haskell-blah and #haskell-overflow 1 day, 7 hours, 12
07:39:14 <lambdabot> minutes and 21 seconds ago, and I have missed 21 hours, 35
07:39:14 <lambdabot> minutes and 27 seconds since then.
07:39:27 <xerox> @type let f = uncurry (:) . ((Control.Arrow.&&&) (take 3) (f . drop 3)) in f
07:39:28 <lambdabot> forall a. [a] -> [[a]]
07:39:57 <boegel> hmm, wasn't there a #haskell-overflow channel too ?
07:40:11 <xerox> Yes there is.
07:44:03 <ibid> what does that do?
07:44:08 <boegel> hmm, how come no-one it there ?
07:44:17 <basti_> I am there
07:44:24 <boegel> oh, nvm, mistake
07:44:38 <boegel> I used haskel <-> haskell
07:44:43 <basti_> heh
07:46:34 <ibid> one of my questions in a haskell-related exam was, "how is the name of the programming language used in this course spelled? a) haskel b) haskell c) hascel d) hascell" (one or two points)
07:46:49 <xerox> hahah
07:47:22 <ibid> not all got full points there
07:47:24 <neologism> ibid: how many students fail in these?
07:47:44 <ibid> neologism: surprisingly many, unless i warn them in advance
07:47:51 <neologism> hehe
07:48:06 <ibid> a) being a fairly popular answer
07:51:27 <xerox> http://geophile.com/osh/index.html
07:51:33 <xerox> h4sh++ :)
08:10:35 <gilles__> hi all
08:10:42 <Cale> hello
08:11:12 <Cale> hey, I'm up and it's morning, and I've actually slept!
08:11:28 <xerox> Eek eek eek!
08:11:44 * Cale runs around in circles
08:11:49 <eivuokko> :)
08:12:05 * basti_ holds a stick in Cale's way
08:12:41 <xerox> Cale: news http://googleblog.blogspot.com/2005/10/supporting-open-source.html !!
08:15:17 <dcoutts_> xerox, Eek eek eek? Doesn't that usually mean something failed to build?
08:15:29 <xerox> Yeah :-)
08:15:56 <gilles__> i see the haskell sequence is using drupal, php cms... isn't there anyone working on a blog/cms software in haskell ?
08:16:29 <xerox> gilles__: there are some ideas floating around in the heavy air
08:17:00 <basti_> gilles__: i was trying to get something done in haspr for that reason, but haspr is way too flakey so far :(
08:17:31 <gilles__> a friend of mine is working on his master thesis on webservice using continuation... sounds interesting
08:21:30 <gour> yesterday there was some rumor about haskellforge here...
08:23:04 <dcoutts_> gour, indeed there was
08:23:17 <dcoutts_> shapr mentioned an idea
08:23:55 <gour> dcoutts_: any action plan?
08:26:13 <Philippa_> it'd probably be reasonably trivial to turn Flippi into a blog, FWIW
08:26:21 <Philippa_> a full-blown CMS might be pushing it a bit depending on what you want
08:28:27 <dcoutts_> gour, ask shapr
08:29:33 <gour> dcoutts_: ok, regarding db stuff, both libgda & lignomedb are relavant to MacOS too?
08:29:44 <xerox> Mathematica: Map[(#+1)&,{1,2,3}]  ==>  {2, 3, 4}  woot :D
08:30:10 <gour> dcoutts_: i looked a bit about evolution (bonobo) for win32, but it looks it's not ready yet
08:30:50 <gour> dcoutts_: shapr is not around and we have 206 nicks :-o
08:30:55 <dcoutts_> gour, if it's not ready on win32 it'll be even worse for macos
08:31:43 <gour> dcoutts_: but libgda is fine?
08:32:38 <gour> dcoutts_: i'm fine with linux, but those worry about those fellow users which are not converted (yet)
08:33:08 <gour> dcoutts_: but s/worry about..
08:33:37 <dcoutts_> gour, libgda is probably more portable
08:34:01 <dcoutts_> gour, but I don't know for sure.
08:34:12 <dcoutts_> it has much simpler dependencies
08:34:23 <gour> dcoutts_: ruby-gnome2 has libgda
08:35:50 <dcoutts_> yay, gtk2hs still builds with ghc-5.04.3 and Gtk+ 2.0 (after a little hacking)
08:36:19 <gour> how old is 5.0x?
08:36:23 <dcoutts_> quite old
08:36:35 <gour> still in use?
08:36:39 <dcoutts_> 5.04 at least has the heiricharcal libs
08:36:46 <dcoutts_> gour, proably not :-)
08:37:13 <dcoutts_> but it allows me to test with Gtk+ 2.0 using a chroot'ed image of my old mandrake installation
08:37:18 <gour> so, why bother :-)
08:37:30 <gour> ahh, old mandrake fan ;)
08:37:39 <gour> good old rpm :-)
08:37:49 <dcoutts_> I started with mandrake and moved on to gentoo
08:38:10 <gour> my 1st linux install was debian, then suse, gentoo
08:38:19 <dcoutts_> and if we calim to still support Gtk+ 2.0 then we'd better test it
08:38:25 <dcoutts_> calim/claim
08:38:52 <gour> sometime we have to break backward-compatibility..
08:39:01 <dcoutts_> it is also working on solaris
08:39:28 <dcoutts_> gour, yes, but it's not necessary here. Be thankful I stripped out the support for ghc 5.02 :-)
08:39:42 <gour> ghc still does not work on sparc?
08:39:48 <dcoutts_> it works fine
08:40:06 <dcoutts_> on sparc/solaris and sparc/linux
08:40:18 * dcoutts_ has access to both
08:40:38 <gour> sparc64 sun4u TI UltraSparc IIe (Hummingbird) GNU/Linux
08:40:53 <dcoutts_> yes, that's me
08:41:01 <gour> so it works?
08:41:05 <dcoutts_> yep
08:41:26 <gour> great news, i have access to one
08:41:35 <dcoutts_> what is it?
08:41:43 <dcoutts_> mine's a SunBlade 100
08:41:45 <Killer666> ghc works well on solaris
08:42:06 <gour> my friend, better say teacher's server
08:42:15 <gour> atmarama.org is there
08:42:31 <dcoutts_> Killer666, yes (at least 6.2.2 and 6.4.1. version 6.4 was very dodgy.)
08:44:10 <gour> libgda/libgnome are approaching new 2.00 api
08:46:12 <gour> so by the time i'd be ready for a task, it would be (probably) more clear what to expect regarding multi-platformability
08:46:47 <dcoutts_> gour, oh, where did you read that?
08:48:11 <gour> dcoutts_: well i saw  on gnome-db list regarding 2.0.0 api
08:48:38 <gour> dcoutts_: http://mail.gnome.org/archives/gnome-db-list/2005-October/msg00002.html
08:49:19 <gour> dcoutts_: in any case, if ruby can have it, why not haskell
08:50:25 <dcoutts_> gour, sure we can have it, it just needs someone to do the work :-)
08:51:32 <gour> dcoutts_: Gtk# has them too
08:52:22 <gour> dcoutts_: as of now, i understand it well :-)
08:54:57 <gour> dcoutts_: but before doing that i'd consider binding for that ephemeris lib, it's much smaller and can serve as a good introduction to c2hs
08:55:24 <gour> dcoutts_: i.e. acquiring required skills
08:55:56 <dcoutts_> yep, sounds like a good idea
08:56:14 <xerox> What is ephemeris ?
08:57:07 * dcoutts_ intends to release the second Gtk2Hs 0.9.10 release candidate later today
08:57:08 <gour> xerox: planetary positions
08:57:15 * dcoutts_ has to go now however
08:57:36 <gour> dcoutts_: good luck, duncan, will report back
08:58:15 <gour> xerox: it is a c-lib for calculating planetary positions and i'd like to provide haskell bindings
08:59:09 <sethk> gour, we found that it wasn't accurate enough, at least for operating LEOs
08:59:31 <gour> what was not accurate enough?
09:00:12 <gour> sethk: what is LEO?
09:00:21 <sethk> gour, LEO is low earth orbit
09:00:26 <sethk> gour, applies to a satellite
09:01:04 <gour> sethk: ah ok, i do not need for satellite, only manin planets
09:01:11 <sethk> gour, than you should be ok
09:01:25 * basti_ likes stellarium
09:01:47 <gour> sethk: however, lib is based on DE406 ephemeris from NASA's JPL
09:02:14 <sethk> gour, yes, I know, but the error per orbit was much too high
09:02:27 <sethk> gour, we had to switch to a 15x15 gravity matrix
09:02:30 <gour> sethk: jsut compressed a bit and with extended time scale (but this is tricky and one cannot be sure - prove it :-)
09:02:54 <gour> what lib did you use?
09:03:19 <sethk> gour, McDonald-Douglas had to rewrite one they used internally  (now Boeing)
09:03:23 <gour> sethk: i'm thinking about Swiss Ephemeris - http://www.astro.com/swisseph/?lang=e
09:03:35 <sethk> gour, I don't know that one.  I'll have to read about it.
09:04:49 <sethk> gour, it would be interesting to calculate the errors.  We saw unacceptable errors in a matter of days, so one that claims accuracy over thousands of years should be similarly vulnerable
09:04:51 <gour> sethk: and considering that i'm interested for vedic astrology (sidereal), much less work (functions) to bind :-)
09:05:13 <sethk> gour, but if things are far enough away for a point mass approximation to work, then it is probably not an issue
09:05:28 <roconnor> :-( I can't make a function type a class instance.
09:06:13 <gour> sethk: as you said, it is difficult to validate ephemeris for 1000 years ago
09:07:13 <gour> sethk: my jyotish teacher told me that there are not positions of planets available in vedic scriptures althugh e.g in mahabharata events are described ery vividly
09:07:34 <sethk> gour, accurately enough for verification, he thinks?
09:07:41 <gour> sethk: e.g. which asterism was rising etc.
09:07:47 <genneth> @seen shapr
09:07:48 <lambdabot> I saw shapr leaving #haskell 1 day, 23 hours, 11 minutes and 45
09:07:49 <lambdabot> seconds ago, and I have missed 21 hours, 35 minutes and 19
09:07:49 <lambdabot> seconds since then.
09:08:24 <gour> sethk: yes, you make a chart of event happened 5000 years ago to verify
09:08:32 <sethk> gour, interesting
09:09:42 <gour> sethk: if you are interested my teacher's site & interesting article about it is  at: http://shyamasundaradasa.com/jyotish/main/what_is_jyotish.ht
09:10:01 <gour> sethk: ahh, http://shyamasundaradasa.com/jyotish/main/what_is_jyotish.html
09:10:37 <gour> sethk: now i have to drive to my wife's parents, but will be back later in the evening...
09:10:47 <gour> sethk: if you happen to have some question
09:11:45 <gour> sethk: one intetresting article is on http://shyamasundaradasa.com/jyotish/resources/articles.html entitled ... Prasna
09:11:54 <sethk> gour, thanks
09:12:35 <gour> sethk: or http://shyamasundaradasa.com/jyotish/resources/predictions/2004_election/2004_us_elections.html prognosing US elections :-)
09:12:42 <gour> sethk: see u later
09:23:39 <genneth> does any one know of any attempts to implement a relational algebra in haskell?
09:24:39 <adept> genneth: you mean, like Codd's algebra etc.?
09:24:52 <adept> genneth: have you looked at haskelldb?
09:25:00 <genneth> i have
09:25:12 <genneth> it's great
09:25:25 <genneth> but i want to introduce my own types and functions into it
09:25:40 <sethk> genneth, I'm actually in the process of porting my database engine into haskell
09:25:50 <sethk> genneth, but I'm still a few weeks away from anything usable
09:25:59 <genneth> sethk: ooohh. what is it written it now?
09:26:04 <sethk> genneth, c++
09:26:34 <genneth> sethk: any code i could see?
09:27:03 <sethk> genneth, the c++ code you can see, is that what you meant?
09:27:09 <genneth> sethk: yes
09:27:16 <sethk> genneth, www.cql.com
09:27:31 <sethk> genneth, which should be working; let me know if it isn't  :)
09:28:15 <genneth> sethk: it's working fine, and I am very intrigued
09:28:22 <genneth> why are you porting it to haskell?
09:28:59 <sethk> genneth, I think there are some interesting commonalities between lazy functional and database that I can exploit
09:29:38 <sethk> genneth, plus it's interesting
09:29:42 <genneth> :-p
09:30:02 <neologism> sql is the most widespread declarative language ;)
09:30:15 <neologism> thats the only commonaliti I can think of
09:30:54 <sethk> neologism, there are parallels in the area of concurrency control.  plus
09:31:10 <sethk> neologism, a partially complete query is in some ways similar to a suspended computation
09:31:32 <genneth> I've been thinking that one of the weakest points of SQL is that the type system sucks
09:32:05 <sethk> genneth, yes, absolutely
09:32:16 <sethk> genneth, plus you don't have user defined types
09:32:35 <sethk> genneth, I'm going to have user defined types and value level locking
09:32:44 <sethk> genneth, the c++ version does not have either
09:32:51 <genneth> sethk: I'm using Postgres at the mo for a project, and I would love to be able to easily added UDTs
09:33:09 <sethk> genneth, yes, absolutely.
09:33:20 <sethk> genneth, it's a far from trivial thing, but I believe it's possible
09:34:09 <roconnor> [1,-2,3,-4,5,...]
09:34:18 <genneth> sethk: PG allows it, via C modules; which is not very nice, especially if i want to use 3rd party binary additions; I can't trust them to not crash the server
09:34:29 <roconnor> so hard to make
09:34:45 <sethk> genneth, allowing the server to crash is not an option IMHO
09:35:13 <sethk> genneth, which of course is another reason to use Haskell; that can't happen
09:35:24 <sethk> genneth, you can screw up your own type, but you won't crash the server
09:38:17 <genneth> roconnor: w = 1:(map (\x -> -((abs x)+1)*(sign x)) w)
09:38:43 <genneth> roconnor: and some good abs and sign
09:39:37 <genneth> sethk: I've been wondering about a way to make Postgres and Haskell sit nicely together
09:39:40 <roconnor> not bad
09:42:32 <roconnor> let fs = id:negate:fs in zipWith ($) fs [1..]
09:42:36 <roconnor> is what I came up with.
09:43:39 <roconnor> I particularly like saying ``zipWith ($)
09:43:42 <roconnor> I particularly like saying ``zipWith ($)''
09:44:40 <xerox> Yeah :)
09:45:12 <xerox> @eval let fs = id : negate : fs in take 10 $ zipWith ($) fs [1..]
09:45:13 <lambdabot> [1,-2,3,-4,5,-6,7,-8,9,-10]
09:45:28 <sethk> genneth, I'm still working out some parts of my design; as I said I think it should fly.  Then the performance will be an issue, but also a workable issue I believe.
09:45:29 <xerox> Very nice.
09:45:34 <sethk> genneth, but time will tell
09:48:30 <SyntaxNinja> good morning
09:48:41 <sethk> genneth, I think I've lost you.
09:49:51 <roconnor> @eval take 10 $ scanl (*) 1 [1..]
09:49:52 <lambdabot> [1,1,2,6,24,120,720,5040,40320,362880]
09:50:41 <xerox> roconnor: what's scanl?
09:51:02 <roconnor> scanl is like foldl, but spits out intermediate results.
09:51:18 <roconnor> I'm trying to learn to use it more often.
09:51:53 <roconnor> This is the best definition of factorials that I have seen.
09:58:58 <kala> I'm trying to build a rotate function (rotate :: Integer -> [a] -> [a]), which would shift list n times to the left. So, it follows quite logically that "rotate 1 (x:xs) = xs ++ [x] and rotate (n+1) x = rot . (rotate 1 x) where  rot y = rotate n y", but I'm getting syntax error
09:59:00 <kala> Prelude> :reload
09:59:00 <kala> ERROR "flatzip.hs":17 - Type error in application
09:59:00 <kala> *** Expression     : rot . rotate 1 x
09:59:00 <kala> *** Term           : rotate 1 x
09:59:01 <kala> *** Type           : [c]
09:59:03 <kala> *** Does not match : a -> b
09:59:17 <kala> is it possible to build the function that way?
09:59:33 <kala> ok, not the syntax error, but type error
10:00:33 <roconnor> you just want rot (rotate 1 x)
10:00:36 <roconnor> no .
10:00:47 <kala> hmm ...
10:01:20 <kala> right. and then I don't need the where rot= trick either
10:01:39 <roconnor> you could just say rotate n (rotate 1 x)
10:01:47 <roconnor> or even rotate 1 (rotate n x)
10:01:49 <roconnor> :-)
10:03:00 <roconnor> although this isn't the most efficient way to defining your function
10:03:20 <roconnor> @type splitAt
10:03:20 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:03:26 <roconnor> ;-)
10:03:38 <xerox> @eval splitAt 1 []
10:03:39 <lambdabot> Add a type signature
10:03:45 <xerox> @eval splitAt 1 [] :: (Int,Int)
10:03:46 <lambdabot> Couldn't match `Int' against `[a]'
10:03:55 <xerox> @eval splitAt 1 [] :: ([Int],[Int])
10:03:56 <lambdabot> ([],[])
10:04:00 <xerox> Okay :)
10:04:34 <roconnor> kala's implementation has the advantage of clearly being correct.
10:04:42 <roconnor> (expect for negative rotations)
10:04:57 <kala> roconnor: yes, I need to implement that yet
10:05:41 <roconnor> but you should be able take n `mod` (length l), split at that point, and switch around the resulting lists.
10:06:56 <kala> switch around means x:xs = xs ++ [x] ?
10:07:43 <roconnor> switch around means a++b where (b,a) = splitAt ...
10:07:49 <roconnor> is this a homework assignment?
10:08:02 <kala> roconnor: yes, this is a home assignement
10:08:50 <roconnor> okay, I've been trying to avoid giving an answer.  It may be best to go with your original idea for verion 1.0 ;-)
10:09:13 <kala> roconnor: well, its not much the idea of solving problem, but writing it in Haskell, which works
10:09:25 <kala> thing which I'm having troubles
10:09:39 <roconnor> yes.
10:10:31 <kala> I really like the way you can work with abstract functions in Haskell. much more abstract and clean than in C
10:11:58 <roconnor> yep, like in my previous problem: let fs = id:negate:fs in zipWith ($) fs [1..]
10:14:42 <svens> hi
10:17:41 <kala> can I apply map to function, which has two arguments?
10:18:10 <roconnor> technically yes, but it probably doesn't do what you think it will.
10:18:27 <roconnor> you will get a list of functions as a result.
10:18:30 <bringert> kala: what do want to achieve?
10:18:34 <kala> ah, never mind, I could use set constructor
10:19:42 <kala> rotations x = [rotate n x | n <- [1..(length x)]] was the thing I was after
10:23:25 <bringert> kala: another way: rotations x = map (flip rotate) [1..(length x)]
10:27:59 <kala> how does the x go to rotate function ?
10:28:03 <bringert> sorry
10:28:06 <bringert> kala: another way: rotations x = map (flip rotate x) [1..(length x)]
10:28:19 <kala> aha, now it makes sense
10:28:31 <bringert> @type flip
10:28:32 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
10:32:57 <gilles> hmm i don't understand something... should i be hable to define things in the interactive interface of ghci ?
10:33:05 <gilles> Prelude> x = 1
10:33:05 <gilles> <interactive>:1:2: parse error on input `='
10:33:07 <gilles> :-(
10:33:08 <roconnor> using let
10:33:11 <roconnor> let x = 1
10:33:15 <gilles> hmm
10:33:17 <gilles> thanks :-)
10:33:20 <roconnor> It's like you are in a giant do block
10:33:33 <gilles> okay
10:33:34 <roconnor> you can also do things like x <- getChar, or whatever
10:33:49 <chucky> yet another way of defining rotations (courtesy of farre): rotations xs = init $ zipWith (++) (tails xs) (inits xs)
10:33:54 <gilles> i'm just beginning to learn
10:33:55 <roconnor> not a very good example, but you get the idea.
10:37:56 <araujo> Hello Haskell'ers!
10:45:25 <basti_> hi araujo
10:53:15 <kala> @type ord
10:53:16 <lambdabot> Not in scope: `ord'
10:53:50 <kala> huh. I need to specifically import Data.Char? http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html#v%3Aord
10:54:37 <basti_> i think so, yes, kala
10:54:58 <xerox> @index ord
10:54:59 <lambdabot> Data.Char
11:13:21 <basti_> emacs crashed O.O
11:13:41 <kombinator> could someone try this definition: ebind = fmap . const ? (and sorry for repetition)
11:14:12 <kombinator> it gives me an error that I don't understand: "Ambiguous type variable `f' in the constraint..."
11:14:41 <kombinator> Here is a paste of the error: http://paste.lisp.org/display/12884
11:14:49 <int-e> @type fmap
11:14:50 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f
11:14:50 <lambdabot> b
11:15:22 <kombinator> @type fmap . const
11:15:23 <lambdabot> forall (f :: * -> *) a a1. (Functor f) => a1 -> f a -> f
11:15:23 <lambdabot> a1
11:15:32 <kombinator> it works here
11:16:07 <kombinator> but I get the abov error message if I dont specify type explicitly
11:17:09 <int-e> you need to provide an explicit type signature there
11:17:14 <int-e> ebind :: Functor f => a -> f b -> f a
11:18:41 <kombinator> But do you know why? I can eval it in ghci prompt but can't define it w/o the signature?
11:18:54 <int-e> it's called the monomorphism restriction, I think. see http://www.haskell.org/tutorial/pitfalls.html (12.3)
11:19:29 <int-e> @eval let ebind = fmap . const in 1
11:19:30 <lambdabot> Add a type signature
11:20:13 <int-e> same thing
11:20:19 <kombinator> but there are no bound identifiers in that expr
11:20:33 <int-e> sure. ebind is bound by the let declaration
11:20:35 <kombinator> (well, except ebind
11:21:12 <int-e> @eval let (ebind :: Functor f => a -> f b -> f a) = fmap . const in 1
11:21:13 <lambdabot>   Illegal signature in pattern: (Functor f) => a -> f b -> f
11:21:13 <lambdabot> a
11:21:13 <lambdabot>    Use -fglasgow-exts to permit it
11:21:24 <int-e> :/
11:22:00 <xerox> @type fmap . const :: Functor f => a -> f b -> f a
11:22:01 <lambdabot> Functor f => a -> f b -> f a :: forall a (f :: * -> *) b. (
11:22:01 <lambdabot> Functor f) => a -> f b -> f a
11:22:07 <int-e> @eval let ebind :: Functor f => a -> f b -> f a; ebind = fmap . const in 1
11:22:08 <lambdabot> 1
11:23:42 <xerox> @eval let ebind = fmap . const :: Functor f -> a -> f b -> f a in 1
11:23:42 <lambdabot>   Class `Functor' used as a type
11:23:42 <lambdabot>   In the type `Functor f'
11:23:42 <lambdabot>   In the type `Functor f -> a -> f b -> f a'
11:23:48 <xerox> Err, whatever :)
11:24:16 <kombinator> Does that meat that I have to provide type sigs for all statements that have types with type classes in them?
11:25:29 <int-e> pretty much, yes.
11:32:55 <vegai> how probable is it that lambdabot runs out of random input?
11:33:18 <vegai> I'm getting  getRandItem: empty list  for just about any plugin that uses random
11:52:02 <dcoutts> @seen vidvandre
11:52:03 <lambdabot> I saw vidvandre leaving #haskell 2 months, 2 days, 22 hours, 24
11:52:03 <lambdabot> minutes and 39 seconds ago, and I have missed 24 days, 5 hours,
11:52:03 <lambdabot> 6 minutes and 50 seconds since then.
11:54:51 <dcoutts> @seen marcot
11:54:52 <lambdabot> I saw marcot leaving #haskell-overflow, #haskell-blah and #
11:54:52 <lambdabot> haskell 3 hours, 2 minutes and 56 seconds ago.
11:55:12 * dcoutts tries to track down Gtk2Hs packagers
11:55:18 <dcoutts> @seen juhp
11:55:19 <lambdabot> I saw juhp leaving #haskell 6 days, 4 hours, 48 minutes and 31
11:55:19 <lambdabot> seconds ago, and I have missed 21 hours, 36 minutes and 18
11:55:19 <lambdabot> seconds since then.
11:59:46 <machack666> Is there a way to treat tuples how you would expect to use vectors, i.e., if I have (x,y) and I want to multiply by a scalar l, l * (x,y) = (l*x,l*y)?
12:00:17 <machack666> plus the additional (x1,y1) + (x2,y2) = (x1+x2,y1+y2)
12:00:40 <xerox> scalarMultiply n = (*n) &&& (*n)
12:00:51 <xerox> vectorSum = (+) *** (+)
12:01:39 <xerox> import Control.Arrow -- <blink>
12:02:12 <wilx> Omg, teh voodoo! :)
12:02:34 <xerox> :-)
12:02:43 <machack666> thanks for the info.  I don;t know if I'm ready to hurt mybrain that hard yet... :D
12:03:04 <adept> xerox: neat, but too complex imo :)
12:03:15 <xerox> adept: check the types, it's not!
12:03:54 <machack666> I'm hoping to use a tuple type...is that still possible?
12:03:58 <xerox> @type (Control.Arrow.&&&)
12:03:59 <lambdabot> forall (a :: * -> * -> *) c' c b.
12:03:59 <lambdabot> (Control.Arrow.Arrow a) =>
12:03:59 <lambdabot> a b c -> a b c' -> a b (c, c')
12:04:47 <xerox> in brief it does get a (b ~> c), and a (b ~> c') and return a  b ~> (c, c')
12:04:52 <xerox> @type (Control.Arrow.***)
12:04:53 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
12:04:53 <lambdabot> (Control.Arrow.Arrow a) =>
12:04:53 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
12:05:23 <xerox> Gets a (b ~> c), a (b' ~> c') and returns a (b, b') ~> (c, c')
12:05:50 <xerox> So you can see it as just working with tuples.
12:06:44 <adept> xerox: i mean, it's like with monads.
12:06:56 <xerox> Nah, I think it's much simpler.
12:06:57 <adept> xerox: types may be simple, but underlying machinery is not.
12:07:22 <adept> xerox: and oftern when you dont grok the internals, you could not use the tools
12:07:31 <xerox> It's not the case, I swear.
12:08:09 <xerox> @eval let dup = (id Control.Arrow.&&& id) in dup 2
12:08:10 <lambdabot> (2,2)
12:08:35 <xerox> @eval let dup = ((+10) Control.Arrow.&&& (*10)) in dup 2
12:08:36 <lambdabot> (12,20)
12:08:36 <adept> xerox: i made one pass at arrows article. no parser errors :) I hope that it will comple on second pass :)
12:08:40 <machack666> @eval dup 2
12:08:41 <lambdabot>  Not in scope: `dup'
12:08:59 <xerox> machack666: they go out of scope, you need to define it in every oneliner
12:09:59 <machack666> hmm...is there a friendly tutorial on arrows?
12:10:12 <xerox> (f &&& g) x = (f x, g x)
12:10:12 <xerox> (f *** g) (x,y) = (f x, g y)
12:10:19 <machack666> I don;t have time to read it now, but it'll definitely go on the "to-read" list
12:10:27 <xerox> Isn't it simple? :)
12:11:11 <machack666> so is it commutative? (f &&& g &&& h) x = (f x, g x, h x)?
12:11:14 <xerox> (Avoiding the underlying nastiness - that's what it does on the surface, so it's usable, in my opinion.)
12:11:49 <kombinator> machack666: I recommend http://www.haskell.org/arrows/ (has links to some tutorials) and even more http://www.soi.city.ac.uk/~ross/papers/fop.html
12:11:52 <machack666> wrong word probably
12:11:56 <xerox> @type id Control.Arrow.&&& id Control.Arrow.&&& id
12:11:57 <lambdabot> forall b. b -> (b, (b, b))
12:11:58 <dcoutts> Gtk2Hs 0.9.10 release candidate 2 is out!
12:11:58 <dcoutts> http://haskell.org/gtk2hs/gtk2hs-0.9.9.8.tar.gz
12:12:07 <machack666> thanks kombinator
12:12:18 <dcoutts> dons, time to get testing :-)
12:12:21 <adept> @type Control.Arrow.&&&
12:12:22 <lambdabot> parse error on input `Control.Arrow.&&&'
12:12:33 <xerox> @type id Control.Arrow.&&& (id Control.Arrow.&&& id)
12:12:34 <lambdabot> forall b. b -> (b, (b, b))
12:12:41 <xerox> @type (id Control.Arrow.&&& id) Control.Arrow.&&& id
12:12:42 <lambdabot> forall b. b -> ((b, b), b)
12:12:51 <xerox> It seems it's not.
12:12:56 <kombinator> dcoutts: let my slooow ghc compile it;)
12:13:10 <dcoutts> kombinator, heh, go for it
12:13:49 <dcoutts> psi, btw Axel said he had no trouble with Gtk+ on MacOSX but he was using rather older versions of Gtk+ (and probably gcc too)
12:15:43 <xerox> Those arrows operators were one of the first thing I learnt when I started Haskell (/me shakes TheHunter's hand)
12:15:51 <adept> xerox: so basically with arrows you program in "zip-unzip" fashion, combining stuff in tuple-of-tuples-of ... with '&&&' and splitting back with '*'
12:16:15 <xerox> adept: and there also are selecting operations
12:16:17 <adept> xerox: can you show some more real-life examples? :)
12:16:21 <xerox> @type Control.Arrow.first
12:16:22 <lambdabot> forall (a :: * -> * -> *) d c b.
12:16:22 <lambdabot> (Control.Arrow.Arrow a) =>
12:16:22 <lambdabot> a b c -> a (b, d) (c, d)
12:16:23 <xerox> @type Control.Arrow.second
12:16:24 <lambdabot> forall (a :: * -> * -> *) c d b.
12:16:24 <lambdabot> (Control.Arrow.Arrow a) =>
12:16:24 <lambdabot> a b c -> a (d, b) (d, c)
12:16:42 <xerox> Which models the more-stateful-than-monad ideas.
12:16:55 <xerox> ...aaaand, arrows composition.
12:17:03 <xerox> @type (Control.Arrow.>>>)
12:17:03 <lambdabot> forall (a :: * -> * -> *) d b c.
12:17:03 <lambdabot> (Control.Arrow.Arrow a) =>
12:17:03 <lambdabot> a b c -> a c d -> a b d
12:17:50 * adept dumps core
12:18:29 <ulfdoz> time to ulimit. :)
12:18:41 <xerox> It's simpler than it sounds, again :-)
12:19:09 <sandos> why cant I use a let in a do-block? trying to write my top-level io monad control loop, not going too well
12:19:21 <xerox> first :: (Arrow (~>)) => (b ~> c) -> ((b, d) ~> (c, d))
12:19:26 <adept> sandos: but you can
12:19:31 <xerox> (Yes you can use this syntax in GHC :-))
12:19:41 <sandos> oh, I think I solved it
12:19:46 <integral> xerox++ # wow!
12:19:48 <xerox> You see, applies the transformation to the first member of the tuple, and the second passes by.
12:20:02 <xerox> integral: @karma+ here ;-)
12:20:03 <sandos> let Z in do ... not do let .. in ...
12:20:12 <xerox> Then second, it's trivial again.
12:20:16 <xerox> adept: you see it?
12:21:14 <gour> dcoutts: i pulled gtk2hs from darcs repo and now gconfdemo compiles
12:21:15 <adept> @karma+ xerox
12:21:15 <lambdabot> xerox's karma raised to 9.
12:21:16 <xerox> (>>>) :: (Arrow (~>)) => (b ~> c) -> (c ~> d) -> (b ~> d)
12:21:25 <xerox> ¥A¥ (in honor to pugs too, heh)
12:21:41 <xerox> (>>>) is (.) for arrows.
12:21:44 <gour> dcoutts: but it gives: gconfdemo: user error (GConf: cannot get value of key, key is unset)
12:21:46 <sandos> oh, btw. I have this ~240 lines of tokeniser/scanner/interpreter, fully monad-free... now I cannot posslibly add a "load-from-disk" command in there without polluting the entire thing with IO monad stuff?
12:21:48 <xerox> Err, flip (.)
12:21:50 <adept> @type Control.Arrow.Arrow
12:21:51 <lambdabot> Not in scope: data constructor `Control.Arrow.Arrow'
12:22:00 <xerox> @kind Control.Arrow.Arrow
12:22:01 <lambdabot> Class `Control.Arrow.Arrow' used as a type
12:22:04 <xerox> heh.
12:22:15 <xerox> Arrow (a :: * -> * -> *)
12:22:18 <adept> sandos: but you cant
12:22:26 <sandos> cant?
12:22:33 <xerox> Let's #haskell-overflow the Arrows.
12:23:13 <adept> sandos: you mean "load-and-parse-file-and-return-data-structure-not-in-IO-monad"?
12:23:21 <xerox> (If anybody has questions/ideas)
12:23:37 <dcoutts> gour, the darcs repo will not be up to date
12:23:42 <sandos> adept: yes...
12:23:48 <adept> sandos: you cant
12:23:52 <sandos> it would suck somewhat to have to parse that outside the other parsing code..
12:23:54 <sandos> hm ok :(
12:23:56 <psi> dcoutts: ok. i have had it working too with older libraries. gtk 2.6 I think.
12:23:58 <adept> sandos: why would you want that?
12:24:01 <xerox> @google PArrows
12:24:01 <sandos> but "There are, in fact, some unsafe functions available to get around this problem but these are better left to advanced programmers. Debugging packages (like Trace) often make liberal use of these `forbidden functions' in an entirely safe manner. " ;)
12:24:02 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/PArrows/
12:24:04 <xerox> Cool reading.
12:24:20 <sandos> because it would be most intuitive, for me atleast, to place that code there
12:24:22 <gour> dcoutts: well, at least it does not segfaults, at least
12:24:32 <sandos> it works this other wat too, though...
12:24:57 <adept> sandos: i dont get that parsing outside of parsing thing
12:25:05 <sandos> Im doing a read-eval-print loop
12:25:14 <adept> xerox: do you have some code online with arrows in it?
12:25:16 <sandos> it calls this humongous interpreter
12:25:17 <dcoutts> gour, try gconftool-2 --recursive-unset /apps/gtk2hs-gconf-demo
12:25:39 <sandos> I think it would be nice to, for example, add a "import" command to the languare Im parsing.. that would parse the file from disk
12:25:52 <sandos> doing this in the top-level loop just isnt very structurally nice imo
12:25:53 <xerox> adept: it's better to not see it :-)  My test were something like childish playing with fold[rl] first argument :-)
12:26:04 <xerox> adept: e.g. Conway's Life :-P
12:26:17 <xerox> adept: but there is PArrows which is a nice reading.
12:26:28 <dcoutts> gour, I think that key existed for you before but with some values missing
12:26:47 <dcoutts> gour, the demo program does not do much error checking :-)
12:26:52 <adept> xerox: thanks!
12:27:23 <xerox> adept: you're welcome - please come to #haskell-overflow if you (or others) want to talk about them, or something.
12:27:45 <adept> xerox: why -overflow?
12:28:04 <adept> :0
12:28:05 <dcoutts> psi, is there a gtk2hs darwin ports maintainer?
12:28:05 <adept> :)
12:28:18 <dcoutts> psi, or would that person be you? :-)
12:28:19 <xerox> It's just to being to distinguish between overlapping discussions.
12:28:44 <xerox> I.e. help/gtk2hs/arrows+lambdabot's output/..
12:29:10 <xerox> Anyway, I think I'll go to sleep shortly.
12:29:23 <adept> sandos: why? is "res <- parseFromFile "aaa"" too unstructural for you?
12:30:45 <psi> dcoutts: no, no such port exists yet
12:31:50 <dcoutts> psi, is there anyone I could prod?
12:32:36 <sandos> adept: uhm, no, its just not placed where every other thing is interpreted.. thats all
12:32:45 <sandos> ie. in the traversal of the AST
12:33:40 * xerox hugs poetix - welcome!
12:34:17 <psi> dcoutts: hm. i have no insight in the darwinports project, but dwright -at- darwinports.com seems to be the maintainer for haskell stuff
12:34:19 * poetix emits muffled yet joyful sounds
12:34:27 <dcoutts> psi, ok thanks
12:34:37 <psi> sorry, gwright
12:34:41 <xerox> poetix: you missed a crash course on Arrows ;-)
12:34:47 <poetix> Dang
12:34:59 <poetix> Although I think I'm getting closer to understanding them by myself
12:35:09 <psi> sorry, that email address was entirely wrong.
12:35:09 <poetix> What I need now are some use cases
12:35:25 <psi> dcoutts: gwright -at- opendarwin.org
12:36:10 <dcoutts> psi, yep just found that at http://ghc.darwinports.com/
12:36:34 <psi> *nod*
12:44:06 <gour> dcoutts: pls. excuse me for not replying earlier, was abesent, gconfdemo now works :-)
12:44:29 <dcoutts> gour, ok great
12:47:06 <gour> dcoutts: so, release is (almost) ready?
12:47:20 <dcoutts> gour, probably
12:47:36 <gour> dcoutts: thumb up
12:47:40 <dcoutts> gour, now I just need to bully all the distro packagin people :-)
12:48:50 <gour> dcoutts: :-) what will be the version number of next release?
12:48:57 <dcoutts> 0.9.10
12:49:03 <gour> dcoutts: and do we how a sort of roadmap?
12:49:13 <gour> dcoutts: i meant one after 0.9.10
12:49:24 <dcoutts> we'll think of a roadmap after we get 0.9.10 out :-)
12:49:57 <gour> dcoutts: witty answer
12:58:00 <xerox> Goodnight folks.
12:59:10 <Cale> dcoutts: say I have a pair of (line,column) pairs, and I want to set the background colour of my TextView to red in between them. How do I do that? It seems overly complicated from the docs, perhaps I'm missing something.
12:59:42 <dcoutts> Cale, hIDE does that. The easiest thing is to go look at the code.
12:59:57 <dcoutts> Cale, basically it amounts to applying a 'tag' to a span of text
13:00:31 <Cale> yeah, it looks like I have to create a tag, register it with the TextBuffer in behind my TextView, and then create a pair of TextIters
13:01:23 <dcoutts> Cale, yes, textBufferGetIterAtLineOffset & textBufferApplyTag
13:02:07 <markg> does anyone know much about runplugs?  I keep getting an error when it runs and I'm not sure what the problem is.
13:02:11 <dcoutts> Cale, and when you register the tag, that's the point where you can set all the text attributes that the tag will modify.
13:03:01 <dcoutts> Cale, for some (rather complex) example code see hIDE/plugins/commonSense/src/Hide/CommonSense/SyntaxHighlight.hs
13:03:37 <dcoutts> Cale, see the addTag function and the code nearby
13:04:12 <Cale> Why do text iters exist? It's not clear to me that it wouldn't be easier to just use the buffer directly.
13:04:27 <dcoutts> Cale, the iters are indexes into the buffer
13:04:48 <Cale> yeah, but a pair of integers is enough to handle that, isn't it?
13:05:14 <Cale> I suppose they support a bunch of additional operations
13:05:18 <dcoutts> well internally the buffer is rather more complex than just an array of 8 bit chars
13:05:36 <dcoutts> they do support many other operations, like line & word operations
13:05:47 <dcoutts> including all the unicode aspect of things
13:06:04 <dcoutts> eg unicode word edge detection
13:06:38 <dcoutts> they actually hide some pretty complex algorithms
13:06:57 <Cale> hmm :)
13:07:07 <dcoutts> but you're right it could be made more convenient in the Haskell interface
13:07:22 <dcoutts> we don't want to see the fact that the iters are imperitive mutable things
13:07:27 <Cale> yeah
13:07:36 <dcoutts> suggestions welcome :-)
13:07:53 <dcoutts> Cale, what are you working on btw?
13:07:56 <Cale> well, I suppose there's the "always copy, then operate" way
13:08:16 <dcoutts> true, but it'd still need to be in the IO monad
13:08:18 <Cale> oh, just thinking about marking syntax errors in Nymphaea
13:08:23 <dcoutts> oh I see
13:08:36 <dcoutts> you know there's a nice red squiggly inderline attribute
13:08:52 <dcoutts> you might like to use that rather than a red background
13:08:54 <Cale> well, if you ensure that it's referentially transparent, you can use System.IO.Unsafe, and they become a new primitive type :)
13:09:05 <Cale> yeah, that might be nicer
13:09:18 <dcoutts> however they need to be in IO at this level since the buffer changes too
13:09:51 <Cale> ah
13:09:58 <Cale> and they become invalid
13:10:05 <dcoutts> that too
13:10:16 <dcoutts> the text markers are for persistent things
13:10:36 <dcoutts> it'd be possible to use iters purely in a limited scope with no buffer changes
13:11:19 <dcoutts> so a bunch of query iter operations could be done as a batch in a pure way
13:11:29 <Cale> I wonder what the best refinement of the IO monad would be so as to ensure that GTK operations are always used correctly :)
13:11:49 <dcoutts> we'd rather not use a GUI monad all over the place
13:12:16 <dcoutts> we already try in several places to use types to enforce Gtk invariants
13:12:27 <dcoutts> the cairo api is one nice example
13:12:31 <Cale> yeah
13:12:37 <dcoutts> it does use a different monad of course
13:13:13 <Cale> I suppose it's still possible to cheat a bit there with liftIO, but you have to go out of your way
13:13:54 <dcoutts> errTag <- Gtk.textTagNew "error"
13:13:54 <dcoutts> Gtk.set errTag [ Gtk.textTagUnderline := Gtk.UnderlineError ]
13:13:54 <dcoutts> Gtk.textTagTableAdd tagTable errTag
13:14:46 <dcoutts> Cale, yes using liftIO in the render monad is perfectly ok, it's just inconvenient
13:15:27 <Cale> in some sense you want it to be a little inconvenient because you might be doing something incorrect :)
13:15:35 <sethk> Cale, dcoutts, do what you advised me to do, which is to create functions to bury the use of liftIO in one place, at least one place for each situation
13:15:35 <dcoutts> yes
13:16:41 <Cale> sethk: yeah, that would be ideal -- I'm not sure if everything sensible could be covered here, but one could get a lot of things wrapped up and then rename liftIO to unsafeLiftIO :)
13:17:13 <sethk> Cale, it wouldn't be unsafe, really, would it?  :)
13:17:37 <Cale> sethk: well, it's possible to do things which crash the program using liftIO
13:17:53 <sethk> Cale, it is?  I wasn't aware of that.  How?
13:17:58 <dcoutts> Cale, no in the Render monad I think
13:18:02 <dcoutts> no/not
13:18:26 <sethk> Cale, if so I shouldn't use it.
13:18:28 <Cale> dcoutts: how about storing pointers to bounded resources
13:18:52 <dcoutts> Cale, yes that'd be bad. But you cen even do that without liftIO :-)
13:19:00 <dcoutts> but one shouldn't of course
13:19:11 <Cale> well, you can prevent it
13:19:15 <dcoutts> with* stlye functions always have that caveat
13:19:36 <dcoutts> because you could return the bounded resource as the return value
13:20:38 <dcoutts> you could prevent it by banning liftIO and makign the with* function return (). Or you could use forall like in runST
13:20:52 <Cale> yeah, I was thinking of using forall
13:21:13 <dcoutts> Cale, however that imposes quite a bit of syntactic overhead
13:21:26 <dcoutts> marcot, you were looking at packaging gtk2hs for debian right?
13:22:40 <sethk> I have to go out in the cold for a bit.  BRB.  :)
13:22:45 <Cale> hmm
13:23:29 <kala> could anybody look at the http://pastebin.com/407031. I'm getting error message "Cannot justify constraints in explicitly typed binding"
13:23:50 <kala> I suppose there is better way to write such function, but that should work as well?
13:24:09 <Cale> kala: add  "(Ord a) =>" to the start of the type sig
13:24:22 <kala> huh. Cale: that means what?
13:24:37 <Cale> That means that the values of type a are ordered in some way
13:24:44 <gzl> kala: you're using <, which you can only use for ordered values
13:24:45 <Cale> you can't use < on them without it
13:25:00 <gzl> kala: so (Ord a) => explicitly says that a must be some type in Ord
13:25:06 <Cale> or just comment the type signature, and ask hugs what type it infers
13:25:07 <kala> qzl: oh ...
13:25:33 <dcoutts> kala, one thing you can do in these situations is to remove the type signature that you added and just load it up in ghci/hugs and ask what type it gets infered as (using :type grows_until)
13:25:58 <dcoutts> then you can add that type signature
13:26:07 <kala> ok, very well.
13:26:13 <dcoutts> it might infer a more general type that you wanted however
13:26:21 <gzl> a stupid example:
13:26:22 <gzl> Prelude> let f (x:y:xs) = x < y
13:26:22 <gzl> Prelude> :i f
13:26:22 <gzl> f :: Ord a => [a] -> Bool       -- Defined at <interactive>:1:4
13:26:36 <dcoutts> kala, in which case you give a more specialied type signature
13:26:51 <dcoutts> marcot, ping
13:29:22 <marcot> dcoutts: sorry!
13:29:24 <marcot> I'm herer.
13:29:32 <marcot> The package is going up in a few days.
13:29:47 <marcot> I don't know why, but debian server take a time to include the package in the distro.
13:30:37 <dcoutts> marcot, heh just in time for 0.9.10 to be released
13:30:46 <dcoutts> that's was what I wanted to mention to you
13:31:00 <dcoutts> I just released the second release candidate
13:31:41 <dcoutts> do you get emails sent to debian-haskell@lists.urchin.earth.li ? or should I forward the email to you?
13:32:05 <marcot> dcoutts: I thought I got it.
13:32:09 <marcot> I don't know anymore.
13:32:20 <dcoutts> ok well I cc'ed that email address
13:32:23 <marcot> I didn't receive nothing nowadays.
13:32:44 <marcot> I'm on gtk2hs-users and devel
13:33:07 <dcoutts> marcot, ok in that case you'll get it, I sent the announcement to gtk2hs-users
13:33:08 <kala> ok, I'm desperate. could somebody point me to a direction of the solution. I need to find a point in the list, where numbers begin to decrease. So, for [1,2,3,3,2,3] the breakpoint would be the second '3'. In Haskell I can find out when the numbers don't grow anymore, but not the point when they start to decrease.
13:33:53 <ski> do you want an index ? or the number where they start to decrease ?
13:33:59 <kala> index
13:34:00 <dcoutts> kala, sounds like it might just be a case of changing a >= for a > somewhere
13:34:10 <marcot> dcoutts: of 0.10?
13:34:58 <dcoutts> marcot, I sent the announcement of the second release candiate for 0.9.10 (the actual version number of the second release candidate is 0.9.9.8)
13:35:13 <kala> hmm. actually, my current code works for [1,2,2,1], but not for [1,1,1]
13:35:40 <ski> what show the answer be for the latter ?
13:35:46 <ski> s/show/should/
13:35:56 <kala> Main> grows_until [1,1,1,1]
13:35:57 <kala> Nothing
13:35:57 <kala> Main> grows_until [1,1,2,1]
13:35:57 <kala> Just 2
13:35:57 <dcoutts> marcot, so the final release that will go on the SF mirrors in the next few days will be gtk2hs-0.9.10.tar.gz
13:38:38 <kala> aha, fixed that as well. ok, I suppose it works
13:38:48 <marcot> dcoutts: hum.. nice.
13:38:57 <marcot> When it gets released I'll update debians mirror.
13:39:39 <dcoutts> marcot, though I'd reccomend doing a test build first. That way I can fix any bugs or problems you have and you will not need to patch things later.
13:40:08 <marcot> With these release candidates?
13:40:34 <dcoutts> yes the current release candidate: http://haskell.org/gtk2hs/gtk2hs-0.9.9.8.tar.gz
13:40:53 <dcoutts> we'll only get bug-free releases if people test the release candidates :-)
13:41:34 <marcot> dcoutts: sure.. I'll work with it as soon as I have time. When do you intend to release it?
13:41:45 <dcoutts> probably by the end of the week
13:41:54 <kala> how do I use the "Maybe Int" data type in place of "Int"?
13:41:55 <dcoutts> unless anyone finds any major bugs
13:42:26 <dcoutts> @type Just 3
13:42:27 <lambdabot> forall a. (Num a) => Maybe a
13:42:50 <dcoutts> kala, use the Maybe data constructors Just and Nothing
13:43:02 <dcoutts> @type Nothing
13:43:03 <lambdabot> forall a. Maybe a
13:44:02 <kala> so, if my grows_until :: [a] -> Maybe Int, then how do I do (grows_until x) + (grows_until y) ?
13:44:28 <Cale> fmap (+) (grows_until x) (grows_until y)
13:44:32 <Cale> er
13:44:34 <Cale> liftM2
13:44:42 <Cale> liftM2 (+) (grows_until x) (grows_until y)
13:44:47 <Cale> or
13:44:56 <kala> ok, let me find the help for that function
13:44:58 <Cale> well, that's really the only nice way :)
13:45:03 <Cale> @type liftM2
13:45:04 <lambdabot> Not in scope: `liftM2'
13:45:09 <Cale> @type Control.Monad.liftM2
13:45:10 <lambdabot> forall r (m :: * -> *) a2 a1.
13:45:10 <lambdabot> (Monad m) =>
13:45:10 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:45:26 <Cale> so in this case
13:45:29 <Cale> m = Maybe
13:45:38 <Cale> a1,a2,r = Int
13:46:08 <Cale> and liftM2 :: (Int -> Int -> Int) -> (Maybe Int -> Maybe Int -> Maybe Int)
13:46:52 <gzl> kala: it would be worth your while to read a little bit about monads
13:47:15 <integral> ($) `app` (grows_until x) `app` (grows_until y)?
13:47:17 <gzl> kala: because that's what this liftM2 business is doing
13:47:21 <integral> @type Control.Monad.app
13:47:22 <lambdabot> Not in scope: `Control.Monad.app'
13:47:25 <Cale> ap
13:47:28 <integral> @type Control.Monad.ap
13:47:29 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m
13:47:29 <lambdabot> b
13:47:39 <kala> probably. I don't understand a thing. I guess I'm doing something wrong, because the solution shouldn't be so complex
13:48:06 <Cale> kala: well, what is it that you're doing?
13:48:20 <thedward> @pl freq xs = unionsWith (+) [ (singleton x 1) | x <- xs  ]
13:48:21 <lambdabot> freq = unionsWith (+) . return . ((singleton x 1 | x) <-)
13:48:39 <Cale> um, that looks broken :)
13:48:55 <ski> case grows_until x of
13:48:55 <ski>   Nothing -> Nothing
13:48:55 <ski>   Just i  -> case grows_until y of
13:48:55 <ski>     Nothing -> Nothing
13:48:55 <ski>     Just j  -> Just (i+j)
13:49:00 <thedward> uh. yeah
13:49:05 <ski> kala : that is the "primitive" solution
13:49:23 <thedward> guess that feature doesn't support list comprehension?
13:49:24 <ski> kala : liftM2 above does the same, but shorter
13:49:25 <kala> Cale: I'm supposed to write a function segments :: Ord a => [a] -> [[a]], which gives segments of a, which are not decreasing
13:49:39 <Cale> thedward: seems like that -- it uses its own parser
13:49:54 <ski> do i <- grows_until x
13:49:54 <ski>    j <- grows_until y
13:49:54 <ski>    return (i+j)
13:50:08 <ski> kala : that is another solution, using "do-notation"
13:50:16 <Cale> kala: groupBy (<)
13:50:46 <Cale> @eval groupBy (<) [1,2,3,1,2,3,4,5,5,1,2,3]
13:50:47 <lambdabot> [[1,2,3],[1,2,3,4,5,5],[1,2,3]]
13:51:04 <gzl> huh
13:51:09 <gzl> it does something odd for me
13:51:14 <gzl> groupBy (<) [1,2,3,2,1]
13:51:14 <gzl> [[1,2,3,2],[1]]
13:51:15 <kala> Cale: not fair :)
13:51:26 <Cale> @eval groupBy (<) [1,2,3,2,1]
13:51:27 <lambdabot> [[1,2,3,2],[1]]
13:51:30 <Cale> huh
13:51:32 <gzl> bad!
13:51:35 <Cale> that is bad :)
13:51:38 <Cale> hmm
13:51:42 <Cale> what?
13:51:43 <marcot> dcoutts: I don't know if I'll have time till that. But the mais problem of debian packaging I've already told you.
13:51:56 <Cale> ah
13:52:01 <Cale> I think I know why
13:52:13 <Cale> it's only comparing with the first thing
13:52:19 <Cale> not adjacent elements
13:52:34 <gzl> oh, I see
13:52:37 <Cale> annoying :)
13:52:47 <gzl> yeah, really annoying
13:52:58 <kala> huh, so the solution is not one line
13:53:03 <marcot> main
13:53:03 <ski> @type group
13:53:04 <Cale> that might be considered a bug even :)
13:53:04 <lambdabot> Not in scope: `group'
13:53:10 <ski> @type Data.List.group
13:53:11 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
13:53:17 <kala> well, so far I have come up with http://pastebin.com/407068, but its not working yet
13:53:17 <gzl> it should be. why would you want to compare against head
13:53:27 <dcoutts> marcot, ok no problem. It'll be nice to have an up to date gtk2hs release in debian at all! :-)
13:53:28 <ski> so, it assumes an equiv. class, i think
13:53:35 <ski> s/class/relation/
13:53:52 <Cale> yeah, but I don't think it's as useful to do that :)
13:54:44 <ski> kala : splitAt i xs = (take i xs,drop i xs)
13:55:26 <kala> ski: yes, I think I know that?
13:55:27 <marcot> dcoutts: ok, sorry anyway..
13:56:04 <ski> kala : so use it (in segments) :)
13:56:23 <kala> ski: well, I'm using this take and drop replacement of it already
13:56:44 <kala> but the code doesn't compile, because of this "Maybe Int" data type
13:56:54 * ski was suggesting the use of 'splitAt', instead
13:56:55 <ski> ah
13:56:58 <ski> hm
13:57:14 <kala> I'll try to rewrite it to get rid of this Nothing part
13:57:26 <ski> in 'grows_until' you always return something of 'Just' form, right ?
13:57:46 <ski> (because you add 'False' to the back of the list)
13:58:02 <kala> ski: yes, correct
13:58:18 <ski> so, you should just return an Int, then, i think
13:58:37 <ski> but 'elemIndex' returns a 'Maybe' ..
13:58:41 <kala> hughs doesn't like Int
13:58:51 <ski> case elemIndex .... of
13:58:55 <ski>   Nothing -> False
13:58:59 <ski>   Just b -> b
13:59:15 <ski> try that
13:59:26 <kala> ok
13:59:40 * glguy is reading http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/mark.pdf  and would recommend it to anyone learning Monads, IO, Concurrency, etc
13:59:50 <ski> (also, you shouldn't need to add 'False' to the end if you do this)
13:59:50 <glguy> (found in a link on haskell.org)
14:00:08 <machack666> does (||) shortcircuit in regards to argument evaluation?
14:00:13 <ski> yes
14:00:28 <ski> @eval True || error "Foo !"
14:00:29 <lambdabot> True
14:00:29 <Cale> machack666: most functions in Haskell shortcircuit :)
14:00:33 <ski> @eval error "Foo !" || True
14:00:35 <lambdabot> Foo !
14:00:42 <machack666> good old lazy eval...
14:01:10 <marcot> dcoutts: did you changed something to make the choose of the name of the directory easier?
14:02:09 <ski> (kala : of course you'll then need to change the signature of 'grows_until', too)
14:02:28 <kala> ski: yep, will do. thanks
14:02:36 <machack666> Cale: are you a friendly haskell-advice-dispensing program, or do you occasionally get some sleep? ;)
14:02:46 <Cale> machack666: I slept
14:03:08 * ski snickers
14:03:20 <sethk> Cale, that sounds like you slept once, and it was enough for the rest of your life.  :)
14:03:30 <Cale> sethk: heh
14:03:32 <machack666> sleep(1) ?
14:04:18 <ski> @eval System.Posix.sleep 1
14:04:18 <lambdabot>  Not in scope: `System.Posix.sleep'
14:04:21 <Cale> Control.Concurrent.threadDelay (10^6)
14:04:27 <ski> @type System.Posix.sleep
14:05:23 <gzl> kala: does this work? grows_until xs = findIndex (== True) (zipWith (>) xs (cycle xs)) where cycle (x:xs) = xs ++ [x]; cycle [] = [] ?
14:05:25 <glguy> @index sleep
14:06:05 <gzl> I don't remember if there's something in the Prelude that does what cycle does
14:06:06 <ski> glguy : lambdabot took a break, it seems ..
14:06:18 <glguy> cycle is in Prelude
14:06:23 <gzl> oh :)
14:06:36 <gzl> it's not listed here: http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
14:06:42 <kala> gzl: hmm ...
14:07:13 <gzl> kala: basically what that says is "give me the index of the first element that's greater than the element following it"
14:07:38 <kala> gzl: thats almost the same, what I'm doing :)
14:07:45 <gzl> kala: right, but this is shorter.
14:07:51 <kala> gzl: but yours is probably more sophisticated
14:08:03 <gzl> kala: and it's one line if cycle really is in the Prelude
14:08:03 <glguy> gzl, in the standard prelude, cycle xs = xs' where xs' = xs ++ xs'
14:08:27 <gzl> oh, that's different.
14:08:46 <gzl> I want something that does (tail xs) ++ [head xs]
14:08:50 <gzl> just moves the head to the end
14:08:53 <gzl> is that in there?
14:09:00 <Cale> no, I don't think so
14:09:03 <gzl> ok.
14:09:06 <gzl> well, whatever. simple enough
14:09:23 <ski> why do you want to rotate ?
14:09:27 <Cale> it's sort of an unfortunate thing to have to do, efficiency-wise
14:09:28 <glguy> gzl, you could do tail $ cycle xs
14:09:49 <gzl> glguy: that's an infinite list...
14:09:55 <gzl> kala: do you see what it's doing?
14:09:58 <glguy> gzl so?
14:10:03 <glguy> gzl, the first argument to zip wasn't
14:10:15 <gzl> huh?
14:10:18 <kala> gzl: findIndex still gives back Maybe Int ?
14:10:23 <ski> @eval (\xs -> zipWith (>) xs (tail xs)) [1,2,3,4,3,2,1,2,3,4]
14:10:23 <gzl> kala: yes
14:10:37 <gzl> ski: oh, I suppose I don't need to rotate at all
14:11:09 <gzl> forgot about that
14:11:23 <gzl> kala: so just use what ski just wrote, you don't need to have that cycle I put in
14:11:52 <ski> (of course, you need to handle the case when the list is empty specially)
14:11:53 <Cale> lambdabot: you're not here
14:11:57 <kala> gzl: yes, its working
14:12:03 <gzl> kala: ok. but do you see why?
14:12:19 <ski> kala : do you handle empty list, too ?
14:12:35 <gzl> ski: why? putting in [] will return Nothing, which is fine
14:12:43 <kala> grows_until [] => 0
14:12:44 <ski> ah
14:12:49 <ski> hm
14:12:51 <gzl> no, it should be Nothing
14:13:03 <kala> gzl: I put case ... of around it
14:13:16 <ski> grows_until :: Ord a => [a] -> Int
14:13:28 <gzl> dunno why, but ok.
14:14:24 <gzl> kala: it's not doing anything complicated, just check out what zipWith does and it should be pretty obvious
14:14:49 <ski> Prelude> let xs = [] in zip xs (tail xs) :: [((),())]
14:14:49 <ski> [] :: [((),())]
14:14:49 <ski> Prelude> let xs = [] in zip (tail xs) xs :: [((),())]
14:14:49 <ski> Program error: {tail []}
14:14:52 <ski> :)
14:14:57 <ski> (that was in hugs)
14:15:12 <gzl> Prelude List> f []
14:15:12 <gzl> Nothing
14:15:13 <ski> lambdabot: @hello
14:15:14 <gzl> that was in ghci
14:15:28 <kala> I think we have covered zipwith ... but when I try to use this grows_until in segments, I get Program error: pattern match failure: segments [Num_fromInt instNum_v32 1,Num_fromInt instNum_v32 2,Num_fromInt instNum_v32 3,Num_fromInt instNum_v32 2,Num_fromInt instNum_v32 3,Num_fromInt instNum_v32 4,Num_fromInt instNum_v32 4,Num_fromInt instNum_v32 3]
14:15:35 <ski> @eval (\xs -> zipWith (>) xs (tail xs)) [1,2,3,4,3,2,1,2,3,4]
14:15:40 <kala> "segment xs = [(take ((grows_until xs) + 1) xs)]"
14:16:08 <gzl> I have no clue what segment is, but at least grows_until seems to be doing what you want
14:16:12 <glguy> lambdabot gets moved to linux... and now we have no lambdabot :(
14:16:35 <gzl> ski: you keep trying to use @eval -- hint, it doesn't work right now :)
14:16:57 <ski> dons : lambdabot is not answering .. is she sulking ?
14:17:15 <glguy> @endsmokebreak
14:17:32 <kala> gzl: segments is supposed to take the first part of the xs, which grows_until identified and then work out the rest of the xs.
14:17:48 <gzl> kala: I don't know what that means. "work out the rest"?
14:17:55 <kala> gzl: split the rest
14:18:36 * ski hmms
14:18:36 <gzl> kala: ...so just do a splitAt.
14:18:50 <thedward> if I import Data.Map is there anyway I can still use '!' ?
14:19:04 <kala> gzl: yes, but I need to split the second part further more ...
14:19:06 <thedward> that is, use the ! operator on lists
14:19:18 <ski> (!!) :: [a] -> Int -> a
14:19:26 <thedward> I'm being dumb. thanks.
14:19:49 <Cale> but in general, you can import things hiding various functions
14:20:19 <ski> kala : hm, i think you might need to return a 'Maybe' from 'grows_until', after all ..
14:20:44 <ski> (because of what you want to do in segments)
14:20:48 <kala> gzl: the original task is to write a function segments :: [a] -> [[a]], which gives the list of parts of a, which are not decreasing.
14:20:49 <Cale> like if you wanted (!) to mean the array index operator, then you could import Map hiding (!)
14:21:01 <kala> ski: so, this error message I get is something fundamental?
14:22:03 <ski> kala : i guess it depends on what you want to do
14:22:12 <gzl> kala: ok. that shouldn't be too bad.
14:22:27 <gzl> kala: change findIndex to findIndices
14:22:35 <gzl> kala: now it'll give you a list of the places to split at
14:22:41 <kala> gzl: hmm ...
14:22:48 <kala> gzl: you could be right
14:22:50 <gzl> > f [1,2,3,2,3,1,2,3]
14:22:50 <gzl> [2,4]
14:22:56 <gzl> > f []
14:22:56 <gzl> []
14:23:10 <ski> kala : possibly the outer '[',']' in the second clause of 'segments' should be removed, though ..
14:23:17 <ski> hm
14:23:19 <gzl> kala: this way you don't even need to deal with Maybe
14:23:21 <lambdabot>  @help <command> - ask for help for <command>
14:23:23 <lambdabot> [False,False,False,True,True,True,False,False,False]
14:23:31 <lambdabot> Unknown command, try @listcommands.
14:23:32 <ski> @eval (\xs -> zipWith (>) xs (tail xs)) []
14:23:44 <Cale> oh, here's a good problem: given a string containing a bunch of u's and d's, find the number of permutations of 1..n which satisfy that pattern of ups and downs.
14:23:47 <lambdabot> Add a type signature
14:24:09 <ski> @eval (\xs -> zipWith (>) xs (tail xs)) [] :: [(Int,Int)]
14:24:09 <lambdabot> Couldn't match `(Int, Int)' against `Bool'
14:24:20 <ski> @eval (\xs -> zipWith (>) xs (tail xs)) [] :: [Bool]
14:24:21 <lambdabot> Add a type signature
14:24:31 * ski is stupid
14:24:48 <ski> @eval (\xs -> zipWith (>) xs (tail xs)) ([] :: [Int])
14:24:49 <Cale> that is, if the pattern is ud, valid permutations are 1 3 2 and 2 3 1
14:24:49 <lambdabot> []
14:26:26 <Cale> (so your program should return 2)
14:27:02 <ski> kala : yes, you should not give a singleton list in the second clause of 'segments'
14:28:22 <Cale> my program works in O(n^3) time where n is the minimum of the number of u's and the number of d's
14:29:05 <ski> hm
14:29:27 <int-e> hmm. I'd say O(n^2) is possible.
14:29:37 <int-e> ah, no.
14:29:42 <int-e> O(n^3) it is.
14:29:52 <Cale> I'd believe O(n^2.7) or so
14:30:45 <Cale> (the most costly operation I do is take a determinant)
14:33:41 <kala> gzl and ski: I'm still getting the same kind of error message. The code and message: http://pastebin.com/407142
14:35:22 <gzl> hmm
14:36:02 <kala> put "Ord(a) =>" to segments definition, but no change
14:37:04 <Cale> um "segments" isn't defined on nonempty lists
14:37:16 <Cale> perhaps you want to add an 's' to segment
14:37:29 <ski> of course
14:37:29 <kala> Cale: ah!
14:37:45 <ski> @index elemIndices
14:37:46 <lambdabot> Data.List
14:37:55 <ski> @type Data.List.elemIndices
14:37:56 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
14:38:06 <ski> elemIndices True
14:38:10 <Cale> Hugs' error messages for pattern match failures are kind of poor
14:38:14 <ski> findIndices id
14:38:18 <ski> should also work
14:39:40 <gzl> kala: that's not what you want, anyway.
14:39:51 <int-e> Oh, it is O(n^2) indeed :)
14:40:17 <kala> gzl: yes, I already fixed that
14:40:19 <kala> Main> segments [1,2,3,2,3,4,4,3]
14:40:19 <kala> [[1,2,3],[2,3,4,4],[3]]
14:40:24 <SamB> anybody got ghci to run out of CVS lately?
14:40:26 <int-e> @lisppaste
14:40:27 <lambdabot> Unknown command, try @listcommands.
14:40:30 <int-e> hmm
14:40:34 <gzl> kala: ok, good. so you're finished?
14:40:41 <int-e> lisppaste2, help
14:40:42 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:41:21 <kala> gzl: almost. segments [1,2,3] should give [[1,2,3]], but gives [[1],[2],[3]]
14:41:55 <Cale> int-e: which algorithm are you referring to (and are you using the same n as I am?)
14:42:27 <gzl> kala: paste your latest code
14:42:31 <gzl> I don't know what code you're looking at now
14:42:33 <int-e> Cale: no, it's not the same n, n is the length of the pattern - so the algorithm is worse for few 'u's or 'd's
14:43:55 <lisppaste2> int-e pasted "O(n^2) up-down-pattern solution" at http://paste.lisp.org/display/12911
14:45:43 <Cale> nice :)
14:46:57 <ski> @eval let permsUpDown = loop 0 0; loop below above [] = 1 ; loop below above (up:ups) | up = sum [loop (below+middle+1) upper ups | (middle,upper) <- split above] | otherwise = sum [loop lower (1+middle+above) ups | (lower,middle) <- split below]; split n = map (\i -> (i,n-i)) [0..n]; in permsUpDown [True,False,True]
14:46:58 <lambdabot> 5
14:47:25 <kala> gzl: I think everything runs fine now. the final code: http://pastebin.com/407163. Thanks for everybody, who helped :)
14:47:37 <ski> int-e : oh, shiny :)
14:48:06 <int-e> Cale: I originally thought I'd have to use map sum . inits   and  map sum . tails  before I realized it could be done with scanl and scanr - that would have been O(n^3)
14:48:25 <Cale> int-e's solution also has a much lower constant than mine :)
14:48:55 <Cale> I didn't really code mine for speed though, it was to apply a particular theorem.
14:49:21 <praseodym> just wondering, does http://www.haskell.org/complex/ (lambda complex)'s naming have anything to do with halflife?
14:49:25 <gzl> kala: cool
14:49:33 <Cale> praseodym: no, I don't think so :)
14:49:57 <ski> kala : please don't '== True'
14:50:00 <praseodym> Cale: because lambda complex is actually something in half life..
14:50:06 <fnord123> no one in #haskell-girls ?
14:50:09 <Cale> praseodym: I know
14:50:24 <kala> ski: shy?
14:50:25 <ski> kala : and i think you don't need to '++ [False]' since you handle the 'Nothing' case
14:50:39 <ski> @pl (== True)
14:50:40 <lambdabot> (True ==)
14:50:42 <ski> bah
14:50:54 <kala> ski: well. there are actually two cases. if the list is always increasing, or the list is always decreasing.
14:51:22 <kala> ski: if the list is increasing, I need to get the length(xs). if the list is decreasing, I need to get 0.
14:51:30 <Cale> int-e: what I do is to produce a particular matrix of binomial coefficients based on the lengths of the runs of 'u' or 'd', and then take the determinant of that matrix
14:51:32 <ski> hm
14:51:34 <praseodym> if (1 == true) == false then false = true
14:52:50 <kala> ski: hmm. I could be just wrong here ...
14:52:52 <praseodym> Cale: never played hl though
14:53:29 <ski> kala : hm, you are prolly right in the second case
14:54:05 <ski> kala : but i think it's nicer to use elemIndex, though
14:54:11 <Cale> praseodym: you should at some point if you like FPS games, it's decent :)
14:54:55 <praseodym> Cale: I played unreal tournament 2003/4 for a long time.. but when I had other things to do I didnt really care fixing my pc so it runs a decent fps...
14:55:07 <praseodym> Cale: last fps being frames per second
14:55:21 <int-e> Cale: I have no idea what you're doing :)
14:55:27 <kala> ski: nah, me wrong again. http://pastebin.com/407183 should be the new code and without this ++ [False]
14:55:39 <gzl> yeah, I dunno why you added that ++ [False]
14:56:08 <kala> gzl: because I'm not smart :)
14:56:27 <ski> (kala : hm, also, write 'foo : bar' instead of '[foo] ++ bar')
14:56:51 <gzl> anyway, remember the way that grows_until works, it's a handy pattern that you can often use
14:57:01 <gzl> zipWith is useful
14:59:05 <kala> gzl: basically, you make two lists (xs and (tail xs)), and put them together to pairs and apply (>) to pairs?
14:59:48 <Cale> http://vx.hn.org/autoshare/pattern.hs -- you can examine it if you'd like -- I wrote it closer to when I was just starting out learning Haskell, so it's perhaps not as polished as it could be. It also doesn't explain the algorithm.
15:00:36 <Cale> it additionally handles w's where w = u + d
15:00:49 <Cale> but it doesn't handle them in a smart way
15:01:03 <Cale> which it could if I used another algorithm from that course :)
15:01:31 <gzl> kala: yes
15:01:37 <Cale> but I'd need to write some code to manipulate polynomials in noncommuting indeterminates more conveniently
15:01:48 <gzl> kala: it lets you operate on two lists component-wise, in other words
15:03:09 <kala> gzl: very good.
15:03:12 <gzl> kala: so any time you want to figure out where <something> happens in a list, you could use this pattern
15:03:27 <kala> well, I'm off to bed now. bye everybody.
15:03:34 <gzl> later
15:05:09 <int-e> Cale: It's funny how you use Parsec but no list comprehension :)
15:05:30 <Cale> yeah
15:06:07 <Cale> well, there are instances of list comprehensions, I just wasn't always using them when it was suitable :)
16:40:28 <araujo> Hello Haskell'ers!
16:41:38 <ski> @yay
16:41:39 <lambdabot> Maybe you meant: map yow
16:43:36 <marcot> dcoutts: r u there?
16:49:06 <Cale> @yow
16:49:07 <lambdabot> I had a lease on an OEDIPUS COMPLEX back in '81 ...
16:49:10 <Cale> @yow
16:49:10 <lambdabot> We just joined the civil hair patrol!
16:50:49 <dcoutts> marcot, hello
16:51:05 <dcoutts> JohnMeacham, bte amd64 does indeed use a register-based calling convention by default
16:51:12 <dcoutts> bte/btw
16:51:55 <dcoutts> JohnMeacham, it's one of the sensible things they were able to do when they designed the amd64 ABI
16:51:56 <marcot> dcoutts: so, have you done something yet about changind the name of the installed packages?
16:52:07 <marcot> Of the directory.
16:52:25 <dcoutts> marcot, no. I'm not quite sure what the best way to tackle that is.
16:52:27 <marcot> It would be ideal if it's easy to split the instalation each ghc package in a directory.
16:52:41 <dcoutts> marcot, right. I'll have a think about it.
16:53:00 <dcoutts> I'll see if there's anything I can do to make that easier for you.
16:53:01 <marcot> something like, --gtk-libdir=libghc6-gtk-dev
16:53:52 <dcoutts> it's more likely to be by passing values to make, eg: make install gliblibdir=... gtklibdir=...  etc
16:54:22 <marcot> dcoutts: remeber that it must be changed also in the .conf files.
16:54:36 <marcot> that's why I thought about configure.
16:54:38 <dcoutts> yes, that happens during make install
16:54:49 <dcoutts> (I think)
16:55:00 <dcoutts> well I'll make sure it works :-)
16:55:09 <marcot> oh, you're right.
16:55:19 * dcoutts must go to bed now
16:55:31 * marcot too
16:55:37 <marcot> what time is it there?
16:57:27 <dcoutts> @localtime dcoutts
16:57:57 <dcoutts> lambdabot, hello!
16:58:05 <dcoutts> @botsnack
16:58:06 <lambdabot> :)
16:58:09 <dcoutts> @localtime dcoutts
16:58:17 <dcoutts> bah!
16:58:27 <dcoutts> s'not working
16:58:43 <dcoutts> 1am
16:58:53 * dcoutts is really going to bed now
16:58:57 <marcot> ok..
16:59:02 <marcot> here is 22h
16:59:08 <marcot> good night.
17:03:17 <dons> @localtime dons
17:03:28 <dons> hmm
17:03:36 <sethk> @localtime dons
17:03:41 <SyntaxNinja> dons: try your watch ;)
17:03:48 <sethk> I had that happen a couple of days ago with @localtime
17:03:49 <dons> :P
17:03:51 <sethk> then it started working again
17:04:46 <dons> it worked for you ski?
17:05:07 <ski> localtime, yes
17:05:07 <dons> (according to the logs, at least)
17:05:12 <ski> :)
17:05:23 <dons> @localtime dons
17:05:24 <ski> @localtime ski
17:05:26 <lambdabot> Local time for ski is Thu Oct 27 02:05:04
17:05:40 <ski> * Received a CTCP TIME from lambdabot
17:05:41 <dons> once again ski gets a reply, and dons doesn't :/
17:05:52 <sethk> I didn't get a reply either
17:05:53 <ski> maybe you somehow don't reply to that .. or block it .
17:05:53 <sethk> @yow
17:05:54 <lambdabot> Here I am in 53 B.C. and all I want is a dill pickle!!
17:06:02 <sethk> but @yow, no problem  :)
17:06:11 <dons> well, it used to work, and I haven't changed my client.
17:06:19 <stefanw> maybe we can trick lambdabot.
17:06:21 <dons> however, lambdabot changed boxes, hmm, possibly irc nodes too
17:06:24 <sethk> dons, it sometimes works for me
17:06:24 <stefanw> @localtime stefanw
17:06:39 <dons> I wonder if it is related to particular irc nodes
17:06:49 <ski> @localtime lambdabot
17:07:08 <dons> lambdabot doesn't know how to reply to that
17:07:15 <ski> hehe
17:07:22 <dons> it does get the '":\SOHTIME\SOH"' msg though
17:07:31 * ski assumed @localtime used the @map, before ..
17:07:54 <dons> oh no, check the logs -- *way* too hard
17:08:12 <ski> which logs ?
17:08:29 <sethk> @localtime ski
17:08:30 <dons> we discussed it in the channel logs, last week sometime
17:08:31 <lambdabot> Local time for ski is Thu Oct 27 02:08:10
17:08:47 <sethk> hmm, seems to depend on the user in the @, not the user making the call?
17:08:51 <sethk> @localtime sethk
17:08:55 <sethk> @localtime ski
17:08:57 <lambdabot> Local time for ski is Thu Oct 27 02:08:36
17:09:00 <ski> @localtime sethk
17:09:17 <sethk> ski, try @localtime ski
17:09:28 <ski> @localtime ski
17:09:29 <lambdabot> Local time for ski is Thu Oct 27 02:09:08
17:09:33 <ski> works as expected
17:09:34 <dons> ah ha!
17:09:42 <dons> if I do /ctcp time dons, I get: Private messages from unregistered users are currently blocked due to spam
17:09:51 <ski> aha
17:09:52 <dons> damn freenode
17:09:59 <ski> there's a command to allow those
17:10:00 <ski> hm
17:10:01 <sethk> I'm not an unregistered user
17:11:19 <dons> @localtime dons
17:11:22 <lambdabot> Local time for dons is Thu Oct 27 10:05:14 2005
17:11:22 <lambdabot> Local time for dons is Thu Oct 27 10:05:14 2005
17:11:22 <lambdabot> Local time for dons is Thu Oct 27 10:05:14 2005
17:11:22 <lambdabot> Local time for dons is Thu Oct 27 10:05:14 2005
17:11:27 <ski> ouch
17:11:32 <psi> heh
17:11:32 <sethk> @localtime dons
17:11:34 <dons> hehe. I NickServ identify'd
17:11:35 <lambdabot> Local time for dons is Thu Oct 27 10:05:28 2005
17:11:51 <sethk> dons, but I was and am already identified
17:12:04 <sethk> @localtime sethk
17:12:25 <dons> maybe you got unidentified some how?/
17:12:27 <ski> possibly you don't allow /msg from unregistered users ..
17:12:27 <sethk> dons, I checked, it says "you have already identified"
17:12:35 <sethk> @localtime sethk
17:12:38 <sethk> weird
17:12:46 <psi> @localtime psi
17:12:52 <dons> sethk, then possibly you have one of the clients that doesn't respond. has it worked previously?
17:13:03 <sethk> dons, it works if I do it for ski  :)
17:13:05 <sethk> @localtime ski
17:13:07 <lambdabot> Local time for ski is Thu Oct 27 02:12:46
17:13:09 <ski> sethk : what happens if you /msg lambdabot @hello ?
17:13:21 <dons> good test, ski
17:13:29 <sethk> so far, no response
17:13:32 <ski> ok
17:13:35 <sethk> but lambdabot works, in general
17:13:44 <psi> why doesn't it work for me?
17:13:48 <ski> so, you don't allow responses from unregistered, i think
17:13:55 <psi> my client responds to ctcp time
17:14:28 <sethk> ski, if that's the default, that's possible.  I don't have anything set for that
17:14:48 <psi> oh, lambdabot is unidentified
17:15:02 <sethk> but then why can I do @localtime ski   ?
17:15:08 <sethk> @localtime ski
17:15:10 <lambdabot> Local time for ski is Thu Oct 27 02:14:48
17:15:15 <sethk> lambdabot is still lambdabot
17:15:23 <dons> i've now identified lambdabot
17:15:34 <dons> (wonder why that didn't happen automagically. it is supposed to. hmm)
17:15:39 <psi> @localtime psi
17:15:39 <dons> @localtime sethk
17:15:40 <lambdabot> Local time for sethk is Wed Oct 26 20:15:17
17:15:40 <lambdabot> Local time for sethk is Wed Oct 26 20:15:17
17:15:40 <lambdabot> Local time for sethk is Wed Oct 26 20:15:17
17:15:41 <lambdabot> Local time for sethk is Wed Oct 26 20:15:17
17:15:43 <lambdabot> Local time for sethk is Wed Oct 26 20:15:17
17:15:44 <dons> ah ha!
17:15:45 <lambdabot> Local time for psi is Thu Oct 27 02:15:23 2005
17:15:47 <lambdabot> Local time for psi is Thu Oct 27 02:15:23 2005
17:15:47 <ski> i have /set something iirc that allows me to msg lambdabot
17:15:49 <psi> :D
17:16:11 <sethk> ah, now I have a lambdabot window
17:16:22 <dons> @localtime stefanw
17:16:23 <lambdabot> Local time for stefanw is Thu Oct 27 10:13:55
17:16:23 <lambdabot> Local time for stefanw is Thu Oct 27 10:13:55
17:16:28 <sethk> does lambdabot send a message to, say, ski, who sends the time to me?
17:16:48 <sethk> then it more or less makes sense
17:16:57 <psi> lambdabot sends a message to the target, which responds to lambdabot, which says it in the channel
17:17:00 <dons> you talk to the channel and lambdabot sends "\^ATIME\^A" to ski.
17:17:18 <ski> /msg nickserv set unfiltered on
17:17:22 <dons> ski sends back to lambdabot, lambdabot passes it to the Localtime plugin, which feeds it back the the person who asked
17:17:29 <ski> a helpful person on #freenode said
17:17:35 <ski> sethk : try that
17:17:46 <sethk> ski, I can't, because now I see everything
17:17:53 <ski> ?
17:17:55 <sethk> ski, to put it another way, it won't show anything any more
17:18:06 <sethk> ski, dons did some black magic with lambdabot
17:18:19 <dons> oh, I identified lambdabot
17:18:22 <ski> @localtime ski
17:18:23 <lambdabot> Local time for ski is Thu Oct 27 02:18:02
17:18:33 <ski> @localtime clog
17:18:35 <lambdabot> Local time for clog is Wed Oct 26 17:18:34 2005
17:18:43 <ski> dons : ok
17:19:52 <dons> possibly if lambdabot disconnects and reconnects, it forgets to identify automatically
17:20:20 <ski> try
17:33:16 <dons> vegai, not sure if you solved it, but your randItem bug is due to an empty input list, not an empty random list.
17:33:37 <dons> it's trying to take a random element of the empty list for some reason, probably due to missing quotes files, and the like
17:48:09 <dons> @seen JohnMeacham
17:48:10 <lambdabot> JohnMeacham is in #haskell. I don't know when JohnMeacham last
17:48:10 <lambdabot> spoke.
17:48:38 <dons> JohnMeacham, nice analysis of ghc code gen issues  :)
17:48:54 <sethk> dons, why does he say I don't know?  Does that mean that lambdabot restarted and JohnMeacham was in the room at that time?
17:49:05 <dons> yep
17:49:16 <dons> he's been here since lambdabot switched over to the linux box
17:49:30 <dons> which is a bit like day 0 for lambdabot. he has no @seen memory beforee that time
17:50:09 <ski> no persistent state for that ?
17:50:41 <dons> yes, we have persistent state, but it was slightly corrupted due to bugs in the @seen plugin. the move was a good chance to flush that state
17:51:18 <dons> the @seen bugs were solved long ago, but their effect was still floating around in the persistent data
17:51:24 <ski> oh
17:51:27 <araujo> Hello Haskell'ers!
17:51:45 <ski> hello araujo'ers
17:52:17 <araujo> That's me!!!
17:58:02 <araujo> Ok, a question, i don't know if this is possible at all though, how could i iterate over a list of values and applying IO monadic functions to some elements?
17:58:22 <dons> @type mapM_
17:58:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
17:58:31 <Cale> @type mapM
17:58:32 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [
17:58:32 <lambdabot> b]
17:59:01 <araujo> mm.. yeah, already knew those two... mmm.. i think my problem is different..
17:59:36 <Cale> araujo: well, what are you trying to do?
18:00:05 <araujo> Cale, yeah, hold, let me check the code better and re-formulate my question.....
18:06:51 <araujo> mm.. yeah.. mapM makes the trick
18:07:17 * araujo was probably too drowsly when looked at the code
18:07:26 <araujo> Thanks.
18:07:32 <Cale> np
18:11:38 <glasser> i have two Maps whose values are doubles.  I'd like to say that they are the same map if they have the same keys and the corresponding values are within some epsilon of each other.  Data.Map doesn't seem to have an "equalBy" -- what's the best way to go here?
18:12:03 <glasser> (actually, the values are "type Probability = Double".  Is it possible to declare an instance of Eq on Probability that differs from Double's == ?)
18:12:16 <ski> (no, for the latter question)
18:12:23 <Cale> if you make Probability a newtype then yes
18:12:41 <glasser> (it doesn't seem to be -- is that what newtype is for?)
18:12:46 <ski> (you could do  'newtype Probability = P Double', though)
18:12:55 <Cale> yeah, that's basically what newtype is for
18:12:58 <glasser> If I change my type to newtype, is that going to break everything else in my program?
18:13:02 <Cale> yes
18:13:05 <ski> no
18:13:07 <Cale> we
18:13:08 <Cale> well
18:13:21 <ski> just where you actually need to use it as Double
18:13:25 <Cale> it will require many constructors to be added
18:13:26 <glasser> I've been pretty consistent about saying Probability, not Double
18:13:43 <glasser> and I won't be magically able to use math operators on Probability, right?
18:13:48 <Cale> hmm
18:13:56 <ski> if you instance Num Probablility, you could
18:14:10 <Cale> you might be able to just say deriving Num, but that might write in an Eq instance as well
18:14:15 <Cale> I'm actually not sure
18:14:22 <ski> hm
18:14:40 <ski> possibly one can give an explicit Eq instance, and derive the Num
18:14:46 * ski isn't sure, either
18:14:48 <Cale> yeah, try that :)
18:14:52 <glasser> Num is not derivable
18:14:57 <glasser> oh, wait, I need some glasgow exts
18:15:02 <ski> in ghc it is, for newtypes
18:15:06 <ski> right
18:16:25 <Cale> yeah, that works
18:16:33 <glasser> I'm getting there...
18:17:25 <Cale> {-# OPTIONS_GHC -fglasgow-exts #-}
18:17:25 <Cale> epsilon = 0.01
18:17:25 <Cale> newtype Probability = P Double deriving (Num, Show)
18:17:25 <Cale> instance Eq Probability where
18:17:25 <Cale>     (P x) == (P y) = abs (x-y) < epsilon
18:18:17 <glasser> What I have working is
18:18:18 <glasser> newtype Probability = P Double
18:18:19 <glasser>   deriving (Num, Show, Ord, Fractional, Read)
18:18:19 <glasser> instance Eq Probability where
18:18:19 <glasser>   x == y = (abs (x - y)) < 0.00001
18:18:28 <Cale> yep
18:18:40 <Cale> you can actually hide the P constructor
18:18:57 <glasser> how's that?
18:19:06 <glasser> also, where does the options_ghc go? just the first line of the file?
18:19:06 <Cale> don't export it from your module
18:19:09 <Cale> yeah
18:20:21 <glasser> neat, ghc can do file-by-file extensions? cool.
18:20:48 <glasser> Hmm
18:20:50 <Cale> deriving (Num, Show, Read, Ord, Fractional, Enum, Real, RealFrac, RealFloat, Floating)
18:21:06 <glasser> if I have a "module ProbFunction where" "import Probability" (and other stuff)
18:21:17 <glasser> and a "module Probability (Probability) where"  (define Probability)
18:21:24 <glasser> then I can use Probability fine in ProbFunction
18:21:27 <Cale> right
18:21:33 <glasser> but not in something that imports it -- how do I re-export it?
18:22:07 <Cale> I think you add it to the export list for your module
18:22:22 <glasser> Hmm, but I'm trying to export everything so I have no list...
18:22:28 <Cale> hmm
18:23:01 <stefanw> dons: is there any version of hs-plugins where System.Plugins.Utils is not hidden (I want to compile riot, which uses two functions from this module)
18:23:13 <Cale> oh
18:24:16 <glasser> Hmm, the onlinereport implies that "module ProbFunction (module ProbFunction, Probability)"
18:24:19 <glasser> might do the trick
18:24:26 <dons> stefanw, the current darcs version looks ok.
18:24:34 <Cale> ah
18:24:36 <Cale> yeah
18:24:56 <Cale> module ProbFunction (module Probability) where... is how you reexport anyway
18:25:10 <dons> hmm, we should cabalise riot too. the build system is wacky
18:25:40 <Cale> glasser: you might at some point care to redo the instances of show and read to make the transition to Probability values more transparent
18:26:10 <glasser> Oh, it's showing P everywhere. good point
18:26:14 <dons> stefanw, btw, *almost* finished your thesis. i'll have a chat to you today or tomorrow about it
18:26:17 <glasser> wait, will the read instance expect a "P " prefix? bah
18:26:18 <dons> sorry for the delay
18:26:25 <Cale> glasser: yeah
18:26:34 <stefanw> dons: np
18:26:40 <Cale> it's really easy to write a new read instance of course :)
18:27:04 <Cale> read xs = P (read xs)
18:28:23 <glasser> Heh, I was just about to type "how would I do that read instance" :)
18:28:45 <ski> hm, can't you derive that instance ?
18:29:06 <ski> nvm
18:29:08 <Cale> ski: the derived instance expects a "P ..."
18:29:14 <glasser> huh, that didn't work
18:29:15 <glasser> ./Probability.hs:11:2: `read' is not a (visible) method of class `Read'
18:29:16 <ski> right
18:29:51 <Cale> oh
18:29:57 <Cale> readsPrec
18:30:18 <ski> readsPrec p xs = map (\(x,y) -> (P x,y)) . readsPrec p xs
18:30:18 <ski> ?
18:30:52 <Cale> yeah
18:30:57 <Cale> that ought to do it
18:31:41 <glasser> Not quite
18:31:47 <glasser>     Couldn't match `[(a, String)]' against `t -> t1'
18:31:48 <glasser>       Expected type: [(a, String)]
18:31:48 <glasser>       Inferred type: t -> t1
18:31:49 <glasser>       Expected type: a1 -> [(Double, b)]
18:31:49 <glasser>       Inferred type: [(a, String)]
18:31:52 <glasser>     Probable cause: `readsPrec' is applied to too many arguments in the call
18:31:55 <glasser>         (readsPrec p xs)
18:32:02 <ski> ah, doh
18:32:10 <ski> readsPrec p xs = map (\(x,y) -> (P x,y)) (readsPrec p xs)
18:32:14 <Cale> readsPrec p xs = map (\(x,y) -> (P x,y)) (readsPrec p xs)
18:32:17 <Cale> yeah
18:32:19 <ski> :)
18:32:55 <ski> readsPrec = map (\(x,y) -> (P x,y)) .: readsPrec    where (.:) = (.) . (.)  --iow
18:33:11 <Cale> heh
18:33:22 * ski freezes ..
18:34:28 <glasser> Awesome.
18:34:33 <glasser> Thanks a lot, both of you.
18:34:39 <Cale> @pl \f g x y -> f (g x y)
18:34:40 <lambdabot> (.) . (.)
18:34:56 <glasser> now I have unit tests for my conditional probability multiplication function!
18:35:17 <Cale> and Probability types are checked
18:35:19 <Cale> :)
18:35:30 <Cale> you can't put a double where a Probability is needed
18:35:32 <glasser> Ooh, I hadn't even thought of that benefit
18:35:43 <glasser> I think writing my own Show instance can be an exercise for the reader :)
18:35:52 <glasser> (showsPrec is the game to play?)
18:36:04 <Cale> you can just write show in fact
18:37:19 <glasser> I can indeed
18:38:20 <Cale> I'd forgotten that read needs readsPrec, since you need to be able to handle alternate parses and get the rest of the string back for the next bit of reading
18:38:58 <Cale> I wonder if the next version of Haskell will integrate something like ReadP or Parsec for that :)
18:39:03 <glasser> Ah, so that's what it does
18:39:23 <Cale> yeah, and Prec stands for Precedence
18:39:37 <Julian> Hi folks
18:39:44 <Cale> hi
18:40:11 <glasser> Now, am I going to screw myself over by having an Eq == that is not transitive?
18:40:25 <Cale> possibly a little
18:41:21 <Cale> things like groupBy become implementation dependent, as I found out today :)
18:42:01 <Cale> I expected that groupBy would compare adjacent elements to determine where to split, but in fact, it only compares the first element in a group with various things
18:42:23 <araujo> Hola Julian
18:42:46 <Cale> so groupBy (<) doesn't produce a list of increasing fragments of a list
18:46:50 <ndm> glasser, worse than that
18:47:15 <ndm> if you use data.map with a Ord that isn't transitive then it can loop forever
18:47:39 <Cale> ndm: it's just Eq
18:48:03 <ndm> Cale, but the point is that Data.Map may use the ==, and the same things could hapeen
18:48:05 <araujo> @index split
18:48:07 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts,
18:48:07 <lambdabot> Language.Haskell.TH.Ppr, System.Random
18:48:45 <Julian> @type split
18:48:46 <lambdabot> Not in scope: `split'
18:48:54 <dons> hmm, what's the opposite of serialising something ?
18:49:18 <stefanw> deserialising?
18:49:32 <dons> :( yeah, that's currently the function name I have. but it's ugly
18:49:33 <ski> split :: Comonad w => w a -> w (w a)    -- class method
18:50:15 <dons> maybe i could use reify and, umm, what's the opposite of reifiying something?
18:50:21 <ski> reflect
18:50:28 <dons> ah, right.
18:50:34 * ski thinks that's a bad idea, though
18:50:37 <dons> hehe.
18:50:46 <ski> hm ..
18:50:54 <ski> 'deify' and 'deflect' ?
18:50:56 <dons> so I have two functoins: t -> FastString, FastString -> Maybe t
18:51:01 <Cale> heh
18:51:26 <stefanw> toFPS, fromFPS?
18:51:26 <dons> this whole `serialise' terminology is bad, imo
18:52:16 <dons>  or showPS, readPS
18:52:53 <dons>  pack unpack
18:53:31 <dons> ah, Binary uses: get/put
18:53:32 <ski> print parse
18:55:27 <dons> I think i'll just write a short Binary class.
18:56:26 <dons> class Persistetent a where get  .. put ..
18:58:54 <Cale> Persistent
18:59:52 <dons> um, yes :) double typing/ wireless lag :P
19:03:53 <glasser> ndm: Hmm. I don't think I'm ever using the Probabilities as *keys* in a map
19:04:14 <Cale> hm, it was always "persistent", that word appearing in the 1880's, but "persistence" is apparently older, and was spelled "persistance" (with the 'a') in around the 1600's, coming to English from French. It was later changed to be spelled with the 'e' after the Latin "persistentem"
19:04:25 <glasser> I guess I could kill the instance Eq on it and just define my own approximatelyEqual
19:05:02 <Cale> whether you do or not, it's probably a good idea to have it be a newtype :)
19:05:07 <sethk> but persistetent isn't there anywhere  :)
19:05:14 <Cale> right :)
19:05:17 <glasser> No, wait, that would get me back to my first problem, which is that Data.Map doesn't have an equalsBy :0
19:05:20 <glasser> er, :)
19:05:36 <Cale> ah
19:06:08 <Cale> oh, well, there are some other things you could do
19:06:54 <Cale> it doesn't have an equalsBy, but it does have fold
19:07:12 <Cale> and unionWith (-)
19:08:25 <Cale> or unionWith (\x y -> abs (x - y)) even
19:08:29 <glasser> ooh, I do see that.  I think I like this way though
19:08:55 <glasser> and then do a fold with something like \a b -> b && a < epsilon
19:08:56 <glasser> ?
19:09:11 <Cale> you could
19:09:24 <Cale> or even add up all the differences, and bound that
19:09:37 <Cale> depending on what you want to test
19:11:17 <Cale> or map (< epsilon) over that distance Map, and then write "and" for Maps.
19:11:32 <Cale> foldr (&&) True
19:12:30 <Cale> heh, or elems it, and use list functions
19:12:44 <glasser> TMTOWTDI
19:14:21 <glasser> well, at least I have hunit tests to make sure that the Probability == does what I expect
19:14:39 <glasser> or wait, no I don't, I forgot to add it to my allTests = tests [ ... ]. that's a pain
19:27:47 <sethk> indentation question.  is this legal?
19:27:52 <sethk> foo
19:27:55 <sethk>      String x
19:28:01 <sethk>      String y = abc
19:28:13 <sethk> does the rest of the function have to line up under abc, or =, or String?
19:28:31 <Pseudonym> That's legal.
19:28:52 <Pseudonym> Everything which is part of "foo" must be at least one space indented to the right of the word "foo".
19:29:35 <Pseudonym> The rest of the function, similarly, must be at least one space indented to the right of "=".
19:29:41 <Pseudonym> I believe that's the rule.
19:29:59 <sethk> ok.  If I wanted I could put = under String
19:30:02 <sethk> ?
19:30:03 <Pseudonym> Yes.
19:30:09 <Pseudonym> I often indent functions like this:
19:30:11 <Pseudonym> foo a b c
19:30:19 <Pseudonym>   = bar baz
19:30:26 <sethk> ok.
19:30:41 <sethk> I just realized I put the type before the arguments.  I was doing c++ a few minutes ago.  :0
19:30:43 <sethk> :)
19:30:54 <Pseudonym> LOL
19:31:12 <Pseudonym> Don't C++ and Haskell.
19:31:20 <Pseudonym> Friends don't let friends do that.
19:31:29 <sethk> Pseudonym, got to pay the rent.
19:31:38 <Pseudonym> Ah, that's important.
19:31:45 <Pseudonym> :-)
19:31:54 * Pseudonym doesn't have a problem with C++ per se
19:32:20 <sethk> Pseudonym, I don't either, except using return as a function name was a very bad thing
19:32:20 <Pseudonym> I think it'd be nice to have a more modern C++ replacement, but a lot of people don't realise what that means.
19:32:57 <sethk> Pseudonym, M$ claims they did that with C#  :)
19:33:03 <Pseudonym> Yeah, right.
19:33:04 <Pseudonym> :-)
19:33:08 <sethk> that would be trolling, if I hadn't put the :)
19:33:21 <Pseudonym> Trolling by proxy, perhaps.
19:33:33 <Pseudonym> I envisage a language which is like C++ with the following modifications:
19:33:46 <Pseudonym> 1. Modern syntax.
19:33:55 <Pseudonym> 2. Removal of the grosser C-isms.
19:34:20 <Pseudonym> 3. Removal of most cases of implicit conversions.
19:34:43 <dons> hey Pseudonym, welcome back :)
19:35:09 <Pseudonym> 4. Support for Haskell-esque parametric polymorphisms and type classes (i.e. run-time template instantiation and compiler-checked concepts).
19:35:17 <Pseudonym> G'day dons.
19:35:17 <sethk> Pseudonym, how about 4.  removal of most cases of creation of temporaries invisibly
19:35:24 <Pseudonym> That'd be good, too.
19:35:34 <sethk> Pseudonym, sane handling of const   :)
19:35:37 <Pseudonym> LOL
19:35:48 <Pseudonym> Well, the C++ handling of const is actually fairly useful.
19:36:02 <Pseudonym> However, const is _semantic_.
19:36:16 <Pseudonym> What would be even better is if the user could define their own semantic tags which are compiler-checked.
19:36:41 <sethk> Pseudonym, the syntax for const, with pointers, is seriously confusing
19:36:45 <Pseudonym> I agree.
19:36:50 <Pseudonym> But I consider that an ugly C-ism.
19:36:57 <Pseudonym> Rather than a problem with const itself.
19:37:14 <sethk> yes, I don't object to the concept.
19:38:46 <Pseudonym> http://www.csse.monash.edu.au/~damian/papers/HTML/ModestProposal.html
19:38:48 <Pseudonym> Ever seen that?
19:38:56 <sethk> Pseudonym, don't think so, let me look.
19:39:20 <sethk> Pseudonym, no, I'll read it.
19:42:21 <glguy> I understand the const meanings for pointers, so that doesn't really bother me, but I think that people that use Haskell shouldn't complain about how easy or hard it is to understand another language :-p
19:42:55 <glguy> don't get me wrong, Haskell is great, but complaining about the meaning of const on a pointer seems silly when you deal with Monads and whatnot
19:43:14 <sethk> glguy, I know you aren't serious, but that's ridiculous.  X is hard so it is ok that Y is done poorly?
19:43:27 <Pseudonym> I think that most people, if they think about it, generally agree that how easy or not it is to use a programming language depends on what you already know.
19:43:30 <glguy> sethk, i don't think that the way that the pointers are is that bad
19:43:32 <glguy> that's all
19:43:50 <Pseudonym> I found learning Haskell trivial because I already knew several languages that Haskell was based upon. :-)
19:44:04 <glguy> and C# doesn't have pointers (outside of unsafe blocks) so its not a big deal there any more
19:44:18 <sethk> glguy, nobody forces you to use pointers in C++, for that matter
19:44:38 <glguy> sethk, true, but not to the same extent
19:44:50 <glguy> you are much more limited in what you can do in C++ if you never touch pointers
19:44:56 <sethk> glguy, hm?  With references, you don't need pointers
19:44:58 <glguy> but in C#, you could live your whole life
19:45:08 <Pseudonym> You can't assign to references.
19:45:11 <Pseudonym> In C++.
19:45:17 <sethk> Pseudonym, not trye
19:45:19 <glguy> without pointers
19:45:21 <sethk> not true
19:45:32 <Pseudonym> Foo& foo = p_foo;
19:45:35 <Pseudonym> foo = q_foo;.
19:45:35 <glguy> sethk, sure, you can get by without them, but you are intentionally making your life more difficult
19:45:42 <Pseudonym> You can't do that.
19:45:44 <glguy> when it comes to c++
19:45:57 <sethk> Pseudonym, I do that frequently, actually.
19:46:02 <sethk> Pseudonym, well
19:46:03 <glguy> references can only be assigned at creation
19:46:07 <sethk> Pseudonym, you mean you can't reassign
19:46:08 <Pseudonym> That does object assignment, not reference assignment.
19:46:09 <Pseudonym> Right.
19:46:14 <Pseudonym> That's what I mean.
19:46:26 <Pseudonym> So references aren't a substitute for pointers there.
19:46:59 <sethk> Pseudonym, no, that's true.  There is always a way to not use pointers, if you happen to be so inclined.  I'm not saying it is a good idea.
19:47:08 <sethk> just that it is possible
19:47:31 <Pseudonym> You're right on that score.  boost::optional<Foo&> being one example.
19:48:08 <glguy> I agreed that you don't *have* to use them
19:48:14 <Pseudonym> The problem with pointers, IMO, is pointer arithmetic.  You so rarely need to work with memory that way that there should be a bigger barrier to doing that.
19:48:18 <sethk> glguy, that's all I was saying
19:48:22 <glguy> okay
19:48:30 <Pseudonym> It makes sense, for example, if you're implementing std::vector.
19:48:44 <Pseudonym> But not if you're using it.
19:48:46 <glguy> working with pointers shouldn't be thought of as working with memory
19:48:50 <glguy> but as working with iterators
19:49:06 <Pseudonym> So what you really want is std::memory_block with appropriate iterators.
19:49:08 <glguy> like if you are using a std::vector
19:51:04 <glasser> Any way (in ghc) to get an exception (like head: empty list) to print something vaguely resembling a stack trace?
19:52:08 <Pseudonym> No.
19:52:22 <Pseudonym> And it's not obvious how to do it, either.
19:52:33 <dons> well, yes, by turning on profiling
19:52:36 <glasser> or even what line the "head" occured on?
19:52:42 <glasser> ooh interesting
19:52:43 <glasser> how's that?
19:52:53 <Pseudonym> Haskell doesn't have a "call stack" in the same sense as strict languages.
19:53:09 <glasser> Yeah, that makes sense
19:53:35 <Pseudonym> Right, because a function call is only evaluated when the result is needed.
19:53:59 <Pseudonym> Which means that there isn't a "call site" in the traditional sense.
19:54:24 <dons> $ cat M.hs
19:54:24 <dons> main = f ; f = g ; g = head []
19:54:24 <dons> $ ghc -prof -auto-all M.hs
19:54:25 <dons> $ ./a.out +RTS -p
19:54:26 <dons> a.out: Prelude.head: empty list
19:54:30 <dons> then look at a.out.prof
19:54:41 <Pseudonym> Hmmm.
19:54:58 <dons> whilch has a call graph, with 'g' at the top
19:56:38 <glasser> Hmm, doing that (with your example) makes an empty a.out.prof
19:56:48 <Pseudonym> Does GHC need to be compiled in a funny way?
19:56:49 <dons> did you recompile with -prof -auto-all ?
19:57:04 <glasser> I did it just with your example commands, yeah
19:57:08 <glasser> (on your M.hs)
19:57:11 <Pseudonym> I tried this as an example:
19:57:12 <Pseudonym> f = [g]
19:57:12 <Pseudonym> g :: Int
19:57:12 <Pseudonym> g = head []
19:57:12 <Pseudonym> main = putStrLn (show (head f))
19:57:14 <dons> don't think so P, just needs way=p libs
19:57:26 <Pseudonym> Empty a.out.prof
19:57:35 <Pseudonym> Hmmm.
19:57:38 <dons> ah, maybe it's inlined
19:57:38 <Pseudonym> I might not have those libs.
19:57:43 <dons> -Onot might be a good idea
19:58:04 <dons> also, you can use {-# SCC "x" #-} pragmas to force certain spots to be profiled
19:58:08 <Pseudonym> Doesn't help.
19:58:15 <Pseudonym> Yes, SCC will help.
19:58:16 <dons> SCC pragmas don't help?
19:58:22 <glasser> What is SCC?
19:58:23 <Pseudonym> No, -Onot doesn't help.
19:58:51 <dons> have a look at the Core output with -ddump-simpl to see if its all optimised away
19:59:39 <dons> glasser, an annotation to a line that says " give me the profiling cost of this code"
19:59:53 <dons> it means that line gets an entry in the table in the prof file.
20:00:07 <dons> so add {-# SCC "myid" #-} in front of any 'head' calls you have
20:00:57 <glasser> literally before the "head" symbol? ok.
20:01:42 <dons> with Pseudonym's example, we get:
20:01:43 <dons> f = [g]
20:01:44 <dons> g :: Int
20:01:44 <dons> g = {-# SCC "head on line 3" #-} head []
20:01:46 <dons> main = putStrLn (show ({-# SCC "head on line 4" #-} head f))
20:01:52 <glasser> No luck.  Well, maybe it will work better with my actual code
20:02:05 <dons> and "head on line 3" is on top of the call graph
20:03:21 <dons> maybe this trick should get an entry on the wiki
20:03:29 <glasser> nope, still an empty file. maybe I don't have the profiler installed or something?
20:03:47 <dons> glasser, is the code short?
20:03:57 <dons> can you paste it
20:04:01 <dons> @paste
20:04:02 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:04:05 <dons> here ^
20:04:19 <glasser> Not particularly.  A few hundred lines. And I bet I could find the bug if I tried (I am in fact doing sketchy things with assuming some lists are non-empty)
20:04:43 <dons> well, you can always insert 'assert (ls /= []) $ head ls
20:04:51 <dons> @type assert
20:04:52 <lambdabot> Not in scope: `assert'
20:04:57 <dons> @type GHC.Base.assert
20:04:58 <lambdabot> forall a. Bool -> a -> a
20:05:10 <dons> then you'll get a line number for the failuer
20:05:13 <glasser> aha, and that works due to laziness. neat.
20:05:20 <glasser> still wonder why the profiler doesn't work
20:05:43 <Pseudonym> Lunch.  BBS
20:05:43 <dons> you're doing something wrong, or you don't have profiled libraries installed
20:05:49 <ptkv> What version of GHC are you using and did you run the program with the flags he provided?
20:06:10 <glasser> I am running GHC 6.4.1 for OSX (installed just a few days ago). I ran the exact line he said
20:06:16 <ptkv> Ah.
20:06:17 <glasser> (it is at least making an empty a.out.prof)
20:06:45 <dons> it will always make an empty file if you turn on +RTS -p
20:06:50 <dons> even if profiling doesn't work
20:07:03 <ptkv> It'll make an empty file even without them.
20:07:19 <glasser> +RTS? I didn't do anything like that
20:07:25 <ptkv> Only with -p will it provide a file with content.
20:07:26 <dons> oh. there you go :)
20:07:33 <dons> ./a.out +RTS -p
20:07:41 <dons> if you want anything to be printed into a.out.prof
20:07:53 <glasser> ack, sorry, I missed the flags to a.out itself
20:09:24 <glasser> got a file now, though I'm not sure how I'd see that "head on line 3" has the exception and not "head on line 4"
20:09:53 <dons> which one comes first? check how the function calls are numbered
20:10:19 <dons> the format of this file is documented in the profiling chapter of the ghc user's guide
20:11:28 <glasser> Well, let's see how it does on my real code.
20:11:37 <glasser> Thanks, dons et al
20:15:49 <Julian> Easy star all stars, Dub side of the moon
20:16:01 <Julian> 10/10
20:16:37 <glasser> Of course after all that I am only using head in two places :)
20:17:40 <dons> oh! then I recommend a binary search to narrow down the fault ;)
20:17:59 <glasser> and one of them is in a module that's unrelated
20:23:50 <Cale> Julian: :) that's a funny album
20:26:17 <Pseudonym> Back.
20:27:06 <sethk> Cale, I've rewritten some things to work with StateT.  I'm going to have, though, per thread state.  First question, is that a situation for using ST instead of StateT?
20:27:18 <sethk> or anyone else who feels like answering, of course.  :)
20:28:23 <Cale> ST is when you want multiple state variables and no IO
20:28:49 <sethk> Cale, it has stToIO
20:29:04 <sethk> Cale, which looks similar to liftIO to me
20:29:13 <Cale> it goes the other way
20:29:28 <sethk> Cale, let me look ...
20:29:31 <Cale> there's unsafeIOtoST or something like that, but that's just as unsafe as unsafePerformIO
20:30:39 <sethk> Cale, no, I don't want unsafe, definitely
20:30:47 <sethk> Cale, ok, so ST is out then.
20:31:10 <sethk> Cale, I actually have both global state and per thread state, so I'll have to handle that.
20:31:23 <Cale> ST is for when there's some pure computation that you want to do which you think would be better expressed with an imperative algorithm
20:31:47 <Cale> You should look at STM, which is completely different from ST :)
20:31:55 <sethk> Cale, ok ...
20:32:46 <sethk> Cale, that looks like synchronization and state to state data flow
20:32:58 <Cale> yeah
20:33:08 <sethk> Cale, ok, I had found that.
20:33:20 <sethk> Cale, I need it but for a different purpose, obviously
20:33:21 <Cale> that's what it's primarily for -- the paper on it is quite good
20:33:32 <sethk> Cale, ok, I'll read that also.
20:34:01 <sethk> hmm, not url for the paper in the library doc.
20:34:05 <sethk> @where stm
20:34:06 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/stm/
20:35:00 <glguy> I'm reading the paper on that site called "Tackling the Awkward Squad"
20:35:02 <glguy> it's pretty good
20:35:21 <Cale> all of simonpj's papers are pretty good :)
20:42:54 <glasser> dons, Cale: everything working now, thanks!
20:43:01 <Cale> glasser: great :)
20:43:17 <glasser> (tomorrow's goal will be to do the approximate inference algorithms... that is, figure out how to do random numbers in Haskell)
20:45:53 <dons>  System.Random?
20:46:13 <glasser> presumably
20:46:28 <glasser> the question is, how much of my program will it make me rewrite into a monad?
20:46:41 <glasser> but that is for me to try to find out and bug you instead tomorrow, not tonight :)
22:00:37 <sethk> Cale, I'm ending up with gobs of liftIO lines.  Have to look at my design again ... :)
22:01:13 <sethk> Cale, hm, I think I can kill most of them by using Trace
22:01:41 <Cale> Trace is for debugging :)
22:02:04 <sethk> Cale, yes, I know; most of these are "here I am, I'm doing this at the moment" things
22:02:11 <sethk> Cale, most of the program is still a shell
22:02:32 <Cale> if you want to be able to print things, just write a print for your monad using liftIO, then you don't have to liftIO it every time :)
22:03:20 <sethk> Cale, I guess I can do the same thing for putStrLn and such
22:04:31 <xerox> 'morning!
22:09:51 <sethk> how do you inline a function?
22:11:45 <dons> {-# INLINE "foo" #-} ?
22:25:58 <dons> @index map
22:26:03 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List,
22:26:05 <lambdabot> Prelude
22:27:59 <dons> @eval 1  +2
22:28:00 <lambdabot> 3
22:28:22 <dons> TheHunter, using packed strings for the @index state halved memory usage
22:28:25 <dons> @seen TheHunter
22:28:26 <lambdabot> TheHunter is in #haskell-overflow, #haskell-blah and #haskell.
22:28:26 <lambdabot> I don't know when TheHunter last spoke.
22:28:39 * xerox doesn't know either
22:31:05 <dons> @index foo
22:31:05 <lambdabot> bzzt
22:31:42 <Korollary> what the monad is #haskell-overflow ?
22:32:28 <dons> sometimes conversation concurrency in #haskell is too high, so we migrate threads over to  #haskell-overflow
22:32:31 <dons> :S
22:32:43 <Korollary> I thought that's what haskell-blah was for
22:32:46 <Korollary> ohg
22:32:50 <Korollary> it's on-topic
22:32:55 <dons> right
22:33:32 <Korollary> could have called it "haskell-extra lane"
22:33:47 <dons> maybe #haskell-2
22:34:10 <xerox> Except that the conversation going on there usually overflows my mind too ;)
22:34:27 <Korollary> haskell-extra strong ?
22:34:35 <xerox> Tabagist?
22:35:36 <wolverian> the conversation _here_ overflows my mind too...
22:35:42 <xerox> I think that 'over the flow' captures the idea quite well ;)
22:39:55 <gzl> wow, this channel gets that overflowed?
22:40:15 <xerox> It gets multi-flowed :D
22:40:39 <Korollary> and it doesn't even take much
22:41:00 <xerox> Right.
22:41:28 <Cale> #haskell-overflow is like a lecture channel a lot of the time
22:41:59 <gzl> huh.
22:42:01 * gzl goes
22:42:17 <gzl> who has ops in here, by the way?
22:42:25 <Cale> in #haskell?
22:42:29 <gzl> yeah.
22:42:39 <ibid> what does it matter?
22:42:53 <gzl> it doesn't. i'm just curious. does that matter?
22:42:56 <Cale> I'd assume that shapr does
22:43:11 <gzl> ok.
22:43:20 <Cale> but generally nobody takes ops without a really good reason
22:43:38 <gzl> yeah, I've never seen anybody with ops in here. that's why I was curious. :)
22:43:52 <Korollary> lambdabot is scary enough
22:44:14 --- mode: ChanServ set +o Pseudonym
22:44:17 <Korollary> @vixen how do you like trolls ?
22:44:18 <lambdabot> sure, i definitely don't hate
22:44:18 <Pseudonym> That better?
22:44:41 <ibid> shapr and SyntaxNinja are the chanserv contacts, at least
22:45:05 <gzl> I wasn't suggesting #haskell should have people opped or anything
22:45:33 <Pseudonym>  /msg chanserv access #haskell list
22:46:01 --- mode: ChanServ set -o Pseudonym
22:46:05 <Pseudonym> Anyway.
22:46:07 <sethk> oh, no, he's started a revolution !!!!
22:46:17 * Pseudonym has no clue what most of the op stuff does anyway
22:46:36 <sethk> hey, you get to bounce people.  what else do you need to know?   :)
22:46:48 <Pseudonym> shapr bounces by himself
22:46:54 <gzl> it's nice that it's rarely necessary here. it's like the total opposite of EFNet #math (which has rampant trolling/spamming problems)
22:47:27 <sethk> well, we could do some trolling, liven things up.
22:47:36 <sethk> for example, I thing cobol is a really great language.  :)
22:47:48 * gzl ADDS 1 TO SETHK.
22:47:49 <Korollary> that's not trolling
22:47:55 <ibid> kicking and banning are the usual things ops do
22:47:58 <sethk> Korollary, well, ok, I'll have to try harder
22:48:18 <Korollary> sethk: so, how do you do quicksort in haskell, and why is it better, hmm ?
22:48:41 <sethk> Korollary, well, it runs o(n) ** -23
22:49:15 <Korollary> sethk: is that in Fahrenheit ?
22:49:18 <xerox> qs [] = []; qs (x:xs) = lt ++ [x] ++ gt where lt = [y | y <- xs, y < x]; gt = [y | y <- xs, y >= x]
22:49:37 <sethk> Korollary, either that or light years, I can't quite remember
22:49:39 * Pseudonym tries out his Metropolis implementation
22:49:50 <xerox> err, qs gt ++ [x] ++ qs gt
22:49:53 <Pseudonym> Hmmm, doesn't seem to do what I want.
22:50:29 <sethk> what's metropolis?
22:50:46 <Pseudonym> Metropolis is (was) a person.
22:50:59 <Pseudonym> He worked on monte carlo methods in the 40s and 50s.
22:51:20 <Pseudonym> Mostly for neutron transport, but I'm trying to solve transposition ciphers.
22:57:44 <Pseudonym> D'oh!
22:57:57 * Pseudonym flips a sign
22:58:01 <Pseudonym> NOW it works.
22:58:57 * xerox high-fives Pseudonym
23:00:25 <Pseudonym> At least, it's turning ciphertext into something that has the statistical properties of English.
23:00:33 <Julian> bye guys
23:00:34 <Pseudonym> It doesn't actually resemble English that much.
23:04:43 <sethk> is there any way to access the pieces of a type, defined with    data X ...        by position?
23:04:48 <sethk> what I want to do is this
23:04:57 <sethk> I have a fairly complex type I'm defining
23:05:07 <Pseudonym> @google "scrap your boilerplate"
23:05:10 <sethk> and it is going to change over the next few weeks.
23:05:23 <sethk> Pseudonym, I have those papers, although I haven't finished reading them.
23:05:23 <Pseudonym> I'd be thinking about using a record.
23:05:31 <sethk> Pseudonym, I am, I think.
23:05:42 <sethk> Pseudonym, but I'm not taking advantage of it, am I?
23:05:45 <Pseudonym> In which case you don't need positions.  Use names.
23:05:49 <sethk> Pseudonym, good point.  :)
23:06:02 <lambdabot> http://www.cs.vu.nl/boilerplate/
23:06:19 <Pseudonym> lambdabot took his time
23:06:25 <Pseudonym> (her?)
23:06:36 <Pseudonym> (I don't think I ever gave lambdabot a gender.)
23:08:16 <sethk> what's the best URL for ghc extensions to haskell?
23:09:10 <sethk> wait, records are haskell 98, aren't they?
23:09:26 <Pseudonym> Yes they are.
23:10:59 <sethk> what's the syntax, for a record Foo with a member bar?
23:11:34 <sethk> just the name?
23:11:35 <xerox> data Foo = Foo { bar :: .. }
23:11:46 <sethk> xerox, no, I've defined it, I mean to access it
23:11:56 <xerox> bar (foo :: Foo)
23:13:17 <sethk> xerox, now you confused me, I'm looking for bar and you are showing me foo  :)
23:13:50 <xerox> bar value, where value is of the Foo type, gives you the field's value
23:14:34 <sethk> xerox, I'm using get (in the State monad) and the state is this type.  I want to use    (something) <- get
23:14:48 <sethk> so I say     xyz <- get
23:14:53 <sethk> then     bar (xyz)   ?
23:14:53 <xerox> data Foo = Foo { bar :: Int }
23:14:53 <xerox> bar :: Foo a -> Int
23:16:08 <xerox> Do you see it?
23:16:42 <sethk> I think so, but I'm trying to use it within a do with <-, which complicates things
23:17:06 <sethk> also, what's the reverse?
23:17:17 <xerox> Foo { bar = newBinding }
23:17:29 <sethk> ok, let me try,
23:17:31 <sethk> xerox, thanks
23:18:01 <sethk> xerox, I'm not sure that's what I want
23:18:02 <xerox> To work with _pure_ values in the monadic context take in consideration 'let'.
23:18:18 <JohnMeacham> dcoutts: they did a lot of sensible things actually. which is not that difficult compared to x86 :)
23:18:24 <sethk> xerox, here is my pattern
23:18:35 <sethk> xerox, I do    state <- get
23:18:55 <sethk> xerox, then I extract one "piece" of state, which we are calling bar
23:19:02 <sethk> xerox, then I want to do a put
23:19:15 <sethk> xerox, and my put is x, but with the bar value updated
23:19:35 <xerox> Let's say bar :: Foo a -> Int
23:19:36 <xerox> do s <- get
23:19:36 <xerox>    let v = bar s
23:19:36 <xerox>    put (s { bar = v + 2 })
23:19:55 <sethk> xerox, ok, thanks, I will try that now, make sure I understand it
23:20:01 <xerox> Gotta run to school now!
23:20:04 <xerox> See you later :-)
23:21:02 <sethk> I always forget this.  Using let, within do, I don't need the "in" keyword?
23:23:01 <xerox> Correct, it does introduce new bindings like you do in GHCi.
23:23:06 <xerox> Now ruuuun :-)
23:52:02 <sethk> Pseudonym, anything in the generics you were talking about earlier that generates get/set functions for record elements?
