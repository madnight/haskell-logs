00:20:32 <araujo> @hoogle dupTo
00:30:03 <astrolabe_> Maybe the spammers were checking the responsiveness of the haskell wiki.
00:30:43 * araujo wonders why firefox can't increase the font size of haskell.org
00:33:39 <araujo> @hoogle fromJust
00:33:41 <lambdabot> Maybe.fromJust :: Maybe a -> a
00:35:33 <astrolabe_> I think there is a special html tag that can be used to stop google following links.  Maybe it would deter spammers.
00:39:28 <int-e> araujo: hmm? the title is an image, for the rest, changing the text size works here.
00:43:30 <araujo> int-e, mm.. i am using Ctrl+ , and it doesn't work
00:44:11 <araujo> It only changes the size of the headers
00:44:31 * int-e shrugs helplessly.
00:45:13 <araujo> it is very difficult to read really....
00:45:48 <astrolabe_> Ctrl+ works for me
00:45:54 <int-e> yes, strange. use links ;)
00:46:37 <astrolabe_> araujo: Could you change the resolution of your display temporarily?
00:47:21 <araujo> mm.. yes i could, but it'd be very annoying too, i am doing other things
00:47:55 <astrolabe_> What OS are you running?
00:48:27 <araujo> Gentoo
00:49:42 <Cale> araujo: perhaps the dpi information for X is set incorrectly?
00:49:48 <araujo> I don't remenber having this problem
00:49:49 <Cale> are fonts small in all programs?
00:50:01 <araujo> Cale, no, they are ok
00:50:21 <int-e> Cale: that should only affect the default size, not the zoom (I'm running gentoo, too, btw ... although that hardly means anything)
00:50:43 <Cale> int-e: well, it'll affect the sizes of all fonts
00:51:09 <araujo> Well, i was wondering if somebody else had the same problem but apparently i am the only one
00:51:20 <Cale> (the meaning of "8pt" in pixels is determined using the number of pixels per inch)
00:51:29 <araujo> The weird hting is that it only happens with this site
00:51:57 <Cale> I don't have any problem with the font size on haskell.org. It's 10pt or so.
00:52:00 <araujo> I can decrese/increase the size on other site good
00:52:43 <Cale> oh and Ctrl-+/Ctrl-- work fine here
01:38:41 <xerox> Happy happy, joy joy.
01:40:37 <Maddas> @hoogle State
01:43:13 <Maddas> @hoogle runstate
01:43:54 <xerox> @botsnack
01:43:55 <lambdabot> :)
01:44:06 <xerox> @type Control.Monad.State.runState
01:44:11 <lambdabot> forall s a. Control.Monad.State.State s a -> s -> (a, s)
01:44:31 <xerox> @docs Control.Monad.State
01:44:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.State.html
01:44:44 <xerox> @where hoogle
01:44:45 <lambdabot> I know nothing about hoogle.
01:44:50 <xerox> Bad.
01:45:11 <xerox> @where+ hoogle http://www-users.cs.york.ac.uk/~ndm/hoogle/
01:45:13 <lambdabot> hoogle ~> http://www-users.cs.york.ac.uk/~ndm/hoogle/
01:47:37 <Maddas> is Control.Monad.State there by default?
01:47:41 * Maddas is confused :-)
01:47:52 <xerox> Where?
01:48:33 <xerox> The Control.Monad.State module is part of the standard Monad Template Library.
01:49:32 <Maddas> Am I supposed to do 'import Control.Monad.State'?
01:49:41 <Maddas> Sorry if that's a horribly basic question
01:50:21 <xerox> Yes, if you want to use its functions.
01:50:38 <Maddas> Right. So it's not supposed to ship with GHC/Hugs?
01:50:58 <xerox> It is shipped with GHC and Hugs
01:51:35 <xerox> Try (in GHCi) :module +Control.Monad.State
01:51:43 <Maddas> Hmm. Shouldn't calling hugs as "hugs Control.Monad.State" work, then? I get an error ("Unable to open file ...")
01:51:59 <Maddas> Hm, okay, that works :-)
01:52:14 <xerox> I don't know much about hugs, sorry.
01:52:22 <Maddas> No worries, ghci will do.
01:52:48 <Maddas> My GHC dies when trying to compile this (tiny) program, the error is /usr/bin/ld: Undefined symbols:
01:52:51 <Maddas> ___stginit_ControlziMonadziState_
01:53:07 <Maddas> I thought that was because I didn't have Control.Monad.State, I guess it's something else, then.
01:53:11 <xerox> Add -mtl to the command line options
01:53:17 <Maddas> Thanks :-)
01:53:25 <xerox> You're welcome!
01:53:51 <xerox> Hmm.
01:54:03 <Maddas> nope...
01:54:08 <csgeek> xerox do u work at xerox?
01:54:10 <xerox> It was something similar :-)
01:54:16 <xerox> csgeek: nope :-)
01:54:28 <likens> -package mtl ?
01:54:46 <Maddas> thanks :-)
01:54:53 <xerox> Right!
01:54:56 <Maddas> I better make an alias, I'll just forget it next time otherwise
01:55:14 <likens> Now I use --make
01:55:29 <xerox> My brain need to properly boot, I just woke up :-)
01:55:36 <Maddas> :-)
01:55:50 <xerox> Right, ghc --make is what everybody envies to Haskell.
01:57:21 <xerox> "--make Build a multi-module Haskell program, automatically figuring out dependencies. Likely to be much easier, and faster, than using make."
01:57:26 <wilx> I think that Ada folks have something like that too.
01:57:29 <Maddas> heh, okay, thanks!
02:00:10 <xerox> Maddas: what are you writing, if I could ask?  :-)
02:10:27 <Maddas> xerox: Trying to write a PGN (Portable Game Notation) parser for chess games
02:10:30 <Maddas> As my first Haskell program :-)
02:10:59 <rep> :)
02:11:48 <skew> what are you using State for?
02:12:15 <Maddas> I thought I'd hide the state of the board
02:12:34 <Maddas> so e.g. move (1, 2) (2, 3) inside the monad will do that move and update the board
02:12:57 <Maddas> I've got no idea of how to cleverly represent the data structures, of course, this being my first non-tutorial program :-)
02:14:08 <xerox> So it's not just a parser?
02:14:21 <Maddas> Well, you _must_ simulate the game in order to parse it
02:14:26 <skew> what's the program supposed to do?
02:14:34 <xerox> Cool :-)
02:14:41 <skew> display the final state of the game?
02:14:57 <Maddas> Display the entire game as a nicely clickable thing, ideally
02:15:04 <Maddas> I'll be happy if I can just parse it properly for now :-)
02:15:32 <xerox> So you can't just parse a string to a list of moves?
02:15:36 <Maddas> (Well, for *today*, I'll be happy if I just learn a lot and manage to get anything at all working)
02:15:51 <Maddas> xerox: Depends on what you consider a list of moves :-)
02:16:05 <xerox> Also, that way you could not do error checking, probably.
02:16:09 <Maddas> Right
02:16:15 <xerox> Have fun :-)
02:16:30 <Maddas> I'll try :-)
02:16:56 <skew> if you want to use State, you should look at using WriterT too
02:17:08 <Maddas> You can't parse it to, say, (Int, Int) -> (Int, Int) without simulating the game
02:17:32 <Maddas> It'll only be unambiguous once you know which of all the possibilities is not allowed due to chess rules
02:17:58 <Maddas> E.g. there might be two possible ways to parse a move, but one is not possible because it would expose the king
02:18:08 <Maddas> skew: I'll have a look, thanks :-)
02:18:23 <csgeek> why do they say haskell is faster than c++?? ( premise i dont know anything about haskell )
02:18:46 <xerox> So you could check 'some kind' of errors.
02:19:05 <Maddas> xerox: Right. And if I want to be able to display it, I need to simulate the game anyway.
02:19:21 <Maddas> I also never wrote any parser for anything useful at all, of course, so that'll be a first time too :-P
02:19:33 <xerox> Indeed.  What do you use to model the board?
02:20:02 <Maddas> I thought of having an Array of Maybe Piece, incrementally updating it hidden behind the State monad
02:20:27 <Maddas> maybe I should use a FiniteMap, but with 64 elements it shouldn't matter much (I guess)
02:20:30 <xerox> An Array of Arrays you mean?
02:20:38 <Maddas> A two-dimensional one, yeah
02:20:51 <Maddas> (Is that not the same as an array with two-dimensional indices?)
02:21:28 <Maddas> I'm using: type Board = Array (Int, Int) (Maybe Piece)
02:21:32 <genneth> Maddas: I would think that with back tracking a purely functional structure would be better
02:21:38 <xerox> Yes, I was checking that :-)
02:22:08 <Maddas> genneth: I'm not sure what you are suggesting
02:22:38 <xerox> Using a Tree of Boards?  :-)
02:22:55 <Maddas> Heh.
02:23:18 <genneth> Maddas: you'll probably involve some backtracking, right?
02:23:29 <genneth> checking out possibilities and all that
02:23:33 <xerox> It's as cool as it sounds ;-)
02:23:55 <Maddas> genneth: Hmm, just one move deep, though, I think, but I see where you're getting at.
02:24:07 <Maddas> I wonder how quickly that would lead my head to explode :-)
02:24:14 <skew> Array is functional, anyway
02:24:26 <xerox> ...and immutable?
02:24:38 <skew> pgn looks pretty tricky to parse
02:25:02 <Maddas> Annoying, I think, but I didn't try yet
02:25:06 <genneth> xerox: as i understand okasaki, it isn't needed to represent the tree directly
02:25:12 <Maddas> (Back in a bit)
02:25:21 <xerox> genneth: who/what is okasaki?
02:25:31 <skew> xerox: immutable too - you have to make new ones
02:25:40 <genneth> xerox: chris okasaki's work on pure functional structures
02:26:21 <genneth> apparently they're very good at being persistent, so that you can keep them around for a long time, expiring as everyone release their references
02:26:45 <genneth> you also get versioning and undos for free
02:26:54 <genneth> see the ZFS thing recently
02:26:58 <xerox> Those kind of things? http://www.dcs.gla.ac.uk/jfp/bibliography/Authors/okasakichris.html
02:27:23 <xerox> You get them by using continuations, in ZFS, don't you?
02:27:31 <skew> that's confusing things a bit
02:27:49 <skew> just by having a purely functional data structure, you can keep references to the old version around as long as you like
02:27:55 <genneth> yeah
02:28:08 <xerox> Right.
02:28:11 <genneth> the continations thing i think is more for the traversal stuff
02:28:21 <skew> some of the good stuff Okasaki did was providing implementations of lots of data structures, and making them very efficient
02:28:28 <genneth> so that you can get a generic "zipper" over any structure
02:28:36 <skew> and coming up with ways of proving that they are efficient
02:29:06 <int-e> @index STArray
02:29:06 <lambdabot> Data.Array.ST
02:29:09 <xerox> I see what you mean, you do it in different continuations to 'fake threads', but what you do is creating a new zipper on the same data structure.
02:29:14 <genneth> skew: i've reading his dissertation; i hear the book is even better
02:29:54 <xerox> Oh, csgeek was an Italian fellow.
02:30:16 <skew> I think I've heard the name before - I was just about to talk at him and he goes away
02:30:22 <genneth> xerox: yeah; that's how i understand it too. the continuations are being used for some kind of co-threading, so that there is better seperation of concerns
02:30:37 <skew> it's delimited continuation stuff
02:30:37 <xerox> genneth: is Chris' thesis available online?
02:30:42 <Maddas> genneth: I did think about using a Zipper
02:30:43 <genneth> yes
02:30:44 <Maddas> xerox: yup
02:30:51 <Maddas> xerox: http://www-2.cs.cmu.edu/~rwh/theses/okasaki.pdf
02:31:06 <xerox> skew: I tried to dig deeply into them but they resisted me, for now.
02:31:10 <genneth> Maddas: i would think that a zipper is too hard... but that's just because i personally have trouble with continuations
02:31:12 <xerox> Thanks Maddas.
02:31:24 <Maddas> genneth: I'm not sure whether a) it's worth it, since I'll never have more than 64 elements and b) I'm a newbie at Haskell anyway, so even Arrays will be hard enough :P
02:31:27 <Maddas> Right
02:31:36 <Maddas> No problem, xerox.
02:32:02 <skew> Maddas: what kind of input are you starting with?
02:32:03 <genneth> Maddas: if Array is pure, so you get none-destructive updates, that would be fine
02:32:19 <Maddas> It is.
02:32:24 <genneth> Maddas: but it could cause interesting runtime complexity
02:32:29 <skew> actually parsing from a string, or writing the tricky move processing stuff first?
02:32:29 <Maddas> skew: Nothing. I'm still at modelling the board :-)
02:32:40 <Maddas> Hm, I'm not sure. What do you suggest?
02:32:43 <skew> Array (Int,Int) Bool seems like a fine choice
02:32:55 <skew> that's what you said earlier, right?
02:33:00 <Maddas> Array (Int, Int) Maybe Piece you mean?
02:33:01 <xerox> skew: to do what?
02:33:08 <Maddas> s/Maybe Piece/(Maybe Piece)/
02:33:20 <Maddas> so I'll only need one Array update per move
02:33:24 <genneth> hmm
02:33:26 <Cale> Use Diff arrays
02:33:28 <xerox> I find the Maybe Piece part very cute.
02:33:29 <Maddas> so complexity shouldn't get too bad..
02:33:33 <Maddas> Thanks :-)
02:33:39 <Maddas> Cale: I'll have a look, thanks.
02:33:52 <skew> right, I was thinking of life or something
02:33:55 <genneth> how about a type of [Move] -> Arraf (Int, Int) (Maybe Piece) ?
02:34:04 <xerox> 'Diff arrays have an immutable interface, but rely on internal updates in place to provide fast functional update operator //.'
02:34:04 <Maddas> Cale: Cool! Exactly what I was looking for earlier.
02:34:15 <genneth> as the actual representation of the board
02:34:45 <skew> the chess board is only so big - it's just a constant factor
02:34:57 <genneth> true
02:35:22 <skew> learn Haskell before you learn the tricks to make it go fast
02:35:26 <Maddas> Right :-)
02:35:26 <skew> makes more sense that way
02:35:33 <xerox> So, maybe a list is enough?
02:35:43 <Maddas> Arrays are easy enough :-)
02:36:04 <Maddas> and if I use a ST monad to hide the board, I can easily switch to Diff arrays/FiniteMap without changing too much code (I hope)
02:36:16 <skew> Array is probably easier, actually
02:36:19 <xerox> I mean, because of the fixed size.  What does it take more memory between a list and an Array?
02:36:34 <skew> Ix stuff lets you use a pair of coordinates as an index yourself
02:36:50 <genneth> Maddas: i don't think hiding behind an ST will gain you anything
02:37:11 <skew> er, Ix lets you use a pair of coordinates as an index, rather than having to write some kind of indexing function for a list yourself
02:37:15 <xerox> ...a better looking parser, at least?
02:37:29 <genneth> @hoogle Ix
02:37:30 <lambdabot> Array.ixmap :: (Ix a, Ix b) => (a, a) -> (a -> b) -> Array b c ->
02:37:30 <lambdabot> Array a c
02:37:30 <lambdabot> Prelude.floatRadix :: RealFloat a => a -> Integer
02:37:30 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
02:37:43 <skew> @info Ix
02:37:44 <lambdabot> Unknown command, try @listcommands.
02:37:52 <xerox> There is not @info anymore :(
02:37:55 <genneth> @type Ix
02:37:56 <lambdabot> bzzt
02:38:05 <genneth> it looks like a type class...
02:38:22 <xerox> instance (GHC.Arr.Ix a, GHC.Arr.Ix b) => GHC.Arr.Ix (a, b)
02:38:38 <genneth> ahhh...
02:38:56 <genneth> that's a little evil, though brilliant
02:39:05 <genneth> any by evil, i mean neat
02:39:15 <xerox> Everybody does.  <blink>
02:39:28 <genneth> :-p
02:40:10 <genneth> i think everyone thinks "i'll use the ST monad!" when they just start haskell
02:40:18 <skew> around here evil usually means "neat, but I wouldn't want to maintain it",
02:40:22 <ValarQ> how do i handle import collisions between modules?
02:40:35 <ValarQ> say i wan't the insert from both Data.Map and Data.List
02:41:13 <ndm> import qualified Data.Map as Map
02:41:22 <ndm> then you explicitly refer to Map.insert to get the map one
02:41:40 <ValarQ> thanks
02:41:58 <xerox> I wonder what's good about ST
02:42:06 <genneth> it feels like C...
02:42:31 <xerox> How is it different from State?
02:42:32 <skew> for completeness, if you just say "import Data.Map as Map", then all the things from Data.Map show up unqualified and qualified with Map
02:42:47 <Cale> It lets you write algorithms which are otherwise pure but have arbitrarily many mutable references.
02:43:02 <Cale> STRefs
02:43:02 <genneth> xerox: nothing i think; just different names
02:43:16 <skew> State just carries around one piece of state
02:43:21 <genneth> State is implemented in terms of ST?
02:43:22 <xerox> Cale: ah, you can hide a [STRef] for example.
02:43:25 <Cale> It's different in that STRefs and STArrays are available
02:43:31 <genneth> oh...
02:43:32 <Maddas> genneth: Oh, I didn't begin using the State monad, but I very quickly felt that it would just make things neater
02:43:49 <genneth> Maddas: i know the feeling... :-D
02:43:50 <skew> ST doesn't hide anything, just lets you pass around mutable references
02:43:56 <rep> the state monad is bad?
02:43:59 <Maddas> genneth: Not because I want to think of mutable data structures, but just because I'd pass around the board everywhere anyway
02:44:01 <xerox> A Stateful parser would mean clearer code to me too.
02:44:05 <xerox> rep: it is not.
02:44:10 <Cale> You should make your own monad out of a state monad, with its own operations restricted to chess moves.
02:44:15 <rep> oh ok
02:44:22 <skew> Maddas: yeah, that's the sort of thing State is for
02:44:43 <Maddas> Cale: I'll think about that some more.
02:44:44 <Cale> By newtyping a State monad
02:44:50 <Maddas> Ah, ok.
02:44:52 <Cale> and hiding the operations in a module
02:44:59 <skew> you might want ST for completely different reasons, like if working with Array is too slow
02:45:11 <xerox> Cale: what kind of operations are you think of?
02:45:20 <genneth> i think hiding in a State only make sense if you don't care how you got to the current state
02:45:29 <Cale> oh, sorry, hiding the constructor
02:45:43 <Cale> and exporting chess operations :)
02:45:58 <xerox> The strange fact about ST is that I heard of it from very short time.  So I wondered what cool, new, powerful and shiny it should have been.
02:46:32 <skew> ST is pretty neat because it doesn't let the mutable variables get out
02:46:48 <xerox> Cale: ah-ha I see what you mean.
02:46:53 <Cale> It uses some neat typing tricks to ensure that the state never escapes
02:47:22 <xerox> I did do that with the Render monad, in Cairo code, but the 'chess operations' part is rather cool :-)
02:47:42 <Cale> xerox: yeah, I was actually thinking it's similar to what you did
02:48:01 <Cale> anyway, I'm going back to sleep :)
02:48:07 <xerox> Cale: how would represent the different moves for a Knight?  knightsmove :: Direction -> .. ?
02:48:27 <skew> has anybody around here used HAppS?
02:48:41 <Maddas> xerox: Thing is, I might not need to do that anyway
02:48:54 <Maddas> Oh, wait, I do.
02:49:01 <Cale> by some encoding similar to http://en.wikipedia.org/wiki/Algebraic_chess_notation
02:49:19 <xerox> Maddas: yeah, but instead of writing functions here and there, a Chess monad sounds _so_ neat.
02:49:34 <xerox> (Tough, I'm heavily biased ;-))
02:49:34 * Maddas nods
02:50:04 <xerox> Cale: what's the meaning of life?  (You seem to have every answer, I just try)
02:50:07 * xerox hides
02:50:15 <basti_> 42!
02:50:22 <rep> hehe
02:50:25 <Maddas> Oh, hmm, actually, I now have an idea of how to model things nicely with a Chess monad :-)
02:50:27 <xerox> Again :-)
02:50:39 <Maddas> involving MonadPlus...
02:50:52 <Maddas> (I thought of that earlier, but I couldn't think of how to make use of it cleverly so that it's better than just using State :-)
02:51:07 * Maddas refactors/rewrites
02:51:08 <Cale> xerox: Depends on what you mean by 'meaning'. :)
02:51:16 * Maddas grins
02:51:17 <xerox> Go to sleep!
02:51:20 <xerox> ;-)
02:51:22 <Cale> :)
02:51:39 <Maddas> (...where '
02:51:41 <Maddas> erg
02:51:58 <xerox> Keep your /dev/random calm!
02:53:10 <Cale> The smartass answer is this link: http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=life&x=0&y=0
02:53:23 <Maddas> I also just noticed http://www.nomaware.com/monads/examples/example25.hs :-/
02:54:26 <xerox> That's the meaning of the word 'life' :-)  You didn't read enough GEB!
02:55:19 <Cale> "Is the meaning of life" is the meaning of life.
02:55:33 <xerox> Maddas: ah!
02:55:36 <int-e> "48 entries found for life." ... which are the 6 superfluous ones?
02:55:50 <xerox> Cale: OK, you did.
02:56:40 <Cale> 'night :)
02:56:52 <xerox> Goodnight :-)
02:57:27 <Maddas> Night!
03:05:17 * Cale gets up again for a sec
03:05:24 <Cale> actually, let me change that :)
03:05:56 <Cale> "Is the meaning of life, when preceded by its quotation" is the meaning of life, when preceded by its quotation.
03:06:11 * Cale goes back to sleep
03:14:48 <JohnMeacham> life is recursion on a term rewriting system? I can buy that.
03:18:57 <int-e> why does ML use postfix notation for type constructors? that's so confusing.
03:20:59 <JohnMeacham> int-e: accident of history maybe. I think the symmetry between type and data constructors wasn't as well established as it is today.
03:21:16 <JohnMeacham> but I am just speculating.
03:24:54 <JohnMeacham> I have often wondered about ML's particularly bad syntax. perhaps people just thought "at least it's better than lisp"
03:28:37 <int-e> heh. I didn't know ML predates Scheme.
03:28:53 <xerox> What does ML stand for?
03:29:54 <sagasu> Macro Language?
03:30:13 <int-e> Meta Language
03:30:46 <int-e> The original ML, implemented in Stanford LISP. ... aha.
03:32:14 <JohnMeacham> are SML and OCAML the only main (direct) ML derivatives still in use out there?
03:32:28 <int-e> (http://people.ku.edu/~nkinners/LangList/Langs/M/ML%5B2%5D.htm)
03:32:39 <int-e> also interesting: http://www.levenez.com/lang/
03:32:52 <sieni> caml light?
03:33:07 <int-e> (probably well known, but maybe there are one or two people out there who've not seen that)
03:37:20 <xerox> For some languages they count compiler/interpreter version numbers, for others reports' dates?
03:39:08 <int-e> xerox: I know, it's hardly fair. But still interesting.
03:39:49 <xerox> Haskell derives from Miranda? :-)
03:40:33 <xerox> ...which derives from ML, uhuh :)
03:45:29 <int-e> oh well. those diagonal arrows are really amusing sometimes. counting PHP 5 and PHP 4 as different languages is also funny.
03:58:18 <ndm> xerox, have you ever seen Miranda?
03:58:24 <ndm> its very similar to haskell...
04:00:03 <sieni> int-e: counting PHP (either 4 or 5) as a language is also funny
04:05:16 <int-e> sieni: I didn't want to go that far. Heh, is Basic on that chart?
04:05:34 <xerox> Yep.
04:06:09 <sieni> or tragic, depending on viewpoint
04:06:17 <int-e> ah, found it.
04:08:22 <sieni> all functional programming languages are there nicely in one group: from bottom up: SML, Haskell, Scheme, Common Lisp, Visual Basic and OCaml
04:08:48 * xerox stares at sieni
04:10:19 <int-e> hmm, I've heard Visual Basic manages to be mostly functional.
04:10:49 <mflux_> maybe because of excel?
04:11:07 <xerox> Now imagine a scream followed by a very long list of interrobangs.
04:11:09 <int-e> Heck no. Visual Basic is useful for non-programmers to prove that they can't program. And that's it.
04:11:43 <xerox> Isn't Haskell useful to Mathematicians to look like they are good at CS too?  /me cloaks rapidly
04:11:52 <int-e> (and calling lisp or scheme functional ... hmm)
04:11:56 <xerox> Howdy droundy.
04:12:04 <droundy> Hi
04:12:27 <xerox> int-e: they are, partly, at least.
04:13:11 <mflux_> atleast all expressions that 'do' something have a value in them?
04:13:12 <int-e> xerox: I want python on that list then, too. And LPC. And some other languages that have closures.
04:13:41 <xerox> They aren't pure, but having functions as first-class citizens isn't considered enough to be called functional programming?  But I see your point.
04:14:12 <ndm> int-e - VB is not functional in any way
04:14:57 <int-e> ndm: I hope you realized that 'functional' has more than one meaning :)
04:15:13 <xerox> Ouch :-)
04:15:14 <ndm> i don't think any of them apply to VB :)
04:15:25 <ValarQ> hehe
04:15:27 <int-e> ndm: anyway, I've never tried to do anything in VB so I wouldn't really know.
04:15:41 <ndm> int-e: i was a professional VB programmer for years :)
04:15:51 * ValarQ stares at ndm 
04:15:52 * int-e comforts ndm
04:16:22 <ndm> too bad they killed it...
04:16:22 * int-e hopes that's not contagious.
04:16:40 <ndm> i've been VB free for about 3 years now
04:16:50 <ndm> a strict diet of javascript, c and haskell
04:19:05 <fnord123> them charts on language histories always show java coming from C++ - but it doesnt like at all. it comes from modula3
04:19:31 <int-e> it certainly looks like C ...
04:20:38 <fnord123> yeah. wow. bbl
04:20:47 <int-e> does anyone know if Oak looked very different from Java?
04:21:00 * int-e doesn't quite get the Objective C connection.
04:21:12 * shapr bounces
04:21:40 <int-e> or scheme, or smalltalk, for that matter. hmm.
04:26:46 <shapr> haha, STM was referenced in a comment on a slashdot article about carbon nanotube memory.
04:28:14 <shapr> http://hardware.slashdot.org/comments.pl?sid=164703&cid=13746900
04:39:52 <shapr> Oleg's ZFS is extremely nifty.
04:42:23 <{Arias}> hi
04:42:29 <ValarQ> hello
04:43:16 <shapr> hiya
04:43:32 <jyp> howdy
04:46:21 <sieni> cool, the stm paper looks nice
04:47:58 <sylvan> STM is sweet
04:49:51 <skew> does anyone have good examples?
04:52:47 <shapr> hey skew, wassup?
04:54:17 <sylvan> skew, of STM?
04:55:11 <shapr> What's up with all these "xMSx" edits on TMRwiki?
04:57:33 <skew> yeah, a nice little demo, to put on some slides
04:57:57 <sylvan> hmm... yeah I think I do!
04:57:59 <sylvan> hang on
04:58:13 <int-e> shapr: Cale removed a bunch of those from the haskell wiki earlier
04:58:14 <sylvan> not anything useful but it's the "standard example" for concurrent programming...
04:58:19 <sylvan> (dining philosphers"
04:58:30 <shapr> bizarre.
04:58:50 <shapr> Looks like a distributed spam attack with bugs.
04:59:18 <shapr> I occasionally get entertaining spam that has %SUBJECT% and %BODY% instead of actual text.
04:59:34 <sylvan> @paste
04:59:35 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:00:38 <skew> dining philosophers is a nice example of how you can avoid deadlock
05:00:52 <sylvan> yep, and with STM you don't hav to do anything, STM takes care of it
05:01:14 <skew> but that's not so impressive when half of them starve
05:01:35 <integral> rather, half of them eat :)
05:01:41 <shapr> There's a philosopher welfare program involved somewhere...
05:01:49 <skew> yeah, it's the scheduler
05:02:13 <skew> actually, I've got the RTS code here
05:02:57 <sylvan> anyway, i pasted up the philospher's example on @paste
05:03:48 <sylvan> it's short and simple and shows a typical example where you in other languages need to introduce extra hacks (ahem, "techniques") to get it to work
05:04:36 <skew> wow, there are pages and pages of main scheduler loop
05:05:37 <shapr> Meaning, we don't need that in each of our concurrent programs now :-)
05:05:57 <skew> yeah, I was hoping to hack in a uniform selection over runnable threads
05:06:10 <skew> but it looks like it will take a bit more staring at the code
05:06:57 <skew> trying out epoll in the scheduler loop might be nice too
05:09:11 <skew> shapr, have you used HAppS?
05:09:53 <shapr> Not really.
05:09:56 <shapr> I've stared at the code a bit.
05:16:11 <skew> I've been sketching out some code around the stuff we do at work, and one part of that is a durable message delivery thing
05:16:47 <skew> so the ACID stuff sounds relevant, but I can't figure out what it's doing
05:17:54 <shapr> If you want journaling, what about Oleg's ZFS stuff?
05:18:00 <shapr> unicycling, bbl
05:18:02 * shapr &
05:18:49 <jyp> JohnMeacham, fyi, compiling jhc : ./DataConstructors.hs:228:52: Not in scope: `ctypeMap'
05:27:18 <swisscheese> Anyone know of a good C# channel?
05:29:25 <rep> ..
05:29:39 <skew> not me, but slightly more on topic, Cw looks like a language to check out if you use C#
05:30:34 <skew> how does google do for you?
05:31:14 <swisscheese> Google did not find much
05:31:55 <skew> there is supposedly a #C# on undernet
05:32:28 <skew> first page of yahoo results...
05:33:14 <Lemmih> swisscheese: Why did you ask that in #haskell?
05:34:48 <swisscheese> I tried Haskell for a while so I had this channel on my favorites.
05:36:05 <swisscheese> What did you seach for on yahoo? "c# irc"?
05:38:56 <Maddas> Hmmm. I'm not sure anymore about what Cale said earlier. What advantages could newtyping the State monad to customzie my own bring?
05:39:12 <Maddas> customize, even. What are the typical operations that one would specialize?
05:47:24 * joelr waves
05:47:32 * xerox waves back
05:47:50 * joelr is formerly known as wagerlabs
05:48:20 <joelr> xerox: what's the proper way to do this?
05:48:21 <joelr> type Packet a = (ByteSized a, Binary a, Typed a) => a
05:48:38 <joelr> xerox: you suggested this yesterday
05:48:48 <xerox> -fglasgow-exts
05:48:57 <joelr> oh
05:49:34 <xerox> What is 'Typed' ?
05:49:53 <joelr> class Typed a where
05:49:53 <joelr>     cmdType :: a -> CommandType
05:50:30 <joelr> Packet.hs:30:0:
05:50:30 <joelr>     All of the type variables in the constraint `ByteSized a' are already in scope
05:50:34 <joelr>         (at least one must be universally quantified here)
05:50:36 <joelr>     In the type synonym declaration for `Packet'
05:50:41 <joelr> it repeats this for all the constraints
05:55:06 <xerox> I'd suggested other things too.
05:59:32 <joelr> this seems to work
05:59:32 <joelr> type Packet = (ByteSized a, Binary a, Typed a) => a
06:00:45 <joelr> thank you xerox
06:05:57 * shapr boings cheerfully
06:05:59 <shapr> I love unicycling!
06:07:18 <xerox> Argh!  I did not order mine yet :-(
06:30:35 <shapr> hei arcatan, learning Haskell?
06:32:22 <xerox> shapr: do you know about GHC internals (threading?)
06:32:41 <shapr> I seriously doubt it, but you can ask...
06:33:00 <xerox> I'm searching for the definition of what GHC uses
06:33:19 <arcatan> shapr: trying to
06:33:35 <arcatan> I'm just wondering how to get n'th element of a list
06:33:41 <xerox> @type (!!)
06:33:43 <lambdabot> forall a. [a] -> Int -> a
06:34:38 <arcatan> oh, thank you.
06:35:07 <xerox> You're welcome.  For a list of List functions:
06:35:10 <xerox> @docs Data.List
06:35:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
06:39:08 <Guest383004>  <> www.onlinebanditbrasil.com <> <<< Jogos Multiplayer: Tetris, Gamão, Puzzle, Yatzy
06:43:55 <xerox> Sob.
06:44:08 <xerox> It is probably not implemented in Haskell, is it?
06:44:17 <basti_> i'm already on freenode
06:44:26 <basti_> #
06:44:34 <basti_> waiting to get voice
06:45:21 <basti_> too late
06:45:34 <integral> basti_: it's easier to just /msg staff for these things
06:45:51 <basti_> do i know who is staff and who is not? :D
06:46:21 <integral> err, basti_: /stats p (see the topic) will tell you which staff are open for business
06:46:25 <basti_> heh
06:46:41 <basti_> noone
06:46:48 <basti_> how great.
06:46:59 <JohnMeacham> jyp: ctypeMap is in the generated PrimitiveOperators.hs. perhaps make didn't realize it needed to rebuild that since darcs changed all the file times.
06:47:13 <Maddas> :x
06:47:28 <Maddas> (Er, wrong window)
06:47:33 <basti_> :D
06:49:56 <shapr> I'm very tired of poker spam.
06:50:39 <xerox> Maddas: it was poker spam!  Liar!
07:10:40 <xerox> Do you know anything about this? http://www.erights.org/talks/promises/paper/tgc05.pdf
07:14:43 <joelr> @index hPutBufBA
07:14:45 <lambdabot> bzzt
07:14:52 <joelr> hmm
07:15:07 <xerox> @index hPufBuf
07:15:08 <lambdabot> bzzt
07:16:32 <xerox> @type System.IO.hPutBuf
07:16:34 <lambdabot> forall a. GHC.IOBase.Handle -> GHC.Ptr.Ptr a -> Int -> IO ()
07:16:54 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html#21
07:16:54 <joelr> Could not find module `IOExts':
07:16:54 <joelr>   it is a member of package lang-1.0, which is hidden
07:16:58 <shapr> xerox: mmm, capability security?
07:17:04 <joelr> what do you do about this?
07:17:12 <xerox> rtfm?
07:17:25 <{Arias}> a good starting manual?
07:17:28 <xerox> ghc-pkg expose?
07:17:33 <{Arias}> 8-)
07:17:50 <xerox> shapr: it seems interesting, at least the language E, I don't know about the paper
07:18:03 <xerox> {Arias}: try out "Yet Another Haskell Tutorial"
07:18:05 <shapr> xerox: Capability security is the interesting part of E.
07:18:20 <xerox> shapr: indeed. I was just reading a tutorial.
07:18:28 <shapr> Capability security would get rid of ssh-agent, cvs logins, and much more.
07:18:31 <{Arias}> go! thanks :D
07:18:47 <xerox> {Arias}: you're welcome, come back with questions! ;-)
07:19:58 <{Arias}> do you know Labra?
07:20:54 <{Arias}> lambdabot has code make by Labra Gayo
07:20:55 <xerox> Nope.  What is it?
07:21:04 <xerox> Oops :-)
07:21:05 <{Arias}> is my teacher xD
07:21:42 <xerox> Yay :D
07:21:58 <{Arias}> we are makeing a semantic web project in haskell
07:22:01 <shapr> nifty!
07:22:12 <shapr> Have you seen Semantic Web code in Haskell by Graham Klyne?
07:22:30 <{Arias}> mmm no :(
07:23:02 <shapr> http://www.ninebynine.org/RDFNotes/Swish/Intro.html
07:23:16 <{Arias}> ok :D
07:24:00 <joelr> @index IOUArray
07:24:01 <lambdabot> Data.Array.IO
07:24:27 <shapr> joelr: If you change an IOExts import into GHC.IOExts, it will probably fix it.
07:24:32 <{Arias}> swish? it the name of a flash designer... no?
07:24:41 <shapr> I don't know.
07:24:45 <joelr> shapr: fix what?
07:24:56 <shapr> joelr: "could not find module IOExts"
07:24:56 * joelr is formerly known as wagerlabs
07:25:01 <shapr> Yes, I know.
07:25:06 <joelr> shapr: ok, thanks. -package lang works also
07:25:26 <shapr> Right, but hierarchical libraries are the way of the future.
07:25:31 <joelr> shapr: GHC.IOExts does not work
07:25:43 <joelr> Could not find module `GHC.IOExts':
07:25:43 <joelr>   use -v to see a list of the files searched for
07:25:46 <shapr> hmm
07:26:01 <shapr> What's the name of the function you're using from IOExts?
07:26:18 <joelr> hPutBufBA
07:26:54 <xerox> Hiya poetix
07:26:59 <poetix> Hi
07:27:00 <shapr> heya poetix!
07:27:08 <shapr> I was just about to send you an email about ZFS.
07:27:09 <poetix> Howay
07:27:13 <poetix> I saw the LtU article
07:27:18 <poetix> It's pretty mind-boggling
07:27:43 <shapr> That's the response I got from Oleg :-)
07:28:11 <poetix> It seems to suggest a powerful sandbox model for execution of safe code with limited privileges
07:28:12 <shapr> He said "I put this online, do you think LtU would be interested?"
07:28:51 <poetix> You have code that is prevented by the type system from doing IO, but can send messages to the enclosing process requesting IO operations
07:29:12 <shapr> I hadn't thought about that, I was just thinking of a reimplimentation of SVN in 540 lines of Haskell.
07:30:07 <poetix> I don't actually understand how it works at all. There is some magic happening somewhere, and I haven't yet found the man behind the curtain.
07:30:24 <shapr> joelr: I figured it out. The "(Old) Haskell libraries" from http://www.haskell.org/ghc/docs/latest/html/ aren't in the hierarchy and require -package statements.
07:30:30 <shapr> What magic?
07:30:41 <joelr> shapr: cool
07:30:45 <shapr> It seems straightforward tome.
07:30:47 <poetix> The way the zipper code "escapes" out into the OS code
07:30:52 <integral> isn't the way it does it's "syscalls" just the same as normal unix syscalls?
07:30:56 <shapr> Oh that.
07:31:22 <poetix> It seems to be able to do something a little like raising events that are handled in a totally different context
07:31:27 <joelr> @index MutableByteArray
07:31:28 <lambdabot> bzzt
07:31:33 <joelr> hmm
07:31:34 <xerox> 530!
07:31:44 <shapr> It's only 4:30pm here.
07:31:50 <xerox> Lines of code :-)
07:31:53 <shapr> oh
07:31:58 <joelr> shapr: where are you?
07:32:11 <shapr> joelr: About a thousand kilometers north of you.
07:32:20 <joelr> shapr: how can it be 4:30pm then?
07:32:47 <shapr> er, isn't it ~16:30 in Stockholm also?
07:33:01 <joelr> shapr: exactly. that's why i'm asking
07:33:27 <shapr> I'm in Boden... why wouldn't it be about 16:30 here?
07:33:44 <xerox> poetix: when a new functional zipper is created upon a data structure you get persistence in terms of undo/snapshot because the data isn't destroyed.  Delimited continuations are used to 'fake' threading in a single-thread-unix process
07:34:09 <poetix> xerox: Yes, that bit I sort of understand
07:34:10 <sieni> joelr: Typically the time zone does not change, if you move north or south
07:34:30 <shapr> Yeah, I think it's like databases that save all of the undo information, there's no real IO going on.
07:34:33 <joelr> shapr: boden is what country :D sweden?
07:34:40 <shapr> joelr: Yes, definitely.
07:34:50 <joelr> shapr: ah, i thought you were in kansas or something
07:34:56 <shapr> Whatever for?
07:34:58 <ValarQ> shapr: what a coinsident, it's ~16:30 here too
07:35:03 <joelr> no idea
07:35:25 <shapr> CosmicRay, aka John Goerzen, he's around there somewhere. But not me. I am originally from Alabama though.
07:35:50 <joelr> @index RealWorld
07:35:52 <lambdabot> Control.Monad.ST, Control.Monad.ST.Lazy, Control.Monad.ST.Strict
07:36:05 <joelr> shapr: ok :-)
07:36:28 * joelr is moving back to the canary islands on tuesday
07:36:39 <shapr> aww, why?
07:36:48 <joelr> shapr: the weather is nicer ;P
07:36:54 <poetix> shapr: I think there is some real IO happening
07:37:49 <shapr> poetix: Look at page 12 of the zfs-talk.
07:38:19 <xerox> poetix: where?
07:38:23 <poetix> "It must ask the "OS" by sending an OSReq"
07:38:26 <shapr> and page 14
07:38:31 <poetix> I think that's picked up by something that does some real IO
07:38:37 <shapr> Yup, exactly.
07:38:57 <joelr> question
07:39:12 <poetix> That's what I find interesting (and mysterious) - an IO-free function can signal out to something that then does IO
07:39:13 <shapr> answer
07:39:26 <joelr> type BinArray = MutableByteArray RealWorld Int -- is in NewBinary.Binary but not exported
07:39:33 <shapr> It doesn't really do IO, it's just a bunch of global state that gets flattened at some point.
07:39:33 <xerox> O_o
07:39:40 <shapr> (I think so, at least)
07:39:58 <poetix> There are some real disk reads and writes, aren't there?
07:40:02 <shapr> Page 14 mentions the supervisor that does conflict resolution.
07:40:04 <joelr> i'm trying to use hPutBufBA which uses MutableByteArray RealWorld a
07:40:17 <joelr> how can I change from one to another since they are basically the same?
07:40:35 <poetix> That's it - the zipper calls an "interrupt" that transfers control to the supervisor, which does the dirty work
07:41:29 <joelr> or how can i cast NewBinary.Binary.BinArray to MutableByteArray
07:41:44 <joelr> cause i'm getting an error
07:41:44 <joelr>     Couldn't match `MutableByteArray RealWorld a'
07:41:46 <joelr>            against `NewBinary.Binary.BinArray'
07:41:46 <joelr>       Expected type: MutableByteArray RealWorld a
07:41:46 <joelr>       Inferred type: NewBinary.Binary.BinArray
07:43:05 <shapr> Before the dirty work is done, you have unlimited undo.
07:43:05 <fnord123> joelr == wagerlabs?
07:43:05 * Lemmih hands unsafeCoerce# to joelr and runs to a safe distance.
07:43:17 <joelr> fnord123: yeah
07:43:25 <joelr> fnord123: how did you know?
07:43:31 <fnord123> haha
07:43:56 <shapr> poetix: Oleg's demo doesn't appear to write anything to the disk at this point. In any case, it's perfect for the version control we want.
07:44:19 <poetix> Hmm
07:44:39 <shapr> Look at ZFS.hs line 43. That's the starting 'filesystem'.
07:45:18 <Maddas> Oleg is awesome :-)
07:45:22 <shapr> I think that means that un/serialization will be just that easy.
07:45:30 <joelr> @index unsafeCoerce#
07:45:31 <lambdabot> bzzt
07:45:44 <xerox> @type System.IO.Unsafe.unsafeCoerce#
07:45:46 <lambdabot> bzzt
07:45:50 <joelr> thanks
07:46:26 <shapr> poetix: Assuming a Data.Graph of Haskell2Xml instances is easily serializable, the ZFS won't add any complication.
07:46:26 <xerox> Hmm.
07:46:39 <fnord123> oleg wrote a paper with a great acknowledgement page :)
07:46:53 <shapr> fnord123: Which one?
07:47:28 <joelr> what's the difference between unsafeCoerce and unsafeCoerce#?
07:47:40 <shapr> the # usually means "unboxed"
07:47:57 <joelr> i thought so
07:48:10 <joelr> unboxed unsafe coerce doesn't quite make sense to me... yet
07:48:29 <shapr> Do you know the difference between a boxed and unboxed array?
07:48:39 <wilx> ZFS talk?
07:48:39 <fnord123> im looking for it
07:48:41 <wilx> ZFS.hs?
07:48:41 <joelr> shapr: that yes
07:48:57 <fnord123> sorry. i was thinking of olin shivers
07:49:07 <fnord123> http://www.scsh.net/docu/html/man.html
07:49:33 <Lemmih> joelr: GHC-only functions are tagged like that.
07:49:41 <joelr> Lemmih: ok
07:50:09 <xerox> The apart from the fs, rest of ZFS.hs is kinda obscure.
07:50:11 <joelr> i still can't find unsafeCoerce# for some reason
07:50:11 <Lemmih> Or rather, GHC tags its primops like that.
07:50:21 <Lemmih> @type GHC.Exts.unsafeCoerce#
07:50:22 <lambdabot> forall b a. a -> b
07:50:25 <joelr> aha
07:50:49 <Lemmih> joelr: All the good stuff is in GHC.IO, GHC.IOBase and GHC.Exts.
07:50:55 <joelr> :)
07:51:12 <rep> do you believe in anarchy?
07:51:21 <shapr> fnord123: Dude, that's gorgeous.
07:51:24 <fnord123> :)
07:51:46 <shapr> rep: Sure, anarchy has worked well at food distribution and medical help in every war zone I've ever seen.
07:52:00 <shapr> Just in case it wasn't totally clear, that was *loaded* with sarcasm.
07:52:01 <rep> you've been in a war zone?
07:52:06 <rep> heh
07:52:33 <fnord123> anarchy = noone with a monopoly on violence. i.e. people competing for dominance
07:52:38 <fnord123> i.e. a civil war
07:53:37 <shapr> As soon as you start making rules, it's not an anarchy anymore.  If you don't have some rules, how can you get anything done?
07:54:05 <xerox> shapr: rules at what level?
07:54:52 <shapr> I think I'd qualify as chaotic good in most situations, I'm definitely a fan of laissez-faire capitalism.
07:55:22 <shapr> I noticed a neat and cool thing in business situations... rules aren't really there to be enforced anyway.
07:55:54 <fnord123> im a fan of small non corrupt governments
07:56:00 <fnord123> or big non corrupt governments
07:56:30 <rep> so you're not a fan of corruption
07:56:30 <arcatan> what does this kind of error (from hugs) mean: ERROR "palseu.hs":37 - Instances of (Floating Int, RealFrac Int) required for definition of muunna10_rek
07:56:55 <shapr> For the most part, people know that each situation is different, and that the rules can't clearly apply to every situation. So, rules are usually used to get rid of people who are damaging whatever is going on. If you are helping whatever is going, but outside of the rules, most people just don't care. Life is more about "lead, follow, or get out of the way!"
07:56:56 <xerox> @hoogle Int -> Double
07:56:57 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
07:56:57 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
07:56:57 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
07:57:26 <xerox> arcatan: does using realToFrac on that function's arg solve the problem?
07:58:10 <arcatan> xerox: yup, thanks
07:58:15 <xerox> Np.
07:58:30 <joelr> assuming that i had something like this "put (LittleEndian size)" and i wanted size to be interpreted as Word32, how would I do that?
07:58:44 * shapr gets off his soapbox, and back on topic!
07:58:49 <shapr> poetix: What do you think about ZFS?
07:59:32 <Lemmih> joelr: (size :: Word32)
07:59:57 <joelr> thanks Lemmih
08:00:11 <joelr> i wonder if this is what's called "local quantification annotation"
08:01:34 <Lemmih> It's usually called a type annotation.
08:01:44 <shapr> Whoat "-- rm path works both on directories and files. One can even try to remove one's own parent and this is safe!"
08:02:24 <joelr> there's this paper on pattern search where they mention local quantification type annotation :-) the guys are from singapore, though, so they might have meant type annotation
08:02:29 <shapr> skew: Oleg has some improvised "get around the lack of select" code in ZFS.hs
08:02:42 <shapr> joelr: Is it Martin Sulzmann?
08:03:04 <joelr> no, ankh.ps
08:03:20 <joelr> let me find it
08:06:35 <joelr> shapr: http://ropas.kaist.ac.kr/aplas/paper/ankh.ps
08:06:53 <joelr> shapr: efficient interpretation of chart pattern language
08:09:58 <xerox> shapr: do you really understand Oleg's zipper?
08:10:13 <shapr> To some degree, sure.
08:10:33 <shapr> Do you understand the zipper?
08:10:51 <xerox> I have the general idea.
08:11:51 <shapr> So, do you see how a change to a zipper is just like changing one node in a graph?
08:12:12 <xerox> Not programmatically
08:13:22 <shapr> Have you read and understood http://www.haskell.org/hawiki/TheZipper ?
08:13:32 <xerox> Let's try again.
08:15:53 <fnord123> i didnt understand it
08:16:22 <fnord123> oh wait, it's basically a pointer to a subtree
08:16:40 <xerox> Cxt is a bit obscure
08:17:22 <xerox> Why isn't it just a Tree with a "Here" constructor?  (Which does what '@' do in the example just before)
08:18:03 <arcatan> hmm, I need to join two list, but I don't want to have any duplicate elements
08:19:00 <fnord123> delete one and then concatenate the empty list and the other list\
08:19:08 <fnord123> no duplicates.
08:19:32 <TheHunter> @type Data.List.union
08:19:33 <xerox> @plugs (nub . (++)) [1..10] [5..15]
08:19:33 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
08:19:33 <fnord123> ive been talking to the people i work with too much. :(
08:19:34 <lambdabot>   Expecting a function type, but found `b'
08:19:34 <lambdabot>   Expected type: [a1] -> [a]
08:19:34 <lambdabot>   Inferred type: [a1] -> [a1] -> [a1]
08:20:00 <joelr> how do you reverse a list?
08:20:07 <xerox> @type reverse
08:20:08 <lambdabot> forall a. [a] -> [a]
08:20:12 <joelr> he
08:20:55 <xerox> @eval let rev = foldl (flip (:)) [] in rev "rleoj ,yaw shit, esle"
08:20:57 <lambdabot> "else ,tihs way, joelr"
08:21:03 <xerox> heh.
08:21:10 <joelr> :D
08:22:55 <xerox> Anyway, the zipper.
08:22:55 <shapr> joelr: C'mon, for simple questions like that you can look at the Prelude :-P
08:22:58 <arcatan> umm, humm, how do I use union or nub?
08:23:14 <xerox> @type Data.List.union
08:23:16 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
08:23:21 <joelr> shapr: true, are you talking about zvon.org?
08:23:22 <xerox> Rather straightforward.
08:23:35 <joelr> how exactly do you look at the prelude/
08:23:42 <xerox> @docs Data.List
08:23:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
08:24:02 <xerox> Also keep this link bookmarked (or even open): http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:24:11 <shapr> joelr: Nah, the docs that come with GHC - http://www.haskell.org/ghc/docs/latest/html/
08:24:35 <arcatan> xerox: hugs says: ERROR - Undefined variable "union"
08:24:40 <joelr> duly bookmarked
08:24:47 <xerox> arcatan: I do not know about hugs :-(
08:24:58 <xerox> arcatan: in GHCi you could do  :module +Data.List
08:25:11 <shapr> If you take some time to read through the Prelude, try out the functions and look at their source.. you can learn a lot about Haskell.
08:25:32 <xerox> Completely agreed.
08:25:47 <xerox> So, zippers.
08:25:56 * joelr nods
08:27:22 <arcatan> TheHunter, xerox, thank you, now it works
08:27:50 <xerox> Uh, actually using that code makes it clear... more or less.
08:28:40 <shapr> TheHunter: Hey, you should send your paste'd Zipper code to Oleg.
08:30:22 <shapr> xerox: So you see how left/right/up/top/modify are like Rubik's cubes?
08:33:32 <Igloo> Heh, a couple of weeks after proclaiming "Haskell is the programming tool of choice for discriminating hackers" Robby Findler appears in g-h-u@ trying to install ghc  :-)
08:33:41 <xerox> *Main> t
08:33:41 <xerox> Fork (Fork (Leaf 1) (Leaf 2)) (Fork (Leaf 3) (Leaf 4))
08:33:41 <xerox> *Main> fst $ up (modify (left $ top t) (\_ -> Leaf 1234))
08:33:41 <xerox> Fork (Leaf 1234) (Fork (Leaf 3) (Leaf 4))
08:33:53 <xerox> shapr: I think so.  I want to use it to implement something now :D
08:34:36 <shapr> I want to explain the tiny bit of Oleg's Zipper that I understand first...
08:34:47 * xerox is all eyes
08:35:07 <shapr> When you modify a zipper, you can keep the previous version.
08:35:25 <shapr> You could make a zipper of a filesystem, and keep all the backups.
08:35:45 <shapr> Gee, I think that was it.
08:35:57 <xerox> I got so far, not programmatically, tough :-)
08:36:00 <shapr> The advantage of a zipper is that you get maximal sharing.
08:36:31 <shapr> I think a delimited continuation means you can cut off the parts you don't need.
08:36:58 <xerox> Oleg's zipper also seem to be  1) monadic  2) polymorphic on the type of the data structure being zipped AND the way directions are expressed.
08:37:39 <xerox> shapr: every user has the zipper on the whole data structure, I think.
08:38:28 <shapr> That's how you get transactional semantic.
08:38:29 <xerox> The continuations play the role of getting the closure of the user environment to a function.
08:38:38 <xerox> For what I understand.
08:38:43 <shapr> I think you're right.
08:38:57 <xerox> Which is neat :-D
08:39:08 <shapr> PostgreSQL does exactly that, as soon as you make a connection you can gurantee that your environment will not change out from under you.
08:39:13 <xerox> But I can't really undestand the CC monad, as now.
08:39:19 <shapr> When you commit, then your changes are saved, and your environment is updated.
08:39:28 <xerox> shapr: so it's really the same, yeah.
08:39:36 <shapr> But I think PostgreSQL probably uses more code than Oleg.
08:39:40 <shapr> to do the same thing.
08:39:57 <shapr> Also, PostgreSQL isn't polymorphic, as you said.
08:39:58 <xerox> shapr: but then what's the commits policy at higher level?
08:40:17 <micket> Hello! Some time ago i asked for a way to save a variable of my own data type to a file and read it from another program later. i was told to derive Show and Read in my datatype. But i'm kind of stuck here, i've written it to a file already but i don't know how to read it again.
08:40:19 <shapr> For Oleg's code, it's the supervisor part.
08:40:24 <basti_> how are continuations employed in zippers?
08:40:39 <basti_> micket: uhm, by "read"
08:40:40 <basti_> :D
08:40:43 <poetix> Oh, they're not just *any* old continuations...
08:40:57 <poetix> They're delimited subcontinuations, which are continuations for people with extra-large brains
08:41:06 <shapr> xerox: I don't really understand the CC monad either, everytime I start reading I realize I'll have to go through six or seven heavy duty papers to understand all this.
08:41:13 <xerox> poetix: they seem to kinda be.  Just they can return to the point they were called at, instead of 'trashing' the rest of the computation, like 'standard' continuations.
08:41:20 <shapr> I haven't had time to read all the papers behind the CC monad :-(
08:41:50 <xerox> I hope simonpj & co. paper will do it for me.
08:42:21 <shapr> I think it will require more than that...
08:42:23 <xerox> basti_: it seems they're heavily interspersed :D
08:42:35 <shapr> For me at least
08:42:49 * basti_ sighs
08:42:49 <xerox> shapr: I like the fact that we can talk about it without deep knowledge, I think it's a good sign.
08:44:14 <shapr> Yes, I think so.
08:44:27 <shapr> But I'm always unhappy when I don't totally understand something.
08:44:32 <xerox> Oleg's code does use exactly the code from that paper (A Monadic Framework for Delimited Continuations.)
08:45:05 <xerox> shapr: same here.  TheHunter didn't give me much hopes, tough ;)
08:45:08 <shapr> I have two levels of understanding, intuitive and thorough. I often can figure something out just by looking at it. Then I have to go read all the references to see if I was right.
08:45:29 <shapr> I'm right about 80% of the time.
08:45:45 <bourbaki> moin
08:45:57 <xerox> I think the only actions I did lately were the ones which finished in IO a.
08:46:37 <xerox> (Talking about how time consuming is reading references <blink>)
08:48:32 <shapr> Well, now you understand that Oleg's zipper aren't very complicated, right?
08:48:50 <{Arias}> absolute x = if x < 0 then -x else x <- why this dont works?
08:49:19 <xerox> shapr: Did you read dzip'term definition?  Sob.
08:49:45 <xerox> {Arias}: what error do you get?
08:50:06 <micket> basti_ sorry.. im stupid. How do i point out what datatype it is? since im doing this in main.. file <- readFile "Station.Data" ; stations <- read file  Thats what i tried.. but of course it didn't work >_<
08:50:09 <{Arias}> No instance for (Num (a -> a))
08:50:11 <basti_> {Arias}: you might have forgotten () around -x
08:50:17 <xerox> {Arias}: you could also write it using guards, which is kinda good-looking:
08:50:18 <xerox> abs x | x < 0     = -x
08:50:18 <xerox>       | otherwise =  x
08:50:40 <basti_> micket: ah of couse, that's a problem.
08:50:53 <{Arias}> arising from use of '-' at ...
08:50:54 <{Arias}> xD
08:50:55 <basti_> micket: you need a type annotation, like stations <- (read file)::Int
08:50:58 <basti_> or something
08:51:14 <micket> ah ok, lemme try that
08:51:16 <xerox> {Arias}: yeah, in the end, error messages _are_ helpful :-)
08:51:31 <shapr> xerox: It's not that bad, do you know what prompt is?
08:51:31 <basti_> {Arias}: you might as well have used "abs"
08:51:36 <basti_> @plugs abs (-13)
08:51:42 <lambdabot> 13
08:51:43 <xerox> shapr: not at all, sigh!
08:51:50 <{Arias}> i'm starting
08:51:55 <{Arias}> i'm only trying
08:51:56 <{Arias}> xD
08:52:08 <xerox> {Arias}: what is 'xD' ?
08:52:09 <basti_> ah ok ;)
08:52:16 <{Arias}> xD is like lol
08:52:24 <basti_> xerox: "slap your eyes and laugh" smiley
08:52:25 <xerox> Urgh.
08:52:40 <xerox> ÃD it's more centered, at least
08:52:52 <basti_> emoticons get wierder and wierder.
08:52:57 <shapr> but xD is mostly from .es
08:53:04 <{Arias}> i'm spanish xD
08:53:13 <Maddas> basti_: ^_^
08:53:18 <xerox> Â¿who would have said?
08:53:36 <micket> basti_ stations <- return $ (read file)::Station   It didn't like that either.. couldn't match `Station' against `m a'
08:54:08 <micket> First time i see an m appear there..
08:54:49 <basti_> micket: try more braces.
08:54:54 <basti_> uhm parenthenses
08:55:06 <basti_> :: binds in a stupid way
08:55:13 <TheHunter> stations <- return (read file :: Station)
08:55:33 <TheHunter> or even: let stations = read file :: Station
08:55:47 <micket> ah
08:55:57 <bourbaki> hey TheHunter basti_
08:56:01 <micket> now everything have paranthesis :P
08:56:13 <micket> and it works! thanks basti_ <3
08:56:19 <TheHunter> hey bourbaki, how's it going?
08:56:31 <bourbaki> quite good thanks how about you?
08:56:59 <TheHunter> good, too, but also quite a lot of work...
08:57:31 <bourbaki> how come? the semester has just started
08:58:09 <TheHunter> nah, I'm having school for like 5 weeks now.
08:58:21 <basti_> micket: great...
08:58:23 <basti_> bbl now
08:58:26 <TheHunter> *'ve had
08:58:54 <bourbaki> TheHunter: oh what courses?
08:59:07 <xerox> shapr: what were we up to?
09:00:13 <TheHunter> bourbaki, geometry+topology, lie groups and diff. eqns, plus teaching.
09:00:40 <bourbaki> ah geometry and topology is cool i guess
09:00:53 <xerox> shapr: ah, right, what is a prompt :-)
09:01:09 <TheHunter> haven't learnt anything new in that course yet :/
09:01:18 <bourbaki> yet :)
09:01:37 <bourbaki> at a certain point you dont learn anymore really new things in math
09:01:49 <TheHunter> i beg to differ.
09:01:58 <bourbaki> heh :)
09:02:31 <bourbaki> actually this points are the axioms ;)
09:02:40 <xerox> so make new ones
09:02:48 <bourbaki> :)
09:03:06 <xerox> That was a question floating in my mind while ago, in fact.
09:03:19 <bourbaki> which one?
09:03:30 <xerox> People sometime talk about 'it depends on the system you're using this definition in' or something.
09:03:45 <xerox> This means that it's all been said on possible axioms basing systems, or not?
09:03:53 <bourbaki> yep
09:04:06 <bourbaki> this is why its so difficult to talk to philosophers
09:04:19 <xerox> Yep as in, no hopes?
09:04:24 <bourbaki> if you are interested in this have a look at goedels theoreme
09:04:35 <xerox> Gee, I'm reading GEB.
09:05:06 <bourbaki> i have it on my desk didnt read it yet so i dont know if the thingy i am talking is in there
09:05:08 <xerox> Err, I'm reading GEB ad school and haskell-based papers at home in fact, glurgle.
09:05:19 <Maddas> :-)
09:05:19 <bourbaki> :)
09:05:25 <Maddas> Sounds like fun!
09:05:45 <xerox> bourbaki: but the point is a little different, I think.
09:06:26 <bourbaki> well the first thing is that you can proof anything if you asume the right axioms
09:06:36 <bourbaki> and the other thing is that you cant proof the axioms in the system
09:06:40 <xerox> I can get along with this.
09:06:55 <bourbaki> plus it wont allow you to alter the truth of the things you state once you asume these axioms
09:07:07 <xerox> But if one said this before today's math was studied... would the man have tried to study it?
09:07:17 <bourbaki> sure
09:07:29 <bourbaki> ever heared of hilberts program?
09:07:33 <xerox> Nope.
09:07:55 <bourbaki> he tried to have a look at all of the mathematical foundations logically
09:08:11 <bourbaki> and they found quite some things that had to be corrected
09:08:25 <xerox> Any reference?
09:08:37 <bourbaki> i have read it in a book
09:08:47 <xerox> I should find a book
09:08:50 <bourbaki> if i am not mistaken it was fermats last theoreme
09:09:07 <xerox> Is it a book?
09:09:21 <bourbaki> yez
09:09:27 <bourbaki> from simon sigh
09:09:48 <integral> *singh
09:09:54 <bourbaki> has a lot of funny mathematical anecdotes
09:09:58 <bourbaki> thanks integral
09:10:13 <bourbaki> http://en.wikipedia.org/wiki/David_Hilbert
09:10:52 <bourbaki> theres also a link to his program
09:10:52 <xerox> Invariants, woot.
09:11:31 <xerox> I heard of Hilbert spaces I think.
09:11:38 <bourbaki> :)
09:11:57 <bourbaki> oh my name is listed there also ;)
09:12:13 <xerox> You're famous and rich!
09:12:36 <bourbaki> famous yes rich no :)
09:12:42 <bourbaki> it would be cooler the other way around
09:15:14 <brx> bourbaki: ..
09:17:58 <brx> it's mentioned in geb iirc
09:18:46 <xerox> brx: what is 'it' exactly?
09:20:54 <brx> xerox:  goedel's incompleteness theorem, what bourbaki said.
09:21:13 <xerox> The whole book is an attempt to demonstrate it, isn't it?
09:21:39 <TheHunter> hmm, ZFS doesn't share the contents of its directory tree between two telnet sessions?
09:21:40 <brx> heh
09:22:16 <brx> xerox: so why did you ask about "it"? :)
09:22:30 <xerox> TheHunter: committing and reloading makes thing synchronize, if it's what you are asking for.
09:22:55 <xerox> brx: I thought you were talking more generally about the axioms/systems/future problem
09:23:22 <TheHunter> xerox, ah, ok
09:24:05 <TheHunter> so refreshing loses the cursor?
09:24:59 <xerox> TheHunter: nope, given that the current path does still exist
09:25:05 <xerox> I think?
09:25:30 <xerox> I didn't try apart from removing the parent and refreshing.
09:25:47 <xerox> In that case it goes to Top
09:25:53 <TheHunter> @bot
09:25:54 <lambdabot> :)
09:26:15 <xerox> In fact I think you're right.
09:26:46 <xerox> If continuations does not what shapr thought, you need to 'instantiate' another zipper on the 'new' data structure.
09:27:03 <xerox> But even, if the path still exists, one could move the new one in the same place?
09:27:32 <TheHunter> the same place need not be the right thing.
09:28:07 <xerox> I see what you mean.
09:28:12 <TheHunter> for example, if the other session has moved a to b and b to c, then i want the cursor to be on c if it was previously on b.
09:28:20 <xerox> Yep..
09:28:53 <xerox> The same path could place the cursor on different values, applied on zippers of different structures
09:29:19 <xerox> So you lose the cursor.
09:30:50 <TheHunter> it's annoying to read Oleg's code since every other function is missing their type signature.
09:31:27 <xerox> :-\
09:31:39 <xerox> dons had a script to put signatures automagically.
09:32:02 <TheHunter> @where dons'magicalscript
09:32:03 <lambdabot> I know nothing about dons'magicalscript.
09:34:02 <paolino> ciao I'm reading http://okmij.org/ftp/Haskell/random-var-monad.txt what are liftM and liftM2 ?
09:34:15 <xerox> @type Control.Monad.Trans.liftM
09:34:17 <lambdabot> bzzt
09:34:22 <xerox> @index liftM
09:34:23 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
09:34:23 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
09:34:23 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
09:34:27 <xerox> @type Control.Monad.liftM
09:34:28 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m
09:34:28 <lambdabot> r
09:34:31 <xerox> @type Control.Monad.liftM2
09:34:33 <lambdabot> forall r (m :: * -> *) a2 a1.
09:34:33 <lambdabot> (Monad m) =>
09:34:33 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:35:02 <xerox> @eval liftM (+2) (Just 1)
09:35:03 <lambdabot> Just 3
09:35:15 <xerox> @eval liftM2 (+) (Just 1) (Just 2)
09:35:17 <lambdabot> Just 3
09:36:09 <xerox> paolino: it lifts the function with 1 (liftM) or 2 (liftM2) arguments into the monad
09:36:19 <xerox> @index liftM3
09:36:20 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
09:36:20 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
09:36:20 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
09:36:35 <paolino> so import Monad  is wrong ? import Control.Monad ?
09:36:39 <xerox> There are probably definitions until M6 or something.
09:36:45 <xerox> paolino: the latter is correct.
09:37:04 <paolino> what is the meaning of lifting?
09:37:11 <TheHunter> import Monad is fine, but Control.Monad is preferred.
09:37:50 <paolino> hugs fails locating liftM with the import Monad
09:38:18 <xerox> paolino: do you understand liftM type?
09:38:36 <paolino> no
09:39:04 <xerox> You have a function from a to b, and a value m a (where m is a monad), liftM lets you apply the function to the value, returning m b.
09:39:47 <xerox> It's the same as fmap, but for monads.
09:39:53 <TheHunter> @type Monad.liftM
09:39:55 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m
09:39:55 <lambdabot> r
09:40:24 <paolino> lambdabot why you line feed in the middle ?
09:40:57 <xerox> And given that most (all?) of the monads are also functors, for them  liftM = fmap.
09:41:11 <TheHunter> all
09:41:18 <xerox> Thanks.
09:41:24 <paolino> uh
09:41:47 <TheHunter> instance Functor Foo where fmap = liftM
09:43:18 <paolino> lift the cover and apply inside,then cover again
09:43:55 <maihem> @yow
09:43:56 <lambdabot> Nipples, dimples, knuckles, NICKLES, wrinkles, pimples!!
09:44:44 <xerox> TheHunter: so 'lift' has a different meaning in liftM and MonadTran's lift?
09:44:58 <TheHunter> very different
09:45:15 <paolino> got it probably, then what about hughs ,it doesn't locate even with import Contro.Monad ?
09:45:36 <xerox> paolino: I'd suggest using GHCi, I don't know much about hugs.
09:45:44 <paolino> k
09:47:21 <paolino> ghci is not content, but for Not in scope: `fromInt'
09:47:47 <xerox> @type fromIntegral
09:47:48 <lambdabot> forall b a. (Num b, Integral a) => a -> b
09:48:00 <xerox> Do you mean that?
09:48:58 <paolino> I didn't write that code ,I wish
09:49:19 <paolino> probably it's old
09:49:44 <paolino> s/fromInt/fromIntegral ?
09:50:02 <xerox> Check if it imports any module which can contain it.  Or even  grep -rni fromInt  in the base directory of code's hierarchy.
09:50:13 <xerox> grep -rn fromInt .  even.
09:51:09 <paolino> it only imports Monad
09:51:21 <xerox> Try with fromIntegral.
09:51:49 <paolino> loaded
09:56:42 <xerox> So liftM f xs = xs >>= return . f
10:25:59 <Maddas> haskell-doc is very handy!
10:43:27 <xerox> Is there a way to overload function application?  Like defining a new $ in, hiding Prelude?
10:44:48 <ski> @pl liftM
10:44:50 <lambdabot> fmap
10:45:10 <ski> xerox : no
10:45:36 <xerox> Hmpf  :-)
10:46:06 <xerox> But then if I use $ everywhere, I could accomplish it ;-)
10:46:09 <ski> what would it mean ?
10:46:37 <xerox> Instead of f (g x), write f $ g x eveywhere
10:46:54 <xerox> ...and write my own $
10:47:01 <ski> if  'f x' expands to 'myapply f x', does that then expand again to 'myapply (myapply myapply f) x' ?
10:47:28 <xerox> Err.. okay.
10:48:06 <ski> hm, what did you want to do/solve ?
10:48:20 <skew> shapr: hey, I'm back - the select I was talking about was the one in the rts that multiplexes the IO from all the Haskell threads, so one read doesn't block the whole program
10:48:40 <xerox> ski: just wondering.
10:48:50 <skew> and I was thinking of epoll purely for performance when you have lots of Haskell threads doing lots of IO
10:48:57 <skew> like 10000 concurrent TCP connections, or so
10:48:58 <xerox> ski: maybe implicit params
10:49:00 <ski> (possibly, it could be that Conor McBride's 'Idiom' type class could help with something like what you maybe want)
10:49:31 <ski> class Idiom i where {k :: a -> i a; s :: i (a -> b) -> i a -> i b}
10:49:48 <ski> 's' is like Monad.ap
10:49:54 <skew> xerox: did you ever talk about prompt with shapr?
10:49:54 <ski> @type Control.Monad.ap
10:49:56 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m
10:49:56 <lambdabot> b
10:50:07 <xerox> skew: unfortunately not :-\
10:50:16 <skew> I think I can explain the delmited subcontinuation stuff, but I haven't understood how it works in the zipper
10:50:44 * xerox shakes skew - please do! (:
10:50:57 <skew> just a minute, I think there's a good paper somewhere
10:51:15 <xerox> Great.  I also have to study for school this night.
10:52:56 <skew> Ok, I don't know where the paper got to
10:52:56 <xerox> I've found that out math books talks about fractals in the very last page, and it explains thoughtfully the Von Kock's curve.  I should show Nymphaea to my math teacher :-D
10:53:24 <skew> You know how the ordinary continuations work?
10:54:07 <{Arias}> can somebody help me?
10:54:08 <{Arias}> http://pastebin.com/388276
10:54:13 <{Arias}> why this don't works?
10:54:32 <{Arias}> the error is here: map factorial nums
10:55:14 <skew> call/cc picks up the entire context of the call, and passes it as a function to it's argument
10:55:27 <xerox> skew: back, sorry.  I know a bit about continuations.  They captures what it's going to be evaluated after the expressions.
10:56:21 <xerox> So call/cc exposes its continuation as a function?
10:57:05 <skew> so the rule with an ordinary continuation is that if you call it, then you run that context to the end of the program, and throw away whatever future evaluation you would have done otherwise
10:57:19 <xerox> I have it so far, yes.
10:58:09 <skew> Some slides I can't find again used A to be an operation that aborts the program, and C to be some context A[C[callcc f]] evaluates as A[C[f (\x -> A[C[x]])]]
10:58:31 <skew> the subcontinution stuff is about not taking the whole continuation
10:58:44 <xerox> C does remain there too?
10:58:49 <skew> I'll talk about the static ones first, shift/reset
10:58:50 <skew> yeah
10:58:53 <Cale> {Arias}: I'll have a look
10:59:00 <skew> if you return normally from the call/cc, you continue with that value
10:59:08 <{Arias}> thanks Cale
10:59:08 <xerox> skew: let me try to understand the expression.
10:59:11 <skew> but, the continuation you got can escape
10:59:39 <xerox> Are the two C the same one?
11:00:08 <skew> yes
11:00:33 <xerox> What does x represent?
11:00:49 <Cale> {Arias}: you wrote "map factorial nums" as a line in a do expression for main, which is necessarily of type (IO a)
11:01:04 <paolino> skew, xerox  what are the [] there ?
11:01:06 <Cale> but  map factorial nums :: (Num a) => [a]
11:01:23 <xerox> paolino: it's not Haskell code!  Just a way to enclose scopes.
11:01:30 <Cale> or more likely [Integer]
11:01:43 <skew> paolino: it's writing a context with a hole - not Haskell syntax
11:01:52 <Cale> if you want to print them, you should use  print (map factorial nums)
11:02:33 <skew> but if you wanted to talk about substituting something for x in 1 + (y * x), you might talk about the bit around x as 1 + (y * [ ])
11:02:54 <goron> What would be a good channel to ask about jargon used in chip design?
11:02:55 <{Arias}> mmm
11:03:01 <ski> xerox : x is just a local variable .. here representing the argument thrown to the continuation (i.e. what appears to be returned at the call/cc call site)
11:03:16 <{Arias}> thank you Cale :D
11:03:46 <xerox> Mumble.
11:04:06 <skew> heres some useful slides, not quite the ones I was looking for http://www.eecs.harvard.edu/~ccshan/recur/talk.ps.gz
11:04:33 <skew> about the contexts, then you can start talking generically about some context C[ ]
11:05:28 <joelr_> howdy
11:05:30 <micket> Hmm, i'm having some problems with a few functions of mine, i'd like to check one of the recursive functions by printing a value from it every recursion. Can i do this easily without having to make all it into IO
11:05:38 <xerox> skew: wait a second, I'm a bit lost.
11:05:59 <joelr_> can you have two functions with the same name and a signature where the type of some arguments is different? or maybe the number of arguments is different
11:06:06 <xerox> You pass callcc a function, which gets the rest of the computation as argument?
11:06:23 <joelr_> can you pattern-match on argument type that is
11:06:46 <xerox> joelr_: that's what typeclasses are there for.
11:07:02 <joelr_> xerox: how's that?
11:07:12 <joelr_> writePacket :: (ByteSized a, Binary a, Typed a) => BinHandle -> a -> IO ()
11:07:18 <joelr_> writePacket :: (ByteSized a, Binary a, Typed a) => Handle -> a -> IO ()
11:07:19 <xerox> joelr_: Think of (+) type.
11:07:21 <joelr_> this does not fly
11:07:35 * joelr_ is thinking erlang
11:07:51 <skew> xerox: that's the idea
11:08:03 <xerox> skew: could you try to give me an Haskell programmatically example?
11:09:15 <davve> micket, the function is called trace
11:09:42 <joelr_> so i do have to name these two functions differently, right?
11:09:46 <xerox> skew: or in scheme if you prefer.
11:10:04 <ski> class PacketHandle h where writePacket :: (ByteSized a, Binary a, Typed a) => h -> a -> IO ()
11:10:05 <ski> ?
11:10:08 <micket> ill look that up davve! thanks
11:10:10 <skew> running code that uses continuations doesn't really help to understand it. I think I can write something useful, though
11:10:31 <xerox> skew: Thank you very much.
11:10:37 <ski> (instance PacketHandle BinHandle where ...  instance PacketHandle Handle where ...)
11:10:56 <ski> (joelr_ : not sure if that helps in your case ..)
11:10:57 <joelr_> ski: i think i see what you are saying
11:11:41 <ski> otherwise, you can either give them different names, or put them in different modules (and use module qualification to disambiguate ..)
11:11:53 <joelr_> ski: i think it's more like instantiating Handle
11:11:57 <skew> take an expression like 1 + 2*x - the continuation of x is 1 + 2*[_]. You can rearrange the code to make it a function, like let f n = 1+ 2*n in f x, so now f represents the rest of what happens
11:12:20 <xerox> skew: right on!
11:12:31 <skew> then 1 + 2 * (callcc g) is pretty much the same as let f n = 1 + 2*n in f (g f)
11:13:01 <xerox> f (g f) ?  why not just  (g f)  ?
11:13:39 <skew> consider something like 1 + 2*callcc (const 3)
11:14:31 <skew> it's just how the operator is defined, but it seems to make more sense to get 7 than 3
11:14:50 <micket> davve, is Hat what i'm after?
11:14:55 <ski> xerox : because, if you don't call f, then you will just return normally from call/cc
11:15:00 <skew> It's even clearer if you have something like if 2*callcc g < 4 then True else False
11:15:14 <ski> xerox : call/cc :: ((a -> b) -> a) -> a
11:15:37 <TheHunter> *Reflection> reset (1 + 2 * callCC' (const 3)) :: Int
11:15:37 <TheHunter> 7
11:15:38 <xerox> (define skew (lambda () (+ 1 (* 2 (call/cc g)))))
11:15:39 <xerox> (define g (lambda (f) (f 3)))
11:15:39 <xerox> (skew)  ==>  7
11:15:51 <xerox> haha TheHunter.
11:16:46 <xerox> ski: that's why I thought it was just (g f)
11:17:03 <skew> you could have abort(C[callcc f]) = abort(f (\x -> C[x])), it's just not usually defined that way
11:17:05 <joelr_> how do you work around "Test.hs:6:5: The last statement in a 'do' construct must be an expression
11:17:08 <joelr_> "
11:17:17 <skew> abort is supposed to represent the end of the program
11:17:35 <xerox> TheHunter: is Reflection available somewhere?
11:17:38 <Cale> joelr_: you probably have something like "x <- y" as the last line of your do block
11:18:04 <joelr_> i have a "print x"
11:18:05 <TheHunter> xerox, sure: http://www.haskell.org/tmrwiki/FunWithLinearImplicitParameters
11:18:16 <Cale> joelr_: can I see?
11:18:45 <joelr_> sec
11:19:07 <dsfsdf34> Hello all
11:19:19 <Cale> hi
11:19:27 <Peach06> just started learning Haskell here
11:19:38 <Cale> cool
11:19:43 <Peach06> having a little prob which i can't wotk out :(
11:19:54 <Cale> what is it?
11:19:54 <joelr_> Cale: the problem went away temporarily :D
11:19:59 <Cale> joelr_: :)
11:20:11 <joelr_> Cale: you just had to ask ;)
11:20:20 <xerox> reset and callCC' types are very mysterious.
11:20:59 <TheHunter> just ignore the types then :)
11:21:19 <xerox> Okay.
11:21:30 <skew> xerox: anyway, that continuation of some expression is "the stuff that happens once it evaluates to some value"
11:21:41 <Peach06> Line 2: Instance of <realFrac Int, Floating Int) required for definition check
11:21:45 <xerox> Could you repeat the f (g f) idea again?
11:21:54 <Peach06> the script can be found here: http://pastebin.com/388304
11:22:05 <skew> xerox: you can reify that as a function that will do exactly the same thing when you pass it a value as the program would have done if the expression evaluated to that value
11:22:22 <xerox> Peach06: try using realToFrac on functions' argument that needs to be converted to fractional types.
11:22:41 <skew> the f (g f) thing was just making the rest of what the program does already be just applying a function to the value you get back
11:22:48 <skew> that's what f does
11:22:51 <Cale> Peach06: sqrt (fromIntegral input)
11:23:14 <skew> so when call/cc was wrapping up that continuation, you get something identical to f
11:23:26 <skew> (at least if your whole program is just that little numeric expression)
11:23:29 <elux> hey
11:23:36 <joelr_> is there a way to see the stack trace with ghci when an exception is thrown?
11:23:37 <Cale> hello elux
11:23:39 <elux> has anyone ever heard about compiling haskell to java bytecode?
11:23:50 <Peach06> xerox - I don't think thats the problem... if I replace "truncate(sqrt(input))" on line 4 with a constant number - it works fine :-/
11:24:06 <skew> I've heard of it, I don't think there is anything that does it any more
11:24:07 <xerox> Peach06: learn from Cale, sorry.
11:24:19 <Peach06> oh didn't see that
11:24:25 <skew> somebody got it working once a while back, but I think it's bitrotted since then
11:25:01 <Peach06> what does from integral do ?
11:25:22 <elux> skew: anymore?  you mean with the newer version of the jvm?
11:25:27 <skew> There's work to get it targeting CLR, which might stick around a bit longer, because lots of important Haskell people belong to Microsoft Research
11:25:29 <Cale> Peach06: It converts Integral typed values to arbitrary number types
11:25:35 <skew> no, the newer versions of ghc
11:25:51 <TheHunter> i don't believe f (g f) is what call/cc does.
11:25:52 <skew> there's stuff for using Java through JNI, though
11:25:57 <Cale> @type fromIntegral
11:25:58 <lambdabot> forall b a. (Num b, Integral a) => a -> b
11:26:12 <TheHunter> shift does g f.
11:26:13 <Cale> So for instance,  Int -> Double
11:26:26 <Cale> Integer -> Float
11:26:31 <Cale> Integer -> Complex Double
11:26:32 <elux> skew: how about haskell with c++?
11:26:32 <skew> TheHunter: well, I was assuming this is the top of the program
11:26:33 <Cale> and so on
11:26:34 <elux> or c
11:26:42 <skew> that's just straight FFI
11:26:53 <skew> easy, and lots of tools to help even more
11:26:59 <beschmi> joelr_: i'm afraid there isn't. do you know at least where (in the source) the exception is raised?
11:27:03 <xerox> I can't concentrate :-\
11:27:20 <joelr_> beschmi: deep in the libraries :(
11:27:24 <xerox> Would boegel mind if we discuss it on -blah ?
11:27:37 <joelr_> beschmi: fortunately in this case i have a clue as to where the problem lies
11:27:46 <TheHunter> skew, but a call to the argument of g never returns.
11:27:54 <skew> Oh, rigt
11:27:55 <Cale> joelr_: what is the exception being thrown?
11:28:01 <skew> yeah, that's a bit different
11:28:04 <joelr_> beschmi: but i'm wondering what i would do if i did not have a clue
11:28:15 <joelr_> *** Exception: Data.Binary.getWord8: end of file
11:28:20 <joelr_> that's all i get exception-wise
11:28:22 <xerox> skew, TheHunter, can you go on #haskell-blah?  Just to be able to chase the discussion properly.
11:28:27 <skew> ok
11:28:38 <elux> skew: have you ever tried ocaml?  i hear its a great functional language with OO support
11:28:53 <joelr_> this is from running this code, sans the seek and tell
11:28:53 <joelr_> main = do
11:28:53 <joelr_>        let packet = ClHandShakePacket 0 0 0 2174
11:28:53 <joelr_>        bh <- openBinMem 1 undefined
11:28:53 <joelr_>        pos <- tellBin bh
11:28:54 <joelr_>        writeBinPacket bh packet
11:28:56 <joelr_>        seekBin bh pos
11:28:58 <joelr_>        l <- unpack bh
11:29:00 <joelr_>        print l
11:29:03 <elux> just wondering why haskell is more popular if OO design is usually preferred when it comes to bigger projects (at least thats the case with imperative languages)
11:29:18 <joelr_> so in this case i know to add the tell and then the seek.
11:29:24 * joelr_ doesn't think haskell is _that_ popular 
11:29:41 <joelr_> if haskell was popular it would not be the tool of choice for discriminating hackers
11:29:48 <joelr_> discriminating is the keyword i think
11:30:14 <elux> its definitely growing in popularity
11:30:22 <Cale> elux: OO design is not the end-all and be-all of program design :) There are other abstractions to be explored
11:30:41 <elux> Cale: but most methodologies go back to OO
11:30:46 <elux> what are you talking abotu specifically?
11:30:50 <beschmi> elux: most ocaml code doesn't use the OO support
11:31:06 <elux> i never used ocaml thats why im asking
11:32:04 <Cale> Well, things like monadic abstraction of code, parametric polymorphism rather than subtype polymorphism, typeclasses and type-directed programming.
11:32:18 * joelr_ is debugging his first Haskell program
11:32:20 <elux> few languages support all that ;)
11:32:31 <micket> aaah unsafeIO, how i love you!
11:32:51 <Cale> micket: haha, what are you doing?
11:33:04 <micket> my code was getting stuck somewhere
11:33:16 <elux> i have to say though, i just recently started learnign haskell and i am very impressed with what i can do with it.. with such little code i gain unparalled flexibility
11:33:24 <micket> and i needed to print a value from the recursive function
11:33:47 <joelr_> how do you do this:        print "Packet size " ++ size
11:33:59 <Cale> micket: there's Debug.Trace :)
11:34:05 <xerox> joelr_: show size
11:34:11 <Cale> (of course, it's written with unsafePerformIO)
11:34:23 <joelr_> oh, ok
11:34:28 <Cale> joelr_: and add a $ after the print
11:34:41 <micket> ah well unsafePerformIO was alot easier then i thought it would be
11:34:48 <Cale> and change the print to a putStrLn :)
11:34:56 <Cale> (or else it'll print the quotes)
11:35:01 <joelr_> "Packet size 13"
11:35:02 <joelr_> hehe
11:35:21 <Cale> print = putStrLn . show
11:39:13 <joelr_> is there a way to instantiate a data type with some of the arguments (just a few named fields for example)?
11:39:21 <joelr_> while providing defaults for others
11:39:24 <shapr> Cale: HaWiki is becoming a nightmare.
11:39:58 <shapr> The spambot is putting the changes back when you revert them.
11:41:19 <Peach06> Having a problem with this script: http://pastebin.com/388326 - Error Line 8: Syntax error in declaration (unexpected ';', possibly due to bad layout)
11:41:23 <micket> damn spammers
11:42:10 <droundy> joelr_: I believe the syntax is:  x = defaultFoo { fooa = "a", foob = "b" }
11:42:33 <joelr_> droundy: david, and what about defaults for other fields?
11:43:11 <droundy> joelr_: They're determined by the value of defaultFoo, which is just any old record.
11:43:16 <shapr> Cale: I turned off anonymous write on HaWiki
11:43:49 <joelr_> droundy: but i don't think you can supply defaults when describing defaultFoo. or can you?
11:44:27 <droundy> joelr_: i.e. this is just an "update" syntax to create a record with a few fields modified...
11:44:38 <joelr_> droundy: right. thanks
11:45:30 <shapr> Cale: Seems that the spambots choose a new random text string to use for spam whenever one string is banned.
11:45:30 <micket> Peach06: the problem is on the previosu function
11:45:59 <micket> Peach06: You messed up the last row on the first function.
11:46:04 <Peach06> yeh.. i was thinking it was the last guard
11:46:13 <Peach06> whats wrong with the statement though ?
11:46:28 <micket> no =
11:46:55 <Peach06> ?
11:47:02 <micket> you need a =
11:47:15 <Peach06> otherwise ?
11:47:21 <micket>  | otherwise = not noFactors x 3
11:47:22 <micket> perhaps
11:47:30 <micket> depends on what you want to do
11:47:57 * joelr_ is getting a hang of haskell, after 1/2 week
11:47:58 <joelr_> instance Binary CommandType where
11:47:58 <joelr_>     put_ bh a = do put_ bh (fromIntegral (fromEnum a) :: Word8)
11:47:58 <joelr_>     get bh = do
11:47:58 <joelr_>              type' <- get bh
11:48:01 <joelr_>              return (toEnum type')
11:48:08 <joelr_> is there a better way to do that put?
11:48:13 <joelr_> or get
11:48:37 <micket> B.t.w i've mean to ask you haskell people this. Just how popular is QuickCheck?
11:48:53 <shapr> For what definition of popular?
11:48:55 <cm> hoohoo
11:48:56 <joelr_> i understand that i can do liftM (get bh) but then it would not be converted to enum
11:48:58 <shapr> hiya cm
11:49:05 <cm> hey shapr
11:49:10 <micket> becuase the introductioncourse im taking in haskell spends roughly half time just for quickcheck
11:49:26 <joelr_> micket: i wanna take that introduction!
11:49:48 <shapr> QuickCheck is the best usable software testing library I'm aware of.
11:49:55 <shapr> Does that help any?
11:51:01 <micket> I just feel its rather pointless most of the time. Sure testing is great and all, but do people spend most time of writing a program into writing quickcheck properties and such?
11:51:07 <micket> joelr_:
11:51:09 <micket> wopps
11:51:21 <micket> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/
11:51:23 <micket> there we go
11:51:24 <droundy> micket: I think it's very popular, and using it involves lots of "interesting" parts of haskell, classes, monads etc.
11:51:29 <joelr_> micket: i have not graduated to that but it's very helpful to do that
11:51:48 <shapr> The most expensive part of real commercial software is finding and fixing bugs.
11:51:57 <droundy> micket: I certainly spend a lot of time writing quickcheck properties (I'm writing an Arbitrary instance right now, in fact)...
11:52:01 <micket> the quickcheck properties i've written doesnt prove shit though
11:52:17 <shapr> But I think droundy has it right, QuickCheck is a small chunk of source that demonstrates lots of Haskell features.
11:52:31 <shapr> micket: Show us your code!
11:52:49 <micket> mm for what?
11:53:01 <shapr> What tests have you written?
11:53:31 <micket> well i had to write something that checked so i evolved the world correctly in the Game Of Life engine i wrote
11:53:33 <micket> for a lab
11:53:50 <shapr> Did it find any problems with your code?
11:53:53 <micket> But in the end, all i did was compare the results to another function..
11:53:55 <micket> No it was fine.
11:54:05 <micket> i just had to becuase they wanted me too.
11:54:14 <joelr_> how do you properly write this:     get bh = toEnum . liftM (get bh)
11:54:20 <shapr> That's funny, QC finds lots of problems with my code.
11:54:42 <micket> but it kinda requiers something true to compare with
11:54:52 <micket> and if you had that, why not use it to start with?
11:54:55 <shapr> From what I've read, most errors are minor corner cases like off-by-one errors and the like. QC finds those well.
11:55:12 <joelr_> i want to get the byte (get bh) and convert that to enum get bh is in the IO monad
11:55:24 <beschmi> joelr_: liftM toEnum $ get bh
11:55:40 <micket> my quickcheck property worked with the decreasing probability that i have written the same faulty algorithm twice.
11:55:58 <shapr> That's not a very good test.
11:56:02 <joelr_> beschmi: thanks
11:56:09 <micket> exactly.
11:56:15 <micket> But its what they wanted to see.
11:56:24 <shapr> I don't think so.
11:56:26 <micket> How do i check that i evolved the world correctly otherwise?
11:56:33 <joelr_> beschmi: any better way to write this?     put_ bh a = do put_ bh (fromIntegral (fromEnum a) :: Word8)
11:56:41 <shapr> You have to come up with properties that really test something.
11:56:49 <shapr> This happens in commercial software too, choice of test is important.
11:57:06 <shapr> micket: look at this example - http://www.haskell.org/tmrwiki/SoftwareTestingWithHaskell
11:57:23 <micket> I've done alot of other quickcheck properties
11:57:44 <Maddas> QuickCheck is very cool :-)
11:57:44 <micket> along the line of, controlling that a sorted list is as long as the list before
11:58:25 <shapr> Right, those are properties that you know must be correct.
11:58:32 <micket> Yes.
11:58:38 <sylvan> micket, most of the time you're not supposed to test if f == g, you're suppposed to test _properties_ of f (like associativity, or that it always returns a positive value, and things like that)... So find properties which should hold for your function and if they all hold, you've decreased the probability of errors greatly
11:59:11 <micket> But he specifically asked for me to write a quickcheck property that checked that i evolved the world correctly.
11:59:13 <beschmi> joelr_: i don't see see any
11:59:29 <sylvan> testing if f == g is useful though, like if you want to re-implement something more efficiently (using a more complex data structure), then you can compare it to a naive implementation
11:59:33 <joelr_> beschmi: thanks :D
11:59:54 <joelr_> sylvan: i second your motion. that's what refactoring is all about
12:00:37 <joelr_> i think quickcheck should be combined with hunit
12:00:38 <skew> shapr: those look like examples of testing your tests with QuickCheck
12:01:08 <rep> tonight i feel like more
12:01:20 <micket> B.t.w John Hughes is my teacher for this course :P
12:01:31 <Maddas> Cool!
12:01:39 <sylvan> micket, yes, and I co-wrote your next lab =)
12:01:47 <Maddas> haha
12:01:56 * joelr_ wrote a chunk of erlang on jh's message board back in june :D
12:01:58 <micket> I don't have a next lab.
12:02:05 <sylvan> the gnomish mines one
12:02:06 <joelr_> right next to the office dooer
12:02:07 <joelr_> he
12:02:10 <micket> Its done
12:02:15 <micket> mine rocked.
12:02:17 <sylvan> well then, how did you like it =)
12:02:32 <skew> micket: the property you want to check on the world updating is probably the core piece of code in the update, but it is a little bit different
12:02:40 <sylvan> it makes for.. interesting submissions... very open ended..
12:03:11 <skew> that's like, for any board and any coordinates in the board, does the final state match the initial state like it should
12:03:37 <micket> but there is nothing like that i could think of for a game of life
12:03:47 <sylvan> micket, where does it say you should test if the world evolved correctly? I only find where it says you should check that the infariants hold
12:03:56 <sylvan> invariants, even
12:04:04 <sylvan> The number of rows stated matches the actual number of rows.
12:04:04 <sylvan> All the rows have the same length.
12:04:04 <sylvan> The number of columns stated matches the actual number of elements in each row.
12:04:04 <micket> the teacher asked me to.
12:04:12 <sylvan> well that's probably what he meant =)
12:04:21 <sylvan> check that the world is valid after the evolution
12:04:31 <micket> "could you please think of a way to check that you evolve function evolves the world correctly?"
12:04:35 <micket> thats what he wrote.
12:05:11 <sylvan> Well you could always ask him, I don't hink he meant "implement the same thing twice" but rather "try to find properties of a valid world, and make sure no evolutions invalidate a valid world"
12:05:21 <micket> I did say all that in the comments
12:05:40 <micket> and my feelings over its usefullness
12:05:49 <skew> micket: you shouldn't have to implement things twice to check that the update was correct
12:06:05 <micket> all the difference was that i just checked for a single cell.
12:06:19 <micket> But its still the same if's and else in the end.
12:06:26 <micket> just written in a slightly different way.
12:06:36 <skew> except, if you program is so trivial that it's little more than the specification you want to hold
12:06:38 <micket> Oh well, ill just wait and see what he replies to say.
12:06:47 <sylvan> do you check that the number of rows stated always equals the acutal number of rows, etc.
12:06:55 <micket> yes!
12:07:04 <sylvan> hmm.. well.. better ask him what he means then
12:07:25 <skew> micket: If this was C and you were mutating the world in place, getting the ifs and stuff rigth wouldn't help if you were overwriting the state incorrectly
12:07:41 <skew> it's a little harder to mix the new and old worlds when the code is Haskell, granted
12:08:04 <shapr> micket: Think of how you could use QuickCheck in a C or Java program.
12:08:43 <Peach06> I have an app which checks if a number is prime using isPrime <number> .. how can i make it check if numbers 1-100 are prime... tried something along the lines off: isPrime [1..100]
12:08:52 <Peach06> which it obviously didn't like :-/
12:09:03 <skew> Peach06: something from Data.List will do what you want
12:09:16 <micket> Peach map the function over the list.
12:09:22 <skew> @hoogle (a -> Bool) -> [a] -> b
12:09:23 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
12:09:23 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
12:09:23 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
12:09:34 <araujo> Hello here
12:09:37 <skew> hey, they're all in Prelude
12:09:46 <Maddas> skew: Heh, being able to search for type signatures is cool.
12:09:50 <Maddas> Hi, araujo.
12:10:01 <skew> yep!
12:10:14 <skew> Why didn't I get stuff like undefined?
12:10:24 <skew> and unsafeCoerce#?
12:10:43 <Maddas> skew: For your own protection? :-)
12:10:44 <micket> sylvan, btw. did ou do the intelligent tram timetable lab in the end of the course?
12:10:53 <skew> (Peach, those two are almost certainly not what you want)
12:11:01 <sylvan> I didn't write it, but I did implement it way back in the day =)
12:11:06 <sylvan> when I took the course
12:11:35 <skew> @hoogle a
12:11:36 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
12:11:36 <lambdabot> Prelude.atan :: Floating a => a -> a
12:11:36 <lambdabot> Prelude.abs :: Num a => a -> a
12:11:38 <micket> it was rather tricky even though the algorithm sounded pretty easy in my head :P
12:11:48 <skew> @hoogle forall a . a
12:11:49 <lambdabot> Prelude.(^) :: (Num a, Integral b) => a -> b -> a
12:11:49 <lambdabot> Prelude.const :: a -> b -> a
12:11:49 <lambdabot> Prelude.(^^) :: (Fractional a, Integral b) => a -> b -> a
12:12:03 <skew> that's not right
12:12:35 <micket> no?
12:13:56 <sylvan> micket, yes it's quite tricky.. and there are many ways to solve it
12:14:04 <joelr_> is there a function to convert a ByteArray to a [Word8]?
12:14:20 <TheHunter> @hoogle a -> a
12:14:21 <lambdabot> Prelude.log :: Floating a => a -> a
12:14:21 <lambdabot> Prelude.atan :: Floating a => a -> a
12:14:21 <lambdabot> Prelude.significand :: RealFloat a => a -> a
12:14:32 <TheHunter> @hoogle+
12:14:33 <lambdabot> Prelude.signum :: Num a => a -> a
12:14:33 <lambdabot> Prelude.id :: a -> a
12:14:33 <lambdabot> Prelude.abs :: Num a => a -> a
12:15:11 <araujo> Anyone knows if there exist a functiona named 'popen' ?
12:15:18 <skew> I think so
12:15:20 <TheHunter> @index popen
12:15:22 <lambdabot> bzzt
12:15:28 <skew> old hslibs, I think
12:16:07 <micket> sylvan, im using a backtracking method, i'm getting some strange errors right now though
12:16:20 <TheHunter> it is defined in lambdabot's PosixCompat.hs, for example.
12:16:21 <sylvan> backtracking = depth-first search?
12:16:30 <micket> uh?
12:16:35 <micket> depth-first?
12:16:50 <skew> where's the course stuff?
12:16:53 <sylvan> you recurse through the graph?
12:17:11 <sylvan> like, straight recursion with a list of visited nodes?
12:17:24 <skew> I want something little to code, to get unlazy
12:17:27 <micket> itll grow out from the endpoint in all directions
12:17:48 <micket> until it passes under the time when i wanted to start.
12:18:00 <araujo> TheHunter, where can i find the lambdabot sources?
12:18:01 <sylvan> Yes but in which order.. Will it visit neighrou 1, then 2 then 3, or will it visit neighbour 1 and then the neigbours to 1
12:18:06 <TheHunter> @version
12:18:07 <lambdabot> lambdabot 3p99, GHC 6.5 (OpenBSD i386)
12:18:07 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:18:14 <araujo> Thanks
12:18:25 <micket> all at the same time.
12:18:48 <micket> it will grow out routes in all directions from every node
12:18:56 <micket> the only optimization i've done is not to go back
12:19:04 <sylvan> okay..
12:19:13 <araujo> Though it seems like if i already had popen since it doesn't let me compile a function with that very same name.
12:19:22 <TheHunter> araujo, but be careful not to close any handles in the calling program when you use popen.
12:19:43 <micket> skew, did you see the link i posted earlier?
12:19:51 <micket> if you wante something to code
12:20:21 <sylvan> well you could do it "breadth first".. Which basically means you keep a queue of nodes you want to visit, and then at each nodes add the neighbours to the end of the queue, and recurse to the first node in the queue..
12:20:31 <skew> I do now
12:20:42 <sylvan> which should be a lot faster...
12:22:38 <micket> This method isnt actually that slow though..
12:22:57 <sylvan> okay
12:23:08 <sbeyer> hi, is there a profiler for Haskell? (ghc has a ghcprof6 and a -prof option but I don't get them to work)
12:23:16 <micket> even if i take the furthest away with the timetable for all 8 trams i got it it doenst  take half a second to find the route
12:23:48 <micket> but then, 8 timetabls isnt much.
12:23:58 <sylvan> true...
12:24:16 <micket> Im thinking about taking a course in datastructures next period
12:24:24 <micket> ill learn that stuff then :)
12:24:36 <sylvan> do you study at dtek?
12:24:40 <sylvan> or gu?
12:24:41 <micket> I only got a 3 points introduction course in java behind me :P
12:24:47 <micket> Mtek
12:24:50 <sylvan> ah
12:24:57 <micket> just picked up an extra course.
12:25:04 <sylvan> check
12:25:25 <micket> dtek yourself?
12:25:28 <micket> or former
12:25:44 <sylvan> jepp
12:25:50 <sylvan> fourth year
12:25:50 <Lemmih_> sbeyer: rtfm http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
12:26:13 <sbeyer> Lemmih_, thanks ;)
12:27:23 <micket> tell one of the first year students to email me their gnomish mines! i have to comment it!
12:27:26 <micket> ;)
12:29:03 <sbeyer> Lemmih, ah I need the profiling libraries (it's an extra package in Debian)... ;) ok.
12:29:13 <sylvan> I hardly know any of them =(
12:29:33 <micket> my teacher wasnt to happy with the gnomish mines i sent in.
12:29:50 <micket> not a single quickcheck property ;D
12:30:29 <micket> but then there isnt much to it than a argument parses and the ability to pick up and leave objects
12:32:16 <shapr> You'd be surprised.
12:32:34 <shapr> Buffer overflows in C are all about parsing an argument... badly.
12:33:25 <shapr> There's also another kind of QC property that's rarely used. I'm not sure if it has a real name but you could call it 'predicted failure' or 'safe failure.'
12:33:30 <Korollary> or receiving it badly
12:33:57 <shapr> For any input that is unacceptable, react predictably.
12:34:09 <shapr> Buffer overflows are not a good way to fail.
12:36:29 <Philippa_> "graceful failure" is the usual term I hear
12:36:30 <ValarQ> shapr: does that mean you will beat me with a LART when i import gets with FFI?
12:36:51 <Philippa_> or more generally, graceful degradation - you don't make more of the system fall over than you have to
12:37:12 <Philippa_> you better have a damn good excuse for it :-)
12:38:00 <xerox> Alien invasion!
12:38:05 <Korollary> not caring ?
12:38:15 <Philippa_> not sufficient
12:38:19 <shapr> ValarQ: Hey, it's your code :-)
12:39:54 <ValarQ> shapr: well, i don't think i dare anyway
12:40:14 <ValarQ> shapr: it actually is a bit scary...
12:41:04 <ValarQ> and i'm starting to get the hang of haskells own io functions
12:42:23 <ValarQ> once i understood how to handle that IO thingie stuck to my data it gets much easier
12:42:31 <ValarQ> s/gets/got/
12:43:20 <shapr> Yeah, I agree.
12:45:35 <ValarQ> my code actually ended up much simpler and shorter than i thought it would once i got it right
12:45:46 <ValarQ> a welcome surprise :)
12:50:33 <shapr> Yeah, I like that about Haskell.
12:52:17 <gzl> using C after Haskell is painful
12:53:43 <skew> using almost anything after Haskell is painful
12:54:14 <astrolabe> Is it a good idea to abstract out pure functions even in a procedural language?
12:54:47 <Oejet> The Haskell road leeds to pain...
12:54:54 <sethk> astrolabe, as a rule probably but every situation is different
12:54:55 <ulfdoz> lol
12:56:12 <gzl> skew: C more than most.
12:56:37 <skew> I don't know, C makes an okay DSL for banging on raw memory
12:57:16 <skew> pretending it's a general purpose language is bad whether you've ever heard of Haskell
12:58:59 <Philippa_> IMO a good DSL still needs better abstraction facilities than C has
12:59:12 <shapr> Silly question, how can I make a list (really Data.Graph) of typeclass instances?
12:59:42 <Philippa_> now? Wrap them in an (isomorphic to) existentially quantified datatype
12:59:48 <Philippa_> later? Boxy types and exists.
13:00:03 <ValarQ> Oejet: lol
13:02:29 <ValarQ> Oejet: i looked on a webpage that sells books for a haskell book today, i found one and on the page there was a note saying that people who bought that book also bought some book called "the paincarrier" (rough translation)
13:04:21 <Oejet> ValarQ: Heheh.
13:04:31 * Philippa_ sniggers
13:05:05 <Philippa_> haskell's rare enough still that it doesn't take much to give a bookseller a link between it and (say) BDSM
13:05:41 <Philippa_> hell, the only reason I've not contributed to that one myself is I've never bought a book on Haskell
13:05:48 <ValarQ> Philippa_: yeah, i know, i found it somewhat amusing anyway :)
13:05:49 <Cale> heheh
13:06:11 <Philippa_> could it have been a translation of "the [new] bottoming book"?
13:06:32 <Philippa_> (it'd be a fairly lousy translation if that's how it translates back, but hey)
13:06:47 <ValarQ> here it is: http://www.adlibris.se/shop/product.asp?isbn=0201342758&mscssid=V8246KFRXBMV8HN1P8NJ75FHSU8533T7
13:07:00 <ValarQ> Philippa_: translate it yourself :)
13:07:14 <astrolabe> I don't know if it is permanent, but there is now a #haskell-overflow channel
13:08:09 <astrolabe> I think I could write 'The cruft of functional programming'
13:08:19 <Philippa_> heh
13:08:24 <Philippa_> astrolabe: it's permanent
13:08:34 <Cale> Philippa_: QuotesPage'd
13:08:35 <Philippa_> OTOH, the joke's pretty much done...
13:12:15 <astrolabe> If I use //, is a whole new array created in memory?
13:12:32 <Cale> astrolabe: depends on the kind of array
13:12:45 <Cale> If it's an Array, then yes.
13:13:12 <Cale> If it's something like a diff array (Data.Array.Diff), then no.
13:13:30 <astrolabe> Thanks, that's what I wanted to know.
13:14:29 <Cale> Diff arrays are a very clever trick :)
13:15:45 <ValarQ> Cale: checked them out when you mentioned them, sounds like a neat thing
13:17:39 <astrolabe> ValarQ: Where are they described?
13:17:41 <Cale> Yeah, more people should be aware of diff arrays, because they make certain runtimes for algorithms easier to obtain without the use of, say the ST monad.
13:17:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.Diff.html
13:17:52 <astrolabe> Ta
13:18:10 <Cale> just ignore newDiffArray, readDiffArray and replaceDiffArray
13:18:33 <astrolabe> ok
13:18:45 <Cale> you don't need to use those unless you're making a specialised instance of the immutable array interface.
13:19:22 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.IArray.html defines all the useful the operations
13:19:26 <Cale> er -the
13:19:59 <Cale> (hehe, editing your message after typing it is dangerous)
13:21:04 <astrolabe> What does 'current' mean in 'Updating an array which is not current makes a physical copy'?
13:22:42 <Cale> Well, when you update a diff array, all the old versions may still be accessible
13:23:24 <Cale> All the operations here are referentially transparent
13:24:19 <astrolabe> Cale: I thought I understood that bit, but if current means that it might get used again, then why not overwrite rather than copy?
13:24:35 <Cale> current means the most recently updated version
13:24:56 <Cale> Order-of-evaluation-wise
13:25:10 <astrolabe> Ah, thanks.
13:26:04 <Cale> Order of evaluation can be somewhat tricky to predict of course, this being a lazy language.
13:27:20 <Cale> But, if you use the diff array in a single threaded manner - only ever using a given version of the array in one place, then you don't have to worry about it :)
13:27:31 <astrolabe> So, is there an array type which leaves the original fixed, and just stores the updates?
13:27:45 <Cale> That could be done
13:28:26 <CosmicRay> Let's say I'm writing a program that reads a binary file in 512-byte blocks.  These blocks contain fixed-width character fields.  What would be the most logical type to use to store the result of my I/O in?
13:29:20 <Cale> CosmicRay: some record type involving strings and WordN's?
13:29:46 <CosmicRay> so I should have a function, say, getBlock that would be Handle -> IO [Word8] perhaps?
13:30:02 <Cale> CosmicRay: that seems sensible enough
13:30:09 <CosmicRay> ok.
13:31:02 <CosmicRay> next question: what is the best way to extract the fixed-length fields out of this [Word8]?  Obviously random indexing is inefficient.  And in the past, I've done things like a whole slew "let (var, xs') = splitAt n xs" sort of things, but that gets ugly fast.
13:31:04 <Cale> But if you're going to do further processing, and you know how the fields are laid out, why not split up the [Word8] into those fields.
13:31:20 <CosmicRay> yes, I'm just trying to think of the best way to do that.
13:32:04 <Cale> CosmicRay: You might have a look at the Packet class that I wrote for Joel
13:32:12 <CosmicRay> got a url?
13:32:29 <Cale> it's on the mailing list, hang on
13:34:16 <Cale> http://article.gmane.org/gmane.comp.lang.haskell.cafe/8115 -- that version is fairly rudimentary - Joel's been extending it, but I don't have his version
13:35:26 <Cale> you may also consider replacing concatBits with something faster, but this will speed things up by at most a constant factor.
13:35:44 <CosmicRay> that looks very interesting and I would be interested in including it in MissingH.
13:35:56 <Cale> go for it
13:35:58 <Cale> :)
13:36:25 <CosmicRay> however, it doesn't really address my particular problem.  I'm fine with getting every field as a [Word8], but the problem is -- with both this approach and splitAt -- the pesky issue of how to handle the "rest" of the list that is returned at each step.
13:37:08 <Cale> you could invent a parsing monad
13:37:16 <jyp> I must be cursed...
13:37:18 <jyp> Compiling Main             ( Main.hs, Main.o )
13:37:18 <jyp> Linking ...
13:37:18 <jyp> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
13:37:18 <jyp>         expectJust upsweep_mod:old_linkable
13:37:41 <jyp> ... the impossible happens so often :/
13:37:46 <Cale> really, it's not even a full parsing monad if everything always succeeds
13:37:56 <CosmicRay> Cale: hmm, wouldn't that be tricky if there's already a list monad?
13:37:59 <Cale> (and has only one possible parse)
13:38:05 <CosmicRay> well, you could attempt to take more data than is available.
13:38:16 <jyp> This is compiling jhc... any clue JohnMeacham?
13:38:19 <Cale> yeah, there is that kind of failure I suppose
13:38:36 <jyp> ... btw your previous advice worked
13:38:42 <Cale> It's just a particular state monad.
13:39:25 <Cale> note that the type of readPacket is the type of a state transformer
13:39:49 <Cale> the initial state is the full string, and it's cut down as the computation proceeds.
13:40:03 <CosmicRay> hmm.
13:40:11 <araujo> There is apparently a Posix.popen function, nevertheless, i can't find anything about it in the standard library.
13:40:14 <CosmicRay> I guess I ought to read up on those.
13:40:28 <araujo> Unless it is ghc extension, anyone knows about this?
13:40:49 <CosmicRay> araujo: let me check
13:42:46 <araujo> Thanks CosmicRay
13:43:42 <CosmicRay> araujo: GHC does not have pOpen in its library directly.  However, it does have enough in it so that you can build your own without having to write any code in C.  I have done so in MissingH.Cmd, where you can find a pOpen and pOpen3.  http://quux.org/devel/missingh/html/MissingH.Cmd.html
13:44:59 <Cale> class Packet a where
13:45:00 <Cale>     readPacket :: (MonadState [Word8] m) => m a
13:45:05 <Cale> you could also do it like that
13:45:36 <CosmicRay> obviously time for me to crack out "What the hell are Monads" again ;-)
13:45:43 <araujo> CosmicRay, Ok, thanks, i'll take a look
13:45:58 <CosmicRay> araujo: code at http://darcs.complete.org/missingh/MissingH/Cmd.hs
13:46:11 <Cale> In fact, allow me to rewrite Packet.hs with that concept. It'll also contain my "more efficient" (untested claim) version of joining Words
13:46:15 <araujo> Thanks
13:46:59 <Oejet> CosmicRay: Just an uninformed suggestion; how about parsing the records and fields directly and let the compiler fiddle with the IO buffer size?
13:48:48 <CosmicRay> Oejet: This is for an implementation of tar, so the buffer size is important to the underlying OS -- and also to extracting data.  You parse the header, then you have to read n buffers and discard any data greater than the size of the file given in the header.
13:49:11 <skew> Oejet: that requires mixing in the code for grabbing more data into the reading code
13:49:24 <skew> At least, if you are talking about using read directly
13:49:25 <CosmicRay> that too, or implementing lazy binary I/O
13:49:51 <CosmicRay> Oejet: tape devices are very sensitive to size of I/O blocks.
13:49:53 <skew> you could probably write it to work a against a Ptr into the data
13:50:03 <CosmicRay> skew: yeah but that is ugly
13:50:12 <CosmicRay> skew: if I do that, I might as well just use libtar in C ;-)
13:50:25 <skew> not if you wrap all that up in some monad
13:50:58 <skew> it might be neat to have the typeclass add up the size of things and defer as many checks as possible on whether you still have more data
13:56:16 <Oejet> CosmicRay: Do you have a quick pointer for the specification of tar?
13:56:23 <Cale> vx.hn.org/autoshare/Packet.hs
13:56:31 <Cale> CosmicRay: there's the monadic version
13:57:06 <Cale> I cheated a bit in order to reuse code that I'd already written, though
13:57:15 <Cale> it's quite possible to clean things up a bit
13:58:03 <araujo> CosmicRay, i just checked, and it seems like i do have POpen in hslibs-import
13:58:43 <micket> what program do you all use to code in?
13:58:51 <Cale> CosmicRay: if you want to handle failure more elegantly, that's also possible, if we extend things a bit
13:58:55 <shapr> emacs, until Yi is ready!
13:59:03 <Cale> emacs and vim
13:59:04 <Lemmih> emacs, until hIDE is ready!
13:59:10 <SamB> hmm, apt is giving me something about needing to temporarily remove an essential package (specifically e2fsprogs) in order to install libgtksourceview-dev...
13:59:23 <Cale> and yeah, only until hIDE/yi are ready :)
13:59:45 <micket> i got stuck with gedit for this lab (its due today and i didn't have time to learn vim)
13:59:54 <micket> its.. not so good...
14:00:07 <Cale> CosmicRay: checking that out? If you need some examples of how to use that new code, I can help
14:00:08 <micket> :/ doesn't even show columns! oh well
14:00:48 <shapr> CosmicRay: What's the OCaml intro you suggest?
14:01:15 <shapr> A friend of mine is learning OCaml.
14:01:52 <skew> do they know Haskell?
14:02:30 <Cale> shapr: I think that perhaps similar edits to multiple pages on the wiki should be controlled.
14:02:52 <shapr> skew: Nope, coming from C/C++
14:03:03 <Cale> It might be irritating when adding a new category though.
14:03:44 <kolmodin> shapr: you might want to have a look at this, a ~100 pages introduction: http://www.cs.caltech.edu/courses/cs134/cs134b/book.pdf
14:03:46 <skew> but if you leave an exemption you get CategoryBuyCheapViagra sprining up all the time
14:04:08 <shapr> kolmodin: Thanks, I'll suggest that.
14:04:32 <skew> I've taken that class - it might be ok
14:05:07 <Cale> skew: heh
14:05:19 <skew> it looks OK
14:05:34 <skew> the professor can be a bit disorganized
14:06:05 <skew> and also seriously underestimate the problems he assigns
14:06:41 * SamB supposes he doesn't need e2fsprogs while he isn't rebooting...
14:07:10 <kolmodin> skew: aren't they all? :) present professors excluded, of course
14:07:11 <beschmi> shapr: there is also http://www.ocaml-tutorial.org/ and the translated oreilly book
14:07:47 <shapr> Thanks, that's what he's trying now.
14:09:21 <skew> Well, once in an algorithms class he asked for a time complexity that had only been attained in a preprint a month or so old
14:09:25 <sethk> SamB, worst case, you can always boot a live cd with e2fsprogs on it, to recover any file systems and make the system boot
14:10:04 <sethk> SamB, so I wouldn't get paranoid about temporarily removing it
14:10:21 <SamB> sethk: yeah, I figured the same... it just upgraded libc...
14:11:28 <shapr> skew: That's definitely challenging.
14:11:36 <skew> Another time, when asked about one of his problems he looked at it a bit and said "Oh, that's harder than it looks", and never managed to solve it himself, IIRC
14:11:38 * SamB wonders why it is displaying time-zone related info
14:12:01 <shapr> heh
14:12:07 <skew> A few students managed both times, though.
14:12:16 <Cale> skew: that's not as bad as this exam I saw for an algorithms course at Waterloo, which requested an algorithm to do some graph-related task (can't recall what it was) with a runtime which it is currently an open problem whether it can be attained.
14:12:31 <Cale> (And provided a misleading hint at that :)
14:12:49 <skew> I'm not sure you can say the same about the time he asked for an argument "why P is not equal to NP"
14:13:13 <skew> Cale: did anybody manage that?
14:13:36 <SamB> okay, apparantly it has installed the new e2fsprogs
14:13:37 <Cale> skew: no, I don't think so. It was removed from marking.
14:13:48 <SamB> now its unpacking a new kernel image...
14:14:11 <SamB> no, I don't have any idea why I need to upgrade my kernel to install libgtksourceview-dev
14:15:25 <SamB> hmm, apparantly I have to reboot soon because its the same version as before and its messing up the module list...
14:15:29 <skew> Aww. I remember a note in some math book after a proof about how the original proof was a lot uglier, and present one was provided on an exam by a student who had missed the day they proved the theroem in class
14:15:42 <shapr> haha
14:15:56 <SamB> heh
14:17:21 <araujo> I remenber one similar note, about a stude who fell asleep in a math class, and the professor had wrote in the blackbord a problem who nobody had been able to solve, when the student woke up thouth the problem was homework, and he worked out and solved the problem in a week
14:17:57 <shapr> I think the lesson here is that often we make our own limitations.
14:18:02 <araujo> yup
14:19:22 <SamB> okay, time to reboot I guess...
14:19:30 <SamB> bye bye!
14:19:43 <shapr> I went to school in California for six months. The teachers put me between two highly irritable kids. I did just slightly better than these two kids because I wanted to fit in. At the end of six months, my teachers gave me a trophy, they'd put me between the two best kids in the school, and hadn't told me about it.
14:20:27 <araujo> :-]
14:22:29 <kolmodin> g'night
14:22:34 <xerox> Goodnight kolmodin
14:22:40 <skew> I think that's why some of these things are put on exams
14:23:21 <skew> There's some famous theorem that was first proved because it had been given every year as a question on a big british math contest, some time around 1900
14:23:39 <skew> or at least relatively useful in combinatorics
14:26:15 <Maddas> shapr: Heh, impressive
14:27:28 <CosmicRay> Lars Wirzenius has a similar story about Linus Torvalds at http://liw.iki.fi/liw/texts/linux-anecdotes.html
14:27:46 <CosmicRay> "I remember once when we were being questioned about some math home work. I happened to know Linus hadn't done it. But bold as he was even then, he claimed to have done them anyway. As luck would have it, the teacher wanted Linus to present his solution to the class. On the way to the blackboard, Linus read the problem, then stood in front of the board for a second or two, and went on to present a solution that the teacher could
14:27:46 <CosmicRay> n't understand. Linus can be quite annoying like that."
14:29:26 <sethk> I used to annoy my circuits class professor that way.
14:29:33 <sethk> I'd look at the circuit and say 1.5 volts
14:29:37 <sethk> and I'd have no idea how I knew
14:29:42 <CosmicRay> heh
14:30:01 <sethk> fortunately he wasn't  a "show your work" kind of guy  :)
14:30:26 <sethk> I'd say well, obviously, the same amount of current will go there and there
14:30:31 <shapr> I call it intuitive thinking.
14:30:35 <sethk> and he would just look at me with this strange expression
14:30:51 <sethk> actually, it would be better if I could figure out how I do it.  :)
14:30:58 <Cale> shapr: there's something odd going on with the syntax highlighter on the wiki
14:31:00 <Lor> Now that I've been playing with mechanized logic a bit, I again begin to appreciate how complex stuff we really solve "by intuition".
14:31:06 <Cale> http://haskell.org/hawiki/PacketClass
14:31:33 <Cale> (the "output left in -" message)
14:31:40 <shapr> My approach is to train both my intuitive thinking, and my plodding through each process.
14:31:45 <shapr> I think it takes some of both.
14:31:47 <basti_> i think intuition is way more powerful than any reasoning
14:32:01 <CosmicRay> I had a similar problem with my high school math teacher.  He'd always ask people to show their work.  I'd say, "What work?  It's obvious that the answer is 42."  He also reduced my grade for not taking any notes in class once.
14:32:09 <basti_> but reasoning gives better, and justified quality.
14:32:10 <Cale> intuition and reasoning have to work together
14:32:15 <basti_> yep
14:32:17 <shapr> I believe intuition is reasoning, just not at the same level.
14:32:19 <sethk> basti_, I think it _is_ reasoning
14:32:24 <basti_> :/
14:32:27 <Cale> this is well-known to anyone who plays go :)
14:32:35 <CosmicRay> Cale: or chess? ;-)
14:32:37 <Cale> or does mathematics :)
14:32:50 <basti_> actually i think this is a semantics problem now
14:32:55 <Cale> chess I wouldn't know, but I assume so :)
14:32:59 <shapr> Nah, it's not a semantics problem...
14:33:07 <basti_> i mean what intuition is
14:33:32 <basti_> sometimes i can combine "intuition" and reasoning
14:33:48 <shapr> I read a recent article about a statue subjected to lots of scientific tests, and all of them said it was authentic. Five art experts looked at it, and decided it was a fake in five seconds.
14:33:50 <basti_> but then its not pure intuition, its just a lucky stroke or something
14:33:53 <astrolabe> I think intuition can use induction from some examples though.  Things should be proved when possible.
14:34:09 <sethk> Cale, actually, I think chess is different.  I'm not particularly good at it, for one thing.  :)
14:34:18 <shapr> I think intuition is higher order reasoning of some sort.
14:34:24 <basti_> btw. theres #blah for that! :P
14:35:21 <astrolabe> Maybe intuition is just the word for things we think are true, but we don't know why we think it.
14:35:23 <basti_> shapr: i think the higher order thing is when you manage to combine reasoning and intuition.
14:35:24 <CosmicRay> Cale: when you have your new Packet, would you mind e-mailing me the code?  jgoerzen at complete . org  please make sure to say what license it's under and include a copyright statement
14:35:30 <shapr> Cale: Something's wrong with the enscript plugin... not sure what.
14:35:39 <Philippa_> intuition is the things your brain knows how to pattern-match on without having to think
14:35:47 <shapr> Right, that!
14:35:49 <Cale> CosmicRay: http://haskell.org/hawiki/PacketClass
14:36:24 <shapr> Higher order pattern matching, sometimes enough pieces fit together that you just know something.
14:36:25 <CosmicRay> oh.  nice.
14:36:31 <Cale> Intuition is the controlled use of emotion for problem solving.
14:36:31 <basti_> i strongly believe theres two kinds of thought: reductionistic/rational/verbal and holistic/intuition/emotional
14:36:42 <astrolabe> Phillipa: or maybe there are other thinkers inside your brain.
14:36:42 <CosmicRay> Cale: care to give me a license&copyright?
14:36:54 <Cale> okay
14:37:22 <Philippa_> astrolabe: nah, I had the experience of perceiving them once
14:37:35 <Philippa_> they were just firing out something closely related to what I was "consciously" thinking
14:37:40 <Philippa_> my head was, er, echoey...
14:37:56 <CosmicRay> dammit.  I can't find a reference on the tar file format.  grr.
14:37:57 <Philippa_> (had just started on tricyclic antidepressants, 'nuff said)
14:37:58 <basti_> Philippa_: "gedankenlautwerden"
14:38:11 <astrolabe> philippa: How come?  drugs.  Ah I see.
14:38:29 <basti_> pretty common though... no need to worry... time to worry is, when the voices start to insult you ;)
14:38:33 <astrolabe> But that doesn't mean there aren't others in there too.
14:38:47 <Philippa_> they felt much the same as the 'voice' of my conscious (verbal) thoughts (I also sometimes think in eg graphs)
14:39:09 <Philippa_> no, but I've... shall we say empirical evidence that they appear to be a) faster and b) specialised
14:39:45 <CosmicRay> and it's amazing how many sites out there are plagiarizing wikipedia.
14:39:51 * Maddas agrees
14:40:02 <astrolabe> I suppose the verbal ones only need a simple channel to be overheard.
14:41:36 <Cale> there you are :)
14:41:46 <Philippa_> btw, it's worth noting that the tricyclics are /not/ hallucinogens
14:42:18 <SamB> what is all this talk about tricycles?
14:42:22 * basti_ laughs
14:42:29 <shapr> unicycles!
14:42:29 <SamB> I thought we were all about unicycles!
14:42:32 <Maddas> Unicycles are *so* 19th century!
14:42:38 <Maddas> Tricycles, the wave of the future!
14:42:40 <Maddas> ;-)
14:43:16 <Cale> I-cycles!
14:43:42 <Maddas> Heh.
14:44:11 <basti_> SamB: tricyclics are the wood-hammer of phsychopharmacology.
14:46:02 <SamB> okay, why might ghc complain about not being able to find package plugins-0.9.8 when it is installed and there aren't any -ignore-package options in its command line?
14:46:27 <basti_> do you have exactly one version of ghc installed?
14:47:07 <SamB> basti_: unless apt decided it needed another one, yes!
14:47:24 <basti_> (potential error source)
14:47:43 <Lemmih> Old interface files could also have caused it.
14:47:44 <basti_> then there were always issues with that, somehow. i remember having that once or twice
14:48:58 <Maddas> Hm. How 'far' does laziness go? For example, if I do: head $ filter (isJust . snd) foo -- will only the first element matching the filter be evaluated?
14:49:07 * SamB tries rebuilding hs-plugins...
14:49:17 <tibbetts> I'm finding myself writing a few lines of code like "sequence (map (uncurry assertBool) (zip (map show values) (map isval values)))". Is there an idiom I'm missing that would let me drop the uncurry and zip?
14:49:19 <Maddas> Ah, I guess.
14:49:39 <SamB> tibbetts: zipWith?
14:49:50 <basti_> Maddas: it is maximally lazy, i think
14:50:01 <Maddas> Right. Thinking about what would happen when applying an infinite list made it clear :-)
14:50:04 <tibbetts> zipWith would do it, at least for two argument functions, which is most of it.
14:50:04 <SamB> that would take care of the map, too ;-)
14:50:33 <SamB> @type zipWith
14:50:34 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
14:50:35 <SamB> @type zipWith3
14:50:37 <SamB> @type zipWith4
14:50:37 <lambdabot> forall d c b a. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
14:50:38 <SamB> @type zipWith5
14:50:38 <lambdabot> bzzt
14:50:39 <lambdabot> bzzt
14:50:48 <SamB> hmm, only up to 3?
14:50:53 <tibbetts> Oh, ok. :)
14:51:04 <Lemmih> @type List.zipWith4
14:51:05 <lambdabot> forall e d c b a.
14:51:05 <lambdabot> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
14:51:06 <tibbetts> yeah, only 3 in ghci at least.
14:51:36 <tibbetts> Ah, List.zipWithN exists up to N = 7.
14:51:37 <SamB> oh, you can import more from Data.List
14:51:42 <SamB> @type Data.List.zipWith4
14:51:44 <lambdabot> forall e d c b a.
14:51:44 <lambdabot> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
14:51:46 <SamB> @type Data.List.zipWith5
14:51:48 <lambdabot> forall f e d c b a.
14:51:48 <lambdabot> (a -> b -> c -> d -> e -> f)
14:51:48 <lambdabot> -> [a]
14:51:48 <lambdabot> -> [b]
14:51:48 <lambdabot> -> [c]
14:51:50 <lambdabot> -> [d]
14:51:50 <SamB> @type Data.List.zipWith6
14:51:52 <lambdabot> -> [e]
14:51:54 <lambdabot> -> [f]
14:51:56 <lambdabot> forall g f e d c b a.
14:51:58 <lambdabot> (a -> b -> c -> d -> e -> f -> g)
14:52:00 <lambdabot> -> [a]
14:52:01 <tibbetts> I'm sensing a trend.
14:52:02 <lambdabot> -> [b]
14:52:04 <lambdabot> -> [c]
14:52:06 <lambdabot> -> [d]
14:52:08 <lambdabot> -> [e]
14:52:08 <Maddas> tibbetts: :-)
14:52:10 <lambdabot> -> [f]
14:52:12 <lambdabot> -> [g]
14:52:15 <shapr> oj
14:52:17 <SamB> okay, I will now stop
14:52:38 * basti_ sighs.
14:52:40 <ulfdoz> Should someone else continue? :)
14:52:44 <SamB> it looks like they only go up to 7
14:52:48 <basti_> please.
14:53:43 <SamB> anyway, most likely more than you would ever actually want to use ;-)
14:54:53 <SamB> I do not think I have even used zipWith3 yet ;-)
14:55:53 <Lemmih> @type let zipWithN n = [| \f x -> $( g (n-1)) (map f x) |]; g 0 = [| id |]; g n = [| \x y -> $(g (n - 1)) (zipWith ($) x y)|] in zipWithN
14:55:54 <lambdabot> bzzt
14:56:04 <ulfdoz> But I'm sure, you accidently implemented it somewhere.
14:56:30 <SamB> Lemmih: you aren't allowed to use TH in @type anymore
14:56:40 <SamB> there was a potential exploit
14:56:47 <Lemmih> I know.
14:56:48 <shapr> No potential about it.
14:56:52 <micket> I used (a,b,c,d) for the lab im working on now..
14:56:53 <micket> i regret it.
14:56:54 <SamB> okay, an actual exploit ;-)
14:57:22 <SamB> I myself got lambdabot to print /etc/passwd to the channel
14:57:52 <Maddas> Hm, is there any concise syntax for pointfree deconstruction/matching of arguments?
14:58:30 <SamB> @pl (\x y z-> x + y * z)
14:58:31 <lambdabot> (. (*)) . (.) . (+)
14:58:40 <SamB> no
14:58:51 <Maddas> Ok
14:59:11 <ski> Maddas : do you mean like either :: (a -> o) -> (b  -> o) -> (Either a b -> o)  ?
14:59:11 <SamB> its all ugly and incomprehensible when you go past one or two args ;-)
14:59:34 <Maddas> Oh, just one argument will do -- e.g. matching against a constructor
14:59:38 <SamB> @pl (\(x, y) z-> x + y * z)
14:59:39 <lambdabot> uncurry ((. (*)) . (.) . (+))
14:59:44 <Maddas> Just a pointfree case statement, I guess :-)
14:59:44 <ski> @type maybe
14:59:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:59:54 <basti_> pointless
14:59:59 <SamB> @pl ((Foo x y) z -> x + y * z)
15:00:00 <lambdabot> (line 1, column 14):
15:00:00 <lambdabot> unexpected ">"
15:00:00 <lambdabot> expecting variable, "(", operator or ")"
15:00:10 <Maddas> ski: Right, but it's a custom data type, so isNothing and isJust (etc.) won't do
15:00:12 <SamB> @pl (\(Foo x y) z -> x + y * z)
15:00:13 <lambdabot> (line 1, column 8):
15:00:13 <lambdabot> unexpected "x"
15:00:13 <lambdabot> expecting operator or ")"
15:00:35 <SamB> @pl (Nothing -> 1)
15:00:37 <lambdabot> (line 1, column 10):
15:00:37 <lambdabot> unexpected ">"
15:00:37 <lambdabot> expecting variable, "(", operator or ")"
15:00:40 <ski> Maddas : you could add something similar to maybe, or either ..
15:00:41 <SamB> @pl (\Nothing -> 1)
15:00:42 <lambdabot> const 1
15:01:10 <ski> hmm
15:01:27 <Maddas> Hmm
15:01:27 <SamB> you basicly have to get used to points ;-)
15:01:35 <Maddas> Thanks :-)
15:02:10 <ski> MORE POINTS
15:03:09 * shapr shoots, shapr scores!
15:03:31 <CosmicRay> is there a String -> Int where the String is given in octal instead of decimal?
15:03:32 <dcoutts> dons, LGPL also means that JaffaCake could contribute
15:04:05 <dcoutts> @seen dons
15:04:06 <lambdabot> dons is in #haskell. Last spoke 19 hours, 30 minutes and 7 seconds
15:04:06 <lambdabot> ago.
15:04:49 <ski> @eval read "0o13" :: Int
15:04:51 <lambdabot> 11
15:04:57 <CosmicRay> ah.
15:04:57 <shapr> bah, ski beat me to it.
15:05:07 <shapr> I should give in to sleep.
15:05:12 * ski grins
15:05:48 * ski should soon, too
15:05:49 <CosmicRay> Hugs.Base> (read "0o10")::Int
15:05:50 <CosmicRay> Program error: Prelude.read: no parse
15:06:02 <ski> hm,hm
15:06:03 <shapr> http://66.249.93.104/search?q=cache:P0Ev4ApK9loJ:www.haskell.org/onlinereport/lexemes.html+haskell+octal&hl=en
15:06:13 <shapr> Section 2.5, numeric literals
15:06:21 <CosmicRay> shapr: yeah but that is in a haskell program.
15:06:28 <CosmicRay> I'm talking about in a string I've read from who-knows-where.
15:06:29 <shapr> http://www.haskell.org/onlinereport/lexemes.html#sect2.5
15:06:49 <shapr> Why would it work any differently?
15:07:03 <CosmicRay> I don't know, but see that read exmaple I just posted.
15:07:54 <CosmicRay> I would have expected it to return 8.
15:08:30 <shapr> Works fine in GHCi.
15:08:46 <Igloo> I think there's such a function in Numeric. I'm sure you can at least show in random bases
15:09:12 <CosmicRay> Igloo: indeed there is.  thanks.
15:09:19 <Igloo> dcoutts: Did JaffaCake say that?
15:09:51 <CosmicRay> although it's not quite that simple, hmm.
15:10:16 <dcoutts> Igloo, well he can't contribute to GPL projects
15:10:37 <Igloo> That doesn't imply what you said, though  :-)
15:11:05 <SamB> @plugs 0010
15:11:07 <lambdabot> 10
15:11:07 <dcoutts> Igloo, it's what I gathered from a discussion
15:11:12 <CosmicRay> Numeric> (fst . head $ (readOct "10"))::Int
15:11:12 <CosmicRay> 8
15:11:14 <CosmicRay> there we go.
15:11:14 <Igloo> OK
15:11:16 <SamB> @plugs 0o010
15:11:18 <lambdabot> 8
15:11:28 <CosmicRay> that was more complicated that it should have been.
15:11:52 <SamB> @plugs read "0o10" :: Int
15:11:53 <lambdabot> 8
15:12:37 <dcoutts> Igloo, but true, he didn't say it explicitly. It'd be worth checking. I think he might not be able to contribute to an LGPL'd module. But writing stuff that links to it that's under another license is ok.
15:12:43 <thedward> http://www.haskell.org/pipermail/nhc-bugs/2004-May/000441.html
15:12:53 <thedward> (regarding hugs reading octal/hex)
15:14:28 * Lemmih would love to use a BSD style license for hIDE.
15:14:48 <dcoutts> Lemmih, you can use any license you like for the modules you write
15:15:14 <SamB> yay BSD3
15:17:13 <dcoutts> Lemmih, so what was the issue exactly with latency & threads?
15:17:23 <sethk> 6 to 6 in the 16th inning houston
15:17:25 <dcoutts> Lemmih, what seems to work less well when not using -threaded?
15:18:14 <Lemmih> dcoutts: Try holding the space bar down.
15:18:31 <dcoutts> Lemmih, ok will do
15:18:32 <metaperl> dang, anyone want to discuss the Clean versus Haskell results in the language shootout: http://shootout.alioth.debian.org/benchmark.php?test=all&lang=clean&lang2=ghc&sort=fullcpu
15:21:59 <Maddas> Nifty, Haskell entries are always shorter
15:23:07 <Maddas> Oh, never mind,
15:23:43 <basti_> metaperl: ghc compiled programs are memory hogs.
15:23:57 <metaperl> basti_: Clean fared worse on memory usually
15:24:08 <metaperl> but Clean was faster in all 10 cases
15:24:25 <metaperl> I blogged my concern here: http://sequence.complete.org/node/119
15:24:41 <basti_> I'm too dumb to read the diagram
15:24:52 <basti_> then
15:25:32 <Lemmih> Micro-benchmarks aren't in touch with reality.
15:25:38 <basti_> that too.
15:25:50 <basti_> and clean is the lucky second imo.
15:25:59 <basti_> its a "get rich quick with FP" scheme from what i can tell
15:26:17 <basti_> (non-free software)
15:26:21 <metaperl> lol @ basti_
15:26:27 <metaperl> oh Clean is not free?
15:26:38 <basti_> you can get the tools for free as in beer
15:26:39 <metaperl> Lemmih: what is a micro-benchmark?
15:26:46 <basti_> but its not free as in freedom iirc.
15:27:00 <basti_> (i tried it a while [with definite WOW results] before i found haskell)
15:27:02 <metaperl> basti_: I dont understand but I'm browsin their site now
15:27:10 <metaperl> WOW, meaning?
15:27:32 <sethk> I thought the clean IDE only runs in windows
15:27:50 <metaperl> it certainly is a prettily designed website, FWIW: http://www.cs.ru.nl/~clean/
15:27:58 <basti_> its about as structured as haskell. It gives a feel of "nothing left to add, nothing that should be taken away"
15:28:15 <beschmi> dcoutts: i'm having the same problem someone (psi?) reported some days ago with the latest gtk2hs + ghc 6.4.1. My program just exits when the onEntryActivate is called. Did you find anything out?
15:28:19 <basti_> and there was a demo program. A jump & run game.
15:28:28 <basti_> as a demo for an FP language.
15:28:35 <basti_> made a rock-solid impression.
15:29:07 <basti_> Clean is licensed under the GNU LGPL, but can be used without the LGPL if bought for â¬495.
15:29:10 <basti_> ah ok
15:29:22 <beschmi> i mean: .. when the onEntryActivate handler is called.
15:30:58 <sethk> yes, the IDE is windows only
15:31:10 <basti_> an url from my uni is 2 clicks away from the Haskell entry in Wikipedia.
15:31:11 <basti_> :D
15:31:41 <basti_> so its not particularly un-free, but not really free either.
15:32:54 <basti_> metaperl: people should include nhc in that shootout.
15:34:24 <metaperl> basti_: is nhc's compiler technology advanced? oh yes, I think they had some heap optimizations or something
15:34:28 <ski> (LGPL)
15:34:43 <ski> (m, oops)
15:34:58 <sethk> hmm, they claim to be the only language with uniqueness typing, and on the same page it says "many new concepts that are now commonly used in the functional language community have been introduced by our group (such as ... uniqueness typing)
15:36:05 <ski> mercury uses uniqueness insts, which serve a similar purpose
15:37:08 <basti_> metaperl: its said to yield better results, memory and time wise.
15:38:42 <metaperl> basti_: *it* being Clean? yes, I pointed out the benchmark results
15:39:12 <humasect> can the encoding of haddock be changed? i can't seem to get japanese comments to come through.
15:39:14 <int-e> ah, clever - they do not say that there are no other solutions to incorporating side effects in a functional language but they make sure sound it like that.
15:39:21 <xerox> Goodnight folks.
15:39:38 <basti_> metaperl: no, nhc compared to ghc. clean might still be a tad better.
15:40:21 <sethk> int-e, they don't advertise the fact that you can get run time type errors, either.
15:40:42 <Maddas> Night, xerox!
15:41:17 <int-e> sethk: err, oops.
15:41:52 <sethk> int-e, which is not to reject their approach, but it seems a bit less than forthcoming
15:43:41 <sethk> All, I've been doing category theory reading, like a good student (although I haven't been a student for 30 years or so), and now I know what a monoid is, but I'm not seeing any relationship between it and monadic programming
15:44:03 <Philippa_> monoid and monads both have some sequence structure to them
15:44:07 <sethk> I see the "laws" correspondence
15:44:09 <Philippa_> it'll be a while before you encounter monads
15:44:22 <sethk> Philippa_, I don't see the sequence implications of the monoid.
15:44:24 <Philippa_> (if you're reading the Pierce book, I'm not sure it includes them at all)
15:44:36 <Philippa_> do you see them in non-commutative monoids?
15:44:56 <sethk> Philippa_, I'll have to read further before I can answer that.  :)
15:44:57 <Philippa_> (some monads're commutative too, with much the same effect)
15:45:15 <sethk> Philippa_, so at this point its "normal" for me not to see the relationship you are saying
15:45:22 <Philippa_> fair enough
15:45:27 <basti_> what is a commutative monad, for example?
15:45:34 <sethk> Philippa_, or at least not totally stupid.
15:45:43 <Korollary> heh, pugs on slashdot again
15:46:01 <JohnMeacham> jyp: what is the issue?
15:46:15 <Philippa_> basti_: the identity monad has at least some commutativity
15:46:28 <basti_> sethk: its not surprising that you don't see the connection.
15:46:42 <basti_> Philippa_: -.-
15:46:43 <sethk> basti_, ok, that's basically what I was asking.
15:46:48 <Philippa_> yeah, there was a post about it on c.l.f a while back
15:47:40 <Philippa_> some of the pre-monad transformer work on combining monads had some examples, IIRC
15:48:01 * shapr stabs top-quoters
15:48:18 <basti_> uhmmm
15:48:25 <Philippa_> you mean top-posters?
15:48:30 <Philippa_> or just people who don't interleave?
15:49:23 <Philippa_> basti_: a 'logging' monad is commutative modulo log output, which is a relevant property for optimisation purposes sometimes to give an example
15:49:35 <Philippa_> (effectively "I don't care about the ordering on this pile of side-effects")
15:49:49 * JohnMeacham blaims outlook.
15:50:08 <Philippa_> the List monad might be, I think the Maybe monad is come to think of it (either it fails sooner or later or it doesn't)
15:50:30 * JohnMeacham knows he has bad spelling.
15:50:40 <basti_> hmmmmh
15:50:52 <SamB> how is hIDE supposed to work?
15:51:33 <basti_> would "commutative" mean that f >>= g  ===  g >>= f or not?
15:51:52 * SamB tries running build.sh
15:51:57 <basti_> autrijus: you have been slashdottet.
15:52:01 * SamB discovers problem with Gtk and hIDE
15:52:10 <metaperl> is there an easy wayto get all the Haskell source here: http://homepages.cwi.nl/~jve/HR/
15:52:12 <autrijus> me?
15:52:17 <Lemmih> SamB: Problems?
15:52:20 <basti_> autrijus: well your homepage.
15:52:23 <metaperl> wget is not working
15:52:33 <SamB> src/Hide/CommonSense/SyntaxHighlight.hs:8:25:
15:52:33 <SamB>     Module `Graphics.UI.Gtk' does not export `AttrOp((:=))'
15:52:43 <autrijus> good because it is down.
15:52:49 <autrijus> triggering redirection.
15:52:49 <Lemmih> Upgrade Gtk2hs.
15:53:13 <SamB> Lemmih: I got the latest release already!
15:53:31 <basti_> ahh
15:54:03 * Korollary optimizes for fun
15:54:10 <astrolabe> Is there a function :: Eq a => (a->a->Bool)->[a
15:54:16 <astrolabe> whoops sorry
15:54:36 <int-e> @type (==)
15:54:38 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:54:46 <astrolabe> Eq a => (a->a->Bool)->[a]->[[a]]
15:55:04 <SamB> Lemmih: and I don't think my gtk2 is recent enough for gtk2hs 0.9.9.5
15:55:09 <astrolabe> nope, let me start again :)
15:55:15 <int-e> @type Data.List.groupBy
15:55:16 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:55:26 <SamB> (which isn't a release)
15:55:27 <astrolabe> O
15:55:32 <int-e> but it might not do exactly what you wand
15:55:33 <int-e> t
15:55:38 <Lemmih> SamB: Tough luck.
15:55:39 <astrolabe> Ah thanks int-e, you read my mind.
15:55:54 <int-e> @eval groupBy (==) [1,1,2,3,4,1,1]
15:55:55 <lambdabot> [[1,1],[2],[3],[4],[1,1]]
15:56:04 <SamB> Lemmih: what am I supposed to do?
15:56:07 <int-e> it maintains the order of the entries of the list
15:56:21 <Lemmih> SamB: Wait for a stable release of hIDE?
15:56:53 <astrolabe> Ah, I don't want the order maintained like that, I want [[1,1,1,1],[2],[3],[4]]
15:57:04 <Lemmih> SamB: hIDE isn't usable so you aren't missing much (:
15:57:34 <likens_> Does anyone have time for a question about installing HaskellDB?
15:57:35 <int-e> astrolabe: sort the list first
15:57:50 <astrolabe> int-e: Why didn't I think of that.
15:58:02 <metaperl> likens_: just ask... if someone knows, they will help
15:58:15 <Korollary> I thought there was a #haskelldb
15:58:32 <likens_> During the build step I see
15:58:32 <Korollary> nope
15:58:35 <likens_> Could not find module `Text.PrettyPrint.HughesPJ':
15:58:35 <likens_>   it is a member of package base-1.0, which is hidden
15:58:35 <likens_>   (imported from src/Database/HaskellDB.hs)
15:58:35 <metaperl> Korollary: no
15:58:45 <basti_> good night
15:58:56 <astrolabe> night basti
15:59:09 <likens_> I'm using 6.4.1 on OS X.
15:59:19 <Korollary> likens_: are you using ghc ?
15:59:27 <likens_> yes
16:00:35 <ski> basti_,Philippa_ : environment/reader monad is also a commutative monad
16:00:43 * SamB has been seeing that error message enough lately to know it is from GHC :-(
16:01:33 <ski> basti_ : i think commutativity for monads would mean that    ma >>= \a -> mb >>= \b -> k a b   =  mb >>= \b -> ma >>= \a -> k a b
16:01:41 <Igloo> The answer might be to add base to the deps in something.cabal
16:02:38 <SamB> Lemmih: so what version of gtk2hs do you have?
16:04:46 <Lemmih> SamB: 0.9.9.5
16:05:27 <likens_> Igloo: don't know how to do that but I tried adding it to the build-depends part of the file and got the same error.  maybe I did it wrong.
16:05:43 <likens_> build-depends: base,
16:05:43 <likens_>                haskell98
16:05:58 * SamB supposes he could try compiling it rather than relying on the info on the site to correctly identify its dependencies
16:06:19 <Igloo> That looks like what I meant. No idea then, sorry
16:07:29 <likens_> Igloo: thanks anyway.
16:34:05 <dons> yow. my harddrive sounds like a lawnmower. that's not good, right??
16:34:33 <ulfdoz> Sounds like IBM.
16:35:21 <ulfdoz> And no, that's not a good sign. :)
16:35:35 <Korollary> especially if it was sounding like that before
16:35:45 <Korollary> s/was/was not
16:36:26 <dons> amazingly, despite this noise, it boots!
16:36:42 * dons furiously backsup any data
16:38:01 * heatsink recommends backing up all data, rather than any data
16:39:20 <dons> I like to take the upper bound of 'any' ;)
16:39:43 <heatsink> :D
16:40:31 <dons> I hope my neighbours don't start banging on my door, telling me to turn off the lawnmower..
16:43:41 <heatsink> "I can't believe the noise these ?"
16:43:48 <heatsink> "I can't believe the noise these kids call music nowadays TURN THAT DOWN!"
16:44:33 <syntaxfree> I can't seem to cons two lists like in lisp.
16:44:38 <syntaxfree> @eval 2:[5..10]
16:44:41 <lambdabot> [2,5,6,7,8,9,10]
16:44:49 <syntaxfree> @eval [1..3]:[10..20]
16:44:50 <lambdabot>  add an instance declaration for (Num [a])
16:44:50 <lambdabot>   In an arithmetic sequence: [10 .. 20]
16:44:51 <dons> @eval [2]++[5..10]
16:44:54 <lambdabot> [2,5,6,7,8,9,10]
16:45:00 <dons> it's the types!
16:45:11 <dons> @type (:)
16:45:13 <lambdabot> forall a. a -> [a] -> [a]
16:45:15 <dons> @type (++)
16:45:16 <lambdabot> forall a. [a] -> [a] -> [a]
16:45:42 <dons> or maybe you mean:
16:45:43 <heatsink> Here's what I think of as consing two lists:
16:45:56 <dons> @eval [1..3] : [10..20] : []
16:45:56 <heatsink> @eval [2]:[[5..10]]
16:45:58 <lambdabot> [[1,2,3],[10,11,12,13,14,15,16,17,18,19,20]]
16:46:00 <lambdabot> [[2],[5,6,7,8,9,10]]
16:46:38 <ski> syntaxfree : collections are homogenous ..
16:46:38 <heatsink> in lisp, ((2) (5 6 7 8 9 10))
16:46:40 <syntaxfree> I don't want that!
16:46:49 <ski> what do you want ?
16:46:54 <syntaxfree> I want [1,2,3,10,11,12,..20]
16:47:02 <int-e> [1..3]++[10..20]
16:47:03 <syntaxfree> I want to concatenate [1..3] and  [10..20]
16:47:03 <ski> @type (++)
16:47:04 <lambdabot> forall a. [a] -> [a] -> [a]
16:47:07 <syntaxfree> ah, thanks!
16:47:12 <syntaxfree> (++) is what I want.
16:47:15 <Lemmih> dons: "System.Plugins.Env.env `seq` ()" segfaults on my box with 6.5
16:47:17 <syntaxfree> Merci beaucoup fish.
16:47:21 <ski> @eval [1..10] ++ [30..35]
16:47:22 <lambdabot> [1,2,3,4,5,6,7,8,9,10,30,31,32,33,34,35]
16:47:26 <syntaxfree> :)
16:47:30 <syntaxfree> thanks everyone.
16:47:38 <ski> syntaxfree : i think that is usually called append in lisps
16:48:04 <Lemmih> dons: (in the call to System.Plugins.ParsePkgConfCabal.parsePkgConf)
16:48:04 <int-e> @eval flip (foldr (:)) [1..3] [5..10]
16:48:07 <lambdabot> [1,2,3,5,6,7,8,9,10]
16:48:11 <dons> Lemmih, oh nice. I'll have a look at it.
16:48:12 <ski> :)
16:50:13 <JohnMeacham> I have not been able to get any hsplugins programs to work on x86-64, are there known problems with it?
16:52:12 <JohnMeacham> by which I mean yi and hIDE.
16:55:00 <dons> hmm, John, what about the testsuite that comes with hs-plugins -- does that run? I'm pretty sure people have built yi on amd64
16:55:26 <dons> how are they not working?
17:06:30 <dons> ah ha! it was the dual fans at the back of the box making all the noise :D
17:06:38 <dons> i hope..
17:06:46 <dons> anyway, no more lawnmower
17:07:09 * Heffalump has an amd64 chroot I can test things in if that helps..
17:09:31 <Lor> Ah, you can do it that way too.
17:09:38 * Lor has an ia32 chroot.
17:10:46 <Heffalump> we weren't brave enough to go for amd64 userland
17:11:55 * Heffalump goes to bed
17:12:13 <Lor> Well, everything works, except those things that don't.
17:12:23 <Lor> (E.g. sml/nj, grumble)
17:12:29 <dons> hehe
17:13:56 <Lor> amd64 is just too cool to ignore. Finally, enough registers to actually _do_ something without meddling with stack all the time.
17:14:06 <Lor> Then again, anything is cool compared to ia32.
17:22:57 <skew> I thought there was a Data.List.merge - where did that go?
17:24:06 * int-e misses that, too. (but I've never seen it)
17:33:39 <TheHunter> union?
17:36:06 <Lemmih> @type Control.Concurrent.mergeIO -- (:
17:36:07 <lambdabot> forall a. [a] -> [a] -> IO [a]
17:43:07 <heatsink> mergeIO === (return .) . (++) ?
17:46:23 <ski> heatsink : i think not
17:46:38 <ski> note "Control.Concurrent"
17:47:06 <heatsink> yes, but there's only one monad there.  How can you execute one monad concurrently?
17:47:10 <dons> nuh.. if only it was that easy.
17:47:14 <heatsink> *one monadic computation
17:48:14 <dons> ...    let
17:48:14 <dons>     buff = (tail_list,e)
17:48:14 <dons>    in
17:48:14 <dons>     forkIO (suckIO branches_running buff ls) >>
17:48:15 <TheHunter> this mergeIO code must be like a million years old, it uses |newEmptyMVar                >>= \ tail_node ->|... instead of do-notation.
17:48:16 <dons> ...
17:48:22 <ski> probably it (don't-care-) nondeterministically selects some interleaving of the two lists
17:48:38 <dons> TheHunter, back in the GPH days?
17:49:08 <TheHunter> actually, it says (c) 2001.
17:49:45 <heatsink> ski: So it evaluates the lists and builds the output depending on which list elements finished evaluating first?
17:50:14 <heatsink> That's the only use I can think of for nondeterminism...
17:50:59 <TheHunter> yes, the comment says that, but the definition looks awfully complicated.
17:51:00 <cm> I don't understand how to use NewBinary.Binary to seek to a given byte offset
17:51:30 <cm> the constructor of "Bin" is not exported, and I can't find another constructor-style function
17:51:31 <heatsink> I didn't know you could do that in haskell.
17:51:45 <heatsink> (distinguish an evaluated thunk from an unevaluated one)
17:51:48 <cm> so can you only seek to where you have been before? :|
17:53:13 <TheHunter> heatsink, it doesn't do that:
17:53:18 <TheHunter> Prelude Control.Concurrent> print =<< mergeIO [undefined] [(1::Int)..]
17:53:18 <TheHunter> [*** Exception: Prelude.undefined
17:57:32 <ski> heatsink : IO is the monad of good and evil
17:58:15 <heatsink> ???
17:58:36 <ski> um, maybe too far-fetched
17:58:38 <TheHunter> @index extremelyUnsafeIsThunk
17:58:39 <lambdabot> bzzt
17:58:40 <ski> :)
17:59:23 <ski> anyway, IO is magic .. one can attribute lost of strange effects to IO .. for better or worse
17:59:30 <ski> s/lost/lots/
17:59:55 <ski> (think some person said the IO monad acts like a "sin-bin")
18:00:35 <ski> (i.e. effects we can't explain we put in IO monad)
18:00:55 <ski> (explain = describe denotationally)
18:01:31 <heatsink> See, this is why all the other programmers consider haskellers to be new age weirdos.
18:01:46 <ski> hehehe :)
18:01:48 <heatsink> What they take for granted is what we put in this box and try not to touch.
18:01:52 <int-e> ski: and it's true, isn't it?
18:02:02 <ski> int-e : which ? :)
18:02:13 <int-e> ski: that IO is a sin-bin
18:02:26 <ski> yes, i think so, to some degree
18:02:30 <int-e> and ST.
18:02:33 <ski> no
18:02:42 <ski> ST is broken out from IO
18:02:45 <ski> better
18:02:46 <int-e> to some degree at least.
18:02:48 <ski> yes
18:02:55 <int-e> IO is an instance of ST.
18:03:04 <ski> i think ST still can have concurrency (iirc)
18:03:11 <int-e> with some weird opaque type RealWorld#
18:03:27 <ski> m
18:03:45 * int-e didn't try to find out where that's defined and how - it's likely a compiler/RTS internal trick.
18:03:56 <ski> yep, it's
18:04:41 <int-e> (and obviously that observation is ghc-specific)
18:04:43 <ski> the point is .. programming in IO monad is not so much different from programming in any old imperative language
18:05:28 <ski> (only haskell is e.g. lazy and has better utilities for higher-order code, etc ..)
18:05:37 <int-e> well, that's what it's designed for (the IO monad)
18:06:08 <ski> thinking about a pure function  A -> IO B is not much different from thinking about an impure function A -> B
18:06:29 <heatsink> yup
18:06:33 <int-e> I know. But it doesn't do anything on its own.
18:06:52 <ski> int-e : yes .. but sometimes it'd be good to be able to chose more fine-grained what effects in IO one wants
18:06:58 <ski> (ST is an example of that)
18:07:21 <skew> ST is a lot better - a function of type A -> ST B can't even have closed over some refernences
18:07:31 <ski> (int-e : which doesn't do anything on it's own ?)
18:07:52 <int-e> ski: the function a -> IO b does nothing.
18:07:56 <ski> s/ST/ST s/
18:08:08 <int-e> ski: in terms of side effects and ignoring stuff like unsafePerformIO.
18:08:16 <ski> int-e : the function [a] -> [a] does nothing
18:08:21 <skew> that's a good point, reasoning about a function of type A -> IO B is easy, it's reasoning about what that IO B will do that's tricky
18:08:47 <ski> int-e : both do things if "run" in the right way .. bind for first, apply for second
18:10:34 <ski> when reasoning about a function A -> IO B one usually shifts from thinking in a category of pure functions/morphisms to another category (the kleisli-category over monad IO) where morphisms are impure functions, just like ordinary imperative langs
18:11:00 <ski> it's a matter of pov if A -> IO B is *side*-effectful or not
18:11:21 <Cale> People might think we're new-age weirdos, but in some sense, Haskellers follow a much older tradition -- we're trying to be more like mathematics.
18:11:22 <ski> (this all imo)
18:11:55 <int-e> ski: I think I agree. There's nothing to argue about really, just a bunch of equivalent models.
18:12:00 <Cale> A -> IO B as a function has no side effects
18:12:44 <int-e> Oh. In a way, only main has side effects.
18:12:48 <int-e> Main.main
18:12:48 <Cale> right
18:13:19 <ski> A -> IO B  as a morphism from A to B has side effects
18:13:21 <int-e> and not out of itself but because its value is being interpreted by the RTS
18:13:24 <Cale> main is the only value which ever gets run
18:13:30 <Cale> riht
18:13:33 <Cale> right*
18:14:06 <Korollary> I thought the side effect stuff was captured by the IO library code and was not expressible in haskell
18:14:48 <ski> very often when reading aloud   Handle -> IO String   we say this is a function taking a file handle and IO-monadically returning a string .. inserting 'IO-monadically' to make this cohere with the pureness of haskell
18:15:11 <Cale> I tend not to think of things that way though.
18:15:13 <ski> main :: IO ()
18:15:16 <ski> main = foo
18:15:19 <ski> foo :: IO ()
18:15:21 <ski> foo = ...
18:15:37 <ski> here main is the same as foo, so if main gets run, then foo gets run
18:15:43 <Korollary> I tend to think that the IO String is the right String by magic as if it's a magical pure function
18:15:57 <cm> hrm, is there something like >>= but infixr (or =<< but infixl)?
18:16:21 <int-e> cm: whatever would you use that for?
18:16:24 <ski> (better to say, that main is the top-point (or something) ..)
18:16:58 <cm> int-e: (return . Constructor) =<< get =<< get =<< get =<< get ...
18:17:07 <Cale> I tend to think of an IO String as an otherwise inert value representing an IO action which can be performed that has a String result.
18:17:20 <cm> int-e: as many gets as there are constructor arguments.. is there a nicer way to do that?
18:17:58 <ski> Cale : yes ..
18:18:17 <ski> (an impure morphism from () to String :)
18:19:14 <Cale> I don't particularly like using the Kleisli category to think about things, but I suppose it could be handy from time to time.
18:19:27 <ski> (Cale : do you then think in terms of the implementation of the effects in the monads, instead of internalizing intuitions about how those effects work .. ?)
18:20:04 <ski> (of course one needs to think in terms of what it purely mean, too)
18:20:30 <cm> int-e: hrm, `ap`
18:21:06 <int-e> uh. Constructor :: a -> M ( b -> M (c -> M (d -> M (Type a b c d))))
18:21:13 <int-e> @index ap
18:21:14 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
18:21:14 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
18:21:14 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
18:21:14 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.
18:21:14 <lambdabot> Inductive
18:21:22 <Cale> I do think about it in an intuitive fashion, but I don't think of A -> IO B as a function from A to B in any sense. It's strictly a function from A to IO B.
18:22:06 <ski> s/function/pure (traditional programming) function/
18:22:18 <Cale> I think of IO B as a particular set of "programs", which are values which can't be observed but can be manipulated.
18:22:22 <cm> int-e: data Foo = Constructor Int Int Int Int Int Int Int Int Int Int Int Int
18:22:36 <cm> get :: IO Int
18:22:41 <int-e> @type >>=
18:22:45 <int-e> @type (>>=)
18:22:46 <lambdabot> bzzt
18:22:46 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m
18:22:46 <lambdabot> b
18:23:05 <int-e> cm: ap looks good. >>= wouldn't do what you want, I think.
18:23:09 <Cale> values of type A -> IO B are pure functions from values of type A to programs of type IO B.
18:23:42 <Cale> For any particular value a in A, you get the same program.
18:23:46 <int-e> cm: because I really think the Constructor would have to have the type I gave to have that work.
18:24:13 <cm> int-e: ... get >>= (get >>= return . Constructor) would do what I want, I think.
18:24:50 <cm> or ..((return . Constructor) =<< get) =<< get)..
18:26:28 <Cale> Is that type-correct?
18:26:36 <int-e> I don't think so.
18:26:43 <Cale> neither do I
18:26:56 <int-e> you want (return Constructor) `ap` ...
18:27:50 <cm> yup, you're right.
18:28:24 <Cale> (return (,)) `ap` getLine `ap` getLine >>= print
18:28:24 <Cale> Hello
18:28:24 <Cale> World
18:28:24 <Cale> ("Hello","World")
18:29:11 <int-e> @index liftIO
18:29:11 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
18:29:11 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
18:29:11 <lambdabot> Monad.Error, Control.Monad.List
18:29:40 <Cale> liftM2 (,) getLine getLine >>= print
18:29:46 <Cale> would be another way to write it
18:30:49 <cm> get fp = (g.g.g.g.g.g.g.g.g.g.g.g.g.g.g.g.g.g.g.g.g) (return DOSHeader) where g x = ap x (get fp)
18:30:58 <cm> :<
18:31:14 <int-e> argh
18:31:31 <cm> :P
18:31:49 <Cale> (!! 21) . (iterate g)
18:31:54 <int-e> iterate g (return DOSHeader) !! <no of args>
18:32:09 <int-e> Cale: heh.
18:32:23 <int-e> (but does that work? no.
18:32:26 <int-e> )
18:32:28 <cm> how would that work?
18:32:36 <int-e> it wouldn't
18:32:45 <int-e> type unification on g fails.
18:33:00 <Cale> ah
18:33:33 <Cale> oh - I hadn't even looked at the definition of g
18:35:15 <cm> (btw, Constructor "takes" both Word16 and Word32)
18:35:26 <Cale> what is this?
18:35:45 <Cale> I missed the initial context, if any :)
18:36:02 <dons> @seen dcoutts
18:36:03 <lambdabot> dcoutts is in #haskell and #gentoo-haskell. Last spoke 3 hours, 17
18:36:03 <lambdabot> minutes and 32 seconds ago.
18:36:25 <cm> trying to write a little library for analyzing PE files, using NewBinary
18:37:05 <Cale> did you see the little Packet class I wrote?
18:37:28 <dons> Lemmih, dcoutts says "<dcoutts> Lemmih, you can use any license you like for the modules you write
18:37:38 <dons> surely he means, what, the plugins only?
18:37:41 <cm> nope :|
18:37:47 <Cale> http://www.haskell.org/hawiki/PacketClass
18:41:12 <dons> Lemmih, textBufferGetSliceCString should go in a gtk-util module I think
18:41:47 <mcnster> hello
18:42:05 <ski> hi mcnster
18:42:11 <mcnster> hi ski :)
18:46:29 <ski> autrijus : nice
18:47:15 * ski will sleep
18:58:48 <cm> how would I represent a bit field data Flag = Foo | Bar | ..  / type Flags = [Flag]?
19:01:51 <Cale> that's probably suitable
19:02:06 <Cale> or (Set Flag)
19:02:50 <int-e> @type fromEnum
19:02:56 <lambdabot> forall a. (Enum a) => a -> Int
19:05:36 <int-e> hmm, it should also be possible to write a data Enum a => Flags a type using Data.Bits - has anyone done that?
19:10:00 <dons> can you make your type an instance of Bits?
19:10:10 <dons> class Num a => Bits a where
19:10:10 <dons>     -- | Bitwise \"and\"
19:10:10 <dons>     (.&.) :: a -> a -> a
19:10:11 <dons> ..
19:10:35 <dons> also setBit, clearBbit, testBit ..
19:11:33 <dons> or at least work out the isomorphism to an Integral type, such that  you can get to an instance of Bits that makes sense
19:11:50 <dons> (which is probably easiest, in fact)
20:23:46 <skew> that's a good point, reasoning about a function of type A -> IO B is easy, it's reasoning about what that IO B will do that's tricky
20:23:50 <skew> ??
20:24:13 <skew> oops, wrong window for those keystrokes...
20:25:57 <skew> oops, wrong window for those keystrokes...
20:26:01 <Cale> heh
20:26:48 <skew> I'm reloading a module lots in ghci, one window right of emacs - you all are one window left...
20:27:13 <Korollary> C-x 3 amen
20:44:02 * humasect same irc left, emacs mid, shell right
20:49:57 <dons> @code
20:49:58 <lambdabot> STRef.lhs: readSTRef (STRef var#) = ST $ \s1# -> readMutVar# var# s1#
20:50:11 <dons> oh yeah :)
20:50:55 <dons> encoding the kind in the value is a weird convention in ghc-haskell, imo
20:51:19 <dons> I guess that since we didn't have kind annotations till recently, it helps.
20:52:02 <Korollary> How do I get the powerset of a Data.Set type of value ?
20:59:32 <skew> no so easily
21:00:00 <Korollary> yeah, there's nothing built-in. I have to write it myself.
21:00:20 <skew> you could do it recursively on the internal representation
21:00:58 <skew> wait, there's not a cartesian product either
21:01:42 <Korollary> I am writing one that works on lists. I'll convert it to use Set once it works.
21:04:48 <Korollary> powerlist (x:xs) = let o = powerlist xs in (map (x :) o) ++ o
21:04:53 <Korollary> powerlist [] = [ [] ]
21:04:56 <Korollary> seems to work
21:11:20 <Cale> Cartesian product is just sequence
21:12:17 <skew> of lists, not sets
21:12:20 <Cale> oh, but not on Set
21:12:22 <Cale> yeah
21:13:21 <Cale> Yeah, actually, Data.Set seems lacking with respect to set operations that don't involve individual elements
21:13:33 <Cale> I suppose it has union
21:14:04 <Cale> and unions, but not Set(Set a) -> Set a
21:14:23 <Cale> Which actually might be a problem anyway
21:14:31 <Cale> because sets aren't ordered :)
21:14:59 <Cale> oh
21:15:01 <Cale> no, they are
21:15:14 <Cale> I wonder what the ordering is defined as
21:15:28 <sethk> Cale, the order elements are added?
21:16:04 <Cale> Ordered in the sense that one can write x < y for values of type Set A
21:16:22 <sethk> Cale, that's a requirement for set?
21:16:33 <Cale> there's an instance (Ord a) => Ord (Set a)
21:16:55 <Cale> To do anything with sets, the elements have to be ordered.
21:17:05 <Cale> because the internal representation is as a search tree
21:17:11 <sethk> there has to be some collection defined that doesn't care about order, though
21:17:22 <sethk> well, I suppose there doesn't _have_ to be
21:17:24 <Cale> (well, a certain kind of size balanced binary tree)
21:17:36 <skew> it seems to be lexicographic order on toList
21:17:39 <Cale> The set doesn't really maintain order
21:17:48 <Cale> skew: ah
21:18:01 <Cale> That instance is important
21:18:18 <Cale> because you want to be able to work with Set (Set a)
21:19:15 <Cale> I really wish the type system could support an instance of Monad on Set.
21:20:26 <Korollary> interesting. They force it by having the constructors be (Ord a).
21:20:34 <Cale> right
21:20:44 <Korollary> insert :: Ord a => a -> Set a -> Set a
21:20:48 <Cale> Sets are one of the primary examples of a monad
21:20:59 <Korollary> I can create a null-set, but it stops there
21:21:17 <Cale> but they can't be made one because of the Ord restriction
21:21:58 <JoslGr0s> someone wanna help me a bit ? (query plz)
21:22:04 <sethk> you mean they can't be an instance of the monad class?
21:22:11 <Cale> Really, the Set constructor is a monad on a subcategory of the category of Haskell types.
21:22:15 <Cale> right
21:22:19 <sethk> JoslGr0s, it is better to ask a more specific question.  :)
21:22:22 <Cale> so they can't be an instance
21:22:44 <skew> I think it would not be hard to allow, though
21:22:45 <Cale> Which is necessary in order to use the monad libraries :)
21:22:59 <JoslGr0s> sethk , well its not a specific question. Its a Exercice .. n i dont know where to begin
21:23:17 <sethk> JoslGr0s, well, you have to tell us more than that if you want help.  :)
21:23:20 <Cale> JoslGr0s: well, what's the exercise?
21:23:22 <skew> just let all your method definitions in an instance freely use any instances you assume in the context
21:23:31 <Korollary> Then, I suppose I can't write a function powerset since I can't possibly make every powerset of all things an instance of Ord.
21:24:05 <skew> Korollary: They just said there's an instance Ord a => Ord (Set a)
21:24:30 <skew> powerset :: Ord a => Set a -> Set (Set a)
21:24:47 <JoslGr0s> well, i need to describe each step of a expression evaluation
21:25:00 <sethk> JoslGr0s, ok, then start with the first step
21:25:15 <sethk> JoslGr0s, or do you have a more general question?
21:25:22 <Korollary> skew: yes, there's an instance
21:25:44 <Cale> JoslGr0s: do you have a question as to which bit to evaluate first?
21:25:50 <JoslGr0s> supposed to be RPN in haskell
21:26:03 <sethk> JoslGr0s, well, no
21:26:16 <sethk> JoslGr0s, rpm uses postfix operators and most haskell operators are prefix
21:26:30 <sethk> JoslGr0s, and some are infix
21:26:36 <JoslGr0s> (>>) push 4 push "hello" cons dup proj2 len  exch proj1 add (>>)
21:26:42 <sethk> rpn that is, not rpm, sorry
21:26:45 <JoslGr0s> i know most of operators r prefix ..
21:27:04 <sethk> JoslGr0s, you said rpn; I was just pointing out that rpn is not correct
21:27:09 <JoslGr0s> (>>) k = k()
21:27:14 <JoslGr0s> what does it mean ?
21:27:49 <sethk> JoslGr0s, back up.  What are you running?
21:28:12 <JoslGr0s> .. interpreter ? hugs
21:28:34 <sethk> JoslGr0s, ok, we don't know that until you tell us.
21:28:43 <JoslGr0s> i know :D
21:29:44 <sethk> JoslGr0s, unfortunately I don't have hugs here, I use ghci which is a different interpreter
21:29:47 <JoslGr0s> (>>) , push, cons, dup , proj2, len, exch, proj1, add r define ... n i need to evaluate the expression
21:30:23 <JoslGr0s> well, i use hugs, but i suppose to do it only with a paper/crayon
21:31:13 <JoslGr0s> anyway, its hard to understand some logic in the expression
21:31:15 <sethk> JoslGr0s, and you are supposed to explain the order of execution?
21:31:34 <skew> defining postfix operators like that is pretty tricky
21:31:37 <sethk> JoslGr0s, or say what the result is?
21:32:15 <JoslGr0s> well, explain all step of execution
21:32:17 <sethk> skew, I don't think they are postfix.  Look at what he typed originally
21:32:30 <Cale> "(>>) push 4 push "hello" cons dup proj2 len  exch proj1 add (>>)" is such an unhaskellish piece of code
21:33:00 <JoslGr0s> some weird enought 4 me
21:33:02 <JoslGr0s> sound.
21:33:28 <Cale> do you have definitions of all those?
21:33:32 <JoslGr0s> cale, yes
21:33:48 <Cale> then you can replace each function by its definition
21:34:10 <JoslGr0s> normally .. yes, but i dont know how with this expression.
21:35:00 <JoslGr0s> (>>) k = k () | (<<) (x,_) = x
21:35:23 <JoslGr0s> anyway ... too tricky 4 me
21:35:34 <sethk> are the (<<) things just prompts?
21:35:50 <JoslGr0s> what do u mean ?
21:35:56 <JoslGr0s> (my english sux)
21:36:20 <skew> sethk: this looks like the postfix stuff oleg put together a while back
21:36:29 <sethk> skew, oh, so they are operators then
21:36:37 <skew> things like push grab a few positional arguments, before working on the stack
21:37:11 <sethk> skew, yes, I can more or less see how that has to be working
21:37:24 <sethk> skew, or at least make an educated guess
21:37:34 <sethk> skew, although definitions wouldn't hurt.  :)
21:37:50 <JoslGr0s> push s x k = k (x,s)
21:37:50 <JoslGr0s> pop (_,s) k = k s
21:37:50 <JoslGr0s> dup (x,s) k = k (x, (x, s))
21:37:50 <JoslGr0s> exch (a,(b,s)) k = k (b, (a, s))
21:37:51 <JoslGr0s> add (x,(y,s)) k = k (x+y,s)
21:37:53 <JoslGr0s> len (x,s) k = k (length x, s)
21:37:55 <JoslGr0s> cons (x,(y,s)) k = k ((y,x), s)
21:37:57 <JoslGr0s> proj1 ((x,y),s) k = k (x,s)
21:37:59 <JoslGr0s> proj2 ((x,y),s) k = k (y,s)
21:38:14 <Cale> okay
21:38:22 <Cale> so it's all continuation passing style
21:38:29 <JoslGr0s> i dont know where to begin
21:38:39 <Cale> k is being used here as the "next thing to do" in each function
21:38:56 <Cale> the function does whatever it does, then passes the result on to k
21:39:15 <Cale> this implements a little forth-like language
21:39:50 <Cale> (>>) k = k ()
21:40:19 <JoslGr0s> in the expression (>>) is a the end ..
21:40:28 <Cale> no, the beginning
21:40:43 <JoslGr0s> sorry :/ (<<) is at the end
21:40:56 <Cale> right
21:41:05 <Cale> I realised that must be how it goes :)
21:41:30 <Cale> (<<) gets rid of the stack :)
21:41:45 <Cale> and gives you back the result
21:42:07 <Cale> quite clever :)
21:42:28 <Korollary> yay, I did powerset for Set a
21:42:45 <JoslGr0s> maybe, but i dont understand
21:42:49 <Cale> okay
21:43:18 <JoslGr0s> how can i evaluate this expression .. where can i begin ?
21:43:56 <sethk> JoslGr0s, right at the beginning.  find a function that matches the first few symbols
21:44:27 <sethk> JoslGr0s, which will be (>>) and then one or more additional symbols from the expression
21:44:53 <JoslGr0s> Humm
21:45:04 <JoslGr0s> (<<) u mean ?
21:46:05 <sethk> JoslGr0s, no, the expression you typed starts with (>>), not (<<)
21:46:21 <sethk>    (>>) push 4 push "hello"
21:46:32 <sethk> JoslGr0s, is the beginning of what you showed us, isn't it?
21:46:49 <JoslGr0s>  "(>>) push 4 push "hello" cons dup proj2 len  exch proj1 add (>>)"
21:46:50 <Cale> btw, in the end, you should get 9
21:46:59 <JoslGr0s> Cale, yes 9
21:47:12 <Cale> (>>) push 4 push "hello" cons dup proj2 len  exch proj1 add (<<)
21:47:28 <JoslGr0s> (hugs tell me this too)
21:47:32 <JoslGr0s> cale, yes this is the expression
21:48:26 <JoslGr0s> :/ how do u find it ?
21:48:42 <Cale> by replacing functions with their definitions
21:49:18 <JoslGr0s> well, i missing something big :/ can u explain ?
21:49:50 <Cale> btw, if you use id rather than (<<) at the end, you can see the stack at various points in the calculation
21:50:11 <Cale> (>>) push 4 push "Hello" id
21:50:14 <Cale> gives
21:50:19 <Cale> ("Hello",(4,()))
21:50:38 <Korollary> @hoogle stat
21:51:02 <JoslGr0s> k
21:51:12 <Cale> okay, so it's just like math
21:51:42 <metaperl> Cale: quick question about math
21:51:51 <Korollary> man, we don't have stat in the libs ?
21:52:12 <JoslGr0s> HeHe ill try again with those information ..
21:52:17 <Cale> you can replace any function by its definition
21:52:45 <metaperl> n > 1 and  n not prime => (LD(n))^2 <= n... but does this also imply that n prime => (LD(n))^2 > n ?
21:52:56 <metaperl> hmm, think I'll goto #math
21:52:57 <Cale> LD?
21:53:04 <metaperl> least divider
21:53:07 <Cale> okay
21:53:11 <metaperl> the number > 1 that divides it
21:53:36 <Cale> If n is prime, then LD(n) = n
21:53:39 <Korollary> metaperl: that statement by itself doesn't imply that
21:53:50 <Korollary> unless explicitly stated as if and only if
21:54:09 <Cale> right, with implies there, you're not going to get that
21:54:16 <Cale> (not directly)
21:54:22 <metaperl> ah, that statement doesnt but given that LD(n) = n, (LD(n))^2 will be greater than n
21:54:30 <Cale> right
21:54:42 <Korollary> btw, if n is prime, then LD(n) = n anyways
21:54:51 <Cale> I just said that :)
21:55:09 <Korollary> I was not reading :)
21:55:17 <Korollary> we both can't be wrong !
21:55:23 <Cale> hehe
21:56:04 <Korollary> maybe missingH has a stat function
21:57:37 <Korollary> thanks to being a debian package, missingH seems to be quite google'able
21:58:36 <Korollary> yep, MissingH.IO.StatCompat
21:58:39 <Korollary> sweet
22:01:05 <Cale> Suppose that p is a positive prime and there is a divisor of p, say d, such that 1 <= d <= p. Then p = kd for some k >= 1. Since p | p we have p | kd, and since p is prime, p | d or p | k. But whichever one of these p divides, it also divides p. So p = d or p = k.
22:01:37 <sethk> that's the classic proof
22:01:53 <Cale> And whichever one it's not is equal to 1.
22:04:43 <xerox> 'morning
22:04:53 <Cale> morning :)
22:05:02 <Cale> (night here)
22:05:26 <JoslGr0s> cale, thx again .. im almost there
22:05:32 <Cale> well, I suppose it's 1am, which might be considered extremely early morning :)
22:05:53 <sethk> Cale, we are in the same time zone
22:06:12 <xerox> 07:05 here, yawn :-)
22:06:37 <sethk> ok, so we have north america, europe, I assume we have an australian contingent?
22:06:44 <Cale> yep
22:06:49 <Cale> fairly major actually
22:07:28 <Korollary> There was a globe with #haskell users on the wiki
22:07:28 <metaperl> is there a quick way to time a function call?
22:07:30 <Cale> dons is Australian, for one :)
22:07:51 * Pseudonym is too
22:08:07 <Cale> http://www.haskell.org/hawiki/HaskellUserLocations
22:08:21 <sethk> Cale, so is lambdabot   :)
22:08:25 <Cale> heh
22:09:33 <sethk> hm, got an attack email with a virus attached, with the return address support@symantec.com, and the attached file named signature.zip
22:10:14 <Cale> heh, it would be really hilarious if that was the actual sender :)
22:10:21 <xerox> metaperl: in GHCi :set +s
22:10:45 <sethk> Cale, there was a case in the last week or so where their virus scanner was hacked to get root access to windows boxes
22:10:49 <Cale> metaperl: if you need to do it in code, look in the CPUTime library
22:12:45 <xerox> Bye bye.
22:13:10 <Cale> xerox: taking off?
22:13:24 <Cale> see you
22:14:36 <Korollary> Cale: are you in school still ?
22:14:40 <Cale> nope
22:14:40 <Korollary> I keep forgetting
22:14:43 <Cale> I'm done
22:14:53 <Korollary> what's next ?
22:15:06 <Cale> At the moment I don't have any plans
22:15:50 <Cale> Mostly relaxing at my parents' for a bit :)
22:16:29 <Cale> and working on personal projects
22:16:48 <Cale> and studying imprimitive symmetric graphs a bit with my friend :)
22:17:56 <Korollary> I can't get any studying done even though I'm "relaxing" myself.
22:18:18 <Korollary> until I start my new job a week from now, that is
22:18:59 <Korollary> I suppose writing haskell counts towards studying
22:20:58 <sethk> Cale, want to help me with my database server port?   :)
22:22:46 <Korollary> sethk: that sounds like a big project
22:22:59 <sethk> Korollary, yes, definitely
22:23:09 <sethk> Korollary, that's why I'm still debating whether to do it.
22:23:29 <Korollary> sethk: what else have you written in haskell ?
22:23:43 <sethk> Korollary, in haskell?  Mostly parsers and filtering programs
22:24:36 <Korollary> sethk: It may be a better idea to hack on something like yi or hide before doing something big like that.
22:25:02 <sethk> Korollary, possibly, but I'm more concerned right now about whether it is worthwhile to do it at all
22:25:19 <sethk> Korollary, in general I've found that a big project is a very good way to really learn a language
22:25:40 <sethk> Korollary, I don't have any doubts about whether I can do it
22:25:50 <sethk> Korollary, but the question is whether the effort is worthwhile
22:25:52 <Korollary> sethk: It's a direct port, yes ? No new features that didn't exist in the c++ version
22:26:13 <sethk> Korollary, mostly.  I do want to upgrade the concurrency control a bit
22:26:28 <sethk> Korollary, and possibly enhance one of the tree structures I designed for it.
22:26:36 <Korollary> sethk: so what would make it worthwhile replicating it in haskell ?
22:26:55 <sethk> Korollary, reliability, for one
22:27:22 <sethk> Korollary, even though I use all the possible c++ type safety tricks, it isn't possible to thoroughly test all the possible type combinations
22:27:57 <sethk> Korollary, and there is an interesting congruence between my concurrency control algorithms and the way haskell does things
22:28:27 <Korollary> sethk: Is this a commercial product ?
22:28:43 <sethk> Korollary, it's been used in some telephone switches, yes.
22:29:26 <Korollary> sethk: but, are you planning on dropping in the haskell version in place of the cpp version ?
22:29:38 <sethk> Korollary, yes
22:29:51 <sethk> Korollary, if I do it in the first place, it will become the main release
22:29:59 <sethk> Korollary, no way I would back port to c++
22:30:44 <sethk> Korollary, it would make a very interesting case study, because of the way that the types are so suited to haskell
22:30:51 <Cale> this is a generic database server?
22:31:04 <sethk> Cale, it's an implementation of SQL '92 with ODBC extensions
22:31:41 <Korollary> sethk: I don't know much about db's, but would haskelldb work for you ?
22:31:59 <sethk> Korollary, I don't think so, although I should certainly look at it again.
22:32:02 <Cale> Is anyone maintaining HaskellDB?
22:32:18 <Cale> It's a cool enough project.
22:32:29 <sethk> Korollary, but a full ANSI SQL implementation, with full transactional semantics, is a different order of magnitude
22:33:05 <sethk> Korollary, getting the concurrency right was a huge effort
22:33:39 <Korollary> sethk: I see
22:33:47 <sethk> Korollary, The question of how the native haskell interface would work is also a very interesting one
22:33:55 * dons keeps meaning to rerender http://www.haskell.org/hawiki/HaskellUserLocations so you can actually see the .au hackers
22:34:20 <Korollary> dons: why not multiple globes ?
22:34:35 <dons> why not a projection that shows everyone?
22:34:38 <boogrrr> ok
22:34:48 <Korollary> dons: I would have to assume that there is such a projection
22:34:54 <dons> 2 globes are ok, 1 globe for all is even better!
22:34:55 <boogrrr> what is haskell? and can someone who knows only a biy of linux use it?
22:35:04 <sethk> boogrrr, sure
22:35:06 <dons> I bet there is, K :) /me hacks
22:35:18 <sethk> boogrrr, you don't really need lots of O/S knowledge to use a language and compiler
22:35:19 <Cale> boogrrr: you don't need to know anything about linux at all to use haskell
22:35:22 <Korollary> boogrrr: it's a programming language. It runs on linux, windows, etc.
22:35:23 <dons> cd /usr/ports/x11/xglobe ; sudo make fetch ; sudo make :)
22:35:24 <Cale> it's a programming language
22:35:29 <sethk> boogrrr, although knowing how to use an editor is certainly helpful
22:35:35 <mflux_> dons, project it so that the area of the countries depends linearly on the number of haskell hackers in the country!
22:35:46 <dons> oh, nice mflux.
22:35:54 <Cale> http://haskell.org/
22:36:00 <dons> I'll write a little haskell script to tweak the xglobe params, shall I ;)
22:36:32 <dons> actually, I don't know of a tool for doing the kind of image mflux suggests
22:36:35 <Korollary> sethk: how do you think haskell's performance will be for something like that ?
22:37:32 <sethk> Korollary, that is a good question.  If I didn't think it was possible to get comparable performance (comparable to c++, at least the same order of magnitude) I wouldn't do it.
22:37:45 <mflux_> dons, you could always write one ;)
22:37:49 <dons> boogrrr, haskell is a great language for beginner programmers, btw, and certainly doesn't require any unix knowledge. it's great for experienced programmers too :)
22:37:55 <sethk> Korollary, but of course what I'm thinking has to be proved (or disproved)
22:38:17 <mflux_> it would need the countries' border coordinates though
22:38:22 <Cale> boogrrr: if you're thinking of trying it out, you can get hold of ghc for free from http://haskell.org/ghc/download_ghc_641.html or if you're running linux, get it from your distribution. I strongly recommend binaries, as the compiler takes a rather long time to compile.
22:38:49 <Korollary> Cale: also, you can't compile without already having a compiler ;)
22:38:53 <dons> bootstrapping compilers is usually a tricky task though.
22:39:02 <sethk> Korollary, basically, it is a compiler/interpreter, and should have similar characteristics to other compilers/interpreters
22:39:03 <dons> K, but that compiler could be gcc ;)
22:39:05 <araujo> You can use, emerge ghc
22:39:08 <araujo> :-]
22:39:35 <Korollary> dons: I don't think the source tarball comes with the hc files
22:39:44 <Cale> or apt-get install ghc6
22:39:56 <sethk> I just use tarballs, it is so much easier
22:40:09 <Cale> easier?
22:40:16 <sethk> Cale, I think so, yes
22:40:23 <Korollary> not for ghc for me. I'd rather skip the compilation as it takes too long.
22:40:23 <Cale> ugh, so much maintenance though
22:40:25 <dons> Korollary, but the .hc tarball does  :)
22:40:39 <Cale> you can't just upgrade all your packages in one go
22:40:51 <sethk> Cale, I have never found it a problem
22:41:00 <Cale> and constantly have to get new versions of libraries
22:41:02 <sethk> Cale, of course I've been using unix for 25 years
22:41:09 <sethk> Cale, and I'm pretty set in my ways.
22:41:11 <Cale> you might just be used to it :)
22:41:13 <Cale> yeah
22:41:23 * dons encourages some of the ~180 people on this channel to add their locations to http://www.haskell.org/hawiki/HaskellUserLocations
22:41:27 <dons> before I recompute the map
22:41:42 <araujo> mm, let's see.. someone from aouth-america already there?
22:41:43 <Korollary> dons: no hc tarballs since 4.0 or something. see http://haskell.org/ghc/dist/6.4.1/
22:41:50 <araujo> south-america*
22:42:04 <dons> araujo, yes! please add your details :)
22:42:07 <sethk> dons, how do you add?
22:42:10 <Megzl> Holy fuck.
22:42:12 <sethk> dons, I'm at the page ...
22:42:20 <araujo> dons, I go! :-)
22:42:24 <Megzl> There's actually this many people in a Haskell channel? I thought it was an obscure little language.
22:42:27 <Cale> Megzl: hm?
22:42:36 <sethk> Megzl, it's not little
22:42:37 <Korollary> Megzl: we hit 180 sometimes
22:42:41 <Cale> Gets up to 180
22:42:47 <Megzl> That's pretty crazy.
22:42:50 <Megzl> So what's good about Haskell?
22:42:54 <araujo> Megzl, slowly taking over the world
22:42:55 <Cale> certain parts of the day
22:42:55 <Korollary> it's addictive
22:42:57 <gzl> wow, this is going to get incredibly annoying with my highlight filter.
22:43:03 <Cale> Lots and lots of things :)
22:43:15 <sethk> dons, am I supposed to click on the edit icon?
22:43:21 <dons> sethk, just edit the wiki entry, yes.
22:43:24 <Megzl> There's even a mini-me here.
22:43:33 <sethk> dons, ok, as soon as I figure out my long/lat
22:43:41 <dons> you get a little editor window, then you save the page (waiting for locks and what-not)
22:43:48 <Cale> The code is easy to reason about, the type system lets the compiler to check a lot of things about your code
22:43:51 <dons> very nice in w3m, as you get to use vim/yi ;)
22:43:57 <Korollary> Megzl: do you know scheme or lisp or ml ?
22:43:59 <sethk> dons, got an easy link for long/lat?
22:44:15 <Megzl> Is Haskell ever going to be a language which compiles? I have no interest in interpreted runtime languages, they're not fast enough for the 3d work I do.
22:44:18 <dons> hmm. nope :/ though if you're in the US maybe google maps will work
22:44:26 <Korollary> Megzl: it does already compile into native code
22:44:29 <dons> try googling for GPS coords for your home town.
22:44:32 <Megzl> Why can't these languages with unique syntax be compiled.
22:44:37 <Megzl> Then I could take them seriously.
22:44:38 <Cale> Megzl: there are several compilers and interpreters
22:44:46 <Megzl> Cale: but are they good?
22:44:48 <Cale> yes
22:44:52 <Cale> ghc is very good
22:44:53 <sethk> dons, well, my home town is NY, NY
22:44:54 <dons> Megzl, in fact, compile Haskell is extrememly fast, as is OCaml
22:45:00 <sethk> dons, which is rather large.  :)
22:45:16 <Megzl> How can you guys use something as obscure as OCaml.
22:45:16 <dons> sethk, then finding GPS coords for your front door might be possible :)
22:45:36 <Megzl> I just don't understand.
22:45:38 <sethk> dons, I could fire up my little gps receiver and see if it acquires
22:45:50 <Cale> Megzl: We tend to be the sort that don't choose our language by popularity
22:45:57 <dons> Korollary, on the subject of .hc files: ftp://ftp.cse.unsw.edu.au/pub/users/dons/ghc/6.2.2/
22:46:12 <Korollary> Megzl: it's not as obscure as you think. Maybe you were given bad impressions before.
22:46:13 <gzl> Megzl: because C makes me want to kill myself
22:46:19 <gzl> and it's really popular
22:46:21 <dons> we still distribute them, just not on the main site
22:46:33 <araujo> dons, i need to subscribe to the page right?
22:46:37 <Megzl> Let me give you an example. All the good API's that I need are written in C++. I use Ogre3d engine. I load up the .cpp files, and see what's going on, and it's directly syntactically related to my own code.
22:46:44 <dons> hmm. no, I don't think so araujo
22:46:48 <dons> the wiki, you mean?
22:46:53 <Megzl> It seems a big disadvantage to code in multiple languages at once.
22:46:56 <Cale> Megzl: the Haskell FFI lets you link to libraries in other languages.
22:47:02 <araujo> dons, yes
22:47:02 <Korollary> dons: hey, but you guys have been slacking heh. where's 6.x ;)
22:47:06 <araujo> dons, i get: You are not allowed to edit this page.
22:47:14 <Megzl> I understand that Cale, but when I take in code like Ogre3d, it becomes my own
22:47:17 <dons> ah, probably someone else has a lock on it
22:47:24 <dons> just wait a little while.
22:47:30 <araujo> No problem, i'll subscribe
22:47:57 <Megzl> ok, enough about this popularity stuff and the fact that all the libs I need are in C++
22:48:03 <Megzl> why's haskell cool syntax wise?
22:48:15 <dons> ah, I see it says: Immutable page (last edited 2005-10-09 04:04:08 by CaleGibbard)
22:48:15 <Cale> just syntactically?
22:48:28 <Megzl> Syntax+features
22:48:31 <araujo> Oh, i can't subscribe either :-(
22:48:32 <Megzl> language abilities
22:48:34 <dons> Cale, does this mean you have to log in, or someone has the lock?
22:48:39 <Cale> just log in
22:48:52 <Cale> Firstly, Haskell is referentially transparent
22:48:55 <sethk> Megzl, www.haskell.org has a ton of stuff
22:49:12 <Cale> which means that functions always do the same thing given the same parameters
22:49:25 <Megzl> What does "a purely functional language" mean?
22:49:28 <Cale> this means that code is *much* easier to reason about
22:49:52 <Cale> purely functional refers to that referential transparency, together with the fact that functions are first class values
22:49:52 <araujo> Megzl, Haskell's syntax is poetry
22:50:01 <pejo> Megzl, Amr Sabry has written an article which discusses that, if you're interested.
22:50:25 <dons> araujo, are you still unable to register, when you click on "UserPreferences"?
22:50:34 <araujo> dons, let me check again
22:50:53 <araujo> Ok, it works now
22:50:58 <araujo> Thanks
22:51:15 <dons> I didn't do anything ;)
22:51:31 <dons> other than check that it worked for me :)
22:51:45 <sethk> dons, I get "you are not allowed to edit this page"
22:51:49 <Megzl> I don't understand what referential transparency is.. what is it?
22:52:08 <Megzl> functions always do the same thing given the same parameters?
22:52:12 <Cale> yes
22:52:18 <Cale> and always return the same value
22:52:40 <Megzl> You're saying the function is entirely dependent on its arguments, and can have no external factors such as other variables it acceses?
22:52:45 <Cale> Right
22:52:46 <Korollary> Megzl: There's an introduction for C programmers here: http://www.haskell.org/~pairwise/intro/intro.html
22:52:50 <dons> sethk, have you refreshed since you logged in?
22:53:14 <sethk> dons, if you mean the wiki, I haven't logged in at all.
22:53:21 <Cale> I recommend the "Yet Another Haskell Tutorial" tutorial though.
22:53:37 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
22:53:59 <Cale> Another great thing about Haskell is its type system
22:54:03 <Megzl> So Haskell is more like writing mathematical functions.
22:54:04 <Megzl> ?
22:54:06 <Cale> yes
22:54:10 <Cale> that's true :)
22:54:19 <Korollary> Megzl: It's going to take some mental effort on your part before the answers you get start to make sense. Haskell is truly unlike the other languages you are familiar with.
22:54:20 <dons> sethk, you need to register to be able to modify the page, it seems.
22:54:21 <Cale> and you can use the same techniques on Haskell code
22:54:23 <Megzl> but what if you need it to depend on other factors?
22:54:31 <dons> once you login it works fine, I just checked
22:54:32 <sethk> dons, ok, then I'll have to figure out how to register.
22:54:39 <sethk> dons, it's not obvious from the front page.
22:54:44 <dons> to register, click on "UserPreferrences"
22:54:45 <JoslGr0s> yes hdaume is a good tutorial :P
22:54:46 <Cale> Megzl: then you use one of various abstractions available to express that
22:54:46 <dons> on any page
22:54:54 <Cale> Megzl: monads being the main one
22:54:58 <dons> then just add your name and a passwd, I think.
22:55:02 <sethk> dons, ok.  that is rather counterintuitive  :)
22:55:18 <Cale> though monads are a more general technique than just managing state
22:55:21 <Megzl> So, a function isn't something that executes code, so much as a function is actually more like a variable?
22:55:23 <Megzl> that you set.
22:55:32 <Cale> Megzl: it's a constant.
22:55:40 <Megzl> yea
22:55:54 <Megzl> Ok, I see... So when you go further with this and wrap your brain around thinking of coding this way, what happens?
22:55:55 <Cale> In fact, x = x + 1 in Haskell is an infinite loop
22:56:26 <Korollary> Megzl: Once you wrap your brain around it, you can write every program you want to.
22:56:40 <Cale> Well, you're able to test that things work more easily, you become aware of state because it is obviously different.
22:56:43 <sethk> dons, ok, now I've registered but all the icons (like edit) have disappeared.  :)
22:56:47 <Korollary> Megzl: but you write them a bit differently.
22:56:56 <Cale> State is actually responsible for most bugs in code.
22:57:03 <araujo> mm.. i have no xearth
22:57:10 <dons> sethk, I think you have to refresh after login. at least I had to.
22:57:17 <araujo> ok, now i do :-]
22:57:21 <Cale> limiting its use, and being aware of it is an incredibly good way to kill bugs :)
22:57:22 <sethk> dons, yes, of course, but nothing changes.
22:57:42 <dons> does it (the wiki) display your name in the top right?
22:57:46 <Megzl> Would you say haskell's syntax is obscure?
22:57:52 <Megzl> C++'s syntax is as simple as QBasic
22:57:59 <Cale> In fact, the type system in Haskell will ensure that side effects like IO, and management of state variables and such, happen in a sane way.
22:58:09 <Korollary> Megzl: Once you learn haskell's syntax, I bet you will hate c++'s syntax.
22:58:15 <Cale> qsort []     = []
22:58:15 <Cale> qsort (x:xs) = qsort less ++ [x] ++ qsort more
22:58:15 <Cale>      where less = filter (<x)  xs
22:58:15 <Cale>            more = filter (>=x) xs
22:58:18 <Korollary> Megzl: because I do
22:58:21 <dons> sethk, do you hhvae the "EditText" link down the bottom left of the page?
22:58:23 <Cale> there's a quicksort implementation in Haskell
22:58:36 <sethk> dons, yes, I think so, let me check
22:58:45 <Megzl> How does Haskell compare in speed to C++ ?
22:59:05 <aleator> Megzl: If you think c++ has simple syntax, nothing in this world will scare you.
22:59:12 <skew> Megzl: the Haskell version of glxgears got the same FPS as the C
22:59:13 <Korollary> Megzl: honestly, it's slower most of the time. But it can compete with java in speed, imho.
22:59:15 <sethk> dons, ok, I see it.  Now I have to wait until it is free.
22:59:31 <Megzl> Why would it be slower?
22:59:33 <skew> Korollary: depends how hard you work
22:59:40 <sethk> aleator, c++ _syntax_ is simple
22:59:43 <Cale> Megzl: more abstraction needs to be compiled away
22:59:52 <skew> Megzl: lazy evaluation, for one
22:59:52 <Korollary> skew: disclaimer: sticking with "idiomatic" haskell code.
23:00:07 <Cale> Megzl: so compiler technology still needs to get better -- there are people working on it
23:00:17 <Cale> But speeds are very usable
23:00:30 <Megzl> Can you give me the basics of this type system you speak of?
23:00:34 <sethk> Cale, and strict evaluation is available
23:00:34 <skew> main = print [1..] just starts printing out numbers and keeps going
23:00:35 <Korollary> definitely faster than perl etc.
23:01:03 <aleator> sethk: simple to use? which is valid template foo<bar<blah>> or foo< bar<blah> > ;)
23:01:16 <Megzl> alaetor: That'll be fixed in C++0x
23:01:35 <Megzl> It's a syntax bug.
23:01:55 <skew> type syntax is pretty messay too. int (*myfun(int x[]))(bool), etc
23:02:31 <Megzl> I've never seen a syntax like that for function pointers, skew.
23:02:51 <skew> that's a function that returns a function pointer
23:02:53 <Cale> Megzl: Okay, so you have your basic types, like Int, Integer (infinite precision), Char, and so on. Then you have type constructors, which are sort of type-level functions which take types to new types. One of these is (->). A -> B where A and B are types, is the type of functions from A to B.
23:03:03 <Megzl> skew...
23:03:44 <Cale> Another example is [], which takes a type to the type of lists of values of that type.
23:03:44 <Megzl> Cale: From A to B?
23:03:53 <Megzl> takes?
23:03:55 <Megzl> What is takes?
23:03:58 <Megzl> what is from?
23:04:03 <Cale> accepting an argument of type A and producing B
23:04:21 <Megzl> how does it know how to convert if it's an arbitrary type?
23:04:30 <smott> haskell sure is obscure, but it's not obscure enough to avoid the occasional troll apparently
23:04:37 <Cale> If Char is the type of characters, then [Char] is the type of lists of Chars.
23:04:53 <Megzl> Smott: Are you saying I'm a troll?
23:04:58 <Cale> Megzl: it doesn't convert values from one type to another
23:05:00 <dons> not that obscure -- it's won the icfp contest 2 years in a row now..
23:05:05 <Cale> It converts types to other types
23:05:34 <Cale> If A and B are types, then so is (A -> B)
23:05:42 <Cale> and so are [A] and [B]
23:05:47 <araujo> dons, Is there a way to know the exact location for my city?
23:05:49 <Cale> and [A -> B]
23:06:10 <Megzl> Cale: Can you tell me how that makes sense in terms of C++ thinking?
23:06:11 <Korollary> araujo: how about wikipedia ?
23:06:12 <Cale> [A -> B] is the type of lists of functions which take a parameter of type A and produce a value of type B
23:06:34 <Megzl> ah
23:06:35 <araujo> Korollary, good, let's see
23:07:03 <dons> also, I found google "$cityname GPS coordinates" is a pretty quick way to get some results
23:07:08 <Cale> Now, you also have type variables, distinguished by the fact that they start with a lowercase letter.
23:07:11 <dons> @google gps coordinates sydney
23:07:13 <lambdabot> http://www.fishnet.com.au/information/gps.html
23:07:16 <Cale> This is how polymorphism works
23:07:23 <Cale> length :: [a] -> Int
23:07:30 <araujo> Korollary, yeah, it is there, thanks
23:07:43 <Cale> It's a function which takes a list of any type, and produces an Int
23:07:53 <Megzl> Smott: ?
23:08:08 <Megzl> Cale: length is the function name?
23:08:11 <Cale> yes
23:08:20 <Megzl> where's the functions definition?
23:08:21 <Korollary> @eval length [1,2]
23:08:27 <lambdabot> 2
23:08:36 <Korollary> @eval length [True, False]
23:08:37 <basti_> Megzl: types in haskell are just the same as in any other programming language, just, in haskell, types can stay variable.
23:08:37 <Cale> length           :: [a] -> Int
23:08:37 <Cale> length []        =  0
23:08:37 <Cale> length (_:l)     =  1 + length l
23:08:38 <lambdabot> 2
23:08:41 <Cale> there
23:08:55 <Cale> length []        =  0 -- the length of the empty list is 0
23:09:21 <Cale> length (_:l)     =  1 + length l -- the length of a nonempty list whose tail is l is 1 + the length of l
23:09:28 <basti_> like in the :: term up there... "a" is a variable type. "length" will take any type you're putting there (a is just a variable and has no constraints)
23:09:41 <Megzl> I do variable type programming in C++, a lot of it. I've built a dynamic typed programming layer, based around boost::any
23:09:47 <Cale> cool
23:09:53 <Megzl> I can change types anytime.
23:09:59 <Cale> Here's a slightly more sophisticated example:
23:10:01 <basti_> yes, templates are a lot like haskel types
23:10:11 <Cale> map :: (a -> b) -> ([a] -> [b])
23:10:12 <Megzl> basti, not templates even
23:10:24 <Megzl> any i = 1.0f;
23:10:28 <Megzl> i = Vect3(0,1,0);
23:10:32 <skew> Megzl: this is more like template stuff, not really much like dynamic typing because the compiler checks that types match up, whatever they are
23:10:35 <basti_> i see
23:10:43 <Cale> It takes a function from values of type 'a' to type 'b' and produces a function from values of type [a] to type [b]
23:11:05 <basti_> haskell is static. It knows about types in advance.
23:11:07 <Cale> It does this in the only sensible way -- by applying the function it's given to each value in the list.
23:11:08 <Megzl> Cale, how can a to b be a range?
23:11:21 <basti_> ?
23:11:27 <Cale> You can pass functions to functions and you can also return them as results.
23:11:29 <skew> "a to b" means taking an a and returning a b
23:11:34 <Korollary> a -> b is not a range. it's a function.
23:11:35 <basti_> its not a range
23:11:44 <basti_> its a type of functions
23:11:45 <skew> like you could have bool lessThanTen(int x) { return x < 10;
23:11:53 <skew> taking an int and returning a bool
23:12:02 <basti_> a value of type "a -> b" is a value that takes an "a" and returns a "b"
23:12:19 <humasect> last type of ->'s = return
23:12:19 <basti_> (a one-parameter function without any constraints)
23:12:26 <Cale> map :: (a -> b) -> [a] -> [b]
23:12:26 <Cale> map f []     = []
23:12:26 <Cale> map f (x:xs) = f x : map f xs
23:12:34 <Cale> -> is right associative
23:12:46 <Cale> what does this say?
23:12:55 <Megzl> Cale, can you show me a few C/C++ functions and haskell equivalents?
23:12:59 <Cale> okay
23:13:02 <Megzl> not functions, but ideas.
23:13:21 <Cale> well, they'
23:13:29 <Cale> they're incredibly different languages...
23:13:36 <Cale> but I can try :)
23:13:51 <Megzl> that would be best, for now.
23:14:05 <Cale> okay
23:14:18 <basti_> see, everything is a function for us.
23:14:29 <basti_> there's function that don't take any parameters
23:14:41 <Megzl> is a variable a function?
23:14:44 <basti_> ("values" like 5 or "hello!")
23:14:53 <basti_> a variable can take any value
23:14:56 <basti_> including functions
23:15:01 <dons> sethk, go ahead and edit the page if you like
23:15:04 <Korollary> Megzl: Nothing varies, per se. Everyhting is a constant.
23:15:06 <basti_> (with 0, 1, or 10 parameters)
23:15:18 <Megzl> everything is a constant. um.
23:15:24 <Megzl> How do you express changing values?
23:15:31 <dons> or anyone else who'd like to make it onto the #haskell map: http://www.haskell.org/hawiki/HaskellUserLocations
23:15:33 <basti_> by replacing constants.
23:15:42 <humasect> "values"
23:15:45 <Cale> Megzl: you express them with functions
23:15:50 <basti_> ;)
23:15:53 <Korollary> Megzl: you create a new value that is built up on the old value. instead of x = x + 1, you say y = x + 1.
23:16:13 <humasect> megzi, think recursion.
23:16:42 <Cale> Megzl: another great big difference between Haskell and C++ is that Haskell is lazy. It never evaluates anything which is not needed to proceed in the computation of output.
23:16:58 <Cale> This means that infinite data structures are possible.
23:17:02 <skew> if you really want to you can make variables that can be changed, but it's usually easier to think about stuff if you don't, because you don't have to try to remember what all the rest of your code does to the variable
23:17:07 <Cale> for instance
23:17:11 <Cale> ones = 1 : ones
23:17:27 <Cale> : is an operator which builds a list from a first element, and a tail
23:17:35 <Cale> (a linked list)
23:18:09 <humasect> what is the ratio of people learning haskell to people forgetting haskell?
23:18:10 <dons> anyone who knows their coords and can't be bothered hacking the wiki, feel free to /msg me your gps coords, and i'll update the wiki page myself
23:18:16 <Megzl> so far, haskell seems to be purely a language of symbols and expressions.. but how does it handle memory and systems programming?
23:18:22 <Cale> If I load this definition into an interpreter, and type "ones", then I'll get [1,1,1,1,1,1,... filling up my screen
23:18:35 <basti_> Megzl: this is gonna be scary ;)
23:18:48 <Cale> don't say that it's going to be scary :)
23:18:50 <skew> that's probably gets compiled to a circular list - [1..] is a better example, if a little harder to define
23:18:59 <Cale> It's really not that scary
23:19:04 <dons> Cale, I thought we traditionally always demoed this code ;)
23:19:06 <Cale> but it is rather different :)
23:19:19 <skew> Megzl: you have to write in the type that you are going to be doing stuff like that
23:19:29 <Megzl> write in the type?
23:19:43 <Cale> values of type IO a in Haskell, represent computations which do some IO, then return a value of type a
23:19:57 <basti_> the type system keeps you from shooting yourself into your foot
23:20:01 <Korollary> Megzl: if you want to mess with the memory directly, there are some design patterns and library functions you can use.
23:20:05 <Cale> there are a few combining operators which string these together
23:20:13 <skew> IO () means I'm going to do some stuff and not return anything that really matters, like void f(void) in C
23:20:46 <skew> memory is allocated for you and garbage collected when you are done with it
23:20:47 <araujo> mm...
23:20:48 <Megzl> Is there a haskell VM I can put into C++ and write scripts with?
23:20:48 <ValarQ> skew: "anything that really matters"?
23:20:55 <ValarQ> skew: can it return anything?
23:21:01 <humasect> soon libghc. =)
23:21:04 <basti_> Megzl: we have a good "foreign function interface"
23:21:05 <araujo> dons, i am not sure what to write in align=
23:21:16 <skew> no, () is a special type that just has one value, also written ()
23:21:21 <dons> you can leave it out araujo
23:21:25 <skew> it just means "I don't have anything interesting to say"
23:21:26 <Megzl> Is haskell being taught in any universities?
23:21:26 <sethk> Megzl, that really doesn't make sense in this context
23:21:28 <araujo> dons, ok
23:21:34 <Korollary> Megzl: yes
23:21:44 <dons> araujo, it's a hint to xglobe about where to write your name tag, iirc
23:21:55 <Korollary> Megzl: U or Portland, I think
23:21:56 <dons> so it doesn't matter if you have a whole continent to yourself ;)
23:22:04 <ValarQ> shapr: an empty tuple, sounds logical
23:22:19 <dons> @eval ()
23:22:20 <Megzl> C++ is just so simple, I can get work done with it.
23:22:22 <lambdabot> ()
23:22:29 <basti_> haskell is simple too
23:22:41 <Cale> Megzl: Haskell is simple, but in a different way
23:22:43 <araujo> dons, ok, i just added myself :-]
23:22:55 <skew> e.g, putStrLn :: String -> IO (), it takes one string and prints it out
23:22:59 <ValarQ> Megzl: C++ simple?
23:23:14 <basti_> if C++ is simple, haskell is too, for sure...
23:23:15 <Korollary> Megzl: You may find something to like about yourself as well. But you have some reading to do. I must admit that as a c++ programmer, if I were in your place now, a lot of what has been just said to you won't make any sense.
23:23:16 <basti_> ;)
23:23:33 <ValarQ> Megzl: never tried ordinary ANSI C? ;)
23:24:05 <basti_> youre really not in an unusual situation Megzl. most people who see haskell the first time are utterly confused. but thats not because we are evil, or stupid, or because we're snobs.
23:24:13 <Megzl> I've done a little bit of C.
23:24:16 <Megzl> I don't like C.
23:24:20 <Korollary> I thought we were snobs...
23:24:21 <Megzl> it's not expressive enough.
23:24:21 <humasect> Haskell For C Programmers is nice.
23:24:34 <humasect> megzi that was my first reason too.
23:24:40 <Cale> I don't like C++. It's not expressive enough. :)
23:24:50 <ValarQ> Megzl: if you wan't a simple expressive language i guess you have come to the right place ;D
23:25:03 <dons> anyone else want to go on the http://www.haskell.org/hawiki/HaskellUserLocations page before I regenerate the map..
23:25:12 <Korollary> dons: I should try
23:25:24 <dons> Korollary, or just msg me your gps coords.
23:25:34 <dons> then there's no need for a write mvar on the page ;)
23:25:45 <Megzl> Haskell reminds me of what I read about APL.
23:25:49 <Megzl> arcane symbols.
23:25:59 <basti_> ahhh. they're not arcane.
23:26:05 <Megzl> writing code that does lots of things in 25 characters.
23:26:12 <ValarQ> dons: i could try to get my cords...
23:26:33 <skew> Cale: it's fairly expressive, just too good for me to control at expressing things like memory leaks, off by one errors and segfaults
23:26:37 <dons> it's pretty easy via google, without needing some gps device.
23:26:42 <araujo> dons, leaving out align , xearth will still show my location right?
23:26:45 <Megzl> Let me paste a little function.. tell me how I'd do this in Haskell
23:26:53 <dons> some guy has almost always posted some coords close to you /me generalises
23:27:02 <dons> araujo, yes, I think so.
23:27:10 <Megzl> http://www.rafb.net/paste/results/9zt9Sx34.html
23:27:13 <dons> align is a hint to help it out in crowded locations.
23:27:18 <Megzl> All of those lines there are pretty basic and imperative.
23:27:21 <araujo> i see
23:27:24 <humasect> i've got my coords.
23:27:25 <Megzl> basic math functions, basic API calls
23:27:53 <Korollary> Megzl: got anything smaller ? That's a bit lengthy
23:27:56 <Cale> http://www.haskell.org/hawiki/HaskellOpenGl
23:27:59 <humasect> Megzi, allow me
23:28:22 <Cale> that's a fairly imperative program written in Haskell using OpenGL
23:28:44 <ValarQ> dons: add me, add me :) 56.816 16.333
23:28:46 <Megzl> I don't see how you could really make this function any more expressive.
23:28:51 <dons> ok :)0
23:28:58 <Megzl> each of those lines are needed. I can't simplify it any more.
23:29:04 <Megzl> Even something like:
23:29:06 <Megzl> "ent->estimateVertexCount((nSegs*4) * nRings);"
23:29:12 <Megzl> really expresses such a simple concept as
23:29:18 <sethk> Megzl, there is a book by Hudak which uses as it's running examples geometric and graphics computations
23:29:22 <Megzl> the estimate vertex count EQUALS nsegs*4*nRings
23:29:31 <Cale> Megzl: in Haskell, IO actions are first class values and can be packed into lists and such, as well as being composed with each other into bigger IO actions
23:29:32 <basti_> it doesnt equal
23:29:35 <basti_> it's assigned
23:29:40 <sethk> Megzl, in that particular case the haskell implementation would be more or less identical
23:29:42 <Megzl> yeah, you know what I mean
23:29:48 <sethk> Megzl, at least it would more or less look identical
23:29:57 <skew> Well, it depends on how the library works
23:30:04 <skew> sethk: I wouldn't go that far
23:30:17 <sethk> skew, the line he gave above?  sure it is identical
23:30:35 <Megzl> How about my function...
23:30:42 <sethk> estimateThing segs rings = segs * 4 * rings
23:30:54 <dons> anyone else know their coords? my xglobe compile is taking a while..
23:31:04 <dons> (hmm. qt3 dependency..)
23:31:21 <sethk> http://www.infoplease.com/cgi-bin/id/A0001769
23:31:27 <humasect> dons 48 and 123 degrees
23:31:29 <sethk> lat and long of major cities
23:31:35 <dons> humasect, cheerrs
23:31:50 <skew> Megzl: still guessing at the API you are using
23:31:51 <Korollary> sethk: No Seattle
23:31:52 <sethk> dons, is there a qt interface to ghc?
23:32:03 <sethk> Korollary, http://www.infoplease.com/ipa/A0001796.html
23:32:10 <kolmodin> autrijus' -Ofun is slashdotted: http://developers.slashdot.org/developers/05/10/09/1831219.shtml?tid=156
23:32:14 <humasect> skew, it's code he is wishing to express more directly
23:32:14 <sethk> Korollary, that's us and canada
23:32:16 <dons> humasect, -123 degrees?
23:32:28 <Megzl> the API is Ogre3d
23:32:31 <humasect> +123 yes sorry
23:32:39 <Korollary> sethk: ah, yes
23:32:53 <humasect> it's canada + us list i'm looking at so i think all positive (i see no negs)
23:33:21 <dons> +123? where does that  put you?
23:33:31 <humasect> on an island
23:33:33 <dons> japan?
23:33:37 <humasect> west of the american continent
23:33:37 <araujo> Oh my god, i am the only haskeller in the sub-continent?!
23:34:11 <basti_> Megzl: there is "IORefs" which are basically "mutable variables". You can put values there with writeIORef :: IORef a -> a -> IO (), for example
23:34:16 <Korollary> araujo: I don't think so.
23:34:21 <Cale> Megzl: I don't think there's currently an Ogre3D library in Haskell -- would you like me to rewrite it in a somewhat Haskell looking skin?
23:34:35 <Megzl> Cale: yes, please.
23:34:38 <dons> humasect, but you're definitely +123 (i.e. slightly west of australia, not -123, west-coast US?)
23:34:42 <araujo> Korollary, you here too?
23:34:50 <Megzl> I just wrote this torus a few hours ago, I want to see what a torus would look like in Haskell
23:34:56 <basti_> Megzl: other than replacing "=" with "writeIORef" etc., you can implement the exact same algorithm you pasted.
23:34:57 <Megzl> by the way, the operators are...
23:34:57 <humasect> i guess it is -123, i'll look somewhere else to be sure.
23:35:02 <Korollary> araujo: no, but I believe there are a few other people from s america
23:35:05 <Megzl> Vect vFrame0 = rot * X;
23:35:16 <humasect>  48.44792 degrees North, 123.37347 degrees West
23:35:24 <Megzl> rot * X; // X is a vector.. rot is a Quaternion... rot*X rotates X by rot
23:35:26 <dons> it's -123 then :)
23:35:28 <humasect> yeah =)
23:35:30 <humasect> thanks
23:35:35 <araujo> Korollary, of course, ;-)
23:35:48 * araujo hopes to see this crowded 
23:36:00 <Megzl> X is a constant for Vect(1,0,0)
23:36:07 <basti_> Megzl: our type system allows for checked-length vectors/matrices/whatevers.
23:36:25 <Megzl> sorry basti, I don't mean a vector as in std::vector<float> x;
23:36:29 <humasect> what is the very center of the image dons?
23:36:34 <Megzl> a Vector3 with overloads for 3d operations
23:36:36 <Megzl> 3d vector.
23:36:44 <dons> qt3 is still compiling way, in case anyone else wants to add their coords..
23:36:53 <basti_> ah
23:36:56 <dons> humasect, not sure yet. i haven't finished compiling the code that will render the image
23:36:58 <basti_> well these are lists for us
23:37:13 <humasect> okay it just seems like lots of people live there
23:37:16 <basti_> a list is much like a std::vector
23:37:23 <humasect> a Haskell Area
23:38:00 <basti_> lots of things can be done by lists.
23:38:10 <basti_> for example, if we have a list of IO scripts, we can do them in a row.
23:38:11 <humasect> Megzi: i wouldn't mind seeing Ogre3D in haskell. i've thought of it...
23:38:23 <Megzl> a few guys on #Ogre3d are writing Ogre code in Haskell
23:38:31 <Megzl> one guy made a game with haskell and ogre3d
23:38:42 <Korollary> neat
23:38:54 <Megzl> there's something like pyogre but for haskell
23:39:19 * dons computes the coordinates of lambdabot
23:39:32 <boegel> Megzl: sounds cool, link ?
23:39:42 <Korollary> whoah, ghc is eating 100+ megs
23:39:44 <boegel> I can add it to the H3D wiki then
23:39:50 <Megzl> I don't know a link, boegel
23:40:06 <humasect> ahh it was boegel... H3D...
23:40:08 <Megzl> I'll ask someone I know, about how he does it.
23:40:08 <basti_> Megzl: basically, I don't think converting your torus code would bring a lot of insight
23:40:30 <humasect> i just found this page again. going to edit myself in
23:40:31 <Megzl> Basti: That's why I used it as an example. I was saying that the code couldn't be expressed any other way
23:40:34 <Megzl> besides just replacing some symbols
23:40:54 <basti_> Megzl: well it would need to, for example, the loops would probably be replaced by maps
23:40:54 <Cale> ent->position(v1 * size);
23:40:54 <Cale> ent->normal((v1-vFrame0).normalisedCopy());ent->textureCoord(seg/nSegs, ring/nRings);
23:40:58 <Cale> whoops
23:41:04 <Megzl> Ok... here's another difficult question for you guys.
23:41:05 <Cale> that could be abstracted
23:41:10 <Megzl> Probably the most difficult
23:41:14 <basti_> (there are no loops like in C++ in haskell)
23:41:17 <ValarQ> Megzl: :-O
23:41:28 <Megzl> This is the hardest question about haskell, for me.
23:41:32 <basti_> but the result would look the same, except for the subtilities that you don't get yet.
23:41:50 <basti_> you'd see lots of similar code and a few arcana inbetween
23:42:32 <Megzl> Why not Python? Why not Ruby? Why not OCaml? Why not Perl6? Why not Dylan?
23:42:45 <basti_> thats inviting zealotry.
23:42:47 <ValarQ> Megzl: why not more than one language?
23:42:47 <smott> troll
23:42:58 <Megzl> Cale: I could abstract that in C++ further, with a local functor.
23:43:01 <sethk> Megzl, other than perl, there aren't general answers to that question
23:43:03 <Cale> I think it's a good question
23:43:14 <sethk> Megzl, each of those languages (other than perl) has its place
23:43:18 <Cale> But one without a short answer
23:43:26 <basti_> even perl has its place, imo
23:43:32 <Megzl> But it's too much for me.
23:43:36 <Cale> and yes, those other languages are decent
23:43:36 <ValarQ> without perl, lol :)
23:43:39 <Megzl> I want to learn one other lang besides C++
23:43:44 <Megzl> I already have to deal with both Lua and C++
23:43:47 <Megzl> i use Lua for scripting
23:43:47 <sethk> basti_, I disagree, there are much better languages of the same class as perl
23:43:49 <Cale> Perl6 is even getting decent thanks to Autrijus
23:43:52 * ValarQ uses C and python quite heavy
23:44:02 <Cale> though it does look a little crazy
23:44:03 <Cale> :)
23:44:05 <basti_> Megzl: you haven't learned a different language if you've not learned a functional or logic oriented language
23:44:14 <sethk> Megzl, there is no difficulty learning python and ruby if you already know a few other languages
23:44:26 <sethk> Megzl, your limit of two is entirely arbitrary and not sensible
23:44:37 <Megzl> Ok, so you're saying I should learn Haskell since it's the only one of those languages that really has a completely different paradigm to it
23:44:55 <basti_> no its not the only one
23:45:11 <Korollary> ocaml is a lot like haskell
23:45:14 <Megzl> I want a language where you program the syntax.
23:45:18 <basti_> just one with lots of recognition and a wide base.
23:45:22 <Megzl> C++ doesn't let you code the syntax.
23:45:22 <basti_> like haskell you mean.
23:45:33 <basti_> we have infix functions.
23:45:47 <Megzl> I want a language that's all about letting me code any kind of syntax I can dream up.
23:45:55 <basti_> just like haskell.
23:45:57 <Megzl> You guys are telling me Haskell is so fixed on this functional idea
23:46:03 <Cale> x +!+ y = x - y + (x * y)
23:46:03 <Megzl> what if I wanted to code a C++ like syntax
23:46:06 <Itkovian> dons: I'm at N 51Â° 14'   E 002Â° 55'  or somewhere in that neighbourhood
23:46:07 <basti_> its not "so fixed"
23:46:16 <ValarQ> Megzl: why don't you install ghc and try experimenting with some code and maybe a tutorial?
23:46:18 <basti_> you just can't get around the fact
23:46:21 <ValarQ> Megzl: see for yourself
23:46:25 * basti_ nods
23:46:32 <Cale> Haskell syntax isn't 100% flexible -- that would be silly.
23:46:35 <basti_> just try and see if you like it.
23:46:38 <shapr> Megzl: http://www.haskell.org/hawiki/HaskellDemo
23:46:45 <Cale> But it lets you define your own control structures
23:46:46 <basti_> @plugs map (+10) [1,2,3]
23:46:46 <Korollary> yay, shapr has arrived
23:46:48 <Cale> and abstractions
23:46:53 <lambdabot> [11,12,13]
23:46:53 <sethk> Megzl, if you want to code a c++ like syntax, then use c++
23:46:55 <basti_> thats what made me go "wow" when i didnt know haskell
23:46:56 <Cale> and lets you define infix operators
23:47:07 <ValarQ> Megzl: this helped me: "Haskell Tutorial for C Programmers" -- http://www.haskell.org/~pairwise/intro/intro.html
23:47:20 <dons> Itkovian, you want to update the entry?
23:47:37 <dons> Itkovian, it currently says: 51.15         2.54
23:47:48 <Itkovian> ah
23:47:50 <Itkovian> erm
23:48:02 <Megzl> I don't want 100% syntax programmability for the base language.
23:48:06 <Itkovian> nah, leave it be then, I missed my entry
23:48:07 <Megzl> Only to be able to define new syntaxes.
23:48:14 <dons> :)
23:48:23 <basti_> Megzl: well haskell has a parser thats modifiable at runtime.
23:49:07 <dons> ok, last chance anyone to get on the map! http://www.haskell.org/hawiki/HaskellUserLocations
23:49:14 <dons> rendering commences in 60 seconds..
23:49:16 <basti_> and then it has easy and obvious general rules.
23:49:28 <sylvan> I think Haskell could sort of use a macro language.. If only to provide syntax extensions for EDSLs... Not as a necessity, but as a convenience, in other words
23:49:29 <ValarQ> dons: the rendering of the year?
23:49:36 <basti_> sylvan: like TH?
23:49:52 <shapr> dons: Are you using xplanet?
23:49:59 <sylvan> Well, I'm not all that into TH, admittedly, but more like Nemerle's macro language
23:50:01 <dons> I'm going to try xglobe.
23:50:11 <dons> it's what we use for the OpenBSD kernel hackers locations
23:50:15 <shapr> nifty
23:50:29 <sylvan> which is simple and powerful for basically everything I'd want to use it for
23:50:36 <shapr> Megzl: Hey, you can't tell if you'll like it until you've tried it.
23:50:40 <Cale> Megzl: well, you'll kind of get that with Haskell -- not completely, but sort of.
23:50:49 <Cale> I recommend that you try it.
23:51:08 <shapr> Megzl: The first lambda is free man ;-)
23:51:12 * shapr tokes on a lambda
23:51:15 <sylvan> =)
23:51:18 <ValarQ> :)
23:51:23 <basti_> trying is easy.
23:51:25 * Korollary challanges shapr to a lambda duel
23:51:27 <Cale> It's by quite a large margin, my favourite of the 10-15 or so languages that I know reasonably well.
23:51:36 * ValarQ prefer the taste of list comprehensions
23:51:41 * shapr puffs on a large redex
23:51:56 <basti_> you can even try only with lambdabot
23:52:01 <basti_> if youre scared to install ghc
23:52:05 * Korollary cheats by using impure code
23:53:02 <shapr> Megzl: Is that HaskellDemo readable?
23:53:18 <earthy> interestingly, the map location for kosmikus is wrong there
23:53:19 <Megzl> No.
23:53:22 <Megzl> shapr: Not at all.
23:54:14 <sylvan> heh
23:54:27 <shapr> Well, two ways to look at that, a) there's an entirely new paradigm out there or b) I need to improve that page
23:54:42 <sylvan> or c) both
23:54:47 <shapr> heh, yes
23:54:59 <earthy> dons? how are we going to suggest updates to the haskell user locations?
23:55:06 <basti_> or d) neither, but thats silly.
23:55:09 <dons> suggest updates?
23:55:22 <dons> well, add some new entries, then I'm happy to re-render the image
23:55:31 <sylvan> There may need to be two pages, one for complete programming newbies, and one for old C programmers... Exactly how they would be different isn't immediatly obvious, though =)
23:55:36 <basti_> Megzl: so are you trying to try?
23:55:39 <earthy> problem is the page is immutable.
23:55:44 <Megzl> Giving you a little hint on the page.
23:55:48 <Megzl> Starting from the top, and going down.
23:55:57 <dons> ah, no it isn't ;)
23:55:59 <Megzl> the number and string ones make sense
23:56:01 <dons> you have to log in
23:56:03 <shapr> earthy: Oh, that. I changed the wiki to "Known" during a spam attack yesterday.
23:56:19 <earthy> sylvan: explaining thunks in terms of functionpointers will work to old C hands
23:56:29 <Megzl> once you get to "
23:56:29 <Megzl> -- this reads as "takes an Integer and produces an Integer".
23:56:33 <earthy> however, n00b's won't understand
23:56:35 <Megzl> there's not enough explanation.
23:56:37 <earthy> shapr: 'ah'. ;)
23:56:44 <Megzl> "this" -- I dont even know what this is
23:56:55 <basti_> Megzl: the line with the :: inside
23:57:00 <Megzl> add1
23:57:03 <Megzl> or add1 ::
23:57:08 <Megzl> or add1 :: Integer -> Integer
23:57:10 <basti_> add1 :: Integer -> Integer
23:57:17 <basti_> "this line" means...
23:57:35 <Cale> add1 is of type function from Integer to Integer
23:57:44 <sylvan> Yeah so maybe it should explain what a type signature is.. Like "::" means "of type" or something ilke that
23:57:58 <Megzl> there you go sylv
23:58:03 <Megzl> You need to make less assumptions
23:58:19 <basti_> Megzl: most people can make that assumption in their heads.
23:58:19 <Korollary> it's a wiki, yes. let's fix it.
23:58:21 <Megzl> You need to forget you know haskell
23:58:21 <ProfTeggy> Morning all.
23:58:25 * shapr is fixing
23:58:54 <Megzl> "-- but you can assign these anyway" // no idea what this means
23:59:11 <basti_> you can put a name to an expression
23:59:17 <basti_> "add2 ="
23:59:32 <Cale> Megzl: even though the function is anonymous, you can assign it a name with =
23:59:36 <ValarQ> shapr: and maybe the first line should be  -- this is a comment
23:59:43 <shapr> heh, maybe so.
23:59:44 <Megzl> You didn't explain what anonymous is
23:59:51 <Megzl> a C++ coder has no idea what that means
23:59:55 <basti_> anonymous means "doesnt have a name" to me
23:59:56 <Cale> anonymous means that the function doesn't have a name
23:59:57 <basti_> what does it mean to you?
