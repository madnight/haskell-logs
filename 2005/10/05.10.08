00:06:31 <araujo> Anyone got some readline code around that i could take a look at?
00:16:16 <shocker> how can i open a file and make each line into list item, then print the entire list?
00:17:30 <Lemmih> dons: Did we decide on LGPL?
00:17:49 <Lemmih> shocker: \path -> print =<< fmap lines (readFile path)
00:18:59 * Lemmih kinda felt that LGPL was forced upon him.
00:19:48 <shocker> Lemmih: how do u specify the file to open?
00:20:23 <Lemmih> shocker: readFile :: FilePath -> IO String.
00:21:57 <shocker> whatever
00:22:30 <Lemmih> shocker: 'readFile' reads a file lazily.
00:24:35 * araujo found something ....
00:24:42 <araujo> mmm.. easier than i thought
00:27:16 <araujo> is there a way to use pattern matching in a lambda function?
00:27:56 <Lemmih> @eval (\(Just n) -> n) (Just 10)
00:28:03 <lambdabot> 10
00:28:21 * araujo scratches his head
00:32:17 <araujo> Lemmih, Thanks ....
00:32:25 * araujo making stupid mistakes
00:36:42 <dons> hi Lemmih
00:37:22 <dons> I was thinking we should make sure all our files are licensed. I started off putting LGPL copyright "The hIDE Team" in those that aren't licensed atm.
00:37:51 <dons> the LGPL discussion is on the wiki. I think dcoutts was concerned about linking against non-free apps.
00:37:57 <basti_> actually, files without any license do not have any licens
00:38:08 <basti_> you'd have to ask the author to work with these sources
00:38:42 <basti_> but then again, as an informal, but accepted rule one could think that the same license applies as it does for "the other files" (of the package)
00:39:06 <dons> yes. but that's sloppy :)
00:39:14 <basti_> yep
00:39:26 <basti_> btw. i had a look. jyp's code is so much better than mine :(
00:40:27 <basti_> his code will be able to do the same tricks as mine, with half the effort
00:40:49 <basti_> (it can't reflect yet, but a comment states that this will be done via "eval")
00:41:31 <dons> oh, i'm not sure it's "better". but he got further along .
00:42:27 <dons> hmm. eval eh?
00:42:55 <basti_> yes eval
00:43:02 <basti_> i think its better from a style point of view
00:44:12 <basti_> i was particularly impressed how easy he accomplished the repetition
00:45:04 <Korollary> What is the equivalent of popen for ghc libs ? the handle created by runInteractiveProcess is not seekable.
00:47:41 <dons> hmm. seekable. interesting.
00:48:36 * basti_ doesnt even understand the problem
00:49:14 <Korollary> basti_: I'm trying to connect to programs. The consumer wants to seek in its stdin, but the producers stdout is not seekable, so it bails out.
00:49:23 <Korollary> s/to/two
00:49:29 <basti_> hmmm
00:49:43 <Korollary> namely, flac --decode and lame
00:49:43 <basti_> i thought stdin is defined as not being seekable.
00:50:30 <basti_> but if flac does it, it probably isnt
00:50:37 <Korollary> lame manual says it will seek to detect wav/aiff headers when input is "-".
00:50:50 <basti_> hmm
00:51:10 <basti_> maybe you can work around that? put a cat before it?
00:51:32 <Korollary> cat's stdout would be in the same situtation I think
00:51:53 <basti_> you need a binary pager :/
00:53:41 <Korollary> well, I could use a temp file, but then I have to run them sequentially
00:54:05 <basti_> :/
00:54:44 <basti_> how does the failure look like, btw?
00:55:26 <Korollary> it intermittently fails and when it does, lame says "assuming raw pcm" and then "error reading input".
00:56:12 <basti_> hmm
00:57:01 <basti_> maybe you make a named pipe and use that instead?
00:57:05 <basti_> are these seekable?
00:57:07 <Korollary> or I could create the pipe myself via mkfifo
00:57:23 <basti_> stereo morons.
00:59:53 <TFK> Hi all
01:05:17 <boegel|home> y0 Maddas
01:05:24 <Maddas> @yow
01:05:25 <lambdabot> I just remembered something about a TOAD!
01:05:30 <Maddas> What's up, boegel|home?
01:07:07 <lightstep> is there an errata page for the bananas paper? it seems that the two definitions of 'fac' are buggy
01:07:10 <bourbaki> moin
01:07:55 <bourbaki> anyone of you awake and familiar with category theory and coalgebras?
01:08:04 <basti_> just a bit
01:08:14 <Maddas> If this would be any other channel I would consider it a joke (:
01:08:27 <Korollary> maybe not in #math
01:08:35 <Maddas> Right, I almost wanted to mention that exception :-)
01:08:49 <bourbaki> well the coalgebra thingy is connected to moandas and arrows though
01:08:54 <Maddas> (Nothing wrong with coalgebra, of course)
01:08:58 <bourbaki> my idea is to model programs as coalgebras
01:09:14 <bourbaki> and build oparators over them that follow the arrow notation
01:09:24 <basti_> bourbaki: uhm thats not exactly a new idea.
01:09:38 <Maddas> Any HOC (Haskell/Objective-C bridge) users here?
01:09:41 <bourbaki> where has anyone written about that yet?
01:09:45 <basti_> but its nice that you found out yourself.
01:09:52 <basti_> i heard a lecture about that possibility
01:09:54 <bourbaki> well but i connect it also to topology
01:09:56 <dons> Maddas, ozone wrote it , and he's often around
01:10:02 <bourbaki> and graph theory
01:10:10 <basti_> not getting into the details, but pretty extensive
01:10:12 <Maddas> dons: Cool, thanks for the tip
01:10:16 <basti_> yes, thats a known fact too.
01:10:21 <basti_> it doesnt help though.
01:10:28 <bourbaki> basti_ can you please search taht lecture papers again?
01:10:31 <bourbaki> it does
01:10:34 <basti_> I have a book handy
01:10:35 <boegel|home> Maddas: nothing really, just chillin'
01:10:39 <bourbaki> cause i have build some language on it
01:10:57 <bourbaki> that is able to model most of the standard ai techniques in a single framework
01:10:59 <Maddas> boegel|home: Sounds good enough
01:11:02 <basti_> Ihringer "Allgemeine Algebra" with an appendix by Gumm (my prof) about Coalgebra
01:11:42 <basti_> it explains bisimilarity, and stuff like that
01:11:47 <bourbaki> ok but a problem at least to me with the usual automaton theory is
01:11:48 <basti_> hmm and notes
01:11:55 <bourbaki> that its not selfmodificable
01:12:10 <bourbaki> and that its also not able to model complex constructions
01:12:18 <basti_> gotem
01:12:25 <bourbaki> i can do the same thing as cw stuff in topology
01:12:31 <bourbaki> gotem?
01:12:41 <bourbaki> yeah i have a paper on that too
01:12:46 <ski> (not selfmodificable meaning ?)
01:12:54 <bourbaki> universelle coalgebraen
01:12:59 <bourbaki> well like in lisp
01:13:06 <bourbaki> the programs can change themselves
01:13:17 <bourbaki> my programs run on hypergraphs
01:13:21 <ski> dynamic loading ?
01:13:22 <bourbaki> or hyperprograms
01:13:36 <bourbaki> something like that yes you can implement dynamic loading with is
01:13:42 <bourbaki> with simple substitution
01:13:42 <basti_> bourbaki: "got them"
01:13:51 <bourbaki> basti_ can you send them via dcc?
01:13:58 <basti_> no because they're written on paper.
01:14:03 <basti_> i think there is no script
01:14:13 <basti_> but I'll have a look
01:14:34 <bourbaki> cool thanks
01:15:19 <basti_> http://www.mathematik.uni-marburg.de/~cmcs/
01:15:54 <bourbaki> thanks
01:15:59 <ski> (hmm .. Jiri Ad√°mek ..)
01:16:20 <basti_> no official script though
01:16:21 <bourbaki> i got a paper from that guy too
01:16:27 <ski> (coauthor of 'the joy of cats' iirc)
01:16:50 <bourbaki> the cool thing is that in the end you will be able to mix all the ai standard techniques
01:16:52 <ski> (um .. maybe it
01:16:56 <bourbaki> just by connecting them
01:17:07 <ski> 's name was 'abstract and concrete categories')
01:17:09 <basti_> Gumm is really a great guy. he has social deficits, but he is a great teacher, and he knows what's important
01:17:14 <bourbaki> all you need to to is to model a function that maps form your problem doman to the input domain
01:17:43 <basti_> and he does CT even though he's not into FP all that much
01:17:51 <ski> (basti_ : asperger or something ?)
01:17:53 <bourbaki> ok but if all this is already known why isnt it used in fp?
01:18:04 <basti_> ski: maybe :P
01:18:05 <bourbaki> aspegners syndrom
01:18:15 <bourbaki> er whatever :)
01:18:20 <ski> *aspergers syndrome
01:18:28 <basti_> bourbaki: lots of it is used.
01:18:38 <basti_> recently i saw people debate on here how to realize equalizers in haskell
01:18:51 <bourbaki> what for?
01:19:01 <basti_> uhm, to see what they could be good for.
01:19:03 <bourbaki> well the program thingy i have in mind is a topos
01:19:04 <basti_> maybe.
01:19:10 <basti_> and then? ;)
01:19:11 <ski> to see if one could have a haskell topos
01:19:14 <bourbaki> so you can do all kinds for funky crunshing on them
01:19:39 <basti_> it won't make your processing more powerful
01:19:45 <bourbaki> it will
01:19:56 <basti_> i won't stop you either.
01:19:56 <bourbaki> cause i can see the structure of a program
01:20:05 <bourbaki> and i can build qoutient programs
01:20:09 <ski> possibly it can make the theory more coherent/orthogonal ..
01:20:22 <bourbaki> and also i can bulid direct sums for program
01:20:23 <bourbaki> s
01:20:27 <ski> (which can help weed out bad special cases, optimisations, etc)
01:20:37 <basti_> like, "programs that you'd never have programmed anyway" (quotient programs)
01:20:45 <basti_> or "alternatives" (sums)?
01:21:01 * ski thinks quotients are often implicitely used in programminf
01:21:05 <bourbaki> well the idea is that you build a program
01:21:05 <ski> s/f/g/
01:21:09 <bourbaki> but you dont implement it
01:21:19 <bourbaki> but you have already a lib at hand that implements some structures
01:21:28 <bourbaki> then you can search all your libs for known structures
01:21:34 <basti_> you mean, like we're doing all the time.
01:21:39 <bourbaki> and all these will be used (via graph matching)
01:21:50 * basti_ is just playing advocatus diaboli right now
01:22:01 <bourbaki> well in the usual programs you use libs
01:22:13 <bourbaki> just by calling the name of the lib and the function
01:22:14 <basti_> you know that what we call "programming" is an NP-Complete problem?
01:22:20 <bourbaki> what i do is all about the structure
01:22:38 <bourbaki> sure you dont have all possible structurals
01:22:49 <bourbaki> but since i have all termingal coalgebras in theory i can
01:23:02 <basti_> you think you can, you want to say ;)
01:23:04 <bourbaki> with these i am able to build all programs as direct sums
01:23:16 <bourbaki> topologically gluing them
01:23:55 <bourbaki> and you can search for structures
01:24:05 <bourbaki> you cant do that yet in the known languages
01:24:14 <bourbaki> maybe in labview or so not sure about these
01:24:25 <basti_> youre rather talking funny interfaces then?
01:24:35 <bourbaki> and you can make modules automatically from programs
01:24:35 <basti_> as opposed to funny programming languages
01:24:45 <basti_> all my programs are modules.
01:24:47 <bourbaki> ie you have 10 programs and you want to know what they have in common
01:24:49 <bourbaki> and make that a module
01:25:00 <bourbaki> a module in my terminiology is a subgraph
01:25:04 <basti_> its just that my operating system is not bright enough to understand a module.
01:25:23 <bourbaki> well my idea is to use the linux virtual file system for my language
01:25:32 <bourbaki> so you can use all the devices as input and output nodes
01:25:46 <basti_> like every program on linux does?
01:26:05 <bourbaki> sure but you just can click it altogether with graphs
01:26:06 <ski> (bourbaki : what about labview ?)
01:26:19 <basti_> ah you want "graphical programming"
01:26:29 <bourbaki> ski i dont know if you can search for structures on a labview program
01:26:29 <basti_> ski: you dont know labview?
01:26:42 <basti_> bourbaki: subgraph isomorphism is NP complete.
01:26:46 * ski has looked a little at labview
01:27:00 <bourbaki> basti_ sure but you can do that for finite programs
01:27:15 <basti_> its decideable yes
01:27:18 <basti_> but NP-complete
01:27:22 <bourbaki> and also due to the topology i will be able to find the homology of a program
01:27:39 <bourbaki> wich helps me in the end to get the terminal programs
01:27:41 <ski> from what little i grasped .. it seemed to be a graphical notation for variables (signal lines) and ways of composing those
01:27:44 <basti_> which will be a NP-complete problem too.
01:27:48 <bourbaki> and also categorizeing all programs
01:27:54 <basti_> ski: yes.
01:28:01 <bourbaki> and also i can use all the stuff from knot theory for layout
01:28:22 <bourbaki> the idea is that once i have all this i can write my ai in this stuff
01:28:25 <ski> basti_,bourbaki : so i guess i don't see how labview would be different enough to be relevant for this ..
01:28:26 <bourbaki> and apply it to itself
01:28:39 <bourbaki> well my programs are algebraic programs
01:28:43 <bourbaki> you can add them and so
01:28:44 <basti_> bourbaki: bascially youre saying a) I'll invent X, b) ...? c) instant AI
01:28:52 <bourbaki> and to all kind of fancy stuff with then
01:29:00 <basti_> ski: bourbaki wants to reimplement labview ;)
01:29:02 <bourbaki> basti_ i need a foundation for my thesis
01:29:18 <bourbaki> no labview is not powerful enough for what i have in mind
01:29:22 <basti_> bourbaki: hint: all thoughts ending with "instant AI" are inherently broken ;)
01:29:25 <bourbaki> and also it needs to be mathematically founded
01:29:43 <bourbaki> no the idea is to make all standard ai techniques usable in one framework
01:29:50 <bourbaki> and visualize it
01:30:05 <bourbaki> and allow things like self changeing
01:30:09 <ski> i don't understand what in labview would be closer to what(ever) you have in mind
01:30:18 <bourbaki> for backpropagation for example
01:30:34 <lightstep> didn't fudgets include self-modification too? and arrows?
01:30:39 <ski> consistency, orthogonality ?
01:30:40 <bourbaki> well i can for example habe programs of programs
01:30:51 <basti_> basically, haskell is self-modifying
01:30:54 <Maddas> Do you know Quartz Composer? It's not any 'proper' programming language, but kind of nifty to play around with
01:31:05 <bourbaki> orthogonality is just up to the terminal program problem
01:31:14 <ski> ('self-modifying' is not a very clear term)
01:31:24 <bourbaki> and its consistent cause i lend a lot form petri nets
01:31:37 <bourbaki> well i want to be able to structurally modify the programs
01:31:49 <bourbaki> graphs that is and also change edges in this graph
01:31:56 <basti_> to lose the type system?
01:32:07 <bourbaki> no the type system is always in there
01:32:10 <bourbaki> cause its a topos
01:32:16 <bourbaki> its strong types
01:32:19 <bourbaki> er typed
01:33:52 <bourbaki> and for example you will be able (at least theoretically) to search neural nets in neural nets
01:34:14 <bourbaki> and or have neural nets over neural nets
01:34:23 <basti_> subgraph isomorphism is NP-complete
01:34:49 <basti_> I'm terribly sorry, but it is.
01:34:53 <bourbaki> yes but its better to get this tool although its np complete instead of not haveing it
01:35:11 <bourbaki> and also in the end it will be applicable to all the standard techniques then
01:35:28 <basti_> a ha.
01:35:32 <ski> hm, should the neural nets denotation be fed into the neural net or some structure, like an AST, that describes it ?
01:35:41 <bourbaki> ast?
01:35:48 <ski> abstract syntax tree
01:35:54 <bourbaki> maybe :)
01:36:13 <bourbaki> i think this depends on the implementation of the group operators on neural nets
01:36:41 <ski> (often intial (anarchic) F-algebras .. sometimes quotients over alpha-equivalence, or something)
01:37:06 <ski> (/quotients/quotiented/)
01:37:11 <bourbaki> then i guess so yes
01:37:17 <ski> which ? :)
01:37:23 <ski> first or second alternative ?
01:37:23 <bourbaki> quotient spaces
01:37:37 <bourbaki> hm
01:37:40 <ski> no, i meant .. denotation, or ast ?
01:37:56 <bourbaki> whats the difference?
01:38:28 <bourbaki> i want to have initial programs to for they will behave like haskell classes
01:38:36 <ski> well, e.g. in haskell, if you have a function, all you can do is apply it (excpet seq) .. if you have an ast describing a function, you can analyze it internally
01:38:43 <bourbaki> that is the actual class implementation is just a functor for fills the edges with real functions
01:38:59 <bourbaki> ah the its clearly an ast
01:39:13 <ski> i.e. this could be seen as diff between quotation or not ..
01:39:20 <ski> ok
01:39:29 <bourbaki> thats why you can for example connect programs in non terminateing places
01:39:40 <bourbaki> but i also can build the quotient space on these
01:39:43 * ski doesn't know what that means ..
01:39:45 <bourbaki> which is applying the arrows
01:40:01 <bourbaki> well if you have two automatons you can just concaternate them
01:40:18 <bourbaki> but you cant say that you want to connect node x of graph y with node z of graph w
01:40:20 <bourbaki> i can do that
01:40:34 <bourbaki> as long as the domains match of course
01:40:45 <basti_> just like a regex match sequence operator?
01:40:58 <bourbaki> im not sure
01:41:01 <bourbaki> but i guess so
01:41:24 <basti_> if youre not sure about that, you should maybe study building regexes with combinators before you think about implementing topology
01:41:30 <basti_> just a hint.
01:41:32 <bourbaki> and also you can fold edges (arrows)
01:41:43 <ski> fold meaning ?
01:41:55 <bourbaki> well if you have two edges adjacent
01:42:01 <bourbaki> then you can just fold them into a single one
01:42:10 <bourbaki> wich is called compilation
01:42:22 <ski> hm
01:42:23 <bourbaki> which is the same as building the quotient space over the subgraph
01:42:36 <bourbaki> the recursion gave me a hard time there
01:42:52 <bourbaki> but i think that i can build the quotient there with anamorphisms
01:43:19 <bourbaki> and for the zoom in and zoomout effect i also will store the intial structure for debugging purposes
01:43:34 <ski> zoom ?
01:43:40 <bourbaki> so you can just determine wich part of the program you want to debug
01:43:55 <bourbaki> well if you build the quotient of a subgraph it will be collapsed to a single edge
01:44:03 <bourbaki> wich is possible cause my programs are topos
01:44:20 <ski> are your graphs objects in the cat ?
01:44:21 <bourbaki> so collapsing all the stuff to an edge is like zooming out in an editor
01:44:40 <ski> (hm, i would guess they are)
01:44:44 <SyntaxNinja> w00t
01:44:46 <bourbaki> well in the end these programs will hopeflly bulid a cat of their own
01:44:52 <SyntaxNinja> free wifi at warsaw airport :)
01:44:58 <Maddas> Yow, SyntaxNinja!
01:45:03 <Maddas> Cool :-)
01:45:16 <SyntaxNinja> if anyone's been trying to get ahold of me, try isaac.jones@gmail.com, won't check syntaxpolice.org for another few days.
01:45:51 <bourbaki> i also tried to implement all this in haskell already but failed when i tried to write programs with homegenous graphs
01:46:12 <ski> (hm, surely the quotient doesn't have to collapse all structure to a single edge, right ?)
01:46:24 <bourbaki> ski nope just the subgraph
01:46:32 <ski> what's homogenous graphs ?
01:46:35 <bourbaki> G = big graph, S = subgraph
01:46:47 <bourbaki> then the quotiont is G / S
01:46:57 <bourbaki> graphs made of homogenous lists
01:47:05 <ski> what about the other parts of G ?
01:47:06 <bourbaki> that is a graph is a structure like this
01:47:12 <ski> e.g. G = S + S + S
01:47:17 <bourbaki> G = { V, (V x V)}
01:47:41 <bourbaki> well all of s is collapsed to a single point in that space
01:47:49 <bourbaki> thats like building the limit over the subgraph
01:47:58 <bourbaki> with i am able to build cause its a topos
01:48:10 <ski> so .. at most one edge, and no edge labelling, right ?
01:48:19 <bourbaki> where V is the vertices and they have to be able to be of different types
01:48:28 <bourbaki> sure the labeling is needed
01:48:35 <bourbaki> the labeleing is assigning a function
01:48:40 <ski> bourbaki : but what about the other copies of S, are they also collapsed ? or not ?
01:48:40 <bourbaki> the edges are arrows
01:48:56 <ski> hm, your graph is a cat ?
01:49:07 * ski thought it was an object in a cat
01:49:15 <bourbaki> other copies shouldnt be affected
01:49:25 <bourbaki> cause your subgraph is made of desticnt nodes
01:49:32 <bourbaki> and my graphs should be a cat yes
01:49:52 <bourbaki> the graphs are categories
01:49:54 <bourbaki> themselves
01:50:02 <ski> m-hm
01:50:12 <bourbaki> not objects in other cats though this might turn out to be good at some places
01:50:30 <bourbaki> the programs are like diagrams
01:50:55 <bourbaki> all my programs have an initial and terminal object
01:51:01 <bourbaki> that is source and sink
01:51:12 <bourbaki> and all subgraphs are guaranteed to have this also
01:52:26 <bourbaki> ski_ does it still make sense for you?
01:52:40 <ski_> ('not objects ...' : possibly)
01:53:17 <ski> source and sink corresponds to ?
01:53:23 <bourbaki> input and output
01:53:28 <ski> ('still' is possibly the wrong word :)
01:53:37 <bourbaki> and since these are cartesian products you get the curry thingy for free
01:53:44 <bourbaki> that is ie
01:53:57 <bourbaki> (R x R) -> R x B
01:54:06 <bourbaki> for example can just be split up into
01:54:08 <bourbaki> R x R -> R x B
01:54:24 <bourbaki> and also you can change the order
01:54:32 <bourbaki> which might come in handy also
01:54:36 <ski> i see no diff there ..
01:54:51 <bourbaki> in (R x R) and R x R?
01:54:56 <ski> yes ..
01:55:04 <ski> do the missing parens signify something ?
01:55:05 <bourbaki> its either one or two nodes in the graph
01:55:24 <bourbaki> and the order does not play a role there
01:55:31 <bourbaki> they are all invariants of the same program
01:55:40 <ski> this is edges, i take it ?
01:55:51 <bourbaki> yes
01:55:58 <bourbaki> well its rather like
01:56:07 <bourbaki> R -> R x B <- R
01:56:09 <bourbaki> or
01:56:17 <bourbaki> (R x R) -> R x B
01:56:33 <ski> ah, better :)
01:56:36 <bourbaki> :)
01:56:53 <bourbaki> and on all the edges you can use all the arrow laws
01:57:19 <bourbaki> and for the dynamicness of the programs there is an interpreter that gets "change" functors for the program
01:57:31 <bourbaki> which you can again connect and so as on the normal program level
01:57:55 <bourbaki> that way you can build the c++ class system for example or dynamic structured stacks
01:58:17 <bourbaki> or do the backpropagation in a neural net
01:58:35 <ski> i have to say i don't get the big picture ..
01:58:51 <ski> we seem to be talking details, here
01:58:55 <bourbaki> well i want for example mix neural nets with decision trees
01:59:10 <bourbaki> and embed these things in simple programs
01:59:48 <bourbaki> and also since i can build indeterministic programs i can implement things like planners
01:59:49 <ski> embed how/in what sence ?
01:59:54 <bourbaki> all in the same framework
02:00:01 <ski> s/sence/sense/
02:00:15 <bourbaki> well ie you want to have a program that converts your data to be fed to the neural net
02:00:21 <ski> as built-in language features ?
02:00:29 <bourbaki> and depending on the output you want to either feed a decision tree or a neural net
02:00:36 <ski> indeterministic means ?
02:00:40 <bourbaki> or you want to have a recusice net
02:00:58 <bourbaki> in one node there are more then one possible function that can be applied
02:01:05 <bourbaki> ie for a planner
02:01:06 <ski> don't-care (/demonic) nondeterminism ? don't-know (/angelic) nondeterminism ?
02:01:17 <bourbaki> you are at a place with 4 roads to go
02:01:33 <bourbaki> and they are all equally good
02:01:51 <bourbaki> so you can apply the usual search algoriths to your program
02:01:53 <ski> and you try all ?
02:01:58 <bourbaki> once you have a metric for it that is
02:02:05 <ski> or you pick one somehow and stick with it ?
02:02:13 <bourbaki> that depends on your exploration strategy
02:02:22 <bourbaki> A* for example
02:02:28 <bourbaki> or reinforcement learing
02:02:37 <SyntaxNinja> @wiki
02:02:37 <lambdabot> http://www.haskell.org/hawiki/
02:02:38 <bourbaki> with if you will apply this is like dynamic programming
02:02:52 <bourbaki> and also you can do genetic programming really easy
02:03:24 <bourbaki> and with the homology for example of the explored paths (functions) form that program
02:03:26 * ski is not very familiar with genetic programming, neural networks ..
02:03:29 <bourbaki> you can tell if they have loops
02:03:50 <ski> they  = ?
02:03:57 <bourbaki> and you can easily calculate the complexity of a program
02:04:01 <bourbaki> the paths
02:04:04 <bourbaki> the functions that is
02:04:08 <ski> (Halting Problem ?)
02:04:25 <bourbaki> do you know a*?
02:04:36 <ski> it's the path-searching algo, right ?
02:04:45 <bourbaki> yes
02:04:46 <ski> (in square-grid)
02:04:53 <ski> i have looked briefly at it
02:04:55 <bourbaki> no in any metric space
02:04:58 <ski> (not much)
02:05:01 <ski> ok
02:05:08 <bourbaki> well you can apply this to your problem here for example
02:05:19 <bourbaki> and this is garanteed to hold if there is a node in finite steps
02:05:25 <bourbaki> that is terminateing the program
02:05:39 <bourbaki> and you cut off loops cause you have been there already
02:05:48 <bourbaki> ockhams razor that is
02:05:55 <ski> space complexity of this ?
02:06:06 <bourbaki> space complexity is just pathlength
02:06:21 <ski> no, of this algo analyzing the program
02:06:22 <bourbaki> time complexity is the sum of all time profiles of all elements
02:06:23 <bourbaki> of the path
02:06:37 <bourbaki> oh sry dont know from top of my head
02:06:41 <bourbaki> but its quite good
02:06:56 <bourbaki> if you find the metric its one if not the best search strategy
02:07:22 <bourbaki> and its garanteed to terminate
02:07:29 <ski> (hm, iiuyc, you want to see the program as a metric space, correct ?)
02:07:33 <bourbaki> unlike depth first search
02:07:37 <bourbaki> yes
02:07:40 <bourbaki> its a graph
02:07:45 <bourbaki> a graph is a topology
02:08:12 <bourbaki> all i need to do now is to find some metric for this topology
02:08:30 <bourbaki> which as i have to admit might not be simple in all cases
02:08:57 <bourbaki> but the over all idea the big picture as you said is that all these different fields have powerful tools already
02:09:15 <bourbaki> that i can apply to these programs to gather infromation and to optimize them
02:09:36 <bourbaki> ie paralelization wont be too hard
02:09:44 <bourbaki> distributability is easy
02:12:24 <ski> i'm not convinced they different tools will coexist happily ..
02:12:40 <bourbaki> well alot of these things do coexist
02:12:56 <bourbaki> for example my topological glue that i will use to connect programs
02:13:09 <bourbaki> is nothing but ... pushout or pullback
02:13:14 <bourbaki> sry cant remember right now
02:15:01 * ski would prolly want to see some examples and/or papers ..
02:15:25 <bourbaki> i think i am now able to put it down
02:15:36 <bourbaki> ill have a course on coalgebras next semester
02:15:54 <bourbaki> and we will have a lot of spare time so i asked my prof if i can tell the others about that
02:15:55 <ski> m
02:16:02 <ski> heh
02:16:07 <bourbaki> so there will be slides as preparation for my thesis
02:20:29 <Maddas> Is there any Haskell thingy that parses pgn files? There are too many chess player named "Haskell" or "Haskel", Google thinks :-)
02:23:26 <Maddas> Maybe I'll use this chance to learn Parsec
02:24:37 <Philippa> as good an idea as any - if pgn's defined with a BNF-like metalanguage you'll have an easy time of it
02:34:21 <paolino> I need some help in writing a solution research tree
02:35:40 * ski wonders if paolino meant 'search'
02:36:34 <shapr> @yow !
02:36:35 <lambdabot> Yow!  Now I get to think about all the BAD THINGS I did to a
02:36:35 <lambdabot> BOWLING
02:36:35 <lambdabot> BALL when I was in JUNIOR HIGH SCHOOL!
02:36:38 <paolino> ski like chesses
02:36:58 <ski> ok
02:36:58 <paolino> decision tree ?
02:37:10 <ski> possibly better phrase
02:37:21 <paolino> I defined the states
02:38:11 <paolino> now I'm stuck with the function to create the possible successive states
02:39:06 * ski wonders what kind of game
02:39:22 <paolino> it's not a game :/
02:39:31 <ski> ok, what kind of states, then :)
02:39:51 <ski> (possibly, it's still a game, in the sense of game theory, though)
02:40:03 <paolino> yes
02:40:04 <bourbaki> :)
02:40:31 <paolino> a state is a tree description of a list
02:40:46 <ski> vague
02:41:20 <paolino> so that all paths have same length
02:41:27 <ski> so each node in your search/decision tree contains a 'tree description of a list' ?
02:41:39 <paolino> si
02:41:40 <paolino> yes
02:42:16 <paolino> and all nodes have at least 'threshold' leaves
02:42:40 <paolino> and the set of final leaves addresses all the list elements
02:43:38 <paolino> I call it HRT hierarchical representer tree (of a population)
02:44:01 <ski> hm-hm
02:44:20 <paolino> should I point out the goal of the research ?
02:44:21 <ski> is there a haskell type definition, embodying this search tree type ?
02:44:26 <ski> maybe :)
02:44:28 <paolino> yes
02:44:43 <paolino> my first haskell definition :)
02:44:54 <paolino> (helped actually)
02:45:33 * shapr bounces cheerfully
02:45:55 <ski> paolino : it often does
02:46:17 <ski> paolino : may we see it ? (or is it sacred ?)
02:46:22 <ski> s/sacred/secret/
02:46:42 <paolino> lisp.paste.org not found ?
02:46:49 <ValarQ> is there any good examples on search trees?
02:46:52 <basti_> actually, for "monadic list backtrack" stuff, the search "tree" type should be [a]
02:47:46 <ski> lisppaste2 : url
02:47:46 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
02:48:09 <shapr> @seen poetix
02:48:10 <lambdabot> Last time I saw poetix was when I left #haskell and #haskell-blah 6
02:48:10 <lambdabot> hours, 27 minutes and 38 seconds ago, and I have missed 1 minute and
02:48:10 <lambdabot> 10 seconds since then.
02:49:01 <lisppaste2> paolino pasted "HRT" at http://paste.lisp.org/display/12348
02:51:37 <ski> paolino : ah, i've seen this before
02:52:26 <paolino> goal of research: stated that values in the list are summable , dividable by a number and admit a distance , find the HTR which minimizes the sum of the standard deviations of the final leaves
02:52:48 <paolino> (I've been busy a while in python sorry)
02:53:09 <ski> 'values in the list are summable' means ?
02:53:42 <ski> (that you have a monoid ???)
02:54:09 <paolino> say a list of points on a plane are good
02:54:11 <ski> (also, which list are we talking about ?)
02:54:28 <ski> m-hm
02:54:28 <paolino> the population
02:54:36 <paolino> the represented list
02:54:47 <paolino> a state is a tree description of a list
02:54:51 <paolino> that one
02:55:51 <paolino> summable , dividable by a number are necessary to calculate a mean value and standard deviation
02:56:27 <paolino> I'm not a math man :(
02:57:10 <paolino> well standard deviation depends on distance :)
02:58:02 <paolino> ciao basti_ , what is "monadic list backtrack" ?
02:58:08 * shapr cackles happily
02:58:34 <ski> paolino : using lists for backtracking/(don't-know-)nondeterminism
02:58:51 <ski> paolino : have you tried prolog ?
02:59:02 <paolino> no
02:59:08 <ski> ok
02:59:19 <shapr> Future work: "cd into a lambda term in bash"
02:59:37 * pesco snickers.
02:59:37 <ski> shapr : hehe
02:59:52 <paolino> better suited language I suppose
03:00:16 <ski> paolino : ok, you seem to be saying you want to have standard deviation on the points ..
03:00:39 <pesco> Ironic, I just got SPAM with the subject "Finally, a patch that works!".
03:00:52 <ValarQ> i'm having some problems understanding how to use the unfoldTree function
03:00:58 <paolino> on the group of points
03:01:08 <ValarQ> and i don't seem to find any good example either :(
03:01:49 <ski> ValarQ : defined where/how ?
03:02:01 <ski> paolino : ya
03:02:02 <ValarQ> ski: Data.Tree in ghc
03:02:13 <smott> ValarQ: http://www.elatae.net/dv/filetree.hs
03:02:14 <paolino> I want to group  them in a way wher standard deviation is minimized
03:02:23 <ski> @type Data.Tree.unfoldTree
03:02:25 <ValarQ> smott: thanks
03:02:28 <lambdabot> forall a b. (b -> (a, [b])) -> b -> Data.Tree.Tree a
03:02:48 <paolino> and each group contains at most 'threshold' points
03:02:57 <ValarQ> ski: that looks familiar
03:03:42 <ski> ValarQ : ah, second arg is the initial seed/state .. this is passed to the function, to get the element at this node + a list of seeds for each subtree, go on recursively for constructing the subtrees
03:03:57 <ski> (ValarQ : that is my guess, looking at the type :)
03:04:42 <int-e> @eval Data.Tree.unfoldTree (\n -> if n<=1 then (n,[]) else (n,[n-1,n-2])) 4
03:04:45 <lambdabot> Node {rootLabel = 4, subForest = [Node {rootLabel = 3, subForest = [
03:04:45 <lambdabot> Node {rootLabel = 2, subForest = [Node {rootLabel = 1, subForest = []
03:04:45 <lambdabot> },Node {rootLabel = 0, subForest = []}]},Node {rootLabel = 1,
03:04:45 <lambdabot> subForest = []}]},Node {rootLabel = 2, subForest = [Node {rootLabel =
03:04:45 <lambdabot> 1, subForest = []},Node {rootLabel = 0, subForest = []}]}]}
03:04:58 <ski> ValarQ : e.g. 'unFoldTree (\n -> (n,[n+1])) 0' should give a linear (infinite tree)
03:05:14 <paolino> the problem is np complete I suppose, so I think a research tree is one possible attack
03:05:25 <ValarQ> ski: oh
03:05:59 <int-e> (my example constructed a fibonacci tree ... I didn't realize the result would be that verbose)
03:06:12 <ski> paolino : i guess i don't know so much about clustering data for optimizing std.dev. :/
03:06:47 <ski> int-e : exponential size ..
03:06:49 <Maddas> Hey shapr :-)
03:06:51 <paolino> This is not my problem. My problem is using haskell
03:07:00 <ski> ok
03:07:06 <ski> more specifically ?
03:07:16 * basti_ laughs
03:07:17 <ski> (or you don't know ?)
03:07:21 <int-e> ski: I knew that, but that tree only has 5 leafs and 4 or so internal nodes ...
03:08:02 <paolino> well I suppose after having it implemented in python and working I can translate it in some way
03:08:10 * paolino cries
03:09:04 <ski> how do you want to cluster the data ?
03:09:14 <ski> (e.g. how did you do it in python ?)
03:10:41 <shapr> hiya Maddas
03:11:16 <shapr> Oleg released ZipperFS, check it out - http://lambda-the-ultimate.org/node/view/1036
03:11:32 <paolino> the tree I paste is the state definition, creating generations of subsequent states and following the best is the simplest (it will not do in the end, but maybe I will know I to switch to the right algorithm)
03:11:44 <shapr> He wrote a pure filesystem with transactional semantics in 540 lines of Haskell.
03:11:52 <Maddas> Cool!
03:11:57 <bourbaki> :)
03:12:01 <basti_> o.0
03:12:13 <bourbaki> sounds like a new challenge for 99 bottles for beer ;)
03:12:32 <shapr> 99 directories of beer?
03:12:38 <bourbaki> heh yes
03:13:15 <bourbaki> anyway off to bed
03:13:21 * ski looks at paolino's source
03:13:26 <shapr> I just woke up.
03:13:37 <shapr> Nice to see Marc Andreesen on LtU.
03:15:04 <paolino> ski a generation of subsequent states is : take some same level nodes and exchange their subnodes , so to optimize the global objective
03:15:51 <shapr> hiya tdias, learning Haskell?
03:16:15 <tdias> I'm trying to, but I'm not having much luck until now.
03:16:41 <shapr> Have you read the introductory stuff?
03:16:47 <stefanw> but you have found this IRC channel, so you must be lucky :-)
03:17:21 <tdias> Maybe ;-)
03:17:54 <tdias> I have bought a book that uses hugs, so I've been trying to install this on cygwin.
03:18:25 <tdias> It compiles okay, unfortunately it does not seem to install the libraries.
03:18:55 <tdias> So whenever I try to start hugs it complains that it can't find the 'Prelude'
03:19:02 <ski> tdias : there are windows-native hugs
03:19:39 <tdias> I know, but I don't like the windows shell and do all my other work using cygwin.
03:19:47 <ski> ok
03:19:59 <shapr> Man, this filesystem is really cool!
03:20:38 <ski> (WinHugs is not so bad, though (it's not using windows shell))
03:21:24 <tdias> I'm sure it's pretty good.
03:21:50 <ski> iirc ndm is porting it to unix, too (or maybe it was reimplementing)
03:22:03 <tdias> Unfortunately it's not what I'm looking for :-(
03:22:05 <shapr> hoi jyp
03:22:13 <jyp> hoi shapr
03:22:18 <shapr> How's code?
03:22:34 <jyp> Still no clue how to compile ghc-api
03:22:43 <paolino> ski ,it would also be ok to represent states with the list and define subsequent states as W random permutations of the list on only N elements, I need the logic for the incomplete search tree mostly
03:23:06 <wagerlabs> wuzzup!
03:23:16 <Maddas> Hi there
03:23:20 <shapr> mmm, filesystems
03:23:26 <wagerlabs> how come i cannot do this?
03:23:27 <wagerlabs> class ByteSized where byteSize :: Integer
03:23:57 <wagerlabs> it says no parameters for class ByteSized but all i want is for instances to implement byteSize
03:24:14 <lightstep> the instance is the parameter
03:24:37 <jyp> Building ghc-api-0.2...
03:24:37 <jyp> ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
03:24:37 <jyp>         unknown exception
03:24:37 <jyp>  Linux/amd64
03:24:40 <wagerlabs> well, if i do class ByteSized a where byteSize :: Integer it complains that a is not being used
03:24:41 <lightstep> like class Functor f where fmap::(a->b)->(f a->f b)
03:24:51 <pesco> shapr: Damn, I need to read these zipper things. Good Morning by the way. :)
03:24:55 <jyp> Anything I should investigate? Lemmih ?
03:25:17 <ski> wagerlabs : class ByteSized a where byteSize :: a -> Integer
03:25:20 <lightstep> if you say "print byteSize", haskell won't know the size of what you want
03:25:24 <wagerlabs> oh
03:25:27 <wagerlabs> ok, thanks ski
03:25:32 <lightstep> so you have to use a solution like ski's
03:25:59 <ski> wagerlabs : just make the byteSize function ignore the argument, it's only there to communicate the type
03:26:41 <ski> wagerlabs : this is sortof a workaround ambiguity problems with doing just  class ByteSized a where byteSize :: Integer
03:26:51 <wagerlabs> cool
03:26:56 <ski> s/workaround/workaround for/
03:28:12 <ski> (wagerlabs : actually any typesignature for byteSize mentioning 'a' would work .. but that's the easiest)
03:28:23 <wagerlabs> ok
03:32:09 <paolino> ski, you think it's far more complicate here than in prolog?
03:32:24 <basti_> backtracking? not at all
03:35:45 <ski> backtracking is not much more complicated
03:36:44 <int-e> isn't backtracking the only thing that prolog is good at?
03:36:52 <basti_> ah no!
03:36:56 <basti_> i wouldnt put it that way
03:37:01 <basti_> prolog programs can run backwards
03:37:05 <basti_> try that in haskell.
03:37:45 <ski> also, prolog has logic variables
03:38:50 <ski> (which of course helps with the 'run-backwards'/reversability/multi-modeness)
03:40:28 <ski> (e.g in prolog one can ask the equivalent of  xs ++ ys = [1,2,3] and get four solutions/answers : xs = [],ys = [1,2,3]  ;  xs = [1],ys = [2,3]  ;  xs = [1,2],ys = [3]  ;  xs = [1,2,3],ys = [])
03:40:38 <ski> wb
03:41:00 <paolino_> damn GPRS
03:41:28 <ski> paolino_ : in your 'representeds', you seem to not use 'level' (first argument) in any essential way
03:41:47 <xerox> Hi paolino.
03:42:07 <paolino_> ciao xerox, ngiorno
03:43:08 <xerox> @docs Data.Tree
03:43:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Tree.html
03:43:12 <xerox> I didn't know it existed!
03:43:46 <pesco> It's not that old, I think.
03:43:54 <paolino_> ski probably
03:45:07 <paolino_> I miss a definition for representeds 0 (Delegate representeds)
03:45:19 <ski> aha
03:45:52 <wagerlabs> @hoogle readArray
03:46:21 <paolino_> representeds level (Delegate representeds')=
03:46:22 <paolino_>   if level>0 then concat $ map (representeds $ level-1) representeds'
03:46:22 <paolino_>   else representeds'
03:46:39 <paolino_> dont know how to use unittest :/
03:48:04 <wagerlabs> is this a correct definition?
03:48:06 <wagerlabs> instance (ByteSized a, Binary a) => Binary (BigEndian a) where
03:48:20 <wagerlabs> i'm having trouble calling a ByteSized method on BigEndian a later on
03:49:43 <ski> wagerlabs : possibly you also want an  instance ByteSized a => ByteSized (BigEndian a)  ?  (guessing)
03:50:12 <wagerlabs> oh
03:50:45 <shapr> pesco: Good morning! Yes, the zipper is really cool.
03:50:47 <ski> or, maybe you instead want to convert/extract the value of type 'a' from the value of type 'BigEndian a'
03:50:55 <ski> that could possibly be saner
03:51:02 <wagerlabs> ski: how would i do that?
03:51:08 <pesco> shapr: Hm, I just realized, I need to read about delimited continuations first.
03:51:15 <wagerlabs> instance (ByteSized a, Binary a) => Binary (BigEndian a) where
03:51:15 <wagerlabs>     put_ bh (BigEndian a) =
03:51:15 <wagerlabs>         if isBigEndian
03:51:30 <wagerlabs> this is what i do now
03:51:33 <ski> wagerlabs : i assumed you had some function of type   BigEndian a -> a  ..
03:51:36 <ski> hm
03:51:53 <wagerlabs> ski: no, i'm just trying to call byteSize on BigEndian a
03:52:05 <xerox> There are no unsafe operations, no GHC let alone Unix threads,
03:52:05 <xerox> no concurrency problems. Our threads cannot even do IO and
03:52:05 <xerox> cannot mutate any global state ‚Äî and the type system sees to it.
03:52:10 <xerox> Is it correct english? :D
03:52:22 <pesco> I think so.
03:52:28 <ski> you can't do that directly unless you have an ByteSized-instance for BigEndian ..
03:53:54 <wagerlabs> done :D
03:54:04 <wagerlabs> now, which module does readArray reside in
03:54:17 * wagerlabs is starting to get a hang of haskell a bit
03:54:44 <ski> @index readArray
03:54:45 <wagerlabs> the typeclass thing in haskell reminds me of CLOS in Common Lisp a bit
03:54:45 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
03:55:38 <ski> wagerlabs : yes, somewhat (but http://www.haskell.org/hawiki/UnderestimatedTypeClasses)
03:55:40 <JohnMeacham> hello.
03:55:47 <JohnMeacham> drunk john is here.
03:57:00 <JohnMeacham> must go. girly girl.
03:57:26 <wagerlabs> @paste
03:57:27 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:57:39 <ski> hi, bye JohnMeacham
03:58:37 <shapr> Given the choice between a cute girl and a Haskell compiler, which would you choose?
03:58:54 <ski> is the compiler cute ?
03:59:00 * shapr grins
03:59:26 <pejo> Is the girl/compiler trustworthy should be a better question!
03:59:26 <wagerlabs> could someone please help me with my paste?
03:59:38 <ski> hehe
04:00:02 * ski wonders if wagerlabs means the QSem ?
04:00:25 <wagerlabs> nono
04:00:27 <wagerlabs> the one above
04:00:47 <shapr> I have a firm rule, never chat on irc while drunk.
04:00:49 <wagerlabs> the how do i get the size of "a" in bh
04:00:49 <ski> (ah /me was to fast with following the link)
04:01:18 <shapr> If I'm going to embarass myself, I'd rather it not be preserved in public logs.
04:02:06 <paolino_> I need to eat something , but I will not leave you with your knowledge :-)
04:02:28 * shapr watches paolino_ slurp the knowledge out a nearby programmer!
04:02:52 <ski> wagerlabs : get :: Binary a => Ptr a -> IO a  ?
04:03:11 <wagerlabs> ski: are you asking me?
04:03:15 <ski> yes
04:03:31 <wagerlabs> ski: i mean, are you asking me if i can write the get method like that? then it's no
04:03:52 <wagerlabs> class Binary a where
04:03:52 <wagerlabs>     put_   :: BinHandle -> a -> IO ()
04:03:52 <wagerlabs>     put    :: BinHandle -> a -> IO (Bin a)
04:03:53 <wagerlabs>     get    :: BinHandle -> IO a
04:03:59 <ski> no, i asked if that is indeed the type signature of get ..
04:04:00 <ski> aha, ty
04:04:38 <wagerlabs> i made a ByteSized (as Cale suggested yesterday) so that i would know the size of the array i would need to read and reverse
04:05:17 <wagerlabs> but since i appear to need an instance of my type _before_ i can get hold of its size
04:05:31 <wagerlabs> it looks like i'll need to read it, size it, and read it again as an array
04:05:34 <wagerlabs> right?
04:05:46 <ski> hm, you need to cheat to make a value of type 'a' to pass to byteSize
04:06:00 <wagerlabs> ski: oh
04:06:05 <wagerlabs> ski: how?
04:06:25 <ski> which should not be a problem, since byteSize isn't supposed to look at it's argument anyway .. it's just for disambiguating the type 'a'
04:06:26 <wagerlabs> ski: i mean, i don't know which ByteSized it is at this point
04:07:09 <Cale> pass (undefined :: MyType) as a parameter, e.g.
04:07:19 <ski> well, the current method your are trying to write is  get :: Binary a => BinHandle -> IO (BigEndian a)
04:07:35 <ski> yes, as Cale says, except we need to capture MyType
04:07:39 <Blastur> if I want to catch an exception and return another value (for the failing statement), how would I do that? i don't really understand how to use the catch() function. Lets say I have myFunc which may generate an exception, i'd like to do this: if myFunc generated an exception, return X, otherwise return myFunc value
04:07:42 <wagerlabs> there's cale! hi cale
04:07:45 <Cale> hi
04:07:53 <Cale> I'm going to sleep soon, really :)
04:07:55 <Cale> hehe
04:08:30 <wagerlabs> wait
04:08:35 <wagerlabs> but i don't know what the type is
04:09:03 <wagerlabs> and i can't pass extra parameters to get since it only takes the handle
04:09:04 <ski> wagerlabs : indeed, which means we have to capture it
04:09:33 <ski> hm wagerlabs, do you mind using extensions ?
04:09:52 <wagerlabs> i'm already using extensions. i forgot where exactly :D
04:09:55 <ski> (it will be simpler that way)
04:09:57 <ski> ok
04:10:11 <wagerlabs> ghc is da bomb, why not use extensions
04:10:20 <wagerlabs> i'm not porting to ARM or anything like that  yet
04:10:30 <basti_> did i tell you guys about my problem with hsp and how i resolved it?
04:10:41 <ski> get bh :: IO (BigEndian a) = ... -- should give you the typevar scoped over ...
04:10:43 * wagerlabs will stop at no extensions to complete the project quickly!
04:11:44 <ski> also, your line in the do will then be 'size <- byteSize (undefined :: a)'
04:11:52 <wagerlabs> aha! bingo!
04:11:56 <ski> understand
04:11:59 <ski> ?
04:12:14 <wagerlabs> ski: 100%
04:12:23 <schyffe> is it possible to create a pointer to a variable in haskell?
04:12:25 <ski> the type annotation in the function head binds the typevar 'a', so you can use it in body
04:12:36 <wagerlabs> cool
04:12:50 <ski> schyffe : it is possibly to create pointers to cells in the state
04:13:12 <wagerlabs> size <- byteSize a in the put, i thought i put that in the IO monad with the do
04:13:18 <schyffe> can you give an example?
04:13:34 <wagerlabs> why then do i get the error  Couldn't match `IO t' against `Integer'
04:13:37 <ski> (note that typevars and ordinary vars are different namespaces .. so they don't collide at all)
04:13:48 <wagerlabs> ski: this was very helpful, thank you!
04:13:56 <schyffe> I'm trying to implement dijkstra with a priority queue, and don't want to re-construct the pq every time
04:16:13 <ski> @type do {ref <- newIORef 0; ns <- mapM (\m -> do {n <- readIORef ref; writeIORef ref (n+m); return n}) [5,8,2,10,3]; print ns}
04:16:14 <lambdabot> bzzt
04:16:53 <Cale> schyffe: look into the ST monad if you need to keep arbitrary state variables around
04:17:17 <ski> @type do {ref <- Data.IORef.newIORef 0; ns <- mapM (\m -> do {n <- Data.IORef.readIORef ref; Data.IORef.writeIORef ref (n+m); return n}) [5,8,2,10,3]; print ns}
04:17:18 <lambdabot> IO ()
04:17:23 <ski> schyffe : try that
04:17:50 <Cale> except that you shouldn't use IO for pure computations
04:17:54 <Cale> use ST :)
04:17:55 <ski> indeed
04:17:56 * wagerlabs has great plans for haskell, in trading for example
04:18:02 <JohnMeacham> shapr: haskell comilirer! nicly motivated.
04:18:17 <wagerlabs> Cale: do i have to as well?
04:18:21 <Cale> (which can be accomplished by replacing "IO" with "ST" in each instance there)
04:18:37 <Cale> wagerlabs: not if you're using Foreign stuff, you can't
04:18:43 <wagerlabs> Cale:
04:18:44 <wagerlabs>  Couldn't match `IO t' against `Integer'
04:18:46 <ski> wagerlabs : you don't have to do ST instead of IO, but it's often better, when possible
04:18:49 <wagerlabs> at @paste
04:18:56 <Cale> @paste
04:18:57 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:18:58 <wagerlabs> in size <- byteSized a
04:19:04 <wagerlabs> in the put_ method
04:19:15 <ski> wagerlabs : similar issue there
04:19:27 <JohnMeacham> wagerlabls: do you work in finace? I am managincg money at the moment and want to switch them to haskell. it woul] reall [be freat for the finande cindory
04:19:32 <ski> (i think)
04:19:35 <Cale> oh
04:19:36 <Cale> yeah
04:19:46 <Cale> you do probably want ST
04:19:50 <wagerlabs> John: wanna switch to MSN Messenger?
04:19:55 <wagerlabs> Cale: how do i do that?
04:20:05 <Cale> hmm
04:20:08 <JohnMeacham> not now. must go. but ttyl.
04:20:21 <wagerlabs> JohnMeacham: shoot me an email to joelr@well.com pleas
04:20:45 <Cale> I seem to recall that Float instance for NewBinary using it
04:20:48 <wagerlabs> JohnMeacham: i have some write ups at http://wagerlabs.com/uptick as well
04:21:14 <wagerlabs> Cale: but i thought they had a different problem in that they were trying to make pure the results the IO monad
04:21:24 <ski> (wagerlabs : hm, no actually i think that 'size <- byteSize a' is ok ..)
04:21:29 <wagerlabs> Cale: whereas i seem to have an issue with sticking pure results into the io
04:21:40 <Cale> oh
04:21:41 <wagerlabs> ski: why is the compiler complaining then?
04:21:47 <ski> looking
04:21:54 <Cale> you do that with return
04:21:59 <wagerlabs>     Couldn't match `IO t' against `Integer'
04:21:59 <wagerlabs>       Expected type: IO t
04:21:59 <wagerlabs>       Inferred type: Integer
04:21:59 <wagerlabs>     In a 'do' expression: size <- byteSize a
04:21:59 <wagerlabs>     In the definition of `put_':
04:22:00 <Cale> @type return
04:22:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
04:22:11 <Cale> oh
04:22:21 <Cale> you just want let size = byteSize a
04:22:30 <wagerlabs> so it should be size <- return (byteSize a)?
04:22:31 <Cale> byteSize a isn't an IO action is it?
04:22:33 <wagerlabs> oh, i see now
04:22:33 <Cale> no
04:22:36 <Cale> that's a waste :)
04:22:39 <wagerlabs> no, it's not an IO action
04:22:48 <wagerlabs> i just learned something! :D
04:22:53 <Cale> you could use return there, and it'd work, but it's silly :)
04:23:09 <ski> ah, right :)
04:23:29 <wagerlabs> now, what is <- ? get the results of the IO action?
04:23:33 <ski> yes
04:23:33 <Cale> yes
04:23:36 <wagerlabs> cool
04:23:40 <Cale> run the IO action and get the result
04:23:50 <Cale> note that you can only use that in defining an IO action
04:24:01 <Cale> so nothing really actually gets run :)
04:24:02 <ski> (or more generally, get the results of the action in the monad we are working in at the moment)
04:24:04 <Cale> (except main)
04:24:15 <wagerlabs> i should probably make the return value of byteSized an Int, i don't think it needs to be an integer of arbitrary size :D
04:24:42 <sylvan> schyffe, there are purely functional priority queues which are quite efficient.... Just because you, on some level, "re-construct it", doesn't mean that it is actually reconstructed internally. For example, if you add a value to a tree map, the "insert" functions returns a new map, but most of the tree is actually left unchanged. Internally everything is pointers, basically, so only the stuff pointing to what you've changed needs to be up
04:24:50 <ski> (also you can't have 'foo <- bar ...' as last line of do-expr .. it'd actually be pointless)
04:25:11 <Cale> sylvan: you've changed needs to be u
04:25:12 <wagerlabs> JohnMeacham: if you are managing money who are you trying to convert to haskell? why not just convert?
04:25:18 <Cale> (that's the end of your message)
04:25:34 <sylvan> hmm.. not here =)
04:25:44 <sylvan> "needs to be updated"
04:26:07 <wagerlabs> ski: why pointless?
04:26:32 <sylvan> schyffe, another example is appending av value to the front of a list. Now i looks like you reconstruct the list, but all you do, internally, is construct an element which points to the old (unchanged) list
04:26:39 <ski> wagerlabs : because variables bound in a '... <- ...' line in a do only scopes over remaining lines
04:26:45 <fatbrain> what the best haskell implementation available for win32?
04:26:53 <sylvan> fatbrain, ghc
04:27:00 <fatbrain> ty
04:27:04 <sylvan> np
04:27:30 <ski> (wagerlabs : note e.g. that '<-' is not assignment in any way)
04:27:55 <xerox> ski: how would you call it?
04:28:02 <Cale> <- is a combination of lambda and bind
04:28:08 <ski> just binding, as always
04:28:15 <sylvan> foo >>= \ x-> bar
04:28:40 <wagerlabs> cool
04:29:24 <wagerlabs> i'm up for another dose of help!
04:30:09 <ski> one way to see that it isn't assignment is to look at e.g.  'do {a <- foo; mapM (\x -> do {...; a <- bar; ...}) someList; ...}'   the inner 'a <- bar' concerns not same variable as the outer 'a <- foo'
04:30:41 <JohnMeacham> I will. at same poin... I think it is about 8billionpp. so they have procedures before you can switchlnagugages.
04:30:53 <JohnMeacham> okay. now I really go.
04:31:01 <ski> each 'apa <- bepa' introduces new variable(s) for apa (shadowing any previous such variables)
04:31:01 <wagerlabs> JohnMeacham: cheers!
04:31:19 <wagerlabs> i'm having trouble with the type signature for reverseArray at @paste
04:31:27 <JohnMeacham> cheeeeers!
04:31:30 <wagerlabs> JohnMeacham: shoot me an email, would love to talk
04:31:46 <wagerlabs> oh, you did :D thanks
04:31:56 <sylvan> @paste
04:31:57 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:31:57 <ski> wagerlabs : interesting indentation :)
04:32:07 <wagerlabs> ski: no idea about proper one
04:32:38 <ski> no, that could actually be nice, at times (e.g. here)
04:33:23 <ski> @index unless
04:33:24 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
04:33:24 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
04:33:24 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
04:33:33 <ski> @type Control.Monad.unless
04:33:34 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:33:49 <ski> you can use that instead of the if-then-else, if you want
04:33:55 <xerox> Cale: the monadic Zipper is kinda like our abstracted core in nymphaea, except being a zipper instead of a list
04:34:17 <wagerlabs> ski: sure, feel free to rewrite the code
04:34:35 <wagerlabs> ski: i'm still learning and that code is actually somebody else
04:34:42 <Cale> xerox: I'll have to look at it :)
04:34:43 <ski> unless (2 * c > n) $ do ...
04:34:53 <Cale> too sleepy at the moment :)
04:34:53 <wagerlabs> that reverseArray is the last thing that stands between me and my binary packets :D
04:35:46 <xerox> Cale: hehe, it seem to me to be as cool as crypting, anyway :)
04:35:50 <xerox> *crptic
04:35:52 <wagerlabs> indentation is screwed up somewhat in emacs's haskell mode
04:35:54 <xerox> cryptic, hmpf!
04:36:28 <Maddas> Speaking of which, is the default Haskell mode in Emacs the recommended one to use (as a beginner)?
04:36:45 <ski> wagerlabs : actually, no need to pass around 'myArray' and 'n' as arguments in the inner loop (they aren't changed)
04:36:58 <wagerlabs> Maddas: no idea but it would certainly benefit from indentation changes. i just use it for editing and run ghci from the command line. i'm on mac osx
04:37:21 <Cale> I don't like the fully automatic indent mode in emacs - I always swap it for the simpler heuristic.
04:37:28 <wagerlabs> ski: point taken, please feel free to change the code or optimize it. it's gonna be crucial and will be called a lot
04:37:43 <wagerlabs> Cale: it works for me usually, except with haskell
04:37:59 <Cale> There are two haskell indent modes
04:38:14 <Cale> you have to pick one
04:38:16 <ski> wagerlabs : it looks ok to me, otherwise .. were you having any problem with it ?
04:38:19 <Maddas> Cale: Do you think switching to the simpler heuristic is more hassle-free when beginning?
04:38:21 <wagerlabs> Cale: really? i'm not using the literate-bird one, is that the one you are talking about?
04:38:28 <wagerlabs> ski: well, yes
04:38:29 <ski> Cale : there are ?
04:38:38 <wagerlabs> Endian.hs:25:21:
04:38:39 <wagerlabs>     Couldn't match `a a1 e' against `ByteArray'
04:38:40 <wagerlabs>       Expected type: a a1 e
04:38:40 <wagerlabs>       Inferred type: ByteArray
04:38:40 <wagerlabs>     In the first argument of `reverseArray_acc', namely `myArray'
04:38:41 <wagerlabs>     In the definition of `reverseArray':
04:38:44 <ski> ah
04:38:46 <ski> :)
04:38:49 <xerox> Is it updateable or updatable ?
04:38:54 <Cale> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
04:38:54 <Cale> (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
04:38:59 <Cale> one of those two
04:39:04 <ski> xerox : former i'd say
04:39:08 <wagerlabs> Cale: oh! maybe i should try simple indent instead
04:39:09 <Cale> the simple one is nicer
04:39:23 <Maddas> Ok, thanks for the tip.
04:39:26 <wagerlabs> Cale: i'm finding the complex one too complex :D
04:39:30 <Maddas> xerox: hm, dictionary.com knows neither (:
04:39:37 <xerox> I think I use the former, Cale.  It's nice apart from leaving the point in strange places sometimes :)
04:40:39 <Cale> I like the fact that the simple one doesn't cycle through the spots, it tries some as you hit tab, in order of indentation, and then just indents by 4 spaces after it runs out of guesses
04:40:48 <Maddas> Heh.
04:40:56 <ski> wagerlabs : hm, where're ByteArray ?
04:41:01 <xerox> Maddas: yep, the GNOME dictionary applet didn't know it too :)
04:41:10 <wagerlabs> ski: Data.Array
04:41:13 <wagerlabs> ski: i think
04:41:36 <xerox> Cale: I like the cycling!  And extensive use of Emacs DWIM keycombo :)
04:42:06 <Cale> I find hitting tab and having my cursor jump backwards unnerving :)
04:42:21 <xerox> boing boing boing :)
04:43:02 <xerox> I hope hIDE will have *smart* input technology
04:43:15 <Maddas> xerox: But the other way cycles too, just only in one way. Unicycling, so to speak :-)
04:43:32 * ski does not like the syntax-highlighter not liking me indenting all code except 'module ... where' 2 spaces
04:43:43 <Maddas> xerox: If it's *really* smart, it doesn't *need* input!
04:43:55 <Maddas> (Taking DWIM to the max!)
04:43:59 <wagerlabs> i must be stupid but i switched on the simple indenting mode and...
04:44:06 <wagerlabs> reverseArray myArray n =
04:44:06 <wagerlabs>     reverseArray_acc myArray n 0 where
04:44:07 <wagerlabs>     reverseArray_acc myArray n c =
04:44:07 <wagerlabs>         unless (2 * c > n) $ do
04:44:07 <wagerlabs>                              let o = n - c
04:44:12 <xerox> Maddas: welcome back to the real world !
04:44:17 <Maddas> :-(
04:44:25 * xerox hands Maddas a unicycle
04:44:26 <wagerlabs> it never lets me align let 4 spaces to the right of unless
04:44:43 <Maddas> xerox: That'll do until we all ride Segways (which will do until the Jetpacks arrive...)
04:44:47 <wagerlabs> it either aligns it with the do (like now), with unless or 4 spaces behind unless
04:44:48 <Lemmih> xerox: Smart input technology?
04:45:07 <wagerlabs> ski: do i need a type signature for the reverseArray_acc as well?
04:45:19 <ski> wagerlabs : should not be needed
04:45:23 <xerox> Lemmih: do you recall that structure editor someone pointed the channel to?
04:45:30 <ski> but, as said, drop first 2 args to it
04:45:34 <Lemmih> xerox: Proxima?
04:45:40 <xerox> Lemmih: Yup.
04:45:53 <wagerlabs> ski: what do you mean? c is getting incremented
04:46:10 <ski> yes, but the other 2 args are not changed upon recursive call
04:46:26 <xerox> I couldn't try it, but the paper showed some of the neat side-effects of it being a structure editor.  How are they possible in hIDE?
04:46:27 <ski> reverseArray myArray n =
04:46:31 <wagerlabs> ok
04:46:32 <ski>     loop 0 where
04:46:36 <ski>     loop c =
04:46:39 <ski> ...
04:46:44 <ski> e.g.
04:46:48 <wagerlabs> ski: not sure i catch the whole drift
04:46:56 <xerox> I usually do:
04:47:19 <ski> just it's unnecessary (cluttering) to pass around stuff that aint chani
04:47:20 <xerox> reverseArray arr n = loop 0
04:47:20 <xerox>   where loop c =
04:47:20 <xerox>         ...
04:47:24 <ski> changing
04:47:49 <ski> xerox : yes .. but wagerlabs' indentation was quite nice imo
04:47:52 <Blastur> what is reverseArray suppose to do? :)
04:48:00 <xerox> ski: do you know where one could look to find informations about those 'delimited continuations' ?
04:48:04 <wagerlabs> well, just reverse the array
04:48:13 <ski> Blastur : destructively reverse the array
04:48:22 <Blastur> cant you use the reverse() function for that?
04:48:23 <xerox> ski: yeah, it's interesting.
04:48:46 <ski> (xerox : makes me think of "named let" in scheme, if you've seen that)
04:48:47 <wagerlabs> i got that code from someone here :-) K...?
04:49:01 <xerox> ski: I did, you're right :)
04:49:03 <wagerlabs> Blastur: i don't know if reverse can be used with arrays
04:49:07 <ski> xerox : hm, some papers by e.g. filinski,wadler, etc ?
04:49:43 <wagerlabs> ski: but before i go into optimizing stuff, would you by chance know why the compiler is complaining?
04:49:44 <xerox> I'll try with ZFS paper before all, thanks for the pointers
04:50:01 <ski> (xerox : see e.g. the two first papers referenced at http://www.haskell.org/hawiki/CpsTransform)
04:50:42 <xerox> Okay!
04:50:45 <ski> Blastur : standard 'reverse' works for lists ..
04:51:18 <xerox> Imagine a slide full of big-letters-code: 'We create the zipper via the following generic function. The function is quite short and it fits on one slide.'
04:51:22 * ski doesn't remember all the titles of the papers he's looked at, concerning continuations :/
04:51:24 * xerox laughs ;)
04:51:26 <Lemmih> xerox: Most of the proxima features are out of reach in hIDE. However, we /will/ be able to perform refactorings based on the AST.
04:51:58 <ski> (Blastur : but not for other things ... (was not clear))
04:52:05 <Maddas> xerox: "Partial Continuations as the Difference of Continuations" might be helpful
04:52:17 <xerox> Lemmih: why are they so far?  Big hug for ghc-api, tough ;)
04:52:35 <Maddas> xerox: It's not Haskell-specific, though
04:53:42 <ski> wagerlabs : i think either you are not importing right modules.. and/or that code is written for some other array variant, and possibly you need to change the 'readArray' and 'writeArray' to operations suitable for 'ByteArray'
04:53:54 <wagerlabs> ski: ok, looking into it
04:54:01 <xerox> Maddas: I wonder what kind of background those paper need the reader to have, in order to understand them.
04:54:26 <wagerlabs> @index readArray
04:54:27 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
04:54:31 * ski has no access to ghc, atm, and can't find ByteArray in online docs atm either :/ so i can't check it rn
04:54:43 <Maddas> xerox: That one in particular uses Scheme, shouldn't be a problem, though ;-)
04:55:02 <Maddas> (It's on my TOREAD stack, among many others, so I can't say much more just yet)
04:55:29 <Lemmih> xerox: The Proxima guy used a lot of time on his thesis and making a practical implementation would be at least as hard. We simply don't have the man power nor the funding.
04:55:35 * wagerlabs would take any other version of destructive reversing of an array
04:56:13 <xerox> Lemmih: fair enough.  So it will be my SoC project next year ;-)
04:56:39 <ski> wagerlabs : but you want to reverse a ByteArray, yes ?
04:56:49 <wagerlabs> actually, i need to look at the funs from NewBinary.Binary
04:57:02 <wagerlabs> ski: right, the one from NewBinary.Binary
04:57:25 <ski> wagerlabs : are there docs or source somewhere ?
04:57:32 <wagerlabs> sure
04:57:53 <wagerlabs> http://www.n-heptane.com/nhlab/repos/NewBinary/NewBinary/Binary.hs
04:58:04 <ski> danke
04:58:21 <Lemmih> dons: ping.
04:59:04 <Maddas> xerox: Oh, by the way -- did the SoC project end nicely?
04:59:35 <ski> #if __GLASGOW_HASKELL__ < 503
04:59:35 <ski> type BinArray = MutableByteArray RealWorld Int
04:59:35 <ski> #else
04:59:35 <ski> type BinArray = IOUArray Int Word8
04:59:35 <ski> #endif
04:59:51 <wagerlabs> ski: that's BinArray, though
04:59:54 <ski> hm, right
05:00:00 <xerox> Maddas: Yup, modulo tax issues :-)
05:00:00 <ski> noticed that now
05:00:59 <Maddas> Sweet :-)
05:01:04 <ski> data ByteArray = BA ByteArray#
05:01:09 <xerox> Maddas: indeed, it was _so_ fun.
05:01:28 <wagerlabs> ski: right, but look at getByteArray -- it looks like MBA is being returned
05:01:30 <xerox> Maddas: did you see Nymphaea?
05:01:31 <Maddas> Bah, don't make me jealous. My summer was terribly boring :-)
05:01:40 <Maddas> Nope, never heard of it.
05:01:41 <xerox> @where nymphaea
05:01:42 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
05:01:48 <wagerlabs> xerox: what did you do for soc?
05:01:57 <Maddas> Ooh, cool. Eye candy!
05:02:20 <xerox> wagerlabs: I wrote the cairo Haskell bindings and gtk interoperability (in Gtk2Hs)
05:02:38 <xerox> That program does serve to show off the resulting power ;-)
05:02:53 <Maddas> Haha :-)
05:02:55 <wagerlabs> xerox: cool
05:03:14 <xerox> (plus the added value of Cale's math-fu, nonetheless)
05:03:59 <astrolabe> Is that background rendered?  Or a vegetable?
05:04:10 <Maddas> Maybe both!
05:04:17 <wagerlabs> ski: what sucks is that they don't export writeByteArray and indexByteArray
05:05:34 <xerox> astrolabe: Maddas got it right ;-)
05:05:53 <ski> wondering if
05:05:54 <ski> putByteArray :: BinHandle -> ByteArray# -> Int# -> IO ()
05:05:54 <ski> getByteArray :: BinHandle -> Int -> IO ByteArray
05:05:56 <ski> suffices
05:06:10 <wagerlabs> ski: they don't have these, though, do they?
05:06:23 <ski> those are exported
05:06:30 <wagerlabs> ski: err, i think these just read and write arrays of a given size
05:06:41 <ski> hm, maybe
05:06:42 <wagerlabs> ski: but it's not clear to me how to access the individual bytes within those arrays
05:07:08 <wagerlabs> ski: go to line 738, though, there's a writeByteArray for you
05:07:19 <wagerlabs> ski: and there's indexByteArray right below it
05:07:42 * wagerlabs wonders if he should break the abstraction of NewBinary.Binary and export more stuff
05:08:47 <wagerlabs> it seems silly to export getByteArray and putByteArray without exporting functions to work with the elements. unless the intention was to use some other methods for that
05:08:54 <ski> ah .. those put and get and communicating the contents with something else, it seems
05:09:10 <wagerlabs> ski: what do you mean?
05:09:15 <ulfdoz> wg #linux.de
05:09:16 <wagerlabs> ski: communicating contents with something else
05:09:17 <ulfdoz> wg #linuxger
05:09:36 <ski> wagerlabs : um, with the handle, which i just noticed
05:09:58 <wagerlabs> ski: well, of course. you use the methods to retrieve the ByteArray from the handle
05:10:30 * ski is slightly tired, so didn't grasp that at first
05:10:34 <ulfdoz> btw. sry for the trash. :)
05:10:49 <ski> (wg ?)
05:10:51 <wagerlabs> *ByteSized> :m NewBinary.Binary
05:10:51 <wagerlabs> Prelude NewBinary.Binary> :info ByteArray
05:10:51 <wagerlabs> data ByteArray = BA GHC.Prim.ByteArray#
05:10:51 <wagerlabs>         -- Imported from NewBinary.Binary
05:11:17 <ulfdoz> ski: alias for "window goto"
05:11:58 <wagerlabs> ski: maybe a case around getByteArray to destruct the constructor and get to the primitive ByteArray#?
05:13:36 <ski> where ?
05:13:45 <wagerlabs> ski: i'm just asking
05:13:51 <ski> me too
05:14:03 <wagerlabs> ski: it the returned value from getByteArray should be destructed
05:14:19 <ski> are you calling getByteArray ?
05:14:28 <wagerlabs> of course
05:14:46 <wagerlabs> take a look at the paste below
05:15:03 <wagerlabs> below the latest, the other paste where we were fixing size <- byteSize a
05:15:06 <ski> ok
05:16:38 <wagerlabs> ski: i retrieve the array that's as big as the type (4 bytes, 8 bytes, 2 bytes) and then try to reverse it and put it back
05:17:16 <astrolabe> How many columns do you guys squeeze your code into?  Is there a standard?
05:17:32 <Igloo> 80
05:17:42 <astrolabe> Danker
05:18:06 <Igloo> Or 79, depending on how you are counting
05:18:30 <astrolabe> Now I'm confused.
05:18:42 <lightstep> less than 70 is very good
05:18:52 <wagerlabs> ski: so what do you think is the best method?
05:18:52 <astrolabe> Ah, I start with 1 when I count.
05:19:10 <Igloo> I mean screen width 80, but the last column empty
05:19:12 * ski is still reading NewBinary and aha:s some
05:19:24 <astrolabe> Oooh thanks.
05:19:26 <paolino_> ok, can someone code for me a function (using monads? ) which calculates n random permutations of a list  ::[a]->Int->[[a]] ?
05:20:24 <lightstep> take n (permutations list)
05:20:54 <ski> paolino_ : n necessarily different permutations ?
05:21:04 <paolino_> :( nothing learned
05:21:15 <paolino_> ski yes
05:21:18 <astrolabe> random = arbitrary or random = pseudorandom
05:21:46 <paolino_> astrolabe probably
05:22:05 * ski thinks .. so getByteArray actually returns a frozen array, which is probably why they don't export the write and index operations ..
05:22:21 <schyffe> how do you sort [(a,b)] if I want to sort on a?
05:22:30 <ski> @type List.sortBy
05:22:31 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
05:22:37 <schyffe> thanks
05:22:42 <paolino_> and different every time I evaluate the function on the same list
05:22:58 <ski> paolino_ : then you need some source of randomness
05:23:26 <ski> (because functions always give same result, if given same arguments)
05:23:42 <xerox> You could model it with lists
05:23:53 <xerox> ...and then generalize to monads, and use Cale's MonadRandom :-)
05:24:08 <ski> xerox : how are you thinking (re list) ?
05:24:22 <paolino_> ski than how you evolve a search tree ?
05:24:29 <xerox> ski: lazily returning all the possible results
05:25:39 <ski> wagerlabs : though, hmm write... and index.. actually seem to work over nonfrozen arrays .. so i'm not sure why they haven't exported them
05:26:14 <ski> xerox : yes, but you still need some source of randomness .. either to generate the results in random order .. or to select a random result
05:26:29 <xerox> ski: that could wait
05:26:32 <wagerlabs> ski: right
05:26:51 <ski> paolino_ : you just make new version of it
05:27:11 <astrolabe> To get a random permutation, append a random element to a random permutation of the remainder.
05:27:30 <lightstep> paolino_, you can usually just create the complete (infinite) tree and rely on lazyness
05:27:31 <ski> s/append/cons/
05:27:58 <ski> lightstep : ya, that's possible, too
05:28:18 <xerox> http://haskell.org/hawiki/MonadTemplateLibrary_2fMonadRandom
05:28:25 <xerox> ski: that's exactly what I said O_o
05:28:29 <paolino_> my source is not a search tree it's the content of a node of the search tree (You kno that :/ )
05:29:33 <ski> xerox : oh .. i thought you were talking about the lazy list of random permutations results
05:30:14 <paolino_> lightstep, rely on lazyness ? how I prune the infinite tree if not evaluating some of it ?
05:30:23 <xerox> ski: nope.  Just how lists model non-determinism, and then generalizing to arbitrary monads, and use MonadRandom :-)  (it's what nymphaea did!)
05:31:12 <xerox> Do anybody tried ZFS?
05:31:43 <astrolabe> zermilo-fraenkel set theory?
05:32:07 * ski chuckles
05:32:14 <xerox> What ?!
05:32:15 <lightstep> paolino_, the parts you have to evaluate will be evaluated, but if you can ignore some parts, they won't be created
05:32:25 <xerox> astrolabe: http://lambda-the-ultimate.org/node/view/1036
05:32:45 <astrolabe> Ah!  :)
05:32:49 <xerox> It does loop infinitely when I kill the telnet client.
05:33:19 <Heffalump> someone was looking for the zipper file system code, weren't they?
05:33:34 <Heffalump> it's appeared on Oleg's website
05:33:51 <xerox> http://calc101.com/
05:34:24 <lightstep> why is FastMutInt defined as `data', and not `newtype'?
05:34:31 <xerox> Heffalump: that's what the LtU article refers to
05:35:34 <xerox> Delimited continuations are actually used to implement 'processes' woot!
05:35:52 <xerox> The whole code is single-threaded and referentially transparent.
05:36:08 <ski> lightstep : because MutableByteArray# is unboxed, i think
05:37:32 * ski is not every sure if one can newtype unboxed types
05:37:53 <bourbaki> moin
05:38:01 <ski> (result of such would be a new unboxed type, then .. and here i think a boxed type was wanted)
05:38:06 <ski> wb bourbaki
05:38:07 <wagerlabs> i'm here
05:40:07 <ski> wagerlabs : from what i understand .. the clean way would be for Binary to provide MBA versions of getByteArray (and possibly putByteArray), and then you would do a reverse over than and finally freeze it
05:40:24 <bourbaki> thx
05:40:47 <wagerlabs> ski: what about just exporting their writeByteArray and indexByteArray
05:41:17 <ski> now, if you instead call getByteArray (a frozen one) you could conceivable cheat and mutate it anyway, because you get a fresh array, and you're only going to mutate it initially one time before returning it
05:42:11 <wagerlabs> ski: oh, i see, you would need to unfreeze, etc
05:42:14 <ski> best would be if one could ask writers of that module about this ..
05:42:18 <ski> yes
05:42:32 <wagerlabs> ski: i see now
05:42:37 <ski> unsafeThawByteArray#  or something like that
05:42:45 <wagerlabs> ski: well, maybe i could do it different
05:43:11 <wagerlabs> since i always deal with sizes of 2, 4 and 8
05:43:18 <wagerlabs> i could just do getByte and putByte
05:43:20 <ski> ByteArray# values are supposed to be constant .. while MutableByteArray# supports update
05:43:38 <wagerlabs> ski: how do i throw and error if i get a size that i do not support?
05:43:52 <ski> unimplemented ?
05:43:57 <ski> @type error
05:43:59 <lambdabot> forall a. [Char] -> a
05:44:07 <wagerlabs> how do  you throw that error, though/
05:44:15 <wagerlabs> an exception
05:44:21 <ski> @eval 1 + error "apa"
05:44:23 <lambdabot> apa
05:44:34 <astrolabe> If I have  type Vertex = (Int,Int) then will Vertex be in Ix?
05:44:34 <ski> that's a run-time error
05:45:04 <ski> astrolabe : if (Int,Int) is in Ix, yes
05:45:07 <xerox> ZFS is more fun that it seem at first glance
05:45:09 <lightstep> :t throw
05:45:28 <wagerlabs> so if i did a case and wanted to do the "otherwise" option i would just call error("Unsupported")?
05:45:35 <astrolabe> ski: thanks.
05:45:38 <ski> yep
05:45:46 <ski> (though no parens needed)
05:46:06 <wagerlabs> i see, allright then. no need to reverse arrays
05:46:14 <ski> m-hm
05:46:37 <lightstep> you prefer your program to crash?
05:46:59 <wagerlabs> i could read in manually from the handle with getByte and then do putByte in reverse
05:47:04 <Blastur> does a higher infix value mean higher priority, or lower priority?
05:47:21 <ski> (he prolly prefers waiting to implement the stuff he doesn't need at the moment, so the stuff he needs will work now rather than later)
05:47:33 <wagerlabs> ski: you are right!
05:47:40 <Igloo> Higher binds tighter
05:47:45 <wagerlabs> i know that i'm gonna be the only guy doing the low-level stuff?
05:47:50 <wagerlabs> !
05:47:51 <ski> Blastur : it means higher priority, i.e. binds stronger
05:47:55 <xerox> Real copy-on-write, cool.
05:48:04 <wagerlabs> so i know i'm gonna support particular types
05:48:46 * xerox points at "Future work: ...; cd into lambda terms in bash; ..."
05:49:00 <Blastur> okay, so .. a <*> b <-> c would mean ((a <*> b) <-> c) if infix for <-> was higher than infix for <*>, right?
05:49:23 <Igloo> No
05:49:30 <lightstep> Blastur, no
05:50:15 <Blastur> (a <*> (b <-> c)) ? :)
05:51:14 <ski> if <-> pulls stronger at b than <*> then the former wins
05:52:24 <xerox> ski: stronger = less infix 'number' ?
05:52:33 <ski> the other way around
05:52:42 <xerox> So he was right?
05:52:52 <xerox> Nope.
05:53:00 <xerox> Misread, nevermind :-)
05:53:01 <ski> "<Blastur> ... if infix for <-> was higher than infix for <*> ..."
05:58:52 <Blastur> is there an easy way to print out how haskell interprets a statement with regard to the infix
05:59:12 <Blastur> like, a <*> b <-> c becomes (a <*> (b <-> c)) with certain values for infix etc
06:00:22 <lightstep> use :t in ghci
06:02:14 <Blastur> doesn't seem to add any parentheses
06:05:05 <lightstep> hm, that's right
06:05:37 <Igloo> Make it a type error, e.g. ... :: (), and it will
06:05:48 <Igloo> Or hsparser might be able to help
06:05:56 <Igloo> Or pprint it from TH
06:06:23 <Blastur> TH?
06:07:25 <xerox> 'Partial continuations can be also reified into first-class objects, but, unlike continuations, when a partial continuation is invoked, control is returned to its invocation point after its termination.'
06:07:33 <xerox> What does happen with continuations, instead?
06:08:19 <shapr> What's a comilirer?
06:09:00 <xerox> A fellow soldier?
06:09:03 * basti_ slaps shapr around a bit with a large lambda
06:09:36 <sieni> xerox: a continuation does not return?
06:11:15 <lightstep> invoking a continuation is like changing worldlines
06:11:54 <ski> xerox : invoking a continuation from an expression will not return .. think of exit() and longjmp() in C, e.g.
06:12:16 <xerox> I didn't know, woot.
06:12:40 <ValarQ> ski: thanks for that tree example, it helped a lot :)
06:13:03 <ski> normal continuations does not return, conceptually  (the implementation might use CPS style with functions modelling continuations, though, and those returns at toplevel (all at once))
06:13:21 <xerox> Gotcha
06:13:51 <xerox> I started reading Maddas' paper but I think I'd more like one that uses Haskell for the examples :-)
06:14:44 <ski> xerox : e.g. invoking a continuation from an expression will ignore the normal current continuation  (this ignoring/throwing-away is *not* inherent in (the standard) continuations, but rather in that we here invoked it from an expression)
06:15:15 <xerox> I got it, thanks
06:15:44 * wagerlabs is back
06:15:51 <wagerlabs> with another @paste problem ;)
06:15:55 <wagerlabs> anyone?
06:16:10 <basti_> would we be able to stop you? :D
06:16:29 <wagerlabs> basti_: resistance is futile!
06:16:34 <xerox> ski: do the two paper you pointed me at talk about partial continuations?
06:16:49 <wagerlabs> basti_: on the other hand, once i get up to speed i'll be able to talk about fun stuff :D
06:17:06 <basti_> heh
06:17:28 <int-e> wagerlabs: byteSize a is bad, you want something like byteSize (BigEndian a) there. I think.
06:17:46 <wagerlabs> basti_: like using haskell for trading and as a DSL in a game engine ;)
06:17:50 <wagerlabs> so i'm a good investment :D
06:18:05 <wagerlabs> int-e: you mean right there in the case?
06:18:08 <basti_> heh
06:18:15 <int-e> wagerlabs: right
06:18:22 <wagerlabs> int-e: byteSize (ByteSize a) then?
06:18:29 <wagerlabs> int-e: oh, i see
06:18:52 <ValarQ> how can i create a binary search tree with ghc's Data.Tree functions?
06:19:03 <ski> xerox : yes  (at least one of them)
06:19:08 <wagerlabs>                 case byteSize (BigEndian a) of
06:19:10 <wagerlabs> did not help
06:19:18 <ValarQ> say i got a bunch of strings that i want to sort for example
06:19:28 * int-e wonders what's that trying to do ... hmm
06:19:30 <ski> (xerox : in any case, knowing the CPS-transform by heart doesn't hurt, either :)
06:20:01 <wagerlabs> int-e: well, a big endian is an instance of both ByteSized and Binary so in the put method of Binary i need to get the size of BigEndian
06:20:10 * int-e is stupid, sorry.
06:21:21 <int-e> does the binary type class require its types to be instances of ByteSized (no, it doesn't - question is, should it?)
06:21:36 <wagerlabs> int-e: Binary - no, BigEndian - yes
06:21:42 <michael> hello
06:21:47 <wagerlabs> int-e: because i need to know how many bytes to reverse
06:21:48 <xerox> Howdy michael.
06:22:47 <int-e> hmm. I guess you still need to add that to the instance: instance Binary a, ByteSized a => Binary (BigEndian a) where
06:23:16 <wagerlabs> i had trouble with this before but let me try it again
06:23:17 <int-e> [possibly with a pair of parentheses around the two type constraints, I'm unsure about the proper syntax here)
06:23:28 <wagerlabs> int-e: you mean combine the two instance declarations into one?
06:24:01 <michael> wagerlabs, it's more like instantiating Binary for any type that is Binary & ByteSized
06:24:05 <int-e> wagerlabs: no, just combine two constraints in the constraint part. (before the =>)
06:24:10 <michael> ".. for any BigEndian type .."
06:24:14 <wagerlabs> int-e: jjey, that works!
06:24:56 <wagerlabs> a bigger question... i have BigEndian and little endin
06:24:58 <wagerlabs> endian
06:25:12 <wagerlabs> both have the same logic as in paste, if byte order does not match then reverse
06:25:34 <wagerlabs> any way to combine the two to avoid code duplication? /i had trouble with the combination yesterday/
06:25:48 <michael> is your code somewhere online?
06:25:57 <wagerlabs> paste
06:26:04 <wagerlabs> @paste
06:26:05 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:26:57 <wagerlabs> imagine a LittleEndian in the paste where the only difference would be an "if littleEndian then"
06:27:29 <wagerlabs> the code is exactly the same otherwise. if we are BE and isBigEndian then fine, if we are LE and isLittleEndian then fine, otherwise reverse
06:28:32 <int-e> hmm. you can make a helper function (with one additional argument, that works for arbitrary Binary instances. put_help :: Binary a => Bool -> Int -> a -> IO () or something like that; the boolean argument would be used to pass in the endianness
06:28:58 <wagerlabs> aha!
06:29:27 <int-e> err, it'll have to take an address and the length, too
06:29:39 <int-e> you can rely on inlining in that context though I believe.
06:30:12 <wagerlabs> ok, thanks!
06:31:25 <wagerlabs> int-e: and how exactly will inlining kick in?
06:32:37 <int-e> wagerlabs: well I was assuming you have all that code in one module. so when the compiler compiles the put_ functions of the respective classes, it should expand the helper function in place
06:32:40 <michael> Zipper-based File Server, wohoot.
06:32:59 <wagerlabs> int-e: ok, thanks
06:33:03 <wagerlabs> michael: what's Zipper?
06:33:45 <int-e> @where zipper
06:33:46 <lambdabot> I know nothing about zipper.
06:34:00 <int-e> is there a readable paper?
06:34:08 <xerox> michael: did you read the slides?  I mean, whoa.
06:34:43 <michael> xerox, no, I'm in text mode atm (xorg compiling) :(
06:34:53 <wagerlabs> xerox: what's so whoa?
06:35:00 * wagerlabs doesn't know about Zipper
06:35:10 <xerox> wagerlabs: more or less every single thing.
06:35:17 <astrolabe_> xerox: where are the slides?
06:35:24 <michael> wagerlabs, a "an updateable and yet pure functional cursor into a data structure"
06:35:28 <wagerlabs> xerox: i wish i knew what you guys are talking about :)
06:35:41 <wagerlabs> cursor = zipper?
06:35:55 * int-e has got that far
06:35:56 <xerox> astrolabe_: on Oleg's site: http://okmij.org/ftp/Computation/Continuations.html#zipper-fs
06:36:08 <astrolabe_> xerox: thanks
06:36:14 <michael> wagerlabs, "It lets us replace an item deep in a data structure, e.g., a tree or a term, without any mutation.".. google oleg zipper
06:36:32 <michael> xerox, what fancy things do they show in the slides?
06:36:36 <xerox> He used delimited continuations to implement transactions/"threads" in a single-threaded process.
06:36:41 * int-e has not quite digested the interaction of multiple zippers on a single data structure
06:36:49 <xerox> The whole thing is referentially transparent.
06:37:06 <xerox> int-e: that's one main point :-)
06:37:09 <int-e> [which means I'm missing the whole point, I believe]
06:37:13 <int-e> xerox: :)
06:37:35 <xerox> Try out the code, as in the demos showed in the slides.
06:37:49 <michael> yeehaw, Xorg is done compiling.
06:39:52 <wagerlabs> i need to read up on delimited continuations... maybe after i deliver on my contract
06:43:53 <xerox> 'A Dynamic Continuation-Passing Style for Dynamic Delimited Continuations (Preliminary Version)'
06:45:18 <wagerlabs> malcolm: ping
06:46:39 <wagerlabs> oops
06:46:49 <wagerlabs> i think i just wasted a few days of work :(
06:47:28 <wagerlabs> nhc98 is GPL and NewBinary is based on nhc's Binary which would mean that NewBinary is GPL too
06:47:36 <wagerlabs> can i use it in commercial software then?
06:48:01 <xerox> Damn restrictive licences.
06:48:08 <xerox> Dunno really, though.
06:48:27 <xerox> Mail the author?
06:51:08 <xerox> There are some delimited continuations here: http://www.cs.indiana.edu/~sabry/research.html
06:51:40 <xerox> Err, use a zipper and apply ("papers that talk about "++) somewhere in the last sentence :)
06:52:38 <xerox> Though "Oleg Kiselyov, Amr Sabry, and Chung-chieh Shan. Dynamic Scope and Delimited Continuations. July 2005." isn't available online, is it?
07:33:00 <xerox> @index newPrompt
07:33:01 <lambdabot> bzzt
07:39:15 <xerox> @index runCC
07:39:16 <lambdabot> bzzt
07:40:30 <xerox> Hmpf.
07:41:55 <xerox> @seen TheHunter
07:41:56 <lambdabot> TheHunter is in #haskell-blah and #haskell. I don't know when
07:41:56 <lambdabot> TheHunter last spoke.
08:17:34 * wagerlabs waves
08:21:38 <wagerlabs> data SrvHandShakedPacket = Mk { procType :: CommandProcType }
08:21:38 <wagerlabs> instance (ByteSized a, Binary a) => SrvHandShakedPacket a where
08:21:38 <wagerlabs>     byteSize a = byteSize $ procType a
08:22:35 <wagerlabs> it seems that i cannot define the method byteSize here, should i separately make the packet an instance of ByteSized and define the method there?
08:23:32 <ski> SrvHandShakedPacket is not a type class, you are missing the name of the type class
08:23:57 <ski> probably  instance (ByteSized a, Binary a) => ByteSized (SrvHandShakedPacket a) where
08:23:57 <ski>    was intended
08:24:19 <wagerlabs> ski: so i should define a new Packet type class that instantiates both Binary and ByteSized then?
08:24:28 <ski> hm, for what reason ?
08:24:30 <wagerlabs> and then instantiate my packet from that?
08:24:42 <wagerlabs> ski: well, packets need to be both sized and binaries
08:25:17 <wagerlabs> which is something that i want to enforce
08:25:58 <ski> in any case 'data SrvHandShakedPacket =' defines a *type* 'SrvHandShakedPacket' and 'instance ... => SrvHandShakedPacket a' defines an instance of the *class* 'SrvHandShakedPacket'
08:26:12 <ski> i was just commenting that this was probably not intended
08:27:17 <ski> (unless you indeed both want 'data SrvHandShakedPacket = ...' for a type, *and* 'class SrvHandShakedPacket a where ...' for a class)
08:28:19 <wagerlabs> ski: all i want is for my packet to "inherit" the methods from both binary and bytesized
08:28:30 <ski> (but it didn't look like that, since 'byteSize', which you tried to define in an instance belongs to class 'ByteSized' not to some class 'SrvHandShakedPacket')
08:29:07 <wagerlabs> so would it work if i enforce that with a Packet typeclass that derives from both ByteSized and Binary?
08:29:17 <wagerlabs> and then derive the server packet from that?
08:30:21 <wagerlabs> so that for each instance of packet the methods of both Binary and ByteSized would need to be defined
08:30:22 <ski> you want methods in classes 'Binary' and 'ByteSized' to apply to values of type 'SrvHandShakedPacket' ?
08:30:55 <wagerlabs> ski: 100%
08:31:16 <ski> if so, i think you may possibly want something like   instance ByteSized SrvHandShakedPacket where byteSize (Mk a) = ...
08:31:19 <wagerlabs> ski: because packets have a size (the sum of field sizes) and can be read and written
08:31:24 <ski> and instance Binary SrvHandShakedPacket where ...
08:32:32 <ski> (don't forget to use 'Mk' to wrap and unwrap between 'SrvHandShakedPacket' and 'CommandProcType')
08:32:37 <ski> hm, in your case
08:32:47 <ski> you may actually (with ghc extension) do
08:33:03 <ski> newtype SrvHandShakedPacket = Mk { procType :: CommandProcType } deriving (ByteSized,Binary)
08:33:13 <ski> if you want the same implementation, i.e.
08:33:16 <wagerlabs> cool, exactly what i wanted. thank you!
08:34:07 <ski> (which raises the question of why you are making a new type 'SrvHandShakedPacket' instead of just using 'CommandProcType' (possibly using a type synonym/alias))
08:34:22 <wagerlabs> never mind that ;) thanks ski!
08:34:30 <ski> yw :)
08:34:43 <TheHunter> xerox, what up?
08:35:14 <xerox> Hi TheHunter.  I was wondering where are defined runCC & co.  Did you take them out of the paper for your TMR2 article, or there is a lib somewhere?
08:36:07 <TheHunter> I never used runCC.
08:36:21 <xerox> Uhm.  What about shift/reset?
08:36:30 <TheHunter> It's from the monadic subcomputations paper.
08:36:39 <TheHunter> @google monadic subcomputations
08:36:41 <lambdabot> http://research.microsoft.com/users/simonpj/papers/concurrent-haskell.ps.gz
08:36:44 <ValarQ> hello again folks
08:36:54 <ValarQ> new questions :)
08:37:06 <TheHunter> @google monadic subcontinuations
08:37:08 <lambdabot> http://research.microsoft.com/users/simonpj/papers/control/control.pdf
08:37:13 <ValarQ> can i use ghc's Data.Tree to create a binary search tree?
08:37:22 <TheHunter> not really awake yet :/
08:37:26 <xerox> TheHunter: the monadic framework for delimited continuations paper?
08:37:47 <ValarQ> or is there some other more accepted method?
08:37:53 <TheHunter> yes, that one. Oleg made a monad transformer library out of it.
08:38:16 <TheHunter> ValarQ, do you know about Data.Map?
08:38:35 <xerox> TheHunter: ah!  I was hoping for a GHC flag like the STM paper implementation ;)
08:38:40 <ValarQ> TheHunter: not yet
08:38:45 <TheHunter> shift/reset can be defined in the plain old continuation monad.
08:38:55 <xerox> TheHunter: and that's what you do in the article, rigt?
08:38:59 <xerox> right, even
08:39:04 <TheHunter> yes
08:39:34 <xerox> Okay.
08:39:35 <TheHunter> ValarQ, Data.Map provides finite maps from an ordered type into an arbitrary type.
08:39:47 <TheHunter> it's like [(a,b)], only more efficient.
08:39:49 <xerox> Prolly the ZFS code has the DC code in some module.
08:40:04 <TheHunter> ZFS?
08:40:07 <xerox> Ah!
08:40:14 <xerox> http://lambda-the-ultimate.org/node/view/1036
08:40:31 <ValarQ> TheHunter: ok, i will have a look at it, thanks
08:40:53 <integral> pugs has a copy of the subcont library in .../src/Pugs/Cont, xerox
08:41:50 <TheHunter> i always have the feeling oleg is overestimating the power of his zippers.
08:41:54 <xerox> module CC_FrameT ( CC, Prompt, SubCont, runCC, newPrompt, pushPrompt, letSubCont, pushSubCont ) where
08:42:41 <xerox> TheHunter: why so?
08:43:34 <TheHunter> because they offer nothing more than what I think is called "the web" in some paper.
08:44:30 <xerox> Those implementation he write are really cool and inspiring :)
08:44:32 <TheHunter> i put a little code to illustrate that on the wiki some time ago:
08:44:38 * xerox is all eyes
08:44:39 <TheHunter> http://www.haskell.org/hawiki/HaskellIrcPastePage_2fZipper
08:44:47 <TheHunter> http://www.haskell.org/hawiki/HaskellIrcPastePage_2fZipperG
08:45:31 <xerox> No english comment to the code anywhere ? :)
08:46:38 <TheHunter> the types of travZipper and traverse should speak for themselves ;)
08:47:29 <xerox> Could you comment them ?  <puppy eyes>
08:50:49 <xerox> I understood how to use it, at least.
08:50:57 <xerox> The Show.Functions trick is really nice :-)
08:51:25 <TheHunter> oh, I didn't do it as explicitely as I thought.
08:52:07 <TheHunter> Anyway, the function zipper transforms a traversal function (traverse) to a web-like Zipper.
08:52:36 <xerox> iterate right foo -- is nice :)
08:52:52 <xerox> Where are the continuations involved?
08:52:55 <TheHunter> and travZipper can reconstruct the traversal function back from the zipper, so both are representations of the same thing.
08:53:28 <xerox> (Where is travZipper?)
08:53:43 <TheHunter> ZipperG
08:54:00 <SamB> @google haskell hIDE
08:54:01 <lambdabot> http://haskell.org/hawiki/hIDE
08:55:37 <xerox> Too complicated, I think :-\
08:55:39 <TheHunter> the function zipper is the only one to use continuations and the plain Cont monad does the job well enough.
08:56:41 <TheHunter> zipper is basically the same as Oleg's function which transforms a traversal function into a datatype, but it's much simpler since it doesn't use the complicated and obscure CC monad.
08:57:06 <xerox> *You* are saying complicated and obscure.
08:57:13 * xerox freaks out
08:57:51 <paolino_> can someone parse this for me :/
08:57:54 <paolino_> instance Monad Tray where
08:57:54 <paolino_>     Empty        >>= _      = Empty
08:57:54 <paolino_>     (Contains x) >>= worker = worker x
08:58:07 <xerox> I thought that the fact that they are 'composable as functions' would make them easier to understand for me.
08:58:08 <TheHunter> it's a Maybe monad.
08:58:19 <xerox> Indeed.
08:58:22 <basti_> paolino_: what is it that you don't understand?
08:58:44 <paolino_>     Empty        >>= _      = Empty
08:59:02 <Heffalump> (>>=) Empty _ = Empty
08:59:04 <Heffalump> does that help?
08:59:12 <paolino_> ah
08:59:17 <xerox> '_' means everything, without bounding it to a name
08:59:18 <paolino_> porcput
08:59:18 <basti_> "_" means "don't care about that value.
08:59:20 <Heffalump> it's just infix operator notation
08:59:56 <paolino_> Heffalump, got the point
09:00:21 <xerox> TheHunter: what do you suggest I could read to grok (partial) continuations (considering if they are actually useful to express interesting new kind of things) ?
09:00:23 <paolino_>     (Empty >>=  _ )  = Empty
09:00:59 <TheHunter> xerox, the CC monad is really hard to understand. I think got them at some point, but I've forgotten much about it since then.
09:01:05 <paolino_> where is the Tray here ?
09:01:37 <xerox> TheHunter: I'll give a try to simonpj & co paper.
09:01:39 <paolino_> data Tray x = Empty | Contains x here :]
09:02:06 <TheHunter> if you want to grok them, I suggest you start reading the paper at page 40 or something where they give the type signatures for their weird functions. Help a lot to find out how their interaction is.
09:02:36 <xerox> TheHunter: I was searching for a paper Haskell-based for that reason, yep.  Thanks for the advice.
09:03:18 <int-e> paolino_: the _ is a dummy variable, a placeholder for values that are not going to be used
09:03:56 <int-e> (what's it technically? a pattern that matches everything and binds nothing? I forgot.)
09:04:54 <paolino_>     ((Contains x) >>= worker)= worker x and this ?
09:05:21 <int-e> paolino_: and compare your Tray type to data Maybe a = Nothing | Just a ... you'll find that it's quite similar. Maybe has a Monad instance that works exactly like the Tray one.
09:06:13 <int-e> paolino_: that unpacks the value of a full tray, and applies the worker function to it. The worker function is defined to return a new Tray, either empty or filled with some value.
09:06:46 <paolino_> if the Tray is Contain x and operates on anything the result is worker applied on x ?
09:07:01 <paolino_> worker/anything
09:08:39 <paolino_> feeding a worker with a Tray containing x is like t
09:08:46 <paolino_> let the worker on x
09:09:49 <paolino_> it's not that Maybe is clearer to me
09:09:49 <int-e> paolino_: I think the model is this: You have a piece of work on a tray. A worker can take the piece of work and modify it; this will either break it or yield a new piece of work (or a finished product). In the latter case, the worker puts it on a tray for the next worker; in the first case he leaves an empty tray. The purpose of >>= is to carry a tray to a worker and give him the piece to work on.
09:11:41 <paolino_> sounds easy :[
09:11:44 * jyp nods
09:13:10 <jyp> Computationally, it implements early abortion of a procedure
09:13:56 <basti_> jyp: hey! i saw your code in yi! great work! its so much clearer than mine
09:14:25 <xerox> TheHunter: for the latter part of the question, are them really useful to something?  I mean, it's worth it going into them, like, say, monads?
09:15:31 <jyp> basti_: thanks
09:15:53 * paolino_ touches desperation and start thinking my math professors has had allucination voting me
09:16:11 <jyp> I would like to continue working on it, but I'm sort of stalled by the hIde transition
09:16:18 <basti_> hmm i see
09:16:26 <basti_> whats your plans for it?
09:16:55 <jyp> basically fix the "TODOs" and "FIXMEs" ;P
09:17:12 <basti_> oh ok
09:17:17 <basti_> i'll have a look into it
09:17:39 <bourbaki> moin
09:19:49 <jyp> basti_: mostly I'd like to get rid of the 'atomic' calls in the keymap definition
09:20:34 <droundy> I have a GADT-related question.
09:21:10 <paolino_> I always thought knowledge is subject to quantum theory, now I'm having the practical demonstration :)
09:21:30 <bourbaki> m theory
09:21:37 <bourbaki> :)
09:21:41 <droundy> If I have:
09:21:41 <droundy> data P a b where
09:21:52 <basti_> jyp: why did you do that at all? i thought its for some justified concurrency...
09:22:08 <droundy>   Hunk :: Int -> P a b
09:22:08 <droundy>   Identity :: P a a
09:22:47 <droundy> And a function:
09:22:47 <droundy> isId Identity = True
09:22:47 <droundy> isId _ = False
09:23:23 <droundy> Is there any way to make isId on return constrain the type of its argument in the same way that a pattern matching case statement would do?
09:24:11 <jyp> basti_: It's for enclosing an interactive function
09:24:43 <Igloo> You could have   isId :: P a b -> Maybe (P a a)
09:24:49 <basti_> jyp: it's not STM's "atomic"?
09:25:01 <jyp> not at all ;-)
09:25:10 <ski> droundy : interesting question ..
09:25:10 <basti_> oh ok
09:25:27 <droundy> Igloo: but would that limit the argument itself?
09:25:34 <ski> droundy : it would only constrain type when returned value was True
09:25:35 <Igloo> No
09:25:41 <jyp> It's defined (and event commented) in the keybinding
09:25:52 <ski> (paolino_ : voting ?)
09:25:55 <droundy> ski: that's what I want.
09:26:06 <droundy> if I have foo :: Patch a a -> IO ()
09:26:23 <ski> droundy : i think the typesystem can't express that (at least easily)
09:26:44 <ski> droundy : in a logic programming language, it could possibly work
09:27:04 <droundy> :(
09:27:20 <paolino_> ski, the .... were convinced I was very good at math ....
09:27:48 <ski> droundy : you want to constrain types based on runtime-values .. such that e.g. in  'if isId ... then <A> else <B>' the type is constrained in <A>
09:28:11 <droundy> Right, that's precisely what I want.
09:28:34 <ski> but what if the result of isId isn't passed to a pattern-matching directly ?
09:28:40 <ski> how to keep track of this ?
09:29:10 <ski> (also, it needs to know that this is indeed isId's behaviour .. it can't tell that from the type if isId, alone)
09:29:43 <droundy> I could do it with pattern matching with 'case ... of { Identity -> <A>; _ -> <B>; }, but I wish I could define isId to implement the same constraint.
09:29:59 <ski> droundy : possibly you could have something of type   P a b -> exists x. Maybe (P x x)
09:30:20 <ski> or   P a b -> exists x. (Maybe (P x x),Equal x a,Equal x b)
09:30:34 <ski> or something like that (perhaps a typeclass Equal, instead ..)
09:32:02 <ski> hm, that's an idea
09:32:10 <ski> maybe views could do it, too
09:33:41 <droundy> Views?
09:34:34 <ski> never implemented, iirc
09:34:40 <ski> more or less, pattern abstractions
09:35:04 <ski> so one could e.g. have two views of complex numbers .. Rectangular and Polar
09:36:10 <ski> both would of course match .. but they'd give different parts
09:36:20 <droundy> Hmmm.  I don't see how views would help (but perhaps it's irrelevant, if they aren't implemented).
09:36:30 <ski> (internally using some coercions)
09:36:59 <ski> hm, well i'm not sure, anyway
09:39:05 <droundy> I guess one could write:  data MyBool a b where { MyTrue :: MyBool a a; MyFalse :: MyBool a b; }
09:39:20 <droundy> Then write isId :: P a b -> MyBool a b
09:40:01 <droundy> We'd still need pattern matching to get the constraints, but this would allow us to write a slightly trickier function for isId.
09:40:02 <SamB> how do I tell cabal to build a package for per-user installation?
09:40:58 <droundy> ski: case isId ... of { MyTrue -> <A>; MyFalse -> <B>; }
09:41:05 <Lunar^> droundy: hi! Did you made any progress with FUSE?
09:41:43 <ski> droundy : m .. that can work
09:42:10 <droundy> Lunar^: No, I've dropped that project... I really only worked on FUSE while I was on vacation (and needed a bit of a break from darcs, too).
09:42:35 <Lunar^> droundy: fun enough, my inital motivation for HFuse was to try a DarcsFS
09:42:42 <Lunar^> droundy: never got past the binding though
09:43:19 <Lunar^> droundy: I should have adversited it earlier :( I feel sorry about the work duplication
09:43:48 <pesco> Can someone enlightened point me to a source for learning about delimited continuations?
09:44:23 <droundy> Lunar^: No problem, I enjoyed myself, and learned about hsffig, which was nice.
09:44:45 <Lunar^> droundy: good to know :)
09:46:03 <droundy> Lunar^: Actually, i'm currently skeptical about how useful FUSE will be, since it seems hard to use it to implement a filesystem with POSIX semantics.  :(
09:48:59 <TheHunter> xerox, i wouldn't know, never used them seriously. There are certainly applications, but you will also need to put a lot of effort in really understanding them.
09:49:16 <ski> (pesco : first two papers referenced at http://www.haskell.org/hawiki/CpsTransform has info about CPS transform and delimited continuations .. not so much about uses of them, though)
09:49:31 <pesco> ski: Okay, thanks.
09:49:35 <droundy> ski: can you see how to extend MyBool to let me avoid pattern matching? I'd like to get around having nested case statements...
09:50:12 <ski> hm, no sorry
09:50:37 <ski> (at times you could possibly case on multiple MyBool:s, though)
09:51:01 * ski briefly wonders if one can indent cases like if-then-else-if-..
09:51:17 <droundy> how is that?
09:51:21 <ski> hm
09:51:41 <ski> possibly you can make some custom function/operator ..
09:52:12 <monochrom> You can foldify and monadize MyBool.
09:52:55 <SamB> is it possible to upgrade Cabal without upgrading GHC?
09:53:04 <ski> (i.e. so you can use '\' and possibly '$' which you can indent more freely, instead of case)
09:56:20 <droundy> monochrom: I don't follow what you mean by foldify and monadize.
10:26:29 <SamB> why is ghc complaining about stuff like:
10:26:41 <SamB> ghc-6.4: Error: module 'Distribution.Compat.ReadP' is exposed by package Cabal-1.0 and package Cabal-1.1.3
10:26:45 <SamB> Error: module 'Distribution.Extension' is exposed by package Cabal-1.0 and package Cabal-1.1.3
10:26:45 <SamB> Error: module 'Distribution.GetOpt' is exposed by package Cabal-1.0 and package Cabal-1.1.3
10:27:00 <SamB> when I just ran `ghc-pkg hide Cabal-1.0'?
10:30:12 <kosmikus> ghc-6.4 is somewhat broken w.r.t. multiple versions of one package
10:30:17 <kosmikus> ghc-6.4.1 doesn't have this problem
10:31:00 <SamB> so I need to update?
10:31:08 <SamB> great
10:32:03 <kosmikus> not necessarily
10:32:09 <SamB> how do I purge all my installed packages...
10:32:33 <SamB> oh?
10:33:18 <SamB> what are my other options?
10:33:25 <kosmikus> just unregister Cabal-1.0
10:36:29 * SamB wonders if this is reversible
10:37:00 <sethk> SamB, there is always  rm -fr   :)
10:37:12 <sethk> SamB, but that tends not to be reversible
10:39:26 <kosmikus> SamB: you can probably "save" the package description via "ghc-pkg describe Cabal-1.0" first, then you can re-register it later
10:39:40 <kosmikus> SamB: but you probably won't need Cabal-1.0 anymore
10:40:26 <SamB> kosmikus: I guess so
10:41:42 <SamB> so, where do I get the gtk package?
10:42:04 <kosmikus> SamB: gtk2hs
10:42:20 <kosmikus> http://haskell.org/gtk2hs/
10:43:05 <SamB> hmm, I seem to be missing something called cpphs...
10:43:23 <xerox> SamB: it's just a preprocessor a-la cpp
10:44:23 <SamB> xerox: should I give an argument, should I symlink something there, or what?
10:45:09 <Oejet> I'm afk, 8) Denmark--Greece.
10:46:28 <xerox> SamB: install it
10:47:00 * wagerlabs looks around appraisingly
10:47:16 <SamB> oh, you didn't tell me it was a debian package!
10:47:36 <SamB> a whole 25 kB!
10:47:51 <xerox> I'm deeply sorry.
10:48:03 * SamB is kidding ;-)
10:48:09 <wagerlabs> folks, i have successfully moved past endian data into composing packets
10:48:22 <xerox> :-)
10:48:35 * xerox gives the today's golden lambda award to wagerlabs
10:48:38 <wagerlabs> got another issue now :-)
10:48:50 <SamB> my dpkg database seems to be in dire need of lubrication
10:48:50 <xerox> They call it 'fun'
10:48:51 <wagerlabs> xerox: hmmm... for what kind of achievement?
10:48:55 <wagerlabs> haha
10:49:42 <wagerlabs> i want to define a packet data type (several actually) and these consist of named fields (obviously)
10:49:56 <SamB> is it probably full of actual cruft records, do I actually have all that cruft installed, or is it just old and tired?
10:50:01 <wagerlabs> but i want to make sure that each packet has a size method and put/get methods
10:50:23 <wagerlabs> so i have a ByteSized type class and the Binary type class from NewBinary
10:51:12 <wagerlabs> how do i make my packets a subclass of both binary and bytesized so that they need to implement size, put and get from both parent type classes?
10:51:45 <xerox> class (Foo a, Bar a) => Quux a where ... -- ?
10:52:03 <wagerlabs> xerox: i tried that :-)
10:52:10 <xerox> What was the result
10:52:26 <wagerlabs> class ByteSized a where byteSize :: a -> Int
10:52:29 <wagerlabs> then the Binary
10:52:48 <wagerlabs> then data SrvHandShakedPacket = Make { procType :: CommandProcType }
10:53:34 <xerox> I'm not sure about what you mean.
10:53:37 <wagerlabs> instance (ByteSized a, Binary a) => SrvHandShakedPacket a where
10:53:37 <wagerlabs>     byteSize (ByteSized a) = byteSize $ procType a
10:53:52 <wagerlabs> Packet.hs:13:4:
10:53:52 <wagerlabs>     `byteSize' is not a (visible) method of class `SrvHandShakedPacket'
10:53:52 <wagerlabs> Packet.hs:13:14: Not in scope: data constructor `ByteSized'
10:54:12 <xerox> SrvHandShakedPacket is both a type and a class ?!
10:54:42 <wagerlabs> xerox: that's the thing, i need a server... packet class that can size, read and write itself... and that has data
10:54:47 <SamB> ls
10:54:51 <SamB> er, hmm..
10:54:53 <xerox> .
10:54:53 <xerox> ..
10:54:55 <xerox> :P
10:55:06 <SamB> thats ls -a, not ls!
10:55:10 <wagerlabs> xerox: do i make same?
10:55:18 <wagerlabs> make sense, sorry
10:55:57 <xerox> wagerlabs: types which instantiates the two classes on which the third one depends on, could instantiate the third too
10:56:19 <wagerlabs> xerox: and what does that mean in layman's terms?
10:57:16 <SamB> wagerlabs: instance uses the type syntax a bit differently from how it is used in real types
10:58:26 <xerox> class (Eq a, Ord a) => Num a where ... -- means that a Num a must instantiate Eq and Ord.
10:58:42 * SamB updates happy
10:58:47 <xerox> and then it will implement all the functions it needs to implement to be a Num.
10:59:02 <wagerlabs> xerox: well, that's what i want but can't figure out how to do it
10:59:26 <wagerlabs> this doesn't work either
10:59:27 <wagerlabs> class (ByteSized a, Binary a) => Packet a
10:59:27 <wagerlabs>     
10:59:27 <wagerlabs> data SrvHandShakedPacket = Make { procType :: CommandProcType }
10:59:27 <wagerlabs>                          deriving (Packet)
11:00:11 <xerox> How is called the class which types must be instances of ByteSized and Binary ?
11:00:20 <wagerlabs> Packe
11:00:21 <wagerlabs> t
11:00:34 <xerox> How is called a sample type which will instantiate Packet?
11:00:43 <xerox> Srv..=
11:00:47 <xerox> Srv..?
11:00:49 <wagerlabs> ServerHandshakePacket
11:00:53 <xerox> ok.
11:01:03 <xerox> Write the class blah packet definition
11:01:18 <wagerlabs> i thought i did
11:01:18 <wagerlabs> class (ByteSized a, Binary a) => Packet a
11:01:23 <xerox> where .. ?
11:01:40 <wagerlabs> do i have to retype the functions from both base classes in there?
11:01:58 <wagerlabs> i.e. the byteSize from ByteSized and put_ and get from Binary?
11:02:00 <xerox> I mean, which functions does work with Packets?
11:02:10 <wagerlabs> size, get and put
11:02:23 <wagerlabs> whey exist in the parent classes
11:02:33 <wagerlabs> do i need to list them again?
11:02:42 <xerox> class (ByteSized a, Binary a) => Packet a where
11:02:42 <xerox>     size :: a -> ...
11:02:42 <xerox>     put :: ...
11:02:45 <xerox>     ...
11:02:55 <xerox> Oh, wait.
11:03:09 <xerox> Could you write the class definition for ByteSized and Binary ?
11:03:16 <wagerlabs> sure
11:03:23 <wagerlabs> class ByteSized a where byteSize :: a -> Int
11:03:40 <SamB> hmm, I wonder why /var/lib/dpkg/status is a text file?
11:03:45 <wagerlabs> class Binary a where
11:03:45 <wagerlabs>     put_   :: BinHandle -> a -> IO ()
11:03:45 <wagerlabs>     put    :: BinHandle -> a -> IO (Bin a)
11:03:45 <wagerlabs>     get    :: BinHandle -> IO a
11:03:57 <wagerlabs> i don't need the put from Binary, just put_ and get
11:04:02 <xerox> wagerlabs: Binary types must me ByteSized right?
11:04:20 <xerox> s/me/be/
11:04:24 <wagerlabs> xerox: that's my requirement
11:04:29 <wagerlabs> xerox: normally they don't
11:04:35 <wagerlabs> need to be
11:04:44 <xerox> So put the constraint to a to be a ByteSize a, on Binary a.
11:04:46 <wagerlabs> i want my packets to be bytesized and binary
11:05:04 <wagerlabs> xerox: where do i put that?
11:05:09 <wagerlabs> xerox: in the packet class?
11:05:18 <xerox> class <constraint> => Binary a where ...
11:05:34 <xerox> So you can't have Binary types which aren't constrained as ByteSized.
11:05:36 <SamB> great, now I get:
11:05:48 <SamB> Building ghc-api-0.2...
11:05:48 <SamB> ghc-6.4: unknown package: Cabal-1.1.3
11:05:48 <wagerlabs> xerox: no, i want to have Binary types that are NOT sized
11:05:54 <wagerlabs> xerox: Packet has to be sized
11:06:00 <wagerlabs> class (ByteSized a, Binary a) => Packet a where
11:06:32 <xerox> a class defines a set of types which implements some functions.
11:06:42 <xerox> brb
11:07:45 <beschmi> wagerlabs: "deriving (Packet)", you can only derive instances for some hardcoded classes
11:07:55 <wagerlabs> beschmi: oops
11:08:52 <xerox> back
11:09:03 <xerox> wagerlabs: do you understand what I mean?
11:09:04 <beschmi> wagerlabs: if you derive eg. Show, then the compiler generates instance Show YourType ..
11:09:09 <wagerlabs> xerox: no
11:09:13 <wagerlabs> class (ByteSized a, Binary a) => Packet a where
11:09:13 <wagerlabs>     byteSize :: a -> Int
11:09:13 <wagerlabs>     put_ :: BinHandle -> a -> IO ()
11:09:13 <wagerlabs>     get  :: BinHandle -> IO a
11:09:19 <wagerlabs> xerox: like this?
11:09:24 <xerox> wagerlabs: there is something you should rethink.
11:09:33 <wagerlabs> xerox: probably, what's that?
11:09:46 <xerox> A TypeClass describes a set of types which implements some functions.
11:09:48 <wagerlabs> xerox: all i want is a nice design for my packets
11:09:59 <xerox> What are those functions for the Packet types?
11:10:07 <xerox> What are those functions for the Binary types?
11:10:12 <xerox> What are those functions for the ByteSized types?
11:10:24 <wagerlabs> the functions for the packet are those of ByteSized AND Binary
11:10:27 <wagerlabs> i.e.
11:10:35 <wagerlabs>     byteSize :: a -> Int
11:10:36 <wagerlabs>     put_ :: BinHandle -> a -> IO ()
11:10:36 <wagerlabs>     get  :: BinHandle -> IO a
11:10:40 <SamB> can I get some kind of help here?
11:11:19 <kosmikus> I've never built ghc-api
11:11:21 <xerox> wagerlabs: you can't have a class which doesn't have any function, as far as I know
11:11:29 <kosmikus> SamB: ghci -package Cabal-1.1.3 works?
11:11:36 <wagerlabs> xerox: fine, how about this?
11:11:42 <wagerlabs> class (ByteSized a, Binary a) => Packet a where
11:11:42 <wagerlabs>     byteSize :: a -> Int
11:11:42 <wagerlabs>     put_ :: BinHandle -> a -> IO ()
11:11:42 <wagerlabs>     get  :: BinHandle -> IO a
11:11:54 <beschmi> wagerlabs: do you only want to be able to use "Packet a =>" in type declarations as a shortcut?
11:11:57 <SamB> kosmikus: it sure seems to
11:12:01 <SamB> Loading package Cabal-1.1.3 ... linking ... done.
11:12:01 <SamB> Prelude>
11:12:12 <wagerlabs> i'm gonna have a lot of different packets
11:12:19 <kosmikus> SamB: ok, what's the call to ghc that produces the error message, then?
11:12:20 <wagerlabs> different data types that are packets
11:13:02 <wagerlabs> packetA, packetB, etc
11:13:15 <SamB> kosmikus: are you sure you want the whole thing?
11:13:42 <kosmikus> SamB: any -ignore-package Cabal in it?
11:13:45 <wagerlabs> Q1: if I do this, class (ByteSized a, Binary a) => Packet a, do i have to add this:
11:13:53 <wagerlabs>  where
11:13:53 <wagerlabs>     byteSize :: a -> Int
11:13:53 <wagerlabs>     put_ :: BinHandle -> a -> IO ()
11:13:53 <wagerlabs>     get  :: BinHandle -> IO a
11:14:15 <SamB> /usr/bin/ghc -Isrc/cbits/ -Isrc/ -Isrc/nativeGen/ -Isrc/stage1 -Isrc/parser -package-name ghc-api -odir dist/build -hidir dist/build --make -i -isrc/coreSyn -isrc/nativeGen -isrc/prelude -isrc/simplCore -isrc/typecheck -isrc/utils -isrc/cmm -isrc/cprAnalysis -isrc/ghci -isrc/javaGen -isrc/ndpFlatten -isrc/profiling -isrc/simplStg -isrc/stgSyn -isrc/types -isrc/codeGen -isrc/deSugar -isrc/hsSyn -isrc/main -isrc/parser -isrc/specialise
11:14:16 <SamB>  -isrc/stranal -isrc/iface -isrc/rename -isrc/basicTypes -#include "src/parser/hschooks.h" -cpp -fglasgow-exts -DGHCI -DUSE_READLINE -ignore-package lang -v0 -package template-haskell-1.0 -package readline-1.0 -package unix-1.0 -package Cabal-1.1.3 -package base-1.0 -package haskell98-1.0 $LOTS_OF_MODULES
11:14:27 <xerox> BOOM.
11:14:45 <xerox> wagerlabs: and then the other classes' definition what will look like?
11:15:26 <xerox> You could do it with fundeps, but I don't know if it's the Right Solution (TM) in this case.
11:15:27 <wagerlabs> well, tried the following but it does not work
11:15:29 <wagerlabs> data SrvHandShakedPacket = Make { procType :: CommandProcType }
11:15:29 <wagerlabs> instance Packet a => Packet (SrvHandShakedPacket a) where
11:15:30 <wagerlabs>     byteSize a = 10
11:15:54 <kosmikus> SamB: let me try if I can reproduce this
11:15:58 <wagerlabs> i'm missing put and get of course to store and retrieve procType
11:16:08 <xerox> wagerlabs: what does a ByteSized type have to implement?
11:16:20 <wagerlabs> class ByteSized a where byteSize :: a -> Int
11:16:23 <xerox> wagerlabs: what does a Binary type have to implement?
11:16:28 <wagerlabs> that's it, just the byteSize methods
11:16:38 <wagerlabs> class Binary a where
11:16:39 <wagerlabs>     put_   :: BinHandle -> a -> IO ()
11:16:39 <wagerlabs>     put    :: BinHandle -> a -> IO (Bin a)
11:16:39 <wagerlabs>     get    :: BinHandle -> IO a
11:16:41 <xerox> wagerlabs: what does a Packet type have to implement?
11:17:12 <wagerlabs> packet? the methods of both ByteSized and Binary
11:17:15 <xerox> Note that it _must_ implement something per-se.
11:17:46 <wagerlabs> do i have to retype the methods like this:
11:17:47 <wagerlabs> class (ByteSized a, Binary a) => Packet a where
11:17:49 <wagerlabs>     byteSize :: a -> Int
11:17:49 <wagerlabs>     put_ :: BinHandle -> a -> IO ()
11:17:49 <wagerlabs>     get  :: BinHandle -> IO a
11:17:57 <xerox> And what does the other two classes implement?
11:18:08 <xerox> It's the third time we go through the same thing.
11:18:32 <wagerlabs> xerox: try a different approach ;) tell instead of question, maybe? :D i appreciate your help, though
11:18:55 <xerox> You should note that a class must implement at least a function.
11:19:10 <wagerlabs> that's fine, so are you saying that i can get away with this
11:19:19 <beschmi> wagerlabs: your types can be instances of both typeclasses, so i don't see why you need the Packet typeclass (besides using it as some sort of typeclass alias)
11:19:28 <wagerlabs> class (ByteSized a, Binary a) => Packet a where
11:19:28 <wagerlabs>     foo :: a -> IO ()
11:19:35 <wagerlabs> with a dummy method or something
11:19:37 <xerox> "Void" classes which only specifies the dependency of types could be done, but you lose the naming, I think.
11:19:52 <xerox> Do you think a dummy method makes yours a good design?
11:20:02 * wagerlabs sighs
11:20:05 <xerox> I'd step back and think.
11:20:06 <wagerlabs> all i want is a packet
11:20:15 <beschmi> wagerlabs: is it only for naming?
11:20:19 <wagerlabs> i have my packet with one named field
11:20:20 <wagerlabs> data SrvHandShakedPacket = Make { procType :: CommandProcType }
11:20:48 <wagerlabs> i want that to have a size and put/get methods so it seems natural for me to have it instantiate ByteSized and Binary. anything wrong with this approach/
11:21:16 <xerox> wagerlabs: a class make sense if there is a function which operates on a restricted set of types.
11:21:25 <xerox> (or more functions, even)
11:21:27 <wagerlabs> of course i want to have generic functions that operate on instances of Packet
11:21:41 <beschmi> then you make SrvHandShakedPacket an instance of ByteSized and of Binary and can use all methods you need with SrvHandShakedPacket
11:21:45 <wagerlabs> any packet
11:21:55 <wagerlabs> beschmi: that's where i was
11:22:14 <xerox> beschmi: he does have a set of Packets.
11:22:22 <SamB> wagerlabs: you could do "type Packet a = (Binary a, Bytesized a) => a"...
11:22:35 <wagerlabs> SamB: type or instance?
11:22:48 <xerox> SamB: can you?
11:23:18 <SamB> xerox: you can with -fglasgow-exts, at least. dunno about without...
11:24:37 <wagerlabs> SamB: what does the full thing look like? you have a ...
11:25:49 <xerox> wagerlabs: he's suggesting you to declare ByteSized and Binary classes, and use a synonym "type Packet a = ..".
11:26:25 <xerox> Then you will use it as  doSomethingWithAPacket :: Packet a -> IO ()
11:26:26 <wagerlabs> then i can instantiate that? for the server handshake packet
11:26:41 <xerox> Instantiate what, in what class?
11:26:55 <wagerlabs> the packet thing must have getSize, put and get methods
11:27:12 <wagerlabs> that's why i was trying to derive it from ByteSized and Binary
11:27:19 <xerox> (foo :: Packet a -> IO ()  will just be a synonym for  foo :: (Binary a, ByteSized a) => a -> IO ())
11:27:43 <xerox> We got it so far, do you understand type synonyms?
11:28:02 <wagerlabs> xerox: i'm not dumb. i just can't get what i want ;)
11:28:28 <integral> you want to just say instance once per packet-datatype, rather than twice?
11:28:41 <wagerlabs> xerox: i don't need type synonyms, i need to force all subclasses of packets to have getSize, put and get methods
11:28:56 <kosmikus> SamB: compilation succeeds for me with ghc-6.4.1, will try now with ghc-6.4
11:29:12 <wagerlabs> integral: once is fine
11:29:12 <xerox> wagerlabs: classes makes sense if functions operates on types of that class.
11:29:29 <wagerlabs> xerox: that's fine, assume i'll have them (functions). later.
11:29:50 <wagerlabs> i have a well-defined problem. i'm looking for solutions and don't want to redefine the problem itself
11:30:05 <xerox> the solution is redefine the problem itself
11:30:13 <xerox> or use explicit constraints
11:30:16 <wagerlabs> in c++ terms, i want an abstract packet class that derives from bytesized and binary
11:30:25 <xerox> or a synonym, which is the same thing but looks better
11:30:32 <wagerlabs> then i want to derive these
11:30:45 <wagerlabs> xerox: can i instantiate a synonym?
11:31:04 <xerox> I don't think so.
11:31:25 <wagerlabs> ok, i'm gonna lay my card on the table
11:32:05 <wagerlabs> i can read a Binary from a Handle and write it to the Handle. BinHandle actually. so my packets have to be instances of Binary
11:32:45 <wagerlabs> but before i shove the packet into the handle i need to allocate a chunk of memory so my packets have to be instances of ByteSized
11:32:50 <wagerlabs> is this clear?
11:33:05 <wagerlabs> i'm having trouble achieving this
11:33:26 <xerox> The concept of what a Packet is, is the point.
11:33:38 <xerox> If a Packet is a class of types, they do need to implement some function.
11:33:53 <wagerlabs> i need to 1) allocate a chunk of memory to open a Binary (BinMem) handle into this chunk of memory
11:33:57 <xerox> If a Packet is a type which is constrained to be in other classes, you just need constraints
11:34:20 <wagerlabs> but i need to know the size of this chunk of memory so i need packets to be able to tell me their size
11:34:39 <wagerlabs> a packet is both data and methods
11:34:54 <wagerlabs> if's a list of fields essentially, where all the fields are Binary themselves
11:35:09 <wagerlabs> this is a packet data SrvHandShakedPacket = Make { procType :: CommandProcType }
11:35:41 <xerox> so you just need  CommandProcType  to be  instantiated in  Binary.
11:35:44 <wagerlabs> since each packet is a Binary and all of its fields are Binary then i can just put of get the fields in the packet's put/get mehtods
11:36:19 <kosmikus> SamB: succeeds for ghc-6.4 as well
11:36:37 <wagerlabs> xerox: this is a packet too
11:36:37 <wagerlabs> data PacketA = Make { a, b, c, d :: Int }
11:36:42 <SamB> kosmikus: huh
11:36:43 <kosmikus> SamB: can you paste your "ghc-pkg list" output somewhere?
11:36:49 <kosmikus> SamB: pm is also ok
11:36:49 <wagerlabs> sorry, like this
11:36:52 <xerox> wagerlabs: I give up.
11:36:59 <SamB> @paste
11:37:00 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:37:09 <wagerlabs> like this i guess
11:37:09 <wagerlabs> data PacketA = Make { a, b, c, d :: (Binary Int) }
11:37:54 <wagerlabs> xerox: there's an impedance here ;) i'm trying to explain my business problem and looking for a haskell solution. you are trying to teach me haskell without addressing my business problem ;)
11:37:59 <beschmi> wagerlabs: you want to implement a generic "shove the packet into the handle" function?
11:38:16 <wagerlabs> xerox: i appreciate your help but can't figure out how to put together what  you are saying to solve my problem
11:38:32 <wagerlabs> beschmi: that (these) functions are already part of the Binary type class
11:38:39 <wagerlabs> they are called put and get
11:38:50 <wagerlabs> class Binary a where
11:38:50 <wagerlabs>     put_   :: BinHandle -> a -> IO ()
11:38:50 <wagerlabs>     put    :: BinHandle -> a -> IO (Bin a)
11:38:50 <wagerlabs>     get    :: BinHandle -> IO a
11:39:22 <beschmi> i thought you need the ByteSized for this?
11:39:25 <SamB> who has the editing lock on the paste page?
11:40:11 <wagerlabs> beschmi: i need that too. i need to know the size of the packet so that i can allocate a chunk of memory to store it. before i shove that buffer into the handle.
11:40:59 <wagerlabs> i solved this before, in a way
11:40:59 <wagerlabs> instance (ByteSized a, Binary a) => Binary (BigEndian a) where
11:41:00 <wagerlabs>     put_ bh (BigEndian a) =
11:41:08 <wagerlabs> newtype BigEndian a = BigEndian a
11:41:24 <wagerlabs> but now i was trying to add data :-) maybe that's my mistake
11:43:52 <tomaszz> wagerlabs: I was only reading parts of this discussion, but it seems that some of your problems come from treating type-classes like subclassing in OO languages
11:44:09 <wagerlabs> tomaszz: 100%
11:44:39 <wagerlabs> tomaszz: i welcome native haskell solutions since i'm trying to learn the language
11:46:00 <wagerlabs> tomaszz: but i see the type of approach that i'm trying to take in the haskell intros
11:46:01 <tomaszz> wagerlabs: did you manage to sort it out?
11:46:07 <wagerlabs> tomaszz: hall daume's namely
11:46:30 <wagerlabs> tomaszz: not at all
11:46:57 <tomaszz> wagerlabs: I mean the difference between OO subclassing and Haskell's type-classes
11:47:05 <wagerlabs> in haskell-tutorial.pdf, page 119, an Entity class with a bunch of methods is defined
11:47:26 <wagerlabs> then there's a data Paddle = Paddle { x, y, z :: Int } type of thing
11:47:44 * tomaszz goes for the pdf
11:48:11 <wagerlabs> and finally there's instance Entity Paddle where ... (the Entity method definitions)
11:48:25 <wagerlabs> i'm trying to do the same thing... except my methods come from two separate Entities
11:49:10 <wagerlabs> but now it's some sort of a problem, all of a sudden
11:49:13 <wagerlabs> so i don't get it
11:49:17 <tomaszz> wagerlabs: so you have to make two "instance" declarations
11:49:35 <Philippa> in haskell 98 there is no way to keep a list of "things that have instances of some typeclass"
11:49:39 <wagerlabs> tomaszz: why not one? because it's a data type and not a newtype
11:49:50 <tomaszz> wagerlabs: one for ByteSized, one for the other one I don't remember
11:49:56 <wagerlabs> Binary, ok
11:50:02 <wagerlabs> but why can i do this then
11:50:13 <wagerlabs> instance (ByteSized a, Binary a) => Binary (BigEndian a) where
11:50:13 <wagerlabs>     put_ bh (BigEndian a) =
11:50:23 <wagerlabs> newtype BigEndian a = BigEndian a
11:50:31 <wagerlabs> because BigEndian is a newtype?
11:50:35 <integral> an instance only defines methods for the typeclass to the right of the =>
11:50:49 <wagerlabs> above works and i don't have to have two separate instance declarations
11:50:56 <tomaszz> wagerlabs: no, newtype doesn't make much difference here
11:50:58 <ski> that says, assuming there are instances for ByteSized a and Binary a, we make an instance of Binary (BigEndian a) as follows ..
11:51:07 <integral> nm
11:51:13 <ski> wagerlabs : no nothing with the newtype to do
11:51:56 <wagerlabs> fine, so what changes when instead of newtype ... i say data BigEndian = BigEndian { x, y, :: Int } for example
11:52:25 <wagerlabs> things seem to break all of a sudden
11:52:26 <beschmi> wagerlabs: the above doesn't make BigEndian a an instance of ByteSized
11:52:53 <tomaszz> wagerlabs: I am not sure, but aren't you trying to derive (Binary, ByteSized) ?
11:52:54 <wagerlabs> beschmi: ok, maybe that's where i'm mistaken
11:53:03 <ski> wagerlabs : because then the dataconstructor BigEndian takes two arguments, so 'put_ bh (BigEndian a) =' will be wrong
11:53:03 <wagerlabs> tomaszz: i was trying to
11:54:02 <wagerlabs> so how do i do the following in haskell then? i'm gonna explain the problem conceptually
11:54:03 <ski> (one can only just use that ghc-deriving extension on newtypes)
11:54:36 <wagerlabs> i want to have packets which are a bunch of fields. i want packets to be instances of newbinary so that i can read/write them to/from a chunk of memory
11:54:59 <wagerlabs> i want to make sure i can get the size of each packet which is the total size of its Binary fields (each field is in turn a Binary)
11:55:30 <wagerlabs> i need each packet to tell me the size so that i can allocate a big enough chunk of memory
11:55:52 <fnord123> hey joel
11:55:56 <fnord123> <- ewan
11:56:03 <wagerlabs> and in the put/get methods of Binary (packet is a Binary, right?) i would just store my fields
11:56:05 <wagerlabs> fnord123: hi ewan
11:56:07 <Philippa> you could use Generic Haskell or Template Haskell. Otherwise you're going to have to provide all the instances by hand
11:56:12 <tomaszz> wagerlabs: did you try: instance Binary Packet where ...
11:56:29 <tomaszz> wagerlabs: and: instance ByteSized Packet where ...
11:56:35 <wagerlabs> Philippa: hi do not mind providing instances by hand
11:56:39 <wagerlabs> tomaszz: not yet, let me try
11:56:47 <tomaszz> wagerlabs: sorry, Packet is a type-class in your code?
11:56:58 <wagerlabs> tomaszz: never mind that, i have no idea what it should be
11:57:32 * wagerlabs is whipping up some code
11:57:34 <tomaszz> wagerlabs: say you have a data-type to represent some kind of packets - PingPacket
11:57:41 <wagerlabs> tomaszz: yeha
11:57:45 <wagerlabs> tomaszz: i'm trying to write that up
11:57:51 <wagerlabs> data PacketA = Make { a, b :: (Binary Int) }
11:57:54 <wagerlabs> something like this
11:58:11 <tomaszz> wagerlabs: you need: instance Binary PacketA where ...
11:58:23 <tomaszz> wagerlabs: you need: instance ByteSized PacketA where ...
11:58:31 <tomaszz> wagerlabs: of course, you have to fill the ...
12:02:10 <wagerlabs> data PacketA = Make { a, b :: Binary Int }
12:02:50 <wagerlabs> can i fix a and b to be not just Binary but Binary Word8 for example
12:03:01 <wagerlabs> instance Binary Word8 where -- that's in Binary.hs
12:03:09 <tomaszz> wagerlabs: ah! remove Binary after ::
12:03:28 <wagerlabs> tomaszz: aha!
12:03:33 <tomaszz> wagerlabs: data PacketA = Make { a, b :: Int }
12:04:42 <tomaszz> wagerlabs: you know, you could forget about type-classes for a moment and write ordinary functions to do what you want
12:04:58 <wagerlabs> tomaszz: that would be too easy :-)
12:05:08 <tomaszz> wagerlabs: like putPacketA / getPacketA, etc
12:05:30 <tomaszz> wagerlabs: so you are trying to learn, not doing real work now? ;-)
12:05:41 <wagerlabs> tomaszz: both
12:07:39 <tomaszz> wagerlabs: seems like you are doing too much low-level programming for this stage of learning Haskell :-)
12:08:32 <tomaszz> wagerlabs: you know, if you don't care about efficiency, you could process packets as ordinary [Word8] lists
12:08:39 <wagerlabs> tomaszz: that's why i want to get past it really quickly
12:08:59 <spenatmannen> whats the name of the function that takes an integer I and an element and makes a list with I elements?
12:09:15 <tomaszz> spenatmannen: replicate?
12:09:19 <spenatmannen> yay!
12:09:20 <yaarg> replicate
12:09:22 <wagerlabs> tomaszz: thank you very much but i already spent 1/2 week figuring out the endian stuff :-) i finally have it working on top of NewBinary.Binary :D
12:10:42 <wagerlabs> one last bit... data PacketA = PacketA { a, b :: Int }
12:10:56 <wagerlabs> this one should be really simple :-)
12:10:57 <wagerlabs> instance Binary PacketA where
12:10:57 <wagerlabs>     put_ bh packet = do
12:10:57 <wagerlabs>                 put_ bh (a packet)
12:10:57 <wagerlabs>                 put_ bh (b packet)
12:11:00 <wagerlabs>     get bh = do
12:11:02 <wagerlabs>              return (PacketA {
12:11:05 <wagerlabs>                            a <- get bh,
12:11:07 <wagerlabs>                            b <- get bh
12:11:10 <wagerlabs>                           })
12:11:11 <tomaszz> wagerlabs: bzzzt
12:11:37 <sieni> A question about polymorphic algebraic types: Can I have different definitions for instances of say Eq depending on whether they are instances of Ord or not (i.e. something like data Foo a = Bar | Baz a (Foo a) if a is not in Ord and data Foo a = Bar | Baz a (Foo a) | Qux a a (Foo a) otherwise)
12:11:44 <sieni> ?
12:11:45 <wagerlabs> what's the correct syntax for the get? i'm trying to construct packetA where each field is read
12:12:25 <tomaszz> get bh = do
12:12:25 <tomaszz>     aa <- get bh,
12:12:25 <tomaszz>     bb <- get bh
12:12:25 <tomaszz>     return (PacketA { a = aa, b = bb })
12:12:39 <tomaszz> wagerlabs: without the first ,
12:12:58 <wagerlabs> tomaszz: no other way? can't do it like i did, right?
12:13:00 <tomaszz> wagerlabs: aa <- get bh
12:13:49 <tomaszz> wagerlabs: I am afraid no - recently there was a long discussion about allowing such things
12:13:54 <wagerlabs> tomaszz: ok
12:13:56 <wagerlabs> thanks
12:14:51 <wagerlabs> tomaszz: well, presto, things are working now!
12:15:09 <tomaszz> wagerlabs: :-)
12:16:09 * tomaszz thinks about sieni's problem...
12:18:03 * wagerlabs is getting a huge leg up with #haskell
12:18:48 <wagerlabs> this is gonna be the ultimate poker simulation environment. closed source, though, since i'm doing this as work for hire
12:18:59 <tomaszz> sieni: I don't understand the role of Eq in your question
12:19:09 <wagerlabs> i'll certainly blog about it, though
12:19:35 <astrolabe_> in what way simulation?
12:19:36 <SamB> how can it be ultimate if its closed-source?
12:19:54 <wagerlabs> SamB: feature-wise? :)
12:20:12 <wagerlabs> well, the customer has a c++ poker server with intermittent memory corruption
12:20:39 <wagerlabs> the requirement is to be able to launch at least 40,000 bots against the server and have them play in games, tournaments, etc. the bots can be AI or scripted
12:20:52 <wagerlabs> and QA techs have to be able to write scripts of their own
12:21:06 <wagerlabs> the 40k bots are simultaneous of course
12:21:13 <tomaszz> wagerlabs: you won't get much improvement if you are going to peek and poke all the time ;-)
12:21:23 <astrolabe_> Wow.  All to catch a memory leak?
12:21:28 <wagerlabs> i was gonna do this in erlang first but then QA techs would have to learn erlang
12:21:34 <basti_> wagerlabs: and you want the result to be rock-solid stable?
12:21:36 <wagerlabs> aleator: corruption, not a leak :)
12:22:01 <wagerlabs> basti_: the result i want is to be able to nail down the sequence of steps required to bring down a server
12:22:05 <beschmi> wagerlabs: liftM2 PacketA (get bh) (get bh), would be shorter in this case
12:22:28 <wagerlabs> beschmi: can you elaborate on that?
12:22:38 <basti_> wagerlabs: you're programming the replacement server, yes?
12:22:52 <wagerlabs> basti_: nope. i already have that. see http://wagerlabs.com
12:23:04 <basti_> ah
12:23:07 <wagerlabs> basti_: i'm programming the test harness that will simulate 40k players
12:23:16 <basti_> i see.
12:23:27 <wagerlabs> beschmi: let me try that
12:23:29 <beschmi> you could define get as: get bh = liftM2 PacketA (get bh) (get bh)
12:23:39 <wagerlabs> beschmi: yes, i like that more
12:24:05 <beschmi> look at the type of liftM2 (Control.Monad) to see how it works
12:24:32 <basti_> wagerlabs: so the new server is running, but sometimes falling apart?
12:25:07 <wagerlabs> erlang is really cool as far as launching tons of processes, etc. goes but it won't let me feed the customer haskell code and tell them that this is a new simple scripting language, specifically designed for testing :D
12:25:12 <wagerlabs> basti_: correct
12:25:19 <basti_> ah ok
12:25:23 <sieni> tomaszz: I'm trying to specify sets, so that for instances of Eq they are just a bunch of points and if they happen to be in Ord as well, I can specify a bunch of intervals as well
12:25:25 <wagerlabs> basti_: and they have been trying to figure it out for ages now
12:25:30 <wagerlabs> basti_: and they cannot
12:25:35 <basti_> and you're expecting that overload conditions are reproducible?
12:26:26 <wagerlabs> basti_: i have no idea but so long as i produce the test harness and writing scripts is simple we could all collectively write scripts and hurl them against the server
12:26:37 <wagerlabs> basti_: we being programmers and qa techs on the customer side
12:26:42 <tomaszz> beschmi: how could I not think about it? I am not writing enough Haskell these days... :-(
12:26:46 * basti_ nods
12:26:52 <basti_> i see the motivation easily
12:26:58 <basti_> i'm just being pessimistic
12:27:09 <wagerlabs> basti_: i think with enough scripts launched against the server something could be reproduced
12:27:29 <tomaszz> sieni: got you go clean the dishes :-(
12:27:39 <basti_> at least the source of the stench might be localized
12:27:42 <wagerlabs> haskell would let me do it in a structured environment i hope. maybe keeping track of exactly what sequence of steps was required to bring the server down
12:27:49 <wagerlabs> basti_: you are talking to me, right?
12:27:53 <basti_> wagerlabs: yes.
12:28:09 <wagerlabs> basti_: i think so, yes. someone could just run the server in the debugger to localize the problem
12:28:24 * basti_ nods
12:28:28 <basti_> and all just for a memory leak
12:28:31 <SamB> wagerlabs: heh
12:28:36 <wagerlabs> right now they are saying that in real life they can reproduce it a few times a day, i.e. it happens a few times a day
12:28:36 <SamB> just run it in a debugger...
12:28:45 <wagerlabs> in the lab it happens maybe twice a week
12:29:01 <wagerlabs> it's not memory leak, it's corruption. as in access violation ;)
12:29:05 <wagerlabs> as in the server going down
12:29:15 <basti_> :-o
12:29:19 <wagerlabs> so my task is to bring down the house
12:29:22 <SamB> the trouble with that is that debuggers don't break on heap corruption...
12:29:22 <wagerlabs> consistently
12:29:26 <basti_> i see.
12:29:31 <basti_> that might be tricky
12:29:45 <beschmi> tomaszz: what else? C++?
12:29:49 <wagerlabs> basti_: it's less trickly with a powerful test harness
12:30:04 <wagerlabs> just waiting for it to happen is certainly tricky
12:30:37 * basti_ nods
12:31:23 <wagerlabs> i have a few other uses for haskell down the road, like detecting collusion in poker and optimizing rake per table (profit per table) by figuring out what variables contribute most to the profit
12:31:47 <wagerlabs> the load-balancing proxy is something that i would write in erlang, though :D
12:31:50 <basti_> :P
12:32:23 <wagerlabs> but test harness is first. being able to make haskell look like simple-to-learn test scripts is the goal
12:32:28 <astrolabe_> Why doesn't collusion make online poker impossible, or offline poker for that matter?
12:32:47 <beschmi> tomaszz: i'm only writing some haskell on the weekend. introduced ocaml at my job and I don't want to use a second language that nobody understands there ;(
12:33:16 <wagerlabs> astrolabe_: it doesn't but if poker room owners want to fight it then i'm hear to take their money and create the tools for them
12:33:25 <fnord123> so can erlang scale infinitely
12:33:33 <wagerlabs> fnord123: i think so
12:33:51 <fnord123> or x - x/x-1
12:34:13 <fnord123> er upside down fraction. x - (x-1)/x
12:34:21 <Oejet> beschmi: s/don't understand/don't want to understand/, right?
12:34:23 <wagerlabs> oh, ewan the "lambasting the dependency injection pattern" ewan :D
12:34:34 <wagerlabs> fnord123: thanks for that tip
12:34:41 <fnord123> haha
12:34:47 * wagerlabs is having a lot of fun these days
12:34:59 <fnord123> im currently lambasting singletons at work and gamedev.net
12:35:02 <wagerlabs> despite the lower memory slot in my powerbook going dead
12:35:33 <tomaszz> beschmi: yes, C++
12:35:43 <wagerlabs> put a 1gb module in the upper slot and everything is rock solid again :-) now if i could only figure out which port the poker server on the virtual pc is using i would be in programmer heaven :)
12:36:00 <wagerlabs> fnord123: they published my article at www.devmaster.net :-)
12:36:27 <fnord123> cool. did gdnet not want it or something?
12:36:36 <wagerlabs> fnord123: i guess not
12:36:53 <fnord123> oh well
12:36:56 <wagerlabs> maybe they thought it was shameless self-promotion :D or maybe it was my mentioning that i wanted to publish it on gamasutra :D
12:39:10 <fnord123> i think they are in league with each other so i wouldnt have thought it would be a problem
12:39:20 <fnord123> maybe they prefer exclusivity
12:39:48 <wagerlabs> fnord123: dunno
12:39:53 * wagerlabs is very happy
12:40:02 <xerox> Finally :)
12:40:20 <wagerlabs> after only 2-3 days of intensive bugging of select distinguished members of #haskell i've got my ducks lined up in a row :D
12:41:03 <Philippa> been a while since I was really reading all the gamedev sites - what's gamedev.net like these days?
12:41:20 <wagerlabs> still the old... still the old...
12:41:37 <wagerlabs> oh, i forgot, i also want haskell as a DSL embedded in a game engine like Torque from www.garagegames.com
12:41:40 <wagerlabs> yeah!
12:41:49 <Philippa> so it's still inferior to flipCode even though flipCode's gone now? ;-)
12:42:13 <Philippa> Haskell would be rather cool for game sim-type code, yeah
12:42:20 <Philippa> would love to play around with FRP for something like that
12:42:30 <xerox> http://www.nihao-collective.com/aram/images/dood17.jpg
12:42:39 <wagerlabs> my love for haskell overwhelms me
12:43:01 <Philippa> ah. Give it a while, it'll merely make you happy later
12:43:20 <wagerlabs> xerox: is that you?
12:43:20 <Philippa> though I'm really looking forward to boxy types+proper existentials, amongst other things
12:43:21 <fnord123> full of children, Philippa.
12:43:38 <Philippa> fnord123: sounds familiar. We got some of the kiddies showing up in #flipcode sometimes
12:43:49 <fnord123> i remember
12:43:57 <wagerlabs> i thought the flipcode guys went to devmaster.net
12:44:13 <fnord123> so you're moving to haskell, joel?
12:44:13 <ski> sieni : i think not you can do that .. (btw, it's called 'parametric (algebraic) types', not 'polymorphic (algebraic) types' .. 'parametric because it take type parameters/arguments)
12:44:23 <wagerlabs> too bad flipcode went down, strange when i think about it. how much money does it take to keep a forum up?
12:44:27 <fnord123> thales drove me away from flipcode
12:44:36 <wagerlabs> fnord123: well, yes and no. what's thales/
12:44:54 <fnord123> he was a moron that was so boring it made me not visit the site
12:44:58 <wagerlabs> haskell is cool for a lot of things and erlang is much cooler for a very specific slice of things
12:45:32 <wagerlabs> if haskell had mnesia (a real-time, replicating, in-memory db that stores any language data) then i would think of not coding in erlang
12:45:34 <Philippa> I was never really a forum type there, mostly just hung around on IRC
12:45:55 <Philippa> heh
12:46:13 <Philippa> yeah, something like that'd probably be doable (aside, possibly, from the real time constraint) but non-trivial
12:46:15 <sieni> ski: Ok, but I can circumvent that, by using functions (a -> Bool) to test if my element belongs to the set
12:46:38 <wagerlabs> erlang is very good for networking and protocol type stuff. proxies, load balancers, etc. i would have done my simulation environment in erlang (i already did in fact, for openpoker) was it not for the "simple scripting language" requirement and my desire to get paid for learning new things
12:46:54 <wagerlabs> Philippa: it's not real-time, that's not a heavy requirement
12:47:18 <wagerlabs> Philippa: erlang is soft real-time to start with and real-time as applied to mnesia just means that a transaction is replicated as soon as it happens
12:47:27 <sieni> ski: Well the term "polymorphic algebraic type" is used in Thompson's book; I just use it as my Haskell manual
12:47:48 <Philippa> fair enough. Do you need the distributed aspect?
12:47:58 <wagerlabs> Philippa: 100%
12:48:15 <fnord123> wagerlabs: http://www.economist.com/science/tq/displayStory.cfm?story_id=4368214
12:48:18 <wagerlabs> there's this thing called GdH, distributed Haskell but it's very experimental apparently
12:48:28 <Philippa> that would stop me hacking it up straight off the bat
12:48:54 <fnord123> I'm so tempted to get people who make pokerbots, some VC, and some realtime feeds and make mucha moola
12:48:57 <wagerlabs> fnord123: well, i was holding that ace up my sleep but you called my bluff
12:49:32 <fnord123> it was kinda obvious to me with the poker -> tick db :)
12:50:03 <wagerlabs> fnord123: of course after the simulation environment, collusion detection, sensitivity optimization and the game engine DSL i'm gonna apply haskell to program trading :D
12:50:09 <wagerlabs> hehe
12:50:47 <fnord123> been reading peyton-jones' paper on making a contract-algebra?
12:51:05 <wagerlabs> i like putting stepping stones together, building up a ladder. the simple scripting language for testing could be translated into a simple scripting language for trading
12:51:08 <wagerlabs> fnord123: of course
12:51:16 <fnord123> haha we read the same papers
12:51:28 <Philippa> that's generally rather likely in here :-)
12:51:33 <wagerlabs> fnord123: no tickdb, though, forget about that
12:51:37 <Philippa> (I never actually did read the whole of that one, but should do)
12:51:43 <wagerlabs> fnord123: can't fight on speed, that's pointless
12:51:44 <fnord123> yeah and #scheme where they seem to have read every paper ever
12:51:55 <wagerlabs> fnord123: gotta focus on analysis
12:51:59 <ulfdoz> schemers are strange.
12:52:46 <sieni> ulfdoz: why the call/cc would you think that?
12:52:49 <fnord123> i agree about analysis
12:52:56 <Cale> sieni: hahaha
12:52:59 <wagerlabs> fnord123: check out papers on pattern matching in similarity search in time series
12:53:20 <wagerlabs> hey cale! i'm done with my packets :D
12:53:40 <wagerlabs> so i'll be bugging people about threads now :D
12:53:51 <Cale> wagerlabs: :)
12:54:43 <ulfdoz> sieni: The love something which looks like lisp. Nothing against the techniques behind the grammar, but I find it unreadable, when expressions become more complex.
12:56:00 <xerox> With correct indentation it's pretty clear, or at least it was, before I learnt Haskell ;)
12:56:21 <sieni> ulfdoz: with proper indentation the parentheses disappear :-)
12:56:22 * wagerlabs loves Common Lisp
12:56:26 <Philippa> well-indented Haskell code can be truly beautiful though
12:56:28 <wagerlabs> scheme is cool too
12:56:32 <wagerlabs> Philippa: right on!
12:56:51 <wagerlabs> one problem is i have not been able to find a job where CL would truly shine
12:56:56 <Philippa> wagerlabs: keep your perversions to yourself ;-)
12:56:58 <ulfdoz> Although, I did ocaml the last days. Can be quite confusing, too.
12:57:02 <wagerlabs> there's always some other language that outshines it
12:57:06 <Philippa> heh
12:57:36 <wagerlabs> i would do OCaml if it weren't for the syntax of the comments and those let in ... let in ... let in...
12:57:43 <Philippa> I do find static typing important, if nothing else - I know just enough about lisps in general that I'd be able to learn one without too much worry, but I don't really have any desire to
12:57:49 <Philippa> heh
12:58:02 <Philippa> OCaml with Haskell's syntax, typeclasses and monads would be cool
12:58:07 <wagerlabs> haha
12:58:34 <Philippa> (that leaves you things like subtyping and strictness by default, which're still big deals)
12:59:00 <ulfdoz> Philippa: I'm sure this is easy to emulate, as Ocaml implements almost every feature I heard of before.
12:59:17 <beschmi> a static language with an emacs mode comparable to slime would be cool
12:59:21 <xerox> OCaml does not have typeclasses?
12:59:33 <monochrom> No.  I miss it too.
12:59:44 <Philippa> xerox: nope
12:59:54 <wagerlabs> isn't there polymorphic variants?
12:59:56 <ulfdoz> At least objects, which should be quite similar, from my point of view.
13:00:05 <Philippa> ulfdoz: monads're easy. AIUI, faking typeclasses is... painful
13:00:09 <wagerlabs> i thought these were a step in that direction /type clases/
13:00:16 <fnord123> do you guys use mysql w/ haskell?
13:00:29 <Philippa> type classes're something different#
13:00:31 <gzl> fnord123: I've used PostgreSQL with Haskell before.
13:00:38 <monochrom> But its module language and object language are still quite powerful, may be able to mimick what you want.
13:00:40 <Philippa> though they're rather cool from an "I want structural subtyping" kind of POV
13:00:45 <fnord123> oh that's not available for os x -which i use. :(
13:00:51 <gzl> fnord123: huh? sure it is.
13:00:56 <wagerlabs> fnord123: strange
13:01:01 <Philippa> monochrom: potentially. Brainfuck can probably write the actual program, too ;-)
13:01:03 <fnord123> not according to postressql.org
13:01:03 <wagerlabs> fnord123: i'm on osx 10.4.2
13:01:08 <Philippa> (in turn, faking dependant types in haskell still isn't fun)
13:01:36 <fnord123> http://www.postgresql.org/ftp/binary/v8.0.4/
13:01:36 <wagerlabs> fnord123: although i never tried PostgreSQL... but i think Ars Technica ran it or something like that
13:01:44 <wagerlabs> or was it mysql?
13:01:49 <gzl> fnord123: you might not be able to compile the raw source, but go get Fink or DarwinPorts; they have copies you can install.
13:01:57 <gzl> no, MySQL and PostgreSQL both work fine
13:01:57 <sieni> what about a decent macro system ;-)
13:02:06 <ulfdoz> Philippa: Yes, that I meant, unfortunately I'm not really familiar with theoretical background of type systems. What I know comes from Java, the rest I did alone at home. I have not much time, to do dive deeper into it.
13:02:16 <wagerlabs> bigdaddy:~/work/Haskell/NewBinary joelr$ port search PostgreSQL
13:02:16 <wagerlabs> postgresql      databases/postgresql    7.4.8           The most advanced open-source database available anywhere
13:02:21 <wagerlabs> postgresql8     databases/postgresql8   8.0.3           The most advanced open-source database available anywhere
13:02:26 <wagerlabs> fnord123: that's darwinports
13:02:40 <gzl> and this is fink:
13:02:41 <gzl> % fink list postgresql | wc -l
13:02:41 <gzl>       39
13:02:49 <fnord123> i dont have fink or darwinports
13:02:53 <gzl> well, go get them
13:02:58 <wagerlabs> fnord123: hehehe
13:02:59 <gzl> that's why you don't have postgresql :P
13:03:04 <fnord123> oh man eevery time i come into #haskell theres a massive dependency issue
13:03:04 <wagerlabs> www.darwinports.org
13:03:14 <gzl> this has nothing to do with Haskell
13:03:18 <gzl> and it's not a dependency issue
13:03:18 * wagerlabs depends heavily on haskell
13:03:21 <fnord123> haskell needs hmerge or whatever you would call an emerge for haskell stuff
13:03:28 * wagerlabs depends heavily on #haskell too
13:03:29 <gzl> fink and dports are package managers that patch the source code as needed to make it compile on OS X
13:03:43 <fnord123> i know it has nothing to do with haskell - but it has to do with coming into #haskell. :P
13:03:51 <gzl> I guess
13:04:14 <xerox> @where cabal
13:04:15 <lambdabot> http://www.haskell.org/cabal
13:04:17 * fnord123 back hurts. wishes he had his aero from work
13:04:21 <Cale> fnord123: it's called Hackage/cabal, and it's being worked on
13:04:51 <fnord123> yeah i know about cabal. i tried to port darcs to use it, but the darcs creator recomended i give up
13:05:26 <fnord123> or posed the difficulties of porting darcs to it in a way to make me give up :)
13:07:11 <wagerlabs> fnord123: why port darcs to cabal? it builds fine as it is
13:08:52 <Cale> fnord123: I'm not sure if I know what you mean by "port" -- just to change the system for building the darcs source?
13:08:56 <fnord123> i wanted to make a darcs lib which would merge nuggets of work on the fly
13:09:14 <fnord123> for collaborative editing in Yi but extensible to other collaborative program.s
13:09:22 <fnord123> i didnt even get a prototype done :(
13:09:24 <wagerlabs> oh, wow
13:09:24 <fnord123> im useless
13:09:31 * wagerlabs is useless
13:09:37 <greenrd> Does anyone know techniques for re-lazifying computations in the IO monad?
13:09:51 <SamB> greenrd: such as?
13:10:00 <Cale> greenrd: unsafeInterleaveIO?
13:10:22 <greenrd> i.e. normally when you build a computation, it is all executed, in a well-defined order, even if you don't need all the reads from the "world" to be done
13:10:41 <SamB> greenrd: concretely?
13:11:17 <greenrd> SamB: I have a function which reads a directory tree on the filesystem and returns an IO (Tree Directory)
13:11:35 <greenrd> SamB: I want to write it so that the filesystem isn't traversed more than necessary
13:12:34 <greenrd> Or more correctly, it returns a computation which reads a directory tree and returns a (Tree Directory).
13:13:14 <SamB> greenrd: unsafeInterleaveIO looks like it'll do
13:13:31 <Philippa> ulfdoz: don't worry about it - type classes're useful for a different set of problems though, I've not seen object types turn into a logic programming language
13:13:38 <SamB> Prelude System.IO.Unsafe> x <- unsafeInterleaveIO $ readFile "foo"
13:13:39 <SamB> Prelude System.IO.Unsafe> x
13:13:39 <SamB> "*** Exception: foo: openFile: does not exist (No such file or directory)
13:14:27 <wagerlabs> how do you import ST?
13:14:32 <wagerlabs> @index runST
13:14:33 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
13:15:12 <SamB> @type Control.Monad.ST.runST
13:15:17 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
13:15:17 <wagerlabs> instance Binary CommandProcType where
13:15:20 <wagerlabs>     put_ bh a = do put_ bh (fromEnum a)
13:15:20 <wagerlabs>     get bh = toEnum(runST(get bh))
13:15:33 <SamB> @type Control.Monad.ST.Lazy.runST
13:15:35 <lambdabot> forall a. (forall s. Control.Monad.ST.Lazy.ST s a) -> a
13:15:49 <wagerlabs> i think i'm doing something wrong
13:16:06 <SamB> what is your error message?
13:16:10 <xerox> I always forget it...
13:16:13 <xerox> What is ST?
13:16:22 <wagerlabs> CommonType.hs:19:26:
13:16:22 <wagerlabs>     Couldn't match `ST s Int' against `IO a'
13:16:22 <wagerlabs>       Expected type: ST s Int
13:16:22 <wagerlabs>       Inferred type: IO a
13:16:22 <wagerlabs>     In the application `get bh'
13:16:24 <SamB> xerox: its like IO only more annoying
13:16:31 <wagerlabs> get bh = toEnum(runST(get bh))
13:17:03 <SamB> unsafeIOToST ?
13:17:07 <wagerlabs> basically, i'm trying to read an Int with get bh, convert it to enum and return... well, return is missing
13:17:14 <xerox> SamB: what does the S and the T stand for?
13:17:22 <SamB> @type Control.Monad.ST.unsafeIOToST
13:17:23 <fnord123> oo. csi on tele. suits you
13:17:23 <lambdabot> forall a s. IO a -> GHC.ST.ST s a
13:17:26 <SamB> xerox: state
13:18:08 <wagerlabs> i have no idea what runST is conceptually but now that you can wrap IO code in it to return a pure value
13:19:43 <greenrd> Do all the scary warnings about unsafePerformIO also apply to unsafeInterleaveIO?
13:20:17 <genneth> i'd imagine so; they feel like they are both doing the undoable
13:20:34 <sylvan> wagerlabs, runST takes an ST-computations and returns a pure value...
13:20:36 <genneth> same goes for Control.Monad.ST.unsafeIOToST
13:20:40 <sylvan> You can only do ST computations in it, not IO computations
13:21:05 <wagerlabs> sylvan: thanks
13:21:23 <wagerlabs> sylvan: but they do this
13:21:24 <wagerlabs> doubleToInts d = runST (
13:21:24 <wagerlabs>     do arr <- newDoubleArray (1,2)
13:21:24 <wagerlabs>        writeDoubleArray arr 1 d
13:21:24 <wagerlabs>        i1 <- readIntArray arr 1
13:21:25 <SamB> I don't think you can write unsafeCoerce with unsafeInterleaveIO...
13:21:27 <wagerlabs>        i2 <- readIntArray arr 2
13:21:29 <wagerlabs>        return (i1,i2))
13:21:41 <SamB> but plenty of the other scary warnings are applicable, I'm sure
13:21:45 <sylvan> yes, all of those newDoubleArray are STArrays
13:21:51 <sylvan> all of those are ST computations
13:22:00 <wagerlabs> sylvan: ah, ok then
13:22:39 <SamB> note that some of the warnings are applicable to readFile and possibly even getContents
13:22:58 <sylvan> Stick to stuff which has "ST ... " as the return type and do what you need to do with your state computations, and then use runST to return the final result
13:23:13 <wagerlabs> sylvan: cool
13:23:39 <Cale> wagerlabs: for another cool example, see the STM paper
13:24:04 <wagerlabs> Cale: my favorite! can't wait to apply it
13:24:14 <Cale> :)
13:24:17 * Cale takes off
13:24:18 <wagerlabs> Cale: very soon i'll get the chance as i'll be doing threads
13:24:22 <Cale> :)
13:24:29 <Cale> yeah, it's a cool library
13:24:32 <xerox> Cale: what do you think about (partial) continuations?
13:24:43 <wagerlabs> any python guys here?
13:24:53 <Cale> xerox: they're kind of neat, but I'm not sure what I'd use them for
13:25:32 <Cale> anyway, later all
13:25:39 <wagerlabs> a friend of mine got a small contract ;)
13:26:07 <xerox> If only I could see continuations' continuation...
13:26:18 <genneth> wasn't shapr posting about something like delimited continuations?
13:26:30 <genneth> are those related?
13:27:14 <xerox> genneth: yep, did you see ZFS?
13:27:22 <xerox> http://lambda-the-ultimate.org/node/view/1036
13:27:44 * SamB wonders why gtk2hs requires so much RAM to compile
13:27:46 <xerox> Check the slides, they're cool.
13:27:53 <genneth> xerox: yeah
13:28:00 <xerox> SamB: in fact it needs much less ram that it used to ;-)
13:28:53 <SamB> well I still find it disconcerting that it has to specify +RTS -H50m -M80m -RTS
13:28:59 <SamB> to the compiler
13:29:22 <xerox> That was part of the Duncan solution.
13:29:52 <genneth> xerox: i just don't know continuations well enough to read that thoroughly
13:31:32 <xerox> genneth: try nonetheless!
13:36:21 <humasect> allo
13:36:35 <xerox> Hi.
13:37:20 <humasect> how are things?
13:37:43 <xerox> Continuous
13:38:00 <humasect> oh compassionate
13:38:42 <xerox> Did you see the Delimited Continuations Monadic Zipper File System ?  http://lambda-the-ultimate.org/node/view/1036
13:39:57 <humasect> =o
13:40:47 <xerox> I think so too :)
13:41:22 <humasect> it's fresh at oct 7 too...
13:42:02 <humasect> i'm excited to see where that goes
13:42:17 <xerox> Check the slides!
13:42:33 <xerox> (And grab the code, you'll need it to demo what the slides say :D)
13:43:06 <humasect> ohh getting
13:44:45 <humasect> oh no System.Posix on w32. no biggie
13:47:15 <xerox> Too bad.
13:47:38 <xerox> Try it remotely, it runs a network socket, hence you can telnet it.
13:47:56 <humasect> i rememeber lots of people wanted to design and work on a full 3d production environment a while back, but no one had the time
13:48:28 <humasect> yeah. no unix shells at my disposal at the moment. i could try cygwin-haskell if i could spend the effort
13:49:33 <SamB> even windows comes with a telnet client...
13:49:38 <genneth> does any one know if they're continuing with that with FUSE or something?
13:49:51 <SamB> or do you mean you don't have any ssh accounts?
13:50:00 <humasect> no System.Posix on mingw version of GHC.
14:03:05 <thaldyron> what's the best way to read/write ADTs to files in haskell?
14:03:18 <basti_> thaldyron: whats good for you?
14:04:05 <SamB> thaldyron: well, if you don't care about the format, Read/Show work okay when your types aren't too big and complicated...
14:06:20 <thaldyron> no the format isn't an issue
14:06:30 <basti_> try Read and Show first.
14:06:39 <thaldyron> ok, thx
14:06:41 <basti_> if it doesnt rule you can always try something else
14:06:43 <SamB> assuming all the types you use are either already instances or are in the same source tree...
14:06:56 <thaldyron> yes they are
14:07:44 <SamB> @plugs show $ Just Nothing
14:07:46 <lambdabot>  add a type signature that fixes these type variable(s)
14:08:27 <xerox> @plugs show (Just Nothing) :: Maybe (Maybe Int)
14:08:28 <lambdabot> Couldn't match `Maybe (Maybe Int)' against `String'
14:08:29 <SamB> @plugs show $ Just True
14:08:31 <lambdabot> "Just True"
14:08:43 <xerox> @plugs show (Just Nothing :: Maybe (Maybe Int))
14:08:45 <lambdabot> "Just Nothing"
14:09:17 <xerox> @plugs show (Just Right Nothing :: Maybe (Either Int (Maybe Int)))
14:09:18 <lambdabot>   The function `Just' is applied to two arguments,
14:09:18 <lambdabot>   but its type `a -> Maybe a' has only one
14:09:18 <lambdabot>   In the expression: Just Right Nothing :: Maybe (Either Int (Maybe
14:09:18 <lambdabot> Int))
14:09:25 <xerox> err :)
14:09:25 <SamB> @plugs read $ show $ Just True
14:09:27 <lambdabot> Ambiguous type variable `a' in the constraints
14:09:33 <xerox> @plugs show (Just (Right Nothing) :: Maybe (Either Int (Maybe Int)))
14:09:35 <lambdabot> "Just (Right Nothing)"
14:09:59 <integral> @plugs (read :: String -> Maybe Boolean) $ show $ Just True
14:10:00 <lambdabot>  Not in scope: type constructor or class `Boolean'
14:10:02 <SamB> @plugs read $ show $ Just True :: Maybe Bool
14:10:04 <lambdabot> Just True
14:10:52 <SamB> usually your code makes it pretty clear what type to use anyways...
14:11:24 <ski> xerox : ST stands for State Transformer
14:12:07 <ski> sieni : yes .. the book may use "polymorphic algebraic datatype", but it is still, strictly speaking, incorrect
14:12:28 <ski> values and functions can be polymorphic
14:12:46 <ski> @type map
14:12:47 <xerox> ski: how is it related to IO?  (rtfm is an acceptable answer if you want)
14:12:47 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
14:13:41 <ski> sieni : the 'forall' means that it's 'polymorphic' .. so such 'forall' in e.g.  'data Maybe a = Nothing | Just a'   just a type-parameter 'a'
14:14:18 <ski> xerox : in ghc  'IO a' is isomorphic to 'ST RealWorld a'
14:14:27 <xerox> ski: ah-ha.
14:14:39 <ski> iirc, something like    newtype IO a = IO (ST RealWorld a)
14:15:02 <SamB> is there a fine manual?
14:15:08 <SamB> I would say RTFSC
14:15:34 <SamB> not that you will necessarily be able to make much of it
14:15:46 <SamB> and not that lots of how it works isn't hardwired into GHC
14:16:39 <ski> xerox : so with this, 'IORef a' is isomorphic to 'STRef RealWorld a', and newIORef, etc can be implemented in terms of newSTRef, etc ..
14:16:52 <ski> xerox : only thing that doesn't carry over is runST
14:17:35 <SamB> thats because of main ;-)
14:18:00 <xerox> ski: I wonder what RealWorld is
14:18:00 <ski> (this is because IO fixes the second typearg of ST to be RealWorld, and runST demands that that typearg is not fixed, nor constrained in any way .. it needs the action to run to be polymorphic in that argument)
14:18:36 <ski> in ghc, iirc   data RealWorld = RW RealWorld#   -- unboxed type
14:18:56 <ski> so RealWorld# is the primitive
14:19:17 <SamB> uk
14:19:31 <SamB> now I get "ghc-6.4: Error: module 'Generics' is exposed by package lang-1.0 and package ghc-api-0.2"
14:19:44 <ski> in code generation, ghc does not generate space or code for handling this, of course
14:21:23 <ValarQ> haskell supports the real world?!?
14:22:04 <ski> sure :)
14:22:20 <xerox> Goodnight.
14:22:27 <ski> night, xerox
14:22:35 <ValarQ> ski: thats mighty impressive!
14:24:23 <SamB> what should I do about this?
14:26:54 <jyp> pwd
14:26:58 <jyp> damn
14:27:45 <ski> /net/freenode/irc/haskell
14:28:08 <jyp> lol
14:30:49 <SamB> ls -la
14:33:25 <jyp> SamB, your trying to build ghc-api
14:33:40 <jyp> ?
14:34:16 <SamB> jyp: this is after installing it
14:35:17 <jyp> Well I'd be interested in how you built it, because it fails here...
14:35:56 <jyp> I suppose you tried -hide-package lang ?
14:36:32 <SamB> jyp: I don't want to have to type that every time I start GHCi :-(
14:36:57 <jyp> .ghci may be what you need then
14:37:26 <SamB> can I put something like that in my .ghci?
14:37:54 <jyp> I think any ghc option is supported
14:39:03 <SamB> no, it seems to exit before it gets to my .ghci
14:39:56 <jyp> mmm... correct spelling is -ignore-package lang
14:40:01 <jyp> I think
14:41:04 <jyp> I any case, did you do anything special to compile ghc-api ? -- s
14:41:14 <jyp> so I can try it here ?
15:09:05 <Lemmih> SamB: ghc-api wont be used in hIDE for much longer.
15:13:40 <davve> lemmih, because of the build problems?
15:22:16 <Lemmih> davve: That and because I want to play with the bytecode generator.
15:24:52 <SamB> I spelled it right in .ghci anyways...
15:26:26 <shapr> hiya david
15:26:35 <droundy> hello
15:26:35 <shapr> How's code?
15:26:58 <droundy> all right, except I can't figure out how to handle equality with the GADT trick.  :(
15:27:04 <rep> i'm bored.
15:27:13 <basti_> rep: write a lisp interpreter.
15:27:18 <shapr> Do you see any similarity between darcs' patch theory and the delimited continuations Zipper? http://lambda-the-ultimate.org/node/view/1036
15:27:24 <rep> i've been thinking about it, actually, basti_
15:27:51 <Heffalump> droundy: what's going wrong?
15:27:54 <basti_> :D
15:28:08 <Heffalump> is this the "assert equality once verified by other means" thing, or something else?
15:28:26 <rep> i think i'll try compiling a linux kernel tomorrow
15:28:27 <droundy> The trouble is that I want to implement an equality check that dynamically restricts the types as a GADT would.
15:28:38 <droundy> Yeah, that's the issue.
15:28:54 <Heffalump> didn't you and Igloo write some code that did that ok?
15:28:58 <Heffalump> Igloo, probably.
15:29:14 <Heffalump> for the "this patch is known to be an inverse of this other patch" thing in the conflictor handling
15:29:14 <skew> droundy: I have absolutely no idea what the context is, but you can usually get by either by only aiming for equality up to isomorphism, or by using unsafeCoerce#
15:29:35 <SamB> droundy: Data.Dynamic doesn't help?
15:29:39 <Heffalump> unsafeCoerce# was the (easiest) solution there.
15:29:46 <Heffalump> Data.Dynamic wouldn't help
15:30:01 <Heffalump> at least I doubt it. I don't know how it interacts with type variables.
15:30:08 <skew> I had to write my own Dynamic with an unsafe constructor from an arbitrary value and a type rep once
15:30:15 <droundy> I have defined a:  data MyBool a b c d where { MyTrue :: MyBool a a b b; MyFalse :: MyBool a b c d; }
15:30:25 <SamB> Heffalump: probably refuses to have much to do with them...
15:30:28 <Igloo> droundy: Is this the same as what you were asking before?
15:30:31 <Heffalump> I don't quite understand what MyBool is for.
15:30:42 <Igloo> If not, I don't see why an isId :: P a b -> Maybe a a isn't what you want?
15:30:49 <Igloo> s/If not/If so/
15:30:58 <droundy> Igloo:  It's related, the idea worked well until I tried to implement the actual code.
15:31:00 <Heffalump> Maybe (Patch a a) ?
15:31:08 <SamB> asked oleg yet?
15:31:09 <Igloo> Yes, sorry
15:31:50 <droundy> The trouble is that that won't restrict the type of the original objects.  (Returning Maybe (Patch a a ))
15:32:09 <Heffalump> why do you need to restrict the type of the original ones?
15:32:16 <xerox> Kind error: Expecting kind `k_a1Dl -> *', but `b' has kind `k_a1Dl'
15:32:48 <droundy> Because I'm doing interesting commutations on the original patches.  I'm writing tests for the "permutivity" property.
15:33:09 <mcnster> hi
15:33:33 <droundy> if I have two patch sequences AB and CD and A == C then I want the type system to tell me that B and D are parallel patches.
15:33:34 <astrolabe_> hello
15:33:42 <skew> I think opening a GADT is the only way to get set some types to unify
15:34:22 <droundy> Heffalump: MyBool is to stand as a witness that if two patches are equal, then their types are the same.
15:34:37 <mcnster> if i have data Foo = FooA Int | FooB Int, how can i test for two values of Foo having the same constructor (while ignoring the Int)?
15:34:46 <mcnster> hi astrolab_ :)
15:34:52 <Heffalump> is permutivity what you used to call transitivity?
15:35:11 <Heffalump> (I think compositionality of commute is a better name, FWIW)
15:35:12 <droundy> yeah, it's the fancy new name:  since it's a nonexistent word, it can't be wrong!  :)
15:35:27 <skew> mcnster: in many ways. A case or pattern match is probably the easiest
15:35:57 <Igloo> droundy: No, the intention is you use the returned patch instead
15:36:06 <mcnster> skew, hmm.  what would the pattern look like?
15:36:13 <skew> you can only do a case on one value, but it can be a pair, and you can use _ in a pattern for stuff you don't care about
15:36:14 <Igloo> Oh, I see
15:36:36 <skew> like, isJust maybe = case maybe of Just _ -> True; Nothing -> False
15:36:42 * Heffalump is still confused
15:36:56 <Heffalump> if A==C I think you just need to do some kind of coercion, don't you?
15:37:32 <mcnster> so i have a=FooA 1 and b=FooB 2.  how do i write "if a=b ..." but only considering the constructor?
15:37:42 <mcnster> (sorry should be ==)
15:37:53 <skew> you can't really do that
15:37:59 <mcnster> ahso
15:38:10 <skew> at least, if you are using the standard == - that will look at the numbers too
15:38:17 <skew> you will need to make a different function to do the comparison
15:38:20 <droundy> Igloo:  but the returned patch isn't the one that needs to be coerced.
15:38:25 <Igloo> Yes, but he wants to tell the typesystem A and C have the same end context and for it to then infer that B and D must have the same start context
15:38:37 <Igloo> But to do that you have to coerce one of B and D too
15:38:57 <Heffalump> I think that's inevitable, but I'm not certain.
15:39:00 <Heffalump> I'll think about it tomorrow.
15:39:53 <droundy> I guess perhaps I need an operation that works on multiple patches.  I just want to make sure that the coersion is done in some sort of "primitive" and well-tested context.
15:40:00 <mcnster> hmm
15:40:34 <SamB> skew: you can use Data.Generic or something of that ilk...
15:41:08 <mcnster> so would i need to do case a of Foo1 _ -> case b of Foo1 _ -> True?
15:41:37 <mcnster> that seems awkward, and i know nothing about haskell is awkward ;-)
15:41:42 <skew> something like that would work
15:42:43 <astrolabe_> It does seem awkward.  Maybe it is a function you shouldn't have to write ;)
15:43:23 <skew> actually, the simples is probably add deriving Data to the type definition, and write toConstr a == toConstr b
15:44:03 <mcnster> oh that's pretty cool
15:44:34 <davve> lemmih, the byte code generator?
15:44:59 * mcnster looks at Data.Generics
15:48:06 <mcnster> thanks skew :)
15:48:11 <Lemmih> davve: GHCi compiles to bytecode.
15:48:48 <davve> lemmih, yeah.. how does that stop hIDE from using ghc-api?
15:49:38 <Lemmih> I had to gut the bytecode generator in ghc-api.
15:50:13 <SamB> Lemmih: so when will this hIDE be?
15:50:39 <Lemmih> Fixing it would require yet another hack which ghc-api is already full of.
15:51:26 <davve> oh.. so you're the one working on ghc-api? :)
15:52:55 <Lemmih> SamB: I just have to coordinate which snapshot of 6.5 we're gonna use with dons and dcoutts. Shouldn't take too long.
15:54:25 <Heffalump> droundy: thinking it through, I think you really do just need some kind of coerce_middle function that takes a pair and returns one.
15:54:45 * Lemmih counts three Davids in #haskell today.
15:55:01 <shapr> I guess that's why Microsoft (Goliath) isn't here.
15:55:11 * Korollary shoots shapr
15:55:14 <droundy> Heffalump: I'm not sure what you mean by coerce_middle... what would its type be?
15:56:40 <Heffalump> either
15:56:55 <Heffalump> coerce_middle :: (Patch a b, Patch b c) -> (Patch a d, Patch d c)
15:57:10 <Heffalump> or something with a forall in it, or perhaps something that has to be passed a Patch a d as well.
15:57:15 <shapr> skew: hiya! ltns!
15:57:45 <Heffalump> oh, hmm
15:57:48 * Heffalump has a different idea.
15:57:52 <Korollary> When passed in Nothing for stdout, the child process inherits the parent's stdout. How do I hand over /dev/null instead ?
15:58:04 <Heffalump> but bedtime now, I'll play with it tomorrow.
15:58:32 <droundy> Heffalump: So for my AB, CD, A==C example, we'd coerce the CD... Okay, have sweet dreams!
15:59:01 <shapr> skew: What's it like working with Darius?
15:59:11 <shapr> skew: Hey, how's that type theory article for TMR? :-)
16:00:20 <ulph> hej shapr
16:01:06 <shapr> hej ulph
16:01:32 <shapr> Haven't been able to afford the Endomorph yet :-/ but cyclecomponents got it onto their website.
16:01:39 <ulph> Nice
16:01:48 <ulph> It's the 24x3.7?
16:01:52 <shapr> yup
16:01:57 <shapr> er, no 26x3.7
16:02:00 <ulph> Oh.
16:02:16 <ulph> That's huge:)
16:02:35 <shapr> Yeah, should be good for chasing snow scooters.
16:02:43 <shapr> Anyway, time for bed, g'nite!
16:02:47 <sethk> I bot the Pierce category theory book in the mail today.  I forget who recommended it.
16:02:53 <ulph> nite
16:05:09 <Philippa> I've actually heard it disrecommended - I got it cheap with TaPL a year or so back though
16:05:11 <Lor> Isn't it rather a booklet?
16:05:17 <JohnMeacham> howdy.
16:05:19 <Philippa> yeah
16:05:23 <Philippa> 'lo John
16:06:18 <skew> shapr: I haven't really been coding with Darius any, but we have talked about design a bit
16:07:00 <skew> shapr: I've started giving little talks about haskell and category theory and stuff
16:07:16 <skew> maybe I'll write something up once I can keep more than half the audience awake :(
16:07:19 <JohnMeacham> I wrote a little script to continually look for changes in source files and rerun ghc, keeping a file up to date with the current error messages. I am not sure why I havn't done it before, keeping the errorlog in one vim window and editing with the other is pretty darn close to continual compilation with feedback as I type. (well every time I :w that is)
16:08:30 <skew> I think my mistake has been expecting people to understand anything - I'm going to do a whirlwind tour of coolness next week, like autrijus is planning for his talk
16:08:33 <sethk> JohnMeacham, if you want to get really tricky you might be able to use the swp file and not even wait for :w
16:08:40 <integral> JohnMeacham: doesn't that make your machine laggy?
16:08:59 <Korollary> JohnMeacham: ocaml has a similar util for emacs (Tuareg mode?)
16:09:04 <Igloo> Presumably you could rebind :w to fork off something to do the rebuild
16:09:31 <skew> speaking of which, does anybody have good short examples of STM being useful?
16:09:54 <skew> you can do dining philosophers, but getting lock-freedom for free isn't too impressive when you don't have fairness
16:09:56 <Lor> Is the asperti&longo book any good? It's free and seems to be pretty comprehensive, but the typography isn't very attractive.
16:10:23 <sethk> Lor, I found it not a good first book, which is why I sent for this other one I got today
16:10:29 <sethk> Lor, but it looks fine on my machine
16:10:34 <JohnMeacham> not really, I mean, it is noticable, but much better than stopping editing and loosing my train of thought occasionally to watch ghc chug along.
16:10:45 <sethk> Lor, what don't you like about the way it looks?
16:10:58 <JohnMeacham> editing is not really cpu intensive to begin with.
16:11:31 <JohnMeacham> though.. I wish the x86-64 version of ghc would catch up to the i386 one in terms of speed. does anyone know what the issues are?
16:12:20 <sethk> JohnMeacham, is it dramatically slower?  A naive individual (such as myself) would have expected the same code running a hair faster
16:12:29 <JohnMeacham> sethk: yeah, but then I'd probably get more spurious messages... I usually :w every time I complete a thought (?) a section of code I expect to compile (but not neccessarily work yet)
16:12:42 <sethk> JohnMeacham, true.
16:12:46 <Lor> sethk, the lines are too long (relative to the character width), and the line spacing is too sparse.
16:13:02 <sethk> JohnMeacham, did you see my question about the -v flag and your compiler?
16:13:13 <JohnMeacham> sethk: pretty dramatically. at least, ghc itself is much slower to compile things, I'd say a factor of 2
16:13:20 <JohnMeacham> sethk: no.. what was it?
16:13:22 <Lor> Also, I don't much like the use of bold in formulas.
16:13:58 <sethk> JohnMeacham, Why not make -v the default for your compiler, and have a flag to turn it off, instead of the other way around.  As you recommend that it be used normally just to show that the thing is cranking
16:14:31 <skew> shapr: our plan, or at least my plan and darius' current project is to generate all the annoying code by hand, rather than have a cycle of a few weeks on trivial changes
16:14:57 <JohnMeacham> sethk: no particular reason. I just was following the convention that programs should produce no output on success (which jhc already breaks anyway)
16:15:20 <sethk> JohnMeacham, it's easy to forget -v, and then start to wonder   :)
16:15:29 <sethk> JohnMeacham, or add a signal handler to turn it on, on the fly
16:15:59 <Philippa> JohnMeacham: I'd expect /some/ slowdown running code in a 64bit address space if that's happening?
16:16:05 <Philippa> you'd blow the cache out more often
16:16:32 <JohnMeacham> sethk: yeah. I think I just type it by default now without thinking... so, it is not that important. but if someone is anoyed enough to send a patch, I will most likely apply it.
16:17:19 <JohnMeacham> Philippa: but I have not noticed it with other programs.. I think ghc must be tickling something in the arch just the wrong way. we have a lot more registers to play with. perhaps it is not making good use of them?
16:18:07 <sethk> JohnMeacham, I might do that patch; it's simple imperative code that I can handle.  :)
16:18:30 <sethk> JohnMeacham, but not using registers well shouldn't make it run slower w.r.t. a 32 bit machine
16:18:35 <JohnMeacham> 6.4.1 does seem somewhat faster than 6.4 though.
16:18:45 <sethk> JohnMeacham, is it possibly runnin in a 32 bit emulation mode of some sort?
16:19:18 <JohnMeacham> sethk: ghc running on the same machine in 32 bit mode is faster. that is how I was comparing them. AMDs 32 bit emulation mode is ful
16:19:27 <JohnMeacham> speed. not really an emulation at all.
16:19:58 <sethk> JohnMeacham, it would be interesting to know why.
16:20:56 <JohnMeacham> Yeah. I have the AMD optimization guides around here somewhere. I will take a look for anything obvious.
16:21:54 <droundy> JohnMeacham: Could it just be that ghc is spending its time figuring out what to do with all those extra registers?
16:21:56 <sethk> It would be kind of hard to do that on purpose.
16:23:45 <JohnMeacham> droundy: it is using gcc as its back end..
16:24:19 <JohnMeacham> droundy: but ghc is still arch dependent anyway, it hardcodes meanings for some registers and mangles the assembly output of gcc in evil ways.
16:24:19 <sethk> I take it gcc in 64 bit is known to not be slow compared to gcc in 32 bit mode?
16:25:11 <JohnMeacham> sethk: a bit slower. but nothing serious. I think it is just because that back end has not had as much work as the i386 one.
16:25:29 <sethk> JohnMeacham, so this is something ghc specific
16:25:50 <sethk> should be possible to narrow it down to a particular pass or part of the process
16:26:19 <JohnMeacham> sethk: yeah. something this dramatic must be something specific. which means it might be easy to fix... like we are hardcoding the wrong register or putting critical structures across cache lines...
16:26:53 <JohnMeacham> sethk: I think it is something about the code ghc generates itself.
16:27:04 * Philippa thinks a mo
16:27:10 <Philippa> I think there are some IA32-specific hacks
16:27:28 <Philippa> jumps where other architectures ret&call, things like that
16:28:13 <sethk> hmm.  So, if gcc is a bit slower in 64 bit mode, and most things we run are built by gcc, tell me why I want a 64 bit machine again?
16:28:18 <JohnMeacham> Phillippa: yeah, that is what the evil mangler does I think. perhaps it is not working on x86-64? it just regex matches on the generated assembly of gcc so is quite brittle and depends on specific instructions gcc generates.
16:29:16 <JohnMeacham> sethk: I meant gcc itself is a bit slower to run. I have not noticed things going slower (and some things definitly go faster.) except in the case of ghc.
16:29:33 <sethk> JohnMeacham, oh, then in general code produced by gcc is not slower
16:29:40 <sethk> is it faster, though?
16:30:42 <skew> sethk: more that 4GB of ram is nice
16:31:11 <sethk> skew, true, but if I don't have the cash right now for > 4g of fast ram, I suppose I shouldn't be buying hardware.
16:31:57 <Korollary> JohnMeacham: It looks like you'll have to hit the mailing list again for that
16:32:00 <JohnMeacham> sethk: stuff that uses a lot of FP can be faster. the x87 is a horrible design when it comes to compilers. you can mmap files bigger than 4gb. (in fact, an OS could switch to pure mmap based IO)
16:32:16 <skew> I'm sort of wrapped up in the serving stuff we do at work, but actually even just having the addresss space can be nice (the mmap stuff)
16:32:30 <sethk> JohnMeacham, the x86 isn't so great either, forgetting x87  :)
16:32:40 <sethk> skew, on a big server, yes, I can see that.
16:32:41 <JohnMeacham> sethk: indeed.
16:33:05 <skew> sethk: I don't know about a personal machine, either
16:33:11 <JohnMeacham>  well, more than 4gb of address space is the good thing. that is independent of the amount of ram you have.
16:35:05 <skew> hey, with the size of hard drives these days, the 64-bit address space almost makes never reclaiming memory a practical strategy
16:36:13 <sethk> I'd like an opinion.  I have a database server written in c++ that has some design features that fit nicely with Haskell.  Do you (any/all of you) think it would be worth the effort to implement the entire thing in Haskell?
16:36:44 <skew> sethk: what are your goals?
16:37:16 <sethk> skew, partly reliability
16:37:16 <metaperl> Any authoritative info on the cost of (++) ... there is an extended discussion about it here: http://sequence.complete.org/node/115
16:37:38 <sethk> skew, partly to see what I could do with the performance
16:37:59 <jyp> Moving things to haskell is the true way, as we all know
16:38:00 <sethk> skew, partly to implement something in haskell that is _very_ io bound
16:38:24 <sethk> jyp, sure, but it is a very big effort
16:38:49 <sethk> skew, also to get more users for it
16:39:46 <skew> Hmm, what kind of database is it?
16:40:04 <sethk> skew, ANSI '92 SQL
16:40:06 <skew> I'm kind of in the market for a really fast, in-memory database thing for Haskell
16:40:10 <jyp> I know! Letwe need to create a monastic order dedicated to rewriting everything in haskell
16:40:19 <jyp> ...
16:40:29 <sethk> skew, it's been used as an in memory database in a lucent switch
16:40:51 * jyp reflects on the late hour
16:41:27 <sethk> skew, and one of it's claims to fame is that you can access the data at the b+tree level when sql is too slow
16:42:17 <skew> We're using something at work which is basically a giant hash table, and I've been reimplementing things in Haskell for my amusement
16:42:36 <sethk> skew, well, hash tables have a few things missing   ...   :)
16:42:46 <skew> very fast lookup, and compact layout are the primary concern
16:42:46 <sethk> skew, but they do tend to be fast
16:43:16 <sethk> skew, layout is not a problem, I do contiguous layout even with variable length fields
16:43:22 <skew> the HAppS db stuff looks good for a prototype
16:43:34 <sethk> skew, at the cost of carrying around length bytes or words, of course, but that's only if you use large variable length stuff
16:43:35 <skew> interesting, what's the licensing like?
16:43:46 <JohnMeacham> @where FastString
16:43:53 <lambdabot> I know nothing about faststring.
16:43:55 <sethk> skew, I've usually used the mozilla license
16:44:05 <sethk> skew, I don't like GPL
16:44:15 <skew> what's that, GPL plus some recontribution term?
16:45:01 <sethk> skew, no, basically free without any restrictions about releasing the source for modifications
16:45:31 <sethk> skew, free without any richard stallman politics.  :)
16:45:51 <skew> why mozilla in particular?
16:46:07 <sethk> skew, only because it is a well known license without annoying restrictions.
16:46:18 <sethk> skew, there is a license that the ACE toolkit uses that I've also used
16:46:42 <sethk> skew, I'll release it under pretty much any license that preserves my copyright
16:46:49 <SamB> and here I thought BSD3 was the well-known license without annoying restrictions...
16:47:14 <SamB> that or MIT
16:47:38 <skew> If you are talking about MPL, section 3.2 seems to require including source code when you distribute modified versions
16:47:46 <JohnMeacham> can mozilla and GPL code be combined? I use BSD3 or (L)GPL pretty exclusivly. anything else would probably just anoy people who want to use my code. they are both well understood licenses
16:48:02 <sethk> skew, I haven't read it in years.  The license I'm using doesn't have that clause.
16:48:15 <sethk> skew, if mozilla isn't the right one and BSD is better, I'll use BSD
16:48:39 <sethk> skew, as I said, as long as my copyright isn't compromised I'm happy
16:48:45 <JohnMeacham> MPL is an odd license with strange quasi-legal stuff in it. at least the NPL version was. that is why they switched to the GPL mostlyp
16:48:48 <skew> JohnMeacham: http://www.fsf.org/licensing/licenses/index_html says no
16:49:48 <sethk> sethk, looking at my distribution, the license is the one from ACE, which is straightforward, but as I said if anyone wanted a BSD license or any other reasonable license I would have no problem with it.
16:50:58 <sethk> at one point I had users who wanted the mozilla license but that was some time ago and obviously I don't spend a lot of time reading licenses.  :)
16:51:03 <sethk> even if I probably should.
16:51:05 <JohnMeacham> oh. that is no good. there is a huge base of source code under the GPL and it would suck to not be able to combine it with your or other stuff... this is why DJB is a codetease. he writes all this great code and waves it in front of you but doesn't let you combine it with anyone elses stuff. (effectivly)
16:51:17 <sethk> BRB, the dog is looking suspicious.
16:51:35 <JohnMeacham> "Don't be a codetease. use the BSD3"
16:52:01 <sethk> JohnMeacham, ok, if that is the consensus of folks who aren't GPL partisans, then I'll do that.
16:53:03 <JohnMeacham> I should get some t-shirts made up that say that.
16:53:25 <SamB> sethk: the consensus of folks sick of trying to combine licenses anyways
16:55:04 <JohnMeacham> Yeah, it doesn't have a lot to do with politics or ideology.. there are just strong practical benefits to being able to combine your code with GPLed code even if your code is not under the GPL itself.
16:55:06 <SamB> though some people spell it "MIT", "MIT/X11", or "X11"
16:55:41 <JohnMeacham> except now that X11 dude even made that ambiguous since he (tried, and failed spectacualarly) to change the X11 license.
16:56:05 <SamB> JohnMeacham: that was just XFree86 anyways
16:56:10 <SamB> not X11
16:56:25 <SamB> X11 probably refers to the reference implementation
16:56:44 <SamB> (or whatever the reference code constitutes)
16:57:40 <JohnMeacham> Hmm.. I have a feeling this "Juicy Juice" is just fructose with a bit of food coloring in it.. /noise
16:57:46 <SamB> It is kind of funny that an attempt to change the license of XFree86 effectively changed the name and management, isn't it?
16:58:04 <skew> I'm having a hard time understanding the HAppS ACID code
16:58:10 <SamB> JohnMeacham: they say its 100% juice, though!
16:58:34 <skew> 100% natural fructose!
16:59:10 <skew> much better than 100% artifical fructose because of the elan vitale, of course
16:59:38 * SamB wonders why installing libgtkcodeview-dev (or whatever its called) is resulting in his kernel image being updated
16:59:50 <JohnMeacham> SamB: yeah. and opened up the development model, which is great, and has been something a lot of people wanted to do for a while, the license thing just gave the extra push needed. it is such a spectacularly bad idea, I have to think it was engineered... like he was sick of running the project, but his pride wouldn't let him just quit, so he engineered a situation where everyone would leave and he would be known as the mart
16:59:51 <JohnMeacham> yr to his coding ideology.
17:00:26 <SamB> JohnMeacham: martyr? hardly!
17:00:36 <SamB> fool? idiot? sure!
17:01:05 <JohnMeacham> SamB: in his head.
17:01:33 <SamB> JohnMeacham: oh, yeah, fine then.
17:01:37 <SamB> "crazy".
17:01:47 <SamB> thats what I'll call him.
17:03:45 <JohnMeacham> hmm.. shall I root for the aliens or the predators.
17:06:05 <sethk> what did he change?
17:06:52 <JohnMeacham> sethk: he basically added the BSD advertising clause to the Xfree86 license. making it incompatable with the GPL.
17:07:15 <sethk> JohnMeacham, I don't know about the BSD advertising clause.  I'll look it up.
17:07:19 <wilx> What is "BSD advertising clause"?
17:08:10 <int-e> @google "BSD advertising clause"
17:08:11 <lambdabot> http://www.gnu.org/philosophy/bsd.html
17:08:12 <JohnMeacham> it basically said any advertisements for software based on the code has to include an attribution to the author. which seems benign until you realize that OSS projects have hundreds or more authors, any ad ends up being half-attributions.
17:08:22 <Korollary> lol
17:09:53 <JohnMeacham> the originators of the license, the university of california system, has since retroactivily rescinded the clause. which is great, because now net and free bsd code can be used with gpled code. but I think openbsd is still sticking to the bsd4 for some reason, but I am not an expert on such things.
17:10:04 <JohnMeacham> the NetBSD source code is a good read.
17:10:53 <wilx> Heh, this is actually rather funny.
17:16:49 <JohnMeacham> is there a way to get ghc compiled programs to spit out the info from +RTS -P even if the program dies from an error or is Ctrl-C ed?
17:17:27 <JohnMeacham> it would be very handy when figuring out why programs are misbehaving to see where they are spending their time when they misbehave.
17:18:37 <JohnMeacham> ooh. maybe it does do so now... excellent.
17:21:08 <int-e> "Our Credit clause is Absolutely Not an advertising clause!" -- http://xfree86.org/legal/licenses.html
17:39:18 <JohnMeacham> A duck by any other name...
17:57:48 * SamB gets rid of ghc-api
18:22:05 <luqui> @pl \x y -> (1,x,3,y,5)
18:22:06 <lambdabot> flip flip 5 . flip ((,,,,) 1) 3
18:40:20 <dons> moin
18:40:35 <humasect> hello
18:41:00 <humasect> dons, were you interested in haskell for 3d media production long ago?
18:41:19 <dons> ah, hmm, don't think so. ozone probably was though.
18:41:21 <humasect> i've kind of forgotten who was.
18:41:25 <humasect> ok
18:41:31 <dons> (he's in my rsrch group)
18:41:48 <humasect> i'm sorta designing something
18:44:26 <tibbetts> Does GHC have introspection support?
18:45:15 <dons> introspection?
18:47:04 <tibbetts> ie, the ability to get a list of all the identifiers defined in a module, and a way to dereference an identifier in order to use it.
18:47:31 <dons> at compile time?
18:47:34 <dons> or runtime?
18:47:37 <tibbetts> Interpretted languages tend to have this, and Java/C# do. It is useful for making unit testing easier to do
18:47:40 <tibbetts> At runtime.
18:47:59 <dons> ah, we don't have runtime metaprogramming, now. the problem is that static typing makes doing this safely very hard.
18:48:05 <dons> however, it's an active area of research.
18:48:20 <dons> we do have compile time metaprogramming, via Template Haskell.
18:48:45 <dons> generally, Template Haskell is enoough. for unit testing I imagine it would be enough.
18:48:52 <dons> since the code isn't changing on the fly.
18:48:57 <tibbetts> Yeah, it may well be enough.
18:49:23 <tibbetts> It limits a few things, but it would get you 80% of the way there.
18:52:06 <dons> for critical cases, we do have hs-plugins, which lets you consturct new modules at runtime. you can certainly use TH inside those modules. meaning that runtime metaprogramming is possible.
18:52:29 <dons> there's a couple of other ways as ewll, but like I say, it's an active area that hasn't even been written up yet.
18:52:59 <tibbetts> I'll start with Template haskell.
19:21:23 <tibbetts> Template haskell seems to give me a way to construct code ala macros, but I don't see how it gives me enough rope to know what identifiers exist in a namespace. Is there support for that?
19:23:54 <dons> it lets you inspect the abstract syntax tree, and talk to the compiler, so think this should be possible, yes.
19:24:06 <dons> s/I think/
19:24:27 <tibbetts> ah, ok, the doc I'm looking at doesn't talk aobut ast inspection. I guess I'll look at more of the papers or something.
19:24:30 <dons> hmm. though what exactly are you trying to do? there may be a more canonical way to do this.
19:26:18 <tibbetts> of course. The goal is to be able to specify a single statement, and have it look in the current namespace and find all identifiers named test*, and run them as HUnit tests.
19:27:09 <tibbetts> though a different idiom that similarly removed the need to redundantly list tests would be fine.
19:27:25 <tibbetts> I'm just used to how java and python and such do it.
19:27:54 <dons> ah, stefanw wrote code that does avoid the need to multiply lists tests using TH. let me find the code.
19:28:52 <dons> here: http://www.cse.unsw.edu.au/~dons/code/fps/tests/Tests.hs
19:29:09 <dons> the support code is in the tests/ dir
19:29:37 <dons> you'll see that inside the $(tests "fps" [d|
19:29:49 <dons> splice is where tests are written, but in
19:30:26 <dons> UnitTestsMain.hs you only need to list the enclosing splice's name, i.e. "fps" allTests = TestList [ fps ]
19:31:12 <dons> so anything called "test_*" inside the $() splice is picked up and added to the  list of tests. is that basically what you want?
19:31:44 <tibbetts> Ah, that is pretty good looking. It definitely cuts down on the excess verbosity/redunancy, which is what I was looking for. I'll give it a try.
19:31:53 <dons> feel free to grab the code from the fps/tests/ dir and use it yourself. it also has QuichkCheck examples which are useful to see, I think.
19:31:54 <araujo> That sounds like reflective programming.
19:33:59 <dons> TH is reflective. It's metaprogramming , after all, so reflection is just one part of the picture.
20:51:10 <metaperl> really bad news: 18,000 died today in a 7.6 earthquake in Pakistan
20:54:25 <ibid> i wonder if it's the same i read about in the morning paper just now
20:54:34 <ibid> (ie. when "today"?)
20:54:45 <sethk> metaperl, 18,000?  God.
20:54:55 <metaperl> well it was 9am saturday at ground zero... sethk: no joke, 18,000
20:55:12 <ibid> local time?
20:55:28 <metaperl> completely overshadows the 1400 dead in guatemala from a mudslide.. ibid: apparently based on news.google.com
20:55:30 <sethk> metaperl, I see it in the ap wire.
20:55:48 <ibid> ok, it probably is the same then
20:56:03 <sethk> metaperl, ap says 617 killed
20:56:28 <sethk> whch is bad enough
20:57:22 <ibid> the paper discussed an eyewitness report of a building collapsing, with all the people living in that building trying to get out of the building, or at their balconies just before the collapse
20:57:28 <metaperl> sethk: yes, and VoA only counts 1700... but wikipedia.org had 18,000 and the lead article at google did as well... http://en.wikipedia.org/wiki/2005_South_Asia_earthquake
20:57:41 <sethk> metaperl, no, 617 in south america
20:58:12 <metaperl> sethk: oh
20:58:26 <sethk> metaperl, ap says 3000.  I'd definitely believe ap over wikipedia
20:59:57 <metaperl> sethk: AP url is what?
21:00:04 <sieni> hmm... again an ESA satellite ended up somewhere else than space
21:00:31 <sieni> I wonder why they put that on Slashdot, since it should be covering _news_
21:00:45 <Korollary> cnn says 18k as well
21:00:49 <sieni> and it would only be news if ESA managed to get the satellite into space
21:14:48 <Cale> shapr: are you there?
21:15:14 <Cale> There's a lot of small annoying spam on the wiki.
21:18:24 <Cale> Is anyone else with revert access on the Wiki around?
21:18:33 <Cale> This is ridiculous.
21:19:25 <sethk> metaperl, http://www.newsday.com/news/nationworld/wire/sns-ap-south-asia-quake,0,4302849.story?coll=sns-ap-nationworld-headlines
21:45:49 <shocker> how can i get the nth item from a list?
21:46:04 <int-e> list!!(n-1)
21:46:42 <int-e> i.e.  list !! 0  is the first item
21:47:03 <shocker> ok thanks
21:47:09 <shocker> what does !! do?
21:47:37 <int-e> shocker: get the n-th item from a list (where 0 is the first item)
21:47:58 <shocker> so thats its only function,
21:48:10 <int-e> that's enough, isn't it?
21:48:13 <int-e> @type (!!)
21:48:23 <lambdabot> forall a. [a] -> Int -> a
21:48:24 <humasect> @libsrc (!!)
21:48:25 <lambdabot> (!!) not available
21:48:58 <shocker> ok then, thanks
21:52:07 <shocker> is there a way to get the nth-5 item to the nth item?
21:52:36 <Cale> like, that range in the list?
21:52:42 <Cale> use take and drop
21:52:51 <shocker> yea
21:52:52 <shocker> ok thnaks
21:53:12 <Cale> (you could also write an obvious function based on those)
21:53:17 <shocker> yep
21:54:04 * Cale reverts the seemingly endless spam commits made on the wiki today
21:54:33 <Cale> heh, I go away for a few hours, and look what happens :)
22:19:17 <shocker> how can i add something to a list, list:something?
22:19:45 <sjanssen> shocker: something:list
22:19:55 <sjanssen> shocker: that adds to the beginning
22:20:01 <sjanssen> @type (:)
22:20:07 <lambdabot> forall a. a -> [a] -> [a]
22:40:57 <int-e> @type append
22:41:02 <int-e> err
22:41:05 <int-e> @type (++)
22:41:05 <lambdabot> bzzt
22:41:06 <lambdabot> forall a. [a] -> [a] -> [a]
22:50:01 <Cale> http://www.haskell.org/hawiki/RecentChanges -- heh
22:50:14 <Cale> cleaned up the spam :)
22:56:39 * int-e wonders what the point of spam like that is.
22:56:43 <araujo> Hello.
22:57:04 <Korollary> it's probably to increase the pageranks of some sites
22:57:27 <Cale> one of the types there was really stupid, just a 4-letter tag
22:57:33 <Cale> xSMx or something
22:57:43 <int-e> yes, that's what I meant
22:57:46 <Cale> maybe just someone testing a spamming script
22:58:01 <Korollary> they should write spamming scripts in haskell ;)
22:58:04 <Cale> there was another spam going on at the same time which was a linkfarm type deal
22:58:44 <Cale> (but it wasn't as widespread)
23:08:51 <int-e> ok, I understand that
23:28:10 <araujo> @hoogle createPipe
23:29:24 * Korollary uses runCommand "/usr/bin/mkfifo f" :(
23:54:15 <sieni> http://yann.lecun.com/ex/images/allyourbayes.jpg
23:55:04 * Korollary keels over and dies
23:57:48 <int-e> oh great. sieni, look at this mess.
23:57:59 <araujo> How do i import a module removing one function from it?
23:58:25 <int-e> uh. wasn't there a hiding specification?
23:59:09 <int-e> yep. import module hiding (function)
23:59:21 <araujo> Thanks int-e
