00:07:48 <Dibrom> anyone around that knows about arrows?
00:11:06 <Oejet> Dibrom: Not me, sadly.
00:11:14 <basti__> just a little
00:12:10 <Dibrom> well, I'm mostly just looking for some good resources to learn about them from.  Of course I've been reading some of the stuff on haskell.org/arrows, and some of the yampa stuff, but I'm wondering if there's anything a little more practical out there yet to play with
00:13:10 <basti_> hehh
00:13:23 <Dibrom> in other words, are there any well known projects using arrows, where I can look at some source code, besides afrp/yampa (which seems to be not up to date)?
00:13:24 <basti_> thats what everyone is wondering
00:13:35 <Dibrom> ok.. so I don't feel so bad then ;)
00:13:39 <basti_> ;)
00:13:56 <Dibrom> guess I'll have to roll my own...
00:14:08 <basti_> no honestly, it seems that arrows are a very general concept, it's not clear if this much generality is needed
00:14:25 <basti_> it has been shown that arrows avoid memory leaks in some cases, though
00:14:53 <Dibrom> yeah.  Well for most applications, probably not.  But one of the reasons I was interested in learning them is for something very much reactive animation type stuff.
00:15:10 <Dibrom> versus what?
00:15:14 <Dibrom> old frp?
00:15:20 <basti_> uhm, monadic style
00:15:24 <Dibrom> oh, ok
00:15:53 <basti_> the "why" is rather unclear to me
00:16:05 <Dibrom> I don't have much knowledge about leakage issues with that, although I've seen it mentioned in numerous arrows papers
00:16:10 <Dibrom> yeah...
00:16:48 <Dibrom> so nobody except for the researchers are really excited about arrows yet then?
00:17:04 <Dibrom> (I just started serious haskell programming about a month ago, so don't know the community well)
00:17:16 <basti_> it seems that when you process a lot of stuff in a monad (like in a regex parser), unused thunks start to pile up
00:17:32 <Dibrom> ok
00:17:47 <basti_> imagine a regex with 10 alternatives in each step
00:17:54 <Dibrom> yeah
00:18:01 <basti_> like [abcdefgh][abcdefghij][bcdefghijkl]
00:18:29 <basti_> it seems that mem is allocated for every alternative, and never given back until the whole regex is processed, in monadic style
00:18:36 <basti_> as for researchers.... ask shapr :P
00:50:12 <Oejet> Oh, boy.  I left boiling water on the stow for the whole night. :-(
00:50:18 <basti_> ugh
00:50:23 <ValarQ> ow
00:52:40 <Oejet> Fortunately the damage was as small as you can hope for.  The buttom layer of the pot fell of, but that's all.  Now it's still cooling down.  It even had a glass lid on it the whole time.
01:07:57 <xerox> Good morning!
01:14:50 <Oejet> xerox: Hello.
01:14:56 <ValarQ> xerox: mornin
01:17:30 <ValarQ> hmm, seems i got some monad troubles, again...
01:18:34 * xerox hands ValarQ some lambdas
01:18:48 * basti_ hands ValarQ an associative law
01:19:08 * sieni should start learning some monad stuff, since coding an nfa regex engine without them is probably stupid
01:19:09 <ValarQ> i wan't to do something like  f x = x : f (dowah x)
01:19:29 <ValarQ> er
01:19:56 <ValarQ> f x = mx : f (dowah mx) -- where x is some data and mx is some monadic the same
01:20:10 <xerox> What's the type of f ?
01:20:13 <basti_> whats dowah?
01:20:27 <ValarQ> heh, i better let you watch my real code...
01:20:57 <ValarQ> the problem is that i don't know how to lift mx into f (because f doesn't take a monadic argument)
01:21:08 <basti_> first, what do you want to do?
01:21:35 <ValarQ> basti_: i wan't to create a list
01:21:45 <ValarQ> http://arda.no-ip.org/nmarkov.hs <- the real thing
01:21:55 <ValarQ> it's the makeText function i'm working on
01:22:19 <ValarQ> i'm trying to create a [Gen String] list
01:22:30 <basti_> hmm
01:22:33 <basti_> what is Gen?
01:22:40 <basti_> quickcheck?
01:22:53 <ValarQ> yeah, Test.QuickCheck
01:23:21 <basti_> i see
01:24:19 <basti_> ahh
01:24:20 <ValarQ> i guess i don't know how to make a recursive (a -> Gen [a])
01:24:25 * basti_ just looked up the type
01:24:39 <basti_> first, you want to generate Strings, don't you?
01:25:02 <ValarQ> no, i don't wan't to call generate in my makeText
01:25:32 <basti_> yes but you want to have a Gen String in the end?
01:25:42 <basti_> or a Gen [String], or a [Gen String]?
01:25:59 <ValarQ> i believe i wan't a [Gen String]
01:26:12 <basti_> so many generators of strings
01:26:28 <basti_> what does that have to do with monads now?
01:26:56 <ValarQ> isn't Gen a type of Monad?
01:27:04 <basti_> hmm
01:27:21 <ValarQ> or am i completely confused?
01:27:23 <basti_> actually it is.
01:27:27 <ski> Oejet : i've had a pot bottom layer melt on the stove ..
01:27:28 <basti_> instance Monad Test.QuickCheck.Gen
01:27:49 <basti_> that means you can build a "Gen" with "do"ing several Gen's.
01:29:07 <ValarQ> hmm :/
01:29:30 <xerox> Hola lispy
01:30:20 <basti_> like: do {x<-intGen;y<-floatGen;return (x,y)} could be a Gen (Int,Float)
01:31:56 <ValarQ> basti_: does that mean i can't make my function recursive?
01:34:08 <araujo> Hello!
01:34:16 <basti_> ValarQ: i didn't say that.
01:34:20 <basti_> :D
01:34:20 <ski> why do you have a '(p1, p2) = px' when you don't use 'p1' or 'p2' ?
01:34:21 <ValarQ> maybe i should experiment with a very limited makeText
01:34:39 <ValarQ> ski: i used them back in the old days
01:34:51 <ski> ValarQ : is it the case that you want to return Gen [String] ?
01:34:54 <ski> ok
01:34:55 <ValarQ> ski: that is 5 minutes ago :)
01:35:24 <ValarQ> hmm, wait a min
01:35:26 <ski> hm, you want a list of generators  ?
01:35:30 <basti_> ValarQ: first, what do you want to generate, and how does that depend on a Map of 2-string-tuples to String Arrays and single Strings?
01:35:31 <ValarQ> i should use p2...
01:35:37 <ski> or you want a generator, generating a list of string ?
01:35:43 <basti_> *and two-string tuples
01:36:09 <ValarQ> http://arda.no-ip.org/nmarkov.hs (reload)
01:36:38 <ValarQ> ski: well, maybe i want the latter
01:36:54 <basti_> what do you want the Gen to generate actually?
01:37:00 <basti_> I think that's what it depends on
01:37:03 <ski> ValarQ : you're 'makeText ... = do ...' seems to imply you want  Gen [String]
01:37:06 <ski> ok
01:38:05 <ValarQ> i wan't to generate a list of strings
01:38:23 <ValarQ> but each string depends on the earlier string
01:38:36 <ski> i bellieve you want 's = getRandomElem slist' as an action in the do, (with s/=/->/ then)
01:38:57 <ski> because otherwise 's' is not a string but a string-generator
01:39:13 <ski> and you want to cons a string, i think
01:39:38 <basti_> ValarQ: like [String]->Gen [String]?
01:39:56 <basti_> (or maybe even like String->Gen String?)
01:40:23 <ski> basti_ : why the (list of) string argument ?
01:40:51 <basti_> hmm maybe i misunderstood
01:41:11 <basti_> that would be like, "a list of strings, where each string depends on some earlier string"
01:41:31 <ski> hello EdLin
01:41:43 <basti_> (implying that we can't reduce this dependency to String -> Gen [String])
01:41:54 <EdLin> ski: hi
01:41:57 <basti_> hi EdLin. are you new to #haskell?
01:42:02 <EdLin> yes
01:42:15 <basti_> our tour bot is offline sadly, but feel free to ask any questions.
01:42:30 <ski> basti_ ?
01:42:32 <ski> @learn
01:42:34 <lambdabot> http://www.haskell.org/learning.html
01:42:38 <EdLin> basti_: thanks
01:42:40 <basti_> ski: the tour-bot called shapr.
01:42:47 <ski> ah .. that bot, yes
01:42:55 <ValarQ> i think i solved it now...
01:43:18 * basti_ .oÂ° ( the miracle of directed questions at work )
01:43:44 <basti_> EdLin: are you new to haskell, too?
01:44:08 <ValarQ> basti_: i should think so :)
01:44:26 <ValarQ> http://arda.no-ip.org/nmarkov.hs <- da result
01:44:44 <ValarQ> gotta clean up that ugly main thought
01:45:19 <ValarQ> thats almost as ugly as my assembler telnet server
01:45:27 <EdLin> basti_: yes, I'm new to Haskell too.
01:45:42 <basti_> I'm sure you know what you mean with that function. I don't.; )
01:45:54 <ski> ValarQ : yes, you can bind 's', too .. but note, if you want you can substitute 'getRandomElem slist' for 's'  (also possibly changing (>>=) into do, if you want)
01:46:02 * ValarQ is thinking about starting a ed(1) vs edlin flamewar with EdLin 
01:46:21 <EdLin> ed(1) is much better, it has regular expressions. :)
01:46:33 <basti_> EdLin: how new? do you know functional programming (or even Prolog)? do you know an other programming language (which?)? do you need any help or tutorial?
01:46:52 <EdLin> I know a bit of lisp.
01:47:02 <ski> that helps
01:47:04 <ValarQ> EdLin: yeah :)
01:47:04 <basti_> thats a good starting point.
01:47:17 <basti_> haskell is different though, it is lazy.
01:47:42 <EdLin> what do you mean by lazy?
01:47:46 * genneth can't be bothered to even get out of bed
01:47:47 <ValarQ> i had to use ed(1) when i messed up my terminfo library some months ago, ed(1) is great
01:47:57 <EdLin> I've seen that term before but don't know it's meaning
01:48:14 <basti_> EdLin: it doesn't evaluate something until absolutely necissairy
01:48:17 <ski> EdLin : arguments e.g. aren't evaluated if not needed
01:48:19 <basti_> for example:
01:48:28 <basti_> @plugs let ones=1:ones in take 10 ones
01:48:29 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
01:48:38 <ski> 'ones' is an infinite list
01:49:14 <ski> @plugs take 5 (map (*10) [4..])
01:49:16 <lambdabot> [40,50,60,70,80]
01:49:29 <basti_> note that lambdabot was able to compute the finite result in finite time, although there's infinite data structures involved
01:49:48 <EdLin> basti_: that's neat. :-)
01:50:11 <EdLin> basti_: if it evaluated it right away that'd be impossible
01:50:28 <ski> as long as we don't try to look (which forces evaluation) at the whole infinite datastructure, we're ok
01:50:30 <basti_> that's the point, yes
01:50:39 <ski> @plugs sum [1..10]
01:50:40 <lambdabot> 55
01:50:43 <ski> @plugs sum [1..]
01:50:47 <lambdabot> Terminated
01:50:49 <ski> :)
01:51:08 <basti_> btw: yes you CAN make lambabot print out infinite datastructures. It's obvious what would happen. Please don't try it in the channel ;)
01:51:29 <genneth> @plugs let fib = 1:1:(fib+tail fib) in take fib 10
01:51:30 <lambdabot> Couldn't match `Int' against `[a]'
01:51:50 <genneth> @plugs let fib = 1:1:(fib+tail fib) in take 10 fib
01:51:51 <basti_> "zipWith"
01:51:51 <lambdabot>  add an instance declaration for (Num [a])
01:52:02 <genneth> oh yeah... damn
01:52:09 <basti_> @plugs let fib = 1:1:(zipWith (+) fib (tail fib)) in take 10 fib
01:52:09 <genneth> i always forget that bit
01:52:10 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
01:52:29 <basti_> EdLin: if you understand why this works, you understood half of haskell.
01:52:33 <ski> @plugs let fibs = 0:1:(zipWith (+) fibs (tail fibs)) in take 10 fibs
01:52:34 <lambdabot> [0,1,1,2,3,5,8,13,21,34]
01:52:41 <ski> can also be written as
01:53:11 <basti_> (thats the "Fibonacci numbers", f(n)=f(n-1)+f(n-2))
01:53:28 <ski> @plugs let fibs = 0:(zipWith (+) fibs (1:fibs)) in take 10 fibs
01:53:29 <lambdabot> [0,1,1,2,3,5,8,13,21,34]
01:54:01 <dons> btw, @eval is an alias for @plugs
01:54:14 <jyp> hey dons
01:54:19 <xerox> (The parens aren't needed)
01:54:36 <dons> hey jyp :)
01:55:10 <ski> basti_ : if one tries to print an infinite datastructure .. it only prints some (10 ?) lines and then pauses (allowing you to resume printing some @more lines if you want)
01:55:23 <EdLin> hope I'm not posting a flame question, but what's the best haskell compiler?
01:55:23 <dons> 7 lines, iirc
01:55:29 <jyp> dons, Yay to your resuming hacking on yi :)
01:55:38 <dons> jyp, yeah! :)
01:55:57 <dons> Lemmih and dcoutts' work on hIDE has been a good motivator
01:56:03 <basti_> ski: yes.
01:56:04 <humasect> =D
01:56:08 <basti_> ski: it's obvious isnt it? ;)
01:56:15 <jyp> I just compiled it... Is it in a runnable state?
01:56:26 <basti_> EdLin: ghc is accepted as the de-facto standard.
01:56:45 <dons> EdLin, ghc is a good haskell compiler. it produces the fastest code and has numerous interesting extensions
01:57:01 <EdLin> basti_: what version of ghc? ghc5, ghc6, and ghc-cvs are all in my Debian repository.
01:57:14 <dons> ghc6, is what you want, most likely
01:57:18 <EdLin> OK.
01:57:21 <basti_> you won't notice the differences, probably.
01:57:53 <EdLin> thanks
01:58:09 <basti_> there's an interactive environment called "ghci" too
01:58:30 <basti_> you can toy around with that a bit to learn the basics.
01:58:34 <basti_> it's handy for debugging too.
01:58:40 <ski> EdLin : and just ask here when you've got questions
01:58:55 <dons> basti_: and for constructing nice examples to show in #haskell :)
01:59:25 <basti_> yep
02:03:55 <ValarQ> damned, i have created a monster :(
02:04:12 <basti_> ?
02:04:13 <ValarQ> this doesn't work well at all
02:04:39 <basti_> first you should try to get clear about what you want to generate.
02:04:47 <ski> 's <- getRandomElem slist'
02:04:54 <ski> you forgot 'slist'
02:04:55 <basti_> then you should learn what you need to do so, and then write a type.
02:05:30 <ValarQ> ski: not in the latest version?
02:05:46 <ski> ah, now it's there
02:06:15 * ski looks more closely for possible more problems
02:06:18 <ValarQ> i believe this is close to what i want, i want to generate a list of strings
02:06:35 <basti_> like in Gen [String] yes?
02:06:42 <ValarQ> basti_: yeah
02:06:59 <basti_> what are the parameters for?
02:07:04 <ValarQ> basti_: so i can hand that to generate
02:07:20 <ValarQ> basti_: you mean the prefixes? px?
02:07:37 <ski> hm 'length slist > 0' is better written 'not (null slist)'
02:07:49 <ValarQ> ski: ok
02:08:03 <basti_> and the m?
02:08:04 <dons> not . null $ slist  perhaps?
02:08:13 <ski> (no need to compute whole length every time we recurse, just to check if it's empty)
02:08:17 <basti_> i mean, i can imagine what prefixes are for
02:08:31 <ValarQ> hmm, "Ambiguous occurrence `null'"
02:08:45 <ValarQ> ski: no, that might be my problem
02:09:35 <araujo> What is a good module for parsing stuff?
02:09:48 * araujo doesn't want to re-invent if possible
02:10:11 <basti_> "parsec"?
02:10:18 <ValarQ> "happy"?
02:10:34 <ski> (if you want you can change 'curry (makeText m) p2' to 'makeText `curry` p2'  .. you can think of '`curry`' a bit like '$' .. or .. you could make 'do p3 <- getRandomElem slist; makeText m (p2,p3)' ..)
02:11:14 <araujo> basti_, ValarQ will check both, thanks
02:12:15 <ValarQ> ski: that might look better...
02:13:04 <ski> (also, because you use the 'getRandomElem' directly in the do, i thnk you don't need 's = getRandomElem slist')
02:13:09 <ValarQ> ski: ok, i updated the file
02:13:41 <ski> (you know you can omit the '{','}', there, right ?)
02:14:09 <dons> parsec and happy are the two standard options
02:14:09 <dons> parsec is for combinator-based parsers, happy is a yacc-style parser generator
02:14:09 <dons> similarly for lexers, we have the alex lexer generator, and the ctk lexer combinator lib
02:14:16 <ski> hmm
02:14:50 <ValarQ> heh, the function got quite small there :)
02:15:24 <ValarQ> ski: that looks a lot better, thanks
02:15:27 <basti_> ValarQ: great.
02:15:34 <ski> np
02:16:16 <ValarQ> it still does no good thought
02:16:36 <ski> hm
02:16:56 <ValarQ> just sucks a great deal of cputime
02:17:10 <ski> which, if any, of the functions do work as intended ?
02:17:29 <EdLin> @plugs print "Hello world"
02:17:30 <lambdabot> No IO allowed
02:17:30 * ski has no idea what the code is supposed to do ..
02:17:46 <ski> EdLin : for security reasons ..
02:17:50 <EdLin> funny, that worked in ghci. :-)
02:17:53 <ski> sure
02:17:55 <EdLin> ski: OK
02:18:19 <ski> but you prolly don't want to give any random irc user access to your machine :)
02:18:32 <EdLin> yeah, that'd be a bad idea. :-)
02:18:46 <ski> (i.e. the machine lambdabot currently lives in)
02:19:15 <ski> (EdLin : there recently was some talk about making a restricted IO, for use here on irc ..)
02:19:32 <dons> lucky we have a type system that can enforce that users don't do bad things on my machine :)
02:19:40 <genneth> ski: I was about to say -- a modified IO monad would be rocking
02:19:41 <ValarQ> ski: it should be a list of almost random words
02:19:58 <ski> ValarQ : which ? :)
02:20:06 <ski> ValarQ : makeText ?
02:20:20 <ValarQ> ski: yeah
02:20:27 <ValarQ> ski: but i think i see the problem now
02:21:02 <ValarQ> ski: i never create any strings
02:21:11 <ValarQ> ski: just calls recursively
02:21:49 <ski> o-k
02:22:23 <ValarQ> now it works :D
02:22:30 * basti_ grins
02:22:36 <EdLin> this lazy stuff is cool, no more for() loop constructs
02:23:04 * ValarQ bows before basti_ and ski
02:23:29 <xerox> ValarQ: what's the purpose of the whole program?
02:23:31 <ski> (ValarQ : ah, i wondered if you shouldn't cons something onto recursive results of makeText, but wasn't sure)
02:23:39 <basti_> ValarQ: no problem. I still dont know what your code is doing, but if poking it with sticks verbally helps i'm always in for it ;)
02:23:52 <ski> :)
02:26:47 <ski> ValarQ : it seems like 'markovb' is always returning a list of 3-element lists .. so is there any specific reason not to do 'markovb :: [String] -> [(String,String,String)]' instead ?
02:27:53 <ski> ((if you do that, you can avoid the possibly-dangerous looking 'ins [p1,p2,s] = ' and instead do 'ins (p1,p2,s)' ..)
02:29:37 <ski> (though, in this case it might be easier to just do 'take 3' as you do currently .. so don't consider this to be such a grave request for change if you like the way it is rn .. just so you understand the other possibility)
02:45:09 <JohnMeacham> hello
02:45:29 <ValarQ> ski: the reason to why i split it in 3 elements is that i wan't all words in a list inserted into a finite map with the two preceding words as the key
02:46:39 <ski> yes .. (but why a three-element list, instead of a triple ? .. that was my question)
02:46:50 <basti_> (hint: "to want" is a complete verb. the 't and 'nt suffixes are shorthands of "not": negations)
02:47:25 <ValarQ> ski: oh, you're right, that should be a [(String,String,String)]
02:47:46 <ski> no, i just said it *could* be [(String,String,String)]
02:47:59 <ski> you have to decide which you like best
02:48:08 <ValarQ> basti_: thanks, i got big problems with that :(
02:48:14 <ski> the triple-version gives more static guarrantees
02:48:36 <ski> (i.e. you see directly by looking at 'ins' that it can't fail in pattern-matching)
02:49:36 * ski used to do 'wan't', too .. but managed to purge that ..
02:50:14 <ValarQ> just hit me with a big LART the next time i say it
02:50:16 <basti_> there is won't: "will not"
02:51:02 * ski guesses 'wantn't' is actually a correct abbrev. ..
02:51:14 <ski> (meaning another thing)
02:51:33 <JKnecht> won't is an idiom, not an ordinary contraction.
02:51:56 <ValarQ> ski: how can i convert that 'take 3' list to a tuple?
02:56:24 <basti_> ValarQ: \[a,b,c]->(a,b,c) if everything else fails ;)
02:57:44 <basti_> you could immediately build the tuple though
02:59:46 <ski> ValarQ : btw, you shouldn't really call 'length' like that in 'markovb' ..
03:00:17 <ski> changing to pattern-matching will also solve the triple-building fine
03:08:19 <ValarQ> ski: how can i match 'length xs < 3' with patterns in a good way?
03:09:23 <ski> hm
03:09:57 <ski> first, in you current 'markovb', i think you can skip the '== 3' basecase, if you change '> 3' to '>= 3' in the recursive case
03:10:13 <ski> good morning yoel
03:10:43 <ValarQ> ski: try reloading my nmarkov.hs
03:11:54 <ValarQ> ski: is that markovb the way to go?
03:12:00 <ski> lemme look
03:12:25 <ski> s/[a,b,c:xs]/(a:b:c:xs)/
03:12:58 <ski> also, as said, you don't need the first case .. it's handled by the other two anyways
03:13:09 <ValarQ> ok
03:13:15 <ski> hm, wait
03:13:21 <ski> there is a bug there
03:13:55 <ski> in your former function, you took the tail and passed it on recursively .. so you stepped one element at a time
03:14:09 <ski> right now you're stepping 3 elems at a time
03:14:24 <ski> try (a : xs@(b:c:_))
03:14:30 <ValarQ> yeah, thats true
03:14:56 <ValarQ> nice pattern :)
03:15:17 <ski> (or, just .. (a:b:c:xs)  but then pass (b:c:xs) recursively   maybe you think this is nicer, dunno
03:15:38 <ski> )
03:15:55 <ValarQ> i like your fancy pattern, thank you :)
03:16:23 <ski> yw :)
03:16:33 <ValarQ> hmm, there is something funny with this program
03:16:40 <ski> hm ..
03:16:51 <ValarQ> it's way to fast, how did my code get this efficient?
03:17:17 <ski> one thing you be that you don't recompute length of lists all the time
03:17:21 <ValarQ> i haven't even turned on the optimization in ghc yet
03:17:31 <ValarQ> that could be it
03:17:44 <ski> s/you be/could be/
03:21:23 <ValarQ> some output from my program: "und even if ye do!" Unheeding, the fierce _blaat_ of the Wizard, his medallion flashing in the late Farahsbax. "Speak," commanded Arrowroot, hoping he wouldn't. "If you be callin' that?" asked Frito.
03:22:21 <psi_> heh
03:22:39 <psi_> is it like megahal?
03:23:01 <ValarQ> almost, it's a much simpler algoritm thought
03:23:13 <psi_> ok
03:23:17 <ValarQ> http://arda.no-ip.org/nmarkov.hs
03:24:28 <ValarQ> thanks to basti_ and ski i now got unlimited amounts of wonderful nonsense :)
03:25:15 <basti_> :D
03:25:32 <ski> hehe
03:26:12 <ski> (ValarQ : are you married to that first base case ? :)
03:27:53 <ValarQ> ski: first base?
03:28:05 <ski> yes
03:28:40 <ValarQ> which of them is the first?
03:29:55 <ski> 'markovb [a,b,c] = [(a,b,c)]'
03:30:42 <ValarQ> oh, that was unnecesary, right
03:30:47 * ValarQ deletes a line
03:31:00 <ski> markovb [a,b,c]  =  markovb (a:b:c:[])  =  (a,b,c) : markovb (b:c:[])  =  (a,b,c) : []  =  [(a,b,c)]    -- using use thw two other clauses
03:31:20 <ski> s/use thw/just the/
03:43:04 <ski> @arr
03:43:05 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
03:46:21 <takuan> gni
03:46:22 <takuan> @arr
03:46:23 <lambdabot> Aye Aye Cap'n
03:49:35 <neologism> what slang is it "arr ya" ?
03:50:11 <likens> are you
03:50:19 <neologism> I mean.. where/when people speak like this>?
03:50:32 <jyp> Pirates
03:50:42 <jyp> ... supposedly
03:50:43 <neologism> heh
03:52:24 <jyp> http://www.syddware.com/cgi-bin/pirate.pl
03:57:13 <ski> http://www.pmachine.com/plugins/pirate-speak/
04:04:14 * araujo throws at dons_ some lambdas
04:04:55 <neologism> lambdas can be thrown? I thought it can only be applied :)
04:05:42 <Philippa> how else do you think you implement exceptions in the lambda calculus?
04:05:51 <araujo> you learnt something new today :-]
04:06:21 <ski> (hm, one can throw around with continuations .. and a function is a continuation that accepts a pair of an argument value and a return continuation ..)
04:09:54 <neologism> where can I get some doc on the lambdabot?
04:31:02 <ndm> i'm having haddock problems :(
04:31:24 <ndm> i do "haddock basic.hs"
04:31:30 <ndm> i get no messages out at all
04:31:37 <ndm> no warnings/errors
04:31:42 <ndm> and then i get no documentation
04:32:43 <JohnMeacham> Hmm.. cabal should ignore any fields in the cabal file that start with 'x-'.
04:33:53 <ndm> should haddock basic.hs work, or have i got the command line wrong?
04:34:22 <Igloo> You need -h or --html or something
04:35:55 <ndm> Igloo: thanks very much, that works now
04:36:10 <ndm> perhaps it should issue a warning if you leave any output options off...
05:06:51 * shapr boings cheerfully
05:08:31 <Philippa> 'lo
05:11:08 <shapr> wassup?
05:12:17 <araujo> morning
05:12:25 <Philippa> Mostly less-than-fun stuff. My right leg's exacting revenge on me for walking back from Corinna's on thursday and I'm not sure I'll manage to drag myself to RPGsoc in an hour
05:12:35 <Philippa> not at this rate, anyway - I've not eaten or showered or...
05:14:05 <earthy> even gotten out of bed
05:14:05 <earthy> ;)
05:14:37 <Philippa> I've managed that one. It took me a good 20 minutes to pour myself a glass of coke from the bottle next to me though, which pretty much sums up where I'm at
05:15:03 <earthy> youch
05:15:18 <earthy> oh well, I've traveled halfway 'cross the country already
05:15:19 <ValarQ> hello shapr
05:15:23 <earthy> so I'm not complaining
05:15:29 <earthy> time to go nerd a bit :)
05:15:44 <Philippa> heh
05:16:07 <Philippa> I'm hoping to go see friends in Cambridge sometime before the end of the year, not sure I'm going to be able to afford a second journey the way things're going at the moment
05:20:11 <shapr> hej ValarQ
05:20:38 <pesco> Moin Moin shapr!
05:20:54 <shapr> hiya pesco, how's life?
05:21:20 <pesco> Pretty good. I've spent some thought on the filesystem stuff.
05:21:25 <ValarQ> shapr: i got that QuickCheck Gen thing to work now :)
05:21:31 <shapr> ValarQ: awesome! I want to see!
05:21:42 <ValarQ> shapr: sure, http://arda.no-ip.org/nmarkov.hs
05:22:20 <shapr> Whoa nice, that cut out a bunch of code.
05:22:53 <ValarQ> yeah, that makeText function got quite nice
05:23:39 <shapr> Did that deepen your understanding of monads?
05:24:01 <ValarQ> yes indeed
05:24:19 <shapr> spiffy
05:25:31 <ValarQ> got quite a lot of help from mr basti_ and mr ski thought
05:25:48 <shapr> Yeah, they're helpful people.
05:26:28 <ValarQ> yeah
05:27:02 <ValarQ> i wonder if i should implement my g-code generator in haskell...
05:27:23 <ndm> shapr, you said you might be able to help me with setting up a hoogle function documentation wiki
05:27:49 <shapr> You want a wiki on haskell.org or what?
05:27:53 <shapr> ValarQ: g-code?
05:28:11 <ValarQ> shapr: yeah, iso g-code for milling/drilling machines
05:28:23 <shapr> Sounds neat, I know nothing about it.
05:28:30 <ndm> shapr, yep - that sounds good
05:28:33 <shapr> I've seen CNC scripting with Haskell, is that related?
05:28:43 <ndm> just something so every single function can have its own documentation page :)
05:29:16 <ndm> i'm going to have haskell.org/hoogle soon
05:29:22 <shapr> ok
05:29:28 <ndm> so either below that, or possibly a non-hoogle one
05:29:34 <ndm> i.e. make it useful for other things too
05:29:39 <ValarQ> shapr: i did a pythonprogram that merged shapes with eachother and calculated the contours to get a path to feed to the milling machine
05:29:46 <shapr> ValarQ: cool!
05:30:26 <ValarQ> shapr: i believe the quadtree implementation would do better in haskell, i guess it will be faster than python as well
05:33:09 <shapr> It sounds like cool code.
05:35:19 * boegel|home takes a peek inside #haskell
05:35:40 <ValarQ> what is the simplest graphics library for ghc?
05:35:40 <Oejet> boegel|home: HELLO!
05:35:51 <ValarQ> HGL?
05:37:38 <Oejet> ValarQ: It seems to be the only one in the GHC standard library.
05:38:21 <ValarQ> Oejet: ok, a simple choice then...
05:38:34 <Oejet> ValarQ: Or, if you are familiar with Cairo, dcoutts and others has done good work with Gtk with Cairo.
05:38:35 <shapr> ndm: It's your choice, I'm willing to set up a wiki however you want.
05:38:58 <ValarQ> Oejet: that sounds real neat
05:39:09 <ndm> shapr, thanks - any suggestions? whatever is easiest really
05:39:23 <ValarQ> Oejet: is there any cairo haskell code out there?
05:39:29 <ndm> would it be a useful haskell resource to document with examples and source code every function in every library ever?
05:40:04 <Oejet> ValarQ: See http://haskell.org/gtk2hs/
05:40:54 <boegel|home> Oejet: hi !
05:40:55 <boegel|home> bye !
05:40:56 <boegel|home> *off
05:41:04 <Oejet> boegel|home: Nooooo.
05:41:09 <boegel|home> Oejet: no ?
05:41:14 <Oejet> No!
05:41:15 <rafl> Hello.
05:41:23 <Oejet> rafl: Hello, there.
05:41:26 <shapr> ndm: Yeah, definitely.
05:41:34 <boegel|home> yes ,I'm out
05:41:47 <ValarQ> Oejet: the cairo bindings seems to be gone
05:41:48 <rafl> Igloo: Do haskell packages need to be recompiled for the new upstream release you uploaded recently?
05:41:53 <ndm> shapr, in that case its probably best off as a separate project, which hoogle just happens to use
05:41:55 <rafl> Igloo: Or are they binary-compatible?
05:42:27 <Igloo> rafl: Libraries need to be reuploaded, yes
05:42:29 <ndm> so pick any sensible name for it, and shove it somewhere on haskell.org
05:42:40 <ndm> (i am very bad at coming up with names for projects)
05:42:45 <shapr> ndm: Why not put it on hawiki itself?
05:42:54 <ndm> licensing
05:43:00 <shapr> hm, ok
05:43:03 <shapr> good point.
05:43:18 <rafl> Igloo: OK. The dep on ghc6 should look like that, right? ghc6 (>= 6.4.1) ghc6 (<< 6.4.1-999)
05:43:27 <shapr> I keep meaning to freeze the existing wiki and create a new wiki with an explicit CC license.
05:43:39 <ndm> but if there was a haskell wiki with an open license, then going on there would be perfectly fine
05:43:40 <Oejet> ValarQ: http://haskell.org/gtk2hs/gtk2hs-0.9.9.5.tar.gz perhaps?
05:43:57 <ndm> actually, better, because then wikilinks could point at useful topics (i.e. pointfree style for . function)
05:44:19 <ValarQ> Oejet: the cairo bindings doesn't seem to be in that package
05:44:41 <Igloo> rafl: You should use the value of ghc6_lib_bdeps from /usr/lib/haskell-utils/ghc6_vars. If you use update-haskell-control from haskell-utils then it can do the substitution from a debian/control.in for you
05:44:52 <Oejet> ValarQ: Oh, I didn't look. :-)
05:45:57 <Oejet> dcoutts: ping, where did the Cairo binding go?
05:46:05 <rafl> Igloo: Cool, thanks. dh-haskell should use it as well.
05:46:48 <ndm> shapr, any idea when you might get round to hawiki2?
05:46:55 <Igloo> Oh, sorry, that's for the build-dep. For the dep you want ghc6_lib_deps
05:47:09 <rafl> Indeed.
05:47:17 <ndm> actually, i might just start using hawiki, and then when it changes i can worry about licenses etc.
05:47:17 <shapr> ndm: Ask me next weekend, I have a bunch of sysadmin stuff lined up for then.
05:47:46 <ndm> shapr, also how should the links go - maybe hawiki/Funcs/Data.Map.Insert ?
05:48:42 <ValarQ> no luck at http://www.cairographics.org/hscairo either :(
05:48:44 <shapr> ndm: I'd suggest structuring it the same way the libraries are... maybe a Data/Map page and then examples for each function there.
05:49:29 <ValarQ> Oejet: that cairodemo looks really impressive
05:49:47 <ndm> shapr, sounds a good idea, but i would like a Data/Map/insert page as well, so i can direct people straight at their particular function
05:49:58 <ndm> and have Data/Map just be brief overviews of each function
05:50:32 <shapr> hawiki does in-page anchors
05:50:47 <shapr> That way you can send people directly to the function.
05:50:48 <Oejet> ValarQ: Yeah, I'm not that advanced yet.  I'm just playing with Gtk2Hs to visualize a git repository.
05:51:03 <ndm> i'm worried the page might get a bit large, with details on every single function
05:51:13 <ndm> but i guess thats not a massive problem
05:51:16 <shapr> do not worry, if it gets slow or large, solutions will be found.
05:51:27 <shapr> I will find a solution, since I've wanted comprehensive stdlibs docs forever.
05:51:41 <ndm> cool :)
05:51:58 <ndm> shall i put it all under an umbrella folder?
05:52:05 <ndm> i.e. hawiki/Func/Data/Map
05:52:16 <ndm> where Func is a better name :)
05:54:29 <shapr> Yeah, probably a good idea.
05:54:32 * shapr tries to think of a good name
05:54:39 <ndm> thoughts on whats a better name than func...
05:59:59 <shapr> StandardLibraries/ maybe?
06:00:14 <shapr> Any docs you write will likely end up in haddock format in the source.
06:00:29 <ndm> i doubt it
06:00:41 <shapr> I don't, SPJ has asked for more docs for the standard libs.
06:00:49 <shapr> He really wants coverage of every function.
06:00:55 <ndm> i want to give thinks like example source code for the function
06:00:59 <ndm> various examples of using it
06:01:04 <ndm> equivalences
06:01:07 <ndm> properties about them
06:01:22 <genneth> @seen boegel
06:01:23 <lambdabot> boegel is in #haskell-blah and #haskell. Last spoke 1 day, 23 hours,
06:01:23 <lambdabot> 5 minutes and 32 seconds ago.
06:01:28 <ndm> like up to a page on some of the standard functions
06:01:31 <shapr> ndm: I think that'll prove useful.
06:01:43 <ndm> but its probably way too much to put into the source
06:01:52 <shapr> Maybe, but maybe not.
06:01:53 <ndm> you'll end up with so little source left...
06:01:55 <JohnMeacham> I have cabal and darcsized my regex library http://repetae.net/john/computer/haskell/JRegex/  it provides an operator similar to the perl =~ but much superior.
06:02:19 <ndm> i'm not a fan of literate programming, and this would be taking it to the extreme
06:03:09 <JohnMeacham> I am also not a fan of literate programming. I delit everything I take over..
06:03:20 <JohnMeacham> except in the case where you are actually writing a paper.
06:04:24 <Philippa> I don't think I object to it if you're writing a small amount of horribly complicated code
06:04:33 <shapr> I like literate programming.
06:04:42 <genneth> sorry for the intrusion, but can any one get to http://elis.ugent.be/~kehoste/haskell-blahSouthPark.html
06:04:48 <shapr> But I'd prefer a single format that's both web and pdf capable.
06:05:08 <JohnMeacham> I like commenting. I use haddock style comments even when i don't plan to run haddock on things.
06:05:22 <ndm> shapr, that would be great
06:05:23 <fnord123> i hate comments
06:05:33 <fnord123> in my experience they are lies
06:05:33 <ndm> but then you can't really wiki things up, can you?
06:05:39 <shapr> hm?
06:05:40 <JohnMeacham> shapr: what do you mean? you can postprocess literate haskell with whatever tools you want.
06:06:00 <shapr> Haddock is html output, latex .lhs is pdf/ps output. I wish for a single format.
06:06:16 <shapr> genneth: Looks like nothing gets past ugent.be's gateway.
06:06:23 <pesco> shapr: Me too. I have that on the backburner.
06:06:24 <ndm> write a .ps generator for haddock
06:06:39 <JohnMeacham> ah, I like to think of haddock comments as a standard. and other tools than haddock itself will emerge "any day now" to create other output types.
06:06:49 <ndm> or wait for salmon, which will have it built in
06:07:06 <ndm> along with hoogle output, xml output, html output...
06:07:39 <genneth> shapr: indeed; i lost my southpark picture, and so wanted to get it off boegel again...
06:07:39 <shapr> I'd say LibraryDocumentation/ is a good folder name.
06:07:45 <Philippa> I wish haddock were better for internal documentation
06:07:54 <Philippa> it seems to only be good for external/interface docs
06:08:28 <JohnMeacham> I wish it handled recursive modules. and what Philippa says.
06:09:23 <JohnMeacham> Well, I also wish it handled parse errors much more gracefully. it should parse the source and pull out the comments as just text and then parse them seperatly, rather than try to do it all in one wacky happy parser pass.
06:10:29 <Philippa> I find parsers along the lines of "try Foo <|> backupCaseThatJustEatsTheBastard" are pretty much essential for non-programming-language stuff that can't be incredibly picky about everything
06:10:56 <JohnMeacham> Yeah, which is why it would be good to split the source and text parsing passes..
06:10:59 <Philippa> I guess writing a wiki parser gets you used to that kind of thing
06:11:39 <shapr> Oejet: I nearly melted my pan this morning, so I thought of a solution... weight activated burners, where the weight of the pan is not quite enough to turn it on. Then when the water is gone, the burner shuts off.
06:11:39 <shapr> Or maybe timed burners? If you set the burner power timer for twenty minutes for example...
06:11:58 <Philippa> I guess that's the more scalable solution, yeah
06:12:18 <Philippa> can't really do that in Flippi because I've no easy way to spot what the equivalent of a comment is ahead of time
06:12:23 <gaal> ndm: ping
06:12:30 <ndm> gaal: pong
06:12:53 <gaal> got the email - thanks - i hope to get to this tonight (it's a $workday here)
06:13:16 <bourbaki> moin
06:13:45 <ski> melted aluminium pot, fun !
06:13:55 <ndm> cool, by then i should have made some more regression tests in it
06:14:20 <gaal> hmm, come to think of it maybe i should send you the latest version now since it does give well-formed output (to the best of my knowledge)
06:14:58 <ndm> cool, email it over and i'll check it in
06:15:11 <ndm> that way i can check the regression tests a bit more
06:15:50 * shapr decides to hack on his ADSL router a bit...
06:16:32 <gaal> heh heh. "shapr decides to hack is ADS@#%*@!!NO CARRIER"
06:16:49 <gaal> (sent.)
06:17:12 <xerox> ndm: what's the point of redoing haddock in a wiki, by hand?
06:17:50 <ndm> xerox, to add 100 times the information
06:18:00 <ndm> gaal: received, thanks
06:19:05 <xerox> ndm: wouldn't something integrated with haddock be more helpful?
06:19:29 <ndm> xerox: do you want a page of documentation on map in the source code to map?
06:20:36 <gaal> interesting, just the other day i was wondering how hard it would be to hack in a link from haddock to source code.
06:21:13 <gaal> the Perl world has http://www.annocpan.org/ - user-annotatable documentation
06:24:00 <ndm> gaal, your thing seems to generate too few newlines on the regression tests
06:24:17 <ndm> i.e. it runs some functions onto each other, without a line break
06:25:11 <xerox> ndm: what kind of documentation are you thinking about?
06:25:25 <ndm> xerox, take for example map
06:25:32 <ndm> show its definition
06:25:35 <ndm> show some example uses
06:25:49 <gaal> ndm: oops, will investigate.
06:25:49 <ndm> show how it responds on teh corner cases, i.e. (x:xs) and []
06:26:05 <ndm> mention its correspondance with list comprehensions
06:26:26 <ndm> show an example of a function written recursively, that could be replaced with a map
06:26:29 <gaal> (x:xs) is a corner case?
06:26:53 <ndm> when i see a function that takes a list, i want to know what it will  do on a non-empty list, and on an empty list
06:27:28 <ndm> i guess x:xs isn't the corner case though...
06:27:40 <gaal> x may be
06:27:43 <xerox> Do you mean commenting the code?
06:27:55 <bourbaki> HAHA!
06:28:01 <bourbaki> commenting code is for babies
06:28:02 <gaal> eg for folds.
06:28:05 <neologism> bourbaki: :)
06:28:23 <Philippa> ndm: I'd add "on an infinite list" as well
06:28:32 <ndm> Philippa: indeed
06:28:42 <ndm> there is lots of information i want to know
06:28:42 <xerox> I think that completely separated documentation easily becomes unmaintainable.
06:28:53 <ndm> xerox, a wiki would be good
06:28:58 <Philippa> in fact, I'd really really *love* to have strictness annotations in the type system because they're type-relevant info if you allow a "definitely not strict" annotation as well
06:28:58 <ndm> but seperate from the code is bad
06:29:32 <ndm> i would love someone else to do all this documentation thingy :) - and suggestions on how to do it are definately welcome
06:29:40 <Philippa> how about a distributed wiki like what shapr's doing with FLM?
06:29:51 <ndm> i considered that
06:30:03 <ndm> but i'm not sure it brings that much to this thing
06:30:14 <ndm> people would just end up using it like a wiki
06:30:18 <ndm> (plus its not finished...)
06:30:19 <xerox> I think haddock does a very nice work.
06:30:27 <Philippa> it does at least let you take a local copy of everything
06:30:37 <ndm> but you can't put a page of docs on map into the source code
06:30:55 <Philippa> true. It's at least as close as the current documentation though
06:30:55 <xerox> I don't get what's so long to write about map.
06:31:09 <ndm> perhaps if someone extended haddock, to hover up documentation from a side file
06:31:15 <ndm> xerox, thats because you know what map does :)
06:32:24 <xerox> I don't want to appear as a type fetishistic... but aren't code + type annotations + comments enough?
06:32:46 <ndm> map f xs is the list obtained by applying f to each element of xs, i.e.,
06:32:48 <ndm>  map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
06:32:49 <ndm>  map f [x1, x2, ...] == [f x1, f x2, ...]
06:32:57 <ndm> thats the current haddock docuemtnation for map
06:33:00 <ndm> what happens on []
06:33:02 <Philippa> typically I want the docs without having to look at the original source - I don't mind them being in a separate file
06:33:06 <ndm> on an empty list
06:33:09 <xerox> Things like "what's going to happen when you use it on an infinite list" is to teach in a tutorial or something.
06:33:24 <ndm> for map, yes
06:33:29 <Philippa> if nothing else, having both end-user docs and implementor's comments in the same file tends to provide so much reading material it becomes hard for me to follow the actual code
06:33:46 <ndm> but there are a million functions, and i don't know their properties
06:33:49 <Philippa> xerox: no it's not. Tutorials are the last place I want to have to look for simple algebraic properties
06:33:56 <ndm> and in general, to find it, the only place to look is the code
06:34:06 <Philippa> and strictness is a simple algebraic property
06:34:07 <ndm> and that provides an implementation, not the specification
06:34:12 <xerox> Philippa: but the behaviors are really the same every time.
06:34:32 <Philippa> "strict on these parms, non-strict on these parms" would do
06:34:42 <Philippa> (at least, in most cases)
06:34:55 <xerox> Isn't this something you could put in the Haddock comments about the function?
06:35:17 <ndm> i always want a few example executions
06:35:22 <Philippa> yes. We're talking about the sorts of things haddock docs cover
06:35:23 <ndm> esp. of ones that crash it
06:35:26 <xerox> You can put examples in the Haddock docs.
06:35:38 <ndm> but they are't there
06:35:43 <Philippa> (as well as a few they don't, I guess - haddock sucks for "internal" documentation)
06:36:00 <ndm> and if you want an average user to do it, you can't get them to submit a patch to the prelude :)
06:36:01 <xerox> http://haskell.org/~duncan/gtk2hs/docs/Graphics-Rendering-Cairo.html#v%3ArenderWithSimilarSurface
06:36:04 <xerox> Like that.
06:36:34 <ndm> i also want a sample implementation in the documentation
06:36:47 <ndm> possibly several implementations
06:36:54 <xerox> The 'link to the implementation' is something I'd love too.
06:37:12 <xerox> ndm: anyway, I see your point, but I think it would easily become desynched/unmaintainable.
06:37:27 <xerox> @docs Data.Map
06:37:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Map.html
06:37:31 <xerox> @libsrc Data.Map
06:37:32 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Map.hs
06:37:41 <ndm> xerox, i agree it could become hard to keep synced
06:37:50 <ndm> depends - i hope the prelude doesn't change that much ;)
06:37:54 <xerox> Haddock is auto-maintaining
06:38:01 <xerox> More or less :-)
06:38:16 <ndm> i dislike long comments in the source, personal preference i guess
06:38:35 <ndm> anyway, i think there is an agreement that there needs to be more documentation on the standard functions
06:38:54 <xerox> I think not.  But's just me.
06:39:41 <xerox> Did you see the latest pugs slides?  They're so cool.  http://perlcabal.org/~autrijus/tmp/pugs.xul
06:39:49 <ndm> @docs Data.List
06:39:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
06:39:58 <xerox> (click LMB, or press RET, to go forward)
06:40:13 <ndm> what does transpose ["test",""] do?
06:40:30 <xerox> @eval transpose ["test",""]
06:40:31 <lambdabot> ["t","e","s","t"]
06:40:31 <ndm> i can think of at least 3 different possible interpretations
06:40:39 <Philippa> xerox: I have to read the fecking report just to check strictness properties. There need to be better docs
06:40:40 <ndm> yes, but the docs don't say
06:41:28 <xerox> Philippa: i.e. '!' and '~' aren't took in consideration?
06:41:52 <xerox> ndm: you got an interactive environment too, in this cases.. don't you?
06:42:01 <ndm> xerox, yes
06:42:02 <xerox> In the end, you are programming.
06:42:20 <ndm> true, but i'd rather be drinking
06:42:34 <xerox> If the only way was compiling a test case to see the result, I'd agreed with you.
06:42:36 <ndm> and if better documentation cut down programming time, and increased drinking time, i'd say that was a win
06:42:55 <xerox> But if you can type it logging on IRC, or spawning a GHCi, or writing in the forever-opened-one... wee.  :-)
06:43:10 <ndm> and if it cuts down bugs later on because people assumed the wrong thing, that would be very cool
06:43:49 <Philippa> xerox: ie '!' and '~' don't occur in the haddock-generated docs that come with GHC
06:43:57 <Philippa> I could RTFS, sure
06:44:02 <Philippa> but that's every bit as bad
06:44:14 <xerox> Philippa: Yea, agreed.
06:44:32 <xerox> ndm: I think it's very unlikely that something you just assume will straighrforwardly work in an Haskell source.
06:44:44 <xerox> (modulo errors in my english, sorry)
06:45:18 <ndm> i would rather have the right information presented to me easily
06:46:04 <xerox> I still think one can't be easily fooled by assumptions on Haskell code behaviours.
06:46:42 <ndm> you assume, then test
06:46:48 <ndm> if it was documented, you just read
06:46:50 <ndm> which is quicker
06:47:09 <xerox> Maybe... except in code made for Obfuscation Contests :-)
06:47:22 <Philippa> I resent having to solve the halting problem to be sure something isn't strict
06:48:24 <ndm> i actually have a tool that may be able to generate strictness annotations from teh source code...
06:49:18 <xerox> Philippa: is there any technical problem in getting the strictness infos up to the html docs?
06:49:37 <xerox> @seen dcoutts
06:49:38 <lambdabot> dcoutts is in #gentoo-haskell, #haskell and #haskell-blah. I don't
06:49:38 <lambdabot> know when dcoutts last spoke.
06:49:47 <ndm> xerox, it isn't in the code explicitly
06:50:03 <xerox> What do you mean?
06:50:15 <ndm> the haskell compiler does not know if map/reverse is strict or not
06:50:25 <ndm> without doing strictness analysis
06:50:28 <xerox> Hmm, using things like datatypes with '!' fields?
06:50:41 <ndm> yeah, but thats only a very restricted case of strictness
06:50:58 <ndm> there is no way to write reverse and "tell" people its strict
06:51:02 <xerox> '~'-annotated patterns are clearly strict, what else?
06:51:29 <ndm> reverse, last, init
06:51:34 <ndm> all those are tail strict on the list
06:51:44 <ndm> but all only use lazy patterns
06:51:51 <ndm> and lazy data structures
06:54:17 <xerox> Oh, code using seq and $! too.
06:54:34 <xerox> Nobody knows why haddock doesn't do strictness analysis?
06:55:30 <Igloo> Why should it?
06:56:42 <Igloo> Strictness the compiler can infer will depend on the compiler, the optimisation level, and require having all the libraries it uses available
06:57:24 <xerox> Where haddock it's just like a preprocessor
07:12:38 <fnord123> http://mediamatters.org/items/200510140006
07:12:41 <fnord123> har har
07:15:20 <basti_> fnord123: may we help you with something?
07:15:44 <fnord123> oops wrong window
07:18:13 <araujo> @index eval
07:18:14 <lambdabot> bzzt
07:21:12 <xerox> Woot.
07:46:52 <RemiTurk> hi all
07:47:11 <xerox> Howdy RemiTurk
08:19:54 <Julian> Hi
08:20:16 <psi_> hi
08:20:27 <xerox> Hi.
08:21:04 <tomaszz> hi
08:21:10 <basti_> JI
08:21:16 * basti_ blundered
08:21:56 <Oejet> Hi.
08:35:33 <musasabi> evening
08:35:51 <ski> hello musasabi
08:36:16 <xerox> Howdy!
08:37:58 <dcoutts> Oejet, ValarQ, the cairo bindings are currently part of Gtk2Hs. you can get the very latest version with darcs get http://haskell.org/gtk2hs/darcs/gtk2hs/
08:38:28 <dcoutts> Oejet, ValarQ, it includes some demos of the cairo code. Ask xerox for more cairo demo code.
08:38:46 <xerox> dcoutts!
08:38:58 <dcoutts> shapr, xerox, you'll both be jelous....
08:39:03 <xerox> Do you think it's possible to you to do a Win32 build of the latest Gtk2Hs?
08:39:09 * dcoutts is off to play unicycle hockey!
08:39:17 <xerox> Wooooot!
08:39:25 <dcoutts> xerox, yeah, probably some time
08:39:42 <dcoutts> xerox, we hope to do a propper Gtk2Hs release by the end of the month.
08:39:53 <xerox> I'd love to be able to build nymphaea on windows!
08:39:56 <dcoutts> xerox, with win32 installers and everything.
08:40:04 <xerox> I have to show off to real people :-D
08:40:08 <dcoutts> xerox, ah, that might be more tricky
08:40:19 <xerox> I mean, to people in the real world here ;)
08:40:42 <dcoutts> xerox, the people w'eve been using for the Gtk+ installer on win32 have not done a Gtk+ 2.8 version yet.
08:40:55 * xerox sighs
08:41:03 <dcoutts> xerox, we might have to make our own installer from the binaries provided on the gtk site.
08:41:12 <dcoutts> which is an improvement actually
08:41:31 <dcoutts> they now do win32 binaries from the gtk site, though not an isntaller
08:41:53 * dcoutts hopes an installer won't be too hard
08:41:53 <xerox> Ah..
08:42:19 <dcoutts> in fact it't be nice if the Gtk2Hs installer came bindled with Gtk+ itself. It would simplify things for people.
08:42:29 <xerox> Indeed.
08:42:36 <dcoutts> xerox, dons you se win32 at all?
08:42:49 <dcoutts> err dons sorry I wasn't really talking to you.
08:42:55 <xerox> hehe.
08:43:04 <xerox> I do not here.  Just at school, but I have a win32 box.
08:43:33 <dcoutts> "do you use win32 at all" was what I meant. And if so have you tried installing Gtk+ 2.8?
08:43:50 <dcoutts> you can use the official binaries
08:44:02 <xerox> Nope
08:44:10 <dcoutts> but it means having access to a box where you can have some time to fiddle with things
08:44:32 <xerox> This week I'll get my friend's win32 laptop again, so I could try
08:45:00 <dcoutts> to be honnest the only really annoying thing about win32 and gtk is that win32 doesn't have a sane concept of library search paths.
08:45:19 <dcoutts> it's very application-centric so you can't have libs that know where their own deps are.
08:45:31 <araujo> @index popen
08:45:32 <lambdabot> bzzt
08:45:41 <dcoutts> it means when on installs gtk on windows you have to put the gtk bin dir on the windows path
08:45:45 <dcoutts> which is fragile
08:46:00 <goron> Windows fragile? Hmm, sounds right.
08:46:57 <xerox> :-|
08:48:26 <xerox> dcoutts, any thoughts about Visual Haskell interoperability?
08:48:39 <xerox> Apart of a big-letter-no?  :-)
08:51:59 <bourbaki> bk
08:56:52 <JKnecht> A fragile little flower that devoured the world and still has plenty of appetite.
08:57:18 <basti_> uhm, what?
08:58:01 <araujo> Could somebody tell me where it is popen located now?
08:58:20 <xerox> araujo: you can find one implementation of that function in lambdabot sources.
08:58:25 <araujo> mm...
08:58:26 <xerox> @index popen
08:58:27 <lambdabot> bzzt
08:58:39 <araujo> xerox, apparently it is a function available in the Posix module
08:59:14 <araujo> But i get this warning message:
08:59:15 <araujo> Warning: Deprecated use of `popen'
08:59:15 <araujo> 	     (imported from Posix, but defined in POpen):
08:59:15 <araujo> 	     This functionality is now available from System.Process
08:59:28 <Cale`> huh.
08:59:30 <xerox> So it tells where it is now?
08:59:55 <araujo> xerox, mm.. im confused actually, because it doesn't work with that module
09:00:10 <araujo> it only works here with thePosix module, nevertheless with that warning
09:00:11 <xerox> @docs System.Process
09:00:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.Process.html
09:00:41 <araujo> yes, i am there
09:00:45 <araujo> there is no popen
09:01:02 <xerox> Maybe it's suggesting you should use runProcess?
09:01:21 <xerox> (or similar function)
09:01:54 <araujo> Let's see...
09:02:26 <araujo> mm..
09:02:34 <araujo> yeah, probably runInteractiveProcess
09:02:39 * araujo test
09:09:22 <shapr> hoi jyp
09:09:53 <shapr> Check out this nifty email I just got: "Thank you for your interest in our Dance lanugage. Up until now, Dance is still for our internal use only and is under serious modifications right now. However, we are planning to release it in early December this year. I will send you a copy as soon as it's availble."
09:09:54 * xerox waves to jyp and shapr
09:10:16 <jyp> hey folks
09:10:27 <Oejet> Hey, jyp.
09:10:30 <xerox> Danceâ½
09:10:33 <tromp> dance? is that a dialect of danish?
09:10:49 <shapr> heh, dance is a DSL for describing human body positions.
09:10:57 <shapr> @google hudak dance
09:10:58 <lambdabot> http://www.cs.virginia.edu/~sullivan/sdsis/Program/Paul%20Hudak.pdf
09:11:06 <shapr> @google dance hudak labonotation
09:11:07 <lambdabot> http://tunes.org/~nef/logs/haskell/04.03.05
09:11:50 <shapr> I wish that cache google keyword searches would jump to the first word hit immediately.
09:12:06 <shapr> I also wish @google would return a few words above and below the found term(s).
09:12:28 <xerox> It uses the 'feeling lucky' bit.
09:12:44 <xerox> (..and grabs the url from the referred page)
09:15:19 <araujo> xerox, yay, it is that function
09:15:40 <xerox> araujo: good!
09:15:58 <araujo> Just that i need to work with handles, (which is far better) than the ProcessID
09:16:03 <araujo> And Strings
09:16:25 <xerox> So the deprecating was a good move :-)
09:16:36 <araujo> Yeah, it looks like so
09:19:29 <jyp> @seen dons
09:19:30 <lambdabot> dons is in #haskell-blah and #haskell. I don't know when dons last
09:19:30 <lambdabot> spoke.
09:19:46 <dcoutts> xerox, I'm not sure what you mean by VS interoperability
09:20:25 <dcoutts> Cale, btw the answer to your question is that yes, it does all happen server side (so long as your X server has the Render extension)
09:20:34 <Cale> ah
09:21:48 <dcoutts> Cale, in indeed even if it didn't have the Render extension the only bit that would involve round trips would be the drawing of the widgets on top (since they're translucent)
09:21:56 <Cale> yeah
09:21:56 <xerox> dcoutts, the last time I asked, you told me it wouldn't have worked with its GHC, I can understand why, though.
09:22:22 <Cale> cool
09:22:30 <dcoutts> xerox, oh you mean using Gtk2Hs with VH.
09:22:55 <Cale> xerox: nice interrobang
09:23:00 <xerox> ;-)
09:23:08 <xerox> (Though terminus doesn't display it)
09:23:22 <dcoutts> xerox, if you build Gtk2Hs using the version of ghc that comes with VH then yes it should work. The Gtk2Hs win32 installer only works with the specific version(s) of ghc it was built for.
09:23:49 <xerox> Given many people here uses debian: do you know how to rebuild /var/apt/cache/archives/partial ?
09:24:09 <xerox> I thought of freeing some space, but I probably did something wrong in cleaning /var/apt/cache/archives/*
09:24:17 <jyp> @google /var/apt/cache/archives/partial
09:24:19 <lambdabot> http://ftp.ale.org/pub/mirrors/openpkg/sources/SRC/apt/apt.spec
09:24:20 * dcoutts really goes to play unicycle hockey now
09:24:31 <shapr> yay, I just got back from unicycling, w00!
09:24:51 * Cale suggests using apt-get clean or apt-get autoclean in the future :)
09:26:32 <Cale> 1193 upgraded, 114 newly installed, 88 to remove and 12 not upgraded.
09:26:32 <Cale> Need to get 1103MB of archives.
09:26:32 <Cale> After unpacking 79.3MB of additional disk space will be used.
09:26:37 <Cale> geez
09:26:49 <Cale> I should really do that at some point
09:26:54 <xerox> Sob.
09:26:57 <xerox> E: Archive directory /var/cache/apt/archives/partial is missing.
09:27:12 <Cale> maybe just create it
09:27:38 <xerox> It worked O_o
09:27:40 <Cale> it doesn't have anything in it on my system
09:27:52 <xerox> Silly.
09:27:58 <xerox> I'll use clean in the future, thanks :-)
09:29:25 * huinca greeting all
09:29:41 <musasabi> hello huinca
09:29:43 <huinca> I'm not sure if  I'm in the right place to ask this, but...
09:30:08 <huinca> regarding functional programming, anyone has experience in PHP?
09:30:26 * huinca just found some nice issues after 5 years of PHP programming :)
09:30:36 <Cale> uh, PHP isn't exactly a functional programming language :)
09:30:36 <xerox> I don't think PHP does have functions as fist-class values.
09:30:49 <huinca> it has something close... "creat_function"
09:30:50 <xerox> You find yourself still living? :-)
09:30:55 <Cale> but I've (horrors!) used it :)
09:30:58 <huinca> vreate an anonymous (lambda-style) function
09:31:03 <xerox> Woot.
09:31:13 <xerox> @google creat_function site:php.net
09:31:14 <lambdabot> No result found.
09:31:22 <Cale> create
09:31:22 <musasabi> Most php programs seem to pass function names around which is quite repulsive.
09:31:25 <huinca> I know the procedural style and somewhat OO of PHP, that's why I came here to ask
09:31:26 <Cale> http://ca.php.net/create_function
09:31:26 <xerox> @google create_function site:php.net
09:31:27 <lambdabot> http://www.php.net/create_function
09:31:56 <xerox> Hah.
09:32:02 <Cale> ah, that's exactly not like lambda :)
09:32:09 <Cale> it's more like eval
09:32:14 <Cale> in that you're reading a string
09:32:21 <Cale> and compiling that
09:32:22 <huinca> I guess it's far away from pure functional paradigm
09:32:34 <Cale> @eval (\x -> x+1) 4
09:32:39 <huinca> though, it may be possible to program wirth it in mind (like in JavaScript)
09:32:39 <lambdabot> 5
09:33:04 <sylvan> php is, IMO, one of the saddest excuses for a programming language ever...
09:33:09 <Cale> Yeah, Javascript actually does have some functional features (though most of the browsers don't implement them)
09:33:15 <xerox> It has, yeah!
09:33:22 <huinca> Most??
09:33:26 <Cale> yeah
09:33:37 <sylvan> I haven't coded JavaScript since 1995 or something, what's happend since?
09:33:38 <huinca> Humm, I strongly disagre regardin JavaScript.. but I'm working in PHP now :)
09:33:44 <Cale> at least, last time I tried
09:33:56 <huinca> sylvan: search beyondJs
09:34:03 <huinca> @google beyondJs
09:34:05 <lambdabot> http://w3future.com/html/beyondJS/
09:34:37 <Cale> huinca: Perhaps grab GHC (a haskell compiler/interpreter) and try it out :)
09:34:45 <Cale> There are good tutorials around
09:34:46 <huinca> I did it, Cale
09:34:58 <huinca> but where I work we're stuck in PHP for web development
09:35:09 <huinca> I started with Helium, in WIndows
09:35:20 <huinca> ANd I played for months with Haskell :)
09:35:25 <Cale> :)
09:35:57 <huinca> .. then.. I found that Javascript can hendle anonymous functions, and even it was possible to implement currified functions
09:36:05 <huinca> and light comes to my house ;)
09:36:21 <vikasg> curried, you mean :)
09:36:32 * huinca apologizes the bad english
09:36:33 * xerox currifies vikasg 
09:36:49 * huinca spanish native speaker
09:36:53 <ndm> huinca, grab WinHugs
09:37:13 <huinca> Thanks ndm, now I've SuSe
09:37:17 * vikasg hits xerox on the head with a lambda
09:37:33 <xerox> curr!! curr!!
09:37:36 * huinca hears  a monad flying near
09:39:24 <huinca> well.. if you guys don't know how to program PHP in functional ways, then no ones knows for sure.
09:39:43 <huinca> I'll keep with the Old Ways of programmings then :)  Thanks !
09:40:00 <Cale> huinca: I suppose just try not to use mutable state
09:40:07 <Cale> as much as possible
09:40:22 <Cale> which is always good practice
09:40:45 <huinca> "mutable state" is something I don't understand... it's like "weak typed" ?
09:40:48 <vikasg> anybody uses the "Emacs Code Browser"?
09:41:09 <huinca> If so, I always define functions and methods with just one kind of type.
09:41:24 <Cale> huinca: reassigning variables after they're set
09:41:26 <huinca> despite of PHP promiscuity in that regard
09:41:35 <Cale> basically, use constants as much as possible
09:42:03 <Cale> at least then, you can reason about the value of things in a moderately sane way :)
09:42:26 <huinca> :) I'll think about
09:43:50 <araujo> @index forkIO
09:43:51 <lambdabot> Control.Concurrent
09:44:09 <Cale> also, since you can apparently pass functions to other functions, write map and fold and such :)
09:44:29 <Cale> though I'm not so sure that will work too well
09:44:50 <vikasg> I think you can use objects to mimic closures, etc.
09:45:09 <vikasg> (does PHP have overloading?)
09:45:25 <Cale> but it's all quite unweildy
09:46:32 <vikasg> hm, STL-PHP?
09:48:00 <huinca> I saw about overheading in PEAR (a good framework for PHP)
09:48:08 <huinca> Ã§overloading, sorry
09:48:22 <resiak> Ã§-overloading ?
09:48:38 <huinca> Cale: I think I could even try to write some curry function
09:49:04 <huinca> And write a prelude.php just for fun, thoug I doubt it would have good perfomance.
09:52:45 * huinca reads deeply about and now he's pretty convinced that Functional PHP are two very different words.
09:52:45 <xerox> Yow.
09:52:57 <Julian> @eval (((\x -> x x) (\x -> x x)) 5)
09:52:58 <lambdabot>   Occurs check: cannot construct the infinite type: t = t ->
09:52:58 <lambdabot> t1
09:52:58 <lambdabot>   Expected type: t
09:52:58 <lambdabot>   Inferred type: t -> t1
09:53:23 <Julian> lol
09:55:06 <basti_> :/
09:56:55 * resiak idly wonders what that was _meant_ to do
09:57:57 <bergrotf> Is there anything like a messagebox in wxHaskell?
09:59:49 <ndm> looks like someones playing with untyped lambda calculus
10:00:45 <xerox> @lambda (((\x -> x x) (\x -> x x)) 5)
10:00:49 <lambdabot> out of fuel - use @resume to continue
10:01:19 <Julian> yeah
10:01:34 * vikasg kicks lambdabot to get it to start
10:01:42 <Julian> thanks xerox
10:02:00 * xerox hits vikasg back with the lambda
10:02:22 * vikasg ducks behind lambdabot
10:02:38 <Julian> @resume
10:02:41 <lambdabot> out of fuel - use @resume to continue
10:02:48 <jyp> @resume
10:02:52 <lambdabot> out of fuel - use @resume to continue
10:02:55 <xerox> Julian: you're welcome.  @lambda does lambda-calculus interpretation, @eval does Haskell interpretation.
10:03:12 <Julian> thanks
10:03:22 <Julian> ;)
10:03:30 <xerox> ...and @resume increases universe's entropy...
10:03:33 <jyp> @arr
10:03:34 <lambdabot> Shiver me timbers!
10:03:35 <Julian> lol
10:05:07 <Julian> what things actually dont increases the universe's entropy....
10:05:24 <vikasg> the null thing
10:05:31 <Julian> =O
10:06:01 <jyp> fyi, it's not certain the total universe entropy really increases
10:06:23 <jyp> because of its expansion
10:06:30 <Julian> mmmmm
10:06:31 <vikasg> you mean they LIED to me?
10:08:22 <jyp> or they just were ignorant and over-confident in their knowledge
10:08:42 <jyp> which happens all-too-frequently :-)
10:09:56 <Julian> the life of a man... in fuction of the increases of entropy that him cause ;)
10:10:34 <eivuokko> I read university's entropy, in which case null thing might might add entropy after it's mentioned.
10:10:55 <jyp> meets just my views on 'life', Julian
10:11:22 <vikasg> eivuokko, university's entropy?
10:11:37 <Julian> lol
10:11:52 <Julian> university entropy, good measurement
10:12:01 <sieni> eivuokko: so you simultaneously are and are not an anemone?
10:12:29 <eivuokko> Mhm, guess so :o
10:12:51 <basti_> are you talking non-classical logic?
10:13:41 <Julian> A\/ ~ A
10:14:39 <Julian> I cant understand
10:17:58 <EdLin> There's an excellent book called "Godel's Proof" by Nagel and Newman that explains that stuff very well
10:18:58 <Julian> there is a functional programming that support dependent types ?
10:19:08 <jyp> yes
10:19:21 <jyp> Epigram is one of those
10:19:41 <xerox> Perl6 :-)
10:20:46 <Julian> http://www.dur.ac.uk/CARG/epigram/
10:21:00 <xerox> @where pugs
10:21:01 <lambdabot> I know nothing about pugs.
10:21:05 <xerox> !
10:21:13 <xerox> @where+ pugs http://pugscode.org/
10:21:14 <lambdabot> pugs ~> http://pugscode.org/
10:21:19 <jyp> @where epigram
10:21:19 <lambdabot> http://sneezy.cs.nott.ac.uk/epigram/
10:22:17 <Julian> cool
10:25:51 <fnord123> are there structures available in haskell?
10:26:20 <jyp> Are you still around, shapr ?
10:26:36 <jyp> fnord123: yes
10:36:07 <Julian> bye guys
10:36:46 <Julian> c u soon
10:43:21 <fnord123> anyone happen across a timelib for haskell that hides me from the horrors of leap years and such?
10:44:24 <sylvan> Doesn't System.Time do that?
10:45:04 <Igloo> There was a lot of discussion about a replacement on the lists recently, but I don't know what came of it off hand
10:45:31 <fnord123> im reading to see if it will. if its based on UNIX's time_t, wont it die in 2030?
10:45:45 <vikasg> 2038
10:46:54 <fnord123> k
10:47:19 <fnord123> im waiting for it
10:47:28 <fnord123> "thats so far off. who cares?"
10:47:36 <jyp> wont unix time be fixed by then ?
10:48:10 <fnord123> maybe well all be using hyper OS
10:48:45 <sylvan> My god it's silly saving storage space like that... Why not just stor pico-secs since the year 0 or something and use 128 bits? That should be enough for anything for a looooong time
10:49:50 <vikasg> sylvan, I think it's rather because 32 bits are easier to handle
10:49:58 <goron> sylvan: Why not use variable length?
10:50:01 <xerox> They said the same for 32bit :P
10:50:02 <fnord123> build in a time register :)
10:50:03 <fnord123> or two
10:50:54 <fnord123> im writing some finance stuff and there exist bonds > 50 years so its a real issue :P
10:51:04 <sylvan> well 128bits is like 10^19 picosecs
10:51:38 <goron> fnord123: Call PHP :D
10:51:39 <sylvan> I mean 10^19 years, if you store picosecs
10:51:45 <fnord123> ?
10:52:13 <huinca> PHP you said? :s still stucked on it!
10:52:14 <fnord123> sylvan thats a depressingly long time
10:52:29 <fnord123> i dont want to use personal homepage
10:52:47 <goron> fnord123: Then link to some C lib.
10:52:57 <xerox> Make up your own Forever.hs
10:53:00 <goron> Or... implement a webservice :D
10:53:09 <huinca> That's Very Old Stuff.. they changed it to another meaning
10:54:06 <fnord123> erf im on a 64 bit machine. maybe i can last longer :)
11:00:16 <goron> 0:34 77.10% 77.10% darcs
11:00:23 <goron> Is this normal for darcs?
11:00:39 <goron> (i.e. excessive CPU usage)
11:02:28 <fnord123> are there bignums in haskell or are doubles limited to the junky style of doubles youll see in C++ ?
11:02:50 <RemiTurk> Integer...
11:03:23 <RemiTurk> @pugs product [1..100]
11:03:25 <lambdabot> 9332621544394415268169923885626670049071596826438162146859296389521759
11:03:25 <lambdabot> 9993229915608941463976156518286253697920827223758251185210916864000000
11:03:25 <lambdabot> 000000000000000000
11:03:54 <fnord123> ok but i also want decimal places
11:04:01 <sieni> fnord123: doubles are doubles
11:04:07 <fnord123> i guess i could have Integer and a scaling factor :-/
11:04:11 <Lunar^> Rationale
11:04:23 <fnord123> ah. :)
11:04:38 <sieni> fnord123: Haskell has Rational numbers
11:04:38 <gaal> ndm, ping
11:04:45 <RemiTurk> @pugs 1 / 2^100 :: Ratio.Rational
11:04:46 <ndm> gaal, pong
11:04:46 <lambdabot>  Not in scope: type constructor or class `Ratio.Rational'
11:04:52 <RemiTurk> oh well :)
11:04:56 <gaal> hoogle cvs server down?
11:05:18 <Lunar^> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Ratio.html
11:05:34 <ndm> its on sourceforge, so you'd hope not
11:05:37 <ndm> i'll just check
11:05:52 <EdLin> @pugs product [1..100000000]
11:05:56 <lambdabot> Terminated
11:06:00 <ValarQ> :)
11:06:10 <EdLin> so much for bignums. ;-)
11:06:26 <ValarQ> or for big calculations...
11:06:33 <ValarQ> @type (1/2)
11:06:35 <lambdabot> forall a. (Fractional a) => a
11:06:36 <gaal> lambdabot has a @pugs now? how cool!
11:06:41 <ndm> gaal: i can do an update
11:06:49 <gaal> ndm: hmmm.
11:06:50 <ndm> pugs = plugs
11:06:58 <xerox> Hahah.
11:07:03 <ndm> spelt wrong, lambdabot has a spelling correction system
11:07:13 <xerox> @pugs [+] 1..10
11:07:14 <lambdabot>  parse error on input `+'
11:07:16 <xerox> ;-)
11:07:30 <ValarQ> heh
11:07:34 <gaal> it actually could of course, now that pugs is cabalized.
11:08:02 <xerox> !
11:08:12 <xerox> Do it!
11:08:13 <gaal> having lambdabot call pugsy eval via, say, the javascript backend would be very funny.
11:08:36 <gaal> nice idea, i might if i get some time :)
11:09:30 <ndm> gaal: if you still can't get the cvs to update, i'll send you a zip of the test directory for you to be getting on with
11:09:59 <gaal> ndm: whoa, works now.
11:10:09 <gaal> always a good cure, talking to the doctor.
11:10:09 <ndm> cool
11:10:15 <ndm> lol
11:10:35 <ndm> are you on windows?
11:10:38 <gaal> also
11:10:47 <gaal> this is colinux.
11:12:00 <EdLin> what does "plugs" mean?
11:12:13 <gaal> wow, i forgot this is cvs and i needed update -d :)
11:12:16 <xerox> EdLin: it comes from hs-plugins' runplugs.
11:12:19 <ndm> ok, well you'll need to write shell script versions of gen-hihoo
11:12:37 <ndm> and modify runtests.hs to call .sh instead of .bat
11:12:44 <gaal> np :)
11:13:16 <EdLin> xerox: I understand your answer less than the question. :-)
11:13:24 <xerox> @where hs-plugins
11:13:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
11:13:30 <xerox> It comes from there :-)
11:14:36 <musasabi> What would be a good place to look for (functional) priority queues supporting getMin, deleteMin, replaceKeyWithNewPriority, and insert in an efficient fashion?
11:14:46 <EdLin> xerox: (looking at website) looks neat. Sort of like embedding a scripting language, except something more powerful
11:15:11 <xerox> EdLin: I'd suggest to read the paper.  It's very, very powerful - it's Haskell itself!
11:28:38 <wchogg> What's a good paper to read for alot of examples on using monads, more than just IO?
11:29:12 <vikasg> wchogg, Hutton's parsing combinator papers
11:30:28 <wchogg> Thanks, I'll try it.
11:33:47 <ndm> gaal, there are now a couple more tests in the test suite
11:33:57 <ndm> still lacking lots, but should help a bit
11:34:03 <ndm> (and i found a bug in hadhtml)
11:36:11 <gaal> cool. Btw, unix needs case matching
11:36:20 <gaal> so the file should be called Basic.hs
11:36:38 <gaal> i fixed a bug on my end as well.
11:36:54 <ndm> just checking, and neither of the files i commited even compile
11:36:59 <ndm> so fixing that up now
11:37:10 <ndm> will remove the files and readd them, case sensitively
11:37:24 <gaal> what's the .HOO spec say about instances?
11:37:30 <gaal> # instance Show IRCError
11:37:32 <gaal> enough?
11:38:32 <ndm> yeah, thats enough
11:38:39 <gaal> also: does runtests hihoo work for you straight away? i had to copy the script over to the test dir.
11:38:49 <ndm> yeah, i had to do that too
11:39:00 <gaal> can i patch to look in ../../data/hihoo?
11:39:09 <ndm> sure
11:39:13 <gaal> cool.
11:39:21 <ndm> i guess you're using a shell script version, rather than the bat file?
11:40:14 <gaal> yeah, i'l fix both :)
11:41:08 <gaal> fixed
11:43:21 <ndm> gaal: i have recommitted the test suite in upper case
11:43:31 <gaal> thanks
12:10:29 <araujo> @index dup2
12:10:30 <lambdabot> bzzt
12:10:45 <sethk> @yow
12:10:46 <lambdabot> I have a TINY BOWL in my HEAD
12:11:11 <xerox> @arr
12:11:12 <lambdabot> I'd like to drop me anchor in her lagoon
12:12:13 <musasabi> araujo: look under System.Posix.IO (dup and dupTo)
12:12:51 <ndm> gaal: a few more tests as well, that should cover most of the basic ones, if you need anymore just ask
12:13:08 <ndm> or if you find anything for which those tests don't entirely define the spec
12:13:36 <araujo> Thanks musasabi
12:15:43 <gaal> ndm: thank you. did you get the email with my updates?
12:15:54 <gaal> wow sf is slow :(
12:16:50 <ndm> gaal: not in the last 6 hours
12:17:14 <gaal> hmm.
12:17:16 <ndm> i'm hoping to move to darcs at some point in the future, so then it will be off sourceforge, and hopefully easier for people to have access
12:19:15 <gaal> eep! silly gmail bounced the attachment.
12:19:42 <RemiTurk> good night
12:20:03 <gaal> ndm: please d/l two files:
12:20:19 <gaal> http://no.perlcabal.org/~gaal/hihoo.pl    # 0.05
12:20:22 <ndm> yeah, gmail bounces things with .bat in them, its annoying!
12:20:34 <gaal> http://no.perlcabal.org/~gaal/hihoo-updates.zip
12:20:47 <gaal> next time i'll encrypt the attachment :)
12:21:10 <ndm> just rename .zip to .anything
12:21:16 <ndm> and then gmail ignores it
12:21:19 <gaal> fantastic
12:21:30 <gaal> .jar? :)
12:21:30 <ndm> .zap is my favourite currently, i have my zip tools configured for it
12:21:39 <ndm> it may get inside .jar's...
12:21:47 <gaal> .par then! :)
12:21:54 <gaal> .har, even.
12:22:02 <ndm> i wouldn't be entirely surprised if it cracked zip encryption, its not that hard to do...
12:22:25 <gaal> it wouldn't crack AES!
12:23:34 <ndm> no, but the old zip encryption standard is certainly not AES
12:23:55 <gaal> yeah.
12:29:03 <ndm> is there anyway to test if a program is running on windows or linux at runtime?
12:29:26 <sethk> ndm, sure.  if it runs for 5 minutes without crashing, it isn't on windows.  :)
12:29:33 <gaal> in perl you have $^O (p5) or $*OS (p6) :)
12:29:45 <ndm> sethk, my code never dies :)
12:31:18 <ndm> @eval do {x <- getEnv "PATH"; print x}
12:31:19 <lambdabot>  Not in scope: `getEnv'
12:32:41 <Heffalump> ndm: it's not going to let you do IO..
12:32:51 <ndm> boooo :(
12:33:00 <ndm> have ssh'ed into linux and done it now
12:33:21 <ndm> getEnv isn't bad io...
12:36:49 <Itkovian> good evening.
12:38:43 <ndm> gaal, all your changes are commited now - including a new runtests.hs which is linux/windows friendly
12:39:10 <gaal> cool!
12:39:35 <gaal> by the way, if it's any consolation, pugs' evalbot doesn't let you look at the system environment either :)
12:40:36 <ndm> ah well, its done now
12:40:45 <ndm> i assume if the users path starts with a '/'
12:40:49 <ndm> then its running linux
12:40:58 <ndm> or at least, not running windows
12:41:03 <gaal> ha!
12:42:19 <gaal> what do i need to read to hack on lambdabot / run it locally?
12:42:34 <xerox> @version
12:42:35 <lambdabot> lambdabot 3p104, GHC 6.5 (OpenBSD i386)
12:42:35 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:43:03 <xerox> It's very simple.  darcsget it, and customize Config.hs.
12:43:03 <gaal> i built it, when run it looked like it was trying to connect to a real server ;)
12:43:15 <xerox> Yeah, it is a bot.
12:43:23 <gaal> aah, hardcoded strings }:)
12:43:39 <xerox> Hmm.
12:44:02 * gaal can't stay focused on anything
12:44:36 <gaal> harumpf, to hack on it i need a real irc server?
12:44:55 <xerox> You could make it join some #tempchannel
12:45:20 <gaal> yeah, okay.
12:45:35 <z0d> or you can set up your own on your machine
12:46:06 <z0d> I did that some years ago, when I wrote an IRC client
12:53:31 <gaal> zowie. lambdabot *interprets* \-expressions. i thought it sends them off to a Real Compiler<tm> via hs-plugins or something.
12:54:02 <Heffalump> it has two different modes of operation
12:54:03 <gaal> maybe we should just teach it to talk with evalbot on #perl6 :)
12:54:05 <Heffalump> I forget which one is which
12:54:15 <Cale> The real one is @eval
12:54:52 <Cale> The pointfree thing just uses a parsec parser or something like that, and uses rewrite rules
12:54:55 <gaal> @eval help
12:54:56 <lambdabot>  Not in scope: `help'
12:55:03 <Cale> @help eval
12:55:03 <lambdabot>  @eval <expr>
12:55:03 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
12:55:53 <goron> @eval [1..]
12:55:54 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
12:55:54 <lambdabot> 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
12:55:54 <lambdabot> 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
12:55:54 <lambdabot> 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,
12:55:54 <lambdabot> 95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
12:55:56 <lambdabot> 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,
12:55:58 <lambdabot> 130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,
12:56:00 <lambdabot> [24 @more lines]
12:56:08 <goron> Well, that's three seconds...
12:56:15 <xerox> 24, could you believe it?
12:56:30 <goron> Maybe really LONG lines?
12:56:39 <goron> No, I don't believe it :)
12:58:19 <cm> lambdapower!
12:58:20 <Cale> it also cuts off the output after a certain amount, of course :)
13:12:27 <gaal> on my machine, runplugs fails with messages like:
13:12:28 <gaal> Failed: gcc-3.3 -I/tmp -c /tmp/ghc17899.s -o /tmp/MZOQa17898.ogcc-3.3: setNonBlockingFD: invalid argument (Bad file descriptor)
13:12:57 <gaal> anyone know why that might happen?
13:13:09 <TheHunter> which version of ghc are you using?
13:13:47 <gaal> 6.4
13:13:50 <TheHunter> there was a bug in 6.4, and it's been particially fixed in cvs, but I don't know if it made it into 6.4.1.
13:14:10 <gaal> oh, thanks. i'll try upgrading then.
13:14:38 <TheHunter> you'll be safe with current cvs ghcs.
13:14:56 <TheHunter> I don't know about 6.4.1.
13:15:08 <gaal> apt-get update ghc-cvs it is :)
13:15:29 <gaal> s/update/install/
13:16:54 <TheHunter> hmm, 20050331-2, that is probably not "current" enough
13:18:01 <TheHunter> http://sourceforge.net/tracker/index.php?func=detail&aid=1249226&group_id=8032&atid=108032
13:18:16 <TheHunter> you need at least 20050802
13:19:28 <Heffalump> that must be before 6.4.1
13:20:16 <gaal> thanks
13:23:45 <gaal> well, ghc-cvs is uninstallable now on debian anyway :(  (#319812)
17:25:39 <glguy> if I wanted to read a comma delimited line from a file... would it make sense to try and write a version of words that uses commas, or replace all commas with spaces and use words?
17:28:35 <Lemmih> You could make a generalization of 'words'.
17:30:07 <glguy> I'm pretty new, could you be more 'specific' ;)
17:30:26 <glguy> a words that takes two arguments?
17:39:32 <Pseudonym> If I ever need VC funding, I'm definitely talking to these guys:
17:39:34 <Pseudonym> http://ycombinator.com/
17:39:44 <Pseudonym> Simply because they have a cool name.
17:39:58 <Lemmih> VC funding?
17:40:03 <Pseudonym> Venture capital.
17:41:49 <dons> maybe I could get funding for more "YI" hacking!
17:42:38 <glguy> What is the Haskell operator for Not Equal
17:42:45 <Cale>  /=
17:42:46 <glguy> apparently it's not != or ~=
17:42:48 <glguy> ahh,
17:43:24 <Cale> I actually like that a lot more than the other common forms
17:43:50 <Pseudonym> != makes sense if you have ! as an operator, too.
17:44:06 <Cale> or ~= if ~ is not
17:44:06 <Pseudonym> But yes, I like it.
17:44:10 <Pseudonym> True.
17:44:11 <glguy> yeah, I can see why they did it
17:44:16 <glguy> I'm just not used to it yet :)
17:44:49 <Pseudonym> Though != is a little confusing in that you might think it to be the same as *= or +=.
17:45:12 <Pseudonym> Admittedly, ! isn't a binary operator, but still.
17:45:15 <mauke> heh, as in flag!=; ?
17:45:33 <JohnMeacham> ~= feels like 'sort of equals'
17:45:45 <mauke> but then you'd also think a >= b means a = a > b
17:45:59 <Cale> I've used ~= for "isomorphic to" in IRC discussions
17:46:00 <Pseudonym> True.
17:47:01 <Pseudonym> Yes, ~= looks like \cong to me.
17:48:07 <sethk> looks like perl to me  :)
17:48:23 <JohnMeacham> =~ is perl..
17:48:34 <sethk> yes, I know, also python and ruby
17:48:43 <sethk> I believe ruby also has ~=
17:48:47 <sethk> and possibly python as well
17:51:36 <glguy> ERROR "attribs.hs":3 - Instance of Num (IO [String]) required for definition of getAttribs  : is this telling me that the function I defined doesn't match the type i defined it as?
17:52:08 <mauke> what is line 3?
17:52:21 <glguy> lines 2 and 3
17:52:21 <glguy> getAttribs n
17:52:21 <glguy>    | n > 0 = do
17:52:39 <sethk> name clash, I think
17:52:54 <JohnMeacham> And haskell now too :)
17:52:56 <glguy> getAttribs already exists?
17:52:59 <mauke> what is line 1?
17:53:08 <glguy> getAttribs :: Int -> IO [String]
17:53:23 <mauke> weird
17:53:27 <Cale> can we see the rest of the definition of getAttribs?
17:53:33 <glguy> yeah
17:53:37 <glguy> what's the flood limit
17:53:43 <Cale> it's saying you're using an IO [String] like a number somewhere
17:53:43 <sethk> glguy, 1
17:53:50 <mauke> use a paste site
17:53:55 <glguy> bah, my hawiki account isn't working, hold please :)
17:54:08 <Cale> if it's only a few lines it's okay
17:54:18 <Cale> like 5 or so, I'd think
17:54:20 <sethk> glguy, I wasn't being serious
17:54:41 <glguy> getAttribs :: Int -> IO [String]
17:54:41 <glguy> getAttribs n
17:54:41 <glguy>    | n > 0 = do
17:54:41 <glguy>         line <- getLine
17:54:41 <glguy>         rest <- getAttribs n - 1
17:54:44 <glguy>         return $ [ a | a <- line, a /= ',' ] : rest
17:54:46 <glguy>    | otherwise = return []
17:54:46 <Cale> ah
17:54:49 <mauke> ah
17:54:50 <Cale> right there :)
17:54:56 <Cale> getAttribs n - 1
17:55:02 <Cale> getAttribs (n - 1) ?
17:55:02 <glguy> oh, missing $
17:55:05 <glguy> yeah
17:55:36 <glguy> bah, okay, thanks :)
17:55:44 <Cale> The type system caught a syntax error :)
17:55:47 <Cale> heh
17:55:55 <Cale> well, not quite
17:55:57 <glguy> I keep thinking that operators have some magic precedence
17:56:11 <Cale> dwim precedence? :)
17:56:28 <Cale> the thing to remember is that function application has higher precedence than anything else
17:56:39 <Cale> even if it's not type correct
18:04:17 <glguy> Hmm... is there a library function for checking if all elements in a list are equal? or should I just test the length $ nub mylist
18:04:59 <Heffalump> and $ zipWith (==) list (tail list)
18:05:20 <dons> @type all
18:05:33 * dons can't remember quite the defn of all
18:05:33 <Heffalump> dons: won't help here. I do know about it :-)
18:05:43 <Heffalump> all f xs = and (map f xs)
18:06:08 <dons> now, lambdabot, what are you doing?
18:06:25 <dons> @bot
18:06:27 <mbot> dons: Null
18:06:34 <glguy> okay, so how do I use all...
18:06:39 <dons> mbot, hello
18:07:06 <glguy> I'm looking at the definition in Prelude.hs
18:07:07 <Heffalump> you don't. You use the expression I gave.
18:07:11 <glguy> ah
18:07:23 <Heffalump> but it's not quite right, cos zipWith doesn't do what I hoped it would if the first list is empty.
18:07:23 <Cale> If you know that the list is nonempty, you could do this:
18:07:26 <Cale> @eval (\xs -> all (== (head xs)) xs) [1,1,1,1,1]
18:07:27 <dons> Heffalump is very insistent at times ;)
18:07:29 <mbot> Cale: True
18:07:34 <Cale> @eval (\xs -> all (== (head xs)) xs) [1,1,1,1,2]
18:07:36 <mbot> Cale: False
18:07:37 <dons> mbot is ood
18:07:40 <dons> odd
18:07:55 <Heffalump> oh, yes, what Cale said would work too, but has the same problem with empty lists as mine.
18:08:07 <Heffalump> oh, no it doesn't.
18:08:19 <Cale> er, yeah
18:08:20 <Heffalump> @evel (\xs -> all (== head xs) xs) []
18:08:22 <mbot> Heffalump:
18:08:22 <mbot> <Plugins.Eval>:1:31:
18:08:22 <mbot>   Ambiguous type variable `a' in the constraint:
18:08:22 <mbot>   `Eq a' arising from use of `=='
18:08:34 <Heffalump> @eval (\xs -> all (== head xs) xs) ([] :: [Int])
18:08:35 <mbot> Heffalump: True
18:08:39 <Heffalump> cunning.
18:08:45 <Cale> @eval (\list -> and $ zipWith (==) list (tail list)) []
18:08:46 <mbot> Cale:
18:08:46 <mbot> <Plugins.Eval>:1:42:
18:08:46 <mbot>   Ambiguous type variable `a' in the constraint:
18:08:46 <mbot>   `Eq a' arising from use of `=='
18:08:54 <dons> who's running mbot?
18:08:57 <Cale> me
18:08:58 <Heffalump> mine will break, if zipWith is defined in the same was as it is in the report.
18:09:07 <Cale> @eval (\list -> and $ zipWith (==) list (tail list)) ([] :: Int)
18:09:08 <mbot> Cale: Couldn't match `Int' against `[a]'
18:09:11 <Heffalump> @eval (\list -> and $ zipWith (==) list (tail list)) ([] :: [Int])
18:09:12 <mbot> Heffalump: True
18:09:15 <Cale> yeah
18:09:17 <dons> Cale, I think you need to install the latest runplugs from the scripts/ dir
18:09:30 <dons> and the latest Plugins/Plugs.hs
18:09:31 <Cale> zipWith chops the shorter list
18:09:32 <Heffalump> but maybe zipWith isn't defined that way. Whereas I can't see any definition of all that would cause a problem with empty lists.
18:09:37 <Cale> to the shorter list
18:09:39 <dons> you should get far less noisy errors
18:09:57 <Heffalump> cale: yes, but according to the report, it inspects both its arguments for non-emptiness simultaneously
18:10:14 <dons> is mbot a lambdabot? or does it contain custom Cale-hacks?
18:10:16 <Heffalump> so (tail list) is going to be an error if list is empty, and the error will be inspected
18:10:23 <Heffalump> @version
18:10:24 <mbot> lambdabot 3p96, GHC 6.4 (Linux i686)
18:10:24 <mbot> darcs get http://www.scannedinavian.org/repos/lambdabot
18:10:26 <Cale> It's a lambdabot with some Cale-hacks :)
18:10:43 <Heffalump> does lambdabot read _darcs/prefs/defaultrepo when building itself?
18:10:50 <Cale> @math Solve[ a x^2 + b x + c == 0, x]
18:10:51 <mbot> Cale: {{x -> (-b - Sqrt[b^2 - 4*a*c])/(2*a)}, {x -> (-b + Sqrt[b^2 - 4*a*c])/(
18:10:51 <mbot> 2*a)}}
18:10:52 <dons> ah, you're about 8 patches behind
18:11:07 <dons> Heffalump, during configuration, yes :)
18:11:08 <Cale> that's quite possible
18:11:14 <Heffalump> dons: eeeevil :-)
18:11:24 <dons> nah, fun :)
18:11:34 <Cale> @math Integrate[Cos[Sqrt[x]],x]
18:11:35 <mbot> Cale: 2*Cos[Sqrt[x]] + 2*Sqrt[x]*Sin[Sqrt[x]]
18:11:44 <Cale> @math Integrate[Sqrt[Cos[x]],x]
18:11:45 <mbot> Cale: 2*EllipticE[x/2, 2]
18:11:49 <dons> ah!
18:12:04 * dons think Cale should submit @math back to lambdabot
18:12:21 <Cale> well, I could, but it's not very useful without a copy of mathematica
18:12:40 <dons> oh, hmm. now, I think I have a copy floating around somewhere ...
18:12:41 <dons> let me see.
18:13:24 <dons> or it could just use the http module to talk to Cale's version of mathematica..
18:13:28 <dons> hehe
18:13:39 <Cale> It's basically gutted-out @plugs with a shell script :)
18:14:06 <Cale> or it could ask mbot in private chat and read the reply back :)
18:14:18 <dons> pill00$ mathematica
18:14:19 <dons> zsh: permission denied: mathematica
18:14:19 <dons> bah
18:14:22 <Pseudonym> http://integrals.wolfram.com/
18:14:28 <Pseudonym> You could do some kind of link to that.
18:14:33 <Pseudonym> If you just want integrals.
18:15:57 <Cale> odd
18:16:21 <Cale> does anyone know which locale X (in particular Xorg) uses when determining which Compose file to use?
18:16:46 <Cale> All of the ones I'm aware of are set to en_US.UTF-8, but it's not using that file
18:19:01 <dons> lambdabot: @version
18:19:02 <lambdabot> lambdabot 3p104, GHC 6.5 (OpenBSD i386)
18:19:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:20:01 <JohnMeacham> Are there any normal-order scheme/lisp like languages? as in non-toy or turing tarpit ones?
18:20:19 <dons> @eval (\xs -> all (== head xs) xs) []
18:20:21 <lambdabot>  add a type signature that fixes these type variable(s)
18:20:45 <dons> I like @eval's brevity
18:21:07 <Pseudonym> That reminds me of a Prolog system that I once used.
18:21:37 <Pseudonym> Any syntax-related error induced the message: "Your program contains one or more syntax errors."
18:21:40 <Cale> It's broken... somehow. Fix it.
18:21:59 <mauke> http://www.gnu.org/fun/jokes/ed.msg.html
18:26:52 <stepcut> so, I want to parse an .html (xhtml) file and output a .hs file that uses Text.Html to render the page. I don't think I want TH, because I want to hand tweak the .hs after it is generated before it is compiled.
18:27:12 <stepcut> Should I use Language.Haskell.Syntax, or is there a better way ?
18:27:37 <stepcut> (I will be using HXT for the .html parsing)
18:29:35 <dons> stepcut: add your details :) http://haskell.org/hawiki/HaskellUserLocations
18:30:10 <Cale> stepcut: that seems sensible, together with Language.Haskell.Pretty
18:30:20 <Cale> but a little bit roundabout...
18:30:39 <Cale> why not read the HTML as data at runtime?
18:30:49 * stepcut ponders
18:32:30 <dons> Langugage.Haskell is the usual way
18:35:41 <stepcut> Cale: I think that could work -- I would need to rewrite the .html a bit on-the-fly, but it should be very programmatic
18:36:06 <Cale> You could even use extra XML tags to mark the places which need extending/changing :)
18:36:23 <stepcut> Cale: the only danger is the .html getting too far out of sync with the code
18:36:36 <stepcut> but I can just be careful :p
18:36:53 <Cale> well, you should definitely use further tags then
18:38:43 <stepcut> Cale: Not sure if that would help -- it is for form processing, so I need to modify databases and SQL queries if the form changes.
18:44:25 <stepcut> dons: do I have to remember my wiki password to edit the page ?
18:45:28 <dons> stepcut, these days yes. your other option is to /msg me your coords, and I'll add them
18:45:49 <dons> @seen jyp
18:45:50 <lambdabot> Last time I saw jyp was when I left #haskell and #haskell-blah 8
18:45:50 <lambdabot> days, 22 hours, 25 minutes and 28 seconds ago, and I have missed 8
18:45:50 <lambdabot> days, 21 hours, 58 minutes and 4 seconds since then.
18:46:04 <dons> lambdabot you silly thing
18:46:34 <dons> @todo-add there's some bug in the 'when i left' code of @seen
18:46:35 <lambdabot> Entry added to the todo list
18:47:30 <stepcut> dons: ah, so then I have to remember my irc password :p
18:47:53 <dons> :p
18:54:01 <sethk> stepcut, it will email it to you
18:54:01 <Pseudonym> Gotta go.  BBL
18:54:28 <stepcut> sethk: the wiki or irc ?
18:54:45 <sethk> the wiki
18:54:52 <sethk> possibly irc, but I don't know.  :)
18:55:02 <stepcut> sethk: do I have to remember the name I used? Or just the email I used ?
18:55:37 <sethk> stepcut, on the wiki, I think the name
18:55:44 <sethk> stepcut, it tells you to use FirstnameLastname
18:55:49 <sethk> stepcut, which is I'm sure what you did
18:56:25 <stepcut> sethk: cool -- I have meaning to recover my pw so I can write, 'Calling C++ from Haskell -- the hard way'
18:56:37 <sethk> :)
18:56:50 <SyntaxNinja> does anyone want to be my netflix friend?
18:57:02 <dons> hey SyntaxNinja!
18:57:11 <dons> add your details! http://haskell.org/hawiki/HaskellUserLocations
18:57:40 <metaperl> SyntaxNinja: me: metaperl@gmail.com
18:58:31 <SyntaxNinja> metaperl: do you have good taste in movies?
18:58:33 <SyntaxNinja> hi dons
18:58:59 <metaperl> SyntaxNinja: no. I dont watch too many movies... I liked Scary Movie 1-3
18:59:08 <metaperl> I like James Bond, Sherlock Holmes
18:59:12 <metaperl> COlumbo
18:59:21 <metaperl> mystery, detective, comedy, horror
18:59:44 <SyntaxNinja> although now I guess I"m goign to have to start thinking about what people will think whne I rent movies.
19:00:20 <stepcut> I got netflixs a month or so ago, but I have only had time to watch 1 movie...
19:01:33 <sethk> @yow
19:01:34 <lambdabot> You can't hurt me!!  I have an ASSUMABLE MORTGAGE!!
19:01:52 <SyntaxNinja> dons: it says its immutable; how do I edit it?
19:02:09 <SyntaxNinja> columbo is funny
19:02:12 <dons> ah, you either login (click on UserPreferences) or /msg me the coords
19:02:13 <stepcut> unsafeEditWiki
19:02:29 <Lemmih> heh (:
19:02:36 <stepcut> Lemmih: !
19:02:43 <metaperl> Columbo is the greatest
19:02:54 <stepcut> Lemmih: can I ask you a few questions about hacanon ?
19:03:00 <dons> Julian: hi! you might like to add to the http://haskell.org/hawiki/HaskellUserLocations :)
19:03:09 <dons> there's quite a few people from .ar it seems
19:03:12 <Lemmih> stepcut: Sure.
19:03:39 <stepcut> Lemmih: why does it need to generate c++ code ?
19:03:56 <Lunar^> Igloo: if I understand correctly, #334110 is because of hugs dependency to libreadline4, right?
19:04:37 <SyntaxNinja> great. I'm supposed to work tonight, and I get a host key change error trying to ssh in :(
19:05:08 <Lemmih> stepcut: To get around the C++ mangler.
19:05:40 <stepcut> Lemmih: so you generate C++ code with extern "C" or something ?
19:05:48 <SyntaxNinja> oh, so lambdabot counts?
19:05:48 <Lemmih> Yeah.
19:06:16 <Lunar^> Igloo: or is it only a matter of doing a the manual bootstrap to close the bug?
19:06:53 <stepcut> Lemmih: If you added that gcc-xml stuff, then you would just use the mangled names ?
19:07:29 <Lemmih> The mangled names aren't valid C names.
19:08:35 <Lemmih> I can't avoid generating C code since some of the marshalling is done there.
19:08:37 <stepcut> Lemmih: in my limited experiments, I have been able to call them fine with the haskell FFI, should I expect that to fail in some cases ?
19:08:49 <dons> of course lambdabot counts ;)
19:09:22 <SyntaxNinja> lambdabot: you count.
19:09:34 <dons> lambdabot must be one of the most widely travelled #haskell citizens, having moved from the furthest south to the furthest north locations on our map
19:09:43 <dons> and back to nearly the furthest south again
19:09:44 <SyntaxNinja> heh
19:10:16 <SyntaxNinja> <-- has been further north than shapr's location, and lives pretty far west
19:10:53 <Lemmih> stepcut: Hm, the mangled names may be OK in C. I don't know enough about C++ to be sure.
19:11:08 <stepcut> Lemmih: also, do you think the approach you have started is still a good way to do things?
19:12:12 <Lemmih> Hacanon is broken but the idea is sound, IMHO.
19:12:14 <stepcut> Lemmih: I noticed development stopped -- wasn't sure if that was do to lack of interest, or a deeper realization
19:12:19 <dons> ah ha! parallelizing the map generation script leads to a reduction from 21 minutes to 3mins 55s to regenerate all the maps :D
19:12:29 <sethk> that's dramatic
19:12:46 <dons> still uses multi-gigabytes of ram, but heh, what can you do ? :)
19:12:51 <Lemmih> stepcut: I lost interest in the C++ library I wanted to bind.
19:13:04 <stepcut> Lemmih: I figured something like that happened :)
19:13:25 <SyntaxNinja> dons: the wiki map took 21 minutes to generate?!
19:13:27 <stepcut> Lemmih: I am (for the time being) interested in making some partial bindings to KDE, do you have any advice ?
19:13:36 <dons> SyntaxNinja, all 5 maps, yep.
19:14:01 <dons> the underlying map is a 200M .tif provided by nasa, and xplanet really takes some time to do the various projections we make
19:14:36 <dons> now I distribute each image on a different node of a cluster, with a lovely speedup
19:15:09 <Lemmih> stepcut: Fixing Hacanon would be a major undertaking so I guess you're better off with the normal FFI tools.
19:15:14 <SyntaxNinja> sweet
19:17:08 <stepcut> Lemmih: sounds good -- for now I am just doing everything 'the hard way' until I figure out a reasonable system for calling C++ from haskell
19:18:01 <stepcut> Lemmih: I am not really sure what to do about all those methods with the same name but differing number and type of arguments, for example
19:18:28 <SyntaxNinja> stepcut: are you writing a pluggin architecture to apt for Haskell?
19:18:35 <SyntaxNinja> that would be totally tubular.
19:18:46 <stepcut> SyntaxNinja: ??
19:18:50 <SyntaxNinja> is apt like, the only thing written in C++?
19:19:03 <stepcut> SyntaxNinja: KDE is also written in C++
19:19:10 <SyntaxNinja> stepcut: I'm just making fun... though it would be cool if you were working on apt.
19:19:14 <Lemmih> stepcut: Hacanon uses overloaded tuples as arguments.
19:19:27 <stepcut> SyntaxNinja: I am working on a native apt replacement in haskell
19:19:46 <stepcut> Lemmih: I will have to look into how that works
19:20:28 <SyntaxNinja> stepcut: really? native to linspire you mean?
19:21:02 <stepcut> SyntaxNinja: well, we *really* need a more generalized dependency checking engine -- once that is in place, the rest is pretty easy
19:21:18 <stepcut> SyntaxNinja: native as in pure haskell
19:21:22 <SyntaxNinja> stepcut: you should base it on cabal :P
19:21:51 <stepcut> SyntaxNinja: so far I just have a hacked up 'dql' program, which a sql like database that uses debian control files for tables
19:21:55 <SyntaxNinja> stepcut: this is for linspire?
19:23:00 <stepcut> so you can do stuff like, select Package, status.Version, other.Version from /var/lib/dpkg/status as status , /some/other/Packages_file as other where status.Package == other.Package;
19:23:25 <dons> hello moomlyn, learning haskell?
19:23:31 <stepcut> SyntaxNinja: well, I do it on company time -- so I don't actually get to work on it often, but it is supposed to elevate in priority next month
19:23:53 <SyntaxNinja> stepcut: this is a general-purpose tool, not for Haskell, right?
19:24:01 <SyntaxNinja> stepcut: will it be open source?
19:24:09 <glguy> I'm trying to read lines until EOF... how do I check hIsEOF, and then read a line or return [] depending on EOF or not... I'm trying to figure out how to use 'if' or 'case'... or something else
19:24:13 <glguy> inside the do block..
19:24:15 <glguy> any ideas?
19:24:36 <mauke> why don't you read all lines at once?
19:24:48 <glguy> yeah, why don't i do that :)
19:24:50 <glguy> okay, sounds good
19:24:55 <stepcut> SyntaxNinja: (1) dql is a command-line tool like modelled on the mysql command-line interface (2) i think it has to be GPL because it is linked against libreadline :p
19:25:12 <glguy> hGetContents, eh?
19:25:17 <SyntaxNinja> stepcut: I'm very curious. got a white paper or anything?
19:25:39 <stepcut> SyntaxNinja: the general purpose library will be written in haskell, but will have C bindings so that it can be called from perl, C++, and other languages used around the office
19:25:40 <mauke> yes, and lines
19:25:48 <dons> SyntaxNinja, is the code for the SyntaxNinjaFS in darcs somewhere?
19:25:56 <stepcut> SyntaxNinja: no whitepaper yet -- but hopefully once I get something really working
19:26:09 <SyntaxNinja> dons: not released opensource yet :(
19:26:27 <SyntaxNinja> but it might be within a few weeks. it's just a matter of getting enough time to make the release!
19:26:33 <dons> ah, ok great!
19:26:48 <SyntaxNinja> the good news is that galois is going to be giving me hours to work on haskell community stuff now :) :)
19:26:58 <stepcut> SyntaxNinja: sweet!
19:26:58 <dons> oh, that is great news!
19:27:07 <Lemmih> nice.
19:27:16 <SyntaxNinja> well, for me anyway, maybe not for the rest of the haskell community ;)
19:27:31 <SyntaxNinja> (even more isaac-inspired haskell mailing list flame-wars anyone?!)
19:27:49 <dons> hehe
19:28:55 <SyntaxNinja> actually, it's funny because it's true. I think part of my work will be in coordinating stuff w/ the industrial haskell standard, and I'm sure it's going to generate lots of mailing list traffic. maybe even more than cabal does on the libraries list.
19:29:14 <dons> yep, i expect so
19:29:43 <SyntaxNinja> considering what happened when I dipped my toe in to ask who raised their hand at HW
19:29:56 <dons> considering the amount of traffic on the topic in the last few days..
19:33:49 * Lunar^ praises HWN! :
19:33:51 <Lunar^> :)
19:34:12 <dons> hi Lunar^!
19:34:28 <Lunar^> hi dons :)
19:34:43 <SyntaxNinja> bbiab
19:34:57 <Lunar^> I'm falling asleep though... :)
19:36:15 <dons> reminds me to implement @timefor
19:36:36 * Lemmih grabs his unicycle and rides off in the night.
19:36:44 <dons> ciao Lemmih!
19:41:13 <glguy> parseCovering xs = filter isDigit (tail $ words $ replace ';' ' ' xs) : ERROR, undefined variable isDigit ... ?
19:42:13 <glguy> any ideas?
19:42:18 <glguy> isn't that in Prelude
19:42:21 <mauke> import Char (isDigit)
19:43:23 <glguy> perfect, thanks
20:30:03 <sethk> Hello, all.  I just updated the HaskellIrcPastePage.  I added my question/info at the beginning.  If folks are willing to take a look at it, I will be most appreciative.
20:37:30 <sethk> is this possibly a case for the RWS monad?
20:55:11 <Lemmih> sethk: Looking for StateT?
20:57:01 <sethk> Lemmih, I'm not sure.  I have the same questions about using StateT that I have with using State
20:57:17 <sethk> so I need to figure out the major question first, then figure out which is the best monad variety.  :)
20:59:33 <Lemmih> Isn't 'StateT (Map FilePath Handle) IO' what you want?
20:59:59 <sethk> it may be, I'm not sure.
21:00:14 <sethk> I don't see any way to use it to do what I want.
21:01:17 <Lemmih> A function of that type would be able to modify the state and use IO actions.
21:01:33 <sethk> yes, but I don't see how I could get there from a main
21:02:05 <Lemmih> @type Control.Monad.State.runStateT
21:02:09 <lambdabot> forall s a (m :: * -> *).
21:02:09 <lambdabot> Control.Monad.State.StateT s m a -> s -> m (a, s)
21:02:16 <sethk> Lemmih, I know the types.  the types are in the docs
21:02:26 <sethk> if the types helped, I wouldn't have to ask any questions
21:02:34 <Lemmih> Then what's the problem?
21:02:46 <sethk> I see nothing in the type that tells me how to do what I want.
21:02:58 <sethk> I'm in a main.  I don't have an IO monad to stuff into a StateT monad
21:03:18 <sethk> I see no way to get any data into a StateT monad
21:03:29 <sethk> I realize that I don't understand it, but that realization doesn't help at all
21:03:42 <Lemmih> The second argument to 'runStateT' is the initial state.
21:03:57 <sethk> I don't see how that helps
21:04:27 <sethk> also, I have runStateT :: (s -> m(a,s))
21:04:34 <sethk> so the only thing I supply to that is one argument, s
21:04:48 <sethk> so there is no second argument
21:05:28 <sethk> where do you see a runStateT with two arguments?
21:05:45 <Lemmih> Try this: main = print =<< execStateT (do n <- get; put (n+1)) 1
21:06:19 <sethk> I don't see anything there we've talked about so far.  But ignoring that, what does that do for me?
21:06:29 <sethk> I don't want to create a value within execStateT and modify it
21:06:37 <sethk> I know how to do that, but it doesn't get me anywhere
21:07:21 <Lemmih> I don't understand what you want then.
21:07:31 <sethk> what good does that example do me?
21:07:42 <sethk> It tells me how to use get and set within runWhatever ()
21:07:48 <sethk> I already know that, I just don't see how it helps.
21:07:56 <sethk> let's take a specific problem, the one I outlined
21:08:16 <sethk> I want to create a file, which returns a file handle, and put that file handle into a Data.Map with the filename as the key
21:08:26 <sethk> then I want to keep that map around and use it whenever I open a file
21:08:38 <sethk> just give me an outline of how to start doing something like that.
21:08:56 <Lemmih> You want to use StateT.
21:09:14 <sethk> ok, to use StateT, I use runStateT.  runStateT has the following signature:
21:09:20 <sethk> runStateT :: (s -> m (a, s))	
21:09:26 <Lemmih> No, it doesn't.
21:09:30 <sethk> which means I can pass a single argument, s, to runStateT
21:09:36 <sethk> that's pasted from the library reference
21:09:36 <Lemmih> @type Control.Monad.State.runStateT
21:09:38 <lambdabot> forall s a (m :: * -> *).
21:09:38 <lambdabot> Control.Monad.State.StateT s m a -> s -> m (a, s)
21:09:57 <sethk> then why does the library reference have the type I pasted?
21:10:08 <sethk> and do I have to assume that everything in the library docs is wrong?
21:10:28 <Lemmih> sethk: Read up on data fields.
21:10:31 <sethk> ghci gives me the same type you just did
21:10:42 <sethk> you didn't answer my question
21:10:46 <sethk> I understand data fields perfectly
21:10:58 <sethk> but the type of runStateT has absolutely nothing to do with data fields
21:11:23 <sethk> are all the monad types wrong in the docs?  That would explain a lot of my confusion
21:11:37 <Lemmih> sethk: Try this: 'data T = Tc { n :: Int }'
21:11:43 <Lemmih> sethk: What's the type of 'n'?
21:12:19 <sethk> well, if it were Int I assume you wouldn't be asking  :)
21:12:27 <Lemmih> 'n' is a function which unwraps the first argument of 'Tc' in 'T'.
21:12:43 <Lemmih> What means that the type of 'n' must be: 'T -> Int'.
21:12:48 <Lemmih> s/What/That/
21:12:59 <sethk> what does that have to do with monads and the types of the runWhatever functions?
21:13:16 <Lemmih> It explains the type of 'runStateT'.
21:13:56 <sethk> It doesn't explain why :t (in ghci) or @type in lambdabot gives the same type as the docs for almost everything, but not for State or StateT
21:14:19 <sethk> there is no data statement in StateT   the type is defined with newtype
21:14:34 <Lemmih> Same thing (almost).
21:14:43 <Lemmih> The difference is not important in this case.
21:14:50 <sethk> You missed the point
21:14:52 <Lemmih> (it's a performance issue)
21:15:03 <sethk> why is the type in the documentation different than the type shown by ghci?
21:15:16 <Lemmih> Try this: 'newtype T = Tc { n :: Int}'. What's the type of 'n'?
21:15:36 <sethk> why don't you tell me what you are trying to say, instead of being oblique
21:15:40 <Cale> hint: it's not Int
21:15:44 <sethk> obviously
21:15:46 <Lemmih> 'n' is a function which unwraps the first argument of 'Tc' in 'T'.
21:15:48 <Cale> It's T -> Int
21:15:51 <Lemmih> What means that the type of 'n' must be: 'T -> Int'.
21:15:58 <Lemmih> s/What/That/
21:16:00 <sethk> what does that have to do with the State or StateT monad?
21:16:16 <sethk> what does that have to do with the docs showing a different type than the programs for runState and runStateT?
21:16:33 <Lemmih> sethk: Do you understand that type of 'n'?
21:17:01 <sethk> you just told me the type of n.  I'm hoping you will tell me what you are trying to say.
21:17:22 <Lemmih> I'm trying to explain Haskell's record system to you.
21:17:28 <sethk> I'm not a student and I don't have time for games
21:17:40 <Lemmih> You really need to understand this.
21:17:43 <sethk> Don't explain the type system to me, tell me specifically whatever it is that you are trying to say
21:17:51 <sethk> you really need to put it into context
21:18:03 <sethk> and nobody is answering either of my questions about the types of runState and runStateT
21:18:20 <Cale> sethk: he is answering you indirectly by using a simpler type
21:18:23 <sethk> It isn't that I don't understand the type you gave for runStateT
21:18:34 <sethk> Cale, please don't answer indirectly by using a simpler type
21:18:46 <sethk> please tell me why the type in the docs is different than the type shown by ghci
21:18:57 <Cale> The docs give the type which one would use when declaring runState as a field of State
21:19:08 <Cale> They list:
21:19:12 <Cale> Constructors
21:19:14 <Cale>   State
21:19:17 <sethk> ok.  when would one declare runState as a field of State?
21:19:23 <Cale>     runState :: (s -> (a, s))
21:19:49 <Cale> the fact that it is really a function State s a -> (s -> (a, s)) is implied
21:20:06 <Cale> (by the fact that it's a field of a record)
21:20:37 <sethk> I don't see what is gained by not showing the function in the docs with the type that it actually has
21:20:52 <sethk> if it is both a function and something else, with the same name, why not say so?
21:21:02 <Cale> It's showing the type of the field, not the type of the extracting function, which has the same name
21:21:19 <sethk> yes, and that is incredibly confusing, especially since the function is NEVER MENTIONED
21:21:29 <sethk> ugh.
21:21:33 <Cale> This is just something which is part of the syntax for records
21:21:55 <sethk> I know, but using the same name for different things, which occurs in many places, not just here, is extremely confusing.
21:22:16 <sethk> especially if one is undocumented
21:22:30 <Cale> It's not undocumented, it's in the Report.
21:22:40 <Cale> Every type will be the same like that.
21:22:43 <Lemmih> I would take less than 10m to about it in the Haskell report.
21:22:50 <Lemmih> *to read
21:22:53 <sethk> Cale, ok, but there is nothing in the docs that says "hey, this is only part of what you need to know, and you have to go read the report"
21:23:09 <sethk> Lemmih, sure, if somehow someone had some idea that the information is missing in the first place
21:23:34 <Cale> Any tutorial which introduces the record constructor syntax should also mention this
21:23:42 <sethk> I agree.
21:23:55 <sethk> but the documentation should also mention it.
21:24:10 <sethk> the documentation shouldn't be a puzzle
21:24:17 <Cale> well, the documentation is trying to be concise
21:24:33 <sethk> trying to hard, it would appear.  :)
21:24:37 <sethk> too hard, sorry
21:25:05 <Lemmih> sethk: It's the same thing with functions, types and type-classes. They'll confuse you till you understand them.
21:25:51 <sethk> sure, but I haven't come across other cases where an important function is omitted in favor of a type constructor
21:26:58 <Cale> It's just that the function in this case is the data field. So you get that function out of the State s a by calling runState, and then apply it to another parameter
21:27:09 <sethk> neither runState, nor runStateT, occurs in the report
21:27:21 <Cale> right, but the record constructor syntax does
21:27:47 <sethk> sometimes I think people want to keep haskell small, so they hide the information.
21:27:55 <Cale> also, if you read YAHT, it introduces this in section 7.7
21:28:04 <sethk> Is YAHT online?
21:28:23 <Cale> yes
21:28:29 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
21:28:35 <Lemmih> sethk: Don't expect all libraries to be in the Haskell Report.
21:28:48 <sethk> Lemmih, I didn't expect ANY libraries to be in the Haskell report
21:29:00 <sethk> you said "it is in the report" when I asked why the function is undocumented
21:29:14 <sethk> the fact that the data statement syntax is covered in the report
21:29:18 <Cale> The syntax is in the report
21:29:24 <sethk> has nothing whatsoever to do with the fact that the function is undocumented
21:29:31 <Cale> it is documented
21:29:35 <sethk> where?
21:29:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.State.html
21:29:52 <sethk> one would think that to use a library, one should look in the library document
21:30:07 <Cale> yeah, that's the library's page
21:30:26 <sethk> that's the same page that doesn't document the function
21:30:31 <Cale> It does
21:30:34 <TheHunter> sethk, there is a reason they don't just put the type of the function in the documentation. Record accessors are special, for example they allow a special kind of pattern-matching (f (State { runState = ...}) = ...), this would totally be obscured by treating runState as a function.
21:30:34 <Lemmih> To use a Haskell library, one should learn Haskell first.
21:30:38 <Cale> It's about halfway down
21:30:53 <sethk> TheHunter, but isn't runState also a function?
21:31:11 <TheHunter> it is, because every record accessor is a function.
21:31:46 <TheHunter> it's not too unresonable to expect you to know how records work when you are planning on using them.
21:32:15 <sethk> I don't agree that I don't know how records work
21:32:26 <sethk> this is very different from other uses
21:32:34 <Cale> It's the same
21:32:41 <Cale> I'll find some more uses :)
21:32:49 <sethk> elsewhere, when I see a constructor, I apply the arguments listed after the constructor
21:33:08 <Cale> the constructor is State
21:33:21 <sethk> OK
21:33:22 <Cale> and runState is a named field in State
21:33:27 <sethk> ok
21:33:40 <Cale> that field is of type (s -> (a, s))
21:34:17 <Cale> so there's automatically a function runState :: State s a -> (s -> (a, s)) implied by the fact that runState is the name of a field in State
21:34:56 <sethk> Maybe has two constructors, Nothing, and Just
21:35:10 <sethk> Nothing is alone, and Just is Just a
21:35:11 <Cale> right, and the field in Just isn't named
21:35:17 <sethk> so when I write, I write either:   Nothing
21:35:25 <sethk> or I write   Just "abc"     for example
21:35:37 <Cale> One could write:
21:35:50 <sethk> but I don't, apparently, write runState (s -> (s, a))
21:35:51 <Cale> data Maybe a = Nothing | Just { fromJust :: a }
21:36:10 <Cale> then fromJust is a field of Just
21:36:36 <Cale> and if I apply fromJust to something of the form Just x, it gives me x
21:37:13 <sethk> if I apply fromJust to something of type   Maybe a    it gives me    a
21:37:25 <Cale> something of type a, right
21:37:34 <sethk> but if I ask ghci what the type of Just is
21:37:46 <sethk> it tells me:  a -> Maybe a
21:38:04 <sethk> meaning I give it an a, and it gives me back a Maybe a, which is correct
21:38:14 <Cale> that's the type of Just
21:38:14 <sethk> so perhaps the problem here is that the initial answer was wrong
21:38:19 <Cale> not fromJust
21:38:38 <Cale> fromJust :: Maybe a -> a
21:38:45 <sethk> I know
21:38:56 <sethk> I'm using Just because Just is a part of the constructor.  fromJust is a function
21:39:00 <sethk> or so the docs show it
21:39:09 <sethk> and runState is part of the constructor
21:39:18 <sethk> but I think perhaps the problem is that the initial answer was wrong
21:39:27 <Cale> right
21:39:28 <sethk> I _do_ apply runState to a function of type     s -> (a, s)
21:39:33 <Cale> I redeclared Maybe there
21:39:35 <sethk> or the other way around, I have to check
21:39:52 <Cale> to show how it would work if Maybe had been declared using record syntax
21:40:00 <luqui> From "all about monads": In that case, a data structure that supports fast append operations would be a more appropriate choice.
21:40:06 <luqui> (rather than a list)
21:40:13 <luqui> what more appropriate choice might this be?
21:40:48 <Cale> luqui: Balanced tree?
21:40:48 <sethk> fast append to the end, perhaps?  Isn't list fast when you add to the beginning?
21:40:55 <Cale> yeah
21:41:23 <luqui> yeah, too bad Writer doesn't know that
21:41:40 <luqui> (or rather, Monoid [a])
21:41:44 <Lemmih> The word 'append' suggest we're talking about two lists.
21:42:17 <TheHunter> there's a Monoid instance for [a] -> [a] (actually already for a -> a) which might do what you want.
21:42:20 <Cale> you can represent lists as functions in a way which allows fast concatenation
21:43:14 <TheHunter> represent a list xs by the function (xs++), then appending will be the same as function composition.
21:43:44 <luqui> so then if you represent the list as (++xs)?
21:44:02 <luqui> maybe it would have to reverse xs...
21:44:27 <Cale> sethk: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Time.html -- look in there, there are some data constructors which use the same syntax
21:45:01 <sethk> Cale, it isn't the data constructor syntax that I'm having a problem with
21:45:18 <TheHunter> (++xs) . (++ys) . (++zs) $ [] === (([]++zs)++ys)++xs
21:45:21 <Cale> I'm fairly sure it is, or this wouldn't have come up
21:45:22 <TheHunter> this is really bad.
21:45:23 <sethk> Cale, I built a small test app with runState, and runStateT, with no problem.
21:45:28 <sethk> Cale, just ran it.
21:45:29 <Cale> okay
21:45:31 <sethk> Cale, works fine
21:45:50 <Cale> so what's wrong?
21:45:54 <sethk> Cale, the reason this came up is that a suggestion was made that I invoke runStateT with more arguments than the signature was showing me
21:46:11 <sethk> Cale, because there is a runStateT function with a different signature
21:46:16 <sethk> Cale, but I don't think that's true.
21:46:34 <luqui> TheHunter, right, (xs++) looks to be the better choice
21:47:19 <Cale> sethk: oh, well, as a field, runState has one argument, and as a function which extracts that field, it has two.
21:47:37 <sethk> Cale, yes, that I understood all along
21:47:39 <luqui> TheHunter, incidentally, the bad way is what Monoid [a]  is doing by default, though, right?
21:47:43 <glguy> What's the best way to do vector and matrix math in Haskell
21:48:50 <TheHunter> luqui, well, monads are usually used in a right-associative way (unless you use >>), so it might be not that bad.
21:49:04 <Cale> glguy: there are some libraries for it scattered around, but what sort of thing are you doing?
21:49:16 <TheHunter> i'm not convinced that the function-approach is faster in any case.
21:49:23 <Cale> glguy: unfortunately, there's nothing standard
21:49:50 <glguy> Cale: i'm implementing the Gram-Schmidt method in one class, and neural networks in another
21:50:06 <glguy> Cale: just looking for some "best-practices" or something for it :)
21:50:40 <TheHunter> luqui, if you write a monadic loop, that blows up the stack, chances are it will also have a desatrous performance. Otoh, I tail-recursive monadic loop will use ++ in a right-associative way, so it's ok to use [a].
21:50:46 <sethk> Cale, I think I see my problem, which is that I simply can't do what I need to do with the State monad.  Which is fine, that's one thing I'm trying to figure out.
21:51:15 <sethk> Cale, because nothing returns a state monad, everything returns just the value (possibly with other values)
21:52:30 <Cale> glguy: Well, I saw the Gram-Schmidt code, which was decent. Lists are sometimes okay, though you might get better performance out of using something like a Diff array if that's critical
21:53:25 <Cale> It's sort of too bad that nobody's come out with a vector spaces and linear maps library that has made its way into the standard libraries.
21:53:25 <sethk> Cale, If I'm going to use a monad as a persistent container of a value, I have to return the monad, not just the value, it seems.
21:53:46 <Cale> sethk: the monadic value, yes
21:54:25 <sethk> Cale, yes, I mean it should return (suppose it was a string, which it isn't, but it doesn't matter)   m String,  not just String
21:54:32 <Cale> right
21:54:47 <Cale> If you have a list, say, if you want to keep around all the elements of the list, there's no way to do that if you just take the head.
21:55:09 <sethk> Cale, that's not a case for the lift functions, is it?
21:55:37 <sethk> Cale, let me look at the types, see if I can figure that out for myself
21:56:25 <Cale> the lift functions take plain monadic values and lift them into the transformed monad.
21:56:29 <sethk> right
21:56:37 <sethk> the return function has the right signature, actually
21:56:39 <sethk> a -> m a
21:57:04 <Cale> Yeah, you could think of return as taking you from the identity monad to your monad.
21:57:33 <sethk> so I can use it to return a State monad, say, with a specific state value
21:57:36 <glguy> I'm trying to understand monads from what I've read... IO is just a particular monad, corrct?
21:57:39 <dons> TheHunter, implict params in lambdabot can be painful sometimes :S
21:57:58 <TheHunter> what's the problem?
21:57:59 <dons> just spent about 1 hr trying to get some code to compile, but it was just the type sig in the end
21:58:05 <dons> nah, it's ok now :)
21:58:16 <dons> just a few errors to do with unbound implict vars
21:58:19 * TheHunter pulls
21:58:22 <dons> but I bound them, so it's ok :)
21:58:32 <Cale> sethk: return x = State (\s -> (x,s))
21:58:41 <Cale> glguy: yes
21:58:52 <Cale> glguy: read my article :)
21:58:56 <glguy> okay, link me
21:59:10 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
21:59:21 <luqui> I've found this tutorial to be excellent for monads: http://www.nomaware.com/monads/html/index.html
21:59:27 <Cale> It will also point you at nomaware :)
21:59:29 <luqui> that's where I learned
21:59:57 <Cale> nomaware takes a slightly different view of monads than I do, but it's one which is more common
22:00:45 <Cale> (but I think my way is easier to start with)
22:00:56 <sethk> Cale, definitely your way is easier to start with.
22:04:12 <TheHunter> dons, are your changes already in darcs?
22:04:34 <dons> nope, on their way soon. I'm implementing @localtime, a wrapper over ctcp time
22:05:01 <TheHunter> sounds cool.
22:06:19 <dons> it almost works :)
22:06:45 <dons> the only real issue was having to map ctcp time replies (which are NOTICES) back to privmsgs handled by the plugin dispatch system
22:06:58 * TheHunter didn't even know there was such a thing as ctcp time.
22:07:17 <dons> CTCP TIME reply from TheHunter: Mon Oct 17 01:06:46
22:07:18 <dons> :)
22:07:33 <TheHunter> your clock is 4 minutes off!
22:07:40 <dons> your clock!
22:07:44 <dons> not mine  :)
22:07:49 <TheHunter> @timein Sydney
22:07:51 <lambdabot>  Monday, October 17, 2005 at 3:07:28 PM EST
22:07:57 <dons> oh, maybe so :)(
22:08:03 <dons> TheHunter wins
22:08:15 <TheHunter> yay!
22:08:56 * TheHunter is relieved since his computer's clock is his "master clock".
22:09:37 <TheHunter> stupid radio clock signals seem to be different in .de and .us
22:10:25 <stepcut> argh, <br></br> and <br/> do not render the same :-/
22:10:26 <dons> hmm :/
22:10:34 <dons> isn't it <br />
22:10:35 <dons> ?
22:10:58 <stepcut> on w3.org it shows <br/>
22:11:34 <sethk> Cale, it's normal for me to get this from ghci, correct?    No instance for (Show (State String Int))
22:11:41 <stepcut> oh well, I can probably hack it with css
22:11:49 <sethk> Cale, I've created my monad, but there is no show instance for it and ghci can't show it to me?
22:12:13 <sethk> both <br/> and <br /> are allowable, I believe
22:12:36 <Cale> sethk: right
22:12:47 <cjs> They are both correct for XML; <br /> will be more compatible with some rather old HTML-only browsers.
22:12:49 <sethk> Cale, my function type is   Int -> State String Int
22:13:09 <sethk> Cale, Int and String chosen arbitrarily for test purposes
22:13:14 <Cale> sethk: Basically, think of a value of type (State s a) as a function from states to (value, new state) pairs.
22:13:26 <sethk> Cale, ok.
22:13:31 <Cale> So you can't show it
22:13:46 <Cale> but if you apply it to an initial state, you can catch the result
22:13:50 <Cale> and perhaps show that
22:14:21 <sethk> Cale, ok, now I have my function that returns State String Int.  How do I use that returned value with runState?
22:14:54 <Cale> runState myStateValue initialState
22:15:19 <Cale> which, remember, is parsed as (runState myStateValue) initialState
22:15:41 <glguy> Cale: does Haskell actually give a Monad special treatment... or is it simply an abstraction of a container?
22:15:50 <sethk> Cale, state here being of type String?
22:16:15 <Cale> sethk: that's right
22:16:18 <Cale> glguy: Haskell has in the Prelude, a typeclass for handling Monads
22:16:25 <sethk> Cale, ghci doesn't like it.
22:16:25 <Cale> and a syntax called do-notation
22:16:47 <Cale> sethk: myStateValue is of type State String Int ?
22:17:03 <sethk> correct, and initialState is of type String
22:17:07 <sethk> do I need parens?
22:17:22 <sethk> shouldn't
22:17:32 <Cale> um
22:17:33 <Cale> hmm
22:17:36 <Cale> shouldn't
22:17:42 <Cale> can I see the code?
22:17:58 <Cale> runState (return 5) "Hello"
22:18:00 <Cale> try that
22:18:12 <sethk> ok, let me check, make sure I didn't just type it wrong
22:18:33 <sethk> Cale, never mind, my mistake.  :)
22:18:37 <Cale> okay :)
22:18:53 <sethk> I had a partial application hidden in there
22:19:02 <sethk> but I figured that out.  :)
22:19:12 <Cale> ah :)
22:19:29 <Cale> glguy: but actually monads come from a newer branch of mathematics called category theory.
22:19:42 <Cale> So they exist outside of Haskell in some sense :)
22:21:09 <glguy> alright, but I don't mean the abstract concept of a Monad, but I mean the type Monad, would I be able to define such a type in Haskell without using the type Monad?
22:21:26 <glguy> like a GlguyMonad, that did the same thing in Haskell as Monad
22:21:48 <Cale> ah, Monad isn't a type, but a typeclass
22:22:11 <glguy> alright, but I don't mean the abstract concept of a Monad, but I mean the type Monad, would I be able to define such a typeclass in Haskell without using the typeclass Monad?
22:22:19 <Cale> instances of this typeclass include lists, trees, State transformers, IO, and a bunch of other things :)
22:22:24 <TheHunter> dons, the annoying thing about implicit params is they somewhat contradict information-hiding: I can't construct a type synonym involving implicit paramters the values if which the user can't change.
22:22:34 <Cale> ah
22:22:36 <glguy> errr, s/ type/ typeclass
22:23:32 <Cale> well, hmm, trying to figure out exactly which question you're asking -- in order to make something in Haskell use the monad operations, you have to define an instance of monad
22:23:36 <Cale> which looks like:
22:23:44 <Cale> instance Monad MyType where
22:23:49 <Cale>    return x = ...
22:23:55 <Cale>    f >>= x = ...
22:23:57 <glguy> nope, I'm asking the wrong question then :)
22:23:58 <Cale> er
22:24:01 <Cale>    x >>= f = ...
22:24:02 <dons> yeah, it's no big problem. it's just something i've noticed before: implicit params in general make it harder to understand code, once you've forgotten the precise details of how it works
22:24:09 <Cale> glguy: hmmm
22:24:11 <Cale> okay
22:24:12 <glguy> okay
22:24:16 <glguy> I rephrase
22:24:20 <sethk> glguy, you can define a type without making it an instance of the Monad class, yes.  Usually you don't, but you can
22:24:27 <Cale> class  Monad m  where
22:24:27 <Cale>     (>>=)  :: m a -> (a -> m b) -> m b
22:24:34 <Cale>     return :: a -> m a
22:24:44 <sethk> glguy, it's a bit ambiguous because now the term "Monad" is both a general term and a specific Haskell type
22:24:48 <Cale> that's how you'd get the Monad class if it weren't in the Prelude already
22:24:56 <Cale> typeclass
22:24:58 <Cale> :)
22:24:58 <glguy> Cale: is the behavior of the Monad class special, or could I create my own class in Haskell that did the same thing
22:25:00 <sethk> glguy, so they don't quite understand that question (which I also asked recently)
22:25:13 <sethk> glguy, you can create your own class
22:25:14 <Cale> glguy: apart from the do syntax, you could do the same thing
22:25:24 <TheHunter> dons, and the order of typechecking is often subobtimal.
22:25:43 <sethk> glguy, you usually don't for logistical reasons, but you can
22:25:51 <Cale> hm?
22:26:07 <Cale> well, you don't define your own Monad class
22:26:08 <TheHunter> ooi, does the word "suboptimal" sound pretentious?
22:26:11 <glguy> I'm not trying to do it, just to understand if it's behavior is defined inside the implementation of a special basis
22:26:22 <Cale> glguy: http://www.haskell.org/onlinereport/standard-prelude.html
22:26:26 <Cale> check that out :)
22:26:28 <glguy> k
22:26:39 <Cale> the monad class is about 1/3 of the way down
22:26:48 <sethk> glguy, as he said, there is the special "do" syntax
22:27:06 <basti_> TheHunter: it surely is not useable for other uses than sarcastic. It's a definite euphemism
22:27:08 <sethk> glguy, I find it easier to code a few examples without using do, so get clear in my mind what is happening
22:27:13 <glguy> a newb question, the do syntax simply means: implied >> between each line?
22:27:22 <Cale> glguy: almost
22:27:28 <sethk> glguy  >> or >>=
22:27:34 <Cale> that's what happens when you dont use <-
22:27:39 <sethk> glguy, depending on whether the preceding line had something <- in it
22:27:57 <glguy> alright, so <- is only acceptable inside a do
22:27:58 <sethk> glguy, no something <-   >>        yes  something <- ...       >>=
22:28:02 <sethk> glguy, right
22:28:11 <Cale> glguy: that and list comprehensions :)
22:28:13 <TheHunter> basti_, that's the beauty of the word.
22:28:14 <glguy> (when we are talking about it in thsi way
22:28:21 <glguy> yeah, that's why I made that qualifier
22:28:23 <sethk> glguy, not only acceptable, but the compiler will barf mostly otherwise  :)
22:28:28 <TheHunter> good morning, btw.
22:28:41 <TheHunter> @timein basti_
22:28:44 <lambdabot>  Sorry, don't know this city
22:28:52 <basti_> TheHunter: its f....ng cold this morning.
22:28:53 <TheHunter> @timein Marburg
22:28:55 <lambdabot>  Sorry, don't know this city
22:28:59 <sethk> @timein NYC
22:28:59 <Cale> do {e} = e
22:29:01 <lambdabot>  Sorry, don't know this city
22:29:03 <basti_> @timein Frankfurt
22:29:04 <TheHunter> that's an insult, isn't it?
22:29:06 <lambdabot>  Monday, October 17, 2005 at 7:28:42 AM CEST
22:29:10 <Cale> do {e;stmts} = e >> do {stmts}
22:29:11 <TheHunter> @timein Fulda
22:29:12 <lambdabot>  Sorry, don't know this city
22:29:19 <Cale> do {p <- e; stmts} 	=	 let ok p = do {stmts}
22:29:19 <Cale> 		    ok _ = fail "..."
22:29:19 <Cale> 		  in e >>= ok
22:29:22 <basti_> "fng" cold?
22:29:24 <sethk> TheHunter, don't feel bad, it doesn't know New York either.  :)
22:29:26 <basti_> yes, to the cold.
22:29:27 <Cale> do {let decls; stmts} 	=	 let decls in do {stmts}
22:29:58 <TheHunter> basti_, god, it's fucking early there.
22:30:05 <basti_> oh yes.
22:30:21 <Cale> the rule for <- is a little funny, just because it allows one to fail to pattern match
22:30:37 <basti_> slept over at my gf's who has an appointment at the dentist's at 8:00
22:30:45 <TheHunter> moin bourbaki
22:30:46 <Cale> It might be something which should be taken out :)
22:30:52 <bourbaki> moin
22:30:54 <TheHunter> you guys are up really early.
22:31:07 <basti_> thats chronical with bourbaki.
22:31:08 <glguy> Alright, so lets see if I can get this statement through the gauntlet: a Monad is just a container that protects its contents from being used by things outside said container until the value is explicitly extracted?
22:31:14 <bourbaki> heh
22:31:17 <bourbaki> i have a flu
22:31:26 <Cale> glguy: somewhat...
22:31:36 <Cale> glguy: I think lists are the best example of a monad
22:31:41 <bourbaki> but also i usually dont switch on the computer when i get up in the morning
22:32:20 <Cale> you can still observe the contents of a list at any point
22:32:26 <sethk> bourbaki, did switching on the computer give you the flu?  :)
22:32:38 <Cale> but in general, there's no way out of a monad
22:33:14 <Cale> return lets you take values and turn them into monadic values
22:33:25 <Cale> but there's no general way to get them back out again
22:33:34 <Cale> and that will differ based on what the monad is
22:34:00 <Cale> a subtle point, the word "monad" refers to the type involved, not the values in it
22:34:14 <Cale> so one speaks of the list monad
22:34:18 <glguy> ah... so you can only add things into the IO sequence (as an example) but never remove things from it
22:34:20 <Cale> but [1,2,3] isn't a monad
22:34:26 <Cale> glguy: right :)
22:34:43 <Cale> only the runtime system can look inside and finally run the thing for you
22:34:44 <glguy> because once the order matters, it always matters
22:34:58 <glguy> (in this case)
22:35:02 <Cale> yeah, that's one way to look at it
22:35:16 <Cale> and there's a lot of extra stuff in there
22:35:16 <glguy> at least for the IO case, i suppose
22:35:18 <Cale> like
22:35:21 <Cale> getChar
22:35:34 <Cale> you can't turn that into a character, because, which would it be?
22:35:36 <TheHunter> something of type "m a" (where m is a monad) is frequently called (monadic) action.
22:36:28 <Cale> getChar is a black box which consists of all the possibilities of the external world for the user hitting a key
22:37:25 <Cale> In some sense, it's a function of type RealWorld -> (Char, RealWorld)
22:37:32 <Cale> but that's a bit odd :)
22:37:45 <glguy> but not that crazy
22:38:10 <Cale> It's a container which holds characters indexed by real worlds :)
22:38:21 <Cale> and for each result, there's a new real world :)
22:38:36 <Cale> (which is the one just after the character is typed)
22:40:23 <glguy> and this allows Haskell to remain "functional"
22:40:27 <Cale> yes
22:40:46 <glguy> because they call the real world a function (or at least a variable)
22:40:58 <Cale> yeah
22:41:20 <glguy> and a do block isn't imperative it's just linking of transformations on the real world
22:41:22 <Cale> something like that :)
22:41:25 <Cale> right
22:41:40 <Cale> and a function String -> IO String is still a pure function.
22:41:55 <Cale> For a given string, it gives the same transformation on the real world.
22:42:06 <Cale> (every time)
22:42:34 <glguy> interesting
22:44:39 <dons> @version
22:44:39 <lambdabot> lambdabot 3p106, GHC 6.5 (OpenBSD i386)
22:44:39 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:44:47 <dons> @help localtime
22:44:47 <lambdabot> print a user's local time
22:44:54 <Cale> @localtime Cale
22:44:55 <dons> @localtime TheHunter
22:44:56 <lambdabot> Local time for Cale is Mon Oct 17 01:44:33
22:44:58 <lambdabot> Local time for TheHunter is Mon Oct 17 01:44:34
22:45:19 <dons> did it do anything weird to your clients?
22:45:29 <TheHunter> --- Received a CTCP TIME from lambdabot
22:45:41 <dons> ok, that's expected.
22:45:44 <Cale> @localtime Cale
22:45:47 <lambdabot> Local time for Cale is Tue Oct 18 01:45:09
22:45:58 <TheHunter> @localtime lambdabot
22:46:10 <dons> unfortunately, lambdabot doesn't know how to do CTCP :)
22:46:31 <dons> it just needs to send a NOTICE: \^ATIME : this is my time\^A msg though
22:46:34 <glguy> "ctcp time" is the same number of characters as "localtime"
22:46:37 <Cale> mwahahaha, subverting lambdabot to make the world think I'm a day ahead!
22:46:41 <glguy> not really a time savings :)
22:47:00 <TheHunter> @localtime TheHunter
22:47:01 <dons> glguy, but it prints in public, which is different
22:47:02 <lambdabot> Local time for TheHunter is Mon Oct 17 01:46:39
22:47:15 <TheHunter> @localtime Cale
22:47:16 <glguy> dons: which is simply more obnoxious :-p
22:47:17 <lambdabot> Local time for Cale is Mon Oct 17 01:46:37
22:47:29 <glguy> at least the other way other people don't know your are pestering said person
22:47:30 <dons> no different, it can be part of our conversations now
22:47:39 <TheHunter> I don't get it.
22:47:55 <dons> ?
22:47:56 <Cale> plus, people can use lambdabot in private to watch people's clocks
22:48:06 <Cale> and lambdabot will act as a cloak of anonymity
22:48:07 <dons> right :)
22:48:21 <glguy> who does that aid aside from stalkers...? ;)
22:48:23 <TheHunter> why did lambdabot report Tuesday for Cale?
22:48:30 <sethk> @yow
22:48:31 <lambdabot> Is it NOUVELLE CUISINE when 3 olives are struggling with a scallop
22:48:31 <lambdabot> in a
22:48:31 <lambdabot> plate of SAUCE MORNAY?
22:48:45 <Cale> TheHunter: because I'm a day ahead of everyone :)
22:48:52 <sethk> If I understood that, I would be very worried.
22:49:14 <dons> @localtime dons
22:49:16 <TheHunter> oh, god, it's time I got to sleep.
22:49:18 <lambdabot> Local time for dons is Mon Oct 17 15:53:02 2005
22:49:29 <Cale> TheHunter: (really, I just changed my machine's clock)
22:49:41 <dons> yeah, I'm not sure it is Tuesday anywhere
22:49:55 <TheHunter> Cale, just realized that (and how stupid I am...)
22:50:01 <glguy> is the 'class' syntax typically used in user applications, or more in libraries?
22:50:15 <glguy> I ask because I haven't heard of it till i started looking into monads
22:50:19 <Cale> glguy: both
22:50:19 <dons> glguy, if necessary, we can block the use of @localtime from private channels
22:50:53 <Cale> glguy: It's a great tool for libraries, because it lets the user extend the operations defined in the library work on new types
22:51:03 <dons> so if anyone has any serious security issue with @localtime, feel free to raise them with me (or TheHunter, shapr, or Cale etc.)
22:51:11 <Cale> and for the same reason basically, it's a good tool for libraries
22:51:15 <Cale> er
22:51:18 <Cale> and for the same reason basically, it's a good tool for applications
22:51:20 <Cale> heh
22:51:42 <glguy> alright, the tutorials that i have read simply haven't covered that, i suppose I need to read more haskell report
22:51:56 <Cale> glguy: YAHT has a section on them I'm sure
22:51:57 <TheHunter> if someone has serious security issues with @localtime, they can just configure their client not to answer ctcp requests.
22:52:00 <Cale> hmm
22:52:06 <Cale> maybe it's unfinished?
22:52:08 <dons> TheHunter, good point
22:52:13 <bourbaki> TheHunter are you in canada atm?
22:52:28 <TheHunter> no, but not too far from it.
22:52:39 * glguy isn't actually concerned about @localtime, just trying to understand it's usefulness outside of adding commands to lambdabot ;)
22:52:41 <bourbaki> semester abord?
22:52:59 <TheHunter> yep
22:53:06 <TheHunter> 2 semesters, actually.
22:53:18 <Cale> glguy: but say, if you were writing a program to work with vectors, you might write the vector space operations into a class, so that you could reimplement vectors using different types (lists, diff arrays, etc), as needed
22:53:19 <bourbaki> nice which uni?
22:53:34 <TheHunter> msu
22:53:36 <Cale> and not have to write a bunch of code to change your app
22:54:03 <dons> glguy, it enriches our conversations. often we ponder what time it is for someone, and having to leave irc to find it is a pain. similar for @timein or @google and so on.
22:54:03 <bourbaki> msu never heared of this one
22:54:08 <dons> there's some benefit to inline data
22:54:20 <glguy> would be nice, I'll need to read on that tomorrow
22:55:02 <dons> i.e. even though you can use your browser to google something, then paste the result, being able to just
22:55:07 <glguy> I also need to read on diff arrays, the tutorial I saw said something to the effect of "what you are working on doesn't need the speed of arrays if you are reading this" ;)
22:55:11 <dons> @google dynamic applications from the ground up
22:55:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
22:55:31 <dons> is somehow more useful, and has different semantics to just pasting :)
22:56:04 <dons> and it is faster, of course
22:56:22 <glguy> dons: i agree, lambdabot is great, i was just teasing about the @localtime function
22:56:28 <Cale> glguy: Diff arrays are nice -- they do something which was previously somewhat "impossible" in functional languages. They have O(1) lookup and O(1) update, as long as you don't use versions of the diff array from the past
22:57:03 <glguy> well, now it's quite late
22:57:07 <glguy> @localtime glguy
22:57:10 <lambdabot> Local time for glguy is Mon Oct 17 00:56:47 2005
22:57:12 <TheHunter> when have diff arrays been introduced?
22:57:13 <Cale> and they're purely functional, you don't have to be writing code typed in a monad to use them
22:57:17 <glguy> and I'm going to hit the sack :)
22:57:24 <glguy> thanks everyone
22:57:28 <Cale> TheHunter: I think 6.2, perhaps?
22:57:31 <Cale> maybe 6.0
22:57:42 <dons> 6.0?
22:57:43 <Cale> glguy: goodnight
22:57:49 <dons> a fair while at least
22:58:03 * TheHunter wouldn't know since he has started haskell only after 6.2 was out.
22:58:11 <dons> @localtime ajfdad
22:58:32 <dons> @bot
22:58:33 <lambdabot> :)
22:58:34 <Cale> they're in 5.04
22:59:23 <cjs> So what if a diff array is not used in a single-threaded style?
22:59:35 <TheHunter> hehe, that's like forever.
22:59:40 <sethk> @localtime sethk
22:59:41 <lambdabot> Local time for sethk is Mon Oct 17 01:59:18
22:59:42 <Cale> cjs: indexing older copies gets slower
22:59:50 <dons> hehe, I started on 4.08.2 :)
23:00:01 <Cale> cjs: linear in the number of revisions made at that index
23:00:47 <cjs> Cale: oh, I understand that, but that's if they *are* accessed in a single-threaded style. Is their behavior correct in a multithreaded environment? Or does that question not make sense?
23:00:58 <dons> I also added @map in that last update, 'cause I'm obsessed ;)
23:02:05 <TheHunter> @help map
23:02:07 <lambdabot> #haskell user map
23:02:11 <TheHunter> @map
23:02:12 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:02:18 <Cale> cjs: their use is completely orthogonal to the use of threads
23:02:43 <Cale> cjs: "single threaded" in this case is just referring to the access pattern
23:03:04 <Cale> (of only ever looking at the most recently updated version)
23:03:05 <TheHunter> (everything is slow in haskell anyway, so we might as well might it thread safe in the first place)
23:03:19 <Cale> heh
23:03:22 <basti_> is it bad if i'm thinking more about what to code than i actually am coding?
23:03:34 <Cale> basti_: no, that's usually good
23:03:36 <Cale> :)
23:03:39 <basti_> ;)
23:03:53 <Cale> It means you're probably writing good code
23:04:01 <basti_> heh I'd hope -g-
23:04:42 <cjs> Cale: Ah, I see. Thanks.
23:04:45 <Cale> When working on the pipeline scheduler, I thought much more than than I typed.
23:05:00 <Cale> -spurious than
23:05:13 <basti_> i'm just thinking about how to do sensible webforms
23:05:24 <basti_> with at least some typechecking across forms
23:06:23 <basti_> i have a State-function now, that returns either some HTML form, or a script to read the user input from the environment
23:06:24 <Cale> heh, see, Haskell has this nice effect
23:06:37 <Cale> In a ghetto language like PHP, you wouldn't think about that
23:06:44 <basti_> yes if it works eventually, that would be very nice
23:06:57 <basti_> big footshot-protection ;)
23:07:14 <ramkrsna> autrijus: is there any API to parse a PO file?
23:07:56 <TheHunter> it recently occurred to me why guis are more popular for configuring applications than configuration files: guis are typed (will only let you enter an integer when an integer is required), whereas config files are untyped (make the slightest mistake and you're screwed)
23:08:14 <Cale> TheHunter: that's a good point :)
23:08:26 <basti_> thats true yes
23:08:35 <basti_> and guis come with their own documentation
23:08:59 <basti_> (when you can choose "Green", "Blue" and "42" for an option, you don't need to look that up in the manual)
23:09:31 <Cale> some config files embed documentation in comments
23:09:38 <autrijus> ramkrsna: from C?
23:09:50 <basti_> the keyword there is -some-
23:09:54 <basti_> .)
23:10:01 <Cale> basti_: of course :)
23:10:19 <TheHunter> but they rarely embed the right amount of documentation.
23:10:51 <ramkrsna> autrijus: anything ;)
23:10:58 <dons> TheHunter, unless you use a statically typed language for your configuration files..
23:12:29 <dons> (that was to your earlier point about guis versus untyped config files)
23:13:19 <TheHunter> we need something like deriving (GUI) where GUI has methods like update :: GUI g => g -> IO g which shows a dialog which allows us to change the value. Maybe even I would bother to write gui-like stuff then.
23:13:26 <autrijus> ramkrsna: er, surely, read-po.h in gettext
23:13:58 <autrijus> ramkrsna: may or may not be useful: http://cvs.sourceforge.net/viewcvs.py/haskell-i18n/Source/Text/I18N/
23:13:59 <Cale> TheHunter: :)
23:14:07 <Cale> TheHunter: Have you seen FunctionalForms?
23:14:18 <TheHunter> no.
23:14:40 <Cale> http://www.sandr.dds.nl/FunctionalForms/index.html
23:14:46 <TheHunter> sounds about like what I want.
23:15:51 <TheHunter> except... I don't want to be bothered with layout definitions.
23:17:53 <TheHunter> I better get some sleep, night everyone!
23:30:20 <kosmikus> morning
23:35:05 <pesco> Morning kosmikus.
23:35:15 * pesco stretches.
23:35:55 <kosmikus> hi pesco; how are you these days?
23:36:54 <ValarQ> morning folks
23:37:19 <ulfdoz> ouch
23:39:18 <bourbaki> pesco do you happen to know what talks there will be on this years chaos camp?
23:40:21 <pesco> bourbaki: Congress you mean? I happen to know there will be one on Lojban. ;-)
23:40:27 <bourbaki> ah yes congress
23:40:40 <bourbaki> lojban?
23:41:14 <pesco> bourbaki: Apart from that, I think they're still in the planning stage and I don't have access to the internal orga data.
23:41:29 <pesco> @google lojban
23:41:30 <bourbaki> hn
23:41:30 <lambdabot> http://www.lojban.org/tiki/tiki-index.php?page=Home+Page&bl
23:42:17 <pesco> kosmikus: Good, thanks. I relocated to Prague for 10 months, to study some mathematics.
23:42:56 <pesco> kosmikus: I'm pretty much going to drown in work, I'm afraid. :(
23:43:10 <dons> pesco! hey, you're a good candidate for:
23:43:11 <dons> @map
23:43:12 <dons> :)
23:43:12 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:43:21 <pesco> dons: Woohoo :)
23:43:56 <pesco> Woah, Germany is almost empty!
23:44:29 <dons> yeah, I think they must teach some top-secret german fp language that we don't know about
23:44:37 <pesco> Haha.
23:44:37 <dons> and france too, but that's the ocaml factor
23:44:44 <pesco> I see...
23:45:22 <bourbaki> maybe the germans are just too lazy
23:45:44 <pesco> dons: How do I add myself? Just type my data into the big chunk on the wiki?
23:45:51 <dons> yep :)
23:45:58 <dons> or /msg me the data, and i can type it for you
23:46:04 <pesco> :)
23:46:08 <dons> the map gets regenerated every 3 hrs straight from the wiki page
23:46:14 <pesco> I see, good.
23:46:22 <pesco> Now I just need to find out my coordinates.
23:46:46 * dons happily snacks on brazillians oreos
23:49:34 <dons> bourbaki: i don't see you on the list ;)
23:51:47 <sethk> when ghci uses a type a1, instead of b, what is it saying?
23:52:15 <dons> hmm, it just generates fresh tyvars with those kinds of names
23:52:56 <dons> in fact, here's the algo:
23:52:57 <dons> freshName = TC $ \s ->
23:52:57 <dons>   let i     = unique s
23:52:57 <dons>       fresh = mkId $ if i < 26 then [chr (ord 'a' + i)] else 't' : show i
23:52:57 <dons>   in (fresh, s {unique = i + 1})
23:53:21 <sethk> dons, in this line, why does it use a1 instead of b?  Assuming that it isn't just arbitrary:   Couldn't match `IORef a' against `IO (IORef a1)'
23:53:54 <dons> ah, a and a1 unify, but IO (IORef _) doesn't against (IORef _)
23:54:16 * boegel greets
23:54:31 <dons> the particular choice of tyvars isn't important
23:55:07 <sethk> dons, I see the error, the types aren't the same, but I wondered if there was any semantic significance to a1 vs. b
23:55:41 <pesco> dons: Aren't there a thousand different coordinate systems for mapping the world? Which one is this?
23:55:44 <ValarQ> greetings boegel
23:55:58 <dons> decimal latitude longitude
23:56:10 <dons> though I think xplanet also handles some other formats
23:56:31 <bourbaki> pesco mathematically speaking there are infinitely many mappings ;)
23:56:39 <pesco> bourbaki: You know what I meant.
23:56:45 <bourbaki> yes
23:57:13 <dons> bourbaki also likes writing "undefined" for his functions :)
23:57:14 <sieni> uncountably many actually
23:57:29 <pesco> Oh, wilx seems to be in .cz, cool.
23:57:49 <pesco> wilx: Where in .cz are you?
23:58:03 <dons> I wonder if I can overlay political boundaries on the map. hmm
