00:00:10 <Megzl> well, I'm thinking like an anonymous struct
00:00:22 <Megzl> but, I can't make assumptions
00:00:26 <basti_> they dont have a name either do they?
00:00:28 <sylvan> perhaps anonymous functions should be introduced in a different context, like when using map
00:00:30 <sylvan> `?
00:00:34 <Megzl> especially since haskell is so different
00:00:43 <Cale> I find that a lot of trouble learning Haskell comes from trying to apply previous programming experience too soon :)
00:00:49 <Korollary> it doesnt hurt to be more verbose there
00:00:53 <sylvan> Cale, indeed.
00:01:04 <Cale> But yeah, that page should be more verbose perhaps.
00:01:11 <humasect> thinking backwards helps
00:01:12 <Megzl> Furthermore
00:01:15 <ValarQ> Cale: yeah, it is a bit rough on us C coders :)
00:01:17 <Megzl> I have no idea what \x is
00:01:28 <Megzl> that concept was introduced out of thin air
00:01:29 <Cale> yeah, that needs explanation
00:01:29 <Megzl> no explanation
00:01:39 <sylvan> well that needs to be explained then.. The back-slash is a lambda
00:01:40 <ValarQ> yeah, that lambda is to early as well
00:01:41 <sylvan> =)
00:01:45 <basti_> Megzl: please calm down a little.
00:01:45 <dons> sethk, are you really in tajikistan? or perhaps you're also -73 degrees, not +73
00:01:50 <Megzl> you also didnt explain what ( ) is
00:01:59 <dons> same goes for lispy, who I don't think is in china.
00:01:59 <Korollary> dons: he's in New York
00:02:05 <basti_> parenthenses have the obvious meaning
00:02:06 <Cale> ( ) are always grouping
00:02:12 <Megzl> Yeah, but why group that?
00:02:13 <Cale> or tupling
00:02:18 <sylvan> well () is just paranthesis, like in any language, or math
00:02:22 <Cale> it's unnecessary to group it
00:02:24 <basti_> to help reading
00:02:24 <dons> why do the americans assume they're +degrees, and not -degrees :P
00:02:26 <humasect> dons i just used the coords of some store in the town.
00:02:28 <ValarQ> Megzl: did you read that haskell for C coders link i gave you?
00:02:28 <humasect> *city
00:02:33 <Megzl> ValarQ: not yet!
00:02:41 <ValarQ> Megzl: as i said, it helped me
00:02:53 <Korollary> dons: I got my coords from wikipedia
00:02:54 <Cale> but lambdas are often grouped just by tradition
00:02:55 <shapr> Gee, how do you explain \x -> x + 1 ?
00:02:59 <sylvan> Heh, first chapter "What the heck is going on?"
00:03:01 <basti_> shapr: "add one".
00:03:08 <ValarQ> shapr: you remove it ;)
00:03:18 <Cale> \x -> x + 1 is the function which takes a parameter "x" and returns the value "x+1"
00:03:21 <dons> most look ok Korollay, humasect. just lispy and sethks were clearly wrong
00:03:22 <sylvan> shapr, I think you need to wait with that and use it in a context, like: map (\x -> x*4 + x) [1..10]
00:03:48 <humasect> just say that lambdas are inline.
00:03:53 <Korollary> shapr: or dont use a lambda and use a let nonanonfunc x = x + 1
00:03:55 <kzm> map (5*) [1..10]? :-)
00:03:59 <dons> @seen seidan
00:04:00 <lambdabot> I saw seidan leaving #haskell 2 months, 23 days, 21 hours, 34
00:04:00 <lambdabot> minutes and 59 seconds ago, and I have missed 23 days, 18 hours, 44
00:04:00 <lambdabot> minutes and 54 seconds since then.
00:04:29 <dons> is seidan in the US too, anyone know?
00:04:51 <dons> since his name's Joel, it seems possible.
00:05:06 <Korollary> just put him in the white house
00:05:14 <shapr> No, Joel is in .jp I think.
00:05:20 <dons> ok. cool.
00:05:54 <dons> it renders as .jp
00:05:58 <Megzl> take that wiki page, and run over it the a way a compiler would, evaluating each and every character/construct, and asking the question: "is this explained?"
00:06:23 <basti_> Megzl: ok I do, and then I calm down, and start to think.
00:06:24 <Megzl> even things like ( which seem obvious
00:06:49 <boegel> Cale: I see you had some work with the wiki yesterday ? spam-action again ?
00:07:01 <Cale> boegel: yeah, tons of it
00:07:23 <Korollary> In general, there are circular dependencies sometimes, and it may not be possible to clarify everything at once. But it can be improved quite a bit.
00:07:26 <boegel> I can tell looking at the recent updates :)
00:07:30 <Cale> Megzl: check out the tutorial I pointed you at
00:07:47 <Cale> and if you have any trouble, come here and ask questions, and there are lots of people willing to help
00:08:17 <shapr> Yeah, definitely.
00:08:26 <Cale> It takes some time to get the big picture of Haskell.
00:08:37 <sylvan> Oh it _hurt_ learning haskell =)
00:08:45 <Korollary> It took me several months
00:09:00 <Cale> The reason I was pointed at Haskell initially is that I was talking to someone about some ideas I had for an algebraic theory of music.
00:09:01 <sylvan> I hear, though, that non-programmers find it a lot easier to learn Haskell than imperative languages..
00:09:03 <Korollary> some sorta jedi experience
00:09:08 <Cale> They pointed me at Haskore :)
00:09:16 <ValarQ> it has taken me almost a month to get this far, and i still don't know how to compose a bit larger programs
00:09:24 <Cale> which is an embedded domain specific language for music, in Haskell
00:09:34 <Korollary> ValarQ: how far are you ?
00:10:05 <ValarQ> Korollary: i have been playing around with Data.Array and Data.Map lately
00:10:25 <Korollary> ValarQ: I was not playing with Data.Anything in my first month
00:10:45 * earthy had no trouble learning Haskell
00:10:58 <earthy> even though I'd been programming imperatively for years
00:11:05 * basti_ hadn't too, but knew scheme and prolog before
00:11:19 <ValarQ> those MonadPlus thingies is a bit tricky thought
00:11:37 <ValarQ> i knew python, maybe that helped a bit
00:11:38 <sethk> sylvan, that's definitely not true
00:11:43 <basti_> its not all that hard when you know theres more to programming than "i++"
00:11:57 <ValarQ> i already got tuples and list comprehensions in my head for example
00:12:02 <Cale> MonadPlus is obvious from the container perspective :)
00:13:08 <ValarQ> Cale: yeah, i actually managed to do that "All About Monads" excercise :)
00:13:11 <sylvan> sethk, what isn't?
00:13:25 <sethk> sylvan, what you said about haskell being easier to learn for non-programmers
00:13:32 <ValarQ> i even wrote a Data.Tree for all the small sheeps :)
00:13:52 <Korollary> ValarQ: sheep plural is sheep again
00:14:00 <sylvan> well that's just what I heard from people who took the course at the same time as me.. While it was hard to learn how to program they say it was easier than when they had to learn Java later on...
00:14:06 <ValarQ> Korollary: oh, thanks
00:14:28 * boegel is still learning Haskell
00:14:34 * basti_ is too
00:14:37 <basti_> but who in here isn't?
00:14:37 <ProfTeggy> boegel, hurry up
00:14:40 <ProfTeggy> ;-)
00:15:06 <sylvan> And it kind of makes sense. In Java you need to grok things like references and mutable state
00:15:10 <Cale> I was showing my nonprogrammer mathematics-student friend Haskell. He'd tried programming in C++ and hated it. He thought Haskell meshed better with the everyday way of thinking about things -- my favourite example he gave me was washing dishes
00:15:38 <sethk> sylvan, oh, no, not at all.  those things are obvious, and you don't in fact really have to understand them at all to use imperative languages
00:15:42 <Korollary> nonprogrammer maths students are not really a representative sample of nonprogrammers.
00:15:48 * araujo thinks Haskell makes good than other languages (java included) for non-programmers too
00:15:57 <Cale> You don't number all the dishes, and increment some number as you wash each one.
00:15:59 <araujo> better even
00:16:02 <sylvan> sethk, obvious because you learnt how to program Java before Haskell, or obvious like in "your mother understands it"?
00:16:06 <Cale> You just wash them all, which is like map.
00:16:23 <Cale> (map wash dishes)
00:16:26 <Cale> :)
00:16:30 <Korollary> Cale: mutating dishes
00:16:31 <araujo> Cale, hah
00:16:39 <sethk> sylvan, obvious as in you take any group of reasonable intelligent people and show them a loop, they have no trouble whatsoever understanding what it does
00:16:51 <ValarQ> Cale: great example :)
00:16:51 <sethk> sylvan, but recursion is absolutely incomprehensible to them.
00:17:01 <Megzl> How does Haskell go about allocating complex object types with various variables inside them?
00:17:04 <boegel> ProfTeggy: don't have the time I'm afraid
00:17:16 <araujo> I actually think Haskell would be a better introductory language for programming than many other out there (java included again)
00:17:20 <Cale> Megzl: data declarations define new types which contain various data
00:17:24 <sylvan> sethk, well then don't show them recursion, shoe them "sum" and "map" etc.
00:17:43 <Cale> Megzl: together with constructors which build values of those types
00:17:48 <Megzl> Do you think recursively all the time with Haskell?
00:17:50 <sethk> sylvan, you can't understand sum and you can't understand map if you don't understand recursion
00:18:01 <sylvan> sethk, sure you can "sum returns the sum of a list"
00:18:10 <Cale> Megzl: You think in terms of higher-order functions
00:18:19 <Megzl> I think recursively in C++ only when creating some specific algorithm that needs it.
00:18:27 <araujo> Students usually worry about C features in Java , than in java itself during the whole semester , and at the end, they neither program in java nor in C
00:18:34 <sethk> Megzl, that's not the same meaning of recursion
00:18:35 <araujo> At least that's what i can see happening here
00:18:38 <Cale> You can understand map without understanding recursion. You just can't understand how it's implemented.
00:18:40 <sethk> Megzl, it's completely different.
00:18:41 <sylvan> sethk, you don't need to know recursion to write simple haskell programs the first week
00:18:50 <sethk> sylvan, I disagree
00:18:52 <Maddas> sethk: A group of reasonably intelligent people find recursion absolutely incomprehensible?
00:18:59 <sethk> Maddas, absolutely
00:19:02 <Maddas> Why?
00:19:10 <Maddas> Why might they not find loops incomprehensible?
00:19:11 <sethk> Maddas, they just don't think in those terms
00:19:15 <Megzl> Like they say...
00:19:17 <sethk> Maddas, a loop is quite obvious
00:19:19 <Megzl> to loop is human
00:19:24 <Megzl> to recurse is godly
00:19:25 <Maddas> sethk: Um, I don't see why
00:19:31 <Maddas> But that may just be me
00:19:32 <sylvan> sethk, well i'm just reiterating what I've heard here at school - that people who have no experience programming have a lot harder time understaning "low-level" langauges like Java
00:19:35 <basti_> anyone who wants to understand recursion needs to understand recursion first.
00:19:52 <Korollary> basti_: cheers
00:19:52 <sethk> sylvan, I've done lots and lots of teaching, and that is simply not the result I see at all.
00:20:07 <araujo> Megzl, i think human mind is pretty recursive actually, it is just they are not _that_ aware of the concept
00:20:08 <sethk> basti_, that's redundent and it says the same thing twice
00:20:13 <sylvan> well do you teach to programmers or to complete newbs?
00:20:15 <basti_> it was a joke ok?
00:20:19 <Maddas> sethk: I agree that if you are used to think in more 'imperative' programming languages, yes
00:20:19 <sethk> sylvan, scientists
00:20:25 <sethk> basti_, really ????
00:20:29 <basti_> sethk: yess!
00:20:29 <sylvan> sethk, so they've probably already programmed
00:20:31 <sylvan> ?
00:20:39 <Maddas> sethk: I know various people who find recursion easier, though, without having programmed much.
00:20:39 <sethk> Maddas, no, I'm talking about people who have never used a language at all
00:20:47 <sethk> sylvan, no, they haven't programmed
00:20:57 <humasect> haha
00:20:59 <Korollary> why does it matter what people think of loops vs recursion ?
00:21:01 <Cale> Everyone recurses
00:21:03 <sethk> sylvan, unless you consider excel programming
00:21:08 <araujo> For example, when you have a dream inside another one and another... :-]
00:21:19 <sylvan> okay.. anyway I think recursion is just as natural as loops... I mean, take the dishwashing example. You say "wash one plate, then wash the rest" =)
00:21:19 <sethk> Korollary, it doesn't necessarily matter
00:21:28 <Cale> They might not formally think of things in terms of recursion right away
00:21:30 <Maddas> Many of them have already studied a bit of math, which certainly has some kind of influence.
00:21:36 <sethk> sylvan, do some testing, you'll find that what I say is true
00:21:38 <Cale> they might not have a name for recursion in their head
00:21:40 <Cale> but they do it
00:21:47 <araujo> Cale, yes, exactly
00:21:56 <sylvan> sethk, I have actually been involved in teaching Haskell, and I don't agree with you
00:22:00 <araujo> recursion is more natural i'd say,
00:22:00 <Korollary> The Fourier transform may not struck many as 'intuitive', but what are you going to do..
00:22:11 <sethk> sylvan, ok.  but I have lots and lots of experience here.
00:22:11 <Maddas> I think it's silly to think either loops or recursion are natural.
00:22:18 <araujo> people just can't recognize it like such
00:22:32 <basti_> we should really make an "excuses" page in the wiki.
00:22:38 <Cale> They're not natural, but they do correspond to mental processes which everyone carries out.
00:22:48 <sylvan> there was a paper I read ages ago about the US army or something like that evaluating what languages were easier to learn, anyone know what i'm talking about?
00:23:04 <Maddas> Cale: Right, I agree.
00:23:09 <Megzl> haskell .: everything is really recursive, but you don't have to think about it that way, but you can think about recursive ideas just as simple high level functions?
00:23:15 <sethk> sylvan, no, except that you are talking about people who used to mandate the use of ada
00:23:33 <Cale> Megzl: yes
00:23:46 <Cale> recursion is as easily expressed as in any language
00:23:54 <Cale> ones = 1 : ones
00:24:02 <Cale> this builds a list recursively
00:24:07 <Cale> it starts with a 1
00:24:14 <Cale> the rest is equal to the whole list
00:24:15 <sylvan> sethk, well I it was linked from haskell.org if I'm not misstaken, trying to find it..
00:24:17 <sethk> Cale, well, no, older languages can't express it at all
00:24:17 <eivuokko> It seems to me like you are to idelogist about teaching programming.  I don't teach, but I have seen job applications where I work and a lot of people clearly do not understand how things work, and they won't really care about code, it being rather low level tool for them.  They can make suprisingly complex programs, but they cannot see it as science, art and their engineering "try this piece and if it don't work, the next".
00:24:41 <Cale> sethk: any, not all
00:24:49 <araujo> loop raen't usually _that_ clear at all, they can become very messy, probably even more than recursion sometimes.
00:24:52 <sethk> eivuokko, yes, I think so
00:24:52 <Maddas> eivuokko: Right. I also found that surprisingly much can be taught if you just find the right, um, way to access them
00:25:01 <Maddas> eivuokko: Assuming that they want to learn, of course.
00:25:03 <sethk> Cale, at any?  No such construct.
00:25:08 <Megzl> Hi Medotchka.
00:25:12 <medotchka> Hi Megzl.
00:25:18 <Megzl> Medotchka should learn Haskell.
00:25:35 <medotchka> Why?
00:25:43 <sethk> why not?
00:25:46 <Cale> sethk: I was emphasizing my use of the word
00:25:54 <sethk> Cale, I know, I was joking
00:25:56 <shapr> Cuz it's cool!
00:25:56 <Cale> heh
00:25:59 <Maddas> araujo: No dispute there, I'm just trying to point out that I don't think that any one is clearly the most "natural" way of thinking
00:26:10 <basti_> hi medotchka are you new here?
00:26:20 <Maddas> araujo: Since people often _learn_ to think in loops and recursion, and what is natural no one may not be to another :-)
00:26:21 <medotchka> Yes.
00:26:30 <Maddas> s/is/feels/
00:26:50 <Megzl> Medotchka, do you think in loops or recursion?
00:27:10 <Maddas> haha :-)
00:27:16 <araujo> Maddas, my point is that i do believe recursion is more frequent in our mental processes than loops
00:27:30 <araujo> For example, never had a dream inside another dream?
00:27:39 <sylvan> I believe mutable updates are pretty much non-existent in our mental processes =)
00:27:44 <sylvan> "Sam = Bob?"
00:27:52 <Cale> higher order functions have a better chance of being natural, as one can start with a natural way of thinking about something, and give it a name.
00:27:53 <Maddas> araujo: Hm, I don't think so. Can't remember, really
00:28:01 <Korollary> ot, how can extract files from a debian package >
00:28:14 <Maddas> araujo: But I disagree that this has anything to do with it. You can also explain that with a loop and a stack if you try hard enough :-)
00:28:16 <Cale> looping is a higher order function, of course :)
00:28:16 <sylvan> dpkg?
00:28:30 <araujo> Maddas, well, that'd be an example, i bet you could find many more proving what i mean
00:28:44 <araujo> Maddas, Exactly, _hard_ enough
00:28:44 <Cale> (but you don't always think of it that way)
00:28:47 <Maddas> araujo: I don't see how that proves what you mean, sorry. It's just a matter of how you interprete it
00:28:49 <Korollary> sylvan: thanks
00:29:10 <Maddas> araujo: Yes, but washing the dishes -- is that recursive or iterative? Or does it even matter? I wash the dishes without thinking which way I do them (assuming I must wash them)
00:29:16 <araujo> Maddas, Well, our dreams are mental process, (at least from another levels)
00:29:40 <araujo> And they are usually more spontaneous than our conscius thoughts
00:29:42 <Maddas> That it is easier to explain it that way doesn't mean that I actually thought of it that way, or that I thought about it at all :-)
00:30:03 * araujo hopes to have spelled that right
00:30:21 <sethk> Maddas, no wonder you break so many dishes.  :)
00:30:34 <Maddas> sethk: I avoid even making them dirty :-)
00:30:44 <Maddas> Well, I try.
00:30:55 <sethk> araujo, conscious
00:31:01 <astrolabe> araujo: 'spontaneous' looks good, 'conscius' doesn't.
00:31:03 <Megzl> I like to grow plants with recursion.
00:31:11 <araujo> astrolabe, sethk hah, thanks
00:31:53 <Megzl> The first task for Haskell would be to implement an L-System.
00:32:03 <Cale> Megzl: :)
00:32:11 <Maddas> Like the thing xerox pointed at? :)
00:32:22 <Cale> xerox and I wrote a nice L-System generator
00:32:28 <Megzl> Show me the code.
00:32:30 <Maddas> :)
00:32:34 <Cale> sure
00:32:49 <Megzl> I'm interested in L-Systems; I've spent a ton of time coding them in C++.
00:32:50 <sethk> Cale, iz that like, ya know, if, den, Lsystem?
00:33:01 <Cale> sethk: heh
00:33:13 <Megzl> I just realized this would be an interesting use for Haskell.
00:33:19 <Megzl> It could change the way I think of L-Systems.
00:33:19 <Cale> Megzl: It's broken into modules -- I'll paste the important bit
00:34:53 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
00:34:59 <Cale> the first bit
00:35:17 <Megzl> That's too little code.
00:35:18 <Cale> unfortunately, it involves some abstractions you don't know yet :)
00:35:33 <Megzl> Where are all the other rules besides F.
00:35:44 <earthy> um, L-systems are simply generative grammars that are the interpreted as pictures, right?
00:35:52 <Cale> Oh, you can give it an arbitrary axiom/set of axioms and rules
00:36:25 <boegel> earthy: right
00:36:26 <Cale> result 7 (return "F", M.fromList [('F', Just "F+F-")])
00:36:31 <Cale> 7 iterations
00:36:36 <Cale> "F" is the only axiom
00:36:47 <Cale> the rule is to replace F with F+F-
00:36:57 <Cale> that's a deterministic one
00:37:07 <Cale> if you wanted other rules, you'd add them to that list
00:37:18 <Cale> result 7 (return "F", M.fromList [('F', ["", "F+F", "F-F"])])
00:37:25 <Cale> this is a nondeterministic l-system
00:37:32 <Cale> again, 7 iterations
00:37:37 <Cale> "F" is the only axiom
00:37:51 <sethk> Cale, and this is useful for what?
00:37:56 <Cale> Replace F with the empty string, F+F and F-F, and give all possible results
00:38:08 <Cale> sethk: drawing beautiful trees and snowflakes :)
00:38:13 <sylvan> sethk, drawing pretty pictures!
00:38:24 <sethk> Cale, sylvan ok.  I've not seen it
00:38:37 <Cale> http://vx.hn.org/autoshare/branchy.png
00:38:43 <boegel> sethk: http://haskell.org/gtk2hs/gallery/Cairo-demo/Cairo_demo_13
00:38:46 <Itkovian> sethk: actually, it can be used to model lifelike stuff
00:38:54 <Cale> http://vx.hn.org/autoshare/Screenshot-Snowflake-Random.png
00:39:04 <earthy> see e.g. http://algorithmicbotany.org/
00:39:10 <Cale> http://vx.hn.org/autoshare/Screenshot-Snowflake.png
00:39:22 <Cale> excuse my terrible connection
00:39:45 <Cale> okay, that second example -- the nondet one, it returns a lazy list of all possible expansions
00:40:21 <Cale> using yet another input, we could choose random expansions
00:40:25 <Cale> and this is in fact what the code does
00:40:25 <Cale> it uses a random number monad
00:40:31 <Cale> to randomly select options for each rule
00:40:42 <Cale> and the same code does the expansion in each case
00:40:51 <Cale> you don't need new code to manage the L-system
00:41:07 <Cale> just new kinds of input to the algorithm
00:41:26 <shapr> Megzl: "That's too little code." is a common reaction to Haskell programs.
00:41:39 <Korollary> wow, missingH is sweet. pipehandles, yes...
00:41:45 <Megzl> It's not very much code in C++, either, actually.
00:42:06 <Megzl> I was remarking only about the lack of seeing many rules.
00:42:27 <Cale> Megzl: ah, the rules are all passed in from the UI
00:42:45 <Cale> (it's abstracted over the rules, as I mentioned)
00:43:09 <Cale> sorry about my horrifically slow connection to the net
00:43:19 <Cale> for anyone downloading those pictures
00:43:29 <Cale> it's "DSL" but just barely
00:43:46 <Korollary> Cale: imageshack ?
00:44:07 <Cale> Korollary: I could, I suppose
00:44:09 <shapr> o'reilly got slashdotted?
00:44:52 <earthy> um. maybe they're on level 3 and you're on cogent?
00:45:02 <shapr> Could be
00:45:32 <Korollary> I load http://www.oreilly.com/ just fine.
00:45:37 <earthy> since I still have nice and reasonably quick access to oreilly.com
00:46:09 <Cale> stupid Tier 1 ISPs
00:46:28 <earthy> stupid level 3 bullying others in an attempt not to go titsup.com
00:47:03 <Itkovian> Megzl: you sound rather unconvinced about the Power of Haskell. However, it _is_ a tad annoying to keep bringing up C++, which, imo is plain ugly. There. I said it.
00:47:15 <Itkovian> no offense intended
00:47:43 <Itkovian> Maybe you should try to grasp the coolness of it instead of comparing it to your favorite language.
00:48:33 <Cale> Comparing Haskell to other languages (except for MLs) is somewhat difficult.
00:50:34 <shapr> Megzl: Anyway, you might like it. There are many nifty ideas in the Haskell world.
00:51:46 <shapr> Most of the cool ideas in the Haskell world can be applied to other languages as well. I use Haskell constructs in my paying Python code.
00:51:54 <Cale> One of the biggest side-benefits of Haskell is that it has connected me with a lot of very cool new programming language research.
00:52:43 <Korollary> I like the #haskell people.
00:52:50 * shapr hugs Korollary 
00:52:59 <Maddas> Don't we all? :-)
00:53:03 <ProfTeggy> The biggest of Haskell to me is its value in rapid prototyping
00:53:07 <Cale> Megzl: I wrote a pipeline scheduler and register allocator for PPC+Altivec assembly (paid), in Haskell, and it came to about 1000 lines, and that was just under 50% documentation.
00:53:08 * Korollary map hug #haskell
00:53:11 <ProfTeggy> biggest value, that is
00:53:43 <Cale> Something similar in C or C++, I can imagine taking 10 times that amount of code.
00:53:53 * boegel 's raytracer was under 500 lines of code, the core was something like 150
00:54:03 <Maddas> Cale: Blech, even my basic Chess board/game infrastructure looks like it'll work out to something like that :-P
00:54:14 * Maddas just can't find elegant ways to do certain things yet
00:54:48 <Cale> Maddas: It was rather like playing chess actually.
00:54:49 <Maddas> Cale: Mind a few questions about what you suggested yesterday?
00:54:54 <Maddas> Cale: Heh. :-)
00:56:06 * Maddas leaves for a short bit
00:56:33 * boegel leaves
00:57:04 <Cale> Maddas: I don't mind if they're quick :)
00:57:42 <Cale> Maddas: otherwise, email me at my gmail.com account: cgibbard
00:57:49 <Maddas> Ok. You suggested newtyping State to create a Chess (board) monad, but what operations would you specialize?
00:57:59 <Maddas> It's quick :-)
00:57:59 <Cale> moving of pieces
00:58:19 <Cale> initialising the board
00:58:23 <Maddas> But the monad itself would say the same pretty much, right?
00:58:27 <Cale> yes
00:58:37 <Maddas> Ah, okay. I thought you had in mind a cleverer bind/etc.
00:58:41 <Cale> you'd just expose particular values of the chess monad
00:58:47 <Maddas> Right.
00:58:51 <Cale> It's just a state monad which carries a board
00:58:59 <Maddas> That's what I did, thanks :-)
00:59:07 * Maddas has a few ideas to make things nicer now, tohugh
00:59:14 <Maddas> Though, even. Thanks for the tips :-)
00:59:53 <Cale> Actually playing chess could be done with the list monad
01:01:05 <shapr> medotchka: Would you like to learn Haskell?
01:02:21 <Cale> (Write a function which from a position, return a list of moves to try, in order. Call that f. Let x be an initial board position, then [x] >>= f >>= f >>= f is a 3 level deep search)
01:02:37 <Cale> returns*
01:04:36 <Korollary> Cale: that's like a turing machine heh
01:04:43 <Korollary> board position = tape
01:04:49 <Cale> yes
01:04:51 <Cale> quite
01:05:23 <Korollary> why would one make this a monad, though ?
01:06:02 <Cale> monads model different kinds of computation
01:06:15 <Cale> at the same time as being containers
01:06:17 <Cale> :)
01:07:22 <Korollary> if x is an inital position, should it not be x >>= f >>= ... ? Why [x] ?
01:07:30 <Korollary> og
01:07:31 <Korollary> oh
01:07:50 <Cale> (return x) would do as well
01:07:57 <Korollary> right
01:08:19 <Korollary> so, [x] >>= f gives you a tree
01:08:55 <earthy> um, no
01:08:58 <Korollary> like [a,b,c,d,e], and a, b are positions themselves
01:09:07 <earthy> [x] >>= f  gives you a list
01:09:47 <earthy> but it is the list of possible successors to x
01:09:49 <Cale> you could use a tree monad to get the tree :)
01:09:51 <Korollary> earthy: I meant it becomes a tree after mutliple..
01:10:06 <Cale> it's a tree evaluation wise
01:10:12 <earthy> um, no.
01:10:13 <earthy> ;)
01:10:19 <earthy> >>= is *very* linear
01:11:06 <Cale> xs >>= f >>= f >>= f will have a tree like structure of transformations associated to it
01:11:33 <earthy> xs >>= f >>= f >>= f will have a powerset like structure of transformations associated to it
01:11:38 <Cale> each item in xs expands to a list of items, and each of those expands further
01:11:44 <earthy> wich is similar, but fundamentally different
01:12:21 <Cale> evaluating the first element of xs >>= f >>= f >>= f will traverse that tree taking the leftmost branch
01:12:23 <earthy> each item in xs expands to a list of items. these are concatenated, and then each item in the concatenated list expands further
01:12:37 <Cale> yes, but it doesn't happen all at once :)
01:12:42 <earthy> yes, it does in fac.t
01:12:55 <earthy> that's what >>= and it's laws state
01:12:55 <Cale> no, it's evaluated lazily
01:13:08 <Cale> I'm looking at something different
01:13:17 <Korollary> Cale: maybe, then it's not a monad
01:13:50 <Cale> Oh, list is a monad. And earthy's description is what actually happens.
01:14:04 <earthy> conceptually you can look at it the way you do, but *only* if you know exactly how many steps down the tree you've taken and how many children each node has
01:14:05 <Korollary> I meant the move tree
01:14:31 <Cale> the final list is like the list of leaves of the move tree
01:14:36 <earthy> exactly
01:15:37 <Korollary> yes
01:16:17 <Cale> and the pattern of computing the elements of that list is like a left-to-right traversal of that tree
01:17:16 <Cale> You can actually feel that if you have a big enough computation, in the lengths of times it takes -- you can tell when the backtracking is happening
01:18:23 <Maddas> Cale: Yeah, I like that idea.
01:18:52 <Maddas> I'm just not sure whether my particular purpose necessates that -- although I'd like to use the list monad for small parts of the problem to do things like you mentioned :)
01:19:22 <Korollary> Maddas: Why not write a go player ? There are a lot of chessplayers already ;)
01:19:25 <Maddas> (I'll never need to search more than 1 move deep, I think)
01:19:33 <earthy> go is slightly, um, hard. :)
01:19:35 <Maddas> Korollary: Not a player, just a PGN viewer :-) Because I'm not happy with any of the existing ones.
01:19:43 <Korollary> ah
01:19:53 <Maddas> Nothing hard, but a nice reason to properly learn Haskell :-)
01:20:23 <Korollary> Maddas: What is your missing import feature ?
01:20:29 <Korollary> er, important
01:20:54 <Maddas> Hmm. Well, I don't even know too many, but none of them seems to support "alternatives" nicely
01:21:15 <Maddas> And all the browser-based ones just die for weird reasons :-(
01:21:25 <Cale> Maddas: have you seen CGoban2?
01:21:28 <Maddas> Yup!
01:21:32 <Korollary> Maddas: did you try xboard/winboard ?
01:21:35 <Maddas> Go just isn't my game :-)
01:21:37 <Cale> Inspired by its editor? :)
01:21:43 <Maddas> no, never seen its editor :-)
01:21:47 <Cale> oh, look at it :)
01:21:53 <Maddas> Korollary: I'm on OS X, but xboard doesn't support alternatives either
01:21:54 <Cale> You can manipulate the game tree
01:22:06 <Maddas> Hmm, I'll have a look :-)
01:22:17 * Korollary quit playing chess years ago
01:22:23 <Maddas> I should, too
01:22:32 <Maddas> I'm no good and don't improve, just waste time :-P
01:22:43 <Maddas> Korollary: j2chess seemed like a nice start, but it's freeware (not open sourced) so I can't just hack in the few features I'd like
01:22:45 <Korollary> I used to improve, but it takes a lot of time
01:22:50 * Maddas nods
01:22:55 <Maddas> I just... forget too quickly
01:23:00 <Maddas> (I'm not in any club, though)
01:23:03 <Korollary> a lot of pattern recognition that you forget once you stop playing
01:23:10 * Maddas nods
01:23:33 <Maddas> And this is one of the few things that I can think of programming that aren't definitely too hard :-P
01:23:35 <Korollary> grandmasters practice 8 hours a day I read
01:23:45 <Maddas> Oh, I'm sure, but I'm not even club level or anything :-)
01:23:49 * Maddas has a look at CGoban2's editor
01:24:23 <Korollary> it's time to write poker bots
01:24:31 <Maddas> heh 
01:24:46 <Maddas> Go seems to be one of the things that I'm even worse at than chess
01:24:55 <Korollary> I dont even know its rules
01:24:59 <Cale> Maddas: it takes a little dedication
01:25:03 * Maddas nods
01:25:11 <Maddas> I probably never had the patience/motivation necessary to really get into it
01:25:30 <Maddas> (I also don't personally know anybody who plays it)
01:25:34 <Cale> I highly recommend forcing it on yourself
01:25:36 <Cale> I play
01:25:42 <Korollary> You can play online probably
01:25:47 <Cale> there are a bunch of people here
01:25:50 <Cale> who play
01:26:06 <Korollary> Cale: Why do you recommend it ?
01:26:20 <Maddas> Cale: I'm sure it's great... I really need to start propelry once
01:26:21 <Cale> Korollary: It changes you in good ways :)
01:26:29 <Cale> Or really...
01:26:34 <Korollary> oh god, but I love myself so much as I am.
01:26:34 <Maddas> Properly, even.
01:26:37 <Cale> It reflects you back at yourself.
01:26:42 <Maddas> Eww. Nothing for me!
01:26:55 <Maddas> I get angry enough at myself when playing chess online :-P
01:27:03 <aleator> Cale: When I play Go I go nearly berserk. :/
01:27:14 <Cale> yeah, you have to overcome that :)
01:27:29 <Korollary> this sounds more like an FPS game than a board game
01:27:52 <Maddas> It's just on those days where I just sit and click without thinking because I'm too tired/lazy to go to bed
01:27:53 <dcoutts> beschmi, that bug was fixed in the latest gtk2hs release
01:28:02 <Maddas> And those days are way too often :-)
01:28:28 <Maddas> Korollary: No way, FPS games are way too easy on you, at least for me :)
01:28:39 <Korollary> "I am too lazy to go to bed" is a beautiful statement. We will never make computers understand natural languages...
01:28:49 <earthy> :)
01:29:07 <Maddas> Lazy /= tired /= exhausted :-)
01:29:19 <Cale> FPS games are about reflecting on instinct to some extent, but they don't require you to think about yourself in quite the depth that go does.
01:29:44 <Korollary> I was talking about the "berserk" part.
01:29:54 <Maddas> Cale: Indeed
01:30:02 <Cale> Korollary: that's due to anger :)
01:30:09 <Korollary> No, it's not anger
01:30:12 <aleator> Go is great way to get very angry.
01:30:13 <Maddas> It's worse :)
01:30:35 <Korollary> You have to have a high dose of adrenaline without being angry at anyone.
01:30:54 <Cale> Well, sometimes it's anger :)
01:30:57 <Cale> hehe
01:31:03 <aleator> There are so stupid mistakes in that game that can never happen anywhere else.
01:31:07 <aleator> +many
01:31:10 <Cale> usually not directed at your opponent
01:31:24 <Korollary> I like games where I can see my own stupidity
01:31:32 <Maddas> Right, with FPSs it's easy to just blame others for your mistakes, and you start over after a bit anyway (usually)
01:31:56 <Cale> with go, you start over after a bit as well
01:32:07 <Cale> but it's harder to blame your opponent
01:32:08 <Korollary> but are you a different when you start over ?
01:32:13 <Korollary> +person
01:32:19 <Cale> yes, usually, just a little :)
01:32:21 <Maddas> One of the few games that I can imagine making me as furiously angry at myself as chess does is golf, but that's no game for me anyway :-)
01:32:40 <Maddas> I usually get more and more angry until I get angry about having started playing chess at all :-P
01:32:43 <Maddas> (On the bad days, that is)
01:32:46 <shapr> I'd like to play Go, but I'm not happy with the clients I've found.
01:33:07 <aleator> whats wrong with kgs one?
01:33:21 <shapr> Hm, I forget...
01:33:34 <shapr> I'll try it when I get back from the bookkeeper.
01:34:05 <Maddas> fAlso, I can never get to memorize openings in Chess, which is _really_ annoying. I'm hoping that writing my own PGN viewer will find me ways to improve on that
01:34:07 <Korollary> bookkeeper has "oo, kk, ee" back to back...
01:34:29 <Korollary> Maddas: I hate openings
01:34:33 <Maddas> I love them!
01:34:42 <Maddas> I just hate that I can't keep them in my head
01:35:09 <Cale> When I play chess, I play it just well enough to know that I'm doing incredibly stupid things :)
01:35:11 <Korollary> well, that's the part I hate. It always comes down to that.
01:35:13 <Maddas> I only know one (the one I always play) for, um, the first 2 moves
01:35:20 <Cale> and have basically no tactical ability :)
01:35:21 <Maddas> Korollary: Yeah, it's annoying
01:35:29 <Cale> (though strategy is okay)
01:35:37 <Maddas> Cale: Me neither, but I'm so terrible at strategy that tactical blunders of the opponent is the only reason why I ever win ta all
01:35:40 <Maddas> at all, even.
01:36:01 <Korollary> all games have opening moves, so those are the most tried and perfected. If you don't know the openings as well as your opponent, you are at a big disadvantage.
01:36:18 <Maddas> Korollary: Hah, I hated it then, too. I always go for unorthodox openings, though.
01:36:29 <Cale> Essentially all of my ability at chess comes from playing go, if you can picture that.
01:36:38 <Cale> It doesn't work too well :)
01:36:47 <Maddas> My inability of playing chess stems from, uh, myself! :-)
01:36:54 <Korollary> Maddas: But there's not much you can do if you are the black
01:37:00 <Maddas> Korollary: You'd be surprised. :-)
01:37:19 <Maddas> But yeah, I know the feeling. I usually just seem to randomly move pieces as black, and somehow, for no reason I can imagine, I manage to win on occasions.
01:37:22 <Cale> But some things work out because I go for things like sente and shape.
01:37:33 <Cale> But I don't know how to really use the pieces.
01:37:55 <kosmikus> good morning
01:38:07 <Korollary> good $timeofday
01:38:09 <Maddas> I really like the way Go feels, I just don't think I'm good at it :-)
01:38:25 <Cale> Maddas: it takes time :)
01:38:40 * Maddas nods
01:38:45 <Cale> Lose your first 50 to 100 games as quickly as possible.
01:38:48 <Maddas> haha
01:38:59 <Maddas> I think losing is one of those things I never get bad at!
01:39:11 <Maddas> (Just annoyed at, but that only helps :-)
01:39:23 <Korollary> why as quickly as possible ?
01:40:04 <Maddas> Cale: I'll definitely start playing it someday. I'm just not in a hurry right now :)
01:40:26 <Cale> Korollary: because you need to see a bunch of shapes happening over and over
01:40:30 <Cale> and gain intuition
01:40:36 <Maddas> (Eh, but I also said that about playing chess or tabletennis in a club and unicycling :-()
01:40:38 <Cale> you can't play without some intuition
01:40:52 <Cale> because step by step evaluation is impossible
01:40:54 * shapr hugs his unicycle
01:41:06 <Maddas> Heh, intuition is the only thing that I have in chess, since I forget about everything else so quickly even during games
01:41:15 <Korollary> Cale: It sounds a lot like a case of massive pattern recognition training
01:41:20 <Cale> yes
01:41:40 <Maddas> It's absolutely hilarious to see me play against my flatmate. I have never lost yet, and it's absolutely mysterious why :-)
01:41:40 <Cale> eventually, once you have some intuition, your logic comes back into use
01:41:46 * Korollary tracks targets on an air-to-air radar
01:41:48 <Cale> Go is all about reasoning about intuition
01:42:05 <Maddas> He would always say "You can't do this because he'd do that, and if he'd do this then that", yada yada -- I usually never even noticed that and just do some move that felt right
01:42:32 <Korollary> Maddas: This number must be prime because it's "rough"
01:42:57 <Maddas> I'm not that good, I just noticed that thinking hard doesn't work well for me :)
01:43:17 <Korollary> "I just noticed that thinking hard doesn't work well for me" is yet another beautiful statement.
01:43:22 <Maddas> Korollary: He'd often win but doesn't because he sees a clever reply to the winning move that I didn't.
01:43:29 <Maddas> Korollary: Oh, just for chess :-)
01:43:44 <Cale> Maddas: A professional go player once said "You only need to see one move ahead. The right one."
01:43:45 <Maddas> (Am I missing something? ;-)
01:43:55 <Korollary> my brain cells are dying as the night goes on
01:44:03 <Maddas> Cale: Yeah, seems like I often get lucky that way.
01:44:09 <Maddas> (But then the bad days come :-)
01:44:23 <Maddas> Anyway, back to doing something useful :-)
01:44:37 <Maddas> (Hmm... now what?)
01:44:42 <Cale> Maddas: we'll have a game of go sometime :)
01:44:50 <Maddas> Sure. Where do you live?
01:45:01 <Cale> Oh, I was thinking on KGS
01:45:10 <Maddas> I know, me too, but I thought the real thing would be even cooler :-)
01:45:12 <Cale> I live in Brantford, Ontario, Canada currently.
01:45:46 <Cale> It's 4:45 am :)
01:45:48 <Cale> hehe
01:46:18 <Maddas> Ow :) Not quite around the corner, but maybe I'll be in the neighborhood sometime
01:46:33 <Maddas> Cale: Up early or up late? I hope latter :-)
01:46:40 <Cale> late
01:46:57 <Maddas> Holidays?
01:47:00 <Cale> yep
01:47:06 <Cale> finished undergrad
01:47:09 <Maddas> Cool :-)
01:47:12 <Korollary> he's a slacker
01:47:16 <Maddas> haha
01:47:21 <Maddas> Korollary: I've got holidays too!
01:47:28 <Korollary> so have I
01:47:35 <Maddas> :-)
01:47:37 <Korollary> until next week
01:47:40 <Maddas> Finished undergrad? ;-)
01:47:45 <Korollary> no, between jobs
01:47:48 * Maddas has his 2 weeks of summer holidays, starting this week
01:47:50 <Maddas> I see
01:48:15 <Maddas> Korollary: What's the new job, if I may ask?
01:48:27 <Korollary> software engineer, again
01:48:35 <Maddas> Nifty :)
01:49:00 <Korollary> I should try to resurrect my acting and modeling careers, alas, no time...
01:49:38 <Maddas> wow, that sounds cool
01:49:47 * Maddas is just another student
01:50:09 <Korollary> ugh, I hope you realize that I was joking around
01:50:18 <Maddas> bah :-P
01:50:28 <ulfdoz> Maddas: The other 10 weeks were fine as well, believe me. :)
01:50:44 <Maddas> ulfdoz: The other ten weeks?
01:50:47 <Maddas> Holidays? :-)
01:50:52 <Korollary> what's wrong with being a student ? I liked it when I was a student.
01:50:53 <ulfdoz> Maddas: yes.
01:51:18 <Maddas> Korollary: Nothing, really, apart from the annoying exams =)
01:51:19 <ulfdoz> Maddas: since mid of july.
01:51:58 <Maddas> ulfdoz: I spent most of that preparing for exams, I'm afraid. Didn't even have enough brain left for programming at the end of the day :-)
01:52:06 <Cale> I eventually want to be a student again :)
01:52:16 <Cale> hopefully not too distant future :)
01:52:23 <Maddas> I hope my university wants me to be one, too :-)
01:52:29 <Korollary> Cale: It ends at some point...
01:52:36 <Cale> but I really need a break at the moment
01:52:38 <ulfdoz> Maddas: I did that the last 2.5 years, it is quite hard.
01:53:04 <Maddas> ulfdoz: Yeah, especially if you find out afterwards that the examiners have a rather different idea of what to study :-)
01:53:09 <Cale> Korollary: well, eventually one goes into research :)
01:53:32 <Korollary> Cale: I must say that working for a while before grad school also gives you a good perspective. When you go to grad school, you are more certain about what you want to study.
01:53:38 <Maddas> ulfdoz: It is quite straining though, yeah.
01:53:51 <Cale> Korollary: is this what you did?
01:54:06 <ulfdoz> Maddas: In my opinion, they all think, you only need to study what they teach as single persons.
01:54:07 <Korollary> Cale: No, I went to grad school right after graduation.
01:54:35 <Maddas> ulfdoz: Yeah, and too many of the exams were about being fast, not being clever, which isn't really something I'm too good at.
01:54:50 <Cale> Maddas: I find the same thing about exams
01:54:50 <Maddas> Well, I usually am, but never at exams :-)
01:54:51 <ulfdoz> Maddas: full ack.
01:55:05 <Korollary> Cale: but now, if I were to go back to school, I'd be ten times more certain, focused and ready to study.
01:55:14 <Cale> I'm terrible with sit in a room and write madly for 3 hours type exams
01:55:25 <Maddas> Yeah, and all except one of our exams was like that. Bah!
01:55:41 <Maddas> (That one happened to be the one where I really didn't understand the matter :-)
01:56:01 <Korollary> Examining people is hard, and the worst thing is that you can get away with giving poor exams.
01:56:07 <Cale> I rather enjoyed my take home 72 hour model theory exam :)
01:56:24 <Maddas> It's only like that for the first two years, here, after that exams get more, uh, intelligent (pardon my arrogance)
01:57:00 <Maddas> The first two years is where selection happens, so competition is large, and that's what I dislike about it -- I really suck at practising boring things, so others naturally do better :-)
01:57:10 <Korollary> at some point, grades don't matter so much. We never cared what the GPA's where for any of our job candidates.
01:57:17 <Maddas> (We have old exams to practise with, over 400 pages of them.)
01:57:59 <Maddas> Korollary: Right, but 40-50% of us will (quite certainly) drop out due to this exam, that's normal and very annoying :)
01:58:00 <cjb> Korollary: Depends what you want to do.  You're not gonna get on a PhD course with a bad GPA.
01:58:20 <Korollary> cjb: That's why I said "job" heh.
01:58:42 <cjb> Well, you said "at some point, grades don't matter so much".  :)
01:59:08 <Korollary> "so much" :)
01:59:21 <{Arias}> hi!
01:59:24 <Korollary> hi !
01:59:31 <{Arias}> x)
01:59:39 <Maddas> :-)
01:59:49 * Maddas flexes
02:00:05 <araujo> {Arias}, Hola
02:00:09 * Korollary feels what is now known as "too lazy to go to bed"
02:00:39 <{Arias}> hola araujo :P
02:00:48 <Maddas> Days should be longer so I'd actually go to be at reasonable times :-)
02:01:23 <Korollary> days are exactly as long as they need to be. Just your expectations of a day are not reasonable.
02:01:59 <Korollary> I have this fear that if I go to bed now, the sleep won't be as good as it can be. I fear a failure.
02:03:02 <cjb> Heh.
02:04:17 <{Arias}> araujo spanish?
02:07:53 <araujo> {Arias}, no, but that's my native idiom :-]
02:08:37 <{Arias}> where are you from?
02:08:49 <araujo> im from venezuela
02:08:55 <dons> new maps!
02:08:56 <dons> http://www.haskell.org/hawiki/HaskellUserLocations
02:09:01 <araujo> haha
02:09:10 <{Arias}> jeje yo si soy español
02:09:14 <{Arias}> :P
02:09:18 <araujo> :-]
02:09:23 <araujo> {Arias}, haskeller?
02:09:29 <{Arias}> begining...
02:09:34 <araujo> sweet
02:09:44 * araujo wonders if shapr for the tour
02:09:52 * araujo wonders if shapr *is around* for the tour
02:10:01 <{Arias}> xD
02:10:17 <dons> anyone missing should stick their coords on the wiki, or msg them to me, and I'll try to update the maps automagically
02:10:19 <{Arias}> i'm reading a tutorial called "yet another haskell tutorial"
02:10:59 <araujo> {Arias}, Don't you know "Razonando Con Haskell"?
02:11:25 <{Arias}> no... go!
02:11:57 <araujo> It is a book written by professors from the Universidad de MÃ¡laga
02:12:03 <dons> shapr, how are the new maps? do they meet with "shapr's seal of approval (tm)"?
02:12:04 <araujo> In your country :-]
02:12:32 <araujo> It's pretty good, you should get it
02:12:41 <{Arias}> ok thanks
02:12:43 <{Arias}> :D
02:13:58 <araujo> Actually one of the best spanish book i've read
02:14:59 <kosmikus> -win 12
02:15:09 <kosmikus> sorry
02:15:10 <araujo> Hi kosmikus
02:15:18 <kosmikus> hey araujo
02:15:25 <araujo> :-]
02:15:38 * kosmikus hates .de keyboard layout
02:15:44 <araujo> hah
02:16:02 <araujo> kosmikus, makes it too difficult for english?
02:16:28 <{Arias}> what keyboard layout?
02:16:29 <earthy> and programming
02:16:35 <kosmikus> inconvenient
02:24:17 <Oejet> kosmikus: It's quite easy to switch the layout.  You are not typing with two fingers, are you? ;-)
02:25:12 <kosmikus> Oejet: I do. That's why I made the mistake. I switched to .de layout temporarily because I had to enter my name and address. And then I forgot to switch back before typing here ;)
02:25:15 <earthy> to that theme (in german): http://www.spiegel.de/unispiegel/schule/0,1518,378215,00.html
02:26:11 <kosmikus> Oejet: I do switch the layouts, I mean. I don't type with only two fingers ...
02:26:13 <Maddas> earthy: Hahaha.
02:27:15 <Maddas> earthy: Sounds impressive, though! I wonder how fast he must move his fingers.
02:28:00 * Oejet doesn't even think that fast.
02:28:26 <Maddas> You don't need to think fast to type fast if just copying some text :-)
02:28:31 * earthy can type at roghly that speed
02:28:38 <earthy> but that's usign ten fingers
02:28:40 * Maddas can type faster, but not with two fingers
02:28:41 <earthy> and making mistakes
02:28:56 <Maddas> Truly impressive, to think that he can type that fast with two fingers.
02:29:05 * Maddas can't really imagine seeing that :-)
02:29:30 <Maddas> ...but then again, I saw a movie of Horowitz playing piano yesterday, so it can't be /that/ bad.
03:26:10 <bourbaki> moin
03:28:19 <Maddas> Morning
03:38:40 <aleator> ls
03:38:58 <aleator> Bah.
03:42:40 <ulfdoz> Kaffee!
03:42:45 <ulfdoz> ECHAN, sorry
03:46:20 <b0gg1e> hi!
03:49:42 <Itkovian> hmm ... what's wrong with this? do { f <- System.IO.openFile x System.IO.ReadMode; c <- System.IO.hGetContents f; l <- lines c; return  l ; } (the bit giving trouble is the lines c thingie)
03:50:48 <dcoutts> Itkovian, lines is a pure function, it's not monadic
03:51:07 <dcoutts> try "let l = lines c" instead of "l <- lines c"
03:51:27 <dcoutts> @type lines
03:51:32 <lambdabot> String -> [String]
03:51:47 <Lemmih> or 'return (lines c)'
03:55:42 <dcoutts> or if we're going for compact: liftM lines $ openFile x ReadMode >>= hGetContents
03:56:47 <dcoutts> or: openFile x ReadMode >>= hGetContents >>= return . lines
03:57:44 <Lemmih> or: liftM lines . readFile
03:57:58 <dcoutts> heh
03:58:09 <dcoutts> you win
03:58:36 <dcoutts> @type Monad.liftM lines . Io.readFile
03:58:37 <lambdabot> bzzt
03:58:41 <dcoutts> @type Monad.liftM lines . IO.readFile
03:58:42 <lambdabot> FilePath -> IO [String]
03:59:06 <phas> hi, i need a little explanation on something that i cannot understand. while i use the notation "data <- readLine", the type of data is supposed to be "String" or "IO String"?
03:59:20 <dcoutts> String
03:59:21 <ProfTeggy> phas, String
03:59:46 <ProfTeggy> <-- dog slow
03:59:48 <dcoutts> it's the "<-" which 'extracts' the String from the IO String
04:00:03 <phas> uuuuhm
04:00:51 <kzm> Hi! Isn't there an "assert" shipped with the libraries?
04:01:03 <dcoutts> @index assert
04:01:05 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
04:01:05 <Lemmih> @type Control.Exception.assert
04:01:07 <lambdabot> forall a. Bool -> a -> a
04:01:42 <kzm> Heh - can't quite get used to asking the bot first.  Thanks!
04:02:09 <dcoutts> kzm, s'ok it's here so we can help to answer your questions
04:02:31 <dcoutts> we don't expect everyone to remember the lambdabot commands
04:02:49 <kzm> @why is it in Control.Exception anyway?
04:02:56 * kzm is trying real hard :-)
04:03:05 <lambdabot> Maybe you meant: ghc wn
04:03:48 <dcoutts> kzm, I guess it's vaugly related to exceptions
04:07:49 <kzm> Hmm... I suppose it can be caught, at least. :-)
04:10:51 <tomaszz> @type foldr id
04:10:52 <lambdabot> forall b. b -> [b -> b] -> b
04:10:54 <Lemmih> dcoutts: @type Control.Exception.AssertionFailed
04:11:05 <Lemmih> urk.
04:11:30 <tomaszz> @hoogle foldr
04:11:32 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
04:11:32 <lambdabot> Prelude.foldr1 :: (a -> a -> a) -> [a] -> a
04:11:32 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
04:12:08 <dcoutts> Lemmih, btw I didn't notice a big difference between the two threading systems. I assume it's really noticalbe for you?
04:12:35 <tromp> l
04:12:42 <tromp> hi folks
04:13:14 <Lemmih> Haven't done a lot of testing with -threaded on.
04:13:35 <dcoutts> Lemmih, what exactly happens when a key press event takes place? does the work get done there and then in the event handler or is it handled in a different thread (like with Yi's input handler) ?
04:13:36 <Lemmih> But the delay is definitely annoying without it.
04:14:44 <dcoutts> Lemmih, it might be that all we need to do is yield to the processing thread after getting a char input. So we don't have to wait 'til next time that thread gets a chance to run.
04:15:19 <Lemmih> CommonSense spawns a thread and restarts it everytime the buffer is changed.
04:16:10 <dcoutts> ok and so what is it that's taking a long time each time a key is pressed? where does the latenc come from?
04:16:18 <dcoutts> latency
04:17:20 <Lemmih> I would guess that something in the parser blocks the other threads for a while.
04:17:37 <dcoutts> Lemmih, the current setup works like this: when the Gtk main loop is idle (ie it's finnished with tasks like redrawing the screen) it gives the GHC RTS a chance to run Haskell threads every N miliseconds.
04:18:38 <dcoutts> so under that scheme, transfering from one thread to another could take up to N miliseconds unless an explict yield is added
04:19:34 <dcoutts> if we can identify this as a problem then I can look at doing something a bit more sophisticated.
04:20:00 <dcoutts> but I'd like to properly understand what's going on first
04:20:59 <dcoutts> Lemmih, oh hmm, you mean the ghc thread is blocking the whole process? hmm
04:21:36 <dcoutts> Lemmih, that's possible. GHC may be using cheating IO for reading its .hi & .hs files.
04:21:48 <dcoutts> since it's used to being the only thing running.
04:22:10 <dcoutts> I suspect ghc's 'slurp' thing may be the culprit.
04:22:21 <dcoutts> @seen JaffaCake
04:22:22 <lambdabot> I saw JaffaCake leaving #haskell 2 days, 19 hours, 11 minutes and 44
04:22:22 <lambdabot> seconds ago, and I have missed 1 minute and 10 seconds since then.
04:22:57 <Lemmih> It shouldn't read any files after its first run.
04:23:35 <dcoutts> Lemmih, another thing to do might be to just pause for a short time before actually doing the ghc parse. so if the user is typeing quickly we don't actually end up doing anything before killing & restarting the thread.
04:24:06 <dcoutts> it'd be fine for the underlining to only appear a second or so after the user stops typing.
04:24:28 <dcoutts> since for large files we're going to get that behaviour anyway.
04:24:47 <Lemmih> ah yes.
04:24:48 <dcoutts> so perhaps just add a threadDelay at the beginning of the ghc parsing/typechecking thread.
04:25:03 <dcoutts> 1 second out to do it
04:25:07 <dcoutts> out/ought
04:26:17 <psi> @hoogle [a] -> [a] -> Bool
04:26:18 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
04:26:18 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
04:26:18 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
04:29:10 <psi> I'd like a 'contains', or something
04:29:17 <dons> dcoutts, Lemmih, I'm about half way through the rewrite of Yi and the yi plugin to use the new api
04:29:37 <dcoutts> dons, oh the new ide shell EditorPage API?
04:29:58 <Lemmih> Hurrah.
04:30:25 <dons> yep
04:30:31 <dcoutts> dons, cool
04:30:46 <dons> the EditorPage stuff, and factoring out assumptions about a standalone ui
04:30:58 <dcoutts> dons, after than you'll be able to help advise me on how to improve that api
04:31:29 <tomaszz> @hoogle [b] -> [b] -> Bool
04:31:30 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
04:31:30 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
04:31:30 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
04:31:31 <dons> also, writing files is now working :)
04:31:45 <tomaszz> @hoogle [b] -> ([b] -> Bool)
04:31:46 <kolmodin> great news :)
04:31:47 <lambdabot> No matches, try a more general search
04:31:56 <dcoutts> dons, oooh. so we're now actually dangerous :-)
04:32:16 <dons> not pushed back into the main repo yet. do a bit more testing first
04:32:47 <dcoutts> dons, the current EditoPage doesn't allow some resource conservation strategies that we'll want to use.
04:33:00 <ProfTeggy> bye all
04:33:59 <dcoutts> dons, I'd really like to get us browsing fptools-sized projects with the appearance that all files are open but with sensible resource usage.
04:35:46 <dcoutts> dons, which means the EditorPage api needs to be sufficiently flexable and the Yi/DemoEditor bits will need to think about resource usage (eg saving/restoring state to/from disk)
04:36:13 <dons> ah, ok. this is certainly doable.
04:36:37 <dcoutts> we don't want to keep 100's of GtkTextBuffer objects around all the time. Then should be constructed & disposed as needed.
04:36:44 <dcoutts> Then/They
04:36:56 <dons> well, we can have custom finalisers, perhaps
04:37:01 <dons> or explictly run them
04:37:27 <dcoutts> the EditorPage api provides events for when pages are exposed and hidden which can be used.
04:37:56 <dons> ah, right. of course.
04:38:25 <psi> hm. is my hugs broken?
04:38:27 <psi> Prelude> :m List
04:38:28 <psi> ERROR - Cannot find module "List"
04:38:37 <dcoutts> psi, :l List
04:38:42 <psi> oh, thanks
04:39:22 <dcoutts> dons, though we might want to not dump/restore every time a page is hidden/shown but some slightly more sophisticated caching strategy.
04:40:29 <dcoutts> eg consider the use cas of jumping to definition/documentation and jumping back very soon afterwards.
04:41:17 <dons> sure.
04:41:40 <dcoutts> so the EditoPage api should not preclude strategies such as a per-window cache with lru eviction policy.
04:42:30 <dons> updated #haskell user maps : http://www.haskell.org/hawiki/HaskellUserLocations
04:42:41 <sieni> is there a nice diagram somewhere about operator precedence and associativity in haskell? (Preferably printable)
04:42:57 <Lemmih> Hi davve.
04:43:06 <davve> lemmih.
04:43:21 <sieni> likr: http://www.isthe.com/chongo/tech/comp/c/c-precedence.html
04:43:29 <dons> i've generated some a nice global projection, and some localised maps. any opinions?
04:43:36 <dcoutts> dons, nice
04:44:02 <Lemmih> sieni: Operator precedence isn't fixed in Haskell.
04:44:04 <dcoutts> davve, oh I've now pushed those GUI state management changes I was talking about.
04:44:30 <Lemmih> (or well, not for the user defined operators, that is)
04:44:36 <davve> dcoutts, oh.. I'll have a look
04:45:08 <dcoutts> Lemmih, sieni: though the precedence of operators from the Prelude is fixed.
04:45:14 <Maddas> haha, lambdabot :-)
04:45:19 <Lemmih> dcoutts: But they are redefinable.
04:45:23 <dcoutts> @botsnack
04:45:23 <lambdabot> :)
04:45:26 <dcoutts> Lemmih, true
04:45:28 <Maddas> dons: They look very cool!
04:45:29 <Lemmih> sieni: GHCi can tell you what you want.
04:45:32 <kolmodin> dons: looks nice
04:45:33 <araujo> Morning
04:46:13 <davve> kolmodin, hur går det med ipopen?
04:46:23 <kolmodin> the HaskellUserLocations page is immutable, perhaps someone is editing it?
04:46:28 <dons> anyone not there, just add your latitute and longitute to the wiki. wikipedia for your home town, and google maps, are useful ways to find these magic numbers
04:46:47 <dons> kolmodin, the entire wiki requries login now, due to spamming I think
04:47:01 <kolmodin> davve: gjort kravspec och halva designspecen. kvar är att implementera, testa och post mortem
04:47:08 <kolmodin> dons: ah, ok
04:47:15 <dons> if anyone just wants to add a coordinate point, they can msg me the numbers and i'll add them
04:47:24 <davve> kolmodin, okay.. i'm going down to NC to work on the compiler
04:48:08 <dcoutts> dons, my  coords are the same as Igloo's
04:48:08 <kolmodin> davve: ok, I've got work to do with my compiler as well
04:48:47 <kolmodin> davve: I've not implemented any optimizations yet, and haven't choosen an extension
04:48:55 <dons> so, my lesson is: xplanet is nicer than xearth or xglobe :)
04:49:05 <dons> dcoutts, ok. i'll add it
04:49:06 <davve> kolmodin, me neither
04:49:16 <rep> heh
04:50:48 <kolmodin> dons: so somehow I have to register or login..?
04:51:40 <kolmodin> you may find your exact position with this site: http://www.maporama.com/
04:51:45 <kolmodin> very nice
04:52:17 <sieni> Can one get the exact location from google maps somehow
04:52:45 <dons> kolmodin, you click on "UsrePreferences" and get a login and a passwd. then you go back to the maps page, and refresh. then click on "editPage" to add an entry :)
04:53:16 <sieni> ok, found it
04:53:28 <kolmodin> ok, nice, thanks
04:53:49 <dons> I'll probably just cron job my script to regenerate the images once a day or so
04:57:22 <{Arias}> hi
04:57:27 <kolmodin> I've added myself now
04:57:38 <{Arias}> why when i try to connect to a socket with handler <- connectTo server port
04:57:59 <{Arias}> it throws a exception? (getServiceEntry: does no exists (no such service entry)
05:00:47 * dcoutts has updated his coordinates for greater accuracy
05:01:37 <kolmodin> the location I entered shoud be my house according to maporama
05:02:04 <beschmi> {Arias}: is there an entry in /etc/services for the service string you're using?
05:02:41 <{Arias}> emmm I'm using windows
05:03:08 * Oejet is not allowed to edit the page.  55.707796        12.566310       "Oejet"               # Peter Eriksen
05:03:21 <{Arias}> i don't know :S
05:03:26 <cjb> {Arias}: Use a port number directly, rather than a service name.
05:04:17 <dons> Oejet,  I'll add you
05:05:28 <dons> time to regenerate the map, I think.
05:05:29 <{Arias}> a port number directly? i don't understand
05:05:44 <Oejet> dons: Thanks.
05:05:57 <{Arias}> server = "localhost"
05:05:57 <{Arias}> port = PortNumber 8080
05:06:01 <{Arias}> handler <- connectTo server port
05:06:12 <MarcWebe1> basti_: Hi, are you here? I still have problems with haskore. I could'nt manage to concat music.
05:10:47 <dons> new map. thanks for the new euro-haskellers :)
05:11:26 <Lemmih> Hi JaffaCake.
05:11:30 <JaffaCake> hiya
05:11:34 <rep> so JaffaCake, you were right, ghc threads are _much_ faster than os threads, at least to get created
05:11:45 <JaffaCake> rep: phew :)
05:11:55 <dons> hehe
05:12:12 <rep> and process scope os threads are also _much_ faster than system scope os threads
05:12:41 <kzm> Is everybody happy with the current trend to avoid prefixing functions etc. with module/type names?  (I.e use Set.empty instead of emptySet)
05:12:42 <JaffaCake> what are process scope os threads?  like the kind that FreeBSD has?
05:13:11 <rep> JaffaCake yes.. threads that the kernel doesn't know about (at least until you do a blocking syscall)
05:13:29 <JaffaCake> rep: right
05:13:39 <dons> kzm, I think this is the convention now that we have a hierarchical name space.
05:13:55 <JaffaCake> kzm: seems the right way to go, IMO
05:14:31 <kzm> I agree in general, but I'm a bit annoyed with the overloading of common prelude names.
05:15:12 <kzm> I don't really want to qualify *everything*, but otoh, having hiding-clauses are a pain too.
05:16:20 <beschmi> rep: did you test how many threads you can keep around with FreeBSD at the same time?
05:16:34 <rep> beschmi yes
05:16:47 <rep> beschmi it depends on how much ram you have
05:17:11 <rep> i was able to have 50000 threads, on a 8GB dual opteron :)
05:18:06 <rep> but only around 3000 on a machine with only 256MB of ram
05:18:35 <rep> if you use 1:1 (system scope) threads, though, you can only have 1500
05:18:51 <rep> i'm not sure if it's tunable or what
05:19:25 <beschmi> the limit in my tests (linux kernel 2.6, 512 MB) was somewhere around 500
05:19:25 <rep> of course i'm not so sure why anyone would want to have so many threads
05:20:17 <rep> well, i reduced the stack size to the minimum (2048 bytes on i386 and amd64)
05:20:38 <rep> otherwise each thread uses around 1MB of stack, which is ridiculous
05:21:02 <ndm> dons, you'll be happy to know that i've decided to go fully darc's with hoogle3
05:21:19 <ndm> not quite yet, but eventually when i get the chance to convert everything and find webspace etc.
05:21:22 <dons> yay!
05:21:28 <dons> @karma+ ndm
05:21:29 <lambdabot> ndm's karma raised to 4.
05:21:46 <dons> there's much goodness in darcs :)
05:21:55 <ndm> yeah, sounds like it
05:22:04 <ndm> but it will take me a while to get used to
05:22:20 <ndm> however, in order to seek other contributions more easily, it must be done...
05:22:25 <dons> oh, probably not that long. switching from cvs was pretty easy for me.
05:22:43 <dons> but yes, it's good for getting code from other people.
05:22:50 <ndm> its switching from a GUI client, to a command line
05:23:02 <ndm> i learnt CVS with a command line, but its been a while since I had to use it that way
05:23:22 <dons> ah, isn't there a gui darcs? for windows?
05:23:30 <dons> I think there's some sort of gui anyway
05:23:44 <ndm> just a random guess, but it will suck compared to tortoisecvs
05:23:56 <ndm> wincvs is so appallingly bad, its far worse than a command line
05:24:07 <dons> the command line is good for your soul ;)
05:24:12 <dons> or karma
05:24:27 <beschmi> rep: oh, i just used the default settings and a modified version of the test programm posted by JaffaCake some does ago: http://haskell.org/hawiki/HaskellIrcPastePage
05:24:47 <ndm> dons, i have to argue against that every single day...
05:25:16 <beschmi> there is also darcsum for emacs, it's pretty cool. but i don't know if it works on windows
05:26:58 <humasect> is there log of HaskellPastePage?
05:27:12 <earthy> unfortunately, not, afaik
05:27:50 <humasect> aww, it was gigantic just a while ago
05:29:02 <rep> beschmi that's probably why you were only able to get 500
05:31:09 <MarcWebe1> Anyone familiar with haskore?
05:33:42 * earthy would like to be
05:33:50 <earthy> but alas, time and other priorities
05:34:24 <humasect> i hear it still works for being a 2000 release?
05:39:05 <MarcWebe1> Do you know any tools to create header files from Microsoft COM libraries? I want to try using them with haskell and hdirect..
05:49:03 <timbod> on a gui for darcs: do you guys use meld (http://meld.sourceforge.net/)? It's just a graphical diff/merge tools, but "meld _darcs/current ." sure beats "darcs whatsnew".
05:50:06 <ndm> timbod, that looks pretty cool
05:50:48 <ndm> but doesn't have a windows package :(
05:51:08 <timbod> It works pretty well for viewing uncomitted changes starting with a directory tree view.
05:51:39 <timbod> oh sorry about win32. I don't live there...
05:55:04 <[Blownose]> if i want to divide something how do i force it to be an Integer (not Fractional) ?
05:56:00 <Philippa> annotate it?
05:56:06 <Philippa> someexpression :: Integer?
05:57:04 <[Blownose]> i want to be able to divide two values and return it as an Integer ?
06:18:21 <shapr> Wow, 25 edits for HaskellUserLocations
06:18:40 <shapr> CosmicRay: y0, where's the HWN repo again?
06:18:51 <shapr> I want to submit a line or two about HaskellUserLocations.
06:19:18 <xerox> dons: is your script which adds type signatures automagically available somewhere?
06:19:30 <shapr> haha, lambdabot has its own entry!
06:19:42 <xerox> :-D
06:19:57 <dons> xerox, yes, let me see...
06:19:58 <shapr> Whoa, I'm by far the northernmost Haskeller on the map.
06:20:01 <dons> shapr :)
06:20:15 <shapr> dons: These images are much better!
06:20:39 <dons> yeah, xplanet uses nasa images for the glob.e
06:20:46 <shapr> Next step, include a shell script in the page so that the impatient can update the images and link to the ones generated.
06:20:54 <boegel> shapr: HWN -> http://sequence.complete.org/
06:21:01 <xerox> @where hwn
06:21:02 <lambdabot> http://sequence.complete.org/
06:21:15 <dons> i'm just downloading a much higher-res image now so the zoom in on western europe will be less fuzzy
06:21:41 <dons> i've got it scripted atm, and was going to just have the script pull the entries off the page nightly
06:21:42 <xerox> @wiki HaskellUserLocations
06:21:44 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
06:21:44 <earthy> sigh.
06:21:50 <earthy> who fucked with the updated location for kosmikus?
06:22:13 <shapr> dons: Ah spiffy
06:22:31 <dons> earthy, oh. it got reverted somehow. hmm.
06:22:40 <xerox> Woot, when did you change the map?  How nice!
06:22:51 <dons> xerox, just today.
06:23:19 <dons> earthy, do you have the old value somewhere. (it was probably me when I was syncing the values people were /msging me with :/ sorry!
06:23:20 <xerox> Great :-)
06:23:45 <earthy> :)
06:23:48 <kosmikus> earthy: you had updated my coordinates?
06:24:12 <shapr> Oh hey, EmacsChannelQuotes includes a script to munge the page source into a fortune file, I think that'd be fun for QuotesPage.
06:24:14 <earthy> Bonn	50.46N	07.06E
06:24:27 <earthy> that's closer than what's presently there
06:24:36 <dons> shall I add that, kosmikus?
06:24:41 <shapr> kosmikus: Happen to have a GPS receiver? :-)
06:25:15 <shapr> The ultimate in geekiness would be a shell script running on my phone that updates the wiki with my GPS coords in realtime.
06:25:17 <kosmikus> dons: sure
06:25:33 <earthy> shapr: that'd be *sick*. :)
06:26:30 <dons> or scarry..
06:26:32 <shapr> "oh look, shapr's gone to the grocery store *again*. Three times in one day... maybe he's flirting with the cashier chick?"
06:26:41 <dons> hehe
06:27:16 * SamB wishes gtk2hs would build according to the detected packages. supposes that he can only really expect that from release versions...
06:27:34 <xerox> SamB: doesn't it?
06:29:12 <shapr> I saw a really cool watch for 700 euro that includes a GPS receiver. It made me realize I'd like to have a spatial TODO list. For example, the next time I'm near the grocery store, I should get fruit.
06:29:19 <Igloo> Heff's is out of date too
06:29:43 <rep> shapr sounds like a great idea.
06:29:50 <xerox> heh
06:29:52 <rep> the spatial todo list, that is
06:29:56 <earthy> that's a contextually aware TODO list
06:30:01 <earthy> and yes, it *is* a great idea
06:30:21 <shapr> Realtime GPS updates would be particularly nifty for spatial FOAF lists. "Notify me when a direct friend is within 50km."
06:30:37 <earthy> hm. that doesn't really work in .nl
06:30:49 <shapr> Then you could have spontaneous geek meetings.
06:30:51 <rep> sounds like something like google would do
06:30:58 <shapr> rep: Don't you work for google?
06:31:00 <xerox> I knew :D
06:31:00 <earthy> I mean, my gf is almost half a country away
06:31:05 <earthy> at 60km. ;)
06:31:14 <rep> shapr haven't started yet
06:31:29 <rep> xerox hehe
06:32:00 <shapr> earthy: GPS receivers have a resolution of 3-4 meters I believe. Good receivers have slightly less than a meter, iirc.
06:32:18 <earthy> shapr: the problem being that .nl is *densely* populated
06:32:32 <earthy> 50km would be an insane radius
06:32:44 <shapr> Ah, you mean about the spatial notifications. In that case, you'd have an option for "in the same pub" ;-)
06:32:51 <earthy> I mean, there's on the order of a couple of million people in a 50km radius from here
06:34:05 <earthy> but yeah, spatial autocontexting would be great
06:34:05 <xerox> http://blog.moertel.com/articles/2005/09/13/scope-herding-with-delimited-continuations
06:36:10 <shapr> Ah, I didn't know tom had a blog.
06:36:15 * shapr adds it to his feeds.
06:36:45 <rep> he rox
06:37:04 <autrijus> hm, I'm editing the Haskell wikipedia article
06:37:09 <autrijus> is it sane to write fib like this?
06:37:10 <autrijus> fib = 1 : 1 : [ a+b | a <- fib | b <- tail fib ]
06:37:18 <earthy> yes
06:37:34 <earthy> it is a well-known example
06:37:39 <dons> but there's the nicer zipWith example
06:37:44 <earthy> exactly
06:37:53 <earthy> 1 : 1 : zipWith (+) fib (tail fib)
06:38:35 <autrijus> it is however harder for a nonhaskell person's "comprehension" (pun intended)
06:38:44 <autrijus> so I'm thinking keep both version
06:38:50 <earthy> yes, do
06:38:51 <autrijus> as a contrast of sugar and power
06:39:04 <dons> autrijus, add yourself to the #haskell user's locations! http://www.haskell.org/hawiki/HaskellUserLocations
06:39:13 <autrijus> dons: I'm all over the world now :)
06:39:21 <dons> hehe true.
06:39:25 <shapr> See, autrijus needs realtime GPS update just to know where he is...
06:45:09 <xerox> I have a delimited continuations example!
06:45:39 <xerox> I wrote it yesterday:  fib n = reset ((+) (shift (\k -> if n > 0 then k (fib (n-1)) else 1)) (shift (\k -> if n > 1 then k (fib (n-2)) else 1)))
06:46:01 <rep> clearly not as cool as  1 : 1 : zipWith (+) fib (tail fib)
06:46:03 <rep> :P
06:46:06 <ndm> autrijus: i think the two vertical bars in a list comprehension is confusing
06:46:11 <ndm> to me at least
06:46:20 <autrijus> dons: where will you be during OSDC?
06:47:04 <autrijus> Dec 5/7
06:47:06 <xerox> rep: uh, it's way cool.
06:47:14 <xerox> autrijus: where is it?
06:47:22 <autrijus> dons: Monash University
06:47:26 <Philippa> I'm a lot less keen on list comprehensions than I was when I first learnt haskell
06:47:34 <Philippa> they feel like they get in my way now
06:47:41 <rep> autrijus how do travel so much?
06:47:46 <dons>   oh, hmm. not sure.
06:47:57 <shapr> Someone on LtU recently mentioned that Python's list comprehensions are much more intuitive than anything in Haskell.
06:48:10 <dons> I'll check it out, autrijus.
06:48:47 <Igloo> Philippa: How so? I think they're lovely for things like [ x | Just x <- xs, even x ]
06:49:01 <autrijus> Philippa: yes, me too, but I still remember it made things much easier at first.
06:49:33 <Lor> list comprehensiosn are just a compact specialized syntax for the do notation.
06:49:34 <autrijus> (more than once, when coding with wolfgang and spj, I caught myself going overboard pointless, much to my embarrasement ;))
06:50:03 <yaarg> the evolution of a haskell programmer thing is great
06:50:04 <Philippa> Igloo: yeah, I should try to remember them more often for stuff like that
06:50:16 <yaarg> (http://www.willamette.edu/~fruehr/haskell/evolution.html)
06:50:23 <Lor> Personally, I wouldn't mind if the comprehension syntax was generalized to arbitrary monads.
06:50:51 <xerox> Lor: what about the error messages? :-)
06:51:05 <Philippa> error messages. I shoot myself in the foot by missing out a return once in a while, hate to think what I'd do with monad comprehensions that weren't syntactically differentiated from list comps
06:51:44 <CosmicRay_> good morning
06:51:48 <autrijus> dons: I may attend OSDC there, and if you are in Sydney, I'd extend my stay and visit you for a few days if you are up to it
06:51:50 <Lemmih> dons: You have a script that can add type signatures automatically?
06:51:57 <shapr> CosmicRay_: There's two of you here now.
06:52:10 <CosmicRay> shapr: perhaps your vision is just blurry ;-)
06:52:12 <autrijus> rep: by not getting any long term onsite jobs :)
06:52:30 <rep> autrijus heh. so you pay for the tickets yourself?
06:52:31 <autrijus> shapr: how are you feeling nowadays? should I arrange to visit you in Stockholm or not? :)
06:52:44 <autrijus> rep: most of the time yes... some times the conference would sponsor me
06:52:46 <timbod> Igloo: why the Just  in your listcomp example? Won't this risk pattern match failure?
06:52:59 <rep> autrijus i see, cool :)
06:53:00 <Igloo> No, that's the lovely thing about it
06:53:20 <autrijus> timbod: patmatch failure equals filter
06:53:22 <xerox> Igloo: is it on the wiki somewhere?
06:53:31 <Igloo> @plugs [x | Just x <- [Nothing, Just 5, Just 6, Nothing]]
06:53:33 <lambdabot> [5,6]
06:53:37 <Igloo> "it"?
06:53:51 <xerox> This abstraction, maybe along other cool ones!
06:54:07 <dons> autrijus, sounds good. you should visit our research group perhaps.. http://www.cse.unsw.edu.au/~pls/
06:54:13 <Igloo> No idea
06:54:20 <timbod> That's cool, I though filters had to come after the comma, (as you had "even")
06:54:24 <xerox> ...or a TMR article :-)
06:54:31 <autrijus> dons: yes :)
06:54:46 <autrijus> dons: so if you'll be around by that time let me know.
06:54:49 <Philippa> timbod: two filters
06:55:03 <dons> what time, Dec 5/7. yes. that should be fine.
06:55:33 <autrijus> so if I'm to visit, would it better be pre or post the conf?
06:55:43 <timbod> Philippa: "two filters" meaning the pattern match and the call to even?
06:56:04 <dons> hmm. doesn't matter much either way to me at least, autrijus.
06:56:12 <autrijus> dons: cool!
06:56:17 <autrijus> i'll keep you posted then.
06:56:23 <dons> cool. please do.
06:58:31 * dons discovers that hi-res images can really stress out a laptop
07:00:15 <timbod> dons: I note on the hide page it says that gtk2hs runs on osx. Is this currently true (or a future plan)?
07:00:31 <Philippa> timbod: yup
07:00:54 <dons> gtk2hs surely does
07:01:15 <timbod> is that native, or via the X server?
07:02:01 <dons> dcoutts knows a lot more about this than me :S
07:03:28 <beschmi> timbod: there is a gtk native port for osx in work: http://micke.hallendal.net/archives/2005/10/gtk-macosx.html
07:03:36 <timbod> Phillipa: thanks - that's my new haskell feature for the day.
07:17:37 <humasect> @hoogle (IO a, IO a) -> IO (a, a)
07:17:38 <lambdabot> No matches, try a more general search
07:17:50 <humasect> @hoogle (m a, m a) -> m (a, a)
07:17:51 <lambdabot> No matches, try a more general search
07:18:48 <Lemmih> @type uncurry (Monad.liftM2 (,))
07:18:49 <lambdabot> forall (m :: * -> *) a1 a2. (Monad m) => (m a1, m a2) -> m (a1, a2)
07:19:28 <Philippa> humasect: \f g -> do {a <- f; b <- g; return (a,b)}. Feel free to name it.
07:19:34 <Philippa> alternatively, there's a func that does it for lists
07:19:45 <Philippa> just not one for tuples (for obvious reasons)
07:19:45 <humasect> philippa, tried that one.
07:20:44 <integral> that's a wee bit like (const f) &&& (const g) isn't it?
07:20:51 <Philippa> yeah
07:20:54 <dons> Lemmih's looks nice, and gets you hackery points
07:20:59 <Philippa> oh, wait, you want to insist on the types matching?
07:21:19 <Philippa> just use a type annotation
07:29:20 <shapr> CosmicRay: When's the next HWN?
07:29:27 <CosmicRay> shapr: tomorrow
07:29:29 <shapr> CosmicRay: Is there a WantedModules for MissingH?
07:29:39 <shapr> CosmicRay: Already know about ZFS and HaskellUserLocations?
07:30:58 <CosmicRay> shapr: I don't have a WantedModules list right now.  It'd be fine if you worked one up ;-)
07:31:10 <CosmicRay> shapr: haven't heard of either ZFS or HaskellUserLocations...
07:31:39 <shapr> I'll write up ZFS & HaskellUserLocations
07:31:50 <shapr> How much is the standard per-entry? about 80 chars?
07:32:36 <CosmicRay> what is ZFS?
07:32:59 <CosmicRay> shapr: are you talking about wiki pages or code?
07:33:44 <MarcWeber> Hi. I want to install hdirect on windows.  But I get this error: ../src/ihc: Command not found when doing make lib. Do you know what ihc is or where to find it?
07:34:49 <CosmicRay> wow, the job of making a tar header parser sucks.
07:34:52 <shapr> CosmicRay: http://www.haskell.org/hawiki/HaskellUserLocations and http://lambda-the-ultimate.org/node/view/1036
07:35:15 <CosmicRay> there are n different formats, where each format is slightly incompatible with every other one, and various sources disagree about the value for n
07:35:17 <MarcWeber> Any ideas?
07:35:17 <CosmicRay> but it is at least 4
07:35:18 <shapr> Also, how can I make a WantedModules? I guess I should put up a wikipage?
07:35:54 <CosmicRay> ahh, col.  I like HaskellUserLocations.  however I do not post my gps coordinates in public.  ;-)
07:36:19 <CosmicRay> shapr: that would be fine, or you could also send me darcs patches for the source tree.  whatever you prefer.
07:36:22 <Igloo> Stick your work ones in?
07:36:45 <CosmicRay> maybe I could just point in the coords for the center of the nearest town
07:37:10 <CosmicRay> shapr: cool on the ZFS thing.  It sounds like it would also be possible to make it an HVFS instance.
07:37:55 <Igloo> Do you work from home, then? Or do you work for a government agency that doesn't exist or something?  :-)
07:38:00 <shapr> CosmicRay: Where's the repo?
07:38:09 <CosmicRay> shapr: http://darcs.complete.org/missingh
07:38:33 <CosmicRay> Igloo: I guess it wouldn't hurt to put in my work location.  it's not far from my home location ;-)
07:38:51 <CosmicRay> I am just nervous about billions of people being able to find out exactly where I live.
07:39:24 <Igloo> Well, I was working on the assumption it wouldn't be too hard to find out where you worked, or where they are located, BICBW  :-)
07:40:24 <dons>     they don't have to be very accurate. city-level is pretty good.
07:41:33 <CosmicRay> Igloo: that is all probably true.
07:41:41 <shapr> My coords are actually the Hotel in the middle of town.
07:42:09 <CosmicRay> shapr: so the person in room 205 will be very surprised at the number of people inquiring about unicycling then? ;-)
07:42:39 <Igloo> I think Heff worked out the coords of our (then shared) office, and then displaced us 0.5m East/West of that point or something  :-)
07:42:54 * shapr grins
07:43:32 <dons> ok, I'm going to updatethe map for the last time in about 60 seconds...
07:43:37 <shapr> Why would anyone show up in person to ask me about unicycles?
07:43:48 <CosmicRay> shapr: you just never know, do you? ;-)
07:44:08 <CosmicRay> heh: " An archive file is not easy to read or manipulate without
07:44:08 <CosmicRay>  using the `tar' utility or Tar mode in GNU Emacs."
07:44:14 <CosmicRay> from the gnu tar manual.
07:44:22 <CosmicRay> I had no idea emacs has a tar mode.
07:44:41 <shapr> emacs has a mode for every occasion.
07:44:47 <earthy> emacs is an operating system all in itself
07:44:51 <xerox> every-occasion-mode
07:44:55 <CosmicRay> heh
07:45:10 <earthy> it must be, the number of OS's it's been ported to
07:45:12 <rafl> CosmicRay: Hello.
07:45:16 <CosmicRay> hi rafl
07:45:25 <rafl> CosmicRay: May I ask a question about packaging hs stuff for Debian?
07:45:30 <CosmicRay> sure
07:45:55 <psi> does anyone know if openbsds ghc port compiles on ppc? I can't find a binary package, which is odd, I guess
07:45:56 <rafl> CosmicRay: I have a problem with pugs. I install the cabal package into /usr/lib/haskell-packages/ghc6/lib/Pugs-6.2.10.
07:46:14 <rafl> CosmicRay: A adjust import-dirs and library-dirs in installed-pkg-config to that path.
07:46:33 <rafl> CosmicRay: When I try to register the package with ghc in the postinst it gives me that:
07:46:49 <CosmicRay> you should not ever have to modify installed-pkg-config
07:46:56 <rafl> CosmicRay: ghc-pkg: src/pcre doesn't exist or isn't a directory
07:46:59 <CosmicRay> you should instead pass appropriate flags to ./setup configure
07:47:17 <rafl> CosmicRay: src/pcre is listed (among others) in include-dirs. How to avoid that error?
07:47:37 <Igloo> psi: I suspect no-one's bootstrapped it
07:48:41 <Igloo> Does lib need to be repeated in "/usr/lib/haskell-packages/ghc6/lib/Pugs-6.2.10"?
07:49:36 <psi> Igloo: does that mean I can't compile it?
07:50:04 <dons> psi, haven't tried it unfortunately.
07:50:06 <CosmicRay> rafl: so you have an unmodified pugs package and it's giving you that error?
07:50:10 <Igloo> psi: It means you'd have to follow the "porting to a new arch"(or similar) section in the building guide
07:50:14 <dons> do you have access to an openbsd ppc?
07:50:25 <CosmicRay> rafl: I think you have to use hs-source-dir or something, but I don't completely recall on that
07:50:31 <psi> dons: yeah, I'm using one right now
07:50:32 <CosmicRay> rafl: the GHC cabal manual would probably be helpful
07:51:48 <dons> so since I haven't had access to one, you need to port it as Igloo says.
07:52:12 <psi> is it difficult?
07:52:16 <dons> you need to create a .hc tarball on either an x86 or amd64 openbsd box (that would be easiest), then untar those on top of a src tree on the ppc
07:52:22 <dons> then try to build that.
07:52:36 <dons> it usually takes a couple of days to get righ -- porting a compiler is not trivial
07:52:53 <Igloo> It /shouldn't/ be difficult, though
07:52:54 <dons> but openbsd is well supported, so it  isn't ridiculously hard
07:53:18 <rafl> CosmicRay: Kind of unmodified. All changes are in debian.
07:53:26 <rafl> CosmicRay: For what should I use hs-source-dir?
07:53:36 <psi> ok. if I'm bored one day then, perhaps :)
07:53:59 <CosmicRay> rafl: I don't remember right off-hand.  the GHC cabal manual should help.
07:54:09 <CosmicRay> rafl: but, what you should do first is see if it builds unmodified.
07:54:19 <rafl> CosmicRay: It does.
07:54:21 <CosmicRay> if it does build unmodified, but your debian package doesn't, then you've messed up something in your debian package.
07:54:23 <CosmicRay> ok.
07:54:39 <CosmicRay> I would suggest making sure that you are not touching the cabal file, and you also should not be modifying the installed-pkg-config file.
07:54:45 <rafl> Well, it builds. registering it with ghc-pkg doesn't work.
07:54:50 <CosmicRay> if you are using dh_haskell, it should take care of those details for you.
07:55:07 <CosmicRay> so pugs is not just a binary but also a library?
07:55:16 <rafl> pugs is way to complex for dh_haskell, imho. :-)
07:55:27 <rafl> CosmicRay: The new release exposes a haskell interface.
07:55:33 <CosmicRay> rafl: I don't know anything about its packaging, but why would it be too complex?
07:55:35 <rafl> Beside the binary.
07:55:58 <dons> psi, well, if you're up to giving me login access, and can leave it on during .au day time, I could do the port and add it to the openbsd ports tree.
07:56:06 <rafl> CosmicRay: It doesn't use Cabal only. It's a perl build system (Makefile.PL, EU::MM) which hacks in Cabal stuff.
07:56:18 <CosmicRay> oh.
07:56:23 <CosmicRay> nasty.
07:56:34 <CosmicRay> I would suggest that the place to start with debianizing it is the call to "setup configure"
07:56:37 <dons> psi, though it's probably best to wait till I get around to porting 6.4.1.
07:56:41 <CosmicRay> that may or may not help you.
07:56:47 <dons> I might get back to you on this.
07:56:48 <CosmicRay> also, the installation should be done with "setup copy"
07:57:20 <rafl> CosmicRay: Yes, I currently investigate the cruel way it get's called.
07:57:25 <CosmicRay> you will need the .installed-pkg-config in this case
07:57:29 <shapr> Wow, -Ofun already has 68 del.icio.us bookmarks.
07:57:38 <CosmicRay> but you should hopefully still be able to copy it unmodified
07:57:38 <rafl> CosmicRay: Yes, I already hacked ./Setup copy into upstream.
07:57:59 <CosmicRay> if you grab haskell-devscripts, dh_haskell_install may be instructive for you.
07:58:13 <dons> btw, I updated the map of western europe, however, it's only marginally better, as xplanet wanted to segfault when I fed it a nice 10km-resolution map :/
07:58:36 * dons wonders if google maps can be cooped into overlaying markers somehow
07:58:44 <dons> co-opted
07:58:58 <shapr> I'm sure it can, that's the whole point isn't it?
07:59:05 <shapr> We just need a wrapper...
07:59:13 <psi> dons: okay. yeah, you can have access. it's a laptop though, so we'd need to find a time when it's stationary, so to speak.
08:00:10 <psi> I guess it should be .au day time
08:01:40 <dons> psi, ah, ok. maybe it's easier if I pester some of the pother ports tree guys
08:02:47 <dons> shapr, right. like that guy did with the chicago crime map.
08:04:00 <CosmicRay> rafl: but I'm afraid I'm probably not going to be much help to you with a build system like that.
08:05:20 <psi> dons: possibly.. just say if need it, though
08:05:59 <dons> ok. cheerrrs
08:06:24 <psi> :)
08:07:37 <rafl> CosmicRay: OK, did some changes. Let's see how it works out.
08:07:46 <CosmicRay> brb
08:10:29 <ulph_> hej allihopa
08:11:48 <psi> hallå
08:17:35 <dons> ah ha, google maps has an api!
08:18:24 <dons> oh my shapr, Google Maps Real-Time GPS Tracker
08:19:47 <xerox> dons: yes it has!
08:20:22 <dons> ok cool. I just have to generate a bunch of javaScript calls from the maarkers page, and then the markers are available to a custom google map
08:22:22 <dons> the gnome guys did the same thing: http://www.gnome.org/~jamesh/maps/gnome.html
08:24:36 <dons> and you can just zoom in until you see the locations at full res. huh. so this is how I track my enemies
08:24:49 <dons> and java programmers, of course
08:25:53 <xerox> We have it for SoC students locations too :D
08:26:09 <dons> oh, cool.
08:26:19 <xerox> http://mwarden.f2o.org/socmeetup/map.php
08:26:23 <dons> it's kind of scary really
08:26:42 <dons> i guess bad guys don't use the internet... right...??
08:26:48 <xerox> :-\
08:27:49 <[Blownose]> how do i divide two values to an Integer (not fractional)?
08:28:06 <Lemmih> @type div
08:28:08 <lambdabot> forall a. (Integral a) => a -> a -> a
08:28:20 <dons> night all!
08:28:27 <xerox> Goodnight dons
08:28:49 <Lemmih> @eval round (323.4 / 5.4)
08:28:51 <lambdabot> 60
08:28:57 <[Blownose]> ah thanks :)
08:29:42 <[Blownose]> import qualified myModule    what does qualified mean in this row ?
08:30:06 <marcot> CosmicRay: hello.
08:30:44 <marcot> CosmicRay: This problem is because when I was going to upload it to mentors.debian.net I accidentaly forgot to put the host..
08:31:02 <psi> [Blownose]: when you use items that the module exports, you need to prefix them with 'myModule.'
08:31:03 <marcot> CosmicRay: and it uploaded to the main server.
08:31:21 <Oejet> They have a scarily good resolution over Baghdad.
08:31:44 <[Blownose]> ok..
08:31:48 <marcot> CosmicRay: I've done it one other time in the -2 revision, but when the upload was complete it saw that I couldn't do that.
08:36:56 <CosmicRay> marcot: hi
08:37:06 <CosmicRay> marcot: ok.
08:37:12 <CosmicRay> marcot: I can try to remove it later on
08:37:37 <marcot> CosmicRay: ok, I think that if I had finished the upload it would have removed the file automatcly.
08:39:32 <CosmicRay> marcot: yes, probably so
08:41:14 <shapr> dons: Seriously? GPS tracker?
08:41:40 <shapr> Wow, http://conversationswithmyself.com/maps/tracker/gmapTracker.html
08:42:18 <[Blownose]> if io
08:42:26 <marcot> CosmicRay: is there a way of maybe I removing the file, since I uploaded it?
08:43:18 <[Blownose]> if i do div 1 0  i get exception divide by zero.. but i want to catch it and have my own error("mytext") how do i do that..
08:44:26 <shapr> Whoa, the gnome google maps includes hackergotchis and blog links. I see some very cool H-jax tricks in the near future.
08:44:45 <CosmicRay> marcot: yes, see ftp://ftp-master.debian.org/pub/UploadQueue/README
08:44:55 <CosmicRay> but I will have to do it since your key isn't authorized
08:45:29 <shapr> Obviously, our next project is to create Haskellgotchis.
08:45:36 <CosmicRay> shapr: bwahaha.
08:45:49 * shapr grins subversively
08:49:23 <marcot> CosmicRay: ok.
08:49:56 <basti_> shapr: btw, I'm currently thinking aloud about doing website/continuation stuff in hsp
08:50:10 <shapr> Like what? how?
08:50:29 <basti_> like: being able to bind forms monadically.
08:50:37 <Lemmih> [Blownose]: Check if you're dividing by zero first.
08:51:09 <basti_> putting together a form gives it a type that represents the values the user was entering, and binding forms chains interaction.
08:51:43 <basti_> it doesn't seem too hard, thats why i'm thinking about it ;)
08:53:53 <shapr> Isn't that how WASH works?
08:54:42 <CosmicRay> if I have something like: x = (fromIntegral . fromEnum '5')::Word8 in a file, will ghc -O2 optimize this conversion away so that the conversion from Char to Word8 doesn't have to happen at runtime?
08:55:22 <basti__> hmmh
08:57:52 <Lemmih> CosmicRay: Yes, if you change that to "x = (fromIntegral . fromEnum) '5'".
09:03:41 <shapr> The gnome guys put the Lost City of Atlantis on their map.
09:03:54 <CosmicRay> Lemmih: interesting.  why can it optimize that case but not the other?
09:05:16 <CosmicRay> Lemmih: what if I do this:
09:05:20 <CosmicRay> c2w8 :: Char -> Word8
09:05:20 <CosmicRay> c2w8 = fromIntegral . fromEnum
09:05:25 <CosmicRay> x = c2w8 '5'
09:14:56 <marcot> In a do statement, is there a way of declaring the type of something, like:
09:15:25 <marcot> do { a :: String; a <- read; return a}
09:16:28 <xerox> return (a :: String)  ?
09:16:47 <marcot> xerox: strange doing this after using it, isn't it?
09:17:21 <xerox> marcot: nope, it's ok
09:17:42 <xerox> marcot: the type is inferred from the whole context
09:17:56 <marcot> xerox: I know, I just want to make it explicit.
09:18:06 <marcot> as in foo :: Int -> Int; foo = (+1)
09:18:10 <marcot> Something like that.
09:18:29 <xerox> put a sig on read?
09:18:48 * shapr boings randomly
09:18:59 <marcot> xerox: on a term.
09:19:02 <marcot> on a
09:19:10 <marcot> I'm in a gtk2hs program, and I have:
09:19:18 <marcot> principal <- xmlGetWidget xml castToWindow "principal"
09:19:23 <xerox> I don't know if  (a :: String) <- foo  is valid, you could try.
09:19:38 <xerox> Ah, I know that function :)
09:19:45 <marcot> xerox: it said that it's only valid with -fglasglow-exts
09:20:13 <xerox> marcot: so it's up to you
09:20:36 <marcot> I was wondering about let
09:20:49 <marcot> let principal :: widget in principal <-
09:20:53 <shapr> uhm, hey... can Busy Beavers be reasoned about inductively?
09:22:45 <Lemmih> CosmicRay: Well, "x = (fromIntegral . fromEnum '5')" gives a type error (:
09:24:34 <CosmicRay> Lemmih: add a $ in there ;-)
09:24:41 <b0gg1e> well it should be (fromIntegral . fromEnum) '5' i suppose
09:26:26 <xerox> f . g $ x  ==  f $ g x
09:31:53 <kolmodin> shapr: Atlantis is not on earth, it's in the Pegasus galaxy. or perhaps you aren't watching stargate? :)
09:36:21 <ehuber> hello, i have a very simple question if anyone would like to answer it..
09:36:29 <ehuber> why is length :: [a] -> Int ?
09:36:33 <ehuber> and not -> Integer?
09:36:47 <ehuber> it causes type errors between Int and Integer..
09:37:36 <ehuber> anyone ? :p
09:37:42 <Cale> ehuber: yeah, that's annoying.
09:37:51 <ehuber> heh yeah.. why is it like that ?
09:37:56 <ehuber> some optimization ?
09:37:59 <Cale> It was an argument during standardisation
09:38:05 <Cale> Int is faster, sure
09:38:06 <shapr> kolmodin: I don't watch TV.
09:38:10 <ehuber> its sort of silly..
09:38:22 <Cale> and you're basically never going to need more than an Int to store the result
09:38:25 <ehuber> if it causes type errors.. and that's the whole point of using haskell.. to make typesafe programs..
09:38:31 <ehuber> yeah.. what about 50 years from now
09:38:32 <ehuber> :p
09:38:38 <ehuber> well ok, that's what i figured, thanks (;
09:38:47 <Cale> they'll be written using a newer Haskell than 98
09:38:51 <ehuber> now.. how can I cast from Int to Integer? I've never had to
09:38:59 <Cale> really it should be  length :: (Num b) => [a] -> b
09:39:07 <Cale> oh, that's easy
09:39:10 <Cale> fromIntegral
09:39:16 <Cale> @type fromIntegral
09:39:21 <lambdabot> forall b a. (Num b, Integral a) => a -> b
09:39:28 <ehuber> but that takes an integer..
09:39:31 <ehuber> at least in Hugs..
09:39:38 <ehuber> Prelude> fromIntegral
09:39:38 <ehuber> ERROR - Cannot find "show" function for:
09:39:38 <ehuber> *** Expression : fromIntegral
09:39:40 <ehuber> *** Of type    : Integer -> Integer
09:39:52 <Cale> do :type fromIntegral
09:39:56 <ehuber> ok
09:40:08 <ehuber> oh, aha
09:40:13 <ehuber> that should do it (:
09:40:15 <Cale> you'll also get the (Integral a, Num b) => a -> b thing
09:40:28 <Cale> Int is in Integral.
09:41:01 <Cale> Integer is the default type for numbers if there's any ambiguity left when resolving types at the end.
09:41:29 <ehuber> ok
09:41:32 <ehuber> thanks (:
09:41:48 <Lemmih> @type List.genericLength
09:41:49 <lambdabot> forall i b. (Num i) => [b] -> i
09:42:12 <Cale> yes, that should be the version in the prelude, imo.
09:42:47 <ehuber> uh.. i found fromIntegral in the online documentation, but not a function to make Real values from Integral values
09:42:56 <Cale> fromIntegral
09:43:00 <Cale> :)
09:43:16 <ehuber> oh.
09:43:20 <ehuber> duh
09:43:21 <Cale> fromIntegral converts Integral types to any type of numbers.
09:44:25 <ehuber> yeah i just noticed that (:
09:44:34 <ehuber> ok, now i finished my fun primedensity function (:
09:44:41 <Cale> :)
09:44:53 <ehuber> primedensity 1 500 ... 0.190381
09:45:28 <kolmodin> shapr: I watch tv shows, not TV :)
09:45:30 <ehuber> oh well, that's enough for today
09:46:12 <ehuber> thanks for the guidance
09:46:25 <Cale> btw, that number defaulting thing can be influenced using default (t_1,t_2,...) where each t_i is a type in Num. It will try each t_i when sorting out defaults for numbers.
09:46:40 <Cale> (and pick the first kind of number with all the class constraints needed)
09:47:06 <Cale> default () turns it off, and default (Integer, Double) is the default
09:47:42 <ehuber> heh i hope i never have to use that function..
09:47:46 <Cale> heh
09:47:54 <Cale> it's a keyword in fact :)
09:48:01 <Cale> I wish it was more generaL
09:48:03 <Cale> l*
09:48:04 <ehuber> :p
09:48:37 <shapr> 181, neat
09:48:46 <shapr> Didn't we have 188 clients on #haskell a few days back?
09:48:47 <Cale> some strange things ended up in Haskell 98, and not some of the strange things I'd have liked :)
09:49:04 <shapr> Speaking of which, any ideas for stuff to add to Haskell 2?
09:49:09 <shapr> er, Haskell 06
09:49:15 <ehuber> please get rid of Int
09:49:37 <shapr> Hm
09:49:38 <ehuber> my fondest wish (:
09:49:43 <Cale> Getting rid of Int is almost possible due to specialization
09:50:00 <Cale> you really need Int when efficiency is a concern
09:50:10 <shapr> But, what about Word8 instead of Int?
09:50:15 <ehuber> la (:
09:50:17 <tromp> how do we compute 2^64 without Int??
09:50:21 <Cale> Int is signed :)
09:50:55 <ehuber> maybe a separate version of haskell without Int .. for me :p
09:50:59 <Cale> hehe
09:51:10 <shapr> It's an interesting thought, I'd definitely like to aim for a more "abstract from the machine details" viewpoint.
09:51:17 <Cale> yeah
09:51:42 <humasect> liftIO is dirty
09:51:45 <shapr> Of course, for sanity that would require ratios instead of floating point.
09:51:46 <Cale> Int always seemed like a bit of a wart to me. If people want to keep it, I think it should be in a library.
09:52:05 <ehuber> arent arrays also a library? arent they ?
09:52:10 <Cale> yes
09:52:27 <Cale> We should completely switch over to IArray/MArray
09:52:46 <shapr> hiya genneth, how's life?
09:52:51 <tromp> what is Int anyway? is it always Int32?
09:52:51 <Cale> wasn't there some news regarding array comprehensions?
09:52:55 <Oejet> I want more efficient datastructures, wrt. strings and records.
09:53:09 <Cale> tromp: compiler dependent, but there's a guaranteed range
09:53:26 <tromp> what's the guaranteed range?
09:53:56 <Cale> -2^29 to 2^29 -1
09:54:13 <tromp> that smells of tag bits:(
09:54:28 <Cale> Well, it allows for them
09:54:48 <tromp> right
09:54:54 <Cale> implementations are permitted to have a larger range
09:55:13 <genneth> shapr: pretty good; getting over an eye infection and 9 o'clock lectures on saturdays
09:55:44 <Cale> shapr: where are the array comprehensions? :)
09:55:47 <shapr> genneth: I enjoyed your LtU thread.
09:55:54 <Cale> I recall hearing about them
09:56:06 <shapr> array comprehensions? Aren't they in Parr?
09:56:07 <Cale> are they implemented?
09:56:11 <genneth> shapr: thanks; i hoped that i didn't piss too many people off with the java remarks
09:56:19 <Oejet> Cale: A bit. :-)
09:56:38 <basti_> eye infections suck
09:56:45 <shapr> You pissed off David Held, but he's already convinced that referential transparency is academic masturbation.
09:56:52 <Oejet> The code in GHC for Parr is buggy at best.
09:57:09 <Cale> shapr: haha
09:57:23 <shapr> Give me a darcs repo where I can commit fixes and I will commit fixes to GHC, including Parr.
09:57:36 <Cale> It would be nice to see monad comprehensions and array comprehensions end up in Haskell 2006.
09:57:37 <genneth> shapr: he also seems to be convinced that the brain is more powerful than a Turing machine...
09:57:47 <shapr> He's convinced of a lot of stuff.
09:58:07 <Cale> I also want to be able to assume that Monads are Functors
09:58:12 <Oejet> genneth: What forum topic?
09:58:25 <genneth> Oejet: Scalability
09:58:27 <xerox> Cale: why you can't?
09:58:32 <shapr> I tend to disagree with him for the most part. I do agree with him that people on LtU should backup their comments with numbers and running code a lot more often.
09:58:34 <genneth> Oejet: it's not what it sounds like
09:58:46 <Cale> xerox: Well, there's nothing explicitly requiring it
09:58:48 <genneth> shapr: ditto; there is a lot of handwaving
09:59:33 <shapr> I think my suggetions for Scalability really will work, and is affordable for most companies.
09:59:47 <Cale> Also, add join to the Monad class and make some default implementations.
09:59:52 <shapr> But I'm basing that off of my microscopic salary :-)
10:00:06 <humasect> why do i suddenly get many "warning: pattern matches are overlapped" now
10:00:09 <Philippa> genneth: his line about the human brain not being able to do things through lack of resources rather than 'in principle' shows a certain lack of clue. Like, what about those tasks for which it'd need infinite resources?
10:00:11 <sylvan> Has anybody tried an evaluation model other than lazy evaluation for haskell? I mean, one that's still non-strict, like lenient evaluation
10:00:31 <Cale> Oh right, and fmap should be renamed to map, and map should be renamed to lmap. :)
10:00:35 <shapr> sylvan: I tried the speculative fork of ghc5.04, it was quite nifty.
10:00:41 <xerox> Cale: agreed :)
10:00:44 <genneth> Philippa: indeed; i though GEB had that whole line kinda covered with fine icing
10:00:47 <shapr> Cale: Put these onto the wiki!
10:00:55 <sylvan> shapr, oh what did it do, just optimistic evaluation or what?
10:01:00 <Philippa> never read GEB. I probably should sometime
10:01:01 <Speck> Cale: wasn't fmap == map in a previous version of Haskell? (and list comprehensions were monad comprehensions?)
10:01:14 <Cale> Speck: yes
10:01:21 <Cale> they stripped it all out for '98
10:01:36 <Speck> iirc, the reason it was changed was because of confusing error messages, right? Or was there another reason?
10:01:52 <Cale> also, some people hate typeclasses
10:02:01 <shapr> sylvan: For the most part, yes. Thunks weren't created by default, instead you would treat the code as strict for 40 or so thunks deep. It would *never* cross IO boundaries though.
10:02:04 <genneth> shapr: i'm kinda of going done that route; i've componentized along existing protocols, in the belief that a protocol like webdav is worth many more hours of mantime than i can invest
10:02:21 <Speck> ic... well I wish I were using haskell during those times... it sounds like an interesting setup. Very monadic
10:02:42 <Cale> Speck: I wasn't, but I still think we should go back to some of those features :)
10:02:59 <humasect> and my pattern matches don't overlap.  different before -> and after.
10:03:20 <Speck> Cale: I agree, but I'm not really knowledgeable enough to say -- very bright people work with Haskell and usually make decisions that are pretty good
10:03:25 <shapr> sylvan: spec_eval had a lot of benefits, including a run of the mill imperative debugger that worked as you expect.
10:03:27 <sylvan> shapr, I'm mainly concerned about lazy evaluation being sort of... "difficult" when it comes to implicit parallelism.. Which would be neat
10:03:54 <shapr> sylvan: Have you read up on declarative parallelism?
10:04:28 <shapr> You should also read the SMP GHC paper, they talk about distributed thunk updating.
10:04:30 <sylvan> not really, except for just now
10:04:30 <Cale> Speck: well, reading the mailing lists made me aware that lots of decisions were rushed due to timelines.
10:04:35 <sylvan> yeah I read that
10:04:40 <shapr> Not distributed, shared memory... but you know what I mean.
10:05:08 <sylvan> I'm very interested in the notion of just writing your program like normal and having the RTS just spread it out on multiple cores
10:05:10 <shapr> Have you read about the Nepal Project and the parallel arrays in Parr?
10:05:18 <xerox> What is Parr?
10:05:19 <sylvan> Yeah I saw the Nepal stuff
10:05:24 <sylvan> Parallell arrays
10:05:29 <sylvan> right?
10:05:30 <Cale> shapr: where should I add them?
10:05:31 <shapr> yup
10:05:35 <Speck> Cale: hm. Interesting. I feel like the Haskell standard is getting ready for some change, what with all the popular extensions and planned Cabalization of GHC, etc.
10:05:50 <shapr> Cale: Create HaskellOhSix or Haskell06 depending on your mood :-)
10:06:09 <sylvan> Is there a summary of what people want tof 06?
10:06:16 <sylvan> I want better module system and records
10:06:20 <sylvan> basically =)
10:06:38 <Cale> heh, HaskellOughtSix sounds like bullets :)
10:06:45 <humasect> i'd like to add to that page.
10:06:48 <shapr> I think parallel arrays are the most likely approach to automatic multicore programs.
10:07:09 <sylvan> yeah well GHC should just take a flag that makes it execute all "map" and list comprehensions etc. in parallell
10:07:17 <shapr> I've never seen a good approach to fullblown transparent automatic parallelism, only data parallelism.
10:07:34 <sylvan> It seems very difficult to get it working well
10:07:36 <sylvan> sadly
10:07:53 <sylvan> but the payoff might be worth it, what with the current trend of multi-core
10:08:04 <shapr> I've been pushing for SMP GHC since I got into the community, now we have -smp
10:08:17 <sylvan> it's still explicit parallellism though?
10:08:24 <shapr> It is, but there's Parr
10:08:37 <shapr> I suggest we hack on Parr and get it to transparently work with -smp.
10:09:20 <humasect> do i have to use guards instead of case..of for this "overlapped pattern matches" situation?
10:09:39 <shapr> There will be an emulator for the STI Cell available for x86 Linux in the next few months (before Xmas). I think we should hack the PPC GHC port to handle the Cell, and offload Parr computations to the SPEs :-)
10:09:58 <sylvan> I would be interested in seeing what happens if you just have a pool of worker threads and a queue of evaluations, so every time something needs to be evaluated you put it in the queue, and a worker thread evaluates it.. Just really optimistically.. See what happens
10:10:33 <shapr> Jan-Willem Maessen is probably the person to ask, he wrote pH, the eager parallal Haskell.
10:10:44 <sylvan> stuff like f = (4+5) * 2 would obviously be slower, but maybe real-world apps aren't that pathological
10:10:54 <mflux> eager haskell sounds really interesting (I've checked the white paper)
10:11:37 <mflux> and sounds like it really has potential for 'automatically' using multi-cpu machines
10:11:42 <mflux> who knows, maybe clusters
10:11:55 <shapr> Jan-Willem mentioned that data locality will quickly become important in multicore and Cell-like designs. I wonder if region allocation can be used to ensure data locality with a certain granularity?
10:12:38 <mflux> atleast having gc should allow moving data around, no? (like in ocaml)
10:12:54 <mflux> well, not gc per se, but the memory management built for it..
10:12:55 <shapr> I wonder if there's some sort of isomorphism between parallel arrays and region allocation?
10:13:05 <Oejet> shapr: Isn't parallel arrays mostly for linearising array operations?
10:13:17 <neadjneki> mflux can you give us a link about it?
10:13:23 <shapr> Yeah, but it ends up ensuring that data and code have excellent locality.
10:13:37 <Cale> what do people think of the idea of making Diff arrays the default immutable array type?
10:13:55 <sylvan> Fine by me!
10:14:03 <Cale> They're really quite nice
10:14:04 <Oejet> shapr: Ah, if I just know what that means. :o)
10:14:12 <shapr> Oejet: So I wonder if parallel arrays are a distant isomorphism of region allocation.
10:14:52 <shapr> Oejet: Think about the STI Cell, each sidekick CPU has 256k of cache/ram. You want the code and the data to both end up in the same 256k chunk.
10:15:23 <mflux> neadjneki, I think this is it: http://research.microsoft.com/Users/simonpj/Papers/optimistic/icfp2003.pdf
10:15:49 <shapr> locality == the property of being near something else
10:16:12 <Oejet> Ok.  And also region allocation is quite memory greedy, at least in MLton, IIRC.
10:16:29 <sylvan> can you enable optimistic evaluation via a command-line flag or something like that?
10:16:40 <astrolabe> Cale: I prefer it as it is I think.  Basic arrays are simpler, diff arrays are less canonical.
10:16:47 <shapr> Nope, optimistic evaluation never reached the 'base' GHC.
10:16:59 <shapr> The changes to the core were quite extensive.
10:17:29 <shapr> iirc, JaffaCake said that it was unlikely it would ever get into the core unless someone else did it.
10:17:50 <sylvan> Well why isn't it the default? It doesn't seem to really hurt many programs, and it helps a lot with space leaks if I understand correctly
10:18:54 <Cale> They kill off a lot of the issues with getting the "right" algorithm complexity in a purely functional way in a lot of cases.
10:18:59 <araujo> Hello!
10:19:16 <kolmodin> araujo: reading HaskellUserLocations, it looks lonely on your continent :)
10:19:18 <kolmodin> araujo: hi!
10:20:14 <astrolabe> Cale: Do you mean space-complexity?
10:20:30 <araujo> kolmodin, hey!
10:20:38 <araujo> kolmodin, yeah, haha, a bit lonely
10:20:49 <Cale> astrolabe: even time complexity
10:23:25 <Cale> astrolabe: O(1) updates to an array have been the big difference between functional and imperative time complexities in a lot of cases, from what I've seen.
10:24:04 <Cale> Usually, you'd get something like an O(log n) in a functional language where you'd get O(1) in an imperative one, but Diff arrays get rid of that :)
10:24:36 <sieni> well, log n isn't usually that bad, it's the constant term in the front
10:24:46 <astrolabe> Cale, I can imagine cases with many updates where the memory manager will be able to clear up after Array, but diff array will lead to long chains of pointers.
10:25:37 <sylvan> astrolabe: But those chains of pointers disappear if you don't use the old array values?
10:25:57 <sylvan> which seems to be the most common usage of arrays (update and forget the old version)
10:26:04 <Cale> I'm fairly sure Diff array always leads to smaller memory footprints after GC.
10:26:38 <mflux> benchmark time!-)
10:26:45 <Cale> Since the old versions are only kept around if there's something hanging on to them.
10:26:57 <sieni> oh, diff arrays look cool
10:27:03 <Cale> And if there was something hanging on to an Array, you'd get the whole thing.
10:27:26 <Cale> They are incredibly cool :)
10:27:32 <dcoutts> timbod, I don't run OSX but people tell me that it builds and runs on OSX. Yes at the moment Gtk+ uses the X server on OSX at the moment. A native port is in development however.
10:27:54 <mflux> I think I can see sylvan's pov with the long chains, could ghc's gc be 'vulnerable' to those?
10:28:04 <Cale> http://www.haskell.org/hawiki/HaskellOhSix has some of my ideas, if course, not the obvious ones.
10:28:08 <Cale> of*
10:28:29 <sylvan> what obvious ones?
10:28:46 <astrolabe> I agree that diff arrays are probably usually more efficient.  My problem is that they are more of a hack for speed than Arrays, and aren't guaranteed to be more efficient.
10:28:50 <shapr> @wiki HaskellTwo
10:28:50 <lambdabot> http://www.haskell.org/hawiki/HaskellTwo
10:29:08 <dcoutts> SamB, Gtk2Hs is not building how you expect? It shouldn't matter if it's a 'release' version or not.
10:29:16 <mflux> well, if the default of Array was a compiler option, one could easily try out the performance of different software
10:29:36 <Cale> sylvan: multiparameter typeclasses etc.
10:29:38 <astrolabe> It is sort of like the comparison between Arrays and lists.  Arrays are often more efficient, but they are more of a hack.
10:30:06 <Cale> You're only going to use Arrays if you're concerned with efficiency in Haskell anyway
10:30:18 <Cale> (well, that's not completely true)
10:30:38 <Cale> But diff arrays make a lot of algorithms nicer to express
10:30:39 <sylvan> So what's the "deal" woth haskell'06, only very conservative extensions, or will there be more deep changes (like proper hierarchical modules, or records)?
10:30:49 <astrolabe> mflux: good point!
10:30:50 <mflux> but sometimes the efficiency is wildly better, think manipulating bitmaps?
10:31:28 <kolmodin> pattern guards? that would be really nice!
10:32:14 <shapr> What's the state of the fptools darcs repo? I would like to hack on Parr
10:33:06 <astrolabe> The leaks I heard suggested conservative for the standard with GHC extensions available outside of it.
10:34:03 <Speck> GHC is going to be blown apart into little, tiny, cabalized bits, no?
10:34:16 <shapr> Yup, soon.
10:34:30 <xerox> shapr: did you read the blog post about delimited continuations?
10:35:29 <Speck> it'll be interesting to see how cabal, hs-plugins, and hIDE come into play in the near future
10:35:29 <shapr> err, yes?
10:36:05 <xerox> Tom Moertel's blog.
10:36:46 <shapr> Yes, I read that.
10:37:11 <xerox> It makes the point kinda well.
10:37:34 <Cale> I'm going to take off -- I'm almost certain I have more ideas stored up to add to that list, but it will require more memory recall :)
10:38:11 <Cale> oh
10:38:12 <Cale> hehe
10:38:22 <Cale> I missed one I was discussing
10:38:25 * shapr is trying to decide whether to do useful stuff or hack on FLM
10:38:51 <gour> dcoutts: ping
10:38:59 * dcoutts tempts shapr to look at hIDE
10:39:01 <dcoutts> goron, pong
10:39:17 <gour> dcoutts:hi duncan
10:39:26 <dcoutts> hia
10:39:51 <gour> i'd like to put together some sort of database application..
10:40:15 <gour> and took a brief look on knoda, kexi...
10:40:51 <gour> for gnome i saw mergeant, but i'm interested what is with Libgnomedb in regards to gtk2hs?
10:41:00 <xerox> shapr: hack FLM!
10:41:09 <shapr> heya SyntaxNinja! ltns!
10:41:10 <xerox> We want that for the next TMR, at least!
10:41:20 <shapr> xerox: hah, unlikely... but possible I guess.
10:41:23 <xerox> Howdy SyntaxNinja :)
10:41:29 <dcoutts> gour, we don't bind gnomedb, but might be possible to do so
10:41:44 <SyntaxNinja> hi!!
10:41:46 <SyntaxNinja> I'm finally home.
10:41:51 <Philippa> 'lo
10:41:52 <SyntaxNinja> whew
10:42:01 <gour> dcoutts: what do you think whether it will be useful?
10:42:12 <shapr> How was your trip?
10:42:16 <SyntaxNinja> awesome
10:42:26 <gour> dcoutts: or is there another, i.e. better way to work with databases in haskell?
10:42:27 <dcoutts> gour, not sure really. I've not thought about db apps too much.
10:42:55 <shapr> I wish I could afford to buy all the books I want. I wish I would read all the books I own. :-)
10:43:09 <SyntaxNinja> I got in late last night.
10:43:18 <gour> dcoutts: do you have some experience with gnome db stuff, i.e. something similar to knoda, kexi..?
10:43:19 <dcoutts> gour, well one way that I'd like to make easier is implementing treeview data models in Haskell. That'd allow you to use a haskell db binding to implement a model.
10:43:21 <SyntaxNinja> today is a holiday, but I figured I should work to make up for extra vacationm I took
10:43:34 <dcoutts> gour, no, I've never played with them.
10:43:51 <gour> dcoutts: how dows hIDE advances?
10:44:04 <dcoutts> gour, good progress I'd say.
10:44:08 <shapr> SyntaxNinja: masochist!
10:44:10 <beschmi> dcoutts: i'm using the latest gtk2hs version (from darcs) and still have the onAfterEntry problem with ghc 6.4.1, everything works fine if i use ghc-6.4
10:44:26 <dcoutts> beschmi, really? hmm I'd better take a look.
10:44:33 <SyntaxNinja> shapr: I'm not going to work _too_ hard :)
10:44:41 <shapr> well ok then
10:44:45 <gour> dcoutts: glad to hear, those days i'm really swamped with other stuff and on week-and another seminar..
10:44:48 <SyntaxNinja> missed you guys!
10:44:49 <shapr> hey, will halFS be OSS soon?
10:44:53 <shapr> we missed you too!
10:45:27 <shapr> gour: Have you seen HaskellDB?
10:45:29 <SyntaxNinja> yeah. I was thinking I should just work on it in my spare time to get it out there.
10:45:35 <beschmi> dcoutts: the latest change i got is from Sep 25
10:45:38 <gour> shapr: no
10:45:43 <SyntaxNinja> I've been working on a big cabal refactoring, though.
10:45:44 <shapr> gour: It's way spiffy.
10:45:53 <SyntaxNinja> mostly in airports.
10:45:56 <gour> shapr: how?
10:46:00 <dcoutts> beschmi, that should be recent enough
10:46:15 <shapr> gour: http://www.haskell.org/hawiki/HaskellDbTutorial
10:46:31 <SyntaxNinja> I added a Distribution.Program so that I could share all the code for adding --with-haddock= and --haddock-args= and such between all the programs cabal uses internally.  this should really cut back on the repetition, and help make things more consistent.
10:46:47 <SyntaxNinja> and I'm thinking then you could add program hooks of some kind, but I haven't fleshed that out yet
10:47:33 <SyntaxNinja> are there any ICFP photos online yet?
10:47:44 <work_metaperl> gour: nibro 's MS Thesis has some good haskelldb stuff in it too
10:48:00 <gour> work_metaperl: you have url?
10:48:26 <shapr> I haven't seen any.
10:48:38 <gour> work_metaperl: do you think having e.g. gnomedb would be useful for gui application (gtk2hs) ?
10:49:47 <gour> work_metaperl: atm, i wanted something to just create simple database with few simple forms, queries..
10:50:07 <work_metaperl> gour: I dont have the URL, shapr or nibro has the right URL... i'm at work right now...
10:50:21 <gour> work_metaperl: but thinking about the future, it could become part of larger haskell application..
10:50:43 <gour> work_metaperl: ok, thanks, will ask nibro
10:51:23 <gour> nibro: work_metaperl told me about your MS thesis & haskelldb, can you provide me with url, please?
10:51:33 <work_metaperl> gour: http://www.cs.chalmers.se/~d00nibro/
10:51:57 <shapr> shIRC?
10:52:07 <dcoutts_shIRC> /me checks if onEntryActivate works
10:52:07 <work_metaperl> gour: the haskell server pages m.s. thesis by him has some haskelldb code in it
10:52:14 <goron> dcoutts: ping
10:52:15 <work_metaperl> but it doesnt show how to make a db connection
10:52:18 <beschmi> dcoutts: seems to work ;)
10:52:28 <dcoutts> beschmi, nope that's why it quit :-)
10:52:34 <dcoutts> goron, pong
10:52:42 <goron> dcoutts: ping
10:52:45 <gour> dcoutts: hi
10:52:51 <gour> work_metaperl: thanks, will take a look
10:53:03 <goron> dcoutts: I think you meant to send a pong to gour.
10:53:20 <beschmi> dcoutts: oh, it quits after the callback
10:53:26 <dcoutts> beschmi, yep
10:53:42 * dcoutts is confused
10:54:03 <XGoron> Now, you can use tab completion for gour
10:54:05 * dcoutts looks at his irc client where it says "<goron> dcoutts: ping"
10:54:20 * gour confused too
10:54:39 <XGoron> 19:38 < dcoutts> goron, pong
10:54:50 * XGoron is not confused.
10:55:15 * XGoron is rarely confused. :D
10:55:38 <XGoron> But on this occasion I curse the Epson "engineer" who build my printer.
10:56:26 <XGoron> It is supposed to have volatile memory, but it remembers garbage... It shouldn't remember anything after the power have been removed.
10:56:28 <dcoutts_shIRC> @arr
10:56:29 <lambdabot> I'll keel haul ya fer that!
10:56:38 <dcoutts> hmm
10:56:45 <XGoron> @arr
10:56:46 <lambdabot> Aye
10:56:55 <SamB> XGoron: what garbage?
10:57:21 <XGoron> SamB: I want to print slides, but it jump prints data.
10:57:23 <XGoron> er just
10:57:54 <XGoron> Like: ADDEADGDDD]A@@P
10:58:07 <gour> dcoutts: what would you prefer for haskell-databases & gtk2hs, gnomedb or haskelldb/hsql..?
10:58:26 <XGoron> It could be the case that this particular printer has become sentient, but I rather just have it do his job.
10:59:42 <dcoutts> gour, I really couldn't say. I've not tried either approach. The gtk2hs + haskelldb/hsql seems like it might be more Haskelly.
11:00:22 <SamB> XGoron: if it was sentient, wouldn't it be printing something that meant something?
11:01:06 <XGoron> SamB: Well, maybe it does say: Hi human, HELP ME!, but I don't know the encoding.
11:01:28 <XGoron> SamB: Anyway, this is very annoying. How can I be sure it doesn't keep printing?
11:02:34 <XGoron> I think my OS has something in some buffer and keeps sending stuff.
11:02:42 <gour> dcoutts: thanks. it looks haskelldb is more actively developed
11:02:49 <XGoron> So a reboot should solve it all.
11:02:58 <XGoron> Unless it saves the buffer :(
11:03:13 <XGoron> Well, than I will just try another OS.
11:03:20 <XGoron> Bye
11:04:25 <SamB> XGoron: I think you would find more profit in enlisting said engineer's help than in cursing him...
11:06:16 <micket> hey guys, i assume many (if not all) of you use linux, could anyone recommend a quick graphical filemanager? nautilus is so slow
11:06:44 <shapr> Is growl some sort of OSX notification thingy?
11:06:50 <gour> micket: MC ;)
11:06:57 <ulfdoz> micket: xffm and konqueror are my favourites.
11:07:07 <kolmodin> graphical filemanagers are overrated anyway...
11:07:17 <shapr> I use ls **/*(#q^R)
11:07:36 <gour> shapr: which shell you use?
11:07:45 <shapr> zsh, of course. l -oSr **/*(#q.Lk+900)
11:07:57 <psi> shapr: yeah
11:07:58 <gour> shapr: jsut asking :-)
11:08:21 <shapr> From a purely technical standpoint, zsh appears to be the most powerful.
11:08:29 <Speck> shapr: yeah growl is an system-wide event api with a focus on event notification
11:08:50 <shapr> I originally switched because bash didn't have a pre-execute hook.
11:08:58 <shapr> Though I think bash has that nowadays.
11:10:15 <shapr> xerox: Didn't you come up with some improvement on command && fin || die ?
11:10:28 <xerox> Yup.
11:10:44 <shapr> What was your improvement?
11:10:57 <xerox> function try () {
11:10:58 <xerox>         $* && fin || die;
11:10:58 <xerox> }
11:11:14 <shapr> ah
11:11:18 <xerox> try make
11:12:38 <dcoutts> beschmi, found the bug. Actually it's a different bug. Arguably it stems from a gtk bug. But I'll fix it anyway. (detail: the activate signal is asking for a return value when it should not get one, though the return value type is indeed null/void)
11:13:38 <gzl> shapr: yeah, it's a global notification framework. doing rather well: http://growl.info/applications.php
11:14:12 <eivuokko> Is HaskellDB still being developed?
11:15:19 <SamB> so how would I install GTK 2.8 on an otherwise debian-testing machine?
11:16:54 <beschmi> dcoutts: cool, so the gtk bug was only hidden when using ghc 6.4 (without gclosure)?
11:17:47 <dcoutts> beschmi, right, because we do the closure stuff differently for 6.4.1 and later.
11:21:34 <Speck> If I'm going to be attempting to contribute to hIDE should I start working with ghc 6.5 instead of 6.4.1 which I currently have installed?
11:23:12 <beschmi> dcoutts: btw, how do you debug gtk2hs. did you use gdb?
11:23:21 <SamB> hmm, so should I install GTK 2.8 from the "experimental" distribution?
11:23:45 <jyp> looks like we're all living on the edge here
11:24:10 <SamB> well hIDE certainly seems to be...
11:24:59 <dcoutts> beschmi, I suspected the problem was in the GClosure marshaling so I turned on the debug mode for that module (which is one of the only bits writte in C)
11:25:18 <dcoutts> SamB, Gtk+ 2.8 will give you cairo!
11:25:45 <Speck> yay cairo
11:26:25 <SamB> dcoutts: well, I don't care too much about the cairo, but I do want to get gtk2hs 0.9.9.5 to build... which does seem to require cairo...
11:27:04 <Speck> 0.9.9.5 requires 2.8 I do believe... there should be a debian package for it in either unstable or experimental
11:27:40 <SamB> how do I put experimental in my sources.list?
11:27:56 <SamB> @google apt sources.list experimental
11:27:57 <lambdabot> http://lists.debian.org/deity/1998/09/msg00046.html
11:28:37 <dcoutts> SamB, it doesn't require the latest Gtk+ version, it works with any Gtk+ version
11:28:49 <SamB> dcoutts: oh?
11:29:02 <yaarg> ,,,,,,
11:29:04 <SamB> it doesn't seem to like mine!
11:29:31 <dcoutts> you only get cairo bindings with cairo & Gtk+ 2.8 installed
11:29:39 * dcoutts will be back later
11:29:40 <SamB> it complains about missing symbols!
11:29:54 <SamB> from the headers
11:30:12 <SamB> dcoutts: are you gone yet?
11:31:41 <CosmicRay> I am increasingly of the opinion that lists are inadequate for dealing with binary data blocks.
11:31:49 <CosmicRay> I'm wondering about using arrays for this.
11:31:55 <CosmicRay> I have never used an array type in Haskell.
11:32:26 <CosmicRay> I think that I need something that can take a C char* and treat it as a Haskell array, without having to re-copy the data
11:32:33 <CosmicRay> an array over Word8 or CChar or something.
11:32:56 <CosmicRay> then, I need to be able to extract individual characters or subsets in constant time, and I would like those subsets to be lists.
11:33:02 <CosmicRay> is this something that is possible at all in Haskell?
11:33:32 <SyntaxNinja> hi CosmicRay!
11:33:48 <SyntaxNinja> CosmicRay: I use arrays for binary stuff
11:34:03 <SyntaxNinja> look at Binary.hs in hs-pluggins, I think.
11:34:05 <Igloo> Why not use Ptr Word8?
11:34:16 <SyntaxNinja> also, I think there was a discussion of this on one of the haskell lists recently
11:34:18 <basti_> CosmicRay: there is these packed string things
11:34:31 <basti_> darcs uses them
11:34:40 <CosmicRay> basti_: yeah, but they require FFI
11:34:50 <basti_> ah
11:35:03 <Igloo> SyntaxNinja: cabal in Debian still needs to be fixed, BTW
11:35:17 * basti_ pretends not to see the importance of that fact.
11:36:18 <Igloo> CosmicRay: The FFIness could be removed (except for mmapping files) in exchange for about a factor of 2 in speed of some ops
11:36:33 <SamB> CosmicRay: but so does aquairing a C char*!
11:36:52 <CosmicRay> basti_: If FPS becomes part of fptools and is included with hugs and ghc, I would use it in a heartbeat.
11:37:00 <SyntaxNinja> Igloo: I know
11:37:02 <CosmicRay> SamB: no, it doesn't.  It requires only Foreign.C.blah
11:37:17 <CosmicRay> SamB: the code is already in System.IO to deal with it
11:37:17 <Igloo> OK, cool
11:37:24 <SyntaxNinja> Igloo: my flight got in at 10:30PM last night!
11:37:27 <SyntaxNinja> that's 22:30
11:37:34 <SyntaxNinja> it's now 11:30 the next day
11:37:36 <CosmicRay> and Foreign.C.blah doesn't require hugs users to build .so files and whatnot.
11:37:44 <basti_> CosmicRay: mmmk.
11:37:46 <Igloo> Ah, OK  :-)
11:37:49 <CosmicRay> maybe it's not a big deal, but to date, MissingH is 100% pure haskell code.
11:37:56 <Igloo> I assumed you'd just been catching up at work or something for a week
11:38:13 <SamB> CosmicRay: hmm, but then how is it a *C* char*?
11:38:29 <CosmicRay> SamB: I don't follow.  How is what a C char?
11:38:30 <SyntaxNinja> Igloo: I was in Germany for a week
11:38:43 <SamB> it sounds like what you don't like is *more* FFI
11:38:44 <CosmicRay> SamB: perhaps I should back up.  I am using hGetBuf/hPutBuf to deal with tar files.
11:38:59 <CosmicRay> SamB: Foreign.C.blah is not FFI (at least, not in my code)
11:39:20 <CosmicRay> SamB: it is a regular haskell module.
11:39:42 <CosmicRay> SamB: so anyway, hGetBuf takes data from a handle and puts it out in memory somewhere.
11:39:55 <CosmicRay> SamB: no conversions, no tricks, nothing else like that.  it is just there.
11:40:06 <SamB> CosmicRay: yes, I see.
11:40:15 <CosmicRay> SamB: so a person could treat is as a Ptr CChar, or a Ptr Word8, or whatever.
11:40:32 <CosmicRay> even a Ptr Word32 if you were so inclined.
11:40:37 <SamB> yeah
11:40:52 <SamB> not that it is that hard to cast a pointer anyway
11:41:01 <CosmicRay> so, let's say my algorithm for working with this binary block involves random access.
11:41:27 <CosmicRay> so, while I *could* pull it back into Haskell as [CChar] or [Word8] or even String, access will be inefficient.
11:42:05 <CosmicRay> and if I try to just use pointer arithmetic and dereference it a bunch of times, I am no better than C as far as safety is concerned.
11:42:21 <CosmicRay> (always must make sure I'm not going outside of the block, etc.)
11:42:26 <SamB> well yeah...
11:42:35 <CosmicRay> I'd rather convert the block into a haskell structure all at once, then access it randomly from there on.
11:42:55 <CosmicRay> and ideally, I wouldn't really have to convert it.  I was thinking perhaps there was some Haskell structure that could use that pointer internally
11:42:58 <CosmicRay> but probably not.
11:43:52 <kosmikus> hi Heffalump
11:44:55 <ulfdoz> Aber der Ansatz an sich, die Daten via SQL abzufragen wäre in meinen Augen wiederum generisch für die Arbeit mit einer Datenbank.
11:45:05 <ulfdoz> damn, sorry guys.
11:45:12 <ulfdoz> and girls (of course).
11:45:26 <SamB> @type Data.Array.IO.hGetArray
11:45:28 <lambdabot> GHC.IOBase.Handle
11:45:28 <lambdabot> -> Data.Array.IO.Internals.IOUArray Int GHC.Word.Word8
11:45:28 <lambdabot> -> Int
11:45:28 <lambdabot> -> IO Int
11:45:46 <SamB> @type Data.Array.IO.hPutArray
11:45:48 <lambdabot> GHC.IOBase.Handle
11:45:48 <lambdabot> -> Data.Array.IO.Internals.IOUArray Int GHC.Word.Word8
11:45:48 <lambdabot> -> Int
11:45:48 <lambdabot> -> IO ()
11:45:55 <CosmicRay> ooo.
11:46:10 <CosmicRay> is there a "what the hell are arrays" document somewhere?
11:46:16 <CosmicRay> I am confused by all the many options
11:46:45 <CosmicRay> also about what "in the IO monad" means in the description of IOUArray.
11:46:48 <SamB> CosmicRay: not that I know of. however, there is the source to Data.Array.*
11:46:56 <CosmicRay> does that mean that all operatins happen in the IO monad?
11:46:58 <CosmicRay> even reads?
11:47:17 <Igloo> Yes
11:47:25 <Igloo> As it's a mutable datastructure
11:47:44 <CosmicRay> hmm.
11:47:47 <CosmicRay> that is annoying.
11:47:54 <SamB> @type Data.Array.IO.unsafeFreeze
11:47:56 <lambdabot> forall e i (b :: * -> * -> *) (m :: * -> *) (a :: * -> * -> *).
11:47:56 <lambdabot> (Data.Array.Base.IArray b e,
11:47:56 <lambdabot> Data.Array.Base.MArray a e m,
11:47:56 <lambdabot> GHC.Arr.Ix i) =>
11:47:56 <lambdabot> a i e -> m (b i e)
11:47:59 <CosmicRay> but I suppose I could live with it.
11:50:18 <humasect> http://rafb.net/paste/results/Cg0CX823.html  <-- i don't understand this behavior.
11:51:14 <Heffalump> pattern matching doesn't work like that
11:51:23 <SamB> hmm, hGetArray and hPutArray don't actually look very efficient...
11:51:25 <humasect> i had the same problem with a case
11:51:36 <Heffalump> handle value1 = ... binds the first parameter to a new variable called value1
11:51:42 <Heffalump> it doesn't pattern match against the global value1 binding
11:51:50 <humasect> =o
11:51:52 <humasect> ohhh
11:51:56 <humasect> okay, right. hmm.
11:51:59 <humasect> thanks
11:52:08 <sethk> humasect, plus all three of those patterns match the same input
11:52:17 <Heffalump> sethk: I assume he realises that now :-)
11:52:28 <humasect> yep thanks =)
11:52:29 <Heffalump> s/he/he or she/ # since I have no idea
11:52:37 <beschmi> Cosmicray, you should be able to use unsafeFreeze to convert the IOUArray to an UArray
11:52:40 <sethk> Heffalump, the warning on the last pattern might actually be ok (as in what he wants)
11:52:42 <Heffalump> in general the pattern matching language is very restricted
11:52:58 <SamB> I suppose the best thing might be to make an IArray instance which stores a pointer and the range...
11:53:04 <Heffalump> you can only write things made up of data constructors and free variables in them
11:53:06 <humasect> qualified variables can't be used in patters. aww =(
11:53:12 <Heffalump> qualified variables?
11:53:27 <humasect> like "value1 = 2" using the namesspace to reach it.
11:53:49 <CosmicRay> thanks beschmi and everyone
11:53:58 <humasect> (these are constants retrieved from FFI #enum, they are not Enum but just constants.)
11:54:09 <CosmicRay> I am also wondering if I ought to try to do something with Parsec for binary files.
11:54:15 <CosmicRay> it is annoying that char is 32-bit. ;-)
11:54:59 <SamB> CosmicRay: with Parsec? no. with utility like that of Parsec? go ahead!
11:55:01 <Heffalump> using what namespace?
11:55:14 <Heffalump> you want to write Foo.value1 = 2 ?
11:55:41 <humasect> matching the pattern with the global
11:56:01 <humasect> handle Module.value1 = ...
11:56:11 <humasect> (same with caseof)
11:56:54 <Heffalump> you just _can't_ pattern match for the value of some other variable, however much you try to trick the compiler :-)
11:57:01 <Heffalump> handle value | value == value1 = ...
11:57:02 <Heffalump> would work
11:57:11 <humasect> 12:52 (humasect) qualified variables can't be used in patters. aww =(
11:57:12 <humasect> 12:52 (Heffalump) qualified variables?
11:57:25 <humasect> tried to explain, sorry.
11:57:38 <humasect> yeah. thanks
11:57:51 <SamB> I wish you could! it would be really sweet!
11:57:54 <Heffalump> I thought that was what you meant initially, then got confused. Anyway :-)
11:58:12 <Heffalump> SamB: it's basically equivalent to allowing non-linear patterns. Which would also be neat, potentially.
11:58:26 <Heffalump> but it's very easy for the user to get confusing behaviour when they typo, then
11:58:35 <Heffalump> (in either case)
11:58:37 <SamB> Heffalump: hmm? non-linear patterns?
11:58:49 <Heffalump> f x x = "Yes they're the same"
11:58:54 <Heffalump> f _ _ = "No they aren't"
11:59:13 <Heffalump> writing that is illegal
11:59:30 <Heffalump> but if it wasn't, you might expect that the first line for f would make sure that its two arguments were equal
11:59:47 <CosmicRay> I heard that erlang has some nice binary pattern matching features
11:59:50 <basti_> that relies on resolution
12:00:04 <basti_> i dont think anyone wants that in pure haskell .)
12:00:09 <Heffalump> basti_: does it?
12:00:10 <SamB> hmm
12:00:13 <Igloo> resolution?
12:00:23 <basti_> i think thats what this technique is called
12:00:26 <Heffalump> I think you just pattern match and then check for equality of the values bound to any repeated names
12:00:31 <Heffalump> Igloo: like in prolog
12:00:32 <basti_> resolving clauses
12:00:38 <Heffalump> but I don't think you need it
12:00:47 <basti_> i think you don't need it ;)
12:00:49 <SamB> I personally would only want it for Int constants...
12:01:09 <CosmicRay> Heffalump: that would be interesting, but it would be tricky, no?  x would have to be a member of Eq, and somehow the compiler would have to enforce that
12:01:16 <Heffalump> CosmicRay: yes
12:01:19 <Heffalump> which wouldn't be that hard
12:01:20 <kosmikus> there's nothing in Haskell that enforces (==) to be an equivalence relation, though
12:01:22 <Heffalump> there's a syntactic translation
12:01:25 <Heffalump> f x x = ...
12:01:28 <Heffalump>  becomes
12:01:32 <Heffalump> f x y | x == y = ...
12:01:45 <Heffalump> kosmikus: sure, but you get what you ask for :-)
12:01:45 <Igloo> kosmikus: But it doesn't have to be
12:01:56 <kosmikus> so, would 'f x x x' would check all three?
12:01:59 <Heffalump> though you have to define whether f x x x
12:02:02 <Heffalump> oh, what he said.
12:02:04 <CosmicRay> now I have absolutely no idea if what I'm about to say is true or not, but:   isn't that not how pattern matching works now?  That is, isn't pattern matching structural
12:02:09 <basti_> what would f x (_:x) do?
12:02:21 <Heffalump> basti_: same translation
12:02:25 <Heffalump> f x (_:y) | x == y
12:02:26 <CosmicRay> basti_: compare x1 to tail x2, I guess.
12:02:36 <SamB> I would just want it to work like C's enum ;-)
12:02:40 <Heffalump> no resolution in sight :-)
12:02:52 * basti_ ponders a bit
12:02:55 <Heffalump> SamB: you can use guards like I suggested
12:03:16 <Igloo> Presumably f x ~(_:x) would be equivalent (unless (==) ignored its second arg)
12:03:16 <Heffalump> CosmicRay: pattern matching is structural, yes.
12:03:20 <Heffalump> but (==) isn't necessarily
12:03:27 <xerox> Is there an extension enabling this, or is it theoretical Haskell?
12:03:32 <SamB> Heffalump: that doesn't look very nice, though!
12:03:33 <Heffalump> I think it's theoretical Haskell
12:03:52 <kosmikus> how would f x ~(_:x) work then?
12:04:22 <xerox> What's the problem with it?
12:04:23 <Heffalump> with great difficult, IMO :-)
12:04:23 <kosmikus> it would just remove the effect of the ~?
12:04:41 <xerox> I think it would propagate it.
12:04:54 <kosmikus> propagate?
12:05:02 <Igloo> kosmikus: unless (==) ignored its second arg, like I said  :-)
12:05:11 <xerox> What is   f x ~(y:ys) = ..   expected to do?
12:05:23 <CosmicRay> Igloo: that would be a very helpful operator ;-)
12:05:23 <xerox> err.
12:05:32 <basti_> xerox: not break if the second arg isn't a list, until you access y or ys.
12:05:33 <CosmicRay> Igloo: the opposite of seq, eh? ;-)
12:05:35 <xerox> f x ~(_:ys) | x == ys = ...
12:05:44 <beschmi> CosmicRay: i wonder if something like http://haskell.org/hawiki/RegexSyntax could be used for binary pattern matching
12:05:47 <kosmikus> xerox: ok, so it'd succeed in all cases, but fail once you access the tail of that second argument if that's not equal to the first?
12:05:55 <xerox> basti_: so what is the tilde there for?
12:05:58 <Heffalump> that's insane!
12:06:00 <basti_> xerox: just this
12:06:17 <Igloo> CosmicRay: I'm sure there are types for which you want all things to be considered equal (or unequal), and you might have the above in a generic function
12:06:20 <CosmicRay> beschmi: yes, actually this already exists (Pesco's library, for instance.)
12:06:21 <Heffalump> but the obvious translation, like xerox's, would force an immediate access to ys
12:06:25 <xerox> basti_: what's the difference between this and not having it?
12:06:25 <Heffalump> so it wouldn't randomly fail
12:06:39 <CosmicRay> beschmi: but one annoyance is that in Haskell, a char is 32 bits
12:06:46 <CosmicRay> beschmi: and a string is a list of 32-bit chars.
12:06:54 <Heffalump> (==) on () can ignore its arguments
12:06:56 <basti_> xerox: f 42 [] would break in any case without ~
12:06:56 <CosmicRay> beschmi: this creates some inefficiencies
12:07:07 <Heffalump> though maybe you'd expect it to be strict
12:07:18 <CosmicRay> beschmi: and it also creates some hassles with hugs and charset translation (though those can be worked around without too much trouble)
12:07:53 <CosmicRay> beschmi: people that are expecting to perform bitwise arithmetic on 8-bit words can be in for a surprise, though.
12:08:41 <xerox> In cases like this one (maybe?), when big discussions gets overlapping, becoming difficult to chase, there is #haskell-overflow.  For present, or future reference.
12:08:57 <Heffalump> too many #haskell-foos !
12:09:20 <xerox> Heffalump: it was very very useful yesterday.  Now I understand partial continuations, modulo questions about it ;-)
12:09:37 * Igloo objects to moving discussions that belong here elsewhere just because they are happening
12:09:43 <Speck> huh? there are more #haskell channels on irc???
12:10:15 <xerox> Speck: the other one is #haskell-blah, for non-haskell related discussions.
12:11:54 <SamB> xerox: how do you have a non-haskell related discussion?
12:12:02 <SamB> after learning haskell, I mean ;-)
12:12:10 <xerox> SamB: that's a profound mystery.
12:13:28 <Speck> verily, a koan deserving much meditation. perhaps in #haskell-blah.
12:18:49 * shapr smacks David B. Held with some facts
12:19:16 <xerox> Who needs fact when you could wave hands in the air furiously.
12:20:23 <Oejet> xerox: And get exercise at the same time.
12:22:07 <Heffalump> shapr: context?
12:23:04 <xerox> shift shapr to know
12:23:31 * SamB hopes they are facts from a book, books being heavier than small stacks of paper or streams of bytes...
12:24:30 * xerox slaps SamB around a bit with a large TAoCP
12:28:32 <shapr> Here's the context for the David B. Held comment - http://lambda-the-ultimate.org/node/view/1030#comment-10759
12:29:00 <shapr> Aw, I should have put (hire me!) in there somewhere.
12:30:06 * xerox pokes shapr
12:30:14 <shapr> ?
12:30:15 <xerox> Less trolling, more FLM.
12:30:21 <shapr> yes, good point :-)
12:30:24 <xerox> <blink>
12:30:41 <shapr> I didn't think I was trolling, I thought I was in fact supplying facts... but it does seem I was responding to a trol.
12:30:45 <basti_> btw trolling, what happened with this "C++" zealot (gimme a torus boys!) ;)
12:31:19 <xerox> shapr: "I don't think it too." said xerox, whispering "FLM" in shapr's hear.
12:31:20 <Heffalump> I think I agree with him more than with you.
12:31:40 <Heffalump> But I'd have to go looking through all the code I've written to mine good specific examples.
12:32:46 <sieni> I would actually want to know C++ better
12:33:27 <shapr> Heffalump: Yeah, but you have a job writing C, obviously you agree with him ;-)
12:33:44 <xerox> I don't think you do reinvent the wheel in Haskell at all.
12:34:08 <xerox> In fact (monads?) composability improves code-reusability very, very much.
12:34:12 <Heffalump> I have a job writing C because it pays me money to do something I like (writing compilers), not because I like writing C..
12:34:33 <Heffalump> my main point of comparison is between Haskell and Perl, I think
12:34:52 <Speck> xerox: what if you find you need to write the monadic version of a pure algorithm you've already written. Is that reinventing the wheel?
12:34:57 <Heffalump> and there's a lot of Perl I've written where I've been able to just reach for CPAN and find what I need, but get stuck because it doesn't exist with the equivalent Haskell
12:35:25 <xerox> Speck: I call it Nymphaea ;-)
12:36:25 <xerox> I don't know much perl, tough I did some work with it, and I think it has one of the largest active community that exists around a language nowadays.
12:36:36 <Speck> xerox: you'll have to clue me in later
12:36:58 <SamB> Speck: I would call that a different algorithm!
12:37:20 <Speck> SamB: I would call _that_ splitting hairs ;-)
12:39:29 <xerox> Speck: in nymphaea I wrote an algorithm using lists to model nondeterminism.  Then we generalized it to Monad(Plus), getting one of the most interesting and fun piece of code I ever written.  We tried some different monads which calculated relative probability of the results to pick one randomly.  It was some kind of applied whipuptitude I never seen in other places.
12:40:21 <xerox> I probably put together too many ideas in one sentence.
12:41:11 <shapr> Heffalump: You could say the same about C though.
12:42:11 <Heffalump> yeah. And it'd be true.
12:42:30 <xerox> It's comparable to debauchery, the more you give, the more you get - being active in the community would only give good outcomes.
12:42:31 <Heffalump> but people tend to choose C for raw performance
12:42:46 <Heffalump> rather than for great libraries
12:44:35 <Philippa> not having to muck around with FFI issues has made me choose C++ for tasks in the past
12:44:54 <Oejet> I have found the Java standard library quite lacking when writing numerical programs.
12:45:15 <Heffalump> yeah, it's good for GUI shit and things like that
12:45:29 <genneth> shapr: you got some jobs with haskell? damn
12:45:31 <Heffalump> or big Java-buzzword type things
12:45:33 <genneth> :-p
12:45:57 <Muad_Dib> yeah :P
12:45:58 <Heffalump> genneth: he chose to implement some jobs that were language-neutral using Haskell, which is slightly different :-)
12:46:04 <Heffalump> EJBs and all that shit.
12:46:25 <Heffalump> (re big Java-buzzword type things)
12:47:15 <xerox> @what EJB
12:47:16 <lambdabot> Unknown command, try @listcommands.
12:47:24 <genneth> @google EJB
12:47:25 <lambdabot> http://java.sun.com/products/ejb/
12:47:28 <Speck> Enterprise Java Beans
12:47:36 <xerox> Beans?
12:47:43 <Speck> yes, Magic Beans
12:47:49 <xerox> Magic Beans.
12:47:56 <genneth> they grow money
12:48:01 <Speck> they make your web application "scale" to the heavens
12:48:14 <Itkovian> uhu
12:48:14 <genneth> they grow out of fertiliser
12:48:25 <Speck> where you will be immediately squashed anyway by the corporate giants
12:48:26 <Speck> :-P
12:49:06 <genneth> am i the only one that thinks "scaling" in that sense it best done by throwing hardware at it?
12:49:23 <genneth> i mean, if you're going the EJB route, you're not exactly strapped for cash...
12:50:09 <Speck> stop trying to define scalability! you'll ruing all my fud^Hfun
12:51:17 <Philippa> scalability does in part mean being /able/ to throw increasing amounts of hardware at it
12:51:33 <Philippa> eg sooner or later you won't be able to make any one computer fast enough
12:53:06 <Heffalump> I think it means that in full.
12:53:29 <Heffalump> "scalable" architectures are ones where the bottlenecks can be removed by adding more stuff.
12:53:31 <genneth> i think they should have bought out erlang when they have the chance...
12:54:21 <Philippa> wouldn't have sold the way Java did
12:54:41 <Philippa> too different - Java targetted a marketful of programmers who grew up on C and C++
12:54:44 <shapr> Heffalump: I don't that is different, clients have needs, how you fulfill them is unimportant, as long as you do it well.
12:54:57 * rep curses at linux
12:55:00 <Philippa> some clients have needs regarding the language you use though
12:55:30 <Philippa> something that creeps in more and more as projects get bigger
12:55:40 <shapr> Sure, but there are still lots of jobs where it's unimportant.
12:55:51 * Philippa nods
12:56:04 <shapr> Haskell plays nice with C via the FFI and Java via the JVM bridges.
12:56:10 <Philippa> Haskell's well-suited for web stuff, certainly - sure, the libs need a little work, but damn does it pay off
12:56:17 <shapr> It's got xml-rpc for the REST stuff.
12:56:21 <Philippa> that's not the only reason for a language requirement
12:56:38 <Philippa> bus factor, for example. How easy is it to get someone else to hack on it?
12:56:47 <xerox> Philippa: what do you advice to look at, to get into haskell web programming?
12:56:57 <shapr> Yeah, but I know the fix for Haskell Bus Factor...
12:57:04 <Philippa> clone SPJ? ;-)
12:57:41 <shapr> Nah, I've talked to some Haskellers who told me they'd be happy to have a reciprocal "We'll pick up your project if you get a Bus Error" agreement.
12:57:42 <Philippa> xerox: I've been using Network.CGI and may well move to one of the modified versions. Haven't had to do anything more strenuous yet - ask someone else about XML
12:57:57 <Philippa> yeah, that works as a starting point for now
12:58:07 <Philippa> less useful 5-20 years out though
12:58:23 <shapr> How so?
12:58:33 <genneth> i would be nice for there to be a haskell web framework that did REST purely, and enforced it...
12:59:03 <Philippa> unless their name's on all the contracts, sooner or later individual bus error agreements'll fall apart
12:59:19 <autrijus> yay, I submitted two lightning talks to Euro OSCON
12:59:28 <autrijus> "Larry was a mariner" and "Visual Basic Rocks!"
12:59:29 <Philippa> in the long run, haskell and haskell-derived languages need to be big enough to be able to advertise for consultants
12:59:41 <Korollary> Visual Basic what ?
12:59:47 <autrijus> the description of the latter:
12:59:48 <autrijus> In the Open Source world, VB has long been held in disdain and contempt.  However, ever since the VB team was infiltrated by lambda ninjas, it took a strange turn and introduces some mind-bendingly advanced concepts not found in free dynamic languages.  You'll have to see it to believe it!
12:59:51 <xerox> What is REST?
12:59:55 * genneth finds him flame suit
13:00:05 <malcolm> how does a language advertise?
13:00:05 <genneth> s/him/his/
13:00:28 <Heffalump> shapr: your solution to the bus factor is viable because the projects you do involve off-site work anyway
13:00:43 <genneth> autrijus: I think VB has been held in disdain in the commercial world too
13:01:02 <autrijus> genneth: right, but this is OSCON, so gotta play to the tune
13:01:12 <xerox> autrijus: what concept were you referring about?
13:01:29 <xerox> err, "what concepts were you referring to", even.
13:01:33 <Philippa> malcolm: for those running haskell-based projects to be able to advertise, HTH
13:01:40 <shapr> Yay, my trac+darcs FLM repo is online!
13:01:55 <Philippa> so FLM now works?
13:02:01 <Heffalump> FLM?
13:02:06 <malcolm> Philippa: yeah, but I meant deeper than that.
13:02:15 <shapr> er, no... just getting trac working with lelit's darcs patch.
13:02:29 <autrijus> xerox: type inference, anonymous types, query combinator and comprehensions, strong duck typing, Maybe types
13:02:41 <xerox> autrijus: in VB ?!
13:02:48 <autrijus> xerox: aye.
13:02:53 <Speck> vb is going places
13:02:58 <xerox> autrijus: but .net?
13:03:03 <autrijus> xerox: http://msdn.microsoft.com/vbasic/future/default.aspx -- click on "Overview"
13:03:08 <Korollary> obviously not vb6
13:03:25 * Heffalump googles and finds out
13:03:26 <Korollary> 9.0 ?
13:03:27 <Philippa> malcolm: killer apps that turn out to be easily hackable get my vote
13:03:37 <Heffalump> Stuff to help with annotation is cool
13:03:44 * malcolm agrees with Philippa
13:03:54 <Heffalump> though I think, as with wikis, the main problem is organising the information well so there's no massive overload
13:04:09 <shapr> autrijus: Um, this looks like Erik Meijer ported bunches of Haskell into VB9
13:04:35 <Korollary> I was hoping they would drop the keyword "dim".
13:05:04 <autrijus> shapr: that is what I meant in my "lambda ninja" quip, yes.
13:05:12 <shapr> nifty!
13:05:20 <Philippa> malcolm: I think we can do it in web apps, though as time goes on we'll need bigger library support to keep up with the set of client-side languages in use
13:05:41 <Korollary> SQL in the language...
13:05:51 <genneth> xerox: http://www.xfront.com/REST-Web-Services.html
13:05:57 <genneth> @google REST
13:05:59 <lambdabot> http://www.xfront.com/REST-Web-Services.html
13:06:16 <malcolm> Philippa: you mean like generating javascript on-the-fly, a la Links?
13:06:21 <Philippa> yeah
13:06:26 <autrijus> shapr: though their dylan-esque incremental static typing is something I very much think is The Way Forward.
13:06:39 <Philippa> well, maybe done manually(ish), but hey
13:07:26 <xerox> What do you want to generate JavaScript for?
13:07:41 <malcolm> xerox: it was just an example
13:07:59 <xerox> malcolm: I'm just asking, I don't know much about those things.
13:08:22 <autrijus> shapr: even Daan expressed the same sentiment in ICFP... I was much surprised
13:08:35 <Philippa> xerox: client-side work in web apps
13:08:41 <autrijus> him being the advanced-static-MLF Morrow guy and all
13:08:43 <malcolm> so, is shapr's Haskell on Heat web framework ready yet :-)
13:08:50 <sieni> Hmm... can I restrict the type class in parametric algebraic type declaration, e.g. I want to say data Foo a b = Bar a | Baz b, but restrict b to belong to a numeric type?
13:09:23 <xerox> sieni: I think the constraint stay between data and Foo
13:09:37 <ski> sieni : data Num a => Foo a b = Bar a | Baz b     (though this might not give all you think it would)
13:09:52 <ski> (s/Num a/Num b/)
13:10:00 <sieni> ski: what would be the caveat?
13:10:08 <dcoutts> SamB, if you changed which version of Gtk+ you had installed then you need to make clean since otherwise it caches the precompiled Gtk+ headers (which might cause missing symbol errors when you build)
13:10:26 <malcolm> sieni: yeah, all you gain is that the compiler forces you to add the same constraint on any function involing Foo
13:10:31 <dcoutts> SamB, in fact you might need to make distclean
13:10:42 <ski> just using a type 'Foo x y' does not assuming x is in Num, you have to explicitely state that anyways
13:11:16 <ski> sieni : e.g. one sadly can't do   data Ord a => Set a = ...    and then  instance Monad Set
13:11:26 <dcoutts> SamB, or darcs pull and then make clean (since I recently changed the cleaning of the .precomp files from 'distclean' to just 'clean')
13:11:51 <gour> dcoutts:  i just found out that e.g. ruby-gnome2 ships with libgda
13:12:20 <dcoutts> gour, well you can look into doing the libgda bindings if you like, the apigen program should handle it]
13:12:21 <Speck> ruby-gnome2 is a massive undertaking
13:12:36 <Speck> it's bindings for all of the gnome libraries
13:12:37 <SamB> dcoutts: but I did `rm */*.precomp'
13:12:52 <gour> dcoutts: however, let's leave it for later, after finishing top-priorities
13:13:07 <dcoutts> SamB, oh ok, so what's the error exactly?
13:13:26 <gour> Speck: but gtk2hs is already something
13:13:41 <dcoutts> gour, yep
13:13:52 <gour> dcoutts: i can put it on my haskell-todo list
13:14:00 <dcoutts> gour, heh :-)
13:14:11 <sieni> malcolm, ski, xerox: thanks
13:15:05 <SamB> dcoutts: that would work great if I had gotten the darcs repo, but I downloaded the tarball because darcs takes too long, gives too little feedback, and is not good enough at error recovery...
13:15:25 <SamB> I would be happy to download a tarball of the darcs repo, though
13:15:36 <gour> dcoutts: enough for today, last few days were extremely busy here
13:15:56 <gour> dcoutts: i wish you good hIDE hacking
13:16:16 <dcoutts> gour, ta
13:16:28 <Speck> dcoutts: should I be using ghc 6.5 to hack hIDE?
13:16:38 <dcoutts> Spark, not sure, ask Lemmih
13:16:45 <ski> (resason instance Monad Set   doesn't work is that Monad requires the monad type to work for all argument types 'a', not just those in Ord)
13:17:20 <Oejet> Good night all.
13:17:54 <xerox> Goodnight Oejet!
13:18:08 <SamB> anyway, I want to paste the actual error
13:18:37 <SamB> where shall I paste it?
13:18:50 <dcoutts> SamB, privmsg
13:20:35 <dcoutts> SamB, oh that might not work if your nick is not registered with freenode
13:20:50 <dcoutts> @paste
13:20:51 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:21:18 * SamB identifies himself with nickserv
13:24:52 <SamB> <dcoutts> ok, use the latest darcs version
13:25:13 <dcoutts> darcs get http://haskell.org/gtk2hs/darcs/gtk2hs/
13:25:27 <SamB> well, the trouble is, I'm on 56k, and darcs doesn't take kindly to being interrupted...
13:25:41 <dcoutts> it's a 700k download
13:25:49 <SamB> could I maybe download a tarball?
13:26:03 <dcoutts> the darcs patch is actually compressed I think
13:26:41 <SamB> well, darcs doesn't like it very much when it for some reason gets interrupted...
13:27:07 <dcoutts> SamB, actually it's 852K
13:27:46 <dcoutts> SamB, I'll probably do another proper tarball release in the next couple weeks
13:28:00 <SamB> when I say tarball, I mean a tarball with a _darcs dir
13:28:10 <dcoutts> ok
13:28:42 <SamB> (actually, the _darcs dir is really ALL it would need ;-)
13:29:09 <Heffalump> you don't need _darcs/current, either
13:29:14 <Heffalump> you can use darcs repair to reconstruct that
13:29:23 <SamB> Heffalump: oh really? neato!
13:29:40 <Heffalump> and then darcs revert -a to reconstruct the working copy
13:29:41 * SamB thinks there ought to be a tool to produce such tarballs
13:30:10 <Heffalump> darcs repair will take quite a long time to run, though
13:30:22 <Heffalump> but it'll all be local work
13:30:27 <SamB> Heffalump: longer than darcs get?
13:30:54 <Heffalump> not sure.
13:30:56 <Heffalump> probably not much more
13:30:59 <dcoutts> SamB, a bzip compressed tarball of the whole repo is 2.3M
13:31:08 <dcoutts> SamB, want it?
13:31:11 <Heffalump> it'll spend a bit of time figuring out "oh, it's corrupted, better fix it"
13:31:28 <dcoutts> or how'd I produce something more minimal?
13:31:29 <SamB> dcoutts: what about with nothing but _darcs, sans _darcs/current?
13:31:31 <Heffalump> dcoutts: where is the repo gettable from?
13:31:44 <shapr> malcolm: There's no code yet, but one point of progress is that ZFS is exactly what I wanted for the version control. So I'm glad I sent Oleg email :-)
13:31:45 * Heffalump will experiment with what I claimed is true and make a tarball for SamB
13:31:46 <dcoutts> Heffalump, http://haskell.org/gtk2hs/darcs/gtk2hs/
13:33:08 <malcolm> shapr:  I see your post on LtU about ZFS.  sounds interesting, if indeed just a baffling as all of Oleg's work
13:33:21 * SamB wonders what kind of CPU Heffalump has
13:33:45 <SyntaxNinja> <--- wrote a filesystem too!!
13:33:53 <SyntaxNinja> oleg is funny
13:34:25 <SyntaxNinja> how's it going malcolm?
13:34:27 <bill-tom-bow> what is haskell good for?
13:34:37 * malcolm wishes he had been at the HW to see the demos
13:34:46 <sylvan> bill-tom-bow, it gets you chicks
13:34:54 <bill-tom-bow> nice
13:35:00 <sylvan> =)
13:35:25 <shapr> I've also been experimenting with Data.Graph, Haskell2Xml, and existentially quantified types.
13:35:26 <SamB> bill-tom-bow: calculating programs in
13:35:53 <SyntaxNinja> bill-tom-bow: I can tell you my opinion on that. some may disagree.
13:35:53 <kosmikus> malcolm: why couldn't you be there?
13:36:00 <bill-tom-bow> imagine fi you could program chciks?
13:36:03 <malcolm> shapr: this weekend I made good progress on unifying Haskell2Xml and Xml2Haskell into a single class
13:36:04 <bill-tom-bow> woa nelly
13:36:05 <astrolabe> bill-tom-bow: writing programmes clearly and concisely.
13:36:05 <SyntaxNinja> bill-tom-bow: I think it's good for rapid prototyping
13:36:07 <Heffalump> samb: 888K. I think it works ok.
13:36:10 <shapr> malcolm: whoa awesome!
13:36:17 <ValarQ> shapr: sounds like a lot of fun :)
13:36:17 <bill-tom-bow> how about web?
13:36:20 <SamB> Heffalump: nice!
13:36:24 <SyntaxNinja> bill-tom-bow: and even better for actually developing a program after you've rapidly prototyped it w/ haskell
13:36:25 <Heffalump> samb: fast Xeon. Didn't even notice the time darcs repair took.
13:36:28 <bill-tom-bow> is it ok for the web?
13:36:28 <Heffalump> or darcs revert -a
13:36:44 <SyntaxNinja> bill-tom-bow: there are a lot of toools for web development, but I don't know much about that. there's WASH and mod_haskell, fwiw.
13:36:48 <malcolm> kosmikus: no funding (current project not FP-related, although that doesn't stop me writing tools for it in haskell)
13:36:59 <SyntaxNinja> bill-tom-bow: it seems good :)
13:37:02 <Heffalump> darcs repair ; rmdir _darcs/current-old ; rm _darcs/patches/pending ; rm _darcs/patches/unrevert
13:37:03 <bill-tom-bow> hehe
13:37:05 <shapr> malcolm: ZFS isn't so baffling if you shade your eyes against the continuation monad transformer bit. Past that, it's just a filesystem that uses the zipper to get transactional semantics.
13:37:06 <Heffalump> sorry, missed a bit
13:37:07 <bill-tom-bow> I love shemale porn
13:37:08 <ValarQ> shapr: what is this Data.Graph module?
13:37:08 <kosmikus> malcolm: I understand
13:37:14 <Heffalump> darcs repair ; darcs revert -a ; rmdir _darcs/current-old ; rm _darcs/patches/pending ; rm _darcs/patches/unrevert
13:37:21 <Heffalump> is I think a reliable way to restore it
13:37:27 <shapr> ValarQ: It's Martin Erwig's Function Graph Library added to the standard libs.
13:37:31 <SamB> it seems to be good for just about everything except writing C or C++ or OO code...
13:37:40 <Heffalump> http://urchin.earth.li/~ganesh/temp/gtk2hs.tar.bz2
13:37:47 <astrolabe> bill-tom-bow: It is also good for expanding your mind.
13:38:14 <bill-tom-bow> can u build apps in modules
13:38:19 <ValarQ> shapr: for writing graphviz graphs?
13:38:22 <bill-tom-bow> with different parts doing diferent stuff?>
13:38:25 <shapr> ValarQ: It does that too.
13:38:30 <bill-tom-bow> and how about saving info for later?
13:38:41 <sylvan> bill-tom-bow, of course!
13:38:44 <bill-tom-bow> is there such a thing as a functionla dtabase?
13:38:51 * malcolm thinks he ought to know what a zipper is
13:38:51 <bill-tom-bow> or do you save in files?
13:38:56 <bill-tom-bow> or in relational database?
13:38:58 <shapr> @wiki TheZipper
13:38:58 <lambdabot> http://www.haskell.org/hawiki/TheZipper
13:39:00 <SyntaxNinja> bill-tom-bow: yeah
13:39:06 <SamB> bill-tom-bow: you can do just about all of those
13:39:09 <SyntaxNinja> bill-tom-bow: you can write to files or use databases
13:39:17 <shapr> malcolm: It's sort of like "generate your own accessor"
13:39:23 <SamB> though I don't know what you mean by a functional database...
13:39:36 <bill-tom-bow> i dunno
13:39:42 <bill-tom-bow> Ive heard of an object databse
13:39:46 <bill-tom-bow> and a realtionla dtabase
13:39:50 <bill-tom-bow> so why not functinal
13:39:51 <bill-tom-bow> lol
13:40:19 <Speck> persisted, related, ADTs?
13:40:28 <malcolm> shapr: ah, I've implemented one of those.
13:40:32 <SamB> you can even write imperative programs
13:40:50 <shapr> malcolm: So you see how that could give transactional semantics on a filesystem?
13:41:05 <malcolm> shapr: not immediately, no
13:42:02 <kosmikus> malcolm: being on the PC wasn't enough to get funding?
13:42:25 <Igloo> I'm not entirely clear what you mean by "transactional semantics", but his implementation means that if two people read and then commit later then the changes commited first are just lost, which doesn't sound much like what I'd understand from the term
13:42:39 <malcolm> kosmikus: to be honest, I didn't think it worth asking
13:42:47 <shapr> Well, a purely functional access on the zipper can be a modification that returns a new value of the zipper.
13:42:54 <wammy-salami> heh
13:43:02 <wammy-salami> lisp room hates my guts
13:43:05 <wammy-salami> jesus
13:43:26 <shapr> For ZFS, it's a zipper on a 'filesystem' that gives maximal sharing.
13:43:57 <shapr> And yes, if you hold the older copies, you have unlimited undo information...
13:44:02 <SamB> the simplest way is by using the Read and Show typeclasses
13:44:20 <SamB> though Read is fairly slow
13:44:31 <xerox> Igloo: good point.
13:44:43 <shapr> Igloo: Actually, there's a supervisor process that gets to deal with conflicts.
13:45:22 <Igloo> Fair enough; I don't think he mentioned that in his demo
13:45:24 <xerox> Igloo: but I think you can do snapshots, and revert back - maybe even after committing?
13:45:28 <Heffalump> Igloo: he did sort of
13:45:32 <xerox> Yeah.
13:45:37 <Igloo> OK
13:45:40 <Heffalump> transactional semantics usually mean "either all the effects happen or none do"
13:45:46 <Heffalump> so you don't get any part-way completed things
13:45:54 <shapr> I want to use ZFS to create development versions of a website, or be able to undo any changes if something doesn't work out.
13:46:21 <Igloo> I think I'd also want to know which was done, though  :-)
13:46:24 <shapr> In this case, you keep the filesystem you started with.
13:46:43 <Heffalump> shapr: can you summarise why using a zipper is better than normal trees for this?
13:47:26 <xerox> Heffalump: it's handier to move here and there?
13:47:31 <malcolm> shapr: Oh, I think I get the idea now.  The transactional semantics don't really come from the zipper at all, but from standard lazy datastructures where it is easy to hold onto previous versions.
13:47:41 <SamB> Heffalump: none of those rm*s work
13:48:03 <shapr> This zipper is automatically derived, so I get to change my datatype as much as I want. The zipper is also used in subversion as the model for version control.
13:48:08 <Heffalump> samb: interesting. You did them from the gtk2hs directory?
13:48:17 <SamB> Heffalump: yes
13:48:19 <Heffalump> shapr: huh?
13:48:43 <SamB> the current-old wasn't under _darcs here
13:48:50 <malcolm> My zipper (although I didn't know that was what it was called at the time) is for navigating through haskell expressions in the hat-trail browser (debugger).
13:48:51 <Heffalump> samb: and you used the fixed version that did darcs revert -a ?
13:48:59 <xerox> Heffalump: The zipper is monadic and parametric over the data structure, and the way directions are expressed.
13:49:22 <SamB> Heffalump: yeah
13:49:30 <Heffalump> samb: oh, hmm, I don't have the directory either
13:49:43 <Heffalump> but _darcs/patches/pending and unrevert are there
13:49:53 <Heffalump> I did have the directory when I tried it _before_ I made the tarball :-)
13:50:16 <Heffalump> xerox: but a tree can be monadic and parametric over the data structure, can't it?
13:50:29 <SamB> maybe I had those and they got deleted already when I tried to run the whole thing?
13:50:36 <xerox> Heffalump: it is, but it is not over the way directions are expressed.
13:50:47 <Heffalump> xerox: hmm. maybe.
13:51:06 <Heffalump> SamB: hmm, not sure.
13:51:10 <Heffalump> anyway, if you don't have them, it's fine.
13:51:14 <Heffalump> They'd just be wasting space if you did.
13:51:16 <malcolm> hmm, is there a zipper class then?
13:51:19 <SamB> yeah, I know that ;-)
13:51:19 <Heffalump> (and there'd be a risk of a corrupted pending)
13:51:33 <xerox> malcolm: yup.
13:51:34 <SamB> I mean about it being fine if I don't have them
13:51:41 <xerox> malcolm: check for ZipperM.hs in ZFS sources
13:52:12 <xerox> (which uses fundeps)
13:52:48 <SamB> what version of automake should I use for this?
13:53:45 <genneth> SamB: famous last words...
13:54:06 <xerox> Howdy praseodym, how's code?
13:54:39 <SamB> oh, it says down here at the bottom of these error messages...
13:55:13 <SamB> automake 1.8, apparantly...
13:55:22 <SamB> or not.
13:56:00 * SamB tries just running autoreconf
13:56:51 <SamB> hmm, it doesn't seem to quite work...
14:00:50 <SamB> hmm, not quite working!
14:00:53 <ski> hm, wasn't mnesia sortof a functional database .. ?
14:03:33 <shapr> malcolm: The ZFS demo lets multiple users telnet in and make changes, and they each keep their current working directory and whatever changes they make. I'm thinking 'transparent codebase forks.'
14:03:40 <shapr> hiya Cosine, learning Haskell?
14:03:58 <shapr> er wait, I've seen you here before, haven't I?
14:03:59 <TheHunter> Heffalump, malcolm, what Oleg calls "The Zipper" is just an equivalent representation of "The Web" (http://citeseer.ist.psu.edu/hinze01web.html), obscured by usage of delimited continuations. Afaics, ZFS can't remember the cursor when the directory tree is refreshed.
14:04:30 <Cosine> not really. i was just checking to see if there was a haskell channel, cuz i'm in the latex channel and all the guys there are talking about is haskell
14:04:37 <xerox> TheHunter: a web could do it?
14:05:01 <TheHunter> you can convert a web to an Oleg-style zipper.
14:05:04 <shapr> Cosine: Ok, if you decide you want to try out Haskell, I'd be happy to give you the quick tour.
14:05:13 <SamB> okay, I think I've got the autocrap all done... it should build now...
14:05:32 <Cosine> sure i don't mind. the first time i heard of haskell was in an ACM programming contest
14:05:34 <TheHunter> i haven't checked the details, but I'm pretty sure you could keep the nice sharing properties.
14:05:47 <kosmikus> #latex: that's my fault ...
14:06:03 <shapr> kosmikus: good advertising! ;-)
14:06:10 <shapr> Cosine: Ok, the tour!
14:06:38 <shapr> The first stop on our tour of #haskell is the handy lambdabot, with lots of useful functions for a budding Haskell programmer...
14:06:53 <genneth> i seem to be having trouble importing Control.Monad.State ...
14:06:54 <SamB> is that also the last stop?
14:06:55 <shapr> The next stop is the channel topic with the url for the channel logs.
14:07:30 <shapr> After that we have the Haskell Wiki with useful info for all skill levels - http://www.haskell.org/hawiki/
14:07:43 <shapr> @learn And of course the famous "Learning Haskell" page!
14:07:44 <lambdabot> http://www.haskell.org/learning.html
14:07:48 <genneth> ski: i seem to remember thinking that mnesia was like STM, just bigger and distributed
14:08:03 <Cosine> what are the advantages of haskell
14:08:05 <Cosine> ?
14:08:25 <shapr> If you want the Baskin-Robbins taste test of Haskell (designed for impatient people), check out the HaskellDemo - http://www.haskell.org/hawiki/HaskellDemo
14:08:26 <Philippa> it's a pure functional language with a decent type system
14:08:29 <SamB> Cosine: fun, higher-order, functional, compositional, monadic!
14:08:42 <SamB> oh, and typed!
14:08:55 <Philippa> you get loads of control over side-effects in your code so they're unlikely to bite you hard if you take a little care up front, for example
14:09:05 <Philippa> most of the other stuff depends what you want us to compare it to
14:09:09 <shapr> Cosine: and if you have any Haskell questions, we're happy to help!
14:09:12 <astrolabe> I would have thought that the human-like performance of the shapr-bot would convince anyone.
14:09:22 * shapr waves the lambda pom-poms
14:09:23 <genneth> Cosine: I think the best advert is the ZFS, a filesystem with transactional semantics and undos in 540 lines of haskell
14:09:40 <shapr> astrolabe: I am not a bot! I am a human bean!
14:09:46 <Philippa> personally I think ZFS is a bit much if you're coming from C or Java. I mean, why'd I even want it?
14:09:52 <cognominal> trying to install hs-plugins... with 'sh configure', I get  sh ./configure
14:09:52 <cognominal> configure: error: cannot find install-sh or install.sh in . ./.. ./../..
14:09:52 <cognominal> what am I doing wrong? I run mandriva cooker.
14:09:52 <cognominal> do I miss some magic  invocation before 'sh configure' ?
14:10:11 * genneth gets some shapr beans and sows them into the ground
14:10:16 <humasect> is there a composable 'case of'?
14:10:33 <Philippa> in what sense?
14:10:36 <humasect> (using lists of possibles maybe?)
14:10:42 <shapr> Cosine: The most easily recognizable 'killer app' of Haskell (in my opinion), is the ease of making parsers. But Haskell has a lot of other good points.
14:10:44 <astrolabe> shapr: You have to claim that to have a chance at the Loebner prize
14:10:50 <Philippa> I guess you could write a function that takes another function to call in the default case
14:11:02 <humasect> hm true. thanks =)
14:11:37 <shapr> genneth: You will reap the boingwind! (sort of like the whirlwind, but this one bounces randomly)
14:12:00 <Philippa> springy unicycle?
14:12:05 <shapr> Sounds about right
14:12:13 <Cosine> shapr: what kind of parsers?
14:12:18 <Philippa> any kind
14:12:32 <Philippa> Parsec'll work with any token type you like, and comfortably covers anything a turing machine can parse
14:12:39 <Philippa> (Parsec being an ordinary haskell library)
14:13:20 <cognominal> don? see my installation question about hs-plugins?
14:13:34 <Philippa> it's really good at stuff more complex than plain regular expressions, in particular - parsers for toy programming languages and the like're a piece of cake
14:13:38 <Philippa> (I'm using it for a wiki)
14:13:56 <shapr> cognominal: did you run "autoreconf && ./configure && make" ?
14:14:24 <shapr> Cosine: Yeah, what Philippa said.
14:15:11 <autrijus> or even non-toy programming languages *grin*
14:15:20 <Cosine> so is haskell on the same level with c/c++
14:15:26 <Philippa> since when does perl count as that? ;-)
14:15:31 <Philippa> define "same level"
14:15:51 <Cosine> well... in terms of programming hierachy (i guess)
14:15:52 <Philippa> you /can/ do most of the low-level stuff possible in them, but you don't want to. It's capable of higher-level abstractions than C++ is
14:15:56 * genneth wonders about why importing Control.Monad.State errors out...
14:16:32 <Philippa> it's much, much higher-level than C is
14:16:41 <Cosine> ok
14:17:14 <shapr> Cosine: I think that with equivalent Haskell and C++ code, the Haskell code will be shorter, easier to debug, and slower.
14:17:14 <Philippa> garbage collection everywhere, you can pass functions about freely, there's pattern-matching...
14:18:14 <Philippa> do you know many languages other than C and C++?
14:18:20 <SamB> autrijus: well, those aren't pieces of cake, exactly
14:18:38 <ski> and a good typesystem with type inference, parametric polymorphism and type classes
14:18:41 <SamB> they might not be too hard, but they aren't pieces of cake.
14:18:57 <shapr> I heard that someone implemented Perl6 in Haskell.
14:19:12 <Philippa> shapr: smartarse ;-)
14:19:21 * shapr snickers evilly
14:19:32 <xerox> The Zippers discussion overflowed.
14:19:46 <autrijus> it can be as fast as C++ though if you are willing to write C in haskell :)
14:19:54 <shapr> Cosine: Here's an implementation of Perl6 written in Haskell - http://www.pugscode.org/
14:20:24 <genneth> autrijus: I prefer waiting for JHC to become complete
14:20:24 <cognominal> shapr: I stole an install-sh from a random place and things seems ok.
14:20:31 * genneth strokes his white cat
14:20:32 <astrolabe> xerox: You mean it can be found in #haskell-overflow?  :)
14:20:46 <xerox> astrolabe: Right on.
14:21:02 <autrijus> genneth: <aol/>
14:21:55 <genneth> now, the only question is, why the hell is Control.Monad.State giving me errors on import ?!?!
14:22:10 <Philippa> I'm very much looking forward to jhc being production quality
14:22:15 <genneth> it doesn't make any sense!
14:22:32 <genneth> not jhc, obviously, which makes a lot of sense
14:22:34 <Philippa> does it use extensions?
14:22:44 <genneth> i think so
14:22:45 <SamB> shapr: but that isn't a complete implementation of perl6!
14:22:53 <genneth> but -fglasgow-ext doesn't help
14:22:53 * SamB has commit access ;-)
14:24:22 <genneth> Philippa: it gives Unresolved top-level overloading with hugs
14:24:39 <genneth> and a crapload of thing i can't understand with ghci
14:25:03 <autrijus> genneth: nopaste the crapload of things?
14:25:07 <SamB> genneth: well, the crapload is probably more understandable...
14:25:19 <SamB> @paste
14:25:20 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:26:16 <genneth> oh wait
14:26:17 <genneth> got it!
14:26:26 <genneth> monomorphism restrictions
14:26:29 <autrijus> ugh.
14:26:53 * autrijus ponders "nomoremorphism"
14:27:45 <Philippa> I call that _|_
14:27:52 <Philippa> 'tis terminal
14:27:53 <autrijus> Philippa++ # well said
14:28:17 <SamB> do we have that in here?
14:28:18 <autrijus> "_|_ is not only advanced, it's terminal!"
14:28:23 <SamB> @karma Philippa
14:28:24 <lambdabot> Philippa has a karma of 0
14:28:51 <JohnMeacham> Philippa: me too :)
14:29:10 <autrijus> JohnMeacham: hi :)
14:29:22 <SamB> autrijus: I think you need to use a different syntax!
14:29:29 <JohnMeacham> hello.
14:29:42 <autrijus> SamB: syntax is overrated
14:29:46 <autrijus> it's the semantics that matters
14:29:58 <Philippa> wub rep farg
14:30:55 <cathper> autrijus: http://en.wikipedia.org/wiki/Brainfuck
14:32:19 <shapr> He has a terminal case of _|_
14:32:32 <autrijus> cathper: http://en.wikipedia.org/wiki/Lazy_K
14:33:02 <SamB> autrijus: well you need to use the right syntax to achieve the correct semantics!
14:33:17 <autrijus> SamB: not so!
14:33:19 <shapr> Is a stick semantics or syntax?
14:33:34 <autrijus> semantics is use; there is no meaning outside usage
14:33:38 <Itkovian> boegel.
14:33:52 <autrijus> so if I say Philippa++, and people understand that I'm praising Philippa, the semantic is established
14:34:05 <Itkovian> autrijus: you really should try brainfuck :-)
14:34:08 <autrijus> whether lambdabot gets it or not is outside my concern :)
14:34:19 <Itkovian> lol
14:34:30 <autrijus> Itkovian: I did; it's one of the first language supported by parrot vm
14:34:36 <SamB> @help karma
14:34:37 <xerox> Syntactically it's more like @karma+ <nick> here :-)
14:34:37 <lambdabot> return a person's karma value
14:35:28 <autrijus> cathper: try this quicksort in J:
14:35:29 <autrijus>   qsort =: ]`(($:@:((}.<:{.)#}.)),{.,($:@:((}.>{.)#}.)))@.(*@#)
14:35:56 <MarcWeber> Does anybody use hdirect on windows? I can't compile it.
14:36:25 <Itkovian> @karma+ autrijus
14:36:26 <lambdabot> autrijus's karma raised to 3.
14:36:55 <xerox> What is J?
14:37:07 <autrijus> xerox: http://en.wikipedia.org/wiki/J_programming_language
14:37:40 <Itkovian> autrijus: is that more readable to the average human if you spread it over multiple lines?
14:38:12 <autrijus> Itkovian: yes
14:38:14 <autrijus> sel=: adverb def 'x. # ['
14:38:14 <autrijus> quicksort=: verb define
14:38:14 <autrijus>  if. 1 >: #y. do. y.
14:38:14 <autrijus>  else.
14:38:16 <autrijus>   (quicksort y. <sel e),(y. =sel e),quicksort y. >sel e=.y.{~?#y.
14:38:19 <autrijus>  end.
14:38:21 <autrijus> )
14:38:27 <autrijus> is the more verbose form
14:38:53 <xerox> Which we all waited for.
14:39:00 <boegel|home> yo Itkovian
14:39:20 <Itkovian> thx autrijus
14:39:38 <xerox> autrijus: what is J useful for? :-)
14:39:54 <Itkovian> for brainfucking I guess
14:40:07 <autrijus> xerox: J is to APL as Joy is to Forth
14:40:10 <cathper> Itkovian: checking out the wikipedia page autrijus just posted will show you the quicksort algorithm among others.
14:40:11 <SamB> xerox: scaring people!
14:40:42 <autrijus> ...and, to a lesser degree, OCaml is to Python
14:42:34 <shapr> I like Joy.
14:42:46 <xerox> Happy happy, joy joy.
14:42:51 <JohnMeacham> shapr: hedonist.
14:43:26 <SamB> ocaml is something to python?
14:43:56 <Philippa> the sane, statically typed version
14:43:59 <Philippa> sort-of
14:44:08 <autrijus> and far more lambda friendly.
14:44:15 <shapr> JohnMeacham: I dunno, you have names, maybe you're the hedonist!
14:45:50 <cathper> oh, I didn't know that Joy was stack based. Actually I just knew it by the name and as an esoteric language.
14:47:13 <Philippa> autrijus: I said sane already
14:48:51 <tic> davve, 10:00 tomorrow?
14:50:28 <JohnMeacham> cathper: it is based on functional composition, which oddly enough, turns out to be very similar to being stack based in practice.
14:51:00 <cathper> JohnMeacham: Okay.
14:51:18 <Philippa> I remember pissing off a few people in #concatenative by saying something like "ah, the generalisation looks like monads again"
14:51:52 <Philippa> more specifically, like *pointless* monads :-)
14:52:25 <Heffalump> @pl \x -> (fst x,x)
14:52:27 <lambdabot> (,) =<< fst
14:55:47 <shapr> hiya poetix
14:56:00 <shapr> cathper: Joy is fun. It's not esoteric!
14:56:16 <poetix> Can't it be both?
14:56:28 <shapr> er, maybe
14:56:58 <autrijus> fromMaybe joy
14:57:04 <cathper> (de)light(ening)
14:57:30 <cathper> ok, I'm too tired now, good night.
14:57:53 <RemiTurk> hi all
14:57:56 <shapr> hoi
14:58:00 <kosmikus> night cathper
15:17:42 <shapr> TDD rocks my world!
15:18:08 <RemiTurk> be careful not to fall off :P
15:18:15 <xerox> What is TDD?
15:18:19 <basti_> derivative types rock.
15:18:23 <RemiTurk> test driven development, I guess..
15:18:24 <Philippa> Test Driven Development
15:18:40 <Philippa> you write the test (empirical spec, if you like), then you write the code to meet the test
15:19:18 <xerox> I'm not fond on acronyms.  I need @wtf on lambdabot.
15:19:24 <rep> @wtf TDD
15:19:27 <lambdabot> No match for "TDD".
15:19:44 <autrijus> TDD is actually Tolkien-Driven Development.
15:19:47 <autrijus> it works for me nicely
15:19:48 * shapr sniggers
15:20:02 * basti_ has a habit of giving preliminary names to variables
15:20:17 <basti_> i usually choose fictional or geographic names
15:20:45 <rep> i think i've spent most of the day compiling this damn kernel
15:20:52 <xerox> frodo = fold ...
15:20:55 <shapr> hah
15:20:56 <xerox> <grin>
15:20:56 <Philippa> autrijus: you let the elves do it all for you?
15:21:12 <basti_> abstain from drugs!
15:21:23 * xerox pets basti_
15:21:33 <autrijus> Philippa: gnomes, but yes
15:21:52 * RemiTurk wonders where all this is going..
15:22:19 <autrijus> but seriously, how good my code is is directly related to how good a tolkien poem I choose for it.
15:22:44 <RemiTurk> actually, writing the (empirical) spec first, and then writing the code to meet the spec seems almost poor mens type-theoretical extracting-programs-from-proofs
15:22:45 <autrijus> for example, Compile.hs and CodeGen.hs flows out quite well because their poems are nice.
15:22:50 <xerox> Goodnight folkiens... err, folks.
15:22:55 <RemiTurk> night
15:22:57 <autrijus> xerox: nite
15:22:58 <basti_> goonight
15:23:04 <basti_> I'm going to bed too
15:23:08 <RemiTurk> good night too then
15:23:10 <RemiTurk> and hi
15:23:47 <kosmikus> autrijus: are there any gnomes in tolkien mythology?
15:25:14 <autrijus> kosmikus: yes, they are High Elves.
15:25:24 <autrijus> but he removed it from later editions.
15:25:37 <kosmikus> ah, ok
15:25:52 <kosmikus> do you have a reference?
15:26:04 <MarcWeber> kosmikus: Have you used hdirect, yet?
15:26:12 * autrijus googleth
15:26:16 <kosmikus> MarcWeber: no
15:26:19 <autrijus> kosmikus: http://en.wikipedia.org/wiki/The_Hobbit#Alternative_version
15:26:23 <MarcWeber> ;-(
15:26:30 <autrijus> kosmikus: grep down for gnome
15:26:53 <kosmikus> autrijus: thanks
15:26:59 <autrijus> :)
15:27:07 <autrijus> <- freely admits to be a tolkien otaku
15:27:16 <kosmikus> so, does the term originate from Tolkien, then?
15:27:38 <autrijus> no, they originate from greek mythology
15:27:39 <dolmen> hi
15:27:45 <kosmikus> ok
15:27:47 <dolmen> I'm new to Haskell
15:27:54 <Korollary> welcome to #haskell
15:27:58 <autrijus> or German mythology.
15:28:11 * kosmikus has never heard of Greek mythology mentioning Gnomes
15:28:11 <autrijus> not sure which, but definitely not anything English :)
15:28:17 <kosmikus> ok
15:28:23 <autrijus> probably germanic then.
15:28:37 * kosmikus isn't good at German mythology even though from .de
15:28:54 <dolmen> How can I debug a "Non exhaustive pattern in function..."
15:28:57 <dolmen> ?
15:30:37 <Philippa> find out what it was that was passed in that there wasn't a pattern for
15:31:09 <Korollary> @paste
15:31:10 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:31:10 <Philippa> (easy way to do that'd be to add a new pattern at the bottom: foo -> error (show foo))
15:31:58 <Korollary> nice, spam on the irc paste page
15:34:07 <Korollary> there's spam at the bottom of pretty much every page
15:41:33 <ulph_> shapr: hey, we need lambdabot :)
15:41:42 <ulph_> can we borrow her for a while?
15:42:14 <shapr> Er, where?
15:42:23 * Korollary notices pimping in progress
15:42:25 <ulph_> thanks
15:42:31 <shapr> g'day Pseudonym
15:42:48 <shapr> ulph_: Ya know, if you write a plugin for lambdabot, you get admin privs too.
15:43:30 <Pseudonym> That gives you arm-up-the-backside privileges.
15:44:51 * Philippa puts on a rubber glove in preparation
15:46:40 <dolmen> Korollary, I pasted my code
15:47:09 <dolmen> Korollary, the eval function
15:51:04 <Korollary> dolmen: It doesn't compile due to the line that goes "else let output left in -"
15:51:30 <malverian[work]> My head hurts reading this Haskell tutorial.
15:51:45 <Korollary> malverian[work]: which one are you reading ?
15:51:47 <malverian[work]> (YaHT)
15:52:00 <SamB> malverian[work]: that happens sometimes
15:52:04 <malverian[work]> I've never used a functional programming language before, so everything is a bit odd ;)
15:52:14 <Korollary> malverian[work]: That is a pretty good one. Ask away if something confuses you.
15:52:27 <dolmen> Korollary, the wiki broke the line
15:52:44 <dolmen> Korollary, the code complies. I'm sure.
15:52:57 <dolmen> Korollary, the problem is at runtime
15:53:02 <Korollary> dolmen: so it's supposed to be "else let output left in - best = best_solution aim best (result, ((-), a, b):operations:[])"
15:53:12 <Korollary> ?
15:53:38 <xenox> re
15:53:39 <dolmen> Korollary, ah I see
15:53:49 <astrolabe> malverian[work]: I think it's a good sign
15:54:53 <malverian[work]> I understand the fibonacci function.. but it's just so weird. This whole lazy evaluation thing..
15:54:56 <dolmen> Korollary, just remove "output left in -"
15:55:08 <SamB> malverian[work]: this stuff can be tough to wrap your head around, and wrapping your head around stuff can naturally give you a headache...
15:56:31 <malverian[work]> SamB, Indeed.
15:57:02 <SyntaxNinja> hi autrijus
15:59:32 <autrijus> hey SyntaxNinja. we are cabalized!
15:59:45 <micket> expect a few days of headaches malverian[work] :)
15:59:52 <autrijus> SyntaxNinja: there are much pain on _stub support.
16:00:03 <autrijus> SyntaxNinja: have you tried cabal with foreign exports?
16:00:08 <autrijus> wrapper, that is
16:00:20 <malverian[work]> micket, I think it will be a good brain exercise if nothing else.
16:00:24 * SamB takes plugins/haskellSense out of the PACKAGES list so he can build all the others
16:01:06 <SamB> alternatively, stop when you start to get a headache and continue later on ;-)
16:01:34 <SamB> after looking ahead for a nice explanation of whatever is giving you a headache
16:02:10 <malverian[work]> In the longer version of the fib function there is a case statement. The syntax is a bit strange.
16:02:59 <SamB> malverian[work]: paste [some of] it?
16:03:01 <shapr> Korollary: I broke the plugin... want to fix it?
16:03:14 <dolmen> any tips for debugging a "Non-exhaustive pattern..." ("eval" function at http://www.haskell.org/hawiki/HaskellIrcPastePage)
16:03:15 <malverian[work]> I assume in a Haskell "case n of", "0 -> a" means.. if n = 0, return a
16:03:41 <humasect> oh my
16:03:42 <malverian[work]> In which case it's not so confusing, but the tutorial doesn't explain that.
16:04:14 <shapr> dolmen: Yeah, it means you're getting an input your code doesn't handle. I always put a fallthrough at the end: myfunction x = error "myfunction got" ++ (show x)"
16:04:45 <shapr> Then at least you get to see what exploded.
16:04:45 <dolmen> shapr, thx, will try that
16:05:14 <astrolabe> malverian[work]: right.
16:05:49 <SamB> malverian[work]: the tutorial is for intelligent people!
16:06:08 <malverian[work]> SamB, Was that an insult? :-P
16:06:12 <astrolabe> SamB: What about the rest of us?
16:06:23 <SamB> malverian[work]: no!
16:06:33 <SamB> astrolabe: what "us" are you talking about?
16:06:41 <malverian[work]> I also assume in the above "case n of", n -> is similar to "default:" in C.
16:06:45 <astrolabe> The unintelligent
16:06:49 <SamB> are you implying that there is an unintelligent person in #haskell?
16:06:54 <humasect> yep malverian.
16:07:04 <dolmen> shapr, my function has a quite complex type. How can I adapt your trick ?
16:07:17 <astrolabe> I'm an interloper
16:07:54 <malverian[work]> I think my biggest thing is getting over the lazy evaluation..
16:08:07 <malverian[work]> It just seems wrong :-P
16:08:08 <astrolabe> sounds right Malverian, but there is no 'fall-through' in haskell
16:08:44 <astrolabe> Yeah, it is freaky.  Have you seen the client/server example.  It does my head in.
16:09:36 <malverian[work]> astrolabe, It makes sense now that I've thought about it.. n is evaluating to n as it entered the case statement.. and obviously the case is evaluating in order, so if you have n -> at the bottoms it's the equivalent of a default:
16:11:19 <astrolabe> right.  That's how it works.
16:11:54 <astrolabe> You can do pattern matches with case too.
16:12:51 <astrolabe> I've got to go to bed.  I feel like HAL as his units are removed.
16:15:53 <SamB> hmm...
16:15:57 <SamB> Loading package gtk-0.9.9.5 ... linking ... <interactive>: /usr/local/lib/gtk2hs/HSgtk.o: unknown symbol `__stginit_ControlziMonadziReader_'
16:16:01 <SamB> ghc-6.4: unable to load package `gtk-0.9.9.5'
16:16:34 <ski> (malverian[work] : 'case' in haskell is a bit like 'switch' in C/C++/Java .. only more powerful)
16:16:59 <SamB> I imagine this is a problem with the specfile for gtk2hs?
16:17:11 <rep> anyone know if there's a way to see how many threads a process has, in linux?
16:17:18 <rep> (os threads, of course)
16:17:25 <SamB> or whatever that thing is called..
16:17:32 <shapr> SamB: I think that's because You've enabled Cairo, but I thought dcoutts had fixed that.
16:17:52 <SamB> shapr: that has nothing to do with cairo!
16:17:59 <ski> (dolmen : you need to do either 'error $ "myfunction got" ++ show x'  or 'error ("myfunction got" ++ show x)')
16:18:08 <SamB> thats the initialization code for Control.Monad.Reader!
16:18:17 <malverian[work]> GAH!
16:18:25 <malverian[work]> the original fib function doesn't even work :-P
16:18:52 <ski> malverian[work] : did you write it in a file ?  or just pasted the definition into hugs/ghci ?
16:18:59 <malverian[work]> ski, Put it in a file.
16:19:04 <malverian[work]> And then :l
16:19:28 <ski> (k .. what is the original def. then ?)
16:19:46 <malverian[work]> It's the long one. The shortened one works.
16:20:02 <Korollary> dolmen: in main, you are calling eval with a tuple (0, []), but the definition of eval only matches a tuple (a, [oneElement])
16:20:07 <malverian[work]> I'll pastebin it unless you just want me to /query it to you
16:20:51 <malverian[work]> Oh crap.. I'm reading the "Haskell for C programmers" manually.. not YaHT
16:21:09 <malverian[work]> It seemed more accessible to me since I've never used a functional programming language.
16:21:32 <shapr> If this spam flood continues, the wiki will permanently become login only.
16:21:36 <SamB> malverian[work]: well, its probably better to pretend you don't know C ;-)
16:22:18 <dolmen> Korollary, ok thx
16:22:28 <Korollary> no prob
16:22:55 <ski> malverian[work] : the one with fib and fibGen ?
16:24:26 <dolmen> Korollary, what pattern can I add ?
16:24:50 <dolmen> Korollary, best_operations and operations will always be an empty list on the first call
16:25:11 <Korollary> dolmen: you need to define what happens for eval aim (best_result, []) [] a b .
16:26:08 <dolmen> ski: what does means "$" in: error $ "myfunction got" ++ show x
16:26:13 <malverian[work]> ski, Yes.
16:26:17 <Korollary> dolmen: have you used ocaml before ? You used a lot of let..in's there.
16:26:29 <ski> dolmen : it is to avoid writing closing parens
16:26:36 <dolmen> Korollary, yes, a long time ago
16:26:44 * humasect $ <3
16:27:24 <ski> f x $ g y (h a $ b + c) $ i z   is the same as   f x (g y (h a (b + c)) (i z))
16:27:38 <Korollary> dolmen: You can combine them in haskell. "let x = 1 (newline, keep indentation) y = 2 in x + y" would work.
16:27:57 <ski> more specifically, $ is an operator defined to be the same as function application, but with low precence instead of high
16:28:06 <ski> f $ x = f x
16:28:16 <ski> is the definition of $
16:28:25 <ski> dolmen : ok ?
16:28:50 * dolmen 's brain is hot ;)
16:28:52 <ski> s/precence/precedence/
16:29:53 <dolmen> ski: "f $ x" means evaluate x before f ?
16:30:02 <dolmen> ski: "f $ x" means "evaluate x before f" ?
16:30:07 <ski> dolmen : no
16:30:23 <ski> dolmen : 'f $ x' means the same as 'f x'
16:30:46 <dolmen> ski: so what is the difference ??? :)
16:30:49 <Korollary> actually, it does. "infixr 0 $". right associative.
16:30:49 <SamB> what in the world is a GtkMenuToolButton (do I need to update libglade?)
16:30:56 <RemiTurk> good night everyone
16:31:37 <ski> (in a few advanced type system examples the compiler can't typecheck the first, so then the second must be used, but when both can be used (which is most of the time), they mean the same)
16:31:53 * dolmen has only read the "Yet Another Haskell Tutorial"
16:32:10 * dolmen has much more to learn ;)
16:32:14 <ski> Korollary : associativity and precedence have nothing to do with the operational order of evaluation
16:32:51 <ski> @eval const 42 $ 1 / 0
16:32:54 <lambdabot> 42
16:32:58 <ski> @eval 1 / 0
16:33:00 <lambdabot> Infinity
16:33:17 * SamB is surprised the glade he just installed didn't pull in the latest libglade
16:33:22 <ski> ah
16:33:30 <ski> @eval const 42 $ 1 `div` 0
16:33:31 <ski> i meant
16:33:32 <lambdabot> 42
16:33:36 <ski> @eval 1 `div` 0
16:33:38 <lambdabot> divide by zero
16:33:38 <lambdabot>  
16:33:41 <ski> :)
16:34:16 <dolmen> @eval :t const
16:34:17 <lambdabot>  parse error on input `:'
16:34:27 <dolmen> @t const
16:34:29 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
16:34:29 <lambdabot> init topic-null topic-snoc topic-tail topic-tell type pl wn
16:34:46 <ski> @type const
16:34:48 <lambdabot> forall a b. a -> b -> a
16:34:49 * dolmen want to know what is "cont"
16:34:55 <ski> const a b = a
16:34:57 <dolmen> const
16:34:59 <ski> is the definition
16:35:02 <dolmen> ok
16:35:18 <ski> it just throws away second argument (without evaluating it)
16:35:52 <dolmen> @eval const 42 1 `div` 0
16:35:55 <lambdabot> divide by zero
16:35:55 <lambdabot>  
16:36:06 <ski> @eval const 42 (1 `div` 0)
16:36:07 <dolmen> @eval const 42 1
16:36:08 <lambdabot> 42
16:36:10 <lambdabot> 42
16:36:14 <dolmen> @eval const 42 $ 1
16:36:16 <lambdabot> 42
16:37:10 <ski> malverian[work] : hm, i see no problem in that fib definition .. maybe you didn't indent the two branches of the 'case' the same when you copied & pasted it ?
16:37:30 <ski> @eval 42 + error "Ouch !"
16:37:32 <lambdabot> Ouch !
16:37:43 <ski> @type error
16:37:44 <lambdabot> forall a. [Char] -> a
16:37:53 <ski> ([Char] = String)
16:39:21 <SamB> @eval 0 * error "Ouch !"
16:39:23 <lambdabot> Ouch !
16:39:29 <SamB> @plugs 0 * error "Ouch !"
16:39:31 <lambdabot> Ouch !
16:39:45 <SamB> @plugs 0 * error "Ouch !" :: Integer
16:39:47 <lambdabot> Ouch !
16:39:52 <SamB> @plugs 0 * error "Ouch !" :: Double
16:39:54 <lambdabot> Ouch !
16:40:32 <SamB> ah, yes, new libglade much improves the toolbar ;-)
16:41:23 <SamB> hmm, this is pretty good for a nonfunctional IDE
16:41:35 <SamB> especially with a whole chunk just left out ;-)
16:41:41 <ski> ((*) is strict in it's arguments, even if the other is 0, yes)
16:42:43 <SamB> @eval head [0:error "Ouch!"]
16:42:45 <lambdabot> Ouch!
16:42:52 <SamB> @plugs head [0:error "Ouch!"]
16:42:55 <lambdabot> Ouch!
16:43:14 <SamB> @plugs head [0:1:error "Ouch!"]
16:43:16 <lambdabot> Ouch!
16:43:35 <SamB> @plugs head [0:error "Ouch!":[]]
16:43:37 <ski> @eval head (0:error "Ouch!")
16:43:38 <lambdabot> Ouch!
16:43:40 <lambdabot> 0
16:44:08 <Korollary> ski: This is weird. I put "a = const 42 $ 1 `div` 0" in a file. ghc -c -ddump-parsed shows "a = ((const 42) $ 1) `div` 0", which is a divbyzero. lol.
16:44:22 <SamB> so why does haskellSense still use ghc-api?
16:44:33 <dolmen> Korollary, I have multiple let because each one must override the definition of best for the rest of the function
16:44:46 <ski> Korollary : hmm ..
16:45:21 <ski> Korollary : does it error when run ?
16:45:32 <Korollary> ski: no, it doesn't
16:45:37 <Igloo> Korollary: It first parses with all infix ops as infixr9 and then fixes them afterwards
16:46:07 <Igloo> I'm not sure whether it printing that early would be considered a bug or deliberate
16:46:11 <ski> Korollary : mayhaps it could be that ghc parses it that way first, and fixes the operators later  (and the dumping forgot to take this into account)
16:46:20 <ski> m, ok
16:46:46 <Korollary> Igloo: What's the correct parse tree then ?
16:47:19 <ski> a = (const 42) $ (1 `div` 0)
16:47:37 <Igloo> Hmm, looking at that it seems to actually be infixl9. I probably just assumed it was the same as the default without checking
16:48:29 <ski> dolmen : hmm, it sounds and looks like you are trying to use 'let' as assignment
16:49:01 <dolmen> ski, well, kind of
16:49:12 <Korollary> I think the best's are different bests
16:49:13 <ski> (dolmen : 'let' is not assignment, it is binding .. each new 'let best = ...' introduces a new variable, shadowing the old)
16:49:24 <Dibrom> anyone here happen to use emacs haskell-mode and ecb?
16:49:34 <malverian[work]> YaHT is nice, this is much more comprehensive a tutorial :0
16:49:45 <dolmen> ski, that is what I want
16:50:17 <ski> then why are you not using the outermost 'best' binding ?
16:50:53 <ski> recall that 'let'-bindings are recursive in haskell
16:51:10 <ski> so    'let x = 1 in let x = x + 1 in x'  will loop
16:51:53 <dolmen> I will have to think to that
16:52:12 <dolmen> too late in the night for brain storming :)
16:53:00 <ski> dolmen : you can either start using different variable names for the different versions (at least two names) .. or you can possibly use a simple state monad (which captures this pattern), which will hide the passing around and "updating" of 'best' for you
16:53:29 <ski> (malverian[work] : yes)
16:54:27 <dolmen> well, I'm going to sleep now. My brain won't rest this night ;)
16:54:42 <Korollary> nite
16:54:43 <dolmen> thx ski
16:54:47 <dolmen> thx Korollary
16:55:06 <ski> (dolmen : possibly, you could also factor that huge expression into one or a few functions, and just pass new versions as arguments ..)
16:55:11 <ski> (doh)
16:55:17 <CosmicRay> http://darcs.complete.org/debian/libarchive.upstream/README
16:55:19 <CosmicRay> that is the coolest bit of code I have found yet this month ;-)
16:56:45 <Korollary> 7-zip support would make it perfect
16:56:47 <shapr> Man, I have a type error I can't quite figure out...
16:57:12 <Pseudonym> From GHC?
16:57:16 <Pseudonym> Now there's a shock. :-)
16:57:31 <Korollary> "typechecker, get out of the productive programmer's way, please"
16:58:14 <shapr> getSubPageMacro :: ([Char] -> IO (Maybe [Char])) -> [Char] -> IO (Maybe [Char])
16:58:14 <shapr> getSubPageMacro oldcode pagename
16:58:14 <shapr>     = do sps <- getSubpagenames pagename
16:58:14 <shapr>          return (subRegex subPageRegex (oldcode pagename) (concat $ intersperse " " sps))
16:58:39 <Pseudonym> @yow
16:58:40 <lambdabot> My LESLIE GORE record is BROKEN ...
16:58:46 <shapr> It's 2am and my brain is failing, and I want to get this working :-P
16:58:54 <Pseudonym> So what's the error?
16:59:00 <CosmicRay> Korollary: I looked at 7-zip.
16:59:04 <shapr> Couldn't match `Maybe [Char]' against `String'
16:59:16 <CosmicRay> kolmodin: it is interesting, but there are several problems with it.
16:59:21 <ski> sps is not a String
16:59:24 <CosmicRay> s/kolmodin/korollary'
16:59:27 <ski> it's a Maybe String
16:59:30 <CosmicRay> Korollary: for one thing, it doesn't build a library at all
16:59:33 <shapr> pagename is the input String, but I need to return a Maybe String
16:59:39 <CosmicRay> Korollary: also, its tar support is rather broken (ignores uid/gid, for one)
16:59:43 <shapr> ski: er, huh?
16:59:45 <Korollary> CosmicRay: I'd be happy with just its compressor, not its archive format.
16:59:50 <ski> hm
16:59:56 * ski is maybe talking rubbish
16:59:57 <shapr> oh is that all?
17:00:07 <CosmicRay> Korollary: I suspect that if they made it into a library, and cleaned it up, the libarchive maintainer would support it.
17:00:18 <shapr> ski: Wait, what's the fix?
17:00:26 <CosmicRay> it is rather messy windows c++ code poorly ported to unix
17:00:38 <ski> shapr : no, i misread .. what's the type of getSubpagenames, then ?
17:01:18 <shapr> ski: getSubpagenames :: [Char] -> IO [[Char]]
17:01:21 <ski> String -> IO [String] ?
17:01:22 <Korollary> CosmicRay: Arent there gzip-like 7z compressors ?
17:01:23 <ski> ok
17:01:32 <CosmicRay> yeah, 7z provides one of those.
17:02:00 <ski> (and type of   'subRegex subPageRegex' ?)
17:02:04 <Lemmih> shapr: Is the error message really that short?
17:02:41 <Korollary> CosmicRay: Automatic detection is cute.
17:02:59 <shapr> ski: String -> String -> String
17:03:14 <ski> hm
17:03:36 <shapr> Lemmih:     Couldn't match `Maybe [Char]' against `String' \n Expected type: Maybe [Char] \n Inferred type: String \n In the application `subRegex subPageRegex \n (oldcode pagename) \n (concat $ (intersperse " " sps))' \n In the first argument of `return', namely \n `(subRegex subPageRegex (oldcode pagename) (concat $ (intersperse " " sps)))'
17:03:44 <CosmicRay> Korollary: yup.  did you notice that it can also read ISO9660 files as if they were tar files?
17:03:45 <ski> you need to run 'oldcode pagename'  as a monadic action, i think .. and that gives you Maybe String
17:03:49 <CosmicRay> that really got me.
17:03:52 <CosmicRay> very slick, that.
17:03:58 <Lemmih> shapr: The error message says it all.
17:04:11 <luqui> hi there.  Can I override a prelude function?  That is, when I say "(*)", I don't want to refer to the one in Num, but the one in my class (for the current file only, of course)
17:04:23 <shapr> Lemmih: Yeah, but I can't figure out which part needs to be inside Maybe
17:05:03 <ski> 'do sps <- getSubpagenames pagename; ms <- oldcode pagename; case ms of Nothing -> ...; Just s -> return (subRegex subPageRegex s (concat $ intersperse " " sps))' ?
17:05:18 <Korollary> CosmicRay: no more mount -t loop for iso's, eh
17:05:39 <CosmicRay> Korollary: yup.
17:06:05 <CosmicRay> kolmodin: I am also going to package kientzle's bsdtar.  which is tar(1) on freebsd.  and it uses libarchive for everything.  meaning, it can extract ISOs and ZIPs.
17:06:09 <ski> (shapr : possibly you could use 'maybe' instead of the case .. and possibly you can use 'liftM' instead of having a separate line for getting s)
17:06:10 <Korollary> hah
17:06:11 <CosmicRay> I think that kicks ass.
17:06:30 <CosmicRay> hell, even iso.bz2 files ;-)
17:06:36 <ski> s/s/ms/
17:06:48 * luqui points people to his question
17:06:48 <Lemmih> shapr: 'subRexex subPageRegex (oldcode pagename) (concat $ (intersperse " " sps))' has type String, right?
17:07:20 * luqui feels like he's a toddler tugging on a pantleg 
17:07:27 <shapr> Lemmih: Yes, I think so...
17:07:28 <ski> luqui : think hugs and ghc at least have some support for using an alternate Prelude, yes
17:07:42 <luqui> I don't really want to use an alternate prelude
17:07:49 <sethk> luqui, left or right leg?
17:07:51 <luqui> I just want to redefine one function
17:07:58 <ski> shapr : oldcode pagename :: IO (Maybe String)
17:08:00 <Korollary> luqui: which function would that be
17:08:17 <luqui> sethk, I hope not the Wrong one
17:08:20 <Lemmih> shapr: Then it's not gonna change to 'IO (Maybe String)' if you apply 'return' to it.
17:08:20 <luqui> Korollary, (*)
17:08:20 <ski> shapr : IO (Maybe String)  is not the same type as  String
17:08:57 <shapr> Lemmih: Ah right!
17:09:12 <ski> luqui : hmm .. you can of course just refrain from importing (*) from Prelude
17:09:18 <shapr> ski, Lemmih: thanks!
17:09:23 <ski> luqui : import Prelude hiding ( (*) )
17:09:31 <Itkovian> night
17:09:35 <luqui> ski, thanks, I'll try that
17:09:38 <ski> night, Itkovian
17:09:53 <Lemmih> (I'm assuming that the second arg to 'subRegex' should be of type 'IO (Maybe String)'.)
17:09:58 <Itkovian> ski thx for the challenging topic
17:10:22 <ski> yw :)
17:11:02 <luqui> ski, worked like a charm, thanks :-)
17:11:29 <shapr> g'night Itkovian
17:14:50 <ski> shapr : possibly you could say ..  subRegex subPageRegex `liftM` oldcode pagename `ap` (return $ concat $ intersperse " " sps)    :)
17:15:36 <shapr> yay, my code appears to work
17:15:59 * ski refrains from eliminating 'sps <- ...' in favour of another liftM ..
17:16:15 * shapr boings cheerfully
17:17:10 <CosmicRay> hey shapr!
17:17:19 <CosmicRay> shapr: look what I found: http://people.freebsd.org/~kientzle/libarchive/
17:17:40 <shapr> CosmicRay: neat
17:17:56 * shapr boings
17:18:04 <CosmicRay> shapr: it even reads ISOs
17:18:07 <shapr> spiffy
17:18:21 <shapr> Sorry I'm distracted at the moment, I think FLM almost works...
17:18:29 <shapr> Are you going to wrap libarchive?
17:18:47 <CosmicRay> I think so.
17:18:52 <CosmicRay> I'm uploading it and bsdtar to debian now.
17:19:02 <shapr> Nifty
17:19:04 <CosmicRay> I found it because it has tar.5 which is the best description of the tar file formats out there.
17:19:09 <CosmicRay> so I'm going to finish my own haskell tar
17:19:13 <CosmicRay> and then package this.
17:19:17 <CosmicRay> for haskell.
17:19:24 <shapr> Cool, I like new code.
17:26:05 * shapr boings
17:31:33 <SyntaxNinja> home!
17:31:48 <shapr> Well, it's not very usable, but it's working.
17:37:50 * shapr gives in to sleep
17:39:45 <Pseudonym> Night.
17:55:34 <Heffalump> samb: I discovered that gunziping the patch files before making the .tar.bz2 saves another 20% or so :-)
18:01:09 <micket> about the lazyness in haskell, if i tell it to read a file in main under do, and not use it right away, will it be read anyway?
18:01:21 <Heffalump> depends what function you use
18:01:46 <Heffalump> anything that uses unsafeInterleaveIO directly or indirectly will mean it's not read until demanded
18:01:59 <micket> i just use readFile
18:01:59 <Heffalump> e.g. readFile or hGetContents (I think)
18:18:59 <ski> greeting BlurredWe
18:19:08 <ski> (s//s/)
18:19:26 <BlurredWe> Hey
18:19:46 <BlurredWe> what projects have been written in haskell?  (things I could take a look at)
18:19:53 <BlurredWe> I know there is a perl 6 interpreter...but beyond that
18:19:59 <ski> darcs, e.g.
18:20:16 <sethk> there is a list on haskell.org
18:20:39 <BlurredWe> cool, I haven't gone through the site fully
18:20:51 <ski> @where darcs
18:20:51 <lambdabot> http://darcs.net/
18:21:05 <BlurredWe> I'm having a hard time wrapping my head around haskell...I've done sequential type programming too much
18:21:17 <ski> if you are interested about possibly learning haskell, you could check out
18:21:19 <sethk> BlurredWe, imperative, not sequencial
18:21:20 <ski> @learn
18:21:21 <lambdabot> http://www.haskell.org/learning.html
18:21:29 <sethk> sequential, sorry
18:21:36 <ski> (especially Yet Another Haskell Tutorial)
18:22:06 <ski> (also "Haskell for C programmers" http://www.haskell.org/~pairwise/intro/intro.html could be interesting)
18:22:22 <BlurredWe> I've gone through about half of 'Yet Another..'
18:22:32 <ski> ok
18:22:38 <BlurredWe> and each individual concept is cool, and I can do simple math type programming
18:23:28 <BlurredWe> I just don't see how you then make the jump to more 'useful' type programs.  I guess haskell is just aimed more at a different area of problems.
18:24:27 <ski> you could have a look at darcs (it's a revision control system)
18:27:08 <dons> we have a nice text editor, a ray tracer, hmm, lots of web stuff, an operating system. all written in haskell. they seem pretty useful
18:27:24 <dons> lambdabot is written in haskell, also an irc client, ginsu.
18:27:44 <BlurredWe> I'm positive that haskell can do all these things, it's just hard to make the switch, but hey, I'm reading the 'for C programmers' doc right now, we'll see
18:28:02 <BlurredWe> another question: how similar is haskell to lisp/scheme?  (never used them)
18:28:13 <dons> similar, but statically typed.
18:28:50 <araujo> and purely functional
18:28:52 <araujo> (Hi!)
18:29:04 <dons> hehe
18:30:57 <ptolomy> High-light of my day at work: I factored a fold out of some haskell code I was working on, replaced it with a "foldl'", and saw a 6x speed-up in the code.
18:30:58 <dons> maybe we should more widely publicise the performance graphs from this years icfp contest
18:31:49 <ptolomy> dons, Where are these graphs? I didn't notice them.
18:32:22 <dons> around page 60 of the summary recently posted to the icfp contest site
18:32:32 <ptolomy> Ah. That's why I missed them.
18:32:39 <dons> it was mentioned in last weeks HWN
18:33:28 <ptolomy> Hm. Well, I have no excuse then.
18:58:40 <rep> so after much fighting/swearing i was able to implement a simple accept filter (return from accept() when 10 bytes have been received) on linux.
19:12:29 <sethk> rep, good, once you can do that you can pretty much do whatever you want
19:13:04 <rep> my goal is to implement something like freebsd's accf_http (accept filter for http requests)
19:14:08 <sethk> rep, what I meant is that once you have gotten past the point of making the connection, looking at the incoming data, etc., you've solved the mechanics
19:14:17 <rep> oh, yes
19:14:18 <sethk> rep, now you can do whatever it is that you really need to do.
19:14:24 <rep> that's why i started like this :)
19:16:11 <rep> linux' tcp stack has a lot more features than freebsd's, but it's also much harder to understand :(
19:16:24 <sethk> rep, the code is much less well organized
19:16:31 <rep> exactly
19:16:39 <litage> what causes functional languages to be significantly slower than imperative languages?
19:16:43 <sethk> evolved code vs. designed code.  :)
19:16:50 <sethk> litage, lazy functional languages
19:17:15 <sethk> I told litage to ask that here instead of another channel so you gurus out there can answer it for him.  :)
19:17:41 <sethk> litage, in lazy evaluation nothing is computed until it is needed
19:17:53 * ptolomy thinks the question, in it's presented form is a bit of the "how long has you been beating your wife?" type thing.
19:17:59 <sethk> litage, so that means any value may be available, but may also need to be computed
19:18:12 <sethk> ptolomy, possibly, but you know what he means.  :)
19:18:43 <litage> i'm interested in haskell but know little about it. i was just wondering if you guys might be able to answer a question or two
19:19:01 * ptolomy is annoyingly pedantic when it doesn't matter. :)
19:19:05 <litage> hah
19:19:26 <metaperl> litage: shoot
19:19:28 <litage> i'm interested in languages that be used server-side for building web applications
19:19:42 <sethk> litage, that's pretty much all languages.  :)
19:20:03 <litage> sethk: yes of course, but i'm more interested in the less-famous, non-standardly-used languages
19:20:51 <metaperl> litage: for Haskell, check this out: http://www.cs.chalmers.se/~d00nibro/hsp/thesis.pdf
19:21:18 <litage> you can use c or perl or whatever server-side, and they have their benefits for certain situations. i'm curious as to what benefits functional or near-functional (eg: lisp, scheme) have for server-side web apps
19:21:34 * litage reads
19:21:40 <dons> metaperl, you should add your coords: http://www.haskell.org/hawiki/HaskellUserLocations
19:21:48 <sethk> litage, that paper addresses your question
19:21:54 <metaperl> dons: ok
19:21:55 <litage> sweet  :)
19:22:08 <sethk> looks interesting, too; I haven't read that one yet.
19:22:40 <litage> sethk: it's a long read though  =P
19:23:08 <metaperl> dons: how do I get my longitude and latitude?
19:23:11 <sethk> litage, well, you get what you pay for.  But your primary question is answered in the beginning.
19:23:39 <metaperl> litage: the other major framework for Haskell is called WaSH
19:23:50 <litage> is paul graham known here? i became interested in [near-]functional languages because of some of his essays on the benefits of using lisp for server-side apps
19:24:16 <metaperl> litage: Wash URL: http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
19:24:36 <sethk> litage, this is a great channel for people who want to really understand programming.  I'll be back in a bit, the dog is demanding my attention for a bit.
19:25:02 <metaperl> litage: the people here know of him, but Haskell is not near-functional. It is 100% pure functional language
19:25:13 <litage> thanks sethk!
19:25:21 <metaperl> and has won ICFP programming contest 2 years straight
19:25:24 <litage> metaperl: yup, that's why i asked  :)
19:27:10 <dons> metaperl, ok, there's 3 ways: 1) wikipedia for your home town, 2) google maps, then click on "link to this page", and the link has your coords, 3) (supposed to be the fastest) http://www.maporama.com I think
19:27:55 <dons> the Lat-Long are in the bottom left of the maporama page
19:28:43 <dons> some other options are listed here: http://www.debian.org/devel/developers.loc
19:38:11 <cjs_> "Won?" It made first prize, but not grand prize, this year.
19:39:04 <metaperl> dons: ok added
19:42:35 <dons> cjs_, no grand prize, there was a judges prize. but Wolfgang definitely won. He was presented as the winner.
19:43:21 <dons> Haskell also came 3rd, and dominated the final rounds
19:43:34 <cjs_> Oh, really? I see. it wasn't quite clear what the first winner they listed was.
19:44:28 <dons> metaperl, I updated the images.
19:45:00 <cjs_> Ah, I see. It's explained elsewhere. It's a bit misleading, really, listing the Judges' prize winner before the "real" winners.
19:45:20 <dons> Pseudonym should add his coords too: http://www.haskell.org/hawiki/HaskellUserLocations
19:45:31 <dons> it is misleading, yes! I found it that way
19:46:26 <Korollary> me too
19:46:52 <Korollary> is the judges' prize lower than the 3rd place ?
19:47:57 <cjs_> It's the prize awarded for the "best re-use" of the first submission to make it into the second.
19:48:35 <Korollary> it appears to be in another dimension'
19:48:35 <cjs_> Financially, it falls somewhere between the 2nd and 3rd prizes.
19:48:58 <cjs_> It was won by the 2nd prize team.
19:50:45 <cjs_> I'm not sure actually how much I buy the criteria for the Judges' prize. After all, who cares how much you changed it, if overall you were more efficient at getting both tasks done? Worst case, you'd throw away your previous program and rewrite completely from scratch in the second round, but even there, if that's faster than re-using, why not? (Not that that would ever happen, of course....)
19:51:38 <Korollary> well, it appears that the initial design was done well enough to support future changes. That deserves some credit for the designers.
19:51:46 <dons> I'm sure some people rewrote their code from scratch in the 2 week interval
19:51:56 <dons> not that it helped them :)
19:52:19 <cjs_> Actually, I don't know that it does. People often waste a lot of time coding for future changes that never happen.
19:53:15 <cjs_> Since I've stopped doing that, I've been able to code faster, write less code to get the job done, and in fact accomodate change better. [Insert all the usual Extreme Programming stuff here.]
19:53:19 <dons> at the presentation an interesting point was made that haskell in particular seems to be good for re-hacking code. a lot higher percentage of haskell programs were rehacked successfully
19:53:25 <Korollary> it's a probabilistic game mostly. Sometimes it doesn't play out, but it doesn't make that a bad idea.
19:53:27 <dons> i guess this is what static typing buys you
19:54:00 <cjs_> If you're working on something you're only 90% likely to use, you should drop it for something you're 100% likely to use.
19:54:38 <dons> hmm, interesting talk: Scaling Linux to 512p and beyond on SGI Altix ia64 machines
19:54:43 <cjs_> (I'm not saying don't design for change; I'm saying don't write code you don't need right then and there. If you set things up right, you can add it later just as easily as you can add it now.)
19:54:45 * dons boggles
19:54:53 <cjs_> Yeah, that typing system is why I'm here.
19:55:14 <Korollary> cjs_: don't you think it's possible to misjudge what you may or may not need ?
19:55:26 <cjs_> That "Composable Memory Transactions" paper blew my little mind.
19:56:00 <cjs_> It's easy to judge; just ask the customer what the final product for the next release is supposed to be. (Well, not "easy," but it can be done.)
19:57:23 <cjs_> Anyway, I don't know if it's appropriate to babble on about XP here; there's lots of info on the web and in books. http://www.amazon.com/gp/product/0321278658/ will give you the idea.
19:58:07 <cjs_> But it's interesting to note that XP is one of the factors that led me here, too. The idea of constantly improving one's tools, etc.
19:58:26 <humasect> interesting text aboce, cjs
20:00:09 <cjs_> ?
20:00:10 <luqui> has anybody done compile-time units in Haskell?
20:00:41 <humasect> can you say more about how much room you leave for changes that are definate to happen? say if you were building first for test, then adding in the middle of that.
20:00:55 <humasect> or not-so-definate
20:01:07 <dons> luqui?
20:01:08 <luqui> let x = Meters 3; y = Seconds in x + y   -- error
20:01:31 <dons> oh, you mean, representing standard units of measurement in the typesystem?
20:01:36 <luqui> yeah
20:01:38 <cjs_> Well, you just add in the middle when you need it. If you need to write 150 lines of code to implement some new feature, it doesn't really matter whether you write it now or next month, if you don't need it until next month.
20:01:43 <luqui> (mostly as an exercise)
20:01:48 <dons> I have seen this done for Farenheit/Celcius, on the haskell mailing list
20:01:56 <dons> Celsius
20:02:12 * luqui will search for that
20:02:14 <cjs_> Actually, if you're interested in talking about this stuff, join #yagni, and I'll babble on about it over there.
20:02:21 <humasect> cjs: okay, yeah. this is something i need to think about
20:02:36 * humasect coffee-up
20:02:38 <cjs_> Hey, wouldn't it be neat to have syntax that let you say, "let x = 3 Meters"?
20:02:57 <sethk> cjs_, no
20:03:13 <dons> what does the syntax describe? 3 :: Meters?
20:04:14 <luqui> perhaps: Meters 3
20:04:28 <cjs_> I wonder how that would work with other stuff. One thing I do miss about Smalltalk is that method calls are so, so obvious to read.
20:04:32 <dons> ah, postfix constructors
20:04:40 <Korollary> doesn't Fortress try to introduce units in the language ?
20:04:48 <luqui> eh, whatever
20:04:52 <luqui> syntax is secondary
20:05:05 <luqui> (and to think, that came from a perl programmer :-)
20:05:09 <sethk> 3 works just fine by itself
20:05:18 <cjs_> True enough. Just a thought. And Haskell probably already has too much syntax, anyway.
20:05:36 * luqui finds that haskell has a pretty good balance of syntax
20:05:51 <luqui> without syntax, you turn into lisp.  And I, for one, can't read lisp worth a damn
20:06:12 <dons> lisp syntax is designed for compilers of the 1960s to be able to parse
20:06:19 <luqui> anyway, any idea how to approach compile-time unit-checking?
20:06:34 <cjs_> Doesn't Haskell have syntax for "if"? I've thought for a little while that that indicates a failing in a language.
20:06:48 <luqui> cjs_, there's not much reason to, though
20:06:50 <dons> it's sugar for case x of True -> .. ; False -> ... ;
20:07:00 <cjs_> Oh, is it? Cool!
20:07:10 <sethk> cjs_, if haskell has if then haskell has if else haskell doesn't have if
20:07:12 <luqui> I've found that I would like to use if as a function more often than a syntactic construct
20:07:21 <dons> it's not really *in the language*, it's part of the syntactic sugar that compiles to the underlying Core language, which is just let/case/f x/\x ->/
20:07:35 <luqui> like: if cond true false
20:07:43 <cjs_> But I am particularly fond of the way that "if" works in Smalltalk: very readably but without any extra syntactic sugar.
20:08:17 <luqui> Smalltalk is interesting in that respect, indeed
20:08:19 <dons> so if you want, just program in the Haskell Core. then there's no need for all the fancy syntax in the world. it's all case or let anyway
20:08:45 <luqui> but translate a typical Haskell program to Smalltalk and you'll probably find that it gets bigger and harder to read rather than easier
20:09:11 <luqui> (I didn't mean translate it to Smalltalk, I mean translate function calls to Smalltalk-style messages)
20:09:19 <luqui> hmm... that'd be pretty hard to do
20:09:26 <luqui> their world models are opposites
20:09:40 <cjs_> dons: but can I, in Haskell core, define new syntax?
20:09:41 <luqui> nevermind, then
20:09:49 <luqui> cjs_, you can define new infix operators...
20:09:54 <dons> cjs_, no. you'd be modifying the language definition
20:10:10 <luqui> cjs_, see perl 6 if you want to define new syntax :-)
20:10:20 <dons> you just use the usual tricks for adding infix operators and higher-order control structures, which look like syntax
20:10:36 <cjs_> Hm. Luqui, that would be a very interesting comparison.
20:10:54 <luqui> you mean Smalltalk/Haskell?
20:11:00 <cjs_> Yeah.
20:11:12 <sethk> you could argue that something that looks like syntax is rather difficult to distinguish from syntax
20:11:23 <luqui> Smalltalk being object-centric and Haskell being function-centric... woah, that would be an interesting language munge
20:11:27 <cjs_> I'll buy that argument.
20:11:27 <dons> right, so the point is moot
20:11:57 <luqui> aanyway, any idea how to go about checking units at compile time with Haskell's type system
20:11:58 <luqui> ?
20:12:10 <cjs_> Anyway, the bigger interesting point to me, in something like Smalltalk vs. Haskell, is can Haskell help me cut down on my test load in a major way? I'm suspecting it can.
20:12:15 <luqui> I did it in C++, but that used the fact that you could use integers in templates
20:12:17 <sethk> luqui, I'm really not sure what you mean by that.  Units are entirely arbitrary
20:12:50 <luqui> sethk, I mean, "Meters 3 + Meters 4" okay, "Meters 3 + Seconds 4" bad, "Meters 3 * Seconds 4" good
20:13:20 <luqui> and have the result of the latter be something like (UnitProduct Meters Seconds 12)
20:13:34 <sethk> you could calculate the unit and have that as part of the result type, I guess
20:13:34 <luqui> But the exact details are not important
20:13:41 <luqui> at compile time?
20:13:49 <sethk> I think so, yes
20:13:55 <sethk> let me think about it
20:14:32 * luqui understands that you have to ditch the standard Num class to do this, and is okay with tha
20:14:33 <luqui> that
20:15:36 <sethk> you can always treat   3 meters    as    3 * meters
20:15:38 <sethk> etc
20:15:43 <sethk> then cancel units
20:15:48 <sethk> and what remains is the type of the result
20:16:22 <sethk> 3 * meters / (2 * seconds)   = 3/2 meters/seconds
20:16:23 <sethk> etc
20:16:34 <sethk> the unit has to bind tightly to the value
20:16:45 <luqui> right, that'd be okay
20:16:57 <luqui> but uh, meters :: ???
20:17:06 <sethk> just thinking out loud
20:17:08 <luqui> okay
20:17:14 <sethk> luqui, but the point is, it's a value, not a type
20:18:28 <luqui> hmm.. it's kinda both though.  Through static analysis you should be able to determine that 3 * meters + 4 * seconds is an error
20:18:46 <luqui> (and that's the whole point of this exercise)
20:18:51 <luqui> (it's easy to implement units as a value)
20:19:15 <sethk> luqui, if the expected type of the expression is, say, meters, and you have your example, it fails
20:19:38 * luqui doesn't follow
20:19:40 <sethk> luqui, treating it as a value is the only way to handle all variations
20:20:00 <sethk> luqui, such as    100 cm * .1 cm/1 meter
20:20:02 <sethk> or whatever
20:20:17 <sethk> luqui, if you just want to handle a small subset, that's different
20:20:31 <luqui> just normalize to SI when constructing
20:20:43 <luqui> which turns into a small subset
20:20:59 <sethk> luqui, it also only accepts a small subset
20:21:07 <luqui> "accepts"?
20:21:21 <sethk> luqui, right, accepts
20:21:24 <sethk> matches
20:21:27 <sethk> finds a constructor for
20:21:31 <sethk> however you want to phrase it
20:21:36 <luqui> a small infinite subset?
20:21:40 <luqui> :-)
20:21:48 <sethk> no, a small very finite subset
20:21:51 <cjs> Is the "money" problem perhaps a more interesting way of looking at this? It has an interesting property that SI units don't: you can't normalize on construction.
20:21:54 <luqui> that is, meters * meters should be okay
20:22:10 <luqui> hmm
20:22:30 <cjs> Throw in "interest rates" and things like that, it could get more interesting.
20:22:33 <luqui> cjs, we're having a hard enough time coming up with the solution with normalization
20:22:41 <luqui> it's an interesting problem already...
20:22:47 <sethk> cjs, I'm not convinced that you can normalize SI units, but the case where you can normalize is not the interesting case
20:23:01 <luqui> sethk, how so?
20:23:01 <cjs> Ok.
20:23:23 <luqui> let cm = 0.01 * meters
20:23:31 <sethk> luqui, ok, so that handles centimeters.
20:23:35 <sethk> luqui, what does that prove?
20:23:40 <humasect>  smalltalk has 2 or 3 syntax constructs.
20:23:40 <luqui> that's normalization
20:23:56 <sethk> luqui, yes, you can normalize centimeters
20:24:01 <sethk> I never doubted that
20:24:06 <luqui> you can normalize everything in a similar way
20:24:10 <humasect> it is half way between objects and functions already.
20:24:12 <luqui> to a basis of standard units
20:24:13 <sethk> you can normalize cgs to mks
20:24:28 <sethk> but that is hardly the universe of possibly interesting values you might enter
20:24:44 <luqui> for my purposes, it is fine
20:24:59 <luqui> as long as meters * meters / kilograms returns a valid unit
20:25:13 <luqui> that's the hard part, the combinations of different bases
20:25:33 <sethk> luqui, if you are happy only handling those units.  But then you are solving a trivial problem so why bother to mechanize it?
20:25:56 <luqui> sethk, because if I solve that problem, it will show me how to generalize it
20:26:20 * dave_m notes Andrew Bromage's post on units in Haskell, http://www.haskell.org/pipermail/haskell-cafe/2003-May/004308.html
20:26:52 <luqui> not to mention, if I'm working in SI (only), it will show me when I try to add a meter and a second, which doesn't make any sense (unless i'm working in a relativistic setting :-)
20:27:26 <luqui> dave_m, thanks
20:28:37 <luqui> dave_m, that's the same way I did it in C++, except he created Peano numbers first
20:29:56 <luqui> oh wait, not quit
20:29:58 <luqui> quite
20:30:29 <luqui> using unique factorization, you can make your basis set out of primes, and have your units be integers
20:31:10 <luqui> 2 = meters; 3 = seconds; 5 = kilograms;  (10, 9) == kg * m / s^2
20:31:24 <luqui> so I guess I need to make peano numbers and do it that way
20:32:15 <dave_m> Some of the later messages in the thread may also be helpful, for example this one from Oleg: http://www.haskell.org/pipermail/haskell-cafe/2003-May/004310.html
20:33:31 <sethk> hmm, a bit more interesting perhaps than I thought, although still not really worth doing practically.
20:37:31 <luqui> of course not
20:37:42 <luqui> like I said, an exercise
20:37:46 <dons> i'm sure there
20:37:50 <dons> s a nice way with GADTs
20:37:54 <dons> ;)
20:38:18 <luqui> ooh, GADT, I hadn't thought about that
20:39:51 <luqui> oops
20:42:32 <dave_m> GADTs could be interesting.
20:49:42 <luqui> where can I learn about catamorphisms
20:50:09 <dave_m> what about them?
20:50:54 <luqui> uh, what they are and stuff
20:51:04 <luqui> WhatIsAFold looks pretty good
20:51:44 <dave_m> catamorphisms are essentially folds over various algebraic types
20:52:07 <luqui> yeah, that teeny little wiki page pretty much did it.  I can grok that
20:52:26 <luqui> neat :-)
20:53:57 <dave_m> luqui: Are you familiar with the idea behind the Rec type constructor? data Rec f = In (f (Rec f))
20:54:18 <luqui> nope
20:54:26 <luqui> is it like a fix on types?
20:54:32 <Pseudonym> @wiki IndirectRecursion
20:54:34 <lambdabot> http://www.haskell.org/hawiki/IndirectRecursion
20:54:36 <Pseudonym> That's one use for it.
20:54:41 <dave_m> Right, it's a fix on types.
20:54:55 <Pseudonym> Errr...
20:55:15 <dave_m> Rec Maybe, for example, is isomorphic to the natural numbers
20:55:20 <Pseudonym> @wiki IndirectComposite
20:55:21 <lambdabot> http://www.haskell.org/hawiki/IndirectComposite
20:55:59 <dave_m> In Nothing ~= 0, In (Just (In Nothing)) ~= 1, etc.
20:56:30 <luqui> cool
20:56:38 <dave_m> The general catamorphism has the type Functor f => (f a -> a) -> Rec f -> a
20:57:33 <dave_m> cata f (In a) = f (fmap (cata f) a)
20:57:48 <luqui> hmm
20:57:53 <Pseudonym> What about the general othermorphisms, as a matter of curiosity?
20:57:54 <luqui> probably have to stare at that for a few hours
20:58:03 <dave_m> You can make a functor LF a b = Nil | Cons a b
20:58:12 <Pseudonym> luqui, it helps if you try it for a few examples.
20:58:17 <dave_m> then, Rec (LF a) is isomorphic to [a]
20:58:24 <Pseudonym> Staring rarely helps as much as playing.
20:59:12 <luqui> Pseudonym, agreed.
20:59:27 <luqui> on the other hand, I still don't really grok fix, I just understand how to use it
20:59:37 <dave_m> I have a toy implementation of catamorphisms and their friends at http://www.eyrie.org/~zednenem/2004/hsce/Control.Recursion.html
21:00:14 <dave_m> It took me awhile to understand fix
21:00:55 <dave_m> I would see definitions like fix f = let a = f a in a and think, "How the hell is *that* supposed to work?"
21:01:17 <sethk> ok, how the hell _is_ that supposed to work?
21:01:43 <dave_m> it's equivalent to fix f = f (fix f)
21:02:08 <dave_m> the trick is that f is usually a function that takes additional arguments
21:02:22 <sethk> dave_m, ok, I see I have to read these URLs.  :)
21:02:30 <sethk> dave_m, I think I get the basic idea but not the details yet.
21:03:07 <dave_m> consider a function like fac f n = if n < 1 then 0 else n * f n
21:03:23 <sethk> ok, that's one even I understand.  :)
21:03:24 <dave_m> the first argument to fac is the "next" function to call
21:03:52 <sethk> yes
21:03:59 <sethk> on the tail call
21:04:20 <dave_m> sort of, the tail call here is actually (*)
21:04:35 <sethk> dave_m, right
21:04:54 <sethk> ok, I was thinking of the usual definition of fac ... this is a bit different
21:05:09 <dave_m> the idea is, fix fac n = fac (fix fac) n
21:05:33 <sethk> what is fac here?  I'm thinking factorial, from the name, but it isn't
21:05:44 <sethk> I get confused by reusing  names like that.  :)
21:05:56 <dave_m> fix fac is the factorial, although I wrote a 0 where there should have been a 1
21:05:56 <sethk> so why the name fac?
21:06:12 <sethk> then don't you need n -1   at the end?
21:06:24 <sethk> let's start again.  :)
21:06:29 <dave_m> yeah, that too. It's late :)
21:06:43 <dave_m> fac f n = if n < 1 then 1 else n * f (n - 1)
21:06:58 <sethk> ok
21:07:02 <sethk> no
21:07:23 <sethk> I'm confused.  fac would usually be     fac n = if n < 1 then 1 else n * fac (n-1)
21:07:24 <luqui> dave_m, can you give me an example of using cata on Rec Maybe?
21:07:55 <dave_m> luqui: hang on a sec
21:07:59 <luqui> facone f n = if n < 1 then 1 else n * f (n-1)
21:08:26 <dave_m> sethk: fix fac 1 => fac (fix fac) 1 => 1 * fix fac 0 => 1 * fac (fix fac 0) => 1 * 1
21:08:50 <dave_m> essentially
21:09:03 <sethk> dave_m, ok, let me look at that for a while
21:09:29 <dave_m> the f argument in fac is sort of like "self" in an OO language
21:10:23 <sethk> dave_m, I understand self in an OO language.  But I see no definition of f here.  Perhaps I'm not supposed to?
21:10:26 <sieni> eeeeeeeeks: http://www.cnn.com/2005/SHOWBIZ/Movies/10/10/aardman.fire/index.html
21:10:38 <dave_m> f is first argument of fac
21:11:02 <sethk> dave_m, yes, but it is used later as a function    f (n-1)
21:11:14 <sethk> dave_m, so I can't understand that code without it
21:11:39 <dave_m> when you call fix fac, the first argument to fac is fix fac
21:11:51 <dave_m> fix fac = fac (fix fac)
21:12:02 <dave_m> that's where the recursion comes from
21:12:06 <sethk> dave_m, ok, in your second example
21:12:21 <sethk> but your second example is a set of reductions, not code, isn't it?
21:12:38 <dave_m> right, I was showing how fix fac 1 gets evaluated
21:12:46 <sethk> ok, just checking.  :)
21:13:15 <dave_m> fix fac is the factorial function, fac is just the function whose fixpoint is the factorial
21:13:38 <sethk> ok
21:14:04 <dave_m> luqui: let f x = case x of { Nothing -> []; Just xs -> 1 : xs }
21:14:23 <dave_m> so f :: Maybe [Int] -> [Int]
21:14:37 <dave_m> then, cata f :: Rec Maybe -> [Int]
21:15:17 <dave_m> essentially, it creates an n-item list of ones
21:15:57 <dave_m> Or, let g x = case x of { Nothing -> 0; Just x -> x + 1 }
21:16:09 <dave_m> then cata g :: Rec Maybe -> Int
21:16:15 <litage> thanks for the information, guys!
21:16:19 <luqui> okay
21:16:22 <dave_m> cata g (In Nothing) = 0
21:16:27 <luqui> hmm, that's precisely what the sig said
21:16:37 <dave_m> cata g (In (Just (In Nothing))) = 1
21:16:40 <dave_m> and so forth
21:17:05 <luqui> okay
21:17:10 <luqui> that gives me a starting point, thanks
21:17:39 <dave_m> I didn't really understand it until I wrote it myself and fooled around for a bit
21:17:39 <sieni> cd kitchen && more coffee
21:18:29 <dave_m> it's also less obvious, because Haskell has general recursion built in, so you can get along fine without explicitly using catamorphisms and fixpoints and so forth
21:19:43 <luqui> dave_m, I don't expect to use this in day-to-day code
21:19:52 <luqui> I just want to wrap my mind out of some of this abstract stuff
21:20:06 <luqui> (actually, I don't expect to program in Haskell for day-to-day code ;-)
21:20:56 <dave_m> sadly, neither do I
21:21:02 * ptolomy programs Haskell at work.
21:21:06 <dave_m> but it is fun
21:21:14 <sethk> dave_m, but fixpoints are important in the lambda calculus literature, so it is something I need to understand better
21:21:16 * ptolomy just hides it well enough that the boss doesn't notice.
21:21:21 * Pseudonym does too
21:21:26 <Pseudonym> Though I don't hide it.
21:21:38 <Pseudonym> My Haskell code doesn't end up shipped, though.
21:22:06 * Pseudonym works on the theory that prototype code should be written in a different language so that there's no chance that it gets shipped without a rewrite
21:22:20 <ptolomy> Pseudonym, Good theory.
21:22:23 <ptolomy> Pseudonym, Also, fun one.
21:22:28 <Pseudonym> Agreed.
21:22:44 <Pseudonym> And more to the point, one that lets you concentrate on the reasons why you're prototyping.
21:22:50 * ptolomy generally prototypes his work code in Ruby until the boss makes him write a slightly less functional version in C#.
21:22:57 <sethk> ptolomy, that is an excellent point
21:22:59 <Pseudonym> If you're scrounging cycles, it's not prototype code.
21:23:01 <dave_m> sethk, fixpoints confused me for a long time, and then one day they suddenly made sense
21:23:25 <sethk> dave_m, I'm still struggling with it, although I think I'm making some progress
21:23:39 <luqui> hmm, how would I write:  "fpow 0 f = id; fpow n f = f . fpow (n-1) f" with a combinator?
21:23:50 <sethk> dave_m, it takes me longer to figure stuff out now than it used to
21:25:06 <dave_m> luqui: I think it would be, fpow = fix (\h n f -> if f < 1 then id else f . h (n - 1) f)
21:25:20 <luqui> ack
21:25:36 <luqui> is there a more specialized combinator than fix that would do it?
21:26:09 <dave_m> you could do it as a fold over natural numbers
21:26:48 <dave_m> fpow f = cata (\x -> case x of { Nothing -> id; Just g -> f . g })
21:26:51 <luqui> ahh yes, that nice notation [0..n]
21:26:57 <luqui> or that
21:27:57 <dave_m> or just fpow f n = foldr (.) id $ take n $ repeat f
21:28:14 <luqui> dave_m, that's the one I just came up with :-)
21:28:42 <Pseudonym> iterate (f.) x !! n
21:29:15 <luqui> iterate, eh?
21:29:28 <luqui> ahh, my goal is complete:
21:29:56 <luqui> intid num = cata (maybe 0 (+1)) (In $ fpow 10 (Just . In) Nothing)
21:30:02 <Pseudonym> Sorry, it's iterate f x !! n
21:30:09 <luqui> er, s/10/num/
21:32:50 <dave_m> neat, isn't it?
21:32:55 <luqui> very fun
21:33:06 * luqui resists the temptation to introduce this into Perl 6
21:34:16 <sethk> @t iterate
21:34:17 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
21:34:17 <lambdabot> init topic-null topic-snoc topic-tail topic-tell type pl wn
21:34:29 <sethk> damn, how do you ask for a type?
21:34:34 <luqui> @type iterate
21:34:48 <luqui> @hoogle iterate
21:34:58 <lambdabot> forall a. (a -> a) -> a -> [a]
21:35:01 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
21:35:28 <dave_m> there are times when I've wished ghci had hoogle
21:35:36 <sethk> hey, lambdabot just crashed my xchat  :)
21:35:48 <sethk> then when I restarted, it reconnected me to lambdabot, but not to #haskell
21:35:56 <lambdabot> Mwhahahahaha!
21:35:57 <luqui> there are times I wish I had an offline lambdabot so I could use @pl
21:36:31 <sethk> whats the difference between iterate and map?
21:36:47 <luqui> iterate (+1) 1 == [1..]
21:36:48 <lambdabot> I h4X0r3d uR m4cH33N!!!!!1!
21:36:56 <sethk> oh, I see
21:37:03 <sethk> iterate's function is a -> a
21:37:10 <sethk> map's is a -> b
21:37:21 <luqui> right
21:37:24 <sethk> hmm plus the first argument to iterate is not a list
21:37:27 <dave_m> also, iterate's result is a -> [a] and map's is [a] -> [b]
21:37:28 <sethk> but other than that   :)
21:37:33 * luqui is very impressed by the amount of information a type signature tells you
21:37:49 <Pseudonym> luqui: If you liked that, try "Theorems For Free"
21:38:04 <Pseudonym> Though don't expect to understand it on a first reading.
21:38:16 * luqui downloads it
21:40:10 <sethk> whats the ghci command that turns on the time displays?
21:40:30 <dons> luqui, how did lambdabot crash xchat?
21:40:33 <sethk> +s ?
21:40:34 <dons> too much output?
21:40:45 <dons> +s I think sethk
21:41:04 <luqui> dons, are you trying to talk to sethk?
21:41:59 <sethk> luqui, he did talk to me.  He didn't just try.  :)
21:42:16 <sethk> luqui, did you see something strange in your irc client?
21:42:37 <luqui> no
21:42:45 <sethk> luqui, then why did you ask?
21:42:48 <luqui> lambdabot returned the two lines I expected it to
21:42:53 <luqui> why did I ask what?
21:42:58 <sethk> oh, sorry, I was looking at the wrong line
21:43:01 <JohnMeacham> yay. fixed the big bad bug.
21:43:05 <sethk> luqui, dons asked about lambdabot
21:43:14 <sethk> dons, I'm the one who said lambdabot crashed xchat
21:43:26 <sethk> dons, I just did a /msg to it.
21:43:32 <luqui> oh, except for lambdabot's "I h4X0r3d uR m4cH33N!!!!!1!" thingy
21:43:33 <sethk> dons, which I've done many times before
21:43:45 <sethk> dons, so I don't know why it crashed this particular time
21:44:37 <sethk> dons, the thing I sent it was just     @type iterate
21:44:46 <sethk> dons, which I sent after I restarted three times with no problem
21:44:56 <sethk> dons, so my xchat was in some funky state, I guess
21:45:07 <sethk> dons, xchat is not referentially transparent  :)
21:45:58 <sethk> is there a way to get the current size of a lazily evaluated infinite list?
21:46:12 <sethk> well, all infinite lists are lazily evaluated.  :)
21:46:37 <dave_m> you mean, how much of it has been evaluated?
21:46:50 <sethk> yes
21:47:16 <luqui> no
21:47:31 <dave_m> in principle, yes, but I don't think any of the haskell environments support it
21:47:45 <luqui> in pure haskell, certainly not
21:47:48 <sethk> with ghci it shows sizes as well as times, so I can infer it, more or less
21:48:02 <sethk> or at least maybe infer an order
21:48:29 <luqui> oh, how do you use +s?
21:48:29 <dave_m> the browser for Alice ML will display partially-evaluated structures and leave placeholders for the values that aren't evaluated yet
21:49:07 <sethk> hmm, this is interesting.  I made an infinite list, did a !! 10000000 on it, and got a stack overflow.  I did the same thing again, and didn't get an overflow, I got a result.
21:50:25 <sieni> hmm... could one use unsafe IO to trigger some statistics keeping on the list, when something is evaluated
21:50:34 <sieni> ?
21:50:40 <sethk> repeatable, too
21:51:35 <dave_m> I've occasionally used trace from Debug.Trace to give me a sense of when thunks are being evaluated
21:52:11 <sethk> dave_m, how?
21:55:20 <dave_m> like, if I wanted to know when a particular list item was being evaluated, I could do zipWith (\n x -> trace (show n) x) [1..] myList
21:55:20 <dave_m> then, when the nth element of myList is evaluated, it will print out "n"
21:55:20 <dave_m> it's not a precise tool
22:02:24 <sethk> dave_m, no, but it doesn't have to be precise to be useful
22:02:38 <dave_m> indeed
22:02:39 <luqui> okay, what's an anamorphism?
22:02:53 <dave_m> it's a unfold
22:03:21 <dave_m> ana :: (a -> f a) -> a -> Rec f
22:03:36 <luqui> oh, makes sense
22:03:52 <luqui> how is it defined?
22:04:07 <dave_m> ana (\n -> if n < 1 then Nothing else Just (n - 1) :: Int -> Rec Maybe
22:04:47 <dave_m> ana f = In . fmap (ana f) . f
22:06:20 <luqui> I can't get Rec to "deriving Show"
22:07:05 <dave_m> yeah, that's a limitation in Haskell's class system
22:07:30 <luqui> I suppose I could define show on Rec with a catamorphism :-)
22:07:44 <dave_m> There's no way to have a context like (forall a. Show (f a))
22:07:51 <sethk> dave_m, does that mean even if I define the required methods for the class, I can't do it?
22:08:02 <luqui> ahh
22:08:43 <dave_m> You could define an  auxiliary class like class Show'1 f where show'1 :: Show a => f a -> String
22:09:01 <dave_m> and then do instance (Show a, Show'1 f) => Show (f a) where ...
22:10:17 <dave_m> or, rather, instance (Show'1 f) => Show (Rec f)
22:14:15 <luqui> cata show (In $ Just $ In $ Just $ In Nothing)
22:14:20 <luqui> "Just \"Just \\\"Nothing\\\"\""
22:14:34 <luqui> can ye think of a way to get rid of those damn quotes
22:15:14 <dave_m> maybe something with showString instead of show?
22:16:02 * luqui doesn't understand ShowS
22:19:33 <dave_m> showRM (In x) = "In " ++ maybe "Nothing" (\rm -> "(Just (" ++ showRM rm ++ "))") x
22:23:28 <luqui> ahh, here's the appropriate cata
22:23:40 <luqui> showRM = cat (maybe "Nothing" ("Just " ++))
22:23:43 <luqui> s/cat/cata/
22:24:30 <luqui> (giving me things like "Just Just Just Nothing", which is not haskell, but it's easy to read)
22:25:18 <luqui> it's great that I came up with that cata... still have yet to understand it :-)
22:27:36 <dave_m> have fun; it's time for me to sleep
22:28:05 <luqui> thanks for your help
22:28:14 <dave_m> you
22:28:16 <dave_m> 're welcome
22:51:10 <dcoutts> SamB, so you've got cairo 1.0 installed but not Gtk+ 2.8? and you're using the current darcs version of gtk2hs?
22:55:17 <ibid> i hope gtk2hs plans to add access to the GSource stuff
22:55:24 <ibid> good morning everybody :)
22:57:15 <dcoutts> ibid, what do you need from the GSource api?
22:59:18 <ibid> dcoutts: the ability to add my own event sources, obviously
23:00:46 <ibid> well, i'd even settle for prewritten binding of haskell sockets to gtk2hs main loop.  though i haven't looked too hard at if that's already available
23:01:16 <ibid> (this is not something i need soon, but i'm fairly sure i'm going to need it in a project i'm contemplating starting, if i want to do it in haskell)
23:03:54 <ibid> in general, i think driving the gtk main loop from haskell (as discussed on the site) is the way to go
23:04:14 <ibid> anything else is fairly awkward
23:05:21 <ibid> even if i were to try a multithreaded approach, which i really don't want to do, scheduling a haskell yield by that hack is yuck, and i have no way to wake the gui thread (without polling something from iside the thread) from mainGUI sleep
23:05:27 <ibid> from another thread
23:05:47 <ibid> this is something i'm having problems even now
23:06:32 <sethk> ibid, what about the pseudo-event approach using a socket?
23:06:57 <sethk> ibid, I think that's doable with gtk2hs
23:07:24 <dcoutts> ibid, we've got an irc client using gtk2hs using the thread approach.
23:07:31 <ibid> sethk: i think it falls under the "i have no way to wake the gui thread" approach
23:07:46 <ibid> dcoutts: which apparently uses the polling technique, am i right?
23:07:50 <dcoutts> yep
23:07:56 <ibid> dcoutts: yuck, as i said
23:08:04 <sethk> what about instead of using the gui thread, using the gtk methods that allow you to check for a single event and handle a single event?
23:08:28 <ibid> sethk: i think i was asking for them in gtk2hs aboce :)
23:08:41 <ibid> sethk: or are you referring to something else than GSource?
23:08:56 <ibid> *above
23:09:05 <sethk> ibid, I don't know whether they are exposed at the haskell level.  Are you saying that they aren't?
23:09:16 <sethk> I assumed they were because it is more or less a requirement
23:09:18 <ibid> sethk: i don't see them
23:09:27 <sethk> ibid, ah, they need to be, definitely
23:09:29 <ibid> sethk: there are 'add timeout' and 'add idle'
23:09:31 <dcoutts> ibid, sethk is talking about the ability to run the gtk main loop from Haskell
23:09:35 <ibid> sethk: but nothing more general
23:09:38 <sethk> dcoutts, I know
23:09:43 <sethk> dcoutts, that's necessary
23:09:53 <ibid> ah, that
23:09:56 <ibid> that's different
23:10:01 <ibid> well, that's polling
23:10:08 <sethk> ibid, it might be polling.
23:10:14 <sethk> ibid, depends on how you implement it
23:10:23 <sethk> dcoutts, what's ibid asking that is different?
23:10:32 <ibid> since gtk2hs api does not expose the fds gtk is looking at
23:10:34 <sethk> sorry, I may have missed the beginning of this
23:10:50 <dcoutts> sethk, he wants to add extra fds to the set that the main loop watches
23:11:15 <sethk> dcoutts, yes, that's also interesting
23:11:17 <ibid> *or* access to the set so that i can select/poll them from inside haskell
23:11:24 <ibid> (and add my own:)
23:11:32 <ibid> the former being more desirable, of course
23:12:00 <sethk> can't we just expose those gtk calls?
23:12:12 <ibid> sethk: i can't sleep and wait for a gtk event and some non-gtk event at the same time using gtk2hs
23:12:20 <sethk> ibid, yes, I know
23:12:23 <ibid> sethk: exposing them was what i asked for originally
23:12:28 <sethk> ibid, ah, ok.
23:12:36 <sethk> ibid, that's the part I missed I guess.  :)
23:12:49 <ibid> 08:54  <ibid> i hope gtk2hs plans to add access to the GSource stuff
23:12:53 <ibid> 08:58  <ibid> dcoutts: the ability to add my own event sources, obviously
23:12:55 <ibid> :)
23:13:09 <sethk> ibid, well, though, what I'm saying is a bit different
23:13:39 <sethk> ibid, I'm saying, instead of using the gtk event loop, use the gtk functions that allow you to check for a pending event, fetch an event, and handle an event
23:13:46 <sethk> because that way you control event priorities
23:13:56 <sethk> where if you give control to gtk you lose that control
23:14:01 <sethk> at least you potentially lose it.
23:14:11 <ibid> the standard technique in c for synchronising the gui thread and other threads is to have the other threads push a byte on a pipe that the gui thread sleeps on (as well as sleeping on gui events)
23:14:18 <sethk> ibid, right
23:14:32 <sethk> ibid, but take a look at the event handler in the ACE library
23:14:39 <sethk> ibid, which uses the other approach I'm talking about
23:14:51 <ibid> sethk: i know that's what you're suggesting, and as i said above, it isn't any more feasible
23:15:04 <sethk> ibid, not any more, nor any less.  But it is better
23:15:21 <ibid> sethk: it's not better, but it's not worse. it just adds no value
23:15:43 <sethk> it does add value.  You can control the priorities of events
23:15:52 <sethk> which is clearly valuable.  Essential in many cases
23:15:59 <ibid> sethk: the problem is that when the pending events have been handled by your mechanism, i need to sleep, and i have the same problem that i have in the other approach
23:16:14 <sethk> ibid, why do you need to sleep?
23:16:30 <sethk> although that doesn't prove that my approach does not add value
23:16:44 <sethk> because that is hardly the only criteria that might be important
23:16:46 <ibid> sethk: gtk allows you to control priorities even if you use the mainGUI approach
23:16:58 <ibid> sethk: it does not add value in my scenario. happy?
23:16:59 <sethk> ibid, only to some extent
23:17:16 <sethk> ibid, no, not really, but ok.
23:17:21 <ibid> sethk: i need to sleep because an idle loop is a bad idea
23:17:32 <sethk> ibid, because you are complaining about having to sleep but I'm giving you a way to not sleep
23:17:43 <ibid> sethk: no. I WANT TO SLEEP.
23:17:54 <sethk> ibid, ok, that's fine, you can still sleep if you like
23:17:54 <ibid> sethk: my problem is to be able to wake up when needed
23:18:07 <sethk> ibid, yes, and when you control the event dispatching, you can control that
23:18:38 <ibid> sethk: the problem is that in both mechanisms, i cannot both sleep until a gui event and until some other event
23:19:06 <ibid> sethk: no, you can't. not with gtk2hs as it currntly is
23:19:28 <ibid> (or alternatively, with gtk2hs you cannot control the even dispatching.  whatever works for you.)
23:20:15 <ski> sethk : i think with Hat you can see how much of a structure has been evaluated
23:20:19 <dcoutts> ibid, I could add a binding for g_io_add_watch_full. Would that be enough for you do you think?
23:20:32 <sethk> ski, ah, thanks.  :)
23:21:09 <ski> sethk : there is a Hat variant in hugs, also, at least, in module Observe
23:21:09 <ibid> dcoutts: well, in that case you need to add all the GIOChannel stuff
23:21:10 <dcoutts> http://developer.gnome.org/doc/API/2.0/glib/glib-IO-Channels.html#g-io-add-watch-full
23:21:37 <dcoutts> ibid, I'd not expose the GIOChannel, but just accept a FD
23:21:38 <ski> sethk : e.g. try 'take 10 $ observe "hey" [0..]'
23:22:12 <ibid> sounds major hackish, but if it works...
23:22:37 <dcoutts> well one can make a GIOChannel from an FD or a file name or, etc...
23:22:45 <ibid> i'd rather just expose the GSource stuff directly, or the full GIOChannel stuff
23:23:17 <ibid> dcoutts: sure.  i just don't trust GIOChannel, it's docs are lacking as specs, and i'd hate for it to do something nasty under the hood
23:23:25 <ibid> dcoutts: but if it works in practice, i'll live
23:23:32 <dcoutts> it's just a wrapper for an FD
23:23:58 <ibid> dcoutts: no, it's a portable interface to a certain kind of IO stuff
23:24:27 <ibid> what bothers me is that it's specified very loosely
23:25:01 <ibid> you get the feeling that it's intended to be a light wrapper over fd's in Unix, but they don't go ahead and promise that
23:25:17 <ibid> (or that the stuff behaves like unix fd's in other systems)
23:25:26 <ibid> ... but that's not a gtk2hs problem :)
23:25:59 <sethk> dcoutts, can you expose the queue and event functions?  I need that for a real-time thing I'm considering gtk2hs for
23:26:22 <dcoutts> sethk, what functions would you need?
23:26:34 <ibid> oh yeah, it's not actually a light wrapper, it adds some sort of character encoding stuff
23:26:53 <sethk> dcoutts, there is one to check whether any events are available, one to fetch the next event, and one to handle a single event
23:27:26 <dcoutts> sethk, and you need that rather than the ones for drivign the main loop bit by bit?
23:27:26 <sethk> dcoutts, or you could expose only the one to fetch an event and use an exception or a Maybe type of thing to indicate that there are no events (but without waiting)
23:27:43 <sethk> dcoutts, yes, I don't want to enter the loop at all
23:28:03 <sethk> dcoutts, because I have to handle certain events within specific periods of time
23:28:20 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-General-General.html#v%3AmainIterationDo
23:28:51 <sethk> dcoutts, ah, thanks, I didn't find them when I looked.
23:29:23 <dcoutts> sethk, tell me if that is sufficient, otherwise we can add more of that stuff.
23:29:25 <sethk> dcoutts, I should have looked there, it makes sense for it to be with the init
23:30:01 <ibid> in summary, i don't trust GIOChannel :)
23:30:22 <sethk> dcoutts, it has eventsPending
23:30:33 <sethk> dcoutts, and I see that mainIterationDo processes one event
23:30:43 <sethk> dcoutts, so that should cover it unless I run into something else
23:30:49 <dcoutts> seafood, ok
23:30:53 <dcoutts> err
23:30:55 <ibid> sethk: i actually use that stuff in JyuGraphics :9
23:30:56 <dcoutts> sethk, ok
23:31:12 <dcoutts> ibid, yes I saw
23:32:25 <ProfTeggy> Morning all.
23:32:42 <ski> morning
23:32:49 <dcoutts> ibid, however if I bind the GSource then you need to provide all the GSourceFuncs yourself
23:33:37 <dcoutts> ibid, which is what the GIOChannel provides for you. It doesn't do any char encoding stuff in this context. It just adds the fd to the set of fds polled each time round the event loop.
23:33:52 <dcoutts> ibid, you can look at the code. It's not doing anything odd.
23:35:08 <basti_> hi ProfTeggy
23:36:37 <ibid> dcoutts: looking at the code is rarely the best course of action. it does tell you what it does now, but it does not tell you what it does in a year, or in some other port
23:36:48 <ProfTeggy> Hello basti.
23:37:10 <ibid> dcoutts: about GSource, yes i know.  that would allow me to for example wrap a MVar :)
23:37:20 <ibid> dcoutts: which would be useful in some situations
23:37:43 <ibid> hmm, actually not
23:37:48 <ibid> hmm
23:37:55 <ibid> forget that :)
23:38:01 <dcoutts> :-)
23:38:15 <ibid> i mean, it would, but so would a GIOChannel :)
23:38:22 <ibid> as i said, whatever works
23:38:38 <ibid> i just don't trust it, but if it's the only thing available... :)
23:38:58 <dcoutts> I'd rather not expose the GSourceFuncs bit since it gives people too much rope to hang themselves with. The code one has to write to implement GSourceFuncs is rather tricky.
23:39:18 <ibid> ok
23:39:37 <ibid> the fd stuff allows me to implement the "send a byte down a pipe" trick :)
23:39:57 <ibid> and it allows watching sockets directly :)
