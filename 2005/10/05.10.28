00:00:47 <paolino> morning
00:01:10 <paolino> how I apply a function to its result n times ?
00:03:19 <paolino> where n is a parameter
00:03:21 <basti_> @type iterate
00:03:22 <lambdabot> forall a. (a -> a) -> a -> [a]
00:03:33 <dons> @type repeat
00:03:34 <lambdabot> forall a. a -> [a]
00:03:38 <glguy> iterate f x !! n
00:03:43 <basti_> @plugs (iterate (*2) 1) !! 10
00:03:44 <lambdabot> 1024
00:05:14 <paolino> thanks can I see the iterate implementation ?
00:05:25 <basti_> @index prelude
00:05:25 <lambdabot> bzzt
00:05:27 <basti_> argh
00:05:30 * basti_ stoopid
00:05:36 <basti_> @index iterate
00:05:37 <lambdabot> Data.List, Prelude
00:05:47 <dons> paolino, check the haskell 98 report
00:05:51 <dons> @where haskell98
00:05:51 <lambdabot> http://haskell.org/onlinereport/
00:06:09 <basti_> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html < or there
00:06:10 <dons> or else the cvs repo, haskell.org/ghc
00:06:13 <glguy> iterate f x = x' : iterate f x' where x' = fx  (my guess)
00:06:32 <dons> @where+ tourofprelude http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
00:06:32 <lambdabot> tourofprelude ~> http://www.cs.uu.nl/~afie/haskell/tourofprelude.
00:06:32 <lambdabot> html
00:06:50 <glguy> err
00:07:04 <glguy> iterate f x = x : iterate f (f x)
00:07:09 <basti_> ^^
00:07:24 <basti_> glguy: are you mezgl?
00:07:33 <glguy> basti_, no
00:07:48 <basti_> glguy: great. do you like opengl?
00:07:55 <paolino> mhh sorry I just woked up
00:08:01 <glguy> basti_, I like games written in it :)
00:08:16 <glguy> but unfortunately my nick doesn't reference OpenGL
00:08:20 <basti_> ah
00:08:36 <basti_> glguy: but still, if megzl (or mezgl or however he's spelled) shows up again, he'll be your job ^^
00:09:04 <glguy> He'll be my job?
00:09:10 <Cale> heh
00:09:25 <Cale> It's no OpenGL that Megzl likes, it's Ogre3D
00:09:28 <basti_> he was always like "haskell isn't c++, thats stupid" and "how could opengl work with that"
00:09:32 <basti_> ah ok
00:10:15 <Cale> Ogre3D is a large library for realtime 3D in C++ -- of course, a binding could be written, but it would be a lot of work.
00:10:34 <basti_> realtime 3d yes?
00:10:46 <glguy> well, I'm not this megzl tool
00:10:52 <glguy> but I'll tell him you said hi ;)
00:10:56 <basti_> heh
00:11:03 <Cale> He was arguing that it should be easier, but I think I may have finally managed to convince him that it's not as easy as having automated tools for it.
00:11:05 * pesco waves arrows around.
00:11:23 <glguy> that Haskell should be easier?
00:11:38 <Cale> that porting C++ libraries to Haskell should be easier
00:12:20 <glguy> seems to me like it'd be a b*tch to do it
00:12:35 <Cale> there are lots of things which make binding C++ libraries to Haskell difficult. If you can get around the name mangling issues with C++, then you still have the fact that the libraries were written for an OO paradigm.
00:13:04 <glguy> I imagine that the trick is lots and lots of duct tape
00:13:05 <pesco> Which makes you all EWEEY!
00:13:19 <basti_> "oh wey"?
00:13:24 <glguy> about the only way I know to attach a square peg to a round hole
00:13:37 <pesco> basti: oo-ee
00:13:54 <pesco> @yow
00:13:55 <lambdabot> Awright, which one of you hid my PENIS ENVY?
00:14:13 <Cale> most automated solutions I could see would be somewhat horrific in their results. There might be a way to do simple libraries and get something relatively usable, but it's not going to look like a Haskell library.
00:14:23 <basti_> of course not
00:14:24 <glguy> lambdabot, why do you take that conversation into #haskell-blah
00:14:39 <pesco> Good morning, #haskell. Sorry for screaming in, but I'm just in a good mood. :)
00:14:52 <aleator> Cale: c2hs is going the right way. Let people wrap things by hand, but provide strong tools for it.
00:15:18 <pesco> @vixen Yeah, lambdabot, you inappropriate goof.
00:15:20 <lambdabot> that's what i figured
00:15:21 <gour> pejo: it looks so, but it seems that ghc people are ready to work together
00:15:35 <Cale> aleator: yeah
00:15:56 <glguy> a curried function is one with a type of x -> y -> z as opposed to (x,y) -> z ... right?
00:16:04 <Cale> glguy: yeah
00:16:24 <glguy> well... not having those in C is starting to drive me crazy :)
00:16:34 <Cale> heh, uncurry is to (,) what foldr is to []
00:16:50 <basti_> lol thats what i thought too glguy ;)
00:16:50 <Cale> er, curry
00:16:56 <Cale> @type curry
00:16:57 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
00:17:11 <pesco> glguy: Just use C++! There they have FUNCTORS!
00:17:15 <Cale> no, I really did mean uncurry
00:17:18 <Cale> @type uncurry
00:17:19 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
00:17:22 <Cale> yeah
00:17:57 <glguy> and in LISP I started writing my lambdas  (lambda (x) (lambda (y) (lambda (z) (+ x y z))))
00:18:56 <glguy> makes things a little uglier when you call the function... but I can live
00:18:57 <Cale> glguy: heh, me too
00:19:21 <paolino> last one can I simplify this ?
00:19:24 <paolino> location ancestor switches = head $ foldr select [ancestor] switches where
00:19:25 <paolino>   select which list = case which `mod` 2 of
00:19:25 <paolino>     0 -> left (head list):list
00:19:25 <paolino>     1 -> right (head list):list
00:19:53 <glguy> paolino, there is an even and odd function
00:20:22 <glguy> so.... select which list | even which = ..... \n otherwise = ....
00:20:38 <Cale> (if even which then left else right) ((head list):list)
00:21:36 <paolino> it's only a case I have a left right tree anyway ... )
00:21:42 <paolino> :)
00:22:27 <Cale> hmm.. there ought to be a standard name for  msum . (map return)
00:22:42 <Cale> I think I'll call it option
00:22:43 <glguy> @index msum
00:22:44 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer,
00:22:44 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
00:22:44 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
00:22:52 <glguy> @type Control.Monad.msum
00:22:54 <lambdabot> forall a (m :: * -> *). (Control.Monad.MonadPlus m) => [m a] ->
00:22:54 <lambdabot> m a
00:22:55 <basti_> paolino: you could make "if which `mod` 2 then left else right"
00:23:06 <basti_> oh darn
00:23:11 <basti_> flakey boy
00:23:24 <Cale> basti_: can't use an Integer as a Bool
00:23:25 <glguy> Cale, so... take a list, turn them all into monads, and add them together?
00:23:33 <Cale> yeah
00:23:47 <basti_> Cale: oh yes, ignoring that of course.
00:23:50 <glguy> so for a list monad.... take  list of elements... put each element in a separate list, and then append all the separate lists together??
00:23:53 <basti_> then, using "even".
00:24:01 <Cale> basti_: I gave that with even, just above
00:24:07 * basti_ nods
00:24:19 <Cale> glguy: yeah, it's a no-op on lists
00:24:46 <glguy> for Maybe it would return the first element?
00:25:08 <Cale> glguy: yeah
00:25:37 <glguy> what context did you hope to use it in?
00:25:45 <Cale> option [] = Nothing; option (x:xs) = Just x
00:26:14 <Cale> well, it's convenient if you're using some other kind of monad which handles nondeterminism
00:26:20 <Cale> http://haskell.org/hawiki/NonDeterminism
00:26:50 <glguy> Cale, what is a Functor in haskell?
00:27:02 <glguy> transforms one monad into another?
00:27:18 <glguy> @index functor
00:27:19 <lambdabot> bzzt
00:27:23 <glguy> @index Functor
00:27:24 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.
00:27:24 <lambdabot> Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.
00:27:24 <lambdabot> Identity, Control.Monad.Cont, Control.Monad.Error, Control.
00:27:24 <lambdabot> Monad.List
00:27:37 <glguy> @type Monad.List.Functor
00:27:37 <basti_> a functor is a function on types
00:27:38 <lambdabot>   Failed to load interface for `Monad.List':
00:27:38 <lambdabot>    Could not find module `Monad.List':
00:27:43 <Cale> it's a function f on types together with a mapping which takes (a -> b) and gives (f a -> f b)
00:27:45 <basti_> it makes a type from another
00:27:59 <Cale> [] is a functor
00:28:05 <glguy> @type Control.Monad.Functor
00:28:07 <lambdabot> Not in scope: data constructor `Control.Monad.Functor'
00:28:12 <basti_> (and additionally there is a function that transforms functions from a type to the "functored" type)
00:28:15 <Cale> @type fmap
00:28:16 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f
00:28:16 <lambdabot> b
00:28:18 <basti_> monads are functors and then something more
00:28:27 <basti_> (namely, >>= and return)
00:28:32 <basti_> (fulfilling certain laws)
00:29:04 <Cale> >>= is a bit too much actually -- if you have >>= and return, you can derive fmap :)
00:29:23 <Cale> join and return is the traditional way :)
00:29:36 <glguy> @type join
00:29:37 <lambdabot> Not in scope: `join'
00:29:40 <glguy> @index join
00:29:41 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer,
00:29:41 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
00:29:41 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
00:29:42 <Cale> @type Monad.join
00:29:43 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
00:29:45 <basti_> ah
00:31:25 <glguy> Is there a simple explaination of what arrows are?
00:31:44 <glguy> They appear here in there during my reading like some mysterious pixie
00:31:51 <basti_> simple? no ^^ they are something like monads, but more general
00:31:57 <glguy> but I've never seen them used
00:32:01 <glguy> in any example
00:32:02 <basti_> every monad can be made an arrow, but not the other way around
00:32:14 <Cale> well, they're kind of like arrows in a category, but the category is of a special kind
00:32:34 <glguy> yeah, I don't know the arrows in the category you speak of
00:32:36 <basti_> "arrows in a category" here having the meaning "morphism"
00:32:40 <basti_> no?
00:32:44 <glguy> I'd be happy to read about it
00:33:03 <glguy> but I haven't heard the term arrows in category theory, and haven't heard my category theory
00:33:06 <Cale> basti_: yeah, same thing in some books :)
00:34:06 <basti_> glguy: some people use "arrow" as a synonym for "morphism". "arrow" in the haskell sense is an arrow in the CT sense, but a special one.
00:34:49 <basti_> thats a bit confusing, since in the CT sense you could call any haskell function an arrow, but you don't do that, usually.
00:35:35 <glguy> that's true, i don't
00:35:52 <Cale> (->) is an instance of Arrow
00:36:09 <basti_> yes, that makes it only worse ^^
00:36:28 <glguy> Haskell is really just one big inside joke for math people... isn't it
00:37:07 <basti_> ah no, its a clean programming language that is related to mathematics.
00:37:09 <glguy> Mathematicians were just sitting around one day telling their math jokes, and someone wrote it all down and started programming in it
00:37:12 <basti_> unlambda is a joke.
00:37:16 <Cale> heh
00:37:19 <glguy> Im teasing of course
00:37:22 <basti_> ^^
00:37:34 <Cale> glguy: the scary part is that there's some truth to that :)
00:37:36 <glguy> unlambda? I'm laughing already ;)
00:37:48 <basti_> unlambda is a functional programming language missing the lambda.
00:37:58 <basti_> it's completely pointless, erm, points-free
00:38:41 <Cale> the hardest part about learning Haskell for me wasn't making use of the abstractions so much as it was learning to talk down at the level of computable things :)
00:38:42 * liyang enjoys writing pointless code.
00:38:44 <glguy> so the whole thing looks as ugly as the stuff that lambdabot spits out for anything more than the most trivial of examples?
00:38:50 <glguy> I think it's neat
00:39:06 <glguy> but it's not a great way a lot of the time to make the code meaningful to a human..
00:39:19 <glguy> @pl f x y = g x y x
00:39:21 <lambdabot> f = flip =<< g
00:39:35 <blackdog> anyone had some experience in embedding haskell in other languages? would using C as a halfway house be the best way to proceed?
00:39:42 <glguy> I still need to work out what that means!
00:40:00 <basti_> glguy: sometimes pl comes up with strange solutions
00:40:22 <Cale> glguy: yeah, it's using =<< in the ((->) a) monad
00:40:43 <basti_> which is completely insaen.
00:40:52 <glguy> what is a cleaner way to do that?
00:41:26 <basti_> points-free i assume?
00:41:36 <glguy> yeah, other wise g x y x is pretty clean :)
00:41:43 <basti_> ^^
00:41:51 <blackdog> what's wrong with the original def? No point getting religious about it.. :)
00:42:08 <glguy> blackdog, because in some languages you don't have arguments apparently :)
00:42:21 <glguy> at least that's what I'm getting out of unlambda
00:42:26 <Cale> oh
00:42:37 <blackdog> oh, i'm with you now...
00:42:47 <Cale> with unlambda you translate not just into points-free form, but into S's and K's
00:42:57 <Cale> @get-definition s
00:42:58 <lambdabot> s not defined
00:42:59 <Cale> @get-definition S
00:43:00 <lambdabot> S = \f g x.f x (g x)
00:43:02 <Cale> @get-definition K
00:43:03 <lambdabot> K = \x y.x
00:43:25 <gour> dcoutts: ping
00:44:59 <glguy> oh, so unlambda is like brainfuck
00:45:07 <glguy> for functional language programmers
00:45:55 <Cale> yeah
00:47:00 <neologism> brainfuck is functional?
00:47:07 <neologism> I thought its just TM implementation
00:47:31 <glguy> no, unlambda is functional
00:47:41 <glguy> and seemingly a nightmare, like brainfuck
00:48:43 <neologism> I think its quite easty to write code in it
00:48:48 <neologism> but reading it is a nightmare
00:51:02 <Cale> well, it's not particularly easy, as it's a lot of typing
00:51:13 <Cale> but you could write an unlambda compiler
00:51:43 <neologism> you basically have S,K,I combinators and mess with them
00:52:12 <C-Keen> moin
00:56:10 <glguy> is there an unlambda compiler somewhere?
00:57:29 <glguy> err... interpreter
00:59:04 <cjs> @google unlambda interpreter
00:59:05 <lambdabot> http://home.nvg.org/~oerjan/unl-int/
00:59:18 <glguy> found it...
00:59:47 <cjs> One in Haskell, one in Intercal (wow!).
01:11:38 <gour> autrijus: is some material from your o'reilly's presentation available?
01:29:18 <glguy> so ... flip =<< g means  (\x -> x >>= g) .. right?
01:35:47 <integral> flip (=<<) g
01:38:11 <glguy> ap means apply?
01:38:39 <glguy> @eval [(1+)] `ap` [2]
01:38:40 <lambdabot> [3]
01:38:58 <glguy> @index if'
01:39:00 <lambdabot> bzzt
01:39:34 <basti_> @index ap
01:39:35 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer,
01:39:35 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
01:39:35 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List,
01:39:35 <lambdabot> Data.Graph.Inductive.Query.ArtPoint, Data.Graph.Inductive.Query,
01:39:35 <lambdabot> Data.Graph.Inductive
01:40:00 <dons> @type Control.Monad.ap
01:40:01 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m
01:40:01 <lambdabot> b
01:40:08 <dons> @type ($)
01:40:09 <lambdabot> forall b a. (a -> b) -> a -> b
01:40:30 <basti_> @eval ap [(+3),(+4)] [4,3]
01:40:32 <lambdabot> [7,6,8,7]
01:40:45 <vegai> dons: hey. Do you recall the INSTANCE_TYPEABLEx -macros used in hs-plugins?
01:40:57 <glguy> ap seems like a more powerful version of map
01:40:57 <dons> used in Typeable.h, yeah?
01:41:07 <glguy> ap [(1+)] [1..10]
01:41:11 <vegai> yep. Seems like the latest ghc-6.5 snapshot has changed those somewhat
01:41:13 <glguy> @eval ap [(1+)] [1..10]
01:41:13 <dons> oh, and it's not distributed with recent ghc, is it vegai?
01:41:15 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
01:41:15 <dons> yeah :/
01:41:18 <vegai> there's only INSTANCE_TYPEABLE0 defined
01:41:29 <glguy> @eval ap [(1+),(-1)] [1..10]
01:41:30 <lambdabot>  add an instance declaration for (Num (a -> a))
01:41:30 <lambdabot>   In the list element: (- 1)
01:41:34 <dons> just grab it from the src. it's in libraries/base/include/Typeable.h
01:41:38 <dons> maybe I should complain
01:41:43 <JaffaCake> mornin'
01:41:44 <vegai> yeah, I'll try that
01:41:51 <glguy> @eval ap [(1+),(flip (-) 1)] [1..10]
01:41:53 <lambdabot> [2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,5,6,7,8,9]
01:42:04 <dons> hey JaffaCake
01:42:23 <dons> vegai, you still trying to build lambdabot?
01:43:12 <dons> vegai, I think you can just put Typeable.h in lib/ghc-6.5/include/
01:43:31 <vegai> yeah. I just did that and retrying
01:43:50 <dons> it worked for me. i should follow this issue up
01:44:18 <vegai> recompiling hs-plugins right now...
01:44:35 <dons> vegai, lambdabot reallyy should be easier. if you want to mail me a list of things that went wrong, I'll chase them up for you
01:44:54 <vegai> yeah, I don't doubt that. It's the dependencies that are tricky
01:44:56 <dons> for one, you were using the wrong hs-plugins weren't you?
01:45:05 <dons> you only need hs-plugins (from darcs) and fps (from darcs)
01:45:12 <vegai> wrong hs-plugins? I'm trying with 0.9.10
01:45:15 <vegai> oh, ok.
01:45:20 <dcoutts> gour, pong
01:45:28 <vegai> but hs-plugins needs haskell-src-exts :)
01:45:32 <dons> use the one in the darcs repo, it doesn't have the hsx dep, and more bugs are fixed
01:45:38 <vegai> aaah.
01:45:40 <dons> vegai, no it doesn't :)
01:46:00 <vegai> so 0.9.10 is not recommended? It's just that I've packaged it
01:46:08 <vegai> so it would be a bit more convenient
01:46:22 <dons> well, it's ok for most, but the cabalised, non-hsx darcs versoin is better.
01:46:28 <dons> it'll be released as 0.9.12 soon
01:47:02 <dons> once i start recommending the darcs version, that usually mean it's time for a release
01:47:03 <vegai> I think I'll wait for that if this works acceptably
01:47:07 <vegai> :)
01:47:12 <dons> ok, sure.
01:47:18 <dons> darcs isn't very scary, i must say
01:47:28 <vegai> well... no, but
01:47:33 <dons> and lambdabot on #haskell (the only one that is tested) uses darcs versions of everything
01:47:39 <dcoutts> @seen marcot
01:47:40 <lambdabot> I saw marcot leaving #haskell-overflow, #haskell-blah and #
01:47:40 <lambdabot> haskell 1 day, 8 hours, 29 minutes and 5 seconds ago, and I
01:47:40 <lambdabot> have missed 6 minutes and 47 seconds since then.
01:47:48 <vegai> you're using it on Debian?
01:47:56 <dons> yep, and openbsd before that
01:47:59 <dons> @version
01:48:00 <lambdabot> lambdabot 3p120, GHC 6.5.20050806 (Linux i686)
01:48:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
01:48:29 <dcoutts> dons, did you find out if the mozembed works on openbsd?
01:50:02 <dcoutts> we couldn't make it work on freebsd since the libgtkmozembed.so was not on the library path and it had a borken -rpath so even when we did link to it sucessully, it couldn't find its dependent libs.
01:50:04 <dons> vegai, have you read the build instructions on the haskell wiki for lambdabot?
01:50:26 <dons> dcoutts, when do you plan to release?
01:51:48 <vegai> dons: nope :)
01:52:00 <vegai> in hawiki?
01:52:03 <dons> yep
01:52:10 <dons> @hawiki LambdaBot
01:52:10 <lambdabot> http://www.haskell.org/hawiki/LambdaBot
01:52:11 <vegai> www.cse.unsw.edu.au seems to be down, is it?
01:52:19 <dons> hmm
01:52:28 <dons> works for me
01:52:37 <vegai> ok... well. It's a long way here
01:53:01 <vegai> somebody just tripped on the wire in China, or something.
01:53:10 <dons> note that the wiki instructions don't mention the new FPS dep, but otherwise that's all you should need to do
01:53:16 <gour> dcoutts: i have a simple file for you regarding our db stuff discussion
01:53:27 <gour> dcoutts: can you open svg?
01:53:28 <dons> (besides some of the plugins which need extra files, like @yow or @hoogle)
01:53:29 <vegai> dons: nothing new on the hawiki page, though.
01:53:42 <dons> on the installation page?
01:53:45 <vegai> I did get it working on ghc-6.4.1, by the way
01:53:45 <vegai> yeah
01:53:51 <dons> ah, ok. cool.
01:53:57 <dons> but runplugs didn't work.
01:54:02 <vegai> I just started toying around so I could get... yes
01:54:10 <dons> ok, well things should be ok then.
01:54:31 <blackdog> hey dons
01:54:33 <dons> i just had some impression that it was really hard, but i guess you're not actually working on this full time right?
01:54:36 <dons> heya blackdog!
01:54:45 <dcoutts> gour, yes I can view svg
01:55:01 <blackdog> any tips on embedding haskell in other languages?
01:55:18 <blackdog> I want to call hs from my ruby sites...
01:55:19 <vegai> no, not really
01:55:25 <vegai> I just recompiled ghc lots of times :)
01:55:31 <dons> ah, you need the inverse FFI :)
01:55:37 <dons> so I guess ruby can call C?
01:55:43 <blackdog> yep
01:56:01 <vegai> ah, now here we go.
01:56:28 <dons> so foreign export your .hs function
01:56:36 <dons> then in C you can do: hs_init(&argc, &argv);
01:56:41 <dcoutts> dons, I plan to release soon, in the next day or two
01:56:50 <dons> my_hs_fun(); hs_exit();
01:56:56 <blackdog> ok, that sounds reasonable.
01:57:13 <dons> foreign export gives you a C header to include in the C code.
01:57:16 <blackdog> can i keep the runtime around and make multiple calls?
01:57:20 <dons> sure
01:57:30 <dons> so ruby calls the C function wihich calls into haskell
01:58:03 <dcoutts> dons, I'll probably release today or tomorrow and then make the announcement two or three days later for the benefit of people preparing packages
01:58:30 <dons> hmm, ok. i won't get a chance to test mozembed till tomorrow (12 hrs from now or so)
01:58:40 <blackdog> peachy. it's going to be interesting to see how it'll fit into a fastcgi setup, but i can worry about that later.
01:58:41 <dcoutts> dons, ok, I can wait :-)
01:59:01 <dcoutts> dons, It'd be nice for it to work since we're going to use it in hIDE
01:59:08 <dons> yep
01:59:16 <dcoutts> @seen juhp
01:59:17 <lambdabot> I saw juhp leaving #haskell 7 days, 18 hours, 52 minutes and 28
01:59:17 <lambdabot> seconds ago, and I have missed 2 days, 8 hours, 6 minutes and
01:59:17 <lambdabot> 30 seconds since then.
01:59:36 <dons> hmm, I thought I reset the @seen state.
02:03:59 <gilles> hello
02:04:34 <dons> hey gilles, welcome :)
02:04:40 <dons> learning haskell?
02:04:45 <gilles> yes
02:04:58 <dons> well, this is a good place to learn
02:05:04 <dons> have you met lambdabot?
02:05:22 <dons> @bot
02:05:23 <lambdabot> :)
02:05:25 <gilles> i've been using darcs for a while and since I had to install GHC to get it running I thought... why not learn it
02:05:35 <gilles> hi lambdabot
02:05:41 <dons> yeah, that's the attitude!
02:05:49 <dons> lambdabot is useful for playing around with haskell here
02:05:50 <dons> @type map
02:05:51 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
02:05:53 <gilles> I saw that it can eval expressions
02:05:58 <dons> @eval map (+1) [1..10]
02:05:58 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
02:06:04 <dons> right :)
02:06:13 <gilles> it's great
02:06:26 <dons> also, you might want to check out the wiki
02:06:28 <dons> @hawiki
02:06:28 <lambdabot> http://www.haskell.org/hawiki/
02:06:38 <dons> a lot of good stuff is documented there
02:07:07 <gilles> what? the wiki is python powered? a shame :-p
02:07:40 <dons> :( oh well, maybe we should switch to flippi
02:07:49 <dons> lambdabot is 100% haskell :)
02:07:52 <dons> @vesion
02:07:52 <lambdabot> lambdabot 3p120, GHC 6.5.20050806 (Linux i686)
02:07:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
02:07:53 <gilles> :-) just kidding
02:08:02 <gilles> hey that's interesting
02:08:06 <gilles> i'll get that code base
02:08:18 <ValarQ> gilles: is python so bad?
02:08:19 <vegai> dons: are you planning on making lambdabot configuration changeable without a recompile?
02:09:08 <gilles> ValarQ: not at all I was really just kidding... but it sure would be nice to advertise the use of haskell on its own website wouldn't it?
02:09:15 <dons> vegai, yes. we really should, since it's pretty simple
02:09:31 <vegai> perhaps I could try that
02:09:32 <dons> i plan to do it before we release lambdabot 4 in the next month or so
02:09:40 <dons> ah, yes, if you like
02:09:46 <vegai> what sort of config file would you like?
02:09:47 <dons> just need to dyn loadd Config.hs
02:09:55 <dons> Config.hs is pretty good
02:09:55 <vegai> oh, yeah. That would work too
02:10:14 <ValarQ> gilles: yeah, is there a haskell webserver?
02:10:37 <dons> another option would be to use a read/show mechanism
02:10:43 <vegai> but when I change Config.hs in the current setup, make wants to recompile almost everything
02:10:47 <gilles> I've seen WASH.. there's also a wiki... named flippi which is using CGI
02:11:11 <dons> vegai, yeah, cause most things use Config.hs
02:11:42 <vegai> dynload wouldn't have that problem?
02:11:42 <dons> but if you split out the defaults, and merge in any values from a dyn loaded config file (perhaps using record syntax to overwrite the defaults) that would be good
02:12:30 <dons> nope, check out the hs-plugins and yi papers for how to structure this stuff
02:12:45 <vegai> hmm
02:12:46 <vegai> [scion@chat lambdabot]$ ./lambdabot
02:12:46 <vegai> lambdabot: Ix{Int}.index: Index (3735552) out of range ((0,93))
02:12:57 <dons> hmm.
02:12:58 <vegai> this should be from the latest darcs revision
02:13:04 <vegai> I'll try a clean build
02:13:14 <dons> yeah, possibly old .hi files lying around
02:14:16 <dons> vegai, note that make -jN works with lambdabot...
02:14:20 <dons> which will speed things up
02:14:26 <dons> also, edit config.mk and use the -Onot flags instead
02:14:27 <vegai> on a uniprocessor too?
02:14:34 <dons> -j2 is a bit faster, yeah
02:14:56 <dons> using -Onot is a big win
02:15:03 <dons> but just for testing, of course
02:15:06 <vegai> yeah, ok
02:15:25 <dons> also, you can load llambdabot in ghci too, to test things
02:15:36 <dons> particularly good for testing new plugins
02:19:10 <earthy> whoa
02:19:12 <earthy> okay
02:19:20 <earthy> that was slightly unexpected
02:19:52 <earthy> the bugfix we wrote yesterday for Data.IntSet.split (and ..splitMember) is going to be applied already
02:20:26 <dons> :)
02:21:18 <bringert> dons: I might have missed some context here, but does ghc work with parallel make?
02:21:44 <bringert> I was googling around trying to find that out this morning
02:21:54 <dons> does ghc itself build with paralell make?
02:22:09 <dons> is that what you ask?
02:22:22 <dons> or can you build haskell programs with ghc, with make -jN ?
02:22:28 <bringert> rather the latter
02:22:36 <dons> you can indeed.
02:22:43 <dons> use ghc -M to generate the deps
02:22:51 <bringert> I seem to recall there being som problem with it, but I could find anything about it
02:22:53 <dons> then let make -jN go nuts
02:23:00 <bringert> s/could/couldn't/
02:23:02 <bringert> ok, cool
02:23:13 <bringert> we should buy a dual-core amd64 then
02:23:30 <pesco> The lambdabot logo is so purty!
02:23:47 <dons> in fact, using the pvm-gmake you can bulid ghc stuff across a clluster
02:23:53 <dons> i've built yi -j20
02:23:57 <bringert> hmm, interesting
02:24:03 <dons> which took around 4s versus 60s :)
02:24:13 * pesco begins to drool.
02:24:20 <pesco> dons: How large was the cluster?
02:24:24 <bringert> I'm working with GF, a 45 KLOC Haskell program
02:24:32 <bringert> it takes 5-7 minutes to compile
02:24:46 <bringert> around 250 modules
02:24:54 <dons> 20 nodes
02:25:12 <pesco> bringert: What does GF stand for?
02:25:25 <pesco> Grand Fubar?
02:25:48 <eivuokko> Grammatical Framework, or not?
02:26:03 <dons> GirlFriend, a la @vixen :)
02:26:18 <pesco> Heheheh.
02:26:38 <eivuokko> Doesn't seem as complex as far as girlfriend's go.
02:27:03 <dons> 45k haskell can do a lot though ;)
02:27:50 <vegai> hmm, how much larger would a static build be
02:27:58 <vegai> ... static build of lambdabot
02:28:08 <pesco> ...not girlfriend
02:28:34 <bringert> pesco: yeah, Grammatical Framework
02:28:34 <vegai> uhh, hmm
02:28:41 <pesco> bringert: I see.
02:28:41 <vegai> @vixen Are you static?
02:28:42 <lambdabot> yes, i am
02:28:46 <bringert> http://www.cs.chalmers.se/~aarne/GF/
02:28:58 <bringert> @vixen what are you?
02:28:59 <lambdabot> yes, i am
02:29:03 <bringert> hmm
02:29:09 <vegai> Aye. Same weird Ix error
02:29:10 <pesco> @vixen I like girls statically-built.
02:29:11 <lambdabot> a lot of people like that
02:29:19 <vegai> [scion@chat lambdabot]$ ./lambdabot
02:29:19 <vegai> lambdabot: Ix{Int}.index: Index (3735552) out of range ((0,93))
02:29:43 <pesco> Wraparound?
02:30:12 <vegai> indeed
02:30:46 <vegai> Naah
02:30:51 <pesco> @vixen Yeah, they're much easier to handle. No breakdowns when you update your modules.
02:30:52 <lambdabot> i didn't think so
02:31:03 <dons> vegai, what ghc version?
02:31:17 <vegai> 20051020
02:31:44 <dons> hmm. on linux?
02:31:47 <vegai> Yep.
02:32:17 <dons> i just built lambdabot on linux with that compiler  :/
02:32:23 <pesco> @vixen Really? You think static makes too large footprints?
02:32:24 <lambdabot> really!
02:32:38 <vegai> hmm, was fps updated recently?
02:32:47 <vegai> should that even matter...
02:32:53 <dons> or possibly it's an hs-plugins .hi file reading bug
02:33:08 <dons> when .hi files change, usually hs-plugins only reports mysterious Ix errors
02:33:21 <dons> vegai, why not build it statically? so the plugins are linked at build time.
02:33:27 <dons> make clean ; make way=static
02:33:34 <vegai> I'm actually doing that now
02:33:37 <dons> then there's no hs-plugins dep
02:34:17 <dons> dinner time now, vegai, mail me any results or probelms you hit, as I want to fix this stuff right now. dons@cse.unsw.edu.au
02:34:29 <pesco> @vixen See? There you have it, sometimes the size is not so important as the inner stability!
02:34:30 <lambdabot> i'm important to some people at least
02:34:39 <vegai> dons: ok.
02:34:46 <pesco> @vixen Yeah, the superficial types, probably.
02:34:47 <lambdabot> i guessed that
02:34:56 <pesco> @vixen As long as you're OK with it, hey.
02:34:57 <lambdabot> just ok?
02:35:09 <pesco> @vixen What do I know!
02:35:10 <lambdabot> i thought you knew
02:35:38 * pesco pffft's and gets back to work.
02:38:45 <bringert> @vixen you seem to just look for keywords and use canned responses
02:38:47 <lambdabot> i'll hafta plead the fifth on that one.
02:39:08 <bringert> @vixen so you are american?
02:39:09 <lambdabot> i think you know the answer to that one, silly
02:39:22 <bringert> @vixen so you are not american?
02:39:24 <lambdabot> why don't you guess?
02:39:34 <bringert> @vixen why dont you tell me?
02:39:35 <lambdabot> because i don't see the need to
02:39:50 <bringert> it's pretty good
02:39:51 <vegai> hm, same error
02:40:02 <jyp> yeah she's a real bitch ;P
02:40:05 <bringert> is there a description / source code for vixen anywhere?
02:40:45 <vegai> bringert: lambdabot's repo, Plugins/Vixen.hs
02:40:54 <vegai> @source
02:40:54 <lambdabot> lambdabot 3p120, GHC 6.5.20050806 (Linux i686)
02:40:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
02:43:43 <bringert> hehe, regular expressions and a list of alternative responses
02:44:18 <bringert> hmm, would be nice to have slots in the reponses that could take values matched by the regexp
02:45:11 <bringert> @vixen where do you go to school? I'm guessing you can't spell sophomore
02:45:12 <lambdabot> Huntington Beach
02:46:16 <bringert> @vixen where do you go to school? I'm guessing you can't spell sophomore
02:46:17 <lambdabot> Huntington Beach
02:46:50 <bringert> haha, it matches "(^| )where.*in.*(ca|cal|california|cali).*"
02:47:28 <bringert> @vixen can you spell sophomore? you're in college, right?
02:47:29 <lambdabot> i sure can
02:47:40 <bringert> gahh, too many regexps
02:48:02 <dons> vegai, hmm. since you're on linux, you can just download the nightly snapshots. maybe you should just use ghc 6.5.20050806
02:48:03 <bringert> @vixen how about Visual Basic?
02:48:04 <lambdabot> Can you really catch syphilis from Visual Basic?
02:48:33 <bringert> someone spent a lot of time writing that list
02:48:44 <vegai> dons: yeah..
02:48:49 <dons> oh, vegai, hmm. now that you have a working runplugs you can just use ghc 6.4.1
02:49:04 <dons> runplugs just needs to work, doooesn't matter if it isn't built with the same ghc as lambdabot itself
02:49:08 <vegai> oh.
02:49:15 <dons> so check if echo "1 + 2" | ./runplugs works
02:49:17 * shapr yawns
02:49:33 * dblhelix greets shapr
02:49:42 <vegai> I'm not sure that make way=static works, by the way
02:49:52 <vegai> but I'll test around a bit first
02:49:59 <shapr> hiya dblhelix
02:50:09 <dons> yeah, it does. been playign with it today. i have no idea at the moment what is wrong with your setup :/
02:50:11 <vegai> by not working, I mean that it seemed to try to pull in the plugins still
02:50:15 <vegai> oh, ok.
02:50:23 <dons> vegai, ah! you need to make distclean
02:50:32 <dons> the Modules.hs wasn't being regenerated
02:50:36 <vegai> ah. Right
02:51:03 <dons> just adding make way=static, without cleaning completely, will break lambdabot, yes
02:55:00 <vegai> still, make way=static doesn't seem to do it. make static=yes, however, does
02:55:21 <vegai> I don't know yet if it still does the right thing, but at least something happens :)
02:55:24 <dons> ah, that's it :)
02:55:49 <dons> config.mk:ifneq "$(static)" "yes"
02:56:09 <dons> if you set way=p you get static=yes for free, i was misremembering
02:56:12 <vegai> yeah, that's what I looked at too
02:56:28 <vegai> ok
02:57:16 <dons> i'm just about to checkout all the stuff and test on linux.
02:57:34 <dons> which hs-plugins are you using?
02:57:59 <dons> the Ix error could certainly be caused by using an old hs-plugins
02:58:13 <vegai> yeah, it was 0.9.10
02:58:20 <dons> ah, ok. there you go.
02:58:34 <dons> the .hi format changed with 6.5, but only hs-plugins in darcs has the patch
02:58:47 <dons> so when we read the .hi file the .hi parser fails, but it's a nasty error :)
02:59:06 <dons> so: darcs hs-plugins, darcs fps, darcs lambdabot, ghc 6.5 == goodness
02:59:17 <dons> since I maintain the first 3, it's not so risky :)
02:59:31 <vegai> heh
03:02:18 <vegai> Modules.o: In function `Modules_k_info':
03:02:18 <vegai> ghc16372_0.hc:(.text+0xced): undefined reference to `PluginsziDynamic_theModule_closure'
03:02:21 <vegai> Modules.o:(.rodata+0x108): undefined reference to `PluginsziDynamic_theModule_closure'
03:02:29 <araujo> Good morning!
03:02:35 <vegai> at the linking phase, doing static build
03:02:38 <dons> that's caused by the Modules.hs not being updated
03:02:57 <dons> Dynamic should not be mentioned in Modules.hs
03:03:04 <neologism> math is hard ;(
03:03:06 <vegai> hmm, I *think* I did this one from a clean slate
03:03:13 <dons> make distclean?
03:03:16 <dons> or make clean
03:03:37 <vegai> rm -rf, actually :P
03:03:52 <vegai> perhaps I'll just get hs-plugins from darcs
03:03:56 <dons> hmm. not sure what that would do, not supported ;)
03:04:01 <dons> you *need* hs-plugins from darcs anyway
03:04:08 <dons> unless you do some 6.4.1 trick
03:04:37 <dons> as the build instructions say: get the darcs versions of everything :)
03:09:56 <shapr> @seen genneth
03:09:57 <lambdabot> Last time I saw genneth was when I left #haskell and #haskell-
03:09:57 <lambdabot> blah 1 day, 4 hours, 44 minutes and 21 seconds ago, and I have
03:09:57 <lambdabot> missed 18 hours, 34 minutes and 5 seconds since then.
03:10:52 <shapr> Too bad, I was going to tell him about Thomas Sutton's blog.
03:12:13 <shapr> This is neat - http://www2-data.informatik.unibw-muenchen.de/relmics/tools/RATH/ - Relation Algebra Tools in Haskell
03:12:19 <dons> hello examplebot
03:12:24 <dons> examplebot, @version
03:12:25 <examplebot> lambdabot 3p125, GHC 6.5.20050806 (Linux i686)
03:12:25 <examplebot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
03:12:27 <shapr> examplebot: @yow !
03:12:28 <examplebot> Couldn't find fortune file
03:12:30 <shapr> aww
03:12:33 <dons> examplebot: @quit
03:13:05 <dons> vegai, ok, I just bult that from the ground up, on linux :) with ghc-6.5.20050806 and darcs everything else
03:13:14 <dons> i'll put the build instructoins on the wiki
03:14:14 <vegai> gah, now I get weird cabal errors
03:14:19 <vegai> Ok. Back to 20050806
03:14:27 <dons> you probably need Cabal 1.13
03:14:38 <dons> or, what do you mean 'weird Cabal errors'?
03:15:16 <dons> no, i'm just using whatever Cabal comes with 20050806
03:15:39 <dons> perhaps something has happened since then, i'll investigate. but for stability go back to 08/06 :)
03:16:33 <vegai> yeah
03:20:29 <dcoutts_> dons, Lemmih, do you know of a stable ghc 6.5 snapshot I should be using for hIDE development?
03:21:31 <dons> I'mm using Aug 06, august seems to be pretty good
03:21:37 <dcoutts_> ok
03:21:52 <dons> check the nightly build reports for the ghc you're interested in, according to the cvs-ghc@ mailing list
03:22:49 <dcoutts_> right
03:22:55 <beelsebob_> can anyone here suggest some 200-1000 line programs I can yoink to test my debuggerer on?
03:23:31 <beelsebob_> best ones should be easily understood and well documented -- but if you can explain what things should do, I'll be happy
03:23:39 <beelsebob_> I'd rather not have monadic code for the moment
03:23:39 <dons> debuggerer? i'm not sure *whatt* kind of program you're looking for, but @vixen might be close ;)
03:23:49 <beelsebob_> lol
03:24:00 <beelsebob_> @vixen
03:24:12 <dons> @vixen do you like beelsebob?
03:24:13 <bringert> @vixen be polite!
03:24:19 <dcoutts_> beelsebob_, hmm, I've got one but it has quite a bit of supporting infrastructure which make it a bit akward to set up
03:24:23 * adept . o O ("you can bugger the code ..." /Pratchet)
03:24:24 <dons> @bot
03:25:03 <beelsebob_> dcoutts: can I give it a try?
03:26:06 <dons> vegai, my exact build steps: http://www.haskell.org/hawiki/LambdaBot_2fInstallation
03:26:28 <dons> i'd be interested to know if following those steps produces a working lambdabot..
03:28:08 <beelsebob_> dcoutts: it isn't lambdabot is it?
03:28:32 <blackdog_> bringert: the regexes are all from the original VB script, except the slur on VB. I added that :)
03:29:16 <dons> I think there should be more slurs
03:29:27 <dons> at least on php and java
03:29:38 <blackdog_> well, there's a well defined input language.
03:29:43 <dons> and something about type hackers being hot
03:29:44 <bringert> hmm, what about a vixen bot where the regexps are in a wiki
03:29:58 <dons> or can be added with @vixen-input foo
03:30:03 <dons> that's doable..
03:30:06 <bringert> yeah, good idea
03:30:17 <bringert> or even som magic stuff you can tell her
03:30:26 <dons> we'd quickly get a very slutty, mean vixen that way  I think
03:30:27 <JohnMeacham> yay! hello. I had my beers to offest the typing.
03:30:59 <dons> @todo-add online method to append to vixen's regexes
03:30:59 <lambdabot> Entry added to the todo list
03:32:04 <blackdog_> th way it's set up at teh moment, there's a hierarchy of probabilities - theres a tree of (Regex,[Tree]).
03:32:06 <dcoutts_> beelsebob_, it's the code generator from gtk2hs
03:32:21 <shapr> JohnMeacham: Does beer help you GRIN?
03:32:26 <blackdog_> or something similar. gah. incoherent tonight.
03:32:49 <bringert> looking through the vixen responses: "there is nothing going on in your pants that the dictatorship of the proletariat will not solve"
03:32:50 <dcoutts_> beelsebob_, it reads various xml files and produces .chs files
03:33:01 <shapr> blackdog_: Hey, you should write more into your blog. And could you change the link to mine to point to http://www.scannedinavian.com/?
03:33:04 <beelsebob_> ah, okay... so does it need much else of gtk2hs hanging about?
03:33:09 <dcoutts_> beelsebob_, but it needs the gtk+ source code
03:33:19 <dcoutts_> beelsebob_, it's in the gtk2hs darcs repo
03:33:23 <beelsebob_> okay... I'll get that... some time soon
03:33:26 <beelsebob_> cool, thanks :)
03:33:42 <dcoutts_> it has a mekfile which (should) download all the gtk etc tar files
03:33:57 <dcoutts_> mekfile/Makefile :-)
03:34:49 <beelsebob_> buggery... fire
03:34:49 <dcoutts_> it's a slightly hairy program, in need of being split into layers, so it might make a good debugging candidate :-)
03:35:13 <dcoutts_> well it's already in layers, but it needs more of them
03:37:58 <beelsebob_> ah good... not any more
03:40:44 * shapr boings cheerfully
03:43:04 <JohnMeacham> it does. it does.
03:46:43 <neologism> what is .lhs ?
03:46:57 <JohnMeacham> literate haskell.
03:46:58 <neologism> looks like latx-haskell
03:46:58 <bringert> literate haskell
03:47:04 <neologism> what is literate haskell?
03:47:28 <dcoutts_> the opposite of iliterate haskell
03:47:30 <psi> comments are default, code is prefixed with >
03:47:50 <jyp> What shakespeare would write if he lived
03:47:58 <jyp> still
03:48:09 <neologism> wow
03:48:17 <bringert> which is not really literate programming
03:48:19 <dcoutts_> literate haskell is good for student writups because they can have their report and their code all in one file
03:48:38 <bringert> but you still have to structure the code they way the compiler likes it
03:48:48 <dcoutts_> and the code still works (unlike if you paste it into a wordprocessor) in hugs/ghci
03:49:04 <bringert> so you can't introduce functions peice-by-piece, intermignled with other functions
03:49:18 <bringert> or am I wwrong? I've never actually tried
03:49:25 <dcoutts_> it's good for reports/emails etc where it's mostly description with snippets of code inbetween
03:49:35 <jyp> haskell is already flexible enough in re-ordering
03:49:45 <neologism> I am jsut looking darcs sources
03:49:58 <dcoutts_> bringert, it doesn't change the haskell language at all
03:50:07 <neologism> I wonder where is Main function
03:50:12 <dcoutts_> it's a simple pre-processor to convert .lhs -> .hs
03:50:27 <bringert> jyp: I don't think so, you can't mix definitions of different functions
03:51:13 <bringert> dcoutts_: right, that's why I'm saying it's not as flexible as you might want when describing the code to a human
03:51:26 <jyp> haskell is already flexible enough, is my personal opinion
03:51:44 <neologism> vim does really bad job with syntax highlighting of lhaskell
03:51:45 <shapr> I rarely succeed in describing Haskell to those who do not already know it.
03:51:48 <bringert> you might want to describe a simple version of the program, then add some new constructs in a later section, which adds new cases to a some functions
03:51:52 <jyp> ie. I think intermixing code of various function doesn't help presentation
03:52:10 <shapr> bringert: Generic Haskell can do this?
03:52:11 <jyp> ok
03:52:21 <shapr> I think it can.
03:52:29 <bringert> how does that work?
03:52:47 <shapr> It lets you extend datatypes, among other things.
03:53:06 <shapr> I forget the details, but it's kosmikus' thesis.
03:53:16 <bringert> right, but can you extend existing functions which new cases?
03:53:18 <dblhelix> extend data types?
03:53:53 <shapr> I don't remember exactly, I think so.
03:53:58 <bringert> I was thinking of a more syntactic thing
03:54:46 <shapr> dblhelix: data Meta = Foo | Bar and then later you could add | Quux
03:55:26 <dblhelix> shapr: but that's really not a GH thing; it's something kosmikus is working on, though
03:55:34 <shapr> Anyway, I have to get back to writing Python :-P
03:55:35 <dblhelix> iirc
03:55:43 <shapr> Oh, I thought it was specifically GH.
03:56:03 <dblhelix> maybe I'm wrong...
03:56:10 <shapr> Or maybe I'm wrong
03:56:18 <dblhelix> one of us is, for sure
03:56:26 <shapr> It's been awhile since I read kosmikus' thesis, and most of it was over my head at the time.
03:56:42 <dblhelix> it's not in his thesis
03:57:00 <dblhelix> (which I have in front of me, right now ;))
03:57:02 <shapr> Ok, I give up. Where's it from?
03:57:03 <bringert> It'd be nice if you could do something like this:
03:57:05 <bringert> First we introduce a simple base language:
03:57:05 <bringert> > data Foo = Foo | Bar
03:57:05 <bringert> We can easily convert terms to strings:
03:57:05 <bringert> > f :: Foo -> String
03:57:05 <bringert> > f Foo = "foo"
03:57:06 <bringert> > f Bar = "bar"
03:57:08 <bringert> Here is a radically new term:
03:57:10 <bringert> > data Foo = ... | Baz
03:57:18 <bringert> Extending f to this new case is trivial:
03:57:20 <bringert> > f Baz = "baz"
03:57:30 <shapr> Yeah, that would be nice.
03:57:56 <bringert> A preprocessor could turn this into:
03:57:57 <bringert> data Foo = Foo | Bar | Baz
03:57:57 <bringert> f :: Foo -> String
03:57:57 <bringert> f Foo = "foo"
03:57:57 <bringert> f Bar = "bar"
03:57:58 <bringert> f Baz = "baz"
03:58:21 <bringert> Hmm, though you might have to replace some existing cases
03:58:32 <dblhelix> http://www.cs.uu.nl/~johanj/DGP2005/andres.pdf
03:58:42 <dblhelix> (fairly preliminary)
03:58:51 <bringert> can you tell I'm trying to grade exams right now?
03:59:01 <bringert> hence all the irc:ing
03:59:58 <dblhelix> the part on open data types and open functions might be of interest to you
04:00:36 <dblhelix> there are some issues involved with pattern matching
04:00:59 <shapr> bringert: hah, I'm here to dodge some painfully boring Python code.
04:02:05 <dblhelix> question on terminology: do you (universally, existentially) quantify over *types* or over *type variables*?
04:02:30 <bringert> I'd say types
04:02:49 <bringert> and you use a type variable to do it
04:03:40 <dblhelix> sounds reasonable
04:03:43 <dblhelix> tnx
04:04:44 <bringert> in id :: forall a. a -> a, the type variable a is universially quantified over all types
04:05:01 * bringert is reiterating
04:05:22 <bringert> isn't "reiterate" somewhat redundant?
04:05:48 <bringert> doesn't iterate already mean that you are repeating something
04:05:59 <bringert> "reiterate" = to once again repeat?
04:07:40 <JohnMeacham> heya, did my message to ghc and cminusminus make sense? it was sort of stream of conciousness. I am not sure if it is novel.. But I have not seen the monadic form carried through to assembly before... hmm...
04:08:44 <JohnMeacham> In any case, it is immediatly useful to jhc, so I guess it doesn't matter if it makes sense :)
04:16:26 <Cale> ah, a monad over the category of values in Val, and GRIN functions between them :)
04:17:11 <shapr> JohnMeacham: I think it's way nifty. I don't have much to compare it with though.
04:18:47 <vegai> is ghc -fvia-C really that good an idea?
04:22:14 <neologism> is there anything like "in" in haskell?
04:22:16 <neologism> like
04:22:16 <kosmikus> shapr, bringert: dblhelix has put it correctly. I'm working on open datatypes at the moment, but it's not in GH. GH has a way to extend generic functions with new cases, but that's a bit like inheritance and defines a new function in the process.
04:22:29 <neologism> foo x = if x in [a,b,c,d\ ... ?
04:22:36 <Cale> `elem`
04:22:41 <neologism> thnx
04:23:26 <JohnMeacham> shapr: coolio. I wanted to add a bunch more about how to lift C-- code back into monadic form suitable for grim optimizations, but my hands were getting tired :)... perhaps a TMR article :)
04:23:48 <neologism> ord/chr ?
04:23:56 <kosmikus> JohnMeacham: please write a HCAR entry!
04:24:00 <Cale> neologism: hm?
04:24:08 <kosmikus> shapr: please write a HCAR entry!
04:24:09 <Cale> neologism: those are functions in Data.Char
04:24:17 <neologism> how can I use it?
04:24:23 <Cale> import Data.Char
04:24:26 <kosmikus> dons: please write a HCAR entry!
04:24:30 <Lunar^> kosmikus: did you get an answer from Andrew Tolmach (or any other House folks) ?
04:24:30 <Cale> then just use ord and chr
04:24:39 <neologism> The requested URL /ghc/docs/latest/html/libraries/base/Data.Char.html was not found on this server.
04:24:42 <neologism> Apache/2.0.46 (Red Hat) Server at www.haskell.org Port 80
04:24:57 <kosmikus> Lunar^: not from Andrew, let me check if anyone else replied
04:25:35 <kosmikus> Lunar^: Thomas Hallgren, yes
04:26:09 <Cale> JohnMeacham: I think that's a very nice way to think about it, and it appears to have nice properties with respect to generating efficient code :)
04:27:44 <Lunar^> kosmikus: great
04:28:12 <Lunar^> kosmikus: when is the deadline already?
04:28:26 <Lunar^> kosmikus: I can try to make an HFuse release and write an entry for HFuse
04:28:30 <neologism> chr ((ord x) - 32)
04:28:33 <neologism> should this work?
04:28:45 <Cale> @eval chr ((ord x) - 32)
04:28:46 <lambdabot>  Not in scope: `x'
04:28:49 <Cale> @eval chr ((ord 'a') - 32)
04:28:51 <lambdabot> 'A'
04:29:01 <neologism> doesnNo instance for (Num Char)
04:29:01 <neologism>       arising from use of `-' at Main.hs:7:31
04:29:05 <neologism> ghc gives me this
04:29:40 <Cale> um
04:30:42 <Cale> you sure that it looks like that?
04:30:57 <neologism> I just rewrote it to
04:31:00 <neologism> toUpper1 xs = map (\x -> if x `elem` ['a'-'z'] then chr (ord x - 32) else x) xs
04:31:07 <neologism>    No instance for (Num Char)
04:31:07 <neologism>       arising from use of `-' at Main.hs:6:41
04:31:29 <Cale> ['a'-'z']
04:31:45 <Cale> should be ['a'..'z']
04:31:48 <neologism> ah :)
04:31:58 <neologism> of coures
04:32:03 <neologism> I havent touched haskell for ages ;)
04:32:10 <integral> it would be nice sometimes if GHC printed a snippet of the line as well as the col number ;-)
04:32:24 <Cale> yeah
04:32:28 <neologism> yes...
04:32:46 <Cale> well, hIDE will take care of that
04:32:47 <Cale> hehe
04:32:57 <JohnMeacham> kosmikus: can I just cull it from my other mailing list posts?
04:33:02 <Cale> you'd have a red underline under - there
04:33:08 <neologism> @get hIDE
04:33:09 <lambdabot> hIDE not defined
04:33:10 <integral> hIDE sounds like it'll practically write you code for you once you write a few type signatures ;-)
04:33:15 <Cale> hehe
04:33:17 <neologism> where can I get the hIDE
04:33:28 <shapr> JohnMeacham: Yes! TMR Article!
04:33:29 <Cale> well, it's hooked up to ghc to to typechecking on the fly
04:33:44 <shapr> kosmikus: I have a draft HC&AR email almost finished...
04:33:44 <Cale> hIDE is currently not even beta :)
04:33:55 <neologism> Cale: can I get the code somewhere?
04:33:58 <Cale> you can get the parts from a number of darcs repositories
04:34:04 <JohnMeacham> shapr: can I cull it from my mailing list posts?
04:34:35 <Cale> http://www.scannedinavian.org/YiWiki/DownloadYi
04:35:26 <JohnMeacham> Cale: I hope so. I already started convering Grin :) it really messes up my region inference algorithms though... I think I will have to figuere out something new..
04:35:33 <shapr> JohnMeacham: of course
04:36:17 <bringert> kosmikus: good thing you showed up here. that got me to submit my HCAR entries.
04:36:40 <bringert> maybe I should write a few more
04:37:00 <JohnMeacham> heh. okay. if no one finds any horrific flaws in it. if I put my class aliases proposal in HMR and it is accepted does that mean it automatically becomes part of the language?
04:37:31 <neologism> is there any documentation which states what each module contains?
04:38:00 <JohnMeacham> states?
04:38:05 <neologism> says
04:38:23 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
04:38:43 <neologism> nice.. thnx
04:39:41 <JohnMeacham> or http://haskell.org/onlinereport/ if you want to stick to haskell 98
04:39:43 <Cale> JohnMeacham: I did a pipeline scheduler/register allocator for PPC/Altivec a while back for a summer job (in Haskell) -- sort of reminds me of some of the issues there :)
04:40:20 <Cale> Code was treated as a graph of dependencies of results.
04:40:58 <Cale> One of the neat things which we had was the ability to define a result in multiple ways and have the scheduler pick the best one.
04:41:22 <Cale> (depending on what units on the processor were free)
04:43:05 <neologism> may I convert IO String to IO Int somewhere?
04:43:12 <neologism> s/somewhere/somhow
04:43:20 <integral> read?
04:43:29 <aleator> return.read?
04:43:50 <Cale> fmap read
04:44:06 <Cale> (or liftM read, same thing)
04:44:22 <Cale> liftM is a bit superfluous though
04:45:25 <neologism> can you show me how?
04:45:43 <bringert> (>>= readIO) also works
04:46:00 <bringert> fails in the IO monad instead of using error
04:46:04 <Cale> n <- fmap read getLine
04:46:36 <bringert> why is there no readM :: (Monad m, Read a) => String -> m a in the standard libs?
04:46:46 <bringert> Iuse it all the time
04:46:47 <neologism> s <- getLine
04:46:47 <neologism>    print (fmap read s)
04:46:50 <neologism> why is this wrong?
04:47:01 <bringert> because s :: String
04:47:03 <Cale> oh, don't need the fmap then
04:47:30 <bringert> nelogism: but you will need an explicit type signature
04:47:47 <neologism>  bringert ?
04:47:50 <bringert> so that the type compiler knows what type to read to
04:48:00 <neologism> :: IO String ?
04:48:16 <bringert> in print (read s), there is no way of knowing what the type of (read s) should be
04:48:21 <jyp> Int
04:48:45 <bringert> so you have to say it explicitly
04:49:49 <neologism> hm...
04:49:57 <neologism> this
04:49:58 <neologism> s <- readLn :: String
04:49:58 <neologism>    print (map (\x -> if x `elem` ['a'..'z'] then chr (ord x - 32) else x) s)
04:50:00 <neologism> compiles ok
04:50:04 <neologism> but when I run the program it
04:50:08 <neologism> witten ~/haskell# ./a.out
04:50:08 <neologism> kljfklasjf
04:50:08 <neologism> a.out: user error (Prelude.readIO: no parse)
04:50:36 <kosmikus> JohnMeacham: sure, you can use whatever you want as a basis; the only important thing is that you submit it ;)
04:50:50 <kosmikus> bringert: thanks
04:51:18 <Cale> neologism: you know that there's toUpper
04:51:30 <Cale> also
04:51:32 <neologism> I am just practicing my skills
04:51:41 <Cale> you don't need to readLn to read a string
04:51:43 <bringert> neologism: it does not compile for me
04:51:50 <Cale> that will make it expect quotation marks
04:51:52 <bringert> "Couldn't match `String' against `IO a'
04:51:52 <bringert> "
04:52:00 <neologism> compiles here
04:52:12 <neologism> ghc 6.4
04:52:26 <dcoutts_> "s <- readLn :: String" is a type error
04:52:46 <neologism> hm...
04:52:50 <neologism> really
04:52:50 <dcoutts_> it's either: (s :: String) <- readLn
04:53:04 <dcoutts_> or: s <- (readLn :: IO String)
04:53:07 <bringert> maybe you compiled something else. I've done that many times. very frustrating
04:53:39 <neologism> s <- readLn
04:53:39 <neologism>    print (map (\x -> if x `elem` ['a'..'z'] then chr (ord x - 32) else x) (s :: String))
04:53:43 <neologism> this gives me the runtime eror
04:53:51 <bringert> "this error message doesn't make any sense" "oh, wait, I for got to save the file / am in the wrong directory / on the wrong machine etc."
04:54:51 <bringert> neologism: as Cale said, readLn is probably not what you want
04:55:04 <bringert> you probably want getLine
04:55:19 <shapr> privet bringert
04:55:28 * shapr pretends to have a clue about cyrillic
04:55:41 <neologism> bringert: I am practicing
04:55:47 <neologism> so I want to knowhow can I convert things
04:55:53 <neologism> cause I obviously dont understand it at all
04:56:13 <jyp> 20 more people here and #haskell beats #python... :)
04:56:34 <psi> don't they have two python channels?
04:56:39 <jyp> shhhhh
04:56:44 <psi> :)
04:56:57 <jyp> there are like 5 haskell channels anywyay :)
04:57:19 <bringert> neologism: ok. getLine reads a string from stdin. readLn reads a string and they calls the read function (actually readIO) on it
04:57:30 <dons> kosmikus, yes, my entry will be in tomorrow (9 hrs or so)
04:58:15 <bringert> read converts a string to a value of the type you want. if you use read to get a string from a string, it will expect a quoted stirng as input.
04:59:00 <dcoutts_> jyp, yeah there are other channels but they are all subsets of #haskell :-)
04:59:24 <neologism> bringert: so what is the correct way to do it using readLn ?
04:59:41 <bringert> what to you want to achieve?
04:59:48 <neologism> I want to know how this all works :)
04:59:58 <kosmikus> dons: great
05:00:29 <bringert> :-)
05:00:31 <shapr> jyp: We had 206 on #haskell a few days back.
05:01:10 <bringert> readLn is for when you want to read something like an int, an double or a quoted string from stdin. i.e. when you want to read the *string representation* of something.
05:01:25 <kosmikus> dcoutts_, Lemmih: what about HIDE for HCAR?
05:01:49 <bringert> the string representation of a string is not the string itself, so readLn is not appropriate for reading unquoted strings
05:02:40 <bringert> readLn is pretty much the same as (liftM read getLine), expect for how it fails when there is an error
05:03:25 <dcoutts_> kosmikus, mmm, yes. Lemmih if you write something, I'll proof-read it :-)
05:03:38 <dcoutts_> kosmikus, I'll send the Gtk2Hs entry of course
05:03:41 <neologism> c <- readLn::IO Int
05:03:41 <neologism>         putStrLn "The pairs itself:"
05:03:41 <neologism>         mapM_ print (p c)
05:03:51 <neologism> this is ok.. but c < readLn:: IO String is not ;(
05:04:12 <bringert> well "c < readLn:: IO String" is ok, but it expects a quoted string as input
05:04:24 <bringert> it's a feature, not a bug :-)
05:04:24 <neologism> yes, but IO Int expects plain number
05:04:27 <bringert> yes
05:04:52 <bringert> readLn expects the *string representation*, the thing that the show function returns
05:05:05 <neologism> ah...
05:05:09 <bringert> Prelude> show 43
05:05:09 <bringert> "43"
05:05:09 <bringert> Prelude> show "foo"
05:05:09 <bringert> "\"foo\""
05:05:30 <bringert> notice the quotes in the string case
05:06:39 <neologism> yes
05:12:07 <JohnMeacham> Cale: Yeah, I used to work on the solaris kernel, paying very close to cache and register behavior was key, no haskell though. perahps once there is a JVM backend..
05:24:07 <neologism> @apply map (+1) [1,2,3]
05:24:08 <lambdabot> Unknown command, try @listcommands.
05:24:14 <neologism> @eval map (+1) [1,2,3]
05:24:15 <lambdabot> [2,3,4]
05:24:55 <dcoutts_> JohnMeacham, that probably makes you a very good person to work on a high level language complier. We need people to pay attention to the register usage and cache behaciour!
05:25:15 <dcoutts_> JohnMeacham, interesting post about the cmm monad monad btw
05:25:48 <dcoutts_> JohnMeacham, do keep sending your brain dumps to the ghc list. It's very interesting reading.
05:26:32 <dcoutts_> JohnMeacham, it makes other people chime in too with their experience. I'd never heard of phc either.
05:29:03 <Lemmih> dcoutts_: I'm not good at writing these things...
05:29:49 <dcoutts_> Lemmih, ok, well just send me a list of things you think I should mention. Same goes for you dons.
05:30:13 <dcoutts_> Lemmih, or maybe we can get dons to write it :-)
05:35:55 <kosmikus> Lemmih: but I'd like an update on Hackage, too ;)
05:39:44 <neologism> how can I remember state using monads?
05:39:52 <dcoutts_> use a state monad!
05:40:24 <dcoutts_> see a monad tutorial for an explanation of what state monads are and how to use them
05:40:54 <neologism> too heavy-weight for what I want
05:41:09 <neologism> is there any way I can "stop" evaulating in foldr?
05:41:29 <neologism> like in
05:41:36 <neologism> foldr (\x -> if x == '0' then (+1) else ...stop...) 0 "0000100"
05:41:44 <neologism> is this possible in any way?
05:41:45 <dcoutts_> not in foldr I think, you can short cut in foldl
05:42:12 <neologism> how?
05:42:49 <dcoutts_> oh wait, I'm wrong it's the other way around
05:42:56 <dcoutts_> foldl f z []      = z
05:42:56 <dcoutts_> foldl f z (x:xs)  = foldl f (f z x) xs
05:43:04 <dcoutts_> foldr f z []      = z
05:43:04 <dcoutts_> foldr f z (x:xs)  = f x (foldr f z xs)
05:43:21 <neologism> how can I stop it?
05:43:48 <dcoutts_> so you can see that in the recursive case for foldr that the result is passed to f as it's second argument, so if you simply return without evaluating the second arg then you're done
05:44:03 <neologism> can you show me on the example I posted?
05:44:08 <dcoutts_> or rather the result is result of f
05:44:36 <dcoutts_> so if say you've just got f _ _ = 3 then that is stopping and returning 3
05:44:59 <dcoutts_> there was a thread on the haskell list a week or so ago about just this issue
05:45:05 <dcoutts_> check the archives
05:45:28 <dcoutts_> basically you can stop just by returning an answer
05:45:54 <neologism> I dont see how can I "return" in fold
05:46:42 <dcoutts_> suppose f _ _ = 3
05:47:12 <dcoutts_> @eval let f _ _ = 3 in foldr f 0 "0000100"
05:47:13 <lambdabot> 3
05:47:48 <dcoutts_> @eval let f _ _ = 3 in foldr f 0 (undefined:undefined)
05:47:49 <lambdabot> 3
05:47:53 <dcoutts_> see?
05:48:06 <dcoutts_> it's not evaluating the whole list
05:48:17 <dcoutts_> (it's just testing to see if it's empty or not)
05:48:23 <dcoutts_> @eval let f _ _ = 3 in foldr f 0 []
05:48:24 <lambdabot> 0
05:48:35 <paolino> ehm , how is it sorting a list ?
05:48:35 <dcoutts_> since if it's empty then you get a diferent answer
05:48:55 <neologism> huh.. I dont see how to appply this to my example
05:49:27 <dcoutts_> neologism, well just by returning an answer that does not use the tail of the list you avoid evaluating the tail of the list
05:49:49 <neologism> if I just "return" then the types dont fit
05:50:07 <dcoutts_> are you trying to do something monadic here?
05:50:15 <neologism> I dont know ;)
05:50:31 <dcoutts_> you're not literally using the function "return" are you?
05:50:40 <neologism> no
05:50:44 <dcoutts_> ok
05:50:59 <dcoutts_> you're quite right that: foldr (\x -> if x == '0' then (+1) else ...stop...) 0 "0000100"
05:51:02 <dcoutts_> does not type
05:51:05 <paolino> it should be trivial sorting I swear or probably I have to import strategies for it
05:51:25 <dcoutts_> neologism, because you're missing the second argument to f
05:51:34 <dcoutts_> paolino, you're just trying to sort a lit?
05:51:37 <dcoutts_> lit/list
05:51:46 <neologism> @eval sort [1,5,7,23,45,]
05:51:47 <lambdabot>  parse error on input `]'
05:51:49 <neologism> @eval sort [1,5,7,23,45]
05:51:51 <lambdabot> [1,5,7,23,45]
05:52:03 <paolino> :t sort is failing here
05:52:15 <JohnMeacham> dcoutts_: okay, but I am running out of my decent brain dumps... pretty soon they will degrade to tips on how to raise chinchillas and how not to make moonshine.p
05:52:16 <Cale> :t List.sort
05:52:21 <neologism> dcoutts_: what second argumetn?
05:52:30 <dcoutts_> JohnMeacham, :-)
05:52:50 <paolino> ah still I miss this story of using '.' to select namespaces
05:52:51 <dcoutts_> neologism, the function you pass to foldr must take two arguments
05:53:01 <dcoutts_> @type foldr
05:53:02 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
05:53:08 <shapr> dons: whoa, check it out - http://www.frappr.com/lambdatheultimate
05:53:34 <neologism> dcoutts_: pls just rewrtie the example.. my brain's failing me ;(
05:54:00 <dcoutts_> shapr, cool
05:55:01 <dcoutts_> neologism, for example:
05:55:03 <dcoutts_> @foldr (\a b -> a `max` b) 0 [1,23, 5,45,7]
05:55:06 <dcoutts_> oops
05:55:10 <dcoutts_> @eval foldr (\a b -> a `max` b) 0 [1,23, 5,45,7]
05:55:12 <lambdabot> *** "a" foldoc "The Free On-line Dictionary of Computing (27
05:55:12 <lambdabot> SEP 03)"
05:55:12 <lambdabot> A#
05:55:12 <lambdabot>  
05:55:12 <lambdabot>    <language> /A sharp/ A separable component of Version 2 of
05:55:14 <lambdabot> the
05:55:16 <lambdabot> [217 @more lines]
05:55:18 <lambdabot> 45
05:55:23 <paolino> anyway I need to pass the sorting function
05:55:30 <dcoutts_> @eval foldr (\a b -> a `max` b) 0 [1,23, 5,45,7]
05:55:32 <lambdabot> 45
05:55:34 <dcoutts_> right
05:55:38 <dcoutts_> neologism, see?
05:55:43 <neologism> not at all :)
05:55:44 <dcoutts_> a function of two arguments
05:55:48 <neologism> yes
05:55:53 <neologism> but how to apply that to my example?
05:56:07 <shapr> JohnMeacham: Purely functional chinchillas?
05:56:40 <ValarQ> shapr: sounds like fun
05:57:58 <paolino> I need to sort a list of values supporting function 'distance::Grupable a=> a->a->Float' from a value of their type
05:58:15 <dcoutts_> @eval foldr (\a b -> if a == 5 then True else b) False [1,23, 5,45,7, undefined]
05:58:17 <lambdabot> True
05:58:39 <dcoutts_> neologism, note how we're not carrying on after meeting 5?
05:58:44 <dcoutts_> @eval foldr (\a b -> if a == 5 then True else b) False [1,23, 5, undefined]
05:58:46 <lambdabot> True
05:58:51 <dcoutts_> @eval foldr (\a b -> if a == 5 then True else b) False [1,23, undefined, 5]
05:58:52 <lambdabot> Undefined
05:58:56 <dcoutts_> see?
05:59:58 <neologism> a bit
06:00:00 * shapr thinks this channel currys on a bit much
06:00:40 <paolino> which is the evolution of "List.sort" accepting a function ?
06:00:56 <dcoutts_> @type sortBy
06:00:57 <lambdabot> Not in scope: `sortBy'
06:00:59 <dcoutts_> @type List.sortBy
06:01:00 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
06:02:07 <paolino> thanks dcoutts
06:03:24 <paolino> bests n value list = take n $ sortBy (distance value) list
06:03:30 <paolino> does it make sense ?
06:03:41 <JohnMeacham> shapr: indeed. quite functional.
06:04:19 <JohnMeacham> http://repetae.net/john/pictures/chin-ignignot-mom.jpg
06:05:08 <neologism> dcoutts_: oldr (\y x -> if y == '0' then x+1 else x) 0 "00001000"
06:05:10 <neologism> doesnt work :(
06:05:52 <neologism> foldr (\y x -> if y == '0' then x+1 else 0) 0 "0000100000"
06:05:54 <neologism> this works ;)
06:05:56 <neologism> thnx for explanation ;)
06:06:41 <blackdog> JohnMeacham: can you call code compiled with jhc from C code?
06:06:48 <dcoutts_> @eval foldr (\y x -> if y == '0' then x+1 else 0) 0 ("00001" ++ [undefined])
06:06:49 <lambdabot> 4
06:07:04 <shapr> Wow, do you really raise chinchillas?
06:07:13 * blackdog thinks that shapr has a weakness for appalling puns
06:08:04 <shapr> Man they're cute.
06:09:34 <JohnMeacham> blackdog: not yet, but it would not be too hard to add, I wrote everything with it in mind.
06:09:35 <bringert> do you also have a picture of how to not make moonshine?
06:10:18 <shapr> Man those are cute.
06:10:46 <basti_> i know a guy who has a ferret as a pet
06:10:52 <JohnMeacham> bringert: only of  my friend (the beta tester) not being very pleased with the result.
06:11:27 <JohnMeacham> shapr: indeed. I can't decide whether she is pregnant again though. she has been gaining weight, but it is hard to tell.
06:12:15 <Lemmih> @seen SyntaxNinja
06:12:16 <lambdabot> I saw SyntaxNinja leaving #haskell 1 day, 11 hours, 27 minutes
06:12:16 <lambdabot> and 46 seconds ago, and I have missed 1 day, 5 hours, 10
06:12:16 <lambdabot> minutes and 9 seconds since then.
06:12:48 <JohnMeacham> yup. moonshine is how this happened http://repetae.net/john/pictures/pirate1.jpg
06:17:55 <paolino> bests n value = (take n).(sortBy (\x y -> (distance x value)-(distance y value)))
06:18:03 <paolino> this is almost there
06:18:17 <paolino> but Float against Oredering
06:18:47 <paolino> as distance returns a Float
06:20:20 <paolino> I feel I'm doing something stoopid  :/
06:21:37 <Lemmih> try: (distance x value `compare` distance y value)
06:21:38 <dcoutts_> @type compare
06:21:39 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
06:25:38 <paolino> :))
06:31:13 <Lemmih> 'module Main where main = putStrLn "Hello world"' segfaults when compiled with jhc. Am I doing something wrong?
06:34:57 <{Arias}> how can I apply readFile and lines in the same line?
06:35:58 <JohnMeacham> Lemmih: it should work. hmm.. try the test/HelloWorld.hs
06:36:16 <JohnMeacham> what os/arch? any warnings during the compile?
06:36:19 <Lemmih> JaffaCake: The initial malloc of one gig fails.
06:36:27 <Lemmih> *JohnMeacham
06:36:42 <vegai> the initial malloc of one gig?
06:36:56 <Lemmih> Changing it to something smaller works.
06:37:00 <JohnMeacham> Ah, just decrease it then. you can edit the C file and rerun the gcc command or change it in C/FromGrin.hs
06:37:28 <JohnMeacham> I chose it sort of randomly. the OS doesn't actually allocate the memory til used so it doesn't actually use a gig of ram.
06:37:29 <JaffaCake> JohnMeacham: what kind of memory management are you donig in jhc?  do you have a GC?
06:37:39 * Raziel se va
06:38:23 <JohnMeacham> JaffaCake: The Boehm GC is the only real option at the moment. I have some experimental region inference code and plans for a gc. not sure which I will eventually go with.
06:38:41 <JaffaCake> ok, thanks
06:39:18 <JohnMeacham> Though the addition of continuations really futzez up the region inference algorithms I was working on.. But I think that can be solved.
06:39:32 * Lunar^ like to see compiler dev. talking :)
06:41:06 <JohnMeacham> hehe.
06:44:13 <blackdog> can someone help me with the FFI? I can't work out how to tell ghc to compile the c code - it craps out on linking. should i bring roses?
06:46:39 <eivuokko> Just give the c sources on the commandline or use -c to just compile and link .o on later step?
06:49:16 <dcoutts_> blackdog, if you're using --make then ghc will automatically complie and link the c bits (I think)
06:49:23 <eivuokko> Yeah, it does.
06:50:20 <blackdog> ghc --make foo.c doesn't work, though... how do i call it?
06:51:18 <eivuokko> What are you trying to do?
06:51:30 <blackdog> call haskell from c
06:52:17 <blackdog> i can see that ghc creates the foo_stub.c file when i compile the hs code
06:52:21 <kosmikus> Lemmih, shapr: thanks for all the entries
06:53:02 <blackdog> how do i put the c code together with the ghc-generated C and hs objects?
06:53:12 <bringert> blackdog: hmm, I've done that once. trying to remember
06:54:22 <blackdog> ok, just doing ghc *.o seems to work. be interesting to see if you can do it in one command line...
06:54:27 <eivuokko> Using external makefile is probably easiest.  Just compile all .hs into .c, stubs iirc are compiled into objects automatically.  Then link them together using ghc.  (when linking use -no-main or so)
06:58:55 <eivuokko> Btw, I cannot do it on one commandline when building dlls.  I compile using haskell with ghc --make -no-link on important modules use output directory options, compile ghc -c c files, then copy all .o in one place and ghc --mk-dll *.o or so.
07:02:52 <blackdog> is there a c routine to slurp in a whole file? Or have i just been spoiled by ruby and haskell?
07:05:10 <bringert> blockdog: most likely
07:05:12 <eivuokko> Spoiled. ;)
07:05:50 <blackdog> <lamb> never an easy way... </lamb>
07:05:59 <bringert> It'd be a little messy, but I guess you could write one which mallocs a vector along the way
07:06:29 <eivuokko> Memory mapping might also be a solution.
07:07:04 <blackdog> eh, i don't really care about errorchecking at this stage. fgets would be fine if it didn't get all hot and bothered by newlines.
07:07:24 <blackdog> i'll throw the code away as soon as it works. promise. :)
07:07:36 <eivuokko> ;)
07:07:42 <blackdog> memory mapping is a good idea, though
07:08:32 <bringert> a quick (and very dirty) other solution is to check the file size, malloc a buffer of that size and read in the file. nasty if someone changes the file after the size check
07:10:17 <bringert> hmm, what happens if someone appends to a file after you mmap() it? you are only seeing and changing the part that you mmap():ed I guess
07:10:42 <bringert> "If the size of the mapped file changes after the call to mmap() as a result of some other operation on the mapped file, the effect of references to portions of the mapped region that correspond to added or removed portions of the file is unspecified."
07:13:28 <blackdog> bringert: wow, unspecified behaviour in core C routines. colour me gobsmacked.
07:15:23 <eivuokko> mmap is posix, not c.
07:16:12 <blackdog> true. i forget that they're not the same thing sometimes.
07:18:50 <bringert> what's the point of the PROT_NONE for mmaping?
07:19:04 <bringert> why mmap something that you won't be able to access?
07:21:15 <blackdog> any comments about the sound of one pointer clapping will get what they deserve.
07:21:48 * bringert says huh?
07:22:25 <blackdog> it just seemed a natural moment for that cod-zen you get with programmers regrttably often.
07:28:52 <blackdog> hurrah. i can call haskell from c. now for ruby.
07:34:48 <b0gg1e> blackdog: just quickread the last section, i've got some rudimentary, unreleased hsc bindings from haskell to mmap.  do want them?
07:35:49 <blackdog> nah, i'm fine, thanks. the mmap stuff was on the C side.
07:39:50 <pesco> Hah, the beautiful C-side.
07:40:15 <b0gg1e> btw i wonder why there is no mmap() in the hierarchical libraries.
07:40:38 <b0gg1e> this would be necessary for things like writing a database in haskell.
07:40:49 <blackdog> if it were haskell, i'd be happy with hGetContents
07:42:50 <shapr> Oh hey, I was going to talk to ProfTeggy about his SASL tutorial.
07:43:37 <shapr> blackdog: Seen the description of the Schvung web framework? what do you think?
07:44:01 <shapr> bringert: Oh hey, do you have any thoughts on that? Haskell Web framework as a Data.Graph value holding Haskell2Xml instances?
07:44:36 <blackdog> b0ggle: might be a type thing -it effectively means that any pure op might trigger an IO action. (although i suppose hgotcentents is the same)
07:44:49 <blackdog> shapr: no, haven't seen it
07:45:18 <b0gg1e> well you want io in the first place.. you have to live with the io monad...
07:45:52 <b0gg1e> assides in case of a db, on some higher level unsafePerformIO and a "Database" monad might be quite reasonable.
07:46:44 <blackdog> sure, but isn't the point of mmap that you can treat a file read op as just a memory read? if you've mapped it at the os level, i'm not sure how you could control side effects
07:48:19 <b0gg1e> well with a db you have to assume that no one from the outside is writing your files, and on the inside, consistency is your job.
07:49:02 <eivuokko> Hmm.
07:49:22 <b0gg1e> of course additonally you could lock the files but im unsure about the interaction of flock, mmap and the diverse unix personalities in extistence.
07:49:35 <eivuokko> Consistency is hard to guarantee with write caches, which cannot be bypassed (afair) with just mmap.
07:50:30 <b0gg1e> yes, thats why you need a block manager and some kind of transaction log and all that.  propably a lot of fun to write in haskell.
07:51:35 <b0gg1e> i do not mean any user file access via mmap is a good idea, this is for performance oriented systems or persistence layer programming
07:53:09 <shapr> What about using ZFS to automatically derived a transactional subcontinuation based zipper for your datatype?
07:53:27 <shapr> That's what I'm planning for Schvung. Then I won't even have to think about it.
07:55:08 <b0gg1e> i have to admit i havent understood the zipper stuff yet.
07:55:33 <araujo> Hello!
07:55:41 <araujo> you mean.. zipWith , zip .. ?
07:55:56 <b0gg1e> no.. ZFS subcontinuations.
07:55:58 <blackdog_> i'w not saying it's not a good idea, just that if you include a routine in the standard libs, you generally expect it to obey its signature
07:56:13 <blackdog_> forgive my typos, i'm still learning dvorak
07:56:20 <b0gg1e> :-)
07:56:33 * b0gg1e thinks, i should do that, too.
07:56:37 <blackdog_> shapr: info on schvung around?
07:57:05 <blackdog_> don't do it to speed up, i'm still slower. but my wrists don't hurt any more
07:57:56 <b0gg1e> shapr, would the ZFS approach allow something like dynamic paging?
07:58:45 <b0gg1e> blackdog: i implented mmap in terms of the foreign module, so it does obey its isgnature in a way.
08:02:16 <b0gg1e> e.g. memMapFileShared :: Ptr a -> [MemProtFlag] -> CSize -> Fd -> FileOffset -> IO (Ptr a)
08:02:22 <shapr> blackdog_: basic idea is on my blog, but you've just heard most of it.
08:02:43 <shapr> blackdog_: ooh dvorak!
08:02:47 <shapr> blackdog_: What do you think so far?
08:03:15 <b0gg1e> url_
08:03:16 <b0gg1e> ?
08:03:35 <blackdog_> it's nice. i just need to practice more.
08:03:43 <blackdog_> i'm probably at 30 wpm
08:04:25 <shapr> Do you notice any of the oft-described advatanges?
08:05:01 <shapr> b0gg1e: For my blog? http://www.scannedinavian.com/ for blackdog_'s blog, http://www.shimweasel.com
08:06:42 <blackdog_> i can't see anything about schvung there... am i high?
08:07:39 <blackdog_> it's odd - left hand and right hand are about evenly split, but left hand stays on the home row and right hand jumps about like a white man convinced he can dance.
08:07:42 <shapr> Yeah, I write a lot on my blog, so it's covered up.
08:08:47 <ozone> blackdog_: fag
08:08:51 <shapr> here's  the schvung discussion -  http://www.scannedinavian.org/blog/2005-09-30.html and http://www.scannedinavian.org/blog/2005-10-03.html
08:09:34 <shapr> Here's the crux of the matter - "<poetix> Having a data model for all the pieces of your system is very powerful, and being able to do graph-traversals and transformations on that model - if it is graph-shaped - is important (and is also where SQL DBMSs tend to fall down)"
08:10:00 <shapr> If you can put the whole website into one or more Data.Graph values, you can statically analyse as much as you want.
08:10:15 <blackdog_> ozone: how i've missed your kindhearted, foulmouthed abuse.
08:10:34 <ozone> blackdog_: bet you do, beeyotch!
08:10:35 <b0gg1e> ah thanks.
08:10:36 <jyp> lol
08:11:26 <b0gg1e> shapr i am interested in sematic web stuff and was looking into associative databases lately.. thats why i wrote the mmap thingy, wanted to try the haskell ffi in action.
08:12:00 <shapr> I thought of a simple i18n solution this way, just parameterise a graph with another graph. gettext does that, but limits it to strings. That's not good enough. I've needed to translate images, entire documents, etc. Graph paramaterization lets the developer do 'i18n' on anything.
08:12:32 <blackdog_> shapr: what's the application domain? what areas are graph traversal algorithms useful for? Most web stuff seems to work ok with reasonably simple structures
08:13:03 <blackdog_>  i think you need a really strong example to motivate it
08:13:36 <shapr> blackdog_: What about guaranteed HTML/XML DTD type safety for the whole site? Or the ability to check for W3C accesibility statically?
08:13:37 <blackdog_> ozone: you gonna stop bawling me out and answer my email?
08:13:40 <ozone> like your momma
08:14:00 <b0gg1e> ah nice idea.
08:14:01 <shapr> blackdog_: subDTD typechecking would give completely typesafe TAL for example.
08:14:08 <Oejet> blackdog_: Why is your righthand jumping around?  What high frequency keys are not on the home row?
08:14:09 <blackdog_> oh, she's not nearly as strong as yours. I could hardly stay on the bed.
08:14:35 <ozone> blackdog_: i'm playing CS, will answer later :)
08:14:56 <blackdog_> Oejet: mostly in comparison to the left, i guess. they almost never move.
08:14:58 <shapr> The motivation is "be able to statically check anything," that is, let's get as far away from Plone as we possibly can.
08:15:43 <bringert> shapr: how do you make dynamic web programming with graphs?
08:15:47 <shapr> Storing the whole thing on top of ZFS means you get transactional semantics, undo, and Plone's 'versions' for free.
08:16:02 <bringert> s/make/do/
08:16:28 <Oejet> blackdog_: I'm thinking about using Norwegian Dvorak layout since it has , and . close (w and e) and is close to Danish in many regards.
08:16:35 <shapr> bringert: I think you use the zipper cursor to dynamically change the site. I haven't thought of anything better yet. Any ideas?
08:16:54 <blackdog_> shapr: i'm unconvinced... it's a nice feature, but not killer.
08:17:13 <bringert> shapr: hmm, for editing the web site that could work I guess
08:17:22 <bringert> but what about database-driver stuff
08:17:28 <blackdog_> try seaside or RoR. they're the competition, not shitboxes like plone.
08:17:44 <bringert> s/driver/driven/
08:17:46 <bringert> dammit
08:18:01 <shapr> blackdog_: Yeah, I need to improve it. Still, it's only a month old, hopefully I can steal ideas from RoR or seaside and improve them in the context of Haskell.
08:18:51 <shapr> bringert: I don't know. I'd like to integrate musasabi's HsWebForms ideas in here somehow. Obviously that would inclued HaskellDB.
08:18:55 <jewel> what's a shitbox?
08:19:03 <blackdog_> anyway, i'm buggered. g'night all.
08:19:07 <shapr> Sounds like a litterbox that's never cleaned :-)
08:19:33 <blackdog_> jewel: a folksy australian non-euphemism for a toilet.
08:19:45 <jewel> but a dirty one?
08:20:15 <bringert> what's the opposite of euphemism?
08:20:20 <blackdog_> not necessarily. often also used to refer to beat-up cars.
08:20:42 <jewel> so what does it mean for code?
08:21:12 <shapr> bringert: I have to go, but if you have any more thoughts on this idea, I'd like to hear about it. I think it might be a good way to do build Haskell-esque webapp framework.
08:21:27 * shapr gets a SIGWENCH, gotta go spend time with tha woman
08:21:46 <bringert> shapr: nibro and I are supervising a project about a haskell web  apps framework, so I'm also very interested in the subject
08:21:57 <blackdog_> well, i was thinking more of the car meaning, now i think of it - thus, it'll gget you where you need to go, but it won't be quiet, fast, or pretty, and there's a funny smell under the hood...
08:22:32 <shapr> bringert: I'll think about doing database driven stuff with Schvung (like the name?).
08:22:38 <shapr> Maybe I'll come up with some nifty solution.
08:22:52 <blackdog_> clearly i'm decohering. really going this time.
08:23:42 <basti_> SIGWENCH yes... ^^
08:23:45 <bringert> shapr: cool name
08:24:22 <bringert> shapr: anothing issue is user input, but you're already thinking about that with haswebforms I see
08:29:31 <MarcWeber> I'm currently reading the monad tutorial. Can I define a data type containing a name, a Maybe father of type sheep ? ghc rejects: data Sheep name father = name::String Maybe father::Sheep
08:29:59 <integral> *blink* that's not the right syntax for data :-)
08:30:48 <integral> data Sheep = MkSheep String (Maybe Sheep); {- but this doesn't name anything -} data Sheep = MkSheep { name :: String, father :: Maybe Sheep }
08:31:46 <ibid> or data Sheep = Sheep { name :: String, father :: Maybe Sheep }
08:32:18 <Speck> since data constructors and type constructors are in different namespaces
08:34:50 <MarcWeber> ibid, integral Thanks. I prefer integrals second = ibids solution :) It's weired: Everytime I think i got the point till I start coding..
08:35:29 <integral> just because they're different namespaces, doesn't mean a bit of disambiguation for the human isn't nice ;-)
08:36:05 <ibid> integral: i tend to use the same name for the single constructor of a type, i find it clearer :)
08:36:17 <ibid> Mk etc are just annoyances, they add no information
08:36:31 <MarcWeber> You are talking about prefixing Mk, aren't you? *me is happy*
08:36:37 <ibid> yeah
08:36:54 <integral> in pugs there's one very annoying style for constructors: data SomeUnion = VFoo VFoo;  data VFoo = MkFoo ...
08:36:58 <integral> *that*'s confusing :-)
08:37:16 <ibid> i've started using the following in my current project:
08:37:37 <ibid> newtype FooPtr = FooPtr MVar Foo
08:37:46 <ibid> data Foo = Foo { ... }
08:37:52 <ibid> gah
08:37:58 <ibid> add the parens where necessary :)
08:38:26 <ibid> type/kind-direct disambiguation of parse trees would be nice
08:38:31 <integral> newtype makes it all worth it :-)
08:38:40 <ibid> ?
08:39:15 <integral> ibid: it's the thing that C missed.  When you've got typedef long size_t, you just don't have the safety of newtype
08:39:40 <ibid> type has it's uses
08:39:45 <ibid> (typedef, too)
08:40:09 <ibid> you can get a newtype in C by using typedef struct { foo mkfoo; } foo_t;
08:40:14 <integral> but not for creating newtypes like size_t ;-)   I tend to use type to name applications of typeconstructors
08:40:36 <ibid> integral: for size_t-like stuff, use the struct hack
08:40:52 <integral> yeah.   I guess all modern compilers have no problem "unboxing" that
08:41:01 <eivuokko> You'd be suprised.
08:41:13 <ibid> well, i don't see why any old compilers would have trouble with htat
08:41:37 <ibid> the only problem i see is that you can't elect not to export the field name, like you can the data constructor
08:42:05 <araujo> Is there a way to pass a data-type to a function?
08:42:34 <ibid> ok, a mindless "structs must be passed specially" calling convention may foul that, but also in modern compilers
08:42:39 <ibid> araujo: what do you mean, specifically=
08:42:59 <araujo> ibid, I wanna pass for example, Int , Double etc to a function as argument
08:43:18 <ibid> araujo: can you give a brief example?
08:43:33 <araujo> mm.. let me see
08:43:53 <MarcWeber> ibid: Would you mind explaining me your line newtype FooPtr = FooPtr MVar Foo?
08:43:57 <integral> sounds a bit like you just want a function with a Num type constraint...
08:44:08 <ibid> MarcWeber: what about it?
08:44:15 <araujo> let f x = 2 :: x + 3 :: x
08:44:25 <ibid> MarcWeber: note that it's supposed to be newtype FooPtr = FooPtr (MVar Foo)
08:44:30 <araujo> Something like that
08:44:37 <ibid> no, you can't
08:44:41 <syntaxfree> I have a .hs file I can run in ghci, but can't compile.
08:44:42 <ibid> but why would you want to do that?
08:44:54 <integral> you can't do: f (x :: a) = (2 + 3) :: a -- in GHC?
08:45:16 <ibid> hmm, that might work, but i think that's an extension, no?
08:45:18 <araujo> ibid, crazy fun :-P
08:45:20 <integral> or just say: f :: Num a => a -> a; f _ = 2 + 3
08:45:35 <integral> @type \_ -> 2 + 3
08:45:36 <lambdabot> forall a t. (Num a) => t -> a
08:45:41 <integral> @type \_ :: a -> (2 + 3) :: a
08:45:43 <lambdabot> a -> (2 + 3) :: a :: forall a t. (Num a) => t -> a
08:46:02 <integral> @type \(_ :: a) -> ((2 + 3) :: a)
08:46:04 <lambdabot> forall a. (Num a) => a -> a
08:46:18 <integral> there we go.
08:46:19 <nuffer> is there any function like "separate :: [Maybe a b] -> ([a], [b])"?
08:46:37 <integral> nuffer: do you mean Either instead of Maybe?
08:46:47 <ibid> nuffer: no, because there's no type Maybe a b
08:47:04 <araujo> Thanks integral
08:48:36 <nuffer> yeah, Either I mean
08:53:00 <nuffer> but is there a function that does what I want?
08:53:01 <bourbaki> moi
08:53:02 <bourbaki> n
08:56:35 <bringert> nuffer: for some reason there are very few funtions in the standard libraries for working with Either values
08:56:41 <bringert> afaik anyway
08:56:49 <beelsebob_> anyone know how to get the hs-plugins version number?
08:57:27 <bringert> there aren't even isLeft / isRight functions
08:57:47 <Speck> use case
08:57:55 <bringert> or Data.Either.either
08:58:38 <nuffer> I can write this function easily... it's trivial
08:58:43 <nuffer> I just wanted to know if it was already done
08:58:56 <bringert> nuffer: I agree, it should be in the libs, but isn't
08:59:26 <bringert> who can come up with the shortest definition?
09:00:20 <Speck> I don't see the use case
09:00:25 <bringert> here's something to get it started: separate xs = ([x | Left x <- xs], [x | Right x <- xs])
09:00:49 <bringert> Speck: how do you write that function using only case?
09:01:32 <bringert> or did you mean with case and recursion?
09:01:34 <Speck> bringert: sorry I wasn't paying attn to the question at hand
09:01:45 <Speck> just case has been enough for all my Either needs
09:02:07 <bringert> yeah, it is most of the time
09:02:53 <Speck> the name Either makes me think I want one or the other, which means to me that there would be very little semantic value in having a function that would make a tuple from it.
09:03:25 <bringert> right, but now it's a list of Eithers
09:03:49 <nuffer> Speck: I want to pull the list apart into two lists
09:03:58 <nuffer> one containing all the Left values and one containing all the Right values
09:04:04 <Speck> why do you have a list of Eithers instead of a relation?
09:04:12 <Speck> (rather, a list of tuples)
09:04:22 <nuffer> because I have a function that returns an either
09:04:24 <nuffer> and I map that over a list
09:05:49 <Speck> hm
09:11:52 <Speck> the definition of Either seems to not require each instance of it have both a left and a right, or is that guaranteed?
09:12:27 <beelsebob_> speck Either Jam undefined
09:12:31 <beelsebob_> no
09:12:34 <int-e> an Either value can not have both Left and Right.
09:12:38 <ibid> Speck: that question is nonsensical.  Either is defined so that every *object* is either left or right
09:12:51 <ibid> (hence the name)
09:12:53 <Speck> I know I know
09:12:58 <Speck> but if you wanted to split it
09:13:02 <Speck> like nuffer does
09:13:07 <ibid> there are no instances of Either
09:13:23 <Speck> I knew it was the wrong word when I chose it
09:13:42 <int-e> bringert: using Control.Arrow, separate = foldr (either (first.(:)) (second.(:))) ([],[]) ... but that's actually longer than your version.
09:13:42 <ibid> object was also the wrong word, *value* is correct
09:14:32 <ibid> Speck: i'm still not sure what you intended to ask, sorry :)
09:14:36 <nuffer> Speck: I'm not dealing with one Either, I have a list of them
09:15:10 <nuffer> so if I had [(Left x), (Left x2), (Right y)] I want to get ([x, x2], [y])
09:15:14 <nuffer> but I already wrote the function I wanted
09:15:20 <nuffer> so, no worries
09:15:24 <Speck> oh I get it
09:15:35 <Speck> sigh I should just keep lurking
09:16:32 <bringert> int-e: hehe, I was just trying to write it using arrows
09:17:05 <bringert> but mine was not as good as yours
09:19:46 <ibid> an obvious solution: separate = foldr hat ([],[]) where hat (Left l) (ls,rs) = (l:ls, rs) ; hat (Right r) (ls,rs) = (ls, r:rs)
09:19:48 <nuffer> I did mine with three lines and pattern matching... it works but not as concise
09:19:54 <ibid> not short though
09:20:15 <nuffer> separate ((Left x):es) = let { (xs, ys) = separate es } in ((x:xs), ys)
09:20:19 <nuffer> and then the right and base cases
09:20:44 <ibid> nuffer: folds are your friends ;)
09:20:57 <nuffer> I'm new to this...
09:21:56 <ibid> fold is the functional programmer's for loop :)
09:22:36 <kala> hello. is this a bug: last [] => Program error: pattern match failure: last []
09:23:08 <ibid> kala: yes.  the interesting question is whose bug it is :)
09:23:12 <kala> hugs
09:23:16 <ibid> kala: likely yours, not last's
09:23:25 <ibid> kala: but that depends on what you're doing
09:23:46 <kala> I'm doing last [] in hugs prompt :)
09:23:48 <int-e> an empty list has no last element
09:23:53 <ibid> kala: yours then
09:23:55 <bringert> here is a nicely unreadable version: separate = (concat *** concat) . unzip . map (either (flip (,) [] . (:[])) ((,) [] . (:[])))
09:24:03 <kala> int-e: last cannot return nothing?
09:24:05 <ibid> kala: last is performing as expected
09:24:21 <int-e> @type last
09:24:22 <lambdabot> forall a. [a] -> a
09:24:24 <int-e> kala: no.
09:24:31 <kala> oh, ok
09:24:41 <ibid> kala: actually, that's what it's doing, in a way
09:24:42 * kala wonders what should I do then ... :)
09:24:45 <ibid> it's returning bottom
09:24:56 <ibid> kala: test for emptiness before calling last
09:25:03 <liyang> you could define a last' [] = Nothing
09:25:08 <liyang> last' [a] = a
09:25:13 <ibid> +Just
09:25:21 <liyang> ibid: thank you. :)
09:25:24 <bringert> or last' = reverse . drop 1 . reverse
09:25:39 <bringert> which is much worse
09:25:44 <int-e> @pl (concat *** concat) . unzip . map (either (flip (,) [] . (:[])) ((,) [] . (:[])))
09:25:45 <lambdabot> (join *** join) . unzip . map (either (flip (,) [] . return) ((,
09:25:45 <lambdabot> ) [] . return))
09:26:01 <liyang> bringert: isn't that init?
09:26:09 <bringert> eh
09:26:10 <bringert> yes
09:26:18 <bringert> so it's *much* worse
09:26:23 <bringert> not even the same function
09:26:29 <ibid> head . reverse
09:26:30 <bringert> sorry about that
09:26:33 <kala> naah, I should probably rewrite my logic, because 'head []' doesn't work either :)
09:26:37 <liyang> The remaining case for last' is left as an exercise for the reader. :)
09:27:16 <bringert> @help pl
09:27:17 <lambdabot>  @pointless <expr> - play with pointfree code
09:27:36 <ibid> liyang: according to a math joke, "left as an exercise for the reader" means that the writer attempted and failed to do it ;)
09:27:52 <liyang> ibid: *sigh*
09:27:58 <ibid> ?
09:28:03 <liyang> Must I? I'm supposed to be at work here. :p
09:28:17 <int-e> @index join
09:28:18 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer,
09:28:18 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
09:28:18 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:28:25 <kala> liyang: come on, its friday :)
09:28:27 <ibid> liyang: if you believe in math jokes, you should
09:28:33 <ibid> liyang: but then you
09:28:44 <ibid> 'll also be able to capture a lion in sahara :)
09:29:43 <ibid> liyang: know that one?
09:29:47 <ustenzel> kala: take 1 . reverse
09:30:12 <kala> @info take
09:30:13 <lambdabot> Unknown command, try @listcommands.
09:30:13 <liyang> last' (_ : t@(_ : _)) = last' t
09:30:40 <kala> @type take
09:30:41 <lambdabot> forall a. Int -> [a] -> [a]
09:41:58 <Philippa> liyang: you're still in the labs at 20 to 6 on a friday? Damn
09:42:53 * beelsebob_ prods Philippa in the naughty bits
09:43:29 <SyntaxNinja> 'morning
09:43:34 <ibid> good evening
09:43:48 <Speck> good afternoon
09:44:04 <SyntaxNinja> it's always morning on IRC :)
09:44:22 <ibid> it's always every time of day on IRC
09:45:09 <liyang> Philippa: not labs... working right now. :)
09:45:32 <liyang> Philippa: incidentally I am planning to visit Nott this month. I've put it off long enough. -_-;;
09:46:12 <SyntaxNinja> blackdog_: h0
09:49:54 <liyang> ibid: actually, do share the lion in sahara one.
09:50:52 <Philippa> liyang: when is it you're starting, again?
09:51:14 <liyang> Philippa: January. Working until then.
09:51:36 <ibid> well, the question is, how does a mathematician capture a lion in sahara?  he (or she, as the case may be) puts a cage in the center of the desert, goes in there him- or herself, locks the cage and finally mirrors the desert with respect to the cage
09:51:55 <ibid> the end result: the mathematician is out of the cage, the lion is inside the cage
09:53:30 <liyang> ibid: I see. Sounds good enough to me. :)
09:54:28 * ibid collected these in my freshman year as math major, when i still though i was to become a pure mathematician
09:54:31 <ibid> +t
09:54:46 <liyang> ditto. >.<;;
09:55:05 <kala> somebody care to comment a homework solution? is it possible to do it better? http://pastebin.com/409084
09:55:19 <ibid> define "better" M)
09:55:38 <kala> ibid: heh. "nicer", "quicker" ... ?
09:55:42 <ibid> (there's always a more obscure one, surely.  as to whether that counts as better, ...)
09:55:49 <paolino> I need help with a zipper: how I exchange two subtrees ?
09:55:53 <integral> kala: you're missing {- -} around the stuff at the top.  It's not valid haskell.
09:56:02 <ibid> (in some haskell circles, more obscure seems to mean better)
09:56:03 <kala> integral: oh, right
09:56:32 <integral> and you've got a mixture of "suffle" and "shuffle"
09:56:35 <basti_> @eval let suffle x = (last x):(init x) in suffle [1..15]
09:56:36 <lambdabot> [15,1,2,3,4,5,6,7,8,9,10,11,12,13,14]
09:57:01 <basti_> urhm
09:57:13 * basti_ wakes up
10:00:13 <paolino> this is my module http://42.vg/84413 I hope the zipper is ok for the exchange operation.
10:00:47 <basti_> @eval let {suffle (x:tx) = x:(suffle $ reverse tx); suffle [] =[]} in suffle [1..5]
10:00:48 <lambdabot> [1,5,2,4,3]
10:00:55 <basti_> ineffective though
10:01:03 <basti_> kala: !
10:01:22 <ustenzel> kala: suffle [] = [] ; suffle (x:xs) = x:suffle (reverse xs)
10:01:40 <ustenzel> (damn, two seconds late)
10:01:43 <basti_> ^^
10:01:53 <kala> uhh
10:02:09 <syntaxfree> so I was examining lambdabot's code.
10:02:27 <syntaxfree> there are a lot of C-style #ifs and #endifs.
10:02:45 <syntaxfree> #if __GLASGOW COMPILER > 604, etc.
10:02:56 <syntaxfree> how do I get that stuff preprocessed so I get compileable Haskell code?
10:03:16 <basti_> hmm actually it's c's preprocessor ^^
10:03:21 <eivuokko> If you are using ghc, use -cpp option.
10:03:58 <kala> basti and ustenzel: very interesting :))
10:04:29 <basti_> kala: it's quadratic though
10:04:37 <MarcWebe1> What is wrong here? http://www.rafb.net/paste/results/KuDtcI16.html Simple Maybe test program ghc error on line 10
10:06:25 <basti_> MarcWebe1: thats a little difficult to explain.
10:07:13 <paolino> should I try to write a smaller module with same functionalities to try being helped ? (I hope not :-| )
10:07:25 <basti_> MarcWebe1: in the end it boils down to the fact that the compiler doesnt know how to "show" the element that isn't there in "Nothing".
10:07:45 <basti_> that sounds bizarre.
10:07:58 <basti_> but try (Nothing::Maybe Int)
10:08:04 <basti_> (int is an instance of Show)
10:08:13 <MarcWebe1> So it should use the second definition, shouldn't it?
10:08:21 <basti_> huh?
10:08:29 <basti_> no the problem is at a different spot
10:08:34 <basti_> comment out line 10
10:08:36 <ibid> MarcWebe1: write a type for the function
10:08:46 <basti_> then use ghci6 to show the type of isJustOrNothing
10:08:48 <ibid> MarcWebe1: spot the problem then?
10:09:49 <basti_> it's the same error message then ibid
10:09:55 <MarcWebe1> ibid: Which type is it ? I want to pass a Maybe and get nothing back..
10:10:06 <ibid> basti_: you missed the point
10:10:12 <basti_> hmm
10:10:20 <ibid> MarcWebe1: did you write a type for the function? what is it?
10:10:22 <basti_> ok then we're basically giving the same advice
10:10:27 <ibid> basti_: yeah :)
10:10:37 <ustenzel> @eval let { s [] _ _ = [] ; s (_:xs) (_:ys) zs = x : s xs zs ys ; suffle xs = s xs xs (reverse xs) } in suffle [1..5]
10:10:38 <lambdabot>  Not in scope: `x'
10:10:57 <ustenzel> @eval let { s [] _ _ = [] ; s (_:xs) (y:ys) zs = y : s xs zs ys ; suffle xs = s xs xs (reverse xs) } in suffle [1..5]
10:10:58 <lambdabot> [1,5,2,4,3]
10:11:25 <ustenzel> kala: this one is linear :)  (and sick, too)
10:11:39 <basti_> sick is different.
10:13:02 <ustenzel> maybe.  in a homework, it will look sick, though.
10:13:04 <paolino_> (sorry my gprs unconnection....) (did I get answers  ? )
10:14:08 <Lemmih> Hi SyntaxNinja.
10:15:35 <Lemmih> syntaxfree: Have you submitted a Hackage/Cabal HCAR entry like you did last time?
10:15:43 <Lemmih> *SyntaxNinja
10:17:04 <SyntaxNinja> hi Lemmih
10:17:10 <SyntaxNinja> I haven't updated the entry (yet?)
10:19:29 <thedward> do I have to do something special to make ghc 6.4.1 work with unicode?
10:20:34 <SyntaxNinja> Lemmih: do you have any changes you want to make?
10:20:36 <roconnor> Anyone here have wine?
10:20:46 <roconnor> I prefer not to drink alone.
10:20:46 <ibid> i'm a cola guy myself
10:21:00 <sethk> roconnor, I have apple juice  :)
10:21:01 <roconnor> me too, but the wine is free.
10:21:05 <ibid> (oh, i thought you were talking about the nonemulator and decided to be smartass)
10:21:10 <ibid> (darn:)
10:21:13 <roconnor> ;-)
10:21:13 <SyntaxNinja> Igloo: any changes to the debian HC&R thingy?
10:21:14 <paolino_> is there some more help on the zipper out of what it's in the wiki ?
10:21:35 <paolino_> roconnor, I have wine here
10:21:53 <Igloo> What does it say now?
10:21:55 <roconnor> good, shall we drink together?
10:22:02 <paolino_> yep
10:22:09 <paolino_> zip
10:22:24 <roconnor> Perhaps a toast to something.
10:22:53 <paolino_> my parent was the great Veronelli now dead :/
10:22:56 <Lemmih> SyntaxNinja: No, it's fine.
10:23:27 <roconnor> Veronelli?
10:24:17 <paolino_> Luigi Veronelli one of the best wine intendor on this planet surface
10:24:39 <roconnor> sethk, you can drink with us too, even if it is only juice.
10:24:58 <SyntaxNinja> Igloo: it says what it said last time
10:24:58 <MarcWebe1> basti_: ibid with this function type definition "isJustOrNothing:: Maybe Int -> IO()" it works.
10:25:01 <SyntaxNinja> @wiki hcnr
10:25:01 <lambdabot> http://www.haskell.org/hawiki/hcnr
10:25:02 <roconnor> paolino_, I suspect your wine is better than what I got.
10:25:09 <basti_> MarcWebe1: yes
10:25:17 <MarcWebe1> Waht is wrong with this:  isJustOrNothing:: (show a) => Maybe a -> IO()
10:25:20 <SyntaxNinja> @hcnr
10:25:21 <lambdabot> Unknown command, try @listcommands.
10:25:22 <MarcWebe1> big s
10:25:32 <roconnor> Domaine de saint-lannes 2004
10:26:16 <paolino_> and a revolutionary guy , he brought a TIR of wine to the Genova fighters some time ago on the G8
10:26:29 <MarcWebe1> basti_: ?
10:26:33 <basti_> MarcWebe1: there is nothing inherently wrong
10:26:36 <basti_> do you know what this means?
10:26:47 <roconnor> Genova fighters?
10:26:56 <paolino_> black block
10:27:14 <syntaxfree> @seen dons
10:27:14 <lambdabot> dons is in #haskell-overflow, #haskell-blah and #haskell. I don'
10:27:14 <lambdabot> t know when dons last spoke.
10:27:19 <roconnor> ah
10:27:29 <roconnor> where was the G8?  Montreal?
10:27:40 <paolino_> Genova
10:27:46 <MarcWebe1> basti_: Ups. you are right but Why doesn't it work with my isJustOrNothing Nothing line?
10:27:46 <roconnor> oh yes
10:27:48 <roconnor> duh
10:28:05 <basti_> MarcWebe1: it does have to do with that type. what does the part before => mean?
10:28:16 <paolino_> @seen xerox
10:28:17 <lambdabot> xerox is in #haskell-overflow, #haskell-blah and #haskell. I
10:28:17 <lambdabot> don't know when xerox last spoke.
10:28:29 <roconnor> sound like my kind of man.
10:28:37 <roconnor> shall we drink to him?
10:28:42 <paolino_> sure
10:28:57 <roconnor> Prima
10:29:07 <paolino_> Salute
10:29:23 <MarcWebe1> That I want the not existing Just *X* value beeing an instance of show to be able to use my function?
10:29:49 <MarcWebe1> because the Just _X_ value isn't used anyway?
10:29:54 <basti_> MarcWebe1: uhm. kinda, yes. ^^
10:30:20 <MarcWebe1> basti_: How to write my isJustOrNothing function to make it compile ?
10:30:47 <basti_> its not a problem of your function
10:30:59 <basti_> most of the time, the type inside maybe would be fixed, so that it works.
10:32:44 <{Arias}> how can i read a file and apply the lines function in the same line?
10:32:59 <basti_> using >>=
10:33:05 <{Arias}> how? :P
10:33:18 <basti_> mm wait
10:33:21 <{Arias}> readFile >>= lines doesnt work
10:33:24 <MarcWebe1> All I want is a function printing "Just<x value" or "Nothing" depending on the Maybe <whatsoever datatype/class instance you can think of if it's inheriting show>
10:33:36 <paolino_> is the Zipper interesting  for anyone but me ?
10:33:40 <MarcWebe1> value
10:33:56 <MarcWebe1> paolino_: What's it about?
10:34:09 <roconnor> print?
10:34:13 <roconnor> @type print
10:34:14 <lambdabot> forall a. (Show a) => a -> IO ()
10:34:21 <basti_> MarcWebe1: you have got that already
10:34:33 <paolino_> I need a function to exchange 2 Loc
10:34:44 <paolino_> I can't grasp it
10:34:51 <roconnor> Loc?
10:35:18 <paolino_> locations in the zipper nomenclature
10:35:27 <roconnor> Prelude> print (Just "hello")
10:35:29 <roconnor> Just "hello"
10:35:31 <roconnor> Prelude> print (Nothing)
10:35:33 <roconnor> Nothing
10:35:42 <basti_> {Arias}:  (readFile "test") >>= (\x->return lines)
10:35:43 <basti_> works
10:35:48 <{Arias}> :)
10:35:49 <basti_> there should be some lift that does that though
10:35:52 <{Arias}> thnaks a lot
10:36:33 <basti_> uhm
10:36:36 <basti_> no it doesnt work
10:36:38 <roconnor> Hmmm, my wine actually tastes pretty good.
10:36:51 <basti_> return $ lines x
10:36:59 <basti_> @pl \x->return $ lines x
10:37:00 <lambdabot> return . lines
10:37:02 * ibid tastes powerade
10:37:04 <basti_> ^^
10:37:06 <MarcWebe1> basti_: http://www.rafb.net/paste/results/q4iIl452.html
10:37:39 <roconnor> wow, that @pl is pretty powerful
10:37:42 <ibid> which should be introduced first?  infinite data structures or higher-order functions?
10:37:42 <roconnor> @wow
10:37:43 <lambdabot> I left my WALLET in the BATHROOM!!
10:38:01 <roconnor> higher-order functions.
10:38:05 <basti_> MarcWebe1: you can't help the error without a type annotation. it will not happen usually. usually, you know exactly which type is in the Maybe. Just not in this case
10:38:08 <MarcWebe1> lambdabot: Go and fetch it ;)
10:38:13 <{Arias}> yeah basti_, thanks
10:38:32 <ibid> roconnor: why?
10:38:34 <basti_> so readFile "test" >>= return . lines  (of course
10:39:06 <roconnor> I don't know.  Because they are more fundamental?
10:39:16 <roconnor> More important.
10:39:19 <ustenzel> {Arias}: lines `liftM` readFile "test"
10:39:54 <ibid> well, you don't need HOFs for infinite data, or do you?
10:40:26 <roconnor> MarcWebe1, I see the problem.
10:40:37 <roconnor> oh
10:40:43 <roconnor> and basti_ explained it.
10:41:50 <syntaxfree> @pl f x y = filter (==x) y
10:41:51 <lambdabot> f = filter . (==)
10:42:09 <syntaxfree> @pl f x y = filter (>x) y
10:42:09 <lambdabot> f = filter . flip (>)
10:42:24 <syntaxfree> what's the definition of flip?
10:42:46 <int-e> flip f a b = f b a
10:43:18 <syntaxfree> hmm. a and b are arguments for flip.
10:43:19 <syntaxfree> so,
10:43:23 <int-e> flip (>) == (<)
10:43:28 <syntaxfree> @eval flip (**) 2 5
10:43:30 <lambdabot> 25.0
10:43:33 <syntaxfree> good!
10:43:41 <syntaxfree> I appreciate that. Thanks.
10:43:50 <syntaxfree> @fact-set flip f a b = f b a
10:43:51 <lambdabot> Fact recorded.
10:43:54 <[Bobl]> whois bobl
10:46:21 <MarcWebe1> roconnor, basti_  isJustOrNothing ((\x::(Maybe Int) -> x) Nothing)  *bg*
10:48:21 <ulph> we need..... lambdabot! :)
10:48:45 <basti_> MarcWebe1: yes that "fixes" it
10:48:55 <basti_> it won't work on isJustOrNothing "hi" though
10:49:15 <MarcWebe1> I know *scream* ;)
10:49:48 <basti_> as i said, usually you'll call this inside a function where the type of the parameter is known
10:50:03 <basti_> like: isJustOrNothing a
10:50:16 <basti_> where a has been passed and is known to Show (otherwise you couldnt call)
10:50:29 <MarcWebe1> basti_: haskell is an academical language, isn't it? So it shouldn't be too uncommon to do unusual things :)
10:50:39 <basti_> well you can do that
10:50:44 <basti_> you just need to give a type
10:50:50 <basti_> (Nothing :: Maybe Int) for example
10:50:54 <basti_> that's no Int
10:50:59 <MarcWebe1> Thanks!
10:52:09 <basti_> maybe you could even say that it's no showable a
10:52:23 <MarcWebe1> I didn't see that before.
10:52:45 <basti_> its the easy way out. but trust me, in this situation, in larger programs, you won't have a problem
10:54:19 <MarcWebe1> I accept that/ believe that, too bye
10:56:16 <SamB> huh, I'm not sure i've seen academic used in such a positive sense of a programming language before...
10:56:33 * basti_ laughs
11:01:10 <thedward> @pl f x y = ( x * 5 ) + ( y * 2 )
11:01:11 <lambdabot> f = (. (2 *)) . (+) . (5 *)
11:10:22 <syntaxfree> @fact welfare
11:10:23 <lambdabot> welfare: The concept of wealth redistribution fails to understand
11:10:23 <lambdabot> that even if $1 trillion from the 225 richest people in the
11:10:23 <lambdabot> world were redistributed to the poorest of the earth, this
11:10:23 <lambdabot> would only give them $1 a day for a year. Our focus should be
11:10:23 <lambdabot> on underlying structural changes and the advancement of
11:10:25 <lambdabot> capitalism such that wealth can be created for the poor on a
11:10:27 <lambdabot> sustained basis..
11:11:56 <rodador> uh!? :-)
11:12:25 <roconnor> doesn't that double the income of the poorest people on the earth/
11:13:53 <ibid> well, the solution is, of course, to kill 99.999 % of world population and *then* redistribute the wealth ;)
11:14:26 <roconnor> which 99.99 % ?
11:14:36 <basti_> the solution is, killing the richest 1% and redistribute their wealth
11:14:44 <basti_> fewest kills, best redistribution
11:15:24 <ibid> roconnor: not 99.99 but 99.999, increases the spoils :)
11:15:45 <ibid> roconnor: obviously the 99.999 % that does not include me :)
11:16:27 <ibid> basti_: your method gives a lousy profit
11:16:49 <roconnor> The Triumph of Hope over Self-Interest
11:16:51 <basti_> enough for everyone probalby
11:16:56 <roconnor>     Nineteen percent of Americans say they are in the richest 1 percent and a further 20 percent expect to be someday.
11:17:40 <ibid> most drivers know they are above average
11:17:58 <ibid> (i suppose that means that the below average drivers are abysemal[sp?]:)
11:18:32 <jyp> Welcome to the New World Order
11:18:35 <roconnor> aren't you comparing means and modes there?
11:19:04 <roconnor> or meadiants.
11:19:12 <roconnor> It's been a while since I've done grade 6 math.
11:19:20 <ibid> roconnor: if most specimens are above average, that means that the minority that's below average are much worse than the majority are better
11:19:26 <jyp> @fact fact
11:19:26 <lambdabot> I know nothing about fact.
11:19:43 <roconnor> I could believe that for driving.
11:19:46 <jyp> They you should STFU
11:20:04 <jyp> , lambdabot
11:20:48 <ibid> basti_: your solution is also wasteful,  just redistribute that wealth, no need to kill them :)
11:21:05 <basti_> but the wealthy would complain
11:21:25 <pesco> You can just tell them give or die...
11:21:43 <basti_> hmm
11:21:47 <ibid> basti_: even the rest will complain that they got too little
11:22:21 <dcoutts_> xerox, ping
11:22:28 <dcoutts_> ibid, ping
11:22:38 <dcoutts_> ibid, oh there you are :-)
11:22:57 <ibid> dcoutts_: you're such a blind person ;)
11:23:11 <dcoutts_> heh
11:23:23 <ibid> (no offense intended to blind people:)
11:23:36 <dcoutts_> ibid, ahch, I can't send you private messages since this nick is unregistered
11:23:38 <{Arias}> is there a function to apply another function to something a number of times?
11:23:55 <dcoutts_> ibid, I was going to send you the link to the FP practical I'm running on Monday
11:23:59 <ibid> dcoutts_: are you on oftc or ircnet?
11:24:30 <dcoutts_> ibid, I'm off home now anyway and my "dcoutts" nick is registered so I'll be able to talk to you privately when I get back.
11:24:48 <dcoutts_> ibid, I don't want my students seeing the practical early :-)
11:24:56 * dcoutts_ goes home
11:25:04 <basti_> you could make a channel
11:25:08 <ibid> paste it there :)
11:25:09 <ibid> i just did
11:25:13 <roconnor> {Arias} I'm constantly looking for that one, but it is never in the Prelude
11:25:30 <ibid> @type iterate
11:25:31 <lambdabot> forall a. (a -> a) -> a -> [a]
11:25:44 <dcoutts_> ibid, I'll talk when I get home. I'll be about 15 min.
11:25:53 <{Arias}> thanks
11:25:54 <basti_> @plugs (iterate (+5) 0) !! 10
11:25:55 <lambdabot> 50
11:26:00 <{Arias}> :)
11:26:01 <pesco> I say we should learn from Diablo and the rest of the collect-all-items games... These people spend humungous amounts of effort to earn a few bits in a savegame. We can distribute food, wares, and whatnot for nothing, just set up some game servers in a vault and somehow link the achievment of items and other cool virtual stuff people can show off with to the production of goods.
11:26:06 <roconnor> it should be called Church.
11:26:09 <roconnor> church.
11:26:16 <ibid> dcoutts_: ok
11:27:38 <rodador> any comments about this book: http://www.haskell.org/soe/ ?
11:28:13 <SyntaxNinja> rodador: my comments here: http://books.slashdot.org/article.pl?sid=04/03/12/221232
11:28:15 <rodador> oh, it's got an entry on /.
11:29:08 * rodador reads /. where everything can (or will can) be found
11:29:27 <{Arias}> well, i was doing the strpos function... i have made this: strpos char str index = if str !! index == char then index else strpos char str ( index + 1 )
11:29:33 <{Arias}> is there another way to do it?
11:29:39 <{Arias}> i'm learning x)
11:30:11 <Speck> @karma+ _astrolabe
11:30:12 <lambdabot> _astrolabe's karma raised to 1.
11:30:24 <ibid> there's always another way
11:30:25 <SyntaxNinja> @karma SyntaxNinja
11:30:26 <lambdabot> You have a karma of 0
11:30:30 <xerox> dcoutts_: pong!
11:30:33 <SyntaxNinja> all my work for nothing
11:30:33 <pesco> @karma pesco
11:30:34 <lambdabot> You have a karma of 0
11:30:34 <basti_> @type takewhile
11:30:35 <lambdabot> Not in scope: `takewhile'
11:30:35 <{Arias}> yes, sure
11:30:36 <roconnor> @type List.findIndex
11:30:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
11:30:37 <basti_> hmm
11:30:37 <flux__> @karma flux__
11:30:38 <lambdabot> You have a karma of 0
11:30:44 <sansucre> rodador: I found soe fun to read but not well organized
11:30:47 <flux__> I think the tracking is lacking ;(
11:30:50 * pesco frowns.
11:30:52 <{Arias}> mmm
11:31:34 <{Arias}> thanks roconnor x)
11:31:47 <pesco> Hah, I've got a plugin idea... Let's reimplement Advogato in lambdabot!
11:31:52 <roconnor> @karma roconnor
11:31:53 <lambdabot> You have a karma of 0
11:31:58 <roconnor> :'(
11:32:01 <jyp> @karma+ SyntaxNinja
11:32:02 <lambdabot> SyntaxNinja's karma raised to 1.
11:32:03 <ibid> @karma ibid
11:32:04 <lambdabot> You have a karma of 0
11:32:08 <ibid> yeah!
11:32:12 <pesco> Karma frenzy!
11:32:13 <ibid> i used to have negative karma :)
11:32:17 <roconnor> @karma+ roconnor
11:32:17 <lambdabot> You can't change your own karma, silly.
11:32:23 <roconnor> figures
11:32:30 <rodador> does lambdabot support priv msgs ?
11:32:36 <pesco> Yes.
11:32:43 <roconnor> it's encouraged
11:32:59 <rodador> so priv-msg it, don't flood }:-)
11:33:47 <rodador> (next lambdabot priv msg: #karma- rodador) hehe
11:33:48 <{Arias}> lambdabot  forall a. (a -> Bool) -> [a] -> Maybe Int
11:33:52 <{Arias}> maybe int?
11:34:02 <roconnor> it may not be in the list.
11:34:43 <{Arias}> @eval List.findIndex (== 'o') "hello"
11:34:45 <lambdabot> Just 4
11:34:52 <{Arias}> "Just 4"?
11:35:09 <pesco> @eval List.findIndex (=='o') "bar"
11:35:10 <lambdabot> Nothing
11:35:26 <roconnor> @eval Maybe.fromJust $ List.findIndex (== 'o') "hello"
11:35:28 <lambdabot> 4
11:35:28 <{Arias}> yes, and if i want only 4, no "just 4" ?
11:35:37 <{Arias}> :D
11:35:43 <roconnor> fromJust is kinda bad programming style.
11:35:55 <SyntaxNinja> fromJust should DIE
11:35:56 <{Arias}> @eval Maybe.fromJust $ List.findIndex (== 'x') "hello"
11:35:58 <lambdabot> Maybe.fromJust: Nothing
11:36:02 <roconnor> but good programming style is a little advanced.
11:36:14 <basti_> Maybe just means that there might be no result
11:36:17 <pesco> {Arias}: fromJust is fine, as long as you can prove it will never get Nothing. ;-)
11:36:22 <jyp> would be ok if exception was properly reported, imho
11:36:22 <basti_> which can happen in some situations
11:36:31 <basti_> the exception IS reported ^^
11:36:31 <{Arias}> xDD
11:36:37 <basti_> @eval fromJust Nothing
11:36:38 <lambdabot> Add a type signature
11:36:41 <basti_> hm
11:36:45 <basti_> @eval fromJust (Nothing::Maybe Int)
11:36:46 <lambdabot> Maybe.fromJust: Nothing
11:36:47 <jyp> basti_, but not properly
11:36:48 <roconnor> *lol*
11:36:50 <basti_> ^^
11:36:59 <SyntaxNinja> maybe I could accept fromJust :: ErrorString -> Maybe a -> a
11:37:09 <roconnor> didn't we /just/ have this discussion
11:37:32 <rodador> (not trolling) isn't an imperative solution to "findIndex" better?
11:37:33 <SyntaxNinja> roconnor: the other day, yeah
11:37:35 <jyp> @karma- jyp
11:37:36 <lambdabot> You can't change your own karma, silly.
11:37:57 <roconnor> rodador, I don't see how.
11:38:12 <rodador> roconnor: well, not better.. more efficient?
11:38:32 <rodador> roconnor: (just asking, i'm totally ignorant about haskell internals)
11:39:03 <{Arias}> xD
11:39:04 <roconnor> findIndex is O(n) in all cases.
11:39:20 <roconnor> I hear it is faster on a quantum computer.
11:39:26 <rodador> yes, but doesn't recursion add a little overhead?
11:39:43 <rodador> haha, probably :-)
11:39:58 <ibid> rodador: depends on what kind of recursion it is
11:40:07 <ibid> rodador: some recursion types are as good as loops
11:40:13 <ibid> rodador: (or rather, *are* loops)
11:40:17 <rodador> aha, so it's that tail recursion thing I heard about ?
11:40:21 <ibid> yeah
11:40:27 <rodador> so the interpreter can optimize that case
11:40:29 <rodador> ok, thanks
11:40:36 <ibid> though laziness mixes that can of worms somewhat
11:40:46 <roconnor> modern implemenations do things like call with continuations, and graph reduction, and other crazyness.
11:42:06 <roconnor> Haskell 'the least-broken programming language available today.'
11:42:31 <roconnor> me was quoting the slashdot article.
11:42:49 <rodador> http://en.wikipedia.org/wiki/Continuation#Programming_language_support
11:43:14 * SamB notices that GHC rewrites main to catch exceptions
11:44:18 <syntaxfree> what are your opinions on Icon?
11:45:13 <roconnor> rodador, you can complie functional code so that no function calls ever return by chaining continuations.
11:45:18 <roconnor> thus no stack is needed.
11:45:49 <ibid> (which is often the opposite of what is needed:)
11:46:32 <rodador> recursion without stacks? wait some hours for me to asimilate that :-D
11:46:39 <SamB> roconnor: but that would probably be a bit silly...
11:47:05 <roconnor> SamB, I understood it to be a common compolation technique.
11:47:20 <roconnor> although not in the context of laziness
11:48:15 <rodador> well, for now i've enough with tail recursion :)
11:48:35 <roconnor> I always assume Prelude functions are fast.
11:48:49 <roconnor> who knows how they are actually implemented.
11:48:53 <syntaxfree> I always assume functions are fast.
11:49:22 <SamB> roconnor: well, you could pretend they are actually implemented the way they look in the source...
11:49:30 <rodador> yes, i referred to a self-made findIndex
11:51:36 <kzm_> Good evening!
11:54:01 <roconnor> @karma +kzm_
11:54:01 <lambdabot> +kzm_ has a karma of 0
11:54:09 <roconnor> @karma+ kzm_
11:54:10 <lambdabot> kzm_'s karma raised to 1.
12:01:29 <{Arias}> @karma+ lambdabot
12:01:30 <lambdabot> lambdabot's karma raised to 4.
12:01:39 <{Arias}> :P
12:02:47 <rodador> gonna eat something
12:04:07 <syntaxfree> @fact lambdabot
12:04:08 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is
12:04:08 <lambdabot> female..
12:08:10 <thedward> @karma- thedward
12:08:11 <lambdabot> You can't change your own karma, silly.
12:09:13 <_astrolabe> can you remove someones karma?  karma wars?
12:09:19 <thedward> @index faststring
12:09:20 <lambdabot> bzzt
12:09:26 <xerox> @where fps
12:09:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
12:09:28 <thedward> @hoogle faststring
12:09:29 <lambdabot> Terminated
12:09:29 <lambdabot>  
12:09:34 <xerox> ^- FastPackedString ?
12:10:06 <thedward> just seeing what lambdabot has indexed
12:10:13 <roconnor> " Here's a simple C function which finds the inverse of a permutation, in linear time."
12:10:39 <roconnor> I bet there is a way to invert a permulation represented as [Integer] in linear time.
12:12:12 <_astrolabe> roconnor: I think your'e right
12:12:36 <roconnor> somehow I think we ought to be able to tie the knot.
12:12:43 <roconnor> ooooh, too much wine.
12:20:05 <xerox> Does 'let .. in let .. in let .. in' sequence evaluation?
12:20:32 <dcoutts> xerox, no
12:20:34 <liyang> ?
12:20:36 <liyang> No?
12:20:37 <dcoutts> that's all lazy
12:20:41 <xerox> Right.
12:20:43 <xerox> seq.
12:21:02 <dcoutts> in ML it would because in ML let is strict
12:22:27 <xerox> Maybe with $!, too..
12:22:30 <xerox> @type ($!)
12:22:31 <lambdabot> forall b a. (a -> b) -> a -> b
12:22:48 <dcoutts> well the $! is for strict application of a function
12:24:36 <xerox> I need something to do:
12:24:39 <xerox> toTop . modify (const t1) . navigate p2 . toTop . modify (const t2) . navigate p1
12:25:10 <rodador> re
12:25:27 <xerox> In order.
12:25:37 <dcoutts> xerox, ? I don't follow
12:26:17 <xerox> Let me think more...
12:29:26 <rodador> we have "f x y :: x -> y -> Int", but the reduction is done currying, or "x" and "y" simultaneously?
12:29:59 <neologism> currying I think
12:30:18 <rodador> s/f x y ::/f ::/
12:32:32 <rodador> maybe it depends on the interpreter/compiler you use
12:32:59 <machack666> is the ordering elems of Data.Array.assocs predicatable?
12:33:20 <neologism> rodador: try
12:33:27 <neologism> (f value1) value2
12:34:15 <nuffer> can anyone point me to a good tutorial on writing monads?
12:34:29 <nuffer> combinators, I believe, I'm looking for?
12:34:35 <rodador> neologism: that's manual currying, isn't it?
12:35:00 <neologism> yes
12:35:16 <neologism> I believe thathaskell evaulation is done by currying every time
12:35:21 <rodador> neologism: i refer if when you input something like "(+) 2 2", Haskell does "((+) 2) 2"
12:35:29 <machack666> @eval let a = Data.Array.array (1,10) [(i,i) | i<-[1..10]] in Data.Array.assocs a
12:35:30 <lambdabot>  Not in scope: `Data.Array.assocs'
12:35:42 <machack666> @eval let a = Data.Array.array (1,10) [(i,i) | i<-[1..10]] in assocs a
12:35:42 <lambdabot>  Not in scope: `assocs'
12:36:03 <machack666> @help
12:36:04 <lambdabot>  @help <command> - ask for help for <command>
12:36:14 <neologism> jesus
12:36:20 <neologism> its impossible to google for "haskell curry
12:36:21 <neologism> its impossible to google for "haskell curry"
12:36:25 <neologism> cause its name of a person :)))
12:38:11 <rodador> lol: http://www.willamette.edu/~fruehr/haskell/evolution.html
12:38:59 <neologism> never seen that?
12:39:32 <rodador> nope
12:39:44 <rodador> i'm newbie :P
12:39:56 <rodador> have to learn some haskell for the uni
12:40:06 <SamB> is there an option to dump the final core, only prettily?
12:43:13 <ezra_> roconnor, when you come back: you should be able to invert a permutation as [Integer] in linear time using bucket sort
12:44:05 <machack666> nuffer: have you seen the nomaware site?
12:45:26 <nuffer> nooo
12:46:02 <machack666> http://www.nomaware.com/monads/html/ may have some useful information for you
12:49:30 <nuffer> is there any function that like "getVals :: [Maybe a] -> [a]" that pulls out all "Just x" and puts them in a list?
12:52:06 <machack666> catMaybe(s)
12:52:07 <gzl> nuffer: I don't think so, but you could do f = (map fromJust) . (filter (/= Nothing)) or something
12:52:12 <machack666> not sure of the presence of s
12:52:16 <machack666> need to import Data.Maybe
12:52:18 <gzl> hmm.
12:52:27 <gzl> oh, nice.
12:52:42 <ibid> "a lisp programmer knows the value of everything and the cost of nothing" - alan perlis "well, a haskell implementor knows the cost of Nothing" - ibid~
12:52:46 <machack666> there's a lot of good stuff in Data.Maybe that I just learned about :)
12:53:01 <gzl> yeah, there are even good things in the Prelude that I forget about sometimes
12:53:20 <thedward> @hoogle [Maybe a] -
12:53:21 <lambdabot> Terminated
12:53:21 <lambdabot>  
12:53:31 <thedward> @hoogle [Maybe a] -> [a]
12:53:33 <lambdabot> Terminated
12:53:33 <lambdabot>  
12:53:39 <gzl> what's @hoogle?
12:53:40 <thedward> is hoogle just broken?
12:54:02 <machack666> haskell google ?
12:54:07 <gzl> oh, good call.
12:54:26 <thedward> http://www-users.cs.york.ac.uk/~ndm/hoogle/
12:54:28 <xerox> @index fix
12:54:29 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer,
12:54:29 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
12:54:29 <lambdabot> Control.Monad.Error
12:54:34 <xerox> @type Control.Monad.Fix.fix
12:54:35 <lambdabot> forall a. (a -> a) -> a
12:54:44 <xerox> Hmpf...
12:54:47 <thedward> you can search by type signature. which is neat
12:55:00 <gzl> oh, nice
12:55:02 <ibid> @fix hoogle
12:55:03 <lambdabot> Unknown command, try @listcommands.
12:55:06 <ibid> darn
12:55:11 * thedward snorts
12:55:17 <thedward> @help hoogle
12:55:17 <lambdabot>  @hoogle <expr>, Haskell API Search for either names, or types.
12:55:23 <thedward> @hoogle map
12:55:24 <lambdabot> Terminated
12:55:24 <lambdabot>  
12:55:39 <gzl> ok, it seems like it's not working.
12:55:47 <thedward> well, you can use the web version
12:55:53 <Cale> @hoogle (a -> b) -> ([a] -> [b])
12:55:54 <lambdabot> Terminated
12:55:54 <lambdabot>  
12:55:57 <xerox> Does Google still return not Haskell's hoogle on search?
12:55:59 <xerox> @google hoogle
12:56:01 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/hoogle/
12:56:06 <xerox> No!  Cool.
12:56:30 <gzl> zvon is so handy.
12:57:18 <Cale> http://www.haskell.org/hoogle/
12:58:52 <thedward> @eval mapMaybe (`lookup` [('a',"AAA"),('b',"BBB"),('c',"CCC")]) "acfg"
12:58:53 <lambdabot> ["AAA","CCC"]
12:59:31 <thedward> @eval mapMaybe (flip lookup [('a',"AAA"),('b',"BBB"),('c',"CCC")]) "acfg"
12:59:33 <lambdabot> ["AAA","CCC"]
13:06:07 <rodador> bye
13:06:10 <machack666> @google nomaware
13:06:12 <lambdabot> http://www.nomaware.com/monads/html/
13:06:51 <machack666> does lambdabot screenscrape, or does it have a web services hook?
13:07:06 <vegai> screenscrape?
13:07:23 <machack666> parse the output of the raw html from searching google
13:11:10 * machack666 checks out the lambdabot source...
13:14:33 <machack666> later
13:16:44 <JohnMeacham> So I was reading http://www.eecs.harvard.edu/~nr/pubs/embed-abstract.html and wondering if anyone has done similar work for haskell? (codewise or paperwise)
13:18:52 <dcoutts> JohnMeacham, sounds interesting
13:20:58 <JohnMeacham> Yeah, his ideas will obviously work in haskell. but with the power of rank-n types GADTs and type classes, it seems that one should be able to  improve on things.
13:21:21 <JohnMeacham> except for threading a monad around since lua is stateful.
13:23:48 <JohnMeacham> BTW, I have a feeling my Grin representation (which my message to ghc-list has a crash-course intro to) could be improved via use of GADTs, but it is only a vauge feeling with no actual meat to it... if anything pops out to the GADT experts out there then let me know.
13:24:26 <dcoutts> JohnMeacham, the darcs folk had a good GADT session and worked some stuff out
13:24:41 <dcoutts> that was at ICFP this year
13:26:38 <JohnMeacham> ah. yeah, I remember talk on the mailing list about them. I will dig through the archives.
13:28:17 <integral> is ghc-list glasgow-haskell-users?
13:28:22 <dcoutts> yep
13:28:35 <integral> thanks :)
13:29:55 * xerox cool snippet of the night
13:29:57 <xerox> crawl :: Path a -> Loc a -> Loc a
13:29:57 <xerox> crawl (L p _ _) = crawl p . left
13:29:57 <xerox> crawl (R _ _ p) = crawl p . right
13:30:01 <xerox> crawl (Top) = id
13:36:42 <franka> Hi, all.
13:36:50 <franka> Hi, all.
13:36:56 <franka> Oops.  heh
13:37:03 <JohnMeacham> Hi, you.
13:37:04 <integral> hehlo
13:37:17 <franka> That second one was supposed to go to #haskell-blah.
13:37:24 <poetix> There was me thinking, "goodness, is that Frank Atanassow", and so it turned out to be. Hi.
13:37:41 <franka> Yes, in the virtual flesh.
13:37:52 <franka> Do I know you?
13:38:02 <poetix> Dominic from LtU
13:38:18 <franka> Ah yes, Dominic.  How are you today?
13:38:41 <poetix> Worryingly close to being 31 years old.
13:39:04 <franka> Ah, I know that feeling.
13:39:23 <franka> Being worryingly close to 32 years old, as I am.
13:40:23 <franka> So when should I wish you a happy birthday?
13:40:34 <poetix> This Sunday
13:40:54 <franka> Yeah, you're right on the edge, aren't you?
13:41:04 <franka> It's all downhill from here.
13:41:16 <franka> Soon you will get old and gray and decrepit.
13:41:18 <poetix> That's what they told me last year.
13:41:44 <poetix> I hope to pass through "distinguished" before I reach "decrepit".
13:42:12 <franka> Best make a U-turn before either.
13:42:37 <poetix> Although I have as yet no notion of what I might possibly do to earn distinction. I suppose I could set up a puppy rescue charity.
13:43:28 <franka> When I think of "distinguished" gentlemen, I don't usually picture them with puppies.  But, I guess it's worth a try.
13:44:04 <franka> You might experiment with a smoking jacket and glass of cognac, though.
13:44:32 <franka> And assemble a bunch of old stories about how it was much worse when you were a young'un.
13:45:09 <franka> "In my day, we had get up, SIX HOURS before we even went to sleep...!"
13:45:31 <neologism> lol
13:46:34 <franka> That was, of course, ripped from Monty Python.
13:46:53 <poetix> I do feel like that most days. I'm convinced that sleep gnomes are stealing my sleeping hours, and replacing them with stressful moments from someone else's life.
13:47:13 <poetix> Maybe that's only fair - maybe they give me sleep to that someone else, who needs it more than I do.
13:47:20 <araujo> Hello!
13:47:49 <franka> Hi, araujo.
13:48:00 <araujo> Hello franka
13:49:07 <poetix> I am having a bit of a headache at the moment caused by over-reliance on reflection (in C#) in my day-job.
13:50:25 <franka> What are you using it for?
13:50:42 <poetix> Writing plug-ins for a custom server
13:51:11 <poetix> The headache isn't in my work, where I have access to reflection and use it quite cheerfully; it comes when I try to think about how to do similar things in Haskell
13:51:12 <Wasp> hi, can anybody explain ">>" in a short why (know, that it should do the same as semicolon in pascal)
13:51:37 <araujo> >> is a monadic operator.
13:51:48 <poetix> It can be derived from >>=
13:51:51 <Wasp> hmm .. that means?
13:52:03 <poetix> @type >>
13:52:04 <lambdabot> parse error on input `>>'
13:52:06 <JohnMeacham> a >> b  is equivalant to a >>= \_ -> b   as in, it is normal monadic bind, that throws away the result of the previous computation.
13:52:11 <poetix> @type (>>)
13:52:12 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
13:52:31 <poetix> @type (>>=)
13:52:32 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m
13:52:32 <lambdabot> b
13:54:27 <poetix> You can think of >>= as extracting a value of type a from the monad m, and passing it to a function of type a -> m b to get a value of type b in the monad m
14:03:15 <franka> I've been reading about delimited continuations.
14:03:22 <xerox> Cool.
14:03:27 <poetix> Oh, good. Do you understand them?
14:03:50 <franka> I understand the concept.  I don't entirely understand the calculi.
14:04:04 <xerox> fib n = reset ((+) (shift (\k -> if n > 0 then k (fib (n-1)) else 1)) (shift (\k -> if n > 1 then k (fib (n-2)) else 1)))
14:04:09 <xerox> ^___^
14:05:26 <franka> Hm... (trying to make sense of this)
14:05:29 <poetix> I can't get my head round them in practice. The concepts seem fundamentally simple, but bogglesome when you try to apply them.
14:06:05 <franka> Yes, that's partly why I am interested in the type systems.
14:06:29 <franka> It tends to help you organize things in your head if you know the types and why they are what they are.
14:07:10 <poetix> Yes - then you're dealing with jigsaw pieces, rather than just spaghetti
14:07:33 <poetix> (remembering jigsaw puzzles where the picture was a plate of spaghetti)
14:07:57 <franka> But that Fibonacci definition looks like a good example.  I haven't seen any examples where delimited continuations are actually essential and call/cc alone won't do.
14:08:47 <xerox> How does them differ from normal puzzles?
14:09:29 <xerox> franka: I did it after a night of #haskell-overflow talking on them with ski and TheHunter! :)
14:09:39 <xerox> I had other examples, hhmmm.
14:09:53 <poetix> Jigsaw puzzles are puzzles where every piece has four edges, and every edge has a uniquely shaped connector
14:10:25 <xerox> fact n = reset ((*) (shift g) n) where g k | n <= 0 = 1 | otherwise = k (f $ n - 1)
14:11:27 <franka> Why do you want to use them for factorial?
14:11:35 <poetix> I get into enough trouble just playing with call/cc in Scheme...
14:11:49 <xerox> That was the first one I did, in trying to understand.
14:11:56 <franka> I see.
14:12:02 <xerox> Though it probably is ok to think about it continuationally.
14:12:30 <xerox> They invert control, making the code local, but I'm too sleepy to talk properly about composable continuations.
14:12:38 <franka> Oh, hm.  That definition is not recursive.
14:13:05 <xerox> It is
14:13:06 <franka> And f is unbound.
14:13:10 <rep> "factorial is like 'hello world', in haskell"
14:13:19 <xerox> f is fact, sorry.
14:13:25 <franka> OK.
14:13:48 <poetix> xerox: Can you break it down for me?
14:14:31 <xerox> poetix: what exactly?
14:14:48 <poetix> The factorial example. I'm being lazy here...
14:15:43 <poetix> Actually, I'm not that lazy - I think I can see how it works now
14:15:47 <Cale> Let S be a topological space. Then a jigsaw puzzle for S is a set of open subsets of S called pieces such that the union of the closure of the pieces is S, and for any two pieces p and q, either p = q, or p and q are disjoint.
14:15:58 <xerox> poetix: The continuation of (shift g) to the nearest reset in |reset ((+) (shift g) n)| is |\x -> (+) k n|
14:15:58 <poetix> lol
14:16:16 <Cale> heh, maybe we should insist that the closure of a piece is compact :)
14:16:20 <franka> hah, show-off.
14:16:32 <lightstep> Cale, probably not
14:16:43 <lightstep> infinite pieces are fun
14:16:58 <Cale> :)
14:17:02 <lightstep> plus, you can compactify any space, so you don't gain anything
14:17:29 <xerox> poetix: then shift passes that function, let's call it k, to g.
14:17:55 <xerox> And then there was a step I don't recall now, like f (k f) or some permutation.
14:18:06 <poetix> Do-si-do
14:19:06 * poetix wonders if a topological description of jigsaw puzzles is possible that would capture the alternation of holes and connectors
14:19:24 <Cale> probably not purely topological
14:19:25 <franka> Anyway, concerning types of delimited continuations, there is a paper which introduces subtraction as the dual of the exponential (->) to handle them.
14:19:55 <xerox> franka: any link?
14:19:57 <poetix> And the url is...
14:19:59 <franka> It is much neater than the attempts to use effects systems.
14:20:05 <franka> OK, justasec.
14:20:33 <franka> http://www.cs.indiana.edu/~sabry/papers/contFoundationLong.pdf
14:20:36 <xerox> Then I really need sleep.
14:20:51 <franka> Zena M. Ariola and Hugo Herbelin and Amr Sabry. A Type-Theoretic Foundation of Delimited Continuations. (May 2005).
14:20:54 <kombinator> could anyone give a link to some intro to delimited continuations (in general)?
14:20:57 <xerox> Ah, Sabry again.
14:21:08 <xerox> I had get that, yeah :D
14:21:24 <dcoutts> @seen marcot
14:21:25 <lambdabot> I saw marcot leaving #haskell-overflow, #haskell-blah and #
14:21:25 <lambdabot> haskell 4 hours, 10 minutes and 16 seconds ago.
14:21:26 <franka> Look in the bibliography, kombinator.
14:21:28 <poetix> Bookmarked, thanks
14:21:40 <franka> Interestingly, it also connects to dynamic scoping.
14:21:46 <franka> And state.
14:21:55 * poetix pricks up his ears
14:21:55 <kombinator> franka: ok, thanks
14:22:28 <xerox> OK, franka: I hope to talk about them with you again sometime.
14:22:43 <xerox> Goodnight, folks!
14:22:49 <franka> OK, xerox, seeya.
14:22:58 <thedward> @index reset
14:22:59 <lambdabot> Text.Html, Text.ParserCombinators.ReadPrec, Text.Read
14:23:27 <franka> Oleg, Ken Shan and Amr Sabry have a paper on it too: Oleg Kiselyov, Amr Sabry, and Chung-chieh Shan. Dynamic Scope and Delimited Continuations. July 2005.
14:23:33 <franka> Haven't read this one yet.
14:23:43 <franka> And there is a monadic framework for delimited continuations:
14:23:53 <franka> R. Kent Dybvig, Simon Peyton-Jones, and Amr Sabry. A Monadic Framework for Delimited Continuations.
14:24:00 <poetix> Got that one.
14:24:02 <franka> (This is a really interesting mix of authors, BTW.)
14:25:17 <poetix> Well, I have to go watch QI. If someone wakes shapr up, I'm sure he'll want to talk about delimited continuations and Oleg's Zipper...
14:25:29 <franka> Seeya, poetix.
14:29:43 <Cale> Oleg's Zipper?
14:29:56 <franka> Yeah, I was wondering about that too...
14:30:11 <Cale> It's just combinatorial differentiation
14:30:30 <Cale> it's been around for quite a long time :)
14:30:43 <Cale> probably a good deal longer than Haskell
14:30:47 <xerox> http://lambda-the-ultimate.org/node/view/1036
14:31:03 <franka> Huet's Zipper is well-known.  I dunno of Oleg's.
14:31:08 * xerox fades in the background again
14:31:53 <franka> Anyway, I would not say it is "just" differentiation.
14:32:22 <Cale> would you include the other movement operations?
14:32:23 <franka> Differentiation works on algebraic expressions.  The Zipper, in its general form, is a way of differentiating certain functors.
14:32:48 <Lemmih> nibro: ping.
14:33:18 <franka> My point is it's a generalization from functions to functors.
14:33:23 <Cale> combinatorial differentiation does too, in a sense -- though I probably wouldn't bother to refer to them as functors in the context that I'm familiar with it
14:33:37 <Cale> They'd just be called combinatorial sets
14:33:56 <Cale> differentiation is the operation which corresponds to differentiation of generating series
14:34:38 <franka> You are talking about species.  This is well-understood in the category Set, but not in general.
14:34:40 <Cale> well, it's not unique in that setting, but the one which is commonly used is exactly the one on functors
14:34:51 <franka> Joyal wrote a paper about it not long ago.
14:34:55 <Cale> yeah, some people formalise it that way
14:35:34 <franka> set-valued functors, I expect.
14:36:17 <franka> The question is what properties of Set are essential to differentiation.
14:36:37 <franka> But I dunno much about it, so I cannot say more.  This is how I understand it.
14:37:45 <Cale> Well, you can define the derivative on a set of combinatorial structures in any way that you like so long as for each object of weight n in the set, there are n objects of weight n-1 in the resulting set.
14:38:19 <Cale> But the easiest way is to decide on a way to delete some subobject of your combinatorial object which generates weight.
14:38:34 <Cale> For instance with graphs, this would generally be vertex deletion
14:38:48 <Cale> which takes edges along with it
14:39:27 <Cale> with naturals, you'd probably look at them as sums of 1's and delete a 1 in each possible way.
14:41:03 <franka> I think the question Joyal addresses is, what if you don't have a "set" of combinatorial structures, but something more abstract.
14:42:12 <franka> But I'm just guessing.
14:42:17 <Cale> in most of the practical cases I'm aware of, it amounts to the same thing, but yeah, I think so too :)
14:44:51 <franka> Hi, Eelco.
14:45:25 * SamB wishes for a way to dump the final core to file in pretty form
14:48:42 <franka> Well, I gotta go.
14:48:49 <franka> Bye, all.
14:49:01 <gzl> hey Cale, mind if I privmsg you?
14:49:28 <Cale> gzl: not at all :)
14:54:30 * Oejet is a bit drunk.
14:54:55 <Oejet> Don't drink while IRC'ing!
14:55:31 <lightstep> i saw john meacham say it once (while drunk on irc)
15:20:02 * dcoutts pushes hIDE updates
15:21:29 * Lemmih pulls.
15:22:10 * araujo dreams at having a better ide for haskell than emacs
15:22:24 * dcoutts sneakily gets Lemmih to test the latest Gtk2Hs release candidate by making hIDE depend on it
15:25:21 * Lemmih still can't run hIDE because of the trouble with ghc-6.5
15:26:14 * dcoutts is using 6.4.1
15:34:01 <ndm> shapr, ping
15:37:47 <ndm> i'm trying to setup hoogle on haskell.org, unfortunately my knowledge of apache is limited (to nothing, pretty much)
15:55:47 <Lemmih> dcoutts: You've got mail.
15:58:45 <dcoutts> Lemmih, thanks
15:59:32 <dcoutts> Lemmih, nice description :-)
16:00:01 <dcoutts> polymorphic
16:00:01 <dcoutts>  editor ?
16:00:35 <dcoutts> you mean the way it can have different editors based on the file name/type ?
16:01:06 <Wasp> is there a standard function to convert num to char?
16:01:13 <dcoutts> show ?
16:01:19 <dcoutts> @eval show 3
16:01:21 <lambdabot> "3"
16:01:57 <dcoutts> or perhaps you mean:
16:02:07 <Igloo> intToDigit
16:02:09 <dcoutts> @eval Char.chr 36
16:02:10 <lambdabot> '$'
16:02:11 <Lemmih> dcoutts: It can act like emacs, vim or anything else.
16:02:18 <dcoutts> Lemmih, ah ok
16:02:37 * dcoutts wonders if polymorphic is the right description
16:02:47 <dcoutts> it sounds a bit "buzzword"
16:03:35 <Lemmih> cameleon editor, perhaps?
16:03:40 <Wasp> @type show
16:03:41 <lambdabot> forall a. (Show a) => a -> String
16:03:53 <dcoutts> Lemmih, yeah I thoguht of cameleon too :-)
16:04:57 <dcoutts> Lemmih, I like the bit about "no seer..."
16:05:08 * dcoutts had to look up the definition of "seer"
16:05:14 <sethk> polytactical?
16:05:14 <Wasp> @type Char.chr
16:05:15 <lambdabot> Int -> Char
16:05:26 <sethk> or maybe polytactile
16:05:32 <dcoutts> sethk, polytastic!
16:05:54 <Wasp> ok for self education:where to get a function reference and how to get type of functions?
16:06:17 <dcoutts> Wasp, well lambdabot does that quite well
16:06:28 <sethk> Wasp, I'm not sure if this is the question, but :t name in ghci   or @type with lambdabot
16:06:31 <dcoutts> or there are indexes of the standard haskell libs
16:06:54 <dcoutts> Wasp, http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
16:07:12 <Wasp> ya ;) but dont wont to disturb conversations on channel :)
16:07:18 <sethk> dcoutts, polytropic
16:07:27 <dcoutts> @google polytropic
16:07:27 <ndm> http://www-users.cs.york.ac.uk/~ndm/hoogle/ also does it
16:07:28 <lambdabot> http://www.taftan.com/thermodynamics/POLYTROP.HTM
16:07:43 <ndm> @hoogle Int -> Char
16:07:44 <lambdabot> Terminated
16:07:44 <lambdabot>  
16:07:46 <sethk> also http://www.zvon.org/other/haskell/
16:07:52 <Wasp> what i search is called in miranda:  "function::"
16:07:55 <sethk> oh, no, lambdabot bailed on us again
16:08:11 <ndm> thats just with hoogle, for some unknown reason...
16:08:31 <dcoutts> sethk, Polytropic processes are internally reversible apparently :-)
16:08:35 <ndm> hoogle with lamdabot, rather than hoogle on its own
16:08:49 <sethk> dcoutts, may not be the right meaning, but it sounds good.  :)
16:08:55 <dcoutts> yeah :-)
16:13:39 <Wasp> tourofprelude the thing what i had search for
16:28:02 <sethk> hmm., I have a file here that seems to crash ghci, if I don't have a CR after the last line
16:29:31 <Lemmih> Crash as in segfault?
16:29:43 <heatsink> yes, how did you know?
16:30:03 <sethk> Lemmih, yes
16:30:25 <Wasp> who is "function (x:xs) = foo"  called?
16:30:45 <sethk> who?
16:30:45 <dcoutts> Wasp, huh?
16:31:07 * heatsink wonders what a stg_ap_pp_ret error is
16:31:12 <Wasp> f (x:xs) = x
16:31:16 <Wasp> for exaple
16:31:37 <Wasp> search for spelling
16:31:42 <dcoutts> Wasp, what is your question?
16:31:43 <Wasp> like "curry"
16:32:16 <Wasp> need phrase to search for. for that way of diffitation of functions
16:32:33 <dcoutts> pattern matching?
16:32:39 <Wasp> aahh :)
16:32:46 <Wasp> yeah, right :))
16:32:57 <heatsink> oh, that's what you meant.
16:33:07 <Wasp> because blub (n-1) = ..    dont work
16:33:41 <Lemmih> @eval let blub (n-1) = n in blub 10
16:33:43 <lambdabot>  Parse error in pattern
16:35:00 <Wasp> *g* nice bot ^^
16:35:47 <Wasp> but also cannot parse
16:35:51 <psi> @eval let foo (n+1) = n in foo 10
16:35:52 <lambdabot> 9
16:36:10 <Wasp> hmm
16:36:26 <Wasp> ahrgx .. right :(
16:36:35 <Wasp> thx
16:37:41 <Lemmih> dcoutts: Will it do as a HCAR entry?
16:40:23 <dcoutts> Lemmih, yeah I think so
16:40:41 <dcoutts> I might add a little about the components we're using
16:40:58 <dcoutts> ie darcs cabal gtk2hs plugins yi ghc-api
16:41:04 <dcoutts> all the usual buzzwords :-)
16:42:01 <dcoutts> dons, does hs-plugins and yi have hcar entries?
16:43:26 <psi> @what hcar
16:43:27 <lambdabot> Unknown command, try @listcommands.
16:43:50 <Lemmih> @google hcar haskell
16:43:50 <dcoutts> @where hcar
16:43:52 <lambdabot> http://www.haskell.org/communities/
16:43:52 <lambdabot> http://www.haskell.org/communities/
16:44:04 <Lemmih> (:
16:44:05 <psi> thanks :)
16:44:41 <Lemmih> Good night, #haskell.
16:45:05 <dcoutts> g'night Lemmih
16:51:11 <heatsink> Can I compile the GHC RTS with detailed debugging output?
16:53:51 <dcoutts> heatsink, yes I believe so
16:54:11 <dcoutts> it may be built by defaulit (I can't remember)
16:54:21 <dcoutts> if it is built then you just link using -debug I think
16:54:27 * dcoutts may be wrong
16:54:32 * heatsink will try
16:54:51 <dcoutts> otherwise you have to rebuild ghc and set the debug option then
16:55:13 <dcoutts> check the ghc/mk/*.mk files for details
16:55:20 <SyntaxNinja> woot
16:55:31 <dcoutts> heatsink, or the new HACKING file on the ghc cvs repo
16:55:34 <dcoutts> SyntaxNinja, ?
16:56:28 <heatsink> ah, there's a libHSrts_debug.a
16:56:34 <dcoutts> great
16:58:41 * CosmicRay looks in.
16:58:45 <CosmicRay> SyntaxNinja: ping
17:03:41 <dcoutts> dons, ping
17:14:21 <CosmicRay> wow.  it's been a busy week.
17:14:28 <CosmicRay> I didn't realize until last night that I hadn't put out HWN this week.
17:14:36 <CosmicRay> and it usually goes out on tuesday.
17:15:19 <SyntaxNinja> hi CosmicRay
17:15:23 <SyntaxNinja> hi dcoutts
17:15:37 <dcoutts> you were wooting
17:15:44 <dcoutts> we were curious
17:15:50 <SyntaxNinja> yes.  it means good things, right?
17:15:59 <SyntaxNinja> I'm playing w/ trac. I like it muchly.
17:16:06 <dcoutts> ah, great
17:16:12 <CosmicRay> dcoutts: heh
17:16:14 <SyntaxNinja> I'm wooting because I'm gunna get to spend like a day a week on haskell program stuff.
17:16:16 <CosmicRay> dcoutts: just very busy
17:16:24 <CosmicRay> argh, phone, brb
17:17:50 <dons> dcoutts, pong
17:18:41 <dcoutts> dons, like Lemmih's hcar entry?
17:18:45 <SyntaxNinja> hi dons
17:19:05 <dons> hey SyntaxNinja!
17:19:11 <dons> dcoutts, where's the entry? or should I check the logs..
17:19:18 <dcoutts> dons, email
17:19:58 * heatsink gets a reproducible segfault in haskell now, that's good
17:20:24 <CosmicRay> back
17:20:34 <SyntaxNinja> hi CosmicRay
17:20:46 <CosmicRay> SyntaxNinja: evening
17:20:53 <dons> dcoutts, Lemmih, oh I think this entry is good :)
17:20:56 <CosmicRay> just sent you an e-mail a few mins back
17:21:03 <CosmicRay> that reminds me, I need to send off some HCAR entries
17:21:07 <CosmicRay> deadline is Tuesday right?
17:22:24 <dcoutts> dons, ok, including the changes I suggested? Want me to send it?
17:22:48 <dons> yep, with the buzzword passage. yes, you can send it.
17:23:10 <dcoutts> ok
17:24:50 <dons> time to build gtk2hs
17:25:34 <dcoutts> yay
17:25:59 * dcoutts is particularly interested in the mozilla/firefox embeding bindings
17:26:38 <dons> we're still on release candidate 2, right?
17:26:53 <dcoutts> yes
17:27:02 <dons> then i'll just skip the test that i've already reported
17:27:10 <dcoutts> ok
17:30:31 <CosmicRay> stupid close button.
17:30:37 <CosmicRay> I just learned that the period of the earth is 23 hours 56 minutes 04. 09053
17:31:34 <dons> oh no! we're losing time!
17:31:39 <CosmicRay> :-)
17:31:52 <CosmicRay> turns out that the missing 4 minutes are accounted for because of the earth's orbit around the sun
17:32:07 <CosmicRay> it advances 4 minutes each day, making it appear that the rotational speed is slower.
17:35:48 * dcoutts goes to bed
17:41:10 <araujo> nini dcoutts
17:41:20 <dons> wow, gtk2hs builds fast these days: 10m40.73s real
17:45:58 <dons> dcoutts: $ ./testembedmoz
17:45:58 <dons> ./testembedmoz: can't load library 'libplc4.so.3.0'
17:46:56 <dons> ah, my fault. /usr/local/mozilla isn't in LD_LIBRARY_PATH
17:47:07 <dons> $ ./testembedmoz
17:47:07 <dons> zsh: segmentation fault (core dumped)  ./testembedmoz
17:54:44 <dons> dcoutts, all other tests run nicely
17:55:31 <SyntaxNinja> CosmicRay: yeah, got your mail. will get back to you
18:20:56 <dons> @yow
18:20:56 <lambdabot> This TOPS OFF my partygoing experience!  Someone I DON'T LIKE
18:20:56 <lambdabot> is
18:20:56 <lambdabot> talking to me about a HEART-WARMING European film ...
18:21:08 <dons> heh
18:41:24 <SamB> its amazing how much more readable Core is if you dump it in the internal form...
18:41:58 <SamB> though I probably ought to dump it *after* the tidy phase...
18:42:27 <dons> oh, it's not in the Z encoding?
18:42:37 <dons> @dynamic-reload hoogle
18:42:38 <lambdabot> module reloaded
18:42:55 <dons> @hoogle Int -> Char
18:42:55 <lambdabot> hoogle: hoogle.txt: openFile: does not exist (No such file or
18:42:55 <lambdabot> directory)
18:42:55 <lambdabot>  
18:43:00 <dons> grr.
18:43:08 <SamB> not unless you convert it to external core, no ;-)
18:43:24 <SamB> also, it isn't indented to crazy depths, which does wonders
18:44:05 <dons> @dynamic-reload hoogle
18:44:05 <lambdabot> module reloaded
18:44:07 <dons> @hoogle Int -> Char
18:44:08 <lambdabot>  Int -> Char @ 0
18:44:08 <lambdabot>  Int -> Char @ 0
18:44:08 <lambdabot>  PackedString -> Int -> Char @ -9 L#?-R#
18:44:13 <dons> ah ha!
18:44:57 <syntaxfree> ahoy.
18:45:32 <heatsink> @choo
18:45:33 <lambdabot> Maybe you meant: echo moo
18:45:48 <lisppaste2> syntaxfree pasted "what's a smarter way to do this?" at http://paste.lisp.org/display/12994
18:47:31 <heatsink> One thing would be not to scan all the primes to find the first prime larger than m
18:47:54 <syntaxfree> how?
18:48:48 <heatsink> factor x (p:primes) | p `divides` x = (x, p) : factor (x `div` p)  (p:primes)
18:49:01 <SamB> the names are all wrong this way
18:49:06 <heatsink>  | otherwise = factor x primes
18:49:15 * heatsink tries to figure out how primes is calculated now
18:50:31 <syntaxfree> um, yes. but the second argument becomes a list, then.
18:50:45 <heatsink> what is factor intended to do?
18:51:32 <syntaxfree> *Main> factor 90 2
18:51:32 <syntaxfree> [(90,2),(45,3),(15,3),(5,5)]
18:52:22 <heatsink> would it ever be useful to say [| factor 90 3 |] ?
18:52:53 <syntaxfree> yes, it would.
18:53:00 * SamB moves his little piece of code that actually does something to HscMain, right after the CoreTidy phase...
18:53:01 <syntaxfree> It's not strictly "factorization".
18:53:09 <heatsink> Okay.  what is factor intended to do? :)
18:53:10 <syntaxfree> But it leads to different behaviour I want to study.
18:53:19 <syntaxfree> it would go
18:54:43 * SamB adds the import it needs
18:57:48 * heatsink waits to see where it will go
18:57:54 <dons> @seen ndm
18:57:54 <lambdabot> I saw ndm leaving #haskell-blah and #haskell 2 hours, 41
18:57:54 <lambdabot> minutes and 27 seconds ago.
18:58:59 <SamB> okay, now I can actually see the link between Core and HC
19:01:42 <syntaxfree> hey, dons.
19:01:45 <syntaxfree> :)
19:02:10 <SamB> hmm, what are SRTs for?
19:03:05 <dons> static reference tables. um, oh err.
19:03:37 <dons> you get an SRT for each let-binding
19:05:11 <dons> hey syntaxfree
19:05:22 <SamB> hmm, this isn't exactly a let binding...
19:05:51 <dons> and any binding group
19:05:57 <dons> see StgSyn and SRT.hs
19:06:04 <dons> in ghc/compiler/*/
19:06:10 <dons> however, what they do I can't recall :/
19:06:56 <dons> ah, an SRT determines the top-level bindings referenced by each let binding and case expression.
19:07:10 <dons> check the ghc commentary
19:07:38 <dons> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
19:07:42 <dons> @where comm
19:07:43 <lambdabot> I know nothing about comm.
19:07:47 <dons> @where+ comm http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
19:07:47 <lambdabot> comm ~> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
19:09:16 <heatsink> oh hey, this could be useful
19:09:18 * heatsink bookmarks
19:09:25 <SamB> this one basicly seems to hold a reference to Text.ParserCombinators.Parsec.Char.char...
19:09:28 <machack666> anyone here used hoc (Haskell on Cocoa)?
19:09:35 * heatsink searches the commentary for stg_ap_pp_ret
19:09:59 <SamB> rather, to its closure
19:10:32 <SamB> to be precise,
19:10:32 <SamB> EI_(TextziParserCombinatorsziParsecziChar_char_closure);
19:10:32 <SamB> static StgWord r3yk_srt[] = {
19:10:32 <SamB> (W_)&TextziParserCombinatorsziParsecziChar_char_closure
19:10:32 <SamB> };
19:11:05 <dons> right, so it's a reference to a top-level binding used in the current let or case
19:11:32 <dons> a static reference, in fact :)
19:15:10 <SamB> wow, , "lvl1_r3yk = Text.ParserCombinators.Parsec.Char.char @ () lvl_r3yi" looked like such a *simple* function...
19:16:13 <SamB> (it was "char ','" in my code, which looks even simpler)
19:17:09 <machack666> @hoogle (a->IO b) -> IO[b]
19:17:10 <lambdabot>  (a -> IO a) -> IO a @ -12 L!*-R?*
19:17:10 <lambdabot>  MVar a -> (a -> IO b) -> IO b @ -21 L#?*!-R#?*
19:17:10 <lambdabot>  (a -> a) -> a @ -21 L!-R???*
19:17:15 * SamB wonders how the garbage collector knows where to return to
19:18:12 <machack666> what does the information after the @ mean?
19:18:37 <machack666> besides lambdabot going insane :D
19:19:06 <dons> i'm currently working on this, but thhe stuff after @ is a ranking, and some other stuff I don't know whta it means
19:19:20 <dons> ask ndm
19:19:25 <machack666> looks like it might have something to do with precidence?
19:19:42 <dons> maybe
19:20:11 <SamB> calling newCAF looks awfully expensive
19:20:22 <dons> @pl let (n,_) = break (== ':') x ; (m,_) = break (== ':') y in n `compare` m
19:20:23 <lambdabot> (line 1, column 5):
19:20:23 <lambdabot> unexpected "("
19:20:23 <lambdabot> expecting natural, identifier or "in"
19:50:10 <araujo> Hello!
19:55:16 <dons> @hoogle map
19:55:23 <lambdabot> An error occured.
19:55:25 <lambdabot>  
19:55:31 <dons> @quit
19:57:21 <dons> @hoogle map
19:57:25 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
19:57:27 <lambdabot> Data.Set.map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set
19:57:29 <lambdabot> b
19:57:31 <lambdabot> Data.Map.mapWithKey :: (k -> a -> b) -> Map k a -> Map k
19:57:33 <lambdabot> b
19:57:40 <dons> output filters suck in lambdabot atm
19:57:53 <dons> @hoogle a -> b
19:57:54 <lambdabot> Test.QuickCheck.Batch.bottom :: a
19:57:54 <lambdabot> Prelude.undefined :: a
19:57:54 <lambdabot> Prelude.seq :: a -> b -> b
19:58:04 <dons> @hoogle+
19:58:04 <lambdabot> Prelude.max :: Ord a => a -> a -> a
19:58:04 <lambdabot> Prelude.id :: a -> a
19:58:04 <lambdabot> Prelude.const :: a -> b -> a
19:58:13 <dons> @hoogle Array
19:58:13 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays.arrayPointer ::
19:58:13 <lambdabot> ClientArrayType -> StateVar (VertexArrayDescriptor a)
19:58:13 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays.arrayElement ::
19:58:13 <lambdabot> ArrayIndex -> IO ()
19:58:14 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays.ArrayIndex ::
19:58:16 <lambdabot> GLint
19:58:25 <dons> interesting
19:58:34 <dons> @hoogle Fix
19:58:45 <dons> @hoogle fix
19:58:56 <dons> @hoogle Monad
19:59:01 <dons> @hoogle Map
19:59:36 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
19:59:38 <lambdabot> Language.Haskell.TH.Syntax.FixityDirection :: FixityDirection
19:59:40 <lambdabot> Language.Haskell.TH.Syntax.Fixity :: Fixity
19:59:42 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
19:59:44 <lambdabot> Language.Haskell.TH.Syntax.FixityDirection :: FixityDirection
19:59:46 <lambdabot> Language.Haskell.TH.Syntax.Fixity :: Fixity
19:59:48 <lambdabot> Prelude.Monad :: Monad m
19:59:50 <lambdabot> Graphics.UI.ObjectIO.StdIOBasic.IOMonad :: Monad m => IOMonad
19:59:52 <lambdabot> m
19:59:54 <lambdabot> Control.Monad.Writer.MonadWriter :: (Monoid w, Monad m) =>
19:59:56 <lambdabot> MonadWriter w m
19:59:58 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
20:00:00 <lambdabot> Data.Set.map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set
20:00:02 <lambdabot> b
20:00:04 <lambdabot> Data.Map.mapWithKey :: (k -> a -> b) -> Map k a -> Map k
20:00:06 <lambdabot> b
20:00:29 <dons> hmm.
20:00:41 <dons> @quit
20:01:08 <dons> the plugin load really fast on linux for some reason.
20:01:12 <dons> plugins.
20:01:19 <dons> @where lambdabot
20:01:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:01:24 <dons> @fact haskell
20:01:24 <lambdabot> haskell: Haskell is the language of choice for discriminating
20:01:24 <lambdabot> hackers.
20:01:34 <dons> @quit
20:02:10 <dons> ok. update all done :)
20:02:15 <dons> @hoogle fmap
20:02:16 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
20:02:16 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) ->
20:02:16 <lambdabot> f a -> m ()
20:02:16 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f
20:02:16 <lambdabot> a -> m (f b)
20:02:38 <heatsink> @pl fix . break
20:02:39 <lambdabot> fix . break
20:02:45 <dons> ndm, i've updated the hoogle plugin in lambdabot to use cvs hoogle now.
20:02:45 <heatsink> should be id.
20:02:52 <dons> heatsink, oooh. nice idea
20:02:59 <heatsink> :)
20:03:23 <dons> you could add a rewrite rule to the Pl plugin, or talk to TheHunter
20:04:27 <heatsink> I'll write that down... gotta do something about the elite module, too
20:05:06 <dons> ok, elite should be easy to hack
20:05:08 * heatsink goes back to debugging null pointers
20:05:14 <dons> :/
20:05:22 <dons> if only the used the Maybe type, eh?
20:05:47 <fizbin> Is there a pastebot I can put some code up on?
20:06:14 * fizbin is going nuts trying to figure out how to add enough context to this definition.
20:06:52 <heatsink> If only C was a little bit more typesafe
20:07:04 <heatsink> Then the typechecker could find all unsafe pointer derefs
20:07:33 <heatsink> You're supposed to say, "what typechecker?"
20:07:34 <dons> @paste
20:07:34 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:07:46 <dons> hehe
20:09:23 <dons> @version
20:09:23 <lambdabot> lambdabot 3p130, GHC 6.5.20050806 (Linux i686)
20:09:23 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
20:09:25 <sethk> what typechecker?
20:09:39 <heatsink> that's the problem!
20:10:15 <sethk> see, I can follow instructions  :)
20:10:33 * dons notes there's now been 601 lambdabot patches in the last 6 months
20:10:57 <Korollary> lambdabot probably needs some refactoring then.
20:11:11 <dons> heh, a lot of those have  been refactoring patches
20:11:19 <dons> in fact, that's mostly what we do, I think
20:11:36 <Korollary> that happens when you're not getting paid for the work heh
20:11:46 <heatsink> :)
20:11:54 <dons> hehe
20:12:23 <dons> it's the prettiest lambdabot under the sun
20:12:26 <fizbin> Um... and how do mere mortals edit that page?
20:12:32 <Korollary> I spent hours messing with perl. I feel like a shower...
20:12:49 <sethk> fizbin, you have to register with the wiki, then you can edit
20:13:07 * heatsink thinks the irc paste page shouldn't be immutable
20:13:18 <Korollary> heatsink: it's a spam target
20:14:10 <fizbin> Ah.  Well, I guess I can understand that spam makes you do that.
20:14:32 <Korollary> fizbin: you can also use lisppaste, rafb.net, etc.
20:17:35 <dons> you just register by clicking on UserPreferences, then refresh
20:18:03 <machack666> does anyone else have the problem of the wiki toolbar disappearing when you are logged in?
20:18:30 <sethk> machack666, yes, I have it also
20:18:39 <sethk> machack666, I use the edit button at the bottom instead
20:19:06 <machack666> I didn't see that --- I've been adding `action=edit' to the url by hand :)
20:19:16 <sethk> machack666, that's harder  ;0
20:19:20 <sethk> :)
20:20:06 <fizbin> Okay, so I've now put something at the bottom of the paste page that is giving me errors.
20:20:44 <fizbin> Basically, I've got a type constructor that takes a single type "a" and I want to declare that this thing is a Monad.
20:21:33 <fizbin> Unfortunately, my type constructor only takes "a"s that are (Ord a), and so apparently I need to somehow restrict the type of >>= in the Monad instance declaration.
20:21:42 <luqui> impossible
20:21:46 <luqui> I've tried this before
20:21:56 <luqui> it's too bad
20:22:31 <heatsink> can you add another constraint?
20:22:43 <heatsink> oh, I didn't see your code there
20:22:43 <machack666> @paste
20:22:44 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:23:51 <luqui> Monads require that binding works for *any* type a and b, so you're not conforming to the definition
20:23:57 <fizbin> luqui: So what you're saying is that the nice "do" syntax is available only to those type constructors with no constraints on them.
20:24:00 <fizbin> Why?
20:24:08 <fizbin> What is the reason for that?
20:24:11 * luqui dunnos
20:24:17 <luqui> He wishes it weren't the case
20:24:32 <luqui> you can tell ghc to omit the standard prelude, though, and then define your own (>>=)
20:24:41 <luqui> that the do notation will then use
20:24:49 <luqui> but there are many complications that come with that
20:25:32 <heatsink> fizbin: Internally, functions with typeclass constraints have different arity than functions without typeclass constraints.
20:28:07 <heatsink> fizbin: The type of (>>=) doesn't allow for the comparison functions to be passed as hidden parameters to your function (>>=)
20:29:29 <fizbin> This would seem to severely limit the possible new Monads that can be created.
20:29:31 <heatsink> That's why it doesn't work with constraints.
20:30:03 <heatsink> Hmm, let me try something.
20:30:39 <fizbin> Unfortunately, there's no way that I can remove the Ord constraint since it's implicit in the Map.unionsWith function I call as part of >>=
20:33:31 <heatsink> @hoogle unionsWith
20:33:32 <lambdabot> Data.Map.unionsWith :: Ord k => (a -> a -> a) -> [Map k a] ->
20:33:32 <lambdabot> Map k a
20:33:32 <lambdabot> Data.IntMap.unionsWith :: (a -> a -> a) -> [IntMap a] -> IntMap
20:33:32 <lambdabot> a
20:35:25 <heatsink> Can you find a way to move the ordering into fields of the Probably datum?
20:36:22 <fizbin> Meaning supply an ordering function along with the type?  Maybe.
20:36:31 * fizbin thinks about this.
20:37:47 <fizbin> Unfortunately, it means I can't use unionsWith and have to roll my own implementation of Data.Map, then.
20:38:54 <fizbin> Or maybe... hrm.
20:40:03 <heatsink> What does your code do with the two maps in the (>>=) operator?
20:42:11 <fizbin> two maps?  n maps.  First, think of each map as being basically [(a,Double)]
20:42:26 <heatsink> ok
20:43:15 <fizbin> Then, for each (k,v) pair in the [(a,Double)] it gets the result of the "rest" as something of type [(b,Double)]
20:44:57 <fizbin> Then, if that something is [(bs, bDbls)], it forms [(bs, v * bDbls)].  Then, it collects the resulting lists for all k and joins them together suming up the "bDbls" values for each "bs"
20:45:09 <machack666> who is the maintainer of haskell-mode ?  The uncomment feature leaves a leading space after removing the `--', which ghc does not like.
20:46:28 <machack666> fizbin: would an accumMap be something useful in that situation?
20:47:42 <fizbin> @hoogle accumMap
20:47:42 <lambdabot> No matches found
20:47:57 <heatsink> @hoogle mapAccum
20:47:58 <lambdabot> Data.Map.mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map
20:47:58 <lambdabot> k b -> (a, Map k c)
20:47:58 <lambdabot> Data.Map.mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a,
20:47:58 <lambdabot> Map k c)
20:47:58 <lambdabot> Data.List.mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (
20:48:00 <lambdabot> acc, [y])
20:48:58 <fizbin> No.  That combines values for different keys.
20:49:39 <fizbin> I don't want that.  I want to combine multiple maps into one map.  i.e. exactly what unionsWith does.
20:49:39 <heatsink> fizbin: I think I'm missing something.  It's doing (sum (map (v *) bDbls))?  Isn't that the same as v * (sum bDbls)?
20:50:30 <fizbin> heatsink: No, because the "v" values are different for each "k".
20:51:20 <heatsink> Oh, I see.  unionsWith is doing [Map b Double] -> Map b Double
20:51:28 <heatsink> I have another question.
20:51:28 <fizbin> Right.
20:51:37 <heatsink> When you're finished with the monadic computation, how do you get the values out?
20:51:56 <heatsink> If you don't need the type of the output b, then you can use an existential type.
20:52:11 <fizbin> (Map.toList . fromProb) (result of computation)
20:54:45 <fizbin> So I kind of do...  However, the "jam the ordering function into the Probably constructor" has given me an idea I think I can persue.  Thanks.
20:55:15 <heatsink> glad to help
20:57:27 * heatsink notes that existential types don't work here because typevars don't instantiate to typeschemes
20:58:31 <syntaxfree> @pl fact n =  (foldl (.) id [\x -> x*k | k <- [1..n]]) 1
20:58:32 <lambdabot> fact = flip (foldl (.) id . return . (*) . ((k | k) <-) .
20:58:32 <lambdabot> enumFromTo 1) 1
20:59:16 <heatsink> pl still doesn't understand list comprehensions
21:00:42 <fizbin> (\_ -> const EQ) is a function that takes two arguments and returns EQ, yes?
21:01:03 <fizbin> Or it it better to write it as (\_ _ -> EQ) ?
21:01:26 <Dibrom> \_ would be 1 argument
21:01:31 <Dibrom> \_ _ is 2
21:01:40 <Dibrom> unless you pass a tuple or something to the first one
21:01:47 * heatsink would write const (const EQ)
21:02:01 <fizbin> @hoogle const
21:02:02 <lambdabot> Prelude.const :: a -> b -> a
21:02:02 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments.constantColor
21:02:02 <lambdabot> :: StateVar (Color4 GLfloat)
21:02:02 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments.Constant ::
21:02:02 <lambdabot> Src
21:02:14 <heatsink> @type const (const EQ)
21:02:15 <lambdabot> forall b b1. b1 -> b -> Ordering
21:02:35 <fizbin> @type (\_ _ -> EQ)
21:02:36 <lambdabot> forall t t1. t1 -> t -> Ordering
21:02:42 <heatsink> either one works
21:05:00 <heatsink> @type curry . const  $ EQ
21:05:02 <lambdabot> forall a b. a -> b -> Ordering
21:05:07 <heatsink> :)
21:08:07 <fizbin> So supposing I make a general expression for a function with signature a->b, is there a way to override that in the case where I know something special about a and/or b, such as (Ord a) ?
21:08:59 <heatsink> Hmm...
21:09:01 <Dibrom> you can do stuff like that with the generics thing
21:09:07 <Dibrom> Data.Generics
21:09:07 <heatsink> The only way I can think of is with overlapping instances
21:09:21 <luqui> but tat doesn't help fizbin in the monad case, because (Ord a) becomes (Typeable a)
21:09:34 <luqui> heatsink, overlapping instances?
21:10:37 <heatsink> I think so.  I'll test my theory.
21:20:04 <Cale> fizbin: could you give an example?
21:20:09 <heatsink> nah, didn't work.
21:20:23 <luqui> heatsink, darn
21:20:39 <dons> @quit new code
21:21:15 <Cale> if a function has signature a -> b, I'm pretty sure that function is something along the lines of \x -> undefined
21:21:22 <heatsink> fizbin's example was at the end of the irc paste page.
21:21:28 <Cale> or a variant which forces evaluation of x
21:21:32 <Cale> oh
21:21:45 <fizbin> Oh, right.  I meant a signature of a -> b -> c
21:22:04 <Cale> fizbin: specific a, b, and c?
21:22:14 <Cale> or forall a,b,c. a -> b -> c
21:22:41 <fizbin> No.  I've got a definition for the general case but I want to use a better definition if, e.g. a is (Ord a)
21:22:57 <Cale> ah
21:23:12 <Cale> are the semantics the same?
21:23:16 <luqui> (Cale is saying that universal signatures restrict what the function can do.  If a function is a -> a, then it can only be "id" or "const undefined")
21:23:43 <luqui> there are no other possibilities (I, for one, think that is pretty cool)
21:24:25 <Cale> well, in Haskell, there are a couple more annoying ones
21:24:25 <fizbin> luqui: Is not the function (\x -> x+1) of type (a -> a) ?
21:24:36 <Korollary> fizbin: no
21:24:50 <Cale> fizbin: it's (Num a) => a -> a
21:24:56 <fizbin> Oh, it matches (a -> a), but is more specific.
21:25:35 <Cale> yeah, it's not that polymorphic
21:25:47 <fizbin> Cale: Um... I /think/ that the semantics are the same, though it's a matter of how you interpret them.
21:26:06 <fizbin> Hrm.  Maybe they aren't.  Drat.
21:26:39 <Cale> well, you probably don't want to replace one with the other in that case :)
21:26:56 <Cale> you can always devise a data type which handles both the cases
21:26:58 <heatsink> fizbin: I had the impression that your semantics for the non-Ord case were going to be (error "error-message")
21:27:21 <Cale> if it's purely an optimisation thing, and you want it to be transparent, I think there are some GHC pragmas which might help
21:28:29 <heatsink> Is this still related to you not being able to define bind with type (Ord a, Ord b) => m a -> (a -> m b) -> m b
21:29:13 <Cale> oh, I'm not sure if it's related, I'd have to think about that
21:29:42 <fizbin> Cale: I think that question was directed at me.
21:29:46 <heatsink> yea :)
21:29:57 <fizbin> heatsink: Yeah, I'm still trying to tackle/mangle that.
21:30:28 <Cale> oh
21:30:46 <Cale> yeah, you can't define something as a monad if it requires an instance of Ord
21:30:51 <Cale> I'm frustrated by that too
21:31:17 <fizbin> Right, which is why I'm trying to fake an ord instance and do some backflips...
21:31:39 <araujo> Cale, why is that?
21:32:11 <fizbin> I think at the moment that I may actually be able to do this so long as I don't use 'return' but use my own (Ord a) - guarded return-like function.
21:32:37 <luqui> I think you can do it if you define OrdMonad
21:32:43 <Cale> araujo: because the class says that >>= has type m a -> (a -> m b) -> m b
21:32:46 <fizbin> That sucks for certain other reasons, but oh well...
21:32:50 <luqui> but, uh, then you can't use do notation.
21:32:52 <Cale> and not (Ord a, Ord b) => ...
21:32:59 <Cale> right
21:33:30 <fizbin> Does the do notation really rquire "return", or just >>= ?
21:33:45 <dons> yep
21:33:54 <dons> do notation is syntax. monads need return
21:34:01 <araujo> Cale, Oh, i see
21:34:03 <luqui> Doesn't matter. do notation requires an instance of monad
21:34:11 <luqui> and monad requires return
21:34:28 <dons> for the theoretical reason we need return, best consult Moggi
21:34:33 <fizbin> But I can define 'return' to something only barely sensible.
21:34:44 <dons> then you have an incoherent monad :)
21:35:02 <dons> that doesn't obey the monad laws, I presume
21:35:37 <Cale> heh
21:35:50 <Korollary> you get jailtime
21:36:13 <luqui> fizbin, I think I know what you're trying to do (eg. return _ = undefined).  It probably won't work, because you still need the (Ord a, Ord b) on (>>=), but it might be a good exercise to try
21:36:15 <Cale> data Trivial a = Trivial; instance Trivial Monad where return x = Trivial, xs >>= f = Trivial
21:36:28 <TheHunter> looks like the do-notation only needs >>= and >>.
21:36:32 <luqui> instance Monad Trivial
21:36:37 <Cale> er
21:36:38 <Cale> yes
21:37:03 <dons> hmm, maybe reversing the class and type is more readable
21:37:18 <TheHunter> oh, and fail, of course.
21:37:31 <Korollary> "Trivial instance Monad" is most readable
21:37:44 <TheHunter> fizbin, you can just hide the Prelude and define your own monad-like functions, i think.
21:37:53 * luqui has always thought that constaints on classes should come after the declaration, eg. "class Foo a <= (Ord a)"
21:38:06 <Cale> I think just "Monad Trivial where" would be decent :)
21:38:07 <dons> Char isAnInstanceOf Read where
21:38:15 <luqui> because I always think that "class Ord a => Foo a" is defining class Ord
21:38:15 <Cale> but the instance keyword does help somewhat
21:38:21 <Korollary> luqui: from a logic point of view, the way it is fine with me
21:38:41 <fizbin> Yeah, and then have Prelude.+ and stuff all over my code.  Ew.
21:38:42 <luqui> yeah, but a readability point of view is suboptimal, IMO.  BTJMO
21:38:46 <Korollary> "if Ord a, then class Foo a"
21:38:48 <Korollary> hah
21:38:56 <Cale> yeah!
21:38:58 <Korollary> btjmo ?
21:39:07 <heatsink> "instance Trivial of Monad"
21:39:14 <luqui> But That's Just My Opinion, man
21:39:28 <luqui> maybe it's: BTJLMOM
21:39:36 <dons> but then you need extra syntax on the rhs of Monad
21:39:38 <TheHunter> import Prelude hiding (Monad(..)) should be fine.
21:39:47 <Cale> heatsink: well, it's an instance of Monad, for Trivial
21:40:12 <Korollary> I think it's btijmo
21:40:25 <Cale> actually, it's not even really clear what to Englishize the code to
21:40:37 <Korollary> let's yoda'ize it
21:40:43 <luqui> "provided"?
21:40:57 <Cale> Trivial is an instance of Monad where
21:41:00 <dons> i think the current syntax is yoda-ised
21:41:13 <dons> instance Monad, Trivial is, yes
21:41:18 <Korollary> heh
21:41:19 <heatsink> Hungry you are, hmm?
21:41:23 <heatsink> Instance Monad Trivial, hmm?
21:41:28 <Cale> Monad Trivial is kind of nice in that it looks like a logical predicate
21:41:33 <luqui> instance You Hungry where
21:41:37 <Cale> which it is sort of supposed to be
21:41:59 <luqui> kind of flies with "given prime p"
21:42:02 <Korollary> Instance be Trivial of Monad, yo !
21:42:03 <Cale> Typeclasses are predicates on types
21:42:24 <heatsink> The instance syntax used to confused me tremendously
21:42:27 <dons> yep, zactly. hence C a => a
21:42:51 <Cale> functions are proofs of types
21:42:52 <dons> the syntax is an elaborated form of the typing judgements
21:43:11 <heatsink> because `Maybe Int' as a datatype and `Monad List' in in instance declaration look the same, but mean totally different things
21:43:19 <luqui> Cale, mmm, that's from ATTaPL, no?
21:43:29 <Cale> luqui: haven't read it
21:43:38 <luqui> Well, I think it is
21:43:49 <luqui> definitely from some other source paper, though
21:44:31 <dons> functions are a witness to the truth of the type.
21:44:34 <Cale> I may be wrong, but I think that's referred to as the Curry-Howard isomorphism
21:44:42 <dons> i think is what Cale is saying, standard H iso
21:44:44 <dons> CH iso
21:45:12 <dons> so given some lemma/type you want to prove, you write an expressionn that has that type, and bingo
21:45:25 <dons> this is how isabelle and twelf operate.
21:45:37 <Cale> one cool thing about that way of thinking is that if you're familiar with proofs, some of the same mental techniques then apply to writing computer programs
21:45:44 <dons> just requires a type system rich enough to encode useful properties to prove
21:45:53 <dons> ah, yes, interesting Cale
21:46:17 <luqui> uh, can I go the other way.  I tend to be a lot better at programming than at proofs :-)
21:46:32 <Cale> for example, if you haven't used a parameter to your function, it's like you haven't used part of the assumptions made in your theorem statement.
21:46:49 <luqui> ohhh, I get it
21:46:50 <dons> you can certainly hack, then try to work out the type of the thing you've hacked, and the typechecker will tell you if you got it right ;)
21:46:57 <heatsink> luqui: The salient question is, are you better at debugging than proofs?
21:47:08 <luqui> I write error-free code.
21:47:11 <luqui> Hahahahahahahaha
21:47:13 <luqui> no
21:47:32 <luqui> the answer to your question is: depends.  But usually, yes.
21:48:07 <luqui> (I've been programming for 11 years, but doing proofs for 2)
21:49:04 <Cale> I've been teaching moomlyn Haskell -- got to get her to join the channel :) One problem that I gave was to construct an appropriate type for a folding function on the datatype  data Nature a = Tree a (Nature a) (Nature a) | River a (Nature a) | Stone  and then write that function.
21:49:42 <heatsink> Who moomlyn is?
21:49:51 <Cale> another freenode user :)
21:51:14 <dons> @pl \(k,v) -> [k,v]
21:51:14 <lambdabot> uncurry ((. return) . (:))
21:51:19 <dons> bah
21:51:29 <dons> sometimes i think @pl is too keen to use monads
21:51:46 <Korollary> sometimes I think people are keen to use pointfree style
21:51:47 <Cale> While thinking about the problem myself, it occurred to me how it's sort of handy to think of parameters as assumptions which should be consumed in the implementation. :)
21:51:58 <heatsink> absolutely
21:52:39 <luqui> dons, I agree
21:52:48 <Cale> dons: me too
21:53:03 <Cale> the ((->) a) monad should be off-limits
21:53:34 <heatsink> So, Cale, is it possible to make a typeclass (MayBeOrd a) that is an instance of Ord, that does the Ord thing when (Ord a), and errors otherwise?
21:53:38 <Cale> In fact, I don't think it should use anything which isn't in the Prelude, and maybe List.
21:53:48 <luqui> Why doesn't Haskell allow section notation in types: (a ->)
21:53:56 <Cale> luqui: beats me
21:54:23 <Cale> also, ghc seems to have a minor bug when printing infix type constructors other than ->
21:54:37 <Cale> I was getting things like  ~> a b
21:54:47 <Cale> where one would want a ~> b
21:55:10 <TheHunter> @pl \x -> f x `op` g x
21:55:10 <lambdabot> liftM2 op f g
21:55:17 <luqui> ugh
21:55:19 <TheHunter> how would you pointfree that one?
21:55:22 <Cale> heatsink: hmm, a type?
21:56:03 <luqui> heatsink, you mean "runtime errors" otherwise, no?
21:56:03 <heatsink> Cale: basically, to make a typeclass that is the union of two typeclasses, instead of the intersection
21:56:18 <heatsink> luqui: yes
21:56:27 <Cale> heatsink: I don't think so.
21:56:34 <luqui> union types are way hard to implement
21:57:13 * fizbin gets it to compile by using a fake ordering type.  Now he gets to the real bugs...
21:57:39 <Cale> fizbin: what type are you trying to force to be an instance of Monad?
21:58:03 <Cale> perhaps I should look more carefully at the paste :)
21:58:09 <dons> I don't mind -> a so much, like that liiftM2 is good, but sometimes maybe there's too much :}
21:58:11 <heatsink> And, I take it that it's also not possible to make the complement of a type.
21:58:31 <Cale> heatsink: right
21:58:56 <Cale> tagged union, product
21:59:19 <Cale> for classes, all you get is intersection and restriction (sort of)
21:59:38 <heatsink> how is restriction distinct from intersection?
22:00:17 <Cale> If you have two classes, you can insist on both. If you have one class, you can construct a new one which is smaller than it.
22:00:27 <heatsink> oh, I see.
22:00:41 <Cale> (by adding new bits to the interface)
22:01:13 <heatsink> Introducing complement or union would lead to NP-complete typable programs, right?
22:01:44 <Cale> I don't really know, but likely.
22:02:03 <heatsink> complement would do that, at least.  I don't know about union.
22:02:16 <Cale> I really don't know why you'd ever want complement.
22:02:19 <TheHunter> the alternative would be to use an s combinator, which isn't even in the libs, and the results would be way uglier.
22:02:56 <Cale> given what classes mean wrt the types
22:03:03 <Cale> hmm
22:03:13 <Cale> I suppose you'd use it while swindling :)
22:03:20 <heatsink> swindling?
22:03:31 <Cale> hehe, in the sort of way Oleg does
22:03:36 * heatsink could see complement used for run-time type checking
22:03:49 * heatsink ... not for much else
22:04:10 <Cale> a type equality class would be useful
22:04:23 <Cale> it can't be that hard to add to the language, can it?
22:04:47 <heatsink> Data.Typeable?
22:04:55 <Cale> well, sort of
22:05:52 <Cale> really, just a class which only holds when its two type parameters are equal
22:06:20 * heatsink discovers that the odd bugs were coming from an extra file that was lying around the directory but wasn't supposed to be compiled into the program
22:06:31 <Cale> :)
22:07:32 <heatsink> instance EqualityClass a a where... instance EqualityClass a b where...
22:07:35 <TheHunter> such a class would also subsume GADTs.
22:07:59 <Cale> yeah, I suppose it would :)
22:08:09 <fizbin> Cale: If you want, I've now put the whole program on the past page - scroll to the bottom, searching for "fizbin".
22:09:01 <fizbin> The Monad is intended to help with complicated conditional probability calculations - the demo code just solves the classic "Monty Hall" problem.
22:11:19 <heatsink> Hmm...
22:11:22 <Cale> heh
22:11:25 <fizbin> I plan to use it in the future to do more complicated stuff, but this problem makes a good "is my code even vaguely working" check.
22:11:51 <Cale> this is kind of funny, but it looks like it should sort of work
22:11:57 <fizbin> And in fact I'm skipping a normalization step which I should do before showing the output.
22:12:06 <heatsink> I don't think you come across (forall a b. a -> m b) functions in conditional probability, unless a and b are independent events.
22:13:22 <Cale> hmm
22:13:24 <heatsink> Maybe I'm rushing.
22:13:33 <fizbin> heatsink: But I'm not using (forall a b. a -> m b).  I'm using (a -> ProbWorld b), where "ProbWorld" is a Monad that runs the universe.
22:13:34 <Cale> are you sure you can't just use a Reader monad?
22:14:38 <heatsink> fizbin: a -> m b is the conditional probability of event b as a function of event a, right?
22:14:55 <heatsink> fizbin: a -> m b is the conditional probability of events in the set b as a function of events in the set a, right?
22:15:01 <newsham> hi
22:15:06 <Cale> hello
22:15:15 <fizbin> No, I think you had it right the first time.
22:15:31 <newsham> anyone read "The haskell road to logic, maths and programming."?  I am reading it and I have a (admittedly non-haskell) question
22:16:26 <fizbin> (ProbWorld b) is a set of possible b values, with probabilities.  a -> ProbWorld b is a function from a value of type a to a set of b values with (conditional) probabilities.
22:17:07 <heatsink> fizbin: How would you write (a -> b -> ProbWorld c)?
22:17:24 <Cale> newsham: ask away :)
22:17:36 <newsham> it would be easier if i could reference the book.. i'll try anyway.
22:18:30 <newsham> in a chapter about proofs, in a section on negation, subsection elimation:  "when you intend to use the given \not \Phi, you can attempt to prove, on the basis of the other given, that \Phi must hold.  In that case, the elimination rule declares the
22:18:43 <newsham> the proof problem to be solved, nomatter what the statemen to be proved!
22:19:01 <newsham> Schematically:   Given: \Phi, \not \Phit
22:19:04 <newsham> Thus: \Psi
22:19:10 <Cale> what page?
22:19:13 <newsham> err.. s/Phit/Phi/
22:19:17 <newsham> page 84, at the bottom
22:19:30 <newsham> then later in an example 3.10 on page 87:
22:19:39 <newsham> "Suppose P.  Then from P and \not P we get Q."
22:19:43 <newsham> I dont understand that
22:20:05 <Cale> oh
22:20:28 <Cale> Well, you don't even need to suppose P first, just P and not P will imply Q
22:20:44 <newsham> I dont understand why P and not P implies Q
22:20:52 <newsham> given that Q could be anything (?!)
22:20:55 <heatsink> If hell freezes over, then anything can happen :)
22:20:57 <Cale> right
22:20:58 <Cale> Suppose P and not P.
22:21:01 <heatsink> Hell is hot and hell is cold
22:21:06 <fizbin> That would be a function from two values to a distribution of values.  Note that in the sample code "hostopen" is a function of "prizedoor" and "choicedoor"
22:21:17 * fizbin types slowly, apparently
22:21:39 <newsham> ok, so the "elimination" just means that if you get to a section where you know \Phi and \not \Phi, then you can just disreguard that entire section
22:21:43 <newsham> because its irrelevant?
22:21:49 <newsham> (intuitively speaking)
22:22:30 <Cale> newsham: if you get a contradiction, then some assumption that you made should fail
22:22:47 <newsham> ie:  Given P \or Q, \not P.   prove: Q.   proof: 1) suppose P.  P and \not P implies Q.   2) suppose Q.  then Q holds.   therefore Q
22:23:28 <newsham> so the P and \not P implies Q    just basically says "if these two contradictions are both true, then everything might as well be true, because it aint happening" ?
22:23:49 <newsham> err..  not "two contradictions", but you know what i'm saying :)
22:23:52 <Cale> Suppose that P and not P. Then if not Q, certainly P, so ~Q => P
22:24:05 <Cale> If Q, then ~P as well
22:24:11 <Cale> (trivially)
22:24:17 <Cale> so Q => ~P
22:24:24 <newsham> ok, i think this makes a little more sense now.  thanks
22:25:28 <Cale> and contrapositive from one of those is enough to show Q and ~Q as well
22:25:38 <newsham> *nod* that makes sense
22:26:03 <newsham> so generally in a world were both P and ~P, everything is implied :)
22:26:20 <Cale> right, given that the usual rules of logic apply
22:26:38 <newsham> ie. no females involved? ;-)
22:27:11 <Cale> i.e. not some nonstandard system where you drop LEM or contrapositive
22:27:23 <newsham> you math people are no fun :)
22:28:09 <Cale> http://homepages.cwi.nl/~jve/HR/HR.ps.gz is still up... that's odd
22:29:00 <newsham> heh.  oops..  i thought they just had the first chapter up
22:29:13 <Cale> well, only the first chapter is linked
22:29:28 <Cale> but my old bookmark still works from when the book was in beta
22:29:34 <Korollary> newsham: if you're reading math, you are math people, too
22:30:31 <newsham> korollary: see, again with the logic.
22:31:04 <Korollary> newsham: well, at least 'in the process of conversion' heh
22:31:33 <newsham> i'm just a programmer who made a wrong turn.
22:31:43 <Cale> soon, you too will be a humourless blob
22:32:03 <Cale> it is only a matter of time :)
22:32:13 <Korollary> that's not necessarily true. If I was not too tired on this Friday night, I would drag this conversation to the gutter.
22:32:13 <newsham> the "not funny" opening in my clique has already been filled by another phd
22:32:13 <JohnMeacham> /meacham
22:32:16 <JohnMeacham> doh.
22:32:22 <JohnMeacham> that doesn't search does it.
22:32:47 <Korollary> hmm. searching for your own name...
22:32:53 <newsham> I'm trying to sucker him into haskell too :)
22:32:59 <newsham> korollary: "vanity search"
22:33:25 <Korollary> When I google myself, I am usually disappointed. So, I don't do it anymore.
22:34:53 <Cale> Haskell is a great thing to sucker people into. It's a good way to make mathematicians think practically, and make practitioners think mathematically :)
22:35:19 <newsham> i'm interested in code correctness, so thinking mathematically has some appeal.
22:35:46 <newsham> the fact that algorithms are specified in terms of their outcome and not the process is also somewhat interesting..  (I'm not from a functional background)
22:35:55 <Cale> equational reasoning about code is really nice
22:35:57 <Korollary> newsham: thus you have no ground to deny the fact that you are a math person. Just come out of the closet.
22:36:11 <newsham> i'm curious if it has lead to better parallelization
22:36:36 <Cale> it may eventually do so
22:36:58 <Cale> have you seen Control.Parallel.Strategies?
22:37:18 <newsham> no.  i'm still somewhat green when it comes to haskell.. there's lots i havent seen
22:37:42 <Korollary> A lot of processes for some reason do not pay attention to describing "what" is being done in enough detail. This happens in code and in documentation. Haskell seems to be very clear about the "what" part.
22:38:09 <Cale> http://research.microsoft.com/Users/simonpj/Papers/strategies.ps.gz
22:38:15 <JohnMeacham> well, I tend to only look on here once a day or so and search if anyone was trying to get my attention.
22:38:44 <Korollary> JohnMeacham: We're just messing with you, dude. Is jhc 20x faster than ghc yet ?
22:39:22 * Korollary is watching NUMB3RS and the chick says that she wants to get a "2nd" PhD (physics).
22:39:35 <Korollary> this show should be on scifi
22:39:52 <newsham> "haskell on a shared memory multiprocessor" jul 2005.  interesting
22:40:48 <newsham> This paper describes a full-scale implementation of shared-memory parallel Haskell, based on the Glasgow Haskell Compiler. Our main technical contribution is a lock-free mechanism for evaluating shared thunks that eliminates the major performance bottlenec
22:41:22 <Cale> newsham: also, for concurrency, check out STM
22:41:58 <Cale> http://research.microsoft.com/users/simonpj/papers/stm/stm.pdf
22:44:11 <newsham> danke
22:45:28 <Cale> it's a mechanism for safe thread communication which guarantees various nice compositionality properties with respect to correctness
22:45:54 <Cale> if you have some programs which don't deadlock, you can put them together and still guarantee that they don't deadlock
22:46:26 <newsham> *nod*
22:50:22 <newsham> thanks for the help and the references
23:01:36 <dons> @hoogle a -> b
23:01:38 <lambdabot> Prelude.id :: a -> a
23:01:38 <lambdabot> Prelude.seq :: a -> b -> b
23:01:38 <lambdabot> Prelude.max :: Ord a => a -> a -> a
23:01:43 <dons> much nicer :)
23:02:36 <Korollary> neat
23:09:40 <luqui> what's different?
23:15:21 <m3ga> @where
23:15:21 <lambdabot> I can not handle empty facts.
23:15:27 <m3ga> @version
23:15:28 <lambdabot> lambdabot 3p145, GHC 6.5.20050806 (Linux i686)
23:15:28 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
23:16:15 <dons> @where fps
23:16:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
23:16:25 <dons> bad message on empty @where, fixing..
23:18:15 <dons> @dynamic-reload where
23:18:16 <lambdabot> module reloaded
23:18:17 <dons> @where
23:18:17 <lambdabot>  @where <key>, return element associated with key
23:18:20 <dons> :)
23:18:29 <m3ga> @where lambdabot
23:18:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:18:36 <m3ga> cool!!!
23:18:50 <dons> thanks :)
23:18:53 <dons> @fact lambdabot
23:18:54 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female.
23:18:59 <dons> apparently :/
23:19:07 <m3ga> dons: you're at unsw?
23:19:10 <dons> @vixen are you female?
23:19:10 <lambdabot> i truely am
23:19:15 <dons> m3ga, yes!
23:19:30 <m3ga> I'm a friend of ozone. know him?
23:19:42 <Cale> yep
23:19:48 <dons> oh my! yes, i used to sit next to him when he did his phd..
23:20:08 <Cale> well, from this channel :)
23:20:11 <dons> we had the same supervisor
23:20:22 <luqui> @vixen what is vixen?
23:20:23 <lambdabot> i'm a vixen
23:20:25 <dons> how do you know ozone?
23:20:30 <dons> through unsw?
23:20:37 <luqui> @vixen what do you do?
23:20:38 <lambdabot> let's don't talk about that
23:20:53 <m3ga> no, through people at csiro. He actually got me onto ocaml first because it suited what I was doing at the time a little better.
23:21:04 <m3ga> i'm now starting to take a look at haskell as well
23:21:04 <dons> ah, right. cool!
23:21:12 <dons> @karma+ ozone
23:21:12 <lambdabot> ozone's karma raised to 1.
23:21:25 <dons> m3ga, well it's the language of choice :)
23:21:28 <dons> welcome :)
23:21:50 <m3ga> yeah, yeah :-) It still seems a little weird to me, even after ocaml.
23:22:02 <dons> how so?
23:22:21 <dons> have you done the lambdabot tour yet?
23:22:25 <dons> @type map
23:22:26 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
23:22:29 <dons> @eval map (+1) [1..10]
23:22:30 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
23:22:32 <dons> @index map
23:22:32 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
23:22:38 <dons> @google haskell
23:22:39 <lambdabot> http://www.haskell.org/
23:22:47 <m3ga> :-)
23:23:08 <dons> @pl \f x -> f (f x)
23:23:09 <lambdabot> join (.)
23:23:37 <Cale> heh, cute
23:24:01 <m3ga> weird basically means that ocaml doesn't have monads
23:24:36 <Cale> monads are really quite nice :)
23:24:42 * luqui agrees
23:24:59 <m3ga> yes, after you understand wtf the are ;-)
23:25:07 <luqui> they are quite difficult to understand at first--at least they were for me--but they're way cool once you do
23:25:13 <Cale> well, have you read MonadsAsContainers? :)
23:25:33 <m3ga> exactly, I'm still in the before stage
23:25:36 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
23:25:53 * luqui used the List monad as his mental template
23:26:01 <luqui> once I grokked that, everything else just fell into place
23:26:05 <dons> actually, ozone and I co-authored a paper, I'd forgotten that
23:26:07 <Cale> yes
23:26:19 <Cale> the list monad is really one of the best examples
23:26:47 <m3ga> Cale: MonadsAsContainers I haven't read. some of the other I have.
23:27:01 * m3ga puts MonadsAsContainers on the reading list
23:27:04 <dons> i think the container metaphor is the leading edge of how to teach monads :)
23:27:39 <Cale> m3ga: I'm plugging it partly because I wrote it -- that was my rationalisation of monads, and I've successfully taught how monads worked to 11 year old kids with it :)
23:27:59 <ibid> Cale: even IO? :)
23:28:15 <Cale> ibid: yeah, we did some IO
23:28:33 <ibid> IO as container is a funky concept
23:28:41 <ibid> not sure it's more help than hindrance :)
23:28:54 <ibid> for many other monads, container does work
23:28:54 <m3ga> Cale : cool, I really ought to be able to understand it then. I did manage to go from C,C++,Python to reasonably pure fp Ocaml in a week or so.
23:30:10 <Cale> It's a little abstract, but basically once you're used to the container analogy, you can think of IO containers as black box containers, where it's possible to connect them up in the various usual ways, but not really to see inside.
23:30:16 <luqui> m3ga, once you know Haskell, you can move to Curry, and then you'll have all three paradigms covered :-)
23:31:00 <ibid> Cale: ie. not really containers but neither having any container-contradictory properties either :)
23:31:07 <m3ga> lukego: curry?
23:31:12 <Cale> ibid: right
23:31:23 <m3ga> luqui: curry?
23:31:34 <lukego> yes please.
23:31:57 <luqui> curry is a logic language (like prolog) derivative of haskell
23:31:59 <luqui> it's quite nice
23:32:23 <m3ga> ahh, ok. Used prolog at uni about 15 years ago :-)
23:32:55 <luqui> oh, so you already have all three paradigms covered
23:33:07 <luqui> (except curry kicks prologs butt to the moon)
23:34:16 <m3ga> luqui: i used scheme at uni too, but never really "got it". I think I needed to be a more experienced programmer to really appreciate fp. Same probably goes for logic.
23:34:51 <m3ga> Are yacc/bison basically logic programming?
23:35:54 <dons> hmm. nope. they're domain specific languages for generating lexers and parser tables
23:36:13 <dons> oh sorry, not lexers. that's lex
23:36:44 <dons> but the language is basically declarative, I guess
23:36:56 <m3ga> i realised they are DSLs, but I thought that since you specify goals it was a little like logic programming (its been a while).
23:37:47 <Cale> m3ga: have you seen Parsec? :)
23:38:27 <Cale> http://www.cs.uu.nl/~daan/download/parsec/parsec.html
23:39:13 <m3ga> yep, ozone showed me. I wasn't that blown away, mainly because I'm so comfortable with flex/bison.
23:39:42 <m3ga> @karma+ ozone
23:39:43 <lambdabot> ozone's karma raised to 2.
23:40:13 <ibid> if one considers the actions as data and not code, then yacc/bison is declarative
23:40:25 <ibid> otherwise, the appropriate term is "a mess" :)
23:40:37 <m3ga> :-)
23:40:42 <Cale> well, though I'd written some parsers with parser generators, it struck me as very cool that parsers were values that one could build at runtime
23:41:50 <ibid> what i'd like to see is a parser combinator library that used GLR as the underlying algorithm
23:42:02 <Cale> One can map a function which builds parsers from values over a list, and then fold <|> over that list to get a parser which parses any one of them (which, being useful, is called choice)
23:43:06 <ibid> i suppose as an arrow library it might even be possible
23:43:12 <ibid> (but certainly not as monadic)
23:43:27 <vegai> what does Einar's arrow parser thingy use?
23:43:46 <vegai> http://www.cs.helsinki.fi/u/ekarttun/PArrows/
23:46:02 <stefanw> ibid: do you think you can program them, given the LR parser work somewhat "counter intuitive"?
23:46:47 <ibid> stefanw: by "program them", do you mean write the library or use the library?
23:46:54 <ibid> anyway, the answer to both is yes
23:47:24 <ibid> vegai: looks like a simple backtracking recursive descent, but i'm not sure
23:47:41 <vegai> probably whatever Parsec uses
23:49:33 <ibid> of course, a GLR parser cannot be particularly lazy
23:50:02 <ibid> but in many situations that's not necessarily a bad thing
23:53:34 <m3ga> dons: i'm trying to build lambdabot and I get : Could not find module `System.Plugins.Load'
23:53:47 <m3ga> i'm on debian unstable, usging ghc-6.4
23:56:05 <Cale> m3ga: might need to install hs-plugins
23:58:18 <m3ga> Thanks. On debian it looks like its called libghc6-plugins-dev. however it doesn't install because os messed up dependancies.
23:58:35 <m3ga> so whats the state of Haskell on Debian?
23:58:46 <Cale> hmm
23:59:02 <Cale> I don't have plugins installed via that package, but usually things are okay
23:59:35 <ibid> m3ga: unstable is called that for a reason
23:59:37 <Cale> darcs get --set-scripts-executable http://www.cse.unsw.edu.au/~dons/code/hs-plugins
23:59:58 <ibid> m3ga: stable is stable, though it is always behind of the leading edge
