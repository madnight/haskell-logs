00:10:54 <jyp> Is dons or shapr around ?
00:13:35 <Cale> http://catb.org/~esr/jargon/html/Q/quux.html -- I like the genitive plural form "quuxuum"
00:41:20 <dons> morning
00:42:12 <basti_> dons: hey... jyp asked for you
00:42:26 <dons> I see
00:42:36 <jyp> hello dons
00:42:45 <dons> hey jyp, what's up?
00:43:20 <jyp> I was wondering...
00:43:33 <jyp> lets suppose I wish to contribute stuff to yi
00:43:46 <dons> this is a good idea :D
00:43:58 <jyp> should I use scannedinavian base or 'yours'
00:44:00 <jyp> ?
00:44:08 <dons> ah! interesting question
00:44:17 <dons> all work iis now focused on scannedinavian.com
00:44:39 <jyp> I thought hIde stuff was newer and better... but after looking it seems sort of broken
00:44:48 <dons> when I get back to .au, I will be moving the .au yi into an ncurses branch, and also mirroring scannedinanvian yi
00:45:03 <dons> itt is a bit broken atm, i'm rewritting from scratch using gtk
00:45:05 <jyp> most of the editor is disabled :p
00:45:12 <dons> but have been distracted this week by icfp
00:45:20 <jyp> oh that's cool ;)
00:45:51 <tuomov> so, what's going on with yi these days?
00:45:52 <dons> however, you should certainly consider working on the yi in scannedinavian as that's where the action is at these days :D
00:46:10 <dons> tuomov, working on version 2. using gtk (but also will keep ncurses of course)
00:46:14 <dons> version 0.2
00:46:24 <tuomov> syntax hl etc?
00:46:37 <dons> yep. we alreaddy have this now (in the gtk versoin) + typechecking
00:46:40 <dons> using ghc-api
00:46:49 <dons> thank to the great hacking of Lemmih
00:47:00 <tuomov> how about ncurses?
00:47:01 <dons> hmm, screeshot somewhere? let me see...
00:47:09 <tuomov> I will _not_ touch gtk crap
00:47:15 * Lemmih is having problems with the typechecking.
00:47:24 <tuomov> and editing in a terminal is so much more convenient...
00:47:37 <dons> tuomov, I know, and agree with your views on uis
00:47:40 <basti_> Lemmih: with typechecking in itself, or with types that don't check?
00:48:01 <dons> tuomov, so don't worry :)
00:48:04 <Lemmih> basti_: with the typechecking in itself.
00:48:16 <basti_> oh
00:48:51 <dons> tuomov, though i'm looking for a higher level ui api over ncurses
00:49:02 <Lemmih> basti_: Issues with the multi-threading.
00:49:28 <dons> Lemmih, you never answered my questoin about how you pass a gtk buffer over to ghc' lexer?
00:49:32 <basti_> you're working at a multi-threaded typechecker?
00:49:34 <dons> oh, sorry, you did.
00:49:37 <dons> it was a String :/
00:49:46 <dons> but that's easy to fix I think
00:49:47 <basti_> ah youre talking about yi
00:49:54 <dons> hIDE + yi
00:49:57 <dons> more correctly
00:50:06 * basti_ nods
00:50:08 <dons> though yi also will remain standalone vim-ish style editor
00:50:16 <tuomov> it would be nice infact, if one could replace a terminal with any window launch from within it, and be able to switch back to the command line with ^Z...
00:50:17 <dons> vim-ish in the sense of not emacs
00:50:18 <basti_> thats good.
00:50:29 <Lemmih> dons: Yeah, that should be very easy to fix. I'm not currently concerned with performance.
00:50:33 <basti_> you mean in terms of size and load time? :P
00:50:42 <dons> yep, that's fine Lemmih
00:50:55 <tuomov> at the moment its not doable by the wm, though, as apps don't tell where they were were launched from
00:50:57 <dons> basti_, no more in terms of too many features. that's for hIDE
00:51:04 <basti_> heh
00:51:08 <dons> tuomov, inteeresting idea.
00:51:16 <tuomov> the WM can't easily distinguish between a program launched from a terminal and a program launched e.g. by the wm itself
00:51:33 <dons> yeah.
00:52:23 <tuomov> 'bg' could detach the window into the background..
00:52:34 <tuomov> e.g. a new tab in the frame in ion
00:52:48 <dons> oh, that's cool
00:53:22 <dons> hey tuomov, i'll be in .fi tomorrow :)
00:53:34 <dons> only for a few hours though
00:53:49 <tuomov> probably too far from where I live.. :(
00:54:48 <dons> actually, i have only 1.5 hrs :/
00:54:52 <dons> hey nibro.
00:55:07 <nibro> hey, I overslept a bit today... ;-)
00:55:30 <dons> you still in .ee ??
00:55:33 <nibro> my plane leaves at 2pm, so I didn't bother to set the clock
00:55:36 <dons> ah, right
00:55:38 <nibro> aye, in my hotel room
00:55:42 <nibro> leaving now :)
00:56:42 <nibro> I thought I would wake up early anyway, but it seems I missed you at breakfast...
00:56:55 <dons> yeah, I ate about 30 mins ago
00:57:11 <nibro> ah, I thought you were earlier than me :)
00:58:17 * nibro waves goodbye to Tallinn
00:58:28 <dons> see you nibro!
00:58:33 <nibro> aye, in Portland :)
00:58:40 <dons> yeah, portland :)
01:00:20 <dons> tuomov, if you have any interesting ui or editing support ideas, feel free to stick them on http://www.haskell.org/hawiki/hIDE
01:00:42 <dons> or http://www.haskell.org/hawiki/hIDE_2fDesign
01:02:30 <dons> you could sticck a link to vis ;) then I'd be sure to read it a few more times.
01:41:31 <Oejet> Good morning.
01:42:52 <Lemmih> Hi.
01:44:17 <Lemmih> dcoutts: ping.
01:45:32 <autrijus> metaperl: http://shootout.alioth.debian.org/benchmark.php?test=binarytrees&lang=all&sort=fullcpu
01:48:50 <musasabi> morning
01:49:04 <Oejet> autrijus: Why is Clean so fast?
01:50:05 <autrijus> metaperl: those are reall really sound bites though. it's not difficult to write C++ that beans GHC on microbenchmarks; similarily it's easy to write far more concise oneliners in perl, or abuse Ruby to metaclass to reach utmost flexibility, etc
01:50:14 <autrijus> s/reall/all/
01:50:31 <autrijus> s/bean/beat/
01:51:05 <autrijus> but my point is that it is possible -- and its saying a lot -- for haskell, as a general purpose language, to have an advantage over other languages at their strenghts.
01:51:45 <autrijus> Oejet: I have no idea.
01:51:59 <cjs> Well, I wonder how good some of these are. The Java version is hilarious.
01:52:21 <autrijus> cjs: feel free to submit a better version :)
01:52:35 <cjs> Err...I think there's a reason I don't do Java any more.
01:52:56 <autrijus> heh :)
01:53:15 <cjs> God, even Ruby's killing me.
01:53:19 <cjs> Thus my presence here. :-)
01:53:45 <Kirby> Autrijus: are you the Autrijus associated with pugs? I'm looking at your code to get ideas for using Parsec for parsing source code. (Honestly, though, I'm not getting very far yet.)
01:54:08 <autrijus> Kirby: greetings.
01:54:34 <autrijus> I'd suggest you starting with a more minimal language first
01:54:48 <Kirby> Yes, I do have an idea for a minimal language to parse.
01:54:51 <autrijus> Harrorth: http://perlcabal.org/~nothingmuch/harrorth/
01:54:57 <autrijus> Baskell: http://www.cs.mu.oz.au/~bjpop/code.html
01:55:48 <Kirby> + - / * % = == < > ; , if else while for return .... a limited subset of C (minus some operators and keywords and minus the entire library) is what I'm looking to parse.
01:56:18 <Pistahh> autrijus: btw I started messing (again) with haskell cca 2 weeks ago after reading the interview with you. :)
01:56:50 <autrijus> Pistahh: ooh :) *glad*
01:56:56 <autrijus> Kirby: you want Parsec.Expr
01:57:01 <autrijus> it does everything for you already.
01:57:12 <autrijus> so your parser should be just a giant operatortable
01:57:16 <autrijus> easily 10 lines
01:57:17 <autrijus> that's all :)
01:57:21 <Kirby> heh
01:57:21 <JohnMeacham> howdy howdy.
01:57:41 <JohnMeacham> Who here likes 'ween'?
01:59:46 <autrijus> Kirby: look at baskell -- it's probably close
02:05:16 <Pistahh> JohnMeacham: I only like helloween, if it matters at all..
02:09:32 <Kirby> autrijus: thanks for the pointer, I've compiled baskell and will look at the source.
02:10:42 <autrijus> cool, have fun
02:23:15 <dons>  re
02:23:27 <dons> afternoon autrijus, how's code?
02:26:31 <cjs> So there's one burning question the answer to which I cannot find in any of my books, any of the on-line tutorials, or anywhere.
02:26:49 <dons> what is this question? :)
02:27:33 <Lemmih> cjs: 42.
02:28:03 <cjs> Really? Boy, did I get that wrong!
02:28:23 <cjs> And all this time, I'd been pronouncing it, "hasKELL."
02:29:12 * dons walks half way across tallinn's cbd, and still has wifi
02:30:51 <cjs> But really, how do you pronounce it? Is the emphasis on the first or the second syllable?
02:31:10 <cjs> (I think this probably takes the cake for stupid language questions, but....)
02:31:10 <dons> HASK-ell
02:31:30 <cjs> So that last e, it's a schwa?
02:32:09 <dons> 'ell' as in 'hell'
02:39:20 <cjs> So it's not. Ok.
02:39:24 <dons> @eval 1 + 2
02:39:24 <cjs> Damn, I'm making progress!
02:39:28 <lambdabot> 3
02:39:41 <cjs> You can do that?
02:39:49 <cjs> @eval 2 * 3
02:39:51 <lambdabot> 6
02:39:55 <cjs> Woah!
02:39:59 <dons> @eval x
02:40:00 <lambdabot> <irc>:1:0: Not in scope: `x'
02:40:02 <cjs> Eval [1..5]
02:40:10 <cjs> @eval [1..5]
02:40:11 <lambdabot> [1,2,3,4,5]
02:40:13 <Igloo> Don't get pronounciation advice from dons. He doesn't even know how to pronounce the name of his own editor  :-)
02:40:19 <dons> :p
02:40:19 <basti_> dont eval [1..]
02:40:29 <cjs> How can I not?
02:40:36 <cjs> (Damn, he saw where that was going.)
02:40:42 * basti_ laughs
02:40:49 <cjs> @eval let x = 3 in x + 2
02:40:51 <lambdabot> 5
02:40:52 <Igloo> I think I say a schwa
02:41:05 <dons> ah, maybe Igloo, yes. some people do
02:41:26 <cjs> @eval let f a = a * 2 in a 6
02:41:27 <lambdabot> <irc>:1:19: Not in scope: `a'
02:41:36 <cjs> Bah.
02:41:44 <cjs> @eval let f a = a * 2 in f 6
02:41:47 <lambdabot> 12
02:42:06 <cjs> @eval let f a = f (a * 2) in f 4
02:42:07 <lambdabot> <irc>:1:42:
02:42:07 <lambdabot>   Ambiguous type variable `a' in the constraint:
02:42:07 <lambdabot>   `Show a' arising from use of `show' at <irc>:1:42-45
02:42:07 <lambdabot>   Probable fix: add a type signature that fixes these type variable(
02:42:07 <lambdabot> s)
02:42:25 <dons> hmm. still need to work on these regexes a bit.
02:42:34 <dons> far too verbose errors
02:42:40 <cjs> Sorry, I just have to.
02:42:43 <cjs> @eval [1..]
02:42:45 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
02:42:45 <lambdabot> 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
02:42:45 <lambdabot> 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
02:42:45 <lambdabot> 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,
02:42:45 <lambdabot> 95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
02:42:47 <lambdabot> 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,
02:42:49 <lambdabot> 130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,
02:42:49 <cjs> Oh no!
02:42:51 <lambdabot> [24 @more lines]
02:43:07 <basti_> ...
02:43:08 <dons> I alway wonder what people think will happen.
02:43:14 <cjs> How do destroy an IRC session in one easy step.
02:43:21 <cjs> I thought it would keep going....
02:43:21 <autrijus> they think you will run out of bits, probably
02:43:30 <dons> hehe
02:43:55 <dons> but if they know about laziness..
02:44:23 <cjs> Laziness, impatience and hubris.
02:44:49 <dons> I'd like to write an impatient functional language
02:45:18 <dons> autrijus, can you add support for impatience to pugs?
02:45:40 <goron> You mean like increasing voltage levels?
02:45:51 <McVoy> Evaluation ahead of time?
02:46:06 <dons> no no, that's speculation.
02:46:14 <cjs> It's like taking out "do". The whole point of "do" is, "be patient, your time will come."
02:46:15 <dons> i don't have a semantics for impatience yet ;)
02:46:38 <dons> i'm not sure that's what 'do' is for cjs. more likely 'let'
02:46:40 <cjs> Otherwise everything would happen at the same time, and the output would be, well, interesting.
02:46:57 <dons> oh, maybe I see what you mean
02:46:58 <goron> "A static semantics for Impatience in Haskell"
02:47:04 <cjs> I think so. Time has no meaning outside of "do".
02:47:15 <dons> ah, sequenceing, yep. got you
02:47:25 <goron> I am looking forward to that publication.
02:47:33 <dons> goron, yeah, that'd be a great paper.
02:47:42 <Igloo> I think impatient semantics should be that if any function takes "too long" to return a result, the implementation should invent a value of the right type and return that
02:47:52 <cjs> Anyway, I'll look for the paper later on LtU. Meantime, it's Saturday night, party time, I'm going to go out and have fun. Ta ta!
02:47:55 <dons> but maybe the dynamic semmantics would be more interesting.
02:48:03 <Igloo> (returning undefined is frowned upon)
02:48:04 <dons> Igloo, yeah!
02:48:06 <dons> that's cool.
02:48:07 <goron> C already has that feature I guess.
02:48:41 <goron> Since there's nothing that's "as fast as Cee", it must have it ;)
02:48:42 <dons> ok. so then we just need  to come up with a good way to produce non-bottom values for types
02:48:48 <dons> so, QuickCheck generators perhaps
02:48:48 <musasabi> The ICFP paper about bit syntax looked interesting.
02:48:56 <dons> musasabi, definitely
02:49:16 <Igloo> It's fairly simple - just pick constructors at random recursively
02:49:17 <goron> musasabi: For Haskell?
02:50:05 <dons> recursively decending into the fiields of the constructor?
02:50:17 <Igloo> And it would be faster than C (for any program that takes more then 10s, o whatever, to run!)
02:50:27 <Igloo> Right
02:50:43 <McVoy> musasabi: Link, please?
02:50:47 <musasabi> goron: It was designed with Haskell in mind, but implemented for a small haskell-like language.
02:50:47 <Igloo> QC can't do that (even ignoring the constraints not represented inthe type), but the impl could
02:50:51 <dons> ok. that's option 1.  then I think we could implement class Impatient so users could either derive (using Igloo's scheme) or write an instance
02:50:58 <autrijus> dons: sure, impatience is fundamental in perl
02:51:03 <autrijus> also is laziness, in fact
02:51:08 <autrijus> we're still working on the hubris bit
02:51:10 <goron> musasabi: So it's stolen from Erlang. Not that I care. I think it's a good feature.
02:51:13 <musasabi> McVoy: The ICFP proceedings (I just have looked at the paper form).
02:51:18 <dons> oh, i'm not sure about that ;)
02:52:18 <dons> Igloo, so impatience is good for those monte carlo (is that the right one?) algos
02:52:20 <Igloo> So by default you would get the above impatience, but you could write a class to for overriding impatience!
02:52:29 <dons> we can have a language that *always* returns a value
02:52:32 <musasabi> goron: It was kind of weird - they didn't try to copy the erlang thing but do their own thing. Personally I would have liked a better comparison with the Erlang bit-syntax.
02:52:43 <dons> yeah, if you're impatient about  the impatienc
02:52:57 <musasabi> Why not simply lift impatient computations into the Maybe monad?
02:53:15 <goron> Anyone into VLSI floor planning?
02:53:17 <Igloo> The problem with ICFP being in Sept/Oct is it'snever on Apr 1  :-)
02:53:24 <dons> so true.
02:53:56 <dons> I tihnk impatient languages would also be great for AI and icfp contests
02:54:00 <Igloo> Of course, if your overiding impatience is too slow the impl will get impatient and have to fall back to generic impatience
02:54:06 <dons> right.
02:55:00 <goron> I think we solved the AI problem. And all the time it was so obvious. We missed impatient languages. How could we ever have missed that?
02:55:19 <dons> also, I'd like to have a -fhow-bored-am-I to tweak the impatience value
02:55:55 <dons> forget search pruning, just get impatient!
02:56:03 <Igloo> So if we right an impatience compiler in itself then if you write too large a program you will find the result of compilation is a random binary
02:56:14 <dons> hehe. good.
02:56:30 <goron> dons: good one. :)
02:56:44 <dons> well, it should have the type Program at least
02:57:01 <dons> but it will be just random abstract syntax generated
02:57:18 <Igloo> Right
02:57:20 * goron hates "registration" for websites with papers, although I should have access to a lot of them....
02:57:23 <dons> unless you write an instance to always produce a tic-tac-toe program
02:57:44 <Igloo> I think "exec nethack" would be canonical
02:57:53 <dons> oh, that's good
02:58:08 * Igloo tries to remember what did that. Was it pragma in gcc?
02:58:31 <Igloo> Or did that run a tetris clone?
02:59:55 <Igloo> Ah, it had a small list including nethack to try: http://en.wikipedia.org/wiki/Undefined_behaviour
03:01:45 <dons> oh that is too much fun
03:01:59 * dons feels let down by `undefined' i nghc
03:02:04 <dons> @eval undefined :: ()
03:02:07 <lambdabot> Prelude.undefined
03:02:10 <dons> bah
03:02:43 <Igloo> It would have to use uPIO to od anything interesting
03:07:33 <goron> Sorry! The wiki is experiencing some technical difficulties, and cannot contact the database server: .
03:07:56 <goron> Is that Undefined_behaviour? :P
03:24:22 <JohnMeacham> I can not repeal the words of the golden eel
03:24:57 <dons> oh my
03:26:38 * Igloo mutters at GADT type errors
03:26:49 <JohnMeacham> The goin' gets tough from the getgo go man go
03:34:29 <JohnMeacham> Hey, I have this theory about haskell. but in order to express it, I need a constant. like 'omega' or something. but that is taken. how does one choose an appropriate name for a meta-computational constant?
03:34:51 <JohnMeacham> I hate to say it. but I need a blog.
03:35:02 <shevegen> hehe
03:43:46 <xerox> Good, very good, morning.
03:47:49 * xerox toasts a chinotto to celebrate the Good(TM) Morning.
04:12:58 <dcoutts> Lemmih, pong
04:13:18 * dcoutts is nursing his hangover
04:15:37 <dcoutts> yay, ghc-6.4.1 finnishied building after 7+1/2 hours on my old 500Mhz sparc box
04:16:33 <dcoutts> ooooh, ghci works! (it didn't with verson 6.2.2)
04:24:30 <shapr> musasabi: ayt?
04:33:15 <shapr> dons: Man, I want a sound file of SPJ saying "Haskell" just so I know what it really sounds like.
04:34:47 <ape> shapr: is your website down?
04:36:29 <shapr> ape: Nope, but .org has weird dns problems. You can try the equivalent address with .com.
04:37:19 <ape> ah sweet thanks works
04:37:36 <ape> is this a problem with just your .org or with all the .org?
04:38:03 <goron> Is DVI "superior" to PDF/PS in some way?
04:38:12 <shapr> Seems to be just my .org. The root servers won't update my entry.
04:38:15 <shapr> Dunno why.
04:38:25 <goron> I think they just hate you.
04:38:35 <goron> hi shapr
04:39:26 <shapr> hoi goron
04:39:30 <shapr> hoe gaat het met jou?
04:40:02 * shapr goes shopping
04:40:07 <goron> Well, my Swedish skills haven't improved that much.
04:40:13 <shapr> tyv√§rr :-)
04:40:16 <shapr> quel dommage
04:40:22 <goron> I am a bit busy.
04:40:35 <shapr> I'm a bit hungry. bbl.
04:40:43 <ape> shapr: for SDL, SDL-0.2.tar.gz is the only file i need to download?
04:54:40 <sylvan> where are the logs for this channel?
04:55:21 <basti_> see topic
04:55:53 <sylvan> it's not in the topic!
04:56:02 <basti_> "logs:
04:56:03 <basti_> http://meme.b9.com/cview.html?channel=haskell&date=today"
04:56:08 <basti_> ...not?
04:56:29 <sylvan> ah, my irc client isn't cooperating with me
04:58:15 <sylvan> Dammit. Why doesn't Data.Map have a Read instance? There must be some reason for why someone said "Okay, we'll have Show, but not Read"
04:59:00 <basti_> humh.
04:59:59 <sylvan> I would've really needed it right about now.. Instead I'll have to serialise it myself into some oddball format..
05:00:29 <basti_> why don't you read lists of key/value tuples and de-list them?
05:00:36 <wilx> I guess they just don't want to force people to use some imperfect format.
05:01:04 <Lemmih> dcoutts: I got some questions about ideShell.
05:01:37 <sylvan> basti_ that's what I do now...
05:02:07 <sylvan> basti_, but the program consists of "read database from disk, do a single search, print result" so it would be nice if it was stored in some sort of structured way
05:02:24 <basti_> i share your pain
05:02:26 <sylvan> And I really don't want to have to use HaskellDB for something this simple =)
05:04:30 <Igloo> Read Map was recently added to CVSI Think
05:05:55 <sylvan> Igloo, oooh!!! I'll have to get that then!
05:40:20 <Lemmih> dcoutts: You want the editor to edit other things than just a text buffer, right?
05:40:34 <Igloo> Like what?
06:03:46 <metaperl> Haskell-Dylan comparison blogged by me: http://sequence.complete.org/node/102
06:06:53 <goron> metaperl: It would be nice if you would actually had a conclusion of some sort.
06:12:10 <dcoutts> Lemmih, the idea with the UI is that there can be various kinds of viewer/editor pages and the browsers allow the user to select between them
06:12:34 <dcoutts> the main example of such a page would be a text editor and a file
06:13:00 <dcoutts> but other examples include viewing html documentation
06:13:27 <dcoutts> or UI pages for configuration / settings
06:13:47 <xerox> ..or humasect's Graph-visualization of code? ;-)
06:13:54 <Lemmih> CommonSense needs to be aware of the text buffer editors (or maybe the other way around).
06:14:23 <dcoutts> Lemmih, right, so the CommonSense will only be attached to the editor pages
06:14:48 <goron> I hate author = {A b and B c and D d} in a Bibtex entry. How can I concert this to {A b, B c and D d} while maintaining the property of being valid bibtex?
06:14:56 <goron> er I have :P
06:15:04 <Lemmih> dcoutts: So DemoEditor and hide-yi should depend on CommonSense?
06:15:20 <dcoutts> Lemmih, note sure, it might be the other way around
06:15:45 <dcoutts> Lemmih, I suspect that CommonSense should just depend on Yi
06:16:03 <Lemmih> Why should CommonSense depend on Yi?
06:16:06 <dcoutts> and the DemoEditor will not use it
06:16:33 <goron> Howly Randomness!
06:16:34 <dcoutts> Lemmih, ok how do you see it interacting?
06:16:54 <Lemmih> CommonSense just needs a TextBuffer.
06:17:07 <dcoutts> ok
06:17:21 <goron> I hate these random implementations...
06:17:26 <dcoutts> so it doesn't hook into Yi, but directly into a GtkTextBuffer ?
06:17:36 <Lemmih> Yeah.
06:17:55 <dons> re
06:18:11 <dcoutts> hmm, I think it'd be better long term to have it use interfaces provided by Yi
06:18:22 <dcoutts> but anyway
06:18:29 <Lemmih> Why?
06:19:06 <dcoutts> but even for now, I still think it depends on Yi, just so it can hook into Yi's TextBuffer
06:19:25 <Lemmih> ):
06:19:31 <dons> hmmI thought Yi was going to depend on CommonSense
06:19:39 <dcoutts> oh ok
06:19:47 <dcoutts> well maybe it is the other way around :-)
06:19:53 <dons> is that right Lemmih?
06:20:18 <Lemmih> dons: Yep. There'll be a Yi plugin for CommonSense which will depend on Yi and CommonSense.
06:20:23 <dons> right.
06:20:26 <dcoutts> I thought the point was it is a plugin and so Yi does not depend on it
06:20:34 <dcoutts> oh ok
06:20:53 <dcoutts> Lemmih, right that make sense
06:21:00 <dons> Yi standalone can use it, orthe Yi plugin will use it. The yi library won't depend on it I thinkk.
06:21:07 <dons> i.e. no depends in the yi cabal file
06:21:17 <dons> just the yi executable, or the yi-hide plugin
06:21:48 <dcoutts> dons, so have you got time to look at making Yi fix into the UI?
06:22:16 <dons> not yet, just sight seeing today :) i start work again on Tuesday
06:22:23 <dcoutts> ok
06:22:33 <dcoutts> I've written another instance of the EditorPage abstraction, for html docs
06:22:44 <dons> excellent
06:22:54 <dcoutts> however it shows up a limitation in the current EditorPage interface
06:23:10 <Lemmih> How should EditorPage's expose their GtkTextBuffer (if any)?
06:23:52 <dcoutts> the EditorPage interface is only for connecting with the UI, you can use any other direct interface for connecting with Yi
06:24:46 <dcoutts> you probably want to register a callback in Yi to allow you to attach your CommonSense thing when Yi loads a suitable file type (eg .hs)
06:24:54 <Lemmih> Yi? I don't want CommonSense to depend on Yi.
06:25:12 <dcoutts> well your glue plugin
06:25:26 * Lemmih wants CommonSense in DemoEditor.
06:25:50 <dcoutts> ok that should be possible too
06:25:55 <xerox> http://www.einradladen.net/catalog/product_info.php?cPath=2&products_id=167
06:26:06 <xerox> I think I'll get this one!
06:26:06 <Lemmih> The CommonSense plugins will just register them selves with CommonSense. They shouldn't touch anything else.
06:26:30 <dcoutts> but at the moment there is no general text editor interface that both Yi & the DemoEditor support
06:26:59 <dcoutts> I suggest a quick hack to make the DemoEditor directly depend on CommonSense
06:27:32 <dcoutts> but the better solution is for the editor to have a hook that you can register with
06:27:37 * Lemmih wants CommonSense in every EditorPage which offers a GtkTextBuffer.
06:27:54 <dcoutts> then you need an interface for the text editors to implement
06:29:05 <Lemmih> And it's possible to have several different EditorPage's running at the same time?
06:29:14 <dcoutts> yep
06:29:34 <dcoutts> each window will display at most one of them at a time (probably)
06:29:53 <dcoutts> but each window maintains a collection of EditorPages that it has open
06:30:15 <Lemmih> I'm not sure how to craft such a interface without depending on CommonSense.
06:30:34 <dcoutts> it'd be easy to do it my making the DemoEditor depend on CommonSense
06:30:40 <dcoutts> otherwise we need to define some hooks
06:30:47 <dcoutts> my/by
06:31:49 <dcoutts> I suggest we just get it working in the Demo editor and then do the hooks
06:32:16 <dcoutts> so in the DemoEditor.hs textEditorPage function...
06:32:44 <dcoutts> in the openPage function it creates the buffer, you could just add you line of code there to attach to it
06:33:01 <dcoutts> that's also the place where we would put any hooks
06:33:04 <Lemmih> Okie.
06:33:17 <dcoutts> so just directly import the CommonSense module
06:39:05 <metaperl> goron: what sort of conclusion?
06:51:00 <araujo> Good morning.
06:51:12 <dcoutts> hi araujo
06:51:30 <araujo> Hello dcoutts
06:51:33 <araujo> What's up?
06:51:40 <dcoutts> hacking on hIDE
06:51:46 <dcoutts> oh and I've got a handover :-)
06:51:56 <dcoutts> handover/hangover
06:51:59 <dcoutts> ugg
06:52:01 <araujo> Nice :-]
06:52:06 <dcoutts> hmmm
06:52:27 <dcoutts> just don't shout to loud
06:52:36 * dcoutts is feeling sensitive
06:52:46 * dcoutts gets up to close the curtains
06:52:46 <araujo> hah
06:53:12 <Lemmih> @eval widgetSetSensitive dcoutts False
06:53:18 <lambdabot> <irc>:1:0: Not in scope: `widgetSetSensitive'
06:53:18 <lambdabot>  
06:53:18 <lambdabot> <irc>:1:19: Not in scope: `dcoutts'
06:53:22 <dcoutts> :-)
06:53:41 <dcoutts> I unicycled home from the party this morning, still quite drunk
06:53:47 <araujo> haha
06:53:56 <Lemmih> heh
06:54:00 * araujo can't imagine dcoutts uncycling drunk
06:54:14 <araujo> http://dev.gentoo.org/~araujo/stuff/src/Smsh.hs
06:54:25 <araujo> I accept suggestions/comments/flames ;-)
06:54:51 <MarcWeber> Is it possible to use ActiveX/COM libraries with haskell?
06:54:53 <dcoutts> hmm the main function is a bit ugly
06:55:04 <araujo> dcoutts, yeah :-(
06:55:19 <dcoutts> MarcWeber, yeah apparently it it possible, I think the HDirect tool helps with that
06:55:55 <araujo> dcoutts, don't you think i should use case there?
06:56:25 <dcoutts> araujo, it could probably be broken up into smaller bits
06:56:32 <MarcWeber> dcoutts: Wow, thanks!
06:56:52 <araujo> dcoutts, mmm...
07:00:14 <araujo> dcoutts, you mean, to do each case option probably a function?
07:01:02 <dcoutts> that'd probably help
07:01:49 <dcoutts> the other think might be to abstract out the calling of fs at the end each time
07:02:35 <dcoutts> only the quit command is special, all other ones just go round the loop again
07:04:30 <Lunar^> Igloo: ?
07:04:31 <Lemmih> You can use 'exitWith ExitSuccess'.
07:04:43 <araujo> dcoutts, i see, good
07:04:51 <Igloo> Lunar^: ?
07:05:07 <Lunar^> Igloo: I am filling an ITP for hscurses
07:05:32 <Lunar^> Igloo: the latest tarball is labeled "ds-20050830"
07:05:34 <Igloo> Which one?
07:05:49 <Lunar^> Igloo: Stefan Wehr's
07:06:18 <Lunar^> Igloo: it doesn't seem like a proper version number to me, do you have any suggestion?
07:06:52 <Lunar^> Igloo: would "0:20050830" be ok?
07:07:22 <Igloo> Is hscurses an overloaded name, and if so is that one clearly the canonical one?
07:07:28 * Igloo has lost track of the curses bindings
07:07:33 <Lunar^> http://www.stefanheimann.net/haskell/
07:07:39 <Igloo> 0: is implicit if you just don't give na epoch
07:07:43 <Igloo> What does the ds mean?
07:07:50 <Lunar^> Igloo: development snapshat, I guess
07:07:56 <Lunar^> Igloo: tuomov does the same for riot
07:08:23 <Igloo> What do released version numbers look like?
07:08:40 <Igloo> It would certainly be good to have ds in there somewhere
07:08:42 <Lunar^> Igloo: there's none.. that's why I was asking :)
07:10:33 <Igloo> I don't see a problem with ds-20050830. It's less than anything likely to be a released version
07:10:50 <Igloo> Oh, wait
07:11:07 <Igloo> That's a complete lie
07:11:44 <Igloo> 0ds-20050830 should work though
07:11:56 <Igloo> See e.g. dpkg --compare-versions 0.0.1 \> 0ds-20050830 && echo yes
07:16:02 <Lunar^> Igloo: thanks
07:16:37 <Lunar^> Igloo: I'll use 0.ds-20050830, personal tastes :)
07:17:14 <Igloo> That doesn't work
07:18:14 <Lunar^> right :(
07:18:21 <Lunar^> ok, let's go without the '.' then
07:28:06 <tempest1> hey
07:28:13 <basti_> y0!
07:30:18 <tempest1> i'm just starting haskell
07:32:40 <Lemmih> dcoutts: Is it possible to freeze/thaw a GtkTextBuffer to avoid flickering?
07:33:18 <dcoutts> Lemmih, yes it is I think
07:33:27 * dcoutts goes to consult docs
07:33:55 <tempest1> so is haskell actually a usable language?
07:34:01 <tempest1> it looks like shit to me
07:34:06 <araujo> uh?
07:34:14 --- mode: ChanServ set +o shapr
07:34:19 * dcoutts thinks tempest1 is trying to start a flame war
07:34:28 <tempest1> ok, i'm sorry
07:34:30 <araujo> Haskell is the best language out there.
07:34:32 <tempest1> i just started reading tutorials
07:34:44 <tempest1> i don't have the most expert of opinions on it
07:34:53 <basti_> tempest1: you should do that some more before you utter such things in this channel
07:35:11 <shapr> tempest1: "looks like shit" is a purely emotional comment that tends to upset people.
07:35:14 <davve> tempest1, what is it that you find shitty?
07:35:22 <tempest1> the way it assigns variables
07:35:30 <araujo> :-/
07:35:31 <shapr> tempest1: I can perfectly understand that some things about Haskell are unfamiliar, but that doesn't mean they're bad.
07:35:35 <tempest1> its just confusing, i'm an experienced C/C++ programmer but this doesn't make much sense
07:35:41 <tempest1> true
07:35:49 <basti_> these two facts might corellate.
07:35:50 <araujo> tempest1, get some reading about functional programming first, i'd recommend.
07:36:27 <shapr> tempest1: I could give you the short tour of the #haskell channel and introductory materials, maybe that would help?
07:37:09 <tempest1> that could help shapr
07:37:13 <shapr> ok!
07:37:22 <tempest1> do you have a link to the materials or whatever?
07:37:30 <shapr> The first sight on our tour is the lovely lambdabot.
07:37:54 <tempest1> oh, you're an admin... this could be bad
07:37:55 <shapr> lambdabot is an IRC bot written in Haskell. lambdabot's nifty plugin architecture means that there's a bunch of useful commands in lambdabot.
07:38:12 <goron> tempest1: The number of Haskell users is growing steadily when looking at the number of people in this channel. So, there must be some reason why it's "good" according to some definition of "good".
07:38:12 <tempest1> cool
07:38:19 <shapr> tempest1: I try my best to be a benevolent admin :-)
07:38:28 <goron> @moo
07:38:31 <tempest1> alright, well i'll trust you lol
07:38:44 <shapr> The second stop on our tour is the Haskell Wiki http://www.haskell.org/hawiki/
07:38:50 <dcoutts> Lemmih, oh, hmm there's not quite what I expected, there's textBufferBeginUserAction/textBufferEndUserAction
07:39:14 <shapr> The Haskell Wiki has lots of good information, both introductory and almost terrifying.
07:39:15 <goron> @eval 1+1
07:39:17 <lambdabot> 2
07:39:18 <tempest1> that's cool, i'm creating a C++ wiki
07:39:26 <dcoutts> Lemmih, what sort of flicker are you getting?
07:39:50 <shapr> The last two stops on our tour are the logs of this channel, linked in the topic, and the "Learning Haskell" page at haskell.org
07:39:51 <shapr> @learn
07:39:52 <lambdabot> http://www.haskell.org/learning.html
07:40:14 <shapr> If you want to learn Haskell, I'd suggest starting with a quick syntax demo I wrote for impatient people (like me).
07:40:17 <shapr> @wiki HaskellDemo
07:40:17 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
07:40:24 <Lemmih> dcoutts: I remove tags before doing the typechecking.
07:40:29 <goron> 'Yet another Haskell Tutorial' is a nice tutorial.
07:40:35 <shapr> After that, I'd suggest reading Hal Daume's "Yet Another Haskell Tutorial" that's linked from the learning page.
07:40:38 <tempest1> thanks shapr, i appreciate the tour
07:40:41 <goron> hehe
07:40:52 <shapr> tempest1: Sure, if you have any specific question, I'd be happy to answer them.
07:40:59 <goron> shapr: You should automate that tour.
07:41:09 <dcoutts> Lemmih, right and then you type check and put them back? it's the error tags we're talking about here yes?
07:41:15 <Lemmih> dcoutts: Yep.
07:41:17 <shapr> goron: Nah, I enjoy giving the tour :-) I like people!
07:41:38 <goron> shapr: I like some people.
07:41:41 * shapr grins
07:41:49 <dcoutts> Lemmih, well how about just removing the tags just before putting the new ones in, when type checking is finnished?
07:41:58 <shapr> People who persist in being unlikable get removed from #haskell by me, so...
07:42:03 <tempest1> well i've got to be going now
07:42:16 <dons> shapr, why are the op privledges on, did something happen?
07:42:17 <shapr> tempest1: Feel free to drop by if you want to learn more.
07:42:17 <tempest1> but undoubtably i'll be back later trying to make something in haskell out of curiosity
07:42:27 <tempest1> bye people
07:42:28 <shapr> tempest1: cool!
07:42:30 <shapr> cya!
07:42:42 <dons> i must have missed something
07:43:03 <dcoutts> dons, yep you did, it wasn't ver exciting thoguh
07:43:25 * dcoutts really cant spell today
07:43:35 * dcoutts blaims the vodka
07:44:02 <goron> What was that Haskell VHDL DSL language called again?
07:44:04 --- mode: shapr set -o shapr
07:44:12 <Lemmih> dcoutts: Did that. But the syntax-highlighter is removing all tags (on the current line) before going into action. Can I remove all but some tags?
07:44:14 <shapr> goron: Lava, Hawk, and some others.
07:44:44 <goron> shapr: Cool, I only knew one.
07:44:46 <dcoutts> Lemmih, hmm
07:44:56 <dcoutts> Lemmih, how do you di it at the moment?
07:45:02 <Lemmih> dcoutts: Aren't textBufferBeginUserAction/textBufferEndUserAction used to create an undo stack?
07:45:20 <dcoutts> Lemmih, yeah I just realised they wouldn't help with flicker
07:45:31 <dcoutts> yes, they're for an undo stack
07:46:45 <dcoutts> Lemmih, heh the docs for gtk_text_buffer_remove_all_tags say:
07:46:46 <dcoutts> Be careful with this function; it could remove tags added in code unrelated to the code you're currently writing. That is, using this function is probably a bad idea if you have two or more unrelated code sections that add tags.
07:47:23 <dcoutts> Lemmih, use gtk_text_buffer_remove_tag or gtk_text_buffer_remove_tag_by_name
07:47:38 <Lemmih> Oki.
07:47:45 <dcoutts> or rather textBufferRemoveTag or textBufferRemoveTagByName
07:48:07 <dcoutts> so you'll have to know which tags you inserted
07:48:16 <Lemmih> camelCase <3
07:48:24 <shapr> I swear that always looks like testicles to me.
07:48:32 <dcoutts> ?!
07:48:41 <Lemmih> haha
07:49:24 <basti_> Lemmih: my hsp installation is working now. How do session variables and forms work?
07:49:37 * Lemmih still have to pick suitable/permanent names for tokens.
07:50:16 <dcoutts> Lemmih, using the Show for them isn't suitable?
07:50:25 <dcoutts> it seemed like a nice hack to me
07:50:51 <Lemmih> basti_: getSessionVar "variable name" :: HSP yourType
07:51:00 <basti_> cute.
07:51:27 <basti_> and forms? (cgi interaction)?
07:52:03 <Lemmih> Um, there's 'getInput "arg"'.
07:52:19 <basti_> thanks
07:52:20 <Lemmih> But no built-in support for forms.
07:52:44 <basti_> i didnt expect that
07:52:48 <basti_> just couldnt find it in the source
07:54:24 <Lemmih> basti_: http://212.242.49.100/Session http://212.242.49.100/Counter
07:55:34 <basti_> mmm why dont you pack the examples with the code? :D
07:55:58 <Lemmih> Good idea (:
07:59:40 <Lemmih> dcoutts: It may be a bit annoying for non-haskell syntax highlighting.
07:59:58 <basti_> hmm how can I set the haspr compile-timeout? i made a Config.hs, but that doesnt seem to do anything
08:00:03 <dcoutts> Lemmih, how so?
08:00:09 <Lemmih> dcoutts: How do I get the text between two TextIter's as a CString?
08:00:26 <dcoutts> Lemmih, at the moment you can't I can add such a feature if you like
08:00:59 <Lemmih> basti_: HSP only reads the config file when it starts /-: You have to restart the server.
08:01:18 <basti_> hmm i did that. Can i check if the config file has been read?
08:02:24 <basti_> there is some Majshdjah.hs or something in the dir now
08:02:51 <Lemmih> Try supplying an invalid argument to GHC (confExtraGHCArgs).
08:02:51 <basti_> but that didnt regenerate
08:04:24 <Lemmih> dcoutts: That and non-string versions of {on|after}Delete,{on|after}Insert would probably speed up the typechecking and highlighting a fair bit.
08:05:22 <basti_> that doesn't appear to change anything
08:05:37 <Lemmih> Where did you put the config file?
08:05:50 <basti_> $PREFIX/haspr/config/Config.hs
08:06:30 <Lemmih> (recompiling haspr with -DDEBUG will put lots of info in /var/www/debug)
08:07:02 <basti_> ah ok
08:07:32 <basti_> lets try that
08:08:03 <Lemmih> dcoutts: The token names aren't Haskell specific?
08:09:48 <dcoutts> Lemmih, yes not going via the string names of the tags would save lots of lookups
08:10:06 <dcoutts> Lemmih, what tokens are you referring to exactly?
08:10:20 <Lemmih> The tokens in the HaskellScanner
08:16:52 <dcoutts> Lemmih, I dont know what you mean about them being Haskell specific or not
08:17:51 <nothingmuch> http://en.wikipedia.org/w/index.php?title=Administrative_Normal_Form&action=edit
08:18:01 * nothingmuch makes a puppy-eyed face
08:18:06 <Lemmih> Never mind. It's not imporant right now.
08:18:40 <dcoutts> Lemmih, I'm looking into how to display the error messages corresponding to the underlined bits in the buffer
08:19:01 <dcoutts> how do you imagine it working exaclty?
08:19:25 <dcoutts> just so I make sure I'm looking at the right thing :-)
08:19:38 <dcoutts> I imagine it like so:
08:21:16 <dcoutts> mouse over the red squiggly bits, if the mouse pauses there for a moment (eg 1/2 sec) then the error message is popuped up in a transient window just beneath the highlited error span (or above if it would go off the bottom of the screen)
08:21:51 <dcoutts> then the transient window should dissapear as soon as the mouse leaves the red highlighted bit
08:22:06 <dcoutts> or probably if the user clicks the mouse, or presses any key
08:22:48 <dcoutts> can we get sensible error messages from the ghc api?
08:22:53 <Lemmih> Yeah.
08:22:58 <dcoutts> ie not including all the pretty printed stuff
08:23:23 <dcoutts> since we'll have the real thing there highlited in front of them
08:23:44 <dcoutts> so we don't need the whole context
08:23:58 <dcoutts> like you would when runing ghc in a terminal
08:24:04 <Lemmih> Yeah, we can do that.
08:24:07 <dcoutts> cool
08:25:15 <Igloo> You should also handle the case where it doesn't fit on the screen. Always annoys me when things don't
08:26:00 <dcoutts> Igloo, you mean if the error is larger than the screen?
08:26:09 <Igloo> Yeah
08:26:25 <dcoutts> well without all the context that chouldn't happen
08:26:33 <dcoutts> chouldn't/shouldn't
08:26:43 <Igloo> Hmm, I guess it's unlikely in that case, yeah
08:27:28 <Igloo> But being able to right click and request it goes to the status pane at the bottom or whatever would still be nice
08:28:09 <dcoutts> that'd be possible (especially if someone else implements it!)
08:28:56 <Lemmih> Errors should always be listed at the bottom, imo.
08:29:22 <dcoutts> Lemmih, ok and have the mouse over only as an extra
08:29:27 <Lemmih> Yeah.
08:29:29 <dcoutts> ok
08:29:51 <Igloo> If I do any hIDE hacking, it'll be "make tabs display with flashing red background and sounds awooga horns every 3 seconds if any are present" mode first  :-)
08:30:20 <Igloo> Lemmih: OK, but it would still be nice to either jump to one you want or to have only it reprinted
08:30:23 <dcoutts> Igloo, I'm sure people will love that
08:31:10 <dcoutts> Igloo, if any errors are present you mean?
08:31:23 <Igloo> any tabs
08:31:36 <dcoutts> oh you don't like tabbed UIs
08:31:48 <Igloo> The other sort of tab
08:31:51 <Igloo> '\9'
08:31:53 <dcoutts> oh that!
08:32:27 <dcoutts> well by default I think the Haskell editing mode should be to convert tabs to spaces
08:32:46 <dcoutts> and any real tabs should be 8 spaces of course
08:33:01 <Lemmih> Igloo: You only want a single error reported at a time?
08:33:18 <Igloo> You don't quite mean that, but yeah
08:34:05 <dcoutts> Igloo, but yes it'd be quite possible to highlinght '\9' chars in the buffer with some background colour. Dunno about the flashing & horns however.
08:34:09 <Igloo> Lemmih: You can dump them all at appropriate times, but it should be easy to get the text of a particular one in something more stable than a tooltip
08:34:28 <dcoutts> Igloo, hmm good point
08:34:58 <dcoutts> we could display the current error under the cursor in a tool window below the editor pane
08:35:19 <Igloo> I don't want it to disappear as soon as I move the cursor!
08:35:48 <dcoutts> well ok, how about this:
08:35:52 <Igloo> What's wrong with right click -> print error in $window?
08:36:29 <dcoutts> you have a errors/warnings area below the editor pane which contains a list of the errors
08:36:49 <dcoutts> seleting one jumps to it in the editor
08:37:32 <dcoutts> and moving into an error in the editor, makes the corresponding error text the currently displayed one in the errors list
08:37:46 <dcoutts> so it doesn't just dissapear when you move off the error
08:38:00 <dcoutts> but it does become current when you move into the error span
08:38:05 <Igloo> I thought that's pretty much what I sid 7 mins ago, but yeah, sounds good  :-)
08:38:26 <dcoutts> Igloo, ok, then I was just explaining it to myself :-)
08:44:34 <Igloo> Bah, QC doesn't seem to allow you to thread your own Monad through its generators
08:50:23 <Lemmih> Anyone wanna test ghc-api (http://scannedinavian.org/~lemmih/ghc-api) before I release 0.2?
08:50:46 <dcoutts> Lemmih, yeah, I want to use it do generate some module graphs
08:52:14 <shapr> jiihaa
08:52:17 <shapr> I love unicycling!
08:53:04 <shapr> Igloo: But I do wish it would ...
08:53:18 <shapr> Igloo: I'm writing an article on QC & Hunit for TMR right now... tell me what you want to od.
08:53:20 <shapr> do*
08:55:01 <dcoutts> Lemmih, ok building it now...
09:03:36 <dcoutts> Lemmih, I wonder if it's possible with Cabal to ask that the package not be exposed by default
09:03:59 <dcoutts> since the ghc-api does not use heirarchical module names
09:04:22 <syntaxfree> hello, mates.
09:04:32 <shapr> g'day
09:05:05 <syntaxfree> I was wondering -- is the correct pronounciation hasKELL or HASkell?
09:05:12 * shapr doesn't know.
09:05:17 <shapr> I want a recording of SPJ saying it.
09:05:35 <Lemmih> dcoutts: Did you install it?
09:06:12 <syntaxfree> Simon Peyton-Jones is really the main head behind Haskell, right?
09:06:24 <dcoutts> Lemmih, yep now I'm getting linker errors
09:06:35 <shapr> syntaxfree: Um, one of them.
09:06:53 <dcoutts> $ ghc -package ghc-api --make Main.hs -o main
09:06:53 <dcoutts> Chasing modules from: Main.hs
09:06:53 <dcoutts> Skipping  Main             ( Main.hs, Main.o )
09:06:53 <dcoutts> Linking ...
09:06:53 <dcoutts> /usr/lib/ghc-6.4.1/libHSrts.a(RtsUtils.o)(.text+0x0): In function `stgMallocBytes':
09:06:54 <dcoutts> : multiple definition of `stgMallocBytes'
09:07:05 <Lemmih> Urk.
09:07:08 <syntaxfree> so why do you want to know how SPJ specifically pronounces it?
09:07:10 <dcoutts> and there are a few other linker error messages too
09:07:22 <syntaxfree> s/SPJ specifically/specifically SPJ
09:07:28 <Lemmih> dcoutts: Try: ghc -DGHCI -fglasgow-exts -cpp src/main/Main.hs -e 'System.Environment.withArgs ["-B/usr/lib/ghc-6.4.1","--interactive"] main'
09:08:36 <manulito_> if i got a function with a few different inparameter defenitions, is there a way to have a where block that covers all of them? since now i have to add a new where for every single defenition
09:08:59 <dcoutts> Lemmih, that loads
09:09:09 <dcoutts> it claims to be ghci 6.5 :-)
09:09:22 <Lemmih> Can you evaluate expressions?
09:09:35 <dcoutts> yep
09:09:53 <Lemmih> Great.
09:11:48 <dcoutts> Lemmih, should it not build-depend on the rts package?
09:11:53 <dons> you're evaluating expressions in ghci-api?
09:13:45 <dcoutts> /usr/lib/ghc-6.4.1/libHSrts.a(RtsUtils.o)(.text+0x0): In function `stgMallocBytes':
09:13:46 <dcoutts> : multiple definition of `stgMallocBytes'
09:13:46 <dcoutts> /usr/local/lib/ghc-api-0.1/ghc-6.4.1/libHSghc-api-0.1.a(RtsUtils.o)(.text+0x0): first defined here
09:14:18 <Lemmih> ghc-api isn't meant to be linked against the rts.
09:14:20 <dcoutts> so stgMallocBytes is defined in libHSghc-api-0.1.a and of course in ghc's libHSrts.a
09:15:48 <Lemmih> stgMallocBytes is hidden in the RTS so I had to redefine it myself.
09:15:54 <dcoutts> so is it supposed to be defined in both places?
09:15:59 <dcoutts> oh I see, hmm
09:16:17 <dcoutts> and it has a different size in the two versions apparently:
09:16:36 <dcoutts> Warning: size of symbol `stgMallocBytes' changed from 55 in /usr/local/lib/ghc-api-0.1/ghc-6.4.1/libHSghc-api-0.1.a(RtsUtils.o) to 53 in /usr/lib/ghc-6.4.1/libHSrts.a(RtsUtils.o)
09:16:59 <sethk> pad it out to 55 in the newer version
09:17:01 <dcoutts> but that's just a side effect of having two versions I guess
09:17:08 <sethk> can't do that when something gets bigger, or course
09:17:12 <dcoutts> when we shouldn't
09:17:13 <sethk> but you can when something gets smaller
09:17:28 <Lemmih> Renaming it in ghc-api might be best.
09:17:29 <sethk> dcoutts, probably other objects around that did get bigger, though
09:17:54 <dcoutts> Lemmih, so you were doing this to load ghc-api dynamcally right?
09:18:05 <Lemmih> Yeah.
09:18:08 <dcoutts> I'm using it in a standalone app
09:18:20 <dcoutts> which might explain some things
09:18:51 <dcoutts> the ld linker can access the symbol where as ghci's linker cannot, which is why you had to re-define it
09:19:30 <dcoutts> I can load my prog in ghci fine
09:19:49 <Lemmih> Does it define a new data type?
09:20:04 <dcoutts> what my prog?
09:20:15 <Lemmih> yeah.
09:20:22 <dcoutts> it's currently a pretty empty prog
09:20:34 <dons> ah yes, I remember this issue. you have to define a data type to get a call to stgMallocBytes
09:20:52 <dcoutts> module Main where
09:20:53 <dcoutts> import GHC
09:20:53 <dcoutts> import System (getArgs)
09:20:53 <dcoutts> main :: IO ()
09:20:53 <dcoutts> main = do
09:20:53 <dcoutts>   [filename] <- getArgs
09:20:55 <dcoutts>   print filename
09:21:02 <dcoutts> that's it at the moment
09:21:11 <dcoutts> I was just seeing if it linked
09:25:37 <Lemmih> dons: Calls to stgMallocBytes aren't a problem.
09:26:41 <Lemmih> Trying to compile a data declaration will fail with '*** Exception: stg_interp_constr_entry'
09:27:10 <dons> ah, ok.
09:27:16 <shapr> syntaxfree: Because SPJ seems like the one guy who's put the most effort and work into Haskell, so I figure I'll say Haskell however he says it.
09:27:18 <dons> maybe i misremember my bug
09:27:50 <Lemmih> (stg_interp_constr_entry is a weird C-- function which I haven't groked yet)
09:30:02 <Igloo> shapr: http://urchin.earth.li/~ian/Q.hs is what I wanted to do. It's not actually that bad to work around, as there, but I think it is non H98
09:31:02 <shapr> Igloo: Any comments/feedback etc about software testing with Haskell? I'm focussing on HUnit and QC, but if you have anything else to say, I want to hear it.
09:31:58 <Igloo> I think it's a good thing, and we should do more of it
09:32:09 <dons> there's the programattiica tools
09:32:19 <Igloo> Although it would also be useful for me to finish the code my test tests
09:32:35 <dons> which are a bit like quickecheck annotations in the src, i think
09:32:48 <shapr> Yeah, I should mention Programatica. It's more a UI than a testing lib.
09:32:59 <shapr> But that definitely fits into software testing with Haskell.
09:33:00 <dons> the house paper from the HW described them, and they've been writeen about before elsewhere
09:33:07 <shapr> There's Hat and Buddha too, but I don't know much about them.
09:33:26 <araujo> dcoutts, there?
09:33:33 <shapr> Anything else I'm missing?
09:34:03 <shapr> I'm planning to cover only QC and HUnit in this article, but I might do Hat, Buddha, and Programatica later.
09:34:18 <dons> Stefan Wehr wrote a wrapper over HUnit that uses TH to make specifying tests more QC-like
09:34:27 <shapr> !
09:34:31 <shapr> Where do I get it?
09:34:36 <dons> it's used in Yi and FPPS I think
09:34:38 <dons> fps.
09:34:39 <dons> let me see.
09:34:42 <Igloo> More QC-like?
09:35:26 <ndm> you specify the property, like in quickcheck
09:35:29 <dons> perhaps I should say that it automates more of the writeing of tests.
09:35:47 <dons> and you write properties that look like QC. but it doesn't use type hackery onr anything
09:36:16 <dons> now, link:  look in testsuite in the ncurses yi
09:36:49 <dons> since I only use this, not the raw HUnit, I may be misreading what HUnit doess on its own
09:36:50 <shapr> ok
09:37:07 <Igloo> Does it check the cases you ask it to, or invent them on its own?
09:37:18 <dons> you have to write the cases
09:37:49 <dons> have a lookk at testsuite/Tests/Buffer.hs
09:37:59 <Igloo> @where yi
09:38:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
09:38:08 <Igloo> @darcs yi
09:38:09 <lambdabot> yi not available
09:38:31 <dons> or in fps, in tests/Tests.hs
09:38:46 <dons> isn't @darcs our plugin for checking local repos?
09:39:28 <dons> (also developed by Stefan Wehr for our icfp entry)
09:39:37 <Igloo> I don't know what it is, but it didn't tell me what I wanted to know  :-)
09:39:56 <dons> the repo:; http://www.cse.unsw.edu.au/~dons/code/yi
09:40:23 <dons> the fps one might be easier to follow
09:40:26 <dons> @where fps
09:40:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
09:40:36 <Igloo> OK, so it looks like it's just slightly sugaring HUnit
09:40:42 <dons> grr. http://www.cse.unsw.edu.au/~dons/code/fps
09:40:47 <dons> ah, ok. could be
09:41:21 <dons> I just noticed when writing the fps one that it was almost identical to the QC tests in the same dir.
09:41:33 <dons> you have a model, you check against the model.
09:41:45 <dons> the hunite ones use a large data file as input, the QC ones generate input on their own
09:42:09 <dons> but the properties in both are the same (or almost the same)
09:43:09 <Igloo> Sure, both boild down to Something -> Bool, the main difference is QC invents the somethings for you whereas with HUnit you tell it what they are
09:43:18 <dons> right
09:44:52 * Igloo disappears
09:50:16 <shapr> dons: Good name for something that brings together QC and HUnit ... HUnite :-)
09:56:40 <dons> hehe
10:00:14 <manulito> if a got a list with values, and one equaly long list with functions. if i would like to apply the function at n:th pos to the value at the n:th pos, if the value is for example above 5, is there a smart way to do this?
10:00:46 <manulito> or doenst need to be above five, just true to some preducate (if that has the right meaning)
10:01:24 <ndm> manulito, zip will do some of what you want
10:01:43 <ndm> zipWith (\f x -> f x) xs
10:01:43 <manulito> doenst zip create tuples?
10:01:47 <manulito> ahh
10:01:52 <ndm> @pl zipWith (\f x -> f x)
10:01:53 <lambdabot> zipWith id
10:02:34 <ndm> @pl \f x -> f x
10:02:35 <lambdabot> id
10:02:56 <ndm> sorry, i'm sure there is a neater way to do (\f x -> f x), but no idea at this moment
10:03:23 <ndm> maybe zipWith (.)
10:04:22 <Lemmih> @eval zipWith ($) [succ,pred] [10,20]
10:04:28 <lambdabot> [11,19]
10:04:51 <manulito> thanks!
10:05:23 <manulito> it works, tho i dont have a clue what ($) menas
10:05:45 <ndm> in that case, it might be best to use (\f x -> f x) - to help future understandability
10:06:47 <ndm> ($)            :: (a -> b) -> a -> b
10:06:49 <ndm> f $ x           = f x
10:10:25 <Oejet> Hello.
10:10:41 <sethk> $ groups everything to the right of the $
10:10:59 <sethk> so that f $ g h  is f (g h) instead of f g h = (f g) h
10:51:49 <syntaxfree> $ rules.
10:52:10 <xerox> @type ($)
10:52:11 <lambdabot> forall b a. (a -> b) -> a -> b
10:58:11 <shapr> Hm, for some reason I thought I had five articles for this TMR.
10:58:41 <Lemmih> How many do you have?
11:00:17 <shapr> I'll have four with my article.
11:00:26 <shapr> I wonder if jyp's article is ready.
11:01:26 * shapr sends mail
11:03:00 <shapr> Hm, looks okay to me.
11:04:09 <syntaxfree> what is the TMR?
11:04:29 <shapr> The Monad.Reader - http://www.haskell.org/tmrwiki/
11:05:00 <syntaxfree> cool.
11:05:07 <shapr> I'm going to publish issue five today.
11:05:14 <syntaxfree> I wikify a magazine?
11:05:25 <shapr> It's a wiki-zine.
11:05:40 <shapr> I'd like to switch it over to using lhs2TeX though.
11:06:04 <syntaxfree> what is lhs2tex?
11:06:10 <shapr> @google lhs2TeX
11:06:11 <lambdabot> http://www.cs.uu.nl/~andres/lhs2tex/
11:06:22 <shapr> It's a neat software by kosmikus.
11:07:00 <syntaxfree> kosmikus who hangs around here?
11:07:12 <syntaxfree> hmm. Literate Haskell :)
11:07:33 <shapr> Yes, that kosmikus.
11:08:10 <shapr> syntaxfree: Are you Diego Navarro?
11:08:17 <syntaxfree> um, yes.
11:08:22 <syntaxfree> I don't think you'd know me, though.
11:08:35 <syntaxfree> I haven't really done anything important programming-wise.
11:08:45 <shapr> Neither have I :-)
11:08:57 <shapr> I just like to learn stuff, and talk to others who enjoy the same.
11:09:13 <syntaxfree> metoo.
11:09:24 <syntaxfree> computer programming is a hobby for me.
11:09:40 <shapr> It went from a hobby to an addiction for me.
11:09:59 <syntaxfree> yeah, I'm in that process
11:10:03 <shapr> I rarely finish any code, but I do enjoy hacking up experiments to figure out how stuff works.
11:10:55 <shapr> syntaxfree: Have you found cool websites like lambda-the-ultimate.org ?
11:11:23 <syntaxfree> nope.
11:11:37 <syntaxfree> I'm working on a backprop library right now.
11:11:49 <syntaxfree> I once wrote one in Matlab, but it was teh kludge. I'm trying to write cleaner now.
11:12:10 <shapr> That sounds cool.
11:12:21 <syntaxfree> write cleaner != write in Clean ;-)
11:12:44 <shapr> :-)
11:13:28 <syntaxfree> It's going alright, now that the type system seems to have stopped working against me.
11:14:39 <syntaxfree> neuron xlist wlist		= activationFunction(sum(zipWith (*) xlist wlist))
11:14:47 <syntaxfree> layer inputList wMatrix		= map (neuron inputList) wMatrix
11:14:53 <syntaxfree> fullnet inputList wMatrix1 wMatrix2 = layer (layer inputList wMatrix1) wMatrix2
11:15:13 <syntaxfree> bingo. That's the three-line neural network ;-). I'm working on the training code now.
11:17:53 <shapr> Looks nice and simple.
11:18:10 <shapr> Has anyone tried to mix neural networks and dataflow programming?
11:19:27 <autrijus> greetings lambdafolks.
11:20:49 <shapr> hiya autrijus
11:21:00 <shapr> hoi ryko
11:21:07 <ryko> hi
11:21:28 <Lemmih> Hmm.
11:21:36 <syntaxfree> They probably have. By now, they have mixed neural networks and traditional mexican cooking.
11:21:51 * Lemmih found a nasty error message in GHC.
11:21:57 * shapr gets an orange mocha quesadilla!
11:22:10 <shapr> "Our neural networks have decided that this is your favorite food."
11:24:37 <autrijus> Lemmih: not brain explosion?
11:25:37 <ryko> I'm having some monad troubles with a parser I'm working on. I'm using Parsec. On handling an import directive, I want need to tokenize the imported file and next parse it (using Parsec) but I don't succeed in 'escaping' the Parsec monad temporarily in order to use the IO monad. Is there a simple way of doing that?
11:26:04 <Lemmih> autrijus: Nope, 'unknown exception'. But I don't think it's related the the bug you found.
11:27:08 <autrijus> *nod*.
11:27:11 <Lemmih> autrijus: I had two packages which depended on each other.
11:27:16 <autrijus> I see.
11:27:22 <autrijus> let me know if I should retest ghc-api
11:27:31 <autrijus> I'd really like to play with that.
11:27:51 <autrijus> ryko: yes.
11:28:05 <Lemmih> Haven't changing anything in ghc-api.
11:28:23 <autrijus> ryko: two ways.  one way is to use lazy request/response streams using unsafeInterleaveIO
11:28:27 <autrijus> which is a bit complex
11:28:36 <ryko> okay
11:28:40 <autrijus> another way is to do separate compilation
11:28:54 <autrijus> i.e. scan for import first, do that, then reparse the original in another scan.
11:28:56 <autrijus> on the gripping hand!
11:29:01 <autrijus> you can just use unsafePerformIO!
11:29:02 <syntaxfree> shapr: what is dataflow programming?
11:29:18 <ryko> the latter might introduce some problems with type-checking.
11:29:25 <autrijus> ryko: http://svn.openfoundry.org/pugs/src/Pugs/Parser/Unsafe.hs
11:29:45 <autrijus> note the "-fno-full-laziness -fno-cse", the NOINLINE, and general voodoo.
11:29:51 <shapr> syntaxfree: It's what spreadsheets do, roughly.
11:29:53 <autrijus> that may just work for you. :)
11:30:11 <syntaxfree> hmm.
11:30:41 <autrijus> again, if you feel uneasy about the name:
11:30:48 <autrijus> runIO :: IO a -> a
11:30:53 <autrijus> runIO = unsafePerformIO
11:30:57 <autrijus> may help.
11:31:08 <syntaxfree> yes, they have done such things with neural networks.
11:31:14 <ryko> I'll look into it, thanks. 'unsafePerformIO' sounds a bit scary though - what's 'unsafe' about it?
11:31:25 <syntaxfree> They also have fully dynamic self-training recurrent neural nets.
11:31:41 <autrijus> ryko: see the System.IO.Unsafe docs.
11:31:51 <autrijus> the paragraph starting with "This is the "back door" into the IO monad..."
11:31:53 <syntaxfree> at the moment, I'm working at the simpler, trained-by-external-data case.
11:31:58 <ryko> okay, will do. Thanks!
11:32:09 <Cale> ryko: it's only unsafe if you don't mind that IO happening randomly
11:32:20 <Cale> er
11:32:22 <Cale> safe
11:32:37 * Heffalump appears
11:32:49 <Cale> unsafePerformIO will perform the IO action when the value of your expression is needed
11:33:04 <Cale> your expression could get evaluated multiple times, or never
11:33:27 <Cale> and will happen only on demand of the value, so it's moderately hard to predict
11:33:46 <Cale> also, it breaks referential transparency horribly
11:33:49 <ryko> okay. In my case the result of the IO calls is the input for the Parser, so I guess using it for that is 'safe', right?
11:34:00 <Cale> and allows you to break the type system
11:34:13 <Cale> I wouldn't use it that way
11:34:30 <Cale> You should write a main function which gets the string to pass to the parser
11:34:40 <Cale> unsafePerformIO should rarely be used.
11:34:53 <Cale> autrijus: you really shouldn't recommend it so much :)
11:35:57 <Cale> It's really mostly just for when you're interfacing with some foreign library, and you have a C function say, that returns a pure result.
11:36:35 <Cale> if the IO action f doesn't return the same result every time, it's unsafe to use unsafePerformIO.
11:36:54 <Cale> (unsafePerformIO f)
11:37:40 <mflux> so I wrote an nntp-module that returns (for example) the message as a list of characters, that is read lazily with by using unsafePerformIO
11:37:47 <mflux> and also reads the rest if you issue a new command in
11:37:57 <mflux> that should be ok, or should there be another kind of interface?
11:38:15 <ryko> How can I write such a 'main' function that can be invoked from within the Parsec mondad?
11:38:30 <mflux> I just like the idea of as much as code executing 'in parallel' when you're doing something like that ;)
11:38:48 <mflux> (so of course I try to avoid issuing 'length' on the data etc)
11:39:14 <Heffalump> autrijus: how about we see who can set up test tracking systems and let people try them out then make some decision? I should be able to setup a bugzilla.
11:41:27 <Cale> ryko: you can't but you also probably shouldn't want to
11:42:05 <Cale> (well, you can cheat with unsafePerformIO, but that's kind of unsafe)
11:42:34 <Cale> You'll end up with code that's harder to check the correctness of, and harder to maintain.
11:44:40 <Cale> ryko: why do you feel the need to use the IO monad inside parsec?
11:45:03 <ryko> In order to tokenize a file I need to read it so I feed Parsec a string
11:45:17 <Cale> right
11:45:31 <Cale> you get that string from inside the IO monad, right?
11:45:47 <basti_> Lemmih: haspr seems to recompile the file every time i load a hsp page.
11:45:50 <ndm_> Heffalump, what other bug tracking systems are there out there?
11:45:51 <ryko> yes, that is no problem.
11:45:58 <Heffalump> ndm_: the Debian one
11:46:11 <Heffalump> I dunno how to set that up though, and I have experience of bugzilla.
11:46:33 <Cale> like  do stringToParse <- readFile "myFile.txt"; parse ...
11:46:43 <basti_> or, not every time, but pretty often
11:46:47 <Cale> rather  let tokens = parse ...
11:46:47 <ndm_> i decided i should write my own bug tracking system, which is what i am doing now
11:46:58 <Cale> ryko: okay
11:47:02 <Heffalump> Igloo is writing one in Haskell
11:47:03 <Cale> then what?
11:47:08 <basti_> but that could be because the compile never can do a whole run
11:47:37 <Lemmih> basti_: It does that when you use more than one file for one page.
11:47:38 <Cale> then you take that stream of tokens you get back inside your IO monad computation and pass it to another parser
11:47:42 <Cale> right?
11:47:53 <xerox> Re.
11:48:12 <Lemmih> @index unsafeFreezeByteArray
11:48:13 <lambdabot> bzzt
11:48:27 <shapr> ndm_: Have you seen Igloo's bark? http://urchin.earth.li/darcs/ian/bts/
11:48:52 <basti_> Lemmih: oh.
11:48:55 <ndm_> no, haven't seen that
11:48:55 <ryko> no - next, Parsec should continue to parse the imported file. Once that is done, it should continue parsing the origional file.
11:49:06 <ndm_> mine is a GUI one, native windows, C#
11:49:25 <ndm_> i reckon i can have it done by tomorrow afternoon - it won't suit anyone but me though
11:50:04 <ryko> I must happen in that order, otherwise I can't do any typechekking on the types defined with the imported files
11:50:22 <Cale> ryko: ah, okay, I really think it's safer to collect a list of imports using the parser then.
11:50:30 <Heffalump> hmm, this bar/net cafe bans stag parties, but it¥s still really loud and drunken..
11:50:40 <Cale> you're talking about in the tokenised version, right?
11:50:53 <Cale> You're parsing the already tokenised file
11:51:00 <shapr> Heffalump: Can you hear #haskell over the music?
11:51:05 <Heffalump> shapr: just about.
11:51:16 <Heffalump> it¥s[ the strength of the message.
11:51:23 <Heffalump> anyway, I¥m off.
11:51:29 <shapr> have fun at the ar
11:51:30 <shapr> bar
11:51:37 <ryko> Yes, the principal file is already tokenized at that time. The imported one isn't.
11:51:41 <ndm_> Heffalump, still in Estonia?
11:51:44 <sethk> sounds like shapr is also at a bar.
11:51:44 <Heffalump> I¥m¥m off to my hotel, not the bar :-)
11:51:48 <Cale> basically, you parse your tokens looking for imports and collect up a list of things to import
11:51:49 <sethk> or an ar
11:51:51 <Heffalump> ndm_: yeah. Went to Helsinki today.
11:51:55 <ndm_> oh, cool
11:52:06 <Heffalump> <gone>
11:52:11 <Cale> then you recurse on those files
11:52:14 <ndm_> we got rejected from 2 restraunts for being stag do's :(
11:52:14 <Lemmih> Goodnight, #haskell.
11:52:15 <Cale> and then continue
11:52:27 <Cale> I think that's a sane way to do it :)
11:52:28 <xerox> 'Night Lemmih!
11:53:10 <ryko> Okay. Complication is that imports can also get dictated by the use of types. My parser should resolve those types by looking for a source file that implements the type.
11:54:42 <ryko> But, it should be possible to do it like you are suggesting. The downside is that it will require multiple parser runs.
11:54:55 <Cale> ryko: okay, so you want to collect up a bunch of type signatures as well? Or how far do you need to go? Is there type inference?
11:55:18 <shapr> ndm_: Stag do?
11:55:49 <ryko> No, no inferencing. Types are specified 'hard' with the source.
11:56:01 <Cale> okay, well, that makes it sound possible anyway
11:56:07 <ndm_> the restraunts in estonia thought we were
11:56:11 <Cale> so you want to collect up imports and types
11:56:12 <ndm_> got rejected from 2
11:56:24 <ndm_> it was just a bunch of about 10 FP'ers
11:56:33 <ndm_> (they are obviously not a very good judge of character)
11:57:05 <shapr> haha
11:57:09 <Cale> don't worry too much about the multiple parser passes
11:57:16 <sethk> ndm_, how could they tell you were FPers?
11:57:38 <ryko> yes, it does. But doing it all in 1 parser run sounds much cleaner. It would enable me to use Parsec's state to collect the type tables, and keep everything in one place.
11:57:45 <ndm_> sethk, they should be able to tell!
11:57:55 <ndm_> and i think some of us had ICFP name badges on
11:58:18 <Korollary> you should have pulled a pocket protector and a perl manual
11:58:19 <shapr> On the other hand, lots of FPers don't look in the least geeky. Colin Runciman and Manuel Chakravarty are in really great shape last I checked.
11:58:58 <Cale> ryko: so importing something right in the middle of the file is never going to be a problem?
11:59:08 <Igloo> I think Manuel does some martial art
11:59:25 <ndm_> we were mainly fairly young, which probably didn't help
11:59:48 <ryko> No, I don't think so - since the that's also the way the type-table should be build.
12:00:06 <ryko> also in regards to scoping, etc.
12:01:45 <shapr> ndm_: Hey, you think your Hoogle TMR article will be releasable for next month?
12:01:56 <ndm_> shapr, no :(
12:02:05 <ndm_> when do you mean by next month?
12:02:23 <ndm_> i want to release it with hoogle3, which is probably aiming for xmas realistically, unless other things calm down
12:02:56 <shapr> Ok, xmas is cool.
12:03:20 <shapr> I'm just trying to figure out if TMR should happen every other month.
12:03:20 <ndm_> i'll try to do it earlier
12:03:39 <ndm_> if poss, it just depends on the code - which is a lot harder to write than the article ;)
12:03:47 <shapr> Yeah, I understand.
12:04:11 <Cale> ryko: You can try the unsafePerformIO hack, but myself, I'd write it such that it wasn't necessary. It becomes hard to think about the code if arbitrary IO can occur as a result of evaluating a pure function.
12:04:30 <shapr> Cale: TMR Laziness article?
12:04:36 <Cale> :|
12:05:02 <Cale> only partly done
12:05:18 <shapr> autrijus: Want to write more about Pugs for the next TMR? (in a month)
12:05:27 <ndm_> shapr, i could probably prod people near me into articles in the nearish future
12:05:39 <shapr> yes please!
12:05:42 <ndm_> can think of 2 people off the top of my head with easy to do articles
12:05:52 <shapr> Can you give me their email addresses so I can bug them?
12:05:53 <ryko> Thanks a lot for your help Cale! I'll look into both.
12:06:05 <ndm_> not yet, they have to finish their projects first
12:06:20 <ndm_> then i'll leap in when they have it done :)
12:06:45 <shapr> ok, cool.
12:06:53 <shapr> Let's see... who else can I bug about TMR articles?
12:07:04 * basti_ hides
12:07:16 <ndm_> have you got a copy of the Haskell Workshop proceedings?
12:07:16 <shapr> beschmi: Hey, want to write about Patch Theory?
12:07:31 <ndm_> just go down the list, bugging each person
12:07:54 <shapr> Some people are likely to write, some aren't.
12:08:15 <RemiTurk> hi all
12:08:15 <shapr> Anyway, I usually bug people when I have the energy.
12:08:20 <shapr> hoi RemiTurk
12:08:22 <RemiTurk> oh no *runs*
12:08:31 <shapr> That's right, it's TMR time!
12:09:07 <shapr> I'd like to have a series of short articles demonstrating all the GHC extensions. Anyone want to volunteer for that?
12:10:02 <RemiTurk> hm, I _have_ been playing around with newtypes+foralls to emulate (typless) lambda calculus approach to naturals/booleans/pairs/sums
12:10:12 <ndm_> that would be cool, i want to see what rank 2 types can actually give
12:10:12 <RemiTurk> today
12:10:29 <shapr> RemiTurk: sounds nice!
12:10:47 <RemiTurk> (like this: newtype Pair a b= Pair (forall c. (a -> b -> c) -> c))
12:11:14 <RemiTurk> and I wonder whether I found something I could call a GHC-performance bug in the process:)
12:11:26 <shapr> basti_: Did you get the new Haskore to stream music?
12:11:56 <shapr> JohnMeacham: Want to write a short summary of Boquist's stuff for TMR?
12:13:36 <basti_> shapr: actually, it's not that hard to stream music (virtual midi device). the hard part i've been struggling with is how to make complicated csound setups appear related to haskell
12:14:56 <basti_> :D
12:15:09 <shapr> I don't understand...
12:15:30 <basti_> i managed to get haskore to stream notes into csound
12:15:39 <shapr> neat!
12:15:46 <basti_> but i did that back then already
12:15:55 <shapr> What do you mean about the csound setups?
12:16:00 <basti_> but the orchestra features of haskore are incomplete and don't make a lot of sense
12:16:07 <shapr> hm
12:16:08 <basti_> csound needs an "orchestra file"
12:16:15 <basti_> ("patch")
12:16:32 <shapr> Ah, ok.
12:16:44 <basti_> you *can* generate this with haskell, but that's like "backwards through the chest into your eye" to quite a german saying
12:16:58 <shapr> heh, what's the problem?
12:17:18 <basti_> the orchestra file has a rather macro-assembler like setup
12:17:33 <shapr> oh
12:17:37 <basti_> the trees that represent it are trees.
12:17:56 <basti_> and then equal parts of the trees are substituted by variable writes and reads
12:18:01 <basti_> clever, but disgusting.
12:19:47 <basti_> i had the idea of demonstrating how to make a vocoder of arbitary complexity
12:20:20 <shapr> Something like festival?
12:21:03 <basti_> i don't know what festival is. Do you know cher's "do you believe"?
12:21:08 <basti_> (or just "believe"?)
12:21:14 <basti_> thats a vocoder
12:21:19 <shapr> Oh, ok
12:21:45 <basti_> strictly speaking its an intonator.
12:21:48 <basti_> there.
12:22:08 <basti_> but it sounds a lot like a vocoder, and i couldnt come up with a equally well-known song ;)
12:22:40 <shapr> Fair enough
12:49:33 <sethk> does concatMap apply a function to each member of a list and then concatenate all the results?
12:51:06 <xerox> sethk: right diagnosis.
12:51:24 <xerox> @pl concatMap
12:51:25 <lambdabot> (=<<)
12:51:31 <xerox> <blink>
12:52:13 <ProfTeggy> Good evening.
12:52:46 <basti_> lol
12:52:47 <xerox> Hiya ProfTeggy.
12:55:43 <sethk> xerox, I though a b =<< is b a >>=
12:55:53 <basti_> huh?
12:55:59 <basti_> a =<< b is b >>= a
12:56:02 * shapr boings
12:56:35 <sethk> right
12:56:39 <sethk> :)
12:56:47 <xerox> sethk: f >>= xs = f =<< xs
12:56:51 <sethk> but it's certainly not concatMap
12:56:57 <xerox> It is :-D
12:57:02 <sethk> it is?
12:57:06 <sethk> how can it be?
12:57:17 <sethk> doesn't have the same signature, at least not the one I'm looking at
12:57:21 <sethk> let me double check,
12:57:26 <xerox> @eval (:[10]) =<< [1,2,3]
12:57:28 <lambdabot> [1,10,2,10,3,10]
12:57:41 <xerox> @eval (:[10]) `concatMap` [1,2,3]
12:57:42 <lambdabot> [1,10,2,10,3,10]
12:57:52 <xerox> @type concatMap
12:57:54 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
12:57:56 <xerox> @type (=<<)
12:57:58 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m
12:57:58 <lambdabot> b
12:58:16 <sethk> xerox, but what about:  concatMap :: (a -> [b]) -> [a] -> [b]
12:58:19 <xerox> (Tip: exchange m a  with  [a])
12:58:37 <xerox> Because lists are monads!
12:59:06 <sethk> xerox, ah, ok.  That explains it, I guess.  :)
12:59:12 <sethk> so in this context,
12:59:20 <sethk> mb === [b]
12:59:23 <sethk> m b
12:59:25 <sethk> that is
12:59:32 <xerox> instance Monad [] where -- if I could say
12:59:32 <xerox>     return = (:[])
12:59:32 <xerox>     f >>= xs = concatMap f xs
12:59:33 <Cale> sethk: the list monad?
12:59:46 <xerox> @pl (:[])
12:59:48 <lambdabot> return
12:59:53 <sethk> xerox, but concatMap also occurs in a non-monadic form, at least in the docs
12:59:54 <xerox> okay..
12:59:59 <xerox>    return x = [x]
13:00:37 <xerox> sethk: concatMap works on lists.  That's why it's used as bind function in monad instance for lists.
13:00:39 <sethk> I just downloaded a "duplicate tab" for firefox that duplicates a tab including history
13:00:57 <sethk> xerox, are there two versions, then?
13:01:02 <xerox> sethk: nope.
13:01:26 <xerox> Do you know how typeclasses work?
13:01:40 <sethk> xerox, yes
13:01:59 <sethk> xerox, but while I've mostly figured out monads over the last two days I'm still (obviously) not completely comfortable with them
13:02:52 <xerox> They let the function do dispatch on the type signature.  I.e. if you use (>>=) in a list context, you get  f >>= xs = concatMap f xs.
13:03:39 <Cale> (type classes do)
13:03:45 <sethk> xerox, one of the things I'm not clear on is what happens when there are two monads in a context
13:04:07 <sethk> xerox, if I use (in this case) a list within, say, a state monad
13:04:09 <basti_> two monads in a context?
13:04:14 <basti_> how could that happen?
13:04:21 <xerox> sethk: the outermost is the one that gets taken in consideration.
13:04:21 <sethk> basti_, you are in main
13:04:25 * basti_ nods
13:04:27 <Cale> You're just not allowed to define a single type to be a monad in more than one way.
13:04:27 <sethk> xerox, that can't be
13:04:34 <xerox> sethk: check this out.
13:04:38 <sethk> xerox, no, I can create a monad in main
13:04:46 <sethk> xerox, I can call a function from main
13:04:51 <sethk> but the IO monad is no longer "there"
13:04:59 <sethk> but
13:05:07 <sethk> I can call a function from within runState(
13:05:12 <sethk> and the state monad _is_ there
13:05:25 <sethk> as long as I don't use a runWhatever
13:05:31 <xerox> @eval [Just 1, Just 2] >>= \Just x -> [x,x*2]
13:05:32 <lambdabot> <irc>:1:21:
13:05:32 <lambdabot>   The lambda expression `\ Just x -> ...' has two argumentss,
13:05:32 <lambdabot>   but its type `a -> m b' has only one
13:05:32 <lambdabot>   In the second argument of `(>>=)', namely `\ Just x -> [x, x * 2]'
13:05:32 <lambdabot>   In the definition of `xxxx':
13:05:34 <sethk> which seems to show that the innermost is used
13:05:34 <lambdabot>    xxxx = [Just 1, Just 2] >>= (\ Just x -> [x, x * 2])
13:05:35 <basti_> you can also pass the monad into functions
13:05:36 <lambdabot>   In the definition of `v':
13:05:38 <xerox> Oops.
13:05:39 <lambdabot>    v = let xxxx = [Just 1, Just 2] >>= (\ Just x -> ...) in take
13:05:40 <lambdabot> 2048 (show xxxx)
13:05:48 <sethk> basti_, right, I can do both
13:05:49 <xerox> Boom boom boom.
13:05:56 <Cale> heh, enough of an error message for you? :)
13:06:02 <sethk> basti_, although doing them at the same time is probably not a good idea.  :)
13:06:08 <Cale> @eval [Just 1, Just 2] >>= \(Just x) -> [x,x*2]
13:06:10 <lambdabot> [1,2,2,4]
13:06:17 <xerox> Yes.
13:06:17 <basti_> sethk: uhm there's transformers for that sort of things
13:06:22 <Cale> the maybe monad is ignored
13:06:24 <basti_> not that i do understand transformers
13:06:32 <sethk> basti_, I know,. but something still happens without using transformers
13:06:48 <sethk> basti_, and as I said it appears to be the _inner_ monad that is in effect
13:06:51 <xerox> basti_: what do you mean by 'passing the monad into functions' ?
13:06:55 <Cale> sethk: there's really only one monad in use at any given time
13:06:58 <xerox> sethk: can you provide an example?
13:07:02 <sethk> Cale, yes, but which?
13:07:07 <sethk> xerox, yes,
13:07:14 <Cale> The outermost one with respect to the type
13:07:20 <xerox> Indeed.
13:07:22 <basti_> xerox: that was loosely speaking. you can use IO inside a function by making it type ... -> IO a
13:07:24 <Cale> if you have an IO (Maybe [a])
13:07:35 <sethk> Cale, then Maybe, correct?
13:07:40 <Cale> then that's an IO computation which merely returns a (Maybe [a])
13:08:05 <sethk> Cale, yes, but, again, I call foo from main, and foo is    foo = runState( whatever )
13:08:16 <sethk> Cale, the runState monad is used within foo
13:08:16 <Cale> you can't call it as an IO action
13:08:18 <xerox> @type Control.Monad.State.runState
13:08:19 <lambdabot> forall s a. Control.Monad.State.State s a -> s -> (a, s)
13:08:20 <Cale> only as a pure function
13:08:30 <sethk> Cale, no, I can't call it as,
13:08:39 <Cale> do runState ...
13:08:42 <Cale> is invalid
13:08:45 <Cale> (for main)
13:08:53 <sethk> Cale, you mean _within_ main
13:08:58 <Cale> yes
13:09:12 <xerox> @type Control.Monad.State.lift
13:09:13 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
13:09:13 <lambdabot> (Control.Monad.Trans.MonadTrans t, Monad m) =>
13:09:13 <lambdabot> m a -> t m a
13:09:43 <sethk> Cale,  So you mean by outermost the one bound most tightly to the context, if You'll permit some non-functional terms
13:10:06 <sethk> but,
13:10:08 <Cale> well, the one which in the type signature occurs "first"
13:10:15 <Cale> in left to right reading :)
13:10:25 <sethk> if I'm in foo(), say, and foo calls bar(), bar is also within the state monad context
13:10:32 <sethk> with my definition of foo
13:10:44 <sethk> as long as bar() doesn't use another monad
13:10:47 <sethk> correct?
13:10:56 <Cale> if it binds it as a State monad computation
13:10:57 <Cale> sure
13:11:02 <xerox> (Could you provide types?)
13:11:13 <Cale> Say, foo :: State a
13:11:15 <int-e> can one use lambdabot to find instances of a given class?
13:11:26 <xerox> int-e: nomore :-\
13:11:41 <int-e> aww
13:11:53 <xerox> int-e: people found it too much verbose, you could do :info Typeclass in GHCi , though.
13:12:00 <Cale> actually
13:12:07 <Cale> Say, foo :: State [a]
13:12:21 <sethk> xerox, called from main, String -> (String, String)
13:12:21 <Cale> foo = do x <- bar; y <- bar; return [x,y]
13:12:51 <Cale> then bar :: State a (for the same value of a)
13:13:03 <xerox> sethk: foo :: String -> (String, String)  is a pure function
13:13:41 <sethk> xerox, yes, but the state monad is a bit strange
13:13:52 <xerox> How is it strange?
13:14:00 <sethk> xerox, see example 15 in the monad tutorial you sent me to yesterday
13:14:08 <sethk> xerox, no monad appears in it's signature
13:14:24 <xerox> sethk: that's strange ;-)
13:14:44 <sethk> xerox, it makes sense, but it is different from other monads.
13:15:03 <xerox> getAny :: (Random a) => State StdGen a
13:15:03 <xerox> getOne :: (Random a) => (a,a) -> State StdGen a
13:15:03 <xerox> makeRandomValueST :: StdGen -> (MyType, StdGen)
13:15:12 <xerox> These ones?
13:15:51 <sethk> yes, look at the signature, though, of runState
13:16:01 <Cale> ah, yeah, my type signatures needed another type :)
13:16:10 <sethk> then look at calls from makeRandomValueST to getAny, e.g.
13:16:13 <xerox> runState :: forall s a. Control.Monad.State.State s a -> s -> (a, s)
13:16:44 <sethk> xerox, but get ghci to display the signature , it is just s -> (a, s)
13:16:47 <xerox> runState 'runs' a stateful computation, giving a tuple of the return value and the state as result.
13:16:56 <sethk> xerox, yes, I know
13:17:11 <sethk> xerox, but it takes an argument (initial state)
13:17:15 <sethk> xerox, and returns a pair
13:17:18 <sethk> (s, a)
13:17:23 <xerox> sethk: the signature of makeRandomValueST only need a State because the state action is given.
13:17:25 <sethk> which isn't monadic
13:17:36 <sethk> xerox, yes
13:17:48 <Cale> sethk: yeah, runState "gets you out of" the state monad.
13:17:54 <sethk> Cale, right
13:17:54 <xerox> runState isn't a monadic action because you couldn't escape it if it was so.  I.e. it was kinda unuseful.
13:18:02 <sethk> Cale, I think I actually understand the state monad.
13:18:07 <xerox> s/was/would have been/
13:18:13 <sethk> Cale, I know how to use it now, but I want to _understand_ it.  :)
13:18:27 <xerox> @libsrc Control.Monad.State
13:18:28 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/State.hs
13:18:38 <MarcWeber> How can I create a lazy list of random numbers?
13:18:38 <MarcWeber> I know I can get one number by using randomRIO(1::Int, 100)
13:18:56 <Cale> sethk: well, the way to understand it is to understand the definitions of =<< and return for it.
13:19:19 <xerox> instance Monad (State s) where
13:19:20 <xerox> 	return a = State $ \s -> (a, s)
13:19:20 <xerox> 	m >>= k  = State $ \s -> let
13:19:20 <xerox> 		(a, s') = runState m s
13:19:20 <xerox> 		in runState (k a) s'
13:19:21 <Cale> @type randoms
13:19:22 <lambdabot> bzzt
13:19:25 <sethk> Cale, yes.  I know the definition but I'm not sure I get all the implications of the type
13:19:36 <Cale> @type Random.randoms
13:19:38 <lambdabot> forall a g.
13:19:38 <lambdabot> (System.Random.Random a, System.Random.RandomGen g) =>
13:19:38 <lambdabot> g -> [a]
13:19:45 <Cale> @type Random.randomsIO
13:19:47 <lambdabot> bzzt
13:19:59 * sethk gets ready to duck
13:19:59 <Cale> @type Random.newStdGen
13:20:01 <lambdabot> IO System.Random.StdGen
13:20:03 <xerox> newtype State s a = State { runState :: s -> (a, s) }
13:20:09 <sethk> it seems to me that the state monad is an object
13:20:09 <Cale> MarcWeber: with randoms :)
13:20:20 * sethk closes his eyes   :)
13:20:42 <xerox> sethk: do you understand the definition of bind for the State Monad?
13:20:43 <basti_> it is not
13:20:51 <Cale> The state monad is the collection of all values of type  State s a
13:20:58 <basti_> its keeps a single semi-global variable
13:21:03 <sethk> basti_, I know it isn't, formally, but it shares some properties with an object
13:21:05 <Cale> well, that's still a lie :)
13:21:06 <sethk> basti_, so?
13:21:09 <Cale> hehe
13:21:24 <sethk> basti_, it has state and essentially a "this" pointer
13:21:35 <xerox> Cale: why does it do runState two times?
13:21:43 <basti_> well objects are thought to be many usually
13:21:49 <basti_> as in, "we got 5 objects of type A"
13:22:09 <sethk> basti_, I know, it's not a great analogy
13:22:10 <basti_> now you can make 5 State's
13:22:23 <sethk> basti_, but it is useful to someone like me who has been using objects for the last 15 years
13:22:23 <basti_> but you can't really bring them together
13:22:27 <basti_> :P
13:22:29 <Cale> xerox: it's removing a level of indirection.
13:22:33 <basti_> youre the second one to say that today
13:22:34 <sethk> basti_, yes, I know
13:22:47 <sethk> basti_, really?  I thought it was too bizarre
13:22:52 <sethk> for anyone else to say it.
13:22:58 <xerox> Cale: where does that level come from?
13:23:03 <basti_> no i mean "i've been working THAT MANY years with objects..:" ;)
13:23:20 <sethk> basti_, it's true, and it makes it harder to change the mindset
13:23:24 <Cale> xerox: from the fact that you're doing map and then join :)
13:23:26 <Cale> hehe
13:23:29 <sethk> not impossible, but harder
13:23:33 <xerox> Cale: oh right.
13:23:35 <basti_> you should forget about objects first.
13:23:40 <basti_> then you can re-learn them when you want ;)
13:23:46 <sethk> basti_, can't.  I still have to work for money
13:23:47 <Cale> and the join bit has to remove that extra layer
13:23:59 <basti_> then pretend you did when you work in haskell
13:24:08 <xerox> And join<Interrupted by Cale)
13:24:12 <xerox> Whatever.
13:24:37 <Cale> what?
13:25:09 <xerox> I was about to ask about join, I couldn't find it in Control.Monad.State.hs
13:25:20 <Cale> @index join
13:25:22 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
13:25:22 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
13:25:22 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
13:25:23 <xerox> Control/Monad/State.hs even
13:26:16 <Cale> Well, that's because when I said join, I really mean join the concept. It gets defined in terms of bind in Haskell, but in some ways it's more primitive.
13:26:19 <sethk> can ghci (or some other thing I may not know about) show all types that are instances of a particular class?
13:26:36 <Cale> :info ClassName
13:26:36 <xerox> So join is inside >>= definition, I see.
13:26:46 <sethk> where are you reading?
13:26:54 <Cale> yeah
13:26:55 <praseodym> would haskell be faster than, say, php?
13:27:05 <sethk> praseodym, I certainly hope so
13:27:15 <sethk> praseodym, but I don't really know
13:27:17 <praseodym> then /me wants drupal in haskell
13:27:26 <Cale> praseodym: it would be more maintainable :)
13:27:31 <praseodym> yeah
13:27:36 <sethk> it's interpreted
13:27:39 <sethk> not compiled
13:27:40 <praseodym> but is there anything like mod_haskell
13:27:59 <xerox> Manipulability and whipuptitude for the masses!
13:28:11 <xerox> @where hsp
13:28:12 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
13:28:16 <Cale> http://losser.st-lab.cs.uu.nl/mod_haskell/
13:28:17 <xerox> Check this out.
13:28:20 <Cale> and hsp
13:28:35 <Cale> I don't know how much mod_haskell is being worked on
13:28:46 <MarcWeber> Cale: Thanks Will have another look into the docs
13:28:55 <praseodym> nice
13:29:16 <praseodym> isnt there anyone that has done some benchmarking php vs haskell then
13:29:41 <xerox> m >>= k  = State $ \s -> let
13:29:42 <xerox>          (a, s') = runState m s
13:29:42 <xerox>          in runState (k a) s'
13:29:53 <xerox> Cale: now I get it, maybe.  m is inside the monad, right?
13:30:07 <Cale> praseodym: I wouldn't really consider them all that comparable :)
13:30:15 <Cale> xerox: yes
13:30:17 <sethk> Cale, right, m is the state
13:30:21 <sethk> Cale, or s is?
13:30:21 <xerox> Gotcha.
13:30:29 <sethk> s
13:30:29 <xerox> sethk: s.
13:30:30 <praseodym> Cale: no thats what I thought would be the problem :)
13:30:33 <sethk> but it's just a symbol
13:30:43 <Cale> s is the state, m is the State monad value
13:30:55 <praseodym> for web applications, however, speed is sometimes more needed than programming speed
13:31:05 <xerox> brr.
13:31:21 <Cale> praseodym: Haskell gets reasonable performance -- enough that I think most web applications would be practical.
13:31:59 <xerox> ...and then there are the clever profiling skills of GHC to serve.
13:32:13 <praseodym> haskell sounds like a serious alternative for developing web applications
13:32:13 <Cale> praseodym: If anything, the problem would be library availability for the sorts of things you might want to do, but this is being worked on and there are some decent libraries available.
13:32:28 <praseodym> I see
13:32:40 <xerox> For example you could use Cairo to draw PNG or anything, now!
13:32:43 * xerox whistles
13:32:44 <Cale> :)
13:32:46 <Cale> hehe
13:33:09 <Cale> praseodym: (xerox is the guy who wrote the cairo binding :)
13:33:22 <praseodym> haha
13:33:35 <praseodym> I'm all new to this though
13:33:49 <xerox> Cale: do you unicycle?
13:34:20 <xerox> praseodym: well.. welcome! :-)
13:35:02 <Cale> nope
13:35:13 <Cale> I don't even ride a bicycle :)
13:35:26 <xerox> heh!
13:35:37 <Cale> I'm strictly pedestrian for now
13:36:15 <xerox> I think I'm getting a unicycle next week :D
13:36:23 <praseodym> whats a unicycle?
13:36:25 * praseodym googlee
13:36:27 <praseodym> s
13:36:38 <tempest1> it's a bicycle with one wheel
13:36:48 <praseodym> I see
13:37:00 <sethk> xerox, I got an electric bicycle recently
13:37:04 <sethk> xerox, it's a blast
13:37:13 <praseodym> what would this one be: http://www.gilby.com/unicycling/photos/2wheeler/180_land.jpg
13:37:15 <sethk> xerox, you are going 15 and it feels like you are going 75  ;)
13:37:17 <xerox> I do skateboard these days!
13:37:43 <xerox> http://www.unicycling.org/unicycling/faq.html#Where's%20the%20other%20wheel
13:37:52 * xerox laughs pointing to that url
13:39:12 <xerox> ¬´Two wheels? That's twice as hard!¬ª
13:40:08 <tempest1> You're kidding, it was there last time I looked (and promptly fall off)
13:41:31 <xerox> Anyway, goodnight :-)
13:42:17 <praseodym> goodnight
13:42:36 <Cale> xerox: we'll have to work on Nymphaea at some point :)
13:42:40 <Cale> 'night
13:43:48 <xerox> Maybe tomorrow, it's Sunday.. :-)
13:44:22 <xerox> Cale: the new math assistant for the lab asked us to make Derive plot correctly the y = cube root of x :-D
13:45:27 <xerox> Cale: I just tried my solution on Mathematica and it seems to work ;-)
13:45:37 <shapr> praseodym: Me and my new unicycle - http://www.scannedinavian.org/~shae/unicycle/PICT3229.smaller.JPG
13:46:03 <praseodym> shapr: nice :)
13:46:21 <praseodym> shapr: is it hard?
13:46:43 <shapr> Nah, it takes an average of ten hours of learning, but then it's just like riding two wheels.
13:47:19 <shapr> Unicycles are more agile though, easier to turn, easier to hop.
13:47:37 <praseodym> cool
13:48:13 <xerox> Cale: the point being not using a root function (which derive happen to not have).
13:53:41 <shapr> hej bojohan, how's code?
14:00:00 <Lor> Hm, what's wrong with scannedinavian.org?
14:00:21 <shapr> I don't know, the root DNS servers for .org won't update. But you can change the address to .com
14:00:32 <shapr> Weird thing is that it works fine for most people.
14:01:31 <Lor> The _really_ strange thing is that www.scannedinavian.org works for me, and dns says it's just an alias for scannedinavian.org.
14:01:52 * shapr shrugs
14:02:03 <shapr> If you can figure out what's wrong, maybe I can fix it.
14:04:49 <davve> hehe
14:04:55 * davve is throwing a party
14:05:24 <davve> i've got three girls dancing for me in my room right now =) surreal
14:05:35 <shapr> wow
14:05:40 <davve> ;D
14:05:43 <shapr> Why the heck are you on irc then?
14:05:47 <davve> hehe :D
14:05:55 * JohnMeacham is recovering from last nights party.
14:06:01 * sylvan too
14:06:13 <shapr> JohnMeacham: Shall I take advantage of your current weakness to persuade you to write about Boquist?
14:06:37 <JohnMeacham> shapr: you can try.. when would you need it by?
14:06:42 <sylvan> note to self: Just because one tequila is good, and two tequila's are better, doesn't mean that infinite tequilas are infinitely better
14:06:46 <shapr> I tend to skip the alcohol, it makes it easier to chase the women.
14:06:52 <davve> sylvan =)
14:07:00 <shapr> JohnMeacham: How about exactly one month from now?
14:07:03 <davve> sylvan, you can't get enough of tequka
14:07:07 <davve> tequial, even
14:07:12 <davve> TEQUILA
14:07:20 <davve> erhhm
14:07:23 <JohnMeacham> shapr: okay, remind me in 3 1/2 weeks.
14:07:27 <shapr> hehe
14:07:30 * davve is drunk
14:07:54 <shapr> davve: And on irc, that's a terrible combination. It's better to go back to the women rather than end up on bash.org
14:08:00 <sylvan> hehe
14:08:33 <shapr> JohnMeacham: Of course, I'd like to have a bit about Boquist and how it's used in JHC.
14:09:57 <JohnMeacham> shapr: this is a very good overview http://www.cs.chalmers.se/~boquist/ifl96-abstract.html
14:10:08 <shapr> I would of course hope you would plug JHC as a cool project to work on.
14:10:14 <sylvan> JohnMeacham, how's jhc coming? I remember trying to get it to work ages ago and failing
14:10:41 <JohnMeacham> shapr: yeah, I was thinking that if I did an article, I would use it as an opprotunity to roll out a jhc mailing list
14:11:09 <shapr> Yeah, good idea.
14:12:05 <JohnMeacham> sylvan: fine. I reworked the points-to analysis so it is no longer dog-slow, musasabi is writing a library/package system for it so you can download precompiled libraries and not spend forever compiling the prelude. and I am working on fixing some (bad) bugs and adding some much needed optimizations
14:12:42 <sylvan> cool..  I'll have to give it another try some day...
14:13:12 <sylvan> Maybe autrijus' statement that Haskell is faster than C++ can become true for more than a few benchmarks if jhc works out =)
14:13:35 <JohnMeacham> Well, I'd only recommend it if you want to try hacking on it or looking at its source. :) at the moment.
14:14:04 <JohnMeacham> sylvan: Yes. that has been a thesis I want to prove.
14:14:43 <sylvan> It's already within 10% on "the shootout" so it's likely that a smarter optimization strategy could get it well ahead... Which would be really cool
14:14:56 <sylvan> Do you have any "unofficial" benchmarks versus GHC ?
14:14:59 <JohnMeacham> (that haskell can be faster than C/C++) a large part of jhcs design was about not compromising the ability to reach that goal.
14:15:13 <shapr> In that case, maybe I should jump in...
14:15:42 <JohnMeacham> no. there are several front end optimizations which are vital for it to be competitive with ghc.
14:16:23 <JohnMeacham> I have mainly worked on the back end since that was the most interesting 'new' thing about jhc.
14:16:49 <sylvan> Ah, okay... Would it be possible to reuse a front end from, say, GHC?
14:17:25 <shapr> This discussion sounds like a good basis for a JHC/Boquist TMR articl.
14:17:39 <shapr> Which front end optimizations are necessary to be competitive with GHC?
14:18:07 <JohnMeacham> sylva: not easily at all. I looked into it. there are some different world-views that would be hard to reconcile.
14:18:20 <sylvan> ah.. too bad
14:18:56 <JohnMeacham> mainly, better strictness analysis, more agressive unboxing, and single-shot-lambda/update avoidance analysis.
14:20:34 <JohnMeacham> oh. and RULES pragmas are surprisingly important. they are implemented internally, just the PRAGMAS arn't parsed yet. (hint hint for anyone looking for a project)
14:22:02 <shapr> It's interesting that JHC is under the GPL rather than BSD.
14:22:33 <JohnMeacham> shapr: Yeah. I might change that. the libraries are under BSD.
14:22:45 <Igloo> Which libraries?
14:23:11 <JohnMeacham> the lib/ directory. and if anyone wanted to use something in a BSD project, I am sure I would say yes.
14:24:54 <shapr> JohnMeacham: Where's Doc.Attr ? It's not in Dac/
14:24:57 <shapr> er, Doc/
14:27:20 <JohnMeacham> do a darcs pull in Doc/ and Boolean/
14:27:25 <shapr> oh, ok
14:27:42 <JohnMeacham> Yeah. darcs needs better support for composing projects.
14:28:13 <Igloo> You can make a meta-repo with scripts in that do all the work
14:28:29 <Igloo> I keep thinking I should write a generic one, but never get around to it
14:29:07 <JohnMeacham> But there isn't much point if I end up having to explain it to everyone and it is not transparent. _I_ have no problem working with my particular setup but if everyone rolls their own....
14:29:29 <Igloo> True
14:29:30 <syntaxfree> JHC is a new Haskell compiler?
14:29:34 <syntaxfree> it's not related to Java, is it?
14:29:41 <Igloo> Nah, YHC is a new Haskel compiler
14:29:46 <Igloo> JHC is old news now  :-)
14:29:57 <sylvan> YHC?
14:30:07 <shapr> What about a meta-repo that has a script that pulls the correct repos for you?
14:30:21 <Igloo> It's a new Haskell compiler (not yet available AFAIK)
14:30:28 <shapr> Who's doing YHC?
14:30:46 <Igloo> York people (only students involved AFAIK)
14:30:46 <JohnMeacham> mainly, I was thinking of one of two options * having a list of subrepos, which darcs pull/get/push recurse down or * having a list of sections of the project where patches must never cross between boundries of them, so you can pull just thepart needed without accidentally getting other bits of the project
14:30:49 <sylvan> villagers need more info!
14:31:34 <Igloo> (not meaning that as a put-down of students, of course, just for information)
14:31:35 <shapr> Green valkrie needs food. Green valkrie is about to die.
14:31:45 <Igloo> (today I will be mostly talking in parentheses)
14:31:50 <shapr> (why is that?)
14:31:58 <shapr> valkyrie* yow
14:32:04 <shapr> Too much swedish...
14:32:05 <int-e> (he's whispering)
14:32:06 <Igloo> (if you haveto ask the question, you could not possibly comprehend the answer)
14:32:13 <shapr> (I can't HEAR YOU!)
14:32:16 <int-e> (he's coding (lisp))
14:32:30 <syntaxfree> (i'm still very fond of lisp
14:32:33 <int-e> )
14:32:52 <shapr> )
14:32:53 * int-e can't have those unmatched parentheses (or -ises?)
14:33:03 <int-e> Oh no, now you broke me, shapr.
14:33:04 * shapr viciously irritates int-e
14:33:07 <Igloo> JohnMeacham: *nod*. I prefer the former, and it could actually be done by a generic external tool, except your fingers would keep saying the same thing
14:33:32 <Igloo> Anyway, it would be a good thing to have in darcs, but needs to be designed and implemented
14:33:40 <basti_> hey shapr i found you on orkut
14:33:46 <shapr> whee, JHC building with dual Athlon MPs is heating up my apartment...
14:33:47 * int-e gives shapr a >,[>,]<[.<] in return.
14:33:47 <JohnMeacham> Igloo. yeah, the former would be pretty easy to implement, and best of all you could have an --ignore-subrepos option and it would completely emulate the old behavior so people that don't like it can ignore it.
14:34:13 <JohnMeacham> shapr: just wait until you try to use it :)
14:34:17 <shapr> oboy!
14:34:53 <JohnMeacham> shapr: if you come across it failing to compile something due to an internal error. try it with -fno-float-inwards or -fno-rules. there is a buggy interaction between them I am still working out.
14:35:01 <rep> hello
14:35:10 <shapr> Have you tried quickcheck tests for your optimizations?
14:35:54 <tensh> is it possible to quickcheck a function with IO a as return type?
14:36:01 <Igloo> A GHC bug you mean?
14:36:05 <shapr> tensh: Sort of...
14:36:16 <shapr> I ended up using unsafePerformIO :-/
14:36:17 <JohnMeacham> shapr: not yet. but I'd really like to. I have added a --selftest option which tests everything I can think of. and started on a E.Arbitrary instance for quickcheck.. but it is a tricky problem.
14:36:33 <JohnMeacham> Igloo: no. a Jhc bug.
14:41:16 <Igloo> There's a QuickCheckM out there, isn't there?
14:41:33 <shapr> Igloo: Yeah, but it requires monads with a 'run' method.
14:42:06 <shapr> Believe me, I fought hard to keep from using unsafePerformIO, but the real fix would require rewriting about a third of QuickCheckM to handle IO.
14:42:32 <shapr> JohnMeacham: Does jhc work with make -j 3 ?
14:43:51 * shapr tries
14:44:13 * shapr turns down the electric heaters.
14:50:12 <JohnMeacham> shapr: it should.. but it might not due to ghc's odd recursive module stuff.
14:50:56 <shapr> Seems to have worked.
14:51:04 <shapr> Next question, does jhc use SMP? :-)
14:51:24 <JohnMeacham> shapr: no.. :) I traded my SMP box for a 64 bit one.
14:51:51 <shapr> aww
14:52:56 <JohnMeacham> but it is probably possible. I want it to have a 'compilation server' mode. where it will continually compile a project incrementally as you edit it, keeping a file of errors up to date. so you can just keep an editor window on the errors file and edit as you see fit in the others... perhaps syntax highlighting the errors..
14:53:54 <shapr> I should mention that in my Haskell Testing article I'm writing right now...
14:53:56 <shapr> zero button testing
14:53:56 <JohnMeacham> Ideally, there would be some standard 'compilation server' interface that all IDEs can talk to and understand.
14:54:17 <JohnMeacham> (I am including 'vim' in the IDE category :) )
14:55:41 <syntaxfree> I can't get syntax highlighting to work with the vim that ships with Panther.
14:55:49 <syntaxfree> so I'm using the gui Text Edit instead.
14:56:37 <JohnMeacham> did you try :syntax on  ?
14:56:47 <JohnMeacham> that is the extent of my knowledge.
14:57:04 * syntaxfree blushes
14:57:54 <syntaxfree> some syntax highlighting, anyway.
14:57:59 <syntaxfree> I don't need arrows in different colors.
14:58:13 <syntaxfree> I want colored parens matching!
14:58:29 <JohnMeacham> oh. there is something for that independent of syntax highlighting..
14:59:02 <syntaxfree> I want more colors, anyway.
14:59:17 <syntaxfree> All this does is to put pipes and arrows in one color and numbers in other.
14:59:19 <syntaxfree> Nothing more!
14:59:23 <JohnMeacham> I tend to use 'gvim' simply for its better colors and sane cut-n-paste behavior
14:59:31 <syntaxfree> aquavim is the suck.
14:59:33 <JohnMeacham> but I disable all the menus and whatnot
14:59:56 <syntaxfree> vim syntax highlighting for python is way superior.
15:00:42 <JohnMeacham> :color borland brings me back.
15:01:03 <JohnMeacham> speaking of standards, there should be a standard for expressing syntax highlighting rules.
15:01:45 <JohnMeacham> I find changing my :color scheme in gvim occasionally is a good way to get over coders-block.
15:02:12 <syntaxfree> so I have a function "secantroot" that extracts the root of a function via newton's method.
15:02:16 <syntaxfree> say, for instance..
15:02:25 <JohnMeacham> though. I maintain that people that like black on white text have a mental disorder.
15:03:00 <syntaxfree> *Main> secantroot (\x->x**2-2) 0.5 0.1 10e-15
15:03:00 <syntaxfree> 1.4142135623730951
15:03:32 <syntaxfree> what I want is to write an infix operator that will take a left side, a right side and subtract them (so to obtain a normal-form equation like leftside-rightsde = 0) and then run it through secantroot.
15:04:00 <syntaxfree> That way, one could do (*2) ~ (*5).(-1)
15:04:13 <syntaxfree> and have it solve 2x  = 5(x-1)
15:04:37 <JohnMeacham> make them smart constructors. so they actually build up a data structure, and then solve that structure.
15:04:53 <JohnMeacham> if I am understanding you.
15:05:25 <Igloo> JohnMeacham: Do you have :set background=dark?
15:05:40 <Igloo> And how is gvim better? Pasting where you put the mouse cursor?
15:05:42 <syntaxfree> JohnMeacham: can I see a more concrete example of that?
15:06:23 <JohnMeacham> yeah. and it can use X colors rather than the 8 or 16 fixed console ones.
15:06:36 <JohnMeacham> do :color oceandeep in gvim
15:07:03 <syntaxfree> (-2) doesn't work as a section equivalent of (\x->x-2)
15:07:06 <JohnMeacham> or :color desert  .. I am partial to 'darkocean'
15:07:10 <syntaxfree> all other sections will work.
15:07:17 <JohnMeacham> oh.
15:07:24 <JohnMeacham> responding to the wrong thing.
15:08:19 <dcoutts> JohnMeacham, you should try hIDE (when it's nearer to being mature)
15:08:32 <dcoutts> it does proper Haskell syntax highliting
15:08:54 <syntaxfree> I couldn't even begin to compile hIDE, and I didn't want to hack around to get it.
15:08:55 <JohnMeacham> dcoutts: maybe at some point. it would be very hard to switch away from gvim.
15:09:00 <dcoutts> and I'm sure we'll implement proper configurable colour schemes
15:09:03 <syntaxfree> You should make a .dmg at some point.
15:09:03 <PKirby> I am writing a minimalist C parser in Haskell with Parsec.  I am currently coding the parser for variable declarations at the start of a function.  I know how to parse the parameter list because it is delimited by ().  How do I get Parsec to do the parsing up to the point where the first word after a semicolon isn't a data type? (currently I am parsing only data types of char, int, and double)
15:09:17 <dcoutts> JohnMeacham, well Yi does a vim keybinding emulation mode
15:09:32 <dcoutts> (Yi beng the editor we're using in hIDE)
15:09:33 <JohnMeacham> (-2) doesn't work because it interprets it as (negate 2)
15:09:54 <dcoutts> syntaxfree, what was the problem?
15:10:01 <JohnMeacham> yeah. but can it parse my hundreds of lines of carefully crafted vim customizations?
15:10:11 <syntaxfree> so, what's the proper sectional form for (\x->x-k)?
15:10:23 <JohnMeacham> (+ -2)
15:10:29 <syntaxfree> hmm good.
15:10:33 <dcoutts> JohnMeacham, nope, but you can customise hIDE in Haskell :-)
15:10:34 <syntaxfree> thanks!
15:10:52 <JohnMeacham> (+ (-2)) actually...
15:10:54 <Astrality> someone who can help me with the groupBy function, it should be pretty simple but i just can't see how to do it
15:11:44 <Igloo> (subtract 2) works
15:12:20 <syntaxfree> *Main> ((subtract 2) . (**2)) 1.5
15:12:20 <syntaxfree> 0.25
15:12:21 <syntaxfree> not bad.
15:12:29 <ProfTeggy> Astrality, ask away
15:12:53 <JohnMeacham> Yeah, subtract 2 is probably better actually in case you have some odd Num instance where adding negative 2 means something different than subtracting 2. (an odd Num instance indeed)
15:13:39 <JohnMeacham> dcoutts: heh. that is a feature. perhaps. when I next have particularly bad coders block.
15:13:39 <dcoutts> PKirby, parsing C is a pain because the parser needs to know which symbols are typedefs and which are not.
15:14:19 <beschmi> syntaxfree: do you use set showmatch for paren matching?
15:14:28 <JohnMeacham> with a monadic parser, it should be easier since you can pass around state that would be difficult to do with a LR(1) parser like yacc.
15:14:29 <dcoutts> JohnMeacham, yes it's extensable by writing plugins as cabal packages
15:14:34 <syntaxfree> just curious, how old are y'all?
15:14:57 * dcoutts thinks for a moment, trying to remember his age
15:15:00 <dcoutts> 24
15:15:09 <ProfTeggy> 37
15:15:10 <JohnMeacham> are you asking a/s/l ? :)
15:15:22 <Astrality> I want to somehow group "x" number of elements in a list and make a list out of them, hmm like  [1,2,3,4,5,6] should be [[1,2,3],[4,5,6]]  if the value of the variable is 3
15:15:23 <JohnMeacham> 28/male/pasadena,ca,usa
15:15:58 <Astrality> and [[1,2],[3,4],[5,6]] if it's 2
15:16:35 <syntaxfree> think in Lisp. then translate it.
15:16:39 <PKirby> dcoutts: I am parsing my own subset of C which I am provisionally calling C'. I am including only what's 'easy' to parse. C' is compilable as C, however.  Looking at the docs, it looks like the 'try' thing might help, though I'm not sure how to use it.
15:17:13 <dcoutts> PKirby, parsec actually has a rather good tutorial
15:17:18 <dcoutts> well worth a read
15:17:25 <syntaxfree> groupby n xl = take n l: groupby n (drop n xl)
15:17:29 <syntaxfree> I  haven't tested it.
15:17:35 <int-e> let group n l = let (b,e) = splitAt n l in if e==[] then [b] else b:group n e in group 3 [1,2,3,4,5,6,7]
15:17:39 <int-e> @eval let group n l = let (b,e) = splitAt n l in if e==[] then [b] else b:group n e in group 3 [1,2,3,4,5,6,7]
15:17:40 <lambdabot> [[1,2,3],[4,5,6],[7]]
15:17:41 <dcoutts> PKirby, it should explain the try thing
15:17:45 <PKirby> I'm looking at http://www.cs.uu.nl/~daan/download/parsec/parsec.html
15:17:58 <Astrality> oh, thanks alot!
15:18:11 <syntaxfree> @eval let group n l = take n l : group n (drop n xl) in group 3 [1,2,3,4,5,6,7]
15:18:12 <lambdabot> <irc>:1:43: Not in scope: `xl'
15:18:18 <dcoutts> PKirby, http://www.cs.uu.nl/~daan/download/parsec/parsec.html#try
15:18:26 <syntaxfree> @eval let group n l = take n l : group n (drop n l) in group 3 [1,2,3,4,5,6,7]
15:18:27 <lambdabot> [[1,2,3],[4,5,6],[7],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:27 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:27 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:27 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:27 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:29 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:31 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:33 <lambdabot> [23 @more lines]
15:18:35 <syntaxfree> stop it!
15:18:49 <Pistahh> @more lines we do not want!
15:18:50 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:50 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:50 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:50 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:50 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:52 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:54 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
15:18:56 <lambdabot> [16 @more lines]
15:18:59 <int-e> syntaxfree: splitAt is a combined drop / take :)
15:19:05 <int-e> @eval 42
15:19:06 <lambdabot> 42
15:19:09 <JohnMeacham> "let's see if it stops"
15:19:10 <syntaxfree> why all the [][][][?
15:19:21 <int-e> syntaxfree: because take n [] = [] and drop n [] = []
15:19:26 <JohnMeacham> because the empty list wasn't checked for.
15:19:34 <int-e> syntaxfree: you really need to test for termination
15:19:37 <dcoutts> PKirby, if it's at all useful to you, c2hs includes a full C lexer & parser (writen my me)
15:20:01 <syntaxfree> so one more line like "group _ [] = []" would do it?
15:20:23 <int-e> yes.
15:20:38 <syntaxfree> how can I write that stuff in a single line so it can be checked through @eval?
15:20:58 <JohnMeacham> there is always 'ghci'
15:21:04 <int-e> @eval let group _ [] = []; group n l = let (b,e) = splitAt n l in b:group n e in group 3 [1,2,3,4,5,6,7]
15:21:05 <lambdabot> [[1,2,3],[4,5,6],[7]]
15:21:08 * syntaxfree has ghci :P
15:21:11 <int-e> like that ;)
15:21:47 <JohnMeacham> I have that same function in GenUtil, but I call it 'chunk'
15:21:57 <syntaxfree> @eval let group _ [] = []; group n l = take n l : group $ drop n l in group 3 [1..12]
15:21:59 <lambdabot> <irc>:1:44:
15:21:59 <lambdabot>   Couldn't match `[[a]]' against `Int -> [a] -> [a1]'
15:21:59 <lambdabot>   Expected type: [[a]]
15:21:59 <lambdabot>   Inferred type: Int -> [a] -> [a1]
15:21:59 <lambdabot>   In the second argument of `(:)', namely `group'
15:22:01 <lambdabot>   In the first argument of `($)', namely `(take n l) : group'
15:22:06 <Astrality> thanks ALOT int-e, and you too syntaxfree =)
15:22:20 <JohnMeacham> my first iteration was embarasingly inefficient. it used 'length'.. never use 'length'.. well.. rarely use length.
15:22:27 <syntaxfree> @eval let group _ [] = []; group n l = take n l : group (drop n l) in group 3 [1..12]
15:22:28 <lambdabot> <irc>:1:44:
15:22:28 <lambdabot>   Expecting a function type, but found `[a]'
15:22:28 <lambdabot>   Expected type: [[a]]
15:22:28 <lambdabot>   Inferred type: [a] -> [a1]
15:22:28 <lambdabot>   Probable cause: `group' is applied to too few arguments in the
15:22:30 <lambdabot> call
15:22:32 <lambdabot>    (group (drop n l))
15:22:34 <lambdabot>   In the second argument of `(:)', namely `group (drop n l)'
15:22:51 <syntaxfree> @eval let group _ [] = []; group n l = take n l : group n (drop n l) in group 3 [1..12]
15:22:52 <lambdabot> [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
15:22:52 <dcoutts> dons, wow, hs-plugins built ok on sparc linux with ghc 6.4.1, I wasn't realy expecting it to work
15:22:57 <syntaxfree> THERE YOU ARE.
15:23:05 <syntaxfree> Actually understandable group by :-P
15:23:08 <JohnMeacham> heh... I am thinking what it would take to write 'jhci'.. mind waiting 2 minutes for each line :)
15:23:51 <JohnMeacham> though... I can forgo points-to analysis and just write an inefficient 'eval' and get away with it for jhci probably... hmm.. something to look into.
15:23:59 <syntaxfree> @eval let group _ [] = []; group n l = take n l : group $ drop n l in group 5 [1..12]
15:24:00 <lambdabot> <irc>:1:44:
15:24:00 <lambdabot>   Couldn't match `[[a]]' against `Int -> [a] -> [a1]'
15:24:00 <lambdabot>   Expected type: [[a]]
15:24:00 <lambdabot>   Inferred type: Int -> [a] -> [a1]
15:24:00 <lambdabot>   In the second argument of `(:)', namely `group'
15:24:02 <lambdabot>   In the first argument of `($)', namely `(take n l) : group'
15:24:06 <syntaxfree> oops.
15:24:14 <syntaxfree> sorry to flood the channel like that. one more test.
15:24:26 <syntaxfree> @eval let group _ [] = []; group n l = take n l : group n (drop n l) in group 5 [1..12]
15:24:27 <lambdabot> [[1,2,3,4,5],[6,7,8,9,10],[11,12]]
15:24:30 <dcoutts> JohnMeacham, so jhc is still very slow to compile things?
15:24:53 <JohnMeacham> dcoutts: yes. but it won't be that way forever.
15:24:56 <shapr> syntaxfree: You can also use private messages.
15:25:06 <dcoutts> JohnMeacham, great :-)
15:25:41 <ProfTeggy> Night all, see you around
15:25:48 <dcoutts> JohnMeacham, actually wouldn't it be ok since in jhci you typically don't evaluate very large expressions so they shouldn't take that long to analyse
15:25:49 <JohnMeacham> dcoutts: oddly enough, each opmitization I add _speeds up compilation_ :) since it ends up presenting simpler code to the back end and you make up the lost time of the optimization there.
15:25:49 <astrolabe> Does anyone know of any web references about how to do memoization?
15:26:18 <dcoutts> JohnMeacham, that is satisfyingly counter-intuitive :-)
15:26:40 <JohnMeacham> dcoutts: but it has to reanalize the prelude and all libraries it depends on too. (at the moment) I am hoping to add some caching of partial analysis results.
15:27:08 <dcoutts> JohnMeacham, ah I see, no seperate analysis possible?
15:27:34 <syntaxfree> @eval map head $ let group _ [] = []; group n l = take n l : group n (drop n l) in group 11 [0..100]
15:27:35 <lambdabot> <irc>:1:0:
15:27:35 <lambdabot>   Ambiguous occurrence `map'
15:27:35 <lambdabot>   It could refer to either `GHC.Base.map', imported from Data.List
15:27:35 <lambdabot> at /tmp/MbpeB17973.hs:15:0-15
15:27:35 <lambdabot>          or `Data.Set.map', imported from Data.Set at /tmp/MbpeB17973.
15:27:37 <lambdabot> hs:18:0-14
15:27:46 <syntaxfree> damn, it had worked on ghci.
15:28:01 <JohnMeacham> dcoutts: it is not possible with boquists algorithm directly, but with some modification, it can be.
15:28:12 <dcoutts> right
15:28:19 <int-e> when did lambdabot start to show verbose errors like this?
15:29:00 <shapr> astrolabe: "memoize' f range = ((map f range) !!)" or "memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)" both of those are from Lor.
15:29:14 <syntaxfree> @karma-- syntaxfree
15:29:15 <lambdabot> You can't change your own karma, silly.
15:29:24 <dcoutts> JohnMeacham, so are you taking the route of structuring jhc as a lib like the new ghc api? so that other programs can use/drive it's various modules/phases?
15:29:36 <astrolabe> shapr: thanks
15:29:42 <dcoutts> the ghc api looks like it's going to be great for IDEs
15:30:13 <dcoutts> JohnMeacham, have you seen the screenshots yet of hIDE highliting type errors in the editor?
15:30:16 <JohnMeacham> I was hoping to spin off the front end as a library and the new 'hatchet' bernie pope was interested in this.
15:30:26 <dcoutts> ah yes
15:30:26 <shapr> astrolabe: Memoization works nicely with referential transparency.
15:30:27 <JohnMeacham> I will look at them.
15:30:39 <dcoutts> http://212.242.49.100/instance-aware-hide.png
15:30:48 <dcoutts> http://212.242.49.100/typechecking.png
15:31:17 <shapr> dcoutts: Can you shrink those down into smaller images I can put into my editorial?
15:31:25 <shapr> Like, smaller windows?
15:31:26 <dcoutts> shapr, ask Lemmih
15:31:40 <dcoutts> Lemmih seems to use a fullscreen style window manager
15:31:43 <JohnMeacham> ah. neat. if you come up with a standard interface for communicating with the compiler to get error info, I will make jhc support it.
15:31:46 <shapr> Probably ion3
15:32:00 <dcoutts> or if Lemmih actually commits that code then I can make some more screenshots
15:32:13 <JohnMeacham> actually, it should handle syntax highlighting too. like have an option to send back an annotated version of its input.
15:32:37 <dcoutts> JohnMeacham, actua;;y it turns out that syntax highliting is quite easy
15:32:58 <shapr> dcoutts: Any name yet for yi + hIDE ?
15:33:18 <dcoutts> shapr, as far as I know it's just called hIDE
15:33:37 <dcoutts> but Yi will continue to exist as a standalone prog too
15:33:40 <JohnMeacham> I was thinking something more complex, like enough info for a full parse so you can do refactoring type stuff in a language independent way.
15:33:46 <syntaxfree> I once saw Yi.
15:33:52 <shapr> ok
15:33:59 <shapr> JohnMeacham: yes!
15:34:15 <dcoutts> JohnMeacham, yes that'd be nice. The ghc api just exposes ghc's abstract representation
15:34:27 <dcoutts> something standardised would be nice
15:34:41 <dcoutts> but I imagine it'd be hard to agree on that standard :-)
15:35:29 <shapr> What about ATerm formatted parse trees?
15:35:36 <dcoutts> JohnMeacham, I think the HaRe refactoring people are going to use the ghc api
15:35:46 <syntaxfree> what's a good matrix manipulation library for Haskell?
15:35:50 <dcoutts> but it may not have enough info for them
15:35:53 <shapr> MetaEnvironment supports a lot of this stuff.
15:36:29 <dcoutts> for refactoring you need to preserve the original as much as possible, rather than just pretty printing the abstrat represnetation
15:36:49 <dcoutts> so you need to preserve white space & comments etc
15:37:08 <JohnMeacham> Yeah. I'd like something language independent. Probably the main reason I stay away from IDEs is I don't like switching editors just because I switch languages :)
15:37:19 <dcoutts> which is a pain for a compiler front end, since they normally get stripped out very early
15:38:00 * shapr waves the ATerm flag
15:38:13 * dcoutts is not familiar with ATerms
15:38:38 <shapr> "The Haskell ATerm library is used to interface Haskell components and Stratego components."
15:38:40 <JohnMeacham> indeed. I was hoping to create a haskell parser that preserved absolutly everything. it would also nicely solve an issue with haskell error messages, namely that you loose track of things like what type synonym was actually used in the source... if it kept track of everything it would spit out the actual lines of your source code rather than trying to reconstruct it from the internal desugared representaion.
15:38:52 <shapr> http://www.program-transformation.org/Tools/ATermLibrary
15:39:01 <dcoutts> JohnMeacham, well hopefully Yi's emacs & vim emulation will be sufficiently up to scratch to get people to switch
15:39:24 <dcoutts> JohnMeacham, right
15:39:53 <Oejet> syntaxfree: Well, there really aren't any really good ones that I've found.
15:39:55 <shapr> dcoutts: Who started hIDE and when?
15:40:25 <JohnMeacham> but will it support C, Prolog, Perl, Sather and AMPL? if I have to use a different editor for each language.. I can't imagine switching.
15:41:03 <JohnMeacham> but I will check it out some more.
15:41:08 <shapr> JohnMeacham: I dream of a re-builder like mode for interactively building parsers for new languages in hIDE/yi.
15:41:44 <dcoutts> shapr, the original histric one or the new one?
15:42:24 <shapr> The original one I guess. I was going to write a bit about the history of the hIDE project for my editorial.
15:43:08 <dcoutts> JohnMeacham, hIDE supports syntax highliting for most other programming languages (we get that for free with the editor widget we're using)
15:43:46 <dcoutts> shapr, ah well the page for the original one is: http://www.dtek.chalmers.se/~d99josve/hide/
15:44:13 <dcoutts> shapr, on that page it states "I've started development of a new hIDE version, ..."
15:44:25 <JohnMeacham> yeah, that is the dream :)
15:44:35 <dcoutts> shapr, which was a joint project between him and me
15:44:41 <JohnMeacham> If I were to implement such a thing, I am sure I would do it as a hIDE plugin.
15:45:44 <dcoutts> shapr, we got some design ideas down and some code written, but it peetered out. I moved on to working on gtk2hs.
15:46:17 <dcoutts> shapr, but we learnt quite a bit from the experience, like the right and wrong ways to run an IDE project
15:46:47 <dcoutts> shapr, I think it was ahead of it's time really, in that the tools and libs were just too imature
15:47:03 <dcoutts> and it was not designed in a modular way
15:47:10 <dcoutts> or a distributed way
15:47:29 <dcoutts> only josve knew the original code base
15:47:37 <astrolabe> shapr:  right, I can see how to memoize functions whose domains are Ixs, but what if I want to memoize a graph?
15:48:04 <astrolabe> maybe memoize is the wrong word
15:49:37 <dcoutts> shapr, these days we've got mature gui libs, darcs & plugins technology, cabal, the ghc api and we know that the code must be modular and we must develop in a team and must draw in outside contributers for the project to be sucessful
15:50:10 <dcoutts> shapr, and we have VisualHaskell as competition! no one wants to be locked into MS Visual Studio
15:50:51 <dcoutts> shapr, and the Haste example shows that it's a practical size project to tackle
15:51:15 <dcoutts> which I think had scared people off trying to build an IDE from scratch in Haskell before
15:51:50 <syntaxfree> Visual Haskell?
15:51:58 <dcoutts> people kept looking at adding Haskell support to kdevelop/eclipse/MSVS/anjuta etc
15:52:00 <syntaxfree> what is Visual Haskell?
15:52:19 <dcoutts> syntaxfree, it's a new Haskell plugin for Ms Visual Studio
15:52:46 <syntaxfree> hmm.
15:52:53 <dcoutts> shapr, because they were scarred off by the effor required to get the basics working
15:53:02 <syntaxfree> one of the key Haskell minds is working at Microsoft, ain't'em?
15:53:14 <dcoutts> syntaxfree, 2 at least!
15:53:25 <syntaxfree> also, Microsoft is officially developing an O'Caml clone.
15:53:40 <Korollary> it's not official.
15:53:52 <dcoutts> shapr, oh of couse and the other thing is yi. Showing that you can make an editor in Haskell and have it not suck.
15:54:00 <syntaxfree> interesting. Microsoft could be quite a boost to functional programming.
15:54:08 <syntaxfree> maybe it's time to stop rooting for open sores :-P
15:54:38 <dcoutts> shapr, since of course an editor is a vital component of an IDE and it's a realy pain to try an integrate advanced language dependent features into an external editor (emacs/vim/...)
15:55:22 <tuomov> everything should use an external editor
15:55:26 <dcoutts> shapr, that was another lesson of the original hIDE. the external editor thing is really hard. And negates many of the advantages of an IDE and using Haskell.
15:55:28 <tuomov> I hate it when programs have crappy internal editors
15:55:50 <dcoutts> tuomov, yep, it's important to make it not suck.
15:56:02 <tuomov> it will suck.
15:56:09 <tuomov> it won't be The Editor I Like
15:56:12 <dcoutts> well, we'll see
15:56:21 <dcoutts> it'll be customisable in Haskell
15:56:51 <syntaxfree> tuomov: do you know of people running ion3 in OS X?
15:56:56 <dcoutts> but we just can't get the features into an external editor.
15:57:02 <tuomov> some apparently do
15:57:19 <dcoutts> the stuff Lemmih has acomplished already would be very hard to do in an external editor
15:57:56 <dcoutts> and we wouldn't be able to make it extensable in Haskell which is really important
15:58:00 <tuomov> one of the reasons I will not touch a word processing package if I can avoid it is that the editors are total crap
15:58:10 <tuomov> with latex I can use the editor I like
15:58:30 <dcoutts> tuomov, which editor is that?
15:58:37 <tuomov> jed with my custom joe binding atm
15:58:49 <tuomov> (joe bindings being the essential thing)
15:59:04 <dcoutts> so what features from that do you find compelling?
15:59:47 <tuomov> and bindings are not just a mapping of keys.. search functionalities differ and so on
16:00:41 <dcoutts> indeed
16:01:07 <dcoutts> I think the console version of Yi does that
16:01:32 <tuomov> there's an incomplete joe mode for it by me..
16:01:44 <dcoutts> joe?
16:01:47 <tuomov> don't know if it works anymore.. haven't had the time to follow what's going on
16:01:51 <tuomov> "joe's own editor"
16:02:18 <tuomov> the bindings are a sort of mix between wordstar and the unix-standard part of emacs bindings
16:02:33 <tuomov> (^A^E^P^N^F^B are unix-standard movement keys)
16:03:10 <tuomov> (and I hate it when these crappy windowzy apps have ^A=totally useless selecta all, ^P=totally useless print, and so on)
16:03:37 <dcoutts> Yi works by having a lexer language for reading the incomming stream of key strokes and mapping them to editor actions
16:04:00 <dcoutts> so it's basically a DSL for writing editor emulation modes
16:04:17 <tuomov> it still sucks having to configure every single app with an internal editor to behave like your favourite editor to the limited extent it can even be configured
16:04:29 <tuomov> e.g. submaps/key sequences are seldom well supported..
16:04:43 <dcoutts> well hopefully we can write modes for the popular ones
16:04:52 <tuomov> you and everyone else..
16:05:04 <tuomov> that's the problem
16:05:15 <tuomov> the editor should be componentizable
16:05:24 <dcoutts> but you can appreciate that it's hard to use an external editor if you're trying to add more features
16:05:38 <dcoutts> eg jump to definition/documentation
16:05:59 <dcoutts> highliting compile errors
16:06:08 <dcoutts> applying refactoring tools etc
16:06:11 <tuomov> you just need to make an api for that
16:06:26 <tuomov> let people write editor plugins then
16:06:39 <dcoutts> yes but the api is very broad
16:07:36 <dcoutts> technically hIDE does not require the use of the 'internal' editor
16:07:52 <tuomov> infact, the application using the editor just needs to expose a marked-up buffer to the editor
16:08:00 <dcoutts> but I doubt we'll be able to implement the nicer language integration features for other editors
16:08:00 <tuomov> the editor doesn't need to know about folds and so on
16:08:59 <dcoutts> we could support any console mode editor that can do client/server things
16:09:06 <dcoutts> ie multiple veiws of the same buffer
16:10:04 <dcoutts> but I wouldn't want to write that integration myself :-)
16:10:26 <dcoutts> I don't know vim/emacs client server things well enough
16:10:30 <tuomov> of course, something like vis could solve the whole editor issue..
16:10:45 <dcoutts> vis?
16:10:52 <tuomov> http://iki.fi/tuomov/vis/
16:11:11 <tuomov> it's an alternative to the current insanity of hard-coded guis
16:11:24 <tuomov> _wimp_ guis
16:11:37 <tuomov> still vapourware
16:12:44 <dcoutts> I've been trying to code the hIDE UI to make it very flexable and make the APIs ok to allow other implementations of the editor shell
16:12:46 <JohnMeacham> hmm.. plugins and yi need to do a 'darcs optimize' :)
16:12:54 <dcoutts> it's not that easy to design
16:16:47 <shapr> dcoutts: So I guess this hIDE is actually a whole new project then?
16:17:15 <Oejet> I have an idea.  Have two windows with the same file; one with your favourite (dumb) editor and one with all that presentation stuff.
16:17:26 <dcoutts> shapr, yep
16:17:54 <dcoutts> shapr, it shares no code, it just borrows the name and some experience & lessons
16:18:05 <shapr> cool
16:18:32 <dcoutts> actually it may share some icons :-)
16:19:43 <JohnMeacham> ./yi-inplace README                                                                                                                      # ~/tmp/x/16/yi  4:18PM john@momenergy
16:19:43 <JohnMeacham> ./yi-inplace: line 2: 24642 Segmentation fault      (core dumped) /home/john/tmp/x/16/yi/yi_ -B/home/john/tmp/x/16/yi $*
16:19:53 <shapr> yow!
16:19:53 <JohnMeacham> hmmm....
16:20:18 <JohnMeacham> this is with the darcs plugins and yi I just grabed right now.
16:20:40 <shapr> Are you using the yi and hIDE repos from ScannedInAvian?
16:21:22 <JohnMeacham> no, from ~dons
16:22:41 <shapr> http://www.scannedinavian.org/YiWiki/DownloadYi
16:23:20 <Lunar^> shapr: and I'm going to make a Debian package soon
16:23:28 <shapr> Spiffy!
16:23:44 <JohnMeacham> hmm.. no gtk2hs in haskell/fedora. that is anoying.
16:23:48 <Lunar^> shapr: I'm struggling with hscurses right now, that's the first step
16:24:16 <JohnMeacham> Lunar^: there are debian packages for ginsu that use almost the same curses package.
16:24:29 <shapr> juhp is the man behind haskell/fedora, right?
16:24:35 <Lunar^> JohnMeacham: might be interesting to work them out
16:25:21 <dcoutts> JohnMeacham, gtk2hs is in the fedora haskell colleciton
16:26:02 <JohnMeacham> nope. I just tried to yum get it. and I looked in the repo directly and it wasn't there.
16:26:24 <syntaxfree> so Haskell is like a direct descendant from this Miranda. What does it have that Miranda hasn't, except the better licensing terms?
16:27:02 <humasec__> #haskell !
16:27:09 <cakoose> I created a new type:  data Rule = Rule { id :: String, action :: String }.  But now my field "id" conflicts with the Prelude's "id".  Is there a way to make its visibility context-specific?
16:27:13 * humasect kthx
16:27:28 <dcoutts> JohnMeacham, oh actually it wouldn't help since you need the latest version for some bug fixes
16:27:34 <JohnMeacham> pretty much everything since the introuduction of type classes. so.. a lot.
16:28:13 <dcoutts> JohnMeacham, gtk2hs is in the collection here: http://haskell.org/fedora/
16:28:27 <dcoutts> but yes you need the latest version anyway
16:29:59 <syntaxfree> humasec :)
16:31:28 <wilx> cakoose, I don't think so, you will have to rename the fields so that they do not conflict with Prelude's.
16:31:45 <JohnMeacham> hmm...  configure.ac:34: required file `gtk2hs-config.h.in' not found
16:31:59 <JohnMeacham> dcoutts: oh.. it is not in the x86_64 one I guess.
16:32:33 <cakoose> wilx: Grr...that sucks.  Thanks, though.
16:32:35 <dcoutts> JohnMeacham, oh yes it doesn't work on x86_64 before ghc-6.4.1
16:32:41 <bojohan> cakoose: or hide Prelude's `id' on import / import qualified
16:32:55 <dcoutts> JohnMeacham, and I guess it hasn't been updated in that repo for ghc-6.4.1 yet
16:34:57 <cakoose> bojohan: I'm used to structure field scope being restricted to the container.
16:35:18 <cakoose> bojohan: It would be nice if every identifier wasn't put in the global file namespace.
16:35:42 <cakoose> bojohan: But then I guess you'd get less type inference, huh?
16:37:36 <wilx> You can export only the type name without its fields.
16:51:01 <bourbaki> moin
16:51:12 <bourbaki> is there any way to map monads to coalgebras?
16:52:42 <shapr> What about comonads?
16:53:37 <bourbaki> hm so monads usually map to algebras?
16:54:33 <shapr> heck if I know, I'm just guessing
16:55:06 <bourbaki> :)
17:10:08 <Oejet> Do you know of any litterature describing GHC's UTF-8 implementation?
17:13:36 <JohnMeacham> Oejet: what utf8 implementation? there is no reason you can't roll your own or use one of the many libraries out there though.
17:15:19 <Oejet> JohnMeacham: I once heard that GHC used UTF-8 chars internally, but didn't do IO yet.  Could you point me to one of those libraries?
17:15:58 <JohnMeacham> it uses UCS4 chars internally.
17:17:33 <JohnMeacham> yeah. http://repetae.net/john/repos/jhc/  see UTF8.hs for conversion routines and CharIO.hs for replacements for the standard IO routines
17:17:49 <JohnMeacham> there are probably other ones floating around too.
17:18:40 <Oejet> JohnMeacham: Thanks!
17:22:05 <Oejet> Hm, PackedString's are ISO-8859-1 internally, it seems.
17:22:54 <syntaxfree> sometimes Haskell seems pretty related to category theory.
17:25:26 <JohnMeacham> that is no coincidence :)
17:25:46 <JohnMeacham> see my packedstring in the same directory. it is UTF8 and has very efficient conversion routines
17:32:45 <Oejet> I would have thought that uft-8 lends itself nicely to GHC's default representation of strings as [Char].  So why UCS4?
17:34:23 <JohnMeacham> because each Char cooresponds to one unicode codepoint.
17:35:06 <JohnMeacham> UCS4 just means one 32 bit number for each character. so it is not really an encoding.
17:42:01 <Oejet> I'm looking for possible optimizations in the general case of ASCII or iso-latin-1 strings.  Maybe tag the strings, one bit.  The rest could be used for a length field.
17:57:11 <JohnMeacham> Yeah, I experimented with adding a flag as to whether the string was just ASCII.. It didn't really seem worth it.
17:57:54 <araujo> Hello.
17:58:00 * araujo back from dinner
18:00:52 <Oejet> JohnMeacham: As in it didn't increase the speed noticably?
18:05:46 <JohnMeacham> Oejet: not really. and it complicated various functions. most operations, concating, comparing, reading/writing don't need to care what the encoding is so always having utf8 is not really any overhead.
18:40:14 <JohnMeacham> qua? I made some inconsequential change to jhc and it fixed a major bug in another section... how odd.
18:50:13 <sethk> why don't these have the same type?     ("abc" ++ "def")     ("abc"(++)"def")
18:51:21 <Oejet> sethk: ("abc"(++)"def") <-- The inner parenthesis look wrong.
18:51:27 <sethk> yes
18:51:29 <sethk> but why?
18:51:30 <Cale> because in one, ++ is an infix operator, and in the other, it's not
18:51:46 <sethk> (++) is not infix?
18:51:49 <Cale> (++) "abc" "def"
18:51:52 <sethk> ok
18:51:57 <Cale> @eval (++) "abc" "def"
18:52:03 <lambdabot> "abcdef"
18:52:16 <humasect> @eval "abc" (++) "def"
18:52:17 <lambdabot> <irc>:1:0:
18:52:17 <lambdabot>   The function `"abc"' is applied to two arguments,
18:52:17 <lambdabot>   but its type `[Char]' has none
18:52:17 <lambdabot>   In the definition of `xxxx': xxxx = "abc" (++) "def"
18:52:17 <lambdabot>   In the definition of `v':
18:52:19 <lambdabot>    v = let xxxx = "abc" (++) "def" in take 2048 (show xxxx)
18:52:21 <lambdabot>   In the definition of `resource': resource = let v = let ... in ...
18:52:23 <lambdabot> in v
18:52:41 <sethk> ghci bars on   :t ++
18:52:45 <sethk> barfs, that is
18:52:50 <Oejet> All infix operators can be made prefix with (..).
18:52:52 <Cale> use (++)
18:52:56 <Cale> @type (++)
18:52:58 <lambdabot> forall a. [a] -> [a] -> [a]
18:53:00 <sethk> right
18:53:05 <sethk> but I was trying to see the difference
18:53:12 <Cale> they have the same type
18:53:13 <sethk> so doing (++) didn't answer my question
18:53:23 <humasect> and all prefix can be made infix with `` ...
18:53:30 <Cale> it's just that one is infix syntactically
18:53:30 <humasect> @eval "abd" `(++)` "def"
18:53:32 <lambdabot> <irc>:1:7: parse error on input `('
18:53:34 <sethk> humasect, I knew that, but not the other
18:53:45 <JohnMeacham> '(++) a b' is equivalant to 'a ++ b'  and 'foo a b' is equivalant to 'a `foo` b'
18:53:46 <sethk> humasect, hm, what's wrong with that?
18:53:46 <Cale> I don't think you can go back and forth
18:53:57 <sethk> Cale, you mean you can't do `(++)`
18:53:58 <Cale> `identifier`
18:54:02 <humasect> sethk, not sure.. parser. maybe ghci, wonder about GHC itself.
18:54:11 <sethk> humasect, ok
18:54:11 <Cale> you can only put an identifier between ``s
18:54:15 <Cale> not an expression
18:54:22 <sethk> ah, that makes some sense
18:54:25 <humasect> but (++) becomes identifier, maybe on a seperate stage.
18:54:32 <humasect> oh ok. "expression"
18:54:34 <sethk> separate
18:54:47 <sethk> @eval (++)
18:54:49 <lambdabot> <irc>:1:20:
18:54:49 <lambdabot>   No instance for (Show ([a] -> [a] -> [a]))
18:54:49 <lambdabot>   arising from use of `show' at <irc>:1:20-23
18:54:49 <lambdabot>   Probable fix: add an instance declaration for (Show ([a] -> [a] ->
18:54:49 <lambdabot> [a]))
18:54:50 <lambdabot>   In the second argument of `take', namely `(show xxxx)'
18:54:53 <lambdabot>   In the definition of `v': v = let xxxx = (++) in take 2048 (show
18:54:54 <lambdabot> [3 @more lines]
18:55:10 <sethk> oh, I wanted @type, didn't I
18:55:28 <Cale> its type is [a] -> [a] -> [a]
18:55:44 <sethk> yes, you did that earlier, I see it now
18:56:00 <sethk> I just wanted the lambdabot syntax so I tried it.  incorrectly.  :)
18:56:05 <sethk> @type (++)
18:56:06 <lambdabot> forall a. [a] -> [a] -> [a]
18:56:14 <sethk> ghci likes :t (++)
18:57:02 <sethk> but I forgot about infix to prefix, although I remembered about prefix to infix
18:57:05 <Cale> The @type command runs ghci
18:57:36 <humasect> heh.
18:57:57 <sethk> Cale, that could explain why the answers are the same.  :)
19:41:23 <__ant__> Hi everyone. Can you please help me? I'm trying to decipher this haskell function:
19:41:26 <__ant__> datatypeAllows :: Datatype -> ParamList -> String -> Context -> Bool
19:41:26 <__ant__> datatypeAllows ("", "string") [] _ _ = True
19:41:26 <__ant__> datatypeAllows ("", "token") [] _ _ = True
19:41:26 <__ant__> I don't understand that ("", "string") part - what is it supposed to mean?
19:42:13 <Cale> It's an ordered pair consisting of an empty string and the string "string"
19:42:26 <__ant__> (Unfortunately I'm no haskell programmer, yet the algorithm that I'm facing is described in haskell. So far I understood, but now I got stuck...)
19:42:36 <Cale> Apparently a value of type "Datatype"
19:42:42 <__ant__> Cale: aha, thanks
19:42:53 <Cale> which means that Datatype is just a type synonym
19:43:03 <Cale> type Datatype = (String, String)
19:43:05 <Cale> most likely
19:43:33 <__ant__> ok, I needed that "ordered pair" knowledge bit ;)
19:43:35 <__ant__> Thank you
19:43:40 <Cale> no problem
19:45:59 <sethk> cale, I've got something here that works and I can't figure out why.  :)
19:46:12 <sethk> Cale, I'm looking at the various monads and making small programs that use them
19:46:17 <sethk> I'm on the reader monad
19:46:30 <sethk> it has this:    local :: (r->r) -> m a -> m a
19:46:45 <sethk> and I have the following call.  modifyEnv is String -> String
19:46:56 <sethk> xyz - local (return "abc") modifyEnv
19:47:01 <sethk> sorry
19:47:09 <sethk> xyz = local (return "abc") modifyEnv
19:47:15 <sethk> Cale, which looks backwards to me.
19:47:26 <sethk> Cale, but it works this way, and if I reverse it, the compiler rejects it.
19:47:43 <sethk> Cale, this is not within runReader( ... )
19:47:59 <sethk> Cale, if you look at the definition of local, it does it's own runReader
19:48:16 <sethk> Cale, obviously I've made the environment a String
19:48:25 <sethk> Cale, environment as used in the doc for ReaderMonad
19:48:39 <sethk> Cale, Control.Monad.Reader       to be correct
19:48:40 * Cale reads
19:48:40 <sethk> sorry
19:48:52 <sethk> local :: (r -> r) -> m a -> m a
19:49:15 <sethk> Cale, for my r -> r I used a String -> String
19:49:28 <Cale> odd
19:49:36 <sethk> Cale, and it works; it creates a monad whose environment is set to the string returned by modifyVal
19:49:55 <sethk> Cale, ok, if it looks a bit odd to you maybe I'm making some progress.  :)
19:50:04 <Cale> well, let me have a look :)
19:50:10 <sethk> Cale, thanks.  :)
19:52:19 <sethk> Cale, the instance declaration (from the monad document) is:        local f c = Reader $ \e -> runReader c (f e)
19:52:37 <Cale> hmm...
19:53:04 <sethk> Cale, I retrieve the value with ask, which works fine
19:53:04 <Cale> runReader (do x <- local reverse ask; return x) "hello"
19:53:15 <Cale> this appears to work
19:53:20 <sethk> yes
19:53:25 <sethk> mine works also, I just don't understand why
19:53:46 <sethk> let me look up reverse...
19:54:33 <sethk> ok, reverse reverses a list.  But ask doesn't return a list
19:54:38 <sethk> so I'm a bit lost again
19:54:50 <sethk> or is it the other reverse from prelude?  I looked at reverse from Data.List
19:55:12 <sethk> hmm., same thing.  Which is actually a good thing.  :)
19:55:12 <Cale> local applies a function to the environment and runs the reader you pass it in the modified environment
19:55:42 <sethk> right.  So "the reader you pass it" is in my example from   (return "abc")
19:55:49 <Cale> no
19:55:53 <sethk> no?
19:55:59 <sethk> it's the only one I pass it
19:56:01 <Cale> oddly, it's reverse :)
19:56:06 <Cale> hehe
19:56:11 <sethk> reverse is a monad also?
19:56:15 <Cale> MonadReader r ((->) r)
19:56:31 <sethk> runReader (r -> a)
19:56:47 <sethk> Cale, how do you read    r ((->) r)  ?
19:57:00 <sethk> I don't understand what the parens are saying (or doing)
19:57:07 <Cale> ah
19:57:16 <Cale> -> is an infix type constructor
19:57:21 <Cale> (->) makes it prefix
19:57:30 <Cale> ((->) r) applies it to the type r
19:57:34 <sethk> ok, my attention span is fading fast at my advanced age
19:57:36 <Cale> so it's rather like (r ->)
19:57:47 <sethk> but if it makes it prefix, then is it a partial application?
19:57:49 <Cale> so functions from the type r
19:57:51 <Cale> yes
19:57:54 <sethk> ok.
19:58:07 <sethk> so  takes an r, and returns a function that, when called, returns an r
19:58:25 <Cale> a function that takes an r and returns something unspecified
19:58:35 <sethk> right, prefix
19:59:03 <sethk> that signature is an instance, right?
19:59:18 <Cale> so if m = ((->) r)
19:59:43 <Cale> then local :: (r -> r) -> m a -> m a = (r -> r) -> (r -> a) -> (r -> a)
20:00:08 <sethk> ok, that has r -> a in the middle is your point
20:00:26 <Cale> yeah
20:00:44 <sethk> but that would make    (return "abc")   r -> r
20:00:58 <Cale> yeah, that's odd...
20:01:08 <Cale> oh, right it is
20:01:15 <sethk> why?
20:01:27 <Cale> well, r = String
20:01:46 <Cale> as well as a
20:02:02 <Cale> and in the monad ((->) r), return x = \r -> x
20:02:07 <sethk> (return "abc") :: (Monad m) => m [Char]
20:02:15 <Cale> right
20:02:20 <Cale> and m = ((->) r)
20:02:25 <sethk> ok
20:02:47 <Cale> so in this case, (return "abc") :: r -> [Char]
20:02:51 <sethk> and runReader is (r -> a)
20:02:57 <sethk> and local is implemented with runReader
20:03:27 <koston> hello guys! , does someone know how to install Wxhaskell on windows ?? I tried with GHC and the latest Wx pack.. but it didn't install right =(
20:04:29 <Cale> koston: I'd probably be more help if I ran windows... but what seemed to happen?
20:06:05 <Cale> sethk: well, you can't apply runReader to this (local (return "abc") blah)
20:06:13 <koston> the "make" program said that I havent installed the right GHC , but i did ..
20:06:27 <Cale> because the result of that local is a function [Char] -> [Char]
20:06:53 <Cale> koston: hmm -- did you/could you run configure first?
20:07:01 <sethk> Cale, yes, that's correct:  I call it with this:    s <- return (testReader2 "ssss")
20:07:32 <Cale> sethk: but of course, that's a rather odd way to use the local function :)
20:07:36 <sethk> koston, is it possible that you need to change the first make in the path to be gnu make?
20:07:45 <sethk> Cale, yes, but it's just a test program
20:08:00 <sethk> Cale, even if it makes no sense the types need to match.  :)
20:08:26 <sethk> Cale, I actually took my state monad test program as a base for this one.
20:08:40 <sethk> Cale, so it sort of makes sense from an evolutionary perspective.  :)
20:08:56 <Cale> koston: also note that there's a binary release for windows if it's being a pain
20:09:04 <koston> ahh sorry , the GHC install program is a .msi file , but when i tried to compile Wxhaskell it said that i havn't istalled GHC , windows is fucked up ! =)
20:09:38 <koston> Cale: ok
20:09:54 <Cale> sethk: :)
20:10:08 <Cale> sethk: I like to think of the reader monad as half a state monad
20:10:20 <sethk> Cale, yes, that's what I was thinking.
20:10:26 <sethk> Cale, look at this type from ghci
20:10:33 <Cale> there's also the writer monad, which is the other half :)
20:10:33 <sethk> MR.local :: (Control.Monad.Reader.MonadReader r m) =>
20:10:46 <sethk> (r -> r) -> m a -> m a
20:10:53 <Cale> right
20:10:56 <sethk> Cale, the part before => is a class qualifier, right?
20:10:59 <Cale> right
20:11:14 <sethk> cale so wouldn't that mean that the instance used is MonadReader s m => MonadReader s (ListT m)
20:11:26 <sethk> wait
20:11:31 <sethk> there is also
20:11:31 <Cale> (MonadReader r m) is like a predicate that some pairs of types (r,m) will satisfy
20:11:46 <sethk> MonadReader r m => MonadReader r (StateT s m)
20:11:57 <Cale> It's the MonadReader r ((->) r) instance that's being used, I'm fairly sure.
20:12:04 <sethk> so I have to look at instances of the form MonadReader something something2
20:12:14 <koston> Cale: maybe I'l install slackware 10.1 , is becomes mutch esier then =)
20:12:19 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.Reader.html -- there's a list of them here
20:12:45 <sethk> Cale, thanks.  I'll have to wade through it and see if I can understand how the compiler chooses one instance
20:13:02 <sethk> Cale, how it infers a specific enough type to choose one, I guess is a better way to say it
20:13:28 <Cale> It chose ((->) r) because of the thing passed as the second argument to local was a function from r
20:13:40 <Korollary> I think there are some verbosity flags for ghc that can be helpful.
20:13:58 <sethk> Korollary, thanks.  I'll look into that.
20:15:02 <Cale> typeclasses, especially multiparameter ones, are very cool tools for type directed programming, but can be rather mysterious at first. :)
20:15:33 <Cale> You basically have a funny decidable version of prolog in the type system :)
20:15:34 <sethk> Cale, actually I'm not really having problems with the classes concept.  It is straightforward in terms of having an exact analog in imperative programming
20:15:49 <Cale> oh?
20:15:59 <sethk> Cale, yes, I was reading something about sequents which talked a bit about prolog
20:16:05 <Cale> I suppose they're sort of like Java interfaces, though a good deal more general.
20:16:10 <sethk> Cale, you have type signatures, and default implementations
20:16:24 <sethk> Cale, and instance looks very much like an OO derived class
20:16:32 <sethk> Cale, without any variables or state, of course
20:16:44 <sethk> Cale, but you can code the same thing in an OO language
20:16:46 <Cale> well, single parameter ones anyway :)
20:17:03 <sethk> Cale, kind of like a c++ class with virtual functions and/or pure virtual functions
20:17:16 <sethk> Cale, I know it's not the same, but it's close enough that the concept is easy to understand
20:17:26 <Cale> multiparameter typeclasses basically let you relate a bunch of existing types to one another, and provide functionality on them wherever that relation holds.
20:17:29 <sethk> Cale, unlike monads, which require a different way of thinking altogether.
20:17:41 <Cale> :)
20:17:51 <Cale> well, monads are an example of a typeclass :)
20:18:06 <sethk> Cale, ok.  I know I have to look at the classes carefully, and deal with the less simple ones, but the concept is not difficult
20:18:16 <sethk> Cale, although what you just mentioned,
20:18:24 <sethk> Cale, having a relation to satisfy, that is
20:18:32 <araujo> Monads are just that, a typeclass right?
20:18:37 <Cale> yeah
20:18:40 <sethk> Cale, doesn't correspond to anything I can think of in imperative code.
20:19:04 <Cale> araujo: yes
20:19:04 <sethk> araujo, in the sense that they implement the Monad class, yes
20:19:07 * araujo has been grasping at this monad thing slowly
20:19:34 <Cale> I'll paste from the prelude:
20:19:39 <Cale> class  Monad m  where
20:19:39 <Cale>     (>>=)  :: m a -> (a -> m b) -> m b
20:19:39 <Cale>     (>>)   :: m a -> m b -> m b
20:19:39 <Cale>     return :: a -> m a
20:19:39 <Cale>     fail   :: String -> m a
20:19:40 <Cale>         -- Minimal complete definition:
20:19:43 <Cale>         --      (>>=), return
20:19:44 <Cale>     m >> k  =  m >>= \_ -> k
20:19:48 <Cale>     fail s  = error s
20:19:56 <Korollary> A monad's definition is actually very simple.
20:20:00 <Korollary> err, see above
20:20:04 <sethk> Cale, in the docs the definition of a monad is actually not that
20:20:13 <wagle> state monad seems quite similar to stuff i've done passing things around in prolog or attribute grammars
20:20:20 <sethk> Cale, for example, the docs say that it is good to make a monad an instance of the Monad class
20:20:21 <Cale> sethk: well, it has to satisfy a few laws
20:20:24 <sethk> but not a requirement
20:20:32 <sethk> Cale, yes, I read the laws.
20:20:40 <sethk> Cale, I even understood all of them except one.  :)
20:20:50 <Cale> sethk: right - really monads only exist in a fairly restricted way in Haskell.
20:20:56 <wagle> assoc?
20:21:07 <sethk> wagle, yes, that one I have to struggle with for a bit
20:21:17 <sethk> wagle, plug some concrete types into the equation and see what it meant
20:21:19 <Cale> sethk: they're actually a concept from category theory, a newish branch of mathematics
20:21:39 <sethk> Cale, yes, I know.  Although I've only read catagory theory when I came across something else that required it
20:21:44 <sethk> Cale, I should read up on it
20:22:08 <sethk> seems to be a rather essential piece of the puzzle
20:22:17 <sethk> but I can't assimilate all of the puzzle at once
20:23:02 <Cale> The trouble is that most of the material on category theory assumes that you have at least an undergraduate degree in pure mathematics, but there are starting to be resources for CS people.
20:23:24 <Cale> A lot of good categories are branches of mathematics.
20:23:39 <sethk> Cale, my problem is that it's been quite some time since I really studied any math, and I'm reacquainting myself with certain things
20:23:46 <wagle> barr and wells book assumes you are cs
20:23:48 <Cale> The category that we care about in Haskell is the category of Haskell types and Haskell-definable functions.
20:25:03 <Cale> but sets and functions, vector spaces and linear transformations, groups and group morphisms, partially ordered sets and monotone functions, topological spaces and continuous maps, and lots of other things are the standard examples.
20:28:01 <sethk> Cale, well, I've worked with several of those, of course, having once been proficient in the math used in EE and physics
20:28:21 <sethk> transformations and vector spaces are important to fields and waves, and such
20:30:35 <Cale> that's good :)
20:31:00 <sethk> but EE is very much _applied_ math
20:31:11 <sethk> so the more general concepts are unfamiliar at times
20:31:32 <sethk> that's why I find it so much easier to go from a specific example to the general concept, instead of v.v.
20:32:08 * araujo back
20:32:39 <Cale> hehe, I have the opposite problem that things often don't seem interesting to discuss at first if they start too specific :)
20:32:44 <araujo> Ok, guys, i have read a few docs abut monads, but i still fail to see how it connects for example, with implementing imperative features for example.
20:33:14 <Torrente> lateral effect
20:33:27 <araujo> As far as i know, a monad is a sequence of computation right?, It is a big computation composed by smaller computations right?
20:33:43 <Cale> araujo: that's one way of looking at it
20:34:04 <Cale> well, a value in a monad
20:34:07 <araujo> So, it is a way to pass infromation from one function to another without losing state with each state transformation.. or something like that?
20:34:08 <Korollary> araujo: Have you read Tackling the Awkward Squad ? It cannot be explained in simpler terms, imho
20:34:24 <araujo> Korollary, No, link please?
20:34:41 <Korollary> http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/
20:34:50 <araujo> Thanks Korollary
20:35:05 <Cale> araujo: you might also like the completely opposite view of monads http://www.haskell.org/hawiki/MonadsAsContainers
20:36:01 <Torrente> I think that Monads are like a paradigm of programming...
20:36:24 <araujo> Thanks Cale
20:36:25 <Korollary> heh Cale, I was just thinking "I should paste Cale's version"
20:36:32 <araujo> Everything that helps is welcome :-)
20:36:33 <Torrente> and have diferents points of view
20:37:14 <Cale> they're more general than a paradigm of programming actually :)
20:37:43 <Torrente> you can read "Introduction to functional Programming" (Richard Bird)
20:37:54 <Torrente> Chapter10
20:38:56 <Torrente> Cale: you think?
20:40:55 <Torrente> Cale: why?
20:42:52 <Torrente> http://citeseer.csail.mit.edu/cache/papers/cs/4583/http:zSzzSzcm.bell-labs.comzSzwhozSzwadlerzSztopicszSz..zSzpaperszSzmonadszSzmonads.pdf/wadler92comprehending.pdf
20:57:15 <Cale> Torrente: well, they're a more general mathematical concept that needn't be applied to CS at all
20:59:35 <sethk> actually, the first few lines of the paper notes that monads are borrowed from category theory
21:03:13 <Lemmih> Good morning, #haskell.
21:04:17 * araujo just got a 30gigs.com account
21:04:30 <araujo> I can share some invites with some haskellers if anyone interested
21:04:31 <araujo> :-)
21:14:05 <Torrente> Cale: ok
21:14:17 <Torrente> Cale: that is true
21:14:52 <Torrente> Torrente: but in a functional point a view....
21:15:03 <Torrente> Cale: Cale sorry
21:21:06 <Cale> Torrente: nothing to apologise for :)
21:21:32 <fnord123> hello
21:21:39 <Cale> or do you mean that you directed your message at yourself? :)
21:21:45 <Cale> hi fnord123
21:22:01 <fnord123> anyone working on any projects?
21:23:06 <Lemmih> Yeah.
21:23:53 <fnord123> im kinda bored. im wondering if i can poke my head into a project or two and see if i can help
21:24:11 <fnord123> actually i just pulled the latest patches for yi. ill have a play on that
21:25:47 <Torrente> Cale: hahaha, yea
21:27:06 <Cale> certainly, even restricted to a programming setting, it's an abstraction which there will be lots of different ways to think about.
21:28:32 <Torrente> Cale: true
21:29:04 <Cale> so I agree with you there :)
21:32:23 <Torrente> I'm locking a conection between a type inference algorithm and a monad.... obviosly, not the simple state monad
21:32:35 <Torrente> someone know about this?
21:33:04 <Cale> hm?
21:33:25 <Cale> could you rephrase that?
21:34:15 <Torrente> a monadic type inference algorithm
21:34:17 <Torrente> but...
21:34:21 <cods> Where can I found explanation of '->' as used the example in http://www.nomaware.com/monads/html/class.html just before 'Summary' near the end, when declaring mothersPaternalGrandfather. I can't find what's supposed to do exactly.
21:34:31 <Torrente> not with the state monad
21:34:42 <Cale> cods: -> or <-
21:34:56 <cods> that's a question ? It's '->'
21:35:19 <Cale> could you paste exactly which code you're referring to? -> is used in a few ways in Haskell
21:35:24 <cods> in "mothersPaternalGrandfather s = mother s >>= \m -> father m >>= \gf -> father gf"
21:35:40 <Cale> ah, that's just part of the syntax for lambda expressions
21:35:47 <Cale> @eval (\x -> x+1) 5
21:35:49 <cods> oh
21:35:58 <cods> yes, I missed the \
21:36:06 <cods> my bad. Thx :)
21:36:07 <lambdabot> 6
21:36:15 <Cale> heh, slow lambdabot :)
21:36:37 <Torrente> lol
21:37:03 <Cale> I wonder if the machine it's on is doing something else at the moment.
21:37:31 <cods> the way it's indented seem confusing from the example I was looking that.
21:37:57 <Torrente> hahaha
21:37:59 <cods> with line break after each '->'
21:38:03 <Cale> cods: yeah, it's a little odd, that's the way monadic code tended to be indented before do-notation
21:38:40 <Cale> Torrente: are you saying you're looking for a good monad to keep track of the information necessary for type-inference?
21:38:40 <Torrente> do-notation = syntax sugar for "->"
21:38:49 <Cale> syntax sugar for >>=
21:38:59 <Cale> and >>
21:39:13 <Cale> but yeah, I suppose the lambdas as well
21:39:14 <Cale> :)
21:39:57 <Cale> do {e} = e
21:40:02 <Torrente> sorry
21:40:03 <Torrente> >>=
21:40:08 <Cale> do {e; stmts} = e >> do {stmts}
21:40:08 <Torrente> haha
21:40:23 <Torrente> god
21:40:43 <Cale> do {p <- e; stmts} = let ok p = do {stmts}; ok _ = fail "..." in e >>= ok
21:41:04 <Cale> do {let decls; stmts} = let decls in do {stmts}
21:41:21 <Cale> :)
21:41:25 <Cale> that's the translation
21:41:46 <Cale> where "..." is a compiler-generated error message that the pattern didn't match
21:42:14 <Cale> incidentally, this is the reason that there's that "fail" method in the monad class.
21:44:10 <Cale> naively, that last one is just  do {p <- e; stmts} = e >>= \p -> do {stmts}
21:47:01 <cods> Is there a good html reference on the web about haskell ? I'm lost with all the documentation listed by bookshelf haskell pages.
21:47:15 <cods> I mean, something online.
21:47:41 <sethk> cods, the tutorials don't help?
21:48:56 <cods> I've tutorials to understand Haskell, but I don't have reference manuel online (sure I can download pdf for that..) to look precisely how are defined some of the part of the language.
21:49:26 <Cale> http://www.haskell.org/onlinereport/
21:49:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
21:50:00 <cods> oops :)
21:50:07 <Cale> that's the Haskell 98 standard, and the current GHC hierarchical libraries
21:50:33 <Cale> If you want documentation on various extentions to Haskell, they're somewhat scattered...
21:50:50 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:50:59 <Cale> that's a fairly major one though
21:51:00 <cods> the http://www.haskell.org/onlinereport/ is linked from where ? (Just curious how I missed it)
21:51:40 <Cale> http://haskell.org/ -> Definition of the Language and the Standard Libraries -> The Haskell 98 Report (Revised)
21:52:51 <cods> oh.. I naively looked at what was listed below 'The Haskell 98 Report (Revised)' but don't tried to click that..
21:53:41 * cods is confused easily
21:54:03 <cods> Thanks again.
22:40:16 <Korollary> araujo: I could use an invite
22:57:07 <araujo> Korollary, Good,
22:57:15 <araujo> email? :-)
22:59:42 <sieni> argh, how can the haskell-mode indentation be so goddamn broken
23:00:22 <araujo> mm.. sieni emacs?
23:00:32 <sieni> yes
23:00:49 * araujo has noticed some weird things too
23:01:06 <sieni> well, emacs is a piece of crap anyway
23:01:10 <araujo> Sometimes my where are indenting differently.
23:03:38 <Lemmih> You can hit tab several times to go through all possibilities.
23:04:41 <sieni> Lemmih: Yes I noticed
23:05:59 <araujo> Lemmih, i do, nevertheless, i sometimes i can't get the correct indenting.
23:06:30 <Lemmih> hIDE will most likely do a better job at auto-indentation.
23:06:53 <araujo> That'd be cool
23:10:10 <humasect> will?
23:10:38 <humasect> sieni: i manually indent with haskell-mode ... two spaces. haven't tried vim
23:30:32 <PKirby> I want to write a function that acts like (++) on a pair of [Char] but also puts some fixed strings of text at the beginning, inbetween, and at the end. Suggestions?
23:34:06 <sieni> PKirby: What's wrong with: mypp x y = "Fixed text" ++ x ++ "Fixed text 2" ++ y ++ "Fixed text 3" ?
23:35:55 <PKirby> I want to make an infix function, so I can do string1 `myinfix` string2 somewhere else in the program.
23:37:00 <sieni> Well, then use "foo" `mypp` "bar"
23:39:20 <PKirby> yay! it worked.
23:49:22 <magnus--> Is this a bug of hugs or according to haskell semantics?:
23:49:37 <magnus--> cartesianProduct xs ys = nub $ sort [ x * y | x <- xs, y <- ys]
23:49:42 <magnus--> prod = cartesianProduct
23:49:51 <magnus--> cartesianProduct and prod now have different types!
23:50:06 <basti_> :-o
23:50:11 <orbitz> hello, i am looking ot implement the BLAST algorithm, do you think a Haskell compiler could produce efficietn enough code?
23:51:01 <basti_> magnus--: this is very strange
23:51:25 <basti_> orbitz: efficient enough for doing -what-?
23:51:46 <orbitz> basti_: well the BLAST algorithm eneds to do quite a bit of work and takes awhiel to run
23:52:12 <magnus--> cartesianProduct :: (Num a, Ord a) => [a] -> [a] -> [a]
23:52:17 <magnus--> prod :: [Integer] -> [Integer] -> [Integer]
23:52:28 <basti_> magnus--: i checked that, it happens the same to me...
23:52:31 <basti_> even in ghci
23:52:40 <basti_> orbitz: yes it does, actually.
23:52:46 <magnus--> prevents my program from working :)
23:52:48 <basti_> orbitz: what kind of thing do you want to know? ;)
23:53:05 <Lemmih> magnus--: It's intentional.
23:53:15 <orbitz> basti_: well generally it's implemetned in C or possibly PERL, i'm simplly tryign to determine fi i should spend time on a native haskell implementation
23:53:15 <basti_> Lemmih: how does that happen?
23:53:38 <basti_> orbitz: it won't be as fast as C, but that's a no-brainer.
23:53:51 <orbitz> basti_: excelelnt
23:53:57 <magnus--> Lemmih: (as basti said)
23:54:01 <basti_> but then, if people code it in Perl and are happy...
23:54:03 <orbitz> would you know of any MPI equivalents?
23:54:48 <basti_> theres a thing called "STM"
23:55:02 <basti_> its not suited for multiprocessor stuff yet
23:55:07 <Lemmih> basti_, magnus--: http://haskell.org/hawiki/MonomorphismRestriction
23:55:11 <basti_> but it might be at some point in the future
23:55:26 <basti_> ah that darn monomorphism restriction
23:55:57 <basti_> but why does it pick Integer, then?
23:56:05 <dons> -fno-monomorphism-restriction ;)
23:56:08 <basti_> instead of breaking
23:56:16 <dons> most general type?
23:56:28 <basti_> Integer is the most general Num and Ord?
23:56:31 <basti_> hmm
23:56:35 <basti_> theres a point to that.
23:56:44 <Lemmih> basti_: That's probably the defaulting.
23:56:54 <dons> @type 1 :: Integer
23:56:59 <lambdabot> Integer :: Integer
23:57:03 <dons> doh.
23:57:04 <dons> @type 1
23:57:06 <lambdabot> forall t. (Num t) => t
23:57:06 <Lemmih> basti_: You can change that behaviour.
23:57:12 <dons> which is Integer
23:57:26 <Lemmih> basti_: 'default (Int); x = 1' now 'x' will have type 'Int' and not 'Integer'.
23:57:32 <basti_> oh nice
23:57:45 <magnus--> But I wanna use Ratios
23:57:53 <magnus--> which are excluded by Integer
23:58:00 <Lemmih> (the argument to 'default' is a comma separated list of types)
23:58:12 <basti_> magnus--: give a type for prod
23:58:18 <basti_> (or just rename cartesianProd to prod)
23:58:50 <Lemmih> Or don't make it a CAF.
23:59:01 <magnus--> prod xs ys = cartesianProduct xs ys
23:59:06 <magnus--> like that and it's fine
23:59:12 <magnus--> thanks Lemmih
23:59:12 * basti_ nods
23:59:18 <basti_> read that page Lemmih pasted
23:59:27 <magnus--> Yes, I did :)
23:59:31 <dons> Lemmih, how's code?
