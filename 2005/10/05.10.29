00:01:20 <m3ga> ibid: I usually run testing. I can't install ghc 6.4 on testing because it clashes with an ocaml package I'm currently using. Testing's ghc 6.2.2 doesn't compile lambdabot :-(.
00:02:29 <ibid> m3ga: well, testing is less stable than stable, obviously :)
00:02:41 <m3ga> ghc-6.2.2 is from stable
00:03:11 <m3ga> when I compile lambdabot I get : ghc-6.2.2: unknown package name: mtl
00:03:51 <Cale> heh, that's annoying because the libraries in mtl are there
00:04:03 <Cale> but the package just wasn't separated from base
00:06:33 <ibid> anyway, the state of haskell in unstable (and to a lesser degree, in testing) is affected by the general state of debian unstable, which is currently "break as break can".  stabilization will start after new year
00:06:57 <ibid> (i'm exaggerating, but not that much)
00:07:21 <musasabi> vegai: what what does parrows use?
00:07:26 <m3ga> so, in order to compile lambdabot from source, I first need to install ghc from source?
00:08:10 <ibid> musasabi: parsing algorithm
00:09:58 <vegai> oh right, I could've asked the source :)
00:10:10 <vegai> source in this case meaning the author
00:10:15 <ibid> m3ga: there is a 6.4.1 in unstable
00:10:16 <musasabi> ibid: currently recursive descent, but it could use a better compiling scheme. But in practise I noticed that for most of my examples more advanced compiling tended to dominate time (even when the parser was much faster).
00:10:38 <ibid> musasabi: which was what i expected :)
00:10:42 <vegai> I was wondering... are there any examples for using PArrows?
00:10:53 <vegai> Preferably with lots of comments
00:13:34 <musasabi> Some examples, but not a lot of comments unfortunately.
00:14:12 <dons> m3ga, to build lambdabot check the REAME ;)
00:14:19 <dons> README. you need ghc 6.5 anyway
00:14:25 <m3ga> ibid : I have ghc version 6.4-4.1 in the unstable machine, but libghc6-plugins-dev (which is required by lambdabot) won't install because the package is broken.
00:14:44 <m3ga> dons: thanks. Any debian ghc 6.5 packages?
00:15:43 <dons> you need the darcs version of fps, plugins and lambdabot. ghc 6.5 has nightly snapshots here: http://www.haskell.org/ghc/dist/current/dist/
00:15:54 <dons> I reccommend the version used by this lambdabot:
00:15:55 <dons> @version
00:15:55 <lambdabot> lambdabot 3p145, GHC 6.5.20050806 (Linux i686)
00:15:55 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
00:16:00 <dons>  -> GHC 6.5.20050806
00:16:36 <ibid> what in 6.5 is so good that lambdabot cannot live without it?
00:16:36 <m3ga> maybe lambdabot is a little too cutting edge for me to be playing with atm :-)
00:16:44 <musasabi> http://youzen.b2.fi/~musasabi/a.hs for example
00:17:08 <dons> a patch to the Process library that breaks @eval in 6.4.x
00:17:22 <dons> so if you can live without @eval, then 6.4.x is ok ::)
00:17:50 <ibid> dons: can the patch be backported?
00:17:57 <dons> most likely, yes.
00:18:08 <dons> we should ask JaffaCake very nicely
00:19:40 <ibid> hmm, what else is in 6.5?
00:21:56 <dons> hmm, also better @kind output ,and you get kind info in @type
00:22:02 <dons> i.e. ghci prints kinds in a nicer way
00:22:17 <dons> i'm sure there's other non-lambdabot related things ;)
00:22:36 <dons> like multi-processor rts, and the ghc package itself comes bundled
00:24:32 <ibid> yeah, i mostly asked to make sure that backporting is meaningful :)
00:28:00 <Cale> dons: I'm using 6.4.x and eval works -- maybe I did something to it though :)
00:28:24 <Cale> that is, @eval
00:29:06 <dons> hmm. well, with 6.4.1 runplugs dies with a weird error due to an fd issue in the process library. we've had several reports
00:29:22 <dons> TheHunter tracked the bug down and came up with a fix
00:30:21 <Cale> ah, right, now I remember editing this
00:30:43 <Cale> I changed an hGetContents or something like that to a getLine
00:31:10 <dons> ah, yes. that would fix it I think.
00:31:23 <dons> but you're stuck with only 1 line of input
00:31:42 <dons> it's a getContents issue, like you say
00:32:12 <Cale> if you're using it for @eval, you shouldn't need more than one line :)
00:32:21 <dons> right.
00:40:19 <ozone> m3ga: welcome!
00:44:16 <vincenz> hello
00:44:21 <vincenz> question about haskell
00:44:44 <vincenz> how does haskell disambiguate between a function defined in a type class and a general function?
00:45:00 <ibid> there is no ambiguity to disambiguate
00:45:01 <dons> disambiguate?
00:45:08 <dons> they're just functions
00:46:28 <dons> I think we need an @darcs, like @where, except for darcs repos.
00:46:42 <ibid> vincenz: i'm guessing that you're wondering that given class Foo ... where foo ... = ... and a toplevel foo ... = ..., how can the compiler know which is being called when foo is called?  the answer is simple: a class function and a toplevel function cannot be declared with the same name
00:46:49 <Cale> certainly class methods are special, but outside of instance and class declarations, they look like any other
00:46:55 <vincenz> ibid: ah, thank you :)
00:47:03 <vincenz> ibid: how about two different classes with the same func
00:47:11 <ibid> vincenz: illegal as well
00:47:17 <vincenz> ibid: and localized funcs?
00:47:26 <vincenz> let main x = let foo =... in ...
00:47:32 <ibid> vincenz: the class functions are in the same namespace as toplevel functions
00:47:33 <Cale> vincenz: two classes can't have the same function name
00:47:56 <ibid> vincenz: the local function name shadows any toplevel function of the same name, regardless of whether it's in a class or not
00:48:15 <vincenz> ibid: why this difference between top level and local?
00:48:23 <vincenz> ibid: why not allow top level as well as class func?
00:48:30 <vincenz> and treat top level as local within that scope
00:48:34 <ibid> vincenz: i don't understand the question
00:48:46 <vincenz> ibid: a local function shaddows something outside of it
00:48:56 <vincenz> ibid: why can't a top level function be a local function within the scope of the entire program
00:48:56 <ibid> vincenz: this how it works in just about any language
00:49:01 <vincenz> and hence just .. shadow a class func
00:49:03 <ibid> vincenz: local names shadow non-local names
00:49:29 <Cale> class functions aren't local to anything
00:49:31 <m3ga> ozone: dude!
00:49:36 <ibid> vincenz: "a top level function" and "local function within the scope of the [module]" are saying the same thing
00:49:50 <vincenz> ibid: so you CAN have a class func and a local func with the same name
00:49:57 <ibid> vincenz: yes, in different modules
00:49:58 <vincenz> I mean top level func and class finc
00:50:10 <vincenz> hmm
00:50:11 <vincenz> ok
00:50:27 <ibid> vincenz: just like you can have two toplevel functions with the same name as long as they are in different modules
00:50:36 <ibid> vincenz: this is no rocket science :)
00:50:44 <vincenz> alright
00:50:48 <Cale> and you don't have one module importing the other unqualified
00:50:54 <vincenz> how do you access a class func foo in another module?
00:50:59 <vincenz> Cale: that's a compile error?
00:51:02 <Cale> yes
00:51:03 <dons> import M (foo)
00:51:07 <Cale> you import it
00:51:12 <Cale> like you would any function
00:51:15 <ibid> vincenz: the same way you do it for a regular toplevel function
00:51:17 <vincenz> and how to call it?
00:51:20 <dons> foo
00:51:24 <Cale> same way
00:51:31 <vincenz> I mean...local module has a top level foo
00:51:34 <Cale> outside of the class and instance declarations, class functions are ordinary functions
00:51:35 <ibid> vincenz: class functions and toplevel functions are identical in every way except how they are defined
00:51:38 <vincenz> and yo have module M that has class func foo
00:51:43 <vincenz> how do I access M.foo
00:51:47 <Cale> <ibid> vincenz: class functions and toplevel functions are identical in every way except how they are defined
00:51:48 <ibid> vincenz: there is no thing that's a "local module"
00:51:48 <vincenz> given that there's already a toplevel foo
00:52:03 <vincenz> module A: top level foo, module B: class foo
00:52:04 <lightstep> vincenz, just like you typed, M.foo
00:52:06 <Cale> import qualified M (foo)
00:52:08 <vincenz> ah
00:52:09 <vincenz> thx
00:52:15 * vincenz is designing his own language
00:52:22 <ibid> aren't we all
00:52:24 <vincenz> and wanted to know how that worked in haskell
00:52:32 <Cale> you might want to read the Haskell report :)
00:52:34 <dons> ah!
00:52:37 <dons> @where haskell98
00:52:42 <vincenz> I want typeclasses in my language
00:52:51 <vincenz> they seriously ease coding
00:52:56 <dons> @bot
00:54:07 <vincenz> I notice that sometimes you have to give type specs to functioins
00:54:21 <vincenz> is this forced to make inference workk, or can inference work without the manually added typing?
00:54:49 <dons> sometimes certain experimental type tricks require annotations. haskell98 doesn't (afaik)
00:54:56 <ibid> vincenz: that depends on how powerful your type system is
00:55:08 <vincenz> I'll have to read the report
00:55:09 <Cale> vincenz: if you want a function to be less polymorphic, or force arguments to be more polymorphic, then you need to add type signatures
00:55:23 <vincenz> the typing system is described in it?
00:55:23 <ibid> vincenz: if you are contemplating doing your own language that has types and type inference, i suggest you study pierce's type books
00:55:37 <vincenz> ibid: I read his first book
00:55:42 <dons> also, Harper's is good too
00:55:54 <Cale> the more polymorphic bit comes from a Haskell 98 extension
00:55:58 <vincenz> what I want is a language that's mostly functional but allows sidie effects
00:56:01 <ibid> vincenz: then you ought to already know the answer to your question about type annotations
00:56:02 <vincenz> and uses a ruby like syntax
00:56:08 <Cale> oh, another case is disambiguating class constraints
00:56:16 <vincenz> so
00:56:17 <vincenz> x.show
00:56:18 <vincenz> not show x
00:56:21 <neologism> vincenz: why do you want side effects?
00:56:28 <vincenz> neologism: I find them useful in some cases
00:56:38 * vincenz likes ocaml a lot but misses some features in it, such as typeclasses
00:56:55 <Cale> Haskell has side effects through unsafePerformIO
00:57:13 * m3ga likes ocaml, c and python, all for different reasons
00:57:14 <vincenz> downside of haskell (in my eyes) is that everythiing is lazy
00:57:24 <Cale> if you don't mind messing up referential transparency completely
00:57:26 <ibid> Cale: and inside IO
00:57:26 <sieni> morning
00:57:35 <Cale> ibid: well, yeah :)
00:57:36 <neologism> lazyness is ok I think
00:57:45 <vincenz> in my opinion one can get easy of programming with fast runtime through the use of statici typing, type classes, and a more imperative syntax
00:57:50 <Cale> vincenz: how is laziness a downside?
00:57:56 <vincenz> Cale: executioin cost
00:58:03 <Cale> it's rare that you want things to be strict
00:58:12 <neologism> hm.. hows optimistic evaluation?
00:59:20 <Cale> the most important things to make strict are just folding down a large data structure into a single value, like a number.
00:59:34 <vincenz> Cale: maybe in your domain
00:59:38 <sieni> vincenz: The three chief virtues of a programmer are: Laziness, Impatience and Hubris. -- Larry Wall
00:59:40 <Cale> well, in general
00:59:48 <vincenz> Cale: rather broad statement
01:00:08 <sieni> lazy vs. strict depends on the application
01:00:10 <vincenz> sieni: hubris being?
01:00:23 <vincenz> hence I want a language that does not use lazy by defacto but does allow lazyness
01:00:32 <vincenz> (ocaml does it, but ocaml has other downsides)
01:00:35 <neologism> you can do lazy evaluation in every language
01:00:56 <Cale> well, basically the only time that laziness is a problem is when you get large expressions building up which don't get evaluated for a long time, and are much larger than the result of evaluating them
01:00:58 <vincenz> neologism: of course, but some language's syntax make it more permissive
01:01:06 <sieni> I would use sml or ocaml in e.g. numerics heavy applications
01:01:26 <Cale> this essentially only occurs when folding a large data structure into a small one
01:01:28 <vincenz> sieni: that's what I use it for riight now, I switched from python to ocaml purely for speed
01:01:41 * vincenz needs to analyze multi-gigabyte binary files
01:01:49 <neologism> what do you mean by analyze?
01:02:36 <vincenz> process
01:02:39 <Cale> vincenz: laziness is great for that, so long as you don't need the whole file in order to produce the first part of your result
01:02:41 <sieni> vincenz: but laziness has other advantages that are not always immediately obvious
01:02:55 <vincenz> sieni: yes but I'd prefer it to be a choice for the programmer
01:03:01 <neologism> vincenz: I mean.. what sort of analyze
01:03:02 <vincenz> Cale:  I do
01:03:05 <Cale> it is a choice for the programmer
01:03:14 <sieni> like defining a list of all possible solutions and taking the head of the list to get the first one
01:03:47 <Cale> seq x y forces the evaluation of x to weak head normal form before returning y
01:03:51 <sieni> vincenz: does sml/ocaml support lazy evaluation without some heavy lambda masturbation?
01:04:05 <sieni> lisp/scheme of course do, since they have macros
01:04:11 <vincenz> sieni: ocaml has a 'lazy type
01:04:27 <vincenz> sieni: and that's what I meant ... for enablinig lazyness in a language, by not forcing an ugly masturbation to get it
01:04:46 * vincenz redirects it to neologism 
01:05:04 <sieni> vincenz: ocaml is otherwise nice, but the compiler has a sucky license and it does not have any really free (gpl/lgpl/bsd) alternatives
01:05:09 <neologism> uhm.. have you looked at erlang?
01:05:09 <Cale> also, have you seen Control.Parallel.Strategies?
01:05:20 <vincenz> why?
01:05:40 <Cale> If you want to stay in Haskell otherwise, there are nice ways to make strictness/laziness issues not so much of a problem
01:06:13 <vincenz> well I've been here in from time to timie, and sometimes I hear "why is this leaking"... it's cause at times haskell abstracts too far away from the computer
01:06:39 <ozone> Cale: i always liked the idea of being able to declare an entire module as lazy/strict
01:06:49 <Cale> it's usually not too hard to figure out -- always look for the large data structure that's getting turned into the small one :)
01:07:01 <ozone> in general, if you want laziness, you want to tackle a particular problem, which a module is usually a reasonable scope for
01:07:11 <vincenz> and my other reason for a new language is to give iti a more imperative syntax
01:07:22 <vincenz> object.method
01:07:28 <vincenz> tho not with a virtual pointer table
01:07:33 <vincenz> but through type classes
01:07:44 <integral> strictness annotations on data types seem much easier to use than seq
01:08:01 <Cale> integral: that works too :)
01:08:57 <ozone> dons: see that jhc vs ghc message?
01:09:02 <ozone> cool stuff :)
01:09:05 <lightstep> vincenz, if you're willing to pick another character, you can use e.g. (#) = flip ($), and then object#method
01:09:29 <dons> very cool, ozone, indeed!
01:09:52 <vincenz> by the way
01:10:00 <vincenz> anyone an expert on clustering algorithms?
01:15:20 <sylvan> ozone, where is this jhc vs ghc message?
01:15:29 <ozone> sylvan: glasgow-haskell-users
01:15:54 <sylvan> ah..
01:15:55 <sylvan> thanks
01:16:04 <m3ga> ozone: jhc?
01:16:38 <ozone> m3ga: crazy guy is writing his own haskell compiler, with some pretty novel compilation techniques
01:17:01 <ozone> it's not really usable yet (it's really, _really_ slow), but it'll be interested to see how it turns out with some time!
01:18:58 <dons> testingbot: @version
01:19:07 <testingbot> lambdabot 3p150, GHC 6.4.1 (OpenBSD i386)
01:19:07 <testingbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:19:22 <dons> testingbot: @eval map (\x -> (x,x)) "haskell"
01:19:23 <testingbot> [('h','h'),('a','a'),('s','s'),('k','k'),('e','e'),('l','l'),('l','l')]
01:19:30 <dons> testingbot, @quit
01:20:51 <m3ga> ozone: writing compilers is for crazy people.
01:20:57 * Cale reads http://www.elet.polimi.it/upload/matteucc/Clustering/tutorial_html/index.html
01:21:10 <Cale> hmm, perhaps I'll implement one or two of these :)
01:21:42 <neologism> m3ga: writing a compiler/interpret can be a school project
01:21:45 <dons> hey masm.
01:21:46 <neologism> I did one ;(
01:22:02 <dons> masm, are you on the map yet?:
01:22:03 <dons> @map
01:22:03 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
01:22:09 <ozone> m3ga: especially haskell ones...
01:22:11 <m3ga> neologism: writing anything other than a toy compiler is for crazy people :-)
01:22:13 <vincenz> Cale: heh
01:22:16 <vincenz> Cale: not quite what I need :D
01:22:18 <neologism> m3ga: ok :)
01:22:23 <vincenz> bit more involved than that
01:22:25 <ibid> writing programs is only for crazy people
01:22:37 <neologism> writing is for crazy people ;)
01:22:52 <m3ga> people are crazy :-)
01:23:09 <ValarQ> we sure are...
01:23:19 <dons> morning Arias
01:23:33 <{Arias}> good morning :)
01:30:29 <masm> dons, no, I'm not.
01:35:04 <dons> masm, feel free to add yourself then :) just work out your coords, and edit the wiki page, or msg me the coords and i'll edit the page :)
01:35:14 <rep> neologism \o/
01:36:44 <neologism> hi reppie
01:36:55 <rep> what's up
01:37:06 <neologism> you wrote my name ;)
01:37:23 <rep> heh
01:38:29 <neologism> ready to commit my patches? :)
01:39:51 <rep> well
01:39:59 <rep> i don't have a box to test them :(
01:40:19 <neologism> I mean the -LOCK(); + return; one ;)
02:07:23 <dcoutts> dons, humph, yeah we had the same problem with gtkmozembed on FreeBSD
02:08:10 <dcoutts> for one thing the libgtkembedmoz.so had not been linked with -rpath so that it could find the other libs it needed
02:08:28 <dcoutts> and then when we used the ldconfig path it segfaulted :-(
02:08:50 <dcoutts> http://dhcp0065.gradacc.ox.ac.uk:8080/~duncan/test-mozembed.c
02:09:01 <dcoutts> you can try that one as a test if you like
02:09:50 <dcoutts> gcc test-mozembed.c -o test-mozembed `pkg-config --cflags --libs mozilla-gtkmozembed gtk+-2.0`
02:12:48 <dons> trying now..
02:13:35 <dcoutts> $ readelf -a /usr/lib/mozilla/libgtkembedmoz.so | grep PATH
02:13:35 <dcoutts>  0x0000000f (RPATH)                      Library rpath: [/usr/lib/mozilla]
02:13:35 <dcoutts>  0x0000001d (RUNPATH)                    Library runpath: [/usr/lib/mozilla]
02:13:54 <dons> $ ./test-mozembed
02:13:54 <dons> zsh: segmentation fault (core dumped)  ./test-mozembed
02:14:08 <dcoutts> you see, on my system the libgtkembedmoz.so was complied with -rpath so it can find it's other libs
02:14:38 <dons> ah, right. but it's empty on mine.
02:14:47 <dcoutts> dons, so did you need so specify LD_LIBRARY_PATH ?
02:14:55 <dons> yes, I needed to
02:15:17 <dcoutts> and ldd says that the libs are being resolved int he way you expect?
02:15:48 <dcoutts> (ie if you built against mozilla, they're not getting resolved with the firefoc libs for example)
02:17:29 <dcoutts> dons, the only other thing I can think of is to try setting the paramter of gtk_moz_embed_set_comp_path to either NULL or "/usr/local/mozilla"
02:18:02 <dcoutts> otherwise we just say it's a bug in mozilla on you system - if it doesn't even work with a minimal C test prog.
02:18:03 <dons> yep, ldd looks correct.
02:18:24 <dons> I wouldnt' be surprised if its a mozilla bug. I rather expect that in fact
02:18:36 <dons> mozilla has been historically flakey on bsd
02:19:06 <dcoutts> no documentation viewer in hIDE for bsd then :-(
02:19:18 <kolmodin> :/
02:20:24 <dons> oh!
02:20:26 <dons> hang on....
02:20:38 * dcoutts hangs on...
02:20:58 <dons> no segfault, and i've got an open window with gtk_moz_embed_set_comp_path = "/usr/local/mozilla"
02:21:02 <dons> !!
02:21:06 <dcoutts> !!!?
02:21:07 <dons> it opens up the freebsd site
02:21:08 <dons> :)
02:21:11 <kolmodin> yay!
02:21:23 <dons> oh this is very nice :)
02:21:23 <dcoutts> oh yeah, we were testing it on freebsd the other day :-)
02:21:42 <dcoutts> grr, the function is completely undocumented
02:21:50 <dons> so all I did was set gtk_moz_embed_set_comp_path ("/usr/local/mozilla");
02:21:56 <dcoutts> it works on my system when it's "" or NULL
02:22:02 <dons> and of course add /usr/local/mozilla to LD_LIBRARY_PATH
02:22:21 <dcoutts> well that one is a config bug on openbsd :-)
02:22:41 <dons> fair enough :)
02:22:57 <dcoutts> either the mozilla libs should be on the ldconfig path or the libgtkembedmoz.so should be complied with -Wl,-rpath,/usr/local/mozilla
02:23:13 <dons> ok. cool.
02:23:17 <dcoutts> either of those things should make it "Just Work"tm
02:23:46 <dcoutts> I'll export a var from the mozembed bindings with the value of the mozilla lib dir on the platform
02:24:22 <dcoutts> so people can use mozEmbedSetCompPath mozEmbedDefaultCompPath
02:24:30 <dons> yeah, cool. that sounds reasonable
02:24:52 <dcoutts> and document it!
02:25:16 <dcoutts> thanks docs
02:25:19 <dcoutts> err
02:25:22 <dcoutts> dons
02:25:25 <dcoutts> :-)
02:25:43 <dons> no worries!
02:25:57 <dons> i'm really happy with how easy gtk2hs is to build now, by the way. great work!
02:26:10 <dcoutts> thanks
02:26:25 <dcoutts> it's been much better since we fixed c2hs
02:38:51 <Lemmih> 'morning, #haskell.
02:39:21 <musasabi> morning Lemmih
02:39:43 <Lemmih> How's code, musasabi?
02:44:06 <musasabi> quite little recently, real life projects have been keeping me very busy
02:48:15 <dons> hey pirroH, welcome :) 
02:50:00 <dcoutts> hi Lemmih
02:50:18 <pirroH> hi dons!
02:50:38 <pirroH> I'm a xerox's pupil
02:51:22 <gilles> hey all
02:51:41 <dons> pirrorH,cool!
02:51:48 <dons> you should check the map then:
02:51:49 <dons> @map
02:51:49 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
02:51:49 <testingbot> http://www.haskell.org/hawiki/HaskellUserLocations
02:51:55 <dons> testingbot, @yow
02:51:55 <testingbot> Couldn't find fortune file
02:51:59 <dons> hmm
02:52:44 <dons> testingbot: @quit
02:52:48 <pirroH> I also know reppie... anyway, cool, I could be the third italian in the europe map :)
02:53:39 <dons> yeah :)
03:14:52 <dcoutts> oh dons, can I get you to test one other thing...
03:15:14 <dcoutts> just wondering if we can avoid having to use LD_LIBRARY_PATH
03:15:41 <dcoutts> I'm wondering if -rpath-link will help us
03:17:16 <ozone> dcoutts: don't you love linkers?
03:17:23 <dcoutts> oh yeah
03:17:38 * dcoutts especially hates the win32 linker
03:18:00 * dcoutts hatesss itsss
03:18:02 <dcoutts> precious
03:19:13 <dons> sure. i love linkers too
03:19:19 <dcoutts> ok...
03:19:31 <dcoutts> with that test-mozembed.c prog
03:19:44 <dons> yep
03:19:51 <dcoutts> gcc test-mozembed.c -o test-mozembed `pkg-config --cflags --libs mozilla-gtkmozembed gtk+-2.0`
03:20:00 <dcoutts> and then add these flags too:
03:20:25 <dcoutts> -Wl,-rpath,/usr/local/mozilla/
03:20:42 <dcoutts> and if it still doens't work with that then try this in addition:
03:20:50 <dcoutts> -Wl,-rpath-link,/usr/local/mozilla/
03:20:56 <dons> you want me to keep the gtk_moz_embed_set_comp_path ("/usr/local/mozilla");
03:20:59 <dons> line?
03:20:59 <dcoutts> yes
03:21:16 <dcoutts> but remove /usr/local/mozilla from the LD_LIBRARY_PATH
03:21:22 <dons> yep
03:21:48 <dons> ok, first one doesn't work.
03:21:56 <dcoutts> what does ldd say?
03:22:01 <dcoutts> what libs can't it find?
03:22:14 <dcoutts> xpcom + 3 others?
03:22:19 <dons> test-mozembed: can't load library 'libnspr4.so.3.0'
03:22:20 * dcoutts guesses
03:22:25 <dons> ldd doesn't actually work, it bails on me
03:22:30 <dcoutts> oh :-(
03:22:41 <dcoutts> ok, try the -rpath-link one too
03:22:42 <dons> it's kind of weird: $ ldd ./test-mozembed
03:22:42 <dons> ./test-mozembed:
03:22:42 <dons> ./test-mozembed: can't load library 'libxpcom.so.3.0'
03:22:42 <dons> ./test-mozembed: exit status 4
03:23:12 <dons> ldd gives same result, and we get $ ./test-mozembed
03:23:13 <dons> ./test-mozembed: can't load library 'libplc4.so.3.0'
03:23:38 <dcoutts> readelf -a /usr/local/mozilla/libgtkembedmoz.so | grep PATH
03:24:17 <dons> empty
03:24:22 <dcoutts> right
03:24:38 <dcoutts> on my machine it says it's RPATH is /usr/local/mozilla
03:24:45 <dcoutts> ok one last one...
03:25:29 <dcoutts> try the -rpath, the -rpath-link and -lxpcom -lplds4 -lplc4 -lnspr4
03:26:01 <dons> works :)
03:26:04 <dcoutts> gcc test-mozembed.c -o test-mozembed `pkg-config --cflags --libs mozilla-gtkmozembed gtk+-2.0` -Wl,-rpath,/usr/local/mozilla/  -Wl,-rpath-link,/usr/local/mozilla/  -lxpcom -lplds4 -lplc4 -lnspr4
03:26:06 <dcoutts> yay!
03:26:20 <dons> oh hang on... my mistake. let me try again..
03:26:52 <dons> nope. doesn't work.
03:26:57 <dcoutts> :-(
03:27:03 <dons> (I'd set LD_LIBRARY_PATH, and forgot to unset it)
03:27:09 <dcoutts> so ldd still says missing things?
03:27:31 <dons> ldd says, which i've never seen before: $ ldd ./test-mozembed
03:27:31 <dons> ./test-mozembed:
03:27:31 <dons> ./test-mozembed: can't load library 'libnspr4.so.3.0'
03:27:31 <dons> ./test-mozembed: exit status 4
03:27:41 <dcoutts> ho hum
03:27:58 <dons> but then if I set LD_LIBRARY_PATH, we get all things found by ldd
03:28:47 <dons> you may have to just print a message suggesting to set LD_LIBRARY_PATH
03:28:58 <dcoutts> well I think the only proper solution (since using LD_LIBRARY_PATH isn't really ok) is for mozilla to be configured with LD_FLAGS=-Wl,-rpath,/usr/local/mozilla
03:29:23 <dons> i'll have a look at how it's currently build
03:29:26 <dcoutts> because putting /usr/local/mozilla on the global ldconfig path will work
03:29:29 <dcoutts> except...
03:29:35 <dcoutts> when you've got firefox installed
03:29:46 <dons> ah, right.
03:29:51 <dcoutts> if they're both on the path then you can only ever use one or the other
03:30:22 <dcoutts> they need to have the rpath set so that if you link agaisnt one then you'll get the same one at runtime
03:31:02 <dcoutts> otherwise you might end up linking against firefox but running with the mozilla libs if mozilla appears before firefox on the ldconfig path
03:31:13 <lightstep> JohnMeacham, in c-minus-monad.txt you flipped the decrement of r_r (eax) and the multiplication of r_n (ebx)
03:31:45 <lightstep> JohnMeacham, or actually, put the writeReg r_n x opcode too early
03:31:47 <dcoutts> dons, https://bugzilla.mozilla.org/show_bug.cgi?id=304655
03:43:29 <xerox> Howdy!
03:43:37 <dcoutts> hia
04:06:38 <dcoutts> anyone feel like writing a darcs plugin for meld? http://meld.sourceforge.net/
04:07:14 <dcoutts> apparently it now has a vcs plugin system
04:07:18 <dcoutts> http://news.gmane.org/gmane.comp.gnome.meld.general/
04:07:28 <dcoutts> you'd need to know python I guess
04:07:50 <dcoutts> anyway it'd be a quick way to get a darcs gui
04:07:56 <eivuokko> Hmh
04:08:28 <dcoutts> I use meld with cvs and just for general file & dir diffs. It's realy pretty good.
04:09:01 <dcoutts> it should be easy to make it use darcs since it's just a matter of a file diff between the files and the _darcs/current/ version
04:09:19 <dcoutts> which is easier than how it works with cvs or svn
04:10:13 <eivuokko> Does it seem like it can could control darcs about which hunks ought to be recorded?
04:10:33 <dcoutts> not sure
04:10:46 <dcoutts> I'd be happy with just diff viewing
04:11:20 <dcoutts> eg just between the current files and their recorded state
04:11:40 * dcoutts looks at the meld vc code
04:11:49 <eivuokko> Yeah, I am considering whetever it'd be worth any work for me to do anything.
04:12:11 <eivuokko> Erm...worth anything for me to do work on it.
04:12:31 <dcoutts> well take a look at the code and see what you think
04:14:34 <dcoutts> the cvs.py and svn.pn files look pretty short
04:18:14 <eivuokko> It seems really bad to me.  I don't see file (directory might be done via changing work directory) but commiting just whole directory at once isn't really an option.  I use WinMerge so it's kinda something I wouldn't use otherwise.
04:18:49 <ndm> ping shapr
04:19:05 <dcoutts> eivuokko, I have to say I never use meld for actually comitting stuff
04:19:09 <ndm> @seen shapr
04:19:09 <lambdabot> I saw shapr leaving #haskell-overflow, #haskell-blah and #haskell 6 hours,
04:19:09 <lambdabot> 46 minutes and 4 seconds ago, and I have missed 2 hours, 16 minutes and
04:19:09 <lambdabot> 15 seconds since then.
04:19:23 <dcoutts> eivuokko, just for looking at changes - for which it is excelent
04:19:42 <dcoutts> eivuokko, I look at what's changed in meld and then actually do the commits on the command line
04:19:46 <eivuokko> dcoutts, Yeah, I am mainly interested because I believe when record/revert I'd love to see hunks graphically.
04:20:30 <dcoutts> right, so I imagine I'd look at the dir diff in meld and then use darcs record on the command line
04:20:58 <dcoutts> I think eventually we'd want a more specialised gui for darcs since it works in a rather different way to cvs/svn/etc
04:21:10 <eivuokko> Yeah, it is sort of more primitive.
04:21:26 <dcoutts> but I was thinking meld would be a quick initial approach
04:22:12 <dcoutts> it's much easier looking at changes in meld than with darcs's command line interface: http://meld.sourceforge.net/meld_file1.png
04:23:57 <eivuokko> Unfortunately, for me, personlly, there is no use-case, because I use winmerge ;) http://winmerge.sourceforge.net/2.4/screenshots.php  So...maybe someone else.
04:24:15 <dcoutts> fair enough
04:24:49 <eivuokko> Hmh, makes me wonder if darcs had xml-output for hunks
04:25:41 <eivuokko> Yeah, stupid thing, I think darcs only has diff which doesn't return darcs' own hunks.
04:26:37 <dcoutts> heh
04:26:54 <dcoutts> people have not yet really tried to build a darcs gui
04:27:05 <dcoutts> I think they'd provide an api if people wanted to make one
04:28:03 <eivuokko> I am not into maintaining such thing, but in general it's not like it's hard to write or anything.
04:48:33 <dons> ndm, i've updated @hoogle to use  the latest hoogle cvs.
04:48:50 <dons> what do the extra annotations in -v output mean, after the score?
04:49:02 <ndm> thats how the score was calculated
04:49:22 <dons> anyway, currently @hoogle just takes the output, and sorts by the score, and then the length of the qualified name
04:49:26 <dons> @hoogle a -> b
04:49:28 <lambdabot> Prelude.id :: a -> a
04:49:28 <lambdabot> Prelude.seq :: a -> b -> b
04:49:28 <lambdabot> Prelude.max :: Ord a => a -> a -> a
04:49:38 <eivuokko> Uhhuh. Where does this come from: The process tried to write to a nonexistent pipe.  nice.. only io I use are putStrLn and getContents.
04:49:43 <ndm> hoogle already sorts by the score, so no need to do that
04:50:15 <ndm> and it added a -n argument
04:50:21 <ndm> to limit the number of returned results
04:50:36 <dons> ah, of course. I mean, it leaves the score as is :)
04:50:36 <dons> yes, I use -n
04:50:58 <ndm> the one thing that is going to change massively is the ranking algorithm
04:51:08 <ndm> if you look at test/score/examples.txt
04:51:19 <joelr> howdy
04:51:19 <ndm> thats a list of ideal rankings
04:51:31 <dons> ok.
04:51:36 <ndm> once it becomes big enough, i'm going to run a genetic algorithm over it to get a "perfect" ranking
04:51:43 * joelr scans the horizon for familiar faces 
04:51:45 <dons> nice :)
04:51:58 <joelr> rankings...
04:52:00 <joelr> stock market?
04:52:09 <ndm> what's the rationale of sorting on lenght of qualified name?
04:52:37 <dons> Prelude and such like tend to have shorter names, and shorter module names.
04:52:50 <dons> usually we want the haskell98 name to bubble up to the top
04:52:53 <ndm> fair enough, will add that actually
04:52:57 <joelr> assuming that i wanted to parse something and return the remainder of the parse buffer plus a (Maybe result) and do some IO for tracing
04:53:06 <ndm> sounds like a very good idea
04:53:15 <joelr> do i need to combine StateT with Maybe and IO? if so in which order?
04:55:06 <joelr> do i use ErrorT instead of Maybe?
04:55:41 <lightstep> yes
04:56:05 <lightstep> perhaps you want WriterT instead of ErrorT
04:56:47 <joelr> hmm... the computations may fail
04:57:05 <joelr> so it's tracing + failing computations + state if the computation did not fail
04:57:18 <joelr> i was thinking of tracing to stdout and thus using IO
04:57:38 <joelr> it looks to me like a combination of StateT, ErrorT and IO, at least intuitively
04:58:21 <lightstep> ok, i didn't understant the original statement
04:58:55 <lightstep> why do you need StateT?
04:59:52 <ndm> @hoogle Eq a => [a] -> [a]
04:59:53 <lambdabot> Prelude.tail :: [a] -> [a]
04:59:53 <lambdabot> Prelude.init :: [a] -> [a]
04:59:53 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
04:59:57 <joelr> lightstep: i'm reading packets out of a fast packed string and packets consist of fields. one each field consumes its share of the fps it should put the rest back for the fields that are coming after
05:00:06 <ndm> dons, that gives nub first in standard hoogle
05:00:07 <joelr> lightstep: so the remaining buffer is the state
05:00:18 <ndm> have you sorted on length in preference to score?
05:01:04 <lightstep> i'd use an ErrorT for errors and WriterT for tracing, and print it to stdout in the wrapper
05:01:08 <joelr> StateT = remaining buffer, ErrorT = not enough buffer remaining, wrong data read, etc.
05:01:24 <xerox> ndm: I tried hoogle today from school with IE and it looked awful, I think there were some problems with the CSS and the image.
05:01:33 <joelr> lightstep: why not combine with IO? why use writerT?
05:01:39 <ndm> xerox, at haskell.org/hoogle?
05:01:47 <lightstep> because IO is evil
05:01:49 <ndm> those are known problems, all to do with server configuration
05:01:58 <joelr> hmm
05:02:20 <ndm> instead of returning the .css or .png files, it returns the front page again, which means it can't findi any images or css
05:03:34 <xerox> ndm: yes
05:03:38 <xerox> Okay :-|
05:03:56 <lightstep> WriterT String is lazy enough so simply running mapM_ putStrLn will be equivalent to including these directly
05:04:50 <joelr> lightstep: ok, so WriterT it is but how do I combine StateT with WriterT and ErrorT? i want my computations to stop in the event of an error
05:05:53 <lightstep> throwError does that
05:07:00 <dons> ndm, ah, right. i've resorted. :/
05:07:05 <dons> i'll fix that
05:07:16 <joelr> lightstep: how do i combine them then?
05:07:49 <dons> yeah, I have:  sortBy qualifiedName res
05:08:02 <dons> but it should do this after a 'group'
05:08:15 <lightstep> WriterT [TraceUnit] StateT FPS ErrorT Whatever Identity
05:08:17 <bourbaki> moin
05:08:27 <dons> unless you add a haskell98-name heuristic to hoogle...
05:08:32 <JohnMeacham> lightstep: I wil fix it. the doc is actually in the jhc darcs repo if you want to make any changes :)
05:09:07 <ndm> dons, i'll add the shortest name heuristic
05:09:12 <ndm> since that seems a good idea
05:09:41 <lightstep> JohnMeacham, it seems like you need some rescheduling heuristic
05:09:53 <joelr> lightstep: indentity is the identity monad?
05:10:16 <lightstep> joelr, yes
05:10:17 <joelr> lightstep: and if i wanted to combine with IO instead of WriterT how would I do that?
05:10:25 <dons> ok, cool. i'll remove my little hack then
05:10:57 <lightstep> joelr, there is no IO transformer, IO always needs to be the base monad
05:11:10 <lightstep> joelr, (instead of Identity)
05:11:46 <joelr> StateT FPS ErrorT Whatever IO
05:11:49 <joelr> like that?
05:12:06 <JohnMeacham> as in rescheduling my day? i suppose it is odd I am on european time being a californian.. but I make do.
05:12:39 <lightstep> no, the instructions, you need to decide which assignment to do first
05:12:47 <lightstep> joelr, yes
05:13:43 <joelr> lightstep: no, the instructions ... was for me?
05:14:03 <lightstep> joelr, no, for j.m.
05:14:21 <joelr> lightstep: ok, thanks :-)
05:14:38 <joelr> lightstep: let me try to write some functions that use this combo
05:16:40 <JohnMeacham> gurp! tipsy.
05:18:09 <joelr> lightstep: i forgot one thing... where do i plug in the resulting value? say i wanted to return a Command
05:18:28 <joelr> lightstep: in this case StateT FPS ErrorT Whatever IO
05:19:09 <lightstep> joelr, after all that
05:19:22 <lightstep> joelr, since it's a parameter to IO
05:19:26 <joelr> lightstep: so StateT FPS ErrorT Whatever IO Command
05:19:28 <joelr> ah!
05:19:37 <joelr> cool
05:20:47 <lightstep> joelr, if you use IO, you can use IORefs and not use StateT, or use exceptions and not use ErrorT
05:20:49 <joelr> lightstep: and over here? WriterT [TraceUnit] StateT FPS ErrorT Whatever Identity? does Command go instead of Identity or after?
05:21:47 <lightstep> yes, after identity
05:21:56 <joelr> ok, thanks
05:22:23 <joelr> i think i see how using IO would be unnecessarily stiffling
05:22:39 <ndm> dons, my hoogle repo at home seems slightly fried, so will wait til i get back into the office on monday to fix it
05:22:59 <ndm> and plan a move to darcs sooner
05:24:29 * lightstep `map` food
05:25:04 <joelr> lightstep: thank you!
05:48:47 <araujo> Good morning!"
06:11:58 <skuggi> i'm trying to use wxHaskell in ghc, but when i try to compile i get:
06:11:58 <skuggi> Bad interface file: C:\skuggi\wxhaskell-0.9.4\lib\imports/Graphics/UI/WX.hi
06:11:59 <skuggi>     mismatched interface file versions: expected 6041, found 6040
06:16:36 <Lemmih> Find a version of wxhaskell compiled for ghc-6.4.1, compile wxhaskell yourself or downgrade to ghc-6.4.
06:20:23 <skuggi> k. there's no other way around this?
06:20:24 <dcoutts> skuggi, or use gtk2hs installer for windows :-) (it's complied against ghc-6.4.1)
06:20:52 <skuggi> dcoutts: what does that do exactly?
06:21:27 <dcoutts> it means you'd have the Gtk2Hs libraries available rather than the wxHaskell ones
06:22:12 <dcoutts> if you've already written a program that uses wxHaskell then it's not a very helpful suggestion since the Gtk2Hs and wxHaskell APIs are not the same
06:22:14 <skuggi> ah, no, i need to use wxhaskell
06:22:28 <skuggi> it's a school thing.
06:22:56 <dcoutts> well if you're required to use wxHaskell then Gtk2Hs is obvously not a great help to you
06:23:14 <dcoutts> if you can choose then you could use either
06:24:31 <skuggi> well, it seems i can actually choose which, but i don't feel like learning something new :P
06:24:51 <dcoutts> then the easiest thing is to downgrade your ghc to 6.4
06:25:15 <gour> skuggi, how much you went into wx already?
06:25:36 <benmos> Hi all - can I ask some advice about the best way to write a very simple function?
06:25:54 <dcoutts> benmos, ask
06:25:54 <benmos> (Or actually if my current definition could be done more elegantly...)
06:26:04 <benmos> what I have at  the moment is:
06:26:08 <gour> dcoutts, hi, i'm exploring gnome & use xchat ;)
06:26:25 <benmos> hmm let me paste that again...
06:26:30 <dcoutts> gour, is the keyboard working?
06:26:32 <skuggi> gour: not all that much, but it's a simple assignment, and i intend to finish it as quickly as possible :P
06:26:43 <benmos> listOfMaybesToMaybeList::[Maybe a]->Maybe [a]
06:26:53 <benmos> listOfMaybesToMaybeList [] = Just []
06:27:00 <benmos> listOfMaybesToMaybeList (l:ls) = do {v <- l; vs <- (listOfMaybesToMaybeList ls); return (v:vs)}
06:27:08 <benmos> that's it
06:27:09 <gour> dcoutts, yes - slovenian layout
06:27:28 <dcoutts> gour, hmm
06:27:33 <kolmodin> dcoutts: trying to steal wxhaskell's users? :)
06:27:35 <gour> skuggi, ah, ok. i tried with wx, but decided to go with gtk2hs
06:27:38 <benmos> Is that a reasonable approach - or can it be done more nicely?
06:27:46 <lightstep> @type Maybe.catMaybes
06:27:47 <dcoutts> kolmodin, well it was worth a go :-)
06:27:47 <lambdabot> forall a. [Maybe a] -> [a]
06:27:52 <kolmodin> haha :)
06:27:56 <gour> dcoutts, how to add a new app to some menu under Applications?
06:28:13 <dcoutts> gour, install a .desktop file in the right place
06:28:15 <skuggi> gour: ah, ok.
06:28:24 <lightstep> benmos, what are you trying to do?
06:28:54 <dcoutts> kolmodin, it seems there havn't been any wx updates for some months
06:29:29 <benmos> trying to return either a Nothing if any elt of the original list was Nothing - and a Just [a] otherwise - if you see what I mean
06:30:02 <dcoutts> benmos, in that case your definition is ok
06:30:08 <gour> dcoutts, you mean there is no something like a menu-editor?
06:30:14 <lightstep> benmos, what you written does exactly that
06:30:19 <kolmodin> dcoutts: yeah, I haven't heard anything in a long time
06:30:27 <lightstep> benmos, it's equivalent to the standard function sequence
06:30:28 <benmos> ok, cool - just checking that there wasn't a clean way to avoid the explicit recursion.
06:30:28 <kolmodin> and I'm on the mail-list
06:30:44 <benmos> ah - cool -  didn't know that... thx
06:30:54 <benmos> ...will use that instead
06:31:05 <dcoutts> gour, there are but not one included in gnome as standard yet. They're usign a new menu standard shared with kde and others. There are some editor available.
06:31:21 <dcoutts> gour, try gnomefiles.org
06:31:30 <Lemmih> @type foldr (Monad.liftM2 (:)) (return [])
06:31:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:32:21 <benmos> ah - awesome
06:32:44 <gour> dcoutts, ok, a little strange no default-editor, but well, it's gnome :-)
06:33:35 <takuan> damn
06:33:48 <dcoutts> gour, actually there's never been an editor, even with the older menu/desktop standard
06:33:50 <takuan> i once read a paper on matrix multiplication in haskell but I can't seem to find it back
06:33:59 <xerox> Lemmih: wow..
06:34:10 <gour> dcoutts, on #gnome, they just told me about smeg
06:34:37 <gour> dcoutts, it's in portage
06:34:42 <joelr> @paste
06:34:43 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:35:16 <gour> dcoutts, just the right thing
06:35:32 <dcoutts> @eval sequence [Just 1, Just 2]
06:35:33 <lambdabot> Just [1,2]
06:35:37 <dcoutts> @eval sequence [Just 1, Just 2, Nothing]
06:35:39 <lambdabot> Nothing
06:35:42 <joelr> hmm
06:35:45 <Lemmih> heh
06:35:47 <benmos> yep - that's exactly what I wanted - thanks.
06:35:49 <joelr> what's up with paste?
06:35:54 <joelr> do i need to create an account
06:36:04 <joelr> i thought lisppaste worked here
06:36:13 <joelr> @lisppaste
06:36:13 <lambdabot> Unknown command, try @listcommands.
06:36:24 <Lemmih> lisppaste2: url
06:36:25 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
06:36:50 <kombinator> hi, dcoutts
06:36:55 <lisppaste2> joelr pasted "how do i run this?" at http://paste.lisp.org/display/13013
06:37:17 <kombinator> dcoutts: I'm still getting that GDK warning from mozembed
06:37:40 <joelr> would appreciate help with this. i can't figure out how to invoke unstuff from ghci to check the log and the final state
06:38:09 <skuggi> i'm trying to import a module from a file that is in the same dir as the file i'm compiling, but for some reason ghc doesn't find
06:38:25 <dcoutts> kombinator, I don't know what's going on there
06:39:19 <dcoutts> kombinator, what mozilla & gtk version is that?
06:39:38 <skuggi> do i have to do something to make ghc find other modules?
06:39:58 <Lemmih> skuggi: -ipath/to/your/modules
06:40:26 <kombinator> dcoutts: mozilla-dev 1.7.8-1, libgtk2.0-0 2.6.10-1
06:40:47 <skuggi> Lemmih: the module is in the same directory as the file i'm compiling. do i still have to do that?
06:41:24 <Lemmih> skuggi: Did you run ghc from that directory?
06:41:40 <dcoutts> kombinator, hmm, dunno. Sorry.
06:41:57 <dcoutts> kombinator, does it work appart from that problem?
06:42:00 <Lemmih> skuggi: 'ghc -c somedir/MyModule.hs' won't make ghc look in 'somedir' for extra modules.
06:42:01 <kombinator> dcoutts: maybe it's internal to mozembed
06:42:03 <skuggi> Lemmih: yes
06:42:07 <dcoutts> kombinator, I suspect so
06:42:14 <kombinator> dcoutts: I see no problems at all
06:42:23 <joelr> anyone? http://paste.lisp.org/display/13013
06:42:30 <dcoutts> kombinator, ok, I guess we'll just ignore it then
06:43:07 <dcoutts> joelr, what's your question?
06:43:16 <Lemmih> skuggi: Try -i.
06:43:26 <joelr> dcoutts: how do i invoke my unstuff from ghci
06:43:33 <joelr> dcoutts: and in general
06:43:47 <Lemmih> ('-i.')
06:43:50 <skuggi> Lemmih: doesn't work.
06:44:07 <dcoutts> joelr, you mean how do you run the StateT monad action?
06:44:24 <skuggi> Lemmih: wait a min and i'll paste the code.
06:44:30 <joelr> dcoutts: no, i have a monad combination
06:44:35 <joelr> dcoutts: this does not work : runStateT $ runWriterT $ unstuff $ packWords [0]
06:44:53 <Lemmih> skuggi: 'ghc -v' will tell you what directories ghc searches through.
06:45:20 <lightstep> joelr, you need runIdentity
06:45:29 <joelr> lightstep: where?
06:47:08 <lisppaste2> skuggi pasted "thing" at http://paste.lisp.org/display/13014
06:48:00 <lightstep> runIdentity . runErrorT . runStateT . runWriterT
06:48:09 <joelr> lightstep: let me try that
06:48:25 <lightstep> perhaps with some parameters
06:48:25 <dcoutts> joelr, the way to diagnose these things is to look at the type of each part of your expression
06:48:48 <joelr> dcoutts: i sort of figured you need to do it inside out
06:49:00 <lightstep> skuggi, does --make help?
06:49:07 <Lemmih> skuggi: Ah. You need to compile Control first (or use --make).
06:49:16 <joelr> lightstep: apologies for the dumb question but why do i need identity in the Error?
06:49:22 <joelr> as the last parameter
06:49:34 <dcoutts> joelr, yes, but using ghci to tell you the type of each part will guide you to where the types do not match
06:49:44 <skuggi> lightstep: ah, yeah, that helped..
06:49:55 <kombinator> dcoutts: so my report is: everything works as in the first RC. The only change I've seen is that actionMenu is built automatically.
06:50:12 <joelr> dcoutts: for example
06:50:15 <joelr> dcoutts: runIdentity.runStateT.runWriterT $ unstuff $ packWords [0]
06:50:18 <lightstep> monad transformers operate on monads, so you need some base. that could be Identity, IO, Maybe, or any other
06:50:18 <joelr> gives me
06:50:27 <joelr>     Couldn't match `Identity a' against `s -> m ((a1, w), s)'
06:50:28 <joelr>       Expected type: WriterT w (StateT s m) a1 -> Identity a
06:50:28 <joelr>       Inferred type: WriterT w (StateT s m) a1 -> s -> m ((a1, w), s)
06:50:28 <joelr>     In the expression: runStateT . runWriterT
06:50:28 <joelr>     In the second argument of `(.)', namely `runStateT . runWriterT'
06:50:31 <joelr> how do i parse that?
06:51:22 <dcoutts> joelr, you check that unstuff $ packWords [0] types ok
06:51:29 <dcoutts> joelr, then runWriterT $ unstuff $ packWords [0]
06:51:31 <dcoutts> etc
06:51:37 <dcoutts> and see which bit breaks
06:51:47 <joelr> dcoutts: it compiles if you mean that
06:51:51 <joelr> dcoutts: the module loads tha tis
06:52:02 <dcoutts> no, just try that within ghci
06:52:13 <lightstep> ErrorT a Identity b ~ Either a b
06:52:13 * joelr is trying...
06:52:21 <dcoutts> you might have to comment out your definition to get it to load in ghci
06:52:38 <joelr> lightstep: don't understand
06:52:45 <skuggi> heh, anyone know how i can redirect stderr in the winxp console? :)
06:52:54 <joelr> dcoutts: runWriterT $ unstuff $ packWords [0]
06:53:01 <joelr>     No instance for (Show (StateT FastString
06:53:02 <joelr>                                   (ErrorT PackedError Identity)
06:53:02 <joelr>                                   (a, [String])))
06:53:02 <joelr>       arising from use of `print' at Top level
06:53:08 <joelr> dcoutts: i guess that went through ok, right?
06:53:09 <dcoutts> joelr, use :type
06:53:39 <dcoutts> joelr, at the ghci prompt> :t runWriterT $ unstuff $ packWords [0]
06:53:51 <joelr> dcoutts: unstuff $ packWords [0] :: (Packed a) => UnpackMonad a
06:53:52 <dcoutts> that'll tell you if it types ok
06:53:58 <dcoutts> and if so what type it is
06:54:08 <dcoutts> then make sure it has the type you expect
06:54:14 <joelr> dcoutts: type UnpackMonad a = WriterT [String]
06:54:15 <joelr>     (StateT P.FastString (ErrorT PackedError Identity)) a
06:54:15 <dcoutts> and built it up, bit by bit
06:54:41 <joelr> dcoutts: how do i build it up bit by bit?
06:54:47 <dcoutts> that way you can narrow down the bit where you don't understand what the types are doing
06:55:00 <dcoutts> well you tried runWriterT $ unstuff $ packWords [0]
06:55:09 <joelr> quite a learning curve
06:55:23 <dcoutts> now do the next one: runStateT.runWriterT $ unstuff $ packWords [0]
06:55:32 <joelr> dcoutts: right. as opposed to? what i'm digging at is the right combination of monad runners
06:55:37 * joelr is trying
06:55:47 <dcoutts> joelr, you are dealing with quite complex types here
06:56:06 <joelr>  runState.runWriterT $ unstuff $ packWords [0]
06:56:12 <dcoutts> so make sure the type of each bit makes sense to you
06:56:18 <joelr>     Couldn't match `State s'
06:56:18 <dcoutts> as you go along
06:56:18 <joelr>            against `StateT FastString (ErrorT PackedError Identity)'
06:56:18 <joelr>       Expected type: WriterT [String] (State s) a
06:56:18 <joelr>       Inferred type: UnpackMonad a1
06:56:37 <joelr> dcoutts: don't i have to start with runIdentity?
06:56:42 <dcoutts> so that when you get to the bit where it breakes you'll have any hope of seeing why it doen't match
06:57:08 <dcoutts> joelr, I don't know. I'm just suggestion the approach you should try to figure it out yourself.
06:57:26 <dcoutts> joelr, maybe you're right. Try it.
06:57:27 <joelr> hmm
06:57:45 <joelr> given this
06:57:45 <joelr> type UnpackMonad a = WriterT [String]
06:57:45 <joelr>     (StateT P.FastString (ErrorT PackedError Identity)) a
06:57:59 <dcoutts> my point is that you have the tools at your disposal to delve more deeply into why it doesn't work
06:58:06 <joelr> it seems that i need to do runIdentity.runError.runState.runWriter
06:58:18 <joelr> dcoutts: and i don't know how to use these tools :-)
06:58:28 <joelr> runIdentity.runErrorT.runStateT.runWriterT $ unstuff $ packWords [0]
06:58:37 <joelr>     Couldn't match `ErrorT e m a' against `s -> m1 ((a1, w), s)'
06:58:40 <joelr>       Expected type: WriterT w (StateT s m1) a1 -> ErrorT e m a
06:58:40 <joelr>       Inferred type: WriterT w (StateT s m1) a1 -> s -> m1 ((a1, w), s)
06:58:40 <joelr>     In the expression: runStateT . runWriterT
07:00:49 <joelr> i'm scratching my head
07:00:52 <joelr> it's not helping
07:03:03 <kolmodin> joelr: you'll have to look a litte more carefully at the types
07:03:16 <kolmodin> look at the type of runSTateT for example
07:03:18 <joelr> kolmodin: have been doing it for the past few minutes
07:03:32 <joelr> enlightenment is not coming
07:04:12 <kolmodin> @google all about monads
07:04:13 <lambdabot> http://www.nomaware.com/monads/html/
07:04:23 <joelr> kolmodin: thank you, i have done that
07:04:28 <kolmodin> that site has a section about monad transformers
07:04:36 <joelr> i have probably all the monad pages open
07:04:56 <lightstep> @type Control.Monad.runStateT
07:04:57 <lambdabot> Not in scope: `Control.Monad.runStateT'
07:05:05 <lightstep> @type Control.Monad.State.runStateT
07:05:06 <lambdabot> forall s a (m :: * -> *).
07:05:06 <lambdabot> Control.Monad.State.StateT s m a -> s -> m (a, s)
07:05:15 <joelr> ok, and then?
07:05:23 <fnord123> I'm having trouble getting my head around lazy structures.
07:05:29 <kolmodin> joelr: see, it needs a initial state to start from
07:05:35 <lightstep> the computation returns both the result and the state
07:05:42 <fnord123> any urls that might help?
07:05:56 <joelr> lightstep: yes, so what do i do?
07:05:57 <lightstep> @google credit card transform
07:05:58 <lambdabot> http://okmij.org/ftp/Haskell/misc.html
07:06:15 <lightstep> fnord123, Oleg's paper is there
07:06:25 <joelr> i suppose rather than an explanation i would appreciate if someone just gave me the proper code sequence. i learn best by example
07:06:25 <fnord123> zips?
07:07:04 <lightstep> joelr, actually, what i said doesn't matter. kolmodin points to the actual problem: you need to supply an initial state
07:07:45 <joelr> lightstep: how do i do that? i thought i'm doing that by passing xs to unstuff
07:07:47 <kolmodin> joelr: open up ghci and create one of your monads. then apply one of the runMyMonadT at the time and see what happens
07:07:48 <joelr> that's my initial state
07:07:52 <lightstep> fnord123, the one about cyclic initialization
07:09:26 <joelr> kolmodin: by creating a monad do you mean simplifying my unstuff function to return that monad and then applying the runner to the unstuff call?
07:10:39 <kolmodin> joelr: f :: WriterT [String] (StateT P.FastString (ErrorT PackedError Identity)) ()
07:10:44 <kolmodin> joelr: f = return ()
07:10:58 <kolmodin> joelr: try to run that
07:11:03 <joelr> ok
07:11:11 <SamB> hmm, is there a mode for literate PERL?
07:11:23 <kolmodin> joelr: apply runWriterT and see what type you get back
07:11:46 <kolmodin> joelr: and work your way thrugh by applying more functions
07:12:00 <joelr> kolmodin: thanks, let me try
07:12:36 <kolmodin> joelr: np
07:12:45 <lightstep> there's also the issue of the initialization
07:12:48 <lightstep> but i'm leaving
07:13:54 <joelr> kolmodin: why start with writerT?
07:14:18 <kolmodin> joelr: because it's the outer one
07:14:45 <joelr> ok, so then
07:14:54 <joelr> t runWriterT f
07:14:54 <joelr> runWriterT f :: StateT FastString
07:14:54 <joelr>                        (ErrorT PackedError Identity)
07:14:54 <joelr>                        ((), [String])
07:15:02 <joelr> this means i have to apply runStateT next, right?
07:15:18 <kolmodin> joelr: you have to peel the monads off like layers of an onion :)
07:15:36 <kolmodin> joelr: right
07:15:40 <joelr> :t runWriterT.runStateT f
07:15:41 <joelr> <interactive>:1:21:
07:15:41 <joelr>     Couldn't match `StateT a (WriterT w m) a1'
07:15:41 <joelr>            against `WriterT [String] (StateT FastString (ErrorT PackedError Identity)) ()'
07:15:48 <joelr> kolmodin: how do i proceed from here?
07:16:05 <kolmodin> @type Control.Monad.State.runStateT
07:16:06 <joelr> the outer one is WriterT and i tried to go with StateT next
07:16:06 <lambdabot> forall s a (m :: * -> *).
07:16:06 <lambdabot> Control.Monad.State.StateT s m a -> s -> m (a, s)
07:16:31 <joelr> kolmodin: and?
07:16:44 <kolmodin> joelr: you see the " -> s" part? you have to give runStateT an initial state
07:16:55 <joelr> kolmodin: i understand it needs an initialization parameter of sorts but where do i plug it in?
07:17:19 <joelr> i feel dumb
07:17:20 <joelr> ok
07:17:33 <kolmodin> joelr: also, you applied them in the wrong order
07:17:33 <joelr> so it's my faststring
07:17:33 <joelr> sec
07:17:48 <kolmodin> joelr: it should say   runStateT (runWriterT f) initialState
07:18:42 <joelr> hmm... it seems to be working
07:19:10 <kolmodin> nice
07:19:40 <joelr> :t runErrorT $ runStateT (runWriterT f) empty
07:19:41 <joelr> runErrorT $ runStateT (runWriterT f) empty :: Identity (Either PackedError
07:19:41 <joelr>                                                                (((), [String]), FastString))
07:19:52 <joelr> i think i'm getting the hang of it
07:20:03 <kolmodin> well done, that's it
07:20:11 <dons> joelr is now level 2 type hacker :)
07:20:19 <joelr> :t runIdentity $ runErrorT $ runStateT (runWriterT f) empty
07:20:20 <joelr> runIdentity $ runErrorT $ runStateT (runWriterT f) empty :: Either PackedError
07:20:20 <joelr>                                                                    (((), [String]), FastString)
07:20:25 <joelr> dons: what's level 2? :-)
07:20:37 <kolmodin> joelr: the level after level 1
07:20:39 <dons> the level after level 1, of course.
07:20:42 <joelr> haha
07:20:44 <kolmodin> hahah
07:21:00 <dons> hehe
07:21:07 <dons> @localtime dons
07:21:10 <lambdabot> Local time for dons is Sun Oct 30 00:15:05 2005
07:21:15 <dons> night!
07:21:19 <joelr> oops
07:21:20 <kolmodin> g'night
07:21:36 <joelr> kolmodin: so now i need to do the Left or right on the result, correct?
07:21:43 <joelr> well, it will return that
07:21:47 <taal> @localtime joelr
07:21:49 <lambdabot> Local time for joelr is Sat Oct 29 15:21:25 2005
07:22:01 <joelr> tenerife, canary islands :-) middle of the work day
07:22:28 <taal> waho
07:22:29 <joelr> kolmodin: so, given this definition of unstuff
07:22:38 <joelr>     unstuff :: P.FastString -> UnpackMonad a
07:22:58 <joelr> and the requirement to supply initial state to runStateT, does it mean i don't need the FastString argument?
07:23:24 <kolmodin> joelr: that's up to you. I have no idea what you are building
07:23:38 <joelr> kolmodin: i'm unstuffing a past packed string
07:23:48 <joelr> i'm reading fields of a binary packet from it
07:24:21 <joelr> so each unstuff reads its data, throws an error (or not), updates the state with the rest of the fast string and returns its value
07:24:32 <joelr> fps, sorry
07:26:26 <kolmodin> you might put the initial string as the initial state, or write a new state by using 'put', or just take it as an argument
07:26:31 <kolmodin> that's up to you
07:26:52 <kolmodin> if you'll excuse me, I've got some other things to do
07:27:00 <kolmodin> I might check up on you later :)
07:28:41 <joelr> kolmodin: thank you very much for your help! i think i'm well on my way now
07:29:15 <joelr> kolmodin: specially that explanation with making up a dumb function and checking types, i could not understand it when other folks were suggesting it before
07:29:27 * joelr thinks kolmodin has a nack for teaching ;-)
07:30:57 * dcoutts congratulates kolmodin 
07:31:00 * SamB gets the feeling PERL would be good when he feels the desire to reach for AWK
07:31:08 <kolmodin> thanks :)
07:31:41 <joelr> :m Data.FastPackedString Unstuff Control.Monad.Writer Control.Monad.State Control.Monad.Error Control.Monad.Identity Control.Monad.Error
07:31:44 <joelr> this is ugly
07:32:20 <kolmodin> joelr: you can use :m +Control.Monad.Writer      if you just want to add another module
07:32:49 <joelr> kolmodin: right. i just needed all of them but
07:32:58 <joelr> thanks for pointing that out
07:33:07 <vegai> how fast is a FastPackedString, really?
07:33:25 <joelr> fast enough for me
07:33:27 <kolmodin> vegai: about 5
07:33:29 <vegai> O(0) for all operations? :P
07:33:47 <kolmodin> vegai: j/k, I don't know :)
07:33:56 <joelr> how would i resolve this ambiguity?
07:33:57 <joelr> runIdentity $ runErrorT $ runStateT (runWriterT unstuff ) empty
07:33:58 <joelr> Top level:
07:33:58 <joelr>     No instance for (Show PackedError)
07:33:58 <joelr>       arising from use of `print' at Top level
07:34:01 <joelr>     Probable fix: add an instance declaration for (Show PackedError)
07:34:14 <joelr> i have data PackedError = PErr String deriving Show
07:34:14 <integral> that's not an ambiguity...
07:34:20 <Lemmih> add an instance declaration for (Show PackageError)?
07:34:33 <joelr> data PackedError = PErr String deriving Show
07:34:35 <joelr> :-)
07:34:39 <joelr> i have that
07:35:17 <joelr> apologies
07:35:24 <joelr>     Ambiguous type variable `a' in the constraints:
07:35:27 <joelr>       `Packed a' arising from use of `unstuff' at <interactive>:1:48-54
07:35:27 <joelr>       `Show a' arising from use of `print' at Top level
07:35:27 <joelr>     Probable fix: add a type signature that fixes these type variable(s)
07:35:28 <joelr> this is the ambiguity
07:35:43 <fnord123> if i make a data statement, am i making a type or a structure?
07:36:02 <integral> joelr: explicit type signature on the argument to print, to tell it what you're unpacking
07:36:22 * joelr slaps himself on the forehead
07:36:48 <integral> or introduce a restriction on the identity function (or some other function you're using
07:36:50 <kolmodin> vegai: I think dons wrote a few lines about the speed of fps once but I can't find it
07:37:38 <vegai> oh, the fps README has some benchmark results
07:37:51 <integral> like: myRunIdentity :: Identity Foo -> Foo; myRunIdentity = runIdentity
07:37:57 <joelr> wasn't there a huge discussion on haskell cafe about this? just recently
07:38:20 <joelr> integral: more like: Either PackedError ((a, [String]), FastString)
07:38:46 <integral> I guess type aliases are your friend for types like that 8)
07:39:04 <CosmicRay> what IO error corresponds to EISDIR ("is a directory" error when you try to open a file)?
07:39:15 <fnord123> brb
07:39:15 <joelr> wow
07:39:21 <joelr> this s..t is actually working
07:39:24 <CosmicRay> same question for ENOTDIR
07:39:30 <joelr> let x :: Either PackedError ((Word16, [String]), FastString) = runIdentity $ runErrorT $ runStateT (runWriterT unstuff ) empty
07:39:32 <CosmicRay> Neither seems to have a component in System.IO.Error
07:39:40 <joelr> Left (PErr "Word8: Empty string")
07:39:51 <joelr> i'll definitely blog about this
07:40:00 <integral> joelr: ah, I was just thinking of (runIdentity $ ...) :: TheType
07:40:16 <vegai> FPS seems to do mmap in O(1), regardless of file size, while PackedString gets a stack overflow at 1MB sized mmap
07:40:18 <joelr> just as soon as i finish converting all my packet splitting code to be monadic
07:40:22 <joelr> integral: question
07:40:36 <joelr> is there a way to make the sequence of run... prettier?
07:40:40 <CosmicRay> vegai: That's because FPS can use mmap(2)
07:40:44 <vegai> mmap alone doesn't do anything, does it?
07:40:48 <vegai> yeah...
07:40:52 <CosmicRay> vegai: because FPS' internal representation is an 8-bit char
07:40:57 <joelr> silly question, i guess not
07:40:59 <CosmicRay> vegai: whereas PackedString's is a 32-bit char
07:41:02 <joelr> anyway, #haskell rules!
07:41:03 <integral> joelr: sure!  runMyBigMonadTComposition = runIdentity . runErrorT . runStateT ...
07:41:19 <vegai> weird benchmark then, why benchmark something that does nothing ..
07:41:27 <joelr> integral: hehe
07:41:32 <vegai> CosmicRay: ohh.
07:41:46 <integral> it's the sort of thing you just stick after the type decl where you make the monad
07:42:22 <joelr> :-)
07:44:17 * joelr rides off into the sun... it's midday in tenerife, really
07:55:00 <taaal> y
07:57:49 <fnord123> its no midday in tenerife
07:57:56 <fnord123> not
08:35:02 <SamB> boy, objdump's disassemblies are much less cluttered with a mangler hacked to mark info tables as data...
08:38:36 <SamB> though the relocations aren't dumping very nicely for me...
08:40:50 <kombinator> what do you use to build small haskell projects? make?
08:41:36 <dcoutts> kombinator, cabal or ghc --make
08:41:37 <SamB> kombinator: ghc --make
08:41:56 * kombinator is playing with hmake, but doesn't understand its purpose
08:42:09 <SamB> maybe with a shell script to hold some optimization/warning options
08:42:56 <joelr> how do you kombine StateT with Maybe for a stateful computation that may or may not return a value and where upon Nothing the rest of the computations are not executed?
08:44:19 <kombinator> ghc --make relinks my objects even if they didn't change
08:46:11 <SamB> kombinator: this isn't usually a big problem in a small project
08:46:29 <SamB> also, you could pass -c if you don't need an executable
08:46:52 <kombinator> SamB: right, but I do care about principles;))
08:46:57 <fnord123> I've got a data structure that has two hashes. however, my ineptitude in haskell has them declared as: data Blah = Data.HashTable(Rational, Rational) | Data.HashTable(Rational, Rational)
08:47:10 <fnord123> I have multiple decls of Main.HashTable now. :(
08:47:33 <SamB> kombinator: they may change it some time, or you could try ;-)
08:48:38 <xerox> dcoutts_: ping
08:48:51 <eivuokko> Is it considered bad style to use kind of non-trivial pattern matches and if so, what's recommended way?
08:48:59 <Lemmih> fnord123: data Blah = Blah1 (HT Rational Rational) | Blah2 (HT Rational Rational)
08:49:15 <fnord123> ah
08:49:22 <xerox> Anybody knows about the transformation from 'data Tree ..' to graphwiz, and then render them?
08:49:31 <SamB> joelr: you probably need MaybeT or something like that...
08:49:47 <fnord123> what is maybe?
08:49:52 <fnord123> oh thats not me :P
08:50:18 <SamB> oh, he left
08:50:20 <fnord123> xerox, which format? dot?
08:50:28 <Lemmih> eivuokko: non-trivial pattern matching?
08:50:33 <xerox> fnord123: I don't really know, do you know how to do that?
08:50:40 <fnord123> yes. dot is very simple
08:50:47 <xerox> fnord123: ..or even if there exist some module which does that for free :D
08:51:00 <SamB> and I really don't know what he was talking about, either!
08:51:06 <eivuokko> Lemmih, like matching 3 first items from a list with constructors laid out and stuff like that.
08:51:11 <fnord123> well I dont know about the haskell side but the dot writing is trivial
08:51:27 * xerox is all eyes
08:51:31 <fnord123> digraph graph_name { node1 -> node2; node2-> node3;}
08:51:46 <SamB> hmm, Tree to graphviz sounds like a fun challange
08:51:53 <fnord123> that will make [node1]---->[node2]---->[node3]
08:51:56 <SamB> the dot manpage describes the format, right?
08:52:00 <fnord123> maybe
08:52:11 <fnord123> its easier to look up examples imo
08:52:34 <SamB> the challange being to come up with a nice clean way to do it...
08:52:39 <fnord123> http://wikisophia.org/wiki/Graph
08:52:40 <xerox> I think a Show instance would be cool.
08:52:49 <xerox> (And probably trivial, seen the example)
08:53:19 <dcoutts> xerox, pong
08:53:37 <xerox> Could we have lamdbabot in #haskell.it ?
08:53:48 <dcoutts> xerox, you're asking me?
08:54:02 <xerox> dcoutts, yes, too :)  I remember you did it sometime, didn't you?
08:54:11 <dcoutts> you should ask dons to set that up, that's what I did
08:54:31 <xerox> dcoutts, oh no.  I mean about the graphviz question.
08:54:32 <xerox> :-D
08:54:38 <dcoutts> oh right
08:54:52 <dcoutts> graphviz is great
08:55:00 <fnord123> I love it
08:55:04 * dcoutts tries to figure out what the question was
08:55:20 <xerox> dcoutts 'data Tree ..' --> dor format
08:56:00 <fnord123> just traverse the tree w/ and for each node, print itself and its children as a line
08:58:24 <dcoutts> xerox, I've got some code here: http://haskell.org/~duncan/WriteDotGraph.hs
08:58:59 <xerox> dcoutts: 404
08:59:06 <dcoutts> try again
08:59:29 <dcoutts> my mistake first time round :-)
08:59:32 <xerox> :D
08:59:34 <dcoutts> it's there now
08:59:41 <xerox> What is the Tree supposed to Show ?
09:00:06 <dcoutts> writeDotGraph :: (Show node, Eq node) => [(node, node)] -> String
09:00:24 <xerox> Where (node,node) is?
09:00:31 <dcoutts> those are edges
09:00:49 <dcoutts> it assumes each node is just a single thing
09:00:51 <xerox> Does it preserve the Tree's shape?
09:00:52 <dcoutts> eg a string
09:01:28 <dcoutts> this code is for a general graph in an edge list representation
09:01:48 <xerox> I see.
09:02:06 <dcoutts> so you could convert a tree into that representation
09:02:19 <xerox> I don't understand the tuple
09:02:34 <dcoutts> an edge is a pair of nodes
09:02:42 <dcoutts> it goes between the two nodes
09:02:50 <xerox> Branch l r  ==>  (l,r) ?
09:02:57 <goron> How do I install a cabal package?
09:03:04 <dcoutts> xerox, I guess so
09:03:10 <xerox> dcoutts, mumble.
09:03:17 <dcoutts> xerox, but your nodes don't have any identity
09:03:48 <xerox> data Tree a = Branch (Tree a) (Tree a) | Leaf a deriving (Read,Show,Eq)
09:04:08 <dcoutts> right, so you'll need to label all your nodes
09:04:20 <dcoutts> otherwise you can't talk about edges between them
09:04:31 <dcoutts> you can just number them
09:04:34 <xerox> I could just label them incrementally in the Show instance, pherhaps.
09:04:37 <xerox> Yes.
09:04:39 <dcoutts> yes
09:04:51 * SamB was just trying to figure out how to number nodes
09:04:58 <Lemmih> goron: runhaskell Setup.lhs install
09:05:08 <goron> Lemmih: No Setup.lhs is included.
09:05:15 <Lemmih> Setup.hs?
09:05:20 <goron> Lemmih: no
09:05:21 <SamB> oh, thats not the Tree I was trying on...
09:05:29 <SamB> that one looks considerably easier
09:05:35 <dcoutts> goron, then it's not a compliant cabal package
09:05:35 <Lemmih> goron: Sure it's a Cabal package?
09:05:48 * xerox explodes
09:05:55 <goron> Lemmih: Well, it's "cabalized" in feb 2005.
09:05:56 * dcoutts dives for cover
09:05:59 <xerox> I can't number them in the Show instance.
09:06:06 <dcoutts> xerox, no?
09:06:20 <xerox> Hmm.
09:06:39 <xerox> I can, a bit haskish, though.
09:06:47 <Lemmih> goron: What are you trying to install?
09:06:48 <goron> darcs get http://cryp.to/funcmp/
09:06:55 <goron> Lemmih: that :)
09:07:01 <xerox> I think I lost track
09:07:52 <goron> Or otherwise: does anyone have a suggestion for a good vector drawing program that actually works?
09:08:12 <goron> The Gimp is raster only. Inkscape is flakey.
09:08:22 <xerox> dcoutts, I do need a [(a,a)], not a String - hrmmm...
09:09:15 <dcoutts> xerox, I don't understand
09:09:25 <xerox> Me neither :)
09:09:43 <Lemmih> goron: You can steal the Setup.lhs script from Cabal. http://cvs.haskell.org/darcs/cabal/Setup.lhs
09:09:44 <flux__> goron, sketch has been usable for some things
09:10:51 * xerox scratches his head
09:11:08 <xerox> dcoutts: do you have an example usage of writeDotGraph ?
09:12:24 <dcoutts> xerox, yes but it probably doesn't help you
09:12:52 <dcoutts> the thing I start with is basically a list of edges between variables which are distinct strings
09:12:58 * goron was amazed by the bad quality of the different drawing tools. 
09:13:20 <dcoutts> xerox, you problem is that your nodes need labeling
09:13:30 <goron> (ofcourse the scope of the GIMP is different, but still)
09:13:43 <xerox> dcoutts, how would I label leafs?
09:13:55 <dcoutts> xerox, you can do that on the fly though I think, by passing the parent label down and the maximum label number up
09:13:58 <sethk> leaves
09:15:09 <xerox> f t = g 0 t
09:15:09 <xerox>   where g n (Leaf x) = [(n,Leaf x)]
09:15:09 <xerox>         g n (Branch l r) = g (n+1) l ++ [(n,"branch")] ++ g (n+1) r
09:15:10 <xerox> ?
09:16:20 * dcoutts hacks on a solution
09:17:36 <goron> flux__: Hmm Python on my system :(
09:19:17 <m3ga> goron, flux__ : try inkscape, successor to sketch, written in C and/or C++.
09:24:05 <franka> Hi, all.
09:24:24 <dcoutts> xerox:
09:24:28 <dcoutts> data Tree a = Branch (Tree a) (Tree a) | Leaf a
09:24:33 <dcoutts> data LTree a = LBranch Int (LTree a) (LTree a) | LLeaf Int a
09:24:36 <dcoutts> label :: Tree a -> LTree a
09:24:36 <dcoutts> label = fst . labelNode 0
09:24:36 <dcoutts>   where labelNode :: Int -> Tree a -> (LTree a, Int)
09:24:36 <dcoutts>         labelNode n (Leaf x) = (LLeaf n x, n+1)
09:24:36 <dcoutts>         labelNode n (Branch l r) =
09:24:37 <dcoutts>           let (l', n')  = labelNode (n+1) l
09:24:41 <dcoutts>               (r', n'') = labelNode n' r
09:24:43 <dcoutts>            in (LBranch n l' r', n'')
09:24:52 <dcoutts> of course you don't have to use the second explicitly labeled tree
09:25:17 <dcoutts> you can just use the label without constructing the labeled tree
09:25:50 <xerox> I see!
09:26:17 <dcoutts> so just return the list of edges between nodes instead of the labeled tree
09:26:18 <xerox> I have to generate the tuples describing connections between labels
09:26:21 <dcoutts> yes
09:27:42 <dcoutts> you probalby also want to return a mapping from node labels to leaf contents
09:28:03 <xerox> Yes
09:34:22 <araujo> Hello Haskell'ers!
09:35:06 <franka> Hi, araujo.
09:35:25 <araujo> @index replace
09:35:26 <lambdabot> bzzt
09:35:42 <araujo> hello franka
09:35:52 <skuggi> anyone here familiar with wxhaskell?
09:37:55 <skuggi> i need a widget like the input but which can't be modified by the user.
09:38:46 <amiddelk> That should be possible...
09:39:28 <amiddelk> at least with the low level interface
09:39:34 <amiddelk> moment, gonna look it up
09:41:09 <skuggi> hm, i'm a bit confused.
09:41:16 <trez_> skuggi: haha, brkar ni ocks med wxhaskell :)
09:41:21 <skuggi> not very familiar with wxhaskell yet
09:41:26 <skuggi> trez_: haha, ja :)
09:41:39 <skuggi> trez_: gr du p chalmers?
09:41:40 <trez_> skuggi: h, erat gnomish fungerade inte att ladda :)
09:41:44 <trez_> skuggi: gu :)
09:41:45 <goron> m3ga: I already said that Inkscape was flakey.
09:41:51 <trez_> axewells kompis
09:41:51 <skuggi> trez_: jaha, det r du :)
09:42:05 <skuggi> trez_: hmm. udda.
09:42:18 <skuggi> vad hnde d?
09:42:26 <trez_> kanske bst om vi tar det i privven
09:43:35 <skuggi> mm
09:45:30 <amiddelk> skuggi: do you only want the user not being able to enter, or is disabling the control itself also a solution for you?
09:47:23 <skuggi> amiddelk: nm, i found what i wanted.
09:47:32 <greenrd> @hoogle sortBy
09:47:32 <skuggi> staticText :)
09:47:33 <amiddelk> this one: textCtrlSetEditable :: TextCtrl a -> Bool -> IO ()
09:47:33 <amiddelk> usage: (textCtrlSetEditable obj editable). ?
09:47:33 <lambdabot> Data.List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
09:51:31 <skuggi> err.. why does ghci crash when i close my window in wxhaskell?
09:59:37 <dcoutts> dons, do you know much about Manuels ports abstraction?
10:00:31 * dcoutts is experimenting with gui state abstractions
10:02:44 <dcoutts> skuggi, apparently the underlying wxWidgets system does not cope well with being restarted
10:02:45 <kombinator> dcoutts: what do you mean by 'state abstractions'?
10:03:08 <dcoutts> kombinator, well people don't like coding guis using IORefs and MVars all over the place
10:03:14 <dcoutts> we want something higher level
10:04:14 <kombinator> higher level, but still 'compatible' with imperative programming?
10:05:06 <amiddelk> dcoutts: you mean things like "Fudgets" ?
10:05:26 <dcoutts> that kind of idea
10:05:37 <dcoutts> but less insane :-)
10:05:45 <dcoutts> and with fewer uses of unsafePerformIO
10:05:46 <amiddelk> :)
10:06:43 <kombinator> dcoutts: I'm still working on arrow-based gui, but it's still in the conceptual stage;)
10:07:16 <kombinator> dcoutts: and is still inferior to the work of Antony Courtney
10:07:50 <kombinator> dcoutts: but I may be able to help you
10:08:28 <dcoutts> kombinator, oh, cool
10:10:42 <dcoutts> I was thinking about a simple ports abstraction
10:10:53 <dcoutts> the idea is that you can write a value into a port
10:11:13 <dcoutts> and register for notification of values that are recieved from the port
10:11:25 <dcoutts> it makes sure that you don't get loops
10:11:41 <kombinator> dcoutts: dynamically?
10:12:08 <dcoutts> ie if you write a value then you don't immediately get notified that you wrote it, only only get the changes that other writers put in
10:12:23 <dcoutts> kombinator, I'm not quite sure what you mean by dynamically
10:12:44 <kombinator> how does it check for loops?
10:13:14 <dcoutts> well...
10:13:24 <dcoutts> it uses a hub
10:13:32 <dcoutts> each port is connected to a hub
10:13:41 <dcoutts> the hub is not visible in the interface
10:13:48 <dcoutts> it's an implementation detail
10:14:04 <dcoutts> so what you actually do is to create multiple ports and connect the together
10:14:07 <kombinator> nevermind
10:14:47 <dcoutts> it's not the same as your arrow loops probelm I guess
10:15:06 <kombinator> I see
10:15:25 <dcoutts> well I don't know, I assume you think it's a different problem
10:15:36 <dcoutts> I don't fully understand your arrow loops problem
10:17:04 <dcoutts> the way I avoid the loops is that each port has an identity so when a port forwards a message to a hub it only gets forwarded to the other ports connected to the hub
10:17:49 <dcoutts> connecting two ports just makes them share a hub
10:18:37 <dcoutts> then the idea is that a port can easily be made a proxy for a gui widget
10:21:29 <kombinator> dccoutts: could you give an example where those ports are superior to ordinary callbacks?
10:24:45 <dcoutts> the ability to connect ports, possibly of different types
10:25:23 <dcoutts> so it's to do model/view/controler things
10:25:29 <dcoutts> controlers write to ports
10:25:35 <dcoutts> views read from them
10:25:51 <dcoutts> the model is the transient value in the port
10:26:36 <dcoutts> or one could connect a more persistent store to a port for the model
10:27:15 <ibid> the real MVC or the fake MVC? :)
10:27:32 <dcoutts> ?
10:27:42 * dcoutts doesn't get it
10:29:31 <sethk> real MVC is like real OO.  Doesn't "really" exist
10:30:12 <sethk> plus it has this problem.  real world applications are poorly modeled by MVC
10:30:34 <dcoutts> in that case fake mvc :-)
10:30:51 <ibid> no, i mean MVC is popularly misunderstood
10:31:09 <sethk> ibid, that too
10:31:35 <ibid> if you're thinking MVC as model being a database or equivalent, view being the GUI and controller mediating between them, that's not MVC
10:32:25 <ibid> MVC is three classes: view handles drawing the screen, controller handles user input and model is in between them
10:32:32 <ibid> (comes from smalltalk)
10:32:36 <dcoutts> yes
10:32:45 <ibid> so, which one :)
10:32:57 <dcoutts> the V and the C often get munged together
10:33:25 <ibid> i don't see much use for MVC is modern programming
10:33:26 <joelr> folks, how do you grab the state of a state monad? say i had [Int] as a state and needed to lift it out
10:33:38 <ibid> a better name for the fake MVC is three-layer design
10:33:44 <sethk> joelr, that isn't the way the state monad works
10:34:07 <joelr> sethk: hmm
10:34:20 <sethk> joelr, runState returns the final state
10:34:36 <sethk> joelr, but that is normally used only as the initial state for additional execution
10:34:54 <sethk> joelr, the state monad is not a static repository for a value
10:35:02 <sethk> joelr, if that is what you need, look at IORef
10:35:13 <joelr> sethk: suppose i ran my computations and got a final state from runState
10:35:28 <sethk> joelr, that's ok
10:35:31 <joelr> type PackMonad a = State [P.FastString] a
10:35:51 <joelr> but i need to get at [...] now to do something with it outside of the monad
10:35:54 <joelr> can it be done?
10:36:34 <sethk> joelr, sure.  The purpose, though, is to use [P.FastString] within the monadic computation
10:36:49 <sethk> joelr, if that fits your needs, then fine
10:37:17 <sethk> joelr, but if what you need is a place to persistently keep a value, and possibly update it, the State monad is not the best way to do it.
10:37:44 <joelr> sethk: assume i'm asking a pointed question ;)
10:37:59 <sethk> joelr, then, sure, using the state returned by runState is fine
10:38:13 <joelr> sethk: i'm packing some deeply nested structure, (a, b, c) for example
10:38:14 <sethk> joelr, or execState or evalState (one of the two returns the state)
10:38:31 <joelr> so i would do something with a to convert it to a FPS, then b and then C
10:38:51 <joelr> now i need to concat them and for that i need to get at the list in my state
10:39:04 <sethk> joelr, from within the monadic computation, you use the get and put functions
10:39:13 <sethk> joelr, to get and/or set the state value
10:39:14 <kolmodin> joelr: look at 'get' and 'put'
10:39:24 <joelr> i'm already doing that
10:39:24 <kolmodin> joelr: (and 'gets' and 'modify')
10:39:32 <joelr>     stuff :: a -> PackMonad ()
10:39:41 <joelr>     stuff a = do acc <- get
10:39:41 <joelr>                  put ((P.packWords $ unpackBits a):acc)
10:40:27 <joelr> but once all the fields are stuffed i need to make one big FPS and do something with it
10:40:41 <joelr> are you suggesting i do that within another monadic computation? what if the code was non-monadic
10:40:58 <ustenzel> joelr: execState, then concat (the FPS equivalent, anyway)
10:41:01 <sethk> joelr, whether it is monadic is your choice
10:41:02 <joelr> that's why i want to grab the [FPS] from the final state
10:41:08 <joelr> execState... let me see
10:41:16 <sethk> joelr, you can always pass the state into a function
10:41:23 <sethk> joelr, a non-monadic function
10:41:38 <joelr> execState	
10:41:39 <joelr> :: State s a	The state to evaluate 	
10:41:39 <joelr> -> s	An initial value 	
10:41:39 <joelr> -> s
10:41:42 <sethk> joelr, the state monad makes using state with a series of computations cleaner
10:41:43 <joelr> how does this get invoked?
10:41:52 <sethk> execState ( do ... )
10:41:57 <joelr> oh
10:42:06 <sethk> joelr, you wrap the function call (or definition) in execState or runState
10:42:13 <sethk> joelr, or evalState but that doesn't return the state
10:42:28 <kolmodin> joelr: it's basicly the same as runStateT but not on a monad transformation
10:44:34 <joelr> runStuff a = P.concat $ execState (do { l <- get; return l}) a
10:44:39 <joelr> something like this?
10:44:48 <joelr> i get a wierd signature, though
10:44:56 <joelr> runStuff :: [Data.FastPackedString.FastString]
10:44:57 <joelr>             -> Data.FastPackedString.FastString
10:45:17 <joelr> i'm expecting to pass in the state monad
10:45:53 <sethk> joelr, the signature looks like that is what you do, but that isn't what you do
10:45:58 <ustenzel> joelr: runStuff a = P.concat $ execState a []
10:46:07 <sethk> joelr, the runState call actually creates the monad.  You pass the initial state value
10:47:02 <joelr> ustenzel: it does the trick
10:47:03 <joelr> runStuff :: forall a.
10:47:04 <joelr>             State [Data.FastPackedString.FastString] a
10:47:04 <joelr>             -> Data.FastPackedString.FastString
10:47:46 <joelr> now, is there a way to write this more succintly?
10:47:47 <joelr>     stuff a = do acc <- get
10:47:47 <joelr>                  put ((P.packWords $ unpackBits a):acc)
10:48:10 <ustenzel> btw, http://research.microsoft.com/~akenn/fun/picklercombinators.pdf has an even more elegant architecture for (de-)serialization.
10:48:44 <joelr> ustenzel: looking!
10:50:04 <ustenzel> stuff = modify . (:) . P.packWords . unpackBits  -- succinct enough?
10:51:01 <joelr> yes!
10:51:14 <joelr> ustenzel: thanks for the paper
10:51:22 <joelr> and thank you all for your help
10:53:51 <kala> you probably know. is there a mathematical libraries (fourier transformation, solving equations systems, generally things Octave could do) for use with Haskell?
10:54:18 <kala> at http://www.haskell.org/libraries/#numerics there doesn't seem to be a general one
11:07:14 <Peach06> Hello all
11:07:26 <Peach06> got a question.. havea  gloat eg 4596.4512
11:07:37 <Peach06> how can i get it in 3 decimal place form ?
11:07:42 <Peach06> i.e. 4596.451
11:08:16 <jyp> @hoogle showFloat
11:08:16 <lambdabot> Numeric.showFloat :: RealFloat a => a -> ShowS
11:08:54 <Peach06> which library is that inm ?
11:09:07 <jyp> showFFloat, sorry
11:09:32 <skuggi> err, is there a way to make ghc not output 7MB large executables?
11:09:42 <jyp> Numeric module, standard with your ghc/hugs/etc.
11:10:12 <cjb> skuggi: There have been some bugs that do that.  Do you have lots of input files?
11:11:06 <sethk> skuggi, my smaller executable programs are about 360K
11:11:17 <Peach06> how would I use showFloat ?
11:11:50 <jyp>  @eval showFFloat (Just 4)  154.45567
11:11:54 <jyp> @eval showFFloat (Just 4)  154.45567
11:11:55 <lambdabot>  add an instance declaration for (Show (String -> String))
11:12:21 <skuggi> cjb: four
11:12:28 <Peach06> ?
11:12:44 <jyp> lambdabot @plugs showFFloat (Just 4)  154.45567 []
11:12:51 <jyp>  @plugs showFFloat (Just 4)  154.45567 []
11:12:53 <jyp> @plugs showFFloat (Just 4)  154.45567 []
11:12:54 <lambdabot> "154.4557"
11:12:55 <flux__> :)
11:13:11 <jyp> damn, I should not do 15 things a time :p
11:13:21 <Peach06> thanks
11:13:55 <skuggi> cjb: the program uses wxhaskell if that has any significance.
11:16:47 <kolmodin> skuggi: run 'strip' on your program
11:17:16 <skuggi> kolmodin: what's "strip"?
11:17:30 <jyp> @man stri[
11:17:31 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
11:17:34 <jyp> @man strip
11:17:35 <soysauce> hej skuggi
11:17:36 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
11:17:38 <Philippa> cuts out all the functions the program doesn't actually use
11:17:40 <jyp> hmmm
11:17:49 <soysauce> skuggi - learning Haskell too? ;)
11:18:12 <jyp> strip - Discard symbols from object files.
11:18:13 <skuggi> hej soysauce
11:18:32 <skuggi> soysauce: oh, it's you :)
11:18:36 <ricebowl> it's me
11:18:41 <skuggi> :)
11:19:01 <skuggi> ricebowl: i'm studying it at school, remember? :)
11:19:21 <ricebowl> yeah
11:19:24 * jyp drinks soysauce 
11:19:32 <ricebowl> wow, that's a little gross ;)
11:19:42 <skuggi> :)
11:19:45 * jyp eats sushi actually :)
11:19:58 <skuggi> jyp: does it exist for windows?
11:20:43 <jyp> dunno... its an elf binutil
11:20:54 <kolmodin> skuggi: have a look in your ghc/bin dir, it might be there
11:20:56 <jyp> if I'm correct
11:21:01 <skuggi> kolmodin: nope..
11:21:08 <skuggi> i'll just get mingw.
11:21:53 * jyp was wrong
11:22:12 <skuggi> :/
11:22:59 <jyp> it might be part of mingw
11:24:02 <kolmodin> skuggi: if you still wan't it to be smaller, you may run petite on it too
11:24:10 <kolmodin> @google petite compressor
11:24:11 <lambdabot> http://www.un4seen.com/petite/
11:25:18 <skuggi> kolmodin: can't even get a hold of strip
11:25:47 <jyp> do you have the other binutils ?
11:26:03 <jyp> objdump, etc.
11:26:39 <heatsink> I'm getting a segfault in ghc-compiled code...
11:27:00 <heatsink> I've narrowed it down to an invocation of the function "when" in the IO monad
11:27:25 <heatsink> when (test_) (hPutStrLn stderr "indvar is null" >> fail "unexpected NULL")
11:27:47 <skuggi> jyp: i thought you said it wasn't a binutil :)
11:27:58 <heatsink> I print to stderr before and after this line; the thing before the "when" prints, but not the thing after
11:28:15 <jyp> skuggi, said I was wrong about that :)
11:28:16 <heatsink> Oops, I forgot to force the value of test
11:29:10 <heatsink> okay.  test_ is a boolean, and it's already been evaluated.
11:29:25 <heatsink> So I know that the segfault is happening in the Prelude function "when"
11:29:32 <heatsink> any suggestions for next steps?
11:29:42 <skuggi> jyp: oh :)
11:31:25 <jyp> skuggi, Or actually, I was wrong about thinking strip was limited to elf format... I should check before stating anything from now on :)
11:31:43 <skuggi> :)
11:31:59 <skuggi> jay, got it down from 7.7MB to 3.5MB
11:32:03 <skuggi> yay*
11:32:23 * heatsink strips
11:32:35 <heatsink> Dammit.  I only lost 2 pounds that way.
11:33:07 <jyp> You don't have to much symbols attached :-)
11:33:29 <skuggi> lol
11:33:33 <kolmodin> heatsink: mind your surrondings, you might earn money if you choose it wisely
11:34:01 <heatsink> yea, then I could gain a couple punds.
11:34:04 <heatsink> *pounds
11:34:18 <goron> Anyone wrote an interface to graphviz?
11:34:30 <jyp> there is one in FGL iirc
11:35:16 <sethk> strip predates elf by at least 15 years
11:35:27 * heatsink reads .hc files
11:35:31 <heatsink> This is cool, allocating on the heap is as fast as allocating on the stack (except for the cost of garbage collection)
11:35:37 * jyp is not that old :)
11:36:13 <vegai> heatsink: how can that be?
11:36:13 <jyp> goron, I wrote one too
11:36:40 <jyp> there's a register for heap alloc in ghc
11:38:08 <heatsink> Apparently the heap is allocated in a linear fashion.  To reserve heap space, simply subtract from the heap pointer and check for overflow.
11:38:45 <heatsink> s/subtract/add/
11:43:15 <heatsink> So I take it no one here has had to debug haskell at such a low level before.
11:43:32 <jyp> @seen JaffaCake
11:43:33 <lambdabot> JaffaCake is in #haskell. I don't know when JaffaCake last spoke.
11:43:46 <jyp> heatsink: nah ;)
11:44:06 <goron> jyp: Is there any way to illustrate a DFS using graphviz?
11:44:18 <gzl> goron: http://www.haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Graphviz.html ?
11:45:19 <goron> gzl: Yes, I found it, but the model that graphviz seems to understand it connect one node to another, and not connect one node, go passed by a few other nodes and then end somewhere else.
11:45:29 <goron> it->is
11:46:50 <goron> Doing it by hand is also a pain.
11:47:15 <jyp> goron, you might want to check this that I wrote ... http://www.haskell.org/tmrwiki/PracticalGraphHandling
11:47:25 <jyp> not sure what you want though
11:47:34 <flux__> is graphviz still being developed?
11:49:22 <goron> jyp: I think I can also just number the order in which the nodes are visited.
11:49:36 <goron> jyp: And that fits in the graphviz model.
11:49:45 <jyp> that's what I'd do, I suppose
11:49:55 <goron> jyp: Thanks for the link.
11:50:04 <jyp> you're welcome
12:05:46 <goron> jyp: Is there any disadvantage to using the one already in fptools?
12:06:01 <jyp> you mean FGL ?
12:06:29 <goron> jyp: yes
12:06:49 <heatsink> @where dons
12:06:50 <lambdabot> I know nothing about dons.
12:07:06 <jyp> I don't find the "constructive approach" so useful
12:07:29 <jyp> but if it's suits you, go for it by all means.
12:07:41 <jyp> He's your father, lambdabot ...
12:08:07 <goron> jyp: What is the use of unfoldr?
12:08:52 <jyp> create a graph...
12:09:05 <jyp> if that's what you're asking
12:09:35 * heatsink tries to figure out where the functions in the .hc files are actually _referenced_
12:10:06 * shapr boings calmly
12:10:07 <goron> jyp: I mean more the general idea of unfoldr.
12:10:49 <jyp> foldr = collapse a complex structure into a value
12:11:00 <shapr> droundy: Hiya. I dunno what's wrong with DarcsWiki, and I haven't had time to investigate more.
12:11:18 <jyp> unfoldr = expand a value to a complex data structure
12:11:33 <jyp> ... both using a clever transformation function
12:12:28 <jyp> in the case of a graph, unfoldr can be used to reify the graph defined by a function (a->a)
12:12:51 <droundy> shapr: I wasn't aware that there was a problem with DarcsWiki... what're the symptoms?
12:12:57 <goron> Could you also give an example for a list?
12:13:03 <shapr> droundy: The weird language stuff for dk?
12:13:15 <droundy> Oh yeah, that.  I forgot about that.
12:14:21 <ulph> hey shapr
12:14:27 <shapr> hej ulph
12:16:27 <jyp> @plugs unfoldr (\x->Just (x,x+1)) 0
12:16:29 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
12:16:29 <lambdabot> 27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,
12:16:29 <lambdabot> 51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,
12:16:29 <lambdabot> 75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
12:16:29 <lambdabot> 99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
12:16:30 <lambdabot> [24 @more lines]
12:16:48 <basti_> that must be a favourite
12:17:11 <Cale> @eval unfoldr (\x -> if x > 10 then Nothing else Just (x,x+1)) 0
12:17:12 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10]
12:17:23 <integral> only 24 more lines?
12:17:34 <Cale> integral: it stops after a while
12:17:50 <integral> hmm?  I thought unfoldr only stopped on Nothing?
12:18:01 <Cale> integral: the bot stops reading output
12:18:05 <integral> ah!
12:18:35 <integral> the @more isn't a continuation then,  just some more lines?
12:18:39 <Cale> right
12:19:16 <shapr> integral: Hey, good idea
12:19:27 <integral> harder to say how many lines are remaining though :-)
12:19:43 <Cale> heh, a bit harder, yeah :)
12:20:01 <basti_> it could just go like ">30 lines left"
12:20:12 <jyp> "a lot"
12:20:14 <shapr> But, um... how do you know unless you call the continuation?
12:20:30 <basti_> well after 3 seconds it knows there are n lines, but outputs only 5
12:20:51 <Cale> hum, ltu is down
12:20:53 <basti_> of course this would shrink to ">0 lines left"
12:20:53 <shapr> I was thinking of switching @more to entirely continuation based.
12:21:01 <shapr> Cale: Yeah, sucks. Second time in three days.
12:21:01 <basti_> then we wouldn't know of course
12:21:14 <integral> a mixed list + continuation for even more approach?
12:21:23 <shapr> integral: That's a good idea.
12:21:28 <shapr> @evenmore
12:21:29 <lambdabot> Unknown command, try @listcommands.
12:21:31 * shapr grins
12:21:58 <xerox> I wonder how do you think you can wrap a continuation in arbitrary code.. ?
12:21:58 <shapr> Oh! I thought of a great application for the dual of @pointless
12:22:06 <shapr> xerox: ContT!
12:22:12 <integral> doesn't GHC have continuations for IO?
12:22:16 <xerox> Yes but...
12:22:25 <Cale> um, you're going to have a small problem with the way that @eval currently works though, won't you?
12:22:28 <xerox> Hmm, I really don't know.
12:22:42 * shapr wraps xerox up into a ContT and puts a spineless tag on that says "do not open until Christmas" ;-)
12:22:46 <Cale> you're going to have to keep a bunch of runplugs processes around
12:22:58 <integral> they're separate processes?
12:23:04 <Cale> yes
12:23:31 <Cale> I suppose that a future @eval could kill off a previous one
12:23:33 <shapr> My woman is visiting, I better clean up the place.
12:23:44 <integral> you can't serialise a whole VM yet? :-P
12:24:04 <xerox> shapr: point.  But.. you don't want to run the whole me, but run me, and stop after 3 secs, and place a continuation *there*
12:24:27 <shapr> xerox: Yeah, I dunno. I'll have to think about it when I'm not so tired :-)
12:25:09 <xerox> OK, otoh we accomplished to have graphviz-zed trees :D  http://img495.imageshack.us/img495/4233/graphimg4kv.gif
12:25:15 <Cale> oh, right, and the time-limiting bit is currently done in runplugs
12:26:12 <xerox> reset (eval (shift (\k -> magic k ircCode)))
12:26:49 * xerox offers a karmapoint to whoever writes 'magic' :-)
12:26:51 <musasabi> Has anyone got a GHC crash with: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
12:26:54 <musasabi>         Prelude.last: empty list
12:27:19 * goron likes GHC messages. "impossible". ha
12:27:26 <musasabi> (very informative and gives hints where the error is...)
12:27:29 <xerox> musasabi: in which context?
12:27:50 <xerox> musasabi: not that I'll actually be able to help :)  You probably need to bug some GHC guru...
12:28:21 <musasabi> xerox: compiling a large source file which uses TH (but it seems to crash after TH has been run - at least -v hints to that direction)
12:32:58 <musasabi> Is there a way to get a trace where the exception occurs in GHC (-xc was broken at least in some versions - is it fixed?)
12:37:10 <ndm> shapr, ping
12:42:04 <SamB> hmm, perhaps I should stop trying to make sense of the code generated for my BF interpreter and just show it (the interpreter) to people...
12:42:12 <SamB> lisppaste2: help
12:42:13 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:43:42 <Wilmer> hi all
12:43:53 <Wilmer> can anyone tell me why hugs suddenly doesn't let me overload a function anymore?
12:45:01 <basti_> hmm how does that look like?
12:45:37 <Wilmer> "ERROR week42.hs:52 - "godown" multiply defined
12:45:56 <basti_> hmm did you put something inbetween the lines there?
12:45:58 <Wilmer> while i got a pretty much identical goup that doesn't give problems
12:46:12 <Wilmer> ahh, they must be in a row?
12:46:16 <Wilmer> okay, this works now, thanks :-D
12:46:27 <basti_> ^^
12:46:28 <basti_> lol
12:46:38 <franka> You are aware that you can only overload using type classes?
12:46:50 <lisppaste2> SamB pasted "bf.hs" at http://paste.lisp.org/display/13015
12:47:27 <Wilmer> franka: you mean by first making a godown :: a -> [a] -> [[a]] like thing?
12:47:41 <SamB> franka: the issue was that you can't intermix the cases of one function with others...
12:47:42 <basti_> i think you're talking about different things
12:48:19 <sethk> he didn't really mean overload
12:48:25 <SamB> yeah
12:48:29 <franka> He wrote "overload".  I think he was writing pattern-matching clauses.
12:48:34 <sethk> right
12:48:59 <SamB> anyone want to look at my BF interpreter?
12:49:13 <sethk> SamB, sure
12:49:19 <Wilmer> you wrote a brainfuck interpreter in haskell?
12:49:35 <sethk> is there a ghc flag telling it to complain about non-exhaustive pattern matches?
12:49:40 <Wilmer> sethk: hmm, wait, yeah, overloading is not the word for this i guess, yeah
12:49:53 <SamB> Wilmer: yup!
12:50:11 <xerox> sethk: -fno-warn-incomplete-patterns
12:50:15 <SamB> I just pasted it and lisppaste2 announced it
12:50:17 <sethk> xerox, thanks
12:50:31 <xerox> sethk: np.  The manpage has a comprehensive list :)
12:52:01 <franka> There are curly braces missing from prev, next, decr, incr.
12:52:07 <franka> Does that actually compile?
12:53:16 <franka> Also read, write.
12:53:45 <franka> And loop has a superfluous semicolon.
12:54:18 <SamB> yes, it compiles
12:54:45 <franka> Really?  I don't think that's correct.
12:55:01 <SamB> I've been recompiling it with different options, I even added a dump option and hacked the mangler (both locally).,
12:55:08 <franka> With GHC?
12:55:10 <SamB> I should think it compiles ;-)
12:55:18 <SamB> yes, GHC.
12:55:26 <SamB> what other implementation has a mangler?
12:55:31 <franka> What is the problem with your code?
12:55:43 <SamB> nothing, I just thought it might be interesting ;-)
12:56:39 <SamB> well, I mean besides the fact that I don't remember how big the tape is supposed to be
12:56:47 <xerox> Where is it?
12:56:57 <SamB> <lisppaste2> SamB pasted "bf.hs" at http://paste.lisp.org/display/13015
12:58:10 <xerox> SamB: I'd add a type synonym to avoid the Storable & co everywhere :D
12:58:17 <xerox> It's very nice!
12:58:32 <dcoutts> marcot!
12:58:35 <xerox> Parsec makes it very straighforward!
12:58:56 <dcoutts> marcot, I was looking at making the changes to the gtk2hs build system that you wanted
12:58:59 <SamB> xerox: well, I tried to stick those in BF, but it didn't seem to work. maybe I need to add {-# OPTIONS_GHC -fglasgow-exts #-} for that...
12:59:08 <xerox> SamB: yeah, do it :D
12:59:12 <SamB> xerox: yes, it does.
12:59:17 <xerox> Cool.
12:59:54 <SamB> (yes, it does Re: Parsec making it very straightforward)
13:00:02 <xerox> Indeed :)
13:00:54 <dcoutts> marcot, I fear it turns out it's too major a change this close to the release, but I can send you the patches if you want to use them yourself.
13:03:44 <SamB> oh, I see, I need to take out the first parameter to BF to do it...
13:05:24 <SamB> actually, I don't think I can do that...
13:05:38 <marcot> dcoutts: hello!
13:06:11 <marcot> dcoutts: no, I prefer to wait for the change in the other release..
13:07:08 <SamB> it complains that:
13:07:13 <SamB> bf.hs:13:0:
13:07:14 <SamB>     All of the type variables in the constraint `Integral a' are already in scope
13:07:14 <SamB>         (at least one must be universally quantified here)
13:07:14 <SamB>     In the type synonym declaration for `BF''
13:07:27 <SamB> also about Storable
13:07:30 <araujo> Hola joelr
13:07:37 <joelr> hola araujo
13:07:58 <araujo> joelr, Spanish Haskell'er? :-)
13:08:19 <joelr> folks, assuming
13:08:20 <joelr> class (Eq a) => PU a where
13:08:20 <joelr>     doU :: UMonad a
13:08:20 <joelr>     doP :: a -> PMonad ()
13:08:20 <joelr> instance (PU a, PU b) => PU (a, b) where
13:08:45 <joelr> how do i code the instance? i want to unpickle a and then unpickle b and return a tuple of those
13:08:51 <joelr> araujo: sort of :-)
13:09:08 <joelr> araujo: does it show me coming from telefonica?
13:09:21 <araujo> joelr, yes
13:09:25 <araujo> :-]
13:09:30 <joelr> araujo: cool :-)
13:10:05 <SamB> doU = liftM2 (,) doU doU
13:10:20 <joelr> SamB: cool, let me try that
13:10:49 <SamB> you'll need to import liftM2 from somewhere if you haven't already
13:10:51 <joelr> SamB: and this for picking?     doP (a, b) = do doP a
13:10:52 <joelr>                     doP b
13:11:15 <SamB> that looks fine, besides the indentation being off...
13:11:30 <joelr> i wonder, though, about putting both doPs in a do, is that necessary?
13:11:39 <SamB> no, it isn't
13:12:00 <SamB> you could say doP (a, b) = doP a >> doP b
13:12:05 <joelr> aha
13:12:21 <joelr>     doU = liftM2 (,) doU doU
13:12:35 <joelr> this doesn't quite work, though, as it needs to be in a Maybe...
13:12:46 <SamB> oh, it does, huh...
13:12:46 <joelr>     Couldn't match `Maybe (a, b)' against `(a1, a2)'
13:12:47 <joelr>       Expected type: a1 -> a2 -> Maybe (a, b)
13:12:47 <joelr>       Inferred type: a1 -> a2 -> (a1, a2)
13:12:47 <joelr>     In the first argument of `liftM2', namely `(,)'
13:12:50 <SamB> hmm...
13:13:14 <joelr> type UMonad a = WriterT [String] UState (Maybe a)
13:13:19 <dcoutts> marcot, sorry I don't quite know what you mean. i'm going to release Gtk2Hs 0.9.10 without the build system changes you want but you can apply the patches after that for when you build your debian packages.
13:13:57 <joelr> SamB: the idea is that one of the doUs can return Nothing
13:14:08 <joelr> SamB: and then Nothing should be returned instead of the tuple
13:14:29 <SamB> yeah. I don't see why that throws off types...
13:14:41 <marcot> dcoutts: ok, I actually have a patch for solving this problem in debian with 0.9.9, which I think that will probably be not different to do it in 0.9.10.
13:14:51 <SamB> so, can I see the whole file?
13:15:00 <joelr> sure, where do you want it?
13:15:08 <joelr> lisp paste should work i think
13:15:34 <SamB> just paste it to lisppaste2
13:15:38 <SamB> lisppaste2: help
13:15:38 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:16:46 <lisppaste2> joelr pasted "UMonad stuff" at http://paste.lisp.org/display/13017
13:17:07 * joelr thinks lisp paste is way better than the old way
13:18:10 <joelr> SamB: does that help?
13:18:44 <kala> could somebody point me to drawTree example or show, how to use that kind of data type? (http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html)
13:22:14 * SamB is still reconstructing the header
13:22:38 <joelr> oh
13:22:44 <joelr> sorry about that sam
13:23:07 <lisppaste2> joelr annotated #13017 with "header" at http://paste.lisp.org/display/13017#1
13:23:13 <joelr> does this help?
13:23:29 <joelr> you can safely delete the doU_Num code
13:23:37 <joelr> no reason to have it for tuples
13:23:41 <frederik2> any idea why this doesn't work?:
13:23:42 <frederik2> ghc -e "getContents >>= (\s -> return $ map Data.Char.toUpper s)"
13:23:49 <joelr> the tuple thing is supposed to be abstract
13:24:38 <frederik2> ah s/return/print/ makes it work. that's laziness for ya
13:25:02 <joelr> SamB: let me know if you are missing anything else
13:27:55 <SamB> hmm, those type names are a bit deceptive
13:28:18 <joelr> SamB: what do you mean?
13:28:32 <joelr> U = unpickle and P = pickle :)
13:28:43 <SamB> *Main> return () :: UMonad ()
13:28:44 <SamB> <interactive>:1:7:
13:28:44 <SamB>     Couldn't match `Maybe ()' against `()'
13:28:44 <SamB>       Expected type: Maybe ()
13:28:44 <SamB>       Inferred type: ()
13:28:44 <SamB>     In the first argument of `return', namely `()'
13:28:46 <SamB>     In the expression: return () :: UMonad ()
13:28:58 <joelr> SamB: right
13:29:44 <joelr> SamB: i'm reading things from a fps and they might not read completely in which case i should return nothing
13:30:13 <joelr> and if i have a "thing" with sub-things A and B and either one does not read in completely then the whole thing should be Nothing
13:31:03 <joelr> with the added twist that i need to keep the fps as state since doUs consume it and i want to add trace messages
13:31:52 <joelr> SamB: i can't figure out how to make the tuple be nothing if either doU reads Nothing
13:32:21 <joelr> `mplus` would try the other if the first one fails, not quite what i want. just sequencing them should do it
13:33:00 <joelr> maybe this
13:33:01 <joelr> do { a <- doU; b <- do U; return (a, b) }
13:33:11 <joelr> i think i tried that, though, and it did not work
13:33:31 <SamB> didn't I say last night that you wanted MaybeT, which unfortunately does not exist?
13:33:36 <ustenzel> joelr: you know, UMonad actually is no monad.  (it could be, if you implemented the instance)
13:33:51 <joelr> ustenzel: no idea what you mean
13:34:07 <SamB> ustenzel: actually, it can't be...
13:34:11 <marcot> dcoutts: but anyway, if you can send me the patches, I think it'll be helpful.
13:34:25 <ustenzel> joelr: there's no `instance Monad (UMonad)' anywhere in your code, is there?
13:34:49 <joelr> ustenzel: sec
13:34:58 <joelr> type UMonad a = WriterT [String] UState (Maybe a)
13:35:02 <joelr> ustenzel: it's a type alias
13:35:04 <ustenzel> SamB: It can't?  Hmm.  But it must be close.
13:35:26 <ustenzel> joelr: i see that.  but it's still no monad :)
13:35:51 <joelr> ustenzel: well, i'm just going along with what i read on the various monad pages
13:36:10 <joelr> do it like they do it on the discovery channel ;)
13:36:48 <ustenzel> joelr: I think, you don't need the StateT anyway and what you want is `type UMonad a = WriterT [P.FastString] Maybe a'
13:36:49 <joelr> ustenzel: i just want to figure out how to do (a, b) for my monad, same for lists
13:37:09 <joelr> ustenzel: wrong. the writer stuff is separate
13:37:21 <joelr> ustenzel: i want logs and i want to consume the fps which i keep as state
13:37:42 <ustenzel> joelr: (a,b) for a monad is easy: liftM2 (,) is your friend.  but you need a monad, and despite its name, UMonad is none.
13:37:58 <joelr> ustenzel: WriterT [String] is for my trace messages, state is for keeping the buffer and i want to return Maybes
13:38:01 <joelr> ustenzel: guide me!
13:38:30 <ustenzel> joelr: ok, so you need both.  you could still replace Identity by Maybe, get rid of the plumbing and enjoy :)
13:38:31 <joelr> ustenzel: are you saying i need just one magic declaration?
13:38:40 <xerox> dcoutts: I deleted some abounding shows, and constructed a little framework for tree, now it does very nice graphs :D  Thanks for writeDotGraph :-)
13:38:58 <ustenzel> joelr: this is Haskell.  everything is just one magic declaration away ;-)
13:38:59 <joelr> ustenzel: i tried that but could not get it right
13:39:17 <joelr> ustenzel: it would not compile with Identity replaced by a Maybe
13:39:35 <ustenzel> joelr: huh?  it should.
13:39:43 <joelr> ustenzel: try it ;)
13:40:05 <joelr> ustenzel: i was doing something wrong, i'm sure
13:40:15 <ustenzel> joelr: import Control.Monad.Error -- the `instance Monad Maybe' is hidden in there
13:40:16 <joelr> ustenzel: you see the lisp paste, right?
13:40:47 <ustenzel> joelr: right in front of my eyes
13:41:03 <joelr>     Couldn't match `Maybe (a, b)' against `(a1, a2)'
13:41:03 <joelr>       Expected type: a1 -> a2 -> Maybe (a, b)
13:41:03 <joelr>       Inferred type: a1 -> a2 -> (a1, a2)
13:41:03 <joelr>     In the first argument of `liftM2', namely `(,)'
13:41:14 <joelr> ustenzel: so importing Control.Monad.Error did not help
13:41:24 <joelr> not here
13:41:25 <joelr> instance (PU a, PU b) => PU (a, b) where
13:41:25 <joelr>     doU = liftM2 (,) doU doU
13:41:25 <joelr>     doP (a, b) = doP a >> doP b
13:41:41 <ustenzel> joelr: yeah, you need a magic declaration and otherwise correct code :)
13:42:00 <ustenzel> joelr: I'll annotate it (hope it works...)
13:42:10 <joelr> ustenzel: but you said i was magically importing the magical declaration from Control.Monad.Error :D
13:42:23 <joelr> ustenzel: oh, wait, that was for Maybe
13:44:19 <joelr> instance Monad (UMonad a)
13:44:19 <joelr>     Kind error: Expecting kind `* -> *', but `UMonad a' has kind `*'
13:44:19 <joelr>     In the instance declaration for `Monad (UMonad a)'
13:44:29 <joelr> ustenzel: do i have to implement all the monad methods? darn
13:44:35 <joelr> i'm just combining things!
13:45:11 <sethk> joelr, you don't have to implement them if you don't call them, noo
13:45:18 <ustenzel> joelr: *if* you're just combining transformers, the methods are there.  plugging a (Maybe a) in there is not "just combining".
13:45:44 <joelr> ustenzel: please show me the way! i'd love to replace Identity with Maybe
13:45:52 <joelr> ustenzel: i think that's how it needs to be done anyway
13:46:20 <ustenzel> joelr: I'm working on it.  Dumping broken code into the channel will only confuse everyone, won't it?
13:46:35 * joelr apologizes
13:49:53 <lisppaste2> ustenzel annotated #13017 with "Transformation" at http://paste.lisp.org/display/13017#2
13:50:30 <ustenzel> joelr: see the paste (just the unpickling stuff).  untested code, but you should get the idea.
13:50:44 <joelr> looking
13:51:59 <joelr> darn, just one magic touch and everything is looking good
13:52:07 <joelr> i wonder when i get to that point myself :-)
13:52:12 <joelr> ustenzel: let me try that code
13:52:14 <ustenzel> joelr: note the type of runU.  if something goes wrong, you get nothing -- no log, no partial result.
13:52:47 <joelr> ustenzel: that was not my intent, btw :-) that i could do with my current non-monadic code
13:52:55 <joelr> ustenzel: surely if things go wrong i want my log!
13:52:59 <lisppaste2> SamB annotated #13017 with "the mythical MaybeT" at http://paste.lisp.org/display/13017#3
13:53:00 <ustenzel> joelr: presumably you want the Maybe inside the tuple; but that requires MaybeT, which does not exist.  That's the stuff for tomorrow's lesson ;-)
13:53:25 <joelr> ustenzel: with the tuple i _do not_ want the maybe
13:53:38 <joelr> ustenzel: not inside. if a or be fails to read then i want nothing instead of a tuple
13:54:00 <SamB> joelr: behold, the mythical MaybeT
13:54:17 <joelr> SamB: where is it hampering me?
13:54:27 <joelr> so can i have the WriterT log if things go wrong?
13:54:37 <ustenzel> joelr: look at the result of runU: you get either (your result, remaining input and log) or (nothing at all).
13:54:38 <joelr> or do i have to switch to ErrorT?
13:55:00 <ustenzel> joelr: but you want: either (result, input, log) or (input, log).
13:55:03 <joelr> ustenzel: i understand that, thanks. i'm asking whether it can be done differently because no log in case of error is of no use
13:55:03 <SamB> joelr: Thats actually an implementation of MaybeT
13:55:23 <ustenzel> joelr: the latter works with the mythical MaybeT or with ErrorT or with ListT.
13:55:31 <SamB> or do you want more anyways?
13:55:34 <joelr> ustenzel: i don't carre about the the log if things go right
13:56:12 <ustenzel> joelr: just try the code as is.   the change is just shuffling around the transformers:  "one magic declaration"
13:56:53 <joelr> i know i'm being a pest but i truly want the log in case of error. that's why i started cooking the whole thing up
13:57:06 <joelr> ustenzel: what's the magic declaration?
13:57:49 <ustenzel> joelr: step one: compile the damn thing as is, see if it works, try to understand it.  Go to nomaware.com, it's really an eye opener.
13:58:09 <dscape> need help
13:58:38 <dscape> i have a ambiguous occurrence
13:58:38 <SamB> joelr: if you want error messages, you might want to look at stuff like Parsec...
13:58:44 <joelr> ustenzel: i have the nomaware open all day
13:58:47 <SamB> Parsec is like the best
13:58:51 <ustenzel> joelr: step two: declare `type Umonad = ErrorT ... (WriterT ... (State ...)' and adapt runU.  Everything is well.
13:58:54 <joelr> SamB: i just want my log, thats all
13:58:58 <SamB> it has such wonderful error messages
13:59:08 <dscape> Control.Monad.State.get and Graphics.UI.WX.Attributes.get
13:59:25 <joelr> ustenzel: that's what i wanted to hear, thanks. i was wondering if it could be done with Maybe but i see that it cannot
13:59:27 <SamB> (note that when I say look at, I mean look at the code and steal ideas)
13:59:31 <dscape> and i need both libraries (thought i only need the WX.Attributes.get
13:59:35 <ustenzel> joelr: or `type Umonad = ListT ... (WriterT ... (State ...)'; works as well.
14:00:20 <dscape> is there a solution for this while not changing the imported files?
14:00:26 <dscape> any1?
14:00:34 <ustenzel> joelr: or write the mythical MaybeT yourself.  That gives a certain feeling of accomplishment right before you throw it away again.  (I knew it, that's what I did :))
14:00:55 <dscape> please?
14:01:14 <sethk> dscape, you can fully qualify the call
14:01:39 <dscape> how?
14:01:40 <joelr> ustenzel: how does this help? type Umonad = ListT ... (WriterT ... (State ...)'
14:01:53 <sethk> dscape, e.g. by writing WX.Attributes.get
14:02:02 <dscape> that didnt work
14:02:03 <ustenzel> joelr: come on, you have to fill in the blanks :)
14:02:10 <joelr> ustenzel: by letting me return either an empty list or something?
14:02:25 <dscape> i tried writting something like :
14:02:26 <sethk> dscape, it does if you get the syntax right.  Post what didn't work on a pastebot so we can look at it.
14:02:34 <dscape> a <- WX.Attributes.get (...)
14:03:07 <ustenzel> joelr: the fundamental question is: "What transformer must be declared to get the Maybe in the result *inside* the tuple?"
14:03:11 <sethk> dscape, sorry, I didn't notice you are in the monad
14:03:23 <dscape> yes :( i am :P LOL
14:03:24 <joelr> ustenzel: but i don't need it inside the tuple :-)
14:03:28 <dscape> state transformer
14:03:34 <ustenzel> joelr: the other tuple ;-)
14:03:46 <dscape> with maybe
14:03:49 <ustenzel> joelr: gimme a minute, I'll spell it out...
14:03:55 <joelr> ustenzel: which other tuple? i'm lost
14:04:04 <ustenzel> joelr: the result of runU
14:04:04 <sethk> dscape, you should be able to create a function for each, by annotating the function with the type, and call one or the other
14:04:39 <sethk> dscape, e.g.     runStateT( do a <- get; return a )
14:04:45 <joelr> ustenzel: ah, understand you now. but i think everyone is saying i need the magical MaybeT, right?
14:04:47 <ustenzel> dscape: StateT x Maybe gives a result of Maybe (a,x).  joelr wants (Maybe a,x).  See the dilemma?
14:05:12 <ustenzel> joelr: you do.  but there's no MaybeT anywhere in the common libraries.
14:05:22 <dscape> yeah buts im like a newbie
14:05:27 <joelr> ustenzel: which means a combination with ErrorT then
14:05:40 <ustenzel> joelr: but there's ListT or ErrorT, they are sufficiently close.
14:05:42 <joelr> haskell is hard on newbies doing hard haskell :D
14:05:46 <dscape> only my second work in haskell
14:05:56 <joelr> it's my first work :-)
14:06:01 <dscape> yeah i do hard haskell :P i want a good grade :P
14:06:17 <joelr> ustenzel: you mean to let me return either an empty list or something?
14:06:31 <dscape> lets see sethk
14:06:33 <joelr> ustenzel: ListT as a replacement for Maybe, right?
14:06:51 <ustenzel> joelr: exactly.  a list of at most one element ist like a Maybe.
14:07:11 <dscape> nget :: (w -> Attr w a -> IO a) -> ...
14:07:17 <ustenzel> joelr: same with ErrorT, an ignored error value is the same as Nothing
14:07:19 <dscape> nget a = get a?
14:07:31 <dscape> with full path?
14:07:34 <joelr> ustenzel: cool hack but more work with ErrorT. i think ListT would be better
14:07:48 <joelr> ustenzel: i guess i'll just have to figure out the combination of transformers now
14:07:52 <dscape> who the fuck is that stupid to code something with a function name that is used in state monad?
14:08:18 <dscape> can someone help me please? im coding 12 hours in a row and i really need a break
14:08:19 <dscape> lol
14:08:31 <Philippa> dscape: someone who hasn't seen that monad
14:08:34 <joelr> ustenzel: i would need to use Identity in the last transformer, right?
14:08:55 <xerox> You can hide bindings when import things doing something like: import Module hiding (binding,..)
14:08:55 <Philippa> someone who wrote a library that wasn't even for Haskell, for that matter
14:09:14 <lisppaste2> ustenzel annotated #13017 with "maybe a list" at http://paste.lisp.org/display/13017#4
14:09:16 * joelr stole the concept of attributes to sell haskell to the client
14:09:18 <dscape> but my teatchers haskell me to code WX for extra credits... :\
14:09:18 <{Arias}> sorry, a language question...
14:09:19 <{Arias}> what is the opposite of to advance?
14:09:20 <{Arias}> :P
14:09:21 <joelr> as a simple scripting language
14:09:38 <Korollary> {Arias}: you mean in english ?
14:09:41 <Philippa> {Arias}: depends on context. Could be to retreat, for example
14:09:42 <{Arias}> yes xD
14:09:45 <dscape> i have to use WX.. its not my choice.. neither is monad status t
14:09:47 <Cale> dscape: import qualified Module as M
14:09:51 <Philippa> (in a military or military-analogy context)
14:09:54 <Korollary> {Arias}: retreat, withdraw, etc.
14:10:04 <Philippa> "go backwards" ;-)
14:10:09 <dscape> Cale: newbie here whats that?
14:10:13 <Cale> dscape: then you have to write M.whatever to access "whatever" from module M
14:10:16 <poetix> To backslide
14:10:21 <Cale> Module Module, rather :)
14:10:22 <xerox> What are you trying to code, joelr ?
14:10:25 <ustenzel> joelr: either transform Identity (and runIdentity somewhere) or use a non-transformer version as the base monad
14:10:26 <{Arias}> i have a buffer, and i need method to "retreat" the pointer
14:10:30 <{Arias}> is correct retreat ?
14:10:40 <dscape> thanks cale :D
14:10:43 <dscape> thats great
14:10:44 <{Arias}> i dont speak english very well :(
14:10:54 <Philippa> if advance is the term used for the other direction, yeah
14:10:54 <Cale> dscape: yeah if two modules you're using use the same name, you have to import one of them qualified
14:10:55 <dscape> but ill write all the code with a M before the monads.. lol
14:11:03 <poetix> Why not "increment" and "decrement" for a pointer?
14:11:10 <{Arias}> oka thanks :D
14:11:13 <dscape> cale not same module names but same function names..
14:11:24 <{Arias}> one function is nextChar
14:11:24 <dscape> does that work for this 2? (i suppose so)
14:11:33 <{Arias}> returns the char and advance de pointer
14:11:35 <sethk> dscape, I tried it here and my method seems to work
14:11:36 <joelr> xerox: it's a scripting library to excercise a poker server
14:11:40 <{Arias}> and th other funcion only retreat de ponter
14:11:40 <Philippa> poetix: leaves you thinking of a number rather than a position
14:11:41 <dcoutts> marcot, how did you do it for the existing release? it might be simpler than my method.
14:11:41 <poetix> prevChar, for previousChar?
14:11:55 <{Arias}> but the funcion dont return the previuos char
14:11:57 <Philippa> really, pointers-the-numbers are a really sucky analogy for most ops
14:11:58 <{Arias}> only move the pointer
14:11:59 <poetix> Philippa: that confuses C newbies, too.
14:12:05 <Korollary> Advance as in advancing on a chess board
14:12:10 <Cale> dscape: yeah -- I suppose you don't have to use "as M", but it makes it more convenient
14:12:25 <Philippa> accurate abstractions without additional conceptual junk are a good thing
14:12:27 <joelr_> xerox: it implements all the binary packets and let you write scripts in simple haskell to send and receive them
14:12:30 <ustenzel> joelr: to get monad transformers, set aside an hour or two, write down the types of the runxxx functions for some transformed monads, then stare at them.
14:12:43 <Philippa> if the position is never accessible as an actual number, I don't think inc/dec are appropriate operation names
14:12:50 <joelr_> ustenzel: thanks
14:12:55 <poetix> Backtrack, back up, goBack...
14:13:01 <dscape> sethk can u give me the code in pvt?
14:13:15 <joelr_> xerox: i'm trying to monadify the code to make things even simpler for scripters. to keep track of packets that led to an error for example
14:13:16 <sethk> dscape, sure,
14:13:25 <dscape> Cale: works like a charm :D
14:13:28 <{Arias}> mmm thanks at all :)
14:13:35 <ustenzel> joelr_: if you stare long enough, you'll think "Why's it all backwards?!" and then it should make sense.  (it did for me)
14:13:43 <dscape> thanks :P i would also try to help out but im a newbie
14:13:44 <{Arias}> i'm spanish and dont speak english very well x)
14:13:49 <joelr_> xerox: but before i monadify scripting i'm trying to monadify my packet picking library because with functional code i cannot debug parsing problems
14:13:51 <poetix> backOneChar...actually, "retreat" is probably fine too.
14:13:56 <dscape> most complicated thing i coded is somethin like
14:14:07 <{Arias}> retreatChar ok ?
14:14:09 <joelr_> xerox: i hope that gives you an idea
14:14:16 <xerox> joelr_: sounds fun, do you have a repo of that, or will have?
14:14:16 <sethk> {Arias}, mejor de mi espanol  :)
14:14:26 <joelr_> xerox: repo? what's that?
14:14:30 <{Arias}> jaja no creo x)
14:14:36 <xerox> joelr_: a repository for the source code
14:14:36 <joelr_> xerox: i'll blog about it for sure, about the experience that is
14:14:48 <joelr_> xerox: it's paid work so the answer is no :(
14:14:55 <{Arias}> sethk, mejor "que" mi espaol :P
14:15:06 <dscape> return (map (\(a:_) -> map (\x -> (fromEnum x) - (fromEnum '0')) a) (map words (lines r)))
14:15:19 <dscape> this is really badly written isnt it? :\
14:15:21 <sethk> {Arias}, pinche idioma
14:15:25 <xerox> joelr_: paid != opensource ;)
14:15:40 <xerox> joelr_: I mean, it could be opensource anyway.
14:15:42 <{Arias}> jeje
14:15:46 <joelr_> xerox: i put in a reasonable bid on the strength of my erlang experience, to learn haskell :-) i had an idea how this would work out best and needed haskell for that. overall the experience has been very positive
14:15:50 <joelr_> xerox: work for hire
14:15:59 <joelr_> xerox: client is not open to open source
14:16:02 <xerox> hmpf.
14:16:25 <joelr_> xerox: i could have never done it without the help from #haskell (Cale still around? ;))
14:16:28 <sethk> I've been paid to make enhancements to my open source projects and then included them later.  So for hire doesn't always preclude opensource
14:16:38 * joelr_ high-fives Cale
14:17:13 <Cale> :)
14:17:17 <joelr_> sethk: except this project has never been open source and the client wants it this way, etc.
14:17:30 <joelr_> Cale has taken me to level 1 of hackerdom
14:17:44 <joelr_> ustenzel and SamB are guiding me to level 2
14:17:45 <sethk> joelr_, I was responding to xerox who said for hire != opensource.
14:17:46 <joelr_> hehe
14:17:52 <sethk> joelr_, most clients won't do it, I know
14:18:17 <joelr_> @localtime joelr_
14:18:21 <lambdabot> Local time for joelr_ is Sat Oct 29 22:17:54 2005
14:18:42 <{Arias}> @localtime {arias}
14:18:48 <joelr_> time to watch a good movie and ... let my beloved go to sleep while i continue tackling the monad transformers
14:18:51 <xerox> @localtime xerox
14:18:52 <lambdabot> Local time for xerox is Sat Oct 29 23:18:30 2005
14:19:01 <{Arias}> @localtime lambdabot
14:19:06 <{Arias}> :P
14:19:34 <sethk> {Arias}, IRC nick not registered?
14:19:36 <joelr_> ustenzel: did you send me the cool paper on pickling?
14:19:43 <xerox> I don't think she implements CTCP answers
14:19:57 <ustenzel> joelr_: jup, that was me
14:20:01 <{Arias}> my nick is registered
14:20:04 <dscape> thanks all..
14:20:12 <{Arias}> and i'm identified
14:20:29 <{Arias}> maybe the client...
14:20:30 <sethk> @localtime {Arias}
14:20:34 <jak> In ghci, how do you force a garbage collect?
14:20:35 <{Arias}> 23:20  lambdabot(n=lambdabo@alonzo.cse.unsw.EDU.AU) CTCP TIME
14:20:36 <dscape> if any of u knows WX and can help me replace a Var (a) with a stateT (a) let me know
14:20:43 <joelr_> ustenzel: cool
14:20:51 <joelr_> gotta run for the time being
14:20:55 <joelr_> thanks guys
14:20:56 <jak> (so that I can force finalisers for open sockets to run?)
14:21:04 <sethk> dscape, why do you want to do that?  Did you say it is an assignment?
14:21:25 <Lemmih> @type System.Mem.performGC
14:21:26 <lambdabot> IO ()
14:21:34 <jak> Lemmih, thanks!
14:21:43 <ustenzel> joelr_: I thought, those combinators are so cool, one could simply put lift and sequ in a type class, and implement a generic version for algebraic datatypes.
14:21:49 <dscape> Wx works with variables (dunno how i didnt checked) and i need to use a state to store a [[Int]]
14:22:08 <joelr_> ustenzel: i was thinking of that
14:22:13 <ustenzel> joelr_: GHC didn't find that idea cool at all.  It complained about too complex types.  Sad, isn't it?
14:22:21 <joelr_> will be back in a couple of hours
14:22:35 <{Arias}> ahh
14:22:38 <dscape> if i used the a <- variable [ value = sampleList ] it world be easy
14:22:40 <{Arias}> my reponse is ... rare xD
14:22:54 <{Arias}> Respuesta CTCP TIME de sethk : Sat Oct 29 17:22:01
14:23:00 <{Arias}> Respuesta CTCP TIME de {Arias} : Son las 23:20:41 del 29/10/2005
14:23:02 <{Arias}> x)
14:23:11 <dscape> but i need to use a State to store
14:23:16 <dscape> like myState [[Int]]
14:23:48 <dscape> if i used a var i would get a 0 in the work
14:23:51 <{Arias}> maybe lambdabot dont understand my reponse
14:24:02 <fnord123> so im looking at these zip papers and im wondering what the drawbacks are.. im thinking that they must use a metric buttload of memory.
14:24:05 <jak> unfortunately it didn't run the socket finaliser, oh well ;(
14:24:10 <fnord123> any other drawbacks?
14:24:37 <Cale> fnord123: they ought not to
14:25:00 <Cale> since you'll be sharing all the subtrees in common with the original value
14:25:02 <Lemmih> jak: Closing the sockets is far more reliable.
14:25:20 <fnord123> oh really?
14:25:25 <Cale> basically, they cost O(depth-to-hole)
14:25:26 <fnord123> auto-masking. delicious
14:25:36 <dscape> is this like a haskell # or a hackers # ? :P
14:25:42 <jak> Lemmih, probably. I'm only asking for development purposes as I've coding up a UDP server and I interrupt it with C-c in ghci
14:26:00 <jak> but I can't reuse the address because the socket didn't close (because I interrupted it)
14:26:14 <dscape> well gtg .. thanks all.. ill sort things out for myself :) tks
14:26:15 <jak> Is there a way to catch the C-c before going back to ghci?
14:27:52 <fnord123> hm i cant find oleg's paper. anyone have it?
14:27:59 <jak> I tried catch (processPackets s) (\_ -> sClose s) but that doesn't seem to catch the C-c
14:28:15 <fnord123> it :: Url
14:31:17 <fnord123> ah,  I was googling zip rather than zipper. :)
14:36:27 * SamB wonders if joelr noticed that he (SamB) wrote and pasted an implementation of the mythical MaybeT
14:36:51 * SamB supposes he should have called it something other than "the mythical MaybeT"
14:37:32 * ustenzel wonders whether joelr noted the significance of the mythical MaybeT
14:42:57 <jak> Yeh, does anybody know what the most efficient way of converting a 4 byte string (of type String) into an integer, where the string is actually raw bytes (little endian) ?
14:43:06 <jak> s/Yeh/Hey/
14:43:19 <sethk> jak, look in Foreign
14:44:48 <ustenzel> jak: the obvious way (fromIntegral+shiftL+(.|.)) is efficient enough
14:44:57 <jak> right, thanks
14:45:47 <ustenzel> jak: maybe use unboxed primitives for the integer; but it shouldn't make a huge difference.
14:46:28 <jak> Data.Char.ord the right function to be using?
14:46:42 <{Arias}> strpos1 = TestCase ( assertEqual "strpos1" 3 ( strpos 'a' "hola" ) )
14:46:46 <{Arias}> why is '3' wrong?
14:47:41 <{Arias}> error: No instance for (Num (Int -> Int)) :S
14:49:50 <{Arias}> ahh
14:50:04 <{Arias}> strpos is char string int -> int :$ sorry
15:05:43 <marcot> dcoutts: just get the .diff.gz from http://packages.debian.org/libghc6-gtk-dev
15:06:34 <SamB> jak: its not like some lowlevel method is going to help you much, since the bytes aren't contiguous...
15:06:54 <SamB> (and in fact each is stored in a 32-bit word)
15:07:09 <dcoutts> marcot, thanks
15:08:07 <dcoutts> marcot, oh, it's not in the packge db yet
15:08:17 <marcot> dcoutts: hum...
15:08:24 <marcot> dcoutts: do you accept a dcc?
15:08:45 <heatsink> Is there a standard typeclass for things that can be written to a Handle?
15:08:55 <dcoutts> marcot, I would but my irc client seems buggy in that regard
15:09:05 <heatsink> ...like Java's Serializable
15:09:09 <marcot> dcoutts: by mail?
15:09:14 <dcoutts> marcot, yes please
15:09:33 <dcoutts> heatsink, Show ?
15:10:26 <marcot> dcoutts: sent.
15:10:32 <dcoutts> ta
15:10:43 <Lemmih> @type hPrint
15:10:44 <lambdabot> Not in scope: `hPrint'
15:10:49 <dcoutts> Lemmih, yeah I agree with out about the hcar thing
15:10:57 <dcoutts> I'll send it as is
15:11:05 <dcoutts> Lemmih, or you can do it!
15:11:14 <dcoutts> you wrote it, you take the credit
15:11:18 <Lemmih> oki!
15:12:20 <heatsink> I'd rather keep Show as the pretty-printing operation.  If there's not a suitable typeclass, I'll just make one.
15:13:25 <dcoutts> or are you looking for binary serialisation?
15:13:28 <heatsink> yes
15:13:33 <dcoutts> in which case there is a class for that
15:13:38 <heatsink> do tell
15:13:43 <dcoutts> not a standard one but there is a good library
15:14:20 <heatsink> This is really for talking between programs over sockets.
15:14:24 <dcoutts> I'm trying to remember if someone cabalised it
15:14:33 <heatsink> (becuase I got fed up trying to debug segfaults with FFI)
15:14:41 <dcoutts> it's the bianry serialisation framework that ghc uses
15:14:53 <Lemmih> @google NewBinary haskell
15:14:55 <lambdabot> http://www.mail-archive.com/haskell-cafe@haskell.org/msg09919.html
15:16:05 <dcoutts> http://hackage.haskell.org/ModHackage/Hackage.hs?action=info&pkg=NewBinary&pkgVersion=0%2e1
15:16:21 <dcoutts> it's cabalised and in hackage
15:16:27 <dcoutts> http://hackage.haskell.org/packages/NewBinary-0.1.tgz
15:16:37 <heatsink> thx
15:18:05 <ustenzel> dcoutts: NewBinary has a strange license.  What's up with that?
15:21:07 <dcoutts> yeah, we've been trying to track that down too
15:21:22 <dcoutts> we can distribte it in gentoo until it's sorted out
15:22:36 <Lemmih> s/can/can't/?
15:24:39 <sethk> would be weird if you can only distribute it until the license gets fixed
15:25:45 <ustenzel> That sucks.  It's not even clear if it may be distributed, let alone modified.
15:27:27 <dcoutts> err yeah, "can't" :-)
15:27:59 <heatsink> :)
15:28:04 <dcoutts> ustenzel, we talked to the people distributing it a while ago I can't really remeber the current situation
15:28:18 <dcoutts> I think they we're going to sort something out
15:28:33 <dcoutts> the thing was that the code had quite a long history
15:28:52 <dcoutts> I think it started with the nhc binary code then made its way into ghc
15:29:16 <ustenzel> the interface changed, too
15:33:48 <sethk> other than the code, the interface, and the license, everything is the same?  :)
15:34:01 <dcoutts> heh
15:37:34 <sethk> how do I interpret the following type?  CQLState' is a record type defined in CQL.State ...
15:37:42 <sethk> closeAllOpenFiles :: forall (m :: * -> *).
15:37:42 <sethk>                      (Control.Monad.State.MonadState CQL.State.CQLState' m,
15:37:42 <sethk>                       Control.Monad.Trans.MonadIO m) =>
15:37:42 <sethk>                      m ()
15:37:42 <sethk> P
15:37:57 <sethk> forget the P, my mouse went an extra line  :)
15:38:37 <sethk> the function is called within runStateT
15:38:49 <sethk> StateT wrapping IO
15:43:55 <ustenzel> sethk: "works in any monad that provides IO and state of type CQLState'"
15:44:39 <sethk> ustenzel, ok.  CQLState' is the type I've used for the State monad state, so that makes sense.
15:44:52 <sethk> ustenzel, and it wraps IO
15:45:04 <sethk> ustenzel, I'm still not fully clear on the types with the transformer monad
15:45:35 <sethk> using the same letter, m, for the two types confuses me
15:46:18 <ustenzel> sethk: the most simple monad that fits the bill is `StateT CQLState' IO'; more transformers can appear anywhere
15:46:47 <sethk> ustenzel, at the moment that's as complicated as  I get.  :)  That is in fact the type.
15:46:53 <ustenzel> sethk: no, there's only one m, only one monad is involved, but there are two constraints on this monad.
15:47:36 <sethk> ustenzel, yes, the StateT monad.  The text says it "encapsulates" the other monad (in this case IO).
15:48:00 <ustenzel> sethk: that's not *the* type.  you simply used liftIO and gets; the inferred type tells you that liftIO and gets have to be available.
15:48:37 <sethk> ustenzel, ah, that makes more sense, thanks
15:49:28 <sethk> ustenzel, because gets is in the class MonadState and liftIO is in the class MonadIO ?
15:49:40 <ustenzel> exactly.
15:54:23 <jak> off hand do any of you know how to print an Int as hex?
15:55:24 <Lemmih> @type Numeric.showHex
15:55:25 <lambdabot> forall a. (Integral a) => a -> ShowS
15:55:34 <jak> thanks Lemmih
16:06:54 <glguy> quick question... if I call length on a specific string twice, does memoization preserve the result? or does it recalculate each time?
16:07:10 <integral> what memoisation? :-)
16:07:18 <glguy> so no
16:07:43 <glguy> length longstring * length longstring has to calculate the length twice?
16:07:52 <glguy> for example?
16:07:53 <Igloo> It might get CSEd but you shouldn't rely on it
16:08:04 <integral> oh, maybe not.  let len = length longstring in len * len
16:08:16 <glguy> I'm aware how to optimize that simple example
16:08:22 <glguy> just illustratingwhat I meant
16:08:53 <glguy> so I should probably store my strings in a pair with their length if I use the lengths a lot?
16:08:55 <integral> well, it's exactly that: an optimization.   If you tried to do that all the time, I think you'd get massive space-leaks...
16:09:07 <integral> or use a FastString library?
16:09:49 <glguy> I was just writting up an app to demonstrate dynamic programming using the longest common string problem
16:09:55 <glguy> and by app, i mean function
16:11:30 <glguy> just considering good practices
16:21:35 <joelr_> SamB: so where's the runMaybeT? :-)
16:24:10 <shapr> ndm: pong/
16:31:24 <psi> yay, i wrote a haskell quine
16:32:30 <psi> show was the key, i think
16:48:38 <araujo> Hello Haskell'ers!
16:51:25 <psi> hi
16:52:19 <fnord123> hello araujo
16:54:03 <araujo> Hello fnord123 psi
16:54:07 <araujo> How you doing? :-)
16:54:10 <fnord123> im ok
16:54:31 <fnord123> trying to learn this haskell stuff through attempting to write programs. unsure if im getting anywhere :-/
16:54:45 <fnord123> \
16:55:12 <araujo> fnord123, Cool.
16:55:25 <araujo> fnord123, Do you already programm in other languages?
16:55:45 <sethk> fnord123, you are getting somewhere.
16:55:49 <fnord123> sure!
16:55:51 <sethk> fnord123, otherwise you wouldn't be here.
17:10:32 <sethk> this is really an amazing language.  I just made a change to an ADT and the corresponding changes to the code in maybe 15 minutes.  Would have been a days work in C++, easily.
17:10:57 <sethk> would have only been 10 minutes if I'd been more careful.  :)
17:13:27 <Cale> sethk: :)
17:13:35 <sethk> Cale, the type checker did all the work for me.
17:13:44 <Cale> yeah
17:14:08 <Cale> I basically can't live without static typing anymore :)
17:14:42 <sethk> in this case it isn't static that saved all the work, it is having constructors that take a different number of parameters as part of the same type
17:16:01 <sethk> but the type checker found any mistakes immediately
17:16:13 <yaarg> anyone use intellisense for emacs?
17:16:33 <sethk> Cale, and the first time it compiled, it ran
17:16:43 <Korollary> there's intellisense for emacs ?
17:17:09 <sethk> must be, but I didn't know that either
17:17:12 <yaarg> http://cedet.sourceforge.net/intellisense.shtml
17:17:25 <yaarg> i just come across it
17:17:30 <yaarg> so i don't know if it works :)
17:19:25 <sethk> yaarg, let us know.
17:19:38 <sethk> yaarg, although I'd put my time into eclipse, rather than there, if I were to put time in
17:21:03 <sethk> walking dog, BRB
17:21:30 <yaarg> yeah i like eclipse but having the feature in emcs would be good too
17:21:46 <yaarg> in any case doesn't look like it does auto completion for libraries which is what i really want
17:41:57 <joelr_> .
17:42:14 <joelr_> is it just me or is everyone sleeping?
17:42:21 <joelr_> hmm... must be a saturday night
17:43:17 <Cale> I'm not sleeping
17:43:37 <Cale> but I'm moving about, so not always at my machine
17:44:20 <joelr_> Cale: I got a monad question ;)
17:44:25 <Cale> waiting for my machine to upgrade 100 packages to install one :)
17:44:29 <Cale> sure
17:44:34 <joelr_> type UMonad = ListT (WriterT [String] (State P.FastString)) --unpickle
17:44:52 <joelr_> doU_Num :: forall a.(PU a, Bits a, Integral a) => UMonad a
17:44:52 <joelr_> doU_Num = do xs <- get
17:44:52 <joelr_>              guard (not $ P.null xs)
17:44:52 <joelr_>              let (ys, zs) = P.splitAt n xs
17:44:52 <joelr_>              put zs
17:44:54 <joelr_>              tell ["Something's cooking!"]
17:44:57 <Cale> okay
17:45:05 <joelr_> guard is fine, put is fine, get is fine
17:45:07 <joelr_> tell does not work
17:45:29 <joelr_>     No instance for (MonadWriter [[Char]]
17:45:29 <joelr_>                                  (ListT (WriterT [String] (State Data.FastPackedString.FastString))))
17:45:32 <joelr_>       arising from use of `tell' at ./Script/PU.hs:41:13-16
17:45:36 <Cale> tell is at the WriterT level, you have to lift it
17:45:40 <joelr_>     Probable fix:
17:45:40 <joelr_>       add an instance declaration for (MonadWriter [[Char]]
17:45:41 <joelr_>                                                    (ListT (WriterT [String] (State Data.FastPackedString.FastString))))
17:45:44 <joelr_>     In a 'do' expression: tell ["Something's cooking!"]
17:45:46 <joelr_> ok
17:45:49 <joelr_> lift it how?
17:45:54 <Cale> or write an instance of MonadWriter
17:46:02 <Cale> lift tell
17:46:12 <joelr_> that's all? interesting
17:46:19 <Cale> because there's a ListT outside that level
17:46:41 <joelr_> yes, but how come i don't need to do that to get to the fps inside the state?
17:46:47 <joelr_> get works fine w/o lifting
17:46:51 <Cale> that's the whole point of monad transformers -- making it easy to get at operations in the transformed monad
17:47:23 <Cale> perhaps there are instances which lift MonadState
17:47:32 <Cale> so that you don't need to
17:47:37 <joelr_> ok, understood now
17:47:38 <Cale> let me look
17:48:13 <Cale> you could just write an instance MonadWriter m => MonadWriter (ListT m)
17:49:06 <joelr_> Cale: ok, i'll look into it, this would work around the ListT
17:49:13 <Cale> also, you might want to look at the nice version of ListT which is on the wiki -- the version in the libraries is apparently somewhat broken
17:49:38 <Cale> (though the version on the wiki won't have many instances written for it yet)
17:49:41 <joelr_> actually, I lifted MaybeT from the Pugs sources, maybe i could use that
17:49:55 <sethk> joelr_, that's a different type of lifting  :)
17:50:13 <Cale> remember to wrap everything up at the end
17:50:14 <joelr_> sethk: :-)
17:50:28 <joelr_> Cale: what do you mean by that /wrapping it up/?
17:50:48 <Cale> Put the new monad in a module, don't export constructors -- export only the operations you really want to support
17:51:03 <Cale> along with the monad operations, of course
17:51:07 <joelr_> Cale: i'm using the ListT instead of MaybeT, btw. empty list = Nothing, that type of thing
17:51:20 <joelr_> Cale: right /wrap up/
17:52:36 <joelr_> how would i fix something like this?
17:52:36 <joelr_>     No instance for (MonadState Data.FastPackedString.FastString
17:52:37 <joelr_>                                 (MaybeT (State Data.FastPackedString.FastString)))
17:52:40 <joelr_>       arising from use of `get' at ./Script/PU.hs:37:19-21
17:52:43 <Cale> Monad transformers usually add a bit more functionality than actually needed -- arbitrary mutation of state, e.g.
17:52:52 <joelr_> i guess i need to make something an instance of MonadState, right? but what
17:53:13 <Cale> instance MonadState s m => MonadState s (MaybeT m)
17:53:29 <joelr_> Cale: no methods needed?
17:53:47 <Cale> oh, you need to write the methods :)
17:54:05 <Cale> my net connection is presently overworked :)
17:54:50 <joelr_> darn / write methods
17:54:56 <joelr_> @index MonadState
17:54:57 <lambdabot> Control.Monad.State, Control.Monad.RWS
17:55:20 <Cale> yeah, just implement get and put
17:55:28 <joelr_> doing
17:55:36 <joelr_> i guess i might do the writer while i'm at it
17:55:43 <Cale> get = lift get, most likely
17:56:02 <Cale> and put s = lift (put s)
17:56:19 <Cale> try that, and see if it does what you want :)
17:56:31 <joelr_> Cale: sure. what about writer? :)
17:57:02 <joelr_> @hoogle MonadWriter
17:57:02 <lambdabot> Control.Monad.Writer.MonadWriter :: (Monoid w, Monad m) => MonadWriter w
17:57:02 <lambdabot> m
17:57:12 <joelr_> hmm... not quite what i want
17:57:15 <Cale> tell looks easy
17:57:19 <Cale> hmm...
17:57:23 <joelr_> can lambdabot give  me the signatures?
17:57:34 <joelr_> for the methods of MonadWriter
17:58:02 <Cale> @type Control.Monad.Writer.tell
17:58:02 <Cale> @type Control.Monad.Writer.listen
17:58:02 <lambdabot> forall (m :: * -> *) w.
17:58:02 <lambdabot> (Control.Monad.Writer.MonadWriter w m) =>
17:58:02 <lambdabot> w -> m ()
17:58:04 <lambdabot> forall (m :: * -> *) w a.
17:58:04 <lambdabot> (Control.Monad.Writer.MonadWriter w m) =>
17:58:04 <lambdabot> m a -> m (a, w)
17:58:10 <Cale> @type Control.Monad.Writer.pass
17:58:10 <lambdabot> forall w (m :: * -> *) a.
17:58:10 <lambdabot> (Control.Monad.Writer.MonadWriter w m) =>
17:58:10 <lambdabot> m (a, w -> w) -> m a
17:58:13 <joelr_> aha
17:58:31 <joelr_> aren't these a case of lifting too?
17:59:19 <Cale> well, now you have an m in the argument type, so you might have to do more work
17:59:25 <joelr_> actually, tell is easy, right
17:59:37 <Cale> that's just lifting
18:00:00 <joelr_> so how do you work around the argument type?
18:00:03 <joelr_> conceptually
18:00:13 <joelr_> a monad cast?
18:00:36 <joelr_> maybe i can just look at how others do it
18:00:36 <Cale> well, you have to define what it does for each of the constructors of your outer monad
18:00:41 <joelr_> for list, etc.
18:00:51 <joelr_> ListT, etc
18:00:54 <Cale> listen NothingT = NothingT, most likely
18:01:02 <Cale> if that's what the constructor is called
18:01:04 <joelr_> no, wait, ListT does not do tell
18:01:20 <Cale> listen (JustT x) = JustT (listen x)
18:01:32 <Cale> I thought you changed to a MaybeT
18:01:36 <joelr_> yes
18:01:38 <joelr_> i did
18:01:51 <Cale> yeah, so it would look something like that.
18:02:08 <Cale> though I don't know what MaybeT looks like
18:02:13 <lisppaste2> joelr pasted "MaybeT from Pugs" at http://paste.lisp.org/display/13023
18:02:18 <joelr_> there
18:02:27 <joelr_> i read your mind cale
18:02:43 <Cale> let's see if I have any luck getting there :)
18:02:52 <Cale> I'm lagged 9 seconds, btw :)
18:03:06 <joelr_> there's no NothingT, though
18:03:14 <joelr_> just a MaybeT constructor
18:03:21 <Cale> ah, okay
18:03:52 <Cale> I'll take a look, give me a few minutes and my net connection will be free again. I should install a shaper :)
18:04:08 <joelr_> ok, thanks cale
18:04:47 <joelr_> i got a conceptual question
18:05:25 <Cale> ah, there we go :)
18:05:29 <joelr_> what?
18:05:39 <Cale> ah
18:05:39 <Cale> okay
18:05:54 <Cale> just looking at how it works
18:06:37 <SamB> joelr_: its right in the newtype
18:06:44 <SamB> (the runMaybeT)
18:07:09 <joelr_> SamB: oh, i missed that. did you see my paste, though? there's a MaybeT in Pugs also
18:07:15 <jak> Is there an easy way of grepping through all the standard library modules to find a particular function?
18:07:24 <jak> For example, I would like to find out what module the 'sleep' function is in?
18:07:38 <Cale> jak: "Index" at the top
18:07:51 <SamB> theres looks about the same as mine
18:07:51 <Cale> of every page
18:07:51 <Cale> or
18:07:55 <Cale> @index sleep
18:07:56 <lambdabot> System.Posix.Unistd, System.Posix
18:08:06 <jak> thanks!
18:08:19 <joelr_> Cale: the only constructor is a MaybeT
18:09:08 <SamB> oh, no, theres is inside-out of mine
18:09:20 <joelr_>     listen (MaybeT a) = listen a
18:09:23 <Cale> joelr_: right
18:09:23 <joelr_> no?
18:09:23 <SamB> or not.
18:09:28 <SamB> let me look at mine again
18:09:47 <Cale> yeah, that will work, if MaybeT is an exposed constructor
18:09:57 <SamB> oh, I forgot something very important
18:10:10 <Cale> er
18:10:12 <SamB> forgot to paste the newtype, silly me!
18:10:20 <Cale> listen = MaybeT . listen . runMaybeT
18:10:25 <Cale> ?
18:11:04 <lisppaste2> SamB annotated #13017 with "the missing MaybeT newtype" at http://paste.lisp.org/display/13017#5
18:11:18 <dons> morning
18:11:44 <SamB> hmm, okay, yes, mine seems about the same as the one in Pugs
18:12:22 <joelr_> that's wierd
18:12:35 <joelr_> i'm searching the ghc sources for instance MonadWriter and i cannot find any
18:13:06 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html -- there are plenty
18:13:10 <SamB> which supports my suspicion that much of the MTL is so "theres only one way to do it" that it cannot be protected by copyright
18:14:14 <Cale> Well, ListT is done the wrong way -- it apparently fails the monad laws
18:14:18 <SamB> well, their style is a bit better, and they have more instances
18:14:52 <SamB> Cale: hmm, dunno if what I have follows those or not...
18:15:13 <joelr_> Cale: i can't figure it out (writer for MaybeT) although i think i'm making progress
18:15:27 <joelr_> instance MonadWriter w m => MonadWriter w (MaybeT m) where
18:15:27 <joelr_>     tell w = lift $ tell w
18:15:27 <joelr_>     listen (MaybeT a) = listen a
18:15:38 <joelr_> this does not work, btw
18:16:03 <joelr_>     Couldn't match the rigid variable `m' against `MaybeT m'
18:16:03 <joelr_>       `m' is bound by the instance declaration at ./Script/MaybeT.hs:29:0
18:16:03 <joelr_>       Expected type: MaybeT m a
18:16:03 <joelr_>       Inferred type: m (Maybe a)
18:16:07 <Cale> http://www.haskell.org/hawiki/ListTDoneRight
18:16:26 <SamB> joelr_: you need a runMaybeT in that implementation, methinks...
18:16:34 <Cale> joelr_: does my suggestion work?
18:16:38 <Cale> listen = MaybeT . listen . runMaybeT
18:16:51 <joelr_> SamB: there's one... in the newtype signature ;)
18:17:02 <Cale> perhaps that needs a Just or some such
18:17:03 <joelr_> Cale: i missed that somehow
18:17:04 <SamB> joelr_: I think you need to call it
18:17:28 <Cale> pattern matching is the same as runMaybeT
18:17:43 <SamB> oh, let me think...
18:18:17 <joelr_> Cale: like this you mean
18:18:17 <joelr_>     listen m (MaybeT a) = MaybeT . listen . runMaybeT
18:18:38 <Cale> no
18:18:48 <Cale> I mean exactly like I wrote :)
18:19:20 <joelr_> hmm
18:19:27 <joelr_> partial evaluation
18:19:49 <joelr_>     Couldn't match `Maybe a' against `(Maybe a1, w)'
18:19:50 <joelr_>       Expected type: MaybeT m a1 -> m (Maybe a)
18:19:50 <joelr_>       Inferred type: MaybeT m a1 -> m (Maybe a1, w)
18:19:50 <joelr_>     In the expression: listen . runMaybeT
18:20:25 <Cale> ah
18:20:27 <Cale> right
18:21:13 <SamB> maybe you need EitherT?
18:21:27 <SamB> no idea what exactly EitherT is...
18:21:29 <joelr_> SamB: no, i'm fine with MaybeT i think
18:21:34 <Cale> no, just another function of type  (Maybe a, w) -> (Maybe (a,w))
18:22:04 <joelr_> Cale: to use in listen you mean
18:22:06 <Cale> lft (x,w) = do k <- x; return (k,w)
18:22:10 <Cale> after listen
18:22:11 <jak> @index threadSleep
18:22:12 <lambdabot> bzzt
18:22:17 <jak> ;(
18:22:28 <Cale> @index threadWait
18:22:28 <lambdabot> bzzt
18:22:30 <joelr_> lft or lift?
18:22:44 <Cale> lft
18:22:48 <Cale> any name
18:22:52 <dons> @index threadDelay
18:22:52 <lambdabot> GHC.Conc, Control.Concurrent
18:22:59 <Cale> yeah, that's it :)
18:23:01 <joelr_> Cale: no dots, no anything?
18:23:05 <jak> aha!
18:23:15 <Cale> joelr_: I just defined it
18:23:28 <dons> now, what would hoogle say:
18:23:32 <dons> @hoogle thread
18:23:33 <lambdabot> GHC.Conc.ThreadId :: ThreadId
18:23:33 <lambdabot> GHC.Conc.ThreadId :: ThreadId# -> ThreadId
18:23:33 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
18:23:42 <Cale> listen = MaybeT . lft . listen . runMaybeT where lft (x,w) = do k <- x; return (k,w)
18:23:43 <joelr_> i'm feeling dumb
18:23:47 <Cale> does that work?
18:23:50 <joelr_> let me try
18:24:05 <Cale> I'll grab the code and see what I can do if not
18:24:40 <joelr_> no dice
18:24:41 <joelr_>     Couldn't match `Maybe a' against `(a1, (Maybe a2, w))'
18:24:41 <joelr_>       Expected type: MaybeT ((,) (m a1)) a2 -> m (Maybe a)
18:24:41 <joelr_>       Inferred type: MaybeT ((,) (m a1)) a2 -> m (a1, (Maybe a2, w))
18:24:41 <joelr_>     In the expression: lft . (listen . runMaybeT)
18:24:44 <joelr_>     In the second argument of `(.)', namely `lft . (listen . runMaybeT)'
18:24:56 <Cale> ah, hmm
18:25:02 <Cale> okay, I'll try :)
18:25:22 <joelr_> thanks cale
18:26:35 <SamB> aren't Cale and me the ones who should be feeling dumb?
18:26:40 <Cale> heh
18:26:46 <Cale> yes
18:26:52 <Korollary> Cale shouldn't feel dumb, nor should you.
18:27:11 <SamB> Korollary: well joelr_ shouldn't be if we can't get it right
18:27:29 <SamB> I've got the same error with no clue why (and code that doesn't really look all that similar)
18:27:36 <joelr_> :-)
18:27:43 <Cale> listen :: MaybeT w m a -> MaybeT w m (a,w)
18:28:25 <Cale> er
18:28:38 <joelr_> in haskell greater than or equal is >=?
18:28:38 <Cale> listen :: MaybeT m a -> MaybeT m (a,w)
18:28:43 <Cale> yeah
18:29:01 <Cale> where MonadWriter w m
18:29:02 <SamB> @type Monad.Writer.listen
18:29:03 <lambdabot>   Failed to load interface for `Monad.Writer':
18:29:03 <lambdabot>    Could not find module `Monad.Writer':
18:29:12 <SamB> @type Control.Monad.Writer.listen
18:29:13 <lambdabot> forall (m :: * -> *) w a.
18:29:13 <lambdabot> (Control.Monad.Writer.MonadWriter w m) =>
18:29:13 <lambdabot> m a -> m (a, w)
18:29:28 <joelr_> Control.Monad.Writer?
18:29:46 <Cale> so in our case, listen :: (MonadWriter w m) => MaybeT m a -> MaybeT m (a,w)
18:29:58 <joelr_> i guess
18:30:02 <SamB> joelr_: are you suggesting the module name, or wondering why I have to give it in the @type command?
18:30:17 <joelr_> it was just reflex :)
18:30:30 <Cale> runMaybeT :: MaybeT m a -> m (Maybe a)
18:30:38 <Cale> which is something that we can apply listen to
18:30:45 <Cale> (the result of that)
18:30:49 <joelr_> hmm
18:30:59 <Cale> which gives m (Maybe a, w)
18:31:05 <joelr_> this whole monad thing is still a big of foreign science to me
18:31:07 <joelr_> but then again
18:31:22 <joelr_> all the cool people are taking it slow and i had to delve into monad transformers
18:31:39 <joelr_> but then again, why not get right to the cool stuff when you see where you can apply it ;)
18:31:45 <SamB> where are we supposed to be getting this "w" from?
18:31:58 <Cale> SamB: from the inner monad
18:32:05 <SamB> oh, right.
18:32:27 <Cale> so we need to get from m (Maybe a, w) to MaybeT m (a,w)
18:32:53 <Cale> MaybeT :: m (Maybe a) -> MaybeT m a
18:33:13 <Cale> ah, we needed an extra fmap
18:38:19 <Cale> okay, that works, shall I write pass?
18:38:19 <SamB> so how does this need to look?
18:38:27 <Cale>     listen m = MaybeT (liftM lft (listen (runMaybeT m)))
18:38:27 <Cale>             where lft :: (Maybe a, b) -> Maybe (a,b)
18:38:27 <Cale>                   lft (x,w) = do k <- x; return (k,w)
18:38:29 <joelr_> yeah!
18:38:31 <joelr_> go cale!
18:38:44 <joelr_> wow, that's a lot of stuff in there
18:38:53 <Cale> you can derive that from the types though
18:39:07 <Cale> there's actually only one way to write that
18:39:19 <Cale> (up to messing around with presentation)
18:40:12 <TheHunter> sometimes I wish there were a haskell editor with a proof-assistant-like interface.
18:40:23 <Cale> so let's see,  pass :: (MonadWriter w m) => MaybeT m (a, w -> w) -> MaybeT m a
18:40:29 <ndm> shapr, ping2
18:40:45 <jak> goodnight, thanks for your help
18:41:20 <Cale> runMaybeT gives us an  m (Maybe (a, w -> w))
18:45:43 <Cale> hmm, we'd be done if we had a function (m a -> m b) -> m (Maybe a) -> m (Maybe b)
18:46:17 <joelr_> :-)
18:46:40 <Cale> oh
18:46:44 <SamB>     pass (MaybeT p) = MaybeT (pass p)
18:46:44 <SamB>     Couldn't match `(Maybe a, w -> w)' against `Maybe (a, w1 -> w1)'
18:46:44 <SamB>       Expected type: m (Maybe a, w -> w)
18:46:44 <SamB>       Inferred type: m (Maybe (a, w1 -> w1))
18:46:59 <SamB>     In the first argument of `pass', namely `p'
18:47:19 <Cale> oh hey
18:47:27 <Cale> all that you need is lft from above
18:47:42 <SamB> yeah, that seemed so, but where to put it?
18:47:55 <Cale> after the pass
18:48:36 <Cale> ?
18:50:00 <Cale> oh
18:50:19 <Cale> or do you need the opposite, which would be kinda bad
18:50:24 <Cale> well, not that bad
18:52:23 <Cale> yes
18:52:34 <Cale>     pass (MaybeT p) = MaybeT (pass (liftM lft p))
18:52:34 <Cale>         where lft :: (Monoid b) => Maybe (a, b) -> (Maybe a,b)
18:52:34 <Cale>               lft k = case k of
18:52:34 <Cale>                         Just (x,w) -> (Just x, w)
18:52:34 <Cale>                         Nothing -> (Nothing, mempty)
18:53:16 <Cale> (that's a different lft)
18:54:25 <SamB> Cale: I can see that. for one thing, I already tried using the previous lft like that...
18:54:26 <Cale> it's moderately awkward because you have to create a value for the second component, but it's luckily possible since that component is a monoid value, and monoids all have an identity element
18:54:28 <SamB> several times!
18:54:57 <Cale> yeah, it struck me that the error message was saying the opposite thing :)
18:55:13 <SamB> sometimes its hard to tell
18:55:19 <Cale> yeah
18:55:27 <Cale> it doesn't really make it terribly clear
18:55:29 <SamB> it would be nice if it would notice when you double a type error like that...
18:55:38 <Cale> Expected and Inferred are sort of similar words
18:55:39 <SamB> but then it would need to keep state between attempts
18:56:01 <SamB> sometimes it even seems to do them backwards from eachother:
18:56:22 <sethk> expected is what should be there, inferred is what actually is
18:56:29 <sethk> from the perspective of the compiler
18:56:30 <SamB>       Expected type: t m a
18:56:30 <SamB>       Inferred type: t1 -> t2
18:56:30 <SamB>       Expected type: MaybeT m1 (a1, w -> w) -> MaybeT m1 a1
18:56:30 <SamB>       Inferred type: t m a
18:56:39 <SamB> doesn't that look a bit odd?
18:56:55 <SamB> thats from a kind error, though...
18:57:34 <sethk> SamB, probably means something dangerous about me, but that doesn't look odd to me anymore   :)
18:59:52 <SamB> well, I mean, I can imagine why it might do that, seeing as the rules are two-way...
19:01:34 <joelr_> looks like i stirred up something big. ouch
19:02:11 <sethk> joelr_, no, not really
19:02:24 <sethk> joelr_, compiler messages do tend to be cryptic IMHO at times
19:04:47 <sethk> lately ghci is telling me things like "can't find Test.hs"   (Test.hs is the file I supplied on the command line of ghci)
19:04:54 <sethk> on a :r
19:04:57 <joelr_> Cale: any luck?
19:11:12 <sethk> hm.  this is interesting.  I'm somehow closing ghci's handle to the file.
19:12:02 <Igloo> Does your code change the working directory?
19:12:10 <sethk> Igloo, yes
19:12:14 <sethk> Igloo, is that the problem?
19:12:21 <Igloo> I suspect so
19:12:34 <sethk> Igloo, must be, because I just printed out the handles of what I close, and I'm not.  :)
19:12:41 <sethk> Igloo, not closing ghci's file, that is.  :)
19:12:48 <Igloo> And a ghci bug to boot, IMO
19:12:56 <sethk> Igloo, I agree, definitely
19:13:09 <sethk> Igloo, I'm using the System.Directory function to change the current directory
19:13:14 <sethk> Igloo, ghci should pick that up
19:16:27 <SamB> hmm, I just suggested Haskell as a method of temporarily stopping ones mind, and the person I suggested it to is actually going to try it...
19:16:40 <sethk> SamB, stopping one's mind?
19:16:42 <Korollary> heh
19:16:46 <sethk> SamB, just remove the battery
19:16:56 <SamB> sethk: most of us don't have those
19:17:37 <joelr_> SamB: it works /stopping the mind/
19:17:43 <joelr_> SamB: at least when you are beginning
19:17:53 <SamB> joelr_: yeah, hence the suggestion ;-)
19:18:05 <joelr_> well, my mind is stopped right now :-) 2am gotta go recharge my batteries!
19:18:30 <joelr_> thank you very much ye kind folks
19:21:42 <SamB> @index list
19:21:43 <lambdabot> bzzt
19:25:29 <dons> list?
19:32:35 <sethk> @index List
19:32:36 <lambdabot> bzzt
19:32:51 <sethk> @index Control.Monad.List
19:32:51 <lambdabot> bzzt
19:38:23 <dons> the list monad?
19:38:33 <dons> the instances are in GHc.Base
19:38:55 <sethk> dons, lambdabot can't unravel those things?
19:39:15 <dons> @index doesn't search for types, does it?
19:39:15 <lambdabot> bzzt
19:39:36 <dons> it's a map from function names to modules
19:40:01 <sethk> dons, I think you are correct
19:40:16 <sethk> dons, also, you should know.  :)
19:40:27 <dons> @index >>=
19:40:27 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
19:40:27 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
19:40:27 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
19:40:41 <dons> another approach would bee to use hoogle
19:40:46 <dons> @hoogle List
19:40:46 <lambdabot> Network.listenOn :: PortID -> IO Socket
19:40:46 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
19:40:46 <lambdabot> Network.Socket.listen :: Socket -> Int -> IO ()
19:40:57 <dons> ah, but it's a bit too many matches
19:41:21 <dons> anyway, there's no List type. it's a [] type, right?
19:41:27 <dons> @index []
19:41:28 <lambdabot> bzzt
19:41:30 <dons> @index [a]
19:41:31 <lambdabot> bzzt
19:41:33 <dons> oh well
19:41:40 <dons> @hoogle []
19:41:41 <lambdabot> No matches found
19:41:46 <dons> @hoogle [a]
19:41:47 <lambdabot> Data.Map.keys :: Map k a -> [k]
19:41:47 <lambdabot> Prelude.repeat :: a -> [a]
19:41:47 <lambdabot> Data.List.tail :: [a] -> [a]
19:41:58 <dons> @hoogle [] a
19:41:58 <lambdabot> hoogle: Hoogle/MatchType.hs:76:8-45: Non-exhaustive patterns in function
19:41:58 <lambdabot> asBound
19:41:58 <lambdabot>  
19:42:07 <dons> ndm: ^^^
19:46:15 <sethk> I asked this before, but I forgot the answer.  What is the command to read in the data for a record type?  Written out with hPrint?
19:47:13 <dons> read combined with readFile?
19:47:21 <dons> @index hPrint
19:47:21 <lambdabot> System.IO
19:47:30 <sethk> dons, I can't do readfile, I have to get one entry at a time
19:47:41 <sethk> dons, but read combined with get line?
19:47:45 <sethk> dons, would that work?
19:48:04 <dons> hPrint is just :  hPutStrLn hdl . show
19:48:16 <sethk> right, so it's really the reverse of show that I need
19:48:36 <dons> so you want: read . hGetLine ?
19:49:09 <sethk> dons, I thought read was like print, implies stdin/stdout.  I guess I was wrong?
19:49:18 <dons> @type read
19:49:18 <lambdabot> forall a. (Read a) => String -> a
19:49:19 <dons> @type show
19:49:20 <lambdabot> forall a. (Show a) => a -> String
19:49:28 <sethk> ok.  got it.  :)
19:49:29 <dons> you still have to do your own IO somehow
19:50:52 <sethk> dons, right, that part I understand
19:51:17 <dons> so:
19:51:22 <dons> @type getLine
19:51:23 <lambdabot> IO String
19:51:31 <dons> @type getLine >>= return . read
19:51:31 <lambdabot> forall a. (Read a) => IO a
19:51:50 <dons> @pl getLine >>= return . read
19:51:50 <lambdabot> read `fmap` getLine
19:52:16 <dons> how much data are you expecting to read off the disk?
19:52:28 <dons> oh, you do it a line at a time though, right?
19:52:50 <sethk> dons, I'm not sure whether it will always be one line, because sometimes there is an associated block of data
19:52:53 <dons> oh, 1 *entry* at a time, not 1 line at a time. hmm.
19:52:55 <sethk> dons, either a line, or a line and a block
19:53:04 <dons> you need a parser!
19:53:08 <sethk> dons, probably.  I haven't finalized the way I'm writing.
19:53:27 <sethk> dons, I could parsec with a lexer, yes
19:53:33 <sethk> dons, and I may
19:53:40 <sethk> but I'll decide that for sure when I finalize the formats
19:53:41 <dons> well, you can probably mix getLine, and when you know you need a block, you read in some extra lines.
19:54:03 <sethk> dons, I was thinking of the put and get buf functions for blocks
19:55:38 <sethk> dons, but I'm modifying the transaction log format, so that's up in the air.  My C++ version isn't truly relational, but with infinite lists I can make the format with haskell truly relational, which should be more interesting
19:56:01 <sethk> of course I could do it in c++ to, but I didn't think the extra complexity was justified
19:56:06 <sethk> s/to/too/
19:56:25 <dons> exactly, and haskell's great for prototyping anyway
19:56:49 <sethk> dons, since this is a port, I'm considering the c++ version as the prototype
19:56:57 <sethk> dons, even though it is 15 years old.  :)
19:57:00 <dons> ah, ok :)
19:58:35 <sethk> One thing I'm noticing.  When you write in c++, nothing ever fits into the patterns in the books.  In Haskell I'm finding most things do fit into the patterns in the books and papers.
19:58:53 <sethk> dons, my class structure is an absolute mess
19:58:57 <sethk> dons, not because I didn't do it well
19:59:07 <dons> oh, that's an interesting point.
19:59:11 <sethk> dons, but because there is no way to map the real world into a one dimensional decomposition
19:59:24 <dons> you get at the underlying concpets in haskell
20:00:42 <sethk> dons, My actual data structures so far map very nicely into ADTs
20:01:16 <dons> I'd hpooe they would :) it would be surprising (very!) if you couldn't encode your types in terms of sums, products and rec types :)
20:07:24 <sethk> dons, If I call a function from the ghci command line, is that function executed in the IO monad?
20:08:19 <dons> yep.
20:08:40 <dons> which is why do-notations works in ghci at the prompt
20:10:01 <dons> oh, we just had ton from .mx
20:10:10 <dons> I should have hassled him to look at the @map
20:10:51 <sethk> dons, I have no idea what you just said
20:11:05 <sethk> dons, oh, that's a person  :)
20:24:44 <sethk> dons, In places where I had to add instance Show, I'll now have to add  instance Read  ?
20:25:23 <dons> hmm, only if you need to invoke read.
20:25:43 <dons> but you'll need to add instance read for types that you are going to read from, yeah.
20:26:35 <sethk> ok.  I have a data type which is an enumeration.
20:26:47 <sethk> I have, for example,  show BeginTransaction = "BeginTransaction"
20:26:59 <sethk> the inverse of that would be?
20:27:11 <sethk> can I pattern match on a string?
20:27:17 <dons> sure
20:27:32 <sethk> so I can say:   read "BeginTransaction" = BeginTransaction   ?
20:27:39 <dons> @eval let f "foo" = error "got foo" ; f _ = error "not a foo" in f "foo"
20:27:39 <lambdabot> Add a type signature
20:27:46 <dons> @eval let f "foo" = error "got foo" ; f _ = error "not a foo" in f "foo" :: ()
20:27:46 <lambdabot> got foo
20:28:12 <dons> remember that a string is just syntax for the data: 'x' : ... : []
20:28:21 <dons> which are normal constructors, just infix and with symbols
20:28:36 <dons> instead of: Cons 'x' (Cons ... (Cons Null)))
20:28:45 <sethk> I'm getting  'read' is not a (visible) method of class 'Read'
20:29:01 <dons> hmm
20:29:12 <dons> hello azuroth!
20:29:18 <sethk> must have done something wrong, let me look again
20:29:20 <dons> you learning haskell?
20:29:26 <azuroth> yeah, I am
20:29:32 <dons> at uni?
20:29:37 <dons> or on your own :)
20:29:47 <azuroth> reading "the craft of functional programming" by simon thompson, it seems pretty good
20:29:53 <azuroth> just on my own
20:29:57 <dons> cool :)
20:30:07 <dons> seems to be a lot of self-study haskell hackers around
20:30:10 <sethk> dons, is it ReadS?
20:30:20 <sethk> no...
20:30:27 <azuroth> I'm wondering what operator $ does?
20:30:41 <sethk> azuroth, f $ g h = f (g h)
20:30:46 <dons> oh, 'read' isn't in class Read
20:30:49 <sethk> f g h = (f g) h
20:30:52 <dons> read :: Read a => String -> a
20:30:54 <dons> read s = either error id (readEither s)
20:31:16 <sethk> but I have    read :: Read a => String -> a
20:31:20 <dons> azuroth, it's a convenient syntax for function application
20:31:27 <sethk> what am I missing?
20:31:32 <azuroth> hmm, okay
20:31:35 <dons> @eval sort $ "haskell"
20:31:36 <lambdabot> "aehklls"
20:31:39 <dons> @eval sort "haskell"
20:31:39 <lambdabot> "aehklls"
20:31:58 <dons> it has low syntax, so you can save on parenthesis in some expressions
20:32:04 <dons> low precendence
20:32:05 <dons> :/
20:32:20 <sethk> dons, I'm missing something, I didn't get the point of what you typed
20:32:21 <dons> @eval sort $ map (+2) [1..10]
20:32:22 <lambdabot> [3,4,5,6,7,8,9,10,11,12]
20:32:32 <azuroth> @eval 5 * $ 1 + 1
20:32:33 <lambdabot>  parse error on input `$'
20:32:53 <dons> @type (5 *)
20:33:14 <dons> @type (* 5)
20:33:16 <azuroth> @eval 5 $ (*) 1 + 1
20:33:18 <lambdabot>  add an instance declaration for (Num (a -> a))
20:33:28 <azuroth> err
20:33:36 <sethk> dons, I have:  show :: forall a. (Show a) => a -> String
20:33:42 <sethk> and read :: forall a. (Read a) => String -> a
20:33:47 <dons> @eval (5 *) $ 2
20:33:47 <lambdabot> 10
20:33:51 <sethk> dons, I don't see the difference
20:34:04 <araujo> mm.. sort
20:34:07 <araujo> @index sort
20:34:08 <lambdabot> Data.List
20:34:11 <dons> yeah, that's right. i don't know what your error is atm sethk
20:34:14 <araujo> Hi everybody!
20:34:24 <sethk> dons, oh, I thought you had told me something that I missed.  :)
20:34:26 <dons> morning araujo :)
20:34:38 <dons> @localtime araujo
20:34:40 <azuroth> thanks :D
20:36:37 <lambdabot> Local time for araujo is Sat Oct 29 23:36:03
20:38:08 <araujo> dons, Hello!
20:38:17 <araujo> dons, midnight here :-]
20:38:19 <sethk> dons, hm, the compiler is telling me that I've already derived Read, because I've implemented Show
20:38:21 <azuroth> @eval 1 + (5 *) $ 1 + 1
20:38:22 <lambdabot>  add an instance declaration for (Num (a -> a))
20:38:30 <azuroth> @eval 1 + ((5 *) $ 1 + 1)
20:38:32 <lambdabot> 11
20:39:03 <azuroth> @eval (1 + 5 *) $ 1 + 1
20:39:04 <lambdabot>   The operator `*' [infixl 7] of a section
20:39:04 <lambdabot>    must have lower precedence than the operand `(+)' [infixl 6]
20:39:04 <lambdabot>    in the section: `((1 + 5) *)'
20:39:24 * azuroth fires up hugs
20:39:48 <dons> you could also try ghc (the haskell compiler)
20:40:52 <azuroth> I like the interactive thingy
20:41:03 <azuroth> I've got ghc installed though
20:41:17 <dons> try ghci then
20:41:23 <dons> that's the interactive interface to ghc
20:41:32 <azuroth> oh, cool
20:41:39 <dons> it'll be installed, if you already have ghc
20:42:05 <azuroth> is the only difference to hugs that it's compiled first?
20:42:20 <dons> ghci interprets the code as well, but uses compiled libraries
20:42:36 <azuroth> ahh
20:42:37 <dons> ghc/ghci has a wider range of libraries, and has moore features
20:42:50 <azuroth> excellent
20:43:10 <dons> hugs is more portable though.
20:44:40 <dons> azuroth, you in sydney?~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~
20:44:46 <dons> sorry.
20:44:53 <dons> wireless went nuts during a rainstorm :/
20:45:07 <dons> you in sydney azuroth?
20:45:21 <dons> moomlyn, hi!
20:45:29 <dons> you guys should add your coords to @map
20:45:30 <dons> @map
20:45:30 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:45:31 <azuroth> no, I'm in newcastle-ish
20:45:47 <azuroth> you're in sydney?
20:45:48 <dons> because I know there's more .au haskell hackers than just the unsw people :)
20:45:50 <dons> yep
20:46:05 <sethk> dons, I don't quite know how, but apparently my implementing show resulted in my being able to derive Read
20:46:34 <azuroth> I don't know my lat/long :-p
20:47:26 <dons> azuroth, try google maps or maporama for your local town :)
20:47:30 <sethk> dons, this is really incredible.  I wish I knew how I did it.  :)
20:47:48 <dons> you didn't just derive (Show,Read) did you?
20:47:57 <dons> on the underlying data type?
20:48:01 <sethk> dons, I did instance for Show
20:48:07 <sethk> dons, then I was able to derive Read
20:48:38 <dons> you can derive Show and Read automagically anyway
20:48:52 <dons> the compiler will do it (though the format mightn't be what you want?)
20:48:53 <sethk> dons, well, I didn't know that.  :)
20:49:11 <sethk> dons, actually the format doesn't matter as long as it reads what it writes
20:49:37 <azuroth> hmm. I'm not allowed to edit the page
20:50:55 <dons> azuroth, you can log in by clicking 'UserPreferrenes' getting a name and paswd, and then refreshing
20:51:03 <dons> or you can msg me the coords and i'll add them :)
20:51:16 <autrijus> rehi :)
20:51:44 <dons> afternoon autrijus :)
20:51:50 <azuroth> hey autrijus
20:53:15 <autrijus> :)
20:53:25 <autrijus> I did the "Learning Haskell" talk thrice now
20:53:31 <autrijus> looking forward to the 4th
20:53:58 <azuroth> are there any videos up?
20:53:58 <dons> hehe
20:54:10 <dons> azuroth, you a pugs guy?
20:54:17 <autrijus> azuroth: no, I think I'll ask OSDC people into doing one
20:54:23 <autrijus> otherwise I can always webcam it
20:54:30 <autrijus> not a priority this moment though :)
20:54:48 <azuroth> not yet :-) hopefully soon though. I'm a parrot/tcl'er
20:55:08 <autrijus> Tcl++ # first high level language to target parrot For Real (tm)
20:55:20 <dons> oh, interesting.
20:57:44 <azuroth> dons: -32.725 , 151.561 I think
20:58:27 <dons> the image gets regenerated in about 5 minutes
20:58:34 <azuroth> excellent
21:08:13 <azuroth> dons: are you at uni?
21:09:16 <dons> yep
21:10:06 <azuroth> doing haskell? or just java etc?
21:10:21 <rep> hehe java
21:11:32 <azuroth> I thought it was pretty popular with unis
21:11:32 <dons> nono, I'm doing a phd investigating typesafe dynamic linking, and i use and teach haskell :)
21:11:39 <azuroth> ohh :D
21:11:57 <dons> we actually teach haskell as the first language to undergrads here at unsw
21:13:42 <azuroth> that's excellent
21:13:53 <azuroth> I'm at TAFE, and all we're doing is java and C++
21:14:46 <dons> cool
21:18:56 <araujo> Some examples of my tiny haskell shell: http://paste.lisp.org/display/13028
21:21:53 <azuroth> lines is like... list of strings from stdin?
21:22:32 <sethk> dons, can you help me with this?  This function works...
21:22:37 <sethk> readFromLog :: forall (m:: * -> *).(MonadState CQLState' m, MonadIO m) => m TransactionLogMessage
21:22:56 <sethk> dons, but I want it to return ().  When I remove the return of the TransactionLogMessage, I get an error about ambiguous types:
21:23:13 <sethk> Ambiguous type variable `a' in the constraints:
21:23:17 <dons> return () ?
21:23:25 <sethk>       `Show a' arising from use of `show' at ./CQL/TransactionLog.hs:71:75-78
21:23:32 <sethk>       `Read a' arising from use of `read' at ./CQL/TransactionLog.hs:69:36-39
21:23:38 <sethk> dons, I want to return nothing, in other words
21:23:48 <sethk> dons, and it is in a monad, so that would be return ()
21:23:57 <sethk>     Probable fix: add a type signature that fixes these type variable(s)
21:24:14 <sethk> I'm not sure how to change the signature to make the type not ambiguous
21:24:42 <sethk> the 'a' it is talking about is from StateT s m a
21:25:33 <dons> hmm, somewhere in there you need to add a type signature to fix the type of some var you're not using
21:25:44 <sethk> dons, right, but I'm not sure how.
21:25:54 <sethk> dons, its the return type.
21:26:15 <sethk> dons, the return type of the monadic computation, I think
21:27:55 <sethk> dons, let's back up a minute if we can
21:28:13 <sethk> dons, what's actually happening is that everything is working just fine, but I'm trying to catch the error that may occur
21:28:31 <sethk> dons, I'm reading the file until the end, so at some point hGetLine throws an exception
21:28:59 <sethk> dons, If I can convert this function to handle the exception, without changing the type, I'm ok for the moment.
21:29:02 <sethk> the function is:
21:29:08 <sethk> dumpOne = do readFromLog
21:29:13 <sethk>              dumpOne
21:29:16 <sethk>    
21:29:20 <sethk> that's it.
21:29:30 <sethk> hm, maybe I just catch the exception in the caller
21:31:29 <sethk> I'm doing something wrong, I think I need  liftIO
21:32:13 <sethk> let me think about this a bit more
21:46:43 <azuroth> @eval map (\(Int a) -> (5 *) a) [2, 1, 5]
21:46:44 <lambdabot>  Not in scope: data constructor `Int'
21:47:07 <azuroth> @eval map (\a -> (5 *) a) [2, 1, 5]
21:47:09 <lambdabot> [10,5,25]
21:47:22 <azuroth> @eval map (5 *) [2, 1, 5]
21:47:24 <lambdabot> [10,5,25]
21:47:32 <azuroth> hmm
21:48:12 <azuroth> ohh...
21:49:24 <azuroth> does the (Int a) one  try to make an Int out of the argument, and call it a?
21:50:01 <heatsink> it looks for the data constructor named Int, and doesn't find one
21:50:09 <heatsink> Int is a type, not a constructor...
21:50:29 <azuroth> ohh
21:50:38 <heatsink> I think you want (a :: Int)
21:50:56 <azuroth> I'm just reading this pugs documentation and trying to figure it out
21:51:09 <azuroth> it's actually using (VJunc s)
21:51:34 <azuroth> I guess VJunc is a ctor that returns a VJunct
21:52:01 <heatsink> It would make sense as a constructor.
21:52:11 <azuroth> is there a say, float constructor that takes an int?
21:52:12 <heatsink> @eval map (\(Just x) -> x) [Just 3, Just 5]
21:52:14 <lambdabot> [3,5]
21:52:38 <azuroth> @eval map (\(Just x) -> x) [3, 5]
21:52:39 <lambdabot>  add an instance declaration for (Num (Maybe a))
21:52:39 <lambdabot>   In the list element: 5
21:52:44 <azuroth> ;-p
21:52:58 <heatsink> the constructors for numbers are all hidden
21:53:06 <azuroth> ahh, ok
21:53:40 <azuroth> ohhhh. I think I get it now
21:54:06 <azuroth> @eval Just 5
21:54:07 <lambdabot> Just 5
21:55:14 <azuroth> I find it really crazy
21:55:33 <heatsink> how?
21:56:13 <azuroth> because it's like... "reverse constructing" it?
21:56:23 <heatsink> deconstructing
21:56:43 <azuroth> finding out what parameters it could have been constructed with?
21:57:29 <heatsink> finding out what parameters it was constructed with.
21:58:10 <heatsink> It works like a case statement.
21:59:30 <azuroth> what if you had two constructors that returned a say, int, one took two params and added them together, one took just one parameter
22:00:08 <heatsink> constructors don't do anything to their data
22:00:26 <azuroth> could you go... map (\(IntAdded x y) -> (x,y)) [NormInt 5, NormInt 2, IntAdded 2 3]
22:00:28 <azuroth> ohh, okay
22:00:48 <azuroth> I should just keep reading...
22:01:45 <heatsink> @eval map (\(Just x) -> x) [Just 3, Nothing]
22:01:46 <lambdabot>  Non-exhaustive patterns in lambda
22:01:46 <lambdabot>  
22:02:19 <SyntaxNinja> Igloo: around?
22:02:32 <azuroth> ahh
22:05:34 * araujo thinkin' about a shelltoolbar concept
22:51:22 <dons> @dynamic-reload plugs
22:51:22 <lambdabot> module reloaded
22:51:33 <dons> @eval map (\(Just x) -> x) [Just 3, Nothing]
22:51:34 <lambdabot>  Non-exhaustive patterns in lambda
22:51:35 <fworp> i know there probably isnt, but is there some compiler flag for ghc that just type-checks your code. Like, as long as some type can be deduced for a top level declaration, it doesnt care if its not defined?
22:51:51 <dons> use 'undefined'
22:52:03 <fworp> hmm, oh yeah
22:52:05 <dons> @eval let f = undefined ; g = "hello" in g
22:52:06 <fworp> cool
22:52:06 <lambdabot> "hello"
22:52:16 <dons> @eval undefined
22:52:17 <lambdabot> Add a type signature
22:52:22 <dons> another option is to use:
22:52:32 <dons> @eval let f = error "not defined" ; g = 1 in g
22:52:33 <lambdabot> 1
22:52:36 <dons> @eval let f = error "not defined" ; g = 1 in f
22:52:37 <lambdabot> Add a type signature
22:52:41 <dons> @eval let f = error "not defined" ; g = 1 in f :: ()0
22:52:41 <lambdabot>  Only unit numeric type pattern is valid
22:52:43 <dons> @eval let f = error "not defined" ; g = 1 in f :: ()
22:52:44 <lambdabot> not defined
22:52:52 <dons> @eval let f = error "not defined" ; g = 1 in f :: 1
22:52:52 <lambdabot>  add an instance declaration for (Show GHC.Base.Unit)
22:53:02 <dons> interesting msg.
22:53:13 <dons> @remember ghc Only unit numeric type pattern is valid
22:54:49 <fworp> 1 is a valid type?
22:55:20 <dons> yyeah, it's a funny syntactic feature almost noone knows about
22:55:31 <dons> @eval undefined :: 1
22:55:32 <lambdabot>  add an instance declaration for (Show GHC.Base.Unit)
22:56:07 <dons> @type undefind :: 1
22:56:20 <dons> @type undefined :: 1
22:56:20 <lambdabot> fd:10: hClose: resource vanished (Broken pipe)
22:56:26 <dons> @type undefined :: 1
22:56:31 <dons> @kind 1
22:56:48 <dons> hmm. lambdabot's being a bit funny
22:56:58 <dons> @bot
22:56:58 <lambdabot> :)
22:57:00 <dons> @kind 1
22:57:06 <dons> @kind Int
22:57:16 <dons> @type map
22:57:35 <dons> maybe I broke @type today
22:57:51 <dons> > :k 1
22:57:51 <dons> 1 :: *
22:58:26 <dons> @quit bad bot
22:58:32 <dons> @type map
22:58:34 <fworp> so 1 is synonymous with ()? whats the purpose of this feature?
22:58:51 <dons> type theoreticians often use the '1' notation for unit
22:58:55 <fworp> oh
22:59:00 <dons> so I guess the ghc guys thought this would be nice
22:59:08 <dons> it's not haskell, it's a ghc extension
22:59:08 <fworp> how thoughtful :P
22:59:21 <azuroth> ahh
23:08:07 <Cale> heh, too bad there's no data constructors
23:08:55 <dons> well, there's GHC.Base.Unit
23:09:01 <dons> but there's no Show
23:11:00 <dons> @dynamic-reload type
23:11:00 <lambdabot> module reloaded
23:11:02 <dons> @type map
23:11:08 <Cale> ah
23:11:19 <Cale> odd
23:11:20 <dons> bad bot. /me tries again.
23:11:44 <dons> sometimes I wonder if ghc 6.5 is the right choice ;)
23:13:57 <dons> @quit reset yourself!
23:14:11 <dons> @type map
23:14:23 <dons> sigh
23:14:31 <Cale> @yow
23:14:31 <lambdabot> Couldn't find fortune file
23:14:47 <dons> everything else is working. i refactored 1 line of @type today
23:15:00 <Cale> well, @yow isn't :)
23:15:11 <dons> oh. hmm.
23:15:13 <dons> actually, that should work.
23:15:31 <Cale> apparently the fortunes aren't installed
23:15:41 <dons> ah, my fault. i reset the path
23:16:26 <dons> ah, and the same issue is why @type is dead, me things..
23:16:28 <dons> thinks.
23:17:24 <dons> @quit take that!
23:17:30 <dons> @type map
23:17:32 <dons> @yow
23:17:41 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
23:17:45 <lambdabot> Couldn't find fortune file
23:20:55 <dons> @quit again..
23:20:59 <dons> @yow
23:21:08 <arcatan> @yawn
23:21:10 <lambdabot> My Aunt MAUREEN was a military advisor to IKE & TINA TURNER!!
23:21:18 <lambdabot> Maybe you meant: wn yow
23:21:21 <dons> @type 1
23:21:21 <lambdabot> forall t. (Num t) => t
23:21:25 <dons> @kind 1
23:21:25 <lambdabot> *
23:21:27 <dons> hehe
23:27:38 <SyntaxNinja> I think that if I were rich the one luxury I'd really be interested in is a secretary.
23:28:39 <dons> i'd like someone to clean my house :)
23:37:13 <Khisanth> dons: don't even need to be rich to do that!
23:37:53 <JKnecht> in India.
23:38:33 <Khisanth> no clue about India :)
23:41:20 <Oejet> Gooood morning Haskell!
23:44:03 <pesco> Good Morning, Oejet.
23:44:13 <pesco> And good morning, #haskell.
23:44:47 <pesco> Oejet: You are in a good mood this morning? What are you up to?
23:46:36 <Oejet> pesco: I'm writing a physics report.  Not in itself a fun thing, but I've solved the movement equations analytically, which the teacher said couldn't be done.
23:47:15 <pesco> Oejet: Oh! That's good. Are you sure your solution is correct?
23:47:45 <Oejet> pesco: Hehe, no.  That's why I'm writing it down, so my peer can review it. ;-)
23:48:25 <pesco> :) I see. Well, my wishes you didn't make a mistake!
23:48:28 <Oejet> Though, the formula is really simple, almost beautiful.
23:48:49 <pesco> What kind of movement?
23:50:01 <Oejet> A skiier down a straight slope.  Forces: Gravity, normal, snow friction and drag forces.
23:50:45 <Oejet> The problem is the model of the drag: F = Dv^2.  The model F = kv is easier.
23:51:26 <pesco> What's drag?
23:51:39 <Oejet> Air resistance.
23:51:43 <pesco> Ah, okay.
23:54:04 <pesco> Well, I have to practice some Lojban vocabulary. See you later
23:54:26 <Oejet> I get this beautiful formula: x(t) = C ln(cosh(Kt)) + v_0t.
23:54:30 <Oejet> pesco: See you.
23:55:43 <pesco> That is indeed a nice formular.
23:56:09 <pesco> formula, mind. ;) (Formular = german for form)
23:57:30 <pesco> But I see you're in dk, so maybe you know? Which part of Denmark are you from?
23:58:15 <Oejet> pesco: The thing is that Maple really gave an unproductive answer to a partial integration.  I think that's were many people give up.
23:58:30 <pesco> Ah, very possible.
23:58:53 <Oejet> pesco: I should know it with my 5 years of German. :-/
23:59:06 <pesco> Ah, in school?
23:59:12 <Oejet> Yep.
23:59:40 <Oejet> That's nontechnical German, though.
23:59:44 <pesco> The German empire, still got it's tentacles in poor ole Denmak. ;-)
