00:34:52 <xerox> 'morning
00:35:59 <autrijus> yo
00:36:55 <ValarQ> mornin xerox
01:05:14 <xerox> We do really want unicode-aware GHC, woot.
01:05:22 <xerox> pugs 'zip' looks like a zipper!  hah.
01:05:26 <xerox> pugs> ("A","B","C") Â¥ (1,2,3)
01:05:26 <xerox> ("A", 1, "B", 2, "C", 3)
01:16:23 <Khisanth> xerox: it's nice until you consider how many keys it takes to type Â¥ :)
01:17:18 <resiak> Khisanth: You could just set up a vim digraph y= or something... then it's the same number of keystokes as zip and looks neater
01:17:34 <resiak> and breaks for all the non-UTF-8 luddites! \o/
01:17:51 <autrijus> \o/
01:18:04 <autrijus> ^KYe is the digraph
01:18:18 <Khisanth> ctrl+k?
01:18:19 <resiak> Cunning.
01:18:27 * resiak hurts vim for not having a â€¦ digraph by default
01:18:48 <Khisanth> yada operator?
01:20:59 <ricebowl> Khisanth - which character is 'Â¥'? Is that n with tilde or a with ring?
01:21:02 * ricebowl has seen that before
01:22:02 <Khisanth> ricebowl: yen sign
01:23:10 <ricebowl> ah
01:23:21 <ricebowl> weird, just looks similar to one of the other two then
01:23:54 <ricebowl> @type (1,2)
01:23:58 <lambdabot> forall a b. (Num a, Num b) => (a, b)
01:24:12 <ricebowl> hmm...
01:24:24 <ricebowl> @type >>=
01:24:25 <lambdabot> bzzt
01:29:22 <bourbaki> moin
01:30:19 <Khisanth> ricebowl: a Y with an = sign through the middle doesn't really look like an n with a tilde or a with a ring :P
01:31:19 <xerox> Khisanth, ricebowl, autrijus: I do it with AltGr+shift+Y !
01:31:45 <Khisanth> c-s-a5 :)
01:31:58 <xerox> I still wonder how to input the other cool unicode chars, is there a standard way?
01:32:07 * ricebowl lacks Alt+Gr
01:32:15 <xerox> I did try all the combination with letters and metakeys, but it's just a limited set of chars.
01:32:22 <xerox> glyphs, even.
01:32:25 <ricebowl> Khisanth - well this client does not support UTF-8
01:32:58 <Khisanth> xerox: gtk apps have have ctrl+shift+hex
01:33:42 <ricebowl> question -- in the list monad, what exactly does it contain?
01:38:14 <xerox> ricebowl: get one it does, my gosh, we are in 2005! :)
01:38:15 <ricebowl> well I don't type Chinese, and all the Russians end up using Latin or KOI8-R or the Windows codepage anyway... :p
01:38:15 <xerox> Khisanth: do you know some useful hexes, or some page to look them up?
01:38:15 <xerox> Also, I hoped terminus had more unicode chars, hmpf :-\
01:38:15 <ricebowl> KOI8-R doesn't play nice with anything else :|
01:38:26 <Khisanth> ricebowl: which client are you using?
01:38:26 <xerox> What kind of keyboard do you have?
01:38:51 <Khisanth> xerox: I just use A5, AB, BB mostly
01:40:29 <xerox> Ah, cool.
01:40:35 <xerox> Emacs doesn't do it :-|
01:41:14 * ricebowl is using mIRC
01:41:23 <xerox> mIRC is not utf-8 aware :-(
01:41:31 <xerox> Grab xchat? :)
01:41:38 <ricebowl> tried it
01:41:46 <ricebowl> didn't really like it on Windows; maybe it's better on Linux
01:41:55 <xerox> I'm using Circe version from CVS (2005-10-19 17:14:33) with GNU Emacs 22.0.50.1 (of 2005-09-24)
01:41:58 <ricebowl> nor HydraIRC
01:42:08 <xerox> <blink>
01:42:13 <ricebowl> hm?
01:43:33 <xerox> I'll show you :-)
01:44:03 <eivuokko> It is hard to keep faith with ghc when building windows dlls :-S
01:44:14 <Khisanth> xerox: we were talking about that the other day, emacs has M-x insert-ucs :)
01:45:29 <xerox> ricebowl: http://haskell.galois.com/~paolo/circe-1044-231005.png
01:45:40 <xerox> Khisanth: ooh!
01:46:58 * xerox goes hunting for ucs fonts and modes
01:51:52 <ricebowl> xerox - bizarre
01:52:22 <xerox> What? :-)
01:52:42 <xerox> I find it very, very handy :_)
01:54:09 <Khisanth> Circe is an IRC client in emacs?
01:54:15 <xerox> Exactly.
01:54:55 <xerox> It's written by a long time ERC user (Emarcs iRc Client), whom started it from scratch with the 'sane defaults' policy in mind.
01:55:10 <xerox> (...unlike ERC, I'd say ;-))
02:01:26 <ricebowl> xerox - I just don't understand why you want to embed it in your editor... :p
02:01:28 <ricebowl> but ok
02:01:53 <MarcWeber> Does ghc-pkg -u do the same as ghc-pkg -register?
02:02:29 <xerox> ricebowl: to do everything without switching windows
02:02:48 <xerox> ricebowl: also, it has many configuration capabilities I miss in other clients.
02:03:03 <ricebowl> *nods*
02:04:01 <ricebowl> hm, what's wrong with this? http://www.rafb.net/paste/results/l84N6L58.html
02:05:02 <xerox> What do you want to do?
02:05:45 <ricebowl> create a function that takes a string as input and produces an IO () as output
02:06:12 <ricebowl> actually, to be honest, I'm not sure what I want to do. Amongst the list would be finishing this Haskell assignment.
02:06:13 <xerox> let baz x y = bar $ foo x y
02:06:27 <ricebowl> why doesn't . work?
02:06:39 <xerox> I think it's more  (.) . (.)  -- :)
02:06:50 <xerox> @pl \x y -> f (g x y)
02:06:51 <lambdabot> (f .) . g
02:06:55 <xerox> Yep.
02:08:03 <ricebowl> @type .
02:08:04 <lambdabot> bzzt
02:08:08 <ricebowl> er
02:08:15 <ricebowl> how do I get him to give me the type of the function? :p
02:08:38 <ricebowl> IIRC it's something like F a -> F b -> (a -> b)
02:09:23 <xerox> @type (.)
02:09:25 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
02:09:46 <xerox> (f . g) x = f (g x)
02:11:03 <ricebowl> yes, I know how it works, that's why I'm confused :S
02:11:27 <ricebowl> hm, this is a problem because of currying?
02:11:39 <basti_> hmm is it right that all (haskell) types are either a) a sum of other types b) a product of other types c) a function of other types?
02:11:41 <ricebowl> I don't see why
02:12:21 <basti_> ricebowl: operators are infix. to override this in the parser (to keep the parser from erring) you need to write prefix operators in parenthenses
02:12:37 <ricebowl> I know
02:12:47 <ricebowl> but that's not the problem
02:13:20 <basti_> not?
02:13:21 <basti_> ^^
02:13:40 <ricebowl> basti_ - I have bar . foo
02:13:46 <basti_> yes.
02:13:51 <basti_> thats . written "infix"
02:14:04 <ricebowl> I know
02:14:11 <ricebowl> bar :: a -> IO ()
02:14:15 <ricebowl> foo :: b -> c -> a
02:14:22 <basti_> ah
02:14:34 <ricebowl> so (bar . foo) :: b -> c -> IO ()
02:14:41 <ricebowl> but apparently I am wrong, and I don't know why
02:15:42 <ricebowl> what xerox said to do does work
02:15:45 <dons> basti_, a function of other types?
02:15:45 <ricebowl> (bar .) . foo
02:15:52 <ricebowl> but...why?
02:16:03 <basti_> hmm because of two parameters only the first is "."ed
02:16:21 <basti_> dons: like data Fun a = Fun Woozle -> a
02:16:48 <dons> hmm, I don't understand the -> you use there
02:17:09 <basti_> "Fun a = Fun (Woozle -> a)"
02:17:12 <dons> in gener not just haskell, you have just sums, products and recursive types
02:17:26 <basti_> isnt that possible?
02:17:30 <xerox> Okay.
02:17:34 <xerox> @type  (\x -> (undefined :: a -> IO a) x) . (\x y -> (undefined :: a -> b -> c) x y)
02:17:35 <lambdabot> forall a b c. a -> IO (b -> c)
02:17:40 <xerox> :-)
02:17:54 <xerox> (yeah, it can be eta-reduced)
02:18:01 <dons> functions are just another type constructor though. they're not special
02:18:04 <xerox> (but it's a nice example, isn't it? :-))
02:18:09 <basti_> dons: hmm
02:18:19 <xerox> ricebowl: do you see what type does it get?
02:18:49 <xerox> ricebowl: the first undefined is bar, the second is foo.
02:18:55 <basti_> dons: but -> has a certain semantics that could make it interesting for me ^^
02:19:05 <dons> ok :)
02:19:32 <basti_> dons: fyi, I'm toying around with deriving types in coq
02:19:35 <dons> it's not treated specially when teaching about the different types. you just teach sums, products and rec types, and that's all you need
02:19:48 <dons> but, say in coq, youu want to have a special ->
02:19:56 <xerox> @wtf coq
02:19:58 <lambdabot> No match for "coq".
02:20:06 <dons> we have 'wtf'??
02:20:18 <basti_> a->b is "exponential"... like b^a, isnt it?
02:20:26 <xerox> @wtf wtf
02:20:27 <lambdabot> No match for "wtf".
02:20:36 <xerox> @wtf monad
02:20:38 <lambdabot> *** "monad" wn "WordNet (r) 2.0"
02:20:38 <lambdabot> monad
02:20:38 <lambdabot>   n 1: an atom having a valence of one
02:20:38 <lambdabot>   2: a singular metaphysical entity from which material
02:20:38 <lambdabot>    properties are said to derive [syn: {monas}]
02:20:40 <lambdabot>   [also: {monades} (pl)]
02:20:40 <basti_> xerox: coq is a proofchecker
02:20:42 <xerox> Yes we do.
02:20:53 <basti_> a very good one too
02:20:59 <dons> hmm. i've never thought of it like that basti_, and not heard of such a view of ->
02:21:08 <basti_> hmm i think like that:
02:21:39 <ricebowl> xerox - how do you say that they aren't defined? They are, I simply chose not to give the definitions because it isn't necessary and they're quite long :p
02:21:44 <basti_> a function a->{0,1} is an element of 2^a (for every element in a, you got two choices)
02:21:44 <dons> but isn't the type (->) a b  just Danother product basically? with special semantics perhaps
02:21:47 <ricebowl> so I gave the types
02:21:53 <ricebowl> but anyway, this is enough for tonight
02:21:56 <ricebowl> I'm sleepy
02:22:00 <xerox> ricebowl: undefined :: type is a way to use the type checker without writing actual definitions.
02:22:11 <ricebowl> *nods*
02:22:23 <ricebowl> ok
02:22:24 <basti_> hmm for a product of a and b you'd need morphisms to a and b from the product
02:22:29 <xerox> @type let bar = undefined; foo = undefined in bar . foo
02:22:30 <lambdabot> forall c a. a -> c
02:22:35 <xerox> Ops.
02:22:49 <xerox> @type let bar = undefined :: a -> IO a; foo = undefined :: a -> b -> c in bar . foo
02:22:51 <lambdabot> a -> IO a; foo = undefined :: a -> b -> c in bar . foo :: forall a b
02:22:51 <lambdabot> c. a -> IO (b -> c)
02:22:57 <xerox> There you go.
02:24:17 <dons> ok, I agree, we have sums, products, rec types and arrow.
02:24:37 <dons> you can check sums products and arrow in basically the same way, but they each have special static and dynamic semantics
02:24:48 <basti_> hmm
02:25:16 <basti_> i'm not about checking anyway ^^
02:25:39 <dons> anyway, in any implementation arrow is special
02:25:55 <dons> not just another TyCon even.
02:26:04 <basti_> TyCon?
02:26:23 <dons> type constructor
02:26:42 <basti_> ahh
02:26:51 <basti_> yes, i regard + and * as "special" too
02:27:02 <basti_> (I'm reasoning about them so i need to introspect them)
02:27:18 <basti_> whats bothering me is that I apparently can't do extensionality in coq.
02:30:40 <tessier> Why is the haskell channel so much bigger than the scheme channel but scheme seems to be more popular than haskell elsewhere?
02:30:49 <tessier> I've seen scheme books but never a haskell book (although I know they exist).
02:30:59 <basti_> haskell is pretty new
02:31:01 <tessier> Some colleges even teach scheme as a first language but I haven't seen haskell used in that way.
02:31:20 <tessier> Why are there 170 people in here and 70 people in #scheme if haskell is newer?
02:31:23 <ndm> tessier: yeah, i learnt scheme as my first uni language
02:31:26 * resiak 's college teaches Haskell as a first language.
02:31:35 <basti_> because IRC is quicker than books
02:32:20 <tessier> It is also encouraging that there are people in here at 2am to answer my newbie questions.
02:32:31 <basti_> 2am? it's 11 am for me ^^
02:32:40 <dons> I learnt haskell as my first language :)
02:32:49 <dons> 11am? it's 7pm!
02:32:56 <tessier> dons: And how are you doing with it? What book did you use?
02:33:08 <xerox> 11am you mean :)
02:33:20 * dons looks across at bookshelf.
02:33:22 * cjb is moving to the States for good today la la.
02:33:28 <dons> Haskell, The Craft of Functional Programming
02:33:39 * tessier adds that to his Amazon wish list
02:33:43 <xerox> I used #haskell :-)
02:33:47 <dons> pretty good for a beginner, i'd say. but that was a while ago
02:33:55 <tessier> xerox: I bet everyone here hated you for a while. :)
02:34:04 <xerox> tessier: you're wrong!  Happily :)
02:34:12 <dons> no no, we encourage newbies :)
02:34:21 <dons> tessier, have you been on the #haskell tour yet?
02:34:23 <tessier> dons: That's good.
02:34:27 <tessier> dons: No, not yet. :)
02:34:30 <xerox> Yeah, now I happen to be useful to people, which is a good return for the community.
02:34:53 <tessier> I seriously need to get my ass in gear and turn out some code before I go broke.
02:34:54 <dons> first, then, you should meet lambdabot, the world-famous haskell bot
02:34:55 * xerox is fascinated of the pugs side, nowadays, though ;-)))
02:34:56 <dons> @bot
02:34:57 <lambdabot> :)
02:35:04 <dons> @eval 1 + 2
02:35:06 <lambdabot> 3
02:35:16 <dons> @eval map (\x -> (x,x)) [1..10]
02:35:18 <lambdabot> [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
02:35:37 <xerox> @eval let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 15 fibs
02:35:39 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
02:35:40 <tessier> I'm discussing the many implementations of scheme over in #scheme. Are there many different implementations of haskell also or is there one that everyone has focused on?
02:35:43 <dons> @pl map (\x -> (x,x)) [1..10]
02:35:44 <lambdabot> map (join (,)) [1..10]
02:35:49 <dons> @type map
02:35:50 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
02:36:08 <basti_> tessier: most of the work is done in ghc, but there's a few other compilers too
02:36:08 <dons> tessier, ndm doesn't like me saying this, but ghc is the way to go
02:36:25 <dons> hugs is also very portable and easy to get going
02:36:26 <ndm> tessier, windows or linux?
02:36:35 <tessier> dons: Does ndm have his own implementation or something? :)
02:36:40 <tessier> ndm: Linux of course.
02:36:40 <xerox> It is the de-facto standard, it produces the fastest code (I think) and it has many nifty extensions.
02:37:01 <ndm> tessier, kind of 2 which i'm involved in
02:37:08 <tessier> If I were using Windows my first question in here tonight would have been "Can I ask a question?"
02:37:08 <tessier> :)
02:37:30 <dons> tessier, also /topic points to logs of the channel
02:37:37 <dons> then we also have a wiki with lots of stuff
02:37:38 <dons> @hawiki
02:37:39 <lambdabot> http://www.haskell.org/hawiki/
02:37:42 <tessier> Wiki's rock.
02:37:48 <tessier> I've seen the wiki. Lots of great stuff.
02:37:56 <Khisanth> unless you want to browse
02:38:17 <xerox> Khisanth: the title/content search works quite well, doesn't it?
02:38:22 <tessier> I browse wiki's all the time. Especially wikipedia.
02:38:30 <tessier> Wikipedia has tons of functional programming info it it.
02:38:41 <Khisanth> xerox: that implies a goal :)
02:38:59 * xerox Â¥-es Khisanth with an infinite list
02:39:02 <Khisanth> xerox: I mean something like walking into a book store
02:39:21 <Khisanth> xerox: lucky for you I am lazy!
02:39:32 <xerox> That's like asking questions here, people usually can point you to interesting spots.
02:39:44 <xerox> Khisanth: it makes my pugs loop, but anyway..
02:39:46 <eivuokko> Is there an option for ghc to not put stub-files generated from foreign export besides the sourcemodule?  Ie to put them on some intermediate build directory.
02:40:12 <dons> eivuokko, good question! hmm.
02:40:15 <eivuokko> I just can't get ghc to do what I want.
02:40:22 <Khisanth> xerox: I thought someone said pugs can run infinite loops in constant time?!
02:40:27 <dons> what about -odir ?
02:40:36 <xerox> Khisanth: try it: (0) Â¥ 0...
02:40:39 <eivuokko> Doesn't work for me, dons :-(
02:40:42 <xerox> Khisanth: I got the pun, though :-P
02:41:12 <eivuokko> dons, none of the obvious, -o, -odir, -ohi seem to matter.
02:41:16 <Khisanth> hmm can't try now would take an hour for me to build pugs
02:41:28 <xerox> An hour ?!
02:41:39 <Khisanth> something like that
02:41:45 <xerox> Let's go to perl6 anyway, I have a little question
02:41:54 <Khisanth> it also involves a lot of disk grinding
02:45:06 * tessier ponders what classes of problems are especially suitable to a functional language as opposed to an imperative language
02:46:49 <dons> all classes :)
02:47:26 <dons> you can do you imperative programming in haskell quite easily (see the IO monad)
02:48:05 <dons> plus you retain the benefits of static typing, much cleaner, simpler and more powerful semantics
02:48:11 <tessier> A monad is a way to interface the purely functional world of haskell with the non-functional outside world (where calling read on a file will not always return the same thing given the same inputs) right?
02:48:34 <Khisanth> ah tonight is just full of puns
02:49:04 <tic> tessier, not quite. the IO monad is like that, however.
02:49:13 <tessier> hmm
02:49:20 <tic> I just think of it as a box with a pre-defined track you can place your instructions on.
02:49:36 <dons> a way to specify sequential actions, perhaps
02:49:37 <tic> and then run them in sequence (I think >>, >>= enforce this.)
02:50:33 <xerox> Where 'action' = side-effective function, in some way.
02:51:13 <dons> so really, you should be wondering which problems require an imperative style, and then just use haskell anyway :)
02:51:53 <tic> the poor thing about Haskell compared to my language of choice, Python, is the standard library.
02:52:05 <xerox> Hmpf.
02:52:06 <tic> other than that, you can write imperative code just as nicely in Haskell as any other one.
02:52:50 <dons> nicer in fact, as you get all the other haskell features in the imperative code too :)
02:53:07 <dons> spj sez: the world's finest imperative language
02:53:07 <tic> yup
02:53:19 <tic> Mhm, that's what I was loosely basing my statement on.
02:57:05 <MarcWeber> Is the package.conf file all you have to make to create your own package?
02:59:03 <xerox> I think the cabal way is the Right One.
02:59:05 <Lemmih> MarcWeber: You probably want to use Cabal instead.
02:59:59 <basti_> what are the rules that govern quotient types?
03:01:28 <eivuokko> I give up...let ghc put all the damn files besides the source..
03:03:36 <xerox> eivuokko: I'd suggest to mail some GHC guru
03:03:45 <xerox> ...or ask in the GHC mailing list?
03:05:08 <eivuokko> Yeah, I probably will.  I have probably path handling bug here, too, which I need to report once I sort out what causes it
03:06:30 <eivuokko> I guess I am just little disappointed how hard it is to use ghc any other way than ghc --make.
03:07:53 <Lemmih> Can't you use Cabal?
03:07:57 <eivuokko> Altho I do know why...I can't make heads or tails out of ghc's driver to see if I could patch it.
03:08:40 <eivuokko> Yeah, I suppose I could try using Cabal, but I had enough problems with Cabal when I tried Visual Haskell that I am not too fond of it
03:10:30 <MarcWeber> Lemmih, xerox: A .pkg file doesn't belong to cabal, does it? They are called .cabal, right?
03:15:25 <MarcWeber> My primary problem is installing the hdirect package. I succeeded in compiling it, now.
03:16:39 <boegel|home> @seen Itkovian
03:16:39 <lambdabot> I saw Itkovian leaving #haskell-overflow, #haskell-blah and #haskell
03:16:39 <lambdabot> 1 hour, 6 minutes and 9 seconds ago.
03:16:48 <boegel|home> anybody talked to Itkovian ?
03:17:28 <benmos> Hi Haskellers! - I've just been glancing through some of the GHC Docs, and I've noticed that some functions (-say- >>=) have their type listed with the initial universal quantification explicit - (ie (>>=) :: forall a b . m a -> (a -> m b) -> m b) whilst others seem to omit it - (eg  return :: a -> m a   or (=<<)).  Could anyone confirm for me that this is just a minor inconsintency in the docs and that I'm not missing some
03:18:04 <Lemmih> MarcWeber: You can tell ghc-pkg to install a package.conf file.
03:18:12 <MarcWeber> benmos: truncated at not missing some
03:18:32 <benmos> sorry - not quite sure I understand you.
03:18:54 <benmos> are you saying that it's purely a documentation inconsistency thing?
03:20:35 <MarcWeber> benmos Sorry. I didn't read enough of your message. There seemed to be something missing at my first glance
03:21:14 <benmos> ah - sorry - the end was:" fundamental distinction? (My understanding was that all std Haskell types are implicitly univ.quantified at the beginning - and that GHC additionally permitted explicit quantification at other places too if reqd)
03:21:15 <benmos> "
03:21:16 <MarcWeber> Lemmih: Can you tell me where to find the documentation for ghc-pkg -u ? This is used in the makefile target install-pkg
03:22:23 <Lemmih> MarcWeber: ghc-pkg has changed a lot lately.
03:23:47 <MarcWeber> Oh.. So we should start adding a line "for ghc-pkg-version : x.x.x" ;-)
03:24:02 <eivuokko> Well.  Cabal makes my ghc crash :)
03:25:31 <MarcWeber> Lemmih: I want to install fptools/hdirect. I'm currently using ghc-6.4 should I try compiling/using ghc-6.5 from fptools or should I try to adapt the .pkg file so that ghc-kg from 6.4 understands it?
03:25:32 <Lemmih> eivuokko: There's a new GHC 6.4.1 msi which should fix some of the Cabal problems.
03:26:46 <eivuokko> Lemmih, thanks, I'll try.
03:27:46 <Lemmih> MarcWeber: If hdirect isn't maintained anymore then ghc-6.5 probably wont help.
03:29:57 <MarcWeber> Lemmih: At least I didn't get any further errors when compiling it (make boot all lib) The only missing part is registering the package. But I could try ghc 6.2.2 and test wether it works there..
03:30:56 <araujo> Morning haskell'ers!
03:32:19 <kombinator> benmos: displaying the types of those functions using :t in ghci gives consistent results
03:32:46 <benmos> ah - thx - hadn't thought of trying that
03:34:02 <benmos> (so basically it looks like the ":t" thing in GHCI always omits the initial quantifier - which I guess means that it's just a slight inconsistency in the html docs - thanks)
03:34:35 <kombinator> it prints foralls if you use -fglasgow-exts switch
03:35:06 <benmos> ah - thx - will give that a go
03:43:24 <JohnMeacham> hmm.. how do you get over coders block?
03:45:53 <davve> johnmeacham, spend some time in boring real life? :)
03:47:32 <JohnMeacham> I have been doing that all weekend and have the appropriate liver damage and inappropriate phone messages on coworkers answering machines to prove it. :)
03:48:28 <davve> john, hehehe.
03:49:04 <basti_> ^^
03:49:30 <davve> I usually get interested in coding again when I've spent some time in programmer PLT-interested circles at school or heard some cool lecture
03:53:04 <JohnMeacham> Yeah, I was thinking of something more short term. Hmm.. I'll choose a paper at random from my collection and try to implement whatever it is about..
03:54:06 <davve> heh
03:59:43 <araujo> @index mapM
03:59:44 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
03:59:44 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
03:59:44 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:04:40 <syntaxfree> @where gtk2hs
04:04:41 <lambdabot> http://haskell.org/gtk2hs/
04:05:33 <syntaxfree> it'd be interesting to have some sort of packaging system coupled with darcs.
04:14:10 <JohnMeacham> you mean like 'darcs dist'? or something else..
04:14:42 <JohnMeacham> ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
04:14:42 <JohnMeacham>         Maybe.fromJust: Nothing
04:14:45 <JohnMeacham> no good...
04:15:16 <dcoutts> syntaxfree, yes me too. Like darcs dist + cabal-put!
04:15:43 <syntaxfree> gtk2hs expects what version of gtk?
04:15:57 <dcoutts> syntaxfree, any version sice 2.0
04:16:20 <syntaxfree> oh, drat.
04:16:22 <dcoutts> it'll bind the functions available in each version
04:16:31 <dcoutts> ?
04:17:45 <syntaxfree> there is an aqua version of gtk 1.something.
04:18:07 <syntaxfree> for gtk 2.x I have to compile X11, then compile gtk .. *yawn*
04:18:42 <xerox> Hiya dcoutts
04:18:49 <dcoutts> hi xerox
04:19:12 <dcoutts> syntaxfree, they are working on a native osx for gtk 2
04:19:27 <dcoutts> syntaxfree, but yes at the moment it uses X11 on osx
04:19:33 <syntaxfree> i wonder if there are any betas.
04:19:42 <dcoutts> not so far as I know
04:20:10 <dcoutts> why do you need to compile X11? it should just be something available to install
04:20:22 <syntaxfree> maybe on the os x dvd.
04:20:28 <syntaxfree> i'll check that one out.
04:21:44 <MarcWeber> Can someone have quick glance at these 24 lines? http://www.rafb.net/paste/results/XJGkQW39.html I want to create simple package but build failes (line 23) because of line 8 of the cabal file..
04:23:38 <ndm> woohoo, hoogle3 works :)
04:24:01 <xerox> Good news!
04:24:23 <ndm> and is (disturbingly) faster, despite searching 80 times more functions
04:24:32 <syntaxfree> I can't seem to build lambdabot.
04:24:53 <syntaxfree> I can't be messing with it before I make it run :~
05:37:58 <kombinator> question: What is "stack overflow"? Is there any stack in haskell interpreter?
05:38:33 <kombinator> Expected Date of Graduation: June/September 2007
05:38:41 <kombinator> sory, wron window
05:38:46 <{Arias}> xD
05:39:06 <{Arias}> kombinator infinte recursivity ?
05:39:50 <kombinator> i can trigger a stack overflow with a big foldl
05:40:03 <ndm> kombinator: its pretty easy to do
05:40:10 <ndm> a | a = a
05:40:17 <kombinator> but I don't understand WHAT is the stack in case of haskell
05:40:36 <ndm> read SPJ's book on teh implementation of functional languages
05:40:43 <kombinator> I know what's stack in case of strict languages (ocaml/C)
05:40:49 <ndm> they have a stack of evaluation, its just slightly more complex
05:41:11 <ndm> its quite similar in concept to C/ocaml
05:41:14 <ndm> you push main on it
05:41:18 <ndm> as a function call to main
05:41:34 <ndm> then the functoins main calls
05:41:34 <davve> kombinator, on the stack lies pointers to nodes that make up the expressions you write
05:42:40 <kombinator> example: foldl f e (x0:x1:xs) -> foldl f (f x0 e) (x1:xs) -> foldl f (f x1 (f x0 e)) xs -> ...
05:43:22 <kombinator> it seems that the stack (if I understand what stack is) is shallow in this case (tail recursion?)
05:46:14 <ndm> stack of f, remember
05:47:03 <kombinator> and the limit on stack size is lower than on heap size?
05:49:56 <shapr> shazam!
05:50:18 <shapr> wassup?
05:50:54 <shapr> That much?
05:51:05 <basti_> yupp!
05:51:09 <ndm> kombinator: depends, in Hugs its fixed to the C stack
05:51:24 <ndm> in GHC I think its fixed at runtime, but can be controlled by a parameter
05:53:26 <kombinator> right, hugs segfaulted on the big foldl example;)
05:56:04 <shapr> Has anyone else read Sven Panne's "Need for Haskell maintainers" post on the libraries list?
05:56:13 <shapr> JaffaCake: Hiya, awake?
05:56:44 <shapr> hiya wanahogalugi, nifty nickname.
05:58:07 <wanahogalugi> hi shapr: That was my attempt to remember the name of the mountain from Find Nemo.. ;-) I simply forgot to switch to my freenode name.. I'm using miranda on win, now..
05:58:22 <shapr> ah, ok
05:58:39 <ndm> kombinator: linux or windows?
05:58:59 <kombinator> linux
05:59:17 <ndm> ah, the windows one has a patch to detect that and print an informative error message
05:59:52 <kombinator> Is it possible to do this on linux as well?
06:00:02 <MarcWeber> shapr: Have you used cabal to create a library, yet? Is still can't figure out the why I get a parse error here: http://www.rafb.net/paste/results/XJGkQW39.html
06:00:05 <ndm> the windows code is highly windows specific
06:00:15 <ndm> but if you can craft equivalent linux code, then it should be doable
06:00:22 <ndm> you have to detect C stack overflow
06:00:35 <ndm> and fix the stack up, so it can be used again
06:00:44 <ndm> fixing it up is the hard bit
06:00:49 <ndm> requires assembly code on windows
06:01:00 <ndm> i can point you at the windows code if you want?
06:01:26 <kombinator> sure, (but I'm not sure if I'll understand it)
06:02:40 <ndm> kombinator: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/hugs98/src/winhugs/StartCode.c?rev=1.9;content-type=text%2Fplain
06:02:49 <ndm> DWORD evaluatorThreadBody(LPDWORD notUsed) {
06:03:07 <ndm> inside the block's #if defined(_MSC_VER) && !defined(_MANAGED)
06:04:40 <shapr> Igloo: I would predict that cvs does get in the way of Haskell maintainers because it's terribly manual to submit patches from an anonymous cvs checkout, getting in the way of 'impulse patching.' Can you think of anything for or against that?
06:04:49 <shapr> MarcWeber: No, I haven't used Cabal myself yet.
06:05:52 <kombinator> ndm: so it uses some Windows-olny machanism designed specifically for handling stack overflows?
06:06:03 <shapr> MarcWeber: Does it really say "Exosed" ?
06:06:23 <ndm> kombinator: it uses __try __except, which is windows only
06:06:33 <ndm> but i guess linux sends a signal on a stack overflow?
06:06:43 <xerox> Q:      Why haven't you graduated yet?
06:06:43 <xerox> A:      Well, Dad, I could have finished years ago, but I wanted
06:06:43 <xerox>         my dissertation to rhyme.
06:06:49 <MarcWeber> shapr  No, type. I can't copy text from the cygwin console. I should be Exposed
06:07:06 <kombinator> segv i think
06:07:13 <Igloo> shapr: The truth is somewhere in the middle, I think. darcs will probably increase contributions a bit, and of course it has other functionality benefits, but Sven is right that it won't solve many of the big problems
06:07:31 <kombinator> but SEGV can mean ordinary segmentation fault
06:07:33 <ndm> yeah, detect stack overflow, patch the stack, give warning message, continue
06:07:42 <Igloo> And I don't think it will lead to anywhere near the amount of contribution you seem to think it will
06:07:43 <ndm> is there no some status code you can check?
06:08:15 <ndm> and you can always record teh base stack pointer at the start, the cmp it with the current one on segv, to tell if thats teh cause
06:08:43 <shapr> Igloo: Yeah, optimism is my strong point. In that case, maybe a list of issues to solve?
06:08:48 <kombinator> don't know, I'll google (but processes on linux have groving stacks anyway)
06:08:51 <shapr> Igloo: btw, have you seen trac+darcs?
06:09:29 <Igloo> Or perhaps over-optimism is your weakness  :-)
06:09:41 <Igloo> I've looked briefly at a site using it
06:10:05 <ndm> kombinator: if they did, then hugs would too
06:10:14 <ndm> since hugs just uses the C stack
06:10:23 <ndm> there must be some limit, which is causing the error
06:10:49 <kombinator> the stack grows until it hits some (low) limit
06:12:17 <shapr> Igloo: Well, obviously I don't think I'm overoptimistic, or I'd change it, but everyone is allowed their own opinion.
06:13:40 <shapr> Heck I think I should be more optimistic.
06:17:38 <shapr> I think most people suffer from a lack of optimism. It's sad. There's so much they could do if they just went out and did it.
06:18:43 <fnord123> hey all. i have a webpage that can dynamically update with javascript
06:18:44 <eivuokko> Does Cabal have ability to build Windows dlls?  ghc-option --mk-dll doesn't seem to work and I am not sure modifying ld options alone is enough (or is it?)
06:18:49 <fnord123> id like to connect it to some haskell code
06:19:22 <fnord123> are there any haskell ajax tools or libs?
06:19:45 <earthy> not yet. :)
06:20:52 <fnord123> oh i see. how would one do it in, say c++ then?
06:20:59 <fnord123> or shall i just move to #C++ :P
06:21:06 <shapr> fnord123: There's XmlRpc
06:21:25 <shapr> BjÃ¶rn Bringert wrote the lib.. lemme find it for you...
06:21:56 <shapr> Ah, here it is - http://www.haskell.org/haxr/
06:28:25 <kombinator> ndm: there seem to be no reliable method of detecting whether SEVG was caused by stack overflow or not on linux
06:29:37 <ndm> kombinator: i can think of a portable method....
06:30:24 <kombinator> ndm: please elaborate
06:30:35 <ndm> void* stack_low;
06:30:37 <ndm> void main() {  int i;   stack_low = &i;}
06:30:52 <ndm> then you just need to figure out the current stack depth, when an overflow occurs
06:31:07 <ndm> and if stack_low vs stack_high is roughly the stack limit, you stack overflowed
06:31:46 <kombinator> the question is: where will be the stack frame of a signal handler on a stack overflow
06:32:02 <ndm> good question!
06:32:08 <kombinator> brb
06:34:24 <ndm> kombinator: how often does hugs stack fault anyway? it shouldn't, and even if it does - recovering would be good
06:37:13 <kombinator> ndm: It would be nice if it said "stack overflow: bye, bye" instead of throwing a SEGV
06:37:33 <ndm> i know
06:37:40 <ndm> winhugs was even worse...
06:37:50 <ndm> it just quit silently without any error message at all
06:53:12 <eivuokko> Seriously, what is the build system everyone use to make dlls with ghc?  It is just so major pain to keep track of everything.
06:53:53 * basti_ doesnt make dll's with ghc
06:53:59 * eivuokko thinks he is best off writing SCons toolset for ghc and foget ever touching this stuff again
06:58:37 <wilx> Well, aren't there existing packages that compile into .dlls?
06:58:52 <Igloo> Can cabal do it?
06:59:00 <eivuokko> Igloo, I don't know how.
07:00:06 <eivuokko> Igloo, in truth, it very likely can with some cleverness, or dunno how Visual Haskell is built
07:00:59 <eivuokko> Igloo, But, as -mk-dll doesn't help, it would be downto ld-options, which is kind of unclear as ld probably shouldn't get basic main linked in...
07:02:16 <eivuokko> I really should writing my ramblings to the ghc-users mailing list, eh :-S
07:06:09 <Igloo> The best solution would be to make cabal able to do it, if it can't already, IMO
07:07:39 <eivuokko> There are soem other stuff I would like Cabal to have....I guess I better start hacking if I want it working :-(
07:09:31 <wilx> What are you doing anyway? :)
07:09:52 <eivuokko> I want to write plugin for stuff I write at work
07:09:58 <eivuokko> *plugins
07:10:13 <eivuokko> Haskell would be nicer for expressing rewriting message queues than C++.
07:10:25 <wilx> I see.
07:11:35 <eivuokko> I don't even have anykind of working prototype plugin working yet because I can't ge the build automated.  Hand manageing objects files would have been faster. ;)
07:46:07 <jacobian> what is the type of a balanced or constant boolean function?
07:48:07 <basti_> "Bool"?
07:48:24 <basti_> that is, "a->Bool". or "a->a->Bool"
07:55:31 <wilx> Balanced functions? What is it?
07:57:36 <jacobian> I have a function from n:Nat. n<2^b   with b fixed.
08:01:00 <jacobian> it returns true for half the domain and false for the other half, or it always returns true or false.
08:01:20 <basti_> ...so?
08:01:36 <basti_> is this any different to Bool, except for being more special?
08:01:41 <basti_> (which is the idea of programming)
08:01:41 <jacobian> no
08:02:01 <basti_> i dont understand you question then
08:03:06 <jacobian> but I was curious how to express a type that talks of the half the domain
08:03:33 <eivuokko> Igloo, The way ghc works atm, I think easiest would be to add (when building dll) Distribution.Simple.Build.constructGHCCmdLine -no-link and add new step for linking that is very much like in libraries, but it would need dependency info to get all .o files to pass ghc --mk-dll.  Does that sound doable or sane?
08:03:34 <Cale> jacobian: unfortunately you can't
08:03:38 <Cale> (in Haskell)
08:04:14 <Igloo> eivuokko: I have no idea how the internals of cabal work, nor how DLLs are built
08:04:16 <jacobian> well, more generally in type theory how would you
08:04:39 <eivuokko> Igloo, Oh, sorry.  Wrong person, uhm, who should I talk to then?
08:05:56 <Igloo> SyntaxNinja is probably the best person, or the appropriate list (libraries@haskell.org?)
08:06:31 <eivuokko> Thanks
08:07:18 <fnord123_> arf, I am trying to make Crypto, but it requires NewBinary - which I have and have built, but I dont know how to make it so the Crypto Cabal file knows where to look for NewBinary
08:07:29 <fnord123_> fwiw, I'm on os x
08:07:34 <glasser> Cale: belated thanks on commute.  I knew there was a way to get the list monad to do what I wanted...
08:07:50 <Cale> glasser: :)
08:08:07 <Cale> jacobian: hmm... I don't know too much type theory, but personally, I'd write that type as its set of elements. {n | n in Nat, n < 2^b} I suppose it's also possible to express something similar as the type of naturals paired with proofs that the given natural is less than 2^b
08:08:21 <glasser> the version I had come up with was
08:08:24 <glasser> cartesianProduct = Map.foldWithKey addAllValues [Map.empty]
08:08:25 <glasser>   where addAllValues k vs cur = [ Map.insert k v m | v <- vs, m <- cur ]
08:10:21 <Cale> does anyone know anything about laws in Miranda, and in particular, why they were abandoned?
08:12:06 <glasser> where's a good place to read about the "record" data types (ie, data Foo = {bar::Baz, x::Y})? I haven't seen them in any book I've read, I guess they're new
08:12:11 <glasser> sohuld I just go striaght to the Report?
08:12:50 <Cale> Perhaps books just leave them out just because they're not all that different from ordinary data types.
08:12:58 <Cale> Just additional syntax :)
08:13:07 <Cale> as well as a few extra features
08:13:11 <glasser> heh. but I want to know the syntax!
08:13:19 <Cale> I'm pretty sure they're covered in YAHT
08:13:26 <glasser> esp the "modifier" syntax where you take one and make a new one with a bit of change
08:13:40 <EdLin> Cale: I'm a Haskell newbie, I thought you meant that the Miranda warnings had been abandoned. ;-)
08:14:07 <EdLin> Cale: wouldn't surprise me
08:14:12 <glasser> aha, sect 3.15
08:14:13 <Cale> (p {x = y}) is the same as p, but where the value of the field x has been replaced by y
08:15:01 <Cale> EdLin, hm?
08:15:12 <Cale> I was referring to the programming language Miranda.
08:15:52 <Cale> Footnote: Miranda is a trademark of Research Software Ltd.
08:15:56 <Cale> :)
08:15:58 <EdLin> Cale: "you have the right to remain silent" and other regulations concerning interrogation and arrest from the Miranda supreme court decision in the early 60s.
08:16:06 <Cale> oh, in the US
08:16:30 <EdLin> Cale: "you have the right to remain silent" is one of the miranda warnings.
08:16:38 <Cale> :)
08:16:43 <glasser> that was my first thought too :)
08:17:22 <EdLin> Cale: the police call it Mirandizing the suspect.
08:17:33 <Cale> Laws were rewriting rules which were defined by the programmer to automatically rewrite values in a data type into a normal form.
08:18:54 <Cale> For example, one could define an algebraic type, like olist ::= Onil | Ocons num olist, and give a law like:  Ocons a (Ocons b x) => Ocons b (Ocons a x), a > b
08:19:07 <integral> Cale: did they also affect pattern matching?  You showed an example with Nat = Zero | Succ Nat | Pred Nat, and a law to normalise to Succ,  but could you then use Pred in pattern matches?
08:19:07 <Cale> which would define the type of ordered lists
08:19:21 <Cale> integral: yeah, you could use both
08:19:34 <Cale> that example wasn't Nat
08:19:38 <Cale> but integers :)
08:19:49 <Cale> Pred would only match against negative values
08:20:05 <integral> err, oops 8-)
08:20:30 <integral> that seems a bit of a drawback
08:20:57 <fnord123_> you also need to confirm that you understand your rights and the police need to keep repeating them until you understand
08:20:59 <Cale> Let's see, it was something like  integer ::= Zero | Succ integer | Pred integer. Succ (Pred n) => n. Pred (Succ n) => n
08:21:11 <fnord123_> and you need to understand the charge being brought against you
08:21:25 <fnord123_> but thats gone now
08:22:18 <glasser> It feels like that could get you into infinite loops
08:23:36 <Cale> glasser: yes, in general it could
08:24:36 <EdLin> fnord123_: it actually doesn't make much of a difference, most suspects waive their rights by talking, 99.9 percent of the time if they had anything to do with it through detective work they have a complete signed confession and are ready for the next step, the plea bargin.
08:24:43 <Cale> but it was as lazy as possible, so there could still be infinite structures with laws applied to them
08:27:35 <EdLin> fnord123_: the best thing to do is to say, yes you'll talk and help the investigation but please may I have a lawyer present.
08:28:03 <fnord123_> it depends on your situation
08:28:14 <fnord123_> and what you want out of it
08:28:19 <EdLin> fnord123_: well, true, IANAL
08:28:53 <fnord123_> e.g. if you were arrested for protesting, or wrongly arrested, then there's nothing to talk about
08:29:15 <fnord123_> or if you are inclined to protect a political enemy of the regime then you might want to keep your mouth shut
08:29:36 <EdLin> fnord123_: you can *pretend* there's something to talk about, keeps the police from getting pissed off until the lawyer comes along and says he doesn't want you to talk.
08:30:30 <fnord123_> usually, the fbi will give you a nice guy to talk to
08:30:36 <fnord123_> hes nice so you can tell him anything
08:30:50 <fnord123_> he or she will usually know a lot about your interests and act like a friend
08:30:56 <fnord123_> confinde in them! :P
08:31:05 <EdLin> fnord123_: you can avoid that whole situation for asking for a lawyer to be present.
08:31:39 <EdLin> but anyways - this doesn't have much to do with the Miranda language.
08:31:40 <fnord123_> not always. they can say its a terror chargwe and ignore your request
08:31:41 <EdLin>  :-)
08:31:55 <EdLin> fnord123_: then you're in deep do-doo
08:32:23 <fnord123_> yeah but that was the point of miranda rights: to stop the police as acting as political silencers
08:32:38 <fnord123_> and arresting people on insane charged
08:32:43 <fnord123_> charges :-/
08:32:59 <EdLin> fnord123_: agreed. Live under King George the stupid has made things deteriorate. ;-)
08:33:11 <EdLin> life*
08:33:42 <fnord123_> miranda is functional
08:34:06 <Cale> Miranda inspired Haskell
08:34:38 <EdLin> there's a book for Haskell that originally was for Miranda, isn't there? I've thought of getting it, is it good?
08:37:23 <Cale> It's supposed to be decent, but I don't know.
08:38:47 <EdLin> Cale: how did you learn Haskell?
08:39:20 <Cale> Tutorials on the web, the Report, and mostly just playing around with it.
08:42:43 <Cale> We ought to have a wiki page with exercises. :)
08:43:56 <Cale> btw, that book is http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
08:44:48 <EdLin> thanks
08:50:42 <fnord123_> any gurus here? im trying to build crypto and I'm not sure how to tell it where to find the NewBinary library (which I've built..)
08:50:48 <fnord123_> Crypto uses Cabal.
08:51:48 <Cale> Is NewBinary a Cabal library?
08:51:53 <fnord123_> it is
08:51:57 <Cale> er package
08:52:00 <Cale> hm
08:54:02 <Cale> I'm not really sure -- does ghc-pkg list show it?
08:54:51 <fnord123_> nope. it isnt registered globally. how might I do that?>
08:55:09 <Cale> ./Setup.lhs install ?
08:55:38 <Cale> Is there a Setup.hs or Setup.lhs?
08:55:41 <fnord123_> oh snap!
08:55:46 <fnord123_> its listed!
08:56:39 <fnord123_> configure complete. building now. :D :D: D You are a legend among men
08:57:00 <Cale> heh
08:57:44 <kala_> can I do add x x = 2*x with pattern matching? I mean, can it detect same values? At the moment I get "Repeated variable "m1" in pattern" with hugs
08:58:06 <Igloo> no
08:58:08 <Cale> kala_: no
08:58:17 <kala_> Cale: bummer.
08:58:19 <araujo> Hello haskell'ers!
08:58:24 <Cale> you have to test for equality
08:58:34 <kala_> Cale: so i need to check manually with if then else?
08:58:35 <Cale> araujo: hello
08:58:40 <Cale> kala_: or guards
08:58:41 <xerox> add x x | x == x = 2 * x
08:58:48 <xerox> oops
08:58:50 <araujo> Cale, :-)
08:58:58 <xerox> add x y | x == y = 2 * x
08:59:02 <Cale> add x y | x == y = 2 * x
08:59:06 <Cale> hehe
08:59:10 <xerox> Hi araujo!
08:59:22 * xerox got fooled again :-)
08:59:28 <integral> hmm,I guess a good reason for not having non-linear patterns is that not everything is an instance of Eq?
09:00:01 <xerox> I think the reason was another
09:00:02 <Cale> integral: well, yeah -- though we already have things where an instance of Eq is required to pattern match
09:00:04 <araujo> xerox!!!
09:00:11 <kala_> Cale and xerox ... thats something like set constructor?
09:00:28 <integral> Cale: hmm, do you have an example?
09:00:29 <Lemmih> Cale: We do?
09:00:37 <mattam> anyone know how to add two tex numbers ?
09:00:57 <Cale> Lemmih: Matching against numbers
09:01:32 <Lemmih> Oh, right.
09:01:49 <integral> ah, numbers aren't constructors 8)
09:01:56 <Cale> which is why Eq is a superclass of Num
09:02:04 <Lemmih> mattam: show (read a + read b)?
09:02:08 <Cale> though that's a bit of a poor reason for that
09:02:32 <mattam> :) i mean in LaTeX
09:02:46 <Cale> mattam: there was a package for it
09:02:50 <Cale> calc, I think
09:03:19 <Lemmih> Ah, sorry. Thought it was a typo for 'text' (:
09:03:40 <mattam> thanks
09:04:28 <Cale> http://www.cirano.qc.ca/informatique/autres_guides/LaTeX-2e/calc.ps.Z
09:04:51 <mattam> nice, i was searching for that
09:06:21 <Cale> http://www.cs.brown.edu/system/software/latex/doc/calc.pdf seems to be newer
09:08:21 <Igloo> I don't see why you think numbers aren't constructors
09:10:37 <Cale> Well, if you write
09:10:48 <Cale> f 0 = True
09:10:53 <Cale> f n = False
09:11:08 <integral> are you really saying: f x | x == fromInteger 0 = True ?
09:11:18 <Cale> yes
09:11:54 <Igloo> Hmm, OK, I guess so
09:32:21 <glasser> how do I do the equivalent of a perl "join"?  ie, given a String and a list of Strings, join the strings with the given string.  intersperse isn't quite it
09:32:32 <integral> concat?
09:32:53 <glasser> oh, i see, concat and intersperse together
09:32:54 <integral> @eval concat ["hello", " ", "world"]
09:32:57 <lambdabot> "hello world"
09:33:10 <integral> there's also unwords and unlines for two common cases
09:43:28 <syntaxfree> every string is a list of chars, right?
09:44:25 <basti_> yes
09:44:28 <syntaxfree> so.
09:44:35 <syntaxfree> imagine I have no way to verify that.
09:44:41 <syntaxfree> I can't ask anyone more knowledgeable.
09:44:45 <syntaxfree> All I have is lambdabot's @type.
09:44:51 <syntaxfree> So I go playing around with it.
09:44:55 <syntaxfree> @type "String1"
09:44:55 <basti_> eval too?
09:44:56 <lambdabot> [Char]
09:45:02 <syntaxfree> @type "String2"
09:45:03 <lambdabot> [Char]
09:45:06 <syntaxfree> and so on.
09:45:15 <basti_> ....?
09:45:17 <basti_> and now?
09:45:30 <syntaxfree> Do you agree that every string whose type returns [Char] improves my confidence in the theory "Every string is a [Char]"?
09:45:42 <basti_> yes
09:45:46 <syntaxfree> so.
09:46:05 <syntaxfree> if "Every string is a [Char]", then most certainly everything that's not a [Char]  is not a string, right?
09:46:25 <syntaxfree> isn't it the same sentence? "Every string is a [Char]", "Every non-[Char] is a non-string"?
09:46:31 <basti_> uhhmmmmmmmmmm
09:46:38 <basti_> are we getting philosophical now? ^^
09:46:45 <syntaxfree> just answer my questions :)
09:46:48 <basti_> but, yes, all strings are [Char]
09:46:53 <basti_> no string is not [Char]
09:46:57 <basti_> except for "String"
09:47:01 <basti_> which is a synonym
09:47:09 <syntaxfree> then all non-[Char] things are non-Strings?
09:47:14 <basti_> yes
09:47:25 <syntaxfree> so, it is the same proposition?
09:47:33 <basti_> i can't tell
09:47:39 <syntaxfree> "Every string is a [Char]"; "Every non-[Char]  is a non-String".
09:47:45 <ndm> String = [Char]
09:47:53 <ndm> is a more succinct way of saying it
09:47:56 <syntaxfree> Well, does "Every non-[Char] is a non-String" imply "Every String is a Char"?
09:47:59 <davve> => versus <=> ?
09:48:06 <ndm> its <=>
09:48:33 <ndm> syntaxfree: with those words, know
09:48:38 <syntaxfree> so we all agree that "Every string is a [Char]" is the same "theory" as "Every non-[Char]  is a non-String"?
09:48:50 <ndm> no, they are logically different
09:49:00 <basti_> strictly speaking it's different
09:49:10 <ndm> a => b      is not hte same as    ~a => ~b
09:49:27 <syntaxfree> I'm asking if a=>b AND b=>a  in this case.
09:49:30 <basti_> hmm we're getting semantic here.
09:49:41 <ndm> syntaxfree: you are confusing logic and haskell
09:49:44 <basti_> in classical logic a <-> b  ===  ~a <-> ~b
09:49:53 <syntaxfree> I'm talking about logic.
09:49:59 <syntaxfree> I could talk about red apples and green pears.
09:50:06 <basti_> in non-classical logic, this does not hold
09:50:09 <syntaxfree> Haskell is more fun than fruits.
09:50:42 <basti_> you could try to talk in formulae then ^^
09:50:52 <syntaxfree> which means you can't guarantee, from the statement "Every non-[Char] is a non-String"  thay "Every String is a [Char]"?
09:50:54 <ValarQ> isn't [CharAlias] also a string? (if CharAlias is Char)
09:51:13 <syntaxfree> ValarQ that's another theory. We're testing my theory first.
09:51:16 <syntaxfree> All we have is @type.
09:51:40 <ValarQ> syntaxfree: no, it was a question
09:52:16 <syntaxfree>  so. Are those propositions equivalent or not?
09:52:45 <basti_> syntaxfree: in haskell things might be non-classical. I do not know if we can reason classically about that.
09:53:25 <syntaxfree> I was just using an example.
09:53:31 <syntaxfree> Let's see.
09:53:42 <syntaxfree> tell me the name of a fruit.
09:53:51 <basti_> lets talk "a" and "b" ok? ;)
09:54:05 <syntaxfree> I have a theory.
09:54:08 <basti_> and still, in classical logic, this is true. There is not just one logic though.
09:54:09 <syntaxfree> All As are Bs.
09:54:34 <syntaxfree> we're playing scientists. We're gonna test empirically my theory.
09:54:49 <syntaxfree> As fall from the sky in the Great Big Cascade of As in the North.
09:54:54 <basti_> want to talk about that in #haskell-blah?
09:55:01 <syntaxfree> oh, ok :)
09:55:34 <MarcWeber> Back again! Hi @ll. My runhasell Setup.hs build runs now but ghc-6.4 crashes (on win). Do you have any idea how to track down the origin of this crash?
10:12:40 <syntaxfree> MarcWeber: you talking 'bout Lambdabot?
10:24:54 <MarcWeber> Wow. Now cabal / installing my own testpackage works fine! jipiee yeah! A tool to fall in love with ;-)
10:30:51 <eivuokko> :)
10:39:32 <HeverClever> what is the meaning of the (!) operator in expressions ?
10:39:42 <HeverClever> indirectToDirect (start, states)
10:39:42 <HeverClever> = tieArray ! start
10:40:03 <Lunar^> @type (!)
10:40:04 <lambdabot> bzzt
10:40:10 <HeverClever> tieArray is a fun defined elsewhere
10:40:12 <Lunar^> @type Data.List.!
10:40:13 <lambdabot> bzzt
10:40:17 <Lunar^> @type Data.Array.!
10:40:18 <lambdabot> bzzt
10:40:25 <Lunar^> grmlml
10:40:29 <Lunar^> @index (1)
10:40:29 <lambdabot> bzzt
10:40:30 <Lunar^> @index (!)
10:40:31 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap,
10:40:31 <lambdabot> Data.Map, Data.Array, Text.Html
10:40:42 <Lunar^> @type Data.Array.(!)
10:40:43 <lambdabot> bzzt
10:40:49 <Lunar^> @type Data.IArray.(!
10:40:50 <lambdabot> bzzt
10:40:59 <Lunar^> @type Data.Array.!
10:41:00 <lambdabot> bzzt
10:41:09 <Lunar^> @pugs :t Data.Array.!
10:41:10 <lambdabot>  parse error on input `:'
10:41:14 <Lunar^> sigh
10:41:22 <HeverClever> can it be some operator for FiniteMap ?
10:42:42 <Lunar^> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html#v%3A%21
10:42:45 <Lunar^> here it is
10:43:07 <HeverClever> ah, thanks a lot
11:07:36 <ustenzel> @type (Data.Array.!)
11:07:38 <lambdabot> forall e i. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> i -> e
11:07:45 <ustenzel> that was easy :)
11:14:17 <kombinator> @type Data.Array.(!)
11:14:18 <lambdabot> bzzt
11:14:27 <kombinator> just checking
11:16:22 <ski_> @index (!)
11:16:23 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap,
11:16:23 <lambdabot> Data.Map, Data.Array, Text.Html
11:16:39 <ski_> @type (Data.Array.!)
11:16:41 <lambdabot> forall e i. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> i -> e
11:24:07 <goron> How hard is it to program/generate PostScript?
11:24:14 <mflux_> not very
11:30:20 <ski_> hello Yubanalesco
11:31:07 <ski_> got any haskell question ?
11:39:38 <syntaxfree> if you haven't, you're welcome at a very bitter flame war at #haskell-blah ;-)
11:40:00 <heatsink> uhn?
11:45:29 <fnord123> Hello
11:45:50 <fnord123> I'm getting an ld problem where an archive i out of date, but im unsure why. I just made it. :(
11:46:27 <fnord123> using Cabal
11:47:10 <syntaxfree> Cabal is dangerously close to Cobol.
11:47:27 <fnord123> LOLZZZZZZZZZZZZ
11:47:45 <syntaxfree> Common arrow-oriented baffling artificial language?
11:52:02 <fnord123> no
11:53:13 <Lemmih> fnord123: You have to tell us more about your problem if you want help.
11:54:34 <fnord123> i build NewBinary and install it. so get-pkg list holds it
11:56:28 <fnord123> then i build Setup for Crypto and then ./Setup configure and it all works
11:57:02 <fnord123> then ./Setup build and it fails on linking
11:57:18 <fnord123> saying that: "ld: table of contents for archive: /usr/local/lib/NewBinary-0.1/libHSNewBinary-0.1.a is out of date; rerun ranlib(1) (can't load from it)"
11:59:38 <fnord123> well since im a genius, I figured out "rerun ranlib" is a command to me...
11:59:46 <fnord123> and I ran it and got past this problem
11:59:55 <fnord123> I use the word genius loosely. :(
12:02:34 <m3ga> @version
12:02:35 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
12:02:35 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:03:18 <m3ga> anyone know if it is possible to compile lambdabot with ghc-6.2.2?
12:03:35 <m3ga> I get : ghc-6.2.2: unknown package name: mtl
12:03:39 <syntaxfree> it's not.
12:03:46 <syntaxfree> you need 6.4.1
12:03:49 <m3ga> syntaxfree: thanks.
12:04:55 <m3ga> thats a bummer. I'm on Debian and if I try to install a later version of ghc it wants to uninstall one of the O'Caml libraries that I'm currently using.
12:05:14 <syntaxfree> that's Linux for ya.
12:05:20 <syntaxfree> Break on thru to the other side :)
12:05:33 <syntaxfree> just compile 6.4.1 on your home directory.
12:05:43 <syntaxfree> you can have both versions running like that.
12:06:19 <greenrd> Has anyone used ReadP?
12:07:55 <ustenzel> m3ga: have you tried haskell-unsafe.alioth.debian.org?
12:08:24 <greenrd> I am looking for a non-trivial example of the use of ReadP.
12:09:16 <greenrd> in order to read it and get a feel for it
12:12:09 <m3ga> ustenzel: that archive seems to be i386. i'm on ppc :-)
12:12:32 <ustenzel> m3ga: Lucky bastard ;-)
12:13:02 <m3ga> ah, it does have powerpc as well?
12:13:05 <m3ga> lucky??????
12:13:26 <ustenzel> m3ga: you've got a PPC.  that counts as luck all by itself :)
12:13:36 <fnord123> because walking into a shop is lucky
12:13:38 <fnord123> (???)
12:14:49 <ustenzel> m3ga: haskell-unsafe does have a powerpc archive!  unfortunately, it is empty.
12:17:20 <m3ga> ustenzel: this ibook ran really, **really** nicely under linux for nearly three years. I then applied a security update under macosx (which I also use very ocassionally) which updated the BIOS. Since then sleep doesn't work and neither does cpu frequency scaling. That means it won't run for more than 10 minutes on battery.
12:17:39 <m3ga> I won't be buying another apple laptop!
12:18:40 <ustenzel> m3ga: sounds bad.  Anyway, grab the ghc 6.4.1 package from testing or unstable and dpkg-buildpackage it.  It should work on stable.
12:18:51 <MenTaLguY> m3ga: when was the security update?
12:18:55 <MenTaLguY> and what model iBook?
12:19:41 <m3ga> its a G3 ibook, cpu is 750CXe rev 3.1, PowerBook4,1
12:19:50 <m3ga> the upgrade was a couple of months ago
12:19:59 <m3ga> ustenzel: thanks
12:21:33 <glguy> That's funny, now that I got a powerbook, I'll never go back to a non-apple laptop. my previous laptop don't compare for what I do
12:22:56 <MenTaLguY> m3ga: huh.  I'm still doing fine for some reason
12:23:29 <m3ga> yep, they are definitely great laptops if you can stand OSX (I can't). If you're running Linux on them you can get caught like this.
12:23:37 <m3ga> MenTaLguY: same model?
12:23:38 <fnord123> i can stand it
12:23:43 <MenTaLguY> no, PowerBook4,3
12:23:57 <m3ga> ahhh minor differences
12:24:00 <m3ga> I guess
12:24:16 <m3ga> fnord123: good for you. I find OSX a PITA.
12:24:17 <MenTaLguY> it's also possible that I haven't booted into MacOSX for a couple months
12:24:20 <MenTaLguY> but I don't think it's been that long
12:24:37 <MenTaLguY> I use Linux for audio/video stuff because OSX is too slow on this hardware
12:24:47 <fnord123> im not skilled with unix or linux enough to administer my own machine yet
12:24:51 <MenTaLguY> and then Linux is certainly nicer for programming
12:24:56 <fnord123> and i cant deal with windows' focus issues
12:25:16 <m3ga> MenTaLguY: that why I like Linux. For coding its fantastic
12:25:51 <m3ga> fnord123: I spent a number of years doing Solaris support. I know unix a little too well :-)
12:25:52 <glguy> that's why I switched to os x from windows, great coding environment, without giving up features in the GUI
12:27:24 <m3ga> glguy: you really need to try a really light weight linux desktop like fluxbox :-) I find the normal gui s do get in my way.
12:28:05 <glguy> m3ga, I know all about fluxbox, openbox and blackbox, but I don't care for minimalist desktop environments on anything but the slowest of hardware
12:28:07 <fnord123> the simple bug in windows that would make me go back if they fixed: when you begin a program, it's window gets to be top of the z order - but if you choose another one while the program loads then it wont popup on top and steal focus
12:28:07 * basti_ is on sawfish
12:28:56 <fnord123> i mean it should do that. in windows, a new window will steal focus and interrupt what you're doing
12:29:00 <fnord123> which pisses me off
12:29:23 <basti_> a general rule would be: anyone who touches my focus deserves to have a bullet shot into his head
12:29:38 <fnord123> a fucking men
12:29:47 <eivuokko> fnord, actually on well behaving programs it doesn't anymore on atleast windows xp.
12:29:54 <glguy> to be honest, I couldn't decide which OS i liked better... so I use them all
12:29:56 <fnord123> it does
12:30:08 <glguy> OS X on the laptop, Gentoo Linux on the left side of my desk, XP on the right side
12:30:17 <fnord123> in windows the focus is resolved at window creation time and z order at window show time
12:30:20 <glguy> OpenBSD on the fileserver
12:30:26 <Cale> Focus-follows-pointer!
12:30:48 <fnord123> on osx its at program start time except for shitty programs like limewire which are awful and remind me of the pain
12:30:54 <Cale> I can't stand having to raise a window in order to type in it.
12:31:05 <fnord123> i cant stand having to use a mouse to change focus. :P
12:31:13 * fnord123 is a happy hacker. 
12:31:18 <glguy> I used ion3 for a while on my linux machine
12:32:10 <glguy> (didn't have a mouse on that machine)
12:32:32 <glguy> and all this mess about "z-order" was simplified
12:32:45 <eivuokko> fnord, anyway, well-behaved programs, which there are plenty, do not take focus unexpectedly.  I dunno details, but if I start multiple programs and it takes time before all windows pop up, and I manually focus one of them, the rest don't take focus.
12:33:23 <fnord123> eivuokko: that isn't my experience. each program steals focus several times as it starts up
12:33:41 <fnord123> e.g. IE, Exceed windows, or bloomberg terminals
12:33:56 <fnord123> oh wait , i dont use IE anymore at work. :)
12:35:07 <MenTaLguY> @type maybe return readIORef
12:35:08 <lambdabot> bzzt
12:35:15 <MenTaLguY> @type maybe
12:35:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:35:59 <Cale> maybe is is to Maybe what foldr is to lists
12:36:14 <Cale> -extra is
12:37:06 <fnord123> awesome. HaXML has a compile error in Instance.hs
12:37:12 <glguy> s/is//
12:44:08 <nuffer> is anyone here familiar with parsec?
12:44:23 <Cale> what about it?
12:44:23 <Lemmih> Yeah.
12:44:50 <nuffer> um, how do I import the lexeme parser?
12:46:14 <nuffer> import Text.ParserCombinators.Parsec.Token gives me a nice long list of compiler errors
12:46:33 <nuffer> oh wait, nevermind, those are my mistake
12:58:51 <Seb> su yall
12:59:19 <Seb> fib :: Num a, Num b => a -> b   gets me "ERROR "fib.hs":1 - Syntax error in input (unexpected comma)"
12:59:22 <Seb> s/su/sup/
12:59:28 <Seb> that's in hugs
12:59:40 <Seb> what am I doing wrong ?
12:59:49 <xerox> Try with parens around the constraints?
12:59:51 <integral> you need () around the constraints
13:00:46 <Seb> ah, ok
13:00:54 <Seb> then this tutorial is slightly outdated ;)
13:02:18 <ski_> (which tutorial ?)
13:02:37 <Seb> Main> fib 100000 ....... zsh: segmentation fault (core dumped)  hugs
13:02:37 <Seb> heh
13:02:47 <Seb> ski_: http://www.haskell.org/~pairwise/intro
13:04:12 <ski_> Seb : rather slightly inaccurate, than outdated ..
13:04:24 <Seb> ski_: k
13:05:06 <ski_> (hugs uses C stack, which can overflow .. this is a known bug)
13:06:26 <Seb> ski_: oh i see
13:06:52 <Seb> anyway, haskell is nice so far :)
13:06:54 <Seb> makes for a change
13:08:31 <glguy> Seb, ghc will calculate fibs out that far and beyond
13:08:51 <glguy> or you could just use the non-self-referencing definition
13:10:45 <Cale> You need some memoisation, or you need to use an accumulator
13:11:04 <Seb> glguy: "non-self-referencing definition" ? You mean non-recursive ?
13:11:14 <Cale> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
13:11:56 <glguy> fib n = ((1+ sqrt 5)^n - (1 - sqrt 5)^n)/sqrt 5
13:12:18 <Cale> that won't work for very far due to loss of precision
13:13:18 <glguy> still... i think it's cool that there is a solution to the recurrence
13:13:30 <Cale> yeah
13:14:17 <basti_> i learned the theory of that... thats really bizarre
13:14:58 <Cale> Oh, it's not that strange, it's just a bit of linear algebra
13:15:41 <Cale> you're diagonalising a linear operator :)
13:16:43 <glguy> If I didn't enjoy computer science so much, I'd get a degree in mathmatics
13:16:53 <glguy> and
13:16:56 <glguy> I'd spell it correctly
13:16:59 <glguy> mathematics
13:35:30 <goron> Cale: Are you saying that you can't efficiently calculate fib 10^100?
13:35:52 <MenTaLguY> @pl (liftM . (* 2)) readIORef
13:35:53 <lambdabot> fmap (readIORef * 2)
13:36:24 <MenTaLguY> @pl (liftM . (* 2)) readIORef $ newIORef 3
13:36:25 <lambdabot> fmap (readIORef * 2) (newIORef 3)
13:37:14 <MenTaLguY> @eval fmap (readIORef * 2) (newIORef 3)
13:37:15 <lambdabot>  Not in scope: `newIORef'
13:37:32 <{Arias}> @type fmap
13:37:33 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f
13:37:33 <lambdabot> b
13:37:33 <{Arias}> :$
13:37:38 <MenTaLguY> @eval fmap (readIORef * 2) (Data.IORef.newIORef 3)
13:37:39 <lambdabot>  Not in scope: `Data.IORef.newIORef'
13:39:00 <MenTaLguY> @eval readIORef * 2
13:39:02 <lambdabot>  Not in scope: `readIORef'
13:39:14 <MenTaLguY> @eval Data.IORef.readIORef * 2
13:39:16 <lambdabot>  Not in scope: `Data.IORef.readIORef'
13:39:19 <MenTaLguY> meh
13:39:29 <MenTaLguY> well, that's what ghci is for
13:40:10 <araujo> Great!
13:40:11 <araujo> Worked
13:46:28 <xerox> dcoutts_: ping
13:47:55 * araujo already can do sweet things like:  %S filter (\ s -> s /= ',') @uptime@
13:48:26 <xerox> Is the source publicly available anywhere, araujo?
13:48:53 <araujo> xerox, not yet, i still need to clean a bit more the code and fully add a few more feature
13:49:08 <araujo> I hope to get something posted in a couple of days or so
13:49:35 <{Arias}> @type fromIntegral
13:49:36 <lambdabot> forall b a. (Num b, Integral a) => a -> b
13:49:38 <xerox> Take in consideration that darcs makes it very, very simple for people to grab the code, hack it, and send you back patches!
13:51:05 <araujo> xerox, hah yeah, you know anywhere i could upload it?
13:51:08 <araujo> mm..
13:51:19 * araujo probably could use the haskell-herd darc repo of Gentoo
13:51:43 * SamB comes to the realisation that GHC really doesn't want to support waiting on any of a number of Fds or timers from a single thread...
13:52:27 <sylvan> Did anyone ever make a Haskell binding to Ogre3D? I've heard people talking about it here and there but  never actually seen it
13:58:16 <musasabi> SamB: Just use N threads ;)
13:58:42 <SamB> musasabi: thats what I suggested, but dcoutts doesn't think its a good idea
13:58:49 <SamB> he thinks it would be too slow!
13:59:02 <SamB> I said "try it and see", but he still didn't seem to think so...
13:59:44 <SamB> but as the only solution that doesn't require hacking GHC, it certainly does have its advantages...
13:59:56 <musasabi> SamB: What are you trying to do?
14:01:44 <SamB> musasabi: well, I'm not trying it yet, but it would be nice to have gtk2hs working along with forkOS without that timeout hack...
14:04:15 <musasabi> And that requires reading from an unlimited number fds?
14:04:36 <xerox> araujo: I'd say to ask shapr, but he's not here :-|
14:05:24 <SamB> musasabi: I dunno, but it requires either having the GHC RTS wait on gtk2hs's Fds, or vice versa...
14:05:37 <SamB> er, I mean GTKs fds
14:06:22 <musasabi> Well you can select(2) in software... (but that does not work that well without -threaded)
14:08:36 <araujo> xerox, Ok, i will try to catch him
14:08:43 <xerox> @seen SyntaxNinja
14:08:44 <lambdabot> I saw SyntaxNinja leaving #haskell-blah and #haskell 1 day, 29
14:08:44 <lambdabot> minutes and 24 seconds ago.
14:11:20 <kombinator> SamB: You want to do async IO while in GTK?
14:12:06 <SamB> of course, my main dissatisfaction is actually that I can't fiddle with it from GHCi properly...
14:12:15 <SamB> because readline blocks
14:13:01 <musasabi> It should be possible to provide a normal and a -threaded version of a library separately.
14:15:06 <SamB> well, apparantly gtk2hs needs some way of ensuring that all calls happen in the same OS thread... so -threaded was, last I checked, not supported
14:19:00 <musasabi> You could have two versions of it - the normal one for non-threaded and a one using Chans for the threaded case if GHC supported such distinction.
14:23:45 <SamB> musasabi: well, GHC may not support it, but there is a way to do it with FFI that the GHC.Conc module uses...
14:26:23 <SamB> this is funny:
14:26:29 <SamB> #if i386_TARGET_ARCH
14:26:30 <SamB>    = let -- Don't change this without first consulting Intel Corp :-)
14:26:30 <SamB>          bytes_per_word = 4
14:26:45 <musasabi> SamB: The hard thing is that you really want two versions of the library - one for -threaded and one without -threaded.
14:27:21 <SamB> well, thats not very hard
14:27:58 <musasabi> It is if you want different versions of basic datatypes.
14:28:25 <SamB> oh, well, I guess that is...
14:29:23 <SamB> can you do custom checks with cabal, without being kicked out of
14:29:26 <SamB> #haskell?
14:39:42 <musasabi> We are all too busy talking about sex on #haskell-blah ;)
14:41:05 * dcoutts joins #haskell-blah
14:41:44 <dcoutts> SamB, so you're hacking on the threading problem I see
14:41:46 <xerox> dcoutts: is the new gtk release going to be in alioth (deb) repo, and support cairo by default?
14:42:00 <dcoutts> xerox, ask a debian person
14:48:05 <dcoutts> SamB, in the multi-threaded rts is it not possible to block one thread on many FDs? by passing them to the IO manager thread?
14:49:40 <tic|school> I have a newbie problem with Haskell..
14:50:16 <tic|school> Trying to sequence an IO op with a return and a cons, somehow.
14:50:47 <tic|school> What I'm doing right now is:  c' <- thisFunction; return (c:c')
14:51:11 <tic|school> but I think it would be nicer to do it something like:  return $ thisFunction >>= (:) c
14:51:24 <tic|school> but that doesnt work, and I can't figure out how to make it work.
14:51:49 <Yubanalesco> Gah...Damn thing is not working, the worse is that I really don't know why I need to do that...
14:52:13 <Yubanalesco> Why would someone want to return the tail of an empty list...
14:53:06 <heatsink> Related to tic|school's question, is a monadic version of foldr possible while using ocnstant stack space?
14:53:09 <SamB> dcoutts: not actually hacking, but I was taking a look...
14:53:57 <dcoutts> SamB, ok
14:54:13 <tic|school> Yubanalesco: me?
14:54:19 <SamB> maybe I should look at bound threads...
14:54:21 <dcoutts> SamB, if you discover anythig promisng/interesting do let me know
14:54:21 <kolmodin> tic|school: import Control.Monad, liftM2 (:) doOne doTheRest
14:54:31 <kolmodin> tic|school: you still need a base case
14:54:35 <dcoutts> SamB, ah, bound threads. They're not quite what the seem.
14:55:03 <heatsink> oh, so that's what liftM is for.
14:55:06 <dcoutts> SamB, they allow you to bind a new Haskell thread to a new OS thread. We need to bind a new Haskell thread to an existing OS thread.
14:55:17 <SamB> dcoutts: ah
14:55:40 <SamB> that sounds a lot less messy than what I thought I remembered you saying, which was the other way round...
14:55:52 <Yubanalesco> Heh ? I was not referring to anyone. Is just that I am requested to override the regular tail function where it returns the empty list when used on an empty list.
14:56:39 <tic|school> kolmodin, *hmm* that's basicaly what I do, no? c <- doOne; return $ doRest >>= (:) c.  'c' should be lifted now, and so doRest's value?
14:57:31 <tic|school> kolmodin, i.e., doesn't >>= lift?
14:57:45 <kolmodin> tic|school: no, >>= is the bind operator
14:57:51 <kolmodin> tic|school: the sequencer
14:58:02 <heatsink> @type (\x (>>=) . return x)
14:58:03 <lambdabot> bzzt
14:58:06 <tic|school> kolmodin, yeah, I thought it took care of lifting as well. Then that's the problem!
14:58:06 <heatsink> @type (\x -> (>>=) . return x)
14:58:08 <lambdabot> forall (m :: * -> *) a b a1.
14:58:08 <lambdabot> (Monad m, Monad ((->) a1)) =>
14:58:08 <lambdabot> m a -> a1 -> (a -> m b) -> m b
14:58:13 <heatsink> @type (\x -> (>>=) . return . x)
14:58:14 <lambdabot> forall b (m :: * -> *) b1 a.
14:58:14 <lambdabot> (Monad m) =>
14:58:14 <lambdabot> (a -> b1) -> a -> (b1 -> m b) -> m b
14:58:23 <heatsink> that's not it.
14:58:28 <tic|school> kolmodin, thanks!
14:58:46 <kolmodin> tic|school: also, you are returning a monadic function, that's probably not what you want
14:59:04 <kolmodin> tic|school: np, any time
15:00:04 <tic|school> kolmodin, I'm just trying to make it look nicer. Lookking at the AFP course's second week excercises. Finished them, just want to try to implement some parts using bind.
15:01:16 <SamB> hmm, I guess you can't just forkIO threads from the bound thread...
15:01:49 <musasabi> that is not possible sadly.
15:01:51 <kolmodin> tic|school: du är ute i god tid :)
15:02:21 <SamB> musasabi: to whom are you responding?
15:02:59 <Yubanalesco> Is there any way to force Haskell to show "unshowable things" like empty list?
15:03:05 <musasabi> SamB: to your forkIO from bounded thread while keeping the bounding.
15:03:29 <musasabi> @eval []
15:03:30 <lambdabot> Add a type signature
15:03:37 <SamB> musasabi: yeah, I just remembered that forkIO always creates unbound threads...
15:03:44 <musasabi> @eval ([] :: [String])
15:03:46 <lambdabot> []
15:04:39 <tic|school> kolmodin, japp :P
15:05:07 <tic|school> försöker iaf.
15:05:46 <tic|school> kolmodin, line 49 of http://rafb.net/paste/results/AKnhbw32.html
15:06:00 <tic|school> kolmodin, if I want to keep that "style", how would I go about doing it?
15:06:17 <tic|school> kolmodin, or do I have to use liftM2?
15:06:27 <kolmodin> I'll have a look
15:06:50 <tic|school> thanks!
15:07:25 <SamB> okay, this is a bit odd...
15:07:30 <SamB> foreign export ccall forkOS_entry
15:07:30 <SamB>     :: StablePtr (IO ()) -> IO ()
15:07:30 <SamB> foreign import ccall "forkOS_entry" forkOS_entry_reimported
15:07:30 <SamB>     :: StablePtr (IO ()) -> IO ()
15:09:32 <SamB> wonder what is accomplished by calling through C?
15:09:48 <kolmodin> tic|school: you could remove line 48 and change line 47 to: liftM (a:) $ while pred f
15:10:42 <heatsink> Open question:
15:11:14 <heatsink> Do other people here write their recursive functions in a less readable style so they can be sure it uses constant stack space?
15:11:19 <tic|school> kolmodin, thanks! just what I was looking for.
15:11:33 <kolmodin> tic|school: look at the type of liftM
15:11:35 <musasabi> heatsink: only if a profile shows them to be problematic.
15:12:02 <musasabi> usually I just try to write clear and readable code and then worry about performance after profiling.
15:12:17 <heatsink> I don't think of that as a performance issue, though
15:12:31 <heatsink> Because stack overflow isn't the same thing as being slow.
15:12:42 <kolmodin> tic|school: by looking at the types you can often see what the function does. often only one implementation is possible
15:12:54 <SamB> I think I go for using heap space...
15:13:35 <SamB> kolmodin: well, often enough there are more than one possible implementation, but most of them would be stupid...
15:13:37 <tic|school> kolmodin, yeah, I just couldn't figure out how to do that.
15:14:05 <tic|school> kolmodin, forgot I could make a higher-order function out of : by only applying one argument like that.
15:14:12 <kolmodin> SamB: well, yeah, I suppose you can return error "donkey" everywhere :)
15:14:15 <heatsink> But I guess I worry about it more than is typical.
15:14:45 <SamB> heatsink: I think it depends on whether you are writing library code or not..
15:15:03 <kolmodin> tic|school: the (a:) part is a partitial application
15:15:41 <kolmodin> tic|school: sending in "while pred f" is the higher order part
15:15:49 <tic|school> kolmodin, which creates a higher-order function? :P  Yup, that was the term I meant.  Forgot you could do things like that and get a function.
15:15:52 <tic|school> Mhm.
15:15:57 <tic|school> thanks again. :)
15:16:17 <kolmodin> :)
15:16:18 <tic|school> good thing I'm taking this class so I don't have to ask stupid questions. :)
15:16:38 <kolmodin> tic|school: there are no stupid questions :) at least not in this channel
15:16:57 <tic|school> kolmodin, what's the opposite of lift?
15:17:15 <tic|school> hrm, return?
15:17:26 <tic|school> no..
15:17:28 <kolmodin> opposite? I don't know what you mean
15:17:48 <tic|school> something like Monad m => m a -> a
15:18:25 <kolmodin> tic|school:   liftM (a:) func    is equal to do { x <- func ; return (a:x) }
15:18:56 <kolmodin> tic|school: ah, how to get a value out of a monad
15:19:02 <tic|school> kolmodin, exactly!
15:19:18 <kolmodin> tic|school: you would have to run the monad
15:19:24 <tic|school> wrooom!
15:19:33 <tic|school> gotcha.
15:19:35 <kolmodin> :)
15:20:28 <tic|school> okay, this is as much as I can do right now.. the exercises in week 4 is about monad transformators, something I do not know anything about yet.
15:20:34 <kolmodin> tic|school: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html   take a look at evalState
15:20:46 <kolmodin> evalState :: State s a -> s -> a
15:21:00 <tic|school> kolmodin, *nod* I remember now, we used them in our comiler. :P  davve set it up though, so that's why I'm not familiar with it.
15:21:04 <tic|school> Yup.
15:21:59 <tic|school> oops, I need to sleep now.
15:22:08 <kolmodin> tic|school: "State s" is a monad, using a monad of that type and an initial state "s" you'll get a value a
15:22:10 <tic|school> Thanks for the help.. Later! Sleep tight.
15:22:14 <tic|school> *nod*
15:22:16 <kolmodin> tic|school: same here, good night
15:50:24 <dcoutts> ibid, I've got an implemntation of SOE using the older Gdk api.
15:50:38 <dcoutts> darcs get http://haskell.org/~duncan/soe/
15:51:37 <dcoutts> ibid, if you've built gtk2hs with Gtk+ 2.8 then my SOE implemntation will use cairo and otherwise fall back to the Gdk implementation
15:52:13 <dcoutts> it probably needs the latest darcs version of gtk2hs
15:52:32 <dcoutts> but it now means it should work with any version of Gtk
16:03:35 <SamB> okay, how do I build only some of libraries?
16:04:25 <SamB> I don't like having stuff I don't particularly care about (like OpenGL) prevent me from compiling stage2
16:07:06 <SamB> dcoutts: it looks like forkOS doesn't do anything any old code couldn't do easily enough...
16:07:37 <SamB> which is to say, it doesn't do much of anything except make an OS thread and start running Haskell code in it
16:08:43 <SamB> though it does do something a bit odd involving foreign exporting and then reimporting a function...
16:10:25 <Yubanalesco> Is it okay to ask simple questions here ?
16:10:52 <SamB> Yubanalesco: what a silly question! fortunately, I like those ;-). Yes, simple questions are quite welcome.
16:11:16 <Yubanalesco> What is wrong with this piece of art (code):
16:11:17 <Yubanalesco> softtail :: [a] -> [a]
16:11:17 <Yubanalesco> softtail (h:t) = if (null (h:t)) then [] else t
16:11:58 <SamB> Yubanalesco: it only matches arguments that have at least one element
16:12:12 <greenrd> well, the pattern matching will fail so null will never be true
16:12:14 <ndm> softtail x = if null x then x else tail x
16:12:21 <ski_> null (h:t) = True    -- forall h,t
16:12:26 <ski_> bah
16:12:30 <ski_> null (h:t) = False    -- forall h,t
16:12:50 <SamB> Yubanalesco: have you looked at the real tail?
16:13:09 <Yubanalesco> Humm, no, but the idea is me implementing a tail that likes empty list.
16:13:28 <Yubanalesco> Instead of the normal one where Haskell jsut does not show unshowable elements.
16:13:31 <Yubanalesco> Like the empty list.
16:13:50 <greenrd> I have a not-so-simple question. Does anyone know any languages similar to Haskell in which partial functions are illegal?
16:13:56 <greenrd> Because I'm trying to implement one.
16:14:35 <SamB> greenrd: well, you could probably just enable -Wall and -Werror...
16:14:39 <greenrd> heh
16:15:00 <ski_> greenrd : partial as in pattern-match failure, or as in nontermination ?
16:15:05 <ndm> greenrd: total function programming, the david turner paper
16:15:12 <greenrd> ski_: both. I figure I'm going to have to ban general recursion (and thereby turing completeness) as well.
16:15:25 <ski_> charity has only terminating functions
16:15:38 <greenrd> ski_: I'm not sure what degree of proof obligations I want to impose on the programmer.
16:15:42 <ndm> also see http://www-users.cs.york.ac.uk/~ndm/projects/patternmatch.php
16:15:59 <ski_> greenrd : no proof obligation in charity ..
16:16:13 <ndm> that generates and solves proof obligations about pattern match errors
16:16:17 <greenrd> ndm: I've read the Turner paper! :)
16:16:20 <ski_> greenrd : you do recursion with primitive fold and unfold mechanism
16:16:55 <Cale> ski_: are you familiar with laws in Miranda? (Miranda is a trademark of Research Software Inc.)
16:17:17 <SamB> Cale: I really don't think you have to say that whenever you mention Miranda.
16:17:25 <Yubanalesco> Well, true about that. Didn't notice that while I was hoping to not to use the already implemented tail function. But then, it still has the problem that Haskell does not show empty lists.
16:17:26 <greenrd> ski_, so fold is generalised to arbitrary stuff, not just lists?
16:17:32 <Cale> SamB: (It's a joke :)
16:17:33 <SamB> I also don't see how they can trademark what sounds like a pretty generic first name...
16:17:41 <ski_> greenrd : right
16:17:48 <Cale> You trademark things for a particular use
16:17:50 <greenrd> Miranda...
16:17:59 * greenrd has a flashback to Serenity, which he saw last night
16:18:04 <ski_> greenrd : and unfold is generalized to general coalgebraic (possibly infinite) datastructures
16:18:19 <greenrd> cool!
16:18:24 <greenrd> I'll have to check that out
16:18:26 <ski_> Cale : sorry, no .. i'd like to look at them, though
16:18:29 <Cale> So another company with a programming language called Miranda would be a problem, but with a sufficiently different product would be okay.
16:18:35 <gzl> ski_: what are you talking about?
16:18:53 <ski_> (greenrd : and you can't express things like taking the sum of an infinite stream :)
16:19:22 <ski_> gzl : um, the proglang Charity, (as well as laws in Miranda, some)
16:19:29 <gzl> hm, ok
16:19:43 <Cale> ski_: they allowed for arbitrary rules to automatically rewrite values of a type into a partiular form
16:19:51 <SamB> so, could I, say, sell a child named miranda?
16:19:52 <gzl> it isn't the case in haskell?
16:20:04 <greenrd> SamB: lol
16:20:05 <gzl> well that one guy named his kid Google
16:20:08 <gzl> total nut
16:20:09 <greenrd> no!
16:20:16 <greenrd> that's child abuse
16:20:20 <gzl> I mean, I like Google, but come on.
16:20:37 <Yubanalesco> People that want a moment of fame...
16:20:44 <SamB> greenrd: you are supposed to object that slavery is illegal!
16:20:55 <Cale> For instance, integer ::= Zero | Succ integer | Pred integer. Succ (Pred n) => n. Pred (Succ n) => n.
16:21:20 <Cale> A pattern match for Pred x would then only match negative numbers.
16:21:43 <ski_> why ?
16:22:01 <ski_> surely Pred x should match Zero, binding x to Succ Zero ?
16:22:21 <Cale> no, because the rewrite rules would be applied first
16:22:34 <greenrd> SamB, I was referring to the kid named Google, not the sale of a girl called Miranda.
16:22:39 <ski_> (another thing is if we played some with subtypes ..)
16:22:55 <SamB> greenrd: oh
16:23:06 <Cale> and those two are sufficient to put any value in the type into the form Succ (Succ ... (Succ Zero))...) or Pred ... (Pred Zero)
16:25:03 <syntaxfree> there's an indian tribe called Haskell.
16:25:14 <greenrd> Cale: So basically, you'd try to construct Pred (Succ Zero) and it'd automatically rewrite that as Zero? Weird.
16:25:24 <Cale> greenrd: yes
16:26:05 <syntaxfree> so Miranda (TM) has features that Haskell hasn't?
16:26:29 <greenrd> Cale: Values whose type changes at runtime give me the heebie-jeebies. Although, in Haskell terms the type hasn't changed, in my language, types can discriminate between constructors in the same data declaration.
16:27:03 <Cale> greenrd: the type hasn't changed at all here
16:27:16 <Cale> It's that the type integer is a quotient of a free type
16:27:33 <greenrd> Sorry, you've lost me there - not familiar with those terms.
16:27:34 <ski_> types /= constructors :)
16:28:13 <syntaxfree> I tend to see Haskell as a  superset of Miranda. Maybe because the syntax is so similar.
16:28:16 <Cale> here's another fun example: olist ::= Onil | Ocons num olist, Ocons a (Ocons b x) => Ocons b (Ocons a x), a > b
16:28:38 <Cale> These are lists which automatically order themselves
16:28:52 <Cale> ohead (Ocons a x) = a
16:29:02 <Cale> this is equivalent to finding the minimum of the list
16:29:07 <SamB> syntaxfree: maybe also because it has both X and Y chromosomes, whereas Miranda only has two X chromosomes?
16:29:12 <ski_> hm, aha, the rewrite rules are directed
16:29:13 <greenrd> That's kinda like... object-oriented programming.
16:29:35 <greenrd> Or, in general, abstracting the interface of a constructor from its implementation.
16:30:06 <Cale> well, this is related to views, but it's not quite the same
16:30:48 <ski_> another feature i imagined would be to cache functions over a datatype
16:31:18 <ski_> so, if you do  data MyList a = Nil | Cons a (MyList a)
16:31:23 <Cale> yeah, you can write memoising structures
16:31:30 <ski_> and had a myLength :: MyList a -> Integer
16:31:44 <ski_> then you could cache myLength *in the datastructor*
16:31:49 <ski_> data constructor
16:32:10 <Cale> yes
16:32:11 <ski_> so, implementation-wise, this would add an extra field to the constructors
16:32:20 * Yubanalesco coughs
16:32:21 <greenrd> OOP was there first ;)
16:32:28 <Yubanalesco> Is there anyway to stop this?:
16:32:28 <Yubanalesco> ERROR - Cannot find "show" function for:
16:32:28 <Yubanalesco> *** Expression : softtail []
16:32:28 <Yubanalesco> *** Of type : [a]
16:32:45 <ski_> except, in this case, it should really suffice to have the length at top, since you can reconstruct the length of the tails
16:32:55 <greenrd> Yubanalesco, I think the problem is you can't show arbitrary values.
16:32:56 <Cale> Yubanalesco: specify what type of empty list you mean
16:32:58 <Yubanalesco> Well, I do understand that Haskell does not like to do that, but I am forced to :P
16:33:20 <Cale> softtail ([] :: [Int])
16:33:36 <ndm> softtail ""
16:33:51 <Yubanalesco> Well, I just wanted Haskell to show an empty list, just trying to make a tail function where it returns an empty list instead of error.
16:33:57 <ski_> Yubanalesco : this is almost always only a problem when trying things in an interactive toplevel .. in most other circumstances, there should be no problem writing code like that
16:34:45 <Cale> Yubanalesco: it's that it's trying to print something and it doesn't know what type it is, so it doesn't know what "show" function to call
16:35:13 <Cale> @type []
16:35:15 <lambdabot> forall a. [a]
16:35:21 <Yubanalesco> softtail x = if (null x) then [] else tail x
16:35:23 <glasser> hmm. in parsec is there a way to get some of the standard token parsers (like the floating point, etc) but not as lexeme (whitespace-skipping)?
16:35:24 <greenrd> In my (unimplemented) language, that would work.
16:35:35 <Cale> Yubanalesco: yep, that works
16:35:35 <Yubanalesco> Hard to say what type it is, when it should be a [a] -> [a]
16:35:41 <ski_> 'show ([] :: [Int])' gives different result than 'show ([] :: [Char])', so it really makes a difference
16:36:21 <Cale> Yubanalesco: yeah, softtail :: [a] -> [a]
16:36:52 <Cale> and if the the input to softtail is an empty list, that doesn't nail down what 'a' is.
16:37:04 <SamB> my, .hc files look very like assembler!
16:37:06 <greenrd> In my language, the type of softtail [] would be just []
16:37:20 <Yubanalesco> Yeah, same as proLog would do...
16:37:29 <greenrd> because my language can discriminate between constructors in the same data declaration
16:37:31 <Yubanalesco> But then Haskell, seems to be a bit picky on that.
16:37:42 <Cale> Yubanalesco: picky?
16:38:01 <Yubanalesco> Well, just because [] is not inside show
16:38:06 <Yubanalesco> I can't show it :P
16:38:22 <ski_> greenrd : 'discriminate between constructors in the same data declaration' meaning ?
16:38:24 <Cale> Yubanalesco: well, [] :: [a] for any a
16:38:25 <greenrd> and can relate the type of the input to the type of the output in more complex ways (restricted dependent types, I guess)
16:38:43 <nuffer> with parsec
16:38:44 <Cale> Yubanalesco: the problem isn't that there isn't a show instance, it's that there are many show instances
16:38:48 <nuffer> let's say I'm parsing if-else statements
16:38:50 <greenrd> ski_, meaning the type [a] has subtypes [] (empty list) and :a (nonempty list)
16:39:00 <nuffer> and I have an "ifClause" and "elseClause" parser
16:39:15 <greenrd> ski_, actually it's more complicated than that, I have "metrics" (optional type parameters which measure the length of a list)
16:39:16 <Yubanalesco> Ahh...
16:39:18 <ski_> Yubanalesco : there are things that one can't show sensibly .. like functions  (except showing them like "<function>" which is not very informative)
16:39:19 <nuffer> how do I combine them to return an ifStatement if there is no else clause, and an ifElseStatement if there are both?
16:39:26 <ski_> greenrd : ah
16:39:31 <Cale> greenrd: doesn't subtype polymorphism not play well with HM?
16:39:42 <greenrd> HM?
16:39:49 <Cale> Hindley-Milner
16:40:20 <greenrd> heh, well, I'm a complete amateur - I need to learn type theory.
16:40:46 <Cale> I seem to recall that it breaks something, perhaps the definition of most general unifier.
16:41:43 <Yubanalesco> So, if I want to show the empty list I must assign some sort of type to the empty list, as someone pointed out, like [] :: [Int] ?
16:41:46 <nuffer> I guess assign the result of the else clause parser
16:41:50 <nuffer> and if it's left, ignore it?
16:41:56 <Cale> Yubanalesco: yeah
16:42:08 <greenrd> Yubanalesco, for the input, not the return value.
16:42:28 <Cale> for either
16:42:37 <greenrd> Yubanalesco, then it gets propagated out to the return value's type, which then becomes [Int] instead of for all a . [a]
16:42:59 <Yubanalesco> Well, which is not good!
16:43:09 <greenrd> sorry
16:43:10 <greenrd> what I meant was
16:43:16 <Cale> @eval let softtail x = if null x then [] else tail x in (softtail []) :: [Int]
16:43:18 <lambdabot> []
16:43:19 <Yubanalesco> Humm, can I still force the return value to continue to be [a] ?
16:43:25 <Cale> @eval let softtail x = if null x then [] else tail x in softtail ([] :: [Int])
16:43:27 <lambdabot> []
16:43:29 <greenrd> don't put the type constraint in the definition
16:43:43 <Cale> right, softtail is still [a] -> [a]
16:43:50 <greenrd> put it in the evaluation of your particular test case
16:43:54 <Cale> it's just that the test input changes
16:44:34 <Cale> note that, as I showed, you can do it either way
16:44:49 <Cale> that is, you can specify the type of the input to softtail
16:44:53 <Cale> or the type of the result
16:45:13 <Yubanalesco> Humm, never learnt anything about @eval
16:45:45 <Cale> Lambdabot has the @eval command so that we can evaluate Haskell expressions in the channel
16:45:53 <Cale> @eval product [1..10]
16:45:55 <lambdabot> 3628800
16:46:14 <Cale> @type \x -> if null x then [] else tail x
16:46:16 <lambdabot> forall a. [a] -> [a]
16:47:07 <Yubanalesco> Oh!
16:47:07 <Cale> @pl \x -> if null x then [] else tail x
16:47:08 <lambdabot> ap (flip if' [] . null) tail
16:47:52 <Cale> heh, @pl is the automatic Haskell code simplifier/obfuscator
16:48:33 <Cale> it rewrites lambda expressions into a form where the value being acted on isn't mentioned
16:49:47 <Cale> if you're going to try that code, beware if' isn't in the prelude, it's defined as  if' b t e = if b then t else e
16:49:51 <greenrd> Cale: Anything that has multiple inheritance is going to have an ambiguity problem to solve or patch around with type inference. Don't Haskell type classes have multiple inheritance, and aren't they therefore vulnerable to the problem you mentioned?
16:50:46 <Cale> greenrd: no, they don't -- they could only possibly have that problem if you turn on overlapping instances, and I can't recall what happens if instances actually overlap
16:51:25 <greenrd> Then you have to turn on incoherent-instances, and pray ;)
16:51:29 <SamB> Cale: the earth will blow up
16:52:07 <Cale> Something like  class Eq a => Num a  doesn't mean that writing an instance of Num automatically gives an instance of Eq. It means that you have to write an instance of Eq before you're allowed to write an instance of Num.
16:52:09 <ski_> somewhere a programmer will turn their back on functional programming
16:52:23 <greenrd> Cale: Yes, I know.
16:52:25 <sh10151> imagine every molecule in your body exploding at the speed of light
16:52:43 <sh10151> total protonic reversal
16:53:04 <greenrd> ski_: probably the programmer who tried to create "incoherent" instances and doesn't understand why he can't
16:53:29 <Cale> http://www.haskell.org/ghc/docs/6.4.1/html/users_guide/type-extensions.html#instance-overlap -- yeah, this has a good overview
16:53:37 <Cale> that's all experimental though
16:53:40 <greenrd> Cale: What I meant was, class (Foo a && Bar a) => Goo a
16:53:57 <Cale> yeah?
16:54:07 <Cale> there's no ambiguity there
16:54:15 <ski_> s/&&/,/
16:54:27 <heatsink> instance (Foo a, Bar a) => Goo a where
16:54:38 <heatsink> s/instance/class/
16:54:44 <Cale> hehe
16:54:46 <heatsink> what ski_ said
16:54:48 <heatsink> ignore me
16:55:20 <greenrd> Oh, because the conjunction (Foo a, Bar a) is a type in Haskell?
16:55:25 <greenrd> Or no?
16:55:26 <Cale> not a type
16:55:33 * heatsink imagines every molecule in its body exploding at the speed of light, but takes infinitely long to do it
16:55:33 <Cale> It's a valid class constraint
16:55:42 <greenrd> Then you'll have a problem with diamond inheritance, I think.
16:55:46 <Cale> no
16:56:00 <Cale> Because 'a' is one particular type in all of this
16:56:02 <greenrd> Oh sorry
16:56:14 <greenrd> Brain not working
16:56:24 <greenrd> Classes != types
16:56:33 <Cale> right
16:58:09 <Cale> Typeclasses are not really anything like OO classes beyond a pale resemblance, and the similarity of words used.
16:58:36 <greenrd> OK
16:58:42 <ski_> also
16:59:35 <greenrd> well, anyway, in my current language design the constructor-discriminating types only have one level of inheritance, and are combinable
16:59:35 <ski_> multiple inheritance is not very much a problem with interfaces (/abstract base classes) .. as opposed to (nonabstract) classes
16:59:59 * heatsink loves typeclasses, now that it understands them.  They're better for abstracting data than classes or interfaces or APIs.
17:00:09 <greenrd> You can obviously represent the conjuction of the empty list type and an non-empty list type as just a normal list type
17:00:22 <SamB> heatsink: you have no gender?
17:00:34 <Cale> SamB: it's just a heatsink
17:00:38 <heatsink> right.
17:00:59 <greenrd> Representing the conjunction of some but not all constructors is a little more tricky, but I think doable, because I allow arbitrary functions to be attached to types :)
17:01:31 <Cale> "Want cool processor. Happy every day to take heat from processor and give to fan."
17:01:32 <ski_> greenrd : s/conjunction/lub/
17:02:11 * heatsink likes places that are hot on one side and cold on the other
17:02:14 <Cale> ski_: isn't it the same thing here?
17:02:15 <greenrd> ski_: huh?
17:02:16 <syntaxfree> is there a way in ghci to see the list of functions in a .hs I just :loaded?
17:02:19 <SamB> heatsink: how did you achieve sentience?
17:02:32 * heatsink wishes McDonalds still served BLTs
17:02:54 <heatsink> *DLTs
17:03:22 <ski_> well .. if i interpret 'conjunction' as 'pair-type' then it seems wrong .. if i interpret 'conjunction' as 'intersection type' then it also seems wrong
17:03:28 <heatsink> SamB: Through lots of hard work.
17:03:51 <ski_> syntaxfree : ':browse Module'
17:04:01 <Cale> ski_: I suppose that disjunction is probably a better term
17:04:04 <syntaxfree> where Module iis..
17:04:04 <heatsink> SamB: how did you achieve sentience?
17:04:05 <ski_> yes
17:04:10 <greenrd> ski_: Oh... I mean disjunction, don't I?
17:04:17 <syntaxfree> ahahhh
17:04:19 <syntaxfree> I see.
17:04:22 <ski_> greenrd : prolly
17:04:28 <syntaxfree> goody.
17:05:36 <ski_> (one of the word 'meet' and 'join' is standard term for this, i think .. the trouble is that i can never remember which is which)
17:05:42 <greenrd> heh
17:06:04 <liyang> join is disjunction...
17:06:07 <liyang> I think.
17:06:09 <liyang> :-/
17:06:21 * ski_ thinks much
17:06:33 <heatsink> ski_: It depends on the exact lalgorithm.
17:06:47 <ski_> what depends on that ?
17:06:55 <ski_> which of them to use ?
17:06:59 <heatsink> whether meet is conjunction or disjunction.
17:07:15 <ski_> oh
17:07:19 <heatsink> Meet moves things toward _|_ and Join moves things toward T
17:07:39 <ski_> T should be the maximal supertype
17:07:39 <heatsink> Actually, let me check that
17:07:55 <greenrd> The problem is the ambiguity between the intentional descriptions of sets or types (in which conjunction is set intersection) and the extensional descriptions (in which conjunction is, arguably, set union)
17:07:56 <heatsink> yes, that's right
17:07:57 <ski_> (e.g. empty record type)
17:08:17 <Cale> ski_: if you wanted to be strange, you could flip the lattice upside down of course :)
17:08:25 <syntaxfree> any standard prelude function that will yield the largest value in a list?
17:08:26 <greenrd> I was thinking in terms of extensional descriptions, hence why I used the word conjunction.
17:08:42 <greenrd> syntaxfree, maximum, I don't know if it's a prelude function tho
17:08:44 <Cale> syntaxfree: maximum
17:08:58 <Cale> @eval maximum [1,2,3,4,5,4,3,2,1]
17:08:58 <syntaxfree> @type maximum
17:09:04 <lambdabot> 5
17:09:05 <lambdabot> forall a. (Ord a) => [a] -> a
17:09:08 <syntaxfree> let's bet on who got there first.
17:09:09 <syntaxfree> oh you did.
17:09:10 <syntaxfree> :~
17:09:44 <greenrd> I probably spelled intensional wrong, as well.
17:10:14 <syntaxfree> ok. in one sentence, how do I put a function in a module other than Main?
17:10:23 <Cale> module Foo where
17:10:29 <ski_> i don't get this intensional vs extensional business ..
17:10:29 <syntaxfree> thanks.
17:10:33 <Cale> write at the top of your module :)
17:10:33 <syntaxfree> do I need to indent?
17:10:45 <Cale> and put into another file
17:10:46 <Cale> no
17:10:53 * ski_ always indents :)
17:10:56 <syntaxfree> yes, I'm putting it into another file.
17:11:15 <Cale> ski_: really?
17:11:16 <syntaxfree> I have a "formatter" collection of functions that puts things in a way gnuplot can read them.
17:11:28 <greenrd> ski_: intensional definition is of the form "all x where property p holds of x"; extensional definition is of the form "[1, 4, 8, 29]" - an explicit list of each and every element
17:11:32 <ski_> Cale : sure :)
17:11:39 <Cale> ski_: that's an unusual thing to indent after
17:11:55 <Cale> since you're going to indent all but one line of your source files
17:12:15 <syntaxfree> then, in the main file, import Foo?
17:12:17 <ski_> i can comment out code nicely, without having to change columns
17:12:24 <syntaxfree> import Foo.hs?
17:12:30 <Cale> import Foo
17:12:43 <syntaxfree> how is it gonna know where to import foo from?
17:12:44 <heatsink> isn't extensional a special case of intensional?
17:13:06 <greenrd> ski_: Informally, I was thinking, the conjunction of two types means combining their extensions. Which is probably ass-backwards to how most people would interpret it.
17:13:37 <syntaxfree> lastly, do I have to do anything with the syntax because of scope (like using Foo.func instead of func), or that's autohandled?
17:14:05 <ski_> greenrd : oh ..
17:14:07 <greenrd> heatsink, Not really, they mean the same thing but they look different. The definition is syntactic not semantic (since semantically the definitions are the same).
17:14:16 <greenrd> If you see what I mean.
17:14:23 <syntaxfree> @eval print "a\nb"
17:14:25 <lambdabot> No IO allowed
17:14:31 <syntaxfree> @eval show "a\nb"
17:14:33 <lambdabot> "\"a\\nb\""
17:14:48 <syntaxfree> Hmm. How do I escape a carriage return, then?
17:14:49 <greenrd> Obviously at some level the distinction between intensional and extensional is semantic as well as syntactic.
17:14:52 <heatsink> greenrd: I don't see how you'd define a countably infinitely set extensionally.
17:15:00 <Cale> syntaxfree: it looks in the same directory, and for hierarchical modules, in subdirectories
17:15:14 <Cale> syntaxfree: your module has to be named the same as the file that it's in
17:15:17 <greenrd> But not at the level of evaluating the definitions.
17:15:27 <syntaxfree> yeah, I experimented and saw.
17:16:04 <greenrd> heatsink, with some ...s.
17:17:22 <syntaxfree> @hoogle intersperse
17:17:23 <lambdabot> List.intersperse :: a -> [a] -> [a]
17:18:40 * heatsink isn't convinced, but my reservations are probably not worth going into.
17:18:51 <greenrd> Yeah, it's a silly argument.
17:19:01 <greenrd> I was just explaining my pratfall :)
17:19:08 <greenrd> Or trying to
17:19:13 <greenrd> I'll stop digging now!
17:19:16 <heatsink> ok
17:19:31 * ski_ doesn't really like things like 'this set of assumptions entails this conclusion'
17:19:46 <syntaxfree> that's what science is all about.s
17:20:00 <syntaxfree> science is not about the truth, is about playing with assumptions and conclusions :)
17:20:46 <greenrd> I thought that was math.
17:20:54 <syntaxfree> math is not even science.
17:21:11 <greenrd> Science wants to know whether the universe really is open or closed - math just asks what would happen if it was.
17:21:15 <syntaxfree> I have a friend that says math is an epistemological phenomenology that bridges philosophy and science.
17:21:26 <ski_> (point being that a set doesn't 'imply' anything .. a set, which you fold with conjunction otoh can imply something)
17:21:26 <greenrd> was open.
17:21:27 <greenrd> gah
17:21:35 <greenrd> time for bed.
17:24:16 <syntaxfree> @eval unlines [1..5]
17:24:18 <lambdabot>  add an instance declaration for (Num String)
17:24:18 <lambdabot>   In an arithmetic sequence: [1 .. 5]
17:24:32 <syntaxfree> @eval unlines $ map show [1..5]
17:24:34 <lambdabot> "1\n2\n3\n4\n5\n"
17:24:45 <syntaxfree> I need those to be in actual lines :~
17:25:01 <syntaxfree> @pl f v = ulines $ map show v
17:25:02 <lambdabot> f = ulines . map show
17:25:33 <ski_> 'be in actual lines' ?
17:29:07 <syntaxfree> yes.
17:29:12 <syntaxfree> I need to print a list...
17:29:15 <syntaxfree> one value per line.
17:29:30 <ski_> that obviously needs IO
17:29:37 <ski_> @eval length "\n"
17:29:39 <lambdabot> 1
17:29:47 <syntaxfree> hmm.
17:29:59 <ski_> e.g. just putStr that list with newlines in it
17:30:01 <syntaxfree> print "1\n\2" yields just that, "1\n2 "
17:30:07 <ski_> putStr
17:30:09 <syntaxfree> hmm. putStr
17:30:11 <syntaxfree> I'll see.
17:30:27 <syntaxfree> bingo.
17:30:29 <heatsink> I think that print = putStr . show
17:30:34 <ski_> print a = putStrLn (show a)
17:30:35 <syntaxfree> :)
17:30:39 <ski_> :)
17:30:47 <syntaxfree> yes, I just got accustomed to use "print" mindlessly.
17:30:49 <syntaxfree> thanks!
17:31:54 <syntaxfree> by the way, anyone conversant in gnuplot?
17:39:16 <heatsink> I've used it once or twice
17:39:44 * heatsink looks for the old gnuplot scripts
17:40:46 <heatsink> from python
17:44:26 <syntaxfree> @pl listofmaxes n =  [collatzMax x | x<-[1..10000]]
17:44:28 <lambdabot> listofmaxes = const [collatzMax x | x <- [1..10000]]
17:44:34 <syntaxfree> oops.
17:44:38 <syntaxfree> listofmaxes n =  [collatzMax x | x<-[1..n]]
17:44:56 <syntaxfree> @pl listofmaxes n =  [collatzMax x | x<-[1..n]]
17:44:56 <lambdabot> listofmaxes = return . ((collatzMax x | x) <-) . enumFromTo 1
17:45:16 <syntaxfree> @pl listofmaxes n = map collatzMax [1..n]
17:45:17 <lambdabot> listofmaxes = map collatzMax . enumFromTo 1
17:45:48 <syntaxfree> enumFromTo is a handy one.
17:46:40 <heatsink> @hoogle (<-)
17:47:03 <syntaxfree> @pl countmaxes m n = count (==m) (listofMaxes n)
17:47:04 <lambdabot> countmaxes = (. listofMaxes) . count . (==)
17:47:08 <heatsink> That's not an operator, is it?
17:47:27 <syntaxfree> <- comes up in list comprehensions.
17:47:38 <heatsink> Yes
17:47:50 <heatsink> I meant, is it a regular operator or a special syntax?
17:49:08 <ski_> syntax
17:49:30 <ski_> used in list comprehensions, and do-notation
17:49:55 <ski_> (and, yes, @pl doesn't understand it, currently)
17:49:59 <syntaxfree> @pl count p l = length $  filter p l
17:50:00 <lambdabot> count = (length .) . filter
17:50:18 <syntaxfree> why wouldn't length.filter suffice?
17:50:38 <ski_> since you want to "bypass" *two* curried arguments
17:50:47 <syntaxfree> hmm.
17:50:54 <ski_> @type let (.:) = (.) . (.) in  length .: filter
17:50:56 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
17:50:57 * syntaxfree goes for the point-full version
17:51:41 <ski_> @type length . uncurry filter
17:51:42 <lambdabot> forall a. (a -> Bool, [a]) -> Int
17:51:48 <ski_> @type curry (length . uncurry filter)
17:51:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
17:51:55 <ski_> that also works
17:52:41 <ski_> night #haskell
17:52:42 <glasser> Oh man.  Parsec is *so nice*.
17:52:43 <musasabi> pointfree programming is missing the point about programs being readable many times.
17:53:39 <ski_> (yes .. but pointfree is sometimes easier to reason about and manipulate with laws (not to speak of diagrams) .. free variables complicate this)
17:54:22 <syntaxfree> I want to _understand_ the point-free style.
17:54:31 <syntaxfree> once I'm conversant in it, I'll be ready to abandon.
17:55:03 <musasabi> it is function composition in the math sense.
17:55:11 <syntaxfree> I know.
17:55:38 <ski_> (plus other combinators)
17:55:46 <syntaxfree> yeah, I know.
17:55:56 <syntaxfree> I want to be fluent in pointfree notation :)
17:57:10 <ski_> (pointfree vs. pointful expressions is a bit similar to hilbert-style versus natural-deduction-style proofs)
18:02:23 <heatsink> Pointfree notation gets messy when a function argument is used more than once.
18:03:08 <syntaxfree> @pl f x = (x,x)
18:03:09 <lambdabot> f = join (,)
18:03:18 <syntaxfree> @pl f x = [x,x,x]
18:03:19 <lambdabot> f = ap (:) (ap (:) return)
18:03:44 <heatsink> @pl let inters x ys = case ys of {[] -> []; (y:ys') -> y:x:inters x ys'} in inters
18:03:45 <lambdabot> (line 1, column 30):
18:03:45 <lambdabot> unexpected "{"
18:03:45 <lambdabot> expecting variable, "(", operator, ";" or "in"
18:03:47 <glasser> return? huh, what's that doing in there?
18:04:39 <heatsink> There's a reader monad involved, which turns the argument "x" into monadic state so it can be read multiple times
18:05:14 <heatsink> @pl let inters x ys = case ys of [] -> []; (y:ys') -> y:x:inters x ys' in inters
18:05:15 <lambdabot> (line 1, column 33):
18:05:15 <lambdabot> unexpected ">"
18:05:15 <lambdabot> expecting variable, "(", operator, ";" or "in"
18:05:28 <heatsink> @pl let inters x ys = case ys of ([] -> []; (y:ys') -> y:x:inters x ys') in inters
18:05:29 <lambdabot> (line 1, column 34):
18:05:29 <lambdabot> unexpected ">"
18:05:29 <lambdabot> expecting variable, "(", operator or ")"
18:06:05 <heatsink> @pl let inters x [] = []; inters x (y:ys) = y:x:inters x ys' in inters
18:06:06 <lambdabot> (line 1, column 14):
18:06:06 <lambdabot> unexpected "["
18:06:06 <lambdabot> expecting pattern or "="
18:20:42 <syntaxfree> you don't feed lets to @pl.
18:21:51 <dons> @pl let x = 1 + 2 in x
18:21:52 <lambdabot> 3
18:22:13 <syntaxfree> oh. mo'fool me.
18:22:27 <syntaxfree> so, I can't compile lambdabot.
18:22:33 <syntaxfree> actually, I can, but it doesn't run.
18:22:51 <dons> what does it do instead?
18:24:24 <syntaxfree> not-runs.
18:24:35 <syntaxfree> just a min, i'll paste the error message. 'tis short.
18:24:46 <dons> do you have the darcs version of hs-plugins?
18:24:55 <syntaxfree> yes.
18:25:01 <syntaxfree> Main.o: unknown symbol `___stginit_GHCziTopHandler_'
18:25:01 <syntaxfree> lambdabot: user error (resolvedObjs failed.)
18:25:12 <dons> hmm. and this is on a mac?
18:25:26 <syntaxfree> it is under OS X, yes.
18:25:37 <dons> ghc --version?
18:25:40 <syntaxfree> 6.4.1
18:26:43 <dons> what does: $ nm ~/lib/ghc-6.4.1/HSbase.o | grep stginit_GHCziTopHandler
18:26:53 <dons> do? (replace ~ with the path to your ghc libs)
18:28:29 <glasser> haskell doesn't have "heredocs", does it?
18:29:01 <syntaxfree> emergency.
18:29:05 <syntaxfree> sorry, I hafta go.
18:30:40 <heatsink> hmm.
18:51:21 <smitty1e> Newby question.  Haskell School of Expression, pg. 29:  I see a recursive polyArea function.  Its type definition states polyArea :: [Vertex] -> Float.  The next line shows it called with three arguments on the lhs, and calling itself recursively with two arguments on the rhs.  Does the implementation unpack enough Vertex elements from the list to match the lhs signature, until it no worky-worky anymore, when the wildcard patte
18:51:21 <smitty1e> rn lets it return 0?
18:53:57 <dons> hmm, you'd have to paste the code, but most likely it is indeed calling itself recursively with successively smaller chunks of the [Vertex] list, until finally it hits []
18:54:21 <dons> @eval let f [] = 0 ; f (x:xs) = 1 + f xs in f "haskell"
18:54:27 <lambdabot> 7
18:55:27 <araujo> Hello haskell'ers!
18:55:40 <dons> hey araujo
18:55:50 <araujo> Hello dons , what's up?
18:56:14 <dons> busy trying to build ghc on powerpc/openbsd :)
18:56:20 <araujo> :-)
18:57:42 <smitty1e> polyArea :: [ Vertex ] -> Float
18:57:42 <smitty1e> polyArea (  v2 : v3 : vs' ) = triArea v1 v2 v3 + polyArea(  v3 : vs' )
18:57:42 <smitty1e> polyArea  _        = 0
18:57:42 <smitty1e>  
18:57:50 <smitty1e> Im
18:58:21 <smitty1e> I'm just bothered by the asymmetry of the lhs to the rhs, as I go for my hellow belt here. ;)
18:58:27 <likens_> dons, which version of ghc comes with openbsd 3.8 ?
18:58:35 <dons> 6.2.2 at the moment
18:58:52 <likens_> thanks.
18:59:04 <dons> but it's easy enough to get either 6.4.1 or 6.5 from http://www.cse.unsw.edu.au/~dons/haskell_openbsd.html
18:59:13 <heatsink> smitty1e: it's taking v2 off the head of the list.
18:59:38 <likens_> which do you recommend?  I'm using 6.4.1 on OS X.
18:59:53 <heatsink> smitty1e: But only if the list contains at least two vertices.
19:00:41 <smitty1e> heatsink: so, the implementation can pull rabbits out of the list hat until the list hat is exhausted?
19:00:51 <dons> well, 6.2.2 is nice and stable. there's no need to explicitly get 6.4.x unless you have some particular need, and even less so with 6.5
19:01:08 <dons> but if you already have  6.4.1 that's ok
19:01:30 <heatsink> smitty1e: not sure what you are describing
19:01:41 <likens_> ok, thanks.
19:01:51 <heatsink> smitty1e: are you asking how that translates to implementation?
19:01:53 <dons> smittyl,e it takes apart the list in the patterrn: (v2:v3:vs')
19:02:09 <dons> that `takes' 2 elements of the list, leaving the rest in vs'
19:02:19 <dons> it then calls polyArea again with (v3:vs')
19:02:31 <dons> so essentially 1 element is consumed each time around
19:03:17 <smitty1e> dons: thanks.  thought that's what was happening, but there is othen subtlety in simplicity...
19:03:33 <dons> no no, it's just haskell, so it is all simple :)
19:03:36 <dons> not tricks :)
19:03:49 <smitty1e> dons: I heard tricks are for kids.
19:14:45 <metaperl> nibro: URL to your thesis?
19:14:54 <metaperl> anyone have the URL to nibro's thesis?
19:15:01 <metaperl> on haskell server pages
19:15:32 <dons> yeah, hmm, let me see..
19:16:26 <dons> note that there's also a recent HW paper on HSP
19:16:39 <dons> thesis, http://www.cs.chalmers.se/~d00nibro/hsp/thesis.ps
19:16:44 <metaperl> ick, no pdf?
19:16:47 <dons> paper, http://www.cs.chalmers.se/~d00nibro/hsp/hsp-hw05.ps
19:16:50 <dons> (and .pdf)
19:17:00 <dons> s/ps$/pdf/
19:17:55 <metaperl> dons: thanks
19:18:07 <dons> don't thank me, thank google ;)
19:18:46 <metaperl> google pointed me to the one without hsp in the URL
19:19:02 <metaperl> http://www.cs.chalmers.se/~d00nibro/thesis.pdf
19:19:05 <metaperl> which is broken
19:19:10 <dons> @google haskell server pages
19:19:11 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp/
19:19:16 <dons> there we go!
19:20:05 <metaperl> ah
19:20:29 <dons> @where hsp
19:20:30 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
19:20:35 <dons> oh, even simpler :S
19:22:33 <dons> interferon, morning/afternoon/night! have you seen:
19:22:34 <dons> @map
19:22:34 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
19:22:51 <dons> ChronoWiz! you too! add yourself to @map if you like :)
19:23:45 <dons> we don't have any melbourne uni people yet :/
19:24:12 <heatsink> so what's with haskell and nsw?
19:24:21 <heatsink> *unsw
19:24:54 <dons> we have a research group here :) and we teach haskell to 100s of first year students
19:25:53 <dons> so we get to brain wash them before they ever hear about java ;)
19:25:59 <heatsink> You can tell a lot about a cs program by what language they teach in the introductory cs course :)
19:26:12 <Philippa_> Oxford do that too, though apparently the level of proof they work with's rather tedious
19:26:29 <Philippa_> UoN does Java through the first year with Haskell in the second semester of it
19:26:40 <heatsink> I remember caltech uses scheme, and here I think they switched from C to java recently.
19:26:46 <Philippa_> you get the chance to do Epigram in the second year though
19:26:51 <dons> huh!
19:27:00 <Philippa_> dons: it's being developed here :-)
19:27:27 <dons> right, ah, so similarly you get a lot of, e.g, Isabelle here
19:27:42 <dons> (though not so much for undergrads :/)
19:28:25 <Philippa_> we only get a 10 credit optional module
19:30:03 <dons> xinming! hi! have you seen:
19:30:04 <dons> @map
19:30:05 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
19:30:10 <dons> I think you should add your details :)
19:30:42 <heatsink> oh cool
19:32:32 <xinming> Oh, cool...
19:32:35 <xinming> I am In China. :-P
19:32:48 <dons> yeah, I guessed ;)
19:33:07 <dons> and we currently have no .cn spots on the map!
19:34:59 <xinming> dons: hmm, How do I add my own info?
19:35:20 <Cale> there's a list lower down on the page
19:35:33 <Cale> You might have to be logged in to the wiki to change it
19:35:51 <dons> or else just /msg me your coords, and i'll add them
19:37:57 <xinming> hold on please.
19:42:19 <Julianus> Hi guys
19:42:48 <Julianus> hi lambdabot
19:43:05 <lambdabot> hi Julianus!
19:43:21 <Julianus> ;)
19:54:47 <xinming> longitude is...
19:55:02 <xinming> 120. 57
19:55:09 <xinming> hmm, I don't know if it's right... :-)
19:55:38 <xinming> the value is right, But I don't know how to say it in English. :-(
19:56:01 <Julianus> mmmmm?
19:57:57 <dons> cool, 120.57 sounds right
19:58:01 <dons> what about latitude?
20:01:41 <xinming> 120.94  	28.14
20:01:50 <xinming> longitude is the previous one,
20:01:56 <xinming> and latitude is the second...
20:02:20 <dons> yep :) I'll add it!
20:02:29 <xinming> real thanks.
20:04:19 <dons> the map will update in about 3minutes
20:09:47 <xinming> great thanks... :-)
20:19:47 * SamB attempts to launch his evil plan
20:21:18 <dons> oh no!
20:22:05 <SamB> actually, I'm just trying to make that thing dcoutts wants where you can have more than one thread bound to the same OS thread ;-)
20:22:22 <SamB> I've started GHC a-building
20:23:05 <Cale> How is that managed on the program side of things?
20:23:06 <heatsink> just to be safe, disconnect your computer from the network and plug it into a surge protector before you run it.
20:23:29 <SamB> oh, okay, so I either need to import Foreign.Ptr, or I can just replace it with a...
20:25:59 <SamB> Cale: I have no idea if this will actually work or not, but I stuck a function in Control.Concurrent with the same type as forkIO and forkOS that should give a thread bound to the same thread as the thread it is called in is bound to...
20:27:42 <SamB> note that this does *not* make me a compiler hacker, as I only hacked the RTS and the library
20:27:54 <SamB> and I haven't even gotten it to compile yet
20:30:50 <Cale> hehe
20:34:59 <SamB> this might not even be thread safe, in the presence of killing!
20:39:38 <SamB> also, a compiler hacker would probably do this with primitives, not probably-way-off FFI...
20:42:16 <SamB> don't suppose anyone knows how to write primitives?
20:43:34 <dons> ah, there's a document on this somewhere..
20:43:42 <dons> have a look on haskell.org/ghc
20:56:59 <nuffer> so, who wants to explain Parsec to me?
20:57:13 <nuffer> mostly I'm trying to make a parser that parses if statements with optional else statements
20:57:28 <dons> suurely there's a tutorial on the wiki?
20:57:30 <dons> I think there must be
20:57:31 <nuffer> I know how to do this using try for if-else and then parsing just the if (if the if-else fails on else)
20:57:39 <nuffer> but that seems terribly wasteful
20:57:44 <nuffer> after the entire if statement has already been parsed
20:57:58 <nuffer> is there any way to combine them so that it sort of falls through to something if it fails on the second part?
21:00:28 <Cale> can't you put the try on the else branch?
21:00:49 <nuffer> but the whole parser will still fail if that fails, ne?
21:00:59 <nuffer> the if input will be consumed, but the result will be a parser error
21:01:01 <Cale> er, or there's something specific for this
21:01:06 <Cale> "option" maybe?
21:01:10 <Cale> let me look
21:01:25 <nuffer> yes, option
21:01:27 <nuffer> that's what I needed
21:03:26 <Cale> of course, you want to wrap the "else" keyword in a try, unless it's already toknized
21:03:33 <Cale> tokenized*
21:11:36 <nuffer> right, I got it working the way I wanted, thanks
21:24:57 <SamB> ok, now I can't get it to build the stuff from the primop list...
21:26:43 <SamB> I've had enough for tonight!
21:55:51 <Julian> k
22:30:14 <gzl> dons: have you checked out MSH?
22:34:29 <palomer> pandora is a kick ass station
22:34:47 <Cale> palomer: huh?
22:34:54 <wolverian> Cale, www.pandora.com
22:35:48 <wolverian> a flash applet that plays songs it thinks are similar to the one you specify. somewhat random and mostly US-centric in artists.
22:41:41 <palomer> but nonetheless good.
22:41:46 <palomer> are there alternatives?
22:43:31 <wolverian> yes, they're called friends. :)
22:44:39 <Cale> Is the music genome project database available?
22:44:48 <gzl> music genome?
22:45:15 <palomer> music genome sounds like something that should have been handled by the semantic web
22:46:13 <Cale> It's a bit too loose with its concept of similarity
22:46:55 <palomer> you set up a music ontology and you tag the songs
22:46:56 <lament> Shubert is kinda similar to Schumann.
22:47:11 <lament> schubert, rather.
22:47:15 <palomer> why is this loose?
22:47:39 <Cale> Well, it just seems to be picking things which aren't similar to the song I entered.
22:48:03 <Cale> hm.. no "A Pig With Wings"
22:48:17 <lament> computers still suck at music :)
22:48:33 * lament feels reassuringly human
22:48:51 <Cale> I wonder if it knows anything about Civilization Phaze III as a whole.
22:49:00 <palomer> Cale: you need to guide it after
22:51:24 <Cale> It would be nice if I could search for the properties directly.
22:52:05 <palomer> man, I've lost all sound from flash
22:52:07 <palomer> sucks
22:56:31 <palomer> try different songs
22:56:38 <palomer> I had a lot of luck with billie holliday
23:45:54 <ulfdoz> Aber er stimmt.
23:45:58 <ulfdoz> ECHAN, sorry
