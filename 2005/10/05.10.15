00:00:16 <basti_> if you can read ML, sure, go ahead... ;)
00:01:53 <gzl> araujo: also, I think there are lots of factors that have stopped innovations to OS design in the last 20 years.
00:02:10 <araujo> Of course, i just mentioned one
00:02:15 <gzl> yeah, I know.
00:02:27 <basti_> gzl: for example?
00:02:30 <dons> there's still innovation, but not as much highly visible stuff
00:02:40 <dons> see mungi for example
00:02:55 <dons> Nomius, you're back! details please: http://haskell.org/hawiki/HaskellUserLocations :D
00:03:05 <Nomius> What's that?
00:03:24 <araujo> Nomius, help us to crowd it down here!
00:04:13 <araujo> Saddly, innovations are being controlled by marketing.
00:04:18 <gzl> basti_: well, due to the way the industry is structured, major changes to the way people think about OS design is unlikely
00:04:24 <gzl> * are unlikely
00:04:28 * basti_ nods
00:05:05 <basti_> os's arent abstract enough
00:05:09 <gzl> a lot of people think OS research is a little dead for that reason -- even if some guy comes up with something neat, nobody's going to use it
00:06:52 <Nomius> Do I have to do all that?
00:06:52 * araujo thinks there are no interest to change that if it still makes good $$$
00:07:29 <dons> Nomius, do you just have your latitude and longitude? that's all you need?
00:07:46 <dons> easy to find with maporama or maps.google.com
00:08:02 <gzl> araujo: there's that, but there's also the issue of it being trivial to hire somebody who's good at C or Java and it being difficult to find anybody who's even heard of Haskell or ML
00:08:09 <Nomius> I have those
00:08:10 <gzl> (at least if you're talking about functional stuff)
00:08:30 <dons> Nomius, just /msg them to me, and i'll update the page :)
00:08:41 <dons> or add your own entry, if you like
00:09:57 <araujo> gzl, Well, Haskell is a very new language, not too many people know about it yet, but i see the community is moving fast
00:10:45 <gzl> yeah, but it's not like these C-like languages
00:14:32 <araujo> I remenber a B. Kernighan interview, they asked him why imperative languages are more used than declarative ones?, He said that declarative programming still doesn't find the way to go from the academic to the pragmatic field as easily as the imperative approaches.
00:14:56 <araujo> Haskell seems like the language changing that too.
00:15:05 <gzl> he also said it was because the style of functional languages doesn't match the way a lot of people seem to think
00:15:21 <dons> that's just the way they learnt to code though.
00:15:23 <araujo> mmm... well...
00:15:30 <araujo> yeah, i agree with dons
00:15:37 <dons> imperative languages a weird on my brain after 5 years of haskell only
00:15:53 <araujo> I actually believe declarative programming is more natural than imperative one.
00:16:00 <gzl> I think that's a factor, but I also think that functional languages have a more mathematical flavor that isn't appealing to lots of people
00:16:08 <dons> it's more like the mathematics you learn in high school
00:16:22 <gzl> it's hard to say whether it's only because they've been brought up on C
00:16:28 <dons> ah, but maybe it would be natural if they didn't get side tracked by C
00:16:32 <dons> yeah, true.
00:16:33 <gzl> maybe, maybe not
00:16:36 <gzl> it's hard to say
00:16:47 <dons> anyway, good programmers should learn to think both ways. if only to properly use recursion in C :)
00:16:49 <Cale> It seems like it is, in the cases that I've seen
00:17:13 <Cale> Though Haskell is best taken with a bit of math.
00:17:16 <dons> and functional programming is a super-set of control structures anyway
00:17:34 <dons> you can easily restrict yourself to using Haskell as the best imperative language ever invented :)
00:17:48 <Cale> Well, I've brought up the point that higher order functions let you forget about control structures sometimes.
00:18:04 <dons> quite so
00:18:44 <Cale> and so it can seem quite natural to be able to write "map wash dishes"
00:19:15 <dons> after all these years of haskell, everywhere I look now I see either maps or folds
00:19:29 <araujo> :-)
00:19:30 <gzl> when I think of people being confused by Haskell, monads are what come to mind
00:19:32 <Cale> :)
00:19:52 <Cale> I taught monads to 11 year old kids :)
00:20:17 <gzl> that creates more questions than it answers :)
00:20:22 <dons> it is often pointed out that it is just the phrase *monad* that scares people. actually using them is natural to state-hackers
00:20:34 <gzl> what were you doing teaching monads to 11 year old kids?
00:20:35 <araujo> I think that depends upon how deep you want to go with monads studies.
00:20:44 <dons> so they should instead be called "warm, fuzzy things"
00:21:07 <gzl> maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
00:21:15 <Cale> gzl: there were some kids which came to the university where I was working to learn Haskell and logic with The Haskell Road, as part of a teaching experiment.
00:21:21 <gzl> oh, cool
00:21:31 <dons> @remember gzl [on why monads are scary]  maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
00:21:39 <araujo> hah
00:21:45 <dons> @quote gzl
00:21:49 <lambdabot>  [on why monads are scary]  maybe it's because people look up monad
00:21:49 <lambdabot> on wikipedia, find the category theory page, and crap themselves
00:21:53 <dons> @quote
00:21:54 <lambdabot> malcolm says: Most software doesn't need to be fast.  But all
00:21:54 <lambdabot> software needs a fighting chance of correctness
00:21:56 <gzl> haha
00:22:03 <dons> @quote
00:22:04 <lambdabot> lambdabot says: of course i'm female
00:22:29 <gzl> brb, rebooting.
00:22:39 <Cale> Monads really aren't that hard to teach if you use the right words :)
00:23:23 <Cale> I think a lot of the difficulties with learning about monads initially was that people didn't really understand them very well, and so it was difficult to get a clear explanation.
00:24:04 <dons> yes, that's true.
00:24:53 <sieni> category theory isn't that difficult, it's just annoying ;-)
00:24:57 <dons> a similar history for typeclasses (though they got sorted faster)
00:25:41 <Cale> typeclasses are now basically the second thing I teach about Haskell :)
00:26:04 <Cale> after some basic things about types and the values inside them
00:26:24 <Cale> at least, what the class contexts mean is important
00:26:55 <araujo> Is there any other language which implementsthis typeclasses concept?,
00:27:05 <Cale> clean
00:27:08 <araujo> I just can't think of any,
00:27:21 <Cale> clean even has multiparameter typeclasses
00:27:28 <araujo> i see
00:27:42 <Cale> but that's the only one I can really think of
00:28:02 * araujo thought Haskell was the only one
00:28:19 <Cale> Clean is astoundingly similar to Haskell
00:28:50 <araujo> Cale, So what is the advantage (if any) of this multiparameter typeclasses?, you can create several instances at once?
00:28:52 <Cale> the major difference is the inclusion of uniqueness types which are used to do IO.
00:29:22 <Cale> Multiparameter typeclasses let you define ways in which a number of types are related to one another.
00:29:23 <dons> neologism: you should add your details: http://haskell.org/hawiki/HaskellUserLocations
00:29:36 <Cale> Together with functionality when the relation holds.
00:29:41 <neologism> dons: :)
00:29:43 <araujo> I see
00:29:53 <Cale> For example, are you familiar with vector spaces?
00:29:55 <neologism> I am just weekend haskell hacker ;)
00:30:07 <araujo> Cale, yes, a little
00:30:12 <Cale> neologism: the page is for people in #haskell :)
00:30:17 <dons> but you hang out on #haskell a lot. which means you count for the #haskell user locations :)
00:30:35 <dons> I think I need to make the purpose of this page a bit clearer.
00:30:45 <neologism> I dont hang on #haskell a lot
00:30:57 <araujo> neologism, you should :-)
00:31:02 <neologism> I plan to ;)
00:31:04 <dons> oh? I seem to see you fairly often. maybe I'm imagining
00:31:10 <Cale> araujo: you could do something like  class VectorSpace f v | v -> f where <+> :: v -> v -> v; *> :: a -> v -> v; -- etc
00:31:22 <dons> anyway, feel free to add your details neologism :)
00:31:23 <Cale> er
00:31:27 <Cale> f -> v -> v
00:31:54 <araujo> Oh i see
00:32:06 <Cale> where f is the "field", the type of scalars, and v the vector type
00:32:32 <Cale> the v -> f is a functional dependency, it says that v determines f
00:32:40 <Cale> which is useful during type inference
00:32:53 <araujo> So you'd have all that encapsulated in one class?
00:32:59 <Cale> (that is, for any v, there's at most one f)
00:33:24 <Cale> yeah, and you would form instances of this class for various v and f
00:33:31 <araujo> I see now
00:33:45 <Cale> now, this is even more interesting in some sense when that functional dependency isn't there
00:35:06 <Cale> That would be a class which properly *pairs* of types would belong to, and any set of pairs might do.
00:35:22 <araujo> Cale, Couldn't we do the same with subclasses in Haskell?
00:35:40 <Cale> no
00:35:58 <Cale> well, not subclasses in the Haskell sense, anyway
00:37:00 <basti_> hmm you can't do that?
00:37:04 * basti_ ponders
00:45:40 <Cale> You need the multiple parameters in order to be able to introduce multiple class type variables into the types of the methods.
00:45:55 <basti_> i tried it and i'm convinced now that it is hard.
00:46:20 <basti_> bbl though
00:56:07 <bourbaki> moin
00:56:41 <Speck> heh
00:56:43 <neologism> he.. nice nick :)
00:57:34 <bourbaki> mine?
00:58:16 <neologism> yeah
00:58:28 <bourbaki> thx
01:04:23 * shapr yawns
01:04:38 <jyp> @yow
01:04:39 <lambdabot> The PILLSBURY DOUGHBOY is CRYING for an END to BURT REYNOLDS movies!!
01:04:42 <Cale> morning? shapr
01:04:45 <shapr> g'mornin
01:20:34 <shapr>  @quote
01:20:46 <Oejet> Good morning all.
01:20:50 <shapr> Hm, australia must be further away today.
01:21:01 <kolmodin> good morning
01:21:16 <shapr> @quote
01:21:17 <lambdabot> blackdog says: my variables aren't varying.
01:21:40 <shapr> Good morning #haskell!
01:21:43 <Oejet> Where is the date line?  I mean which part of the world has the first morning?
01:21:57 <jyp> Japan...
01:22:13 <dons> nah, somewhere just past Samoa
01:22:22 <dons> Fiji possibly
01:22:30 <dons> it was a big issue in 2000
01:22:39 <jyp> Sure... i didn't mean to be technical :)
01:22:49 <dons> ok :)
01:23:07 <araujo> Be carefule, dons is becoming an expert with this timezone thing
01:23:24 <dons> hehe :) but also I live near the timezone, sort of
01:23:31 <araujo> :-)
01:25:33 <Oejet> dons: So it's afternoon now there?
01:26:32 <dons> @timein auckland
01:26:35 <lambdabot>  Saturday, October 15, 2005 at 9:26:12 PM
01:26:57 <shapr> @timein Stockholm
01:26:58 <lambdabot>  Saturday, October 15, 2005 at 10:26:35 AM CEST
01:27:05 <shapr> oh, I have to get ready
01:27:05 <dons> @timein apia
01:27:07 <lambdabot>  Friday, October 14, 2005 at 9:26:44 PM
01:27:15 <Oejet> @timein Copenhagen
01:27:17 <lambdabot>  Saturday, October 15, 2005 at 10:26:54 AM CEST
01:27:23 <Oejet> Yay. :-)
01:27:26 <araujo> @timein maracaibo
01:27:27 <lambdabot>  Saturday, October 15, 2005 at 4:27:04 AM
01:27:34 * Oejet sets his clock.
01:27:37 <shapr> @timein Montgomery
01:27:39 <lambdabot>  Saturday, October 15, 2005 at 3:27:16 AM CDT
01:27:43 <Maddas> @yow
01:27:44 <lambdabot> The Osmonds!  You are all Osmonds!!  Throwing up on a freeway
01:27:44 <lambdabot> at
01:27:44 <lambdabot> dawn!!!
01:28:00 <dons> heh
01:28:01 <jyp> oi
01:28:13 <shapr> Today is particularly random.
01:28:16 <Maddas> :-)
01:28:40 * dons ponders the existence of random days
01:28:55 <shapr> Whoa, this year we had 366 days!
01:29:12 <dons> oh my, IT'S HAPPENING AGAIN!
01:29:17 * shapr laughs
01:29:29 <bourbaki> @timein home
01:29:30 <lambdabot>  Sorry, don't know this city
01:29:45 <Oejet> @timein Springfield
01:29:58 <bourbaki> :)
01:30:05 <Oejet> lambdabot ponders.
01:30:38 <shapr> @hello
01:30:38 <lambdabot>  @help <command> - ask for help for <command>
01:30:45 <Maddas> @timein Ouagadougou
01:30:46 <dons> or possibly it isn't. @timein isn't terribly good at returning failure
01:30:47 <lambdabot>  Saturday, October 15, 2005 at 8:30:24 AM
01:30:57 <shapr> Man, lambdabot sure is a fun toy.
01:31:05 <Oejet> @timein Springfield
01:31:08 <Oejet> Grrr.
01:31:10 <Maddas> shapr: Indeed :-)
01:31:17 <dons> too many springfields, Oejet
01:31:24 <dons> patch submitting time!
01:31:29 <dons> @version
01:31:29 <shapr> @timein Springfield, IN
01:31:30 <lambdabot> lambdabot 3p104, GHC 6.5 (OpenBSD i386)
01:31:30 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:32:26 <shapr> How many patches makes for another version?
01:33:23 <dons> hmm, ~100 is pretty good actually
01:33:31 <Maddas> How many patches must a program go through before it can call itself new? :-)
01:33:31 <dons> though there were about 400 for 3.0
01:34:00 <dons> probably i'll just release every 6 months or so
01:34:00 <Maddas> Wow, impressive
01:34:09 <bourbaki> @timein Guildford
01:34:10 <lambdabot>  Sorry, don't know this city
01:34:31 <shapr> Cale: You suggested integrating FLM with CiteSeer, how would that work?
01:34:32 <bourbaki> @timein Greenich
01:34:34 <lambdabot>  Sorry, don't know this city
01:34:42 <shapr> @timein Greenwich
01:34:44 <lambdabot>  Saturday, October 15, 2005 at 9:34:21 AM BST
01:34:49 <bourbaki> :)
01:35:00 <shapr> Though I've heard it spoken "grennitch"
01:35:11 <dons> that's how I'd say it
01:35:20 <dons> and I have the Queen on my money :)
01:35:27 <bourbaki> heh
01:35:40 <dons> it's a pity that Greenwich doesn't use GMT
01:35:56 <shapr> Also, should I use CiteSeer for permanent research paper urls, or should I use DOI? http://www.doi.org/about_the_doi.html
01:35:58 <Cale> shapr: hmm, well, it looks like FLM is a web app, so actually what might be a good way to do it is by writing a small greasemonkey plugin which would tack some things onto the citeseer pages
01:36:12 <shapr> Ahh that sort of integration
01:36:15 <Cale> like an extra link to FLM
01:36:18 <shapr> That's an excellent idea!
01:36:45 <Cale> which would either create the pages in FLM from the (ps/pdf) article there, or go to the existing one
01:36:47 <shapr> I thought you meant something like automatically importing new papers via CiteSeer
01:37:13 <Cale> that might also be doable, via scraping, if they have a "what's new" page or something like that.
01:37:49 <shapr> I was thinking something like a link in FLM navigation that says "import all available referenced articles"
01:38:26 <shapr> Then it would crawl CiteSeer, grab the docs, create your local copies, and look for existing darcs repos for the papers.
01:38:50 <Cale> I'm still not clear on how FLM is going to be run. Is it a user app which communicates to a central server that has everyone's margins?
01:38:59 <Cale> ah
01:39:01 <shapr> No, there isn't a central server.
01:39:15 <Cale> okay, so it's darcs-based
01:39:21 <shapr> It works like lambdabot.
01:39:22 <araujo> JKnecht, see? :-)
01:39:23 <shapr> Right.
01:39:35 <shapr> The only downside there is that repo discovery will be difficult sometimes.
01:39:41 <shapr> I don't know how to beat that.
01:39:55 <Cale> well, centralising somewhat would be good
01:40:00 <shapr> Maybe there should be a central server where you advertise an url to repo pair?
01:40:03 <Cale> yeah
01:40:12 <shapr> That could lead to spam though.
01:40:35 <shapr> But I'll make sure to include anti-spam tricks like mass undo, blacklisting of strings, etc
01:40:36 <JKnecht> :)
01:40:43 <shapr> Though probably not till 2.0 or so.
01:40:50 <shapr> hola JKnecht
01:40:51 <Cale> JKnecht: Magister Ludi?
01:41:12 <shapr> Cale: Anyway, if you think of more ideas for FLM, I want to hear 'em!
01:41:24 <Cale> :)
01:41:30 <JKnecht> right. J is my birth initial, my birth surname is an American slave name whence the monicker.
01:41:59 <Maddas>  JKnecht :-)
01:42:04 <JKnecht> more panache than JX.
01:53:25 <JKnecht> lamdabot help
01:53:42 <JKnecht> lambdabot help
01:54:09 <Cale> @listcommands
01:54:10 <lambdabot> use listcommands [module|command], please. Modules are:
01:54:10 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
01:54:10 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
01:54:10 <lambdabot> spell state system todo topic type version vixen where
01:54:40 <Cale> @hoogle [a] -> a
01:54:41 <lambdabot> Prelude.product :: Num a => [a] -> a
01:54:41 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
01:54:41 <lambdabot> Prelude.last :: [a] -> a
01:55:01 <JKnecht> @fooBar
01:55:02 <lambdabot> Unknown command, try @listcommands.
01:55:32 <Cale> @pl \x -> 3*x^2 + x + 1
01:55:33 <lambdabot> (1 +) . ((+) =<< (3 *) . (^ 2))
01:55:37 <Cale> heh
01:55:50 <Cale> @pl \x y z -> x z (y z)
01:55:51 <lambdabot> ap
01:55:54 <ValarQ> ?
01:56:20 <Maddas> @hoogle (a -> Bool) -> array a b -> array a b
01:56:21 <lambdabot> Prelude.seq :: a -> b -> b
01:56:21 <lambdabot> Prelude.(^) :: (Num a, Integral b) => a -> b -> a
01:56:21 <lambdabot> Prelude.(**) :: Floating a => a -> a -> a
01:56:26 * ValarQ stares at that first @pl
01:56:33 <Cale> @hoogle (a -> Bool) -> Array a b -> Array a b
01:56:34 <lambdabot> Array.ixmap :: (Ix a, Ix b) => (a, a) -> (a -> b) -> Array b c ->
01:56:34 <lambdabot> Array a c
01:56:44 <Maddas> IOops, thanks Cale.
01:56:54 <Cale> hum, not quite hoogle :)
01:57:01 <Maddas> ixmap isn't what I want, though (I think). I'll just define my own filterArray and mapArray :-)
01:57:35 <Cale> @hoogle (a -> b) -> Array i a -> Array i b
01:57:36 <lambdabot> Array.ixmap :: (Ix a, Ix b) => (a, a) -> (a -> b) -> Array b c ->
01:57:36 <lambdabot> Array a c
01:57:48 <Cale> why does it give that one? :)
01:59:12 <Cale> use amap for mapping over elements
01:59:55 <Cale> ValarQ: the first one uses bind in a creative way, together with the ((->) e) monad.
02:00:33 <Cale> JKnecht: there are lots of things which lambdabot can do, as you might see :)
02:01:09 <Cale> @eval let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in take 30 primes
02:01:12 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,
02:01:12 <lambdabot> 97,101,103,107,109,113]
02:01:25 <ValarQ> :)
02:01:50 <Cale> @type Text.ParserCombinators.Parsec.oneOf
02:01:52 <lambdabot> forall st.
02:01:52 <lambdabot> [Char] -> Text.ParserCombinators.Parsec.Char.CharParser st Char
02:01:58 <Cale> @type map
02:01:59 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
02:03:49 * Cale goes back to struggling with a 20x20 griddler.
02:04:12 <JKnecht> Cale: I do. Kimba his eyes opened.
02:05:52 <Maddas> Cale: Oh, thanks!
02:07:36 <JKnecht> (actually 'Kiteo, his eyes opened': http://rec.horus.at/trek/lists/darmok.html )
02:17:37 <JKnecht> alright, Sokath :)
02:20:02 <Cale> :)
02:26:29 <tomaszz> I have a question to those experienced in publishing research papers
02:27:21 <tomaszz> How do you know that your ideas haven't been published before?
02:27:56 <tomaszz> Do you have to go through tons of papers or you can ask some experienced researcher?
02:28:11 <jyp> It's part of the research really
02:28:20 <tomaszz> experienced in your area
02:28:43 <tomaszz> Is there a risk that you idea might be "stolen"?
02:28:47 <jyp> First step is to get to the state of the art before building into it
02:29:11 <jyp> in that process you should become aware of what exists already
02:29:32 <tomaszz> Seems to be a big effort
02:29:44 <tomaszz> but I guess it pays off
02:29:52 <jyp> Yeah, research is painful :)
02:30:04 <dons> literature reviews --> so you find out what's been done. also talking to people. i'm not sure that there's much risk of ideas being stolen, since not many people understand what you're doing anyway
02:30:16 <dons> though it does happen
02:30:17 <tomaszz> :-)
02:30:25 <dons> well, I presume it does happen
02:30:51 <JKnecht> the essence of the scientific enterprise is that it produces a body of public knowledged ...
02:31:08 <dons> tomaszz, it's like open source software.
02:31:23 <tomaszz> yes, but there must by some reward for the original inventor
02:31:27 <tomaszz> at least recognition
02:31:41 <tomaszz> there should be
02:31:53 <JKnecht> your concept of your idea being stole doesn't therefore make sense. Rather it's a matter of establishing that you are the proper recipient of eponomy.
02:31:55 <tomaszz> rather than "must"
02:32:38 <tomaszz> I have a nice idea for masters thesis, but I am not sure it wasn't done before
02:32:48 <dons> {Arias}: add your details : http://haskell.org/hawiki/HaskellUserLocations :)
02:33:00 <dons> you too wilx
02:33:09 <JKnecht> By virtue of establishing that you had idea first, which you could do a number of ways.
02:33:15 <{Arias}> ok :)
02:33:17 <tomaszz> I guess I shouldn't be so concerned about recognition ;-)
02:33:41 <dons> tomaszz, well, find out what's been done in the area first. you don't want to waste time just to find out it's been done
02:34:02 <dons> once you understand the area well, you'll know about lots of good unsolved problems to work on probably
02:34:11 <tomaszz> I started doing this, but I got overwhelmed by the amount of papers ;-)
02:34:26 <dons> yes, you could easily following bibtex entries forever
02:34:29 <JKnecht> How old are you tomas?
02:34:45 * tomaszz is 27 years old
02:34:51 <{Arias}> dons, how can i add my detail?
02:35:13 * tomaszz doesn't have MSc yet
02:35:23 <dons> you can either edit the wiki page, or /msg me the coordinates
02:35:41 <dons> to edit the wiki page, you need to click on UserPreferrences, and get a username and passwd. then refresh, then edit
02:36:03 <neologism> dons: if I just tell you city/state will you add me ?
02:36:05 <{Arias}> mmm, how can i get my coordinates? xD
02:36:24 <dons> neologism, can you find the coordinates first please?
02:36:29 <araujo> wikipedia is a oog place for coordinates
02:36:33 <JKnecht> Hmmm, well still pretty young. But I can tell you if you can't trust your peers in Academia, you can't trust anybody. And BTW, you can't ")
02:36:38 <dons> coordinates can be found with maporama.com, wikipedia, maps.google.com etc
02:36:41 <araujo> Hola {Arias}
02:36:46 <{Arias}> hola araujo :)
02:36:49 <JKnecht> s/")/:)/
02:36:50 <{Arias}> ok dons
02:36:51 <neologism> dons: too lazy ;)
02:37:16 <dons> neologism, a suitably constructed @google might even do the trick
02:37:21 * tomaszz got himself deep in s*** doing automatic translation from MSSQL to PostgreSQL and would rather start from scratch with some nice problem
02:37:28 <dons> @google latitude longitude Sydney Australia
02:37:29 <lambdabot> http://www.infoplease.com/ipa/A0001769.html
02:37:38 * dons crosses fingers
02:37:39 <tomaszz> I am not in academia
02:37:42 <neologism> @google latitude longitue Brno Czech
02:37:43 <lambdabot> No result found.
02:37:47 <neologism> @google latitude longitude Brno Czech
02:37:48 <lambdabot> http://www.findlocalweather.com/forecast.php?icao=LKTB
02:37:52 <dons> the city for Brno?
02:37:59 <JKnecht> you are now.
02:38:15 <neologism> yes, I am in brno now
02:38:24 <tomaszz> I am in academia?
02:38:24 <dons> ok, I can add that
02:38:54 <Maddas> @google latitude longtitude academia
02:38:56 <lambdabot> http://www.cpan.org/MIRRORED.BY
02:39:12 <Maddas> heh
02:39:20 <eivuokko> Funny :)
02:39:34 <JKnecht> (by virtue of your using Haskell, writing scholarly papers, etc.)
02:39:51 <tomaszz> I am using Haskell in my job :-)
02:39:56 <eivuokko> Using Haskell? :o
02:39:59 <tomaszz> and I didn't write the paper yet
02:40:05 <tomaszz> haven't?
02:40:08 <neologism> I am using haskell to make other programmers envy me :)
02:40:28 <tomaszz> neologism: it is a nice side-effect ;-)
02:41:08 <Maddas> Funny, if I used Haskell I think most peers in my age would laugh at me for not using Java or C++ :-)
02:41:24 <Maddas> (Or rather if I told them I was using it)
02:41:48 <JKnecht> And you care?
02:41:49 <int-e> well, I earn blank looks
02:41:53 <tomaszz> I must say that at least some of my peers aren't frightened by the idea of using Haskell
02:41:59 <moonfish> has anyone here got any experience with haskelldb?
02:42:10 <eivuokko> I have used it.
02:42:11 <Maddas> JKnecht: I just said that because neologism remarked that others envy him for it
02:42:25 <Maddas> And no, I don't really care about the opinion of most of them on these regards
02:42:29 <int-e> "Haskell? What? Isn't that a purely academic language? What good is it? Everyone does Java and PHP."
02:42:32 <Maddas> Not anymore, at least :-)
02:42:43 <neologism> people envy some features haskell has
02:43:03 <eivuokko> I am on of those.
02:43:06 <eivuokko> *one
02:43:06 <Maddas> Right, natural selection will hopefully still take care of a few of my peers :-P
02:43:07 <moonfish> I've got a projection that can return null values. How do I exclude the nulls?
02:43:18 <tomaszz> "Paskell? Is is that language they teach to high-school students?"
02:43:19 <dons> filter?
02:43:29 <tomaszz> Is it
02:43:36 <dons> moonfish, what kind of null values?
02:43:36 <JKnecht> I'd guess 95% of U.S. programmers asked would say it was Wallys friend on Leave It To Beaver.
02:43:38 <dons> Nothings ?
02:43:50 <Maddas> tomaszz: Actually, CS students here know Haskell, but a) I'm not studying CS and b) many of them dislike it just because they studied it
02:43:59 <eivuokko> moonfish, why not check for them with..well there is a thing to check that, isNull or something.
02:44:14 <Maddas> JKnecht: Heh!
02:44:31 <moonfish> it's all inside the query monad though.
02:44:35 <Cale> null checks if a list is empty
02:44:56 <Cale> which query monad?
02:45:09 <dons> haskelldb
02:45:11 <moonfish> the haskelldb Query monad
02:45:18 <neologism> Maddas: I am a CS student and they didnt teach me haskell
02:45:20 <tomaszz> Maddas: this person confused Haskell with Pascal :-)
02:45:26 <neologism> I was taught lisp/prolog :(
02:46:16 <JKnecht> I myself would have lumped it with ML until an hour or so ago.
02:46:20 <moonfish> so the type I have is something like Query (Rel (RecCons MyColumnType *Expr (Maybe Integer)) RecNil)
02:46:24 <Maddas> tomaszz: Haha :-)
02:46:30 <Maddas> neologism: Sounds fun!
02:46:49 <moonfish> and I need it to be Query (Rel (RecCons MyColumnType *Expr Integer) RecNil)
02:46:59 <neologism> not at all
02:47:12 <moonfish> s/*/(
02:47:13 <tomaszz> Anyway, thank you all for your advices
02:47:47 <Maddas> neologism: Was the course no good?
02:48:02 <neologism> it was AI course
02:48:08 <neologism> with 2 lectures about lisp/prolog
02:48:14 <eivuokko> moonfish, I am not sure, but why can't you simply add something like restrict notNull t!myfield in query?
02:48:39 <tomaszz> Now is the time to get some peers in Academia ;-)
02:48:42 <eivuokko> Or you mean you want to build types by hand (or to clear inference)?
02:49:17 <Maddas> neologism: Ah
02:49:33 <moonfish> the closest I could get is project (col << (fromNull (constant 0) $ t!col))
02:50:05 <moonfish> ...which has the right type, but just replaces the null with 0.
02:51:20 <eivuokko> Ehm, so do t <- table foo; restrict notNull t!col; project foo_col << t!col ?
02:51:42 <moonfish> doesn't give the right type :(
02:51:55 * eivuokko is confused
02:52:42 <eivuokko> Maybe I am jsut slow or something :-S  But why is the type important?
02:53:39 <moonfish> well, the type must indicate that there can't be nulls, because that's what the code surrounding it is expecting.
02:54:59 <eivuokko> And restict and project you had for converting doesnt help either?
02:56:05 <moonfish> which restrict and project?
02:57:11 <eivuokko> That fromNull-project you had and the nonNull-restrict?
02:58:13 <moonfish> the fromNull works on the type-side, but it gives me the wrong value, i.e. I want the result to be an empty relation when there is a null, rather than a relation containing 0.
02:58:32 <JKnecht> is sure the real Academia is no Castalia.
03:00:03 <JKnecht> but compared to the viper pit which ordinary wage labor markets present I guess it is.
03:01:28 <Maddas> Is there any nice way to exit a DO block prematurely? when foo (return ...) doesn't exit it, and wrapping everything in if .. then return else ... gets rather unwieldy pretty quickly
03:02:21 <jyp> no... but you can use an 'error' monad
03:02:58 <jyp> there is also the 'when
03:03:01 <Maddas> Hmm. I'll stick to unwieldy things, I think, but thanks for the tip (it's just in one or two cases)
03:03:05 <jyp> ' primitive
03:03:15 <Maddas> Right, I could just wrap the positive part in a when
03:03:35 <moonfish> eivuokko: oh, i see what you mean: *combine* the not-Null restriction with the fromNull projection. Let me try that ...
03:03:37 * jyp tips his hat
03:04:37 <eivuokko> moonfish, Yeah.  It's ugly and unneccesarily  taxes underlying systems, but if you need the type...  I gave up a bit on haskelldb because of issues like that.
03:05:03 <eivuokko> Not that I did anything else with haskell after that, really ;)
03:06:11 <eivuokko> I tried to hack the expressions a bit, so one could modify types with multiparam type classes (sort of like c++ templates), but I they were always undecideable.  With those one could remove problesm like you have, I think.
03:08:53 <moonfish> eivuokko: that worked! but as you said, the resulting query looks rather stupid. Mind you most haskelldb-generated queries do.
03:10:18 <tomaszz> Maddas: you can also use a continuation monad(-transformer)
03:13:34 <Maddas> tomaszz: Learning about those comes another day ^_^
03:13:44 <Maddas> tomaszz: I found a neat way of making things nicer by using lazy evaluation, though
03:14:13 <Maddas> (e.g. I can do a pattern match and delay checking whether it even succeeded until after the match)
03:14:33 <Maddas> Which is quite cool to someone new to lazy evaluation :-)
03:19:08 <Cale> heh, solved it :) (the griddler-type puzzle I was working on)
03:19:35 <ValarQ> Cale: congrats :)
03:20:29 <ValarQ> Cale: i'm working on your ascontainers article now, i found that fractal thingie quite neat
03:20:36 <Cale> :)
03:21:08 <Cale> xerox and I have actually put that idea to use in an L-System generator :)
03:22:03 <ValarQ> the one you used to scare that C++ hacker?
03:22:20 <JKnecht> as a Haskell n00b, may I ask if the Monad bears the same relation to Haskell as the functor does to Prolog, i.e. as a fully practically realized abstraction?
03:22:26 <Cale> ValarQ: yes :)
03:22:27 <neologism> what is a L-system?
03:22:46 <neologism> JKnecht: funktor vs monad?
03:23:09 <Cale> JKnecht: A monad is actually a functor on the category of haskell types with the appropriate natural transformations, yeah.
03:23:38 <JKnecht> Cale: Thank You.
03:23:43 <ValarQ> is a monad just a functor with some extra laws?
03:24:16 <sylvan> neologism, it's a way to draw plants and cool stuff using simple laws
03:24:45 <sylvan> http://en.wikipedia.org/wiki/L-system
03:24:57 <ValarQ> or am i off the hook again?
03:25:05 <Cale> ValarQ: It's a triple (T,eta,mu) where T is a functor, and eta : 1 -> T and mu : T^2 -> T are what are called natural transformations, and they satisfy some extra laws.
03:25:25 <Cale> In Haskell, eta is called return, and mu is called join
03:25:56 <Cale> but we don't define monads directly with return and join in Haskell, we use return and bind instead
03:26:05 <ValarQ> ok
03:26:10 <Cale> join is in the Monad library
03:26:17 <ValarQ> what about monadplus then?
03:27:25 <Cale> MonadPlus adds some additional structure. I'm not sure exactly what it is in terms of category theory.
03:28:02 <Cale> Probably that the functor is a monoid object in some suitable category.
03:29:04 <Cale> http://vx.hn.org/autoshare/griddler-20x20.png if anyone would care to see it :P
03:30:44 <Cale> (the game is to determine the colours of the squares by using the lengths of the black runs in the rows and columns)
03:31:06 <neologism> Cale: what is the equivalent of the functor T in haskell then?
03:31:21 <Cale> neologism: the type constructor, together with liftM/fmap
03:31:41 <neologism> ah
03:31:44 <xerox> Woot to L-Systems! Back in some minutes.
03:32:57 <bourbaki> hasnt boegel written an l system interpreter in haskell?
03:34:12 <Cale> yes, HaskLS
03:34:38 <Cale> we've done something which isn't 3D, but which has a more sophisticated type of L-System.
03:34:48 <bourbaki> whos we?
03:34:55 <Cale> xerox and I
03:35:17 <Cale> Using xerox's Cairo binding
03:35:26 <bourbaki> whats cairo?
03:35:35 <bourbaki> did you read these paper of that one guy?
03:35:40 <Cale> A nice 2D vector graphics library.
03:35:47 <bourbaki> there is a book on lsystems for certain plants
03:35:51 <Cale> yeah
03:35:59 <bourbaki> even for the petals and so
03:35:59 <Cale> I have that, was reading bits of it
03:36:16 <bourbaki> whats the name of the book you have?
03:36:42 <bourbaki> so you have also written bezier patches for the leves and petals?
03:36:45 <bourbaki> leaves
03:38:00 <Cale> "The Algorithmic Beauty of Plants"
03:38:23 <bourbaki> ah this already contains the thingies for propatation of hormones and so?
03:38:40 <bourbaki> its one of the guys earlier works if i am not mistaken
03:38:44 <Cale> oh
03:38:49 <bourbaki> there are more profund papers on his website
03:39:13 <Cale> Currently our program only does line segments, but there are lots of ideas to extend it.
03:39:15 <bourbaki> the has done some work on insects eating the plants and also sun acting on it
03:39:22 <bourbaki> and that its sticking to a wall and so
03:39:42 <bourbaki> there was a very good website forgot the name though
03:39:48 <neologism> Cale: how can I express Maybe monad in prolog using functors? I dont get it...
03:40:13 <bourbaki> he wrote some plants there with petals and also had quite good ideas for the turtle
03:40:23 <Cale> neologism: I'm not sure -- I've only used prolog a small amount.
03:40:35 <neologism> I have to implement somethinglike this
03:40:44 <Cale> neologism: are prolog functors the same as category theory functors?
03:40:55 <neologism> I dont know but I suppose they are
03:41:54 <JohnMeacham> Ah. I just spent the evening being berated by a busty german girl for being a horrible american slob. You'd think that if she didn't like americans, she would have not asked me out. ah well. time to code.
03:42:19 <bourbaki> heh
03:42:51 <Cale> heh
03:43:04 <ValarQ> hmm :/
03:43:35 * malcolm thinks he agrees with JohnMeacham about some aspects of Cabal
03:44:04 <bourbaki> cabal? isnt there missing an e?
03:44:10 <bourbaki> and an a too much?
03:44:43 <Cale> http://en.wikipedia.org/wiki/Cabal
03:44:59 <xerox> Yow!
03:45:15 * JohnMeacham is hopeful we can fix some of the problems in cabal.
03:45:53 <Cale> There should be a related project called Junta
03:45:54 <malcolm> JohnMeacham: I'm coming round to the idea that Cabal ought to be a program rather than a library
03:48:06 <JohnMeacham> malcolm: yeah, it is worse when you realize each compiler will have its own library of cabal, which one do you use? I sort of think the only reason it was made an executable was because that is the way perl did it. it also bothers me that we of all people don't have a declarative package description language.
03:49:02 <malcolm> I can envisage a half-way house between hmake and make.  hmake has no configuration file and just builds your program/library.  make absolutely requires a config file of instructions.
03:49:15 <JohnMeacham> A line should be added to the cabal file called build-style: which can be things like make, autoconf, or cabal for the simple cabal behavior.
03:50:38 <JohnMeacham> Also, I think cabal should write a specification on how compilers and preprocessors should behave to be used by cabal. I was all set to make jhc and DrIFT cabal compliant, but then found there was nothing I could do. I had to modify cabal and then get everyone to upgrade it. which seems completly backwards.
03:51:07 <malcolm> It would be nice to basically use hmake, but say, be able to add a rule for a new preprocessor.
03:53:48 <Cale> um...
03:53:50 <Cale> heh
03:53:52 <bourbaki> heh
03:54:04 <{Arias}> um...
03:54:31 <{Arias}> :P
03:56:15 <Maddas> heh
03:56:20 <ValarQ> huh?
03:57:27 <{Arias}> um...
03:57:46 <Maddas> cycle ["um...", "heh"]
03:58:20 <Cale> It was just slightly funny that this user couldn't decide if they wanted to be in the channel or not.
04:04:25 <rafl> Igloo: 6.4-4.1 is in etch now. When will 6.4.1 go into unstable?
04:11:33 <tomaszz> speaking of make, I found it quite pleasant to use Haskell as a substitution for make
04:11:44 <tomaszz> make has some irritating limitations
04:12:01 <tomaszz> even GNU make
04:12:24 <malcolm> tomaszz: how did you use haskell as a substitution for make?
04:12:40 <tomaszz> well, first I defined a type for rules
04:12:56 <tomaszz> let me find it...
04:13:31 <malcolm> tomaszz: so you have something like a Makefile, only read in by Haskell?
04:14:34 <tomaszz> actually, written in Haskell
04:14:40 <tomaszz> type Rule = FilePath -> Maybe (BuildMonad (IO ()))
04:15:11 <tomaszz> a -> Maybe x is like first-class pattern-matching
04:15:15 <malcolm> tomaszz: ah, so the rules have to be compiled before being used
04:15:26 <tomaszz> yes, but I use #!runhaskell
04:15:51 <tomaszz> newtype BuildMonad a = BuildMonad { runBuildMonad :: WriterT [FilePath] IO a }
04:15:52 <malcolm> tomaszz: cool.  I suppose one could use hs-plugins as well
04:16:04 <tomaszz> the BuildMonad is for generating dependencies
04:16:31 <tomaszz> and building the actual action
04:16:40 <tomaszz> note that I use BuildMonad (IO ())
04:17:09 <tomaszz> I use Parsec to "pattern-match" file names
04:17:39 <malcolm> ooh, monad transformers.  mind-bending.
04:17:39 <dcoutts> dons, we still seem to be missing yi/src/Yi/UI.hs from the Yi darcs repo. I can't build at the moment.
04:18:11 <tomaszz> I can show you how a typical rule looks like
04:18:28 <malcolm> tomaszz: have you published the code anywhere?
04:18:45 <malcolm> tomaszz: yes please, show us a rule
04:19:15 <dcoutts> JohnMeacham, our declarative package description language is the .cabal file.
04:19:45 <tomaszz> I'll have to polish it for presentation, wait a moment
04:19:47 <dcoutts> JohnMeacham, from that we can generate gentoo ebuilds, .rpms, debian .debs etc.
04:20:03 <wilx> Bah, I cannot edit the HaskellUserLocations page.
04:20:11 <Cale> wilx: log in
04:20:17 <wilx> Ah.
04:20:29 <malcolm> dcoutts: Yes, but I think we could drop e.g. the list of modules (can be computed)
04:20:32 <Cale> anyone having trouble editing the wiki, log in, since all the pages are immutable to nonusers now
04:21:05 <dcoutts> malcolm, yes possibly. Though there is still the exposed/hidden distinction.
04:21:22 <dcoutts> malcolm, automake requires you to spcify all the source files too
04:21:45 <malcolm> dcoutts: I think we have come to the conclusion that exposed/hidden makes no sense, since a hidden module still blocks that module name from any other package.
04:22:04 <xerox> Cale: did the shape indicating the starting position and direction work for you, somewhere in the past? :)
04:22:12 <dcoutts> malcolm, but hidden ones cannot be imported from other packages. And that's useful sometimes.
04:22:19 <dcoutts> dons!
04:22:20 <malcolm> dcoutts: maybe
04:22:25 <Cale> xerox: it still works for me, afaict
04:22:26 <xerox> Greetings, dons.
04:22:43 <dons> oh, I must have dropped out for a little while
04:22:48 <xerox> Cale: so I probably have an older version!  It doesn't do anything here :-(
04:23:05 <Cale> ah, I'll put up my copy
04:23:09 <dcoutts> dons, any chance that you could add the missing src/Yi/UI.hs file?
04:23:11 <malcolm> dcoutts: it should be easy to run something like "cabal --list-modules" to determine the modules though, without needing to do it manually.
04:23:28 <dons> dcoutts, oh!
04:24:10 <dcoutts> malcolm, if there is a module in a lib/package that re-exports all the other modules then you could chase imports. But it's not always the case.
04:24:27 <Cale> http://vx.hn.org/autoshare/nymphaea.tar.bz2
04:24:27 <tomaszz> @paste
04:24:29 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:24:33 <dcoutts> malcolm, but you're right it could be mostly automated, in most cases.
04:24:43 <malcolm> dcoutts: so you just need to put a minimal rootset of modules in the .cabal file...?
04:24:50 <dcoutts> malcolm, yep
04:25:08 * dcoutts makes a mental note to add such a feature ti hIDE
04:25:28 <wilx> Whee!
04:25:28 <tomaszz> can't edit the paste wiki page
04:25:28 <wilx> Done.
04:25:34 <malcolm> dcoutts: for the exposed/hidden thing, you could place a pragma at the top of each file?
04:25:41 <xerox> Cale: I was thinking about the alphabet in the parser.  It could be handy being able to use dummy chars for rules, like, say, 'X'.
04:25:42 <tomaszz> I'll put it on my site
04:25:43 <Cale> xerox: tell me how that works for you :)
04:25:48 <Cale> xerox: yeah
04:26:00 <malcolm> dcoutts: or maybe check if it has haddock docs - if not, then its hidden?
04:26:33 <xerox> Cale: which mouse button is the one to be used to set the position?
04:26:45 <Cale> left
04:26:47 <dcoutts> malcolm, yeah that'd be a reasonable way of setting a default that the programmer can then tweak.
04:26:58 <dons> dcoutts, so yi using the editor page api is almost done now. yi is now paramaterised by a UI existential wrapping the ui operations (basically the EditorPage api). so you just a wrapped instance of UI into yi, which makes sure to call the appropriate ui-specific code. So yi stays independent of each ui.
04:27:17 <dons> the only thing left now is to finish writing the plugin/hide instance of UI, that uses the EditorPage api
04:27:25 <xerox> Cale: Nothing :-\
04:27:37 <Cale> xerox: which gtk2hs are you using?
04:27:42 <malcolm> tomaszz: did you paste your Makefile-like rule?  I can't see it.
04:28:11 <xerox> Cale: 0.9.9.5
04:28:21 <Cale> xerox: change to the cvs version
04:28:36 <tomaszz> malcolm: see http://www.uncurry.com/Rule.hs
04:28:40 <Cale> dcoutts fixed some bugs since then which affect how events are set
04:28:52 <dons> oh, my little description of a make system specified entirely with maps and folds got lost in the irc wildnerness
04:28:59 <Cale> (it's actually a bug in gtk2)
04:28:59 <tomaszz> it's a bit lengthy for what it does
04:29:08 <xerox> Cale: which version is it?
04:29:19 <dcoutts> Cale, well bug/quirk.
04:29:24 <Cale> yeah
04:29:30 <xerox> I'll try darcspulling.
04:30:00 <tomaszz> note the nested monads
04:30:27 <malcolm> tomaszz: looks quite nice
04:30:37 <Cale> dcoutts: It's probably possible for someone to claim it as a feature, but I'd call it a bug :)
04:30:46 <dcoutts> :-)
04:31:44 <tomaszz> malcolm: you get lexical closures and HOFs (almost) for free :-)
04:31:48 <malcolm> dons: want to resend (make system with map/fold)?
04:32:02 <dcoutts> malcolm, I guess the reason that Cabal requires the whole list of modules at the moment is that Cabal does not do the import chasing itself. It lets hugs/ghc --make do that. So it can't calculate the modules from the rootset. It needs the hmake code.
04:32:22 <int-e> Cale: it certainly violates the principle of least surprise.
04:32:33 <araujo> @index hPutStr
04:32:34 <lambdabot> System.IO
04:32:38 <malcolm> dcoutts: SyntaxNinja is going to steal the import-chasing from hmake soon.
04:32:45 <xerox> Cale: the latest version wasn't the one which drew a green tree on a black background?
04:33:05 <dcoutts> malcolm, oh great. The license is ok then?
04:33:25 <Cale> xerox: it is the latest, unless you did some new work :)
04:33:43 <dcoutts> dons, I quite liked JaffaCake's ghc --make system where it spawns a thread for each module which waits on the MVars for it's import modules. And then uses a semaphore to limit the concurrency.
04:33:47 <malcolm> dcoutts: my bit is OK, but some of the code belongs to Thomas Hallgren, so Isaac is going to ask him too.
04:33:55 <dcoutts> malcolm, right
04:34:00 <Cale> xerox: I think that feature is broken because you need a newer gtk2hs
04:34:01 <xerox> Cale: the one I just grabbed from your url draws the fluffy line, which I recalled to be a previous version.
04:34:11 <dons> just an idea I was toying with this week. make rules construct a tree, which is evaluated by walking the tree in preorder, pruning subtrees, and evaluating the code for each node/rule, until you reduce the tree to the root. most make rules are maps, i.e. %.o : %.c. but some are folds bin: $(OBJS).
04:34:13 <tomaszz> malcolm: I added more comments
04:34:20 <xerox> (I'm building the upgraded darcs repo sources)
04:34:25 <dcoutts> xerox, want to talk about the createSimilarSurface issue?
04:34:31 <dons> so I'm thinking there would be a nice way of both describing and evaluating such a tree using real maps and folds
04:34:35 <xerox> dcoutts, okay.
04:34:45 <Cale> xerox: hmm..
04:35:42 <Cale> xerox: does it have -> in the syntax?
04:35:46 <dons> dcoutts, ah! that is nice.
04:35:50 <Cale> (for the productions)
04:35:55 <xerox> Cale: nope.
04:35:59 <Cale> oh
04:36:01 <Cale> hmm
04:36:27 <xerox> Yay
04:36:37 <malcolm> tomaszz: I wonder if it could be made clearer by e.g. storing the different actions in a datastructure:  mkRule { match = do ...,  mkdependencies = do ...,  createtarget = do ... }
04:36:43 <xerox> The other one (drawing the tree, and having '->') works!!
04:36:55 <xerox> Cale: this is *impressive*
04:36:57 <Cale> oh, what?
04:37:03 <xerox> I wonder why it didn't work yesterday
04:37:10 <Cale> oh, okay :)
04:37:19 <xerox> Whoa.  You definitely rock.
04:37:38 <xerox> My gosh, you all people should try it :-D
04:37:40 <Cale> :)
04:37:42 <Cale> thanks
04:37:43 <tomaszz> malcolm: but then you wouldn't get nice lexical-closure
04:37:48 <xerox> I'll update the public repo.
04:37:59 <malcolm> tomaszz: oh yes, of course, silly me
04:39:55 <tomaszz> malcolm: the whole thing is much more friendly when I use Template Haskell to do perl-like string interpolation
04:40:24 <tomaszz> malcolm: so I can write: system $(interp "cat %{firstInput} %{secondInput} > %{target}"
04:40:25 <malcolm> tomaszz: perl-like == friendly?  hmm
04:40:28 <tomaszz> )
04:40:48 <malcolm> tomaszz: oh right, that does look nicer
04:41:02 <tomaszz> malcolm: instead of system ("cat " ++ firstInput ++ " " ++ secondInput ++ " > " ++ target)
04:41:49 <xerox> tomaszz: take in consideration the (somehow clearer) form: concat ["cat ",firstInput," ",secondInput," > ",target]
04:41:53 <tomaszz> got to go to eat some cauliflower ;-)
04:42:07 <dcoutts> xerox, so what should the type of withSimilarSurface be?
04:42:11 <xerox> @where nymphaea
04:42:11 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
04:42:20 <xerox> Public repo updated, check it out! ;)
04:42:27 <xerox> dcoutts, let me open it
04:42:33 <tomaszz> xerox: yes, or even (concat (intersperse " " ["cat",firstInput,secondInput,">",target])
04:42:42 <dcoutts> xerox, oh I'll gobby it
04:42:51 <xerox> That's a nice idea.
04:43:03 <Cale> xerox: I think the transparent background on that page should be slightly more opaque :)
04:43:15 <Cale> (it's kind of hard to read)
04:43:27 <malcolm> JohnMeacham did identify some more pressing problems with Cabal though - how do I tell it about a new preprocessor?  a new language extension?
04:43:43 <Cale> (though the background is beautiful)
04:43:45 <xerox> Cale: one of this weekend goals is to rewrite that page, and its style :-D  I had many people saying the same.
04:43:52 <xerox> Cale: yeah, I wanted to show it off! :D
04:52:34 <xerox> Cale: any idea about the acceptable characters issue?
04:55:18 <Cale> xerox: well, my idea for extending the parser is elaborate :)
04:55:42 <xerox> Please tell me :D
04:55:55 <Cale> What I'd like to do is to be able to define new symbols with graphics directives attached to them
04:56:16 <Cale> (possibly no graphics, in which case they'd be ignored in drawing)
04:56:33 <xerox> Yep.
04:58:00 <Cale> I think that it should not be too hard on the cairo side of things to have some functions which build some new drawing commands to get plugged into the turtle graphics renderer.
04:58:33 <Cale> We could build a Map of commands to cairo graphics.
04:59:01 <Cale> The parsing is also not so bad, but the UI seems like it could be somewhat involved :)
04:59:05 <Cale> (at least to me)
04:59:20 <xerox> How do you foresee it?
05:00:24 <Cale> Well, it would be nice if it had a layout in rows, one for each graphics command
05:01:19 <Cale> and each row would have a textbox for the command name, a dropdown list for the type of graphics, and then a properties button which would be hooked up to additional properties for that type of graphics
05:02:00 <Cale> Possibly if there are few properties for some kinds of graphics, one could just the controls inline.
05:02:20 <Cale> somewhat like a mixer on it's side. :)
05:02:30 <xerox> hehe
05:02:50 <Cale> It would be nice though, to have different colours :)
05:02:57 <xerox> So graphics will be base shapes like line, circle, etc..  or more complex things?
05:02:59 <Cale> yeah
05:03:03 <xerox> Oh, colours :-D
05:03:53 <Cale> yeah, aside from setting the basic foreground colour for each of the pens, perhaps a directive which sets a hue shift by degrees :)
05:04:13 <xerox> Woot.
05:04:26 <Cale> so, that should be a lot of coding already :)
05:04:46 <xerox> So...
05:05:05 <xerox> BBIAB.
05:05:09 <Cale> okay
05:05:11 <Cale> I was moderately overwhelmed by it, so I figured I'd wait for you to be around.
05:05:16 <Cale> heh
05:05:22 <xerox> Thanks ;)
05:20:46 <Igloo> rafl: I built what I hope will be the final thing overnight, so probably today if I don't find anything wrong with it
05:23:25 <Lunar^> Igloo: yeah! :)
05:23:38 <Lunar^> Igloo: did you sort out the cabal issue?
05:23:44 <Igloo> What cabal issue?
05:24:20 <Lunar^> does ghc6 package comes with cabal?
05:24:26 <Igloo> Yes
05:24:50 <Lunar^> No conflicts with libghc6-cabal-dev, then?
05:26:15 <Igloo> It doesn't Conflict: libghc6-cabal-dev, but the libghc6-cabal-dev in unstable won't be installable with it
05:26:27 <Igloo> Nor will any other library built against an older ghc
05:27:13 <Lunar^> Igloo: sure
05:27:34 <sieni> maybe I'll continue with my toy regex engine
05:27:55 <Lunar^> Igloo: is the amount of haskell packages sufficient to require coordination with the release team?
05:28:32 * Igloo talked to the release team before making this upload
05:29:15 <Lunar^> Igloo: that answers my question thanks
05:29:34 <Lunar^> The discussion about splitting fptools is really cool on a packaging POV
05:37:18 <kolmodin> @where ghc-api
05:37:19 <lambdabot> http://scannedinavian.com/~lemmih/ghc-api/
06:06:15 * ValarQ reads Cales article for the 4:th time
06:15:57 <araujo> @index hSetBuffering
06:15:58 <lambdabot> System.IO
06:46:14 <mcnster> morning
06:54:10 <Oejet> mcnster: Hello.
07:09:05 <xerox> Yow!
07:10:23 <ValarQ> 'lo xeroix
07:12:40 <dcoutts> hi xerox
07:12:54 <dcoutts> want to come see what we've done to your nice code :-)
07:16:55 <xerox> I'm reading the backlog :D
07:18:01 <xerox> MonadIO!
07:18:46 <dcoutts> yep
07:23:35 <dcoutts> xerox, ping!
07:23:50 <xerox> Pong!
07:23:56 <xerox> I've just finished reading the backlog.
07:23:59 * dcoutts tries to get a response from xerox about /privmsg sutff
07:24:18 <xerox> Woot. Didn't see, sorry.
07:24:23 <dcoutts> np
08:33:03 <araujo> @index wait
08:33:03 <lambdabot> bzzt
08:46:03 * araujo wonders what it is a good indentation style for functions that takes many arguments
08:47:25 <gaal> aloha. does anyone have a built GHC working copy handy? I want to generate a .HOO file for GHC libraries.
08:48:00 <Igloo> A what?
08:48:10 <gaal> a Hoogle definition file.
08:48:28 <gaal> Hoogle only does Prelude, but can be taught to know about GHC libraries too.
08:48:53 <JKnecht> I thought you meant a GHC binary.
08:49:14 <gaal> # http://no.perlcabal.org/~gaal/hihoo.pl
08:49:42 <gaal> JKnecht: nope, I need someone who built GHC themselves and left all the .hi files intact.
08:50:01 <gaal> seeing as that's the easiest way to fetch function signatures.
08:50:54 <ulfdoz> gaal: I can set up a build.
08:51:24 <gaal> ulfdoz: thanks!
08:53:29 <gaal> ulfdoz: this is a first take on the convertor, so likely a few things will have to be weeded out.
08:54:02 <gaal> but when you do have the interface files, try perl hihoo.pl -i ghc/hslibs > libraries.hoo
08:54:33 <lisppaste2> syntaxfree pasted "more errors I can't explain" at http://paste.lisp.org/display/12540
08:55:53 <xerox> So nobody came up with Haskell syntax highlighting for lisppaste.
08:56:08 <basti_> where is syntaxfree?
08:56:38 <xerox> haha.
08:56:44 <xerox> HE's watching us.
08:57:41 <basti_> hey syntaxfree. what type is []?
08:57:59 <syntaxfree> hmm. let me think
08:58:00 <ulfdoz> 'a list, I'd guess.
08:58:10 <syntaxfree> @type []
08:58:10 <ulfdoz> Sorry, for the ml syntax.
08:58:12 <basti_> a list of what? ;)
08:58:14 <lambdabot> forall a. [a]
08:58:27 <syntaxfree> a list of ones!
08:58:36 <syntaxfree> a list of integers.
08:58:50 <basti_> no it's a list of unrestricted "things"
08:59:03 <syntaxfree> oh, yes, by default.
08:59:10 <syntaxfree> I thought you were asking what I wanted to do.
08:59:11 <syntaxfree> I see.
08:59:39 <basti_> you do, yes? ;)
08:59:55 <syntaxfree> well, I half-see it.
09:00:31 <syntaxfree> I still fail to see why I can't declare a type that's less general than what the compiler expects.
09:00:59 <basti_> you can.
09:01:20 <basti_> unifying that is what causes problems
09:01:21 <syntaxfree> @type \n->(==) n [1]
09:01:22 <lambdabot> forall a. (Eq [a], Num a) => [a] -> Bool
09:01:34 <syntaxfree> unifying?
09:01:48 <syntaxfree> @type \n->(==) n []
09:01:49 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
09:02:19 <syntaxfree> ah, well.
09:02:33 <syntaxfree> I think I being to see it.
09:02:39 <syntaxfree> isZero and isOne are different.
09:02:55 <syntaxfree> can I then declare zero :: (Num a)=>[a]?
09:03:03 <ibid> unification is the process of seeing if by replacing types variables by types we can make to types identical
09:04:18 <syntaxfree> why can't I do zero :: (Num a)=>[a]  and then zero=[]?
09:04:29 <syntaxfree> I want zero to be an empty list of nums!
09:05:06 <basti_> you can't?
09:05:11 <basti_> you should be able to!
09:05:17 <syntaxfree> yes. I'll show you.
09:05:23 <basti_> i can
09:06:08 <neologism> syntaxfree: what do you mean by zero = [] ?
09:06:13 <neologism> thats a type or?
09:06:20 <lisppaste2> syntaxfree pasted "nothing but trouble" at http://paste.lisp.org/display/12541
09:06:23 <xerox> neologism: it's a value
09:06:57 <kosmikus> @plugs let zero :: (Num a) => [a]; zero = []; in zero
09:06:58 <lambdabot> []
09:07:30 <syntaxfree> OH.
09:07:30 <syntaxfree> fixed.
09:07:34 <basti_> syntaxfree: thats because your program not only implies Eq a
09:08:34 <syntaxfree> why does the compiler infer Eq [a], but Eq a will work?
09:09:42 <kosmikus> because there's an instance of the form "Eq a => Eq [a]"
09:09:56 <syntaxfree> ah. of course.
09:10:09 <syntaxfree> What's the most restricted type of numbers? I just need it to store a list of ones.
09:10:27 <xerox> Int, I believe.
09:13:02 <syntaxfree> I can create a custom datatype that stores a list of ones, right?
09:13:29 <xerox> Indeed.
09:13:56 <syntaxfree> I know how to create a datatype that will store one of a discrete set of choices, but how do I make an "infinite" one like that?
09:14:01 <syntaxfree> a variable-length list of ones?
09:14:27 <rlaager> Given a number n and a character c, I would like to build a string containing n copies of c. For example: f 3 'x' would produce "xxx" Can anyone point me to the best way to do this?
09:14:49 <xerox> ones = 1 : ones
09:14:49 <ibid> that's a good exercise :)
09:14:57 <syntaxfree> f 0 x = []
09:15:05 <syntaxfree> f n x = x : f (n-1) x
09:15:20 <xerox> take n $ repeat x
09:15:58 <TheHunter> replicate n x
09:16:11 <xerox> Okay :-)
09:16:57 <syntaxfree> data Nat  a = 1 | 1: (Nat a)?
09:17:01 <syntaxfree> is that it?
09:17:49 <xerox> syntaxfree: data <TypeConstructor> <Type Variables> = <DataConstructor 1> | .. | <DataConstructor n>
09:18:19 <syntaxfree> I don't understand :(
09:18:53 <Mortis_kruul> Look at http://www.muzyka.oz.pl :)
09:19:30 <xerox> syntaxfree: you need data constructors to construct values of the given data type.
09:19:43 <xerox> The classical example is  data Maybe a = Just a | Nothing
09:21:20 <syntaxfree> dang brb.
09:22:16 * int-e ponders data Nat = :- | :+ Nat
09:22:54 * xerox sees Oleg's code coming in the distance
09:23:05 <ndm> data Nat = Zero | Succ Nat
09:23:10 <ndm> thats the standard definition
09:23:45 <int-e> Yes. the :... constructors only really make sense as binary constructors anyway.
09:24:13 <ndm> indeed
09:24:30 <ndm> or data Number = Zero | Pos NatP | Neg NatP
09:24:39 <ndm> data NatP = One | Succ One
09:24:43 <Cale> data HZero; data HSucc a; class HNat a; instance HNat HZero; instance (HNat a) => HNat (HSucc a)
09:25:47 <int-e> *Main> print ((:-) (:+))
09:25:47 <int-e> (:-) :+
09:26:07 <xerox> Smileys!
09:26:10 <int-e> [using data Nat = (:+) | (:-) Nat deriving Show]
09:26:31 <int-e> useless, but cute.
09:26:41 <ndm> int-e, useless?
09:26:50 <ndm> defined that way, you get lazy naturals
09:27:02 <ndm> so length a > length b is true even if b is an infinite list
09:27:14 <ndm> whereas currently in haskell that is neither true nor false, its bottom
09:27:26 <Igloo> That looks like a deriving Show bug
09:27:39 <int-e> ndm: I didn't mean the type, I meant the naming of the constructors. There are arguably uses for such a type with properly named constructors.
09:27:54 <ndm> int-e: fair enough :)
09:28:06 <ndm> can you have non-binary : constructors?
09:28:31 <Cale> well, yes, as was just shown :)
09:28:53 <Igloo> Impressive, hugs and ghc have /different/ deriving Show bugs there
09:29:06 <Cale> heh
09:29:09 <ndm> what about nhc?
09:29:18 <Igloo> I dunno, I don't have it installed any more
09:29:33 <Igloo> It needs to give :- (:+) to give us the full set
09:30:14 <int-e> it needs to give (:-) (:+)  to work.
09:30:24 <int-e> neither :- nor :+ are binary
09:30:57 <Igloo> Aww, nhc98 gets it right. How boring.
09:31:24 <ndm> woot, and hence yhc
09:34:15 <int-e> ndm: wait a second. "so length a > length b is true even if b is an infinite list" are you sure?
09:34:34 <ndm> ahem, switch to <
09:35:08 <ndm> or flip your definition of < and >, either is possible in haskell...
09:37:24 <dcoutts> xerox, Cale, ping
09:37:40 <Cale> hello
09:37:47 <dcoutts> see gobby session
09:38:06 <dcoutts> and I'm about to upload a new haddock'ed version of the docs
09:38:57 <astrolabe> Does an infix operator have to be made entirely of symbols, or just begin with a symbol?
09:39:40 <Igloo> Entirely of symbols
09:39:40 <ndm> astrolabe: entirely symbols
09:39:46 <xerox> dcouttspong
09:39:49 <astrolabe> thanks
09:40:11 <araujo> Well you can make a function infix with 
09:40:12 <int-e> astrolabe: see http://www.haskell.org/onlinereport/lexemes.html#ids for the gory details.
09:40:25 <int-e> araujo: wrong ones, it's ``.
09:40:33 <araujo> oh yeah :-)
09:47:17 <syntaxfree> my irc client converts stuff like :) to smileysa.
09:47:25 <syntaxfree> anyway, I have to learn data constructor syntax, it seems.
09:48:00 <xerox> Which client is it, syntaxfree?
09:48:07 <syntaxfree> Conversation.
09:48:25 <Cale> syntaxfree: there's usually a way to turn that off
09:48:33 <syntaxfree> yes, probably.
09:48:57 <syntaxfree> bingo. graphical smileys  off ;)
09:50:08 <syntaxfree> data Nat = Zero | Succ Nat
09:50:25 <syntaxfree> hmm. Does Haskell have some kind of natural number type?
09:50:32 * xerox hands syntaxfree a prolog
09:50:53 <syntaxfree> I really was trying to define natural number operations in terms of lists.
09:51:05 <syntaxfree> It's for my Scheme-vs-Haskell project.
09:51:15 <syntaxfree> first instance here:
09:51:18 <syntaxfree> @hawiki DiegoNavarro
09:51:19 <lambdabot> http://www.haskell.org/hawiki/DiegoNavarro
09:52:20 <xerox> Blech, ") ) )" 
09:53:49 <syntaxfree> Cale did the indentation on my Scheme code.
09:53:58 <syntaxfree> I had posted it as a monolithical block.
09:54:08 <ulfdoz> Some week ago, there was url in the topic, which explained, how to use a parser for tupling operations on a data structure. If somebody remembers, I'd like to reread it. Wasn't able to find it.
09:54:21 * syntaxfree loves to write Scheme code in one neverending line that gets wordwrapped to an unreadable mess.
09:54:31 <xerox> Trailing ") ) )" is horrible :-)
09:54:39 * int-e would append them to the last line
09:54:46 * xerox too
09:54:53 <syntaxfree> Well, ask Cale.
09:55:01 <xerox> It's a wiki, in the end.
09:55:16 <syntaxfree> my favorite style is the monolithic block, but he was so nice to take the time to do it, I thought I'd leave it like that.
09:55:59 <JKnecht> uldfdoz: why not search the archive (meme.b9.com)?
09:56:19 <araujo> There exist a function to return a polymorphic value but that does nothing else?
09:57:09 <SamB> hmm, how do you use gtk2hs from GHCi without having GTK highjack the process?
09:57:18 <Mortis> Look at http://www.muzyka.oz.pl :)
09:58:04 <SamB> araujo: you mean like 'error "foo"'?
09:58:09 <ulfdoz> cool frontend.
09:58:11 <xerox> SamB: what's your error?
09:58:17 <araujo> syntaxfree, add yourself to http://www.haskell.org/hawiki/HaskellUserLocations!!!
09:58:24 <araujo> SamB, yes, something like that
09:58:30 <araujo> But it isn't an error
09:59:18 <SamB> xerox: error? no error. I just want to be able to keep doing stuff but also have GTK run its event loop...
09:59:32 <xerox> SamB: I think it's not possible.
10:01:21 <tomaszz> xerox: even using a threaded RTS?
10:01:49 <xerox> tomaszz: dcoutts explained it in a paper on the Gtk2Hs site, I think.
10:04:30 <araujo> Anybody knows?
10:04:58 <tomaszz> xerox: that's unfortunate
10:11:20 <dcoutts> tomaszz, you can use Haskell threads with Gtk2Hs, however you can't use the threaded RTS
10:11:26 <dcoutts> oh he's gone
10:11:51 <Cale> dcoutts: check that Cairo.hs is saved
10:11:53 <dcoutts> xerox, Cale, thanks for helping with the new code & docs
10:11:58 <dcoutts> Cale, it is. Ta.
10:12:02 <Cale> there's a star next to it in Gobby
10:12:29 <SamB> how would you use the threaded RTS normally?
10:14:14 <SamB> hmm, so forkIO is no help...
10:15:39 <lisppaste2> syntaxfree pasted "mo' problems (no, it's not indentation)" at http://paste.lisp.org/display/12543
10:16:18 <SamB> this never happens in smalltalk!
10:16:21 * int-e wonders if forkOS can help.
10:16:52 <SamB> int-e: actually, thats what I meant to do! but I did the wrong one by mistake
10:17:12 * int-e has found that the RTS threading engine interrupts sleep system calls for the first OS thread but not for the other.
10:17:40 <syntaxfree> the type ladder is a steep climb.
10:17:40 <JKnecht> @listcommands
10:17:41 <lambdabot> use listcommands [module|command], please. Modules are:
10:17:41 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
10:17:41 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
10:17:41 <lambdabot> spell state system todo topic type version vixen where
10:18:07 <dcoutts> SamB, there's a trick to use threads with Gtk2Hs
10:18:18 <dcoutts> then one can use forkIO as much as you want
10:18:19 <smott> syntaxfree: you should put the type of the function directly above the function body. it's much easier to read for someone unfamiliar with the code then
10:18:22 <JKnecht> @listcommands topic threads
10:18:23 <lambdabot> No module "topic threads" loaded
10:18:30 <SamB> dcoutts: trick?
10:18:35 <dcoutts> SamB, see...
10:18:50 <droundy> @listcommands darcsPatchWatch
10:18:51 <lambdabot> darcsPatchWatch provides: repos repo-add repo-del
10:18:52 <JKnecht> @topic threads
10:18:53 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-
10:18:53 <lambdabot> tail topic-tell join todo type
10:19:06 <dcoutts> SamB, http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
10:19:15 <droundy> @repos
10:19:16 <lambdabot> {no repositories defined}
10:19:22 <xerox> dcoutts, thanks to you for the hard work :D  Gotta study now.
10:19:37 <syntaxfree> @dance
10:19:37 <lambdabot> "dice" (line 1, column 1):
10:19:37 <lambdabot> unexpected end of input
10:19:37 <lambdabot> expecting digit
10:20:02 <droundy> @repo-add http://darcs.net
10:20:03 <lambdabot> cannot add invalid repository: http://darcs.net/_darcs/inventory:
10:20:03 <lambdabot> getPermissions: does not exist (No such file or directory)
10:21:41 <dcoutts> xerox, oh I wanted to show you the star demo and how nice it is now :-)
10:21:59 <xerox> I still poke here once a while :D  /me watches
10:22:12 <dcoutts> xerox, see in gobby starAndRing
10:22:40 <xerox> Woot!
10:24:21 <malcolm> is there a way to get darcs record messages sent out to a mailing list, like cvs commit does?
10:28:59 <Philippa_> can't think of one, though it'd be easy to do with darcs send if you keep a personal repo and a central one
10:29:21 <droundy> It requires a bit of an extension to the --post-hook feature.  Not hard to implement.
10:29:47 <malcolm> I think when fptools moves over to darcs, we'll want that feature.
10:30:17 <Igloo> You can do it with the test hook, but fixing post hook to be able to do it would be better
10:30:41 <droundy> We just need to pass the patch names in an environment variable to the post-hook.
10:31:16 <Igloo> Oh, yes, sorry, test would have the same problem
10:42:54 <fnord123> do the kkk use haskell? :(
10:44:06 <malcolm> the kool koders of kentucky?
10:44:45 <fnord123> klu klux klan - a discriminating group of people
10:45:08 <malcolm> but are they discriminating hackers?
10:45:31 <glguy> Could someone recommend a haskell compiler for OS X (for someone with an interest in haskell who's just getting started)
10:45:43 <fnord123> glguy: i use ghc to good effect
10:45:56 <fnord123> coming from C++ and bigloo, it works a treat for me
10:46:10 <malcolm> glguy: nhc98 and hugs also work OK on OS X
10:46:11 <fnord123> (and im on os x)
10:46:35 <glguy> I'm installing ghc 6.4 from darwinports... hopefully that's the current version
10:46:55 <fnord123> i think there might be a 6.4.2 but i dont think youll see a difference until you're hardcore
10:46:57 <Thorn> hello
10:47:07 <fnord123> hello thorn
10:47:28 <Thorn> hi fnord123
10:48:47 <psi_> dons: should nhc98 build on openbsd ppc?
10:48:57 <psi_> my build segfaults
10:49:29 <malcolm> psi_: file a bug report on nhc98 :-)
10:49:57 <malcolm> psi_: it's probably something to do with gcc-4.0 at a guess
10:50:21 <fnord123> im looking to find out what => does. I see it in type decls a lot
10:50:46 <fnord123> ive looked on two syntax 'tours' and neither discussed it
10:50:58 <psi_> stupid color scheme. i can't see who's replying :-) however, I'm using gcc 3.3
10:51:53 <malcolm> psi_: which version of nhc98?
10:51:59 <glguy> openbsd isn't going to go to gcc-4 for a long time
10:52:11 <psi_> version 1.16
10:52:13 <glguy> they like propolice more than the features in gcc-4
10:52:37 <malcolm> psi_: try 1.18, it fixed a couple of bugs in that respect
10:53:14 <fnord123> proper optimisations using SSA trees will probably come in 4.2 - and then it will be great, imo
10:53:38 <psi_> mkay, I might. that means I have to go outside the ports tree, though.
10:54:05 <malcolm> psi_: tell the port maintainer to upgrade to 1.18 too
10:54:34 <ulfdoz> gaal: your script does nothing.
10:55:18 <psi_> malcolm: ok. that's dons :-)
10:55:24 <astrolabe> Is there a built in 'and' operator that only evaluates the second argument if the first is true?
10:55:31 <Igloo> &&
10:55:39 <Thorn> is there an event library for haskell? like Qt signals, or boost::signal, or erlang messages?
10:55:46 <astrolabe> Igloo: Thanks
10:55:47 <psi_> perhaps it's already updated, though. I'm using the stable ports tree.
10:55:49 <gaal> ulfdoz: you need -i file; and i'll have a much improved version very very soon.
10:55:54 <gaal> (and thanks!)
10:55:57 <malcolm> psi_: dons is probably asleep right now
10:56:09 <psi_> yeah
10:56:38 <ulfdoz> gaal: At least I don't get any output. It silently terminates after about ten seconds.
10:56:43 <malcolm> astrolabe: && is not builtin - laziness means it doesn't need to be.
10:57:05 <gaal> ulfdoz: can you pick one hi file, and do hihoo.pl -i thatfile.hi  ?
10:58:09 <astrolabe> @pl True && error "blah"
10:58:09 <lambdabot> True && error "blah"
10:58:28 <astrolabe> bums, how do you get it to evaluate something?
10:58:53 <malcolm> @eval False && error "broken"
10:58:55 <lambdabot> False
10:59:06 <astrolabe> malcom: duh thanks
10:59:16 <ulfdoz> gaal: No change.
10:59:52 <malcolm> @eval True || undefined
10:59:54 <lambdabot> True
11:00:22 <gaal> ulfdoz: okay, let me put up the newer version.
11:01:16 <astrolabe> Oh, I get it, &&:: Bool -> Bool -> Bool, so it evaluates the arguments in order.
11:01:48 <gaal> ulfdoz: please try the version at http://no.perlcabal.org/~gaal/hihoo.pl
11:01:57 <gaal> ndm: ping
11:02:16 <astrolabe> @pl (&&) False
11:02:18 <lambdabot> (False &&)
11:02:34 <astrolabe> @pl (&&) True
11:02:34 <lambdabot> (True &&)
11:02:40 <astrolabe> boo!
11:02:57 <astrolabe> hee.  no offence brx
11:02:58 <xerox> What did you want? :)
11:03:27 <astrolabe> (True &&)   ~    id    ?
11:03:29 <int-e> const False
11:03:34 <int-e> for the latter
11:03:46 <astrolabe> int-e right
11:03:58 <int-e> err. first. sorry.
11:04:12 <astrolabe> int-e: even more right!
11:06:28 <ulfdoz> gaal: Now several empty lines are printed.
11:07:19 <SyntaxNinja> some estonia photos here: http://www.syntaxpolice.org/pics/estoniaBerlin/Estonia/index.html
11:07:29 <SyntaxNinja> some of you might be in them :)
11:08:04 <gaal> ulfdoz: very strange! what file are you running it on?
11:09:11 <ulfdoz> gaal: Tried Posix.hi and FiniteMap.hi
11:09:41 <gaal> ulfdoz: does ghc --show-iface on either of these files produce output?
11:10:02 <gaal> and are you using a not-ancient perl?
11:11:13 <gaal> SyntaxNinja: funny pic of autrijus there :)
11:11:25 <ulfdoz> gaal: Yes, on both files I get output. perl version 5.8.6.
11:11:42 <SyntaxNinja> gaal: yeah :)
11:11:54 <SyntaxNinja> he is, of course, hacking :)
11:12:09 <gaal> of course :)
11:16:29 <gaal> ulfdoz: what platform are you using?
11:16:44 <gaal> maybe open-pipe is broken there?
11:18:34 <ulfdoz> gaal: gentoo-linux on Athlon.
11:18:45 <xerox> SyntaxNinja: add names to pics' infos :D
11:18:58 <syntaxfree> new installment in the "The same code in Scheme and Haskell" series.
11:19:11 <syntaxfree> @hawiki DiegoNavarro
11:19:12 <lambdabot> http://www.haskell.org/hawiki/DiegoNavarro
11:19:16 <gaal> ulfdoz: that definitely oughta have pipe-open :)
11:24:22 <SyntaxNinja> autrijus: is your email inbox full?
11:24:32 <SyntaxNinja> I got a file too large error while trying to email you
11:24:46 <SyntaxNinja> my email probably looks like spam to a computer.
11:25:02 <SyntaxNinja> "hey I just wanted to let you know that there is a picture of you online..."
11:26:21 <SyntaxNinja> it's a sad day when you have to try to figure out a way to write a simple email and NOT sound like spam.
11:27:45 <gaal> SyntaxNinja: given sufficient $@%, it'll look like Perl to the Bayes filter.
11:27:48 <ulfdoz> gaal: Would it help you, if I bundle the hi files for you?
11:28:07 <sethk> syntaxfree, start by mentioning that you have $32 million that you need to transfer out of the country
11:28:09 <Blicero> replace your email spellchecker with a bayeschecker
11:28:11 <SyntaxNinja> gaal: perl looks like swearing?
11:28:32 <gaal> ulfdoz: not sure if my ghc can read yours (i686 here), but sure, let's try.
11:28:33 <malcolm> SyntaxNinja: photos show lots of hairy people - I should have been there...
11:28:42 <SyntaxNinja> malcolm:  :)
11:28:45 <gaal> # gaal@forum2.org
11:28:52 <SyntaxNinja> malcolm: I forget if you have a beard? I remmeber your long hair
11:29:26 <gaal> SyntaxNinja: Perl has its distinctive style. That's it.
11:29:33 <malcolm> beard yes, but not as long as my hair.
11:30:18 <SyntaxNinja> malcolm: though I think your hair is more tame and orderly than Ian and David (that's Igloo and droundy, btw)
11:30:38 <SyntaxNinja> but yes, you should have been there :) next year?
11:31:11 <malcolm> SyntaxNinja: should be there the next 3 years, dv
11:37:18 <ndm_> i see my photos :)
11:37:38 <gaal> ndm_: which one is you? :)
11:38:50 <ndm_> ginger :)
11:39:00 <ndm_> http://www.syntaxpolice.org/pics/estoniaBerlin/Estonia/13.html
11:39:06 <ndm_> in the front of hte picture
11:39:55 <gaal> Ah, the only picture with short haired people it it
11:42:23 <gaal> sent you a .hoo btw.
11:42:30 <Philippa_> bah, maybe I'll make it sometime
12:01:21 <ndm_> gaal, cheers - got it
12:01:37 <ndm_> and my hair in that is relatively long compared to normal
12:05:01 <syntaxfree> everytime I let my hair grow a bit, it starts falling.
12:18:49 <ulfdoz> There are days, where people do strange things.
12:21:31 <ulfdoz> gaal: After significantly improving the method to call tar with all relevant information, I proudly offer your tarball at http://www.gislin.de/misc/hi_files.tar.bz2 (160kb).
12:26:24 <a-zwei> does anyone know of a time library for ghc (on windows) that has higher than 1 sec precision? I was going to try the one at http://semantic.org/TimeLib/ , but it doesn't appear to compile under windows
12:27:56 <sylvan> a-zwei, CPUTime
12:28:03 <sylvan> @index CPUTime
12:28:04 <lambdabot> bzzt
12:28:06 <sylvan> hmm
12:28:28 <a-zwei> I thought that only got the cpu usage time
12:28:47 <sylvan> ah, true
12:29:25 <sylvan> System.Time looks to have picosecs, no?
12:29:47 <a-zwei> yeah, but (on windows, at least) it always seems to just be 0
12:29:55 <sylvan> hmm.. weird
12:32:32 <a-zwei> maybe I'm wrong. I tested some more and actually got a picosec value
12:33:06 <sylvan> yeah it seems to work here
12:33:09 <a-zwei> ok
12:33:11 <a-zwei> thanks
12:33:12 <ulfdoz> ghc is an amazing slow compiler....
12:33:19 <a-zwei> heh
12:33:40 <ulfdoz> 2h until now for a built of ghc itself.
12:39:24 <Lemmih> GHC isn't really that slow. Compiling large amounts of Haskell is a complex task.
12:41:40 <Oejet> And linking takes a lot of time, but I don't know why.
12:41:59 <malcolm> Oejet: are you on solaris?
12:42:25 <Oejet> malcolm: GoboLinux, I'm the only user.
12:42:56 <malcolm> Oejet: not using an NFS-mounted filesystem?
12:42:58 <Oejet> There's plenty of memory to spare, it seems.
12:43:22 <Oejet> No, local Reiserfs.
12:44:18 <Oejet> The CPU load is about 100% for about three minutes linking Hello World from the Gtk2Hs distribution.  That's a 7MB binary though.
12:44:24 <malcolm> Oejet: hmm, don't know why it should be slow then
12:44:39 <malcolm> Oejet: 3 minutes?  that's outrageous
12:46:08 <malcolm> Oejet: try running ranlib on all of the lib.a archives maybe?
12:46:55 <Oejet> Hm, I'm not exactly sure what that means.  Do you mean the Gtk2Hs ones?
12:48:13 <malcolm> Oejet: all the ones being linked against I suppose.  It's only a thought, I don't know whether it will help or not.
12:49:59 <Oejet>  /demo/hello] make  =>  212.28s user 4.28s system 94% cpu 3:49.38 total
12:51:13 <Oejet> ldd helloworld |wc -l  => 27
13:07:09 <Maddas> ulfdoz: You think 2h is amazingly slow? Heh.
13:09:44 <Maddas> (Maybe I've just had bad luck when choosing my own software projects, though :-)
13:13:06 <ulfdoz> Maddas: My own projects are not that large that I could recognize it. :)
13:13:38 <Maddas> Er, sorry, when choosing software projects that I compile on my own. Definitely not projects that I am the author of :-)
13:14:36 * shapr boings
13:16:44 * shapr cackles happily
13:19:21 <genneth> anyone see that paper on asynchronous signals in haskell?
13:20:12 <ValarQ> shadowie: what?
13:21:04 <ValarQ> eh, s/shadowie/shapr/
13:22:37 <Oejet> genneth: http://www.haskell.org/~simonmar/bib/async01_abstract.html ?
13:23:04 <genneth> Oejet: yes
13:23:48 <ValarQ> shapr: still awake?
13:24:16 <genneth> ValarQ: i think he cackled his way into a coma
13:24:26 <ValarQ> :(
13:24:32 <frederik> it was a death cackle
13:24:52 <ValarQ> po' lil' shaper
13:25:41 <ValarQ> well well
13:26:06 <ValarQ> maybe someone else feels like assisting me with this monad trouble...
13:26:29 <ValarQ> i got here this 'Gen String' thingie
13:26:48 <ValarQ> and in the other hand i got this 'String' thing
13:27:43 <ValarQ> and in front of me is this 'ghc' saying that those are incompatible
13:28:18 <malcolm> ValarQ: so a String isn't a Gen String, seems obvious
13:28:23 <ValarQ> i was thinking about converting the 'String' to a 'Gen String' but i don't see how to do that in a good way
13:28:46 <malcolm> ValarQ: did you say the Gen is a monad?
13:28:46 <ValarQ> malcolm: no, that sounds reasonable
13:28:53 <fnord123> If I have a function I don't intend to export, and I define it and ghc says "not in scope: functionName" then how might i put functionName in scope
13:28:55 <ValarQ> malcolm: yes, i believe it is
13:29:32 <malcolm> ValarQ: so "return s" ought to lift a String s into the monad to become a Gen String
13:29:35 <ValarQ> malcolm: both shapr and the ghc 'Haskell Hierarchical Libraries' calls it a monad
13:30:51 <malcolm> fnord123: import the module containing  the function?
13:31:05 <fnord123> I'm defining it
13:31:35 <malcolm> fnord123: so maybe you mis-spelled it
13:31:45 <fnord123> perhaps function names need to be capitalised
13:31:51 <glguy> This is a really newb question I'm sure, but I'm trying to follow a Haskell tutorial.. how do I type these example functions into Hugs? when I try to say: fibs :: [Int]   I just get an error
13:31:54 <ValarQ> malcolm: hmm, that might just do the trick...
13:32:17 <malcolm> ValarQ: which monad is Gen?  is it in QuickCheck?
13:32:28 <ValarQ> malcolm: yeah, Test.QuickCheck
13:32:40 <Oejet> glguy: What error do you get?
13:32:55 <glguy> Oejet: ERROR - Undefined variable "fibs"
13:33:12 <ValarQ> malcolm: i did another crazy thing thought (feel free to laugh at me anytime)
13:33:20 <Oejet> glguy: You probably didn't define fibs yet, did you?
13:33:37 <malcolm> glguy: you need to put the function definition into a file, then load it into Hugs with :load file.hs
13:33:59 <glguy> malcolm: when I tried that, i got even crazier errors :)
13:34:09 <ValarQ> malcolm: i have this 'member px m' statement which is delievers a bool
13:34:19 <glguy> bah
13:34:27 <glguy> okay, it works from the file
13:34:36 <Oejet> glguy: Hehe.
13:34:43 <ValarQ> malcolm: now m is a monad so i thought about using 'liftM (member px) m' instead
13:34:50 <glguy> Oejet: the problem was that I had: take 10 fibs     in my file
13:34:53 <glguy> Oejet: and it didn't like that
13:34:54 <ValarQ> malcolm: that didn't work to well thought
13:35:09 <sylvan> glguy, hugs isn't like some of the interactive environments for other languages. In other words: You can't define stuff in hugs, just test stuff already defined in a file
13:35:38 <glguy> sylvan: good to know :) the other language I was playing with before this one was Lisp
13:35:43 <glguy> so you can see where I went wrong :)
13:36:36 <Oejet> glguy: File.hs: definitions (e.g. fibs :: [Int]...), Hugs: expressions (e.g. take 10 fibs).
13:36:36 <genneth> ValarQ: how did it not work?
13:36:38 <malcolm> ValarQ: what would the lifted version return, if the unlifted version returned a Bool?
13:37:09 <ValarQ> "Couldn't match `Bool' against `t -> t1'" my ghc would say
13:37:25 <ValarQ> (maybe it's just another error of mine)
13:37:34 <genneth> ValarQ: whats the type of m?
13:37:51 <ValarQ> 'm' is a 'Gen String'
13:38:13 <ValarQ> wait, that was the wrong message
13:38:16 <Oejet> I'm going to bed.  See you sometime again.
13:38:19 <ValarQ> "Couldn't match `Bool' against `m r'" is the real thing
13:38:38 <glguy> Oejet: just a quick question... given that fibs is the sequence of fibanacci numbers, if I type fibs !! 1000, does that mean that the first 1000 elements will be stored in memory forever? or does hugs clean that up as it goes
13:39:01 <genneth> glguy: it will clean it up when it thinks it should...
13:39:41 <glguy> genneth: on those lines, I did a fibs !! 10000 (obviously would be a big number) and now I get Garbage collection fails to reclaim sufficient space on all further operations...
13:39:49 <glguy> is there a way to fix that short of :q
13:39:57 <genneth> :gc
13:39:59 <malcolm> glguy: If fibs is a top-level value, Hugs will keep the 1000 elements, yes, until you load a new file, or explicitly clean up with :gc
13:40:23 <ValarQ> can't i use liftM in a guard?
13:40:36 <genneth> ValarQ: i don't see why not
13:40:43 <ValarQ> hmm :(
13:40:54 <genneth> ValarQ: any complete examples we can peek at?
13:40:56 <glguy> Main> :gc \n ERROR - Garbage collection fails to reclaim sufficient space
13:40:58 <glguy> :)
13:41:09 <malcolm> ValarQ: but the guard must still be a  Bool overall
13:41:49 <ValarQ> genneth: sure
13:42:04 <ValarQ> malcolm: i guess it's a 'Gen Bool'
13:42:16 <ValarQ> http://arda.no-ip.org/nmarkov.hs
13:42:26 <ValarQ> i'm working with ghc6.4 btw
13:43:31 <genneth> ValarQ: good point there from malcolm; what you might want to do is to keep pushing functions down, past the monad, and use higher up
13:43:38 <malcolm> ValarQ: m is a Map, right?
13:44:37 <ValarQ> malcolm: yes, i guess i was confused when i called it an "Gen String" earlier
13:45:01 <malcolm> ValarQ: and what you really want is for px  to be 'run' to generate a value that you can lookup in the Map?
13:46:25 <ValarQ> malcolm: well, the map is a 'Map (String,String) [String]'
13:47:18 <ValarQ> malcolm: and i'm working with 'Gen Strings' a lot, so somewhere i must be able to do a comparison of them, or am i wrong?
13:47:43 <malcolm> ValarQ: what I'm saying is that, rather than lifting 'member' into the Monad, you want to drop px out of the monad.  I'm sure there must be a 'runGen' operation or something?
13:48:20 <ValarQ> malcolm: there is the generate function
13:48:24 <genneth> ValarQ: you can compare them, you just can't use the resulting values everywhere; Gen encodes impurity, doesn't it?
13:51:08 <ValarQ> genneth: i guess you're right
13:51:24 <glguy> I promise to keep my questions to a minimum, but could someone tell how to correct my type error in the following: divbyten :: Num a => [a] -> [a] \n divbyten x = map (/ 10) x
13:51:59 <int-e> @type (/)
13:52:00 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:52:01 <ValarQ> malcolm: but px needs to be a '(Gen String, Gen String)'
13:52:14 <glguy> and a Fractional isn't a num?
13:52:20 <int-e> glguy: you need a Fractional instance for a, a Num instance isn't enough.
13:52:23 <ski> @type div
13:52:24 <lambdabot> forall a. (Integral a) => a -> a -> a
13:52:32 <int-e> glguy: every Fractional is a Num but not vice versa
13:52:37 <glguy> ah, okay
13:52:42 <malcolm> ValarQ: (p1,p2) = px, and then you need to generate p1 and generate p2 before pairing up the results again
13:52:50 <ski> try that if you want to divide and throw away the fractional part (really, the remainder)
13:53:02 <ski> @eval 16 `div` 7
13:53:04 <lambdabot> 2
13:54:23 <ValarQ> malcolm: you're saying i got to move my 'generate' down a great bit?
13:55:18 <Cale> Hello all
13:55:25 <ValarQ> hello Cale :)
13:55:42 <ski> @eval 16 / 7
13:55:43 <lambdabot> 2.2857142857142856
13:55:58 <Cale> glguy: learning Haskell? Don't worry about minimising your questions too much, people are generally willing to help out :)
13:56:24 <glguy> Cale: I just don't want people to feel that I should have read more before pestering them
13:56:41 <Philippa_> don't worry, we'll tell you to RTFM if we do
13:56:42 <ValarQ> malcolm: if i do i got the problem i had before i used Gen, i had to pass around the randomgenerator everywhere
13:56:50 <Cale> Philippa_: hehe
13:56:56 <genneth> ValarQ: i think the general rule is that you should minimise the influence of monads; and keep them only at the topmost layer
13:57:13 <Philippa_> that certainly applies to IO, I'm less sure about other monads
13:57:31 <syntaxfree> glguy: the channel is very helpful with the most basic questions.
13:57:33 <ValarQ> genneth: i have been trying to do that, but i need 'choose' to be pretty low
13:57:34 <Philippa_> part of me wants to just have everything be monadic by default so I can play semantic lego all day long
13:57:37 <genneth> Philippa_: Gen and Random are one way i think
13:57:42 <ski> genneth : for IO, anyways
13:57:43 <ValarQ> genneth: or at least i thing i need that
13:57:48 <glguy> Alright, so I'm trying to write a function that takes a list of numbers, and returns a list whose 2 norm is 1, I'm having trouble getting the function's type declaration correct, tho
13:57:56 <syntaxfree> glguy: anyway, I'm somewhat a beginner too, so I'm bound to be more patient than the gurus ;-)
13:58:08 <syntaxfree> what is a 2-norm?
13:58:13 <Philippa_> "whose 2 norm is 1"?
13:58:16 <glguy> magnitude, sum of squares
13:58:26 <genneth> glguy: you can try not declaring the type, and see what the compiler gives you...
13:58:29 <malcolm> ValarQ: yeah, after all your 'makeText' function is returning a list of Gen Strings, so you can use the Gen Strings you pass in to construct the ones you pass out.
13:58:43 <genneth> glguy: and are you a phycist by vocationL
13:58:45 <Philippa_> yeah, I wouldn't have declared a type for that
13:58:57 <ski> glguy : so you want to divide all elements with the norm ?
13:58:59 <Cale> in general, the p-norm of a vector in R^n is  (sum over i = 1 to n of (x_i)^p)^(1/p)
13:59:02 <Philippa_> I give types when I know more than the compiler might: this isn't one of those situations
13:59:03 <glguy> ski: yeah
13:59:04 <ValarQ> malcolm: ?
13:59:14 <glguy> genneth: I'm a computer science student
13:59:20 <Cale> if the vector x has components (x_1, x_2,..., x_n)
13:59:30 <glguy> I thought that the types were required, learning something new :)
13:59:39 <Philippa_> heh
13:59:42 <ValarQ> malcolm: what do you mean by construct?
13:59:58 <genneth> glguy: i thought only us phycists and mathmos used norms... turns out they're more used than i thought
14:00:05 <Cale> glguy: yeah, Haskell has pretty decent type inference
14:00:12 <malcolm> ValarQ: So, you can run generate, that's what I mean by construct
14:00:27 <ski> glguy :  twoNorm :: Fractional a => [a] -> [a]   ?
14:00:30 <genneth> glguy: if haskell require type handholding, we'd all just find another language to play with... :-)
14:00:45 <glguy> ski: yeah, that's what I have now
14:00:55 <Cale> Er, twoNorm :: Fractional a => [a] -> a, I'd think
14:00:58 <glguy> unit x = map (/ sum [ a * a | a <- x] ) x   look right?
14:01:03 <genneth> ski: i think it has to be broader than even that, since the two norm needs a sqrt
14:01:17 <glguy> bah, true
14:01:19 <ValarQ> malcolm: ok, but i still don't see how i should do lookups in my StringMap from my "Gen" environment
14:01:23 <glguy> getting ahead of myself
14:01:34 <Cale> yeah, in facto
14:01:38 <Cale> fact*
14:01:41 <Cale> Floating
14:01:56 <genneth> ValarQ: make a pure lookup thing, and liftM it into the monad when you use it?
14:02:09 <Philippa_> genneth: some compscis have an interest in physics simulation
14:02:26 <Cale> class  (Fractional a) => Floating a  where
14:02:26 <Cale>     pi                  :: a
14:02:26 <Cale>     exp, log, sqrt      :: a -> a
14:02:28 <Cale> ...
14:02:51 <malcolm> ValarQ: result = do { x <- generate p1; return (Map.lookup m x) }
14:02:59 <Cale> actually, the line after that is relevant too :)
14:03:00 <glguy> I would guess the following then, however I get new type errors: unit x = map (/ sqrt sum [ a * a | a <- x] ) x
14:03:03 <Cale>     (**), logBase       :: a -> a -> a
14:03:05 <genneth> Philippa_: i'm a physicist who thinks that the universe is just a computer anyway...
14:04:06 <genneth> glguy: i think you need some parentheses
14:04:07 <int-e> a nice diagram of the standard type classes can be found at http://www.haskell.org/onlinereport/basic.html#sect6.3
14:04:30 <glguy> I've been exploring functional languages, haskell seemed intriguing
14:04:43 <ValarQ> genneth: i'll try to implementent/experiment with that
14:04:46 <Cale> glguy: might need some more parens around the sum...
14:04:49 <genneth> glguy: sqrt $ sum [a * a | a <- x ]
14:05:02 <ValarQ> thanks for your help genneth and malcolm, i
14:05:12 <int-e> and somewhere below that diagram there's a table that summarizes the various Num classes and their operations.
14:05:33 <genneth> ValarQ: no probs; one more haskeller is one more step to world domination
14:05:34 <glguy> More importantly, what would the best way to have written such a function in Haskell
14:05:41 <ValarQ> i'll be back when i have tested it :)
14:05:51 <genneth> glguy: it depends on what you mean by "best"
14:06:02 <Cale> unit x = map (/ norm x) x
14:06:02 <Cale>     where norm x = sqrt $ sum [ a * a | a <- x]
14:06:03 <ValarQ> genneth: yeah, you've won me :)
14:06:04 <glguy> genneth: I mean in the spirit of typical haskell style
14:06:09 <Cale> that's a little cleaner
14:06:17 <Philippa_> there're several "typical" haskell styles
14:06:24 <Philippa_> some people have a thing for pointless style, for example
14:06:35 <Cale> in fact, norm is sufficiently useful, that I'd lift it to the top level here
14:06:50 <Cale> (most likely)
14:07:31 <glguy> fair enough
14:08:33 <ski> (hm, s/twoNorm/twoNormalize/)
14:09:11 <Cale> @pl \x -> map (/ sqrt (sum $ map (^2) x)) x
14:09:12 <lambdabot> map =<< flip (/) . sqrt . sum . map (^ 2)
14:09:15 <Cale> heh
14:09:34 <Cale> you could do that if you want to turn it into point-free gibberish :)
14:10:40 <genneth> where the hell did that =<< come from?
14:11:10 <ValarQ> genneth: i'm innocent!
14:11:24 <Cale> It seems that @pl likes to abuse the "functions from a particular type" monad
14:12:28 <sethk> what's the difference between @eval and @pl?
14:12:37 <int-e> @pl is pointless
14:12:38 <lambdabot> is pointless
14:13:05 <integral> @pl \pl -> pl is pointless
14:13:06 <lambdabot> flip ($ is) pointless
14:13:11 <Cale> in the sense that it converts functions so that they don't mention the value (or point) to which they are being applied
14:13:19 <glguy> But to respond to the compsci using haskell, in the higher level cs classes, its about the math, and not programming, and the prospect of using haskell to perform some of the math seemed highly appealing from what I've read
14:13:38 <genneth> @pl \x -> (x (x x)) x (x x)
14:13:39 <lambdabot> join (ap id (join id)) `ap` join id
14:14:01 <glguy> Am I to infer that f $ g x means f ( g x ) ?
14:14:04 <Cale> The @eval command just evaluates a haskell expression
14:14:10 <Cale> yeah
14:14:18 <Cale> f $ x = f x
14:14:21 <int-e> @index ($)
14:14:21 <lambdabot> Prelude
14:14:31 <Cale> but $ has low precedence
14:14:43 <int-e> and is right associative
14:16:28 <genneth> glguy: we don't like () enough to use them all the time
14:18:18 <genneth> i swear that i didn't understand haskell for about 2 years; then one day monads made sense; then there was calm
14:19:17 <mflux> it may have been the same for me, otoh I had only read introductiorial material for two years ;) (and even then seldomly)
14:19:26 <Cale> genneth: Did "Monads as Containers" help at all?
14:19:27 <Cale> :)
14:19:35 <mflux> hmh, introductorial
14:19:50 <Philippa> understanding monads came to me somewhat gradually, although I /really/ got it when I did
14:20:06 <genneth> Cale: unfortunately saw that after i got the hang of them; but found it to resonate a lot with my understanding
14:20:31 <genneth> i think the problem is that there's so little to grasp
14:20:35 <araujo> @index chdir
14:20:36 <lambdabot> bzzt
14:20:42 <Cale> I didn't really understand monads until I realised that they were like containers.
14:20:53 <genneth> it's just an algebraic structure, that actually does nothing on its own
14:21:04 <Cale> at which point everything made sense :)
14:21:10 <genneth> :-p
14:21:21 <genneth> there is something zen like in comprehending them
14:21:28 * araujo sees monads like a data structure of computations
14:21:40 <int-e> genneth: hmm, that sounds familiar. you need additional operations associated to the monad to do anything useful with it.
14:21:44 <sethk> Cale, the problem is that there is at least one monad where each monad "think of it as" fails.
14:21:53 <sethk> Cale, for example, the maybe monad doesn't really contain anything
14:21:58 <Cale> yes it does
14:21:58 <araujo> Though i admit i don't perfectly understand them
14:22:07 <Cale> the Maybe monad is the perfect example of that
14:22:08 <sethk> Cale, what?
14:22:18 <Philippa> AFAIK my "think of it as" is pretty much the most basic CS/Haskell-centric one possible
14:22:21 <sethk> Cale, it doesn't, it just does something predefined with one value
14:22:25 <Cale> It's a container type that either simply holds one value, or none
14:22:27 <genneth> i saw this description for category theory that said that it's the embodiment of everything that was unessential to a situation
14:22:30 <sethk> Cale, it never "contains" nothing or just
14:22:32 <Philippa> but that's because I pretty much read off the category theory
14:22:39 <sethk> Cale, no, it has a preprogrammed output to maybe
14:22:45 <Cale> sethk: hm?
14:22:46 <sethk> Cale, that is to Nothing, sorry
14:22:53 <Cale> It's like a box which may be empty
14:23:05 <Cale> A value of type (Maybe a) is.
14:23:10 <genneth> sethk: i would have said that the maybe monad is the most container like
14:23:10 <sethk> Cale, it has an associated function that takes an argument, Maybe a, and does something predefined with Nothing
14:23:18 <sethk> genneth, it doesn't contain anything
14:23:32 <Cale> yes it does!
14:23:33 <integral> it contains that value
14:23:42 <sethk> it simply has an associated function that returns Nothing if the input is Nothing
14:23:51 <Cale> a value of type (Maybe a) is a container that may or may not contain an a
14:23:58 <sethk> Cale, I didn't say it wasn't
14:24:07 <Cale> that's the "containing" view
14:24:10 <sethk> Cale, I said the maybe _monad_ does not contain a Maybe
14:24:14 <integral> sethk: careful when you say "no, " after someone says something
14:24:25 <genneth> i think sethk is pointing out that the interesting bit of maybe isn't the container bit
14:24:31 <Philippa> sethk: it's not supposed to. It /is/ a Maybe, which is a container of 0-1 values
14:24:31 <integral> sethk: the maybe monad *is* a maybe (plus some operators)
14:24:34 <Cale> sethk: when I say that monads are containers, I mean that monads are container types
14:24:54 <sethk> Cale, that's confusing because many other monads, such as State, _do_ contain a value
14:25:00 <Cale> the maybe monad is the type constructor together with the return and bind functions
14:25:07 <Cale> sethk: hm?
14:25:12 <Cale> the return value
14:25:18 <Philippa> I'm guessing in the identity monad case you'd count it as a 'degenerate' container of exactly one value?
14:25:25 <Cale> the rest is just part of the container
14:25:31 <Cale> like a label on the box
14:25:33 <sethk> Philippa, no, as not a container at all
14:25:42 <Cale> Philippa: yes
14:25:42 <Philippa> sethk: I wasn't asking you
14:25:50 <sethk> Philippa, so?
14:26:01 <Philippa> so you clearly don't understand the model I was asking about in the first place
14:26:12 <int-e> sethk: the state lies outside of Cale's container
14:26:14 <sethk> Philippa, nothing clearly about it
14:26:20 <sethk> int-e, ok...
14:26:30 <Philippa> Cale: a strictifying monad'd be a similarly 'degenerate' value with a big ! on the front of a box, I guess
14:26:40 <Cale> :)
14:26:49 <int-e> sethk: there's a 'magic' function to access the state and put it in the container though; that's getstate
14:27:08 <Philippa> 'k. Your model makes more sense to me now, I guess put that way it's not as insufficiently general as I used to think
14:27:18 <sethk> int-e, yes, indeed, my point is that it is a very different thing than a Maybe monad, and does in fact have an associate value that it contains
14:27:33 <Philippa> I still tend to think of the container as having something from a different semantic universe inside it, but hey
14:28:00 <Philippa> sethk: all of them contain (or, in the worst case, are) the basic return value though
14:28:02 <Cale> If you want, the state monad container is a little strange. Really, state monad values are like huge "arrays" of (value, newstate) pairs indexed by states
14:28:32 <int-e> oh no! that's yet another view of the beast.
14:28:33 <int-e> :)
14:28:41 <Philippa> yeah, I think that's where your model sort-of breaks down for me because I don't get to neatly abstract that out
14:28:55 <Cale> You could choose not to :)
14:29:12 <genneth> wait... doesn't this dual view of monads imply some morphism between functions and containers?
14:29:16 <Philippa> yeah, but the "arrays" aren't as conceptually useful as "it wants to be fed an initial state"
14:29:17 <Cale> The view that it's a black box that we're not quite sure what's in it is okay too
14:29:18 <int-e> Cale: that's the parallel universe version ;)
14:29:25 <Philippa> I tend to think of the runFoo functions as being rather important
14:29:50 <Philippa> insofar as in the general case you need those to extract things back into this universe
14:29:53 <Cale> well, that runFoo function is a box of sorts :)
14:30:15 <Cale> just, rather "large" internally :)
14:31:13 <Philippa> runFoo's more of a destructor/deconstructor
14:31:17 <Cale> The container model is useful, because it's really easy to come up with ways to make types into monads using it.
14:31:21 <Philippa> I mean yeah, /everything/ with a name is a box of sorts...
14:31:25 <ski> (for comonads you have makeFoo functions corresponding to the monad runFoo ones)
14:31:55 <Cale> for comonads, it seems that "concatMap" becomes "scanl1"
14:31:57 <Philippa> ski: that mildly does my head in because I keep wanting to call it return, I keep wondering whether I'm thinking right or completely backwards for doing anything useful...
14:32:06 * ski just thought he should confuse things some ..
14:32:14 <Philippa> I need to hack up a signal function comonad for myself
14:33:20 <ski> Cale : scanl1 ?
14:33:24 <Cale> yep
14:33:25 <ski> @type scanl1
14:33:26 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
14:33:42 <ski> in what sense ?
14:33:54 <genneth> on a side note, what does List correspond to in the CH isomorphism?
14:34:05 <Cale> @eval scanl1 (+) [1,2,3,4,5]
14:34:05 <ski> CH ?
14:34:07 <lambdabot> [1,3,6,10,15]
14:34:12 <genneth> ski: Curry-Howard
14:35:15 <ValarQ> genneth: hello again :)
14:35:18 <jyp> @seen dcoutts
14:35:18 <lambdabot> dcoutts is in #haskell-blah, #haskell and #gentoo-haskell. Last
14:35:18 <lambdabot> spoke 4 hours, 13 minutes and 6 seconds ago.
14:35:22 <ski> genneth : a formula  List A, such that this is iso to  True or (A and (List A))
14:35:36 <ValarQ> can i convert my (Gen String,Gen String) to a Gen (String,String) ?
14:36:03 <integral> does CH just mean building the type up out of + and * ?
14:36:03 <Philippa> ski: a list of things that're taken to be true, then?
14:36:12 <ski> @type \(ma,mb) -> ma >>= \a -> mb >>= \b -> return (a,b)
14:36:13 <genneth> ski: thanks... i now need the rest of the evening to digest that :-P
14:36:13 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (m a, m a1) -> m (a, a1)
14:36:55 <integral> ValarQ: \(ma,mb) -> do { a <- ma; b <- mb; return (a,b) }
14:37:05 <genneth> integral: beat me to it
14:37:05 <ski> genneth : prolly, just for asking about truth of things, the List A construction isn't terribly interesting ..
14:37:16 <genneth> ski: clearly
14:38:03 <ValarQ> integral: thanks
14:38:26 <ski> Cale : i'm sorry i fail to see how this would be related to "concatMap for comonads" ..
14:38:35 <genneth> integral: http://en.wikipedia.org/wiki/Curry-Howard_isomorphism
14:38:46 <integral> ah, thanks :-)
14:38:48 <Cale> okay, one minute while I reconstruct the witness to this :)
14:38:57 <jyp> @type liftM2 (,)
14:38:58 <lambdabot> bzzt
14:39:03 <Cale> the idea being that >>= for monads is like concatMap
14:39:26 <Cale> whereas =>> is a bit like scanl1 (with an improved type)
14:39:44 <ski> @type Control.Monad.liftM2 (,)
14:39:45 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
14:40:03 <ski> @type uncurry (Control.Monad.liftM2 (,))
14:40:04 <lambdabot> forall (m :: * -> *) a1 a2. (Monad m) => (m a1, m a2) -> m (a1, a2)
14:40:20 <ski> @pl \(ma,mb) -> ma >>= \a -> mb >>= \b -> return (a,b)
14:40:21 <lambdabot> uncurry (liftM2 (,))
14:40:39 <ski> Cale : hm, let me think about that ..
14:40:50 <ski> which comonad are you thinking of ?  Stream ?
14:41:00 <Cale> yeah
14:41:07 <Cale> or nonempty lists
14:41:24 <ski> hm
14:41:40 <ski> (hadn't considered that)
14:41:53 <Cale> I'm actually having trouble reconstructing the example in my current state though :)
14:41:58 <ski> (=>>) :: Stream a -> (Stream a -> b) -> Stream b
14:42:16 <ski> as =>> asb = fmap asb (tails as)
14:42:52 <Cale> I suppose with stream, you get the future as input
14:43:24 <ski> yes .. anti-causal signal comonad
14:45:28 <Cale> ah, there it is
14:45:42 <Cale> I suppose it's not quite the same, but here's an example :)
14:45:53 <Cale> vsum (V x) = x; vsum (xs :> x) = x + vsum xs
14:46:05 <Cale> *Main> (V 1 :> 2 :> 3 :> 4 :> 5) =>> vsum
14:46:05 <Cale> (((V 1 :> 3) :> 6) :> 10) :> 15
14:46:19 <ski> fnord123 : '=>' is used for type class constraints in type signatures
14:46:58 <ski> hm
14:47:04 <Cale> so, really, it's kind of cheating, because it's rebuilding the sum each time
14:47:29 <Cale> so perhaps that isn't the best characterization of it :)
14:47:33 <ski> hm .. you sum from in to out ..
14:47:57 <ski> ah, of course ..
14:48:35 <Cale> you're summing up the entire past and present
14:48:48 <ski> possibly one could use comonad laws to rewrite into a more efficient version, using sharing
14:50:59 <Cale> @eval map sum (init (tails [5,4,3,2,1]))
14:51:00 <lambdabot> [15,10,6,3,1]
14:52:00 <Cale> it's really something like that
14:53:07 <ski> m ,yes
14:53:22 <genneth> right; night all
14:53:26 <Cale> night
14:54:21 <Cale> It's more general than a scanl-type thing because you get to look at only part of the past if you want
14:54:52 <Cale> @eval map (\xs -> sum $ take 3 xs) (init (tails [5,4,3,2,1]))
14:54:53 <lambdabot> [12,9,6,3,1]
14:57:08 <Cale> *Main List> (V 1 :> 2 :> 3 :> 4 :> 5) =>> (vsum . vtake 3)
14:57:08 <Cale> (((V 1 :> 3) :> 6) :> 9) :> 12
14:58:38 <Cale> I think the stream view is actually fairly natural. You can always convert a thing of comonadic type into a stream, in a natural way, but you might lose lots of information.
14:59:20 <ski> hm
14:59:43 <Cale> actually, hmm...
14:59:46 <Cale> is that true?
14:59:49 <ski> state-in-context ?
15:00:56 <ski> (btw, i think state-in-context possibly could have some similarities with continuation monad ..)
15:01:17 <ski> data StateInContext s a = SIC s (s -> a)
15:01:24 <Cale> ah, no, you can't because there's no complement to extract
15:01:40 <ski> (complement ?)
15:01:44 <Cale> You need an additional  w a -> w a
15:01:52 <Cale> which is like tail
15:01:54 <ski> m-hm
15:01:57 <Cale> instead of head :)
15:02:13 <Cale> and while that *sort of* is in there
15:02:14 <ski> with environment-comonad wou have local ..
15:02:21 <Cale> via split
15:02:35 <Cale> you don't naturally have a way to access it
15:03:18 <ski> (btw, hm, actually, it's interesting that Stream is both a comonad and a monad)
15:04:17 <ski> (i the latest uustalu&varmo paper, they use return in their comonadic interpreter .. to give initial environment wrapped in a comonad)
15:04:27 <ski> (s/i/in/)
15:08:03 * ski 's pondering when we could optimise (=>>) for Stream ..
15:08:56 <Cale> I think it might be interesting to have a comonadic structure with an additional natural transformation w a -> w a
15:09:13 <ski> any laws ?
15:09:18 <Cale> I'm not sure it would have to satisfy any laws
15:09:25 <ski> heh
15:09:31 <Cale> all of them would be moderately interesting
15:10:05 <Cale> The fact that it's a natural transformation is already a bunch of properties :)
15:10:21 <Cale> The idea is that you can apply it to the structure and then extract
15:10:32 <ski> m, yes
15:10:46 <ski> hm, is infinite binary trees a comonad ?
15:11:05 <Cale> hmm... probably
15:11:15 <Cale> let me think about that one for a sec :)
15:11:23 <ski> (hm ...   as =>> foldS f  =  ???)
15:12:05 <ski> t@(Node a l r) =>> wab = Node (wab t) (l =>> wab) (r =>> wab)
15:12:07 <ski> prolly
15:12:34 <ski> (laws need to hold, also, of couse)
15:12:35 <Cale> cocausality is awesome :)
15:12:41 <ski> ?
15:12:53 <Cale> (or anticausality)
15:13:05 <ski> (for some reason this reminds of a tree of oracles)
15:13:12 <Cale> Well, what is it doing structurally?
15:13:23 <Cale> extract is easy -- take the value at the root
15:13:46 <ski> applying wab to every "tail/future" (every point having two direct futures)
15:13:53 <Cale> for split, perhaps produce at each node, the tree of subtrees of that node
15:14:06 <Cale> hmm... what do I mean by that :)
15:14:10 <ski> yes, seems reasonable
15:14:25 <Cale> ah, yeah
15:14:37 <ski> in fact, i think that implies that (=>>) def .. or vice versa if you like :)
15:14:40 <Cale> where the edges are choices of subtree at each step
15:14:48 <Cale> yeah
15:15:04 <ski> wa =>> wab = fmap wab (split wa)
15:15:05 <Cale> x =>> f = fmap f (split x)
15:15:17 <Cale> split x = x =>> id
15:15:22 <ski> right
15:15:26 <Cale> I wrote my comonad class the right way :)
15:15:36 <Cale> so I get to choose which :)
15:15:44 * ski did, too
15:16:44 * ski wants to use message-dispatching syntax with Stream, though
15:16:55 <Cale> Finite nonempty binary trees will work too
15:17:40 <Cale> Bimonads are interesting, if that's what you'd call them
15:17:58 <ski> hm .. data Tree a = Nil | Node a (Tree a) (Tree a); data NonEmptyTree a = TopNode a (Tree a) (Tree a) ?
15:18:03 <Cale> I suppose they're at their best when they come from an adjunction
15:18:11 <Cale> yeah
15:18:30 <ski> or .. data NonEmptyTree a = Leaf a | Node a (NonEmptyTree a) (NonEmptyTree a)  ?
15:18:46 <Cale> er
15:18:50 <Cale> yeah, that's better
15:18:56 <Cale> you want to be able to stop :)
15:18:59 <ski> hm, are those iso ?
15:19:03 <Cale> no
15:19:12 <Cale> data NonEmptyTree a = TopNode a (Tree a) (Tree a) -- these are all infinite
15:19:14 <ValarQ> how can i convert my 'Gen (a,a)' to '(Gen a,Gen a)' ?
15:19:42 <ski> Cale : data Tree a = Nil | ...
15:20:03 <ski> ValarQ : no
15:20:05 <sethk> is the purpose of System.Posix.IO just to provide IO with posix semantics?  Or are there reasons to use Posix.IO instead of IO, or v.v.?
15:20:15 <ski> ValarQ : other direction works fine, though
15:20:32 <Cale> sethk: Posix.IO has extra stuff in it :)
15:20:41 <sethk> Cale, yes, and a couple of things missing, also
15:20:49 <Cale> but it's stuff which will only work on Posix systems
15:20:52 <Igloo> The Posix is less portable
15:20:59 <Igloo> Notably mostly absent on Windows
15:21:04 <sethk> Igloo, oh, ok.
15:21:07 <ValarQ> ski: ok
15:21:15 <sethk> I was thinking more portable, but I wasn't thinking about windows  :)
15:22:11 <Cale> ski: I suppose that a comonad with a particular n.t. w a -> w a is like a comonad with a path in it.
15:22:15 * ski wonders what reasonable extra laws bimonads should satisfy
15:22:32 <ski> n.t. ?
15:22:39 <Cale> natural transformation
15:22:44 <ski> k
15:22:46 <Cale> join . split = id ?
15:23:07 <Cale> and for that matter,
15:23:18 <ski> hm .. i thought about that for Stream some while ago ..
15:23:26 <Cale> extract . return = id
15:23:37 <Cale> that one definitely
15:23:47 <ski> hm, no, i think join . split = id doesn't hold for Stream
15:24:04 <ski> split = tails
15:24:21 <ski> join = diagonal
15:24:25 <Cale> if join is to map to the first element, that's good
15:24:26 <Cale> ah
15:24:43 <ski> it has to be, to satisfy monad laws, iirc
15:24:49 <Cale> really?
15:24:53 <Cale> hmm...
15:25:26 <ski> i don't remember exactly, but i seem to recall thinking that anyway .. hm
15:25:26 <Cale> I thought I determined at one point that there were at least uncountably many definitions of monad for Stream :)
15:25:42 <ski> lemme think some
15:25:53 <ski> ah
15:25:55 <ski> now i remember
15:26:15 <ski> no, i think i didn't determine it necessarily uniquely
15:26:37 <ski> what i did was to notice that  Stream ~= (Nat ->)  and simsalabim
15:26:54 <ski> (that was how i noticed it being a monad in the first case)
15:28:01 <ski> so for the comonad, we use the monoid structure on Nat, while for the monad we use the comonoid structure on Nat
15:29:49 <ski> (Cale : ok ?)
15:30:18 <ski> hiya JoslGr0s
15:34:52 <Cale> ski: hmm
15:36:59 <dons> moin
15:37:04 <dons> @seen SyntaxNinja
15:37:05 <lambdabot> I saw SyntaxNinja leaving #haskell 4 hours, 1 minute and 52 seconds
15:37:05 <lambdabot> ago.
15:40:36 <syntaxfree> @seen eieiei
15:40:37 <lambdabot> eieiei has changed nick to syntaxfree.
15:40:37 <lambdabot> You are in #haskell. Last spoke just now.
15:40:46 <syntaxfree> hey. smart bot!
15:41:21 <ski> (Cale : the comonoid just being 'of course', i.e. counit n = (); comult n = (n,n))
15:41:57 * syntaxfree really envies those who understand category theory.
15:42:24 * dons really categorises those who understand envy theory
15:42:28 <Cale> um
15:42:33 * shapr cackles happily
15:42:38 <Cale> I'm not sure what your notation means there
15:42:42 * syntaxfree really theorizes those who envy category understanding.
15:43:07 <dons> shapr, did you see SyntaxNinja's pics?
15:43:26 <ski> Cale : which ?
15:43:30 <dons> ndm, nibro, me: http://www.syntaxpolice.org/pics/estoniaBerlin/Estonia/13.html
15:43:35 <Cale> counit n = ()
15:43:38 <shapr> nah, where?
15:43:38 <ski> oh
15:43:48 <dons> JaffaCake, Igloo, David Roundy: http://www.syntaxpolice.org/pics/estoniaBerlin/Estonia/10.html
15:43:48 <shapr> oooh
15:43:55 <ski> (that's just the comonoid structure ..)
15:43:56 <Cale> how does that describe a natural transformation?
15:43:59 <dons> autrijus: http://www.syntaxpolice.org/pics/estoniaBerlin/Estonia/14.html
15:44:02 <Cale> T -> 1
15:44:09 <ski> yes
15:44:13 <ski> um
15:44:16 <ski> Nat -> 1
15:44:25 <Cale> that is, from the functor T to the identity functor
15:44:41 <Cale> (not to the unit type)
15:45:04 <ski> ah, .. you think i mean the comonad by counit ..
15:45:46 <shapr> What's that with Heffalump in #11?
15:45:51 <ski> i meant the comonoid over Nat .. inducing (Nat ->) to be a monad  (i.e. environment monad)
15:45:53 <shapr> er "Who"
15:46:28 <dons> oh, um, memory fails..
15:46:42 <shapr> Who's wearing the C&C t-shirt in #12?
15:47:05 <Igloo> Is it Nils?
15:47:55 <dons> in #12, that's Tom Moertel
15:48:14 <ski> Cale : possibly we should continue some other time when we're more awake ..
15:48:19 <Cale> yeah
15:48:31 <Cale> I've had 2 hours sleep in the last 2 days :)
15:48:35 <ski> hehe
15:48:40 <ValarQ> Cale: same here
15:48:45 <Igloo> Oh, no
15:48:51 <Cale> This is totally voluntary
15:48:55 <Cale> :)
15:48:59 * shapr volunteers
15:49:00 <ValarQ> since shapr mentioned that QuickCheck thingie i can't think of anything else :(
15:49:15 <shapr> ValarQ: I could mention something new :-)
15:49:26 <ValarQ> must get this to work, must get this to work, must get this to work...
15:49:42 <Cale> ValarQ: what are you doing?
15:49:42 * ski also got linear logic 'par' on brain trying to infiltrate my thoughts on everything ..
15:49:45 <ValarQ> shapr: you'll kill me
15:50:24 <ValarQ> Cale: shapr thought i passed around randomgenerators to much and told me to go for the Gen monad in the QuickCheck module
15:50:25 <Cale> ValarQ: Use the simplicial category!
15:50:32 <shapr> I tend to have several avenues of research going at once. Or as someone else put it, "do you ever finish anything?"
15:50:40 <Cale> (heh, just mentioning something else at random)
15:50:53 <shapr> I wouldn't say you did it too much, just that there's a possible avenue of improvement.
15:50:58 <shapr> Running code is good code.
15:51:51 <Cale> ValarQ: what's the problem?
15:52:00 <ski> typechecks goo-oo-ood, type error baa-aa-aad
15:52:06 <ski> (sorry)
15:52:06 <Cale> I'm unfamiliar with Gen, but I wrote my own simplistic monad for that
15:52:18 * ski goes to sleep .. night #haskell
15:52:23 <Cale> night
15:52:51 <ValarQ> Cale: my mind is the biggest problem
15:53:01 <ValarQ> Cale: i didn't know haskell when i was born
15:53:09 <Cale> heh
15:53:18 <Cale> ValarQ: You're new around here aren't you?
15:53:24 <ValarQ> Cale: yeah :)
15:53:49 <ValarQ> Cale: my problem now is that i found out that  length (x::Gen [String])  doesn't work
15:53:56 <ValarQ> (obviously)
15:54:09 <Cale> run the generator
15:54:22 <Cale> y <- x
15:54:28 <Cale> let len = length y
15:55:01 <ValarQ> i think i know how to handle it, just one night more...
15:55:09 * shapr grins
15:55:49 <ValarQ> btw, why do i get the feeling that i got the lowest grade of education here?
15:56:05 <dons> ValarQ!
15:56:13 <ValarQ> hello mr Dons
15:56:21 <dons> you in .se?
15:56:25 <ValarQ> dons: yes
15:56:47 * dons thinks he should plot a map of universities which teach haskell, and those that have haskell research groups
15:57:02 <dons> are you at Chalmers, btw?
15:57:06 <shapr> Oh, good idea
15:57:07 <ValarQ> me?
15:57:18 <dons> yes, ValarQ?
15:57:38 <shapr> ValarQ: If you mean formal CS education, I don't have any. Well, I had cs101 in 1992. We had IBM XTs with monochrome (green) monitors.
15:57:48 <dons> ValarQ: or did you pick up haskell on your own?
15:58:21 <shapr> Haskell is a wonderful mindtoy.
15:58:22 <ValarQ> shapr: i have only read (what do you call it in english?) "gymnasieniv"
15:58:45 <ValarQ> dons: no, you guys have helped me :)
15:58:55 * dons is interested in mapping the extent of the haskell community
15:59:34 <ValarQ> the only education i got is as an electrician
15:59:55 <shapr> The nearest swede says that's like high school.
15:59:56 <dons> cool!
16:00:02 <dons> @karma+ ValarQ
16:00:02 <lambdabot> ValarQ's karma raised to 1.
16:00:14 <ValarQ> yay, i got some karma :)
16:00:31 <ValarQ> i got some military education thought
16:00:44 <dons> in haskell? ;)
16:00:47 <shapr> I did have ... six? years of college. But I kept taking art class, poetry class, french, literature, archeology, whatever was fun.
16:00:49 <ValarQ> i used to work as a sergeant in the swedish royal navy
16:00:59 <dons> or is haskell only used for peaceful purposes, I wonder?
16:01:01 <ValarQ> dons: no, no haskell
16:01:15 <Cale> launchMissiles :: IO ()
16:01:20 * shapr scripts a water balloon launch with haskell
16:01:30 <dons> oh, no, galois probably has written haskell for some non-civilian uses, certainly
16:01:42 * shapr fires an intercontinental ballistic water balloon at dons!
16:01:47 <ValarQ> dons: i only use awk i war situations
16:01:54 <dons> argh!
16:02:14 <ValarQ> (thats actually completely true)
16:02:21 <shapr> ValarQ: Which comvux are you at again?
16:02:34 <ValarQ> shapr: Axel Wedel
16:02:53 <ValarQ> shapr: 200m from Kalmar castle :)
16:04:04 <shapr> neat
16:04:44 <shapr> oooh aaah - http://www.kalmar.se/templates/Page.aspx?id=3263
16:04:58 <ValarQ> hmm, i tried to learn emacs at the same time as haskell, didn't work out thougt, i'm right back to vi again...
16:05:20 <ValarQ> shapr: :)
16:05:32 <shapr> I can probably help you with emacs.
16:05:36 <Cale> I use emacs and vi about half and half.
16:05:51 <ValarQ> the problem is that i have used vi for very long
16:05:51 <shapr> I used vi for editing files as root, since tramp sucks too much.
16:06:15 <shapr> You've used C for very long too, right? :-)
16:06:23 <ValarQ> i was thinking about switching to emacs for heavier programming
16:06:29 <shapr> emacs has its good points.
16:06:30 <cjb> I hate that tramp doesn't cache its stupid "detect every possible environment on the planet, badly" visit, but don't hate anything else about it.  What stops you using it?  :)
16:06:32 <ValarQ> shapr: yes, very long :)
16:06:38 <Cale> ValarQ: me too, and it was rough learning emacs at first, but it only takes about a week or so of forcing yourself to use it, and you'll get used to it
16:06:46 <ValarQ> shapr: started coding in python for less than a year
16:07:22 <ValarQ> Cale: yeah, i guess so
16:07:54 <shapr> cjb: It requires that the remote system uses a set prompt, so won't fit with my custom zsh setup. It has to refresh every five seconds and locks the rest of emacs if the remote ftp site goes down. The multihop syntax changes every few months. It has a race condition when used together with gnus, two erc connections, ghci, and some other subprocesses.
16:08:12 <shapr> I could probalby come up with several pragraphs of whining about tramp.
16:08:42 * cjb has a custom zsh setup, and it seems to work.  :)
16:08:55 <cjb> What's special about your prompt?  Mine's moderately wacky.
16:09:02 <ValarQ> well? was i right about me having the lowest grade of education?
16:09:06 <shapr> I think I'm using clint
16:09:12 <cjb> I also use gnus and erc.  :)
16:09:52 <shapr> ValarQ: No, We have some fifteen year olds here.
16:10:10 <shapr> Though I think Mikael is sixteen now.
16:11:18 <ValarQ> shapr: ok, thats sounds promising
16:12:39 * dons >>= off to the cricket! :)
17:14:50 <JKnecht> still trying to digest that; productive development users of Haskell under 17 ... doesn't sound like it'll hold much water but prolly should be supported in principle.
17:20:07 <JKnecht> like squeakland playing like kids could use Squeak like it was Logo (not that they explicitly do so). Actually think it would sortof work there.
17:21:41 <Maddas> Why shouldn't it work with Haskell?
17:24:05 <JKnecht> yeah, it's all about the qualifications on 'use' and 'understanding'. In my brief exposure to Haskell in depth (before today I had thought it a pure research tool) it seems to make some serious demands on the sophistication of the programming user.
17:25:19 <Maddas> So you think people under 17 are not smart enough yet? :-)
17:25:20 <Cale> It's not so much that it makes those demands, it's just that room is available to be sophisticated.
17:25:59 <syntaxfree> Haskell is not hard if you haven't been exposed to traditional programming concepts yet.
17:26:07 <syntaxfree> Or if you have been started in programming with Scheme.
17:26:17 <JKnecht> Yeah there's a general phenomemon where novices programmers do better with non-von neumann models than those with experience with standard imperative languages ....
17:26:43 <syntaxfree> it actually looks like mathematics.
17:26:49 <JKnecht> sometimes.
17:27:06 <Cale> You largely think about it in similar ways to mathematics
17:27:22 <syntaxfree> I mean, the syntax to get basic things done.
17:27:51 <Cale> you can make substitutions
17:28:05 <syntaxfree> the thing about Haskell is that strict typing leads to discouraging show-stoppers.
17:28:17 <JKnecht> Right. I guess I'm prejudiced in my perspective as a developer looking at this for serious use.
17:28:33 <Cale> syntaxfree: It's better that they show up at compile time than runtime
17:28:47 <syntaxfree> Cale: maybe. It does put off the beginner, though.
17:30:00 <syntaxfree> Scheme is very enjoyable for beginners. Trouble is, it's almost impossible to read code later.
17:30:06 <Cale> Perhaps. Personally, I'd rather get an error message that pointed me at a specific place in my code to check for errors when I compile the thing, rather than fiddling around with a debugger
17:30:34 <JKnecht> Also, there is that certain something one finds in say Smalltalk or Prolog which make them I think easier to learn. Something like conceptual unity or tightness in the model of computation as practically implemented.
17:30:39 <syntaxfree> Maybe it's just because all my code is numerical and I end up using (Floating a)=>etc etc. for everything.
17:31:02 <syntaxfree> the easiest language to learn is Scheme.
17:31:05 <syntaxfree> syntax ends in two lessons.
17:31:11 <Cale> syntaxfree: if the type signatures get in your way, leave them off
17:31:12 <syntaxfree> two more for recursion.
17:31:18 <JKnecht> which in my grand total of a few hours looking at it I don't see in Haskell.
17:31:30 <syntaxfree> and two more for recursion patterns.
17:32:09 <Maddas> JKnecht: I dispute the idea that people under 17 can't use Haskell to implement (useful) things.
17:32:11 <syntaxfree> iin his Metamagical Themas column, Douglas Hofstadter gets away with teaching to solve complicated fractal and metaprogramming problems with Lisp in three magazine-sized columns.
17:32:20 <JKnecht> I never said that.
17:32:20 <sethk> JKnecht, it is somewhat less intuitive, I agree.  However you can't judge it's utility without understanding its perspective
17:32:36 <Maddas> JKnecht: Ok, I misunderstood then :-)
17:33:10 <syntaxfree> I find the Gentle Introduction so proeminently displayed at haskell.org vastly inferior to Hal Daume's htut as a beginner reference.
17:33:40 <syntaxfree> in any case, this is the right time to gather support for my new pet project:
17:33:42 <Cale> Hal Daume's "Yet Another Haskell Tutorial"
17:33:44 <JKnecht> I do understand it's perspective, I think. I prefer the '98 spec.
17:33:49 <syntaxfree> @hawiki MyFirstFiveMinutes
17:33:50 <lambdabot> http://www.haskell.org/hawiki/MyFirstFiveMinutes
17:33:57 <syntaxfree> Cale: precisely.
17:34:12 <syntaxfree> oops. wait a minute.
17:34:37 <syntaxfree> jeez. My wiki page disappeared.
17:34:43 <sethk> JKnecht, you have to program in it for a while before you can judge whether you just need to think a bit differently, or it in fact is missing something
17:35:36 <syntaxfree> JKnecht: ever programmed in Scheme?
17:35:46 <JKnecht> now I'm already sold. I made the decision in the first few hours of looking at the current state of things since the '98 report.
17:35:54 <JKnecht> s/now/no/
17:36:31 <Cale> JKnecht: sold on what, exactly?
17:36:34 <JKnecht> no but I've used Smalltalk, Lisp, and Prolog for more than 20 years.
17:37:01 <syntaxfree> well, Scheme is a clean Lisp.
17:37:44 <JKnecht> Haskell as a vehicle to address problems of 'programming in the large', if you will. An aspect Maybe of post-OO programming.
17:38:15 <syntaxfree> Some people say the functional paradigm is a poor man's version of the OO way. And some say the opposite.
17:38:30 <syntaxfree> I'm way more comfortable with the idea of higher-order functions than with objects, classes and inheritance.
17:39:02 <syntaxfree> too much linear algebra, I guess :(
17:39:06 <Cale> :)
17:39:22 <sethk> I don't know that the two perspectives are orthogonal
17:39:33 <Cale> I think that the two perspectives are dual.
17:40:05 <sethk> there is nothing in the OO paradigm, per se, that prohibits higher order functions
17:40:06 <Cale> In the sense that they're sort of the same thing with a bunch of the arrows pointing the other way.
17:40:15 <sethk> although you are less likely perhaps to think about using them.
17:40:58 <syntaxfree> I know some basic category theory.
17:41:04 <syntaxfree> emphasis on "some basic".
17:41:11 <Cale> In FP, data is hard to extend, but functional interfaces are easy to extend, which is sort of the opposite of OO.
17:41:12 <sethk> JKnecht, there is more overlap than I thought when I first started using haskell
17:41:19 <syntaxfree> I can't quite relate the ideas I learned to computer science in general and Haskell in particular.
17:42:12 <Cale> syntaxfree: In Haskell, we're mostly concerned with the category of Haskell types and Haskell-definable functions.
17:42:17 <JKnecht> I never live in language ghettos, so I can take Haskell for all it's strengths.
17:42:34 <sethk> JKnecht, sure, nobody ever said that other computer languages should never be used
17:42:35 <syntaxfree> where objects are haskell types and arrows are haskell functions?
17:42:45 <Cale> yes
17:42:52 <syntaxfree> hmm. not bad.
17:43:06 <syntaxfree> why do functors arise, then?
17:43:09 <Cale> An instance of the Functor class is actually an endofunctor on this category.
17:43:21 <JKnecht> In fact haskells FFI libs seem like an excellent platform for general integration.
17:43:26 <syntaxfree> I don't know what an endofunctor is. My category theory stops there.
17:43:37 <Cale> ah, just a functor from a category to itself
17:43:42 <syntaxfree> hmm. I see.
17:43:44 <sethk> sounds too much like an endodontist for my taste  :)
17:43:48 <syntaxfree> why are endofunctors interesting?
17:43:52 <Cale> The type constructor is the map on objects
17:44:00 <Cale> and fmap is the map on arrows
17:44:18 <syntaxfree> hmmm.
17:44:33 <Cale> For exactly the reason that you might use fmap in a program :)
17:44:48 <syntaxfree> I can't see an endofunctor different from id.
17:44:53 <Cale> []
17:45:09 <Cale> [] takes a type and gives the type of lists on that type
17:45:16 <syntaxfree> my category theory stopped at the chapter 4 of Michael Arbib's "Arrows, structures, functors -- the categorical imperative"
17:45:22 <syntaxfree> Ahhh.
17:45:31 <Cale> and think about what fmap does :)
17:45:37 <syntaxfree> I don't know what fmap does.
17:45:42 <Cale> fmap :: (a -> b) -> (f a -> f b)
17:45:46 <Cale> so in this case:
17:45:50 <syntaxfree> ummm.
17:45:54 <Cale> (a -> b) -> ([a] -> [b])
17:45:55 <syntaxfree> fmap is like "map" for functions.
17:45:59 <syntaxfree> wow.
17:46:03 <syntaxfree> that is .. powerful.
17:46:21 <Cale> (f is the functor there)
17:46:42 <Cale> Yeah, it's a nice abstraction
17:46:51 <syntaxfree> hmm.
17:47:16 <syntaxfree> can I declare a functor, that, says, will double the result of all functions?
17:47:28 <Cale> double?
17:47:54 <JKnecht> See that's what I mean. How many 17 year olds are gonna grok Category Theory, SFAICT an essential element of Haskell mastery.
17:47:59 <Cale> fmap is map, in the case of lists
17:48:01 <syntaxfree> yes. so  every function f will become (*2).f ?
17:48:02 <sethk> I'll see that and double again
17:48:14 <Cale> JKnecht: you don't need category theory to understand Haskell
17:48:20 <sethk> JKnecht, theory, yes.  but not necessary to effectively use it.
17:48:22 <Cale> It's just nice if you have it
17:48:24 <syntaxfree> Haskell mastery != writing productive code in Haskell.
17:48:36 <Cale> syntaxfree: no
17:48:49 <Cale> (to your question)
17:48:50 <Maddas> JKnecht: I don't know.
17:48:53 <JKnecht> right exactly my original point, that equivocations on 'use' are necessary for such claims.
17:49:27 <syntaxfree> anyone who can write Scheme and can grok the basics of the  type system can get away with solving problems in Haskell.
17:49:48 <Maddas> JKnecht: I bet you'll find 17-year olds understanding (at least basic) category theory if you look for them, though. I don't see why the age is a problem
17:49:49 <Cale> syntaxfree: think about the type of fmap some more
17:50:07 <Cale> it takes a function between any two types: (a -> b)
17:50:11 <sethk> age is only a problem for me, but I'm too old, not too young  :)
17:50:13 <JKnecht> OK, I'm gonna leave the Chinese Room for a few minutes and run to the convenience store.
17:50:18 <syntaxfree> and returns (f a -> f b)
17:50:21 <Cale> right
17:50:28 <syntaxfree> not (a -> f b).
17:50:29 <syntaxfree> true.
17:50:31 <Cale> so it's something purely structural
17:50:47 <Cale> f is some data constructor here, remember
17:50:56 <Cale> like [], or Tree, or Maybe
17:51:03 <Maddas> sethk: Right :-)
17:51:06 <Cale> (or IO)
17:51:17 <syntaxfree> Damn. I have to learn the basics of data constructors TODAY.
17:51:22 <Cale> er
17:51:27 <Cale> type constructor
17:51:33 <Cale> sorry, I'm a little sleepy :)
17:51:33 <syntaxfree> yes, yes. that.
17:52:09 <syntaxfree> please point me to some introduction specifically on type constructors? :~
17:52:09 <Cale> (been up 2 days with only 2 hours sleep in the afternoon)
17:52:22 <Cale> syntaxfree: YAHT covers them
17:52:36 <Cale> When you do data declarations
17:52:46 <syntaxfree> ah, yes, there.
17:52:52 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
17:52:56 <syntaxfree> yes, yes.
17:52:57 <Cale> Tree is a type constructor
17:53:00 <syntaxfree> I know what type constructors are.
17:53:05 <Cale> okay
17:53:06 <syntaxfree> I want to learn the theory.
17:53:26 <Cale> well, hmm :)
17:53:41 <sethk> syntaxfree, have you read the mark jones paper?
17:54:08 <syntaxfree> nope.
17:54:11 <syntaxfree> title/year? :~
17:54:22 <sethk> it's 95
17:54:34 <sethk> it's URL appears in the library docs.  hold on, I'll get it...
17:54:47 <syntaxfree> the title would help find it in jstor or scholar.google
17:54:56 <Cale> http://www.cse.ogi.edu/~mpj/pubs.html
17:55:21 <syntaxfree> there are a lot of Joneses in this game.
17:55:31 <sethk> what cale said.  :)
17:55:43 <syntaxfree> there's Simon, there's the functional dependencies guy, there's this Mike guy..
17:55:59 <sethk> the beginning of "functional programming with overloading and higher order polymorphism" is a nice description of the type system
17:56:13 <sethk> syntaxfree, well, you want everything, don't you.
17:56:42 <syntaxfree> I got the URL, thanks :)
18:01:11 <syntaxfree> I love how every reference to Miranda (TM), be it in the academia, in websites or late-night pub chatter, must mention Miranda (TM) is a trademark of Research Software Ltd.
18:01:37 <sethk> syntaxfree, my daugher has a friend named Miranda, and she never says that.
18:01:52 <Cale> I think she should start.
18:02:05 <sethk> Cale, I'll speak to her about it.  :)
18:02:06 <Cale> :)
18:02:27 <syntaxfree> she's talking about Miranda, not Miranda (TM), which is a trademark of Research Software Ltd.
18:02:56 <syntaxfree> Miranda was also a popular ICQ clone. That also wasn't Miranda (TM), which is a trademark of Research Software Ltd.
18:03:41 <sethk> syntaxfree, don't forget Carmen Miranda
18:05:09 <syntaxfree> I think I will refer to Miranda (TM) -- a trademark of Research Software Ltd. -- as "that old language" from now on.
18:07:59 <syntaxfree> Cale & sethk: that's a great, informative and accessible paper. Thank you.
18:08:19 <sethk> syntaxfree, np, I like that one.
18:09:20 <syntaxfree> yes. It's at the same time readable for newbs and quite informative. It's  nice to move onto from tutorials to more theoretical work without being overwhelmed by the prerequisites.
18:09:41 <Cale> btw, what it refers to as constructor classes are now also referred to as typeclasses
18:22:06 <Maddas> Wee, more papers. I wonder whether I will ever catch up with even a fraction of the papers I purport to read :-)
18:22:51 <Maddas> Thanks and good night, everybody.
18:23:07 <syntaxfree> if it makes you feel better, I'm trying to follow the literature in monetary policy, network extrernalities and rock studies as well.
18:23:30 <syntaxfree> I spend so much time looking at the LaTeX default font, I don't know why my handwriting hasn't gotten similar to it yet.
18:23:51 <Maddas> Heh.
18:24:29 <Maddas> It's not that I _couldn't_ read what I download (or at least a significant part of it), it's just that I don't get around to (even though I'd have the time)
18:24:43 <Maddas> Getting a working printer might help :-)
18:32:07 <JohnMeacham> cmr bestows respect onto any document.
18:33:06 <syntaxfree> yes, yes.
18:33:22 <syntaxfree> I write the most insignificant assignments in LaTeX for the effect.
19:31:51 <int80_h> wake up
19:32:04 <sethk> int80_h, don't do that, you startled me
19:32:11 <int80_h> my bad
19:32:26 <int80_h> but is anyone working on a MEWA framework for haskell?
19:32:36 <int80_h> I don't want to duplicate other's work.
19:32:52 <int80_h> and if someone is doing this, maybe I can joiun in
19:39:01 <int80_h> nothing to see here.
19:39:03 <Cale> MEWA?
19:40:27 <int80_h> meta-level Architecture for Generic Web-Application Construction
19:40:47 <int80_h> looks more fun than rails
19:41:20 <int80_h> someone is doing a LISP project
19:41:51 <sethk> Cale, you told me, or someone did, about a couple of web server projects
19:42:11 <int80_h> this would be put on tope of a web server
19:42:16 <JKnecht> looks like it's already done in Squeak.
19:42:26 <int80_h> I was poking around, found a haskell web server. looks good
19:42:34 <int80_h> yeah it was done in smalltalk first
19:42:46 <int80_h> but at the very least, it looks like a fun exercise
19:43:00 <sethk> int80_h, I know what it is, so were the projects I'm thinking about
19:43:11 <sethk> int80_h, even if they are different they might be a good source for you
19:43:31 <int80_h> :)
19:43:55 <int80_h> I've been finding some good books too. Got one on algorithms for functional languages.
19:44:06 <int80_h> which is exactly something I could use
19:45:48 <sethk> int80_h, the okasaki book?
19:46:06 <int80_h> don't think that's it. Let me google it
19:46:13 <sethk> doesn't matter, just curious
19:46:34 <int80_h> don't have it on me, but I don't think that is the author
19:47:14 <sethk> int80_h, only asked because that's the only one I have, so if there is another I don't have it. :)
19:48:00 <int80_h> it's the rabhi
19:48:02 <int80_h> one
19:50:38 <int80_h> I like this paper "What the hell are monads"
20:03:35 <glguy> I'm trying to read in lines from a file, each line will become a list of the space delimited elements... could someone recommend a good place to read about string manipulation in haskell...?
20:04:46 <stepcut> glguy: Data.List ...
20:05:18 <sethk> glguy, also Text.Regex
20:05:21 <glguy> stepcut: I'm not sure, but I don't think that's what I want (could be I'm new) but I want "1 2 3 4 5" to become [1,2,3,4,5]
20:05:45 <sethk> glguy, look at readFile, hRead???  (there is a read line, for example).  Also lines, and words, both functions in the preamble
20:05:46 <humasect> [] == Data.List
20:05:49 <Cale> @eval map read $ words "1 2 3 4 5"
20:05:54 <lambdabot> Ambiguous type variable `a' in the constraints
20:06:00 <Cale> @eval map read $ words "1 2 3 4 5" :: [Integer]
20:06:02 <lambdabot> [1,2,3,4,5]
20:06:07 <glguy> ah, very good :)
20:06:28 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
20:06:49 <Cale> String = [Char]
20:07:03 <sethk> there is also a file handling for newbies in the wiki
20:07:05 <Cale> @type reverse
20:07:07 <lambdabot> forall a. [a] -> [a]
20:07:17 <Cale> @eval reverse "Hello, World!"
20:07:19 <lambdabot> "!dlroW ,olleH"
20:07:57 <glguy> I understand that f . g x means f(g(x)), and f $ x means f x... but don't these two basically do a similar thing, could someone help me to understand the difference?
20:08:14 <Cale> (f . g) (x) = f (g x)
20:08:24 <Cale> @type (.)
20:08:26 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
20:08:27 <sethk> f $ g x and f (g (x ))  are the same
20:08:36 <Cale> @type ($)
20:08:37 <lambdabot> forall b a. (a -> b) -> a -> b
20:08:46 <sethk> or just    f (g x)     to get rid of a set of parens
20:08:51 <syntaxfree> I love Haskell.
20:08:59 <Cale> (.) is composition of functions, whereas ($) is just function application
20:09:01 <sethk> glguy, no difference, just a convenience thing
20:09:13 <glguy> I've looked at the definitions in Prelude.hs, but I'm tyring to understand when one should be used over the other
20:09:14 <Cale> there's a difference :)
20:09:22 <syntaxfree> glguy "." is an operation between two functions.
20:09:29 <Cale> a pretty big one, as they aren't the same type
20:09:30 <sethk> Cale,   between   f  (g x)   and   f $ g x    ?
20:09:31 <syntaxfree> "$" is just a way of getting rid of parentheses.
20:09:32 <glguy> AH
20:09:35 <glguy> okay :)
20:09:38 <Cale> oh, not between those two
20:09:39 <syntaxfree> $ is syntactic sugar.
20:09:44 <Cale> $ is just a function
20:09:48 <sethk> Cale, that's what I meant to be saying  :)
20:09:52 <syntaxfree> "." is an actual operation.
20:09:54 <glguy> so I could use (.) for : map f . g list
20:10:10 <syntaxfree> yes.
20:10:22 <syntaxfree> or :  map (\x-> f$g x) list
20:10:23 <sethk> Cale, yes, that's true, they aren't equal in general, just my examples evaluate to the same thing
20:10:26 <Cale> (.) is also a function, but a different one
20:10:40 <Cale> f . g = \x -> f (g x)
20:10:45 <Cale> f $ x = f x
20:11:08 <glguy> so they can be used to the do the same thing in one specific case
20:11:12 <Cale> yeah
20:11:15 <glguy> but I understand what the difference is
20:11:35 <Cale> they can both help cut down on brackets, but they're different conceptually :)
20:11:37 <sethk> glguy, right
20:12:20 <Cale> @eval map ($2) [\x -> x+1, \x -> x^2]
20:12:23 <lambdabot> [3,4]
20:12:50 <Cale> whereas, of course, you can't compose them with 2 :)
20:13:16 <Cale> @eval foldr (.) id [\x -> x+1, \x -> x^2] 4
20:13:18 <lambdabot> 17
20:13:51 <Cale> this composes the functions in the list and then applies the result to 4
20:14:05 <Cale> so, square 4 and add 1 :)
20:14:25 <syntaxfree> I wonder if you can generate a sequence of functions and map (.) to it.
20:14:26 <Cale> but again, ($) doesn't work there
20:15:07 <Cale> @type (.) (\x -> x + 1)
20:15:09 <lambdabot> forall b a. (Num b) => (a -> b) -> a -> b
20:16:15 <syntaxfree> how can I generate an infinite list of functions like (\x->x/k) for k=[1..]?
20:16:39 <Cale> [\x -> x/k | k <- [1..]]
20:17:00 <syntaxfree> hmm. good one. Can that be done with map?
20:17:12 <sethk> Cale, that generates functions?  not values?
20:17:13 <Cale> yes, just by desugaring that
20:17:20 <sethk> Cale, didn't know it was that smart.  :)
20:17:21 <Cale> sethk: functions are values :)
20:17:28 <sethk> Cale, yes, I know
20:17:31 <syntaxfree> Cale: how? :~
20:17:38 <Cale> map (\k -> \x -> x/k) [1..]
20:17:46 <syntaxfree> oh true.
20:17:48 <Cale> or just
20:17:48 <sethk> Cale, but not all values are equal
20:17:51 <Cale> map (\k x -> x/k) [1..]
20:18:02 <syntaxfree> @eval foldl (.) map (\k -> \x -> x/k) [1..10]
20:18:03 <lambdabot>   The lambda expression `\ k -> ...' has one arguments,
20:18:03 <lambdabot>   but its type `[b]' has none
20:18:18 <syntaxfree>  @eval foldl (.) $ map (\k -> \x -> x/k) [1..10]
20:18:37 <Cale> the ' ' will prevent it from doing anything
20:18:45 <Cale> @eval foldl (.) $ map (\k -> \x -> x/k) [1..10]
20:18:46 <lambdabot> Couldn't match `b -> c' against `[b1]'
20:18:58 <Cale> @eval foldl (.) id $ map (\k -> \x -> x/k) [1..10]
20:18:59 <lambdabot>  add an instance declaration for (Show (a -> a))
20:19:04 <syntaxfree> @eval  [\x -> x/k | k <- [1..10]]
20:19:05 <lambdabot>  add an instance declaration for (Show (a -> a))
20:19:09 <Cale> @eval (foldl (.) id $ map (\k -> \x -> x/k) [1..10]) 1
20:19:11 <lambdabot> 2.7557319223985894e-7
20:19:18 <syntaxfree> cool!
20:19:20 <syntaxfree> sequences of functions!
20:19:26 <Cale> yes
20:19:32 * syntaxfree remembers real analysis fondly.
20:19:35 <Cale> :)
20:21:04 <syntaxfree> @eval (foldl (.) id $ map (\k -> \x -> x/(2^k)) [1..10]) 1
20:21:07 <lambdabot> 2.7755575615628914e-17
20:21:46 <Cale> hmm... cute what happens to the digits there :)
20:21:46 <syntaxfree> @eval (foldl (.) id $ map (\k -> \x -> x/(2^k)) [0..10]) 1
20:21:49 <lambdabot> 2.7755575615628914e-17
20:22:06 <syntaxfree> now try to discover why that happens.
20:22:16 <Cale> because one of the functions is \x -> x
20:22:24 <syntaxfree> an intermediate analysis function will help ;-)
20:22:33 * syntaxfree whispers "Ascol-Arzel"
20:23:04 <Cale> oh, are you referring to the digits?
20:23:18 <syntaxfree> sequences of functions could become a whole Haskell idiom.
20:23:40 <glguy> so how do I get an IO String to a [Char]
20:23:43 <syntaxfree> Weird iterations can be expressed as a fold over a sequence of functions.
20:24:18 <sethk> glguy, generally speaking, the whole purpose of the IO monad is to stop you from getting IO String to [Char]
20:24:27 <sethk> glguy, by the way String is just a synonym for [Char]
20:24:42 <sethk> glguy, there is a way to do it, unsafe io, but that isn't what you should be doing.
20:24:46 <syntaxfree> man, I love Haskell.
20:24:49 <Cale> glguy: inside a do-block for an IO action, you can just do:
20:24:55 <Cale> y <- myIOString
20:25:10 <Cale> and then y is of type String
20:25:14 <glguy> ah
20:25:20 <Cale> (where myIOString :: IO String)
20:25:45 <Cale> the <- essentially means to run the IO action and give the result a name
20:26:10 <glguy> alrighty, i can deal with that :)
20:26:16 <Cale> The important thing to remember is that actions are not the values that they return.
20:27:15 <syntaxfree> @eval  map (foldl (.) id [\x -> x^(1/k) | k <- [1..10]]) [1..10]
20:27:17 <lambdabot> Ambiguous type variable `a' in the constraints
20:27:50 <Cale> @eval  map (foldl (.) id [\x -> x**(1/k) | k <- [1..10]]) [1..10]
20:27:52 <lambdabot> [1.0,1.0000001910127994,1.0000003027481412,1.0000003820256353,1.
20:27:52 <lambdabot> 0000004435180416,1.0000004937609985,1.0000005362408153,1.0000005730385
20:27:52 <lambdabot> 08,1.0000006054963742,1.0000006345309258]
20:28:16 <syntaxfree> what did I do wrong?
20:28:26 <Cale> ^ only works with integer exponents
20:28:35 <syntaxfree> ahh yes.
20:28:45 <Cale> there are 3 kinds of exponentiation in the prelude :)
20:28:55 <syntaxfree> @eval  map (foldl (.) id [\x -> x**(1/k) | k <- [1..100]]) [1..10]
20:28:57 <lambdabot> [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
20:29:10 <syntaxfree> do you realize the insane ammount of calculation implied in that single call?
20:29:11 <Cale> actually, (^) only works with positive integer exponents
20:29:24 <Cale> (^^) extends it to negative integers
20:29:26 <syntaxfree>  @eval  sum $ map (foldl (.) id [\x -> x**(1/k) | k <- [1..100]]) [1..100]
20:29:35 <Cale> and (**) works with Floating exponents
20:30:03 <syntaxfree> poor lambdabot. Maybe I've abused it now.
20:30:20 <Cale> if you put a space before the @, it will ignore you
20:30:37 <syntaxfree> oh.
20:30:44 <syntaxfree> @eval  sum $ map (foldl (.) id [\x -> x**(1/k) | k <- [1..100]]) [1..100]
20:30:46 <lambdabot> 100.0
20:30:59 <syntaxfree> I wonder what kinda muscles lambdabot has.
20:31:09 <syntaxfree> @eval  sum $ map (foldl (.) id [\x -> x**(1/k) | k <- [1..5]]) [1..100]
20:31:11 <lambdabot> 103.0806087183691
20:31:59 <Cale> that's not that much computation for a computer :)
20:32:24 <syntaxfree> I'm trying to figure it out as a Matlab routine, and I see nested loops-a-plenty.
20:33:15 <glguy> is there a Haskell paste bot?
20:33:35 <syntaxfree> paste.lisp.org will post stuff here. But no syntax highlighting.
20:33:39 <Cale> @paste
20:33:40 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:33:44 <syntaxfree> some people use the hawiki as well.
20:33:46 <Cale> usually we use the wiki
20:33:51 <syntaxfree> @hawiki HaskellIrcPastePage
20:33:52 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:33:53 <syntaxfree> oh.
20:33:58 * syntaxfree ain't fast enough.
20:34:34 * Cale cleans up
20:35:20 <Cale> syntaxfree: if you like that, you're sure to like infinite lists :)
20:36:07 <Cale> @eval let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in take 20 primes
20:36:10 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
20:36:19 <Cale> primes is the list of all primes :)
20:38:07 <glguy> could someone look at http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show , see what I'm trying to do, and tell me where I've gone astray (I understand that I made a mistake on the end of line 6)
20:38:46 <sethk> BRB, dog calling
20:39:45 <Cale> glguy: okay, where's the definition of gram?
20:40:18 <Cale> also, you don't need an inline type signature if the type is known in the code
20:40:18 <glguy> Cale, i excluded it because it works with a fixed list
20:40:21 <Cale> (which is usually)
20:40:31 <glguy> Cale: and wasn't part of the problem
20:40:41 <Cale> also, what's the type of getArrays?
20:40:49 <glguy> getArrays :: [[Double]] -> [[Double]]
20:40:51 <Cale> (or what do you think it should be?)
20:40:57 <glguy> I've just defined it in my current source
20:41:00 <Cale> okay, but it does IO, right?
20:41:11 <Cale> so it actually can't have that type
20:41:12 <glguy> yeah, so it's IO [[Double]] -> [[Double]]?
20:41:20 <Cale> nope
20:41:21 <glguy> errr
20:41:22 <glguy> wait
20:41:23 <glguy> let me
20:41:26 <glguy> IO [[Double]]
20:41:30 <Cale> also, looks like you're passing a number
20:41:33 <glguy> oh :)
20:41:40 <glguy> Num -> IO [[Double]]
20:41:51 <Cale> Integer -> IO [[Double]], say
20:41:58 <glguy> okay
20:42:18 <Cale> You might be able to make it (Num a) => a -> IO [[Double]] but let's avoid that :)
20:42:42 <Cale> now, there's a problem, definitely, with that second case
20:42:46 <Cale> because it returns []
20:42:55 <glguy> and not a [[]]?
20:43:06 <Cale> [] :: [[Double]], but not IO [[Double]]
20:43:10 <Cale> this is easy to fix
20:43:11 <glguy> ah
20:43:18 <Cale> "return []"
20:43:36 <glguy> wait
20:43:38 <glguy> i know another one
20:43:47 <glguy> I need the map function on a separate line
20:43:49 <glguy> with a <-
20:43:57 <glguy> and then append it to getArrays (n-1) afterwards?
20:44:00 <Cale> you need the getArrays on a separate line
20:44:20 <Cale> because it returns an IO thing which you want to run
20:44:36 <Cale> rest <- getArrays (n-1)
20:44:56 <glguy> ah, okay
20:45:42 <Cale> then: return $ (read $ words line) : rest
20:45:52 <Cale> or some similar construction
20:46:25 <glguy> Cale: so I wouldn't use the map anymore?
20:46:52 <Cale> oh, sorry :)
20:47:01 <Cale> return $ (map read $ words line) : rest
20:47:46 <Cale> in main, you also have to separate out the getting of the arrays :)
20:48:10 <Cale> if you can keep straight in your head what's an IO action, and what's a pure value, you should be fine
20:48:30 <Cale> also note that for giving pure values names in a do-block, you can use let
20:48:41 <Cale> like:
20:48:58 <Cale> let thisLine = map read $ words line
20:49:12 <Cale> return (thisLine : rest)
20:50:30 <Cale> make sense?
20:50:39 <glguy> i think so
20:50:57 <Cale> The distinction seems awkward at first, but you learn to like it. :)
20:51:08 <glguy> i think so
20:51:10 <glguy> err, mt :)
20:52:32 <Cale> let me know if that code works
20:52:41 <glguy> I have one more error
20:53:01 <glguy> I'll update the paste "bot"
20:53:48 <glguy> done
20:55:21 <Cale> okay, that last line of 'main' right?
20:55:35 <glguy> oh, IO () becomes IO [[Double]]
20:55:48 <Cale> you probably want to print the result or something
20:55:48 <glguy> no?
20:55:58 <glguy> yeah... so print gram basis?
20:56:01 <glguy> and still ()
20:56:07 <Cale> currently that last line is  [[Double]]
20:56:10 <Cale> which is the problem :)
20:56:14 <Cale> so yeah, print it
20:56:20 <glguy> so add return [] ?
20:56:23 <glguy> or return () ?
20:56:23 <Cale> print $ gram basis
20:56:25 <glguy> or something?
20:56:28 <Cale> don't need a return
20:56:31 <glguy> alright
20:56:38 <glguy> cool ,it compiles
20:56:41 <Cale> all that return does is turn values into trivial actions
20:56:49 <Cale> which just return that value
20:56:53 <glguy> ah
20:57:21 <syntaxfree> Sequences of fuctions allow for a new definition of factorial.
20:57:41 <glguy> beautiful ! it works :)
20:58:01 <syntaxfree> @eval  map (foldl (.) id [\x -> x*k | k <- [1..10]]) [1..10]
20:58:03 <lambdabot> [3628800,7257600,10886400,14515200,18144000,21772800,25401600,
20:58:03 <lambdabot> 29030400,32659200,36288000]
20:58:34 <syntaxfree>  @eval  foldl (.) id [\x -> x*k | k <- [1..4]]) 4
20:58:42 <syntaxfree> @eval  foldl (.) id [\x -> x*k | k <- [1..4]]) 4
20:58:42 <lambdabot>  parse error on input `)'
20:59:03 <syntaxfree> @eval  (foldl (.) id [\x -> x*k | k <- [1..4]]) 4
20:59:04 <lambdabot> 96
20:59:31 <syntaxfree> @eval  (foldl (.) id [\x -> x*k | k <- [1..4]]) 1
20:59:32 <lambdabot> 24
20:59:39 <syntaxfree> bingo?
20:59:48 <syntaxfree> @eval  (foldl (.) id [\x -> x*k | k <- [1..3]]) 1
20:59:50 <lambdabot> 6
21:00:07 <syntaxfree> YEAH. That one isn't listed at the "Evolution of a Haskell Programmer"
21:00:09 <glguy> Cale: alright, now my code works, just wondering if you'd just glance over the current iteration and see if I've made any other newb Haskell "mistakes" or if I'm getting it...
21:00:17 <glguy> i added the "excluded parts"
21:00:46 <glguy> and then I'll leave you alone for a while while I read more
21:04:26 <glguy> or anyone else for that matter /: )
21:06:25 <Cale> that looks sane on first glance :)
21:06:35 <Cale> I'll try running it :)
21:07:44 <Cale> yep, it seems to work :)
21:09:28 <glguy> and that
21:09:46 <glguy> alright, cool... as you have seen I make a lot of mistakes
21:09:54 <glguy> figured I'd have you look at the rest of my test code
21:34:35 <glguy> What is the # operator...?
21:35:09 <glguy> wait
21:35:20 <glguy> nevermind, it's defined in the function definition I'm looking at
22:32:35 <sethk> can a type defined with a    data Tname =  A | B | C     be used in a later data statement, as in      data T2 = Constructor Int Tname       ?
22:35:08 <sethk> never mind.  I figured it out.
22:35:19 <sethk> I was using the type name instead of one of the constructors   :)
22:43:53 <syntaxfree> @eval  (foldl (.) id [\x -> x*k | k <- [1..5]]) 1
22:44:00 <lambdabot> 120
22:58:07 <sethk> @yow
22:58:07 <lambdabot> Finally, Zippy drives his 1958 RAMBLER METROPOLITAN into the
22:58:07 <lambdabot> faculty
22:58:07 <lambdabot> dining room.
23:07:58 <Cale> http://vx.hn.org/autoshare/griddler-25x25.png :)
23:24:18 <sethk> what is it?
23:25:31 <Cale> a puzzle
23:25:39 <Cale> it starts out grey
23:25:59 <Cale> the numbers along the sides are the lengths of black runs in each row and column
23:26:13 <Cale> you fill it in with black and white :)
23:26:39 <Cale> http://www.chiark.greenend.org.uk/~sgtatham/puzzles/
23:26:51 <Cale> "pattern"
23:28:42 <Cale> unfortunately, it seems to eat 100% cpu and freeze when I ask for a 30x30 puzzle, so 25x25 is as big as I can try
23:29:20 <sethk> I'll have to think about it.  I'm not good at seeing the strategy quickly for that type of thing
23:30:07 <Cale> oh, I see, it just takes it a while to solve the thing and determine that the puzzle has a unique solution before displaying it :)
23:30:28 <Cale> 30x30 looks ridiculous :)
23:31:21 <Cale> It's known that given a solution to the puzzle, determining if there is another solution is NP-complete
23:36:04 <Cale> @eval 2^(30^2)
23:36:10 <lambdabot> 8452712498170643941637436558664265704301557216577944354047371344426782
23:36:10 <lambdabot> 4409075977515906760942025150063147903198921140588621175609520429685960
23:36:10 <lambdabot> 0862365540703323053418694398408134669970428282282305684838772653137901
23:36:10 <lambdabot> 4466368452684024987821414350380272583623832617294363807973376
23:47:44 <stepcut> @eval 10^(10^(10^(10)))
23:47:48 <lambdabot> Terminated
23:47:52 <stepcut> hehehe
