00:21:08 <shapr> hoi boegel!
00:21:27 <shapr> boegel: Does your PhD advisor like your article?
00:25:37 <boegel> shapr: my HRay article ?
00:29:54 <wagerlabs> hello everyone! this channel never sleeps :)
00:32:21 <basti_> nope
00:33:39 <wagerlabs> any manual way of loading my own packages into ghci? without going through setup install with cabal?
00:33:42 <dons> why would it sleep?
00:34:11 <dons> wagerlabs, hmm. just load the src?
00:34:26 <wagerlabs> i must be stupid :)
00:35:28 * wagerlabs got a lot of help from #haskell yesterday
00:36:36 <dons> cool. we try to be helpful :)
00:36:52 <boegel> wagerlabs: that's what #haskell is all about !
00:37:49 <basti_> sometimes we're just making fun of people though.
00:38:11 <dons> oh basti_ :p
00:38:41 <wagerlabs> question... if i had newtype BigEndian a = BigEndian a deriving (Show, Eq, Ord, Num)
00:38:42 <dons> java programmers mostly ;)
00:38:49 <wagerlabs> in a module and then
00:38:55 <wagerlabs> instance (Storable a) => Storable (BigEndian a) where
00:39:05 <wagerlabs> and i exported BigEndian from the module
00:39:22 <wagerlabs> all the functions of storable that i defined would be exported too, right?
00:39:26 <dons> yep
00:39:42 <dons> instances are magically exported.
00:39:51 <wagerlabs> cause when i browse storable i see the functions and when i browse my module i just see
00:39:54 <wagerlabs> data BigEndian a
00:40:04 <wagerlabs> dons: fair enough
00:41:53 <shapr> wagerlabs: We tried sleeping once...
00:42:03 <wagerlabs> :D
00:42:32 <wagerlabs> i'm trying to create a unit test for BigEndian on a... big endian platform
00:43:41 <dons> hmm, I just realised a colleague of mine wrote some endian-handling code. /me goes src diving
00:43:49 <boegel> shapr: my Phd advisor had nothing to do with my thesis, that was another prof...
00:44:19 <boegel> shapr: but I sent an email to my thesis advisor, and I got "Looking good, congratulations" back, so i guess he likes it :P
00:45:56 <wagerlabs> with :: Foreign.Storable.Storable a =>
00:45:57 <wagerlabs>         a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
00:46:18 <wagerlabs> how do i write a call to this?
00:46:39 <wagerlabs> with CInt $ do { ... }
00:46:42 <wagerlabs> ?
00:47:29 <dons> with x $ \ptr -> do something to ptr
00:48:31 <wagerlabs> dons: but the whole call  is supposed to be in the IO monad, right?
00:48:41 <ski> yes
00:48:49 <dons> it has IO type, so yep
00:50:05 <wagerlabs> but where's the pointer?
00:50:40 <dons> it's passed as an argument to the second argumment of with
00:50:48 <wagerlabs> i.e. i'm supposed to pass in a storable and a function that takes a pointer to a storable. ptr is the function
00:51:17 <dons> you call: with x f, where f is a function that takes a Ptr
00:51:20 <wagerlabs> dons: i thought ptr is the name of the lambda... i guess \ is the lambda and ptr is the argument, right?
00:51:40 <dons> lambdas don't have names, so ptr is the argument
00:51:59 <wagerlabs> dons: so if the lambda took two pointers then it would be \(ptr1, ptr2), right?
00:52:38 <dons> nope ;)
00:52:43 <dons> \ptr1 ptr2 -> ...
00:52:48 <wagerlabs> :D
00:52:52 <wagerlabs> gotta go read up
00:52:54 <dons> you have a single tuple argument, containing 2 ptrs.
00:53:38 <dons> though with the curry and uncurry functions you can convert between a b and (a,b)
00:54:12 <shapr> boegel: spiffy!
00:54:50 <wagerlabs> any emacs mode lovers?
00:54:58 <wagerlabs> haskell emacs mode that is
00:54:58 <dons> I would like to see graphs of the number of nicks sitting in #haskell over time.
00:55:21 <shapr> We've got logs.
00:55:54 <shapr> I can show you the earliest log we've got: http://www.scannedinavian.org/~shae/01.12.16
00:56:22 <shapr> names: list (clog kepler hcf shapr xbill dnm pHa smkl dennisb)
00:56:55 <dons> we do. but hmm, working out who's there at any point is a bt annoying
00:56:58 <dons> oh, and juhp!
00:57:16 <dons> hehe topic: '#haskell: spooky. quiet.'
00:57:34 <dons> very unlike the #haskell of 2005
00:57:38 <shapr> yup
00:57:54 <dcoutts> morning folks
00:58:16 <dons> morning dcoutts
00:58:20 <dcoutts> I'm looking for a question
00:58:27 <shapr> dons: What sort of features do you want for a #haskell log reporter?
00:58:44 <dons> well, i'm just really interested in a nicks versus time graph
00:59:07 <dcoutts> we've got an introductory session for all our new phd students and I'm supposed to run the 'ice breaker' session
00:59:12 <shapr> So, max nicks per day?
00:59:30 <shapr> dcoutts: give 'em all an irc client and get 'em onto #haskell :-)
00:59:49 <dcoutts> where we get them to stand up and say who they are and a little bit about themselves, I need an inane question to ask them to make it lest booring
00:59:54 <dons> per day or per week, perhaps. daily, weekly, yearly graphs would be good
01:00:50 <dcoutts> something more interesting than "what is your favourite colour?" but les political than "if you ruled the world what is the first thing you'd do?"
01:01:06 <dons> if you rule the world, what language would you program in?
01:01:10 <dcoutts> ha!
01:01:31 <shapr> dcoutts: Bring your unicycle!
01:01:40 <shapr> Ask people what they do for fun.
01:01:43 <dcoutts> shapr, oh good idea
01:01:52 <dcoutts> especially the really big one!
01:01:55 <dons> shapr, graphs like this, basically: http://www.oxide.org/cvs/
01:02:04 <shapr> Bring a list and map of the nearest quality pubs.
01:02:12 <dcoutts> hmm
01:02:35 <shapr> In fact... I'd suggest you take all the PhD students down to the pub to have an ice breaker session.
01:02:47 <shapr> Just make sure they don't too many pints :-)
01:03:00 <shapr> get*
01:03:01 <dcoutts> sadly our secedule only gives time for a coffe break :-(
01:03:22 <dcoutts> we're teaching them how to teach & run practical sessions
01:03:33 <shapr> So, tell them all at the coffee break that you've rescheduled your meeting at a pub after work.
01:03:54 <shapr> Hm, all my experience in commercial software development teaches me that there are two kinds of meetings..
01:04:04 <shapr> At least, two flavors that actually work..
01:04:34 <Lemmih> Good morning, #haskell.
01:04:39 <dcoutts> morning Lemmih
01:04:43 <shapr> One is a stand up meeting with donuts, make sure there's nowhere to sit down and food to eat, and then people won't sit down and talk for long, and they'll only say something if they really need to say it. (Programmers don't turn down free food)
01:04:59 <dcoutts> :-)
01:05:19 <shapr> The other kind of meeting involves going to a restaraunt or pub and having a relaxed discussion about how things are going.
01:05:28 <shapr> Both flavors of meetings get results.
01:05:35 <dcoutts> ah I see a theme here
01:05:39 <dcoutts> food
01:05:47 <shapr> Meetings where your manager/boss/etc talks to the subjects are a waste of time and money.
01:06:03 <shapr> Well, yes..
01:06:28 <shapr> Some programmers just aren't naturally social, some are distractible and need something to do with their hands...
01:06:40 <shapr> Everybody feels more relaxed and happy after food
01:06:47 <dcoutts> yep
01:07:19 <shapr> Free food motivates people to come to the meetings, gives people something to hold and wave around, improves the mood, etc
01:07:43 <C-Keen> moin.
01:07:56 <shapr> Anyway, that's my advice on having meetings.
01:08:21 <dcoutts> so maybe I'll get them to write their names on the board with a sketch of their favourite food and get them to say what they do in their spare time / as a hobby.
01:08:33 <shapr> Sounds good to me.
01:08:49 <dcoutts> thank's for the inspiration :-)
01:08:58 <shapr> Sure, but there's one caveat...
01:09:04 <shapr> This only works for -Ofun people
01:09:13 * dcoutts grins
01:09:32 <shapr> I have no idea how to deal with "just business" types who don't want to get to know the others they work with.
01:09:50 * shapr decides his blood type is Ofun
01:10:24 <shapr> hiya C-Keen
01:10:58 <dcoutts> then after the ice breaker session we're also doing this daft roleplay thing where I pretend to be a dumb student how can't code and another person plays the teacher/demonstrater. I'm supposed to be havign some problem I don't understand.
01:11:10 <shapr> Um
01:11:30 <dcoutts> what Haskell error messages to beginners get most do you think
01:11:36 <shapr> Sounds daft to me.
01:11:46 <dcoutts> and what would their corresponding misconception / mistake have been?
01:11:47 <shapr> Oh, they get "not an instance of Num" first
01:11:57 <shapr> Char is not an instance of Num
01:11:59 <dcoutts> oh yeah
01:12:15 <shapr> Then they ask why the types are different between ghci and ghc
01:12:19 <shapr> (type defaulting in ghci)
01:12:36 <shapr> Then a week later they ask how to get an Int out of an IO Int
01:12:43 <dcoutts> heh yeah
01:13:14 <shapr> Then they write code where they leave out the base case and can't figure out how to debug infinite loops
01:13:23 <dcoutts> ah yes, good one
01:13:39 <shapr> @type (**)
01:13:41 <dcoutts> (I'm tring to confuse the other chap I'm doing the role play with)
01:13:44 <lambdabot> forall a. (Floating a) => a -> a -> a
01:13:44 <shapr> @type (^)
01:13:46 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
01:14:05 <dcoutts> he said I should just come up with some things and he'll have to work them out
01:14:10 <shapr> Then they always use the wrong one of ** or ^ in their code and get stuck again.
01:14:38 <shapr> Or even worse, they stick together two different modules where each use ** and ^ correctly and get stuck on that.
01:14:46 <dcoutts> hmm, yes that's one they're going to get wrong this term I reckon
01:15:08 <dcoutts> we're doing a Haskell practical that uses int's & doubles & ^/**
01:15:38 <dcoutts> and they'll get errors from missing fromIntegral all over the place
01:15:43 <shapr> yup
01:16:19 <integral> runSTArray $ do { newArray (1,2) 1 } -- my favourite is do not working with runSTArray
01:16:52 <shapr> dcoutts: Oh, someone will surely get the indentation of if-then-else wrong
01:16:56 <dcoutts> integral, isn't that the '$' not working with runSTArray
01:17:10 <dcoutts> shapr, how does that go wrong?
01:17:13 <shapr> they'll do it vertically with each having the same amount of indentation.
01:17:22 <integral> hmm, is it?  I don't know.  I don't understand when foralls move around, really
01:17:29 <shapr> Gee, maybe we should write a FAQ
01:17:43 <shapr> I hadn't realized how many of these errors are repeated on #haskell
01:17:50 <dcoutts> I don't get the if-then-else one
01:18:06 <dcoutts> unless they start at column 0
01:18:16 <integral> I've done the if-then-else one inside a do block
01:18:25 <dcoutts> but people do get the indentation of where clsuses wrong all the time
01:18:46 <dcoutts> integral, ah yes in a do block, but we usually don't intoduce do notation very early
01:18:47 <dons> maybe we need an newbie-FAQ
01:19:16 <shapr> I think so.
01:19:23 <integral> ah, you're right, dcoutts, it is the $ that's the problem
01:19:25 <shapr> That's another good idea for log analysis.
01:20:14 <shapr> dcoutts: Hm, I can't remember the details of the if problem right now.
01:22:12 <dcoutts> shapr, thanks again, that's plenty of inspiration
01:22:25 * dcoutts dashes off for the session
01:23:04 <shapr> :-)
01:36:35 <aleator> @seen JohnMeacham
01:36:37 <lambdabot> JohnMeacham is in #haskell. I don't know when JohnMeacham last spoke.
01:36:56 <aleator> JohnMeacham: Ping?
01:56:15 <shapr> The difference between copy buffer and selection in X irritates me. Is it just my early years of using windows?
01:59:22 <rep> probably :)
01:59:40 <shapr> In that case, how do you copy'n'paste from and to emacs and an xterm?
01:59:46 * shapr looks at rep
02:00:09 <ski> mark -- middle-button ?
02:00:16 <shapr> I don't want to use the mouse.
02:00:48 <rep> you can't, afaik, in X
02:00:50 <shapr> I have ion and emacs so that my RSI will get better, but using the mouse regularly hurts more.
02:00:56 <ski> (hm, can you mark stuff in xterm without using the mouse ?)
02:01:10 <shapr> No, good point.
02:01:26 <shapr> eshell works nicely though.
02:01:39 <rep> shift-space to mark beginning, C-w to copy, at the end?
02:02:14 <shapr> That only seems to copy for zsh, not for X
02:03:17 <rep> at least in os x, the top of the emacs kill-buffer is actually the os copy-paste buffer, so you can copy to/from emacs
02:03:43 <rep> but i'm not sure it works that way in in X
02:03:47 <rep> -in
02:03:49 <shapr> I can do that in X also.
02:04:03 <rep> so all is good!
02:04:08 <rep> (or not?)
02:04:23 <yaarg> xclip
02:04:23 <shapr> So I guess I just need to find two things, a keybinding to paste into gnome-terminal, and a terminal that lets me select via the keyboard, emacs-style.
02:05:04 <rep> does ctrl-v work, shapr ?
02:05:05 <shapr> I often wish for Python's interactive _ value in shell scripting.
02:05:32 <shapr> Nope, C-y pastes for zsh, but C-v does nothing.
02:05:37 <rep> ah
02:05:41 * ski wants program windows to have sane colorings ..
02:05:44 <shapr> I have emacs keys set for gnome, but it doesn't always work.
02:05:48 <shapr> ski: Like what?
02:05:50 <yaarg> you can use xclip to access the clipboard from the command line
02:05:57 <rep> screen has vi-style copying, afaik
02:06:02 <shapr> yaarg: Nifty, didn't know about that.
02:06:36 <ski> i.e. if it can use default bgcolor as it's bgcolor, it should allow the same for textcolor
02:06:42 <rep> so screen+xclip would work
02:07:04 <shapr> ski: huh?
02:07:17 <ski> if i change bgcolor to black and textcolor to white e.g., some programs will still show black text on top of that
02:07:56 <shapr> That's braindead.
02:08:07 <ski> indeed
02:09:24 <shapr> yaarg: This is great! thanks!
02:10:09 * shapr makes xcopy $1 (file or text string) and xpaste aliases
02:11:53 <yaarg> shapr: yup it's very useful :)
02:14:11 <booger> anyone up for helping me with a haskell problem?
02:14:22 <ski> what is your problem ?
02:16:06 <dblhelix> booger: shoot
02:16:33 <shapr> Next question, is there some way to edit keybindings for firefox? I want to bind C-v and M-v emacs-style
02:16:57 <shapr> Ola wagerlabs. ¿como est as?
02:17:03 <wagerlabs> ola shapr
02:17:05 <wagerlabs> hola
02:17:11 <shapr> Privet :-)
02:17:21 <shapr> Oh right, ola is portuguese
02:17:22 <wagerlabs> @paste
02:17:23 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:17:37 <shapr> óla actually
02:17:44 <wagerlabs> if i wanted to define a type Endian that took a Big/Little "argument"
02:17:48 <wagerlabs> how would i do that?
02:18:09 <shapr> You'd probably want data Endian = Big | Little
02:18:12 <wagerlabs> the reason is that i would like to use the code at @paste but don't want to duplicate the method
02:18:40 <wagerlabs> i just want to say if type != platform type then use reverse methods
02:19:07 <wagerlabs> shapr: you mean data Endian = Big a | Little a
02:20:48 <dblhelix> wagnerlabs: where's that a coming from... it's not at the lhs
02:21:08 <wagerlabs> dblhelix: what do you mean?
02:21:09 <dblhelix> wagerlabs:  hence, it's not legal haskell
02:21:29 <wagerlabs> i have this right now
02:21:29 <wagerlabs> newtype BigEndian a = BigEndian a deriving (Show, Eq, Ord, Num)
02:21:51 <wagerlabs> and then
02:21:52 <wagerlabs> instance (Storable a) => Storable (BigEndian a) where
02:22:18 <dblhelix> wagnerlabs: but don't you want Endian a = Big a | Little a or something isomorphic?
02:22:34 <wagerlabs> dblhelix: i think that's what i want, yes
02:22:44 <wagerlabs> dblhelix: but i also want these to be instances of storable
02:23:31 <dblhelix> wagnerlabs: that shouldn't pose a problem
02:23:48 <shapr> wagner :-)
02:23:51 * shapr grins
02:24:14 * wagerlabs should just rename himself to joelr :D
02:24:41 <dblhelix> oops
02:24:57 <wagerlabs> how do i define a type that takes just two values, Big or Little?
02:24:58 * dblhelix has the music in him today
02:25:10 <wagerlabs> newtype Endianness = Big | Little?
02:25:13 <Matt-W> data Wibble = Big | Little
02:25:19 <Matt-W> or something of that sort :-)
02:25:36 * Matt-W never did understand the difference between newtype and data
02:26:04 <dblhelix> Matt-W: it's a strictness issue
02:26:12 <wagerlabs> but then how do i define an instance of Storable that also takes Endianness?
02:26:45 <dblhelix> Matt-W: furthermore, a newtype can only have one data constructor, which can only take one argument
02:26:48 <wagerlabs> the reason i want Endianness as a separate type is because i have a function that returns the endianness of the platform
02:27:37 <dblhelix> Matt-W: as a consequence a type constructor defined with newtype is truly isomorphic with the argument type of it's sole data constructor
02:28:49 <dblhelix> wagerlabs: data TheThingToStore = SomeConstructor Endianness BaseVal deriving (...)
02:28:58 <Matt-W> dblhelix: so it's helpful when reasoning and presumably can give hints to the compiler
02:29:36 <dblhelix> Matt-W:  indeed, the compiler can, in many cases, just throw strip off the data constructor
02:29:49 <dblhelix> /s/throw strip/strip
02:29:52 <wagerlabs> dblhelix: but how do i enforce the types of the arguments to the constructor?
02:30:21 <Matt-W> dblhelix: handy. Thanks.
02:30:27 <dblhelix> wagerlabs: please elaborate on that
02:30:37 <dblhelix> wagerlabs: what do you mean?
02:30:48 <wagerlabs> dblhelix: i want the two "arguments" to be Storable and Endianness, of these types
02:31:07 <dblhelix> Matt-W: note that newtype T = D A ~= data T = D !A
02:32:01 <dblhelix> wagerlabs: if BaseVal is some fixed type, then you should ensure that it's Storable
02:32:18 <wagerlabs> dblhelix: yes, how do i do that?
02:32:37 <dblhelix> wagerlabs: instance Storable BaseVal where ...
02:33:13 <wagerlabs> hmm
02:33:13 <wagerlabs> so
02:33:16 <Matt-W> dblhelix: are you meaning approximately equals with ~=? I keep reading it as the Perl 5 pattern match operator
02:33:18 <dblhelix> wagerlabs: or you could abstract away from BaseVal: data TheThingToStore a = SomeConstructor Endianness a deriving (...)
02:33:44 <wagerlabs> data Endianness = Big | Little
02:33:51 <dblhelix> wagerlabs: instance (Storable a) => Storable (TheThingToStore a) where ...
02:33:52 <wagerlabs> dblhelix: so far so good?
02:33:58 * shapr quotes wagerlabs on LtU
02:33:58 <dblhelix> wagerlabs: yes
02:34:08 <wagerlabs> shapr: where? :)
02:34:21 <dblhelix> Matt-W: yes, I mean "more or less equal" ;)
02:34:28 <Matt-W> dblhelix: just checking :-)
02:34:50 <wagerlabs> dblhelix: then data Endian a = Endian a, Endianness b?
02:35:06 <dblhelix> wagerlabs: ehhh????
02:35:24 <wagerlabs> dblhelix: i want Endian to be a storable with an extra argument of Endianness :)
02:35:44 <dblhelix> wagerlabs: data Endian a = Endian Endianness a
02:35:57 <shapr> wagerlabs: http://lambda-the-ultimate.org/node/view/1030#comment-10661
02:36:16 <wagerlabs> dblhelix: but i want endianness to be an _extra_ argument, the first one should be a value
02:36:25 <wagerlabs> dblhelix: a constructor with two arguments
02:36:43 <wagerlabs> dblhelix: where the first one is a value and the second one is the endianness
02:36:50 <wagerlabs> dblhelix: or is the value there by default somehow?
02:37:16 <dblhelix> wagerlabs: then just switch them: data Endian a = Endian a Endianness
02:37:51 <dblhelix> wagerlabs: then you can have values like Endian 'a' Big and Endian 5 Little
02:37:58 <wagerlabs> i'm famous... almost :D
02:38:12 <shapr> wagerlabs: I was saddened by the vendor response mentioned in your blog post. My idealism says that companies want a better mousetrap, my experience says that they will continue to employ replacable neanderthals with hammers as their mousetraps.
02:38:20 <dblhelix> wagerlabs: these have types Endian Char and Endian Integer, respectively
02:38:22 <wagerlabs> dblhelix: that's exactly what i want!
02:38:36 <dblhelix> wagerlabs: then, now you have it :)
02:38:41 <wagerlabs> dblhelix: but how do i retreive the Endianness  later on?
02:38:48 <wagerlabs> in the Storable functions
02:39:00 <wagerlabs> shapr: you are right
02:39:01 <dblhelix> getEndianness : Endian a -> Endianness
02:39:12 <dblhelix> getEndianness (Endian a e) = e
02:39:27 <wagerlabs> dblhelix: wow, i'm gonna do this now
02:39:40 <dblhelix> wagerlabs: this calls for a drink! :)
02:39:40 <shapr> wagerlabs: I think the only solution is for us to form our own companies and make enough money to kill of the neanderthal employers.
02:40:06 <Matt-W> shapr: most people are stuck in neanderthal mode, unfortunately
02:40:14 <wagerlabs> shapr: that's why i switched from pitching openpoker to consulting for poker shops and trying to propose solutions that don't change their existing infrastructure. of course this only works with shops where that infrastructure is broken and needs to be shored up
02:41:08 <wagerlabs> folks, any shorter word for Endianness? ByteOrder maybe? :D
02:41:57 <Matt-W> Not that's readable
02:42:31 <malcolm> BigLittle
02:43:02 * Matt-W is a fan of using names which make sense, no matter how verbose it gets
02:43:54 <wagerlabs> so i have this right now
02:43:55 <wagerlabs> isBigEndian = $(lift $ (1::CChar) /= (unsafePerformIO
02:43:55 <wagerlabs>                                      $ with (1::CInt)
02:43:55 <wagerlabs>                                      $ peekByteOff `flip` 0) ) :: Bool
02:44:17 <wagerlabs> which returns True or False with the help of the lift (which was explained to me yesterday(
02:44:33 <wagerlabs> how would i convert it to returning Big or Little? anything more elegant than an if?
02:45:06 <wagerlabs> i.e. how would i write a lift to go from boolean to Endianness? just a simple function with guards?
02:46:02 <malcolm> It will be a conditional of some kind: if, case, guards - they all amount to the same thing.  Just choose the least verbose.
02:46:16 <wagerlabs> getHostByteOrder
02:46:16 <wagerlabs>     | True -> BigEndian
02:46:16 <wagerlabs>     | otherwise -> LittleEndian
02:46:19 <wagerlabs> like this?
02:46:31 <earthy> yes, but the name is misleading
02:47:02 <wagerlabs> another try...
02:47:03 <wagerlabs> data ByteOrder = BigEndian | LittleEndian
02:47:11 <wagerlabs> getHostByteOrder :: ByteOrder
02:47:33 <earthy> getHostByteOrder | isBigEndian = BigEndian ; | otherwise = LittleEndian
02:47:53 <wagerlabs> earthy: oh, thank you!
02:48:17 <earthy> the sytnax may be off though
02:48:33 <earthy> I don't often write code with guards
02:49:34 <shapr> Man, I have to read this guy Kent Dybvig, I've been seeing his work in a number of intereting places.
02:54:59 <ski> isn't that some scheme (or lisp) guy ?
02:55:05 <shapr> Yup
02:56:23 <Lemmih> dons: pign.
02:56:25 <Lemmih> *ping
02:57:01 <wagerlabs>     peek = if getHostByteOrder == getByteOrder a
02:57:19 <wagerlabs> i'm getting a "a not in scope" error
02:57:33 <wagerlabs> do i put getByteOrder a in parens?
02:57:53 <Akshaal> peek a =
02:58:17 <wagerlabs>     peek (Endian a) = if getHostByteOrder == getByteOrder a
02:58:23 <wagerlabs> or is Endian a superfluous here?
02:58:32 <wagerlabs> instance (Storable a) => Storable (Endian a) where
02:58:32 <wagerlabs>     sizeOf (Endian a) = sizeOf a
02:58:32 <wagerlabs>     alignment (Endian a) = alignment a
02:58:32 <wagerlabs>     peek (Endian a) = if getHostByteOrder == getByteOrder a
02:59:09 <wagerlabs> no, i don't think it is
03:02:47 <shapr> I'm so happy the quote "it's turtles all the way down" is getting popular.
03:06:54 * ski thought the turtle swam through space ..
03:10:52 <shapr> hiya srle
03:11:42 <wagerlabs> folks, could you help me compile @pate
03:11:44 <wagerlabs> @paste
03:11:46 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:15:53 <wagerlabs> please :-)
03:17:57 <dblhelix> fmap Endian ... gives you a list of Endians: [Endian], I guess you need [Ptr Endian]s
03:18:48 <wagerlabs> dblhelix: Cale wrote that yesterday but Endian was a newtype yesterday
03:19:00 <wagerlabs> dblhelix: now it's a data
03:19:16 <dblhelix> that shouldn't make too much of a difference
03:19:34 <wagerlabs> this was the original:    peekR = peekByteOff `flip` 0
03:19:58 <araujo> Hello.
03:21:09 <wagerlabs> the version from yesterday is below in the paste
03:21:23 <wagerlabs> i think it's an issue of my adding (Endian a b) to peek
03:21:25 <wagerlabs> ;(
03:27:34 <wagerlabs> this is a simpler example:
03:27:34 <wagerlabs> instance (Storable a) => Storable (Endian a) where
03:27:35 <wagerlabs>     sizeOf (Endian a _) = sizeOf a
03:27:36 <wagerlabs>     alignment (Endian a _) = alignment a
03:27:36 <wagerlabs>     peek (Endian a b) =
03:27:37 <wagerlabs>         if getHostByteOrder == b
03:27:40 <wagerlabs>            then peek0
03:27:42 <wagerlabs>            else peekR
03:27:45 <wagerlabs>         where
03:27:47 <wagerlabs>             peek0 a = peekByteOff `flip` 0
03:27:50 <wagerlabs>             peekR a = peekByteOff a 0
03:27:59 <wagerlabs> it complains
03:28:01 <wagerlabs> Endian.hs:36:10:
03:28:01 <wagerlabs>     Couldn't match `Ptr (Endian a)' against `Endian a1'
03:28:01 <wagerlabs>       Expected type: Ptr (Endian a)
03:28:01 <wagerlabs>       Inferred type: Endian a1
03:31:27 <shapr> I think there's some fairly obvious connection between delimited continuations and comonads, but it isn't immediately clear to me.
03:31:28 <ski> 'peek (Endian a b) =' is worng
03:31:31 <Akshaal> then peek0 a else peekR a
03:31:59 <Akshaal> peek0 a = peekByteOff a 0
03:32:05 <ski> (shapr : i just defined a nice function in nqCPS for streams)
03:32:15 <shapr> hm!
03:32:38 * ski converts list functions to stream functions
03:32:58 <ski> (nqCPS is more or less delimited continuations, you know)
03:33:11 <wagerlabs> Akshaal: does that compile for you?
03:33:39 <wagerlabs> ski: sorry, does that compile for you?
03:33:45 <Akshaal> wagerlabs: I don't know
03:33:49 <wagerlabs> ski: i put that in to be able to grab b
03:34:00 <ski> wagerlabs : peek gets a 'Ptr (Endian ..)', so you need to extract the value before you patternmatch
03:34:01 <wagerlabs> ski: which is the byte order
03:34:11 * ski has not tried compiling it
03:34:32 <wagerlabs> ski: let me see...
03:35:04 <ski> peek :: Storable a => Ptr a -> IO a
03:35:05 <wagerlabs> ski: so i do peek = ... but how do i get to the value of b then?
03:35:16 <ski> hm
03:36:14 <ski> i think your peek0 and peekR hasn't same type
03:37:00 <wagerlabs> ski: Endian is "Endian a b" where A is storable and B is ByteOrder
03:37:01 <Akshaal> oh, really. peek should be 'peek a = do {d = peek a; return $ Endian d getHostByteOrder}
03:37:35 <ski> that doesn't work
03:37:49 * ski wonders if the design is right
03:38:04 <wagerlabs> Akshaal: it's not quite what i have in mind :) i need to compare the byte order in Endian with the host byte order to see if direct or reverse peek needs to be used
03:38:46 <wagerlabs> Endian is just a wrapper around a storable that includes the byte order
03:38:48 <beschmi> the definition of castAway seems wrong with data instead of newtype
03:39:12 <beschmi> (but that should be a runtime error)
03:39:21 <ski> hm, i think peek is used for stuff where the type is abstract and the value is actually a foreign value
03:39:40 <ski> (which is not exactly the case here)
03:39:42 <ski> hm
03:40:53 <Akshaal> wagerlabs: just write your own "peekWithEndianness a b = "
03:40:58 <ski> ideally, we'd want to decompose a Ptr to an Endian into two Pointers to the two parts .. then compare the stored endianess with the host endianess and use that to read the other pointer
03:41:11 <wagerlabs> Akshaal: i want Endian to be an instance of Storable
03:42:01 <wagerlabs> ski: i think the issue is that with newtype and no additional byteorder argument the runtime reps matched and they no longer do
03:42:06 <ski> wagerlabs : you want to, dynamically have different endianesses stored in different Endian values, right ?
03:42:44 <wagerlabs> ski: Endian is exactly like a Storable but with an extra flag to tell me what's inside
03:42:54 <wagerlabs> ski: so i guess you are right
03:43:18 <wagerlabs> ski: basically, i get a Storable from a socket but it has a little-endian storable in it
03:43:30 <ski> or would fixing the endianess by a typeclass or global constant (different on different platforms) suffice ?
03:43:38 <ski> hm, i guess it would not
03:43:42 <wagerlabs> so to extract the host-endian i need to possibly do a conversion
03:44:37 <wagerlabs> ski: i'm reading a 32-bit integer (or 16 bit or a float) from the socket but that has little-endian data in it
03:44:42 <wagerlabs> ski: sent from wintel
03:44:48 <wagerlabs> ski: so i can't just use the value
03:45:16 <wagerlabs> ski: i'm looking to compose packet definitions from Endian fields and i would know in advance that these fields would be little-endian, for example.
03:45:18 <ski> you can't associate an endianess with the socket, somehow, and use that when getting values out of it, hmm
03:45:21 <ski> (?)
03:45:42 <wagerlabs> ski: i could but i don't want to duplicate the reading code
03:45:48 <ski> m
03:46:06 <wagerlabs> ski: i would need to have different i/o code to read big and little endian values
03:46:46 <wagerlabs> ski: so i would need to create little-endian sockets or big-endian sockets. doesn't seem to buy me much over wrapping storables in something with a a byte order flag (Endian)
03:48:42 <ski> hm, you said 'Endian a b' .. you intend to pass in different types for 'b' ?
03:49:14 <wagerlabs> ski: yes, because i might want to read/write BigEndian whilst on a little-endian platform
03:49:35 <ski> what types could 'b' be ?
03:49:53 <wagerlabs> Big|Endian
03:49:57 <wagerlabs> please see @paste
03:50:05 <wagerlabs> for the complete definition
03:50:56 <ski> m, looking
03:52:00 <wagerlabs> ski: would it suffice to convert a Ptr (Storable a) to Ptr (Endian a) somehow?
03:53:04 <ski> (hm, i think 'peekByteOff `flip` 0' is better written '(`peekByteOff` 0)')
03:53:38 <wagerlabs> ski: that does not help the overall issue, though :(
03:53:41 <ski> 'Ptr (Storable a)' is nonsense
03:53:47 <ski> no, still loking
03:53:50 <ski> looking
03:54:21 <ski> (it just looked so strange so i had to comment)
03:54:58 <Matt-W> Is there a library function to pull an item out of a list which matches a given predicate, returning said item and the remainder of the list?
03:56:12 <shapr> hej ralejs
03:56:19 <ralejs> Hej shapr
03:56:36 <wagerlabs> would this work as a cast?
03:56:38 <wagerlabs> castAway1 :: Storable a => Ptr a -> Ptr (Endian a b)
03:56:38 <wagerlabs> castAway1 = castPtr
03:56:58 <aleator> Matt-W: dropWhile & not?
03:57:16 <shapr> ralejs: I hear that comonads still have the black box problem.
03:57:34 <ralejs> shapr: What do you mean?
03:57:40 <Matt-W> aleator: without losing any items which might be before the desired item in the list
03:58:01 <Matt-W> I think I'll just write my own
03:58:09 <shapr> I was hoping Comonads would give some of the advantages of arrows without any of the drawbacks.
03:58:51 <ralejs> Well, I suppose we don't know comonads well enough yet. Or did you have something in particular in mind?
03:59:24 <shapr> Uustalo's recent comonads paper.
03:59:38 <ski> shapr : black box problem ?
03:59:44 <ski> wagerlabs : probably not
03:59:48 <shapr> ski: Arrows can't optimize lifted functions.
03:59:53 <shapr> No introspection.
03:59:58 <wagerlabs> i'm going bonkers
04:00:09 <wagerlabs> what i'm trying to do seems rather simple
04:00:11 <shapr> wagerlabs: Visit me when you get here!
04:00:30 <wagerlabs> is it me? is it haskell? why is this so difficult?
04:00:38 <shapr> wagerlabs: Maybe there's a much much simpler solution? Wrong approach?
04:00:39 <ralejs> Right. Well comonads are just like monads only dual, so some of the intuition about monads carries over. For example lack of introspection.
04:00:46 <basti_> shapr: having an reasonable framework for dataflow semantics is an advantage
04:01:00 <shapr> wagerlabs: Can you restate the original question?
04:01:02 <ski> wagerlabs : (if your design indeed works) i think you need to first read out the value endianess, compare with the host endianess, and using that read out the value
04:01:21 <wagerlabs> ski: exactly, but how do i accomplish that?
04:01:26 <wagerlabs> shapr: please see @paste
04:01:53 <ski> shapr : ah, right .. so for that extra-optimised parser, arrows may still be best (especially as i think comonads can't parse)
04:01:55 <wagerlabs> shapr: i'm trying to make an instance of storable that also includes the byte order
04:02:11 <wagerlabs> data ByteOrder = BigEndian | LittleEndian deriving (Show, Eq, Ord)
04:02:11 <wagerlabs> data Endian a = Endian a ByteOrder deriving (Show, Eq, Ord)
04:02:15 <ski> wagerlabs : sorry, i don't know, i haven't done much with the FFI
04:02:23 <ralejs> shapr: What do you mean with arrows can't optimize lifted functions?
04:02:24 <wagerlabs> shapr: instance (Storable a) => Storable (Endian a b) where
04:02:36 <ski> wagerlabs : maybe peekOff something to get the endianess ?
04:02:47 <shapr> wagerlabs: No, I mean... what's the *original* problem?
04:03:10 <shapr> wagerlabs: You're trying to get a specific solution to work.. maybe there's a different and easier solution?
04:03:11 <ski> ralejs : functions can't be analyzed (except by calling them :)
04:03:16 <wagerlabs> shapr: i can read a CInt, Float, etc. out of a socket but they might be in the wrong byte order
04:03:34 <shapr> Why is that?
04:03:39 <wagerlabs> shapr: i'm composing packets from fields and giving fields a particular byte order
04:03:49 <wagerlabs> shapr: why's what?
04:04:13 <aleator> Matt-W:  takeWhile & dropWhile & not?
04:04:27 <Plex> Are declarative and functional languages the same (meaning), or are there differences?
04:04:30 <ralejs> ski: Yes, but I still don't understand what shapr meant when he said that arrows can't optimize lifted functions.
04:04:32 <shapr> wagerlabs: Windows sends one byte order, right?
04:04:43 <ski> Plex : declarative is a superset of functional
04:04:49 <wagerlabs> shapr: i'm on powerpc which is big-endian. i'm working with a wintel server that _always_ sends little-endian
04:05:01 <shapr> Do you get packets from powerpc also?
04:05:06 <wagerlabs> shapr: by the same token, though, i might be on wintel and get packets from powerpc
04:05:37 <ski> ralejs : if you convert a function to an arrow by  arr :: Arrow ar => (a -> b) -> ar a b  then you can't look inside the function
04:05:41 <malcolm> wagerlabs: your code doesn't compile because of this line: instance Storable a => Storable (Endian a b)
04:05:42 <ralejs> ski: Nevermind. I thought shapr was answering my question. I was confused by that. Sorry.
04:06:04 <wagerlabs> malcolm: so what should i change it to? i want my Endian to be a storable
04:06:07 <malcolm> wagerlabs: Endian does not have two parameters, just one
04:06:24 <wagerlabs> malcolm: so i need to add the other parameter in there?
04:06:36 <malcolm> wagerlabs: No, take one out!
04:06:44 * ski thinks wagerlabs changed back and forth a bit
04:06:56 <wagerlabs> ski: why do you say so?
04:06:56 <malcolm> wagerlabs: instance Storable a => Storable (Endian a) where ...
04:07:04 <shapr> wagerlabs: Can you tell what flavor of packet you will get ahead of time?
04:07:08 <wagerlabs> malcolm: it does not tell
04:07:14 <wagerlabs> malcolm: it does not help that is
04:07:21 <ski> wagerlabs : i.e. you weren't sure if you wanted one or two args ..  am i correct ?
04:07:23 <wagerlabs> shapr: of course. i know that
04:07:29 <malcolm> wagerlabs: well, there are other problems too, that was just the first one
04:07:38 <wagerlabs> ski: i want Endian to be 2 arguments
04:07:46 <ski> ok
04:07:52 <wagerlabs> malcolm: but does it matter that endian is defined like this:
04:08:00 <wagerlabs> data Endian a = Endian a ByteOrder deriving (Show, Eq, Ord)
04:08:05 <wagerlabs> malcolm: there's a byte order present
04:08:07 <ski> what types do you envisage passing as second argument ?
04:08:18 <wagerlabs> ski: data ByteOrder = BigEndian | LittleEndian deriving (Show, Eq, Ord)
04:08:21 <malcolm> wagerlabs: Yes, Endian takes only one type parameter - a.
04:08:28 <ski> wagerlabs : that is just one type
04:08:38 <wagerlabs> malcolm: but how do i plug in byte order?
04:08:41 <malcolm> wagerlabs: The other component (ByteOrder) is fixed, not a parameter
04:08:48 <ski> wagerlabs : if you only ever want to have one type as 'b' you don't need a second parameter
04:09:04 <wagerlabs> malcolm: so i can't do Endian 111 BigEndian?
04:09:16 <wagerlabs> i want to do Endian Big, etc.
04:09:17 <ski> hm
04:09:30 <ski> i just realized we might be talking past each other
04:09:37 <malcolm> wagerlabs: I think you are getting confused between datatype specification and value construction.
04:09:38 * ski was talking about the *type* Endian
04:09:53 <wagerlabs> malcolm: i could well be
04:09:54 <ski> wagerlabs : maybe you were talking about the *data constructor* Endian ?
04:09:56 <wagerlabs> i probably am
04:10:07 <wagerlabs> ski: i don't know what i was talking about, honestly
04:10:27 <ski> wagerlabs : maybe it'd be better, at least for now, if you named the type and the constructor differently ?
04:10:32 <malcolm> wagerlabs: It /is/ slightly confusing, because of the common habit in Haskell-land of naming the value-constructor identically to the type-constructor, but they really live in separate namespaces.
04:10:42 <wagerlabs> ski: how?
04:10:49 <wagerlabs> ok, let me step back
04:10:59 <wagerlabs> i have a block of memory
04:11:01 <ski> data Endian a = MakeEndian a ByteOrder -- or something similar
04:11:05 <wagerlabs> storables let me peek from that memory
04:11:24 <wagerlabs> so i want a Endian storable that takes the byte order
04:11:39 <malcolm> wagerlabs: I know what it is you are trying to do.  it is just the syntax that is a little but wrong
04:11:52 <wagerlabs> i'm willing to correct it! :D
04:11:53 <ski> (or confused)
04:12:04 <wagerlabs> malcolm: so where do i start?
04:12:35 <malcolm> wagerlabs: OK, so data Endian a = ... declares a type name, parameterised on any type a
04:12:54 <wagerlabs> malcolm: ok, sure
04:13:12 <wagerlabs> malcolm: it has to be one of those suitable for Storable, though
04:13:27 <wagerlabs> malcolm: "a" has to be
04:13:32 <beschmi> wagerlabs: how do you intend peek to work? you pass it eg. a Ptr (Endian Int32), in which byte order should it read the int? always in LittleEndian?
04:13:36 <malcolm> wagerlabs: and the RHS, ... = Endian a ByteOrder declares the way you can construct a value of that type, namely by putting an 'a' and a ByteOrder together, with a tag 'Endian'
04:13:59 <ski> beschmi : in the byteorder stored, methinks he wants
04:14:11 <wagerlabs> beschmi: it would need to be Ptr (Endian Int32 BigEndian) or Ptr (Endian Int32 LittleEndian)
04:14:11 <malcolm> wagerlabs: So, in type signatures and instance heads, you need to use the type expression Endian a
04:14:43 <ski> wagerlabs : now you're confusing types and values
04:14:45 <malcolm> wagerlabs: but in value-level expressions, you need to use data constructions looking like Endian a b
04:15:15 <wagerlabs> ski: allright, i see that i am.
04:15:17 <malcolm> wagerlabs: in the type signature of 'castAway', you have Endian a b, but it should be Endian a.
04:15:23 <beschmi> ok, i see what you're trying to do
04:15:26 <wagerlabs> malcolm: correcting
04:15:29 <ski> wagerlabs : as you have defined them, BigEndian,LittleEndian are values (constructors, in fact) of type ByteOrder
04:16:03 <wagerlabs> folks, could someone update the wiki?
04:16:25 <wagerlabs> cause while the individual bits all make sense, they are not coming together for me
04:16:26 <malcolm> wagerlabs: in the instance definition, I see the method 'peek' takes one value argument 'a', but tries to use 'b' on the RHS
04:17:09 <malcolm> wagerlabs: You probably mean the 'b' from the instance ... Storable (Endian a b), but that is actually a type variable, not a value variable.
04:17:20 <wagerlabs> malcolm: do you think you could update my @paste code?
04:18:03 <malcolm> wagerlabs: I was about to type it in here, but maybe the pastecode would be a better place.  I was looking at the version you posted to haskell-cafe actually.
04:18:10 <malcolm> @paste
04:18:11 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:18:20 <wagerlabs> malcolm: it should be the same version
04:18:44 * ski suggests renaming the data constructor to MakeEndian or MkEndian or something
04:19:03 <ski> (so we can discuss this easier without going insane ;)
04:19:43 <wagerlabs> the whole thing seems pretty simple conceptually. just add a flag to a storable, the byte order. if the byte order matches the host order then just use the storable function (peek, poke, etc) and otherwise use the reverse function.
04:19:59 <wagerlabs> the implementation turns out to be remarkably difficult :-) for a newbie at least
04:20:58 <malcolm> ski: good idea, I'll rename the data constructor so it looks different from the type constructor.
04:21:21 <ski> thank you
04:21:46 * ski is not so fond of that style anyway
04:22:19 <wagerlabs> and i have yet to get to threads and Concurrent Haskell
04:22:55 <wagerlabs> for the benefit of folks who weren't here yesterday, i'm trying to write a simulation environment to thoroughly test a wintel poker server that has intermittent memory corruption
04:23:17 <wagerlabs> the customer wants me to be able to launch at least 40k players that run through scripts
04:23:33 <wagerlabs> i was gonna do this in erlang (easy) but customer does not want his qa techs to learn erlang.
04:23:43 <thaldyron> Can anyone tell me how the performance of Parsec compares to bottom up parsers concerning long input (>100.000 lines) ?
04:23:53 <earthy> um
04:23:56 <earthy> 'it depends'
04:24:04 <earthy> on the grammar, to be exact
04:24:31 <wagerlabs> i suggested a scripting language but instead of writing an interpreter i think i can slip in haskell and make it look like a scripting language, doing commands like expect Some Games
04:25:27 <thaldyron> earthy: well it's grammatically tagged natural language
04:25:43 <earthy> the you're fucked both ways. :)
04:25:54 <thaldyron> lol
04:25:55 <earthy> natural language is *hard* to parse quickly
04:25:57 <malcolm> wagerlabs: see the pastebot for my attempt to fix your code.
04:26:02 <wagerlabs> looking
04:26:34 <earthy> and the only stuff I know that actually gets reasonable performance is stuff like AGFL (@ http://www.cs.ru.nl/agfl/ )
04:26:34 <wagerlabs> malcolm: let me try to compile that
04:26:50 <malcolm> wagerlabs: I don't recall the signatures for poke (and variations), so it may still need some tweaking
04:27:41 <ralejs> thaldyron: I suggest you check out Peter Ljunglöf's papers. He's been doing some natural language parsing and compared some parsing libraries. http://www.cs.chalmers.se/~peb/pubs.html
04:27:41 <wagerlabs> still doesn't work
04:27:44 <wagerlabs> Endian.hs:36:10:
04:27:44 <wagerlabs>     Couldn't match `Ptr (Endian a)' against `Endian a1'
04:27:44 <wagerlabs>       Expected type: Ptr (Endian a)
04:27:45 <wagerlabs>       Inferred type: Endian a1
04:27:50 <shapr> @type Foreign.poke
04:27:51 <lambdabot> forall a.
04:27:51 <lambdabot> (Foreign.Storable.Storable a) =>
04:27:51 <lambdabot> GHC.Ptr.Ptr a -> a -> IO ()
04:27:59 <thaldyron> earthy: thanks for the link
04:28:48 <ski> 'peek (MkEndian a b) =' ...
04:29:11 <malcolm> wagerlabs: yeah, OK, so poke expects a Ptr as its first argument, but you are pattern-matching on a MkEndian instead.
04:29:26 <wagerlabs> malcolm: umm... and the solution is?
04:29:32 <malcolm> wagerlabs: Shall I fix the paste?
04:29:35 <ski> peek takes not something of type 'Endian a' but something of type 'Ptr (Endian a)'
04:29:37 <wagerlabs> please!
04:29:47 <wagerlabs> malcolm: please do
04:31:02 <ski> peek ptr = do storedByteOrder <- peekByteOff ptr someOffset; if storedByteOrder == hostByteOrder then ... else ...
04:31:17 <malcolm> @type pokeByteOff
04:31:19 <lambdabot> bzzt
04:31:35 <ski> peekByteOff :: Storable a => Ptr b -> Int -> IO a
04:31:45 <malcolm> @type Foreign.pokeByteOff
04:31:46 <lambdabot> forall a b.
04:31:46 <lambdabot> (Foreign.Storable.Storable a) =>
04:31:46 <lambdabot> GHC.Ptr.Ptr b -> Int -> a -> IO ()
04:32:08 <ski> pokeByteOff :: Storable a => Ptr a -> Int -> a -> IO ()
04:32:10 <ski> ya
04:32:45 <ski> wagerlabs : something along that line, i think
04:33:16 <malcolm> wagerlabs: OK, try that
04:33:23 <wagerlabs> let me see
04:34:02 <wagerlabs> malcolm: the paste looks the same to me
04:34:10 <ski> (also, i'm not sure your castAway works ..)
04:34:50 <ski> (you might have to add some offset and/or force some thunks)
04:34:52 <wagerlabs> ski: it might not work allright
04:34:54 <malcolm> wagerlabs: Hmm, I edited my previous entry, rather than adding a new one.
04:35:15 <malcolm> wagerlabs: need to press 'reload'?
04:35:21 <wagerlabs> ski: because of the added byte order?
04:36:18 <malcolm> ski: I don't think any extra offset is needed - the byteorder tag is not being stored in memory
04:36:20 <ski> no, i don't think so .. hopefully the byteorder gets added after the other part
04:36:36 <ski> byteorder is sure stored in memory
04:36:47 <ski> question is if MkEndian tag is stored in mem
04:36:59 <wagerlabs> malcolm: no change
04:37:33 <wagerlabs> malcolm: maybe i'm not looking in the right place. what changed?
04:37:41 <malcolm> wagerlabs: Ah, Now i go in to edit it again, it says there are edit conflicts, even though it previewed just fine last time.
04:38:07 <ski> wagerlabs : press the 'glasses' icon to see last changes
04:38:29 <ski> (top left of page)
04:38:36 <ski> s/left/right/
04:39:06 <wagerlabs> no changes to peek, some changes to poke
04:41:08 <malcolm> wagerlabs: right, added a new version.  Yes, changes to poke only.
04:41:52 <wagerlabs> malcolm: but i still had problems with peek
04:41:59 <wagerlabs> malcolm: let me try your latest version
04:42:14 <malcolm> Oh, I didn't realise there were still problems with peek
04:42:49 <wagerlabs> malcolm: try compiling the code ;)
04:43:18 <wagerlabs> i'm looking for alternatives if you folks have any
04:43:34 <malcolm> wagerlabs: it's too painful cutting and pasting from the IRC machine to the one with the compiler...
04:43:54 <wagerlabs> NewBinary looked good until i realized that i would need to change all the functions get/put to read little-endian :(
04:43:55 <malcolm> wagerlabs: anyway, must dash, back in an hour or so
04:44:02 <wagerlabs> plus there's no float support in NewBinary
04:44:06 <wagerlabs> malcolm: thanks for your help!
04:44:43 <MarcWeber> How do you start some other programs from haskell? I know there is hsshellscript, but it's blocked by ghc-6.4. (I'm using gentoo) Do you use another compiler (version) or another way?
04:45:49 <ski> @type System.system
04:45:51 <lambdabot> String -> IO GHC.IOBase.ExitCode
04:45:51 <ski> ?
04:46:02 <wagerlabs> argh
04:46:15 <wagerlabs> should i just give up on haskell?
04:46:57 <ski> maybe you need more time to get familiar with the lang ?
04:47:12 <ski> (or find someone who's more fluent with the FFI)
04:47:16 <wagerlabs> ski: that too but... if experts can't figure this out...
04:47:26 <wagerlabs> it's not even an issue with ffi i think
04:47:27 * ski is not an expert
04:47:34 <wagerlabs> but i might well be wrong
04:47:38 <ski> peek and poke are FFI stuff
04:47:47 <wagerlabs> yes
04:48:42 <Akshaal> wagerlabs: just implement peek/poke as i mentioned, implement additional toBig, toLittle... and life will be much easy with IO you want
04:49:25 <wagerlabs> Akshaal: let me revisit your suggestion...
04:50:43 <wagerlabs> Akshaal: you mean this: peek a = do {d = peek a; return $ Endian d getHostByteOrder
04:51:35 <Akshaal> yes, yes
04:52:13 <Akshaal> toBig $ peek ptr
04:52:28 <Akshaal> toLittle $ peek ptr
04:52:49 <ski> aha
04:53:07 <ski> toCurrent $ peek ptr   ?
04:53:21 <wagerlabs> Akshaal: i don't think it's gonna work... trying to think why... i need to store the byte order in the fields themselves and have them return me the proper values
04:53:26 <wagerlabs> in host order
04:53:48 <Akshaal> oh
04:53:51 <wagerlabs> Akshaal: unless the peek you are talking about should be part of instance of storable
04:54:05 <wagerlabs> Akshaal: where field is part of a packet definition
04:54:36 <Akshaal> ok
04:54:42 <Akshaal> then
04:55:02 <wagerlabs> Akshaal: your suggestion just returns an Endian with the host byte order, no conversion
04:55:21 <Akshaal> first you need to peek endiennes from pointer
04:55:31 <wagerlabs> Akshaal: how?
04:55:42 <ski> peekByteOff ptr someOffset
04:55:46 <Akshaal> then you need to peek value from pointer plus size of endiannes value
04:56:05 <wagerlabs> Akshaal: but is byteorder actually stored as part of the data? or not?
04:56:12 <ski> Akshaal : endianess comes after the other part, in his definition
04:56:16 <wagerlabs> assuming this
04:56:17 <wagerlabs> data ByteOrder = BigEndian | LittleEndian deriving (Show, Eq, Ord)
04:56:17 <wagerlabs> data Endian a = MkEndian a ByteOrder deriving (Show, Eq, Ord)
04:57:11 <Akshaal> peek ptr = do {e <- peek ptr; b <- peekOff ptr (size e); ...)
04:57:25 <Akshaal> mmm
04:57:33 <ski> need as cast, too  i think
04:57:38 <ski> s/as/a/
04:58:30 <Akshaal> if endiannes comes after the other part, then swap e and b in my definiton
04:58:41 <wagerlabs> can we take a different tack for a second
04:59:08 <ski> Akshaal : but he wants to use endianess to determine how to peek the other part
04:59:50 * Akshaal sighs
05:00:32 <ski> e <- peekOff ptr (size ..)
05:01:33 <ski> hm
05:02:08 <ski> how will 'peekByteOff a 0' reverse the endianess ?
05:02:30 <ski> (in 'peekR', i.e.)
05:03:25 <ski> hi, JaffaCak1 : do you know how to handle endianess in a sane way ?
05:03:30 <JaffaCak1> dcoutts: I'm failing to build hIDE
05:03:46 <Akshaal> peek ptr = do {order <- peekOff $ size (undefined :: retVal); if order = current then peek ptr else peekR ptr}
05:03:49 <JaffaCak1> ski: haven't been reading the h-cafe discussion, sorry
05:04:24 <ski> Akshaal : something like that could work ..
05:04:30 <Akshaal> peek :: Ptr a -> IO retVal
05:04:40 * JaffaCak1 wonders why his nick has changed
05:04:50 <ski> we need to capture retVal
05:05:53 <dcoutts_> JaffaCake!
05:06:00 <JaffaCake> ah, that's better
05:06:10 <ski> one way is do define a function   'foo :: Ptr (Endian a) -> a; foo = undefined'  and then do 'size (foo ptr)'
05:06:11 <dcoutts_> so what's the build problem?
05:06:27 * JaffaCake can't cut-n-paste from laptop to desktop :(
05:06:34 <ski> Akshaal : see what i mean ?
05:06:49 <JaffaCake> "Module Graphics.UI.Gtk' does not export 'AttrOp((:=))"
05:07:01 <JaffaCake> I guess a version problem with gtk
05:07:04 <dcoutts_> JaffaCake, ah yeah you need the latest version of Gtk2Hs
05:07:20 <JaffaCake> then I have a request: can you guys put proper version dependencies on your packages?
05:07:26 <Akshaal> we can capute it from signature of peek
05:07:30 <dcoutts_> darcs get http://haskell.org/gtk2hs/darcs/gtk2hs
05:07:31 <Akshaal> capture
05:07:43 <ski> Akshaal : maybe
05:07:44 <dcoutts_> JaffaCake, hmm I thought it did depend on gtk >= 0.9.9.5
05:08:13 <JaffaCake> it's the commonSense package, doesn't have any versions
05:08:18 <dcoutts_> ah ok
05:08:37 <dcoutts_> you're quite right it should
05:08:52 <JaffaCake> thanks, that would help
05:09:00 <dcoutts_> we'venot paid much attention to it being easy to build yet
05:09:12 <JaffaCake> you are in a maze of twisty version dependencies, all alike
05:09:20 * dcoutts_ grins
05:09:56 * JaffaCake disappears to get lunch
05:09:58 <dcoutts_> part of the problem is that it needs the latest bug fixes & improvements in several dependent packages
05:10:14 <dcoutts_> and they're fixes added as a result of hIDE development
05:10:38 <dcoutts_> so when we do an actual hIDE release we'll make sure there are released versions of the dependent packages too
05:16:41 <Akshaal> @hoogle IO a -> IO ()
05:16:43 <lambdabot> Prelude.print :: Show a => a -> IO ()
05:16:43 <lambdabot> Prelude.log :: Floating a => a -> a
05:16:43 <lambdabot> Prelude.atan :: Floating a => a -> a
05:17:13 <basti_> Akshaal: what are you trying to do?
05:17:38 <Akshaal> ignore result of computation
05:17:46 <Akshaal> like ocaml's ignore function
05:18:00 <dcoutts_> foo >> return ()
05:18:25 <Akshaal> tnx
05:18:56 <lightstep> loging in to sequence doesn't work without cookies
05:20:38 <ski> fun type : 'Stream a -> ([a] -> o) -> Stream o'
05:20:51 <b0gg1e> how do I do character encoding conversion in ghc?
05:20:59 <b0gg1e> (e.g. read utf8 from a file)
05:22:14 <ibid> anybody here familiar with Gtk2HS?
05:22:20 <dcoutts_> ibid, wrote it :-)
05:23:15 <wagerlabs> how do you convert a sequence of bytes [Word8] into a Float?
05:23:16 <lightstep> @index Data.Unicode
05:23:17 <lambdabot> bzzt
05:23:18 <ibid> ok.  how is gcSetValues supposed to work?
05:23:51 <ibid> it is missing the mask parameter from the C API, and i can't figure out what the source is doing
05:24:16 <ibid> the two ways of using it that i tried both failed
05:24:21 <dcoutts_> ibid, Gtk.gcSetValues gc Gtk.newGCValues { Gtk.foreground = colour }
05:24:52 <dcoutts_> where Gtk.Color (floor (r * 2^16)) (floor (g * 2^16)) (floor (b * 2^16))
05:25:13 <dcoutts_> assuming r,g,b are floating point values in the range [0,1]
05:25:29 <ibid> ahh, they're 16-bit values
05:25:36 <dcoutts_> gdk colours are represented by 16bit values, yep
05:25:36 <ibid> hmm
05:26:09 <dcoutts_> oops "where colour = ..." etc
05:26:31 <ibid> hmm
05:26:47 <ibid> the docs say "A few of the values in the GC, such as the dash pattern, can only be set by the latter method." - but there's no latter method in that context
05:26:47 <dcoutts_> ibid, but if you don't have to use the gdk drawing api, then don't. Use cairo :-)
05:27:00 <ibid> dcoutts_: cairo is 2.8, right?
05:27:05 <ibid> can't assume that
05:27:13 <dcoutts_> ok, fair enough
05:28:37 <ibid> so, i can't give gcSetValues the result of gcGetValues, modified?
05:29:09 <{Arias}> hi!
05:29:11 <dcoutts_> it only updates the ones you change
05:29:25 <dcoutts_> ibid, oh and for the dash you can use gcSetDashes
05:29:44 <malcolm> wagerlabs: have you sorted your peek problem yet?
05:29:53 <wagerlabs> malcolm: not at all
05:30:02 <Lemmih> dcoutts_: I think we should use 6.5 from now on.
05:30:05 <dcoutts_> ibid, so in the example above it doesn't reset all the falues other than foreground, rather it only updates the foreground
05:30:09 <dcoutts_> Lemmih, oh?
05:30:23 <dcoutts_> falues/values
05:30:24 <wagerlabs> malcolm: i'm thinking that maybe the whole ffi thing is too complex. i'm looking at NewBinary now to see if it can be coopted to do what i need
05:30:26 <malcolm> wagerlabs: I was thinking that really you have a conceptual problem here, not a Haskell one as such
05:30:30 <wagerlabs> malcolm: are you familiar with NewBinary?
05:30:33 <ibid> i get a BadPixmap X error if i try to use the result of gcGetValues
05:30:48 <malcolm> wagerlabs: I wrote the original Binary that NewBinary is based on
05:30:56 <wagerlabs> malcolm: oh, wow
05:31:14 <dcoutts_> ibid, I'm not sure what's going on there, but you probably don't need gcGetValues
05:31:31 <ibid> (the gc was originally created by gcNew)
05:31:33 <wagerlabs> malcolm: so NewBinary reads bytes in particular order and assembles things
05:31:35 <malcolm> wagerlabs: Anyway, I need to think again about what is stored where, in what format.
05:31:36 <{Arias}> one question, a good compiler for windows??
05:31:38 <dcoutts_> it only updates the ones you sepcify, all the others are left unchanged, rather than reset
05:31:43 <Lemmih> JaffaCake: Hi. Got some code for me?
05:31:53 <malcolm> {Arias}: yhc?
05:31:56 <wagerlabs> malcolm: so i thought i could just read bytes in a different order if needed
05:31:58 <dcoutts_> Lemmih, JaffaCake is probably still at lunch
05:32:02 <{Arias}> let's see x)
05:32:04 <ibid> dcoutts_: i'm currently using it also to reset the original values
05:32:14 <JaffaCake> dcoutts: back
05:32:17 <malcolm> The problem is, how do you know what order the bytes are stored in, before you read them
05:32:19 <wagerlabs> malcolm: but this does not fly instance (Binary Word32) => Binary (Endian Word32) where
05:32:24 <wagerlabs> malcolm: i know this
05:32:36 * dcoutts_ thinks JaffaCake should be more leisurly with his lunch
05:32:44 <JaffaCake> Lemmih: sure, hang on a tick
05:32:47 <wagerlabs> malcolm: i know in advance the order the bytes are stored in. what i do not know (determine with TH) is the order of the host platform
05:32:48 <ibid> dcoutts_: so using it as the base of modification just seems natural
05:32:56 <wagerlabs> malcolm: the platform where i'm running
05:33:19 <dcoutts_> ibid, yeah, to be honnest I don't like the way we've wrapped that C API in Haskell.
05:33:21 <malcolm> OK, so you want to 'peek' from a known byte order, yes?
05:33:50 <wagerlabs> malcolm: ultimately, i want to compose a packet of fields and say this packet is little endian, for example. alternatively, i can say for each field in the packet that they are little-endian
05:34:18 <ibid> dcoutts_: no problem, i'm just writing a SOEGraphics-style wrapper for use in class :)
05:34:29 <dcoutts_> ibid, oh cool! We want that. :-)
05:34:31 <malcolm> wagerlabs: I see, so you are on a host platform of unknown endianness, and you are trying to create a specific endianness of data to send over the network.
05:34:36 <wagerlabs> malcolm: i just want to convert to host order from a known byte order. the complication is that i might be on the same byte order as the packet in which case the conversion should just return the same value
05:34:43 <dcoutts_> ibid, I was thinking of doing it using cairo.
05:34:52 <wagerlabs> malcolm: correct. sent and received.
05:34:55 <dcoutts_> but that's not possible for you, like you said
05:35:03 <wagerlabs> malcolm: and i know the endianness of my host platform with this bit of code
05:35:08 <wagerlabs> isBigEndian = $(lift $ (1::CChar) /= (unsafePerformIO
05:35:09 <wagerlabs>                                      $ with (1::CInt)
05:35:09 <wagerlabs>                                      $ peekByteOff `flip` 0) ) :: Bool
05:35:14 <ibid> dcoutts_: i also get the error if i use a modified version of the return value of newGCValues
05:35:17 <pitecus> Is it possible to introduce function definition in the hugs shell?
05:35:20 <malcolm> wagerlabs: Are you sure you want to convert /to/ host order?  I thought you wanted to convert to specified order
05:35:45 <dcoutts_> ibid, yeah, to be honnest I'm running a practical this term using Gtk2Hs and I've had to avoid cairo too since the lab machines don't have sufficiently up to date software.
05:35:45 <JaffaCake> Lemmih: check your inbox
05:35:56 <dcoutts_> ibid, ok what are you doing exactly?
05:35:57 <Lemmih> JaffaCake: Thanks.
05:36:01 <ski> pitecus : local ones, surely ... let f x = x + 1 in map f [0,1,2]
05:36:11 <wagerlabs> malcolm: i'm writing a bot that will connect to a wintel server. the server sends everything little-endian, the bot could be running on big or little endian. to understand the values sent by the server the bot needs to convert them to its host byte order
05:36:16 <wagerlabs> malcolm: right?
05:36:36 <JaffaCake> Lemmih: you'll need to use memcpy or something instead of bstrToStringLen()
05:36:52 <dcoutts_> ibid, btw would you mind sending us what code you come up with in the end for the SOE interface. I'd really like to distribute an SOE api with Gtk2Hs.
05:36:55 <wagerlabs> malcolm: by the same token the bot could be connecting to a big-endian server that sends everything big-endian
05:36:59 <pitecus> ski, I meant to define a function and use it later on, not in the same expression.
05:37:01 <ibid> dcoutts_: i'll darcsify this so you can take a look in a minute
05:37:10 <ski> pitecus : no, not possible
05:37:25 <ski> (pitecus : in hugs, i.e.  in ghci it works)
05:37:33 <pitecus> OK
05:37:37 <wagerlabs> malcolm: NewBinary seems easier to comprehend to me. at least when they do things like this
05:37:39 <ibid> dcoutts_: please don't laugh too hard at my code.  i am not a haskell novice but this *is* my first gtk2hs code :)
05:37:48 <dcoutts_> ibid, no problem
05:37:50 <wagerlabs> instance Binary Word16 where
05:37:50 <wagerlabs>   put_ h w = do -- XXX too slow.. inline putWord8?
05:37:50 <wagerlabs>     putByte h (fromIntegral (w `shiftR` 8))
05:37:50 <wagerlabs>     putByte h (fromIntegral (w .&. 0xff))
05:37:53 <wagerlabs>   get h = do
05:37:55 <wagerlabs>     w1 <- getWord8 h
05:37:55 * boegel farts loudly
05:37:58 <wagerlabs>     w2 <- getWord8 h
05:38:00 <wagerlabs>     return $! ((fromIntegral w1 `shiftL` 8) .|. fromIntegral w2)
05:38:01 <boegel> woops, wrong channel
05:38:31 <dcoutts_> boegel! be gone with you! back to #haskell-blah
05:38:56 <wagerlabs> malcolm: so i could use NewBinary but then i would need to somehow create Endian wrappers around Win32, Word64, etc. seems like a lot of code
05:38:57 * dcoutts_ grumbles about the declining standards of behaviour in the youth of today
05:39:00 <malcolm> wagerlabs: are the shiftL and shiftR operations independent of byte order?
05:39:19 * boegel farts again
05:39:25 <wagerlabs> malcolm: no idea :) i assume they just use whatever the host order is
05:39:34 <wagerlabs> malcolm: of the platform where the shifts are running
05:39:36 * dcoutts_ holds his nose
05:39:39 <malcolm> wagerlabs: that's what I meant.
05:39:44 <wagerlabs> malcolm: i assume they are independant
05:40:32 <malcolm> wagerlabs: is 1234 `shiftR` 8 == 0123 or 1230 ?
05:40:47 <wagerlabs> malcolm: but it also seems that to implement the endian wrapper on top of NewBinary i would need to basically write new instances of all the primitive types that NewBinary handles
05:41:09 <wagerlabs> malcolm: i would assume it's 0123. i haven't checked
05:41:29 <JohnMeacham> anyone have some nice ascii histogram drawing code?
05:41:33 <malcolm> wagerlabs: If the pattern for the wrappers is regular, you could write a cpp-macro to do it :-)
05:41:35 <ibid> dcoutts_: http://antti-juhani.kaijanaho.info/darcs/jyugraphics/
05:41:41 <ibid> dcoutts_: it is by no means complete :)
05:41:57 <wagerlabs> malcolm: anyway, i'm looking for suggestions
05:42:06 <wagerlabs> malcolm: actual code would be better
05:42:19 <yaarg> of course you can do it in haskell :)
05:42:59 <malcolm> wagerlabs: actually, the other option should have been 0123 or 2340.  I mean the byte ordering, not the actual number  (1234 = littleendian, 4321 = bigendian)
05:44:13 <wagerlabs> malcolm: that's cool. does it solve the problem?
05:44:39 <tomshackell> is the binary stuff based internally on C shifts?
05:44:51 <dcoutts_> ibid, ok got the code. Which bit is being problematic?
05:44:57 <wagerlabs> malcolm: in the following, does ByteOrder actually take memory space?
05:44:58 <wagerlabs> data ByteOrder = BigEndian | LittleEndian deriving (Show, Eq, Ord)
05:44:59 <wagerlabs> data Endian a = MkEndian a ByteOrder deriving (Show, Eq, Ord)
05:45:18 <malcolm> tomshackell: Yes, it was in the original Binary, dunno about NewBinary
05:45:40 <boegel> ibid: what does it do ?
05:45:44 <ibid> dcoutts_: darcs pull it, i fixed a compilation error i didn't notice (damn runghc executed it despite a compilation error, apparently using old compilation output)
05:45:57 <tomshackell> malcolm: ah.
05:45:59 <ibid> dcoutts_: and then runghc Test.hs, it fails for me
05:46:13 <malcolm> wagerlabs: Well those are type declarations - there are no values stored in that fragment of code.
05:47:10 <wagerlabs> malcolm: and i understand that. i'm talking about when you construct the type
05:47:11 <ibid> dcoutts_: the offending code is in withColor
05:47:12 <malcolm> wagerlabs: But a value like MkEndian 0 LittleEndian, yes there is a tag in memory corresponding to the ByteOrder value LittleEndian.
05:47:20 <ibid> boegel: what's "it" in this case? :)
05:47:53 <malcolm> wagerlabs: It depends on how clever the compiler is as to how much space it takes.
05:48:09 <wagerlabs> @paste
05:48:10 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:50:17 <tomshackell> malcolm: did you get my link to the cvs?
05:50:23 <ibid> dcoutts_: can you reproduce it?
05:50:31 <Lemmih> JaffaCake: Ah. I wrote the same code but accidentally mistook 'memcpy_ptr_baoff' for 'memcpy_baoff_ptr' (:
05:50:38 <malcolm> wagerlabs:  On reflection, I think NewBinary might be the easier route than Storable.
05:51:08 <malcolm> tomshackell: nope, not yet
05:51:47 <wagerlabs> malcolm: lots of code, though
05:51:56 <malcolm> wagerlabs: yeah.
05:52:03 <dcoutts_> ibid, yep, and here's a fix:
05:52:04 <wagerlabs> malcolm: no? i would need to duplicate the reading and writing of primitives in reverse order
05:52:04 <dcoutts_>                               Gtk.gcSetValues gc
05:52:04 <dcoutts_>                                   Gtk.newGCValues { Gtk.foreground = Gtk.foreground v }
05:52:07 <tomshackell> malcolm: cvs -d /usr/shackell/cvs checkout yhc
05:52:12 <boegel> ibid: the link you gave dcoutts, the jyugraphics stuff
05:52:14 <wagerlabs> malcolm: can you take a look at paste again, please
05:52:17 <dcoutts_> instead of Gtk.gcSetValues gc v
05:52:56 <Akshaal> wagerlabs: wait a bit, I will try to write it for you
05:52:59 <malcolm> tomshackell: cool. its checking out now
05:53:21 <dcoutts_> ibid, I don't quite know what's wrong with that API. I inherited that one. It's not nicely designed. Sorry about that.
05:53:25 <wagerlabs> malcolm: that's the code that Cale wrote yesterday, basically. the stuff i was fighting with today was an ttempt to streamline Cale's code since for LittleEndian it would look the same with the exception of a few characters where "if not be ..." is concerned
05:53:32 <ibid> dcoutts_: i'm lazy.  can you darcs send that? :)
05:53:38 <dcoutts_> ibid, yep
05:53:51 <wagerlabs> Akshaal: which version? cale's? i just posted another one on paste where the runtime representation does not include the byte order tag
05:54:22 <ibid> boegel: as i said earlier, it's a SOEGraphics-style wrapper for Gtk2HS for use in a course i'm going to give in a few weeks
05:54:54 <ibid> dcoutts_: i can work with a bad api, but it better be documented ;)
05:54:56 <dcoutts_> ibid, sent, tell me if it arrives ok, I'm slightly suspicious of my local mail setup
05:55:09 <wagerlabs> my attempt at optimization turned out to be more difficult than expected
05:55:09 <boegel> ibid: never heard of SOEGraphics, enlight me :)
05:55:30 <ibid> dcoutts_: though i understand if that particular one is not one of your priorities, given cairo :)
05:55:45 <ibid> boegel: it's the graphics library used in the multimedia book
05:55:57 <dcoutts_> ibid, the proper way to fix it is to change the API to make it use properties
05:56:16 <malcolm> wagerlabs: hmm, yes I see what Cale's code is trying to do now.  I was a bit puzzled before on the mailing list, because I assumed the BigEndian type was trying to hold all endianness information.  But it isn't, it is just a simple wrapper to indicate /one/ of the options, and as you say they should be a corresponding LittleEndian type.
05:56:29 <boegel> ibid: oh, okay
05:56:35 <ibid> dcoutts_: not yet
05:57:00 <malcolm> wagerlabs: it's actually quite a neat idea
05:57:10 <ibid> dcoutts_: if it just replicated the C API, it'd be easier to work with, but it has some deep magic that omits the mask...
05:57:16 <wagerlabs> malcolm: right. not think of how you would do little endian. you would just duplicate that code, right? so i thought why not add a byte order tag and have a single piece of code for big and little endian that just compares the tag with the host byte order
05:57:23 <wagerlabs> malcolm: do you see where i'm coming from?
05:57:28 <dcoutts_> ibid, yeah and it doesn't do it in an obvious way
05:57:28 <malcolm> wagerlabs: but has some syntax problems just like the other code I looked at earlier
05:57:47 <wagerlabs> malcolm: that code actually compiles (cale's), so no syntax problems
05:58:00 <dcoutts_> ibid, I thought it was ugly when I first saw it :-)
05:58:07 <ibid> boegel: i'm not following strictly the book, so i'm not calling it (yet another) SOEGraphics :)
05:58:12 <ibid> dcoutts_: heh
05:58:22 * ibid should look at packaging that beast again
05:58:32 <malcolm> wagerlabs: Ah but...  The key thing is that with /two/ types, BigEndian and LittleEndian, you can just label which one you want, and the type system chooses the right instance. Whereas with a single type, you
05:58:43 <ibid> dcoutts_: no mail yet
05:58:43 <dcoutts_> ibid, so are you trying to replicate the SOEGraphics API exactly?
05:58:51 <malcolm> can only distinguish Little and Big at the /value/ level, not the type level.
05:59:13 <ibid> dcoutts_: i'm trying to avoid gratuitous differences, but if i find something hard to implement, i might deviate
05:59:16 <wagerlabs> malcolm: true
05:59:56 <malcolm> wagerlabs: re: compile problems, yes you are right - I didn't read it carefully enough and assumed it was more similar to the previous stuff than it really is.
06:00:58 <ibid> dcoutts_: however, if there's wider interest, i might change that policy to strict adherence to the API :9
06:01:21 <malcolm> wagerlabs: At the value-level, you don't know whether you are expecting little or big endian, unless you can pass in a parameter to tell it.  But at the type-level, you don't need to pass a parameter, just give the signature you want.
06:02:02 <wagerlabs> malcolm: i think i just learned an important lesson
06:02:12 <malcolm> wagerlabs; what's that?
06:02:15 <wagerlabs> malcolm: i'll just go with cale's approach then and do the types
06:02:53 <malcolm> wagerlabs: Now I understand Cale's solution, I think it is better than using NewBinary.  Much less code for one thing.
06:03:08 <wagerlabs> yu[
06:03:24 <ibid> dcoutts_: received mail
06:03:40 <dcoutts_> ibid, ok great. (I had to fix my local mail setup)
06:03:47 <wagerlabs> malcolm: it's also in line with the solution posted to the list
06:04:10 <malcolm> wagerlabs: But there is one stumbling block ahead - when does your program decide what byte ordering is coming in/ going out to/from the server?
06:04:10 <dcoutts_> ibid, I notice there might be difficulties with the main loop interaction
06:04:36 <wagerlabs> malcolm: at runtime
06:05:00 <malcolm> wagerlabs: OK, so it reads a few bytes of data and then decides which ordering it is getting?
06:05:00 <ibid> dcoutts_: hmm?
06:05:09 <ibid> dcoutts_: thanks. the patch fixed it
06:05:13 <wagerlabs> malcolm: actually, i will already know this. for the app that i'm working on the byte ordering of data going to/from the server is always gonna be little-endian
06:05:13 <dcoutts_> ibid, eg you run mainGUI some times but mainIteration other times
06:05:23 <ibid> dcoutts_: how is that a problem?
06:05:27 <wagerlabs> malcolm: so it's compile-time, not even runtime
06:05:47 <wagerlabs> malcolm: thanks for your help. i'll step away for lunch
06:05:53 <malcolm> wagerlabs: OK, then there will be no problem.
06:05:57 <dcoutts_> ibid, Gtk usually likes to be in control, running it's main loop. (Though that's not the only way to use it)
06:06:01 <malcolm> wagerlabs: bon appetit
06:06:04 <ibid> that's true
06:06:12 <dcoutts_> ibid, it depends on how the SOEGrahpics expects it to work
06:06:31 <ibid> dcoutts_: but the feeling i got from SOEGraphics is that it's not an event system, it has the control
06:06:38 <dcoutts_> ibid, right
06:06:54 <dcoutts_> ibid, so they draw graphics onto the screen. Is that supposed to be persistent? or do they handle redrawing themselves?
06:07:37 <ibid> dcoutts_: so the main loop is run only when inside a JyuGraphics function; i use iteration when i just want to process the events that my previous code had generated, and mainGUI when i'm waiting for user input
06:07:50 <ibid> dcoutts_: it seems to assume persistency
06:07:59 <ibid> dcoutts_: and that's how i've written it
06:08:42 <ibid> dcoutts_: if you have time, could you figure out what's wrong with the commented-out line labelled with Gtk-CRITICAL
06:10:13 <dcoutts_> ibid, so each window has a persistent graphics object associated with it which gets run when the window recieves an expose event
06:10:18 <ibid> yeah
06:10:37 <dcoutts_> and drawInWindow justs adds to that graphics object (which is just an IO () action)
06:11:00 <ibid> i debated with myself whether to use a graphics buffer or a graphics action as the persistent thing
06:11:03 <ibid> dcoutts_: yeah
06:11:20 <ibid> dcoutts_: and schedules a redraw, and processes the event immediately :)
06:11:27 <dcoutts_> right
06:11:33 <thaldyron> is there a tool to convert .hs -> .lhs ?
06:12:05 <shocker> how can i parse a text file in haskell?
06:12:15 <ibid> it seems that the full SOE API allows the API user to determine which is used
06:12:16 <dcoutts_> @where parsec
06:12:17 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
06:12:19 <ibid> and i might at that later
06:12:24 <ibid> s/at/add/
06:12:35 <dcoutts_> ibid, which is used? between what and what?
06:12:42 <dcoutts_> ibid, you mean the double buffering?
06:12:44 <Lemmih> shocker: You can either use alex+happy or Parsec.
06:12:46 <ibid> yeah
06:12:51 <dcoutts_> ibid, I think that's just a hint.
06:12:57 <dcoutts_> ibid, Gtk+ can do either.
06:13:06 <ibid> ah, ok :)
06:13:10 <shocker> Lemmih: what are they?
06:13:28 <ibid> i was actually referring to my 16:10 line ("i debated with myself...")
06:13:40 <Lemmih> shocker: http://haskell.org/alex/ http://haskell.org/happy/
06:13:44 <shocker> ok thanks
06:14:14 <ibid> dcoutts_: if you get bright ideas or whatever, feel free to bug me :)
06:15:10 <dcoutts_> ibid, ok, I'm just looking over the SOE API
06:15:57 <dcoutts_> ibid, heh with cairo the polyBezier would be easy :-)
06:16:32 <ibid> ok :)
06:16:39 <dcoutts_> ibid, all the actual drawing stuff looks ok
06:16:51 <dcoutts_> ibid, it's the interaction model that is tricky
06:17:17 <Lemmih> dcoutts_: Are you able to run hIDE compiled with GHC 6.5?
06:17:36 <ibid> yeah, well, this is not intended for real-world programming ;)
06:17:57 <ibid> just to allow the use of bells and whistles while one is still learning
06:18:03 <dcoutts_> Lemmih, I've not tried it yet
06:18:11 <thaldyron> is there a tool to convert .hs -> .lhs ?
06:18:17 <dcoutts_> ibid, I might be tempted to use threads
06:18:24 <ibid> dcoutts_: why?
06:18:44 <dcoutts_> ibid, to catch and filter the events
06:19:09 <dcoutts_> ibid, ie run mainGUI in the main thread and post interesting events to another thread.
06:19:32 <ibid> dcoutts_: is it worth the effort?
06:19:36 <dcoutts_> ibid, then in the other thread it'd work in the more message processing style that the SOE model seems to assume
06:19:38 <Lemmih> dcoutts_: I'm getting weird segfaults.
06:19:39 <dcoutts_> ibid, not sure :-)
06:19:49 <dcoutts_> Lemmih, from the GUI?
06:21:51 <JohnMeacham> ▁▂▃▄▅▆▇▇▆▅▄▃▂▁▁▂▃▄▅▆▇▇▆▅▄▃▂▁
06:24:34 <lightstep> is that unicode?
06:24:50 <lightstep> i thought they only had languages
06:25:37 <dcoutts_> ibid, or an alternative might be to have a event source attached to each window in an MVar. Then getWindowEvent/maybeGetWindowEvent would take/tryTake that MVar and inspect it to see if it's the kind of event it's interested in.
06:25:44 * boegel sees two boobies passing
06:26:01 <boegel> y0 CosmicRay
06:26:02 <basti_> boegel: dcc pics
06:26:18 <dcoutts_> ibid, then when setting up each window, you install event handlers to fill the current event MVar when ever that event occurs.
06:26:24 <boegel> any c guru's in here ? I'm having trouble with compiling some benchmarks
06:26:33 <CosmicRay> morning boegel
06:26:42 <boegel> afternoon CosmicRay :)
06:27:26 <CosmicRay> boegel: according to my great grandfather, American Central Standard Time is "God's time", so there ;-)
06:27:37 <shapr> JohnMeacham: what the heck was that?
06:27:39 <CosmicRay> he refused to change his clocks for daylight saving time for that reason.
06:27:48 <dcoutts_> ibid, so you think the window only 'runs' when waiting for events (ie getKey, getLBP, getWindowEvent etc).
06:28:11 <Lemmih> dcoutts_: hIDE segfaults after the static core has ended (yes, really) and when I try to load hide-HaskellSense.
06:28:27 <shapr> thaldyron: it's easy to convert to lhs, just rename the file and put "> " in front of all the existing code lines.
06:28:59 <dcoutts_> Lemmih, hmm I'll not be able to build it myself 'til Sunday night or Monday. I'm away this weekend.
06:29:12 <dcoutts_> Lemmih, I suggest sticking with 6.4.1 for the moment :-)
06:29:46 <dcoutts_> Lemmih, or using gdb to see which lib is crashing (ie if it's ghc or gtk+)
06:30:00 <shapr> CosmicRay: Man, I had something to ask you... but I forget what.
06:30:37 <Lemmih> dcoutts_: It crashed even if I only load hide-base.
06:30:42 <CosmicRay> shapr: something about the beauty contest?
06:30:56 <CosmicRay> shapr: pages are going to go up today, I hope.
06:31:04 <shapr> ah cool!
06:31:10 <CosmicRay> shapr: the repo is ready now.
06:31:13 <shapr> I don't know... I think it was something else actually.
06:31:26 <CosmicRay> shapr: and the benchmarks are working.  I just need to get them set up on a 32-bit machine and run them.
06:31:27 <boegel> CosmicRay: heh
06:31:43 <shapr> Oh hey
06:31:53 <shapr> I had another ShootOut variation idea that would show Haskell favorably
06:31:54 <CosmicRay> boegel: to be fair, I am not entirely sure that he was aware that the entire world did not use central standard time ;-)
06:31:58 <CosmicRay> oh?
06:32:37 <shapr> I wanted a series of tests that measured how well a single program scaled from one to many CPUs.
06:33:15 <shapr> Amusingly Skaller immediately said something like "We don't have any languages that can do that!"
06:33:16 <basti_> what's jean-phillipe bernardy's nickname on here?
06:33:22 <shapr> basti_: jyp
06:33:27 <basti_> ah
06:33:34 <basti_> great work on yi's emacs2
06:33:47 <basti_> almost completely obsoletes mine ;(
06:34:06 <CosmicRay> shapr: haha
06:34:08 <CosmicRay> shapr: nifty.
06:34:12 <CosmicRay> I like it.
06:34:42 <ibid> dcoutts_: yes
06:34:46 <lightstep> does ghc do that?
06:35:05 <shapr> lightstep: 6.5 does.
06:35:16 <Lemmih> shapr: What mailing list?
06:35:16 <xerox> woot
06:35:19 <lightstep> whoa
06:35:24 <shapr> Shootout mailing list, lemme find the url.
06:35:36 <ibid> dcoutts_: i'm going away for a while, bbl
06:35:41 <lightstep> when will debian have it?
06:35:52 <rep> woot
06:35:54 <shapr> I only vaguely recall Skaller's response, so I may have it wrong.
06:40:03 <CosmicRay> shapr: you were thinking of contributing something to the beauty contest, but I forget what...
06:40:18 <shapr> Oh, a rant!
06:40:25 <CosmicRay> heh
06:40:28 <shapr> Yes, I think it was about that.
06:40:37 <shapr> Too bad I can't remember what I was going to say.
06:40:46 <CosmicRay> about being communicative?
06:40:51 <shapr> Hm, yeah.
06:41:01 <CosmicRay> the file you'll want is probably website/lib/faq.tpl.php
06:41:19 <CosmicRay> and I just have to add that the shootout code SUCKS BIG TIME.
06:41:29 <CosmicRay> it's almost as hideous as the debian build daemons.
06:41:58 <CosmicRay> autrijus had to help me fix a Perl bug in it yesterday ;-)
06:42:43 <shapr> Lemmih: http://thread.gmane.org/gmane.comp.lang.shootout.general/1991
06:43:51 <shapr> Ah no, he just said that there's no good way to measure emulated multiple CPUs, and that OCaml can't run a single program on multiple CPUs
06:45:33 <shapr> I've discovered that it's best if I find the article/paper/book in question and check my memory before describing a particular bit of information. :-/
06:45:51 <rep> shapr if the program forks instead of creaoting it thread, it'll exploit multiple CPUs :)
06:45:56 <rep> in any language
06:46:57 <shapr> In that case you just send your replies back through some sort of IPC, right?
06:47:18 <rep> but you don't want to fork too often, or have significantly more processes than CPUs, because forking is expensive, and context switches between processes are expersive too
06:47:21 <rep> shapr yes
06:47:50 <shapr> Sounds like a cheesy implementation of MPI
06:47:59 <xerox> @what MPI
06:48:00 <lambdabot> Unknown command, try @listcommands.
06:48:01 <shapr> Or maybe MPI is a nifty implmentation of ...
06:48:04 <xerox> :-)
06:48:13 <rep> well, MPI does a lot of things
06:48:18 <shapr> @google mpi pvm beowulf
06:48:19 <lambdabot> http://www.beowulf.org/archive/2001-February/002359.html
06:48:52 <basti_> did i mention that STM ought to go multiprocessor?
06:49:04 <shapr> Isn't it already in 6.5?
06:49:13 <basti_> :-o
06:49:22 <basti_> even virtual parallelism?
06:49:25 <xerox> That paper is great
06:49:29 <basti_> (pvm or something)
06:49:38 <basti_> (or, abstracted parallelism)
06:49:53 <basti_> that would ultra-rule.
06:50:07 <xerox> Please elaborate on that
06:50:26 <basti_> me hor shapr?
06:50:35 <shapr> You did what to me?
06:50:39 <xerox> ahr ahr
06:50:50 <xerox> You, psybasti :)
06:51:02 <basti_> eruhm
06:51:17 <basti_> xerox: STM currently only abstracts multithreading on a single processor.
06:51:44 <xerox> Yes I read the paper
06:51:50 <basti_> however, there are useful low-level abstractions for multiprocessor systems.
06:52:07 <basti_> With STM on multiprocessor systems, things would be way cooler than without.
06:52:24 <basti_> (easy accessible parallelism)
06:52:34 <basti_> given the advances of lock-free programming
06:53:55 <shapr> Oh hey, have you seen the AnandTech articles that are the reason whatshisname wrote "On Threading" (Tim Bray maybe?)
06:54:44 <shapr> Anyway, these AnandTech articles make a lot of interesting points about what software will need to do in the future to work well on multi-core CPUs.. one point is zero or optimistic locking instead of standard locks...
06:55:07 <rep> optimistic locking?
06:55:13 <shapr> Maybe I should write an article on how GHC fits nicely onto multicore CPUs.
06:55:21 <shapr> rep: like STM
06:55:58 <shapr> basti_: Yes, STM + SMP will totally kick ass.
06:56:05 <basti_> not only SMP
06:56:16 <basti_> even clustering
06:56:31 <shapr> Yes, but STM + SMP lets us laugh at Java/C/etc programmers who have race conditions, deadlock, etc.
06:56:49 <basti_> yes.
06:56:54 <rep> i guess i'll read the paper
06:57:07 <shapr> rep: Google will love you for it.
06:57:12 <basti_> but SMP is explicitely only this bizarro construction of "many processors on one board that share a chipset"
06:57:54 <shapr> At the moment, that's the only multi-processing GHC does.
06:58:31 <basti_> thats good, but does not corellate well with reality.
06:58:45 <cjb> Hello.  Any ion users around, by any chance?
06:58:48 <shapr> me me!
06:59:01 <shapr> cjb: I think tuomov uses ion also.
06:59:04 * Lemmih is also an ion user.
06:59:09 * xerox was
06:59:17 <shapr> basti_: It does correlate with multicore desktops.
06:59:30 <cjb> ion2 had a feature where you could double-click on a frame title to "roll it up" (and presumably there was a keyboard shortcut too), but ion3 doesn't do it.  Is the feature gone, or just the keybinding?
06:59:51 <shapr> works fine for me.
07:00:02 <cjb> Also, I got a new laptop.  :)  http://www.inference.phy.cam.ac.uk/cjb/unity.png
07:00:23 <cjb> Huh.  I'm using the default config, or so I thought.
07:00:29 <shapr> I'm using "Version: 20050820-4" with debian/unstable
07:00:38 <basti_> shapr: sadly, "multicore" systems (chipset saving excuse for multiprocessing) interest me not in the slightest, personally.
07:00:40 <rep> cjb not very sexy :P
07:00:47 <xerox> cjb: what is the 'news' reader?
07:00:52 <cjb> xerox: That's gnus.
07:01:05 <cjb> I'm using '3ds-20050625', from Ubuntu/breezy.
07:01:11 <cjb> rep: I disagree.  :)
07:01:15 <shapr> basti_: They interest me lots
07:01:31 <cjb> (It's a laptop screen, running at 1920x1200.  Feels like I have two monitors!)
07:01:48 <xerox> cjb: how big is the screen?
07:01:49 <shapr> basti_: Though I admit, I'd rather have Haskell fully supporting clusters.
07:01:52 <cjb> xerox: 17".
07:01:57 <basti_> shapr: until the bottleneck shifts back to processors.
07:02:10 <shapr> basti_: that'll be a few years.
07:02:24 <cjb> shapr: Do you happen to know what the function called to do the frame-rolling-up is called, so I could google for references to it?
07:02:25 <rep> where's the bottleneck, currently?
07:02:40 <basti_> rep: mem, periphery
07:02:47 <xerox> eek, it's gnus?!
07:03:16 <booger> hm, i'd like some help with a haskell-problem..
07:03:17 <shapr> cjb: What are you building in that screenshot? XSimpleIO? Is that wxHaskell or Cairo?
07:03:18 <basti_> (1 random mem access > 30 processor cycles)
07:03:51 <cjb> shapr: Building a package called sfcd, which frederikEaton wrote.
07:04:03 <cjb> xerox: Yup.  gnus is lovely.  (and does mail and RSS as well as news.)
07:04:30 <shapr> Where do I get it from?
07:04:32 <cjb> I think it's xlib, neither exHaskell nor Cairo.
07:05:23 <cjb> Hm, not sure if he's released it properly.  It's a version of Dasher that does arithmetic coding on a two-dimensional interval instead of a one-dimensional one.
07:06:36 <cjb> (So it's 3d, sort of, using a space-filling curve (Peano curve) for the coding.  I don't know if you know enough about Dasher for that to mean anything, though.  :)
07:07:19 <xerox> Any shot? :)
07:07:31 <cjb> Yeah, was just finding it.  :)  http://www.inference.phy.cam.ac.uk/cjb/sfcd.png
07:07:49 <cjb> (That's showing the bottom-left quarter of what was originally a full square, and is being zoomed down upon.)
07:08:02 <basti_> cjb: just like dasher :D
07:08:15 <cjb> You can see how the space-filling curve works from the arrangement of the a..z boxes.
07:08:32 <shapr> cjb: http://www.scannedinavian.org/~shae/cfg_floatws.lua
07:09:07 <cjb> shapr: Thanks.  But I was trying this on WIonWS frames..
07:09:11 <shapr> oh
07:09:20 <cjb> Oh!  Sorry, I didn't make that clear at all.
07:09:24 <shapr> In that case, why not just copy over the dblclick line?
07:09:41 <shapr> mdblclick("Button1@tab", "WIonFrame.set_shaded(_, 'toggle')"),
07:10:23 <cjb> Will give it a try.
07:12:05 <cjb> Hm.  Doesn't generate an error, but also doesn't work.
07:12:33 <shapr> Try looking at the ion3 docs to figure out the real name of functions for WIonWS
07:12:49 <basti_> shapr: I'm trying to instantiate Monad inside Lemmih's hsp's. That sucks though, because the file appears to compile, but then the old version is run, without any other indication of error. I asked Lemmih and he didnt have a clue.
07:13:54 <shapr> If hs-plugins still uses externally declared type sigs, maybe that's what failed?
07:14:04 <basti_> hmmmh
07:14:09 <basti_> that would at least be an indication
07:14:37 <shapr> Otherwise, hsp might be using the wrong hs-plugins method, one of make, reload or something rebuilds and reloads, and one only builds? I think...
07:15:13 <basti_> well normally it works
07:15:20 <basti_> Monad instantiation repeatably breaks stuff
07:15:21 <xerox> Is there a known Haskell parser for mathematical expressions, anywhere?
07:15:35 <basti_> xerox: there's parser builders like happy.
07:15:51 <basti_> hmmmmm
07:15:55 <shocker> how can i return true if a file exists
07:15:56 <shocker> ?
07:16:15 <xerox> I think I'd rather use Parsec, but I was asking if there are any implementations of the same idea around that you know.
07:16:16 <cjb> shapr: it's "mdblclick("Button1", WIonFrame.toggle_shade, "tab")," in ion2; the ion3 docs say that toggle_shade has been replaced with set_shaded, but that doesn't seem to do anything on an IonFrame.
07:17:15 <basti_> there's no error in the debug file too :/
07:17:26 <xerox> I could avoid any difficulties by using s-expressions, now that I think of them :)
07:17:43 <shapr> cjb: http://www.scannedinavian.org/~shae/cfg_ionws.lua
07:18:22 <cjb> shapr: Yes, I have one of those two.  :)  Notice there's no double-click binding.
07:18:35 <basti_> shapr: normally the command is called "stat"
07:18:37 <basti_> wah
07:18:41 <basti_> shocker: normally the command is called "stat"
07:18:43 <cjb> s/two/too/
07:18:51 <Lemmih> @index doesFileExist
07:18:51 <lambdabot> System.Directory, Distribution.Compat.Directory
07:18:52 <basti_> I fail to find it in the haskell docs though
07:18:57 <basti_> Lemmih: thanks
07:19:06 <shocker> hmm
07:19:40 <basti_> Lemmih: i still don't understand why instantiating Monad breaks hasp. No errors in the debugging file too
07:21:08 <JohnMeacham> yeah, unicode has pretty much everything, including a lot of drawing characters.
07:21:17 <JohnMeacham> ░░▒▒▓▓██
07:21:45 <Lemmih> basti_: Does the file compile correctly?
07:22:12 <basti_> Lemmih: there is no error in the debug log
07:23:00 <basti_> "making page with args...", "Loading symbol... Success"
07:23:09 <basti_> hmm what happens if i remove the symbol file? :D
07:23:54 <basti_> then it compiles, but "Can't create object file"
07:24:11 <xerox> What special characters could appear in type names (data constructors) ?
07:27:26 <earthy> xerox: what do yo mean?
07:27:49 <xerox> Like data Foo = Foo+ | Foo* | Foo_ | Foo: | Foo,
07:28:11 <xerox> They do probably not work, I wonder if any special character could appear in a data constructor name,
07:30:29 <earthy> well, data Expr a = a .+. a | a .-. a | a .*. a | a
07:30:35 <earthy> is valid Haskell
07:31:17 <Igloo> No it isn't
07:31:30 <xerox> Only 'a' ?
07:31:35 <earthy> not only a
07:31:39 <earthy> it isn't?
07:32:25 <Igloo> If you want infix data constructors they have to start with :
07:32:33 <kolmodin> its not valid
07:32:38 <Igloo> And the last option you'd neeed a constructor for
07:32:49 <earthy> yeah, the latter is true
07:33:02 <earthy> but ISTR having code with .thingy. as conop's
07:33:33 <earthy> ah, no, my bad
07:33:36 <earthy> that was just ordinary functions
07:35:56 <earthy> but, umm, data Foo = Foo+ | Foo* | Foo_ | Foo: | Foo, is illegal as well
07:36:03 <Igloo> Yes
07:36:13 <earthy> as conid -> large { small | large | digit | ' }
07:36:38 <earthy> and consym -> (: {symbol | :}) - <reservedop>
07:37:43 <earthy> so, valid would be  data Expr a = a :+ a | a :- a | Foo a
07:37:49 <earthy> but *not* e.g.  a :_ a
07:38:05 <earthy> or a :, a
07:38:24 <earthy> anyway, it's quite clearly specified in the report
07:39:16 <xerox> Thanks
07:44:34 <wagerlabs> good afternoon
07:44:50 <wagerlabs> can you test code like this at the ghci prompt?
07:44:51 <wagerlabs> main = do
07:44:51 <wagerlabs>     ptr_x <- new (BigEndian(1::Int))
07:44:51 <wagerlabs>     (BigEndian x) <- peek ptr_x
07:44:52 <wagerlabs>     poke ptr_x (BigEndian 2)
07:45:01 <wagerlabs> it's hanging for me for whatever reason
07:45:21 <basti_> yes
07:45:28 <basti_> load that in ghci, and then type "main"
07:45:30 <basti_> :)
07:45:45 <wagerlabs> basti_: it hangs. strange
07:45:49 <basti_> o
07:45:55 <wagerlabs> testing each line separately does not work
07:45:59 <basti_> I'd say I'd expect it to behave the same
07:46:04 <wagerlabs> actually, the second like does not work
07:46:30 <wagerlabs> and main hangs regardless of whether i type it at the ghci prompt or load it from a file. isn't a return needed at the end?
07:47:21 <malcolm> Anyone here familiar with wxhaskell?
07:47:46 <basti_> wagerlabs: not necissairly.
07:47:58 <basti_> wagerlabs: return is very different in haskell than in C or Java.
07:48:06 <wagerlabs> basti_: ok
07:49:21 <shapr> malcolm: For what definition of familiar?
07:49:42 <malcolm> shapr: there are a couple of API calls that are not doing what I expected
07:51:13 <malcolm> shapr: e.g. Graphics.UI.WXCore.Draw.getTextExtent seems to only tell me how big the first line of text is, doesn't work with multiple lines
07:51:39 <xerox> What's wrong with:
07:52:03 <xerox> data A = B | C
07:52:03 <xerox> data D = D A A
07:52:03 <xerox> type E = D B C
07:52:07 <Lemmih> wagerlabs: You probably got a loop in your code.
07:52:27 <wagerlabs> Lemmih: it's benjamin's source, posted to haskell-cafe
07:52:34 <wagerlabs> Lemmih: let me look into it
07:52:51 <Lemmih> xerox: B and C aren't types. And D isn't a type constructor.
07:54:34 <wagerlabs> @paste
07:54:35 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:55:24 <xerox> Lemmih: mumble.
07:55:30 <Lemmih> xerox: E makes a much sense as 'type E = Int Just Nothing'
07:56:00 <Lemmih> s/ a / as /
07:56:07 <xerox> Lemmih: I was trying to make a synonym for D B C.
07:56:34 <xerox> I think I can avoid it, anyway.
07:56:38 <Lemmih> You can't since 'D B C' isn't a type.
07:57:01 <Lunar^> @seen SyntaxPolice
07:57:03 <lambdabot> I haven't seen SyntaxPolice.
07:57:14 <Lunar^> *sigh*
07:59:18 <ndm> @seen SyntaxNinja
07:59:19 <lambdabot> I saw SyntaxNinja leaving #haskell 6 days, 23 hours, 35 minutes and
07:59:19 <lambdabot> 23 seconds ago, and I have missed 5 days, 15 hours and 9 minutes
07:59:19 <lambdabot> since then.
08:00:13 <Lemmih> wagerlabs: It's not surprising that the peek hangs.
08:00:25 <wagerlabs> Lemmih: really?
08:01:12 <xerox> Lemmih: does't D get two As ?
08:01:28 <Lemmih> 'peek' is defined by a call to 'peekElemOff' and 'peekElemOff' is defined by a call to 'peek'.
08:02:32 <Lemmih> xerox: data At = Bc | Cc; data Dt = Dc At At; type Et = Dt Bc Cc
08:03:07 <xerox> Lemmih: yes
08:03:42 <Lemmih> But the kind of 'Dt' is * so you can't give it any arguments.
08:03:45 <Lemmih> @kind Int
08:03:46 <lambdabot> *
08:03:48 <Lemmih> @kind Maybe
08:03:49 <lambdabot> * -> *
08:03:52 <wagerlabs> Lemmih: you mean peekByteOff
08:04:14 <xerox> Lemmih: I don't get what's the difference between yours and my example
08:04:42 <Lemmih> xerox: I just made the difference between types and data constructors explicit.
08:05:18 <Lemmih> xerox: Do you see why you can't give Dt any arguments?
08:06:20 <Lemmih> (ignoring the fact that Bc and Cc aren't types and therefore not valid arguments)
08:06:31 <xerox> Lemmih: because it is not parametryc?
08:06:35 <xerox> s/y/i/
08:07:02 <xerox> Maybe it's data Dt At = Dc At At ?
08:07:08 <Lemmih> Perhaps you want: 'e = D B C'?
08:07:32 <wagerlabs> thanks Lemmih
08:07:42 * wagerlabs will be back with more questions :D
08:07:49 <wagerlabs> after these messages
08:07:51 <xerox> So foggy...
08:07:58 <xerox> Am I blind?  I can't see what you mean.
08:08:50 <Lemmih> xerox: 'Dt' is a valid type by itself, right?
08:09:08 <xerox> It has kind * -> * -> *
08:09:15 <Lemmih> No, it doesn't.
08:09:19 <xerox> Uh.
08:09:19 <Lemmih> It has kind *.
08:09:28 <xerox> Okay.
08:09:41 <xerox> Because it has no type variables, but two fields
08:10:38 <Lemmih> Dt doesn't have any arguments/fields. Dc has got two, though.
08:11:09 <Lemmih> That's why Dc has the type :: A -> A -> Dt.
08:11:39 <xerox> At -> At -> Dt, I see
08:12:14 <xerox> I think I got it.
08:12:23 <xerox> What I wanted was a _value_
08:12:36 <xerox> <Lemmih> Perhaps you want: 'e = D B C'?
08:12:38 <xerox> Exactly.
08:12:46 <xerox> Thanks Lemmih.
08:12:53 <Lemmih> No problem (:
08:14:02 <basti_> ah
08:14:05 <basti_> Lemmih: i found the problem
08:14:23 <basti_> in compiled/XXX.hs, (>>=) is changed to >>=
08:14:35 <basti_> so I just have to use the infix form
08:19:01 <basti_> mmmh
08:19:10 <Lemmih> basti_: Urk. That's a problem in the haskell parser /-:
08:19:39 <basti_> rather in the reconstruction huh
08:20:00 <basti_> infix doesnt work as well, for reasons i fail to recognize
08:20:15 <basti_> ("parse error in pattern")
08:21:00 <Lemmih> (the parser includes a pretty printer)
08:21:24 <basti_> ah
08:21:40 <Lemmih> Using the GHC library would solve everything.
08:23:30 <basti_> hmm in infix mode, theres a pair of parenthenses too much
08:24:01 <basti_> heh
08:24:08 <basti_> got a workaround!
08:24:12 <basti_>    ((>>=)) (Form (_,b)) f  = f b
08:24:14 <basti_> :D
08:24:20 <basti_> st00pid.
08:24:36 * basti_ bounces
08:24:58 <basti_> no
08:24:59 <basti_> :/
08:25:01 <basti_> wtf?
08:30:28 <Lemmih> dcoutts_: How do we fix the threading issue?
08:30:32 <basti_> is there any escape functoinality in the parser?
08:30:49 <Lemmih> escape functionality?
08:31:27 <basti_> hmm i was thinking about using a -D to feed in this single string
08:31:44 <basti_> (but the extra-ghc-args thing isn't working?)
08:31:58 <basti_> maybe something similar to keep this from happening
08:32:29 <Lemmih> It should work. You have to restart the server for it to take effect, though.
08:32:53 <dcoutts_> Lemmih, what threading issue?
08:33:01 <basti_> i know, thats what i was doing
08:33:45 <Lemmih> dcoutts_: Running the parser/typechecker in the same thread as everything else is not really acceptable.
08:34:10 <dcoutts_> Lemmih, yes, so run it in another Haskell thread
08:34:38 <Lemmih> It'll still be in the same thread.
08:34:48 <dcoutts_> we can use multiple Haskell threads, we just can't use the -threaded RTS
08:35:28 <dcoutts_> besides, the -threaded RTS would not make it faster since the RTS only runs one Haskell thread at once anyway
08:35:38 <Lemmih> It blocks every other Haskell thread when it does heavy IO or 'let loop () = loop () in loop ()'.
08:36:03 <dcoutts_> if it's blocking doing IO then thats a bug in ghc or the ghc api
08:36:09 <Lemmih> dcoutts_: But then we could fork the parser in an OS thread.
08:36:31 <dcoutts_> it wouldn't help, only one Haskell thread can run at once
08:36:45 <Lemmih> The RTS can only shift threads when the program is doing allocations.
08:37:05 <JaffaCake> you'll need the threaded RTS eventually if you want to take advantage of SMP
08:37:20 <dcoutts_> Lemmih, right, and that's true for the single and multi-threaded rts
08:37:42 <dcoutts_> JaffaCake, if we could bind Haskell threads to specific OS threads then we could use the threaded rts
08:37:48 <Lemmih> JaffaCake: Does vs run the typechecker in a background thread?
08:38:10 <dcoutts_> JaffaCake, but at the moment we can't do that and so it'd break Gtk+ to run it with multiple OS threads.
08:38:18 <JaffaCake> dcoutts: yes, I remember the problem
08:38:30 <JaffaCake> but you want to bind multiple Haskell threads to the same OS thread, which is tricky
08:38:36 <dcoutts_> JaffaCake, yes
08:38:57 <dcoutts_> that's what happens with the single threaded RTS :-)
08:39:08 <JaffaCake> by definition :)
08:39:11 <dcoutts_> which is why it works with Gtk+
08:39:43 <JaffaCake> I still think you should try using Haskell-side locking of the API
08:39:50 * dcoutts_ shudders
08:40:11 <JaffaCake> it won't impose much overhead, you can take the lock across multiple calls
08:40:19 <JaffaCake> it's just a bit annoying
08:40:34 <dcoutts_> but that makes it explicit and therefore people will forget and they progs will crash
08:40:43 <JaffaCake> if you want to run on SMP, you'll have to bite the bullet eventually
08:40:44 <shapr> @seen genneth
08:40:45 <lambdabot> I saw genneth leaving #haskell 9 days, 8 hours, 36 minutes and 1
08:40:45 <lambdabot> second ago, and I have missed 5 days, 15 hours and 9 minutes since
08:40:45 <lambdabot> then.
08:40:55 <dcoutts_> at the moment (with the single threaded rts) it works just fine
08:41:17 <dcoutts_> one can use as many Haskell threads as one likes and you can do GUI stuff in any/all of them
08:41:38 <JaffaCake> sure, but you can't eg. make a non-blocking foreign call
08:41:47 <dcoutts_> true
08:42:05 <dcoutts_> we'd like it to work with the threaded rts for that reason
08:42:13 <dcoutts_> +smp in the future
08:42:31 <shapr> hei esap
08:42:35 <esap> hei shapr!
08:42:40 <basti_> Lemmih: the Config.hs file is being loaded (checked with a debug statement inside the file. The Additional option I gave doesn't show up though.
08:42:43 <shapr> Have you had any time to work on your TMR article?
08:42:47 <dcoutts_> if we do it transparently at the API level then every call needs locking which will be very slow.
08:42:56 <esap> shapr: I've almost forgot about the whole thing :-)
08:43:16 <shapr> You could clip off the unfinished part and submit what you have. It already has excellent parts.
08:43:34 <shapr> Oh, lhs2TeX is going to be the encouraged formatting method for the next TMR.
08:43:36 <JaffaCake> dcoutts_: I guess it's a choice between complexity in the RTS and complexity in the app, and since I'm responsible for the RTS I know where I want the complexity to go :)
08:43:46 <dcoutts_> JaffaCake, :-)
08:43:49 <wagerlabs> hhowdy
08:44:44 <wagerlabs> how come ghci is barfing on my show?
08:44:44 <wagerlabs> main = do
08:44:44 <wagerlabs>     ptr_x <- new (BigEndian(1::Int))
08:44:44 <wagerlabs>     x <- peek ptr_x
08:44:44 <wagerlabs>     show x
08:44:47 <wagerlabs>     poke ptr_x (BigEndian 2)
08:45:16 <shapr> What error do you get?
08:45:50 <dcoutts_> JaffaCake, you already introduced the bounds thread idea to cope with the (odd) threading needs of OpenGL. There are actually many more foreign libs that are like Gtk+ than like OpenGL, ie it's not safe to use the same object from different threads concurrently.
08:45:52 <wagerlabs> lets see
08:46:02 <wagerlabs> test.hs:7:4:
08:46:02 <wagerlabs>     Couldn't match `IO' against `[]'
08:46:04 <wagerlabs>       Expected type: IO
08:46:04 <wagerlabs>       Inferred type: []
08:46:04 <wagerlabs>     In a 'do' expression: show x
08:46:05 <wagerlabs>     In the definition of `main':
08:46:19 <dcoutts_> JaffaCake, so called "thread aware" but not thread safe.
08:47:20 <JaffaCake> dcoutts_: I don't see it as just pandering to OpenGL, it's a delicate compromise that allows an implementation of the RTS in several different ways
08:47:39 <dcoutts_> JaffaCake, ie all global data is protected but individual objects would need locking to prevent access from multiple threads. The Win32 graphics API is even more strict. It will not allow access from threads that did not create the resource, rather than just locking to prevent concurrent access.
08:47:47 <Lemmih> wagerlabs: 'show' just makes a String out of 'x'. You probably want to output that string to stdout.
08:47:48 <dcoutts_> JaffaCake, yes fair enough.
08:48:14 <wagerlabs> Lemmih: printStrLn?
08:48:16 * xerox is wondering about a possible problem....
08:48:29 <Lemmih> wagerlabs: putStrLn (show x) or print x.
08:48:53 <xerox> Do pattern matching force evaluation of functions' arguments?
08:48:54 <JaffaCake> dcoutts_: the one restriction you're coming up against is that you can't have multiple Haskell threads bound to the same OS thread.  If we drop this restriction, we'd lose some of the portability (eg. no 1-1 implementation).
08:49:20 <JaffaCake> maybe that's not such a big deal, but I also worry about how to implement the scheduler properly
08:49:34 <dcoutts_> JaffaCake, yes that is true. Gtk+ would not be usable in a 1-1 threading model.
08:50:20 <xerox> For example, in:  f Constructor _ = Foo;  f x _ = x;  am I sure that x will be completely evaluated (in order to try to match Constructor) before the computation goes to that pattern-matching case?
08:50:26 <JaffaCake> ghc -threaded is essentially an optimised 1-1
08:50:30 <dcoutts_> JaffaCake, I think linux uses a thread queue per cpu and then occasionally rebalances threads that are not bound to a cpu.
08:50:59 * JaffaCake has a lightbulb moment
08:51:08 <dcoutts_> JaffaCake, so the translation of that would be one queue per pthread and a rebalancer. It has the side effect of getting good cpu affinity.
08:51:18 <JaffaCake> the redesign of the RTS we're working on might make this easier, actually
08:51:19 <rep> JaffaCake what do you mean by 1-1 ?
08:51:38 <dcoutts_> rep, one OS thread for each Haskell thread
08:51:58 <rep> dcoutts_ and that's how it should be!
08:51:59 <JaffaCake> dcoutts: yes, in our redesign of the RTS we're going to have one Haskell thread queue per OS thread
08:52:18 <JaffaCake> which should make it easier to do what you want!
08:52:24 <dcoutts_> JaffaCake, ok then that would make binding  threads easier
08:52:25 <rep> dcoutts_ there's really no point in the RTS implementing its own threads
08:52:36 <dcoutts_> rep, oh yes there is :-)
08:52:41 <rep> dcoutts_ why?
08:52:44 <rep> i mean, what is it?
08:52:46 <JaffaCake> rep: I respectfully disagree
08:52:53 <dcoutts_> rep, Haskell threads are ultra-lightweight
08:53:06 <JaffaCake> rep: there's a couple of orders of magnitude in it
08:53:15 <rep> dcoutts_ get a better threading library/os
08:53:15 <dcoutts_> rep, you can use dozens/hundreds/thousands of Haskell threads
08:53:26 <JaffaCake> GHC has the fastest threads on the planet :)
08:53:37 <rep> (such as freebsd with libpthread)
08:53:43 <thedward> @commands
08:53:44 <lambdabot> Unknown command, try @listcommands.
08:53:44 <JaffaCake> rep: not good enough
08:53:48 <thedward> @listcommands
08:53:48 <rep> JaffaCake why not?
08:53:49 <lambdabot> use listcommands [module|command], please. Modules are:
08:53:49 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
08:53:49 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
08:53:49 <lambdabot> spell state system todo topic type version vixen where
08:53:56 <dcoutts_> rep, C green threads have too much state
08:54:00 <JaffaCake> rep: try it, pthreads are a lot slower
08:54:03 <dcoutts_> rep, eg a stack.
08:54:10 <rep> JaffaCake not here
08:54:21 <JaffaCake> that sounds like a challenge :)
08:54:35 <rep> JaffaCake i get the same results on my box with forkOS and forkIO
08:54:48 <rep> (for httpd.hs)
08:55:05 <JaffaCake> are you sure you're compiling with -threaded?
08:55:17 <rep> yes, you can't use forkOS without -threaded :)
08:55:36 <thedward> @google jhc
08:55:38 <lambdabot> http://www.jhc.org/
08:56:08 <JaffaCake> so you're saying that there's essentially zero overhead to fork an OS thread?
08:56:25 <dcoutts_> rep, you can read the original Concurrent Haskell paper for some benchmarks.
08:56:32 <rep> JaffaCake not zero, but very low
08:56:42 <JaffaCake> I know a little about FreeBSD's pthreads, but I'm still surprised if they're faster than GHC's threads
08:56:50 <rep> JaffaCake because freebsd has an n:m threading library
08:56:56 <dcoutts_> JaffaCake, I think FreeBSD's libpthread uses an m-n model. So they're partially user space threads.
08:57:05 <rep> dcoutts_ exactly
08:57:13 <dcoutts_> So they're a bit quicker than OS threads
08:57:20 <JaffaCake> yes, but you still need to do *something* to fork a thread
08:57:33 <rep> JaffaCake create a new stack. that's about it
08:57:37 <basti_> uhm
08:57:46 <basti_> is there a way to do what C does with #define in haskell?
08:57:59 <dcoutts_> rep, but they'll still carry more overhead than GHC lightweight threads I'll bet. But fewer orders of magnitude than with ordinary OS threads.
08:58:00 <JaffaCake> rep: is that entirely in user space?
08:58:08 <dcoutts_> JaffaCake, it's a mixture
08:58:09 <basti_> i only find -D in ghc, but that replaces stuff *in the C code*
08:58:11 <earthy> basti_: you can run cpp on your haskell code. :P
08:58:12 <Lemmih> basti_: You can use cpp on haskell sources.
08:58:19 <rep> dcoutts_ maybe, but at least blocking in one thread won't block all the other threads
08:58:21 <basti_> hmmh
08:58:23 <JaffaCake> I meant pthread_create
08:58:30 <earthy> basti_: but you can also do template haskell, which is a *lot* more powerful and functional
08:58:45 <basti_> earthy: this is a workaround for the broken prettyprinter :(
08:59:16 <rep> JaffaCake not really. they create n kernel threads per cpu, and then the userland scheduler schedules the user-threads between those kernel threads
08:59:17 <beschmi> rep: FreeBSD threads are based on http://citeseer.ist.psu.edu/anderson92scheduler.html ?
08:59:17 * basti_ graaaaahs
08:59:18 <xerox> basti_: there is cpphs too
08:59:22 <rep> beschmi yes
08:59:28 <dcoutts_> rep, well doing IO does not block Haskell threads. Doing FFI calls does which is why the threaded RTS was developed.
08:59:41 <basti_> xerox: hmmm
08:59:49 <JaffaCake> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/testsuite/tests/ghc-regress/concurrent/should_run/conc004.hs?rev=1.2.4.1;content-type=text%2Fplain
08:59:59 <JaffaCake> rep: try that benchmark with forkIO vs. forkOS
09:00:12 <basti_> ah cpphs, thats what you other guys were talking about too
09:00:17 <rep> JaffaCake ok
09:00:25 <basti_> so how do i do that? manually?
09:00:34 <malcolm> @where cpphs
09:00:35 <lambdabot> http://www.cs.york.ac.uk/fp/cpphs/
09:00:42 <basti_> it is installed
09:00:57 <thedward> @where jhc
09:00:58 <lambdabot> http://repetae.net/john/computer/jhc/
09:01:00 <basti_> the problem is: there is a code preprocessor called trhsx
09:01:09 <dcoutts_> rep, and just change it to "import Control. Concurrent"
09:01:12 <basti_> the modification would need to take place AFTER trhsx
09:01:19 <basti_> (maybe i just make a script :D
09:01:26 <dcoutts_> rep, or rather "import Control.Concurrent"
09:01:32 <rep> :)
09:02:03 <wagerlabs> is there a concept of include files in haskell? or do i just put definitions in a separate module?
09:02:45 * malcolm shudders
09:02:53 <xerox> O_o
09:03:39 <dcoutts_> rep, JaffaCake, on my system forking 10,000 OS threads takes 3.264s, forking 10,000 Haskell threads takes 0.072s
09:03:55 <dcoutts_> I didn't want to try the full 100,000
09:04:02 <malcolm> wagerlabs: with a decent module system, there is almost never a need for #includes
09:04:13 <dcoutts_> or rather 1,000,000
09:04:14 <wagerlabs> malcolm: cool
09:04:28 <wagerlabs> is there a way to define a record where the first field has a constant value?
09:04:53 <dcoutts_> well at least not OS threads :-) forking 1,000,000 Haskell threads took 3.052s
09:04:56 <Lemmih> 0.811s vs. 11.037s on my box.
09:05:12 <JaffaCake> which is which, Lemmih?
09:05:20 <wagerlabs> i'm graduating to definining my network packets and the first field is always the type ... hmm... doesn't make a lot of sense
09:05:31 * dcoutts_ is currently using an old 500Mhz box
09:05:42 <malcolm> wagerlabs: if it is constant, why wuld you want to store it in a record?
09:05:47 <Lemmih> JaffaCake: 0.811 are 1,000,000 Haskell threads.
09:05:50 <wagerlabs> i'll rephrase that, one sec
09:05:58 <JaffaCake> Lemmih: what OS?
09:06:13 * dcoutts_ is using linux 2.6.9
09:06:29 * Lemmih is on a Debian box with a 2Ghz AMD CPU and 1.5Gb DDR memory.
09:06:55 <Lemmih> (using a 2.6.8 kernel)
09:07:00 <rep> forkOS seems to be much slower.
09:07:04 <wagerlabs> the packet type is a byte and i want to define an "enum" in haskell and barf is i retrieve a value that i don't know from the network. possible?
09:07:05 <JaffaCake> Lemmih: interesting that your OS threads seem a lot faster than dcoutts'
09:07:12 <rep> but something is weird
09:07:29 <dcoutts_> JaffaCake, my machine is much older/slower
09:07:39 <dcoutts_> JaffaCake, and my machine is a sparc
09:08:21 <JaffaCake> hmm, but the ratio was quite different, that's still surprising
09:08:22 <malcolm> wagerlabs: I only understood up to the word "barf".
09:08:33 <JaffaCake> rep: weird how?
09:08:35 <wagerlabs> i = if :)
09:08:52 <rep> it only has 4 threads at once, at most
09:08:57 <wagerlabs> malcolm: suppose packet type can be either 1 or 2. i want to stop 3 from getting through
09:09:02 <dcoutts_> JaffaCake, hmm, yes the ratio is quite different
09:09:47 <malcolm> wagerlabs: So you want something like   getByte :: IO (Maybe Int)
09:09:52 <rep> hm
09:09:53 * dcoutts_ needs to go catch a bus to Cambridge
09:09:59 <JaffaCake> I've gotta go, rep - can you email me what you find?
09:10:01 <dcoutts_> bye folks
09:10:06 <xerox> Bye bye Duncan!
09:10:07 <wagerlabs> malcolm: i just want an enum
09:10:12 <Lemmih> Bye.
09:10:15 <JaffaCake> bye
09:10:32 <wagerlabs> malcolm: or maybe a newtype that's a list of things where each thing has a byte value
09:10:42 <malcolm> wagerlabs: getByte = do { i <- getInt;  if i`elem`[1,2] then return (Just i) else return Nothing }
09:11:22 <malcolm> wagerlabs: Or perhaps   data Enum = One | Two | Wrong
09:11:44 <wagerlabs> malcolm: data Enum, yes, but how do I assign byte values to One, Two, etc.?
09:12:00 <wagerlabs> malcolm: and then lift 1, 2, etc. to One, Two, etc?
09:12:12 <malcolm> wagerlabs: getByte = do { i <- getInt;  case i of 1 -> return One; 2 -> return Two; _ -> reutrn Wrong }
09:12:35 <wagerlabs> malcolm: right
09:12:51 <malcolm> wagerlabs: Oh, I see.  data MyType = One | Two | Wrong deriving (Enum)
09:13:10 <wagerlabs> malcolm: and the numerical values?
09:13:29 <malcolm> wagerlabs: getByte = do { i <- getInt;  return (toEnum i) }
09:14:09 <wagerlabs> malcolm: do One, Two, etc. need to have sequential values? what if i have a break between values
09:14:18 <wagerlabs> malcolm: i.e. i want One, Three, Five
09:14:38 <malcolm> wagerlabs: if you want to choose non-sequential numbers, then you need to write the instance of the Enum class by hand rather than deriving it automatically.
09:15:11 <Cale> wagerlabs: though I recommend interpreting the numbers available in some way when naming the values of the data type, if possible
09:15:13 <thedward> @hoogle condition
09:15:14 <rep> are GHC threads stackless?
09:15:25 <wagerlabs> malcolm: how do you do that? hmm... i gotta look up Enum
09:15:29 <wagerlabs> Cale: hi
09:15:35 <Cale> hello
09:15:51 <malcolm> wagerlabs: same as for any class.  methods are called toEnum and fromEnum.
09:15:56 <wagerlabs> Cale: well i have a C enum where some values are sequential and others not
09:16:03 <malcolm> @type toEnum
09:16:07 <lambdabot> forall a. (Enum a) => Int -> a
09:16:14 <malcolm> @type fromEnum
09:16:15 <lambdabot> forall a. (Enum a) => a -> Int
09:16:38 <wagerlabs> so my two and from are just big case statements, right?
09:16:54 <wagerlabs> what do you return in case of error?
09:17:04 <malcolm> wagerlabs: yeah, or pattern-matches, or whatever
09:17:05 <wagerlabs> does the error value need to be part of the Enum?
09:18:05 <Cale> wagerlabs: if you want an error value, then yes
09:18:06 <malcolm> wagerlabs: Not necessarily.  You could use the (Maybe a) type for error handling.  Or (Either String a) if you need a meaningful error message
09:18:43 <Cale> but then you need to have Maybe MyType be the instance of Enum.
09:18:44 <wagerlabs> malcolm: something like | otherwise Maybe a?
09:18:55 <malcolm> wagerlabs: If you use Maybe or Either, you would need to be able to detect whether a value is in the allowable range before using toEnum.
09:19:09 <malcolm> wagerlabs: Nope, you are mising up types and values again.
09:19:14 <Cale> ah, I see what you're suggesting :)
09:19:27 <wagerlabs> malcolm: allright, let me take a stab at this
09:19:36 <wagerlabs> i'm gonna define an instance of Enum
09:19:51 <wagerlabs> with my own toEnum, etc.
09:20:33 <wagerlabs> is there a way to look up a type definition in ghci? :t Enum does not work
09:21:13 <xerox> wagerlabs: you could do :info Enum to see its definition and instances.
09:21:13 <Lemmih> Enum is not a type.
09:21:24 <xerox> But yes, it is a TypeClass.
09:21:38 <Cale> :info Enum
09:21:38 <wagerlabs> xerox: thank you, just what i needed
09:21:56 <wagerlabs> wow
09:22:01 <xerox> wagerlabs: keep in mind it is a _Typeclass_, not a Type, anyway.
09:22:08 <wagerlabs>   succ :: a -> a
09:22:08 <wagerlabs>   pred :: a -> a
09:22:08 <wagerlabs>   toEnum :: Int -> a
09:22:10 <wagerlabs>   fromEnum :: a -> Int
09:22:10 <wagerlabs>   enumFrom :: a -> [a]
09:22:11 <wagerlabs>   enumFromThen :: a -> a -> [a]
09:22:13 <wagerlabs>   enumFromTo :: a -> a -> [a]
09:22:16 <wagerlabs>   enumFromThenTo :: a -> a -> a -> [a]
09:22:23 <wagerlabs> i would need to implement all these methods just to have a disjointed enum?
09:22:26 <xerox> i.e. those 'a' are constrained under "Enum a"
09:22:46 <xerox> wagerlabs: usually the documentation is explicative in terms of what is the minimum correct definition for a given typeclass.
09:24:44 <malcolm> wagerlabs: the Haskell Report says the minimum complete definition is just toEnum + fromEnum.  All the other methods have sensible defaults.
09:25:07 <wagerlabs> malcolm: right. lets see...
09:26:47 <wagerlabs> how do you deal with constants? they are just variables which you cannot start with an uppercase letter, right?
09:27:04 <Cale> the default definitions only work if your values map to successive integers
09:27:35 <wagerlabs> Cale: they do not since i'm mapping enum { foo = 1, bar, baz = 200 }
09:28:09 <malcolm> Cale: true.  but I don't expect wagerlabs to need succ pred or any of the others, at least not initially
09:29:07 <Cale> right
09:30:06 <malcolm> Cale: it is worth remembering for later, when the prog crashes mysteriously though :-)
09:30:35 <wagerlabs> i wish i could do data Foo = Bar (1) | Baz (2)
09:30:48 <Cale> It'd probably a good idea to put error stubs in for the other Enum methods
09:32:56 <malcolm> wagerlabs: if you need to make a lot of such enumerations, or to alter them frequently, it might be worth writing a little script to generate your datatype decl and instance decl from a CSV file or something
09:33:10 <wagerlabs> malcolm: interesting
09:34:49 <wagerlabs> ok
09:34:50 <wagerlabs> data CommandType
09:34:50 <wagerlabs>     = CT_Unknown
09:34:51 <wagerlabs>       | CT_CommDisconnected
09:34:51 <wagerlabs> instance (Enum a) => Enum (CommandType a) where
09:34:53 <wagerlabs>   toEnum
09:34:55 <wagerlabs>       | 0x1A -> CT_Unknown
09:34:58 <wagerlabs>       | 27 -> CT_CommDisconnected
09:35:00 <wagerlabs>   fromEnum
09:35:03 <wagerlabs>       | CT_Unknown -> 0x1A
09:35:05 <wagerlabs>       | CT_CommDisconnected -> 27
09:35:08 <wagerlabs> like this?
09:35:51 <malcolm> wagerlabs; won't compile.
09:36:07 <wagerlabs> malcolm: i haven't tried yet
09:36:48 <Cale> wagerlabs: syntax error
09:36:51 <malcolm> wagerlabs: toEnum 0x1A = CT_Unknown;  toEnum 27 = CT_CommDisconnected
09:39:47 <wagerlabs> Kind error: `CommandType' is applied to too many type arguments
09:40:25 <malcolm> wagerlabs: it doesn't need any type arguments
09:40:35 <malcolm> wagerlabs: instance Enum CommandType where
09:41:38 <wagerlabs>     Couldn't match `CommandType' against `t -> t1'
09:41:38 <wagerlabs>       Expected type: CommandType
09:41:38 <wagerlabs>       Inferred type: t -> t1
09:41:38 <wagerlabs>       Expected type: Int -> CommandType
09:41:38 <wagerlabs>       Inferred type: CommandType
09:41:39 <wagerlabs>     In a right-hand side of function `toEnum': CT_Unknown
09:43:15 <malcolm> wagerlabs: did you fix the decl of toEnum already as I suggested above?
09:43:40 <wagerlabs> malcolm: where? i fixed the instane
09:43:42 <wagerlabs> instance
09:43:58 <malcolm> toEnum 0x1A = CT_Unknown;  toEnum 27 = CT_CommDisconnected
09:44:08 <wagerlabs> malcolm: oh, i thought i could use guards
09:44:33 <malcolm> wagerlabs: the value in the guard needs to be a Bool, not an Int
09:44:51 <wagerlabs> malcolm: ok, pattern matching it is
09:45:35 <wagerlabs> so how do you define constants? is there an idiom where i don't want a constant name to start with lowercase?
09:45:42 <wagerlabs> i could do
09:46:06 <beschmi> i modified the threading test to keep all the threads alive: http://www.haskell.org/hawiki/HaskellIrcPastePage
09:46:10 <wagerlabs> version = 2174 for example but then i would be using version somewhere else and it would look like a variable as opposed to a constant
09:46:58 <malcolm> wagerlabs: you would need to use e.g. x==version instead of trying to pattern-match on version.
09:47:16 <wagerlabs> malcolm: version is a separate issue
09:47:35 <wagerlabs> malcolm: i'm just asking in general how do people define constants so that they look like constants in other languages
09:48:26 <malcolm> wagerlabs: For most types, a constant is just a particular constructor, so you can pattern-match against it really easily.  For numbers, the "constructor" is just the literal number itself.
09:49:05 <wagerlabs> ok, let me take a different tack
09:49:24 <wagerlabs> in C i could do #define VERSION 2174 and since it's uppercase everyone would know it's a constant (sort of)
09:49:41 <malcolm> wagerlabs: you could write the same thing in Haskell + cpp
09:49:43 <wagerlabs> it looks like i need to do protocol = 2174 in Haskell and then protocol looks just like everything else
09:49:53 <beschmi> forkOS can't handle more than 380 threads at the same time, forkIO handles 10000 fine
09:49:57 <Cale> wagerlabs: everything in Haskell is a constant
09:50:06 <wagerlabs> cale: true
09:50:17 <wagerlabs> I thought haskell was single-assignment btw
09:50:35 <Cale> It's not single assignment, it's declarative.
09:50:38 <wagerlabs> how come i can do this then?
09:50:38 <wagerlabs>     y <- peek ptr_y
09:50:38 <wagerlabs>     print y
09:50:39 <wagerlabs>     poke ptr_y (BigEndian 035.465)
09:50:39 <wagerlabs>     y <- peek ptr_y
09:50:45 <wagerlabs> it's in do { ... } of course
09:50:58 <Cale> well, that's part of a single value
09:51:09 <malcolm> wagerlabs: ghc -cpp -DVERSION=2174 blah.hs
09:51:16 <wagerlabs> Cale: it looks like an assignment to me :D
09:51:16 <Cale> the do {...} is a single pure value
09:51:26 <wagerlabs> Cale: oh, allright
09:51:41 <Cale> peek is a pure function which returns an action
09:51:48 <malcolm> wagerlabs: the two 'y's are different - they could even be different types
09:52:33 <Cale> yes, that too
09:52:45 <Cale> those y's are in different scopes
09:53:03 <wagerlabs> enums are certainly hard to do in haskell
09:53:30 <wagerlabs> what with duplicating them around 3 times (data ..., toEnum, fromEnum)
09:53:37 <wagerlabs> err, not hard, just tedious
09:54:12 <Cale> apart from deriving Enum, they're not used very much
09:55:15 <wagerlabs> Cale: unless you are doing protocols of course
09:56:17 * malcolm heads into the sunset
10:32:09 <basti_> Lemmih: i worked around the problem with a script that calls first trhsp and then cpphs with -Dsomething=\(\>\>\=\)
10:34:20 <Lemmih> /-:
10:34:50 <basti_> suboptimal.
10:34:53 <basti_> but it works.
11:23:27 * wagerlabs wages
11:23:34 <wagerlabs> err, waves
11:24:39 <wagerlabs> is there a way to derive data types? i.e. data Foo = Foo { a :: Int } and then data Bar = Bar { b :: String } deriving Foo
11:24:44 <wagerlabs> will this work?
11:25:00 <wagerlabs> in such a way that bar will have both a and b fields?
11:25:51 <Cale> wagerlabs: no
11:26:00 <Cale> and deriving only derives typeclasses
11:26:04 <Cale> and only certain typeclasses
11:26:10 <wagerlabs> cale: allright
11:26:13 <Cale> You can do:
11:26:42 <Cale> data Bar = Bar { b :: String, f :: Foo }
11:27:03 <wagerlabs> Cale: i see... thanks
11:27:18 <Cale> or  data Foo a = Foo { x :: Int, ext :: a }
11:27:32 <Cale> and type Bar = Foo String
11:28:26 <wagerlabs> thanks cale
11:28:33 <wagerlabs> i'm defining my packets now
11:28:58 <wagerlabs> Cale: i thought of doing it as a list like you suggested before but then doing packets as data types helps document the protocol
11:29:33 <wagerlabs> i suppose i should make each packet an instance of storable and define peek and poke, right?
11:30:06 <wagerlabs> are there better ways of doing this? because peekByteOff does not make sense. hmm... actually, i don't have to touch peekByteOff, just peek and poke, right?
11:30:07 <Cale> quite possibly
11:31:08 <Cale> Though I don't see why it wouldn't be possible, as long as you're using the Packet class, to just create a type which specifies endianness and do the flipping while decoding
11:31:21 <wagerlabs> is type a keyword?
11:31:44 <wagerlabs> cale: right, a packet would have named fields which could be big or little endian
11:31:56 <wagerlabs> cale: which i think would do the flipping for me
11:32:40 <Cale> type is a keyword, it just makes type synonyms
11:32:47 <wagerlabs> ok /type/
11:32:50 <Cale> um
11:33:00 <Cale> "packet would have named fields which could be big or little endian"
11:33:01 <Cale> ?
11:33:03 <Cale> what?
11:33:12 <Cale> okay
11:33:28 <wagerlabs> data Packet =
11:33:28 <wagerlabs>     Packet { cmdType :: CommandType,
11:33:28 <wagerlabs>              procType :: CommandProcType,
11:33:28 <wagerlabs>              foo :: BigEndian Int
11:33:28 <wagerlabs>            }
11:33:31 <Cale> So you could define instances of Packet for types which are records, of course.
11:33:31 <wagerlabs> wouldn't this work?
11:33:57 <wagerlabs> it should be Packet1 or something like that
11:34:19 <wagerlabs> i would just make each packet an instance of Storable
11:36:14 <Cale> hmm
11:36:23 <Cale> are you using C code for the network stuff?
11:36:37 <wagerlabs> Cale: no, i'm using haskell
11:36:47 <wagerlabs> Cale: at least on my side i am
11:36:49 <Cale> okay, so why bother with Storable?
11:37:00 <Cale> You have a bunch of Word8's right?
11:37:13 <wagerlabs> Cale: well, i need to read/write packets
11:37:31 <wagerlabs> Cale: and packets have endian fields
11:38:00 <wagerlabs> so i was thinking of reading the packet into a chunk of memory and then peeking from that
11:38:14 <wagerlabs> each record would peek its fields sequantially
11:38:43 <wagerlabs> oh, shoot, that won't work, would it? i would need to advance the pointer myself... wouldn't look nice
11:38:52 <Cale> It'll be a mess :)
11:39:00 <wagerlabs> Cale: so what do you recon?
11:39:08 <Cale> Can you get a stream of Word8's from the network?
11:39:24 <wagerlabs> Cale: of course i can. read a FPS and unpack that
11:39:30 <wagerlabs> Cale: why?
11:39:42 <wagerlabs> Cale: you want me to do packets your way don't you? :D
11:39:45 <michael> whee
11:40:34 <wagerlabs> Cale: can i use record with named fields _and_ your [Word8] approach
11:40:46 <Cale> yes
11:41:03 <wagerlabs> Cale: how exactly?
11:41:20 <wagerlabs> plus, i still need my endian fields!
11:41:32 <Cale> make instances of Packet for them
11:42:01 <Cale> and make an instance of Packet for BigEndian a where a is in Packet.
11:42:39 <Cale> You might need to add an additional class method to determine the number of Word8's eaten by reading a particular type in order to implement that
11:42:49 <Cale> but it will simply amount to reversing the string
11:42:55 <wagerlabs> Cale: sounds like i won't need the endian stuff i was writing then
11:43:03 <wagerlabs> Cale: cause that's storable-specific
11:43:10 <wagerlabs> Cale: or do I?
11:43:27 <Cale> yeah, but you will want the TH code for determining endianness of the platform
11:43:49 <wagerlabs> Cale: how do i convert [Word8] to Float for example?
11:45:23 <wagerlabs> Cale: wouldn't doing it with storables be easier?
11:45:38 <sylvan> (Word8,Word8,Word8) -> Word32  first
11:45:41 <sylvan> then fromIntegral, I guess
11:45:49 <wagerlabs> plus, [Word8] might not prove to be the optimal base
11:45:50 <michael> huh?
11:45:56 <wagerlabs> could prove to be a bit slow
11:45:58 <michael> fromIntegral?
11:46:04 <wagerlabs> whereas Storable reads from memory
11:46:35 <sylvan> fromIntegral takes any integral value (like Word16) and returns a Numeric value
11:46:49 <Cale> [Word8] shouldn't be slow if you can consume the list efficiently
11:46:53 <sylvan> @eval fromIntegral (4 :: Word15) :: Double
11:46:58 <lambdabot>  Not in scope: type constructor or class `Word15'
11:47:00 <sylvan> @eval fromIntegral (4 :: Word16) :: Double
11:47:02 <lambdabot> 4.0
11:47:06 <sylvan> @eval fromIntegral (4 :: Word32) :: Double
11:47:08 <Cale> however, you may want to use storable to do some of the conversions
11:47:08 <lambdabot> 4.0
11:47:35 <michael> not quite what you would want it to be, or is it_
11:48:03 <sylvan> michael, you're talking to me?
11:48:07 <michael> yeah
11:48:15 <sylvan> yeah that's the expected result
11:48:21 <sylvan> fromIntegral converts between integral values and numeric values
11:48:36 <Lemmih> sylvan: That's not what wagerlabs wants.
11:48:39 <michael> but the Word32 is 32-bit float.
11:48:42 <wagerlabs> Cale: do you dislike storables?
11:48:49 <sylvan> ah
11:48:54 <Cale> wagerlabs: well, Storable is for FFI, really
11:48:58 <sylvan> sorry.. I should have read further back
11:49:10 <michael> sylvan, you would want the equivalent of *(float32*)&myWord32
11:49:17 <Cale> You might be able to make use of it, but it doesn't seem perfectly suited.
11:49:21 <wagerlabs> i don't see how redefining a bunch of stuff would be easier than just defining peek and poke for each record :D with the exception of advancing the pointer of course
11:49:34 <sylvan> you could do it manually by extracting the mantissa and exponent and then using math operations, but that's just a hack =)
11:49:36 <wagerlabs> Cale: hmm
11:49:48 <Cale> wagerlabs: you also have to put the packets into an array first
11:50:02 <wagerlabs> Cale: at what point?
11:50:04 <michael> sylvan: somewhere along the last lines he seemed concerned about speed ;)
11:50:04 <Cale> and not a Haskell Array, but an FFI array
11:50:12 <sylvan> =)
11:50:14 <wagerlabs> sylvan: yeah, i'd rather not do it myself (float)
11:50:19 <wagerlabs> Cale: that's easy
11:50:30 <wagerlabs> with Storable
11:50:34 <Cale> wagerlabs: but it's not exactly transparent :)
11:50:36 <wagerlabs> will allocate it for me
11:50:39 <Cale> yeah
11:51:15 <wagerlabs> cale: i can't read a Float from [Word8] so it's not a complete solution. i would be mixing storables with other things all over the place
11:51:20 <wagerlabs> Cale: doesn't sound optimal
11:51:35 <Cale> hang on a sec :)
11:52:28 <Cale> what about encodeFloat/decodeFloat?
11:52:44 <wagerlabs> Cale: what about them?
11:52:48 <wagerlabs> need to look them up
11:53:31 <sylvan> @hoogle encodeFloat
11:53:33 <lambdabot> Prelude.encodeFloat :: Integer -> Int -> a
11:53:33 <wagerlabs> Cale: how do i use that with [Word8]?
11:53:52 <wagerlabs> it takes an Integer and returns an Int? no... that's wrong
11:54:15 <sylvan> Hmm.. Maybe the Int is the size of the float
11:54:26 <sylvan> docs?
11:55:10 <sylvan> ah it's the mantissa and exponent
11:55:16 <Cale> well, it's somewhat awkward to use, I suppose
11:56:01 <Cale> but that gives you the significand and exponent
11:56:25 <wagerlabs> life sucks
11:56:49 <wagerlabs> Storable is winning
11:56:54 <Cale> well, you can use Storable to convert them I suppose
11:57:01 <Cale> You could do both
11:57:07 <wagerlabs> hope is not lost, though, as Cale comes to the rescue
11:57:12 <Cale> use Storable for converting numbers
11:57:23 <wagerlabs> Cale: why would i bother with [Word8] then?
11:57:37 <wagerlabs> Cale: i could use Storable for everything else as well
11:57:55 <Cale> Well, that seems awkward for larger parsing tasks
11:57:56 <wagerlabs> i need to use it for Floats and Endians already :-)
11:57:58 <Cale> but okay
11:58:00 <Cale> you could
11:58:13 <Cale> Well, you wouldn't need it for endians
11:58:19 <wagerlabs> Cale: it does seem awkward but i don't see a more elegant solution yet
11:58:30 <Cale> It's much much simpler to handle endians from the [Word8]
11:58:50 <michael> @hoogle Storable
11:58:55 <Cale> you just chop off the bit of the list you'll be interested in and reverse it
11:59:05 <wagerlabs> Cale: true
11:59:32 <Cale> and then pass it to the code that handles that type of packet
11:59:41 <wagerlabs> Cale: well, if you can give me a encode/decodeFloat to/from [Word8] then i would gladly use the approach
12:00:52 <wagerlabs> Cale: also, didn't you say concatBits wasn't particularly efficient?
12:01:55 <Cale> right -- you could basically use Foreign.Storable and such to write the Packet instances
12:02:43 <wagerlabs> Cale: but i like elegant approaches :D
12:03:07 <wagerlabs> Cale: i wonder if damage can be limited to encodeFloat/decodeFloat that works with [Word8]
12:03:56 <wagerlabs> Cale: i don't know haskell well enough to write these functions, though
12:04:36 <Cale> encodeFloat/decodeFloat are particularly irritating, because you end up writing code that depends on the floating point representation.
12:04:37 <wagerlabs> as a workaround maybe that [word8] could be packed into a FastString, a C pointer obtained from that and Storable used on that C pointer to get the float
12:05:01 <wagerlabs> then presto, you have your Float from [Word8]
12:05:20 <Cale> yeah, something like that
12:05:27 <wagerlabs> it's well known that Float is 4 bytes and Double is 8
12:06:24 <wagerlabs> cale: question
12:06:49 <wagerlabs> suppose i have
12:06:50 <wagerlabs> data CommandProcType
12:06:50 <wagerlabs>     = Invalid
12:06:50 <wagerlabs>       | Server
12:06:50 <wagerlabs>       | Client
12:07:34 <wagerlabs> and it's an instance of enum so i have toEnum/fromEnum, how would I store that to [Word8]? convert fromEnum to Int and then stick it into a Word8, Word16, etc?
12:07:51 <wagerlabs> cale: which function is the opposite to fromIntegral?
12:07:53 <Cale> Yeah
12:08:03 <Cale> opposite?
12:08:18 <wagerlabs> well, i assume i can't just assign an Int to a Word8, can I?
12:08:18 <Cale> round?
12:08:22 <Cale> sure
12:08:26 <Cale> fromIntegral
12:08:35 <Cale> Int and Word8 are both Integral types
12:08:53 <michael> (which I thought was really cute the first time I realized :)
12:09:01 <Cale> so you can convert between them at will with fromIntegral
12:09:03 <wagerlabs> Word8 = fromIntegral Int? so what's fromIntegral, a type-cast of sorts? a lift function?
12:09:19 <Cale> fromIntegral can't be applied to types :)
12:09:24 <Cale> but yeah
12:09:35 <Cale> fromIntegral :: (Num b, Integral a) => a -> b
12:10:21 <Cale> so it converts an integral value to a number of any type
12:11:09 <wagerlabs> instance Packet Word16 where
12:11:09 <wagerlabs>     readPacket xs = let (ys, zs) = splitAt 2 xs in (concatBits ys, zs)
12:11:16 <wagerlabs> how do i write a readPacket from this?
12:11:31 <Cale> for what?
12:11:33 <Cale> Int?
12:11:36 <wagerlabs> i.e. how do i split a Word16 into two Word8s? shifts, etc?
12:12:03 <wagerlabs> Cale: well, i would need to store my fields into a [Word8] so that it can be packed into a FastString and dumped to a Handle, right?
12:12:05 <michael> foo&0xff, foo>>8
12:12:20 <wagerlabs> Cale: writePacket, sorry
12:12:40 <Cale> yeah, what michael said :)
12:12:51 <wagerlabs> NewBinary.Binary has all these functions
12:12:53 <Cale> of course, using the operations in Data.Bits
12:13:08 <Cale> or NewBinary.Binary, whatever that is :)
12:13:31 <wagerlabs> what sucks is that you end up implementing another NewBinary
12:13:38 <wagerlabs> by copy-pasting all the code from there
12:14:11 <Cale> oh hang on
12:14:19 <wagerlabs> except they are doing it on top of arrays
12:14:53 <Cale> ah, we should petition for a Data.Bits instance for Float and Double :)
12:15:13 <wagerlabs> NewBinary does not have code for Float and Double
12:15:25 <Cale> oh, I suppose it doesn't have casts anyway
12:15:35 <wagerlabs> Cale: do you think what you are suggesting can be implemented on top of NewBinary instead?
12:15:58 <wagerlabs> Cale: because otherwise you are using a different backing store and reimplementing all the NewBinary functions
12:16:22 <Cale> oh, quite possibly
12:16:27 <wagerlabs> Cale: it also looks like they took care of advancing the pointer
12:16:28 <Cale> http://www.isi.edu/~hdaume/haskell/NewBinary/Binary.hs
12:16:35 <Cale> is that what you're talking about?
12:17:02 <wagerlabs> yes
12:17:04 <Cale> jeez there's some ugly looking code in there :)
12:17:18 <wagerlabs> Cale: it does the trick, though :)
12:17:24 <Cale> yeah
12:17:36 <Cale> better that it be sealed away in a module that someone else writes :)
12:17:38 <wagerlabs> i would basically need to redo
12:17:40 <wagerlabs> instance Binary Word16 where
12:17:40 <wagerlabs>   put_ h w = do -- XXX too slow.. inline putWord8?
12:17:41 <wagerlabs>     putByte h (fromIntegral (w `shiftR` 8))
12:17:41 <wagerlabs>     putByte h (fromIntegral (w .&. 0xff))
12:17:41 <wagerlabs>   get h = do
12:17:44 <wagerlabs>     w1 <- getWord8 h
12:17:46 <wagerlabs>     w2 <- getWord8 h
12:17:49 <wagerlabs>     return $! ((fromIntegral w1 `shiftL` 8) .|. fromIntegral w2)
12:17:54 <wagerlabs> to store into [Word8]
12:18:18 <wagerlabs> maybe it's better to devise a way to do things on top of NewBinary
12:18:21 <Cale> well, first of all, how are you getting your network stream?
12:18:34 <wagerlabs> Handle from Socket
12:18:38 <Cale> okay
12:18:58 <wagerlabs> i see they require the Handle to be seekable but... i can just as well get the block of memory from the socket and open a BinIO handle into that
12:19:07 <wagerlabs> openBinMem
12:19:10 <Cale> okay
12:19:14 <xerox> hSetBuf/hGetBuf
12:19:14 <xerox> ?
12:19:30 <Cale> instance Binary a => Binary [a]
12:19:35 <Cale> that's usful
12:19:39 <Cale> useful*
12:19:40 <wagerlabs> Cale: how?
12:19:57 <wagerlabs> Cale: that's a list of Binary fields sort of, right?
12:20:10 <Cale> yep
12:20:15 <Cale> instance Binary Word8 too
12:20:19 <wagerlabs> Cale: how would i elegantly do Endian on top of NewBinary? reimplement all the IO functions again?
12:20:49 <Cale> Write an instance (Binary a) => Binary (Endian a)
12:20:51 <wagerlabs> Cale: that is the primitive reads and writes
12:21:16 <wagerlabs> Cale: but how would i know how many bytes to reverse?
12:21:22 <Cale> that's the trouble
12:21:25 <Cale> hmm
12:21:45 <Cale> the Binary class doesn't seem to have a way to tell you, or does it?
12:22:01 <wagerlabs> i'm looking
12:22:05 <wagerlabs> seems unlikely so far
12:24:00 <wagerlabs> Cale: take a look at instance Binary Integer where
12:24:11 <wagerlabs> they are doing some funky stuff with a byte array that includes sizing it
12:24:57 <Cale> Well, we know the sizes of these things...
12:25:20 <Cale> at worst we just need a new class that keeps track of the sizes for us, if they don't do that
12:25:37 <wagerlabs> Cale: they don't
12:26:09 <wagerlabs> and if you stick with knowing sizes than you will need to implement reversing code for each type
12:26:16 <Cale> class ByteSized a where byteLength :: Integer
12:26:46 <wagerlabs> Cale: ok, and then?
12:27:08 <Cale> instance (ByteSized a, Binary a) => Binary (Endian a)
12:27:39 <wagerlabs> hmm
12:28:14 <wagerlabs> Cale: and how do you reverse then? allocate a new memory buffer, store, allocate a new memory buffer, reverse?
12:28:39 <Cale> well, I'm staring at this library -- is there Haddock for it?
12:28:57 <wagerlabs> Cale: now idea. I assume you are talking about NewBinary
12:29:02 <Cale> (or other reasonable documentation)
12:31:21 <Cale> hmm
12:31:48 <wagerlabs> i'm lost
12:31:56 <wagerlabs> i can't figure out the reverse
12:32:29 <wagerlabs> apart from opening a handle into the memory, getting a byte array, reversing the bytes, storing back into the binary handle to memory and reading the real type
12:32:30 <Cale> maybe create a buffer, put the value into it, then get it as a list of Word8's
12:32:33 <Cale> reverse that list
12:32:39 <Cale> and then write it back to the buffer
12:32:49 <Cale> er
12:33:05 <Cale> sorry
12:33:36 <Cale> just copy the bytes as Word8's to a new buffer, in reverse, then read them as the other type
12:33:45 <Cale> (a in Endian a)
12:34:32 <Cale> How do we get a BinHandle to a chunk of memory?
12:34:39 <wagerlabs> openBinMem
12:37:21 <wagerlabs> Cale: you can read a byte array from that handle
12:37:27 <wagerlabs> with getByteArray
12:37:29 <Cale> what the heck is the type Module? Certainly not what it is in the libraries
12:37:49 <Cale> oh, that type signature is commented out anyway
12:38:09 <Cale> also, that parameter is completely unused
12:38:13 <wagerlabs> Cale: there's even code for FastStrings in there, commented out for some reason
12:39:36 <wagerlabs> Cale: what are you up to?
12:40:06 <Cale> reading the source for NewBinary
12:43:18 * wagerlabs is waiting for cale's expert opinion
12:44:20 <Cale> I say read some memory
12:44:23 <wagerlabs> i'm sick and tired of figuring out what ought to be simple :( i just hope that the parts of haskell that do not concern io are gonna give me that boost in productivity
12:44:38 <Cale> er, read some of the stream in bytes
12:44:53 <Cale> then reverse them as a list
12:44:53 <michael> wagerlabs, how about writing an article for TMR once you got everything sorted out?
12:44:59 <michael> i'm sure it would be very welcome
12:45:06 <Cale> then put them into a new memory buffer
12:45:16 <wagerlabs> Cale: sure, i always have a 32bit int that's the size of the packet, this comes first. it's little-endian too
12:45:18 <Cale> then read that memory buffer as whatever type you need
12:45:23 <wagerlabs> michael: i will, once i sort it out
12:46:03 <wagerlabs> Cale: using what approach? NewBinary? Storable? [Word8]?
12:46:22 <ValarQ> psi: wb
12:47:03 <michael> wagerlabs: awesome :)
12:47:04 <Cale> wagerlabs: I was describing for NewBinary
12:47:05 <psi> ty ;)
12:47:13 <ValarQ> :)
12:47:24 <wagerlabs> Cale: right. so how do i convert from little-endian to host order?
12:49:45 <Cale> hmmm
12:51:01 <wagerlabs> Cale: implement LittleEndian primitive types and then BigEndian primitive types and the associated put_ and get?
12:51:01 <wagerlabs> Cale: or the ByteSizeable approach?
12:51:30 <Cale> The goal if you have endian things should just be to turn whatever structure you have into a bunch of Word8's so that it can be reversed
12:51:58 <wagerlabs>  Cale: ok so...
12:53:09 <xerox> Whoa, this discussion is lasting hours :)
12:53:12 <Cale> the trick to not writing a million instances is to have a parametric Endian type which becomes an instance of whatever binary data handling class you're concerned with.
12:53:38 <wagerlabs> Cale: would you pass Endianness in as a tag or have BigEndian and LittleEndian?
12:53:50 <Cale> Not as a value tag
12:53:57 <Cale> but perhaps as a type tag
12:54:05 <Cale> Like you might do
12:54:26 <wagerlabs> lets see
12:54:38 <wagerlabs> data ByteOrder = BigEndian | LittleEndian deriving (Show, Eq, Ord)
12:54:38 <wagerlabs> data Endian a = MkEndian a ByteOrder deriving (Show, Eq, Ord)
12:54:41 <wagerlabs> like this you mean?
12:54:51 <Cale> yes, something like that
12:55:00 <Cale> uh no
12:55:03 <Cale> sorry :)
12:55:19 <Cale> data BigEndian = BigEndian
12:55:26 <Cale> data LittleEndian = LittleEndian
12:55:36 <Cale> class End a where hostMatches :: Bool
12:55:55 <wagerlabs> Cale: and then?
12:56:13 <wagerlabs> Cale: i suppose you would have a separate reverse function and use it in both instances?
12:56:36 <Cale> data (End a) => Endian a b = Endian a b
12:57:02 <wagerlabs> what's b?
12:57:09 <wagerlabs> ah, the value
12:57:14 <wagerlabs> End is byte order
12:57:16 <Cale> It's sort of odd
12:57:28 <Cale> Since there are essentially only two byte orders
12:57:49 <Cale> you probably should just have separate BigEndian a and LittleEndian a types
12:57:52 <Cale> i.e.
12:58:03 <Cale> data BigEndian a = BigEndian a
12:58:08 <wagerlabs> Cale: would you need a ByteSizeable type?
12:58:10 <Cale> data LittleEndian a = LittleEndian a
12:58:24 <Cale> A ByteSizable class, possibly
12:58:39 <Cale> Values belong to types and types belong to classes :)
12:59:23 <Cale> You need to know the sizes of things in order to treat them uniformly when swapping their bytes
12:59:53 <wagerlabs> Cale: so i would need to make Word8, Word16, etc. instances of ByteSizeable?
12:59:58 <Cale> yes
13:00:23 <Cale> anything which you want to be able to swap the order of with Endian
13:01:29 <wagerlabs> class ByteSized a where byteSize :: Integer
13:01:30 <wagerlabs> instance ByteSized Word8 where
13:01:30 <wagerlabs>     byteSize = 1
13:01:32 <wagerlabs> like this?
13:02:15 <Cale> yeah
13:02:42 <wagerlabs> how do i convert a byte array from NewBinary to a [Word8], reverse and convert back to byte array for storage?
13:03:43 <wagerlabs> i think that's one thing i'm missing and the other one is how to get the pointer to the current position in the NewBinary buffer
13:04:39 <wagerlabs> tellBin gives the current position as a BinPtr
13:05:25 <Cale> Haskell doesn't tend to get used for manipulating binary data that often, can you tell? ;)
13:05:57 <wagerlabs> Cale: i can already
13:06:02 <wagerlabs> Cale: BinPtr is that a pointer?
13:06:14 <wagerlabs> data Bin a = BinPtr !Int !Int -- byte/bit
13:06:14 <wagerlabs>   deriving (Eq, Ord, Show, Bounded)
13:06:17 <Cale> data Bin a = BinPtr !Int !Int -- byte/bit
13:06:30 <Cale> I suppose it's just an index
13:06:34 <wagerlabs> I mean, I wonder if it can be converted to a Ptr suitable for Storable. to read the float
13:06:39 <Cale> to a particular byte/bit we're looking at
13:06:45 <Cale> oh, not easily
13:07:06 <Cale> first problem is that it has higher resolution than that sort of pointer
13:07:18 <xerox> Write the whole thing in C and foreign import it? :)
13:07:24 <Cale> heh
13:07:34 <Cale> I was actually thinking about what one could do
13:07:58 <Cale> You could basically do that with Storables.
13:08:06 <Lemmih> I must be missing something. You want to load some data and convert it from little endian to host endian?
13:08:12 <wagerlabs> Cale: do what?
13:08:48 <wagerlabs> Lemmih: i think we are going higher level now :) we have advanced to packets to realize that we need a better way to read the fields
13:09:00 <wagerlabs> i think that's what happened
13:09:01 <Cale> wagerlabs: Load the thing into a chunk of allocatd memory and call a C function on it which does the translation, then read it back as whatever.
13:09:20 <wagerlabs> Cale: load what thing?
13:09:33 <Cale> the chunk of bytes that's in the wrong order
13:09:40 <Cale> (or potentially wrong order)
13:10:32 <wagerlabs> Cale: i can already do this with a Storable, you wrote that code ;)
13:10:46 <wagerlabs> Cale: no need to go to C. the question is how to get to that chunk of memory with NewBinary
13:15:59 <wagerlabs> cale?
13:17:08 <Cale> I can't see a direct way
13:17:17 <Cale> though I don't really know how NewBinary works
13:18:35 <wagerlabs> this is frustrating stuff :(
13:22:07 <wagerlabs> Cale: thanks for all your help. I'm going back to Storable. `plusPtr` is my friend
13:22:18 <Cale> okay
13:22:26 <Cale> yeah, NewBinary looks awkward to me
13:22:43 <wagerlabs> Cale: I wish there was a standard solution to my problem
13:22:44 <Cale> It's undocumented, and quite rough looking
13:22:52 <Cale> yeah, well, maybe we'll come up with one :)
13:33:12 <wagerlabs> newByteArray :: Int# -> IO MBA
13:33:13 <wagerlabs> newByteArray sz = IO $ \s ->
13:33:13 <wagerlabs>   case newByteArray# sz s of { (# s, arr #) ->
13:33:13 <wagerlabs>   (# s, MBA arr #) }
13:33:20 <wagerlabs> what's the point of the case here?
13:33:27 <wagerlabs> throw an error if something is wrong?
13:34:08 <michael> pattern matching I guess
13:34:13 <basti_> wagerlabs: no, just destructing the constructor.
13:34:21 <wagerlabs> basti_: huh?
13:34:36 <basti_> you can't get things out of a constructor other than matching against it
13:34:38 <michael> wagerlabs: alternative ways would be .. where .. and let .. in ..
13:34:54 <wagerlabs> can't you just assign to a tuple?
13:35:03 <basti_> and an obvious way to do that is a case alternative, even if there is no alternative
13:35:12 <wagerlabs> (# s, arr #) = newByteArray# sz s
13:35:16 <wagerlabs> oh, i get it now
13:35:18 <michael> no
13:35:29 <michael> let whatyouwrote in .. would work
13:35:29 <wagerlabs> it's indeed destructing the constructor
13:35:33 <michael> :)
13:35:41 <wagerlabs> what are the #?
13:35:47 <michael> strictness annotations, maybe?
13:35:50 <wagerlabs> like what's # s and arra #?
13:36:02 <wagerlabs> and why # in front of s and after arr? wierd
13:36:02 <TheHunter> (# s, arr #) is an unboxed tuple.
13:36:11 <michael> ahh yep
13:36:13 <wagerlabs> wow!
13:36:16 <wagerlabs> he
13:36:28 <wagerlabs> what's an unboxed tuple?
13:36:33 <wagerlabs> as opposed to a boxed one
13:36:48 <TheHunter> one that has no extra "bottoms"
13:37:07 <wagerlabs> what are the extra bottoms?
13:37:19 <TheHunter> \(# x,y #) -> ... is simply illegal, btw.
13:37:27 <wagerlabs> in this scenario
13:37:27 <wagerlabs> newByteArray sz = IO $ \s ->
13:37:27 <wagerlabs>   case newByteArray# sz s of { (# s, arr #) ->
13:37:27 <wagerlabs>   (# s, MBA arr #) }
13:37:50 <wagerlabs> what is s? seems like an argument
13:38:17 <wagerlabs> it's something that's part of NewByteArray it looks like
13:38:28 <TheHunter> something of type (a, b) can either be a pair of an a and a b or it can be a bottom, i.e. undefined, error... or it can be a thunk
13:38:37 <TheHunter> (# a, b#) is always a pair.
13:38:48 <wagerlabs> TheHunter: got it
13:38:55 <wagerlabs> what's s above though?
13:39:07 <TheHunter> but it probably only valid if a and b are themselves unboxed.
13:39:09 <wagerlabs> i mean, how do i read this?
13:39:10 <wagerlabs> newByteArray sz = IO $ \s ->
13:39:10 <wagerlabs>   case newByteArray# sz s of { (# s, arr #) ->
13:39:10 <wagerlabs>   (# s, MBA arr #) }
13:39:21 <wagerlabs> IO $ ? why not do { ?
13:39:37 <TheHunter> hm?
13:40:01 <TheHunter> you have to look up the internal representation of IO.
13:40:23 <wagerlabs> what's an Int#?
13:40:29 <pesco> Is this right? (a, b, c) ~ "pointer to three things"  --  (# a, b, c #) ~ "just three things in consecutive memory"
13:40:29 <TheHunter> an unboxed Int
13:40:33 <wagerlabs> newByteArray :: Int# -> IO MBA
13:40:50 <TheHunter> pesco, yes.
13:40:58 <TheHunter> at least that's how understand it.
13:41:12 <pesco> Okay. I'll mark it as "supported by one vote".
13:41:14 <pesco> ;)
13:41:39 <wagerlabs> top prize goes to the person who can figure out how to get a Ptr from a newByteArray
13:42:19 <TheHunter> what's the type of arr?
13:42:49 <wagerlabs> http://www.isi.edu/~hdaume/haskell/NewBinary/Binary.hs
13:44:14 <TheHunter> MutableByteArray# probably might be a pointer.
13:44:21 <TheHunter> @index MutableByteArray#
13:44:22 <lambdabot> bzzt
13:44:41 <wagerlabs> type BinArray = MutableByteArray RealWorld Int
13:44:52 <wagerlabs> isn't MBA just a constructor for BinArray?
13:45:24 <TheHunter> MBA is a box around a MutableByteArray#
13:45:36 <TheHunter> and god knows where MutableByteArray# is defined.
13:46:30 <wagerlabs> http://www.haskell.org/hdirect/ffi-6.html
13:47:04 <wagerlabs> GHC's ByteArray and MutableByteArray primitive types are (im)mutable chunks of memory allocated on the Haskell heap, and pointers to these can be passed to foreign imported external functions provided they are marked as unsafe.
13:47:12 <TheHunter> anyone care to resolve haskell.org for me?
13:47:43 <wagerlabs> haskell.org.            10800   IN      A       128.36.229.215
13:48:11 <wagerlabs> TheHunter: does this mean I can pass MBA as a pointer to Storable's peek?
13:49:21 <TheHunter> @index MutableByteArray
13:49:22 <lambdabot> bzzt
13:52:06 <TheHunter> i don't know enough on how ghc represents arrays, and which functions one should use to convert them into pointers.
13:52:32 <TheHunter> and whether that is advisable at all.
13:53:02 <poetix> gnah - libobby-0.3.0 parameterises its basic classes by <selector_type>, whatever the heck that is
13:53:08 <poetix> Everything's broken!
13:54:00 <michael> IIRC it was a bitset parameter for an overdesigned iterator?
13:54:03 <michael> I could be mistaken.
13:55:21 <poetix> Unlikely in this context
13:59:03 <poetix> I suppose I just have to ask on the mailing list
13:59:11 <michael> *emerges darcs*
13:59:31 <poetix> The temptation at this point to write a pure Haskell shared document buffer implementation, and sod compatibility with anything else, is pretty strong
14:01:26 <michael> :)
14:01:40 <michael> is that for yi/hIDE?
14:03:57 <poetix> Originally it was just for the fun of it. But I think it would be a good thing for hIDE to have.
14:04:28 <poetix> The trouble with libobby is, it's written in C++, and for FFI purposes I need a plain C API.
14:05:06 <poetix> I was working on one, and making a bit of progress. But now they've parameterised several of the basic classes, which is just an immense pain.
14:05:13 <michael> I agree, C++ is a bit of a pain as a FFI "target".
14:06:10 <poetix> I don't know if there exists a better approach with templated code than writing a separate plain C function for every type one might want to parameterise the class with.
14:06:55 <michael> I don't think so. What is this selector_type about? (Don't have darcs yet, can't look for my own, and I don't remember :|).
14:07:11 <poetix> I might just have to earn my FFI scout badge doing something less masochistic
14:07:47 <malcolm>  what does libobby do?
14:07:59 <michael> Providing shared buffers.
14:08:03 <poetix> On the other hand, if <selector_type> will always be one of about three types, it might be sort of OK - I guess I have to wait and see what the developers say about it (since it's far from obvious from just reading the code)
14:08:38 <poetix> It's a nice little library, and gobby (which is written on top of it) is a terrific application.
14:08:46 <malcolm> shared buffers over files?
14:08:56 <michael> Preferrably you could convince them of maintaining the C bindings you started.
14:09:04 <poetix> Shared buffers over a network. For collaborative editing.
14:09:05 <michael> malcolm, buffers for collaborative editing.
14:09:21 <michael> tuple programming :-)
14:09:33 <xerox> tuple programming, yay
14:09:41 <xerox> n-tuple programming, even
14:09:59 <poetix> Heh, I was explaining tuple spaces to someone earlier
14:10:20 <malcolm> linda-style
14:10:58 <poetix> I wrote a Python implementation that works with 3-tuples, and has two extra operations: graph-collect and graph-copy-collect
14:11:29 <poetix> It allows you to do copy-collect operations on all triples joined in the same RDF graph
14:12:10 <poetix> I still don't know if this was a fabulously great idea, or a fabulously pointless one. It was fun to write, anyhow.
14:21:11 <SamB> anybody here hack on wxHaskell?
14:24:59 <michael> poetix: apparently the reason is that win32/posix require a different selector (I guess that means something like select()?)
14:25:09 <michael> gr.
14:25:30 <SamB> what are you talking about?
14:25:36 <malcolm> SamB: I've been using wxhaskell a bit recently
14:26:16 <michael> SamB: libobby.
14:26:22 <SamB> malcolm: hmm, I don't suppose you've figured out how to set the initial value of a spinCtrl properly?
14:26:29 * rep yawns
14:26:36 <SamB> @google libobby
14:26:57 <malcolm> SamB: haven't used a spinCtrl - what does it do?
14:27:07 <z0d> dons: http://www.cse.unsw.edu.au/~dons/lambdabot/ is a 403. is that intentional?
14:27:17 <michael> arrow up/down for changing a typically numerical value
14:27:32 <dblhelix> is there some kind of library that enables implementing ghci-like shells, i.e., environments that have a map of strings to commands (:type -> ..., :browse -> ...), complete :ty to :type, have a context-sensitive prompt, allow in-place editing of the current command line, etc.?
14:28:36 <SamB> "hex <- spinCtrl ps 1 maxBound [ selection := inithex ]" for some reason leaves the text field blank...
14:29:08 <malcolm> SamB: I've found some strange things in wxhaskell too
14:29:22 <SamB> and stranger yet, "hex <- spinCtrl ps 1 maxBound [ selection := inithex, text := show inithex ]" results in the textfield starting out with a 1 in it...
14:30:04 <SamB> I guess I'll try and fix it, if nobody knows what I should be doing...
14:30:38 <SamB> and if it turns out not to be a functional bug, I should at least inspire some documentation ;-)
14:31:38 <malcolm> SamB: radiobuttons on menus don't group together (on the mac anyway)
14:32:20 <SamB> malcolm: that doesn't sound very odd
14:32:41 <SamB> I don't think I've ever heard of radiobuttons on menus that *did* group together
14:32:41 <malcolm> SamB: but the documentation says they should
14:32:59 <SamB> malcolm: oh, well then thats different ;-)
14:33:15 <SamB> or maybe :-(
14:33:19 <malcolm> SamB: otherwise they aren't radio buttons, they are just checkboxes
14:33:41 <SamB> malcolm: oh, you mean they don't act as a group?
14:34:02 <SamB> let me try your code!
14:34:04 <malcolm> SamB: yeah, they each have individual settings (up.down)
14:34:25 <SamB> if it doesn't work here either, maybe you just aren't doing it right?
14:36:04 <malcolm> SamB: well I decided I wanted tickboxes instead anyway :-)
14:36:15 <SamB> malcolm: oh
14:37:07 <malcolm> SamB: and in any case, most of the code isn't mine.  I'm just hacking on it, but am not free to release it, at least until i discuss that with the owner.
14:37:33 <rep> so i'm trying to create 500000 os threads.
14:37:40 <rep> it takes a while.
14:38:05 <rep> and it uses _a lot_ of memory
14:38:08 <rep>  7292 ssouhlal  125    0  7190M  6134M CPU1   1   6:03 59.33% create
14:38:53 <wilx> Heh.
14:39:30 <rep> (with the minimum stack size)
14:40:12 <rep> almost 8G resident :P
14:40:14 <rep>  7292 ssouhlal  127    0  8717M  7267M CPU1   0   7:59  1.90% create
14:40:24 <rep> it finished creating them :D
14:41:52 <ValarQ> rep: why would anybody want so many threads?
14:41:59 <rep> i wonder :)
14:42:30 <SamB> especially OS threads?
14:42:58 <rep> i wanted to see how many OS threads i could create
14:43:01 <ValarQ> i find it difficult enough to manage one process...
14:43:16 <ValarQ> rep: i see...
14:43:34 <rep> 500000 is pretty good, i think :)
14:43:46 <Cale> what sort of machine are you running?
14:43:58 <rep> dual opteron with 8G of ram
14:44:20 <SamB> 500000 is pretty insane, I think
14:45:11 <Cale> heh, it is insane
14:45:22 <ValarQ> i made two pretty interesting programs for a programming article in swedish
14:45:45 <ValarQ> it is a small backdoorlike server written in different languages
14:46:00 <ValarQ> maybe someone can comment my (bad) haskell version?
14:46:19 <ValarQ> http://arda.no-ip.org/server.hs
14:46:49 <shapr> @yow !
14:46:49 <thbot> Couldn't find fortune file
14:46:54 <shapr> aw
14:47:11 <ValarQ> hello shapr
14:47:16 <shapr> greetings ValarQ, how's code?
14:47:26 <ValarQ> shapr: pretty ok
14:47:37 <shapr> inte så daligt?
14:47:44 <ValarQ> shapr: i just asked for some feedback on some code i wrote
14:48:00 <shapr> Which code?
14:48:04 * shapr looks at the logs
14:48:05 <kosmikus> hi shapr!
14:48:12 <Korollary> ValarQ: I've written something similar in haskell. Yours looks cleaner than mine.
14:48:22 <ValarQ> Korollary: ok
14:49:03 <shapr> Cute, what's the article for?
14:49:14 <ValarQ> shapr: different programming languages
14:49:21 <shapr> I want to know which mag so I can buy it.
14:49:22 <ValarQ> shapr: i wrote the haskell and assembler versions
14:49:28 <ValarQ> shapr: it's on the net
14:49:41 <ValarQ> http://arda.no-ip.org/server.asm
14:49:53 <malcolm> kosmikus: did you write the book on Generic Haskell?
14:50:02 <kosmikus> malcolm: which book?
14:50:20 <malcolm> kosmikus: there's more than one?
14:50:34 <kosmikus> malcolm: you mean "Exploring GH"?
14:50:35 <shapr> ValarQ: Yow that's cool!
14:50:43 <shapr> ValarQ: Are you going to write an Erlang version?
14:50:44 <ValarQ> shapr: which of them?
14:51:03 <malcolm> kosmikus: that's it.  I was given it a week or two ago.  Looks interesting.
14:51:07 <shapr> The asm version is cool, I haven't written asm in a very long time.
14:51:09 <ValarQ> shapr: no, my erlang skills isn't very good
14:51:28 <kosmikus> malcolm: yes, that's my phd thesis; I don't usually think of it as a "book", that's why I was asking ...
14:51:55 <malcolm> kosmikus: Well, it has a pretty cover, and lots more chapters than my thesis.
14:51:58 <ValarQ> shapr: asm can be fun, it was quite interesting to compare with :)
14:52:58 <malcolm> kosmikus: My next project (from Jan) is going to involve developing polytypic algorithms for scientific visualisation
14:53:01 <kosmikus> malcolm: this format of publishing a phd thesis is standard in .nl, but it doesn't have a real publisher, and you cannot order it anywhere expect by asking me ;)
14:53:41 <kosmikus> malcolm: Jan?
14:53:43 <ValarQ> shapr: i'm playing around with this thing called "MonadPlus" now
14:53:50 <malcolm> kosmikus: January
14:53:55 <shapr> I might try writing assembly again if I get access to an STI Cell cpu.
14:56:05 <shapr> MonadPlus is cool. Have you read Mark P. Jones' paper http://www.cse.ogi.edu/~mpj/pubs/springschool.html ?
14:56:11 <SamB> hmm, well it works okay if I say "hex       <-  spinCtrl ps 1 maxBound [ text := show inithex ]"
14:56:23 <malcolm> kosmikus: I don't think I'm going to have time to read your thesis in depth before January.
14:56:43 <ValarQ> shapr: nope, haven't read that paper
14:57:29 <kosmikus> malcolm: sure, that's not very much time to read 350 pages ...
14:57:34 * shapr grins
14:57:39 <shapr> type indexed what?
14:58:15 <malcolm> SamB: maybe [ selection := ... ] means something different, like whether the text should be highlighted?
14:58:30 <shapr> Personally, I think the art in kosmikus' thesis is the most entertaining I've seen in any academic publication :-)
14:58:54 <malcolm> kosmikus: no, I meant I'm not even going to start - too busy.
14:59:22 <ValarQ> where is mr kosmikus's thesis?
15:00:07 <malcolm> shapr: Erik Meijer's thesis was fairly amusing, but not through illustration - he peppered jokes into the formalisms
15:00:30 <shapr> malcolm: ooh, I have to read that.
15:00:30 <malcolm> ValarQ: on my bookshelf :-)
15:00:35 <Korollary> you gotta have some fun writing 350 pages, imho
15:00:38 <shapr> ValarQ: http://www.cs.uu.nl/~andres/ExploringGH.pdf
15:00:50 <malcolm> shapr: do you like bananas, lenses and barbed wire?
15:00:51 <Lor> Wadler's "A taste of linear types" is also hilarious.
15:01:06 <Korollary> the titles give it all away
15:01:22 <shapr> malcolm: Actually, I never finished it, because I don't know the symbols!
15:01:44 <shapr> I got a few pages in, but I got very tired of having to ask on #haskell every four lines.
15:02:06 <ValarQ> malcolm: ow, that thing is a book!
15:02:18 <Korollary> shapr: there needs to be a blog to discuss (page by page) papers
15:02:26 <malcolm> shapr:  (( banana ))  (| lens |)   {[ barbed wire ]}
15:02:30 <shapr> Korollary: Are you teasing me?
15:02:41 * Korollary disappears
15:02:47 * shapr snickers
15:02:56 <shapr> Korollary: You're absolutely right :-)
15:02:59 <rep> ring ring ring bananaphone
15:03:06 <wagerlabs> howdy
15:03:08 <wagerlabs> instance Binary Integer where
15:03:08 <wagerlabs>     put_ bh (S# i#) = do putByte bh 0; put_ bh (I# i#)
15:03:08 <wagerlabs>     put_ bh (J# s# a#) = do
15:03:13 * malcolm wonders where shapr's blog lives
15:03:14 <wagerlabs> what are the S#, J# and I#?
15:03:16 * Korollary coughs *fermat's* cough *last margin* cough
15:03:29 <shapr> malcolm: He's teasing me about my fabled bit of code "Fermat's Last Margin"
15:03:49 <shapr> What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
15:03:57 <shapr> How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs.
15:04:32 <shapr> The name comes from "This is the last margin Fermat would have ever needed."
15:04:42 <malcolm> shapr: I remember when you disappeared from IRC for a whole week writing it.
15:04:50 <shapr> Yeah well..
15:04:54 <shapr> It still isn't finished.
15:05:17 <shapr> Asymptotically complete comes to mind.
15:05:30 <malcolm> shapr: is it going to take as long as Andrew Wiles' proof of Fermat to complete?
15:05:34 <shapr> My blog is here http://www.scannedinavian.com/
15:05:37 <shapr> Gee I hope not.
15:05:57 <shapr> Wasn't that something like six years for the first automated proof, and then another six or seven to make sure?
15:06:10 <Cale> Well, better that than the length of time it took mathematics as a whole to find a proof :)
15:06:10 <Korollary> it wasnt automated iirc
15:06:30 <Cale> the proof isn't automated
15:06:35 <shapr> oh, ok.
15:06:41 <Cale> in fact, Wiles doesn't even use a computer
15:06:49 <shapr> heresy!
15:06:55 <Korollary> automating that proof is actually considered a major task for the theorem provers
15:06:55 <Cale> just pencil and paper
15:07:00 <malcolm> shapr: I was thinking more of the hundreds of years from the original hypothesis
15:07:28 <shapr> oh. yow.
15:09:10 <shapr> At the moment I'm much more enthusiastic about the web publishing idea.
15:09:18 * SamB thinks haddoc ought to spit out the stylesheet before it starts on the HTML
15:10:07 <Korollary> with mathml ?
15:11:56 <SamB> ok, how do you write inline code snippets in haddoc?
15:12:37 <shapr> I've been reading up on Data.Graph and Oleg's Continuated Zippers.
15:12:39 * malcolm thinks he ought to tidy up Haskell2Xml
15:12:45 <Cale> wagerlabs: ouch -- those look like something to do with the internal representation of Integers in haskell.
15:12:50 <shapr> malcolm: yes please!
15:13:19 <shapr> Do you have a blog?
15:13:37 <wagerlabs> Cale: btw, someone already did Binary Float and Binary Double for us :D
15:13:51 <malcolm> shapr: my first post to my blog was today.  Will it last?  who knows
15:14:03 <wagerlabs> Cale: check out http://www.n-heptane.com/nhlab/repos/NewBinary/Tests/BinDouble.hs
15:15:16 <wagerlabs> folks, how do you reverse an array?
15:15:16 <malcolm> http://nhc98.blogspot.com/
15:15:36 <michael> wagerlabs: how is the Binary schminary going? :o)
15:15:51 <wagerlabs> michael: still at it but now almost done
15:15:52 <shapr> haha, THC is a much better name.
15:15:59 * wagerlabs is almost done
15:16:08 <wagerlabs> just need to figure out how to reverse an array of known size
15:16:33 <ValarQ> is there a simple explanation to what a "Functor" is?
15:16:33 <michael> very cool :)
15:16:34 <Korollary> I've done that I think
15:17:17 <wagerlabs> i need code similar to this, NewBinary-style
15:17:17 <wagerlabs> http://www.n-heptane.com/nhlab/repos/NewBinary/Tests/BinDouble.hs
15:17:33 <SamB> wagerlabs: easy enough
15:18:13 <SamB> wagerlabs: I bet it isn't much more efficient than reversing an array of unknown size, though
15:19:07 <sethk> ValarQ, basically a mapping from a function to another function
15:19:31 <lisppaste2> Korollary pasted "reverse" at http://paste.lisp.org/display/12340
15:19:41 <ValarQ> sethk: ok
15:19:46 <Korollary> wagerlabs: that's how I've done it
15:20:23 * malcolm falls gently asleep
15:20:43 * shapr falls over asleep like a marble slab falling out the window.
15:21:02 <wagerlabs> Korollary: what's MyArray?
15:21:20 <wagerlabs> never mind
15:21:23 <wagerlabs> an argument
15:21:30 <wagerlabs> i ought to go to sleep now :-)
15:21:41 <wagerlabs> trouble understanding things
15:21:55 * Korollary pours Mountain Dew for you
15:22:19 * Korollary just read about the relentless gamer that died after 50 hours of online gaming at a cafe
15:22:24 * michael binds shapr 
15:23:52 <cbus> korollary, gonna try and break his record?
15:24:58 <wagerlabs> thank you kind people for putting up with me
15:25:02 <Korollary> cbus: I don't have the stamina anymore. My humble record is 16 hours of RTCW.
15:25:13 <michael> :-)
15:25:14 * wagerlabs rides into the sunrise
15:26:02 <moonlite> I've been programming for 16h straight. The question is. What is more challenging for the body? Gaming or programming.
15:26:16 <Korollary> moonlite: gaming consumes me much quicker
15:26:51 <moonlite> Hm. Seems true. I get stressed up as hell after playing only 30 minutes of quake3
15:27:37 <michael> :D
15:27:43 <cbus> korollary, lol :)
15:27:49 <cbus> moonlite, i would say
15:27:59 <cbus> 24h straight nethack is painfull :)
15:28:04 <moonlite> :)
15:30:28 <Khisanth> hmm eye strain, not as much when coding as when gaming
15:32:22 <Korollary> There are many people who can put in 80 hours of programming work a week. I can't imagine many people playing rocket arena 3 10 hours a day for one week
15:33:27 <SamB> what do I do with wxHaskell patches
15:34:57 <SamB> Korollary: and there are only 7 days a week, too!
15:40:10 <astrolabe> Is one module per file compelled? recommended?
15:43:15 <Lor> compelled.
15:43:34 <astrolabe> thansk
15:44:41 <SamB> having the module name match the filename is nearly compelled, too...
15:46:49 <astrolabe> I guess lots of small modules would be a pain then?
16:02:27 <araujo> Hello!
16:10:51 <SamB> astrolabe: define lots?
16:11:58 <SamB> also, define small
16:12:31 <SamB> and what would be the point of having many modules in one file, anyway? they'd all need to be rebuilt at the same time!
16:14:47 <astrolabe> hmm.  Off the top of my head, how about a module for quaternians implementing addition,opposites, multiplication and inverses only.  That would be quite small.  Wouldn't a big program made of modules that size get unwieldy?
16:16:44 <astrolabe> Perhaps I'm equating modules with C++ classes too strongly.
16:17:56 <SamB> probably quaternians are a bad example
16:18:21 <SamB> and its true that modules are nothing like C++ classes
16:18:40 <SamB> (except for the part where they have their own namespaces, anyway)
16:19:16 <SamB> though they are possibly much more like C++ classes than typeclasses are ;-)
16:21:01 <mcnster> hi
16:21:21 <mcnster> newbie q here...
16:21:43 <mcnster> getting "Non-exhaustive patterns in record update" rt error
16:21:50 <SamB> anyway, I'm not sure what the problem would be with having lots of little modules. in fact, it would probably be better than what tends to happen, which is that some modules get quite large...
16:21:55 <astrolabe> My first effort at haskell came out as a jumble of functions, so I'm trying to modularise more this time.  Using ADTs in particular, but it seems I could take that too far.
16:22:03 <mcnster> but where is the pattern in a record update?
16:22:16 <SamB> if you take it too far, you'll probably be the first to know ;-)
16:22:53 * SamB goes afk now
16:25:14 <mcnster> nm think i see the prob
16:25:21 <mcnster> bah
16:25:56 <astrolabe> hee hee
17:33:18 <araujo> http://dev.gentoo.org/~araujo/stuff/src/Smsh.hs
17:33:51 <araujo> Suggestion, criticism, flames welcome :-]
17:40:23 <rep> do you think google is an evil empire
17:42:15 <int-e> it's an empire of worrying dimensions and that's a fertile ground for evil seeds.
17:42:22 <int-e> I wouldn't say it's evil yet ...
17:43:25 <rep> so you think they'll become evil?
17:43:33 <der_eq> araujo: how to use it? it gives me "smsh: sm.db: openFile: does not exist (No such file or directory)"
17:44:24 <int-e> probably :/
17:44:38 <der_eq> ah: "You need to create a database with the fields for each media:
17:44:39 <der_eq> 	Title:Author:AlbumName:Genre:Year:MediaFilePath"
17:46:09 <rep> int-e why?
17:47:15 <araujo> der_eq, ah yeah :-)
17:48:26 <int-e> rep: it's growing and I believe people are corrupt in general ... so it's only a matter of time. Oh and I'm pessimistic, too.
17:48:30 <der_eq> the parser could be a bit more error-tolerant
17:48:46 <rep> i see
17:48:54 <araujo> der_eq, yeah, i agree
17:49:19 * araujo needs to work the errors better
17:50:42 <araujo> der_eq, doesn't look the man function too messy also?
17:50:48 <araujo> main even
17:51:00 <rep> do you think yahoo is an evil empire
17:51:09 <araujo> rep, no i dont :-P
17:51:26 <der_eq> indeed
17:51:55 <araujo> der_eq, i was thinking probably to split it up into smaller functions.
17:52:23 <araujo> i am not sure if it is the way to go for better code though.
17:53:49 <der_eq> well, there are plenty of possible improvements... automatic db generation, gstreamer bindings, gui support, automatic song rating, db<->songfile syncing etc...
17:54:41 <araujo> haha yeah, a LOT :-]
17:54:55 * araujo would like to get gui support indeed.
17:55:13 <araujo> Let's see how far i can get with this ;-)
17:55:57 <araujo> For the moment, i was thinking also that i probably could get it with readline support.
17:56:08 <der_eq> http://www.gnome.org/projects/rhythmbox/ has a nice gui
17:56:17 * araujo checks
19:20:33 <mcnster> hi
19:20:52 <mcnster> i'm having dreams about monads
19:21:12 <Korollary> awesome
19:22:01 <mcnster> yeah last night there was this big conveyor belt in the sky and these black wrapped kevlar tubular things slotting in
19:23:00 <mcnster> but i'm still too scared to use Monad.State in my code
19:24:00 <dons> moin
19:26:32 <wagle> http://www.cenqua.com/commentator/
19:27:43 <Korollary> neat
20:01:20 * dons fires up hIDE for some hacking
20:19:43 <dons> @bot
20:19:43 <thbot> :)
20:19:47 <dons> grr.
20:19:50 <dons> stupid network
20:23:14 <dons> lambdabot, @bot
20:23:15 <lambdabot> :)
20:23:21 <dons> thbot: @quit
21:01:46 <Korollary> @index log
21:01:48 <lambdabot> Prelude
21:16:33 <dons> @code
21:16:34 <lambdabot> Utils.hs: moveBytes               :: Ptr a -> Ptr a -> Int -> IO ()
21:24:07 <dons> Lemmih, dcoutts, ping
21:24:36 <dons> did we decide on a license for hIDE? GPL?
21:25:14 <dons> I'd like to make sure we license and haddockify all the hIDE code, and am willing to maintainn that
21:25:48 <shocker> what is IO Handle?
21:26:08 <dons> a handle inside the IO monad, shocker
21:26:12 <Korollary> shocker: It's a value of type Handle inside an IO monad
21:26:42 <shocker> hmm
21:27:50 <shocker> i'm trying to open a file then put each line into a list using lines
21:30:44 <Korollary> do {handle <- openFile ".bashrc" ReadMode; let yourList = lines $ hGetContents handle; -- continue with your code }
21:31:00 <shocker> ok thanks
21:41:29 <Korollary> @index fromJust
21:41:30 <lambdabot> Data.Maybe
21:43:41 <shocker> how can i think show the contents of yourList?
21:43:47 <shocker> think=then
21:46:14 <Cale> print yourList
21:46:28 <Cale> or, putStrLn show yourList
21:46:36 <Cale> rather, putStrLn $ show yourList
21:50:40 <Korollary> yeehaa
21:57:22 <dons> dcoutts, Lemmih, ah we decided on LGPL, did we. sounds ok.
22:00:32 <shocker>  The last statement in a 'do' construct must be an expression
22:03:08 <sethk> shocker, check your indentation, first, make sure you don't have any tab/space stuff
22:03:30 <sethk> shocker, do    putStrLn "test"    or something to make sure it actually does work
22:05:03 <shocker> where should the let be indented to?
22:06:35 <sethk> shocker, to the right of the do
22:06:54 <sethk> shocker, you can use terminators instead of indentation when you aren't sure
22:07:13 <sethk> as in    do { something; something; something }
22:07:18 <shocker> ok
22:08:06 <sethk> shocker, usually when I get that "last ... must be an expression" I've screwed up the indentation or left out a ; or something of that sort
22:08:13 <shocker> yep
22:08:41 <shocker> main  = do { x <- openFile "test.hs" ReadMode; let y = lines $ hGetContents x; putStr $ show y }
22:10:28 <shocker> should that work?
22:13:09 <sethk> shocker, I don't think you can use let in that context
22:13:18 <sethk> you can, however, do:
22:13:35 <sethk>     ; y <- return( lines $ hGetContents x)
22:14:00 <sethk> shocker, because of the <- within do you need a monadic value
22:14:11 <sethk> shocker, return x  takes a value x and returns a monad with value x
22:14:22 <shocker> yea
22:14:46 <sethk> shocker, I'm far from an expert but I've been struggling with this lately so I've discovered some of the tricks.
22:14:59 <shocker> ah yea
22:16:04 <shocker> still not working :(
22:16:41 <xerox> shocker: you can use let in a do block - it has a slightly different meaning from the let you use in expressions (if you know Scheme, it's its let*).
22:17:14 <sethk> xerox, does it get a matching "in" ?
22:17:36 <sethk> xerox, that wouldn't seem to make sense, so probably the answer is no
22:19:19 <xerox> It does.
22:20:57 <shocker> main = do { x <- openFile "test.hs" ReadMode; y <- return( lines  hGetContents x); putStrLn $ show y }
22:22:05 <xerox> @plugs do { xs <- let x = 1 :: Int in return (repeat x); return $ take 10 xs } :: Maybe [Int]
22:22:14 <lambdabot> Just [1,1,1,1,1,1,1,1,1,1]
22:22:47 <xerox> I should study Kant!  Don't let me play with Haskell!  :(
22:25:27 <dons> but Kant is all categories, right ;) so is Haskell. hehe.
22:27:10 * xerox hehs
22:28:04 <xerox> I always pass the time before deadlines concentrating completely myself on other things than the subject of the given deadline - darn school.
22:46:30 <Korollary> dons, does hIDE colour --'s within "'s correctly ?
22:47:33 <dons> withing strings, you mean?
22:47:43 <Korollary> yes
22:47:49 <dons> I assume so.
22:47:53 <dons> seems pretty easy
22:48:10 <dons> esp using the ghc-based syntax colouring
22:48:40 <dons> i.e. it's just a StringLit str, so no ambiguity with regexes
22:49:14 <Korollary> I wonder why haskell-mode doesn't because c-mode has no problems with " /* yadda */ "
22:51:49 <dons> hmm. you can't use regexes to handle Haskell's *nested* {- {- -} -} syntax though
22:52:01 <dons> you'd have to call some lisp functoin to parse it.
22:52:11 <Korollary> long live hIDE
22:52:21 <dons> :)
22:53:55 <Korollary> I think the modules in GHC require some consolidation. I just wrote 70 lines of Haskell and had to import 10 modules.
22:55:50 <dons> in GHC? or the hierarchical libraries?
22:56:11 <Korollary> hierarchical libraries
22:59:08 <Korollary> System.Process exports just 8 symbols.
23:00:53 <dons> Korollary, I can confirm that "--" is handled properly :)
23:01:14 <Korollary> @karma hIDE
23:01:15 <lambdabot> hIDE has a karma of 0
23:01:18 <Korollary> lol
23:03:16 <sieni> well, but one could handle them up to some fixed nesting level, such as 30, which Should Be Enough For Everybody :-)
23:04:00 <Korollary> hIDE should have a mode where it fetches the required modules for you and adds them to the import list
23:05:43 <stefanw> and removes unneeded imports
23:05:49 <dons> sieni, nice regexes ;). would be easier to port a haskell lexer to elisp, surely?
23:06:03 <dons> hmm. we could use --dump-minimal-imports from ghc
23:06:11 <dons> seems easy. great idea!
23:06:26 * dons adds it to the hIDE plugins todo list
23:07:12 <stefanw> I remember I used this feature with eclipse and java a lot
23:07:46 <bourbaki> moin
23:08:07 <dons> yeah, I think managing the module systemwould be a useful feature.
23:08:31 <bourbaki> has anyone of you dealt with coalgebras yet and algebraig petri nets?
23:08:37 <bourbaki> -g+c
23:21:33 <dons> stefanw, since all your proofs arC[C[C[C[Ce done... you could add some thoughts to http://www.haskell.org/hawiki/hIDE or http://www.haskell.org/hawiki/hIDE_2fDesign ;)
23:22:22 <sieni> bourbaki: ask your local algebraist :-)
23:22:28 <bourbaki> heh
23:23:10 <bourbaki> well i have the idea that the monad and arrow stuff could be coupled with coalgebras to form something like algebraic petri nets
23:23:14 <bourbaki> just more powerful
23:23:42 <bourbaki> that is one could apply all the arrows to the programs and also you could fold recursions in the programs with anamorphisms and so
23:50:34 <Korollary> @index forkIO
23:50:36 <lambdabot> Control.Concurrent
