00:14:24 <ski_> skew : are you sure you didn't mean 'instance Match a b' ?
00:16:06 <ski_> JohnMeacham,dons,skew(,Cale) : (re 'Set NewtypeOfInt') do you know about 'restricted type synonym' in hugs ?
00:17:28 <JohnMeacham> ski_: I don't think so.
00:17:38 <JohnMeacham> ski_: is there a paper on them somewhere?
00:19:16 <ski_> hm, not sure
00:19:33 <ski_> anyway, they are a bit like a cross of newtype and type
00:19:52 <ski_> type MyInt = Int in foo,bar
00:20:26 <ski_> makes the typesynonym known in definitions of foo and bar, and acts like an abstract newtype everywhere else
00:21:34 <ski_> so, no explicit coercion is needed (so one can coerce (Set Int) to (Set MyInt) painlessy, without unsafeCoerce# + optionally a rewrite rule)
00:21:54 <Cale> hello
00:22:34 <skew> ski_: no, I was trying to write an instance that would only work if two types matched
00:22:53 <skew> the point is that instances can't really match properly on explicitly quantified types
00:26:16 <ski_> hm
00:26:49 <ski_> what do you mean ?
00:27:01 <C-Keen> moin :-)
00:27:28 <skew> instance Match a a should only apply where the two types are the same, like Match Int Int or Match () (), but it doesn't work with Match (forall a . a) (forall a . a)
00:29:39 <ski_> instance Match (forall a. a) (forall. a)   if it would work, would declare an instance of Match where both the two arguments are the absurd type (forall a. a)  (which only has the value _|_ in haskell)
00:29:53 <skew> no
00:29:59 <skew> the instance is Match a a
00:30:21 <ski_> 'instance Match a a' /= 'instance Match (forall a. a) (forall a. a)'
00:30:27 <skew> yes
00:30:50 <ski_> instance Match a a    indeed would define a general instance appying whenever the two arguments are the same type
00:30:56 <skew> the constraints Match Int Int or Match () () are satisfied by that instance, but a constraint Match (forall a . a) (forall a .a) is not
00:31:08 <ski_> (but ghc only allows it if passes extra flag)
00:31:18 <ski_> hm, you meant like that
00:31:52 <ski_> i think that could be because  'instance Match (forall a. a) (forall a. a)' isn't allowed in the first place
00:34:54 <skew> It would be nice for using HList and stuff if explicitly quantified types could at least be matched against each other
00:35:08 <skew> how did HObject handle methods with class constraints on them?
00:40:47 <ski_> i guess one could package them up in new haskell types, in some cases
00:45:53 <skew> another thing I was thinking about was trying to make a typerep that could cover quantified types
00:46:59 <skew> between GADTs and type classes I thought I could get a bit closer, even if maybe you had to abstract out the variable in a newtype
00:49:00 <ProfTeggy> Moin
00:56:20 <JohnMeacham> I am confused by stephane's post to haskell-cafe... I am not sure what he thinks we mean by a new standard... but I don't think it is what he is thinking..
01:00:37 <dblhelix> JohnMeacham: well, I got from it that he thinks that H98 is sufficient for real-world programming, but that the libraries aren't; hence, that we should invest in providing richer libraries rather than a richer language
01:00:51 <dblhelix> JohnMeacham: for the record: I do not share his opinion
01:01:55 <dblhelix> admittedly, I'm more interested in Haskell as a research tool and a research object than as a programming language _an sich_
01:02:30 <JohnMeacham> Yeah, I think perhaps he is used to single source languages, where the built in libraries are a bigger deal. I don't see haskells standard library growing too much. (but the available cabalized libraries will flourish)
01:02:38 <dblhelix> clearly, his main interest is in haskell as a competitive language
01:02:56 <ulfdoz> Yes, I think, dblhelix is right. Especially I think that some language extension like OOHaskell is something, which is different from a progressive developing of a standard.
01:03:58 <JohnMeacham> In any case, no matter how hard I try, I can't be any more users than I am right now. so I can't meet that request of his. and i do write libraries :)
01:05:14 <JohnMeacham> in any case, asking people working on an open project in their spare time to work on something else is pretty silly.
01:05:38 <dblhelix> for me, what counts is that it's been quite a long time that I wrote a .hs file that did not have {-# OPTIONS -fglasgow-exts #-} at the top
01:05:53 <ulfdoz> But the point of the OP is, that there is almost no current haskell program conform to Haskell98.
01:09:12 <JohnMeacham> indeed. there are also very few programs that conform to just ANSI C :) but yeah, we need a new standard.
01:09:47 <ulfdoz> There are also a very few things for which C is a nice lang, I think. :)
01:17:40 <earthy> I gathered a different opinion
01:19:13 <dons> ndm, well at least I tried to write yi in nhc-haskell, but got killed by the lack of concurrency libs
01:19:33 <dons> yi doesn't use any type-hackery that nhc doesn't also provide though :)
01:19:53 <dons> @seen ndm
01:19:54 <lambdabot> I saw ndm leaving #haskell-blah and #haskell 9 hours, 28 minutes and
01:19:54 <lambdabot> 30 seconds ago.
01:19:57 <dons> oh :/
01:20:00 <earthy> that the problem was not even too few libs, but rather libs not being standard across implementations
01:21:01 <earthy> so that the standardization effort should be on new standard library functionality rather than new language features
01:37:58 <musasabi> But the problem of libs being unportable is that they use language features which are not standard.
01:38:20 <musasabi> So to make libraries more portable some addition to the standard could be considered.
01:38:32 <JohnMeacham> yeah.
01:39:33 <kosmikus> I think a major part of the new standard will be to revise the Libraries Report.
01:39:47 <earthy> anyone seen autrijus recently?
01:39:59 <kosmikus> It can't stay as it is anyway, because Hierarchical Libraries seem to be relatively uncontroversial.
01:40:20 * earthy nods
01:42:18 <kosmikus> Stephane is probably right to say that all these other things are very important. But he also says that "languages have been killed by many incompatible versions". This is a situation that we already have with Haskell, not as bad as other languages, but still ...
01:43:32 <JohnMeacham> Yeah, but I don't see many more standard libraries being added (as required). just the current ones rearranged. and a few fundamentals changed. like a new IO library, a better class hierarchy and I'd like to see Data.Typeable and Data.Dynamic (but not Data.Generics) become standard.
01:44:16 <JohnMeacham> kosmikus: the only reason the hierarchical libraries are controversial to me is that they are not standard :)
01:45:34 <kosmikus> well, they are more standard than most other extensions
01:45:43 <kosmikus> they are described in an addendum
01:46:02 <kosmikus> I'd be much happier if more extensions would have such a compiler-independent description
01:46:21 <JohnMeacham> Yeah.
01:46:44 <dblhelix> i think the number of standard libraries should be as small as possible (this goes for any language); hierarchical libraries help structuring useful libs that are not standard and can help facilitating portabillity of those
01:46:58 <kosmikus> And I agree, there probably won't be *many* more libraries, but possibly a few, like you also mentioned, plus a bit of restructuring and cleaning up.
01:49:06 <kosmikus> With the FFI being probably incorporated into the next standard, there also won't be less need to standardize libraries, because a larger number of libraries can then be just reused in all compliant compilers.
01:51:20 <JohnMeacham> Indeed. jhc's prelude is actually almost fully portable. it is based completly on the FFI rather than compiler specific built-ins.
01:52:09 <kosmikus> oh, s/won't/will/
01:52:33 <kosmikus> JohnMeacham: very nice
01:53:26 <JohnMeacham> Yeah. I just added a couple new 'foreign' constructs for importing a C operator and creating a type from a C type.
01:57:25 <ProfTeggy> brb
02:02:09 <JohnMeacham> Hmm.. does anyone know if ghc has to turn case statements into supercombinators when they appear in a lazy context? Hmm.. time to dig through the source...
02:21:28 <musasabi> JohnMeacham: About the class alias proposal, won't the ablity to specify default methods for aliases cause trouble?
02:27:08 <skew> there's no way to do a conditional on a class constraint in an instance declaration, is there?
02:28:09 <int-e> hmm. not sure what you mean - you can do something like instance Num a => Num (Mytype a) where
02:28:21 <skew> like class TestOrd a where testOrd :: a -> Bool, instance (Ord a) => a where testOrd _ = True, instance a where testOrd _ = False
02:28:30 <skew> I think Oleg had some trick for doing a negation
02:28:44 <JohnMeacham> musasabi: no, it just fills in the methods with the defaults as a simple substitution. the hi files would have to keep track of the names of the default methods for aliases, but that shouldn't be difficult, it is all local info.
02:29:04 <musasabi> JohnMeacham: Think about class A a where a :: a -> Int; a _ = 0; class B b where b :: b -> Int; b _ = 1; class alias (A a,B a) => AB a where a _ = 2; First the user defines "foo x = a x" and then "foo x = a x where unused = b x".
02:29:09 <skew> maybe I should hack backtracking into the instance processing
02:29:17 <JohnMeacham> like for instance you can have a class alias for EqOrd and just write the 'compare' and it will fill in the Eq methods as well as the Ord ones.
02:29:58 <int-e> ah. there are some complicated resolution rules for overlapping instances, and a GHC option that allows them http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#instance-overlap
02:30:21 <musasabi> JohnMeacham: The first foo declaration should produce "0" as it has the type "foo :: A a => a -> Int", but the second has they type "foo :: AB a => a -> Int" and produces "2".
02:30:29 <skew> oh, that was instance for not-a-function, not "doesn't have an instance of X"
02:30:43 <JohnMeacham> musasabi: class aliases are not infered. The only time the default methods are used are at class instantiation time, it just uses the defaults assosiated with whatever you place in the instance head.
02:31:08 <int-e> (skew, that was for you)
02:31:13 <skew> Let's see, instances are scoped just like classes, right?
02:31:19 <skew> I mean, just like other imports
02:31:37 <JohnMeacham> but you havn't declared any instances for your classes.
02:32:00 <musasabi> point.
02:33:15 <skew> so it's not really a closed world assumption
02:33:30 * musasabi would like to see a real typelevel lambda, equality, negation and implications - implemented in a simple way. I think they can all be done in GHC with fundeps but the code looks horrible.
02:33:42 <JohnMeacham> once it chooses an instance, it will pull all the methods from its dictionary, which has already been filled in with methods given in the instance or the appropriate default.
02:34:04 <skew> int-e: The unification rule just looks at the instance head
02:35:01 <musasabi> JohnMeacham: ok, that makes more sense then.
02:35:41 <skew> doing a backtracking search when two instances conflict wouldn't change the meaning of any currently valid programs
02:36:07 <JohnMeacham> musasabi: yeah, you can think of it as a smart macro preprocessor. it dosn't change the runtime at all, it just distributes instance declarations across the members of the alias appropriatly.
02:37:22 <dons> musasabi, well , you could write ext-Core programs, they have type-level /\ and application
02:37:57 <dons> or write external-jhc, that would be fun :)
02:39:19 <JohnMeacham> dons: the PTS used by jhc shares a lot of properties with ghc's core based on system F. it would be fairly straightforward to translate between them (but the ghc core will become more verbose due to having to duplicate type info at the type and term level).
02:40:01 <dons> yes, I know :) but JHC uses a much richer type theory, doesn't it?
02:40:11 <dons> wasn't it a lambda cube IR?
02:40:19 <dons> or am I forgetting myself?
02:40:41 <JohnMeacham> but jhc core is a general PTS encompasing the whole calculus of constructions and dependent types and the whole compiler is designed to work on the general language, so you could write just a front end with dependent types and jhc should be able to handle it just fine. (this is not well tested)
02:41:14 <skew> oh, that kind of PTS
02:41:30 <skew> fancy
02:41:31 <JohnMeacham> the lambda cube is a particular PTS. and frankly, I am pretty confused on the terminology myself :)
02:42:24 <JohnMeacham> a 'cayenne' front end would be cool. you can probably use the whole haskell front end and just modify the parser to accept the fancier language and add the appropriate rules in E/FromHs.hs
02:42:44 <shapr> hiya tomaszz
02:43:14 <skew> well, fancy typeclasses won't solve my problem alone. I'll describe what I'm trying to do
02:43:36 <dons> John, are, that's what I thought. like I say to musasabi, writing code in a dependently typed IR would be like writing theorems in Twelf == fun :D
02:43:57 <JohnMeacham> in any case, both lambda cube and PTSs are systems of generating lambda calculi, I am not sure what to call the particular varient jhc uses though.. perhaps just "the upper right corner of the lambda cube"
02:44:11 <tomaszz> shapr: hi! :-)
02:44:38 <araujo> Good morning!
02:44:40 <shapr> tomaszz: How's code?
02:45:01 <tomaszz> shapr: you mean the "ghc --make" thing?
02:45:08 <shapr> Well, whatever code you're working on...
02:45:40 <tomaszz> shapr: well, it depends
02:45:47 <tomaszz> shapr: some is good, some is bad
02:46:55 <tomaszz> shapr: just yesterday I completed a prototype of a system which can revolutionize some areas of work in the company I work for
02:47:27 <tomaszz> shapr: the most important part of it is in Haskell :-)
02:47:36 <skew> I'm putting together a little library for writing distributed systems. You define the types of components as functions which take a few Chans and give you an IO action that will communicate on them. You pass the library some maps naming these types of components, giving a type and name to the processes you want at runtime, listing the nodes in the system, describing how to connect the channels together, and assigning processes to 
02:47:48 <skew> tomaszz: fancy that, I'm trying to write the same tonight
02:49:26 <shapr> tomaszz: Neat, what does the prototype do? Or is that confidential company info?
02:49:38 <skew> My code is checking that the channel types match up, and should probably check that all channels are connected. This is where the fancy typeclasses come in - rather than requiring you to provide a TypeRep or suchlike describing your argument types, I made a typeclass that pulls them off the function type.
02:50:11 <skew> I'd like to make a further distinction between channels which can be remote, and channels which must be  local
02:50:12 <tomaszz> shapr: I fear it is confidential and I am under a NDA
02:50:16 <shapr> ah, too bad
02:50:42 <skew> Hmm, I think newtype Local a = Local a, and wrapping that around the chans would probably do the trick
02:51:18 <skew> 250k lines of C - I'm aiming for about 10 pages of Haskell for a rough sketch
02:51:26 <tomaszz> shapr: damn, I don't even know how much I can say
02:51:46 <tomaszz> shapr: I could already say too much ;-)
02:51:46 <skew> can you say what company you are looking for, and if they have a web page?
02:52:02 <tomaszz> shapr: how I like those NDAs :-(
02:52:11 <shapr> Yeah, I understand.
02:52:30 <musasabi> skew: have you looked at JoinHs? It does much of that.
02:52:43 <skew> actual distribution?
02:53:16 <tomaszz> skew: is it somehow similar to Erlang?
02:53:34 <skew> ah, looks pretty similar
02:53:43 <skew> except I'm expressing the graph statically
02:53:50 <skew> which might be a loss
02:56:18 <tomaszz> skew: so we're both doing some kind of static analysis probably...
02:56:43 <tomaszz> skew: and how's your code?
02:56:51 <tomaszz> shapr: and how's your code?
02:56:59 <tomaszz> skew/shapr
02:57:28 <musasabi> skew: yes, it implements actual distribution.
02:58:02 <tomaszz> on saturday I used IRC for the first time in my life ;-)
02:58:08 <JohnMeacham> sweet. just chopped 288 lines of unneeded code. I love it when a refactoring comes together.
02:59:27 <tomaszz> can someone tell me how can I set my realname in IRC?
02:59:41 <shapr> It depends on your client.
02:59:54 <tomaszz> I use irssi at the moment
03:00:15 <skew> I'm just checking consistency at the moment
03:00:18 <shapr> My code is moving along nicely, check out the demo: http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=TestMargin
03:00:51 <shapr> I'm also investigating using trac with darcs - http://thunderbird.scannedinavian.com/proj
03:01:04 <eivuokko> tomas, in irssi /set real_name what ever and restart, I think.
03:01:23 <eivuokko> Erm, reconnect should be enough :o
03:01:49 <tomaszz> shapr: is it a PDF renderer?
03:02:20 <shapr> Sort of, the "Margin" button downloads the pdf/ps in the attribute, and calls imagemagick to generate page images, after which those images are attached to wiki pages.
03:02:38 <shapr> The idea is that each paper will have its own darcs repo, and only the per-page annotations will be in the repo.
03:02:41 <tomaszz> eivuokko: thanks!
03:02:52 <shapr> Basically, research papers will finally have comments enabled!
03:03:01 <eivuokko> Hmmm
03:03:10 <eivuokko> Hehe, that'd be nice :)
03:03:24 <tomaszz> shapr: interesting
03:03:53 <shapr> The process is: 1. You make comments in your own repo. Someone else pulls from your repo to see your comments. You pull from the repos of others to see their comments.
03:04:10 <ibid> shapr: you're trying to recreate fenpdf? ;)
03:04:16 <tomaszz> shapr: this can be a revolution in science! :-)
03:04:40 <shapr> ibid: Sort of, fenpdf did a lot more stuff, so cool it got shut down.
03:05:01 <shapr> tomaszz: At least it would let people share comments on any paper.
03:05:09 <shapr> The name is "Fermat's Last Margin"
03:05:56 <shapr> The original motivation was that I want to read the margin notes of everyone I know.
03:06:55 <ibid> shapr: heh
03:07:22 <shapr> ibid: One advantage of this scheme is that only the annotations are shared in the repo, not the papers themselves. This way I skip copyright issues entirely.
03:09:56 <skew> I'd like a library that lets you restrict some channels to local access, so you can allow unserializable values on them
03:10:46 <skew> In particular, a process managing a big Map could pass out a reference to the current state for another thread to process, and then go back to servicing update requests
03:10:54 <shapr> I wish I could find an open source ps/pdf -> svg renderer.
03:15:05 <shapr> hej shadowie, learning Haskell?
03:17:32 <shadowie> shapr: yep :)
03:18:31 <shapr> musasabi: Arjan says that Dazzle's graph editing component will be OSS, he's working on it together with malcolm.
03:19:25 <shapr> musasabi: "At the moment I can give you a simple code extraction from Dazzle, but if you wait a little longer you will be able to get the diagram editor plus all the cool extensions Malcolm already made."
03:20:04 <shapr> shadowie: #haskell is a good place to ask questions. Have you already found the learning page on haskell.org ?
03:22:31 <shadowie> shapr: aye, been coding for a few weeks now, working on a route-finding-thingie atm, think i might have some questions later today =)
03:23:45 <dcoutts> Speck, the reason that it's not necssarily a good idea to make the GUI plugable is that many modules need to use the GUI lib, and they all need to use the same one (at least within any single run of the program). It's not something that you can change transparently very easily. It would require that every other plugin came in versions that use wxHaskell+Gtk2Hs+ etc ...
03:24:58 <dcoutts> Speck, we don't have a common API that all the GUI toolkits support (this would be a very hard thing to build if it were to encompas more than basic GUI functionality)
03:26:20 <dcoutts> that said, I expect many hIDE plugins will not need to use the GUI lib directly but will be able to use services provided by other hIDE infrastructure.
03:27:58 <musasabi> shapr: nice, thank you for the information :-)
03:28:26 <basti_> http://deimos.dynalias.org/linear-logic.txt < to whom it may concern
03:34:24 <shapr> hoi Itkovian
03:39:42 <sieni> Is there some need to support something else than gtk+?
03:41:57 * shapr advertises lwn.net - subscribe now! Otherwise lwn.net might disappear!
03:47:08 <ibid> (dd's can get a sponsored subscription; those may exist for other big projects too)
03:47:50 <shapr> lwn.net is a great resource, it's worth supporting.
03:51:00 <ibid> it even links to hwn :)
03:53:52 <dcoutts> ibid, I think I've implemented all of SOE now except for the Region stuff.
03:54:16 <dcoutts> the regions stuff is a pain. How were you planning on implementing it?
03:54:52 <dcoutts> the original SOE on X11 uses the X Regions API but fakes elipses as 40 point polygons.
03:55:43 <dcoutts> (It does that hack for sheared elipses too. My cairo version just uses the appropriate transformation matrix)
04:00:11 <autrijus> @pl \name pad -> fmap head (lookupPad name pad)
04:00:12 <lambdabot> (fmap head .) . lookupPad
04:01:43 <ProfTeggy> "@pl" as in point-less (point-free)?
04:01:52 <basti_> yes
04:01:53 <shapr> aww, they don't have HWN in LWN this week.
04:02:04 <ProfTeggy> Ingenious. ;-)
04:05:39 <MarcWeber> Nobody is using hdirect on windows, is someone?
04:07:46 <skew> autrijus: Oleg put together a full composition operator
04:08:38 <skew> http://www.okmij.org/ftp/Haskell/polyvar-comp.lhs
04:08:44 <autrijus> ooh.
04:09:51 <Itkovian> hi shapr.
04:10:31 * basti_ cries.
04:10:34 <skew> I'm not sure when that has a runtime cost
04:10:37 * basti_ wants a full composition operator either.
04:10:44 <basti_> uhm ", too"
04:11:36 <skew> I think you could clean up the base case using his "not a function" instance
04:12:01 <skew> http://www.okmij.org/ftp/Haskell/isFunction.lhs
04:14:19 <ProfTeggy> In this context, I always remember this post: http://groups.google.com/group/fa.haskell/msg/3c331e368479b065?hl=en&
04:14:25 <Lunar^> @seen SyntaxPolice
04:14:26 <lambdabot> I haven't seen SyntaxPolice.
04:14:31 <Lunar^> @seen SyntaxNinja
04:14:32 <lambdabot> I saw SyntaxNinja leaving #haskell 10 hours, 51 minutes and 48
04:14:32 <lambdabot> seconds ago.
04:15:51 <ProfTeggy> @type (.) . (.)
04:15:52 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:26:00 * ski_ was just about to mention that
04:26:14 <ski_> @pl \f g x y -> f (g x y)
04:26:16 <lambdabot> (.) . (.)
04:26:41 <ski_> @pl \f g x y z -> f (g x y z)
04:26:42 <lambdabot> (.) . (.) . (.)
04:26:45 <ski_> etc
04:27:10 <ski_> (i sometimes define  (.:) = (.);  (.::) = (.) . (.:); ...)
04:27:51 <ski_> (autrijus : ok ?)
04:29:47 * ski_ notices usenet post
04:30:13 <ProfTeggy> Exactly
04:30:35 <ProfTeggy> Nice way to name these functions, ski
04:30:43 <ski_> ty :)
04:31:07 <ski_> (bah, of course (.:) = (.) . (.)  !)
04:32:02 <araujo> :-)
04:32:21 <int-e> @pl (.)(.)
04:32:22 <lambdabot> ((.) .)
04:32:32 <shapr> @pl (.).(.)
04:32:33 <lambdabot> (.) . (.)
04:32:42 <shapr> bok gour
04:36:46 <gour> shapr: bok
04:36:58 <gour> very busy those days
04:37:06 <gour> but not with haskell :-(
04:37:24 <Lunar^> Does Florian Ragwitz come here?
04:37:40 <gour> some perl-friend just throw me a glove with some simple cgi script...
04:37:44 <Igloo> rafl_ is he
04:37:57 <Lunar^> Igloo: thanks :)
04:38:07 <gour> asking to write similar thing in haskell, wondering if it can be simpler than perl
04:38:25 <z0d> gour: perldoc CGI has some examples
04:38:29 <gour> is there any haskell script doing something like old cgiemail script?
04:38:40 <Lunar^> rafl_: How far has you been with the hsplugins package?
04:39:26 <gour> z0d: since i'm preaching about haskell, i'm supposed to show something in it :-)
04:40:56 <gour> z0d: ahh..missed your nick, didn't use \t..since i'm preaching about haskell, i'm supposed to show something in it :-)
04:40:59 <shapr> gour: If you can come up with something equally simple, does your friend have to show Perl matching Haskell next?
04:41:18 <ProfTeggy> hehe, shapr
04:41:42 <gour> shapr: well, the original argument was about writing some app in C++ vs. Haskell :-)
04:42:01 <shapr> That's not much of an argument.
04:42:11 <gour> shapr: but then this problem of picking the result of html form and emailing it evolved
04:42:38 <z0d> though I wouldn't write CGIs these days
04:43:00 <z0d> it's better to have an application running, as with FastCGI
04:43:17 <humasect> are there many OSX users in here, working with haskell?
04:43:19 <z0d> or any other persistent framework
04:43:19 <shapr> I think bark has SMTP code, and I think two flavors of email code are in MissingH (one from WASH, one from Peter Simons).
04:43:37 <gour> z0d: whatever, there are several pages on the site containing forms and after submitting one, the data has to be emailed
04:44:33 <gour> z0d: atm, for that purpose some cgiemail-like script is used, but those are very insecure
04:44:41 <gour> z0d: anything better in haskell?
04:44:54 <shapr> I found the weirdest bug... when I run "nice mpdscribble" nice never comes back to me.. But when I hit C-c, nice stops, and mpdscribble writes into its log that it has shutdown. But it doesn't really shutdown, it's still running. What the heck is going on?
04:45:26 <gour> shapr: thanks, i'll take a look in MissingH
04:46:00 <shapr> gour: Philippa write some improved Network.CGI code, but you can probably use the standard Network.CGI just fine for what you're doing.
04:46:15 <shapr> wrote*
04:46:17 <ibid> dcoutts: i was postponing it, basically :)
04:46:42 <gour> shapr: will take a look, but probably not before the next week
04:46:52 <shapr> ok
04:46:52 <gour> @where MissingH
04:46:53 <lambdabot> http://quux.org/devel/missingh
04:47:00 <dcoutts> ibid, mm, it's not that easy to emulate with cairo it seems. I could just use the same hack as the original SOE uses I guess.
04:48:21 <gour> the above url for missingh point at tarballs, where is darcs repo?
04:48:49 * shapr smacks self for cluelessness
04:49:51 <rafl_> Lunar^: Finished. Only needs to be uploaded.
04:50:00 <Lunar^> rafl: good news! :)
04:50:15 <Lunar^> rafl: I just filled an ITP for riot, so I need it... :)
04:50:19 <Philippa> afternoon
04:50:29 <Lunar^> rafl: is the package in a darcs repos, or something?
04:50:30 <Philippa> shapr: I didn't write any improved Network.CGI
04:50:39 <shapr> Oh, I thought you did.. with file uploading...
04:50:41 * shapr is confused today.
04:50:54 <Philippa> nope, I know musasabi and bringert and a couple of others have had a go at that kind of thing
04:50:59 <shapr> Oh, ok
04:51:02 <rafl> Lunar^: Yes, locally on my laptop. I'll upload the source package for you today. Give me 2h to get to my laptop.
04:51:21 <Philippa> there's a CGI.hs in my Flippi dir but I don't know if it's even in the repo - I just figured I'll need to supply my own sooner or later
04:51:48 <Lunar^> rafl: thanks! :) What are you waiting for the official upload?
04:52:07 <rafl> Lunar^: For emlo to create my account.
04:52:26 <Lunar^> rafl: that could take ages, right? :)
04:53:32 <rafl> Lunar^: Normally that's quite fast. I already were approved by joerg and nomeata also mailed elmo yesterday to ask him for my account because he doesn't get enough sleep is he always uploads my packages. :-)
04:53:52 <Lunar^> rafl: pretty cool
04:54:11 <rafl> Lunar^: If that impresses elmo, yes.
04:54:30 <rafl> I woundn't count on that, though.
04:54:36 <gour> Philippa: that would be nice, pls. let me know if you cook something
04:55:18 <Philippa> it's unlikely to be any better than anything already in existance - in practice I kinda want Flippi abstracted on CGI/interface-to-server library anyway
04:55:31 <boegel> the haskell mailinglist is quite active today...
04:55:53 <Philippa> so I'll probably just mod Network.CGI to do the bare minimum extra for now (which atm is handling other content-types)
04:57:27 <gour> Philippa: fine, let me 1st become a bit familiar with the standard module, i still wear noob shirt :-)
04:58:17 <Philippa> the wrapper function's all you really care about most of the time
04:58:42 <Philippa> takes a function of type [(String, String)] -> IO Html, turns it into a CGI
04:59:01 <Philippa> the input to that function's just an association list containing the CGI environment
04:59:47 <gour> what CGI environment is consisting of?
05:02:24 <Philippa> the CGI-relevant environment variables + the fields in the query string
05:05:09 <gour> Philippa: ahh, thanks
05:10:17 <musasabi> What would be a good excuse for a switch from StateT IO to ConT ReaderT IO ?
05:10:44 <StevenG> can someone help me
05:10:47 <StevenG> im logged into oracle
05:10:55 <StevenG> how do i create my own database from scratch :p
05:13:45 <dcoutts> StevenG, perhaps you're in the wrong channel for that kind of question :-)
05:15:00 <StevenG> woops :p
05:17:05 <Philippa> nor did I particularly appreciate being spammed with a "do my homework for pay" request while I was asleep
05:17:21 <int-e> well, now that we have a file system, wouldn't a database be the logical next step?
05:17:36 <Philippa> IIRC there's already an in-memory database
05:18:33 * ProfTeggy recognizes the word "database" and raises his head.
05:20:46 <kzm> Hi.  I get "Error in array index", and am at a loss as to where and which etc.  Didn't GHC use to at least say something about which index, and expected range?
05:37:21 <shapr> StevenG: Yeah, I didn't appreciate privmsg spamming either.
05:37:37 <boegel> shapr: ?
05:37:37 <StevenG> k duely noticed, thx.
05:39:15 <shapr> boegel: StevenG was in need of @wiki HomeworkHelp
05:39:38 <boegel> shapr: oh, I see
05:39:48 <Philippa> it's generally impolite, you won't find many people on IRC who do appreciate it
05:41:23 <StevenG> <StevenG> k duely noticed, thx.
05:41:36 <MarcWeber> Has anyone any idea how to get some help on how to compile hdirect on windows?
05:46:04 <MarcWeber> join lksjdf
05:46:37 <shapr> MarcWeber: Have you asked on haskell-cafe?
05:48:58 <MarcWeber> shapr: Not yet.. But I'll try..
05:59:05 <xerox> Ciao!
06:04:38 <dcoutts> hi xerox
06:05:09 <ValarQ> hello folks
06:08:25 <xerox> http://codespeak.net/pypy/dist/pypy/doc/objspace.html#the-thunk-object-space
06:08:39 <xerox> Laziness in python, under pypy
06:23:03 <MarcWeber> Now I get this error: TypeInfo.lhs:1:0: conflict: monative Info belongs to the current program/library to package lang.
06:23:26 <MarcWeber> Can I tell ghc to not use its module?
06:25:44 <ChronoWiz> werd up to unimelb pplz
06:26:13 * shapr weirds up
06:26:23 <shapr> Is that like fogging up? ;-)
06:28:19 <tromp> dc
06:33:04 <Maddas> parsec is easy to pick up, yay :-)
06:33:21 <xerox> Maddas: good to hear! :D
06:33:39 <xerox> Which kind of static checking does a C compiler do, if any?
06:34:00 <earthy> use-before-define
06:34:11 <earthy> types
06:34:34 <xerox> earthy: what does it mean?
06:34:39 <earthy> (modulo a large coercion table)
06:34:51 <Maddas> xerox: Checking you don't use variables before defining them :-)
06:34:57 <earthy> a c compiler checks to see if everything used is indeed defined
06:35:03 <araujo> We can't print the functional type?
06:35:08 <earthy> it checks to see if the types are correct
06:35:34 <dblhelix> araujo: we can't show values of function type, no
06:35:35 <earthy> that's about the extent of C's static checking
06:36:34 <Philippa> araujo: functions're potentially-infinite, and you can't just use a source representation in practice
06:36:35 <xerox> earthy: what else can be done as static checking on a program (NOT in C, say, in Haskell or whatever)
06:36:51 <earthy> array bounds checks
06:36:57 <dblhelix> araujo: but you can do something like:
06:36:57 <dblhelix> instance Show (a -> b) where show function = "<<function>>"
06:37:01 <earthy> memory definedness
06:37:10 <earthy> usually that is guaranteed differently though
06:37:45 <araujo> Thanks
06:37:50 <xerox> Thank you earthy
06:43:25 <araujo> yeah.. that'll make it, thanks dblhelix
06:43:48 <dblhelix> araujo: you're welcome
07:10:19 <luqui> @pl \f -> f . f
07:10:21 <lambdabot> join (.)
07:10:24 <luqui> what is join here?
07:11:08 <dblhelix> @type Monad.join
07:11:10 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
07:11:43 <shapr> For which monad instance?
07:11:45 <luqui> I don't see any monads in my function...
07:12:02 <arjanb> for instance (r->)
07:12:07 <shapr> ohh
07:12:13 <shapr> nifty
07:12:16 <dblhelix> i.e. the Reader monad
07:12:26 <luqui> I see
07:12:39 <luqui> but Reader isn't just a synonym is it?
07:13:05 <dblhelix> usually, it's a newtype, i.e., an isomorphism
07:13:32 <luqui> so that means that I couldn't actually write join (.) in real code for that function
07:13:51 <dblhelix> newtype Reader r a = Reader {runReader :: r -> a} ; instance Monad (Reader r) where ...
07:14:35 <dblhelix> luqui: you could, provided that you have instance Monad ((->) r) where ...
07:15:15 <StevenG> ive got a question
07:15:21 <arjanb> both have an instance but Reader is usually used because it gives less confusing error messages
07:16:02 <shapr> StevenG: Ask your question.
07:16:17 <shapr> but not in private...
07:16:29 <shapr> At least, not in private to me.
07:16:34 <luqui> haha
07:16:54 <StevenG> shapr: grumpy man :p
07:16:58 <MarcWeber> How can I execute other applications from haskell? I want to play some midi and call mplayer
07:18:33 <luqui> StevenG, if you ask your question we will answer it.  Unless, apparently, your question is the same as MarcWeber's :-/
07:19:53 <MarcWeber> He luqui, thanks!
07:20:15 <shapr> MarcWeber: If you want to read output of a child process, POpen
07:20:52 <MarcWeber> Will have a look at it.
07:22:05 <xerox> Isn't there some code (in TMR/hawiki?) to actually produce MIDI output?
07:23:27 <MarcWeber> xerox: Don't know. But I also want to call another application to read some text. I want to play a sound and afterwards letting tell me which pitch it has been
07:24:54 <xerox> MarcWeber: search the hawiki, I think it has something, though I don't recall the name.
07:26:13 <MarcWeber> xerox: There is haskore.
07:30:31 <autrijus> luqui: hi
07:36:16 <luqui> autrijus, hi. just playing with @pl in here
07:36:25 <autrijus> luqui: cool, thanks for the meeting notes, btw.
07:36:39 <autrijus> though not sure what "people need more time to think about that" refers to
07:36:53 * luqui goes to #perl6
07:41:41 <int-e> has there ever been a followup to the programming challenge in TMR 1? (at the end of 'Pseudocode: Natural Style')
07:42:50 <earthy> hey, an autrijus
07:43:17 <shapr> int-e: Not that I know of.
07:43:41 * int-e wonders if O(2^n*n) is any good for the first part.
07:44:37 <luqui> what is the standard set of combinators that you need to represent pointfree lambda calculus
07:45:12 <int-e> is pointfree lambda calculus the combinator calculus? (then S and K suffice)
07:53:12 <shapr> luqui: For extreme entertainment, check out unlambda
07:53:49 * luqui has seen unlambda
07:53:55 <luqui> but that was before I learned any functional language
07:54:04 <luqui> so I gave up pretty much immediately
07:54:51 <shapr> I think lambdabot needs an unlambda interpreter.
07:57:05 <ProfTeggy> Is lambdabot's @pl document somewhere?
07:57:09 <ProfTeggy> +ed
07:57:35 <shapr> Probably in the source if anywhere. TheHunter wrote it.
07:57:42 <shapr> So you can probably ask him.
07:57:52 <shapr> afaik, it's a term rewriting implementation
07:57:58 * ProfTeggy nods
07:58:17 <\x> hm, \x.xx doesn't work.
07:59:35 <int-e> @eval let bubble [a] = Right [a]; bubble (a:b:cs) | a>b = Left $ b:a:cs; bubble (a:bs) = either (bubble.(a:)) (Right.(a:)) $ bubble bs; bubblesort as = either bubblesort id $ bubble as in bubblesort [5,2,23,13,17]
07:59:38 <lambdabot> [2,5,13,17,23]
08:01:38 <bourbaki> moin
08:02:00 <ValarQ> bourbaki: goodafternoon
08:02:46 <bourbaki> what happened to esap?
08:08:11 <bourbaki> @seen esap
08:08:13 <lambdabot> I saw esap leaving #haskell 17 hours, 28 minutes and 29 seconds ago.
08:08:26 <bourbaki> aha
08:09:11 <shapr> hoi kagy
08:09:32 <ValarQ> how do i do a combined adjust/insert to a Data.Map.Map ?
08:10:07 <ValarQ> i wan't to insert a value and if the key exists update it
08:10:52 <shapr> fiveop_: Hiya, learning Haskell?
08:11:30 <fiveop_> nope
08:11:44 <shapr> Long time user?
08:12:03 <fiveop_> "stalker" might fit
08:12:13 <shapr> Are you stalking Haskell B. Curry?
08:12:21 <fiveop_> nope
08:12:33 <bourbaki> haskell b. curry reminds me of alfred e neumann :)
08:12:35 <shapr> Who are you stalking?
08:12:41 <shapr> And, why stalk on #haskell?
08:12:56 <shapr> If you're not interested in FP, #haskell will likely bore you to tears.
08:13:13 <fiveop_> Looked for some ham
08:13:46 <musasabi> Haskell is pure Joy, and joy can be implemented in Haskell.
08:13:51 * shapr laughs
08:14:17 <bourbaki> has anyone deeper insights in coalgebras and can tell me how they relate to monads?
08:14:42 <shapr> fiveop_: What sort of ham? I don't think meat products are often discussed here.
08:15:03 <shapr> Well, except for the sausages on ralejs' homepage.
08:15:25 <fiveop_> but someone formerly known as a meat product is discussion with you (as the channel) right at the moment :P
08:15:43 <fiveop_> discussing ...
08:16:41 <brx> fiveop: not to be confused with disco-cussing?
08:18:10 <shapr> fiveop_: Who is it?
08:18:34 <fiveop_> bourbaki
08:18:49 <bourbaki> fiveop_: ?
08:19:12 <ValarQ> aint easy being a meat product...
08:19:36 <bourbaki> ValarQ: are you a feminist?
08:19:44 <shapr> bourbaki: Wow, you're famous enough to stalk! I'm so jealous.
08:19:45 <ValarQ> bourbaki: don't think so
08:20:01 <bourbaki> ValarQ: then why do you say its hard to be a meat product?
08:20:07 <ValarQ> bourbaki: i don't even know exactly what a meat product is
08:20:08 <bourbaki> shapr: stalk who?
08:20:23 <shapr> er, I think fiveop_ just said he's stalking you.
08:20:27 <bourbaki> ValarQ: meat product ~ women :)
08:20:48 <ValarQ> bourbaki: ok, i was thinking more literally :)
08:20:51 <shapr> Not always.. I went into some bars in Southside in Birmingham where I was obviously a meat product.
08:21:01 <bourbaki> shapr: heh
08:21:30 <shapr> The girls were arranged in an aisle, and as you walked to the bar to order a beer, they'd check you out in this order: 1. crotch 2. wallet 3. face
08:21:35 <musasabi> some meat products are quite tasty but they come with all kinds of sideissues one tends to forget.
08:22:07 * earthy grins
08:22:12 <bourbaki> shapr: did they at least look good ;)?
08:22:21 * earthy has been in such bars as well
08:22:31 <shapr> I guess so. I wouldn't want to have a relationship with any of them though.
08:22:44 <earthy> the person I was with hadn't even noticed he was being checked out, so oblivious was he
08:23:20 <bourbaki> shapr: you guess so :)?
08:23:57 <shapr> Well, physically speaking, they looked great. But style is part of 'looking good' and these girls were serious gold-digger types.
08:23:59 <bourbaki> but you cant be a meat product in this case cause you have to be bought if you want to be a meat product
08:24:16 <bourbaki> but if they want you to buy them stuff they are still the meat products
08:24:37 <musasabi> bourbaki: depends on what meat one is interested in ;p
08:24:52 <bourbaki> musasabi: heh
08:25:00 <bourbaki> what kind of meat is there?
08:25:12 <beelsebob> @seen JaffaCake
08:25:13 <lambdabot> I saw JaffaCake leaving #haskell 8 hours, 17 minutes and 21 seconds
08:25:13 <lambdabot> ago.
08:25:17 <beelsebob> pants
08:25:35 <beelsebob> I finally get CVS write access... and then I get a new machine and need to change my ssh key
08:26:35 <ValarQ> hmm, there must be some more efficient way of insert/update a key/value to a finite map...
08:27:20 <mflux> than what?
08:28:01 <ValarQ> than using member to choose if i'm going to do an insert or update
08:29:18 <mflux> oh, so if the element is there you want to update it in a certain way, otherwise you want to insert another kind of element?
08:29:35 <ValarQ> exactly
08:30:09 <sylvan___> isn't there a function like insertWith (a->a->a) which would merge the two elements if one already exists? there should be
08:30:09 <mflux> I doubt many map interfaces provide that
08:30:29 <mflux> plainly inserting does overwrite existing elements though
08:30:46 * ValarQ checks for insertWith functions
08:30:47 <sylvan___> insertWith :: (a->a->a) -> Set a -> a -> Set a, or something
08:31:03 <sylvan___> not sure if it is, but everytime I've written a binary tree for illustrative purposes I've included a function like that
08:32:10 <ValarQ> sylvan: found it, and it works great :)
08:36:31 <mflux> @hoogle [[[a]]] -> [[a]]
08:36:33 <lambdabot> Prelude.concat :: [[a]] -> [a]
08:36:33 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
08:36:33 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
08:38:33 <mflux> @hoogle [[a]] -> [a]
08:38:34 <lambdabot> Prelude.concat :: [[a]] -> [a]
08:38:34 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
08:38:34 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
08:55:41 <sethk> @hoogle lines
08:55:42 <lambdabot> Prelude.lines :: String -> [String]
08:55:42 <lambdabot> Prelude.unlines :: [String] -> String
09:02:20 <joelr> howdy
09:02:41 <joelr> are there any tutorials on using STArrays, etc.?
09:03:52 <shapr> I think I've seen demo code on the wiki
09:03:54 <ValarQ> is there any function to randomly pick an element in a list?
09:04:42 <shapr> Yes, but I forget its name.
09:05:01 <shapr> It's in the Random module somewher.
09:05:13 <shapr> Why am I dropping letters so much? :-/
09:05:22 <ValarQ> System.Random ?
09:05:38 <shapr> Sounds right to me.
09:05:54 <xerox> mtl/MonadRandom ;-)
09:06:31 <ValarQ> didn't find any...
09:06:54 <xerox> You could get a random number n and (!! n) list.
09:07:25 <xerox> You could also generalize the code to an arbitrary monad and use Cale's MonadRandom.
09:07:35 <xerox> (Which is on the wiki)
09:07:43 <joelr> shapr: where on the wiki?
09:08:14 <xerox> joelr: some page about 'imperative programming in ...' or something
09:08:37 <joelr> xerox: ok, i'll poker around
09:08:46 * xerox bets
09:22:13 <shapr> xerox: bwahaha
09:22:53 <xerox> shapr: heh, it took a while, eh? ;-)
09:22:59 <shapr> hiya enienskv, learning Haskell?
09:23:07 <shapr> xerox: Nah, I'm working, and I just saw it.
09:23:11 <enienskv> yes, beginner
09:23:33 <shapr> enienskv: Are you learning for fun or profit?
09:24:05 <shapr> In any case, have you seen the "learning Haskell" page?
09:24:56 <enienskv> shapr: yes, I want to rewrite some program in haskell
09:25:18 <enienskv> shapr: not so serious :-)
09:25:20 <shapr> What sort of program? Maybe I can suggest some libraries?
09:26:08 <enienskv> shapr: one of them will search google and pack the result
09:26:25 <shapr> pack the result?
09:27:38 <shapr> lambdabot has code to search google.
09:27:41 <shapr> @google haskell google code
09:27:43 <lambdabot> http://haskell.org/gtk2hs/
09:28:54 <enienskv> the program let me setup a library, in which all items are based search results.
09:29:11 <enienskv> a virtual and dynmic library.
09:29:28 <ProfTeggy> Bye all *wave*
09:29:48 <shapr> Sounds easy enough.
09:30:21 <enienskv> yes
09:30:28 <kosmikus> hi SyntaxNinja
09:34:54 <xerox> shapr: hehe, I'm studying, same applies ;)
09:35:25 <bourbaki> bb ppl
09:35:25 <SyntaxNinja> 'morning
09:35:33 <ulph_> xerox: hey how's it going, did you receive the uni? :)
09:35:40 <shapr> hiya SyntaxNinja
09:38:17 <tomaszz> 'evening
09:40:26 <dcoutts> SyntaxNinja, cabal Q: does cabal install c2hs .chi files? For some projects (eg gtk2hs) that are split across multiple packages they need to import the .chi files from dependent packages. So under the cabal model I guess they would need to be installed.
09:40:35 <xerox> ulph!  I still have to order it!  Damn money :-)
09:41:21 <ulph_> Oh I see.
09:41:47 <ulph_> hm my terminal is messed up
09:41:47 <b0gg1e> good evening.
09:41:54 <dcoutts> SyntaxNinja, though it would only be necessary to install the .chi files for modules that are exposed.
09:42:57 <joelr> any suggestions on how to replace newDoubleArray with the new polymorphic newArray from Data.Array.MArray?
09:43:03 <joelr> replace the call that is
09:43:32 <SyntaxNinja> dcoutts: no, I don't think it installs them.
09:43:57 <SyntaxNinja> hi shapr
09:44:57 <dcoutts> SyntaxNinja, I'm just wondering how I'd cabalise gtk2hs.
09:45:26 <SyntaxNinja> dcoutts: I guess cabal should be made to install them :)
09:45:47 <SyntaxNinja> not too hard. it was recently changed to install profiling objects
09:45:53 <SyntaxNinja> same kinda thing
09:45:57 <dcoutts> right
09:46:25 * SyntaxNinja is sad because I was hacking a lot on cabal whileI was gone, and so were simon and ross. I lost (I'll have to resolve the conflicts)
09:46:27 <SyntaxNinja> bugger
09:46:58 <dcoutts> I think it would be possible to split gtk2hs into several independent cabal packages. Though each would need to run their own ./configure script.
09:47:03 <SyntaxNinja> dcoutts: so you could either do that, look at Dist.Simple.Install, or email me an example program and I'll do it.
09:47:23 <SyntaxNinja> why do you want them to be separate packages, ooi?
09:47:46 <dcoutts> SyntaxNinja, well the current model is one cabal thingy = one ghc package
09:47:52 <dcoutts> and gtk2hs has 7 ghc packages
09:48:04 <SyntaxNinja> ahh. and you don't want to make 7 cabal packages? :)
09:48:09 <SyntaxNinja> why so many ghc packages?
09:48:10 <dcoutts> that's ok
09:48:21 <dcoutts> to match the deps of the underlying C libs
09:48:57 <dcoutts> otherwise we'd have to depend on lots of C lbis which you might not have installed (eg mozilla, gconf etc)
09:49:03 <SyntaxNinja> ahh
09:49:39 <dcoutts> so with the current cabal incarnation I'd need 7 .cabal packages
09:50:01 <SyntaxNinja> right
09:50:03 <dcoutts> and I'd have to install the .chi files for the base packages since the other ones import them
09:50:11 <SyntaxNinja> ahh
09:50:20 <dcoutts> so that'd be the .chi files for glib & gtk
09:50:43 <dcoutts> oh and cairo
09:51:18 <dcoutts> then I'd need to write a script that cabal configured, built and installed all the packages in the right order
09:51:50 <dcoutts> that's where the cabal support for multi-package distributables would be handy :-)
09:51:52 <SyntaxNinja> right.
09:51:59 <SyntaxNinja> I really need to do that :)
09:52:17 <SyntaxNinja> but I want to get cabal-get out there first; I think that may change the way ppl think about it.
09:52:29 <SyntaxNinja> change some use cases, and I'll want to know about that before doing multi-package support
09:52:30 * SyntaxNinja shrugs
09:52:59 <dcoutts> we do need to think carefully before doing multi-package thingies since it affects dependency resolution quite a bit
09:53:23 <SyntaxNinja> and the logic for intsalling stuff in the right order is in cabal-get.
09:53:58 <dcoutts> I think the multiple .cabal packes in one tarball should be just as a convenience if we do it at all
09:54:00 <SyntaxNinja> I definitely wouldn' tmind having a program cabal-install which would do something smart w/ "find . -name "*.cabal" |xargs cabal-install"
09:55:12 <dcoutts> with my gentoo hat on, the difficulty with multiple cabal packages in one distributable is that we then need to depend on distributables rather than packages
09:55:34 <dcoutts> so we then need a package<->distributable mapping
09:55:47 <dcoutts> and optional packages could get tricky
09:56:19 <SyntaxNinja> hm. yeah
09:56:30 <dcoutts> eg suppose a package depends on one of the optional mozembed package supplied by gtk2hs
09:56:46 <dcoutts> s/one of//
09:57:06 <dcoutts> then is the dependency on the gtk2hs package?
09:57:10 <dcoutts> or on the mozembed package?
09:57:32 <dcoutts> I mean do we have one ebuild for gtk2hs, or one for each of the packages within gtk2hs
09:57:46 <dcoutts> if it's the former thenw we have a problem
09:58:03 <dcoutts> supose I already installed gtk2hs but didn't enable the mozembed package
09:58:04 <Igloo> As long as you end up with a binary gtk2hs package that depends on the real binary packages gtk, mozwhatever, etc, I think deps for OS packages should be OK
09:58:07 <SyntaxNinja> I think it should depend on the smaller package
09:58:22 <Igloo> The gtk2hs binary package wouldn't include any modules, but would build-dep on the others
09:58:38 <dcoutts> Igloo, yes that's ok for debian and binary packages. It's more of a problem for gentoo and cabal-get which manage source packages.
09:59:10 <dcoutts> SyntaxNinja, right, I think we should try to keep the packaging unit the cabal package.
09:59:23 <paolino> evening all ,I'm regressing :/ how I print an IO Int ?
09:59:26 <dcoutts> SyntaxNinja, and if some cabal packages happen to share the same tarball well that's ok.
09:59:37 <Igloo> Ah, yes, because you can't see what bin packages a srcpackage will make
09:59:52 <dcoutts> Igloo, in gentoo it's 1-1
10:00:04 <tomaszz> paolino: do x <- ioInt; print x  ?
10:00:13 <Igloo> IM what cabal bin packages
10:00:14 <tomaszz> paolino: or: ioInt >>= print
10:00:42 <Igloo> (does that mean you currently have 7 gtk2hs packages in gentoo?)
10:00:50 <dcoutts> Igloo, no just one
10:01:06 <Igloo> So you won't be any worse off then?
10:01:08 <dcoutts> Igloo, and it optionally supples more or less ghc packages depending on USE flags
10:01:09 <paolino> well was not obvious ,phew thanks tomaszz
10:01:35 <dcoutts> Igloo, so at the moment we'd have a problem if we had anything that depended on optional packages supplied by gtk2hs
10:01:43 <tomaszz> paolino: be sure you know what you are doing
10:01:51 <dcoutts> Igloo, right, but we want to be better off :-)
10:02:49 <Igloo> Change to Debian, then^URight, I see  :-)
10:03:12 <SyntaxNinja> dcoutts: right
10:03:13 <dcoutts> gentoo has a policy of not splitting packages up any more than the upstream provider does
10:03:48 <dcoutts> so we don't do what debian does and have multiple binary packages produced from one source package
10:04:01 <dcoutts> it reduces our packaging burden considerably
10:04:16 <Igloo> I don't think it does
10:04:27 <dcoutts> so if we think things need to be split up more then we bully upstream :-)
10:07:02 <dcoutts> SyntaxNinja, so the ideal as far as I can see would be like this:
10:07:16 <dcoutts> suppose there is a gtk2hs tarball with 7 .cabal packages in it
10:07:30 <dcoutts> the user has happened to install the base gtk2hs packages
10:07:46 <dcoutts> then they install something which depends on one of the optional gtk2hs packages
10:08:15 <dcoutts> we should be able to install just that extra optional package without having to build any other packages from the gtk2hs tarball
10:08:37 <dcoutts> to satisfy the dependency of this new app (that say depends on the mozembed package)
10:09:01 <dcoutts> so the unit for packages is the .cabal package, but some packages can share a tarball
10:09:09 * Igloo is a bit confused. Is it possible a 3rd party library could need the chi files?
10:09:45 <dcoutts> Igloo, it's unlikely to be honnest. It depends on whether the app exposes it's innards for external extensions.
10:09:51 <dcoutts> app.lib
10:10:02 <dcoutts> app/lib I mean :-)
10:10:08 <Igloo> Hmm, OK
10:10:37 <dcoutts> eg the cairo package exposes Graphics.Rendering.Cairo.Internal
10:10:54 <dcoutts> and the gtk package has to import that to implement the gtk/cairo extension
10:11:49 <dcoutts> SyntaxNinja, so gentoo & cabal-get users would not emerge/cabal-get gtk2hs but rather glib gtk cairo gconf, etc
10:12:10 <dcoutts> but cabal-get would only download the gtk2hs tarball once
10:12:29 <dcoutts> (and gentoo can do the same thing)
10:13:49 <dcoutts> SyntaxNinja, the thing I'd want to avoid is the situation that just installing an extra optional package from a tarball requires that every package in that tarball be configured & built.
10:14:37 <SyntaxNinja> hm. yeah
10:14:37 <dcoutts> SyntaxNinja, for the debian people that wouldn't be a problem, but it would be for cabal-get users and gentoo users.
10:14:49 <SyntaxNinja> you should write this stuff down on the wiki :)
10:15:12 <dcoutts> so the point is a multi-package distributable should merely be an aggregation
10:15:28 <dcoutts> SyntaxNinja, which wiki page exactly?
10:15:44 <Igloo> The more you talk, the more I think hackage shouldn't know about multi cabal packages
10:15:51 <Igloo> gtk2hs should just be a tiny package with build-deps
10:16:00 <SyntaxNinja> unless we had some kind of meta-package thingy
10:16:09 <SyntaxNinja> like debian does
10:16:11 <SyntaxNinja> virtual package I mean
10:16:17 <SyntaxNinja> dcoutts: a new page, i guess.
10:16:22 <SyntaxNinja> linked from teh cabal page
10:16:35 <Igloo> Do you really mean virtual package?
10:16:54 <SyntaxNinja> yeah, so what should happen when someone uploads a tarball w/ multiple packages; hackage could unpack it and re-tar it into the individual packages, I ugess.
10:17:03 <SyntaxNinja> Igloo: umm no.
10:17:19 <SyntaxNinja> Igloo: I cna't remmeber what you call it when you have a package that just depends on other packages.
10:17:30 <Igloo> Either task or meta-package, I think
10:17:37 * SyntaxNinja is, as usual, trying to have this conversation while doing his Real Job
10:17:41 <Igloo> meta-package /is/ just a tiny package with build-deps, though
10:17:50 <dcoutts> SyntaxNinja, it's not necessary to re-tar into individual packages
10:17:54 <SyntaxNinja> right. yeah, I was right the first time :)
10:17:58 <SyntaxNinja> dcoutts: why not?
10:18:17 <Igloo> I think uploading gtk2hs should mean uploading a tarball of the n+1 cabal packages (gtk, mozembed, ..., gtk2hs)
10:18:23 <Igloo> And hackage then untars it, yes
10:18:32 <dcoutts> SyntaxNinja, it's just that cabal-get has to be aware of which .cabal package it is supposed to be building from the tarball
10:18:48 <Igloo> And possibly keeps the tarball around for people to download too
10:19:04 <SyntaxNinja> yeah
10:19:43 <dcoutts> The way it works in gentoo is that multiple ebuilds can specify the same tarball, then the ebuild unpacks the tarball and builds the specific bit from it.
10:20:00 <dcoutts> And of course the tarball only needs to be downloaded once.
10:20:01 * SyntaxNinja nods
10:20:15 <Igloo> But why lump it all in one tarball?
10:20:27 <dcoutts> Igloo, convenience
10:20:37 <Igloo> I think that'll make everything else harder
10:20:51 <dcoutts> Igloo, eg GStreamer comes all as one tarball with the core + 101 plugins in the same tarball.
10:21:09 <b0gg1e> is there a more elegant way to write  sizeOf (((toEnum . fromEnum) 'c') :: CChar)
10:21:13 <b0gg1e> ?
10:21:23 <dcoutts> Igloo, then gentoo has lots of ebuilds for GStreamer plugins, which just unpack the tarball and build the appropriate GStreamer plugin.
10:21:33 <Igloo> gentoo only does this because it can't change what upsream does
10:21:59 <dcoutts> Igloo, right (can't/doesn't)
10:22:11 <Igloo> But in Haskell's case we can
10:22:18 <dcoutts> Igloo, yes
10:22:27 <Igloo> And it makes things simpler, so we should!
10:22:43 <dcoutts> so no multi-package tarballs! yay!
10:23:09 <Igloo> Oh, that was an anti-climax. I was sure you were going to disagree with me at some point  :-)
10:23:12 <dcoutts> we just need to make sure our tools make it convenient to work with projects that consist of multiple packages
10:23:15 <SyntaxNinja> maybe you don't need multi-packages if you have cabal-install
10:23:24 <Lemmih> b0gg1e: sizeOf (undefined :: CChar)
10:23:31 <SyntaxNinja> that's what I'm wondering, and why I want to wait until cabal-get is out
10:23:32 <b0gg1e> ah thanks
10:23:33 <SyntaxNinja> hi drbean!
10:23:40 <SyntaxNinja> er, droundy... d'oh
10:23:43 * Igloo points and laughs at SyntaxNinja 
10:23:46 <SyntaxNinja> what a tease
10:23:56 <b0gg1e> thats much better :-)
10:24:20 <dcoutts> Igloo, so for example a project will likely be strictured as a single source tree and it needs to be convenient to build several packages at once.
10:25:12 <dcoutts> eg when working on gtk2hs, it has to be easy to build all the package in one go
10:25:14 <Igloo> dcoutts: Right, so building the root cpackage should magically look for */$dep.cabal for each of its deps or something and try to build any that exist
10:27:09 <Igloo> I don't know if it's worth differentiating between build-deps that are "part of" me and build-deps that I just use, or differentiating between "just trying to install gtk2hs" and "trying to build all of this here gtk2hs and all of its parts"
10:33:18 <SyntaxNinja> droundy: !
10:33:46 * SyntaxNinja hands droundy a cookie
10:37:22 * SyntaxNinja gets tired of waitng and eats droundy's cookie.
10:38:21 <cathper> very ninja-ish ...
10:38:45 * SyntaxNinja nods sagely while sitting in the full-lotus
10:38:52 <SyntaxNinja> then eats cathper's cookie!
10:39:25 <cathper> :-)
10:48:21 <cm> heyp
10:48:27 <SyntaxNinja> hi
10:48:59 * Lemmih wonders if cm mistyped 'hey' or 'help'.
10:50:10 <shapr> good question
10:50:15 <cm> like hey, just with p
10:52:35 <dcoutts> like "yep" as a mutilation of "yes/yeah", but for "hello/hey". "heyp"
10:52:43 <cm> :-)
10:59:34 <tomaszz> @help
10:59:35 <lambdabot>  @help <command> - ask for help for <command>
10:59:56 <tomaszz> @help help
10:59:57 <lambdabot>  @help <command> - ask for help for <command>
11:00:15 <tomaszz> @help hoogle
11:00:16 <lambdabot>  @hoogle <expr>, Haskell API Search for either names, or types.
11:00:26 <tomaszz> @help pl
11:00:27 <lambdabot>  @pointless <expr> - play with pointfree code
11:06:39 <kerny404> hi
11:06:50 <kerny404> what do you think is the best tutorial about haskell?
11:06:56 <kerny404> on haskell.org?
11:07:47 <jyp> what says http://www.haskell.org/learning.html ?
11:08:22 <jyp> http://www.isi.edu/~hdaume/htut is said to be very good
11:08:42 <adept> kerny404: "yet another haskell tutorial"
11:10:13 <kerny404> thanks
11:10:27 * jyp tips his hat
11:10:52 <sylvan> there's the "haskell for c programmers" also, which is good if you've only programmed imperative stuff before
11:10:56 <ValarQ> http://www.haskell.org/~pairwise/intro/intro.html has helped me
11:11:09 <psi> found some pretty cool (i think) books at a take-whatever-you-want bookshelf at school. "the implementation of functional programming languages" by Simon Peyton Jones, and "computational category theory" by Rydeheard & Burstall.
11:12:09 <psi> free stuff is always nice. i guess these are pretty good books, as well!
11:12:51 <autrijus> they are!
11:12:59 <autrijus> the first one is online even
11:13:13 <autrijus> but a deadtree copy is cool
11:13:45 <shapr> Isn't the first one only in image format?
11:14:48 <shapr> Man I suck at freedroid, I think I'll go back to hacking on FLM.
11:19:08 <shapr> Hm, "'Plans are useless, but planning is essential', optimistic non-strict evaluation as adaptive just-in-time compilation."
11:28:07 <vina> hi. Can someone help me in a design problem?
11:29:01 <xerox> No!
11:29:13 <xerox> ...because we don't know your problem yet.
11:29:35 <vina> xerox: well telling the problem it the easier part :-)
11:29:52 <vina> I am developing a event logger in haskell
11:30:19 <vina> So in the first verstion, I had the type Event:
11:30:27 <xerox> One like the standard linux loggers?
11:31:03 <vina> data Event = Event {moment :: ClockTime , task :: Maybe Task}
11:31:24 <vina> xerox: I dont know this one, but is more ou less like Hourglass
11:32:38 <vina> so I stoped programming C in haskell, testing all the time when a task was or was not Nothing...
11:33:00 <vina> and wanted to construct a type like this:
11:33:27 <vina> data Event = StartEvent {moment :: ClockTime , task :: Task} | StopEvent {moment :: ClockTime}
11:33:51 <musasabi> vina: you might want to look at the missingh logging framework for ideas.
11:34:51 <vina> musasabi: someone's code is always a good source of good code
11:35:22 <vina> musasabi: but see, this program I'm developing is my first in haskell
11:35:49 <vina> musasabi: I wanted to develop till the end, and then throw it away, if it was the case
11:36:35 <vina> musasabi: surelly in version 2 I'll take this care
11:37:54 <vina> meantime, I just want to know if is there a way to pattern-match an event, extracting the moment, in one line of code
11:38:11 <vina> without testing the two possibilities
11:39:09 <tomaszz> vina: in this case you can simply write (moment e), where e :: Event
11:39:53 <tomaszz> vina: but it's possibly a better idea to move moment out of StartEvent/StopEvent
11:40:40 <tomaszz> vina: and for example define: data EventType = Start Task | Stop
11:40:46 <vina> tomaszz: I don't know if I didn't undestand your answer, but moment should be of type ClockTime...
11:41:23 <tomaszz> vina: record field labels can be used in two ways
11:41:30 <tomaszz> vina: three, actually
11:41:40 <tomaszz> vina: for pattern matching
11:41:55 <tomaszz> vina: when defining value of record type
11:42:00 <tomaszz> vina: and as a selector function
11:42:17 <tomaszz> vina: when you have variable e of type Event
11:42:45 <tomaszz> vina: you can write (moment e) to extract the value of field moment
11:43:12 <tomaszz> vina: this works because you have field moment in both data-constructors and those fields have the same type
11:43:20 <vina> tomaszz: Damn, It's just what I wanted...
11:43:46 <vina> tomaszz: You know, I used field labels only for documentation of the type
11:44:10 <vina> tomaszz: but in my entire program, I haven't used this feature yet
11:44:27 <ulfdoz> [A
11:44:28 <tomaszz> tomaszz: correction, there are more uses, for example in a record update expression
11:44:28 <vina> tomaszz: thank you VERY much!
11:44:44 <tomaszz> I am writing to myself...
11:44:52 <tomaszz> vina: you're welcome
11:44:54 <vina> tomaszz: i'm still with you :-P
11:45:24 <vina> musasabi: and musasabi, thank you too
11:45:28 <tomaszz> vina: I know, I just wrote to tomaszz - and that's me
11:45:40 <vina> tomaszz: Isaw it :-)
11:46:02 <tomaszz> I've got to go, bye
11:46:16 <vina> tomaszz: see ya
11:48:55 <vina> musasabi: I was looking at MissingH spec
11:49:54 <vina> musasabi: I'm developing some more related to a Personal task logging
11:50:01 <vina> musasabi: for PSP
11:55:42 <kzm_> Any good ideas how to debug "Error in array index"?
11:55:53 <shapr> kzm_: Where is it happening?
11:55:59 <kzm_> In my program.
11:56:05 <shapr> ok, but...
11:56:05 <xerox> Who would have said.
11:56:07 <kzm_> Which uses arrays all over the place.
11:56:10 <shapr> ah
11:56:14 <kzm_> :-(
11:56:24 <shapr> Why not make a safe array checker?
11:56:24 <cm> reduction stack! :
11:56:26 <xerox> You could make no guesses?
11:56:52 <kzm_> Well, you know, it would help if the error message indicated for instance which function was the culprit.
11:56:56 <shapr> Or alternately, catch the exception in various places and report it there.
11:57:09 <kzm_> Or if +RTS -xc told me something else than "CAF"
11:57:12 <integral> use NumberParamT to typecheck your array sizes?
11:57:46 <kzm_> Hmm... I guess I can wrap everything (it's mostly IOArrasy) with catch.
11:57:56 <kzm_> NumberParamT?  Phantom types?
11:58:41 <kzm_> Or replace all array ops with #defines using __LINE__ etc in the error checking code.
12:01:57 <shapr> integral: That's a neat idea.
12:03:21 <kzm_> What is NPT?
12:03:22 <dcoutts> @wiki Cabal/MultiPackageDistributables
12:03:22 <lambdabot> http://www.haskell.org/hawiki/Cabal/MultiPackageDistributables
12:03:32 <kzm_> @index NumberParamT
12:03:32 <lambdabot> bzzt
12:03:48 <dcoutts> SyntaxNinja, Igloo, so i've tried to summarise our discussion in the above wiki page.
12:04:22 <dcoutts> SyntaxNinja, Igloo, please tell me or just edit it yourself if you think I've left anything out.
12:04:47 <dcoutts> I've linked it from the Cabal/Design page
12:26:11 <thedward> @hoogle ( a -> Bool ) -> [a] -
12:26:12 <lambdabot> No matches, try a more general search
12:26:17 <thedward> @hoogle ( a -> Bool ) -> [a] -> [[a]]
12:26:18 <lambdabot> No matches, try a more general search
12:26:24 <thedward> @hoogle ( a -> b ) -> [a] -> [[a]]
12:26:25 <lambdabot> Prelude.mapM :: Monad a => (b -> a c) -> [b] -> a [c]
12:26:25 <lambdabot> Monad.filterM :: Monad a => (b -> a Bool) -> [b] -> a [b]
12:26:25 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
12:48:03 <ValarQ> psi: wb
12:49:12 <psi> hey
13:03:37 <SyntaxNinja> thanks, dcoutts
13:07:37 <dcoutts> SyntaxNinja, a problem with allowing 'private' info to flow from one package to another in a distributable (eg picking up .chi files from the build tree of dependent packages rather than the .chi files being installed) is that it precludes the possability to build just one extra package from a distributable. The principle should be that a distributable should always be able to be split up and built seperately.
13:10:44 <SyntaxNinja> I agree
13:11:10 <SyntaxNinja> a 'distributable' should be made up of proper cabal packages which may be inter-dependent.
13:11:23 <ndm> thedward, watch out - syntax errors results in the no matches warning :)
13:25:30 <dcoutts> yay! the first SOE demo from the SOE web site works with my new SOE implementation with no code changes (except for: import Graphics.SOE becomes import Graphics.SOE.Gtk)
13:26:00 <dcoutts> ibid, are you interested in the code. It could be adapted for the older gdk api if you need that.
13:26:01 <mcnster> congrats dcoutts :)
13:26:31 <dcoutts> and it's smooth :-) zero flicker, unlike the original implementation
13:26:57 <monochrom> Are you the guy contributing to the SOE package included in GHC?
13:27:16 <dcoutts> nope. this is a new implementation based on gtk/cairo
13:27:29 <SyntaxNinja> is it going to actually work?
13:27:31 <monochrom> Ah alright.  Still, you're cool.  <3
13:27:32 <thedward> SOE?
13:27:34 <SyntaxNinja> bbiab
13:27:44 <dcoutts> @google Haskell School of Expression
13:27:46 <lambdabot> http://haskell.org/soe/
13:27:55 <dcoutts> I'm probably going to distribute it with Gtk2Hs
13:28:07 <dcoutts> or on it's own as a cabal package
13:28:12 <thedward> ah
13:28:20 <dcoutts> it's only 500 lines or so
13:28:54 <dcoutts> http://haskell.org/~duncan/gtk2hs/SOE-cairo.png
13:29:03 <dcoutts> original vs. new
13:30:07 <dcoutts> To be honnest I don't know if anyone uses SOE for teaching
13:30:18 <dcoutts> but the idea is that this should be a drop in replacement
13:30:24 <shapr> dcoutts: You should send your SOE.Gtk to Hudak right away.
13:30:40 <shapr> Heck I might finally go through my Hudak book now that I'll be able to install SOE.
13:30:54 <dcoutts> shapr, I should yes
13:31:08 <dcoutts> it should actually be easer to install, even on win32
13:31:42 <dcoutts> (though not just yet on win32 since ther installers for gtk+cairo are not out yet)
13:32:15 <dcoutts> one of the problems with SOE has been the difficulty with keeping it up to date and installable
13:32:34 <CosmicRay> Is it possible that -split-objs on some platforms will fail?
13:32:41 <dcoutts> CosmicRay, yes
13:32:41 <CosmicRay> also, does cabal grok split-objs these days?
13:32:47 <dcoutts> CosmicRay, no
13:32:55 <CosmicRay> hmm.  I don't like either of those answers. ;-)
13:32:59 <dcoutts> :-)
13:33:01 <dcoutts> sorry
13:33:17 <CosmicRay> So, if I understand correctly, that means that any program that uses any code from a library -- even if just a small part -- has to link in the entire library?
13:33:24 <dcoutts> -split-objs fails on solaris I think, and linux ppc/ppc64. It sometimes works on linux sparc
13:33:36 <dcoutts> yes :-(
13:33:41 <CosmicRay> ugh.
13:33:50 <dcoutts> well something aproximating that
13:33:59 <Igloo> In the general case, yes
13:34:03 <dcoutts> I think the standard linkers can exclude some bits
13:34:10 <dcoutts> but probably only on a per-module basis
13:34:13 <shapr> Will x86 PIC be in 6.4.2?
13:34:14 <CosmicRay> -rw-r--r--  1 root root 5.3M Oct 10 08:17 /usr/lib/haskell-packages/ghc6/lib/MissingH-0.12.0/libHSMissingH-0.12.0.a
13:34:23 <CosmicRay> dcoutts: ahh.  well that is OK then.
13:34:30 <dcoutts> CosmicRay, you can strip the final executable
13:34:40 <CosmicRay> dcoutts: that also removes unused code?
13:34:48 <dcoutts> not sure
13:35:03 <CosmicRay> hmm, a binary that uses that library compiled to about 1.1M and stripped to 900K.
13:35:14 <CosmicRay> so obviously it does do some optimization, on i386 at least.
13:35:14 <dcoutts> -split-objs gives a much finer granularity on what the linker can strip off
13:35:18 <CosmicRay> I bet it doesn't on alpha.
13:35:41 <CosmicRay> could this be something that registerized platforms do better?
13:35:51 <CosmicRay> under 6.4, binaries on amd64 and alpha are huge
13:35:54 <dcoutts> yeah, I find ghc-produced exes are considerably bigger on sparc linux than x86 linux
13:35:55 <CosmicRay> much larger than i386
13:36:08 <CosmicRay> yeah, same thing I've seen.
13:36:33 <dcoutts> though -split-objs does now work on amd64
13:36:49 <Igloo> CosmicRay: IMO lumping unrelated things in the same package is silly anyway
13:38:21 <CosmicRay> Igloo: I see your point, but having dozens of tiny packages is silly as well.
13:38:22 <shapr> Still, MissingH can't beat 17MB  -rw-r--r--   1 root 17072628 2005-09-19 23:46 libHSbase.a
13:38:39 <shapr> hiya malcolm
13:38:50 * malcolm waves
13:39:07 <shapr> how's code?
13:39:25 <CosmicRay> BTW, I must just say that I have found a new appreciation for Haskell over the last few years.
13:39:34 <shapr> years?
13:39:35 <CosmicRay> it is amazing the speed with which I can experiment with new algorithms.
13:39:38 <CosmicRay> s/years/hours/
13:39:42 <CosmicRay> wow that was quite the braino
13:39:48 <malcolm> JohnMeacham: nobody stopped me putting an LGPL'd library into fptools.  But ghc won't ship with anything that isn't BSD.
13:40:09 <shapr> Yeah, Haskell is great for speed of change.
13:40:31 <CosmicRay> shapr: all sorts of stuff on my little gopherbot: multithreaded operation, ways of storing state, algorithms for making sure that we don't hit more than one server at once, in-memory caching of pending URLs, etc.
13:40:50 <CosmicRay> some performance optimizations worked, others didn't, and between Haskell and darcs it was very easy to experiment.
13:41:00 <CosmicRay> and also, in most cases, if my code compiled, it worked.
13:41:02 <CosmicRay> I like that.
13:41:21 <monochrom> I am reading CosmicRay the wrong way.  I misread him as: Haskell has sped me up from years to hours.  Consequently I'm very very thrilled.
13:41:37 <CosmicRay> so anyway, this is not news to anyone here, but I just had to mention it
13:41:41 <CosmicRay> monochrom: haha
13:41:52 <shapr> I wouldn't want to write a gopher spider in C.
13:41:56 <malcolm> I've probably changed about 2000 lines of code in one go, without incremental testing, and after getting past the compile errors, it pretty much works.
13:42:12 <CosmicRay> shapr: on alpha, -rw-r--r--  1 root root 17156258 Apr 22 17:41 /usr/lib/haskell-packages/ghc6/lib/MissingH-0.10.7/libHSMissingH-0.10.7.a
13:42:24 <shapr> not bad
13:42:33 <malcolm> (that's not a boast about my ability either, it's all down to Haskell I reckon)
13:42:33 <shapr> that's two mb more than base on x86
13:42:44 <CosmicRay> libHSbase on alpha is, oddly, only 18MB
13:42:48 <CosmicRay> this is ghc 6.2 tho
13:43:01 <CosmicRay> malcolm: yeah.  this is really great.
13:43:33 <CosmicRay> malcolm: I always knew this would be the case, but it's neat to actually experience it.
13:43:54 <CosmicRay> malcolm: if you were doing Java, you'd write 2000 lines of code to pop up a dialog box, and it still would crash ;-)
13:46:05 <pnou> ls
13:46:09 <pnou> sorry
13:46:42 <CosmicRay> pnou: as punishment, you must count the number of bits in /dev/null until you come up with a positive number
13:47:07 <CosmicRay> pnou: but really, 2 characters doesn't bug me much ;-)
13:47:35 <monochrom> I'm wondering if the holographic limit for blackholes apply to /dev/null.
13:49:51 <pnou> root@corwin:~# echo > /dev/null
13:49:51 <pnou> root@corwin:~# ls -l /dev/null
13:49:51 <pnou> crw-rw-rw-  1 root root 1, 3 2005-04-11 22:02 /dev/null
13:49:54 <pnou> done :-)
13:50:14 <CosmicRay> heh
13:53:00 <pnou> moreover in France, positive includes zero ;-)
13:54:03 <CosmicRay> darn french
13:54:12 <ValarQ> doesn't surprise me...
13:54:16 <CosmicRay> heh
13:54:21 <pnou> tsss
13:54:28 <CosmicRay> they probably just do that because positive doesn't include zero for everyone else ;-)
13:55:11 <MarcWeber> Good evening. I need some happy help. I've tried to copy he example from the documentation to test.y file. But I get some compilation errors. Do you have a compilable happy example to study?
13:55:12 <luqui> does negative include zero?
13:55:27 <pnou> yep
13:55:42 <Cale> no
13:55:47 <Cale> not usually
13:56:01 <Cale> well, possibly in France :)
13:56:09 <pnou> Cale: i'm talking about french convention
13:56:30 <Cale> ah, yes you are
13:56:44 <Cale> serves me right for jumping into the conversation in the middle :)
13:57:00 * shapr cackles happily
13:57:08 <shapr> Haskell makes coding so much fun!
13:57:16 <MarcWeber> if x<0 then -x >0, right? Thus 0 neither positive nor negative (?)
13:57:17 <Cale> yes it does!
13:57:18 <pnou> actually "x is greater than y" means "x is greater or equals to y"
13:57:49 <Cale> pnou: do they write "greater than and not equal to" signs?
13:57:56 <pnou> Cale: yep
13:57:59 <Cale> wow
13:58:09 <pnou> well
13:58:11 <CosmicRay> Cale: I don't even know what that would look like.
13:58:12 <pnou> the sign are the same
13:58:15 <malcolm> (x<0) implies not (x>=0)
13:58:30 <Cale> CosmicRay: like a greater than sign with a crossed out line underneath it
13:58:36 <CosmicRay> ah
13:58:39 <pnou> but they don't call them with the same name
13:58:45 <Cale> pnou: ah
13:58:46 <Cale> okay
13:59:07 <pnou> "x > y" is said "x is stricly greater than y"
13:59:16 <Cale> ah, okay
13:59:28 <Cale> so you at least use the same symbols :)
13:59:36 * dcoutts mails Paul Hudak
14:00:02 <pnou> Cale: what a shame! ;-)
14:00:18 <malcolm> Has anybody here been asking Arjan van IJzendoorn for the code for Dazzle?
14:00:22 <Cale> I was worried that you might have extended the terrible old notation for subsets to other orderings :)
14:00:25 <shapr> um, me
14:00:42 * earthy merely asked for the code for xtc
14:00:56 <earthy> and while Martijn didn't really have time for it, Arjan thought he could put some time into it
14:00:59 <malcolm> Arjan tells me he is getting requests daily.
14:00:59 <shapr> malcolm: I asked him for Dazzle code, I want the graph editor.
14:01:34 <earthy> thing is, Dazzle is not just his to disseminate
14:01:40 <malcolm> shapr: have you seen my version of Dazzle's graph editor on my blog?
14:01:45 <earthy> prof. van der Gaag funded it. :)
14:02:07 * shapr looks
14:02:41 <malcolm> AIUI, the main reason he can't release Dazzles is because it uses a closed-source bayesian engine (SMILE)
14:02:45 <shapr> malcolm: oooh
14:02:48 <shapr> nifty!
14:02:58 <earthy> um, smile isn't closed source, IIRC.
14:03:01 <ValarQ> woohoo, i'm almost done with my markov chain thingie :D
14:03:17 <ValarQ> and it only got two mayor problems!
14:03:23 <malcolm> But Arjan told me today he is willing to donate the diagram editor code to the community.
14:03:37 <pnou> by the way, when you say "x is included in y", can x be equal to y?
14:03:38 <ValarQ> s/mayor/major/
14:03:57 <earthy> ah, damn, yeah, it is closed source
14:04:54 <earthy> otoh, ripping the smile binding out isn't all that hard
14:04:55 <malcolm> so I'm going to set up a public darcs repository for the "Blobs" editor, and Dazzle is going to turn into just another client of the editor.
14:05:03 <shapr> w00
14:05:56 <dcoutts> @index unsafePtrEq
14:05:57 <lambdabot> bzzt
14:06:17 * dcoutts grumbles about old SOE code with broken imports
14:06:20 <ValarQ> shapr: hej formaren
14:06:30 <ValarQ> shapr: do you have a minute?
14:06:37 <shapr> Maybe, for what?
14:06:51 <Cale> How well-received do people think a proposal to extend the kind system would be, in general?
14:06:57 <ValarQ> http://arda.no-ip.org/markov.hs
14:07:11 <ValarQ> shapr: for laughing at my ugly code :)
14:07:57 <Cale> ski and I have been discussing including as kinds, restrictions on the kind * by typeclasses.
14:08:02 * shapr looks
14:08:33 <dcoutts> @index Memo
14:08:34 <lambdabot> bzzt
14:08:41 * ValarQ hopes he doesn't make shapr cry
14:09:29 <shapr> Hm, looks neat to me
14:09:53 <vina> hi people. Can somebody help me? I've asked a question today about pattern matching and field labels in disjoint constructors, but the solution that was presented didn't work.
14:10:07 <Cale> vina: okay
14:10:26 <ValarQ> shapr: oh, not a total failure then
14:10:44 <vina> Cale: supose I had this type:
14:10:44 <ValarQ> shapr: i'll have to work on it thought...
14:10:51 <vina> data Event = Event {moment :: ClockTime , task :: Maybe Task}
14:10:51 <Cale> ValarQ: that code doesn't look so bad :)
14:10:57 <dcoutts> @index reallyUnsafePtrEquality
14:10:58 <lambdabot> bzzt
14:10:59 <dcoutts> @index reallyUnsafePtrEquality#
14:11:00 <lambdabot> bzzt
14:11:05 <shapr> Definitely not. I haven't written any markov code before, so I can't make any brilliant observations but it looks nice.
14:11:12 <Cale> ValarQ: [x] ++ blah is the same as x : blah
14:11:36 <vina> Cale: Then I minded that tgis type should be more concise:
14:11:41 <ValarQ> Cale: thanks
14:11:56 <vina> data Event = StartEvent {moment :: ClockTime , task :: Task} | StopEvent {moment :: ClockTime}
14:12:01 <Cale> vina: okay
14:12:24 <shapr> I like folding over insertWith, that's a nice idiom.
14:12:24 <vina> Cale: Because I was always testing if task = Just something ou Nothing
14:12:25 <Cale> that will work, but you will have to be careful with the task function
14:12:57 <vina> Cale: I know, global scope. My problem is with pattern matching
14:13:02 <Cale> Now you have to test if you have a StartEvent or a StopEvent
14:13:21 <Cale> not the global scope, rather, task fails if applied to StopEvent
14:13:21 <ValarQ> shapr: i didn't know how to solve it in another way
14:13:36 <vina> Cale: Yes
14:14:03 <vina> Before, some functions worked independently of the type of Event
14:14:14 <dcoutts> @type GHC.Prim.reallyUnsafePtrEquality#
14:14:18 <lambdabot> forall a. a -> a -> GHC.Prim.Int#
14:14:21 <dcoutts> hah!
14:14:27 <Cale> hahaha
14:14:37 <vina> Cale: Do I have always to test both Constructors?
14:14:54 <Cale> vina: well, you're going to do some testing either way
14:15:16 <vina> Well, Supose that I have to implement (<)...
14:15:19 * ValarQ continues to code
14:15:19 <shapr> ValarQ: You can do "insertWith (++)" instead of "insertWith (\x y -> x ++ y)"
14:15:34 <vina> Cale: It doesn't matter the task, right?
14:15:50 <Cale> vina: then the first definition is better, because you can use deriving Ord
14:15:55 <ValarQ> shapr: oh
14:16:11 <vina> Cale: was my first implementation
14:16:27 <Cale> whereas the second definition, you could also do that, but you'll get a strange ordering
14:16:28 <ValarQ> shapr: that was almost a bit silly :)
14:16:43 <shapr> ValarQ: Nice code :-)
14:17:00 <vina> Cale: but I think the second, with disjoint constructor, maps better the domain of the problem...
14:17:02 <Cale> vina: of course, < isn't hard to define either way
14:17:08 <vina> Cale: yes
14:17:29 <Cale> x < y = (moment x) < (moment y)
14:17:30 <ValarQ> shapr: pretty hard for a C coder like myself thought
14:17:33 <shapr> I'd suggest using System.GetOpt or Pesco.GetOpt so "kalas.txt" can be a commandline parameter.
14:17:44 <shapr> ValarQ: and you picked up Haskell quickly too!
14:17:48 <vina> Cale: does that work????
14:17:48 <Cale> or just getArgs :)
14:17:54 <shapr> ValarQ: You are no longer a mere C coder!
14:17:56 <vina> Cale: Damn
14:17:58 <Cale> vina: what do you mean?
14:18:02 <sylvan> ValarQ just briefly looking. Is there any reason why you're not using tuples of three strings instead of a list (which is always of length 3)?
14:18:10 <ValarQ> shapr: it took me several days to come this far
14:18:12 * shapr gives ValarQ the badge of the golden lambda
14:18:17 <ValarQ> :)
14:18:32 <vina> Cale: So, the solutiohn proposed to me a few hours ago work
14:19:02 <Cale> :)
14:19:11 <vina> Cale: so, I think that _I_ am the problem :-(
14:19:33 <sylvan> ValarQ, also: [(take 3 xs)] ++ (markovb $ tail xs) probably looks better like this: take 3 xs : markovb $ tail xs
14:19:33 <vina> Cale: thanks a lot, Cale
14:19:38 <Cale> vina: don't worry, you're learning :)
14:19:48 <Cale> and you're quite welcome
14:20:29 <ValarQ> sylvan: thanks
14:20:40 <ValarQ> i'm learning quite a lot here :)
14:21:01 <vina> Cale: I have to tell this to tomaszz...
14:21:15 <Oejet> ValarQ: Be careful your head doesn't explode.
14:21:18 <Oejet> Good night all.
14:21:27 <davve> sylvan: so.. when are you going to implement the trex proposal in ghc? ;)
14:21:41 <sylvan> davve, haha, that'll take a while =)
14:21:50 <davve> sylvan, exjobb?
14:22:03 <sylvan> davve, not likely
14:22:18 <ValarQ> tokiga danskar...
14:22:19 <vina> Cale: You see, I was so eager (althoug haskell is lazy) to find a patter matching solution that I was blind for the obvious
14:22:38 <dcoutts> from ghc/compiler/prelude/primops.txt.pp:
14:22:39 <dcoutts> section "Unsafe pointer equality"
14:22:39 <dcoutts> --  (#1 Bad Guy: Alistair Reid :)
14:22:46 <dcoutts> primop  ReallyUnsafePtrEqualityOp "reallyUnsafePtrEquality#" GenPrimOp
14:22:47 <davve> sylvan, damnit
14:23:13 <Cale> vina: well, there are lots of ways to look at things :)
14:23:34 <dcoutts> and indeed it seems that Alistair Reid is the only user of this thing. :-) There are no other uses in the ghc libs.
14:24:08 <shapr> ValarQ: For extra monad points you might be able to steal Gen from QuickCheck and skip all that manual passing around of random number generators in getRandomIndex and makeText. You'd probably end up with a simple lift instead.
14:24:27 <thedward> @hoogle ( a -> Bool ) -> [a] -> ([a],[a])
14:24:28 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
14:24:28 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
14:24:28 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
14:24:39 <thedward> aha
14:24:59 <ValarQ> shapr: i haven't been working with the lift functions yet
14:25:12 <thedward> I knew there had to be a function like partition
14:25:41 <Cale> or look at my Random monad
14:25:59 <thedward> is there any web based tool that provides the equivalent of @hoogle?
14:26:01 <Cale> http://www.haskell.org/hawiki/MonadTemplateLibrary_2fMonadRandom
14:26:19 <Cale> thedward: it started out on the web
14:26:35 <Cale> http://www-users.cs.york.ac.uk/~ndm/hoogle/
14:26:58 * ValarQ disappears
14:27:08 <thedward> ah. silly me. thanks!
14:27:21 <shapr> ValarQ: btw, I like being called formaren :-)
14:27:45 <Cale> I think that ski and I have come up with a solution to the problem of Set not being able to be defined as an instance of Functor and Monad.
14:28:31 <dcoutts> @eval case GHC.Exts.reallyUnsafePtrEquality# undefined undefined of { 0# -> False; 1# -> True }
14:28:33 <lambdabot>  parse error on input `->'
14:28:33 <Cale> But it's going to need a bit of formalisation. :)
14:29:31 <shapr> malcolm: I'm sure you can guess why I want a graph editor... same reason I'm enthusiastic about the merging of Haskell2Xml and Xml2Haskell.
14:30:04 <malcolm> shapr: ah, web content management
14:30:31 <Cale> shapr: btw, if you come up with a way to convert postscript/pdf to svg, let me know :)
14:31:48 <dcoutts> @eval case GHC.Exts.I# (GHC.Exts.reallyUnsafePtrEquality# undefined undefined) of { 0 -> False; 1 -> True }
14:31:49 <lambdabot>  Not in scope: `#'
14:31:53 <dcoutts> bah
14:31:53 <malcolm> I have a small generator for SVG from graph diagrams...
14:32:03 <shapr> Cale: I've only found commercial products for that.
14:32:05 <dcoutts> eval doesn't use -fglasgow-exts
14:32:24 <dcoutts> malcolm, oh does that do the graph layout then?
14:32:48 <shapr> I want Haskell on Heat to keep everything in one or more Data.Graph values.
14:32:50 <malcolm> dcoutts: no, you have to do the layout by hand
14:33:03 <dcoutts> malcolm, oh ok I'll stick with graphviz
14:33:29 * dcoutts is planning on a module dependency graph view for hIDE
14:33:47 <shapr> I'm quite excited about the idea of doing i18n via graph parameterization. That would totally rock!
14:34:22 <autrijus> shapr: have you looked at my slides?
14:34:24 <malcolm> Hmm, can you get the output of graphviz as anything other than postscript?
14:34:29 <shapr> autrijus: Not recently
14:34:45 <autrijus> shapr: ok, I'd really appreciate feedback before jumping into killer-app-showcase
14:34:47 <shapr> autrijus: Hey, have you see Trac? How does it compare to RT?
14:34:53 <autrijus> shapr: http://perlcabal.org/~autrijus/tmp/haskell.xul
14:35:31 <dcoutts> malcolm, yes you can get png, svg, "dot" and several others
14:36:31 <dcoutts> malcolm, the "dot" form is most interesting since it's the same as the input language but with layout locations added. So it can be used by code to do other renderings.
14:37:02 <thedward> Cale: pstoedit can convert to svg
14:37:26 <malcolm> dcoutts: cool - so you could spit a diagram out to graphviz and get it back in nicely layed out
14:37:27 <Cale> autrijus: slide 16 is a bit odd in that where isn't part of expression syntax, but it's fine :)
14:37:35 <Cale> thedward: oh, cool
14:37:36 <shapr> autrijus: Hm, somewhere around slide 18 you might want to say 'evaluation' or ... hey you could go old school and describe the difference between function and procedure. Procedure originally meant something like 'code in the IO monad'.
14:37:39 <dcoutts> that's the route I'm planning on using, I'll get graphviz to do the layout and then I'll do the drawing (with zooming & panning) with cairo in a Gtk widget.
14:37:53 <thedward> pstoedit -f plot-svg tiger.ps > tiger.svg
14:38:02 <autrijus> Cale: elaborate? hmm
14:38:19 <Cale> where is part of the declaration syntax
14:38:25 <Cale> @eval x where x = 2
14:38:27 <shapr> Procedure specifically meant "something where the side-effect is important, not the result" and obviously, function meant the opposite.
14:38:27 <lambdabot> 2
14:38:34 <Cale> hmm... that's odd :)
14:38:43 <dcoutts> malcolm, the dot text file format is trivial to parse & print
14:38:44 <autrijus> I still don't get it :)
14:38:51 <Cale> doing that in ghci will result in a parse error
14:38:55 <autrijus> where/let has a duality.
14:38:58 <Cale> yes
14:39:09 <Cale> but where scopes over guards
14:39:29 <Cale> and is actually part of the declaration of the function and not an expression
14:40:01 <autrijus> Cale: got it.
14:40:09 <Cale> (so the where there would presumably go after the end of the current do-block
14:40:11 <Cale> )
14:40:14 <autrijus> shapr: not, will do it verbally
14:40:29 <sylvan> autrijus: I like your fibs example... is probably easier to explain to newbies than the zipWith one...
14:40:33 <shapr> It's funny how laziness gives you dead code elimination at runtime for free.
14:41:03 <shapr> It also gives you dynamic reordering. I suspect that could do a lot more than we use it for right now.
14:41:41 <autrijus> Cale: fixed.
14:42:02 <shapr> love the "typing sucks" bit
14:42:10 <Cale> heh
14:42:16 <Cale> yeah, I was just seeing that :)
14:43:05 <Cale> heh, P is for Polymorphic
14:43:16 <autrijus> :)
14:43:40 <shapr> autrijus: Can you use colors in your slides?
14:43:50 <autrijus> shapr: yes, will add later
14:43:54 <autrijus> after the contents
14:43:57 <Cale> colours matching the types and values :)
14:44:01 <autrijus> yup
14:44:04 <Speck> shapr: I don't think it follows in the takahashi style
14:44:25 <shapr> It took me ten seconds to find the difference between slides 45 and 46
14:44:36 <autrijus> lol
14:44:47 <Cale> who is this going to be presented to?
14:44:57 <autrijus> Cale: in Amsterdam: Euro OSCON
14:45:06 <Cale> cool :)
14:45:07 <autrijus> so, bunch of hackers in perl/python/php/ruby/java
14:45:12 <Cale> :)
14:45:13 <autrijus> then, in Nordic Perl Workshop
14:45:17 <autrijus> then, in OSDC Australia
14:45:19 <autrijus> among other places.
14:45:19 <Cale> uwahahaha!
14:45:38 * autrijus is trying to spread the lambda :)
14:45:50 <Cale> We can suck all those imperative programmers in and twist their minds :)
14:47:08 <sylvan> Cale, no we straighten their minds :-)
14:47:11 <boegel|home> autrijus: when I check out your slides, the alfa and beta's are small, and all other text is huge
14:47:18 <Cale> sylvan: how true :)
14:47:27 <autrijus> boegel|home: I think you need some sane truetype fonts
14:47:40 <boegel|home> autrijus: hmm, okay :) I won't bother
14:47:46 <autrijus> boegel|home: nah. linux?
14:47:48 <boegel|home> the huge text is meant to be, right ?
14:47:53 <boegel|home> autrijus: yeah, FC4
14:47:57 <autrijus> k sec
14:48:00 <autrijus> I'll add Vera
14:48:02 <shapr> I like it!
14:48:09 <autrijus> shapr: ooh!
14:48:15 <autrijus> shapr: any other concept you think I should show
14:48:20 <boegel|home> shadowie: yeah, it's cool
14:48:22 <autrijus> before plunging into the wonderful world of Real Apps?
14:48:35 <sylvan> autrijus, in slide 78, any reason for not using partition instead of list comprehensions.. i mean you've already showed them how list comprehensions work, so why not opt for brevity?
14:48:40 <shapr> The currying section is particularly nice.
14:48:48 <boegel|home> autrijus: mention darcs, gtk2hs, cairo binding ?
14:49:18 <boegel|home> s/shadowie/shapr
14:49:30 <work_metaperl> what's the URL to the slides? the one with .xul extension?
14:49:38 <sylvan> work_metaperl, yes
14:49:49 <autrijus> boegel|home: try refresh, see if it works
14:50:09 <shapr> autrijus: I call higher order combinators 'traversal essences', but I don't know how to fit that into the takahashi method.
14:50:10 <boegel|home> autrijus: 45=46 ? (only a smaller font)
14:50:23 <autrijus> only a smaller font? :-/
14:50:38 <autrijus> a sec
14:50:40 <sylvan> boegel|home, nope there's paranthesis added
14:50:57 <shapr> Also, you've probably got enough info in here to blow the mind of the average motivated commercial imperative programmer anyway.
14:51:06 <boegel|home> sylvan: oh, but the font is a little smaller too I think
14:51:15 <sylvan> yeah it is, to make it fit I suppose =)
14:51:18 <boegel|home> autrijus: same problem, small alfa, beta, lambda
14:51:27 <autrijus> boegel|home: can't help then :-/
14:51:30 <Cale> autrijus: I'd perhaps like to discuss a type system (really, kind system) extension with you, since perhaps you could have some idea of how tricky it would be to implement :)
14:51:35 <boegel|home> autrijus: how can I fix it ?
14:51:44 <work_metaperl> autrijus: slide 20. I dont see an "in" in the let statement
14:52:10 <autrijus> work_metaperl: sure, as there's no expression there
14:52:12 <sylvan> autrijus, do you plan to go into the technology stuff in depth, or just mention it? I think STM is pretty cool and something non-haskeller's will see the significande of
14:52:13 <work_metaperl> oh it's not a complete let
14:52:18 <autrijus> work_metaperl: maybe it is, maybe it's in a monad
14:52:32 <autrijus> sylvan: look to the later slides, there's a table of content, STM is among them
14:52:45 <autrijus> Cale: sadly, I think I need to focus on the slide a bit... maybe next week
14:52:53 <Cale> okay :)
14:52:58 <autrijus> work_metaperl: (in do notation you don't need the 'in')
14:53:05 <work_metaperl> oh
14:53:18 <work_metaperl> @type oneOf
14:53:19 <lambdabot> bzzt
14:53:24 <sylvan> autrijus, yeah but I wasn't sure if you're just mentioning it in passing.. Maybe you should demonstrate them with a few quick examples (copy-paste from the STM-paper =))
14:53:27 <autrijus> sylvan: re brevity, point take
14:53:32 <autrijus> sylvan: yes, I'll expand each
14:53:36 <autrijus> this is work in progress :)
14:53:36 <boegel|home> autrijus: http://www.elis.ugent.be/~kehoste/Screenshot.png (any way I can fix this ?)
14:53:36 <Maddas> @type Text.ParserCombinators.Parsec.oneOf
14:53:38 <lambdabot> forall st.
14:53:38 <lambdabot> [Char] -> Text.ParserCombinators.Parsec.Char.CharParser st Char
14:53:39 <sylvan> ah
14:53:39 <work_metaperl> what is oneOf? in slide... hmmm ,lost my slide numbers
14:54:03 <boegel|home> autrijus: it's really cool :)
14:54:06 <Cale> It's a function which takes a string of characters and produces a parser which will accept any one of them
14:54:16 <work_metaperl> wow
14:54:17 <sylvan> work_metaperl, a parser which parse one of the stuff in the list
14:54:17 <boegel|home> also the white and blach/huge text works really well
14:54:24 <work_metaperl> from parsec?
14:54:27 <Cale> yes
14:54:27 <boegel|home> @index oneOf
14:54:27 <work_metaperl> oh
14:54:28 <lambdabot> Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec
14:54:28 <shapr> Yeah, I like white on black
14:54:34 <work_metaperl> yes, Maddas said that long ago :)
14:54:38 <Maddas> :)
14:54:38 <sylvan> =)
14:54:46 <boegel|home> sorry then :)
14:54:58 <shapr> Man, everyone is so helpful here!
14:55:06 <Cale> :)
14:55:09 <autrijus> sylvan: like this? http://perlcabal.org/~autrijus/tmp/haskell.xul?page=79
14:55:09 <Maddas> boegel|home: You have been excused.
14:55:13 <boegel|home> shapr: haven't we always been ?
14:55:28 <work_metaperl> you know the wildest thing I've seen lately? the Sieve of Erastosthenes in "The Haskell Road..." amazing program if you think about what is happening in terms of list manipulation
14:55:32 <shapr> Maybe we should have a yearly holiday ... "Act Like #java Day"
14:55:43 <Cale> work_metaperl: yes, that's a nice example :)
14:55:45 <boegel|home> fuck you dude, don't go asking that here
14:55:51 <shapr> Then we could kick people off the channel for asking questions.
14:56:01 <Maddas> shapr: Haha.
14:56:12 <autrijus> boegel|home: try install oneOf ["Anonymous", "Lucida Console", "Andale Mono"]
14:56:22 <Cale> @eval let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in take 20 primes
14:56:24 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
14:56:41 <Cale> fairly memorable piece of code :)
14:56:42 <work_metaperl> @type tail
14:56:43 <lambdabot> forall a. [a] -> [a]
14:56:49 <Maddas> <newbiee> "What does the "Act like #Java Day" in the topic mean?"    * newbiee was kicked by shapr (Too many questions asked.)
14:56:52 <autrijus> @pl let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in take 20 primes
14:56:53 <lambdabot> (line 1, column 45):
14:56:53 <lambdabot> unexpected "="
14:56:53 <lambdabot> expecting variable, "(", operator, ";" or "in"
14:56:55 * shapr laughs
14:57:00 <sylvan> autrijus, I think where (before,after) = partition (<pivot) xs
14:57:02 <work_metaperl> can that fibs work with tail returns a list?
14:57:03 <sylvan> is better
14:57:18 <work_metaperl> slide 34
14:57:31 <autrijus> work_metaperl: sure
14:57:31 <sylvan> and then qsort (pivot:xs) = qsort before ++ [pivot] ++ qsort after
14:57:44 <sylvan> (i like to use ++ on both sides, just looks nicer =))
14:57:50 <Cale> sylvan: I'm not so sure for a presentation to non haskellers
14:57:56 <work_metaperl> oh a list comprehension takes the list one at a time
14:58:00 <Cale> It creates more things which need explaining
14:58:10 <work_metaperl> that fibs is  really a beautiful program
14:58:11 <sylvan> Cale, partition?
14:58:15 <Cale> yeah
14:58:31 <sylvan> Hardly more work than explaining to filter calls or two list comprehensions
14:58:31 <Cale> though it is somewhat nicer in an absolute sense, I agree
14:58:39 <Cale> I suppose :)
14:58:40 <sylvan> s/to/two
14:59:00 * boegel|home leaves for bed
14:59:04 <boegel|home> bye everyone !
14:59:24 <Maddas> Good inght!
14:59:24 <Cale> later boegel|home
14:59:41 <Maddas> Er, night.
15:00:06 <sylvan> autrijus, by the current look, it seems like you're betting thouroughly owned by the lack of horizontal real-estate on slides =)
15:00:19 <sylvan> s/betting/getting
15:00:36 <kosmikus> autrijus: just looking at your slides, but haven't read all the previous comments, so apologies in advance for anything that's already been said
15:00:38 <autrijus> sylvan: try again http://perlcabal.org/~autrijus/tmp/haskell.xul?page=79
15:00:41 <autrijus> kosmikus: no prob
15:00:43 <sylvan> better =)
15:01:04 <kosmikus> autrijus: when comparing declarative and imperative, why do you use where and reverse the order; you could use let and have the examples be completely symmetric
15:01:06 <rep> wooot i start working on october 31st!
15:01:10 <sylvan> I usually use "less" and "more" :-)
15:01:40 <autrijus> kosmikus: fixed, please refresh
15:01:51 <sylvan> autrijus, also, you forgot the base case on qsort
15:02:11 <autrijus> sylvan: point. fixed
15:02:20 <kosmikus> autrijus: ah, you do both, I see
15:02:27 <autrijus> kosmikus: but I agree; let is now introed first
15:03:31 <kosmikus> autrijus: a <=> b to say that two functions are equal?
15:03:34 <sylvan> autrijus, minor point, but I think you should say "a <=> b !" (not the exlamation mark) to contrast the question mark in the earlier slide
15:03:39 <autrijus> kosmikus: two things are equal
15:03:58 <autrijus> sylvan: k, added
15:04:14 <kosmikus> autrijus: anyway, why <=>, not =?
15:04:43 <work_metaperl> equivalance is three bars IFF is <=>
15:04:48 <work_metaperl> equal is yet another thing
15:05:07 <sylvan> maybe equal is better here?
15:05:20 <sylvan> although they may not have equality defined...
15:05:27 <autrijus> kosmikus: well, because I use <=> as "is interchangable with"
15:05:33 <kosmikus> hmm, ok
15:05:34 <work_metaperl> autrijus: slide 38. I think that should say: "Types rock. Typing sucks" (not Type rocks)
15:05:34 <autrijus> so it's neither = nor ==
15:06:13 <kosmikus> autrijus: depends on what you say with the slide, of course
15:06:45 <autrijus> work_metaperl: fixed
15:06:57 <autrijus> kosmikus: yeah. I'll stick with <=> for now
15:07:40 <work_metaperl> that qsort confuses me!
15:08:01 <autrijus> work_metaperl: blame sylvan!
15:08:18 <work_metaperl> the one in Why haskell is much easier to understand
15:08:19 <sylvan> uhoh! You can't prove anything!
15:08:30 <sylvan> work_metaperl, I agree totally!
15:08:42 <kosmikus> autrijus: what's on the slide after "print (take 999 fibs)"? I see only a tiny "::" symbol ...
15:08:46 <autrijus> work_metaperl: so, what is confusing you?
15:08:49 <autrijus> kosmikus: it is supposed to be huge
15:08:54 <autrijus> kosmikus: so you also lack the font :-/
15:09:11 <autrijus> kosmikus: each part is annotated with one symbol from the Great Haskell Brand
15:09:28 <kosmikus> autrijus: ah, I see
15:09:33 <work_metaperl> autrijus: the pattern matching on the left. I never see "rest" calculated
15:10:09 <autrijus> work_metaperl: wait, refersh http://perlcabal.org/~autrijus/tmp/haskell.xul?page=78
15:10:32 <Cale> (and don't forget to look at the next slide too)
15:11:01 <autrijus> but good point
15:11:02 <work_metaperl> nibro's M.S. Thesis on haskell server pages is looking good for haskell technology... shows how to code up bbs's and use haskelldb
15:13:30 <autrijus> ok, qsort improved
15:13:41 <autrijus> (same url as above)
15:13:43 <work_metaperl> autrijus: would that other one work?
15:14:04 <autrijus> what other one?
15:14:06 <kosmikus> autrijus: in the fac example, don't you want to do "fac = \x -> case x of 0 -> 1; x' -> x' * fac (x'-1)" or similar to emphasize the similarity to the slide before?
15:14:11 <sylvan> autrijus, the n is not in scope in the list comprehension when you do n < x
15:14:18 <sylvan> you need to place the comparisons after the generator
15:14:32 <autrijus> er, silly me.
15:14:42 <autrijus> fixed
15:15:14 <autrijus> kosmikus: I used that, yes, but then I'd like to talk about _ at least once.
15:15:19 <kosmikus> ok
15:15:24 <autrijus> the aim of this talk is to have people not Freak Out
15:15:25 <work_metaperl> autrijus: the quicksort like this is the clearest: http://haskell.org/aboutHaskell.html
15:15:30 <autrijus> when staring at real haskell code
15:15:38 <kosmikus> autrijus: [7.5..] looks rather cryptic to me ;)
15:15:45 <work_metaperl> autrijus: how do you generate slides in xul?
15:16:05 <autrijus> work_metaperl: click "View Source"
15:16:10 <shapr> I just saw a post on LtU that makes me wonder, maybe you want to mention/show that if-then-else is a 'function' in Haskell?
15:16:11 <autrijus> kosmikus: give me something interesting from Enum
15:16:34 <autrijus> work_metaperl: better, press Ctrl-E
15:16:37 <autrijus> you'll be surprised.
15:16:45 <autrijus> (and press Ctrl-E again.)
15:17:05 <work_metaperl> wow
15:17:14 <autrijus> work_metaperl: high tech
15:17:23 <autrijus> not the same sort of high tech as haskell, but still high tech.
15:17:37 * shapr snickers at http://lambda-the-ultimate.org/node/view/1045
15:18:27 <Cale> Jacques is great :)
15:18:38 <shapr> WYSIWYG is dead, "results-oriented" is the new GUI paradigm.
15:18:46 <Cale> He was working on Coconut with us :)
15:19:41 <kosmikus> autrijus: ah, you're demonstrating slowsort ;)
15:19:57 <autrijus> kosmikus: *sigh* yes. want me do hammings instead? :)
15:20:08 <autrijus> I did that in the interview already
15:21:08 <kosmikus> autrijus: not sure.
15:21:10 <sylvan> merge-sort is nice =)
15:21:24 <autrijus> sylvan: too complicated
15:21:30 <autrijus> 6 lines is max in takahashi
15:21:40 <sylvan> hmm... put it on two slides
15:21:46 <sylvan> mergesort on one, and merge on the other
15:21:50 <sylvan> :-)
15:21:52 <autrijus> can't backreference :)
15:21:59 <autrijus> (all sorts of weird cognitive restrictions)
15:22:08 <sylvan> wth is this takahashi?
15:22:30 <autrijus> some japanese guy who maxed out fonts introducing ruby (on rails, etc)
15:22:50 <davve> autrijus, but ruby sucks ;)
15:22:59 <autrijus> davve: yeah, I here javascript is the new ruby
15:23:06 <autrijus> which is why I'm hacking this javascript/xul applications
15:23:08 <autrijus> ;)
15:23:21 <autrijus> s/here/hear/
15:23:35 <davve> never used javascript but i's probably bettar than ruby
15:23:35 <sylvan> autrijus, so he set up a bunch of rules on what you can and can not do when making a presentation?
15:23:49 <kosmikus> autrijus: ok, I'm through. Everything was minor. I think it's very good.
15:23:58 <autrijus> kosmikus: thanks!
15:24:11 <autrijus> sylvan: at first by example, but yeah.
15:24:16 <shapr> I think it's like "How to do PowerPoint presentations that don't suck."
15:24:44 <sylvan> well so if you introduce an operator, say, ~~~ that merges two lists one slide n, and then mergesort using that on slide n+1, that's wrong?
15:25:58 <autrijus> sylvan: that would be okay.
15:25:59 <shapr> It's too much for a Java programmer who doesn't do operator overloading.
15:26:33 <shapr> hiya interfer`
15:26:38 <autrijus> if I want to show userdefined operator, I'd show hammings
15:26:47 <autrijus> but I'm convinced it's peripheral at best.
15:27:03 <autrijus> as is `infix`
15:27:34 <sylvan> well still, people may object that qsort is slow because you don't randomly choose a pivot element, so merge-sort may be a better real-world example that's still pretty short and sweet
15:27:57 <interfer`> shapr, hi
15:28:49 <kosmikus> sylvan: that's not a real argument; if you compare with imperative code, it's not the part that randomly chooses a pivot that makes the difference in loc
15:29:21 <shapr> interfer`: Are you learning Haskell? Have any questions?
15:29:44 <autrijus> sylvan: yup, but all things considered, I think qsort won't freak people out
15:30:02 <autrijus> and we have plenty of Haskell-beats-imperative-down-cold technologies to show after that slide.
15:30:16 <sylvan> true enough...
15:30:35 <autrijus> but thanks for the "partition".
15:30:39 <sylvan> np
15:31:57 <interfer`> shapr, i haven't worked with haskell in a few months - i just never took #haskell out of my autojoin :)
15:32:26 <shapr> Well, now you have another chance!
15:32:45 <shapr> interfer`: btw, gorgeous tree on the background there. Did you take that pic?
15:32:51 <interfer`> shapr, i did
15:32:58 <kosmikus> autrijus: when's the talk?
15:33:07 <interfer`> shapr, it's at an amazing park nearby my school
15:33:11 <autrijus> kosmikus: in 3 days
15:33:15 <autrijus> *panicks*
15:33:18 * autrijus goes back slidehacking
15:33:21 <shapr> interfer`: Can I have your permission to use that pic on my desktop?
15:33:27 <interfer`> shapr, sure :)
15:33:40 <autrijus> kosmikus: Euro OSCON, then Nordic Perl Workshop, then OSDC Australia
15:33:52 <autrijus> kosmikus: and probably other places as well
15:33:56 * autrijus spreadeth the lambda
15:33:57 <shapr> interfer`: spiffy! thanks!
15:33:58 <kosmikus> great. you come around :)
15:34:23 <autrijus> kosmikus: :)
15:35:42 <shapr> interfer`: The background on galoot.org is almost as nice. If it were a bit more clear...
15:36:41 <interfer`> shapr, i agree, it's a shame it was so cloudy when i was there
15:36:44 <kosmikus> autrijus: good luck with it; I'm leaving for today ...
15:36:58 <interfer`> shapr, from that spot, on a clear day, you would be able to clearly see the manhattan skyline in the distance
15:37:01 <autrijus> kosmikus: enjoy, thanks!
15:38:56 <shapr> Well, I hope you take a photo on a clear day.
15:39:56 <shapr> hi dave
15:40:03 <dave_m> hi, shapr
15:40:04 <shapr> How're the comonads treating you?
15:40:26 <dave_m> I've made some real progress using them with attribute grammars
15:40:51 <shapr> neat
15:41:47 <dave_m> I think there's a possibility for a comonad-based XML library
15:42:11 * dcoutts wrestles the SOE ball animation demo into working correctly
15:43:42 <shapr> Hm, I need to add lists to the Flippi markup.
15:47:23 <shapr> dave_m: Oh hey, check out my cool toy: http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?edit=TestMargin
15:47:53 <wilx> Hmm, still no 6.4.1 port for FreeBSD.
15:48:05 <wilx> Somebody is slacking.
15:50:04 <shapr> Er, should have been "view" oops
15:50:09 <autrijus> wilx: I simply changed the version in ports and it worked (modulo some deleted files/)
15:50:42 <wilx> Hmm.
15:50:50 <autrijus> or you want my /usr/local/lib/ghc-6.4.1 ?
15:50:56 <dave_m> shapr: cool. I can think of times when that would be handy
15:51:19 <autrijus> (x86 6.0-BETA5)
15:52:22 <shapr> Yeah, I hope it'll let me read what other people have written into their margins.
15:52:26 <wilx> Nope, I have just 5.4. I will wait a little more time before I start hacking the port myself :)
15:53:11 <autrijus> prod simonmar@ms
15:59:11 <Cale> shapr: Is it possible to define a more convenient LaTeX notation for the wiki? Something like how inline code gets `
16:06:21 <shapr> huh?
16:06:45 <shapr> oh
16:06:48 <shapr> hm
16:07:33 <shapr> I can probably hack it up, but ask me later, I'm hacking on FLM right now. In fact, I'm even more likely to hack it up for Flippi instead of Moin.
16:07:59 <Muad_Dib> shapr the hackr
16:08:00 <Muad_Dib> :)
16:09:51 <shapr> Hey, I'm making progress, I'm happy.
16:10:23 * Cale types up a proposal for an extension to the kind system
16:12:17 <dave_m> Cale: what are you proposing?
16:12:50 <Cale> dave_m: Subkinds of * given by class contexts.
16:13:21 <Cale> Together with subtle changes to the meaning of class and data declarations with class contexts.
16:13:38 <Cale> Which would hopefully allow things like Set to be in the class Functor and Monad.
16:13:54 <dave_m> Ah, the holy grail
16:14:30 <dave_m> Have you read Hughes's proposal for well-formed types?
16:15:07 <Cale> Yeah, I saw that, but it seemed a bit ugly to me
16:15:16 <Cale> even though it did solve the problem
16:15:26 <dave_m> yeah, I didn't care for it either
16:15:32 <Cale> The extension that I propose wouldn't require syntax changes
16:15:44 <Cale> except the syntax for kinds, where it occurs
16:16:23 <dave_m> I look forward to seeing it
16:17:13 <Cale> The basic idea is that for every class context cx with a single free variable, say a, you introduce a kind: {a | cx}
16:17:25 <Cale> consisting of those types which meet that class context.
16:17:39 <Cale> data Eq a => Set a = NilSet | ConsSet a (Set a)
16:18:06 <Cale> now gives the type constructor Set the kind {a | Eq a} -> *
16:18:38 <shapr> g'day Pseudonym
16:18:50 <Pseudonym> G'day.
16:18:59 <Cale> and so we can infer that wherever Set is applied to a type, it must be in Eq
16:18:59 <Pseudonym> So, who's going to be on the Haskell 06 committee?
16:19:03 <Cale> (in this case)
16:19:38 <dave_m> Cale: sounds good so far
16:19:50 <Cale> and class Functor (f :: * -> *) where fmap :: forall a,b :: *. (a -> b) -> (f a -> f b) becomes...
16:20:24 <Cale> class Functor (f :: k -> *) where fmap :: forall a,b :: k. (a -> b) -> (f a -> f b)
16:21:05 <dave_m> so there's some kind polymorphism as well
16:21:09 <Cale> yes
16:21:28 <Cale> there's a subkind relation defined in the obvious way
16:21:43 <Cale> and every one of my new kinds is a subkind of *
16:21:56 <Cale> which I'd personally like to rename to Type, but whatever :)
16:22:39 <dave_m> so, do you have to declare the kind of 'f' in Functor f, or is that inferred?
16:22:45 <Cale> inferred
16:22:56 <Cale> by the kind of the constructor which you're applying it to
16:23:07 <Cale> er
16:23:10 <Cale> which f is
16:23:17 <Cale> by the data declaration
16:23:59 <dave_m> Oh, so I guess when you're doing Functor (f :: k -> *), that k can't turn out to be * -> * or something
16:24:05 <Cale> right
16:24:07 <Cale> k < *
16:24:21 <Cale> I should have mentioned :)
16:24:53 <Maddas> I'm not sure whether it would make sense to do so, but can one export type declarations from a module?
16:24:54 <Cale> Does this seem reasonable?
16:24:58 <dave_m> I guess that keeps things sane; I'd hate to have to explain fully polymorphic kinds to newbies
16:25:06 <Maddas> Since it's "only" an alias, it's clearly not necessary, but it might be handy
16:25:07 <Cale> :)
16:25:20 <Cale> Maddas: I'm fairly sure you can
16:25:22 <dave_m> Maddas: yes
16:25:25 <Maddas> What's the syntax?
16:25:36 <Cale> same as the syntax for exporting anything else
16:25:42 <dave_m> You just mention the type name in the module clause
16:25:50 <Maddas> hm, GHCi seems to choke on that :-(
16:26:13 <Maddas> oh, ack!
16:26:16 <dave_m> what are you trying to do?
16:26:26 <Maddas> I just forgot commas for the previous items in the export list. Bah. Thanks :-)
16:26:55 <dave_m> Cale: it sounds reasonable to me
16:27:10 <Maddas> (Or commata?)
16:27:28 <dave_m> ?
16:27:42 <Maddas> Never mind, commas is right. Sorry for bothering :-)
16:29:47 <Cale> hmm... I may have to generalise things a bit to play nicely with multiparameter type classes.
16:29:58 <Cale> in
16:30:07 <Cale> data (CFoo a b) => Foo a b = ...
16:30:56 <Cale> we can't factor so that we only have subkinds of *
16:32:30 <Lunar^> Igloo: I don't remember: was there anything blocking an updated cpphs debian package?
16:33:19 <Igloo> Lunar^: Only time, but AFAIK the current one won't cause any problems
16:33:43 <Lunar^> Igloo: malcom fixed the #def issue in 1.0
16:33:57 <Igloo> But that only matters when compiling with ghc
16:34:17 <Lunar^> Igloo: which matters if I want to get hscurses in the archive
16:34:25 <Igloo> Why?
16:34:37 <Lunar^> Igloo: because hscurses works only with GHC, AFAIK
16:34:40 <Igloo> (when compiling cpphs with ghc)
16:34:56 <dave_m> Cale, the obvious choice would be a subkind of (*,*), but that opens a whole can of worms
16:35:38 <Lunar^> Igloo: it's not really a problem, because I have removed the commented hsc2hs directives which actually made problems, but that's an uncessary patch
16:36:41 <Cale> dave_m: hmm
16:37:07 <Lunar^> Igloo: now I remember, there was also the truncated output issue
16:37:33 <Igloo> Oh, sorry, the truncated one is what not compiling with ghc fixes
16:37:51 <Igloo> Right, so the #def problem will still exist
16:38:18 <Lunar^> Igloo: would that help if I provide you an updated package?
16:38:36 <Igloo> No
16:38:54 <Igloo> Checking yours would be no easier than making my own
16:39:01 <Lunar^> That's what I though
16:39:07 <dave_m> Cale, or maybe { a -> b -> * | CFoo a b} < (* -> * -> *)
16:39:17 <Cale> yes
16:39:24 <Cale> or ski just suggested to me
16:39:36 <Cale> {a | } -> {b | CFoo a b} -> *
16:40:11 <ski> hi dave_m
16:40:19 <dave_m> hi, ski
16:41:35 <ski> dave_m : another thing ..  (.>>) :: Comonad w => w a -> b -> w b  actually just needs Functor w
16:41:51 <ski> (in your category lib)
16:41:57 <dave_m> Cale, here's an ugly case for you: data T a = forall b. C a b => T a b
16:42:04 <dave_m> ski: yeah, I noticed that later
16:42:25 * ski thinks (.>>) is fairly useless
16:42:49 <Cale> http://www.haskell.org/hawiki/ClassRestrictedKinds -- here's the start of it anyway, feel free to edit :)
16:42:51 <dave_m> it's a holdover from one of the original Comonad papers
16:42:55 <Cale> hmm
16:42:55 <ski> (hm, yes, i thought existentials could possibly be problematic)
16:43:39 <ski> (dave_m : yes, Kieburtz thought it'd be analogous to (>>) .. which it of course isn't)
16:45:01 <dave_m> Indeed; I think Kieburtz was trying too hard to make the comonads seem like monads
16:45:29 <ski> indeed
16:46:04 <Cale> hmm... tricky
16:46:28 <ski> (dave_m : btw, possibly  transform :: s -> Context s s  would be a useful primitive ..)
16:47:50 <dave_m> ski: what would it do?
16:47:59 * ski apologizes for trying to steer over the discussion to comonads :)
16:48:21 <ski> the obvious thing
16:48:50 <ski> transform s = Context id s
16:49:27 <Cale> Well, let's see, I suppose it's {a | exists b. C a b} -> *
16:49:28 <ski> (/me invented 'transform' for a sort-of application of the state-in-context comonad)
16:49:40 <Cale> but that's a hard sort of thing to deal with
16:49:56 <ski> hm
16:50:12 <ski> Cale : which kind are you resticting, there ?
16:50:17 <Cale> *
16:50:23 <dave_m> How would that look using the lambda cube syntax...?
16:50:27 <ski> (in 'data T a = forall b. C a b => T a b', i.e.)
16:50:36 <Cale> Sorry, I don't know the lambda cube syntax :)
16:50:52 <Cale> In particular, my background is pure math
16:51:05 <Cale> ski: yes
16:51:32 <ski> Cale : but *which * kind in there ?
16:51:39 <dave_m> There have been a few proposals for intermediate languages based on the lambda cube for Haskell compilation
16:51:40 <Cale> hm
16:51:56 <ski> Cale : the kind of 'a' ??
16:52:09 <ski> Cale : the kind of 'b' ??
16:52:11 <dave_m> I thought that was the kind of T
16:52:18 <Cale> ski: T is a type constructor with one parameter
16:52:23 <ski> indeed
16:52:32 <dave_m> T :: { a | exists b. C a b } -> *
16:52:32 <Cale> T :: {a | exists b. C a b} -> *
16:52:37 <dave_m> jinx
16:52:42 <Cale> hehe
16:53:09 <Cale> but this introduces a bunch of kinds which may be hard to reason about
16:53:13 <ski> i'm not convinced any constraining of 'a's kind is needed, here
16:53:23 <Cale> really?
16:54:02 <Cale> I mean, you could do that, and maintain the usual properties.
16:54:13 <Cale> But it would be slightly unnatural
16:54:18 <ski> before, we wanted constrainings when we wrote    data (...) => Foo ... = ....   and noticed that that didn't get us exactly what we wanted
16:54:28 <dave_m> I actually *have* used a type like that, but there was a functional dependency involved
16:54:46 <ski> but here you have  data Foo ... = forall ... . (...) => ...
16:54:51 <Cale> ski: It didn't?
16:55:14 <ski> data Ord a => Set a = ...   currently in haskell doesn't give us what we want, no
16:55:18 <Cale> oh
16:55:20 <ski> that was sort of the point
16:55:22 <Cale> yes, of course
16:55:36 <Cale> I thought you were referring to the additional kind constraints made
16:56:20 <Cale> The idea is just to extend things so that they apply naturally.
16:56:30 <ski> no, just to a presently legal haskell definition, which we maybe might want to change semantics of  (or allow another syntax for getting what we want)
16:56:38 <ski> yes, sure
16:57:42 <Cale> It would seem that the natural thing to do in the case of data T a = forall b. C a b => T a b, is to restrict the kind of T to just those types 'a' which would work.
16:58:40 <ski> in the case of 'data (...) => Foo ... = ...' we wanted to restrict those arguments to Foo that had constraints in '(...) =>'  (not necessarily using same syntax)
16:59:05 <ski> maybe
16:59:11 <ski> i'm not sure, that's all i say
16:59:25 <Cale> The set of types which work in this case is {a | exists b. C a b}
16:59:33 <Cale> but I'm not sure if we can deal with that
16:59:39 <Cale> Can we?
16:59:48 <Cale> (regardless of syntax for it)
17:00:09 <Cale> we could ignore the constraint here
17:00:22 <Cale> but it would be a little odd is all
17:00:26 <dave_m> I wouldn't worry too much about it; it's an unusual corner case
17:00:37 <ski> (a :: *) x (b :: *) x> C a b
17:00:38 <ski> hmm
17:00:55 <ski> we want to get smooth features
17:02:02 <dave_m> to clarify: don't worry about it too much *yet*; there may be more important stumbling blocks ahead
17:02:10 <ski> m, point
17:02:49 <ski> (dave_m : btw, i'd like to, at some time, discuss comonads :)
17:04:02 <dave_m> ski, I'm always up for learning more about comonads
17:04:23 * ski doesn't have much time, rn, though ..)
17:04:59 <ski> hm
17:05:16 <ski> i'm thinking
17:05:29 <Pseudonym> I prefer pomonads, which are social constructs which are free to find their own expression as part of a larger cultural narrative.
17:05:35 <ski> data Foo ... = forall ... . (...) => ...
17:05:41 <dave_m> :)
17:05:58 <ski> that in some way the constrainst are more 'private' to the type here than in
17:06:08 <ski> data (...) => Foo ... = ...
17:06:18 <ski> maybe i'm mistaken ..
17:07:10 <ski> (hm .. pomset logic :)
17:07:16 <dave_m> Can you draw a meaningful distinction between 'data T a = exists b. C a b => T a b' and 'data exists b. C a b => T a = T a b'?
17:07:33 <ski> how about
17:07:49 <ski> well
17:08:08 <ski> you actually mean s/exists/forall/ in the first case, at least, yes ?
17:08:42 <dave_m> The haskell syntax is "forall", but the meaning is exists; they were trying to conserve keywords
17:08:52 <ski> i think not
17:09:08 <ski> i think it's reasonable to have 'forall' there
17:09:22 <dave_m> Sure, but that's not what it means.
17:09:27 <ski> sure it is
17:09:33 <ski> i'll show
17:09:44 <ski> data SomeC = forall x. Show x => SC x
17:09:47 <dave_m> 'data T = forall a. T a' is existential. 'data T = T (forall a. a)' is universal
17:10:01 <ski> forall x. Show x =>  SC :: x
17:10:11 <ski> forall x.  SC :: Show x => x
17:10:17 <ski> SC :: forall x. Show x => x
17:10:19 <ski> see
17:10:38 <ski> um
17:10:52 <ski> of course i forgot to add '-> SomeC' at the end now :)
17:11:03 <ski> so
17:11:09 <ski> forall x. Show x =>  SC :: x -> SomeC
17:11:13 * THC4k ist away (Random Number generation is too important to be left to chance)
17:11:16 <ski> forall x. Show x =>  SC :: x -> SomeC
17:11:25 <ski> forall x.  SC :: Show x => x -> SomeC
17:11:30 <ski> SC :: forall x. Show x => x -> SomeC
17:12:19 <ski> anyway, the point being that the type of the constructor really is universally quantified
17:12:38 <ski> now, of course the polarity is flipped if we do
17:12:51 <ski> data T = MkT (forall a. a)
17:12:51 <dave_m> The constructor is universally quantified, yes
17:13:03 <ski> MkT :: (forall a. a) .> T
17:13:10 <ski> s/.>/->/
17:13:33 <dave_m> Yeah, the GADT syntax makes that clearer
17:13:58 <dave_m> 'data T where T :: a -> T' vs 'data T where T :: (forall a. a) -> T'
17:14:00 <ski> yah
17:14:49 <ski> so, i think using 'forall' in front (instead of inside arguments) of the constructor, makes sense for making 'existential datatypes'
17:15:22 <dave_m> So, my ugly corner case becomes 'data T a where T a b :: forall b. C a b => a -> b -> T a b'
17:15:31 <ski> (there is a polarity change across the constructo)
17:15:50 <dave_m> No, it's 'data T a where T :: forall b. C a b => a -> b -> T a
17:15:53 <ski> hm, that's not quite right, i think
17:16:00 <ski> yes, looks better
17:16:12 <ski> yes, that's right
17:16:14 <dave_m> I hit enter before I finished thinking
17:16:49 <ski> so, hm
17:16:59 <Cale> So how exactly do we change the kind inference algorithm?
17:17:10 <ski> in the Set case, what did we have, there, in terms of gadt, e.g. ?
17:17:38 <ski> hmm
17:17:49 <ski> it's abstract of course
17:17:53 <Cale> there are lots of simple cases, but can we run into cases where a restriction is inferred on a kind * -> *
17:18:04 <Cale> er
17:18:07 <Cale> let me clarify that
17:18:18 <Cale> Say we have something which is currently kinded as
17:18:25 <Cale> (* -> *) -> *
17:18:33 <ski> we need to be able to parameterize at times over which subtype of *, i think
17:18:43 <ski> mhm
17:19:03 <Cale> May we end up with ({a | Eq a} -> *) -> * ?
17:19:08 <Cale> seems likely
17:19:14 <ski> hm
17:19:39 <Cale> ah
17:19:41 <ski> if we have something which takes Set-like things as arguments
17:19:47 <ski> i guess you mean ?
17:19:53 <Cale> yes
17:20:08 <Cale> hmm...
17:20:16 <Cale> will that ever be inferred?
17:20:20 <ski> ({a | Eq a} -> *) -> *   <:   (* -> *) -> *
17:20:26 <Cale> yes
17:20:32 <Cale> subkind
17:20:37 <ski> yah
17:21:06 <Cale> What happens in the case  data Foo a = Foo (Set a)?
17:21:16 <ski> hmm
17:21:17 <Cale> We need to inherit the kind restrictions
17:21:30 <ski> Foo is almost a newtype of Set
17:21:43 <ski> so, we need to restrict 'a' in same way
17:21:44 <Cale> data Foo a = Foo (Set a) | Bar (Something a)
17:21:59 <ski> still need to restrict a
17:22:01 <Cale> here we need to take the meet of the kinds.
17:22:07 <ski> yes
17:22:28 <ski> hm, meet = glb ?
17:22:36 <Cale> intersection.
17:22:48 <Cale> so, yes
17:22:52 <ski> ok
17:22:55 <Cale> if you think of * as the top
17:23:11 * ski can't remember which is which of meet and join
17:23:32 <Cale> intersection and union help to remember
17:23:52 <ski> if you know which to associate them with, yes
17:23:58 <Cale> the intersection is where the sets meet each other
17:24:06 <Cale> the union joins them together
17:24:12 * ski didn't know this
17:24:33 <Cale> that's my mnemonic anyway :)
17:24:52 <Cale> okay
17:25:31 <Cale> the Haskell Report is kind of fuzzy on kind inferene as it is
17:25:36 <Cale> inference*
17:26:14 <Cale> (probably because it's kind of simple)
17:26:43 <ski> m
17:27:10 <Cale> but it would be nice to have a version of the algorithm sitting in front of us so as to know what needs changing
17:28:25 <ski> possibly we could all go and study some TaPL
17:28:28 <dave_m> it seems like a close relative of the simply-typed lambda calculus. That might be a starting point
17:30:48 * ski should go to bed ..
17:42:24 <Cale> hmm
17:42:58 <Cale> dave_m: can you think of a way to construct a situation where a kind of ({a | Eq a} -> *) -> * will be inferred?
17:43:24 <dave_m> hmm
17:43:48 <Cale> Just description wise, I think I can handle how to restrict parameters which are currently kinded as *
17:44:47 <dave_m> No, but that might be problematic
17:45:06 <dave_m> consider data Rec f = In (f (Rec f))
17:45:28 <dave_m> What happens if you try to do Rec Set?
17:45:49 * THC4k ist away (Random Number generation is too important to be left to chance)
17:46:39 <Cale> hmm
17:49:06 <dave_m> higher-order kinds can be complex.
17:49:21 <dave_m> I think Haskell is unusual for supporting them at all
17:49:34 <Cale> I think you'll have problems there
17:49:47 <Cale> unless you can get an instance of Ord
17:49:52 <Cale> (or Eq)
17:50:24 <dave_m> My guess is that Rec Set is rejected, because you need something of type * -> *
17:50:34 <Cale> because applying f to (Rec f) implies that Rec f satisfies the parameter kind of f
17:50:50 <Cale> (the context there)
17:50:58 <Cale> which involves Eq, say
17:51:50 <dave_m> Yeah, there's some recursion. Maybe you could do Rec :: exists k. (k -> k) -> k
17:52:40 <dave_m> So, if you can fit Set into {a | Eq a} -> { a | Eq a}, then Rec Set :: { a | Eq a }
17:52:59 <Cale> ah
17:53:21 <Cale> yes, it would be nice to be able to say that Set is kinded that way
17:53:59 <Cale> due to the instance Eq a => Eq (Set a)
17:58:10 <Cale> Or something like
17:58:17 <Cale> data X f = Set (f Char)
17:58:53 <Cale> from this, we can infer that f :: k -> {a | Eq a}
17:59:43 <Cale> So in general, there are a good deal of factors influencing the kind of a constructor.
18:00:16 <dave_m> that's for sure
18:00:37 <Cale> hmm...
18:02:17 <lisppaste2> syntaxfree pasted "frustrating error, makes me wish for dynamically-typed language" at http://paste.lisp.org/display/12503
18:03:28 <Cale> syntaxfree: your types are too generic
18:03:30 <syntaxfree> here I am. Did the pastebot show you my code snippet? :~
18:03:32 <Cale> yes
18:03:38 <Cale> derv :: (Integral a, Floating a) => (a -> a) -> a -> a -> a
18:03:42 <Cale> taylor :: (Integral a, Floating a) => (a -> a) -> a -> a -> a -> a
18:03:51 <Cale> you can get ghci to generate those for you
18:03:52 <syntaxfree> those are the types I need?
18:03:54 <Cale> yes
18:04:05 <Cale> you can delete the type signatures
18:04:10 <Cale> and it will infer those
18:04:12 <syntaxfree> hmm. I'll try that.
18:04:25 <dave_m> You're using ** in some places, and ^ in others
18:04:33 <dave_m> @type (**)
18:04:37 <syntaxfree> sometimes I think I should just pretend Haskell is dynamically typed.
18:04:38 <lambdabot> forall a. (Floating a) => a -> a -> a
18:04:47 <dave_m> @type (^)
18:04:48 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
18:05:12 <Cale> ah yeah
18:05:18 <syntaxfree> letting it infer types gets the snippet to compile, but I get errors.
18:05:19 <Cale> replace ^ with **
18:05:30 <Cale> derv :: (Floating a, Enum a) => (a -> a) -> a -> a -> a
18:05:37 <Cale> taylor :: (Floating a, Enum a) => (a -> a) -> a -> a -> a -> a
18:05:55 <syntaxfree> even if I use ** in all occurrences.
18:05:58 <Cale> (Integral a, Floating a) isn't satisfied by any types
18:06:25 <dave_m> @type fromIntegral
18:06:27 <lambdabot> forall b a. (Num b, Integral a) => a -> b
18:07:06 <lisppaste2> syntaxfree pasted "will compile but not run" at http://paste.lisp.org/display/12504
18:07:39 <Cale> syntaxfree: didn't you pass the parameters in the wrong order?
18:08:08 <syntaxfree> OH.
18:08:25 <Cale> also, you seem to have written an (infinite?) loop
18:09:01 <syntaxfree> (that way of calculating derivatives is WAY inefficient, O[n(n-1)] if I'm not wrong, but I wanted to do it as proof-of-concept.
18:09:01 <Cale> there's no place where the recursion stops
18:09:08 <syntaxfree> hmm. true.
18:09:15 <Cale> you need base cases
18:09:31 <syntaxfree> yeah, I forgot about'em.
18:10:38 <syntaxfree> I have a mathematical question. Dunno where else to ask.
18:10:56 <syntaxfree> Imagine a circle of M kids playing a game.
18:11:03 <syntaxfree> We start from kid 1 and count up to N.
18:11:06 <Cale> dave_m: hmm... the kind inference is complicated, but I'm fairly convinced it could be done
18:11:26 <syntaxfree> The Nth kid is removed from the circle. I'll paste the Haskell code for it.
18:11:33 <Cale> Perhaps I should e-mail SPJ or something, and see what kind of a reply I get :)
18:11:53 <Cale> syntaxfree: are you referring to the Josephus problem?
18:12:02 <lisppaste2> syntaxfree pasted "circle elimination" at http://paste.lisp.org/display/12505
18:12:21 <syntaxfree> the code is perfect, and I've ran it for tens of thousands of combinations of M and N.
18:12:31 <Cale> I coded a very efficient solution to that problem not so long ago
18:12:31 <syntaxfree> I can't seem to find any kind of structure in the plots, though.
18:12:45 <Cale> which handed cases in the hundreds of millions
18:12:52 <Cale> handled*
18:13:00 <Cale> did you see it?
18:13:02 <syntaxfree> oh, so it's a classic problem. I saw some kids playing that, and I started wondering whether there are closed-form solutions, etc.
18:13:34 <Cale> there are closed form solutions for specific n
18:13:54 <syntaxfree> where do the closed-form solutions come from?
18:15:13 <Cale> solving a recurrence equation
18:15:22 <Cale> (or system thereof)
18:17:18 <syntaxfree> I generated tens of megabytes of data with solutions to that problem to see if I could do any kind of analysis on it.
18:17:35 <Cale> That's usually not a good way to attack a combinatorial problem
18:18:05 <Cale> Better is to try to define recurrence equations which the solution has to satisfy.
18:22:27 <syntaxfree> I see.
18:22:30 <Pseudonym> Knuth et al's "Concrete Mathematics" has a lot about this.
18:22:56 <Pseudonym> And it's an excellent book anyway.
18:23:02 <syntaxfree> ah, I saw that on the library shelf the other day.
18:23:29 <Pseudonym> In fact, I think there might be a solution in that book.
18:23:32 * Pseudonym can't remember
18:24:33 <syntaxfree> I'm testing the solution from this site: http://www.pballew.net/josephus.html
18:24:49 <syntaxfree> Now that I know the name of the problem, I'll do some research.
18:28:35 <Cale> http://homeweb2.unifr.ch/hungerbu/pub/josephus/finaljosephus.ps
19:00:36 <sethk> I have to get some books out of storage.  I have that Knuth et. al. book, which reminded me.
19:00:50 <sethk> but, there are some other discrete math books that I think are better organized
19:01:02 <Pseudonym> Yes, but they don't cover as much ground.
19:01:08 <Pseudonym> As a rule.
19:01:16 <sethk> true
19:01:30 <sethk> which makes knuth good as a reference but not terribly good for learning
19:01:37 <Pseudonym> But I do agree.  Concrete Mathematics LOOKS like a course of lectures.
19:01:49 <Pseudonym> I use "course of lectures" in the same sense that I'd use "course of chemotherapy".
19:02:02 <sethk> I have to admit to being biased against Knuth because of MIX and MMIX
19:02:07 <sethk> I think he calls the newer one MMIX
19:02:10 <Pseudonym> None of that in CM.
19:02:17 <sethk> true
19:02:25 <sethk> but still, guilt by association  :)
19:02:36 <Pseudonym> Yeah, I see his reasoning for using assembly language, but I don't buy it.
19:02:43 <Pseudonym> Maybe in the 60s it made some kind of sense.
19:03:03 <Pseudonym> OK, let me rephrase that.
19:03:06 <sethk> I do understand the reasoning, and I even partially buy into a pseudo language for the first editions.  But a revised pseudo-language?
19:03:24 <Pseudonym> Using MIX (or MMIX) lets you do virtual experiments to see how the algorithms run on "hardware".
19:03:37 <Pseudonym> Which don't depend on specifics of compilers, etc.
19:03:48 <Pseudonym> But the primary expression should be something high-level.
19:04:28 <sethk> I don't buy it for the second go around.  There is very close to a one to one relationship between C and assembler code
19:04:31 <sethk> and...
19:04:43 <sethk> if you want a machine level language, because it is more accurate, use a real one
19:05:04 <Pseudonym> Yes.  Even PISA would have been a better option.
19:05:13 <sethk> yes, I think so also.
19:06:14 <sethk> Also, as someone who hasn't been a student for many (many) years, I really don't appreciate books that leave out important things with condescending notes about the being "left as an exercise for the reader."
19:06:21 <Pseudonym> I'm not convinced that there is a true one-to-one correspondence between C and assembly language.
19:06:27 <Pseudonym> C compilers are pretty sophisticated.
19:06:39 <Pseudonym> Oh, that's "proof by delegation".
19:06:46 <sethk> :)
19:06:56 <Pseudonym> It's closely related to proof by example.
19:07:03 <sethk> For the purposes of illustration, then, think of a C compiler with optimizations disabled
19:07:08 <Pseudonym> "We show here the case N=2.  The general case is left as an exercise."
19:07:15 <Cale> well, if he told you the solution in the chapter, it wouldn't make as good of an exercise at the end of the chapter :)
19:07:33 <Cale> and it's nice when books have good exercises
19:07:56 <sethk> Cale, Of course you aren't being serious.  Seriously, though, can you think of a case where you could not give a detailed example in the text, and still come up with a valuable exercise?
19:08:06 <sethk> I doubt that such a case really exists.
19:08:25 <sethk> I consider that the "I don't want to do it and I'm too cheap to pay my graduate students to do it" solution
19:08:27 <Pseudonym> Writing good exercises is hard.
19:08:29 <Cale> hehe
19:08:32 <sethk> Pseudonym, yes, it is
19:08:45 <sethk> Pseudonym, but that doesn't justify not supplying good examples in the text
19:08:49 <Cale> See "Calculus" by Michael Spivak for a book with excellent exercises
19:08:53 <Pseudonym> Actually, I can see why you'd leave a proof as an exercise if it's not instructive.
19:09:02 <sethk> Pseudonym, sure, if it isn't instructive
19:09:09 <sethk> Pseudonym, but that's not the situation I'm talking about
19:09:16 <Pseudonym> But a better way would be to provide a citation to a proof.
19:09:26 <Pseudonym> Right.
19:09:35 <Cale> often there will be solutions manuals
19:09:38 <sethk> Yes, definitely, a citation is always going to be better
19:09:57 <sethk> Cale, yes, but often it isn't possible to order the solutions manuals if you aren't on staff at a uni
19:10:24 <sethk> I might look for a part time teaching job just so I can get review copies and solutions manuals.  :)
19:10:24 <Pseudonym> TAoCP has always included Fermat's Last Theorem as an exercise, but in the latest edition, it's been dropped from difficulty 50 to difficulty 49.
19:10:33 <sethk> :)
19:10:48 <sethk> I bought a book called "Fermat's last theorem for amateurs"
19:10:49 <Pseudonym> To his credit, he did cite the proof.
19:10:55 <Pseudonym> sethk: Oh?
19:11:05 <Pseudonym> Does it talk about Taniyama-Shimura?
19:11:09 <sethk> but it should be called "fermat's last theorem for amateurs with a PhD in mathematics"
19:11:13 <Pseudonym> :-)
19:11:19 <Cale> haha
19:11:20 <sethk> I don't know, it's 50 pages long
19:11:23 <sethk> and I'm on page 3
19:11:26 <Pseudonym> Ah.
19:11:38 <Pseudonym> And how long did it take you to reach page 3?
19:11:44 <sethk> Do you think the "it is easy to prove" proof exists?
19:11:59 <sethk> Pseudonym, Oh, just 15 minutes.  I've gotten to page three about five times
19:12:07 <Pseudonym> I think that we don't have the tools to answer that question yet.
19:12:13 <Pseudonym> I don't think that Fermat had one.
19:12:20 <Pseudonym> Or, at least, he had a flawed one.
19:12:30 <sethk> Pseudonym, but I decided that it's more useful for me to tackle category theory and lambda calculus, if I want to struggle
19:12:34 * Pseudonym nods
19:12:41 * Pseudonym just borrowed a copy of Barr and Wells.
19:12:48 <sethk> Pseudonym, that's what I think, also.  He had one in mind but it had a flaw he didn't see.
19:12:58 <sethk> Pseudonym, he probably saw it later, and so he never wrote it down.
19:13:01 <Pseudonym> Thinking long-term, here's how I see it:
19:13:18 <Pseudonym> Maths before about 1800 was all about getting as many details as you could.
19:13:28 <Pseudonym> From about 1800 to about 1890, it was about organisation.
19:13:39 <Pseudonym> Things like abstract algebra.
19:13:57 <Pseudonym> Organising the knowledge that we had, looking for similarities, hierarchies and so on.
19:14:18 <Pseudonym> 1890 to about 1950 was about the limits of mathematics.
19:14:31 <Pseudonym> Realising that hierarchical organisation wasn't necessarily going to work.
19:14:40 <Pseudonym> And that there was always stuff that couldn't be done in maths.
19:14:42 <Pseudonym> Goedel, Turing etc.
19:14:55 <Pseudonym> From 1950 to today, there has been a change, I think.
19:15:11 <sethk> There is another, perhaps you might call it a bump in there
19:15:14 <Pseudonym> There's been a realisation that the limits maybe aren't so important.
19:15:29 <sethk> where it was realized that things that were rejected as being not universally applicable
19:15:40 <sethk> are in fact very useful in specific situations
19:15:47 <sethk> such as in machines
19:15:47 <Pseudonym> Because when you get down to it, maybe all branches of mathematics are really the same.
19:16:07 <Pseudonym> And maybe theorems are better proved by transforming the problem into a completely different branch of mathematics.
19:16:23 <Pseudonym> There are two ways of attacking this problem.  Category theory is the "top-down approach".
19:16:28 <sethk> Yes, that's true.  I think there is an analogy there to the way we typically solve EE problems.
19:16:49 <sethk> Which is we usually invent a coordinate system that makes the problem easy to solve, and find a transformation from that coordinate system to a common one
19:16:55 <Pseudonym> The other way is by finding connections underneath, and the Langlands programme (including Wiles et al) exemplify that.
19:17:06 <Pseudonym> Right.
19:17:08 <Pseudonym> That's true.
19:17:22 <Pseudonym> So if you have a number theory problem, maybe it's better solved by going to differential geometry.
19:17:44 <Pseudonym> Even though there's no obvious connection between them.
19:17:55 <sethk> Which contributes to category theory, by showing that something is common to number theory and differential geometry (for instance)
19:17:59 <Pseudonym> Right.
19:18:39 <Pseudonym> And the same with Taniyama-Shimura, which shows that certain types of analytic functions (modular forms) are deeply related to certain number-theoretic objects (elliptic functions).
19:18:41 <sethk> I need these analogies to handle the extreme abstractions of category theory (extreme to us practical engineering types)
19:18:48 * Pseudonym nods
19:18:53 <sethk> BRB
19:19:04 <Pseudonym> I think that computer scientists of all people should be able to appreciate this.
19:19:17 <Pseudonym> Maths is, for the first time, appreciating the difference between a specification and an implementation.
19:19:46 <Pseudonym> Mathematicians have always seemed to think that you specify something by giving a formal model for it.
19:20:09 <Pseudonym> But a formal model is an implementation.
19:20:19 <Cale> well, that's all changed over the last 100 years. Mathematics is quite stratified now.
19:20:38 <Pseudonym> Category theory, for example, encourages you to investigate things by probing them from the outside, not by peering inside them.
19:20:42 <sethk> and a paradox can be viewed as the border between category theory and a concrete branch
19:21:08 <Pseudonym> That is, by investigating the interface, not the implementation.
19:22:50 <Cale> or model theory
19:22:56 * Pseudonym nods
19:23:07 <Pseudonym> But how many differential geometers use model theory?
19:23:41 <Pseudonym> This is why I think that the programme of 21st century mathematics will be to rein in the insanity.
19:23:57 <Pseudonym> To try to get some order back to all of the stuff that we've learned recently.
19:24:39 <Pseudonym> To a great extent, that has already started.
19:26:19 <Pseudonym> The amount of mathematics in the world increases almost at the same rate as Moore's Law.
19:26:37 <Pseudonym> Which makes it impossible to find what you need.
19:27:55 <Cale> Well, most people stick to their area, which ends up in a potential for lots of duplication.
19:28:00 <Pseudonym> Right.
19:29:56 <sethk> not only duplication, but what Pseudonym is saying I think is that you have the same thing being "discovered" in different formulations
19:29:57 <Cale> Model theory may actually be a fairly important piece of the puzzle. I've seen uses of it in generalising things like Galois theory which were incredibly successful. It would be nice to unify it with other efforts.
19:30:26 <sethk> Cale, yes, but it can also be a trap to focus only on things that will unify
19:30:35 <Pseudonym> Indeed.
19:30:50 <sethk> rather than on the _part_ that will unify
19:30:59 <Pseudonym> When I talk about "the programme", of course, people will work on what they want to work on.
19:31:08 <sethk> of course
19:31:11 <Pseudonym> And people will still do basic research in whatever takes their fancy.
19:31:16 <sethk> but one works from a frame of reference
19:31:20 <Pseudonym> Of course.
19:31:47 <dons> @seen dcoutts
19:31:48 <lambdabot> dcoutts is in #haskell-blah, #haskell and #gentoo-haskell. Last
19:31:48 <lambdabot> spoke 3 hours, 49 minutes and 36 seconds ago.
19:32:07 <dons> Lemmih, dcoutts: any idea how I can prevent gtk warnings like: (runtests:21753): GtkSourceView-CRITICAL **: file gtksourceundomanager.c: line 617 (gtk_source_undo_manager_insert_text_handler): assertion `strlen (text) == (guint)length' failed
19:32:29 <dons> or don't you guys get them? in which case I should possibly upgrade gtk
19:32:42 <sethk> dons, if that happens, you clearly can't prevent the assertion
19:32:55 <Pseudonym> You could avoid using GTK.
19:33:06 <dons> hehe
19:33:27 <sethk> dons, that looks like you've constructed a string that is longer than the original string
19:33:34 <sethk> dons, by going through some undo steps
19:33:43 <sethk> dons, which  is really really nasty
19:33:46 <dons> yes, but unfortunately that makes no sense in my context.
19:33:57 <sethk> dons, that's even worse
19:34:00 <dons> this happens given the initial string, without any mutations
19:34:08 <sethk> dons, imperative programming, at it's finest
19:34:14 <dons> yes :S
19:34:27 <sethk> do you know the value of length?
19:34:27 <dons> one option is that my gtk version is old
19:34:46 <dons> no. i'm using gtk2hs layered on top, so I don't see the guts underneath
19:34:59 <sethk> dons, put in a print statement of some sort
19:35:13 <sethk> dons, is length 0?  set to some default?
19:35:17 <sethk> -1?
19:35:21 <sethk> ugh
19:35:42 <sethk> just remove every file that strlen occurs in    :)
19:35:44 <Pseudonym> Lunch time for me.
19:35:45 <Pseudonym> BBL
19:36:07 <dons> strangely, it doesn't appear damaging in any way.
19:36:31 <dons> also, since no other hIDE user has mentoined this, it may just be my old version of gtk playing up
19:36:34 <sethk> dons, actually, that's not strange.  If it were real, the program would seg fault very quickly
19:36:47 <sethk> dons, even if it is an old version of gtk, it is still inexplicable
19:36:57 <sethk> dons, except of course that it is a very nasty bug
19:37:13 <sethk> dons, I'd be willing to bet that, at the point the assertion is checked, length has not been set
19:38:02 <sethk> or the length of the string is zero, and a check is made against   strlen(whatever) - 1
19:44:40 <dons> ah, yay for QuickCheck. 1 bug yi+gtk squashed
19:47:37 <Speck> hmm... I installed c2hs from darwinports and it didn't register with ghc... is there any way I can register it myself?
19:54:29 <dons> hi tizoc! learning haskell?
19:54:39 <tizoc> dons, yes
19:54:59 <dons> well, this is the right place :)
19:55:05 <tizoc> hehe
19:55:22 <dons> feel free to ask questions.
19:55:26 <dons> or check out the Haskell wiki:
19:55:30 <dons> @hawiki
19:55:31 <lambdabot> http://www.haskell.org/hawiki/
19:55:46 <dons> also, you can ask lambdabot, or Haskell bot, for various haskell-ish things
19:55:50 <dons> @type map
19:55:55 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:55:57 <dons> @eval map (+1) [1..2]
19:56:00 <lambdabot> [2,3]
19:56:05 <tizoc> its likea sarahbot from #scheme, right?
19:56:16 <dons> not sure. but probably, yes.
19:56:23 <tizoc> hehe, ok
19:56:29 <dons> though I'm not sure if any other bots actually let you run code in irc
19:56:59 <tizoc> dons, sarahbot does
19:57:13 <dons> cool. I should investigate sometime
19:57:29 <tizoc> you do something like this: sarahbot, eval (* 4 (+ 1 2))
19:57:32 <dons> also, since you're in .uy (?) I'll point here: http://www.haskell.org/hawiki/HaskellUserLocations :D
19:57:48 <dons> can you run full scheme code though?
19:57:52 <dons> not just arithmetic
19:57:57 <tizoc> yes
19:58:15 <tizoc> you can talk with sarahbot if you want :P
19:58:17 <dons> cool. do you know how they deal with side effects though?
19:58:35 <sethk> what's the lambdabot @command to get all symbols matching a string?  I did   @whatever lines   earlier.  something with a g    @gobble?   No, but something like that
19:58:52 <dons> sethk, @hoogle?
19:58:55 <dons> @hoogle map
19:58:56 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
19:58:56 <lambdabot> Prelude.mapM_ :: Monad a => (b -> a c) -> [b] -> a ()
19:58:56 <lambdabot> Prelude.mapM :: Monad a => (b -> a c) -> [b] -> a [c]
19:58:57 <sethk> dons, right
19:59:04 <sethk> dons, like I said, something with a g   :)
19:59:05 <tizoc> I don't know, all I know about sarahbot is that it runs on SISC, a scheme that runs on the java vm
19:59:16 <tizoc> hehe, hice
19:59:18 <tizoc> nice
19:59:30 <dons> huh. that's interesting tizoc. I'll definitely check sarahbot out
20:00:17 <tizoc> I was reading a paper yesterday, that mentioned lambdabot
20:00:31 <dons> ah! :)
20:00:36 <tizoc> it was a paper about Yi and dynamic programs in Haskell
20:00:55 <dons> yes, what a nice coincidence :)
20:01:15 <dons> @google dynamic applications from the ground up
20:01:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
20:01:18 <dons> :)
20:01:28 <tizoc> cool!
20:01:51 <tizoc> sarahbot doesn't do that, I think
20:02:38 <sethk> yet another paper on my list of papers to read.    (:
20:03:52 <sethk> I'll be done with it by the time I'm 175
20:07:14 <dons> tizoc, did you come to #haskell after reading about it in my paper?
20:07:25 <dons> or did you already know about it.
20:07:45 <tizoc> dons, about haskell, or about lambdabot??
20:07:51 <tizoc> dons, nice paper :)
20:08:02 <dons> the #haskell irc channel, I mean.
20:08:39 <tizoc> dons, I was 99% sure it existed before reading the paper
20:08:47 <dons> ah, ok good :)
20:08:48 <tizoc> after reading the paper, I am 100% :P
20:08:52 <Cale> heh
20:09:12 <dons> I was just wondering if my paper was having a side effect of sending people to #haskell
20:09:15 <sethk> I'm not 100% sure that _I_ exist
20:09:46 <tizoc> sethk, as far as I know, you can be another lambdabot :P
20:09:47 <Cale> Whether anything exists depends on your definition of existence.
20:10:54 <sethk> Cale, prove that.   :)
20:12:22 <Cale> That's easily done by defining two notions of existence which are negations of one another.
20:12:58 <tizoc> lambdabot can play chess?!?!?
20:13:10 <Cale> yeah, I think there's a chess module
20:13:28 <Cale> It can also say stupid things :)
20:13:31 <Cale> @yow
20:13:32 <lambdabot> I'm mentally OVERDRAWN!  What's that SIGNPOST up ahead?  Where's
20:13:32 <lambdabot> ROD
20:13:32 <lambdabot> STERLING when you really need him?
20:13:32 <tizoc> yes, thats why I'm asking, I'm looking at the code
20:13:55 <tizoc> hehe, sarahbot also has "yow" :P
20:14:10 <dons> lambdabot can play chess, but it's been a while since we used that code
20:15:51 <tizoc> @google monads and continuations
20:15:52 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
20:15:58 <tizoc> :)
20:17:55 <sethk> @yow
20:17:57 <lambdabot> Of course, you UNDERSTAND about the PLAIDS in the SPIN CYCLE --
20:18:04 <sethk> @hoogle lines
20:18:05 <lambdabot> Prelude.lines :: String -> [String]
20:18:05 <lambdabot> Prelude.unlines :: [String] -> String
20:18:21 <Cale> tizoc: check out @pl
20:18:28 <dons> ah!
20:18:39 <dons> good ide, Calea ;)
20:18:46 <dons> idea, not ide
20:19:11 <Cale> @pl \x y z w -> (x z w) (y z w)
20:19:11 <tizoc> @pl continuation monad
20:19:12 <lambdabot> liftM2 ap
20:19:12 <lambdabot> continuation monad
20:19:38 <Cale> It translates code involving lambdas into point-free code
20:20:09 <tizoc> ah, I was using it like @google :/
20:20:41 <Cale> @pl \x y z -> (x + y * z)
20:20:42 <lambdabot> (. (*)) . (.) . (+)
20:20:46 <Cale> hehe
20:21:04 <Cale> not always that useful, but fun
20:21:31 <Cale> @pl \x y z -> x z (y z)
20:21:32 <lambdabot> ap
20:22:02 <Cale> @type ap
20:22:07 <lambdabot> bzzt
20:22:10 <Cale> @type Control.Monad.ap
20:22:12 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m
20:22:12 <lambdabot> b
20:22:37 <Cale> @type Text.ParserCombinators.Parsec.oneOf
20:22:38 <lambdabot> forall st.
20:22:38 <lambdabot> [Char] -> Text.ParserCombinators.Parsec.Char.CharParser st Char
20:23:01 <Cale> @type length
20:23:03 <lambdabot> forall a. [a] -> Int
20:23:12 * dons wonders about pluggable rewrite rules for @pl
20:23:19 <Cale> :)
20:23:26 <dons> so it could do not just pointfree simplifications
20:23:34 <dons> but say, monadificiatoin, obfuscation..
20:23:45 <tizoc> lambdabot is cool :)
20:24:11 <Cale> dons: or the opposite of what it presently does :)
20:24:13 <dons> needs a nicer syntax than the current rules (though they're not too bad actually)
20:24:19 <dons> Cale, yes!
20:24:38 <dons> there must be several different sorts of automated rewrites that would be useful
20:24:55 <dons> as well as reductions and so on
20:24:57 <Cale> then you could take that module and plug it into yi :)
20:25:09 <dons> right!
20:25:21 <dons> and we'd have a pluggable HaRe
20:25:47 <dons> I think I should write this down on the hIDE todo list
20:25:53 <Cale> It'd be nice if @pl actually used proper Haskell syntax. I've seen it choke on things.
20:26:03 <dons> ah, good point. we could just use ghc-api now
20:26:31 <dons> @todo @pl should use ghc-api for parsing
20:26:32 <lambdabot> module "todo" screwed up: @todo given arguments, try @todo-add or @
20:26:32 <lambdabot> listcommands todo
20:26:52 <dons> @todo-add  @pl should use ghc-api for parsing (and typechecking!)
20:26:53 <lambdabot> Entry added to the todo list
20:34:17 <Speck> hmm... I installed c2hs from darwinports and it didn't register with ghc... is there any way I can register it myself?
20:38:54 <Lemmih> heh
20:41:11 <Lemmih> Using ghc-api for @pl would be cool but very difficult.
20:45:36 <sethk> what is @pl?
20:45:38 <sethk> @pl
20:45:39 <lambdabot> (line 1, column 1):
20:45:39 <lambdabot> unexpected end of input
20:45:39 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
20:45:39 <lambdabot> expression
20:45:47 <sethk> @pl 2+3
20:45:48 <lambdabot> 5
20:45:56 <sethk> @pl 23*pi
20:45:58 <lambdabot> 23 * pi
20:47:19 <tizoc> @pl \x y -> x + y
20:47:20 <lambdabot> (+)
20:47:36 <Pseudonym> @pl \x y z -> f x y z
20:47:37 <lambdabot> f
20:47:43 <Pseudonym> Quelle surprise.
20:47:53 <Pseudonym> @pl \f g x -> f x (g x)
20:47:54 <lambdabot> ap
20:48:12 <Pseudonym> Whoever is on the Haskell06 committee... please add that to the prelude!
20:48:24 <Pseudonym> If you need a strong argument for it... @pl is broken!
20:54:04 <araujo> Hello haskell'ers!
20:55:55 <tizoc> araujo, tanto tiempo :P
21:01:21 * araujo recordando
21:01:27 <araujo> tizoc!!!
21:01:34 <tizoc> jajaaj
21:01:54 <araujo> tizoc, have you finally decided to learn Haskell? :-]
21:02:05 <tizoc> yes, again :P
21:02:11 <araujo> Cool.
21:02:32 <araujo> Welcome
21:02:53 <araujo> tizoc, hey check it out, add yourself to http://www.haskell.org/hawiki/HaskellUserLocations
21:03:05 <tizoc> ok
21:04:31 <araujo> We need to crowd it down here :-]
21:04:53 <tizoc> araujo, I'm trying to figure how to do it
21:05:55 <Pseudonym> NASA has higher res images now, too.
21:06:07 <araujo> tizoc, just get your latitude and longitude from one of the links , and click on EditText
21:06:27 <araujo> You only need to add yourself to the list.
21:07:36 <Plaza_> ok
21:10:50 <ibid> dcoutts: possibly :)
21:12:10 <Pseudonym> I think that the phrase "pissed off" should appear in more formal language extension proposals.
21:12:37 <Speck> hello!
21:12:39 <Pseudonym> Kudos to John for putting it in the class alias proposal.
21:12:44 <Speck> lol
21:13:10 <Pseudonym> 10 karma points if he gets it in the Haskell 06 specification.
21:14:23 <sethk> Pseudonym, I doubt it   :)
21:14:35 <sethk> by the way, where are you reading that?  where do proposals go?
21:14:42 <Pseudonym> http://repetae.net/john/recent/out/classalias.html
21:14:49 <Pseudonym> I don't think they go anywhere.
21:15:20 <sethk> oh, that's what I meant, whether there is an "official" place for such things
21:15:27 <Pseudonym> No.
21:15:30 <Pseudonym> Not yet, anyway.
21:16:02 <Pseudonym> I have to go to a job interview.
21:16:07 <Pseudonym> BBS
21:29:38 <ape> anyone feel like helping me with an ot problem?
21:30:00 <sethk> ape, depends on whether anybody knows anything about the t
21:30:26 <ape> hm... problem is i can't mention the problem because i don't want to spam the channel with ot stuff
21:30:42 <sethk> ape, nobody here will get upset about a line or two
21:31:08 <ape> ok cool... i just got back from this party and the music was really loud and now my ears are all ringing and shit and i can barely hear. what should i do?
21:31:44 <sethk> ape, drive your car into a brick wall.  the airbags will explode and you'll be deaf
21:32:09 <ape> does that really happen?
21:32:31 <sethk> ape, sometimes.  :)
21:32:38 <sethk> ape, usually the deafness is temporary
21:32:57 <ape> problem is i can't sleep now because of this
21:33:01 <sethk> ape, it's like the old joke about the man who keeps hitting his head on a brick wall
21:33:08 <sethk> his friend asks him why he is doing it
21:33:16 <sethk> and he says, "because it feels so good when I stop"
21:33:55 <ape> wasn't there some messed up historical mathematician who behaved often in that way?
21:34:08 <sethk> probably many of them.
21:34:23 <sethk> I take it you don't have a bottle of lnestra?
21:34:28 <ape> what's that?
21:34:29 <sethk> lunestra
21:34:34 <sethk> sleeping pills
21:34:41 <sethk> take two, see you in four hours
21:34:49 <sethk> best cure for a hangover
21:35:00 <ape> i didn't drink anything
21:35:12 <ape> unfortunately :(
21:39:06 <Cale> ape: usually that will go away after a while
21:41:51 <sethk> ape, sounds like hangover symptoms anyway
21:42:01 <sethk> ape, the sleeping pill cure is good for a headache
21:42:12 <sethk> ape, actually, I don't drink so I don't really know anything about hangovers
21:42:46 <Cale> It sounds like he was exposed to noise which was overly loud
21:42:50 <sethk> ape, three tylenol and three ibruprofen is pretty good also
21:42:56 <sethk> Cale, yes, I know
21:43:00 <Cale> that sounds like overkill
21:43:14 <sethk> not for me.  I have to take much stronger stuff than that
21:43:27 <sethk> but I get industrial strength headaches
21:44:04 <Cale> Did he say he had a headache?
21:44:18 <ape> i do not have a headache
21:44:28 <sethk> I guess I just assumed that since it would give me a headache
21:44:51 * THC4k ist away (Random Number generation is too important to be left to chance)
21:44:55 <sethk> you said your ears are ringing and for me that always goes with a headache
21:45:00 <sethk> the problem is the ringing ears?
21:45:18 <Cale> Yeah, that'll happen with loud music
21:45:50 <Cale> Usually it'll eventually go away, but it's possible you might have damaged your hearing somewhat.
21:46:22 <sethk> I used to play in fairly loud bands but I always made sure the speakers were between the audience and me
21:46:48 <sethk> Once they found a seriously high person _inside_ one of the big bass cabinets
21:46:51 <Cale> Probably just wait it out, and if it doesn't stop, go and see a doctor.
21:46:55 <sethk> I wouldn't have wanted to be him.  :)
21:46:59 <Cale> heh
21:47:19 <sethk> I'm trying to remember if there were any supposed folk cures for ringing ears
21:47:37 <ape> how bad of an idea would it be to go to another party in 19 hours?
21:47:44 <sethk> maybe white noise would help with the ringing being at the front of your mind
21:47:56 <sethk> ape, do you want to be able to hear for the rest of your life?
21:48:02 <sethk> ape, if you go, buy ear protection
21:48:02 <Cale> ape: depends on what you want to put yourself through :)
21:55:34 <araujo> mm....
21:57:04 <ape> i would look silly wearing earplugs :(
21:57:21 <sethk> tough choice, silly or deaf, which is better?
21:57:40 <araujo> -34.53      -56.10       "br1" align=bottom      # Bruno Martínez
21:57:55 <araujo> Is that entry correct in HaskellUsersLocations?
21:58:07 <araujo> xearth is giving errors here
21:58:09 <xerox> 'morning
21:58:18 <Cale> morning xerox
21:58:25 <tizoc> araujo, I added it, maybe its the tilde
21:58:34 <tizoc> I added it, and the one above it
21:59:41 <araujo> tizoc, ooh, i think it isn't bottom but below
21:59:51 <tizoc> oops
22:00:14 <tizoc> Im going to edit it
22:00:19 <araujo> :-]
22:01:10 <tizoc> done
22:03:01 <araujo> Good!
22:04:56 <tizoc> Im a careless bastard :P
22:06:13 <araujo> ;-)
22:22:29 <Leimy> man this channel is seriously bumpin
22:22:51 <Pseudonym> You wait 'till the DJ puts on the house.
22:25:30 <Leimy> hOppin in the House? :)
22:25:57 <sethk> Pseudonym, how was the interview?
22:26:05 <Pseudonym> I got it.
22:26:15 <Pseudonym> This guy is doing some seriously cool stuff.
22:26:19 <Pseudonym> I'll be working in nanotech.
22:26:56 <araujo> oh, a new version of hOp
22:37:57 <sethk> Pseudonym, sounds interesting.  :)
22:38:11 <sethk> Pseudonym, got any others for somebody located in NY?   :)
22:43:46 <Speck> @google h0p
22:43:49 <lambdabot> http://sfj.abstractdynamics.org/archives/000858.html
22:43:53 <Speck> hmm...
22:44:06 <Pseudonym> Nope.
22:44:23 <Pseudonym> Sorry.
22:44:24 <Speck> I thought they weren't working on h0p anymore, and just working on House
22:44:35 <Pseudonym> The stuff this guy is working on... well, let's put it this way.
22:45:07 <Pseudonym> It's for sports science.  Australia doesn't really have any defence "secrets" as such, but don't you EVER get in the way between the Australian government and doing well in sport.
22:45:20 <Pseudonym> So no, nothing in NY.
22:45:56 <sethk> Pseudonym, they did have that bizarre looking soccer guy doing television commercials here for a while ... he did look ... strange
22:46:14 <Pseudonym> What bizarre looking soccer guy?
22:47:14 <sethk> this was a long time ago, I don't remember
22:47:19 <sethk> but he was from Australia
22:47:27 <Pseudonym> The only Australian soccer guy I know if is Harry Kewell, and he doesn't look bizarre.
22:47:30 <sethk> his hair looked a lot like cleets
22:47:35 <sethk> this was a _long_ time ago
22:47:39 <Pseudonym> Ah.
22:47:48 <sethk> 20 years or so
22:47:53 <Pseudonym> Before my time, clearly.
23:00:42 <C-Keen> moin
23:01:00 <Pseudonym> OK, I have a question.  This is probably the wrong place to ask, but nonetheless.
23:01:07 <Pseudonym> One thing this guy wants to do is buy me a laptop.
23:01:11 <Pseudonym> I have no idea what to get.
23:01:31 <Pseudonym> I'm guessing that seeing as money is probably no object, something AMD64 would be best.
23:01:45 <Leimy> Get an asus ferarri
23:01:59 <luqui> ghc and amd64 don't like each other
23:01:59 <Leimy> they've got a mobile Athlon64
23:02:06 <luqui> so if you are a ghc hacker, amd64 is best :-)
23:02:10 <Pseudonym> :-)
23:02:12 <Leimy> heh
23:02:28 <Pseudonym> I'll definitely want a working GHC, but won't 32-bit GHC work?
23:02:46 <Pseudonym> I've also heard about the higher-end HP laptops.  Are they any good?
23:03:03 * luqui isn't an expert, but I tried for several hours to get a ghc running a 64 bit kernel and failed
23:03:10 * Pseudonym nods
23:03:17 <Leimy> use a 32bit kernel :)
23:03:36 <luqui> right, that would have required a reinstall, which exceeds the "couple hours" thing
23:03:59 <Leimy> what about a 32bit GHC on a 64bit kernel?
23:04:07 <Pseudonym> BTW, did you mean "Acer Ferrari"?
23:04:10 * luqui didn't know enough to do that, but maybe it's possible
23:04:14 <Leimy> Pseudonym: yeah
23:04:20 <Leimy> I'm sure I misspelled it :)
23:04:26 <Pseudonym> I really don't care for the colour scheme.
23:04:28 <Leimy> luqui: of course it is :)
23:04:33 <Pseudonym> Can you get them without prancing horses?
23:04:45 <Leimy> Pseudonym: doubtful... since that's the Ferrari logo :)
23:04:59 <Pseudonym> I mean "decent amd64 laptops", not ferraris specifically.
23:05:08 <Leimy> no idea
23:05:11 <Leimy> that's the only one I know of
23:05:17 <Leimy> that I know a person who has one :)
23:05:49 * Leimy is typically off in mac land
23:05:58 * Pseudonym nods
23:06:02 <Leimy> haven't really paid much attention to intel-like CPUs until recently
23:06:24 <Leimy> the roadmaps for CPUs with virtualization hardware looks good from both AMD and Intel
23:06:48 <sethk> Pseudonym, I'm very happy with my Fujitsu.  Screen quality is a big thing for me.  It has a 1600x1200 lcd, 15"
23:06:52 <Leimy> though it does look like intel may be first to market with it
23:06:53 <sethk> Pseudonym, of course, it weights a ton
23:07:12 * Pseudonym nods
23:07:23 <sethk> Pseudonym, I have good compatibility with fujitsu and thinkpad, w.r.t. linux
23:07:29 <sethk> Pseudonym, stay away from dell laptops
23:07:35 <Pseudonym> OK.
23:07:46 <Pseudonym> One thing I was thinking of is those cool laptops which turn into tablets.
23:07:46 <sethk> actually, the stay away from is the important thing with laptops
23:07:59 <Pseudonym> (AMD64 isn't critical, obviously.)
23:08:01 <sethk> Pseudonym, they are tempting, yes, but I don't know if that makes sense if you plan to run linux
23:08:07 <Pseudonym> (Just something seriously decent.)
23:08:15 <Pseudonym> Well, I'll probably be dual booting.
23:08:21 <sethk> also the tablet input methods are still very much a work in progress
23:08:38 <sethk> I haven't had a chance to test a tablet yet, so I can't say w.r.t. compatibility
23:08:41 <Pseudonym> Right.
23:08:44 <Pseudonym> Who makes those?
23:08:46 <sethk> but I suspect thinkpad will be good here
23:08:48 <sethk> tablets?
23:08:54 <sethk> dell has one which I would not buy
23:08:57 <Pseudonym> Laptops that convert into tablets.
23:09:01 <Pseudonym> Ah, looks like HP does.
23:09:01 <sethk> I believe IBM is shipping one
23:09:07 <sethk> I hate HP's keyboards
23:09:12 <sethk> if you are a touch typist, be very careful here
23:09:14 <Pseudonym> What's wrong with them?
23:09:22 <sethk> don't get a keyboard with only one control or only one alt key
23:09:28 <Pseudonym> *nod*
23:09:33 <sethk> don't get a keyboard with asymmetrical alt/control locations
23:09:46 <sethk> IBM's keyboards on the laptops are really much much better, in general, than others
23:09:51 <Pseudonym> I think I want a) CPU grunt and lots of ram, b) big screen, and c) tablet would be nice, but not critical.
23:10:00 <Pseudonym> Those are my rough requirements.
23:10:07 <Pseudonym> OK, I'll look at IBM.
23:10:09 <sethk> at the moment I think the tablet feature costs more than it is worth
23:10:30 <sethk> I don't tend to be an early adapter for things I'm not actually developing for
23:10:55 <eivuokko> Is there any high-end, for serious work, laptops with tablets anyway?
23:10:57 * Pseudonym nods
23:11:12 <sethk> eivuokko, I've seen some ads, but I'm skeptical (as always)
23:11:15 <Pseudonym> Well, the tablet thing I think is cool because I have some ideas for personal projects that use that.
23:11:27 <Pseudonym> Which is why it's not a serious requirement.
23:11:27 <eivuokko> Most of tablet thingys I have seen are "CEO" kind of stuff.
23:11:28 <sethk> I like something like "I've used it and it works", not "I've seen some ads"   :)
23:11:41 <sethk> cbo?
23:11:41 * Pseudonym likes to draw
23:11:54 <pejo> Pseudonym, I havne't seen the start of the discussion but why not get a mac, if you just want things to work?
23:11:56 <sethk> Pseudonym, get a plug in tablet, for now
23:12:14 <sethk> pejo, I've talked to _many_ people who have had _serious_ hardware problems with mac laptops
23:12:34 <sethk> and apple is plain awful when it comes to fixing defective machines of all types
23:12:35 <pejo> sethk, really? Must be 15 around here and it just works.
23:12:42 <Pseudonym> pejo: My job is to write firmware for some custom hardware, AND to interface with that hardware.
23:12:51 <Pseudonym> So I want to use an OS that I already know how to system program for.
23:12:58 <Pseudonym> But it's a reasonable question.
23:13:10 <sethk> pejo, Possibly because people who have hardware problems tend to find each other and swap horror stories
23:13:23 <sethk> pejo, but there are entire web sites devoted to people disgusted with apple
23:13:28 <sethk> and their lack of hardware support
23:13:36 <sethk> and their blatent refusal to fix obvious problems
23:14:32 <sethk> with the laptops it's generally "the screens go after a couple of years and apple refuses to count the number of defective pixels"
23:14:57 <sethk> or rather apple gets a different answer when they count, and it just always happens to be a number that doesn't get your screen replaced.
23:21:44 <basti_> there are entire websites devoted to people disgusted with -anything- arent there?
23:22:03 <sethk> basti_, no
23:22:11 <Pseudonym> Yes, such as my website www.hate-websites-really-suck.com
23:22:24 <sethk> basti_, not that it is relevant, but no.  :)
23:22:31 <basti_> ;)
23:22:43 <sethk> basti_, because whether some other web site is bs is an independent event
23:22:47 <basti_> i didnt want to counter your rant. i was just making a witty remark!
23:22:53 <sethk> basti_, I know
23:23:08 <basti_> i do not have lots of experience with apple hardware
23:23:17 <sethk> basti_, I'm just pissed at apple, because their machine can't run osx, and it runs linux fine, and they won't admit osx is broken
23:23:34 <basti_> that would piss me off also.
23:23:50 <Pseudonym> OK, I think I like the look of the ThinkPad G41.
23:23:57 <basti_> I'm pretty sure that apple's hardware is well-constructed, though, other than you typical "IBM compatible"
23:24:19 <sethk> basti_, yes, but that doesn't help much if you paid money for it to run osx and it won't run osx.  :)
23:24:24 <basti_> no.
23:24:27 <dons> Pseudonym, on the topic of hi-res nasa maps -- i'm using the highest res one they have on their "blue marble" site. some 200M down to 5k resolution.
23:24:31 <sethk> and the cheap poor quality machines run linux just fine   :)
23:24:33 <basti_> i understand your agression
23:24:41 <dons> is there some I don't know about, or is that the map you were referring to?
23:24:43 <basti_> anything runs linux
23:24:46 <sethk> basti_, I don't get pissed easily.
23:24:51 <sethk> basti_, well, no, not broken hardware
23:25:04 <basti_> i thought your thing runs linux fine?
23:25:06 <sethk> basti_, give me a machine with bad hardware and I'll crash linux on it   :)
23:25:12 <sethk> basti_, it does, yes
23:25:20 <sethk> basti_, I was being witty this time   :)
23:25:24 <basti_> hmm ok
23:25:36 <sethk> basti_, actually their machine runs ok if you take out one of the processors
23:25:40 <Pseudonym> dons: They have some new ones, I believe.
23:25:48 <dons> in the last couple of days?
23:25:56 <basti_> that sounds a lot like a software problem to me
23:25:57 <Pseudonym> Maybe not in the last couple of days.
23:26:14 <sethk> basti_, absolutely, especially as linux doesn't show the problem in SMP mode
23:26:16 <Pseudonym> But they have some that are 21600x10800.
23:26:29 <dons> ok, that's the one I'm using
23:26:32 <sethk> Pseudonym, do you need a scope to see the dots?
23:26:33 <Pseudonym> Gotcha.
23:26:34 <ValarQ> sethk: what os showed problems?
23:26:38 <sethk> ValarQ, osx
23:26:40 <ValarQ> sethk: ok
23:26:46 <Pseudonym> sethk: Sorry?
23:26:49 <dons> and it takes 20+ mins for xplanet to churn out the images :S
23:26:53 <sethk> 21600x10800
23:26:59 <Pseudonym> You might.
23:27:07 <sethk> Pseudonym, I was pretending that was the screen, not the res
23:27:15 <sethk> the screen res that is
23:27:26 <sethk> which would make an interesting sized laptop  :)
23:27:41 <dons> hehe. normal size, but very very sharp
23:27:46 <basti_> ah resolution doesnt have anything to do with size
23:27:46 <basti_> ;)
23:27:53 <sethk> basti_, it does on LCD screens
23:27:56 * ValarQ wants a tadpole laptop
23:28:07 <sethk> the G41 is a nice box
23:28:17 <sethk> G41, or T41?
23:28:19 <basti_> sethk: modulo technology advancing, no?
23:28:25 <ValarQ> sethk: from apple?
23:28:27 <sethk> G
23:28:46 <sethk> ValarQ, no, we were talking about intel arch laptops before
23:28:51 <sethk> g41 is a thinkpad
23:29:02 <ValarQ> ok
23:29:08 <sethk> someone mentioned it, and I remembered I had loaded one with linux recently
23:29:49 <dons> I think adept should add his location to @wiki HaskellUserLocations too!
23:29:54 <dons> @wiki HaskellUserLocations
23:29:55 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:30:03 <dons> adept: :)
23:30:19 <ValarQ> dons: still working on those maps? :)
23:30:31 <dons> no no. all done
23:30:39 <dons> it just updates itself automatically now.
23:31:01 <dons> but it would still be nice to get 50% coverage of the users of #haskell on the maps
23:31:07 <dons> currently it's about 30%
23:31:11 <Pseudonym> G41 is what I'm looking at.
23:31:23 <Pseudonym> Yes, and you can get any sort of linux loaded on it.
23:31:27 <sethk> Pseudonym, might want to add a SIMM to the standard config
23:31:34 * Pseudonym nods
23:31:42 <Pseudonym> Oh, I'm going to get as much RAM and disk as I can.
23:33:11 <basti_> btw. is germany a haskell vacuum or what?
23:33:30 <dons> no, it's not. but maybe the .de guys don't like putting their details up ?
23:33:40 <basti_> ;)
23:33:45 <dons> or they hang out on some mythical #haskell.de ?
23:33:46 <basti_> TheHunter: speak up!
23:33:46 <basti_> ;)
23:33:52 <dons> ah, but he's in the US.
23:33:56 <dons> and stefanw is in .au
23:33:57 <basti_> he is?
23:33:58 <stefanw> or they are in .au
23:34:02 <basti_> ohh
23:34:03 <dons> so they clearly all move out!
23:34:13 <basti_> dang.
23:34:22 <dons> yeah, most are in Sydney I think, eh stefanw?
23:34:26 <basti_> "the rats are leaving the sinking ship"
23:34:33 <basti_> ...or what...
23:35:01 <stefanw> yeah, sydney is full of haskell hackers
23:37:18 <ValarQ> how do i trace exceptions with ghc?
23:37:53 <dons> hmm. you want to see the call stack?
23:37:59 <ValarQ> my program just spits out, you are a bad man and the index is to large
23:38:04 <dons> turn on profiling
23:38:13 <dons> then look at the profiler output
23:38:40 <dons> does it really say "you are a bad man" ? ;)
23:38:51 <ValarQ> dons: no :)
23:39:13 <ValarQ> dons: the profiler output is empty...
23:39:24 <dons> are you using +RTS -p ?
23:39:49 <ValarQ> nope, whats RTS?
23:40:02 <basti_> heh
23:40:02 <dons> check the profiling section of the user guide for ghc
23:40:13 <basti_> everyone trips over that
23:40:28 * ValarQ reads
23:41:56 <basti_> maybe we should supply ghc-profrun which just appends +RTS -p to the options ;)
23:42:17 <ValarQ> oh, now i see
23:44:13 <ValarQ> "4.14.4. RTS options for hackers, debuggers, and over-interested souls", heh
23:49:59 <ValarQ> dang, my program only coredumps when i pass it the RTS flag -xc
23:50:25 <basti_> hmh :(
23:51:07 <int-e> dons: I hope you're happier now ;-)
23:52:12 <vincenz> Hello
23:52:22 <JohnMeacham> howdy.
23:52:33 <vincenz> I've been thinking a bit lately and was hoping to bounce an idea off of you people
23:53:24 * basti_ is ready for bouncing
23:53:27 <int-e> Hmm. I'm sitting on some code I wanted to contribute to GHC (printing numbers, I mentioned it a week ago then let it slip) ... where's the best place to bug people about it? (ask for comments etc.)
23:53:44 * int-e wears his peril-sensitive sunglasses and protective gear.
23:54:00 <Speck> hmm... I can't get the cairo example for gtk2hs to run, even though it is all installed correctly. I get a not in scope error for renderWithDrawable
23:54:54 <vincenz> if you compare ocaml (or another ml) with haskell, I see two major differences: lazyness and type classes.  Now one could, in theory, make an ml that works with the premise of type classes.  The reason I like type classes is because they shorten typing, the correct function is found through the type of of the data it is being called in.  This is actually not too far from oop, if one thinks about it, except the decision of which function is a
23:56:02 <ulfdoz> vincenz: It is cut off at "decision of which function is a"
23:56:18 <dons> int-e: what am I happy about? sorry, missed something ..
23:56:47 <int-e> dons: HaskellUserLocations ;)
23:57:03 <vincenz> ulfdoz: "a..t compile time not runtim.  Why not make it easier for typical ooplike proponents to use a functional language by stepping away from 'reverse some_list' to some_list.reverse
23:57:03 <dons> ah, let me see...
23:57:17 <Speck> hrm... where is a dcoutts when you need one
23:57:54 <basti_> vincenz: `flip` ?
23:58:01 <vincenz> of course, my knowledge of haskell is limited, and I'm better with ocaml.  But I often find syntaxes like ruby and such more convenient, on the other hand I enjoy the hard typing (with type inference of course ;) ) of functional languages due to speed
23:58:23 <Pseudonym> You've come to the right place, then.
23:58:37 <vincenz> well I miss type classes in ocaml
23:58:47 <Pseudonym> I do think that the ML family's biggest drawback is the archaic syntax.
23:59:06 <ValarQ> what do i do when the debugger crashes? debug the debugger?
23:59:10 <Pseudonym> No problems with the semantics at all.
23:59:12 <vincenz> the lack of typeclasses leads to lot more fingertyping
23:59:15 <Pseudonym> True.
23:59:22 <dons> int-e, ah! very nice. 7 new people.
23:59:43 <earthy> ML indeed is hampered by the fact that it was designed as an ad-hoc meta language for a prover
23:59:54 <vincenz> otoh, I dislike lazyness
23:59:56 <earthy> you see that in 'shortcuts' in the language design
