00:03:28 <svens_> morning'
00:12:15 <ibid> dcoutts: nice.  remind me again, where is it?
00:24:04 <C-Keen> moin
00:54:22 <dons> @yow
00:54:23 <lambdabot> I'm meditating on the FORMALDEHYDE and the ASBESTOS leaking into
00:54:23 <lambdabot> my
00:54:23 <lambdabot> PERSONAL SPACE!!
00:55:27 <dons> hey Raziel! welcome :)
00:55:42 <dons> and hi to korcs and takuan as well
00:55:52 <dons> you guys should check out @map
00:55:53 <dons> @map
00:55:54 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
00:56:02 <dons> and further expand the #haskell domain :)
00:56:59 <dons> Raziel, korcs, I don't think we have anyone in .es or .hu on the map yet :/
00:57:27 <dons> lrrr, same with you! no one in .ruu on the map :/ add your details!
01:01:07 * lrrr is trying to figure out his coordinates now...
01:03:28 <dons> cool :) maporama is pretty good. google maps is also good
01:09:43 <ricebowl> hmm, I'm having difficulty figuring out how to write this pattern in Haskell
01:09:56 <ricebowl> I'm trying to connect everything in my program together.
01:10:25 <ricebowl> I'm iterating over the input. Each iteration takes an input state, may produce I/O output, and results in an output state
01:10:42 <ricebowl> and I have a suspicion that >>= does exactly what I want, but I don't know how to write it.
01:10:46 <ricebowl> :|
01:11:33 <basti_> hmm
01:11:35 <aleator> sequence+repeat?
01:11:48 <basti_> ricebowl: what types are the functions you want to chain?
01:12:10 <ricebowl> well there is just one function
01:12:15 <basti_> ah
01:12:21 <basti_> it is IO ()?
01:12:23 <dons> maybe @paste ?
01:12:24 <ricebowl> no
01:12:25 <dons> @paste
01:12:25 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:12:28 <basti_> but?
01:12:37 <basti_> ^^
01:12:39 <ricebowl> hold on, let me explain the problem in a little more detail and perhaps it will make sense
01:12:44 * basti_ nods
01:13:08 <ricebowl> I have to read input line-by-line. The problem is just traversing a directed graph to determine if two nodes are connected.
01:13:34 <basti_> dependant on the input i suppose?
01:13:41 <ricebowl> each line of input either defines a new edge in the graph (no output to stdout) or inquires as to whether two nodes are connected (produces output)
01:13:43 <ricebowl> right
01:13:58 <basti_> i see
01:13:58 <ricebowl> so my function's type looks something like: (String, Graph) -> Graph
01:14:02 <basti_> u huh
01:14:05 <lrrr> got it :)
01:14:09 <ricebowl> except not quite, because I have to produce output too
01:14:23 <basti_> hmm yes and you probably want it to depend on input
01:14:29 <ricebowl> so I defined a type called Output which is Nothing Graph | Something String Graph
01:14:56 <ricebowl> I don't know, I'm having a terrible time understanding monads, but intuitively I think >>= does *exactly* what I am trying to do
01:15:01 <Cale> ricebowl: you should keep IO separate from the rest of your computation
01:15:32 <ricebowl> for each line of input I take the current graph and produce a new resulting graph and maybe do some I/O
01:15:33 <basti_> hmm, first, IO activity would be designated by a *result* of type IO a
01:15:41 <ricebowl> right
01:15:54 <Cale> This sounds like the sort of thing you could break into "read graph", "read two vertices", "determine if there's a path", "print result"
01:16:05 <ricebowl> Cale - yes, that's already done
01:16:18 <ricebowl> like I said, my function's type is (String, Graph) -> Graph
01:16:23 <Cale> right
01:16:35 <basti_> basically the only IO parts are "reading the task" and "printing the result"
01:16:37 <Cale> so you know how to read graphs from strings
01:16:43 <ricebowl> that function itself is actually the composition of various smaller functions, but anyway, the problem that's killing me is the I/O :p
01:16:54 <Cale> okay, so you know about getLine
01:16:56 <Cale> ?
01:16:58 <ricebowl> right
01:17:08 <Cale> and putStrLn and print
01:17:17 <ricebowl> but the output... I'm completely lost as to how to maybe print a string
01:17:21 <Cale> you can use a do block to chain a bunch of IO together
01:17:24 <Cale> oh
01:17:30 <ricebowl> actually, no, nm, I know how to do that
01:17:36 <basti_> ^^
01:17:54 <basti_> "IO a" values are io scripts. >>= is a script chaining operator
01:18:17 <ricebowl> I wanted to do something like getLine >>= [action that processes current (String, Graph) -> Graph]
01:18:43 <basti_> so youre rather concerned with the "read a graph" part yes?
01:18:54 <Cale> main = do { putStrLn "What is your name?"; name <- getLine; putStrLn ("Hello, " ++ name) }
01:18:58 <ricebowl> just concerned with passing data around, i.e. how to write the loop
01:19:20 <eivuokko> So you just need fold over IO actions, right?
01:19:34 <ricebowl> "getLine >>= foo" -- foo has to have type (IO String -> IO a), right?
01:19:39 <ricebowl> eivuokko - yes
01:19:57 <basti_> no it has to have type "String -> IO a"
01:20:04 <ricebowl> oh, right
01:20:07 <basti_> that monad stuff is kinda assymetrical
01:20:13 <ricebowl> yes, but it makes sense
01:20:20 <basti_> yes.
01:20:25 <ricebowl> anyway, I'm trying to find a way to make it have type (String, Graph) -> IO Graph
01:20:41 <basti_> hmm are you sure?
01:20:44 <ricebowl> no :p
01:20:50 <basti_> I think Graph -> IO Graph would fit better
01:20:59 <ricebowl> well that's the type of return
01:21:05 <basti_> (it would be reading a string itself)
01:21:23 <basti_> or, you keep with (String,Graph)-> Graph and make another funtion of type "IO Graph"
01:21:36 <basti_> which would read the graph and return it
01:21:41 <integral> return . f :: a -> IO b, if f :: a -> b
01:21:49 <ricebowl> I was reading about monads and there was an example of a monad that captures state, and basically >>= went from state to state, each time passing the previous state in to the next
01:21:56 <ricebowl> so it struck me that that's *exactly* what I need
01:22:06 <basti_> yes it is, there is a so-called "State monad"
01:22:24 <basti_> but this is (in the trivial view) incompatible with IO
01:22:54 <ricebowl> hm
01:23:03 <basti_> there is a way around that, but i'm not sure that you want to learn about that right now ^^
01:23:09 <basti_> ("monad transformers")
01:23:20 <ricebowl> haha probably not; I need to finish up this assignment :p
01:23:47 <basti_> so you should keep your function
01:23:49 <ricebowl> technically it was due Friday, but as he said, it isn't due until he grades it
01:24:03 <basti_> and just write a loop that reads strings and passes them to a row of your functions
01:24:17 <ricebowl> well, that's possible, but like I said, I need to preserve my state
01:24:24 <basti_> ...sooooo? ^^
01:24:39 <ricebowl> hmm...
01:24:53 <basti_> @type iterate
01:24:57 <ricebowl> @type (getLine >>=)
01:24:58 <lambdabot> forall a. (a -> a) -> a -> [a]
01:24:58 <lambdabot> forall b. (String -> IO b) -> IO b
01:25:07 <basti_> @type zip
01:25:08 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
01:25:16 <basti_> @type sequence . replicate
01:25:17 <lambdabot> bzzt
01:25:20 <basti_> uhm
01:25:24 <ricebowl> @type (sequence . replicate)
01:25:25 <lambdabot> bzzt
01:25:30 <ricebowl> nevermind. :p
01:25:30 <basti_> (scope)
01:25:37 <basti_> you might look into these functions
01:26:03 <basti_> you could, for examle, lazily read a list of lines, zip them with your functions, and then fold over application
01:26:37 <ricebowl> what is sequence?
01:26:46 <basti_> "fold with >>="
01:27:10 <ricebowl> I don't follow entirely; could you offer an example?
01:27:28 <basti_> hmm its hard in lambdabot, but i can show you an example for ghci
01:28:03 <basti_> sequence [putStr "hi",putStr " you",putStr " there\n"]
01:28:50 <basti_>  sequence (map putStr ["hi"," you"," there\n"])
01:29:28 <ricebowl> ok
01:29:32 <ricebowl> brb then, going to try that
01:29:38 <basti_> hF, i'm off to work
01:29:52 <basti_> it'll be a little more complicated
01:29:55 <ricebowl> alright, thanks
01:30:00 <basti_> but i don't want to solve your homework  ;)
01:30:01 <ricebowl> you .se?
01:30:05 <ricebowl> hah and I don't want you to ;)
01:30:06 <basti_> you need to learn it yourself
01:30:07 <basti_> no .de
01:30:11 <ricebowl> ah ok
01:30:23 <ricebowl> thanks again
01:30:35 <ProfTeggy> .de, .se, .it, what does it matter nowadays?
01:30:38 <ricebowl> BTW, the [] expression you wrote has type [IO ()] doesn't it?
01:30:44 <ricebowl> ProfTeggy - none, but I was curious
01:30:49 <ProfTeggy> ricebowl, right
01:31:09 <ProfTeggy> ricebowl, yes, that's the type
01:31:11 <ricebowl> so sequence is [IO ()] -> IO ()?
01:31:19 <ProfTeggy> *nod*
01:31:22 <ricebowl> ok
01:31:40 <ProfTeggy> well, it's most specific type is [m a] -> m [a]
01:31:42 <basti_> no sequence is [IO a] -> IO [a]
01:31:49 <basti_> or m yes
01:31:51 <ricebowl> ah, ok
01:32:01 <basti_> note that this is not exactly what you want!
01:32:05 <ricebowl> right
01:32:08 <ProfTeggy> but [IO ()] -> IO [()] is an instance of that type
01:32:10 <basti_> you'll need to do something to pass the state inside the list
01:32:19 <ricebowl> >>= no doubt
01:32:23 <basti_> no ^^
01:32:31 <ricebowl> well I'll figure something out :p
01:32:53 <ricebowl> however, I'm not sure what to do now if I don't want to print anything...
01:33:23 <basti_> @plugs  (foldr (\a b->a.b) id [(+5),(+4),(+3)]) 1
01:33:25 <lambdabot> 13
01:33:36 <basti_> if in doubt use "return" ^^
01:33:38 <basti_> @type return
01:33:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
01:33:50 <ricebowl> basically I could construct a function that is String -> IO () and then write sequence (getLine >>= func)
01:34:05 <ricebowl> hm
01:34:10 <ricebowl> ok, let me screw around with it for a bit then
01:34:17 <ricebowl> if I go offline, blame the hurricane :p
01:34:24 <basti_> ^^
01:34:33 <bourbaki> moin
01:41:40 <ValarQ> bourbaki: mornin
01:47:40 <ricebowl> what is the function equivalent to readLine which reads an entire file?
01:47:49 <ricebowl> is there a reference somewhere?
01:50:06 <ibid> ricebowl: the report is the best reference
01:50:46 <ibid> ricebowl: and you are probably thinking of getContents
01:51:08 <ibid> or readFile
01:51:30 <lightstep> or hGetContents
01:51:52 <ibid> yeah
01:52:39 <lightstep> @hoogle IO String
01:52:41 <lambdabot> Prelude.getContents :: IO String
01:52:41 <lambdabot> Prelude.getLine :: IO String
01:52:41 <lambdabot> System.getProgName :: IO String
02:02:13 <ricebowl> readFile probably
02:05:39 <ricebowl> hmm, maybe not.
02:05:55 <Cale> ricebowl: what would you like to do?
02:07:06 <ricebowl> we were looking at solutions to some simple problems in class
02:07:18 <ricebowl> the general structure of each was main = <something> >>= <something>
02:07:39 <ricebowl> and I remember him talking about how input was consumed immediately
02:07:48 <ricebowl> but I don't remember how it worked exactly
02:08:22 <Cale> if you use getContents or readFile, you don't close the file handle, as it will be closed automatically when you finish reading the file
02:08:48 <ricebowl> right
02:09:01 <ricebowl> ultimately I want to loop over the lines in the file, I'm still trying to figure out how
02:09:22 <Cale> okay, so you get the file as a String
02:09:29 <Cale> you can use lines to break that up
02:09:40 <ricebowl> yes, right
02:09:49 <ricebowl> hmm...
02:09:53 <Cale> fmap lines getContents
02:10:09 <Cale> or
02:10:17 <Cale> fmap lines (readFile "myfile")
02:10:30 <ricebowl> ah
02:10:34 <{Arias}> why fmap?
02:10:41 <Cale> fmap or liftM
02:11:01 <Cale> because it does exactly what's desired? :)
02:11:10 <Cale> @type fmap
02:11:11 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f
02:11:11 <lambdabot> b
02:11:22 <Cale> @type fmap lines getContents
02:11:23 <lambdabot> IO [String]
02:11:32 <wearpants> there, it's a little easier to chat from the same PC I am working on :p
02:11:42 <mauke> @type interact
02:11:43 <lambdabot> (String -> String) -> IO ()
02:11:48 <{Arias}> @type lines.readFile
02:11:50 <lambdabot> bzzt
02:11:56 <{Arias}> ahh
02:11:57 <Cale> @type readFile
02:11:59 <lambdabot> FilePath -> IO String
02:12:01 <wearpants> readFile produces IO String
02:12:03 <wearpants> lines consumes String
02:12:05 <Cale> right
02:12:14 <{Arias}> ok :)
02:12:24 <Cale> you could also do:
02:12:33 <mauke> @type readFile >>= return . lines
02:12:35 <lambdabot> bzzt
02:12:51 <mauke> @type readFile "er, ok" >>= return . lines
02:12:52 <Cale> @type readFile "myfile" >>= (return . lines)
02:12:53 <lambdabot> IO [String]
02:12:53 <lambdabot> IO [String]
02:13:13 <{Arias}> @type (>>=)
02:13:15 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m
02:13:15 <lambdabot> b
02:13:17 <wearpants> makes sense
02:14:03 <Cale> which is the same as do { x <- readFile "myfile"; return (lines x) }
02:15:39 <wearpants> oh!
02:15:48 * wearpants gets an idea
02:28:14 <dcoutts> ibid, darcs get http://haskell.org/~duncan/soe/
02:34:13 <dcoutts> SamB, so apparently in the next version of the GHC RTS it will be easier to support binding multiple Haskell threads to one OS thread. It's not really possible in the current version.
02:35:23 <dcoutts> SamB, the problem we'd still have however is once we've got a bunch of Haskell threads bound to the same thread as the one running the GUI main loop is how to let those Haskell threads run. We need some cooperative scheduling between gtk and ghc.
02:35:42 <dcoutts> SamB, it's basically the same situation as in the single threaded case.
02:36:05 <dcoutts> SamB, and Ideally we'd like to do it without polling.
02:37:06 <kombinator> dcoutts: is it possible to do async IO and use gtk2hs, but using one thread only (select based)?
02:38:17 <dcoutts> kombinator, I'm not quite sure what you mean. What kind of async IO are you thinking about?
02:39:07 <kombinator> for instance - reading a file using non-blocking calls, so that the interface won't freeze if there is a congestion)
02:39:42 <bringert> anyone know an easy way to install ghc 6.4.1 on Ubuntu Breezy on amd64?
02:40:10 <dcoutts> kombinator, well the main problem with using gtk in Haskell with multiple threads is that the call to the gtk main loop blocks all other Haskell threads.
02:40:23 <kombinator> bringert: I don't know, but I'm using ghc 6.4.1 successfully on Debian/AMD64
02:40:32 <Cale> bringert: I'm not sure how compatible ubuntu and debian are, but there's a debian package
02:40:53 <dcoutts> kombinator, so the problem is not doing IO at the same time but just getting giving those other threads a chance to run. And we have a number of ways of doing that.
02:41:27 <dcoutts> kombinator, all ordinary Haskell IO is non-blocking anyway.
02:41:40 <kombinator> is it?
02:41:45 <bringert> kombinator,Cale: I'm new to Ubuntu and Debian (since last week), so I don't know either
02:41:52 <bringert> where would I find the debian package?
02:42:33 <kombinator> I'll try to hang some proof of concept program then
02:43:14 <kombinator> bringert: I got it from here: deb http://ftp.de.debian.org/debian-amd64/debian/ unstable main contrib
02:44:45 <kombinator> dcoutts: but I don't believe that if I make an IO that blocks from a gtk callback the interface won't freeze
02:45:13 <dcoutts> kombinator, ah no, you're not allowed to block in a gtk callback.
02:45:29 <kombinator> that's why i want async IO
02:45:36 <dcoutts> kombinator, if you need to start something long running then you can fork a thread
02:45:49 <kombinator> and preferably select() based (not with threads)
02:46:45 <dcoutts> well Haskell threads are very light weight. They're not OS threads. At least in the signle threaded RTS they all use on OS thread and use select().
02:47:13 <dcoutts> so forking a thread in a callback is a perfectly reasonable thing to do
02:47:28 <dcoutts> in Haskell, but not in C.
02:48:10 <dcoutts> kombinator, but it is possible to get the gtk main loop to call you back when there is activity on a file descriptor.
02:48:21 <dcoutts> kombinator, that might be what you're after.
02:48:30 <kombinator> right
02:49:11 <kombinator> dcoutts: Is it avaliable in gtk2hs?
02:49:35 <dcoutts> kombinator, in the latest darcs version, yes
02:49:46 <kombinator> oh, that's nice
02:50:03 <dcoutts> I added it the other day because someone else requested it
02:50:36 <dcoutts> kombinator, the inputAdd function
02:51:51 * kombinator is getting the dev version of gtk2hs
02:52:14 <dcoutts> darcs get http://haskell.org/gtk2hs/darcs/gtk2hs/
02:52:20 <bringert> kombinator, Cale: thanks, the debian package seems to work on unbuntu
03:14:32 <kombinator> dcouts: are those warnings from autoreconf harmful?
03:21:36 <dcoutts> kombinator, usually not
03:22:19 <dcoutts> kombinator, it usually is just complaining about macros installed by other packages that are not quite escaped properly.
03:22:38 <dcoutts> we're not even using them, but autoconf still scans them,
03:24:41 <lightstep> is there a way to get a haskell REPL running in yi?
03:24:55 <lightstep> well, something with fold and map implemented in it i guess
03:24:57 <lightstep> i dont like DrScheme :O
03:46:35 <dcoutts> ibid, btw I found and fixed the bug that you noticed with gcGetValues and the forground/background colors.
03:52:06 <ibid> ah, nice
03:56:32 <Heffalump> anyone use Haskell for scripts, with a #!..runhaskell line?
03:57:35 <jak_> ak
03:57:58 <kombinator> dcoutts: Yeah, inputAdd should be enough for what I need
04:02:01 <dcoutts> kombinator, ok great
04:02:18 <dcoutts> kombinator, btw there's going to be a 0.9.10 release candiate out shortly
04:02:27 <dcoutts> ie a tarball
04:04:38 <kombinator> dcoutts: I'll check it out. Is there any testing procedure for gtk2hs? I can test it on Debian/i386/GHC 6.4.1 and Debian/AMD64/GHC .4.1
04:04:53 <kombinator> 6.4.1 of course
04:07:35 <dcoutts> kombinator, are you on the gtk2hs-users mailing list?
04:07:49 <dcoutts> I'll send the email about the release candiate there
04:08:24 <dcoutts> kombinator, and yes testing would be apreciated, especially on amd64
04:08:32 <kombinator> no... Once I was, but then I was silently unsubscribed... I'll read the archives
04:09:07 <dcoutts> kombinator, it unsubscribed you without you asking to be?
04:09:41 <dcoutts> anyway, the testing procedure is to build it, install it, run make installcheck and then any other gtk2hs programs you've got
04:09:42 <kombinator> messages just stopped arriving at some point
04:10:21 <kombinator> and my 'list account' didn't work. I just resorted to reading archives
04:10:56 <Lemmih> dcoutts: Any news on the hIDE front?
04:11:59 * Lemmih would love to get the ghc-6.5 issue out of the way so he could start hacking again.
04:12:01 * kombinator is running make installcheck
04:12:18 <JaffaCake> Lemmih: which 6.5 issue?
04:12:42 <kombinator> ls
04:12:46 <kombinator> sorry..
04:15:36 <Lemmih> JaffaCake: hIDE segfaults when its compiled with ghc-6.5.
04:15:46 <JaffaCake> oops
04:15:51 <JaffaCake> any idea why?
04:18:17 <Lemmih> I think it has something to do with hs-plugins.
04:19:25 <dcoutts> Lemmih, I've been preparing the Gtk2Hs 0.9.10 release so I've not been hacking on hIDE recently. That should change once the release is out of the way.
04:20:19 <dcoutts> kombinator, oh a nice thing to check is if the mozembed demo actually works on debian.
04:20:30 <dcoutts> and on dabian on amd64
04:20:56 <dcoutts> since there are some non-trivial details with paths and the mozilla embedding thing
04:21:50 <dcoutts> kombinator, you can ensure it's being built by using ./configure --enable-mozilla (or --enable-firefox)
04:22:18 <dcoutts> you might need some extra mozilla-devel package or something to get all the headers etc
04:25:07 <kombinator> dcoutts: OK, I'll try it with MozEmbed (later). Note that I have GTK 2.6, so I probably won't be able to test Cairo...
04:25:15 <dcoutts> ok, np
04:25:47 <benja> hi
04:25:59 <benja> quick question: the way that Haskell prints strings, is that magic?
04:26:08 <benja> i.e., that it's not ['H', 'e', 'l', 'l', 'o']
04:26:41 <dcoutts> benja, it's because of the definition of instance Show Char
04:27:09 <dcoutts> the show class has a method for showing lists of the value, so it's customisable
04:27:12 <benja> oh
04:27:14 <benja> ok :)
04:27:16 <benja> thanks
04:27:18 <dcoutts> but there is a default supplied
04:27:28 <benja> yeah, got it
04:30:50 <boegel> @seen shapr
04:30:51 <lambdabot> I saw shapr leaving #haskell and #haskell-blah 21 hours, 16 minutes
04:30:51 <lambdabot> and 28 seconds ago.
04:49:41 <dcoutts> the first Gtk2Hs 0.9.10 release candiate is out:
04:49:42 <dcoutts> http://haskell.org/gtk2hs/gtk2hs-0.9.9.7.tar.gz
04:49:52 <dcoutts> md5sum (1bb622960e19078d8cc829eef1d0b367)
04:58:34 <wearpants> is there a function that does the same thing as scanl but only returns the last result?
04:59:06 <wearpants> er, nevermind.
04:59:14 <wearpants> don't know what I was thinking
05:03:44 <basti_> wearpants: k.
05:07:59 * beelsebob_ wonders why (!!) is not of type Integral a => [b] -> a -> b
05:09:21 <Lemmih> Performance/Convenience reasons, I believe.
05:11:42 <beelsebob_> why convenience?
05:11:46 <beelsebob_> I get performance
05:12:06 <beelsebob_> well actually... I don't... if the user is dumb enough to index a list that long, why not let them?
05:13:18 <basti_> what would you save in such a list?
05:13:30 <basti_> 4G data elements?
05:13:58 <ibid> dcoutts: i've created a jyu fork of your soe code (mostly backporting, but also some interface changes, including the module name change)
05:14:21 <benja> basti_: how about a lazy list corresponding to some difficult many-step simulation?
05:14:22 <ibid> dcoutts: my JyuGraphics test code is now adapted to use that fork
05:14:43 <basti_> benja: with 4 billion steps yes? ^^
05:15:02 <ibid> benja: hi :)
05:15:02 <benja> basti_: yes
05:15:05 <benja> ibid: HI :)
05:15:07 <benja> er
05:15:08 <benja> hi :)
05:15:20 <benja> that was a *real* caps-lock error ;)
05:15:38 <Lemmih> beelsebob_: Defaulting to Integer's is a bit worse than using Int's.
05:16:15 <beelsebob_> ah, okay... I see what you mean now
05:24:26 <syntaxfree> good morning, everyone.
05:24:42 <syntaxfree> @pl f n dom = filter (\m->f m == n) dom
05:24:43 <lambdabot> f = fix ((filter .) . flip . ((==) .))
05:25:06 <syntaxfree> pl dom f n = filter (\m->f m ==n) dom
05:29:52 <syntaxfree> @pl dom f n = filter (\m->f m ==n) dom
05:29:52 <syntaxfree> @pl fiber dom f n = filter (\m->f m ==n) dom
05:29:52 <syntaxfree> @eval 2+2
05:29:53 <lambdabot> dom = fix (flip (flip . (filter .) . flip . ((==) .)))
05:29:53 <lambdabot> fiber = flip (flip . (filter .) . flip . ((==) .))
05:29:53 <lambdabot> 4
05:39:20 <syntaxfree> @eval let symplecrypt x = map chr $ map (+1) $ map ord x in symplecrypt "I get by with a little help from my friends"
05:39:21 <lambdabot> "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:46:50 <boegel> @eval let sympledecrypt x = map chr $ map (-1) $ map ord x in sympledecrypt "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:46:51 <lambdabot>  add an instance declaration for (Num (Int -> Int))
05:46:55 <boegel> arg
05:47:57 <boegel> what's wrong with it ? :|
05:48:52 <syntaxfree> @let h = map ord x = h "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:48:52 <lambdabot> Unknown command, try @listcommands.
05:49:00 <aleator> :) those trip me often..
05:49:07 <syntaxfree> @eval let h = map ord x in h "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:49:08 <lambdabot>  Not in scope: `x'
05:49:21 <syntaxfree> @eval let h x = map ord x in h "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:49:23 <lambdabot> [74,33,104,102,117,33,99,122,33,120,106,117,105,33,98,33,109,106,117,
05:49:23 <lambdabot> 117,109,102,33,105,102,109,113,33,103,115,112,110,33,110,122,33,103,
05:49:23 <lambdabot> 115,106,102,111,101,116]
05:49:38 <syntaxfree> @eval let h x = map (-1) $ map ord x in h "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:49:39 <lambdabot>  add an instance declaration for (Num (Int -> b))
05:49:39 <lambdabot>   In the definition of `xxxx':
05:49:39 <lambdabot>    xxxx = let h x = (map (- 1)) $ (map ord x)
05:50:23 <aleator> @eval map (chr.(\x -> x-1).ord) "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:50:25 <lambdabot> "I get by with a little help from my friends"
05:50:32 <syntaxfree> @eval let charRot n r = let base = if isUpper n then 65 else 90 in chr (base + (mod ((ord n) - base +r) 26) in charRot 'Z' 1
05:50:33 <lambdabot>  parse error on input `in'
05:52:23 <syntaxfree> @eval let charRot n r = let base = if isUpper n then 65 else 90 in chr (base + (mod ((ord n) - base +r) 26)) in charRot 'Z' 1
05:52:25 <lambdabot> 'A'
05:53:37 <syntaxfree> @eval let charRot n r = let base = if isUpper n then 65 else 90 in chr (base + (mod ((ord n) - base +r) 26)) in map (\x->charRot x (-1)) "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:53:38 <lambdabot> "IngeZnb_n]iZhnanliZZlenhelpnfromnm_nfriends"
05:54:40 <dcoutts_> ibid, great. what sort of features are you adding?
05:54:46 <syntaxfree> @eval let charRot n r = let base = if isUpper n then 65 else 90 in chr (base + (mod ((ord n) - base +r) 26)) in map (\x->charRot x (-1)) "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:54:48 <lambdabot> "IngeZnb_n]iZhnanliZZlenhelpnfromnm_nfriends"
05:54:53 <syntaxfree> why?
05:55:29 <syntaxfree> @eval let charRot n r = let base = if isUpper n then 65 else 90 in chr (base + (mod ((ord n) - base +r) 26)) in map (\x->charRot x 1) "I get by with a little help from my friends"
05:55:31 <lambdabot> "Johf[oc`o^j[iobomj[[mfoifmqogspnon`ogsjfoeZ"
05:55:47 <syntaxfree> that is no good.
05:55:51 <ibid> dcoutts_: not really features, the main features are backporting
05:55:55 <syntaxfree> oh, not 90, 97.
05:56:02 <ibid> dcoutts_: you can look at it at the old address :)
05:56:10 <syntaxfree> @eval let charRot n r = let base = if isUpper n then 65 else 97 in chr (base + (mod ((ord n) - base +r) 26)) in map (\x->charRot x (-1)) "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:56:11 <lambdabot> "Ingetnbynwithnanlittlenhelpnfromnmynfriends"
05:56:17 <dcoutts_> ibid, ok.
05:56:21 * dcoutts_ darcs pulls
05:56:21 <ibid> dcoutts_: i suspect that the patches are not particularly cherrypickable, unfortunately
05:56:22 <syntaxfree> boegel so there :)
05:56:56 <dcoutts_> ibid, oh you can't use anything later than gtk2hs 0.9.8 ?
05:57:20 <boegel> syntaxfree: what's wrong with the other one ?
05:57:22 <boegel> @eval let sympledecrypt x = map chr $ map (-1) $ map ord x in sympledecrypt "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:57:23 <lambdabot>  add an instance declaration for (Num (Int -> Int))
05:57:29 <syntaxfree> some typehackery.
05:57:38 <syntaxfree> i'm sure adding a type declaratio nwould fix it.
05:57:40 <boegel> I don't see what's wrong...
05:57:41 <ibid> dcoutts_: "can" is a relative thing :)
05:57:48 <syntaxfree> @eval let sympledecrypt x = map chr $ map (-1) $ map ord x in sympledecrypt "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet" :: Int
05:57:50 <lambdabot> Couldn't match `Int' against `[Char]'
05:57:58 <syntaxfree> haha. Naïve attempt :)
05:58:11 <dcoutts_> ibid, I don't understand :-(
05:58:18 <ibid> dcoutts_: i "can" in the sense that it is possible to upgrade, but i "can" not in the sense that i don't want to invoke the wrath of the admins :)
05:58:18 <syntaxfree> sympledecrypt :: [Char]->[Char]?
05:58:26 <syntaxfree> :t ord
05:58:32 <boegel> @eval let sympledecrypt x = (map chr $ map (-1) $ map ord x) :: (Int -> Int) in sympledecrypt "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:58:32 <syntaxfree> @type ord
05:58:33 <lambdabot>   Expecting a function type, but found `b'
05:58:33 <lambdabot>   Expected type: Int -> Int
05:58:33 <lambdabot>   Inferred type: [Char]
05:58:33 <dcoutts_> ibid, ho hum :-(
05:58:34 <lambdabot> bzzt
05:58:47 * boegel gives up
05:58:50 <boegel> stupid lambdabot :P
05:58:57 <boegel> @plugs let sympledecrypt x = map chr $ map (-1) $ map ord x in sympledecrypt "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
05:58:58 <lambdabot>  add an instance declaration for (Num (Int -> Int))
05:59:02 <syntaxfree> @type ord
05:59:02 <boegel> arg :)
05:59:03 <lambdabot> bzzt
05:59:06 <boegel> @index ord
05:59:07 <lambdabot> Data.Char
05:59:13 <boegel> @type Data.Char.ord
05:59:14 <ibid> dcoutts_: my baseline version is what they installed a few weeks ago in the puter classrooms
05:59:14 <lambdabot> Char -> Int
05:59:16 <syntaxfree> @type Data.Char.ord
05:59:17 <lambdabot> Char -> Int
05:59:21 <boegel> syntaxfree: :)
05:59:26 <dcoutts_> ibid, right
05:59:38 <syntaxfree> maybe (\x->x-1)::Int->int  instead of (-1)?
05:59:44 * dcoutts_ grubles that 0.9.9 was out then
05:59:52 <ibid> dcoutts_: was there a win installer?
05:59:55 <dcoutts_> ibid, never mind
06:00:00 <ibid> :)
06:00:04 <syntaxfree> @plugs let sympledecrypt x = map chr $ map (\x->x-1)::Int->Int $ map ord x in sympledecrypt "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
06:00:05 <lambdabot>   Expecting a function type, but found `a'
06:00:05 <lambdabot>   Expected type: [Int]
06:00:05 <lambdabot>   Inferred type: [a] -> [b]
06:00:09 <dcoutts_> ibid, there was for 0.9.8 but not 0.9.9
06:00:15 <syntaxfree> grrr.
06:00:15 <dcoutts_> ibid, there will be for 0.9.10
06:00:23 <syntaxfree> 'nyway.
06:00:26 <ibid> dcoutts_: yes, and that was why we installed 0.9.8 and not 0.9.9 :)
06:00:33 <ibid> dcoutts_: this laptop currently runs 0.9.9
06:00:36 <dcoutts_> ibid, I'm doing the installer for the 0.9.10 release candidate later today
06:00:41 <dcoutts_> ibid, ok, I see
06:00:47 <syntaxfree> does the ROTn specify that spaces must still be spaces?
06:00:48 <boegel> @plugs let sympledecrypt x = map chr $ map (\x -> x-1) $ map ord x in sympledecrypt "J!hfu!cz!xjui!b!mjuumf!ifmq!gspn!nz!gsjfoet"
06:00:49 <lambdabot> "I get by with a little help from my friends"
06:00:52 <boegel> yaay !
06:00:54 <boegel> :)
06:01:02 <dcoutts_> ibid, the 0.9.10 release candidate source tarball is out now
06:01:04 <ibid> dcoutts_: but i'm going to do this course with what they have now. that's the main reason for the fork
06:01:09 <boegel> syntaxfree: cracked your simpledecrypt :)
06:01:10 <syntaxfree> boegel is a superdecryt hacker. The NSA should hire you.
06:01:14 <dcoutts_> ibid, yes, ok
06:01:14 <boegel> *crypt even
06:01:24 <boegel> syntaxfree: who says I ain't NSA ?
06:01:30 <ibid> dcoutts_: i wonder if the new timer function is even remotely cherrypickable :)
06:01:42 <dcoutts_> ibid, probably
06:01:53 <dcoutts_> ibid, it doesn't use anything fancy
06:02:00 <ibid> yeah
06:02:15 <ibid> of course, it does have a flaw
06:02:32 <dcoutts_> ?
06:02:43 <ibid> one had better not call it more than once (including the optional call from openWindowEx or whatever it was)
06:02:58 <dcoutts_> why?
06:04:01 * dcoutts_ has to go teach functional programming now
06:04:10 <dcoutts_> back later
06:04:12 <ibid> dcoutts_: as far as i can tell, if you call it multiple times, all of those timers are simultaneously active
06:04:19 * ibid starts teaching tomorrow
06:04:23 <syntaxfree> @let stringSub stringA stringB = map chr (zipWith (-) (map ord stringA) (map ord stringB)) in stringSub "Shorty" "Longer"
06:04:23 <dcoutts_> ibid, true, but that's ok
06:04:24 <lambdabot> Unknown command, try @listcommands.
06:04:40 <syntaxfree> @evval let stringSub stringA stringB = map chr (zipWith (-) (map ord stringA) (map ord stringB)) in stringSub "Shorty" "Longer"
06:04:41 <lambdabot> Prelude.chr: bad argument
06:04:42 <ibid> dcoutts_: what i'd like it to do is to have each call override the previous
06:04:58 <dcoutts_> ibid, ok, we can talk about it later
06:05:02 <ibid> dcoutts_: but i didn't feel like invading the central data structures too much :)
06:05:02 <syntaxfree> @eval let stringSub stringA stringB = (zipWith (-) (map ord stringA) (map ord stringB)) in stringSub "Shorty" "Longer
06:05:03 <lambdabot>  lexical error in string/character literal
06:05:05 <ibid> yeah
06:05:09 <syntaxfree> @eval let stringSub stringA stringB = (zipWith (-) (map ord stringA) (map ord stringB)) in stringSub "Shorty" "Longer"
06:05:10 <lambdabot> [7,-7,1,11,15,7]
06:05:15 <syntaxfree> oh!
06:05:57 <syntaxfree> @let stringSub stringA stringB = map chr (map (\x->x+(minimum (map ord stringA))) (zipWith (-) (map ord stringA) (map ord stringB))) in stringSub "Shorty" "Longer"
06:05:58 <lambdabot> Unknown command, try @listcommands.
06:06:10 <syntaxfree> jesus, someone should make @let a synonym for @eval let
06:06:22 <syntaxfree> @eval let stringSub stringA stringB = map chr (map (\x->x+(minimum (map ord stringA))) (zipWith (-) (map ord stringA) (map ord stringB))) in stringSub "Shorty" "Longer"
06:06:23 <lambdabot> "ZLT^bZ"
06:06:33 <syntaxfree> boegel: Crack that one, man :)
06:08:44 * boegel scratches his hair
06:10:02 <boegel> @eval let stringAdd stringA stringB = map chr (map (\x -> x + (minimum (map ord stringA))) (zipWith (+) (map ord stringA) (map ord stringB))) in stringSub "ZLT^bZ" "Longer"
06:10:03 <lambdabot>  Not in scope: `stringSub'
06:10:10 <boegel> @eval let stringAdd stringA stringB = map chr (map (\x -> x + (minimum (map ord stringA))) (zipWith (+) (map ord stringA) (map ord stringB))) in stringAdd "ZLT^bZ" "Longer"
06:10:11 <lambdabot> "\242\263\270\273\275\280"
06:10:15 * boegel swears
06:10:23 <boegel> hey, why not plain char's ? :)
06:10:46 <boegel> it's cracked, only in 1337 notation :P
06:10:56 <syntaxfree>  @eval let stringAdd stringA stringB = map chr (map (\x -> x + (minimum (map ord stringA))) (zipWith (+) (map ord stringA) (map ord stringB))) in stringSub "Trouble is, the sentence and the key have to be the same size" "that could prove very annoying, but it can be arranged,I hope"
06:11:08 <syntaxfree> oops.
06:11:16 <syntaxfree> I used your stringAdd instead of my stringSub.
06:11:35 <boegel> :)
06:11:38 <syntaxfree> @eval let stringSub stringA stringB = map chr (map (\x->x+(minimum (map ord stringA))) (zipWith (-) (map ord stringA) (map ord stringB))) in stringSub "Trouble is, the sentence and the key have to be the same size" "that could prove very annoying, but it can be arranged,I hope"
06:11:40 <lambdabot> Prelude.chr: bad argument
06:11:44 <boegel> hehe
06:12:15 <syntaxfree> @eval let stringSub stringA stringB = (map (\x->x+(minimum (map ord stringA))) (zipWith (-) (map ord stringA) (map ord stringB))) in stringSub "Trouble is, the sentence and the key have to be the same size" "that could prove very annoying, but it can be arranged,I hope"
06:12:16 <lambdabot> [0,42,46,33,98,41,22,-53,29,47,44,-48,34,25,15,-37,115,15,41,34,12,
06:12:16 <lambdabot> 110,34,23,-46,18,21,27,-46,45,92,101,-34,22,17,121,-41,20,97,51,36,-
06:12:16 <lambdabot> 46,116,45,-37,98,36,-50,34,39,23,-39,46,29,97,60,32,43,26,42,32]
06:12:25 <syntaxfree> why?
06:13:22 <syntaxfree> I've got whole -46, -53. That shouldn't happen :(
06:13:53 <syntaxfree> @eval let stringSub stringA stringB = (map (\x->x+(maximum (map ord stringB))) (zipWith (-) (map ord stringA) (map ord stringB))) in stringSub "Trouble is, the sentence and the key have to be the same size" "that could prove very annoying, but it can be arranged,I hope"
06:13:54 <lambdabot> [89,131,135,122,187,130,111,36,118,136,133,41,123,114,104,52,204,104,
06:13:54 <lambdabot> 130,123,101,199,123,112,43,107,110,116,43,134,181,190,55,111,106,210,
06:13:54 <lambdabot> 48,109,186,140,125,43,205,134,52,187,125,39,123,128,112,50,135,118,
06:13:54 <lambdabot> 186,149,121,132,115,131,121]
06:14:11 <syntaxfree> @eval let stringSub stringA stringB = map chr (map (\x->x+(maximum (map ord stringB))) (zipWith (-) (map ord stringA) (map ord stringB))) in stringSub "Trouble is, the sentence and the key have to be the same size" "that could prove very annoying, but it can be arranged,I hope"
06:14:13 <lambdabot> "Y\131\135z\187\130o$v\136\133){rh4\204h\130{e\199{p+knt+\134\181\
06:14:13 <lambdabot> 190\&7oj\210\&0m\186\140}+\205\134\&4\187}'{\128p2\135v\186\149y\
06:14:13 <lambdabot> 132s\131y"
06:14:19 <boegel> omg :)
06:14:34 <boegel> @eval (\131 :: Char)
06:14:35 <lambdabot>  parse error on input `)'
06:14:41 <boegel> @eval \131 :: Char
06:14:42 <Lemmih> How about cycling the key?
06:14:42 <lambdabot>  parse error on input `}'
06:16:24 <Lemmih> @eval '\131'
06:16:25 <lambdabot> '\131'
06:21:00 <araujo> Morning haskell'ers!
06:21:19 <dblhelix> good afternoon, araujo !
06:21:27 <araujo> Hello dblhelix
06:24:23 <earthy> goody. my backupsystem works
06:29:34 <syntaxfree> @eval let stringSub stringA stringB = map chr (map abs (zipWith (-) (map ord stringA) (map ord stringB))) in stringSub "Trouble is, the sentence and the key have to be the same size" "that could prove very annoying, but it can be arranged,I hope"
06:29:36 <lambdabot> " \n\SO\SOHB\t\nU\ETX\SI\fP\STX\a\DC1ES\DC1\t\STX\DC4N\STX\tN\SO\v\
06:29:36 <lambdabot> ENQN\r<EB\n\SIYI\fA\DC3\EOTNT\rEB\EOTR\STX\a\tG\SO\ETXA\FS\NUL\v\ACK\
06:29:36 <lambdabot> n\NUL"
06:38:49 * boegel notices 188 people in #haskell
06:38:56 <boegel> close to the 200 magic number
06:39:12 <boegel> join ##level3
06:43:25 <syntaxfree> I can spawn up a few clones, if 200 is important.
06:44:18 <syntaxfree> boegel: what, internet-wide problems again?
06:47:37 <boegel> syntaxfree: no, I was just checking if they were still on it in there :)
06:48:10 <syntaxfree> it's cool that the big boys have chosen freenode for their channels.
06:49:22 <boegel> which big boys ?
07:25:30 <xah> hi
07:28:17 <beelsebob_> lo
07:28:33 * beelsebob_ waits for someone to say flip-flop
07:28:48 <earthy> flop
07:31:18 <xah> hi all... i'm new to irc, but online since 1991...
07:31:32 <xah> just wanted to get a feel of things.
07:32:02 <Philippa_> are you Xah Lee on usenet by any chance?
07:32:04 <shapr> Are you Xah Lee?
07:32:09 <Philippa_> jinx!
07:32:11 <shapr> :-P
07:32:24 <xah> yes. :)
07:32:29 <shapr> I actually dropped by to ask a question, too bad I forgot what it was.
07:32:55 <shapr> bringert: hiya! How's code?
07:33:09 <shapr> xah: Are you learning Haskell?
07:33:20 <xah> yes, am starting to.
07:33:34 <xah> just started to read the tutorials and refs.
07:33:37 <xah> yesterday
07:33:51 <shapr> Do you need pointers to more tutorials or other information?
07:33:58 <xah> btw, i have one question:
07:34:09 <xah> i have downloaded ghc/ghci on mac.
07:34:10 <ValarQ> shapr: hello formarn
07:34:17 <shapr> hej ValarQ, wazzup?
07:34:39 <ValarQ> shapr: working on those monads again
07:34:43 <shapr> Which ones?
07:34:52 <ValarQ> shapr: i was thinking about implementing that Gen monad myself
07:34:56 <shapr> Or maybe you're investigating monad transformer or other interesting thingys?
07:34:57 <xah> but when i define a type, i get "not in scope" from ghci.
07:35:34 <shapr> xah: You can't define types in GHCi, but you can load them from files.
07:35:48 <shapr> xah: I use haskell-mode in emacs and C-c C-l to dump the file into ghci
07:36:01 <ValarQ> shapr: transformer?
07:36:15 <xah> must a function definition always comes with its type definition as well?
07:36:16 <shapr> There are fully incremental compilers like hi and hs-plugins, but I don't think there's an easy to use ghci-style front end for those.
07:36:59 <shapr> ValarQ: http://www.nomaware.com/monads/html/introIII.html
07:37:06 <eivuokko> xah, nope, compiler will deduct the type if you don't give one.  It succeeds very often (altho type might not be what you expected).
07:37:26 <ValarQ> shapr: thanks
07:37:33 <shapr> xah: Functions can be defined in GHCi. let inc = x + 1
07:37:34 <xah> (ok. Thanks.)
07:38:09 <shapr> JaffaCake: When do you expect the first fptools darcs repo?
07:38:33 <JaffaCake> shapr: dunno, hopefully soon
07:38:42 <shapr> Cool, I look forward to it.
07:38:51 <shapr> It'll definitely encourage me to contribute.
07:38:57 <eivuokko> Heh
07:39:59 <shapr> I had a cvs.haskell.org ssh key long ago... but it took weeks and then I reinstalled and forgot to back it up and... in any case, darcs is a lot easier for me personally.
07:41:03 <shapr> I think pre-commit testing would be workable if the tests were refactored. The point of pre-commit testing is more about top-level regression tests.
07:41:57 <shapr> For example, a single end-to-end test could check a bunch of things at once, and if that fails, it could then execute the detailed test suite.
07:42:46 <shapr> Of course, I'm discounting GHC build time...
07:43:18 <shapr> xah: Any other questions?
07:43:32 * SamB figures out what he messed up in primops.txt.pp
07:43:49 <xah> shapr: i'm sure more will come forth. :)
07:44:05 <shapr> ok
07:44:15 <xah> currently i just have to read more. :)
07:45:04 <Igloo> shapr: Are you suggesting the central repository build ghc for every commit?
07:45:12 <shapr> Nope
07:45:15 <Igloo> Good  :-)
07:45:24 <shapr> That surely sounds painful.
07:45:25 <SamB> Igloo: oi! that would take a CPU, indeed!
07:45:40 <Igloo> Quite
07:45:44 <SamB> and probably less recalculation of dependencies, too!
07:45:53 <shapr> Maybe we could get microsoft to donate a 32-cpu monster, and we could run make -j 45
07:46:06 <SamB> shapr: would that work?
07:46:12 <shapr> It should.
07:46:22 <shapr> I'd like to have that box in my apartment though. It'd save on heating.
07:46:28 <SamB> heh
07:46:32 <shapr> We had our first snow last week, and it didn't get above zero today.
07:46:39 <SamB> maybe one of Sun's crazy SPARCS?
07:46:52 <shapr> Nah, sparcs don't make as much heat ;-)
07:47:08 <SamB> but they have so many more CPUs!
07:47:18 <shapr> well, yeah...
07:47:35 <shapr> I've heard the latest multicore SPARCs are incredible.
07:51:53 <SamB> C-- seems really rather wierd...
07:51:54 <tromp> i don't believe it:(
07:52:08 <SamB> heh
07:52:29 <SamB> thats the definition of incredible right there ;-)
07:53:12 <SamB> does GHC get built with support for -threaded by default?
07:53:17 <C-Keen> re.
07:53:23 <SamB> oh, I guess so...
07:53:28 <shapr> SamB: Since 6.4 I think yes.
07:53:46 <ValarQ> SamB: isn't C-- a lowlevel language?
07:53:56 <SamB> because I'm seeing compiler invocations with -optc-DTHREADED_RTS
07:53:59 <SamB> ValarQ: yeah
07:54:07 <integral> does GHC actually use C--?
07:54:26 <SamB> integral: well yeah, why did you think they implemented the C-- compiler?
07:54:28 <SamB> for fun?
07:54:57 <shapr> I thought they implemented it to be a portable assembly language?
07:54:59 <integral> erm,  well they are research people...  so I guess yes
07:55:10 <SamB> there are a few files in ghc/rts written in cmm
07:55:15 <integral> Wasn't it fun?
07:55:39 <shapr> Man I hate top quoting.
07:55:42 <SamB> integral: yeah, but why would you put a C-- compiler in a Haskell compiler just for fun?
07:56:17 <shapr> Well, GHC is -Ofun
07:56:29 <integral> SamB: I didn't know it was in GHC at all.  I thought it was a separate project
07:56:45 <SamB> integral: oh, GHC has one too
07:56:55 <integral> oh, it's a separate implementation too?
07:56:57 <SamB> it supports an extended subset
07:57:44 <integral> so that's what's used when GHC isn't compiling via C?
07:58:00 <SamB> I'm not sure, but it is used when building the RTS
07:58:19 <integral> oh, ok.
07:59:17 <shapr> I now have very many Haskell-oriented blogs. Google's blog search function works nicely.
08:02:48 <SamB> oh, great!
08:02:58 <SamB> now it complains:
08:03:00 <shapr> Anyway, for all those interested in Fermat's Last Margin... should I just kick it out the door when it barely works.. or should I polish it up some first?
08:03:09 <SamB> GHC/PrimopWrappers.hs:575:28: Not in scope: `GHC.Prim.currentBoundOSThread#'
08:03:10 <SamB> GHC/PrimopWrappers.hs:577:38:
08:03:10 <SamB>     Not in scope: `GHC.Prim.bindCurrentThreadToOSThread#'
08:07:16 <JaffaCake> SamB: GHC uses a subset of C-- as an internal representation in the back end
08:11:57 * joelr waves
08:12:22 <shapr> hiya joelr
08:13:14 <joelr> dons: ping
08:21:30 <joelr> dons appears to be sleeping :D
08:21:41 <joelr> has anyone used hs-plugins to dynamically load haskell code?
08:22:05 <Itkovian> joelr: see lambdabot afaik
08:22:35 <joelr> Itkovian: what do you mean exactly?
08:23:05 <Itkovian> Well, afaik, lambdabot is using hs-plugins. Somebody correct me if I'm wrong.
08:23:59 <joelr> Itkovian: right, yes, i think so. i wish dons was here, though. i'm wondering how to load plain haskell code as opposed to something structured like a plugin
08:24:06 <Itkovian> ic.
08:24:12 <joelr> i'm trying to hide away haskell from the customers
08:24:16 <Itkovian> doesn't eval do that?
08:24:22 <Itkovian> joelr: heh
08:24:47 <joelr> Itkovian: hmm... i didn't think of that...
08:28:16 <bringert> shapr: hi! not much code lately, mostly teaching
08:28:29 <bringert> shapr: how's yours?
08:31:43 <shapr> bringert: Moving right along, Fermat's Last Margin is almost ready for an alpha release.
08:33:11 <xah> shapr: where do i get haskell-mode for emacs? just google search?
08:33:35 <shapr> I think Stefan Monnier is the maintainer nowadays. I use the debian packages myself.
08:37:06 <glguy> Does the name Monad in MSH (Microsoft's shell) have anything to do with the Monad in Haskell (I thought I read that they had hired some GHC programmers)
08:38:03 <yaarg> no glguy
08:39:15 <ibid> glguy: those are unrelated
08:39:27 <yaarg> well apart from the meaning
08:39:57 <ibid> i mean, the ghc programmers and the monad system are to my knowledge unrelated
08:40:30 <ibid> the former are employed by microsoft *research*
08:40:38 <ibid> the company is *huge*
08:40:39 <Philippa_> I got the impression the MSH guys'd been thinking about typed pipes and stuff?
08:40:54 <ibid> well, i have no real information :)
08:42:20 <Philippa_> (I mention that just because it's a vague theoretical connection)
08:42:23 <shapr> bringert: Check out the prototype - http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=TestMargin
08:42:53 <glguy> :-D $ write "virgin forest" \n write: virgin forest is not logged in
08:43:10 <shapr> oj
08:43:22 <yaarg> Philippa_: it passes information between commandlets as objects
08:45:04 <bringert> shapr: interesting. would there be a way to use CSS or somethng to put the annotations in a specific place?
08:45:25 <bringert> highlight something or draw arrows
08:45:29 <bringert> etc.
08:48:07 <syntaxfree> does the name Monad precede Haskell in theoretical computer science?
08:48:18 <syntaxfree> I used to know the word "monad" from philosophy.
08:48:45 <Philippa_> the use in theoretical computer science doesn't quite AFAIK (but it's close). The use in category theory (which is where the TCS use comes from) does
08:48:58 <Itkovian> shapr: one remark ... would it be possible to use pdf's instead of images?
08:49:00 <Philippa_> it's a pre-existing mathematical structure that turned out to be useful
08:49:02 <syntaxfree> ah, yes.
08:49:12 <syntaxfree> my category theory stops at equalizers and coequalizers :)
08:49:31 <syntaxfree> that's about chapter 4 of Michael Arbib's "Arrows, structures, functors".
08:50:22 <ibid> i thought monads in tcs precedes the haskell concept a little
08:50:40 <Philippa_> ibid: point, I read the question more literally than that
08:51:10 <Philippa_> the Haskell usage came pretty much directly from the TCS and the usual insight that "oh look, denotational semantics = functions, I wonder if we can get some useful FP techniques from there?"
08:51:14 <ibid> in that their use in denotational semantics was an inspiration for its use in hgaskell
08:51:22 <ibid> yeah:)
08:52:03 <Philippa_> and lo and behold, it worked. What a surprise :-)
08:53:27 <syntaxfree> I really need to take the next step in CT.
08:54:24 * ibid is beginning to freak out, the first lecture tomorrow and my materials are scattered all over the place
08:55:21 <Philippa_> syntaxfree: I'm finding I get by OK with my rather poor grounding in it, though I'd like to know more. Really I mostly find the opportunity to use categories to describe the semantics of individual languages a useful insight
08:55:41 <Philippa_> insofar as you can then use it to express useful relationships between and indulge in lots of silly metalanguage wankery :-)
08:55:53 <syntaxfree> I might just be unable to see the cat theory behind Haskell.
08:56:29 <syntaxfree> maybe I need to get a good look at the theoretical aspects of haskell monads and pick up cat theory as needed.
08:56:45 <Philippa_> I've not sat down and bashed out the details, I suspect laziness does some fun things - but you can build categorical models of algebraic datatypes and the like fairly easily, I've seen it done in enough papers
08:57:03 <Philippa_> if you can grok the raw category theory, monads as used in Haskell're fairly easy
08:57:54 <syntaxfree> I didn't find cat theory to be hard until the point I went.
08:57:55 <Philippa_> you just need to know that one category involved is Haskell's semantics, and the other is the semantics of another language that has some requirements imposed by the available operations (eg programs in it are haskell values, it supports 'higher order computations' (see join), programs can contain haskell programs (see return))
08:58:13 <syntaxfree> I have more trouble with real analysis than with arrow-chasing proofs.
08:58:26 <Philippa_> note that while programs in the other language are haskell values, it doesn't mean they're necessarily expressible in haskell without touching the other category (see IO)
08:59:06 <xerox> Howdy, folks.
08:59:09 <syntaxfree> hmm.
09:00:48 <Philippa_> you can also deduce that the monadic signiature supports sequencing (but doesn't require it except in a dependency kinda way)
09:01:17 <Philippa_> that and the programs-as-abstract-values thing are what makes monads a suitable structure for IO
09:01:27 <Philippa_> this making any sense?
09:04:01 <shapr> bringert: I don't know, I haven't investigated that. Once Mozilla supports SVG, putting arrows on top of an image will be easy. I do wish I knew of an open source tool to convert pdf/ps to SVG.
09:04:26 <thedward> shapr: pstoedit
09:04:35 <xah> the symbols in haskell logo: Î»â†’âˆ€Â»âˆ·â‡’, i'm using in my learning blog, which order makes more sense?
09:05:03 <shapr> Itkovian: well, the point is to annotate research papers. 'Real' annotation would require parsing the PDF/PS and inlining just that page.. I think. Can you think of a better awy?
09:05:03 <syntaxfree> I don't see any of those symbols.
09:05:04 <integral> âˆ· isn't just a :: ?
09:05:06 <bringert> shapr: as long as it's just text (and no arrows etc) couldn't you just use some CSS positioning
09:05:11 <syntaxfree> Î»ââÂ»â·â
09:05:18 <syntaxfree> screenshot? ;-)
09:05:25 <Itkovian> shapr: nono, I mean, dividing the paper pdf into page pdfs
09:05:27 <syntaxfree> also, blog URL? :)
09:05:28 <xah> (i'm using utf8 encoding)
09:05:30 <shapr> bringert: No clue, could I?
09:05:37 <bringert> I think so
09:05:40 <Itkovian> not for writing ont the page, but it's better for printing, no?
09:05:51 <bringert> it was a while since I played with that stuff
09:06:15 <xah> what does the double right angle mean in haskell?
09:06:15 <shapr> bringert: Ok, I'll add that to the list of things to investigate for a 'real' release.
09:06:52 <shapr> Itkovian: Well, the point of this is to annotate it inside the wiki so your annotations are shared with everyone.
09:07:10 <shapr> xah: It's the monadic bind that doesn't pass anything.
09:07:12 <Itkovian> sure, I'd keep that, but instead of a png, I'd show a pdf, eh.
09:07:43 <shapr> Is there some simple way to snip apart a PDF file into pages?
09:08:23 <shapr> bringert: btw, I love the EH2004 logo, brilliant design.
09:08:57 <xah> shapr: what about the => (sorry for basic questions)
09:09:13 <shapr> xah: you should check out the HaskellDemo
09:09:15 <shapr> @wiki Haskelldemo
09:09:16 <lambdabot> http://www.haskell.org/hawiki/Haskelldemo
09:09:17 <shapr> oops
09:09:19 <shapr> @wiki HaskellDemo
09:09:20 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
09:09:25 <shapr> => means "is an instance of a typeclass"
09:10:12 <shapr> Itkovian: If you can find a simple way to snip apart PDFs that works on Linux, I'll stick it in there. (though maybe not in the first version)
09:10:31 <xah> shapr: am reading the demo now. Thanks. does haskell actually use the inverted A?
09:10:39 <Itkovian> ghostscript? or keepboth the png and the pdf
09:10:51 <shapr> Yeah, but it's the word 'forall'
09:10:54 <integral> xah: it's written as "forall"
09:11:07 <xah> got it. Thanks.
09:11:21 * shapr feels universally qualified angst.
09:11:29 <shapr> forall angst...
09:11:53 <shapr> Itkovian: The pdf is kept, it gets cached locally.
09:12:33 <Itkovian> yes, but not in separate pages.
09:12:43 <Itkovian> printing pdf is way prettier than printing pngs
09:12:43 <xerox> Check this out... http://video.google.com/videoplay?docid=-6501132973100863357&q=parkour
09:13:12 <thedward> shapr: you can split a pdf with ghostscript (http://centaur.maths.qmul.ac.uk/Info/pdf-faq.html#UNIX)
09:13:43 <shapr> thedward: pstoedit is nice, too bad the SVG output isn't OSS
09:13:43 <Philippa_> xerox: seen before. A friend of mine does a little
09:14:17 <xerox> I'd love to be so agile.
09:14:21 <Itkovian> seen that
09:14:25 <Itkovian> it's cool
09:14:57 <thedward> shapr: the version I have uses liplot, which is GPL...
09:15:02 <thedward> err. libplot
09:16:27 <shapr> Itkovian: I agree that bitmaps don't print as well as vector formats, that's why I'd like SVG. If you find some cool way to do what you want, patches are always accepted :-)
09:22:16 <thedward> shapr: in particular, the version that comes with debian is linked to libplot, and requires no additional software to output to svg
09:22:56 <shapr> !
09:24:51 <basti_> hmm a quotient type only makes sense with a equivalence as "denominator" doesnt it?
09:30:32 <shapr> thedward: It's not quite perfect, but it's close!
09:30:52 <thedward> I've had good luck with logos and such, haven't played with using it for text documents
09:32:06 <shapr> Surprisingly, the SVG files are smaller.
09:33:16 <thedward> interesting
09:33:28 <shapr> pstoedit takes more time than imagemagick's convert, but it appears to work. Kerning is the only problem.
09:34:22 <shapr> I think it's using a font that's slightly too large.
09:34:53 <ndm> has anyone any idea how to use CGI under haskell...
09:35:17 <ndm> i just want to get the query string, nothing fancy
09:36:08 <shapr> I use Flippi :-)
09:36:26 <ndm> if the user doesn't type ?q=blah then it goes to the arguments
09:36:51 <ndm> i.e. if they do cgi-file?query you get ["query"] as getArgs
09:36:57 * basti_ frowns at his broken haspr installation
09:37:43 <shapr> Hm, this svg file could be heavily optimized.
09:37:44 <gour> shapr: have you tried inkscape & latex with pstricks macros export?
09:37:58 <shapr> er, huh?
09:38:53 <gour> shapr: well, i'm thinking about some tool to illustrate beamer presentations..
09:39:04 <Itkovian> gour: keynote ;-)
09:40:14 <syntaxfree> hmm. a monad is a type of functor.
09:41:46 <shapr> thedward: Does SVG output of a ps or pdf work for you? If so, maybe I have my DPI settings wrong in X
09:43:10 <pesco> SVG! Bah!
09:43:35 <pesco> I have _suffered_ SVG.
09:43:46 <shapr> hm?
09:43:52 <gour> Itkovian: can you explain (in short) what they are talking about?
09:44:24 <shapr> Here's what I have - http://www.scannedinavian.org/~shae/multiproc.svg
09:44:41 <pesco> shapr: When making the KHJK logo, I tried to do it in SVG (writing by hand) and became quite angry quite soon.
09:44:45 <shapr> I shrunk the font of the first few words down to 8.0 from 8.9 something.
09:45:23 <pesco> I have no idea how the implementors of SVG viewes and, worse yet, editors stand it.
09:45:57 <shapr> That seems to have fixed the kerning. This leads me to believe that it used my (incorrect) dots per inch setting for its font size.
09:46:07 <shapr> pesco: I've never tried it. Much pain?
09:46:35 <pesco> They _probably_ do something quite similar to what I did. Work on a decent representation, write an exporter, forget about SVG.
09:48:33 <pesco> shapr: Much pain. I mean the thing is _called_ Scalable Vector Graphics. You would _expect_ a language for describing geometric shapes independent of particular coordinate systems and output devices.
09:49:26 <pesco> The fun starts when you realize that they not only have "pxels" as a unit of measurement (bad enough!), but it's also the default.
09:50:08 <thedward> shapr: it works fine here, but once again I haven't done anything with text
09:50:24 <pesco> That's worse than it sounds, because, well, all the other units are physical units, too. So it is in fact impossible to _not_ code physical units into your SVG images.
09:51:38 <pesco> You might think, oh well, grmbl grmbl, but it doesn't stop there!
09:52:20 <thedward> shapr: hmm. yeah. fonts not happy there. I know there are various ways to tweak the font choices it makes, but I've not used them myself.
09:52:52 <shapr> pesco: That sucks. I was hoping for shapes that were separately scaled.
09:52:58 <pesco> Wait until you try to tell it, that for christ's sake, you would like to specify your image with the y-axis pointing up instead of down.
09:53:38 <pesco> It is possible, mind you! But you don't want to know the details.
09:53:47 <shapr> I'll take your word for it.
09:54:34 <shapr> Ok, time to restart X with the X and Y of my screen in mm, bbl
09:55:01 <pesco> :)
09:55:03 <thedward> why would pstoedit care about x resolution?
10:05:38 <vegai> dons: Hey... should lambdabot's runplugs be working with ghc-6.4.1 and hs-plugins-0.9.10 (and its runplugs)?
10:12:08 <dcoutts_> ibid, I'm back
10:14:37 <ibid> dcoutts_: :)
10:14:54 * ibid is working furiously on his course
10:16:01 <dcoutts_> ibid, I'm doing the same for my FP course :-)
10:16:10 <dcoutts_> ibid, anything I can help you with then?
10:16:48 <dcoutts_> ibid, I should announceon the Gtk2Hs web site that Gtk2Hs is being used to teach FP at at least 2 universities :-)
10:16:59 <dcoutts_> ibid, which uni are you at?
10:17:06 <ibid> i'm mostly trying to cope under me telling myself that i'll suck :)
10:17:16 <ibid> dcoutts_: university of jyvÃ¤skylÃ¤, finland
10:17:20 <dcoutts_> na, you'll be fine :-)
10:17:25 <ibid> opening lecture is tomorrow
10:17:57 <ibid> this, btw, isn't my first course or my first attempt at teaching fp :)
10:18:03 <dcoutts_> ibid, well when both courses are going ok (ie we're sure that they don't suck) then maybe we could stick a news item on the Gtk2Hs web site. It'd be good advertising.
10:18:12 <ibid> yeah
10:18:21 <ibid> yours has started already?
10:18:23 <dcoutts_> ibid, me too. But it's a new practical for the Oxford FP course.
10:18:32 <dcoutts_> mine starts on monday
10:18:36 <ibid> ah
10:18:40 <ibid> next week?
10:18:43 <dcoutts_> at least the 2nd practical which I'm doing starts then
10:18:45 <dcoutts_> next week
10:19:11 * ibid sucks at examples
10:19:22 * dcoutts_ too
10:19:34 <dcoutts_> those are the bits I need to finnish off
10:20:12 <ibid> suomettaa
10:20:22 <ibid> suomettuminen
10:20:23 <ibid> :)
10:20:59 <ibid> i've had trouble finding comparable courses with material on the web
10:21:51 <ibid> (this is a "haskell as a second language" type of elective course in a generally oo university)
10:26:00 <gour> dcoutts: do you offer correspondence course too?
10:27:13 <dcoutts_> gour, no, sorry
10:27:39 <dcoutts_> gour, thanks for testing the release candidate btw
10:27:44 <gour> dcoutts_: :-)
10:28:18 <dcoutts_> dunno exactly what's going on with those plugins
10:28:27 <gour> dcoutts_: are msgs from mozembed because of 32/64bit plugins?
10:28:55 <dcoutts_> quite possibly
10:29:07 <dcoutts_> try "file" on all those files
10:29:14 <dcoutts_> and the testmozembed exe
10:29:22 <dcoutts_> it should say if they are 32bit or 64 bit
10:29:31 <dcoutts_> the testmozembed will probably be 64bit
10:29:57 <dcoutts_> file /opt/netscape/plugins/*.so
10:30:06 <dcoutts_> file /home/gour/.mozilla/plugins/*.so
10:30:12 <gour> dcoutts_: yes, nppdf.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), stripped
10:31:27 <gour> dcoutts_: everything is 32-bit
10:31:32 <kombinator> dcoutts_: Examples compiled by installcheck use the default gtk package installed in the system, not the one installed from their tree?
10:32:43 <dcoutts_> kombinator, yes it used the installed gtk packages, so should be done after make install
10:32:56 <kombinator> dcoutts_: I just looked at one of their makefiles and didn't notice any reference to the alternative package.conf that I've specified during ./configure
10:33:19 <kombinator> What if I want to install to an alternatice package.conf?
10:33:38 <dcoutts_> kombinator, oh, yes the demos might not be compiled using the alternate package.conf file
10:33:44 <kombinator> will have to change makefiles I guess..
10:33:53 <dcoutts_> kombinator, but you can build them yourself that way
10:34:01 <kombinator> right
10:35:48 <dcoutts_> kombinator, ohm, actually looking at the Makefile.am code again, it should use the package.conf file that you specify during make installcheck
10:36:04 <dcoutts_> # For the install check just make sure all the demo programs compile and link
10:36:04 <dcoutts_> DEMO_MAKE_ARGS= $(if $(PKGCONF), HCFLAGS="-package-conf $(PKGCONF)") \
10:36:04 <dcoutts_>                 $(if $(GHCPKG_USE_AUTOLIBS),, HCNEEDSPACKAGE=yes) HC=$(HC)
10:36:40 <dcoutts_> gour, so what does file say about the demo/mozembed/testembedmoz ?
10:36:49 <dcoutts_> is it 32 or 64 bit?
10:37:59 <dcoutts_> kombinator, so if it's not doing that properly I'll look into it
10:38:45 <kombinator> dcoutts_: no, I don't see any reference to that package.conf
10:38:46 <gour> dcoutts_: testembedmoz:    ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for GNU/Linux 2.6.6, dynamically linked (uses shared libs), not stripped
10:39:12 <dcoutts_> kombinator, so what command does it run when you make installcheck?
10:39:32 <dcoutts_> gour, so that'd explain why it cannot load the plugins
10:40:25 <gour> dcoutts_: yes, good guess, although the window with the file gets opened
10:40:56 <dcoutts_> gour, yes, it just ignores the plugins that it cannot load
10:41:21 <dcoutts_> gour, if you start mozilla from a command line I bet you'll get the same messages
10:41:57 <kombinator> dcoutts_: my appologies - it does specify the correct package.conf
10:41:57 <gour> dcoutts_: yes, this is a well-known issue with the lack of 64-bit flash etc. plugins
10:42:03 <dcoutts_> goodchilde, yes
10:42:11 <dcoutts_> kombinator, ok great. :-)
10:42:31 <gour> dcoutts_: bit i can live with that, i'm not impressed with flash sites anyway
10:42:37 <dcoutts_> gour, heh
10:42:55 <kombinator> dcoutts_: It's just not present in Makefiles but probably smuggled in env variables.
10:43:13 <gour> dcoutts_: wish you all the best with the course, i have another (3rd group) for the week-end, just before yours :-)
10:43:43 <dcoutts_> so, so far gour has found one bug. One of the demos it not built by default.
10:44:13 <gour> dcoutts_: huh, great accomplishment
10:44:32 * gour laughs on himself for his contribution to the haskell community
10:44:34 <dcoutts_> kombinator, hmm, I'd expect it to be in the Makefile near the top as: PKGCONF = ....
10:44:49 <xerox> @karma+ gour -- ;-)
10:44:50 <lambdabot> gour's karma raised to 1.
10:45:04 <dcoutts_> gour, your bug fixing & website stuff is really helpful. And the darcs setup.
10:45:20 <gour> xerox: hey, i want to get rid of my karma & become karma-free ;)
10:45:35 <dcoutts_> gour, the darcs thing has been really sucessful in helping people keep up with the latest gtk2hs dev  version
10:45:47 <gour> dcoutts_: i'm longing for the real stuff :-)
10:45:53 <xerox> gour: that's positive karma!
10:46:01 <dcoutts_> gour, it means people find bugs much sooner so there are fewer found when it comes to a proper release
10:46:02 <kombinator> dcoutts_: right, it's in the main Makefile
10:46:12 * kombinator *embarassed*
10:46:23 <dcoutts_> kombinator, no problem :-)
10:46:34 <gour> xerox: can you explain it to me more philosophically ;)
10:47:21 <dcoutts_> kombinator, the gtk2hs build system is rather complex :-(
10:47:38 <gour> dcoutts_: iirc, i saw here (sometime ago) that shapr put some instance of trac online
10:47:50 <xerox> gour: concat $ intersperse (randomBuzzword) ["@karma+ ", "is ", "good ", "for ", "you "]
10:48:10 <gour> dcoutts_: but it looks it's not hIDE related?
10:49:01 <dcoutts_> gour, oh, dunno. I thought he was doing it for hIDE.
10:49:06 <gour> xerox: nice attempt :-)
10:49:21 <gour> dcoutts_: url?
10:49:32 <dcoutts_> gour, ask shapr
10:49:34 <dcoutts_> @seen shapr
10:49:35 <lambdabot> I saw shapr leaving #haskell 54 minutes and 49 seconds ago.
10:49:39 <xerox> dcoutts_: what's the situation for Haskell+Gtk on OS X ?
10:49:56 <dcoutts_> xerox, it should work with the OS X X11 server
10:50:10 <psi_> it does work
10:50:35 <dcoutts_> psi_, oh great. Have you tried the 0.9.10 release candidate?
10:50:44 <xerox> I'm going to be payed shortly and I'm looking for the pb 12".. hmm.
10:50:50 <gour> dcoutts_: btw, i concluded that sqlite & hsql would be enough for my db needs with haskell
10:50:54 <Lemmih> gour: Hi. Do you have ghc-6.5 installed and feel like doing some hIDE/hs-plugins testing?
10:51:12 <psi_> dcoutts_: no. i was looking for something to do, though :-)
10:51:12 <dcoutts_> psi_, it'd be great for me to be able to menation in the Gtk2Hs release announcement that it has been tested on OS X.
10:51:17 <gour> Lemmih: no, i'm on 6.4.1
10:51:20 <dcoutts_> psi_, yay! :-)
10:51:30 <dcoutts_> gour, right.
10:51:34 <psi_> does it include cairo support?
10:51:40 <dcoutts_> psi_, yep
10:51:44 <psi_> i'd like to try nymphaea
10:51:51 <dcoutts_> oh, yeah
10:51:52 * xerox boings happily
10:51:57 <gour> dcoutts_: can I use gentoo ghc-cvs to help Lemmih with the testing?
10:52:12 <dcoutts_> psi_, that'd be nice. It works fine on Win32. We tried that the other day.
10:52:20 <dcoutts_> gour, probably.
10:52:24 <psi_> ok
10:52:53 <gour> Lemmih: so, i can try to emerge 6.5, but it will take some time ._)
10:53:20 <dcoutts_> xerox, we should get some screenshots of Nymphaea on several platforms, like we did for boegel's HRay.
10:53:40 <dcoutts_> xerox, add it to our "featured Gtk2Hs apps" section on the website. :-)
10:53:42 <xerox> dcoutts_: yes sure. I'm making a new site which will have a page for that, too :)
10:53:58 <gour> Lemmih: or do you need immediate feedback?
10:54:28 <dcoutts_> xerox, so we'd have a little bit on the Gtk2Hs website which would have a few pics showing of Gtk2Hs and links to the main site.
10:54:56 <dcoutts_> xerox, we want to show that Gtk2Hs is really being used and that it can be sued for cross-platform apps.
10:55:01 <xerox> dcoutts_: I'd love it.  Cale made some _very_cool_ pics!  Let me finish the new site before :-)
10:55:04 <dcoutts_> sued/used :-)
10:55:31 <xerox> (The template is there, I need to write four more pages and it's done)
10:55:33 <dcoutts_> xerox, ok and hopefilly psi_ will get it to work on OSX and we can get some pics of that too.
10:55:41 <xerox> It would be great.
10:55:58 * xerox is slacking instead of writing the â€œTheoryâ€ page :)
10:57:35 <gour> dcoutts_: i'm waiting 1.0 release to move to gallery2, is it ok?
10:57:59 <Lemmih> gour: Nope, any time would be great. Thanks.
10:59:03 <gour> Lemmih: ok, do i need head of 6.5 or some snapshot would do?
10:59:24 <dcoutts_> gour, sure
10:59:45 * SamB wonders what a join var is, and why GHC considers it interesting for one not to be let-escaped
11:00:20 <SamB> GHC said:
11:00:25 <SamB> Interesting!  A join var that isn't let-no-escaped [zdj{v s8Ky}]
11:00:47 <psi_> xerox: do you need glade to build nymphaea?
11:00:55 <vegai> is the last part ghc cursing?
11:01:21 <SamB> ValarQ: no.
11:01:29 <kombinator> gour: You've just compiled gtk2hs on an AMD64 box - did you compile in mozembed?
11:01:44 <gour> kombinator: yup
11:01:54 <xerox> psi_: libglade at least, and gtk2hs compiled with support
11:01:55 <SamB> I'm not sure what the zdj, the brackets, or the v are, but the s8Ky is a core identifier (it shows up in the generated .hc code)
11:02:03 <xerox> Dinner, BBL.
11:02:13 <SamB> er, s/ValarQ/vegai/
11:02:30 <psi_> xerox: ok. i have some compiling ahead of me, then :)
11:02:34 <kombinator> I can't get past configure, even though I have firefox and I haven't found any firefox-dev package in Debian...
11:02:35 * psi_ recently reinstalled os x
11:03:02 <Lemmih> gour: Any recent CVS snapshot of ghc should be fine.
11:03:14 <gour> Lemmih: fine
11:04:13 <ibid> dcoutts_: the Jyu in JyuGraphics is for jyvÃ¤skylÃ¤ university :)
11:04:55 <Lemmih> gour: And you don't have to install hIDE or its dependencies, only hs-plugins (from the darcs repo) is needed for the test.
11:05:32 <SamB> kombinator: you need to install the gtk headers for that
11:05:56 <dcoutts_> ibid, is there a web page?
11:06:03 <SamB> that is, the specific ones needed for mozembed...
11:06:18 <ibid> dcoutts_: for which?
11:06:27 <SamB> I think
11:06:45 <dcoutts_> ibid, the universtiy?
11:06:49 <kombinator> SamB: you mean gtk2?
11:06:50 <SamB> let me run dpkg -S
11:06:52 <gour> Lemmih: no new patches in hs-plugins repo?
11:07:05 <dcoutts_> ibid, btw I still don't understand the issue with timers. It looks ok to me.
11:07:13 <gour> Lemmih: i'm emerging 6.5
11:07:16 <ibid> dcoutts_: www.jyu.fi
11:07:20 <SamB> oh, just install mozilla-dev, actually...
11:07:39 * SamB wonders why he even has that installed...
11:07:43 <ibid> dcoutts_: it installs a new timeout handler each time the timer setter is called
11:07:50 <dcoutts_> kombinator, not all distros produce -dev packages for firefox or even mozilla
11:08:04 <SamB> kombinator: you got that?
11:08:15 <dcoutts_> kombinator, what we need exactly for firefox support it the firefox-gtkmozembed.pc file
11:08:16 * kombinator is installing mozilla-dev
11:08:39 <SamB> oh, maybe not
11:08:42 <dcoutts_> ibid, right but that only happens once for each window.
11:08:51 <SamB> cause I don't have that .pc file
11:09:02 <dcoutts_> ibid, oh your api allows you to set the timer again later
11:09:27 <ibid> dcoutts_: that's what i was referring to, that the new function is broken in that way :)
11:09:29 <SamB> ouch!
11:09:44 <ibid> dcoutts_: the english main page is http://www.jyu.fi/indexeng.shtml
11:09:50 <dcoutts_> ibid, so you'd have to change the timer, which would mean having to save the handler id so you could remove the timer later
11:10:01 <dcoutts_> ibid, ok thanks.
11:10:16 <dcoutts_> ibid, so you can removet the handler with timoutRemove
11:10:38 <dcoutts_> ibid, and save the id returned by timoutAdd
11:11:01 <ibid> dcoutts_: yes, and as i said above (way back there:) i didn't want to change the central data structures, so i didn't do that
11:11:04 <SamB> so how come there isn't a firefox-dev package?
11:11:17 <dcoutts_> ibid, I can send you a patch
11:11:47 <kombinator> now --enable-mozilla works, but --enable-firefox doesn't
11:12:29 <ibid> dcoutts_: ok :)
11:12:45 <ibid> dcoutts_: funnily, there seems not be an english version of the new department home page
11:13:09 <SamB> I don't suppose there is a way to search all the packages by contained files?
11:13:32 <kombinator> SamB: go to the debian packages page
11:13:50 <kombinator> http://www.debian.org/distrib/packages
11:15:06 <SamB> hmm, why did they move it from packages.debian.org?
11:15:11 <SamB> at least it forwards...
11:15:19 <ibid> they didn't?
11:15:23 <ibid> it's always been like that
11:15:25 <ibid> iirc
11:15:46 <SamB> well then why do I even know the address packages.debian.org?
11:16:03 <ibid> it's easier to remember?
11:16:09 <kombinator> I remember it too
11:16:14 <kombinator> (the old one)
11:16:27 <ibid> what's "the old one"?
11:17:36 <kombinator> http://packages.debian.org
11:17:59 <dcoutts_> ibid, I've sent the patch. I've not tested it :-)
11:18:14 * SamB wishes GNU ar was optimised for thousands of members
11:18:41 <ibid> :)
11:18:57 <SamB> hmm, I wonder how hard it would be to fix it...
11:19:14 <SamB> does it have any architecture dependencies?
11:19:28 <ibid> kombinator: that's not "the old one", it's always, iirc, redirected to the other address
11:19:57 <SamB> ibid: maybe the other address used to redirect there?
11:20:38 <ibid> unlikely
11:20:53 * kombinator doesn't remember clearly enough to argue
11:21:26 <dcoutts_> ibid, send some more patches, fixing the first one. :-)
11:21:31 <ibid> packages.debian.org is visible in package maintainer contact addresses
11:22:39 <dcoutts_> ibid, got a link to the Finnish version of the CS department page?
11:23:29 <dcoutts_> ibid, I don't see the CS dept even on the Finnish version of the home page
11:24:16 <SamB> this source file is awful short
11:24:25 <dcoutts_> SamB, yeah, ghc severly abuses ar when it comes to having thousands of members
11:24:39 <dcoutts_> especially when using the splitobj thing
11:24:52 <dcoutts_> then every function goes into it's own .o file
11:25:01 <SamB> well, yes, I would have said tens or hundreds if splitobj wasn't on
11:25:22 <ibid> dcoutts_: there are two "cs depts", i'm on the dept that's not called "the cs dept" :)
11:25:26 <ibid> dcoutts_: (uni politics)
11:25:31 <dcoutts_> heh
11:25:33 <SamB> actually, I think this is more like 10s or 100s of thousands
11:25:47 <ibid> dcoutts_: http://www.jyu.fi/it/laitokset/mit/
11:25:58 <SamB> ibid: what is it called?
11:26:19 <ibid> SamB: in english, department of mathematical information technology
11:26:37 <ibid> (MIT, get it:)
11:27:02 <ibid> the finnish name drops the "mathematical"
11:27:22 <jgilbert> Hi, and help!
11:27:31 <dcoutts_> ibid, I see :-)
11:27:38 <jgilbert> I'm looking for a Haskell parser for moinmoin
11:28:13 <jgilbert> I think that http://haskell.org/hawiki/ has one, but I can't find out where to download it
11:28:26 <ibid> the funny  part is that these two depts form the "faculty of information technology" (finnish universities are organized into "faculties" which usually contain one or more "departments")
11:29:05 <ibid> (a faculty in finnish university jargon is, i believe, equivalent to a school or a college in other parts of the world)
11:29:15 <ibid> roughly equivalent
11:29:21 <jgilbert> Can I get an ACK so I know someone can read my messages?
11:29:28 <ibid> jgilbert: we read you
11:29:37 <jgilbert> cheers, thanks
11:29:46 <ibid> no idea on your question :)
11:29:51 <jgilbert> natch
11:30:00 <ibid> from me at least'
11:30:56 <ibid> the reason for two departments is mostly historica
11:30:57 <ibid> l
11:32:27 <ibid> the department called "department of computer science and information systems" was a part of the social sciences faculty for a looong time and traditionally focused on suit computing
11:33:14 <ibid> the department called "department of mathematical information technology" is an outgrowth from the maths department, its former scientific computing unit
11:33:26 <bringert> is there anything you can do about the increased memory usage of Haskell programs compiler on amd64?
11:33:33 <bringert> s/compiler/compiled/
11:33:34 <ibid> (or rather, applied mathematics)
11:33:51 <SamB> bringert: use 32-bit mode!
11:34:03 <SamB> or, double your RAM
11:34:06 <Igloo> bringert: You are using a registerised 6.4.1 presumably?
11:34:12 <dcoutts_> ibid, I'll write a little thing for the Gtk2Hs web site and check it with you before putting it up.
11:34:13 <ibid> those two departments used to be separated so long that their work cultures are virtually incompatible
11:34:17 <ibid> dcoutts_: ok
11:34:24 <bringert> Igloo: what's that?
11:34:32 <bringert> I can google though
11:34:55 <Igloo> bringert: If it 6.4.1 then it will be registerised by default
11:34:55 <SamB> bringert: you can even google right here
11:35:02 <Igloo> s/it/it's/
11:35:26 <bringert> Igloo: I use 6.4.1 from debian unstable on ubuntu breezy
11:35:41 <ibid> while we (the staff of the faculty) prepared for the bologna process, we unified our basic teaching, so most of our core curriculum is now shared between the depts
11:36:01 <ibid> (should i shut up?:)
11:36:03 <Igloo> I suspect that won't be registerised, but I'm not sure
11:36:10 <SamB> ibid: I'm not sure
11:36:13 <jgilbert>  /msg nickserv register joshuacgilbert@gmail.com
11:36:34 <jgilbert>  /msg nickserv register
11:36:46 <ibid> jgilbert: you might want to lose the space? :)
11:36:46 <Igloo> Rebuilding it with amd64 added to the list currently containing i386 sparc in debian/rules might help
11:36:47 <SamB> jgilbert: shh! there are logbots around!
11:37:23 <jgilbert> ibid: you
11:37:26 <SamB> what list?
11:37:32 <jgilbert> ibid: you're a pearl, thanks
11:37:43 <bringert> Igloo: I'm new to debian / ubuntu, but I'll see what I can figure out
11:37:58 <ibid> dcoutts_: the faculty seems to have english pages http://www.jyu.fi/it/en/
11:38:35 <jgilbert> the question is increasing the memory available to a Haskell process under Debian?
11:39:05 <ibid> jgilbert: how are you experiencing the memory shortage?
11:39:32 <jgilbert> I don't have one. I'm a Debian user and thought that that was the topic
11:39:51 <jgilbert> My raison d'etre is a Haskell parser
11:39:52 <Igloo> No, the question is if it is possible to reduce the memory used
11:40:01 <ibid> ah, misparsed:)
11:40:15 <jgilbert> reduce? how is that a Debian specific question?
11:40:22 <bringert> Igloo: so ghc 6.4.1 is normally registerised, but the debian unstable package is not?
11:41:12 <SamB> oh, so thats why GNU ar doesn't like such huge archives; it apparantly uses a linked list of members...
11:41:20 <dcoutts_> SamB, heh heh
11:42:05 <Igloo> bringert: The build breaks (or at least it used to) on arches where registerisation is not supported, so it's only turned on on arches where it's known to work, and I haven't tested/updated it on amd64 (or powerpc) yet
11:43:18 <SamB> or maybe not, I can't tell yet...
11:45:19 <bringert> Igloo: ah, thanks for the explanation. I'm new (started last week) to debian and ubuntu, but I'll figure out to to build new packages I guess. Do you know which GHC version I need to get support for registerization for amd64?
11:45:41 <Igloo> 6.4.1
11:46:05 <bringert> ok, thanks
11:46:18 <Igloo> apt-get source ghc6; cd ghc6*; vi debian/rules (and add amd64 to the i386 sparc list); dpkg-buildpackage -rfakeroot -us -uc; should do it
11:46:29 <Igloo> You might also want to add a note to debian/changelog
11:46:52 <Lunar^> Igloo: ghci doesn't work with the last Debian package on powerpc, it seems
11:47:11 <xerox> Igloo: are you the debian :+: haskell guy?
11:47:13 <Igloo> Lunar^: Did it work before?
11:47:20 <Igloo> xerox: One of them
11:47:35 <Lunar^> Igloo: I think it was working with 6.4
11:47:39 <xerox> Igloo: a question - will the new gtk2hs support cairo from the .deb ?
11:47:49 <Igloo> Lunar^: What happens now?
11:48:01 <Lunar^> Igloo: it's working with the sarge package, for sure
11:48:23 <Igloo> xerox: No idea; marcot was looking at packaging gtk2hs I think
11:48:32 <ibid> i was too :)
11:48:44 <xerox> Igloo: if you have any word in it, please push for cairo support :)
11:48:49 <ibid> i'll probably pass, though
11:49:16 <Lunar^> Igloo: I'll get ghc6=6.4-4.1 to check
11:50:11 <kombinator> Igloo: are you going to upload registered ghc to amd64?
11:50:25 <dcoutts_> ibid, so I'm writing the little blurb for the Gtk2Hs website. It'd be nice to have a quote from you about why you chose to implement the JyuGraphics module using Gtk2Hs rather than something else.
11:50:44 <Igloo> Lunar^: DYM 6.4.1-1?
11:51:05 <dcoutts_> ibid, eg because it's got a win32 installer, or because it's easier to modify than the original HGL based version, or because the HGL is borken on win32?
11:51:08 <Igloo> kombinator: Once I have some evidence it works, yes
11:51:16 <ibid> dcoutts_: ok, here's the raw material, please don't quote it verbatim from irc :)
11:51:23 <dcoutts_> ibid, sure :-)
11:51:41 <dcoutts_> ibid, I'll get you to 'ok' any quote :-)
11:52:33 <ibid> dcoutts_: basically, 1) i wanted some way of doing visual stuff with haskell with minimal time needed to learn the graphics API
11:52:51 <ibid> dcoutts_: 2) it would have to be portable to at least linux and windows
11:53:09 <ibid> dcoutts_: (because of the distribution of os's here:)
11:53:38 <ibid> dcoutts_: 3) my first choice, the ghc-bundled graphics library was out of order on windows
11:54:08 <ibid> dcoutts_: 4) i had some experience in gtk programming (as opposed to, sat wxwidgets)
11:54:24 <ibid> dcoutts_: i think that's the main of it :)
11:54:32 <ibid> *say
11:54:34 <dcoutts_> ibid, ok thanks, that's great.
11:55:52 <dcoutts_> ibid, your course is for first year students? or for older sutdents doing an optional FP course?
11:56:31 <ibid> dcoutts_: the course is elective intro to fp after a minimum of year and a half of oo programming in java
11:57:14 <kombinator> dcoutts_: I've got lots of warnings in the end, like this: Warning: Graphics.UI.Gtk.Abstract.Box: could not find link destinations for:
11:57:14 <kombinator>     Graphics.UI.Gtk.Types.GammaCurve
11:57:15 <ibid> dcoutts_: the "optimal" placing is third year, though there are a lot of older students participating too (this is the second fp offering basically ever)
11:58:18 <Lunar^> Igloo: ghci in ghc6=6.4-4.1 works
11:59:03 <ibid> hmm, i need an "oh wow" example of haskell that's 1) short and 2) something that one can understand after a five minute explanation without knowing haskell
11:59:15 <Lunar^> Igloo: "ghc-6.4.1: Unable to mmap( MAP_FIXED ) for Jump Islands"
11:59:18 <ibid> i've been using the qsort, but it's a mild "oh wow"
11:59:39 <ibid> something fun with infinite lists, perhaps?
11:59:51 <psi_> i like the qsort a lot
11:59:55 <integral> simple lambda-calculus evaluator?
12:00:08 <ibid> integral: might work in another context, but not here :)
12:00:16 <dcoutts_> kombinator, yes, don't worry about that
12:00:25 <SamB> how short?
12:00:34 <ibid> SamB: something i can fit on a slide :9
12:00:41 <integral> translate a java exercise of theirs that took them several pages? :-P
12:00:48 <psi_> the infinite list of primes using eratosthenes sieve is pretty cool
12:01:00 <ibid> yes, it is
12:01:15 <ibid> also potentially too complicated without prior exposure
12:01:20 <SamB> you want something without monads?
12:01:43 <ibid> SamB: unless you can explain it in five minutes to third-year undergrads with no fp background :)
12:02:04 <ibid> how the example works, that is, not the whole underlying theory
12:03:45 <Igloo> Lunar^: Hmm, that bit of code doesn't seem to have changed. Can you file a bug with a full paste either to the GHC bugs list or as a Debian bug please?
12:05:54 <Lunar^> Igloo: I'm trying to understand the strace
12:08:04 <SamB> hmm, maybe a BF interp is a bit too much?
12:08:13 <syntaxfree> ibid: show them The Evolution of a Haskell Programmer.
12:09:18 <ibid> isn't that an inside joke?
12:10:22 <syntaxfree> it showcases many styles.
12:10:27 <ibid> true
12:10:34 <syntaxfree> @google The Evolution of a Haskell Programmer
12:10:35 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
12:10:45 <syntaxfree> I have a factorial function not yet mentioned on the Evolution.
12:11:09 <syntaxfree> fact n =  (foldl (.) id [\x -> x*k | k <- [1..n]]) 1
12:11:22 * xerox has one too
12:11:38 <xerox> syntaxfree: cool one!
12:11:52 <syntaxfree> it's a sequence of functions ;-)
12:12:12 <xerox> Mine is delimited-continuations-powered.
12:12:58 <int-e> hmm. why not map (*) [1..n] ?
12:13:17 <int-e> or at least (*k) instead of \x -> x*k
12:13:40 <syntaxfree> because I wanted to make clear I was building a sequence of functions.
12:13:40 <psi_> dcoutts_: woops, the build failed right away
12:13:55 <syntaxfree> Sequences of functions and their properties are often studied in real analysis courses.
12:13:59 <psi_> ./mk/chsDepend -iglib:cairo cairo/Graphics/Rendering/Cairo/Internal/Utilities.chs
12:14:03 <psi_> could not find {#import.chs on search path glib cairo
12:14:05 <psi_> make[1]: *** [cairo/Graphics/Rendering/Cairo/Internal/Utilities.dep] Error 1
12:14:36 <dcoutts_> psi_, it'll be a problem with bash/sh being different on osx.
12:15:02 <dcoutts_> psi_, I'll need to make mk/chsDepend use more portable shell code
12:15:14 <syntaxfree> bash being different on os x?
12:15:24 <Lunar^> Igloo: "mmap2(0x30062000, 0, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, 0, 0) = -1 EINVAL" <--- size=0, sounds like a problem
12:15:29 <syntaxfree> Mingus:~/Documents syntax$ bash --version
12:15:29 <syntaxfree> GNU bash, version 2.05b.0(1)-release (powerpc-apple-darwin7.0)
12:15:29 <syntaxfree> Copyright (C) 2002 Free Software Foundation, Inc.
12:15:38 <psi_> same version here
12:15:51 <dcoutts_> psi_, it's using /bin/sh not bash
12:15:57 <dcoutts_> well not necessarily bash
12:16:05 <psi_> sh is bash, apparently
12:16:23 <glguy> :t Functor
12:16:29 <glguy> @t Functor
12:16:30 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
12:16:30 <lambdabot> init topic-null topic-snoc topic-tail topic-tell type pl wn
12:16:42 <glguy> @type Functor
12:16:46 <lambdabot> bzzt
12:16:57 <glguy> needs to be an @search
12:17:00 <glguy>  :)
12:17:01 <dcoutts_> @index Functor
12:17:02 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
12:17:02 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
12:17:02 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:17:04 <int-e> class Functor (f::* -> *) where fmap :: (a -> b) -> f a -> f b
12:17:06 <psi_> $ sh --version
12:17:06 <psi_> GNU bash, version 2.05b.0(1)-release (powerpc-apple-darwin8.0)
12:17:07 <glguy> yeah, that
12:17:26 <Igloo> Lunar^: If you send to the ghc bugs list then Wolfgang will be able to diagnose it more easily than I
12:18:08 <dcoutts_> psi_, hmm then perhaps is a sed difference
12:18:22 <xerox> O(pow(2,N)) break!  http://www.flipcode.org/cgi-bin/fcarticles.cgi?show=63877
12:18:57 <psi_> dcoutts_: seems to be a BSD sed
12:19:17 <psi_> if there is such a thing
12:19:39 <dcoutts_> psi_, you can see in the script there is a rather hairy DEPS=... line
12:19:50 <gour> Lemmih: ghc-6.5 head does not build here :-(
12:22:06 <dcoutts_> psi_, what does this give: echo '{#import Graphics.Rendering.Cairo.Types#}' | sed 'y/./\//;s/^{#import \(qualified \)\?\([a-zA-Z1-9/]*\)#}.*/\2/'
12:22:28 <dcoutts_> on my system it gives Graphics/Rendering/Cairo/Types
12:23:02 <psi_> {#import Graphics/Rendering/Cairo/Types#}
12:23:07 <Lunar^> Igloo: it's #1261411 on sf.net ghc tracker
12:23:18 <Igloo> OK, cool, thanks
12:23:22 <psi_> wait..
12:23:41 <psi_> yes, i get that
12:23:48 <psi_> what i pasted
12:23:52 <dcoutts_> right
12:24:35 <dcoutts_> psi_, how about: echo '{#import Graphics.Rendering.Cairo.Types#}' | sed 's/^{#import \(qualified \)\?\([a-zA-Z1-9\.]*\)#}.*/\2/'
12:24:58 <psi_> {#import Graphics.Rendering.Cairo.Types#}
12:25:06 <dcoutts_> psi_, ok and this one: echo '{#import Graphics.Rendering.Cairo.Types#}' | sed 's/^{#import \([a-zA-Z1-9\.]*\)#}.*/\1/'
12:25:21 <psi_> Graphics.Rendering.Cairo.Types
12:25:32 <dcoutts_> ah ha
12:25:41 <dcoutts_> I think it doesn't like the ? bit
12:26:10 <dcoutts_> psi_, so how ahout: echo '{#import Graphics.Rendering.Cairo.Types#}' | sed 'y/./\//;s/^{#import \([a-zA-Z1-9/]*\)#}.*/\2/'
12:26:34 <psi_> sed: 1: "y/./\//;s/^{#import \([ ...": \2 not defined in the RE
12:26:36 <psi_> :-)
12:26:44 <dcoutts_> meep
12:27:00 <dcoutts_> my fault
12:27:22 <dcoutts_> echo '{#import Graphics.Rendering.Cairo.Types#}' | sed 'y/./\//;s/^{#import \([a-zA-Z1-9/]*\)#}.*/\1/'
12:27:27 <dcoutts_> try that
12:27:43 <psi_> Graphics/Rendering/Cairo/Types
12:27:48 <dcoutts_> yay
12:28:12 <dcoutts_> ok just hack the mk/chsDepend.in with that sed line
12:28:22 <dcoutts_> I'll update it for the next release candidate
12:28:22 <kosmikus> what are you trying to do?
12:28:41 <psi_> installing gtk2hs in os x
12:28:45 <dcoutts_> kosmikus, it was a RE line that bsd sed didn't like
12:28:50 <kosmikus> I see
12:29:01 <kosmikus> so, you don't need to match qualified?
12:29:04 <dcoutts_> bsd sed doesn't accept {thing}?
12:29:21 <dcoutts_> optional things
12:29:39 <dcoutts_> perhaps \(qualified \|\) would work
12:30:13 <dcoutts_> psi_, does this work: echo '{#import Graphics.Rendering.Cairo.Types#}' | sed 's/^{#import \(qualified \|\)\([a-zA-Z1-9\.]*\)#}.*/\2/'
12:31:08 <kosmikus> strange
12:31:25 <psi_> no, {#import Graphics.Rendering.Cairo.Types#}
12:31:25 <kosmikus> \(qualified \)* would be safe in this context, though
12:31:38 <psi_> do I need to reconfigure or something? i got the same error
12:32:18 <dcoutts_> kosmikus, oh yes good point
12:32:39 <dcoutts_> psi_, yes you need to reconfigure after editing the .in version of the script
12:33:03 <dcoutts_> psi_, ok one final version then: echo '{#import Graphics.Rendering.Cairo.Types#}' | sed 's/^{#import \(qualified \)*\([a-zA-Z1-9\.]*\)#}.*/\2/'
12:33:28 <kosmikus> is there no GNU sed for BSD?
12:33:39 <psi_> dcoutts_: Graphics.Rendering.Cairo.Types
12:33:46 <dcoutts_> psi_, yay. Ok thaks.
12:35:11 <psi_> should I use that line instead?
12:36:23 <Lunar^> Igloo: we really need wolfgang, it seems :) I'm trying to figure out why we have "m" = "n" in Linker.c:ocAllocateJumpIslands
12:36:51 <Lunar^> Igloo: the piece of code is only run with USE_MMAP
12:37:03 <kosmikus> ah, and maybe \{0,1\} works instead of \? on BSD ...
12:37:05 <Lunar^> Igloo: might be a temporary fix to disable it
12:37:13 <kosmikus> dcoutts_, psi_ ^^
12:37:52 <psi_> i don't know if i messed up...
12:37:53 <psi_> ./mk/chsDepend -iglib:cairo cairo/Graphics/Rendering/Cairo/Internal/Utilities.chs
12:37:57 <psi_> ./mk/chsDepend: line 35: unexpected EOF while looking for matching ``'
12:37:59 <psi_> ./mk/chsDepend: line 60: syntax error: unexpected end of file
12:39:10 <psi_> this is unknown territory for me, i'm just doing what you're telling me (i hope) :)
12:41:15 <dcoutts_> psi_, hmm line 35 is: DEPNAME=`echo "$DEPDIR/$DEP" | $SED 's%\.//*%%'`;
12:41:29 <gour> does haskelldb work with sqlite3?
12:41:38 <psi_> i haven't touched that line
12:41:47 <dcoutts_> psi_, I know
12:41:56 <psi_> line 28 looks like this now: | $SED 'y/./\//;s/^{#import \([a-zA-Z1-9/]*\)#}.*/\1/';
12:42:13 <dcoutts_> psi_, you could try changing it to: DEPNAME=$(echo "$DEPDIR/$DEP" | $SED 's%\.//*%%');
12:42:44 <dcoutts_> psi_, you line 28 looks fine
12:42:48 <dcoutts_> you/your
12:43:19 <psi_> ok, one sec
12:43:59 <psi_> uhm..
12:44:12 <psi_> ./mk/chsDepend: line 27: unexpected EOF while looking for matching ``'
12:44:38 <psi_> same error on line 60
12:44:49 <psi_> (same as before)
12:44:53 <dcoutts_> psi_, oh!
12:45:04 <dcoutts_> psi_, it is a problem with a missing '`' on line 28
12:45:23 <dcoutts_> it's:  | $SED 'y/./\//;s/^{#import \([a-zA-Z1-9/]*\)#}.*/\1/'`;
12:45:30 * xerox points dcoutts_ to #haskell-overflow to a Gtk2Hs-related talk :)
12:45:46 <dcoutts_> note the ` char justbefore the ; and after the end og the '' string
12:45:52 <dcoutts_> xerox, oh yeah, sorry
12:46:14 <xerox> I didn't explain myself well, we are talking of Gtk2Hs there too :-)
12:46:27 <xerox> I didn't mean to stop you from talking here, sorry.
12:46:31 <psi_> oh, ok
12:46:36 <dcoutts_> xerox, oh I thought you meant psi_ and I were flodding #haskell with our debugging :-)
12:46:56 <xerox> No problems for me with that, it gave -overflow a reason more to exist :-)
12:48:54 * dcoutts_ would like to note that a Windows installer of the first Gtk2Hs 0.9.10 release candidate is available at:
12:48:55 <dcoutts_> http://haskell.org/gtk2hs/gtk2hs-0.9.9.7.exe
12:49:01 <dcoutts_> md5sum (d6d4afa729df3ca794f9a0dc816ef7a6)
12:52:15 <xah> basic question: when i do â€œadd2 = (\x -> x + 2)â€ to ghci, it says parse error on input "=". What's up?
12:54:12 <int-e> xah: that's not an expression
12:54:31 <int-e> xah: you can do let add2 = (\x -> x + 2) in add2 4
12:54:33 <kosmikus> xah: you can say "let add2 = ..."
12:54:45 <int-e> xah: but you can not declare new functions like that in ghci
12:54:50 <xah> int-e: it's from haskell-demo
12:54:53 <kosmikus> well, you can
12:55:25 <xerox> Yes, use: let <name> <args> = <expr>
12:55:58 <xerox> or even: let <name> <args> | <guard> = <expr> | .. | otherwise = <expr>
12:56:26 <int-e> xah: if you want to test larger haskell programs, you better create a file containing the declarations and then :l(oad) it in ghci (there is also :r(eload) which reloads the last file that was loaded)
12:57:17 <xah> so it can be used in a source file, but not in ghci? ... ok. But why's ghic has these differences? i mean, after all, it's legal haskell code?
12:57:30 <icb> has anyone here created a new account on b9 lately?
12:58:10 <xerox> xah: GHCi lets you introduce new bindings with the 'let' syntax.
12:58:19 <gzl> dons: hey. had some questions for you. mind pinging me when you're around? thanks
12:58:29 <xah> xerox: ok. thanks.
12:58:50 <icb> the account registration appears broken, hence no search
13:11:50 <bringert> Igloo: if my build of registerised 6.4.1 on amd64 works (still compiling...), I'll need to rebuild it again using itself to get a more efficient GHC, right?
13:12:47 <Igloo> No, as the GHC you end up with is a stage 2 GHC
13:13:05 <bringert> ah, ok
13:37:37 --- mode: ChanServ set +o SyntaxNinja
13:37:54 <SyntaxNinja> -o SyntaxNinja
13:43:01 <psi_> $ ./nymphaea
13:43:01 <psi_> Bus error
13:43:04 <psi_> :(
13:43:58 <sieni> i.e. failure to provide public transportation
13:45:32 <psi_> yeah, for all i know. not a very descriptive error message :)
13:50:07 <dcoutts> psi_, oh that's a shame.
13:50:16 <dcoutts> psi_, do any of the other cairo demos work?
13:50:36 <psi_> where are they?
13:50:48 <dcoutts> psi_, demos/*
13:50:57 <dcoutts> psi_, after installing do: make installcheck
13:51:02 <dcoutts> it builds all the demos
13:51:19 <dcoutts> or maybe it's just demo/*
13:51:45 <dcoutts> the demo/cairo/StarAndRing.hs one is a good start for cairo
13:52:04 <dcoutts> psi_, so you've gto Gtk+ 2.8.x on OS X? I'm suprised.
13:53:03 <psi_> yep
13:53:40 <dcoutts> psi_, oh, ok. great.
13:53:57 <dcoutts> psi_, the demo/cairo/StarAndRing.hs is a pure cairo demo. It doesn't use Gtk.
13:55:21 <psi_> it works
13:56:02 <dcoutts> and the other two cairo demos?
13:56:12 <dcoutts> the text one also does not use gtk
13:56:24 <dcoutts> and the third one does use gtk
13:56:45 <psi_> text works, the other one gives me bus error
13:56:54 <dcoutts> hmm
13:57:12 <psi_> could it be because of gcc 4.0?
13:57:15 <dcoutts> do other gtk probs work?
13:57:18 <dcoutts> psi_, possibly
13:57:24 <dcoutts> probs/progs
13:57:28 <psi_> one sec
13:57:35 <dcoutts> eg the gtk-demo program
13:57:51 <dcoutts> with that try opening the colour selector dialog
13:58:01 <dcoutts> I know that uses cairo
13:58:30 <psi_> yep, that works
13:59:11 <psi_> i did not specify -f-via-C. would it still matter?
14:00:20 <dcoutts> if you did not override the flags with ./configure -with-hcflahs=... then the default was -O and that iplies -fvia-C
14:00:27 <dcoutts> iplies/implies
14:00:30 <psi_> ah
14:01:55 <psi_> i'll try to recompile
14:04:46 <dcoutts> psi_, you can get it to build faster if you use ./configure --with-hcflags=-fvia-C
14:05:13 <dcoutts> since that'll turn off optimisations but leave it using via-C (rather than -fasm)
14:06:21 <psi_> I did --with-hcflags="-O0 -fvia-C"
14:06:38 <psi_> is -O0 redundant?
14:07:05 <dcoutts> the -O0 is indeed redundant
14:07:10 <dcoutts> it's the default
14:07:38 <psi_> mkay
14:12:53 <xah> how to apply a anonymous function? e.g. â€œ\x -> x + 2â€
14:16:29 <dcoutts> xah, like so...
14:16:38 <dcoutts> @eval (\x -> x + 2) 1
14:16:40 <lambdabot> 3
14:16:48 <dcoutts> or ...
14:16:56 <dcoutts> @eval let f = \x -> x + 2 in f 1
14:16:58 <lambdabot> 3
14:17:43 <xah> thanks. it would be neat to have it in the haskell-demo page
14:18:34 <xah> that is, add it to: http://www.haskell.org/hawiki/HaskellDemo
14:19:20 <sieni> @eval (2 +) 1
14:19:22 <lambdabot> 3
14:19:54 <thebug> @yow
14:19:55 <lambdabot> ... I'm IMAGINING a sensuous GIRAFFE, CAVORTING in the BACK ROOM
14:19:55 <lambdabot> of a KOSHER DELI --
14:32:06 <palomer> whe was interested in creating tablatures from midi files?
14:34:31 <basti_> hmm
14:46:27 <psi_> dcoutts: the difference in build time between optimized and unoptimized builds is really not noticable under os x
14:46:37 <psi_> i'm still compiling :S
14:48:53 <dcoutts> psi_, heh, ok
14:49:09 <psi_> hm..
14:49:18 <psi_> $ ./nymphaea
14:49:18 <psi_> nymphaea: Cannot initialize GUI.
14:49:24 <dcoutts> is X11 running?
14:49:37 <psi_> ah, i forgot to set DISPLAY
14:49:40 <dcoutts> that error means it could not find the X server
14:49:53 * dcoutts thought that worked autoagically on OS X
14:50:01 <psi_> Bus error :(
14:50:05 <psi_> not in Terminal.app
14:50:17 <dcoutts> do the other gtk demos work?
14:50:22 <dcoutts> how about hello world?
14:51:18 <psi_> nope
14:51:26 <dcoutts> bus error again?
14:51:36 <psi_> yeah
14:52:00 <dcoutts> so it's getting a bus error when contacting the X server?
14:52:08 <psi_> it appears so
14:52:21 <dcoutts> try adding debug aoutput before and after the initGUI call in the hello world app
14:53:01 <dcoutts> and it's not a failure to call the function since we know it works in the case that it cannot contact the X server! :-)
14:53:23 <SyntaxNinja> for recursive modules, is it necessary to use a hi-boot file on both of them, or just one?
14:53:33 <psi_> before
14:53:33 <psi_> after
14:53:33 <psi_> Bus error
14:53:35 <psi_> :)
14:53:44 <dcoutts> psi_, ah ok.
14:54:15 <psi_> i'll try some more
14:54:30 <dcoutts> psi_, lets move to #haskell-overflow
14:54:37 <psi_> ok
15:12:29 <nuffer> how does one access command line arguments to a haskell program?
15:12:44 <integral> @type getArgs
15:12:46 <lambdabot> bzzt
15:13:06 <basti_> @index getArgs
15:13:06 <lambdabot> System.Environment
15:13:17 <basti_> @type System.Environment.getArgs
15:13:18 <lambdabot> IO [String]
15:13:20 <nuffer> ah, thanks
15:13:22 <basti_> nuffer: like that.
15:16:34 <nuffer> alright, newbie question, but I have two files, why can they apparently not see each others' contents?
15:16:41 <nuffer> (two haskell source files that is)
15:18:58 <basti_> nuffer: ?
15:19:11 <basti_> ah youre talking like modules, and importing
15:19:16 <nuffer> yeah, that sort of stuff
15:19:17 <basti_> yes thats a bit restricted in haskell
15:19:20 <nuffer> sorry, I'm a real haskell newbie
15:19:24 <basti_> thats not a problem
15:19:34 <basti_> you're demonstrating that you can pose sensible questions
15:19:34 <basti_> ^^
15:19:44 <basti_> wait I'll dig up a link for you
15:19:51 <basti_> you have to do that with "modules"
15:20:10 <basti_> http://www.haskell.org/onlinereport/modules.html
15:20:13 <nuffer> thanks
15:20:21 <basti_> thats a little dry, but says it all
15:48:59 <SamB> does anyone know of any alternative implementations of ar which would produce archives compatible with i386-linux?
15:49:43 <SamB> or of a way to not have fptools/libraries build with -split-objs?
16:01:57 <dcoutts> SamB, echo "SplitObjs=NO" >> mk/build.mk
16:05:47 <SamB> dcoutts: ah, thanks ;-)
16:07:04 <dons> gzl, pong
16:08:01 <dons> @seen joelr
16:08:02 <lambdabot> I saw joelr leaving #haskell 7 hours, 13 minutes and 33 seconds ago.
16:09:18 <dons> @seen Lemmih
16:09:19 <lambdabot> I saw Lemmih leaving #haskell 2 hours, 32 minutes and 41 seconds ago.
16:09:27 <dcoutts> hi dons
16:09:41 <dons> hey dcoutts! how's gtk2hs coming along?
16:09:47 <dons> should I fork off a build?
16:10:00 <dcoutts> the first release candidate is out
16:10:18 <dcoutts> it's probably got a bsd bug
16:10:28 <dcoutts> to do with sed
16:10:28 <dons> ah, ok. maybe I *should* fork a build
16:10:37 <dcoutts> fixed in the next rc
16:11:07 <Igloo> Is that dons' first law of OS software?
16:11:19 <dons> hehe
16:12:02 <dons> yes, "your code probably has a bsd bug to do with sed" -- dons law
16:15:06 * dcoutts goes to bed
16:15:18 * dons has breakfast
16:16:34 <syntaxfree> @fact-set Breakfast Meal that usually breaks fasts.
16:16:34 <lambdabot> Fact recorded.
16:20:08 <sorje_> or breaks fast
16:28:31 <syntaxfree> @fact-set Welfare The concept of wealth redistribution fails to understand that even if $1 trillion from the 225 richest people in the world were redistributed to the poorest of the earth, this would only give them $1 a day for a year. Our focus should be on underlying structural changes and the advancement of capitalism such that wealth can be created for the poor on a sustained basis.
16:28:32 <lambdabot> Fact recorded.
16:28:43 <syntaxfree> Smaaart lambdabot :)
16:36:17 <dons> i'm not sure if a critique counts as a fact ;)
16:37:15 <stepcut> hehe
16:37:21 <stepcut> @fact girls
16:37:22 <lambdabot> I know nothing about girls.
16:37:27 <stepcut> :-l
16:37:42 <dons> maybe lambdabot should pay more attention on #haskell-blah
16:39:25 <dons> ./mk/chsDepend -iglib:gtk::mozembed mozembed/Graphics/UI/Gtk/MozEmbed/Types.chs
16:39:25 <dons> could not find {#import.chs on search path glib gtk  mozembed
16:39:31 <dons> hmm.
16:41:36 <int-e> dons: is using perl instead of sed an option?
16:42:04 <dons> int-e, in general?
16:42:10 <dons> yes, I would say
16:42:23 <dons> esp. this idiom: perl -pi -e 's/.../.../'
16:42:25 <int-e> dons: for gtk2hs and that particular problem.
16:42:57 <dons> oh, I'm not sure if this is the problem dcoutts pointed to (though maybe it is)
16:43:05 <dons> ah! but i'mm using the darcs repo, which is out of data by 12 hrs
16:43:09 <dons> that explains it.
16:43:15 <dons> out of date
16:48:54 <syntaxfree> dons: remember you wanted me to "nm" some file when I complained about problems running lambdabot?
16:49:09 <dons> right.
16:49:16 <dons> to nm | grep at least ;)
16:49:31 <syntaxfree> the error message was: Main.o: unknown symbol `___stginit_GHCziTopHandler_'
16:49:34 <stepcut> on dvorak, nm and rm are very, very close to each other...
16:49:48 <syntaxfree> what was the command you wanted me to type?
16:49:50 <stepcut> 'tis problematic at times :p
16:51:12 <dons> syntaxfree, first find your ghc libs (could be ~/lib/ghc-*)
16:51:26 <dons> then nm HSbase.o | grep stginit_GHCziTopHandler
16:52:41 <syntaxfree> ok.
16:52:49 <syntaxfree>          U ___stginit_GHCziTopHandler_
16:52:50 <syntaxfree> 0028fc74 T ___stginit_GHCziTopHandler
16:52:50 <syntaxfree> 0028fbf0 T ___stginit_GHCziTopHandler_
16:53:19 <syntaxfree> except it's not in HSbase.o, it's in libHSbase.dylib
16:53:31 <syntaxfree> a .dylib is like a .o
16:54:18 <dons> hmm, ok. let me ponder.
16:54:29 <dons> or perhaps I'll log on to a mac and try myself.
16:54:56 <syntaxfree> I can't give you access, I'm behind an odd connection.
16:55:35 <dons> no no, I have a box somewhere here.
16:55:48 <dons> i've previously run mac-a-bot on this channel from ozone's g5
16:55:55 <dons> maybe I should check it again :)
16:57:22 <dons> @seen ozone
16:57:22 <lambdabot> I saw ozone leaving #haskell 4 days, 10 hours, 42 minutes and 34
16:57:22 <lambdabot> seconds ago, and I have missed 59 seconds since then.
16:57:47 <syntaxfree> 4 days!
16:57:57 <syntaxfree> what does "missed 59 seconds" mean?
16:58:16 <syntaxfree> @seen Simon_
16:58:17 <lambdabot> I saw Simon_ leaving #haskell 5 days, 4 hours, 48 minutes and 26
16:58:17 <lambdabot> seconds ago, and I have missed 59 seconds since then.
16:58:26 <syntaxfree> @seen Simon__
16:58:26 <lambdabot> I haven't seen Simon__.
16:58:31 <dons> lambdabot is of the opinion that there is a 59 second gap in its logs when it wasn't connected to the channel
16:58:34 <dons> which may be correct, in fact
16:58:36 <syntaxfree> I see.
16:58:52 <dons> the output of @seen is probably a little verbose in fact
16:58:59 <syntaxfree> @fact-set lambdabot Lambdabot is a bot of curious opinions.
16:59:00 <lambdabot> Fact already exists, not updating
16:59:07 <syntaxfree> @fact lambdabot
16:59:08 <lambdabot> lambdabot: is female..
16:59:20 <dons> if you'd like to tweak it to produce only 1 line of output, that'd be good (after you get the bot running, of course!)
16:59:37 <syntaxfree> @fact-cons lambdabot Lambdabot is a bot of curious opinions, and
16:59:38 <lambdabot> Fact altered.
16:59:43 <syntaxfree> @fact lambdabot
16:59:44 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female..
17:01:03 <dons> ok, now maybe I can test things: $ uname -msr
17:01:03 <dons> Darwin 8.2.0 Power Macintosh
17:02:10 <syntaxfree> Mingus:/usr/local/lib/ghc-6.4.1 syntax$ uname -msr
17:02:10 <syntaxfree> Darwin 7.9.0 Power Macintosh
17:02:18 <syntaxfree> it must be running Tiger.
17:02:20 <syntaxfree> 10.4.2
17:02:26 <syntaxfree> Since I'm on 10.3.9
17:06:00 <syntaxfree> @eval let charRot r  n  = let base = (if isUpper n then 65 else 97) in if (isAlpha n) then chr (base + (mod ((ord n) - base +r) 26)) else n in map (charRot 13) "This sentence might be encrypted in ROT13 for your convenience."
17:06:06 <lambdabot> "Guvf fragrapr zvtug or rapelcgrq va EBG13 sbe lbhe pbairavrapr."
17:08:10 <dons> syntaxfree, a simple rot13 plugin would be a good intro to hacking lambdabot
17:08:38 <syntaxfree> well, I already wrote a rot13 function. I just need to learn how to make it a plugin :)
17:08:46 <dons> in fact, documenting how to do this on the wiki would be even better!
17:08:54 <syntaxfree> hmm. good idea.
17:10:06 <dons> feel free to start a "Introduction to writing lambdabot plugins" on hawiki, I'll edit and give you hints if you get started (once I fix lambdabot on the  mac for you ;)
17:10:25 * dons enjoys hacking on the mac, as it feels so bsd-ish
17:10:36 <syntaxfree> good project.
17:10:41 <syntaxfree> will do :)
17:12:27 <dons> syntaxfree, where would `make' be installed on a mac?
17:12:33 <dons> I think i'm missing some elements in my $PATH
17:12:48 <syntaxfree> Mingus:~/lambdabot syntax$ which make
17:12:59 <likens> bubelah:~/lang+tools/haskell/monads_sge/examples sge$ type make
17:13:00 <likens> make is /usr/bin/make
17:13:10 <syntaxfree>  /usr/bin/make
17:17:59 <dons> excellent, cheers guys
17:18:39 <dons>  it was being hidden by another gmake in my path
17:19:14 <syntaxfree> fink installs its own versions  of stuf like tar sometimes.
17:19:25 <sheriff> How do I express 'to the power of' in haskell?
17:19:30 <syntaxfree> maybe there are differences between the gnu tar and the bsd tar, but it's annoying.
17:19:37 <syntaxfree> sheriff there are three ways.
17:19:45 <syntaxfree> @type (^)
17:19:46 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
17:19:58 <dons> @eval 2 ^ 5
17:20:00 <lambdabot> 32
17:20:23 <syntaxfree> @type (^^)
17:20:25 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
17:20:28 <syntaxfree> @type (**)
17:20:29 <lambdabot> forall a. (Floating a) => a -> a -> a
17:20:30 <syntaxfree> look.
17:20:37 <syntaxfree> @eval 2^8
17:20:39 <lambdabot> 256
17:20:41 <syntaxfree> but..
17:20:45 <syntaxfree> @eval 2^0.5
17:20:46 <lambdabot> Add a type signature
17:20:52 <sheriff> ok
17:20:54 <syntaxfree> in that case, you need (**)
17:20:59 <syntaxfree> @eval 2**0.5
17:21:01 <lambdabot> 1.4142135623730951
17:21:13 <syntaxfree> @eval 2^^(1/3)
17:21:14 <lambdabot> Add a type signature
17:21:17 * sheriff is using Haskell to check his sequence homework, and, to be honest, there's very very little that needs to be changed in converting my prose answers to haskell :)
17:21:34 <syntaxfree> :)
17:21:56 <dons> sheriff, cool!
17:22:08 <dons> sheriff, you should add yourself to:
17:22:09 <dons> @map
17:22:10 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
17:22:13 <syntaxfree> it's the first time I actually get to answer a newbie question.
17:22:15 <dons> we don't have many .cz people :)
17:22:23 <sheriff> I'm doing the first introductory module to a maths degree by correspondence
17:22:28 <dons> @karma+ syntaxfree
17:22:29 <lambdabot> syntaxfree's karma raised to 1.
17:22:41 <sheriff> And the stuff I've used programming I breeze through, the other stuff is hard
17:22:46 <dons> sheriff, have you seen "The Haskell Road to Maths and Logic"?
17:22:55 <syntaxfree> dons: I haven't!
17:22:55 <sheriff> dons: Nope, still working through the gentle guide
17:22:59 <dons> it's a text book based on the premise that you can do maths in haskell with a minimum of fuss
17:23:14 <dons> @google "The Haskell Road to Maths and Logic"
17:23:15 <sheriff> dons: I'm not really from .ch, it's just I find the fact my host says 'couch' to be funny ;-)
17:23:16 <lambdabot> No result found.
17:23:16 <syntaxfree> sheriff: I tend to prefer Hal Daume's "Yet another Haskell tutorial".
17:23:28 <sheriff> syntaxfree: oh, wait, if I'm honest, I think that's what I'm reading :P
17:23:37 <sheriff> Sorry, I've been working flat out for about 20 hours, my brain is fried :)
17:23:40 <syntaxfree> I find it's gentler than the Gentle ±IIntroduction.
17:23:43 <syntaxfree> @google htut
17:23:45 * sheriff checks
17:23:45 <lambdabot> http://www.isi.edu/~hdaume/htut/
17:23:57 <dons> oh, sorry, I really did read '.cz' for some reason. not .ch. but you can still add your details :)
17:24:25 <sheriff> Ah yes, I'm using YAHT
17:24:34 <sheriff> dons: fair enough
17:24:34 <dons> hmm, syntaxfree, another plugin. map domain names to their countries
17:24:49 <syntaxfree> hmm.
17:24:51 <dons> i.e. @whereis .ch
17:24:52 <syntaxfree> that's easier :)
17:25:14 <gzl> dons: hey
17:25:29 <gzl> dons: I was curious if you had looked at MSH (in light of that functional shell thing you had written up)
17:25:32 <syntaxfree> dons: incidentally, how would you do it?
17:25:40 <syntaxfree> MSH is object-oriented.
17:25:46 <syntaxfree> Some people are comparing it to Ruby.
17:25:49 <dons> syntaxfree, just keep a Map String String in the plugin state, and the `process' would do a Map.lookup
17:25:56 <sheriff> wooh, autrijus is on it
17:25:57 <dons> MSH, ?
17:26:09 <syntaxfree> MSH = Monad Shell.
17:26:13 <syntaxfree> the new shell by Microsoft.
17:26:21 <dons> right, I know about this.
17:26:33 <dons> but thought the 'monad' was just for show, and not actually FP?
17:26:45 <syntaxfree> it's just a title.
17:26:56 <syntaxfree> maybe it's inspired in Leibniz's monads.
17:27:53 <sheriff> dons: It won't let me add myself, but, I'm the same as dcoutts
17:28:09 <syntaxfree> sheriff: you need a hawiki account.
17:28:10 <dons> ah! welcome then :)
17:28:14 <syntaxfree> It's easy to get one.
17:28:31 <dons> click on 'UserPreferences', set a name and passwd, refresh, edit
17:28:47 <sheriff> syntaxfree: Right now this very second, I'm a little busy, but I'll be back when I have time to dive into haskell again, which should be next week
17:29:21 <syntaxfree> sheriff: what kind of sequence exercises are you doing?
17:30:22 <sheriff> syntaxfree: Oh, very trivial ones
17:30:23 <dons> mac people: wheree would I get libreadline.5.0.dylib?
17:30:24 <sheriff> for example:
17:30:46 <syntaxfree> in my box, it's /usr/local/lib
17:30:55 <syntaxfree> er, /usr/local/lib/ghc-6.4.1
17:31:03 <syntaxfree> it's where the .pkg installer for ghc 6.4.1 put it.
17:31:17 <sheriff> eg: Consider the following geometric sequence: 10, 14, 19.6, 27.44; write down a recurrence system that describes this sequence
17:31:35 <sheriff> syntaxfree: It's a beginner's course
17:31:59 <syntaxfree> take logs ;-)
17:32:21 <sheriff> This bit I'm finding easy. Simplifying algebraic expressions, however, having precisely 0 practice/experience/whatever
17:32:27 <sheriff> was challenging
17:32:45 <dons> syntaxfree, but I don't have access to the installer, I'm just using the .bz2 ghc. can I just install libreadline from somewhere? (I guess: yes)
17:33:10 <syntaxfree> I don't understand.
17:33:32 <sheriff> dons: Do you have darwinports?
17:33:33 <syntaxfree> are you asking if you can copy libreadline from somewhere to the appropriate folder for your own ghc?
17:33:58 <dons> i'm just borrowing this machiiine, so don't want to go installing anything in /usr/local if possible
17:34:01 <sheriff> dons: http://www.justatheory.com/computers/os/macosx/libreadline.html
17:34:06 <sheriff> dons: A complete solution :)
17:34:27 <dons> syntaxfree, more if I can grab the src and build it from somewhere
17:34:58 <dons> ah, ok. that looks more like it. cheers sheriff
17:35:27 <syntaxfree> the source?
17:35:39 <syntaxfree> hmm. I don't know. I don't have the ghc sources.
17:35:46 <dons> $ curl -O ftp://ftp.gnu.org/pub/gnu/readline/readline-5.0.tar.gz
17:35:48 <syntaxfree> I can send you whatever .dylib you need, though.
17:35:56 <dons> no no, it's ok. i'm on my way now :)
17:36:28 <gzl> dons: it's not exactly functional, but it does show some influence
17:36:43 <gzl> dons: it uses first class functions fairly extensively
17:36:43 <dons> ah, ok. interesting. do you have a url?
17:36:47 <dons> !
17:36:48 <gzl> and you can define map/fold and such
17:36:55 <gzl> (I don't think they're built in)
17:36:58 <gzl> there's some neat stuff
17:36:59 <dons> oh, cool. should definitely link to it then
17:37:06 <gzl> http://arstechnica.com/guides/other/msh.ars
17:37:22 * dons happily compiles readline
17:37:39 <gzl> it's generally passing objects through pipes and such
17:37:49 <gzl> so it does have higher level analogues of some of those features
17:37:55 <gzl> anyway, you can check it out in the article
17:39:06 <dons> chers
17:39:28 <gzl> it's like a mishmash of OO, SQL, Unix shell syntax, and FP
17:39:47 <syntaxfree> I've seen it compared to Ruby.
17:39:53 <gzl> I don't know Ruby, so I can't say.
17:40:01 <syntaxfree> also to "Python shell" projects.
17:40:11 <syntaxfree> I did look into Ruby once. It's very object-oriented.
17:40:18 <gzl> I could see that. though I don't know if Python has the databasey stuff.
17:40:23 <SamB> I don't think Ruby has SQLish parts...
17:40:32 <syntaxfree> say, a loop is started as  3.to(5){i->print i}
17:40:46 <SamB> Python definately does not...
17:40:54 <gzl> yeah, I didn't think so.
17:41:11 <syntaxfree> Ruby is making huge inroads as a web backend language.
17:41:18 <gzl> really? I thought Python was.
17:41:27 <syntaxfree> Ruby is all the rage these days.
17:41:31 <gzl> really.
17:41:33 <syntaxfree> @google Ruby on Rails
17:41:34 <lambdabot> http://www.rubyonrails.org/
17:41:39 <gzl> yeah, I know that project
17:41:47 <gzl> I didn't realize Ruby was so popular
17:42:00 <syntaxfree> it's not PHP yet, but it's certainly stronger than Python in that particular market.
17:42:01 <gzl> what's the deal with Perl 6?
17:42:06 <gzl> ok.
17:42:16 <syntaxfree> a Perl 6 compiler was written in Haskell, it seems.
17:42:54 <stepcut> syntaxfree: yeah, it can also turn perl6 code into javascript or perl5 code now I think
17:43:05 <gzl> yeah, I know about pugs
17:43:15 <gzl> but they're changing Perl 6 a *lot*
17:43:21 <syntaxfree> into javascript? ooh.
17:43:39 <gzl> more like *the* Perl 6 compiler was written in Haskell :)
17:43:59 <gzl> it's not an alternative, it's the main thing
17:44:10 <gzl> and the only thing
17:44:33 <stepcut> maybe they will keep tweaking perl, until perl6 = ghc6
17:44:40 <stepcut> then I might use it..
17:45:42 <SamB> stepcut: but I want to use ghc7!
17:46:12 <syntaxfree> someone needs to formulate a variation of Greenspun's Tenth Law for Haskell.
17:46:52 <glguy> what is the orignal law?
17:47:25 <stepcut> SamB: I still haven't finish beating all the levels in ghc6
17:48:45 <SamB> stepcut: when you do, will they release ghc7?
17:48:51 <syntaxfree> glguy: it's something along the lines of "Every sufficiently complicated program contains an informally specified implementation of half of Common Lisp"
17:49:04 <SamB> syntaxfree: which half?
17:49:19 <syntaxfree> that is a fine question.
17:49:19 <stepcut> SamB: well, they released ghc6 before I finished ghc5, so I don't think they base their releases on me
17:49:25 <SamB> and isn't that like twice as much LISP as you need?
17:49:50 <SamB> how do you find the levels?
17:50:31 <stepcut> SamB: well, I am currently on the Arrows level -- I am getting pretty good, but I haven't defeated Arrow based GUI's yet
17:50:58 <SamB> I think Arrows are a red herring
17:51:04 <SamB> or at least, they can be
17:51:16 <stepcut> Indeed
17:51:26 <stepcut> but sometimes they are nice
17:52:07 <stepcut> For example, I use them in sometimes but not others when using HXT (haskell xml toolbox)
17:56:38 <SamB> I had heard that they were sometimes nice for HTML stuff
17:57:43 <glguy> I heard that Goodie Good was a witch
18:02:15 <dons> morning ChronoWiz
18:02:57 <ChronoWiz> morning dons
18:03:15 <dons> you should add your spot to:
18:03:18 <dons> @map
18:03:19 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
18:03:20 <dons> :)
18:06:46 <sethk> damn.  I just had a phone interview for a job in California and I think they are going to hire me.
18:06:53 <sethk> I hate california
18:07:06 <gzl> you realize that job offers aren't binding :)
18:07:22 <sethk> yes, I know, but it's a two month temporary and is sort of interesting
18:07:57 <dons> sethk, did you see SimonM's soln for the borken yi issue?
18:08:14 <sethk> dons, I just started looking at my email and noticed there is one from him.
18:08:16 <sethk> let me read it.
18:08:25 <dons> and I replied, saying it works :)
18:08:38 <dons> summary: rebuild hs-plugins with the latest cabal, *then* build yi
18:08:49 <sethk> ah, that's not at all terrible
18:08:56 <sethk> dons, should I pull again from darcs?
18:08:58 <ChronoWiz> california for two months would be ok
18:09:06 <dons> the key thig is that stuff goes bad if you bulid hs-plugins, then update Cabal, then try to build yi
18:09:20 <sethk> ChronoWiz, I know, I just like to complain  :)
18:09:21 <dons> sethk, no. just rebuilding hs-plugins should be enough.
18:09:36 <sethk> dons, I mean, though, are there enough changes to pull again in yi?
18:09:56 <dons> hmm. maybe. darcs  pull is cheap ;)
18:10:06 <sethk> dons, sure, only takes a few seconds.
18:10:26 <sethk> that cabal update thing explains why others didn't see it.
18:10:41 <dons> yep.
18:10:59 <dons> I suspect this is also what explains Lemmih's mysterious hs-plugins segfault when reading package.confs
18:11:22 <sethk> certainly possible, same general area of the code I'd imagine
18:11:35 <dons> I think he probably updated Cabal, but then didn't update hs-plugins. so hs-plugins is calling the old interface, and this leads to badness
18:11:57 <sethk> certainly plausable
18:17:17 <SamB> hmm, I must have somehow managed to do those in the right order...
18:20:38 * SamB wonders why Cabal is using deprecated functions
18:20:51 <SamB> and modules, too!
18:21:08 <dons> SamB, darcs patch and send!
18:21:19 <dons> ;)
18:21:36 <SamB> dons: well, I'm in the fptools tree at the moment...
18:22:17 <SamB> really, I'm just trying to build stage2 without building everything under the sun in libraries...
18:22:43 <dons> hmm.
18:23:02 * dons hunts through his ghc-build box of tricks..
18:23:06 <SamB> so I can use ghci, so I can test something
18:23:26 <dons> in build.mk: GhcLibWays =
18:23:35 <dons> so you don't bother with -prof or unreg ways
18:23:36 <SamB> I will be thoroughly disappointed if I get only an unthreaded ghci...
18:23:52 <SamB> oh, so I still get all the other kinds of ways?
18:24:11 <dons> yep, particular prof which  is *slow*
18:24:58 <SamB> slow to build, you mean?
18:24:58 <dons> yep.
18:25:06 <SamB> it does seem rather slow
18:25:18 <SamB> so its nothing I messed up in the options, then, which is nice...
18:25:25 <SamB> but still, I might want it...
18:26:09 <dons> for super-happy fun try GhcLibHcOpts=-H64m -Onot -fasm
18:26:12 <Itkovian> dons: nice map!
18:26:16 <dons> :)
18:26:39 <SamB> I don't know... hmm.. I have 74 M free... I guess that *might* be super-happy...
18:26:45 <dons> also SamB, you can speed htings up a bit building inside a ramdisk
18:26:48 <SamB> after all, my big swap-fiend has been ar...
18:26:59 <SamB> dons: I don't think that works on Linux...
18:27:08 <glasser> i know there are various haskell-based editors/ides under development... are there any that currently work on OSX?
18:27:13 <dons> oh, come on ;) it has to work on linux
18:27:16 <SamB> ... ext2 is about as fast as a ramdisk anyways!
18:27:27 <dons> ah, may well be.
18:27:38 <SamB> its the unified swap/cache architecture
18:27:48 <dons> anyway, with all these tweaks, I can build libs + 2 ghc stateges in about 18 mins on a P4 3Ghz
18:28:15 <dons> glasser, hIDE/yi probably do.
18:28:17 <SamB> well, I only have a PII 450 MHz
18:28:29 <dons> oh no. ok, sit back and enjoy the view then :)
18:28:45 <dons> you really need to turn of profiling for now, i'd think
18:29:07 <SamB> how do I turn that off too?
18:29:31 <glasser> dons: yi is by you right?
18:29:49 <glasser> Hmm. How do I tell if I already have hs-plugins installed? I think I might.
18:29:49 <dons> yep.
18:29:58 <dons> ghc-pkg list plugins
18:31:01 <glasser> aha. is plugins-0.9.8 going to be new enough for yi?
18:31:29 <dons> nope.
18:31:33 <dons> @where hs-plugins
18:31:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
18:31:52 <tessier> anonymous functions are basically lambda's, correct?
18:32:04 <tessier> It seems Microsoft's new command shell, msh, supports lambdas.
18:32:09 <tessier> And first class functions.
18:32:19 <gzl> yeah.
18:32:27 <SamB> does it use authentic lambdas?
18:32:33 <glasser> 0.9.10 will be (don't need straight from vcs), right?
18:32:41 <tessier> SamB: What are "authentic" lambdas?
18:32:49 <dons> hmm. getting it from darcs is a better bet.
18:33:00 <dons> darcs get http://www.cse.unsw.edu.au/~dons/code/hs-plugins/
18:33:03 <SamB> the ones that look like the lower case letter lambda!
18:34:55 <Itkovian> tessier: you mean a shell in 'Vista'?
18:35:37 <tessier> Itkovian: Yeah. Looks like they have finally decided the old DOS COMMAND.COM isn't cutting it anymore.
18:35:52 <gzl> I think you can download it right now
18:35:54 <SamB> hmm, is it VMS that I am reminded of when I see that MSH Cmdlets all derive from a common base class?
18:35:56 <gzl> I don't think it needs Vista
18:36:05 <gzl> SamB: they don't look like lambdas. :)
18:36:16 <SamB> tessier: actually they renamed that to cmd.exe a while back
18:36:30 <Itkovian> Hmm, I don't think I'll use a mickeysoft shell.
18:36:41 <gzl> it's good
18:36:46 <Itkovian> In fact, I'm quite certain of that
18:36:54 <tessier> SamB: Wow, such innovators!
18:36:59 <gzl> haha
18:37:01 <Itkovian> gzl: sorry, but I find that hard to believe :-)
18:37:26 <SamB> looks like they stole it all from VMS and GHCi and Ruby and Python and oh, so many other countless systems...
18:37:27 <gzl> *shrug*
18:37:31 <Itkovian> and even if they have a good idea, somebody will prolly decently implement it in a real shell.
18:37:37 <gzl> I really doubt it
18:37:41 <SamB> then again, most of those systems stole so many ideas, it isn't funny either...
18:37:45 <gzl> the Unix shells are so antiquated
18:37:56 <Itkovian> gzl: they do everything i need them to.
18:38:10 <SamB> yeah, unix shells are pretty old and crusty
18:38:39 <tessier> It's funny how anything old is automatically considered bad
18:38:45 <gzl> that's not true
18:38:51 <tessier> The unix shells are still the best command shells going
18:38:51 <gzl> there are lots of old things that aren't considered bad
18:38:53 <Itkovian> this talk is really dumb
18:38:56 <gzl> they're still really crusty
18:39:05 <tessier> crusty == bad
18:39:24 <gzl> yes, but they're not bad because they're old. they're bad because there are lots of nice things they don't do.
18:39:34 <SamB> they are the most useful shells I know of, but maybe thats because they have all those nice commands to run...
18:39:39 <Itkovian> gzl: such as?
18:39:41 <gzl> also, they're not bad. they're just not as good as they should be
18:39:44 * dons grumbles about having to ranlib everything all the time on the mac
18:40:20 <Itkovian> dons: really: 'typo in readme' ... ;-)
18:40:23 <gzl> they just operate at a really low level. if you want to use regexes on the command line, for example, you have to resort to sed or awk, and those are entirely separate languages
18:40:48 <tessier> gzl: You sound just like the guy who wrote this article about msh. :)
18:41:08 <tessier> gzl: But part of the unix philosophy is to build small tools that each do their job really well and then string them together.
18:41:09 <Itkovian> gzl: caught in the act!
18:41:20 <gzl> how is that caught in the act?
18:41:22 <tessier> I think bash, sed, awk, etc. fit that model well.
18:41:30 <sethk> gzl, tessier is correct.  In fact, the newer shells do _much_ too much
18:41:35 <gzl> it's fine to use small tools
18:41:37 <Itkovian> 'sound like' 'article' 'msh'
18:42:00 <gzl> I agree with some of the points he made, what's the problem?
18:42:01 <SamB> all we need now is a tool that parses command lines really well
18:42:11 <tessier> SamB: hehehe
18:42:41 <SamB> and one to shoot people who put spaces in source trees
18:42:43 <Itkovian> omg -- mickeysoft just found out about mutexes it seems ...
18:42:50 <Itkovian> 'transactional memory'
18:43:01 <SamB> Itkovian: they've had mutexes, haven't they?
18:43:13 <SamB> transactional memory is better, at least when it is the simple kind
18:43:16 <dons> well, they keep hiring haskell programmers, it's going to have some effect after a while, right?
18:43:17 <Itkovian> SamB: I'm listening to a keynote talk at ACSAC
18:43:34 <gzl> I mean, you're welcome to disagree with me and the article, but you haven't even read the article and are content to simply whine about Microsoft
18:43:41 <Itkovian> It's an intel guy who seems to be sleeping with mickeysoft
18:43:44 * dons has now bulid readline, gmp, ghc and darcs on a mac :D
18:43:51 <Itkovian> gzl: correct :-)
18:44:32 <Itkovian> it's 4 am for me, and I'm not in any particular mood to think things through ...
18:44:58 <SamB> is this new Windows going to support old programs, or just new ones?
18:44:58 <dons> @localtime Itkovian
18:45:02 <gzl> well, this is a waste of time for me, so bbl
18:45:05 <tessier> This article is funny in that it keeps comparing MS to Linux like MS is finally trying to catch up to where Linux has been for years.
18:45:20 <gzl> tessier: they are, the old shell blew
18:45:22 <Itkovian> thanks for summarizing it tessier
18:45:26 <SamB> tessier: its true!
18:45:30 <tessier> segphault@sbcglobal.net is the author
18:45:38 <Itkovian> dons: I'm in singapore
18:45:43 <SamB> "what took them so long?", is my response
18:45:54 <tessier> http://arstechnica.com/guides/other/msh.ars/
18:46:00 <tessier> That is the url to the whole article
18:46:03 <Itkovian> hoping that I won't dangle from a noose wednesday because some junk uses my bag to transport his goodies
18:46:03 <SamB> and "can I have it, only without .net?"
18:47:07 <SamB> oh wow, this much and they don't even have stderr!
18:47:33 <gzl> yeah that was odd
18:47:42 <SamB> and if you redirect to a file, it doesn't serialize, just prints...
18:47:47 <gzl> the conditional syntax is weird too
18:47:48 <SamB> thats like bad!
18:47:56 <gzl> there are definitely some oddities
18:48:08 <SamB> conditionals remind me of find syntax
18:48:15 <SamB> or test, maybe...
18:48:31 <jgilbert> evening all
18:48:37 <gzl> I would have preferred using > and < for comparisons and >> and << for redirection
18:48:54 <Cale> hello jgilbert
18:49:12 <jgilbert> I'm trying to write take using guards and I'm stuck
18:49:30 <Cale> okay
18:49:34 <SamB> I would prefer <- for redirection
18:49:38 <jgilbert> take2 :: Int -> [a] -> [a]
18:49:39 <jgilbert> take2 n ys
18:49:39 <jgilbert>           | (n, ys) == (0, ys)    = []
18:49:39 <jgilbert>           | (n, ys) == (n, [])    = []
18:49:40 <jgilbert>           | (n, ys) == (n, ys)    =  ys
18:49:41 <Cale> where do you get stuck?
18:49:46 <jgilbert> the last line
18:49:53 <jgilbert> I need an 'else' clause
18:50:03 <Cale> "otherwise" or "True" would work
18:50:15 <SamB> why aren't you using pattern matching?
18:50:22 <jgilbert> Cale: you're kidding
18:50:34 <jgilbert> SamB: I already wrote that version
18:50:37 <dons> nmm, those comparisons are a bit odd though.
18:50:44 <SamB> jgilbert: what was wrong with it?
18:50:50 <jgilbert> the goal is to implement it in as many ways as possible
18:51:02 <jgilbert> first.hs:19:20:
18:51:02 <jgilbert>     No instance for (Eq a)
18:51:02 <jgilbert>       arising from use of `==' at first.hs:19:20-21
18:51:03 <jgilbert>     Probable fix: add (Eq a) to the type signature(s) for `take2'
18:51:03 <jgilbert>     In a pattern guard for
18:51:04 <jgilbert>        the definition of `take2':
18:51:04 <jgilbert>         (n, ys) == (n, ys)
18:51:06 <jgilbert>     In the definition of `take2':
18:51:08 <jgilbert>         take2 n ys
18:51:10 <jgilbert>                 | (n, ys) == (0, ys) = []
18:51:12 <jgilbert>                 | (n, ys) == (n, []) = []
18:51:14 <jgilbert>                 | (n, ys) == (n, ys) = ys
18:51:17 <jgilbert> it fails to load
18:51:28 <Cale> ah, you shouldn't compare ys to anything
18:51:28 <dons>  | n == 0 = [] ; | ys == [] ; | otherwise = ys
18:51:36 <Cale> null ys is okay
18:51:41 <Cale> but not ys == []
18:51:52 <Itkovian> jgilbert: Can't you just use n==0, null ys and otherwise?
18:52:17 <jgilbert> dons: interesting point
18:52:23 <Cale> um, also, I don't think this does the same thing as 'take'
18:52:33 <Itkovian> like take2 n ys | n==0 || null ys = []   | otherwise = ys
18:52:36 <dons> and take the point about using null ys to avoid an Eq
18:52:43 <Itkovian> hmm, sorry dons
18:52:45 <Itkovian> didn't see that
18:53:03 <jgilbert> ah, yes, it doesn't do the same thing as take, the last expressions should be recursive
18:53:09 <jgilbert> but I was debugging the sucker
18:53:10 <Itkovian> jgilbert: never use ys::[a] == []
18:53:21 <glasser> Hmm. Trying to compile hs-plugins from darcs is throwing a ghc bug for me
18:53:25 <jgilbert> Itkovian: can I ask why?
18:53:31 <dons> glasser, msg me
18:53:42 <Cale> | otherwise = (head ys) : take2 (n-1) (tail ys)
18:54:26 <Itkovian> jgilbert: because that assumes that a is an instance of Eq I think
18:54:36 <Itkovian> which need not be the case.
18:55:00 <Itkovian> jgilbert: also _never_ use length (ys::[a]) == 0
18:55:09 <Cale> jgilbert: yeah, as soon as you apply == to a list, it will pick up the fact that == is only defined on lists of things which have == defined on them
18:55:11 <Itkovian> because that evaluates ys
18:55:37 <Itkovian> I seem to tell my students that every year, and still there are some who don't get it
18:55:52 <jgilbert> we just don't seem to learn
18:55:58 <Cale> hehe
18:56:14 <dons> in fact, we often use it as a trick to force a list to be evaluated, it's that bad.
18:56:16 <SamB> Itkovian: this is what we have a typesystem for!
18:56:26 <SamB> to tell us when we do stupid stuff like that
18:56:35 <syntaxfree> take n x:xs = take (n-1) xs
18:56:40 <syntaxfree> take 0 x = x
18:56:44 <syntaxfree> take _ [] = []
18:56:46 <Cale> take n (x:xs) = take (n-1) xs
18:56:47 <syntaxfree> listo :)
18:56:59 <Itkovian> syntaxfree: take 0 x = x ?
18:57:00 <Cale> don't forget the parens :)
18:57:05 <jgilbert> syntaxfree: that's the easy way
18:57:13 <SamB> heh
18:57:16 <syntaxfree> I always forget the parens in (x:xs) patterns.
18:57:21 <Igloo> That looks suspiciously like drop to me
18:57:32 <Cale> yeah, that's drop
18:57:42 <SamB> jgilbert: well, in this case, isn't it the right way? only with the proper expressions?
18:57:44 <syntaxfree> haha, yes.
18:57:45 <syntaxfree> sowwy.
18:57:48 <Itkovian> it more like x:(take (n-1) xs)
18:57:52 <Cale> take2 n ys | n == 0 = []
18:57:52 <Cale>            | null ys = []
18:57:52 <Cale>            | otherwise = (head ys) : take2 (n-1) (tail ys)
18:57:57 <Itkovian> take 0 x = []
18:58:17 <syntaxfree> nyway, take n (x:xs) ++ drop n (x:xs) = (x:xs)
18:58:26 <jgilbert> Cale: I like that, it works
18:59:07 <jgilbert> is there a way to reduce the number of calls? I'm calling head and tail separately, but I should be able to get all the info in one step
18:59:17 <jgilbert> or am I thinking too ML?
18:59:22 <SamB> jgilbert: he should have had you do factorials, then you could recreate "Evolution of a Haskell Programmer" ;-)
18:59:24 <Cale> pattern match
18:59:57 <jgilbert> SamB: there's no he, this is for fun
19:00:05 <SamB> oh
19:00:11 <syntaxfree> I have a factorial function not mentioned in "The evolution of a Haskell programmer".
19:00:20 <SamB> syntaxfree: this must be a bug!
19:00:21 <sethk> syntaxfree, NO!!!
19:00:27 <SamB> we must replace it with a flowchart now!
19:00:31 <jgilbert> By day I write research genetics software in Python
19:00:53 <syntaxfree> fact n =  (foldl (.) id [\x -> x*k | k <- [1..n]]) 1
19:00:57 <sethk> jgilbert, I'm thinking haskell is very internesting for DNA sub-sequence matching
19:01:06 <syntaxfree> I still do some stuff in Python but I'm gradually replacing it with Haskell.
19:01:17 <glasser> hmm.  upgrading GHC from 6.4 to 6.4.1 with the Mac OS X installer.  It says I should uninstall 6.4 first.  Where is the script for that?
19:01:37 <dons> @pl (foldl (.) id [\x -> x*k | k <- [1..n]]) 1
19:01:37 <lambdabot> k | k <- [1..n]
19:01:39 <jgilbert> sethk: actually, that's pretty much a solved problem. Our goal is to find significant genes given a microarray
19:01:50 <SamB> I rarely touch the stuf (Python) anymore
19:02:07 <sethk> jgilbert, I didn't mean that the problem was interesting, I meant that the Haskell solution might be interesting.  :)
19:02:14 <syntaxfree> my Python code is almost purely functional.
19:02:25 <jgilbert> now now, Python has some very nice features. It's also a common stepping stone to Haskell
19:02:33 <sethk> jgilbert, I don't know much about microarryas.  I helped some people with some genetic software about two years ago, haven't really followed it since.
19:02:33 <syntaxfree> except from the final "print" functions.
19:02:45 <sethk> I like python for many jobs
19:02:50 <jgilbert> although it's quite inefficient if your code is functional
19:02:55 <syntaxfree> the best stepping stone to Haskell is Scheme, I think.
19:02:57 <SamB> jgilbert: but it has neither types nor monads!
19:03:01 <jgilbert> function calls are too expensive
19:03:13 <dons> scheme?
19:03:13 <SamB> scheme is too off-putting, I think...
19:03:28 <syntaxfree> Scheme is extremely easy to learn.
19:03:33 <sethk> I agree with SamB.  I almost decided to give up haskell when I took a look at scheme.  :)
19:03:33 <jgilbert> SamB: Python __has__ types. Strong typing. Merely dynamic in some implementations
19:03:34 <SamB> too many functions, not enough syntax
19:03:41 <CosmicRay> syntaxfree: I'd say OCaml.
19:03:42 <syntaxfree> People are often writing complicated stuff in the first week.
19:03:48 <SamB> jgilbert: not very strong really!
19:03:51 <syntaxfree> O'Caml is statically typed.
19:03:54 <jgilbert> Scheme was a stepping stone to LISP for me
19:03:58 <SamB> and it doesn't catch things until you hit them!
19:04:06 <SamB> and not even always then
19:04:10 <sethk> it really depends on the user, of course.
19:04:10 <syntaxfree> Scheme is a lisp.
19:04:14 <sethk> what they are used to.
19:04:14 <jgilbert> SamB: well, that's dynamic typing for you
19:04:18 <sethk> syntaxfree, he knows that.  :)
19:04:25 <jgilbert> :)
19:04:32 <SamB> jgilbert: yeah, I know.
19:04:33 <syntaxfree> I tried to go to Common Lisp, but the scope rules, "funcalls" and all were annoying.
19:04:41 <syntaxfree> "defun" sounds like de-fun.
19:04:49 <SamB> but if I wanted Dynamic, I would have *said* Dynamic
19:04:49 <syntaxfree> I don't want to take away the fun in programming.
19:04:52 <CosmicRay> my favorite thing about haskell is how fast I can change my algorithms.
19:05:19 <syntaxfree> lastly, every common lisp book/tutorial I've seen is imperative.
19:05:21 <SamB> CosmicRay: yeah, the compiler always tells you what you missed!
19:05:21 <CosmicRay> syntaxfree: and that's exactly what happens when your list of operators consists of the left and right parentheses ;-)
19:05:22 <jgilbert> SamB: there are type inferencing compilers for Python
19:05:48 <syntaxfree> CosmicRay: I love the look of Scheme programs.
19:05:51 <SamB> jgilbert: do they keep me from doing stupid things or misspelling names?
19:05:54 <jgilbert> static typing is avaiblable, and if you want your code to run fast, you better use it
19:06:07 <jgilbert> SamB: yessir
19:06:11 <syntaxfree> I love writing Scheme programs as compact chunks of text.
19:06:18 <CosmicRay> jgilbert: I've never heard of this.  last I heard, there was cpython, jython, and perhaps an experimental .net interpreter
19:06:20 <syntaxfree> I don't use linebreaks even between functions.
19:06:30 <SamB> how do they keep me from doing stupid things, while still being called Python, and not, say, Pyrex?
19:06:30 <CosmicRay> syntaxfree: why aren't you using perl? ;-)
19:06:39 <syntaxfree> I don't like the look of perl.
19:06:44 <SamB> CosmicRay: too much syntax
19:06:46 <glasser> (no ideas about how to uninstall ghc 6.4 on mac?)
19:07:09 <jgilbert> CosmicRay: the .net interpreter is pretty stable. I'm thinking of Pyrex, Psyco, PyPy
19:07:35 <syntaxfree> I have a mac.
19:07:43 <syntaxfree> I should say, I use OS X.
19:07:43 <CosmicRay> jgilbert: interesting.  I switched mostly from Python to Haskell about a year ago.
19:07:47 <syntaxfree> I could have a mac and run Linux.
19:07:48 <Cale> take3 n = foldr (\x ys -> if n == 0 then [] else x : (take3 (n-1) ys)) []
19:08:01 <CosmicRay> jgilbert: apparently some of these were around then so I have no excuse ;-)
19:08:05 <syntaxfree> anyway, I had 6.2.1 from Fink.
19:08:09 <CosmicRay> jgilbert: there are a lot of pythoners and former pythoners in the haskell community.
19:08:10 <syntaxfree> and I installed 6.4.1 from the .pkg
19:08:19 <jgilbert> CosmicRay: I'd like to switch to Haskell or OCaml but we have too many students to do that
19:08:20 <syntaxfree> I am a semi-former pythoner.
19:08:20 <CosmicRay> jgilbert: and your nick sounds very familiar to me, but I can't quite place it.
19:08:35 <syntaxfree> Gilbert is the name of a very fast guitar player from some band.
19:08:35 <SamB> jgilbert: Pyrex is not Python!
19:08:37 <syntaxfree> I forget which.
19:08:42 <CosmicRay> jgilbert: you might be interested in my MissingPy library, an interface to Python from Haskell
19:08:43 <dons> we normally refer to former pythoners as 'refugees'
19:08:48 <CosmicRay> dons: haha
19:08:51 <jgilbert> CosmicRay: Through bitter experience I've found that amateurs learn Python the fastest
19:08:58 <CosmicRay> dons: what are former perlers then? ;-)
19:09:11 <SamB> jgilbert: isn't that true of most things?
19:09:19 <Cale> CosmicRay: patients
19:09:30 <dons> hmm, converts maybe? (thinking of the subtle pugs brainwashing ;)
19:09:32 <CosmicRay> Cale: ahh.  and current perlers?  *cough* autrijus *cough*
19:09:32 <jgilbert> SamB: It certainly is. The various py to C compilers are Python as well
19:09:48 <dons> he's the head brain washer!
19:09:52 <SamB> jgilbert: no, the language is totally different!
19:09:54 <CosmicRay> heh
19:09:59 <lament> python python python
19:10:00 <jgilbert> The nice thing about Python is how fast the community moves
19:10:08 <sethk> dons, who is the head brain?  and why does it need to be washed?
19:10:09 <jgilbert> SamB: Are you being sarcastic?
19:10:19 <syntaxfree> the nice thing about Python is the HUGE availability of libraries and modules.
19:10:29 <SamB> jgilbert: no, its just that you can't let the similarity of the syntax fool you.
19:10:32 <jgilbert> SamB: Pyrex is Python with optional typing
19:10:38 <SamB> Pyrex is a language all its own.
19:10:50 <syntaxfree> I don't know any readymade Haskell libs for backprop neural nets or genetic algorithms.
19:11:01 <jgilbert> mmm. That's a pretty thin argument
19:11:08 <Cale> syntaxfree: write one :)
19:11:12 <CosmicRay> syntaxfree: on the other hand, parsec kicks ass
19:11:13 <jgilbert> Pyrex is a superset of Python
19:11:18 <syntaxfree> I was writing one.
19:11:23 <syntaxfree> But it's a mess, and it doesn't use data types.
19:11:26 <CosmicRay> really, parsec is the killer app for haskell right there, imho.
19:11:29 <syntaxfree> I tend to write Haskell as if it was Lisp.
19:11:35 <syntaxfree> Everything's a list or a list of lists.
19:11:44 <Cale> syntaxfree: yeah, you end up with trouble if you do that
19:11:57 <syntaxfree> Cale: why?
19:11:58 <CosmicRay> the one thing that bugs me about haskell is its weakness with binary data.
19:12:10 <jgilbert> syntaxfree: That's how I write in every language. As long as it all fits in your head (and you don't use Perl) it works great
19:12:20 <CosmicRay> I wish that Char was 8 bits.
19:12:33 <Cale> syntaxfree: you end up with types like [[(a,[(b,[c])])]]
19:12:45 <CosmicRay> jgilbert: but to really work well, you need lazy lists.  and python's hackish way of simulating that is just not very nice.
19:12:52 <CosmicRay> jgilbert: ocaml streams or haskell lists are much nicer.
19:12:52 <SamB> CosmicRay: isn't Ptr good enough for you?
19:13:02 * SamB kids
19:13:09 <CosmicRay> heh
19:13:13 <Cale> syntaxfree: and leaning on the type system a bit helps GHC to check your code :)
19:13:31 <CosmicRay> jgilbert: is PEP3000 really going to happen?
19:13:52 <jgilbert> CosmicRay: Sometimes yes, sometimes no. One of our feature subset selection algorithms only works because it is implemented eagerly with dynamic programming
19:13:54 <Cale> syntaxfree: Ideally, you can tell almost exactly what a function is going to do based on its type signature.
19:14:16 <jgilbert> CosmicRay: After Perl 6 I'd say
19:14:18 <CosmicRay> Cale: yeah, it is surprising how often that works with Haskell.
19:14:23 <CosmicRay> jgilbert: hmm.
19:14:28 <CosmicRay> jgilbert: bummer.
19:14:33 <jgilbert> CosmicRay: why?
19:14:47 <CosmicRay> jgilbert: well, it seems that many of the nicer fp features are being removed.
19:15:09 <jgilbert> CosmicRay: exactly, put it off as long as possible
19:15:27 <CosmicRay> jgilbert: imho, Haskell is what Python should have evolved into ;-)
19:15:46 <Cale> I think that rather than removing lambda, they just ought to make it work sanely.
19:15:53 <CosmicRay> Cale: I agree.
19:16:08 <syntaxfree> removing lambda is so un-python.
19:16:09 <jgilbert> CosmicRay: I have to disagree with you there. One of Python's greatest strengths is its reflection (introspection)
19:16:15 <syntaxfree> Python for me was "all styles available".
19:16:21 <syntaxfree> One can use Python as if it was Basic.
19:16:28 <syntaxfree> or as an OO language.
19:16:30 <jgilbert> I haven't seen anything as nice outside of Smalltalk
19:16:44 <CosmicRay> jgilbert: I have used some of that.  haskell doesn't really have it, but it has other alternatives that are better.  typeclasses, for instance.
19:17:03 <CosmicRay> I believe that a lot of that in Python leads to unnecessary complexity
19:17:39 <jgilbert> CosmicRay: I'm not so sure that it's better. The ability to embed a shell in your program and interact with the objects live is incredibly powerful.
19:18:05 <dons> does it help you write correct code though?
19:18:11 <Itkovian> brb
19:18:16 <CosmicRay> jgilbert: I would like to see eval() in haskell.
19:18:19 * dons puzzles about the semantics of such a thing
19:18:25 <CosmicRay> jgilbert: I don't see the use for an exec() though.
19:18:27 <dons> @type System.Eval.Haskell.eval
19:18:30 <syntaxfree> I would like to see (eval ()) in Haskell.
19:18:32 <dons> ;)
19:18:33 <lambdabot> forall a.
19:18:33 <lambdabot> (AltData.Typeable.Typeable a) =>
19:18:33 <lambdabot> String -> [System.Eval.Utils.Import] -> IO (Maybe a)
19:18:35 <jgilbert> Fast, correct, cheap; choose two
19:18:37 <Cale> CosmicRay: dons did that
19:18:47 <CosmicRay> Cale: it's unsufficiently portable though
19:18:50 <syntaxfree> I was writing Scheme programs that write Scheme programs the second week.
19:18:55 <Cale> CosmicRay: hm?
19:18:55 <CosmicRay> not dons' fault (hello JaffaCake)
19:19:02 <dons> CosmicRay, I think you over-estimate its unportability though.
19:19:04 <jgilbert> dons: it makes bug-fixing a hell of a lot easier
19:19:05 <Cale> you mean, to other Haskell implementations?
19:19:05 <CosmicRay> Cale: you're speaking of hs-plugins, right?
19:19:08 <Cale> yeah
19:19:15 <CosmicRay> Cale: I mean to various platforms.
19:19:25 <dons> didn't you think it needed registerised ghc?
19:19:27 <Cale> oh, what's wrong with it?
19:19:40 <CosmicRay> dons: I thought it only works where ghci works.
19:19:53 <CosmicRay> afaik that is still correct ;-)
19:19:59 <Cale> doesn't ghci work basically everywhere?
19:20:02 <CosmicRay> Cale: no
19:20:04 <dons> yeah, but ghci doesn't cimply registerisation/unregisterisation
19:20:22 <dons> it needs linker support, which ghci also needs. so ghci is the sign.
19:20:25 <CosmicRay> Cale: off the top of my head, it is unsupported on AIX, alpha/linux, sparc/linux, ppc64/linux, etc.
19:20:29 <CosmicRay> dons: right.
19:20:32 <dons> but not registerisation
19:20:35 <jgilbert> CosmicRay: ghci is part of Debian, what more do you need?
19:20:36 <dons> sparc/linux should work
19:20:41 <dons> as ghci works on sparc
19:20:47 <syntaxfree> it's supported on ppc/darwin
19:20:51 <CosmicRay> jgilbert: it is built in Debian but it does not work everywhere.
19:21:11 <dons> AIX, alpha*,ppc64* won't work though
19:21:25 <CosmicRay> jgilbert: for instance, on my alpha, it does this:
19:21:30 <CosmicRay> Loading package base ... /usr/lib/ghc-6.2.2/HSbase.o: unsupported ELF format
19:21:30 <CosmicRay> ghc-6.2.2: panic! (the `impossible' happened, GHC version 6.2.2):
19:21:30 <CosmicRay>         loadObj: failed
19:21:31 <jgilbert> CosmicRay: It doesn't work on some of Debian's releases?
19:21:33 <CosmicRay> which is expected for alpha.
19:21:41 <CosmicRay> jgilbert: no, it doesn't work on some of Debian's platforms.
19:22:11 <jgilbert> CosmicRay: just to be clear, you mean when using the Debian distro on those platforms?
19:22:36 <CosmicRay> jgilbert: well, it is not debian-specific that it is broken there.
19:22:40 <dons> I'd expect plugins/eval to work on: x86* powerpc amd64* and sparc
19:22:47 <dons> oh, and ia64
19:23:12 <jgilbert> CosmicRay: yes, but that doesn't mean that the DDs haven't patched it to make it limp along
19:23:28 <CosmicRay> jgilbert: they haven't.
19:23:53 <CosmicRay> jgilbert: igloo (debian maintainer) is fairly well-connected in this community and hangs out on this channel.  it would be in upstream if he knew of any such patches.
19:24:09 <jgilbert> CosmicRay: OK. I've never run into a problem on any platform. Good to know what to watch out for
19:24:14 <dons> the linker for alpha isn't remotely working
19:24:16 <CosmicRay> knowing him, he'd probably refuse to include them unless they were included upstream first anyway ;-)
19:24:52 <CosmicRay> jgilbert: really, it doesn't bug me all that much.  ghc itself works, just not ghci, and there's always hugs.
19:25:10 <CosmicRay> jgilbert: but on the platforms where ghci doesn't work, things such as template haskell and hs-plugins also don't work.
19:25:31 <CosmicRay> th doesn't bug me but hs-plugins is so cool I would love to use it.
19:25:49 <jgilbert> I can understand. That __really__ sucks
19:25:50 <SamB> because TH uses the bytecode interpreter and hs-plugins uses the loader...
19:26:11 <dons> well, TH uses the loader as well
19:26:12 <SamB> well, actually TH uses the loader too...
19:26:16 <SamB> yeah
19:26:24 <dons> if you ever see those "Loading package base... " msgs while compiling seomthing with TH in it
19:27:02 <SamB> it occured to me just after I said that that it needed to load code too...
19:27:10 <dons> :)
19:27:19 <jgilbert> Well, thank you all for a very refresahing evening
19:27:24 <dons> it's cool that we can even mix compiled and interpreted code
19:27:25 <jgilbert> I shall return
19:27:31 <jgilbert> good night
19:27:35 <CosmicRay> thanks jgilbert
19:27:49 * CosmicRay seeks some algorithm advice.
19:27:58 <SamB> CosmicRay: use them!
19:28:07 <CosmicRay> I am building a spidering/caching bot, to try to cache what is left of gopherspace (similar to archive.org)
19:28:08 <CosmicRay> SamB: lol
19:28:10 <SamB> they work better than just hoping for the best
19:28:26 <CosmicRay> presently my program knows of about 1.5 million URLs, and stores state in a PostgreSQL database.
19:28:31 <SamB> cache?
19:28:34 <CosmicRay> state being visited/notvisited sort of thing.
19:28:39 <SamB> you mean archive?
19:28:46 <CosmicRay> SamB: yes
19:28:59 <SamB> with like history, if any of it were to change?
19:29:09 <CosmicRay> I hope to add that feature down the road, yes.
19:29:20 <CosmicRay> right now I'm just trying to capture what is there now.
19:29:22 <SamB> if the issue comes up?
19:29:29 <CosmicRay> it will, I'm sure.
19:29:52 <CosmicRay> so anywya, this bot is multithreaded, and I am imposing the limitation that I will never have more than one simultaneous connection to any given host.
19:30:06 <CosmicRay> this has been a bit of a challenge to the performance of the system.
19:30:44 <CosmicRay> at present, I maintain a postgresql host-finding thread, that basically keeps doing SELECT DISTINCT host FROM files where state = NotVisited.  whenever a thread gets idle, it takes the next one from the list.
19:30:51 <CosmicRay> then it does a select * from files where host = blah.
19:30:57 <SamB> you could create a thread for each host, and stick Chans to them in a Map...
19:31:22 <CosmicRay> the thread communication bit isn't what's got me stuck
19:31:25 <CosmicRay> it's the db side
19:31:26 <SamB> oh
19:31:36 <CosmicRay> this algorithm is really inefficient to the db
19:31:51 <CosmicRay> I should say, "where host = blah and state = NotVisited" above.
19:32:04 <CosmicRay> basically, every host change implies scanning a sizable chunk of the db.
19:32:52 <CosmicRay> and I can't just do select * where state = NotVisited because there tend to be a lot of items from a single host grouped together, so I don't want several threads processing them at once.
19:35:49 <CosmicRay> my first naive algorithm was to just keep picking items from select * and skip a given item if another thread was processing that host.
19:36:20 <CosmicRay> I found that this was very inefficient; all the small servers were spidered quickly, and things bogged down when only big ones remained.
19:46:53 <dons> in references to rsi and carpal tunnel syndrome: "One way to reduce stress is simply to use the mouse less."
19:47:11 <sethk> one way to eliminate stress completely is to commit suicide
19:47:11 <Itkovian> dons: I agree
19:47:15 <dons> maybe ion3 should be prescribed for its health benefits ;)
19:48:01 * dons doesn't have a mouse
19:48:22 <glguy> ion3 should be prescribed because it is awesome
19:48:28 <dons> hehe
19:49:02 <Itkovian> wtf is ion3?
19:49:16 <dons> tuomov's brilliant window manager
19:49:20 <dons> @seen tuomov
19:49:21 <lambdabot> tuomov is in #haskell. Last spoke 2 days, 3 hours, 19 minutes and 52
19:49:21 <lambdabot> seconds ago.
19:49:28 <dons> @where ion
19:49:29 <lambdabot> I know nothing about ion.
19:49:34 <dons> @google tuomov ion
19:49:35 <lambdabot> http://modeemi.cs.tut.fi/~tuomov/ion/
19:49:45 <dons> @where+ ion http://modeemi.cs.tut.fi/~tuomov/ion/
19:49:46 <lambdabot> ion ~> http://modeemi.cs.tut.fi/~tuomov/ion/
19:50:18 <glguy> ion3 is a window manager that allows you to control everything from the keyboard
19:50:25 <glguy> and doesn't allow overlapping of windows
19:50:39 <dons> the wm of choice for the discriminating hacker.
19:50:42 <glguy> which seems bad at first
19:50:49 <Itkovian> ok
19:50:52 <dons> but it's quite natural if you've ever used an eidtor
19:50:53 <glguy> until you start playing with it
19:51:19 <Itkovian> hmm
19:51:36 <Itkovian> I love Aqua ... seems the best I've ever used
19:53:01 * SamB wonders why his 41-line BF implementation baloons out to 5130 lines of .hcr and 7211 lines of .hc
19:53:08 <glguy> which is Aqua? (OS X?)
19:53:15 <Itkovian> yeah, OSX
19:53:23 <glguy> yeah, I like my Powerbook a lot
19:53:30 <Itkovian> idd
19:53:33 <dons> SamB, deriving Read,Show?
19:53:38 <glguy> but I don't want my desktop to be the same os as my laptop
19:53:44 <SamB> dons: not a bit
19:53:44 <Itkovian> why not?
19:53:50 <dons> they bloat like ... umm ... something that bloats a lot.
19:54:06 <glguy> Itkovian, because it limits what I can do... I don't gain anything from having two computer swith the same OS
19:54:30 <glguy> for example, I have a windows desktop and a mac laptop, i can play games and whatnot on the desktop, but still get to use os x
19:54:32 <SamB> I parse straight to StateT Word8 IO ()...
19:54:33 <dons> you gain by having a seamless transition between environments
19:54:34 <Itkovian> well, ... I prefer to keep a server like machine for that
19:55:06 <glguy> the transition never slowed me down, I'm comfortable in all of my machines
19:55:26 * SamB would have one machine if he wanted seamless
19:56:23 <Itkovian> glguy: I'm comfy _on_ all of my machines, rather than in them :-)
19:56:46 <SamB> of course, most of the .hcr file is those huge constructor names...
19:56:51 <glguy> i don't sit on my machine either
19:56:59 <dons> I run the same OS with the same config files and such on home, work and laptop :)
19:57:01 <glguy> but I'm comfortable with my machine
19:57:06 <SamB> and whitespace
19:58:04 <SamB> yeah, this .hcr file has got to be 95% whitespace...
19:59:01 * dons wrote much of the .hcr ppr so I hope it's at least readable :}
19:59:07 <dons> oh, not .hcr, .hc
19:59:34 <SamB> that is pretty printed?
19:59:43 <SamB> there is like no indentation!
19:59:53 <dons> not .hcr then.
20:00:10 <dons> unless it's been tweaked to not use the pretty mode for dumping .hc
20:00:16 <dons> (which is what ghc usuallyy does)
20:00:31 <SamB> the .hcr is pretty printed, the .hc is
20:00:45 <SamB> s/.hs is/.hc is not/
20:01:02 <dons> ok. and so it should be.
20:01:25 <dons> there's some flag to get the ppr version of every phase
20:02:32 <SamB> only the .hcr is ugly, because it gets stuck between the indentation and the right margin
20:02:59 <SamB> (only it actually goes beyond the margin)
20:04:23 <SamB> oh, are the loops in BF like do-while loops or like while loops?
20:06:53 <SamB> hmm, I probably ought to handle EOF...
20:11:02 <wamd> Hello everyone.  Interesting project.  I am trying to find pairs of numbers in 65,000,000 random sets.
20:11:18 <wamd> Someone told me to try it in Haskell.
20:11:34 <wamd> Suggestions?
20:12:00 <SamB> details!
20:13:42 <Itkovian> wamd: what do the sets look like?
20:14:01 <wamd> Ok, I have 65,000,000 sets each with eight numbers.
20:14:32 <Itkovian> ok
20:14:34 <wamd> 1,64,17,95,214,3,126,50 etc.
20:14:43 <lament> lottery eh
20:14:52 <Itkovian> ;-)
20:14:54 <wamd> Nope. :D
20:14:59 <wamd> Just bordem. :D
20:15:08 <lament> what's the range on the numbers?
20:15:14 <lament> anything?
20:16:05 <wamd> 8^8 for now.
20:16:40 <wamd> So from 1 to 16,777,216
20:17:38 <lament> so you can just keep a dictionary
20:17:42 <lament> with keys being those numbers
20:17:54 <lament> and values being lists of sets (set indices, whatever)
20:18:23 <lament> would that work?
20:19:48 <wamd> I'm not sure.  Could you give an example of what that might look like?
20:20:16 <lament> i don't know what that would look like in haskell
20:20:39 <lament> i don't know how you make dictionaries :)
20:20:53 <sethk> lambdabot, Data.Map
20:20:56 <Itkovian> what do you mean by pairs? things that are alike? or just (x,y) from the eight possibilities?
20:21:00 <sethk> lament, that is  :)
20:21:17 <sethk> lament, if you mean dictionary in the python/ruby sense
20:21:50 <lament> yes.
20:22:16 <sethk> lament, then Data.Map
20:22:20 <wamd> 1,2 36,124 etc.
20:22:31 <lament> ohhh
20:22:34 <sethk> lament, you should change your nick, because when I type lam<tab>, I get lambdabot    :)
20:22:50 <lament> wamd: then what do you mean by "find"? Aren't they immediately obvious?
20:22:59 <lament> sethk: on the contrary, lambdabot should change its nick!
20:23:13 <sethk> lament, well, I suspect he isn't going to.  :)
20:23:33 <lament> actually, _i_ don't care either way :)
20:23:47 <lament> but you're free to bribe me, of course
20:24:00 <sethk> lament, you are making my fingers sore.  :)
20:24:40 <lament> that's not much of a bribe :)
20:25:13 <sethk> lament, you want bribes, you should go to #fatcats
20:30:02 <Cale> wamd: what exactly do you mean by "find pairs of numbers" -- find all those sets with two particular numbers in them?
20:32:30 <Cale> wamd: and I recommend building/reading those sets lazily
20:33:30 <Cale> as if you need to keep 65 million such sets in memory, the memory requirements would be quite large.
20:35:35 <wamd> Well I am currently using MySQL to hold the sets and I am reading them into a script to compare them.
20:38:37 <Cale> what are you looking for?
20:38:51 <Itkovian> wamd: describe the problem better
20:39:02 <Itkovian> wamd: give an example using e.g. 2 sets
20:42:33 <wamd> Set 1: 1,3,5,7,9,11,13,15. Set 2: 2,4,6,8,10,12,14,16 Looking for 11,13.
20:42:45 <wamd> I find 11,13 in Set 1.  Not in set 2.
20:42:51 <Cale> oh, that's easy enough
20:43:12 <Itkovian> ic
20:43:29 <Itkovian> at least you can lazily browse the sets
20:44:16 <Itkovian> wamd: first write a function that checks if a pair is present in a set, you can use e.g. filter, zip for that
20:44:42 <Cale> filter (isSubsetOf (fromList [11,13])) mySets
20:45:08 <Cale> where mySets is your list of sets
20:45:19 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
20:45:30 <Itkovian> you may want to zip [1..] with your sets
20:45:47 <wamd> Ok, next noob question.  Any suggestions as to a good Haskell tutorial?  Never used it before.
20:45:49 <Itkovian> to get set numbers as well ...
20:45:57 <Itkovian> Not the gentle intro
20:46:00 <wamd> Was directed here by another room.
20:46:05 <Cale> wamd: Yet Another Haskell Tutorial is good
20:46:10 <Itkovian> idd
20:46:17 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
20:46:32 <Cale> What programming languages are you familiar with?
20:47:16 <machack666> is there a quick way to tell is a list has duplicate elements in it?  I'm using `containsDuplicate a = not . null $ a \\ nub a' which gets slow very quickly.
20:47:31 <Cale> If you're familiar with a bunch of imperative/OO languages, I recommend trying to forget everything you know about them while initially learning Haskell.
20:48:56 <wamd> Cale: I know C, Python, Perl, and PHP.
20:49:02 <machack666> Itkovian: "2 dozen short lessons" about haskell is a good one as well
20:49:03 <wamd> Programming noob I suppose.
20:49:15 <dons> machack666, sort the list and then write a fold that checks each element is /= the previous elem?
20:49:20 <Itkovian> machack666: hey, I didn't ask ;-)
20:49:25 <Itkovian> tell wamd
20:49:33 <Cale> wamd: yeah, forget everything you know about those, because for a while, they'll just get in the way of your thinking
20:50:06 <icb> anyone here able to signup for an account on meme.b9?
20:50:28 <Korollary> icb: I think I couldn't do it the last time I tried.
20:50:32 <icb> the registration seems broken, without account, it won't let one search
20:50:40 <wamd> Cale: So I should just forget everything I know and start at the beginning.
20:50:49 <Cale> wamd: yeah, probably :)
20:50:57 <Cale> Haskell is a rather different language
20:50:59 <icb> koro, i tried it on a half dozen platform/browser combo
20:51:08 <SyntaxNinja> Igloo: alive?
20:51:15 <machack666> Itkovian: do'h!
20:51:26 <Itkovian> machack666: np :-)
20:51:35 <palomer_> anyone have access to a computer with one terabyte of ram?
20:51:53 <wamd> Sorry only 32GB. :D
20:51:54 <Cale> One big difference is that evaluation is lazy: that is, nothing is ever evaluated unless it's needed. This gives you things like infinite lists, infinite trees and such.
20:52:15 <Cale> (as long as you don't use the whole infinite list, you're okay :)
20:52:31 <wamd> Cale: So I could write some pretty fast code then eh?
20:52:39 <Cale> potentially
20:52:52 <sethk> Cale, actually, as long as he doesn't use 32 gig, which is hardly infinity  :)
20:52:56 <machack666> or pretty large :D
20:52:57 <Cale> Though there's a high amount of overhead inherent in using Haskell
20:53:31 <machack666> who maintains haskell-mode?
20:53:34 <Cale> well, garbage collection will usually take care of things
20:53:40 <icb> is Kevin Rosenberg still the maintainer for meme?
20:53:45 <dons> machack, > foldl (\(Just x) y -> if x == y then Nothing else (Just y)) (Just '\0') (sort "dups") or so
20:53:59 <dons> not sure if that type checks
20:54:12 <Cale> An example:  primes = sieve [2..] where sieve (x:xs) = x : [y | y <- xs, y `mod` x /= 0]
20:54:16 <dons> let's see what @pl says
20:54:23 <Cale> wamd: that defines the list of all prime numbers
20:54:27 <palomer_> wamd: really?
20:54:29 <dons> @pl foldl (\(Just x) y -> if x == y then Nothing else (Just y)) (Just '\0') (sort "dups")
20:54:30 <lambdabot> (line 1, column 15):
20:54:30 <lambdabot> unexpected "x"
20:54:30 <lambdabot> expecting operator or ")"
20:54:41 <Cale> @eval let primes = sieve [2..] where sieve (x:xs) = x : [y | y <- xs, y `mod` x /= 0] in take 20 primes
20:54:57 <lambdabot> [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39]
20:55:03 <Cale> lambdabot is compiling GHC again?
20:55:06 <wamd> palomer_: Yes.  Sparc machine with 32GB.
20:55:16 <dons> it's that time of day ;)
20:55:17 <SamB> @eval let primes = sieve [2..] where sieve (x:xs) = x : [y | y <- xs, y `mod` x /= 0] in primes
20:55:20 <lambdabot> [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,
20:55:20 <lambdabot> 49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,
20:55:20 <lambdabot> 95,97,99,101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,
20:55:20 <lambdabot> 131,133,135,137,139,141,143,145,147,149,151,153,155,157,159,161,163,
20:55:20 <lambdabot> 165,167,169,171,173,175,177,179,181,183,185,187,189,191,193,195,197,
20:55:20 <palomer_> wamd: can you run a proggy for me?
20:55:21 <wamd> My Dad gave it to me for Christmas.
20:55:22 <lambdabot> 199,201,203,205,207,209,211,213,215,217,219,221,223,225,227,229,231,
20:55:24 <lambdabot> 233,235,237,239,241,243,245,247,249,251,253,255,257,259,261,263,265,
20:55:26 <lambdabot> [24 @more lines]
20:55:28 <dons> I'm thinking of moving lambdabot over to a dedicated box, actually
20:55:29 <Korollary> wamd: Not quite.
20:55:31 <dons> we'll see if I get time
20:55:46 <SamB> wamd: how much does that cost?
20:56:10 <wamd> Not sure. :D He got it from work.  Works for ExxonMobil.
20:56:47 <SamB> I would like something with more than 512MB and 450x1 MHz some time...
20:57:16 <SamB> well, I do have that XP box with a 600 MHz CPU, but that hardly counts...
20:57:26 * SamB recalls that he only has 256 MB
20:57:37 <Cale> wamd: another big difference is that you write Haskell programs by making definitions of functions and values. The order in which these definitions appear is irrelevant, and once defined, values don't change, so in some sense, everything is a constant.
20:58:06 <Cale> Functions must always give the same value when given the same parameters.
20:58:09 <wamd> Cale: Everything is a constant?  Isn't that inefficient?
20:58:14 <Cale> no
20:58:21 <Cale> Not necessarily
20:58:42 <SamB> it certainly makes the garbage collector's job a lot easier!
20:59:03 <Cale> It also makes the programmer's job a lot easier.
20:59:20 <SamB> true, true!
20:59:27 <Cale> Since things don't change their behaviour, it's much easier to test if things are working correctly.
20:59:44 <Cale> and also much easier to prove that the program is correct
20:59:55 <SamB> or just believe that it is
21:00:00 <Cale> yeah
21:00:14 <Cale> even if you never write down your proof
21:00:29 <machack666> the strong typing and pattern matching make flow control much easier to manage.  You feel like you're only writing the important parts of the program.
21:00:49 <Cale> Yeah, Haskell is strongly and statically typed.
21:00:57 <Cale> But there's type inference
21:00:57 <SamB> machack666: yeah, thats exactly what it feels like, most of the time!
21:01:08 <Cale> so you don't need to write type signatures everywhere
21:01:15 <SamB> especially when you leverage the libraries
21:01:43 <Cale> now, one question is how does getChar work?
21:01:59 <machack666> I'm a recent convert to haskell, and so now when I try to do things in other languages, I'm like "why can't I just do a pattern match" ? (or whatever is easier.)
21:02:31 <Cale> IO in Haskell is rather differently handled from other languages
21:03:06 <Cale> though in the end, the IO programs look rather similar to imperative code:
21:03:09 <sethk> I was doinig a phone interview for a job today, and they asked me to take a single linked list written in C and reverse it.  I forgot how much of a PITA pointers are.  :)
21:03:25 <Korollary> machack666: you can sorta emulate a pattern match with carefully worded switch statements.
21:03:40 <SyntaxNinja> sethk: I had that experience too
21:03:42 <Cale> main = do { name <- getLine; putStrLn ("Hello, " ++ name) }  is valid Haskell.
21:04:12 <Korollary> sethk: I was asked the same question about a month ago
21:04:16 <SyntaxNinja> sethk: I came up with a really lame, yet efficient solution to one question, then said that I didn't like it and I redid it w/ recursion, and it was much more beautiful.
21:04:22 <wamd> Thanks all. Definitely going to look into Haskell.  Love a good challenge.  School in the morning. Goodnight or Goodday as the case may be.
21:04:27 <machack666> Korollary: the perl6 given() and the ~~ constructs look like they'll help in that regard as well.
21:04:35 <SyntaxNinja> sethk: but the interviewer said that the way I did it the first time was the way it was implemented in the system.
21:04:38 <sethk> syntaxfree, I asked them if I could assume an inexhaustible stack, and they said yes.  :)
21:05:00 <sethk> syntaxfree, well, yes, of course, because with a real life sized list and without tail recursion optimization, you can't use recursion
21:05:02 <SyntaxNinja> grrr. I am the NINJA!!
21:05:04 <Korollary> SyntaxNinja: I solved many interview questions using recursion, and was always asked "why did you do it recursively?". I mean, whaddaya mean why ???
21:05:31 <Cale> "Because lists are fundamentally recursive"
21:05:42 <SyntaxNinja> Korollary: I can't remember what it was, but you basically had to build a stack by hand instead of relying on the implicit stack of recursion.
21:06:03 <sethk> Cale, well, sure, but without a compiler capable of optimizing away tail recursion you can't take advantage of that
21:06:30 <Cale> sethk: premature optimisation -- it's the compiler writer's problem to optimise that. :)
21:06:30 <Tac> push on ... pop off.... insta reversal
21:06:43 <Korollary> @seen Pseudonym
21:06:44 <lambdabot> I saw Pseudonym leaving #haskell-blah and #haskell 6 days, 22 hours,
21:06:44 <lambdabot> 4 minutes and 11 seconds ago, and I have missed 59 seconds since
21:06:44 <lambdabot> then.
21:07:03 <Korollary> holy kangaroo
21:07:31 <sethk> Cale, I might have told you, I actually ran tests of several compilers to see if they would pick up the canonical pattern for tail recursion optimization (C compilers).  The only one that had an explicit flag for enabling tail recursion optimization failed the test.
21:07:47 <Cale> wow
21:07:50 <Korollary> sethk: which one was that ? (with the flag, that is)
21:07:53 <sethk> Cale, it was trivial to make the others fail, but at least they handled the simplest case
21:08:05 <sethk> Korollary, the solaris compiler (from sun, not the gnu compiler for solaris)
21:08:09 <Korollary> ah, sun cc
21:08:10 <Cale> I thought that gcc had tail recursion optimisation now?
21:08:37 <sethk> Cale, yes, it does
21:08:48 <sethk> Cale, and it picks it up in many cases, but far from all the cases where it should
21:08:57 <sethk> Cale, it did as well as any
21:09:02 <Korollary> -foptimize-sibling-calls
21:09:25 <Korollary> hmm, -mtail-call, too
21:10:17 <Cale> It seems like something which should be relatively easy to pick out
21:10:48 <Korollary> Cale: the man page admits that its detection of invalid cases is not complete.
21:11:13 <sethk> Cale, I wasn't giving it hard cases, though, I was giving it cases such that, if it didn't pick up my test case, it would never pick it up.
21:11:35 <sethk> Cale, more or less  f x = if x then y else f x
21:11:40 <sethk> Cale, not those arguments
21:11:48 <Korollary> I bet testing tailcall optimization is high on the gcc developers' todo lists
21:11:50 <sethk> Cale, and if then else, the else being the tail call
21:11:58 <sethk> Korollary, I wouldn't know.
21:12:11 <sethk> Cale, if you don't pick that up, what can you pick up?
21:12:16 <Korollary> sethk: I was being sarcastic :)
21:12:21 <sethk> Korollary, I know
21:12:31 * Korollary keels over
21:12:35 <sethk> Korollary, so was I
21:13:57 <Cale> sethk: I agree, that should be easy
21:14:24 <sethk> makes you wonder what they tested it with.  :)
21:15:05 <Cale> f x = do {print "x"; f (x+1)} ?
21:15:33 <Cale> sans-quotes, or whatever :)
21:16:16 <Cale> I suppose that's not tail recursive in Haskell :)
21:22:46 <Cale> hmm, looks like it's getting optimised anyway :)
21:22:55 <Cale> (you really would want it to be)
21:25:44 <machack666> anyone else do documentation lookups through google?  and anyone else notice that the ghc documentation changed paths on us?  and anyone else a little bit annoyed by this?  :D
21:26:21 <Cale> machack666: I was annoyed
21:26:37 <Cale> I have a tree of bookmarks to all the documentation
21:26:42 <Cale> which needed updating
21:26:55 <machack666> google's links need to be updated as well.
21:27:01 <Cale> I just edited bookmarks.html with vim :)
21:27:18 <machack666> is there a command-line reference tool akin to `perldoc' which lets you look things up in the shell?
21:27:32 <Cale> perhaps I should export those bookmarks and put them online somewhere
21:27:44 <Cale> not that I'm aware of
21:28:01 <machack666> I've got a local copy of the library docs on my drive, but it's so much easier to open a browser window... :D
21:28:04 <Cale> you could write one which just passed the right thing to Firefox.
21:28:48 <Cale> A hoogle sidebar would be cool
21:29:10 <Korollary> machack666: maybe you can use google desktop search for the html files on your drive
21:29:36 <machack666> Korollary: I'm using Mac OS X.  I don't think they have a google desktop search yet.
21:29:42 <machack666> I suppose I could try spotlight
21:30:18 <Cale> on MacOS X, I used to use Quicksilver a lot
21:31:00 <machack666> quicksilver.blacktree.com?
21:31:02 <Cale> it was rather good at finding the documentation links in my bookmarks, and I suspect if you pointed it at the directory on your disk with all the docs in it, that would work too
21:31:04 <Cale> yeah
21:31:22 <sethk> I point it locally, yes, and it works fine
21:31:26 <sethk> all the links work
21:31:33 <sethk> there is some sort of logical root
21:32:00 <sethk> I've had it in a couple of different places in the tree (on a couple of different machines)
21:32:31 <Cale> quicksilver seems to me something which I wouldn't go without on a Mac
21:32:43 <machack666> in OS X 10.4, you can type Cmd-Space to get a search window.  typing (say) `Data.List nub' pulls up the apprpriate file in fairly short order.
21:33:33 <machack666> Data.Maybe has some pretty cool stuff, for as simple a datatype as Maybe is.
21:34:25 <Cale> spotlight seems complementary to quicksilver, though on the surface they do the same thing, they're better at reasonably different sets of tasks
21:34:52 <palomer_> damnit, can't ANYONE give me access to a ramful computer?
21:35:04 <Cale> palomer_: why do you need access to that much ram?
21:35:20 <Cale> that's a ridiculous amount of ram, btw.
21:35:56 <palomer_> I'm cracking DES
21:36:00 <Cale> why?
21:36:04 <palomer_> for fun
21:36:08 <palomer_> to show that it can be done
21:36:12 <palomer_> on a single computer
21:36:18 <Korollary> I think that's been shown already
21:36:22 <palomer_> in a short enough amount of time
21:36:38 <palomer_> Korollary: it took 22 days and the computer was custom built
21:36:52 <Cale> 22 hours, wasn't it?
21:36:55 <Korollary> palomer_: plain DES ?
21:37:01 <palomer_> plain DES
21:37:13 <palomer_> Cale: that was the distributed attack
21:37:24 <Korollary> hah, I was expecting DES to be much easier than that nowadays...
21:37:46 <palomer_> ok, it took 56 hours with a computer
21:37:52 <palomer_> I think I can do it in 20
21:38:02 <palomer_> and the computer doesn't even need to be fast
21:38:08 <Korollary> palomer_: but if it takes one TB of ram, that is not too practical either.
21:38:22 <palomer_> but it's more practical than a custom built computer
21:38:46 <Korollary> palomer_: we can always assume that dedicated people will have custom computers.
21:39:08 <palomer_> but more people can crack with run of the mill ramful computers
21:40:48 <palomer_> anyways, it'll be a breakthrough regardless
21:40:57 <palomer_> whoever helps me gets their name on my paper
21:41:00 <palomer_> :O!
21:42:04 <sethk> are there problems on the net again today?  Anyone seeing any name server problems?
21:42:29 <palomer_> I could probably cut it with 50 gigs
21:43:58 <_astrolabe> palomer_:What does the algorithm use the ram for?
21:44:16 <palomer_> storing huge datastructures
21:44:22 <palomer_> formulae, actually
21:44:34 <palomer_> in propositional logic
21:45:01 <_astrolabe> Oh, so it is a 'clever' attack?  Got a link?
21:45:27 <palomer_> err, I "invented" it
21:45:48 <palomer_> but it's so frigging ram hungry:O!
21:46:13 <Cale> palomer_: why not test it on smaller cases?
21:47:17 <palomer_> that's what I'm doing it
21:47:56 <Cale> how large a key can you break using the ram on your machine?
21:48:11 <palomer_> 42 bits
21:48:18 <palomer_> and DES is 56 bits
21:49:24 <palomer_> it's really a ram issue
21:49:48 <Cale> how long do you think it would take with sufficient ram?
21:50:00 <palomer_> I'm guessing about 15 hours
21:50:56 <palomer_> here, I'll get you as good an estimate as I can
21:51:16 <Cale> not that I can provide you with a machine with tons of ram in it :)
21:51:25 <Cale> My own machine has only 1GB.
21:51:30 <palomer_> yeah, ditto
21:51:40 <gzl> how confident are you that it works?
21:51:48 <palomer_> 99%
21:52:10 <palomer_> it's not rocket science, it's just combining things that people never thought of combining
21:52:17 <gzl> has anyone else looked at it?
21:52:22 <_astrolabe> Is there no way of efficiently swapping to and from disk?
21:52:45 <palomer_> gzl: no, I just finished it, like, right now
21:53:19 <gzl> are you really expecting someone on IRC to supply access to a computer that has 1 TB of RAM?
21:53:43 <sethk> _astrolabe, that's sort of an open ended question
21:53:56 <_astrolabe> Yes
21:54:00 <vegai> we might have that much RAM, combined :P
21:54:10 <palomer_> when I was finding the 8th term of the egyptian fraction sequence, I got offered some really fast computing on irc
21:54:15 <vegai> naah, probably not, only about 200 of us
21:54:50 <_astrolabe> I have 2.5G :)
21:55:08 <gzl> how fast?
21:55:51 <_astrolabe> 2GHz PC
21:56:15 <palomer_> some solidstate computer simulator cluster
21:56:31 <palomer_> it had 4gigs of ram
21:56:52 <gzl> my friend's home computer has 4 gigs of RAM :)
21:58:02 <Cale> which sequence are you referring to exactly?
21:58:02 <palomer_> if only I had access to IBM research software:O!
21:58:37 <palomer_> http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A002966
21:58:37 <_astrolabe> Are you using memory efficiently?  ie at bit level?
21:58:56 <palomer_> _astrolabe: I did not develop the underlying library
21:59:02 <palomer_> that would take years
21:59:41 <_astrolabe> No, but to encode formulae, there are more and less efficient ways.
22:00:01 <palomer_> yeah
22:00:03 <Cale> You should compute a(9), then you can get credit on Sloane
22:00:04 <_astrolabe> And you could use a binary file after you had done the encoding
22:00:15 <palomer_> the underlying library takes care of that
22:00:21 <Cale> (if you're not already the guy with credit for a(8))
22:00:21 <palomer_> Cale: credit?
22:00:28 <palomer_> Cale: I am
22:00:35 <Cale> oh :)
22:01:47 <palomer_> brb
22:01:49 <Cale> ah, I see, I should have been able to figure that out from the link to http://www.magnesium.net/~palomer/egypt.cpp
22:01:52 <gzl> why is that sequence interesting?
22:02:02 <palomer_> gzl: practical purposes? non
22:02:05 <palomer_> none
22:02:13 <gzl> what made you pick that one then?
22:02:27 <palomer_> Polytope was trying to find a(8)
22:02:34 <palomer_> so I decided to try
22:03:16 <gzl> ok.
22:03:18 <Cale> palomer_: yeah, I should have been able to tell by the link to http://www.magnesium.net/~palomer/egypt.cpp :)
22:03:40 <gzl> though magnesium.net/~palomer/ is a weird page referring to somebody with a different name.
22:04:27 <palomer_> I forgot my code was posted
22:04:32 <palomer_> don't look at it, it's ugly
22:05:07 <Cale> It's C++ code, of course it's going to be ugly.
22:05:07 <palomer_> oh my god, I used to comment my code
22:05:09 <palomer_> hah!
22:05:23 <gzl> wow, you're not kidding :)
22:05:33 <Cale> this is barely commented :)
22:05:41 <gzl> the indentation is screwed up too
22:05:55 <palomer_> is it?
22:06:00 <gzl> seems to be
22:06:02 <palomer_> where?
22:06:05 <gzl> maybe it's just me
22:06:27 <palomer_> but yeah, the code is based on a simple idea
22:06:30 <Cale> there's only one place in the file where it's screwed up here, and that's commented out anyway
22:06:31 <gzl> there are several pairs of lines with closing braces at the same indentation level
22:06:39 <gzl> ok, maybe it's me then
22:06:45 <palomer_> I wrote a paper on it for my honours project, if anyone is interested
22:07:12 <palomer_> (though I doubt if anyone is)
22:07:44 <Cale> watch someone come up with a recurrence, or a decent g.s. for it and be able to compute huge amounts of the sequence :)
22:07:54 <palomer_> I _really_ doubt it
22:08:22 <Cale> well, with current tools, that's perhaps not so easy.
22:08:49 <Cale> you need another kind of generating series to count them
22:08:55 <Cale> hmm...
22:10:42 <Cale> or actually...
22:11:07 <gzl> is your DES thing simply faster than brute force or faster than the other methods that have been found?
22:11:22 <gzl> the 22 hours thing is just for brute forcing it
22:11:30 <palomer_> yeah, my thing is definitely faster
22:12:00 <palomer_> I mean, I can figure out 36 bits in 6 minutes
22:12:19 <palomer_> (only 20 bits to go!)
22:13:01 <palomer_> I could probably do _much_ better with better software
22:13:02 <palomer_> humph.
22:13:13 <palomer_> maybe I'll give IBM a call
22:13:21 <gzl> my impression was that even those are sort of sidelined since they're not practical to actually use
22:20:19 <palomer_> oh no, IBM is concentrating on practical implementations
22:27:12 <machack666> what's an easy way to incorporate a "program trace" akin to print statements in the code which follow the execution, so I can tell why this code is messing up?  (Or alternately, is there some sort of meaningful debugger so I don't have to resort to the above? :D)
22:27:29 <Cale> Debug.Trace
22:27:39 <Cale> there are some debuggers
22:27:51 <Cale> but if you use extensions to H98 they won't help you
22:28:17 <Cale> machack666: what does the code look like?
22:28:28 <machack666> sounds good.  I'm glad I don't have to try to force Control.Monad.Writer to do things.
22:29:04 <machack666> it's recursive for the most part; I undergo a deductive phase until I have no more straight inferences to go on, and then I switch over into hypothesis mode
22:29:06 <palomer_> getting out of X so I can use all my ram
22:30:04 <machack666> where I merge the results of setting a particular datum to one of several remeaining valid values, continuing until I have a contradiction.
22:30:16 <machack666> and deduce, ad naseum
22:30:37 <Cale> There's also quickcheck for testing desired invariants using random data
22:30:58 <Cale> what are you deducing btw?
22:31:36 <machack666> I'm writing a program to solve sudoku, and validate that in fact there is a unique solution for a given puzzle.
22:32:05 <Cale> ah, cool, sounded like something along those lines :)
22:32:13 <glguy> I wrote a really simple solver for sudoku a couple weeks ago in C
22:32:16 <Cale> I recommend the list monad :)
22:32:27 <glguy> doesn't take much time at all
22:32:34 <machack666> just another task to help me on my journey to haskell competency
22:32:44 <machack666> the core core algorithm is pretty simple
22:34:46 <glguy> Cale, if I want to write a "loop" from 1 to n, is it better haskell style to write a head recursion function (opposite of tail recursion) or to just have an index variable and an upper bound variable?
22:34:55 <machack666> list monad is definitely my friend.
22:35:00 <glguy> and an auxillary function that starts the loop at 1
22:35:02 <kala_> palomer: if you are cracking DES with propositional logic, isn't your solution some kind of revolutionary in solving SAT problem as well?
22:35:10 <Cale> glasser: it depends what kind of loop you want
22:35:18 <Cale> er
22:35:22 <glguy> i got it
22:35:23 <Cale> glguy: *
22:35:45 <Cale> loops are not usually just loops :)
22:36:10 <Cale> you're usually manipulating data in some patterned way -- is it a fold, or a map, or a filter, or a zip?
22:36:24 <machack666> [funcWithIndex i | i <- [lower..upper]]
22:36:34 <Cale> that's a map
22:36:48 <Cale> map funcWithIndex [lower..upper]
22:36:59 <glguy> good call...
22:38:09 <glguy> http://rafb.net/paste/results/0dUh2j84.html
22:38:27 <glguy> (code for the gauss-seidel method)
22:38:44 <glguy> I guess it's a fold...
22:39:02 <glguy> kind of..
22:39:13 <glguy> what I'm talking about is in the function gs'
22:39:42 <Cale> hmm
22:39:53 <glguy> I imagine that the code just looks like a mess
22:41:39 <glguy> i bet I could define the sequence of iterations as a sequence
22:41:40 <glguy> ...
22:41:56 <glguy> and then take elements until the difference in the norms is sufficiently small
22:42:08 <Cale> I wasn't previously aware of Gauss-Seidel, it does look very recursive though.
22:42:49 <Cale> Though shouldn't there really be only one parameter to the recursive part?
22:42:58 <Cale> hmm...
22:43:00 <glguy> true
22:43:11 <glguy> only g and n change..
22:43:34 <Cale> you don't need to pass a and b because they're in scope
22:44:22 <glguy> originally, gs' wasn't inside the where clause
22:44:36 <glguy> not for any good reason
22:44:44 <Cale> g also doesn't look like it's changing, does it?
22:44:57 <glguy> yeah, g gets updated each time
22:45:02 <glguy> ...
22:45:05 <glguy> or not
22:45:09 <glguy> hmm, interesting
22:45:18 <glguy> since it's the just return value
22:45:36 <Cale> um
22:45:39 <Cale> bug?
22:45:58 <Cale> gs' a b g n = g
22:46:12 <Cale> oh
22:46:16 <Cale> no, that's rubbish :)
22:46:47 <Cale> but you don't need to pass it around, certainly
22:46:55 <glguy> right
22:46:58 <glguy> down to one argument
22:47:19 <glguy> now turn that into a non-recursive function?
22:47:22 <glguy> and map with it?
22:47:27 <glguy> or something to that effect...
22:47:32 <Cale> it's quite possibly a list function
22:47:48 <Cale> let's see...
22:48:11 <Cale> oh, it relies on the index quite heavily
22:48:18 <glguy> looks like i don't need it redefine l either
22:48:23 <Cale> since you're reading out of that array
22:48:25 <Cale> yeah
22:48:53 <glguy> actually, the 'l' in the let block isn't in scope
22:49:09 <Cale> why?
22:49:16 <Cale> it's used in s
22:49:36 <glguy> right, because I redefined it in the second let block (gs' 's let clause)
22:49:47 <glguy> but is there a way to keep using the same one from above
22:49:47 <Cale> yes
22:49:54 <glguy> as a where?
22:49:58 <Cale> move that one into the where
22:50:08 <Cale> you shouldn't really need both a let and a where
22:50:19 <Cale> (unless you have guards)
22:50:40 <Cale> where scopes over guards, let is part of an expression
22:51:47 <Cale> um, you really want the local l though, don't you?
22:52:07 <glguy> it shouldn't change tho
22:52:46 <Cale> then you can probably just rename it and move it up a level into the where
22:52:54 <glguy> k
22:53:36 <Cale> I wonder how strict "bounds" is
22:53:54 <glguy> what do you mean?
22:54:09 <Cale> oh, I suppose you're going to use r anyway
22:54:43 <Cale> hmm, what's going on in the first let block...
22:56:39 <glguy> http://rafb.net/paste/results/PMVMvS20.html
22:56:45 <glguy> (cleaned up a bit)
22:57:43 <glguy> i could map across a list of indexes..., but I'd need to recycle the output back in as input
22:57:48 <glguy> like a one argument fold
22:59:51 <sieni> hmm... list monad was on the list of stuff to be learnt
23:01:35 <glguy> alright, I think I can make this a foldl function
23:03:28 <Cale> have you seen the matrix representation of the algorithm? Perhaps that could be used to represent what's going on more clearly?
23:03:45 <glguy> the matrix version just proves that it works (from what I can tell)
23:03:59 <glguy> and requires you to use the inverse operation
23:04:00 <glguy> on the matrix
23:04:11 <glguy> which is what the method is designed to help you avoid
23:04:30 <glguy> (that's how I interpreted it at least)
23:04:54 <Cale> um, hmm... in the page I'm looking at, the inverse is only taken on a diagonal matrix, but perhaps I should look more closely
23:05:12 <glguy> You know better than I
23:05:17 <glguy> could be true
23:05:25 <Cale> yeah
23:05:34 <Cale> taking the inverse of a diagonal matrix is cheap
23:05:47 <Cale> you just invert the entries
23:06:16 <glguy> ah
23:07:00 <glguy> alright, i rewrote it as a foldl
23:07:43 <Cale> (the diagonal entries, obviously :)
23:10:23 <glguy> http://rafb.net/paste/results/mFzAER26.html
23:10:25 <glguy> better?
23:10:53 <Cale> lots better than the original :)
23:11:43 <Cale> hmm... don't have to pass r
23:11:49 <Cale> oh
23:11:52 <Cale> or do you?
23:12:05 <glguy> I think you do for the foldl to work
23:12:07 <Cale> right, you do
23:12:08 <glguy> and because it changes
23:12:16 <glguy> i renamed it
23:12:20 <glguy> so that its not so confusing
23:25:43 <glguy> @index norm
23:25:44 <lambdabot> bzzt
23:25:48 <glguy> just checking :)
23:27:35 <glguy> @type sqrt
23:27:40 <lambdabot> forall a. (Floating a) => a -> a
23:30:01 <dons> @yow
23:30:02 <lambdabot> Actually, what I'd like is a little toy spaceship!!
23:55:46 * boegel boings
23:58:44 * basti_ holds a cast iron frying pan above boegels head
