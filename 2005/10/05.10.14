00:00:08 <earthy> such as a complete lack of overloading
00:00:20 <vincenz> the question is whether my idea is feasible
00:00:24 <Pseudonym> I do find myself wanting to choose when to use laziness and when not to.
00:00:25 <ulfdoz> vincenz: I can (sometimes must) live with both. I don't see big differences there. And ocaml sometimes a bit confusing.
00:00:44 <vincenz> I know (I remember the thoughtexperiment) that certain haskell features concerning typeclasses REQUIRE lazyness
00:01:04 <vincenz> so not sure how feasible typeclasses are in a strict (as in nonlazy) language
00:01:08 <Pseudonym> http://www.ucomics.com/patoliphant/2005/10/05/
00:01:22 <earthy> um
00:01:43 <Pseudonym> I don't think I've heard that one.
00:01:43 <int-e> Pseudonym: lol
00:01:46 <Pseudonym> Do you know what the features are?
00:01:48 <earthy> typeclasses provide for a method of resolving overloading, mostly
00:02:07 <vincenz> the guarantees of monads are not there in a nonlazy language
00:02:11 <earthy> I don't think they have anything to do whatsoever with evaluation strategy
00:02:12 <vincenz> let me explain
00:02:36 <vincenz> when you use monads for IO, you know that a function will have as typing IO _ when it does IO
00:02:41 <vincenz> this is not so if the language where strict
00:02:42 <vincenz> hwy.
00:02:44 <vincenz> I could do
00:02:54 <vincenz> let x = (do some io);(return another value)
00:03:06 <vincenz> in lazy the first part would never be executed as it's not part of the return chain
00:03:15 <earthy> what is the semantics of ; there?
00:03:21 <vincenz> earthy: sequencing
00:03:28 <vincenz> ala ocaml
00:03:40 <int-e> vincenz: that's specific to the IO monad. In fact if you implemented the IO monad as what it is - a suspended IO action, to be executed when needed, they also work in a strict context.
00:03:54 <earthy> vincenz: but that is already a side-effecting operator
00:03:58 <vincenz> int-e: I would be interesting in the reasoning behind that as I do not see it
00:04:28 <vincenz> earthy: true but you could do it as
00:04:33 <earthy> vincenz: I parsed it as in haskell, where the semantics would be   some io >>= \_ -> return another value
00:04:45 <Pseudonym> Oh, I know what the problem is.
00:04:48 <earthy> that >>= also enforces sequencing
00:04:49 <Pseudonym> Yes, vincenz is kind of right.
00:04:52 <vincenz> let main = (let x = do some io in dont_use_x_i_return)
00:05:05 <Pseudonym> The problem is that, for example, >> is lazy in its second argument.
00:05:24 <Pseudonym> As it must be.
00:05:28 <vincenz> however I am not sure how far the IO moand stuff is related to typeclasses being proper and correct
00:05:32 <earthy> vincenz: that would indeed not execut the io
00:05:47 <vincenz> so I'm wondering whether typeclasses would work in a strict functional language (possibly with side effects)
00:05:49 <earthy> as an unused x properly should not be used!
00:06:04 <Pseudonym> I don't think it's typeclasses that are the issue, vincenz.
00:06:07 <vincenz> earthy: that would require an insanely difficult typing scheme in a strict language
00:06:18 <earthy> vincenz: *why*?
00:06:23 <Pseudonym> I think it's monads, and ensuring that things are evaluated at the right time.
00:06:28 <Pseudonym> And not before time.
00:06:31 <vincenz> earthy: you'd have to pass x_is_evalled_as_Type in the return type
00:07:14 <earthy> let me get this straight. let main = let x = do_some_io in print_something_not_involving_x
00:07:37 <earthy> and you're telling me that a compiler can not see that x is not used in print_something_not_involving_x ?
00:07:38 <vincenz> Pseudonym: I guess, I just wanted to ensure I didn't oversee anything.  I would rather like typeclasses in a strict functional language, and then if one switches to a more algol like syntax, it would be rather neat
00:07:46 * Pseudonym nods
00:07:49 <vincenz> earthy: strict languages assume x is evalled
00:07:56 <earthy> vincenz: no they do not
00:07:59 <dons> strictness doesn't change the typing. this is weird.
00:08:20 <Pseudonym> Yeah, I'm 99.99% sure that it's not typeclasses that are the problem.
00:08:27 <vincenz> earthy: I could probably come up with a more contrived examle
00:08:35 <earthy> strict languages state that *when* x is used, it is evaluated *before* it is used
00:08:49 <int-e> vincenz: IO a is basically a function, WorldState -> (WorldState, a). It's not evaluated before the WorldState - the context in which it is evaluated - is known.
00:08:51 <earthy> if it isn't ever used, which is something that can be checked statically, then it will never be evaluated
00:09:06 <vincenz> earthy: isn't that an undecideable property?
00:09:07 <ValarQ> i think i have found the bug (without help from the debugger)
00:09:08 <ulfdoz> Who still knows Algol? :)
00:09:13 * earthy does
00:09:20 <vincenz> well not algol
00:09:23 <ValarQ> is that getRandomIndex on http://haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers really ok?
00:09:24 <earthy> some Algol 60 and some Algol 68
00:09:25 <Pseudonym> Hello, my name is Pseudonym, and I'm a recovering Algoholic.
00:09:26 <earthy> nice languages
00:09:28 <vincenz> I'm thinking something like ruby/python
00:09:51 <ValarQ> shouldn't it be  getRandomIndex list = randomRIO ( 0::Int, length list - 1 ) -- instead?
00:10:21 <vincenz> why has no ML-variant implemented typeclasses?
00:10:26 <earthy> vincenz: no, it is decidable if an identifier is refered to. at least, in a language without references...
00:10:27 <vincenz> they do cut down on typing
00:10:28 <Pseudonym> Sounds to me that you want an imperative language with a Haskell-like type system.
00:10:31 <vincenz> (as in finger)
00:10:35 <Pseudonym> Which is a noble goal, I think.
00:10:39 <vincenz> Pseudonym: somewhat yes
00:10:47 <vincenz> :)
00:10:48 <Pseudonym> I've wanted one of those for a while, too.
00:11:08 <earthy> vincenz: ML variants have a much stronger module system that allows operator renaming
00:11:08 <vincenz> static typing can get you a lot in the sense of performance boosting and bug-less guarantees
00:11:09 <Pseudonym> I describe this hypothetical language as the Ideal Stepanov Language.
00:11:14 <earthy> thereby alleviating part of the need for typeclasses
00:11:17 <vincenz> earthy: they require more fingertyping
00:11:32 <vincenz> and typeclasses fit more closely to the idea of oo
00:11:34 <vincenz> imho
00:11:49 <vincenz> Pseudonym: stepanov?
00:11:50 <earthy> but, it sounds like you want Algol 68 with polymorphism and a module system.
00:12:04 <Pseudonym> vincenz: Alex Stepanov.  Google knows all.
00:12:19 <vincenz> ah
00:12:21 <vincenz> stl-dude
00:12:29 <Pseudonym> More than that.
00:12:46 <Pseudonym> Suppose you were redoing the STL today, and more so.
00:12:56 <Pseudonym> Your mission is to design a language which makes it ideal to implement.
00:13:00 <sethk> what's the function that is like words but allows you to specify the delimiter?  I know I can use splitRegex, but is there one that takes just a plain Char ?
00:13:15 <vincenz> Pseudonym: with the proposition ala ruby of 'everything is an object'
00:13:22 <Pseudonym> It turns out that it looks an awful lot like imperative Haskell.
00:13:24 <vincenz> well not physically an object, but you know what I mean
00:13:31 <Pseudonym> No!
00:13:33 <vincenz> type classes on all types
00:13:33 <Pseudonym> You don't need that!
00:13:41 <Pseudonym> With type classes, nothing has to be an object.
00:13:45 <vincenz> aka 'methods' (being the functions in the typeclasses)
00:13:58 <vincenz> Pseudonym: abstractly they're the same
00:14:07 <Pseudonym> There's a critical difference.
00:14:10 <vincenz> yes
00:14:16 <Pseudonym> With typeclasses, you can add interfaces after the event.
00:14:27 <JohnMeacham> is europe awake yet?
00:14:30 <vincenz> Pseudonym: with ruby and open classes, similar
00:14:32 <vincenz> JohnMeacham: yes
00:14:33 <ValarQ> JohnMeacham: yes
00:14:37 <Pseudonym> A Haskell typeclass is almost the same thing as a STL "concept".
00:14:41 <eivuokko> Atleast those not sleeping late.
00:14:52 <vincenz> Pseudonym: I think you base your oo view too much on closed class definitions
00:14:57 <Pseudonym> Perhaps.
00:15:04 <vincenz> Pseudonym: ruby has openclasses which are kinda neat
00:15:40 <vincenz> myprogram:  class String;def poop; self.reverse;end;end
00:15:41 <Pseudonym> I'm also trying to ensure that the hypothetical language has an easy-to-understand performance model.
00:15:44 <vincenz> "abc".poop
00:15:58 <vincenz> Pseudonym: yes me too, which sadly is lacking in haskell due to lazyness
00:16:25 <vincenz> you step away one step too much from the computer, and I often come in hear and here like 'hey look at this code, it's bleeding resources, why?'
00:16:30 <JohnMeacham> gosh I have been prolific on the mailing list the last day or so. hmm.. perhaps I should take a break.
00:16:32 <vincenz> s/hear/here/reverse
00:17:36 <sethk> JohnMeacham, europe should be awake, unless they keep my hours  :)
00:17:50 <vincenz> anyways, I think it would be a great language, and if you combine that with the type-ful research they do at alice for futures and concurrency :)
00:18:04 <sethk> anyone know the answer to my question?  Is there a function like splitRegex, only one that takes a Char (or a one character String) instead of a regex?
00:18:09 <JohnMeacham> well, most of the US is asleep, as they don't keep my hours :)
00:18:13 <Cale> Typeclasses don't really seem much like OO classes to me. They're like relations on types, where if the relation holds, you get some functionality.
00:18:24 <Pseudonym> @wiki RunTimeCompilation
00:18:26 <lambdabot> http://www.haskell.org/hawiki/RunTimeCompilation
00:18:29 <Pseudonym> sethk: Something like that?
00:18:42 <JohnMeacham> Yeah, OO classes are more similar to haskell data types.
00:18:44 <vincenz> Cale: yes, but one can see the functions defined therein as methods if you stick to ducktyping oo instead ofinterface oo
00:18:52 <dons> sethk, there's some string splitting functions in MissingH
00:19:09 <sethk> dons, Pseudonym thanks
00:19:14 <dons> also, in h4sh provides some similar functions
00:19:16 <Pseudonym> Anyway, gotta go.
00:19:18 <Pseudonym> Nytol!
00:19:22 <vincenz> Pseudonym: later
00:19:45 <vincenz> Cale: and imho, ducktyping oo is better than interface oo, programmer-time-wise
00:19:45 <sethk> JohnMeacham, be careful when talking about OO classes.  Especially, remember that the class concept is triply overloaded in C++
00:20:17 <sethk> so comparing OO to haskell classes or haskell types, especially when OO might mean c++, is ambiguous
00:20:39 <vincenz> I'm looking at oo from a ruby point of view: open classes and ducktyping
00:21:12 <vincenz> (or those that don't know ruby, smalltalk)
00:21:25 <tic> pythonpython!
00:21:25 <Cale> How would you express something like  MonadState s m | m -> s ?
00:22:07 <vincenz> Cale: I'm not the expert, hence me throwing it in as an idea...
00:22:11 <vincenz> Cale: what does that say, tho?
00:22:17 <sethk> vincenz, haskell classes (I'm clarifying; I know you know this) to me are like interfaces, a c++ class with only pure virtual functions e.g.
00:22:20 <vincenz> what is the operator being defined
00:22:35 <vincenz> sethk: step away from interfaces
00:22:37 <vincenz> sethk: ducktyping1
00:22:47 <vincenz> where each haskell class gives you certain methods
00:22:50 <Cale> MonadState is a class which state monad type(constructors) belong to.
00:22:56 <Speck> I dunno. I was never big on ducktyping even when I was using Ruby.
00:22:59 <Cale> s is the type of state being carried around
00:23:03 <sethk> vincenz, I'm not familiar with that term but I'm very familiar with both c++ and ruby.  So use terms that are more generally understood
00:23:04 <Cale> and m is the monad constructor
00:23:12 <vincenz> Cale: that would be a class with a constructor containing one inner thing
00:23:12 <Cale> and m determines s
00:23:30 <vincenz> class MonadSate; def initialize(s); @s=s;end;end
00:23:39 <vincenz> tho typed of course
00:23:57 <vincenz> sethk: if you know ruby, you know ducktyping
00:24:09 <sethk> vincenz, I said I don't know the _term_ ducktyping
00:24:24 <vincenz> sethk: you don't have to derive from an interface having a method definition to pass the class to a place that requires that the obejct derives from that interface
00:24:49 <vincenz> interfaces are obsolete
00:24:58 <vincenz> hence so are pure virtuals
00:25:10 <Cale> hmm, I'm not sure that's really the same.
00:25:19 <sethk> vincenz, I suppose if you don't mind giving up compile time error detection"
00:25:19 <JohnMeacham> sethk: true.
00:25:32 <vincenz> sethk: hence my idea....using HASKELL type classes
00:25:41 <vincenz> with full typing, instead of the flimsy dynamic typing
00:25:49 <dons> @type H4SH.List.tokens
00:25:50 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
00:25:56 <dons> sethk: ^^
00:26:14 <sethk> vincenz, it's not really anything different.  It is just the same old find the errors at compile time (c++, java) or not until run time (smalltalk, ruby)
00:26:27 <vincenz> sethk: I think you're not understanding what I am saying
00:26:44 <vincenz> sethk: syntax wise: ruby, type wise: haskell
00:27:00 <vincenz> use type classes as a substitute for the ducktyped classes in ruby, thereby shifting it to compiletime
00:27:15 <sethk> vincenz, why is that any better than what c++ and java do?
00:27:29 <vincenz> sethk: you don't need to define interfaces
00:27:31 <JohnMeacham> one of haskells greatest things is its syntax :) I am so glad it is based on miranda and not ML.
00:27:41 <Cale> sethk: type inference?
00:28:03 <vincenz> so you get the gains of ruby: not having to define pointless interfaces, and the typing of haskell: stricter typing than javan and c++
00:28:04 <Speck> vincenz: if you're really going to learn haskell, your haskell implementation should differ greatly, and you'll probably find that you won't use type classes in the same way that you would ducktyping in your ruby version. However, the only way to know for sure is to dive in! :-)
00:28:15 <JohnMeacham> vincenz: have you seen 'sather' it decouples class inheritence from code reuse, and ends up with something more similar to polymorphic haskell typeclassesp
00:28:32 <vincenz> JohnMeacham: ah, I haven't, thanks :)
00:28:48 <sethk> vincenz, I don't really see a practical difference between being an instance of a haskell style class or deriving from a base class with virtual functions.
00:28:57 <sethk> vincenz, same amount of work, same amount of typing
00:29:15 <sethk> you aren't inferring anything that you aren't explicitly declaring
00:29:38 <vincenz> sethk: so then in your point of view, templates are pointless
00:29:40 <JohnMeacham> vincenz: it was the language that made me realize there was more out there than the standard OO world, which eventually led to my discovery of haskell. sather has a great OO model, I don't know why other languages didn't pick it up.
00:30:02 <vincenz> I think templates are a small step in the direction of typeclasses with HORRIBLE syntax
00:30:28 <sethk> vincenz, I agree, templates are awful from the developer perspective
00:30:39 <vincenz> sethk: yet they're very useful
00:30:43 <sethk> vincenz, indeed
00:30:49 <vincenz> they allow me to do many things without having to incur the virtual cost
00:30:54 <vincenz> the idea is to drive it further
00:31:02 <sethk> vincenz, but I still don't see where you are going further
00:31:02 <JohnMeacham> vincenz: have you seen the HList stuff? you don't have to declare those and can fill them with rank-n functions giving you something much more powerful than most OO systems.
00:31:13 <vincenz> JohnMeacham: HList?
00:31:17 <Speck> hmm... weird error installing cabal cvs:  Error: file does not exist: "ranlib"
00:31:30 <JohnMeacham> umm.. the paper is called 'haskell's overlooked object system' or something like that...
00:31:38 <vincenz> sethk: ah, I'll look into it, thanks
00:31:45 <Cale> yes, check out the HList paper if you want to have a real idea of what typeclasses are about :)
00:31:55 <sethk> vincenz, you mean JohnMeacham , not me.  I'm not that smart.  :)
00:32:01 <vincenz> yip
00:32:07 <JohnMeacham> http://homepages.cwi.nl/~ralf/OOHaskell/  - very fascinating
00:32:22 <sethk> Speck, ranlib is the old bsd library thing.  it is supposed to be a noop program on other UNIXs
00:32:27 <Cale> Not even OOHaskell, but the paper before that :)
00:32:32 <sethk> Speck, *NIXs I guess is the term.
00:32:52 <sethk> Speck, what machine are you on?
00:32:59 <Speck> I have ranlib though... OS X
00:33:01 <vincenz> sethk: basically...Yes you're right, computation wise it's the same... But !  There is an important difference, virtual function calls can be expensive, that is why not all data types in c++ derive from a common interface/class (not even in java).  In ruby they do, but as you can tell, the performance goes down tremendously... By using typeclasses you'd shift the finding of the correct method to compiletime, leading to serious gains in perfo
00:33:11 <sethk> Speck, hm, path thing maybe?
00:33:15 <vincenz> s/computation wise/computerprogramming wise/
00:33:17 <sethk> Speck, some sort of build glitch
00:33:26 <Cale> http://homepages.cwi.nl/~ralf/HList/
00:33:28 <Speck> sethk: nope, this installer is just being stupud
00:33:29 <JohnMeacham> basically they show how you can just write a fully typesafe object system in ghc haskell that is more general and powerful than the built in systems of other languages. and with much stronger typing guarentees.
00:33:41 <sethk> Speck, ok, that's true regardless  :)
00:34:07 <Speck> any cabal hackers in the audience?
00:34:09 <JohnMeacham> Yeah, the OOHaskell stuff builds on the HList stuff. but you can read them in either order.
00:34:13 <sethk> vincenz, what I still don't see is what you've gained over c++ and java.  ruby and smalltalk resolve those at runtime, but c++ and java do not.
00:34:23 <sethk> vincenz, true, they carry a virtual table, but not the level of overhead
00:34:32 <sethk> vincenz, very different than ruby and smalltalk
00:34:44 <vincenz> sethk: c++ and java do
00:34:50 <vincenz> ever heard of a virtual function table?
00:34:55 <sethk> vincenz, so if you don't make that distinction, you are talking just as much about a difference between ruby and c++ as you are a difference between a hypothetical system and c++
00:35:07 <vincenz> and otoh, c++ and java require interfaces
00:35:07 <sethk> vincenz, if you would read what I wrote, you would find the term in my sentence
00:35:10 <vincenz> yes
00:35:14 <vincenz> I typed too fast
00:35:15 <sethk> vincenz, I do know how c++ and java and ruby work
00:35:43 <sethk> vincenz, given the well known performance issues with haskell, I just don't see that your proposal gains anything in the real world.
00:35:57 <vincenz> sethk: I think the performance issues of haskell have to do with lazyness
00:36:03 <vincenz> not typeclasses
00:36:05 <Cale> class HNat n; data HZero; data HSucc n; instance HNat HZero; instance HNat n => HNat (HSucc n)
00:36:36 <Cale> Type level naturals :)
00:36:40 <sethk> vincenz, well, as a blanket statement it isn't correct.  lazyness is certainly not the only issue.
00:37:00 <mflux> what kind of performance increases did eager haskell offer?
00:37:02 <sethk> vincenz, you would have to do a proper analysis of exactly what happens in your implementation before you can say anything meaningful about performance
00:37:20 <vincenz> sethk: well I think that in theory, static typing can get you much faster than dynamic typing
00:37:35 <Cale> and they define things like HTrue and HFalse, (type-level booleans), and HEq, an equality testing class for type level naturals.
00:37:38 <sethk> vincenz, and I responded that c++ is 100% statically typed
00:37:46 <vincenz> Cale: what is this?
00:37:53 <Cale> class HBool b => HEq x y b | x y -> b
00:37:54 <vincenz> sethk: and c++ has a horrible oo system
00:38:00 <Cale> this is from the HList paper
00:38:01 <sethk> vincenz, don't change the subject
00:38:05 <vincenz> sethk: I'm not
00:38:09 <vincenz> sethk: c++ is not fully oo
00:38:10 <sethk> vincenz, sure you are
00:38:17 <vincenz> I want full oo, with static typing
00:38:19 <sethk> vincenz, you are saying you get gains from static typing
00:38:31 <sethk> vincenz, you don't get gains from static typing when comparing to a language with static typing
00:38:32 <vincenz> sethk: the reason c++ has gains is because it drops oo in the parts where it gains
00:38:43 <sethk> vincenz, well, that's arguable
00:38:45 <vincenz> meaning tradeoff programmer time compiletime
00:39:00 <sethk> vincenz, there really is nothing in the OO conceptual framework that requires run time dispatching
00:39:10 <sethk> vincenz, dynamic run time dispatching
00:39:14 <vincenz> if you stick to ruby like idiom, everything is an object, and then substitute objectlasses for typeclaases, you have full oo but return to static typing
00:39:21 <lament> sethk: except Alan Kay's word :)
00:39:26 <sethk> vincenz, I'm not sticking to ruby
00:39:37 <sethk> vincenz, if you have to stick to ruby to make your point, your point is very weak
00:39:57 <vincenz> sethk: I think you're missing my point
00:40:03 <Cale> seriously, check the HList paper out, as it is a good example of how Haskell typeclasses can do things which are nothing like OO classes :)
00:40:16 <vincenz> Cale: I will :)
00:40:52 * Speck waves his hands to call attn to his problem :-(
00:41:06 <sethk> Speck, sorry, got a bit carried away there.  :)
00:41:16 <Cale> oh, sorry Speck, what's your problem?
00:41:53 <Speck> compiling cabal cvs on OS X, the install phase hits an error with Cabal itself
00:42:02 <sethk> he's getting a message about ranlib on osx
00:42:11 <Speck> it tries to find ranlib in Distribution/Simple/Install.hs
00:42:16 <Speck> grep for ranlib
00:42:42 <Cale> is ranlib in the path?
00:42:45 <Speck> and I don't know how rawSystemVerbose is called, but it doesn't look like it's being called correctly -- I'm not sure though
00:42:49 <Speck> Cale: yes it is
00:43:14 <Speck> but calling rawSystemVerbose like this shouldn't work: rawSystemVerbose verbose "ranlib" [libTargetLoc]
00:43:40 <Speck> they don't even use the path string, just "ranlib", which makes me think it's a bug that just never got tested
00:45:30 <Cale> rawSystemVerbose is less than verbosely documented
00:45:46 <Cale> I'm not sure if it should want a path
00:46:31 <Speck> well, I changed "ranlib" to ranLibLoc and it compiled
00:46:43 <Speck> oh, it always compiled, it needs to install! (stupid me)
00:47:00 <Cale> it should compile so long as you pass a string :)
00:47:11 <Speck> yeah, I get the same error, which isn't actually raised at the cabal level I don't think
00:47:26 <Speck> file does not exist: "ranlib"
00:47:31 <Cale> hrm
00:47:48 <Cale> what are you trying to install?
00:48:06 <Speck> cabal cvs
00:48:25 <Speck> funny, because cabal uses itself to install itself
00:48:41 <Speck> just a quick bootstrap makefile
00:49:06 <Speck> compiles Setup.lhs to an executable (sorry I'm talking on so many lines...)
00:49:49 <Cale> it's fine :)
00:50:00 <Cale> I'll grab the darcs version and see
00:50:06 <Speck> thanks :-D
00:50:32 <Speck> unfortunately the error only shows on ./setup install step
00:51:24 <Speck> ooooh the error I'm getting is actually coming from rawSystemVerbose
00:51:43 <Cale> yeah, I want to see the implementation of that, if it's in cabal
00:52:00 <vincenz> hmm
00:52:21 <vincenz> seems boo comes closer to what I want (but not fully yet as it's still based on c# underneath, so no higher order typing)
00:53:03 <Speck> doesFileExist definitely wants a path
00:53:11 <Speck> so rawSystemVerbose definitely wants a path
00:53:13 <sethk> vincenz, if your concept is valuable you won't find a ready made solution.  If it is close, you should be able to establish the value of your concept.
00:53:49 <sethk> vincenz, perhaps show a couple of concrete examples for people like me who care about the practical as well as theoretical side of things
00:54:11 <sethk> vincenz, I wasn't saying it's not a good concept, I was saying you haven't proved that it is (or isn't) a good concept.
00:54:18 <Speck> I don't think findExecutable in Distribution/Compat/Directory.hs is returning a full path
00:54:48 <vincenz> sethk: I know, I need to think it through more, it's in my head but not crystal clear yet, more of a feeling
00:54:53 <vincenz> anyways, time to go to wok
00:54:54 <vincenz> work
00:55:41 <ProfTeggy> Morning all.
00:55:48 <Cale> morning
00:56:00 <Cale> Speck: it looks like findExecutable should work
00:56:36 <Cale> but rawSystemVerbose doesn't use it
00:57:11 <Speck> no, the ranlib code uses it, ignores the result, and passes "ranlib" to rawSystemVerbose
00:57:21 <Speck> which pretty clearly needs the full path
00:57:29 <Speck> or maybe not?
00:57:45 <Cale> where is the ranlib code?
00:57:50 <sethk> what's the haskell data structure that is like a python dictionary?  A collection with lookup, most likely a hash table?
00:58:03 <mflux> Data.Map
00:58:08 <Cale> Distribution/Simple/Install.hs?
00:58:19 <Speck> ok, yeah, findExecutable does return the whole path
00:58:35 <Speck> oh durr... I need to remake the ./setup script with the makefile again! duh!
00:58:41 <Cale> oh
00:58:45 <sethk> mflux, thanks.  My internal symbol table confused that with map in Data.List.    :)
00:58:58 <Cale> um
00:59:04 <Cale> that still looks like a bug
00:59:12 <Speck> yeah, there's a bug in cabal, I'll push a patch
00:59:32 <Cale> it should surely be using ranLibLoc
00:59:36 <Speck> yup
00:59:38 <Speck> and arLoc
00:59:51 <Cale> kind of funny that it goes to all that trouble and then doesn't use them :)
01:00:16 <Speck> probably just a brain-fart on the part of whoever was working on that
01:03:06 <Speck> sigh I really want a faster computer :-(
01:06:35 <sethk> I just got the type system to do something seriously impressive and I didn't even have to beg for help.  :)
01:08:13 <Speck> sethk: what'd you get it to do?
01:08:52 <sethk> create a Data.Map with a specific key type and abstract value type without having any keys or values handy
01:08:52 <JohnMeacham> is anyone working on a 'standard' cabalized distribution of HList ond OOHaskell? or are they still too experimental.
01:09:26 <Speck> I thought OOHaskell was distributed by itself
01:09:47 <sethk> is OOHaskell an active project?
01:09:53 <Cale> yep
01:09:58 <JohnMeacham> Also, does anyone have any pointers to information on writing efficient interpreters in haskell? I mean, it is really easy and fun to write interpreters in haskell, but I am particularly interested in doing it efficiently.
01:10:09 <sethk> I thought someone said it was defunct.  Must be confusing it with another
01:10:22 <Cale> probably O'Haskell
01:10:37 <sethk> Cale, I think so.  Definitely a similar name
01:10:42 <Cale> which has been replaced by Timber, but I'm not sure what Timber's been up to.
01:10:49 <Speck> Cale: yeah it works with those two lines changed
01:10:49 <Cale> http://homepages.cwi.nl/~ralf/OOHaskell/
01:10:52 <sethk> JohnMeacham, if you run into anything, can you let me know?  I'm writing one also.
01:10:56 <sethk> JohnMeacham, (seth@cql.com)
01:11:04 <JohnMeacham> Yeah, but it sort of packaged as just a set of examples rather than a sharable package.. like, I want to write libraries that use HList in their interface, which only works if everyone agrees on their hlist implementation and can install the same packaged version of it.
01:12:16 <JohnMeacham> In particular, my HsASA and GetOptions have a 'psuedo-HList' built of nested tuples, and a real HList in the interface would make more sense.
01:14:22 <Cale> sethk: did you use undefined?
01:14:35 <sethk> Cale, no, just a type signature
01:14:47 <sethk> Cale, and the definition of the abstract type
01:14:48 <Cale> ah, with the empty map :)
01:15:07 <sethk> Cale, not a big deal but three days ago I could not have done it
01:15:12 <Cale> :)
01:16:02 <Itkovian> @seen boegel
01:16:03 <lambdabot> boegel is in #haskell-blah and #haskell. Last spoke 18 hours, 15
01:16:03 <lambdabot> minutes and 22 seconds ago.
01:16:19 <jonasj> hello, anyone know anything about wxHaskell?
01:16:35 <Cale> I've used it a couple of times
01:17:13 <sethk> jonasj, I've installed it and written a few trivial programs
01:17:39 <jonasj> I need to lock an entryfield and indent the text in it to the right, but I can't find the attributes in the documentation
01:19:19 <Cale> enabled :: Attr w Bool
01:19:25 <Cale> Graphics.UI.WX.Classes
01:20:31 <jonasj> nice! thanks
01:20:34 <Cale> alignment :: Aligned w => CreateAttr w Align
01:21:01 <Speck> can't load .so/.DLL for: readline.5 (dlopen(libreadline.5.dylib, 10): image not found)     <-- ? (configuring hIDE)
01:21:11 <Cale> which means that you have to set it on creation
01:21:18 <Cale> that's in Graphics.UI.WX.Controls
01:23:34 <jonasj> k, do you know what sort of invalue Aligned uses? I.E to align it to the right, what parameter do I give it?
01:24:07 <Cale> AlignLeft, AlignRight, or AlignCentre
01:24:21 <jonasj> okay, thanks a bunch
01:24:24 <Cale> (which are the constructors of the data type Align)
01:25:39 <jonasj> thanks, it worked like a charm
01:27:18 <dons> speck:  hmm :/
01:27:31 <dons> you don't have readline installed?
01:27:37 <dons> and this is on the mac, right?
01:27:43 <Speck> I have readline installed
01:27:59 <Speck> I used darwinports to install ghc
01:28:02 <dons> ah, but it's a Cabal issue
01:28:21 <Speck> sigh, I just fixed a cabal issue! not another one! :-P
01:28:27 <dons> it's happening during Setup.hs configure?
01:28:31 <Speck> yeah
01:28:53 <dons> ok. so it's a Cabal issue
01:28:54 <Speck> want the verbose?
01:29:01 * dons wipes hands of the matter ;)
01:29:10 <Speck> :-(
01:29:14 <dons> nono, we shall consult Lemmih, master of Cabal
01:29:59 * dons wonders why readline is a dependency of hIDE
01:30:25 <Speck> it loads it after mtl, lang, and quickcheck
01:30:55 <dons> ok, sigh, I want to see this. post the output somewhere :)
01:31:01 <dons> @paste
01:31:02 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:31:03 <dons> perhaps
01:31:33 <Speck> too long for that
01:31:42 <Speck> and a little ot
01:31:46 <Speck> I'll use rafb
01:32:10 <dons> hmm, I was under the impression anything to do with haskell can get posted on @paste
01:32:16 <dons> oh well
01:32:40 <Speck> well I'm sure it could be, but I regularly scan that page for cool code snippets and wouldn't like finding this on there myself
01:32:56 <dons> ah, fair enough
01:32:58 <bourbaki> moin
01:33:17 <Speck> http://rafb.net/paste/results/o5gs4n24.html
01:34:26 <jonasj> Cale : do you know if it's possible to override the colors set by the enabled attribute? I've managed to change the background color, but the font refuses to comply.
01:34:47 <dons> huh, Speck, I'm confused.
01:34:50 <dons> is that all there is?
01:35:10 <dons> can you post the entire output of the command that triggers the error?
01:35:17 <dons> and what is the command you typed?
01:35:47 <Speck> err, I added the path to LD_LIBRARY_PATH and it appears to be working
01:35:56 <dons> oh, ok :)
01:35:58 <Speck> yup ;-) sorry
01:36:10 <dons> but still, what were you actually typing on the shell to trigger this?
01:36:21 <Cale> jonasj: hmm...
01:36:25 <Speck> runghc Setup.lhs configure --prefix=/opt/local
01:36:36 <dons> huh, ok. so that''s Setup.lhs getting compiled.
01:36:52 <dons> but then why is QuickCheck being loaded.
01:36:59 <dons> and readline?
01:37:00 <dons> weird.
01:37:02 <Speck> yeah
01:37:21 <dons> what happens if you use runhaskell?
01:37:24 <dons> instead of runghc
01:37:49 <Speck> ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1)   hahaha haskell hates me
01:37:53 <dons> are you using a -v flag?
01:37:54 <Speck> I don't have a runhaskell
01:37:59 <Speck> and yes I am using the -v flag
01:38:08 <dons> ok (that's not in the above string ;)
01:38:15 <Speck> oops, sorry
01:38:19 <Speck> it's late here
01:38:36 <dons> @timein Speck
01:38:39 <lambdabot>  Sorry, don't know this city
01:38:40 <dons> I really want that cmd
01:38:42 <Cale> http://wxhaskell.sourceforge.net/doc/Graphics.UI.WX.Classes.html#t%3AColored
01:38:48 <Speck> 4:38 AM
01:39:06 <Speck> @timein Baltimore, MD
01:39:08 <dons> :)
01:39:08 <Cale> jonasj: does setting the 'color' attribute work?
01:39:09 <lambdabot>  Friday, October 14, 2005 at 4:38:45 AM EDT
01:39:28 <mauke> @timein myhouse
01:39:29 <lambdabot>  Sorry, don't know this city
01:39:47 <Speck> using @timein <nick> could grab the lat/long from the user locations page and figure it out :-P
01:39:48 <Cale> http://wxhaskell.sourceforge.net/doc/Graphics.UI.WX.Controls.html#t%3ATextCtrl seems to indicate that the controls are instances of Colored
01:40:05 <dons> can someone thing of a way to map latitude and longitude to timezones?
01:40:10 <dons> think
01:40:18 <Cale> roughly?
01:40:20 <dons> I guess I could hard code them, oh. it's probably easy
01:40:39 <Cale> timezones aren't quite straight :)
01:40:42 <dons> well, exact would be better. using TZ
01:40:43 <jonasj> Cale: bgcolor worked but the text remains grey
01:41:04 <Cale> jonasj: perhaps simply because it's disabled...
01:41:10 <dons> using zoneinfo, perhaps
01:41:22 <araujo> Hello haskell'ers!
01:41:45 <jonasj> bummer, I guess I'll have to live with it. Thanks for the help
01:42:09 <dons> Cale, any ideas?
01:42:13 <dons> or maybe I'll google
01:42:14 <Cale> there ought to be a separate editable property
01:42:31 <Cale> dons: I'm not sure... there ought to be some "right way" to do it
01:42:41 <Cale> an approximation probably suffices :)
01:42:48 <dons> quite so.
01:43:24 <dons> I suspect one of the map/search pages will offerr both the local time and allow searching with coords
01:43:33 <sethk> dons, that's actually rather complex
01:43:47 <sethk> dons, oracle added an entirely new type and set of functions in order to do that
01:43:55 <dons> oh, nice :)
01:44:12 <sethk> dons, in particular finding the distance between two sets of coordinates turns out to be extremely difficult
01:44:14 <dons> lambdabot has http, so I only need to find a site that has oracle in the background :)
01:44:22 <dons> really?
01:44:24 <sethk> dons, which is similar to mapping time zones
01:44:24 <dons> why so?
01:44:35 <sethk> dons, I have to look it up, it was a couple of years ago that I worked with it
01:44:36 <Cale> http://img.factmonster.com/images/timezones.gif
01:44:51 <sethk> dons, there is an absolute ton of info about it on the web, you'll have no trouble finding it
01:44:55 <Speck> grumble grumble scannedinavian.org is down so I can't dl ghc-api
01:45:04 <sethk> dons, oracle's documentation is one place I know it exists
01:45:14 <sethk> dons, although I don't want to sentence you to reading that.  :)
01:45:32 <Cale> http://upload.wikimedia.org/wikipedia/en/4/4b/Timezones.png -- better yet
01:46:34 <Cale> kind of ridiculous :)
01:47:19 <dons> sethk, maybe this isn't the problem I want to solve.
01:47:34 <sethk> dons, it is not trivial, to say the least.  :)
01:47:47 <sethk> dons, damned curved surface planet
01:48:03 <dons> well, it seems intuitively easy to work out, given a set of timezones, which timezone a given pair of coords is in.
01:48:18 <kzm> Profiling problem: profiling claims three different inputs take approximately the same time.  (/bin/)time says otherwise.
01:48:28 <dons> which is all I actually want to do.
01:48:33 <sethk> dons, you can do a brute force with the coordinates of the time zone edges.  That wouldn't be all that difficult
01:48:41 <sethk> dons, mathematically ugly, but it would work.
01:48:47 <dons> ugly, but it would work.
01:48:52 <dons> and theere's not many timezones
01:48:58 <sethk> dons, yes, it's not bad because you only care about one of the two coordinates
01:49:02 <kzm> (i.e. three runs take 2.3-2.9s, wall clock (and time) says 3, 10 and 150s.
01:49:10 <dons> ah, basically true.
01:49:19 <kzm> any ideas?
01:49:21 <dons> though see e.g. iceland
01:49:32 <dons> kzm, profiling doesn't count system time
01:49:42 <dons> could that be the problem?
01:49:49 <sethk> dons, we do have someone from Finland.  Not sure about Iceland  :)
01:50:06 <kzm> dons: don't think so:
01:50:06 <dons> no one in svalbard?
01:50:08 <kzm> 122.63s user 0.36s system 99% cpu 2:03.19 total
01:50:49 <kzm> profiling claims: 2.96 secs   (148 ticks @ 20ms)
01:51:15 <kzm> There is, to put it nicely, an unexplained disagreement.
01:51:17 <dons> time spent garbage collecting?
01:51:33 <dons> or oetherwise in the rts?
01:51:37 <kzm> Possibly - how do I check?
01:51:56 <kzm> There is slightly more total alloc in the latter (long running) case - 466Mb vs approx 400.
01:52:11 <Cale> You clearly need both spherical coordinates: http://inms-ienm.nrc-cnrc.gc.ca/images/time_services_images/TZ01SSE.jpg :) -- where to get this map data in a convenient form though?
01:52:52 <kzm> The main difference, I should add, is that I use hashtables - quite a lot of them in the long-running case.  Are they expensive to - say - initiate, and could that - somehow - avoid being accounted?
01:53:33 <dons> hmm.  can't irc finger someone to find their machine's local time?
01:53:37 <dons> maybe that's *easier*
01:53:41 <Cale> :)
01:53:55 <Cale> -dons- TIME Fri Oct 14 18:47:28 2005
01:54:02 <dons> right!
01:54:18 <Cale> -Cale- TIME Fri Oct 14 04:53:51
01:54:32 <dons> though I'd still like a: @timefor Cale that's just a binding to this
01:54:43 <dons> so that means teaching lambdabot a new trick
01:54:45 <beelsebob_> hmm... The algorithm I want to use is gonna be shit in haskell...
01:54:48 <dons> but that''s easy :)
01:55:24 <Cale> I still think it would be really cool to have a haskell library which could map (lat,long) to a time zone
01:55:27 <Cale> :)
01:55:32 <beelsebob_> Anyone think of a good way of doing this: I have a tree, I need to assign a property to items in the tree, and then traverse it in order of that property
01:55:43 <Cale> Bonus points if it can tell both the observed and legislated time zone :)
01:55:45 <dons> that would be cool yes. and useful!
01:55:56 <beelsebob_> with each move in the tree, the properties will change
01:56:02 <beelsebob_> anyone got any ideas?
01:56:52 <dons> traverse in order of the property
01:56:54 <dons> hmm
01:56:58 <Cale> beelsebob_: sorry, I'm not sure exactly what it is that what you said means
01:57:11 <beelsebob_> tree, easy, right?
01:57:14 <Cale> yes
01:57:19 <Cale> rose tree?
01:57:20 <dons> tree: easy
01:57:25 <beelsebob_> each branch in the tree is assigned some number
01:57:26 <Cale> or binary?
01:57:31 <Cale> okay
01:57:35 <beelsebob_> n-arry tree
01:58:01 <beelsebob_> I need to make a traversal of said tree in order of the value of that number
01:58:02 <Cale> data Tree a = Branch a [Tree a]
01:58:10 <beelsebob_> yep, that exactly
01:58:27 <beelsebob_> with each move I will make a decision:
01:58:36 <beelsebob_> 1) look within the subtree, and renumber it
01:58:38 <Cale> Okay, hmm... what sort of runtime can we get here -- do we know the size of the tree beforehand?
01:58:47 <beelsebob_> 2) have to jump back up to where I was before and carry on
01:59:19 <beelsebob_> the tree is pottentially huge, but I'm prepared to ignore anything below the n-th level of it for efficiency's sake
01:59:28 <Cale> things are lazy :)
01:59:53 <Cale> If you can avoid observing parts of the tree which aren't needed, they won't be generated
01:59:53 <beelsebob_> well no, what I'm saying is I won't bother looking at the values assigned to nodes below level n
01:59:59 <beelsebob_> to save searching the whole tree
02:00:04 <beelsebob_> (and save generating it)
02:00:39 <Cale> This number is computed by some function, or it's just recorded on the nodes?
02:01:12 <Cale> I suppose that doesn't matter too much
02:01:29 <beelsebob_> both
02:01:34 <Cale> What does renumbering consist of?
02:01:42 <beelsebob_> it's recorded... but will be updated regularly
02:02:22 <beelsebob_> renumbering involves looking at each node in the tree... which is it's self a graph, and doing some fairly heavy duty analysis
02:03:04 <beelsebob_> see the way I want to do it is just to have Tree (Int, NodeExp) and jeep updating
02:03:13 <beelsebob_> but that's gonna involve *lots* of in place updates
02:03:19 <beelsebob_> which Haskell is going to suck at
02:03:41 <Cale> well, you could use STRefs
02:03:46 <beelsebob_> bleh
02:03:50 <dons> dblhelix: http://www.haskell.org/hawiki/HaskellUserLocations :D add your details!
02:03:51 <beelsebob_> a bit hacky
02:04:00 <beelsebob_> I'd rather have a neat algorithm
02:04:03 <dblhelix> dons: I will :)
02:04:05 <Cale> well, if you want in-place updates, that's what it is :)
02:04:18 * kzm sighs.
02:04:38 <beelsebob_> I was considering having a Tree NodeExp, and a [(Int, Tree)] that keeps track of the values at each point in the tree
02:04:43 <Cale> but it is probably better to think some about how to do it in a pure fashion :)
02:04:46 <beelsebob_> because then I only have to update the list, not the tree
02:04:57 <dons> yeah, it's not hackish in fact. you're being explict about your destructiveness :)
02:04:57 <Cale> What problem are you solving?
02:05:14 * kzm is thinking about quitting his job and get rich programming PowerPoint for some consultant company.
02:05:20 <dons> but , like Cale says, see if you can solve it without resorting to side effecting evil
02:05:20 <beelsebob_> my delta debugging
02:05:43 <beelsebob_> yeh... I'm just trying to think up the non-evil solution
02:05:46 <beelsebob_> *g*
02:05:52 <Cale> delta debugging?
02:06:03 <dons> kzm, programming PowerPoint. this isn't some secret norwegian functional language I guess :/
02:06:27 <Speck> is cpphs cabalized? I downloaded the sources and it has a cabal description file, but not Setup.(l)hs
02:06:28 <kzm> No, it means telling people what they already know, but charging a lot for it.
02:07:02 <beelsebob_> cale: http://www.cs.kent.ac.uk/people/rpg/tatd2/ifl05.pdf
02:07:17 <kzm> ..because, as well all know, the value of knowledge is proportional to the price.
02:07:27 <dons> hehe
02:07:29 <bourbaki> Cale are you familiar with coalgebras?
02:08:22 <Cale> bourbaki: in a very limited way
02:08:38 <bourbaki> Cale do you maybe know how they relate to monads?
02:08:50 <kzm> Is an array of (Maybe a) going to be a lot slower than an (array of bool,array of a)?
02:09:05 <kzm> (using IO(U)Array or similar)
02:09:19 <Cale> bourbaki: they seem more related to comonads
02:09:19 <bourbaki> i thought that the return is like a coalgebraic thingy while the monadic operation are then operations on processes in the term of coalgebras
02:09:24 <kzm> I expect the Maybe might add an overhead of one word per datum.
02:09:53 <bourbaki> well monads are just a way to deal with processes and these processes are used in coalgebras that is the return is a coalgebraic function
02:10:12 <bourbaki> while the monadic operatios are of algebraic quality
02:10:17 <dons> you could unpack the 'a' possibly into the Maybe, then you save the indirection
02:10:24 <dons> into the Just.
02:10:25 <bourbaki> in a comonad this is the other way around
02:10:43 <bourbaki> the return is an albebraic function and the comonadic operators are coalgebraic
02:11:24 <Cale> join is algebraic
02:11:31 <kzm> dons, exactly.  And from - I think - Tomasz' experiments, IOUArray Int Bool is really efficient. Using - I think - 1 bit per Bool.
02:11:32 <Cale> split is coalgebraic
02:11:45 <bourbaki> yep i thought about the return thingy though also
02:11:45 <Cale> in some loose sense
02:11:48 <bourbaki> ie
02:12:02 <Cale> oh, yeah
02:12:07 <Cale> unit and counit
02:12:07 <dons> really? 1 bit per Bool. hmm.
02:12:10 <bourbaki> if you want to describe an automaton you map from S -> (A -> S)
02:12:13 <dons> maybe GHC does some magic for this case
02:12:21 <bourbaki> while S is a state and A is an alpha bet
02:12:23 <dons> instead of the usual 32 bits per Bool
02:12:29 <bourbaki> this really looks like the return
02:13:04 <dcoutts> kzm, yes that's right it does use a packed bit array
02:13:14 <kzm> dons: I seem to remember it was so.  Could be wrong, of course.  I can try to look it up - think it was Sieve of Eratosthenes or something.
02:13:18 <Cale> bourbaki: hmm
02:13:23 <kzm> dcoutts, Okay.
02:13:33 <dons> ah, /me dives into this code to check.
02:13:45 <dons> without even using associated types, I guess ;)
02:13:49 <dcoutts> kzm, which of course means it's slower on lookup/modify than a IOUArray Int Word8
02:13:54 <bourbaki> Cale and these thinies i have there these S -> (A -> S) are used for the coalgebraic notion of automatons
02:13:56 <kzm> so likely that a separate Just/Nothing-array will save me time and (especially) space.
02:14:42 <kzm> Well - there will be some bitwise ops, but they should be fast.  If the array is large - larger than L1 or L2 - it might not matter much.
02:14:42 * beelsebob_ notes that his new laptop is actually capable of keeping up with this stream
02:14:45 <beelsebob_> :)
02:14:48 <Cale> :)
02:15:14 <bourbaki> is there a general lib for haskell with automatons and monads?
02:16:05 <Speck> ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1): unknown exception
02:16:21 <Speck> I'm getting these errors when I build ghc-api, is that because I'm not using 6.5?
02:16:23 <Cale> beelsebob_: that's rather cool
02:16:24 <dblhelix> dons: added
02:16:35 <beelsebob_> cale: why thank you :)
02:16:52 <kzm> I am basically trying to do fast word frequency counts, if anybody is interested.  In particular, I'm having a hard time trying to come up with a suitable data structure.
02:16:59 <dons> dcoutts, got a ref for where this packed array representation is defined?
02:17:15 <dons> i've not seen such a thing in all my fptools-browsing days :}
02:17:42 <Cale> beelsebob_: is there some way to tie the implementation to GHC such that it doesn't go out of date when new extensions/libraries come along?
02:18:03 <beelsebob_> cale: no... it's going to use standard Haskell 98
02:18:08 <beelsebob_> it's being implemented on Hat
02:18:17 <beelsebob_> (and is compatable with nhc, and yhc)
02:18:22 <beelsebob_> ... and ghc of course
02:18:25 <Cale> right
02:18:38 <Cale> so I take it these trees are evaluation trees?
02:18:46 <beelsebob_> the trees are EDTs
02:18:50 <beelsebob_> the graphs with in them are traces
02:20:09 <sethk> kzm, Data.Map?
02:20:11 <Speck> hmm... apparently autrijus got the same error compiling ghc-api that I did
02:20:45 <Cale> kzm: I wrote some code for that
02:22:03 <Cale> kzm: let me update it to use Data.Map, it's old :)
02:22:23 <kzm> Data.Map takes too much space.  Direct array only works for small word sizes.  Hash tables seem to slow down for long words (Int64-size) and large data.
02:23:00 <kzm> The current idea is to combine a direct array (taking the first part of the word) pointing to a hash table for the rest of the world.
02:23:25 <kzm> That way, the HT can work on smaller size data also (since it needs to store the key as well as the value)
02:23:25 <dons> MarcWeber: you should add your details: http://www.haskell.org/hawiki/HaskellUserLocations :D
02:24:10 <kzm> (The words in question are (overlapping) k-tuples of {ACGT}, btw.  Not text)
02:24:26 <MarcWeber> dons: Wow.. What is this? ;)
02:24:29 <Cale> Data.Map takes too much space?
02:24:36 <Cale> oh
02:25:23 <Cale> perhaps a trie?
02:26:16 <ProfTeggy> Hi Marc.  You're from Konstanz?
02:26:22 <kzm> Cale, well, that's kind of what I have in the first step - but wider than one char.
02:26:34 <Cale> how many words are you talking about, approximately?
02:26:40 <musasabi> kzm: write a binding to judy.
02:26:55 <sethk> kzm, What Cale just suggested is interesting (it is used in some data compression programs for a similar purpose).  The trie let's you find matching initial strings.  If you only care about whether the word matches (rather than part of the word or the beginning of the word), hashing the entire word would absolutely be faster than any other method.
02:27:02 <MarcWeber> dons: Before I call myself a haskell "user" I want to get started with the stuff I want to do ;) At the moment I'm struggling with compiling hdirect on win and happy ;)
02:27:15 <MarcWeber> ProfTeggy: I am
02:27:17 <dons> no, it's a #haskell user, which you clearly are :)
02:27:24 <tomaszz> dons: I just added myself to HaskellUserLocations :-)
02:27:25 <sethk> 'night all.  Actually 5:30 am here.  If I don't sleep the sun will come up and I'll turn into a vampire.
02:27:35 <ProfTeggy> MarcWeber, I've been at U KN from 1994 til 2004.
02:27:35 <sethk> see everyone in a few hours.   :)
02:27:51 <MarcWeber> ProfTeggy: kosmikus has been here, too
02:27:52 <Cale> kzm: how many words are you talking about?
02:27:59 <ProfTeggy> MarcWeber, first PhD student, then Asooc.Prof. in the CS dept.
02:28:07 <dons> anyway, if you (or anyone!) add their coords, the image gets recomputed every few hours. so feel free to fill in the missing .de people!
02:28:08 <ProfTeggy> MarcWeber, I know.  He was attending my FP class ;-)
02:28:14 <kzm> Cale, I'd like to be able to handle - oh, a data set size of 100M at least.
02:28:26 <dons> tomaszz, cheers!
02:28:28 <kzm> Cale, the actual number of different words will be smaller, of course.
02:28:56 <tomaszz> dons: hi
02:28:57 <kzm> In the end, I also want to store the set of positions for each word, but that can use a different data structure.
02:29:20 <MarcWeber> ProfTeggy: Failed in math, no IK3,4 Schein, no luck with girl friend.. (didn't tidy up her room.. had some light kind of depression.. ;) Ok. That's enough. Have you already used happy?
02:29:23 <dcoutts> dons, sorry I don't. I just remember it's what JaffaCake told me.
02:29:35 <dons> ah, ok. so maybe it *is* ghc magic
02:29:37 <kzm> musasabi, yes, I'm more or less drifting towards that - so an FFI to Judy might be the simplest way.
02:29:46 <dons> because I can't find any super-rewrite rule in the src
02:29:47 <ProfTeggy> MarcWeber, the parser gen?  Yes.
02:30:00 <dons> (and I thought you needed associated types to do this trick anyway)
02:30:24 <dons> but the compiler can certainly do this, and does similar stuff for other types
02:30:33 <dons> i.e. [Int] of small values gets packed too
02:30:48 <kzm> sethk, stone.  The sun turns things (trolls in particular) to stone.  Vampires turn to dust, I think.
02:31:16 <Cale> okay, I'll test my algorithm on a 150MB file :)
02:31:39 <sethk> kzm, once I turn to either stone or dust I have difficulty communicating
02:31:43 <MarcWeber> ProfTeggy: Can you tell me how to use the compile the first example given in the documentation? Or do you have another simple working example?
02:31:45 <dcoutts> Speck, if you're missing renderWithDrawable then it's because either you don't have the cairo C libs installed or you don't have Gtk+ 2.8.x. You need both for the Gtk+/cairo integration bindings to be built.
02:31:49 <Cale> I believe that it runs in space which is only dependent on the number of words.
02:31:53 <kzm> sethk, well - my current attempt as well as the direct array lookup is kind of a trie - the first few levels of it.
02:31:55 <MarcWeber> dons: How to add myself?
02:32:14 <kzm> Cale, but with a certain constant overhead.
02:32:21 <sethk> kzm, ok.  I'd like to know more about what you are doing.  I hope you'll be here when I get back.
02:32:29 <Speck> dcoutts: the cairo bindings are registered with ghc-pkg
02:32:41 <Cale> Map.toList $ Map.fromListWith (+) (zip wds [1,1 ..])
02:32:51 <kzm> sethk, appreciate it.
02:33:16 <kzm> sethk, it's kinda lonely to be the only Haskell programmer in the country, surrounded by Perlites and Pythonistas.
02:33:20 <kzm> :-)
02:33:31 <Speck> dcoutts: and I have the cairo libs and includes, as well as gtk+ 2.8.x
02:33:51 <kzm> sethk, so the onus is on me to demonstrate the superiority of my Kung Functional.
02:33:56 <Speck> dcoutts: I made sure that gtk2hs compiled with cairo support
02:34:03 <dons> MarcWeber, just edit the wiki page, or /msg the coords to me, and I'll add them
02:35:17 <dcoutts> Speck, oh and your c2hs question. If you're using the most recent c2hs version 0.14.x then it doesn't provide a ghc package any more.
02:35:53 <Speck> dcoutts: thanks I figured that one out :-)
02:36:10 <Speck> is there anyway to see what is in scope with ghci?
02:36:48 <ProfTeggy> MarcWeber, which example specifically?
02:38:36 <dcoutts> Spark, :b <module>
02:38:44 <dcoutts> err Speck I mean.
02:39:38 <dcoutts> Speck, which Gtk2Hs version are you using exactly? a released tarball or the darcs version?
02:41:00 <Speck> dcoutts: darcs, also, the cairo demo compiles if I add "import Graphics.UI.Gtk.Cairo" where renderWithDrawable is defined
02:41:39 <Speck> (and it works)
02:41:53 <Speck> (very pretty too)
02:42:55 <dcoutts> Speck, hmm the top level module should export it too
02:43:11 <Speck> hmm... actually, I have the cvs version, not darcs
02:43:14 <Speck> is that bad?
02:43:32 <dcoutts> Speck, I changed that last night actualy so it unconditionally exports the Graphics.UI.Gtk.Cairo module
02:43:57 <dcoutts> Speck, oh darcs/cvs whatever, one's a mirror of the other
02:44:16 <Speck> ok. I'd rather be using darcs but I didn't see it when I was looking
02:44:23 <dcoutts> the cvs is still the master, darcs is the mirror
02:44:48 <dcoutts> Speck, yes the darcs mirror is rather recent
02:44:59 <dcoutts> darcs get http://haskell.org/gtk2hs/darcs/gtk2hs/
02:45:02 <Speck> cool, well I'll update and see if it works
02:45:22 <Speck> hm... do you have any ideas about my ghc `impossible occurance' when compiling ghc-api?
02:45:38 <Speck> unknown exception
02:45:39 <dcoutts> dons, btw you seem to have missed the src/Yi/UI.hs module
02:46:00 <dcoutts> Speck, some people get it some don't. We have not been able to track it down.
02:46:59 <Speck> I haven't been able to get any debug information
02:47:47 <dcoutts> Speck, does -v help to naoorw down which module is causing the problem?
02:47:53 <MarcWeber> ProfTeggy: http://www.haskell.org/happy/doc/html/sec-using.html code boxes excluding 2.1. But the example given by 2.1 would be nice, too. I've used lynx -dump and removed the text, added some import lines to the header. But I get an error. Here is my resulting .y file http://www.rafb.net/paste/results/RtrdfZ49.html
02:47:55 <dcoutts> naoorw/narrow
02:48:13 <Speck> dcoutts: not that I can see, it happens immediately after "building ghc-api..."
02:48:43 <dcoutts> Speck, oh with cabal? then use ./Setup.lhs build -v
02:49:12 <Speck> k
02:49:58 <Speck> @paste
02:49:59 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:50:15 <tomaszz> @hoogle a -> [a -> a] -> a
02:50:18 <lambdabot> Prelude.(^) :: (Num a, Integral b) => a -> b -> a
02:50:18 <lambdabot> Prelude.const :: a -> b -> a
02:50:18 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
02:51:57 <tomaszz> it would be nice if lambdabot could answer: foldr ($)
02:52:52 <kosmikus> that'd make the search space too large, I think
02:52:58 <MarcWeber> dons: 47 40' (north) , 9 10' (east)
02:53:12 <tomaszz> yeah, it could be difficult
02:53:16 <kosmikus> but if you first do your query, and then ask again "why" foldr fits the query, this answer would be nice
02:53:18 <Speck> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:54:03 <tomaszz> kosmikus: is there a @why command?
02:54:16 <kosmikus> tomaszz: no, I don't think so
02:54:42 <dcoutts> Speck, oh I see. Try building the GHC module manually with ghc --make
02:54:50 <kosmikus> tomaszz: you should talk to the hoogle author ;)
02:54:57 <Cale> ndm
02:55:05 <ndm> Cale
02:55:05 <tomaszz> I wonder if somebody tried to create such a tool before
02:55:06 <kosmikus> yes, that's him
02:55:15 <Cale> people are talking about you :)
02:55:17 <ndm> ah, yes, i am the hoogle author
02:55:21 <dcoutts> Speck, ghc -Isrc/cbits/ -Isrc/ -Isrc/nativeGen/ -Isrc/stage1 -Isrc/parser -package-name
02:55:21 <dcoutts> ghc-api -odir dist/build -hidir dist/build -hide-all-packages --make -i -isrc/coreSyn -isrc/nativeGen
02:55:21 <dcoutts> -isrc/prelude -isrc/simplCore -isrc/typecheck -isrc/utils -isrc/cmm -isrc/cprAnalysis -isrc/ghci
02:55:21 <dcoutts> -isrc/javaGen -isrc/ndpFlatten -isrc/profiling -isrc/simplStg -isrc/stgSyn -isrc/types -isrc/codeGen
02:55:21 <dcoutts> -isrc/deSugar -isrc/hsSyn -isrc/main -isrc/parser -isrc/specialise -isrc/stranal -isrc/iface -isrc/rename
02:55:22 <dcoutts> -isrc/basicTypes -#include "src/parser/hschooks.h" -cpp -fglasgow-exts -DGHCI -DUSE_READLINE
02:55:26 <dcoutts> -ignore-package lang -v0 -package template-haskell-1.0 -package readline-1.0 -package unix-1.0
02:55:28 <dcoutts> -package Cabal-1.1.4 -package base-1.0 -package haskell98-1.0 GHC
02:55:30 <dcoutts> eek!
02:55:31 <Cale> ah
02:55:32 <dcoutts> sorry
02:55:40 <ndm> but i got into the chat room just after whatever it was that was being said :(
02:56:00 <tomaszz> OK, I'll repeat...
02:56:03 <tomaszz> @hoogle a -> [a -> a] -> a
02:56:05 <lambdabot> Prelude.(^) :: (Num a, Integral b) => a -> b -> a
02:56:05 <lambdabot> Prelude.const :: a -> b -> a
02:56:05 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
02:56:06 <Speck> dcoutts: where do I run ghc --make ?
02:56:08 <tomaszz> it would be nice if lambdabot could answer: foldr ($)
02:56:22 <tomaszz> it could be difficult
02:56:26 <dcoutts> Speck, from the ghc-api build dir
02:56:33 <ndm> yeah, thats half on the horizon
02:56:45 <ndm> the idea is that it would be more likely to answer foldr
02:56:54 <tomaszz> ndm: are you working on this?
02:56:55 <dcoutts> Speck, so yse the command that you pasted but with just the GHC module rather than specifying all of them
02:57:01 <Cale> <kosmikus> that'd make the search space too large, I think
02:57:01 <Cale> <tomaszz> yeah, it could be difficult
02:57:01 <Cale> <kosmikus> but if you first do your query, and then ask again "why" foldr fits the query, this answer would be nice
02:57:06 <ndm> and then it will give a direct option to fill in the blanks
02:57:14 <ndm> tomaszz: not quite, something close to it
02:57:22 <ndm> unfortunately haskell has too many useless functions
02:57:30 <Speck> dcoutts: is that what you pasted?
02:57:31 <tomaszz> ndm: undefined ?
02:57:33 <ndm> if you include any, then you get id composed with everything
02:57:37 <dcoutts> Speck, yeah
02:57:51 <ndm> tomaszz: no, just a->a style ones, which include too little type information
02:57:57 <ProfTeggy>    ndm, so the "usefulness" of a function would have to measured in a sense?
02:57:58 <ndm> and can be composed with anything
02:58:12 <ndm> ProfTeggy: yes, but also with respect to its inverses
02:58:16 <tomaszz> ndm: right, it would require some usefulness metric
02:58:17 <dcoutts> Speck, but it's the same as from the wiki paste page but without specifing all the modukls in the package, just the top level GHC one
02:58:38 <ndm> there are a million ways to write id in haskell, by composing multiple functions
02:58:41 <ProfTeggy> ndm, I feel that parametricity plays a role in there
02:58:58 <Speck> dcoutts: same panic
02:59:13 <sieni> cool, tor actually works
02:59:28 <ndm> i don't think it will ever support full function composition at search level - but my supervisor wants it to
03:01:03 <tomaszz> ndm: some kind of heuristic search may be necessary
03:01:33 <ndm> tomaszz: it already has heuristics, i'm working on improving them for the next version
03:01:55 <ndm> i'm also adding all of GHC's libraries, so its likely that searches will already return too many results
03:02:06 <ndm> and heuristics should be able to sort them down
03:03:23 <tomaszz> ndm: I am keeping my fingers crossed :-)
03:03:52 <ndm> i am also moving it to haskell.org/hoogle
03:04:04 <ndm> they are in the process of setting up an account
03:04:14 <dcoutts> Speck, and no extra info, even if you use -v ?
03:04:57 <Speck> dcoutts: nope :-(
03:06:36 <kzm> musasabi, do you have any experience with Judy?
03:07:03 <kzm> (Judy arrays, that is, lest anybody get the wrong impression :-)
03:08:07 <dcoutts> JaffaCake, we're getting "unknown exception" during ghc --make, probably during the import chasing phase. Any idea how to track it down?
03:08:15 <dcoutts> JaffaCake, see: http://www.haskell.org/hawiki/HaskellIrcPastePage
03:08:39 <dcoutts> JaffaCake, it's when building Lemmih's version of the ghc-api package
03:08:47 <MarcWeber> ProfTeggy: Is this example meant to compile out of the box?
03:08:53 <JaffaCake> right, I think Lemmih reported it
03:08:54 <dons> ndm, yes, I've often thought that it would be nice if hoogle could offer some simple @pl-ish expressions that have the required type
03:08:57 <JaffaCake> is it repeatable?
03:09:05 <Speck> JaffaCake: for me every time
03:09:10 <dcoutts> JaffaCake, for some people it's repeatable
03:09:16 <dcoutts> unknown exception usually means a dynamic exception that was not caught
03:09:16 <JaffaCake> on a clean build tree?
03:09:42 <JaffaCake> dcoutts: it's an interesting panic: an exception was raised while trying to print out the error message :)
03:09:49 <dcoutts> heh :-)
03:10:05 <JaffaCake> that's why it says "ghc-6.4.1: ghc-6.4.1: panic"
03:10:11 <Speck> aha I was wondering
03:10:22 <JaffaCake> ok, I'll have to look into it
03:10:33 * Speck gives JaffaCake a cookie
03:10:44 * JaffaCake munches it
03:11:02 * ibid beeps
03:11:03 * Speck wants to get hacking on hIDE, but so many roadblocks :-(
03:11:27 <dcoutts> ibid, want my SOE code?
03:11:34 <JaffaCake> dcoutts: what's the quickest way to repeat the crash?
03:11:53 <dcoutts> JaffaCake, ask Speck. I can't reproduce it.
03:12:07 <ibid> dcoutts: yes :)
03:12:13 <dcoutts> ibid, since you sent me your version, it's only fair :-)
03:12:18 <ibid> heh
03:13:07 <JaffaCake> Speck: can you give me instructions to reproduce?
03:13:47 <JaffaCake> Speck: what version of Cabal?
03:13:48 <Speck> JaffaCake: I did a Cabal configure (retargeted prefix), then a build
03:14:03 <JaffaCake> ok good, so not partially-built then
03:14:09 <Speck> JaffaCake: darcs latest, with a patch I just sent to issac jones
03:14:22 <dons> MarcWeber, added :)
03:16:23 <dcoutts> ibid, darcs get http://haskell.org/~duncan/soe/
03:16:46 <dcoutts> ibid, you either need the latest darcs version of gtk2hs to build it or comment out the call to Gtk.flush
03:17:29 <dcoutts> ibid, so it'd be nice to make a version that uses the older Gdk api
03:17:36 <ibid> where's the darcs of gtk2hs?
03:17:41 <dcoutts> but keeps the existing event processing and other stuff.
03:17:45 <ibid> what version of gtk2hs is needed?
03:18:01 <dcoutts> darcs get http://haskell.org/gtk2hs/darcs/gtk2hs/
03:18:19 <dcoutts> ibid, it uses an extra function I added yesterday :-)
03:18:41 <ibid> i mean, does that work with a release version, and if so, which?
03:18:50 <dcoutts> ibid, so todays version is needed, or comment out Gtk.flush
03:19:14 <dcoutts> ibid, if you comment that call out then it should work with the 0.9.9.5 tarball version
03:19:22 <dcoutts> but I've not tried that
03:20:14 <ibid> ok
03:20:48 <ibid> well, for the course i need the gdk version
03:20:56 <ibid> should i fork this or are you working on that?
03:21:12 <ibid> (this is probably superior to my JyuGraphics:)
03:23:57 <musasabi> kzm: Some years back I used it in a C app, but don't remember much.
03:26:55 <booger> how do i check what kind the return type from a function is?
03:27:16 <earthy> um?!
03:27:24 <dons> what kind?
03:27:31 <booger> parse :: String -> Either String Expr
03:27:36 <dons> :k
03:27:47 <booger> and if i use parse i want to know if it's a string or an expr coming out
03:27:54 <Cale> use case
03:27:55 <dons> ah, 'case'
03:27:58 <earthy> booger: owh, you just case match on (Left string) or (Right expr)
03:28:17 <booger> ok.. hmm.. but i'm calling the function from inside an io loop
03:28:20 <Cale> case parse str of { Left xs -> ... ; Right e -> ... }
03:28:28 <musasabi> data Eeither a b = Left a | Right b
03:28:49 <earthy> booger: so?! apply another function to the result of that parse function
03:29:02 <earthy> so that that function does the case match for you
03:29:27 <dons> @eval case Left "x" of Left a -> a ; Right b -> b
03:29:30 <lambdabot> "x"
03:29:31 <booger> hmm.. yes..
03:29:34 <booger> :)
03:29:45 <booger> i'll have a look at it!
03:29:46 <booger> thanks
03:29:48 <booger> brb
03:30:06 <dons> btw, "kind" means something else in Haskell (and type theory) which is why we got confused at first
03:30:23 <booger> ahh.. :D sorry.. :)
03:30:32 <dons> values have types, types have kinds, if you follow.
03:30:38 <dons> kinds are the `types' of types
03:30:47 <dons> @kind Int
03:30:49 <lambdabot> *
03:30:55 <dons> @kind Either
03:30:56 <lambdabot> * -> * -> *
03:31:54 <SlowByte> what are types of types of types? :)
03:31:59 <dons> and kinds have sorts, sometimes.
03:32:00 <dblhelix> kinds have superkinds, there's really only one superkind in haskell
03:32:17 <dblhelix> sorts, superkinds... potato, potato
03:32:19 <dons> also known as "sorts", at least in some domains
03:32:24 <dons> right.
03:32:48 <dons> I like "sorts" myself
03:32:57 <ibid> heh, some other people use sorts for types :)
03:33:04 * poetix struggles to imagine a superkind
03:33:29 <poetix> (a -> a) is a type, (* -> *) is a kind - correct?
03:33:39 <Cale> right
03:33:44 <dblhelix> I've seen "sorts" used for the set {type, kind, superkind, supersuperkind, ...}
03:33:45 <dons> @type 'c'
03:33:47 <lambdabot> Char
03:33:52 <dons> @kind Char
03:33:55 <lambdabot> *
03:34:07 <dons> @kind (->)
03:34:09 <lambdabot> ?? -> ? -> *
03:34:23 <dblhelix> ... @superkind * would give "<box>"
03:34:36 <dons> [] perhaps?
03:34:48 <dons> or [ ]
03:34:53 <dons> maybe not.
03:35:07 <dons> see we have a few kinds, not just *
03:35:20 <dons> @kind GHC.Base.Int#
03:35:22 <lambdabot> #
03:35:32 <dons> and that's it. *, ?, ??, #
03:35:46 <dons> though I think there's another that's used internally by ghc
03:35:49 <dblhelix> but # is really ghc specific
03:35:56 <dons> and jhc goes nuts on this stuff too
03:36:21 <Cale> I want to see at least one kind per class context :)
03:36:26 <dblhelix> I even think that from a theoretical pov # would even have a different superkind
03:36:36 <Cale> but having trouble formalising things
03:37:21 <dblhelix> forget my last remark... it's nonsense
03:37:32 <dblhelix> # :: BOX
03:38:23 <dcoutts> ibid, feel free to add gdk support and darcs send me patches
03:42:00 <autrijus> spj++ spj++
03:42:14 <autrijus> # applies my GADT+Rec+Existential patch, cleaned it up, to CVS
03:42:36 <autrijus> and assigned me the task of adding cs and tests and more parser cases
03:42:45 <dons> oh, wow. congratulations :)
03:42:51 <autrijus> "Would you like to attend to those things when you get time?  Then you'll be an Accredited GHC Hacker!"
03:42:54 <cjb> :)
03:42:58 <dons> tests are good :)
03:43:00 <cjb> autrijus: You should come hang out in Cambridge more.
03:43:01 <Speck> autrijus: I read about the gadt+rec+existentials on your blog. cool stuff :-)
03:43:03 <autrijus> of course I'd like :)
03:43:07 <booger> aight guys.. my headache is solved.. thanks again!
03:43:17 <ibid> dcoutts: no promises though
03:44:15 <dcoutts> ibid, no probs
03:45:01 <dcoutts> ibid, or fork it. Replace the cairo code with your gdk code and I'll reintegrate them (and make it beuild the appropriate version depending on wether the user has cairo installed)
03:45:13 <autrijus> cjb: UK visa is notoriously hard to get nowadays.
03:45:33 <autrijus> cjb: so although I'd very much like, my schengen doesn't allow me to visit there this time
03:45:50 <autrijus> cjb: I plan to come back next March, though. not sure how to arrange things so I get some interesting hacking done.
03:47:12 <cjb> autrijus: Gosh, okay.
03:47:36 * cjb is currently trying to get a US visa, from the UK, and it's just as hard.  :)
03:48:12 <Speck> autrijus: I noticed that we both had the same problem compiling ghc-api. were you compiling on os x?
03:48:42 <JaffaCake> Speck: the crash happens for me too.  :)
03:48:57 * JaffaCake dives in
03:49:25 <Speck> oh boy
03:49:35 <Speck> jaffa-the-hack to the rescue
03:51:22 <dcoutts> Speck, yay
03:51:33 <JaffaCake> oh no! it's gone away when I compile with last night's STABLE build
03:51:44 <autrijus> oh no!
03:51:58 * JaffaCake suspects something Cabalish
03:52:03 <autrijus> stable of fbsd or of ghc?
03:52:10 <JaffaCake> ghc
03:52:45 <dcoutts> it happens when one builds without using cabal
03:53:04 <JaffaCake> but having a new Cabal installed might affect it
03:53:27 <dcoutts> ah yes
03:53:38 <dcoutts> Speck, what cabal version do you have installed?
03:53:53 * dcoutts has Cabal-1.1.3
03:54:02 <Speck> dcoutts: darcs latest, with a patch I just sent to syntax
03:54:07 <Speck> 1.1.4
03:54:11 <beelsebob_> JaffaCake: did you get my email about badly timed laptop death?
03:54:13 <dcoutts> though I don't get the ghc-api build problem
03:55:12 <JaffaCake> beelsebob_: yes, sorry it dropped into my spam folder so I only just noticed it
03:55:22 <beelsebob_> okay, no probs
03:55:34 <beelsebob_> I'm in no hurry... I've broken my code again :)
03:55:57 <Cale> JaffaCake: what do you think of extending the kind system to deal with the problem of class contexts not being very meaningful in data declarations?
03:56:40 <Cale> (say, adding subkinds of * consisting of those types which satisfy a given class constraint)
03:57:25 <dcoutts> Cale, why does it need a kind extension?
03:57:45 <JaffaCake> Cale: my buffer is full right now, that sounds like one for an email discussion
03:58:14 <Cale> Well, you want to be able to infer from Set being applied to a type 'a' that (Ord a)
03:58:47 <Cale> It seems natural to express that in the kind of Set
03:58:48 <JaffaCake> dcoutts: it's definitely related to Cabal-1.1.4
03:59:35 <dcoutts> JaffaCake, oh interesting, how is Cabal-1.1.4 calling ghc that's different from 1.1.3?
03:59:56 <Cale> Say, Set :: {a | Set a} -> *
03:59:59 <Cale> er
04:00:02 <Cale> Say, Set :: {a | Ord a} -> *
04:00:03 <JaffaCake> it's not the calling of ghc, it's something about the installation of Cabal-1.1.4 itself
04:00:06 <Cale> anyway, goodnight :)
04:00:33 <dcoutts> JaffaCake, hmm wierdy
04:01:38 <Igloo> Cale: I think the meaning of data Ord a => Set a = ... should be changed so the typechecker can see that the Monad etc instance actually does apply for all types
04:03:26 <sylvan>  autrijus, perhaps you should mention hsp in your presentation (maybe even replace wash/go)?
04:04:42 <autrijus> I'll mention both.
04:05:04 * autrijus renaps a bit... bbiab &
04:13:12 <kzm> JaffaCake, sorry to pester you, but about profiling... or should I just email a report to ghc-bugs or similar?
04:13:23 <autrijus> wow, this works, I'm startled.
04:13:26 <autrijus> fibs@(_:rest) = 0:1:[ x+y | x <- fibs | y <- rest ]
04:13:54 <JaffaCake> kzm: what about profiling?
04:14:25 <kzm> I get profiling reports about time consumption that differ (wildly) from observed wall clock time (/bin/time)
04:15:00 <JaffaCake> kzm: sounds interesting... probably an email to ghc-bugs is best
04:15:07 <kzm> Three cases, profiling reports 2.3-2.9 seconds, time reports 3s to 2 minutes - 99%cpu, alsmost exclusively user time.
04:15:48 <kzm> I'm using hash tables a lot, especially in the long-running cases - but it's strange if that somehow escapes profile accounting, isn't it?
04:15:50 <JaffaCake>  the real time really varies between 3s to 2 minutes?
04:16:00 <kzm> Yes.
04:16:09 <JaffaCake> just randomly?
04:17:13 <kzm> No, consistently.  Case 1 (few large hash tables) profiles to 2.x seconds, and measures to (the expected) slightly more.
04:17:27 <JaffaCake> ah, I see
04:17:32 <kzm> Case 3 (many small tables) profiles to approximately the same, but measures to 130 seconds or so.
04:18:07 <JaffaCake> I think GC time is discounted from the profile... might want to check +RTS -sstderr
04:18:16 <kzm> ghc 6.4.1
04:18:23 <JaffaCake> dcoutts: I know what the crash is
04:18:30 <dcoutts> JaffaCake, oh yes?
04:18:31 <kzm> Okay, I can try that.  BRB.
04:18:52 <JaffaCake> the error message should read "ghc-6.4.1: unknown package: Cabal-1.1.4"
04:18:58 <dcoutts> hah!
04:19:01 <JaffaCake> that's bug #1
04:19:34 <JaffaCake> the reason that Cabal-1.1.4 is unknown, is that the command line contains "-ignore-package lang"
04:19:54 <dcoutts> Ah, I've seen that kind of error message before and I've not been able to figure out why it happens.
04:20:06 <JaffaCake> and -ignore-package P also ignores everything that depends on P, and it turns out that Cabal-1.1.4 depends (indirectly) on lang, because it depends on uitl
04:20:17 <dcoutts> oh I see
04:20:28 <dcoutts> my Cabal-1.1.3 doesn't depend on util :-)
04:20:40 <JaffaCake> Cabal-1.1.4 shouldn't, really
04:20:55 <dcoutts> because we hacked it to not depend on util (because from expreience, depending on util breaks everything)
04:21:05 <JaffaCake> yes
04:21:19 <dcoutts> JaffaCake, I've talked to SyntaxNinja about this issue before (and at some length :-) )
04:21:20 <kzm> JaffaCake, GC seems to be taking the excess time, yes.
04:21:41 <JaffaCake> kzm: a space leak?  maybe try heap profiling?
04:22:05 <JaffaCake> the time profile should really report GC time too
04:22:09 <kzm> case 1:  %GC time      52.1%  (51.4% elapsed)
04:22:23 <kzm> case 2: %GC time      86.2%  (87.5% elapsed)
04:22:25 <dcoutts> JaffaCake, in fact he only needs to depend on the unix package, and only for ghc-6.2.2. Since 6.4 includes the module he needs in base.
04:22:35 <kzm> case 3 isn't finished yet, but I guess I know what to expect :-)
04:22:48 <JaffaCake> heh
04:22:53 <dcoutts> JaffaCake, he's only depending on util since that happens to depend on the unix package
04:23:00 <JaffaCake> yep
04:23:29 <kzm> Interesting that the amount of allocation doesn't differ a lot.
04:23:38 <Speck> hmm... -ignore-package seems like a dangerous arg
04:23:50 <dcoutts> Speck, actually it's rather important
04:24:15 <Speck> I imagine it is, somehow
04:24:18 <kzm> For completeness, case 3: GC    time  209.95s  (210.17s elapsed)
04:24:19 <int-e> hmm. that's the second case of bad performance due to excessive GC I see this case (the first being the buffered IO one where a large buffer causes GC to take more time)
04:24:29 <int-e> I see this *week*
04:24:32 <kzm> (or 98.7% or the running time)
04:24:47 <JaffaCake> kzm: wow
04:25:02 <joelr> hello
04:25:04 <Speck> that's quite pathological
04:25:09 <dcoutts> JaffaCake, the gentoo cabal-1.1.3 ebuild removes util from the Build-Depends and for ghc-6.2.2 it replaces it with the unix package. I don't know what is needed on win32.
04:25:35 <JaffaCake> dcoutts: when i get aronnd to doing conditional dependencies we can fix this properly
04:25:46 <Speck> JaffaCake: any way to fix it improperly?
04:25:47 <joelr> assuming that I have class Foo, is there  a way to have a list where the members are instances of Foo?
04:25:54 <JaffaCake> Speck: just looking into it
04:26:08 <Speck> JaffaCake: don't mean to push. take your time of course!
04:26:19 <Speck> @karma+ JaffaCake
04:26:20 <lambdabot> JaffaCake's karma raised to 2.
04:26:30 <JaffaCake> Speck: I *think* just removing the -ignore-package lang should work around it
04:26:33 <Maddas> joelr: Not sure, but shouldn't Foo a => [a] do it?
04:26:38 <Speck> JaffaCake: I'll give it a go
04:26:57 <Maddas> joelr: ('do it' as in being the type signature you're looking for)
04:27:11 <joelr> Maddas: doesn't quite. if i have Bar and Baz that are instances of Foo I cannot do [Bar, Baz] :(
04:27:13 <dcoutts> JaffaCake, in the mean time just removing the util will fix it for 6.4 but break it for 6.2.2
04:27:16 <JohnMeacham> dons: jhc has # and * internally. It really does need more, those don't capture all the invarients I want. but I read this really cool paper about being able to declare your own kinds somewhere. but I can't seem to find it again.
04:27:52 <joelr> JohnMeacham: does the license on MissingIO prevent it from being used in commercial projects?
04:27:59 <Maddas> joelr: Oh, I see. I'm just a newbie, so I'll retreat now :)
04:28:10 <JohnMeacham> ? What is MissingIO?
04:28:18 <joelr> JohnMeacham: MissingH, sorry :D
04:28:27 <joelr> JohnMeacham: i thought you were the maintainer
04:28:29 <dcoutts> JaffaCake, it only happens to work when depending on util since that depends on unix in the unix version of ghc and does not depend on unix in the win32 version of ghc. Which is exactly what Cabal needed. (Whihc incedentally means Cabal doesn't work on win32 with 6.2.2)
04:28:41 <JohnMeacham> I call # hash, because the lambdacube already has something called BOX.
04:28:50 <JaffaCake> JohnMeacham: Tim Sheard has paper(s) about declaring kinds
04:28:53 <JohnMeacham> joelr: nope. but I think the maintainer does hang out here.
04:29:04 <joelr> JohnMeacham: oh, sorry then
04:29:14 <musasabi> CosmicRay is the MissingH maintainer.
04:29:18 <JohnMeacham> JaffaCake. Ah, that is the one I am thinking of I think. it is a possibility in ghc's future?
04:29:19 <JaffaCake> dcoutts: yes, it's a horrible hack
04:29:25 <joelr> musasabi: cool, thanks
04:29:28 <kzm> Anything interesting I could try with GC +RTS options?
04:29:36 <JaffaCake> JohnMeacham: yes, simonpj is thinking about it quite seriously
04:29:52 <JaffaCake> apparently there's a fairly simple hack to make it work
04:30:15 <musasabi> joelr: Do you mean www.cs.chalmers.se/~rjmh/Papers/restricted-datatypes.ps ?
04:30:15 <JaffaCake> simon was muttering something about "kind * having kind *"
04:30:29 <JohnMeacham> Cool. I got excited when I read that paper. combined with the boxy types stuff, haskells type system is progressing at an amazing rate.
04:30:42 <bourbaki> is there a lib for haskell that allows me to do automatons with monads?
04:30:54 <joelr> musasabi: don't know, i'll read through that
04:31:08 <musasabi> sorry I meant JohnMeacham.
04:31:09 <kzm> Perhaps unsurprisingly, things are *really fast* if I give a large initial heap (-H500M) :-)
04:31:14 <joelr> musasabi: what i want is to be able to stick different instances of Foo into a list,
04:31:25 <JaffaCake> kzm: you want to heap profile and find the leak
04:31:42 <musasabi> JohnMeacham: www.cs.chalmers.se/~rjmh/Papers/restricted-datatypes.ps has the basic stuff about the need for restricted kinds.
04:31:52 <Speck> @google HList
04:31:54 <lambdabot> http://homepages.cwi.nl/~ralf/HList/
04:31:57 <joelr> i.e. if instances of Packet had a mechanism to serialize them then i want to be able to construct a list of instances calling the constructor of each
04:32:01 <Speck> joelr: go to the HList site
04:32:18 <musasabi> The OOHaskell paper had a nice section about heterogenous lists.
04:32:18 <JohnMeacham> musasabi: no, I was thinking of tim sheard's one. but that is a good paper too :)
04:32:39 <bourbaki> oh has anyone ever written a graph class useing HList?
04:32:47 <joelr> just what i need, unless it's OOHaskell
04:33:03 <Speck> it's oohaskell
04:33:05 <kzm> Okay - I'll run a set of heap profiles now.
04:33:09 <kzm> Thanks!
04:33:32 <joelr> oops
04:34:07 <Maddas> joelr: Might http://haskell.org/hawiki/ExistentialTypes be helpful?
04:34:36 <joelr> Maddas: right on the money! thank you
04:35:02 <Maddas> No problem :-)
04:35:23 <Speck> joelr: also, the HList paper looks at various systems for heterogeneous lists, you might want to look into more methods
04:35:42 <joelr> Speck: i downloaded that and will take a good look, thanks
04:35:44 <joelr> data AnyRenderable = forall a. Renderable a => AnyRenderable a
04:36:35 <joelr> is this the same as instance (Renderable a) => AnyRenderable a?
04:37:36 <joelr> i guess not quite
04:38:04 <joelr> when should i use => vs. forall a.?
04:39:40 <JohnMeacham> I always lose the sheard one because I forget to look at the mega stuff in addition to the haskell stuff.
04:41:16 <sylvan> joelr, the forall there is just a way of hiding the type variable "a" from the left-hand side.. so that you can create a list with AnyRenderables
04:41:48 <joelr> sylvan: ok, thanks
04:42:02 <sylvan> you could, and should, also instantiate AnyRenderable into the Renderable class (by simply unwrapping the AnyRenderable constructor), to make it easier to work with values of type AnyRenderable
04:42:49 <sylvan> Also, now days I'd recomend using GADT's instead.. "data AnyRenderable where AnyRenderable :: (Renderable a) => a -> AnyRenderable"
04:43:06 <sylvan> it just looks better, imo
04:43:38 <joelr> what is the meaning of data AnyRenderable where AnyRenderable :: (Renderable a) => a -> AnyRenderable?
04:43:56 <joelr> after the where is that a constructor?
04:44:13 <joelr> no, that's a function, right?
04:45:44 <joelr> sylvan: AnyRenderable is a function that given a Renderable returns AnyRenderable?
04:46:07 <sylvan> jolelr, yep.
04:46:09 <joelr> sylvan: sort of a container for Renderables, right?
04:46:12 <sylvan> AnyRenderable is a constructor, even
04:46:20 <sylvan> yeah, you can think of it that way
04:46:35 <joelr> sylvan: but Renderable is a class... cool
04:46:49 <sylvan> the syntax there is a way of generalizing the standard algebraic data types so you can give the exact type signature for each constructor (in this example we only have one)
04:46:57 <joelr> is someone familiar with the wxHaskell way of passing arguments in a list?
04:47:02 <sylvan> which is nice if you want to "hide" types from the left hand side
04:47:16 <sylvan> what do you mean?
04:47:20 <joelr> [ on := ... , etc ]
04:47:37 <joelr> i'm curious how they do that
04:47:42 <sylvan> ah.. it's just a list of Attrs
04:47:58 <joelr> attrs? i guess i should read more on wxHaskell
04:48:06 <joelr> i'd like to use this approach myself
04:48:13 <sylvan> look at the type of on, (:=)
04:48:15 <joelr> and define packets that are lists of Attrs
04:48:26 <joelr> and be able to set them and get them
04:48:44 <sylvan> := is just an operator which takes various things and turns them into a value. I think it's called "Attr w" where w is the widget in question
04:49:10 <joelr> sylvan: ok, thanks
04:49:23 <sylvan> so "on command := fun" takes the "on command" and packages it up with "fun" into an Attr...
04:49:32 <sylvan> @type :=
04:49:41 <joelr> ok, thanks sylvan!
04:49:47 * joelr takes off
04:49:49 <Speck> I dunno if lambdabot knows about wxhaskell
04:49:50 <lambdabot> bzzt
04:49:54 <sylvan> I don't think so either
04:49:59 <sylvan> @index :=
04:50:00 <lambdabot> Control.Parallel.Strategies
05:02:47 <shapr> What other languages have monad implementations?
05:03:14 <shapr> I've got an url to Monads in Perl on sleepingsquirrel.org. Aren't there OCaml and Java implementations as well?
05:03:45 <earthy> Clean, obviously
05:03:58 <earthy> and Scheme
05:04:12 <earthy> see e.g. David Espinosa's PhD thesis
05:04:52 <tomaszz> I was playing with monads in OCaml, but it doesn't qualify as "OCaml has monad implementations" ;-)
05:06:18 <earthy> http://www.ccs.neu.edu/home/dherman/code.html has http://www.ccs.neu.edu/home/dherman/code/monads/JavaMonads.tar.gz
05:06:29 <shapr> Ah, thanks
05:07:32 <Speck>   package ghc-api-0.2 has conflicting dependencies:
05:07:32 <Speck>      Generics is in the following packages: lang-1.0 ghc-api-0.2
05:07:32 <Speck>      Unique is in the following packages: util-1.0 ghc-api-0.2
05:07:57 <Speck> I wonder if JaffaCake and dcoutts shoved off
05:08:22 <JaffaCake> I'm here
05:08:27 <shapr> Why are those conflicting? ghc-api shouldn't depend on itself should it?
05:08:50 <tomaszz> Nice camouflage, JaffaCake ;-)
05:09:09 <Speck> I think ghc-api and lang are conflicting wrt Generics, and ghc-api and util are conflicting wrt Unique
05:09:13 <JaffaCake> ta :)
05:09:56 <JaffaCake> Speck: ghc-api should not be installed exposed
05:10:08 <JaffaCake> and Cabal should not depend on util
05:10:52 <JaffaCake> sigh, we should really fix this module restriction thing
05:11:17 <Speck> cabal is confusing :-X
05:12:04 <MarcWeber> Can some one tell me about the module NativeInfo?
05:17:31 <dcoutts> JaffaCake, will the ghc-api that comes with ghc-6.6 be installed exposed? or will it use the module namespace nicely.
05:17:58 <JaffaCake> no, and no
05:18:07 <dcoutts> that ok I guess
05:18:24 <JaffaCake> it'd be nice to rename all the modules, but it's not urgent
05:18:26 <dcoutts> GHC.* would be nicer of course :-)
05:18:30 <JaffaCake> yes
05:18:32 <dcoutts> yes
05:18:48 * dcoutts was saying yes to the "not urgent"
05:19:08 <dcoutts> Cabal doesn't let you install not exposed so far as I know
05:19:27 <Speck> if I force an install, I can hide it right?
05:19:34 <dcoutts> Speck, yes
05:22:13 <Speck> hrm... it says to use force, but doesn't seem to like it as an argument
05:32:57 <shapr> hoi swiert, how's code?
05:33:10 <swiert> hi shapr - not much happening.
05:33:30 <swiert> I've been trying to work out what my PhD is supposed to be about.
05:33:44 <JaffaCake> dcoutts: yes, that's a defficiency in Cabal (that it doesn't let you install hidden)
05:33:57 <swiert> How about yourself?
05:34:10 <JaffaCake> dcoutts: the install for ghc-api could have a post-install hook that hides ghc-api
05:34:23 <shapr> Fermat's Last Margin is working, though it doesn't have darcs integration yet.
05:34:45 <shapr> I'm looking for feature suggestions for research paper annotation.
05:37:14 <dcoutts> JaffaCake, that kind of post-install hook won't work in a distro package (unless it just uses sed on the .installed-package-info file)
05:37:25 <swiert> Hmm, it would be nice to tag and browse research papers a la delicious.
05:37:38 <JaffaCake> hmm, good point
05:37:42 <swiert> Though that might be beyond the scope of FLM.
05:38:24 <dcoutts> JaffaCake, it certainlt can't call ghc-pkg to hide since if the user did ./setup regster --gen-script then the thing isn't even registed yet so can't be hidden.
05:38:28 <shapr> Tagging is easy with a wiki, but it does make me wonder how to nest repositories.
05:38:52 <dcoutts> JaffaCake, the simplest thing would be to add another field to the .cabal file
05:39:12 * shapr adds that to the TODO list
05:39:31 <dcoutts> JaffaCake, I wonder if it wouldn't be better for forwards compatability if Cabal ignored fields that it didn't understand (or emit a warning)
05:40:24 <JaffaCake> possibly, though you might get odd things going wrong later rather than an error up front
05:40:35 <dcoutts> JaffaCake, since we get problems that people use a new field and then old Cabal version refuse to even parse the file. So it means one can't use the "buid-depends: Cabal >= 1.x.y" trick to make older cabal versions report that a newer one is required,
05:41:02 <JaffaCake> ah yes
05:41:21 <dcoutts> currently it leaves users wondering "what happened?" "what version of what is too old?"
05:41:24 <JaffaCake> you don't want to depend on Cabal though, really
05:41:45 <dcoutts> I guess so
05:41:58 <shapr> swiert: Do you have a vague idea about your thesis?
05:42:07 <dcoutts> JaffaCake, perhaps as one of these tool depends we've been talking about
05:42:11 <JaffaCake> there's a problem caused by plugins depending on Cabal
05:42:27 <dcoutts> JaffaCake, like the "this package needs happy-1.15 to build" things
05:42:33 <JaffaCake> yes
05:42:45 <swiert> shapr: The thing is, there is a *lot* of category and type theory to wrestle my way through.
05:42:59 <dcoutts> what's the plugins depending on Cabal problem?
05:43:27 <JaffaCake> oh, if you have multiple versions of Cabal installed, and plugins depends on one of them, horrible things happen
05:43:28 <swiert> I kind of pick things up gradually, slow and steady, but there's still a lot I don't know.
05:43:37 <dcoutts> JaffaCake, ah yes ok
05:43:53 <JaffaCake> it turns out that having multiple versions of a package installed is ok until you have something that depends on one of them
05:43:56 <JohnMeacham> Is there a policy against using hierarchical module names in ghc? or is it just tradition?
05:44:03 <JohnMeacham> in ghc's source code itself I mean.
05:44:17 <JaffaCake> JohnMeacham: we never got around to converting
05:44:41 <JaffaCake> there's a lot of "old style Haskell" in GHC :)
05:45:06 <JaffaCake> autrijus was complaining about the use of `thenM` instead of do-notation
05:45:18 <JohnMeacham> Yeah, I noticed the `thenM` too :)
05:45:37 <JohnMeacham> if writing a new module, should one give it a hierarchical name?
05:45:59 <JaffaCake> well, probably not, I think it's a change we'd want to make consistently when we do
05:46:03 <dcoutts> JaffaCake, yes allowing multiple versions to be installed at once only helps a bit. It's easy to end up with inconcistent deps.
05:46:34 <Si\Uni> does anyone know if fgl has an algorithm for counting the number of loops in a graph?
05:46:55 <JaffaCake> dcoutts: it's actually a bit worse than that: just having a dep on one of the versions of Cabal means you can't use Cabal any more
05:47:09 <JaffaCake> because GHC doesn't know which one to import
05:47:50 <dcoutts> what when one has an exposed package that uses cabal?
05:48:00 <JaffaCake> yes
05:48:10 <shapr> swiert: That sounds like the right way to do a PhD.
05:48:18 <dcoutts> JaffaCake, ohh nasty. I hadn't found that one.
05:48:27 <JaffaCake> so you have Caba-1.0 (hidden), Cabal-1.1.4 (exposed) and plugins that depends on Cabal-1.1.4
05:48:44 <JaffaCake> then try to import Distribution.something, and GHC will complain
05:49:21 * dcoutts tries to see understand that happens
05:49:36 <dcoutts> see understand/understand why
05:50:13 <dcoutts> what kind of plugin do you mean exactly (is the fact it's a plugin significant?)
05:50:41 <JaffaCake> no, I just meant the package "plugins" (as an example of something that depends on Cabal)
05:50:51 <dcoutts> oh right
05:51:45 <JaffaCake> without the dependency, GHC always knows which Cabal you want when you import something, because only one of them is exposed
05:51:47 <swiert> shapr: regardless of what I end up doing, I'm learning a lot - which is always good.
05:52:03 <dcoutts> in Gentoo we unregister Cabal-1.0 after installing ghc. And then all other cabalised packages depend on Cabal-1.1.3. so we only ever have one cabal verion installed globally.
05:52:23 <JaffaCake> dcoutts: good choice :)
05:52:23 <dcoutts> which is probably why I've not seen this problem before.
05:52:51 <JaffaCake> it shows up if you want to actually develop & test Cabal
05:57:34 <JohnMeacham> I wonder if we should have a pragma where we can declare that a CAF should be floated inward as far as possible, even inside of lambdas. I mention it because say I have a really compact C string representation internally that some haskell function acts on to create a constant haskell string. well, the haskell string is huge and really easy to generate from the compact C constant array, but it will be floated to the top as a
05:57:34 <JohnMeacham>  CAF and hence saved in its inefficient form.. if I could declare said caf should be floated inward, then it should be rebuilt each time (I think). does this make sense?
05:58:11 <dcoutts> un-memoising
05:58:29 <JohnMeacham> actually, if I put an INLINE pragma on a CAF what happens? will it be floated back out to the top by the full lazyness transformation?
05:58:36 <dcoutts> it's something they've batteled with in darcs I believe
05:59:12 <JaffaCake> JohnMeacham: yes, I've often wondered whether we needed something like that
05:59:31 <JaffaCake> I don't recall anyone ever actually asking for it, so we've never looked into it
05:59:33 <JohnMeacham> or perhaps some way to declare something 'unupdatable'.. but the semantics of that seems hard to pin down and i think the 'float-inable' pragma should do what I want...
06:00:42 <dcoutts> it's a time like this that the H98 specification of non-strict rather than lazy helps. You can make it not memoise without breaking semantics.
06:00:43 <JohnMeacham> perhaps just some code to make sure any cafs with an INLINE pragma are not floated back outward? perhaps setting a flag in its Id info?
06:00:49 <JaffaCake> I think it might be fairly easy... the annotation would tell GHC's simplifier to pretend that the expression is in WHNF, so it won't worry about duplicating its evaluation
06:01:37 <JohnMeacham> yeah, and the INLINE should float it in as far as possible.. or actually not if it appears in argument position, we would want to create a local definition as close to its use site as possible.
06:02:36 <JohnMeacham> so perhaps it is not quite the same thing as INLINE.. more like SUPERINLINE from jhc, where it duplicates the function body when it appears in argument position in addition to inlining when it appears in the head of an application.
06:02:58 <dcoutts> xerox, ping
06:02:59 <Speck> dcoutts: do I need anything special to enable sourceview on gtk2hs?
06:03:47 <JaffaCake> I need to offline for a while to get some hacking done... buy folks
06:03:56 <Speck> bye~ thanks Jaffa!
06:04:23 <Lunar^> that's so true :)
06:04:40 <JohnMeacham> later.
06:06:47 <xerox> dcoutts, I'lll be back in aminute.
06:06:56 <dcoutts> Speck, you need the sourceview C libs & headers installed
06:07:44 <dcoutts> Speck, you might find that you need a -dev package, eg sourceview-dev (or -devel perhaps)
06:07:54 <dcoutts> it depends on your distro
06:09:21 <Speck> ooh, gtksourceview
06:09:25 <dcoutts> yes
06:10:42 <Speck> oh boy... well assuming nothing else goes wrong, I'll be able to compile hIDE next
06:11:18 <dcoutts> heh heh, good luck
06:11:57 <Speck> thanks a lot for your help. hopefully once I have everything working I'll be able to contribute
06:12:08 <dcoutts> cool
06:12:19 <dcoutts> that'd be great
06:12:38 <dcoutts> what's your area of interest for hIDE?
06:12:43 * dcoutts works on the GUI
06:13:30 <Speck> I'm not sure yet. I'm definitely interested in the GUI, but mostly I'd just like to have a great Haskell IDE, so anything to that end, really.
06:13:57 <Speck> and hopefully learn a lot along the way
06:14:00 <dcoutts> Have you used Gtk2Hs before?
06:14:14 <Speck> I've never been able to install it until just now
06:14:20 <dcoutts> oh ok :-)
06:14:32 <Speck> I've read about it though
06:14:55 <dcoutts> reading the demo code is the easiest way to learn at the moment
06:15:27 <Speck> cool I'll have to scour the demos after classes
06:15:35 <Speck> which start in an hour :-(
06:15:52 <dcoutts> and reading the hIDE GUI bits with the Gtk2Hs reference docs close to hand :-)
06:16:47 <Speck> I'm somewhat curious about how the cabalization of ghc, cabal in general, hs-plugins, and hIDE (not to forget others), will affect the evolution of haskell
06:17:14 <dcoutts> we hope it'll be interesting :-)
06:17:15 <Speck> it launches haskell to almost a platform, instead of a language
06:17:48 * dcoutts wonders exactly what a platform is
06:17:59 <Speck> I'm using it specifically to be generic
06:18:04 <dcoutts> platform is a bit of amarketing term :-)
06:18:11 <Speck> solution?
06:18:13 <humasect> La Technology Layer
06:18:41 <dcoutts> I guess it refers to language implemntation & associated tools rather than the language spec
06:19:00 <Speck> I don't like to get too bogged down by definitions
06:19:20 <Speck> as a staunch post-modernist, I am deathly afraid of all forms of semantics
06:19:47 <dcoutts> heh heh, ok :-)
06:20:10 <humasect> ghci could end up really as just an interface to hs-plugins
06:20:25 <ProfTeggy> bbiab
06:20:31 <dcoutts> I think it'd rather be the other way around
06:20:54 <dcoutts> hs-plugins will probably end up implemented in terms of the ghc api
06:21:02 <humasect> ah yeah
06:21:41 <Speck> with ghc breaking apart though... it's almost as if it isn't really a ghc
06:22:04 <Speck> at least I think that would be really cool
06:22:04 <humasect> it will be nice, and if ghci can do a bit more with ffi. like handling .hsc and loading dll/so without restarting with -l<lib>
06:22:09 <dcoutts> it can get confusing, certainly
06:22:23 <Speck> it tickles me, post-modernly
06:22:39 <humasect> gcc did fine, Glorious Haskell Collection. =)
06:23:07 <beelsebob_> YAY!!!!!
06:23:10 <beelsebob_> hat-delta works!
06:23:33 <xerox> Hi!
06:23:37 <Speck> integrating compiler with libraries is a cool idea -- I've never seen it before, but I'm not so well versed
06:23:50 * xerox high-fives beelsebob
06:23:58 * beelsebob_ high-fives xerox
06:24:09 <dcoutts> humasect, that's the responsability of a IDE / build system / interactive evaluator thingy.
06:24:22 * Speck high-fives everyone (on the flip side as well) as he goes to perform the morning ritual
06:24:36 <basti_> morning?
06:24:44 <beelsebob_> it's morning to me
06:24:50 <beelsebob_> but then it's always morning to me
06:24:59 <dcoutts> it's a post-modern post-meridian morning for Speck
06:25:03 <basti_> ahh
06:25:08 <basti_> that kind of morning
06:25:47 <xerox> dcoutts, pong!
06:26:00 <dcoutts> xerox, oh I was going to say. surfaceCreateSimilar is broken :-0
06:26:07 <xerox> Woot!
06:26:09 <humasect> there isn't anything for Xcode for haskell right? was about to try Visual Haskell shortly.
06:26:11 <xerox> How?
06:26:31 <dcoutts> because it creates a surface without freeing it later. We want withSimilarSurface instead.
06:26:43 <xerox> Indeed!
06:27:03 <dcoutts> xerox, but actually we want: renderWithSimilarSurface :-)
06:27:05 <xerox> ...or an opaque Surface datatype?
06:27:19 <dcoutts> Surface is opaque
06:27:21 <xerox> renderWithSimilarSurface is even simpler, isn't it?
06:27:21 <beelsebob_> humasect: fraid not
06:27:31 <beelsebob_> I was going to try to build a plugin some time
06:27:39 <beelsebob_> there's a SEE highlighting mode though
06:29:11 <humasect> ah, i'll check out SEE as well.
06:29:17 <psi_> SEE?
06:29:47 <dcoutts> xerox, what do you think the type of renderWithSimilarSurface would be?
06:30:33 <dcoutts> xerox, it would certainly be useful I think. One of the points of cairo is that you can create a temporary surface, draw stuff on it and then composite it back onto a main image/surface.
06:30:47 <beelsebob_> SubEthaEdit
06:30:56 <psi_> ah
06:31:09 <dcoutts> xerox, you can even use a temporary surface as a pen or mask.
06:31:10 <beelsebob_> the mode is here... http://www.dusoft.co.uk/freebies.php
06:31:31 <dcoutts> xerox, so yes I've figured out how to do regions with and/or/xor/diff operators.
06:32:13 <dcoutts> xerox, in the general case one has to use intermediate surfaces and composite them together using the appropriate porter-duff operators.
06:32:30 <xerox> Ah!
06:32:56 <xerox> I'm sorry I have people in the house today, I'll be free in some hours.  I'm going to install linux on a friend's computer ;-)
06:33:11 <dcoutts> xerox, ok. I'll change the code and you can see what I've done :-)
06:36:08 <{Arias}> Do somebody knows why when I try to connect with localhost using connectTo it throws an exception?
06:36:23 <{Arias}> exception is: getServiceEntry: no such service entry
06:36:34 <beelsebob_> hehe, friend of mine just invented the GMG Machine
06:36:46 <beelsebob_> because G-Machine was taken :(
06:36:54 <dcoutts> beelsebob_, is that like an OMG Machine
06:37:04 <beelsebob_> dcoutts: don't think so
06:37:07 <dcoutts> or OMFG! machine
06:37:34 <{Arias}> the code that throws the exception is this:
06:37:35 <{Arias}> handle <- connectTo "localhost" ( PortNumber 8080 )
06:37:43 <dcoutts> when I invent a virtual machine it'l be an OMG or an OMFG machine.
06:37:48 <beelsebob_> it's an abstract machine for efficiently running graph programs
06:38:08 * dcoutts appologises for teasing beelsebob_ 
06:38:17 <beelsebob_> hehe
06:38:32 <beelsebob_> it's not my machine though, so I'm merely passing the teasing on
06:38:39 <dcoutts> ok :-)
06:39:00 <dcoutts> in that case you can tell him it should change the name to fit the acronym :-)
06:39:10 <beelsebob_> he's considering it now
06:39:19 <beelsebob_> it might become the oh-my-graph-machine
06:39:31 <beelsebob_> and then when he improves on it the oh-my-finer-graph-machine
06:39:34 <dcoutts> the '!' in OMFG! is optinal
06:39:48 <ProfTeggy> re
06:39:52 <dcoutts> optinal/optional
06:40:24 <beelsebob_> he's also now considering the "Original Machine For Graphs"
06:40:44 <dcoutts> nice
06:47:16 <kolmodin> hmm, I get a "Stack space overflow" error, any hints on how I could get some info about where it happened?
06:47:40 <araujo> kolmodin, using buddha?
06:47:51 <kolmodin> nope
06:48:04 <kolmodin> ah, I can try :)
06:48:21 <dcoutts> kolmodin, use beelsebob_'s hat-delta!
06:48:21 <araujo> :-]
06:48:30 <Speck> hat-delta!
06:48:32 <kolmodin> I thought you asked me if I did
06:48:45 <dcoutts> @cool-add hat-delta
06:48:46 <beelsebob_> hat-delta!!!!!
06:48:46 <lambdabot> Unknown command, try @listcommands.
06:48:52 <kolmodin> dcoutts: mmmm, what? :)
06:48:59 <dcoutts> we need a @cool list
06:49:03 <beelsebob_> @cool add hat-delta
06:49:03 <dcoutts> @todo
06:49:04 <lambdabot> 0. SamB: A way to get multiple results from a google search
06:49:04 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
06:49:04 <lambdabot> 2. SamB: stop mangling long urls
06:49:04 <lambdabot> 3. dons: improve formatting of @dict
06:49:04 <lambdabot> 4. dons: write Haskell Manifesto
06:49:05 <lambdabot> 5. lispy: don't let lambdabot's prettyprinter split the sequence @
06:49:07 <lambdabot> foo across lines
06:49:09 <lambdabot> [11 @more lines]
06:49:12 <lambdabot> Maybe you meant: code moo
06:49:15 <dcoutts> @more
06:49:16 <lambdabot> more: empty buffer
06:50:23 <dcoutts> ah I've already added that @todo item
06:50:32 <beelsebob_> :)
06:50:42 <dcoutts> 10. dcoutts: implement @cool list, as a clone of the @todo(-add)
06:51:18 <xerox> I want @what !
06:51:21 <beelsebob_> hat-delta is temporarily broken again
06:51:24 <beelsebob_> but it's getting there
06:51:31 <dcoutts> @todo-add make @todo n give the n'th @todo item
06:51:32 <lambdabot> Entry added to the todo list
06:51:43 <xerox> beelsebob_: does hat-delta have a referring url?
06:52:15 <beelsebob_> xerox: http://www.haskell.org/hat/ and http://www.cs.kent.ac.uk/people/rpg/tatd2/ifl05.pdf for the mo
06:55:59 <xerox> @where hat
06:56:00 <lambdabot> http://www.cs.york.ac.uk/fp/hat
06:56:04 <xerox> Okay :-D
07:02:12 * beelsebob_ does the dance of it works
07:02:26 * beelsebob_ does the dance of it's better than I ever would have guessed
07:02:32 <basti_> what?
07:03:16 <beelsebob_> hat-delta
07:03:24 <beelsebob_> (I just fixed it again)
07:03:28 <dcoutts> yay
07:03:42 <beelsebob_> I wonder if Jaffa Cake updated my ssh key
07:03:47 <dcoutts> so what exactly is better about hat-delta compared to the original hat?
07:04:00 <beelsebob_> give me a sec, and I'll do a paste that shows you
07:04:14 * dcoutts never used the original hat
07:05:02 <basti_> i see
07:05:03 <beelsebob_> @paste
07:05:05 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:06:49 <beelsebob_> there we go... pasted
07:07:17 * dcoutts tries to see what is going on there exactly
07:07:40 <beelsebob_> it's a series of questions asking... "should insert sort of this be this"
07:07:43 <beelsebob_> .tc
07:07:52 <dcoutts> yes
07:07:55 <beelsebob_> and then it tells you where the bug is based on those answers
07:08:06 <dcoutts> and the old one asked redundent questions compared to the new one?
07:08:14 <beelsebob_> hat-delta predicts where the bug is and asks that question first
07:08:23 <dcoutts> ah ok, nice
07:08:32 <beelsebob_> wheras hat-detect just systematicaly traverses the tree
07:08:46 <dcoutts> so the old one generated questions and asked them in any old order?
07:09:11 <beelsebob_> well, there was a systematic orderding to them
07:09:16 <dcoutts> the new one uses heuristics/guesswork/magic to ask the more likely questions first?
07:09:21 <beelsebob_> but not really relevant to where the bug would be
07:09:28 <beelsebob_> yep, correct
07:09:31 <dcoutts> cool
07:09:36 <beelsebob_> I think the new one can be improved a bit more too
07:09:52 <dcoutts> it uses nhc?
07:09:57 <beelsebob_> because I think if it favoured questions that left the tree balanced, it would find shorter paths more commonly
07:10:07 <beelsebob_> it can use ghc, nhc, yhc or hbc
07:10:12 <dcoutts> oh nice
07:10:25 <dcoutts> it's based on source transformations right?
07:10:26 <xerox> {Arias}: maybe problem with resolving the name?
07:10:31 <beelsebob_> yeh, at the moment
07:10:43 <dcoutts> oh? you're planning to change that?
07:10:49 <beelsebob_> although an upcoming version of yhc will produce debugging binaries without that stage
07:10:57 <dcoutts> ah I see
07:11:14 <dcoutts> yhc == nhc 2.0 ? sort of? or am I confused
07:11:21 <{Arias}> xerox, is localhost
07:11:26 <beelsebob_> and hence speed up execution about 20 times, compile about 5 times, and reduce trace size by a chunk
07:11:28 <{Arias}> i have apache on port 8080
07:11:33 <beelsebob_> yhc is indeed kinda nhc 2
07:11:41 <xerox> {Arias}: could you try with the ip addresS?
07:11:42 <beelsebob_> but it's not a not a haskell compiler
07:11:42 <{Arias}> server and port is corect
07:11:48 <{Arias}> yes xerox
07:11:54 <ndm> beelsebob_: you tested on hbc?
07:11:55 <beelsebob_> so they're changing the name to York Haskell Compiler
07:11:56 <{Arias}> with ip, with other server/ports...
07:12:02 <{Arias}> alwys ths same exception :(
07:12:05 <beelsebob_> ndm: no... but hat worked on it originally
07:12:17 <beelsebob_> and it's still in the configure scripts
07:12:31 <dcoutts> beelsebob_, the York Haskell Compiler is not a Haskell compiler?
07:12:34 <ndm> sounds a bit optamistic, allegedly nhc still compiled with hbc, but i doubt anyone did it years
07:12:35 * dcoutts is confused
07:12:44 <ndm> dcoutts: nhc = not a haskell compiler
07:12:44 <beelsebob_> dcoutts: no, that's exactly the point
07:12:55 <ndm> then later, acronym changed to aNother haskell compiler
07:12:59 <ndm> yhc is a haskell compiler
07:13:02 <dcoutts> oh I see. :-)
07:13:12 <ndm> which is about 50% nhc
07:13:20 <dcoutts> what was nhc when it was not an HC?
07:13:25 <ndm> and 50% pure brilliance :)
07:13:33 <beelsebob_> dcouts: something close to an hc
07:13:37 <ndm> dcoutts, a haskell compiler lacking certain features
07:13:46 <beelsebob_> ndm: yeh, strangely the same 50% :P
07:13:52 <beelsebob_> *g*
07:13:53 <dcoutts> I see, it was a modest haskell compiler
07:14:11 <ndm> yes, for example n+k patterns were added much later on
07:14:14 <ndm> and were never the defaults
07:14:26 <ndm> whereas yhc always supports n+k patterns without a flag
07:14:34 <dcoutts> right
07:14:58 <dcoutts> I think I've asked this question before: will yhc support the full FFI?
07:15:05 <kolmodin> now it just works(tm)
07:15:50 <beelsebob_> I *think* it will
07:15:53 <beelsebob_> hang on a sec
07:16:59 <dcoutts> beelsebob_, ndm, oh and another bug that's been stopping us from having nhc in gentoo was that it complains when it's heap is allocated in the upper 2GB of the VM space. (I guess it uses that to distinguish pointers from ints or something)
07:17:37 <beelsebob_> Tom says "I'm intedning so, but not internal ghc hackery ffi, i.e. the ffi addendum"
07:18:00 <Igloo> "internal ghc hackery ffi"?
07:18:04 <dcoutts> beelsebob_, just the FFI spec is ok. GHC extensions are not required.
07:18:10 <beelsebob_> :)
07:23:14 <beelsebob_> dcoutts: tom says the "infamous hi memory bug" has been very much fixed, mostly by ripping out the back end and inserting something much better
07:23:38 <dcoutts> beelsebob_, oh is that in a recent nhc98 release? or will we have to wait for yhc?
07:23:55 <beelsebob_> you'll have to wait for yhc... the major change in yhc is the backend rewrite
07:24:01 * dcoutts asks with his Gentoo packaging hat on
07:24:09 <dcoutts> beelsebob_, ah ok
07:24:37 <dcoutts> kosmikus, so nhc stays broken then.
07:26:42 <beelsebob_> it does
07:26:52 <beelsebob_> nhc is dead, long live yhc
07:27:23 <dcoutts> so what's the focus of nhc?
07:27:57 <beelsebob_> dieing?
07:28:08 <dcoutts> err, I mean yhc :-)
07:28:10 <beelsebob_> Malcolm's gonna stop maintaining it when yhc comes out
07:28:18 <ndm> being good :)
07:28:21 <beelsebob_> it's a fast compiler with *some* optimisations
07:28:26 <ndm> it will be fast to compile
07:28:27 <beelsebob_> and eventually debugging code
07:28:31 <ndm> portable byte code
07:28:39 <ndm> i.e. you can produce a cross platform binary
07:28:43 <dcoutts> so it'll lie somewhere between hugs & ghc
07:28:49 <beelsebob_> yep
07:28:51 <dcoutts> in the speed/portability scale
07:28:57 <ndm> yep
07:29:04 <ndm> oh, no
07:29:08 <dcoutts> and with extra debugging features
07:29:10 <ndm> in portability it will beat everyone
07:29:18 <ndm> the 64 bit port took 10 minutes
07:29:23 <ndm> the windows port took 15
07:29:37 <dcoutts> nice, that's easier than hugs
07:29:42 <ndm> way easier
07:29:45 <Igloo> It is?
07:29:55 <Igloo> I thought hugs Just Worked
07:29:56 <dcoutts> but it needs a Haskell compiler to bootstrap
07:30:00 <ndm> dcoutts, no
07:30:09 <ndm> runtime written in c, compiler in haskell
07:30:18 <ndm> hence you can download a cross platform binary of yhc
07:30:22 <ndm> and the c runtime
07:30:30 <dcoutts> oooh, nice
07:30:33 <eivuokko> Cool.
07:30:37 <ndm> then using only gcc (or any c compiler from 1990 and beyond)
07:30:43 <ndm> you have a full haskell toolchain
07:30:57 <dcoutts> so only the runtime needs to be built for each platform
07:31:01 <ndm> yep
07:31:03 <beelsebob_> yep
07:31:04 <dcoutts> and that just needs a C compiler
07:31:06 <dcoutts> nice
07:31:07 <beelsebob_> which is nice
07:31:07 <ndm> and its 100% pure c
07:31:22 <ndm> no assembly, and very clean code
07:31:33 <ndm> written with portability in mind
07:31:39 <dcoutts> and what about the low level libs, eg IO etc
07:32:07 <ndm> the standard IO stuff is contained in the runtime as primitives
07:32:27 <ndm> and it just uses the c library fopen fread fwrite etc. for that stuff
07:32:31 <dcoutts> ah ok, which is then implemented in terms of C FILE* stuff.
07:32:37 <ndm> yeah
07:32:38 <eivuokko> Hmmm.  foreign?
07:32:53 <ndm> FFI stuff will be platform specific
07:33:03 <dcoutts> so the base libs don't use any FFI
07:33:11 <ndm> no, not the base libs
07:33:57 <dcoutts> theoretically FFI stuff could be portable too
07:34:05 <ndm> not really
07:34:07 <ndm> it calls into c
07:34:13 <dcoutts> so long as the C prototypes are the same
07:34:21 <ndm> and the c stuff gets compiled into a c dll, i.e. binary
07:34:34 <ndm> oh, its portable at the compiler side
07:34:43 <ndm> but the dll you are calling into will not be, because its c
07:35:00 <ndm> however, you can ship mydll.dll and mydll.so and get some portability
07:35:42 <dcoutts> well I was thinking calling "int foo (int)" on one platform is the same as another, execpt for the C calling convention which the runtime could handle.
07:36:01 <dcoutts> I mean the bytecode representation for a FFI call is not necessarily platform specific
07:36:18 <ndm> oh no, the bytecodes are platform independant
07:36:30 <ndm> so if you call ffi, the haskell bytecode will be the same
07:36:35 <ndm> but the dll you call will be differrent
07:36:48 <dcoutts> is it really that different?
07:36:48 <ndm> (in theory, the ffi isn't implemented yet, but thats the design)
07:37:13 <ndm> dcoutts, its a c dll - it could be x86 for one thing and PPC for another
07:37:29 <dcoutts> I mean a call to a win dll with a given synbol name is not really that different from one to an elf symbol
07:37:47 <dcoutts> well the runtime does the appropriate calling convention for the given arch/platform
07:38:15 <ndm> dcoutts, those are details - but hopefully
07:38:35 <ndm> its not been implemented, so the little things are still up in the air
07:38:49 <ndm> remember, windows has 3 calling conventions at least
07:39:07 <ndm> so there may have to be some kind of which calling convention flag in the byte code
07:39:08 <dcoutts> ndm, but the FFI spec defines which calling convention to use
07:39:20 <araujo> @index (//)
07:39:20 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.
07:39:20 <lambdabot> Array
07:39:25 <ndm> does it, i haven't read it
07:39:39 <dcoutts> ndm, each ffi import can specify a calling convention
07:39:43 <ndm> dcoutts - i'm sure something as sensible and cross platform as possible will be done
07:40:07 <ndm> so you want to be able to specify (unix = cdecl, windows = stdecl)
07:40:09 <ndm> ?
07:40:27 <dcoutts> ndm, yes, I recok there's a good chance that it could be portable even for FFI. but probably only when using ccall. stdcall is really win32 specific.
07:40:49 <dcoutts> ndm, no everything use ccall, except the win32 api itself.
07:41:23 <ndm> in windows world, some stuff uses __fastcall (pascal stuff mainly) as well
07:41:27 <xerox> callcc?
07:41:30 <dcoutts> eg gtk compiled for unix or win32 should be the same really.
07:42:02 <ndm> dcoutts, i think i'm missing the point slightly - it feels as though i've missed something...
07:42:05 <dcoutts> all portable C code uses ccall convention for everything
07:42:12 <ndm> yes
07:42:49 <dcoutts> ndm, I reckon that it should be possible to have say gtk2hs compiled with yhc and work without modification between win32 & linux (and across arches on linux)
07:43:18 <dcoutts> ndm, the only bit that would need to change is the "package file" or something to say which .so or .dll files to load.
07:43:39 <ndm> dcoutts, that would be desirable - and definately something worth working for
07:43:44 <ndm> and should fall out quite naturally
07:43:48 <dcoutts> appart from that, loading up a given symbol name and makeing a ccall to it should be essentiall the same for all arches
07:44:03 <ndm> yes, that would be the way it works
07:44:11 <dcoutts> since the rts is specific for the platform it can smooth out any wrinkles
07:44:17 <ndm> yep
07:44:31 <ndm> i.e. on windows it does LoadLibrary and GetProcAddress to do symbol resolution
07:44:35 * basti_ can now make 10 submit buttons with unique id's by page = <p> <% combineL $ replicate 10 submit %> </p> in haspr.
07:44:39 <dcoutts> wrinkles like how to setup a ccall on a sparc or ppc64 (which is rather tricky)
07:44:46 <Maddas> basti_: heh!
07:44:54 <basti_> (and will later be able to reconstruct the ID's)
07:44:57 <basti_> is that good or not?
07:44:58 <dcoutts> ndm, yes and on posix it used dlopen + dlsym
07:45:07 <ndm> yep, thats how its currently working
07:45:24 <ndm> that is one of the desired effects of yhc
07:45:37 <ndm> a GUI haskell program that *isn't* 8mb in size
07:45:38 <dcoutts> ndm, glibc has some FFI lib for constructing C calls on the fly. That might be useful. I think it's also distributed as a seperate lib.
07:45:45 * basti_ has earned a hackersnack
07:45:54 <dcoutts> ndm, see libffi on linux
07:45:58 <ndm> dcoutts, cool will pass it onwards
07:46:15 <dcoutts> ndm, it handles setting up the stack and registers for the C call etc
07:46:29 <ndm> very handy, could make ffi implementation easier
07:46:33 <ndm> thanks
07:46:38 <dcoutts> np
07:47:24 <Maddas> basti_: Sounds great :-)
07:47:28 * Maddas should look at haspr sometime
07:47:55 <basti_> it was a painful journey to get this far.
07:48:41 <basti_> the pivot now is a datatype that encapsulates a "State" and runs this as soon as a form is converted to XML, to get the unique ID's
07:49:59 <basti_> hmm but no, i should make that triggerable, so I can decide what is a Form and what is not.
07:50:05 * basti_ sighs
07:51:20 <dcoutts> ndm, http://sources.redhat.com/libffi/
07:51:28 <dcoutts> ndm, it says it's part of gcc now
07:51:48 <kolmodin> ah, found my bug
07:51:52 <ndm> nice, have told the guy implementing it
07:52:38 <kolmodin> is there a way to derive a Read insance without adding "deriving Read" where it's defined?
07:53:03 <dcoutts> kolmodin, DrIFT or Template Haskell
07:53:45 <kolmodin> nothing easier? :)
07:54:01 <dcoutts> sorry
07:54:49 <kolmodin> I get a generated AST from bnfc, but the data types are missing Read instances
07:55:16 <kolmodin> quite annoying..
07:58:06 <Oejet> I'm wondering, given that you have the entire source for your program and dependant libraries, couldn't a compiler not compile in exactly the functions which are necessary, thus saving some space?
07:58:16 * shapr swears at haskell-mode
07:59:08 <ProfTeggy> shapr, is 'semantic.el' any good?
08:00:11 <shapr> ProfTeggy: Sort of
08:00:36 <shapr> It's a good idea, and I think it's the right idea, but it doesn't work very well.
08:00:55 <shapr> Emacs users tend to stick with regex manipulation, which I consider stone age tech.
08:01:28 <shapr> The plan for hIDE is to have all the modes based on parsers, though most modes will start out using regexes for highlighting.
08:02:15 <ProfTeggy> shapr, thank you
08:02:45 <shapr> The Semantic Bovinator would be great if it were given the official blessing of the (x)emacs maintainers, and all the regex modes were rooted out and replaced.
08:03:07 <shapr> I could go on in great detail :-)
08:03:11 <dcoutts> shapr, yep, all the modes that people don't care about sufficienly will use the GtkSourceView regex based syntax highliting.
08:03:16 <Leimy> regex still works as well as it used to though and it is well understood
08:03:50 <dcoutts> Leimy, yes it's fine much of the time. But for some languages there are corner case which don't work well.
08:03:53 <Maddas> Doesn't regex-based highlighting work pretty badly in general? (Just working well for the "typical" cases)
08:04:07 <Leimy> sure
08:04:13 <dcoutts> Leimy, and shapr is particularly good at finding and getting annoied with those corner cases :-)
08:04:16 <Leimy> I'll look at hIDE someday
08:04:27 <Leimy> but the fact that it says IDE in it means I'm gonna hate it
08:04:27 <Leimy> I hate IDEs
08:04:27 <Leimy> :)
08:04:27 <shapr> Truly, I seem to be a corner case myself.
08:04:27 <Igloo> RE syn hl works fine in most cases
08:04:34 <dcoutts> Leimy, hopefully when hIDE is nearer to being useful :-)
08:04:40 <Igloo> Haskell has a few oddities, like "as" only being a keyword in certain contexts
08:04:51 <Maddas> Heh. Maybe it's just Emacs modes that don't do things very well :-)
08:05:00 <Leimy> C has oddities like that too
08:05:06 <Leimy> and it shows up more in C++
08:05:06 <Maddas> Doesn't almost every language? ;-)
08:05:17 <Leimy> , being an operator or just a separator for instance :)
08:05:38 <Leimy> some C++ declarations are horribly nasty
08:05:39 <dcoutts> Leimy, we're hoping to make hIDE not one of those "get in your way" sort of IDEs :-)
08:05:57 <dcoutts> Leimy, but getting the UI right is not that easy.
08:06:41 <Leimy> string file(istream_iterator<char>(cin), istream_iterator<char>()); is different from string file((istream_iterator<char>(cin)), istream_iterator<char>());
08:07:00 <Leimy> UI is the problem
08:07:09 <Leimy> as soon as it's defined you are stuck with it for the most part
08:07:18 <dcoutts> Leimy, well feel free to contribute your UI ideas
08:07:21 <xerox> dcoutts, gtk2hs on windows works only with ghc 6.2.2?
08:07:26 <Leimy> keep in mind I'm a plan 9 user sometimes :)
08:07:32 <Leimy> there's basically no UI :)
08:07:33 <dcoutts> xerox, no it works with 6.4
08:07:33 <Leimy> I kind of like it
08:07:58 <dcoutts> xerox, well with 6.4 too. And it should build from source with any version.
08:08:15 <dcoutts> xerox,  really need to do another gtk2hs release with a win32 installer.
08:08:34 <dcoutts> *I* really need to ....
08:10:35 <shapr> hola labra
08:10:43 <shapr> Kactus Jack is pretty good.
08:10:45 <labra> hola, hablas espaol?
08:10:49 <ndm> dcoutts, i've been writing a new installer for winhugs
08:10:52 <labra> thanks :)
08:10:53 <ndm> if you are interested...
08:11:00 <dcoutts> ndm, what do you use
08:11:03 <ValarQ> can't be easy writing an IDE
08:11:07 <ndm> C :)
08:11:19 <dcoutts> ndm, I've been using something that's not too bad. I just need to do another release with it.
08:11:29 <dcoutts> ndm, oh :-)
08:11:30 <ndm> dcoutts, what do you use?
08:11:33 <shapr> no habla espaol
08:11:36 * dcoutts tries to remember
08:11:37 <shapr> sadly
08:11:41 <ndm> but the installer is very generic and portable
08:11:42 <xerox> dcoutts - I'm trying with GHC 6.4.1
08:11:45 <labra> ok...I can speak english
08:11:46 <xerox> (on windows)
08:11:49 <ndm> and all you need to do to build is:
08:11:50 <ValarQ> shapr: hej formarn :)
08:11:58 <xerox> ah, from sources.
08:12:01 <xerox> It is kinda difficult.
08:12:07 <ndm> cat installer.exe my_package_as_a_zip.zip > release_package.exe
08:12:10 <dcoutts> ndm, I use Inno Setup. It's free software.
08:12:13 <Leimy> So whatever happened to Yi?
08:12:32 <dcoutts> Leimy, it's getting a Gtk UI and being made into a plugin for hIDE
08:12:40 <Leimy> gtk
08:12:41 <labra> shapr: thank you for your comment in my blog
08:12:48 <Leimy> well looks like I'll be using emacs till I die :)
08:12:53 <ValarQ> shapr: you said something about stealing Gen from QuickCheck yesterday, how can i do that?
08:12:54 <labra> I did not expect it
08:12:58 <dcoutts> Leimy, though it'll still be usable stand alone and with the curses UI
08:13:10 <Maddas> Leimy: :-)
08:13:29 <shapr> labra: sure :-)
08:14:18 <shapr> ValarQ: Maybe you can import QuickCheck and use the Gen monad?
08:14:54 <labra> by the way...I was trying to compile lambdabot and I found the sourceforge page
08:15:05 <shapr> That's waay out of date.
08:15:08 <labra> but I also found that the last version is in a different place
08:15:14 <shapr> @version
08:15:16 <lambdabot> lambdabot 3p104, GHC 6.5 (OpenBSD i386)
08:15:16 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:15:23 <shapr> I should remove most of the source in haskell-libs
08:15:30 <labra> maybe it would be a good idea to provide some link to the new version?
08:15:49 <shapr> Yes, good idea.
08:16:05 <labra> do you know if lambdabot would compile in ghc 5.02
08:16:22 * ValarQ scratches his head
08:16:28 <dcoutts> labra, probably not
08:16:38 <labra> i was afraid of that
08:16:54 <dcoutts> I don't think 5.02 has the heiricharcal libs
08:17:04 <labra> no, it does not have them
08:17:19 <dcoutts> 5.04 might be ok :-)
08:17:29 <dcoutts> labra, I suggest you use a much more recent ghc
08:17:36 <labra> yes, of course :)
08:17:49 <labra> the problem is that it is the server of our school
08:17:55 <labra> and it is a bit out of date
08:18:16 <dcoutts> if you've got enough disk space you can install a version in your home dir
08:18:19 <shapr> Get your admins to install debian?
08:18:37 <labra> it is debian but it is woody
08:19:00 <shapr> oh
08:19:14 <dcoutts> shapr, easier said than done. I have a hard enough time trying to get our IT people to move from Solaris 9 to 10, let alone switching to soemthing else completely.
08:19:31 <shapr> scary
08:19:38 <labra> I tried to compile the sources of ghc 6.4 but it gave me some errors
08:20:02 <shapr> But then, after four years my German clients are finally comfortable with Zope and Python, and now I want to switch to something else.
08:20:09 <dcoutts> shapr, yeah, it's "welcome to the 80's" for all our new students each year :-)
08:20:28 <shapr> cutting edge research, just to keep our stone age hardware running...
08:20:34 <shapr> I feel like that sometimes.
08:21:07 <shapr> labra: Maybe we can help you fix the errors for 6.4 ?
08:21:53 <labra> ok...I will say where it stops compiling...
08:21:55 <labra> just a moment
08:21:56 <dcoutts> shapr, by default we make our students use basically raw X11 with a very old style WM. The really new thing we've got is Gnome 2.0 (yes .0)
08:22:57 <shapr> wow
08:23:09 <Oejet> dcoutts: Same here.  You'd think universities were progressive...
08:23:52 <labra> ok...i have downloaded the sources
08:23:55 <dcoutts> Oejet, I think it's porbably worse among CS departments since they got computers first so they've had longer to drag their feet
08:23:57 <labra> and I made ./configure
08:24:01 <davve> dcoutts, we just switched from your kind of system to x86 and linux.. now everyone just plays quake3
08:24:37 <Oejet> dcoutts: Exactly.
08:24:46 <dcoutts> davve, yeah our new PhD students have got x86 boxes with linux/windows dual-boot. But the undergrads...
08:25:59 <Leimy> have free strippers?
08:26:10 <Maddas> davve: Don't worry, that'll stop soon.
08:26:17 <Maddas> davve: I think Quake 4 is just 'round the corner :-)
08:26:24 <Leimy> it is
08:26:29 <Leimy> I think it's out this month isn't it?
08:26:39 <Leimy> then Xbox 360 before christmas
08:26:51 <Maddas> Not sure, I just overheard some (Quake-playing) friends mentioning it.
08:27:10 * Maddas doesn't even have a TV in his room
08:27:11 <labra> no, when i run make
08:27:22 <labra> it compiles some of the modules...
08:27:25 <Leimy> it's out in 4 days :)
08:27:35 <labra> but then, it stops with
08:27:48 <Maddas> Leimy: :-)
08:28:01 * shapr doesn't own a TV
08:28:07 <labra> it stops compiling the "foreign.hs"
08:28:10 <shapr> I do have a Playstation 2 though
08:28:24 <labra> it says that it does not find the "Foreign.hi"
08:29:55 <shapr> labra: Hm, I don't know. What sort of system are you compiling on?
08:30:35 <Maddas> shapr: Heh, do you play on the TV with it or is it defunct?
08:30:46 <Maddas> Er, s/TV/computer/ (obviously :-)
08:32:02 <labra> it is debian
08:32:24 <labra> I am trying to remember how to obtain the version number and such information
08:32:41 <labra> i think it is 2.4.20
08:33:14 <labra> maybe the problem is that the new 6.4 version uses hierarchical libraries?
08:37:38 <labra> what do you need?
08:45:47 <vincenz> re
08:55:20 <Lemmih> Yak! The people wanting to include regex'es in the next Haskell standard must be pulling some kind of horrible joke.
08:55:44 <vincenz> Lemmih: you mean "yacc"?
08:55:48 * dcoutts thought that too
08:55:50 <vincenz> :P
08:55:55 <Philippa> I don't mind them being in the standard library. Too much. Syntactic support? Sod off
08:57:09 <Lemmih> The notion of 'standard libraries' is obsolete and will go away.
08:57:22 <Maddas> Lemmih: WhY?
08:57:44 <Maddas> Do you mean regarding Haskell in particular or in general?
08:58:00 <Lemmih> Maddas: It was a convenience trick which hopefully wont be needed in the future.
08:58:34 <Maddas> Lemmih: I don't think I understand what you mean :-)
09:00:01 <Lemmih> Installing a Haskell library was unreasonably hard before Cabal. The Haskell implementations 'fixed' this by shipping with a large set of standard libraries.
09:00:14 <Maddas> Ah, I see what you mean.
09:02:47 <Philippa> OTOH, things like the IO and ST monads are a little more critical IMO
09:04:23 <Lemmih> Philippa: GHC should ship with vital packages like 'base' and 'rts'.
09:04:31 <Oejet> The point being, I guess, that there will be an endorsed library distribution, one that you can expect all Haskell implementations to have?
09:05:52 <dcoutts> Oejet, the other way of looking at it is that a "standard" library should simply be an implementation that works with any Haskell implementation.
09:06:39 <Oejet> But it sure is nice to have no "external" library dependencies.
09:06:59 <dcoutts> that's because current packaging is less the great
09:07:21 <Philippa> once it really is just cabal-get parsec, it won't need to come with the compiler
09:07:22 <dcoutts> if it was easier to install things with automatic dependency resolution then "external" would not seem so bad
09:07:36 <Philippa> (though a big pile-o'-packages you can install by default wouldn't go amiss)
09:08:07 <dcoutts> though how do we bootstrap cabal-get ?
09:08:19 <dcoutts> include it with hugs/ghc/yhc/jhc etc?
09:09:00 <Igloo> The impls must include enough to build it
09:10:12 <dcoutts> Igloo, but then it makes installing ghc + other libs hard if there is a manual step of "download this tarball and build cabal-get"
09:10:37 <dcoutts> currently it's very easy to get ghc with parsec.
09:10:48 <dcoutts> it needs to be just one step away
09:11:00 <dcoutts> does perl come with it's cpan thingy?
09:11:23 <Igloo> I think there should be 2 ghc tarballs, one with extra stuff in installme/. ghc will automatically build and install anything in that directory (either topologically sorting it itself or just by reading a file with the order in)
09:12:02 <Igloo> cabal-get would be in the second only
09:12:16 <Lemmih> Yihaa. SimonMar fixed the 'unknown exception' bug (:
09:12:42 <Igloo> Actually, I guess there's no need for the first one to contain all the necessary libs
09:13:23 <ProfTeggy> Nice weekend all.
09:16:17 <dcoutts> Lemmih, well he figured out what the problem is. It's less clear how to fix it. It requires cabal to not build depend on the util package.
09:17:07 <Lemmih> Oh. Didn't he mark the bug report as fixed?
09:18:32 <dcoutts> Lemmih, oh well it doesn't report unknown execption any more
09:18:48 <dcoutts> Lemmih, it now reports a more helpful error
09:19:19 <dcoutts> Lemmih, which cabal version are you using?
09:20:53 <Lemmih> 1.1.4
09:22:18 <Lemmih> Seven patches younger than the current darcs repo.
09:22:36 <rep> woot
09:23:14 <dcoutts> Lemmih, what does this report: ghc-pkg field Cabal-1.1.4 depends
09:24:16 <Lemmih> depends: base-1.0
09:24:33 <dcoutts> oh so SyntaxNinja did fix it then
09:24:34 <dcoutts> good
09:24:57 <dcoutts> earlier versions depended on util be default which is what caused all the problems
09:26:57 <Lemmih> The darcs repo of Cabal still depends on util /-: I removed the dependency myself because it was causing trouble with something else.
09:27:21 <dcoutts> Lemmih, oh. :-(
09:27:35 <dcoutts> Lemmih, I did the same thing. And the gentoo ebuild does that too.
09:28:21 <dcoutts> @seen SyntaxNinja
09:28:22 <lambdabot> I saw SyntaxNinja leaving #haskell 15 hours, 37 minutes and 8
09:28:22 <lambdabot> seconds ago.
09:28:24 <Lemmih> Does it use the 'util' package on Windows or mac?
09:28:46 <dcoutts> Lemmih, it build-depends on it on all packages but uses it on none
09:28:59 <dcoutts> packages/platforms
09:29:10 <dcoutts> it uses the unix package
09:29:18 <dcoutts> which the util package pulls in as a dep
09:29:21 <Lemmih> Hi SyntaxNinja.
09:29:21 <dcoutts> SyntaxNinja!
09:29:25 <Lemmih> Coming as called (:
09:29:34 <dcoutts> we were just talking about you :-)
09:29:42 <dcoutts> and Cabal
09:30:19 <dcoutts> JaffaCake found yet another way in whihc Cabal depending on the util package breaks things :-)
09:31:22 <dcoutts> Lemmih, and the reson it doesn't depend on the unix package directly is that that package doesn't exist on windows (on windows, the util package does not depend on the unix package)
09:31:53 <dcoutts> so the only platform/ghc-version that needs the unix package is ghc-6.2.2 on unix.
09:32:02 <dcoutts> no other platform needs it
09:32:34 <dcoutts> ghc-6.2.2 on unix is the special case here
09:32:47 <dcoutts> (cabal probably doesn't work with ghc-6.2.2 on windows)
09:33:16 <SyntaxNinja> hi Lemmih, dcoutts
09:33:52 * SyntaxNinja loves the util package
09:34:09 <dcoutts> SyntaxNinja, it would make us very happy if the util dep could be dropped
09:34:22 <dcoutts> and if necessary implment a work around for older ghcs
09:34:41 <dcoutts> at the moment we're breaking things for people using 6.4.x
09:34:59 <dcoutts> it'd be better to have it break for 6.2.2 instead :-)
09:35:16 <dcoutts> and then implement a work around for that case if it's really important
09:35:45 <dcoutts> at the moment people have to manually hack cabal to make it play nicely with anything else.
09:37:10 <SyntaxNinja> yeah
09:37:39 <SyntaxNinja> but we should just harass jafacake to implement optional modules!
09:37:48 <dcoutts> SyntaxNinja, yes that too
09:38:00 <dcoutts> but we also need a shorter term fix
09:38:07 <SyntaxNinja> but yeah, let's drop the util package for ghc < 6.4, and I'll have a separate .cabal file for ghc 6.2.2, which I'm probably the only one usng anyway.
09:38:33 <dcoutts> I think trading off 6.4 brokenness for 6.2.2 brokenness is ok in the short term
09:39:23 <RemiTurk> hi all
09:39:48 <ValarQ> hi you
09:40:26 <dcoutts> SyntaxNinja, we were trying to figure out why only Lemmih and myself could build our software. It turned out to be because both of us had removed the util dep from our Cabal installations. For everyone else ghc gave wierd error messages.
09:47:54 <beelsebob_> Yay, Olaf was impressed
09:48:07 <beelsebob_> ... admittedly he did code himself a very good example
09:48:23 <beelsebob_> he tried a random peice of buggy code and it cut the question count from 22 to 2
09:48:26 <beelsebob_> :)
09:49:19 <SyntaxNinja> dcoutts: makes sense.
09:50:26 <dcoutts> SyntaxNinja, yeah. Unfortunately ghc was throwing an "unknown exception" rather than a propper error message. :-) JaffaCake has now fixed that in cvs.
09:53:47 <SyntaxNinja> ahh, I see. it was JaffaCake's fault... I thought so ;)
09:54:43 * beelsebob_ wonders if jaffaCake has given him cvs access again
09:57:33 <dcoutts> SyntaxNinja, yes. :-). So we've moved from not knowing why other people can't build our stuff, to knowing it's Cabal's fault :-)
09:57:49 <SyntaxNinja> jaffacake's fault!
09:58:02 * SyntaxNinja is glad he's not here...
09:58:05 <beelsebob_> heh
09:58:29 <dcoutts> the bad error message was JaffaCake's fault
09:59:17 <dcoutts> the new error message since JaffaCake fixed it is "ghc-6.4.1: It's Cabal's fault!"
10:01:27 <SyntaxNinja> hehehe
10:02:38 <SyntaxNinja> dcoutts: OK it's on my TODO list.
10:03:05 <dcoutts> ta muchly
10:03:57 <SyntaxNinja> np.
10:14:32 <SyntaxNinja> @yow
10:14:34 <lambdabot> I left my WALLET in the BATHROOM!!
10:14:39 <dcoutts> @arr
10:14:40 <lambdabot> I'd like to drop me anchor in her lagoon
10:14:44 <SyntaxNinja> I found a wallet in the bathroom once.
10:14:51 <SyntaxNinja> must have been lambda
10:14:57 <SyntaxNinja> lambdabot's
10:19:20 <dcoutts> xerox, ibid, yay! my SOE region code is working (implemented in terms of cairo's compositign operators)
10:20:19 <dcoutts> and because it's implemnted using the bitmap compositing it can be extended to use things like a bitmap's alpha channel as a region.
10:23:04 * RemiTurk is going to buy a new harddisk, install a new linux and try gtk2hs+cairo+hIDE Real Soon Now
10:23:44 <dcoutts> RemiTurk, cool
10:24:47 <RemiTurk> I've been planning to upgrade for well over a year now, but never got around to it, but now that my music HD is dying I don't have much of a choice ;)
10:28:05 <RemiTurk> btw, what do people think about the place for class-constraints in JohnMeacham 's class-alias proposal?
10:31:09 <RemiTurk> I'm wondering whether I'd prefer them to be to the left of the alias-part
10:38:21 <wilx> I
10:38:23 <wilx> Err...
10:38:35 <wilx> I prefer the "class alias" wording
10:39:21 <wilx> One can easily miss the difference between = and => but "alias" is virtually impossible to miss.
10:39:55 <wilx> On the other hand it eats one usable variable name.
10:40:03 <RemiTurk> I'm thinking about
10:40:06 <RemiTurk>  > class alias Num a = Eq a => (Additive a, Multiplicative a)
10:40:10 <RemiTurk> vs
10:40:20 <RemiTurk>  > class alias Eq a => Num a = (Additive a, Multiplicative a)
10:40:23 <RemiTurk> or something like that
10:40:26 <wilx> Ah.
10:40:34 <RemiTurk> damn, I'll have to leave _now_ for dinner (parents..)
10:40:46 <RemiTurk> I'll read backlater I guess.. ;)
10:40:47 <RemiTurk> bye for now
10:41:43 <wilx> Hmm, for the sake of uniformity the class constraint should be left of the name.
10:42:59 <syntaxfree> what do you think of Ruby?
10:43:31 <wilx> Well...now that I think about it...isn't it the same as adding Eq a to the alias part?
10:43:32 <wilx> Hmm...
10:43:39 <wilx> syntaxfree, that it is mostly off topic here?
10:44:11 <syntaxfree> well, for someone who really enjoys Haskell, would you choose Ruby over Python?
10:44:42 <Igloo> I'd choose Haskell.
10:46:03 <syntaxfree> I'm learning Haskell, though I use Python in a 99% functional fashion for most of my 'real' work. I haven't quite picked up monads yet.
10:46:15 <xerox> dcoutts, way cool!  You rock!
10:47:03 <xerox> syntaxfree: it's not as hard as it could sound, do it!
10:47:29 <wilx> I'd use Perl :)
10:47:30 <syntaxfree> I like higher-order functions.
10:47:37 <syntaxfree> I think in higher-order functions.
10:47:48 <wilx> But if I were to pick between the two I would pick Ruby over Python.
10:47:48 <syntaxfree> I can't fathom how anyone gets anything done without higher-order fucntions.
10:47:58 <wilx> lol
10:48:13 <wilx> People do whole lot of stuff in languages like C/C++ etc.
10:48:18 <wilx> You get used to it.
10:48:34 <syntaxfree> I think my brain's not wired for languages without higher-order functions.
10:48:40 <Maddas> I doubt that.
10:48:42 <xerox> syntaxfree: I'd say, take a look at http://www.haskell.org/hawiki/MonadsAsContainers
10:48:44 <Maddas> I doubt it's wired for either :-)
10:49:14 <syntaxfree> anyway. sometimes I want to get the results from a very large computation and do something like print descriptive stats without calculating everything again.
10:49:22 <syntaxfree> the type system also gets into my nerves sometimes.
10:49:58 <sethk> syntaxfree, which type system?  c++?
10:50:08 <syntaxfree> Haskell.
10:50:10 <xerox> It has one ?!  <chuckle>
10:51:36 <syntaxfree> Functional style seems to suit better for writing the actual numerical computing, but doing some final-art procedures on the bulk of data seems like an imperative job to me.
10:51:53 <syntaxfree> Let's say I build this big list of numbers using a functional program.
10:52:00 <xerox> Like... ordering?  <chuckle-again>
10:52:13 <syntaxfree> So I need the list of numbers, but I also need the arithmetic mean of them.
10:52:27 <syntaxfree> I'm not gonna just write "mean list" and let it compute everything again!
10:52:45 <xerox> syntaxfree: functional structures does memoize.
10:53:18 * Maddas doesn't understand
10:53:21 <syntaxfree> so if I write a program and actually compile it to an executable binary, it will "memoize"?
10:53:23 <Maddas> Why would it compute everything again?
10:53:36 <syntaxfree> because that's what happens when working at ghc or hugs!
10:53:41 <xerox> Maddas: indeed.  With functional structures you get persistence for free!
10:53:46 <xerox> (or is it persistance?)
10:53:48 <Maddas> xerox: I don't understand either :-)
10:54:15 <Maddas> syntaxfree: You mean if you access a variable, the contents are recomputed on every access?
10:54:31 <syntaxfree> well, yeah. it's not a variable, it's a function.
10:54:48 <Maddas> syntaxfree: Why not save the result to a variable then?
10:55:10 <syntaxfree> hmm. Now I'm starting to feel pretty stupid. In Haskell?
10:55:12 <Maddas> I have the feeling that I'm missing the mark :-)
10:55:23 <xerox> syntaxfree: try using ':set +s' in GHC.
10:55:26 <xerox> GHCi, even.
10:55:43 <Maddas> syntaxfree: Yes, why not?
10:55:49 <syntaxfree> hmm. How?
10:55:52 <xerox> Also, there is no difference between 'variables' and 'functions', they are all values.
10:56:28 <Maddas> xerox: Well, right. But if I save the result of executing a function in a variable (say, using let), surely accessing the variable doesn't really recompute it every time?
10:56:54 <syntaxfree> yes, but isn't "let" local to a specific function like in Lisp?
10:56:58 <sethk> Maddas, no, of course not
10:57:03 <syntaxfree> er, Scheme. I keep on calling Scheme Lisp.
10:57:09 <xerox> Maddas: that's true.  Check with ':set +s' in GHCi.
10:57:15 <sethk> syntaxfree, doesn't matter, scheme is very close to lisp
10:57:21 <Maddas> xerox: Right, so that's the difference I was talking about :-)
10:57:38 <sethk> Maddas, there is nothing keeping you from allowing the let to be whatever scope you may need
10:57:40 <xerox> Maddas: but Haskell is lazy!
10:57:49 <Maddas> xerox: Isn't that orthogonal to my point?
10:58:01 <sethk> Maddas, also see the where (which is like let, but at the end) which to me is more natural looking.  But that's just an esoteric opinion
10:58:09 <sethk> Maddas, no, it isn't orthogonal
10:58:22 <sethk> Maddas, and since you have full control over the scoping of the let, I don't see your point
10:58:25 <syntaxfree> @eval let x = map (\x->product [1..x]) [1..5] in main = do print x
10:58:27 <xerox> Maddas: in some sense, a let binding of a function (partially or fully applied, doesn't matter), saves the computation to-do, not the resulting value.
10:58:30 <lambdabot>  parse error on input `='
10:58:38 <xerox> But I miss what do you mean by orthogonal :-)
10:58:40 <syntaxfree> what's wrong with that?
10:58:58 <sethk> syntaxfree, indeed, you can enter bad syntax.  so what?
10:59:10 <syntaxfree> haha. I'm not trying to make a point.
10:59:11 <xerox> syntaxfree: 1) lambdabot does not do IO 2) "main =" ?!
10:59:25 <Maddas> xerox: Right, I know that. I just wanted to point out to syntaxfree that it doesn't execute the computation to-do every time you access the variable.
10:59:31 <syntaxfree> I'm trying to get my syntax right so I can ask if that code will do what I mean.
10:59:45 <Maddas> xerox: Whether it executes it on first access or right away (strictly) is another question
10:59:47 <xerox> Maddas: Okay.  What's the meaning of orthogonal?
10:59:55 <syntaxfree> so, essentially, a Haskell compiler will do stuff the smart way?
11:00:06 <Maddas> xerox: Hm, 'not pertaining to'
11:00:13 <xerox> syntaxfree: that's what you should expect :-D
11:00:19 <Maddas> xerox: As in, it is not relevant to that particular question
11:00:37 <xerox> Maddas: thanks!
11:00:40 <sethk> syntaxfree:     do x <- map (\x->product [1..x]) [1..5] let x = map (\x->product [1..x]) [1..5] in main = do print x
11:00:45 <sethk>                                  syntaxfree sorry
11:00:53 <sethk> syntaxfree:     do x <- map (\x->product [1..x]) [1..5]
11:00:59 <syntaxfree> let x = map (\x->product [1..x]) [1..500] in do print (sum x)
11:01:00 <syntaxfree> that works.
11:01:08 <syntaxfree> hmm.
11:01:08 <sethk> syntaxfree, true
11:01:10 <Maddas> xerox: I think it's just a pseudo-analogy of orthogonality in Geometry, but I don't know for sure
11:01:16 <sethk> syntaxfree, there are several ways to do it.
11:01:25 <Maddas> sethk: My point was only that you could store values in let.. sorry if I said more than I realized
11:01:27 <syntaxfree> "Orthogonal" as in "independent" comes from statistics.
11:01:29 <xerox> syntaxfree: what's your point in doing IO?
11:01:36 <Maddas> syntaxfree: Oh, cool, thanks.
11:01:41 <sethk> Maddas, I didn't dispute that.  I don't think.
11:01:52 <sethk> Maddas, maybe I misunderstood something you said
11:02:00 <Maddas> sethk: I probably said more than I wanted to :-)
11:02:08 <Maddas> No worries, then
11:02:21 <syntaxfree> xerox: I want to print an expensive-to-compute list and its mean.
11:02:44 <syntaxfree> without having it compute the list twice.
11:03:15 <arjanb> the hawiki got a lot spam again :(
11:03:17 <xerox> syntaxfree: print $ concat [sum xs, mean xs] where xs = computation
11:03:19 <sethk> syntaxfree, I don't see any place where the list is computed twice.  (I assume you mean generated)
11:03:50 <xerox> Simplifying.
11:03:57 <Maddas> syntaxfree: Right, the let (or where) should do that just fine, for example.
11:04:23 <syntaxfree> so basically a Haskell compiler is a lot smarter than the compiler of an imperative language.
11:04:52 <astrolabe> It seems similar to an imperitive language to me
11:05:06 <sethk> syntaxfree, I don't see anything here that an imperative compiler would handle differently
11:05:13 <Maddas> syntaxfree: Apart from lazy evaluation, why in this regard? What is special about this way of using let/where?
11:05:19 <astrolabe> it's like :  let a = computation, print a, print mean(a)
11:05:46 <Heffalump> BOO!
11:05:55 <Maddas> syntaxfree: It's just like Scheme's (let ((xs (computation))) (print xs) (print (mean xs)))
11:05:56 <syntaxfree> yes. but "a" in astrolabe's example will be a variable containing a number, not a computation.
11:06:54 <xerox> syntaxfree: once the computation is done, the value is memoized, in a functional structure.
11:07:03 <astrolabe> syntaxfree: true, but that is about when the calculation is done, rather than how many times.
11:08:31 <syntaxfree> In an imperative language, if I do something like "print expensive_computation(x), mean(expensive_computation(x)), it will call the function twice.
11:08:53 <Maddas> syntaxfree: Uh, yes. But not if you save expensive_computation(x) to a variable first and use that instead.
11:08:53 <xerox> That's strictness.
11:09:06 <Heffalump> and not if the function is marked as pure and the compiler does CSE
11:09:13 <Maddas> Right :)
11:09:15 <syntaxfree> CSE?
11:09:24 <Heffalump> common subexpression elimination
11:09:29 <syntaxfree> ah, yes.
11:09:46 <Heffalump> the key difference is that in a language like Haskell, all functions are pure
11:09:49 * syntaxfree is reminded of #gentoo discussions of compiler flags.
11:09:53 <Heffalump> no need for special annotations
11:10:04 <syntaxfree> Heffalump: pure means?
11:10:23 <Heffalump> "has no side effects and returns the same value when passed the same parameters"
11:10:30 <syntaxfree> hmm.
11:10:37 <sethk> syntaxfree, it's true that you can do dumb things in an imperative language.  Actually, though, doing dumb things is much more costly in a functional language
11:10:45 <sethk> syntaxfree, but that's not a characteristic of the language
11:10:53 <syntaxfree> Pure function = an actual function, as opposed to a subroutine that reads from/affects global variable.
11:10:55 <sethk> syntaxfree, you can find a way to miscode and force recompilation in any language
11:11:09 <sethk> syntaxfree, no, not function in that sense
11:11:27 <astrolabe> but in haskell, the compiler is'nt guaranteed to simplify f 3 + f 3 I don't think.
11:11:45 <syntaxfree> hmm.
11:12:15 <ValarQ> astrolabe: not guarantieed, but it should be safe for it to do right?
11:12:16 <Heffalump> it's not.
11:12:28 <Heffalump> (guaranteed, that is)
11:12:28 <astrolabe> so say a + a where a = f3
11:12:28 <syntaxfree> I've been doing some Haskell for four or six weeks now, but I think I haven't quite understood lazy evaluation yet.
11:12:30 <Heffalump> it's nomally safe.
11:12:31 <Maddas> syntaxfree: The thing is, if you save let a = expensiveComputation x in ... that is analogous to binding it to a variable in other languages
11:12:38 <Heffalump> unless it could create a space leak
11:14:16 <syntaxfree> it seems to me that (cost of dumb code / cost of smart code) in Haskell is higher than in other languages.
11:15:59 <ndm> i can't get to scannedinavian.org, can anyone else
11:15:59 <shapr> syntaxfree: Yes, I agree.
11:16:04 <shapr> I can get there fine.
11:16:32 <shapr> ndm: Is it the hostname problem again?
11:16:34 <ndm> i get no response, was hoping to get GHC API
11:16:36 <sethk> ndm, takes me 9 hours on an airplane
11:16:37 <syntaxfree> so suppose I was to create a new data type, circularList.
11:16:41 <ndm> shapr, how do i tell?
11:16:53 <astrolabe> syntaxfree:  I think it that is a measurement ot the sophistication of a language.
11:16:59 <ndm> do you have an IP address i can try?
11:17:00 <shapr> ndm: What does "host www.scannedinavian.org" give you?
11:17:04 <syntaxfree> circularList is a lot like a regular list, except it's ... circular.
11:17:11 <ndm> shapr, a long wait
11:17:15 <shapr> hm
11:17:22 <shapr> What about scannedinavian.com ?
11:17:38 <Heffalump> syntaxfree: how would you define that as a datatype?
11:17:42 <ndm> shapr, same
11:17:45 <astrolabe> works for me shapr.  Pic of a penguin :)
11:18:05 <shapr> ndm: it's 194.23.215.164
11:18:08 <syntaxfree> can I redefine (!!)  so that let a = [1,2,3,4,5] in a!! 7    returns 2?
11:18:15 <syntaxfree> oops.
11:18:34 <syntaxfree> nah, that's right.
11:18:40 <Heffalump> only by hiding the prelude
11:18:46 <shapr> ndm: Does the ip work?
11:18:59 <shapr> astrolabe: I'm glad it works for someone.
11:19:11 <tomaszz> syntaxfree: why not use: cycle [1,2,3,4,5] ?
11:19:20 <syntaxfree> hmm. there's such a thing?
11:19:35 <ndm> shapr, yep the ip works fine :)
11:19:43 <tomaszz> syntaxfree: it's in the Prelude
11:19:46 <syntaxfree> oh, christ, that's probably faster than the implementation of the Josephus I wrote.
11:20:00 <shapr> Something's very screwy with the DNS system. Or my configuration, not sure which.
11:20:41 <syntaxfree> I can often not open lambda-the-ultimate.org
11:21:05 <ndm> shapr, i can run some commands or something if you need more debug information
11:21:37 <sethk> ndm, run the dig command for the site you aren't reaching
11:21:50 <sethk> ndm, that will give you information about what dns is doing
11:23:05 <ndm> it looks to resolvel to 213.242.136.207
11:23:16 * shapr grumbles
11:23:18 <ndm> yeah, ping agrees
11:23:31 <sethk> ndm, what dig command did you enter?
11:23:35 <shapr> I update my DNS records some months ago. That's the old IP address.
11:23:41 <SyntaxNinja> shapr!
11:23:53 <shapr> SyntaxNinja!
11:24:25 <syntaxfree> hmm. Apparently, I have a Brother in Syntax.
11:24:39 <Lemmih> @seen dons
11:24:39 <lambdabot> dons is in #haskell-overflow, #haskell-blah and #haskell. Last spoke
11:24:39 <lambdabot> 7 hours, 41 minutes and 40 seconds ago.
11:24:45 * syntaxfree whistles the guitar solo to "brothers in arms".
11:25:17 <shapr> That's a great album.
11:25:24 <syntaxfree> no it isn't.
11:25:37 <syntaxfree> the organ-driven second track is the Song I Most Hate In The World.
11:25:54 <syntaxfree> or is it the third track? The organ-driven ditty.
11:25:58 <shapr> ?
11:26:07 <shapr> Oh, chix for free?
11:26:18 <sethk> syntaxfree, it's a parody.
11:26:22 <syntaxfree> nah. "Money for nothing" is good.
11:26:41 <syntaxfree> I used to play-and-sing a KDE parody of "Money for nothing".
11:26:59 <shapr> er, why would "dig scannedinavian.org" give me the wrong answer when executed on scannedinavian.org itself?
11:26:59 <sethk> syntaxfree, I said the second track is a parody
11:26:59 <syntaxfree> "I want my ... I want my .. I want my KDE ..". Then I bought a Mac.
11:27:09 <syntaxfree> the organ-driven one?
11:27:25 <sethk> syntaxfree, the one you said you hated
11:27:45 <syntaxfree> I mostly like "Money for nothing", the acoustic/country/ballad one and "Brothers in arms".
11:28:12 <syntaxfree> there's a #haskell-blah.
11:28:21 <syntaxfree> Should I take my usual off-topic banter there?
11:28:34 <astrolabe> Is there a name for the idiom where a function returns a list it is passed, but with some new elements consed onto the front?
11:29:39 <sethk> astrolabe, not sure what you mean.  It's common to return stuff like          f x = whatever:whatever:x
11:30:05 <astrolabe> yeah, that
11:30:18 <syntaxfree> why is that an idiom?
11:30:43 <astrolabe> to build lists efficiently, rather than using ++ recursively
11:31:21 <tomaszz> sometimes it's forced by performance penalty of (list ++ [a])
11:31:41 <tomaszz> I wouldn't call this an idiom
11:32:17 <syntaxfree> We've come up with a martial arts style colored belt grading system:
11:32:19 <syntaxfree> tee hee.
11:32:34 <astrolabe> Isn't a programming idiom just a commonly used pattern?
11:32:37 <tomaszz> we should use democratic sequences more often
11:32:41 <Heffalump> syntaxfree: that's rather out of date
11:33:15 <syntaxfree> drats.
11:33:20 <syntaxfree> what's the new system?
11:33:41 <Heffalump> there isn't one, but noone has updated that one for aaaages.
11:33:45 <Heffalump> feel free to do so.
11:33:51 <syntaxfree> I can't.
11:33:56 <syntaxfree> I'm just a yellow/orange belt.
11:34:02 <syntaxfree> more yellow-ish.
11:34:43 <tomaszz> I vote that Data.Sequence should be part of the new Haskell standard
11:35:07 <tomaszz> The same with Data.Set and Data.Map
11:35:49 <musasabi> tomaszz: I would rather see a good well defined library package than trying to squeeze everything to base.
11:40:46 <sethk> tomaszz, what difference does it make if it is in base, or in a library that is always available?
11:41:26 <tomaszz> hmmm... OK, you are right
11:41:55 * syntaxfree wonders if he should learn Fortran.
11:42:34 <astrolabe> I suppose it's a trade off between not having too many includes, and not using up too much of the namespace
11:42:56 <astrolabe> syntaxfee:  Why?  you do numerical stuff?
11:43:30 <syntaxfree> yes.
11:44:20 <astrolabe> My job is numerical algorithms, and I get by with C,C++ and matlab (yuk).
11:44:34 <syntaxfree> I know Matlab.
11:45:03 <syntaxfree> That's mostly what I use.
11:45:04 <astrolabe> What kind of algorithms do you do?
11:45:28 <astrolabe> Ah, I see why you are called syntaxfree now :)
11:46:05 <syntaxfree> I'm trying to get in a masters program in numerical mathematics.
11:47:12 <astrolabe> Ah, ok.  Good luck.  Maybe you could ask one of the lecturers.
11:47:34 <syntaxfree> ask what?
11:47:46 <syntaxfree> I went to a summer course there.
11:48:17 <syntaxfree> I'm getting my BS in economics, but I really want to move onto numerical computing.
11:48:42 <astrolabe> Ask if it would be helpful to learn Fortran.
11:48:58 <syntaxfree> ah, yes.
11:49:41 <syntaxfree> they mostly use Matlab, it seems.
11:49:53 <astrolabe> I can recommend browsing Numerical recipes.  It is quite readable.
11:50:15 <musasabi> syntaxfree: You are probably best of with the tool the department prefers.
11:50:55 <syntaxfree> that means "Don't mention functional programming in your application letter"?
11:51:06 <astrolabe> hee hee
11:51:33 <syntaxfree> I was hoping to get away with mentioning how I'm interested in the application of functional programming to the world of numerical maths :(
11:52:08 <astrolabe> They probably use Matlab for prototyping, and a PROPER language for implementation.
11:52:24 <syntaxfree> I see.
11:52:43 <astrolabe> syntaxfree:  You could, if you had examples or specific ideas.
11:52:44 <syntaxfree> dang. What am I gonna write in my application letter?
11:53:12 <astrolabe> Well, why do you want to do it?
11:53:34 <syntaxfree> astrolabe: I'm guessing recursive computation of nth-order derivatives using the Taylor series ain't quite it :~
11:53:57 <syntaxfree> mostly because I read a  numerical maths manual  and became fascinated with it.
11:54:10 <syntaxfree> Then went on to a summer course in the school I'm applying to and also enjoyed it.
11:54:39 <astrolabe> Maybe I'm naive, but they seem like good reasons to me.
11:55:00 <syntaxfree> well, my problem is, I'm finishing my BS in economics.
11:55:33 <syntaxfree> and I have a mediocre GPA, to boot.
11:55:44 <astrolabe> My feeling is that functional programming is good for rapid prototyping and non-time critical applications.
11:56:23 <astrolabe> But matlab has the advantage for prototyping that it has lots of 'library' type functions built in.
11:56:36 <astrolabe> Particularly for linear algebra.
11:56:39 <musasabi> There are at least the scientific computing (numeric calculations) in OCaml people.
11:57:01 <syntaxfree> maybe I'm just too nave about the sheer size of real-life (or academic, for that matter) computations.
11:57:14 <syntaxfree> OCaml is impure-functional, right?
11:57:27 <musasabi> yes.
11:57:28 <astrolabe> But if you wanted to experiment with new tree-type algorithms, red-black trees, ball-trees etc, Haskell would be ideal.
11:58:06 <syntaxfree> I know they have some work in fluid dynamics. What are red-black trees?
11:58:35 <astrolabe> They are a structure for binary trees that keeps them relatively balanced.
11:58:38 <Lor> basic balanced search trees
11:58:52 <syntaxfree> ah.
11:59:19 <syntaxfree> hmm. Interesting.
11:59:29 <Lor> http://www.eecs.usma.edu/Personnel/okasaki/jfp99.ps
11:59:56 <Lor> Imperative red-black trees are common stuff in all data structures courses, but they are bloody complex. Okasaki's functional variant is muchmuchmuch simpler.
12:00:05 <syntaxfree> how fast is compiled Common Lisp code?
12:00:24 <Lor> Depends on the compiler. And the code.
12:00:28 <Lor> What did you expect? :)
12:00:31 <syntaxfree> Haha :)
12:00:45 <syntaxfree> as opposed to Haskell, OCaml and Fortran?
12:01:19 <Lor> I gather there are some commercial lisp implementations that have invested seriously in optimization.
12:01:49 <Lor> Well, uh, how fast is compiled Haskell code when compared with OCaml?
12:01:55 <Lor> Or OCaml when compared with fortran?
12:02:36 <syntaxfree> what am I gonna do with my life?
12:03:17 <astrolabe> They will probably be impressed by enthusiasm, and signs that you've researched the subject, and their course.
12:03:21 <sethk> syntaxfree, trade it in for a new one
12:04:04 <syntaxfree> hmm. that sounds like good advice, astrolabe.
12:05:08 <syntaxfree> I'm scared shirtless.
12:08:44 <Oejet> Lor: You could say that Common Lisp people sometimes look at the assembly output of their compiler and so do OCaml people.  I am yet to come across an analysis of Haskell assembly output.
12:10:19 <mauke> looks like http://www.haskell.org/hawiki/HaskellUserLocations got spammed
12:10:28 <astrolabe> I suppose if the haskell community were bigger, there would be enough people to make GHC compile to assembler.
12:12:25 <Oejet> astrolabe: Well, think of the generated C then.
12:13:17 <astrolabe> I looked at that once briefly for a simple program.  Pages of gobbledegook!
12:14:09 <syntaxfree> I once tried to understand the mzc-generated C code for a very simple Scheme program.
12:14:19 <syntaxfree> gobbledegook inded.
12:16:04 <Oejet> Exactly.  I want something like http://www.ocaml-tutorial.org/performance_and_profiling for a Haskell compiler.
12:16:05 * syntaxfree is wondering whether he should add himself to http://haskell.org/hawiki/HaskellChannelPeople
12:16:51 <sethk> the fact that examining assembly language code is painful is NOT a reason it shouldn't be done.  :)
12:17:28 <syntaxfree> s/wondering/pondering
12:26:37 <Lor> mzc-generated code is quite readable when compared to e.g. what ghc generate.s
12:28:35 <Maddas> boo, my first attempt to run my Haskell program on input seems to get it stuck in an infinite loop! :-)
12:28:43 <syntaxfree> "Overloading" = using the same operator for analogous actions for different types?
12:28:44 <Maddas> (It can't be /that/ slow..)
12:29:03 <tuomov> overloading = using the same operator for whatever
12:29:17 <tuomov> polymorphism = using the same operator for analoguous stuff
12:29:23 <syntaxfree> My infinite loops rapidly converge to a stack overload.
12:29:41 <syntaxfree> polymorphism is a subset of overloading, then.
12:39:18 <Heffalump> syntaxfree: yes, you should
12:40:59 <syntaxfree> should what?
12:41:05 <Heffalump> add yourself
12:41:10 <Maddas> @type Debug.trace.trace
12:41:12 <lambdabot> bzzt
12:42:04 <Maddas> (got it)
12:42:27 <syntaxfree> ah, yes.
12:42:44 <syntaxfree> nah, the list seems to be only for black-belts.
12:42:53 <Heffalump> I don't think so.
12:43:35 <shapr> syntaxfree: Have you written any Haskell code?
12:43:45 <Heffalump> there seem to be a bunch of people at different levels
12:44:05 <kzm_> Good evening!
12:44:12 <shapr> greetz Ketil
12:44:30 <shapr> How're your arrays?
12:44:32 * Heffalump decides to upgrade himself
12:44:46 * kzm_ mutating and wreaking GC havoc, I suppose.
12:44:48 * kzm_ grins
12:45:29 <kzm_> is the 'bot interrogable for ghc RTS options, or must I resort to www? :-)
12:46:21 * syntaxfree is reading John Hughes' "Why functional programming matters".
12:49:34 <kzm_> Hmm...this is a difficult nut to crack.
12:50:11 <kzm_> I can't find any good options to avoid or minimize the cost of GC'ing my hash tables.
12:51:54 * kzm_ sighs again.
12:53:27 <kzm_> Simon says that "mutable objects  don't work too well with gen. GC"
12:53:45 <kzm_> So I suppose that goes for IOArrays and friends as well, then?
12:54:15 <Heffalump> gen = generational?
12:54:23 <kzm_> Yes, sorry.
12:54:40 <Heffalump> sounds a bit odd, aren't most Java GCs generational?
12:54:53 <kzm_> I guess you don't all have his message open in another window :-)
12:55:07 <Maddas> Ergh. -prof -auto-all outputs a file which only says that 100% of the time is spent in Main. That's not very helpful, is it? Main doesn't do anything other than calling other functions
12:55:20 <syntaxfree> can't I make a Haskell program that accepts command-line arguments simply saying "main x = "  etc?
12:55:21 <stepcut> hrm, I wonder if I can directly call from C++ member functions from C if I know the name mangling scheme used by the c++ compiler...
12:55:36 <Lor> Heffalump, I think it just refers to the need for a write (or read) barrier.
12:55:47 <heatsink> syntaxfree: do you want to write a haskell program on the command line?
12:55:56 <kzm_> No idea.  S.M. claims it works that way for GHC - I'm not gtoing to contradict him.
12:56:01 <Maddas> Spent in Main.main in particular.
12:56:20 <syntaxfree> I want to write a Haskell program that accepts command-line arguments.
12:56:39 <heatsink> syntaxfree: import System
12:56:42 <Heffalump> import System.IO
12:56:47 <heatsink> oh, sorry
12:56:48 <Heffalump> sorry, System
12:56:53 <Heffalump> no, I think heatsink is right
12:56:54 <syntaxfree> hmm.
12:56:57 <Heffalump> and then call getArgs
12:57:05 <syntaxfree> ok, ok. thanks.
12:57:11 <kzm_> Maddas, what kind of program?
12:58:00 <Maddas> kzm_: Just a parser I wrote.
12:58:15 <heatsink> How do you go about debugging "Inferred type is less polymorphic than expected" errors?  My usual method of adding explicit type signatures doesn't help here.
12:58:16 <Maddas> Ah, great -caf-all helps.
12:58:59 <xerox> syntaxfree: there also is pesco's code in the wiki, I think, which was kinda nice.
12:59:14 * syntaxfree thinks of submitting the haskell-generated C code for "main = do putStrLn "Hello world" " to the IOCCC
12:59:25 <syntaxfree> s/haskell-generated/GHC-generated
12:59:29 <heatsink> haha
13:00:10 <ValarQ> :)
13:00:38 <Speck> I just took my first pure math class ever, and it was fantastic, and it's all thanks to haskell
13:00:50 <Speck> rudimentary stuff, of course, but fun
13:00:58 <syntaxfree> why is it thanks to haskell?
13:01:06 <heatsink> yea :) All that stuff makes sense once you learn how to program in Haskell.
13:01:19 <heatsink> well, most of it anyway.
13:01:32 <syntaxfree> what stuff?
13:01:36 <Speck> I always liked math, but I never really got it, then haskell led me to pure math and I found I really liked it. I've always been an arts/humanities person.
13:01:50 <shapr> Yeah, me too!
13:02:00 <bubblesort> I liked math, thats why I started to like haskell :)
13:02:06 <Speck> Intermediate Symbolic Logic... he even talked about CT
13:02:08 <shapr> I'm beginning to see how to apply category theory directly to everyday life.
13:02:09 <wilx> Heh.
13:02:13 <wilx> I don't like math.
13:02:16 <wilx> But I like Haskell.
13:02:36 <ValarQ> i liked haskell, thats why i started with math :)
13:03:04 <syntaxfree> I liked maths, that's why I started with Haskell.
13:03:17 <syntaxfree> I was also an arts/humanities person who dropped out of film school.
13:03:31 <syntaxfree> I went to study economics, praying that it used little math.
13:03:41 <syntaxfree> It uses a LOT of maths, and turns out I like the maths better than the economics.
13:03:53 <basti_> no wonder
13:05:44 <heatsink> I can't figure out what to look for when the compiler won't unify variables... Expected type: SExp v; Inferred type: SExp v1
13:06:44 <xerox> Constraints?
13:06:46 <malcolm> heatsink: probably, v is declared in a signature, but the actual type is different
13:07:06 <basti_> heatsink: hmm that means something like, "i got two instances of SExp v, that might describe different v's, though"
13:07:11 <heatsink> Right
13:07:27 <heatsink> I have no idea why it decides that they're not the same instance, though.
13:07:31 <heatsink> I intended them to be the same.
13:07:50 <basti_> you have to tell the compiler, not me ;)
13:08:04 <basti_> (eg. unify them in a signature)
13:08:16 <basti_> though, if the compiler can't infer, something is broken
13:08:40 <heatsink> How do I unify two variables in a signature?  I'm not calling them different names.  Both are called "v".
13:08:57 <shapr> Yay, I added SyntaxNinja's code into FLM.
13:08:58 <heatsink> (in different signatures -- one is a local function declared in a "where" clause)
13:09:12 * shapr works on darcs integration next
13:09:35 <basti_> heatsink: not by calling them same names :)
13:09:47 <basti_> heatsink: they have to be "connected"... dont know how to call that else
13:10:13 <basti_> for sample "let x=map id list" unfies the type of x with that of list
13:10:23 <SyntaxNinja> shapr: w00t
13:10:30 <SyntaxNinja> shapr: what will darcs do?
13:10:38 <heatsink> basti_: sure
13:10:49 <shapr> SyntaxNinja: I just copy'n'pasted rather than pulling the patch.
13:10:58 <malcolm> heatsink: sounds you you are expecting the local sig to use the same variables as the top-level sig
13:11:04 <heatsink> basti_: I thought the message was printed because the compiler tried and failed to unify them.
13:11:12 <shapr> works nicely - http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=MarkupTest
13:11:13 <SyntaxNinja> shapr: I mean, what is darcs integration supposed to do?
13:11:21 <basti_> heatsink: hmm let me think up an example
13:11:22 <heatsink> malcom: I'm expecting the variables in the signatures to be unified during type inference
13:11:31 <malcolm> heatsink: you can turn on "scoped type variables" in ghc to make it work
13:11:31 <SyntaxNinja> a lot of that is Philippa's code too, btw.
13:12:08 <basti_> uhm yes how do you get that error hmm
13:12:10 <shapr> SyntaxNinja: Oh, I have two options, and I really need some user suggestions...
13:12:27 <shapr> I could hack it so that FLM is just one big repo, and then all annotations would be together.
13:12:42 <shapr> But, if FLM gets any popularity at all, that'll quickly cause conflicts and much pain.
13:13:04 <shapr> So the better option is probably to put each research paper into its own repository.
13:13:16 <basti_> we should start an error message demonstration library in the hawiki shouldnt we?
13:13:18 <SyntaxNinja> why will it cause conflicts?
13:13:37 <malcolm> heatsink: another idea is just to comment out the signature on the local defn.
13:14:06 <shapr> Because, if a hundred people all make their own changes to the same repository, something will conflict, I know it will.
13:14:29 <shapr> Well, at least I think so.
13:14:40 <heatsink> malcom: the error goes away when I comment out the signature.
13:14:50 <heatsink> malcom: I don't understand why.
13:14:52 <SyntaxNinja> shapr: is FLM code based on the latest flippi, with pluggable back-end and all?
13:15:04 <shapr> huh?
13:15:08 <shapr> pluggable?
13:15:17 * Philippa snorts
13:15:35 * basti_ hands Philippa a handkerchief
13:16:18 <malcolm> heatsink: When you give an unconstrained type variable in a local signature, it means forall v . v  But in your case, it can't be any old v, it must be the same v as was already mentioned in the top-level signature.
13:16:22 <SyntaxNinja> Philippa: plug it!
13:16:44 <SyntaxNinja> shapr: which version of flippi, or which things did you pull?
13:16:52 <basti_> malcolm: are you able to provoke that error?
13:16:57 <Philippa> shapr: he's talking about the PageIO transformers
13:17:04 <shapr> oh, sure.
13:17:27 <Philippa> and the possibility of writing a transformer that's pretty much "const functionIActuallyWant"
13:17:41 <malcolm> heatsink:  Really, you expected the fact that the have the same name (v) to mean they are the same variable.  but type variables don't have scope in Haskell outside of the single signature they appear in.
13:17:44 <Philippa> which lets you swap out all the back end and provide your own storage mechanism
13:18:13 <heatsink> malcom: I still don't understand, because polymorphic functions get instantiated to narrower types all over the place.
13:18:33 <heatsink> malcom: (++) :: forall x. [x] -> [x] -> [x]
13:18:45 <shapr> My only assumption so far is that the raw text for a page is kept in the text field. I'm using that to get unrendered macros.
13:18:56 <malcolm> basti_: I would have to think hard to write a small testcase - but heatsink has one already :-)
13:19:00 <heatsink> malcom: but I can do f :: [y] -> [y] -> [y]; f = (++)
13:19:04 <basti_> malcolm: -laughs-
13:19:26 <Philippa> shapr: I'll probably make that assumption permanent next time I modify the plugin model
13:20:11 <malcolm> heatsink: how big is the example that was giving your original error message?
13:21:20 <heatsink> malcom: the top-level function is fifty LOC, and it refers to a number of other functions that make a few hundred lines in total
13:22:01 <SyntaxNinja> malcolm: check your msgs :)
13:22:15 <heatsink> malcom: Shall I paste on the irc paste page?
13:22:30 <Philippa> heatsink: you can do that because it unifies the y with the x in (++)'s signiature
13:22:33 <malcolm> http://research.microsoft.com/users/simonpj/papers/scoped-tyvars/
13:22:46 <Philippa> in fact, it has to do so - it checks (++) has a type that matches f's signiature
13:23:46 <heatsink> Philippa: Yeah, I'm trying to figure out what the difference is between that and my code where the typevars won't unify.
13:24:36 <malcolm> The paper I just gave a reference to has a nice explanation in the introduction - you don't need to read it all.
13:24:44 <heatsink> oh! I didn't see that.
13:27:13 <malcolm> SyntaxNinja: msgs where?  email?
13:29:26 <heatsink> oh, I see.  My local function references a variable with the outer function's type.
13:30:52 <heatsink> thanks!
13:31:38 * heatsink reads about scoped typevars in the ghc docs
13:44:27 <SyntaxNinja> malcolm: no, private message in IRC.
13:44:48 <SyntaxNinja> malcolm: they might appear inline, but in a different color or something, or a new tab, or a new window, all depends on yoru client.
13:45:02 <malcolm> syntaxninja: found the window
13:49:23 <SyntaxNinja> hm. I'm not sure if you're replying, but I can't hear you.
13:50:13 <SyntaxNinja> ah well, maybe email is better anyway.
13:50:13 <malcolm> SyntaxNinja: lets try again... PM coming up
13:52:47 <SyntaxNinja> no dice.
13:52:53 <SyntaxNinja> are you getting an error message in another window?
13:52:54 <SyntaxNinja> IRC sucks.
13:53:01 <kzm_> what's the problem?
13:53:01 <thedward>  are you registered with nickserv?
13:53:18 <malcolm> I got your first window, (eventually, when i found it)
13:53:23 <thedward> msg's from unregistered nicks are being silently dropped at the moment.
13:53:25 <SyntaxNinja> I'm registered, and I think I turned off the misfeature that malcolm would have to register to send me msgs
13:53:41 <malcolm> register how?
13:53:55 <thedward> SyntaxNinja: how did you turn it off?
13:54:04 <SyntaxNinja> I don't remmeber, shapr told me how I think.
13:54:22 <kzm_> Y
13:54:59 <kzm_> WOrks for me
13:55:07 <SyntaxNinja> malcolm: send a private message to "nickserv" with the contents "help". I'm not sure it's worth it.
13:55:12 <SyntaxNinja> malcolm: I'll send you mail :)
13:55:30 <kzm_> How can you send a private message to nickserv, if they are silently dropped? :-)
13:56:11 <sethk> kzm_, wrong question.  It is easy.  The problem is how to receive the private message if it is dropped.  Doesn't stop you from sending it.  :)
13:56:33 <malcolm> nickserv doesn't seem to be in this group - I don't know enough about IRC to know what to do.  I use a pointy-clicky client,
13:56:44 <thedward>  /msg nickserv help
13:56:47 <kzm_> Ah, that's true, of course.  I was assuming nickserv needed to actually receive the msg to act upon it :-)
13:57:18 <SyntaxNinja> malcolm: which client? I use a pointy-clicky one too (gaim). it does a lot to make IRC actually work, but this particular IRC network is sorta evil.
13:57:24 <thedward> if it is to stop msg spam, why couldn't spam bots register?
13:57:45 <SyntaxNinja> I guess because they could more easily kill the spam bots.
13:57:52 <SyntaxNinja> but it's probalby just another arms race
13:57:59 <malcolm> Colloquy.  I tried to register, and it told I was already registered
13:58:10 <Philippa> do you know what your password is?
13:58:11 <SyntaxNinja> malcolm: someone already is using your nickname, probably
13:58:18 <SyntaxNinja> unless you registered before
13:58:21 <skew> Hello, I'm trying to build the tests for haxr, but compiling PersonTH is failing. Does anybody know about this problem?
13:58:34 <malcolm> syntaxninja: could be me on a different machine maybe?
13:58:38 <Philippa> looks like it, yeah
13:58:43 <Philippa> Last Seen Address: n=minimac@d207-216-20-226.bchsia.telus.net
13:58:55 <Philippa> does that look like one of yours?
13:59:09 <Philippa> apparently it's been registered for 3 years
13:59:12 <SyntaxNinja> malcolm: no, not really. you have to bend over backward to register, and you'd probably remember learning how to do it.
13:59:36 <SyntaxNinja> malcolm: it's probably just a common enough name that someone already registered it. nickserv is how they would kick you off if they ever found you using it.
13:59:38 <malcolm> Philippa: not a machine I've ever used.
13:59:46 <SyntaxNinja> and if they cared, and could figure out how to use nickserv
13:59:47 <Philippa> time to pick another nick then
14:00:08 <Philippa> otherwise you run a risk of being randomly kicked when the owner returns to reclaim it
14:00:09 <SyntaxNinja> or ask the admins to let you register this one, if the other user is idol.
14:00:15 <SyntaxNinja> did I mention that IRC sucks?
14:00:19 <Philippa> last seen <24 hours ago
14:00:24 <SyntaxNinja> ahh
14:03:53 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051011"]'
14:03:53 --- topic: set by CosmicRay on [Tue Oct 11 09:43:45 2005]
14:05:30 <skew> I get some odd errors about not being able to find the PersonTH module, when I'm trying to build the PersonTH module
14:05:31 <SyntaxNinja> malcolm: well, I basically wanted to talk to you about the hmake licence.  it sounds like the way I want to use the dependency chasing code may or may not conform to your licence, depending on whether or not you think that cabal performs "substantially the same task" as hmaek.
14:05:36 <Maddas> Oy! things work :-)
14:06:07 <SyntaxNinja> s/hmaek/hmake
14:08:47 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051011"]'
14:08:47 --- topic: set by CosmicRay on [Tue Oct 11 09:43:45 2005]
14:09:03 <SyntaxNinja> what's the difference between import chasing and dependency chasing?
14:09:36 <malcolm> syntaxninja: The copyright holder is always free to give away his/her code  under any conditions they like, even if it is also available under a more restrictive licence.
15:37:51 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051011"]'
15:37:51 --- topic: set by CosmicRay on [Tue Oct 11 09:43:45 2005]
15:37:52 <SyntaxNinja> ocaml uses a modified LGPL that doesn't have that clause.
15:38:07 <Igloo> Have you got a URL for that?
15:38:11 <SyntaxNinja> I'm also not a lawyer. is there some reason that it's necessary to point that out?
15:38:17 <SyntaxNinja> Igloo: just google for ocaml license, I guess.
15:38:23 <sethk> SyntaxNinja, yes
15:38:29 <malcolm> wxHaskell and HaXml have special exclusion clauses on top of the LGPL
15:38:31 <SyntaxNinja> sethk: are you giving me legal advice?
15:38:38 <Lor> Ah yes, there was the Big Ocaml License Discussion a couple of years back.
15:38:45 <SyntaxNinja> hi Lor
15:38:47 <sethk> SyntaxNinja, that would be practicing without a license
15:38:54 <sethk> SyntaxNinja, which is why the disclaimer is necessary
15:39:04 <SyntaxNinja> sethk: I figued it was something like that.
15:39:14 <Lor> Hi.
15:39:23 <sethk> SyntaxNinja, I never said it made _sense_  :)
15:39:53 <SyntaxNinja> malcolm: I'm not complaining, fwiw. I think you have every right to release things under the terms that you want to release them, and I'd choose lgpl-style (really ocaml-style) if it were up to me.
15:39:58 <thedward> It seems I could use gtk2hs to load and manipulate image files, but that seems overkill.
15:40:02 <SyntaxNinja> but I'm stuck between a rock and a hard place on this one, it seems.
15:40:37 <malcolm> SyntaxNinja: The wxHaskell clause essentially says you don't have to provide a mechanism to relink against a newer version of the LGPL library.  Provided you distribute the original unmodified version of the library only.
15:40:59 <SyntaxNinja> malcolm: makes sense. sounds similar to ocaml.
15:41:24 <malcolm> SyntaxNinja: I used something similar for HaXml, and Blobs is going to be the same.
15:42:12 <SyntaxNinja> I'm afraid that the upshot will probbaly be that cabal will be somewhat more inconvinient for use outside of GHC
15:42:13 <Cale> Blobs?
15:42:32 <SyntaxNinja> but maybe hugs will start coming with cpphs
15:44:14 <malcolm> SyntaxNinja: maybe I should add a similar clause to cpphs
15:45:23 <malcolm> Hugs on Windows was a major reason for writing cpphs, so it would be sad if it wasn't used.
15:46:21 <mcnster> hello
15:46:22 <SyntaxNinja> malcolm: I'd prefer that everyone use cpphs :)
15:47:07 <SyntaxNinja> but basically, we want cabal to be as standalone as possible. I guess that for hugs, if you want cabal to do dependency chasing, you'll have to go and install cpphs, that's all.
15:47:24 <malcolm> time for bed here - I'll turn into a pumpkin soon
15:47:41 <SyntaxNinja> OK :) good talking to you.  thanks for your time.
15:47:49 <SyntaxNinja> and I really like all the important software you write :)
15:47:58 <malcolm> night all
15:48:37 <Maddas> Just as a note, Franz have a modified LGPL too for code they release (they produce Allegro Common Lisp)
16:00:02 <syntaxfree> I hate common lisp's funcall.
16:00:15 <syntaxfree> it's so ... artificial.
16:00:35 <syntaxfree> why can I just say "f x" to use a function that has been passed as an argument to another?
16:01:23 <Maddas> syntaxfree: Because of the seperate namespaces.
16:01:35 <sethk> anyone remember the vim command to find a matching paren?
16:01:39 <Maddas> %
16:02:33 <sethk> Maddas, thanks
16:02:38 <Maddas> No problem
16:03:03 <Maddas> Good night :-)
16:05:16 <syntaxfree> it's ugly.
16:08:16 <cinema> ping shapr
16:08:20 <shapr> salut
16:08:33 <heatsink> what is a channel password?
16:08:37 <shapr> How may I assist you?
16:08:51 <cinema> shapr, I have a big stock of papers (pdf & ps)
16:09:05 <shapr> yes?
16:09:12 <cinema> thought you might be interested in the stock
16:09:22 <shapr> Well, I'm interested in the urls.
16:09:42 <cinema> I have the papers, not a catalog of them
16:10:04 <shapr> Fermat's Last Margin will distribute the notes for the papers, not the papers themselves.
16:10:14 <shapr> Otherwise I'll get into trouble with Springer-Verlag
16:10:31 <cinema> I see. What is there in the notes
16:10:45 <shapr> Whatever the users write.
16:10:58 <shapr> The idea is that you write notes on your papers with FLM, then I can download your notes.
16:11:11 <shapr> Once everyone does that, it's like a distributed message board for each page
16:11:17 <Cale> um, I thought that there would be page images
16:11:22 <shapr> Yes, there will be.
16:11:41 <Cale> so you're sort of redistributing them -- but they have to be online anyway, right?
16:11:45 <shapr> The "Margin" script will download the file onto your machine, and generate images there.
16:11:53 <Cale> ah, okay
16:11:59 <cinema> OK. I can print each paper & send it to you, it would be several meters high
16:12:01 <shapr> No, I won't redistribute papers or images.
16:12:07 <shapr> wow, that's a lot of papers.
16:12:39 <Cale> Interface the thing with citeseer :)
16:12:40 <cinema> Yes. My ultimate problem will be to *read* them
16:12:53 <shapr> Cale: Want to write a plugin?
16:13:45 <shapr> cinema: That's the best part.
16:13:46 <Cale> shapr: it uses hs-plugins?
16:13:59 <shapr> No, but that's a good idea.
16:14:07 <cinema> shapr, future is always the best part
16:14:23 <stepcut> hoo-ray! I wrote my first haskell kde application!
16:14:25 <shapr> I'm a hedonist. I live in the present.
16:14:29 <shapr> stepcut: yay!
16:14:30 <Cale> stepcut: cool :)
16:14:36 <stepcut> now comes the hard part...
16:14:55 <Cale> stepcut: So I take it from that a QT binding is in the works :)
16:14:56 <stepcut> figuring out how to automate the binding process :p
16:15:01 <Cale> ah
16:15:22 <Cale> just a bunch of FFI imports so far?
16:15:26 <stepcut> yes
16:15:41 <stepcut> I had to use nm -C and nm to figure out the name mangling :p
16:15:46 <stepcut> (by hand)
16:15:47 <Cale> yeah
16:15:56 <micket_> Help... http://rafb.net/paste/results/8dfbQk44.html
16:16:02 <Cale> I've done that in a small-scale way just to check that it could be done
16:16:07 <micket_> I can't get it to work.. i hate this :X
16:16:27 <stepcut> Cale: yeah, it was hard to find information on how to even do it, but I kinda guessed and it worked
16:17:11 <Cale> micket_: hmm... that's not really enough to determine what's going on
16:17:32 <Cale> that return looks like it needs a $ or some parens though
16:17:42 <Cale> because currently you're passing it 3 parameterss
16:17:49 <Cale> (one of which is (:) )
16:18:38 <micket_> Adding paranthesises doesnt change anything
16:18:49 <Cale> what's the error that you're getting?
16:18:57 <micket_>  Couldn't match `[(a, b, Gen b, [Char])]' against `Gen [a1]'
16:19:03 <micket_> For the return row
16:19:11 <micket_>  Couldn't match `[(a, b, Gen b, [Char])]' against `Gen [a1]'
16:19:13 <micket_> wopps
16:19:37 <micket_> (the one on row 12 that is)
16:19:49 <luqui> what is Gen?
16:19:58 <Cale> Is Gen from QuickCheck?
16:20:04 <micket_> Yes
16:20:07 <luqui> ahh
16:20:13 <Cale> okay
16:20:32 <Cale> so, it says that you're giving it a list, when it wants a Gen
16:20:59 <Cale> or vice versa
16:21:15 <Cale> um
16:21:24 <Cale> there are various concerning things in that code
16:21:30 <Cale> like depart <- x + time
16:21:45 <Cale> do you have a monad which is also an instance of Num?
16:21:57 <Cale> dinner
16:22:00 <Cale> I'll be back
16:22:16 <micket_> I have no idea.
16:30:22 <dolmen> heatsink, do /msg nickserv help
16:40:23 <Cale> micket_: okay, so first of all, I think you want let depart = x + time
16:40:51 <Cale> and similarly for arrive
16:41:51 <Cale> what is frequency?
16:41:59 <Cale> ah, I see
16:43:19 <Cale> so t x :: Gen (Int, Int, Int, String)
16:43:29 <Cale> so you shouldn't need to apply return to it again
16:43:48 <Cale> which would make it something like Gen (Gen (Int, Int, Int, String))
16:44:08 <Cale> micket_: does that make sense?
16:44:24 <Cale> frequency :: [(Int, Gen a)] -> Gen a
16:48:03 <micket_> thanks!
16:48:43 <micket_> now i think ill just lie down and die a little.. i feel like shit, ugh, goonight all!
17:24:25 <Cale> @seen Lemmih
17:24:26 <lambdabot> Lemmih is in #haskell. Last spoke 11 minutes and 1 second ago.
17:24:55 <Lemmih> Hi Cale.
17:25:03 <Cale> hello
17:25:08 <Cale> I'm building cabal-get
17:25:19 <Cale> and I get errors near the end with Hs-Source-Dirs
17:25:21 <SyntaxNinja> sweet
17:26:02 <Lemmih> Quick fix: change it to hs-source-dir. Correct fix: upgrade cabal.
17:26:07 <Cale> ah
17:26:09 <Cale> okay
17:26:36 <Cale> I should use the 1.2 Release Candidate then?
17:27:15 <SyntaxNinja> ja
17:27:54 <Lemmih> Isn't 1.2 stable now?
17:28:07 <Cale> http://www.haskell.org/cabal/download.html
17:28:14 <Cale> says that it's the RC
17:29:21 <SyntaxNinja> it is indeed
17:38:04 <machack666> Is there an established optimized algorithm for finding a set of matching elements from a very large set of potential objects?  For instance, given the set of all words in the English language, find those ten-letter words which have the third letter "b" and the sixth letter "a"?
17:39:16 <machack666> we want to avoid the brute force as much as possible
17:39:40 <machack666> it seems to me that this is homomorphic to partial key completion in the database world
17:40:04 <wagle> if your queries are not fully generalized, then you can optimize to the average query
17:41:36 <wagle> i dont know what any "established optimized algorithm" would be though
17:41:50 <machack666> The english language is my domain right now -- but I'm looking for a datatype which can be used for any other arbitrary objects.  Something like Data.Map, where the key is something along the lines of (_ _ b _ _ a _ _ _ _) in the example I gave earlier
17:42:07 <machack666> where _ stands for a free variable
17:42:29 <wagle> so your queries are only for particular constants in particular positions?
17:42:41 <Cale> grep "^..b..a.*$" /usr/dict/words :)
17:42:55 <machack666> cale: That's kind of what I have been doing.
17:43:06 <wagle> i've used Cale's method many times, and it seems quiter fasdt
17:43:11 <wagle> quite
17:43:14 <wagle> fast
17:43:20 * wagle cant type
17:43:30 <Cale> that's a brute force search though
17:43:33 <machack666> wagle: it's a lot like the pattern matching that haskell does for signatures, but used for grepping huge sets
17:44:21 <Cale> Well, depending on how much memory you'd like to consume, you could build a structure which indexes words by various letters
17:44:36 <wagle> i'm trying to understand what the space of possible/probable queries is
17:44:53 <Cale> If you have all the one-letter-specified sets, then you can simply intersect them.
17:45:03 <machack666> I want to optimize for the fact that I know that the data structure is immutable, and that the lifetime of the object is large, so the results for a single query will be the same
17:46:24 <machack666> not only that, we know that ..b..a. is a subset of ..b.... and .....a., so if we do not have any cached results for a particular query, we could just scan through the smaller of the two subsets (assuming they have cached results)
17:46:45 <wagle> well, hashing sound good..  especially since you can spend the time to get a good hash function
17:47:14 <machack666> how would hashing work for "arbitrary" keys
17:47:28 <Cale> If you already have the sets for ..b.* and .....a.* you can just intersect them
17:48:17 <machack666> I'm trying to optimize for time right now
17:48:31 <araujo> Hello all!!
17:48:51 <wagle> hey
17:49:08 <machack666> the proposal you suggested would be O(n*m) for the n,m, for the a set and b set, wouldn't it?
17:49:42 <wagle> sound like a database seatch problem.. but i never took database
17:49:46 <wagle> search
17:50:01 <Cale> cale@zaphod[~/cabal-get-bootstrap/cabal-get-0.2.1]$ ./setup configure
17:50:01 <Cale> setup: Warning: No license-file field.
17:50:01 <Cale> setup: No local build info generated during configure. Over-ride empty configure hook.
17:50:14 <wagle> i dont think database people do O(n*m)
17:50:15 <Cale> (which also happened during the ./install)
17:50:29 <Cale> O(n+m)
17:50:42 <Cale> Assuming you use Data.Set
17:51:45 <Cale> and there's a note there that (big `intersect` small) is faster
17:52:10 <wagle> ordering matters..
17:52:16 <machack666> the algorithm I am using right now (not in haskell) is essentially this:
17:52:36 <machack666> maintain a mapping of patterns to lookup results.
17:53:40 <machack666> if an unknown pattern is encountered (i.e., we have not seen it before) see if there is a pattern in the cache that the current pattern was a subpattern of.
17:54:14 <machack666> in the case that multiple patterns in the cache match, use the one which has the least number of results.
17:54:49 <Cale> oh, that's somewhat good, but you could do better, I think :)
17:55:15 <machack666> and then scan through the list of results to find, add the current results to the cache under the given pattern, blah, blah...etc
17:55:25 <machack666> I think so too...
17:55:47 <machack666> it's a tradeoff between space and time, isn't it always?
17:56:10 <Cale> well, you can probably compare patterns quickly, while searching takes a long time
17:56:31 <machack666> yes, in the general case.
17:56:58 <machack666> and I can optimize for the set of words being divided according to length
17:57:05 <Cale> So it's good if you can determine how much of your solution you can build from the cached results, and what's a good subset of the cached results to combine to form your partial solution
17:57:11 <machack666> ie, don't have to worry about comparing 3 and 10 letter words
17:58:14 <machack666> I have an arbitrary cutoff where if there are less than 10 results, we don't worry about caching those in the pattern lookup.  However, if we find that there is a pattern which results in 0 results, we *do* cache that
17:58:45 <Cale> why wouldn't you cache small match sets like that?
17:59:39 <Cale> knowing about small sets of matches is good, because then when someone comes along with a query which is a refinement of one of those, you don't have to look through much
18:00:17 <Cale> though I suppose if there are a lot of queries to consider, the cache may get large
18:00:27 <Cale> so at some point you have to worry about space
18:00:31 <machack666> that's true; I haven't done the measurements on the best cutoff value.  it just seemed like that would grow the space
18:00:49 <machack666> I figured 10 is still a very few number of words to look through
18:00:58 <Cale> oh
18:01:00 <Cale> I see
18:01:01 <machack666> that could be tuned for sure
18:01:14 <Cale> If there's already a cached item with 10 elements
18:01:20 <Cale> then you don't store a refinement
18:01:25 <machack666> right
18:01:28 <Cale> oh, okay :)
18:02:10 <Cale> so you probably want some notion of a lattice on queries
18:02:19 <machack666> the 0-bombs are the best refiner for determining whether a pattern has any matches :)
18:02:27 <Cale> right
18:02:51 <Cale> anything above them in the lattice will also have 0 results
18:03:09 <machack666> I can kind of guess what a lattice is, but is there some reading you could point me to?
18:03:40 <Cale> http://en.wikipedia.org/wiki/Lattice_%28order%29
18:04:40 <machack666> thx
18:04:41 <Cale> that's the abstract algebraic way to compare searches :)
18:06:03 <Cale> though actually, your searches don't quite form a lattice, as you can't search for (a or b) in a given spot
18:07:05 <Cale> so it's probably just a semilattice
18:07:17 <Cale> that is, only one of join or meet is there
18:07:54 <Cale> hmm... :)
18:10:09 <Cale> well, you want to talk about the operation that's not always there though -- if two searches are such that for each position, they are equal, or at least one of the two doesn't make a request
18:10:14 <Cale> then you can combine them
18:10:28 <Cale> (form their "meet")
18:10:45 <Cale> and that corresponds to intersection
18:12:00 <machack666> another consideration is that as the set of keys in the cache grows, so does the amount of time to check for the subpattern, as it is essentially the same operation, but in reverse.
18:12:46 <machack666> as long as # of keys << |search space|, you're doing okay.
18:14:07 <Cale> right
18:14:38 <Cale> if someone searches for "qwyjibo" and it's not there, that's not a particularly interesting thing to cache
18:15:29 <Cale> it's when the search term is general, but few matches are generated that is interesting
18:15:41 <machack666> yes, it's the most limiting
18:16:27 <Cale> You also probably want a way to subsume and remove results.
18:16:28 <machack666> the search space for potential n-letter words is e^n, where e is # of elements in the "alphabet"
18:16:44 <machack666> but the set of "sensible" words is substantially smaller
18:16:51 <machack666> very low information ratio
18:17:05 <machack666> retrieve_all_sorted_by
18:17:17 <Cale> If I get 0 results for "q.y....", then I no longer need to store that I got 0 results for "qwyjibo"
18:17:19 <machack666> wrong pasteboard
18:17:20 <machack666> wc -l /usr/share/dict/words
18:17:27 <machack666> 234937 /usr/share/dict/words
18:17:36 <machack666> right
18:18:02 <machack666> but optimizing the removal of redundant subpatterns seems like it would be another expensive process
18:18:14 <machack666> but interesting, nonetheless
18:18:23 <Cale> well, it's something that we want to be efficient
18:18:53 <machack666> I suppose you could remove those as you scan through the pattern space to begin with...
18:19:52 <machack666> ie, if you're doing a lookup for a key and you are retrieving the list of valid superpatterns, you could examine those for redundancy without incurring the O(n) cost (or at least an additional O(n))
18:23:38 <Cale> hmm
18:23:54 <machack666> does haskell reuse immutable objects when using sub-maps, and the like?
18:24:02 <Cale> yes
18:24:14 <Cale> Only references to things get stored in the maps
18:24:33 <Cale> In fact, only references to things ever get stored in any data structure.
18:24:46 <machack666> so the submaps wouldn't be additional storage (other than the ptr overhead)
18:24:49 <Cale> (unless it's something like an unboxed array)
18:24:58 <Cale> right
18:25:06 <Cale> which can be significant
18:25:15 <Cale> but perhaps not too bad
18:25:28 <machack666> sure; 100000 submatches would still be 100000*sizeof(ptr)
18:25:45 <machack666> but smaller than the contents of the 100000 items
18:26:10 <Cale> the trick is, I think, to realise when you have redundant things in your cache, and throw them away
18:27:25 <machack666> that would keep the overall cache size down, yes.
18:28:20 <machack666> delete from Data.Map O(log n)
18:28:48 <machack666> basing the structure on Data.Map would give us that efficiency for the cache lookup
18:29:28 <Cale> hmm...
18:29:30 <machack666> s/lookup/deletion/
18:29:37 <machack666> although both is true.
18:29:45 <machack666> s/is/are/
18:31:14 <machack666> Data.Map.keys is O(n) for the cache subpattern scan
18:32:01 <machack666> although, since we know that the interface we're using is the only way to get at the structure, we can maintain a Set for this information.
18:32:59 <machack666> Data.List.length is O(n), I believe.  Maybe storing two maps, one mapping to sub results and one mapping to number of subresults is in order.
18:35:47 <Cale> Okay, so let's look at the algorithm when we have a query like ".a.b.c."
18:35:53 <machack666> for a generalized algorithm, we'd need an out-of-band indicator for the "."
18:36:02 <Cale> Maybe that's not in the cache
18:36:13 <machack666> can you pass _|_ in as a "I don't care what this is", or does that mess it up?
18:36:45 <machack666> i.e. 'a':_|_:'b':_|_:'c':_|_:[] ?
18:36:45 <Cale> um, you have to be careful, because evaluating _|_, ever, is trouble
18:37:15 <Cale> It's like Medusa, you look at it and you turn to stone :)
18:37:35 <Cale> so you probably want Maybe Char
18:37:53 <machack666> yes, Maybe a could be the polymorphic type
18:37:58 <Cale> right
18:38:10 <machack666> although, it's sure nice being able to write just strings
18:38:25 <Cale> write a convenience function :)
18:38:35 <machack666> periodsToMaybes :: String -> [Maybe Char]
18:38:42 <Cale> yeah
18:39:52 <machack666> anyway, someone else's problem as far as the algorithm is concerned.
18:40:22 <machack666> back to ".a.b.c." ...
18:40:32 <Cale> okay, suppose that's a cache miss
18:40:44 <Cale> Since if it's a cache hit, we're done :)
18:41:25 <machack666> yes
18:41:46 <Cale> Other interesting hits would be: "...b.c.", ".a...c." and ".a.b..."
18:43:00 <machack666> or ".a....." "...b..." ".....c."
18:43:18 <Cale> Right, those are less interesting, but still interesting
18:43:25 <machack666> or, i suppose "......." , the terminal one :D
18:43:29 <Cale> right
18:44:06 <Cale> so we want to figure out which of these we have. If we have ".a.b...", the ones with just a and just b don't interest us.
18:44:10 <dons> moin
18:44:15 <Cale> but the one with just c does.
18:45:36 <machack666> @paste
18:45:37 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
18:46:25 <machack666> hmm, locked
18:46:43 <machack666> I was going to illuminate the conversation with some counts from /usr/share/dict/words
18:47:28 <Cale> locked?
18:47:56 <Cale> maybe try logging in -- we've had lots of problems with spam on the wiki lately
18:48:03 <dons> @seen Lemmih
18:48:04 <lambdabot> Lemmih is in #haskell. Last spoke 1 hour, 20 minutes and 9 seconds
18:48:04 <lambdabot> ago.
18:48:13 <Cale> possibly shapr changed it so that you have to log in to edit
18:48:38 <machack666> ok
18:48:55 <Lemmih> Hi dons.
18:49:24 <dons> Lemmih, you pinged?
18:49:53 <machack666> logging in did the trick, although I lost the navigation bar
18:51:00 <machack666> got the text in
18:56:53 <machack666> ping
18:57:09 <Cale> yeah
18:57:31 <Cale> just thinking about the best way to handle this
18:58:26 <Cale> you could probably build a tree, though you'd have to be careful in order to get sharing, and it could be annoying to modify
18:58:46 <Cale> (you don't really want a tree, you want a dag)
18:59:27 <machack666> well, just because you have ".a.b..." does not that you have either "...b..." or ".a....." in the cache
18:59:45 <machack666> as ".a.b..." could be the initial query
19:00:58 <machack666> and without knowing the heuristics of the search space, I'd be hesitant to initiate a scan on either of the super patterns, as they would require an O(n) serial scan.  (Although, I suppose, this could be done in paralell.)
19:01:38 <machack666> If you're already committed to the O(n) scan, you might as well get as much done as possible.
19:03:56 <Cale> Oh, if you have nothing related in the cache, probably it's best to just do the plain search
19:05:41 <machack666> what I do right now is preload in the cache all n-letter words for the general pattern "."x n
19:05:50 <Cale> but when you get a miss, I think it's worth it to try combining previously performed searches as much as possible
19:06:03 <machack666> so there is always trivially a super pattern that will match something.
19:06:29 <Cale> right
19:06:33 <machack666> (In my case, this is a *one-time* cost, as we serialize out the structure across invocations)
19:07:53 <Cale> okay
19:08:07 <machack666> right.  I don't know if there is any sort of cross-correlative analysis we can do; the only thing that I could prove to myself that worked was the strict superset.
19:09:22 <Cale> you always want to take the less specific searches that have been done and combine them.
19:09:27 <Cale> One question is:
19:09:29 <JohnMeacham> gah
19:09:52 <JohnMeacham> how do I define preprocesor symbols in cabal?
19:10:01 <Cale> Suppose that we're looking for ".a.b.c." and have in the cache ".a.....", "...b..." and ".....c."
19:10:26 <Cale> do we build and store something like ".a.b..." while on our way to the final result?
19:10:35 <JohnMeacham> I want -DFOO to be passed to the various c preprocesors
19:10:37 <machack666> whichever has the least number of elements would be the best choice
19:10:54 <machack666> so it depends if .a..... is the best choice :D
19:11:28 <machack666> in that case, why not do all three [ermutations?
19:11:44 <Cale> well, it might be worthwhile for future searches, but it's costly
19:11:57 <machack666> especially the more general the pattern is.
19:12:33 <machack666> i would say no on the sub-generation.
19:12:49 <Cale> well, you're going to do one of those sub generations
19:12:55 <Cale> so you might as well store it
19:13:06 <Cale> but which one? :)
19:13:06 <machack666> because you could have '.a.b.c.d.e.f.g.h.i.' that would were looking for and presumably generate it for each permuation.
19:13:12 <Cale> yes
19:13:15 <Cale> that would be bad
19:13:20 <Cale> well...
19:13:22 <Cale> possibly
19:14:01 <machack666> say the cost for .a..... is 1000, for ...b... is 200 and for .....c. is 20.
19:14:10 <machack666> you'd be a fool not to jump on that c
19:14:14 <Cale> right
19:14:14 <machack666> :D
19:14:37 <JohnMeacham> gosh... I should have looked at the cabal design earlier... there are some pretty fundamental bad design decisions.. where is the appropriate list to discuss cabal issues?
19:14:54 <dons> libraries@ ?
19:15:06 <Cale> so I'd say take the two smallest, intersect those, cache the result, then intersect with the remaining one
19:16:08 <JohnMeacham> okay... hmmm... not sure if I am ready to send another really big mail to the list. I am still catching up with replies to my class alias thing.. perhaps it can wait until monday..
19:16:28 <dons> hehe
19:16:40 <dons> you might want to  look at the Cabal design work that was done about a year ago
19:16:51 <machack666> so ...b.c. goes in cache, (quicker op than a^b or a^c) and then cache (a^(b^c))
19:16:52 <dons> there's a web page and a long thread on libraries@ I think
19:17:02 <Cale> machack666: yeah
19:17:34 <machack666> say we already have ...b.c. in the cache (and say it's 10)
19:18:06 <machack666> then we would get .....c. = 20 and ...b.c. = 10 as our smallest entries.
19:18:09 <machack666> what then?
19:18:42 <JohnMeacham> yeah... well, I figured I'd start converting my stuff, having a compiler, a program, a library, and a preprocessor to all switch. and I can honestly say that none of them are able to be easily converted without large compromises in the current cabal design...
19:18:49 <Cale> then we just manually filter ...b.c.
19:18:57 <machack666> we can observe that "...b.c." is a subpattern of ".....c." and skip the recaching phase.
19:19:56 <JohnMeacham> Which sort of sucks. because I was hoping I could just do it in an afternoon...
19:20:02 <machack666> but say it's "...ti.." and "....io.", where we don't have "....i.." in the cache
19:20:08 <machack666> it's not a strict subset
19:20:11 <Cale> oh
19:20:25 <Cale> and what are we looking for?
19:20:29 <dons> JohnMeacham: what kind of compromises?
19:20:53 <Cale> If we're looking for ....i.., it's not helpful
19:20:59 <dons> I've found just about all things are cabalisable
19:21:03 <dons> all things I've tried
19:21:29 <machack666> how about "c..tio."
19:21:38 <Cale> oh
19:21:53 <Cale> then you want to intersect the results for "...ti.." and "....io."
19:21:55 <machack666> (or maybe "...tio." -- I don't know what's more interesting at this point
19:22:10 <Cale> which gives you the results for "...tio."
19:22:27 <JohnMeacham> simple programs and libraries work. which is what many things are. but as soon as you try to do anything interesting, the whole system breaks down. it needs some design changes to degrade gracefully. plus, if there was more competition between compilers, a lot of the design would also be very limiting.
19:22:32 <machack666> I suppose it depends on the number of elems in ti and io
19:23:35 <Cale> machack666: ah
19:23:37 <Cale> yeah
19:23:47 <Cale> I suppose there's some difficult choices to be made
19:23:54 <JohnMeacham> my main criticism boils down to: If I can't add support for a preprocessor, compiler, or language extension without modifying cabal. then it is inherently broken.
19:24:10 <Cale> it might be faster to directly filter than to intersect sometimes
19:24:36 <machack666> yes
19:25:11 <JohnMeacham> my second most main criticism involves various non-obvious but bad results of cabal being a library rather than a program.
19:26:24 <Cale> machack666: but I think as a first approximation, just use intersect, and only filter when the nothing suitable is in the cache already
19:26:31 <Cale> -the
19:27:10 <Cale> so long as you pass the arguments to intersect in the right order, I bet it will be comparably fast
19:28:30 <machack666> hmm
19:30:27 <machack666> if two items in the cache are complementary subsets of the search pattern, then we can intersect.
19:31:08 <machack666> ie, if we can .a..... and ...b.c. we can computer .a.b.c. as the trivial intersection of the two
19:31:26 <machack666> similarly with .a.b... and .....c.
19:31:45 <machack666> or .a.b... and ...b.c. for that matter
19:32:14 <machack666> as long as the two patterns 'unioned' can make up the search pattern, we can derive it without filtering
19:32:45 <machack666> i don't think we'd want to break it down any further than 2 patterns.
19:33:09 <machack666> as far as combinations are concerned
19:33:48 <Cale> well, as the sizes seem to grow a lot as the pattern gets more general, I'd search as far as possible
19:34:01 <Cale> (for the best possible starting point)
19:35:09 <machack666> as far = most constraints ?
19:35:23 <machack666> or most general?
19:35:38 <Cale> well, collect as many relevant constraints as you can
19:35:45 <machack666> ok, I'm on your page
19:36:35 <Cale> if a constraint is relevant and in the cache, then any subconstraint is irrelevant and we don't want to go through those
19:43:10 <machack666> ok, going to digest for a while.
19:43:33 <machack666> it's pretty much the algorithm I had before with the addition of the intersections
19:44:24 <Cale> yeah
19:44:45 <Cale> the trick is in finding the best collection of intersections to use
19:45:04 <Cale> since in general, there could be lots of ways to do it
19:45:18 <Cale> but I think the heuristic of picking the smallest sets first is a good one
19:46:44 <machack666> bye now
19:47:00 <Cale> see you
20:12:29 <lisppaste2> syntaxfree pasted "what's wrong with this?" at http://paste.lisp.org/display/12533
20:15:38 <syntaxfree> did my lisppaste get through?
20:16:37 <sethk> lisppaste2, minimal (x:xs)
20:16:40 <sethk> lisppaste2, parens
20:16:40 <Cale> yes, one sec
20:16:44 <syntaxfree> ah thanks.
20:16:54 <Cale> yeah
20:16:58 <sethk> syntaxfree, I did that two hours ago, that's why I caught it immediately  :)
20:17:25 <syntaxfree> I also forgot to declare (Eq a)=>
20:17:33 <luqui> @paste
20:17:35 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:18:25 <syntaxfree> and a base case, too.
20:18:50 <syntaxfree> I'm sure there's a better way to do this with custom datatypes, but I'm trying to translate Scheme code function-per-function for an example.
20:21:21 <Cale> You could also import List and use nub
20:21:33 <Cale> @eval nub [1,1,1,2,3,2,4,1,3,5]
20:21:45 <lambdabot> [1,2,3,4,5]
20:30:50 <syntaxfree> I want to show two chunks of equivalent code in Scheme and Haskell.
20:32:36 <Cale> dons: heh, blackdog's name in HaskellUserLocations got spammed when the page images were being generated -- there's a link to tripod in the image
20:35:52 <syntaxfree> @wiki
20:35:53 <lambdabot> http://www.haskell.org/hawiki/
20:36:38 <syntaxfree> my own page at the hawiki is immutable!
20:38:28 <Cale> log in
20:38:55 <syntaxfree> I created it before having an username :(
20:39:06 <Cale> that shouldn't matter
20:39:16 <syntaxfree> ok!
20:39:18 <syntaxfree> thanks :)
20:39:20 <Cale> I think all pages are immutable now unless you log in
20:39:26 <Cale> because of spammers :|
20:39:56 <syntaxfree> I cleaned some spam today from HaskellOnMac
20:40:15 <syntaxfree> subtle spam, too. They changed links from GHC to online cassinos.
20:40:38 <Cale> yeah
20:40:56 <Cale> I reverted a couple hundred pages, I may still have missed some
20:40:58 <sethk> syntaxfree, that would fit better with a less deterministic language
20:41:06 <sethk> Cale, who does all that?
20:41:18 <sethk> Cale, who spends all that time?  Why haskell's wiki?
20:41:22 <sethk> Cale, I don't get it.
20:41:36 <Cale> sethk: automatic robots
20:41:51 <syntaxfree> sethk what do you mean?
20:42:00 <sethk> syntaxfree, I just don't understand the psychology
20:42:01 <Cale> and it's usually so that certain pages get a higher pagerank in Google
20:42:09 <sethk> ah, now that I understand
20:42:16 <sethk> money
20:42:40 <sethk> it's the vandalism I don't get.  Someone with enough ability to write a bot also has the ability to do something useful.
20:42:54 <syntaxfree> not necessarily.
20:43:00 <syntaxfree> writing a bot is very simple.
20:43:12 <Cale> On the Haskell wiki, most of the vandalism I see looks like bot testing
20:43:14 <sethk> syntaxfree, somebody wrote the tools to make it simple
20:43:27 <sethk> Cale, testing?  You mean someone testing their attack bot?
20:43:31 <Cale> yeah
20:43:55 <syntaxfree> to make what simple?
20:43:57 <sethk> I don't understand why people spray paint bridges either.  :)
20:44:00 <sethk> syntaxfree, construction of a bot
20:44:08 <sethk> syntaxfree, it's not simple
20:44:22 <Cale> Once you have a bot which messes with moinmoin wikis, it's easy to apply it all over the place.
20:44:29 <syntaxfree> hmm. isn't it just a bunch of HTTP requests?
20:44:47 <sethk> syntaxfree, of course.  But your average vandall is not conversant in RFPs
20:44:51 <sethk> vandal, sorry
20:44:59 <sethk> syntaxfree, http is actually a complex protocol
20:45:16 <sethk> syntaxfree, I didn't believe that until I wrote an http proxy
20:45:34 <sethk> but, easy, hard, somebody still get's their jollies that way
20:45:39 <skew> sethk: have you heard the phrase "script kiddy"?
20:45:49 <syntaxfree> It seems to me it can be done with curl and bash.
20:45:49 <syntaxfree> anyway.
20:45:49 <syntaxfree> @hawiki DiegoNavarro
20:45:50 <lambdabot> http://www.haskell.org/hawiki/DiegoNavarro
20:45:55 <sethk> skew, yes, of course, but then I'm talking about the folks who write the tools used by the kiddies
20:46:14 <Cale> There are also relatively easy to use HTTP libraries and tools out there
20:46:33 <sethk> Cale, sure, and somebody went to a lot of trouble to make it easy for a script kiddie to build a bot
20:46:34 <syntaxfree> yes. Curl is an out-of-the-box HTTP thing-doer.
20:46:37 <Cale> I wouldn't be surprised if someone was able to do it with a shell script and curl.
20:46:52 <skew> I don't think complexity is really an issue - If it's easy morons will do it themselves, and if it's hard somebody will do it just because it's hard
20:47:09 <sethk> skew, yes, but there are hard things to do that you can get paid to do.
20:47:10 <syntaxfree> I wrote stuff to log me onto my building network's proxy web interface.
20:47:17 <syntaxfree> it was two lines of bash.
20:47:20 <sethk> skew, I just mean I don't understand the mindset
20:47:32 <sethk> syntaxfree, why did you want to do that?
20:47:32 <skew> I think you need to make something tricky and mind numbiingly boring if you don't want somebody to write tools for working with it
20:47:35 <Cale> An automatic library-book renewer is always fun
20:47:49 <sethk> Cale, Hadn't thought about that
20:48:05 <sethk> Cale, now I know why a couple of libraries have eliminated on line renewals.
20:48:14 <syntaxfree> Cale: that's a neat idea. I'm always paying late fees because I haven''t renewed online.
20:49:06 <syntaxfree> skew: what about randomly-changing interfaces?
20:49:06 <syntaxfree> skew: the wiki would look the same. But the underlying CGI calls would change randomly.
20:49:26 <Cale> You just have to be careful, because someone might put a hold on one of your books, and then it can't be renewed, so you want the cron job to report that to you :)
20:49:46 <sethk> Cale, if you are a vandal, you just want to mess everything up for as many people as possible
20:49:50 <skew> that would be pretty cool
20:50:01 <sethk> syntaxfree, It would be interesting to see a packet trace of a bot update.
20:50:13 <syntaxfree> not too hard from a suitably large discrete set of interfaces, more interesting if interfaces evolve randomly from within.
20:50:37 <skew> But you still need a UI, so you could probably make a bot that just clicks any like labeled edit
20:50:47 <Cale> syntaxfree: that almost works, but you end up with bots that load the page and read off the cgi call to make.
20:50:49 <stepcut> skew: use a png
20:50:52 <skew> and fills it's stuff into the visible test area
20:50:53 <syntaxfree> skew: unless the edit button is an image.
20:50:55 <Cale> It would slow them down
20:50:58 <syntaxfree> with a random name.
20:51:16 <syntaxfree> anyway.
20:51:18 <syntaxfree> captchas.
20:51:22 <syntaxfree> captchas stop spam.
20:51:28 <sethk> syntaxfree, it would be fun to try.
20:51:38 <sethk> syntaxfree, what is captchas?  Is that anything like tarpit?
20:52:01 <Cale> completely automated public Turing test to tell computers and humans apart
20:52:09 <Cale> http://en.wikipedia.org/wiki/Captcha
20:52:48 <sethk> Cale, interesting, another thing I have to read.
20:52:56 <sethk> Cale, I've done some work in that area, I'll have to compare it.
20:53:24 <Cale> basically, present a distorted picture of a word, and ask the user to type it in
20:53:36 <Cale> something which OCR would have horrible difficulty with
20:53:39 <sethk> Cale, oh, yes, I've seen that
20:53:46 <sethk> Cale, the weird wavy prints, etc.
20:53:50 <Cale> yeah
20:53:56 <Cale> and messy, random fonts
20:54:01 <sethk> those are effective?  I wondered.
20:54:10 <syntaxfree> though they've found a way around captchas.
20:54:10 <Cale> and often lines and junk going through it
20:54:12 <Cale> yes
20:54:16 <syntaxfree> they put them in porn sites.
20:54:17 <shapr> fun to implement in Flippi?
20:54:21 <syntaxfree> so you answer it.
20:54:22 <Cale> yeah
20:54:35 <syntaxfree> to see naked grannies blowing balloons or something.
20:54:39 <sethk> syntaxfree, what do you mean?
20:54:54 <Cale> and then it's really the captcha of another pae
20:54:56 <Cale> page*
20:54:58 <sethk> syntaxfree, they redirect and grab the info?
20:55:12 <Cale> yeah
20:55:14 <syntaxfree> they grab the captcha image.
20:55:17 <syntaxfree> then reuse the info.
20:55:35 <sethk> syntaxfree, have to make one time use random human readable things
20:55:43 <Cale> I think the sane thing to do there is to monitor the IP address :)
20:55:45 <sethk> syntaxfree, which is non-trivial, but would be interesting to try
20:56:03 <Cale> though that would possibly break things like tor
20:56:31 <Cale> but the whole point is to identify yourself somewhat
20:56:47 <syntaxfree> http://www.puremango.co.uk/acdc_breakcaptcha.php
20:58:42 <sethk> Cale, I'm not sure why the human-only readable thing would relate to tor.  The image would still travel to the client, the answer to the server.
20:59:34 <syntaxfree> which do you find more readable, Scheme or Haskell? http://www.haskell.org/hawiki/DiegoNavarro
21:00:26 <Cale> sethk: well, if the server monitored IP address, then a tor user may have their IP address change between receiving the captcha and sending the response
21:00:39 <heatsink> It seems like the thing to do is to embed a description of the authentication process in the CAPTCHA.
21:01:09 <sethk> Cale, yes, but I don't see how the IP relates to the human readable thing.  Isn't checking IPs orthogonal to that?
21:01:16 <sethk> Cale, or am I missing something?
21:01:29 <heatsink> If you're on a porn site and the CAPTCHA says "enter the text shown below and your Yahoo! username", then hopefully users will be more suspicious
21:01:47 <heatsink> of course, it is a porn site so... maybe not.
21:02:13 <sethk> don't forget the yahoo password
21:02:35 <syntaxfree> maybe users do realize the trick but still want to go for it.
21:02:52 <sethk> someone actually tried to hire me to write, for a porn company, a thing that creeps in to a browser, and makes a call to a 900 number.  a long call.
21:03:04 <heatsink> wow
21:03:22 <syntaxfree> that's kinda unethical.
21:03:30 <sethk> syntaxfree, no shit  ?
21:03:35 <sethk> syntaxfree, I had to turn it down.
21:03:43 <syntaxfree> I'm being sarcastically naive.
21:03:53 <syntaxfree> sarcastically earnest, actually.
21:04:12 <sethk> syntaxfree, it's serious, major, reprehensible unethical
21:04:13 <sethk> :)
21:04:22 <sethk> syntaxfree, although I have to admit I thought it was a clever idea.
21:04:41 <syntaxfree> oh. dialers are standard game in the porn industry.
21:05:04 <sethk> syntaxfree, yes.  but the 900 number was a new one on me.  Maybe I'm naive
21:05:17 <Cale> One guy that I know runs a virus-scanning proxy which replaces ads on web pages with ads that give him money if you click on them
21:05:25 <syntaxfree> http://www.google.com/search?client=safari&rls=pt-br&q=porn+long-distance+call+dialer&ie=UTF-8&oe=UTF-8
21:05:46 <syntaxfree> http://www.google.com/search?hl=pt-BR&client=safari&rls=pt-br&q=porn+900+call+dialer&btnG=Pesquisar&lr=
21:06:55 <heatsink> Changing dialups to dial a 900 number is an old scam.  Compromised computers earn the trojan writers money for every minute they're online.
21:07:29 <stepcut> my uncle had 2 or 3 of those installed on his PC -- fortunately he is not on dialup
21:07:51 * heatsink reboots to test the kernel
21:23:51 <Cale> syntaxfree: formatted the code on your page :)
21:24:10 <syntaxfree> thanks :)
21:24:50 <syntaxfree> OH. Proper indentation for Scheme! Doublethanks!
21:25:05 <Cale> :)
21:26:16 <Cale> it makes the scheme more readable, but also points out how much more typing scheme is to write
21:27:20 <syntaxfree> yeah. Somehow, I got used to writing Scheme as compactly as possible.
21:31:32 <Cale> phew, good thing the "Delete Page" link asks for confirmation -- it's right under the "search titles" textbox
22:29:31 <araujo> Hello all!
22:30:20 <dons> hi araujo!
22:30:34 <araujo> Hola dons ! , what's up?
22:32:08 <dons> working on hIDE. how about you?
22:32:48 <araujo> dons, just getting up and next to code some scripts :-)
22:33:00 <araujo> How hIDE goes?
22:33:35 <dons> good good. I'm working on testing at the moment. Trying to squash bugs :)
22:37:27 <araujo> :-)
22:38:12 * araujo hopes to change emacs for hIDE 
22:39:13 <dons> me too :) but it will be some time yet
22:40:37 <araujo> I should get the sources of it, to see if i can at least report bugs too :-]
22:41:23 <luqui> can someone give me an example of an instance of Monad that does not satisfy monad laws?
22:41:54 <luqui> (not a standard instance, of course; a contrived one)
22:42:54 <dons> so here are the laws:
22:42:54 <dons> > return a >>= k  ==  k a
22:42:54 <dons> > m >>= return  ==  m
22:42:54 <dons> > m >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h
22:44:11 <dons> so, here for example is the defn of 'return' for Monad []
22:44:14 <dons>     return x            = [x]
22:44:20 <dons> break it, then your law doesn't hold.
22:44:29 <dons>     return x = [] , perhaps
22:44:32 <Cale> who is learning about monads? :)
22:44:35 <luqui> me
22:44:43 <luqui> I'm actually reading "theorems for free"
22:44:50 <luqui> and I couldn't come up with such an example
22:44:52 <dons> is that what you meant, luqui?
22:45:04 <luqui> but that's because I still don't quite grok the insides of monads
22:45:14 <luqui> dons, probably, let me stare at that
22:45:25 <dons> so now m >>= return  == m  no longer holds
22:45:28 <luqui> right
22:45:38 <dons> it's easy to break the law!
22:45:41 <luqui> but it is still well-typed
22:45:46 <Cale> assuming that you haven't changed >>= as well
22:45:58 <dons> yeah, hack away, and it quickly turns into nonsense
22:46:02 <luqui> okay, that's what I was trying to find out
22:46:04 <dons> the type system doesn't encode the laws
22:46:11 * luqui knew that
22:46:16 <dons> yep :)
22:46:30 <luqui> I was just wondering, given the level of genericity of the types involved, how easy it was to break the laws
22:46:34 <luqui> apparently pretty easy
22:46:50 <dons> well, you're still constrained by the polymorphic list type, for example.
22:47:00 <dons> so you can't say: return x = 1
22:47:31 <dons> you're restricted to expressions that are valid for all lists, but that still leaves plenty of room
22:47:38 <dons> return x >>= [x,x,x,x] say
22:48:22 <dons> even more fun to break >>=  ->      m >>= k             = foldr ((++) . k) [] m
22:48:39 <dons> @type (>>=)
22:48:43 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m
22:48:43 <lambdabot> b
22:50:01 <luqui> dons, is that a broken version?
22:50:22 <luqui> that looks like concatMap
22:50:22 <dons> it would be nice to have to provide a witness to the Monad and Functor laws, but we might need dependent types (anyone have some ideas on this?)
22:50:38 <dons> that's the (correct) >>= for the list monad
22:50:46 <luqui> okay
22:50:57 <Cale> xs >>= f = concat (map f xs)
22:51:54 <luqui> [] >>= f = [];  (x:_) >>= f = f x       -- still satisfies the laws
22:52:11 <luqui> ... I think
22:52:18 <Cale> yes, quite possibly :)
22:52:58 <Cale> things are necessarily monads in a unique way
22:53:02 <Cale> aren't*
22:53:08 <luqui> right
22:55:08 <luqui> dons, what do you mean a witness?
22:55:38 <Cale> a proof, essentially
22:56:30 <dons> yup. I'm thinking of a type that would force us to construct the required instance such that is must satisfy the monad laws, say
22:57:20 <luqui> you could do that in haskell?
22:57:40 <dons> I suspect yes (these days), but I'm not sure.
22:57:46 <luqui> wow
22:57:47 <Cale> possibly, but it would be tough without dependent types
22:58:17 <Cale> You can simulate some effects of dependent types through the typeclass system
22:58:18 <dons> what property is simplest, let me see..
22:59:56 <dons> doing this would almost be paper-worthy, I suspect :S
23:00:13 <dons> as usually you would fall back to a theorem prover
23:00:43 <dons> hmm, what about Functor, that looks easier
23:00:47 <dons> > fmap id  ==  id
23:00:48 <dons> > fmap (f . g)  ==  fmap f . fmap g
23:01:47 <dons> all the mental tricks I'd usually deploy in Twelf are useless here. dependent types please!
23:02:31 <luqui> is there some really trivial example you could give so I could see what you're talking about?
23:02:39 <Cale> okay
23:03:13 <dons> ah, ok. here's quick sort on the type level: http://www.cse.unsw.edu.au/~dons/qs.transcript
23:03:17 <Cale> so let's say you have a vector type, and you want to define a concatenation on vectors, and make sure that the sizes are right
23:04:33 <Cale> You could define naturals at the type level, as in that transcript
23:04:48 <Cale> and equality and sum of naturals via typeclasses
23:04:54 <Cale> with functional dependencies
23:05:12 <luqui> peano naturals
23:05:15 <Cale> yes
23:05:32 <Cale> check out the HList paper for lots of that sort of hackery :)
23:05:48 <luqui> you're just talking about encoding the laws in the type system?
23:05:53 <Cale> I believe it has been referred to as typeclass swindling :)
23:05:56 <Cale> yes
23:05:56 <dons> right, and then we also have lists of nats, so functor laws on [Integer] seems plausable
23:19:06 <Cale> dons: what do you think of the idea of extending the kind system to include subkinds of * given by class contexts in order to solve the problem of Set not being in the Functor class?
23:20:32 <dons> I like the idea of having more precise type information about class contexts, certainly.
23:20:46 <Cale> That is, introduce new kinds, something like {a | Ord a}, and make class contexts in data declarations restrict the kind of the type constructor being defined, so that those classes can be inferred by its application.
23:21:01 <dons> yep.
23:21:33 <dons> I hadn't thought about how that fixes Functor Set, but it seems elegant
23:21:51 <Cale> well, you change the meaning of the class declaration from:
23:22:02 <Cale> class Functor (f :: * -> *) where
23:22:22 <Cale>    fmap :: forall a,b :: *. (a -> b) -> (f a -> f b)
23:22:25 <Cale> to
23:22:35 <Cale> class Functor (f :: k -> k') where
23:22:51 <Cale>    fmap :: forall a,b :: k. (a -> b) -> (f a -> f b)
23:22:58 <Cale> where k, k' are subkinds of *
23:23:09 <dons> yes, I see your post. I like this, I wonder what SPJ's opinion of how doable this is.
23:23:27 <Cale> yes
23:23:39 <Cale> I've been thinking about sending him an email, actually :)
23:24:06 <dons> there's been other talk of hacking the kind system lately, so it is nicely timed
23:24:07 <Cale> It's too bad that he doesn't IRC (or maybe that's a good thing actually, he'd never get anything done :)
23:25:44 <Cale> oh, right, I'd actually forgotten I'd made that post already :)
23:25:48 <Cale> hehe
23:26:09 <dons> oh. there's also the polymorphic kind stuff spj has talked about previously
23:26:13 <Cale> I just sent something similar as a reply in the same thread, oops :)
23:26:21 <Cale> yeah
23:26:46 <Cale> I think the type system is getting complicated enough that the kind system needs to be extended to keep it under control :)
23:27:34 <Cale> oh, hang on, I hadn't sent that to everyone
23:27:42 <Cale> which post are you referring to?
23:27:50 <Cale> The Haskell Wiki, perhaps?
23:29:20 <dons> um, hmm, "private correspondence" perhaps? :S
23:29:33 <dons> it came up somewhere at sometime in the last few months
23:29:37 <Cale> oh
23:29:38 <Cale> hmm
23:29:49 <dons> but I'm sure the news has been leaked on other channels
23:29:53 <Cale> I sent a message to Wolfgang Lux about it
23:30:03 <Cale> and I've talked about it here
23:30:30 <Cale> so perhaps you're remembering that :)
23:30:44 <dons> i'm sure i've seen email from SPJ talking about polymorphic kinds
23:31:41 <dons> Nomius_: hi! you should add your details : http://haskell.org/hawiki/HaskellUserLocations :D
23:31:46 <araujo> Yeah!
23:31:49 <araujo> Hola Nomius_
23:31:57 <dons> and I missed exe again :/
23:32:41 <Cale> even the closeup on Europe is getting crowded :)
23:33:26 <dons> hmm, the low countries (is that the term?) need their own map
23:33:31 <araujo> There eist a haskell shell?
23:33:52 <dons> not really araujo, though there's been some ideas floated.
23:33:56 <araujo> (a shell written in haskell)
23:34:04 <araujo> I see....
23:34:04 <Cale> and there's H4SH
23:34:12 <dons> oh, and there's a shell in house
23:34:18 <dons> the OS, I presume written in haskell
23:34:29 <araujo> Yeah, though it isn't _that_ functional
23:34:31 <araujo> Yes
23:34:53 <dons> I made a short survey of the field at one point: http://www.cse.unsw.edu.au/~pls/thesis-topics/functionalshell.html
23:34:57 <araujo> I am looking for something which i could change bash for :-)
23:35:14 <dons> hmm, should add h4sh to that page, come to think of it
23:35:21 <araujo> Let's see
23:35:50 <dons> and stepcut had something cooking, not sure what though.
23:36:37 <gzl> hey, cool
23:36:41 <gzl> I was just looking for something like that
23:36:43 <gzl> (a functional shell)
23:37:17 * araujo would like to give a try to this project
23:37:26 <dons> araujo: go for it!
23:37:55 <dons> I have a few more ideas in the DOC file that comes with h4sh.
23:37:59 <araujo> I've been writting shell for a quite a time, nothing impressive, but functionals
23:38:03 <gzl> how practical is this Haskell OS stuff?
23:38:05 <dons> also, Oleg has written on the topic of shells as monads
23:38:15 <dons> gzl, very practical. it is used and works.
23:38:29 <araujo> gzl, i just downloaded version 0.5 today, it is very usable.
23:38:37 <dons> a high-assurance OS is a great thing
23:38:41 <gzl> where's it used?
23:39:02 <araujo> http://www.cse.ogi.edu/~hallgren/House/
23:39:37 <dons> anyone have a link to SyntaxNinja's filesystem-in-haskell?
23:39:39 <araujo> dons, i will have to take a lookat h4sh
23:39:45 <gzl> yeah, I'm looking at that House page
23:39:49 <gzl> but it doesn't really say where it's used
23:40:12 <gzl> and how does performance compare to some OS written in C?
23:40:27 <dons> check the papers, gzl, I'm sure they address this
23:40:51 <araujo> gzl, I think it is being used mainly for OS researching
23:40:53 <dons> though at ICFP the purely-Haskell OS is used for "demo purposes" and in practice they use a mostly-haskell OS, iirc
23:41:09 <dons> s/at ICFP it was stated that: /
23:41:19 <gzl> ok.
23:41:23 <gzl> I'll check it out.
23:41:42 <araujo> I use it on qemu here, though it works on bare hardware too.
23:42:40 <dons> yes, they ran it on a ThinkPad laptop while presenting their talk at ICFP
23:42:40 <gzl> oh, this shell stuff is neat
23:42:51 <gzl> typechecking the function composition in a pipeline
23:43:01 <araujo> Yeah, that's a good one.
23:44:25 <gzl> wait, this is a PhD thesis topic suggestion?
23:44:37 <dons> no, a 6 month honours thesis
23:44:49 <gzl> ok. it seemed a little odd otherwise :)
23:45:07 <dons> usually the student would do this project after finishing their 3 year bachelor
23:45:26 <dons> as an introduction to research, prior to a masters or a PhD (if they do very well)
23:45:39 <araujo> dons, did you code something for it?
23:45:54 <gzl> this seems kind of fun.
23:45:54 <dons> I wrote the topic :)
23:46:08 <dons> here are the other topics you can do: http://www.cse.unsw.edu.au/~pls/thesis-topics/
23:46:17 <gzl> especially since I literally *just* finished writing a shell in C
23:46:18 <araujo> Just asking to look at the code if any
23:46:25 <gzl> reinventing the usual thing, though
23:46:36 <araujo> gzl, did you ?
23:46:42 <dons> araujo, no code yet, though h4sh might count in a way.
23:46:48 <araujo> Ive been writing shell for quite a time too.
23:46:56 <araujo> dons, ok
23:47:35 <gzl> araujo: yes. for a class.
23:47:45 <gzl> I would never bother otherwise
23:51:10 <gzl> dons: they don't really say much about performance in the House paper
23:51:28 <gzl> only that it seems to have been OK for House's needs and that they haven't done any real performance analysis yet
23:51:38 <dons> ok
23:52:54 <gzl> I was arguing with somebody about this the other day, and they kept coming back to performance (claiming that it's impossible anything could rival an OS/shell/low-level what-have-you  written in C)
23:53:13 <gzl> so I was especially interested in whether they had data on this
23:54:26 <gzl> araujo: why were you writing a shell?
23:54:30 <gzl> and does it do anything interesting?
23:54:38 <dons> I think the main emphasis is high assurance. so it just doesn't crash. however, the performance isn't shabby, afaik
23:55:06 <dons> having an OS that actually works seems to me more important that something that runs fast, but does the wrong thing :)
23:55:22 <gzl> well, does the wrong thing sometimes
23:55:39 <basti_> are you talking about haskell vs. traditional languages for OS implementation?
23:55:42 <dons> I guess 90% of people are happy with an OS that does the wrong thing most of the time  ;)
23:55:46 <gzl> basti_: yes
23:56:20 <basti_> i think the benefits of a haskell construction would outweigh the slower speed by far
23:56:40 <gzl> but it depends on how much slower it is and what you're doing with it
23:56:45 <dons> I've found it interesting over the past few years that the OpenBSD guys (with an emphasis on correctness in the OS) have been adding more and more static typing tricks to the gcc they use to build the kernel
23:57:05 <araujo> I think thinking about "fast" OSes have stopped innovations to OS design in the last... mm.. 20 years?
23:57:11 <basti_> benefits being, clearer code, concepts being more primitive and orthogonal
23:57:12 <araujo> House is a way to change that imho.
23:57:32 <araujo> *thinking about "fast" OSes have stopped innovations to OS design in the last... mm.. 20 years?
23:57:42 <araujo> To make more more sense :-)
23:58:09 <dons> fast, but obfuscated, does make it harder to reason and refactor, I would imagine.
23:58:10 <gzl> basti_: I totally agree, and I can think of lots of reasons why a haskell construction would be nicer, but performance is one of the main arguments people use in favor of C, so I'd be curious to see how a haskell approach compares in that specific benchmark
23:58:47 <basti_> that will be very hard to say until you have a definitive example
23:58:49 <araujo> gzl, I wrote some shell and code for shells in several languages just for fun.
23:58:55 <gzl> basti_: yeah, I know, I'm just saying in general.
23:58:59 <basti_> ;)
23:59:03 <sieni> well there ought to be select() or poll() that you could wake up by signaling a pthread condition instead writing to a pipe
23:59:11 <basti_> i think the problem won't be as big as people might expect
23:59:21 <basti_> for example, haskell might use stream semantics.
23:59:50 <basti_> which would be better for file I/O than the contortions posix stuff is going through.
23:59:51 <sieni> what about using ML in os design? ;-)
