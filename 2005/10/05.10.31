00:05:17 <stefanw> found it in        install pkgDscr lbi (Nothing, verb)
00:05:26 <stefanw> sorry, in Distribution.Simple.Install
00:06:14 <kosmikus> stefanw: thanks very much for the update. I only wanted to know myself, actually ...
00:09:44 <joelr> howdy
00:10:23 <joelr> any idea how Data.Map lookups can be used in the `mplus` context?
00:10:38 <skew> that should word
00:10:44 <skew> that should work fine
00:11:03 <skew> and give either return val or mzero
00:11:08 <joelr> skew: how so?
00:11:16 <stefanw> kosmikus: np, if I write the email than I can also correct the problem ;-)
00:11:18 <joelr> skew: they don't return maybe
00:11:31 <joelr> skew: map lookup throws an exception i believe
00:12:01 <skew> Data.Map.lookup :: (Ord k, Monad m) => k -> Map k a -> m a
00:12:03 <joelr> Prelude Data.Map Control.Monad> x ! "foo"
00:12:03 <joelr> *** Exception: Map.find: element not in the map
00:12:17 <skew> it uses fail in whatever monad you happen to be in
00:12:18 <joelr> hmm
00:12:24 <joelr> skew: let me try that
00:12:33 <skew> fail "foo!" :: Maybe () => Nothing
00:13:17 <skew> empty ! 'x' :: Maybe Int => Nothing too
00:13:38 <joelr> skew: i missed that somehow, thanks
00:14:37 <joelr> skew: i'm trying to create a lookup function that uses the first map and if not found then the second
00:15:26 <skew> and what then?
00:15:39 <joelr> skew: seems like a good fit for `mplus` but i don't necessarily want to fail the current monad. maybe i should just lighten up and do it the regular pure way
00:15:56 <skew> you can always use another monad locally
00:16:33 <joelr> skew: let me think how i can do this ... you mean like runMaybe ( ... )
00:16:42 <skew> like lookups key maps = msum $ map (!key) maps :: Maybe val
00:17:41 <skew> ghci needs some way to import a module qualified, with a short name
00:17:48 <joelr> @index runMaybe
00:17:49 <lambdabot> bzzt
00:18:08 <joelr> skew: which monad would lookups use?
00:18:12 <skew> Maybe
00:18:23 <joelr> skew: cool
00:18:36 <joelr> skew: and maps is a list?
00:18:41 <skew> actually, might as well use anything in MonadPlus
00:19:32 <skew> but just like with lookup, you can treat the result as a Maybe if you want
00:21:02 <joelr> skew: playing with it now
00:21:33 <joelr> @index mplus
00:21:34 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
00:21:34 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
00:21:34 <lambdabot> Control.Monad.Error, Control.Monad.List
00:21:39 <joelr> @index msum
00:21:40 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
00:21:40 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
00:21:40 <lambdabot> Control.Monad.Error, Control.Monad.List
00:22:31 <skew> ! is not the same as lookup
00:23:20 <joelr> skew: ok
00:27:07 <joelr> (!!) maps key = msum $ map (M.!key) maps
00:27:20 <skew> ! is not the same as lookup
00:27:28 <skew> ! uses error, lookup uses fail
00:27:35 <joelr> skew: that's what you had i thought
00:27:41 <joelr> let me replace it
00:28:38 <skew> I wonder why ! does that. Also, I wonder why there is no updateAll function
00:30:32 <joelr> how come there's no runMaybe?
00:30:40 <skew> what would it do?
00:30:43 <joelr> skew: like this then
00:30:44 <joelr> (!!) maps key = msum $ map (lookup.key) maps
00:30:44 <joelr> x :: M.Map String Int = M.empty
00:30:44 <joelr> y :: M.Map String Int = M.fromList [("a", 1)]
00:30:44 <joelr> z m = (!!) [x, y]
00:30:47 <joelr> right?
00:31:23 <musasabi> joelr: What should be the type signature of runMaybe?
00:31:48 <joelr> musasabi: never mind that :-) i think it doesn't know the signature of (!!)
00:31:56 <joelr>     No instance for (MonadPlus ((->) [(b, b1)]))
00:31:56 <joelr>       arising from use of `z' at <interactive>:1:0
00:32:12 <joelr> well, no, actually it does
00:32:12 <joelr> (!!) :: forall b1 b a.
00:32:13 <joelr>         (Eq b, MonadPlus ((->) [(b, b1)])) =>
00:32:13 <joelr>         [a] -> (a -> b) -> [(b, b1)] -> Maybe b1
00:32:50 <joelr> but i'm trying to run z "a" and it's giving me the no instance of monadplus error which tells me that i probably need some sort of runXXX( z "a" ) no?
00:33:04 <joelr> i must be wrong
00:33:32 <skew> you probably want z m = [x,y] !! m
00:33:53 <xinming> @map
00:33:54 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
00:33:58 <skew> and maybe you need a type signature to pick an instance of MonadPlus
00:34:10 <joelr> z :: forall b1 b.
00:34:10 <joelr>      (MonadPlus ((->) [(b, b1)]), Eq b) =>
00:34:11 <joelr>      (Data.Map.Map String Int -> b) -> [(b, b1)] -> Maybe b1
00:34:23 <joelr> this is for z m = [x, y] !! m
00:35:10 <joelr> no, not right
00:35:47 <joelr> (!!) :: forall b1 b a.
00:35:47 <joelr>         (Eq b, MonadPlus ((->) [(b, b1)])) =>
00:35:48 <joelr>         [a] -> (a -> b) -> [(b, b1)] -> Maybe b1
00:35:53 <joelr> there's MonadPlus in there
00:36:12 <skew> that's not at all the type you want for !!
00:36:34 <joelr> skew: i recon so since i still can't do z "a" :-)
00:36:54 <skew> you want something like (Ord k, MonadPlus m) => k -> [Data.Map k v] -> m v
00:40:20 <joelr> so (Ord k, MonadPlus m) => k -> [Data.Map k v] -> m v but lookup :: (Monad m, Ord k) => k -> Map k a -> m a
00:40:40 <joelr> how do you use lookup for a map lambda?
00:40:53 <skew> MonadPlus is a subclass of Monad, so that's fine
00:41:06 <skew> lookup k looks fine to me
00:41:17 <skew> I used msum (map (lookup k) maps)
00:42:04 <joelr> foo.hs:8:35: Not in scope: `k'
00:42:10 <joelr> argh
00:42:28 * joelr does a mental morning excercise
00:43:58 <joelr>     Couldn't match the rigid variable `k' against `[[([Data.Map.Map k v], b)]]'
00:43:58 <joelr>       `k' is bound by the type signature for `!!'
00:43:58 <joelr>       Expected type: [[([Data.Map.Map k v], b)]]
00:43:58 <joelr>       Inferred type: k
00:43:59 <joelr>     In the second argument of `map', namely `maps'
00:44:18 <boegel|home> joelr: please don't paste too much in here :)
00:44:32 <joelr> boegel|home: ok, apologies
00:45:05 <boegel|home> joelr: there's a 5-10 lines max per paste, but when you're pasting lot's of things, it's better to use a paste page or the wiki
00:45:18 <joelr> boegel|home: ok
00:45:43 <boegel|home> joelr: I'm just saying it so you won't get shapr mad, you don't won't that to happen
00:46:06 <boegel|home> joelr: see -> http://www.elis.ugent.be/~kehoste/haskell-blah/shapr-ChanOp_dcoutts.png
00:46:11 <lisppaste2> joelr pasted "msum " at http://paste.lisp.org/display/13069
00:46:27 <boegel|home> when you're good, he's more like this -> http://www.elis.ugent.be/~kehoste/haskell-blah/shapr-angelic_dcoutts.png
00:47:02 <joelr> hehe
00:47:19 <joelr> any idea what i'm doing wrong? it looks fine on the surface
00:47:30 <musasabi> How should I decide whether to use HaXML or Haskell XML Toolbox for new apps?
00:47:31 <joelr> must be something deceptively simple
00:48:45 <joelr> i have things reversed for starters
00:49:25 <joelr> aha
00:49:29 <joelr> much better now!
00:50:11 <lisppaste2> joelr annotated #13069 with "a small fix" at http://paste.lisp.org/display/13069#1
00:51:13 <joelr> how do i extract the value, though?
00:51:58 <lisppaste2> joelr annotated #13069 with "how do i extract the value?" at http://paste.lisp.org/display/13069#2
00:52:23 <joelr> i thought it's done with runXXX( z "a" ), am I mistaken?
01:00:29 <joelr> i can't figure it out
01:00:47 <joelr> anyone willing to give that last bit of help?
01:19:10 <boegel|home> damn smallband :(
01:19:19 <skew> joelr: you need to fix the type of m
01:19:24 <joelr> skew: how?
01:19:26 <skew> try z "a" :: Maybe Int
01:19:30 <joelr> ah!
01:19:32 <joelr> damn
01:19:50 <joelr> :(
01:19:54 <joelr> i feel like a moron
01:20:03 <joelr> but hey, i learned something new today! :-)
01:20:21 <joelr> yesterday i new how to pass in computations now i now what to do when they are expected :)
01:24:10 <stefanw> does anybody know why cabal sets the permissions to 744 and not 755 when installing binaries?? Everything is ok when copying the file by hand...
01:29:23 <flux__> umask, maybe?
01:29:51 <stefanw> umask is 022, copying by hand is ok
01:41:12 <joelr> ghc thinks my module name is main
01:41:24 <joelr> whereas I have module Script.Engine where at the top
01:41:28 <joelr> why would that be?
01:41:47 <joelr> this is from Cabal "./Script/Engine.hs: file name does not match module name `Main'"
01:42:37 <xerox> Howdy
01:43:03 <joelr> xerox: hi
01:43:33 <joelr> has ghc gone bonkers?
01:43:36 <xerox> I think you need a Main module
01:44:00 <joelr> xerox: i'm building a library and i did not change anything but a function before it started complaining
01:44:10 <joelr> i now commented out that function but it's still complaining
01:44:11 <xerox> D'oh.
01:44:20 <xerox> Which library is it?
01:44:24 <joelr> mine :-)
01:44:32 <xerox> D'oh, again :)
01:44:35 <joelr> xerox: but the point is, it's complaining about a mismatch
01:44:40 <joelr> xerox: but i see none!
01:44:56 <skew> joelr: you just want module Engine, I think
01:45:09 <joelr> but it's in the directory Script
01:45:19 <joelr> it was working fine before, honest
01:47:22 <joelr> seems to have something to do with my import list
01:47:58 <joelr> case i comment out all the code (remove it from the file in fact) but it's still complaining
01:49:27 <ProfTeggy> G'day all.
02:01:21 <joelr> that was truly wierd
02:01:38 <joelr> i had to copy the file contents into another file and then copy that back
02:01:43 <joelr> maybe my emacs was screwing up
02:06:49 <JohnMeacham> evening.
02:16:01 <joelr> is there an elegant way to write a lookup then insert or adjust for Data.Map?
02:16:31 <joelr> never mind, i'm an idiot and insert already does that
02:20:38 <joelr> question
02:21:22 <joelr> if i have a function that returns a value in a monad, how can i compose them?
02:21:36 <jyp> them what ?
02:21:37 <JohnMeacham> 'ap'?
02:21:59 <joelr> say "getvar :: m v"
02:22:10 <araujo> Good morning!
02:22:21 <joelr> can i do x <- getvar $ getvar "getvar"
02:22:39 <jyp> =<<
02:22:46 <joelr> oh, cool
02:22:48 <jyp> instead of $
02:24:02 <joelr> what if i wanted to use getvar :: m v as argument to a regular function?
02:24:17 <joelr> any quicker way than x <- getvar ; foo x
02:24:26 <kolmodin> getvar >>= foo
02:24:41 <kolmodin> is that what you ment?
02:24:47 <joelr> so something like getvar >= print
02:24:48 <joelr> right?
02:25:08 <kolmodin> getvar >>= print, right
02:25:10 <joelr> or getvar >= putStrLn "This is the value" ++ show
02:25:29 <kolmodin> is the same thing as   do x <- getvar ; print x
02:25:36 <JohnMeacham> there is also =<<, but I have not had occasion to use it. I feel I am missing something.
02:25:47 <joelr> cool, thanks
02:30:06 <kolmodin> joelr: getvar >>= \x -> putStrLn ("this is the value" ++ x)
02:30:06 <kolmodin> joelr: but you are probably better of by using the do-syntax
02:30:40 <joelr> kolmodin: thanks!
02:31:06 <JohnMeacham> getvar >>= putstrln . "This is the value" . (++)  maybe..
02:31:50 <JohnMeacham> oh. getvar >>= putStrLn . ("This is the value" ++)
02:33:41 <kolmodin> JohnMeacham: yeah, that's nicer
02:35:14 <vegai> @pl getvar >>= \x -> putStrLn ("this is the value" ++ x)
02:35:15 <lambdabot> putStrLn . ("this is the value" ++) =<< getvar
02:41:19 <JohnMeacham> I wonder why it chose =<< rather than >>=.
02:42:43 <joelr> is this wrong?        let vars = map (\p -> (attrName p, p)) propsOf cmd''
02:42:54 <joelr> oops, yes, a $ is missing
02:46:51 <boegel|home> dons: the publication on the benchmark I'm running says it's 852 billion instructions, now I'm at 800 :)
03:21:07 <shapr> Has anyone re-implemented the "Types and Programming Languages" interpreters in Haskell?
03:21:35 <tromp> not me:(
03:22:05 <shapr> tromp: Do you keep up with the concatenative yahoogroup?
03:22:25 <tromp> not at all
03:22:41 <shapr> Stevan Apter is working on his own Lazy-K - http://www.nsl.com/k/slack/slack.htm
03:23:18 <shapr> It's based on ProfTeggy's SASL notes, "The Construction of an SASL Compiler"
03:24:02 <shapr> tromp: just in case concatenative languages interest you...
03:24:04 <tromp> thx for the pointer
03:24:29 <tromp> is slack a concatenative lang?
03:25:02 <shapr> No, Slack is actually purely functional, but the idea came from long discussions about Joy on the yahoogroup.
03:26:49 <tromp> i was not particularly charmed by those concatenative languages
03:27:00 <shapr> Ok :-)
03:29:31 <boegel|home> shapr: a new TMR coming up ?
03:29:37 <shapr> boegel|home: Gimme some articles :-)
03:29:45 <boegel|home> shapr: I ain't got any :P
03:29:59 <boegel|home> I find it strange there's no more animo for it
03:30:09 <shapr> I have one planned that extends my previous software testing article.
03:30:29 <shapr> I dunno, I'd like to get more articles. Who should I ask?
03:30:52 <boegel|home> shapr: I don't know
03:31:04 <shapr> edwinb: Want to write about dependent types for the next TMR?
03:31:07 <boegel|home> you've tried several things already
03:31:30 <boegel|home> @vixen would you want to write for the next TMR ?
03:31:31 <lambdabot> i might :)
03:31:42 <boegel|home> there you go :)
03:31:49 <boegel|home> say, is ghc available for Alpha ?
03:32:06 <shapr> lispy: Want to write about autoproc?
03:32:18 <boegel|home> I have to aggerate measuring results, and I think Haskell might be good for it
03:32:28 <shapr> aggerate?
03:32:33 <shapr> aggregate?
03:32:37 <dons> ghc runs on alpha, yep.
03:32:47 <boegel|home> aggregate, yeah :)
03:32:53 <dons> debian has it packaged even
03:33:07 <shapr> ProfTeggy: Did you see the complimentary things said about your "The Construction of an SASL Compiler" on http://www.nsl.com/k/slack/slack.htm ?
03:33:12 <boegel|home> dons: ok, thanks :) I hope I can get it installed on this old machine :) but I should write my program first :)
03:33:29 <shapr> boegel|home: Are you running Debian on that old machine?
03:33:43 <boegel|home> dons: I'm going to have to compile it myself, since it's for Digital Unix
03:33:47 <boegel|home> shapr: no, why ?
03:33:55 <shapr> Because then you could use a binary deb
03:34:01 <boegel|home> shapr: and it's not my machine, it's one from the research group
03:34:04 <shapr> Ah, ok
03:34:29 <boegel|home> shapr: I'm stressing it greatly atm, it's been executing a instrumented binary for 80hours straight :)
03:34:57 <shapr> JaffaCake: You think a rough GHC's Hacker's Intro could be done in a month?
03:35:00 <boegel|home> I hope it'll finish soon, 'cause I need to measure lot's of other stuff to
03:35:11 <JaffaCake> shapr: it's done :)
03:35:18 <boegel|home> JaffaCake: w00 !
03:35:45 <JaffaCake> well, not really an intro to hacking GHC per se, just an intro to getting your build set up in a way that's useful for hacking on
03:35:53 <shapr> awesome!
03:35:58 <shapr> Can I put it into the next TMR?
03:36:04 <JaffaCake> hang on, I'll find the URL
03:36:38 <JaffaCake> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/ghc/HACKING?ontent-type=text%2Fplain
03:37:05 <shapr> spiffy!
03:37:08 <astrolabe> Is 'HasBounds a => IArray a e' legal haskell 98?
03:37:44 <JaffaCake> shapr: feel free to grab it for TMR, if you want
03:37:49 <astrolabe> sorry, that should have 'class' on the front
03:38:26 <astrolabe> Is 'class HasBounds a => IArray a e' haskell 98?
03:39:50 <astrolabe> I am confused that IArray seems to have more than one argument
03:41:43 <kosmikus> it's not, Haskell 98 has only single-parameter type classes
03:42:10 <astrolabe> kismikus, thanks that gives me somewhere to start.
03:42:16 <astrolabe> *kosmikus
03:42:24 <boegel|home> astrolabe: that was funny :)
03:42:40 <astrolabe> :p
03:46:11 <shapr> JaffaCake: Thanks, I will.
03:46:13 <dcoutts_> JaffaCake, maybe there should be a list of some little examples that people who want to get into ghc hacking could try out.
03:46:27 <dcoutts_> I was thinking of one the other day...
03:46:35 <shapr> Yeah, simple tasks to start with would be neat.
03:47:21 <JaffaCake> sure, any ideas?
03:47:34 <dcoutts_> we have a really slow nfs setup in the department, and compiling gtk2hs progs takes a while because it has to pull >100 little .hi files accross the network. I was thinking of a .hi packer for packages
03:47:45 <dcoutts_> like we pack all the .o files into a .a file
03:48:17 <dcoutts_> so it'd mean extending the .hi file reader
03:48:32 <dcoutts_> and writing a little tool to pack them into one file
03:48:46 <dcoutts_> then cabal could use that for example when building packages
03:49:35 <shapr> Or adding tests
03:49:57 <shapr> Or documentation
03:50:05 <shapr> Template Haskell needs more docs and tests.
03:50:22 <dcoutts_> hmm, I think you need little fun examples
03:50:38 <dcoutts_> for tests and documentation you really need to know what you're doing :-)
03:50:43 <dcoutts_> it has to be right :-)
03:50:46 <shapr> That's true
03:51:08 <shapr> I'd like to have darcs because then patches work sort of like a moderated mailing list.
03:51:35 <dons> adding a flag to print something from some phase would be useful to the beginnner, perhaps.
03:51:40 <dcoutts_> you want something small and fun, like a student practical.
03:52:12 <dcoutts_> beginners would not necessarily expect their first mini project to get integrated into the ghc sources
03:52:53 <shapr> Or maybe they'd expect to get suggestions for improvement before integration?
03:53:04 <shapr> Sort of like Linus says "This is a good idea, but a bad implementation."
03:57:47 <MarcWeber> Cale: Are you listening? I've got some problems understanding your monads/their purpose/usage
03:57:58 <Cale> MarcWeber: hello
03:58:44 <liyang> SquishMe: register SquishMe too, and use /msg NickServ link Squish sqush'spassword
03:58:47 <boegel|home> @eval read "100" :: Int
03:58:48 <lambdabot> 100
03:58:52 <liyang> so the oops.
03:58:53 <liyang> oops.
03:58:56 <liyang> Gah.
03:58:58 <liyang> Ignore me.
03:59:14 <shapr> What's SquishMe?
03:59:27 <liyang> A person. We think.
03:59:31 <shapr> ok..
04:00:01 <liyang> (Wrong channel.)
04:00:11 <MarcWeber> Cale: What does liftstate do? Is evalRand only for getting one value (because it doesn't return StdGen)?
04:01:17 <Cale> MarcWeber: evalRand executes a computation which is somewhat random -- you pass it a StdGen, it constructs a value based on the given computation
04:02:49 <Cale> liftState does exactly what its type says it does :)
04:02:55 <Cale> liftState :: (MonadState s m) => (s -> (a,s)) -> m a
04:03:21 <Cale> it takes a function from states to values and states, and returns a value typed in the state monad
04:04:22 <Cale> (which does that state transforming)
04:04:50 <musasabi> How would I process a sequence of <tr><td><foo>key</foo></td><td>value</td></tr> nicely to [(Key,Value)] with Haskell XML toolbox?
04:05:03 <Cale> in the case of m = State, this is just the same as wrapping that thing up in the State constructor
04:05:53 <Cale> MarcWeber: does that help?
04:07:07 <MarcWeber> Cale: Not sure. state=representation in string format of StdGen? (with read. show g = g ) ?
04:07:26 <Cale> hm?
04:08:12 <MarcWeber> doc: System.Random.html state is used as a string representation of the random generator state. ( to be able to save/restore it)
04:08:28 <Cale> that's a different state
04:08:44 <astrolabe> The line 'class HasBounds a => IArray a e' is from http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html  Is the haskell extension that it uses listed here? http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
04:09:35 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#multi-param-type-classes
04:10:02 <astrolabe> Cale, thanks alot
04:10:50 <xerox> Hmm, how would you write a function to calculate the mean square deviation?
04:10:57 <Cale> it's just the same as ordinary typeclasses, but with more than one type parameter
04:11:24 <MarcWeber> Cale: Which kind of state were you talking about?
04:11:39 <Cale> MarcWeber: I'm using a state monad to carry around the StdGen
04:12:34 <astrolabe> Cale, I need to think about it :)
04:12:57 <MarcWeber> Then I'll consult the monad tutorial again.. ;)
04:13:33 <Cale> actually, that MonadRandom code isn't my newest
04:13:36 <Cale> hmm
04:13:56 <poetix> shapr: Chris Rathman has done/is doing the TaPL code in Alice ML - quite close to Haskell
04:14:02 <Lemmih> Can the techniques from the HList paper still be used in >=GHC-6.4?
04:14:28 <MarcWeber> Cale: I don't thnink that that really matters.. ;) I'll have to go through that monad stuff completely first
04:14:40 <shapr> poetix: hiya! Where's the code?
04:15:07 <Cale> MarcWeber: yeah, just get some familiarity with state monads, which aren't the easiest to understand
04:15:36 <poetix> http://codepoetics.com/wiki/index.php?title=Topics:TAPL_in_other_languages:Alice_ML
04:16:05 <shapr> Oh right, you run the TaPL wiki.
04:16:38 <MarcWeber> Cale: Thanks a lot. I'm still thinking haskell is the way to go ;) bye
04:16:50 <shapr> er, CTM wiki
04:19:46 <Blah75> hello all
04:19:58 <Blah75> having a little problem with Haskell - keep getting this error:
04:19:59 <Blah75> ERROR - Garbage collection fails to reclaim sufficient space
04:20:03 <Blah75> not sure exactly what it means
04:20:11 <Blah75> i'm guessing something is running out of memory
04:20:44 <liyang> lol.
04:20:55 <liyang> Looks like a space leak.
04:21:01 <Blah75> how do you mean ?
04:21:20 <liyang> What are you writing?
04:21:55 <Blah75> its a long winded thing, which basically generates a long list of data
04:22:28 <Blah75> if i add more and more things to this list, theres a limit it reaches at which point it prints that error
04:35:38 <tromp> maybe you cld paste the relevant lines of code here
04:44:10 <boegel|home> is there a 'log base 10' function in Prelude ?
04:44:21 <boegel|home> @index log
04:44:22 <lambdabot> Prelude
04:44:26 <boegel|home> @index log10
04:44:26 <lambdabot> bzzt
04:44:48 <mauke> @index logBase
04:44:49 <lambdabot> Prelude
04:45:15 <liyang> Just write log10 x = log x / log 10 ?
04:45:35 <boegel|home> mauke: thanks !
04:46:28 <boegel|home> @fromIntegral
04:46:29 <lambdabot> Unknown command, try @listcommands.
04:46:34 <boegel|home> @index fromIntegral
04:46:35 <lambdabot> Prelude
04:49:26 <Cale> xerox: oh, sorry, I could have answered that
04:53:56 <gilles> hey
04:56:20 * boegel|home scratches his head
04:56:47 <boegel|home> okay, tell me if I'm mistaking here, but 'logBase 10 x' would give you y in x = 10^y, right ?
04:56:58 <boegel|home> regardless of types
04:57:36 <Cale> should, yeah
04:57:42 <Cale> and up to numerical problems
04:57:43 <boegel|home> well, it doesn't
04:58:04 <Cale> oh, not ^
04:58:06 <Cale> **
04:58:21 <boegel|home> oh wait :) some rounding problems
04:58:22 <Cale> but mathematically, that's what it does
04:59:08 <boegel|home> sorry, it's rounding problems, I suggested hugs would be able to do 10 perfectly, so I used truncate in steadof round :) my fault !
04:59:28 <Cale> ah
04:59:39 <Cale> it should do base 2 the most correctly
05:03:07 <boegel|home> ok, nvm :)
05:04:27 * boegel|home leaves
05:16:59 <shapr> kiiyah!
05:17:02 * shapr karate chops lambdabot 
05:19:32 <xah> shapr: :D
05:22:11 <ndm> dons?
05:22:55 <shapr> Any idea where I can beg, borrow, or steal a copy of Richard Hamming's "You and Your Research" ?
05:23:17 <shapr> I've found used copies on amazon.co.uk for large sums of money, but I can't really afford those.
05:23:21 <Spark> library? :p
05:23:29 <shapr> Does anyone here have one they'll sell to me for a smaller sum of money?
05:24:05 <Igloo> What is a large sum OOI?
05:24:22 <shapr> Igloo: I'll buy a copy off of you for a hundred pounds sterling, how's that?
05:24:38 <Igloo> I don't have one, I'm just curious as to what a large sum is
05:24:44 <shapr> amazon.co.uk has used copies from 157 pounds to 500 something pounds.
05:24:57 <shapr> Does that count as a large sum of money? :-)
05:25:02 <Igloo> Wow
05:25:13 <Igloo> Do you know what the list price is?
05:25:18 <shapr> forty pounds
05:25:39 <shapr> I *really* want that book.
05:26:01 <shapr> I've been looking for a copy under a hundred pounds for nearly a year now.
05:26:53 <xerox> Cale: answers are welcome :-)
05:27:24 <Cale> xerox: mean square deviation, right?
05:27:32 <xerox> Yes.
05:28:05 <Cale> that is, take the mean of the values, compute the absolute values of the differences of the values from the mean, then square those, and sum it
05:28:11 <Cale> er
05:28:23 <shapr> After I read it, I would put that book on my shelf next to my first edition copy of Vernor Vinge's 'True Names.'
05:28:27 <Cale> then divide again by the number of values
05:28:36 <Cale> which is, take the mean again :)
05:28:46 <xerox> Yes.  But I'm not happy with the definition I wrote :)
05:29:04 <xerox> So I would like to see how other people would've wrote it :)
05:29:17 <Cale> let m = mean xs in mean [abs (x - m) ** 2 | x <- xs]
05:29:42 <Cale> er, you're squaring anyway
05:29:46 <shapr> Igloo: If you happen to find a copy, I'm serious about buying it off of you for a hundred pounds.
05:29:49 <Cale> let m = mean xs in mean [(x - m) ** 2 | x <- xs]
05:30:07 <Igloo> shapr: Have you tried asking the publisher if they have any?
05:30:25 <shapr> No, I think it's been out of print for many years. But I'll ask anywya.
05:30:29 <shapr> Good idea, thanks.
05:38:20 <marcot> dcoutts: helo there.
05:45:41 <dcoutts_> hia marcot
06:17:40 * boegel|home sings: woooooooooooooohoooooooohohohoooooow
06:19:02 <shapr> hiya boegel|home!
06:21:46 * boegel|home wonders is the music is always this good when he's at work
06:21:51 <boegel|home> s/is/if
06:23:09 <shapr> I wish I could find proofs by creator.
06:23:21 <shapr> Cale: Is there such a thing? Even better, in an automated proof checker format?
06:23:48 <Cale> shapr: not that I'm aware of
06:24:03 <shapr> I'm looking for a proof by Colin L. Mallows.
06:24:22 <joelr> is there a monadic version of while?
06:24:30 <joelr> or is there an easy way to simulate it?
06:24:33 <shapr> Cale: CPAN - Computer Proof Archive Network?
06:25:50 * boegel|home blinks: 290248 kehoste   53    0   11M 4636K run    82.2H 99.30% clustalw_kehos
06:27:08 <joelr> ping
06:27:39 <Cale> shapr: that's a neat idea.
06:29:35 <astrolabe> mean [x**2|x<xs]-(mean xs)**2  (unless you are worried about numerical accuracy)
06:38:19 <boegel|home> shapr: what's the max # clients so far ?
06:38:57 <xerox> How many consequent strings long n are there in a string long m, with n < m ?
06:39:13 <xerox> m - n?
06:40:14 <tromp> consequent???
06:40:21 <boegel|home> xerox: it's more complicated than that I think
06:40:36 <xerox> tromp: sorry.  I mean "continuous" (?)
06:40:55 <boegel|home> he probably means "# substrings of length n in a string of length m"
06:41:10 <xerox> Like n=2 in "foobar", ["fo","oo","ob","ba","ar"]
06:41:15 <tromp> ah, m-n+1
06:41:23 <boegel|home> is it that simple ?
06:41:31 <xerox> boegel|home: I would have thought so
06:41:52 <xerox> tromp: okay, thanks.
06:42:44 <xerox> Now I need a nice way to calculate them ;)
06:42:48 <boegel|home> is there any way to aggregate 'n/x +n/y + n/z' without knowing the values of x,y,z ?
06:43:24 <xerox> boegel: n * (1/x + 1/y + 1/z) ?
06:43:51 <boegel|home> xerox: wait, no, I asked it in a wrong way :)
06:44:28 <boegel|home> I have 3 values a b c (a = n/x, b = n/y, c = n/z), and I need to calculate n / (x+y+z), without knowing x,y,z
06:44:31 <boegel|home> is that possible ?
06:45:25 <marcot> boegel|home: sure it is.
06:45:26 <boegel|home> hmm wait
06:45:28 <astrolabe> shapr: is this what you are after? http://www.abe.pl/html/english/details.php?id=9056995014
06:45:38 <boegel|home> since I know n, it shouldn't be that hard :)
06:45:46 <boegel|home> but I was thinking without using n...
06:45:56 <boegel|home> if _that's_ possible :)
06:46:00 <marcot> n / (x + y + z) = (a^-1 + b^-1 + c^-1)^-1
06:46:24 <marcot> I'm not sure if  it's haskell.
06:46:53 <marcot> (a**(-1) + b**(-1) + c**(-1))**(-1)
06:47:08 <Si\Uni> is there anyway of converting a monadic transformation (i.e. a -> m a) into a pure transformation in the monad (i.e. m (a -> a))?
06:47:20 <boegel|home> marcot: nice thinking :)
06:47:59 <marcot> boegel|home: thanks.
06:49:29 <shapr> boegel|home: 206 I think
06:49:51 <shapr> astrolabe: YES! You think they really have it?
06:50:08 <astrolabe> shapr:  could be  :)
06:50:48 <int-e> marcot: for integer exponents, you could consider using ^^, too - that also works for rational numbers, say.
06:51:08 <shapr> Amazon claims to have it for 17 pounds, but I've ordered that flavor repeatedly, and they keep saying "aww, no go" months later.
06:51:40 <astrolabe> Amazon seem to do that quite a lot these days.  It's annoying.
06:53:04 <astrolabe> shapr: I've just noticed, they say 'out of stock'  sorry.
06:53:32 <shapr> too bad :-(
06:53:44 <marcot> int-e: good point.
06:56:11 * xerox mumbles
06:57:27 <astrolabe> shapr: There are a few places here http://www.google.co.uk/search?hl=en&q=9056995014&btnG=Google+Search&meta= that claim to have it.  I'd take it with a pinch of salt though.
06:59:59 <gour> dcoutts, ping
07:06:05 <joelr> folks, assuming i wanted a monadic while and did something like this
07:06:06 <joelr> while cond action =
07:06:06 <joelr>     do continue <- cond
07:06:06 <joelr>        if continue
07:06:06 <joelr>           then do { action; while cond action }
07:06:09 <joelr>           else return ()
07:06:19 <joelr> while my condition be re-evaluated on every loop?
07:06:42 <joelr> will it be re-evaluated, sorry
07:07:17 <earthy> joelr: yes. look at the code. :)
07:07:25 <xerox> mdo? :)
07:07:33 <joelr> xerox: what?
07:07:41 <integral> joelr: cond is a monadic action...
07:07:46 <JaffaCake> joelr: strictly speaking it may depend on the monad, but in most cases yes
07:08:01 <integral> so, the action itself won't be...
07:08:06 <joelr> mdo, is that the recursive do extension?
07:08:25 <joelr> integral: the action won't be re-evaluated?
07:08:47 <joelr> i basically want to run my action on every loop
07:08:49 <integral> joelr: I hope not...  after it's been forced once, I'd expect it to be updated.
07:09:02 <earthy> cond won't be re-calculated, no
07:09:03 <integral> joelr: the *action* itself is rerun though
07:09:10 <joelr> darn
07:09:14 <shapr> Yeesh, this book is $1588 in the US.
07:09:17 <joelr> how do i force cond to be re-evaluated?
07:09:21 <integral> joelr: o_O why?
07:09:26 <earthy> $1588 for a *book*?!
07:09:44 <joelr> i have a game loop with a condition, or at least i'm trying to fake one
07:09:50 <joelr> while (keep going) do { stuff }
07:10:00 <integral> joelr: I don't understand.  You don't need to reevaluate cond
07:10:13 <shapr> earthy: Yeah, by Richard Hamming
07:10:18 <joelr> integral:  why not? my monad changes on every iteration
07:10:20 <shapr> earthy: published 1997 even
07:10:26 <integral> cond :: (Monad m) => m a -- you need to "run" the monad again, not evaluate it.  You run it by putting it on the right of the <-
07:10:28 <joelr> integral: cond re-evaluates the world
07:10:29 <earthy> okay, I can see the pull. but $1588??
07:10:29 <integral> joelr: o_O
07:10:40 <integral> ok, I must be missing something
07:10:51 <shapr> earthy: It's out of print, and it's a clear recipe for becoming a famous researcher :-)
07:11:03 <joelr> integral: which is something that i'm doing, right
07:11:06 <integral> joelr: consider: foo a = do { a; a };  main = foo (putStrLn "hello")
07:11:10 <JaffaCake> joelr: you're fine, the cond *action* will be *re-exectued* each time around the loop
07:11:11 <integral> joelr: that prints "hello" twice
07:11:17 <joelr> integral:     do continue <- cond
07:11:20 <joelr> ok, cool
07:11:24 <shapr> Is amazon.co.uk down?
07:11:29 <integral> joelr: but it evaluates (putStrLn "hello") *once*
07:11:30 <joelr> thank you guys
07:12:19 <astrolabe> shapr yes
07:12:33 <shapr> foo
07:12:36 <xerox> let f n 0 _ = []; f n i xs = take n xs : f n (i-1) (drop (n-1) xs)
07:12:37 <shapr> I killed it!
07:12:53 <xerox> I think there SHOULD be a generalization of that pattern.
07:12:58 <xerox> Do you know what it is?
07:13:26 <xerox> (try: f 2 (length "foobar" - 2 + 2) "foobar")
07:13:30 <xerox> ops, "+ 1"
07:16:47 <xerox> Hmmm.
07:21:01 <boegel|home> is there some function which maps a mask to some string, to extract information ?
07:21:34 <boegel|home> or which can split up a string into several string, given some character ?
07:21:38 <boegel|home> @index split
07:21:39 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.
07:21:39 <lambdabot> TH.Ppr, System.Random
07:21:46 <boegel|home> hmm
07:21:54 <boegel|home> @type lines
07:21:55 <lambdabot> String -> [String]
07:21:59 <boegel|home> something like this ^
07:22:09 <boegel|home> @hoogle String -> Char -> [String]
07:22:10 <lambdabot> Data.List.lines :: String -> [String]
07:22:10 <lambdabot> Data.List.words :: String -> [String]
07:22:10 <lambdabot> Prelude.lines :: String -> [String]
07:22:19 <boegel|home> @hoogle Char -> String -> [String]
07:22:20 <lambdabot> Data.List.lines :: String -> [String]
07:22:20 <lambdabot> Data.List.words :: String -> [String]
07:22:20 <lambdabot> Prelude.lines :: String -> [String]
07:22:23 <boegel|home> hmm
07:22:30 <astrolabe> boegel|home: yeah, it would be good if words and lines used some more general function
07:22:40 <boegel|home> astrolabe: but it's not so ?
07:22:45 <astrolabe> probably defined for general lists
07:22:45 <sylvan> yeah, wordsBy would be neat
07:22:46 <Lemmih> A generalization of 'lines' would have the type: (Char -> Bool) -> String -> [String]
07:23:10 <astrolabe> boegel|home: Not according to my haskell book
07:23:15 <SamB> @index IORef
07:23:16 <lambdabot> Data.IORef
07:23:18 <boegel|home> Lemmih: why (Char -> Bool) ?
07:23:20 <sylvan> @hoogle (a -> Bool) -> [a] -> [[a]]
07:23:21 <lambdabot> No matches, try a more general search
07:23:49 <sylvan> boegel|home, because it needs to "test" if a character should cause a "break"
07:24:00 <Lemmih> @evel words "hello\t world"
07:24:01 <lambdabot> ["hello","world"]
07:24:20 <boegel|home> sylvan: given some character, there's no need for a Bool function, right ?
07:24:24 <sylvan> It's better to pass in the test, instead of requireing it to always be (\x y -> x==y)
07:24:45 <sylvan> well it's more general to pass in the test function, so if you're making it general, don't just make it a little general
07:24:54 <boegel|home> wordsBy ':' "this:is:a:test" = ["this","is","a","test"]
07:25:16 <astrolabe> So, clearly the way to do it is to swap ' ' for the character you want, then use words, and then swap back.
07:25:22 <sylvan> Maybe you want to split a string of chars at each 'a' 'b' and 'c', say
07:25:25 <boegel|home> I don't see how passing a function is more general than passing just and argument
07:25:29 <flux__> lemmih, wouldn't you potentially like to generalize by sequences?
07:25:53 <boegel|home> sylvan: hmm, ok
07:25:56 <sylvan> boegel|home, like I said, just passing the char you can ONLY split the list by comparing against a single char, maybe you want to split it on several different chars?
07:25:58 <boegel|home> didn't see it like that :)
07:26:13 <flux__> and also potentially you would like to get 'empty words', "a b   c" -> ["a", "b", "", "", "c"]
07:26:24 <boegel|home> astrolabe: swapping would work I think....
07:26:25 <flux__> and then the generalized function is quite complex ;)
07:26:27 <boegel|home> @index swap
07:26:28 <lambdabot> bzzt
07:26:28 <sylvan> in fact, I think words is like that, I mean it splits on more tokens than just ' '
07:26:31 <boegel|home> @index subst
07:26:32 <lambdabot> bzzt
07:26:34 <boegel|home> @index subs
07:26:34 <lambdabot> bzzt
07:26:44 <astrolabe> boegal: it was joke, that's horrible.
07:26:52 <boegel|home> astrolabe: it would work for me ;)
07:27:22 <boegel|home> astrolabe: let me just find the definition of words :)
07:27:25 <astrolabe> I think I've written one, hang on a mo
07:27:36 <flux__> infact maybe it should just return empty words too, you can easily filter them out
07:27:38 <Lemmih> flux__: I don't think so.
07:27:46 <sylvan> it's fairly simple to write one using takeWhile and dropWhile
07:27:53 <flux__> well, how about efficiency?
07:28:23 <flux__> maybe I should try to write the function before questioning these though ;)
07:28:29 <sylvan> well write a splitWhile :: (a -> Bool) -> [a] -> ([a],[a])
07:28:34 <sylvan> and use that
07:29:09 <astrolabe> I can't find it :(
07:29:24 <boegel|home> astrolabe: http://www.cs.uu.nl/~afie/haskell/tourofprelude.html#lines :)
07:29:47 <astrolabe> boegel: I mean I wrote a general one, or I thought I did.
07:31:53 <sylvan> @eval let wordsBy f xs = let (a,b) = break f xs in a : wordsBy f b in wordsBy (==' ') "this is a few words"
07:31:55 <lambdabot> ["this","","","","","","","","","","","","","","","","","","","","","","",
07:31:55 <lambdabot> "","","","","","","","","","","","","","","","","","","","","","","","",""
07:31:55 <lambdabot> ,"","","","","","","","","","","","","","","","","","","","","","","","","
07:31:55 <lambdabot> ","","","","","","","","","","","","","","","","","","","","","","","","",
07:31:55 <lambdabot> "","","","","","","","","","","","","","","","","","","","","","","","",""
07:31:57 <lambdabot> [23 @more lines]
07:31:59 <sylvan> ah, crap =)
07:32:02 <boegel|home> :)
07:32:14 <sylvan> I need where clauses =)
07:32:37 <boegel|home> @index flatten
07:32:37 <lambdabot> Data.Tree
07:32:41 <boegel|home> :s
07:32:46 <boegel|home> :t concat
07:32:48 <boegel|home> grr
07:32:53 <boegel|home> @type concat
07:32:54 <lambdabot> forall a. [[a]] -> [a]
07:33:01 <boegel|home> hmm, that works...
07:33:10 <int-e> @eval let wordsBy _ "" = []; wordsBy f xs = let (a,b) = break f xs in a : wordsBy f b in wordsBy (==' ') "this is a few words"
07:33:11 <lambdabot> ["this","","","","","","","","","","","","","","","","","","","","","","",
07:33:11 <lambdabot> "","","","","","","","","","","","","","","","","","","","","","","","",""
07:33:11 <lambdabot> ,"","","","","","","","","","","","","","","","","","","","","","","","","
07:33:11 <lambdabot> ","","","","","","","","","","","","","","","","","","","","","","","","",
07:33:11 <lambdabot> "","","","","","","","","","","","","","","","","","","","","","","","",""
07:33:13 <lambdabot> [23 @more lines]
07:33:15 <eivuokko> Don't you want span instead of break?
07:33:27 <SamB> @index unsafePerformIO
07:33:27 <lambdabot> System.IO.Unsafe, Foreign
07:33:46 <int-e> ah!
07:34:21 <sylvan> @eval let wordsBy f xs = let (a,b) = break f xs in a : wordsBy f (dropWhile f b) in wordsBy (==' ') "this is a few words"
07:34:22 <lambdabot> ["this","is","a","few","words","","","","","","","","","","","","","","","
07:34:22 <lambdabot> ","","","","","","","","","","","","","","","","","","","","","","","","",
07:34:22 <lambdabot> "","","","","","","","","","","","","","","","","","","","","","","","",""
07:34:22 <lambdabot> ,"","","","","","","","","","","","","","","","","","","","","","","","","
07:34:22 <lambdabot> ","","","","","","","","","","","","","","","","","","","","","","","","",
07:34:23 <int-e> @eval let wordsBy _ "" = []; wordsBy f xs = let (a,b) = break f xs in a : wordsBy f (tail b) in wordsBy (==' ') "this is a few words"
07:34:24 <lambdabot> [23 @more lines]
07:34:26 <lambdabot> Prelude.tail: empty list
07:34:29 <ProfTeggy> hmm
07:34:34 <int-e> *sniff*
07:34:40 <sylvan> @eval let wordsBy _ [] = [] ; wordsBy f xs = let (a,b) = break f xs in a : wordsBy f (dropWhile f b) in wordsBy (==' ') "this is a few words"
07:34:42 <lambdabot> ["this","is","a","few","words"]
07:34:55 <xerox> hehe
07:34:58 <xerox> I did this:
07:34:58 <sylvan> looks better with where-clauses I think
07:35:10 <xerox> http://rafb.net/paste/results/KhdDiV80.html
07:35:16 <xerox> The second one is very nice but not working atm.
07:35:44 <sylvan> wordsBy _ [] = []
07:35:44 <sylvan> wordsBy f xs = e : wordsBy f (dropWhile f xs')
07:35:44 <sylvan>     where (e, xs') = break f xs
07:36:33 <xerox> ah, silly me.
07:36:51 <xerox> I can't do that, heh.
07:38:34 <thedward> @eval words  "this is a few words"
07:38:35 <lambdabot> ["this","is","a","few","words"]
07:39:59 * xerox wants arrows btlblbl..
07:40:30 <ProfTeggy> xerox, eat this \Rightarrow, \to
07:40:43 * xerox yummys
07:43:17 <boegel|home> is there some way to prevent 'show $ read' from producing a string like "0.001960" like "1.96e-3" ?
07:43:27 <boegel|home> @eval show $ read "0.001960"
07:43:28 <lambdabot> Add a type signature
07:43:36 <boegel|home> @eval show $ (read "0.001960" :: Float)
07:43:37 <lambdabot> "1.96e-3"
07:43:41 <boegel|home> @eval show $ (read "0.001960" :: Double)
07:43:42 <lambdabot> "1.96e-3"
07:43:46 <boegel|home> anyone ?
07:43:49 <ProfTeggy> boegel, one second
07:43:57 <Igloo> There are other show functions in Numeric
07:44:04 <boegel|home> oh ? lemme see
07:44:28 <boegel|home> @eval showEFloat $ (read "0.001960" :: Float)
07:44:29 <lambdabot> Couldn't match `Maybe Int' against `Float'
07:44:31 <ProfTeggy> showFFloat (Just 2) x ""
07:44:41 <boegel|home> @eval showFloat $ (read "0.001960" :: Float)
07:44:42 <lambdabot>  add an instance declaration for (Show (String -> String))
07:44:47 <boegel|home> arg :)
07:45:11 <boegel|home> @eval showFloat $ (readFloat "0.001960")
07:45:12 <lambdabot>  add an instance declaration for (Show (String -> String))
07:45:20 <boegel|home> @eval readFloat "0.001960"
07:45:21 <lambdabot> [(1.96e-3,"")]
07:45:36 <sethk> with the parens you don't need the $
07:45:47 <boegel|home> sethk: yeah I know, sorry:)
07:46:01 <ProfTeggy> @eval showFFloat (Just 5) 0.001960 ""
07:46:03 <lambdabot> "0.00196"
07:46:14 <boegel|home> that's just because I removed the type
07:46:21 <boegel|home> ProfTeggy: hmm, okay, thanks :)
07:47:00 <boegel|home> @eval showFFloat Nothing 0.001960 ""
07:47:01 <lambdabot> "0.00196"
07:47:09 <boegel|home> @eval showFFloat Nothing 0.001960 "bmeh"
07:47:10 <lambdabot> "0.00196bmeh"
07:47:21 <ProfTeggy> it's of type ShowS
07:47:24 <xerox> @eval showFFloat (Just 6) 0.001960 ""
07:47:26 <lambdabot> "0.001960"
07:47:27 <boegel|home> @eval showFFloat Nothing (read "0.001906) ""
07:47:27 <lambdabot>  lexical error in string/character literal
07:47:35 <boegel|home> @eval showFFloat Nothing (read "0.001906") ""
07:47:37 <lambdabot> "0.001906"
07:47:41 <xerox> This is cool.
07:47:48 <boegel|home> it is? :|
07:48:16 <thedward> @index showFFloat
07:48:17 <lambdabot> Numeric
07:56:07 <shapr> ProfTeggy: Hey, did you see the comment about your SASL guide?
07:57:10 * boegel|home leaves for a break
07:57:20 <sylvan> @where SASL
07:57:20 <lambdabot> I know nothing about sasl.
07:57:26 <sylvan> bah.. What's SASL?
07:57:57 <shapr> sylvan: http://www.inf.uni-konstanz.de/~grust/SASL/
08:01:13 <shapr> hiya reddi
08:04:22 <reddi> hi ;-)
08:08:56 <shapr> How's code?
08:09:16 * basti_ stretches
08:09:27 <reddi> *hehe*, let me try a bit bevor i will ask ;-)
08:10:39 <basti_> are you new to haskell?
08:10:57 <reddi> i know haskell since a few weeks ;-)
08:11:03 <basti_> ^^
08:21:44 <ProfTeggy> shapr, hi
08:21:51 <ProfTeggy> shapr, a comment... no.
08:21:56 <ProfTeggy> Where? LtU?
08:23:51 <reddi> is there an operator ! in haskell?
08:23:59 <reddi> e.g. 3! = 1*2*3
08:24:31 <psi> no
08:25:02 <reddi> ok, then there is m!/(m-n)! not defined also
08:25:25 <astrolabe> http://lambda-the-ultimate.org/
08:25:41 <astrolabe> Ooops sorry
08:25:50 <astrolabe> reddi: no
08:26:53 <astrolabe> @eval product [5..8]
08:26:54 <lambdabot> 1680
08:28:37 <araujo> Hello!!!!!!!
08:29:02 <ProfTeggy> @eval nub "!!!!!!"
08:29:03 <lambdabot> "!"
08:29:06 <ProfTeggy> ;-)
08:29:13 <psi> :D
08:29:26 <shapr> ProfTeggy: On http://www.nsl.com/k/slack/slack.htm - "In the course of this project, my guide and constant companion has been Torsten Grust's The Construction of an SASL Compiler, a beautifully written introduction to the subject intended for second-year students in computer science."
08:30:06 <ProfTeggy> shapr, ah this one.  Yes, the guy has contacted my some time ago.
08:30:30 <shapr> Stevan has done some nice stuff.
08:30:34 <reddi> http://pastebin.com/412284  what is wrong on line 4?
08:30:45 <ProfTeggy> shapr, oh... I'd love to see that.
08:31:44 <shapr> It requires that you be interested in concatenative languages though :-)
08:32:03 <reddi> that means ?
08:32:10 <ProfTeggy> "concatenative language"
08:32:10 <ProfTeggy> hmm
08:32:20 <shapr> Silly question, how do I sum a bunch of numbers in zsh?
08:32:24 <reddi> or dont u talk to me ?
08:32:26 <psi> @type (/)
08:32:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
08:32:33 <shapr> reddi: Sorry, I was talking to ProfTeggy.
08:32:47 <reddi> ok, no problem
08:33:16 <psi> if you want an int, use `div`
08:33:34 <reddi> i see, ok thx
08:35:47 <astrolabe> maybe use product [m-n+1..m]
08:36:28 <astrolabe> hmm
08:36:43 <astrolabe> @eval [8..7]
08:36:44 <lambdabot> []
08:37:03 <psi> @eval product []
08:37:04 <astrolabe> :) yeah that should work
08:37:05 <lambdabot> 1
08:39:21 <araujo> @index longjmp
08:39:21 <lambdabot> bzzt
08:39:26 <araujo> @index setjmp
08:39:26 <lambdabot> bzzt
08:41:21 <araujo> Anyone knows if there exist some Haskell functions equivalents to those?
08:41:45 <Igloo> throw/catch and friends?
08:41:48 <shapr> To longjmp and setjmp? What about the ContT monad transformer? :-)
08:42:22 <Igloo> I'm not really sure whatyou want to do, though
08:42:56 <reddi> if i enter bigger numbers then i get divide by zero
08:43:00 <reddi> what can i do against that?
08:43:32 <araujo> Igloo, i want to do just the same of longjmp/setjmp
08:43:39 <reddi> http://pastebin.com/412299 something like that
08:43:43 <araujo> shapr, probably.....
08:44:09 <reddi> if i enter 45 over 6 (the probability to get the price in a lottery game in AUSTRIA) then i get an error
08:44:16 <reddi> fak 45 6
08:44:41 <reddi> maybe i should not use integer?
08:44:43 <astrolabe> reddi: line three should be  |n>m = 0?
08:45:22 <psi> reddi: Integer allows arbitrarily large values. Int is restricted.
08:45:51 <astrolabe> reddi: Also it would be better to use product [m-n+1..m]
08:46:00 <psi> yeah..
08:46:41 <reddi> ok, i will be back in an hour, phone, thx for now
08:46:57 <astrolabe> And most lotteries are computed by combinations, not permutations
08:48:31 <SamB> hmm, I just blew up GHCs brain...
08:48:39 <SamB> better go do what I'm supposed to be doing...
08:49:27 <shapr> hiya CosmicRay, ltns
08:50:27 <CosmicRay> morning shapr
08:50:30 <CosmicRay> indeed
08:51:28 <shapr> Wassup?
08:51:43 <CosmicRay> starting on HWN early this week ;-)
08:51:51 <CosmicRay> also, I hate hsql
08:51:53 <shapr> CosmicRay: Silly question, can you think of a good way to stick together a kinesis keyboard and a TC1100 in such a way that they site on your lap?
08:51:57 <shapr> What did hsql do?
08:52:02 <shapr> @seen krasimir
08:52:03 <lambdabot> I haven't seen krasimir.
08:52:14 <CosmicRay> shapr: I don't know what a kinesis keyboard is, but I own a tc1100.  nice machine.
08:52:30 <shapr> CosmicRay: kinesis - http://www.kinesis-ergo.com/advantage.htm
08:52:49 <CosmicRay> shapr: well, besides the things I've complained about before (loading the entire result set into RAM after a query but before any rows are fetched, buggy escape handling, no support for prepared queries), it also appears to have memory leaks.
08:53:11 <CosmicRay> shapr: hmm.  looks like it would be hard to fit both on a lap.
08:53:32 <shapr> Sounds like HSQL needs help.
08:53:38 <CosmicRay> shapr: so when I get the time at some point, I plan to write my own hsql.
08:53:42 <vegai> happy hacking mk2 fits on any lap
08:53:42 <shapr> cool!
08:53:51 <astrolabe> saw it in half and glue one half to each leg
08:53:52 <CosmicRay> actually I've started with it a bit.  I'll base it on Perl's DBI.
08:53:53 <shapr> vegai: Yeah, but Kinesis makes happy hands.
08:54:08 <shapr> CosmicRay: I want something that will sit nicely under HaskellDB
08:54:10 <CosmicRay> shapr: so do you own the tc1100 already?
08:54:20 <CosmicRay> shapr: this should work even nicer than hsql
08:54:25 <shapr> No, I don't. I'm looking for a laptop I can combine with a kinesis keyboard though.
08:54:27 <CosmicRay> I'm calling it HDBC for the moment ;-)
08:54:34 <shapr> Sounds good.
08:54:38 <CosmicRay> shapr: the tc1100 truly does kick ass.
08:54:53 <CosmicRay> I use to take notes in class.
08:54:57 <Oejet> Maybe gambling is illegal in Austria?
08:54:57 <CosmicRay> and linux works reasonably well.
08:55:16 <CosmicRay> I haven't gotten suspend-to-ram to work yet but swsusp2 works.
08:56:13 <Peach44> Hello all
08:56:27 <vegai> 'ello, mate
08:56:27 <astrolabe> hi
08:56:39 <Oejet> Peach44: Hello.
08:56:45 <CosmicRay> shapr: the cpu and hdd speed are, as you might expect, not stellar, but they do just fine
08:56:52 <Peach44> Having a little problem with Haskell
08:56:56 <Peach44> keep getting the message: ERROR - Garbage collection fails to reclaim sufficient space
08:57:09 <vegai> which implementation?
08:57:11 <shapr> CosmicRay: I just want something I can use on the bus, etc
08:57:27 <Peach44> anyone have any ideas what could be causing it ?
08:57:46 <CosmicRay> shapr: http://changelog.complete.org/search/node/tc1100
08:58:00 <astrolabe> Peach44: It is quite easy unless you are careful
08:58:13 <Peach44> how do you mean ?
08:58:29 <astrolabe> Peach44: You can make huge data-structures by mistake
08:58:38 <Peach44> yes
08:58:41 <Peach44> i think thats what it is
08:58:50 <Peach44> a am creating a really big List
08:59:09 <Peach44> i'm guessing that the list is a little too big for Haskell to handle ?
08:59:11 <CosmicRay> shapr: it's small, sturdy, and has a touchscreen.  hard to beat that.  I like small laptops.  this one is about as small as one could possibly get and still be large enough for a detachable keyboard and 1024x768 screen.
08:59:15 <CosmicRay> s/detachable//
08:59:20 <CosmicRay> (but the keyboard can detach)
08:59:24 <astrolabe> Peach44: Maybe you don't need such a big list though.
08:59:43 <Peach44> hmm
08:59:44 <shapr> I wish I could find a laptop that was not designed to include keyboard and screen. I'd much rather have just a small and portable cpu and battery combination, and attach my own display and input devices.
08:59:58 <astrolabe> Peach44: What are you trying to do?
09:00:11 <CosmicRay> shapr: hm.
09:00:14 <shapr> CosmicRay: Ever heard of such a thing?
09:00:15 <Peach44> I'm creating a list of items... which are then parsed and output
09:00:19 <Peach44> which is then*
09:00:36 <CosmicRay> shapr: there is a vague recollection stirring somewhere, but I can't really remember.
09:00:45 <astrolabe> Peach44: Maybe you can create it as it is needed.
09:00:47 <Peach44> do you want to see a copy of the code (it'll make little sense most probably)
09:00:53 <astrolabe> @paste
09:00:54 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:00:56 <Peach44> ok
09:00:58 <CosmicRay> shapr: though without the keyboard the tc1100 is pretty darn thing.  not much bigger than the display itself and probably 1/3" thick.
09:01:09 <CosmicRay> s/thing/thin/
09:01:22 <CosmicRay> shapr: the keyboard adds only a little thickness
09:01:41 <CosmicRay> the trouble with using it with a different keyboard on your lap will be getting it propped up at a useful angle.
09:01:45 <astrolabe> Peach44: Someone (shapr) told me to try to write the code to work on an infinite list.
09:01:52 <pesco> Good day all.
09:02:20 <astrolabe> by pesco
09:02:22 <astrolabe> *bye
09:02:24 <CosmicRay> shapr: unlike most laptops, on this one, all the "guts" are in the screen side, so if you do use it with the internal keyboard, the keyboard is on your lap and the screen (plus the cpu, hdd, etc.) is flipped up.
09:02:35 <CosmicRay> perhaps if you keep the internal keybaord and silde it under your external one for balance.
09:02:41 <pesco> astrolabe: Hm, that was meant as a greeting. :)
09:02:49 <CosmicRay> I dunno, for me, I'd just use the internal keyboard.
09:03:00 <Peach44> http://pastebin.com/412324
09:03:02 <Peach44> thats the paste
09:03:03 <astrolabe> pesco:  LOL
09:03:15 <Peach44> the highlighted bit is the list creation
09:03:36 <Peach44> the bit directly below the highleted section (processStack) is the bit which parses the stack
09:04:51 <kala> when I look at the tree examples in the textbook, there is definitions like "data Tree a = Leaf a | Branch (Tree a) (Tree a)", but there are no definition of Leaf or Branch. What does those mean?
09:05:12 <shapr> kala: Leaf and Branch are constructors.
09:05:18 <shapr> @wiki HaskellDemo check this out
09:05:18 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo check this out
09:05:27 <kala> ok
09:06:46 <astrolabe> Peach44: Sorry, I've hurt my back and have to have a lie-down.  Could someone else look at Peach's code please.
09:08:15 <kala> shapr: so, if I want to have many branches, I define data Tree a = Leaf a | Branch
09:08:38 <kala> data Tree a = Leaf a | Branch [Tree a] ?
09:14:14 <Peach44> if its a binary tree: data Tree a = Empty | Leaf a | Branch (Tree a) a (Tree a)
09:14:33 <shapr> Peach44: You don't need the leaf
09:14:48 <shapr> Peach44: "Branch Empty a Empty" is the same thing
09:18:01 <Peach44> how would you get sub trees then ?
09:18:10 <Peach44> ohh.. sorry mis read
09:22:24 <ProfTeggy> Bye all!
09:30:14 <vincenz> shapr: Hi!
09:30:17 <vincenz> shapr: been a while
09:30:18 <shapr> hiya
09:30:20 <shapr> yup
09:30:22 <shapr> What's up?
09:30:26 <vincenz> nothiing much
09:30:32 <vincenz> thinking of making my own language ;)
09:30:36 <shapr> Good idea
09:31:09 <vincenz> sarcasm?
09:31:27 <shapr> vincenz: No, I'm serious. It's a great way to learn about languages.
09:31:31 <shapr> I want to make my own also.
09:31:31 <vincenz> ah heh
09:31:36 <ndm> hoogle is now in beta! http://haskell.org/hoogle/ - comments welcome
09:31:48 <vincenz> I want to make a language ala merd, but I don't agree with most decisions
09:31:58 <vincenz> basically, statically typed full OO language
09:32:02 <vincenz> using a ruby like syntax
09:32:07 <vincenz> and a haskell like type system
09:32:18 <shapr> vincenz: Seen Scala?
09:32:33 <vincenz> shapr: yeah
09:32:39 <vincenz> shapr: doesn't quite cut it tho
09:32:46 <shapr> Seen Fortress?
09:32:48 <vincenz> doesn't seem to have higher order types
09:32:52 <vincenz> hmm
09:32:54 <vincenz> not that one no
09:32:56 <shapr> Yeah, I like higher order types too.
09:33:04 <vincenz> like monands and such
09:33:09 <vincenz> don't think that would be possible with scala
09:33:24 <vincenz> and I want static by default and polymorphism by explicit choice
09:33:53 <vincenz> most times, even in dynamic languages, big containers are monomorphic
09:35:32 <kala> this http://www.haskell.org/hawiki/HaskellDemo is not entirely valid code? The "
09:35:45 <kala> In the "data People = Person Name Age", Person is not defined?
09:35:46 <vincenz> merd is quite neat, but it makes some odd choices I would not make
09:35:48 <Peach44> is there a function in the prelude that can create a random number between limits ?
09:36:03 <vincenz> kala: Person is a data Constructor
09:36:06 <vincenz> kala: you define it there
09:36:26 <kala> vincenz: huh. how come that I haven't learned all that yet
09:36:49 <vincenz> kala: no idea
09:37:35 <Peach44> anyone know of a random number gen ?
09:37:48 <vincenz> Peach44: how random?
09:38:52 <thedward> Peach44: not in the prelude, I don't think, but check out the Random module (http://haskell.org/onlinereport/random.html)
09:38:59 <mwc> shapr: you aware of any cool voodoo in Scala that isn't apparent from the quick look on Wikipedia?
09:39:10 <mwc> Looks somewhat interesting but I don't see anything too new or spectacular
09:39:20 <Peach44> so import Random ?
09:39:54 <mwc> Mersenne Twisters are supposed to be pretty fast and relatively easy to implement
09:40:05 <mwc> if you need something with pretty high quality randoms
09:40:21 <Peach44> just need to generate a random number between 1 and 3 a few times
09:40:31 <shapr> mwc: Not really, just heard it's cool.
09:40:51 <mwc> I imagine that Haskell's Random is built on top of the system's, and that one's not even usable as a PRNG half the time
09:41:13 <shapr> I think Random is its own PRNG.
09:41:33 <Peach44> so easiest way to accomplish it ?
09:41:40 <shapr> Whatever happened to Posix.popen from GHC 6.2? Is it System.Posix somewhere?
09:42:47 <shapr> mwc: I think Scala claims to bring the cool FP stuff to a more comfortable syntax, and includes OO features.
09:42:58 <shapr> I guess you don't need Scala if Haskell is comfy.
09:43:58 <vincenz> shapr: not as far as one would hope, however ;?
09:44:04 <mwc> Yeah, well, I finally broke myself of OO
09:44:12 <mwc> now I'm learning to eat with a fork
09:44:44 <SamB> @doc System.Random
09:44:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
09:44:48 <Lemmih> Hi SyntaxNinja.
09:44:50 <vincenz> btw
09:44:55 <vincenz> are you allowd to use hoogle as name?
09:45:02 <vincenz> isn't that name-right infringement?
09:45:29 <SamB> vincenz: "trademark"?
09:45:35 <vincenz> yeah
09:45:37 <mwc> vincenz: do you work for google?
09:45:37 <vincenz> that thing
09:45:43 <vincenz> mwc: does it matter?
09:45:44 <mwc> I think the lambda makes it sufficiently differnt
09:45:56 <vincenz> mwc: everyone who sees that name will associate it witih google
09:46:06 <SamB> vincenz: well, if you do, you'd probably be like "oh, cool", rather than "we are so gonna sue you"
09:46:15 <mwc> Yeah, and the colors and page design don't help :P
09:46:21 <vincenz> google, froogle, hoogle
09:46:26 <mwc> I agree, until we get a C&D from google, who cares?
09:46:35 <vincenz> i iguess
09:46:43 <mwc> vincenz: that's hoog{\lambda}e
09:46:47 <mwc> :P
09:46:49 <vincenz> yeah yeah
09:46:57 <vincenz> any layman will say hoogle
09:46:57 <mwc> Could always cahnge the name to that if Google does send a letter
09:47:24 <SyntaxNinja> 'morning
09:47:26 <shapr> Yeah, we can call it fuug{\lambda}e
09:47:34 <shapr> hiya SyntaxNinja
09:47:39 <vincenz> shapr: yeah and have problem with the drinks ;)
09:47:59 <SamB> vincenz: but hoogle doesn't compete with drinks
09:48:15 <shapr> drinks?
09:48:37 <SyntaxNinja>  Fugle \Fu"gle\, v. i.
09:48:38 <SyntaxNinja>      To maneuver; to move hither and thither. [Colloq.]
09:48:38 <SyntaxNinja>      [1913 Webster]
09:48:38 <SyntaxNinja>            Wooden arms with elbow joints jerking and fugling in
09:48:38 <SyntaxNinja>            the air.
09:48:41 <mwc> shapr: just bust out some crazy scandanavian double vowels
09:48:53 <shapr> Right, good idea.
09:48:59 <shapr> wow, cool word.
09:49:01 <mwc> Huugaa\lambda
09:49:51 <SyntaxNinja>  flugelhorn \flugelhorn\, flugelhorn \fl["u]gelhorn\[from German
09:49:51 <SyntaxNinja>      fl["u]gelhorn.] n.
09:49:51 <SyntaxNinja>      A brass wind instrument resembling a cornet but with a wider
09:49:51 <SyntaxNinja>      bore, and having three valves.
09:50:53 <SamB> hmm, hoogλe doesn't look very nice here...
09:51:19 <SamB> well, maybe its okay.
09:51:23 <vincenz> flugel
09:51:35 <SamB> but thats a font issue, I guess, anyways...
10:03:09 <DukeDave> pete :)
10:04:03 <shapr> hiya peteog
10:04:14 <peteog> DukeDave Dave :)
10:04:43 <peteog> shapr, hi
10:04:45 <DukeDave> ahh hey shapr, I was just telling pete about my list comprehension test :)
10:04:55 <shapr> Oh, you had a test?
10:05:06 <DukeDave> only the one you gave me :)
10:05:28 <shapr> Oh, I'd call that a tutorial, but hey...
10:05:35 <shapr> If it was a test, you passed.
10:05:35 <peteog> haha :)
10:05:40 <DukeDave> nice
10:05:59 <xerox> @eval Data.Map.empty
10:06:00 <lambdabot>  Not in scope: `Data.Map.empty'
10:06:08 <xerox> No map in @eval, how boring?
10:06:41 <shapr> xerox: You could add a patch to import some 'safe' modules?
10:07:07 <peteog> DukeDave, I wonder If Dave Smallwood knows about this channel?
10:07:09 <DukeDave> @eval reverse "peteog"
10:07:10 <lambdabot> "goetep"
10:07:22 <xerox> shapr: that's an indea..
10:07:28 <DukeDave> it wouldn't surprise me if he is idling in here :)
10:07:33 <peteog> yeah
10:07:43 <peteog> so have you just been coding all day?
10:07:47 <xerox> Another question.  In Monad you specify how things go in return and bind.  Where do you do that in Arrow?
10:07:50 <shapr> @google dave smallwood
10:07:52 <lambdabot> http://endo.sandia.gov/2741/personnel/smallwood/
10:08:07 <xerox> Ah-uhm, gotcha, in the instance, which implements (***) (&&&) (>>>) and such.
10:08:21 <DukeDave> did I tell you he showed me some of the code where he has started reimplementing java5 modules in a functional paradigm... its nuts!
10:08:42 <DukeDave> heh, its bot heaven in here :)
10:08:46 <peteog> yeah that sounded mental :)
10:08:52 <peteog> he really doesnt like OO :)
10:08:54 <shapr> Who is this guy?
10:09:33 <shapr> He sounds interesting.
10:09:34 <peteog> he is our (DukeDave and I's) lecturer  for the Haskell module
10:09:50 <DukeDave> oh shapr, that's not him btw!
10:09:51 <shapr> Which college?
10:09:55 <DukeDave> (the google link
10:10:10 <peteog> shapr, http://www.cse.dmu.ac.uk/~drs/
10:11:12 <shapr> Neat stuff on his page.
10:11:31 <DukeDave> shame he doesn't have a link to his java reimplementations
10:11:38 <shapr> Cool, he links to the HaWiki and Ward's Wiki.
10:13:19 <shapr> Yeah, he should show up here :-)
10:13:31 <SamB> that sounds fun
10:13:52 <kala> ok, I copied some data definitions from http://www.haskell.org/hawiki/HaskellDemo to http://pastebin.com/412397, but I'm getting "ERROR "calc_tree.hs":12 - Syntax error in data type definition (unexpected `{', possibly due to bad layout)". Whats wrong?
10:14:48 <mauke> you need a constructor name there
10:15:46 <kala> in the front of "{" ?
10:16:46 <kala> hmm ... yes, this works. In that case there is error in HaskellDemo?
10:17:39 <thedward> @eval M.empty
10:17:40 <lambdabot> Add a type signature
10:17:47 <lisppaste2> DukeDave pasted "uni exercise - comments?" at http://paste.lisp.org/display/13085
10:17:53 <thedward> @eval M.empty::Map
10:17:54 <lambdabot>  Not in scope: type constructor or class `Map'
10:18:18 <xerox> @type empty
10:18:19 <DukeDave> if anyones bored - I'm pretty sure this is an ugly way to do this... comments? :)
10:18:19 <lambdabot> Not in scope: `empty'
10:18:38 <xerox> DukeDave: 'this' being what?
10:19:05 <DukeDave> ^ that paste.lisp
10:19:05 <thedward> @type M.empty
10:19:06 <lambdabot>   Failed to load interface for `M':
10:19:06 <lambdabot>    Could not find module `M':
10:19:16 <thedward> @type Map.empty
10:19:17 <lambdabot>   Failed to load interface for `Map':
10:19:17 <lambdabot>    Could not find module `Map':
10:19:25 <SamB> @type Data.Map.empty
10:19:27 <lambdabot> forall a k. Data.Map.Map k a
10:19:34 * boegel|home is back
10:19:42 <SamB> @plugs Data.Map.empty
10:19:43 <lambdabot>  Not in scope: `Data.Map.empty'
10:20:17 <boegel|home> suppose I have a list of type [[Float]], and I need to compute the average of all 1st elements, all 2nd elements, and so on...
10:20:22 <boegel|home> any tips ?
10:20:28 <SamB> @eval M.empty::M.Map
10:20:29 <lambdabot>   `Data.Map.Map' is not applied to enough type arguments
10:20:29 <lambdabot>   Expected kind `?', but `Data.Map.Map' has kind `* -> * -> *'
10:20:29 <lambdabot>   In an expression type signature: Data.Map.Map
10:20:47 <SamB> @eval M.empty::M.Map Int Int
10:20:49 <lambdabot> {}
10:21:34 <mauke> @type map average . transpose
10:21:35 <lambdabot> Not in scope: `average'
10:21:35 <lambdabot>  
10:21:35 <lambdabot> <interactive>:1:14: Not in scope: `transpose'
10:21:35 <boegel|home> blah [ [0,3,6], [3,6,9], [6,9,12] ] = [3,6,9]
10:21:43 <mauke> @type map average . List.transpose
10:21:44 <lambdabot> Not in scope: `average'
10:21:48 <boegel|home> @index average
10:21:49 <lambdabot> bzzt
10:21:50 <mauke> heh, ok
10:21:57 <DukeDave> boegel, I'll be able to tell you in 2 weeks :)
10:22:00 <mauke> you'll have to write it yourself
10:22:01 <boegel|home> @type List.transpose
10:22:02 <lambdabot> forall a. [[a]] -> [[a]]
10:22:15 <boegel|home> mauke: what does transpose do ?
10:22:20 <SamB> @eval transpose [[1,2], [3,4]]
10:22:21 <lambdabot> [[1,3],[2,4]]
10:22:22 <astrolabe> @index mean
10:22:23 <lambdabot> bzzt
10:22:33 <boegel|home> @eval transpose  [ [0,3,6], [3,6,9], [6,9,12]
10:22:34 <lambdabot>  parse error on input `}'
10:22:40 <boegel|home>  [ [0,3,6], [3,6,9], [6,9,12] ]
10:22:43 <mauke> @eval transpose [ [0,3,6], [3,6,9], [6,9,12] ]
10:22:43 <boegel|home> grr
10:22:44 <lambdabot> [[0,3,6],[3,6,9],[6,9,12]]
10:22:55 <boegel|home> doesn't do shit ? :)
10:23:21 <astrolabe> @buckYourIdeasUp
10:23:21 <lambdabot> Unknown command, try @listcommands.
10:23:31 <DukeDave> heh
10:23:32 <boegel|home> it's probably a bad example list :)
10:23:32 <mauke> @eval transpose [ ["a1","a2","a3"], ["b1", "b2", "b3"] ]
10:23:33 <lambdabot> [["a1","b1"],["a2","b2"],["a3","b3"]]
10:23:37 <SamB> boegel|home: no, your list is symettrical about the diagonal
10:23:39 <boegel|home> yeah, thought so
10:23:58 <DukeDave> that was a wonderfuly bad example of a matrix transpose ;)
10:24:08 <boegel|home> nice trick... should be quite easy then
10:24:27 <boegel|home> @eval map sum $ transpose [ [0,3,6], [3,6,9], [6,9,12] ]
10:24:29 <lambdabot> [9,18,27]
10:24:33 <SamB> @eval transpose [[], [1], [2,3]]
10:24:34 <lambdabot> [[1,2],[3]]
10:24:52 <DukeDave> that is a good trick...
10:24:56 * DukeDave remembers
10:24:58 <boegel|home> @eval map ((\x -> x/3) $ sum) $ transpose [ [0,3,6], [3,6,9], [6,9,12] ]
10:24:59 <lambdabot>  add an instance declaration for (Fractional ([a] -> a))
10:24:59 <lambdabot>   In a lambda abstraction: \ x -> x / 3
10:25:30 <xerox> @eval map ((/3).fromIntegral.sum) $ transpose [ [0,3,6], [3,6,9], [6,9,12] ]
10:25:32 <lambdabot> [3.0,6.0,9.0]
10:25:42 <boegel|home> @eval map (`div` 3) $ map sum $ transpose [ [0,3,6], [3,6,9], [6,9,12] ]
10:25:44 <lambdabot> [3,6,9]
10:25:50 <boegel|home> xerox: :o)
10:26:05 <xerox> map f (map g xs)  =~=  map (f . g) xs
10:26:09 <SamB> @eval let average xs = sum xs / length xs in map average $ transpose [[1], [2,3]]
10:26:10 <lambdabot>  add an instance declaration for (Fractional Int)
10:26:10 <lambdabot>   In the definition of `average': average xs = (sum xs) / (length xs)
10:26:10 <lambdabot>   In the definition of `xxxx':
10:26:11 <boegel|home> I admit, div won't work with floats, but hey
10:26:25 <SamB> @eval let average xs = sum xs / length xs in map average $ transpose [[1.0], [2,3]]
10:26:26 <lambdabot>  add an instance declaration for (Fractional Int)
10:26:26 <lambdabot>   In the list element: 1.0
10:26:26 <lambdabot>   In the list element: [1.0]
10:26:26 <boegel|home> @eval map (`div` 3 . sum) $ transpose [ [0,3,6], [3,6,9], [6,9,12] ]
10:26:27 <lambdabot> Couldn't match `[a] -> c' against `[a1]'
10:26:45 <boegel|home> @eval map ((`div` 3) . sum) $ transpose [ [0,3,6], [3,6,9], [6,9,12] ]
10:26:46 <lambdabot> [3,6,9]
10:26:48 <SamB> @eval let average xs = sum xs / length xs in map average $ transpose ([[1], [2,3]] :: [[Float]])
10:26:49 <lambdabot> Couldn't match `Int' against `Float'
10:26:58 <SamB> @eval let average xs = sum xs / length xs in map average $ transpose ([[1.0], [2.0,3.0]] :: [[Float]])
10:26:59 <lambdabot> Couldn't match `Int' against `Float'
10:27:06 <SamB> thats freaky!
10:27:09 <boegel|home> anyway, thanks, the transpose bit helped me a lot :)
10:28:09 <SamB> @index unsafeCoerce
10:28:10 <lambdabot> bzzt
10:32:51 <thedward> @eval let average xs = sum xs / genericLength xs in map average $ transpose ([[1.0], [2.0,3.0]] :: [[Float]])
10:32:52 <lambdabot> [1.5,3.0]
10:32:58 <thedward> @eval let average xs = sum xs / genericLength xs in map average $ transpose ([[1.0], [2.0,3.0]] )
10:32:59 <lambdabot> [1.5,3.0]
10:33:48 <thedward> @type length
10:33:49 <lambdabot> forall a. [a] -> Int
10:33:52 <xerox> @pl \f x = f x x
10:33:53 <lambdabot> (line 1, column 6):
10:33:53 <lambdabot> unexpected "="
10:33:53 <lambdabot> expecting pattern or "->"
10:33:56 <thedward> @type genericLength
10:33:57 <lambdabot> Not in scope: `genericLength'
10:33:59 <xerox> @pl \f x -> f x x
10:34:00 <lambdabot> join
10:34:06 <xerox> @type List.genericLength
10:34:08 <lambdabot> forall i b. (Num i) => [b] -> i
10:34:09 <thedward> @type List.genericLength
10:34:09 <lambdabot> forall i b. (Num i) => [b] -> i
10:35:47 <ndm> @seen dons
10:35:47 <lambdabot> dons is in #haskell-overflow and #haskell. Last spoke 6 hours, 44 minutes
10:35:47 <lambdabot> and 12 seconds ago.
10:37:30 <dcoutts> @seen gour
10:37:30 <lambdabot> I saw gour leaving #haskell 3 hours, 25 minutes and 49 seconds ago.
10:49:41 <gour> dcoutts, ping
10:59:47 <shapr> hiya zacch, learning Haskell?
11:00:27 <Muad_Dibber> Who in here isn't learning Haskell?
11:01:16 <zacch> hi shapr, did a functional programming class in ony one year ago and used it for that
11:01:25 <shapr> Cool, how did you like it?
11:01:50 <zacch> shapr: nothing fancy though, they did not go very deeply into Monads, taught a bit of (untyped) lambda calculus though
11:02:01 <zacch> I learned Monads mostly from Phil Wadler's papers
11:02:26 <shapr> That's a good place to pick it up, he was the one who connected Moggi's work to Haskell.
11:03:03 <zacch> shapr: I liked it very much. Wadler once asked about what the "killer application" of functional programming would be - I'd argue it is easy "teachability"
11:03:31 <zacch> I don't know why there are so many classes about Java these days.
11:03:33 <reddi> how do i transform Int into Integer?
11:03:46 <shapr> I often change my mind about the killer application of FP. The last week or so I've thought it's the ability to analyse everything ahead of time.
11:03:52 <reddi> u said a few hours ago that integer has a bigger range
11:04:02 <zacch> reddi: fromInt ?
11:04:05 <shapr> reddi: You can use fromIntegral
11:04:10 <zacch> ah yes, that was it
11:05:25 <dcoutts> gour, pong
11:06:02 <gour> dcoutts, how is your class?
11:06:11 <dcoutts> gour, pretty good thank you
11:06:18 <joelr> how would you implement computations that can timeout?
11:06:21 <gour> dcoutts, congrats
11:06:26 <dcoutts> thanks
11:06:41 <dcoutts> it's running for the next 4 weeks, so we'll see how it goes
11:06:41 <gour> dcoutts, have you seen my msg that i'm on gnome desktop?
11:06:49 <dcoutts> gour, yes
11:06:57 <gour> dcoutts, it's cool :-)
11:07:24 <gour> dcoutts, however, after emerging gamin, i wanted to have inotify in the kernel and upgraded to 2.6.14
11:07:34 <dcoutts> joelr, using a thread, forkIO, threadDelay and throwTo
11:07:37 <joelr> like say connecting to a server or reading from a socket
11:07:38 <gour> dcoutts, but this is a problem
11:07:44 <joelr> dcoutts: i thought so, thanks
11:08:08 <dcoutts> gour, the gentoo-sources kernels have the inotify patch
11:08:12 <gour> dcoutts, 1st, newer kernels do not create nvidia dev nodes, than 2.6.14. cannot compile nvidia driver
11:08:24 <gour> dcoutts, which one?
11:08:29 <joelr> dcoutts: what does throwTo do if the thread is already gone?
11:08:50 <dcoutts> gour, I'm using 2.6.12-gentoo-r10
11:08:57 <gour> dcoutts, i didn't know that, i.e. gamin ebuild told me i missing it
11:09:14 <dcoutts> joelr, holding onto the ThreadId keeps the thread alive so you can throwTo
11:09:43 <joelr> dcoutts: right, but what if it's already done, i.e. connected to the server, read from the socket, etc
11:10:01 <dcoutts> joelr, however if the thread has finnished runing then I expect that throwing an exception to it does nothing
11:10:10 <joelr> dcoutts: aha
11:10:32 <gour> dcoutts, i went from  12 --> 14 and now i have to use xorg's nv driver :-(
11:10:53 <gour> dcoutts, anyway, no need for the graphic speed atm ;)
11:10:59 <joelr> dcoutts: and i guess to detect that the thread has done its job i would need to sleep in small delays and poll some MVar, right? for a total cumulative sleep time that i need
11:11:01 <dcoutts> gour, you could try the latest stable gentoo-sources
11:11:25 <gour> dcoutts, i'm on ~amd64, when will gtk2hs come out?
11:11:36 <dcoutts> gour, today
11:11:56 <dcoutts> gour, you tested the latest release candidate right?
11:12:21 <gour> huh, your 2nd shift can finish pretty late :-) yes, i tested it
11:12:45 <dcoutts> joelr, well you can fork two threads, one to sleep and the other to run the computation
11:13:11 <gour> dcoutts, gnome really looks nice and i'm even more inspired to work (in the future) on libgda/libgnome
11:13:15 <joelr> dcoutts: and use something like STM to wait on the two?
11:15:49 <dcoutts> joelr, I've pasted a version, see it?
11:16:01 <dcoutts> gour, cool
11:16:15 * dcoutts goes back to dealing with the Gtk2Hs 0.9.10 release
11:16:52 <joelr> dcoutts: yes, thanks!
11:17:18 <gour> dcoutts, all the best in providing new release
11:17:52 <gour> dcoutts, i'm going to try to solve some exercise from 14th chapter, as long as there is still some power in my brain :-)
11:18:32 <reddi> http://pastebin.com/412463  how do i tel pascalLine to make a list of the values of the function fak x y and x is going from 0 to y and y is constant
11:18:47 <basti_> huh?
11:18:53 <reddi> maybe someone is understanding my (bad formulated) question ;-)
11:18:59 <basti_> yes maybe.
11:19:05 <reddi> do you?
11:19:16 <basti_> not really
11:19:36 <basti_> do you want to implement faculty?
11:19:52 <reddi> i did it already ;-)
11:20:14 <joelr> dcoutts: why do you have deepSeq if you don't need it?
11:20:27 <basti_> soooo? ^^
11:21:13 <reddi> if i enter pascalLine 4 then i want a list with the values [1, 4, 6,4, 1] - it is the same as if i would call fak 0 4, fak 1 4, fak 2 4, fak 3 4, fak 44
11:21:21 <reddi> do u understand the question now?
11:21:22 <basti_> ah
11:21:23 <basti_> yes
11:21:28 <basti_> maybe something like:
11:21:31 <reddi> ok, and how do i implement that?
11:21:49 <basti_> hmm
11:21:55 <basti_> like:
11:22:28 <basti_> @eval zipWith (+) [1..10] (repeat 12)
11:22:29 <lambdabot> [13,14,15,16,17,18,19,20,21,22]
11:22:32 <basti_> maybe?
11:23:24 <reddi> one moment, maybe i can adapt that
11:23:46 <basti_> (+) is + in prefix
11:23:49 <basti_> so you don't need parens
11:25:55 <dcoutts> joelr, we needed it for the program I took that code from.
11:26:10 <joelr> dcoutts: ok, thanks
11:30:45 <joelr> dcoutts: what type of app was that if you don't mind my asking
11:30:51 <basti_> reddi: in case of further language problems, i think time has come to create a #haskell.de for discussions in german
11:30:59 <joelr> i wonder what kind of heavily-threaded apps are actually written in haskell
11:31:30 <reddi> basti: hehe, why do u know that i am german ;-)?
11:31:34 <reddi> basti_: it works ;-)
11:31:47 <Philippa_> joelr: the IRC client I'm working on is ending up with a reasonably high thread count
11:31:54 <basti_> reddi: because your tld gives away that you're chatting from austria?
11:31:56 <Philippa_> it's a fairly natural way to model the info+control flow in it
11:32:48 <joelr> i saw some very funky behavior when launching two threads from ghci. both threads print to stdout (putStrLn) and i actually had to press enter in ghci to see some output
11:32:51 <joelr> wonder why that was
11:36:37 <basti_> @hoogle Integer -> Int
11:36:39 <lambdabot> Text.Regex.Posix.regExtended :: Int
11:36:39 <lambdabot> Text.Regex.Posix.regIgnoreCase :: Int
11:36:39 <lambdabot> Text.Regex.Posix.regNewline :: Int
11:36:44 <basti_> -.-
11:36:59 <xerox> Hoogle back again!
11:37:02 <xerox> @docs Data.List
11:37:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
11:37:07 <xerox> The fix is there too, woo.
11:37:10 <xerox> @karma+ dons
11:37:11 <lambdabot> dons's karma raised to 14.
11:38:03 <basti_> @hoogle Integer->Int
11:38:04 <lambdabot> Text.Regex.Posix.regExtended :: Int
11:38:04 <lambdabot> Text.Regex.Posix.regIgnoreCase :: Int
11:38:04 <lambdabot> Text.Regex.Posix.regNewline :: Int
11:38:09 <basti_> this is broken.
11:39:34 <thedward> @hoogle a b -> b [ a ]
11:39:35 <lambdabot> Prelude.id :: a -> a
11:39:35 <lambdabot> Data.Graph.Inductive.Monad.nodesM :: GraphM m gr => m (gr a b) -> m [Node]
11:39:35 <lambdabot> Data.Graph.Inductive.Monad.edgesM :: GraphM m gr => m (gr a b) -> m [Edge]
11:39:38 <xerox> @hoogle Eq a => a -> a -> Bool
11:39:39 <lambdabot> Prelude.(==) :: Eq a => a -> a -> Bool
11:39:39 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
11:39:39 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
11:40:17 <xerox> @hoogle Functor f => (a -> b) -> f a -> f b
11:40:19 <lambdabot> No matches, try a more general search
11:41:21 <thedward> the integer -> int response is kind of off
11:41:26 <thedward> @type Text.Regex.Posix.regNewline
11:41:27 <lambdabot> Int
11:41:37 <thedward> huh
11:42:09 <dcoutts> joelr, it was a network app actually.
11:42:30 <joelr> dcoutts: what kind
11:42:34 * joelr loves network apps
11:42:40 <joelr> mine is a network app :-)
11:42:48 <joelr> a bring-down-the-server type of network app
11:42:55 <dcoutts> joelr, it was the ICFP '05 competition. The program had to respond to the server within 5 seconds or you'd be disqualified
11:42:57 <joelr> my first haskell project too
11:43:16 <joelr> dcoutts: oh, cool!
11:43:33 <dcoutts> the deepseq was requred so that the complete evaluation of the reply was included in the timout
11:43:42 <joelr> if i wasn't bored with writing poker software i would rewrite it in haskell
11:44:07 <dcoutts> otherwise lazyness might mean that the evaluation was delayed until the message was serialised and written to the network
11:44:19 <dcoutts> and that would have not been counted in the timout
11:44:25 <joelr> dcoutts: cool
11:44:26 <xerox> heh
11:44:37 <dcoutts> so we had to deepseq the message within the timout
11:45:32 <dcoutts> joelr, I was assuming you didn't have quite such strict time limits and so you might not need the deepseq
11:45:36 <joelr> if i rewrote my poker server in haskell that would have given me plenty of food for thought but that would be boring (lisp, then erlang, then haskell)
11:45:47 <joelr> dcoutts: right, i don't have such limits
11:46:23 * joelr is thinking of that next big-pay off project
11:46:32 <joelr> i would surely do it in haskell
11:46:40 <dcoutts> heh, good luck
11:46:50 <joelr> the guts of a game? trading software?
11:47:21 <joelr> i'm supposed to get an RFP for collusion detection in poker today
11:47:26 <joelr> but that's work for hire :(
11:47:51 <dcoutts> hmm, interesting
11:48:07 <joelr> i was thinking of bayesian networks or something
11:48:17 <joelr> since the dazzle people did it
11:48:24 <joelr> hell of a second haskell project, though :D
11:51:53 <wilx`> Collision detection in poker?
11:52:01 <joelr> wilx`: 100%
11:52:22 <wilx`> What is there in poker that can colide?
11:52:33 <tromp> collude
11:52:40 <joelr> my poker software business bombed so i'm doing consulting for poker companies
11:53:06 <joelr> wilx`: people can collude by playing on laptops side by side for example, so that they can see each others cards
11:53:38 <joelr> generally, it's people revealing cards to each other
11:54:09 <C-Keen> re
11:54:45 <wilx`> Hm...
11:55:09 <araujo> Hello!
11:56:48 <dcoutts> ibid, ping
12:10:25 <reddi> @hoogle map
12:10:26 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
12:10:26 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
12:10:26 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
12:12:57 <basti_> reddi:
12:13:02 <basti_> @eval map (+1) [1,2,3,4]
12:13:03 <lambdabot> [2,3,4,5]
12:13:19 <basti_> @eval map toUpper "hI rEdDi"
12:13:21 <lambdabot> "HI REDDI"
12:13:26 <reddi> *LOL*
12:13:41 * SamB thinks Philip Wadler is wrong in thinking that a functional programming language needs a debugger in "Why no one uses functional languages"
12:13:48 <basti_> @eval map (\x->(x+2,"hi reddi")) [7.0,4.3]
12:13:50 <lambdabot> [(9.0,"hi reddi"),(6.3,"hi reddi")]
12:13:54 <basti_> etc
12:14:45 <{Arias}> xD
12:15:36 <basti_> as you can see the input and output types are free.
12:15:41 <SamB> why, probably less than 1% of python or perl users have ever had any success in using the python/perl debugger...
12:15:42 <mikehammad> is anyone familiar with literature that handles recursive types in system F_3?
12:15:53 * basti_ isn't
12:19:54 <SamB> hmm, do people researching language extensions start with an awkward problem?
12:22:04 <dcoutts> @seen ibid
12:22:05 <lambdabot> ibid is in #haskell-overflow and #haskell. I don't know when ibid last
12:22:05 <lambdabot> spoke.
12:33:25 <joelr> dcoutts: ping
12:34:29 <Philippa_> SamB: if all we manage is perl or python's popularity, we've screwed up
12:34:43 <Philippa_> there've been plenty of situations where a debugger would've saved me some effort
12:34:57 <Philippa_> I do rather resent having to either sprinkle print statements of various sorts or build a debugging monad
12:35:37 <SamB> Philippa_: well, true...
12:36:25 <SamB> but he was talking about even *modest* langauge implementations
12:36:35 <SamB> not just wildly audacious
12:36:54 <dcoutts> johs, ']
12:36:59 <dcoutts> oops
12:37:09 <dcoutts> joelr pong
12:37:13 <Philippa_> er, what value of modest?
12:37:17 <dcoutts> oh he's gone
12:37:24 <Philippa_> I mean, where does GHC count on the scale?
12:40:24 <SamB> well, I think it is at least "proud" if not "arrogant"
12:41:40 <franka> Hello.
12:49:39 * shapr boings
12:50:34 <araujo> Hello franka
13:38:11 <xerox> Do you know of any image-mangling libraries for Haskell ?
13:38:19 <shapr> um, yes
13:38:26 <xerox> Hm, cool.. where?
13:38:56 <xerox> I'd love something like "PNG -> MatrixOfRGB"
13:39:18 <shapr> Oh like that... hm
13:39:24 <shapr> Igloo had something for XBM files
13:39:30 <xerox> That's something.
13:39:34 <shapr> bringert wrote a binding to a lib for generating images via CGI
13:39:48 <shapr> Jan somebody from Numeric Quest had some really good code that I can't remember much about.
13:40:36 <xerox> Ooh-kay, thanks.  I'll bug someone of them :-)
13:40:55 <shapr> You can find bringert's project on http://www.bringert.net/projects.html
13:40:59 <wilx`> This Cairo thing doesn't read images?
13:41:19 <xerox> wilx`: it does, but the internal representation is opaque
13:41:29 <wilx`> Ah, I see.
13:42:00 <xerox> Oh, GD..
13:42:02 <wilx`> But you should be able to do getPixel x y or something, maybe?
13:42:04 <wilx`> Ah.
13:42:11 <wilx`> GD is nice, at least in Perl.
13:42:37 <xerox> wilx`: does it let you do that?
13:42:53 <wilx`> Well, I do not know :)
13:43:13 <wilx`> But it seams like it should :)
13:43:22 <wilx`> ..seems logical..
13:43:53 <xerox> bringert's bindings are a little stripped :)
13:53:47 <shapr> hiya poetix
13:55:35 <basti_> shapr: http://www.csounds.com/manual/html/lorenz.html
13:55:48 <basti_> whoops
15:06:39 <dons> @seen ndm
15:06:39 <lambdabot> I saw ndm leaving #haskell-blah and #haskell 3 hours, 2 minutes and 55
15:06:39 <lambdabot> seconds ago.
15:11:17 <shapr> I can't believe it's not butter!
15:11:52 <dons> maybe it *is* butter?
15:13:52 <shapr> hm, good point
15:14:55 <shapr> Who's Koray Can?
15:20:43 <Frederick> hi folks
15:23:20 <SyntaxNinja> hi
15:29:12 <SyntaxNinja> kosmikus:  (or anyone else) who is the HW chair before daan?
15:29:44 <dons> SyntaxNinja, I read in the QuickCheck paper that testing accounts for 50% of the cost of software development, as I've not worked in commerical software, does that figure sound right? Does  galois work even harder on testing?
15:30:05 <dons> (I'm giving a talk on automated testing today)
15:31:20 <SyntaxNinja> dons: Galois puts a huge amount of effort into correctness, but not all of that is in testing.  Other areas are verification; proving program correctness, correct processes, etc.  I can't really estimate how much time galois puts into testing, though.
15:31:37 <dons> SyntaxNinja, hmm I think Manuel was the chair in 2002.. Not sure about 2003 though
15:32:04 <kosmikus> SyntaxNinja: Henrik
15:32:06 <SyntaxNinja> he was my guess for 2003
15:32:17 <dons> Henrik was 2004
15:32:24 <dons> wasn't he?
15:32:33 <kosmikus> Johan, Manuel, Henrik, Daan
15:32:42 <SyntaxNinja> OK
15:32:54 <SyntaxNinja> Johan who?
15:33:11 <kosmikus> oh no, I swapped Manuel and Johan
15:33:17 <kosmikus> Jeuring
15:33:41 <dons> Manuel 2002, Johan 2003, Henrik 2004, Daan 2005
15:34:13 <Frederick> guys does anyone here uses ghc on windows?
15:34:26 <kosmikus> John 97, Erik 99, Graham 2000, Ralf 2001
15:34:33 <dons> Ralf in 2001?
15:34:35 <dons> yes.
15:34:38 <Frederick> how can I compile a given file on windows (im on a linux box trying to help a mate in a windoze box)
15:34:49 * dons doesn't have proceedings back that far :)
15:34:51 <kosmikus> John L., not John H.
15:35:19 <dons> Frederick, I'm pretty sure: ghc --make M.hs works on Windows
15:35:28 <SyntaxNinja> kosmikus, etc. thanks.
15:36:03 <franka> Hey, can I ask your names, kosmikus and SyntaxNinja?
15:36:45 <kosmikus> kosmikus: you know already that I'm Andres :)
15:37:00 <franka> Oh yes, I'd forgotten. :)
15:37:23 <SyntaxNinja> franka: Isaac
15:37:54 <franka> OK, thanks.
15:38:03 <dons> oh, we should have asked @google
15:38:12 <dons> @google Haskell Workshop 2002
15:38:13 <lambdabot> http://www.cse.unsw.edu.au/~chak/hw2002/
15:38:16 <dons> @google Haskell Workshop 2003
15:38:16 <lambdabot> http://www.cs.uu.nl/~johanj/HaskellWorkshop/cfp03.html
15:38:20 <dons> @google Haskell Workshop 2004
15:38:20 <lambdabot> http://www.cs.nott.ac.uk/~nhn/HW2004/
15:38:23 <dons> :)
15:38:36 <SyntaxNinja> which john in '97, ooi?
15:38:43 <shapr> dons: Hey are your QC notes online?
15:38:54 <SyntaxNinja> @google who was the haskell workshop chair in 1997?
15:38:56 <lambdabot> http://www.cse.ogi.edu/~jl/ACM/Haskell.html
15:38:59 <SyntaxNinja> ahh
15:39:03 <dons> shapr, they're being written atm. up in around 6 hrs.
15:39:12 <dons> hehe
15:39:18 <dons> *that* john
15:39:31 <SyntaxNinja> @google how many lines of code does GHC have?
15:39:32 <lambdabot> http://www.haskell.org/tmrwiki/DifferentLanguage
15:39:45 <SyntaxNinja> darn
15:39:48 <dons> 250k
15:41:16 <dons> in fact, here's the code/comment break down for all of $fptools:     TOTAL:              389,773    207,510
15:41:29 <dons> just in ghc/compiler is: 86337  64883
15:41:30 <Frederick> guys the windows box says ghc isnt a recognized command
15:41:46 <dons> ghc + libraries: 229,345 126,685
15:42:06 <dons> Frederick, you sure ghc is installed?
15:42:32 <Frederick> dons, nope since it is on the pc of a classmate
15:42:48 <dons> well, maybe it isn't installed then ;)
15:45:34 <Frederick> dons, ghci seems to work but not ghc she cant compile the files
15:46:49 <dons> what error message?/
15:47:52 <Frederick> dons, "ghc inst recognized as an internal nor external command"
15:48:03 <Frederick> dons, doesnt seem to be on the path
15:54:05 <dons> maybe you can just run it in ghci then? like so:
15:54:12 <dons> $ echo 'main' | ghci M.hs
15:54:12 <dons> yes
15:54:16 <vincenz> what are the equality operators for shallow and deep equality in haskell
15:54:17 <vincenz> ?
15:54:39 <dons> == ?
15:54:46 <vincenz> for both?
15:55:10 <dons> how do you defined shallow and deep?
15:55:23 <vincenz> you don't know the difference?
15:55:29 <SamB> vincenz: there isn't one for shallow equality. what is shallow equality?
15:55:39 <vincenz> SamB: referential equality
15:56:10 <shapr> intensional vs extensional?
15:56:16 <vincenz> not sure about your terminology
15:56:20 <SamB> vincenz: you get that with IORefs and STRefs
15:56:27 <dons> I'm imagining that what kind of equality you get depends on the instance of Eq you're using
15:56:40 <SamB> otherwise, it is unavailable due to referential transparency
15:56:40 <shapr> vincenz: Purely functional usually means you only have values.
15:56:43 <dons> and you're free to define your own instance
15:56:44 <vincenz> shapr: true
15:56:56 <SamB> well, Ptr and ForeignPtr too...
15:57:15 <shapr> vincenz: details here - http://www.haskell.org/tmrwiki/FpVsOo
15:57:16 <dons> oh, is 'deep' here ptr equality?
15:57:41 <SamB> so basically, to test referential equality, you need opaque references.
15:57:57 <vincenz> hmm
15:58:01 <vincenz> alright I'll think on it some more
15:58:38 <SamB> vincenz: what are you trying to do?
15:58:59 <vincenz> SamB: defining my own language
15:59:07 <vincenz> imperative, oo, with haskell type system
15:59:11 <vincenz> and non lazy
15:59:19 <shapr> You may want to try the Language Prototyping System.
15:59:22 <vincenz> something like merd buit somewhat dififerent
15:59:24 <vincenz> shapr: ?
15:59:33 <shapr> @google language prototyping system
15:59:34 <lambdabot> http://lsi.uniovi.es/~labra/LPS/LPS.html
15:59:51 <vincenz> tx
15:59:58 <SamB> vincenz: what good is the type system without laziness or functionality?
16:00:18 <dons> kind of breaks everything, doesn't it
16:00:33 <vincenz> SamB: I will have functional style programming underneath but I want an oo like syntax
16:01:55 <kosmikus> oo-like syntax?
16:02:05 <kosmikus> what's that supposed to mean?
16:02:32 <dons> it means *verbose* ;)
16:02:32 <vincenz> ...
16:02:35 <vincenz> no
16:02:36 <vincenz> it means
16:02:45 <vincenz> x.flatten.zip(o).concat(y)
16:02:47 <vincenz> instead of
16:02:52 <SamB> dons: thats only Java
16:02:56 <vincenz> (concat (zip (flatten x) o) y)
16:03:00 <shapr> dons: Oh, have you seen the verbosity um, flame, on LtU?
16:03:01 <kosmikus> vincenz: you can have that in Haskell
16:03:05 <SamB> vincenz: but that type system is totally different
16:03:16 <vincenz> SamB: no it's not
16:03:20 <vincenz> just syntactic sugare
16:03:22 <vincenz> sugar
16:03:23 <vincenz> mostyl
16:03:38 <vincenz> anyways, there are some other things I want changed, such as non lazyness
16:05:23 <shapr> go for it!
16:05:27 <vincenz> I am
16:05:37 <SamB> that is, like, worse than Python's syntax
16:06:11 <vincenz> it's inspired by ruby
16:06:15 <dons> perhaps we should be more concerned about the type system ;) syntax is the trivial part
16:07:10 <dons> vincenz, why not write a preprocessor to haskell that strictifies and translates your syntax? then you get to keep the type system
16:07:31 <dons> i.e. translates your syntax into strict haskell?
16:07:42 <dons> you'd get that done in a couple of days
16:08:24 <dons> you could operate entirely in unboxed, strict values in fact :)
16:08:32 <dons> it would be super-fast
16:11:38 <dons> have you seen the POPL Mark Challenge for language design?
16:12:30 <vincenz> haskell is by default not strict, no?
16:12:37 <shapr> That's correct.
16:12:41 <vincenz> and define superfaast?
16:13:21 <dons> as fast as C
16:14:19 <dons> I wrote such a `compiler' to haskell in a few days once, and the resulting code was stunningly fast. usually outperforming equivalent C programs (though not with -O3 to gcc)
16:15:39 <dons> vincenz, you might want to read up on unboxed values in haskell
16:16:33 <Igloo> Although hopefully GHC will take care of that without you having to
16:17:32 <dons> not entirely. certainly for normal coding, but as a target for another language, you can kick it along a bit by being explicit
16:18:02 <vincenz> yeah but the fact is, haskell is pervasively lazy
16:18:12 <dons> except in unboxed values, which must be strict ;)0
16:18:45 <dons> you're aware that lazyness simplifies the semantics greatly?
16:19:20 <vincenz> for some problems
16:19:52 <Igloo> I'd have thought you seqing things appropriately would suffice, but perhaps I am being naive  :-)
16:19:55 <vincenz> dynamic typic greatly simplifies codinig too...and yet you use haskell, to every problem there's a proper solution
16:20:00 <vincenz> so please
16:20:02 <vincenz> no golden hammer
16:20:17 <dons> umm... i'm talking about defining language semantics
16:20:21 <vincenz> ye
16:20:29 <vincenz> lazyness is not suitable for all problems
16:20:50 <dons> well, it's a greater burden on you, if you're going to have strict semantics
16:20:57 <dons> more proofs to do
16:21:02 <dons> more rules to write
16:21:05 * vincenz shrugs
16:43:34 <stefanw> dons: do you remember your tiny HUnit bugfix some time ago? I think we introduced a new bug when fixing the old one ;-)
16:45:27 <glguy> You mean HUnit doesnt protect itself from regressions with HUnit?
16:46:20 <glguy> ;)
16:46:28 <dons> stefanw!
16:46:43 <dons> it was a cpp issue, iirc?
16:47:54 <stefanw> yup. And fixing the cpp issue "turned on" another bug because now another part of the code is executed which does not work properly for GHC
16:48:08 <dons> ah.. :/
16:48:21 <dons> and no one has noticed in 6 months?
16:48:31 <dons> does anyone but us used HUnit ?
16:48:37 <shapr> I use my own HUnit sources.
16:48:49 <shapr> Do you have RunTestDots.hs ?
16:48:53 <SamB> so just you three?
16:48:56 <stefanw> good idea, HUnit is not very well written.
16:49:23 <stefanw> no, what's RunTestDots.hs
16:50:42 <shapr> It's a test runner that works like pyunit.
16:50:49 <shapr> It shows ..FE..
16:51:01 <shapr> Just sort of cute.
16:51:02 <stefanw> ah, I use TestTT
16:51:10 <stefanw> actually it's testTT
16:56:30 <stefanw> shapr: where do I get this RunTestDots.hs?
16:57:10 <shapr> http://www.scannedinavian.org/~shae/RunTestDots.hs
17:02:47 <nuffer> how do I deal with ambiguous occurence errors?
17:04:27 <shapr> ?
17:04:31 <shapr> What's the error?
17:04:36 <nuffer> I have two classes
17:04:43 <nuffer> err, not classes, data types
17:04:55 <nuffer> that have entries with the same name
17:05:06 <nuffer> data BOp = Add | ....
17:05:11 <nuffer> data Op = Add | ....
17:05:14 <nuffer> Add becomes ambiguous
17:07:48 <dons> you need to show us the exact error message ;)
17:08:21 <shapr> I think you need to change your constructors so that they don't overlap.
17:08:31 <shapr> BAdd and OAdd maybe?
17:08:43 <nuffer> myeh, I just imported the module as qualiified
17:26:41 <lisppaste2> araujo pasted "shell regexp" at http://paste.lisp.org/display/13099
17:27:07 <araujo> shell regexp à la haskell :-]
17:31:26 <Cale> isSuffixOf
17:32:33 <dons> preparing slides in QuickCheck is a great way to make sure there are no errors!
17:33:29 <gzl> preparing slides *in* QuickCheck?
17:36:59 <dons> writing slides with code in them, running that code in QC first
18:14:28 <bmedwar> can anyone point me to instructions for multiple executables in a visual haskell project
20:01:14 <machack666> when you define a typeclass is it possible to define a default implementation for functions in that typeclass?
20:02:02 <sethk> machack666, yes
20:12:35 <machack666> can you define a typeclass to extend an existing class (i.e., in order to override particular functions for specific types, but leave the default implementation the same for everything else?
20:13:39 <machack666> I am writing a Show' class which defines show' to be show, and I want Show' to be automatically defined for all classes which already define Show (with the exception of the specific types that I am overriding).
20:14:14 <sethk> machack666, that I'm not sure about.
20:14:15 <machack666> Any way of doing that without defining individual Show' instances for all of the existing non-overridden types?
20:14:46 <sethk> machack666, I can't think of one, but ask other people who know more than me also
20:17:53 <machack666> is everyone out trick-or-treating? ;D
20:18:29 <sethk> usually there would be people here at this time
20:18:44 <sethk> I'm not sure where they are over in Australia.  :)
20:19:23 <Lemmih> Maybe you can get away with "instance Show a => Show' a" if you throw some flags at GHC.
20:21:12 <machack666> I've got that right now, minus any specific flags (other than -fglasgow-exts)
20:22:46 <sethk> machack666, does it do what you want?
20:23:20 <machack666> the instance that I defined for the types does what I want, but it complains about a lack of a Show' instance for the other types [Int], as an example
20:24:17 <machack666> wait...I just had class (Show a) => Show' a where show' :: a -> String, not an actual instance declaration.
20:24:40 <machack666> -fallow-undecidable-instances ...
20:26:05 <Lemmih> It works for me with undecidable and overlapping instances.
20:26:18 <machack666> now I'm getting the overlapping instances problem
20:26:23 <machack666> is that -fallow-overlapping-instances
20:26:24 <machack666> ?
20:26:30 <Lemmih> Yes.
20:26:58 <machack666> I may just be able to do that without the additional typeclass rigamarole
20:27:37 <machack666> still getting the overlapping instances error
20:29:07 <machack666> do the flags have to be specified in the Main.hs, or in any of the files which will be using the features?
20:34:22 <sethk> machack666, good question.  I don't know.  Certainly at the least where they are used and defined, possibly everywhere
20:37:04 <machack666> I've got -fglasgow-exts -fallow-undecidable-instances -fallow-overlapping-instances defined in Main.hs, as well as in Utils.hs (where my custom trace function lives).  Everything compiles fine; it's at runtime that the undecidable instance message occurs.
20:37:23 <machack666> Is there a way to set the "preferred" instance declaration when there is ambiguity?
20:38:36 <machack666> what's the best way to find out about this?  the ghc user's manual?
20:39:55 <sethk> since it is a ghc extension, that's probably the only place
22:47:02 <glguy> can someone explain why the function Array.accum is called accum
22:47:07 <glguy> I understand what it does
22:47:17 <glguy> but not why it is named what it is named
22:52:48 <glguy> More importantly... can someone explain why it is necessary to use "map" when "fmap" is more general
23:09:13 <dblhelix> glguy: maybe not a strong argument, but perhaps because there's no dictionary passing involved with the non-overloaded map?
23:14:58 <Cale> Well, probably that was the argument at the time, but I think today, I'd say that's what the specialize pragma is for :)
23:15:34 <Cale> I suppose another reason is that usage of map forces the parameter to be of list type, which is sometimes what you want, but that's not too strong an argument either.
23:26:08 <ibid> i think map used to be a Functor method, but it was split partly so that map error messages would be a little more comprehensible
23:26:42 <ibid> my understanding is that this is the argument for making monad comprehensions mere list comprehensions, as well
23:26:55 <Cale> yeah
23:27:08 <Cale> there's that too :)
23:30:44 <ibid> hm, in 1.4 there used to be an Eval class too
23:31:11 <ibid> yes, map was a functor method
23:31:25 <ibid> (++) was a method in MonadPlus
23:31:39 <pediddle> oh, how i wish that were still true
23:32:36 <ibid> ah, Eval was a class that was implicitly instanced to all types
23:32:42 <ibid> derived, rather
23:32:47 <ibid> contained eg. seq
23:32:59 <dons> shapr, quickcheck notes at: http://www.cse.unsw.edu.au/~dons/talks/qc.ps.bz2
23:33:27 <pediddle> ibid: where are you finding these documentation?
