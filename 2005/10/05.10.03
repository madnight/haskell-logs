00:01:45 <JohnMeacham> Oejet: yup. it is pretty much based on that paper.
00:02:02 <JohnMeacham> Oejet: with the goal of expanding on the ideas to make them practical for a real haskell compiler
00:04:10 <Oejet> JohnMeacham: Great.  Got to study now.  See you.
00:47:23 <Trinsic> can anyone tell me if function composition like (square .  f) 5  (which in my eyes) is not as clear as square (f 5), is for the sake of mathematicians?
00:48:21 <boegel> Trinsic: no, it allows you to make the notation a lot short
00:48:24 <Lemmih> It allows you to write 'g = square . f' instead of ' g x = square (f x)'
00:48:32 <boegel> and to redefine compisition you use a lot
00:48:46 <boegel> sqF = square . f
00:48:49 <boegel> sqF 5
00:49:44 <paolino> morning everybody
00:50:01 <Lemmih> 'morning, paolino.
00:51:01 <paolino> Now that I have some ideas of what is going on, I'd like too see something from higher
00:51:27 <Pistahh> and what is the difference between f . g  and f $ g  ?
00:51:31 <paolino> I want to rewrite my AI programs in haskell
00:52:17 <Lemmih> Pistahh: 'f $ g' == 'f g', 'f . g' == '\x -> f (g x)'
00:53:09 <paolino> AI -> non-determinism -> Monads is right ?
00:53:16 <Pistahh> Lemmih: how would you explain it if I were e.g. a lawyer? :)
00:53:21 <Lemmih> @pl (f $ g, \x -> f (g x))
00:53:21 <lambdabot> (f g, f . g)
00:53:26 <basti_> paolino: the list monad gives ND emulation
00:54:01 <Pistahh> @pl f g x
00:54:02 <lambdabot> f g x
00:54:13 <Trinsic> lemmih oh i like that!
00:54:22 <Pistahh> whats the difference between f g x and f (g x) ?
00:54:30 <Trinsic> boegal, what is spF 5?
00:54:48 <paolino> basti_ what do you mean with 'emulation' ?
00:55:00 <Lemmih> Pistahh: 'f g x' == '(f g) x'
00:55:03 <basti_> paolino: well currently only few computers can do real nondeterminism
00:55:28 <Pistahh> Lemmih: sorry I still do not understand :(
00:56:06 <basti_> Pistahh: think about it like that: in f g x, g is a parameter to f. In f (g x), g is applied to x, and then becomes a parameter to f
00:56:28 <paolino> basti_, then I substitute s/non-determinism/choosingonesolution ?
00:56:42 <basti_> paolino: well you can choose ALL solutions too
00:56:47 <Lemmih> Pistahh: 'f g' is function application.
00:57:21 <Pistahh> sorry, I'm not a mathematican-like, so this stuff is a bit hard for me to understand.
00:57:31 <Pistahh> does f g mean I apply function f on function g?
00:58:19 <Lemmih> Yes.
00:58:54 <Lemmih> Like: 'succ 10'.
00:59:09 <basti_> its really easy. you can define a function, mention it, or apply it.
00:59:10 <paolino> basti_, in my experience it takes hours of real computation to find a solution and ,if the program doesn't choose on the way it will never find a valid one
00:59:26 <basti_> paolino: i didn't say you can't pick
00:59:42 <Pistahh> Lemmih: but 10 is a value, not a function
01:00:02 <paolino> basti_, is picking a monadic behaviour?
01:00:06 <basti_> thats just a hallucination
01:00:15 <basti_> paolino: hmm
01:00:47 <basti_> paolino: yes, it can be
01:00:49 <Lemmih> Pistahh: Values are functions with no arguments.
01:02:50 <paolino> basti_, then how do I get back to the situation before the picking to try another picking ?
01:03:36 <basti_> paolino: hmm. for example, you could be sorting lists. thats not monadic, but you can do it anyway.
01:03:46 <basti_> then the first element of the list after sorting would be the first pick
01:04:07 <basti_> if the empty list results some time from then on, the next element in your sort would be picked
01:05:27 <Pistahh> @pl (\x -> 2*x) . (\x -> x+3)
01:05:28 <lambdabot> (2 *) . (3 +)
01:07:03 <paolino> basti_, say I have a set of words ,the solutions are all the possible subsettings of the set satisfying some conditions
01:07:58 <basti_> that would be like do {x<-subsettings words;y<-filter subsettings}
01:08:59 <basti_> {} and ; are replacements for line breaks in one-liners
01:09:20 <paolino> subsetting words leads to an almost infinite set
01:09:39 <basti_> aw thats ok
01:09:48 <basti_> it won't evaluate all solutions at once
01:09:53 <basti_> ("lazy evaluation")
01:11:14 <paolino> my flight has ended I need an example
01:11:19 <paolino> :(
01:11:26 <basti_> hmm okay.
01:11:30 * basti_ thinks one up
01:12:43 <paolino> let's cluster them for lenght
01:13:25 <paolino> not infinite really
01:14:10 <basti_> hmm ok
01:14:38 <basti_> but that wont do much monad wise.
01:15:31 <paolino> say all subsets must have a range of possible power
01:16:06 <paolino> like have power between min and max
01:16:54 <basti_> @plugs sortBy (\a b->compare (length a) (length b)) ["aaaa","bb","ccc","d"]
01:17:07 <lambdabot> ["d","bb","ccc","aaaa"]
01:17:07 <basti_> thats not monadical.
01:18:08 <basti_> btw :P
01:19:01 <paolino> I can do that in visual basic probably :/
01:19:17 <basti_> lets do something monadic
01:19:25 <paolino> :)
01:20:42 <paolino> what type sortBy belongs to ?
01:20:47 <basti_> @plugs  do {a<-["a","b","c"];return $ a++"u"}
01:20:51 <basti_> @type sortBy
01:21:20 <lambdabot> ["au","bu","cu"]
01:21:23 <lambdabot> bzzt
01:21:26 <basti_> uh
01:21:29 <basti_> @type Data.List.sortBy
01:21:35 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
01:22:36 <paolino> ehm what is the dollar for there ?
01:22:43 <basti_> thats just changing parenthenses
01:22:48 <basti_> a $ b c === a (b c)
01:23:06 <tromp> what's === ?
01:23:30 <basti_> it's supposed to mean "is a function equal to"
01:23:34 <basti_> (you cant compare functions)
01:24:04 <JohnMeacham> yay. CPR analysis and the worker/wrapper split seem to be working. jhc should be stepping up the competition with ghc soon..
01:24:27 <JohnMeacham> It was sort of working before, but I rewrote it and it is much better now.
01:25:35 <paolino> return (a ++ 'u') ?
01:25:44 <basti_> "u"
01:25:47 <basti_> @type (++)
01:25:58 <lambdabot> forall a. [a] -> [a] -> [a]
01:25:59 <paolino> what is a ?
01:26:08 <basti_> a is a variable from the line before
01:26:40 <paolino> not a list of strings ?
01:27:52 <basti_> ah
01:27:55 <basti_> you mean its type
01:27:59 <basti_> yes it is a list of strings
01:28:16 <paolino> ++ made weird then
01:28:17 <basti_> but <- and line break respective ; do slightly strange things inside the do stuff
01:28:24 <basti_> no it's do's fault
01:28:32 <basti_> maybe you see better when i rewrite [typing]
01:29:08 <basti_> @plugs concatMap (\a->[a++"u"]) ["a","b","c"]
01:29:18 <lambdabot> ["au","bu","cu"]
01:29:37 <basti_> thats the same thing, just with <- and ; rewritten
01:31:10 <basti_> actually two rewrites. a <- b inside do is b >>= a, and >>= is concatMap for lists
01:31:14 <basti_> (i know that sounds bizarre)
01:32:30 <paolino> still I miss the big figure :/
01:32:40 <basti_> thats quite normal.
01:33:15 <basti_> see, it all starts with monads
01:33:19 <basti_> @type (>>=)
01:33:22 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m
01:33:22 <lambdabot> b
01:33:30 <basti_> lambdabot: great linebreak
01:34:05 <paolino> with the second syntax you define something
01:34:20 <basti_> hmm look at that type
01:34:27 <basti_> its a function with two parameters
01:34:29 <paolino> with the first you change it
01:34:37 <basti_> to the left, theres a value of type "a" in a box called "m"
01:34:50 <basti_> to the right there's a function from "a"'s to m-boxes of type "b"
01:35:56 <basti_> m-boxes can be lists, for example
01:36:14 <basti_> so to the left there's a [a], and to the right there's a a->[b]
01:36:30 <basti_> and the result will be [b]
01:36:47 <basti_> now if you think about that, concatMap would be some sort of a canonical function to have that type
01:36:50 <basti_> @type concatMap
01:36:53 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
01:37:30 <paolino> loosing information ?
01:37:44 <basti_> no not at all
01:37:50 <basti_> its just changing information
01:38:08 <basti_> @plugs concatMap (\x->[x]) "abcde"
01:38:11 <lambdabot> "abcde"
01:38:18 <basti_> @plugs concatMap (\x->[x,'u']) "abcde"
01:38:21 <lambdabot> "aubucudueu"
01:38:23 <paolino> at least you loose the form of the information
01:38:35 <basti_> @plugs concatMap (\x->[(chr.(+1).ord) x]) "abcde"
01:38:37 <lambdabot> "bcdef"
01:39:53 <basti_> it can be altered yes
01:39:54 <dblhelix> @eval [1, 2, 3] >>= \n -> [n + 1, n + 2, n + 3]
01:39:57 <lambdabot> [2,3,4,3,4,5,4,5,6]
01:40:13 <paolino> looks like for lists it reversible (in your examples at least)
01:40:25 <dblhelix> (more or less typical use of list as a monad...)
01:40:43 <basti_> well its possible that information is lost
01:40:47 <basti_> but that isnt bad at all
01:41:44 <basti_> < phone :(
01:41:50 <paolino> I didn't say that ,I'm wondering how to get back and try another route
01:45:33 <shapr> JohnMeacham: Is the machine code generated by jhc also SSA?
01:50:32 <JohnMeacham> shapr: GRIN and SSA are isomorphic. more or less.
01:50:36 <basti_> ...
01:51:23 <JohnMeacham> shapr: boquist mentions it in his thesis. also, someone else (?) I forget who wrote a paper on how SSA is equivalant to a monadic form which is basically what grin is.
01:51:47 <Philippa> damn, I should've picked up on that
01:51:54 <Philippa> would've left BvE looking a little embarassed
01:52:07 <Philippa> ('lo btw - can't hang around too long, got a lecture to get to)
01:52:12 <shapr> hi Philippa
01:52:31 <dblhelix> Philippa: what lecture?
01:52:32 <JohnMeacham> shapr: basically, you can think of Grin as functional code with a fixed monad. it is no accident my constructors are called :>>= and :->
01:53:22 <Philippa> dblhelix: the Epigram undergrad module here
01:53:39 <Philippa> I thought you were just smiley-obsessed ;-)
01:53:42 <shapr> JohnMeacham: I think P193 of Boquist's thesis says that values and live ranges would be the same thing if the generated RISC code were SSA, any idea what advantage that would give?
01:53:48 <dblhelix> Philippa: cool! wished I could attend that one
01:54:14 <Philippa> JohnMeacham: would there be any practicality to keeping enough typing in Grin to tell which effects're possible in which code?
01:55:12 <juhp> shapr: (slightly ot) can I ask you how you generate the tmr from sxml?  out of curiosity
01:55:24 <juhp> s/the //
01:56:15 <shapr> JohnMeacham: The tiny bit of text on P194 implies that SSA machine code has advantages. Any ideas what those advantages are, and will you be doing that with JHC?
01:56:24 <shapr> juhp: Oleg did that.
01:56:44 <juhp> ah :)  so it is just for his article? :)
01:59:54 <Philippa> juhp: ask Oleg? He might have code you can use
02:00:13 <juhp> Philippa: yeah ok
02:00:27 <juhp> sxml looks pretty neat and readable :)
02:00:38 <Philippa> so does wiki code IMO, but hey
02:00:56 <Philippa> then again, I'm in the lucky position where I often get to design it for myself
02:01:09 <juhp> Philippa: :)
02:01:29 <juhp> Philippa: how is your wiki in haskell coming on? :)
02:03:29 <Philippa> slowly, like most things in my life
02:03:57 <Philippa> SyntaxNinja wanted some stuff added, so I'm slowly working on that for now. The version in the darcs repo is in the middle of gaining a plug-in model
02:04:14 <Philippa> said plug-in model is trying to go in very scary but impressive directions
02:06:12 <shapr> Oleg suggested that TMR switch to using lhs2TeX... I decided it solves some of the TMR problems, so next month will be lhs2TeX
02:06:18 <Philippa> argh!
02:06:37 <Philippa> I don't want to work with that, can you rig up a processor?
02:06:45 <shapr> I'll see what I can do...
02:06:50 <Philippa> if nothing else, if you switch next month I have to reformat all my WIP...
02:11:18 <basti_> paolino: still there?
02:24:36 <paolino> basti_, my clusterer takes all the english words and build disjoint subsets of them with a range for their power (5-20) so that 2/3 grams difference is minimized in all the subset population
02:24:55 * basti_ nods
02:25:11 <basti_> paolino: list monads are depth-first search so to say
02:25:13 <Trinsic> How does haskell recurse? ie. does it use like a linked list?
02:25:47 <Heffalump> errm, that depends on what you're doing
02:26:13 <Heffalump> if there's no tail recursion, you'll effectively get a chain of thunks that looks sort of like a linked list.
02:26:17 <paolino> this is good to apply edit-distance to  a small set of words to perform fuzzy matching
02:27:29 <JohnMeacham> shapr: SSA has a lot of advantages. but it is not really a machine code, rather an intermediate compiler language. and can be used to generate machine code. the defining feature of SSA (static single assignment) is that each variable always has a single definition, this is inherently true of Grin since it is purely functional. but much easier to reason about than SSA IMHO since you can use all the monad knowledge we already
02:27:29 <JohnMeacham>  possess.
02:27:43 <JohnMeacham> gcc recently switched to a SSA intermediate language.
02:28:10 <JohnMeacham> not sure. why i was. inserting so many. periods.
02:28:34 <paolino> basti_ ,to achieve this I've abstracted the problem with a costant depth tree clustering
02:29:57 <paolino> basti_, where every layer is self linked with a constant number of links per node
02:30:05 <basti_> uhm
02:30:21 <basti_> so you write an expand function for every node.
02:31:21 <basti_> it'd proabaly look like a->[a] wouldnt it?
02:31:26 <shapr> JohnMeacham: Sure, I know that much about SSA, but I don't see why Boquist thought it would be an advantage for generated machine code.
02:32:29 <paolino> not really , an exchange-children function for a set of same-layer "neighbours" node
02:32:47 <paolino> nodes
02:33:45 <paolino> the tree is complete at the beggining
02:34:20 <paolino> all subsets are done
02:34:20 <basti_> hmmm
02:34:27 <basti_> so what are you trying to do?
02:34:34 <basti_> sort it?
02:35:12 <paolino> then they exchange what they are representing to minimize standard deviation
02:35:42 <paolino> probably sort it is the rigth concept
02:35:50 <basti_> hmm for me a search problem is solved by expansion and exploration
02:36:06 <paolino> this is different
02:36:13 <basti_> hmmh
02:36:18 <paolino> well
02:36:21 <basti_> so you got a tree and want to sort it some way?
02:36:55 <paolino> let's start like that
02:37:20 <basti_> how do you determine the order?
02:37:26 <JohnMeacham> shapr: Hmm.. where did boquist say that?
02:37:58 <JohnMeacham> I am in programming mode so have temporarily sacrificed my verbal skill, if I seem terse :)
02:38:31 <paolino> it comes out from an entropy function applied to a set of same-layer nodes
02:38:58 <paolino> minimize sum of standard deviation
02:39:03 <basti_> so you just sort the children list on every level?
02:39:03 <cjs_> Hey, this Yi thing, can you actually set it up so you could press a button and it would change from "Emacs" mode to "vi" mode, essentially?
02:39:46 <paolino> basti_ ,sounds right
02:40:20 <basti_> hmm then why dont you do that? ;)
02:41:04 <paolino> well because I don't see how to describe it in a functional way
02:41:14 <basti_> whats a tree in haskell?
02:41:16 <paolino> I have the code running in python
02:42:28 <paolino> every node points to  a set of subnodes
02:42:31 <Philippa> cjs_: it could be done with a further plugin, I imagine
02:43:39 <paolino> data Tree value=[Tree value]
02:43:43 <basti_> so basically you'd recurse into the tree, and sort the subForest of every node
02:43:53 <Heffalump> paolino: where do you put the values?
02:44:22 <basti_> thats a good question in your case, actually
02:44:24 <paolino> every node has one tuple
02:44:27 <cjs_> That would be truly amazing for vi and emacs users pair programming together.
02:44:39 <basti_> paolino: it does?
02:45:08 <paolino> first element is the sum of all the values of the final leaves below him,
02:45:23 <Heffalump> paolino: where? Your definition isn't syntactically correct anyway.
02:45:29 <paolino> second element is the number of final leaves
02:46:12 <basti_> paolino: second element?
02:46:36 <paolino> data Tree (sum,count)=Branch [Tree (sum,count)]
02:46:51 <basti_> does that compile?
02:47:08 <paolino> 80 % false
02:47:18 <basti_> *laughs*
02:48:10 <Heffalump> that's still not syntactically correct
02:50:40 <paolino> haskell compiler is not fair with noobs
02:50:46 <basti_> it is
02:51:03 <paolino> it thinks it is
02:51:35 <basti_> maybe try something like "data Tree a = (a,[Tree a])"
02:51:48 <paolino> well it tries to be, I appreciate
02:51:53 <Heffalump> it is syntactically valid? You can require a tuple as a parameter to a datatype?
02:52:00 <paolino> * phone
02:52:19 <dblhelix> data Rose a = Branch a [Rose a]
02:52:42 <dblhelix> (rose trees, rhododendrons)
02:52:51 <basti_> uhm yes forgot a constructor too
02:53:05 <nothingmuch> moral question: does it make sense for a node to appear in more than one place in the graph fed into an AG?
02:53:15 <paolino> back
02:53:36 <dblhelix> nothingmuch: do you have a particular example in mind?
02:53:38 <Philippa> nothingmuch: depends on the AG, no?
02:53:57 <nothingmuch> dblhelix: yes, but it's in perl
02:54:12 <dblhelix> nothingmuch: yuck ;)
02:54:22 <nothingmuch> i'll try to translate ;-)
02:54:31 <dblhelix> nothingmuch: appreciated
02:55:00 <nothingmuch> data Type = TO TOperator | TV TVariable;
02:55:18 <paolino> data Tree value=Rose value [Tree value]
02:55:24 <nothingmuch> data TOperator = Nullary String | Binary Type String Type
02:55:36 <nothingmuch> data TVariable = Free | Instantiated Type
02:56:22 <nothingmuch> now i have the type a -> a
02:56:36 <basti_> paolino: looking good
02:56:41 <paolino> basti_, actually there is a condition holding on the two values on the right
02:56:56 <basti_> what'd it be?
02:57:08 <nothingmuch> this is 'Binary Instantiated x "->" x'
02:57:13 <JohnMeacham> shoot. you can't lambdalift a function that takes unboxed arguments... hmm.. curious. that is going to be a pain to work around.
02:57:19 <nothingmuch> x = Free
02:58:23 <nothingmuch> now, i'm computing the set of free variables, and there is an inherited attr coming from the binary operator
02:58:29 <nothingmuch> and from the instantiated variable
02:58:29 <paolino> (fathersum,fathercount)=(sum sonsvalues,sum sonscount)
02:58:43 <nothingmuch> both trying to set the input free set of x
02:58:58 <dblhelix> nothingmuch: you mean Binary (TV (Instantiated (TV Free))) "->" (TV Free)
02:59:01 <dblhelix> ?
02:59:01 <basti_> paolino: uhm
02:59:09 <nothingmuch> err, yes
02:59:20 <nothingmuch> but the (TV Free) are the same thing
02:59:22 <Philippa> paolino: you can't do anything to encode that in Haskell 98's type system
02:59:37 <Philippa> you need some thoroughly weird stuff (I've got a lecture on such a system in an hour)
02:59:43 <nothingmuch> it could be anything else, i guess
02:59:48 <nothingmuch> in haskell this doesn't seem so naughty ;-)
03:00:08 <Philippa> what you /can/ do is stop anything other than a set of trusted functions building values of your type, so if you really /do/ trust those functions then you trust them to maintain that invariant
03:00:33 <nothingmuch> nevermind, this is an implementation issue
03:00:55 <Philippa> Haskell does have a habit of making things seem far less filthy
03:01:06 <Philippa> and thus potentially encouraging you to do really damn dirty (and fun) things on occasion
03:01:28 <dblhelix> it's about trusting yourself
03:01:57 <dblhelix> what I like about epigram (or deptypes in gen) is that you can vary the degree of trust in yourself
03:02:23 <Philippa> ain't the existential quantifier wonderful? :-)
03:02:45 <paolino> it's been quite a piece of code in python anyway nothing so complicate
03:03:32 <basti_> paolino: i would say, you'd have to generate a tree that obeys these constraints
03:03:42 * dblhelix still looks forward to doing existential stuff with boxy types
03:03:45 <Philippa> have to admit I'm half going in the hope Conor McBride's there though. Far too much stuff I should talk to him about (and really, if somebody has a footnote in a paper that reads "<idea you've had> - anyone wanna cooperate on this?" you've kinda got to say hi
03:03:50 <Philippa> )
03:04:20 <Philippa> dblhelix: same here, the Ruby folks can check out /our/ duck typing
03:04:34 * dblhelix grins
03:05:45 <paolino> basti_ , the program (imperative one) is keeping on changing this values (obviously)
03:05:45 <JohnMeacham> Hmm.. can ghc support higher order functions that take unboxed arguments?
03:06:01 <paolino> moving children
03:06:06 * dblhelix is preparing for travelling 60 km and doing ten hours or so of non-stop coding and then some writing
03:06:16 <Philippa> JohnMeacham: dunno, I'd have thought so as long as all the types matched?
03:06:21 <basti_> paolino: you can replace a value with another value.
03:06:40 <Philippa> polymorphism is the killer, no?
03:07:01 <paolino> it has to be lazy on that calculations
03:07:13 <basti_> it's lazy everywhere.
03:07:41 <Si\Uni> Has anyone ever written bisimulation algorithms for fgl graphs?
03:07:51 <dblhelix> Philippa: doesn't ghc treat boxing/unboxing as a kinding issue....? would this mean that you'll need suitable kinded type constructors for function space? (->) :: # -> # -> # or so?
03:08:24 <dblhelix> or # -> # -> *...?
03:08:34 <Philippa> dblhelix: erk. Kind-level polymorphism and/or subkinding? I'm pretty sure it does one of the two from the one time I poked around a Core reference
03:08:45 * dblhelix really should look into this stuff some time
03:08:59 <Philippa> I really should get moving though
03:09:12 <dblhelix> Philippa: enjoy your lecture!
03:10:23 <dblhelix> well, I guess # is a subkind of *, for you can coerce by boxing
03:16:57 <JohnMeacham> Yeah, but you can't pass unboxed values to polymorphic functions... I am running into trouble because my generic apply routine won't know how to apply a function to a possibly unboxed type.
03:26:12 <shapr> JohnMeacham: Page 194 of his thesis
03:30:06 <paolino> basti_ I suppose I can define a function for Rose _ [Tree children] which returns the tuple
03:32:14 <paolino> and set value to () on all the nodes which are not leaves
03:36:44 <arjanb> JohnMeacham: afaik ghc can't do unboxing on higher order functions
03:36:49 <basti_> paolino: uhm no
03:36:59 <basti_> paolino: () is not a member of type (a,b)
03:37:23 <paolino> data Tree value=Rose [Tree value]|Foglia value
03:37:23 <basti_> you could use Maybe however
03:37:35 <JohnMeacham> arjanb: okay. then I won't try to make jhc do it :) and instead try to figure out how to ensure code is never generated which tries to do so
03:37:44 <basti_> thats a definition of some kind of tree yes.
03:38:04 <paolino> values Foglia value=(value,1)
03:38:06 <basti_> now, of course, you can define a function like "returnTupleIfRose ..."
03:38:11 <basti_> uhm no
03:38:36 <basti_> if, then: values (Foglie value)=(value,1)
03:38:49 <basti_> but that wouldnt help again, because it would break on Rose
03:38:55 <arjanb> JohnMeacham: if you make apply only take a boxed argument then you can remove the superfluous (un)boxing after inlining it, right?
03:38:58 <paolino> values (Rose subnodes)=map sum dezip (value subnodes)
03:39:05 <paolino> values (Rose subnodes)=map sum dezip (values subnodes)
03:39:19 <JohnMeacham> shapr: Ah, I remember what you are talking about. I believe it had to do with the inability to express loops and joins directly in Grin. but this is not as much of an issue for jhc since I am going through C-- (or C) so can do a basic blocks analysis on the code in its c-- form.. since he was going straight from grin -> assembly it wasn't as easy for him to do that.
03:39:32 <basti_> paolino: thats type [(a,b)], though
03:39:41 <basti_> not (a,b)
03:39:59 <basti_> maybe you're looking for some kind of fold
03:42:58 <paolino> foldl (\(summa,count) (exsumma,excount)=(summa+exsumma,count+excount)) (0.0,0) (values subnodes)
03:43:34 <basti_> try foldr1
03:43:39 <JohnMeacham> arjanb: yeah, but then I loose the advantage of my unboxing transformations... and the analysis needed to figure out where to insert the boxing/unboxing might be triickier than solving the original problem somehow.
03:43:43 <basti_> then you can leave away the zero
03:43:48 <basti_> and foldr is lazy too.
03:44:06 <JohnMeacham> shapr: but there might be more to it. I will look at it some more when I find my copy of the thesis.
03:44:10 <basti_> no, it's better memory-wise.
03:44:46 <paolino> basti_ what about that lambda
03:44:56 <paolino> can I take it away?
03:44:57 <basti_> thats looking good
03:45:01 <basti_> hmmh
03:45:03 <basti_> not easily
03:45:13 <basti_> thats what lambdas are for btw: constructing functions on the fly
03:45:19 <JohnMeacham> shapr: I was actually thinking of solving it at the Grin level by allowing local function definitons but only if they are used as tail-calls. this would allow direct loops and joins in grin and I could leave tail-called functions where they are instead of lambda lifting them.
03:45:37 <paolino> k
03:45:59 <Heffalump> hi ndm
03:45:59 <paolino> then I leave it like that, what is foldr1 ?
03:46:07 <ndm> hi Heffalump
03:46:10 <ndm> back in the UK yet?
03:46:10 <paolino> use the first as base ?
03:46:12 <pejo> JohnMeacham, is C-- usable on anytihng but Linux/IA32?
03:46:26 <basti_> paolino: yep
03:46:34 <paolino> k
03:46:47 * dons rematerialises in singapore
03:46:50 <Heffalump> how close is jhc to being usable for "real programs", btw?
03:46:53 <Heffalump> hi dons
03:47:01 <Heffalump> it took you that long to get to Singapore?
03:47:07 <dons> I'm half way!
03:47:16 <basti_> dons: hey i know that feeling :D
03:47:20 <Heffalump> I guess you only left Estonia 12 hours ago or so.
03:47:20 <dons> about 9hrs to go
03:47:25 <dons> right
03:47:32 <JohnMeacham> pejo: it depends on what you mean by 'usable' I think the main compiler is only ia32, but it is already used as an intermediate language in ghc and I plan to use it for the same in jhc. so eventually when there is a c-- front end for gcc I can just switch to using it.
03:47:34 * Heffalump has got home, slept and is now at work!
03:47:42 <dons> boo hoo
03:47:46 <basti_> Heffalump: .au is far away.
03:47:49 <Heffalump> basti_: indeed.
03:48:00 <dons> yeah :/
03:48:00 <ndm> ndm has got home, got drunk, slept, and completed 2 part time jobs and is now at work
03:48:06 <dons> hehe
03:48:09 <Heffalump> But it's scary to realise the contrast between dons and I, when we were at the airport simultaneously.
03:48:16 <basti_> -g-
03:48:25 <ndm> well Estonia to UK is 1 hour
03:48:27 <dons> yeah. it's nasty
03:48:28 <JohnMeacham> Heffalump: getting closer all the time :)  once I finish this worker/wrapper stuff, it will be competitive with ghc and I can concentrate on the more advanced optimizations.
03:48:30 <ndm> if you take account of the time difference
03:49:11 <basti_> my gf's relative (who is in australia) wasn't able to visit surprisingly... he called us instantly when he did so...
03:49:24 <basti_> he was like "sad that i had to... 3 hours before..."
03:49:43 <pejo> JohnMeacham, yeah, C-- frontend on gcc would be nifty.
03:49:53 <basti_> and we were like "uhm 3 hours but youre going to arrive... uhm -quick calculation- oh yes"
03:50:44 <JohnMeacham> shapr: But i am not sure how to express the local functions in the monadic framework in a clean way... I mean, they could just be declared values, but they are not first-class so that seems unclean to me... hmm.. it would allow me to directly output ,'while' loops in the generated C code so I wouldn't have to rely on gcc's questionable tail-call elimination algorithm
03:50:45 <dons> hmm. I did spend 1 hour on the tarmac in bangkok though.
03:50:54 <dons> and it was nicely 100 degrees F
03:51:08 <JohnMeacham> pejo: yeah. now that gcc is SSA based, it should be easier to do.
03:51:13 <basti_> mmmm nice
03:51:14 <basti_> :)
03:51:47 <JohnMeacham> pejo: I don't think it can be taken that seriously until it can hook into the vast set of hand-tuned code-generators that gcc provides.
03:53:26 <pejo> JohnMeacham, shrug, I wouldn't be surprised if Ramsey and a couple of grad students could match gcc when it comes to quality of the code it outputs.
03:55:32 <JohnMeacham> pejo: maybe for ia32, sparc and a few others.. but not for the other hundred targets gcc supports.. plus. I don't see why they would want to when gcc already has all this nice code generation code
03:57:09 <pejo> JohnMeacham, yeah, portability is won by gcc due to sheer number of developers, a bunch of them employed by companies making the targets they work on.
03:59:07 <pejo> JohnMeacham, from a prototype pov I'd say that anything is easier to "fix" than gcc internals.
03:59:52 <JohnMeacham> pejo: yeah... but hopefully the switch to SSA has cleaned things up a bit.
04:12:18 * dons surives yet another passport check
04:13:56 <ndm> you have wifi at the airport?
04:14:49 <dons> yep
04:15:00 <dons> all the airports do, just about.
04:15:02 <ndm> you have a laptop that can operate off battery? (we didn't)
04:15:19 <dons> even Tallinn had an info kiosk with java == java ssh ;)
04:15:30 <dons> yes, luckily my battery has held up :)
04:16:03 <dons> security is noticeably tighter in singapore than .ee or .fi
04:16:07 <dons> interesting.
04:16:21 <ndm> yeah, it would be
04:16:25 <nibro> there were even some power outlets on the airport, so I didn't even need to use my battery
04:16:31 <nibro> could save it for the flight :)
04:16:32 <ndm> and they aren't a fan of chewing gum :)
04:16:57 <dons> so i've heard. oh, nibro would be yet another person who's been home for days now
04:17:04 <MarcWeber> sylvan: I've tried understanding your randomsR term. But I don't know exaclty where to start reading it.
04:17:08 <MarcWeber> let randomsR (a,b) g = let (x,g') = randomR (a,b) g in x : randomsR (a,b) g' in (randomsR (1,5::Int) (mkStdGen 54))
04:17:15 <MarcWeber> Should I start at the : operator?
04:17:16 <nibro> indeed, I've been home for 44 hours more or less :)
04:17:26 <shapr> salut kowey
04:18:06 <ndm> nibro, did i meet him?
04:18:27 <nibro> ndm: aye, I sat on the other side of dons at the restaurant :)
04:18:28 <kowey> heya, shapr
04:18:31 <kowey> and room
04:18:41 <nibro> had the chicken tandoori, like you :p
04:18:42 <dons> ndm! yes. when drinking beer
04:18:44 <ndm> ah, fair enough :)
04:18:49 <paolino> basti_ , to move childrens I need to refer also to fathers
04:18:52 <dons> hehe
04:19:06 <nibro> I'm the guy who will keep bugging you about that lexer you know ;)
04:19:12 <shapr> ICFP nametags need a space for irc nickname next year.
04:19:28 <dons> they do
04:19:37 <nibro> absolutely
04:19:42 <dons> SyntaxNinja wrote his on, at least
04:19:58 <nibro> so did ndm, that's why I knew his :)
04:20:08 <shapr> Maybe we should make #haskell t-shirts
04:20:18 <dons> oh, nice idea :)
04:20:25 <boegel> and #haskell-blah t-shirts too ! :D
04:20:29 <shapr> yeah!
04:20:33 <ndm> nibro, do so - i need it or it will never end up getting done
04:20:35 <dons> to compete with all the pugscode.org ones being handed out ;)
04:20:40 <shapr> dons: totally
04:20:58 <shapr> Now we need someone to do some graphic design...
04:21:17 <dons> well, you just need a lambda, right ;)
04:21:36 <shapr> Too bad Fritz doesn't hang out here.
04:21:56 <Igloo> And they need to have 'It's pronounced "hash", dammit!' on the back
04:22:12 <dons> yep!
04:22:25 <shapr> Amusingly, I don't think I've ever said it.. I just say "the haskell irc channel".
04:22:46 <shapr> Any ideas for a logo?
04:22:49 <nibro> so now I know why it's called "pound", they're on the same key :)
04:22:51 <dons> i bet shapr says 'pound'..
04:23:00 <nibro> £ and # that is
04:23:10 <shapr> I don't say either! Just 'haskell channel'
04:23:39 <shapr> I'd probably say fyrkant just to be difficult :-)
04:23:45 <dons> hehe
04:24:19 <nibro> shapr: the official swedish name is br‰dgÂrd, just so you know
04:24:29 <nibro> but no one ever says that either ;)
04:24:29 <shapr> oh neat
04:24:59 <pejo> nibro, hm, wasn't there some commercial years ago about "plustj‰nsterna" which used "fyrkant" and "stj‰rna"?
04:25:19 <nibro> yeah, it's all Televerket's fault
04:25:21 <shapr> lexiconen vet inte av br√§dg√•rd...
04:26:11 <alar> if you need lambda, take a look at http://www.cafepress.com/skicalc.6225368
04:26:14 <shapr> My gf translated "All your base" into Swedish for me, I was thoroughly entertained.
04:26:21 <shapr> CATS: alla era baser √§r tillh√∂rande oss
04:26:41 <shapr> I put that line as the topic of #haskell.se :-)
04:26:57 <shapr> alar: Yeah, that's Riastradh's t-shirt design.
04:27:03 <nibro> shapr, sv.wikipedia.org/wiki/Br‰dgÂrd
04:27:31 <shapr> I wonder if Riastradh still has the source of that t-shirt.
04:29:30 * dons is boarding the plane. ciao!
04:29:40 <dons> see you on the other side of the equator ;)
04:30:58 <shapr> cya dons
04:31:31 <shapr> Anyone know of blogs related to FP that I might not know?
04:32:27 <alar> lj.com/community/declarative ?
04:33:47 <shapr> Five entries, all by Ashley Yakely :-)
04:34:07 <shapr> I do like this one - http://del.icio.us/tag/haskell
04:35:06 <alar> well, I use lj.com/community/ru_declarative :)
04:35:25 <alar> probably that is not what you want
04:35:39 <shapr> Sadly, I can't read russian.
04:36:32 <alar> but why do you need any blogs? this channel is not enough?
04:36:52 <shapr> I always want more :-)
04:37:20 * alar feels jealous for shapr energy
04:37:34 <shapr> You shouldn't, it's irritating a lot of the time.
04:37:52 <shapr> Hyperactivity is real, and it never stops!
04:38:17 <shapr> alar: You could contribute to the energy, want to write an article for TMR? :-)
04:38:26 <alar> what is TMR?
04:38:43 <shapr> alar: http://www.haskell.org/tmrwiki/
04:39:05 <alar> probably you know also about LtU and hask-sequence?
04:39:13 <pejo> shapr, you've probably seen http://keepworkingworkerbee.blogspot.com/, but it's still interesting.
04:39:41 <shapr> alar: Yes. Maybe I should put my list online so others can compare.
04:40:22 <alar> well, I have nothing to write an article on
04:41:06 <shapr> There are lots of easy articles available. For example, There are many GHC extensions that don't have much documentation.
04:42:05 <alar> and I have only one topic to start a blog or to find an existing one
04:42:45 <alar> semi-academic question: are there useful programming environments where halting problem has a solution?
04:43:48 <shapr> alar: Do you know about the Busy Beaver?
04:43:53 <alar> no
04:44:31 <shapr> http://grail.cba.csuohio.edu/~somos/bb.html
04:44:43 <shapr> hei eivuokko! long time no see
04:44:54 <eivuokko> Hiya shapr, all :)
04:45:20 <shapr> alar: In short, it's easy to discover termination properties for any given program, so start with the smallest possible turing machine programs and work your way up.
04:45:51 <shapr> eivuokko: How's code?
04:46:29 <eivuokko> It's C++ ;)  Just dropped into leech nice ideas :-P
04:46:54 <rep> hehe
04:47:07 <alar> shapr: "This function is well-defined but rapidly becomes un-computable for even a small number of states and symbols. "
04:47:23 <basti_> re
04:47:33 <shapr> alar: Ok, so it's not useful :-)
04:47:50 <shapr> alar: There's also Epigram, which is not turing complete, and is guaranteed to terminate.
04:48:00 <shapr> alar: The H-M typesystem also is guaranteed to terminate.
04:48:07 <alar> sounds more interesting
04:48:14 <shapr> That's one of its especially useful properties.
04:48:41 <pejo> alar, hm. There are languages which guarantee termination of things. But they tend to be quite restricted. Not even sure I understood your question.
04:48:56 <Trinsic> anyone here know the status of web development with haskell? or have a url with something that's a bit past bleeding edge?
04:49:12 <alar> I just want to discover usefulness or uselesness of turing-incomplete systems where halting problem has a solution
04:49:36 <shapr> Trinsic: There's musasabi's hswebforms, nibro's HSP with Lemmih's extensions, Lemmih mod_haskell and lots more.. what exactly do you want to know?
04:49:46 <alar> to find out if "scripting language of my dreams" can exist
04:49:54 <shapr> hiya poetix!
04:49:57 <poetix> Hi
04:50:07 <shapr> Thanks for writing an article for TMR5!
04:50:09 <poetix> TMR #5 looks good
04:50:18 <poetix> Looking at Oleg's thing right now
04:50:23 <JohnMeacham> Trinsic: WASH is amazing. I am surprised it has not become a killer app for haskell.
04:50:47 <shapr> JohnMeacham: It's a pain in the butt if you want to use html links instead of form submission, and it's hard to modify.
04:50:54 <Spark> alar: consider having a specification language that provides loop invariants and so on, and statically verifying that the code meets that specification
04:50:55 <shapr> poetix: Tell me if you figure it out :-)
04:51:06 <Lemmih> What I wouldn't do for a peek at the vshaskell sourcecode *sigh*
04:51:21 <Spark> alar: then you have a language that prevents non-termination but with which you can still write useful programs
04:51:30 <Trinsic> shapr, looking for a MVC type interface, preferably a web server or apache add on.
04:51:33 <Spark> alar: there are some programs that need to loop forever though, like daemons
04:51:36 <shapr> Lemmih: You could always ask the authors how they solved certain problems. That would help you out without violating licenses.
04:51:46 <shapr> g'day blackdog
04:51:50 <Lemmih> @seen JaffaCake
04:51:51 <lambdabot> I saw JaffaCake leaving #haskell 9 days, 20 hours, 52 minutes and 19
04:51:51 <lambdabot> seconds ago, and I have missed 2 minutes and 40 seconds since then.
04:52:02 <Lemmih> Does Krasimir IRC?
04:52:10 <shapr> I haven't seen him.
04:52:21 <Spark> alar: also some algorithms are non-deterministic and are infinitely unlikely to terminate, such as while (true) { if (rand()<0.95) break; }
04:52:33 <rep> JohnMeacham what's so amazing about WASH?
04:53:00 <shapr> Trinsic: There is a version of Simon Marlow's HWS that uses hs-plugins for apache-style dynamically loaded plugins.
04:53:55 <basti_> non deterministic compiler?
04:54:02 <basti_> now -that- would rule
04:54:05 <alar> Spark: for deterministic daemons I can always put a restriction that daemon = terminatable part + infinite loop instruction.
04:54:33 <alar> basti_: some logic languages have so-called nondeterminism
04:54:36 <dcoutts> how's it going Lemmih?
04:54:43 <Spark> alar: i always thought the non-termination could be at the root of the program, i.e. you have an event loop
04:54:55 <Spark> alar: event callbacks always terminate, but the event loop itself does not
04:55:04 <basti_> alar: hmm i know what you mean. thats not the same though. ;)
04:55:15 <alar> basti_: I know :)
04:55:17 <basti_> i was thinking like, a randomly behaving compiler, but thats something else
04:55:18 <Spark> alar: also consider how non-termination applies to concurrency, where you have threads waiting for other threads and so on
04:55:24 <dcoutts> Lemmih, ooh more patches I see :-)
04:55:29 * dcoutts goes to build them
04:55:38 <Lemmih> dcoutts: GHC is tricking me.
04:55:49 <shapr> hiya jewel
04:56:13 <alar> Spark: so I want to find observable bounds of guaranteed-to-terminate programs
04:56:26 <Spark> observable bounds?
04:56:31 <alar> maybe there is enough space inside the bounds
04:56:51 <alar> guaranteed-to-terminate programs cannot do something
04:56:57 <jewel> hi
04:57:03 <alar> I want to find what they can not?
04:57:24 <dcoutts> Lemmih, oh? how so?
04:57:26 <basti_> alar: for example, find out if another program will crash
04:57:26 <alar> or, alternatively, what they are guaranteed to be able to do
04:57:58 <Spark> alar: what if your program takes a linked list as input, then there are infinite possible inputs
04:58:11 <basti_> they are guaranteed to be able to compute any function we call "computeable"
04:58:31 <bourbaki> 170 :)
04:58:37 <shapr> yay! 170 clients on #haskell!
04:58:40 <Lemmih> dcoutts: Checking a module apparently alters GHCs internal state.
04:58:45 * boegel parties with shapr 
04:58:48 <shapr> w00!
04:58:50 <Spark> thats more than there are days until christmas
04:59:04 <bourbaki> christmas ? PAH!
04:59:42 <urtie> woops
04:59:42 <dcoutts> Lemmih, and what does that break?
05:00:10 <shapr> Admittedly, at least three clients here are bots, but this is a nice round number of clients on #haskell.
05:00:15 <Lemmih> dcoutts: It completely screws (sp?) the next module check.
05:00:35 <Lemmih> dcoutts: I think it loads some hi files twice or something...
05:00:50 <dcoutts> Lemmih, ah I see
05:00:56 <Spark> "NEWS at 10: number of clients on #haskell outweighs number of actual haskell programmers!"
05:01:03 <dcoutts> Lemmih, well JaffaCake should be back soonish
05:01:06 <alar> basti_: so I can create imaginary language where halting problem is decidable and it still will be able to compute computable function?
05:01:09 <rep> haha Spark
05:01:27 <shapr> Spark: #haskell is just a cult of personality, we're all here to bask in the reflected coolness of SPJ.
05:01:29 <basti_> alar: thats a different statement
05:01:41 <dcoutts> Lemmih, your latest code builds & runs ok for me btw
05:01:58 <Pistahh> what is SPJ?
05:02:11 <basti_> there are a few languages that can do almost-any function and are always-terminating
05:02:21 <dcoutts> Lemmih, so you're now running the checking in a background thread?
05:02:30 <basti_> ("general calculator" or something - primitive recursion)
05:02:33 <alar> basti_: are there examples of those languages?
05:02:35 <shapr> @where SPJ
05:02:36 <lambdabot> I know nothing about spj.
05:02:44 <Lemmih> dcoutts: I'm trying but it's not going very well (:
05:02:55 <basti_> they can't, however, calculate the ackermann function, whomever that might concern
05:03:09 <dcoutts> Lemmih, oh the background thread you mean? it's proving tricky?
05:03:15 <Blastur> is there a prelude function / easy way to find the index of a substring in a string?
05:03:16 <alar> why? they don't have recursion?
05:03:25 <shapr> Pistahh: Simon Peyton-Jones
05:03:30 <basti_> yes they do, but "primitive" recursion only
05:03:45 <dcoutts> alar, not 'general' recursion
05:03:50 <shapr> Hey, anyone have ideas for a #haskell logo?
05:03:51 <basti_> http://en.wikipedia.org/wiki/Primitive_recursive_function
05:03:54 <alar> only first-order recursion?
05:04:14 <basti_> which are exactly the computable functions < oh
05:04:18 <basti_> I didnt know that
05:04:30 <basti_> alar: its a little more complicated
05:04:37 <alar> <basti_> which are exactly the computable functions < oh
05:04:50 <alar> do not understand this one
05:04:52 <dcoutts> alar, eg Eppigram does some kind of structural inductive thing, so it's more powerful than primitive recursion
05:05:01 <basti_> thats c&p from the wikipedia article
05:05:45 <dcoutts> basti_, eg the Ackerman function is not primitive recursive but you can write it in eppigram
05:06:04 <basti_> dcoutts: that proves that epigram can do more than primitive recursion
05:06:47 <alar> dcoutts: is there a web page about epigram?
05:09:01 <shapr> @where epigram
05:09:02 <lambdabot> http://sneezy.cs.nott.ac.uk/epigram/
05:09:20 <shapr> lambdabot knows all!
05:10:00 <Pistahh> @where being_polite
05:10:01 <lambdabot> I know nothing about being_polite.
05:10:09 <alar> =)
05:10:22 <basti_> argggh
05:10:41 <Pistahh> @where monads
05:10:42 <lambdabot> I know nothing about monads.
05:10:49 <Pistahh> just like me.
05:11:39 <alar> =))
05:11:52 <basti_> as i keep saying, call monads "cute pink fuzzy things"
05:12:02 <basti_> that won't make it easier but it will help the scare
05:12:15 <Pistahh> @where cute_pink_fuzzy_things
05:12:16 <lambdabot> I know nothing about cute_pink_fuzzy_things.
05:12:21 <Pistahh> see?
05:13:49 <shapr> Cale: Has anyone calculated the golden ratio for other dimensions?
05:15:24 <basti_> its not as hard a thing to calculate i'd say
05:15:56 <basti_> when you know today's mathematics
05:17:36 <shapr> I don't :-)
05:18:08 * basti_ sighs
05:18:09 <basti_> ;)
05:18:32 <basti_> hmm or
05:18:42 <basti_> that kinda depends on how you define the golden ratio
05:19:15 <alar> They are defined using recursion and composition as central operations and are a strict subset of the recursive functions, which are exactly the computable functions.
05:19:25 <alar> somebody help me with the language
05:19:37 <alar> what are computable functions?
05:19:43 <alar> subset or superset?
05:19:46 <basti_> uhm
05:19:56 <basti_> a subset is a set that contains only elements from another set
05:19:58 <basti_> (its superset)
05:20:04 <alar> yes
05:20:10 <basti_> and computeable functions are, well, computeable.
05:20:17 <alar> but what does wikipedia mean?
05:20:23 <basti_> (by a turing machine or its equivalent)
05:20:31 <Pistahh> @where wikipedia
05:20:31 <lambdabot> I know nothing about wikipedia.
05:20:33 <alar> all recursive functions are computable
05:20:38 <basti_> yes
05:20:49 <alar> or only the subset - first-order recursive?
05:21:03 <Pistahh> @where wikipedia -> http://www.wikipedia.org
05:21:03 <lambdabot> I know nothing about wikipedia.
05:21:05 <basti_> ohh
05:21:10 <Pistahh> @help where
05:21:10 <lambdabot>  @where <key>, return element associated with key
05:21:17 <basti_> it seems that i misunderstood that sentence
05:21:23 <Pistahh> @where wikipedia  http://www.wikipedia.org
05:21:24 <lambdabot> I know nothing about wikipedia.
05:21:41 <basti_> it ways: computeable functions are (general) recursive and vice versa
05:21:44 * Pistahh asks for help :)
05:21:54 <alar> Pistahh, you need counterpart of where
05:21:57 <shapr> @wikipedia Epigram
05:21:59 <lambdabot> http://en.wikipedia.org/wiki/Epigram
05:22:00 <alar> maybe @there? =)
05:22:19 <Pistahh> @there wikipedia  http://www.wikipedia.org
05:22:20 <lambdabot> I know nothing about wikipedia.
05:23:55 <basti_> uhm says
05:24:14 <alar> thanks
05:24:36 <basti_> Pistahh: you dont need to do that as there is a wikipedia lookup functions
05:25:08 <Pistahh> basti_: so @where wikipedia should refer to @wikipedia. :)
05:25:36 <shapr> Philippa_: Or maybe we should all switch to sxml?
05:28:42 <Pistahh> basti_: anyways, how to store something for @where?
05:28:57 <basti_> Pistahh: i dont have a clue either
05:29:30 <shapr> @help where
05:29:31 <lambdabot>  @where <key>, return element associated with key
05:29:38 <shapr> @listmodules
05:29:38 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
05:29:38 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
05:29:38 <lambdabot> spell state system todo topic type version vixen where
05:29:44 <shapr> @listcommands where
05:29:45 <lambdabot> where provides: where where+
05:29:45 <Lemmih> @help where+
05:29:45 <lambdabot>  @where+ <key> <elem>, define an association
05:30:34 <Pistahh> @listmodules karma
05:30:35 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
05:30:35 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
05:30:35 <lambdabot> spell state system todo topic type version vixen where
05:30:52 <Pistahh> @help system
05:30:52 <basti_> @listcommands karma
05:30:53 <lambdabot> system provides: echo listchans listcommands listmodules uptime
05:30:53 <lambdabot> karma provides: karma karma+ karma-
05:31:53 <xerox> I don't understand the point of teaching Haskell showing a MissingH lib.
05:32:43 <xerox> s/showing/using/
05:34:05 <alar> @karma+ basti
05:34:06 <lambdabot> basti's karma raised to 1.
05:34:10 <alar> @karma+ shapr
05:34:12 <lambdabot> shapr's karma raised to 11.
05:34:14 <alar> @karma+ Spark
05:34:15 <lambdabot> Spark's karma raised to 1.
05:35:11 <shapr> w00!
05:35:35 <basti_> shapr: you need to balance that
05:35:36 <Pistahh> is there a command to show ppl with the most karma?
05:35:42 <shapr> Balance what?
05:35:47 <basti_> the karma
05:35:55 <basti_> either is too bad if it's too much
05:36:05 * shapr grins evilly
05:36:17 --- mode: ChanServ set +o shapr
05:36:28 <shapr> basti_: I could kick you off the channel, would that help balance my karma?
05:36:29 <Pistahh> shapr: you have to balance karma+ with karma-. :)
05:36:53 * shapr cackles gleefully
05:37:02 <basti_> no because i know it'd only be prentended
05:37:09 <basti_> that wouldnt be really evil
05:37:25 <shapr> dang
05:37:26 <basti_> it's like welfare taxes.
05:37:29 <shapr> I guess I'm just not evil.
05:37:35 --- mode: shapr set -o shapr
05:37:37 <basti_> those don't give good karma as well
05:38:18 * alar is awaiting the begin of karma war
05:40:58 <basti_> but then again, some tibetan monks actually automatized prayer... they have rotateable columns with prayers written on them, and when you rotate those, its thought to be as good as an actual prayer
05:41:23 <basti_> maybe something similar could apply for implementing welfare taxes
05:42:52 <shapr> hoi praseodym, hoe gaat het met jou?
05:43:45 <MarcWeber> basti_: I got this line from sylvan :
05:43:46 <MarcWeber> let randomsR (a,b) g = let (x,g') = randomR (a,b) g in x : randomsR (a,b) g' in (randomsR (1,5::Int) (mkStdGen 54))
05:44:06 <basti_> MarcWeber: great
05:44:13 <MarcWeber> it generates an infinite array of numbers within the range 1..5
05:44:27 <MarcWeber> But I don't know exaclty where to start reading this line? At the list concatenation :?
05:44:32 <basti_> heh
05:44:37 <basti_> maybe at the :
05:44:53 <MarcWeber> basti_: You know the function randomR?
05:45:00 <basti_> you should first seperate the parts of a the let construction
05:45:06 <basti_> uhm, yes
05:46:48 <MarcWeber> Does the part after the : belong to the first let?
05:47:28 <basti_> no to the second
05:47:33 <basti_> or
05:47:34 <basti_> uhm
05:47:35 <basti_> wtf
05:48:03 <basti_> yes into the inner
05:49:45 <MarcWeber> and the in x or in (ran.. does belong to the first,snd let? .. *thinking*
05:50:01 <basti_> try to put parenthenses around it
05:50:10 <basti_> if it breaks, you saw it the wrong way
05:52:20 <cds> 170.
05:52:27 <shapr> cool
05:52:38 <shapr> Hiya cds, learning Haskell?
05:54:52 <shapr> salut stef_
05:55:21 <stef_> salut
05:56:38 <cds> shapr: I'm just here to break the 170 users barrier.. but I've shown interest in learning Haskell in the past :)
05:57:02 <shapr> cds: Well, we've got 171 now, so life is good :-)
05:57:09 <MarcWeber> basti_: What does in mean?
05:57:18 <basti_> @plugs let x=5 in x
05:57:24 <lambdabot> 5
05:57:25 <basti_> its the separator for let
05:57:25 <cds> shapr: heh
05:58:04 <cognominal> well I was cheating , by mistkaes I had two irc client running, stef_ is really cognominal
05:58:13 <Philippa_> re
05:58:39 <Pistahh> cognominal: never do misteaks! ;)
05:59:47 <basti_> mis-steaks?
06:01:20 <cognominal> mis-skate may be, are we surfing aren't we
06:02:11 <cds> Stop talking about food!
06:02:17 * cds 's stomach grumbles
06:02:59 <Pistahh> cognominal: should we also stop talking about pizza?
06:03:16 <Pistahh> and cordon bleu?
06:03:38 * cds cries.
06:06:22 <cognominal> ho, autrijus is here twice, I was in good company when I was two
06:20:58 <cbus> can anyone type some swedish chars on utf8 for me? :)
06:21:19 <ulfdoz_> a <- :)
06:21:20 <Pistahh> cbus: what about some hungarian? :)
06:21:37 <cbus> nah :)
06:21:40 <basti_> √§ happens in sweden doesnt it?
06:21:41 <cbus> running charsetwars.pl
06:21:46 <cbus> want to see if it converts properly
06:22:02 <basti_> (a with diaresis
06:22:27 <cbus> basti_, yeah
06:22:28 <cbus> hmm fucked
06:22:34 <xerox> √§√´√∂√Ø√º√•≈Ø√¢√™√¥√Æ√ª
06:22:50 <cbus> 15:22:12 -!- Irssi: [charsetwars.pl:convert_txt()] Conversion error (in, utf-8, √§√´√∂√Ø√º√•≈Ø√¢√™√¥√Æ√ª, xerox, #haskell,
06:22:53 <cbus>           FreeNode)
06:22:53 <cbus> :)
06:22:56 <cbus> wtf
06:23:12 <xerox> Doesn't irssi support utf-8 by default?
06:23:24 <basti_> no you have to switch on some option usually
06:23:25 <cbus> i want it to convert to iso8859-1
06:23:37 <basti_> better stick to utf-8
06:23:39 <cbus> and they have recode in irssi in 0.9.10 (which isnt released yet)
06:23:46 <cbus> utf-8 isnt default on irc :)
06:23:57 <shapr> It is here and on #haskell.se and #unicycling
06:24:10 <basti_> and lots of other channels on freenode too
06:24:16 <cbus> but not on all the other channels im on
06:24:21 <basti_> because uhm... theres people outside of europe too!
06:24:23 <cbus> this is the first one that actually has utf-8 as default for me
06:24:32 <basti_> (surprise! :)
06:24:54 <cbus> √•√§√∂
06:24:56 <shapr> I wish irc would go utf8 entirely :-/
06:24:57 <cbus> hmm
06:25:06 <cbus> i wouldnt mind
06:25:14 <cbus> but i hate that some are utf8 and some arent :)
06:25:19 <cbus> doesnt work
06:25:27 <basti_> a benevolent charset dictator! ;)
06:25:27 <cbus> bah have work to do
06:25:39 <cbus> keymap dictator too? :)
06:25:43 <xerox> @¬µ
06:25:45 <lambdabot> Maybe you meant: pl wn
06:25:51 <xerox> ih ih.
06:25:51 <cbus> haha
06:25:57 <basti_> @√§
06:25:58 <lambdabot> Maybe you meant: pl wn
06:26:00 <basti_> hmh
06:26:12 <Pistahh> ı˚
06:26:15 <basti_>   
06:26:47 <basti_> btw. there's also #haskell-blah for the rather casual topics :P
06:26:48 <xerox> √ó‚Ç¨¬Æ√∏√ó!
06:26:53 * xerox whistles
06:27:28 <JohnMeacham> I ‚ô° Unicode
06:27:44 <xerox> Oi, ¬ßh√¶!
06:27:58 <JohnMeacham> I ‚ô£ Baby Seals
06:28:39 <basti_> I love characters that don't render
06:28:48 <xerox> I SQUARE basti_
06:29:28 <Pistahh> I !? java
06:30:14 <JohnMeacham> ‚àÉ!x‚ààU.P(x) <=> ‚àÉx‚ààU.(P(x) ‚àß ‚àÄy‚ààU\{x}.¬¨P(x))
06:30:21 <xerox> Lambdas?
06:31:09 <sieni> WTF-8?
06:32:28 <JohnMeacham> Hmm.. I bet there is a better definiton of ‚àÉ!
06:38:05 <joao> :-)
06:39:09 * Heffalump has a prototype charset filter program for IRC (written in Haskell, naturally)
06:39:21 <Heffalump> if anyone wants it, they're welcome, though it has some problems.
06:41:34 <rep> does System.Posix.Process.executeFile fork, before calling execve()?
06:42:59 <rep> hm , it seems like it doesn't
06:53:27 <rep> Linking ...
06:53:28 <rep> ld: warning suggest use of -bind_at_load, as lazy binding may result in errors or different symbols being used
06:53:30 <rep> symbol _dladdr used from dynamic library /usr/lib/libm.dylib(dyldAPIsInLibSystem.o) not from earlier dynamic library /opt/local/lib/libdl.1.dylib(dlfcn.o)
06:53:34 <rep> :(
06:54:24 <basti_> :-o
06:54:36 <rep> any ideas? :)
06:54:43 <xerox> cry
06:54:59 <rep> this is when i import System.Posix.Process (forkProcess, executeFile)
06:55:05 <rep> (on os x)
06:56:26 <rep> well
06:56:51 <rep> why am i using them anyway.
06:58:10 <rep> runProcess should work
07:08:23 <Plex> I haven't had any experience with declarative languages, only imperative. Which style is, if at all, "better"(easier, faster development) at manipulating & parsing strings of text? I do realise alot of that depends on the specific language.
07:08:44 <Plex> and please don't say Perl.
07:09:14 <Khisanth> since when is Perl a style?
07:09:29 <Plex> It isn't, but I think it fits under the 'imperative' style
07:10:02 <Khisanth> Perl fits in several ...
07:10:33 <Philippa_> perl fits under lack of style
07:11:17 <Plex> I didn't want to use perl because it feels too "flimsy", and has alot of other problems, although a good language, but nevermind that
07:13:56 <Heffalump> does anyone use the Haskell PCRE bindings?
07:14:35 <humasect> haskell just may be multi-purpose.
07:15:10 <xerox> Just Right
07:15:23 <humasect> =)
07:15:56 <humasect> if haddock could export tex..
07:17:20 <alar> Heffalump, are there just bindings or PCRE library?
07:18:25 <Trinsic> so many stuffy people working in the IT industry.
07:19:54 <Philippa_> Trinsic: yerwhat?
07:20:01 <Philippa_> (I mean yeah, I dare say...)
07:21:55 <xerox> @index iterate
07:21:57 <lambdabot> Data.List, Prelude
07:22:01 <xerox> @type List.iterate
07:22:03 <lambdabot> forall a. (a -> a) -> a -> [a]
07:24:39 <Heffalump> alar: I thought there were bindings.
07:25:36 <Heffalump> http://repetae.net/john/computer/haskell/hsregex/hsregex-0.2/RRegex/PCRE.hsc [chop off bits of the URL to find the entire thing]
07:27:36 <alar> foreign PCRE :(
07:27:49 <gour> dcoutts: ping
07:27:56 <alar> i don't see why it can't be implemented in haskell
07:28:06 <Heffalump> alar: that'd be effort, though..
07:28:10 <Heffalump> alar: what's wrong with that?
07:28:16 <alar> nothing
07:28:38 <alar> except that I don't know the API of pcre.h :)
07:28:48 <alar> never used it in C
07:28:59 <Trinsic> Philippa_ I gues you take personal offense to that statement.
07:29:36 <Heffalump> alar: read the Haskell API, then :-)
07:30:23 <Heffalump> alar: it looks like it does the hard work of talking to the library and exports some nice easily usable functions
07:31:37 <praseodym> what would be a good GUI toolkit for haskell, like there is Qt and GTK for C(++)?
07:32:15 <gour> @where gtk2hs
07:32:16 <lambdabot> http://haskell.org/gtk2hs/
07:32:17 <humasect> wxhaskell or gtk2hs
07:32:25 <humasect> i think even htoolkit is useable now
07:32:37 <alar> Heffalump, if reading PCRE.hsc is enough to understand the API, then I'll use it
07:32:53 <Heffalump> it seems to be at a quick glance to me
07:32:58 <Heffalump> it has haddock, so perhaps you want to read the HTML
07:33:04 <alar> at least while I'm too lazy to write own PCRE library in haskell =))
07:33:16 <Heffalump> though that hasn't been generated in the URL I'm looking at
07:33:29 <alar> oh, with haddock it's much easier
07:34:44 <boegel> shapr: 176 !
07:34:50 <shapr> w00!
07:36:53 <shapr> alar: I think there is a native implementation or two.
07:37:09 <basti_> wb paolino
07:37:14 <paolino> :)
07:37:41 <paolino> I think I'm realizing a better vision of the problem.
07:37:50 <basti_> :)
07:39:03 <paolino> Every possible clustering tree is an evolutionary state, the ones you want to put in the nodes value of the research tree
07:39:18 <shapr> hiya b0gg1e
07:39:29 <b0gg1e> hi!
07:39:32 <shapr> How's code?
07:40:38 <b0gg1e> not doing to much haskell lately.
07:40:45 <shapr> aw, why not?
07:40:48 <b0gg1e> although for my last cs exams in databases i implemented some exemplary algorithms in haskell.
07:41:21 <b0gg1e> most of my time i have to write java now... at work and for a university project.
07:41:33 <b0gg1e> in the remaining time i'm reading all i can find on topic maps.
07:42:11 <paolino> basti_,then the expand function applies to the research tree nodes and creates some possible clustering tree derived from the one represented in the expanding node
07:42:19 <b0gg1e> another thing: i found dealing with non-hierarchical data structures (graphs) impractical in haskell.
07:42:31 <basti_> paolino: i'm sure you know what you're talking about. That is a good thing.
07:42:41 <shapr> b0gg1e: How so? Were you using Erwig's FGL?
07:42:57 <shapr> b0gg1e: Have you seen the "Practical Graph Manipulation" article from this month's TMR?
07:43:27 <b0gg1e> no although i know about them. if i remember correctly FGL has problematic complexity (insert was logarithmic if i remember correctly).
07:43:32 <b0gg1e> no.
07:43:48 <b0gg1e> i should read that.
07:44:30 <shapr> http://www.haskell.org/tmrwiki/PracticalGraphHandling
07:44:56 <shapr> b0gg1e: What sort of graph manipulation are you doing?
07:46:14 <b0gg1e> i'm into sematic web (read topic maps) lately and wondered how to effectively realize a data structure like that.
07:46:35 <Philippa_> Trinsic: I'd guess you didn't understand what I actually said
07:47:03 <shapr> b0gg1e: In that case, have you seen Graham Klyne's Semantic Web libraries and apps in Haskell?
07:47:10 <b0gg1e> also for databases i wanted to implement b*-trees for the fun of it, but wondered how to do that effectively *outside* the IO Monad (destructive array updates...)
07:47:39 <b0gg1e> no not yet, wasnt in haskell-land that much lately.
07:47:42 <shapr> You could use STArray.
07:48:25 <Philippa_> which'd trade one monad for another of course - that may not be what you want, but hey
07:48:50 <shapr> b0gg1e: http://www.ninebynine.org/RDFNotes/Swish/Intro.html
07:48:58 <shapr> hi trez
07:49:02 <trez> hello :)
07:49:11 <shapr> How's code?
07:49:11 * poetix wonders if you could use the Zipper with b*-trees
07:49:29 <shapr> poetix: What about Oleg's subcontinuations zipper?
07:49:36 <poetix> That's the one I meant
07:50:02 <poetix> Updatable b*-trees with transaction semantics - yummy
07:50:34 <shapr> b0gg1e: As poetix says, Oleg's "Zipper as Tree of Subcontinuations" code will give you fast, large, mutable, datatypes for a b* tree.
07:51:05 <b0gg1e> that does sound interesting.
07:51:43 <b0gg1e> shapr: thanks for all the links, will look into these later.
07:51:58 <shapr> Sure
07:52:14 <paolino> when has haskell planet earth invasion been planned ?
07:52:28 <poetix> You think we'd tell you?
07:52:40 <shapr> paolino: There's nearly 180 people on the channel. The invasion has already begun!
07:52:41 <paolino> No
07:53:00 <poetix> We probably would, actually. We're quite open about our world-domination plans.
07:53:33 <alar> shapr: I'm sure if there is no native implementation it will appear soon. Regexp is easy to implement with functional power at hand
07:54:56 <Heffalump> aren't PCREs quite complicated?
07:55:45 <shapr> I thought they were relatively simple, at least compared to a lot of other stuff Haskell already does.
07:56:38 <shapr> I think the PC part isn't much extra on top of standard RE.
07:57:01 <b0gg1e> BTW is it possible to write a shared library in ghc that can be interfaced easily from the c side?
07:57:14 <poetix> b0ggle: Yes.
07:57:24 <poetix> b0gg1e, even: Yes.
07:57:47 <poetix> Haskell FFI is - well, it's no harder than FFI in most other languages, anyway
07:57:50 <b0gg1e> i wonder how one would pass in and out complex data structures and state.
07:58:06 <poetix> Write marshallers to marshall them to C datatypes
07:58:23 <b0gg1e> hmm.
07:58:37 <shapr> c2hs has nice marshalling support.
07:58:49 <b0gg1e> if you want something like a "handle" you propably have to live in the IO monad anyways.
07:58:51 <poetix> Yes, it doesn't have to be a totally manual process
07:58:58 <b0gg1e> ah will look into that, too.
07:59:05 <paolino> how I cut a list in pieces of at most k elements ?
07:59:30 <shapr> paolino: recursively take k ?
07:59:47 <paolino> take yes
08:00:57 <poetix> @eval take 4 [1,2,3]
08:00:59 <lambdabot> [1,2,3]
08:01:37 <poetix> But...
08:01:52 <poetix> @eval (take 4) . (take 4) [1,2,3,4,5,6,7]
08:01:55 <lambdabot> <irc>:1:11:
08:01:55 <lambdabot>   Expecting a function type, but found `[a]'
08:01:55 <lambdabot>   Expected type: a1 -> [a]
08:01:55 <lambdabot>   Inferred type: [a2]
08:01:55 <lambdabot>   Probable cause: `(take 4)' is applied to too many arguments in the
08:01:56 <lambdabot> call
08:01:58 <lambdabot>    ((take 4) [1, 2, 3, 4, 5, 6, 7])
08:02:00 <lambdabot>   In the second argument of `(.)', namely `(take 4) [1, 2, 3, 4, 5,
08:02:02 <lambdabot> 6, 7]'
08:02:09 <poetix> @eval (take 4) . (take 4) $ [1,2,3,4,5,6,7]
08:02:11 <lambdabot> [1,2,3,4]
08:02:11 <alar> @type splitAt
08:02:12 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:02:14 <humasect> i find it a little strange that hs-plugins has System.Lang.Haskell when there is Language.Haskell in base.. they can't play together ?
08:06:06 <shapr> poetix: Hey, I had an idea about a web framework in Haskell..
08:06:14 <poetix> Another one?
08:06:24 <humasect> :o
08:06:49 <shapr> poetix: Was talking to pesco and Malcolm, Malcolm mentioned that Haskell2Xml is the ShowXml I've been wishing for, and pesco talked about a graph structure to automatically build navigation.
08:07:29 <poetix> That sounds promising
08:08:04 <poetix> Besides being a typeclass, what does Haskell2XML give you?
08:08:33 <shapr> I like the idea of Haskell2Xml for the 'Naked Datatypes' approach.
08:08:41 <shapr> I don't know, I haven't jumped into HaXml yet.
08:09:31 <shapr> musasabi's hswebforms does something like this already, automatically deriving edit/view forms from HaskellDB database tables/rows.
08:10:26 <poetix> Would you output XHTML directly, or pass XML to XSLT to generate pages?
08:10:50 <shapr> the latter
08:10:53 <poetix> Or something other than XSLT (I've always wanted a non-XML syntax for that language)
08:11:12 <shapr> HXmlToolbox does some XSLT stuff itself.
08:11:36 <poetix> It would be nice to have the transforms specified entirely using some DSEL
08:11:43 <shapr> The good side of XML + XSLT is that Mozilla can process that on the client side.
08:12:04 <poetix> I find it useful to do XSLT transforms with parameters, though, which isn't supported
08:12:26 <shapr> Ok, so assuming this idea will really work, how do you change the Graph?
08:12:58 <poetix> You have some serialized representation of it stored somewhere, presumably
08:13:31 <shapr> I'm just trying to figure out how to get all of today's webapp server features with this sort of Haskell-esque approach.
08:13:44 <shapr> hiya fer, learning Haskell?
08:14:03 <paolino> splitter [] power =[]
08:14:04 <paolino> splitter list power  = [taken]++splitter rest power
08:14:04 <paolino>   where (taken,rest)=splitAt power list
08:14:13 <paolino> teachings welcome
08:14:38 <poetix> shapr: Do you want on-line site configuration, the ability to bring new pages online or schedule them to come online at a particular date?
08:15:01 <shapr> poetix: I want a Haskell-esque approach, whatever that entails.
08:15:42 <poetix> I like the idea of having a purely functional implementation of the sitemap, such that old values are still accessible
08:15:51 <poetix> So you can roll forward and roll back between versions of the site
08:16:40 <alar> paolino: I've invented just the same thing
08:16:45 <poetix> Ditto for content - every page has a history of diffs, like a wiki page
08:16:59 <shapr> poetix: Or just make darcs part of the framework..
08:17:03 <KrispyKringle> shapr: What's the new project? A CMS?
08:17:09 <shapr> KrispyKringle: Yeah, sort of...
08:17:12 <KrispyKringle> Neat.
08:17:16 <KrispyKringle> shapr: More details? :P
08:17:30 <poetix> shapr: Is there a programmatic interface to darcs, such that you can query the history of an item etc.?
08:17:32 <KrispyKringle> shapr: A few weeks ago I wrote a bit of a Python wiki to try out some new ideas...
08:17:45 <shapr> I've been wishing for a Haskell webapp server for years. The brains and time have always been available, but the coherent idea has been missing. I think I know part of it now.
08:18:00 <shapr> poetix: If not, I can add it.
08:18:12 <KrispyKringle> shapr: You don't really need to use something as big as darcs, though. You aren't going to have any branching, presumably. You could just keep a list of diffs for a page.
08:18:24 <shapr> You *will* have branching.
08:18:26 <KrispyKringle> And diff code is pretty small. I think I even remember seeing a Haskell example somewhere.
08:18:27 <poetix> I think darcs makes the pure functional approach to data explicit - it's the kind of VCC a Haskell programmer would create
08:18:29 <KrispyKringle> Why would you have branching?
08:18:38 <shapr> Because, development versions of websites happen all the time.
08:18:45 <KrispyKringle> Hmm.
08:18:56 <KrispyKringle> OK, I guess.
08:18:59 <shapr> Zope/Plone each have their own support for 'versions' where you can sort of not commit a bunch of changes.
08:19:02 <poetix> But you typically have development, staging and production on separate servers
08:19:10 <KrispyKringle> Right.
08:19:14 <shapr> poetix: Only in a 'real' development environment.
08:19:20 <KrispyKringle> I thought the point of the diffs was just to allow people to see different, older versions of a page.
08:19:22 <poetix> Or at least sandboxed from each other
08:19:29 <shapr> My clients have trouble scraping up a single 600MHz server.
08:19:38 <KrispyKringle> Not to allow development to be done on the production machine.
08:19:46 <KrispyKringle> Although that is a kinda neat idea.
08:19:57 <paolino> shapr I inject my opinion and experience .Store as much as possible in an rdf graph.Possibly later it will pay
08:20:02 <shapr> KrispyKringle: Sanity dictates that development not happen on the production machine. Clients are often insane.
08:20:09 <KrispyKringle> Haha.
08:20:13 <KrispyKringle> OK. I take it back. :P
08:20:15 <shapr> paolino: Why?
08:20:31 <KrispyKringle> shapr: I also question doing the XSLT on the client side. What's the advantage?
08:20:33 <shapr> paolino: I'm a great fan of YAGNI.
08:20:34 <poetix> Export to RDF-literate tools, I guess
08:20:36 <KrispyKringle> Other than less compatibility.
08:21:05 <shapr> paolino: I'll see if Data.Graph values can be dumped to RDF easily.
08:21:12 <poetix> Maybe use of a triplestore for a back-end
08:21:22 <paolino> yes
08:21:44 <poetix> RDF graphs have some idiosyncrasies, like the difference between URLs and literals:
08:21:45 <paolino> and store also programming information there
08:22:03 <poetix> two instances of the same URL are the same node, two instances of identical literals are different nodes
08:22:06 <paolino> so you can scale the rendering weight
08:22:36 <poetix> Sounds like Chandler...
08:22:51 * poetix sniggers unpleasantly behind his hand
08:23:06 <paolino> I'm not addressing RDF as syntax but triples as logics
08:23:27 <shapr> I asked Malcolm about using 'subDTDs' for 'typechecking' something like TAL. He said that was a planned feature of HaXml, but the funding ran otu.
08:23:44 <paolino> anyway it is just an opinion
08:23:53 <shapr> paolino: I'll check it out, thanks for the input :-)
08:24:17 <shapr> But I don't know anything about RDF or storage as triples, so it'll take me a few days to look around.
08:24:29 <poetix> shapr: Take a look at Tripoli...
08:24:34 <shapr> ok
08:25:20 <shapr> poetix: So how do you build a CMS with this structure?
08:25:58 <poetix> Well, versioning is a major feature of CMSes, and versioning happens to be something that a pure semantics supports very nicely
08:26:22 <poetix> The more I think about it, the more I like the idea of multiple branches also
08:26:44 <poetix> One site customised for multiple purposes
08:27:32 <poetix> I don't think the details of serving HTTP requests or building web pages are the interesting design areas here - I think it's the data model that wants thinking about
08:28:00 <pesco> poetix: I agree.
08:28:38 <shapr> Yes, I think so too.
08:28:41 <poetix> Can you have a datatype that represents a site at times T1...n, for users U1...n
08:28:42 <paolino> Our server is now down for OS switching, and haskell infection but we have code inside contents (Uries) and even python classes has an URI and every possible little or big thing expressed as triples graph.Even code dependencies.The result is at least amazing
08:29:59 <poetix> There are some interesting arguments to be had about triples (as "binary relations") versus the full relational model for this kind of thing
08:30:56 <paolino> I'm not an expert and was very skeptic, but now I can serialize the server functionalities
08:31:06 <shapr> Crazy as it sounds, I think Oleg's transactional subcontinuation zippers are a good approach here.
08:31:38 <paolino> users structures,what ever,now I go back in my haskell ignorance
08:32:13 <shapr> poetix: subcont zipper is sort of like multiple futures.
08:32:29 <poetix> Having a data model for all the pieces of your system is very powerful, and being able to do graph-traversals and transformations on that model - if it is graph-shaped - is important (and is also where SQL DBMSs tend to fall down)
08:32:44 <poetix> Yes, it seems like a theory of patches for data
08:32:54 <shapr> Yes, exactly.
08:33:06 <b0gg1e> where can i read about oleg's zippers?
08:33:58 <b0gg1e> paolino: is that code public?
08:34:06 <shapr> @google oleg zipper subcontinuation
08:34:07 <lambdabot> http://www.scannedinavian.com/2005-04-30.html
08:34:09 <shapr> whoops
08:34:40 <shapr> That's my blog :-)
08:35:00 <b0gg1e> :-)
08:36:09 <poetix> OK, back to the zipper-as-subcontinuation
08:36:22 <paolino> bogg1e
08:36:25 <paolino> yes
08:36:34 <paolino> it is heavy python
08:37:05 <paolino> it uses bdb as backend
08:37:12 <poetix> How would you persist a "zipped" data structure mid-"zip", along with details of the "zipping" in progress?
08:37:32 <paolino> for triples and a directory on fs for contents
08:38:41 <poetix> It seems to me that the zipper gives you a very rich and powerful semantics for all the transitional states between one definite version of a data structure and another definite version.
08:39:12 <shapr> Isn't the zipper a datastructure itself?
08:39:44 <shapr> It's just like a rubik's cube with a single window, or like the 'fifteen' puzzle where only one square has an open space.
08:40:00 <shapr> b0gg1e: Anyway, Oleg has published two parts of his Zipper series.
08:40:05 <paolino> b0gg1e, IMO it's more powerful than Zope/Plone as idea ,it's working also, but not so easy to fire
08:40:29 <shapr> Speaking of which, maybe we should ask Oleg about this?
08:40:39 <shapr> I think I owe him an email or three.
08:40:39 <b0gg1e> so where to get it?
08:40:56 <b0gg1e> i was thinking about writing something like that for topicmaps.
08:41:10 <paolino> svn co www.pytypus.org/pytypus
08:41:30 <paolino> it has no dependencies
08:41:55 <b0gg1e> could not connect to server?
08:42:04 <shapr> poetix: The way I understand it, the subcont zipper is such that each node is a continuation/cursor (database-cursor style) to a possible future.
08:42:08 <b0gg1e> svn co http://www.pytypus.org/pytypus
08:42:26 <poetix> shapr: Right. So how do you persist something like that?
08:42:33 <paolino> I have a look,aruba is working on my machine
08:43:09 <shapr> Isn't it a datastructure already? http://www.haskell.org/hawiki/TheZipper
08:43:17 <shapr> Are Oleg's Zippers different?
08:43:39 <paolino> svn co svn://www.pytypus.org/pytypus
08:44:13 <poetix> Not every data structure is easily persistable. Some contain things like closures.
08:44:40 <tromp> The base of liberties in Go is 2.975734192
08:45:01 <basti_> :-o
08:45:03 <trez> is there an easy way to convert integers to binarynumbers?
08:45:11 <tromp> sure
08:45:16 <poetix> I don't know how Oleg represents subcontinuations, but would guess that they have a type with a -> in the middle.
08:45:28 <shapr> poetix: Here's part one - http://www.haskell.org//pipermail/haskell/2005-April/015769.html
08:45:58 <basti_> trez: look at that http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Bits.html
08:46:31 <trez> basti_: thank you :)
08:46:31 <paolino> data Tree value=Foglia value how I create Foglie with elements of a list as values
08:46:49 <paolino> map Foglia [1,2,3]
08:47:11 <Flawless> what does the tilde in "f x ~(p,q) = (x+p, q+1" mean? The function itself is clear enough
08:47:20 <basti_> that will give [Foglia 1, Foglia 2,...]
08:47:22 <Flawless> +), of course
08:47:26 <poetix> The problem is, how to make something that looks like (Monad m) => (Term -> m (Maybe Term, Direction)) -> Term -> m Term an instance of Read and Show
08:47:34 <basti_> Flawless: thats a strictness annotation.
08:47:39 <paolino> it gives an error
08:47:57 <paolino>     No instance for (Show (Tree a))
08:47:57 <paolino>       arising from use of `print' at Top level
08:48:00 <basti_> Flawless: basically it keeps the tuple unevaluated until one of its parts is evaluated
08:48:13 <basti_> paolino: that means "can't show (Tree a)"
08:48:29 <paolino> in the interpreter ?
08:48:34 <Flawless> basti_: Ok, so that's "just" a compiler hint?
08:48:55 <basti_> Flawless: not really, the version without ~ might break not as often.
08:49:01 <basti_> paolino: generally.
08:49:14 <Flawless> basti_: break not as often?
08:49:20 <Flawless> basti_: but ok, it's important :)
08:49:25 <basti_> well for example the tuple could be undefined
08:49:48 <Flawless> Yes, ok
08:49:49 <basti_> then ~(p,q) might not break under circumstances
08:50:02 <Flawless> so ~(p,q) is only eval'd if I use p or q?
08:50:03 <basti_> (i.e. if neither p nor q are addressed for some reason)
08:50:06 <basti_> yup
08:50:10 <Flawless> whereas (p,q) would be in any case?
08:50:16 <basti_> yup
08:50:18 <Flawless> ok
08:50:22 <basti_> (p,q) looks if there is a tuple
08:50:26 <Flawless> but I thought haskell was (very) lazy?
08:50:33 <ibid> Flawless: in this case it's a hint, but it has other kinds of uses where it's not a hint
08:50:36 <basti_> yes it is. not with destructing things though
08:50:39 <alar> (p,q) is matched against tuple constructor in any case
08:50:54 <Flawless> oh, and ~(p,q) is not?
08:50:57 <alar> yes
08:51:01 <Flawless> I see
08:51:06 <Flawless> thanks all :)
08:51:29 <Flawless> Now I can present this research paper without not understanding the examples given ;)
08:51:36 <poetix> shapr: This is the Zipper data structure: Zipper term (CC r m (Maybe term, dir) -> CC r m (Zipper r m term dir)). Suppose one of these represents your site map. When it's not part of a running Haskell process, where does it go (flat file, database) and how does it get there (marshalling, unmarshalling)?
08:51:38 <basti_> :P
08:51:44 <alar> if p or q are not used you may feed ~(p,q) with something_that_is_not_a_tuple
08:51:57 <Flawless> alar: yes
08:52:01 <shapr> poetix: SerTH ?
08:52:06 <mflux> so it affects typing too?-o
08:52:40 <poetix> Can SerTH do continuations? Functions from one continuation to another?
08:52:45 <shapr> Don't think so.
08:52:51 <ibid> Flawless: something i've sometimes done is foo (1, ~(Foo a b)) = ..., which works even if Foo is not the only constructor, as long as every time the first element is 1, the second element is a Foo
08:53:09 <wagerlabs> howdy
08:53:13 <Flawless> ibid, oh, neat
08:53:18 <shapr> hiya wagerlabs
08:53:40 <basti_> i think we agree that it's a pretty esoteric feature
08:53:41 <ibid> Flawless: gah, sorry, that's a bad example
08:53:45 <wagerlabs> do x <- b means x is assigned b, right?
08:53:47 <basti_> :P
08:53:59 <basti_> wagerlabs: thats a special syntax for cute fuzzy pink things
08:54:01 <shapr> wagerlabs: Not really, it means b is executed and its result is assigned to x.
08:54:08 <ibid> Flawless: foo x ~(Foo a b) | x > 0 = a + b | otherwise = 0
08:54:08 <wagerlabs> monads, yes
08:54:11 <Flawless> ibid: Well, you tried ;)
08:54:28 <ibid> Flawless: in which case when x is <= 0, it does not matter whether the second parameter is a Foo or not
08:54:35 <wagerlabs> do x <- b
08:54:36 <wagerlabs> let as = absSeqComponents a
08:55:00 <mflux> so, is that a pretty thing to do?-)
08:55:02 <wagerlabs> i understand everything that follows b is executed but what's the point of having b in there?
08:55:11 <wagerlabs> instance Encode Journey where
08:55:11 <wagerlabs> decode a b =
08:55:11 <wagerlabs> do x <- b
08:55:15 <Flawless> ibid: ok, I think I understand what you're getting at
08:55:24 <Flawless> ibid: otherwise is a haskell keyword, right?
08:55:50 <ibid> Flawless: no, otherwise is a constant in the standard library
08:55:56 <basti_> i think "otherwise" is just a redefinition of "True"
08:55:57 <ibid> Flawless: it's defined otherwise = True
08:56:01 <Flawless> ibid: ok, but close :)
08:56:45 <Flawless> so is it <expr> | <case> | ... | <case>  ?
08:56:52 <shapr> paolino: Is pytypus.org webserver down?
08:57:23 <ibid> Flawless: no, it's <pattern> | <test> = <expr> | ... | <test> = <expr>
08:57:34 <shapr> poetix: Ok, so zipper serialization might be a problem... but the Data.Graph value holding Haskell2Xml sounds gorgeous.
08:57:34 <ibid> Flawless: it's syntactic sugar for the case construct
08:57:36 <Flawless> ibid: yes, that's what I meant by <case> :)
08:57:44 <Flawless> ibid: oh, I see
08:58:00 <ibid> Flawless: of course, the real one needs line separators
08:58:06 <Flawless> yes
08:58:08 <ibid> Flawless: because of the layout rule
08:58:13 <Flawless> layout rule?
08:58:21 <ibid> Flawless: and note that i said <pattern>, not <expr>
08:58:24 <Flawless> yes
08:58:31 <Flawless> although, what can I put in <pattern>?
08:58:31 <ibid> Flawless: the rule that defines what indentation means
08:58:38 <alar> Has someone read http://www.haskell.org/tmrwiki/NumberParamTypes ?
08:58:44 <paolino> shapr yes,until I'm tripping on haskell No I put it up now
08:58:53 <basti_> alar: yes but i got sick
08:59:00 <ibid> Flawless: a function pattern is f <simple-pattern> ... <simple-pattern>
08:59:02 <shapr> alar: I read it, I'm the editor of TMR :-)
08:59:15 <Flawless> ibid: where f is the name, right?
08:59:27 <Flawless> ibid: or actually the letter f?
08:59:27 <alar> basti_: how does the concept of number-parameterized types fit into language?
08:59:30 <ibid> Flawless: and a simple pattern is <variable> or <constant> or <constructor> <simple-pattern> ... <simple-pattern>
08:59:35 <ibid> Flawless: the name being defined
08:59:40 <Flawless> ibid: ok, check
08:59:42 <basti_> alar: uhm, thats what the paper is talking about, actually
08:59:44 <ibid> Flawless: this is the syntax for normal function definition
08:59:47 <Flawless> yes
08:59:49 <shapr> alar: Spoken or programming language?
08:59:53 <basti_> oh
08:59:59 <basti_> yes, good question
09:00:00 <poetix> shapr: If I could figure out a representation of the Zipper in terms of, say, relations and operations on those relations - export it from the Haskell type system, and express it in terms that an RDBMS can work with, then that would be a major result.
09:00:02 <ibid> Flawless: of course, my definition of a pattern is a simplification
09:00:06 <alar> shapr: haskell and implementations
09:00:14 <Flawless> ibid: yes, I thought so
09:00:34 <alar> you can parameterize type with type
09:00:41 <alar> but with number?
09:00:48 <Flawless> ibid: ok, thanks for the help :)
09:00:52 <shapr> alar: Value types let you check list lengths, check matching vector sizes, check matrix calculations and much more.
09:00:53 <ibid> Flawless: np :)
09:00:56 <Flawless> ibid: I have to get back to the presentation
09:01:23 <alar> shapr: yes, it's useful, but how can I define Vector of n type?
09:01:32 <shapr> poetix: If you can Show it, you can throw it into an RDBMS.
09:01:36 <shapr> alar: The article shows you.
09:01:42 <poetix> Yes, but I can't Show it!
09:01:54 <alar> without inventing new GHC extensions?
09:02:03 <alar> I'll read it then :)
09:02:31 <poetix> The Zipper datatype lives inside a fairly complex type system. The problem is how to export it from that type system so that it can live (or sleep) on a hard disc somewhere
09:02:41 <shapr> alar: If you already know how to build Peano numbers in lambda calculus, think of that applied to type classes.
09:03:59 <shapr> poetix: betcha Oleg knows how :-)
09:07:29 <poetix> shapr: Yes, I think what we need is inside understanding of what the Haskell version of Oleg's Zipper actually represents - then we can work out how to create a serialized representation of it.
09:08:18 <nnunley> Hrm.  Are there any pointers for getting ghc 6.5's System.Console.Readline to compile under OSX?
09:08:49 <Lemmih> nnunley: Is there a specific reason you're using 6.5?
09:09:09 <nnunley> Lemmih:  Curiosity.  I have a working 6.4.
09:09:46 <xerox> paolino: add 'deriving (Read,Show)' at the datatype definition.
09:13:29 <shapr> 181 on #haskell, whee!
09:13:33 <wagerlabs> abcd_to_integer :: ABCD -> Integer
09:13:33 <wagerlabs> abcd_to_integer (ABCD (a,b,c,d)) = rev_num a * 2^(96 :: Int)
09:14:06 <wagerlabs> what does (ABCD (a, b, c, d)) mean in the second line? is this constructing an ABCD on-the-fly?
09:14:24 <basti_> no it's actually destructing it
09:14:38 <basti_> ABCD seems to serve as a not-too useful tag for a quadruple
09:14:50 <wagerlabs> basti_: type alias?
09:15:00 <xerox> More a newtype.
09:15:07 <basti_> it should be one, but a alias doesn't have a constructor
09:15:10 <wagerlabs> newtype ABCD = ABCD (Word32, Word32, Word32, Word32) deriving (Eq, Show)
09:15:12 <wagerlabs> cool
09:15:30 <xerox> A newtype is a labelled synonym, more or less :-)
09:15:35 <basti_> yep
09:16:08 <basti_> macro-like type = "type", same with constructor = "newtype", several constructors = "data"
09:16:09 <xerox> It's useful, for example, to get more understandable error message, above other means.
09:16:16 <basti_> yes
09:16:34 <wagerlabs> ok, last question... (bs!!1) what's the !!?
09:16:40 <xerox> Thankfully I have the proof-checker basti synched on my stdout.
09:16:45 <xerox> @type (!!)
09:16:50 <lambdabot> forall a. [a] -> Int -> a
09:17:08 <basti_> List indexing
09:17:09 <xerox> 'list !! n  takes the nth element out of list'
09:17:15 <wagerlabs> ah, ok
09:17:18 <wagerlabs> thanks a lot guys
09:17:23 <xerox> You're welcome.
09:17:28 <xerox> Bye bye.
09:17:54 <basti_> -g-
09:18:13 <shapr> poetix: So, time to study Oleg's articles, and ask him for the third part...
09:18:26 <poetix> shapr: Where's part two, btw?
09:20:08 <paolino_> triple db and contents server up
09:20:21 <alar> Haskell98 extensions to multi-parameter classes with functional dependencies and higher-ranked types
09:20:35 <alar> what are classes with functional dependencies?
09:20:38 <paolino_> indexer up
09:21:01 <Lemmih> alar: class A b c | b -> c
09:21:03 <paolino_> yeppa renderer up
09:21:23 <alar> Lemmih: where is it documented
09:21:33 * alar doesn't understand this notation
09:22:11 <alar> part of haskell98 I don't know yet
09:22:42 <paolino_> someone spammed it but it's up at port 6666
09:23:32 <nnunley> Lemmih:  Seems that Apple uses the NetBSD readline library, rather than the GNU readline library.
09:24:55 <paolino_> I go and fix the triples spammed
09:25:27 <Trinsic> Does microsoft handle haskell through .NET?
09:25:40 <Trinsic> i recall there being a VM or something for functional languages like SML.
09:26:15 <Lemmih> alar: http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies
09:27:36 <shapr> poetix: Haven't found it yet...
09:28:53 <poetix> Hey, quickie poll: Hands up if you just started a university course with some Haskell content
09:30:36 <rep> blah
09:30:39 * poetix tries to count the hands, and fails, because this is IRC for pete's sake
09:30:51 <rep> System.Posix doesn't work on OS X
09:30:52 * nnunley grins at poetix.
09:30:55 <rep> what a pain in the ass
09:30:59 <alar> thanks!
09:31:13 <shapr> poetix: I think this is it - http://www.haskell.org/pipermail/haskell/2005-May/015844.html
09:31:16 <poetix> Trinsic: You'll be wanting F#
09:31:23 <nnunley> rep: Fun.
09:31:30 <poetix> Which is an ML-in-dotnet
09:31:45 <rep> Linking ...
09:31:45 <rep> ld: warning suggest use of -bind_at_load, as lazy binding may result in errors or different symbols being used
09:31:48 <rep> symbol _dladdr used from dynamic library /usr/lib/libm.dylib(dyldAPIsInLibSystem.o) not from earlier dynamic library /opt/local/lib/libdl.1.dylib(dlfcn.o)
09:31:51 <rep> etc
09:32:38 <rep> why oh why
09:33:07 <nnunley> rep:  I suggest building 6.4 with Darwin ports.  Haven't had that particular problem.
09:33:56 <rep> nnunley % port installed | grep ghc                         [18:33]
09:33:56 <rep>   ghc 6.4_8+darwin_8 (active)
09:34:18 <nnunley> rep: Oh well.
09:34:52 <nnunley> rep: Same here.  What gcc version?
09:35:00 <rep> 4
09:35:11 <rep> how do i switch to 3?
09:35:14 <nnunley> rep:  I've had to use 3.3.
09:36:01 <nnunley> gcc_select 3.3
09:36:40 <kowey> ghc 6.4.1 works with gcc 4.0, it seems
09:36:57 <kowey> (port selfupdate)
09:36:58 <rep> kowey does importing System.Posix work?
09:37:54 <kowey> eh... i think so... i do it, at least :-)
09:37:54 <rep> nnunley do you think i should recompile ghc with gcc 3?
09:38:19 <kowey> but the System stuff has always been problematic for me (so i tend to avoid touching it)
09:38:27 <rep> well, i guess i'll upgrade to 6.4.1
09:38:30 <nnunley> rep:  Let me confirm that I have System.Posix working correctly, first.
09:38:48 <kowey> rep: do you use wxhaskell?
09:38:56 <rep> kowey no
09:40:00 <kowey> k... otherwise, i was going to warn about looming trouble :-)
09:40:02 <nnunley> rep:  Yes.  I have things using System.Posix successfully with ghc 6.4_8+darwin_8 and gcc 3.3
09:41:11 <dcoutts> gour, pong
09:41:29 <rep> ok, thanks
09:41:34 <gour> dcoutts:hi duncan, i'm back here and pulled few hide patches
09:41:58 <rep> well, i guess i'll take a 8 hour break, while ghc recompiles :)
09:42:27 <gour> Dodaj proizvod u konfigurator  10424  Optimum raƒçunala (www)
09:42:31 <gour> Dodaj proizvod u konfigurator  10424  Optimum raƒçunala (www)
09:42:42 <gour> dcoutts: hIDE builds but gives: hIDE: unknown exception
09:42:58 <gour> dcoutts: forget those garbage pasted before :-(
09:43:10 <ulfdoz_> translate it! ;)
09:43:41 <gour> ulfdoz: add item to the configurator ...
09:45:05 <ulfdoz_> I c. My first polish words.
09:45:36 <gour> ulfdoz_: Polish?
09:46:21 <ulfdoz_> gour: I guessed. English is the only foreign language I know.
09:46:48 <gour> ulfdoz_: then it's not a bad guess - it's Croatian
09:47:25 <dcoutts> gour, you need to edit plugins/haskellSense/src/Hide/CommonSense/Haskell.hs line 28 to set your ghc path. It's only a temporary hack, don't worry.
09:47:32 <ulfdoz_> i.e. guessing has higher chances to be correct than claiming to know nothing without trying and having also no result. :)
09:48:24 <kowey> got a stumper from a friend here:
09:49:04 <kowey> let f x y = x + y
09:49:06 <kowey> :t f
09:49:17 <kowey> (Num a) => a -> a -> a
09:49:20 <kowey> nice and polymorphic
09:49:28 <kowey> let g = \x y -> x + y
09:49:30 <kowey> :t g
09:49:36 <kowey> Integer -> Integer -> Integer
09:49:39 <kowey> why?
09:49:44 <dcoutts> it's the monomorphism restriction
09:49:49 <kowey> hmm..
09:49:50 <kowey> have a link
09:49:51 <kowey> ?
09:50:10 <kowey> ahh... gentle guide
09:50:10 <dcoutts> @wiki Monomorphism
09:50:11 <kowey> thx
09:50:11 <lambdabot> http://www.haskell.org/hawiki/Monomorphism
09:50:27 <dcoutts> oops
09:50:31 <dcoutts> @wiki MonomorphismRestriction
09:50:31 <lambdabot> http://www.haskell.org/hawiki/MonomorphismRestriction
09:50:34 <dcoutts> there
09:50:41 <kowey> many thanks
09:51:41 <dcoutts> kowey, it's well asknowledged that it's a quirk in the language, though there is a rationale for it
09:52:20 <xerox> paolino_: how's it going?
09:53:02 <paolino_> with haskell slow-fine
09:53:49 <rep> yay for darwinports
09:54:01 <rep> won't let me upgrade/uninstall ghc
09:54:01 <gour> dcoutts: i get lot of: file name does not match module name `Main' in th console
09:54:19 <dcoutts> gour, yep that's due to another hack
09:54:24 <Lemmih> *sigh*
09:54:31 <gour> dcoutts: and 'Main' in module Main where is underlined?
09:54:55 <dcoutts> gour, it's currently 'TempModule'
09:55:02 <gour> dcoutts: ok, i see that hIDE is for hackers only :-)
09:55:08 <dcoutts> it's just a temporary hack, don't worry :-)
09:55:28 <gour> just a joke
09:55:39 <dcoutts> we promised Lemmih we wouldn't report any bugs if he showed us the code :-)
09:55:50 <dcoutts> so consider it a preview :-)
09:56:12 <gour> ok, i'll shut up my mouth ;)
09:56:16 <dcoutts> we're lucky to see/run the code at all :-)
09:56:21 <gour> sure
09:56:33 <paolino_> shapr, b0gg1e www.pytypus.org:6666
09:56:36 <dcoutts> but it shows the progress
09:57:04 <shapr> paolino_: neato
09:57:05 <dcoutts> gour, you'll find it's easier to see what it's doing with some very simple code that doesn't import too much
09:57:07 <gour> it looks like a full-featured app, there is even Print icon, btw, do you have any experience with video-projectors?
09:57:17 <Lemmih> I'm current stuck until I can speak with JaffaCake or krasimir. It's kinda frustrating.
09:57:28 <shapr> email them both!
09:57:29 <dcoutts> gour, nope, I don't know video-projectors
09:57:44 <dcoutts> Lemmih, yeah, email them and cc the ghc list
09:57:51 <gour> dcoutts: you don't use such stuff on the university?
09:57:52 <b0gg1e> ah, thanks paolino, will have a look.
09:58:03 <dcoutts> gour, I don't personally
09:58:14 <b0gg1e> paolino, do you mind if you give this url out to a few other ppl?
09:58:19 <gour> dcoutts: ah, ok
09:58:27 <paolino_> no really
09:58:35 <dcoutts> gour, I've done it once, but it was just a matter of turning the thing on and plugging the vga plug into the back of the laptop
09:59:02 <gour> dcoutts: for my week-end seminar i used transparencies..
09:59:18 <gour> dcoutts: but just 'discovered' about latex-beamer package..
09:59:26 <paolino_> it's all OS contents also.It's a wiki,blog pluggable live and what ever you like.
10:00:02 <gour> dcoutts: so it would be nice to have one, but, cause i'm on the budget, i'm not sure whether 800x600 is enough
10:00:17 <dcoutts> gour, yeah they're expensive things
10:00:26 <dcoutts> I'd try to borrow one, otherwise don't bother
10:01:12 <gour> dcoutts: well, renting in croatia is not cheap, and i'm regularly giving seminars (in the areas where they even do not have flip-chart)
10:01:17 <paolino_> b0gg1e, It's secure,it implemented all the ideas they are NOW start defining in W3C to make some sanity in the URI theory :)
10:01:29 <shapr> gour: What about big pieces of paper and a marker?
10:01:52 <gour> shapr: that's called flip-chart?
10:01:53 <paolino_> but it's python
10:01:58 <shapr> gour: yes :-)
10:02:11 <gour> shapr: i'm already using that
10:02:31 * paolino_ goes back to haskell reality
10:02:53 <xerox> paolino_: what is it (the W3C-compliant thing) ?
10:03:35 <paolino_> we call them URI gardens
10:04:07 <paolino_> don't remember the name they've given
10:04:07 <paolino_> wait
10:05:04 <pesco> shapr: I'm heading home. I'll think about the Website/Content stuff and let you know tomorrow.
10:05:13 <shapr> pesco: ok, thanks.
10:06:02 <rep> i wish ghc compiled faster :)
10:06:15 <shapr> hiya Harlock, learning Haskell?
10:06:33 <Harlock> hi
10:08:46 <shapr> bok gour
10:09:08 <gour> bok shapr, thank you for TMR5
10:09:23 <shapr> Yeah! Do you want to write for the next issue?
10:09:57 <alar> Lemmih: "There should be more documentation, but there isn't (yet). Yell if you need it."
10:09:59 <alar> :)
10:10:09 <gour> shapr: about what? my wrestling with the language - still on the 14th chapter
10:10:34 <Harlock> shapr: i'll have to for uni
10:10:56 <shapr> gour: I'm not sure, I'll think about it.
10:11:10 <Harlock> shapr: along with maude
10:11:17 <gour> shapr: i consider myself still too young for the task
10:11:33 <shapr> Nah, there are lots of fun and easy articles that could be written.
10:11:41 <shapr> gour: Do you know the OOP Design Patterns?
10:12:23 <gour> shapr: i heard for that gang of four book, but no interest to dive in
10:12:38 <Harlock> brb
10:13:09 <shapr> ok
10:13:12 <paolino_> xerox ,can't locate the document W3c is too much wide knowledge producer I will get it tomorrow from a friend involved sorry
10:13:54 <gour> shapr: if/when i acquire some more haskell skills, i'd like to help writing some gtk2hs tutorial(s)
10:14:14 <dcoutts> gour, excelent!
10:14:18 <gour> shapr: so that those coming after me can have an easier gui start
10:14:36 <gour> shapr: i already sold my soul to dcoutts :-)
10:14:45 <dcoutts> gour, 'coz I never seem to find time to write docs
10:15:01 <sylvan> Is it just me, or is the OpenGL-2.1 package (came with GHC HEAD) new?
10:15:18 <paolino_> *Main> :t Rose (map Foglia [1,2,3])
10:15:21 <paolino_> Rose (map Foglia [1,2,3]) :: (Num a) => Tree a
10:15:21 <paolino_> *Main> :t map Rose .(map Foglia) [[1,2],[2,3]]
10:15:29 <shapr> gour: spiffy!
10:15:32 <dcoutts> gour, oh btw we've got a hIDE website set up using WP. I told Lemmih that you might be able to help with any customisation.
10:15:32 <gour> dcoutts: i understand - you know the stuff
10:15:42 <paolino_> what I 'm doing wrong ?
10:15:46 * SamB wishes for an HM-typed, higher-order C
10:15:56 <gour> dcoutts: i saw it, although i'd prefer to have trac+darcs
10:16:00 <xerox> Cale: ping
10:16:07 <dcoutts> gour, persuade Lemmih
10:16:20 <xerox> SamB: Haskell?
10:16:36 <alar> SamB: higher-order is easy, but I'm not sure if HM-typed is possible
10:16:59 <work_metaperl> paolino_: is there a "." in front of (map Foglia)
10:17:01 <gour> dcoutts: but i'm not sure if e.g. trac can be installed on one server and to have darcs repo on the other - i mean shapr provides for darcs repo
10:17:11 <dcoutts> gour, if you want to help us run the site then I'm sure you could persuade us to use something other than WP. It's just what Lemmih and I have used before.
10:17:30 <paolino_> work_metaperl, it is wanted but wrong ?
10:17:48 <Lemmih> I just want a weblog. trac+darcs sounds fine if we can set it up.
10:18:04 <dcoutts> gour, well we could move the darcs repo, that's no problem.
10:18:05 <gour> dcoutts: that's fine, i'm just thinking that having ticket/bugs/wiki/repo in one place could be handy
10:18:15 <dcoutts> gour, you're probably right
10:18:21 <work_metaperl> paolino_: i'm a newb. I see what that "." is --- function composition... I'm sorry the haskell Gods are ignoring you right now.. they'll get to you in a sec I'm sure
10:18:36 <work_metaperl> 16 SJT chapters-old newb :)
10:18:55 <paolino_> eheh
10:19:17 <gour> dcoutts: probably you write more haskell code than blog articles :-)
10:19:33 <dcoutts> gour, yeah :-)
10:22:14 <paolino_> is type constructor Rose (is it ?) a function ?
10:22:42 <xerox> Data constructors are functions.
10:22:47 <work_metaperl> paolino_: it looks that way from your code... can you paste your code somewhere? paste.lisp.org/new/haskell
10:23:07 <xerox> data <Type Constructor> <type parameters> = <Data Constructor> <parameters> | ..
10:23:36 <gour> dcoutts: well, trac requires several packages missing on haskell.org, so i do not know whether its admin will be happy with it
10:23:36 <alar> xerox: do you mean that constructor can be used anywhere where function is usable?
10:23:46 <work_metaperl> oh and the Type Constructor can be the exact same "word" as the Data Constructor:   data Storage = Storage [Int]
10:24:07 <xerox> alar: Data Constructors _are_ functions.  Try, in GHCi, :type Just
10:24:07 <work_metaperl> data Storage = Sto [int] -- another way, but the earlier way works too
10:24:39 <Harlock> re
10:24:42 <alar> so they can be partially applied, passed as arguments, etc..?
10:24:47 * work_metaperl wants a folding UML-generating mode from the haskell editor
10:25:02 <Harlock> shapr: as i was saying.. yup, i must learn some haskell for uni, along with maude :)
10:25:15 <shapr> Harlock: Cool, that's good stuff.
10:25:20 <work_metaperl> alar: yes, beautiful isn't it... haskell is nothing but referentially transparent functions
10:25:27 <shapr> I think maude was the first with ADTs, or was it the first with laziness?
10:25:39 <work_metaperl> Harlock: I recommend SJT's book
10:25:41 <Harlock> shapr: no idea :)
10:27:11 <lisppaste2> paolino pasted "Constructor as function" at http://paste.lisp.org/display/12197
10:27:19 <dcoutts> gour, what does it need?
10:27:26 <shapr> Who else might be interested in a Haskell web framework?
10:27:46 <dcoutts> gour, and what versions?
10:27:56 <gour> dcoutts: see http://projects.edgewall.com/trac/wiki/TracInstall
10:28:01 <dcoutts> gour, ok
10:29:02 <gour> dcoutts: and atm, trac is at 0.9beta2
10:29:07 <work_metaperl> why do people who paste at paste.lisp.org get ignored? I've never gotten responses when I paste there?
10:29:31 <gour> dcoutts: 'problem' is that we (probably) do not need the (defualt) svn back-end
10:29:46 <shapr> work_metaperl: I don't think they do get ignored, I think it's just that a paste doesn't seem to be the same as a question.
10:30:14 <gour> dcoutts: but a darcs backend, so official trac tarball should be patched with lele's darcs backend
10:30:35 <work_metaperl> yes, I've always had to say: I'm having some problems with such and such and here is a synopsis: paste.rafb.net/asdf4w3qrf89asd2
10:30:40 <work_metaperl> but anyway
10:30:54 <work_metaperl> paolino_: what does :t Foglia return
10:31:06 <gour> dcoutts: on my box i have trac+darcs with sqlite
10:31:20 <paolino_> Foglia :: value -> Tree value
10:31:20 <work_metaperl> Foglia is operating on integers in the first map of your paste and lists of integers in the second map in your paste
10:31:49 <work_metaperl> paolino_: so how could Foglia work on integers as well as lists of integers?
10:32:11 <dcoutts> gour, well on haskell.org we can probably use postgresql, it has rpms for that but not sqlite
10:32:51 <dcoutts> gour, but we'd need a local instalation of python since the system version is too old
10:33:05 <paolino_> I mumble more work_metaperl thanks
10:33:06 <dcoutts> gour, we'd run it all as the hide user
10:33:30 <alar> paolino: you can increase his karma ;)
10:33:37 <work_metaperl> paolino_: ok, I see. you are taking a curried version of Foglia by (map Foglia) and composing its output with a curried version of Rose
10:33:41 <dcoutts> gour, so do we not need subversion in that case?
10:33:51 <gour> dcoutts: postgresql is installed?
10:34:03 <gour> dcoutts, no we do not need svn
10:34:17 <paolino_> that was my aim
10:34:17 <work_metaperl> just do the type signature of each curried version separately and I bet you will see that they are not compatible
10:34:20 <dcoutts> gour, it's not installed yet, but it's easy to install
10:34:28 <gour> dcoutts: if we installe from the source
10:34:36 <xerox> Type hacking is great.
10:34:49 <gour> dcoutts, hmm, i'd prefer sqlite then, it's more stable
10:34:59 <gour> dcoutts, postgresql backend is new one
10:35:14 <dcoutts> gour, there are redhat postgres rpms available, it's just apt-get install rh-postgres
10:35:18 <dcoutts> gour, oh I see
10:35:31 <dcoutts> gour, I didn't see any sqlite rpms
10:35:35 * alar has to go
10:35:40 <gour> dcoutts, and it's more lite :-)
10:36:23 <dcoutts> gour, in that case we'd need a local installation of slqite
10:36:39 <gour> dcoutts: yes, see http://www.sqlite.org/download.html
10:37:28 <Harlock> mmm in uni's library are these: "haskell: the craft of FP", "the haskell school of expression: learning FP through multimedia", "introduction to FP using haskell".. this last is translated to spanish
10:37:39 <Harlock> i think they are the most famous books on haskell
10:39:00 <Harlock> no maude books :)
10:39:41 <xerox> I enjoyed 'The Haskell road to Math, Logic and Programming'.
10:40:12 <araujo> Harlock, spanish speaker?
10:40:41 <paolino_> work_metaperl, no way I can get it right
10:41:22 <work_metaperl> xerox: I have that book road to Math, Logic and Programming, but it doesnt go into types or monads does it?
10:41:28 <Harlock> araujo: yes, it's my tongue language
10:41:53 <work_metaperl> paolino_: what do you mean? did you separately type each of the two functions you are trying to compose?
10:42:00 <araujo> Harlock, nice, same here
10:42:01 <xerox> work_metaperl: it does, I'm sure about types, less about Monads.
10:42:14 <araujo> Harlock, Te recomiendo "Razonando con Haskell" en ese caso
10:42:25 <work_metaperl> maybe I will look it over after I finishh SJT
10:42:41 <work_metaperl> the algorithms book by Fethi is good according to autrijus
10:42:48 <araujo> It is a very good written book about Haskell.
10:42:53 <araujo> And it is in spanish :-]
10:42:59 <work_metaperl> that's what he read after YAHT
10:43:12 <work_metaperl> YAHT = yet another haskell tutorial
10:43:25 <work_metaperl> books, books, books, books
10:44:11 <work_metaperl> [b | x <- (1..20), b = "books" ] -- how do you create a string with 20 instances of "book" in it?
10:44:14 <paolino_> (map Foglia) is [a]-> [Tree a]  appliable to the elements of the outer list
10:44:51 <work_metaperl> paolino_: if no one here helps you, then the haskell cafe will.. just email there and you will have an answer in under 8 hours
10:45:08 <Harlock> araujo: Bird's book has a bad translation?
10:45:39 <paolino_> work_metaperl, ok
10:46:07 <Harlock> my level on haskell is "hello world", i.e. the factorial function :)
10:46:20 <work_metaperl> paolino_: but go ahead and give the type of map Rose  -- i'm curious... also I wonder if :t map Rose is any different from :t (map Rose)
10:46:31 <work_metaperl> hello world requires monads in haskell
10:46:40 <xerox> It depends.
10:46:56 <Harlock> argh, that "monads" thing doesn't sound good to me :)
10:47:16 <Harlock> i'm reading it all the time
10:47:34 <work_metaperl> i'm not quite to monads and don't intend to involve my mind with them until SJT gets to them
10:47:41 * work_metaperl returns to work
10:48:31 <Harlock> well, in fact the course is not only about Haskell.. FP in general.. we learn a bit of haskell, maude and prolog
10:49:16 <Harlock> why a logical language like prolog is said to be functional?
10:49:32 <xerox> No.
10:49:43 * xerox rolls on the floor laughing.
10:51:03 <Harlock> :)
10:51:35 <work_metaperl> paolino_: did you type each part of the composition separately? and are you sure you dont needs parens around map Rose? this is not a hard problem. I think we can solve it? why won't someone help paolino_?
10:51:45 <work_metaperl> dcoutts: can you help paolino_?
10:51:57 <Harlock> xerox: that was what the prof said..
10:52:06 <xerox> Harlock: I was just kidding.
10:52:14 <work_metaperl> Harlock: Prolog is relational isn't it?
10:52:25 <work_metaperl> what is maude?
10:52:29 <Harlock> xerox: i suppose "declarative" is more appropiate
10:52:29 * dcoutts tries to find the problem paolino_ is struggling with
10:52:31 <work_metaperl> xerox: can you help paolino_?
10:52:40 <Harlock> xerox: yes, i got the joke :)
10:52:52 <work_metaperl> dcoutts: right here: http://paste.lisp.org/display/12197
10:52:55 <xerox> work_metaperl: I'm sorry, I don't know what the problem is.
10:53:00 <work_metaperl> xerox: http://paste.lisp.org/display/12197
10:53:13 <Harlock> work_metaperl: the prof defined it as a "term rewriting" system
10:53:17 <work_metaperl> this is amazing - i will _never_ paste at paste.lisp.org when i have a problem with haskell
10:53:30 <work_metaperl> rafb.net/paste it is for me
10:53:35 <Harlock> work_metaperl: http://en.wikipedia.org/wiki/Maude_system
10:54:01 <work_metaperl> Harlock: prologs results in the language shootout aren't so good in somecases... it has exponential memory use and explodes on the Ackerman function
10:54:33 <dcoutts> work_metaperl, paolino_ it's a problem with brackets
10:54:37 <work_metaperl> prolog is fine until you have to weed through a search tree, throwing in red and green cuts
10:54:47 <work_metaperl> dcoutts: you mean parentheses?
10:54:53 <dcoutts> work_metaperl, yep
10:54:56 <work_metaperl> ha! I was right!
10:55:05 <work_metaperl> map Rose needs them?
10:55:14 <xerox> You want   map (Rose . (map Foglia)) [[1,2],[2,3]]
10:55:16 <Harlock> work_metaperl: what the prof said is that at the end, prolog is reducible to functional programming or something like that
10:55:51 <work_metaperl> well relations are a superset of functions so there's some theoretical merit in that statement
10:56:21 <xerox> work_metaperl: You prolly want  map (Rose . (map Foglia)) [[1,2],[2,3]]
10:56:23 <work_metaperl> relatiosn can be functions but functions cant be relations... although soon SJT will cover relations and sets in the chapters I have not read
10:56:47 <work_metaperl> xerox: it is paolino_'s problem, i am serving as ambassador to haskell gods for paolino_
10:56:52 <work_metaperl> :)
10:56:53 <dcoutts> work_metaperl, actua;;y once you fix the brackets you've got another problem
10:57:06 <work_metaperl> paolino_: are you there?
10:57:08 <dcoutts> (Rose . map Foglia) [[1,2],[2,3]] is fine
10:57:14 <dcoutts> but (map Rose . map Foglia) [[1,2],[2,3]] is not
10:57:30 <xerox> dcoutts: map (Rose . (map Foglia))
10:57:39 <work_metaperl> this is paolino_'s problem and he is not answering...
10:57:43 <dcoutts> because  map Foglia  [[1,2],[2,3]] :: [Tree [Int]]
10:57:44 <Harlock> work_metaperl: prolog -> relations & haskell -> functions ?
10:57:46 <xerox> dcoutts: to get a  Num a => [Tree a] out.
10:58:28 <dcoutts> the point is that Rose takes a list of trees and that's what you've got
10:58:40 <dcoutts> sing map Rose would need a list of lists of Tree
10:58:44 <dcoutts> sing/using
10:58:48 <work_metaperl> Harlock: haskell is a purely functional programming language. Prolog is relational. but dont mind me
10:58:55 <Harlock> work_metaperl: i think the points was that of rewriting.. you can rewrite a function as its result value, you can search facts in prolog to rewrite some query, you rewrite in maude...
10:59:03 * dcoutts goes back to what he was doing before
10:59:15 * work_metaperl sighs
11:00:18 <Harlock> work_metaperl: oh, sorry, the phrase "relational database" is so hardcoded in my mind.. :)
11:01:29 <xerox> Watch this:
11:01:30 <xerox>     Kind error: Expecting kind `* -> k_a6a5 -> k_a6a7',
11:01:30 <xerox> 		but `a () b' has kind `k_a6a7'
11:01:34 <xerox> YAY :D
11:01:47 <sieni> a relation can trivially be represented as a function
11:02:34 <shapr> xerox: wow, how'd you do that?
11:02:35 <sieni> If R is a relation on A, i.e. a subset of A x A, then they correspond exactly to functions A x A -> {0,1}
11:02:51 <basti_> xerox: wow
11:02:55 <xerox> shapr: I'm trying to solve a problem at type level.
11:03:09 <xerox> It's just for fun, I don't know if I ever come to solve it :D
11:03:10 <shapr> neat
11:03:20 <xerox> I got it from the GEB
11:03:29 <xerox> @wikipedia G√∂del Escher Bach
11:03:32 <lambdabot> No result found.
11:03:35 <Harlock> xerox: GEB = godel escher bach ?
11:03:36 <xerox> @wikipedia Godel Escher Bach
11:03:40 <lambdabot> http://en.wikipedia.org/wiki/Godel_Escher_Bach
11:04:08 <Harlock> xerox: i'm reading that book too :)
11:04:25 <xerox> Harlock: so, I'm trying to implement the MIU system :-D
11:04:34 <basti_> i read that the first time about 10 years ago.
11:04:42 <xerox> (at type level, and find the solution, heh)
11:04:50 <Harlock> xerox: haha i was thinking of implement some of those formal systems on maude
11:04:54 <shapr> xerox: cool!
11:05:12 <xerox> shapr: that book is *very* inspiring.
11:05:17 <Harlock> xerox: (when i'll learn more of it, of course)
11:05:33 <Harlock> argh, my english really sucks!
11:06:23 <Harlock> xerox: are you doing it with "maude over maude" or have you written another specification language for the formal systems?
11:07:09 <xerox> Harlock: what does 'maude' mean?
11:07:26 <Harlock> xerox: ouch, s/maude/haskell/g :)
11:07:40 <xerox> I'm using the Haskell typesystem.
11:07:46 <Harlock> aha
11:08:00 <work_metaperl> what is maude?
11:08:02 <xerox> Let's spoil the fun:
11:08:04 <xerox> *Main> :t one axiom
11:08:04 <xerox> one axiom :: M (I () (U () ()))
11:08:20 * xerox hides rapidly
11:08:45 <Harlock> work_metaperl: http://en.wikipedia.org/wiki/Maude_system
11:10:10 <Harlock> xerox: lol
11:10:23 <xerox> How can one get the type checker/inferrer to do loops? :D
11:10:36 <xerox> Nevermind, I had an idea.
11:10:43 <Harlock> xerox: maude is saying to me "implement MIU on me, implement MIU on me" :)
11:12:08 <soma_> i have a silly problem.. how do i insert spaces into a string? .. it should be easy enough but... like "hello" becomes "h e l l o "
11:12:30 <kowey> intersperse?
11:12:41 <soma_> huh? yeah in between the chars
11:12:49 <shapr> @type intersperse
11:12:50 <lambdabot> bzzt
11:13:03 <shapr> @type Data.List.intersperse
11:13:04 <lambdabot> forall a. a -> [a] -> [a]
11:13:04 <soma_> oh, its a prelude function?
11:13:05 <kowey> erm. .. concat $ interspere ' ' str  (i think)
11:13:18 <xerox> @plugs List.intersperse 'a' "hello"
11:13:21 <lambdabot> "haealalao"
11:13:27 <xerox> Rrr :D
11:13:39 <kowey> right... concat's if you got a list of strings
11:13:41 <kowey> silly me
11:13:42 <work_metaperl> for every character in the string return the character and a space
11:13:56 <xerox> @plugs List.intersperse ' ' "hello"
11:13:58 <lambdabot> "h e l l o"
11:14:13 <soma_> ah, from the List module then
11:14:17 <soma_> thanks guys
11:15:15 <Harlock> xerox: in maude, you can write something like "op _+_ : Nat Nat -> Nat ."
11:15:31 <Harlock> xerox: then "eq 0 + N = N ."
11:15:44 <Harlock> xerox: the engine then goes rewriting
11:16:00 <xerox> Harlock: uh-uh..
11:18:54 * wagerlabs is back with more questions :-)
11:19:10 <Harlock> well, gonna eat something
11:19:22 <wagerlabs> what's the meaning of $! in return $! (fromIntegral (x :: Int64))?
11:19:28 <Harlock> bye
11:19:36 <xerox> Mumble mumble.
11:20:10 <sieni> soma_: concat $ map (\x -> [x,' ']) "hello"
11:20:46 <xerox> hah I was trying to do something like that too :D
11:20:48 <paolino_> work_metaperl, thanks again
11:21:13 <CosmicRay> hey metaperl, get my email about sequence?
11:22:07 <shapr> hey CosmicRay
11:22:22 <CosmicRay> hi shapr
11:22:32 <paolino_> so '.' operator is weaker than function calling ?
11:22:35 <shapr> wagerlabs: Hey, you can likely use QuickCheck's algebraic or model based specifications to test your server.
11:22:55 <shapr> wagerlabs: Or just port it to linux and use valgrind
11:23:09 <shapr> CosmicRay: Seen TMR5? Is the formatting on your artice bearable?
11:23:13 <wagerlabs> shapr: i might be able to, that's the goal but... it's a little more complex than that as i actually need scripts
11:23:22 <wagerlabs> shapr: return $! (fromIntegral (x :: Int64)), what's the meaning of $! here?
11:23:27 <CosmicRay> shapr: haven't seen it.  url?
11:23:32 <shapr> wagerlabs: strictify
11:23:40 <shapr> wagerlabs: Why do you need scripts?
11:23:44 <wagerlabs> ah! no laziness for you
11:23:56 <shapr> CosmicRay: http://www.haskell.org/tmrwiki/IssueFive
11:24:18 <wagerlabs> shapr: long story. basically, i need bots to join, play games, participate in tournaments and the like
11:24:21 <shapr> wagerlabs: Actually, I think it just means "force weak head normal form". It's not really strict, but it's closer.
11:24:23 <CosmicRay> shapr: cool.  I hope you posted about it to one of the lists?
11:24:28 <xerox> @plugs (flip foldr [] . (. (:)) . flip (.) . (:)) ' ' "hello"
11:24:30 <lambdabot> "h e l l o "
11:24:32 <xerox> prrr.
11:24:53 <shapr> wagerlabs: That sounds great, but why would you want scripts for that?
11:25:08 <sieni> xerox: that's insane :-)
11:25:15 <wagerlabs> shapr: because i can check the outcome?
11:25:17 <xerox> Dinner, later :-)
11:25:20 <CosmicRay> shapr: looks good except for a couple of minor things.  The sections that are sidebars can be eliminated completely (they just duplicate things)
11:25:29 <wagerlabs> shapr: that is because i know what the outcome should be
11:25:46 <shapr> wagerlabs: Wouldn't you encode that into your QuickCheck spec?
11:26:09 <wagerlabs> shapr: hmm... that would be rather complicated i think
11:26:38 <shapr> If you tell me what you want to encode, I'll tell you if I think it's easy or hard with QuickCheck.
11:28:22 <shapr> Maybe I'm confused... but it sounds like you want to manually check the output of your bots.
11:28:26 <CosmicRay> shapr: but a huge thanks for converting frmo that bastard of a rtf file
11:29:02 <shapr> :-)
11:29:09 <shapr> Whoa cool, skew is working at Yahoo now.
11:29:28 <shapr> I happen to know one of his coworkers.
11:30:54 <shapr> wagerlabs: Anyway, the model/algrebraic spec stuff is documented here: http://www.cs.chalmers.se/~rjmh/Papers/QuickCheckST.ps and I think manually checking outputs is a bad thing http://c2.com/cgi/wiki?GuruChecksOutput
11:31:40 <shapr> But maybe I'm just confused about what you were saying.
11:37:36 <Cale`> @eval "hello" >>= (\x -> [x,' '])
11:37:37 <lambdabot> "h e l l o "
11:41:52 <work_metaperl> does Haskell optimize take n lis ++ listElem ++ drop (n+1) lis
11:42:10 <work_metaperl> Cale: sweet
11:42:38 <work_metaperl> Cale: what if you dont want a trailing space?
11:45:10 <wagerlabs> shapr?
11:45:15 <shapr> You screamt?
11:45:15 <wagerlabs> i'm sorry, i came down hard
11:45:28 <shapr> Using Windows?
11:45:38 <wagerlabs> shapr: so why do you think poker scripts can be encoded for quickcheck
11:46:18 <wagerlabs> shapr: no, i have a powerbook. after two years of honest-to-good, never-let-you-down service it's getting finicky
11:46:36 <shapr> If you tell me what you want to encode, I'll tell you if I think it's easy or hard with QuickCheck. Anyway, the model/algrebraic spec stuff is documented here: http://www.cs.chalmers.se/~rjmh/Papers/QuickCheckST.ps and I think manually checking outputs is a bad thing http://c2.com/cgi/wiki?GuruChecksOutput
11:46:57 * work_metaperl heads to chiropractor
11:47:01 <wagerlabs> shapr: the road to hell is paved with good intentions and i tried to upgrade memory. turned out i can't and now i had an issue with the original memory that was factory-installed
11:47:19 <wagerlabs> shapr: well, here's what i want to encode...
11:47:54 <sylvan> quickcheck is awesome
11:47:59 <wagerlabs> shapr: i have X players at the table, they take actions in turn, if the action is a FOLD then they are out of the loop
11:48:18 <wagerlabs> shapr: at the end of the game they all have been dealt cards and i know who the winners are
11:48:36 <sylvan> wagerlabs, you probably want to write a quickcheck property for smaller parts and not the entire application
11:48:40 <wagerlabs> shapr: right now i just give each bot the appropriate commands and have an extra bot watch for the winners and compare
11:49:02 <wagerlabs> sylvan: that's sort of what i do right now but shapr seems to be suggesting encoding the script in quickcheck
11:49:15 <shapr> Given the right datatypes, I think that's pretty simple to encode in QuickCheck.
11:49:19 <wagerlabs> shapr: maybe there's a miscommunication :) when i say script i mean game script, i.e. a sequence of actions
11:49:35 <shapr> Right, I understand that.
11:49:37 <wagerlabs> but right now a have a better problem on my hands
11:49:44 <wagerlabs> NewBinary/Binary.hs
11:50:10 <shapr> Still trying to swap endian-ness_
11:50:11 <shapr> ?
11:50:15 <wagerlabs>     putByte h (fromIntegral (w `shiftR` 8))
11:50:16 <wagerlabs>     putByte h (fromIntegral (w .&. 0xff))
11:50:19 <wagerlabs> shapr: you got it!
11:50:21 <sylvan> I tink it's harder to find useful properties for functions as you move up the "program hierarchy".. in other words: the small funtions are easy to write automated test for, the entire program is harder
11:50:31 <wagerlabs> is this big or little endian? i think it assumes native
11:50:44 <shapr> sylvan: Have you read QuickCheckST.ps for QuickCheckM ?
11:50:58 <sylvan> nope.. doing so now in fact!
11:51:14 <shapr> It's spiffy++
11:52:38 <wagerlabs> how does this determine endianness?
11:52:38 <wagerlabs> be = $( (1::CChar)/=(unsafePerformIO $ with (1::CInt) $ peekByteOff `flip` 0) ) :: Bool
11:53:38 <ndm> wagerlabs, it takes a CInt of 1
11:53:43 <ndm> i.e. 0x00001
11:53:52 <ndm> and peeks at the first byte
11:54:07 <ndm> if its one way round the first byte will be set, the other way round and it won't be
11:54:21 <wagerlabs> ndm: but wouldn't it always be in the proper position on each platform?
11:55:00 <ndm> peekByteOff is obviously platform depandant
11:55:32 <ndm> or looks like it is, from that definition - i don't know its internal details
11:55:54 <ndm> but (peekByteOff `flip` 0) == (`peekByteOff` 0)
11:55:59 <ndm> i would have thought?
11:56:04 <wagerlabs> ndm: did you see todays email on haskell-cafe?
11:56:15 <wagerlabs> ndm: i'm trying to make sense of it
11:56:44 <wagerlabs> let me paste it to the haskell wiki
11:56:45 <wagerlabs> @paste
11:56:46 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:56:51 <ndm> i saw the email
11:57:15 <wagerlabs> ok, that's the one
12:00:17 <wagerlabs> pasted
12:02:27 <goron> musabi,dons,anyone who knows: I have a question about co-variance. The <= relation stands for "more polymorphic than". Now, a<=Int is a trivial fact. But when we now try to derive (A stands for forall) (Aa.a->a) <= Int -> Int, we get a problem. Since we have to derive that a<=Int (since the last a and the last Int are co-variant) *and* we have to derive Int<=a (because they are contra-variant). So.... we can't make this derivation, so there must be someth
12:03:10 <xerox> *Main> :t one (M (I () ()))
12:03:10 <xerox> one (M (I () ())) :: I () (U () ())
12:03:10 <xerox> *Main> :t one (M (I (I () ()) ()))
12:03:10 <xerox> one (M (I (I () ()) ())) :: I (I () ()) (U () ())
12:03:19 <xerox> Oh my gosh, I think I understood how it goes.
12:04:02 <basti_> i understood the article but i thought it isnt worth the effort ;)
12:04:17 <basti_> until it freaked out, that is
12:07:39 <shapr> wagerlabs: That's Template Haskell code used to do some crazy bit flipping.
12:07:57 <wagerlabs> how do you know it's template haskell?
12:08:05 <shapr> $( )
12:08:07 <ndm> the $( )
12:08:08 <wagerlabs> oh
12:08:08 <wagerlabs> right
12:08:16 <Cale> goron: the last part of your message was cut off "so there must be somet"
12:08:23 <ndm> woops, i totally missed that when i looked...
12:08:24 <wagerlabs> so then it will do the right thing as it's a compile-time check
12:08:38 <goron> hing wrong.
12:08:38 <Cale> xerox: looking at the MIU problem?
12:08:39 <goron>                Anyone who can help me?
12:08:51 <goron> Cale: That was all.
12:09:27 <Cale> goron: hmm
12:09:40 <xerox> Cale: yep!
12:09:56 <xerox> Cale: I had this insane idea of resolving it at type level.
12:10:08 <Cale> xerox: :)
12:10:11 <goron> Cale: Do you happen to know how it works? I think you do since you also know all sorts of stuff about Category theory.
12:10:23 <xerox> Dunno why, but I understand your points about how fun fundeps are, now :-D
12:10:38 <Cale> :)
12:10:41 <wagerlabs> shapr: how easy would be to enhance this code to implement little endian?
12:11:06 <wagerlabs> shapr: i suppose i the most important bit is that $() and then i can go on the value of "be", right?
12:11:16 <xerox> Cale: I'm wondering about how to do a think, I think I'll bug you in a short while ;-)
12:11:20 <xerox> *thing
12:11:33 <Cale> goron: well, I understand co- and contravariant functors, but what you're talking about isn't directly category theory. I have seen that distinction being made before (Int -> Int) being considered more polymorphic than (a -> a)
12:12:51 <KrispyKringle> Apparently, dark chocolate is a good treatement for diarhea.
12:12:53 <KrispyKringle> whoops
12:13:01 <KrispyKringle> hrmm. i should mind which terminal window im in.
12:13:03 <xerox> O_o
12:13:05 <goron> KrispyKringle: Thanks for informing us.
12:13:11 <KrispyKringle> goron: I was reading FARK.
12:13:18 <KrispyKringle> And I posted that in #macosx maybe 3 hours ago.
12:13:24 <goron> What is FARK?
12:13:25 <KrispyKringle> And just now went to hit the up arrow and reecompile my code.
12:13:28 <KrispyKringle> goron: Fark.com.
12:13:38 <KrispyKringle> goron: It's not news.
12:13:41 <KrispyKringle> It's Fark.com.
12:14:31 <shapr> wagerlabs: The be code appears to set byte zero to the value of zero for a CInt of value 1, and then compare that to another CInt. I assume it's doing that to figure out at compile time whether your platform is big endian or not.
12:15:13 <wagerlabs> shapr: right. so to implement LittleEndian i would just use this code as a template, right?
12:15:28 <shapr> Yup
12:15:50 <goron> Cale: But if you would prove (Int->Int)<=(Aa.a->a), then you would have the same problem.
12:15:58 <shapr> I think you'd need to search and replace BigEndian with LittleEndian, and change /= to ==
12:16:16 <shapr> At least, that sure sounds good to me.
12:16:24 <wagerlabs> and replace if be with if not be, right?
12:17:05 <shapr> um, I was thinking of le = $( (1::CChar)==(unsafePerformIO $ with (1::CInt) $ peekByteOff `flip` 0) ) :: Bool , but yeah.
12:17:11 <goron> shapr: Have you read my question?
12:17:23 <wagerlabs> shapr: oh, you are right
12:17:33 <wagerlabs> shapr: let me copy this piece of code ;)
12:17:51 <shapr> wagerlabs: I was assuming that BigEndian and LittleEndian would be in different files, but if they're in the same file, your solution is better.
12:18:05 <wagerlabs> shapr: ah, ok
12:18:39 <shapr> Even better, you might be able to turn it into an Endian typeclass with big and little methods :-)
12:18:47 <wagerlabs> shapr: what i don't get is how would i apply this new BigEndian type to the classes in Binary.hs
12:18:56 <wagerlabs> shapr: i don't know how :(
12:19:08 <shapr> You know how to make a typeclass?
12:19:27 <wagerlabs> shapr: sort of. lots of examples, though
12:20:18 * shapr suddenly wishes to have some of the lambdabot plugins on the command line.
12:20:37 <wagerlabs> shapr: wait
12:20:44 <wagerlabs> shapr: that could be left for later
12:20:55 <wagerlabs> shapr: do you have Binary.hs from NewBinary handy?
12:20:58 <shapr> yes
12:21:01 <shapr> looking at it now.
12:21:37 <wagerlabs> shapr: i'm gonna be using that to read data from the packet and write it. that data can be little endian or big endian, depending on where it's coming from
12:22:04 <wagerlabs> shapr: i suppose i'll need to define LE and BE versions of the Word16, Word32, etc. no?
12:22:11 <shapr> Hey, when will you update your blog? ;-)
12:22:18 <wagerlabs> my blog?
12:22:23 <wagerlabs> update it with what exactly?
12:22:46 <shapr> I don't know, I just enjoy reading what you write.
12:23:03 <wagerlabs> shapr: ah, soon. just as soon as i'm able to make progress with the endian stuff
12:23:08 <shapr> ok
12:23:54 <shapr> btw, did SPJ work on LexiFi?
12:24:21 <wagerlabs> shapr: i don't think he did. thanks for the compliment, btw
12:24:30 <shapr> :-)
12:24:57 <wagerlabs> shapr: so as soon as i make progress (and you are kindly helping me!) i'll start writing about the goodness of haskell as applied to verifying poker servers
12:25:38 <wagerlabs> shapr: i
12:26:00 <shapr> Haskell may not be the best solution, but it is fun to read about your adventures.
12:26:10 <wagerlabs> shapr: why do you think it's not?
12:26:21 <shapr> Because I don't know everything :-)
12:26:42 <shapr> Haskell is the best solution of which I am aware, but I'm sure there are many solutions I haven't heard of.
12:26:50 <wagerlabs> shapr: i like being able to document stuff, kind of write the program as a spec
12:27:01 <shapr> In that case, you'll really like QuickCheck.
12:27:39 <wagerlabs> shapr: right. but i still need the endian stuff
12:27:40 <shapr> Binary.hs doesn't use Storable, so I'm trying to figure out how to plug them together.
12:28:05 <wagerlabs> shapr: the server is on the pc and talks little endian and i'm on the mac and need big-endian
12:28:30 <wagerlabs> shapr: that's what i was thinking about. binary just needs to read things in a different order. that could be a way but it seems kind of  messy
12:28:42 <shapr> I've forgotten how you're using NewBinary to read from Sockets, do you have code for that?
12:29:02 <wagerlabs> shapr: there's code in NewBinary to open a BinHandle from a Handle
12:29:08 <wagerlabs> and you can get a Handle from a Socket
12:30:30 <wagerlabs> shapr: anything wrong with that? i was gonna define my various packets on top of Binary
12:30:43 <shapr> Have you tried that already? The comments only talk about files.
12:30:54 <wagerlabs> dunno, haven't tried
12:31:03 <wagerlabs> would it matter? a Handle is not a Handle?
12:31:31 <autrijus_tw> hm, anyone still got a copy of the lab.tar.gz in the SSA/ANF paper?
12:31:33 <shapr> Handles are Handles, I just don't know if anything in NewBinary assumes file semantics.
12:31:41 <autrijus_tw> it was in www.cse.unsw.edu.au/~patrykz/ssa-lambda/lab.tar.gz
12:31:48 <wagerlabs> right
12:32:38 <shapr> wagerlabs: hdl :: !IO.Handle, -- the file handle (must be seekable)
12:33:19 <wagerlabs> shapr: so it won't work with sockets?
12:33:19 <goron> autrijus_tw: Do you happen to know why forall a.a->a subsumes (Int->Int)?
12:33:22 <wagerlabs> shapr: @^@#$^
12:33:25 <wagerlabs> :(
12:33:29 <shapr> Not directly
12:33:45 <shapr> But, why not just read from a socket and use Foreign.Storable?
12:34:01 <wagerlabs> shapr: don't know how. plus, need a way to define a Packet
12:34:27 <wagerlabs> shapr: and if I were to go the Storable route i would need to implement basic readers/writers for basic types, right?
12:34:34 <wagerlabs> shapr: any reason to reinvent the wheel?
12:35:22 <shapr> wagerlabs: readers/writers to/from raw memory exist - http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign.Storable.html
12:36:07 <CosmicRay> metaperl: btw, I have resolved to branch the shootout to form a project focusing on readable, canonical code
12:36:15 <CosmicRay> metaperl: I'm tailorizing the cvs repo to darcs as we speak.
12:36:23 <shapr> CosmicRay: oh tell me more!
12:36:39 <shapr> CosmicRay: Have you seen my post to the shootout list about that very idea?
12:36:46 <wagerlabs> shapr: so then i would maybe take a chunk of FastString and convert it to a pointer?
12:36:51 <CosmicRay> shapr: well basically, I am annoyed that so many programs on the shootout are heavily optimized.  they don't have code that an average person would write, or even understand.
12:36:55 <CosmicRay> shapr: no I haven't
12:36:58 <wagerlabs> shapr: do you have the exportables from FastString handy?
12:37:09 <CosmicRay> shapr: I do read that list occasionally, but haven't for a few months.  when was this?
12:37:09 <shapr> wagerlabs: exportables?
12:37:25 <wagerlabs> shapr: well, you know, the functions that the module exports
12:37:26 <CosmicRay> shapr: I griped about it myself quite awhile ago, it went nowhere
12:37:45 <CosmicRay> shapr: anyway, this tailorizing is taking quite awhile, but I'll let you know when the darcs repo is up
12:38:04 <shapr> CosmicRay: http://lists.alioth.debian.org/pipermail/shootout-list/2005-March/001296.html
12:38:30 <CosmicRay> oh heh, now I remember this discussion!
12:38:39 <humasect> is 'foreign' really spelt correctly?
12:38:45 <CosmicRay> shapr: have you done anything towards it yet?
12:39:00 <CosmicRay> shapr: what got me going on this was metaperl's blog post about the shootout.
12:39:20 <CosmicRay> shapr: I remembered that it is what brought me to haskell in the first place, but so much of the haskell code over there is icky and over-optimized, I don't think it would do so anymore.
12:39:35 <shapr> Yeah, I agree. I'd sacrifice speed for read.
12:40:58 <jyp> I've been advocating that last year or so with no success. :/
12:41:03 <CosmicRay> super.
12:41:05 <CosmicRay> so there are three of us.
12:41:21 <CosmicRay> that is so much better than just one ;-)
12:41:36 <shapr> Darius Bacon has also wished for a Code As Literature website.
12:41:43 <wagerlabs> shapr: can you give me a pointer? there are functions that convert FastString sto pointers
12:41:56 <wagerlabs> shapr: which one would be suitable for use with Storable?
12:42:05 <CosmicRay> initially I was going to whack out all the non-haskell code, and then have categories such as "Canonical Shootout Haskell", "Minimal LinesOfCode", "Easy Grokking for Beginners", "Canonical Solutions"
12:42:13 <CosmicRay> we could still benchmark them against each other.
12:42:23 <CosmicRay> but maybe the whacking out non-haskell code isn't the best plan
12:42:47 <CosmicRay> jyp: do you read the shootout list?
12:42:50 <shapr> wagerlabs: I don't know, is FastString just the bottom eight bits of a unicode char? I'm getting confused with so many different disconnected bits...
12:42:57 <jyp> I don't since then :p
12:43:00 <CosmicRay> at the present rate of tailorization, it will not be done, well, today.
12:43:08 <CosmicRay> jyp: haskell-cafe then? ;-)
12:43:14 <xerox> CosmicRay: Yo!  I got complaints from people I linked your (TMR) Haskell tutorial to, who say that installing MissingH give them some troubles.  I also wonder why one should teach Haskell using a "Missing in Haskell" library :-D
12:43:24 <wagerlabs> shapr: yeah, byte arrays are faststrings, sort of
12:43:29 <jyp> only from time to time on gmane
12:43:32 <wagerlabs> shapr: or the other way around
12:43:49 <CosmicRay> xerox: what sort of problems?
12:43:59 <CosmicRay> xerox: because I use the library for pretty much everything I write ;-)
12:43:59 <xerox> CosmicRay: dependencies I think.
12:44:08 <CosmicRay> xerox: there aren't any.
12:44:23 <shapr> I don't know the compatibility of FastString and Storable, but assuming  FastString doesn't do any compression, then yes, I think you can happily turn pointers into anything you want via Storable.
12:44:35 <CosmicRay> xerox: if they have 0.11.3, the latest on my site, they should be fine
12:44:39 <wagerlabs> shapr: i just don't understand which function i need to use
12:45:42 <CosmicRay> xerox: if you have any more specific reports -- specific error numbers and ghc versions -- I would like to hear about it.
12:45:50 <shapr> wagerlabs: I think you need to use "peek myPointer :: IO Int" or something.
12:45:54 <xerox> CosmicRay: "make setup and the README says it has dependencies"
12:45:57 <CosmicRay> xerox: current missingh versions are designed for ghc 6.4 or the 2005xx hugs releases
12:46:06 <wagerlabs>         construct,            -- :: (Ptr Word8) -> Int -> IO () -> IO FastString        packAddress,          -- :: Addr# -> FastString
12:46:07 <goron> Could anyone prove in here that (forall a.a->a) is more polymorphic than (Int->Int)?
12:46:09 <wagerlabs>         unsafePackAddress,    -- :: Int -> Addr# -> FastString
12:46:12 <wagerlabs>         unsafeFinalize,       -- :: FastString -> IO ()
12:46:29 <shapr> hiya malcolm
12:46:30 <wagerlabs> shapr: would any of these work?
12:46:41 * malcolm boings
12:46:43 <wagerlabs> no, wait, that's PACK
12:46:45 * shapr hops
12:46:51 <CosmicRay> xerox: if they have GHC 6.4, the only other thing they need is cpphs
12:47:06 <CosmicRay> xerox: which I assumed would be on haskell dev machines anyway?
12:47:50 <shapr> wagerlabs: I see two steps, 1. read from a Socket into a byte array in memory 2. parse that byte array. Am I missing anything?
12:48:19 <wagerlabs> shapr: you are right
12:48:35 <wagerlabs> FastStrings have methods for that for example
12:48:50 <wagerlabs> see section I/O with FastStrings
12:49:12 <shapr> Where?
12:49:28 <wagerlabs>         -- * I\/O with @FastString@s
12:49:29 <wagerlabs>         hGet,                 -- :: Handle -> Int -> IO FastString
12:49:29 <wagerlabs>         hPut,                 -- :: Handle -> FastString -> IO ()
12:49:29 <wagerlabs>   
12:50:03 <xerox> CosmicRay: mumble.
12:51:00 <shapr> How do you know the length of the message?
12:51:04 <xerox> CosmicRay: Cabal seems to be a missing dependence
12:51:24 <CosmicRay> xerox: it comes with GHC 6.4
12:51:26 <Flawless> "foo bar where bar = baz", is just syntactic suger for "let bar = baz in foo bar", right?
12:51:36 <shapr> There must be an easier way to do this... I think I've seen something in Simon Marlow's HWS.
12:51:42 <xerox> CosmicRay: that explains it.
12:51:47 <CosmicRay> ghc 6.2?
12:51:55 <xerox> CosmicRay: yep.
12:52:03 <CosmicRay> xerox: I did note that in the INSTALL file ;-)
12:52:23 <xerox> CosmicRay: reported.
12:52:39 <wagerlabs> shapr: i do
12:52:50 <wagerlabs> shapr: it's always <length> <body>
12:55:22 <shapr> Ah, neat.
12:55:41 <wagerlabs> shapr: not really, i don't think so. they read strings mostly. don't deal with numbers.
12:56:52 <CosmicRay> xerox: err, to them, or to me? ;-)
12:56:54 <wagerlabs> shapr: but i guess i should do the BE/LE stuff on top of that TH code
12:57:06 <xerox> CosmicRay: his problem is that he is on OS X
12:57:10 <goron> Where are the type hackers when you need them?
12:57:17 <CosmicRay> xerox: oh.  more fun.
12:57:27 <CosmicRay> xerox: really that article uses only a few functions from MissingH
12:57:45 <xerox> CosmicRay: I stated it too, but he's a bad guy when he wants ;)
12:58:28 <shapr> wagerlabs: Yeah, your endian-ness is step 1.5 in both directions.
12:58:44 <CosmicRay> xerox: tell him to pull the "contains" function from missingh/MissingH/List.hs into his source file.  that should give him all he needs.
12:59:03 <xerox> CosmicRay: in fact I'm convinced using it is not a so good idea, in the end.
12:59:12 <CosmicRay> xerox: MissingH, you mean?
12:59:14 <wagerlabs> shapr: well, if you decide to come up with any bits of code to make that TH bit work with Storable i would very much appreciate it :) time for me to hit the sack!
12:59:15 <xerox> Yep.
12:59:22 <shapr> wagerlabs: ok, g'night
12:59:22 <wagerlabs> good night folks!
12:59:30 <CosmicRay> xerox: for this article, or in general?
12:59:38 <xerox> For teaching Haskell to beginners
12:59:49 <xerox> I think stick with a portable language is better
12:59:50 <CosmicRay> ah
12:59:54 <shapr> hiya poetix
12:59:59 <poetix> Hi shapr
13:00:19 <poetix> This graph representing a web site...what information does it actually encode?
13:00:48 <poetix> Is it like a link table, with source and destination pages as nodes and links as edges?
13:01:24 <shapr> I think so. What else could it encode?
13:01:26 <Flawless> "foo bar where bar = baz", is just syntactic suger for "let bar = baz in foo bar", right?
13:01:38 <ndm> flawless, yep
13:01:42 <Flawless> ndm: ok, thanks
13:01:45 <humasect> or the other way around..
13:02:03 <ndm> humasect, no - only one way round
13:02:22 <malcolm> flawless: 'where' is only at declaration level, 'let' is expression level
13:02:25 <humasect> aw okay
13:02:42 <shapr> hiya Leadhyena
13:03:12 <poetix> shapr: That's useful to begin with. But it says nothing about, for example, where the link text itself appears in the page.
13:03:15 <Leadhyena> shapr: hey there!
13:03:44 <Leadhyena> had an interesting question about State monads if you have the time to talk about it...
13:05:13 <Leadhyena> or anyone else out there who knows about state monads is free to chip in as well.
13:06:03 <Leadhyena> I am trying to write a function that does a simple fold of a state monad across a list, for practice (I'm sure something in the prelude that does it already)
13:06:21 <Leadhyena> looks like this:
13:06:44 <Leadhyena> applyAcrossList :: (Int -> State Int ()) -> [Int] -> State Int ()
13:06:54 <Leadhyena> applyAcrossList apl ~(x:xs) = let y = apl x in y >> (applyAcrossList apl xs)
13:07:09 <Leadhyena> applyAcrossList apl _ = apl 0;
13:07:22 <Leadhyena> appList apl ~xs = execState (applyAcrossList apl xs) 0
13:07:32 <poetix> @type mapM_
13:07:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
13:07:43 <malcolm> why the twiddles?
13:07:56 <Leadhyena> right poetix... but I'm fighting a recursion problem
13:08:10 <poetix> What is the problem?
13:08:12 <Leadhyena> with basic stack settings, I cannot iterate across 100,000 length list
13:08:20 <Leadhyena> 100001 gives me a stack error
13:08:29 <Leadhyena> meaning there is no tail recursion
13:08:38 <Leadhyena> the twiddles are trying to get it to tail recurse
13:08:45 <Leadhyena> but then it gives me a heap error
13:08:59 <malcolm> The twiddle stops the recursion from having a base case
13:09:07 <Leadhyena> ah okay
13:09:26 <Leadhyena> i thought it was for an evaluation issue
13:09:43 <shapr> poetix: I dunno...
13:09:52 <malcolm> Yes, it stops the pattern from evaluating.
13:10:22 <Leadhyena> any way to get the state to evaluate element by element, instead of nesting 100,000 calls
13:10:24 <Leadhyena> ?
13:10:25 <shapr> poetix: Ah, the Haskell2Xml instance?
13:10:28 <malcolm> My guess is that your bind operation (>>) is too lazy
13:10:45 <poetix> shapr: yes?
13:11:04 <Leadhyena> how would I make it less lazy, malcolm? attach a $ somewhere?
13:11:10 <shapr> Maybe that tells you where to put stuff on the page?
13:11:33 <malcolm> Leadhyena: either use  seq y $ y >> applyAacross apl xs
13:12:00 <malcolm> Leadhyena: or fix the definition of (>>) with a seq
13:12:04 <poetix> shapr: I was thinking in terms of a tree of content, which in a sense is all an HTML document is anyway
13:12:30 <shapr> tell me more!
13:12:31 <poetix> shapr: So a page is defined as a top-level node with a tree of containers branching out from under it
13:13:07 <poetix> The idea here is partly that the page definition merely links pieces of content together in a container hierarchy; the content is defined elsewhere, and most importantly can be shared between pages
13:13:16 <poetix> (and versioned, updated etc. separately)
13:13:26 <malcolm> Leadhyena: I suspect your problem is to do with arithmetic on the Int stored in your State.
13:13:49 <shapr> CosmicRay: Using the same interface for the ArtOut?
13:14:17 <shapr> poetix: Sounds really cool... how to implement it?
13:14:42 <poetix> shapr: I kind of have the relational structure in my head already...
13:15:08 <shapr> Write it down! I want to implement it before I have to do another Plone job...
13:15:13 <poetix> I'm just trying to think about what would make good underlying data structures for storing and manipulating web content
13:15:50 <poetix> With the proviso that a pure functional approach to data structures might yield an interestingly Haskell-ish way of doing content management
13:16:46 <poetix> So, a page as a tree of containers; a site map as a graph based on a table of links; a journalling/versioning approach to development so that nothing is ever thrown away
13:16:58 <ProfTeggy> Hi
13:17:03 <shapr> y0
13:17:36 <ProfTeggy> They show my fav sci-fi movie of all times in German TV tonight.
13:17:40 * ProfTeggy prepares
13:17:50 <shapr> poetix: It makes sense... we can even do typechecking of the output via subDTDs
13:18:03 <ProfTeggy> *sit-back, open bottle*
13:18:29 * ProfTeggy senses DTDs ... 
13:19:05 <poetix> ProfTeggy: you've done a lot of work on efficient relational representations of tree structures...
13:19:15 <poetix> Which paper on the subject should I read first?
13:19:30 <jyp> poetix: what about ontologies and the like
13:19:38 <ProfTeggy> poetix, I'm still in the midst of this work.  There's still interesting stuff buried.
13:20:02 <ProfTeggy> poetix, it depends on the type of queries you are about to issue.
13:20:04 <ProfTeggy> XPath-style?
13:20:22 <ProfTeggy> Information retrieval style?
13:20:37 <poetix> jyp: Part of me still thinks ontologies are a bit of a fraud - but I can be made to see otherwise if someone waves a good use case in front of me
13:20:43 <ProfTeggy> XQuery style (i.e., w/ intermitten node construction, subtree pasting)?
13:20:47 <ProfTeggy> +t
13:21:05 <poetix> ProfTeggy: Wanting to grab a whole subtree in one query
13:21:21 <poetix> Probably not requiring all the sophistication of XPath
13:21:32 <jyp> It can be seen just as a generalisation of trees
13:21:40 <ProfTeggy> poetix, then allow me to point you to Staircase join.
13:21:56 <poetix> I remember the term from the XQuery paper
13:22:15 <ProfTeggy> http://www-db.in.tum.de/~grust/files/watch-axis-steps.pdf
13:22:50 <poetix> ProfTeggy: thanks
13:22:56 <poetix> shapr: I will email you something presently
13:23:05 * CosmicRay returns
13:23:19 <CosmicRay> shapr: What's ArtOut?
13:23:30 <ProfTeggy> poetix, don't hesitate to send questions or comments.
13:24:30 <shapr> CosmicRay: ShootOut vs ArtOut? Trying to think of a good name for your fork of the Shootout.
13:24:56 <CosmicRay> Ah
13:24:56 <jyp> ShowOut ? :P
13:24:59 <CosmicRay> heh
13:25:14 <CosmicRay> shapr: so do you think I should include the other languages as well, or do it haskell-only?
13:25:47 <CosmicRay> one thing to be said about the haskell community: we're good at naming things.
13:26:04 <malcolm> CR recently reminded me of the gist of the subDTD thinking we did for HaXml.  A query/transformation has a corresponding DTD->DTD type, which can be seen as a specialisation of the DTD wrt to the script.  Dually, you can specialise a script wrt to a DTD, giving you a script->script specialisation for optimisation.
13:26:20 <shapr> CosmicRay: I'd include everything.
13:26:41 <CosmicRay> shapr: do you think it still makes sense to have a "small", "nice", "normal", etc. view?
13:27:49 <CosmicRay> maybe we need to reorganize the tree in some fashion
13:28:08 <CosmicRay> but to me, I think it would be nice to see the speed comparison between the optimized version, the 1-line version, and the 5-line easy-to-grok version ;-)
13:29:11 <ProfTeggy> The notion of 'subDTD' is unknown to me.  What does it refer to?
13:30:14 <ProfTeggy> Subtyping (w.r.t. the regular types specified in a DTD)?
13:30:44 <malcolm> A DTD is the type of a whole document, but fragments of a document also have a type - a subDTD
13:31:15 <ProfTeggy> oh, OK, so 'sub' related to subtrees, not specific tree instances
13:31:42 <malcolm> Yes, the subDTD could be a subtype of the real DTD, in the sense that it strictly admits fewer values.
13:32:06 * ProfTeggy nods
13:34:38 <ProfTeggy> What would a typical use of a subDTD?  Validation of subtrees?  Partial (re)validation after document update?
13:35:21 <malcolm> validation of transformation scripts...
13:35:28 <shapr> Also composable html macros
13:40:33 <shapr> CosmicRay: I'd make the goals of the ShootOut fork be (in this order) 1. communication, 2. speed of change, and 3. elegance.
13:43:30 <Sickjacken> good latex spelling check for latex anyone?
13:43:31 <Oejet> Are the papers/presentations from ICFP online somewhere?
13:44:04 <basti_> Sickjacken: ispell has a latex mode
13:44:05 <malcolm> ACM digital library?
13:44:18 <basti_> iirc
13:44:23 <JohnMeacham> where is this shootout fork?
13:44:28 <basti_> yup -t
13:44:45 <CosmicRay> JohnMeacham: it is being created right now.
13:44:54 <CosmicRay> JohnMeacham: I'm tailorizing the CVS repo into a darcs repo
13:44:59 <Sickjacken> awesome basti_
13:45:07 <CosmicRay> JohnMeacham: it is slow going since it is over cvs pserver.  so it'll prboably be up tomorrow.
13:45:16 <JohnMeacham> ah. cool.
13:45:25 <prionic> whats this shootout fork?
13:45:48 <CosmicRay> prionic: a fork that focuses on good, clean, communicative code instead of raw speed.
13:45:51 <goron> I guess a fork of the famous language shootout.
13:46:02 <CosmicRay> prionic: to really give people a better idea of what it looks like to code in a particular language
13:46:13 <astrolabe> good idea
13:46:37 <CosmicRay> inspired by the complete ugliness of much of the haskell code in the alioth shootout.
13:46:57 * ProfTeggy is going to watch 'Outland' now.  Nice evening all.
13:47:07 * shapr waves to ProfTeggy 
13:47:08 <paolino_> basti_ I've found a film of the python clusterer on job http://img167.imageshack.us/my.php?image=pytypus6ed.gif
13:47:29 <CosmicRay> anyway, time for me to run.  thanks for the feedback shapr, I'll URL you when the repo's ready.
13:48:11 <basti_> paolino_: ah thats what youre trying to do?
13:48:34 <paolino_> yep
13:48:37 <goron> There's nothing wrong with a raw performance shootout.
13:48:50 <paolino_> that's what I did
13:48:54 <basti_> paolino_: mmhk
13:49:01 <basti_> oh
13:49:13 <basti_> ah i mean, trying to do in haskell, also
13:49:24 <shapr> goron: There is if none of the code in the shootout looks like actual code in the languages being tested.
13:49:31 <paolino_> well,I hope
13:50:12 <basti_> paolino_: you're aware that haskell is not good at number crunching? at least without heavy modifications
13:50:34 <basti_> but you can move out the low level parts to C
13:51:11 <goron> shapr: Well, I know that some people are coding with a cpu cycle counter in mind. Sometimes it's even necessary. I for one, would like to be able to do the same in Haskell.
13:51:14 <paolino_> surely is faster than python
13:51:25 <basti_> prolly yes.
13:51:37 <basti_> brb
13:52:09 <work_metaperl> go to the Debian shootout . haskell does quite well at number crunching... top 10 overall
13:52:16 <work_metaperl> @shootout
13:52:16 <lambdabot> Unknown command, try @listcommands.
13:52:19 <monochrom> perhaps I should write html with a cpu cycle counter in mind, too.
13:52:24 <work_metaperl> @url shootout
13:52:25 <lambdabot> Maybe you meant: arr pl
13:53:14 * work_metaperl wants more orange juice
13:53:23 <monochrom> when I write in haskell, I have a rewrite step counter in mind.
13:53:31 <goron> Somebody claimed recently to be working on real-time Haskell. Does anyone know more about that?
13:53:41 <shapr> goron: I disagree, the best speedups come from changes in the abstraction. - http://www.scannedinavian.com/2005-04-29.html
13:55:31 <goron> shapr: I read that before, and still there are area's where performance is important. I agree that it would be better to have some really good compiler that can generate optimal code, but unfortunately this is rather hard.
13:55:47 * dons rematerialises in sydney
13:55:54 <shapr> g'day dons!
13:55:55 <work_metaperl> welcome dons
13:55:56 <Heffalump> shapr: you're assuming a model where changes are frequent and use is infrequent (relatively)
13:56:00 <Heffalump> hi dons.
13:56:03 <dons> and that's how long it takes to fly to .au :)
13:56:08 * astrolabe agrees with goron
13:56:10 <monochrom> I don't know of a good way to design a language that is both abstract and low-level.
13:56:22 * Heffalump has been home for nearly 24 hours now.
13:56:37 <dons> :/
13:56:44 <dons> I should move to europe
13:56:55 <monochrom> There may be hope in a language containing an abstract subset and a low-level subset.
13:56:58 <Heffalump> they'll move ICFP to .au then
13:57:04 <shapr> Heffalump: I disagree. Frequent use calls for simple automated optimizations applied to a simple code.
13:57:05 <work_metaperl> dons: Europe is cold, except for spain
13:57:05 <monochrom> Or there may be evil in it.
13:57:13 <grkic> I need help with a little haskell problem...any1 who could help me???
13:57:15 <dons> metaperl, yeah, I noticed ;)
13:57:17 <goron> monochrom: You could have an interface to the compiler for just cranking in more details.
13:57:19 <work_metaperl> grkic: shoot
13:57:21 <shapr> monochrom: It's possible, look at Oleg's FFT/Split-Radix paper.
13:57:44 <Heffalump> shapr: simple automated optimisations applied to simple code just don't get you fast enough in the common case.
13:57:49 <goron> monochrom: E.g. like in C where you can advice the compiler to use a register for some value.
13:57:57 <shapr> monochrom: http://lambda-the-ultimate.org/node/view/652
13:58:03 <monochrom> Alright, there may be hope.
13:58:16 <Heffalump> Igloo has some simple benchmarks of string searching where even after heavily hand-optimising the Haskell he's still a factor of two off the performance of the C code.
13:58:19 <Heffalump> That matters.
13:58:27 * goron nods
13:58:50 <grkic> I need help with making a code work...any1 who could help me out???
13:58:51 <work_metaperl> Heffalump: why is that?
13:58:53 * monochrom delights in the bright better braver future.
13:59:07 <goron> But is that due to the language, or just because the C compiler is very good.
13:59:09 <goron> ?
13:59:12 <Heffalump> work_metaperl: Jaffacake says it's some problem with register allocation in GHC.
13:59:24 <monochrom> Don't talk to those who write like "any1".
13:59:27 <work_metaperl> can it be improved?
13:59:34 <Heffalump> note that I said heavily optimised Haskell above. Really unpleasant. The simple code is probably a lot slower.
13:59:43 <Heffalump> work_metaperl: not very quickly, but in principle, yes.
13:59:53 <work_metaperl> I have an optimization question here: http://sequence.complete.org/node/107
13:59:59 <shapr> grkic: Ask your question.
14:00:07 <astrolabe> grkic: You could ask a question here
14:00:12 <astrolabe> oops :)
14:00:21 <Heffalump> I'm just pointing out that in general Haskell imposes 2 or 3x slowdowns or worse, and that matters in many cases.
14:00:28 <grkic> yeah...i have a               type Env = [(String,Bool)]
14:00:36 <grkic> and i wanna wright a function
14:00:39 <Heffalump> monochrom: isn't there a parser combinator called any1?
14:00:49 <grkic> then when written the string it take out the Boolean
14:00:54 <work_metaperl> still, when all is said and done, Perl, C++, Java, and everyone else has had to bow down to Haskell's robust type system for 2 years straight in ICFP
14:00:55 <monochrom> hahahaha Heffalump
14:01:11 <Heffalump> work_metaperl: on tasks designed to suit FP.
14:01:15 <goron> E.g. "OpenOffice starts really slow" is a frequenly heard argument for not using Java.
14:01:19 <Heffalump> not exactly a fair test
14:01:24 <shapr> Heffalump: So, what ends up costing less time overall, improving GHC, or writing and debugging C code for every applcation that needs speedy strings?
14:01:27 <work_metaperl> haskell might run slower but it produces error free solid code in a short amount of time... Heffalump this year's problem was an OO problem
14:01:39 <grkic> value :: String -> Env -> Bool
14:01:39 <monochrom> Now it would be cool to also define operators like ??, ?!, etc.  "any1 ??!!"
14:01:40 <Heffalump> shapr: depends on the situation.
14:02:06 <Heffalump> your arguments are true under certain circumstances. They aren't true in general.
14:02:11 <work_metaperl> I dont think this was a FP problem. of course, if they said hook up to a CORBA request object or do some other task that required large real-world libraries, then haskell would have issues
14:02:19 <goron> Heffalump: that's called valid. :P
14:02:28 <goron> "true in general"
14:03:02 <monochrom> Ah, "valid", "true", "provable", "true but unprovable", "valid but untrue", ...
14:03:20 <goron> monochrom: Makes your head hurt, right?
14:03:21 <mauke> "0 but true", huhu
14:03:26 <work_metaperl> grkic: ok that can be done... you want to do a lookup... but what if the String is not found... what behavior do you want?
14:03:47 <shapr> I believe that my arguments are true in general, but not necessarily in that specific instance.
14:03:49 <work_metaperl> I think it should be value :: String -> Env -> Maybe Bool
14:04:08 <work_metaperl> Haskell has a nice balance of speed and quality assurance
14:04:22 <mauke> NotJustMaybe
14:04:24 <grkic> if the string isnt found then like error: string not found or somethin
14:04:26 <Heffalump> there are a large number of circumstances in which runtime speed matters more than development speed.
14:04:29 <work_metaperl> other languages sacrifice quality for speed or for ease of use
14:04:34 <grkic> no i just want  value :: String -> Env -> Bool
14:04:36 <work_metaperl> Heffalump: true
14:04:45 <mauke> value :: (Monad m) => String -> Env -> m Bool
14:04:51 <work_metaperl> grkic: are you guaranteed that the value is in the list?
14:04:59 <work_metaperl> if so, then it's easy
14:05:06 <dons> Heffalump, but do you think that for serious applications, any mirco-level speed issues get outweighed by benefits elsewhere?
14:05:18 <Heffalump> dons: depends on the application.
14:05:20 <goron> But *why* is Haskell so slow? Is it just that there's too little analysis done?
14:05:33 <Heffalump> goron: laziness is one major problem.
14:05:35 <dons> or are the there aps that just can't be coded in Haskell?
14:05:51 <dons> naive Haskell can be slow. though i'm not sure in practice this is always true
14:05:51 <grkic> it should be in the list...but if it isnt a error message would be good
14:06:02 <Igloo> dons: The case above is enough for David to be against removing the C code from FastPackedString
14:06:10 <work_metaperl> dons: a factor of 2 on a simple string search is not a micro-level speed issue :)
14:06:12 <Heffalump> dons: the compiler I work on for ARM couldn't be rewritten in haskell and still meet its design goals
14:06:15 <dons> Igloo, interesting.
14:06:23 <mauke> @hoogle (a -> Bool) -> [a] -> b
14:06:24 <dons> Heffalump, is it embedded?
14:06:24 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
14:06:24 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
14:06:24 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
14:06:29 <grkic> like an example would be
14:06:30 <grkic> value "x" [("x",True),("y",False)] = True
14:06:33 <shapr> I argue that the best way to get runtime speed is to prioritize speed of change.
14:06:41 <Heffalump> dons: no, but of course the code our customers write is
14:06:44 <Igloo> (so if anyone is interested in writing some C-- optimisations or tweaking the GHC RTS, please do speak to SimonM about it  :-)  )
14:06:59 <dons> Heffalump, that seems weird. what about nhc's experience?
14:07:02 <Heffalump> shapr: you're obsessed with that, and it's just not true in many cases. Speed of change is just not that important.
14:07:07 * astrolabe suspects that memory use is a big problem too.
14:07:13 <Heffalump> dons: what about it?
14:07:19 <work_metaperl> that hoogle thing r0x the house
14:07:23 <shapr> Heffalump: I totally disagree, and ask for evidence for your opinion.
14:07:29 <dons> oh, low mem compiler ,produces low mem binaries, for embedded systems
14:07:33 <Heffalump> I'm just giving you evidence..
14:07:37 <work_metaperl> astrolabe: in a lazy language?
14:07:38 <Heffalump> dons: low mem, fast.
14:07:42 <Heffalump> (the compiler, that is)
14:07:44 <mauke> grkic: lookup           :: (Eq a) => a -> [(a,b)] -> Maybe b
14:07:44 <autrijus> rehi.
14:07:48 <dons> ah.
14:07:49 * autrijus is having fun with Visual Haskell.
14:07:51 <Heffalump> and yes, our customers certainly couldn't use Haskell for much of what they do.
14:08:02 <xerox> autrijus, cool!
14:08:12 <shapr> Heffalump: No, you're saying they couldn't use the GHC RTS for much of what the do.
14:08:12 <dons> yeah, I think that's definitely a blind spot in everyday haskell
14:08:13 <work_metaperl> Heffalump: customers? aren't you a graduate student
14:08:24 <ndm> Hefalump, you work for a chip manufacturer - its not a typical case...
14:08:26 <dons> though the nhc guys have done much useful work here.
14:08:32 <grkic> the definiton would be that value x env returns the value associated with x in the environment env
14:08:38 <ndm> most people work a lot higher level than you do
14:08:40 <Heffalump> no, I'm saying they couldn't use haskell. Even without the RTS, the code is significantly larger and slower than the equivalent C.
14:08:42 <monochrom> the customers of the grad student are the profs and the undergrad students.
14:08:44 <Heffalump> work_metaperl: no :-)
14:08:46 <grkic> and it should have the type   value :: String -> Env -> Bool
14:08:47 <astrolabe> work_metaperl:yeah, having a table of pointers to some kind of to-be-evaluated tree instead of to ints for example.
14:08:55 <Heffalump> been there, got the PhD, did the postdoc. Now I work in industry.
14:08:55 <shapr> But a compiler, interpreter, or DSL written in Haskell could generate faster code than you can get from C.
14:09:14 <Heffalump> shapr: just how much compiler-writing experience do you have?
14:09:40 <dons> are these compilers for what kidn of language?
14:09:49 <work_metaperl> autrijus: what about "...faster than C++" --- in your interview... any data on that?
14:09:51 <Heffalump> dons: our compiler is for C.
14:09:53 <shapr> However much experience I have isn't evidence one way or the other.
14:10:17 <autrijus> work_metaperl: er, something like http://shootout.alioth.debian.org/benchmark.php?test=binarytrees&lang=all&sort=fullcpu
14:10:25 <dons> i'm not sure Haskell would make for a slow C compiler, btw
14:10:31 <Heffalump> shapr: however, if you don't have any it lends credence to the assertion I make that you don't know what you are talking about.
14:10:36 <autrijus> work_metaperl: it's just soundbite. we both know it's possible to write ultraconcise perl oneliners that haskell can't match.
14:10:43 <Heffalump> dons: I am. We optimise our data structures at the bit level quite often.
14:10:46 <ndm> compilers in haskell are slow, sad to say...
14:10:53 <Heffalump> you just can't do that in Haskell right now
14:10:55 <autrijus> work_metaperl: but the point is that it's possible for haskell, as a general purpose language, beat other languages at their own game, at least sometimes.
14:10:56 <astrolabe> Isn't it clear that for some types of programming speed is crucial, and for other types, it hardly matters?
14:10:57 <work_metaperl> autrijus: thanks. haskell smoked C++
14:11:02 <dons> the data structures in the compiler?
14:11:02 <Heffalump> astrolabe: yes.
14:11:04 <shapr> Heffalump: ad hominem isn't evidence.
14:11:05 <Heffalump> dons: yes
14:11:09 <dons> huh
14:11:14 <ndm> compare hugs vs ghc
14:11:30 <work_metaperl> autrijus: is there good haskell-perl5 connectivity? or is that only in p6?
14:11:33 <dons> defininitely on the hard research edge then. and not a typical case.
14:11:39 <Heffalump> shapr: my personal experience of writing compilers definitely is, though.
14:11:57 <work_metaperl> autrijus: meaning can I used CGI.pm from haskell easily? and could I write functions in Haskell and use them from Perl5?
14:12:04 <ndm> on one particular project, hugs "loads/compiles" in 4 seconds, ghc in 5 mins
14:12:11 <Heffalump> dons: well, likewise I'm sure our customers must be optimising for small data structures. The embedded market is reasonably large :-)
14:12:27 <shapr> Heffalump: Do you have some sort of equation that shows when speed of change is more important than runtime speed?
14:12:35 <work_metaperl> Heffalump: what language do you use at work?
14:12:43 <Heffalump> work_metaperl: C normally. Haskell if I can find a reason to.
14:13:06 <Heffalump> shapr: no, of course not. It would have a huge number of variables in it, many of which would be hard to measure values for.
14:13:11 <autrijus> work_metaperl: a certain Heffalump has a certain AntiBuddha.
14:13:29 <Heffalump> however, I can reasonably assert that there are many situations where the balance is clearly in favour of runtime speed.
14:13:34 <shapr> If it can't be expressed in figures, it is not science; it is opinion. --Lazarus Long
14:13:34 <work_metaperl> wow Clean was the fastest of all
14:13:45 <autrijus> work_metaperl: the other direction, which is Inline::GHC, may be made easier now ghc-api is there, but it doesn't build on my laptop, so I can't yet work on it :)
14:13:54 <Heffalump> shapr: well, you don't have figures either, and my opinion is rather more informed than yours.
14:13:58 <astrolabe> My job is signal processing research, and loads of computing time is spent doing algorithmically trivial stuff like taking the dot product of vectors.  I'm not optimistic about converting them to haskell :(
14:14:01 <ndm> consider why the GHC runtime isn't written in haskell....
14:14:04 <Heffalump> and you're right, it's not science.
14:14:06 <shapr> Heffalump: I disagree.
14:14:32 <Heffalump> Well, you're wrong. And your continuing assertions that fly in the face of reason do Haskell a disservice, IMO.
14:14:42 <dons> i shoudl talk to tony sloane more about nhc on arm
14:14:49 <Heffalump> dons: yeah, that does sound cool
14:15:07 <shapr> Heffalump: I've been doing commercial software development for a lot of years, and in several languages.
14:15:34 <Heffalump> shapr: and I have no doubt that for much or all of the markets you work in, your claims are valid.
14:15:59 <Heffalump> However, there are significant markets out there for which they are just wrong, and making general assertions is just silly.
14:16:07 <shapr> You just made one ;-)
14:16:22 <malcolm> Most software doesn't need to be fast.  But all software needs a fighting chance of correctness.
14:16:24 <monochrom> "All assertions about 'the programming industry' are wrong, for there is no one single programming industry." - Albert Y. C. Lai
14:16:34 <Heffalump> monochrom: right :-)
14:16:43 <dons> well put malcolm.
14:17:04 <shapr> So, maybe I'm right, then... since neither of us have worked in enough markets or industries to know "in general" ?
14:17:25 <Heffalump> shapr: I started by pointing out that your claim wasn't generally applicable. You kept disagreeing. I told you about one quite significant market where it isn't applicable. You kept claiming it was.
14:17:39 <shapr> And I still believe it is.
14:17:41 <Heffalump> I never tried to make an assertion that applied to everything, you did.
14:17:52 * Heffalump drops the subject
14:17:53 <astrolabe> 'generally applicable' is an ambiguous phrase.
14:17:54 <shapr> Ok, fair enough.
14:17:56 <Lor> What is the property of a relation xRy that for all x it is decidable whether there exists y such that xRy?
14:17:59 <malcolm> Of course, in the real-time safety critical field, we want both fast and correct.  So companies are thinking of moving from Ada to C++.
14:18:04 <dons> @remember malcolm Most software doesn't need to be fast.  But all software needs a fighting chance of correctness
14:18:16 <Heffalump> lor: well, it being finite would help :-)
14:18:26 <Heffalump> malcolm: hmmm... :-)
14:18:32 <Heffalump> you have to doubt the sanity of some people
14:18:33 <grkic> anyone who could help me in Private with a function probleeeem??
14:18:50 <work_metaperl> grkic: i probably can... i will be back in 5 minutes... pm me?
14:18:54 <grkic> yup
14:19:00 <grkic> alrighty...in 5 minutes then
14:19:07 <dons> oh, don't you always think of bug free non-segfault joy when someone mentions C++ ?? ;)
14:19:12 <Heffalump> work_metaperl: re the haskell-perl5 thing, I have a prototype bridge that lets you call perl5 from haskell
14:19:28 <Heffalump> but I have both that and some darcs stuff to work on atm, so it's not going all that fast.
14:19:40 <Lor> Heffalump, I'm thinking about reduction relations. Whether they get stuck or not, at least we ought to be able to know which!
14:19:43 <malcolm> I'm told there is already C++ running inside some car components, like ABS brakes and so on.
14:20:25 <Heffalump> heh
14:20:28 <dons> hmm. that's really quite scary
14:20:37 <Heffalump> that doesn't surprise me at all
14:20:41 <dons> hopefully these guys have good testing methods
14:21:14 <malcolm> Testing typically takes 50% of the project budget in safety-critical fields.
14:21:53 <Oejet> That little?
14:21:55 <dons> there's money in writing QC for C++ then
14:22:03 <Heffalump> do you know how much automated verification they do?
14:22:22 <Heffalump> (as in theorem proving and the like)
14:22:39 <dons> hmm. you can do verification on C++?
14:22:49 <malcolm> Some automated verification, yes.  depends on the safety integrity level (SIL)
14:23:12 <dons> oh, i guess they do verify asm.
14:23:45 <malcolm> I think it is mostly model-checking, some Z/B + theorem-proving, and some automated test generation from specs.
14:23:55 <Heffalump> that doesn't sound too bad
14:24:19 <dons> ah, not the high end stuff galois does
14:24:28 <malcolm> such techniques are only mandated for SIL 3+4
14:24:30 <astrolabe> In the introduction to the recent C++ numerical recipes, the authors say that their test code has found bugs in many C++ compilers.
14:25:04 <Heffalump> of course, one important factor is programmer skill. And there are quite a few very good C++ programmers around who can probably write code that is relatively bug-free.
14:25:11 * Oejet is afraid to look inside a C++ compiler.
14:25:21 <malcolm> Also, I would guess that because ABS brakes are a safety-add-on, they would be only be SIL 2.
14:26:33 <shapr> Heffalump: I would like for you to consider this paper: http://lambda-the-ultimate.org/node/view/652
14:26:50 <astrolabe> I s'pose you'd need to prove the computations finish quickly enough as well as correctly.
14:26:59 <work_metaperl> Heffalump: it looks like Clean is similar to haskell, but faster?
14:27:12 <work_metaperl> Igloo: any feedback on Clean? it looks similar to haskell but faster
14:27:26 <Igloo> I've never used it
14:27:36 <Heffalump> work_metaperl: what does?
14:27:38 <work_metaperl> Igloo: the debian shootout results
14:27:46 <work_metaperl> Heffalump: the Clean programming language
14:27:48 <Igloo> I'm not sure what you're asking me
14:28:08 <monochrom> I am similar to Haskell but faster and smarter.
14:28:11 <work_metaperl> Igloo: you had some data on haskell and string searches. Maybe you should do them in Clean?
14:28:41 <Heffalump> shapr: right, so a researcher focusing on a particular algorithm managed to make abstracted code closer to the best C implementation.
14:28:49 <Igloo> There's no benefit for me, but you could add clean cupport if you wanted
14:28:56 <Heffalump> what does that show, apart from the fact that things are getting better for high-level languages?
14:29:37 <Igloo> s/string/raw memory/ really, incidentally
14:30:51 <shapr> Heffalump: As for "<Heffalump> Well, you're wrong. And your continuing assertions that fly in the face of reason do Haskell a disservice, IMO." Could you list my continuing assertions that fly in the face of reason?
14:31:10 <grkic> :Work_metaper im not a registered member so i cant talk to you in priv ... :(
14:31:30 <grkic> need to reg...be right back
14:31:39 <shapr> I believe I've flown in the face of your opinion, and nothing more than that.
14:31:47 <basti_> i worked a bit with clean before i was doing haskell
14:31:49 <Heffalump> the ones about speed of change being more important than runtime speed in all situations. But as I said, there's no point in continuing this discussion.
14:31:53 <astrolabe> Would it be possible to include monadic operations in Hakell for direct control of the cpu?
14:31:56 <work_metaperl> grkic: what is your question/
14:32:16 <Heffalump> astrolabe: hard to see how GC could work if you can control everything about the machine inside Haskell.
14:32:39 <Heffalump> cos you could stomp on the heap and stuff. Though I guess that's no different from C.
14:32:52 <Heffalump> what you're really asking for is monadic inline assembler, I guess.
14:33:07 <astrolabe> Heffalump: yes
14:33:17 <shapr> Heffalump: I don't think I said that speed of change of change is more important in all situations.
14:33:33 <shapr> Even if I did, you have given me opinion, not reason.
14:33:36 <Heffalump> shapr: fine. I think you did. Can we just drop it?
14:33:47 <grkic> ok.......  type Env = [(String,Bool)]             and i need to make a function that looks like this  value :: String -> Env -> Bool    so when typing a string t will return the Boolean next to it.     ex.value "x" [("x",True),("y",False)] = True
14:33:51 <astrolabe> together with instructions for getting haskell's structures out of the way first.
14:34:06 <work_metaperl> should I schedule a pay-per-view boxing match between shapr and Heffalump?
14:34:11 <int-e> @type lookup
14:34:12 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
14:34:13 <Heffalump> astrolabe: I can't see any reason in principle that it couldn't be done, but I'm not sure there's much benefit to be had.
14:34:41 <basti_> grkic: lookup. see int-e.
14:34:51 <grkic> ok thx
14:34:57 <shapr> Heffalump: You said that my assertions do Haskell a disservice. How does that work?
14:35:48 <Heffalump> because if people believe you and then discover that you are wrong, they will be more suspicious of future claims by others
14:35:57 <int-e> work_metaperl: try selling sodas and popcorn.
14:36:19 <work_metaperl> then Heffalump and shapr will throw them at each other :)
14:36:55 <Heffalump> :-)
14:37:05 <basti_> throwing popcorn is ok
14:37:10 <Heffalump> eating it is better
14:37:11 <basti_> soda bottles is not
14:37:16 <autrijus> I'd like some pushcorns
14:37:29 <xerox> √≤karma- autrijus
14:37:30 <autrijus> popcorns are overrated.
14:37:32 <xerox> oops..  ;-)
14:37:34 <work_metaperl> the only use for soda is throwing it... either throwing it up or throwing it out
14:37:39 <basti_> rule of thumb: "*rustle*" = ok for throwing, "*ponk*" = not ok
14:37:41 <work_metaperl> it does not belong in the human body
14:37:57 <shapr> Heffalump: So what? I'm not Haskell. We all just try to figure stuff out the best we can. I'm doing my best, I assume you're doing yours.
14:38:06 <wagle> throwing popcorn in the exception monad?
14:38:06 <work_metaperl> push corn, pop corn, unshift corn, shift corn
14:38:13 <xerox> resetcorns
14:38:15 <autrijus> splicecorns
14:38:20 <basti_> argh
14:38:21 <work_metaperl> :)
14:38:22 <wagle> cornads
14:38:26 <work_metaperl> LOL
14:38:31 <xerox> call-with-current-corn
14:38:32 <work_metaperl> cornads .... LOLOLOL
14:38:32 <basti_> call/cccorns
14:38:37 <Oejet> cocorns
14:38:37 <xerox> ahah!
14:38:37 <work_metaperl> lol
14:38:40 <int-e> cornads are generalized stacks?
14:38:48 <xerox> co-cornads
14:38:50 <Heffalump> shapr: I'm just commenting on your opinions. I obviously don't have any power to make you act differently.
14:38:55 <xerox> (along the lines of co-monads)
14:38:57 <wagle> xerox: rnads
14:38:57 <Oejet> xerox: Too late. :-P
14:39:00 <astrolabe> Online discussions escalate too easily because of lack of non-verbal signals.
14:39:00 <work_metaperl> thats so corny
14:39:04 <xerox> Oh.
14:39:10 <autrijus> cornads can be generalized to carrowts
14:39:17 <work_metaperl> lol
14:39:27 <xerox> Ziporns
14:39:28 <shapr> Heffalump: But my opinions aren't Haskell's opinions, neither are yours... what's the problem?
14:39:33 <Heffalump> autrijus: you are a deeply disturbing individual :-)
14:39:34 <xerox> It sounds.. :D
14:39:47 <xerox> Zippcorns
14:40:00 <Heffalump> shapr: people will tend to apply some degree of association between different Haskell advocates
14:40:17 <autrijus> Heffalump: wait until I evolve into a disturbing committee.
14:40:28 <shapr> I seriously doubt anyone smart enough to learn Haskell is going to consider anything to be pure gospel.
14:40:54 <Heffalump> of course not. That doesn't mean opinions don't have influence.
14:40:56 <astrolabe> True, even for some of us not smart enough :)
14:41:38 <autrijus> gah, I found the unpleasing truth -- the GHC bundled with Visual Haskell is a crippled 6.5
14:41:46 <Heffalump> crippled how?
14:42:15 <wagle> Visual Haskell # .net?
14:42:17 <autrijus> the IDE complains it can't find Control.Monad.ST, even though I listed base
14:42:21 <autrijus> as the dependency
14:42:26 <autrijus> same for GHC.Exts
14:42:39 <autrijus> without those two, I can't compile Data.FastPackedString
14:42:44 <autrijus> and hence none of the new pugs stuff.
14:42:44 <xerox> ST /= State ?
14:42:49 <autrijus> xerox: no, ST is ST
14:42:50 <Heffalump> xerox: correct
14:42:57 <xerox> ST = ?
14:42:59 <wagle> i'd look for some example code that asked it in the odd but acceptable way
14:43:06 <astrolabe> But if it is someone's honest opinion, based on their experience, that is unreproachable.  You just need to know that if you are doing something different, you're experience might differ.
14:43:35 <Heffalump> astrolabe: right. I just think shapr is generalising excessively.
14:44:03 <shapr> My blog entry says "I value speed of change"
14:44:10 <Heffalump> but I've stated my opinion, and he's stated his, and we've persuaded everyone we're going to persuade of the relative merits, so there's no point in continuing :-)
14:44:54 <xerox> I.e. the continuation is id
14:44:56 <basti_> theres no point in even explaining this
14:45:03 <autrijus> reanimating dead horses is, I hear, apparentice necromancers' favourite pastime.
14:45:04 <basti_> we've all done this
14:45:25 <work_metaperl> do you know how much YiDE hacking you 2 could've done by now? all this arguing when you could be hacking
14:45:40 <xerox> bzzt
14:45:47 <autrijus> hIDE is called YiDe now?
14:45:53 * Heffalump is trying to prove some stuff about darcs patch theory.
14:46:11 <work_metaperl> I think yide is an editor written by dons. I dont know what hide is.
14:46:12 <autrijus> with an integrated shell and it may turn into YidDEsh
14:46:18 <work_metaperl> lol
14:46:27 <Heffalump> hIDE is the dcoutts+dons(+others?) IDE
14:46:33 <work_metaperl> alt.religion.torah.haskell.yiddesh
14:46:35 <Heffalump> yi is a standalone text editor and also a plugin for hIDE
14:46:47 <work_metaperl> oh
14:46:57 <xerox> Goodnight, Haskellers.
14:46:57 <work_metaperl> and what is visual haskell? does it fit in the picture?
14:47:05 <astrolabe> night xerox
14:47:12 <work_metaperl> we are not haskellers. we are Heffalumpers
14:47:28 <Heffalump> work_metaperl: a Visual Studio plugin for Haskell.
14:47:37 <work_metaperl> oh, a winders thing
14:47:44 <dons> yi is an editor written by dons
14:47:56 <basti_> I've seen labview at work. THATS visual programming
14:48:12 <dons> hIDE is the working name for hIDE-2, currently Lemmih, dcoutts and dons :)
14:48:26 <astrolabe> But it has a tendancy to get tangled I understand.
14:49:22 <autrijus> . o O ( Glasgow Heffalump Compiler )
14:49:29 <Heffalump> work_metaperl: winders?
14:49:42 * Heffalump worries about getting compiled into something low-level and unintelligible
14:49:52 <autrijus> winders is a soundalike for windows
14:49:54 <Heffalump> oh, "windows"
14:49:54 <Heffalump> yeah
14:50:05 <Heffalump> especially in Cockney :-)
14:50:57 * autrijus tries to picture a desugared, renamed, typechecked and simplified Heffalump
14:51:05 * autrijus decides to abort that particular thread of thought.
14:51:21 <Heffalump> thank you.
14:51:32 * wagle hands Heffalump a cookie to resugar him
14:51:48 <basti_> uhm Heffalump, one question: are you chatting from liechtenstein or is that a hallucination?
14:52:03 <Heffalump> just a domain name
14:52:07 <Heffalump> the machine is in London
14:52:13 <Heffalump> and I'm in Cambridge (UK)
14:52:17 <basti_> oh ok.
14:52:21 * basti_ nods
14:52:32 <Heffalump> http://www.earth.li sort of explains
14:52:34 <work_metaperl> there's no premiere league soccer team in Cambridge is there?
14:52:34 <Heffalump> (I think)
14:52:39 <Heffalump> work_metaperl: no.
14:52:39 <basti_> ah "earthly"
14:52:44 <basti_> okay i didnt get that
14:52:48 <Heffalump> I think the soccer team just got relegated to the Conference :-)
14:52:57 <basti_> i've wondered what kind of sentiment would make people consider liechtenstein for anything.
14:53:33 <autrijus> Heffalump: uhm, one question, what does the nick Heffalump stand for?
14:53:46 <wagle> this channel needs a FAQ
14:53:52 <wagle> 8)
14:53:58 <basti_> its a cartoon character
14:54:06 <rep> @#!#@!#@!
14:54:07 <lambdabot> Unknown command, try @listcommands.
14:54:10 <rep> WHY OH WHY
14:54:11 <wagle> @Heffalump
14:54:12 <lambdabot> Unknown command, try @listcommands.
14:54:16 <rep> d: warning prebinding disabled because dependent library: /opt/local/lib/libgmp.3.dylib is not prebound
14:54:19 <rep> ld: Undefined symbols:
14:54:22 <rep> _rl_initialize
14:54:22 * basti_ hugs rep
14:54:24 <rep> _rl_reset_terminal
14:54:27 <Heffalump> autrijus: a winnie-the-pooh character
14:54:27 <rep> _add_history
14:54:30 <rep> _readline
14:54:32 <Heffalump> which is elephant-like
14:54:41 <rep> ghc hates me :(
14:54:44 <Heffalump> and "Ganesh" is a Hindu elephant god
14:54:45 <autrijus> ah. thanks.
14:55:01 <Heffalump> and I like bouncing, and stomping on things.
14:55:05 <Heffalump> Particularly stairs.
14:55:26 <work_metaperl> elephants are vegetarians. but look how large they get
14:55:29 <autrijus> I like stomping on bugs.
14:55:54 <autrijus> it gives me this zilla feeling.
14:56:12 <Heffalump> surely it gives you a rt feeling? :-)
14:56:27 <autrijus> recently it's a hiveminder feeling :)
14:57:44 <int-e> @type scanl
14:57:45 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
15:00:47 <dcoutts> dons, you back home already then?
15:02:31 <davve> dcoutts,dons: did you guys agree on a ghc 6.5 snapshot for hIDE?
15:10:50 <prionic> is there a haskell aquivalent to the c++ standard constructors (int(), float(), etc...)? I need them to return a valid value as fallback
15:11:28 <basti_> prionic: uhm
15:11:47 <basti_> prionic: did you ever manage to create an uninitialized variable in haskell?
15:12:47 <basti_> but other than that:
15:13:00 <basti_> @plugs (maybe 123 id (Just 5),maybe 123 id (Nothing))
15:13:02 <lambdabot> (5,123)
15:13:48 <basti_> Maybe is a datatype for things that might not happen
15:14:52 <prionic> yes thats good, but i dont want to set the fallback values by my self... is there a constant for each type?
15:15:06 <Korollary> prionic: I don't understand what you are asking
15:15:44 <work_metaperl> prionic: what are you doing? what is your problem to be solved? actually SJT has a nice section on error handling and shows 3 different methods (which I have all forgotten :)
15:16:02 <prionic> im looking for something like (Maybe a) -> a
15:16:07 <dcoutts> davve, actually we're still using 6.4.1
15:16:08 <work_metaperl> prionic: tell us your entire problem spec
15:16:42 <basti_> prionic: why don't you just pack maybe conveniently?
15:16:49 <basti_> like: maybe0 = maybe 0 id
15:16:58 <int-e> . o O ( class Default a where default_value :: a ... extractMaybe :: Default a => Maybe a -> a; extractMaybe = maybe default_value id ... )
15:17:00 * int-e ducks
15:17:00 <davve> dcoutts, okay.. I downloaded and tried to build ghc-api with ghc 6.4.1 to try out the latest hIDE, but ghc panics when building ghc-api
15:17:09 <davve> :(
15:17:16 <davve> Lemmih says he don't know why
15:17:30 <prionic> int-e: that exists?
15:17:32 <basti_> int-e: yes, a class Default could make sense, but it would be definitely overengineered
15:17:37 <int-e> prionic: I hope not.
15:17:39 <autrijus> prionic: you can write that in pure haskell, sure
15:17:46 <basti_> for most purposes
15:17:52 <int-e> basti_: I agree
15:17:54 <prionic> int-e: why not?
15:17:58 <dcoutts> davve, you're not using and amd64 are you?
15:18:18 <int-e> prionic: it seems to make little sense really, with existing Maybe class and maybe utility function.
15:18:21 <basti_> prionic: that'd be like shooting sparrows with cannons.
15:18:26 <prionic> yeah ill would write that for my project if i dont find something similar
15:18:26 <davve> dcoutts, nope
15:18:43 <Korollary> You don't need 'fallback' values because you can use Maybe. If you don't wanna write code that deals with the Nothing case, then don't, and there will be a runtime error.
15:18:50 <int-e> prionic: and you can easily make one for yourself if you really feel it's necessary.
15:19:08 <basti_> basically it's not an issue
15:19:12 <prionic> Korollary: thats just what i dont need runtiome errors
15:19:30 <dcoutts> davve, what was the error exactly?
15:19:38 <basti_> prionic: then default with maybe at a strategic place
15:19:45 <work_metaperl> prionic: where is input coming from?
15:20:03 <work_metaperl> prionic: i asked for an entire problem spec.
15:20:05 <autrijus> class Default a where default :: a
15:20:20 <autrijus> instance Default Int where default = 0
15:20:21 <autrijus> etc.
15:20:23 <prionic> work_metaperl: xml -> string -> read
15:20:28 <autrijus> is more lightweight and may just work.
15:20:43 <basti_> autrijus: and then dodefault :: Maybe a -> a
15:20:47 <prionic> autrijus: thats what i had in mind
15:20:47 <autrijus> aye.
15:20:49 <basti_> hmm
15:21:00 <basti_> that brings a question to my mind
15:21:20 <basti_> can we express general folds/unfolds in haskell?
15:21:25 <autrijus> or, in spirit of a certain language, you can call it "undef" instead of "default"
15:21:37 <basti_> uhm no
15:21:42 <basti_> yes, folds/unfolds
15:21:46 <autrijus> you can then write "undef" and, depending on the expected type, it will mean 0, or an empty string, or whatever else.
15:21:59 <basti_> where the fold for Maybe would be maybe
15:22:04 <int-e> autrijus: that's clutter with Preludes' 'undefined'...
15:22:17 <autrijus> @type Data.Generics.gfoldl
15:22:18 <basti_> the fold for Id would be id. the fold for list is foldr etc.
15:22:19 <lambdabot> forall a (c :: * -> *).
15:22:19 <lambdabot> (Data.Generics.Basics.Data a) =>
15:22:19 <lambdabot> (forall a1 b.
15:22:19 <lambdabot> (Data.Generics.Basics.Data a1) =>
15:22:19 <lambdabot> c (a1 -> b) -> a1 -> c b)
15:22:21 <lambdabot> -> (forall g. g -> c g)
15:22:23 <lambdabot> -> a
15:22:23 <autrijus> basti_: like that?
15:22:25 <lambdabot> -> c a
15:22:26 <int-e> @type undefined
15:22:27 <lambdabot> forall a. a
15:22:31 <basti_> oh cool
15:22:34 <int-e> @pl undefined
15:22:35 <lambdabot> undefined
15:22:43 <int-e> @eval undefined
15:22:44 <lambdabot> <irc>:1:25:
15:22:44 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:22:44 <lambdabot>   `Show a' arising from use of `show' at <irc>:1:25-28
15:22:44 <lambdabot>   Probable fix: add a type signature that fixes these type variable(
15:22:44 <lambdabot> s)
15:22:45 <basti_> that must be it although i don't understand it
15:22:55 <int-e> @eval undefined :: Int
15:22:57 <lambdabot> Prelude.undefined
15:22:59 <autrijus> there's also a gunfold.
15:23:12 <autrijus> basti_: taking some time to learn SYB is probably worthwhile :)
15:23:15 * basti_ nods
15:23:25 <Korollary> what is syb ?
15:23:25 <basti_> SYB?
15:23:27 <autrijus> boil your scratchpads
15:23:33 <autrijus> er, I mean, scratch your boilerplates.
15:23:37 <Korollary> ah
15:23:38 <basti_> ah
15:23:38 <prionic> how do i catch the read "no parse error" exception?
15:23:53 <basti_> boilerplate is a nice thing
15:23:57 <autrijus> prionic: use readIO and catch, for one
15:24:24 <prionic> autrijus: thats in the io monad, i figure
15:24:28 <autrijus> aye.
15:24:35 <prionic> no good
15:24:47 <araujo> Hello haskellers
15:25:07 <autrijus> prionic: in that case, reads.
15:25:13 <Korollary> hello araujo. did you get my pm last night ?
15:25:18 <prionic> @type reads
15:25:19 <lambdabot> forall a. (Read a) => ReadS a
15:25:27 <araujo> Hello Korollary , mm.. letme check
15:25:30 <autrijus> reads "foo" :: [(a, String)]
15:25:39 <autrijus> then test if the list is null, which would mean and failed read.
15:26:18 <basti_> uh
15:26:21 <prionic> autrijus: hey thanks, thats it (what does the a mean)
15:26:34 <autrijus> prionic: "a" is whatever type you are reading into.
15:26:40 <autrijus> the (Read a) part.
15:27:28 <araujo> Korollary, mm, can't find anything here, you could send it me again
15:27:35 <araujo> ?
15:33:48 <dcoutts> davve, well when we both have some time let's try and debug that build problem. Perhaps when JaffaCake is back.
15:35:08 <davve> dcoutts, sure
15:35:20 <araujo> Korollary, you've got mail
15:36:08 * araujo goes to get sleep 
15:36:32 <Korollary> thanks
15:42:52 * basti_ is going to bed
16:08:16 <vincenz> Hello
16:09:10 <Heffalump> hi
16:09:24 <vincenz> Anyone knowledgeable of clean?
16:09:38 <araujo> Korollary, invite ther haskellers too :-)
16:09:46 <araujo> other even
16:10:05 <araujo> vincenz, this channel is about Haskell
16:10:06 * Heffalump tries out jhc
16:10:39 <vincenz> araujo: yes but it's supposedly very similar to haskell so I was curious as to the differences
16:10:43 <Heffalump> araujo: given the lack of a #clean and the similarities between the languge, I don't think it's unreasonable to have the odd Clean conversation
16:10:47 <araujo> ah ok,
16:10:50 <dons> araujo, Clean is alsmost haskell. certainly revlevant here.
16:10:55 <Heffalump> but I don't know anything about the similarities :-)
16:11:01 <Heffalump> I just hear they exist.
16:11:12 <araujo> Really?, i didn't know Clean was almost Haskell.
16:12:52 <araujo> I just was pointing out that probably vincenz would like to try other channel, but if it is the same :-]
16:13:34 <vincenz> anyone knowledgeable as to the differences?
16:17:03 <Cale> vincenz: the IO system is the major difference
16:17:28 <dons> linear types too. also they have much better dynamics
16:17:36 <dons> uniqueness types, sorry. /me is tired
16:17:56 <vincenz> Cale: how so?
16:18:05 <Cale> yeah, they use uniqueness types in order to make sure that IO is done correctly.
16:18:22 <Cale> (rather than having an IO monad)
16:19:09 <vincenz> which do you consider superior?
16:20:47 <Heffalump> anyone know if JohnMeacham is interested in receiving jhc bug reports (the reason I think he may not is that he acknowledges it doesn't compile everything atm)
16:21:06 <Cale> Well, I rather like Haskell's way of doing it - monads are a rather nice uniform way to capture different kinds of effects. But I don't really have enough experience with Clean's way of doing things to say that either one is better.
16:21:31 * vincenz nods
16:23:05 <vincenz> ok
16:23:06 <vincenz> thx
16:31:16 <prionic> @type maybe
16:31:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:34:06 <Heffalump> anyone know how to make jhc output C?
16:37:55 * Heffalump discovers that it just does automatically, doh :-)
17:10:17 <wagle> anyone gotten clean to work on macosx 10.4?
17:23:12 <JohnMeacham> yup. the C code generator is pretty simple, just a few hundred lines with room for lots of improvements.. it should be pretty easy to write another code generator if anyone wants a simple project..
17:23:24 <JohnMeacham> for some definition of simple.
17:24:19 <JohnMeacham> the output is a whole lot more verbose than it needs to be for one. and I'd like to annotate more things with comments.
17:24:56 <Heffalump> johnmeacham: are you interested in examples of medium-sized programs jhc can't compile?
17:25:05 <Heffalump> or do you have plenty of failures to be going on with? :-)
17:25:31 <Heffalump> it was quite a funny error message:
17:25:33 <Heffalump> What:    type unification error
17:25:33 <Heffalump> Why:     attempted to unify a -> b with a -> b
17:25:34 <JohnMeacham> Heffalump: it depends on the reason it can't compile it. if it is a new one then I am certainly interested :)
17:26:20 <Heffalump> (is that the error message you'd also get if the program had a real type error?)
17:26:29 <JohnMeacham> Heffalump: ah. yeah, send me those. are you sure you arn't using any ghc extensions?
17:26:40 * Heffalump checks
17:27:10 <JohnMeacham> Heffalump: yeah, that is part of why I want to spin off the front end as a seperate haskell type checking library. so other people can help improve it without having to mess with jhc internals...
17:27:16 <Heffalump> it certainly doesn't get compile with any flags like -fglasgow_exts
17:27:38 <JohnMeacham> okay. send it to me. in any case, that error message seems very odd.
17:28:16 <Heffalump> actually, another file in the compile is using cpp and I didn't pass -f cpp or the pre-defines to jhc. Could that have confused it?
17:28:35 <Heffalump> but the other file is a parsing module, and the one with the error is a pretty-printer, so they aren't directly linked
17:28:48 <JohnMeacham> Heffalump: maybe... but I'd expect a different message then... in any case, jhc is buggy in that it didn't catch the error earlier and give a saner message.
17:28:49 <prionic> @hoogle Either
17:28:51 <lambdabot> Prelude.either :: (a -> b) -> (c -> b) -> Either a c -> b
17:28:51 <lambdabot> IO.try :: IO a -> IO (Either IOError a)
17:29:50 <prionic> @hoogle type
17:29:52 <lambdabot> Prelude.asTypeOf :: a -> a -> a
17:30:12 <JohnMeacham> I believe it is a jhc error though, because when it says a it actually means a_32 for some unique number (but it doesn't display it when printing) so I am guessing those numbers arn't lining up giving that error message... which is bad, but trackdownable.
17:30:22 <Heffalump> right
17:31:53 <blob> so, anyone using ubuntu here? Is there some repository with up to date haskell packages?
17:32:55 <Heffalump> JohnMeacham: ok, darcs get http://urchin.earth.li/darcs/ganesh/mag/, then in src/ try to compile AGMain.hs
17:33:46 <Heffalump> [I also get a confusing error when trying to compile Main.hs, but you have to first create Infer.hs using make, which first builds the thing that AGMain.hs is for, to be able to compile that]
17:36:44 <JohnMeacham> okay. I will look into it.
17:37:11 <Heffalump> cool. (I have no particular need to actually compile this program with jhc, I was just interested to see how much faster it'd run if I did)
17:37:29 <Heffalump> btw, did you hear about the Haskell '06 thing?
17:37:42 <blob> new standard?
17:38:21 <Heffalump> blob: yes
17:38:25 <Heffalump> well, that's the plan
17:39:54 <Heffalump> hi borism_
17:39:58 <JohnMeacham> heh. probably no faster at the moment. I have several key optimizations disabled as I work on them.
17:40:10 <Heffalump> JohnMeacham: fair enough :-)
17:40:40 <JohnMeacham> but it does have very small binary sizes :) on the order of 10's of k rather than hundreds of k to megabytes for ghc.
17:41:02 <Heffalump> anyway, John Launchbury is coordinating the Haskell '06 standard at the moment - it was discussed at the HW. The idea is to be a fairly small extension to H98 and to clean up a few misfeatures.
17:41:23 <prionic> whats the  "Scrap your boilerplate" style of generic programming ?
17:41:27 <Heffalump> Since you're a Haskell implementer, you might want to contact him about it. He asked anyone who was interested in helping to email him.
17:41:47 <Heffalump> prionic: read the paper of that name by Simon Peyton Jones and Ralf Laemmel
17:41:55 <prionic> will do
17:41:57 <Heffalump> and a couple of others with similar names that take the concept further
17:43:09 <JohnMeacham> ah. how will it be determined? a small group of people or an open thing on the list?
17:43:19 <Heffalump> there'll be a committee, as usual
17:43:32 <Heffalump> and they'll make the final decision
17:43:33 <Heffalump> s
17:43:49 <Heffalump> but there'll be an open RFC process for discussing things.
17:44:19 <Heffalump> John's call for volunteers included volunteers to serve on the committee.
17:44:31 <Heffalump> I expect something will appear on the mailing list befor elong.
17:45:41 * Heffalump heads to bed
17:46:23 <Heffalump> (on the subject of binary sizes, I was impressed by the size of hello world, but disappointed that the C code for it made no sense at all. Is there an easy explanation for why it doesn't end up as the equivalent C?)
18:03:11 <JohnMeacham> Heffalump: try looking at the C code generated by ghc sometime :)
18:05:05 <JohnMeacham> Heffalump: the main reasons it doesn't look like the C code are that string literals are stored in their haskell representation, i.e. a sequence of list cons cells holding a single character each. and that the definiton of putStrLn is notably different than the C puts or printf in that it evaluates and prints each character independently one at a time.
18:08:08 <rep> Heffalump what size did you get for hello world?
18:13:41 <JohnMeacham> It would be perfectly possible to store string literals as C UTF8 strings and have a routine that reads them... I havn't done it yet because I think it would be neat if said code didn't self-update, since producing the haskell list is trivial and we don't want to take up memory with a big haskell list when we have a compressed form right there..
18:15:24 <JohnMeacham> ghc treats string literals as special in various ways to do similar things.. I have avoided doing so in jhc because I don't like special purpose code. ideally it would be an analysis that finds any constant lists of unboxed values that can be stored in a compressed form.
18:17:17 <prionic> is this valid? : val::(Read a, Typeable a)=> a -> String
18:17:21 <JohnMeacham> I added a new pragma "SUPERINLINE" which not only inlines functions where they are used, but instantiates a new copy of the function for each higher-order use of it. this seems to greatly improve the points to in some cases as things like 'id' and '$' end up with huge eval blocks since pretty much anything can be passed to them.
18:19:15 <JohnMeacham> id is particulary notorious. as all it is is an 'eval'. it ends up unifying every occurance of id so anything that analises its results in turn ends up with a huge eval block.. you can see that in the generated C code as enormous odd switch statements.
18:25:31 <JohnMeacham> rep: I believe it is somewhere around 8k or was it 18k... something like that.
18:25:53 <rep> is that good? :P
18:27:22 <JohnMeacham> rep: ghc is 150k I think.
18:27:45 <rep> JohnMeacham and yet it takes _forever_ to compile
18:28:45 <JohnMeacham> rep: not forever. but on the order of minutes. but it will be much faster. hopefully sooner rather than later once we get prepackaged libraries set up so you don't have to recompile the whole prelude every time.
18:29:21 <rep> minutes?
18:29:26 <rep> it takes 8 hours, here
18:31:38 <JohnMeacham> rep: hm. what are you compiling?
18:31:46 <rep> ghc!
18:31:59 <juhp> haha
18:32:23 <JohnMeacham> heh. 8 hours to compile ghc seems pretty fast to me :)
18:32:50 <rep> heh.
18:33:14 <rep> i personally think it's ridiculous :)
18:33:31 <JohnMeacham> though, there are exponential growth bugs that are triggered by some programs.. the lambda program from nofib seems to do so reliably making it take about a half-hour rather than 3 minutes for comparably sized programs.
18:33:43 <rep> heh
18:34:20 <JohnMeacham> I am still looking for an expert on constraint solving to rewrite Fixer.hs to make it fast :)
18:34:33 <rep> well, i think i'll go to bed
18:34:51 <rep> but first, i'll leave you with an awesome video
18:34:56 <rep> http://video.google.com/videoplay?docid=-8218176694028201834&q=Ballmer
18:35:28 <JohnMeacham> I am not even sure it is a constraint solving problem to begin with.. it seems too simple.
18:35:34 <rep> night :)
18:35:38 <JohnMeacham> night.
19:07:56 <sh10151> does anyone have an acm membership?
20:30:37 <SamB> hmm, something turned off autorepeat in X... how to turn it on again...
20:35:08 <SamB> ah, `xset r'
20:36:58 <Pseudonym> Does anyone know anything about Bluespec?
20:47:43 <wagle> a little
20:48:31 <Pseudonym> Ah, I found some papers.
20:48:36 * Pseudonym shall read them
20:48:40 <wagle> i tried to figure it out about two (one?) years ago, and missed getting the open version of the compiler by about a month..  they went propritary
20:49:00 <wagle> i didnt even find any decent papers..  just a manual
20:49:34 <wagle> let me know if you find anyt good papers
21:01:52 <humasect> okay... NOW i will read TMR.
21:05:10 <heatsink> What is it called when logical deduction is applied backwards, reasoning from conclusion to premises?
21:06:50 <int-e> @where tmr
21:06:51 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
21:08:55 <ptolomy> Hah. I showed my lawyer friend a few lines of rather obfuscated haskell this morning, and I just found out that he's been working on it all day. he was intrigued enough to read the gentle introduction, and now he's asking for more.
21:08:57 <ptolomy> crazy bastard.
21:09:39 <cjs_> heatsink: depends on how you do it. One fallacy that works like that is called "asserting the consequent."
21:10:01 <Pseudonym> The last thing we need in Haskell is lawyers.
21:10:33 <ptolomy> hehe.
21:10:37 <Pseudonym> Though I'm sure your friend is the exception.
21:11:09 <ptolomy> well, apparently he finds trying to decypher the semantics of haskell more interesting than lawyering, so he gets some points.
21:11:17 <heatsink> :)
21:11:38 <cjs_> const * const appendr :: const [a] -> const *a -> const a
21:12:19 <cjs_> I can't say I miss the good ol' days of C and language-lawyering.
21:13:41 <ptolomy> actually, I believe he sues people on the behalf of record companies, so distracting him is positive all around.
21:15:28 <heatsink> cjs_: I'm describing goal-directed construction of a proof tree.  I just thought someone here would know a name for it.
23:52:33 * boegel breaks the silence
23:55:32 * Pistahh glues the pieces together
23:55:33 <trez> damn you!
