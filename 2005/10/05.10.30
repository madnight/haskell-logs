00:00:57 <Oejet> pesco: The Danish empire including colonies used to be very big (think Greenland).
00:01:12 <Oejet> Enough talk, though.
00:01:25 <pesco> Yes, I'm from Pinneberg, which used to be Danish some time way back, the last outpost before Hamburg. :)
00:02:07 <pesco> Your countrymen built a nice town hall for us. :) Okay, enough chatter.
00:02:16 * pesco hurries to another desktop.
00:02:19 <Oejet> Btw. I'm from Copenhagen.
00:02:58 * pesco shouts, from another desktop, "Ah, I see. I think I've been there once..."
00:05:45 <m3ga> Oejet: I was in Copenhagen just last week :-)
00:10:42 <Oejet> m3ga: What did you do?
00:13:07 <Oejet> Hello, xerox.
00:13:12 <xerox> Hi!
00:13:31 <xerox> Thanks to the person who put lambdabot in #haskell.it :)
00:16:15 <xerox> What's up, folks?
00:17:28 <Cale> not much
00:17:53 <m3ga> Oejet: visited relatives :-)
00:20:54 * Cale goes off to play Homeworld 2
00:21:10 * xerox goes hunting for breakfast
00:35:58 <araujo> @index hFlush
00:35:59 <lambdabot> System.IO
00:37:38 <xerox> What System.IO.writeFile there before GHC 6.4.1?  I noticed it only yesterday - very, very handy.
00:37:48 <xerox> s/What/Was/
00:42:14 <araujo> Hello xerox
00:42:18 <araujo> yeah, it is handy
00:42:29 <araujo> @index remove
00:42:30 <lambdabot> bzzt
00:43:32 <araujo> What is the function to replace an element for another in a list?
00:55:07 <xerox> araujo: if you want to replace elements positionally I think you have to roll up your own function.
01:29:07 <xinming> @map
01:29:08 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
01:35:14 <jyp> @yow
01:35:15 <lambdabot> Frivolity is a stern taskmaster.
01:54:09 <kala> can I skip the "else" part of the "if" expression?
01:54:24 <kala> or if pred then do_something else do_nothing?
01:54:43 <kolmodin> kala: no
01:55:02 <shapr> Since Haskell is purely evaluation, you have to do something. if then else is just syntactic sugar for a case expresion.
01:55:29 <kolmodin> kala: what should the expression return if the condition evaluates to false?
01:56:19 <araujo> hey shapr !
01:56:22 <shapr> hiya araujo
01:56:28 <araujo> shapr, http://paste.lisp.org/display/13028
01:56:35 <kala> kolmodin: oh, right.
01:56:36 <araujo> Take a look at some examples :-]
01:56:39 <kombinator> kala: if your writing it in monadic style you can use when :: (Monad m) => Bool -> m () -> m ()
01:57:50 <kolmodin> @type Control.Monad.when
01:57:51 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:20:54 <kala> what would be proper way of parsing imput file of semicolon separated data? use regular expressions ?
01:20:59 <kala> input file
01:22:06 <basti_> there is regex and parser packages
01:23:13 <xerox> ...and patter matching :)
01:23:45 <kala> yes, I was wondering if I could do it without special regexp package?
01:23:52 <basti_> yes, for the simple cases
01:24:15 <basti_> you could accumulate a string until you find a ;
01:24:17 <kala> for lines like A.2.1.2; "Programmer obtains the code";  LEAF; arvud
01:24:45 <xah> i made a haskell logo: http://xahlee.org/haskell/haskell-logo.png
01:24:59 <xerox> Hi xah !
01:25:12 <xerox> I was about to ask if you were Xah Lee :)
01:25:50 <Philippa> you know you're infamous when ;-)
01:26:30 <xerox> I passed much time in the graphics gallery.. :)
01:26:36 <xah> i see that some of you are "registered". What does it mean to be registered?
01:26:48 <kala> basti_: but I cannot do things like parse xs1:";":xs2:";": ... = do_something ?
01:26:48 <xerox> xah: /MSG ChanServ HELP REGISTER
01:27:03 <xerox> kala: with Parsec, surely!
01:27:14 <basti_> kala: hmm you can do -similar- things.
01:27:20 <xerox> :-)
01:27:29 <kala> ok, let me read a bit of documentation
01:27:33 <xah> xerox: sorry... new to irc. don't quite get it. But what do i get to be registered?
01:28:10 <xerox> xah: /QUERY ChanServ will open a private communication channel with ChanServ, which is a service.  Then type "HELP" in there.
01:28:20 <xerox> Errrrr!  NickServ, I'm sorry :-)
01:29:09 <xerox> (That is, /QUERY NickServ)
01:54:30 <JohnMeacham> happpy! holoowweeen!
01:54:33 <JohnMeacham> almost.
01:54:51 <xah> haskell logo, now in public domain: http://xahlee.org/haskell/haskell-logo.html
01:54:52 <JohnMeacham> happy! was the key part.
01:56:56 <Philippa> 'twould be nice
02:11:45 <kala> when I compile a regexp with mkRegex, do I need to quote any characters in regular expression?
02:12:33 <kala> I'm getting parse error on the next line of the mkRegex and I cannot figure out why
02:13:09 <Philippa> it takes an ordinary Haskell string if that's what you mean?
02:13:34 <kala> yes, wait a moment, I'll paste the whole code
02:16:40 <boegel|home> kala: no more than 3 lines in here !
02:17:14 <kala> http://pastebin.com/410790
02:17:22 <kala> boegel|home: yes :)
02:17:45 <boegel|home> kala, ok , I just thought you were going to paste it in here :)
02:18:20 <xerox> <boegel preemptive-mode="off">
02:18:21 <kala> oh, I messed up the line numbers. line 15 is the "hClose inputHandle" line
02:18:49 <boegel|home> you mean line 23 ? :)
02:19:14 <kala> yes
02:21:51 <kala> when I comment out the line 21 and 22, text compiles
02:22:19 <kolmodin> kala: move line 22 to after line 25
02:22:41 <kala> aha, I'm in the do loop?
02:23:18 <kolmodin> kala: you cannot say 'where' and then continue with statements
02:23:42 <kala> ok. is there a way to write this line 21 without using where construction?
02:23:53 <kolmodin> kala: or change the 'where' to a 'let' expression
02:24:24 <kolmodin> kala: let parse str = ... instead of line 22, put it before line line 21
02:24:37 <kala> ok
02:26:38 <kolmodin> kala: also, if the program isn't given any arguments it's going to crash on the (head args) part
02:26:56 <kala> no, I test the null args part?
02:27:15 <kolmodin> kala: yes, but the execution continues after the 'if'-expression
02:27:28 <kolmodin> @type System.Exit.exitFailure
02:27:29 <lambdabot> forall a. IO a
02:27:51 <kolmodin> you might want to use that function to exit your program at that point
02:28:45 <kala> ok, thanks. but I'm having troublems with this "map (map putStrLn (parse)) input" line as well. every expression in do loop must return IO (), right?
02:28:55 <kolmodin> 'return ()' doesn't exit the function as in a language like C or Java
02:29:29 <kolmodin> @type Control.Monad.mapM
02:29:30 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
02:29:47 <kolmodin> use that if you want to map over a monadic function
02:34:16 <kolmodin> kala: http://pastebin.com/410800
02:35:35 <xerox> @index nub
02:35:36 <lambdabot> Data.List
02:35:39 <xerox> @docs Data.List
02:35:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
02:35:41 <kala> kolmodin: oh thanks, thats something I was after
02:36:27 <xah> lambdabot: 404 not found
02:36:30 <kolmodin> kala: look at the types of the functions and arguments and you'll se it has to be that way
02:37:08 <xah> also just made a circular logo: http://xahlee.org/haskell/haskell-logo.html
02:37:23 <kala> kolmodin: I forgot the input is String, not [String]
02:37:24 <kolmodin> it should be Data-List.html, not Data.List.html
02:37:31 <xerox> xah: ah right, exchange the Data.List with Data-List.
02:37:45 <xerox> Let's patch it.
02:38:35 <xerox> @docs
02:38:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
02:38:48 <jak> Is MonadWriter as efficient, complexity-wise, as using shows ?
02:40:30 <ndm> shapr, ping
02:41:57 <jak> Where can I find the source to the base haskell libraries in GHC online?
02:42:20 <kolmodin> jak: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/mtl/Control/Monad/Writer.hs?rev=1.2;content-type=text%2Fplain
02:42:33 <jak> kolmodin, thanks
02:43:20 <kolmodin> jak: np
02:43:44 <kolmodin> jak: I was asking that myself the other day :)
02:45:52 <Lemmih> @libsrc Control.Monad.Writer
02:45:53 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/Writer.hs
02:46:43 <jak> Lemmih, thanks
02:47:05 <jak> What do you think the behaviour of (>>=) for MonadWriter is
02:47:46 <jak> m >>= k calls runWriter on m and then runWriter on (k a) and then appens the two results
02:48:55 <kolmodin> ah, I woundered what the complexity of the  w `mappend` w' part was
02:49:14 <kolmodin> adding to the end of a list all the time
02:49:50 <Philippa> a reverseWriter might be useful on occasion
02:50:08 <Philippa> OTOH, that becomes strict
02:50:28 <jak> or maybe instead of using a list type, use a type like ShowS
02:50:53 <Philippa> what does ShowS do that's special?
02:51:58 <kolmodin> jak: yeah, I though that might be an idea
02:52:11 <jak> type ShowS = String -> String
02:52:31 <kolmodin> Philippa: it takes the end of a string as an argument
02:52:42 <jak> instead of using ++ to append strings, you work with ShowS and use function composition instead (.)
02:53:32 <kolmodin> Philippa: so it becomes (s++(s'++(s''))) instead of potentially ((s++s')++s'')
02:53:39 <kolmodin> brb
02:55:03 <jak> @libsrc GHC.Show
02:55:03 <lambdabot> GHC.Show not available
02:58:25 <shapr> ndm: pong
02:58:45 <ndm> shapr, do you have any experience of cgi and configuring haskell.org?
02:58:55 <Metaltude> nope
02:58:55 <shapr> cgi yes, haskell.org, no
02:59:03 <ndm> i'm trying to set it up so hoogle works properly, and i'm out of my depth on the cgi side
02:59:08 <shapr> hoi Metaltude, hoe gaat het met jou?
02:59:18 <Metaltude> ok
02:59:34 <ndm> i'm trying to configure the cgi so haskell.org/hoogle runs my cgi script
02:59:35 <Metaltude> eerste chat ever
02:59:36 <ndm> which it now does
02:59:37 <shapr> Metaltude: Are you a student at uu.nl or so?
02:59:39 <Metaltude> behalve mn dan:P
02:59:54 <Metaltude> neej:P
02:59:58 <ndm> but unfortunately haskell.org/hoogle/any_random_file.txt also invokes my cgi script
03:00:06 <shapr> Metaltude: Just learning Haskell for fun?
03:00:43 <autrijus> rehi
03:00:47 <shapr> ndm: Most people set a particular file suffix for cgi scripts, and then would use hoogle.cgi or so
03:00:51 <shapr> hiya autrijus
03:01:01 <ndm> shapr, yeah - thats what i tried
03:01:46 <roconnor> Think the HaskellUserLocations ought to use an area-preserving projection?
03:02:04 <shapr> roconnor: I think it should use frappr.com
03:02:34 <roconnor> that doesn't look area preserving.
03:02:47 <roconnor> other than that it does seem nicer.
03:03:51 <shapr> just for kicks - http://www.frappr.com/haskellers
03:04:09 <shapr> The downside of using frappr is that we're limited to whatever they enable.
03:04:21 <shapr> We could do so much more with our own OSS framework on top of Google maps.
03:04:52 <shapr> ndm: at first glance, the httpd.conf looks right.
03:05:17 <roconnor> Google maps allows you to make your own programs out of them.
03:05:21 <integral> eww, they mark Glasgow on the map at the default scale, but not Edinburgh :-(
03:05:32 <ndm> shapr, go to http://haskell.org/hoogle/random.txt and it also gives you the index.cgi
03:05:44 <ndm> more worryingly, it returns the html front page for my images and css as well
03:05:53 <roconnor> I'd still prefer area-preserving.
03:05:55 <shapr> ndm: Oh wait, don't you want scriptalias /hoogle to .../hoogle.cgi ?
03:06:11 <ndm> maybe?
03:06:14 <roconnor> this isn't a navagational map. ... although maybe google maps is.
03:06:20 <shapr> ndm: Yes, I think that's it. Are you editing, or shall I try it?
03:06:32 <ndm> probably best if you do
03:06:41 <ndm> i'm not editing it
03:06:56 <shapr> ok, I'll try it.
03:09:50 <shapr> ndm: Actually, you can probably use this 'bug' as a feature the same way MoinMoin does. Then you could url decode hoogle/[a] -> [a] to the correct search.
03:10:19 <ndm> and write my own file lookup code for all requests?
03:10:27 <shapr> hm?
03:10:40 <ndm> so hoogle/help.htm actually returns the help page
03:10:46 <ndm> i'd have to do readFile writeFile
03:10:53 <shapr> Oh, I see what you mean.
03:10:55 <ndm> yeah, thats a good idea
03:10:57 <shapr> Just a moment...
03:11:29 <shapr> MoinMoin has two aliases. The other one is "Alias /moinwiki/ /usr/share/moin/htdocs/"
03:11:30 <Philippa> the main reason I'm not doing that with Flippi is I'm not sure it makes sense to have a "special page" for all possible requests
03:11:42 <Philippa> (much as it does for viewing and editing, it doesn't really for scripts)
03:11:44 <shapr> That's where it keeps all of its 'static' info.
03:12:04 <ndm> i can do that, if its easier
03:12:25 <vegai> I was hoping to find some lovercraft jokes from antarctis, could not ;/
03:12:47 <shapr> btw, John Hughes gave me an excellent reason to not fork QuickCheck.
03:12:51 <vegai> Antractic.
03:13:01 <Philippa> vegai: they kept talking about hast... er, that'd be a bad idea, wouldn't it?
03:13:01 <xerox> shapr: that is?
03:13:05 <Philippa> er, *d'oh*!
03:13:38 <shapr> xerox: Well, you'll all know in a few weeks/months.
03:13:45 <liyang> (lovercraft? o.O)
03:13:50 <xerox> shapr: <blink>
03:13:56 <vegai> liyang: typo
03:14:12 <liyang> heh
03:14:13 <Philippa> shapr: something funky coming up, then?
03:14:14 <vegai> ...or was it
03:14:16 <liyang> Mornign!
03:14:17 * vegai smirks.
03:14:41 <shapr> Philippa: Something nifty, hopefully.
03:17:05 <shapr> This looks way cool - http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=10218 - build a computer from the transistor on up.
03:19:47 <Philippa> could well be fun, though it's a bit expensive for me to grab as a toy when it's only a could
03:20:00 <Philippa> (don't ask me about the virtual instruments I want right now)
03:21:43 <Lemmih> Has anyone performed intersection on hlist-style types before?
03:21:59 <shapr> ndm: I'm done editing, go for it :-)
03:22:29 <ndm> shapr, still seems to give the same behaviour?
03:25:26 <Maddas> @yow
03:25:27 <lambdabot> All right, you degenerates!  I want this place evacuated in 20 seconds!
03:25:50 <Maddas> Good day :-)
03:28:19 <shapr> ndm: Yes, my suggestion was to treat it as a feature :-)
03:28:38 <ndm> shapr, ok - will code it up as such tomorrow
03:28:47 <ndm> thanks for the suggestion!
03:41:11 <shapr> hola labra, how's code?
03:41:19 <arcus> hello people, anyone awake?
03:41:41 <arcus> oh, I see there is.
03:42:17 <shapr> g'day arcus
03:42:24 <arcus> can someone help me? I'm just going through a haskell tutorial, and I'm having a bit of difficulty with this I/O stuff.
03:42:37 <shapr> Which tutorial? Have you discovered monads yet?
03:43:09 <arcus> I sort of very vaguely know what a monad is, in fact that was a major motivation for starting to learn haskell yesterday :]
03:43:37 <Maddas> Hey there, arcus :-)
03:43:42 <shapr> This is the best monads tutorial I know - http://www.nomaware.com/monads/
03:43:59 <Oejet> arcus: Welcome.
03:44:06 <arcus> it's 'Yet another Haskell Tutorial'
03:44:11 <arcus> hi, Maddas.
03:44:48 <arcus> do you mind if I paste a short (five line) function?
03:44:56 <shapr> @paste
03:44:57 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:45:06 <shapr> If it's over three lines, it's better to put it onto the paste page.
03:45:17 <shapr> And, because of wiki spam, you'll need to create a user account on the wiki
03:45:17 <arcus> actually, it's four.
03:45:20 <shapr> @wiki UserPreferences
03:45:21 <lambdabot> http://www.haskell.org/hawiki/UserPreferences
03:45:36 <shapr> On the good side, then you get to add your name to the HaskellUserLocations :-)
03:46:05 <arcus> I think I'll risk the wrath of the channel for pasting four lines...
03:46:07 <arcus> putFactorials (number : numbers) = do
03:46:07 <arcus>  let fact = factorial number
03:46:07 <arcus>  putStr ("factorial " ++ number ++ " is " ++ fact)
03:46:07 <arcus>  putFactorials numbers
03:46:41 <arcus> now, I get a type error - with putFactorials numbers.
03:46:43 <Maddas> Is number a string?
03:46:51 <shapr> Well, I'm the wrath most of the time.
03:47:21 <arcus> the error is Type [b] does not match IO a
03:47:35 <arcus> oh, I suppose maybe it's still a string... let me see.
03:47:37 <shapr> @type putStr
03:47:38 <lambdabot> String -> IO ()
03:47:56 <Maddas> (And fact, for that matter -- I doubt factorial returns a string)
03:48:01 <shapr> That's the type ofthe putStr line, what's the type of the next line?
03:48:29 <arcus> Maddas: oh, it's my factorial... I suppose I should have checked there wasn't one already defined, but no matter.
03:49:07 <arcus> hmm, I think 'number' should be a number.
03:49:21 <Maddas> I think what shapr is referring to might be the problem you mentioned
03:49:37 <Maddas> @type ++
03:49:38 <lambdabot> parse error on input `++'
03:49:42 <Maddas> @type (++)
03:49:43 <lambdabot> forall a. [a] -> [a] -> [a]
03:50:24 <arcus> oh, I need to turn 'number' into a string there.
03:50:37 <arcus> hmm...
03:51:02 <shapr> What about making a function that returns factorial of N, and then printing that result?
03:51:20 <shapr> That'll be cleaner, and easier to make your types match.
03:51:37 <shapr> And you'll be able to use it in GHCi with no trouble.
03:52:17 <arcus> I did think of that, but the problem excercise wanted me to write them out as "factorial 3 is 6" etc.
03:52:37 <arcus> I suppose I could just take two lists...
03:53:44 <resiak> Could you not map (\x -> (x, fact x)) across [1..n], then map a stringification function across them, then concat and print the result?
03:53:54 <resiak> (or am I missing something here?)
03:54:24 <arcus> no, you're not missing something.
03:57:59 <JohnMeacham> girly girl.
03:58:08 <JohnMeacham> where? oh. crap. must go now.
03:59:01 <JohnMeacham> haloweeeen party. good times.
03:59:35 <arcus> well, I'll do it like that, then.
03:59:55 <shapr> JohnMeacham: Better to get off of IRC and enjoy those good times :-)
04:00:29 <paolino> mofning
04:00:42 <arcus> I thought there was something subtle that I was not getting about I/O, but it seems it's just a type error...
04:00:54 <paolino> how do I import Data.Map hiding (!) ?
04:01:39 <shapr> arcus: Those can be subtle.
04:02:53 <arcus> oh, my other question is, the tutorial says you can't do this:
04:03:08 <arcus> 'else return (word : askForWords)'
04:03:19 <arcus> where askForWords is a recursive call.
04:03:33 <arcus> but you have to do:
04:03:42 <arcus> else do
04:03:42 <arcus>   rest <- askForWords
04:03:42 <arcus>   return (word : rest)
04:03:47 <arcus> why is that?
04:04:12 <arcus> because I can do something like the first when I'm defining factorial...
04:05:19 * shapr doesn't understand the question
04:05:38 <Maddas> arcus: Check the type of askForWords
04:05:40 <paolino> importing Data.Map creates some problems om 'map' 'filter' occurrencies
04:06:07 <arcus> Maddas: oh, I see.
04:06:36 <arcus> I guess it's IO -> [a]
04:06:39 <arcus> or something like that.
04:06:42 <Maddas> Er...
04:06:56 <Maddas> arcus: Do you mean IO [a]?
04:07:07 <arcus> maybe :]
04:07:12 <Maddas> :-)
04:07:37 * Maddas also recommends the nomaware tutorial, by the way
04:09:25 <Lemmih> paolino: import Data.Map hiding ((!))
04:09:42 <paolino> :)
04:09:46 <arcus> askForWords :: IO [[Char]]
04:09:51 <arcus> what does that actually mean?
04:09:59 <shapr> @wiki HaskellDemo
04:10:00 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
04:10:10 <shapr> arcus: Do you know what [] means?
04:10:15 <paolino> I have another problem this is my type : type Grams2Set = Data.Map.Map String Int
04:10:23 <arcus> shapr: a list of something?
04:10:31 <shapr> arcus: yes, so what does [[]] mean?
04:10:38 <paolino> can I use it to as an instance to a class ?
04:10:40 <arcus> shapr: a list of a list.
04:10:50 <shapr> arcus: So what does [[Char]] mean? :-)
04:10:52 <arcus> well, a list of the empty list, I guess.
04:11:03 <arcus> shapr: I'm more wondering what the IO means.
04:11:14 <Lemmih> paolino: You can do that with a newtype.
04:11:14 <shapr> arcus: Parameterized types are mentioned on the HaskellDemo.
04:11:16 <paolino> instance Groupable Grams2Set where   is illegal after :/
04:11:16 <arcus> shapr: it's a list of a list of characters...
04:11:29 <Lemmih> (or with the right amount of ghc flags)
04:11:31 <arcus> shapr: what is the HaskellDemo?
04:11:32 <shapr> arcus: You are correct. In Haskell, String is the same as [Char]
04:11:38 <shapr> @wiki HaskellDemo
04:11:39 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
04:12:21 <paolino> Lemmih, newtype Grams2Set = Data.Map.Map String Int ?
04:12:48 <Lemmih> paolino: newtype GramsToSet = GramsToSet (Map String Int)
04:13:31 <arcus> shapr: ta.
04:13:39 <paolino> looks like a data definition
04:13:49 <Lemmih> paolino: Indeed.
04:15:20 <paolino> ok, now I have a bunch of :   Couldn't match `Map k a' against `Grams2Set'
04:16:35 <paolino> ok, now I have a bunch of :   Couldn't match `Map k a' against `Grams2Set'
04:16:36 <Lemmih> You have to wrap/unwrap it like you would with a data declaration.
04:16:38 <paolino> ops
04:18:54 <paolino> Lemmih mmhh can I have an example
04:19:05 <paolino>   distance one other = sum [ one!k - other!k | k <- concatMap keys [one,other]]
04:19:11 <paolino>  
04:19:29 <Lemmih> distance (GramsToSet ond) (GramsToSet other) = ...
04:21:36 <paolino> mean items ?
04:21:59 <paolino> [GramToSet] ?!?
04:23:18 <arcus> shapr: I've read over the demo. My guess is that IO [[Char]] means a function that returns a list of strings from some IO operations?
04:24:54 <paolino> Lemmih can I use funcion typing fo it ?
04:25:45 <Lemmih> Function typing?
04:26:34 <paolino> mean :: [Grams2Set]->Grams2Set
04:26:45 <paolino> which gives me another error
04:27:47 <Lemmih> Did you call it 'Grams2Set' or 'GramsToSet'?
04:28:03 <paolino> Grams2Set
04:28:09 <paolino> Grams3Set
04:28:13 <paolino> GramsNSet
04:28:16 <Lemmih> Ah.
04:29:15 <paolino> class Eq a => Groupable a where
04:29:17 <paolino>   mean :: [a]->a
04:29:17 <paolino>   distance :: a->a->Float
04:29:23 <Lemmih> 'newtype Grams2Set = Grams2Set {unwrapGrams2 :: Map String Int}' will put a function of type 'Grams2Set -> Map String Int' in scope.
04:30:38 <arcus> well, I'm to bed. no doubt this IO stuff will become clear to me eventually.
04:30:43 <arcus> thanks for your help.
04:31:53 <paolino> Lemmih, let items' = map unwrapGrams2 items ?
04:33:06 <shapr> Aww, I missed answering.
04:36:50 <_astrolabe> Is there a neater way to define   vplus (x1,y1) (x2,y2) = (x1+x2,y1+y2)   ?
04:37:49 <shapr> _astrolabe: Um, I think you could use one of the arrow ops.
04:38:11 <shapr> _astrolabe: btw, why not use the astrolabe nick? Is it registered by someone else?
04:38:18 <_astrolabe> oh dear
04:38:39 <paolino> Lemmih what I wrote doesn't resolve
04:39:31 <shapr> @type (Control.Arrow.***)
04:39:33 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
04:39:33 <lambdabot> (Control.Arrow.Arrow a) =>
04:39:33 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
04:39:42 <shapr> Maybe that one?
04:39:44 <_astrolabe> sometimes my machine falls off irc for some reason, and can't log back on because irc thinks I'm still there.  I altered my name when that happened.
04:41:01 <EdLin> _astrolabe: /msg NickServ ghost nick password
04:41:03 <_astrolabe> is that *->*->* some 'kind' thing?
04:42:04 <autrijus> yes.
04:43:02 <_astrolabe> EdLin: thanks, but I don't understand, and I'm not that fussed really.
04:43:25 <EdLin> _astrolabe: /msg NickServ help
04:44:38 <_astrolabe> oh, I see, thanks
04:45:16 <EdLin> np
04:45:24 <_astrolabe> 'Kill another user who has taken you nick'  I suppose sometimes extreme measures  are called for :)
04:46:40 <EdLin> _astrolabe: well, if you don't register your nick someone else might. It happened to me and I had to change my nick, since then I always register my nick.
04:47:41 <_astrolabe> hmm that would annoy me
04:48:10 <EdLin> _astrolabe: yep
04:48:39 <paolino> @hoogle Int->Float
04:48:40 <lambdabot> An error occured.
04:49:33 <paolino> how do I convert ?
04:50:05 <autrijus> @plugs fromInteger 1 :: Float
04:50:07 <lambdabot> 1.0
04:50:07 <paolino> from Int to float ?
04:50:13 <autrijus> fromInteger for one
04:50:18 <autrijus> oh, Int
04:50:25 <paolino> yep
04:50:27 <autrijus> fromIntegral then
04:50:36 <autrijus> @type fromIntegral
04:50:36 <lambdabot> forall b a. (Num b, Integral a) => a -> b
04:50:42 <paolino> :)
04:50:48 <autrijus> hth :)
04:51:59 <paolino> it does .Lemmih I can't get out of my hole
04:52:37 <paolino> newtype Grams2Set = Grams2Set {unwrap :: Map String Int} deriving Eq
04:52:47 <paolino> is it right ?
04:55:29 <paolino>   mean items' = fromList [(k,(sum $ map (!>k) items) / length items) |k <- concatMap keys items] where
04:55:30 <paolino>     items = map unwrap items'
04:56:11 <paolino> Lemmih ,I suppose this is not what you intended :/
04:56:38 <kala> is there a simple way of getting all the lines from the file as [String] or should I first get the contents of the file as String with hGetContents and then break up the String to [String] ?
04:59:43 <astrolabe> @type getLine
04:59:45 <lambdabot> IO String
05:00:09 <astrolabe> @type hGetLine
05:00:11 <lambdabot> Not in scope: `hGetLine'
05:00:42 <astrolabe> @type IO.hGetLine
05:00:44 <lambdabot> GHC.IOBase.Handle -> IO String
05:01:14 <kala> astrolabe: I could do [x | x <- hGetLine handle], but what happens at the end of line?
05:01:20 <kala> end of file, I meant
05:02:50 <astrolabe> hmmm sorry, I only do easy questions.
05:03:15 <kala> :(
05:03:46 <astrolabe> maybe your idea is better.  There is a lines function I think.
05:03:57 <kala> @type lines
05:03:58 <lambdabot> String -> [String]
05:04:03 <kala> hmm :)
05:04:25 <paolino> is there someone withs a bit of confidence with newtype ?
05:05:12 <Cale> newtype is pretty easy to use
05:05:47 <astrolabe> that sounds like confidence.
05:05:56 <Cale> hehe
05:06:37 <paolino> newtype Grams2Set = Grams2Set {unwrap :: Map String Int} deriving Eq
05:06:43 <paolino> is this ok ?
05:06:51 <Cale> yeah, should be
05:07:06 <paolino> what does it mean unwrap ?
05:07:32 <Cale> well, values of the type Grams2Set are of the form Grams2Set m where m is a map
05:07:42 <Cale> unwrap (Grams2Set m) = m
05:08:29 <paolino> instance Groupable Grams2Set where
05:08:30 <paolino>   mean (items::[Grams2Set]) = fromList [(k,(sum $ map (!>k) items) / length items) |k <- concatMap keys items]
05:08:35 <paolino> I can't fix this
05:09:31 <paolino>       Expected type: Grams2Set
05:09:32 <paolino>       Inferred type: Map k a
05:09:58 <Cale> Stick "Grams2Set $" on the front of the right hand side
05:10:25 <Cale> you've given a Map, when you want to give a Grams2Set
05:10:42 <paolino> ah it's the return value wrong?
05:10:50 <Cale> yeah, probably
05:10:59 <Cale> I don't know what the Groupable class is
05:11:09 <Cale> or what the type signature of "mean" is
05:11:20 <Cale> but that's likely the problem
05:11:25 <paolino> class Eq a => Groupable a where
05:11:30 <paolino>   mean :: [a]->a
05:11:30 <paolino>   distance :: a->a->Float
05:11:42 <Cale> yeah, that's the problem then
05:14:39 <paolino>     Couldn't match `Map k a' against `Grams2Set'
05:14:40 <paolino>       Expected type: [Map k a]
05:14:40 <paolino>       Inferred type: [Grams2Set]
05:14:40 <paolino>     In the second argument of `concatMap', namely `items'
05:14:44 <paolino> grrr
05:14:51 <Cale> ah, you need to unwrap them
05:15:36 <Cale> replace keys with (keys . unwrap)
05:15:44 <paolino> <Cale> newtype is pretty easy to use
05:15:48 <Cale> yep
05:15:51 <Cale> it is :)
05:15:54 <paolino> :)
05:16:30 <Cale> The only thing it does is to make a new type which is isomorphic to the original one.
05:16:55 <Cale> what you called unwrap here is the isomorphism which goes back to the original type
05:17:23 <Cale> and the "constructor", in this case Grams2Set, is the isomorphism which goes from the original type to the new one
05:18:04 <kala> @type hGetContents
05:18:06 <lambdabot> Not in scope: `hGetContents'
05:18:18 <kala> @type IO.hGetContents
05:18:20 <lambdabot> GHC.IOBase.Handle -> IO String
05:18:59 <kala> how do I process this 'IO String' ? it seems I cannot give it to lines.
05:20:07 <Cale> well, you got it inside a do-block right?
05:20:18 <Cale> er
05:20:21 <paolino> Cale thanks
05:20:38 <Cale> well, write a do-block which looks like
05:20:52 <Cale> do cts <- hGetContents handle
05:21:03 <Cale>   print (lines cts) -- or whatever
05:21:39 <Cale> you have to run the IO action to get the String
05:21:49 <Cale> which can only be done inside of another IO action
05:22:14 <kala> so, I cannot generally process the contents of the file as [String] anywhere in Haskell?
05:22:24 <Cale> cts :: String
05:22:54 <Cale> if you want,  fmap lines (hGetContents hdl) :: IO [String]
05:23:12 <astrolabe> kala: write a pure function that does your processing and takes [String] as input, and call it from a do-block.
05:23:49 <kala> astrolabe: hmm ...
05:24:17 <Cale> if you haven't yet read a tutorial on monads, this is where they come in :)
05:24:21 <kala> astrolabe: this is what I had. I was trying to make my code look more abstract
05:24:34 <kala> or more ... "nicer" ...
05:24:56 <kala> Cale: it seems that everytime I have a problem you refer to Monads :)
05:25:08 <Cale> heh
05:25:24 <astrolabe> It sounds as though you know as much as me.  I should stop giving advice, but to my mind that is the 'nice' way to do it.
05:26:01 <kala> astrolabe: this do-block seems to me as a conventional instructions based programming. And I would like to avoid it
05:26:19 <paolino> (fromIntegral.sum $  map (!>k) items) / (fromIntegral.length)  items) -- why this does not pass type inference ?
05:27:00 <Cale> (!>k)?
05:27:17 <astrolabe> kala: I agree you should try to minimise it, but if your program has input and output, then it seems correct (and necessary?) to use imperitive code.
05:27:20 <paolino> (!>) :: Grams2Set -> String -> Int
05:27:21 <paolino> (!>) (Grams2Set grams) key  = findWithDefault 0  key grams
05:27:47 <kala> astrolabe: yes, I suppose ...
05:32:06 <Cale> um, it does
05:33:06 <paolino> Cale ?
05:33:10 <Cale> *Main> :t (fromIntegral . sum $  Prelude.map (!> k) items) / (fromIntegral . length) items
05:33:10 <Cale> (fromIntegral . sum $  Prelude.map (!> k) items) / (fromIntegral . length) items :: (Fractional b) =>
05:33:10 <Cale>  b
05:33:22 <Cale> *Main> :t k
05:33:23 <Cale> k :: [Char]
05:33:36 <Cale> *Main> :t items
05:33:36 <Cale> items :: [Grams2Set]
05:34:32 <paolino>     No instance for (Fractional Int)
05:34:37 <paolino>       arising from use of `/' at Groupable.hs:76:78
05:34:37 <paolino>     Probable fix: add an instance declaration for (Fractional Int)
05:34:42 <Cale> well, yeah
05:34:54 <Cale> you can't interpret that as an Int, because you're dividing
05:35:04 <Cale> if you want integer division, use `div`
05:41:14 <paolino> Ah yes the problem is Map String Int ,I see
05:41:15 <paolino> Haskell doesn't pardon
05:43:01 <paolino> Cale ,with newtype I can override !
05:43:06 <paolino> (!)
05:43:34 <Cale> hm?
05:43:55 <Cale> You can define your own (!) if you import Map qualified
05:44:09 <paolino> (!) :: Grams2Set -> String -> Float
05:44:10 <paolino> (!) (Grams2Set grams) key  = findWithDefault 0  key grams
05:44:52 <Cale> yeah, so long as (!) isn't already in scope
05:45:14 <Cale> you might just want to import Data.Map hiding ((!))
05:48:02 <paolino> yep
05:49:05 <paolino> Cale one more question.What if I want to open the type to support GramsNSet Int
05:50:02 <Cale> um, I'm not really sure what your type name even means :)
05:52:56 <paolino> I want to make it parametric
05:53:18 <paolino> Grams2Set = GramsNSet 2
05:53:40 <Cale> newtype Grams2Set a = Grams2Set {unwrap :: Map String a} deriving Eq ?
05:54:08 <Cale> er, I don't know what the 2 is supposed to represent
05:54:27 <Cale> you have an arbitrary-size map from String to Int
05:54:34 <Cale> where's the 2? :)
05:55:14 <Cale> what would Grams3Set look like?
05:55:38 <paolino> it's the lenght of the strings
05:55:48 <paolino> but probably it's a parameter of the constructors ?
05:56:01 <Cale> oh
05:56:02 <paolino> builder functions I mean
05:56:10 <Cale> yeah
05:56:20 <Cale> as it is, you can't control that from the type
05:56:25 <paolino> damnd OO
05:56:34 <Cale> you could embed the naturals in the type system
05:56:52 <Cale> and then use types to indicate somehow the lengths of the strings
05:56:58 <Cale> but it would be unwieldy
05:58:23 <paolino> I have an instance of lambdadot on #haskell.it, how do I do a @let a=4 ?
05:58:32 <Cale> you don't
05:58:46 <paolino> it can't store values ?
05:58:49 <Cale> right
05:59:32 <Cale> let a = 4 in ...
06:00:30 <Cale> The only thing @eval does is to run a program called runplugs, and pass it your expression, then collect the result.
06:00:53 <Cale> nothing is stored in between
06:02:02 <paolino> I see
06:03:09 <Cale> I kind of like it that way -- huge amounts of annoying user state would get built up otherwise
06:03:45 <integral> oleg did a tmr article on embedding numbers in the type system
06:04:07 <Cale> yeah, it's not so hard once you know how to do it :)
06:04:30 <Cale> the HList paper is where I first saw it really put to good use
06:04:46 * integral just uses it for modular numbers, and matrices
06:17:18 <araujo> Morning!
07:08:07 <jak> @index read
07:08:07 <lambdabot> Text.Read, Prelude
07:09:25 <jak> Why would one prefer parsec over the read operations?
07:18:00 <Wasp> @index random
07:18:01 <lambdabot> System.Random
07:30:12 * shapr boings cheerfully.
07:30:17 <shapr> Unicycling is great fun!
07:30:29 * dcoutts grees with shapr 
07:31:33 <dcoutts> jak, for more complex parsing tasks it's much better and easier to use
07:31:36 <shapr> hiya kpreid_
07:31:51 * kpreid_ lurks
07:31:54 <fnord123> so I'm looking at the IO Monad...
07:32:02 <musasabi> A good Parsec vs ReadP comparison would be nice.
07:32:11 <fnord123> and I'm wondering.. how do I print a rational or an integer?
07:32:22 <jak> How about performance-wise?
07:32:33 <xerox> @type print
07:32:34 <lambdabot> forall a. (Show a) => a -> IO ()
07:32:47 <xerox> print = putStrLn . show
07:32:53 <xerox> i.e. you can 'print' anything Show-able.
07:33:03 <shapr> musasabi: oh hey, I was thinking about PArrows vs Parsec. Wouldn't the arrow based parsing give advantages when the inputs are statically known, and be exactly like monadic parsing where the inputs are not statically known?
07:33:21 <fnord123> o ok
07:33:34 <fnord123> so i want to derive my data off show if i want to print it
07:33:35 <musasabi> s/input/grammar/ ?
07:33:47 <dcoutts> jak, parsec performance is pretty good, I think it's faster than the ReadS stuff
07:34:32 <shapr> Yeah, Daan's example of an xml parser where the tags are not known at compile time was his anti-arrow/pro-monad example. But I think it would be the same as monadic parsing, does that seem correct to you?
07:34:42 <musasabi> shapr: For PArrows I am looking at two things 1) the comonadic parser combinators (there are some issues which are not yet solved) and 2) the lack of good syntax
07:35:02 <dcoutts> shapr, I think arrow based parsing could be made afster because it has more static structure
07:35:26 <shapr> dcoutts: Yeah, but Daan said that monads can do more... and I think he's wrong. Lemme get the example.
07:35:28 <musasabi> yes, One could embed monadic parsers in an arrow parser - but not reason about their behaviour after that.
07:35:34 <dcoutts> shapr, I might get round to using it as an example for partial evaluation
07:35:39 <jak> very interesting... what about code-generating tools (I forget what the haskell parser generator is called)
07:35:45 <shapr> musasabi: Yeah, but it would be no worse than a monadic parser then, right?
07:35:47 <dcoutts> shapr, no, I think he's right that they can do more.
07:35:57 <shapr> dcoutts: how so?
07:36:15 <dcoutts> shapr, it's all to do with the data flow
07:37:05 <shapr> Here it is http://www.cs.uu.nl/~daan/download/papers/parsec-paper-letter.pdf
07:37:06 <dcoutts> shapr, the monadic parser can adapt itself depending on the input. The arrow one cannot. That is a tradeoff. The arrow one can be optimised precisely because it does not depend on the dynamic input.
07:37:50 <musasabi> dcoutts: but both could be embedded into eachother
07:37:50 <shapr> But... won't the arrow-style parser be effectively a monadic parser in cases of dynamic input? Would it be any worse?
07:37:53 <dcoutts> shapr, the arrow parser combinators can be extened with monadic bits so that you can do the xml example
07:37:59 <musasabi> The arrow syntax is ugly.
07:38:04 <musasabi> That is one large problem.
07:38:25 <dcoutts> Doaitse's original parsers did not use the arrow syntax and were quite readable.
07:39:00 <dcoutts> they had a nice "f <$> x" application style syntax
07:39:33 <musasabi> dcoutts: mixing computation into the parser tends to make such parsers ugly (but it might be that I was simply lacking the right combinators)
07:40:13 <bosie> if i have a rather stupid question i guess, but somehow i am not able to understand why/how it works:
07:40:14 <bosie> g :: (Int -> Int -> Int ) -> Int
07:40:14 <bosie> g h = h 6 3
07:40:14 <bosie> testing:
07:40:14 <bosie> Main> g (*)
07:40:16 <bosie> 18
07:41:03 <bosie> could someone pls tell me why it is possible to have 4 int in the declaration but using only 3 of them and passing (*) works ?
07:41:29 <Igloo> I think you are misunderstanding the type signature
07:41:33 <dcoutts> @type (*)
07:41:35 <lambdabot> forall a. (Num a) => a -> a -> a
07:41:35 <Igloo> (*) has type Int -> Int -> Int
07:41:50 <Igloo> i.e. you give it an Int, then another Int, and then it has type Int
07:41:56 <bosie> oh
07:41:57 <Igloo> (*) 5 has type Int -> Int
07:42:04 <Igloo> (*) 5 6 has type Int
07:42:07 <dcoutts> bosie, so your function only takes one argument which must have the type (Int -> Int -> Int)
07:42:09 <MenTaLguY> yay for currying
07:42:19 <Igloo> Int -> Int -> Int == Int -> (Int -> Int)
07:42:40 <dcoutts> Int -> Int -> Int /= (Int -> Int) -> Int
07:42:41 <bosie> thank you
07:44:01 <bosie> hmm so if i dont have 6 3 written "hardcoded" in the source i would have to pass them to g?
07:44:19 <MenTaLguY> in this paticular case, no
07:44:32 <MenTaLguY> well, yes,
07:44:35 <MenTaLguY> never mind
07:44:39 <MenTaLguY> brain fart
07:44:39 <bosie> kk
07:44:51 <jak> @libsrc liftM
07:44:52 <lambdabot> liftM not available
07:44:57 <jak> @libsrc fmap
07:44:57 <lambdabot> fmap not available
07:45:04 <jak> liftM == fmap ?
07:45:21 <jak> @index liftM
07:45:22 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
07:45:22 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
07:45:22 <lambdabot> Control.Monad.Error, Control.Monad.List
07:45:33 <jak> @index fmap
07:45:33 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
07:45:33 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
07:45:33 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
07:45:49 <jak> @libsrc Prelude
07:45:49 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
07:47:27 <jak> Where is fmap defined?
07:47:31 <xerox> @index fmap
07:47:32 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
07:47:32 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
07:47:32 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
07:47:53 <xerox> jak: it depends for what type do you want to see the Functor instance :)
07:48:14 <jak> xerox, any and all types please :)
07:48:21 <jak> at least Monad and maybe List
07:48:27 <bosie> MenTaLguY thanks tried it works now ;)
07:48:28 <xerox> jak: pop up GHCi, and do :info Functor
07:48:46 <MenTaLguY> Monad isn't a type
07:49:14 <jak> MenTaLguY, you're right
07:49:30 <jak> I suppose what I'd like to see is the default implementation of liftM and fmap
07:49:32 <jak> if there is one
07:49:54 <jak> How to get at GHC.Base source ?
07:50:02 <xerox> jak: the fact that they are polymorphic what does suggest?
07:50:22 <jak> Got GHC.Base source
07:50:38 <MenTaLguY> as far as I know there is no default implementation
07:51:30 <MenTaLguY> in principle liftM could normally be implemented in terms of fmap, but the Monad type class doesn't imply Functor for some dumb reason
07:51:34 <MenTaLguY> (it should, technically)
07:51:59 <jak> strange
07:52:38 <MenTaLguY> if Monad implied functor, bind could technically have a default implementation of:
07:52:38 <MenTaLguY> (>>=) = join . fmap
07:53:08 <MenTaLguY> er... join . flip fmap actually, I think...
07:53:28 <xerox> @pl join . flip fmap
07:53:29 <lambdabot> join . flip fmap
07:53:31 <xerox> @pl join . fmap
07:53:31 <lambdabot> join . fmap
07:53:34 <xerox> :)
07:55:54 <jak> How do I delit a .lhs file?
07:55:58 <jak> .lhs -> .hs ?
07:57:01 <jak> ghc -E
07:58:31 <jak> I get it, liftM is an ordinary function at the top level which requires a Monad instance to work on
07:58:39 <jak> whereas fmap is a method of a class
07:58:48 <MenTaLguY> no, not at all
07:59:00 <MenTaLguY> for one thing, don't start thinking about "methods" in classes
07:59:05 <xerox> jak: they are both polymorphic functions.
07:59:07 <MenTaLguY> type classes aren't classes in the sense of OO
07:59:13 <jak> well you know what I mean, fmap is a member of class Functor
07:59:20 <xerox> jak: they accept a class of types as inputs.
07:59:21 <jak> type-class Functor
07:59:35 <xerox> jak: for each type in the class you need to provide an implementation of the function (instance)
07:59:58 <jak> yes, that's true for fmap
08:00:13 <jak> but not for liftM, which makes use of functions that work with Monads
08:00:24 <jak> i.e. liftM has a definition, whereas fmap is dynamically dispatched
08:00:33 <xerox> Nope.
08:00:36 <MenTaLguY> that's not true at all
08:00:52 <MenTaLguY> you're letting your experience with "classes" in OO languages cloud your thinking
08:00:55 <xerox> They both have a definition for each type instantiated in the type class.
08:00:55 <jak> http://darcs.complete.org/fptools/libraries/base/Control/Monad.hs
08:01:18 <jak> liftM f m1              = do { x1 <- m1; return (f x1) }
08:01:23 <MenTaLguY> type classes /= OO classes
08:01:40 <xerox> Heh
08:01:53 <jak> I agree, however, there is a similarity in the way they are implemented
08:02:02 <xerox> jak: ok, it has a general definition, because what is a Monad implements return and bind.
08:02:02 <MenTaLguY> not really
08:02:19 <MenTaLguY> the polymorphism introduced by type classes is compile-time, based on static type
08:02:23 <jak> in the sense that type-class functions involve a dictionary lookup
08:02:45 <jak> or should do should the static type not be completely known
08:02:56 <MenTaLguY> the static type is always completely known in Haskell
08:03:20 <MenTaLguY> (which can be both liberating and constraining)
08:04:58 <jak> what would be interesting is to see if you can use liftM wherever you could use fmap
08:05:59 <MenTaLguY> since Functor does not imply Monad, you can't
08:07:48 <MenTaLguY> If Monad implied Functor, you could probably (I haven't proved it) subtitute fmap for liftM safely, but since it doesn't you can't do that either.
08:08:07 <jak> so really fmap is more general than liftM
08:08:28 <MenTaLguY> that would be true if Monad implied Functor
08:08:33 <jak> hahahah
08:08:37 <MenTaLguY> as it is they're basically orthogonal
08:31:08 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051011"]'
08:31:08 --- topic: set by CosmicRay on [Tue Oct 11 09:43:45 2005]
08:31:08 --- names: list (clog cinema pdzq_ gour samx lisppaste2 kpreid_ ikor EdLin shapr fnord123 bosie MenTaLguY rasfar praseodym perspectival Robish chs_ Itkovian fanopnaic meren roconnor Bobl davve xinming arjanb astrolabe marcot phb Nomius_ paolino Wasp takuan Trixsey|Laptop cptchaos mauke masm ndm isomer_ iblechbot revision17_ jak turok basti_ xerox jyp Oejet pesco lambdabot svens autrijus khaladan moomlyn Lemmih fatbrain stepcut TheHunter albertelegance)
08:31:08 --- names: list (araujo Nioate JKnecht norpan_ ski binary42 Peach06 soysauce SamB tic cbus stef_ magagr vincenz psi cjs metaperl shammah ex_nor johs work_metaperl tromp dons tismith eivuokko JaffaCake vegai kaol mattam moonlite tessier dhpeterson chucky wli ricebowl thebug asmodai tic|school nibro lispy djw KrispyKringle keverets neologism jiing scw yaarg Matt-W Philippa Khisanth Baughn dcoutts kzm triple_ Seb earthy wolverian Spark eno-away sylvan markg)
08:31:08 --- names: list (boegel sowhat C-Keen cmeme enantiomer ozone venk gdsx skylan Nico- resiak arguile syrus edwinb Tac AtnNn flux__ goodchilde benja kala benmos liyang kelan emu ulfdoz arcatan mornfall kosmikus tumm cods CLxyz multi_io integral rep ksandstr seafood ibid musasabi borism noj Lor JohnMeacham ValarQ pitecus dav jlouis tuomov frederik2 stefanw thedward cjs__ Maddas bacam Igloo aleator dcoutts_ yosemite Lunar^ gaal Cale sieni kolmodin jgrimes sethk)
08:31:08 --- names: list (trez wchogg cathper drbean cooz cjb jp-autark gzl pejo kpk)
08:31:13 <xerox> Your editor of choice could simply put spaces instead of tabs, but still let you use the TAB key.
08:31:25 <xerox> I.e. Emacs does it, if properly configured.
08:31:33 <MenTaLguY> that can be done in vim as well
08:31:39 <xerox> I hope so :-)
08:31:49 * MenTaLguY is a vim user
08:32:07 <xerox> (setq-default indent-tabs-mode nil)
08:33:01 <resiak> Yes, vim does that too, if I configure it to do so.
08:38:40 <bosie> another question:
08:38:40 <bosie> inToArray :: Int -> [Int].....
08:38:40 <bosie> | otherwise =  intToArray(div f 10) ++ intToArray(mod f 10)
08:38:40 <bosie> in haskell, does it get executed the same way it would likei n java?
08:45:12 <kala> if I have a type Estimation = (LowerLimit,HigherLimit, Probability), how do I access the parts of this data type in a function ?
08:45:34 <MenTaLguY> pattern matching
08:45:41 <kala> aa, ok
08:45:56 <MenTaLguY> you may want to define helper functions which pull out individual components, for some uses, too
08:47:13 <kala> in general, if I have a complex data type (many Estimations for example), and I would like to print them, I need to define instance of Show class+
08:47:14 <kala> ?
08:50:35 <shapr> lispy: Hey, are you tracking the icculus Q3 with your q3 repo?
08:50:46 <MenTaLguY> you can probably get the compiler to automatically derive show for you
08:51:08 <MenTaLguY> for a type, though, it should already do that, if the components have show defined for them
15:30:03 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051011"]'
15:30:03 --- topic: set by CosmicRay on [Tue Oct 11 09:43:45 2005]
15:30:03 --- names: list (clog exnor skew pdzq joelr_ chris2 SamB stef_ skugg threeve ndm Raziel benmos zamez amiddelk palomer lisppaste2 marcot cmeme bojohan sorje wilx xerox xs Korollary Frederick eyck samx kpreid_ shapr bosie rasfar chs_ fanopnaic xinming arjanb Nomius Wasp takuan Trixsey|Laptop mauke masm isomer_ revision17_ turok Oejet pesco lambdabot svens autrijus khaladan moomlyn Lemmih fatbrain stepcut TheHunter albertelegance araujo JKnecht norpan_ ski)
15:30:03 --- names: list (binary42 Peach06 soysauce tic cbus magagr vincenz psi cjs metaperl shammah ex_nor johs work_metaperl tromp dons tismith eivuokko JaffaCake vegai kaol mattam moonlite tessier dhpeterson chucky wli ricebowl thebug asmodai tic|school nibro lispy djw KrispyKringle keverets neologism jiing scw yaarg Matt-W Philippa Khisanth Baughn dcoutts kzm triple_ Seb earthy wolverian Spark eno-away sylvan markg boegel sowhat C-Keen enantiomer ozone venk gdsx)
15:30:03 --- names: list (skylan Nico- resiak arguile syrus edwinb Tac AtnNn flux__ goodchilde benja kala liyang kelan emu ulfdoz arcatan mornfall kosmikus tumm cods CLxyz multi_io integral rep ksandstr seafood ibid musasabi borism noj Lor JohnMeacham ValarQ pitecus dav jlouis tuomov frederik2 stefanw thedward cjs__ Maddas bacam Igloo kpk pejo gzl jp-autark cjb cooz drbean cathper wchogg trez sethk jgrimes kolmodin sieni Cale gaal Lunar^ yosemite dcoutts_ aleator)
15:30:08 <Cale> @eval 2*2*2*2*2*2*2
15:30:10 <lambdabot> 128
15:30:12 <Cale> not 60
15:30:18 <skew> shapr: well, the stat call in 9P seems to carry something like posix permissions
15:30:28 <shapr> hm, interesting
15:30:36 <Cale> bosie: prime factorisations are unique up to ordering and multiplication by units
15:30:42 <Cale> (in the integers)
15:30:53 <bosie> Cale sure but you cant know that unless you mult it
15:31:02 <skew> Has anyone read Wadler's pretty printer paper?
15:31:09 <Cale> bosie: uh, sure
15:31:23 <bosie> Cale isnt that brutal ? thats bruteforce
15:31:26 <Cale> bosie: I just described a factorisation algorithm
15:31:32 <bosie> kk
15:31:45 <skew> I'm not sure about the rule for concatenation unions at the top of p.9
15:32:10 <Cale> you try primes up to the square root of n, and if there's nothing then n is prime
15:32:42 <Cale> and if there's a factor, you record that and divide by it, recursing
15:32:50 <bosie> i dont care if n is prime
15:33:49 <lisppaste2> joelr pasted "what am i doing wrong?" at http://paste.lisp.org/display/13060
15:34:26 <Cale> bosie: sure you do, that corresponds to the case when there is just one factor
15:34:45 <bosie> kk
15:35:07 <Cale> joelr_: I told you :)
15:35:17 <joelr_> Cale: but that's a monad
15:35:24 <Cale> look at the type of runEngine
15:35:27 <joelr_> Cale: how can I pass in a monad?
15:35:35 <Cale> a monad is a type
15:35:46 <Cale> you want a value in that monad?
15:36:03 <joelr_> Cale: yes, I want the value and I thought runEngine is supposed to give me that
15:36:06 <skew> joelr_: how many arguments does runEngine take?
15:36:17 <joelr_> at least that's how i did that before
15:36:30 <joelr_> granted, i did not base it on IO previously
15:36:32 <skew> or, how many arguments to you need to give it before it gives you something with an IO type
15:36:34 <Cale> joelr_: look at the type of runEngine carefully
15:36:51 <Cale> you have to pass it two parameters before you get something of the form (IO a)
15:37:03 <Cale> That is, the EngineResult
15:37:08 <joelr_> i just don't know how to pass it that second parameter
15:38:30 <Cale> well, you need a computation in the EngineState monad
15:38:50 <joelr_> Cale: that's great but a bit of a loop if you will
15:38:55 <Cale> why?
15:39:17 <Cale> runEngine takes a world, and an EngineState computation, and turns it into an IO computation
15:39:24 <joelr_> umm... lets see... i'm trying to analyze the state at the end of a series of computations
15:39:46 <joelr_> oh, hmm
15:40:41 <joelr_> it can't be _that_ simple
15:40:45 <joelr_> wow
15:40:57 <joelr_> this is what happens when you start at a monitor all day :(
15:41:10 <joelr_> of course i meant to pass it the computation itself
15:41:36 <Cale> :)
15:43:45 <shapr> g'day blackdog
15:44:28 <joelr_> are monads normally instances of show?
15:44:52 <joelr_> i added deriving show to World and it now says that the whole monad needs to be an instance of show
15:45:03 <Cale> no, usually not
15:45:22 <Cale> like, State monads can't be
15:45:26 <joelr_>     No instance for (Show (MaybeT (WriterT [Command] (StateT World IO)) ()))
15:45:27 <joelr_>       arising from the 'deriving' clause of a data type declaration at ./Script/
15:45:33 <Cale> right
15:45:41 <Cale> Writer monads can't be shown
15:45:45 <joelr_> all i did is add "driving Show" after World
15:45:56 <Cale> right
15:45:56 * shapr drives showily
15:45:58 <skew> Cale: writer is usually just (a,w)
15:46:04 <shapr> vroom!
15:46:09 <Cale> er, oops
15:46:10 <Cale> right
15:46:11 <joelr_> i don't want to show monads, i just want to show my world once i extract it from the monad
15:46:14 <Cale> Readers can't :)
15:46:22 <Cale> StateT World IO
15:46:26 <Cale> that's what's getting you
15:46:27 <joelr_> run script = do world <- runEngine newWorld script
15:46:28 <joelr_>                 putStrLn $ "World: " ++ show world
15:46:39 <joelr_> Cale: hmm
15:46:42 <Cale> yeah, that shouldn't be a problem in itself
15:46:43 <skew> lists, Maybe, and Either are the only ones that come with a show
15:47:02 <Cale> joelr_: what's a World?
15:47:11 <Cale> you need to add a show instance for World
15:47:11 <joelr_> thing is that if i don't add deriving show to World then it says there's no World for show
15:47:24 <Cale> what's the World type?
15:47:33 <joelr_> data World =
15:47:33 <joelr_>     World {
15:47:33 <joelr_>            debug_level :: Int, -- debug level
15:47:33 <joelr_> ...
15:47:33 <joelr_>           }
15:47:35 <joelr_>     deriving Show
15:47:39 <Cale> okay
15:47:54 <Cale> is there anything not-showable as one of the fields of a World?
15:48:01 <joelr_> Cale: hmm
15:48:01 <bosie> Cale not sure how it works actually
15:48:19 <bosie> Cale read about it in theory but nop :(
15:48:38 <lisppaste2> joelr annotated #13060 with "World" at http://paste.lisp.org/display/13060#1
15:49:03 <joelr_> Cale: why doesn't it complain about the contents of World, though?
15:49:19 <Cale> joelr_: did you add a deriving Show to EngineState or something?
15:49:51 <skew> lots of things in World look suspicious
15:50:00 <Cale> yeah, Callbacks in particular
15:50:07 <joelr_> Cale: i don't think so, let me see again
15:50:14 <joelr_> and let me paste the suspicious stuff
15:50:21 <Cale> also BIO, if that has anything to do with IO
15:50:28 <joelr_> argh
15:50:34 <joelr_> it's Callback
15:50:35 <joelr_> indeed
15:50:47 <skew> maybe you should define your own Show instance
15:50:55 <joelr_> BIO and SSL are just opaque
15:51:06 <joelr_> and callback is just a computation
15:51:09 <skew> do they have Show instances?
15:51:27 <joelr_> i think it's complaining about Callback. quite straightforward
15:51:38 <joelr_> type Callback = EngineState ()
15:51:42 <skew> deriving Show only works if every component has a Show instance
15:52:03 <skew> otherwise you can write your own -- instance Show World where show w = ...
15:52:04 <joelr_> skew: ok, i guess i'll do my own show
15:52:11 <Cale> what would you expect it to show there? :)
15:52:34 <joelr_> Cale: well... dunno, i actually don't want to print the world. i guess i should use evalState
15:52:37 <joelr_> to drop it
15:59:40 <stefanw> is 6.6 or 7.0 the next "major" or GHC?
15:59:53 <dons> 6.6
16:02:03 <Igloo> Why do you need to know?
16:03:08 <stefanw> because I wanted to write "The build system will use Cabal once GHC 6.6 is out." in the hcar entry for hscurses
16:04:01 <Igloo> Ah, OK
16:04:31 <dons> once the next major releaes of ghc occurs?
16:04:51 <dons> reminds me to write the hcar entries
16:05:16 <Igloo> 6.6 is fine there even if 7.0 is the next release
16:06:00 <stefanw> that's what I wrote, but kosmikus asked whether I mean 6.6 or 7.0. Anyway, 6.6 is more exact.
16:07:18 <sethk> Igloo, is there a bug already open on the ghci current directory problem?
16:07:29 <Igloo> no idea
16:07:57 <sethk> Igloo, ok, I'll look.  since you knew about the problem I thought you might know if there is a bug  :)
16:08:09 <Igloo> I didn't know about the problem
16:08:18 <sethk> Igloo, you told me about it
16:08:46 <Igloo> You told me the symptoms and I applied my brain  :-)
16:08:56 <sethk> Igloo, ok.
16:09:04 <sethk> Igloo, I didn't know my description was soo good.  :)
16:44:20 <Frederick> guys does anyone here knows how to keep haskell highligth active to all buffers in vim?
16:45:13 <dons> just turn it on by default?
16:45:20 <Frederick> dons, yup
16:45:33 <Pseudonym> Put "syntax on" in your vimrc.
16:45:35 <Frederick> dons, for this session
16:45:59 <dons> :syntax on
16:46:00 <Frederick> Pseudonym, any other command needed?
16:46:02 <Pseudonym> Or :syntax on from the command line
16:46:03 <Frederick> sone
16:46:04 <Pseudonym> Nope.
16:46:23 <Frederick> thx folks
16:47:46 <bosie> is there a way to get all prime factors of a number in just one line?
16:48:06 <shapr> bosie: Haskell Golf can you get anything in one line.
16:48:13 <shapr> But it might be a very long line.
16:48:17 <bosie> lol
16:48:35 <bosie> in a reasonable long line
16:48:36 <bosie> ;)
16:48:47 <dons> just use enough lambdas
16:48:59 <bosie> dons i bg ur pardon?
16:49:12 <bosie> beg
16:49:32 <shapr> The first lambda comes free man
16:49:35 * shapr tokes on a lambda
16:49:50 <bosie> hmmm
16:50:14 <bosie> come again please
16:51:56 <shapr> bosie: Soon you just won't get a buzz at all from C or C++, you'll only be able to get a real high from purely functional programming.
16:52:54 <Pseudonym> let { pf 1 _ = []; pf n (f:fs) = if n `mod` f == 0 then f : pf (n `div` f) (f:fs) else pf n fs } in pf 1023 [2..]
16:53:02 <Pseudonym> @eval let { pf 1 _ = []; pf n (f:fs) = if n `mod` f == 0 then f : pf (n `div` f) (f:fs) else pf n fs } in pf 1023 [2..]
16:53:04 <lambdabot> [3,11,31]
16:53:11 <Pseudonym> There you go.
16:53:20 <Pseudonym> Could probably remove a few spaces from there.
16:53:36 <Pseudonym> It's not terribly efficient, but it works.
16:53:40 <Pseudonym> @eval let { pf 1 _ = []; pf n (f:fs) = if n `mod` f == 0 then f : pf (n `div` f) (f:fs) else pf n fs } in pf 1024 [2..]
16:53:41 <lambdabot> [2,2,2,2,2,2,2,2,2,2]
16:54:32 <Pseudonym> @eval let { pf 1 _ = []; pf n (f:fs) = if n `mod` f == 0 then f : pf (n `div` f) (f:fs) else pf n fs } in pf 3107418240490043721350750035888567930037346022842727545720161948823206440518081504556346829671723286782437916272838033415471073108501919548529007337724822783525742386454014691736602477652346609 [2..]
16:54:38 <lambdabot> Terminated
16:54:40 <Pseudonym> Damn.
16:54:41 <bosie> is that for me?
16:54:46 <Pseudonym> No $15,000 for me.
16:55:19 <Pseudonym> Yes, that is a slightly-over-one-liner prime factoriser.
16:55:51 <bosie> let { pf 1 _ = []; pf n (f:fs) = if n `mod` f == 0 then f : pf (n `div` f) (f:fs) else pf n fs } in pf 1023 [2..]
16:55:58 <bosie> that line should do my job?
16:56:01 <Pseudonym> Yes.
16:56:07 <Pseudonym> That does 1023, obviously.
16:56:13 <Pseudonym> Substitute for your own number.
16:56:24 <bosie> hang on
16:57:30 <bosie> bosie :: Int
16:57:30 <bosie> bosie = let { ........
16:57:35 <bosie> doesnt even load
16:57:44 <Pseudonym> No.
16:57:49 <Pseudonym> Wrong type.
16:57:56 <Pseudonym> This returns a list of Int.
16:57:58 <bosie> kk
16:58:02 <Pseudonym> You wanted the prime factors, right?
16:58:05 <Pseudonym> Not just one factor?
16:58:12 <bosie> [int]
16:58:15 <bosie> yea right
16:58:30 <bosie> sweet
16:58:44 <bosie> did you just write that one out of the top of ur head?
16:58:44 <Pseudonym> There are more efficient ways, BTW./
16:58:48 <Pseudonym> Yes.
16:59:15 <Pseudonym> But it's based on one I wrote previously, which is much more efficient.
16:59:32 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/
16:59:44 <Pseudonym> I recommend grabbing that if you want something a bit more serious.
17:00:51 <bosie> dude how the heck can you know all that?
17:01:01 <bosie> it took me like 3 hours of trying without ANY result
17:01:27 <Igloo> Is there a good reason for 30030 in Prime, Pseudonym?
17:01:31 <Pseudonym> Yes.
17:01:38 <Igloo> Namely?  :-)
17:01:44 <Pseudonym> product [2*3*5*7*11*13]
17:01:49 <Pseudonym> Whoops.
17:01:56 <Pseudonym> @eval 2*3*5*7*11*13
17:01:57 <lambdabot> 30030
17:02:00 <Pseudonym> That's why.
17:02:27 <Pseudonym> BTW, it took me a couple of days to write Math.Prime.
17:02:28 <Pseudonym> On and off.
17:02:33 <bosie> rocks !
17:02:39 <bosie> Pseudonym thx you very much
17:02:49 <Pseudonym> No problem.
17:03:27 <bosie> damn nice
17:03:48 * Igloo scans http://primes.utm.edu/glossary/page.php?sort=WheelFactorization and gets confused by the 49 business
17:04:38 <Pseudonym> The wheel factorisation algorithm is actually much simpler than that explanation.
17:04:45 <Pseudonym> Suppose you're searching for primes.
17:04:54 <bosie> you arent a math prof or so?
17:04:55 <Igloo> Oh, because it isn't divisible by 2,3,5
17:04:58 <Pseudonym> Nope.
17:04:59 <Pseudonym> Right.
17:05:04 <bosie> math student?
17:05:08 <Pseudonym> Nope.
17:05:11 <bosie> right
17:05:14 <bosie> at least math interested?
17:05:18 <Pseudonym> Yes. :-)
17:05:23 <bosie> figured that ;)
17:05:36 <Igloo> So presumably it's faster to just try dividing than to discover we won't learn anything new by checking it for primality itself?
17:05:48 <Pseudonym> Anyway.  If you're trying to find the prime factors of some number, it makes sense to test 2 first, and then skip all subsequent even numbers.
17:06:07 <Frederick> guys Ive read yeat Another Haskell Tutorial, Haskell-Tutorial, A gentle introduction to Haskell, Two dozen short lessons and haskell to C programmers so I think I got the basics to start my homework, ive google for some samples and would like if you mind to check a pdf with me
17:06:08 <bosie> erm
17:06:10 <bosie> k
17:06:15 <Pseudonym> Similarly, it makes sense to test 3 first, and then skip all numbers divisible by 3.
17:06:39 <Frederick> the pdf explains how to representate free-contxt grammars in haskell but is it into a "pseudo" haskell so it will need some small twaks
17:06:44 <Pseudonym> i.e. only search numbers congruent to 1 and 5 (mod 6)
17:06:44 <Igloo> Yup, and eventually you hit the law of diminishing returns
17:06:55 <Pseudonym> Igloo: Kind of.
17:06:58 <Pseudonym> For small numbers, yes.
17:07:09 <Pseudonym> Which is why I only use primes between 2 and 13.
17:07:10 <Pseudonym> :-)
17:07:11 <gzl> isn't Atkin the standard fast way of computing all primes up to a given number?
17:07:42 <Pseudonym> gzl, I don't know that there's a "standard way".
17:07:48 <Pseudonym> But I'll look that one up.
17:08:07 <Pseudonym> Oh, nice!
17:08:12 <gzl> :)
17:08:16 <Pseudonym> That is a clever algorithm.
17:08:42 <Pseudonym> This is good for finding primes, but I'm not certain that it's better than the wheel algorithm for factorisation.
17:08:54 <bosie> actually at the moment i try to realize what ur code is doing
17:08:55 <gzl> that I don't know.
17:08:58 <Pseudonym> When searching for prime _factors_, you don't really need primes.
17:09:07 <Pseudonym> You just need a sequence which definitely contains all primes.
17:09:20 <Pseudonym> (Of which [2..] is a very conservative approximation.)
17:09:24 <gzl> yeah, I just noticed that your code generates a list of all primes up to a given number, so I thought I'd mention it
17:09:26 <Pseudonym> (Which is what I use in the one-liner.)
17:09:29 * Pseudonym nods
17:09:33 <Pseudonym> Thanks, I'll try that.
17:09:51 <gzl> djb has a fast C implementation of it
17:09:55 <Pseudonym> I wrote the code before this paper was published, though.
17:10:07 <Pseudonym> So you can forgive me for not knowing about it at the time, surely? :-)
17:10:26 <gzl> done. :)
17:10:39 <Igloo> Dude, Real Haskell module writers develop optimal algorithms as they go!
17:11:37 <bosie> Pseudonym thanks for the code lol i wonder why i didnt get it
17:12:37 <Pseudonym> BTW, I did go to a lot of trouble to optimise the case of small primes.
17:12:43 <Pseudonym> i.e. less than 30030^2.
17:12:49 <Frederick> guys the sample of what Im trying to do is here http://img414.imageshack.us/my.php?image=suggestion72ic.jpg and here http://img414.imageshack.us/my.php?image=suggestion85ak.jpg but there they only show how to define static grammars and I need to be able to give as inout the symbols, variables, and productions of the grammar can anyone give me a hand on it please?
17:13:05 <palomer> man, as soon as I have some free times on my hands I'm going to learn haskell
17:13:12 <palomer> is the haskell grammar a CFG?
17:13:23 <Igloo> That's probably few enough to hardcode, although ghc might make hard work of compiling it
17:13:29 <Frederick> palomer, lcfg?
17:13:32 <Igloo> Oh, squared. Maybe not.
17:13:36 <palomer> Frederick: lcfg?
17:13:50 <Frederick> palomer, what do you mean?
17:13:56 <palomer> context free grammar
17:14:17 <Pseudonym> It is, but its lexical language isn't regular.
17:14:35 <Pseudonym> The offside rule complicates things a lot.
17:15:26 <Frederick> palomer, this si exactly what im trying to do
17:15:42 <Frederick> palomer, but I dont think haskell is a cfg
17:16:09 * Igloo wonders if something close enough can be given without the "at a parse error, insert a }" clause for Haskell '06 (or Haskell 2 if that's not an option)
17:18:26 <palomer> hah
17:18:29 <palomer> what a coincidence
17:18:34 <palomer> the question just popped out of my head
17:18:38 <palomer> I don't think haskell is a CFG
17:19:05 <palomer> since deciding wether a name is a constructor or a free variable isn't something CFGable
17:19:33 <Igloo> The case of the first letter tells you that
17:19:45 <palomer> Igloo: is that part of the grammar?
17:19:57 <palomer> or is it simply encouraged, like in sml
17:20:06 <Igloo> It's part of the lexical syntax
17:20:15 <palomer> nice!
17:20:19 <palomer> 2 points for haskell
17:20:34 <Frederick> guys what do you mean?
17:20:37 <bosie> how can i check if 2 lists are equal ?
17:20:46 <Igloo> And if it wasn't then it would still be a CFG
17:21:04 <Pseudonym> @eval [1,2,3] == [1..3]
17:21:05 <lambdabot> True
17:21:18 <Igloo> Things would just be names rather than further differentiated
17:22:11 * Igloo suspects layout+parsing can't be expressed as a CFG, but parsing after the layout rule insertions is
17:23:36 <bosie> uhm
17:23:41 <bosie> eval isnt really declared is it?
17:25:15 <bosie> Pseudonym if i try that in ghci it doesnt work
17:25:20 <Frederick> Igloo, are you creating CFG's  with  haskell? cause I need some help on it
17:25:22 <bosie> parse error on input
17:25:46 <bosie> wait
17:26:12 <Igloo> I'm not
17:26:34 <Frederick> Igloo, thx
17:26:50 <Frederick> guys can anyone plese give me a small help with the links ive just posted aboive?
17:28:01 <bosie> Pseudonym how do you do it ?
17:28:25 <Pseudonym> I go into GHCi and type that on the command line.
17:28:37 <bosie> i did that
17:29:10 <bosie> <interactive>:1: parse error on input `@'
17:29:25 <Pseudonym> No, leave out the @eval.  That's a lambdabot command.
17:29:35 <bosie> oh
17:29:38 <Pseudonym> @arr
17:29:38 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
17:32:37 <Frederick> Pseudonym, are you reasonably used to haskell?
17:32:46 <Pseudonym> Yes, I'd say so.
17:32:56 <bosie> Frederick lol
17:33:09 <Frederick> Pseudonym, may you give me a help to start out?
17:33:21 <Frederick> bosie, what is so fun?
17:33:30 <Pseudonym> Perhaps.  You'd be better off asking in the group, so everyone can help.
17:35:20 <Frederick> Ive asked like 3 times but oki lets try again, Im trying to write a context-gree grammar manipulator, basically Im having problems how to manage a structure that dinamically accpets differents grammars (I mean changing productions, symbols, terminals...) Ive posted above screenshots of papers that give a pseudocode of what I want to do
17:36:07 <Pseudonym> Gotcha.
17:36:18 <Frederick> :)
17:36:48 <Pseudonym> Well, I usually use something like this:
17:36:58 <Pseudonym> data Sym = T String | N String
17:37:06 <Pseudonym> Where T means terminal and N means nonterminal.
17:37:07 <Pseudonym> Then:
17:37:15 <Pseudonym> Actually, even better:
17:37:19 <Pseudonym> type Term = String
17:37:22 <Pseudonym> type Nonterm = String
17:37:26 <Pseudonym> data Sym = T Term | N Nonterm
17:37:35 <Frederick> Pseudonym, oh Im starting to get it let me take a note book
17:37:38 <Pseudonym> data Production = Term ::= [Sym]
17:38:11 <bosie> Pseudonym dude you saved my day! thank you very much
17:38:24 <Pseudonym> bosie, can I ask what you're doing?
17:38:40 <bosie> preparing for my haskell exam
17:38:45 <Pseudonym> Ah, OK.
17:39:00 <bosie> prof is issuing 5 problems each lecture without giving the solution to it (doh)
17:39:44 <Frederick> Pseudonym, done
17:39:50 <Frederick> oki lemme read it with you
17:40:16 <Frederick> our symbols can be String of the terminals or variables sets right?
17:41:47 <Frederick> Pseudonym, shouldnt in fact Term and Nonterm be lists?
17:42:24 <Pseudonym> A terminal is a symbol.
17:42:28 <Pseudonym> So is a nonterminal.
17:42:32 <Pseudonym> I represent these by strings.
17:42:37 <Pseudonym> e.g. N "NP" for a noun phrase.
17:43:38 <Frederick> Pseudonym, ok so I will also need another structure like nontermSet = [Nonterm] right?
17:46:27 <Frederick> ??
17:47:54 <Pseudonym> If you want, yes.
17:48:01 <Pseudonym> Or just use [Nonterm]
17:48:28 <Philippa> as in data CFG = CFG {nonterms :: [Nonterm]...
17:48:39 <Philippa> (er, damn, someone's going to have to explain the record syntax now, right?)
17:49:31 <Frederick> Philippa, I didnt understand what you meant on your fist post
17:49:41 <Pseudonym> Philippa makes a lot of fist posts.
17:50:07 <Philippa> butbutbut... I'm sure Google Groups won't find a single post by me about fisting!
17:50:18 <Pseudonym> LOL
17:50:48 <Philippa> (x-noarchive is your friend ;-)
17:51:06 <Frederick> Philippa, why would I need records? would I need something like this? http://research.microsoft.com/~simonpj/Haskell/records.html
17:51:13 <Pseudonym> Unfortunately, it's not the friend of people who reply to your posts.
17:51:20 <Pseudonym> As I found out the hard way.
17:51:49 <Pseudonym> Frederick: A record is much like any other data constructor, except that the positions have names as well as position.
17:51:57 <Philippa> Frederick: no, I was using the existing Haskell98 record syntax. It's just a way of labelling items in a constructor
17:51:59 <Philippa> what he said
17:52:11 <Pseudonym> data Foo = Foo { one :: Int, two :: Char }
17:52:12 <Pseudonym> is the same as:
17:52:14 <Philippa> be careful about finding research. You don't want it, you want to know the existing language
17:52:16 <Pseudonym> data Foo = Foo Int Char
17:52:26 <Pseudonym> Except that it also defines two functions:
17:52:28 <Pseudonym> one :: Foo -> Int
17:52:33 <Pseudonym> one (Foo x _) = x
17:52:36 <Pseudonym> etc
17:54:29 <Frederick> oki so I would create something like data Productions = Productions {a :: Char, b::Char}?
17:54:46 * Philippa heads off for the night
17:54:53 <bosie> Pseudonym what do you do here:   pf n (f:fs) =
17:55:22 <araujo> Hello!!!!
17:56:52 <Frederick> Pseudonym, Philippa Ive read about parsec does it worth to be used on my case or it would only turns things harder?
17:57:05 <sethk> Frederick, definitely worth checking
17:57:29 <sethk> Frederick, there is of course also happy, which is a yacc type thing
17:57:43 <Frederick> sethk, oki guys so give me 1 more hour so I can read stuff
17:58:10 <Frederick> sethk, wich one of them do you recommend I want to do this project untill the next friday so I wont have time to read tons of different docs
17:58:40 <sethk> Frederick, well, happy works from a bnf input, which you are probably familiar with.  parsec is not difficult to learn.
17:58:50 <sethk> Frederick, I don't like code generators so I prefer parsec
17:59:03 <sethk> Frederick, but that's just me, most people don't have the same problem with code generators.  :)
17:59:46 <Frederick> sethk, oki as I feel im getting to somewhere I will make some more coffee and read both docs since they arent so big
18:00:50 <Pseudonym> bosie: That's pattern matching.
18:01:08 <Pseudonym> pf is the name of the function.
18:02:20 <bosie> let me read about it
18:06:46 <Pseudonym> Lunch.  BBL
18:12:56 * dons things QuickCheck should have a better logo
18:13:05 <dons> something with lambdas and foralls in it
18:13:05 * luqui agrees
18:13:13 * luqui disagrees
18:13:19 <dons> hehe
18:13:24 <sethk> luqui, is confused
18:13:27 <Frederick> sethk, parsec reports that handling left recursive grammars is a nousiance (I agree) and reports that thjere are 2 functions (I think this is the name) to help the programmer to get rid of left recursion as described here -> http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#chainl I think I need chainl1 am I right? so I can remove left side recursion as required to chomsky and greibachs normal forms am i right?
18:13:27 <dons> lambdas are compulsory!
18:13:39 <dons> even lambdabot has a lambda
18:13:52 <Cale> the rest of the greek alphabet feels left out :(
18:14:09 <dons> well, pi sometimes gets a run. Gamma is always welcome, so is tau
18:14:15 <dons> and big lambda is fun
18:14:25 <Cale> what about poor little upsilon
18:14:32 <Cale> nobody uses upsilon
18:14:33 <sethk> Frederick, you can definitely remove the left side recursion.  I'd have to check on which functions do what; it's been a few weeks since I was using it.
18:14:49 <dons> maybe we should start popularising upsilon
18:14:52 <sethk> Cale, epsilon is more popular
18:14:56 <Cale> yeah
18:15:04 <sethk> upsilon looks like a typo
18:15:09 <Cale> heh
18:15:15 <sethk> or a pun  :)
18:16:45 <Cale> Υυ -- I suppose it looks too close to roman letters if it's typeset the wrong way.
18:17:18 <Cale> In the font I'm using, uppercase upsilon looks just like Y, which isn't quite right.
18:20:13 <Frederick> sethk, I can be wrong but as far as Ive read I cant use happy cause I wont be able to make the simplifications
18:20:15 <bosie> whats the command for hugs in lnx?
18:21:02 <sethk> Frederick, That's possible.  Though, can't you make the same transformations you would make if using yacc ?
18:21:16 <Frederick> sethk, ive never used yacc
18:21:51 <sethk> Frederick, there are some routine transformations to the grammar to deal with potential ambiguities that I think are also usable with happy.
18:21:51 <bosie> whats the command for hugs in lnx?
18:22:02 <sethk> Frederick, AFAIK both can handle arbitrary grammars.
18:22:18 <sethk> Frederick, I know that yacc does more than just the restricted grammars.
18:22:18 <dons> bosie, "hugs" probably
18:22:43 <dons> unless you haven't installed hugs. you could also try "ghci" -- install ghc first though ;)
18:22:57 <bosie> ghci is insatlled but not working ;)
18:24:02 <Frederick> sethk, happy seemed more friendly but Im afraid of it cause Parsec docs looked much more complete
18:24:05 <luqui> bosie, what architecture are you on?
18:24:08 <bosie> thanks dons ;)
18:24:20 <dons> bosie, how is it not working?
18:24:23 <sethk> Frederick, if you are on a deadline and you are comfortable with parsec, go for it.  parsec is very good.
18:24:52 <bosie> dons hang on
18:25:15 <Frederick> sethk, im not on a hurry but I would say I dont have time to waste, like I need to start and ifinish cant be switching approachs
18:26:09 <sethk> Frederick, I'd say both are good, and if parsec strikes you as more intuitive or more complete, go with it.
18:26:15 <Frederick> k
18:26:22 <bosie> Loading package base ... /usr/lib/ghc-6.2.2/HSbase.o: unsupported ELF format
18:26:22 <bosie> ghc-6.2.2: panic! (the `impossible' happened, GHC version 6.2.2):
18:26:22 <bosie>         loadObj: failed
18:26:37 <sethk> bosie, that's kind of an ancient ghc
18:26:40 <Frederick> bosie, wich distro are you using?
18:26:55 <bosie> how do i know that?
18:27:09 <Frederick> bosie, are you on a linux box?
18:27:12 <dons> well, it's not that ancient
18:27:18 <bosie> Frederick how do i know
18:27:19 <dons> but I tihnk maybe he's on a funny OS
18:27:31 <Frederick> dons, that is why am I asking
18:27:32 <dons> type: uname -msr
18:27:54 <bosie> [fp425:~:29] uname -msr
18:27:54 <bosie> Linux 2.6.8-2-generic alpha
18:27:59 <dons> alpha!
18:28:03 <dons> no ghci on alpha
18:28:20 <sethk> dons, why?
18:28:22 <Frederick> boegel, uname -msro
18:28:31 <dons> no one has written the linker code
18:28:49 <Frederick> dons, what do you mean?
18:29:05 <bosie> [fp425:~:30] uname -msro
18:29:05 <bosie> Linux 2.6.8-2-generic alpha GNU/Linux
18:29:15 <dons> ghci requires linker support. ghc carries its own linner. it needs to be ported to each new arch/object format
18:29:22 <dons> no one has done this for the 64 bit alpha
18:30:00 <dons> it is done for: x86/* sparc powerpc ia64
18:30:06 <dons> oh and now amd64
18:32:29 <Frederick> dons, so he cant generate executables?
18:32:48 <dons> no, of course he can.
18:32:55 <Frederick> sethk, wich approach do you think is better to use with parsec? http://rafb.net/paste/results/QEN4Jm35.html
18:32:57 <dons> he just can't use ghci, the interactive environment
18:33:06 <dons> ghc itself still works fine
18:33:06 <Frederick> dons, oh
18:33:21 <Frederick> dons, maybe he can ssh a machine that has ghi
18:33:34 <Frederick> *ghci
18:33:46 <dons> of course
18:34:16 <bosie> i cant nop
18:34:17 <Frederick> bosie, do you have acces via ssh to any machine that runs ghci?
18:34:19 <bosie> and i ssh to a machine yes
18:34:31 <bosie> no ghci runs locally on my machine but no ssh
18:35:05 <Frederick> bosie, sorry I couldnt understand what you meant
18:35:10 <dons> anyway, you either ue hugs, or get to an x86 and use ghci
18:35:26 <dons> probably hugs is all you need anyway
18:35:45 <bosie> i connect to ssh and on that machine is hugs only and a broken ghci
18:35:57 <bosie> and locally i have ghci installed
18:35:59 <dons> so use ghci on the local machine then.
18:36:09 <bosie> yes but i have to test my code on the ssh machine
18:36:17 <dons> ok. so you're stuck with hugs then
18:36:25 <bosie> yes
18:36:44 <dons> the instructors must have said which compiler/interpreter to use, right?
18:36:57 <dons> you can of course test your code with ghc too
18:37:04 <dons> ghc --make Main.hs
18:37:06 <dons> ./a.out
18:37:15 <dons> you don't need to fiddle around in ghci
18:37:18 <bosie> ah thats cool thx
18:39:06 <dons> @seen shapr
18:39:06 <lambdabot> shapr is in #haskell-blah and #haskell. I don't know when shapr last
18:39:06 <lambdabot> spoke.
18:39:10 <bosie> thx guys
18:39:19 <dons> shapr, why shouldn't we fork QuickCheck?
18:39:31 <dons> no new code in a few years now, and it's only 300 loc anyway..
18:39:49 <dons> or maybe we can convince the code to appear in darcs..
18:39:52 <Frederick> guys how can I read the first construction here -> http://rafb.net/paste/results/rAKRUR37.html are both equivalent?
18:41:50 <sethk> Frederick, I'm not sure what you are asking
18:43:53 <Frederick> sethk, Im asking with of the ways is better (easier) to handle the grammar
18:45:32 <luqui> Frederick, you're trying to construct a parse tree?
18:45:45 <sethk> Frederick, I would probably say the first because it uses parsec capabilities.  Really the question is closely related to the gramar you want to implement
18:46:07 <sethk> Frederick, but if you are using parsec it probably pays to stay close to the parsec examples
18:47:04 <Frederick> sethk, no it isnt a tree it is a context free grammar handle, I must get a context free grammar and put it into greibachs end chomsky normal forms
18:47:16 <Frederick> I meant luqui
18:49:45 <luqui> ahh
18:49:58 <luqui> parsing a grammar with a grammar :-)
18:50:12 <Frederick> luqui, I dont get what you mean =/
18:50:23 <luqui> maybe I don't get what you mean
18:50:24 <luqui> anyway...
18:50:36 <luqui> is there a place where I can learn about arrows
18:50:49 <luqui> the paper and the teeny examples on the wiki have not been a help
18:52:30 <Frederick> guys oki ive started write the code, now I got a doubt, how can I associate 1 variable with a seth of productions? because in this example -> http://rafb.net/paste/results/PKnGEP98.html im saying that a Production is a terminal from the set of symbols right?
18:52:40 <luqui> and is there a way I can use Paterson's arrow syntax in my program?
18:54:11 <luqui> Frederick, your language is a little confusing... do you just want to use an array and then the "choice" function?
18:54:48 <bojohan> -farrows
18:55:17 <luqui> oh, neat
18:55:36 <Frederick> luqui, wich "choice" function are you talking about?
18:55:52 <Frederick> luqui, I got a Free-Context Grammar right?
18:56:45 <luqui> let's start from the top.  Do you have a context-free grammar in a data structure in your program, or do you have a particular context-free grammar you are trying to implement?
18:57:39 <Frederick> luqui, I need a structure to represent it cause I need to evalueate different grammars given in run time
18:57:54 <luqui> okay
18:58:35 <Frederick> so my first is step is be sure my current structure is oki do you think I can use thay?
18:59:44 <luqui> well, I'm having trouble with: data Production = Term ::= Sym
18:59:58 <luqui> Don't productions have a nonterminal on the left side?
19:00:07 <luqui> And don't they usually have more than one symbol on the right side?
19:00:23 <Frederick> luqui, so Im.
19:00:48 <luqui> ?
19:00:53 <Frederick> luqui, I can have productions like lemme rafb
19:01:16 <luqui> ? again
19:02:02 <heatsink> :)
19:03:03 <Frederick> luqui, http://rafb.net/paste/results/lZ1apj40.html
19:03:40 <luqui> oh paste :-)
19:04:00 <Frederick> luqui, I read is as , A grammar (G) is a set of variables (V), (T)erminals, (P)roductions, and a (S)tarting symbol oki?
19:04:11 <luqui> ok
19:04:30 <Frederick> my Starting Symbom S is S (could be S1) if you want
19:04:36 <luqui> mk
19:05:14 <Frederick> My productions are S->aSb | & where & is the empty word for exemple a&b = ab oki?
19:06:06 <luqui> oh, CNF
19:06:14 <Frederick> yes
19:06:15 * luqui doesn't have experience with that, but I get it
19:06:25 <Frederick> http://rafb.net/paste/results/MefaJ962.html
19:06:54 <Frederick> what do you mean by CNF?
19:07:05 <luqui> oh wait
19:07:07 <luqui> nevermind
19:07:08 <Frederick> thats not chomsky normal form yet
19:07:11 <luqui> this is a particular grammar
19:07:22 <Frederick> ?
19:07:48 <luqui> okay, moving on
19:09:10 <Frederick> so Ive created that basic structure http://rafb.net/paste/results/Ezdrtu27.html where I have a grammar that is a Set of terminals, Nonterminals and Productions oki?
19:10:15 <luqui> okay, and I still contest your definition of Production
19:10:27 <Pseudonym> Back.
19:10:42 <bosie> Pseudonym i looked at your math stuff
19:10:49 <bosie> Pseudonym are you a fulltime haskell guy?
19:10:52 <Pseudonym> Nope.
19:11:04 <bosie> any other FP language?
19:11:05 <luqui> I think (and I could be wrong) that it should be: data Production = Nonterm ::= [Sym]
19:11:09 <Pseudonym> Nope.
19:11:15 <bosie> k
19:11:20 <Frederick> luqui, no problem I can understand it I got it from examples so lets check
19:11:38 <bosie> Pseudonym then you arent so bad ;)
19:11:40 <Frederick> luqui, you are right
19:11:49 <bosie> better said: therefor ;)
19:12:01 <Frederick> Im writing the basics on a notebook before coding in pc
19:12:04 * Pseudonym has been using strongly-typed lazy functional languages since about 1992
19:12:08 <luqui> ahh
19:12:11 <Pseudonym> On and off.
19:12:17 <Frederick> luqui, so how do I read that statement?
19:12:24 <bosie> in 92 i didnt even have a computer :(
19:12:40 <luqui> A production defines a nonterminal to be a sequence of symbols
19:13:03 <Frederick> luqui, so it is wrong do you agreee with me?
19:13:16 <luqui> so what is wrong?
19:13:22 <Pseudonym> I did.  I even had Gofer for DOS.
19:13:56 <Frederick> cause a nonterminal is 1 symbol, a Variable is a sequence (can I call it a set?) of variables and terminals
19:14:39 <luqui> a Variable is a sequence of nonterminals and terminals?
19:14:51 <luqui> (I'm not familiar with the notion of a variable in a CFG)
19:15:25 <Frederick> luqui, is as in S -> aSb, S is a variable, it is a sequente os terminals (a,b) and nonterminals (S) is it oki?
19:16:03 <bosie> and i dont even know what Gofer is
19:16:21 <luqui> Uh, okay
19:16:48 <bosie> ok guys
19:16:53 <bosie> thank you very much for all your help
19:16:58 <Frederick> luqui, is it clear for you?
19:17:04 <bosie> i am off to bed, good night
19:17:24 <luqui> not really
19:17:28 <Pseudonym> Hugs is the Haskell User's Gofer System
19:17:45 <Pseudonym> It's a partial rewrite of Gofer, the earlier system, to conform to Haskell.
19:17:47 <Pseudonym> Anyway, night.
19:18:23 <bosie> hehe after 6 months alpha assembler coding for univ i have to admit hugs is alot better than asm
19:19:05 <luqui> bosie, no kidding ;-)
19:19:32 <bosie> luqui yes ;)
19:19:44 <bosie> luqui i did prolog last sem too and i already prefer haskell
19:20:45 <Frederick> luqui, I want to use my construction to do the follwiing I want to read via console -> S is my starting Symbol, P is my set of productions, {a,b] is my set of terminals
19:22:30 <bosie> nite
19:23:46 <luqui> hmm.  Frederick, sorry I can't seem to help.  I have to do homework now :-/
19:24:14 <Frederick> luqui, thx a lot :)
19:24:18 <Frederick> good luck with hm
19:35:24 <Frederick> guys what is wrong on line 7? http://rafb.net/paste/results/358Tsp43.html
19:35:51 <heatsink> is this a quiz?
19:36:01 <Frederick> heatsink, no, why?
19:36:43 <heatsink> It sounds like a quiz question.  (5 pts) find the error in this code.
19:37:03 <heatsink> Anyway, types have to start with an uppercase letter.
19:37:04 <Frederick> I want to have a special variable called starting symbol that is of the type of symbols
19:37:35 <Frederick> heatsink, that was the problem :)
19:37:58 <Frederick> heatsink, is my use of getline incorrect?
19:38:01 <heatsink> Do I get 5 points?
19:38:24 <luqui> Frederick, it needs to be capitalized
19:38:38 <Frederick> heatsink, yes and a candy
19:38:50 <heatsink> yay
19:38:53 <luqui> from a very superficial look at the problem.  You may be trying to do something different though
19:39:28 <heatsink> Frederick: also, variables have to strt with a lowercase letter
19:40:15 <Frederick> updated version http://rafb.net/paste/results/zwznki53.html
19:41:34 <Frederick> I have an error saying that the last statament of the do must be an expression
19:42:07 <heatsink> right
19:42:15 <heatsink> What do you expect main to do?
19:42:43 <Frederick> heatsink, by the momment I just want to store my set o ariables, terminals, starting symbols and productions
19:44:14 <heatsink> You are reading strings, are those supposed to represent sets?
19:45:38 <Frederick> heatsink, im not sure of the best way to do it yet a grammar would have a representation like http://rafb.net/paste/results/lZ1apj40.html so I think i need sets
19:48:34 <luqui> sets are very seldom necessary.  They are used in abstract descriptions because they are the language of mathematics.  Usually you translate that into higher-level data structures
19:48:51 <luqui> I would store a CFG as a map from nonterminal names to sequences of symbols
19:49:03 <luqui> excuse me, lists of lists of symbols
19:49:07 <Frederick> luqui, great idea
19:49:20 <Frederick> luqui, isnt a map a good idea?
19:49:26 <heatsink> Oh, "context-free grammar"
19:49:36 <heatsink> I was trying to figure out what kind of control flow graph that was :)\
19:49:44 <Frederick> heatsink, rofl
19:50:40 * luqui usually avoids using CFG as context-free grammar, but that's what we've been talking about for the last hour :-)
19:52:33 <Frederick> luqui, how can I do this map?
19:53:21 <Frederick> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html#map
19:54:48 <luqui> huh?
19:55:02 <luqui> oh
19:55:03 <luqui> map
19:55:10 <luqui> haha, you want Map
19:55:43 <luqui> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
19:56:05 <dons> @doc Data.Map
19:56:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
19:56:08 <dons> :)
19:56:13 <luqui> lambdabot++
19:58:05 <Frederick> luqui, how do I use it for what I need I mean, first I use getStr to read the sets than use map? can you give me a hand on it?
19:58:36 * luqui is still procrastinating
19:58:40 <luqui> I have to get out of here
19:58:41 <luqui> sorry
19:59:14 <Frederick> thx a lot dude
19:59:26 <Frederick> dons, do you know how to use map?
20:00:09 <dons> @eval map toUpper "haskell"
20:00:10 <lambdabot> "HASKELL"
20:00:25 <dons> or do you want Data.Map?
20:00:52 <Frederick> Lemem read about Data.map
20:01:19 <dons> you mean Data.Map right?
20:01:23 <dons> case is important :)
20:01:30 <dons> @eval M.empty
20:01:30 <lambdabot> Add a type signature
20:01:37 <dons> @eval M.empty :: M.Map String String
20:01:38 <lambdabot> {}
20:01:49 <dons> @eval M.insert "foo" "bar" M.empty :: M.Map String String
20:01:50 <lambdabot> {"foo":="bar"}
20:02:05 <dons> @eval let m = M.insert "foo" "bar" M.empty :: M.Map String String in M.insert  "x" "y" m
20:02:06 <lambdabot> {"foo":="bar","x":="y"}
20:02:40 <dons> this show instance is bogus
20:02:58 <Frederick> dons, if I wanted to do something like S->aSa | & how would it be?
20:03:14 <Frederick> like S generates aSa or generates empty
20:03:20 <Frederick> where S is a variable and a is a terminal
20:03:26 <dons> do you want the parsec code for this?
20:03:35 <dons> what kind of 'do something' do you mean?
20:04:05 <heatsink> It's a good idea to figure out what you're going to do with your data before you figure out how you will store it.
20:04:32 <heatsink> And it would help to explain the former before asking us about the latter :)
20:04:39 <Frederick> dons, yes itm trying to use parsec
20:05:28 <Frederick> I want to generate a context-free grammar representation I want to give the parts of the grammar, than give a word and check if the word belongs to the language generated by the grammar
20:07:06 <heatsink> Are you going to use Parsec to do the checking?
20:08:02 <Frederick> yes
20:08:11 <Frederick> but this is a future step
20:10:59 <Frederick> any ideas?
20:11:57 <heatsink> Well, I don't know much about context free grammars.
20:12:01 <heatsink> I understand bnf.
20:12:18 <Frederick> heatsink, it is pretty much the samething
20:12:58 <skew> I'm trying to get a pretty printer to do what I want - foo(a,b) => foo(a,\nb) -> foo\n(a,b) -> foo\n(a,\nb)
20:13:00 <Frederick> heatsink, like this http://rafb.net/paste/results/lZ1apj40.html
20:13:20 <Frederick> I got s that is a starting symbol, a set of productions, and a set of terminals
20:13:24 <heatsink> Frederick: that doesn't look like bnf to me though
20:13:27 <skew> I can get Daan's pprint to do it, but not Wadler's or the one that comes with GHC
20:13:45 <skew> (the \n in the argument list is supposed to line b up with a)
20:14:38 <skew> heatsink: the productions in the set "P" are the BNF part
20:14:50 <heatsink> oh, thx
20:15:00 <skew> S names the start symbol, and T is the list of tokens
20:15:05 <Frederick> skew, exaclty thx a lot
20:15:27 <skew> what's the V for?
20:16:16 <Frederick> skew, v is the set of variables
20:17:11 <skew> nonterminals?
20:17:17 <Frederick> yes
20:19:01 <Frederick> guys here http://en.wikipedia.org/wiki/Formal_grammar#Context-free_grammars
20:19:25 * heatsink forgot why you wanted help
20:19:42 <Frederick> heatsink, i want give input on the sets
20:21:35 <Frederick> got the idea?
20:22:33 <heatsink> Yea.
20:23:41 <Frederick> can you please just help me to accomplish this cause Ive istarted it like 18 pm knowing nothing of haskell at all and now it is almost 3 am and I will feel very happy if I finish this input stage by today
20:23:58 <heatsink> Well, you have 21 hours left :)
20:24:19 <heatsink> I think next step is to make a data type for your grammar.
20:24:24 <Frederick> heatsink, what do you meant?
20:24:58 <Frederick> heatsink, input doesnt work yet, the data type for the productions is missing you guys have suggested map but I dunno how to use it
20:26:16 <heatsink> In this case, Set might be more appropriate.  But it's hard to tell.
20:27:16 <Frederick> wich would be the difference?
20:29:54 <heatsink> Well, I would make the choice by designing the function that makes a parser that accepts strings out of a grammar specification.
20:30:39 <heatsink> Now I'm trying to figure out how to say something more useful
20:30:49 <Frederick> what would it be? sorry it is 3 am here and im not a native english speaker if you could explain into a lower level I might understand so I go sleep thinking on it to continue tommorw
20:31:18 <heatsink> Are you comfortable writing higher-order functions?
20:32:09 <Frederick> what is that?
20:33:21 <heatsink> Are you comfortable giving functions as inputs to functions, or getting functions as outputs from functions?
20:33:47 <Frederick> heatsink, sure, Ive done calculus, discrete math and a bunch of this crap
20:34:04 <Frederick> f(g(h(x))) is a friend of mine >:p
20:34:05 <heatsink> ok
20:36:06 <heatsink> Let's see...
20:36:34 <heatsink> What do you want to do with the grammar, after you read it?
20:38:43 <Frederick> heatsink, I need to remove uselless symbols, empty productions, basically transform it to chomsky and greibachs normal forms, also check if given words belong to it
20:39:19 <Frederick> ah I also need that productions like A->B B ->a become A->a where B was excluded
20:40:14 <heatsink> Okay.
20:41:23 <Frederick> ?
20:41:32 <heatsink> Yes, then Data.Map is probably what you want.
20:41:53 <heatsink> It stores (key, value) pairs.
20:42:53 <heatsink> Terminals don't have associated data, so those can go in a Set
20:42:54 <Frederick> heatsink, 3 am here my brain is frozen
20:43:09 <Frederick> so I will just take not of this tis
20:43:12 <Frederick> tips
20:43:43 <heatsink> the modules Data.Map and Data.Set both contain definitions of useful data structures
20:43:59 <Frederick> k
20:44:46 <heatsink> um... figure out the grammar for how you specify the CFG, write a parser for it using Parsec to produce your data
20:45:10 <heatsink> Have you found the documentation for the haskell libraries and Parsec?
20:45:19 <sh10151> Frederick: itym (f . g . h) x
20:45:26 <Frederick> heatsink, yes and have already read it
20:45:31 <Frederick> sh10151, ?
20:46:04 <heatsink> ok, then you should be ready to go.
20:46:17 <Frederick> heatsink, I will re-read it tommorow and come back with more concise questions, but I still stuck with the input stuff but the map will change my input so I wont mind wit it now
20:46:23 <Frederick> dudes thx a lot gtg sleep cya
20:46:31 <heatsink> goodngiht.
20:46:47 <dons> @elite dudes thx a lot gtg sleep cya
20:46:47 <lambdabot> dudE$ T|-|x a |OT 9+G zlEeP (y4
20:46:49 <dons> hehe
20:47:06 <ozone> @elite owned
20:47:06 <lambdabot> o\/\/ned
20:47:39 <sh10151> @elite combinator
20:47:40 <lambdabot> C0mbInAT0r
20:47:54 <sh10151> @elite tackling the awkward squad
20:47:54 <lambdabot> +4(k|InG +hE 4wKWARd sQu4d
20:48:07 <sh10151> missed out on the \/\/\
20:48:17 <sh10151> \/\/here did it go wrong?
20:48:28 <dons> it chooses different ones each time
20:48:33 <dons> @elite tackling the awkward squad
20:48:33 <lambdabot> +Ack1ING tHE awKW4rD zqUAD
20:48:33 <sh10151> @elite tackling the awkward squad
20:48:34 <lambdabot> t4xxLINg +|-|3 4wkw4rD zQuad
20:48:49 <sh10151> t4xxling
20:48:55 <sh10151> i like it
20:49:04 <sh10151> hmm
20:49:09 <sh10151> @elite +Ack1ING tHE awKW4rD zqUAD
20:49:09 <lambdabot> +4(x1iN9 +h3 aWkw4rd Zqu4d
20:49:32 <sh10151> @elite +4(x1iN9 +h3 aWkw4rd Zqu4d
20:49:33 <lambdabot> +4(x1in9 +h3 a\/\/xW4RD zqU4d
20:56:32 <dav> what's the fixed point :-)
21:44:16 <dons> @yow
21:44:16 <lambdabot> I feel partially hydrogenated!
21:58:45 <Pseudonym> Gotta go.  Nytol!
22:30:00 <dons> hello MauS, welcome :)
22:36:09 <MauS> hello, everyone
22:38:44 <dons> MauS, learning haskell, or have you been using it for a while?
22:39:49 <MauS> dons: have been learning for several months :)
22:39:54 <dons> cool :)
22:40:11 <dons> you should check out our user map:
22:40:12 <dons> @map
22:40:12 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
22:40:32 <dons> you can add your coords by logging in and editing the page.
22:41:02 <dons> I know there's quite a few .ru haskell people, but they're not yet on the map for some reason
22:41:44 <MauS> hmm, why not. Will add myself. By the way, what's the purpose of it?
22:42:12 <dons> oh, we just like to see how far and wide the #haskell community is spread :) it's just for fun.
22:42:28 <dons> also, it seems to have the side effect of helping people get to know each other
22:43:02 <dons> for example, the south american guys i think didn't all know each other until they got on the map
22:43:18 <MauS> you convinced me :)
22:48:14 <dons> morning boegel
22:50:42 <boegel|home> hey dons
22:53:47 * boegel|home scratches his head
22:54:13 <boegel|home> I'm profiling a benchmark for work, and it has been running for 75h already :|
22:54:29 <dons> hmm :/
22:54:38 <dons> sounds like you need to do some profiling ;)
22:55:36 <boegel|home> well, it's quite a big benchmark, needs 12m native execution
22:56:40 <boegel|home> when I compare to my other runs, it should take about 56h, but I'm way over that already...
22:56:46 <dons> 12m of binary code?
22:56:55 <dons> 12M
22:57:41 <dons> what's it written in?
22:59:18 <dons> @seen shapr
22:59:18 <lambdabot> shapr is in #haskell-blah and #haskell. I don't know when shapr last
22:59:18 <lambdabot> spoke.
22:59:46 <rasfar> I was going to update my coordinates (moved some months ago), but it says I'm not allowed to edit the page.  Is that because someone else is editing it, or am I in somebody's bad books?
23:00:06 <dons> you have to login these days
23:00:14 <dons> thanks to the spammers
23:00:27 <rasfar> oh ah ... let's see if I can figure out how ....
23:00:33 <dons> to log in you cliick on 'UserPreferences' (bizarrely enough), get a name and passwdd, refresh.
23:00:37 <dons> then edit away :)
23:01:13 <dons> i've made this decision to stick to a really high key repeat rate, in the hopes my typing will get even faster, and i'll stick to it, damnit ;)
23:01:24 <boegel|home> dons: 12 minutes :à
23:01:30 <boegel|home> let me check the size...
23:01:54 <dons> 12 minutes native executoin? you mean when not profiling?
23:02:02 <dons> ikegami--, hey! you should also be on the map:
23:02:04 <dons> @map
23:02:04 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:02:08 <boegel|home> dons: yes
23:02:09 <dons> since you're around all the time :)
23:02:22 <dons> and when you profile it drops to 72hrs!?
23:02:27 <boegel|home> I have a ~3m benchmark which took over 10hours
23:02:32 <dons> this isn't ghc's profiler, I guess?
23:02:57 <boegel|home> dons: yeah :) nonono, not at all :) I'm using ATOM, which profiles the execution each 100,000 instruction
23:03:06 <boegel|home> s/100,000/100,000th
23:03:09 <boegel|home> it's written in C
23:03:17 <dons> that is so bad, 72hrs. you should complain to them.
23:03:22 <dons> gprof isn't good enough?
23:03:29 <boegel|home> no I shouldn't, it just takes that long :)
23:04:10 <dons> ah, so every 100k instrs, it halts everything, and increments counters for all statee values and such like?
23:04:18 <dons> I'm guessing..
23:04:33 <boegel|home> dons: I'm measuring some stuff, µarch-independent characteristics (ilp, workload, data stream stride, ...)
23:04:47 <ikegami--> dons: ok :)
23:05:06 <boegel|home> and that needs some calculation each 100,000th instruction, and also some bookkeeping each instruction
23:05:35 <dons> huh. wow. well, i guess you'll get some data out of 72hrs of this thing :)
23:05:53 <boegel|home> dons: yeah :) I already have 66m of output :)
23:06:30 <skew> you are getting a lot more data than just execution time then?
23:06:41 <boegel|home> so far 767495100000 instruction :)
23:06:44 <boegel|home> +s
23:07:38 <boegel|home> roughly 767 billion <:O)
23:10:03 <basti_> whats that going to be? ^^
23:11:52 <boegel|home> I'm just gathering info on several benchmark suites
23:12:01 <basti_> ah
23:12:12 <boegel|home> the bad thing is, SpecCPU2000 is yet to come, and that uses almost 4h of native execution time
23:13:00 <boegel|home> @seen Itkovian
23:13:01 <lambdabot> I saw Itkovian leaving #haskell-overflow, #haskell-blah and #haskell 1
23:13:01 <lambdabot> day, 9 hours, 55 minutes and 1 second ago, and I have missed 19 hours, 49
23:13:01 <lambdabot> minutes and 9 seconds since then.
23:13:01 <basti_> is that a cpu emulation yes?
23:13:18 <boegel|home> basti_: no, it's instrumented code
23:13:34 <boegel|home> so it runs natively, but with a lot of instructions added
23:13:35 <basti_> i see
23:13:43 <dons> hmm. 12 / (72 * 16) == 4 * 60 / x
23:13:55 <dons> 72 * 60, i mean
23:14:02 <boegel|home> dons: ?
23:14:08 <ikegami--> Hey, I notice that I couldn't edit the HaskellUserLocations via web browser
23:14:27 <dons> you need to login first
23:14:28 <ikegami--> I got a error message 'You are not allowed to edit this page'
23:14:31 <ikegami--> aha
23:14:32 <dons> click on UserPreferences
23:14:44 <dons> get a name and passwd, refresh, and edit away :)
23:15:39 <ikegami--> I see
23:21:31 <ikegami--> then I added my address on the page
23:21:52 <ikegami--> wow already there are two japanese
23:21:58 <ikegami--> :)
23:22:06 <dons> :) I'll regenerate the map now.
23:22:08 <ikegami--> and many in east asia
23:26:28 <rasfar> wow, i'm currently furthest north in western hemisphere! and it's beginning to feel like it too.
23:38:41 <stefanw> I'm writing a post install hook in Cabal. How can I get the directory where binaries should be installed to? LocalBuildInfo has only `prefix'
23:40:05 <C-Keen> moin
23:58:13 <MauS> dcoutts: maps from xearth look nice :)
