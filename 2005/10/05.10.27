00:00:12 <Pseudonym> Errr... I thik so.
00:00:26 <Pseudonym> In theory you should be able to do this by scrapping your boilerplate.
00:00:44 <sethk> OK, I'll look at the docs
00:01:08 <sethk> I can write a program to generate them in a few minutes, but maybe something already exists
00:03:55 <Pseudonym> Gotta go.
00:03:59 <Pseudonym> Nytol!
00:06:14 <kzm> @seen JohnMeacham
00:06:15 <lambdabot> JohnMeacham is in #haskell. Last spoke 47 minutes and 56
00:06:15 <lambdabot> seconds ago.
00:07:45 <kzm> Good morning!
00:43:16 <JohnMeacham> hello.
00:45:16 <JohnMeacham> Hmm.. I am thinking about the possibility of adding continuations to GRIN. on one hand, they would be very useful, on the other, I worry they might break useful properties and they would completly futz up my region inference plans.
01:06:55 <dons> JohnMeacham, I like your codegen analysis btw :) great stuff
01:07:30 <gour> JohnMeacham: i like you jhc work, sounds great
01:07:45 <JohnMeacham> dons: thanks. it was an accidental discovery, I accidently typed ./a.out instead of ./hs.out and noticed it took several seconds instead of one. I am still not sure what is happening with x86_64
01:07:55 <gour> JohnMeacham: how long it will take on amd64
01:08:09 <gour> JohnMeacham: i'd use jhdc-darcs ebuild
01:08:41 <gour> JohnMeacham: s/ jhdc-darcs/jhc-darcs
01:08:51 <JohnMeacham> jhc produces code that runs roughly the same on x86-64 and i386, within a few percent. ghc code runs dramatically slower on x86_64 than i386 for reasons I am investigating.
01:09:22 <gour> JohnMeacham: i mean, how long does the build runs in comnparison with ghc?
01:09:43 <JohnMeacham> gour: heh. not ready for that yet. although some stuff is reliably faster than ghc, some stuff is drastically slower, I think I am losing sharing somewhere in jhc which will be a very tricky bug to track dow.
01:10:32 <gour> JohnMeacham: well, let me try another time - how long it will take to build jhc on amd64 3000/1GB ?
01:10:34 <JohnMeacham> gour: oh. jhc compiles small programs on the order of minutes. and runs out of ram before it can compile big ones :)
01:11:23 <gour> JohnMeacham: i'd also like to see better ghc performance on amd_64, that's why i put 64-bit Gentoo on my box at the 1st place
01:11:29 <JohnMeacham> gour: ah. to build jhc with ghc? not long, 10-20 minutes maybe. I have a amd64 3200/2GB . but keep in mind I have no concept of time.
01:11:54 <gour> JohnMeacham: ok, let me try it then..
01:12:15 <dons> is ghc compiling via C or asm on amd64?
01:12:18 <JohnMeacham> I'd like to see haskell take advantage of the SSE goodness on amd cpus..
01:12:22 <JohnMeacham> c.
01:12:33 <JohnMeacham> it always uses C for -O builds.
01:12:39 <dons> ah yes, of course
01:12:48 <dons> though simonM has rumoured switching to asm
01:13:16 <dons> for what it's worth, my OS hacker friends always moan when I tell them about how ghc lays out code and data, and does computed jumps all over the place
01:13:29 <dons> "won't someone think of the caches?" they plead
01:14:30 <gour> JohnMeacham: how does jhc compare with nhc, or what is your primarily reason for another hc?
01:14:38 <JohnMeacham> well, given what I saw in the post, I am surprised we are getting any benefit from gcc at all! we are completly constraining what it can do. in fact, I wouldn't be surprised if ghcs asm output surpsassed via-C, not because the asm output is awesome but because via-C is producing horrible code :)
01:16:01 <dons> now that we use Cmm as a nice clean imperative IR, it should be possible to cleanly do things like the pattern matching you describe
01:16:06 <JohnMeacham> gour: to try out crazy optimizations that no one said would work in a production compiler and try to make them do so :) to test out new language extensions. but the original motivation was to learn haskell, I started it as my first non-toy haskell project. I figured it would cause me to learn the language twice as fast as I had to both use it and understand it to write a compiler for it.
01:16:14 <dons> this was intended at least, when we were rewriting the backend last summer
01:17:03 <JohnMeacham> dons: yeah, I have been looking at the ghc Cmm stuff, and thinking about how I could modify grin such that it could produce especially good output given the power of a cmm backend rather than C
01:17:08 <dons> if you're up for it, porting some of this low-level tricks as rewrites on Cmm would be pretty cool
01:17:13 <gour> JohnMeacham: iirc, i read that somewhere :-)
01:17:58 <JohnMeacham> dons: I was thinking just that. I think ghc has both a cmm parsing and printing library, so I think you get a cmm -> cmm optimizer for free if you split it off into its own program.
01:18:06 <gour> JohnMeacham: so you are definitely for production compiler quality, not a research project?
01:18:17 <dons> JohnMeacham, yes true. that could be done.
01:18:18 <JohnMeacham> gour: that is the intent. it has a ways to go.
01:18:43 <dons> we have a reasonably nice ppr for Cmm (I tried to follow the C-- spec, but it's probably drifted a bit since then)
01:18:51 <dons> and Simon wrote a Cmm parser
01:19:01 <dons> (for the rts code written in Cmm)
01:19:09 <gour> JohnMeacham: i understand
01:19:10 <JohnMeacham> dons: are they both in the ghc/compiler/cmm directory?
01:19:24 <dons> there's a nice spot in the backend too for a hook to optimise Cmm -> Cmm, prior to generating either C or asm
01:19:35 <dons> it's commented out at the moment I think, this hook.
01:19:42 <dons> should be in the cmm dir, yes
01:20:02 <dons> Cmm.hs  CmmLex.x  CmmLint.hs  CmmParse.y  CmmUtils.hs  MachOp.hs  PprC.hs  PprCmm.hs
01:20:05 <dons> all live in cmm/
01:20:43 <dons> the C we print from Cmm is pretty much as-is, and could be tweaked to be friendlier to gcc, I'm sure
01:20:44 <JohnMeacham> I might grab them. I got a lot of ideas from reading the cmm paper. I think with minor tweaks grin could represent all of cmm but in a monadic/typesafe framework! so we get a theory behind cmm for free.
01:21:28 <dons> ah!
01:21:43 <dons> just having basic types in the Cmm code was of great benefit (see CmmLint.hs for example)
01:21:50 <JohnMeacham> in particular, if I add continuations and jumps, everything cmm can do is there and it still retains all its monad properties.
01:23:39 <JohnMeacham> I have convinced myself continuations don't break the monad properties, but it worries me that it introduces a possible bug, that you can hold onto a continuation after a stack frame runs out. grin is 'safe' in the sense that the only possible runtime error in typesafe grin is running off the end of a case statement. breaking that would make me sad. perhaps the type system could differentiate between values that might hold
01:23:39 <JohnMeacham> a continuation and those that can't.. hmm..
01:24:59 <JohnMeacham> so, I definitly think we can formulate all of cmm as a monad, but I am unsure whether we can do so in a way that guarentees all run-time invarients that we would like to.
01:26:38 <pejo> dons, isn't cmmToCmm the "hook" you're talking about? (in AsmCodeGen.hs in nativeGen/ in my (old) checkout).
01:26:39 <JohnMeacham> global registers are a little iffy too. but not so bad because we can assume they were just declared in some arbitrary outer scope and hold the equivalant of IORefs and are not mutable themselves.
01:26:47 <dons> pejo, I think that's the one, yep
01:26:57 <dons> or no, hang on, there's one a bit higher up
01:27:00 <dons> not in nativeGen
01:28:23 <dons> cmmToCmm is just a quick rewrite isn't it, for the asm generator? it used to be a stix phase
01:28:42 <dons> oh, I see it does constant folding
01:28:42 <pejo> dons, nod.
01:29:01 <gour> sethk: have you checked SE lib?
01:29:30 <sethk> gour, haven't really had a chance yet, other than glancing at it.
01:30:04 <gour> sethk: ok, pls. let me know after trying it, what do you think
01:30:26 <sethk> gour, I will
01:30:31 <gour> sethk: ta
01:32:02 <JohnMeacham> hmm.. the monadic cmm would also necesarily always be in SSA form, which is not a problem I think. I guess the question is whether arbitrary gotos and labels can be simulated with continuations? does anyone know?
01:32:39 <JohnMeacham> without code duplication being a key requirement.
01:34:01 <dons> I wonder if the SSA<->ANF paper says anything on this
01:34:58 <dons> http://www.cse.unsw.edu.au/~chak/papers/CKZ03.html
01:35:50 <kzm> JohnMeacham, do you still think it is cache that accounts for difference between AMD and Intel perf?  Or has that possibility been eliminated?
01:35:52 <dons> I have a feeling one of the authors, patrykz, has pondered the connection between continuations and gotos/labels.
01:37:44 <JohnMeacham> kzm: no. at least, not in the way I said. but it very well might in another way.
01:39:20 <kzm> If so, it'd be interesting to check how it performs on Athlon (not -64) and PIII as well.
01:41:12 <kzm> How does the A64 perform in 32-bit mode?  (One would presume the caches were similar?  Or perhaps funny behavior is triggered by longer pointers?)
01:45:09 <dons> John, timely mail from SPJ...
02:15:53 <JohnMeacham> okay. I have convinced myself that continuations can subsume arbitrary labels if we introdue an 'mfix' primitive to grin. very nice.
02:16:39 <JohnMeacham> I am curious, why is it nasty? I think i am missing something being used to x86.
02:18:04 <JohnMeacham> oh. his other email? hmm..
02:19:47 <vegai> the latest lambdabot seems to be using some FastPackedString that isn't in ghc-6.4.1, right?
02:20:13 <vegai> ah, google found it. Nevermind.
02:21:41 <dons> vegai, yep you need fps
02:21:49 <dons> currently experimental .. i'm hacking on it as we speak
02:23:35 <vegai> about the problem with runplugs... do you think it would be possible to backport that fix from ghc-6.5 to ghc-6.4.1?
02:24:18 <dons> :/ hmm.
02:24:24 <dons> we could ask SimonM very nicely
02:24:25 <dons> perhaps
02:25:03 <vegai> I guess it cannot be fixed at runplugs's end?
02:25:05 <dons> what you up to with lambdabot?
02:25:20 <dons> nope, it's a bug in the fd handling in the Process lib, fixed by TheHunter in 6.5
02:25:50 <ibid> he's running a lambdabot on our course channel
02:26:25 <vegai> well, I could also just use ghc-6.5
02:26:25 <dons> ah, cool :)
02:26:33 <vegai> is it relatively stable?
02:26:36 <dons> just install 6.5 on the lambdabot machine, and things should be good.
02:26:38 <dons> very stable
02:26:42 <dons> try:
02:26:44 <dons> @version
02:26:44 <lambdabot> lambdabot 3p120, GHC 6.5.20050806 (Linux i686)
02:26:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
02:26:51 <dons> the 6.5.20050806 snapshot
02:26:58 <dons> that's been running for months in #haskell with no worries
02:27:00 <vegai> ok, I'll give that a shot
02:27:14 <dons> let me know if you have any other difficulties
02:27:25 <vegai> yep
02:27:37 <dons> for one, atm, I'm trying to make the build system more self-contained.
02:27:44 <dons> for example, runplugs is also built inplace now
02:28:00 <dons> and memory usage is going down. it halved already today, and hopefully i can make some more gains
02:28:23 <dons> vegai, also, with 6.5, you get nicer @type output
02:28:25 <dons> and @kind works better
02:35:04 <dcoutts> dons, what gtk version were you using there?
02:35:16 <dcoutts> dons, 2.4.x right?
02:35:39 <dcoutts> that demo should only be complied for gtk 2.6.x I think
02:35:41 * dcoutts checks
02:35:49 <dons> ok. yeah. 2.4.x
02:36:16 <dcoutts> my fault
02:36:25 <dcoutts> I added the about dialog thing which is 2.6 only
02:36:34 <dcoutts> but didn't update the build
02:37:04 <dcoutts> we try to only build demos that are expected to work for the configuration
02:37:12 * dcoutts fixs that
02:40:11 <dcoutts> dons, did the mozemed demo work then?
02:40:35 <dons> hmm, not sure if I got that far in the build
02:40:45 <dons> i'll try again when I get home
02:42:42 <ricebowl> there's no way to process a tuple as a list, is there?
02:43:03 <ricebowl> that is, I want to map over (a, a)
02:47:04 <ricebowl> hmm, Haskell tuples are not so nice :(
02:47:19 <tromp> tmap f (a,b) = (f a,f b)
02:49:35 <ricebowl> ah
02:49:45 <ricebowl> but there's no way to treat tuples generically, is there :|
02:50:10 <ricebowl> i.e. tmap *only* works for tuples of 2, not for 3, 4, 5, etc.
02:50:55 <Cale> ricebowl: no, in fact, Haskell programmers rarely use any tuples which aren't pairs
02:51:19 <ricebowl> *nods* so it would seem
02:51:21 <Cale> if your datatype has more than 2 things in it, write a data declaration
02:51:46 <Cale> in fact, sometimes you want a data declaration even when it does have just 2 things in it
02:51:58 <Cale> then you can provide an instance of Functor and use fmal
02:51:59 <ricebowl> well I am not referring to any specific code, just wishing that tuples were orthogonal to lists
02:52:00 <Cale> fmap*
02:52:09 <ricebowl> since the only real difference is that tuples have a static, defined length
02:52:13 <Cale> um, they are orthogonal to lists
02:52:22 <Cale> you mean something like parallel :)
02:52:29 <kosmikus> Generic Haskell can handle tuples generically
02:52:41 <ricebowl> "Generic" Haskell?
02:52:47 <ricebowl> Cale - I meant generically
02:53:06 <kosmikus> it's a language extension, but the implementation is rather experimental
02:53:16 <Cale> ricebowl: the tuple equivalent of a list is something like (a,(a,(a,(a,()))))
02:53:16 <ricebowl> Cale - wouldn't you be able to fmap over a tuple?
02:53:26 <ricebowl> Cale - I know
02:53:33 <ricebowl> kosmikus - ah, I see
02:53:38 <Cale> also, look at the HList library
02:53:49 <kosmikus> generic-haskell.org
02:53:59 <Cale> you can't generally fmap over tuples, because they have 2 types associated with them
02:54:17 <Cale> you need a pair of functions, which you lift to a tuple function
02:54:29 <Cale> tmap f g (x,y) = (f x, g y)
02:54:34 <ricebowl> Cale - ah, true...
02:55:22 <kosmikus> that's why in Generic Haskell, gmap {| (,) |} takes two function arguments, and gmap {| (,,) |} takes three ...
02:55:24 <Cale> if they have all the same type, then that's the same as a list, except that the length is stored in the type
02:55:40 <ricebowl> Cale - right, which is the primary reason why I bother with tuples
02:55:45 <ricebowl> they are *extremely* convenient for that
02:56:43 <Cale> well, you could use some typeclass swindling to encode the naturals at the type level and use that to make sure your vectors have the right dimensions
02:57:31 <Cale> If you go along that road you end up with the HList library :)
02:58:00 <ricebowl> ah well
02:58:23 * ricebowl just wants to complete his class assignment
02:58:23 <Cale> or you could use arrays
02:58:34 <Cale> arrays work well too
02:58:51 <Cale> though they're not compile-time checked
03:00:15 <Cale> they make it harder to get the bounds wrong than a list though, and if you're accessing things randomly, they'll do much better than a list performance-wise
03:01:00 <ricebowl> *nods*
03:01:09 <ricebowl> !! does surprisingly well too ;)
03:01:28 <Cale> xs !! n is O(n)
03:01:32 <ricebowl> yes
03:01:45 <kosmikus> yes, so for sufficiently small n, it does well
03:01:47 <ricebowl> however, in Hugs I believe it was, !! was significantly faster than using my own function which did the same thing
03:01:57 <roconnor> We need dependent types for vectors of length n.
03:02:52 <roconnor> I wonder if we can abuse the class mechanism to do this.
03:03:02 <Cale> yeah
03:03:04 <Cale> you can
03:03:05 <kosmikus> sure, it's already done
03:03:13 <kosmikus> you can use GADTs too
03:03:25 <kosmikus> but it's all not very nice
03:03:31 <roconnor> anyhow, if you have (a, (a, (a, ...))) with all the same types, what you really want is a list.
03:04:08 <roconnor> oops, I mis-read what tmap did.
03:04:40 <ricebowl> heh, what's the difference between Prelude.take and List.genericTake?
03:04:53 <Cale> @type List.genericTake
03:04:54 <lambdabot> forall a i. (Integral i) => i -> [a] -> [a]
03:04:57 <ricebowl> the only difference I see is that the latter takes an Integral instead of an Int
03:04:59 <Cale> @type take
03:04:59 <lambdabot> forall a. Int -> [a] -> [a]
03:05:03 <Cale> yes
03:05:12 <Cale> that's the only difference
03:05:39 <Cale> I think the generic versions should be the ones in the prelude with specialisations made in the case of Int
03:06:16 <ricebowl> heh, I still don't see the difference ;)
03:06:29 <Cale> well, you can't use the prelude version with an Integer
03:06:39 <ricebowl> yes
03:07:04 <ricebowl> but that said, you generally can't have a list with more elements that can be represented by Integer...
03:07:33 <Cale> right, but you have to do lots os fromIntegral to get the types right this way
03:07:36 <Cale> of*
03:08:41 <ricebowl> hm, I see
03:09:00 <Cale> by Int, you mean, of course :)
03:10:46 <ricebowl> er, right
03:11:02 <ricebowl> hm, what's the syntax for case?
03:11:05 <Cale> Integer too, but that's less spectacular :)
03:11:08 * ricebowl has never used it before
03:11:10 <Cale> case x of
03:11:16 <Cale>    foo -> ...
03:11:21 <ricebowl> ah ok, thanks :p
03:45:42 <ibid> well, the length of the following list is not representable by either Int or Integer:
03:45:54 <ibid> let xs = 1: xs in xs
03:45:55 <ibid> :
03:49:05 <musasabi> and in practise it is quite hard to use lists with length larger than maxBound of Int (and running length on them sounds very slow=
03:50:11 <ibid> only if you force the evaluation of that many elements
03:51:33 <gour> dcoutts: ping
04:21:15 * kzm is trying a different server (the EU one), hoping there will be fewer disconnects this way.
04:21:48 <ibid> "the" eu one?
04:22:00 <ibid> i'm on
04:22:03 <ibid> 14:21 [Freenode] -!-  server   : orwell.freenode.net [Helsinki, FI, EU]
04:22:17 <kzm> ibid, eh, well - irc.eu.freenode.net or something like that.
04:22:40 <ibid> heh
04:22:45 <kzm> What was in my menu - apoligies if I fail to grok the guts of IRC properly.
04:23:00 <ibid> well, that's probably more than one server
04:23:07 <ibid> (nothing irc-specific about this)
04:23:20 <kzm> And my name is still listed as using irc.freenode.net
04:23:22 <ibid> there are more than one eu server, that irc.eu or whatever gives you a random one
04:23:33 <kzm> Okay.
04:23:49 <ibid> irc.freenode.net gives you a random one from anywhere
04:23:52 <kzm> I just tend(ed) to get avalances of people disappearing and reappearing.
04:24:05 <ibid> find out your closest server and use that :)
04:24:09 <ibid> orwell is mine
04:24:12 <kzm> I guess the only thing I changed was the use of a proxy.  Let's see what happens.
04:24:34 <kzm> @find-closest-server
04:24:35 <lambdabot> Unknown command, try @listcommands.
04:24:39 * kzm grins.
04:25:01 <ibid> the freenode web page lists servers
04:25:10 <ibid> at least used to
04:34:54 <JohnMeacham> does no one agree that 'spineless tagless G machine' would be an awsome name for a band?
04:35:16 <glasser> Good morning #haskell!
04:35:35 <glasser> So I now have My First Real Haskell Program, which takes about an hour to do a complex calculation
04:35:58 <glasser> I'd like to understand why, perhaps by the equivalent of throwing in some logging statements to see when it gets to each step
04:36:06 <vegai> @paste
04:36:06 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:36:09 <glasser> What's the best way to do this? Something involving the writer monad?
04:37:13 <SamB> glasser: do what?
04:37:24 <vegai> ghc has a profiler, perhaps that could help?
04:37:36 <SamB> oh, the logging?
04:37:36 <vegai> doesn't it...?
04:37:45 <SamB> vegai: yes, there is a profiler
04:37:53 <glasser> Right, and I'll give that a shot (dons was showing me the profiler last night for a different reason)
04:38:26 <ibid> Debug.Trace does logging, but it also changes the program's eval order
04:39:45 <vegai> http://users.aber.ac.uk/afc/stricthaskell.html
04:40:02 <glasser> What does "The trace function is not referentially transparent" mean?
04:40:13 <glasser> Also, how does it output a string without beig in the IO monad?
04:45:32 <autrijus> glasser: using the wonderful unsafePerformIO :: IO a -> a
04:45:56 <autrijus> glasser: the trace "functions" is a much needed imperative desert, in the wide oasis of referential transparency
04:46:00 <glasser> ah
04:46:10 <glasser> so basically "it's wrong but it feels so right"?
04:46:13 <autrijus> yes
04:46:43 <kosmikus> it doesn't feel right anymore after a while ...
04:46:56 <autrijus> it breaks reftrans because different evaluation order will yield different output
04:47:08 <autrijus> whilst reftrans means (among other things) evaluation order doesn't truly matter
04:47:19 * glasser nods.
04:47:23 <glasser> So my two questions were one and the same,
04:47:28 <autrijus> yup.
04:48:23 <kzm> JohnMeacham,
04:48:40 <kzm> Oops.
04:49:18 * kzm was trying to come up with something clever, mixing up STG with Spinal Tap, but apparently failed.
04:49:54 <kzm> STG, well known for its punctuality?
04:49:57 * kzm sighs.
04:50:12 <glasser> Hmm.  Will trace output its label before or after evaluating the other arg? Or does this question make no sense?
04:50:50 <kzm> I'd expect before, but haven't really experimented with it.
04:51:23 <glasser> since my program seems to print the trace statement for every single step in the program in seconds (and then take hours to actually calculate the results)
04:51:29 <kzm> (or am able to come up with a good way to perform meaningful experiments :-)
04:51:43 <kzm> I suspect that would be due to laziness.
04:51:49 <glasser> right
04:52:05 <glasser> I mean, that's what makes sense from a functional standpoint, but dammit I want my cake and eat it to
04:52:10 <glasser> er, have and eat too
04:52:17 <kzm> E.g. if you do trace - perform calculation - trace - print result, the actual calculation is likely not being performed before you print.
04:52:47 <kzm> Try to force it, with e.g. seq?
04:53:10 <glasser> Can I do that without monadifying my whole program?
04:54:17 <autrijus> you can use seq
04:54:22 <autrijus> and implicit params
04:54:28 <autrijus> and even _linear_ implicit params
04:54:34 <autrijus> and FFI
04:54:44 <glasser> i'm not sure I get what you mean
04:54:45 <autrijus> those being the chief nonmonadic ways of imperativeness
04:55:33 <kzm> Short answer: yes.
04:56:18 <glasser> oh, seq != sequence
04:56:48 <kzm> I.e. x `seq` y  will return the same as y, but evaluate x to WHNF first.  WHNF is not necessarily complete evaluation, though.
04:57:12 <kzm> (Usually makes sense when x is part of y)
04:58:14 <kzm> I haven't looked, but one way to implement trace is to use something like: trace msg exp = unsafePerformIO (print msg)) `seq` expr
04:58:32 <kzm> Without the seq, the IO would never be performed, as its result is not required.
04:58:45 <glasser> Hmm, I need to do it the other way round though. ie, I want to do the IO *after* the thing with an interesting result
04:59:29 <kzm> let result = f x in result `seq` trace msg result ?
04:59:42 <glasser> Oh, that's cute
04:59:52 <xah> sorry Basic Question... when i do "f x = x + 1" and ghci says parser error on =. ?
05:00:06 <glasser> You can't define functions through ghci
05:00:16 <earthy> let f x = x + 1
05:00:19 <boegel> xah: let f x = x + 1
05:00:24 <boegel> earthy: grr :)
05:00:35 <boegel> @plugs let f x = x + 1 in f 3
05:00:36 <lambdabot> 4
05:00:43 <kzm> earthy-boegel: 1-0
05:00:52 <xah> darn... quite frustrated with ghci... if i can't define functions, can't define types, what's a good use of ghci?
05:01:01 <kzm> @score earthy +1
05:01:02 <earthy> xah: you *can* define functions
05:01:02 <lambdabot> Maybe you meant: code more
05:01:16 <boegel> xah: yes you can
05:01:17 <earthy> but only using let
05:01:26 <boegel> xah: using let
05:01:28 <xah> why do i have to use the "let" in ghci?
05:01:29 * boegel grrs
05:01:32 * earthy looks at boegel ;)
05:01:41 <ibid> xah: because the ghci prompt is inside do
05:01:48 <ibid> (well, sort of:)
05:01:49 <boegel> xah: because ghci is only intented for rapid prototyping
05:02:02 <xah> ok. Thanks.
05:02:10 <boegel> kzm: score ?
05:02:30 <kzm> Well, the bot seems to do just about everything else :-)
05:02:35 <earthy> if you want to do full haskell at a toplevel, get Helium and Hint
05:03:01 <kzm> With all the features, I might as well try things just to see if they happen to be implemented.
05:03:25 <glasser> Oh, duh, easier way:
05:03:33 <kzm> @karma boegel
05:03:33 <lambdabot> boegel has a karma of -1
05:03:35 <glasser> just make sure the trace message depends on the result :)
05:03:39 <kzm> Oops!
05:04:00 <kzm> @karma kzm
05:04:01 <lambdabot> You have a karma of 0
05:04:29 <boegel> :(
05:05:58 <xah> if i put add1 x = x + 1 \n f(4) in a file x.hs and do :load x, what am i missing?
05:06:02 <tuomov> hmm.. I can't seem to be able to build hs-plugins
05:06:15 <tuomov> $ cat install.sh
05:06:20 <xah> do i need some kind of "main" stuff?
05:06:58 <ibid> xah: what do you expect should happen?
05:07:20 <earthy> the f(4) is not Haskell
05:07:54 <xah> ha ha... i just want to test of defining a function, calling it, print it.
05:07:57 <glasser> you can put "add1 x = x + 1" in x.hs, then in ghci ":load x" and then "add1 6"
05:08:09 <eivuokko> earthy, it is function applcation of f with parameter 4 isn't it...
05:08:16 <earthy> eivuokko: no.
05:08:18 <glasser> calling functions from ghci is possible, not just defining them
05:08:21 <boegel> xah: then you should invoke it
05:08:30 <xah> i see.
05:08:35 <earthy> not as I read the haskell report, but I'll check
05:09:03 <eivuokko> earthy, Uhm, it does happen to work with ghc, but I didn't read report.
05:09:25 <glasser> isn't it just equivalent to f 4? where the parens are just grouping parens that aren't really grouping anything?
05:09:28 <xah> yay it worked. Thanks. :)
05:09:44 <glasser> putting it at top level in a file might not be great
05:09:58 <earthy> hm. I may misread the lexical structure for program then
05:10:10 <earthy> which is repetitions of lexeme whitespace
05:10:22 <earthy> ah, see. I did misread. ;)
05:10:41 <earthy> there is a | there that I missed in my pdf viewer
05:11:10 <earthy> anyway, a functionapplication isn't allowed at toplevel. :)
05:11:16 <eivuokko> :)
05:17:22 <boegel> almost at 200 again
05:20:28 <dons> I'm scared, does this mean haskell is mainstream?
05:21:04 <dons> what will we do with ourselves, when we're not in a secret club anymore?
05:22:00 <bringert> make up a new language
05:22:38 <glasser> the new language will only have side effects, nothing can return values
05:22:56 <dons> yeah!
05:23:14 <dcoutts> gour, pong
05:23:20 <CosmicRay> glasser: isn't brainf*ck such a language?
05:23:26 <bringert> it should be so pure that it only has functions, no values
05:23:32 <CosmicRay> bringert: heh
05:23:33 <bringert> hmm, that's lambda calculus
05:23:41 <dons> no, we'll just start programming in dependently typed haskell, and no one will understand what we're doing anymore
05:23:57 <int-e> CosmicRay: for lack of function calls, maybe. There's a lot of testing values for zero and modifying values going on...
05:23:57 <bringert> we'll write all our programs at the type level
05:24:00 <CosmicRay> dons: oh, I thought that already happened (arrows) ;-)
05:24:09 <dons> bringert, right!
05:24:14 <glasser> nah, brainfuck can totally read from an array
05:24:47 <dons> e.g http://www.cse.unsw.edu.au/~dons/qs.transcript
05:25:03 <bringert> glasser: how do you take input if all you can do is side effects (= change stuff)
05:25:04 <dons> in particular, who needs an eval: *Sort> :t listQSort list1
05:25:04 <dons> Cons
05:25:04 <dons>     (Succ Zero)
05:25:04 <dons>     (Cons (Succ One) (Cons (Succ Two) (Cons (Succ Three) Nil)))
05:25:20 <glasser> bringert: You expect so much from a language
05:25:52 <bringert> hmm, I wonder where my type-level fixed-width binary arithmetic program went
05:26:05 <bringert> 32-bit addition in types
05:26:10 <dons> we really need some way to do IO on the type system, I think we need monads up there
05:26:17 <bringert> hmm
05:26:33 <bringert> you can do that with TH, right?
05:26:52 <dons> yeah, but it's kinda hacky
05:26:55 <dons> ;)
05:27:05 <musasabi> What about just lifting types to value level (and just giving N seconds to the typechecker) ?
05:27:08 <dons> I want real state in my types :)
05:27:23 <bringert> real estate?
05:27:31 * dblhelix asks: what's the best way to present the operational semantics of a small functional language with a letrec construct?
05:28:03 <dcoutts> dblhelix, ml.
05:28:28 <dcoutts> dblhelix, because in Haskell the lazyness makes the presentation of operational semantice harder.
05:28:37 <dblhelix> dcoutts: I mean, formally.... as a proof system
05:29:14 <dons> on paper, or in a prover?
05:29:24 <dblhelix> dons: on paper...
05:29:33 <dblhelix> did I mention the language is non-strict? ;)
05:29:53 <dons> have you read: Programming Languages: Theory and Practice, Robert Harper
05:30:08 <dblhelix> dons: no
05:30:19 <dons> http://www.cs.cmu.edu/~rwh/plbook/offline.pdf
05:30:33 <dblhelix> dons: thanks
05:30:41 <dons> I reckon *that's* the way to do it.
05:30:57 <dons> it's how we teach it here at unsw, too
05:31:46 <C-Keen> re
05:31:47 <dblhelix> dons: I always considered letrec a derived construct (i.e. in terms of let and fix)
05:31:57 * musasabi thinks of a type like "data Type = Int | Integer | List Type | ..." and allowing functions operating on Types into type signatures (+ maybe monads)...
05:32:37 <dons> type-level functions are on their way...
05:32:48 <eivuokko> Hmmh.
05:33:13 <musasabi> dons: but there is a difference between normal Haskell functions just operating on type level and cheating with evil class declarations...
05:33:30 <dons> yeah, we want just normal functions, right?
05:33:33 <musasabi> yes.
05:33:43 <dons> that's what are on their way. spj and chakravarty at least are working on this
05:34:02 <musasabi> Tricking type classes to act as functions feels very unelegant and hacky - not very haskell like.
05:34:23 <dons> exactly. we just have to sit back and reaalise, heh! we want normal functions on the type level
05:34:23 <kosmikus> well, it's not only type classes you can use
05:34:27 <kosmikus> gadts are much nicer already
05:35:08 <kosmikus> musasabi: http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/typecase.pdf
05:35:16 <kosmikus> is a nice overview of the techniques that you can use
05:37:40 <musasabi> kosmikus: isn't that more about generics?
05:39:16 <kosmikus> what do you want?
05:39:49 <musasabi> of course one can declare: data Z; data S a; class Add a b c | a b -> c; instance Add Z (S a) (S a); instance Add a (S b) x => Add (S a) b x
05:40:47 <musasabi> I want to have: add 'Z x = x; add ('S x) y = 'S (add x y)
05:41:40 <musasabi> both say the same thing (minus bugs), but one is much more readable.
05:41:43 <xah> what's with the exodus??
05:41:56 <kosmikus> so, what you really want is dependent types ...
05:42:05 <xah> lol. is that a class room?
05:42:11 <dons> or enough of an extension of system F ...
05:42:23 <kosmikus> like omega?
05:42:41 <musasabi> dependent types are scary.
05:43:03 <dons> hmm, possibly. I think the spj/chak stuff is less than omega, but you still get terminating functions
05:43:07 <mattam_> a little
05:43:08 <kosmikus> less scary to me than duplicating the Haskell language on the next level
05:43:09 <dons> musasabi, oh they're not so bad :)
05:43:34 <ndm> musasabi: i agree! way scary
05:43:38 <musasabi> kosmikus: is there something that can be expressed with normal functions that cannot be expressed on type level with type classes (with a deep nesting stack) ?
05:43:57 <musasabi> if not, then there should be no problem of using functions in place of those evil instances.
05:44:00 <mattam> dons: reference ?
05:44:28 <kosmikus> musasabi: I definitely agree that functions are better than classes.
05:44:28 <dons> mattam, oh, for the unpublished in-progress spj work ?
05:44:39 <mattam> yep
05:44:41 <dons> no referrences yet, except the two recent associated types papers
05:45:12 <mattam> hmm, ok, i'll find them
05:45:35 <boegel> 199 !
05:45:57 <dons> and i'm not sure if it's hinted at there, but here's the refs of the recent work: http://www.cse.unsw.edu.au/~chak/papers/CKP05.html
05:47:23 <kosmikus> but associated types are also "more about generics" ...
05:47:43 <dons> it's all type hackery, right?
05:47:45 <glasser> dons: what was the point of the -auto-all in the profile compilation last night?
05:47:57 <glasser> I see it in --help but don't quite grok
05:48:06 <kosmikus> dons: depends on what you want to say by this
05:48:07 <dons> glasser? what compilation?
05:48:33 <glasser> when we were trying to get the profiler working to figure out when a head was throwing an error
05:48:36 <kosmikus> I think that associated types are much less hackery than fundeps
05:48:39 <glasser> (hmm, maybe not "last night" for you )
05:48:55 <kosmikus> or, positively put, they're more "in the spirit of functional programming"
05:49:00 <dons> kosmikus, I agree  :)
05:49:08 <dons> no hackery as in evil, hackery as in fun!
05:49:35 <dons> glasser, -auto-all inserts profiling points automatically for you
05:49:41 <dons> no need to add SCC points by hand
05:49:49 <glasser> ah, I see
05:49:58 <dons> profiling points, also known as "cost centres"
05:50:07 <mattam> looks like a java or ML module interface from here
05:50:12 <dons> the term  "profiling points" I just made up :S
05:51:38 <dons> mattam, regarding ML functors, there's a 2 way translation between Haskell with associated types and ML modules
05:52:04 <mattam> i suppose it's section 6 stuff
05:52:09 <mattam> :)
05:52:44 <dons> the translation is to appear in stefanw's forthcoming thesis
05:53:08 <dons> actually, the phrac repo probably has a working version already
05:55:26 <glasser> Does the profiler use CPU time or real time? (Or the real question: if I put my laptop to sleep and then take it to campus, will that screw it up?)
05:55:53 <dons> hmm
05:55:58 <dons> try it!
05:56:13 <glasser> Oh, I am anyway, but I won't know the answer for a few hours :)
05:56:41 <glasser> I suppose if it says "an execution of + took 3 hours" I will know my answer :)
05:57:09 <musasabi> associated types solve some problems one has to fight with fundeps.
05:59:12 <musasabi> at least I think so. (I get things like class Foo a b | a -> b; bar :: forall t. Foo SomeType t => ... which section 6.1 hints might be solvable with associated types)
06:06:22 <datenmaulwurf> Hi!
06:07:02 <eivuokko> Hello.
06:08:03 <araujo> Morning!
06:08:14 <datenmaulwurf> I have to create the caesar chiffrieralgorithmus in haskell
06:08:54 <datenmaulwurf> it's my first semester and functional programming isn't my best
06:09:03 <datenmaulwurf> can anyone help me with it?
06:09:04 <beelsebob_> @hoogle [a] -> a -> [a]
06:09:05 <lambdabot> Terminated
06:09:05 <lambdabot>  
06:09:06 <vegai> a what?
06:09:11 <beelsebob_> m'kay?
06:09:15 <vegai> I mean the what?
06:09:19 <beelsebob_> hoogle working well in lambdabot
06:09:22 <b0gg1e> ..then you have found a jolly good opportunity to improve it :-)
06:09:34 <vegai> I believe dons mentioned that it was broken due to some update
06:09:43 <b0gg1e> it's really really not that hard.
06:09:59 <b0gg1e> (ceasar chiffre)
06:10:10 <vegai> oh, such a thing really exists? :)
06:10:18 <datenmaulwurf> yeah, i have no idea - i think i need 2 functions, which convert char -> ascii and ascii -> char
06:10:23 <vegai> @google ceasar chiffre
06:10:25 <lambdabot> http://www.unikik.uni-hannover.de/downloads/Kryptographie_MNU2002.ppt
06:10:38 <b0gg1e> call it "alphabet rotation"
06:10:38 <vegai> bah.
06:11:11 <datenmaulwurf> lol, i don't have powerpoint :|
06:12:04 <b0gg1e> with n=3
06:12:04 <datenmaulwurf> the is a note: er use only "non-capital-letters" (i dont know the word in english) and the next letter of "z" is "a"
06:12:16 <datenmaulwurf> n should be variable
06:12:21 <datenmaulwurf> but this is not the problem ;)
06:12:37 <earthy> lower case, datenmaulwurf
06:12:43 <datenmaulwurf> ah, thanks
06:12:45 <datenmaulwurf> right
06:13:09 <earthy> (named after the cases the lead letters were in, capitals in the upper case, others in the lower case)
06:14:51 <earthy> upper case, capital, majuscule vs lower case, 'small letter', minuscule
06:15:34 <kzm> Hi.  I have something fishy going on with Data.IntSet and split.  Any known bugs?
06:15:41 <datenmaulwurf> i know it's very bad to ask for a complete solution, but i have no ideo how to start and how to rotate the letters
06:16:05 <gour> dcoutts: so, this db stuff is interesting..
06:16:18 <kzm> split 16 $ fromList [17,18,19,30,40] ==> ({},{17,18,19,30,40})
06:16:20 <kzm> But:
06:16:24 <earthy> datenmaulwurf: well, find a way to map letters to new letters
06:16:37 <earthy> parameterized by the n
06:16:42 <kzm> split (16*m) $ fromList (List.map (m*) [17,18,19,30,40]) ==> ({17000000,18000000,19000000},{30000000,40000000})
06:16:46 <earthy> then, apply that map to each letter in a string
06:17:25 <kzm> (surely these numbers are way too small to cause overflows?)
06:18:02 <datenmaulwurf> ok
06:18:03 <b0gg1e> . o O ( String = [Character] )
06:18:22 <datenmaulwurf> b0gg1e, i know *g*
06:18:28 <datenmaulwurf> but thanks!
06:18:35 <datenmaulwurf> ok
06:18:46 <datenmaulwurf> but how to convert the letter to a Int?
06:19:15 <earthy> ord?
06:19:28 <b0gg1e> fromEnum :: forall a. (Enum a) => a -> Int
06:19:29 <datenmaulwurf> foo n = ord (n)   ?
06:19:53 <kzm> It changes behavior when m>=482 (!)
06:19:55 <kzm> Help?
06:20:05 <b0gg1e> characters are just an example of an enumeration, haskell is more abstract here than most programming languages
06:20:23 <b0gg1e> there's also toEnum.  there, now you know all you need.
06:22:03 <datenmaulwurf> ok, thanks
06:22:07 <datenmaulwurf> i'll try it
06:23:33 <int-e> @eval let m=1000000 in S.split (16*m) $ S.fromList (List.map (m*) [17,18,19,30,40])
06:23:35 <lambdabot> ({},{17000000,18000000,19000000,30000000,40000000})
06:24:47 <datenmaulwurf> what's wrong with this part?
06:24:47 <datenmaulwurf> caesar  n       =       ord (n)
06:24:57 <earthy> um. nothign?
06:25:11 <datenmaulwurf> i call it: caesar bla
06:25:19 <datenmaulwurf> caesar bla
06:25:19 <datenmaulwurf> ERROR - Undefined variable "bla"
06:25:35 <datenmaulwurf> or only with one letter
06:25:36 <datenmaulwurf> the same
06:25:47 <datenmaulwurf> caesar b
06:25:47 <datenmaulwurf> ERROR - Undefined variable "b"
06:26:38 <earthy> @eval let caesar n = ord n in caesar 'b'
06:26:39 <lambdabot> 98
06:26:47 <xerox-> Morning
06:27:05 <xerox-> What are you doing with Sets? woot :)
06:27:14 <kzm> int-e, is S IntSet or Set?  It works with regular Sets of Ints.
06:27:22 <int-e> kzm: it's Data.Set
06:27:26 <int-e> hmm.
06:27:30 <kzm> Data.IntSet doesn't work.
06:27:46 <kzm> xerox-, trying to pack both key and value into the same Int :-)
06:27:58 <int-e> ah, that line had scrolled out.
06:28:42 <xerox-> If they're fixed-size it's trivial
06:29:04 <earthy> okay, a simple caesar cipher is about 5 lines.
06:29:18 <xerox-> earthy: is it rot13 ?
06:29:30 <earthy> xerox: caesar is rotn ;)
06:29:39 <earthy> where n is a parameter
06:30:24 <datenmaulwurf> what's the opposite of ord?
06:30:29 <earthy> chr
06:30:30 <datenmaulwurf> Int -> Char?
06:30:33 <datenmaulwurf> thanks
06:30:44 <earthy> btw, you don't need either :)
06:31:07 <earthy> (using ord and chr will break on EBCDIC machines, e.g.)
06:31:15 <datenmaulwurf> :(
06:31:20 <datenmaulwurf> so how should i start?
06:31:24 <earthy> not that there's many of those around
06:31:34 <datenmaulwurf> toInt :: Char -> Int
06:31:34 <datenmaulwurf> toInt   a       =       ord (a)
06:31:34 <datenmaulwurf> toChar :: Int -> Char
06:31:34 <datenmaulwurf> toChar  n       =       chr (n)
06:31:46 <earthy> well, what if you had a list mapping each character to the right transposed character?
06:31:46 <datenmaulwurf> i thought i should start with these 2 functions
06:31:59 <earthy> that's what you're after, right? :)
06:32:09 <xerox-> caesar n = fmap (chr.(+n).ord)
06:32:29 <earthy> xerox-: that breaks on ebcdic. that breaks on z. that breaks. :)
06:32:37 <xerox-> woot
06:32:41 <xerox-> just mod it :)
06:33:10 <earthy> @eval let caesar n = fmap (chr.(+n).ord) in caesar 3 "abcdefghijklmnopqrstuvwxyz"
06:33:12 <lambdabot> "defghijklmnopqrstuvwxyz{|}"
06:34:10 <xerox-> @eval let caesar n = fmap (chr.(`mod` 26).(+n).ord) in caesar 3 "abcdefghijklmnopqrstuvwxyz"
06:34:11 <lambdabot> "\SYN\ETB\CAN\EM\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\
06:34:11 <lambdabot> SI\DLE\DC1\DC2\DC3\DC4\NAK"
06:34:16 <xerox-> hah.
06:34:25 <earthy> told ya. :) it breaks. :)
06:34:54 <earthy> and you are assuming that characters of the alphabet are in consecutive places in your character ordering
06:35:17 <xerox-> @eval let caesar n = fmap (chr.(+97).(`mod` 26).(+n).(subtract 97).ord) in caesar 3 "abcdefghijklmnopqrstuvwxyz"
06:35:18 <lambdabot> "defghijklmnopqrstuvwxyzabc"
06:35:29 <earthy> now you're even assuming ASCII :P
06:35:34 <xerox-> And it's ok :)
06:35:40 <datenmaulwurf> that's cool!
06:35:55 <datenmaulwurf> lambdabot, with which code you did it?
06:36:01 <datenmaulwurf> sry for my terrible english
06:36:07 <earthy> caesar n s = map (mapto n) s
06:36:07 <earthy> mapto n c = case lookup c $ mapping n of
06:36:07 <earthy>                 Just d -> d
06:36:07 <earthy>                 Nothing -> c
06:36:07 <earthy> mapping n = zip ['a'..'z'] (drop n ['a'..'z'] ++ take n ['a'..'z'])
06:36:11 * earthy whistles
06:36:15 <xerox-> @eval let caesar n = fmap (chr.(+ (ord 'a')).(`mod` 26).(+n).(subtract (ord 'a')).ord) in caesar 3 "abcdefghijklmnopqrstuvwxyz"
06:36:16 <lambdabot> "defghijklmnopqrstuvwxyzabc"
06:36:21 <xerox-> Ooh-kay.?
06:36:29 <earthy> no, you're still going to break on EBCDIC
06:36:39 <kzm> xerox-, nothing is trivial when there are bugs in the std libs. :-)
06:36:40 <xerox-> Who uses EBCDIC?
06:36:54 <earthy> hey, I don't. ;) but ord might.
06:36:59 <kzm> and which haskell compilers run on EBCDIC systems?
06:37:18 <xerox-> So it's enough :)
06:37:22 <earthy> nhc could conceivably be made to run on ebcdic. :)
06:38:12 * int-e wonders why Data.IntSet.split works for small numbers ...
06:38:43 <xerox-> @type Data.IntSet.split
06:38:44 <lambdabot> Int
06:38:44 <lambdabot> -> Data.IntSet.IntSet
06:38:44 <lambdabot> -> (Data.IntSet.IntSet, Data.IntSet.IntSet)
06:39:08 <earthy> that gets you nicely restricted to machine words, int-e
06:39:20 <int-e> earthy: look at the implementation of split there ...
06:39:29 <xerox-> @libsrc Data.IntSet
06:39:30 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/IntSet.hs
06:40:05 <datenmaulwurf> Main> toInt 'a'
06:40:05 <datenmaulwurf> ERROR - Illegal Haskell 98 class constraint in inferred type
06:40:20 <xerox-> @index toInt
06:40:20 <lambdabot> bzzt
06:40:22 <earthy> int-e: yes. Int.
06:40:26 <int-e> earthy: it only splits one of the two subtrees of a Node, but the splitting is not done monotonically like that ... it has to split both subtrees really.
06:40:29 <ndm> @hoogle :: Char -> Int
06:40:29 <lambdabot> Terminated
06:40:29 <lambdabot>  
06:40:31 <earthy> Int is finite-length
06:40:38 <earthy> ah, wait
06:40:42 <earthy> other problem. :)
06:40:43 <ndm> the answer is: ord
06:41:01 <int-e> it's kzm's problem.
06:44:25 <int-e> @eval Data.IntSet.split 2 $ Data.IntSet.fromList [0,1]
06:44:26 <lambdabot>  Not in scope: `Data.IntSet.fromList'
06:44:41 <int-e> --> ({0},{1})
06:45:42 <kzm> ditto for -1
06:46:10 <xerox> Off-by-one error?
06:46:21 <int-e> no
06:46:54 <int-e> bad algorithm error
06:47:32 <earthy> @eval let m = 1000000 in Data.IntSet.split (16*m) $ Data.IntSet.fromList $ map (m*) [17,18,19,30,40]
06:47:33 <lambdabot>  Not in scope: `Data.IntSet.fromList'
06:48:03 <earthy> ah, no Data.IntSet in lambdabot
06:48:09 <kzm> For {0,1}, odd numbers work, and evens don't !?
06:48:34 <kzm> i.e. split x $ fromList [0,1] works for odd, positive x.
06:49:04 <kzm> and for even negative x
06:51:44 <lisppaste2> int-e pasted "IntSet.hs split patch" at http://paste.lisp.org/display/12937
06:52:35 <xerox> :-)
06:54:26 <int-e> The point is, the IntSet data structure branches on single bits, so it's not possible to shortcut split in the way it's done with sorted trees ...
06:56:36 <int-e> hmm. that means the operation is not O(log n), though.
06:56:36 <earthy> why not?
06:57:06 <earthy> i.e.: why is it not possible to shortcut?
06:57:11 <int-e> earthy: take {0,1} - it's encoded as 'branch on the lowest bit. if it's 0, use {0}, else {1}'
06:57:25 <earthy> so, we split at 0
06:57:46 <earthy> the mask in the bin will be 00000000 (for 8-bit int)
06:57:48 <int-e> no, it splits on the LSB ... and ignore all more significant bits.
06:57:53 <int-e> the mask is 1
06:58:13 <int-e> hmm
06:58:41 <earthy> should that not be 10000000 (in base 2) then? for 8-bit ints?
06:58:45 <int-e> Ok, there's the prefix *mumbles* it should be used then - but how?
06:58:51 <earthy> or some such trick?
06:59:06 <earthy> it *is* based on being big-endian
06:59:28 <int-e> earthy: well, the branch has to distinguish 0 and 1 ... there's only one bit that does that.
06:59:36 <earthy> true
06:59:49 <vegai> gah, the cabal in ghc-6.5 adds the compiler version to the installed libraries' paths
07:00:17 <earthy> but the prefix will then be 0000000x and the mask 1111111x or not?
07:04:00 <int-e> Bin 0 1 (Tip 0) (Tip 1)
07:04:06 <int-e> prefix 0, mask 1
07:04:31 * earthy thinks
07:04:40 * xerox blinks
07:08:33 <lisppaste2> int-e annotated #12937 with "ok, this seems better :)" at http://paste.lisp.org/display/12937#1
07:10:57 <int-e> but is it correct? hmm.
07:15:08 <RemiTurk> good afternoon everybody
07:15:16 <xerox> 'noon
07:16:34 <int-e> Ah I believe it is correct. The code is careful to always split on the most significant bit, so the resulting tree is ordered.
07:16:49 * earthy nods
07:16:53 <earthy> that's what I figured
07:19:32 <int-e> hmm. well, almost - it does not handle negative numbers :(
07:21:25 <earthy> I still don't quite yet grasp the highestBitMask function
07:23:10 * joelr waves from sunny tenerife
07:23:14 <int-e> earthy: it just duplicates all bits to the right. 1 -> 11 -> 1111 -> 11111111. before the last xor, the number is of the form 0*1* (in binary)
07:23:22 <joelr> has anyone used quickcheck alot?
07:23:24 <earthy> yeah
07:23:28 <earthy> now I got it
07:23:35 <earthy> I couldn't do it off the top of my head
07:23:42 <earthy> the case structure was tricky :)
07:23:49 <earthy> I got confused by the x's
07:23:56 <earthy> but they're constantly changing
07:23:58 <basti_> are there any alternatives to concat.map for the list monad bind?
07:24:03 <xerox> joelr: no but they say it's cool - do you know anything about it?
07:24:13 <basti_> i mean, alternatives that COULD make sense ^^
07:24:35 <xerox> concat.reverse.map or reverse.concat.map ? :-)
07:24:36 <joelr> xerox: trying to use it
07:24:46 <basti_> :)
07:25:47 <xerox> Maybe some kind of fold?  8-X
07:26:13 <machack666> is `*** Error in array index' different than an `out-of-bounds' error?
07:26:33 <xerox> I'd say no, it isn't.
07:28:14 <machack666> I think I read somewhere that if you don't provide an association for an index on creation of an array, it is an error to try to replace the slot at a later time.  Is this true?
07:28:25 <machack666> if so, that might be my error
07:31:06 <earthy> okay. right. the split function only works if the prefixes are equal, but does not check that.
07:31:28 <earthy> it assumes that the prefixes are equal, by construction
07:31:54 <earthy> however, this assumption fails if a number has not been entered into the tree...
07:32:34 <int-e> well, there is splitMember, too
07:32:47 <earthy> yeah
07:32:59 <earthy> but that is my current hypothesis
07:34:36 <lisppaste2> int-e annotated #12937 with "fix for negative numbers, assumes 2's complement (but I think the whole module does that)" at http://paste.lisp.org/display/12937#2
07:37:04 <machack666> @eval let a = Data.Array.array (1,10) [] in a Data.Array.// [(4,2)]
07:37:04 <lambdabot>  Not in scope: `Data.Array.//'
07:38:01 <machack666> well, in ghci, I get two different errors depending on the case
07:38:21 <machack666> let a = Data.Array.array (1,10) [] in a Data.Array.// [(4,2)] results in a `undefined array element' error
07:38:35 <machack666> let a = Data.Array.array (1,10) [] in a Data.Array.// [(14,2)] results in a `index out of bounds' error
07:38:52 <machack666> both of which are different than the `error in array index' error
07:38:54 <int-e> earthy: there must be a different approach that explicitely checks for prefix mismatches, but that will also run into the problem of having to use that prefix for comparison with x ... it could short-circuit some of the calculation in that case though.
07:39:39 <earthy> I'm not sure my hypothesis is correct
07:40:18 <int-e> (note that the tree is, in fact, not ordered, if there are both negative and non-negative numbers - the negative numbers are in the right subtree, the non-negative numbers in the left.)
07:41:06 <earthy> as by construction the prefix *is* shared in the tree, and at the tips we check if the number is lower or higher than the number in the tree
07:41:46 <earthy> and the tree is split on bits from high to low
07:42:15 <earthy> well, trie, really
07:42:53 <int-e> well, the final leaf that we arrive at will be sorted into the correct 'half' of the result. but on the way there, the current code will sort whole subtrees into the wrong half of the result.
07:43:10 <earthy> in the case of negatives
07:43:30 <earthy> as the entire trie is in fact sorted if you look at the numbers as unsigned
07:43:52 <int-e> right.
07:44:22 <earthy> but that does not explain the result for splitting on 16m in 17m, 18m, 19m, 30m, 40m
07:47:30 <int-e> why not? as you said it's a trie, and on the way to the leaf, some bits of 16m are skipped ... apparently the final check happens in the subtrie that contains 30m and 40m ...
07:48:37 <earthy> but the trie is built as (((17 /\ 18) /\ 19) /\ 30) /\ 40
07:48:58 <int-e> m is not a power of 2
07:49:11 <earthy> int-e: I know that. :)
07:51:25 <earthy> 0000 0010 0110 0010 0101 1010 0000 0000   40m
07:51:25 <earthy> 0000 0001 1100 1001 1100 0011 1000 0000   30m
07:51:25 <earthy> 0000 0001 0010 0001 1110 1010 1100 0000   19m
07:51:25 <earthy> 0000 0001 0001 0010 1010 1000 1000 0000   18m
07:51:25 <earthy> 0000 0001 0000 0011 0110 0110 0100 0000   17m
07:51:28 <earthy> are the bitstrings
07:52:21 <int-e> for m=1000000?
07:52:28 <earthy> yup
07:54:47 <int-e> so the trie looks like this: (25:(23:(21:(20:17,18),19),30),40) (where 25: and so on are the bit numbers that are tested)
07:55:34 <int-e> and 16m has bit 25 unset, bit 23 set ...
07:56:28 * earthy nods
07:56:45 <int-e> at that point, bit 24 does not match the prefix, but the code never uses the prefix.
07:57:59 * earthy nods
07:58:48 <int-e> and thus, when it tests bit 23, it blindly puts (21:(20:17m,18m),19m) into the left half of the result.
07:59:07 <earthy> so split assumes the prefix is already in the set
07:59:35 <earthy> this can only occur on outliers for a subtree, right?
07:59:56 <earthy> my hypothesis was right. darnit. ;P
08:00:41 <int-e> sorry, outliers?
08:01:42 <int-e> Are those numbers outside of the range covered by a subtree? if yes, that's right.
08:01:48 <earthy> that is what I meant
08:04:01 <joelr> wow
08:04:03 <joelr> i'm still here
08:05:17 <earthy> smaller and clearer testcase:
08:05:31 <earthy> @eval Data.IntSet.split 2 $ Data.IntSet.fromList [4,6,8]
08:05:32 <lambdabot>  Not in scope: `Data.IntSet.fromList'
08:05:43 <earthy> grm
08:05:45 <sethk> joelr, where did you expect to be?
08:05:51 <earthy> why doesn't lambdabot have the full ghc lib? :)
08:05:59 <int-e> earthy: what didn't you like about split 2 $ fromList [0,1]?
08:06:01 <earthy> Prelude> Data.IntSet.split (2) $ Data.IntSet.fromList [4,6,8]
08:06:02 <earthy> ({4},{6,8})
08:06:09 <joelr> sethk: hehe
08:06:18 <joelr> where's that QuickCheckST paper?
08:06:38 <joelr> found!
08:06:40 <sethk> @where QuickCheckST
08:06:41 <lambdabot> I know nothing about quickcheckst.
08:06:42 <earthy> int-e: what I don't like is that it doesn't show the issue as clearly
08:07:10 <int-e> earthy: hmm. I'll admit I saw the issue first and then constructed the example *g*
08:07:32 <joelr> google has it
08:07:40 <earthy> anyway, this needs fixing. :P
08:07:55 <earthy> especially given that splitMember is also broken :P
08:08:38 <int-e> hmm. right. I initially thought it'd do something different.
08:13:32 <Philippa_> earthy: that last line was a rather wincemaking thing to read out of context :-)
08:13:42 * earthy laughs
08:13:55 <earthy> if it isn't Philippa ;P
08:15:25 <lisppaste2> int-e annotated #12937 with "same thing for splitMember" at http://paste.lisp.org/display/12937#3
08:17:39 <xerox> @hoogle OI a
08:17:39 <lambdabot> Terminated
08:17:39 <lambdabot>  
08:19:45 <lisppaste2> Earthy pasted "fix for Data.IntSet" at http://paste.lisp.org/display/12940
08:20:33 <earthy> now, where to send this patch?
08:20:42 <earthy> libraries@haskell?
08:21:10 <int-e> earthy: does that work for {0,-1}?
08:21:20 <earthy> not sure. :)
08:21:27 <int-e> earthy: test it? *fg*
08:21:35 <Lemmih> Didn't Data.IntSet get a new maintainer recently?
08:21:58 <int-e> [I did: rename the module to IntSet2, load in ghci, test ...]
08:22:08 <earthy> um, in a sense it does. :P
08:22:19 <int-e> for unsigned integers, eh?
08:22:24 <earthy> but for the fact that -1 is not unsigned :P
08:23:24 <int-e> btw, union l r  == t
08:23:32 <earthy> um... yeah
08:23:59 <earthy> it is the simple stupid fix. :)
08:29:01 <int-e> earthy: hmm doesn't x<p just work? (in the interesting case, p is 0 ...)
08:29:26 <int-e> earthy: and x is outside the range [p, p+2m-1] anyway, or the prefix would match.
08:30:24 <int-e> earthy: instead of mask x m < p, I mean.
08:30:36 <earthy> int-e: it might
08:31:11 <earthy> but that saves you one operation when you already know you are done
08:31:49 <int-e> earthy: err, ok. it does not help. I managed to confuse myself :)
08:32:49 <int-e> earthy: then I have no better idea than the explicit m<0 check that I used, too.
08:33:06 <earthy> yup, it is the only one that works
08:33:22 <earthy> it's a bit of a pity though
08:33:39 <earthy> as it really needs to be checked only *once*
08:34:07 <int-e> I know ... we could split the function into two then.
08:34:53 <int-e> one that only handles the m<0 case and one that does the rest.
08:37:06 * int-e goes idle for a bit.
08:38:13 <araujo> lisppaste2, help?
08:38:13 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:38:47 <lisppaste2> araujo pasted "parse" at http://paste.lisp.org/display/12941
08:39:13 <araujo> Someone with free time that can give me a hand with that algorithm?
08:39:53 <araujo> I want to get something like: parseAr "foo @bar 1@ @bar 2@" == ["bar 1" , "bar 2"]
08:50:00 <musasabi> It seems that http://haskell.org/ghc/dist/6.4.1/ghc-6.4.1-x86_64-unknown-linux.tar.bz2 is actually a .tar.gz file.
08:51:44 <lisppaste2> earthy pasted "Next fix for Data.IntSet: should be complete (assumes ones or twos complement)" at http://paste.lisp.org/display/12942
08:55:31 <int-e> earthy: looks good, two cosmetic nitpicks: the else in splitMember seems to be one too far to the right (or there's a tab/space problem) and splitMember' uses mask x m < p while split' uses x < p - that's slightly confusing.
08:56:06 <araujo> Anyone knows a web site containing the source of the Prelude?
08:56:52 <int-e> http://www.haskell.org/onlinereport/standard-prelude.html
08:57:32 <goron> araujo: The source is implementation independent, but implementors can use the one int-e suggested.
08:57:40 <goron> er dependent.
08:57:59 <int-e> (as explained in the first few lines of that web page)
08:58:06 <araujo> Thanks
08:58:16 <goron> int-e: indeed.
08:59:11 <earthy> owh, that might be
09:00:18 <earthy> there, all fixed now
09:00:32 <earthy> now, who are we going to hit with the patch? :)
09:01:41 <gaal> ndm: ping
09:02:24 <earthy> int-e: want credit?
09:02:56 <int-e> earthy: yes
09:03:42 * int-e still wonders where to go ... ghc bugs, http://sourceforge.net/tracker/?group_id=8032&atid=108032 ?
09:03:58 <earthy> nah, libraries
09:04:14 <earthy> it's not just ghc, as the hierarchical libs are used by hugs as well, right?
09:04:23 <earthy> at least, the code seems to suggest so
09:08:13 * int-e is clueless.
09:11:56 <micket> Hello guys! My tutor seems to have a problem with a small program i've written. He claims he is getting "ERROR - Garbage collection fails to reclaim sufficient space". He doesnt give me more information than this. What causes such errors? Is it a hugs or ghc error?
09:12:22 <int-e> it's Haskell's way of saying 'out of memory'
09:12:47 <xerox> (It's probably an Hugs error.)
09:13:03 <micket> And way of meassuring the memory usage (max) of my program?
09:13:20 <basti_> profile it
09:13:21 <micket> And i'm using Fedora 4
09:13:34 <basti_> you'll probalby need a special profiling package
09:14:05 <micket> Ok, any more directions before i start to wildly google for it?
09:14:24 <basti_> i dont know the package name on fedora4
09:15:03 <micket> ah ok so its completely haskell unrelated?
09:15:41 <earthy> um, no
09:15:41 <earthy> :)
09:15:52 <micket> ok >_<
09:16:02 <basti_> lol
09:16:26 <xerox> Debian has: ghc6-prof - Profiling libraries for the Glasgow Haskell Compilation system
09:16:28 <earthy> profiling support is part of ghc
09:16:45 <earthy> but you'd need a Fedora 4 package of that profiling support to be able to use it :)
09:17:07 <int-e> ah it's a hugs error indeed.
09:17:14 <micket> I seriously doubt my program uses more than.. oh 20 megs or ram at most
09:17:27 <micket> stupid tutor..
09:19:30 <Cale> what's the program do?
09:19:40 <thedward> I'm constantly amazed at how much RAM seemingly simple stuff takes in HUGS
09:21:49 <micket> It fins the fastest route through a network of trams (given a whole bunch of timetables)
09:23:26 <roconnor> @hoggle debug
09:23:27 <lambdabot> Terminated
09:23:27 <lambdabot>  
09:23:31 <roconnor> :-(
09:23:44 <roconnor> @info debug
09:23:45 <lambdabot> Unknown command, try @listcommands.
09:23:49 <micket> google told me i wanted ghc-prof, http://www.haskell.org/fedora/haskell/4/i386/ and i found this. yay i thought! But i use version 6.4, and this one cant locate the package ghc-622. Do i really need to downgrade to that version?
09:27:25 <rodador> (not trolling) what's the URL of a tiny real world open source haskell project?
09:27:39 <rodador> i'm taking classes of haskell at uni but i would like to see a real world example
09:27:40 <xerox> @where nymphaea
09:27:41 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
09:27:48 <Cale> :)
09:28:12 <rodador> i only see the axiomatic definition of natural numbers and things like that (interesting, anyway)
09:28:20 <rodador> xerox: thanks
09:28:29 <bringert> rodador: darcs is a real word project, but hardly tiny
09:28:34 <xerox> Yeah :)
09:28:35 <Cale> rodador: Haskell is quite a practical language actually :)
09:29:17 <Cale> It's just that it's also practical for mathematical things, which is nice in CS courses, but doesn't show that it can actually be useful too :)
09:29:35 <bringert> rodador: do you want to just see an example of haskell code? or a fully-fledged open source project, but with very little code?
09:29:57 <rodador> bringert: both things would be nice
09:30:12 <xerox> rodador: see the pm.
09:30:30 <rodador> xerox: "pm." ?
09:30:41 <xerox> Private messages :)
09:30:49 <rodador> xerox: ouch, ok, sorry :-)
09:31:01 <xerox> np :)
09:31:26 <gour> xerox: that 'darcs get ..' line is still stretching into right-side menu on konqi
09:31:40 <xerox> gour: a new site is in beta ;)
09:33:15 <gour> xerox: great, with epiphany is better, opera - ok - actually the line comes under the right-menu, like \vskip
09:33:27 <bringert> rodador: darcs is the canonical example of an open source project using haskell, but it is quite large
09:34:00 <rodador> bringert: yes, i see
09:34:29 <bringert> rodador: if you just want real haskell code, you may want to look at some haskell libraries. the standard libraries have implementations of data structures and the like.
09:35:34 <bringert> there are also lots of projects writing libraries for various things. some that I have written / am involved in: HaskellDB (db interface), HaXR (XML-RPC interface), CGi and FastCGI libraries, date parsing
09:35:37 <rodador> i browsed sourceforge haskell software map
09:36:25 <rodador> ah, yes, i saw haskelldb
09:36:35 <bringert> Grammatical Framework is a large (natural) language processing program written in Haskell: http://www.cs.chalmers.se/~aarne/GF/
09:36:38 <ndm> gaal: pong
09:36:47 <rodador> i find Nymphaea interesting
09:37:08 <bringert> rodador: have you seen the Haskell Communities and Activities Report
09:37:08 <bringert> : http://haskell.org/communities/
09:37:25 <rodador> nope, thanks
09:37:26 <xerox> rodador: thanks! :-D
09:37:56 <xerox> rodador: ideas/patches are welcome ^_^
09:38:05 <gaal> ndm: heya :) just wanted to see if hoogle can use my help
09:38:26 <ndm> gaal, i've done lots of work - hoogle3 is almost ready
09:38:33 <ndm> it at http://www.haskell.org/hoogle
09:38:37 <ndm> but strictly as an alpha
09:38:50 <Cale> xerox: making the menus do something would be a good idea :) we should really do that, or hide them for now
09:39:00 <xerox> Right.
09:39:11 <gaal> cool! alpha's great
09:39:11 <xerox> Anybody willing to do that? :D
09:39:51 <ndm> i have a todo list at http://www.haskell.org/hawiki/Hoogle
09:40:03 <ndm> some of them are already done, others not as much
09:40:12 <ndm> its mainly fiddly little things now
09:44:02 <micket> this isnt my day.. ghc-prof rpm crashes
09:45:23 <chucky_> micket: If it's a hugs error, why not try using hugs, and try to find why it crashes?
09:46:13 <chucky_> since ghc does things differently than hugs, you might not be able to find anything worthwhile by using ghc to profile
09:47:50 <gaal> ndm: this is great :)
09:48:31 <ndm> thanks :), and thanks for your help as well
09:49:01 <gaal> my pleasure :)
09:51:13 <dcoutts> dons, you about?
09:53:24 <micket> Ok. It seems Hugs first takes forever to load the file with all my data in, then it runs out of memory
09:53:42 <micket> what would i even do about that?
09:54:17 <SyntaxNinja> micket: tried ghc?
09:54:45 <micket> yes it works fine.
09:54:55 <micket> But it seems my tutor wants to use hugs.
09:55:18 <chucky_> your lab should work in hugs
09:56:07 <SyntaxNinja> strange. what version of hugs? there may be some bug
09:56:28 <micket> ghc 6.4.1
09:56:30 <SyntaxNinja> micket: is it a huge amount of data?
09:56:33 <micket> and latest of hugs
09:56:41 <micket> Ill see how big the file is
09:57:04 * SyntaxNinja just got here, so sorry if I'm missing context
09:57:20 <ndm> windows or linux?
09:57:27 <MarcWeber> Having a function a -> b -> result, How can I tell haskell that a should be of type RandomDistribution and b should be of type StdGen?
09:57:54 <micket> Linux, fedora 4
09:58:05 <micket> The file i read in is 128K
09:58:32 <micket> and it's the actual datatype i use written down as a list
10:00:34 <micket> hugs crashes before the actaul work is done in the program as well. It doesnt go further than to look if the input from the user is in the list of my data.
10:00:50 <micket> which never have taken more than a fraction of a second to check in ghc
10:01:38 <rodador> argh, always opening my mind with haskell..
10:01:53 <rodador> used to yacc.. no! here they use http://www.cs.uu.nl/people/daan/download/parsec/parsec.html
10:01:57 <rodador> :-)
10:02:14 <Cale> MarcWeber: f :: RandomDistribution -> StdGen -> result
10:02:41 <Cale> whatever type "result" was -- it can't be usefully polymorphic here I don't think
10:02:49 <chucky_> rodador: How do you get "used to" yacc? I've always found it to be rather frustrating to work with. :)
10:03:01 <MarcWeber> Cale: Oh. And the => syntax is then used if you need a type more than once?
10:03:27 <rodador> chucky_: two compilers courses using it.. *sigh*
10:03:34 <Cale> MarcWeber: no, => applies typeclass constraints to the type variables
10:03:56 <chucky_> rodador: ah. :) But Parsec is *much* easier. Took me about an afternoon to learn
10:04:05 <Cale> MarcWeber: for instance (Ord a) => [a] -> [a] means that a is any type with an ordering (which means that < and so on are defined)
10:05:42 <MarcWeber> Cale: Then can I write this: (RandomDistribution rd, StdGen g) => rd -> g -> result?
10:06:11 <Cale> Is RandomDistribution a class?
10:06:20 <Cale> StdGen isn't a class
10:06:29 <Cale> You'd want RandomGen, I think
10:06:31 <MarcWeber> Yes, it is
10:07:08 <SyntaxNinja> rodador: if you want something more like yacc, there's happy, which is quite nice.
10:07:16 <Cale> also, "result" being lowercase, means any type at all, which I don't think you want
10:07:24 <Cale> you couldn't write a useful function of that type
10:08:55 <Cale> MarcWeber: perhaps just try writing your function and seeing what ghci/hugs infers
10:09:10 <Cale> by using ":type myFunction"
10:10:59 <rodador> gonna eat something.. bye and thanks!
10:11:26 <MarcWeber> Cale I want to implement a function returnnig random values but where you can set the relative prorability of each item. I'm thinking of randomRDist array 2 [(True,1),(False,2)} mkStdGen returning False twice as often as true. I'll do this
10:11:51 <Cale> MarcWeber: I wrote some code to do that not so long ago
10:12:26 <MarcWeber> Cale May I learn from your code?
10:12:54 <Cale> http://www.haskell.org/hawiki/MonadTemplateLibrary_2fMonadRandom -- sorry if you don't know much about monads yet :)
10:13:07 <Cale> fromList at the end is what does it
10:13:22 <MarcWeber> We will see.. ;)
10:13:37 <Cale> you should be able to do something like:
10:13:41 <Cale> g <- newStdGen
10:13:53 <Cale> evalRand (fromList [...]) g
10:14:10 <Cale> where [...] is the list of values with their weights
10:14:52 <micket> sigh.. im getting depressed. What should i do about this crash in hugs? All it should do is compare a string to a one part of a datatype in a list of say, 30 in total? It works fine in haskell, doesn't use noticeble amount of ram and takes a fraction of a second?
10:15:05 <ibid> interesting stuff that google brings one: http://www.geocities.com/Heartland/Prairie/3735/ :)
10:15:06 <Cale> micket: can I see?
10:15:41 <micket> Sure. http://www.micket.com/ <-- That's all the files. TramTime.hs has the main function.
10:16:41 <Cale> ibid: :) I like the little piece of music
10:17:15 <Cale> micket: where does it seem to chew memory?
10:17:31 <micket> After asking about the departure station
10:17:36 <micket> thats when confirmStation is run
10:18:00 <SyntaxNinja> micket: what's the error you get?
10:18:02 <micket> And due to the laziness that's when the file is read as well i guess, since it's the first time it's acutally used.
10:18:18 <Cale> micket: yes
10:18:46 <Cale> SyntaxNinja: his tutor gets "GC failed to reclaim sufficient space"
10:18:58 <micket> "ERROR - Garbage collection fails to reclaim sufficient space"
10:19:10 <dcoutts> that's an error from hugs
10:19:17 <micket> Yup.
10:19:18 <Cale> right
10:19:29 <Cale> apparently the code runs okay in GHC
10:19:37 <dcoutts> hugs has a small heap
10:19:58 <micket> at least it does for me and a friend who tested it just a while ago, using an older version of ghc.
10:20:10 <dcoutts> though I suspect it may still be a problem with the prog if it's using that much heap
10:20:39 <micket> I formatted the data to my datatype and wrote it to a file using another program
10:21:00 <micket> this program simply reads that file, which contains a list of the actual datatype used directly
10:21:06 <micket> And it's just 128 kb
10:21:24 <xerox> @index integerDivision
10:21:25 <lambdabot> bzzt
10:22:37 <chucky_> I would like to remind people that this is a lab in a course. In other words, help him but don't give him the solution (because that would be cheating)
10:23:05 <chucky_> and since I'm a tutor in the course, cheating right now would probably be a bad idea. :)
10:23:56 <micket> Trust me i'm certainly not asking for that. But now that you mention you are a tutor how about some help ;)
10:23:58 <SyntaxNinja> @wiki HomeworkHelp
10:23:59 <lambdabot> http://www.haskell.org/hawiki/HomeworkHelp
10:24:00 <Cale> micket: furthermore, it says that without actually consiming all that much memory
10:24:20 <SyntaxNinja> chucky_: those are the guidelines that this channel follows.
10:24:36 <SyntaxNinja> chucky_: if you see someone step over the line here, go ahead and point it out, but I've rarely, if ever, seen it.
10:24:54 <SyntaxNinja> students often try to get answers out of us, though.  some have even offered cash ;)
10:25:03 <chucky_> I know. :)
10:25:05 <bringert> I used to be chucky's tutor once upon a time. anyone here who's been my teacher?
10:25:40 * bringert is trying to get a degrees of separation thing going
10:25:51 <micket> I'm actaully a programming tutor myself.
10:25:55 <micket> for M1
10:26:00 <micket> (not in haskell)
10:26:24 <bringert> maybe we can find a cycle
10:27:17 <Cale> ah
10:27:29 <chucky_> micket:  Have you tried moving station.data into your haskell code instead of reading it as a file?
10:27:39 <Cale> it works if you increase the hugs heap size a bit
10:27:52 <micket> how do i do that?
10:28:05 <dcoutts> man hugs
10:28:11 <Cale> hugs -h10M TramTime.hs
10:28:23 <micket> chucky_ It would be a rather ugly sullotion if you ask me. I have a separate program that generates this data given the timetables formatted in such a way given in the lab-pm
10:28:46 <chucky_> micket: I know, but you could try it to see if that works
10:29:22 <micket> Ok, then there is another problem, a 128 k file, using one row. I've tried to paste that in a whole lot of editors before, they all crash
10:29:25 <Cale> 250k is the default value. 1M is insufficient
10:29:28 <Cale> 2M seems to work
10:29:45 <Cale> micket: vim handles it okay
10:30:03 <micket> I started learning vim today :)
10:30:58 <micket> Hmm.. Is hugs alot slower than ghc in general?
10:31:06 <micket> becuase it sure takes alot longer time
10:31:31 <Cale> yeah
10:32:13 <micket> Ok.
10:32:16 <Cale> yeah, it is a lot slower in hugs :)
10:32:34 <Cale> just tell your tutor to give it some more heap
10:32:44 <micket> I will! thanks alot Cale
10:32:51 <Cale> np
10:34:47 <Cale> btw, don't ever try -H100M unless you have a lot of memory. It quickly consumed 750MB of ram on my system, and pushed everything out to swap, then thrashed a bit before hugs got killed :)
10:35:06 <chucky_> ha ha
10:36:10 <chucky_> another good tip is to always press ctrl-c *before* starting to fix recursion bugs. Otherwise, you'll forget an instance of ghci that eats up all resources and causes your computer to more or less hang (trust me, I've tried)
10:39:16 <micket> B.t.w chucky. I ended up resubmitting this lab 3 times, everytime getting higher demands on the documentation requiered. I think the lab-pm is lacking, since the submission part doesn't even specify the need for a seperate technical manual explaining the algorithm used. Is this something all of the tutors demanded on this lab?
10:40:32 <shapr> I have a strange question... I defined a simple arbitrary instance for data Tree a = Nil | Node (Tree a) a (Tree a) deriving (Eq,Ord,Show), and prop_Tree   :: Tree a -> Bool ; prop_Tree x = True . When I run quickCheck prop_Tree, I get "no Show instance IO ()"
10:41:13 <shapr> My question, is there some way to generate a type random via an Arbitrary instance?
10:42:01 <chucky_> micket: I'll side-step your question by saying that there is no separate documentation regarding how the lab should be corrected, apart from the lab-pm. Which means (more or less) that we can put any additional requirements that we think should be there
10:42:20 <shapr> I can think of a cheesy implementation that would use Data.Typeable and a list of Strings containing type names.
10:42:40 <shapr> But how would I then get a QuickCheck property like the one above to actually work?
10:43:27 <shapr> Let's say I wanted to test associativity of addition for any type, how could I randomly generate types in some way that I could actually use?
10:43:49 <shapr> Should I ask this on the mailing lists instead?
10:45:12 <shapr> I wonder if there's some cheesy phantom types trick I could use for this.
10:45:34 <shapr> dons: Can hs-plugins eval types?
10:45:46 * shapr wonders fruitlessly
10:46:28 * gour can only say 'bok' to shapr
10:46:34 <shapr> bok gour
10:46:39 <MarcWeber> Cale: I get this error: http://www.rafb.net/paste/results/ZUwWA675.html
10:46:46 <gour> we missed you
10:47:00 <shapr> I have snow, and a unicycle :-)
10:47:12 <gour> shapr: yesterday there was 206 souls here
10:47:14 <shapr> And about two months worth of work to finish in the next month.
10:47:17 <shapr> wow, cool!
10:47:33 <gour> shapr: we have almost summer here - 20C - t shirts :-)
10:47:45 <micket> chucky_: That really doesn't sound like a good way though if you ask me. It kind of kills the purpose of a lab-pm.
10:47:53 * Oejet has neither. :-(
10:48:06 <shapr> gour: It's -8C here.
10:48:42 <gour> shapr: only  28C difference :-)
10:48:46 * shapr grins
10:49:08 <cooz> its -12C here :)
10:49:34 <gour> cooz: where r u?
10:49:39 <shapr> Seb: Are you sebc?
10:49:53 <roconnor> shapr, i need wiki help.
10:49:53 * Oejet was in a Russian sauna; very moist and 90C.  Almost boiling you. :-)
10:49:54 <cooz> gour: in finland
10:50:05 <Seb> shapr: nope
10:50:12 <Seb> shapr: i'd be sebd, if anything ;)
10:50:20 <chucky_> micket: Perhaps. I'm not saying I agree or disagree with you, but the lab pm:s are not my responsibility. And Chalmers doesn't pay me enough for me to try to fix things that are not my responsibility
10:50:22 <shapr> Seb: ok, merci :-)
10:50:27 <shapr> roconnor: Of what sort?
10:50:30 * gour concludes that shapr has a warm weather in comparison with cooz
10:50:31 <Seb> shapr: haha, de rien
10:50:51 <roconnor> shapr, I need my account password reset or something like that.
10:50:57 <shapr> ah, ok
10:51:04 <roconnor> RussellOconnor
10:51:31 <gour> cooz: man haskellers there?
10:51:40 <chucky_> micket: So I urge you to contact John or write in the course evaluation if you think the lab pm:s are not specified well enough
10:51:52 <shapr> roconnor: Oh I found your blog, it's nice. I'm going to try out Tor Hidden Services this weekend.
10:51:55 <micket> I'm currently emailing him about it in fact.
10:52:05 <roconnor> ;-)
10:52:13 <micket> For now it seems he solved the problems by not answering them though.
10:52:22 <gour> shapr: how your unicycle likes snow?
10:52:28 <roconnor> I've never used any hidden services myself.
10:52:31 <cooz> gour: I don't know anyone, but probably there are more than me :)
10:52:39 <roconnor> maybe I looked at the Hidden Wiki.
10:52:42 <SyntaxNinja> shapr!
10:52:44 <gour> cooz: same here :-(
10:52:54 <chucky_> micket: Be patient. John gets a lot of e-mail
10:53:31 <shapr> gour: It's okay, but I wish for a larger tire. My three inch tire was suppossed to be temporary. I haven't been able to afford the 3.7 inch tire yet though.
10:53:41 <shapr> hiya SyntaxNinja!
10:53:43 <roconnor> *sigh* I'm screwed.  My algorithm is bad.
10:54:04 <shapr> roconnor: But at least you know... if you were writing this in C, it would have taken you much longer to figure that out!
10:54:04 <micket> I could imagine. But it isn't the first time. Since i'm not a dtek student i asked how to do about the lab-trading for gnomish mines, never got a reply to that until the second email a week later.
10:54:18 <roconnor> thanks shapr.
10:54:36 <roconnor> writing this in C would have totally sucked.
10:54:51 <roconnor> even writing in ML would suck a little.  I can't imagine life without streams.
10:54:56 <shapr> gour: I still have some trouble on the soft snow, I hope the larger tire will fix that.
10:55:28 <shapr> Are there a standard set of equations to calculate 'contact patch' from volume, pressure, and weight?
10:55:30 <gour> shapr: i cannot even imagine driving at all .-)
10:55:51 <shapr> Maybe I should ask that on #physics
10:56:12 <gour> shapr: i think haskellers know everything
10:56:27 <gour> shapr: but i'm not the one (yet)
10:56:33 <shapr> I admit, this is the most informative channel I've founded^H^H
10:56:46 * gour lol
10:57:05 <shapr> cooz: Kemi? Rovaniemi?
10:58:28 <roconnor> shapr, What do you have to do to reset my password?
10:58:49 <shapr> roconnor: Wait for me to fix it, it's in progress.
10:59:00 <roconnor> okay, will wait.  Thanks.
10:59:31 * roconnor thinks about how screwed he is
10:59:38 <shapr> What's the problem?
11:00:05 <frederik2> at UCL when I turn in homework, i have to fill out and attach a cover-sheet, partly so that i can sign each assignment to say that it wasn't plagiarized
11:00:09 <frederik2> how common is this?
11:00:13 <roconnor> I'm trying to compute exp (1/3)
11:00:25 <roconnor> withing 10^-1000
11:00:34 <roconnor> using diadics
11:00:51 <roconnor> Sorry Dyadics
11:00:58 <roconnor> Dyadic rationals {a / 2^b}
11:01:14 <MarcWeber> Cale: Thanks I'll try to understand your code at home.. bye
11:01:17 <frederik2> i also have to hand it in to a secretary, there is no e.g. slotted box to put it in for "accountability reasons"
11:01:45 <frederik2> apparently most other british universities are like this but i'm wondering about europe
11:02:04 <roconnor> so the first thing I do is approximate 1/3 as a dyadic
11:02:25 <_astrolabe> shapr: In the high pressure & small weight limit, contact patch area = weight / pressure
11:02:31 <roconnor> and I get 50449019....2315 * 2^-6000
11:02:47 <roconnor> this 50449019....2315 is some huge number
11:03:05 <Oejet> frederik2: In DK we typically sign reports and handins, but there is really no reason to explicitly state that the normal rules have been followed, which is just assumed by all parties.
11:03:06 <roconnor> then I try and raise that to 366
11:03:19 <roconnor> (50449019....2315)^366
11:03:43 <roconnor> I do this because I need 366 terms in the taylor series.
11:03:47 <roconnor> or there abouts.
11:04:07 <roconnor> anyhow, this is all very slow.
11:04:12 <frederik2> maybe i can write a script using latex which fills out the cover-sheet with an image of my signature. still, it just seems pointless. we had to sign a thing about plagiarism when we got here
11:04:21 <roconnor> because I need only the most signfigant bits out the end.
11:04:22 <basti_> roconnor: integral numbers or fractions too?
11:04:35 <roconnor> just integeral numbers
11:04:37 <basti_> thought about using floats btw? ^^
11:04:40 <shapr> _astrolabe: Will that work for finding the difference in contact patch between a 3" and 3.7" tire for 93 kilos? Any idea how I can calculate the area needed to support 93 kilos on snow?
11:04:46 <roconnor> I have another implemenation that uses rationals
11:04:48 <basti_> "Integer" is a type of arbitary precision integers
11:04:56 <roconnor> In that case 1/3 is directly representable.
11:05:04 <roconnor> I need only compute 3^366
11:05:26 <_astrolabe> shapr: What pressure?
11:05:26 <Oejet> Why do I think that Danes are just generally more reasonable than the rest of the world?  Is it ego?
11:05:29 <basti_> @plugs 3^366
11:05:29 <xerox> @eval 3^366
11:05:33 <gour> shapr: by experiment :-)
11:05:36 <xerox> Woot.
11:05:46 <chucky_> frederik2: At Chalmers (in Sweden) you normally sign all things that are handed in on paper. But most things are handed in via the web these days
11:05:47 <basti_> xerox: stereo morons
11:05:53 <xerox> basti_: haha.
11:06:07 <shapr> _astrolabe: Your choice, anywhere from 10psi to 60psi. I tend to run about 20psi for easy jumps though.
11:06:08 <basti_> where is lambdabot?
11:06:12 <shapr> @hello
11:06:25 <basti_> roconnor: what we wanted to say, typing "3^366" will already suffice to compute 3^366
11:06:48 <vegai> he's behind a split
11:06:52 <vegai> (or she, whatever)
11:06:58 <_astrolabe> shapr: thats really low.  My sum is for hard ground.  How much do you sink into the snow?
11:06:59 <basti_> ah
11:07:41 <shapr> _astrolabe: lower pressure gives higher area of contact, makes it easier to float over mud & sand... and snow also, I hope.
11:07:46 <basti_> don't forget that compressing snow is plastic!
11:07:53 <basti_> you'll lose energy when you do
11:08:51 <_astrolabe> shapr: I think it will depend a lot on the snow texture.  I can imagine you up to your neck :)
11:08:55 <shapr> I don't really mind, I just want to chase snowmobiles on my unicycle.
11:08:57 <roconnor> basit_: ?
11:09:01 <_astrolabe> LOL
11:09:15 <basti_> ah
11:09:25 <basti_> roconnor: start ghci, type "3^366"
11:09:31 <roconnor> yes
11:09:33 <roconnor> I can do that
11:10:03 <basti_> so wheres the problem?
11:10:08 <roconnor> but when i approximate 1/3 by a number of the form {a/2^b}, a can be really big
11:10:10 <shapr> _astrolabe: Well, assuming hard ground, will the formula above give me a rough idea of the contact patch difference?
11:10:19 <frederik2> i'm starting to see the good side of the US. i mean, there are tons of lawyers which looks bad, but at least people realize that you don't have to sign all your homework to be punishable for plagiarism. and it's a consumerist culture, but at least they have decent customer service
11:10:21 <basti_> hmm
11:10:23 <roconnor> and then a^366 is slow
11:10:26 <basti_> too big?
11:10:31 <basti_> probably yes
11:10:32 <roconnor> not too big
11:10:38 <Maddas> frederik2: I've never had to sign anything.
11:10:39 <roconnor> I don't crash
11:10:46 <frederik2> Maddas: where?
11:10:51 <roconnor> it just take 100 longer than you'd want.
11:10:55 <basti_> hmm
11:11:00 <_astrolabe> shapr: the formula above doesn't include the tyre width, so it would say no difference.
11:11:03 <Maddas> (Hand-ins or reports, that is, I do have to sign large exams)
11:11:06 <roconnor> really I just need the top bits.
11:11:11 <Maddas> frederik2: Switzerland
11:11:16 <shapr> _astrolabe: weight stays constant, pressure can range from 10 to 60 psi, it's the difference in tire size that I want to measure.
11:11:22 <integral> homework doesn't count for anything for me, so no need to sign it
11:11:28 <_astrolabe> shapr: which would be wrong for low pressure tyres.
11:11:44 <cooz> shapr: oulu
11:11:44 <shapr> _astrolabe: Any idea how I can factor tire volume into that equation?
11:11:50 <frederik2> Maddas: where in Switzerland?
11:11:53 <roconnor> so I need to truncte my number, before multiplyig.
11:11:56 <_astrolabe> shapr: let me think a mo.
11:11:56 <Maddas> frederik2: ETH Zurich
11:12:06 <frederik2> Maddas: do you have to speak German for that?
11:12:07 <Maddas> frederik2: I'm just in the third year, though, so I've never actually written any large reports yet :-)
11:12:08 <roconnor> But I was trying to avoid that sort of work.
11:12:09 <shapr> cooz: Ah, you're south of me. Do you know XTL? He's in Oulu also. Oh, and I think Erno Kuusela is there these days.
11:12:39 <Maddas> frederik2: Yeah, you do need to at least understand German.
11:12:42 <shapr> I haven't been to Oulu in years. It's a nice town. I'm tempted to visit.
11:12:59 <cooz> shapr: ohh, erno is my workmate :)
11:13:04 <frederik2> Maddas: what's the networking policy like? here everything is done through a Cisco VPN. it's a pain in the ass. my laptop is not supported
11:13:09 <Maddas> Cisco VPN :-)
11:13:27 <shapr> cooz: Say hi from shapr, and tell him that I want to do Pair Programming again sometime :-)
11:13:30 <Maddas> How is it not supported? The wireless card?
11:13:57 <frederik2> Maddas: no, well there is a debian client, but our IS department only gives a configuration file for the proprietary client
11:13:59 <roconnor> Hmm, Now that I'm logged into the wiki, the edit icons are gone.
11:14:15 <frederik2> Maddas: and the debian client doesn't support obfuscated passwords, which are contained in their configuration file
11:14:15 <roconnor> ah
11:14:19 <roconnor> got them back
11:14:38 <cooz> shapr: heh, okay, i will say..
11:14:40 <Maddas> frederik2: Ouch. It isn't that bad here, I'm not sure of the details, but there's definitely a client (at least one) for Linux.
11:15:00 <shapr> cooz: Where do you work? If that's not confidential information...
11:15:09 <frederik2> Maddas: yeah, that's what they say too. but you have to be intel redhat, certain kernel. i'm running linux on powerpc.
11:15:20 <Maddas> Ah.
11:15:38 <Maddas> The student shop also sells laptops that dual-boot Windows and Linux, and they usually make sure that any required software is available for Linux as well as for the Windows part.
11:15:43 <Maddas> (Debian, for that matter)
11:16:17 <frederik2> Maddas: that's nice. still, would be better without proprietary protocols. i don't see the point, really, network bandwidth is so cheap and it's easy to limit wireless users
11:16:25 <cooz> shapr: at university, doing some research stuff..
11:16:27 <Maddas> frederik2: There's also a web-login thing now that you can use instead of the Cisco VPN client. I'm glad, the client tends to be a pain in the ass for me :-)
11:16:50 <shapr> cooz: In that case, I tried to persuade Erno to rewrite the second version of your research stuff in Haskell, using QuickCheck :-)
11:16:59 <frederik2> i just read this today: http://www.srcf.ucam.org/~hmw26/newnham.txt
11:17:06 <frederik2> depressing account of networking at a college in cambridge
11:17:17 <shapr> cooz: I still think that approach would beat the tar out of your current Java based solution.
11:17:42 <Maddas> frederik2: ...wow. One GB per *term*? One GB per hour I might understand :-)
11:17:49 <cooz> shapr: Why do you belive that we have java solution? ;)
11:17:56 <frederik2> it refers to this: http://www.cam-info.nrsmith.me.uk/cam-info/Colleges - which I'm partly responsible for, i did some research when i was applying
11:17:57 <xerox> Woot, we'll get Mr. Mandelbrot stomping his feet on Adam Smith in some days, in Italy!
11:18:01 <shapr> cooz: I read the research papers.
11:18:05 <integral> that's just one college though.  All the colleges set their own limits
11:18:16 <Maddas> frederik2: We have unrestricted access.
11:18:30 <Maddas> (The bandwidth is capped, but at something way over 1MB/s)
11:18:35 <cooz> shapr: aa, you are reading some old paper? we are using python currently..
11:18:58 <shapr> cooz: Well, that's better. But you should read the QuickCheck papers to see why I suggest it.
11:19:04 <frederik2> Maddas: that's good. some of the cambridge colleges are good, but unfortunately most students don't think to research the situation before going
11:19:09 * xerox melts
11:19:22 <micket> What does this mean? I can't even tell if its a warning or an error or just some information
11:19:23 <micket> TramTime.o(.rodata+0x7d0): In function `r3jT_srt':
11:19:26 <micket> : undefined reference to `TestziQuickCheck_oneof_closure'
11:19:29 <Maddas> frederik2: Well, I don't think I'd change university only because of bandwidth limits anyway :-)
11:20:01 <frederik2> Maddas: ... and then they find that their internet connection is much worse than their DSL at home
11:20:03 <shapr> micket: You need to link with whatever lib has Test.QuickCheck... libHSbase?
11:20:07 <chucky_> micket: It's a linking error. Try deleting all .hi and .o-files and recompiling
11:20:10 <chucky_> or use --make
11:20:48 <frederik2> Maddas: it's not just limits, it's being fined 20 pounds for using 50p worth of bandwidth over the limit, for instance, or not being able to run a web server or use a wireless access point or use skype etc.
11:21:02 <Maddas> frederik2: That does sound rather horrible.
11:21:10 * Maddas reads the link
11:21:23 <integral> frederik2: that's only one college though.   Both of my colleges (Christ's and Westminster) aren't *that* bad
11:21:44 <frederik2> integral: yeah, i'm vaguely familiar with a lot of them
11:22:05 * xerox melts again
11:22:23 <integral> and looking at yesterday's network stats, king's college transferred 120GB
11:22:35 <frederik2> integral: some, for instance, would consider having to log in to the network every time you wake up your laptop "not *that* bad" - but it's still damn annoying
11:22:58 <Maddas> integral: Heh, do you consider that much or little?
11:23:02 <frederik2> integral: and probably indicative of a poor administrative situation
11:23:05 <integral> frederik2: I didn't need to do that at christ's,  they just do DHCP
11:23:14 <integral> frederik2: and no objection to inbound connections either.
11:23:45 <frederik2> http://www.cam-info.nrsmith.me.uk/cam-info/QuickReference
11:23:47 <integral> Maddas: that's the top of the list of all departments and colleges, so a lot ;-)  The whole uni transfers about 2TB a day
11:24:31 <integral> umm, that grid's not very well filled in to draw any conclusion from...
11:24:39 <frederik2> integral: then fill it in
11:24:42 <Maddas> integral: Wow, I wouldn't consider 120GB to be much. For ten to twenty people, maybe, but not for a college :-)
11:24:42 <micket> when i used ghc --make TramTime.hs all i got was an a.out file.. ?
11:24:47 <Maddas> integral: I'm really spoiled, though.
11:25:19 <frederik2> integral: i think i put King's and Trinity Hall on my app, which seemed the best from those pages
11:25:33 <Oejet> integral: 120 GB per day, right?
11:25:40 <integral> Oejet: yeah
11:25:44 <integral> that was yesterday's number.
11:26:17 <integral> I have no idea how I'd transfer 120GB/day by myself, Maddas  :-/
11:26:20 <frederik2> from the newnham thing: 'The college has also been widely disseminating official college
11:26:23 <frederik2> documentation which describes the use of network bandwidth as an
11:26:26 <frederik2> "egoist" activity.'
11:26:34 <chucky_> micket: That's the executable file. You can change it with "-o fileName"
11:26:44 <frederik2> xerox: why are you melting?
11:27:04 <xerox> We'll get Mr.Mandelbrot here for a conference on ECONOMICS!
11:27:06 <sethk> micket, that's standard unix compiler behavior
11:27:16 <xerox> He's going to stamp his feet on Adam Smith loudly!
11:27:20 <Maddas> integral: Oh, me neither, but first-semester students tend to go crazy downloading stuff in the beginning.
11:27:41 <frederik2> "damn egoists"
11:27:51 <integral> Maddas: sure, but for a 60 day term, that's 7.2TB and I just don't have that much disk space with me
11:27:57 <Maddas> :-)
11:28:04 <integral> newnham is not on the whole very representative of anything ;-)
11:28:04 <Maddas> Apart from downloading linux iso files, it's quite handy to have speedy internet access for that.
11:28:19 <int-e> integral: surely your /dev/null is big enough *g*
11:28:33 <frederik2> finally someone points it out
11:28:37 <Oejet> xerox: Ah, you mean _the_ Adam Smith?
11:28:57 <micket> chucky_ sethk, ok thanks!(I'm actually new to linux as well as you might tell)
11:29:17 <xerox> Oejet: Yessir.
11:29:19 <Maddas> integral: My estimates may be totally off, of course
11:29:20 <frederik2> xerox: reference? is it anything new? some secret discovery? or what?
11:29:49 <integral> hmm, I think I remember a gentoo developer here saying they did about 900MB/day (but they got tutorial permission first ;-)
11:30:41 <frederik2> to avoid being fined, or to avoid having their connection throttled?
11:31:26 <integral> christ's is fines only.  at about the same tarriff as Churchhill I think
11:31:31 <xerox> frederik2: i'll tell you in a little while
11:31:39 <frederik2> because BT doesn't ever fine me. i don't think. it's just, you can't get DSL in the colleges
11:32:03 <integral> frederik2: BT in cambridge? golly, you must really hate NTL's service ;-)
11:32:11 <frederik2> whatever
11:32:16 <frederik2> i'm in london
11:32:22 <shapr> How is it?
11:32:27 <frederik2> ok, for the most part
11:32:37 <frederik2> but customer service here sucks, and networking at UCL sucks
11:32:48 <shapr> Mooch off wireless links?
11:32:50 <integral> oh, sorry, I assumed you were in Cambridge since you seemed to know everything about the internet setup here
11:33:06 <frederik2> no, i was just applying since my advisor is moving there
11:33:15 <frederik2> so i had to choose a college and that is how this whole thing started
11:33:31 <frederik2> anyway, maybe i'll do my phd in the states. haven't decided
11:33:33 <_astrolabe> shapr: my best guess is that that formula is not too bad for a hard surface, and that the area in contact would be about the same for the different tyres at the same pressure.
11:33:45 <integral> ah;  but surely as a graduate you'll not end up in college accomodation?
11:33:53 <Oejet> Please go to #haskell-overflow with the network talk.
11:34:07 <Oejet>  /college talk.
11:34:12 <basti_> there also is #haskell-blah for haskell-unrelated talk
11:34:12 <frederik2> i don't know. it's the principle of it that bothers me
11:34:16 <_astrolabe> shapr: But I think the big tyre will be noticably better on snow, because you'll sink into it a bit.
11:34:18 <frederik2> sorry
11:34:22 <integral> there's -blah and -overflow?
11:34:24 <basti_> -overflow is the "high level" chan afaics
11:34:25 <basti_> yes
11:34:28 <Oejet> basti_: Ah, that's what I meant.
11:34:43 <basti_> blah is informal, fun talk and unrelated
11:34:47 <frederik2> this is why you guys should use gale
11:34:52 <basti_> overflow is hardcore haskell
11:34:54 * frederik2 goes back to homework
11:34:58 <shapr> _astrolabe: There's a huge difference between a 3 inch tire on a 45mm rim and a 3 inch tire on a 65mm rim.
11:35:12 <basti_> -blah is good for unicycle talk as well ^^
11:35:29 <_astrolabe> shapr: you wanna go to blah?
11:36:12 <shapr> sure
11:37:21 * Oejet checks the channel count.  Wow, 196 people.
11:38:09 <Oejet> In #java: 176 people.
11:38:14 <dcoutts> @seen marcot
11:38:44 <dcoutts> lambdabot!
11:38:51 <dcoutts> @seen lambdabot
11:40:34 <glguy> lambdabot has been less than stable lately
11:45:35 <dcoutts> hmm, ever since it got recomplied with ghc-6.5 I think
11:52:43 <paolino> can someone parse this type for me ? fromInteger :: (Num a) => Integer -> a .Thanks
11:53:08 <TheHunter> It's probably not lambdabot's fault, dons is gone, too.
11:53:10 <shapr> paolino: It says, if you give me an Integer, I will you back whatever instance of Num that you ask for.
11:53:42 <paolino> fromIntegral :: (Num b, Integral a) => a -> b
11:53:53 <paolino> shapr what is the difference ?
11:54:24 <SamB> paolino: that takes any instance of Integral and gives you an instance of Num
11:54:39 <SamB> (again, of your choice)
11:55:03 <paolino> why it didn't write fromIntegral :: (Num a)=> Integral -> b ?
11:55:28 <paolino> fromIntegral :: (Num a)=> Integral -> a ?
11:55:37 <vegai> Integral is a typeclass like Num. Integer is a type
11:56:16 <SyntaxNinja> fromIntegral needs to die
11:56:28 <SyntaxNinja> me and sigbjorn are starting an "I hate fromIntegral" club
11:56:38 <Igloo> Why?
11:56:40 <SyntaxNinja> we're also going to have "fromJust and head" subclubs
11:56:52 <ptolomy2> Sometimes I feel like Haskell was designed to make writing obfuscated code difficult, because the obfuscation has been factored out into the language itself.
11:56:59 <SyntaxNinja> @eval (fromIntegral (-1))::Word32
11:57:01 <shapr> ptolomy2: heh, how so?
11:57:05 <SyntaxNinja> oh
11:57:13 <shapr> ptolomy2: I think it just makes the difficulty in problems harder to ignore.
11:57:14 <SyntaxNinja> Igloo: well, anyway, because of over/underflow
11:57:20 <Igloo> Ah yes, I remember now
11:57:42 <SyntaxNinja> Igloo: admit. you hate it too
11:58:17 <Igloo> I only hate it a teeny weeny bit. fromJust and head much more so.
11:58:36 <vegai> what's wrong with head?
11:58:55 <Igloo> You need pattern guards to get rid of them nicely, though (although I can't come up with a good example of why OTTOMH)
11:58:59 <ptolomy2> shapr: Yeah, I mean it more jokingly. But I'm looking at some code I just wrote that makes use of point free style and gets friendly with '>>=', and I think "man, that's scary.".. but it is rather readable to folks familiar with the language.
11:59:00 <Igloo> vegai: It can fail
11:59:16 <vegai> Igloo: dramatically?
12:00:05 <Igloo> Yes. It leaps into center-stage and proclaims "Why doth thou call me with an empty list?"
12:00:48 <vegai> that could be distracting
12:01:01 <SyntaxNinja> Igloo: isn't fromIntegral more insidious, though? I mean, at least with head and fromJust you KNOW it's probably going to fail ;)
12:01:21 <SyntaxNinja> @eval head []
12:01:28 <vegai> you should write a Haskell play
12:01:28 <SyntaxNinja> lambdabot: "Why doth thou call me with an empty list?"
12:01:32 <SyntaxNinja> heh
12:01:41 <vegai> He's dead, Jim.
12:02:43 <Igloo> SyntaxNinja: Most of the time I'm doing guaranteed safe conversions
12:16:21 <Cale> ptolomy2: can we see? :)
12:20:03 <araujo> Yeah!!!!
12:20:09 <araujo> MaDe It!
12:23:28 <shapr> hiya krasimir!
12:23:54 <shapr> How's HToolkit treating you?
12:24:08 <Krasimir> hi shapr
12:30:19 <paolino> what are newtypes ?
12:30:23 <ptolomy2> Cale: Well, the code that i was looking at isn't really a great example.. more of general observation regarding the relative incomprehensibility of certain classes of haskell code to the uninitiated.
12:30:28 <joelr> howdy
12:30:35 <joelr> shapr: ping
12:30:40 <shapr> hiya joelr
12:31:16 <Cale> paolino: basically types which are implemented the same as the original type, but which look different to the type system
12:31:36 <joelr> shapr: question... Arbitrary is already defined for lists but how do i defined it for fast strings that i would create from arbitrary lists?
12:31:39 <Cale> so you can do something like  newtype Dollars = Dollars Integer
12:31:48 <joelr> instance Arbitrary FS.FastString where
12:31:48 <joelr>     arbitrary = FS.packWords (arbitrary :: [Word8])
12:31:55 <joelr> this does not work for obvious reasons
12:32:20 <shapr> Do you have a Word8 instance?
12:32:26 <Cale> and then a value of type Dollars can't be used as an integer (and you have to use the Dollars constructor to make them) but it's implemented as a plain integer.
12:32:38 <TheHunter>     arbitrary = FS.packWords `fmap` (arbitrary :: [Word8])
12:32:40 <joelr> shapr: of course
12:32:49 <paolino> grazie Cale
12:32:53 <joelr> TheHunter: let me try that
12:33:08 <joelr> TheHunter: `fmap` coming from Control.Monad?
12:33:22 <TheHunter> it's in the Prelude
12:34:16 <joelr> TheHunter: what's the meaning of that?
12:34:24 <joelr> TheHunter: what is it mapping over what?
12:34:36 <TheHunter>     arbitrary = FS.packWords `fmap` (arbitrary :: Gen [Word8])
12:34:43 <TheHunter> and Gen is a functor.
12:35:00 <TheHunter> I don't think you need the type signature anyway.
12:35:44 <TheHunter> moin dons
12:36:21 <joelr>     Overlapping instances for Arbitrary [Word8]
12:36:22 <joelr>       arising from use of `arbitrary' at Arbitrary.hs:23:37-45
12:36:22 <joelr>     Matching instances:
12:36:22 <joelr>       Arbitrary.hs:11:0: instance (Integral a, Bounded a) => Arbitrary a
12:36:22 <joelr>       Imported from Test.QuickCheck: instance (Arbitrary a) => Arbitrary [a]
12:36:24 <joelr>     In the second argument of `fmap', namely `(arbitrary)'
12:36:49 <joelr> i screwed up someplace...
12:37:28 <TheHunter> the instance declaration in line 11 overlaps with the a => [a] one.
12:37:46 <joelr> TheHunter: right, i have this for all integrals
12:37:51 <joelr> instance (Integral a, Bounded a) => Arbitrary a where
12:37:52 <joelr>     arbitrary = arbitraryBounded
12:38:14 <joelr> TheHunter: how do i resolve this, though?
12:38:41 <TheHunter> remove the instance declaration.
12:39:12 <joelr> TheHunter: which one? the one for integrals? but then i cannot test properties with just Word8 for example
12:41:17 <TheHunter> i guess you could use -fallow-overlapping-instances, but personally, I would get rid of the instance declaration and provide instances for all types I need.
12:42:27 <joelr> overlapping instances does it for me!
12:43:50 <joelr> TheHunter: thanks
12:46:11 <TheHunter> how do I get cabal to show me how it is invoking ghc?
12:46:44 <ptolomy2> What is the best way to return a copy of a list with the nth element replaced by a new value? I feel like I'm missing a prelude function somewhere..
12:47:48 <Igloo> You need to write it yourself; splitAt will help
12:47:55 <Igloo> Don't forget it's a linear operation, though
12:48:35 <TheHunter> zipWith ($) (\i -> if i == x then const newVal else id)
12:49:44 <TheHunter> replace ind newVal = zipWith ($) (\i -> if i == ind then const newVal else id) [0..]
12:50:36 <TheHunter> i'm really stupid today...
12:50:41 <TheHunter> replace ind newVal = zipWith (\i -> if i == ind then const newVal else id) [0..]
12:59:33 <joelr> guys, how would you implement tracing in a non-IO monad?
12:59:55 <ptolomy2> Cool. I hadn't considered the zipWith option. I'd been using splitAt. Neato.
13:00:04 <integral> WriterT?  unsafePerformIO?  Debug.Trace.trace?
13:00:30 <joelr> well, i'm reading of keeping the output string in the state but can't quite figure it out
13:00:40 <joelr> integral: what's writerT?
13:00:53 <joelr> integral: is that a monad too?
13:01:14 <TheHunter> ptolomy2, splitAt has better performance, though :(
13:01:16 <integral> it's a monad trasformer version of the Writer monad.  That's the one which keeps a monoid to which you can add output to as a side-effect
13:01:48 <joelr> integral: so I would make my monad an instance of both state and WriterT?
13:01:57 <joelr> any examples of that?
13:02:06 <integral> yep.  hmm, examples, hmm
13:02:53 <integral> probably bits in http://www.nomaware.com/monads/html/index.html
13:03:30 <integral> http://www.nomaware.com/monads/html/xformerexamples.html#example22 -- an example of WriterT around IO, keeping a log
13:04:07 <wolverian> wow, worst colours ever.
13:04:55 <joelr> cool, thanks integral
13:06:26 <joelr> i don't think i have time to convert my code to use monads this weekend :( barely enough time to introduce quickcheck
13:06:44 <joelr> maybe if the customer pays to upgrade the project
13:07:00 <shapr> Did you look at the model based testing in QuickCheckST?
13:07:17 <integral> if the tracing's just debugging, then Debug.Trace may be want you want.  very handy
13:07:18 <joelr> shapr: i did, thanks. i think the code exists even
13:07:30 <shapr> Which code?
13:07:30 * joelr didn't know about Debug.Trace
13:07:37 <joelr> shapr: the monadic QuickCheck
13:07:47 <joelr> shapr: look around on JH's site
13:07:51 <shapr> excuse me?
13:07:52 <joelr> under QuickCheck
13:07:58 <shapr> You mean QuickCheckM, right?
13:07:59 <gour> good night, folks
13:08:13 <joelr> john hugh's, yes, that's what i meant but i understand that i'm wrong :)
13:08:26 <joelr> shapr: i think i got confused between QCM and QCST
13:08:40 <shapr> There are two QuickCheck papers, each of which has a matching QuickCheck version.
13:09:07 <shapr> The most recent paper added monadic testing, but the monad must have a run function.
13:09:18 <shapr> There isn't a run function for the IO monad outside of unsafePerformIO.
13:09:37 <joelr> one last bit of help, folks
13:09:51 <joelr> i now have arbitrary FastStrings
13:09:57 <joelr> how do i do arbitrary
13:09:57 <joelr> newtype CString = CString FS.FastString deriving (Eq, Show, Typeable)
13:10:00 <shapr> I'd like to get your instances btw.
13:10:00 <joelr> for example
13:10:11 <joelr> shapr: of what?
13:10:15 <joelr> instances of what
13:10:19 <shapr> I'm going to do some QuickChecking of dons' FPS lib soon.
13:10:24 <shapr> For combinattorent
13:10:48 <shapr> Er, doesn't dons already have QuickCheck tests in his FPS lib?
13:10:50 * shapr looks
13:11:03 <joelr> hmm... maybe as simple as CString arbitrary
13:11:05 <joelr> actually
13:11:34 <shapr> Ah, he uses pack.
13:13:06 <joelr> shapr: so to get an arbitrary version of a list of word8s that does not include 0s
13:13:20 <joelr> do i define a newtype around [Word8]?
13:13:23 <shapr> use ==> from the quickcheck paper.
13:13:27 <joelr> and make an arbitrary of that?
13:14:01 <joelr> shapr: yes, but ==> is not the question, ghc would complain about duplicate definitions if i just put the constraint on the list, right?
13:14:35 <joelr> so am i correct around creating a newtype ByteListWithoutZeros = BLWZ [Word8]?
13:14:54 <joelr> and then doing instance Arbitrary ByteListWithoutZeros?
13:14:56 <shapr> Look at the example on the first page that uses ==>
13:14:59 <shapr> er, second page.
13:15:04 <joelr> looking
13:15:18 <shapr> If you read the paper, much will become clear :-)
13:15:27 <joelr> i just don't think you can add a constraint for an existing arbitrary
13:15:33 <joelr> and i read the paper a few times already ;)
13:15:52 <shapr> Look at section 2.3
13:16:05 <shapr> The property is constrained, not the generator.
13:16:07 <joelr> i could be confusing things, though
13:16:22 <joelr> yes, indeed, constraining the property as opposed to the arbitrary generator
13:16:39 <joelr> shapr: thanks!
13:16:41 <shapr> sure
13:16:55 <shapr> btw, your other blog disappeared... I'm sure you know :-)
13:17:05 <joelr> shapr: whic hother blog?!
13:17:16 <shapr> You had two, remember? tech and up.. something.
13:17:19 <joelr> shapr: i thought that i have a nice categorized blog now
13:17:22 <shapr> uptick maybe?
13:17:59 <shapr> It's nice, but I keep wanting to read about the easy and rough spots you've found in Haskell.
13:18:01 <joelr> shapr: it's there, just click on trading. i'm planning to get back to updating the blog, i have been without internet for 2 weeks after moving to tenerife, plus the contract has kept me very busy
13:18:21 <shapr> That way I'll have some ideas on how to improve introductory materials maybe.
13:18:25 <joelr> shapr: honestly, i underbid on the project by a week or two just to learn haskell ;)
13:18:30 <shapr> heh, cool
13:18:45 <joelr> shapr: one week went into learning and i'm still catching up and new ideas come up all the time, like the monads today
13:18:55 <joelr> all that leaves no time for the blog
13:19:08 <joelr> i hope to normalize my life after this project is delivered
13:19:17 <shapr> Bah, normal lives suck.
13:19:24 <joelr> and yes, i'll be doing the cool projects in haskell now :-)
13:19:33 <shapr> I'd rather stick with the massive information influx bit :-)
13:19:46 <shapr> Sadly, I can't afford to do that.
13:19:57 <joelr> you will be particularly surprised as to what made me finally pick haskell over ocaml
13:20:03 <joelr> and it wasn't the ton of cool papers ;)
13:20:16 <sieni> joelr: ocaml's sucky license?
13:20:28 <joelr> i don't think ocaml has a sucky license
13:20:33 <joelr> people use it for commercial work
13:20:35 <shapr> joelr: The audio processing paper?
13:20:35 <joelr> no
13:20:42 <SamB> Parsec?
13:20:42 <joelr> shapr: that paper too
13:20:49 <joelr> no = not the ocaml license
13:20:50 <joelr> it
13:20:50 <joelr> was
13:20:51 <joelr> the
13:20:52 <joelr> way
13:20:55 <joelr> you
13:20:57 <joelr> can
13:21:00 <joelr> do
13:21:08 <joelr> comments with -- instead of (* .... *)
13:21:09 <joelr> hehe
13:21:11 * shapr likes the interesting formatting
13:21:13 <SamB> heheh
13:21:21 <joelr> i was just building up the suspense ;)
13:21:24 * shapr laughs
13:21:42 <SamB> that sounds silly, but it is true that ocaml isn't particularly pretty
13:21:59 <joelr> yeah, with haskell you could use where for variety
13:22:01 <basti_> it's butt ugly
13:22:17 <shapr> I think JHC produced binaries will be much faster than GHC produced binaries, so there's another speed increase just over the horizon.
13:22:19 <joelr> i now want to use haskell for network programming
13:22:29 <SamB> I am not experienced enough to know the depths of its ugliness, and I hope to keep it that way.
13:22:33 <sieni> joelr: the compiler has a sucky license
13:22:40 <joelr> what's the difference between jhc and ghc?
13:22:43 <joelr> sieni: how so?
13:23:11 <shapr> JHC is using Boquist's GRIN for its backend, and GHC uses the spineless tagless G machine, aka STG.
13:23:37 <joelr> hmm... feature-wise, are jhc and ghc compatible?
13:23:38 <sieni> joelr: it's licensed under QPL, read about it on gnu site
13:23:41 <shapr> On the other hand, Simon Peyton-Jones is probably the world's greatest expert on functional language implementation, and may come up with some amazing optimization.
13:23:52 <SamB> joelr: no. jhc is missing a lot of features at the moment.
13:23:56 <shapr> JHC doesn't yet do everything that GHC does.
13:24:07 <joelr> ok
13:24:08 <sieni> joelr: basically makes it difficult to fork ocaml even for open source purposes
13:24:28 <shapr> sieni: How so?
13:24:32 <joelr> sieni: oh, that. i don't think i'll ever be concerned about forking ocaml
13:25:07 <shapr> On the other hand, JHC is GPL, while GHC is BSD.
13:25:29 <shapr> GHC has a bunch of closed source versions used by companies.
13:25:42 <joelr> shapr: what would they enhance i wonder
13:25:51 <joelr> and which companies (apart from galois)
13:26:02 <shapr> BlueSpec for one.
13:26:21 <joelr> never heard of them. what do they do and what do they close ghc for?
13:26:22 <sieni> shapr: Read for yourself: http://www.trolltech.com/licenses/qpl.html
13:26:30 <sieni> gpl and bsd are ok
13:27:02 <sieni> and even trolltech dual-licenses all the stuff they license under qpl also under gpl
13:27:08 <shapr> sieni: Oh hey, doesn't this mean any changes you make can be put into a commercial version by the original developer?
13:27:18 <sieni> shapr: yes
13:27:22 <shapr> Much suckage.
13:27:26 <sieni> shapr: but you can't
13:27:31 <shapr> extreme suckage
13:27:41 <shapr> paskaa
13:27:44 <sieni> it's like "we're bsd, but everybody else is gpl"
13:28:03 <joelr> String.hs:1:0:
13:28:03 <joelr>     conflict: module `Script.String' belongs to the current program/library
13:28:03 <joelr>     and also to package Script-0.1
13:28:19 <joelr> how do you overcome things like that? i'm doing development on a package that i have installed
13:28:30 <joelr> by loading individual modules into ghci to test things
13:28:44 <joelr> do i really need to unregister the package until the final build?
13:28:51 <SamB> joelr: well, GHC uses a lot of -ignore-package flags when it builds
13:28:53 * shapr doesn't know
13:29:15 <shapr> sieni: What do you think of a spam filter named paskalle? :-)
13:29:17 <joelr> interesting
13:30:51 <sieni> shapr: is there such a filter?
13:31:47 <shapr> Well, yes. But I never finished it.
13:31:53 <shapr> I mean, it sort of works.
13:32:20 <shapr> But I think the name is the best feature.
13:32:26 <joelr> shapr: i'm sorry, what did you say about bluespec?
13:32:43 <shapr> I think that BlueSpec uses a closed source version of GHC
13:33:03 <joelr> what do they do?
13:33:10 <shapr> http://www.bluespec.com/
13:33:47 <joelr> cool
13:33:47 <sieni> it would be a funny case for a noun (allative instead of nominative, see http://en.wikipedia.org/wiki/Finnish_grammar#Noun_forms), but nice one anyway :-)
13:33:55 <joelr> wonder what they needed to enhance in ghc
13:35:47 <markg> Has anyonene in here set up a lambdabot?
13:36:00 <shapr> sieni: I thought it meant something like "to take a shit"
13:36:03 <shapr> markg: oh I've done it!
13:36:18 <shapr> markg: You're not the Mark from Aetion, are you?
13:36:52 <shapr> sieni: or "to take the shit out of" which fits a spam filter perfectly.
13:37:02 <glguy> Does anyone have the link to the research papers on that research.microsoft.com site?
13:37:04 <joelr> haskell reduced my stress level
13:37:25 <shapr> Haskell has made me look to the stars, now I've realized how dirty my feet are.
13:37:25 <joelr> not having access to #haskell and haskell-cafe increses it significantly!
13:37:51 <shapr> minun nimi on Shae
13:38:20 <shapr> Min olen Americalainen. Min haluan hampurilainen!
13:38:35 <shapr> Anyway....
13:38:52 <markg> shapr I am
13:38:53 <joelr> haha
13:38:57 <sieni> shapr: well, sort of, but one would say that [menn] [paskalle], which would translate to something like [go] [for a shit] if translated directly
13:38:59 <joelr> shapr: what's the hampuri bit?
13:39:07 <shapr> joelr: hamburger :-)
13:39:09 <markg> I'm having trouble with @eval
13:39:34 <shapr> Isn't ohjelmointia just the coolest word?
13:39:37 <markg> actually, more specificly runplugs keeps returning "ghc: failed with error code 1"
13:39:43 <markg> and I have no idea why
13:40:09 <shapr> markg: Isn't there another Mark at Aetion? Carroll?
13:40:30 <markg> There is
13:40:39 <joelr> shapr: so did you say you love hamburgers? or you want hamburgers?
13:40:39 <shapr> Ok, I thought so.
13:40:46 <shapr> joelr: I want hamburgers.
13:40:47 <markg> I'm Mark Goldman
13:40:55 <shapr> Nice to meet you markg, I'm Shae Erisson.
13:41:07 <sieni> shapr: I do that every day! :-)
13:41:19 <shapr> sieni: Yeah, and it's still a very cool word.
13:41:23 <shapr> Finnish rocks.
13:41:26 <markg> likewise.
13:41:36 <flux__> shapr, actually it would be 'hampurilaisen', and earlier 'nimeni on'
13:41:47 <flux__> shapr, but you're doing so much better than conan o'brien!
13:42:04 <markg> have you any idea why runplugs would fail with that message?
13:42:05 <shapr> flux__: I lived in Tornio for three years, so...
13:42:13 <shapr> markg: strace'd it?
13:43:00 <shapr> hoi boegel|home
13:43:11 <boegel|home> yo shapr
13:43:16 <shapr> wazzup?
13:43:17 <rep> hi i'm in california!!!
13:43:24 <sieni> flux__: From the map http://www.cse.unsw.edu.au/~dons/images/haskell/eu.jpg it seems that shapr is from Lule or something pretty close to finland :-)
13:43:38 <shapr> Actually, I'm from Alabama.
13:43:46 <boegel|home> shapr: I'm pretty tired, and sick of running between my home and my gf's
13:43:46 <shapr> Men jag bor i Boden.
13:44:12 <shapr> boegel|home: So stay at her place!
13:44:16 <shapr> That's what I do.
13:44:29 <joelr> i'm from russia, my dad is cuban and i returned to tenerife after passing through finland and sweden overt the course of spring and summer :D anyone can beat that?
13:44:30 <shapr> And my girlfriend is so very cute :-)
13:44:43 <joelr> swedish girls are cute
13:44:46 <shapr> Truly
13:44:46 <joelr> i can attest to that
13:45:12 <joelr> shapr: what's with the jogging pants affinity, though? you know the really ugly cotton type
13:45:24 <shapr> But I'm an equal opportunity admirer. I do not discriminate on the basis of sex, race, or age.
13:45:29 <sieni> boegel|home: get another girlfriend to your place so you have some time to read some good haskell books while taking a bus between your and the first girlfriend's apartment
13:45:34 <markg> I have straced it, but I don't really know what I'm looking for.
13:45:37 <boegel|home> shapr: there's no room... we're planning to live together, but the appartement isn't ready yet
13:45:51 <shapr> boegel|home: Oh, I see
13:46:11 <boegel|home> sieni: I don't want another girlfriend, I barely have time for one
13:46:14 <shapr> markg: My first guess would be that ghc didn't compile the code for whatever reason.
13:46:15 <markg> @eval "hello" ++ " world"
13:46:25 <shapr> Can you use hs-plugins outside of lambdabot?
13:46:40 <boegel|home> shapr: do you have a pic of your gf ?
13:46:52 <shapr> er, yeah...
13:46:59 <sieni> boegel|home: yes, but you can get more time for yourself since when your gf#1 thinks that you ar with gf#2 and vice versa, you can sneak out and do some hacking
13:47:03 * shapr moves this to #haskell-blah
13:47:06 * boegel|home notices lambdabot is gone and screams
13:47:25 <shapr> markg: Have you tried running the test suite that comes with hs-plugins?
13:47:29 <joelr> quickcheck is awesome!
13:47:33 <shapr> yes it is!
13:47:54 <shapr> joelr: Though it is frustrating, Koen and John have had QuickCheck2 in closed beta testing for more than a year.
13:48:08 <shapr> QC2 has some really cool features.
13:48:21 <joelr> shapr: wonder when they will release it
13:48:36 <markg> I thought I had. but its re-compiling now
13:48:46 <markg> plugs worked, but runplugs didn't
13:48:52 <markg> (when I first built it)
13:48:59 <shapr> QC2 has a shrink combinator that checks to see if the bug is present with the init of the input list to arbitrary, meaning it automatically finds the smallest test case that fails.
13:49:19 <joelr> shapr: yeah, i heard about that recently
13:49:25 <shapr> Where from?
13:49:36 <joelr> shapr: on haskell-cafe maybe? don't remember
13:49:42 <shapr> Maybe so, I dunno.
13:49:55 <joelr> shapr: hey, you are a poet and you don't know it
13:50:08 <shapr> Actually, I do know it. But most of my poetry sucks.
13:50:25 <joelr> another quickcheck question
13:50:31 <joelr> never mind
13:50:34 <joelr> i'm being silly
13:50:44 <shapr> I'm getting impatient for QC2
13:50:51 <joelr> i was gonna ask if i needed to define a type alias or newtype for waiting :: Attr Word16 (LE Word16) = makeAttr "waiting"
13:50:57 <joelr> err, just the attribute part
13:51:07 <joelr> when i realized that Attr... is a type in itself
13:51:07 <shapr> I hacked a test driven development extension into QC2, maybe I should just fork QC?
13:51:14 <joelr> which i can make an instance of arbitrary
13:57:11 <markg> from the testsuite for hs-plugins everything was either ok or ignored with the exception of runplugs and pdynload/bayley1
13:57:34 <shapr> Those both failed the testsuite?
13:57:52 <shapr> What OS and version are you using?
13:58:03 <markg> debian current
13:58:21 <markg> The Glorious Glasgow Haskell Compilation System, version 6.4.1.20050801
13:59:57 <shapr> markg: debian/unstable?
14:00:14 <markg> unstable only on certain things
14:00:22 <markg> I think ghc being one of them
14:00:36 <shapr> ghc6 in unstable is 6.4.1-1
14:01:10 <Igloo> That's not a ghc from Debian
14:01:49 <markg> ghc package from   http://haskell-unsafe.alioth.debian.org/archive/i386
14:02:00 <markg> I belive
14:02:08 <markg> either that or I compiled from source.
14:03:29 <shapr> There's also libghc6-plugins-dev in debian/unstable
14:07:16 <markg> [cmd=64 ret=0]% sudo apt-get install libghc6-plugins-dev
14:07:16 <markg> Reading Package Lists... Done
14:07:16 <markg> Building Dependency Tree... Done
14:07:16 <markg> E: Couldn't find package libghc6-plugins-dev
14:07:41 <markg> I have the proper lines in my sources.list
14:07:55 * boegel|home wonders if he should crunch some numbers or watch Lost
14:08:10 <markg> watch lost, it will be more fun than math
14:08:58 <shapr> markg: apt-get update?
14:09:26 <markg> yep
14:09:48 <shapr> hm
14:09:59 <shapr> Maybe libghc6-plugins-dev is in haskell-unsafe?
14:10:55 <markg>  apt-cache search plugins | grep ghc returns nothing
14:13:38 <markg> is there any way of figuring out what runplugs isn't liking?
14:14:58 <shapr> See anything useful in strace?
14:15:11 <JohnMeacham> I totally had a dream I was a monad last night.
14:15:19 <Igloo> :-)
14:15:29 <shapr> You could use the cargo cult approach, upgrade your ghc6 and darcs pull the latest hs-plugins, and see if that fixes it.
14:15:35 <Muad_Dibber> eww JohnMeacham
14:15:37 <markg> just that ghc failed
14:15:49 <markg> I just pulled a copy of hs-plugins yesterday
14:15:52 <shapr> It doesn't say anything about how it failed?
14:16:38 * joelr declares today the QuickCheck day
14:16:39 <joelr> or maybe evening
14:16:57 <joelr> instance (Arbitrary a, Arbitrary b) => Arbitrary (Convertible a b) where
14:16:57 <joelr>     arbitrary = liftM2 (Convertible a b) arbitrary arbitrary
14:17:11 <joelr> oops
14:17:54 <joelr> you can't generate an arbitrary class, can you
14:17:56 <joelr> :D
14:18:03 <shapr> like what?
14:18:16 <joelr> that's me just speaking out loud
14:18:30 <joelr> class Convertible a b where
14:18:30 <joelr>     convert_AB :: a -> b
14:18:30 <joelr>     convert_BA :: b -> a
14:18:33 <joelr> i use this to cast
14:18:54 <markg> I see some things like SIGVTALRM virtual timer expired
14:19:29 <adept> markg: you OS and HW arch?
14:19:34 <markg> and I see where GHC exits
14:19:47 <adept> markg: do you have strace or truss AND are not afraid to use them? :)
14:19:50 <markg> os is debian current, arch is i386
14:20:01 <adept> markg: "current" = sid?
14:20:07 <markg> I have strace, I have never used truss but am not afraid do use it
14:20:19 <joelr> shapr: how do you write this? arbitraryConvertible :: forall a b.(Convertible a b) => Gen a
14:20:37 <joelr> that wouldn't work, would it? Gen (Convertible a b)?
14:20:38 <adept> markg: "truss" is from other, parallel universe. forget about it (not i386)
14:20:40 <shapr> What are you trying to do?
14:20:44 <markg> sarge I belive, sid is unstable
14:20:54 <markg> is it not?
14:21:02 <joelr> shapr: create a generator for convertibles
14:21:09 <adept> markg: strace -f -o LOG your_command and_args_here
14:21:12 <markg> (uses debian at work, personally I'm a slackware guy)
14:21:30 <shapr> joelr: I don't know how to do that. But I would like to know if it's possible.
14:21:37 <joelr> arbitraryConvertible :: forall a b.Gen (Convertible a b)
14:21:40 <joelr> like this probably
14:21:45 <adept> markg: yes, you are right, "sid"="ustable", but "unstable" (for me) is "current" as in "current developments"
14:21:49 <joelr> let me try and see if it works
14:22:33 <adept> markg: among other things, "unstable" carries libghc6-plugins-dev, as you've been pointed :)
14:22:39 <joelr> arbitraryConvertible :: forall a b.Gen (Convertible a b)
14:22:39 <joelr> arbitraryConvertible = Convertible arbitrary arbitrary
14:22:42 <joelr> checking further
14:23:08 <joelr> and of course it does not work because Convertible is not a data constructor
14:23:09 <joelr> oops
14:23:57 <markg> I would like to figure out why its not working when compiling from source though.
14:24:13 <markg> its sort of a charachter flaw of mine.
14:24:21 <adept> markg: hav you got the log from strace?
14:24:27 <markg> yep
14:24:29 <joelr> shapr: no need for arbitrary convertibles, though
14:24:36 <joelr> this should work
14:24:36 <joelr> prop_Convertible :: forall a b. (Arbitrary a, Arbitrary b, Convertible a b) => a -> b -> Bool
14:24:40 <joelr> prop_Convertible a b = convert_BA $ convert_AB a == a
14:24:41 <adept> markg: look for SIGVTALRM in it
14:24:50 <joelr> maybe
14:25:20 <adept> markg: what are the events preceeding crash, according to log?
14:25:43 <markg> There are several SIGVTALRMs
14:25:53 * boegel|home leaves
14:25:57 <boegel|home> g'night everyone
14:26:06 <markg> immediatly before the first one are severl rt_sigprocmask calls
14:26:45 <araujo> lisppaste2, help?
14:26:46 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:28:12 <araujo> An example of my tiny haskell-shell: http://paste.lisp.org/display/12959
14:28:13 <araujo> :-)
14:29:10 <shapr> markg: It really does exist - http://packages.debian.org/unstable/libs/libghc6-plugins-dev
14:29:28 <adept> shapr: he runs stable
14:29:35 <markg> I belive you, I misunderstood what current meant
14:29:42 <shapr> oh
14:29:50 <markg> my bad.  As I said before I'm a slackware guy myself.
14:30:16 <adept> markg: and what about "things befor the exit"?
14:30:27 <shapr> araujo: wah cool, do you have a Functor instance for files/directories?
14:31:15 <araujo> shapr, that was a way i was thinking to implement it with
14:31:32 <araujo> But no, not yet, it is a simple Process -> Function interaction
14:32:00 <markg> I get 3 SIGVTALRMs before exit, right before it exits, I see a SIGCHLD where ghc exits I presume
14:32:36 <markg> does runplugs have a built in max computation time that may be set too short?
14:32:56 <adept> markg: paste the bottom (for a sensible definition of "bottom") somwhere
14:33:13 <shapr> I think it does, that could be the problem.
14:33:16 <adept> markg: i mean, bottom of the log
14:34:12 <markg> 20628 close(2)                          = 0
14:34:12 <markg> 20628 exit_group(1)                     = ?
14:34:12 <markg> 20626 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 1}], 0) = 20628
14:34:12 <markg> 20626 --- SIGCHLD (Child exited) @ 0 (0) ---
14:34:12 <markg> 20626 read(6, "", 8192)                 = 0
14:34:12 <markg> 20626 close(6)                          = 0
14:34:14 <markg> 20626 stat64("/tmp/MczYH20626.o", 0xb7b6d2d8) = -1 ENOENT (No such file or directory)
14:34:16 <markg> 20626 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, {B38400 opost isig icanon echo ...}) = 0
14:34:18 <markg> 20626 read(4, "", 8192)                 = 0
14:34:20 <markg> 20626 close(4)                          = 0
14:34:22 <markg> 20626 write(1, "ghc: failed with error code 1\n", 30) = 30
14:34:24 <markg> 20626 unlink("/tmp/MczYH20626.hi")      = 0
14:34:26 <markg> 20626 unlink("/tmp/MczYH20626.o")       = -1 ENOENT (No such file or directory)
14:34:26 <shapr> hm, that's a big paste
14:34:28 <markg> 20626 unlink("/tmp/MczYH20626.hs")      = 0
14:34:30 <markg> 20626 times({tms_utime=4, tms_stime=1, tms_cutime=55, tms_cstime=6}) = 2098633149
14:34:32 <markg> 20626 setitimer(ITIMER_VIRTUAL, {it_interval={0, 0}, it_value={0, 0}}, NULL) = 0
14:34:34 <markg> sorry
14:34:35 <shapr> You should really put that into a pastebot
14:34:45 <shapr> @paste
14:34:50 <markg> consider me chided
14:34:57 <shapr> heh, no worries :-)
14:35:30 <shapr> lisppaste2: url?
14:35:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:36:22 <adept> markg: do you see stat64("/tmp/MczYH20626.o", 0xb7b6d2d8) = -1 ENOENT ? Obviousyl, compiled '.o' was not there for some reason, and runplugs bailed out.
14:37:02 <markg> I got that, but I don't know why it would be failing
14:37:15 <adept> markg: try strace -f -e file -o LOG same_thing_as_before to narrow down to file-handling funcs and try to see maybe something is missing
14:37:58 <adept> markg: plus, you could look for process 20628 execution log - it is the compiler, i believe
14:38:18 <adept> markg: ah. it say this clearly that "ghc: failed with error code 1"
14:38:40 <markg> I know, that was one of the first things that I stated
14:38:51 <markg> I don't know why its failing though.
14:39:14 <markg> all the tests in the hs-plugins testsuit succeeded except for runplugs
14:39:15 <adept> markg: wel, use strace :)
14:39:33 <adept> markg: but look for the child of the traced process.
14:41:29 <adept> markg: or paste the previous 50 lines of the same log
14:45:17 <markg> adept: would you accept a dcc send of the log file?
14:47:10 <adept> markg: not sure, since i'm here through jabber transport
14:47:30 <adept> markg: just use http://paste.lisp.org/new/haskell
14:47:30 <markg> Thats ok, its blocked anyway...
14:51:43 <markg> http://home.frognet.net/~bitshftr/LOG
14:54:30 <dcoutts> Igloo, Heffalump, kosmikus: next year we should call our ICFP team "the spineless tagless G machine"
14:58:22 <adept> markg: the only suspicious place is
14:58:22 <adept> 20628 fcntl64(0, F_GETFL)               = -1 EBADF (Bad file descriptor)
14:58:22 <adept> 20628 unlink("/tmp/ghc20628.s")         = 0
14:58:22 <adept> though I dont know whether it's bug or "feature"
14:59:09 <adept> markg: i mean, process writes to FD, then closes it, then tries to G_GETFL it. Doesn't make much sense.
15:00:11 <markg> I don't know either.
15:00:56 <markg> I tried bumping up the run time from 3 seconds to 13
15:02:31 <adept> markg: I'd personally just included unstable into sources.list, did apt-get update, did apt-get source libghc6-plugins-dev, and tried to build THAT source, if I were you.
15:02:54 <adept> markg: using dpkg-buildpackage, of course
15:03:19 <adept> markg: or, even better, I'd upgraded ghc to the one from unstable.
15:03:37 <adept> markg: the version of yours is too suspicious
15:04:03 <markg> It was a pull from cvs in august
15:06:14 <adept> markg: august now is more in the "last year" category than in "this year" :)
15:06:46 <adept> markg: besides, driving bleeding edge with compilers ...
15:06:49 <xerox> @index splitAt
15:07:10 <adept> markg: either you should upgrade to sid altogether, you leave that risky habit ;)
15:07:27 <adept> markg: i mean "... or leave that risky habit"
15:09:59 <markg> *sigh* that still won't tell me why runplugs is blowing up on me.
15:10:07 <markg> Now its personal ;)
15:22:25 <JohnMeacham> not haskell related but interesting if you know wolfram or his work: http://www.cscs.umich.edu/~crshalizi/reviews/wolfram/  Heh... it makes me wonder what sort of things we will be publishing in our quackery years, "Monads don't emulate the world, the world is a poor emulation of a monad."  "The second law of thermodynamics as expressed via functional dependencies"
15:22:58 <paolino> ehm sorry what is wrong with
15:23:01 <paolino>       case which
15:23:02 <paolino>            | False = (Left path node):list
15:23:02 <paolino>            | True  = (Right node path):list
15:25:52 <JohnMeacham> heh. good quote "As the saying goes, there is much here that is new and true, but what is true is not new, and what is new is not true"
15:26:40 <ski> paolino : are you using 'case' as a function name ?
15:26:43 <adept> paolino: chase foo of bar -> baz ; zak -> zag;
15:27:14 <ski> adept : 'chase' ? :)
15:27:22 <paolino> aaahh /me hides
15:27:37 <shapr> JohnMeacham: Wolfram has always been the academic equivalent of a one hit boy band.
15:27:50 <adept> ski: oh my. I decided to cut to the 'chase' obviously.
15:27:56 <adept> time to sleep
15:32:24 <JohnMeacham> of course any minute now oleg is going to come along and actually express the second law of thermodynamics via functional dependencies as a purly incidental part of improving HList syntax or something.
15:33:59 <shapr> heh, have you seen my quote about Oleg doing type theory calculations with BGP?
15:36:19 <glguy> can I define a function that takes an Integer, or a (Integer -> Integer) and handles them differently?
15:37:11 <dcoutts> glguy, not easily
15:37:19 <gzl> why do you want to do that?
15:37:21 <dcoutts> glguy, you can but you probably shouldn't
15:37:55 <glguy> dcoutts: I'm trying to figure out Excercise 9.9 in SOE, use    fix f = f (fix f)   to write a non-recursive version of remainder
15:37:59 <glguy> I'd like to work through this example
15:38:17 <glguy> and I'm trying to figure out a way to short circuit the evaluation of f
15:38:36 <dcoutts> glguy, if it's an SOE exercise then you certainly should be trying to distinguish arguments based on their type
15:38:44 <dcoutts> should/shouldn't
15:38:46 <dcoutts> oops :-)
15:38:49 <glguy> okay
15:38:57 <glguy> if I have   f x = 0
15:39:02 <glguy> that means that x won't be evaluated
15:39:02 <glguy> right?
15:39:07 <dcoutts> yes
15:39:21 <glguy> and then I can handle the f 0 case
15:39:41 <micket> I take it alot of people use vim here. I'd like to downsize the width of the row numbers column. Is that possible?
15:39:50 <micket> google gave me nothing but dead ends
15:40:02 <liyang> micket: row numbers?
15:40:26 <gzl> even more people use vim in #vim
15:41:14 <shapr> shocking
15:42:12 <liyang> This is the 10 O'Clock News. The headlines tonight:
15:42:26 <micket> gzl: sorry should i checked for that channel first.
15:42:43 <liyang> micket: no harm in asking here...
15:48:21 <stefanw> <interactive>:1:4:
15:48:22 <stefanw>     My brain just exploded.
15:48:22 <stefanw>     I can't handle pattern bindings for existentially-quantified constructors.
15:48:29 <stefanw> nice error message!
15:48:30 <xerox> Wake up, people!
15:48:39 * dcoutts wakes up
15:48:59 <xerox> f 2 3 [0..]  ==>  [[0,1,2],[3,4,5]]
15:49:08 <xerox> f 1 6 [0..]  ==>  [[0,1,2],[3,4,5]]
15:49:13 <xerox> OPS
15:49:18 <dcoutts> xerox, ?
15:49:30 <dcoutts> xerox, been drinking too much coffe?
15:49:53 <glguy> I'm trying to use 'fix f = f (fix f)' to write a non-recursive remainder function.  I don't want the answer, but can someone help me understand how to get 'f' not to evaluate it's argument in one case, but evaluate them in the remaining casses....???
15:50:08 <xerox> I need a function like:
15:50:09 <xerox> f 2 3 [0..]  ==>  [[0,1,2],[3,4,5]]
15:50:09 <xerox> f 1 6 [0..]  ==>  [[0,1,2,3,4,5]]
15:50:09 <xerox> f 6 1 [0..]  ==>  [[0],[1],[2],[3],[4],[5]]
15:50:11 <xerox> Any ideas?
15:50:29 <glguy> that expands out to f(f(f(f(f(f(....fix f
15:50:32 <integral> xerox: doesn't the first arg just map to take?
15:50:55 <xerox> integral: right!
15:51:08 <xerox> Now I have to make sublists of n elements...
15:51:22 <xerox> A list comprehension, maybe.
15:51:51 <integral> groupBy (\x y -> x `div` z == y `div` z)
15:52:07 <norpan> huh
15:52:15 <xerox> Where 'z' is the snd arg of f?
15:52:32 <joelr> shapr: ping
15:52:32 <integral> @eval (\t z xs -> take t $ groupBy (\x y -> x `div` z == y `div` z) xs) [0..]
15:52:35 <integral> xerox: yeah
15:53:07 <liyang> glguy: you need to think higher order than a function that takes a value and returns a result...
15:53:11 <joelr> data Attr a b = Attr String
15:53:12 <joelr>     (a -> Dynamic, Dynamic -> Maybe a)
15:53:12 <joelr>     (a -> b, b -> a)
15:53:12 <joelr> makeAttr :: (Typeable a, Convertible a b) => String -> Attr a b
15:53:12 <joelr> makeAttr name = Attr name
15:53:14 <joelr>                 (toDyn, fromDynamic)
15:53:16 <joelr>                 (convert_AB, convert_BA)
15:53:25 <xerox> joelr: paste it on a pastebin?
15:53:26 <joelr> folks, how would I defined a QuickCheck arbitrary for Attr?
15:53:54 <joelr> xerox: sorry about that
15:54:07 <joelr> @paste
15:54:35 <xerox> lisppaste2: url
15:54:35 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:55:21 <joelr> new paste is cool
15:55:48 <lisppaste2> joelr pasted "attr arbitrary" at http://paste.lisp.org/display/12963
15:56:06 <glguy> liyang: do you happen to have the soe book?
15:56:28 <shapr> joelr: ?
15:56:28 <liyang> glguy: had. Friend's borrowed it (long term) for now. :)
15:56:42 <joelr> shapr: would you kindly take a look at paste?
15:57:09 <glguy> so I need a higher order function that eventually short circuits?
15:57:15 <lisppaste2> joelr annotated #12963 with "and this one too" at http://paste.lisp.org/display/12963#1
15:57:21 <shapr> joelr: You need to define the type. Did you look at my demo with data Tree a ?
15:57:26 <liyang> glguy: *nod*
15:57:54 <joelr> shapr: i did, thanks but there are nuances with the default todyn, fromdyn, etc.
15:57:56 <xerox> integral: any idea about why |pick 1 1 [0..]| works, while |pick 1 1 (randomRs (0,1) (mkStdGen 0))| doesn't?
15:57:56 <shapr> No clue how forall interacts with arbitrary.
15:58:10 <glguy> welp, off to class
15:58:13 <xerox> integral: ahah!
15:58:16 <glguy> wish me luck
15:58:19 <liyang> g'luck.
15:58:20 <integral> xerox: sorry, I've never used the random number things yet
15:58:21 <liyang> :)
15:58:25 <xerox> integral: you rely on the number contained :D
15:58:31 <integral> yeah!
15:58:37 <xerox> Too bad.
15:58:43 <integral> you could a) come up with a better way of doing the sublists, or zip with [0..]
15:58:45 <shapr> joelr: What nuances? no comprendre
15:59:16 <xerox> integral: the mapAccumL way made my head explode lately.
15:59:22 <shapr> ich verstehe nicht, min ei ymarran, jag frstr inte... ah whatever...
15:59:38 <shapr> I've forgotten how to spell that in Finnish anyway.
15:59:50 <joelr> shapr: here
15:59:58 <joelr> instance (Arbitrary a, Arbitrary b) => Arbitrary (Attr a b) where
15:59:58 <joelr>     arbitrary = liftM Attr arbitrary (toDyn, fromDynamic) (convert_AB, convert_BA)
16:00:03 <xerox> I could simply do take and drop...
16:00:21 <integral> time for sleep.  good night, xerox :-)
16:00:23 <xerox> iterate take.
16:00:26 <shapr> joelr: Have you tried to compile that?
16:00:27 <xerox> Goodnight, thanks integral!
16:00:38 <joelr> shapr: i don't know how to lift this so that only the name is arbitrary. it does not compile
16:01:58 <shapr> You just call makeAttr in your instance.
16:02:11 <shapr> And it uses oneof like in the examples I sent to the list.
16:02:35 <shapr> Assuming you have a list of names you want to randomly choose from...
16:02:50 * xerox ponders iterateAccum
16:03:04 <joelr> shapr: aha, i'm an idiot, of course i can just call makeAttr
16:04:12 <joelr> how do you shorten this?
16:04:14 <joelr> instance (Typeable a, Arbitrary a, Typeable b, Arbitrary b, Convertible a b) => Arbitrary (Attr a b) where
16:04:24 <xerox> Good enough: subs n xs = take n xs : subs n (drop n xs)
16:05:20 <joelr> never mind
16:07:28 <joelr> shapr: this works
16:07:29 <joelr> instance (Typeable a, Arbitrary a, Typeable b, Arbitrary b, Convertible a b) => Arbitrary (Attr a b) where
16:07:32 <joelr>     arbitrary = makeAttr `fmap` arbitrary
16:07:58 <joelr> but this doesn't
16:07:59 <joelr> arbitraryProp :: forall a b.(Arbitrary a, Arbitrary b) => Attr a b -> Gen Prop
16:07:59 <joelr> arbitraryProp  = liftM2 (:=) arbitrary arbitrary
16:09:24 <shapr> Well, I have to go off and work on painfully boring Python code now, sadly.
16:09:32 <joelr> ouch :-)
16:09:42 <xerox> Let's say I have [f,g,h,..] :: [(a -> a)] ...
16:09:43 * shapr joins the #plone channel to commence the punishment.
16:09:48 <joelr> shapr: good luck!
16:09:58 <shapr> I'll need it. That and a bunch more Ritalin too.
16:10:09 <xerox> How can I do ..(h(g(f(x))))
16:10:19 <pesco> shapr: .uu
16:11:50 <shapr> la plon xrani mi
16:12:24 <shapr> coi pesc .i ma nuzba
16:14:40 <eivuokko> xerox, can you foldr (.) id over it?
16:14:46 <xerox> YES
16:14:50 <xerox> I got it two secs ago too
16:14:52 <xerox> Thanks anyway.
16:15:44 <pesco> Damn, I'm not conversational yet. I translated my first real piece of Lojban text today, the first stanza of "ckape litru", and transcribed it into Tengwar right away. ;)
16:16:17 <pesco> I haven't coded for what, weeks?! Uh-oh.
16:16:32 <shapr> I wish I could type tengwar into emacs. Last I checked all the tengwar fonts are broken.
16:16:51 <pesco> shapr: Aw. Did you try the unicode ones?
16:17:22 <shapr> There are unicode tengwar fonts? I know jcowan had requested space in unicode for the fonts, but I didn't think it had been approved yet?
16:19:36 <pesco> shapr: I'm not sure he made the proposal, but it's still in limbo. However, he (IIRC) founded the ConScript Unicode Registry to assign space to different constructed scripts in the private use area.
16:19:56 <pesco> shapr: But there are fonts, yes. They're called Code2000 and Code2001.
16:22:00 <xerox> It worked! BWHAAH!  ...err, goodnight folks.
16:23:12 <pesco> xerox: Congratulations! And goodnight. ;)
16:23:30 <pesco> (Whatever it was you achieved. *g*)
16:24:22 <pesco> I'm going to bed as well.
16:24:24 <xerox> A function generating an arbitrary number of random paths in a given tree starting at arbitrary location.
16:24:31 <pesco> See you all later.
16:24:32 <xerox> (Goodnight to you too :))
16:24:38 <pesco> xerox: Ah, cool. :)
16:24:46 <Pseudonym> Night.
16:25:02 <joelr> shapr: still here? i got that thing to compile
16:25:02 <Pseudonym> Is there a law of conservation of people or something?
16:25:10 <pesco> shapr: Talk to you soon, in Lojban! ;-)
16:25:25 <Pseudonym> Mi ne parolas Lojxban-o.
16:26:04 <pesco> I've lost all my Esperanto. (That was it, no?)
16:26:08 <Pseudonym> Jes.
16:26:13 <joelr> arbitraryProp :: forall a b.(Eq a, Packet b, Show a, Convertible a b, Arbitrary a, Arbitrary b) => Gen (Attr a b) -> Gen Prop
16:26:16 <joelr> arbitraryProp attr = liftM2 (:=) attr arbitrary
16:26:35 <Pseudonym> I'm not sure what the Esperanto word for Lojban is.
16:26:45 <Pseudonym> I bet it doesn't have one.
16:27:09 <pesco> Heh. I guess that's a reason I like Lojban! I know exactly whath the word for Esperanto is!
16:27:25 <Pseudonym> What is it?
16:27:31 <pesco> la .esperanto.
16:27:34 <Pseudonym> There you go.
16:27:47 <Pseudonym> I guessed Lojxban-o, because that's phonetic.
16:28:01 <Pseudonym> Not sure about the hyphen.  That's common in borrowed terms.
16:28:10 <pesco> Hm. Okay.
16:28:19 <Pseudonym> More common in acronyms.
16:28:23 <pesco> Anyway, I was going to bed... ;)
16:28:36 * pesco hides under the blanket.
16:28:40 <Pseudonym> Yes.  Bonan vesperon.
16:46:23 <ulph> @seen lambdabot
16:58:50 <dons> @bot
17:04:46 <ozone> moinmoin
17:09:21 <dons> @seen markg
17:09:22 <lambdabot> markg is in #haskell. I don't know when markg last spoke.
17:09:39 <dons> marg, runplugs fails with 6.4.x compilers due to a  bug in the System.Process library.
17:09:51 <dons> markg, you need to install ghc 6.5 if you're going to play with runplugs
17:16:58 <dons> @seen vegai
17:16:58 <lambdabot> Last time I saw vegai was when I left #haskell and #haskell-
17:16:58 <lambdabot> blah 18 hours, 51 minutes and 23 seconds ago, and I have missed
17:16:58 <lambdabot> 18 hours, 34 minutes and 5 seconds since then.
17:30:28 <eivuokko> Typically, do these withFoo-functions survive exceptions correctly?
17:31:12 <eivuokko> ie, in case of exception, do they free the resouce.
17:31:37 <dons> use bracket if you're worried, but most do, for example, the MVar functions
17:31:44 <dons> if in doubt, download $fptools and check
17:31:48 <eivuokko> Hmm
17:32:30 <eivuokko> I was actually asking, because I suspect that some of the stuff in darcs (which uses with-idiom in some places) doesn't actually work correctly.  This means I really need to check, I guess.
17:32:34 <dons> hmm, I always think >> has a lower precedence that $
17:40:25 <Cale> $ has a really low precedence
17:42:59 <dons> yeah, I know, but for some reason my brain says >> should be lower still
17:43:10 <dons>  f $ x y >> g
17:43:17 <dons> always breaks :)
17:43:25 <dons> but then, I'd want F $ \x -> do ...
17:43:25 <dons> to work
17:47:28 <Igloo> I tend to stay away from mixing operators that aren't obviously related, like + and *, without parentheses
17:52:10 <shapr> For those who missed it, there's a neat LtU post discussing unifying the Curry-Howard isomorphism and its equivalent from philosophy - http://lambda-the-ultimate.org/node/view/1078
17:55:59 <glguy> can someone help guide me to solving how to declare the remainder function using 'fix' where fix f = f (fix f)
17:56:05 <glguy> this problem is plaguing me
17:56:23 <Pseudonym> Do you have a recursive definition?
17:56:54 <glguy> remainder a b = if a < b then a else remainder (a - b) b
17:57:05 <glguy> is this really obvious?
17:57:28 <liyang> glguy: the result of the function you are trying to write is not the fixpoint. It's the function that's the fixpoint.
17:57:36 <dons> @type Control.Monad.fix
17:57:36 <lambdabot> Not in scope: `Control.Monad.fix'
17:57:45 <liyang> glguy: well, pretty much once you've understood it.
17:57:46 <dons> @type Control.Monad.Fix.fix
17:57:47 <lambdabot> forall a. (a -> a) -> a
17:58:06 <dons> why does fix get its own module?
17:58:18 <liyang> glguy: I'm not sure what other advice I can give without telling you the answer...
17:58:30 <glguy> I understand
17:58:36 <dons> ah, MonadFix class is why.
17:59:12 <Pseudonym> remainder = fix (\r a b -> if (a < b) then a else r (a-b) b)
17:59:19 <liyang> in the signature of fix above, the type variable a might be (Int -> Int -> Int)
17:59:29 <Pseudonym> @type (\r a b -> if (a < b) then a else r (a-b) b)
17:59:30 <lambdabot> forall a. (Ord a, Num a) => (a -> a -> a) -> a -> a -> a
17:59:35 <liyang> Pseudonym: -_-;;
17:59:44 <liyang> Pseudonym: he asked not to be told the answer...
17:59:51 * glguy just did a /clear
17:59:52 <Pseudonym> Oh, sorry.
18:00:00 <Pseudonym> Basically, the rule is very simple.
18:00:03 <Pseudonym> Consider this:
18:00:17 <Pseudonym> factorial = \x -> if x == 0 then 1 else x * factorial (x-1)
18:00:28 <Pseudonym> The first thing to do is to abstract out the recursive call.
18:00:43 <Pseudonym> factorial = (\fac x -> if x == 0 then 1 else x * fac (x-1)) factorial
18:00:47 <Pseudonym> Make sense?
18:00:51 <dons> fix has a vaguely unfoldr-like charm about it :)
18:01:19 <Pseudonym> @eval let factorial = (\fac x -> if x == 0 then 1 else x * fac (x-1)) factorial in factorial 5
18:01:21 <lambdabot> 120
18:01:34 <Pseudonym> Do you buy that transformation?
18:01:35 <glguy> alright
18:01:50 <Pseudonym> So now you have a definition of the form: foo = f foo
18:02:04 <Pseudonym> The solution of which is foo = fix f
18:02:09 <glguy> like fix f = f (fix f)
18:02:24 <Pseudonym> Well, foo = f foo means that foo is a fixpoint of f.
18:02:26 <glguy> fix f being the foo of course...
18:02:33 <Pseudonym> The LEAST fixpoint of f is fix f.
18:02:41 <glguy> okay..
18:02:54 <Pseudonym> So the least solution to that equation is foo = fix f
18:03:20 <Pseudonym> Make sense?
18:04:00 <glguy> alright, I understand how to do it now
18:04:07 <Pseudonym> Cool.
18:04:07 <glguy> yeah, my remainder function works
18:04:14 <dons> shapr, stefaqnw and I are giving a talk about testing, using hunit and qc next week. do you have notes for your QC stuff somewhere?
18:04:20 <glguy> that's wild
18:04:25 <glguy> i need to look at it more
18:04:32 <dons> "stefanw" I mean  :/
18:04:35 <shapr> Which stuff? the TDD QC stuff?
18:04:53 <dons> oh, I was just wondering if you've collected some random notes on the area
18:04:59 <Pseudonym> Now if you thought that was wild, your next exercise is to implement mutual recursion.
18:05:00 <glguy> When is fix-point more than just a way to make something look really complicated?
18:05:13 <glguy> define mutual recursion first...
18:05:18 <shapr> dons: I have lots to say on the subject, but it's not collect.d
18:05:26 <glguy> is that like   a x = b x     and b x = a x
18:05:26 <Pseudonym> f = 1 : g
18:05:28 <Pseudonym> g = 1 : f
18:05:30 <dons> I was going to talk, I think, with FPS as an example, about how to choose a reasonable model to check against, and what kind of properties are interesting to check
18:05:32 <Pseudonym> g = 2 : f
18:05:35 <Pseudonym> Try that instead.
18:05:45 <Pseudonym> You can do this by inlining g, but try doing it without.
18:05:50 <dons>  stefan'll talk about hunit and more, I think
18:06:02 <dons> anyway, we'll have notes up that you can use by next Tues :)
18:06:04 <shapr> dons: In essence, I want QC2, I want shrink, I want QuickCheckM with IO support. The different QCm demos are great, but very hard to emulate. I love the demonstrated model, algebraic, and specification based tests.
18:06:13 <Pseudonym> glguy, fix is usually more obfuscated than the alternative, but it's an important building block.
18:06:28 <Pseudonym> It's like using recursion where "map" would do.
18:06:37 <dons> shapr, right. do you have any ptrs to good QC references?
18:06:38 <shapr> QC moves the difficulty into writing good generators and choosing useful properties.
18:06:40 <Pseudonym> It's usually cleaner to use map.
18:06:56 <dons> ah, that's a nice way to put it shapr
18:07:02 <glguy> Pseudonym, so you want me to write a fix point for f = 1 : 2 : 1 : 2 : 1 : 2 : ....
18:07:11 <glguy> Pseudonym, without just merging the 1 : 2
18:07:14 <Pseudonym> No, I want you to translate that directly.
18:07:16 <Pseudonym> Right.
18:07:19 <shapr> QC could subsume HUnit entirely if I'd get off my butt and write the 'use saved test values' extension to my TDD extension.
18:07:46 <dons> though I find  I use HUnit for huge limit tests
18:07:54 <shapr> limit tests?
18:08:03 <dons> (i.e. sending megs of data into a packed string and such like)
18:08:08 <dons> stuff I wouldn't want to do with QC
18:08:15 <dons> stress tests
18:08:25 <dons> whereas I leave the tricky properties to QC
18:08:52 <dons> yi tests 100M+ files with HUnit, not  QC :}
18:09:00 <shapr> The TDD code I wrote for QC saves the (seed,size) tuple of a failing case and reloads failing cases into the beginning of the next run.
18:09:31 <dons> yeah, that's cool. I'd want something like that. they could be saved permanently as HUnit cases
18:09:33 <shapr> It wouldn't be hard to extend that to load Readable data.
18:09:36 <shapr> Exactly
18:10:15 <dons> have you seen stefan's sugar-syntax for HUnit that uses TH?
18:10:25 <dons> makes HUnit a  bit nicer to play with.
18:10:45 <glguy> Pseudonym, is this considered inlining (i know it's not a finished result, I'm just working with it) (code follows)
18:10:55 <shapr> There's a big category of missing tests. Most code isn't tested for acceptable failure, or correct failure with incorrect input.
18:11:06 <glguy> @eval let f = (\r -> 1 : r) ((\r -> 2 : r) f) in take 10 f
18:11:07 <lambdabot> [1,2,1,2,1,2,1,2,1,2]
18:11:14 <dons> shapr, yeah, true!
18:11:38 <Pseudonym> I'd call that inlining, yes.
18:11:39 <shapr> Software tests check for the correct result from the correct input, and almost never check for handling of incorrect input. Otherwise we wouldn't get buffer overflows.
18:11:41 <dons> this kind of stuff I usually throw to a nasty black-box-style perl script that just checks output and $?
18:11:46 <glguy> aight :)
18:12:17 <shapr> I think the ==> operator in QC should be extended to treat the non-matching inputs as 'check for acceptable failure.'
18:12:34 <dons> being able to specify legal exceptions that are thrown would be interesting
18:12:54 <dons> such -and-such will fail with ExitFailure 42, or so
18:13:00 <shapr> I'd like to see stefanw's TH sugar.
18:13:08 <dons> http://www.cse.unsw.edu.au/~dons/code/fps/tests/Tests.hs
18:13:21 <dons> essentially, the $(tests "fps" [d| splice
18:13:35 <dons> and some extra assertions: http://www.cse.unsw.edu.au/~dons/code/fps/tests/TestFramework.hs
18:13:47 <dons> oh, and it uses m4 to give you the line number of the assertion that failed
18:13:55 <dons> we used this in the icfp contest, and it worked very nicely
18:13:55 <shapr> I think that a QC extended with acceptable failure tests would probably break open the average TCP/IP stack in short order.
18:14:44 <Pseudonym> glguy, want a hint?
18:14:47 <shapr> that first url is 403
18:15:05 <glguy> Pseudonym, will i end up with two fix points?
18:15:14 <Pseudonym> Nope.
18:15:19 <glguy> okay
18:15:22 <shapr> I used to say that to my friends when were looking at a pretty girl with a wedding ring :-) She's totally 403, dude.
18:15:31 <Pseudonym> let { f = 1 : g; g = 2 : f } in f
18:15:35 <Pseudonym> is the same as:
18:15:39 <glguy> I'm workin on it
18:15:49 <Pseudonym> let (f,g) = (1 : g, 2 : f) in f
18:16:00 <Pseudonym> Should be easy now.
18:16:16 <shapr> dons: I would very much like to get hold of the QC survey results and start a QC fork.
18:16:46 <glguy> @eval let (f,g) = (1:g,2:f) in take 10 f
18:16:48 <lambdabot> [1,2,1,2,1,2,1,2,1,2]
18:17:05 <shapr> Ah, now I can see the first url.
18:17:42 <dons> yeah,, I'd be up for a grand-unified QC/HUnit project
18:18:15 <dons> or just  darcs get  fps, the code is in tests/
18:18:18 <dons> @where fps
18:18:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
18:18:20 <shapr> I came up with some other crazy ideas that would probably work with QC, but I forget what they were.
18:19:03 <shapr> I sent an email to Koen recently asking about QC2. I generally have to email him about eight times over a period of several months before he says "we're still not ready."
18:19:14 <glguy> (f,g) = (\(r.q) -> (1 : q, 2 : r)) (f,g)
18:19:17 <glguy> on this track?
18:19:19 * shapr sends a lot of "gee, how's that project doing?" sort of emails.
18:19:47 <Pseudonym> If you replace the . with a , then yes.
18:19:59 <Pseudonym> I know what you meant,
18:20:49 <glguy> (f,g) = fix (\(r,q) -> (1 : q, 2 : r))    doesn't work
18:20:56 <glguy> but let me play a little longer
18:21:09 * shapr decides to email John Hughes instead
18:21:47 <Pseudonym> let fix f = f (fix f) in fst (fix (\(r,q) -> (1 : q, 2 : r)))
18:21:55 <Pseudonym> @eval let fix f = f (fix f) in fst (fix (\(r,q) -> (1 : q, 2 : r)))
18:21:57 <lambdabot> Stack overflow
18:22:00 <Pseudonym> Hmm.
18:22:12 <shapr> dons: Tell me when you put your notes up, maybe I'll remember something else.
18:22:45 <dons> ok. will do
18:22:50 <stefanw> dons: I would contribute to a unified testing framework as well
18:23:02 <dons> ah! I suspected as much ;)
18:23:10 <shapr> I wonder who else would?
18:23:27 <shapr> Anyway, it'd be worthwhile, and I'm tired of waiting for QC2.
18:23:53 <Pseudonym> OK, it helps if you compile out the tuples.
18:23:56 <Pseudonym> pair x y = \f -> f x y
18:23:57 <Pseudonym> fst p = p (\x y -> x)
18:23:57 <Pseudonym> snd p = p (\x y -> y)
18:24:07 <Pseudonym> Then you get:
18:24:23 <Pseudonym> @eval let fix f = f (fix f) in (fix (\p f -> p (\x y -> f (1 : y) (2 : p x)))) (\x y -> x)
18:24:24 <lambdabot> Couldn't match `[a] -> [a] -> t' against `[a]'
18:24:26 * dons >>= uni to hear peteg talk arrows
18:24:27 <Pseudonym> Errr...
18:24:43 <Pseudonym> @eval let fix f = f (fix f) in (fix (\p f -> p (\x y -> f (1 : y) (2 : x)))) (\x y -> x)
18:24:44 <shapr> Does peteg do IRC?
18:24:44 <lambdabot> Add a type signature
18:24:49 <Pseudonym> Oooh!
18:24:51 <shapr> neat error message!
18:25:02 <Pseudonym> @eval let fix f = f (fix f) in (fix (\p f -> p (\x y -> f (1 : y) (2 : x)))) (\x y -> x) :: [Int]
18:25:04 <dons> :D
18:25:07 <lambdabot> Terminated
18:25:11 <Pseudonym> Hmmm.
18:25:14 <dons> mwhahaha
18:25:18 <glguy> it's infinite series
18:25:24 <glguy> you need to take 10 or something?
18:25:31 * shapr decides to take 5...
18:25:34 <shapr> g'night!
18:25:39 <Pseudonym> @eval let fix f = f (fix f) in take 10 $ (fix (\p f -> p (\x y -> f (1 : y) (2 : x)))) (\x y -> x) :: [Int]
18:25:44 <lambdabot> Terminated
18:25:50 * shapr &
18:25:57 <eivuokko> FFI spec says that it is system dependent whetever ForeignPtr finaliser may call back into haskell.  Is there such restriction in ghc or what issues it might have?
18:25:58 <Pseudonym> @eval let fix f = f (fix f) in take 10 $ (fix (\p f -> f (1 : p (\x y -> y)) (2 : p (\x y -> x)))) (\x y -> x) :: [Int]
18:25:59 <lambdabot> [1,2,1,2,1,2,1,2,1,2]
18:26:02 <Pseudonym> That's more like it.
18:26:17 <Pseudonym> #pl (fix (\p f -> f (1 : p (\x
18:26:28 <Pseudonym> @pl (fix (\p f -> f (1 : p (\x y -> y)) (2 : p (\x y -> x)))) (\x y -> x)
18:26:29 <lambdabot> fix (ap (flip . flip id . (1 :) . ($ const id)) ((2 :) . ($
18:26:29 <lambdabot> const))) const
18:26:34 <Pseudonym> Damn, it uses ap.
18:26:53 <glguy> @pl fix (\a b -> if a < b then a else r (a - b) b)
18:26:55 <lambdabot> fix (liftM2 ap (flip =<< (if' .) . (<)) (join . (r .) . (-)))
18:27:09 <glguy> @type ap
18:27:10 <lambdabot> Not in scope: `ap'
18:27:13 <glguy> @index ap
18:27:14 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer,
18:27:14 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
18:27:14 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List,
18:27:14 <lambdabot> Data.Graph.Inductive.Query.ArtPoint, Data.Graph.Inductive.Query,
18:27:14 <lambdabot> Data.Graph.Inductive
18:27:22 <glguy> @type Control.Monad.ap
18:27:23 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m
18:27:23 <lambdabot> b
18:27:33 <Pseudonym> Not quite what you want.
18:30:18 <sethk> what's the best way to handle  Module X imports Module Y, and module Y imports module X?  Or do I have to remove the circular dependency?
18:31:35 <Pseudonym> Complain to the Simons, and ask them for a real module system.
18:31:44 <Pseudonym> Barring that, write hi-boot files.
18:31:50 <eivuokko> ghc manual had some notes about it
18:32:07 <sethk> no magic?  too bad.  :)
18:32:32 <Pseudonym> You could always use hugs.
18:33:42 <sethk> Pseudonym, no, I'm writing something I hope people might use.  It has to compile.
18:34:21 * Pseudonym nods
18:36:50 <glguy> my newb solution to circular module deps would be to put it all in one file :)
18:37:18 <Pseudonym> That's not so dumb, actually.
18:37:26 <Pseudonym> Though you might get away with refactoring.
18:38:02 <Pseudonym> It depends what you're importing.  If it's only data structures, for example, it's best to put that in a separate module.
18:39:56 <sethk> Pseudonym, I moved the data structures
18:40:13 <sethk> Pseudonym, I would end of with a file thousands of lines long, which is a bad thing
18:40:50 <Pseudonym> How big is the actual strongly-connected component?
18:42:15 <sethk> only about 40 lines
18:42:52 <glguy> is it possible to write fix-point functions in C++?
18:45:22 <eivuokko> Unfortunately, I didn't follow, so I am not sure what fix-point is, but it was just a high-order function abstraction?
18:46:26 <sethk> I think he means a function to find a fix-point, although I'm not sure how that works in Haskell either
18:46:47 <eivuokko> Uhm.
18:46:58 <glguy> I mean to write the equivalent of   remainder = fix (\r a b -> if a < b then a else r (a - b) b)
18:47:01 <glguy> in C++...
18:47:23 <sethk> glguy, it has to be possible, since both are turing complete
18:47:37 <glguy> sethk, it only has to be possible to solve the same problems
18:47:43 <glguy> not express them the same way...
18:47:49 <eivuokko> glguy, it can be almost convient with boost::fuction and boost::lambda or similar libraries.
18:48:01 <eivuokko> But it's just not usually worth it for such tasks.
18:48:10 <glguy> Doesn't appear to be worth it in haskell either
18:48:17 <glguy> so that can't ever be the point :)
18:49:35 <sethk> glguy, that's not exactly correct.  You implied something about turing completeness which, in isolation, is true, but for this example is false.
18:49:52 <syntaxfree> @fact Turing
18:49:54 <lambdabot> I know nothing about turing.
18:52:47 <glguy> @fact lambdabot
18:52:47 <eivuokko> Btw, it doesn't make much sense to use fix-type idiom in imperative language, does it?  You could write loop easier, eh?
18:52:48 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is
18:52:48 <lambdabot> female..
18:53:14 <glguy> eivuokko, it doesnt seem to make sense using it in any language, the point is just to do it :)
18:53:32 <glguy> from whta I can tell it just makes things a little bit less readable
18:54:14 <eivuokko> The excersice seems to center around how to manage "state", so it might open up understanding how to use lambda and ehm sort of fold to keep state.
18:54:19 <Dibrom> anyone know if it is possible to make something like a constructor synonym for a predefined type?
18:55:11 <Dibrom> I'd like to do something like: (:+.) = (:+)
18:55:30 <Philippa> not AFAIK
18:55:42 <Philippa> you could have (+.) = (:+) though
18:55:47 <Dibrom> yeah, I suspected not
18:55:55 <Dibrom> yeah, prob with that is I can't pattern match with it
18:57:26 <Dibrom> another question, is there a Complex type defined for Rational somewhere?  Or are Float and Double the only things support by current libs?
19:06:37 <araujo> Hello Haskell'ers!
19:07:08 <eivuokko> Hiya
19:09:16 <glguy> woul this be the lisp equivalent of fix (anyone know lisp?)  (defun fix (f) (f (fix f)))
19:09:58 <Dibrom> what does fix do?
19:10:06 <Dibrom> in haskell
19:10:19 <glguy> fix f = f (fix f)
19:11:12 <Dibrom> yeah, should be the same then I believe
19:20:27 <syntaxfree> hey araujo.
19:20:58 <syntaxfree> I don't understand the definition of fix.
19:23:53 <Korollary> syntaxfree: isn't it similar to ones = 1 : ones ?
19:24:08 <Dibrom> seems like it applies f to itself infinitely?
19:24:16 <syntaxfree> yes. but ones = 1: ones is an infinite list.
19:24:33 <syntaxfree> does it make sense to speak of infinite recursion in the case of function composition?
19:24:54 <Dibrom> why not?
19:25:23 <syntaxfree> because, um, an infinite list exists so I can say something like  "take 10 ones".
19:25:32 <syntaxfree> when does fix f = f (fix f) stop executing?
19:26:14 <syntaxfree> @eval fix (*2)
19:26:16 <lambdabot> Loop
19:26:31 <syntaxfree> @eval fix (1/)
19:26:32 <Dibrom> yeah, I don't know what exactly it'd be useful for that way.  But maybe it is somehow useful for monads or something.
19:26:33 <lambdabot> Loop
19:26:41 <Cale> um, fix is quite useful
19:26:50 <Dibrom> Cale: what is it used for?
19:27:08 <Cale> @eval fix (\f n -> if n = 0 then 1 else n * f (n-1)) 5
19:27:09 <lambdabot>  parse error on input `='
19:27:14 <Cale> @eval fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5
19:27:15 <lambdabot> 120
19:27:27 <Dibrom> oh, heh..
19:27:32 <Cale> that's an anonymous factorial function :)
19:27:39 <Dibrom> should have thought of that
19:27:47 <Dibrom> brainfried tonight
19:28:06 <syntaxfree> hmm.
19:28:18 * syntaxfree still prefers his factorial function as a sequence of functions.
19:28:36 <syntaxfree> It's my own personal pearl, and I cherish it as an object of beauty.
19:28:44 <Cale> fix is called a least fixed point operator
19:29:02 <syntaxfree> why a least fixed point?
19:29:14 <syntaxfree> and does "fixed point" have anything to do with fixed point theorems in topology?
19:29:46 <Cale> well, in the sense that it's finding a value which is a fixed point of f
19:29:57 <Cale> y f = f (y f)
19:30:02 <Cale> look at that as an equation
19:30:14 <syntaxfree> hmm.
19:30:20 <Cale> it basically says right away that (y f) is a fixed point of f
19:30:32 <syntaxfree> I see.
19:30:40 <glguy> Cale, so.... fix-point functions simply allow for anonymous recursive functions?
19:31:01 <Cale> glguy: yeah, that's their most important function, I'd say
19:31:25 <Cale> Once you have one, you can do recursion, even when there's no way to do recursion otherwise
19:31:28 <glguy> so fix-point functions are in a sense as important as lambda-expressions
19:31:45 <syntaxfree> @eval fix (\f string->if string="" then 0 else 1+f.tail string) "Hmm"
19:31:46 <lambdabot>  parse error on input `='
19:31:56 <syntaxfree> @eval fix (\f string->if string=="" then 0 else 1+f.tail string) "Hmm"
19:31:57 <lambdabot>   Expecting a function type, but found `[a]'
19:31:57 <lambdabot>   Expected type: a -> [Char]
19:31:57 <lambdabot>   Inferred type: [a1]
19:32:09 <Cale> glguy: yeah, they can be. Sometimes it's possible to write fix as a lambda term.
19:32:16 <syntaxfree> @eval fix (\f string->if string=[] then 0 else 1+f.tail string) "Hmm"
19:32:17 <lambdabot>  parse error on input `='
19:32:25 <syntaxfree> @eval fix (\f string->if string==[] then 0 else 1+f.tail string) "Hmm"
19:32:27 <lambdabot>   Expecting a function type, but found `[a]'
19:32:27 <lambdabot>   Expected type: a1 -> [a]
19:32:27 <lambdabot>   Inferred type: [a2]
19:32:37 <syntaxfree> @eval fix (\f string->if string="" then 0 else 1+f.tail string)::[Char]->Int "Hmm"
19:32:38 <lambdabot>  parse error on input `='
19:32:49 <syntaxfree>  @eval fix (\f string->if string==[] then 0 else 1+f.tail string)::[Char]->Int "Hmm"
19:33:01 <syntaxfree> @eval fix (\f string->if string==[] then 0 else 1+f.tail string)::[Char]->Int "Hmm"
19:33:02 <lambdabot>  parse error on input `"'
19:33:26 <glguy> @pl f x y = g x y x
19:33:27 <lambdabot> f = flip =<< g
19:33:36 <syntaxfree> @eval fix (\f string->if string==[] then 0 else 1+f.tail string) "Hmm"  :: [Char]->Int
19:33:37 <lambdabot>   Expecting a function type, but found `[a]'
19:33:37 <lambdabot>   Expected type: a1 -> [a]
19:33:37 <lambdabot>   Inferred type: [a2]
19:33:40 <syntaxfree> HELP!
19:34:09 <glguy> @type =<<
19:34:10 <lambdabot> parse error on input `=<<'
19:34:19 <glguy> @type (=<<)
19:34:20 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m
19:34:20 <lambdabot> b
19:35:09 <glguy> @type flip =<< g
19:35:11 <lambdabot> Not in scope: `g'
19:35:13 <Cale> @eval fix (\f string -> if null string then 0 else 1 + (f . tail) string) "Hmm"
19:35:14 <lambdabot> 3
19:35:21 <Cale> @eval fix (\f string -> if null string then 0 else 1 + (f . tail) string) "Hello, World"
19:35:22 <lambdabot> 12
19:36:27 <syntaxfree> AH!
19:36:32 <syntaxfree> mo'fool me.
19:36:35 <syntaxfree> thanks, Cale.
19:36:37 <glguy> @eval map (fix (\r n -> if n == 0 then 1 else n * r (n-1))) [1..5]
19:36:39 <lambdabot> [1,2,6,24,120]
19:36:40 <syntaxfree> @karma+ cale
19:36:41 <lambdabot> cale's karma raised to 1.
19:36:46 <glguy> heh
19:36:57 <syntaxfree> keep the spirit of '99. I'm going away now.
19:37:10 <Cale> also, remember always to leave spaces between (.) and its parameters
19:37:28 <Cale> since it's used in qualified names
19:37:41 <Cale> which is really unfortunate, but what can you do? :)
19:38:04 <glguy> rename the . operator to `o` :)
19:38:18 <glguy> f `o` g x = f ( g x )
19:38:19 <Cale> yeah, you could, or to some unicode character :)
19:38:27 <Cale> 
19:38:38 <glguy> I can read those now :)
19:38:39 <glguy> (xchat)
19:38:42 <Cale> that's not the right one, but it's close and I can type it
19:38:52 <Cale> hmm...
19:38:52 <Cale> :)
19:39:34 <glguy> hwo do you type them...
19:39:49 <Cale> I wish GHC was better about unicode in source files, so one could use  for type variables :)
19:40:18 <Cale> Compose ^ 0
19:40:22 <Cale> makes 
19:40:44 <Cale> (Both Alt Keys) abgde -> 
19:41:17 <glguy> 
19:41:50 <Cale> this is a property of my keyboard setup :)
19:42:32 <Cale> In gnome, you can set various key combinations to swap keyboard layouts. I have it set such that both alt keys toggles between English and Greek.
19:42:45 <glguy> I'm in GNOME 2.10 right now
19:43:25 <Cale> In Keyboard Preferences, you add a new layout, like "Greek Eliminate dead keys"
19:43:39 <glguy> have my compose key working... ?
19:43:46 <glguy> ?
19:43:49 <Cale> oh, for compose
19:44:08 <glguy> ? and whatnot, but that's about it
19:44:10 <Cale> Layout options -> Miscellaneous -> Caps lock is compose  is what I use
19:44:20 <Cale> I'm getting ? there
19:44:25 <glguy> You never use the caps lock?
19:44:32 <Cale> pretty much never
19:44:46 <Cale> When do I ever want to type in all caps?
19:44:53 <glguy> obviously you don't, you turned it off
19:44:53 <glguy> :)
19:45:23 <Cale> IT'S EASY ENOUGH TO HOLD DOWN SHIFT!
19:46:01 <glguy> stop yelling
19:46:02 <glguy> shesh
19:46:07 <Cale> there are also options to set Right Alt, Right Win-key, and Menu as compose :)
19:46:11 <Cale> hehe
19:46:23 <glguy> I am using the Right-Alt -> Compose option
19:46:33 <glguy> the keyboard I have on this machine doesn't have a menu key or a right window key :)
19:46:45 <glguy> it's the tiny PlayStation 2 USB keyboard
19:47:45 <Cale>  - I can also type Japanese (though I have to work on learning that language :)
19:48:34 <Cale> uim is nice for that :)
19:50:10 <Pseudonym> BBL.  Lunch.
19:59:18 <Cale> glguy: make sure that X-Chat is set to UTF-8 in the properties for FreeNode in the server list
19:59:30 <Cale> that affects how characters are sent
20:36:39 <glguy> 
20:36:48 <glguy> did that come across correctly?
20:38:36 <pediddle>    -    ---
20:38:52 <glguy> Those aren't gibberish
20:38:54 <glguy> so that's a plus
20:39:07 <glguy> well.. they are gibberish
20:39:10 <pediddle> hehe
20:39:11 <glguy> but they look structured
20:39:20 <sethk> glguy, hard to know without knowing what they are supposed to look like
20:39:29 <sethk> glguy, I got the ae character
20:39:31 <pediddle> it's just devenagari spelling out "make sure that X-Chat is set to UTF-8" phonetically
20:39:35 <glguy> cool
20:39:47 <pediddle> night
20:47:44 <cjs> glguy: Is that supposed to be "datsu"? (The  character--did mine come out right?)?
20:48:26 <cjs> I'm just using "system default" as the charset. The pediddle stuff didn't come out as anything recognisable.
20:49:09 <sethk> same here
20:49:23 <sethk> at least I didn't get any pediddle on my floor
20:50:03 <glguy> cjs, yeah, i was using the "datsu"
20:50:16 <glguy> I don't know how to make many characters
20:54:33 <machack666> is the order of operations on a list comprehension well defined?
21:05:09 <sethk> machack666, I believe so, yes.
21:11:49 <Cale> machack666: yeah, it's like nested loops where the first generator is the outermost one -- there's a direct translation into map and filter given in the report.
21:47:04 <xerox> y f = f (y f) -- D'oh :)
21:57:12 <Cale> xerox: hi
21:57:19 <Cale> hm?
21:58:22 <Cale> glguy: yeah, that's showing up correctly.
22:03:26 <Cale> (I think :)
22:09:49 <JohnMeacham> That was a lot of typing.  I need a drink.
23:33:49 <gour> JohnMeacham: i just read your Cmf message
23:34:10 <gour> JohnMeacham: although i do not understand lot of stuff, it sounds pretty impressive
23:34:30 <dhpeterson> hi all
23:34:44 <dhpeterson> i'm just getting into haskell (working through YAHT)
23:34:49 <gour> JohnMeacham: opening the new door to the production use of haskell
23:34:51 <dhpeterson> about to order a book or two on haskell
23:35:02 <gour> hi dhpeterson
23:35:04 <dhpeterson> looking for pointers or tips
23:35:05 <dhpeterson> hi gour
23:35:20 <dhpeterson> pointers to books, i mean :) (not *)
23:35:25 <gour> dhpeterson: i'm also learning haskell
23:35:29 <dhpeterson> cool
23:35:46 <dhpeterson> is it your first functional language or do you have backgground?
23:35:57 <gour> dhpeterson: you have a list on http://haskell.org/bookshelf/
23:36:04 <dhpeterson> yes i've seen
23:36:20 <gour> dhpeterson: it's my 1st fpl and (hopefully) the last :-)
23:36:44 <gour> dhpeterson: i boughtt craft of fp - http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
23:37:00 <gour> dhpeterson: i mean, haskell can solve all my needs ;)
23:37:19 <dons> turing-completeness is a great thing ;)
23:37:41 <dhpeterson> i'm looking at craft2e also
23:37:50 <gour> dhpeterson: for the best tour on haskell, contact shapr
23:37:59 <gour> dhpeterson: he is a real guru for it
23:38:24 <gour> dhpeterson: i'm on the 14th chapter and i really like the book
23:38:55 <gour> dhpeterson: started by using, helium, then hugs and now i use ghc
23:39:02 <dhpeterson> i started with gchi directly
23:39:04 <gour> dhpeterson: actually, ghci
23:39:44 <gour> dhpeterson: http://lambda-the-ultimate.org/ is a nice site
23:39:47 <dhpeterson> i have programmed in several imperative langs (c, c++, java, c#) and also seen a bit of lisp and scheme, but haskell is my first concerted atempt
23:39:55 <dhpeterson> gour: yes i have just come across that site
23:40:04 <gour> dhpeterson: as well as http://sequence.complete.org/
23:40:38 <dhpeterson> what i can't understand about the whole FP community is ... if FP is as powerful as I understand it to be (from my readings of SICP, Paul Graham's On Lisp, etc), then why did imperative languages "win" (at least in a populatiy sense)
23:40:54 <dhpeterson> the more i look at haskell the more i see its power relative to traditional langs
23:41:11 <dhpeterson> why did OO and grady booch and UML and all that ^&#% "win" over FP?
23:41:13 <dhpeterson> i just don't get it
23:41:33 <dhpeterson> i'm not trolling here, i'm genuinely curious
23:41:34 <integral> they're simpler?
23:41:44 <gour> dhpeterson: you know about Beta & VHS?
23:41:50 <dhpeterson> heh yes :)
23:41:51 <gour> dhpeterson: or linux & win32?
23:41:56 <dhpeterson> again yes
23:42:02 <dhpeterson> though i have used linux for a long time
23:42:19 <gour> dhpeterson: so, it's not easy to change someone's habits :-)
23:42:24 <dhpeterson> but they didn't just win in "society" they also (seemed to) win inside the mainstream academic community
23:42:25 <dons> not sure if they're simpler at all. oo semantics are often hideous
23:42:35 <dhpeterson> i guess i am at a disadvantage, engineering facult ;)
23:42:37 <integral> my guess is that it's because people on Unix, just used C,  and then microsoft used C for their windows
23:42:41 <gour> dhpeterson: http://haskell.org/hawiki/TheMonadReader is another spot to visit
23:42:41 <dhpeterson> yep
23:42:42 <dons> not inside the language design community..
23:43:00 <dhpeterson> dons: right, from what i understand
23:43:07 <dhpeterson> but outside certainly
23:43:08 <dons> or the theorem proving community either. they love fp
23:43:17 <dhpeterson> hey dons, i've been to your site
23:43:21 <dhpeterson> you're at UNSW right?
23:43:25 <dons> yep :)
23:43:29 <gour> however, haskell community is exceptionally user-friendly one
23:43:29 <dhpeterson> i'm at sydney uni
23:43:32 <dons> ah!
23:43:36 <dons> welcome :)
23:43:39 <dhpeterson> thanks
23:43:41 <dons> you should add yourself to:
23:43:42 <dons> @map
23:43:42 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:43:43 <dons> :)
23:43:47 <dhpeterson> k hang 1
23:43:55 <gour> dhpeterson: now you're in a good hands :-)
23:44:22 <dons> much haskell hacking going on over at usyd?
23:44:35 <dhpeterson> none at all
23:44:42 <dhpeterson> i teach 2 courses in school of EIE
23:44:47 <dhpeterson> web-centric stuff
23:44:55 <dons> one point is, if haskell keeps winning the icfp contest, despite twice as many C++ entries each year, it'll have to catch on.
23:45:04 <dhpeterson> i have been reading mark jason dominus' "higher order perl"
23:45:11 <dons> yikes!
23:45:14 <dhpeterson> i.e. perl -> pugs -> haskell is my approach ;)
23:45:18 <dhpeterson> yes i kniw
23:45:19 <dhpeterson> know
23:45:25 <dons> ah! another pugs convert, eh?
23:45:26 <gour> dons: i hope so
23:45:29 <dons> @karma+ autrijus
23:45:29 <lambdabot> autrijus's karma raised to 6.
23:45:36 <dhpeterson> heh
23:45:48 <dhpeterson> my background is imperative programming
23:45:59 <dhpeterson> but the more i look for myself, i see the power of the functional languages
23:46:01 <dons> have you met lambdabot before?
23:46:06 <dhpeterson> no
23:46:14 <dons> due to the wonders of strong static typing, we have:
23:46:16 <dons> @eval map (\
23:46:17 <lambdabot>  parse error on input `}'
23:46:20 <dons> @eval map (
23:46:20 <lambdabot>  parse error on input `}'
23:46:26 <dons> sorry, new keyboard... grr
23:46:39 <dons> @eval map (\x -> x+2) [1..10]
23:46:40 <lambdabot> [3,4,5,6,7,8,9,10,11,12]
23:46:44 <dons> @type map
23:46:44 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
23:46:50 <dons> @google haskell
23:46:51 <lambdabot> http://www.haskell.org/
23:46:53 <gour> it's nice to see attempts to join efforts of jhc & ghc to make better (production) tools
23:46:54 <dons> @version
23:46:54 <lambdabot> lambdabot 3p120, GHC 6.5.20050806 (Linux i686)
23:46:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
23:47:25 <dhpeterson> i saw your hs-plugins dynamic plugins package
23:47:33 <dhpeterson> that looked interesting
23:47:37 <dons> cool :) in fact, thats how @eval works
23:48:17 <gour> dhpeterson: it can become a killer feature
23:48:29 <dhpeterson> gour: agree
23:48:38 <dons> also, pugs uses hs-plugins to do inline haskell, iirc
23:48:39 <dhpeterson> my eyes lit up when i saw it
23:48:51 <gour> dhpeterson: and let's help it to become :-)
23:50:01 <gour> with the new optimizations (ghc, jhc), hs-plugin technology, hIDE, guis (gtk2hs,wxghaskell), darcs..if haskell won't catch then..
23:54:08 <dhpeterson> agree
23:54:45 <pejo> gour, the "join efforts of jhc & ghc" is mostly Meacham finding flaws in both of them, no?
