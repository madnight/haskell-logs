00:04:29 <dons> sigh, nhc98:
00:04:29 <dons> OS allocated a heap in high memory (>0x80000000)
00:04:30 <dons>     which breaks this program's run-time system.
00:05:45 <dons> ndm, beelsebob, I need that high byte, don't I?
00:06:40 <dons> high bit, I mean
00:28:20 * dons hackety hacks at the nhc rts
00:53:29 <Lunar^> dons: is it related to the recent OpenBSD malloc changes?
00:57:16 <dons> I think so, yes.
00:57:46 <dons> by replacing malloc-based allocation of the nhc heap, with an mmap allocator given a starting ddress hint, things seem to work :)
00:59:50 <dons> fingers crossed nothing breaks :S
01:05:28 <Lunar^>  :)
01:13:38 <{Arias}> good morning
01:38:04 <Cale> sethk: well, you know you're allowed to write (MonadState m) => a -> m b
01:38:29 <Cale> So long as your function doesn't actually use IO, and only uses get and put, that's okay.
01:38:49 <sethk> Cale, remind me, which question are you answering?
01:38:54 <sethk> :)
01:39:23 <sethk> Cale, never mind, half asleep
01:39:30 <Cale> sethk: the one about which monad to use :)
01:39:45 <Cale> If your function doesn't use IO, it should never have IO in the type
01:39:50 <Cale> that's a good rule
01:40:12 <Cale> State is hard to reason about, and IO is harder
01:40:22 <sethk> Cale, right.  The thing is, I would say that it is close to 50/50, doing things in IO, and doing things that are not IO.
01:40:39 <Cale> really?
01:40:56 <Cale> Well, I can see that possibly happening :)
01:41:21 <sethk> Cale, I can set it up so that I make calls to functions that don't do IO
01:41:31 <Cale> right
01:41:32 <sethk> Cale, while the "main" line, if you will, is doing mostly IO
01:42:01 <sethk> seems then that StateT is not good
01:42:10 <Cale> right, you want to separate the bits which actually manage network and file access from everything else
01:42:43 <basti_> the empty set is a final object in Set, and that means, for every other set, there's a morphism, right?
01:43:08 <Cale> but what I was saying is that if you know that you need state for a computation, but you don't know if you'll directly need it from a StateT IO, you can give it a type like  (MonadState m) => m a
01:43:28 <Cale> basti_: um, no, it's initial.
01:43:35 <basti_> aww.
01:43:41 <sethk> Cale, right, but here is what I'm not seeing exactly.
01:44:04 <sethk> Cale, wait...
01:44:33 <sethk> Cale, I can pass in a state monad, or STRef, and use that value as the initial state when I leave the IO environment
01:44:45 <Cale> basti_: the final objects in Set look like one element sets
01:44:56 <sethk> Cale, well, not exactly
01:44:59 <Cale> (are one element sets rather)
01:45:05 <sethk> Cale, I think I see a way, let me think for a while.
01:45:08 <sethk> Cale, thanks again
01:45:23 <Cale> sethk: okay, you're welcome :)
01:45:43 <Cale> sethk: what is your state?
01:45:53 <basti_> Cale: hmm ok i see...
01:46:39 <Cale> basti_: for every set B, there is a unique function {} -> B.
01:46:39 <sethk> Cale, It's complicated.  I have a list of open cursor values, a list of open files in the back end, a list of intermediate sets while processing a query, etc.
01:46:45 <basti_> ah yes... the unique morphism is the zero-morphism...
01:46:57 <Cale> sethk: hmm...
01:47:00 <sethk> Cale, lot's of lists, lots of binary trees,
01:47:02 <basti_> and for the final object, it's the one that maps everything to the one set member
01:47:08 <sethk> Cale, in other words, bunches of data.
01:47:59 <sethk> Cale, So I will have a type, CqlState, something like this:  data CqlState = CqlState { ofm ::OpenFileMap, ... }
01:48:13 <Cale> hmm...
01:48:21 <Cale> basti_: right
01:48:30 <sethk> Cale, on the client side I'm doing a lot of network I/O.
01:48:41 <sethk> Cale, at the back end I'm doing lots of file IO
01:49:03 <sethk> Cale, there is also a substantial amount of state related to concurrency control and deadlock detection
01:49:33 <Cale> It sounds like enough that you shouldn't need it all at once though.
01:50:04 <sethk> Cale, yes, that's true.  I have a list of open queries.  There is a complex ADT for each open query
01:50:22 <Cale> Which makes me wonder whether it wouldn't be better to split it up into smaller parts, and make sure that only the code which needs a given piece of state will have it, as much as reasonable.
01:50:25 <sethk> Cale, there will be a lot of lists of things.
01:51:11 <sethk> Cale, it still has to live somewhere.  It can live in IORef and/or STRef, or in a StateT, or no doubt other options.
01:51:13 <Cale> If a function doesn't have access to a piece of state, that's one less possibility for a hard to track down bug :)
01:51:25 <sethk> Cale, I agree.
01:51:31 <Cale> It can also live in function parameters
01:52:03 <sethk> Cale, yes, that's true, although in that case I think it actually lives in an IORef
01:52:05 <Cale> (the only issue being where you start passing the same things to every function
01:52:17 <Cale> hm?
01:52:43 <sethk> Cale, a function parameter can specify where to fetch the data, but the parameter can't really be the data.
01:53:35 <Cale> I suppose if you want to say where it is, it would be on the stack, then -- well, on the heap, a pointer to it would be on the stack.
01:54:13 <sethk> Cale, no, that's not what I meant.
01:54:23 <sethk> Cale, all of the data is needed in multiple places
01:54:31 <sethk> Cale, and some of the data is needed in multiple threads
01:54:53 <sethk> Cale, but I have a way of handling it.
01:54:57 <sethk> how does this sound?
01:56:20 <sethk> I create my initial state value.  I call a State monad function, supplying my state as the initial state.  I spawn a separate thread fo this function.  When the data is needed, other threads in the server obtain the data from the state thread
01:57:08 <Cale> hmm...
01:57:16 <sethk> Cale, don't really need the monad for that, though
01:57:20 <Cale> That's doable, but seems indirect.
01:57:23 <sethk> Cale, just pass in an IORef
01:57:41 <Cale> You'd use something like an IORef and an MVar
01:57:56 <sethk> Cale, yes, it is.  But it gets rid of the problem of threading the state through the functions, and it eliminates having to use StateT
01:58:08 <sethk> Cale, right, an IORef and synchronization primitives
01:58:40 <Cale> But it does keep you in the IO monad wherever you need that state
01:58:48 <sethk> right
01:59:24 <sethk> I'm going to code some very brief things with the structure in place, and try it both ways.
01:59:43 <sethk> I think one or the other will be better.
01:59:46 <Cale> hmm...
01:59:49 <sethk> unless both are awful.  :)
02:00:38 <sethk> Cale, using liftIO is not all that bad, with the StateT monad.  that gets rid of the kludgyness
02:01:01 <sethk> there are just a million liftIO calls, but I don't they impose computational overhead.
02:01:04 <sethk> Or do they?
02:01:15 <Cale> Well, the classical way of doing this sort of thing, and one which is still decent, is to just explicitly pass the state into the necessary functions, and return it when (possibly) modified. This is still a good way to at least think about doing things.
02:01:38 <Cale> They shouldn't impose too much -- well, the whole extra monad imposes something.
02:01:58 <Cale> But getting rid of it would be a horrible premature optimisation.
02:02:02 <sethk> Cale, I'm familiar with that.  It just seems to me that the nature of the beast screams for a state monad.
02:02:10 <Cale> okay
02:02:21 <sethk> because of the structure of the code.
02:02:25 <sethk> as in:
02:02:51 <Cale> If you imagine that every function you're working with would reasonably need the state value, and also need to return the state value, then a state monad is sensible.
02:02:58 <sethk> parse statement -> fetch from dictionary -> do query optimization -> do query execution ->    etc.
02:03:29 <Cale> that sounds like pure code, apart from query execution
02:03:57 <Cale> well, parsing can be done in a parsing monad
02:04:05 <sethk> Cale, yes, I know that
02:04:14 <sethk> Cale, forget parsing it's not relevant.
02:04:26 <sethk> Cale, I might be processing a query, or defining a cursor.
02:04:50 <sethk> ultimately the processing that is done is more or less the same.  But the cursor does several blocks and waits, and does a few more, and waits. etc.
02:05:33 <Cale> like lazy IO?
02:05:40 <sethk> Cale, So if I can create a set of combinators, I can reuse them, in query processing, in declare cursor ...
02:05:46 <sethk> Cale, no, not lazy io
02:05:58 <sethk> an CQL cursor is a data structure with an attached query.
02:06:09 <sethk> when you process a query, you do a series of operations.
02:06:51 <sethk> using a cursor, there are separate steps, you set up the cursor, provide it with an sql statement, allow it to do it's thing which is all of the preliminaries before the first fetch.
02:07:08 <sethk> but, every step in cursor processing is also a step in query processing
02:07:35 <sethk> query processing does them front to back.  With the cursor, you do them in groups.
02:07:36 <Cale> okay, so you certainly want to be able to share that code.
02:07:40 <sethk> exactly
02:08:05 <sethk> and the state (or StateT) monad seems idea for that.
02:08:15 <Cale> hmm...
02:08:30 <JohnMeacham> burp. happy octoberfest.
02:08:32 <sethk> I'm going to have to go, which is very unfortunate because I was hoping to talk to you about this.  Can we continue later?
02:08:42 <Cale> sethk: of course :)
02:08:52 <sethk> that will also give me time to sketch a couple of ideas.
02:08:52 <boegel|home> what's octoberfest ?
02:08:58 <JohnMeacham> well, the cheesy american version of it in any case.
02:08:58 <sethk> Cale, thanks again, later
02:09:10 <Cale> sethk: I would really think hard about what bits of the program need to access what state
02:09:23 <basti_> is the empty set isomorph to every set?
02:09:28 <basti_> that strikes me as bizarre.
02:09:29 * boegel|home will be enjoying a sauna with his gf this afternoon
02:09:32 <JohnMeacham> lots of beer. liederhosen. polka music. lots of sterotypes you can drink to.
02:09:33 <Cale> sethk: a lot of what you're saying doesn't *really* sound very stateful
02:09:42 <Cale> but I'm not sure
02:09:47 <boegel|home> JohnMeacham: sounds like, erm, fun
02:10:10 <sethk> Cale, Let me write up some particulars.  We want to know whether it doesn't sound stateful because it isn't, or because I didn't convey the information.
02:10:19 <Cale> sethk: okay
02:10:21 <sethk> 'nigh
02:10:23 <Cale> night
02:28:11 <pesco> morning
02:28:24 <pesco> :)
02:34:23 <basti_> how does one prove that morphisms to 1 are unique?
02:35:13 <pesco> What's 1?
02:35:24 <basti_> the sets with one element
02:37:10 <pesco> So which category is this?
02:37:19 <basti_> The category of sets
02:37:35 <basti_> but the question is valid as well for other categories and their final objects
02:37:47 <basti_> hmm ah you cant prove that category wise can you?
02:37:55 <basti_> its a property of a cat and an object that you prove
02:37:58 <Cale> basti_: functions are sets f of pairs (a,b) in AxB such that for every a in A, there is exactly one b in B such that (a,b) is in f
02:38:45 <basti_> hmm i se
02:38:47 <basti_> e
02:39:02 <Cale> If B has one element, there is no choice whatsoever as to what the corresponding b is for each a in A.
02:39:13 <Cale> (it has to be that one element of B)
02:39:26 <basti_> hmm ok
02:39:58 * basti_ .o° ( and how do i say that in coq?? ;)
02:40:28 <Cale> I don't know coq, but I could try to formalise that further if you'd like.
02:40:50 <basti_> no it's rather a puzzle for me.. i know that the proof must be simple...
02:41:06 <basti_> the trick is that coq is intuitionistic
02:41:12 <Cale> oh
02:41:14 <Cale> heh
02:41:35 <Cale> intuitionistic logic is strange
02:41:41 <basti_> yes but constructive
02:41:53 <basti_> thats the point
02:42:06 <Cale> yeah, but quite different things are true
02:42:18 <Cale> it's not just the constructive part of ordinary mathematics
02:42:20 <basti_> i thought its a subset of classical logic?
02:42:25 <Cale> it's a different mathematics altogether
02:42:32 <basti_> :-°
02:43:08 <basti_> i really thought its a subset.
02:43:13 <Cale> nope :)
02:43:25 <basti_> so whats true in intuitionistic that is not in classical?
02:43:36 * basti_ does the NP-trick with Cale 
02:44:07 <Cale> all functions [0,1] -> R are uniformly continuous
02:44:55 <Cale> hmm, was that it?
02:45:09 <basti_> ah, well, but in classical that would mean: all functions [0,1] having the "classical property" are uniformly continuous
02:45:30 <basti_> simple: i ask you to prove something which is left for me to check ;)
02:45:54 <Cale> well, really it's not comparable
02:45:57 <basti_> (you're the N, i'm the P... every NP problem is like a ND-suggestion and a P-checker)
02:46:01 <basti_> hmm :/
02:46:02 <Cale> the definitions are different
02:46:13 <Cale> so the theorems don't mean the same thing
02:46:34 <basti_> i see
02:51:18 <Cale> Here's a theorem from ordinary mathematics I don't know is provable in constructive mathematics: Every finitely branching infinite tree has an infinite path.
02:52:37 <basti_> thats dependant on the axiom of choice isnt it?
02:52:57 <Cale> no
02:53:06 <basti_> then not :(
02:53:13 <Cale> It's only finitely branching
02:53:27 <basti_> hmm.
02:53:48 <Cale> You don't need the axiom of choice to choose from a finite set
02:54:14 * basti_ nosa
02:54:22 <basti_> ds
02:54:33 <Cale> hm?
02:54:48 <basti_> i wanted to say: /me nods
02:54:53 <basti_> .)
02:54:54 <Cale> ah
02:55:09 <basti_> hey Megz whats up?
02:57:43 <basti_> Cale: btw, i have to reason about functional equality, of course!
02:58:18 <astrolabe_> Cale: Maybe you need AOC if you are choosing from a finite set infinitely many times?
02:58:32 <Cale> oh, yeah, perhaps you need countable choice here
03:01:43 <Cale> Well, hmm...
03:01:54 <basti_> mmh?
03:02:56 <Cale> You can show that there's a path of length n, for every n, easily enough.
03:03:29 <astrolabe_> yes
03:03:37 <Cale> and you can also fix it so that you have a family of paths of length n for every n, such that the path of length k-1 is a subpath of the path of length k
03:04:24 <Cale> so the "diagonal" is an infinite path
03:05:09 <Cale> since any of the adjacent pairs on it is connected, and to witness this, you only need look at one of the finite paths far enough out into the sequence.
03:06:54 <astrolabe_> Cale: how do you fix it to get the subpath property?
03:07:52 <Cale> Call a path v1,v2,v3,...vn /admissible/ if the vertex vn has a subtree which is infinite.
03:08:38 <astrolabe_> Hang on, if a finitely branching tree is infinite, then one of the children of root heads an infinite subtree.
03:08:46 <Cale> right
03:09:19 <Cale> So you pick that vertex, and you extend your admissible path to a new one.
03:09:37 <astrolabe_> Yeah, not that hard once you see it :)
03:09:40 <Cale> also, the root vertex alone is an admissible path
03:10:03 <Cale> this is also exactly how you prove the Bolzano Weierstraß theorem.
03:10:30 <astrolabe_> What is this admissible path business? isn't that too complicated?
03:11:00 <Cale> Well, I wanted to be extra careful that I wasn't going to invoke the axiom of choice by accident.
03:11:06 <astrolabe_> Simply choose at each node, a subnode heading an infinite tree.
03:11:10 <Cale> right
03:11:11 <astrolabe_> Ah ,ok.
03:11:43 <Cale> no "choosing" in the axiom of choice sense needs to be done here
03:11:49 <Cale> only law of excluded middle
03:11:51 <astrolabe_> Sorry, can you complete the proof without AC?
03:12:22 <Cale> Okay, so first off, [root] is an admissible path.
03:12:34 <astrolabe_> Cale: Right!
03:12:59 <Cale> Suppose that no subtree has infinitely many vertices. Then the tree has finitely many vertices. Contradiction.
03:13:30 <astrolabe_> right again
03:14:03 <Cale> So there exists a v_2 adjacent to v_1 = root such that [v_1,v_2] is admissible.
03:14:19 <astrolabe_> yes.
03:14:40 <Cale> Actually, that's not even necessary to say :)
03:14:53 <Cale> Let [v_1,v_2,...,v_n] be an admissible path.
03:15:10 <Cale> Then v_n has a subtree with infinitely many vertices.
03:15:31 <Cale> Let the root of that subtree be v_{n+1}.
03:16:00 <astrolabe_> I think you are going to use AC :)
03:16:03 <Cale> then some subtree of v_{n+1} has infinitely many vertices, by the same argument as for the root.
03:16:28 <astrolabe_> yes. Ok so far.
03:16:44 <Cale> So [v_1,v_2,...,v_n,v_{n+1}] is admissible.
03:16:55 <astrolabe_> right
03:17:34 <Cale> Consider the sequence of paths:
03:17:40 <Cale> [v_1]
03:17:43 <Cale> [v_1,v_2]
03:17:47 <Cale> [v_1,v_2,v_3]
03:17:48 <Cale> ...
03:18:08 <astrolabe_> The whole sequence?
03:18:12 <Cale> yes
03:18:20 <astrolabe_> Doesn't that use choice?
03:18:23 <Cale> no
03:19:05 <astrolabe_> If I have a sequence of non-emply sets: S1,S2,...
03:19:26 <astrolabe_> Then I can pick e1 in S1.
03:19:32 <astrolabe_> Then e2 in S2
03:19:39 <Cale> and so on, but that's not what I'm going to do
03:19:45 <astrolabe_> and get a sequence e1,e2,...
03:19:50 <Cale> I'm actually just going to pick the last one
03:20:00 <astrolabe_> But you have picked all of them
03:20:01 <Cale> So I don't need the axiom of choice :)
03:20:19 <Cale> Claim: [v_1,v_2,v_3,...] is a path.
03:20:23 <astrolabe_> There isn't a last one, it's an infinite sequence.
03:20:35 <Cale> no, the last element of each finite path in that sequence
03:21:18 <astrolabe_> But the sequence itself doesn't exist without choice.
03:21:22 <Cale> no
03:21:24 <Cale> it does
03:21:38 <Cale> You can have functions from N to various sets without needing choice
03:21:41 <astrolabe_> Does my sequence e1,e2,... exist without choice?
03:21:48 <Cale> not necessarily
03:22:01 <Cale> If I have a rule for doing the picking, then I don't need choice.
03:22:10 <astrolabe_> What is your rule?
03:22:28 <Cale> Pick the last member of the path.
03:22:49 <Cale> in fact, I don't even need to bother with that at all
03:22:52 <astrolabe_> You need to choose a decendent for a node.
03:22:57 <Cale> I can just say:
03:23:09 <Cale> The path [v_1, v_2, v_3, ...]
03:23:49 <astrolabe_> Cale: but that relies on the existence of the sequence v1,v2,...
03:23:52 <Cale> because the v's remain the same throughout the construction, and eventually every n in N gets mapped to v_n
03:24:13 <Cale> I showed that v_n exists in some admissible path, right?
03:24:23 <Cale> admissible, finite path
03:24:41 <Cale> and then I built longer and longer paths
03:24:46 <astrolabe_> You showed you could find a finite sequence of any length.
03:24:49 <Cale> right
03:25:05 <Cale> moreover, they were completely contained in one another
03:25:26 <Cale> So the v_5, once chosen, was always the same.
03:25:56 <Cale> (I didn't need axiom of choice to choose it, because there were finitely many things to choose from)
03:27:04 <astrolabe_> I'm confused I admit.  I've forgotten too much, and will need to think.
03:27:38 <astrolabe_> So why does my set version fall over?
03:28:27 <Cale> Well, do you agree that one only needs the axiom of infinity to get something like the set {0,1,2,3,...}
03:28:41 <Cale> in fact, that's what the axiom of infinity gives you
03:28:50 <astrolabe_> yes
03:28:51 <bourbaki> moin
03:28:57 <Cale> morning :)
03:28:58 <astrolabe_> hi bourbake
03:29:06 <astrolabe_> bourbaki I mean :)
03:29:11 <bourbaki> :)
03:29:12 <Cale> hmm...
03:29:28 <Cale> But you are right, that this is somewhat odd. :)
03:29:38 <Cale> I think that I'm only using induction.
03:30:28 <Cale> We show that for each n in N, there is a path P_n with n elements such that P_n \ P_{n-1} is a singleton.
03:30:34 <xerox> Howdy!
03:30:39 <Cale> hiya
03:30:58 <astrolabe_> Cale: right.
03:31:15 <astrolabe_> But you are trying to use the same path for all N.
03:31:24 <Cale> no, they're different
03:31:35 <Cale> it's just that P_{n-1} is contained in P_n
03:32:08 <astrolabe_> I mean, you are using subsequences of an N-independent sequence.
03:32:14 <Cale> So I'm saying that the path n |-> union (P_n \ P_{n-1}) (the union unpacks the singleton)
03:32:21 <Cale> is the path we're looking for
03:32:32 <Cale> haven't yet shown that it's a path, but that's easy
03:33:08 <bourbaki> what do you try to proove?
03:33:13 <astrolabe_> There is a different between for all N there exists P_1.,,,P_N
03:33:36 <astrolabe_> and there exists P_1,... such that for all N ...
03:33:50 <Cale> The P's are my paths
03:34:05 <Cale> P_k = [v_1,...,v_k]
03:34:09 <bourbaki> Cale: astrolabe_ what do you try to proove?
03:34:25 <Cale> which is really the function from {1,2,...,k} to the vertex set of my tree.
03:34:26 <astrolabe_> Cale is trying to show that every tree with infinitely many nodes contains an infinite sequence, without using the axiom of choice
03:34:37 <Cale> and finite branching
03:34:57 <astrolabe_> Cale: I don't accept it when you say 'the P's'
03:35:05 <astrolabe_> They don't exist.
03:35:09 <Cale> Hm?
03:35:19 <bourbaki> why dont you use the multiplication of adjacency matrices for that
03:35:20 <astrolabe_> Ooops sorry, yes with finite branching :)
03:35:58 <bourbaki> if you multiply these you will never get something like A^k = A^(k+1) and all As are non negatice
03:36:01 <bourbaki> er negative
03:36:21 <Cale> How can your check that the product is defined?
03:36:24 <Cale> you*
03:36:45 <Cale> and that you don't eventually reach a maximum?
03:36:51 <bourbaki> well the matrix would be A /in M(inv,inv)
03:37:01 <Cale> hm?
03:37:06 <astrolabe_> bourbaki: ok so they are all non-neg, how do you know there is a sequence from that?
03:37:20 <bourbaki> the ajacency matrix is invinitly bit
03:37:23 <bourbaki> dang big
03:37:44 <bourbaki> and everytime you multiply the matrix with itself you get the new paths in that graph
03:37:53 <Cale> I suppose that you can guarantee convergence
03:37:59 <Cale> on the elements
03:38:01 <Cale> of A^k
03:38:09 <bourbaki> if its infinitely big it wont converge
03:38:29 <Cale> I mean that the elements of A^k are defined for each k
03:38:41 <bourbaki> ah yes but thats easy to see
03:38:51 <Cale> well, it needs some checking
03:38:52 <astrolabe_> Adjacency matrices just encode easier stuff.  I think they obscure the issue.
03:38:59 <bourbaki> you can proove that easly we have done that in graph algos
03:39:19 <bourbaki> well but its an easy way to do what you want i think
03:39:19 <Cale> bourbaki: but doesn't this count walks and not paths?
03:39:42 <bourbaki> Cale: you just get the number of paths there are from one node to another each step
03:39:46 <Cale> Oh, I suppose we can make the trees directed away from the root.
03:40:03 <bourbaki> you can use that technique for cycle checks and to see if you graph is a tree for example
03:40:10 <astrolabe_> bourbaki: how does this help?
03:40:15 <bourbaki> and you need that for the transitive graph
03:40:38 <bourbaki> astrolabe_: you wanted to show that there are infinitely many branches right?
03:40:42 <Cale> astrolabe_: A^n counts the number of walks of length n between two vertices.
03:41:05 <astrolabe_> bourbaki: no.  There are only finitely many at each node, by defn
03:41:06 <bourbaki> right
03:41:10 <Cale> but I think this makes things harder computationally :)
03:41:21 <bourbaki> and if you sum these matrices up you get the transitive graph
03:41:37 <bourbaki> i didnt say its computationaly the best way
03:41:46 <bourbaki> its just an idea for an easier proove
03:41:50 <astrolabe_> We want to show that there is an infinite sequence where each elt is a child of its predicessor.
03:41:50 <Cale> you have to check that each element of A^k is well-defined, and that A^k contains an entry which is equal to k
03:41:57 <Cale> and I don't know how you're going to do that
03:41:57 <bourbaki> you dont want to calculate proofs anyway :)
03:42:30 <bourbaki> well that A is welldefined is easy
03:42:30 <Cale> er
03:42:40 <Cale> actually, you want A^k to contain a nonzero entry
03:42:56 <bourbaki> and then showing that there always is an A^(k+1) is also easy i think
03:43:00 <Cale> So how do you show that A^k is never the 0 matrix?
03:43:08 <Cale> this is equivalent
03:43:15 <bourbaki> if it was then the tree would be finite
03:43:22 <Cale> also, you *must* direct the edges of the tree
03:43:24 <Cale> no
03:43:27 <bourbaki> thats following form your axion that its infinite
03:43:28 <bourbaki> yes it is
03:43:36 <bourbaki> k is the length of the path
03:43:41 <Cale> Suppose that it's infinitely branching...
03:43:52 <bourbaki> an infinite tree is defined as a graph where k = oo
03:44:04 <Cale> what?
03:44:26 <bourbaki> if G is a tree with infinite nodes
03:44:41 <Cale> No, it's defined as an acyclic graph with a vertex set which is infinite
03:44:47 <bourbaki> then A^k =! A^(k+1) is always true
03:45:01 <Cale> um, prove that?
03:45:05 <astrolabe_> I'm going to the yummy french bakery before they run out of yummy things.  Back in 1/2 hour.
03:45:09 <Cale> okay
03:45:11 <bourbaki> if it has no cycle then there is at least one infinite path
03:45:24 <Cale> astrolabe_: anyway, you don't need AC, afaict
03:45:34 <Cale> astrolabe_: you just construct an appropriate function
03:45:45 <bourbaki> i mean you have to be able to traverse all the infinite nodes
03:45:51 <bourbaki> and they have to be connected
03:45:55 <bourbaki> otherwise it wont be a tree
03:45:57 <Cale> bourbaki: why?
03:46:04 <bourbaki> thats the definition of a tree
03:46:10 <bourbaki> all nodes need to be connected
03:46:15 <bourbaki> and the graph is cycle free
03:46:16 <Cale> oh
03:46:19 <Cale> yes
03:46:24 <dons> could someone try to ftp ftp://ftp.cs.york.ac.uk/pub/haskell/nhc98/nhc98-1.18-library-interfaces.tar.gz
03:46:26 <bourbaki> from that follows that there is an infinitely long path
03:46:34 <Cale> a connected acyclic simple graph is a tree
03:46:35 <dons> just to see if its not just me
03:46:44 <bourbaki> and from this follow that A^k , k = oo
03:46:58 <bourbaki> and thus there is no fixed point
03:47:07 <Cale> but not every connected acyclic simple graph with infinitely many vertices has an infinite path.
03:47:17 <bourbaki> but there doenst necessarily need to be finite branching not infinite
03:47:31 <bourbaki> cause it could be a string or a binary tree
03:47:40 <Cale> bourbaki: I don't understand at all.
03:47:59 <bourbaki> Cale: why not i mean if it has infinitely many nodes
03:48:06 <Cale> Not every connected acyclic simple graph with infinitely many vertices has an infinite path. The finite branching is absolutely necessary.
03:48:24 <bourbaki> then you need an infinitely long path to connect them all
03:48:29 <Cale> Consider the graph with vertex set N, and with edge set {{0,1},{0,2},{0,3},...}
03:48:48 <bourbaki> ok a starlike graph?
03:49:11 <Cale> This is a simple graph, as it has no loops, and it's acyclic, and it's clearly infinite.
03:49:20 <bourbaki> yes
03:49:35 <Cale> But the vertex 0 has infinitely many neighbours.
03:49:42 <bourbaki> right
03:49:50 <Cale> So you really do need that condition.
03:49:51 <bourbaki> ah ok i see what you mean
03:49:59 <bourbaki> you are right sorrry
03:50:31 <Cale> no problem
03:50:41 <bourbaki> but i have a counterexample for the finite brachning also
03:50:58 <bourbaki> take your graph and do that starlike branching in each leave again
03:51:10 <bourbaki> still a tree but non finite branching
03:51:48 <Cale> yeah, and it still fails the infinite path property
03:52:28 <bourbaki> yes true but i thought you wanted to show that each tree with infinite nodes has a finite branching factor
03:52:42 <Cale> um, that's false
03:53:05 <Cale> My original graph contradicts that
03:53:15 <bourbaki> oh heh right :)
03:53:29 <bourbaki> ok then im a bit confused what did you want to show again?
03:53:50 <Cale> That every tree with finite branching and infinitely many vertices contains an infinite path.
03:54:05 <Cale> Here's the standard proof.
03:54:38 <bourbaki> hm
03:55:16 <bourbaki> wont you need over coutably many nodes for that?
03:55:22 <Cale> nope
03:55:33 <Cale> You start with some vertex.
03:55:35 <Cale> v_1
03:55:36 <bourbaki> so its like in the hilbert hotel thingy?
03:55:48 <Cale> Then you know that there are finitely many neighbours of v_1
03:55:56 <bourbaki> oh dang i should read the senctences propperly :)
03:56:00 <bourbaki> finite branches
03:56:44 <Cale> one of them must be the root of an infinite tree (with v_1 deleted, say)
03:57:27 <Cale> This is easier to state if we fix a root vertex.
03:57:54 <Cale> Let v_1 be the root. Then one of the subtrees hanging from v_1 is infinite.
03:58:36 <Cale> If not, then they're all finite, say wth c_1,...,c_k vertices respectively.
03:58:52 <Cale> So the whole tree has 1 + c_1 + ...+ c_k vertices
03:59:01 <Cale> which is a contradiction, since we said it's infinite
03:59:07 <bourbaki> ah ok
03:59:23 <Cale> So pick v_2 which is the root of an infinite subtree.
03:59:48 <Cale> by the same argument as before, we can pick a v_3, and so on.
04:00:00 <Cale> (formally, we're using induction)
04:02:39 <bourbaki> @seen esap
04:02:40 <lambdabot> I saw esap leaving #haskell 1 day, 14 hours, 6 minutes and 15
04:02:40 <lambdabot> seconds ago, and I have missed 59 seconds since then.
04:04:04 <bourbaki> Cale: do you know if these arrow operations directly map to category theory operations?
04:08:26 <Cale> Arrows correspond to somewhat special categories.
04:08:36 <Cale> Freyd categories, I think they're called.
04:08:56 <Cale> (I assume you're talking about Hughes arrows)
04:09:32 <bourbaki> yep well i thought that ie the &&& operator looks quite like the ct product
04:14:02 <astrolabe_> I'm back, the walk has cleared my head, and I'm now sure that you need AC!
04:17:43 <bourbaki> and you also need the DC :)
04:18:23 <astrolabe_> DC?
04:18:34 <bourbaki> AC/DC :)
04:18:39 <astrolabe_> Hey, I'm using italics.  How did that happen?
04:18:42 <astrolabe_> groan!
04:18:43 <bourbaki> and then you can rock all night long ;)
04:18:50 <Cale> heh
04:18:59 <Cale> Maybe CC
04:19:06 <Cale> but surely not full AC
04:19:26 <bourbaki> whats ac?
04:19:32 <Cale> Axiom of choice.
04:19:36 <astrolabe_> Yeah, countable choice will do.
04:19:36 <bourbaki> ah
04:20:19 <astrolabe_> I think I was letting you get away with sloppy defn by induction.
04:20:19 <Cale> But I'm not sure where exactly it applies, as all that I'm doing is defining a set inductively.
04:20:45 <astrolabe_> I channlange you to state what your inductive statement is.
04:20:47 <Cale> Or recursively, if you'd like.
04:20:54 <astrolabe_> *challange
04:21:27 <Cale> If there is an admissible path in T of length n, then there is an admissible path in T of length n+1
04:21:45 <Cale> Or perhaps you mean:
04:21:53 <astrolabe_> Sorry, I meant what is f_n
04:22:10 <astrolabe_> So here you mean there is an admissible path of length n.
04:22:21 <Cale> yes
04:22:24 <astrolabe_> Which I agree with for all n.
04:22:29 <Cale> okay
04:22:44 <bourbaki> nighto guys
04:22:50 <Cale> night
04:22:55 <astrolabe_> But you then went on to use that that the different length paths are sub-paths
04:22:58 <astrolabe_> night night.
04:23:12 <Cale> right, I did use that
04:23:34 <Cale> sorry the statement is actually more :)
04:24:09 <astrolabe_> Hah yeah, but I think you will have difficultly pinning it down!
04:24:46 <Cale> hmm
04:26:42 <astrolabe_> Oh no, I'm going to stuck in italics for the rest of my life :(
04:26:46 <Cale> hm?
04:26:58 <Cale> Well, I seem to need some recursion.
04:27:05 <Cale> Which might not be valid.
04:27:23 <Cale> So that is maybe where CC creeps in.
04:28:17 <Cale> Apparently you can't show that the statement "X is infinite" is equivalent to "there is a bijection between X and a proper subset of X" without countable choice :)
04:29:02 <Cale> oh, rather CC implies that
04:29:07 <Cale> from ZF
04:29:11 <Cale> but ZF doesn't
04:29:21 <Cale> However, that's weaker than CC>
04:29:30 <astrolabe_> Hmm.
04:29:45 <astrolabe_> Hooray.  Back on a normal font somehow.
04:30:10 <Cale> That is, there's a model of ZF where countable choice fails, but every infinite set is in bijection with a subset of itself.
04:30:14 <astrolabe_> You can still define things inductively without choice I think.
04:30:38 <Cale> yes
04:31:22 <Cale> but I need to recurse here, to say that there is an admissible path of length n which contains the admissible path of length n-1
04:32:47 <astrolabe_> You can show that for any n, there are a sequence of 'concentric' paths of length 1,2,...,n.
04:33:11 <Cale> but I can't reuse that sequence when I go to n+1
04:33:20 <Cale> for some strange reason
04:33:26 <Cale> This is odd...
04:33:28 <astrolabe_> Cale: right! weird isn't it.
04:33:45 <Cale> since I'd expect to be able to define a set recursively with N
04:34:26 <Cale> (N itself is defined recursively, but apparently just having it isn't enough to do this yourself?)
04:34:42 <Cale> I'm not completely convinced yet.
04:34:57 <astrolabe_> There is no choice involved when you define N.
04:35:04 <Cale> Though I do suspect some instance of CC getting in somewhere
04:35:11 <Cale> Well, it's axiomatic
04:35:21 <Cale> N exists by fiat, usually :)
04:35:27 <dons> @seen goron
04:35:28 <lambdabot> I saw goron leaving #haskell 14 hours, 10 minutes and 53 seconds ago.
04:35:48 <astrolabe_> There is an axiom in some set theories that if S is a set, so is {S}.
04:36:10 <astrolabe_> They let you define N.  Perhaps I'm mis-remembering.
04:37:09 <Cale> Well, you need some way to get hold of that set, but I'm pretty sure that doesn't give you N
04:37:57 <Cale> In ZF, it's axiom of the unordered pair used in a trivial way that gives you {x}
04:38:22 <astrolabe_> Yeah, I think I'm muddled again :(
04:38:53 <Cale> But you still need the axiom of infinity, which says that there exists N such that the empty set is in N, and that for all x in N, we have x union {x} in N.
04:39:33 <astrolabe_> Cale: right, that is one way to define the natural numbers.
04:40:12 <astrolabe_> You could also use {},{{}},{{{}}},...
04:40:37 <Cale> right, but you can't get the set of those
04:40:49 <Cale> unless you add something
04:41:03 <Cale> which is the axiom of infinity
04:41:19 <astrolabe_> right.
04:41:48 <Cale> It's actually more convenient to use the x union {x} definition of successor, because you then get that n has n elements :)
04:43:15 <astrolabe_> Cale: yeah.  Have you read Halmos?
04:43:52 <Cale> no, though I'm pretty sure I've paged through his book before
04:44:31 <astrolabe_> I thought it was a really excellent introduction.  Must be very old now.
04:44:37 <astrolabe_> But still good.
04:45:45 <Cale> http://mathworld.wolfram.com/Zermelo-FraenkelAxioms.html -- heh, as stated, these are either missing an axiom or are circular
04:45:53 <astrolabe_> crumbs expensive though http://www.amazon.co.uk/exec/obidos/ASIN/0387900926/qid=1129981483/sr=1-1/ref=sr_1_8_1/026-5778571-9456438
04:46:16 <Cale> yes, I've definitely looked through that
04:46:24 <Cale> the pure math club had a copy
04:47:37 <astrolabe_> Why are they missing an axiom or circular?
04:48:18 <Cale> The axioms on mathworld leave out the axiom of the empty set. They explain how to get it from infinity and comprehension, but if you look, infinity uses the empty set in its definition.
04:49:02 <astrolabe_> Ha. That's amuseing.  The humblest axiom.
04:50:14 <Cale> I think I'll comment :)
04:50:46 <dons> are their defns mechanically checked somehow?
04:50:51 <Cale> no
04:51:07 <astrolabe_> Cale, hang on a mo
04:51:10 <Cale> they're definitions anyway :)
04:51:18 <astrolabe_> It isn't circular
04:51:23 <Cale> hm?
04:52:03 <astrolabe_> You can test whether a set is the empty set without knowing that the empty set exists.
04:52:44 <Cale> Well, it says (Ø in S) as part of the predicate there
04:52:45 <astrolabe_> Actually 6 says that there is a set which contains the empty set.
04:52:59 <astrolabe_> Which implies that the empty set exists.
04:53:03 <Cale> right, but nothing there defines Ø
04:53:30 <astrolabe_> No, but the axioms aren't definitions.
04:54:09 <Cale> are you meaning to say that Ø is a free variable?
04:54:10 <astrolabe_> You could add a definition of the empty set, but it wouldn't be an axiom.
04:54:45 <Cale> Well, something has to catch the symbol Ø
04:55:00 <astrolabe_> The symbol is defined at the top of the page.
04:56:01 <astrolabe_> You could just consider it as a shorthand for a proper definition.
04:56:04 <Cale> Well, not just as part of the alphabet.
04:56:12 <xerox> Yow.
04:56:22 <Cale> By this, Ø could contain an element.
04:56:27 <astrolabe_> Hia xerox.
04:56:40 <xerox> Hællo :)
04:57:03 <Cale> :)
04:57:19 <astrolabe_> It says '' 'funny phi' is the empty set''
04:57:32 <astrolabe_> You are assumed to know what that means.
04:58:01 <astrolabe_> But if you got pedantic, they could replace it with its definitions in each of the axioms where it is used.
04:58:07 <Cale> yes
04:58:26 <Cale> Or simply reinstate that extra axiom :)
04:58:55 <dons> if only the maths guys had type checkers :)
05:00:08 <astrolabe_> The axiom was about its existence rather than its defn.
05:00:31 <astrolabe_> It would be superfluous, but possibly more aesthetically pleasing.
05:02:23 <astrolabe_> dons: In set theory, everything has the same type! (well almost).
05:02:52 <Cale> Everything is a set. I suppose there are proper classes, but they can always be removed from proofs.
05:02:56 <xerox> I think there exist typed set theory, developed somehow against-Gödel ;-)
05:03:01 <dons> nah, I was just making a general point about using mechanical means to check things
05:03:09 <dons> esp. proofs
05:03:10 <Cale> There are also class functions, but they can be boiled away as well.
05:03:54 <skew> I just had a crazy idea: argument inference
05:05:13 <dons> astrolabe_, a la http://www.cl.cam.ac.uk/Research/HVG/Isabelle/dist/library/ZF/index.html
05:07:30 <astrolabe_> Wow, is that a system for checking maths?
05:08:13 <dons> Isabelle is a generic theorem proving environment, the most popular one.
05:08:20 <dons> people contribute proofs of various logics as libraries
05:08:25 <dons> including maths
05:08:40 <dons> but also it's good for, say, checking soundness of type systems
05:09:34 <xerox> 'soundness' ?
05:10:01 <dons> type systems are logics, you wouldn't want them to go wrong in corner cases
05:10:09 <Cale> http://metamath.org/
05:10:34 <xerox> Which is isomorphic to metalogic.org? :-)
05:10:37 <dons> same with operational semantics of programming langs. these are great things to prove mechanically
05:10:47 <Cale> It's a good example of getting carried away with a formal system :)
05:10:47 <dons> you want to be sure your rts spec is sound
05:11:11 <xerox> What's the meaning of 'sound' in this context?
05:11:28 <dons> no bugs
05:11:48 <Cale> http://us.metamath.org/mpegif/mmset.html#trivia
05:12:54 <Cale> the complete proof of 2 + 2 = 4 involves 2,109 subtheorems
05:12:56 <syntaxfree> @pl a == b+x
05:12:57 <lambdabot> a == b + x
05:12:58 <xerox> Cale: that site is INSANE
05:13:04 <syntaxfree> @pl f a b x = a == b + x
05:13:05 <lambdabot> f = (. (+)) . (.) . (==)
05:13:16 <xerox> I was talking about it yesterday with my cousin, my gosh, there actually is people who _do_ it :-)
05:13:21 <Cale> Yes, personally, I think it's a ridiculous waste of time, but if people have fun doing it...
05:13:36 <syntaxfree> hmm.
05:13:36 <dons> here for example, mechanically checkable proofs about thhe lambda cube, so we can rest assured that JHC isn't based on the wrong axioms. http://www.cl.cam.ac.uk/Research/HVG/Isabelle/dist/library/Cube/Cube.html
05:13:47 <syntaxfree> where does metamath start from?
05:14:00 <Cale> ZFC
05:14:07 <dons> the twelf guys are in the business of formalising ML in the twelf prover, which is along the same lines, xerox
05:14:19 <xerox> Woot...
05:14:23 <syntaxfree> zermelo-frankel choice axiom?
05:14:40 <Cale> syntaxfree: yes
05:15:08 <dons> a guy I work with implemented ghc's Core language inside the twelf prover and then established various safety properies
05:15:15 <dons> so that was good to know about ghc.
05:15:19 <Cale> The related pages on physics are good, but perhaps too much. I'd rather see *more* physics formalised to a *lesser* extent.
05:15:25 <dons> man it evaluated haskell slowly though ;)
05:16:41 <Cale> really, they just did a bunch of stuff that's essentially mathematics, and doesn't get into the particulars of axioms/theorems from physics.
05:17:12 <syntaxfree> "There you have it, the axioms for (essentially) all of mathematics! Wonder at them and stare at them in awe. Keep a copy in your wallet and memorize them, and you will hold in your brain the encoding for all theorems ever proved and that ever will be proved, from the most mundane to the most profound."
05:17:21 <syntaxfree> hehe. I want a t-shirt with the zfc axioms.
05:17:34 <Cale> It probably already exists
05:17:38 <syntaxfree> Cale: that's mathematical physics for you.
05:17:56 <syntaxfree> Mathematical physics is usually stuck in giving mathematical rigidity to stuff physics has known for some time now.
05:18:26 <syntaxfree> Not too different from mathematical economics, except more involved, as in needing more mathematics to it.
05:18:46 <Cale> Yes, because physicists refuse to say what they mean, and rather say something which is sort of, but not quite what they mean, and which if interpreted literally, is actually inconsistent.
05:18:51 <syntaxfree> though ergodic theory is irreversibly creeping its way into mathematical economics.
05:19:21 <Cale> (or not even defined)
05:19:24 * dons attempts a powerpc bootstrap of ghc
05:19:42 <xerox> overflow? ;-)
05:21:42 <araujo> Morning!
05:21:51 <syntaxfree> cale: I like your style. Let's start a company.
05:22:10 * xerox will cairo-render the logo
05:22:39 <dons> morning ndm
05:22:45 <ndm> dons, morning
05:22:52 <syntaxfree> is Cairo hard? I've been doing image generation outputting PPM files.
05:23:01 <xerox> It's very, very handy!
05:23:02 <ndm> have been up for hours actually, but housemate was bittorrenting, so IRC kept cutting out
05:23:08 <Cale> Cairo via gtk2hs is nice :)
05:23:10 <ndm> you'll be happy to know i'm hacking hoogle3 :)
05:23:25 <dons> i've been busy porting nhc to powerpc/openbsd, and have hit a couple of issues
05:23:25 <dcoutts> Cale, :-)
05:23:26 <syntaxfree> I don't want gtk!
05:23:28 <xerox> ndm++ !
05:23:35 <syntaxfree> Cale: hey, answer me!
05:23:46 <dons> could I get your comment on the mail I sent to nhc-bugs@  ?
05:23:47 <Cale> syntaxfree: shapr already asked :)
05:24:00 <syntaxfree> oh, too bad :-P
05:24:04 <dcoutts> syntaxfree, you can use cairo without gtk for outputting to .png files
05:24:07 <Cale> syntaxfree: but what would your company do?
05:24:13 <syntaxfree> dcoutts: that's better.
05:24:19 <dons> ndm, unfortunately, at the moment i've got some nasty segfault, so I'm stuck for a little while. i'll have to think further about it tomorroow.
05:24:31 <Cale> and would you be interested in writing a strategy combinator library for RTS games?
05:24:39 <ndm> i don't subscribe to nhc-bugs
05:24:40 <syntaxfree> Cale: we basically go to angel VCs, drop our brilliant eccentric minds' contents on them, they get enthusiastic, and give us money.
05:24:41 <Cale> (or working on one)
05:24:46 <syntaxfree> Then we sell our stock and pull out.
05:24:50 <dcoutts> heh
05:24:52 <dons> ndm, oh. ok. sorry for bugging you then :}
05:24:53 <Cale> heh
05:25:06 <ndm> dons, nah - i will look it up in teh archive
05:25:09 <dons> i'm not sure about who's read-up on nhc src at the moment
05:25:09 <ndm> it should really subscribe
05:25:15 <Cale> ndm: once hoogle 3 is done, you should make it a hIDE plugin :)
05:25:19 <dons> oother than malcolm
05:25:21 <ndm> Cale, i will
05:25:26 <dons> Cale, it's on the todo list for hIDE :)
05:25:27 <ndm> dons, Tom is pretty well versed
05:25:43 <dons> let's hope he's on the nhc-bugs@ list then :)
05:25:44 <syntaxfree> Cale: a combinator library for RTS games sounds cool, but my Haskell skillz aren't quite there yet.
05:26:16 <syntaxfree> a couple of months from now I'll be doing m4d h4ck1ng.
05:26:27 <syntaxfree> then I'll talk to you again :)
05:26:46 <ndm> dons, that looks good :)
05:27:07 <ndm> Tom probably knows most about the runtime
05:27:19 <dons> right. cheers
05:27:30 <ndm> this bug is one of the reasons for yhc, it fixes this bug  by rewriting the entire runtime...
05:27:46 <dons> yeah, I remember we talked about it at icfp
05:28:05 <dons> allocating lower down the addr space seems also reasonable ;)
05:28:25 <ndm> yep, that is also good
05:28:26 <syntaxfree> do you find that knowing C beforehand helped you learn  Haskell?
05:28:28 <ndm> how portable is that code?
05:28:43 <ndm> syntaxfree: knowing every additional language helps you when you learn a new one
05:28:44 <xerox> syntaxfree: quite the opposite
05:28:58 <pesco> syntaxfree: I didn't feel it hindered me.
05:29:00 <dons> that's probably unix specific, but it's easy enough to grab the rest of the portability gunk from MBlock.c in ghc
05:29:03 <syntaxfree> I'm worried that I never worked in a larger software project either.
05:29:12 <dons> good point though, ndm.
05:29:15 <Cale> syntaxfree: yeah, hindered
05:29:18 <xerox> syntaxfree: I think you should not worry about it.
05:29:36 <Cale> basically, you have to learn to ignore what you knew about C for a while
05:29:37 <ndm> at york, all the machines allocate with the hi-bit set, so no one has been running nhc for some time now...
05:29:37 <syntaxfree> I mean, say,if I went and tried to hack something into lambdabot, I fear I wouldn't know my way around the codebase even if I was already minor-wizardly in Haskell.
05:29:49 <Cale> then later on, it will start attaching in your head
05:30:11 <Cale> but at first, thinking about Haskell using what you know about C is bad
05:30:23 * syntaxfree doesn't know no C
05:30:40 <Cale> do you have previous programming exprerience?
05:30:43 <dons> ndm, argh :S
05:30:43 <syntaxfree> I did some programming in BASIC as a child.
05:31:00 <Cale> ah, that should be easy enough to ignore, eh?
05:31:03 <syntaxfree> and then became serious again about programming about a year ago, with Python and later Scheme.
05:31:12 <dons> syntaxfree, lambdabot's particularly easy. it has a plugin structure, so you don't need to know much about anything to write a lambdabot plugin :)
05:31:23 <Cale> scheme might transfer somwhat
05:31:25 <syntaxfree> ah, I also hacked the odd PHP/MySQL thing over the years because my parents needed it.
05:31:27 <Cale> somewhat*
05:31:34 <dons> my mum could write a lambdabot plugin :)
05:31:50 <syntaxfree> yes, I know. I have a "The same code in Scheme and Haskell:" ongoing project, remember? ;-)
05:31:53 <xerox> O_O
05:31:59 <pesco> dons: My mum did. j/k
05:32:07 <syntaxfree> Python transfers a lot, too. I was doing really functional stuff in Python.
05:32:23 <dons> hehe
05:32:24 <syntaxfree> with maps and filters and list comprehensions and no loops.
05:32:26 <Cale> yeah, possibly, though I think you'll need a different view of data
05:32:37 <Cale> oh, possibly
05:32:51 <syntaxfree> the type system got in my way a little in the beginning, but I'm already "getting it".
05:32:53 <Cale> python is usually considered to be OO
05:33:09 <syntaxfree> Mark Jones' "Functional programming with overloading and type classes" helped a lot in picking up the theory.
05:33:24 <Cale> After a little while, the type system actually serves as a highway to writing the right code.
05:33:39 <dons> and the type system is *great* for coding while sleepy
05:33:52 <dons> you just hack any garbage together, and let the checker deal with it
05:33:58 <Cale> There's less possible things to write, so it's easier to find the one you want.
05:34:56 <syntaxfree> anyway, it's not really the language-learning part that worries me, but the software engineering one.
05:35:38 <syntaxfree> I'm finding myself coding things I couldn't before. Very quickly, too.
05:35:41 <ndm> syntaxfree: that takes experience
05:35:41 <astrolabe_> That is a cool quote dons.  You should publish it.  I'm always sleepy.
05:35:49 <ndm> and being wrong about a million times
05:36:03 <syntaxfree> I can't fathom how anyone gets anything done without higher-order functions.
05:38:05 <Cale> syntaxfree: I went off and coded that pipeline scheduler I probably mentioned shortly after learning Haskell. Well, it had been maybe a year or so.
05:38:43 <syntaxfree> I don't know what a pipeline scheduler is.
05:39:11 <syntaxfree> I think I get the idea intuitively, but I'm not sure.
05:40:22 <Cale> Ah, it takes a graph representation of a computation, expressed in terms of assembler, and decides the best order to run the instructions, given that the code is going to be operating in parallel, mapping over a list, on the same processor. The processor is broken into units which can only do one thing at a time.
05:40:22 <dons> hmm. this must be the easiest port of ghc i've ever done.
05:41:15 <syntaxfree> hmm.
05:41:18 <syntaxfree> interesting.
05:41:51 <syntaxfree> I think I wanna go over the lambdabot source.
05:42:03 <syntaxfree> sounds like a good place to start playing with a larger project.
05:42:15 <dons> @version
05:42:16 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
05:42:16 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:42:17 <dons> go for it!
05:42:21 <Cale> In addition to this, my code dealt with multiple ways to compute the same intermediate value, picking between them based on what parts of the processor were more available than others.
05:42:25 <skew> dons: how much of the RTS would I need to understand to drop in epoll instead of select?
05:42:26 <dons> think of a plugin you'd like to write, or one you'd like to improve
05:42:42 <dons> hmm, skew, could be tricky. select is used for some subtle thingies
05:42:57 <dons> at least check the discussions about select on the lists first,
05:43:00 <skew> I thought there was just one call?
05:43:30 <syntaxfree> I'd like to have a fact-list.
05:43:31 <dcoutts> skew, I've thoguht about that too
05:43:53 <dcoutts> skew, I think it'd need a different internal api for the place where select/epoll is used
05:44:00 <Cale> syntaxfree: anyway, that was quite successful, and we ended up with code to compute sine/cosine pairs at a rate of 2.7 clocks/float
05:44:01 <dons> ah, I see it is only 1 call
05:44:15 <Cale> (as scheduled by my code)
05:44:24 <syntaxfree> I'll try it ;-)
05:44:29 <Cale> as well as part of a general compiler
05:44:33 <skew> I got as far as finding the call, but I didn't understand all the stuff around it
05:44:34 <dcoutts> skew, since epoll wants an interface where you register interest in a fd. Select is to gather things and use them in one shot.
05:44:56 <dcoutts> skew, and it's different between the single threaded and multi-threaded rts
05:45:17 <dons> ah, and epoll is a linuxism
05:45:28 <dcoutts> skew, you might find it easier to look at the multi-threaded rts version
05:45:48 <dcoutts> skew, because it does the IO manager stuff in Haskell via the FFI rather than in C in the RTS
05:45:49 <skew> I think I was looking at the single-threaded version
05:46:09 <syntaxfree> Cale: cool. Sines and cosines are useful :)
05:46:55 <skew> The idea was to get more performance for handling *lots* of concurrent connections in a server where we could stand a bit of customization to make it fast
05:47:09 * syntaxfree loves spouting truisms no one can disagree with.
05:47:20 <syntaxfree> it's best when they're trivial, too.
05:48:34 <skew> Has anybody here tried Nemerle? The stuff about macros having access to the typechecker sounds really nice
05:48:35 <Cale> syntaxfree: yeah, my code is part of a compiler being worked on for a high-level signal processing language.
05:48:52 <autrijus> rehi
05:49:04 <Cale> syntaxfree: the idea is somewhat like generalising the methods used to construct FFTW
05:49:17 <syntaxfree> ahhh yes,  I see.
05:49:22 <dons> syntaxfree, so you know we already have a fact plugin?
05:49:43 <dons> SamB I think worked implemented it in its current form
05:49:54 <syntaxfree> yes. But no one teaches it anything!
05:50:10 <dons> sorry, no, it was jlouis
05:50:14 <syntaxfree> I'm always going "@fact Haskell"  "I don't know anything about Haskell".
05:50:21 <Cale> everyone teaches where
05:50:26 <syntaxfree> Anyway, now it knows what haskell is, anyway. I taught him that.
05:50:35 <Cale> @fact Haskell
05:50:36 <lambdabot> haskell: Haskell is the language of choice for discriminating
05:50:36 <lambdabot> hackers..
05:50:44 <dons> yep.we have @where for src projects, and wikipedia, foldoc and google for all else
05:51:15 <syntaxfree> Something that annoys me about fact is that it adds a period.
05:51:28 <dons> considering the success of @where, it may be that these kind of things only work if you populate the db fairly well first
05:51:30 <syntaxfree> So all my facts have double periods.
05:51:49 <syntaxfree> dons: anyway, sounds like a fairly simple place to start.
05:51:57 <dons> maybe patch getFact:         Just x  -> fact ++ ": " ++ x ++ "."
05:51:59 <dons> ;)
05:52:29 <syntaxfree> I might want to add fact-search, too.
05:52:31 <Cale> @code
05:52:32 <lambdabot> Unboxed.hs: -----------------------------------------------------------------------------
05:52:36 <Cale> wow
05:52:40 <Cale> profound
05:52:49 <syntaxfree> but I'll start with fixing that pesky period and adding fact-list.
05:52:52 <xerox> :-}
05:53:06 <dons> making @code a bit more fun would be good too :)
05:53:06 <dons> @code
05:53:07 <lambdabot> Bits.hs: infixl 8 `shift`, `rotate`, `shiftL`, `shiftR`, `rotateL`, `rotateR`
05:53:13 <dons> yay, kind of better
05:53:14 <xerox> Cale: It's like "unboxed haskell?  no comment"
05:53:31 <syntaxfree> maybe the pesky period fix could first probe if the last character of the string is a period.
05:53:44 <xerox> syntaxfree: do it!
05:54:03 <syntaxfree> how do I pick up the last character of a string, short of doing   let last string = string !! (length string) ?
05:54:10 <xerox> @type last
05:54:14 <lambdabot> forall a. [a] -> a
05:54:21 <xerox> @eval last []
05:54:23 <lambdabot>  add a type signature that fixes these type variable(s)
05:54:27 <xerox> @eval last [] :: Int
05:54:29 <lambdabot> Prelude.last: empty list
05:55:03 <Cale> beware of the function [a] -> a
05:55:25 <syntaxfree> @eval let fixperiod string = if ((last string) == ".") then string else string ++ "."  in fixperiod "This sentence has no period"
05:55:26 <lambdabot> Couldn't match `[Char]' against `Char'
05:55:40 <syntaxfree> @eval let fixperiod string = if ((last string) == '.') then string else string ++ "."  in fixperiod "This sentence has no period"
05:55:41 <lambdabot> "This sentence has no period."
05:55:47 <Cale> for it may contain trappes and sprynges of great variety and harm
05:55:52 <dons> hehe
05:56:16 <dons> @remember Cale Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
05:56:17 <syntaxfree> jesus, fink is royally broken.
05:56:23 <xerox> @eval let f xs | last xs == '.' = "Yes." | otherwise "No." in f ""
05:56:24 <lambdabot>  parse error on input `in'
05:56:24 <syntaxfree> I might as well manually get darcs.
05:56:33 <xerox> @eval let f xs | last xs == '.' = "Yes." | otherwise = "No." in f ""
05:56:34 <lambdabot> Prelude.last: empty list
05:56:47 <syntaxfree> yes, I know about guards ;-).
05:56:55 <syntaxfree> I think you might need a semicolon between guards.
05:57:12 <xerox> You don't, I was pointing out the exception.
05:57:15 <syntaxfree> oops. no you didn't.
05:57:34 <syntaxfree> I never try guards in one-liners. That's why I used the ugly if then else.
05:57:39 <Cale> @eval let f xs | null xs == "Null." | last xs == '.' = "Yes." | otherwise = "No." in f ""
05:57:40 <lambdabot>  parse error on input `|'
05:57:46 <dons> wow, I've almost finished the openbsd/powerpc port of ghc, and *not one thing has gone wrong*
05:57:49 <Cale> @eval let f xs | null xs = "Null." | last xs == '.' = "Yes." | otherwise = "No." in f ""
05:57:51 <lambdabot> "Null."
05:58:12 <syntaxfree> @eval let fixperiod string = if ((last string) == '.') then string else string ++ "."  in "I never try guards in one-liners. That's why I used the ugly if then else."
05:58:13 <lambdabot> "I never try guards in one-liners. That's why I used the ugly if
05:58:13 <lambdabot> then else."
05:58:27 <syntaxfree> @eval let fixperiod string = if ((last string) == '.') then string else string ++ "."  in ""
05:58:29 <lambdabot> ""
05:58:37 <Cale> syntaxfree: you don't need parens around the conditional
05:58:48 <syntaxfree> @eval let fixperiod string = if ((last string) == '.') then string else string ++ "."  in fixperiod ""
05:58:49 <lambdabot> Prelude.last: empty list
05:59:16 <syntaxfree> oh, ok. I'll add the null case when I have guards. Too lazy to nest ifs right now :-P
05:59:29 <Cale> @eval let fixperiod string = if null string then "" else if last string == '.' then string else string ++ "."  in fixperiod ""
05:59:30 <lambdabot> ""
05:59:35 <Cale> @eval let fixperiod string = if null string then "" else if last string == '.' then string else string ++ "."  in fixperiod "Hello"
05:59:36 <lambdabot> "Hello."
05:59:38 <Cale> @eval let fixperiod string = if null string then "" else if last string == '.' then string else string ++ "."  in fixperiod "Hello."
05:59:40 <lambdabot> "Hello."
06:00:14 <dons> sigh, just when I thought nothing would go wrong: Linker.c:1306:6: #error ocAllocateJumpIslands doesnt want USE_MMAP to be defined
06:00:24 <syntaxfree> hmm.  I could just use "or".
06:00:53 <xerox> You can't
06:00:55 <Cale> syntaxfree: hm?
06:01:02 <Cale> how?
06:01:07 <syntaxfree> @eval let fixperiod string = if ((null string) or (last string == '.')) then string else string ++ "."  in fixperiod ""
06:01:09 <lambdabot>   The function `(null string)' is applied to two arguments,
06:01:09 <lambdabot>   but its type `Bool' has none
06:01:09 <lambdabot>   In the predicate expression: ((null string) or ((last string) == '.
06:01:09 <lambdabot> '))
06:01:16 <ndm> dons, you posted "nothing has gone wrong" - its entirely your fault
06:01:25 <dons> ndm, so true!
06:01:25 <Cale> ah
06:01:29 <dons> @eval last []
06:01:30 <lambdabot> Add a type signature
06:01:32 <Cale> ||
06:01:36 <dons> I like my terse error msgs :)
06:01:52 <dons> unless someone can think of a super-tricksy defaulting scheme for runplugs/@eval ?
06:01:58 <Cale> @eval let fixperiod string = if null string || last string == '.' then string else string ++ "."  in fixperiod ""
06:01:59 <lambdabot> ""
06:02:01 <dons> for, like, 5 @karma points...
06:02:02 <xerox> (||) does not short-circuit?
06:02:20 <Cale> it does
06:02:25 <xerox> Ah, woops.
06:02:28 <Cale> like all Haskell functions :)
06:02:46 <Cale> well, most
06:03:03 <syntaxfree> @google darcs
06:03:04 <xerox> dons: ":: Int" and you're done <grin>
06:03:05 <lambdabot> http://abridgegame.org/darcs/
06:03:17 <dons> xerox, ok, that's the trivial soln.
06:03:22 <dons> but perhaps we could use Dynamics...
06:03:29 <xerox> No karma for xerox
06:03:32 <dons> it has to be done at runtime, in userland
06:03:39 <basti_> karmacoma?
06:03:43 <dons> so a typecase soln could work..
06:03:57 * dons scratches chin and ponders
06:04:08 * syntaxfree screams at boegel. Heeeeey, add my south park doll already.
06:04:51 <dons> so, since we already have a monomorphic restriction on @eval code (it has to be Showable) then it's not so bad to also add a Typeable constraint
06:05:00 <dons> wrap the code in Dynamic, and do a typecase
06:05:16 <dons> ah, but if it isn't monomorphic, we can't wrap it in the first place. grr
06:05:29 <dons> and if we can't wrap it, we can't add our own runtime coerce
06:05:37 <dons> hmm tricky
06:06:04 <dons> @eval typeOf (toDyn 1)
06:06:05 <lambdabot> Add a type signature
06:06:12 <dons> @eval typeOf (toDyn (1::Int))
06:06:14 <lambdabot> Dynamic
06:06:30 <dons> @eval typeOf (1::Int)
06:06:32 <lambdabot> Int
06:06:38 <dons> @eval typeOf (1)
06:06:40 <lambdabot> Add a type signature
06:06:45 <xerox> @type typeOf
06:06:46 <lambdabot> bzzt
06:06:58 <dons> @type Data.Typeable.typeOf
06:06:59 <lambdabot> forall a. (Data.Typeable.Typeable a) => a -> Data.Typeable.TypeRep
06:07:25 <dons> so the problem is that the user already has to add the type sig before I could even begin to wrap this thing
06:07:40 <dons> hmm. TH to the rescue..
06:08:10 <dons> inspect the abs syn of the fragment, and add a type sig based on the normal defaulting rules perhaps...
06:08:13 <dons> that would be cool
06:08:52 <dons> I'll write a TMR article, "Userland type defaulting for the masses"
06:08:58 <dons> "with class"
06:09:12 * xerox pokes dons
06:09:23 <dons> oh, sorry, was I rambling agaain?
06:09:37 <xerox> Ah, you said you'll write! :-D
06:09:48 <syntaxfree> my fink is so broken I can't get darcs.
06:10:00 <Cale> you need to work typeclasses in in order to be allowed to use that bad pun
06:10:16 <syntaxfree> oh lord, why can't we get an official Apple-sanctioned unix packaging system for OS X?
06:10:59 <dons> Cale, oh, already I've said I'll use typeOf, which is in the Typeable class. close enough for me ;)
06:11:34 <dons> it worries me that this requires either compile time metaprogramming, or polymorphic dynamics
06:11:37 <dons> interesting problem.
06:12:00 <Cale> well, it's already an issue of metaprogramming in some sense
06:12:05 <dons> oh, and it's being used to solve a runtime metaprogramming issue..
06:12:09 <dons> yeah, right :)
06:12:58 <araujo> @index fromJust
06:12:59 <lambdabot> Data.Maybe
06:27:10 <syntaxfree> @version
06:27:11 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
06:27:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:27:25 <dcoutts> dons, what does this report on your BSD system: pkg-config --libs mozilla-gtkmozembed
06:29:37 <dons> -pthread -L/usr/local/mozilla -lgtkembedmoz -lxpcom -lplds4 -lplc4 -lnspr4
06:30:13 <dcoutts> dons, ok and I guess that /usr/local/mozilla is not in your LD runtime path?
06:30:43 <dons> not by default, I don't think
06:30:44 <dcoutts> and /usr/local/mozilla does indeed contain all the mozilla .so files right?
06:30:48 <dons> yep
06:30:52 <dcoutts> ok thanks
06:31:11 <dons> /usr/local/mozilla/lib/
06:31:18 <dcoutts> oh?
06:31:21 <dcoutts> what's that
06:31:41 <syntaxfree> yay!
06:31:45 <dons> mozilla needs its own silly dir for some reason
06:31:49 <dons> so, ls /usr/local/mozilla/lib/libgtkembedmoz.so.3.0
06:31:50 <syntaxfree> Mingus:~ syntax$ darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:31:51 <syntaxfree> Copying patch 48 of 576...
06:32:32 <dcoutts> dons, oh that's not good. That mean -L/usr/local/mozilla is wrong. It means we will not find the libs at link time right?
06:32:39 <dons> ah!
06:33:17 <dons> oh, but they're also symlinked in /usr/local/mozilla/
06:33:20 <dons> so it's ok
06:33:22 <dcoutts> ah ok
06:33:34 <dcoutts> but that path is not on the runtime ld search path
06:33:39 <dons> no
06:33:49 <dons> not unless I add it somehow
06:33:53 <dcoutts> so it means pkg-config is still not giving us the right info
06:34:05 <syntaxfree> dons: so are you running in the so-called Linus mode? ;-)
06:34:11 <dcoutts> dons, so the hack in the gtk2hs build system is still necessary
06:34:30 <dons> dcoutts, but things seem to be ok. is there a test I can perform?
06:34:40 <dcoutts> dons, we have to add -Wl,-rpath/usr/local/mozilla
06:34:47 <dons> ah, yes.
06:34:51 <dons> that's what you need.
06:35:05 <dcoutts> dons, that's because the gtk2hs build system alreay uses a similar hack, that's whay it works at the moment
06:35:25 <dcoutts> I noticed on my system with a newer mozilla that the pkg-config actually gives that right flags
06:35:25 <dons> ok.
06:35:34 <dcoutts> so I'm changing the way the hack works
06:35:36 <dons> syntaxfree, linus mode? on openbsd!? ;)
06:36:38 <dcoutts> dons, If I ask you nicely will you try out the gtk2hs-0.9.10 release candidate? it'll be out today or monday.
06:36:48 <dons> yes :)
06:36:51 <dcoutts> ta
06:37:00 <dons> i had to build gtk2hs a couple of times yesterday anyway :)
06:37:04 <dcoutts> heh
06:37:05 <dons> it doesn't take so long these days
06:37:09 <dcoutts> yes
06:37:34 <dcoutts> you can use ./configure --with-hcflags=-O0 to make it build quicker
06:38:52 <dons> ok, so ghc is happy with my custom linker hacks, and is now continuing on its way. oooh.. maybe this compiler port will only need 1 fix :D
06:40:46 <neologism> anyone here able/willing to help me with some FA taks?
06:43:13 <syntaxfree> dons: do I still need hs-plugins to compile lambdabot?
06:43:22 <dons> of course
06:43:33 <syntaxfree> well, I can't seem to compile hs-plugins.
06:43:35 <dons> it's a plugin-based app :)
06:43:40 <dons> oh, why not?
06:44:10 <syntaxfree> trying to follow from here: http://haskell.org/hawiki/LambdaBot_2fInstallation
06:44:17 <dons> hmm. possibly you can avoid the plugin dependency with: make way=static
06:44:52 <dons> oh, you need to: chmod 700 configure
06:44:54 <dons> in hs-plugins
06:44:56 <syntaxfree> so I go search the wiki for what this "runhaskell" is, and apparently it's a haskell interpreter.
06:45:06 <dons> sure. you don't have it?
06:45:11 <syntaxfree> nope.
06:45:13 <dons> not an interpreter, a wrapper over ghci
06:45:17 <syntaxfree> I tried to use ghci.
06:45:19 <syntaxfree> ahh. I see.
06:45:21 <Lemmih> Or hugs.
06:45:22 <dons> ok, try: ghc -o setup Setup.hs
06:45:24 <syntaxfree> I have to go get runhaskell.
06:45:34 <syntaxfree> I tried.
06:45:36 <dons> then run: ./setup configure and so on
06:45:41 <syntaxfree> Setup.hs won't compile.
06:45:55 <dons> ok hmm. what ghc version are you using?
06:45:59 <syntaxfree> "Failed to load interface for `Distribution.Simple':"
06:46:17 <syntaxfree> Mingus:~ syntax$ ghc --version
06:46:18 <syntaxfree> The Glorious Glasgow Haskell Compilation System, version 6.2
06:46:26 <dons> $ ghc -o setup -package Cabal Setup.hs
06:46:35 <dons> oh, you'll need 6.4 for lambdaobt
06:46:48 <syntaxfree> ghc-6.2: unknown package name: Cabal
06:46:49 <syntaxfree> hmm. ok.
06:46:54 <dons> and it uses Cabal too, so you would need that, unless you update to 6.4
06:46:59 <syntaxfree> yeah.
06:47:04 <syntaxfree> um, I have to fix fink first then.
06:47:13 <syntaxfree> otherwise it'll be a mess, as the current ghc is installed by fink.
06:47:16 <dons> I think lambdabot uses some type trickery that requires 6.4
06:47:21 <syntaxfree> such a fuss!
06:47:35 <dons> oh well. install ghc by hand, it aint too hard, esp. on linux
06:48:15 <syntaxfree> it'll probably conflict in weird ways to the version installed by Fink.
06:48:35 <dons> not if you install it in ~/
06:48:41 <syntaxfree> Such are the ways of Darwin Mingus.local 7.9.0 Darwin Kernel Version 7.9.0: Wed Mar 30 20:11:17 PST 2005; root:xnu/xnu-517.12.7.obj~1/RELEASE_PPC  Power Macintosh powerpc
06:48:44 <syntaxfree> true.
06:48:49 <dons> i have 6.4.1 and 6.5 in ~/ and 6.2.2 in /usr/local
06:48:55 <syntaxfree> hmm. good.
06:48:58 <syntaxfree> @where ghc
06:48:59 <lambdabot> http://haskell.org/ghc
06:48:59 <dons> oh, and you're on the mac, so things are harder already
06:49:26 <dons> we'll see how this works... but you should get Wolfgang Thaller's ghc 6.4.1 package, I think
06:50:15 <syntaxfree> @google wolfgan thaller ghc
06:50:17 <lambdabot> No result found.
06:53:15 <ndm_> @google wolfgang thaller ghc
06:53:16 <lambdabot> http://www.mail-archive.com/cvs-all@haskell.org/msg20811.html
06:55:22 <syntaxfree> hey, I'm worrying in vain.
06:55:37 <syntaxfree> there's a .pkg installer for 6.4
06:55:48 <syntaxfree> 6.4.1, too.
06:59:16 <syntaxfree> what is an Array?
06:59:38 <dons> an array
07:00:52 <dons> night all!
07:00:57 <syntaxfree> oh. now I understand!
07:00:59 <syntaxfree> g'night.
07:01:25 <basti_> syntaxfree: uhm, acually it's an array. What's the problem there?
07:01:49 <syntaxfree> no problem at all :)
07:01:52 <astrolabe_> syntaxfree: like an array in C
07:02:05 <astrolabe_> but also different
07:02:13 * Cale looks for prior uses of the word Array
07:02:46 <Cale> Array i e is the type of arrays with index type i and element type e
07:03:19 <Cale> To be a useful index type, i must be an instance of the class Ix
07:03:31 <Cale> which is defined in the prelude
07:06:41 <syntaxfree> ghc sure is a big download.
07:08:58 <ndm_> syntaxfree: hugs isn';t exactly small nowadays either...
07:10:03 <syntaxfree> I don't remember.
07:10:16 <syntaxfree> I installed Hugs the first time I went around playing with Haskell.
07:10:41 <syntaxfree> that was about a year ago. I quickly gave it up. But, anyway, back then everyone told me I'd be better off with GHC.
07:10:47 <ndm_> windows or linux?
07:11:01 * ndm_ uses Hugs for everything
07:11:08 <syntaxfree> Back then it was Windows.
07:11:20 <ndm_> you really have been corrupted since then...
07:11:27 <syntaxfree> why?
07:11:40 <ndm_> going from Windows+Hugs to Linux (I guess)+GHC
07:11:58 <ndm_> its like going from being a jedi to a murderer ;)
07:11:59 <syntaxfree> I own a Mac now :)
07:12:06 <ndm_> ah, will forgive you then
07:12:27 <ndm_> since you can't use the cool winhugs on mac
07:12:36 <syntaxfree> I was one of the hordes that went and bought a mini. But I have a story behind that.
07:12:46 <ndm_> i was very tempted...
07:13:01 <syntaxfree> import taxes for computers are expensive, in Brazil.
07:13:13 <syntaxfree> a friend went to the US and just put the computer in his backpack.
07:13:25 <ndm_> nice :)
07:13:33 <syntaxfree> It ended up being half the price what I'd pay for a similarly-powered x86.
07:14:10 <syntaxfree> I did use Winhugs. What's so cool about it?
07:15:13 <Cale> ndm is working on a cooler version of winhugs
07:17:45 <ndm_> http://www-users.cs.york.ac.uk/~ndm/projects/winhugs.php
07:17:49 <ndm_> it looks very pretty
07:17:56 <ndm_> and has nice features like jumping to error messages
07:18:03 <syntaxfree> WOW. GHC requires 250 megs of RAM
07:18:05 <ndm_> and its massively faster than ghc for development
07:18:19 <ndm_> esp on my 128Mb computer, GHC just hits swap and eats the dust
07:18:33 <ulfdoz> syntaxfree: GHC even doesn't compile with 64 MB RAM + 128MB of swap.
07:18:47 <syntaxfree> s/RAM/HD space.
07:18:57 <ndm_> WOW, that is a lot
07:19:01 <ndm_> did you build from source?
07:19:09 <syntaxfree> I have 256, and I never had any kind of trouble with ghc.
07:19:24 <syntaxfree> I keep it running large computations in the background, and listen to music/watch movies.
07:19:50 * syntaxfree hugs the mini
07:19:55 <Cale> Package: ghc6
07:19:55 <Cale> Priority: optional
07:19:55 <Cale> Section: devel
07:19:55 <Cale> Installed-Size: 81532
07:19:58 <dcoutts> ulfdoz, syntaxfree, you can limit ghc's memory use with ghc +RTS -M64m -RTS
07:19:59 <Cale> 81MB
07:20:26 <Cale> as for RAM, it depends on what you're doing with it
07:20:44 <dcoutts> and you can make it take much less memory when building ghc if you turn off the objcplit feature. That makes ld take a lot of memory.
07:20:54 <Cale> <syntaxfree> s/RAM/HD space.
07:21:20 <syntaxfree> freudian slip.
07:21:50 <ndm_> dcoutts, what does that feature do?
07:21:54 <Cale> though where are you getting the 250MB number -- on my system it's less than 100
07:22:42 <syntaxfree> Cale: that's what the installer told me.
07:22:51 <syntaxfree> "It will take 250 megs of space".
07:22:56 <Cale> off
07:22:58 <Cale> odd*
07:23:42 <Cale> Haskell needs more antarctican users
07:24:23 <astrolabe_> What does DSL stand for?
07:24:30 <ndm_> domain specific language
07:24:31 <Cale> domain specific language
07:24:34 <goron> @fact DSL
07:24:35 <lambdabot> I know nothing about dsl.
07:24:38 <astrolabe_> Thanks
07:24:45 <Cale> @help fact
07:24:45 <lambdabot>  @fact <fact>, Retrieve a fact from the database
07:24:48 <Cale> @help fact+
07:24:49 <lambdabot>  @help <command> - ask for help for <command>
07:24:52 <syntaxfree> @fact-set domain specific language
07:24:52 <lambdabot> Fact recorded.
07:24:56 <Cale> @help factmodule
07:24:57 <lambdabot>  @help <command> - ask for help for <command>
07:25:00 <syntaxfree> @fact-remove domain specific language
07:25:01 <lambdabot> Unknown command, try @listcommands.
07:25:02 <Cale> ah, fact-set
07:25:12 <syntaxfree> @fact-set DSL Domain specific language
07:25:13 <lambdabot> Fact recorded.
07:25:29 <Cale> @listcommands
07:25:30 <lambdabot> use listcommands [module|command], please. Modules are:
07:25:30 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
07:25:30 <lambdabot> haddock help hoogle karma lambda localtime more pl plugs quote
07:25:30 <lambdabot> search seen spell state system todo topic type version vixen
07:25:30 <lambdabot> where
07:25:32 <syntaxfree> I'm gonna make some improvements to fact today.
07:25:34 <Cale> @listcommands fact
07:25:35 <lambdabot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-
07:25:35 <lambdabot> update
07:25:42 <syntaxfree> fact-delete domain
07:25:44 <Cale> @fact-delete domain
07:25:45 <lambdabot> Fact deleted.
07:28:33 <Cale> augh, they subtly changed the locations of all the hierarchical library docs
07:29:12 <Cale> Is RSS capable of expressing something like that?
07:29:29 <ndm_> Cale, yes - but it would be b etter just not to move them...
07:29:38 <Cale> I have bookmarks to every page there.
07:29:57 <ndm_> you can always set up your own url forwarder
07:30:29 <ndm_> i think hoogle will have to have one anyway, so a url hoogledocs?module+Data.Map will always stay valid
07:32:55 <syntaxfree> so, after I went all the way to get ghc 6.4.1 ...
07:33:07 <syntaxfree> hs-plugin's  Setup.hs won't compile.
07:35:32 <ndm_> what error message?
07:37:43 <syntaxfree> ah, nevermind. I tried runghc instead and its okay.
07:38:05 <syntaxfree> Run GHC sounds like a good name for a nerdcore rap group.
07:38:15 <syntaxfree> We're gonna diss MC Hawking.
07:39:52 <chucky> :D
07:41:14 <ulfdoz> syntaxfree: I think you mean THC?
07:42:10 <basti_> lets have a rhymes battle in #haskell-blah
07:42:17 <dcoutts> ndm_, the objsplit thing is to allow more to be stripped when linking ghc pakckage libs. So it gives smaller executables.
07:50:06 <Cale> It would be nice if there were some facility for building a bookmarks.html from the current GHC packages installed on my machine.
07:51:48 <SamB> which did what?
07:52:15 <Cale> Built a tree of bookmarks to haddock documentation for all the modules in the hierarchy
07:53:27 <Lemmih> Wouldn't that be really easy to hack?
07:53:47 <neologism> are you any skilled with kleens algebra?
07:54:04 <Cale> Should be not so hard to write.
07:54:20 <Cale> neologism: as in regular expressions?
07:54:48 <neologism> yes, kind of
07:55:12 <neologism> regular expressions are just one of the kleens algebras
07:56:46 <neologism> I have to proof that (a*)* = a*
07:56:48 <Cale> okay, looking at the definition in Wikipedia, I can deal with that
07:56:54 <neologism> do you think that
07:56:59 <neologism> [16:50] <@neologism> (a*)* = a*
07:56:59 <neologism> [16:50] <@neologism> a**a** = a*
07:56:59 <neologism> [16:50] <@neologism> a*a* = a*
07:56:59 <neologism> [16:50] <@neologism> a* = a*
07:57:02 <neologism> is the proof?
07:58:13 <Cale> um, could you put each of those steps in terms of a theorem you know?
07:58:26 <Cale> (or an axiom)
07:58:28 <neologism> yes.. in theorems
07:58:32 <neologism> but not in axioms
07:58:42 <neologism> this seems very easy to me
07:59:16 <neologism> if I were forced to use axioms I would not be able to prove that
08:01:21 <Cale> Which axioms are you using?
08:01:32 <Cale> (just for *)
08:02:16 <Cale> same as those on wikipedia?
08:02:42 <neologism> I doint use axioms
08:02:56 <neologism> there's a theorem which states that a** = a*
08:02:59 <neologism> and a*a* = a*
08:03:05 <neologism> and a* = a*a*
08:03:06 <Cale> Well, you must have had the word "Kleene algebra" defined for you.
08:03:30 <neologism> kleene algebra has some axioms and you can derive some theorems from the axioms
08:03:46 <neologism> and I used those 2 derived theorems - a*a* = a* and a** = a*
08:03:47 <Cale> yes, of course
08:03:51 <Cale> um
08:04:00 <Cale> I don't think it's fair to use a** = a*
08:04:08 <Cale> since that's what you're trying to prove
08:04:13 <Cale> isn't it?
08:04:19 <neologism> I dont think so
08:04:43 <Cale> a** is the same thing, up to notation, as (a*)*
08:04:44 <neologism> (a*)* != a**
08:04:49 <Cale> what?
08:04:53 <neologism> or is it?
08:04:54 <SamB> neologism: how do they differ?
08:05:03 <Cale> how is it anything else?
08:05:07 <neologism> hm.. when I think about it...
08:05:09 <Cale> Well, give some axioms
08:05:14 <basti_> what is "*" for you?
08:05:25 <neologism> * is an operation
08:05:36 <Cale> lots of things are operations
08:05:37 <ndm_> neologism: i do lots of work with regular expressions
08:05:45 <syntaxfree> * is an operator.
08:05:46 <neologism> ndm_: this is not a regular expression
08:05:55 <neologism> * is unary operation
08:05:58 <basti_> a special one or an arbitary?
08:06:00 <ndm_> regular expressions are a type of kleene algebra
08:06:02 <neologism> . and + are binary operators
08:06:09 <syntaxfree> ?
08:06:11 <ndm_> (i mean REAL regular expressions, not perl style ones)
08:06:12 <basti_> or one where we know some properties?
08:06:20 <neologism> I have only scripts in czech language ;(
08:06:28 <SamB> what is a kleen algebra?
08:06:28 <ndm_> neologism: you need a set of axioms
08:06:34 <neologism> yes.. I have the set
08:06:37 <neologism> but in czech language
08:06:42 <Cale> Translate :)
08:06:42 <neologism> ie. not usefull for you
08:06:56 <ndm_> Salomaa 1966 is what most people use as their set of axioms
08:07:05 <Cale> Is wikipedia accurate in this regard?
08:07:18 <neologism> w8
08:07:25 <neologism> www.stud.fit.vutbr.cz/~xdivac02/tin1.pdf
08:07:28 <neologism> page 13
08:07:31 <neologism> there is a set of axioms
08:08:23 <ndm_> yeah, they are the salomaa ones
08:10:51 <ndm_> but missing a** -> a*, i think
08:11:05 <neologism> I have to prove that a** = a*
08:11:11 <neologism> so it hardly be an axiom ;)
08:11:17 <neologism> ...can be...
08:11:37 <Cale> of course it's not, since it's not in that list
08:11:37 <syntaxfree> what is an "algebra"?
08:11:44 <syntaxfree> I know what an algebra of probabilities is.
08:11:49 <ndm_> from those rules, i can't see how to prove it
08:11:51 <syntaxfree> I've studied mathematical probability.
08:11:58 <neologism> syntaxfree: do you know what "group" is?
08:12:00 <syntaxfree> but I don't understand the more general meaning of "algebra".
08:12:02 <Cale> syntaxfree: a wide variety of things, but usually something with an addition and multiplication.
08:12:05 <syntaxfree> kind of.
08:12:12 <syntaxfree> I know what an abelian group is.
08:12:25 <neologism> group is a tuple (S, 1, .)
08:12:26 <ndm_> possibly using A.12 and A.13, if you proved it twice from both directions
08:12:29 * resiak contemplates a joke about a grape.
08:12:44 <Cale> The most common definition is as a vector space with a multiplication which makes it a ring in a way that scalar multiplication agrees with ring multiplication in a nice way.
08:12:48 <neologism> ndm_: I dont understrand a.12 and a.13
08:12:54 <Cale> but that doesn't agree with this case
08:13:04 <syntaxfree> that doesn't fit a probability algebra.
08:13:09 <Cale> There are also algebras of sets
08:13:12 <ndm_> the <= is a subset notation in this case
08:13:20 <neologism> algebra is a structure where you have 3 operations (two binary and one unary) and two fixed points
08:13:26 <neologism> (one for each binary operation)
08:13:38 <neologism> + set on which you define those operations
08:13:40 <Cale> neologism: We'd call that a ring.
08:13:44 <neologism> this is algebra
08:13:47 <neologism> ah...
08:13:52 <neologism> I dont have american education ;)
08:14:28 <Cale> neologism: but lots of things like that are algebras :)
08:14:42 <neologism> algebra is terminus technicus
08:15:02 <neologism> its something like "function"
08:15:10 <neologism> its not something concrete is just a structure
08:15:22 <neologism> anyway - I wonder how to prove that ;(
08:17:11 <neologism> found something ;)
08:18:21 <Cale> you have to use A12 and A13, there's no other way to remove *'s
08:18:43 <neologism> do you understand what 12/13 says?
08:18:45 <neologism> I dont
08:19:15 <ndm_> i do
08:19:19 <neologism> tell me pls
08:19:47 <Cale> think of them as regular expressions and <= as subset as ndm said earlier, and those become somewhat obvious
08:20:02 <ndm_> b+ac <= c   `implies`   a*b <= c
08:20:11 <ndm_> so for example:
08:20:23 <ndm_> a+aa* <= a*
08:20:26 <ndm_> implies
08:20:35 <ndm_> a*a <= a* as well
08:20:50 <neologism> well, but its an implication
08:20:53 <neologism> you cannot reverse that
08:20:56 <ndm_> you can
08:21:02 <ndm_> you can do it twice, once from both end
08:21:13 <ndm_> and you get a bi-implication, hence an equality
08:21:28 <neologism> I dont get it
08:21:35 <neologism> how do you turn an implication into equality?
08:21:48 <Cale> b + ac <= c means that everything in b is in c, and that concatenating things in a to things in c results in things in c.
08:22:32 <neologism> the last sentence on page 13 says
08:22:35 <Cale> so it's somewhat natural that we should be able to take something in b and concatenate as many things from a to the front of it as we want
08:22:48 <neologism> the <= is defined as a <=b ~  a+b = b
08:22:49 <Cale> and end up with something in c
08:22:52 <Cale> right
08:23:01 <neologism> so it can be rewritten as
08:23:07 <Cale> a <= b means that the union of a and b is equal to b
08:23:38 <neologism> (b + ac) + c = c `implies` (a*b + c) = c
08:24:23 <Cale> that's a lot less natural to work with though
08:24:41 <syntaxfree> well, I've got sunshine in my stomach
08:24:42 <Cale> Think of a, b, and c as sets of strings.
08:24:46 <syntaxfree> er, I mean, I've got hs-plugins working.
08:24:52 <syntaxfree> but compiling lambdabot fails.
08:25:07 <syntaxfree> ld: archive: /usr/local/lib/plugins-0.9.10/libHSplugins-0.9.10.a has no table of contents, add one with ranlib(1) (can't load from it)
08:25:15 <Cale> a <= b means that every string in a is also a string in b.
08:25:22 <Cale> a + b is the union of the sets
08:25:33 <SamB> syntaxfree: apparantly an OS X/cabal problem
08:25:52 <SamB> or just a common problem with building things on OS X...
08:25:57 <Cale> ab is the set of all possible concatenations of a string in a and a string in b
08:26:01 <integral> + is set union, <= is subset of, and juxtaposition is set product?
08:26:21 <Cale> yes, associative set product
08:26:21 <neologism> how can I use this to prove what I have to prove?
08:26:40 <Cale> well, it should give you the right outlook :)
08:26:55 <syntaxfree> hmmm. I apparently did "ranlib /usr/local/lib/plugins-0.9.10/libHSplugins-0.9.10.a"
08:26:55 <Cale> also, look at what ndm wrote
08:27:01 <Cale> he basically gave you half the proof
08:27:07 <neologism> uhm?
08:27:09 <neologism> so I didnt get it
08:27:21 <syntaxfree> and it finished the make.
08:30:48 <Cale> neologism: well, if you know that a <= b then wherever you have a + b, you can just replace this with b, right?
08:31:21 <neologism> uhm?
08:31:27 <neologism> how do you get this?
08:31:39 <neologism> or.. how does this apply to my problem?
08:31:41 <neologism> I dont see it
08:31:46 <ndm_> by the definition of <= at the bottom
08:31:48 <Cale> a <= b means a + b = b
08:32:12 <neologism> yes, but how can I apply this?
08:32:22 <ndm_> you can rewrite A.12 and A.13 using the rule at the bottom
08:32:33 <neologism> yes... but?
08:33:15 <Cale> Well, once you have some inequalities, you can simplify a particular expansion of a** which uses A10 and distributivity.
08:33:38 <neologism> I still have no clue where to start ;)
08:33:55 <Cale> Okay, you have a** -- what applies to it?
08:34:18 <neologism> this is what I dont know ;)
08:34:46 <Cale> well, there are just 13 axioms, and that's a simple expression. Does it match any of them?
08:34:54 <neologism> I think it doesnt...
08:35:26 <Cale> well, it clearly matches against A10
08:35:36 <neologism> yes.. but it makes no sense
08:35:41 <neologism> ah!
08:35:47 <Cale> you can replace the a* with (1 + aa*)
08:37:50 <Cale> If you're careful, you can probably solve it directly with just some applications of A12/A13
08:38:10 <neologism> I am just trying
08:42:15 <neologism> I dont know
08:51:56 <neologism> Cale: how did you get the thing about a<=b means that I can replace a+b with b
08:51:58 <neologism> where can I use this?
08:52:09 <Cale> from the meaning of <=
08:52:15 <neologism> but where canI use it?
08:52:40 <Cale> well, anywhere that you have a sum
08:52:49 <neologism> I dont have sum anywhere
08:53:28 <neologism> and I dont understand how the A.12 match my formula
08:55:44 <Cale> okay, suppose that you can show that 1 + a*a* <= a*
08:55:56 <Cale> then you'll know that a** <= a*
08:55:56 <neologism> ok
08:56:14 <neologism> and?
08:57:21 <Cale> Well, if a <= b and b <= a then a = b, right? I suppose your page doesn't say that explicitly.
08:57:43 <Cale> But it turns out that <= is actually a partial order
08:58:07 <neologism> yes
08:58:09 <Cale> so you'd be half of the way there
08:58:14 <SamB> Cale: it is?
08:58:30 <neologism> but how can I show that    1+a*a* <=a* ?
08:58:32 <Cale> SamB: yeah, I'm fairly sure
09:00:55 <neologism> what is this good for?
09:01:01 <neologism> I want the first step from
09:01:06 <neologism> a* = (a*)*
09:01:09 <neologism> to anything else
09:01:11 <neologism> I just dont get it
09:01:12 <Cale> heh, on page 15 it says <= je neostrým cástecným usporádáním
09:01:15 <SamB> Cale: yeah, it looks like it is
09:01:54 <SamB> what did you say this was written in?
09:02:29 <ndm_> woohoo, hoogle3 just did its first proper type match
09:02:42 <Cale> I'm not sure either, but what it says after that is very suggestive :)
09:03:08 <neologism> translation: partial ordering
09:03:11 <Cale> <= je reflexivní, <= je tranzitivní, <= je antisymetrické
09:03:20 <Cale> I can read that well enough :)
09:03:40 <SamB> Cale: yeah ;-)
09:03:43 <Cale> In fact, I can infer what most of this is saying from context :)
09:03:53 <poetix> Quick FFI / c2hs question - how do I pass a pointer to a Haskell function to a C function that takes a function pointer, e.g. void setHandler(void (*handler)())
09:03:59 <neologism> so.. do you have a clue how to do that proof?
09:04:42 <dcoutts> poetix, you need to use the foreign import "wrapper" thing
09:04:45 <Cale> neologism: well, I'm sure you'll get it if you mess around applying various axioms until you get a feel for how things work
09:05:04 <dcoutts> poetix, see the ffi spec for an explanation, or the gtk2hs code for some examples
09:05:15 <neologism> I dont know how to apply any of those axioms (as it makes any sense)
09:05:18 <poetix> Ah, gtk2hs - good call
09:06:23 <Cale> neologism: well, A10 and A11 each apply in 2 different ways to a**
09:06:44 <Cale> that's treating a** as the right hand side
09:06:50 <Cale> er
09:06:54 <Cale> or a part of it
09:06:55 <Cale> so
09:07:11 <Cale> (a*)* = (1+aa*)*
09:07:26 <Cale> or (a*)* = 1 + a*a**
09:09:17 <gaal> (1+) ndm_
09:09:52 <neologism> Cale: yes..
09:10:01 <Cale> well, you try things :)
09:10:08 <Cale> I'm not going to spell it out
09:11:47 <Cale> the last 4 axioms are the only ones which mention * so they'll be important, but you might need some other things, so don't forget about the others when simplifying things. Distributivity can help because it means you can factor expressions
09:12:00 <Cale> (as well as expand them out)
09:12:22 <lightstep> there are examples of simplifications on page 17
09:13:53 <neologism> GOT IT!
09:14:59 <Cale> :)
09:16:39 <neologism> oh.. I didnt :(
09:17:25 <lightstep> @where ffi
09:17:26 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
09:19:24 <neologism> hm.. maybe I should use modus ponens
09:37:08 <neologism> I have no idea how to prove it :(
10:01:53 <MenTaLguY> hello
10:09:32 <JKnecht> hi
10:10:03 <syntaxfree> so lambdabot compiles, but won't  run.
10:11:04 <syntaxfree> Main.o: unknown symbol `___stginit_GHCziTopHandler_'
10:15:42 <syntaxfree> @version
10:15:43 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
10:15:43 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:16:56 <Digby> hi, would anyone mind helping me get a simple function to work? just a problem not finding a show function to print some output
10:18:11 <MenTaLguY> Digby: sure, what do you have?
10:18:58 <Digby> ERROR - Cannot find "show" function for: *** Expression : encodeMsg "hello" *** Of type    : String -> String
10:19:30 <Digby> there's my error, not sure if i need to tell you any more? i've just started learning haskell at uni
10:19:41 <MenTaLguY> ok ... are you sure that expression should evaluate to a function from a string to a string?
10:19:51 <syntaxfree> what is the function?
10:19:55 <Digby> yeah i'm sure of that
10:20:14 <MenTaLguY> show isn't defined for functions
10:20:26 <syntaxfree> I know.
10:20:31 <MenTaLguY> so, that's probably about the best you'll get, unless someone brings some serious haskell-fu to bear
10:20:50 <MenTaLguY> can we see your definition of encodeMsg, at any rate?
10:21:00 <syntaxfree> maybe it's a simple oops? what is encodeMsg?
10:21:33 <Digby> it's only one of a set of functions i've had to define to solve a problem of encoding strings
10:21:54 <Digby> i could paste the script in dcc window if you like?
10:22:14 <MenTaLguY> hrm, what is the prefered means for posting code snippets in this channel?
10:22:18 <Digby> 60 lines in total but i'm sure you wouldn't need to see the whole lot
10:22:36 <MenTaLguY> is there a pasteboard somewhere or something that everyone uses?
10:22:46 <JKnecht> n00b here but you could use lisppaste.
10:23:02 <MenTaLguY> Digby: to rephrase my earlier question, you're expecting (encodeMsg "hello") to evaluate to a string, aren't you?
10:23:29 <Digby> yes that's right
10:23:32 <MenTaLguY> ahh
10:23:33 <MenTaLguY> thought so
10:23:59 <MenTaLguY> you want encodeMsg to have the type String -> String, but the way you've defined it, it has the type String -> String -> String instead
10:24:23 <Digby> oh, it takes two parameters
10:24:29 <MenTaLguY> the reason you get a result of type String -> String is that there's a dangling string argument yet to be applied
10:24:40 <franka> Is lambdabot broken?
10:24:41 <MenTaLguY> s/applied/provided/
10:25:01 <MenTaLguY> I'd really recommend adding type annotation to all your top-level functions
10:25:07 <MenTaLguY> it will catch these sorts of things much earlier
10:25:11 <basti_> hi guys
10:25:20 <MenTaLguY> i.e.
10:25:20 <MenTaLguY> encodeMsg :: String -> String
10:25:20 <MenTaLguY> encodeMsg = ... etc ...
10:25:25 <basti_> start of semester? ^^
10:25:26 <Digby> i've done that yeah
10:25:30 <syntaxfree> digby: use paste.lisp.org
10:25:48 <Digby> ok syntax
10:27:05 <lisppaste2> Digby pasted "Newbie error" at http://paste.lisp.org/display/12763
10:27:12 <Digby> :)
10:27:44 <franka> Has anyone read Tarmo Uustalu et al. "The Essence of Dataflow Languages"?
10:27:55 <basti_> franka: yes.
10:28:11 <franka> basti_ What did you think?
10:28:28 <basti_> franka: it starts out very interesting, the later point about clocks is rather a no-brainer afaics ;)
10:28:33 <franka> Are you in Utrecht, BTW?
10:28:36 <basti_> no
10:28:39 <basti_> marburg
10:28:40 <franka> NL?
10:28:42 <basti_> no.
10:28:43 <franka> OK.
10:28:43 <basti_> .de
10:28:48 <MenTaLguY> I see
10:28:57 <basti_> i just bear a dutch name.
10:28:57 <MenTaLguY> Digby: so ... this looks basically okay
10:28:59 <franka> I thought the part on clocks was pretty interesting.
10:29:03 <MenTaLguY> Digby: (at quick glance)
10:29:05 <syntaxfree> @hawiki HaskellUserLocations
10:29:06 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
10:29:12 <MenTaLguY> Digby: what's the problem you're trying to solve again?
10:29:14 <franka> The distributive laws, I mean.
10:29:21 <basti_> it -is-, theoretically, but i either didnt understand the point, or it was a no-brainer
10:29:25 <Digby> i'll append the message to the post
10:29:30 <basti_> yes, the generalisation to distributive laws is useful.
10:29:31 <Digby> the error message sorry
10:30:02 <franka> Anyway, the paper got me wondering whether comands deserve a do-like syntax, and if so, what it should be.
10:30:09 <franka> comonads
10:30:15 <lisppaste2> Digby pasted "Newbie error" at http://paste.lisp.org/display/12765
10:30:33 <basti_> franka: hmm, i think they do, but how it would look I don't know. Rather similar, probably
10:30:57 <franka> Perhaps.  Had you ever looked into dataflow languages before reading that article?
10:31:04 <basti_> yes, a little bit.
10:31:17 <MenTaLguY> Digby: incidentally, just as a HaskellStyle thing, it's preferred to write:
10:31:17 <MenTaLguY> encodeListPairs (zip formattedMsg formattedPwd)
10:31:17 <MenTaLguY> ...or even:
10:31:17 <MenTaLguY> encodeListPairs $ zip formattedMsg formattedPwd
10:31:26 <franka> I had heard of them, but never looked deeply into it.
10:31:27 <MenTaLguY> but they are semantically the same thing
10:31:39 <franka> I've looked at Lucid Synchrone and Lustre now.
10:31:46 <MenTaLguY> I mean, with the space after encodeListPairs in the first case
10:31:46 <basti_> franka: i have a little experience with Oz.
10:32:00 <franka> It's interesting.  I think I had the same experience w.r.t. those that imperative programmers have w.r.t. Haskell.
10:32:05 <franka> It's quite a different paradigm.
10:32:08 <basti_> i think the dataflow "paradigm" (or what you'd call it) is a very important thing
10:32:10 <Digby> MenTaLguY: yeah I rushed the end a bit :)
10:32:41 <franka> I know some Oz; I think it's not the same.  But maybe I don't know the dataflow part of Oz.
10:32:44 <MenTaLguY> ok
10:32:58 <basti_> oz has easily accessible dataflow stuff
10:33:00 <franka> I know Alice ML a bit better.  That is more in the direction of implicit synchronization.
10:33:01 <MenTaLguY> basically the deal is that there's no standard definition of show for a function
10:33:23 <MenTaLguY> I guess you're trying to see what the curried function looks like, up to this point?
10:34:17 <franka> I encourage you to take a look at this:
10:34:19 <franka> http://www-spi.lip6.fr/lucid-synchrone/manual-html/manual002.html
10:34:21 <Digby> yeah, i mean the purpose of my assignment is to encode a string as in the function and print it to screen
10:35:09 <MenTaLguY> don't you need to supply the password to get an encoded string?
10:35:28 <franka> Perhaps we should call dataflow a "coeffect" and leave "effect" for monadically expressible stuff.
10:35:38 <Digby> i think you may have solved my problem lol
10:35:48 <MenTaLguY> coeffect is weird to say
10:35:58 <syntaxfree> coffee?
10:36:11 <franka> MenTaLguY If you have a better suggestion...?
10:36:16 <MenTaLguY> not really...
10:36:35 <syntaxfree> calling duals "co-things" is traditional cat theory style.
10:36:42 * MenTaLguY nods
10:37:00 <Digby> MenTaLguY: thanks for the help... gonna go and hide under a rock for a few days now
10:37:30 <MenTaLguY> well, the terminology category theory was never very uniformly mellifluous anyway
10:39:17 <MenTaLguY> heh, I had my own Haskell question actually but I answered it in the process of trying to reduce it to the essentials to paste here
10:39:48 <MenTaLguY> though, I'm sure there will be lots more where that one came from..
10:40:04 <CosmicRay> sethk: ping
10:42:50 <syntaxfree> how do I load the contents of one .hs file from another?
10:43:02 <lightstep> #include
10:43:09 <CosmicRay> syntaxfree: are you thinking of import?
10:43:09 <lightstep> or better, use modules
10:43:21 <CosmicRay> lightstep: that is not part of standard haskell, that would require cpphs or some such
10:43:27 <syntaxfree> oh. one more concept to learn.
10:43:34 <CosmicRay> syntaxfree: modules, you mean?
10:43:51 <dcoutts> syntaxfree, you almost certainly want to use import
10:43:59 <CosmicRay> syntaxfree: file:///usr/share/doc/haskell98-tutorial/html/modules.html
10:43:59 <CosmicRay> err
10:44:04 <CosmicRay> let me get you a better url ;-)
10:44:09 <dcoutts> syntaxfree, to get access to the things that Foo.hs exports, then use:
10:44:12 <dcoutts> import Foo
10:44:17 <dcoutts> at the top of your other module
10:44:24 <syntaxfree> I most likely want import.
10:44:36 <CosmicRay> http://www.haskell.org/tutorial/modules.html
10:44:37 <CosmicRay> there.
10:45:22 <CosmicRay> modules in haskell are really very easy, sane, and nice.
10:45:34 <CosmicRay> I think haskell's module system has fewer pitfalls and annoying special cases than most.
10:45:40 * MenTaLguY nods
10:45:53 <Philippa> I'd like nested modules sometimes
10:46:20 <CosmicRay> some languages (ocaml) support that.
10:46:31 <CosmicRay> I've found that it leads to a great deal of confusion
10:46:58 <Philippa> what do you find causes it?
10:47:07 <syntaxfree> is there any standard prelude function like prettyList v = foldl (++) "" [(show x)++ " " | x<-v]
10:47:10 <syntaxfree> ?
10:47:44 <Philippa> mostly I just want them for tighter scope control, eg if there's a helper module I really don't want most modules importing
10:48:33 <ndm_> hi gaal
10:49:12 <MenTaLguY> syntaxfree: hmm, not per se.  That could probably be written more concisely, though
10:50:03 <syntaxfree> @pl f x y = g x
10:50:04 <lambdabot> f = const . g
10:50:12 <syntaxfree> how so?
10:50:15 <syntaxfree> @type const
10:50:18 <Philippa> intersperse is likely your friend
10:50:19 <lambdabot> forall a b. a -> b -> a
10:50:30 <MenTaLguY> prettyList v = foldl (++) "" $ intersperse "" $ map show v
10:50:37 <syntaxfree> @pl f x = g x y
10:50:38 <lambdabot> f = flip g y
10:50:39 <ndm_> and concat
10:50:47 <Philippa> use concat rather than fold
10:50:52 <Philippa> bah!
10:50:55 <MenTaLguY> ah, indeed
10:51:07 <MenTaLguY> prettyList v = concat $ intersperse "" $ map show v
10:51:23 <lightstep> maybe " "?
10:51:26 <MenTaLguY> er, yeah
10:51:30 <MenTaLguY> prettyList v = concat $ intersperse " " $ map show v
10:52:17 <basti_> and IF you use fold, you probably want foldr .)
10:52:35 <Igloo> Isn't that unwords . map show?
10:52:41 <syntaxfree> it's the same, in this case.
10:52:50 <MenTaLguY> Igloo: so it is
10:53:06 <syntaxfree> intersperse is good, yes.
10:53:08 <syntaxfree> @pl prettyList v = concat $ intersperse " " $ map show v
10:53:09 <lambdabot> prettyList = join . intersperse " " . map show
10:53:23 <syntaxfree> @type join
10:53:25 <lambdabot> bzzt
10:53:32 <lightstep> @type Monad.join
10:53:34 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
10:53:45 <MenTaLguY> (prettyList = unwords . map show) still wins by far
10:53:48 <syntaxfree> o. heavy wizardry.
10:53:54 <syntaxfree> what IS unwords?
10:53:54 <Igloo> There's no need to use join over concat
10:54:09 <Igloo> Seems a pretty random thing for pl to do to me
10:54:11 <MenTaLguY> syntax free: combines a list of strings into a single space-separated string
10:54:12 <syntaxfree> yes, yes. I'm just investigating pointfreeness.
10:54:29 <syntaxfree> I'm not gonna use that pointless style in my programs ;-)
10:54:41 <Philippa> Igloo: it seems to be list monad obsessed :-(
10:54:59 <syntaxfree> MenTaLguY well, I need a list of strings into a \n-separated string as well.
10:55:02 <Philippa> I use it in very small doses sometimes, but if I wanted a concatenative language I'd use one
10:55:08 <MenTaLguY> aha
10:55:10 <Philippa> unlines?
10:55:14 <MenTaLguY> would unlines do?
10:55:19 * MenTaLguY grins
10:55:24 <Igloo> syntaxfree: Depending on my mood I might write the above as a point-free function, but I wouldn't use join
10:55:41 <syntaxfree> I'm learning point-free style, that's all.
10:55:57 <tromp> when in ghci, how wld you print a list of strings, one per line?
10:55:59 <MenTaLguY> though, unlines is a little different than unwords, since it adds a final "\n" that a simple application of intersperse would not
10:56:21 <Igloo> tromp: mapM_ putStrLn
10:56:52 <syntaxfree> hmm. unlines does exist.
10:57:22 <tromp> thx, Igloo
10:58:29 <MenTaLguY> alternately, (putStr . unlines)
10:59:08 <MenTaLguY> @help
10:59:08 <lambdabot>  @help <command> - ask for help for <command>
10:59:30 <MenTaLguY> @commands
10:59:31 <lambdabot> Unknown command, try @listcommands.
10:59:49 <MenTaLguY> er... is there any way to explore lambdabot features without spamming the channel?
11:00:07 <MenTaLguY> privmsg doesn't seem to work...
11:00:09 <CosmicRay> you can msg the bot
11:00:15 <CosmicRay> you may have msg filtering on
11:00:16 <CosmicRay> stupid freenide
11:00:20 <CosmicRay> node
11:00:23 <syntaxfree> use #haskell-blah
11:00:25 <CosmicRay> there's some command to fix that
11:02:29 <MenTaLguY> eh well
11:04:33 <JohnMeacham> gurp.
11:05:08 <JohnMeacham> I mean.. hello!
11:05:16 <CosmicRay> hello ;-)
11:05:44 <Philippa> johnMeacham = do {swim; swim; hungry} ?
11:10:09 <RemiTurk> hi all
11:12:15 * ski_ pondered calling comonadic values 'passions'
11:12:18 <ski_> franka,basti_ : hm, environment can be expressed both as monad and a comonad .. this is possibly an argument for using 'effects' for both
11:12:41 <franka> For that one, yes.
11:12:46 <franka> But that's a good point.
11:13:17 <ski_> (basti_ : and i don't think special syntax for comonadic things should look similar to do for monads)
11:16:13 <franka> OTOH, the Reader monad is not quite a side-effect, is it?  I used to wonder about this.
11:16:30 <franka> Whether it's appropriate to call it that.
11:17:18 <Philippa> I think it is insofar as it's a "side-channel"
11:17:36 <franka> More like a side-cause, perhaps? :)
11:18:01 <interferon> xb
11:18:16 <Philippa> heh
11:19:00 <Philippa> I have to admit I tend to think about monads in terms first of "different semantics" and then in terms of the side-effects I do and don't want those semantics to support
11:19:08 <lisppaste2> MenTaLguY pasted "good name for function?" at http://paste.lisp.org/display/12767
11:19:11 <Philippa> well, not so much side-effects as features, I guess
11:19:26 <MenTaLguY> so, anyone have any ideas what I should call "apply"?
11:19:38 <MenTaLguY> compose, maybe, but I dunno...
11:19:40 <franka> Me too, Phillippa.
11:20:03 <interferon> MenTaLguY, "the dutch compositor device"
11:20:16 <Philippa> ah well. Great minds still think shite and all that
11:20:48 <Philippa> it does seem to be the... I guess most productive way to view them unless you're building one by hand (in which case you need more info)
11:21:02 <MenTaLguY> interferon: sadly, spaces aren't valid in Haskell identifiers, so far as I know
11:21:16 <MenTaLguY> interferon: is that an actual term for it though?
11:21:32 <interferon> MenTaLguY, not at all
11:21:40 <interferon> :)
11:22:05 <Philippa> runChain?
11:22:18 <Philippa> or even just chain?
11:22:21 <franka> Your Compose declarations are illegal.
11:22:38 <franka> No constructors, and you need parens.
11:23:40 <Philippa> mconcat? ;-)
11:23:53 <franka> Is it supposed to be parallel composition?  I don't know how to compose a -> b's in series unless a=b.
11:24:17 <Philippa> it looks rather a lot like an attempt at monoids?
11:24:34 <ski_> MenTaLguY : possibly you want 'type Compose' instead of 'data Compose' ?
11:25:10 <franka> Yes, perhaps Philippa is right.
11:26:03 <Philippa> in fairness, the monoid typeclass is such that you can only have one instance for a given type
11:26:21 <franka> Yeah, that's why I avoid type classes.
11:26:29 <MenTaLguY> ski: ah, yeah, I meant type
11:26:46 <MenTaLguY> and, I'm not sure what it's an attempt at
11:26:55 <MenTaLguY> I'm just taking some existing code and generalizing it as far as I can
11:27:02 <MenTaLguY> in hope that I find something useful
11:27:08 <Philippa> there're times when I'd love a more general defaulting mechanism for typeclasses
11:27:14 <MenTaLguY> if it turns out to be something that can be accomplished via something in the standard libraries, so much the better
11:27:28 <Philippa> but it'd almost certainly turn out to be a very bad thing
11:27:52 <lightstep> it's similar to foldr
11:27:53 <ski_> (MenTaLguY : hm, just wondering .. you don't want to compose with the default anyway, even when the list is nonempty ?)
11:28:51 <franka> You probably want: foldr (.) id fs
11:28:52 <MenTaLguY> ski: correct
11:29:12 <MenTaLguY> franka: nope.
11:29:38 <franka> Else hike compose and id to a type class or an existential record.
11:30:01 <franka> Like an Arrow type.
11:31:22 <MenTaLguY> franka: elaborate please?
11:32:21 <SyntaxNinja> Igloo: alive?
11:32:37 <Igloo> yup
11:32:58 <MenTaLguY> brb
11:33:21 <franka> Well, you can define a monoid-like thing with its own notion of composition and identity and put it in a record.
11:33:37 <SyntaxNinja> Igloo: I'm going to try to fix up cabal in Debian today; do you see any problem w/ replacing the libghc6-cabal-dev (etc) packages w/ the new version of cabal? any need for a new package?
11:34:09 <SyntaxNinja> Igloo: I'm going to try to figure out if this package can coexist w/ Cabal-1.0 without changing the name.
11:34:36 <marcot> SyntaxNinja: yuppi!!!
11:34:40 <MarcWeber> Hello again. I got a lot closer to my goal compiling hdirect. But now my cygwin gcc installation cn't find cc1. I've never meat this program. What is it doing?
11:35:11 <SyntaxNinja> hi marcot. I just replied to you, heh
11:35:19 <Igloo> SyntaxNinja: We don't have any nice automatic way to depend on ghc6's cabal if you don't change the name
11:35:34 <SyntaxNinja> marcot: good timing. I was sitting at my computer thinking, "I have a bunch of debian stuff to catch up on, what should I start with..."
11:35:51 <Igloo> In fact, there isn't a nice way at all; it needs a conflict
11:35:55 <CosmicRay> Igloo: do you mean in control files or in cabal files?
11:36:18 <Igloo> control files
11:36:34 <marcot> SyntaxNinja: I was just going to make a new revision of c2hs 0.13.6. Now I think I'll wait for package 0.14.3 with cabal!
11:36:40 <CosmicRay> Igloo: I don't see the problem.  if you're wanting the cabal that comes with ghc, couldn't you just dep on ghc (>= 6.4)?
11:36:50 * SyntaxNinja nods in sync w/ CosmicRay
11:36:56 <Igloo> There's not much point depending on cabal in a .cabal file, except maybe to fail if you turn out to be using an incompatible one
11:37:24 <MarcWeber> sfaslkfjsaf
11:38:05 <CosmicRay> Igloo: I was thinking of some programs that might use utilities from cabal for purposes other than building themselves.  I suppose that's rare though.
11:38:11 <Igloo> CosmicRay: To be nicely automatic you need to depend on libghc6-cabal-dev. But the more important point is you also need to not have a libghc6-cabal-dev binary package hiding ghc6's
11:38:54 <CosmicRay> Igloo: wouldn't you just dep on ghc6 (>= 6.4) and conflict with libghc6-cabal-dev in that case?
11:39:08 <MenTaLguY> franck: could you humor me and define existential record please?
11:39:16 <MenTaLguY> I'm afraid I don't have a strong background here
11:39:26 <Igloo> Yes, that's what you'd have to do. Which is hideous.
11:39:57 <marcot> CosmicRay: hello.
11:40:01 <CosmicRay> or, can't you specify a particular package version to use these days?
11:40:06 <marcot> CosmicRay: I'm doing the gtk2hs package.
11:40:07 <CosmicRay> hi marcot
11:40:10 <franka> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification
11:40:14 <marcot> CosmicRay: Could you upload it for me too?
11:40:15 <CosmicRay> marcot: nice
11:40:29 <Igloo> I'm not going to stop you, anyway, but that's my opinion on the matter
11:41:16 <CosmicRay> marcot: sure
11:41:22 <SyntaxNinja> another option is to use the same debian package, but a different name for the cabal package, which would not cause that conflict
11:41:23 <marcot> CosmicRay: ok then..
11:41:27 <CosmicRay> marcot: that would be great to have in debian
11:41:50 <CosmicRay> SyntaxNinja: that would mean that we'd have to hack every upstream reference to -package Cabal
11:41:58 <CosmicRay> SyntaxNinja: perhaps the right thing to do is decide on that upstream?
11:42:02 <franka> data FreeMonoid x = forall a. FreeMonoid a (a -> a -> a) (x -> a)
11:42:08 <CosmicRay> surely debian is not the only place where this problem strikes
11:42:32 <marcot> CosmicRay: sure it would.
11:42:36 <CosmicRay> either that or stop breaking backwards compatibility with new versions so this problem goes away ;-)
11:42:44 <Igloo> SyntaxNinja: That seems a very odd thing to do. What problem does it solve?
11:43:02 <SyntaxNinja> Igloo: packages that depend on the old cabal need not conflict w/ the new one
11:43:16 <Igloo> You mean libghc6-cabal-dev providing a cabal package cabal-foo, right?
11:43:18 <SyntaxNinja> really, though I guess they don't need to conflict with the new one.
11:43:23 <SyntaxNinja> Igloo: yeah
11:43:36 <Igloo> But why not also rename the Debian package if you're going to do that?
11:43:39 <franka> Then: funMonoid = FreeMonoid id (.) (\x -> (x:)) :: FreeMonoid ([x] -> [x]), for example.
11:44:05 <SyntaxNinja> so wait, why did you say that such packages would have to conflict?
11:44:11 <Igloo> So the names match, and the Provide: libghc6-cabal-dev of ghc6 isn't confused?
11:45:11 <SyntaxNinja> CosmicRay: I don't want to stop breaking backward compatibility yet ;)
11:45:22 <CosmicRay> SyntaxNinja: hehe
11:45:29 <SyntaxNinja> CosmicRay: and it's more about adding new features than breaking backward compatibility, which hasn't been a big deal, IMO.
11:45:37 <Igloo> When cabal is run, if you need the one that comes with ghc6 then you need to not have the other one installed
11:45:43 <SyntaxNinja> folks want the newer versions to use the new features.
11:45:58 <SyntaxNinja> Igloo: why?
11:46:03 <CosmicRay> SyntaxNinja: so you're saying that nothing that expects ghc's cabal would be broken if used with the latest cabal?
11:46:07 <Igloo> Because otherwise you'll get the new one
11:46:15 <SyntaxNinja> Igloo: you can just specify that you want Cabal-1.0 in your rules file.
11:46:23 <CosmicRay> Igloo: would -package Cabal-1.0 work instead?
11:46:35 <MenTaLguY> so, what exactly does forall mean?  I've not quite wrapped my head around it yet
11:46:38 <SyntaxNinja> CosmicRay: in practice, I doubt it. I think the only things that have changed are the hooks, and not many ppl are using them.
11:46:56 <CosmicRay> SyntaxNinja: HSQL is, to name a prominent example.
11:47:07 <Igloo> Possibly; Syn is better positioned to answer that than me  :-)
11:47:10 <SyntaxNinja> does hsql work w/ cabal-1.0?
11:47:10 <dcoutts> SyntaxNinja, just fyi, on Gentoo we unregister Cabal-1.0 and install Cabal-1.1.3 with ghc-6.4.1
11:47:21 <CosmicRay> SyntaxNinja: yes
11:47:26 <SyntaxNinja> dcoutts: yeah, Igloo doesn't want to do that.
11:47:29 <franka> It entails that you don't have to mention the element type in the type name, MenTaLguY.  It's hidden.  For example 'a' appears in on the right-hand side but not on the left.
11:47:39 <franka> in my FreeMonoid declaration above.
11:47:42 <dcoutts> SyntaxNinja, Well he should. :-)
11:47:59 <SyntaxNinja> CosmicRay: so there's a chance it'll break w/ the latest cvs head, but not cabal 1.1.3; anyway, the hooks are specifically in the area of stuff we don't promise not to change.
11:48:00 <CosmicRay> MenTaLguY: in what context?
11:48:04 <SyntaxNinja> and the fix is easy.
11:48:19 <dcoutts> keeping Cabal-1.0 when ghc-6.4.1 was release was a mistake in my opinion. Cabal-1.1.3+ works much better.
11:48:42 <SyntaxNinja> dcoutts: it would have had to become 6.6 in that case. no library API changes are allowed between minor versions of ghc.
11:49:06 <dcoutts> yeah, I know the rule but I still think it was a mistake
11:49:18 <SyntaxNinja> I think it should be the case that packages which need cabal 1.0 can specifically specify -package Cabal-1.0 in their rules file and it'll work.
11:49:31 <dcoutts> make packages need later than 1.0
11:49:32 <SyntaxNinja> with ghc 6.4.1, but not 6.4
11:49:48 <dcoutts> and we rely on the later features to make it work with the gentoo packagin system.
11:49:51 <CosmicRay> SyntaxNinja: I'd be happy with that.
11:50:24 <SyntaxNinja> I expect that Cabal-1.0 would be the exception rather than the rule, but i kinda agree w/ igloo to leave cabal-1.0 in there.
11:50:49 <dcoutts> SyntaxNinja, is that really the case? If I use "runhaskell Setup.lhs ..." it'll just use whatever version of Cabal is exposed, not the version specified in the .cabal file.
11:51:07 <SyntaxNinja> dcoutts: the .cabal file doesn't specify cabal versions
11:51:17 <CosmicRay> dcoutts: it's not portable to use runhaskell anyway
11:51:18 <dcoutts> unless it's a build depends
11:51:31 <SyntaxNinja> dcoutts: yea
11:51:38 <dcoutts> CosmicRay, yeah we don't actually do it either.
11:51:42 <SyntaxNinja> dcoutts: I don't think I understand the question.
11:51:56 <dcoutts> SyntaxNinja, hmm it moke liekly I don't understand. ;-)
11:52:05 <SyntaxNinja> Igloo: what's your ideal solution again? a new libghc6-cabal-foo-dev package and new cabal-foo ghc package?
11:52:06 <ski_> franka : 'FreeMonoid ([x] -> [x])' ?
11:52:12 <Igloo> Yes
11:52:28 <dcoutts> SyntaxNinja, I thought the question was about a hypothetical package that works with Cabal-1.0 but not with a later version.
11:52:42 <ski_> franka : is the hidden type '[[x] -> [x]] -> [[x] -> [x]]', here ?
11:52:46 <SyntaxNinja> so my solution of using the same ghc and debian package names would break your provides.
11:53:00 <SyntaxNinja> dcoutts: yeahk, it should work, you just have to explicitly state which version of cabal you want.
11:53:03 <franka> MenTaLguY, instead of Chain c x fs you would write Mult f1 (Mult f2 f3), say..
11:53:12 <franka> MenTaLguY: That was just an example for lists.
11:53:13 <SyntaxNinja> dcoutts: if it's not the exposed one.
11:53:18 <dcoutts> SyntaxNinja, oh the rules file is a debian specific thing. I see.
11:53:24 <SyntaxNinja> dcoutts: right.
11:53:29 <franka> Nevermind the [x].
11:53:31 <dcoutts> SyntaxNinja, so that allows you to specify the cabal package to build with. ok.
11:54:04 <franka> Um, wait, lemme see if I can find a paper.
11:54:23 <SyntaxNinja> Igloo: so we would have to get rid of the provides:, and packages that need cabal-1.0, if any, will have to depend on the right version of ghc...
11:54:25 <Igloo> SyntaxNinja: I don't think it would actually break anything today, but it is on lots of edges of breaking things (like packages expecting ghc 6.4.1 to have the cabal it comes with, automatic dependency generation for programs using cabal's libraries)
11:54:58 <SyntaxNinja> Igloo: my intuition is that by the time those things become a real problem, we'll get a version of ghc w/ a new cabal.
11:55:09 <SyntaxNinja> CosmicRay: what do you think is better?
11:55:11 <Igloo> SyntaxNinja: And also make sure they really are getting the old cabal
11:56:02 <CosmicRay> SyntaxNinja: sorry, I haven't been following the discussion for the last couple of minutes
11:59:00 <franka> MenTaLguY, can't find it right now, sorry.  Maybe I am only confusing you, anyway.  This is not stuff for beginners; you should do it the way it makes sense to you right now.
11:59:20 <MenTaLguY> franka: at least I grok forall now
12:00:00 <franka> That's good. I was trying to find a Mark Jones paper which I thought had some examples of its use, but I can't find the right one, or maybe I'm misremembering.
12:01:48 <franka> Anyway, I have to get something to eat now, so I'll be away for a bit.
12:02:05 <MenTaLguY> thanks
12:03:36 <SyntaxNinja> Igloo: what purpose does the provides: serve?
12:08:55 <Igloo> SyntaxNinja: It means you can automate generating the (build-)deps from the .cabal file
12:10:29 <SyntaxNinja> Igloo: why does it help?
12:11:22 <Igloo> Becase you just do map (\dep -> "libghc6-" ++ dep ++ "-dev") to generate them
12:12:06 * Igloo is in and out, BTW
12:13:32 <SyntaxNinja> Igloo: oh, you mean in the case where there's no _real_ libghc6-cabal-dev package
12:15:33 <SamB> ok, someone explain why this doesn't work:
12:15:39 <SamB>     counts = runSTUArray $
12:15:40 <SamB>              do arr <- newListArray (0,15) (replicate 0)
12:15:40 <SamB>                 return arr
12:15:45 <SamB> but this does:
12:16:20 <SamB>     counts = runSTUArray
12:16:21 <SamB>              (do arr <- newListArray (0,15) (replicate 0)
12:16:21 <SamB>                  return arr
12:16:21 <SamB>                 )
12:17:00 <ski_> @type Data.Array.ST.runSTUArray
12:17:01 <lambdabot> forall e i.
12:17:01 <lambdabot> (GHC.Arr.Ix i) =>
12:17:01 <lambdabot> (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e))
12:17:01 <lambdabot> -> Data.Array.Base.UArray i e
12:17:29 <ski_> it takes a polymorphic argument, and $ monomorphizes it
12:17:56 <SamB> oh
12:18:14 <marcot> I'm trying to write a haskell program which calls a C function of the type: void gpc_tristrip_clip       (gpc_op           set_operation,
12:18:18 <marcot>                               gpc_polygon     *subject_polygon,
12:18:20 <marcot> sorry for the code..
12:18:20 <SyntaxNinja> Igloo: OK, so that reason isn't useful here.  if we assume that most packages will actually want the newer cabal (which I think is true) then we lose out because we'll have to change hte upstream .cabal files in order to automatically generate dependencies.
12:18:22 <marcot>                               gpc_polygon     *clip_polygon,
12:18:25 <marcot>                               gpc_tristrip    *result_tristrip);
12:18:37 <SyntaxNinja> marcot: use the wiki paste page :)
12:18:40 <marcot> Anyway, the result of the function is one of it's parameters.
12:19:05 <marcot> Is there a way of calling a function such as this in c2hs?
12:21:20 <SamB> ski_: why does $ do that?
12:21:40 <franka> Oh, ski_, I just saw your comment.  You're right; I had the type wrong.
12:21:57 <ski_> all normal uses of polymorphic things monomorphizes them
12:25:10 <sethk> @type $
12:25:12 <lambdabot> bzzt
12:25:18 <ski_> @type ($)
12:25:19 <lambdabot> forall b a. (a -> b) -> a -> b
12:26:18 <malcolm> ski_: not entirely accurate.  The only things monomorphised are type variables constrained by a class predicate, and even then, only in certain circumstances
12:27:11 <ski_> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#universal-quantification
12:27:52 <ski_> or rather http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#id3147071
12:29:08 <ski_> malcolm : hm, possibly .. (i was roughly describing H-M)
12:35:32 <ricebowl> is there a definition somewhere for "wtf is a monad?"
12:35:45 <xerox> @wiki MonadsAsContainers
12:35:46 <SamB> @wtf monad
12:35:46 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
12:35:49 <lambdabot> *** "monad" wn "WordNet (r) 2.0"
12:35:49 <lambdabot> monad
12:35:49 <lambdabot>   n 1: an atom having a valence of one
12:35:49 <lambdabot>   2: a singular metaphysical entity from which material
12:35:49 <lambdabot>    properties are said to derive [syn: {monas}]
12:35:51 <lambdabot>   [also: {monades} (pl)]
12:35:52 <xerox> @google all about monads
12:35:53 <lambdabot> http://www.nomaware.com/monads/html/
12:36:05 <xerox> Also  Monad = Monad
12:37:09 <basti_> @google monad catholic
12:37:10 <lambdabot> http://www.newadvent.org/cathen/10447b.htm
12:38:01 <SamB> I think this needs some work before ST becomes standard...
12:38:46 <ski_> also, see http://www.haskell.org/hawiki/UsingMonads and the tutorials linked from there
12:38:52 <ricebowl> what exactly is a Functor?
12:39:08 <basti_> a function on type level.
12:39:16 <ski_> roughly, something that can be mapped over
12:39:29 <ricebowl> "on type level"?
12:39:33 <ski_> (in haskell context, i.e.)
12:39:41 <ricebowl> as in it represents abstractly a function?
12:39:46 <basti_> a function that makes a type from another type
12:40:43 <xerox> It's like a thing with two properties, identity, and triangles maps to triangles - if I could explain it correctly
12:41:12 <basti_> it has some important properties too
12:41:18 <ski_> a type function  'f :: * -> *'  taking types to types together with a mapping function 'fmap :: forall a b. (a -> b) -> (f a -> f b)'  (satisfying 'fmap id = id' and 'forall f g. fmap (g . f) = (fmap g) . (fmap f)')
12:41:33 <xerox> Yeah right!
12:41:59 <xerox> I don't know if people can appreciate this definition at first glance, though.
12:42:00 <ski_> e.g. the type constructor '[]', "list of", together with 'map :: forall a b. (a -> b) -> ([a] -> [b])'
12:43:10 <ski_> another example is 'Maybe', with 'fmap f Nothing = Nothing; fmap f (Just a) = Just (f a)'
12:43:11 <ricebowl> xerox - I would say no ;)
12:43:13 <ski_> @kind Maybe
12:43:14 <lambdabot> * -> *
12:43:17 <ski_> @kind Maybe Int
12:43:18 <lambdabot> *
12:43:22 <ricebowl> this is very confusing
12:43:23 <ski_> @kind []
12:43:24 <lambdabot> * -> *
12:43:27 <ski_> @kind [] Bool
12:43:28 <lambdabot> *
12:43:32 <ski_> @kind [Bool]
12:43:33 <lambdabot> *
12:43:48 <xerox> ricebowl: I'd say, play with Binary Trees, and try to write its Functor instance.
12:44:21 <ricebowl> xerox - well I'm still very confused as to what exactly such a thing is
12:44:27 <xerox> @eval (Just 1) `fmap` (+1)
12:44:29 <lambdabot>   Expecting a function type, but found `Maybe a'
12:44:29 <lambdabot>   Expected type: a -> b
12:44:29 <lambdabot>   Inferred type: Maybe a1
12:44:38 <xerox> @eval (+1) `fmap` (Just 1)
12:44:40 <lambdabot> Just 2
12:44:42 <xerox> @eval (+1) `fmap` Nothing
12:44:44 <lambdabot> Nothing
12:44:50 <ski_> ricebowl : i guess one could have a hawiki/FunctorsAsContainers, too
12:45:00 <ricebowl> these are all properties, though :S
12:45:06 <ricebowl> I really don't understand *what* it is
12:45:27 <ricebowl> I am reading through the "Gentle Introduction to Haskell" and just becoming more and more confused
12:45:35 <xerox> In Haskell terms is a type, and a function.
12:45:51 <ricebowl> in one way, monads seem to me like classes from the OOP languages, but then they really aren't
12:46:30 <ski_> ricebowl : think of a value of type 'f a' as some structure (possibly collection), with possibly occurances of values of type 'a' within it .. what 'fmap' does is to make a copy of the whole structure, replacing each element 'x' of type 'a' with 'f x'
12:46:38 <MenTaLguY> monads are  just a category of stuff
12:46:44 <poetix> What means a.out <<loop>>?
12:46:54 <xerox> poetix: that your program got an infinite loop :-\
12:46:57 <ski_> poetix : you have a black hole
12:47:06 <poetix> Wow. Wonder how I managed that...
12:47:22 <xerox> poetix: delete the 'let a () = a () in a'  <blink>
12:47:31 <mauke> @eval let a = a in a
12:47:33 <lambdabot> Add a type signature
12:47:40 <MenTaLguY> in the case of monads specifically, any particular monad consists of three functions:  a type constructor for a container, and then definitions for bind (>>=) and return
12:48:00 <MenTaLguY> Haskell's monad type class has some additional bits, but they're just a matter of convention for the use of monads
12:48:21 <MenTaLguY> you can make any container type into a monad, actually
12:48:26 <MenTaLguY> by defining bind and return
12:48:36 <MenTaLguY> s/container/generic/
12:48:46 <MenTaLguY> for it
12:48:56 <ski_> 'generic' meaning ?
12:49:06 <SamB> oh, strictly speaking the latter doesn't work either ;-), but that had nothing to do with my question...
12:49:06 <MenTaLguY> er, right, I'm being imprecise
12:49:16 <MenTaLguY> I'm bad with terminology
12:49:42 <MenTaLguY> parameterized type?
12:49:52 <xerox> Is there any monad which does something more elaborated in 'return' than just wrap the argument in the type's data constructor?
12:49:52 <MenTaLguY> there's a specific Haskell term which I can't think of right now
12:50:00 <ricebowl> are monads simply a stateful mechanism?
12:50:20 <ski_> no
12:50:20 <xerox> ricebowl: they're a way to do stateful computations, above other things
12:50:27 <MenTaLguY> ricebowl: no, not at all.  they aren't stateful, although they can be used to represent computations that manipulate state
12:51:08 <ski_> MenTaLguY : not all parameterized types can be made into monads .. consider e.g. data Foo a = F (a -> Bool)
12:51:09 <SamB> xerox: what data constructor?
12:51:20 <xerox> But I think it's ok to talk about them in terms of things that make it possible to express the *order* in which computation is going to be done.
12:51:30 * SamB thinks of newtypes
12:51:32 <xerox> SamB: like 'Just' for 'Maybe a'
12:51:37 <xerox> SamB: Yeah right.
12:51:43 * araujo writing a small haskell shell
12:51:54 <xerox> araujo: cool!!
12:52:09 * ricebowl gets even more confused
12:52:17 <ricebowl> araujo - heh, I already started doing that ;)
12:52:34 <ricebowl> though my professor said it has been done and didn't work out so well
12:52:39 <xerox> ricebowl: if you have a list of computations, which one is going to be done first?
12:52:42 <ricebowl> has been done by him, I should say
12:52:57 <ricebowl> xerox - the list maintains order...
12:52:59 <araujo> xerox, yeah, sort of, i at least got something a bit useful.
12:53:11 <ricebowl> hmm, [a,b,c] is like a >>= b >>= c >>= []?
12:53:14 <xerox> ricebowl: nope, in general.
12:53:21 <xerox> Err, no, again.
12:53:29 <araujo> ricebowl, you doing the same?,
12:53:41 <xerox> The point is that you do not know.  You use function application to do things in order (i.e. monads)
12:53:46 <araujo> we probably could share ideas then :-)
12:54:24 <ricebowl> araujo - hehe, sort've, it wasn't strictly Haskell, and I was working on the back-end which I understand much better than the front-end, since I am still learning Haskell
12:54:45 <ricebowl> xerox - yes, but I meant are they equivalent in the context of the list monad :p
12:55:07 <araujo> ricebowl, What exactly do you mean with the back-end , front-end ?
12:55:20 <ski_> ricebowl : monads can be used to sequence "computations", loosely
12:55:26 <araujo> Ok, i hope to get this one written entirely on haskell
12:55:38 <ricebowl> araujo - interpreter vs. parser
12:55:49 <xerox> @eval [1] >>= \x -> [2] >>= \y -> [3] >>= \z -> [x,y,z]
12:55:50 <lambdabot> [1,2,3]
12:55:59 <araujo> I already got working | , >,<
12:56:07 <ski_> ricebowl : consider e.g. list monad ..
12:56:18 <ski_> @eval [1,2,3] >>= \a -> [40,50] >>= \b -> return (a,b)
12:56:19 <lambdabot> [(1,40),(1,50),(2,40),(2,50),(3,40),(3,50)]
12:56:27 <araujo> ricebowl, Oh, ok, it is probably a bit different than what i do, i want to be able to run haskell code from the prompt.
12:56:45 <ricebowl> araujo - quite a bit different; I want a shell with Haskell syntax
12:56:46 <ski_> ricebowl : note how this is a bit similar to nested loops
12:57:26 <ricebowl> ski_ - right, but I'm still missing the underlying principles, so it all appears as magic to me
12:57:44 <araujo> Right now, i am thinking ina good way to abstract program processes so it can interface with Haskell code.
12:58:00 <xerox> araujo: GHCi? :-)
12:58:05 <ricebowl> it would be as to a non-programming-literate person suddenly being introduced to generics (templates in C++ speak)
12:58:17 <ski_> ricebowl : so, in the list monad, the order given by the sequencing describes which varying things varyes fastest, so to speak
12:58:18 <ricebowl> makes absolutely no sense because you have no grasp on how it functions
12:58:33 <araujo> xerox, yeah?, can i do it with ghci?
12:58:52 <xerox> araujo: run Haskell code from a command line, at least
12:59:05 <ski_> ricebowl : how what functions ? the particular monads, underneath ?  or how and why to use and think about the monads ?
12:59:11 <poetix> xerox: Some progress with hobby, but I'm puzzled about how to make the next bit work.
12:59:20 <MenTaLguY> hrm
12:59:23 <araujo> xerox, ooh, hah, of course
12:59:27 <MenTaLguY> another naming question, though not really Haskell-specific
12:59:32 <xerox> araujo: or check it out plugs in hs-plugins for an (dynamic) eval-based version of GHCi.
12:59:34 <ricebowl> ski_ - nevermind, this is just going to go in circles, I'll keep reading :p
12:59:42 <xerox> poetix: what exactly?
12:59:44 <MenTaLguY> I've got a mutable ordered collection of callbacks
12:59:44 <ski_> ricebowl : ok :)
12:59:45 <araujo> xerox, yes, i am using hs-plugins
12:59:49 <MenTaLguY> what should I call it?
12:59:54 <xerox> araujo: did you see plugs?
12:59:59 * araujo needs to think over this better
13:00:04 <poetix> xerox: I'm waiting for a callback from the external lib, to tell me the connection's established and I can log in
13:00:05 <araujo> xerox, yes, i did.
13:00:21 <ricebowl> actually, can you explain the difference between "first-order" and so forth terminology?
13:00:26 <poetix> The trouble is, I don't seem to be getting the callback.
13:00:27 <xerox> poetix: do you mind going to #haskell-overflow?  signal/noise is getting lowered
13:00:33 <ricebowl> "Actions are first order values ..." <-- not sure what that means
13:00:33 <poetix> xerox: Sure
13:00:51 <ski_> ricebowl : hm, i presume they mean "first-class" ..
13:00:58 <ricebowl> first-class as well, then :p
13:01:14 <ricebowl> I have only heard it in the context of functional programming and am not familiar with the term
13:01:29 <ricebowl> does that mean that it acts as data -- it can be computed on?
13:01:39 <MenTaLguY> ricebowl: exactly
13:01:46 <araujo> first class citizens.
13:01:50 <MenTaLguY> and that they have distinct data types
13:02:01 <ski_> ricebowl : somthing being a first-class value means that you can pass around it, pass as argument, return from function, store and retrieve from data structures
13:02:35 <ski_> ricebowl : basically, it's use isn't restricted, with respect to other values
13:02:50 <araujo> They can be anywhere in which you can have other data.
13:03:07 <ski_> e.g. functions in Pascal isn't fully first-class since you can't return or store them (but you can pass them as arguments)
13:03:14 <ricebowl> *nods*
13:03:14 <ski_> right
13:03:23 <ricebowl> ok, that makes sense
13:03:44 <ricebowl> am a bit rusty on Pascal, but it's the same in most (all?) imperative languages
13:03:47 <ski_> @type sequence
13:03:48 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:03:59 <araujo> ricebowl, what?
13:04:06 <ski_> that wouldn't be possibly if monadic actions weren't first-class values
13:04:09 <ricebowl> that functions are not first-class
13:04:11 <mauke> ricebowl: depends on if you count Perl as imperative
13:04:15 <mauke> or Lisp
13:04:25 <ricebowl> LISP is weird, but most people classify it as functional
13:04:34 <ricebowl> perl...yeah, good point. And I have used that feature. ;)
13:04:37 <araujo> ricebowl, not the same, you can find imperative languages (through different paradigms) that might have first class functions.
13:04:38 <ski_> ricebowl : functions in C is first-class .. otoh, it's not the same kind of functions
13:04:40 <MenTaLguY> LISP is so heavily multi-paradigm it transcends language paradigms
13:04:44 <araujo> For example, some OOPL
13:04:51 <ricebowl> ski_ - how so?
13:04:54 <MenTaLguY> but much LISP code is relatively imperative
13:04:54 <SamB> araujo: only they won't be functions ;-)
13:05:06 <araujo> Right, they are more like methods.
13:05:09 <MenTaLguY> well, compared to most Haskell code ^_-
13:05:10 <ski_> you can return a function (pointer) and store it in datastructures, etc
13:05:15 <ski_> but
13:05:17 <ricebowl> in C you can't construct functions at runtime
13:05:22 <ricebowl> which isn't quite the same
13:05:26 <SamB> actually, I meant they would be procedures...
13:05:30 <mauke> ski_: yeah, but that doesn't buy you much without closures/anonymous functions
13:05:30 <ski_> right
13:05:43 <ski_> ricebowl : that's what i meant by saying it's not the same class of functions
13:05:47 <ski_> only toplevel functions
13:06:00 <araujo> I think that'd depend pretty much upon the language.
13:06:17 <ski_> mauke : indeed .. but for the functions that C provide, they are first-class
13:06:32 <araujo> Well, some would say Lisp is dis-functional :-]
13:06:37 <ricebowl> haha
13:06:41 <ski_> (there's some term for what i called 'toplevel function', but i can't recall it rn)
13:07:15 <mauke> heh, so C has first-class functions but not first-class arrays
13:07:23 <araujo> ski_, Functions that takes other functions?
13:07:44 <ski_> there is anyway a transformation called 'firstification' than transforms a program using closure-functions into only toplevel functions, iirc
13:07:52 <SamB> mauke: but they are worthless because they can't be nested!
13:07:54 <Maddas> mauke: Surely functions are more important than arrays :-)
13:07:57 <ricebowl> mauke - arrays can be passed around in the same sense that functions can be
13:08:12 <ricebowl> arrays are more "first-class" than functions
13:08:16 <mauke> ricebowl: I disagree
13:08:20 <ski_> araujo : no, functions that don't use nonlocals .. (module globals, say)
13:08:33 <mauke> because it actually makes sense to copy an array
13:08:57 <ski_> ricebowl : arrays in which language ?
13:09:06 <ricebowl> ski_ - still referring to C
13:09:18 <MenTaLguY> array's aren't really first-class in C
13:09:22 <ricebowl> I forget now whether it's possible to pass arrays by-value
13:09:23 <MenTaLguY> you can only represent them indirectly through pointers
13:09:27 <MenTaLguY> you can't
13:09:34 <ricebowl> MenTaLguY - and functions aren't? :p
13:09:35 <mauke> ricebowl: no, because C doesn't have array values
13:09:36 <MenTaLguY> pass them by value, or even, really, reference
13:09:40 <araujo> ski_, ok, got confused with "higher-order functions"
13:09:47 <ski_> there are two different array concepts in C
13:09:54 <ricebowl> mauke - well maybe I'm confusing C and C++; semantics do differ slightly
13:10:00 <MenTaLguY> ricebowl: function pointers have a distinct identity, as compared to general pointers
13:10:01 <mauke> ricebowl: no, C and C++ are the same there
13:10:07 <ricebowl> hm
13:10:51 <ricebowl> isn't it possible to write void foo(int array[])? And you can add a subscript as well...
13:11:01 <mauke> ricebowl: that makes a pointer
13:11:11 <ricebowl> I see. Non-intuitive...
13:11:22 <ricebowl> I always go the pointer route anyway
13:11:33 <mauke> C arrays support three operations: & (address-of), sizeof, decay to pointer to first element
13:11:44 <mauke> note that copying or indexing is not in the list
13:11:52 <MenTaLguY> yeah, with the exception of directly declaring an array object, arrays do not really exist in C/C++
13:12:06 <MenTaLguY> all other uses of the array syntax merely use pointers
13:12:17 <ricebowl> *nods*
13:12:36 <ski_> typedef struct { char name[16]; } Foo;
13:12:40 <ricebowl> I suppose that is true, then, though Java has distinct array pointers
13:12:48 <glguy> they don't exist in C,  but they exist in the C++ library
13:12:53 <MenTaLguY> arrays are indeed first-class objects in Java
13:13:14 <glguy> and the C++ library is a big part of what makes C++ C++
13:13:14 <MenTaLguY> STL vectors aren't features of the language, per se, nor are they arrays as such
13:13:28 <MenTaLguY> they just overload the [] operator
13:13:33 <ski_> that is a type isomorphic to 16-element array of char
13:13:56 <ski_> so, arrays do exist .. only they aren't first-class
13:13:57 <glguy> anyway, I came in late in the discussion, so that's all I'll say :)
13:13:58 <ricebowl> ski_ - but not interchangable...
13:14:08 <ski_> sure
13:16:02 <ricebowl> oh well; getting back on-topic, is there an easy way to take a return value of (a, [b]) and cons to the front of the second element? :p
13:16:13 <MenTaLguY> yeah
13:16:28 <MenTaLguY> well, hrm
13:16:37 <MenTaLguY> couple ways
13:16:43 <MenTaLguY> I guess they don't count as ultra-easy
13:16:48 <mauke> @pl \(a, b) -> a : b
13:16:49 <lambdabot> uncurry (:)
13:17:05 <MenTaLguY> ohh
13:17:10 <ricebowl> I keep having to run the computation in a where clause and then built the tuple back up from the constituent parts
13:17:10 <basti_> not if a and b are different types though
13:17:29 <MenTaLguY> he doesn't want to cons fst onto snd, but rather keep fst and just modify snd, essentially
13:17:34 <ricebowl> right
13:17:48 <basti_> modifying things is hard.
13:17:56 <basti_> but \(a,b)->(a,a:b)?
13:17:59 <MenTaLguY> well, "modify" with scare quotes
13:18:08 <ricebowl> oh well; perhaps I am just thinking about the problem incorrectly
13:18:24 <basti_> @eval (\(a,b)->(a,a:b))  1 [2..4]
13:18:26 <lambdabot>   The function `(\ (a, b) -> (a, a : b))' is applied to two arguments,
13:18:26 <lambdabot>   but its type `(a, b) -> (a, b)' has only one
13:18:26 <lambdabot>   In the definition of `xxxx': xxxx = (\ (a, b) -> (a, a : b)) 1 ([2
13:18:26 <lambdabot> .. 4])
13:18:29 <MenTaLguY> I think what he wants is the similar but different \a (b, c) -> (b, a:c)
13:18:31 <basti_> arhg
13:18:36 <basti_> @eval (\(a,b)->(a,a:b)) (1,[2..10])
13:18:37 <lambdabot> (1,[1,2,3,4,5,6,7,8,9,10])
13:18:52 <MenTaLguY> i.e.
13:18:54 <ricebowl> MenTaLguY - yes, right
13:19:01 <ricebowl> that's exactly what I ended up doing before :S
13:19:11 <ricebowl> but it's a fair bit of typing
13:19:11 <mauke> @pl \x (a, b) -> (a, x : b)
13:19:13 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,)) . (:)
13:19:19 <mauke> OBVIOUS
13:19:20 <basti_> urgh
13:19:21 <MenTaLguY> @eval (\a (b, c) -> (b, a:c)) 1 ('k', [2..10])
13:19:23 <lambdabot> ('k',[1,2,3,4,5,6,7,8,9,10])
13:19:29 <basti_> scaary
13:19:59 <MenTaLguY> let's see ... (,) is .. oh, I see
13:20:03 <MenTaLguY> a curried tuple constructor
13:20:04 <MenTaLguY> wow
13:20:05 <basti_> yes
13:20:10 <basti_> isnt that cool?
13:20:14 <MenTaLguY> very cool
13:20:33 <basti_> @eval (,,) 2 "hello" (Just ())
13:20:34 <lambdabot> (2,"hello",Just ())
13:20:42 <MenTaLguY> that's one reach I so strongly prefer Haskell to the other ML dialects
13:20:44 <ricebowl> oh wow, neat :o
13:20:48 <MenTaLguY> the syntax is simply so symmetric
13:22:03 <basti_> @eval (:) 1 []
13:22:05 <lambdabot> [1]
13:22:09 <ski_> @type (Control.Arrow.***) id . (:)
13:22:11 <basti_> do you see a pattern there?
13:22:11 <lambdabot> forall b a. a -> (b, [a]) -> (b, [a])
13:22:25 <ski_> @eval ((Control.Arrow.***) id . (:)) 1 ('k', [2..10])
13:22:27 <lambdabot> ('k',[1,2,3,4,5,6,7,8,9,10])
13:22:44 <basti_> ski_: youre nuts.
13:23:05 <ricebowl> well, enough thinking for the moment; I'll come back to this later :p
13:23:16 <ricebowl> bbl
13:23:30 <ski_> one could also use  instance Functor ((,) a)
13:23:36 <ski_> basti_ : ty
13:23:58 <ski_> @type fmap . (:)
13:24:00 <lambdabot> forall (f :: * -> *) a. (Functor f) => a -> f [a] -> f [a]
13:24:13 <ski_> @type \(x,y) -> (fmap . (:)) (x,y)
13:24:15 <lambdabot> forall a b (f :: * -> *).
13:24:15 <lambdabot> (Functor f) =>
13:24:15 <lambdabot> (a, b) -> f [(a, b)] -> f [(a, b)]
13:24:28 <ski_> hm
13:24:31 <basti_> o.0
13:24:48 <ski_> @type \a (x,y) -> (fmap . (:)) a (x,y)
13:24:50 <lambdabot> forall a a1. (Functor ((,) a)) => a1 -> (a, [a1]) -> (a, [a1])
13:24:57 <ski_> yes, that's the one
13:25:25 <ski_> so 'fmap . (:)' would work just as well as '(Control.Arrow.***) id . (:)'
13:25:42 <ski_> (given the obvious instance)
13:27:03 <neadjneki> how does ghc know where to search for imports on windows?
13:27:51 <Philippa> ghc-pkg
13:36:12 <neadjneki> several modules can be part of a package, right? so how can i know whether a certain module is part of a package, and which one?
13:39:44 <boegel|home> grr
13:40:00 <neadjneki> more importantly where are these packages defined ..
13:40:11 <boegel|home> somehow the color depth of my FC4 installation got changed, anybody know how to change that ? sucks when I'm looking at a film on dvd
13:41:18 <cjb> Weird.  You change in /etc/X11/xorg.conf, at the 'DefaultColorDepth' (or something) directive.
13:44:29 <boegel|home> cjb: it says 'DefaultDepth 24'
13:46:36 <boegel|home> @seen Itkovian
13:46:37 <lambdabot> I saw Itkovian leaving #haskell-overflow, #haskell-blah and #haskell
13:46:37 <lambdabot> 1 day, 3 hours, 40 minutes and 22 seconds ago.
13:48:09 <cjb> boegel|home: Oh, and something's changing it?  Huh, I didn't think you could change the depth of a running X server.
13:49:56 <boegel|home> cjb: I didn't touch anything, but when I booted my laptop today, the color depth is really crappy
13:49:58 <SamB> cjb: maybe it depends on the implementation?
13:50:19 <boegel|home> then gui in preferences says it uses 'millions of colors', but aparently that's not the case
13:50:22 <cjb> boegel|home: Oh!  Your laptop was suspended, or a cold boot?
13:50:30 <SamB> boegel: there is also a command-line option to the X server...
13:50:31 <cjb> 'cause I've *certainly* need colour depths go freaky after suspend/resume.
13:50:43 <boegel|home> cjb: cold boot, suspending isn't working yet :)
13:50:48 <cjb> Hm.
13:51:10 <boegel|home> just rebooted too, I though maybe i hit some key while rebooting, but no :)
13:51:30 <boegel|home> man, my english sucks tdoay :) or rather, my typing sucks :)
15:06:28 <JKnecht> reads Milners notes/emails ( http://www.cis.upenn.edu/~bcpierce/types/archives/1988/msg00042.html )
15:07:56 <JKnecht> wonder if 'Henk' is Barendregt?
15:11:16 <sethk> JKnecht, wouldn't think so
15:11:29 <sethk> JKnecht, sounds like a duck with a head cold
15:13:41 <JKnecht> :)
15:21:50 <eivuokko> What is _ called in natural speech/text?
15:24:01 <Dibrom> underline?
15:24:48 <stepcut> underscore ?
15:25:11 <eivuokko> I sort of meant the on used in patterns..
15:25:15 <eivuokko> *one
15:26:01 <Dibrom> wildcard, otherwise, anything? not sure it has a specific name
15:26:04 <stepcut> possible, "don't care"
15:27:10 <eivuokko> Dibrom, ah, otherwise/anything sound sensible when code is read out loud.  Thanks.
15:27:30 <Dibrom> np
15:37:42 <CosmicRay> hey sethk
15:38:13 <CosmicRay> sethk: used perl's DBI much?
15:39:20 <Dibrom> anyone know of a particularly good template haskell tutorial with up to date ghc syntax?
15:39:57 <Cale> I don't know of relatively up to date documentation, let alone a tutorial.
15:40:16 <Dibrom> damn
15:40:37 <Cale> but you can still manage to learn it, I think
15:40:52 <Dibrom> yeah
15:41:03 <Dibrom> will just be more work ;)
15:41:10 <Cale> Someone just needs to collect up the existing material into one place and make sure everything is up to date
15:41:16 <Cale> I'd start with the papers
15:41:31 <Dibrom> those are the most out of date of all though, aren't they?
15:42:35 <Cale> yeah, but things haven't changed all *that* much conceptually
15:43:00 <Dibrom> well the concept I don't think is much of a prob, as long as I can find some valid syntax to examine
15:43:07 <Cale> you'll find that things might have been renamed slightly -- the up-to-date names are in the GHC modules documentation
15:43:09 <Dibrom> I can probably infer most of the important stuff from that and save a lot of time
15:43:28 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html points at a bunch of stuff
15:43:39 <Dibrom> yeah, been looking at that a bit
15:53:27 <araujo> Hola Nomius_
15:54:53 <Nomius> HOla
15:56:01 <Nomius> Whoever you are...
16:00:41 <vina> hi people... Is somebody here using programatica tools?
16:01:16 <araujo> Nomius, .ve here, i see you are from .ar
16:01:53 <Nomius> Yeap :-)
16:19:39 <JKnecht> who was Miranda?
16:21:10 <araujo> And independence soldier here in my country
16:22:29 <araujo> http://en.wikipedia.org/wiki/Francisco_de_Miranda
16:23:59 <JKnecht> so the FP predecessor to Haskell was named for him?
16:26:36 <araujo> oh, i wouldn't know.... the name is trademarked by some company in the UK
16:29:30 <tuomov> it's snowing
16:29:51 <Cale> hmm... interesting -- the original miranda system seems to have some sort of feature on algebraic datatypes which sounds like a quotient (called "laws"), but I haven't found much information on it
16:32:41 <JKnecht> hmm... Turners '86 Sigplan Notices report doesn't seem to say.
16:33:32 <Cale> Apparently "Miranda: A Non-Strict Functional Language with Polymorphic Types" Turner 1985 has info on it
16:34:08 <Cale> I'll see if I can download that
16:37:18 <Dibrom> Cale: are those GHC template haskell docs out of date? They say 'latest', but the stuff I'm doing returns type ExpQ for stuff I need to splice, whereas the GHC docs say it should be type 'Q Exp'
16:37:31 <JKnecht> i suspect a personal relation of Turners.
16:38:09 <Cale> Dibrom: type ExpQ = Q Exp
16:38:16 <Cale> from http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html
16:38:29 <Dibrom> it's a type synonym?
16:38:33 <Cale> yep
16:38:39 <Dibrom> ah ok, good
16:39:15 <Dibrom> starting to get the hang of this I think
16:39:30 <Dibrom> sort of annoying that you have to split the template stuff out into a separate file though
16:39:57 <Cale> yeah
16:40:01 <Cale> that is annoying
16:40:35 <Dibrom> do you know if this is a theoretical issue, or just an architectural issue?
16:40:43 <Dibrom> it would be nice if they could remove that restriction in the future
16:47:19 <Cale> hmm, the acm digital library has a bad simple search, but the advanced search appears to work okay
16:49:54 <Cale> integer ::= Zero | Succ integer | Pred integer
16:50:01 <Cale> Succ (Pred n) => n
16:50:05 <Cale> Pred (Succ n) => n
16:50:29 <JKnecht> Cale: i prefer to walk the directory tree for known items.
16:53:43 <JKnecht> hmmm, Miranda was the daughter of Prospero.
16:54:09 <Cale> wow, cool, you could even write olist * ::= Onil | Ocons * (olist *). Ocons a (Ocons b x) => Ocons b (Ocons a x), a > b.
16:54:20 <Cale> and get the type of ordered lists
16:54:55 <Cale> ohead (Ocons a x) = a  would suffice to find the least element of the list :)
16:55:42 <Cale> there must be some horrible problem with them, or they wouldn't have been removed
16:56:11 <Cale> I hope it's not just efficiency, this sort of automatic rewriting could be handy.
16:56:27 <integral> can't you get the same effect just by using a function wrapped around the constructor rather than the constructor?
16:56:46 <integral> succ (Pred n) = n; succ x = Succ x
16:58:24 <Cale> integral: well, that's not quite the same as ensuring that they're always in normal form -- you can hide the constructors, but then you're not allowed to pattern match
16:59:15 <integral> ah, yes, you'd have to trust the user never to use the constructors to construct =)
17:02:48 <Mask> In hugs, what does the error message "Instance of (type) required for definition of (function)" mean?
17:03:03 <Cale> (type) is actually a class
17:03:34 <Mask> Oh, oops
17:03:45 <Cale> classes can be thought of as relations which can be true or false on a type, and when they're true, they provide some functionality
17:04:13 <Cale> For instance, the class Eq tells whether elements of a type can be compared for equality
17:04:23 <Cale> and when they can, it provides (==) and (/=)
17:04:32 <Igloo> I can't get that error, but it's probably a class /and/ a type
17:04:57 <Cale> oh, yeah, it's a particular instance
17:05:12 <Dibrom> interesting that Q is a monad
17:05:20 <Dibrom> guess it makes sense though.. runIO is very cool
17:05:21 <Cale> It'll say something like "Instance of Eq (a -> b) required for definition of foo"
17:05:45 <Mask> Yeah, I have Num (Int,[Int])
17:06:05 <Mask> But, what does it mean? Is my function not returning the right thing?
17:06:07 <Igloo> It means you've done something like x+1 where x has type (Int,[Int])
17:06:10 <Cale> Right, that means that somewhere you applied an operation like * or + to a value of type (Int,[Int])
17:06:26 <Mask> Oh, thanks
17:06:29 <Igloo> And the + being applied to it means it must have a Num type
17:06:29 <Cale> Which is valid if you provide an instance of Num for those
17:07:13 <Igloo> Or you've written 0 instead of (0, []) or something
17:08:26 <Cale> These laws are like a restricted version of the pattern matching/manipulation that gets done in mathematica.
17:09:26 <JKnecht> I suppose the most compelling explanation is the "Miranda Laws" and the connection this would have to types.
17:10:58 <stepcut> alright! My first contribution to the wiki! http://www.haskell.org/hawiki/C_2b_2bFromHaskell
17:11:15 <stepcut> it's a bit of a hack job all around though :p
17:11:47 <Cale> stepcut: looks nice actually :)
17:12:44 <JKnecht> yes.
17:12:48 <Dibrom> is template haskell supported in anything besides ghc?
17:13:48 <stepcut> Dibrom: not that I know of --though there may be an out of date pre-processor...
17:13:56 <Cale> heh, I love how searching for "hugs" gives hugs98 as the first hit.
17:14:23 <stepcut> Cale: well, the information is pretty hard to find anywhere else -- so in that sense it is pretty nice
17:14:40 <stepcut> Cale: but, I don't think I will be getting accepted into any journals anytime soon :p
17:15:15 <Cale> eh, that's pretty nice for a wiki page.
17:15:44 <stepcut> :p
17:16:01 <Dibrom> stepcut: ok
17:16:06 <Dibrom> too bad, this seems very powerful
17:16:11 <Dibrom> I hope it catches on with more compilers
17:16:27 <stepcut> Cale: My long term goal is to make something like wxFruit for KDE
17:16:27 <Cale> Someone should hack up some FFI support for g++ compiled C++ programs.
17:17:03 <stepcut> Cale: of course, even different versions of g++ mangle differently :
17:17:05 <stepcut> :.
17:17:06 <stepcut> :p
17:17:09 <Cale> ow
17:17:30 <Cale> I suppose you could use the presently installed g++ as the "standard"
17:17:38 <stepcut> That is why debian and friends are having a fit with the gcc 3.0 -> 4.0 transition
17:17:51 <Cale> yeah, that seems like a really very stupid issue
17:18:01 <SamB> stepcut: I thought we ALREADY had our fit!
17:18:13 <stepcut> SamB: is it done ?
17:18:17 <stepcut> brb
17:18:53 <Cale> If I used C++, I'd be complaining about that.
17:19:14 <SamB> stepcut: I mean, didn't we have one at 3.2 or 3.3 ?
17:19:30 <Cale> Not like there's really a standard for interfacing programs written in different Haskell compilers either...
17:19:40 <SamB> Cale: me too
17:19:53 <stepcut> SamB: yeah, the c102 transition-- but now there is the c1002 transition :p
17:20:25 <SamB> what do these names mean?
17:20:28 <Cale> Perhaps Haskell should deal with this before it gets to the point where there are a whole bunch of incompatible Haskell compilers.
17:20:39 <SamB> Cale: why would there be?
17:20:55 <Cale> SamB: many compilers?
17:20:56 <SamB> why would you want compatible haskell compilers?
17:21:13 <SamB> you don't even have compatible minor library revisions...
17:21:28 <SamB> Cale: no, why would there be a standard?
17:21:29 <Cale> I suppose that's true :)
17:22:18 <Cale> But eventually, people are going to want to write libraries in Haskell which are distributed in binary form.
17:22:24 <ndm> so you can have compatible tools
17:22:34 <stepcut> could be nice to compile some CPU intensive routines with a highly optimizing compiler, but be able to use all the GHC extensions in the rest of the program...
17:22:34 <ndm> like debuggers/refactors etc.
17:22:53 <Cale> yeah
17:23:04 * stepcut goes to make dinner
17:23:24 <SamB> Cale: well, they are going to have to figure out how to do that without sacrificing performance, or give up!
17:24:10 <Cale> SamB: doesn't separate compilation already kind of mess that up?
17:24:29 <SamB> Cale: not with cross-module inlining
17:25:45 <SamB> also, wouldn't you need a common RTS?
17:26:04 <Cale> hmm
17:26:44 <Cale> well, no, I don't think necessarily, at the cost of a little efficiency.
17:27:04 <Cale> (or potentially quite a bit, I suppose)
17:27:10 <Cale> What's the least information necessary to be able to know how to inline a function/value from a library?
17:27:51 <SamB> you could just use FFI both ways...
17:28:20 <SamB> well, maybe.
17:28:21 <Cale> hmm...
17:28:46 <Cale> polymorphic types are maybe tricky
17:28:51 <Cale> maybe not
17:29:23 <Cale> since you could guarantee that it doesn't matter what the values are
17:29:38 <Cale> I suppose you need at least a data standard for the RTS
17:29:40 <SamB> but really, can't we worry about that sort of thing when such nasty people show up?
17:29:59 <Cale> heh
17:31:48 <Cale> As long as there's a relative compiler monopoly, it's okay, I suppose.
17:32:54 <SamB> Cale: I think at this point source compatability is more interesting...
17:38:16 <ndm> Cale, a compiler monopoly means a weaker standard...
17:38:26 <ndm> and less future compatability guarantees
17:42:07 <syntaxfree> ahoy.
17:45:14 <syntaxfree> helllooooo.
17:45:37 <stepcut> hello
17:45:45 <syntaxfree> I'm bored.
17:45:53 <stepcut> :p
17:46:23 <syntaxfree> and boegel STILL hasn't posted my south park doll.
17:47:02 <stepcut> !!
17:47:06 <Peach44> Hello all
17:47:08 <syntaxfree> @type (!!)
17:47:14 <lambdabot> forall a. [a] -> Int -> a
17:47:55 * stepcut has too many projects going on to be bored
17:47:57 <syntaxfree> @pl i x n = (cycle x) !! n
17:47:57 <lambdabot> i = (!!) . cycle
17:48:11 <syntaxfree> hmm. what kind of projects?
17:48:14 <syntaxfree> hello Peach.
17:48:27 <stepcut> (a) A binding to KDE
17:48:37 <syntaxfree> to KDE or just Qt?
17:48:49 <stepcut> (b) A library for doing Decimal arithmetic
17:49:00 <syntaxfree> explain (b) better.
17:49:01 <stepcut> (c) A realtime synth
17:49:07 <SamB> stepcut: KDE? sounds like madness!
17:49:07 <syntaxfree> wow. big stuff.
17:49:19 <Peach44> how to i evaluate the type of something? is it: type "blah" ?
17:49:21 <stepcut> SamB: well, I haven't gotten very far yet :p
17:49:23 <SamB> doesn't that require a preprocessor?
17:49:40 <syntaxfree> KDE has a transparent object model that's very cool.
17:49:48 <sethk> Peach44, in ghci?  :type (blah)
17:49:52 <SamB> @type "blah"
17:49:53 <syntaxfree> lotsa things can be accomplished from the command line.
17:49:53 <lambdabot> [Char]
17:49:55 <stepcut> SamB: KDE has a moc preprocessor, but that is not needed for a haskell binding
17:50:03 <syntaxfree> I wish Apple would do something like that for Cocoa.
17:50:09 <Peach44> thanks sethk
17:50:19 <stepcut> SamB: but I do need to parse the headers files (hopefully using gcc-xml...)
17:51:13 <Dibrom> syntaxfree: do what for Cocoa?
17:51:17 <Peach44> why does head of a list always have type Char ?
17:51:33 <Peach44> my list: ["one","two","three]
17:51:36 <Peach44> head = "one"
17:51:42 <syntaxfree> in KDE, you can, say, change a toolbar's place from the command line, messing with the objects.
17:51:42 <stepcut> syntaxfree: regarding (b) - This is pretty much exactly what I want and why I want it -- except for haskell instead of python -> http://www.python.org/peps/pep-0327.html
17:51:50 <syntaxfree> Peach44: not necessaryly!
17:51:56 <syntaxfree> @type head $ [1,2,3]
17:51:57 <lambdabot> forall a. (Num a) => a
17:52:14 <syntaxfree> @type head $ ["One", "two", "three"]
17:52:16 <lambdabot> [Char]
17:52:24 <syntaxfree> @type head $ "One"
17:52:25 <lambdabot> Char
17:52:34 <Peach44> i see.. a list of chars
17:52:45 <syntaxfree> a string is a list of chars.
17:52:50 <Peach44> yes
17:53:11 <syntaxfree> @eval tail $ "This sentence hasn't got no first character"
17:53:14 <lambdabot> "his sentence hasn't got no first character"
17:53:23 <Peach44> ok... i have a function which needs to take in a [String] - now the input is the head of a list - which won
17:53:29 <syntaxfree> @eval "How cool is this" !! 7
17:53:30 <lambdabot> 'l'
17:53:33 <Peach44> which won't work as it is the wrong type
17:53:37 <Peach44> how can i fix that ?
17:53:57 <syntaxfree> hmm. You want to feed a character to a function that needs a string?
17:54:16 <Peach44> want to feed in a [Char] as a [String]
17:54:28 <Cale> Peach44: what should that mean?
17:54:29 <syntaxfree> I don't understand.
17:54:34 <syntaxfree> what is a [String]?
17:54:39 <Peach44> List of strings ?
17:54:41 <Cale> perhaps you want [c]?
17:54:52 <syntaxfree> oh, so it's a [[Char]]
17:54:54 <Cale> yes
17:55:03 <Dibrom> syntaxfree: have you seen fscript?
17:55:09 <syntaxfree> Dibrom: not really.
17:55:25 <Dibrom> it lets you mess with objective-c stuff from a commandline type interface, almost sort of like a repl
17:55:39 <syntaxfree> cool.
17:55:44 <syntaxfree> Will look into it.
17:55:49 <Dibrom> http://www.fscript.org/
17:56:01 <syntaxfree> anyway.
17:56:07 <syntaxfree> Peach44: let me see if I understand.
17:56:12 <Peach44> ok
17:56:16 <syntaxfree> you have a function that takes something like ["One", "two", "three"]
17:56:19 <syntaxfree> a list of strings.
17:56:21 <Cale> Peach44: you can just wrap the thing in [] before passing it in
17:56:27 <syntaxfree> @type ["One", "two", "three"]
17:56:28 <lambdabot> [[Char]]
17:56:37 <syntaxfree> but you want to pass ["One"]
17:56:39 <Cale> like, passing ["Hello"] rather than "Hello"
17:56:48 <syntaxfree> yeah, what Cake said. Wrap the thing in [].
17:56:56 <Cale> Cale
17:56:58 <Cale> hehe
17:57:02 <Peach44> I tried that.. still get the type mismatch
17:57:07 <syntaxfree> damn, there goes my first opportunity to actually help someone ;-)
17:57:12 <Cale> Peach can we see the code?
17:57:12 <syntaxfree> Peach44: can we see the function?
17:57:19 <Peach44> sure one sec
17:57:21 <syntaxfree> if it's long, use http://paste.lisp.org
17:57:28 <Cale> or
17:57:30 <Cale> @paste
17:57:31 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:57:49 <syntaxfree> is HaskellIrcPastePage unlocked for people without hawiki ids?
17:57:56 <Peach44> one sec
17:58:35 <syntaxfree> stepcut: the Decimal thing sounds interesting.
17:58:44 <Cale> syntaxfree: oh, perhaps not.
17:58:48 <syntaxfree> stepcut: Sounds like something I'd use for my planned financial apps.
17:58:52 <stepcut> syntaxfree: I am having difficulty dealing with the 'context'
17:59:09 <syntaxfree> stepcut: I think I don't have the mojo to help there yet :)
17:59:29 <stepcut> syntaxfree: ie, being able to use different rounding or precision, or change what conditions are errors
17:59:40 <stepcut> syntaxfree: but I have some ideas
17:59:51 <Peach44> http://paste.lisp.org/display/12776
17:59:55 <syntaxfree> A simple representation for a decimal is an (Int, Int) tuple.
18:00:00 <Peach44> its the last function
18:00:06 <Peach44> buildHtml
18:00:17 <stepcut> syntaxfree: darcs get http://www.n-heptane.com/nhlab/repos/Decimal/ if you want to play with what I have so far
18:00:19 <syntaxfree> WOW. Nested guards.
18:00:39 <Cale> well, nested functions
18:00:55 <syntaxfree> that too.
18:01:00 <Peach44> lol :P
18:01:15 <syntaxfree> I didn't expect the spanish inquisition.
18:01:36 <Peach44> line 58 is the one with the problem
18:01:40 <Cale> right
18:01:44 <Peach44>          | isKeyword [template] = (getContent template)++(buildHtml templates)
18:01:57 <Peach44> isKeyword :: [String]->Bool
18:02:13 <Cale> type FileContents         = String
18:02:22 <Cale> so template :: Char
18:02:32 <Cale> so [template] :: [Char]
18:02:34 <Peach44> crap
18:02:46 <Peach44> forgot to use words first
18:02:55 <Peach44> words template should do the trick
18:03:46 <sethk> Peach44, function, not template
18:03:55 <Cale> sethk: hm?
18:04:06 <Peach44> yes.. i know words is a func
18:04:15 <Peach44> just saying... my usuage should read "words template"
18:04:23 <Peach44> template is my own variable
18:04:26 <sethk> oh, sorry
18:04:30 <Peach44> np :)
18:04:30 <sethk> my mistake  :)
18:05:51 <Peach44> ohh.. still same problem
18:05:52 <syntaxfree> I wonder when someone will come in with a question I can answer ;-)
18:05:58 <Peach44> one sec.. gonna fiddle with it some more
18:07:07 <Peach44> :(
18:07:55 <lisppaste2> peach44 pasted "Haskell" at http://paste.lisp.org/display/12777
18:08:22 <stepcut> syntaxfree: what is your favorite color?
18:08:24 <stepcut> :p
18:08:34 <syntaxfree> european or african color?
18:08:39 <Peach44> now how do i go about fixing it - i'm getting same problem
18:08:47 <Peach44> type mismatch [Char] against [String]
18:08:51 <stepcut> syntaxfree: I don't know.... AAAAHHHHHHHHH
18:08:59 <syntaxfree> yay for mixed Holy Grail jokes.
18:09:07 <Peach44> template = Char -- and i want it to be a String
18:09:08 <stepcut> :p
18:09:28 <Peach44> template = [Char] -- and i want it to be a [String] (sorry.. they lists)
18:09:35 <Peach44> they're*
18:10:00 <Peach44> any idea how to convert it :=/
18:10:01 <Cale> isKeyword :: [String] -> Bool ?
18:10:04 <syntaxfree> if I'm not a complete idiot, then [String] is [[Char]], right?
18:10:15 <Cale> or shouldn't it be isKeyword :: String -> Bool
18:10:17 <sethk> syntaxfree, it is even if you are a complete idiot
18:10:25 <Cale> syntaxfree: String is a synonym for [Char]
18:10:31 <sethk> syntaxfree, the two are functionally independent
18:10:47 <syntaxfree> so char2string x = [x], ain't?
18:10:56 <syntaxfree> @pl char2string x = [x]
18:10:57 <lambdabot> char2string = return
18:11:10 <syntaxfree> @type return
18:11:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
18:11:24 <Peach44> tried [template] and it now tells me mismatch of [[Char]] against [Char] :P
18:11:25 <Cale> hehe, oooh
18:12:15 <Cale> Peach44: I think the first problem with your last program is that isKeyword has a type signature that's wrong
18:12:30 <Peach44> how is it wrong ?
18:12:34 <Cale> It just takes one string doesn't it?
18:12:39 <Peach44> yup
18:12:47 <Cale> then it shouldn't take a list of them
18:12:53 <Peach44> but it needs it to be a [String] so it can dump it in another function
18:13:09 <Peach44> getKeywordDefs takes [Strings]
18:13:24 <Cale> well, why not do that wrapping there
18:13:29 <Peach44> note, i'm making those changes at the moment
18:13:53 <Cale>        | isKeyword template = (getContent template)++(buildHtml templates)
18:14:03 <Cale> buildHtml isn't passed enough parameters there
18:14:11 <Peach44> :e
18:14:25 <Peach44> you have a point there
18:15:40 <Peach44> i think its fixed the problem i had with keywords
18:15:54 <Peach44> now its not liking buildHtml templates
18:16:01 <Cale> right
18:16:09 <Cale> because you didn't pass enough params
18:16:14 <Peach44> i've fixed that
18:16:27 <Cale> oh, that's also true
18:16:29 <Peach44> templates == list of Strings
18:16:37 <Peach44> i'll unword it.. should do the trick
18:16:38 <Cale> so you want unwords templates
18:16:40 <Cale> yes
18:16:53 <Cale> what's your second param?
18:17:00 <Peach44> content
18:17:35 <Cale> okay, it should compile
18:17:58 <Cale> though there are lots of ways to clean this up :)
18:18:48 <Peach44> so true :P
18:18:49 <Peach44> buildHtml unwords(templates) content
18:18:50 <syntaxfree> like running everything through @pl?  :-P
18:18:55 <Peach44> anything obviously wrong with that ?
18:19:09 <Cale> buildHtml (unwords templates) content
18:19:23 <Cale> parens are used to group things
18:19:30 <Cale> not for function parameters
18:20:01 <Cale> (x) is always the same as x if x is a single token
18:20:02 <Peach44> ohhhh it compiles
18:20:07 <Cale> :)
18:20:08 <Peach44> now to see if it does what its ment to do :P
18:20:15 <Peach44> doubt it.. but here goes
18:20:53 <Cale> There are lots of functions here with weak types, so it's not as likely as usual.
18:21:02 <Cale> But you'd be surprised :)
18:21:20 <Peach44> Program error: pattern match failure: buildHtml_v1578 []
18:21:28 <Peach44> heh... looks like i missed an exception :P
18:22:12 <Cale> that's hugs mutilated way of saying that you haven't defined buildHtml on the empty list
18:22:22 <Peach44> yes
18:22:53 <Cale> buildHtml [] content = []
18:22:53 <Cale>  ?
18:23:12 <Peach44> 	| inputTemplate == "" = ""
18:23:14 <Peach44> :)
18:23:41 <Cale> btw, == "" is not the best way to check if a string is empty
18:23:52 <Cale> the null function is better in general
18:23:55 <Peach44> what would get through
18:23:56 <Peach44> ok
18:24:21 <Cale> well, I suppose for strings, you're always going to be able to compare Chars, so there's no issue
18:25:00 <Cale> but in general list functions, "== []" forces the element type of the list to be an instance of the class Eq
18:25:10 <Cale> whereas null doesn't
18:25:14 <Peach44> i see
18:25:43 <Cale> (or you can just pattern match :)
18:26:47 <Peach44> thanks for the help
18:26:53 <Peach44> seems to be doing what it needs to :)
18:27:00 <Peach44> ..surprisingly :P
18:27:38 <Cale> isKeyword keyword = not . null $ getKeywordDefs [keyword]
18:29:00 <lambdawar> anyone familiar with temporal logic ?
18:30:26 <Cale> Peach44: btw, fst (x,y) = x; snd (x,y) = y
18:30:46 <Cale> ah, you're already using them here and there
18:36:11 <glasser> hmm.  I have a Map x [y].  (Or it could be a Map x (Set y).)  Is there a really simple way to turn that into a [Map x y] (or Set (Map x y)) which is essentially the "cartesian product" of the map?
18:37:30 <glasser> like, if I have a mapping to [1, 2], and b mapping to [3, 4], I'd like to get a list of a->1,b->3,   a->2, b->3, etc
18:38:30 <glasser> you know, like the list comprehension does for me
18:43:36 <Cale> hmm
18:57:51 <syntaxfree> does anyone use Clipper nowadays?
19:07:55 <dons> morning all
19:10:48 <Cale> commute m = map Map.fromList $ sequence [[(x,y) | y <- Map.findWithDefault [] x m] | x <- Map.keys m]
19:20:58 <Cale> glasser: is that what you're looking for?
19:23:41 <Cale> seems like there should be something shorter...
19:38:37 <sethk> How do you interpret this?  This is in response to a :t in ghci:      m :: StateT Integer ((,) [Char]) Double
19:38:49 <sethk> what does the (,) mean here?
19:39:16 <sethk> That is in the monad position of StateT s m a
19:39:53 <stepcut> very interesting...
19:40:25 <sethk> more interesting still, I can run that monad with runStateT
19:40:53 <sethk> but I don't know how to interpret (,)
19:41:08 <dons> it' a prefix (,)
19:41:17 <sethk> dons, meaning what?
19:41:30 <sethk> dons, prefix to [Char] ?
19:41:35 <dons> yeup
19:42:05 <sethk> *Main> (,) "test"
19:42:05 <sethk> Top level:
19:42:05 <sethk>     No instance for (Show (b -> ([Char], b)))
19:42:05 <sethk>       arising from use of `print' at Top level
19:42:05 <sethk>     Probable fix: add an instance declaration for (Show (b -> ([Char], b)))
19:42:08 <sethk>     In a 'do' expression: print it
19:42:10 <sethk> *
19:42:21 <dons> @type (,) 1 2
19:42:33 <lambdabot> forall a b. (Num a, Num b) => (a, b)
19:42:36 <dons> @kind (,) Int
19:42:37 <lambdabot> * -> *
19:43:41 <sethk> dons, in words, what is that prefix supposed to convey?  also, I have (,) with one, not two, succeeding type variables (or real variables)
19:44:03 <Cale> (,) = /\ a b -> (a,b)
19:44:03 <sethk> ah, it can take one or two args
19:44:06 <Cale> right
19:44:30 <dons> @kind []
19:44:32 <lambdabot> * -> *
19:44:35 <dons> @kind [] Int
19:44:36 <lambdabot> *
19:44:39 <dons> @kind [Int]
19:44:40 <lambdabot> *
19:44:44 <sethk> so it means "turn the next two things into a tuple"
19:44:51 <dons> it's just syntax  :)
19:45:00 <sethk> dons, the whole world is just syntax.  :)
19:49:24 <Cale> Type would be a better name for *
19:49:40 <Cale> [] is a sort of function from types to types
19:52:06 <JKnecht> cale: r u @ U of Toronto?
20:13:37 <sethk> Check me on this if you have a moment:  The MonadState methods get and put can't be used with a StateT monad.  The only way to get at the state in a StateT monad is with a function such as withStateT.  That is, the only thing you can do with a StateT monad is invoke a function with a StateT argument type.
20:16:36 <sethk> my reasoning is this:
20:16:53 <MenTaLguY> well, no, a StateT is used to wrap another monad
20:16:57 <sethk> to create a StateT monad, you either use the StateT constructor or the runStateT function
20:17:03 <sethk> MenTaLguY, yes, I know, but that's meaningless
20:17:34 <sethk> to create a StateT monad, you supply the function (whichever one) with a function that returns m (s, a).  If the monad I'm wrapping is IO, then my function must return IO (s,a)
20:17:42 <sethk> which makes my function in the IO monad
20:18:46 <sethk> I know the docs say it "wraps a monad" but I don't see how that matters.
20:19:11 <sethk> well, actually, it says it "encapsulates" another monad
20:19:15 <Cale> MonadState is a class, and there's an instance for all MonadState monads
20:19:17 <sethk> which I guess is the same thing
20:19:29 <Cale> (sorry, that's a tautology)
20:19:34 <sethk> Cale, :)
20:19:42 <sethk> Cale, you see what I'm saying?
20:19:58 <sethk> Cale, if the only way to have a StateT monad is with an IO function ...
20:20:03 <Cale> Monad m => MonadState s (StateT s m)
20:20:08 <sethk> Cale, assuming what I want is StateT * IO *
20:20:21 <sethk> Cale, that doesn't tell me anything
20:20:48 <Cale> If m is a Monad, then StateT s m is a MonadState with state type s.
20:20:50 <MenTaLguY> you can lift IO functions into the combined state/IO monad and use them there
20:21:11 <sethk> MenTaLguY, Yes, if there were a way to get into the combined monad in the first place, then I could
20:21:27 <sethk> MenTaLguY, but how?  What function do I call?
20:21:36 <sethk> MenTaLguY, what syntax do I write?  What do I _do_
20:21:36 <Cale> If you want to give a *really* generic type to your function then you can't use IO
20:21:49 <sethk> Cale, right
20:21:50 <Cale> but you can still give a less generic one even if you done
20:21:54 <Cale> don't*
20:21:56 <sethk> ok, maybe that's a better way to say it
20:22:04 <MenTaLguY> what do you mean by "get into", I guess?
20:22:29 <sethk> MenTaLguY, type something such that the compiler will consider me to be in the semantic environment of the StateT monad
20:22:47 <sethk> MenTaLguY, I can easily get into the State monad
20:23:02 <sethk> Cale, are you saying then that IO is special?
20:23:20 <sethk> Cale, because it is inescapable in one direction?
20:23:22 <Cale> Well, something can't be of type forall s,m,a. MonadState s m => StateT s m a if it uses IO
20:23:29 <Cale> because IO isn't mentioned there
20:23:37 <Cale> and yeah, IO is one-way
20:23:46 <sethk> Cale, yes, indeed, but I can instantiate a monad of type StateT * IO *
20:23:57 <sethk> Cale, I think that's the crux of it, then
20:24:16 <sethk> Cale, except, doesn't that apply to _any_ concrete realization of the StateT monad?
20:24:18 <Cale> You can get a computation of type  forall s,a. StateT s IO a
20:24:22 <Cale> yeah
20:24:29 <sethk> Cale, right, I've done that
20:24:45 <Cale> but if you need IO, you won't get forall s,m,a. StateT s m a
20:25:00 <Cale> but anything of that type could be combined with the pieces that do use IO
20:25:07 <sethk> Cale, right.  but I'm trying to state what the implications of that type
20:25:19 <sethk> Cale, right, I have been coding those all night.  :)
20:26:02 <sethk> and in an environment where I can use liftIO, the monad type is _not_ StateT * IO *
20:26:22 <Cale> um, that allows for liftIO
20:27:49 <Cale> @type (liftIO :: IO a -> StateT s IO a)
20:27:55 <lambdabot> bzzt
20:28:11 <Cale> @type (Control.Monad.Trans.liftIO :: IO a -> Control.Monad.State.StateT s IO a)
20:28:13 <lambdabot> forall a s. IO a -> Control.Monad.State.StateT s IO a
20:28:24 <sethk> Cale, that's going in the reverse direction
20:28:31 <Cale> ah, okay
20:28:34 <Cale> yeah
20:28:41 <sethk> hence my one way question
20:28:45 <Cale> you can't go the other way without running the state computation
20:29:15 <sethk> by running the state computation, are you talking about runState? or runStateT?
20:29:42 <Cale> runStateT, evalStateT, etc.
20:30:15 <Cale> @type Control.Monad.State.evalStateT :: Control.Monad.State.StateT s IO a -> s -> IO a
20:30:16 <lambdabot> Control.Monad.State.StateT s IO a -> s -> IO a :: forall s a.
20:30:16 <lambdabot> Control.Monad.State.StateT s IO a -> s -> IO a
20:30:17 <sethk> Cale, but, the argument to runStateT, etc, is:   s -> m (a, s)
20:30:33 <sethk> Cale, so if the argument is s -> m(a, s), and m is IO, then the function is in the IO monad
20:30:34 <Cale> right, you have to have an initial state around
20:30:55 <sethk> Cale, the point is I can't, e.g., use the get and put methods
20:31:20 <sethk> Cale, again I mean I can't _if_ the type is StateT * IO *
20:31:23 <Cale> well, inside a value of type StateT s IO a, you can. But not inside an IO a
20:32:06 <sethk> Cale, what I'm saying is that there _is_ no way in
20:32:14 <sethk> were there a way in, I could
20:32:19 <Cale> er, hmm...
20:32:29 <Cale> I'm not sure how it is that you're thinking about this :)
20:33:05 <sethk> I'm thinking as follows.  To get a StateT monad, I have to use either runStateT or the StateT
20:33:09 <sethk> those are the only ways.
20:33:19 <sethk> both of those require a function that returns m(s, a)
20:33:35 <sethk> if m is IO, then the function (that is the argument to runStateT) is in the IO monad
20:33:46 <Cale> runStateT doesn't build a StateT, it unbuilds it
20:33:51 <sethk> and that's the only function I can invoke from runStateT
20:33:56 <sethk> Cale, no, it does both.
20:33:59 <sethk> look at the signature
20:34:16 <Cale> @type Control.Monad.State.runStateT
20:34:18 <sethk> sorry, not runStateT
20:34:18 <lambdabot> forall s a (m :: * -> *).
20:34:18 <lambdabot> Control.Monad.State.StateT s m a -> s -> m (a, s)
20:34:20 <sethk> you are correct
20:34:24 <sethk> I meant StateT
20:34:33 <sethk> I still get turned around about the constructor vs. the dummy
20:34:39 <sethk> @type StateT
20:34:41 <lambdabot> bzzt
20:34:41 <Cale> You normally don't use the StateT constructor directly though
20:35:03 <Cale> you use get, put, return and >>=, or the do notation
20:35:09 <sethk> I see no other way to create a value of type   StateT * IO *
20:35:19 <sethk> Cale, I know what the docs say.
20:35:25 <Cale> @type return 5 :: StateT a IO Integer
20:35:26 <lambdabot> bzzt
20:35:29 <sethk> and, if I were in a StateT monad I can do that.  I have done that
20:35:34 <Cale> @type return 5 :: Control.Monad.State.StateT a IO Integer
20:35:36 <lambdabot> Control.Monad.State.StateT a IO Integer :: forall a. Control.Monad.
20:35:36 <lambdabot> State.StateT a IO Integer
20:35:47 <sethk> ok, there's your monad.  Now what?
20:35:58 <Cale> well, that one is definitely boring :)
20:36:00 <sethk> the only thing you can do is use one of the functions such as runStateT
20:36:05 <Cale> here's a more interesting one
20:36:10 <sethk> withStateT,  _something_StateT
20:36:18 <Cale> yes
20:36:33 <Cale> you need to runStateT to actually do something useful
20:36:42 <Cale> but you probably only need one of these
20:37:05 <Cale> (or very few of them in your whole program)
20:37:06 <sethk> I know that, what I'm saying is that I can do something useful, but I cannot be in the StateT monads computational environment
20:37:31 <sethk> the fact that runStateT lets me do something useful doesn't imply that runStateT lets me do _anything_ useful
20:37:31 <Cale> I don't know exactly what you mean by that :)
20:37:40 <Cale> oh, sure
20:37:42 <Cale> heh
20:38:06 <sethk> whereas I don't have these restrictions with, say, List
20:38:15 <MenTaLguY> List isn't a monad transformer
20:38:19 <sethk> because list is bidirectional.
20:38:22 <sethk> MenTaLguY, yes, I know
20:38:35 <MenTaLguY> State is also bidirectional, in that sense
20:38:57 <sethk> perhaps I mixed up the sense I was trying to talk about.  :)
20:39:04 <sethk> but what's wrong with my logic here?
20:39:18 <sethk> Is is true, is it not, that a function that returns IO foo is in the IO monad.
20:39:40 <Cale> Some people would say that
20:39:49 <sethk> Cale, I just did.  :)  Is it wrong?
20:40:07 <Cale> I'd only say that a value of type IO a for some type a is in the IO monad
20:40:24 <Cale> so that function just returns something in the IO monad
20:40:32 <sethk> yes, ok, that's true
20:40:55 <sethk> so my argument applies strictly to StateT, and perhaps to other state transformers
20:41:13 <Cale> I'm not completely sure what it is that you're arguing :)
20:41:33 <sethk> not arguing per se, trying to check my logic which probably has a flaw, but I can't find the flaw
20:41:50 <sethk> if my premise is wrong, then my conclusion is wrong
20:41:57 <sethk> at least potentially wrong
20:42:03 <sethk> and definitely probably wrong  :)
20:42:38 <sethk> ok, here is another way to put it.
20:42:46 <Cale> The gist of the situation is that, often, and in particular with IO, you eventually have to use runStateT (or one of its bretheren) in order to flatten a (StateT s IO a) into an (IO a) in order to make it useful.
20:42:58 <sethk> If you create a persistent value of a StateT monad, you cannot execute that monad in the StateT environment
20:43:16 <sethk> Cale, yes, I know.  That's all working
20:43:28 <Cale> what do you mean by persistent?
20:43:31 <sethk> I think what I was saying is much too broad
20:43:45 <sethk> Cale, I'm in main, and I call a function that returns a StateT
20:44:00 <Cale> oh, you have to wrap that in a runStateT
20:44:04 <sethk> Cale, then, somewhere further down in the do, I call runStateT with that monad as a argument
20:44:14 <sethk> Cale, but the state is lost at that point
20:44:33 <MenTaLguY> yes, but presumably you've built an IO computation at that point which can use the state
20:44:42 <sethk> MenTaLguY, yes, indeed.
20:44:42 <MenTaLguY> the state isn't lost, so much as hidden within the IO computation you've constructed
20:44:45 <Cale> well, you get the state back
20:45:07 <sethk> with?
20:45:20 <MenTaLguY> it's sort of like when people want to mingle IO with their computations for progress reports
20:45:22 <sethk> if I invoke runStateT, the state is changed to the second argument of the call
20:45:31 <Cale> (x,s) <- runStateT myStateTThingy myInitialState
20:45:37 <MenTaLguY> when you can simply build a lazy data structure and iterate through it in the IO monad instead
20:45:43 <sethk> MenTaLguY, right
20:45:56 <sethk> MenTaLguY, I think that's what I mean, I can't reverse those roles
20:46:07 <Cale> sethk: I think you might be thinking of StateT computations somewhat like static C functions, which they're not.
20:46:26 <Cale> The state is a parameter to the whole execution
20:46:34 <sethk> Cale, No.  I may not understand them, but I don't think they are like static c functions.
20:46:41 <sethk> Cale, yes, I understand that
20:46:48 <Cale> and every time you call runStateT you pass in something new
20:46:56 <sethk> Cale, right.
20:46:59 <Cale> and it's not "remembered" by the StateT thing at all
20:47:03 <sethk> right
20:47:31 <MenTaLguY> there's nothing to say that you can't return the old state as part of your IO value
20:47:38 <sethk> MenTaLguY, in fact, I _must_
20:47:39 <MenTaLguY> and use that as your initial state for the next runStateT
20:47:43 <sethk> MenTaLguY, yes
20:47:59 <MenTaLguY> well, as far as that is concerned, that's how functional programming goes
20:48:04 <sethk> MenTaLguY, what I'm trying to clarify is what persists (the answer appears to be nothing)
20:48:14 <MenTaLguY> all this Monad business is just a way to (sometimes) pretend that we're not
20:48:21 <sethk> MenTaLguY, I know.  I'm not trying to be argumentative.  I'm trying to understand.
20:48:27 <MenTaLguY> correct, anyway
20:48:47 <sethk> MenTaLguY, yes, I do understand that.
20:48:47 <MenTaLguY> nothing gets in except via parameters/bound variables, nothing gets out except via the result
20:48:55 <sethk> MenTaLguY, you mean for IO
20:49:05 <Cale> for state monads
20:49:18 <sethk> Cale, oh, right
20:49:28 <sethk> because none of the StateT methods return a StateT
20:49:38 <sethk> except ... runStateT does
20:49:44 <Cale> no
20:49:47 <Cale> it doesn't :)
20:49:55 <Cale> StateT does
20:49:56 <Cale> >>= does
20:49:59 <Cale> return does
20:50:01 <Cale> get and put
20:50:13 <sethk> Cale, ok.
20:50:16 <Cale> all the general monad operations
20:50:16 <sethk> Cale, return then
20:50:28 <Cale> join, liftM, etc.
20:50:38 <sethk> Cale, I can call return and make a monad, and the compiler doesn't say a word
20:50:39 <sethk> :)
20:51:29 <sethk> Cale, I can, on the other hand, associate a computation with the StateT monad, return the monad, and execute that computation
20:52:03 <sethk> Cale, so I think I'm confused because the association with the computation persists, but the state does not
20:53:29 <Cale> Think of a (StateT s m a) as a block of code which can: modify the state of type s, do anything which something of type m can do, and returns a value of type a.
20:53:33 <sethk> ah, I see it.  What I just said is correct.  According to my test program.
20:53:34 <Cale> er
20:53:38 <Cale> something of type m a
20:53:50 <sethk> right, e.g., IO a
20:53:51 <Cale> import Control.Monad.State
20:53:51 <Cale> inc :: (Num s, MonadState s m) => m ()
20:53:51 <Cale> inc = do x <- get
20:53:51 <Cale>          put (x + 1)
20:54:02 <Cale> runStateT inc 5 >>= print
20:54:09 <Cale> (last line in ghci)
20:54:19 <sethk> Cale, I've seen that example.  I don't see how it's helpful, but I see it.
20:54:27 <sethk> let me show you my example, it is only a few lines
20:54:30 <Cale> okay
20:54:44 <sethk> f1 :: Int -> IO (String, Int)
20:54:44 <sethk> f1 x = do putStrLn "Hello, my name is f1"
20:54:44 <sethk>           putStr "My argument is "
20:54:44 <sethk>           print x
20:54:44 <sethk>           return ("hello", (x + 2))
20:54:56 <sethk> {- forget the trace messages  :)  -}
20:54:59 <sethk> then
20:55:14 <sethk> let m = StateT f1
20:55:22 <Cale> oh
20:55:33 <sethk> Now, I can invoke on that monad, and f1 will be run
20:55:41 <Cale> that's exactly the way in which one is not intended to build StateT computations :)
20:55:53 <sethk> Cale, I know.  I'm trying to understand how it works.
20:55:54 <Cale> (although it's perhaps the most obvious)
20:56:12 <Cale> perhaps I should show another way to write that
20:56:21 <sethk> Cale, so, you see what I mean?  I could create a second monad, say  StateT f2
20:56:29 <sethk> m2 = StateT f2
20:56:44 <sethk> say f2 is like f1 but with a different arithmetic operation, or whatever
20:56:52 <sethk> now, if I do this:   runStateT m1 100
20:56:54 <sethk> f1 runs
20:56:58 <sethk> but if I do this:
20:57:03 <sethk> runStateT m2 100
20:57:07 <sethk> then f2 is run
20:57:28 <sethk> so in let m = StateT f1
20:57:41 <sethk> the associate between m and f1 persists until m goes out of scope
20:57:57 <sethk> association, sorry
20:58:34 <sethk> I know, as you said, that this isn't the way to do things.
20:58:43 <sethk> but you have to admit it is instructional.  :)
20:58:45 <Cale> f2 :: StateT Int IO String
20:58:46 <Cale> f2 = do liftIO $ putStrLn "Hello, my name is f2"
20:58:46 <Cale>         liftIO $ putStrLn "My argument is "
20:58:46 <Cale>         x <- get
20:58:46 <Cale>         liftIO $ print x
20:58:46 <Cale>         put (x+2)
20:58:48 <Cale>         return "hello"
20:58:58 <Cale> there's another way to write f1
20:59:32 <sethk> Cale, yes.  lifting to IO is no problem.  It's lifting from IO that I can't do with StateT
20:59:48 <Cale> um, that is a StateT
20:59:58 <Cale> and it lifts from IO
21:00:11 <sethk> Cale, to f1
21:00:20 <Captain_Fourier> hello
21:00:23 <sethk> well, I guess you can conceive of the direction either way.
21:00:34 <Cale> hello Cap'n
21:00:49 <Captain_Fourier> when i am building ghc is there anyway to do the equivalent of DESTDIR
21:01:00 <Cale> I'm not sure
21:01:23 <sethk> Captain_Fourier, yes
21:01:30 <Cale> just to make sure, you are building it because you either want to hack on it, or a binary is not available for your platform?
21:01:31 <sethk> Captain_Fourier, hold on, I'll get it.
21:02:03 <sethk> Captain_Fourier, --prefix on the ./configure
21:02:14 <sethk> Captain_Fourier, --prefix=
21:02:41 <Captain_Fourier> hmm that doesnt work later
21:02:54 <Captain_Fourier> its the latter Cale
21:02:57 <sethk> Captain_Fourier, worked for me.
21:03:01 <Cale> Captain_Fourier: okay then :)
21:03:13 <sethk> Captain_Fourier, I kept two versions, they both were happy
21:03:26 <Captain_Fourier> i need it to install into a buildroot
21:03:39 <Captain_Fourier> where it will be bundled into an rpm
21:03:59 <Captain_Fourier> but i dont want when i unpackaged it to go to /var/tmp/ghc-root/
21:04:34 <sethk> Captain_Fourier, you can try the destination directory specs at the lower leve
21:04:36 <sethk> level
21:04:52 <sethk> such as --bindir=, --sbindir=, etc.  unless you already tried that too.
21:06:05 <Captain_Fourier> if i set those
21:06:20 <Captain_Fourier> will still think /usr/local is where to loook
21:06:59 <sethk> Captain_Fourier, I'm not sure then what it didn't do that to me.
21:08:32 <sethk> are there execution time paths that might explain his results?
21:08:43 <Captain_Fourier> hm
21:10:00 <sethk> Captain_Fourier, if mine were mixed up, I'd have 6.2 and 6.4 and _nothing_ would work.  :)
21:10:09 <Captain_Fourier> ok
21:11:25 <sethk> Captain_Fourier, sorry I don't have better information.
21:12:23 <sethk> now ... :)
21:12:36 <sethk> what will happen if I put a StateT monad into another StateT monad.
21:12:38 <Captain_Fourier> its ok
21:12:41 <stepcut> I think I am going to try to make a yampa based byte parser, so I can do non-blocking, incremental parsing on streams like network data as it arrives
21:12:46 <Captain_Fourier> ill look at the official spec file
21:12:58 <sethk> stepcut, what's yampa?
21:13:14 <Captain_Fourier> heh they did a hack
21:14:18 <stepcut> sethk: (http://www.haskell.org/yampa/) It is an arrow based library for creating a network that reacts to signals
21:14:39 <stepcut> or, atleast, that is one way to describe it...
21:15:28 <stepcut> I may not actually use yampa itself, but I think arrows and yampa-like ideas are the solution to the problem
21:15:53 <stepcut> the problem being -- how do you parse something like network data in a single threaded program
21:16:36 <sethk> stepcut, thanks, I'll look at it.
21:16:46 <stepcut> you need some way to say 'here is some data I got via IO, parse as much as you can for now, and be able to pick up where you left off when more data comes in'
21:17:27 <stepcut> sethk: http://www.ida.liu.se/~henni/Publications/hw2003.pdf
21:17:55 <stepcut> that is a fun yampa article to read because they talk about implementing space invaders using yampa+opengl
21:18:18 <sethk> stepcut, thanks.  why single threaded?  just out of curiousity
21:19:40 <stepcut> sethk: more challenging :p
21:20:22 <stepcut> actually, I don't remember why anymore :-/
21:20:53 <stepcut> I think it is because the first time I wanted to solve this problem, I didn't have access to threads...
21:34:27 <glguy> who had that unicycle videos website
21:58:57 <stepcut> what a weird collection of things for sale: http://sandiego.backpage.com/buyselltrade/classifieds/ViewAd?oid=oid%3A376619&name=wanted%2Ftrade
21:59:16 <stepcut> oh wait, that's his *want* list
21:59:25 <stepcut> still pretty damn weird
22:07:13 <syntaxfree> @pl f x = 2
22:07:14 <lambdabot> f = const 2
22:07:20 <syntaxfree> @type const
22:07:25 <lambdabot> forall a b. a -> b -> a
22:07:50 <syntaxfree> @eval map (const 2) [1..5]
22:07:53 <lambdabot> [2,2,2,2,2]
