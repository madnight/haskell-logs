00:01:39 * boegel rubs his head
00:01:46 <basti_> :D
00:02:43 <basti_> now to something completely different: how are type derivatives best explained axiomatically?
00:09:42 <glguy> @index diffarray
00:09:43 <lambdabot> bzzt
00:09:46 <glguy> @index diff
00:09:47 <lambdabot> bzzt
00:09:52 <glguy> @index Diff
00:09:53 <lambdabot> bzzt
00:09:55 <basti_> glguy: what are you trying to do?
00:09:55 <glguy> @index DiffArray
00:09:56 <lambdabot> Data.Array.Diff
00:09:57 <glguy> :)
00:10:00 <basti_> ah ^^
00:10:07 <glguy> I need the contructor for diff array
00:10:12 <glguy> the drop in replacement for array
00:11:16 <glguy> how do I do that...
00:11:24 <glguy> I want to compare the performace in my application
00:12:15 <basti_> hmm
00:12:30 <basti_> afaik diff array is just the same as normal array except for the internals?
00:12:34 <glguy> yeah
00:12:37 <glguy> but how do i make one
00:13:12 <basti_> oof.
00:13:17 <basti_> there's some buisiness with a monad
00:13:38 <basti_> do you know about monads?
00:13:54 <glguy> I know about them
00:13:54 <glguy> but
00:14:00 <glguy> how much do I need to know about them
00:14:04 <glguy> I've not mastered them
00:14:18 <basti_> hmm mainly how to use them
00:14:22 <glguy> okay
00:14:24 <basti_> did you use "do" for I/O stuff?
00:14:38 <glguy> yes, but I know how to use bind (>> and >>=) instead
00:14:45 <glguy> is that w hat you mean?
00:14:51 <basti_> yes thats pretty good
00:15:05 <basti_> you can choose whatever notation you want, they're equivalent
00:15:10 <glguy> right
00:15:24 <glguy> but what's this business about diffarrays and needing special Monad usage
00:16:05 <glguy> (I'm already using standard arrays in my "application")
00:16:37 <basti_> "special"? ;)
00:16:43 <basti_> lets have a look
00:17:29 <basti_> its IO in the case of Diff Arrays
00:18:42 <glguy> i can handle that
00:18:48 <glguy> just need to know how to make one
00:19:06 <basti_> newDiffArray <
00:19:06 <basti_> ;=)
00:19:33 <glguy> @index newDiffArray
00:19:33 <lambdabot> Data.Array.Diff
00:19:37 <glguy> alrighty
00:23:44 <glguy> does the diff array only support single dimension arrays?
00:25:33 <dons> @quit moving home
00:25:51 <basti_> glguy: i think you can use tuples as indexes
00:26:34 <dons> @version
00:26:34 <lambdabot> lambdabot 3p108, GHC 6.5.20051020 (Linux i686)
00:26:34 <lambdabot> darcs get pill00:code/lambdabot
00:26:43 <dons> lambdabot now has a *dedicated* machine
00:26:44 <dons> :)
00:26:49 <vegai> yay :)
00:27:00 <vegai> Hmm, I guess that @plugs issue is fixed on ghc-6.5?
00:27:04 <vegai> but not 6.4.1
00:27:08 <dons> some commands are currently borked till their support files get ported
00:27:17 <dons> vegai, yep fixed.
00:27:20 <dons> @eval 1 + 2
00:27:21 <lambdabot> 3
00:27:27 <vegai> I wonder when they will release that
00:27:34 <dons> hopefully lambdabot should be noticeably faster in its new home
00:27:42 <vegai> I fear HEAD code
00:27:50 <dons> now that she doesn't have to compete with 2 nightly builds of ghc running all the time
00:27:50 <glguy> @eval [1..]
00:27:52 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
00:27:52 <lambdabot> 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
00:27:52 <lambdabot> 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
00:27:52 <lambdabot> 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,
00:27:52 <lambdabot> 95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
00:27:54 <lambdabot> 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,
00:27:56 <lambdabot> 130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,
00:27:58 <lambdabot> [24 @more lines]
00:27:58 <glguy> yikes
00:28:00 <vegai> evil :)
00:28:02 <glguy> I didn't think it would actually print all that
00:28:04 <dons> that seemed *very* fast on my end. what about you guys?
00:28:04 <glguy> oh
00:28:04 <glguy> good
00:28:15 <vegai> dons: it was
00:28:23 <dons> cool
00:28:25 <vegai> probably IRC was the bottleneck there
00:28:39 <dons> hopefully
00:28:42 <vegai> you should watch out that it won't get kicked because of flooding :P
00:28:53 <dons> whereas it has been access to ram until now :)
00:28:58 <dons> poor starving lambdabot
00:29:06 <dons> luckily lambdabot has flood protection, vegai
00:29:12 <dons> well, it's supposed to anyway
00:29:19 <eyck> @eval[12..]
00:29:20 <lambdabot> Unknown command, try @listcommands.
00:29:23 <vegai> oh, ok.
00:29:26 <eyck> @eval [12..]
00:29:28 <lambdabot> [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,
00:29:28 <lambdabot> 34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,
00:29:28 <lambdabot> 57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
00:29:28 <lambdabot> 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,
00:29:28 <lambdabot> 102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,
00:29:30 <lambdabot> 119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,
00:29:31 <lambdabot> 136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,
00:29:32 <eyck> interesting..
00:29:34 <lambdabot> [24 @more lines]
00:29:40 <vegai> eyck: how?
00:29:41 <dons> so things that don't work are currently: hoogle, timein, yow (?)
00:29:42 <dons> @yow
00:29:42 <lambdabot> Couldn't find fortune file
00:29:48 <dons> so I'll fix those later today
00:30:16 <eyck> vegai: why only 24 more lines?
00:30:39 <eyck> what would the last one look like?
00:30:40 <dons> we chop off large amounts of output arbitrarily at 2048 bytes :)
00:30:42 <dons> just to be mean
00:30:50 <eyck> that's so mean...
00:31:03 <basti_> one could chop the lines a tad earlier btw.
00:31:11 <basti_> so that they fit in 80 chars
00:31:26 <dons> we used to not do this, but [6123413241 @more lines] is fun, though expensive on ram
00:31:41 <dons> (just working out how many @more lines is bad)
00:32:03 <dons> hmm, good point basti_
00:32:09 <vegai> do people often have 80 chars wide terms?
00:32:18 <dons> i do :)
00:32:22 <basti_> i do too
00:32:33 <vegai> some things wrap rather ugly... like
00:32:35 <vegai> @jargon hacker
00:32:37 <lambdabot> *** "hacker" jargon "Jargon File (4.3.1, 29 Jun 2001)"
00:32:37 <lambdabot> hacker n. [originally, someone who makes furniture with an axe] 1.
00:32:37 <lambdabot> A
00:32:37 <lambdabot>  person who enjoys exploring the details of programmable systems and
00:32:37 <lambdabot> how
00:32:39 <lambdabot>  to stretch their capabilities, as opposed to most users, who prefer
00:32:41 <lambdabot> to
00:32:44 <lambdabot> [53 @more lines]
00:32:46 <vegai> see what I mean?
00:33:06 <dons> vegai, oh you want *longer* lines?
00:33:15 <sheriff> dons: that's not the problem there
00:33:23 <sheriff> dons: The problem is it's not rewrapping the source
00:33:30 <dons> the wrapping sucks, yep
00:33:38 <sheriff> We had a similar issue writing infobot's RSS plugin
00:33:42 <dons> it's on the todo, but no one is employed to do this , so it doesn't get done :/
00:33:43 <glguy> literate haskell?
00:33:51 <sheriff> Is it written in haskell?
00:33:59 <dons> there's actually a whole output filter abstraction in lambdabot, we need to tweak it
00:34:04 <dons> sure
00:34:06 <dons> @version
00:34:06 <lambdabot> lambdabot 3p108, GHC 6.5.20051020 (Linux i686)
00:34:06 <lambdabot> darcs get pill00:code/lambdabot
00:34:15 <dons> hmm. that darcs get is wrong too
00:34:27 <sheriff> What does pill00 correspond to?
00:34:36 <dons> another box I pulled the src from... hang on..
00:34:44 <dons> @quit try again
00:34:47 <C-Keen> re
00:34:52 <dons> @version
00:35:00 <lambdabot> lambdabot 3p108, GHC 6.5.20051020 (Linux i686)
00:35:02 <lambdabot> darcs get pill00:code/lambdabot
00:35:19 <dons> grrr
00:35:57 <dons> @dynamic-reload version
00:35:57 <lambdabot> module reloaded
00:35:59 <dons> @version
00:35:59 <lambdabot> lambdabot 3p108, GHC 6.5.20051020 (Linux i686)
00:35:59 <lambdabot> darcs get pill00:code/lambdabot
00:36:03 <dons> sigh
00:36:36 <dons> @dynamic-reload version
00:36:36 <sheriff> I would be surprised, naively, if that changed without you re-darc-pulling
00:36:36 <lambdabot> module reloaded
00:36:38 <dons> @version
00:36:39 <lambdabot> lambdabot 3p108, GHC 6.5.20051020 (Linux i686)
00:36:39 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
00:36:41 <sheriff> ah
00:36:43 <sheriff> bingo :)
00:36:55 <dons> nah, editing the _darcs/prefs/repos was what is required
00:37:28 <dons> also, you'll notice she's moved from OpenBSD to Linux :/ oh well
00:38:47 * dons `throwTo` home
00:40:49 <sheriff> gah, I wish darcs would stop segfaulting on my openbsd box :(
00:41:19 * sheriff tries upgrading
00:42:38 <dons> sheriff, ah! what version?
00:42:41 <dons> I have a patch
00:43:25 <musasabi> Is there a way to avoid wrapping killThread in forkIO in presence of safe C calls?
00:44:06 <JohnMeacham>  yay. some real performance benefits in jhc. some tests are more than twice as fast since I started specializing updates and made a better memory manager.
00:44:14 <musasabi> http://youzen.b2.fi/~musasabi/kill.hs demonstrates the problem - killThread does not return until the sleep is done.
00:44:53 <dons> sheriff, basically since the recent malloc and mmap changes on openbsd, possibly the use-after-free issue, darcs started segfaulting in the packed string code. You can fix it with a patch I have that prevents the munmap.
00:45:02 <JohnMeacham> I was getting disheartened, a lot of my recent optimizations were only giving a few percent improvements, but this lets me know there are some dramatic steps that can still be made.
00:45:05 <dons> I'd forgotten about the patch, but it should get pushed back into darcs I think
00:45:18 <dons> sheriff, so which openbsd version and which darcs version/
00:46:48 <sheriff> dons: 3.6/6.2.1
00:46:59 <sheriff> oh wait
00:47:00 <dons> ah, ok. there's many many other issues then :)
00:47:01 <sheriff> that's wrong
00:47:12 <sheriff> 0.9.23
00:47:22 <C-Keen> sheriff: you should upgrade that openbsd box if you can
00:47:28 <sheriff> C-Keen: Why?
00:47:29 <dons> update to 3.8 and ghc 6.2.2 and darcs 1.0.3
00:47:33 <dons> it's way way more stable
00:47:41 <dons> in fact, it just works
00:47:55 * sheriff looks at the upgrade instruction from 3.6->3.7->2.8
00:47:56 <dons> you can get both ghc-6.2.2 and darcs 1.0.3 from the ports tree
00:48:00 <C-Keen> sheriff: lots of improvements on application and system level
00:48:05 <dons> it's easier to dump your
00:48:15 <dons> home dir somewhere, and do a snapshot install
00:48:23 <C-Keen> sheriff: don't upgrade, install the latest stable or a snapshot will save you pain
00:48:26 <dons> you could be back up and running 3.8 in 15 minutes or so
00:48:46 <C-Keen> dons: using openbsd as well :)
00:48:58 <dons> had any troubles with ghc or darcs?
00:48:58 <sheriff> Is it feasible to do that if the machine is remote?
00:49:11 <dons> nope
00:49:26 <C-Keen> sheriff: if you have access to a serial line during boot maybe. You can also have a look at wbx remote install script
00:49:33 <dons> scary
00:49:48 <sheriff> I've upgraded by hand before...
00:49:52 <C-Keen> sheriff: but this might not work and you could end up with a non responding machine
00:49:57 * sheriff looks at the instructions to determine difficulty factor
00:50:07 <C-Keen> sheriff: upgrading by hand is not really an option
00:50:09 <dons> upgrading by hand is far more error prone
00:50:16 <C-Keen> too many things have been changed
00:50:20 <dons> esp. over 2 versions
00:50:33 <C-Keen> if you get stuck you won't get any help
00:50:54 <C-Keen> compiler has been changed as well
00:51:23 <sheriff> hrm
00:51:27 <dons> C-Keen, sheriff, btw, I maintain the Haskell ports on OpenBSD, so you should complain/ask me if you have any issues with them
00:51:43 <C-Keen> dons: will sure do :)
00:51:45 <dons> and we have a nice page for this:
00:51:48 <sheriff> I think this is a battle to fight another day
00:51:56 <dons> http://www.cse.unsw.edu.au/~dons/haskell_openbsd.html
00:52:12 <sheriff> am I likely to get any improvement simply upgrading darcs?
00:52:25 <dons> hmm, no I don't think so, there was an FFI bug in ghc
00:52:32 <dons> so maybe updating ghc and darcs would do the trick
00:52:40 <glguy> @index liftIO
00:52:41 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
00:52:41 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont,
00:52:41 <lambdabot> Control.Monad.Error, Control.Monad.List
00:52:46 <dons> ghc is buildable from src on openbsd quite easily, as is darcs
00:53:16 <C-Keen> using the packages will not work
00:53:17 <sheriff> hrm
00:53:25 <glguy> @type liftIO
00:53:26 <lambdabot> bzzt
00:53:28 <C-Keen> nor a newer ports tree
00:53:28 <dons> right. the packages expect 3.8
00:53:37 <glguy> @type Control.Monad.List.liftIO
00:53:38 <lambdabot> bzzt
00:53:45 <dons> but if you need darcs, then building ghc and darcs is very feasible
00:53:57 <glguy> @type Control.Monad.Trans.liftIO
00:53:58 <lambdabot> bzzt
00:54:00 * C-Keen likes darcs
00:54:03 <glguy> :-/
00:54:08 <dons> @type map
00:54:08 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
00:54:14 <dons> ok, so @type isn't broken
00:54:31 <dons> @type List.sort
00:54:31 <lambdabot> bzzt
00:54:35 <dons> @type Data.List.sort
00:54:36 <lambdabot> forall a. (Ord a) => [a] -> [a]
00:54:45 <dons> @type Control.Monad.Trans.lift
00:54:45 <lambdabot> bzzt
00:54:53 <glguy> @type Control.Monad.Trans.liftM
00:54:54 <lambdabot> bzzt
00:55:58 <dons> hmm :/ weird
00:57:05 <dons> @type Control.Monad.Trans.lift
00:57:05 <lambdabot> bzzt
00:57:30 <C-Keen> maybe longer functions with 4 dots won't get typed?
00:57:42 <C-Keen> @type function.that.doesnot.exist
00:57:42 <lambdabot> bzzt
00:57:47 <C-Keen> @type function.that.doesnot
00:57:48 <lambdabot> bzzt
00:57:57 <dons> hmm, it's working for me in a privmsg channel though :/
00:58:00 <dons> @type Control.Monad.Trans.lift
00:58:00 <lambdabot> forall (t :: (* -> *) -> * -> *)
00:58:00 <lambdabot>             a
00:58:00 <lambdabot>             (m :: * -> *).
00:58:00 <lambdabot>           (Control.Monad.Trans.MonadTrans t, Monad m) =>
00:58:00 <lambdabot>           m a -> t m a
00:58:03 <dons> ah ha!
00:58:14 <C-Keen> what is it?
00:58:15 <dons> look at that lovely kind
00:58:37 <dons> monad transfomer
00:58:39 <dons> former
00:58:52 <C-Keen> I mean why does it work now?
00:59:25 <dons> reloaded the module to use a different version
00:59:34 <dons> not sure why it was working in the privmsg though, oh well
01:00:10 <dons> @localtime dons
01:00:13 <lambdabot> Local time for dons is Tue Oct 25 17:54:03 2005
01:00:23 <dons> hometime! ciao!
01:19:31 <metaperl> would someone mind telling me what MD5 is useful for? someone said there is a way to make an MD5 signature of a directory tree and only rescan it when the signature changes... but how would that tell me what files changed?
01:21:08 <Cale> metaperl: it's a hash function
01:21:26 <musasabi> metaperl: you would create a file with the md5 of each file in the subdirectories and then use that.
01:22:27 <Cale> cat * | md5sum -
01:22:38 <JohnMeacham> You know why I can't wait for fptools to be in darcs? the ability to delete directories. there are like 5 stub directories all named run-time or rts or common-rts and I can never remember which one the rts actually is in :). okay. not the most important reason, but it will be nice.
01:23:16 <Cale> I can't believe that CVS can't do that
01:24:38 <integral> it's because CVS doesn't version the directory structure, it just versions the individual files.  each file is essentially it's own wee RCS repository
01:33:09 <Cale> http://en.wikipedia.org/wiki/The_quick_brown_fox_jumps_over_the_lazy_dog -- "The phrase "The quick brown fox jumps over the lazy dog" can be generated in the English Microsoft Word by typing =rand() and pressing the ENTER key."
01:33:17 <Cale> what?
01:33:20 <Cale> heh
01:41:57 <bortzmeyer> JohnMeacham: you can delete directories in CVS with -P
01:42:09 <bortzmeyer> Prune empty directories.  See see node `Moving  directories'  in  the
01:42:09 <bortzmeyer>          CVS manual.
01:42:59 <JohnMeacham> bortzmeyer: but that doesn't actually version control the changes. it just deletes anything that happens to be empty.
01:44:03 <bortzmeyer> JohnMeacham: sure. darcs still rules :-)
01:44:11 <bortzmeyer> but CVS is not so bad
01:44:47 * ValarQ prefers svn over cvs
01:45:11 <ValarQ> still doesn't beat darcs thought :)
01:45:16 * dcoutts prefers darcs over cvs
01:46:14 <bortzmeyer> Creating a record from a text file: I have a text file with "attribute :value" pairs. I want to create a record from it.
01:46:34 <bortzmeyer> With an iperative language like Perl or Python, I just loop. I'm looking for an Haskell way.
01:47:07 <bortzmeyer> And, yes, I've read http://haskell.org/hawiki/UpdateInPlace which only solve part of the problem
01:47:33 <vegai> would building a Parser be an overkill?
01:47:47 <bortzmeyer> vegai: yes, I think so
01:47:58 * eyck prefers svk over anything else
01:48:26 <eyck> hmm, actually, with svk you can prefer it, and not need to force it down everyone else throats
01:48:29 <bortzmeyer> eyck: svk is not in Haskell :-)
01:50:44 <sheriff> I need to find a client I can write Haskell for
01:50:45 <dcoutts> dons, that problem was indeed the bsd sed problem I was talking about. darcs pull and try again.
01:50:55 <sheriff> Or who doesn't mind if I deliver the project in Haskell
01:50:56 <eyck> bortzmeyer: but it makes using haskkell so much easier..
01:51:15 <eyck> bortzmeyer: anyhoo, I would be very happy if you rewrote svk in haskell, that would be very cool
01:51:58 <dcoutts> dons, the fix went into cvs last night but the darcs mirror only updates once a day. (it's there now though)
01:52:28 <vegai> svk?
01:52:33 <vegai> @google svk
01:52:34 <lambdabot> http://svk.elixus.org/
01:52:58 <vegai> oh, right
01:55:01 <eyck> @google svn
01:55:02 <lambdabot> http://subversion.tigris.org/
01:55:15 <eyck> @google shilsed
01:55:17 <lambdabot> No result found.
01:55:18 <eyck> ha!
01:56:07 <eyck> lambdabot is broken, @google eyck doesn't work properly.
01:56:44 <vegai> how's it supposed to work?
02:03:54 <eyck> properly, of course.
02:04:49 <Lemmih> It works just like google.com for me.
02:07:10 <Cale> @google eyck
02:07:10 <lambdabot> http://www.ibiblio.org/wm/paint/auth/eyck/
02:07:25 <Cale> um, yeah, that's the top result here
02:16:44 <eyck> yeah, but that is obviously wrong.
02:16:52 <eyck> from my point of view anyway
02:18:17 <Cale> well, that's what @where is for
02:22:29 <eyck> @where @where
02:22:30 <lambdabot> I know nothing about @where.
02:31:16 * boegel boings
02:40:10 <vegai> has shapr assimilated boegel?
02:56:06 * boegel beeps
03:06:37 <earthy> enum Bool
03:06:37 <earthy> {
03:06:37 <earthy>     True,
03:06:37 <earthy>     False,
03:06:37 <earthy>     FileNotFound
03:06:39 <earthy> };
03:06:44 * earthy sniggers
03:07:46 <sylvan> hmm... What am I missing here: arr :: DiffArray Char Int
03:07:46 <sylvan> arr = listArray (0,255) (repeat 0)
03:08:04 <sylvan> this gives me "No instance Num Char"
03:08:23 <sylvan> but why would Char need to be an instance of Num? I only need Ix (of which Char IS an instance)
03:11:17 <earthy> ummm
03:11:34 <sheriff> Is there a decent Ruby-on-Rails equivalent for Haskell?
03:11:39 <earthy> you are using integer literals for the chars
03:11:51 <vegai> 0 is a Char? I was about to ask
03:11:58 <sylvan> earthy, but I have explicitly typed them to be chars?
03:12:00 <vegai> sheriff: happs.org is the closest, I guess, but not very ready
03:12:05 <sylvan> ah so 0 can't be interpreted as a char?
03:12:10 <sylvan> check, I'll use chr
03:12:25 <earthy> sylvan: true enough, but fromInteger is only defined for Num
03:12:35 <earthy> An integer literal represents the application of the function fromInteger to the appropriate value of type Integer, so such literals have type (Num a) => a.
03:13:26 <sylvan> yeah, too much C lately =)
03:13:28 <earthy> there is a Num instance for CChar though. :)
03:13:39 <sheriff> vegai: thanks
03:14:30 <sheriff> ah well, I'll use this as an excuse to improve my Catalyst rather than my Haskell I think :)
03:15:55 <vegai> sheriff: I might be mistaking the lack of documentation and examples in HappS as a sign of non-readiness
03:18:26 <sheriff> vegai: It doesn't look to have the feature set of the other mvcs, from a cursory glance
03:18:42 <sheriff> And I'm sure I'll find another place for Haskell soon
03:28:17 <reddi> hi, i am new here! is there a way to find out, if the numbers in a list have all the same value?
03:30:17 <JaffaCake> GHC hacking guide: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/ghc/HACKING?content-type=text%2Fplain
03:30:19 <psi_> all (== head list) list
03:30:33 <musasabi> reddi: case list of [] -> True; (x:xs) -> all (== x) xs
03:30:39 <aleator> (1==).length.nub?
03:31:41 <reddi> how do i find out all possible list operators? is there a tutorial to find in the net?
03:31:54 <reddi> thx: musasabi
03:32:26 <musasabi> reddi: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
03:33:00 <reddi> musasabi: that is what i have looked for, thx
03:44:37 <dcoutts> JaffaCake, nice
03:44:59 <JaffaCake> thanks - let me know if you think I should add anything else
03:46:54 <reddi> why is there a "missing binding for variable "istQuerSchnapps" in type signature" in http://pastebin.com/405085
03:47:01 <sheriff> dcoutts: What do you do in Oxford?
03:47:27 <dcoutts> sheriff, I'm the comlab's teaching assistant.
03:47:35 <int-e> reddi: istQuerSchnapps != istQuerschnapps
03:47:42 <sheriff> Is that part of OUCS?
03:47:54 <dcoutts> sheriff, no it's the CS department
03:48:13 <sheriff> ah, ok
03:48:14 * sheriff is also in Oxford
03:48:16 <reddi> int-e: why?
03:48:45 <dcoutts> sheriff, but you're not on the Oxford CS degree?
03:49:01 <sheriff> No. In, not at, despite having a St Hilda's NUS card ;-)
03:49:07 <int-e> reddi: capitalisation matters. one has an upper case 'S', the other a lower case one.
03:49:25 <dcoutts> sheriff, in that case I don't teach you :-)
03:49:43 * dcoutts finds it a bit odd bumping into his students on #haskell
03:49:44 <reddi> int-e: thx, i was blind ;-)
03:50:28 <sheriff> I'm vaguely considering applying to do an undergrad course if I can keep up very high marks on my Open Uni course
03:53:46 <dcoutts> sheriff, or if you've done an undergrad course before then the comlab does a good 1 year MSc conversion course.
03:54:50 <dcoutts> the people on the MSc course usually have some background in science or mathematics. They often don't have much programming experience.
03:55:20 <sheriff> I've not. I started work straight out of school having managed to underscore on my predictions by a fairly impressive 30 UCAS points. I'm now running a little contracting course, and picking away at a Maths degree in my free time
03:55:38 <sheriff> s/course/company/
03:56:05 <dcoutts> sheriff, well if you finnish the math degree then the MSc course would be appropriate rather than the undergrad CS course
03:56:17 <dcoutts> and it'd save you 2 years :-)
03:56:30 <datenmaulwurf> hi
03:57:12 <datenmaulwurf> I have to write a little-heskell-programm, but I have a few problems/questions
03:57:19 <dcoutts> just ask
03:57:36 <ibid> dcoutts: wish me luck (first lecture in 20 mins) ;)
03:57:42 <sheriff> dcoutts: I'm not very far into it. I think I'll keep at it for two years, and keep saving up from my little company, and then apply
03:57:55 <dcoutts> ibid, good luck!
03:58:02 <ibid> :)
03:58:16 <sheriff> I'd like to go into a compsci course knowing the syllabus pretty thoroughly through exposure to it
03:58:17 <kolmodin> ibid: go and get them! :)
03:58:25 <dcoutts> ibid, lets hope your students don't find too many bugs in our software :-)
04:01:04 <dons> @quit restore missing state
04:01:33 <dons> @quit try again
04:13:40 <reddi> is there a function for comparing 2 lists or do i have to implement this by myself?
04:14:07 <Lemmih> @eval [1..10] == [10,9..1]
04:14:08 <lambdabot> False
04:14:18 <Lemmih> @eval [1..10] == [1..10]
04:14:19 <lambdabot> Terminated
04:14:24 <basti_> "terminated??
04:14:27 <eyck> what?
04:14:28 <Lemmih> Terminated?
04:14:29 <Lemmih> @eval [1..10] == [1..10]
04:14:31 <lambdabot> True
04:14:45 <Lemmih> You're a bit weird, lambdabot.
04:14:46 <dcoutts> lambdabot, you scared us!
04:14:50 <dons> hehe
04:15:18 * dcoutts suspects dons has implemented a "random reply" lambdabot module :-)
04:15:31 <reddi> o, thx, that easy ;-)
04:16:04 <dons> that was a bit odd, but lambdabot has just moved to a new home (a dedicated box!) that should hopefully mean she doesn't have to compete for resources anymore
04:16:46 <JKnecht> why 'she'?
04:16:57 <dons> @where lambdabot
04:16:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:17:00 <dons> :)
04:17:21 <dons> also:
04:17:26 <dons> @vixen what do you tthink of haskell programmers?
04:17:26 <lambdabot> church is my favourite computer scientist.
04:17:42 <dons> @vixen ok, but what about haskell hackers?
04:17:42 <lambdabot> church is my favourite computer scientist.
04:17:54 <dons> @vixen sometimes you're repetitive!
04:17:54 <lambdabot> why not always?
04:18:10 <dons> @vixen ok, *always* repetitiive, if you like it that way
04:18:11 <lambdabot> i'd say i like
04:18:29 <dons> @vixen which way do you like it?
04:18:30 <lambdabot> yah, i like
04:19:08 <dons> @vixen where are you from?
04:19:09 <lambdabot> Huntington Beach California
04:19:15 <JKnecht> @vixen you're not a very good Eliza.
04:19:16 <lambdabot> thanks, i do my best to be good
04:19:28 <dons> @vixen a s?
04:19:28 <lambdabot> 19/f
04:19:33 <basti_> ^^
04:19:56 <dons> @vixen what do you think of visual basic?
04:19:56 <lambdabot> Can you really catch syphilis from Visual Basic?
04:20:02 <basti_> lol
04:20:08 <JKnecht> rofl
04:20:14 <dons> @vixen what is your name?
04:20:14 <lambdabot> My name is Emily
04:20:18 <dons> ah!
04:20:39 <dons> @vixen aslp ?
04:20:40 <lambdabot> 19/f/California/No pics
04:21:13 <dons> @vixen what's 1 + 2 ?
04:21:14 <lambdabot> why are you giving me a math test?
04:21:20 <JKnecht> I firmly resolve any (further) bots I do will be gender-free.
04:24:25 <JKnecht> @seen Cale
04:24:26 <lambdabot> Cale is in #haskell-overflow and #haskell. I don't know when
04:24:26 <lambdabot> Cale last spoke.
04:24:35 * SamB wishes C compilers could do that "compilation IS NOT required" trick
04:24:41 <Cale> hello
04:24:57 <SamB> @seen Cale
04:24:57 <lambdabot> Cale is in #haskell-overflow and #haskell. Last spoke 15
04:24:57 <lambdabot> seconds ago.
04:24:57 <Cale> why does lambdabot not know when I last spoke?
04:25:13 <datenmaulwurf> Hi again
04:25:15 <SamB> Cale: it because it has a gap in its logs?
04:25:21 <Cale> ah
04:25:30 <SamB> thats just a guess
04:25:39 <JKnecht> shouldn't it have taken last time it had?
04:25:40 <Cale> also, I thought it might have been logged into -overflow, which it isn't.
04:25:47 <datenmaulwurf> I have to create the caesar-chiffrier-algorythmus in haskell
04:25:58 <datenmaulwurf> can anyone help me?
04:26:06 <dons> no no, I took advantage of the move from manzano to alonoz to reset the @seen state, which had some corrupted elements floating around in it.
04:26:09 <SamB> JKnecht: probably ought to have, and stated that it believed there was a gap in its logs...
04:26:23 <basti_> datenmaulwurf: let me guess: this is your first semester doing haskell? ^^
04:26:24 <SamB> oh, I see
04:26:54 <datenmaulwurf> basti_, you're right ;)
04:26:57 <SamB> caesar-chiffrier-algorythmus?
04:27:07 <SamB> algorythmus?
04:27:08 <basti_> datenmaulwurf: we'll help you, but we won't tell you everything, ok? ^^
04:27:13 <JKnecht> sounds like borborygmus.
04:27:15 <datenmaulwurf> i know
04:27:15 <basti_> SamB: cesar chiffre algorithm
04:27:22 <datenmaulwurf> i want to LEARN it
04:27:23 <basti_> first you'll need ord and char
04:27:25 <basti_> @type ord
04:27:26 <lambdabot> bzzt
04:27:30 <basti_> @type Data.Char.ord
04:27:32 <lambdabot> bzzt
04:27:34 <basti_> @index ord
04:27:36 <lambdabot> Data.Char
04:27:39 <datenmaulwurf> i think i need to subfunctions
04:27:39 <basti_> huh?
04:27:45 <datenmaulwurf> char -> int
04:27:45 <SamB> huh indeed
04:27:48 <datenmaulwurf> and int -> char
04:27:49 <datenmaulwurf> right?
04:27:56 <basti_> yes right
04:27:58 <datenmaulwurf> ok
04:27:59 <basti_> these are given
04:28:03 <datenmaulwurf> and there's the problem
04:28:06 <SamB> @eval Data.Char.ord 'a'
04:28:07 <dons> @type Char.ord
04:28:07 <lambdabot> Terminated
04:28:07 <lambdabot> bzzt
04:28:08 <datenmaulwurf> i can't tell them
04:28:16 <basti_> Char->Int is ord, chr is Int->Char
04:28:21 <Lemmih> dons: What's up with lambdabot?
04:28:23 <SamB> @plugs Data.Char.ord 'a'
04:28:24 <lambdabot> 97
04:28:25 <dons> hmm... maybe ghc 6.5.xxyy isn't so friednly :/
04:28:41 <SamB> dons: do you have that module loaded?
04:28:54 <dons> @type map
04:28:54 <lambdabot> bzzt
04:28:57 <JKnecht> what's the diff between 'bzzt' and 'Terminated'?
04:28:58 <dons> hmm :/
04:28:59 <SamB> oh, wait, would give different error if not
04:29:00 <datenmaulwurf> basti_, i've to go now
04:29:06 <basti_> cu datenmaulwurf
04:29:12 <datenmaulwurf> are you here later?
04:29:15 <basti_> yes
04:29:19 <datenmaulwurf> ok, thanks !!
04:29:20 <datenmaulwurf> ;)
04:29:23 <basti_> cu
04:29:24 <datenmaulwurf> cu
04:29:28 <SamB> JKnecht: Terminated is more annoying because it gives the impression that it got the answer but won't tell you
04:30:24 <JKnecht> whereas bzzt indicates bottom?
04:30:52 <SamB> it indicates that something went wrong, but not very specifically.
04:31:21 <SamB> lambdabot used to actually give you error messages, someone decided it ought to just say "bzzt" to avoid confusion...
04:31:58 <JKnecht> polymorphic perverse :)
04:32:13 <basti_> hmm we ought to have "bzzt [@more for details]"
04:32:20 <SamB> hmm, yes ;-)
04:32:32 <SamB> or something like that
04:33:08 <JKnecht> @type fooBar
04:33:12 <lambdabot> bzzt
04:33:17 <JKnecht> @more
04:33:18 <lambdabot> more: empty buffer
04:33:42 <dons> ok, i've moved it back to the openbsd box for now, i'll debug the linux one tomorrow.
04:33:45 <dons> @type map
04:33:47 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
04:33:55 <SamB> @type Data.Char.ord
04:33:57 <lambdabot> Char -> Int
04:33:58 <SamB> @type Data.Char.chr
04:34:00 <lambdabot> Int -> Char
04:34:17 <dons> @eval Data.Char.ord 'a'
04:34:19 <lambdabot> 97
04:35:04 <dons> the linux one may be flakey for a number of reasons: new ghc version (last night's head) for one.
04:35:25 <SamB> dons: when was last night for you?
04:35:35 * SamB couldn't get it to build last night for him
04:35:39 <dons> @localtime dons
04:35:43 <lambdabot> Local time for dons is Tue Oct 25 21:29:34 2005
04:35:53 <Cale> @localtime Cale
04:35:55 <lambdabot> Local time for Cale is Tue Oct 25 07:35:32
04:36:01 <SamB> ah, so about last morning?
04:36:07 <SamB> @localtime SamB
04:36:08 <dons> oh, um, i just grabbed the last one that built properly
04:36:10 <lambdabot> Local time for SamB is Tue Oct 25 07:38:26
04:36:30 <dons> $ ghc --version
04:36:30 <dons> The Glorious Glasgow Haskell Compilation System, version 6.5.20051020
04:37:08 <dons> also though, this was the same kind of box as the openbsdd one, but different ghc, gcc and OS. so who knows what weird thing happened in between.
04:37:50 <dons> athough I've run lambdabot on a linux machine for a couple of years now with no worries. so I doubt it's the OS ;)
04:41:49 <Lemmih> dons: Using hs-plugins with ghc-6.5 on Linux?
04:42:29 <dons> yes.
04:42:32 <Lemmih> dons: And 'System.Plugins.Env.env `seq` ()` doesn't segfault?
04:43:06 <dons> Lemmih, check the thread on haskell-bug@ I think (?). it's almost certainly due to building hs-plugins with a differrent Cabal version to the currently running version
04:43:15 <dons> which triggered , also, panics in ghc
04:43:37 <dons> so i downloaded darcs Cabal, built hs-plugins, built lambdabot, all is good :)
04:43:46 <dons> 'cept for the weirdness above
04:43:47 <Lemmih> But I only got one Cabal installed.
04:44:10 <dons> did you ever build hs-plugins with 1.0 then install 1.1.3 say?
04:44:11 <SamB> Lemmih: well, is it the same version you built hs-plugins with?
04:44:19 <Lemmih> SamB: Yeah.
04:44:36 <Lemmih> Otherwise I wouldn't be able to load hs-plugins.
04:44:50 <SamB> Lemmih: how so?
04:45:13 * SamB wonders why it takes so long to calculate the dependencies for GHC proper...
04:45:48 <dons> Lemmih, so you built hs-plugins with the same Cabal that is currently running on your box?
04:46:26 <Lemmih> Built with, as in the Cabal library the Setup script used?
04:46:53 <dons> yeah, what Cabal was installed when you built hs-plugins?
04:47:00 <dons> and is it the same one that is currently exposed?
04:47:05 <Lemmih> Why does that matter?
04:48:00 <Lemmih> I installed hs-plugins with 6.4.1 (Cabal-1.1.4) for 6.5 (Cabal-1.0).
04:48:43 <Lemmih> Cabal-1.1.4 compiles libraries the same way Cabal-1.0 does.
04:49:28 <SamB> Lemmih: `ghc-pkg describe hs-plugins' to find out
04:50:04 <dons> so, for some reasons, hs-plugins will depend at runtime on the same Cabal version it was compiled with.
04:50:05 <SamB> er, s/hs-//
04:50:08 <dons> for example, to parser package.conf files.
04:50:37 <Lemmih> SamB: I know which Cabal libary I built hs-plugins against and ghc-pkg-6.5 confirms it.
04:51:06 <dons> anyway, check the mail thread from Simon, sethk and me. which has the details.
04:51:19 <dons> sorry, i'm falling asleep at the moment :S
04:51:39 <dons> I'm only guessing this is the same bug you have
04:51:47 <dons> but it sounds plausible
04:52:12 <Lemmih> I don't see how it could have effected hs-plugins.
04:53:28 <Lemmih> *affected
04:54:17 <ValarQ> hello folks
04:54:31 <dons> have you tried rebuilding hs-plugins with the latest cabal? does it still crash?
04:54:51 <ValarQ> i'm making a finite map with a fold and insertWith, is there any simple way to make that nonlazy?
04:54:56 <Lemmih> dons: Trying that now.
04:55:22 <dons> and why don't I see it with Cabal-1.1.4, ghc-6.5.20051020, plugins-0.9.10 and Cabal-1.0 hidden
04:55:23 * ValarQ is afraid it takes up to much memory
04:55:43 <dons> add a $!  or a seq
04:56:32 <ValarQ> dons: in my 'foldr1 (.) insert empty' ?
04:56:47 <ValarQ> s/sert/serts/
04:58:06 <dons> but profile it first, to see if it is actually costs you anything
04:58:14 <dons> also, there's a strict fold you could play with
04:58:16 <dons> @type fold'
04:58:18 <lambdabot> bzzt
04:58:21 <dons> @type foldl'
04:58:22 <lambdabot> bzzt
04:58:37 <dons> @type Data.List.foldl'
04:58:38 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:01:28 <dons> night all!
05:01:36 <ValarQ> dons: g'dnite
05:03:01 <dcoutts> g'night dons
05:03:39 <gour> dons: is it still night :-)
05:04:32 <dcoutts> @localtime dons
05:04:35 <lambdabot> Local time for dons is Tue Oct 25 21:58:27 2005
05:05:39 * Lemmih slaps head.
05:06:05 <Lemmih> It was an old .hi file which messed it up (:
05:06:06 <gour> dcoutts: ohh, here is 20C (like a summer) and I thought it's the same over there :-)
05:06:14 <ValarQ> hmm, that hp2ps graph was quite interesting
05:22:50 <ValarQ> "Stack space overflow"...
05:22:58 * ValarQ wonders what he has done this time
05:25:25 <boegel> used too much memory ? :P
05:26:36 <ValarQ> probably...
05:27:56 <ValarQ> i believe my finite map producing fold is to blame, but making the little fella strict didn't do much good
05:33:55 * ValarQ stares at his profile report
05:34:35 <ValarQ> my memory seems to be in a place called "BLACKHOLE"
05:36:50 <boegel> :D
05:43:11 <kosmikus> CosmicRay: I'm going to send a HCAR reminder to haskell@haskell.org today, in case you want to include that again into HWN ...
05:47:38 <CosmicRay> kosmikus: excellent
05:47:48 <CosmicRay> kosmikus: please do that within the next few hours
05:48:02 <ndm> kosmikus: i'll do mine now!
05:58:13 <kosmikus> CosmicRay: within the next three, I hope, but not much earlier ...
05:58:24 <rafl> CosmicRay: Hello. Do you know how I can prevent Cabal from adding library-dirs to Package.cabal when writing ti .installed-pkg-config? That fucks up the pugs hs interface installtion in Debian.
06:00:46 <boegel> CosmicRay: y0, how about HWN ?
06:03:24 <paolino> morning all
06:04:19 <paolino> is it possible to unimport the module defining a name I want to use ?
06:04:39 <basti_> you can import ... hiding (name)
06:05:09 <paolino> ciao basti_ , I wan to to redefine Left and Right
06:05:23 <basti_> these come from the prelude
06:05:35 <basti_> if you reimport the prelude, you can override the defaults
06:06:52 <paolino> not clear enough what is a reimport ?
06:07:27 <basti_> type "import Prelude hiding (Either (Left,Right))" in the top of the file
06:07:39 <paolino> import prelude hiding (Left,Right) ?
06:07:51 <paolino> ah thanks
06:08:02 <xerox> paolino!!
06:08:14 <paolino> xerox !!!
06:08:38 <xerox> Did you hear tazzo yet?
06:08:52 <paolino> yup I'm zipping
06:09:00 <xerox> :-D
06:09:26 <paolino> well I wish it worked actually
06:09:52 <xerox> Agreeable
06:11:14 <MarcWeber> Hi. I want to assign a number to every character "abc.." with a=1 b=2 c=3 .. So in this case a "indexOf" function would be sufficient. How would you implement this?
06:12:40 <Lemmih> @eval zip "abc" [1..]
06:12:41 <lambdabot> [('a',1),('b',2),('c',3)]
06:12:46 <Lemmih> Something like that?
06:13:01 <xerox> @type lookup
06:13:02 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
06:13:52 <ibid> dcoutts: i showed them BouncingBall :)
06:13:59 <paolino> xerox should  it hold "top $ left (tree,T) === (tree,T)" ?
06:14:32 <xerox> paolino: top does not get a Loc a.
06:14:40 <paolino> s/T/Top
06:14:41 <kolmodin> ibid: where they impressed? :)
06:15:10 <xerox> paolino: Top is a nullary constructor
06:15:22 <paolino> xerox up $ left (tree,Top) == (tree,Top)
06:16:10 <xerox> paolino: yes.
06:16:17 * boegel notices the staggering number of actives in #haskell: 193 !
06:17:00 <Philippa> yeah, it's not such a shock that there're two offshoot chans now...
06:17:28 <Igloo> I'm not sure "actives" is the best term  :-)
06:17:35 <Philippa> true :-)
06:17:46 <Philippa> most of 'em are pretty idle
06:18:01 <Philippa> (not me, oh no!)
06:18:10 * xerox boings a bit
06:19:31 <MarcWeber> Lemmih: Let me try
06:19:43 * musasabi tries to picture the whole channel boinging with lambdas
06:22:05 <xerox> MarcWeber: did you see the 'lookup' function?
06:23:01 <ibid> kolmodin: i hope :)
06:23:12 <kolmodin> :)
06:23:36 * boegel asks if anyone keeps logs of #haskel-blah
06:27:45 <joelr> howdy folks
06:27:48 <joelr> dons: ping
06:28:01 <MarcWeber> Lemmih: works like a charm s
06:29:40 <MarcWeber> Lemmih: works like a charm ;-) But I think I have to do some benchmarks on tasks like this to get to know wether there are big differences in different implementations..
06:29:49 <lisppaste2> paolino pasted "browsable tree" at http://paste.lisp.org/display/12850
06:30:20 <paolino> xerox it doesn't satisfy the equation :(
06:30:38 <xerox> Indeed
06:31:10 <xerox> up (t, Left c r) = (Branch t r, c)
06:31:10 <xerox> up (t, Right l c) = (Branch l t, c)
06:32:17 <paolino> :)
06:32:58 <xerox> left and right need not to lose information too.
06:34:08 <xerox> left (Branch l r, c) = (l, Left c r)
06:34:21 <xerox> left (Branch l r, c) = (r, Right l c)
06:34:31 <xerox> the latter is 'right' sorry :)
06:35:52 <paolino> what about the value in the Branch ?
06:36:00 <xerox> Value?
06:36:18 <xerox> Oh, I see.
06:36:43 <xerox> I'd put it in the middle of the edges, but whatever... you can just keep it.
06:37:24 <paolino> my Branch has a value also :/
06:37:25 <paolino> I should be able to unpuzzle it alone I suppose
06:37:45 <paolino> up (t, Left c r) = (Branch t r, c) ?
06:37:48 <xerox> Maybe you need other kind of movements.
06:37:50 <joelr> has anyone used hs-plugins on windows?
06:38:19 <paolino> the Branch misses the value
06:38:34 <xerox> With the current Path you can't mark the place occupied by the values at the nodes.
06:40:54 <paolino> ahi
06:41:27 <paolino> So I'm not any free in defining the tree
06:41:30 <lambda41> Well, the path really only stores the way back to the top, so one direction should be enough; how about Path a = Top | Up (Path a) (Tree a) ? Right now, Left and Right both lose a label that up can't reconstruct.
06:42:38 <xerox> int-e: there should not be information loss
06:43:13 <int-e> xerox: right, you already said that. but there is, in the paste version.
06:43:46 <xerox> So it's all about what paolino want :)
06:43:54 <paolino> int-e how I "go down" ?
06:44:09 <xerox> (With left or right?)
06:44:47 <paolino> there  is no Left Right in int-e Path
06:44:48 <int-e> paolino: left (tree@(Branch label left right), path) = (left, Up path tree)
06:45:26 <int-e> paolino: simply remember the tree that up needs to reconstruct instead of the right subtree and the label at the node (that you forgot)
06:46:15 <xerox> int-e: does this version preserve order?  (I think so but I'm still wondering a bit)
06:47:03 <int-e> xerox: it preserves the whole tree ... hmm. I guess you need to distinguish Left and Right once you want to support updates.
06:51:20 <int-e> xerox: up would be up (_, Up path tree) = (tree, path) ... obviously all changes below that node (if there are any) would be lost.
06:51:45 <xerox> Yeah.
06:54:13 <paolino> int-e from that I guess the solution is not even that
06:56:20 <int-e> paolino: to support changes you're probably best off with something like data Path a = Top | Left a (Path a) (Tree a)| Right a (Path a) (Tree a) (note the added a in Left and Right - it can store the label that left and right currently lose)
06:56:39 <xerox> That's what I meant before.
06:56:56 <int-e> xerox: I know.
06:57:02 <xerox> Also I'd put the value between the edges, for shape's sake :D
07:02:28 <Lemmih> Hi davve.
07:03:59 <tic> yo davve.
07:17:11 <shapr> yay, ipv6 freenode is back.
07:17:24 <shapr> Wow, 197 clients, another all time high.
07:17:32 <beschmi> is there any other GUI toolkit than fudgets implemented in haskell? everything else seems to be bindings to c-libs
07:17:46 <shapr> beschmi: Gadgets, in House
07:17:56 <Lemmih> Hi shapr.
07:18:07 <shapr> hiya Lemmih
07:18:09 <shapr> How's code?
07:18:10 <Lemmih> Written your HCAR entries yet?
07:18:16 <shapr> er, no? When's the due date?
07:18:32 <beschmi> shapr: yes, i forgot to mention that. seems to be based on the some ideas
07:18:44 <shapr> Yesterday I got a month's worth of work that must be finished in less than a month.
07:18:46 <Lemmih> shapr: 1 November
07:19:02 <shapr> beschmi: What about the arrow-based critters? wxFruit, FranTk, etc?
07:20:54 * shapr writes HC&AR entries...
07:20:56 <beschmi> shapr: i'm not sure how much of the low level stuff is implemented in haskell. i'm trying to implement some nicer widgets on top of hscurses
07:23:28 <shapr> kosmikus: What's up with "\entry{unchanged, unpinged}% done, shouldn't be removed" ? Do you have your incoming emails set to automatically strip out attachments and stick them into the report?
07:27:15 <ndm> alpha version: http://www-users.cs.york.ac.uk/~ndm/cgi-bin/hoogle3-cgi
07:27:24 <ndm> if anyone has any feedback, i'd be interested to hear it
07:27:37 <ndm> but don't send it to the lists or anything yet, its still very much alpha!
07:28:41 <shapr> ndm: Did you already see my comment?
07:28:49 <ndm> yep
07:28:58 * shapr checks for a response!
07:29:05 <ndm> responding now, still typing....
07:29:37 <shapr> :-)
07:30:16 <ndm> it will move to darcs, but probably not for a few weeks at least
07:30:22 <shapr> ndm: Also, if you had a darcs repo I could submit a patch for the typo I just found - help.htm has "Haskel"
07:30:36 <ndm> help.htm isn't finished at all
07:30:42 <ndm> its from the old version of hoogle
07:30:53 <ndm> and it 404's on the stylesheet and script files
07:30:55 <shapr> oh, ok then.
07:31:01 <ndm> which is why its styled badly
07:31:13 <ndm> thats what i was going to do now, write all the pages!
07:32:28 <JohnMeacham> You know what is neat? having your compiler change the xterm title as it makes progress, so your taskbar becomes a progress meter for your compiles.
07:32:57 <shapr> JohnMeacham: That is especially cool.
07:33:57 <xerox> eek eek eek
07:33:57 <JohnMeacham> Hmm.. I should make it so you can set jhc dump flags in the environment, so I don't have to remember to keep passing my favorite ones.
07:34:27 <shapr> xerox: boop boop
07:35:23 <shapr> hiya franka
07:36:46 <franka> Hey, shapr.
07:37:38 <shapr> dons: Seen bbe? 'binary sed' - http://members.surfeu.fi/tjsa/bbe/
07:39:14 <shapr> So, have I missed any good #haskell tour opportunities?
07:40:17 <xerox> Yes, dons gave one!
07:40:27 <shapr> oh cool! Who's the newbie?
07:42:50 * Lemmih tries to summon two more Haskellers.
07:42:53 <basti_> eep
07:44:16 <shapr> I have this crazy idea that immutability and garbage collection on the hardware level will lead to easy use of NUMA without cache coherency, and nearly transparently allow an arbitrary number of levels of cache, with no write checking required.
07:44:29 <shapr> Well, that's 199
07:45:15 <shapr> c'mon, one more Haskeller :-)
07:45:56 <davve> shapr, NUMA?
07:46:14 <neologism> non-uniform memory acces?
07:46:18 <shapr> Non Uniform Memory Access
07:46:30 <davve> ah, okj
07:46:44 <zer0`> hi
07:46:58 <shapr> CPUs have their own memory in NUMA, AMD's x86-64 is a good example.
07:47:01 <shapr> hiya zer0`
07:47:03 <shapr> hej bergrotf
07:47:10 <basti_> 200!
07:47:13 <shapr> whee!
07:47:22 <bergrotf> tja sharpr
07:47:50 * shapr boings cheerfully
07:47:53 <Lemmih> gour: Welcome to the overpopulated Haskell channel (:
07:48:24 <gour> Lemmih: huh, over 200 :_)
07:48:53 <gour> Lemmih: it's getting hot here :-)
07:49:39 <gour> Lemmih: have you seen my yesterday's messge - ghc-6.5 does not build here
07:50:15 <paolino_> sorry what is wrong here ? average list = foldr1 (+) list / length list
07:51:07 <gour> shapr: few (or more days ago) i've noticed you installed trac. was it for hIDE?
07:51:16 * ibid wrote an incomplete "haskell cheat sheet" for my course
07:51:17 <basti_> paolino_: use more parenthensises
07:51:19 <paolino_> something to do with building a Fractional from Int ?
07:51:52 <shapr> gour: I haven't yet installed a hIDE trac, because I haven't figured out the apache access yet.
07:51:53 <basti_> hmm
07:51:54 <basti_> no
07:51:56 <Lemmih> gour: Oh, OK. I found out why it wasn't working on my box.
07:52:18 <gour> Lemmih: so no testing required, atm?
07:52:43 <Lemmih> paolino_: 'length list' has type Int but '/' isn't for integer division.
07:52:43 <paolino_> average list = (foldr1 (+) list) / (length list) doesn't compile even
07:52:49 <gour> shapr: ok, i'm glad you're on the way ;)
07:53:08 <tromp> try using fromIntegral
07:53:28 <paolino_> I need fractional division
07:53:31 <paolino_> k
07:53:50 <Lemmih> gour: Yeah, no need for testing now.
07:55:11 <xerox> @pl \xs -> (fromIntegral $ f xs) / (fromIntegral $ g xs)
07:55:12 <lambdabot> ap ((/) . fromIntegral . f) (fromIntegral . g)
07:55:19 <xerox> @pl \f g xs -> (fromIntegral $ f xs) / (fromIntegral $ g xs)
07:55:19 <lambdabot> (. (fromIntegral .)) . liftM2 ((/) . fromIntegral)
07:56:28 <kolmodin> cd
07:56:33 <kolmodin> err, wrong window
07:57:00 <xerox> ..at least it wasn't a password.. was it?  <blink>
07:57:12 <kolmodin> :)
07:58:10 <gour> Lemmih: good 'cause ghc-head (still) does not build
07:58:10 <kolmodin> actually, I have written a password on irc once. not in this channel though
07:58:37 <Lemmih> Why is #haskell so popular all the sudden?
07:58:56 <gour> hIDE development
07:59:20 <kolmodin> the AFP course at chalmers just started :)
07:59:52 <gour> dcoutts works on new gtk2hs release
08:00:45 * xerox is so happy about it :)
08:03:03 <gour> JaffaCake: is it know nthat ghc-head does not build (on amd64)?
08:03:28 <JaffaCake> I fixed a build error today, I think
08:03:51 <JaffaCake> things are a bit unstable after the recent changes to the RTS
08:03:54 <gour> JaffaCake: ghc-6.4.1: Can't find main/ErrUtils.lhs-boot
08:04:11 <JaffaCake> ah, thanks
08:04:14 <JaffaCake> I need to commit that file
08:04:41 <gour> JaffaCake: i can (still) live with 6.4.1 :-)
08:05:30 <JaffaCake> committed now, please let me know if it works
08:06:57 <gour> JaffaCake: i'm using ghc-cvs ebuild, so will take some time, but will report back, ta
08:07:15 <JaffaCake> ok, thanks
08:08:10 <shapr> Neat, we had 204 earlier.
08:09:07 <dcoutts_> shapr, really? wow
08:10:19 <shapr> Oh, I had an idea for a simple darcsforge. Someone with a lot of bandwidth could automatically pull from repos. If the users put an index.html in their darcs repo, they'd automatically have a 'website' too.
08:11:19 <dcoutts_> shapr, good idea. Does haskell.org have a lot of bandwidth?
08:11:25 <dcoutts_> forge.haskell.org ?
08:11:43 <shapr> They're hosted at Yale's CS department.
08:11:44 <dcoutts_> dns forge.haskell.org -> haskell.org or cvs.haskell.org perhaps?
08:11:44 <bourbaki> moin
08:12:36 <shapr> JaffaCake: Do you know if haskell.org / Yale would be willing to host a simple darcsforge like that?
08:13:21 * JaffaCake reads up
08:13:54 <dcoutts_> pulling via http is not terribly bandwidth intensive (it's quick compared to ssh pulls)
08:14:22 <JaffaCake> haskell.org has more bandwidth than cvs.haskell.org... you'd need to ask John Peterson who handles haskell.org, he's usually quite enthusiastic about adding services tho
08:14:41 <shapr> Ok, cool.
08:15:06 <JaffaCake> we're putting the RT server on haskell.org, when autrijus gets around to it
08:15:19 <dcoutts_> RT?
08:15:27 <JaffaCake> request tracker
08:15:31 <dcoutts_> oh right
08:15:45 <dcoutts_> what are you using for that then? bugzilla? Trac?
08:16:03 <JaffaCake> autrijus very kindly offered to set up RT for us to use instead of sourceforge
08:16:15 <dcoutts_> @google RT request tracker
08:16:16 <lambdabot> http://www.bestpractical.com/rt/
08:17:59 * dcoutts_ tries yet again to build the Gtk2Hs 0.9.10 release candidate on Solaris 9 with Gtk+ 2.0 and pango 1.0
08:18:26 * dcoutts_ dislikes Solaris
08:20:04 <ndm> JaffaCake: just for ghc, or will all haskell.org projects be able to use it?
08:20:34 <JaffaCake> I think other projects could use it to, at least that's the impression I got
08:21:31 <shapr> dcoutts_: Any word on your partial evaluation code? Seems like it might be handy with Template Haskell.
08:22:24 <juhp> JaffaCake, rt better than bugzilla?
08:22:36 <dcoutts_> shapr, sorry, it's still in the heavy working-out-algorithms stage. It should be useful with TH, that's what I've been targeting.
08:22:51 <shapr> cool
08:23:07 <JaffaCake> juhp: I haven't used either, I believe both have their good/bad points
08:23:11 <dcoutts_> shapr, but I've got some nice graph and type inference algorithms :-)
08:23:51 <shapr> neat :-)
08:27:23 <CosmicRay> shapr!
08:27:33 <CosmicRay> JaffaCake: was the info on reproducing that bug satisfactory for you?
08:27:37 <CosmicRay> JaffaCake: cool.  RT is very nice.
08:28:00 <CosmicRay> JaffaCake: but it takes a little bit to get set up optimally (especially to let the public have access to the system).  I'm assuming autrijus knows all this already.
08:28:15 <CosmicRay> shapr: can I run a database algorithm design question by you?
08:28:25 <JaffaCake> CosmicRay: great instructions, I'll have a go at reproducing
08:28:36 <CosmicRay> JaffaCake: ok, thanks, feel free to ask if you need clarification anywhere
08:28:48 <JaffaCake> sure, will do
08:28:57 <CosmicRay> JaffaCake: I could also send you core files, binaries, whatever else from my box if it would help.
08:29:24 <shapr> CosmicRay: sure
08:29:47 <JaffaCake> CosmicRay: actually, it might be worthwhile to look at a core file first
08:29:55 <gour> JaffaCake: StgCRun.c:88:0
08:30:01 <CosmicRay> shapr: ok.  so with gopherbot, I am doing an archive.org-like thing with what remains of gopherspace.  I have a multi-threaded bot, and I want to download every gopher URL I can, and make sure I have no more than one simultaneous connection to any given host.
08:30:08 <gour> JaffaCake: error: request for member `DebugFlags' in something not a structure or union
08:30:09 <JaffaCake> CosmicRay:  if you could send me a link to the core and the binary that'd be great
08:30:13 <CosmicRay> JaffaCake: ok, I'll dig one up for you in a few minutes
08:30:27 <CosmicRay> JaffaCake: will you also need any of the .so's that it's linked against?
08:30:59 <JaffaCake> CosmicRay: probably not, as long as gdb can load up the binary
08:31:14 <CosmicRay> shapr: I store state information in a SQL database, one row per URL, that is selectable by host and state (visited/notvisited/etc.)
08:31:16 <CosmicRay> JaffaCake: OK
08:31:22 <JaffaCake> gour: hmm, don't know what's causing that
08:31:56 <juhp> JaffaCake, ok - I wonder if bugzilla isn't better suited to tracking bugs and stuff
08:32:26 <juhp> it is also written in perl ;)
08:32:36 <CosmicRay> shapr: so my current algorithm basically doing a SELECT DISTINCT host from FILES.  Each worker thread reads a row from that query whenever it finishes with its host.
08:32:55 <JaffaCake> juhp: if someone sets it up, I'm happy to try it out
08:32:58 <CosmicRay> shapr: then the worker threads go out and do a SELECT * FROM files WHERE host = blah and state = notvisited
08:33:05 <CosmicRay> (add that state = notvisited to that select distinct above)
08:33:23 <CosmicRay> JaffaCake: Uploading the file now...
08:34:01 <CosmicRay> shapr: problem is, with millions of rows, there are a few very large servers (100,000 or more URLs) but many very small servers.  the per-worker-thread select is expensive, and I'd prefer to minimze it.
08:34:16 <CosmicRay> nice.  bzip2 compressed this 291MB core file down to 8.9MB. ;-)
08:34:39 <JaffaCake> juhp: also, it'd be nice if we could transfer our metadata from sourceforge (autrijus says he can do this for RT)
08:34:44 <musasabi> CosmicRay: how about caching all the active connections in the daemon process?
08:35:11 <CosmicRay> musasabi: I could do that, but then when a given thread is done processing a url, how does it figure out what to do next?
08:35:15 <gour> JaffaCake: I pasted the error with some context at: http://rafb.net/paste/results/9lncXA74.html
08:35:51 <CosmicRay> musasabi: in fact, my first attempt was to maintain an active hosts list, and have a single running query (select * from files where state = notvisited), and to simply skip over any hosts that were being processed already.
08:35:57 <CosmicRay> this turned out to be very expensive.
08:36:29 <juhp> dcoutts, is the rc available somewhere?
08:36:47 <CosmicRay> since selectors from one host tend to occur in blocks close to each other, and again it tends to wind up with a few large servers to download from
08:36:48 <musasabi> CosmicRay: I would just try to minimize hitting the db (caching data) and use proper indexes.
08:36:58 <kosmikus> shapr: no, that's just a comment for me about what kind of changes were made during the last report
08:37:04 <CosmicRay> musasabi: I've already done all I can with the indices.
08:37:21 <kosmikus> shapr: it doesn't appear in the typeset version, you can remove it or leave it as it is; I will update it ...
08:37:22 <CosmicRay> musasabi: which have helped.  and switching from sqlite3 to postgresql also helped.
08:37:58 <CosmicRay> musasabi: but I'm not sure how I can minimize hitting the db better.  Something with that master query perhaps, so I wouldn't have to issue queries from each thread?
08:38:19 <CosmicRay> maybe keep a list of entries for a specific host that have been skipped over due to being in use?
08:38:43 <JaffaCake> gour: I don't get that on my x86 build, I'll have to wait until tonight's x86_64 build
08:39:00 <gour> JaffaCake: ok, no rush ;)
08:40:28 <wilx`> Hmm, what about separating the table into two, visited and notvisited?
08:40:48 <CosmicRay> JaffaCake: http://www.complete.org/~jgoerzen/crash.tar.bz2
08:40:48 <wilx`> (Random guess.)
08:41:06 <juhp> gour, have you tried the "gtk2hs-0.9.10 release candidate"?
08:42:45 <juhp> JaffaCake, ok fair enough - I haven't used rt that much - though we use both at work - do the perl people use rt too?
08:43:00 <JaffaCake> I believe so
08:43:05 <juhp> aha
08:43:17 <MarcWeber> How can I get commandline arguments? A Keyword is enough to google/ grep the libraries..
08:43:42 <Lemmih> @type System.Environment.getArgs
08:43:46 <lambdabot> IO [String]
08:44:05 <gour> juhp: yes
08:44:35 <Lemmih> @google Why IO type getArgs
08:44:36 <lambdabot> http://comments.gmane.org/gmane.comp.lang.haskell.general/12260
08:44:42 <juhp> gour, oh good - do you have an url? or did I miss a mail :)
08:45:02 <wilx> CosmicRay, could I see your DB's schema?
08:45:33 * juhp would like to submit gtk2hs to Fedora Extras soon, but right now just build it for ix86...
08:45:35 <gour> juhp: http://haskell.org/gtk2hs/gtk2hs-0.9.9.7.tar.gz
08:45:53 <juhp> gour, thanks
08:46:28 <ndm> @hoogle args
08:46:29 <lambdabot> System.getArgs :: IO [String]
08:50:13 <CosmicRay> wilx: see initTables in http://darcs.complete.org/gopherbot/DB.hs
08:57:08 <shapr> CosmicRay: what about a queue of host / url pairs? You could select one unvisited url for each distinct host, put those items into a queue, and each time the queue starts to get smaller than the number of worker threads you could select up another chunk to throw into the queue.
08:58:05 <shapr> You'll probably end up with multiple connections to slow hosts once the list of distinct hosts with an unvisited url gets small.
08:58:42 <shapr> But it's an easy to implement 'best-effort' approach to not having more than one connection to a host.
08:59:40 <CosmicRay> shapr: hmm, how would the queue filler do its query?
08:59:55 <CosmicRay> just a select * sort of thing?
09:02:35 <wilx> Well...I think I would use varchar(255) for host, and integers for state or any enum-like column. That is micro optimization that could make your rows shorter, more rows on page, less IO.
09:03:17 <wilx> And as for the state column, if the state is only few values, I think I would try to make on table for each state.
09:04:22 <shapr> CosmicRay: map (select max(url)) (select distinct host)
09:04:45 <shapr> um, "where state = notvisited"
09:05:58 <kosmikus> CosmicRay: sent now
09:06:57 <autrijus> JaffaCake: I'm still pending john peterson's instructions on the rt layout.
09:07:19 <autrijus> (I can use the default one, but he said he'll get back to me today)
09:07:48 <musasabi> Also with postgresql you can make an aggregate index (that is one containing both the hostname and state=notvisited)
09:07:58 <sheriff> If I use 'the formula' to solve a quadratic equations, can one answer be wrong?
09:08:30 <SamB> sheriff: why do you ask?
09:08:53 <wilx> Does SET ENABLE_SEQSCAN to OFF really speed things up?
09:18:40 <shapr> I have a brain teaser that I've been staring at for years. I want to do lazy key promotion in a bayesian spam filter I wrote. The promotion functions are simple, trimBang takes '!' off the end, trimCase turns FOO into Foo and then foo. I want to iterate a trim function until it returns [], and then when the next trim function works, I want to start the iterations all over again.
09:19:21 <shapr> I can't figure out how to write that.
09:23:09 <shapr> I sort of want to fold mplus over the whole thing, but that's not quite right.
09:23:56 <musasabi> Is there any ReadP tutorial?
09:27:37 <xerox> @seen paolino
09:27:37 <lambdabot> I saw paolino leaving #haskell 1 hour, 25 minutes and 43 seconds ago.
09:27:40 <xerox> @seen paolino_
09:27:41 <lambdabot> I saw paolino_ leaving #haskell 1 hour, 12 minutes and 39 seconds
09:27:41 <lambdabot> ago.
09:32:45 <joelr> hello
09:32:58 <SyntaxNinja> hi
09:33:02 <joelr> what's the quickest way to re-export a bunch of imports from a single module?
09:33:37 <SyntaxNinja> quickest?
09:33:44 <joelr> i.e. module Baz that imports Foo and Bar and exports there defs
09:33:44 <SamB> joelr: well, if you want to export whole modules, just say "module Foo, module Bar" in the export list
09:34:07 <kosmikus> module Baz (module Foo, module Bar) where ...
09:34:08 <joelr> aha
09:34:11 <joelr> thank you!
09:35:52 <joelr> strange
09:36:02 <joelr> do the module files have to be upper case as well?
09:36:21 <kosmikus> I think so, yes
09:36:46 <joelr> Baz.hs:3:8: Unknown module in export list: module `Foo'
09:36:53 <joelr> i have Foo.hs in that directory
09:36:59 <kosmikus> have you imported Foo?
09:37:11 <joelr> nope
09:37:15 <kosmikus> :)
09:37:23 <SamB> that usually helps ;-)
09:37:38 <joelr> haha
09:37:41 <joelr> yes, it did
09:37:44 <joelr> thank you folks!
09:38:28 <CosmicRay> autrijus: I can try to help with rt questions if you have any
09:42:37 * SamB thinks he sees the purpose of -split-objs...
09:43:55 <dcoutts_> SamB, now you're getting huge executables because you didn't use -split-objs?
09:44:21 <SamB> dcoutts: well, hello world has an insane symbol table, thats all...
09:46:03 <SamB> I doubt if GHC has much more overhead from this, since it uses so little from the libs anyway
09:52:52 <hemstock> hello
09:53:47 <tennin> hi
09:54:36 <hemstock> can you please tell me why the types do not much here?
09:54:37 <hemstock> http://pastebin.ca/26622
09:54:49 <hemstock> I ve been trying to find it for 2 hours
09:54:59 <basti_> types aren't supposed to do much ^^
09:55:05 <basti_> [you probably mean "match"]
09:55:38 <hemstock> yeah :P
09:55:49 <defcon8> hello
09:55:52 <hemstock> I get this error
09:56:00 <hemstock> *** Expected type : [a] -> ([a],[a])
09:56:00 <hemstock> *** Inferred type : [[a]] -> ([[a]],[[a]])
09:56:02 <defcon8> what is haskell used for these days?
09:56:14 <hemstock> But it doesnt make any sence
09:56:19 <basti_> i get a different error
09:56:20 <xerox> defcon8: everything
09:56:27 <basti_>     Couldn't match the rigid variable `a' against `[a1]'
09:56:28 <basti_>       `a' is bound by the type signature for `halve'
09:56:32 <kombinator> hemstock: try x instead of [x] in b an c
09:56:55 <SamB> fun and profit!
09:56:58 <basti_> painfully obvious yes ^^
09:57:12 * basti_ gives hemstock a gentle cuddle for the shock
09:57:21 <defcon8> xerox, but in the industry
09:57:48 <xerox> defcon8: are you learning Haskell?
09:57:48 <hemstock> thank you kombinator
09:57:50 <basti_> defcon8: you mean something along the line "who thinks haskell is worth $$$$$"?
09:57:53 <hemstock> But why should that matter?
09:58:10 <basti_> hemstock: [x] is the list that contains the one element x.
09:58:13 <basti_> x is x.
09:58:22 <basti_> theres a difference
09:58:23 <xerox> basti_: what a profound.. :-)
09:58:37 <dcoutts_> defcon8, in industry haskell is being used for high asurance software
09:58:43 <hemstock> ooooh
09:58:47 <hemstock> Thank you so mucj
09:58:48 <hemstock> much
09:58:50 <basti_> xerox: i dont want to make it more complicated than it is
09:59:05 <xerox> basti_: sorry, I was referring to 'x is x' :-)
09:59:08 <defcon8> xerox, not yet
09:59:10 <basti_> xerox: oh
09:59:11 <tennin> anyone know of a (more or less) introductory book on compiler design that applies well to functional languages like Haskell?
09:59:14 <defcon8> yeah as im thinkign of doing cs
09:59:22 <tennin> i don't know enough to judge well, but the books I looked at like the dragon book and Crafting a Compiler seem heavily oriented toward procedural languages
09:59:25 <defcon8> and will haskell make me money
09:59:26 <SyntaxNinja> defcon8: I work for a company using Haskell for most projects
09:59:28 <basti_> tennin: theres lots of parsing stuff around.
09:59:34 <defcon8> hmm
09:59:37 <Itkovian> defcon8: you shoudl study something you enjoy
09:59:37 <dcoutts_> defcon8, that is where people will pay you a lot of dosh to write software that doesn't go wrong, with some dagree of asurance
09:59:48 <defcon8> right
09:59:49 <SyntaxNinja> defcon8: are you looking for a short-term payoff, or a long-term carreer? what kinds of things do you enjoy?
09:59:55 <SyntaxNinja> defcon8: haskell makes me money, and I enjoy it.
10:00:04 <defcon8> well im still learning actually
10:00:09 <defcon8> i know C a bit of CPP and python
10:00:11 <Itkovian> if you don't enjoy it, you'll quit first thing in the morning
10:00:31 <SamB> defcon8: CPP is usefull with Haskell. But you probably meant C++...
10:00:32 <defcon8> what about the library abundancy of haskell?
10:00:35 <ricebowl> I thought the point was the be well-rounded, not necessarily studying only "useful" subjects since all are in some form or another useful
10:00:44 <beschmi> tennin: there is "modern compiler construction in ML" y Appel
10:00:54 <ricebowl> since programming is an art, not a science
10:01:35 <Oejet> ricebowl: It's not even yet an engineering discipline, I guess.
10:01:37 * xerox high-fives ricebowl keeping his SICP copy in the other hand
10:02:33 <kombinator> SyntaxNinja: do you use some fancy haskell idioms at work?
10:02:42 <pejo> tennin, Xavier Leroy has a bunch of slides on his homepgae if your compiler is for functional languages. Appel got "Compiler construction in ML".
10:02:48 <xerox> Idioms as in, that library? :)
10:02:51 <ricebowl> fwiw where I work we use only assembly and C++, C# occasionally for GUI work, but we have to design some scripting languages... take a guess as to what it will be based off of ;)
10:02:54 <kombinator> SyntaxNinja: like doing specialized monads etc.?
10:03:43 <tennin> if you're hoping to make money in the short term you should look through the classified ads where you live and learn whatever seems to be demand
10:03:44 <pejo> tennin, The C-- people have some papers, one is using Huet's Zipper for the CFG.
10:03:56 <tennin> but if you're seeking to be effective in the long term, and gain a deep understanding of the subject,
10:03:58 <defcon8> oh and which haskell compil;er should i use for haskell on linux?
10:04:25 <SyntaxNinja> kombinator: I personally don't use anything overly fancy, though I do have a couple of specialized monads in my program.
10:04:31 <tennin> chances are you'll find yourself needing to explore far from the beaten path
10:05:08 <defcon8> anyone?
10:05:12 <hemstock> how does null react If you use it in a conditional expression?
10:05:21 <tennin> thanks everyone
10:05:24 <SyntaxNinja> defcon8: ghc is what we use for the mots part here.
10:05:32 <SyntaxNinja> s/mots/most
10:05:38 <DonChullio> Hi here is a very good Browser Game !!!! http://www.street-conflicts.de.ki !!!!! It's about Gangster and ...... !!!!!!
10:05:48 <tennin> so the Appel book is "for" ML-like languages, not merely "in" it?
10:05:50 --- mode: ChanServ set +o SyntaxNinja
10:05:53 --- kick: DonChullio was kicked by SyntaxNinja (SyntaxNinja)
10:05:58 <defcon8> thanks SyntaxNinja
10:06:13 <defcon8> guess ill have a look into haskell then
10:06:16 <xerox> paolino!!
10:06:16 <tennin> "in" one, rather... bad grammar day
10:06:21 <xerox> paolino: I got something for you.
10:06:35 <xerox> Wops.
10:06:58 <pejo> tennin, I wasn't sure what you wanted by reading your question. I've only read the Java version of his book, so I can't answer that question. Your local bookstore might have a copy you could browse though (or library).
10:07:05 <xerox> paolino: welcome back :-)
10:07:17 <DonChullio> Hi here is a very good Browser Game !!!! http://www.street-conflicts.de.ki !!!!! It's about Gangster and ...... !!!!!!
10:07:17 <paolino> I should imagine eheh
10:07:45 <dcoutts_> heh heh
10:07:47 <tennin> ok, sorry for being unclear
10:07:49 <ricebowl> that wasn't spam or anything
10:07:55 <xerox> paolino: watch this:
10:07:55 <xerox> t = Branch (Leaf 1) 0 (Leaf 3)
10:07:55 <xerox> > modify (top t) correct
10:07:55 <xerox> (Branch (Leaf 1.0) 2.0 (Leaf 3.0),Top)
10:07:55 <SyntaxNinja> can someone tell me how to ban him?
10:07:55 <dcoutts_> left before he could get kicked
10:07:56 <ricebowl> probably get zero-day'd if you go to that website
10:08:06 <ricebowl> SyntaxNinja - /mode #haskell +b *!*@*.de
10:08:14 <ricebowl> though you probably want a narrowed mask ;)
10:08:48 <paolino> xerox, obscure
10:08:58 <ricebowl> I think *!*@*.de covers like half the chan :|
10:09:05 <xerox> paolino: oh :-)  Just notice that the value is now the mean as you asked.
10:09:10 <dcoutts_> SyntaxNinja, on my IRC client there are menu things for kick and ban, so if you did /kick ... , try /ban ...
10:09:23 <xerox> paolino: we'd better go on #haskell.it or #haskell-overflow :-)
10:09:25 <ricebowl> mm, where is #deutsch-help
10:09:35 <paolino> .it
10:09:38 <ulfdoz> SyntaxNinja: /mode +b *!*email@*.adsl.hansenet.de
10:10:09 <integral> /mode +b DonChullio!*@* -- is often sufficient for less persistent ones
10:10:39 <SyntaxNinja> k thanks.
10:11:23 <xerox> paolino: The zip and correct trees: http://haskell.galois.com/~paolo/Tree.hs
10:13:16 <pejo> tennin, oh, and Simon Peyton Jones has some out of print stuff on his homepage. http://research.microsoft.com/users/simonpj/papers/slpj-book-1987/index.htm
10:13:36 <defcon8> haskell has boggled me :|
10:13:36 <MarcWeber> Can you help my once again? This is my attempt: http://www.rafb.net/paste/results/cHIj1b59.html I get a "Not in Scope: IntValue" Error
10:13:43 <defcon8> "gentle" <- heh
10:13:57 <pejo> tennin, and maybe http://research.microsoft.com/users/simonpj/Papers/pj-lester-book
10:15:02 <Oejet> defcon8: Does your head hurt yet?
10:15:37 <defcon8> its not that
10:15:42 <defcon8> it doesnt give very practical examples
10:15:49 <defcon8> anyone know a better tutorial?
10:15:53 <defcon8> starts with hello world and stuff
10:16:52 <ricebowl> hah
10:16:57 <ricebowl> I/O is harder than real computation
10:17:02 <ricebowl> not that I/O is that difficult, but anyway
10:17:10 <defcon8> crao :|
10:17:13 <defcon8> crap
10:17:22 <SyntaxNinja> @tutorial
10:17:23 <lambdabot> Unknown command, try @listcommands.
10:17:24 <ricebowl> get an interactive interpreter such as GHCi
10:17:30 <SyntaxNinja> defcon8: "Yet another haskell tutorial"
10:17:32 <SyntaxNinja> @learn
10:17:32 <ricebowl> you can play with it in the interpreter which makes it much easier
10:17:32 <lambdabot> http://www.haskell.org/learning.html
10:17:45 <defcon8> ok
10:17:53 <ricebowl> add a b = a + b -- what do you think this does?
10:17:59 <MarcWeber> Lemmih: Are you still here?
10:18:00 <SyntaxNinja> defcon8: FYI, hello world is "main = putStrLn "hello world"
10:18:14 <defcon8> found it
10:18:30 <tennin> the "gentle introduction" is meant for people experienced with other functional or quasi-functional languages like Lisp, Scheme and ML
10:18:32 <defcon8> right main is the func?
10:18:51 <ricebowl> on that note, why is the comma operator curried for only two arguments? It doesn't make any sense to me.
10:18:57 <ricebowl> @type (,)
10:18:58 <lambdabot> forall b a. a -> b -> (a, b)
10:19:02 <SyntaxNinja> defcon8: ja
10:19:23 <defcon8> it makes me dl the pdf
10:19:43 <tennin> it's only gentle if you meet that criterion
10:19:48 <Lemmih> MarcWeber: Yeah.
10:19:55 <Lemmih> Hi SyntaxNinja.
10:20:02 <defcon8> ahh right redirecting me
10:20:11 <ricebowl> you *could* download John Hughes's notes
10:20:29 <ricebowl> er, I think it's offered in PDF too
10:20:40 <MarcWeber> Would you mind having a gentle look at: http://www.rafb.net/paste/results/cHIj1b59.html ? Perhaps there is a much better way to do this
10:20:52 <SyntaxNinja> hi Lemmih
10:21:17 <tennin> meet that prerequisite?  i can't speak my native language today =(
10:22:31 <tennin> the Peyton-Jones/Lester book looks good, thanks
10:24:18 <Lemmih> MarcWeber: Functions must start with a lower case letter, you need parentheses around (Just x) and the argument 'chars' shadows the top level definition.
10:26:33 <ricebowl> tennin - if it makes you feel better I accidentally started speaking another language, and I wasn't even sure which I was speaking
10:26:36 * ricebowl is sleepy
10:27:10 <MarcWeber> Lemmih: Thanks. It works now. Is this the way to do it? Or are there still some shorter alternatives?
10:32:50 <xerox> Performance question.  Is it better to use a list or a Set of tuples (Int,a) to do heavy computation on an ordered set?
10:37:20 <xerox> @docs Data.Ratio
10:37:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Ratio.html
10:39:24 <_astrolabe> Does haskell have a standard set implementation?
10:40:03 <xerox> Yes
10:40:06 <xerox> @docs Data.Set
10:40:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Set.html
10:40:27 <xerox> What's up with those urls.  It's:
10:40:28 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
10:41:22 <SyntaxNinja> xerox: bizarre. ping JaffaCake
10:45:11 <defcon8> if read "7" is syntactically correct then why isnt show 5*5 or something
10:45:31 <SyntaxNinja> show (5*5)
10:45:40 <SyntaxNinja> @eval show (5*5)
10:45:42 <lambdabot> "25"
10:45:59 <defcon8> nvm
10:46:06 <kombinator> application binds stronger than operators
10:46:27 <kombinator> show 5*5 parses as (show 5)*5
10:46:28 <ricebowl> @eval show (*) 5 5
10:46:29 <lambdabot>   The function `show' is applied to three arguments,
10:46:29 <lambdabot>   but its type `a -> String' has only one
10:46:29 <lambdabot>   In the definition of `xxxx': xxxx = show (*) 5 5
10:46:32 <ricebowl> hm
10:46:35 <ricebowl> @eval show ((*) 5 5)
10:46:37 <lambdabot> "25"
10:46:54 <defcon8> but how can read "5" be ok
10:47:12 <basti_> "5" parses as a value
10:47:22 <SyntaxNinja> @eval show 5
10:47:23 <lambdabot> "5"
10:47:26 <SyntaxNinja> no problem
10:47:34 <basti_> not as quote-5-quote
10:48:09 <defcon8> ahh this is hard
10:48:17 <defcon8> maybe ill have another look when im college or something
10:48:23 <basti_> its not
10:48:27 <basti_> "5" is a single value
10:48:43 <basti_> 5+5 are three values
10:48:53 <defcon8> naah not that
10:48:59 <defcon8> other stuff in the tutorial
10:49:02 <basti_> oh
10:49:05 <basti_> which tutorial?
10:49:15 <defcon8> the yet another one
10:49:20 <basti_> ah
10:49:28 <basti_> what page are you on?
10:49:56 <defcon8> cant remember. closed it
10:50:00 <defcon8> ill look another time
10:50:00 <basti_> ^^
10:50:35 <basti_> don't say "complicated" unti you encounter "that funny IO type" ;)
10:56:44 <dcoutts_> xerox, the lambdabot @docs plugin needs updating. Haddock 0.7 changed the html file names because names with '.' characters in can confuse some web servers.
10:56:58 <xerox> Hmpf!
11:23:50 <SamB> what is the "front panel"?
11:24:21 <franka> Where did you see that?
11:24:30 <integral> looking at an IMSAI?
11:25:03 <franka> What is "IMSAI"?
11:25:46 <integral> the 8080 computer with a programmer's front panel featured in the movie _War Games_.
11:26:37 <dcoutts_> SamB, in ghc it's a gtk gui that gives you stats about the ghc rts when running a program
11:26:55 <dcoutts_> SamB, it may or may not work. It uses gtk 1.2.
11:27:14 <dcoutts_> at one time I was thinking of updating it to use gtk 2.x
11:27:18 <paolino> if I calculate fact 3000 twice it takes same time to do the calculation, is this expected and wanted ?
11:27:26 <dcoutts_> SamB, but I found the whole thing a pain to build
11:27:43 <dcoutts_> paolino, yes and usually.
11:27:46 <luqui> paolino, sure
11:28:01 <luqui> if you put the result in a variable (creating a thunk for it) the second time will be instant
11:28:07 <dcoutts_> paolino, you can give it a name and it will be 'memoised', ie only calcuated once
11:28:28 <dcoutts_> eg: let foo = fact 3000 in (foo, foo)
11:28:57 <paolino> I see
11:28:57 <dcoutts_> paolino, in ghci if you say: let foo = fact 3000
11:29:14 <dcoutts_> then time how long it takes to evaluate foo the first time
11:29:22 <dcoutts_> and then see how long it takes to do it again
11:30:16 * SamB wishes GHC could not compile stuff faster
11:30:48 <SamB> I guess thats what I get for building it without optimisation...
11:31:00 <dcoutts_> SamB, yep :-)
11:31:15 <dcoutts_> you read the hacking notes that JaffaCake pointed at eariler?
11:31:30 <SamB> nope
11:31:37 <SamB> didn't see that
11:31:54 <paolino> now if I have a recursive function on a tree and apply it on the top node, (which implies applying to the children also) and then reapply it to a children the second call do the recursion again. Right?
11:32:32 <franka> Right.
11:32:38 <SamB> paolino: yes, why?
11:33:35 <paolino> Isn't it obvious it's redoing same calculations ?
11:34:29 <SamB> paolino: the compiler isn't going to come up with theorems and try to prove them...
11:35:12 <paolino> well in an imperative situation I would not ask it
11:35:39 <luqui> in an imperative situation you would be managing everything yourself, so you would cache to avoid the recursion
11:35:43 <luqui> as you should in Haskell
11:36:12 <paolino> defenetly for the imperative
11:36:18 <luqui> paolino, however, to get optimal efficiency for this kind of problem, consider using an attribute grammar
11:36:31 <franka> Even in a functional language, there has to be some way to discard recalculate results.  Otherwise memory would only increase.
11:36:33 <dcoutts_> SamB, http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/ghc/HACKING?content-type=text%2Fplain
11:36:36 <franka> +and
11:36:44 <SamB> what I want to know, is *why* would you do that?
11:37:03 <integral> you could just have lots and lots of swap space, so you never need to free memory
11:37:22 <SamB> dcoutts: um, you could have just said "fptools/ghc/HACKING" or "ghc/HACKING in the fptools tree"
11:37:36 <SamB> I did see that when I did a cvs up earlier
11:38:02 <dcoutts_> SamB, ok :-)
11:38:23 <dcoutts_> SamB, that was just the utl JaffaCake said eariler
11:39:05 <paolino> SamB if calculating a node of a tree implies calculating all the subnodes and after a while I need a subnode value I don't want to recalculate it
11:40:31 <paolino> luqui what is an attribute grammar ?
11:40:55 <paolino> haskell way for a descriptor ?
11:41:00 <luqui> it's a method for doing complex computations over trees
11:41:04 <luqui> paolino, yes, sortof, using UUAG
11:41:14 <luqui> it's a preprocessor for haskell
11:41:44 <luqui> you can also do it manually without too much trouble, but I don't recommend it because it becomes very hard to change
11:42:39 <paolino> as I'm a full noobie I will not follow your help, but I will remember that is the way
11:42:48 <SamB> paolino: so keep the results of the computation in a tree
11:42:51 <luqui> okay fair enough
11:43:40 <paolino> SamB that involves some kind of state for a node which fears me
11:44:06 <SamB> paolino: not really
11:44:37 <paolino> at least an "if"
11:44:47 <SamB> however, it would be easier to help you if you would paste your code somewhere
11:45:21 <dcoutts_> paolino, if calculating the tree is expensive then do it once, save it's value and then you can lookup subnodes in the saved version of the tree.
11:45:30 <franka> If you have to do multiple passes over a tree, another thing you can do is to fuse them together into one pass.
11:46:07 <SamB> or try to get the compiler to do it for you ;-)
11:47:31 <luqui> heh, like UUAG does (precisely)
11:47:50 <SamB> only without the fancy name ;-)
11:49:36 <paolino> the tree updating (changing node and leaf context) should be asynchronous to evaluations of nodes , so it's impossible to know which nodes will be evaluated before the tree is abandoned
11:50:34 <SamB> context?
11:50:41 <paolino> position
11:50:59 <SamB> what sort of recursive computation are you performing?
11:51:16 <SamB> how about you just put the code up somewhere?
11:53:31 <paolino> it's in an awful state, I will try to get it right before asking more thanks
11:53:55 <SamB> okay, how do I run the stage-2 compiler in-place?
11:54:03 <SamB> in particular, I want to start ghci in place
11:56:23 <Igloo> ghc/driver/ghci/ghci-inplace
11:56:52 <Igloo> I think that'll default to stage2
11:56:59 <Igloo> Otherwise ghc/compiler/stage2/ghc-inplace --interactive or somesuch should do it
12:00:51 * SamB gets a linker error, rms libraries/base/HSbase.o, makes...
12:02:44 * SamB is glad he doesn't HAVE to rebuild the entire library whenever his stage1 gets relinked
12:11:18 <Nico-> shapr: ping?
12:13:43 * SamB wonders what HSrts.o is for: doesn't GHCi need to link against the rts already?
12:13:55 <lisppaste2> paolino pasted "cached calculations" at http://paste.lisp.org/display/12859
12:14:45 <paolino_> it doesn't work also
12:21:08 <elux> what is the @ operator in haskell.. ie:   splits (x:xs) = sp1 [x] xs where sp1 ys (xs@(x : xs')) = ...
12:21:09 <elux> ?
12:22:39 <basti_> elux: its not an operator
12:22:56 <basti_> it's giving several names to the same thing
12:23:26 <elux> could i leave it out?
12:23:40 <basti_> only if you dont need xs, or don't need x and xs'
12:24:09 <elux> hrmm .. is that because i have the where clause in the function?
12:24:14 <basti_> no
12:24:38 <elux> ok, then when is the case that i should use it?  ..
12:25:04 <basti_> when you have to use the list and it's parts in the same scope
12:25:26 <basti_> (alternatively you could type (x:xs') instead of xs but thats awkward)
12:25:55 <elux> hrmm..
12:26:26 <elux> im still not udnerstanding
12:26:26 <basti_> paolino_: hmmm
12:26:51 <basti_> elux: well using (a:ta) in a definition will "destruct" the list
12:27:03 <dcoutts_> elux, so you could say: where (x:xs') = ...
12:27:06 <paolino_> basti_ it is the parenthesis the error
12:27:07 <basti_> (split it up to head and tail)
12:27:16 <dcoutts_> elux, and that'd bind x to the head and xs' to the tail
12:27:20 <elux> right
12:27:32 <dcoutts_> now you could also do: where xs = ...
12:27:34 <elux> i just dont udnerstand why i need xs@(x:xs')  why cant i just use x:xs'
12:27:40 <dcoutts_> right? and that'd bind xs to the whole thing
12:27:56 <dcoutts_> elux, yes?
12:27:58 <basti_> elux: just for convenience
12:28:05 <dcoutts_> now, suppose you wanted to do both
12:28:07 <elux> but if i omitt it, it doesnt work
12:28:17 <SamB> okay, I'm getting this error when I try to start ghci:
12:28:22 <SamB> Loading package base-1.0 ... linking ... ghc-6.5: /home/naesten/hacking/haskell/fptools/libraries/base/HSbase.o: unknown symbol `currentBoundOSThreadzh_fast'
12:28:24 <SamB> ghc-6.5: unable to load package `base-1.0'
12:28:35 <basti_> paolino_: check the type of "value"
12:29:03 <dcoutts_> elux, supposes you want xs to be bound to the whole list and (x:xs') to be bound to the head and tail.
12:29:10 <basti_> paolino_: no, even average.
12:29:17 <elux> ok
12:29:24 <dcoutts_> elux, to do both of those things in one go you say: where xs@(x:xs') = ...
12:29:30 <elux> ahhhh .. so xs outside of the where has the entire list
12:29:38 <paolino_> basti_ :average xs = sum xs / fromIntegral (length xs)
12:30:16 <dcoutts_> elux, so xs is a name for the wole thing and the other bit after the '@' is the pattern for binding sub-components of the value
12:30:26 <elux> makes a lot more sense
12:30:28 <elux> thank you
12:30:29 <basti_> paolino_: check the type. It's other than you think it is.
12:30:40 <dcoutts_> elux, in this case the sub-components are just the head and tail of the list
12:30:45 <dcoutts_> elux, np
12:31:17 <Nico-> shapr: I wanted to talk about haskell&FPGA; I don't know much about any of both, except things I could read on the net, but I imagine this association might be sooooo nice for number crunching and hpc
12:31:35 <xerox> What is FPGA?
12:31:45 <basti_> field programmable gate array
12:31:48 <Nico-> field programmable gate array
12:31:51 <elux> does anyone know where i can find documentation on prelude functions like uncurry?
12:31:56 <Nico-> oops :)
12:31:57 <basti_> programmable logic ic's
12:31:58 <SamB> its reprogrammable chips
12:32:16 <basti_> elux: the prelude is commented
12:32:26 <SamB> elux: well, you could read the Prelude, or the Haskell report
12:32:38 <basti_> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
12:32:55 <integral> if you're using GHC, the Prelude is in the hierarchical libraries haddocks
12:32:56 <Nico-> xerox: just imagine you have a special-purpose coprocessor for any kind of task you want
12:33:52 <Nico-> shapr: and Lunar^ told me you're into this
12:34:05 <xerox> Nico-: I recently read about morphware based on magnetic ports, something like that?
12:34:21 <Nico-> xerox: yes, morphware is working on this
12:34:30 <xerox> That's way cool!
12:34:35 <Nico-> other ones too
12:34:56 <Nico-> xerox: have a look at the grape-dr project (from google)
12:35:02 <xerox> Will do.
12:36:34 <Nico-> most is in japanese, but they are planning super-super-computing (super-fast connections, fpga, huge distributed storage) and their previous works were fast *and* low-cost
12:37:12 <elux> if i want to trace a function.  i have to first import Debug.Trace .. but how can i trace the evaluation of a function with it now?
12:37:23 <elux> trace somefunction parameters      ?
12:37:55 <Nico-> shapr: so, I need to get away now, but you can leave me messages in the irc awaylog
12:38:05 <Nico-> bye everyone, see you
12:38:38 <elux> or is there a better way to trace the evaluation of some function?
12:44:14 * SamB wishes dons was around
12:44:31 <SamB> anyone know the dynamic loader well?
12:46:44 <dcoutts_> SamB, you can try me or Lemmih
12:47:37 <SamB> dcoutts: do you know anything about where it normally looks for primitive symbols?
12:48:11 <Oejet> elux: I think there are some explanations in the GHC user guide at haskell.org/ghc -> documentation.
12:48:13 <SamB> did you see that error I pasted above?
12:50:46 * SamB wonders if maybe Control.Concurrent got miscompiled, rms the .o and runs make...
12:50:52 <nuffer> http://www.scriptease.be/pastebin/12
12:51:00 <nuffer> I know I can refactor that to be much more concise, but I'm not sure how
12:51:01 <nuffer> any help?
12:51:33 <kombinator> dcoutts_: Is there any documentation for the ProfileViewer example?
12:52:02 <kombinator> dcoutts_: for instance what files it expects
12:52:03 <dcoutts_> SamB, the rts linker symbols that it knows about are listed in Linker.c
12:52:33 <dcoutts_> kombinator, it expects the time profile files, and not the xml format ones
12:52:57 <dcoutts_> kombinator, there's no documentation apart from the source code. :-)
12:53:05 <gour> dcoutts_: today i emerged glade-2.12.1 and saw there is support for gnomedb
12:53:22 <dcoutts_> gour, yes that has been in glade for some time
12:53:43 <gour> dcoutts_: so it would be nice to have bindings for libgda & libgnomedb, what do you think?
12:53:45 <kombinator> dcoutts_: oh, some sort of ghc profiling?
12:53:51 <dcoutts_> kombinator, yes
12:54:44 <dcoutts_> kombinator, maybe I should include an example profile file with the demo, however they are usually rather large. (The ones I was interested in when I wrote the viewer program were several Mb large)
12:55:10 <dcoutts_> gour, it might be nice. I don't think I've got the time however. But you can look into it :-)
12:55:40 <gour> dcoutts: i understand your time is already sold out
12:56:20 <gour> dcoutts_: however, thinking about haskell-gui application with embedded sqlite, it would be nice to have db bindings
12:56:54 <gour> dcoutts_: so, when i become more familiar with haskell, i'd consider to try it
12:57:19 <gour> dcoutts_: i hope there are not too many functions ;)
12:57:25 <kombinator> gour: have you tried hsql?
12:57:50 <gour> kombinator: emerged it, but didn't have time to try it out
12:58:04 <dcoutts_> gour, I frear that libgda probably has many functions
12:58:10 <dcoutts_> frear/fear
12:58:27 <gour> kombinator: is it convenient for embedding sqlite?
12:58:37 <gour> dcoutts_: really?
12:58:54 <dcoutts_> gour, you might need to extend the gtk2hs code generator to understand the libgda types
12:59:24 <SamB> dcoutts: and to think, that was like the one thing that was still correct at the top of primops.txt.pp...
12:59:28 <gour> dcoutts_: that would speed up the process significantly?
12:59:58 <gour> dcoutts_: at least, ch2hs is handy for maintaning bindings in the future
13:00:08 <dcoutts_> gour, yes, making the code generator do more mean less manual tweaking of the output from the code generator
13:00:24 <dcoutts_> gour, the code generator produces c2hs input remember?
13:00:26 <dcoutts_> http://www.gnome-db.org/docs/libgda/libgda-api.html
13:01:37 <gour> dcoutts_: huh, lot of things, at least, i suppose, libgnomedb is not relevant for multi-platform apps, true?
13:02:08 <pesco> How does @pl work?
13:02:18 <dcoutts_> gour, I don't know if it would build on non-unix platforms. It might need porting.
13:02:36 <dcoutts_> pesco, look at the source :-)
13:02:40 <dcoutts_> @version
13:02:41 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
13:02:41 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:02:50 <gour> dcoutts_: but libgda should work?
13:03:15 <dcoutts_> gour, actually looking at libgda it doesn't look too bad. It uses GObjects so the code generator should work with it ok.
13:03:31 <ricebowl> is there a ternary version of (,)?
13:03:36 <ricebowl> @type (,)
13:03:38 <lambdabot> forall b a. a -> b -> (a, b)
13:03:50 <ricebowl> is there some built-in with type a -> b -> c -> (a, b, c)?
13:03:50 <gour> dcoutts_: your words sounds like a nectar for my ears :-)
13:04:09 <ricebowl> or must one build one's own function? :|
13:04:22 <xerox> @type (,,)
13:04:23 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
13:04:27 <xerox> @type (,,,)
13:04:28 <lambdabot> forall d c b a. a -> b -> c -> d -> (a, b, c, d)
13:04:30 <xerox> @type (,,,,)
13:04:31 <lambdabot> forall e d c b a. a -> b -> c -> d -> e -> (a, b, c, d, e)
13:04:35 <xerox> :-)
13:04:55 <kombinator> gour: what do you mean?
13:05:17 <ricebowl> ah nice
13:05:18 <ricebowl> thanks
13:05:24 <ricebowl> that's *exactly* what I was looking for
13:05:25 <kombinator> gour: hsql has support for sqlite
13:05:47 <dcoutts_> gour, libgda has more chance of working on win32 than libgnomedb since gnome-db uses bonobo (though I hear that is getting ported since Evolution ie being ported to win32)
13:05:56 <gour> kombinator: i'm on gentoo, so i just installed hsql yesterday, but my haskell skill are not (yet) developed so i can just try it out :-(
13:06:06 <SamB> ricebowl: thats actually just the constructor for 3-tuples...
13:06:29 <dcoutts_> gour, I think you might find that hsql + gtk2hs is a better approach than libgda+gnome-db+gtk2hs
13:06:37 <SamB> @type (1,,)
13:06:38 <lambdabot> bzzt
13:06:47 <SamB> @type (1,)
13:06:48 <lambdabot> bzzt
13:06:49 <basti_> @type (,,) 1
13:06:50 <lambdabot> forall a b c. (Num a) => b -> c -> (a, b, c)
13:07:04 <SamB> why don't those section right?
13:07:06 <gour> dcoutts_: and what about gnomdb widgets?
13:07:38 <gour> dcoutts_: definitely, hsql + gtk2hs is more easy & simple, less work...
13:07:46 <basti_> SamB: this stuff has to be parsed
13:07:55 <SamB> basti_: true, true!
13:08:13 <SamB> and hugs probably wouldn't implement that if it WAS in the standard...
13:09:28 <kombinator> dcoutts_: do you want me to send config.log in my build report? (I haven't saved the output of configure)
13:09:57 <dcoutts_> gour, yeah using hsql + gtk2hs would mean you'd miss out on the nice widgets provided by gnome-db
13:10:23 <dcoutts_> kombinator, did your build work?
13:10:38 <kombinator> yes
13:10:58 <kombinator> with no problems
13:11:16 <gour> dcoutts_: that's why i was/am thinking about that approach 'cause i envison my application to use database for storing user's data
13:11:17 <dcoutts_> kombinator, I just want to know what platform/OS/CpuArch, ghc version and gtk version
13:11:31 <kombinator> ok
13:12:11 <dcoutts_> kombinator, and if you did anything non-standard with ./configure then that might be interesting too
13:13:00 <dcoutts_> kombinator, the config.log tells you what ./configure flags you used (on the 7th line)
13:14:06 <dcoutts_> gour, the point is you could still use ordinary widgets for displaying data from a database, but you'd miss out on the specialised ones like some of the dialog-style ones.
13:14:57 <dcoutts_> gour, http://www.gnome-db.org/docs/libgnomedb/ch06.html
13:15:03 <gour> dcoutts_: sure, all gtk2hs widgets are on disposal
13:16:00 <gour> dcoutts_: yes, i saw them and must say that gnome is arousing a lot of attraction in my heart recently
13:17:02 <gour> dcoutts_: although after login gnome complains about my keyboard layout (and i need cro chars in teminal)
13:18:43 <dcoutts_> gour, gnome can use any keyboard layout and there is even an applet for switching, it's probably a configuration problem
13:19:48 <gour> dcoutts_: well, i saw keyboard layout, but after login, i'm informed about xklavier, X server or ...bug and advised to provide
13:20:04 <gour> dcoutts_: xprop .. & gconftool .. output
13:20:35 <xerox> dcoutts_: news!! http://googleblog.blogspot.com/2005/10/supporting-open-source.html
13:20:42 <gour> dcoutts_: while on kde everything works out of box. however, new gnome looks very nice
13:26:17 <SamB> somebody *else* appears to have left GHCi in an unusable state...
13:26:49 <dcoutts_> xerox, I found your entry in that list :-)
13:27:05 <xerox> dcoutts_: aha!:D
13:27:14 * xerox is happy
13:28:11 <dcoutts_> xerox, and there you are on the map!
13:28:16 <xerox> Yea, too :D
13:28:27 <dcoutts_> http://code.google.com/soc-map.html
13:29:30 * xerox bounces happily
13:30:26 <dcoutts_> it's interesting, it looks like there were many more European SoC students than US ones
13:31:18 <basti_> SoC?
13:32:01 <kombinator> dcoutts_: are you interested in build report from x86 as well?
13:33:15 <dcoutts_> kombinator, a quick summary, you can just tell me here if you don't want to write another email :-)
13:33:32 <xerox> basti_: The Google Summer of Code program: http://code.google.com/summerofcode.html
13:33:42 <basti_> ahh
13:34:00 <kombinator> dcoutts_: well, I haven't built it yet;)
13:34:10 <dcoutts_> kombinator, ok :-)
13:34:20 * dcoutts_ is going home now
13:34:34 <xerox> Bye bye dcoutts
13:34:37 <xerox> and goodnight people.
13:35:02 <gour> dcoutts_: good night
13:36:52 <kuffis> this code doesn't copy binary files, only text files:
13:36:53 <kuffis> 	textfile <- readFile "file1"
13:36:53 <kuffis> 	writeFile "file2" textfile
13:37:05 <kuffis> what should i do to read binary files in GHC
13:38:40 <Igloo> You need to use openBinary and do hGetContents/hPutStr on the handle yourself
13:38:50 <Igloo> openBinaryFile I mean, I think
13:39:00 <kuffis> thanks, I'll try it
13:42:36 <gour> good night #haskell
13:53:02 <sethk> kuffis, there are also functions to read/write a binary block of data
13:59:40 <kuffis> now it says that IO doesn't export openBinaryFile or hSetBinaryMode, even if the document lists them under System.IO. Am I missing something?
14:02:53 <kuffis> sorry, it was GHC.Handle
14:41:50 <fnord123> Hi all. I'm trying to get Haxr working. Has anyone here used it?
14:53:04 <Cale> fnord123: I've never even seen that before, looks neat
14:53:15 <fnord123> :)
14:53:59 <fnord123> I'm running the example here: http://www.haskell.org/haxr/ but I get the error: b.out: user error (Error calling examples.add: connect: does not exist (Connection refused))
14:54:05 <glguy> I've been using vim to do my haskell "work". Just wondering if any of the editors out there are any more or less suited for haskell development...
14:54:51 <Cale> glguy: the emacs mode is a bit more sophisticated -- yi and hIDE are in the works, and they'll be ideal once they're more usable. :)
14:54:53 <fnord123> I'm using vim
14:55:09 <Cale> I use both vim and emacs to edit Haskell
14:55:36 <glguy> do you use any options other than say expandtab and autoindent in vim?
14:56:00 <Cale> cale@zaphod[~]$ wc -l .vimrc
14:56:00 <Cale> 203 .vimrc
14:56:09 <Cale> heh
14:57:16 <Cale> that file is overkill though
14:57:28 <glguy> awesome, my powerbook just froze!
14:57:54 <glguy> My linux machine restarted today for some reason too
14:58:02 <glguy> must be something in the air
14:58:14 <Cale> humidity?
14:58:16 <shapr> Snow?
14:58:17 <glguy> (but windows just keeps on keeping on) :)
14:58:22 <glguy> :-P snow :)
14:58:23 <Cale> heh
14:58:55 <glguy> I downloaded and booted the looking glass 3d live cd
14:58:56 <shapr> The snow that fell outside my window today is still there.
14:59:19 <glguy> wow, if my 3ghz machine couldn't handle that with a decent video card..
14:59:24 <glguy> thye are doing something way wrong
14:59:45 <glguy> aside from throwing substance to the wind in favor of 3d effects
15:00:52 <fnord123> shapr, where from?
15:00:57 <glguy> Cale, so... you liked the Hitchhiker's Guide?
15:01:06 <Cale> yeah
15:01:19 <glguy> Did you care for the movie after reading the books?
15:01:30 <fnord123> Cale:  whats is your .vimrc??
15:01:31 <Cale> I haven't actually seen the movie
15:01:36 <fnord123> can you pastebin it?
15:02:03 <Cale> Oh, it's based on Tom Gilbert's vimrc
15:02:16 <shapr> fnord123: This snow came from the sky. But seriously folks ... I'm in Boden, Sweden. I'm the northernmost Haskeller.
15:02:38 <shapr> Until I persuade my friend in Tornio to start showing up here.
15:03:41 <SyntaxNinja> shapr!
15:03:44 <shapr> hi!
15:03:44 <musasabi> we had some snow today, but it melted away.
15:03:53 <SyntaxNinja> shapr: ever figure out that wiki problem w/ login?
15:04:12 <shapr> No, but I haven't looked again since last time.
15:04:25 <shapr> The correct solution is to upgrade to Moin 1.3, since 1.4 is getting close...
15:06:34 <glguy> Cale, do you have a good link to demonstrate how to make use of diffArrays
15:07:04 <Cale> http://www.rafb.net/paste/results/I8B3eZ52.html
15:07:08 <Cale> oh
15:07:14 <Cale> that's just my vimrc :)
15:07:53 <glguy> @index newDiffArray
15:07:54 <lambdabot> Data.Array.Diff
15:07:54 <Cale> DiffArrays? You use them just the same as Arrays, the only difference is that you change "Array" in the type to "DiffArray" and import Data.Array.Diff
15:08:02 <Cale> don't use newDiffArray
15:08:04 <glguy> ah
15:08:10 <Cale> that's the low-level interface
15:08:13 <glguy> someone had me looking into that last night
15:08:19 <Cale> you want the IArray interface
15:08:39 <glguy> so instead of typeing: array (1,10) $ zip [1..10] [0,0..]
15:08:52 <glguy> ...
15:09:20 <glguy> i don't do anything different and change the type of the function?
15:09:24 <glguy> to accept diff arrays?
15:09:27 <musasabi> yes.
15:09:29 <Cale> right
15:09:35 <glguy> bah!
15:09:43 <glguy> you need to be online more then :)
15:09:48 <Cale> heh
15:10:01 <musasabi> Or better yet you profile it with both and then decide.
15:10:16 <Cale> sorry that the docs aren't clearer on this point
15:10:26 <glguy> I've been profiling it by saying: time ./myexecutable
15:10:32 <glguy> is there a better way :)
15:11:03 <musasabi> you can use GHC profiling, but that works fine too if you are just testing whether a specific change makes sense.
15:14:06 <glguy> well... it's 1/2 the speed of the C++ solution
15:14:11 <glguy> but that's probably not too bad, right?
15:14:24 <glguy> it's a lot prettier than the C++ solution tho :)
15:16:51 <Cale> what do the arrays contain?
15:17:00 <glguy> one contains a matrix
15:17:05 <glguy> and one contains the vector
15:17:13 <glguy> this is the gauss seidel thing I was asking about earlier
15:17:16 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Unboxed.html
15:17:44 <glguy> they contain doubles
15:18:02 <glguy> so... UDiffArray ? or just UArray
15:18:06 <Cale> You could try a UArray Double
15:18:11 <glguy> ok
15:18:30 <Cale> Oh, there's also DiffUArray
15:18:53 <musasabi> STUArray + unsafeRead/Write is the fastest there is, but that is not very pretty.
15:19:04 <glguy> UArray is single dimensioned only?
15:19:43 <glguy> @index UArray
15:19:44 <lambdabot> Data.Array.Unboxed
15:20:00 <glguy> never mind
15:20:47 <glguy> @index UDiffArray
15:20:48 <lambdabot> bzzt
15:20:49 <Cale> oh, hadn't thought about that, yeah it looks like it doesn't have instances for pair types
15:20:59 <glguy> @index DiffUArray
15:20:59 <lambdabot> Data.Array.Diff
15:22:16 <_astrolabe> Does anyone know of a more efficient replacement for floodfill?
15:22:18 <glguy> for what I'm doing, the overhead on the diff array is too much
15:22:26 <glguy> but UArray does show a speed up
15:22:32 <glguy> so, thanks for the pointer :)
15:22:54 <Cale> musasabi: At the point you're willing to go to unsafeRead/Write, wouldn't some kind of MArray be better?
15:23:16 <musasabi> Cale: STUArray is an MArray - the fastest kind there is afaik.
15:23:17 <Cale> oh, I suppose STUArrays are :)
15:23:18 <glguy> #define MArray
15:23:30 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
15:23:39 <musasabi> glguy: MArray is the interface to mutable arrays.
15:23:54 <Cale> why the unsafe versions?
15:23:56 <musasabi> glguy: there are STArrays, STUArrays, IOArrays and IOUArrays.
15:24:10 <SyntaxNinja> xerox: alive?
15:24:20 <musasabi> glguy: U for unboxed. The IO-versions are implemented on top of the ST ones.
15:24:44 <musasabi> Cale: because the bound check cost can be nasty on occasions.
15:24:55 <SyntaxNinja> xerox: congrats: http://code.google.com/soc-results.html
15:25:25 <fnord123> 404
15:25:28 <SyntaxNinja> xerox: so did you switch to cvs? : http://sourceforge.net/cvs/?group_id=49207
15:25:30 <glguy> worked for me
15:25:35 <glguy> 200
15:25:49 * glguy thinks 200 is the success signal
15:25:56 <SyntaxNinja> wfm
15:26:06 <fnord123> oh it worked on a refresh
15:26:19 <fnord123> google's problems with 404s are documented somewhere
15:26:24 <fnord123> ho ho i run into it all the time
15:26:30 <Cale> SyntaxNinja: gtk2hs has cvs and darcs
15:27:33 <Cale> hmm, unsafeRead/Write aren't in the documentation
15:28:34 <SyntaxNinja> Cale: IC
15:31:15 <Julian> Hi folks
15:31:19 <Julian> hi lambdabot
15:31:27 <Julian> ;)
15:31:35 <Cale> hi Julian
15:32:04 <Julian> @eval (\x -> "Hi " ++ x) "julian!"
15:32:05 <lambdabot> "Hi julian!"
15:38:13 <glguy> If I wanted to build an infinite sequence that builds off of the previous element, I should be able to write: myseq x = x : map aux $ myseq x
15:38:14 <glguy> right?
15:38:42 <integral> @type unfold . Just
15:38:44 <lambdabot> bzzt
15:38:56 <integral> @type Data.List.unfold . Just
15:38:57 <lambdabot> bzzt
15:38:59 <glguy> ah, the unfold pattern
15:39:01 <glguy> @index unfold
15:39:02 <lambdabot> bzzt
15:39:04 <integral> @index unfoldl
15:39:04 <lambdabot> bzzt
15:39:07 <glguy> :)
15:39:29 <integral> @type Data.List.unfoldr . Just
15:39:31 <lambdabot> bzzt
15:39:43 <integral> @type Data.List.unfoldr . Data.Maybe.Just
15:39:45 <lambdabot> bzzt
15:40:36 <glguy> sweet , it worked
15:40:37 <integral> @pl \f -> unfoldr (Just . f)
15:40:37 <lambdabot> unfoldr . (Just .)
15:40:40 <integral> ah
15:41:01 <Julian> @type foldr
15:41:02 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
15:44:10 <luqui> how come I can do: "(const . const) [] 1 2", but I can't do "sq f = f . f; sq const [] 1 2" ?
15:44:35 <integral> monomorphism?
15:44:43 <luqui> ?
15:44:53 <integral> @type \f -> f . f
15:44:54 <musasabi> luqui: add type signatures.
15:44:54 <lambdabot> forall c. (c -> c) -> c -> c
15:45:52 <luqui> yeah, I mean, why does it infer that type signature?
15:46:23 <integral> @type (.)
15:46:25 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
15:46:48 <luqui> musasabi, what type signature should I add...
15:46:51 <integral> c unifies with a there
15:47:12 <musasabi> luqui: when you add it you see what causes the problem.
15:47:22 <luqui> ahh, i understand
15:47:28 <luqui> but I still don't understand
15:47:43 <luqui> I guess the more appropriate question is:
15:47:50 <luqui> why *can* I write (const . const) [] 1 2
15:47:58 <luqui> ohhh
15:48:10 <luqui> because the instance of const on the left is getting different types than the instance on the right
15:48:16 <luqui> which can't happen when you pass it into a function
15:48:28 <fnord123> anyone joined the channel lately who's given haxr a go?
15:53:59 <Lemmih_> fnord123: I've used haxr (XmlRpc) before.
15:56:08 <fnord123> oh great. I have some code running but I think I've configured the paths wrong or something
15:56:15 <fnord123> I can't seem to connect to my running server....
15:57:03 <fnord123> http://localhost/~mylogin/cgi-bin/a.out ... can't connect to that (though the a.out is running from ~mylogin/cgi-bin/
15:59:31 <fnord123> any thoughts or links to better documentation that what can be found at haskell.org/haxr?
16:08:05 <Lemmih> Nope.
16:10:46 <JohnMeacham> Yay! jhc is now consistantly producing faster results than ghc -O.
16:11:02 <musasabi> ^_^
16:11:37 <Muad_Dibler> jhc being?
16:11:50 <SamB> Muad_Dibber: take a wild guess
16:12:07 <luqui> haskell compiler the hut
16:12:18 <pesco> the hut?
16:12:18 <SamB> JohnMeacham: does it support the mtl?
16:12:23 <Muad_Dibler> hc part i can guess :P
16:12:28 <Igloo> JohnMeacham: Is there a page showing how much of the language is implemented somewhere?
16:12:30 <Muad_Dibler> but what stands the j for i meant
16:12:31 <SamB> hutt
16:12:34 <SamB> not hut, hutt
16:12:39 <luqui> heh
16:12:45 * luqui isn't a star wars geek
16:12:54 <JohnMeacham> Just haskell 98.
16:12:57 <luqui> but good to know anyway
16:13:02 <pesco> JohnMeacham: Any progress on the memory front?
16:13:24 <JohnMeacham> pesco: just some incremental progress. nothing groundbreaking.
16:13:39 <Igloo> JohnMeacham: Do you have plans to extend it to common extensions (MPTCs, fundeps etc)?
16:14:17 <JohnMeacham> Igloo: yup. eventually. perhasp when haskell 06 comes together so I have something to shoot for extension wise.
16:14:22 <pesco> JohnMeacham: Hm, so you're still searching the solution space, or is there a particular plan on how to do it?
16:14:38 <Igloo> OK, thanks
16:15:42 <JohnMeacham> pesco: Yeah, I have a fairly good idea how to do monadic regions the way I want, and it would be straightforward (ish) to add a garbage collector. I am not sure if a hybrid or a full region inference method will be best though.
16:16:04 <JohnMeacham> in any case, it is fairly indepedent of the rest of the compiler so it is entirly possible there will be multiple options.
16:16:13 <pesco> JohnMeacham: Hm, I don't suppose it's possible (yet) to compile only certain modules with jhc and link them into some GHC executable, i.e. for optimizing critical parts?
16:16:22 <pesco> JohnMeacham: I see.
16:16:58 <fnord123> so Lemmih, where do you run your server from
16:17:19 <pesco> JohnMeacham: I haven't gotten around to read enough of how region inference works (let alone in your particular setting) to fully understand the connections.
16:18:41 <pesco> (Or garbage collectors for that matter...)
16:18:44 <JohnMeacham> pesco: no. unless the interface could be specified in the FFI.
16:19:12 <pesco> Right. :/ That would be a useful application though.
16:20:27 <pesco> But I guess the internals are so different to make it at least very complicated, right?
16:21:51 <fnord123> maybe i need a webserver to run as well. :-/
16:26:12 <JohnMeacham> pesco: yeah. none of the primitives would match up. it actually wouldn't be too bad since jhc has no runtime to get entangled with ghc's one.
16:27:27 <JohnMeacham> pesco: but certainly not trivial. creating updatable thunks in jhc that can be called in ghc should be possible, but the other way around would be.. difficult. class instances likely would not be able to cross the boundry too.
16:27:48 <Philippa> GHC<->JHC via FFI, duh ;-)
16:28:25 <JohnMeacham> Yeah, a "portable" hs-plugins like thing that only allowed strict interfaces via the FFI might be useful.
16:29:01 <JohnMeacham> then we can create portable (but somewhat limited) modules for haskell programs with any compiler/language.
16:29:02 <Philippa> it'd be cool to have a tool that autogenerated FFI imports for GHC/JHC modules that met certain restrictions
16:29:34 <musasabi> perhaps one could use TH on the GHC side...
16:29:36 <Philippa> "we intend to compile this parser module with JHC 'cos it does cool things with parsec code, but as the interface is just a parseThis function we can expose that fine"
16:30:23 <Philippa> I'd kinda like to have an option to sit down with JHC's optimisation passes and the intermediate code and run further passes by hand to beat code into shape
16:30:42 <JohnMeacham> Yeah. it would probably be possible to pickle up arbitrary haskell datatypes using Binary. it would just be like everything was deepseq'ed at the boundry.
16:30:59 <JohnMeacham> PhilippaQ me too.
16:31:15 <Philippa> strictness-as-type-annotation would be a good thing generally, IMO
16:31:21 <Philippa> I mean, it *is* type info, dammit!
16:34:30 <dcoutts> Philippa, in Clean strictness is part of the type, however that design decision tends to cause problems I believe
16:34:42 <dcoutts> since you end up with the 2^n variants problem
16:34:43 <Lemmih> fnord123: I've only used XmlRpc from an Apache server.
16:35:32 <dcoutts> if each function arg can be annotated strict or not, and each variant is a different type then there are 2^n variants
16:36:04 <fnord123> yeah I just set mine up.
16:36:15 <fnord123> i get a 404 now instead of connection refused
16:36:18 <fnord123> delightful! :)
16:36:49 <dcoutts> phb, so in practice apparently the Clean folk don't use the '!' annotations as much as they could. I think it's better to leave it just as info for the compiler.
16:36:52 <JohnMeacham> one might argue it already is part of the type when you use explicit unboxed tuples.
16:37:03 <dcoutts> phb, err I meant Philippa, sorry
16:37:07 <JohnMeacham> or unboxed anythings actually.
16:37:22 <dcoutts> JohnMeacham, yes in that case it is.
16:37:29 <wchogg> Dumb question, but what does "unboxed" really mean?
16:37:56 <JohnMeacham> and the 2^n explosion of workers was mentioned in the papers too :)
16:38:12 <dcoutts> JohnMeacham, which is why the unbox pragma is generally preferable since that tells the complier to unbox when it can and re-box when necessary.
16:38:35 <dcoutts> where as if you do it manually then you've got to do the reboxing manually
16:39:57 <JohnMeacham> dcoutts: yeah, in jhc I plan on having it always unbox strict fields. definitly any that correspond to an underlying C type. not sure about product types in general. heap analysis through data stuctures loses a lot of precision and this should help with that some.
16:41:22 <Philippa> dcoutts: I'd treat strictness annotations as something with a flavour of subtyping on, certainly
16:41:22 <dcoutts> JohnMeacham, the slight danger in always unboxing is if a value has to be re-boxed frequently to be passed to polymorphic functions.
16:42:16 <dcoutts> JohnMeacham, so in some sections it can be a saving to keep the boxed representation
16:42:48 <dcoutts> JohnMeacham, I wonder how much you could do with profiling feedback to the complier
16:42:52 <Philippa> in fact, unless you had an "always re-evaluate" annotation as well I can't think of any situation where you couldn't pass a value as strict by evaluating it first, or say a strict value isn't good as a not-known-strict one
16:43:47 <dcoutts> JohnMeacham, eg gcc has this program for generating various statistics from a run of the program which it can then use to direct optimisations like branch predistion and loop unroling.
16:43:47 <Julian> guys, you can join to the haskell girls channel in #Haskell-Girls
16:44:07 <Julian> :-)
16:44:23 <Julian> the channel inhabitation problem
16:44:55 <Philippa> you mean I'm not the only one eligible? :-)
16:45:05 <ozone_> dcoutts: if you do cross-module optimisation, i think you can unbox everything
16:45:10 <ozone_> at least, that's what intuition tells me...
16:45:35 <int-e> Philippa: 'guys, ...'
16:45:41 <dcoutts> ozone, only if you expand/inline/specialise polymorphic functions that use the unboxed values
16:45:49 * int-e wonders
16:45:52 <Philippa> int-e: "guys" is pretty much gender-neutral these days
16:45:55 <ozone> dcoutts: yep
16:46:23 <int-e> Philippa: ah ok. thanks.
16:46:45 <dcoutts> Philippa, yes I guess the subtyping heiracharcy would follow the information heirarchy, that is how much do you know about the value. eg is it known to be already evaluated.
16:46:57 <JohnMeacham> dcoutts: yeah, but I think it is easier to just always unbox and improve my polymorphic function specialization than figure out some algorithm to decide something selectivly.
16:47:15 <Julian> my friend SusyQ
16:47:26 <SusyQ> hi Julian
16:47:36 <SusyQ> How R U ??
16:47:36 <JohnMeacham> dcoutts: but the statistics thing is a good idea that I'd like to explore sometime.
16:47:52 <Julian> @eval (\x -> "Hi " ++ x) "SusyQ
16:47:54 <lambdabot>  lexical error in string/character literal
16:48:08 <Julian> @eval (\x -> "Hi " ++ x) "SusyQ"
16:48:10 <lambdabot> "Hi SusyQ"
16:48:17 <dcoutts> JohnMeacham, I'm thinking more generally. For many parts of a program inlining and other agressive optimisations are a loss since it bloats code without giving a performance beniefit since it's not in the 'hot' 10% of the program.
16:48:39 <dcoutts> JohnMeacham, right, so it allow you to target the optimisations better.
16:49:17 <dcoutts> JohnMeacham, it'd give a more accurate cost model to use when deciding what level of various optimisations to apply in each bit of code.
16:49:21 <SusyQ> @eval (\x -> "How" ++ "R"++x) "You"
16:49:22 <lambdabot> "HowRYou"
16:54:41 <wchogg> Out of curiousity, but does anyone here try to use haskell for scientific computing?
16:54:52 <Julian> someone know a channel about Coq  ?
16:55:10 <ricebowl> Julian - mejor que no hablaras contigo...
16:55:40 <ricebowl> right?
16:55:58 <Julian> ricebowl: uhhh?
16:56:35 <ricebowl> mira vos y "la mujer" tienen la misma direccin ;)
16:56:55 <ricebowl> oh well, it's not important
16:57:02 <Julian> yea man
16:57:08 <Julian> NAT
16:57:54 <Julian> someone know a Coq channel??
17:00:41 <SusyQ> Haskell-Girls Rulesssss
17:11:17 <Julian> I love Miranda
17:11:21 <Julian> and the lolo guitar
17:11:29 <Julian> haha :-)
17:12:26 <ulfdoz> Prima Idee, dann reicht's vielleicht auch noch fr 'ne "kleine" Sun.
17:12:29 <ulfdoz> ECHAN, sorry
17:20:42 <SusyQ> join to the Haskell-Girls channel... !!!!!!!
17:27:26 <Julian> @lambda (\x -> x x) (\x -> x x)
17:27:31 <lambdabot> out of fuel - use @resume to continue
17:27:45 <Julian> @resume
17:27:49 <lambdabot> out of fuel - use @resume to continue
17:29:38 <Julian> @where lambdabot
17:29:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:37:57 <dons> wow, we had 200 #haskellers last night
17:38:11 <Julian> wow
17:39:03 <SamB> @fact lambdabot
17:39:03 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female..
17:40:00 <ski_> wchogg : possibly http://users.info.unicaen.fr/~karczma/arpap/ could be of some interest
17:42:41 <dcoutts> ibid, how did it go today?
17:42:56 <ibid> dcoutts: okat
17:43:24 <ibid> dcoutts: i was just starting to go to bed, i've been writing the instructions for our one and only hands-on session
17:43:50 <dcoutts> ibid, I'm finnishing off practical instructions too :-)
17:43:54 <ibid> dcoutts: too bad you don't know finnish, would be fun to let you read them :)
17:44:06 <dcoutts> ibid, heh heh :-) yeah
17:44:19 <ibid> but, summary:
17:44:20 <dons> hey br1, hey marcot :)
17:44:38 <br1> hello
17:44:38 <int80_h> hi, I just sent mail to the haskell mailing list if anyone cares to address the problem I present :)
17:44:43 <dcoutts> ibid, I've got to go over the practical description with the lecturer and other demonstrators tomorrow. So I'm up late adding the finnishing touches.
17:44:45 <ibid> 1. compile and run all the programs we made in the first lecture
17:44:59 <ibid> 2. test them in GHCi
17:45:17 <int80_h> or, would it be okay to post the mail to the website
17:45:19 <ibid> 3. write a program that calculates your age given your birth year
17:45:42 <dcoutts> I'm having my students use ghc to produce a standalone program when it comes to the final gui bit.
17:45:46 <ibid> 4. write a program that calculates the size of a room given its basic measurements
17:46:41 <ibid> 5. write a program that reads in a date and outputs it +1day
17:47:09 <ibid> 6. write a simple text-based menu from which the user can select 2-4
17:47:30 <dcoutts> ibid, I should send you my practical description/questions when I'm finnished writing it.
17:47:55 <ibid> 7. modify bouncing ball to include gravity
17:48:22 <ibid> dcoutts: i'm hoping these are not too much and not too little :)
17:48:28 <dcoutts> the one I'm doing involves a bit of list/string processing and some recursive functions using a stack and a bit of trigenometry
17:48:38 <dcoutts> ibid, yeah, that's a tricky thing to judge
17:48:43 <Julian> someone know a channel about Coq ??
17:49:07 <ibid> dcoutts: i'm trying to overshoot so that nobody has too little to do :) it doesn't matter so much if they don't do all of them
17:49:19 <ski_> Julian : #coq ?
17:49:40 <dcoutts> ibid, the one I'm doing has loads of opportunities for optional/extension questions.
17:49:53 <lisppaste2> int80_h pasted "exercise problem" at http://paste.lisp.org/display/12868
17:50:00 <ibid> dcoutts: the idea here is just to become comfortable with the tools, the programming exercises are hopefully not too hard for the students :)
17:50:01 <dcoutts> it's pretty open ended
17:50:34 <Julian> ski_: thx
17:50:46 <ibid> but, i have a grand total of two hours left for sleeping, so i need to go and make use of them, bbl :)
17:50:49 <dcoutts> ibid, yeah, here too. It's only the first term for the students with little previous programming experience
17:51:02 <ibid> dcoutts: how's the announcement? :)
17:51:23 <dcoutts> ibid, I'm going to wait 'til I've started my course too. :-)
17:51:28 <ibid> heh
17:51:30 <ibid> ok
17:51:33 <ibid> sleep, bbl
17:51:39 <int80_h> nighty nighty
17:51:40 <dcoutts> ibid, g'night
17:53:10 <int80_h> dcoutts do you have a moment to look at my post?
17:56:49 <int80_h> anyone?
17:57:42 <dcoutts> int80_h, what's that?
17:59:11 <int80_h> oh hold on
17:59:22 * dcoutts holds on
17:59:24 <int80_h> http://paste.lisp.org/display/12868
17:59:28 <int80_h> there it is :)
17:59:39 <int80_h> I posted this to the haskell mailing list as well, is that poor form?
18:01:05 <dcoutts> int80_h, no, it's not bad form
18:01:24 <dcoutts> "illegal
18:01:24 <dcoutts>  instruction" error ? that's not good.
18:01:28 <dcoutts> sounds like a bug in hugs
18:01:34 * dcoutts tries the code in ghci
18:01:51 <dons> yeah!
18:02:00 <dons> doesn't sound like a logical error, imo
18:02:00 <dcoutts> dons, ?
18:02:03 <int80_h> ah never thought of that
18:02:22 <dons> illegal instruction usually == much badness
18:02:35 * dcoutts notices that dons is feeling enthusastic
18:02:39 <marcot> But there's also an logical error.
18:02:45 <dons> coffee!!
18:02:45 <marcot> I replyed your e-mail.
18:02:47 <int80_h> marcot, please elucidate
18:02:50 <int80_h> thanks :)
18:03:40 <dons> I wonder how much fun a lambdabot-on-a-disk ubuntu style cd would be :}
18:03:59 <int80_h> thanks ,arcot, I can't use map yet
18:04:09 <int80_h> I'm trying to stick with the order in the book
18:04:10 <marcot> int80_h: ok..
18:04:16 <dons> @eval map (+1) [1..10]
18:04:22 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
18:04:25 <Julian> ski_: join us dude!
18:04:28 <dons> @eval map toUpper "haskell"
18:04:30 <lambdabot> "HASKELL"
18:04:33 <marcot> int80_h: do you think that the other solution is better?
18:04:35 <int80_h> nor can I use where, but I think I'll use your second example
18:04:48 <int80_h> yeah I think I can do something with the second
18:04:51 <ski_> "illegal instruction" sound like a bug
18:05:01 <marcot> #let f 0 = 0
18:05:03 <int80_h> I have some questions about it
18:05:04 <marcot> @let f 0 = 0
18:05:05 <lambdabot> Unknown command, try @listcommands.
18:05:13 <ski_> Julian : but i already thanked you
18:05:16 <Julian> @eval map putStr ["Hello"," ","world"]
18:05:17 <lambdabot> No IO allowed
18:05:39 <dons> hello SusyQ, yet another .ar hacker!
18:05:40 <dons> @map
18:05:41 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
18:05:46 <marcot> int80_h: about the second one?
18:05:48 <dons> you should add your details :)
18:05:53 <Julian> dons: SusyQ is my friend
18:05:57 <dons> ah!
18:06:06 <SusyQ> hi Donss
18:06:08 <SusyQ> yeahh
18:06:12 <dons> welcome then :)
18:06:18 <SusyQ> thx
18:06:28 <ski_> int80_h : in any case, your code in 'maxOverf' looks weird
18:07:00 <Julian> dons: where r u from?
18:07:06 <dons> oh Julian , you're not on the map either! you should add your details too
18:07:11 <dons> check the map :)
18:07:13 <int80_h> yeah marcot, I was just looking it over
18:07:23 <Julian> yea
18:07:24 <int80_h> this is what I think the exercise is asking for
18:07:27 <Julian> I dont know
18:07:31 <int80_h> say f 9 returns 8
18:08:07 <int80_h> if I do this maxOverf 9, I will get 9 returned
18:08:19 <dons> Julian, I'm in .au
18:08:19 <ndm> dons, hoogle3 is nearing completion
18:08:24 <int80_h> say f 9 returns 10
18:08:28 <dcoutts> ndm, good news
18:08:33 <Igloo> Anyone know why hs-plugins depends on mzscheme?
18:08:36 <int80_h> if I do maxOverf 9 I will get 10 returned
18:08:46 <dons> Igloo, oh fun fun :p
18:08:46 <ski_> int80_h : i interpret the exercise as you should return the maximum of the values  f 0,f 1,...,f n
18:08:49 <int80_h> do I have that part right?
18:08:49 <marcot> int80_h: whi this?
18:08:57 <Igloo> dons?
18:09:03 <int80_h> ski_ yes given the definition of f,
18:09:10 <ndm> http://www-users.cs.york.ac.uk/~ndm/cgi-bin/hoogle3-cgi (strictly as an alpha)
18:09:14 * ski_ refrains from writing that pseudocode in haskell
18:09:16 <dons> Igloo? ??
18:09:18 <Julian> @type putStr
18:09:20 <lambdabot> String -> IO ()
18:09:21 <ski_> int80_h : sure
18:09:26 <int80_h> if n is bigger than f n, the n gets returned
18:09:33 <int80_h> otherwise f n gets returned
18:09:37 <dcoutts> ndm, nice looking site :-)
18:09:38 <Igloo> dons: I don't understand "oh fun fun :p"?
18:09:38 <dons> Igloo: mzscheme -- I'm confused.
18:09:43 <Julian> @type map putStr ["Hello", " ", "world"]
18:09:45 <lambdabot> [IO ()]
18:09:54 <dons> oh, I assumed you were making some joke. I guess not  :S
18:09:58 <Igloo> http://buildd.debian.org/fetch.php?&pkg=hs-plugins&ver=0.9.10-1&arch=ia64&stamp=1130279206&file=log&as=raw
18:10:06 <dons> oh sigh.
18:10:07 <ndm> dcoutts, i probably spent as much time on the looks as i did on the code :)
18:10:18 <int80_h> if I haven't gotten that part right I need to get clarification
18:10:20 <ndm> dons, how easy is it for you to upgrade the hoogle in lamdabot
18:10:21 <int-e> @type sequence
18:10:22 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
18:10:23 <Igloo> http://buildd.debian.org/fetch.php?&pkg=hs-plugins&ver=0.9.10-1&arch=hppa&stamp=1130280033&file=log&as=raw is a fascinating looking failure, too
18:10:24 <dons> ah, I see.
18:10:27 <marcot> then is just: maxOverf m { | f m > m = f m; | otherwise = m }
18:10:32 <Igloo> ld -x -r -o HSaltdata.o AltData/Dynamic.o AltData/Typeable.o
18:10:33 <Igloo> <stdin>:1:35: error: operator '&&' has no right operand
18:10:38 <dons> someone wanted to bulid the website docs perhaps?
18:10:42 <ndm> and would you prefer to move to a proper plugin, rather than a console shell call
18:10:46 <dcoutts> ndm, appart from the links to the functions bein broken it looks good. :-)
18:10:48 <Igloo> Ah, that's probably it
18:10:48 <dons> which uses tex2page, which is a scheme program??
18:10:48 <int80_h> and, if my code looks wierd, I'm not using the full language. But rather the subset I have seen from the first four chapters
18:11:02 <ndm> dcoutts, it uses hoodoc, a program i have yet to write...
18:11:10 <int80_h> marcot, is that not what I have?
18:11:10 <dons> updating hoogle is easy. a plugin is even better
18:11:12 <Julian> #Haskell-Girls
18:11:18 <dons> (as it means lambdabot is more self-contained)
18:11:27 <marcot> no.
18:11:32 <dcoutts> ndm, so how do I add extra packages for hoogle to search ?
18:11:33 <marcot>       | otherwise = (maxOverf m-1)
18:11:37 <Julian> @help
18:11:38 <lambdabot>  @help <command> - ask for help for <command>
18:11:38 <marcot> That's wht you have.
18:11:39 <int80_h> I better compare
18:11:41 <dons> Iglolo, they shouldn't really bother building the website docs, I think
18:11:52 <ndm> dcoutts, you can't - but its pretty easy for me to
18:11:58 <Julian> @help type
18:11:59 <lambdabot>  @type: return the type of a value
18:12:03 <int80_h> oh marcot it has to be recursive, where f 0, f 1...f n gets compared to n
18:12:10 <Julian> wow, verbose
18:12:13 <ndm> if you checkout hte cvs, you can generate hoogle files from haskell
18:12:25 <dcoutts> ndm, the Gtk2Hs docs are pretty large and a pain to search through
18:12:25 <ndm> and then you can run hoogle at the command line, with additional packages
18:12:25 <Igloo> dons: It's nice to have HTML documentation available, but we do generally have a problem when it's only buildable on some arches
18:12:40 <ndm> dcoutts, eventually hoogle3 will have them
18:12:42 <Igloo> Although making haddock portable would fix most instances
18:12:46 <dons> ah, and you're not using the haddockised/cabalised hs-plugins yet.
18:12:50 <dons> I should realise that soon.
18:12:53 <ndm> all the code support is there, its elmost entirely front end issues
18:13:27 <dons> ndm, do you want to write the plugin (or I guess I should :)
18:13:31 <Julian> my friend is grogui without breath gas
18:13:38 <ndm> i plan to strip out OpenGL from the base (it really doesn't belong!), then give the searcher the option to add more packages, i.e. OpenGL and Gtk2Hs
18:13:38 <dcoutts> ndm, cool. So what would be the best way to organise that? Run an instance of hoogle on the Gtk2Hs site? or have the 'centeral' hoogle index the latest version of the Gtk2Hs docs?
18:13:53 <ndm> dons, would you rather a command line version (as now), or a proper plugin?
18:14:00 <int80_h> dcoutts, did you run my code in ghci?
18:14:06 <dcoutts> int80_h, yes
18:14:13 <int80_h> did it work?
18:14:18 <ndm> dcoutts, that i have no idea on at all  - what suits you?
18:14:18 <dcoutts> int80_h, Non-exhaustive patterns in function f
18:14:26 <dons> ndm, I'd like to perhaps write a plugin module in lambdabot that 'imports Hoogle.Main' or some such
18:14:28 <dcoutts> ndm, I'm not sure :-)
18:14:33 <dons> if hoogle could come as a cabalised lib
18:14:43 <ndm> dons, it will do, pretty soon
18:14:54 <dcoutts> dons, ndm, then we could do a lambdabot and a hIDE plugin. :-)
18:14:58 <int80_h> dcoutts, which means? oh I know...hold on
18:14:59 <ndm> dons, really easy to do that now - it has a proper interface that should work
18:15:12 <dons> ok, cool. let me  know when that happens, and I'll write a plugin interface. which we'd also want for hIDE, as dcoutts says
18:15:14 <ski_> int80_h : as i understand it, you shouldn't be comparing the input to 'f' with the output from 'f'
18:15:18 <Julian> the beast pop
18:15:19 <dcoutts> int80_h, it's because your f is not defined for all inputs.
18:15:41 <int80_h> ah I just changed that
18:15:45 <dons> ndm, where hoogle3 src? is it sourceforge/cvs?
18:15:46 <ndm> dcoutts, i figured things like Gtk2Hs would be on the main hoogle site, but things like pugs (which are more a project than a library) would be on a separate Pugs only hoogle
18:15:48 <ski_> int80_h : rather, you should compare outputs for differing inputs (0 .. n)
18:15:51 <dons> or is it darcs... fingers crossed..
18:15:52 <ndm> dons, yep
18:15:56 <int80_h> integers 1...5 have been defined for f
18:15:57 <dons> cvs?
18:15:58 <ndm> sorry no darcs yet
18:16:00 <int80_h> now I will try again
18:16:01 <ndm> give me time...
18:16:19 <ndm> shapr keeps prodding me towards darcs...
18:16:29 <dons> so do I!
18:16:35 <ndm> i know
18:16:35 <dcoutts> ndm, ok, then we'd have the Gtk2Hs documentation page link to your hoogle page with optional Gtk2Hs indexing turned on.
18:16:53 <Cale> marcot: did you see the reply to your message on the list?
18:16:54 <ndm> i want yhc to move to darcs first, and experiment with that for a few weeks
18:17:01 <dons> ah, good idea.
18:17:04 <ndm> then i'll move hoogle, once i have a better feel for darcs
18:17:21 <ndm> dcoutts, sounds good :)
18:19:14 <int80_h> wahhh...it still fails when f n > n
18:19:32 <int80_h> I've defined f n through five
18:19:49 * ski_ still don't understand why you compare 'f n' to 'n'
18:19:57 <int80_h> because I need the max
18:20:18 <syntaxfree> you know the Caesar cyper, right? ROT13 is a special case of it.
18:20:21 <ski_> so why compare input to output, when you need max of outputs ?
18:20:25 <int80_h> how can I decide which has the larger value if I don't compare?
18:20:44 <int80_h> ski, I think I might not understand what the problem that needs to be solved is
18:20:54 <syntaxfree> So I picked up a huge chunk of english text, and determine the relative letter frequencies.
18:20:56 <ski_> i was just thinking actually comparing 'f 0' and 'f 1' etc might help
18:21:05 <int80_h> say I wasn't using fn to produce an output
18:21:13 <int80_h> say I was using an integer m
18:21:17 <syntaxfree> then, for an arbitrary word, I define a score function that ponders each  letter by its expected frequency.
18:21:29 <dons> TotaX, hi! another .ar haskeller?
18:21:40 <int80_h> if I wanted to find the larger of m and n, would I not compare them. How would that be different from comparing the output of f n to n?
18:21:51 <syntaxfree> so, to decipher a Caesar-encrypted text, I run the Caesar for n=1..26, and use the score variable on each alternative.
18:22:03 <syntaxfree> and I choose the one with the largest score. It works!
18:22:15 <syntaxfree> I came up with that in the last 10 minutes, and I'm really really happy.
18:22:21 <marcot> Cale: no..
18:22:44 <ski_> int80_h : sorry, it was my understanding that you should compare 'f 0','f 1',...'f n' with eachother, to find which is the largest of those ..
18:22:59 <syntaxfree> hello, everyone, btw.
18:22:59 <Cale> marcot: oh, wait :)
18:23:17 <Cale> marcot: you were the one who replied, sorry :)
18:23:27 <marcot> Cale: ok..
18:23:44 <syntaxfree> so, in a simple fashion that doesn't require me writing actual recursion. I  have a list of pairs (String, Floating), and I want to select the one pair with the largest floating.
18:23:50 <syntaxfree> What is the easiest way to do that?
18:24:08 <syntaxfree> better yet, of sorting by score?
18:24:27 <int80_h> ski_, that could be. It's possible I'm misunderstanding what the problem to be solved is
18:24:35 <ski_> int80_h : also, possibly you want 'maxOverf (m-1)' instead of 'maxOverf m-1', but maybe someone already mentioned that ..
18:24:49 <Cale> syntaxfree: if you swap them so it's (Floating, String), the default Ord instance will do to sort them
18:24:55 <Cale> otherwise, use sortBy
18:25:08 <syntaxfree> Cale: thanks!
18:25:20 <int80_h> ski_ so I should be comparing f n to f (n -1)?
18:25:27 * syntaxfree 's heuristic exhibits pseudosmart behaviour.
18:25:52 <ski_> int80_h : i'm assuming e.g. that 'maxOverf 2 = 44'
18:26:09 <ski_> int80_h : that is my interpretation of the problem, yes
18:27:06 <int80_h> sp
18:27:23 <int80_h> so when I'm done I should get a result of 44, because f 1 has the largest value
18:27:38 <int80_h> I'm not allowed to use where
18:27:39 <int80_h> yet
18:27:41 <int80_h> so I
18:27:50 <int80_h> I'm really not sure how to accomplish this
18:28:03 <Cale> ah, it's int80_h's problem which was answered on the mailing list by marcot :)
18:28:15 * ski_ could write it with the help of [0..n] and map
18:28:23 <int80_h> I can't use map or lists
18:28:40 <marcot> int80_h: my second version was without map or lists.
18:28:54 <int80_h> marcot: but you use where
18:29:03 <int80_h> and it would be cheating for me to do so
18:29:18 <int80_h> but I did learn a bit more about the language. So thank you :)
18:29:24 <marcot> int80_h: just substitute biggest with overF (m - 1)
18:29:24 <ski_> int80_h : then you should prolly make a recursion down to base case 0
18:29:31 <marcot> int80_h: than you can take the where out.
18:29:37 <int80_h> marcot: do you agree that ski's interpretation of the problem is correct?
18:29:51 <int80_h> ski: that's the challenge, it has to be recursive
18:29:52 <marcot> int80_h: it's the same as mine.
18:29:59 <int-e> int80_h: why do you even compare f m and m ... the one has nothing to do with the other.
18:30:13 <int80_h> int-e I misunderstood what the problem to be solved was
18:31:05 <int80_h> okay marcot, I will be able to modify your second solution to not include the where statement? (is that even the right phrasing?)
18:31:17 <marcot> int80_h: yes.
18:31:30 <marcot> just subistitute biggest with the right side of the = in where.
18:31:38 <int80_h> yay thanks
18:31:38 <marcot> I think mapOverf (m - 1)
18:31:47 <Julian> I cant compile lambdabot
18:31:59 <int80_h> okay off to my TA gig
18:32:08 <marcot> Ok.. good night all.
18:32:10 <Julian> ghc-6.4: unknown package: plugins
18:32:13 <int80_h> fear, int80_h is respon
18:32:20 <Julian> some help ?
18:32:31 <int80_h> fear, int80_h is responsible for the edification of the younger generation
18:32:37 <Cale> maxOverf 0 = f 0; maxOverf m = if maxOverf (m-1) < f m then f m else maxOverf (m-1)
18:33:00 <int80_h> I don't understand the 0 = f 0
18:33:14 <int80_h> if it said | 0 = f0 I would understand that
18:33:24 <dons> Julian, you need to install hs-plugins first
18:33:33 <dons> check the bulid guide on the wiki
18:33:33 <marcot> Is just the same as | m == 0 = f 0
18:33:37 <dons> @hawiki LambdaBot
18:33:38 <lambdabot> http://www.haskell.org/hawiki/LambdaBot
18:33:39 <marcot> I'll sleep, good night all.
18:33:42 <int80_h> ah
18:33:53 <ski_> if n = 0, then f 0,f 1,...,f n becomes just f 0, which is surely the maximum, then
18:34:05 <dons> here Julian: http://www.haskell.org/hawiki/LambdaBot_2fInstallation
18:34:07 <int80_h> thanks Cale
18:34:12 <int80_h> well and everyone
18:36:14 * ski_ leaves
18:36:26 * int80_h wuvs #haskell
18:36:38 <int80_h> I don't really see how I could go on learning haskell without this channel
18:37:07 <int80_h> I think maybe five people on campus has even heard of the functional model, let alone anything about haskell specifically
18:37:12 * int80_h is all alone
18:37:46 <ski_> haskell !!!
18:37:49 <ski_> (sorry)
18:37:58 <Julian> dons: thx
18:38:51 <Cale> int80_h: well, you'll have to learn it and show people :)
18:39:16 <Cale> which campus?
18:39:34 <int80_h> oh a community college in california
18:39:50 <int80_h> I have a vision of the discrete math class being taught with haskell one day
18:40:03 <int80_h> it seems to me, the only "in" fp has around here
18:40:09 <int80_h> is through the math department
18:41:04 <int80_h> okay I must leave
18:41:07 <Cale> well, the math department ought to be the ones teaching CS
18:41:08 <Cale> :)
18:41:20 <int80_h> I want to get through this book asap so I can get to the algorithms book I have
18:41:38 <int80_h> for functional languages. It looks really cool
18:42:30 <ski_> Cale : :)
18:50:41 <syntaxfree> I'm in love with myself.
18:54:56 <Julian> syntaxfree: wow
18:55:04 <Julian> syntaxfree: narciso
18:55:07 <Julian> :-)
18:58:39 <MenTaLguY> @pl sequence_ . fmap
18:58:40 <lambdabot> sequence_ . fmap
18:58:57 <MenTaLguY> yeah, excitement
18:59:22 * MenTaLguY wanders off again, having thoroughly embarassed himself
19:10:06 <Julian> dons: i cant compile lambdabot
19:10:24 <Julian> ghc-6.4: unknown package: plugins
19:11:52 <MenTaLguY> do you have the hs-plugins package installed?
19:11:59 <Julian> yes
19:12:22 <MenTaLguY> ghc-6.4 doesn't seem to think so
19:12:30 <MenTaLguY> so, that would be the thing to look into
19:13:26 <Julian> ghc -Wall -Werror -cpp -fglasgow-exts -I. -funbox-strict-fields -O2 -fvia-C  -threaded  -package plugins -main-is Boot.main -c Boot.hs -o Boot.o -ohi Boot.hi
19:13:27 <Julian> ghc-6.4: unknown package: plugins
19:13:27 <Julian> make: *** [Boot.o] Error 1
19:13:55 <MenTaLguY> do you have any other ghc versions or other haskell compilers/interpreters installed?
19:14:04 <MenTaLguY> maybe the plugins package was installed to a different one?
19:14:20 <Julian> hugs
19:14:57 <MenTaLguY> you might have to explicitly specify ghc when building/installing hs-plugins then
19:15:14 <Julian> but....
19:15:24 <Julian> I do emerge hs-plugins
19:15:40 <Julian> and this merge hs-plugins and ghc-bin
19:15:47 <MenTaLguY> huh
19:17:05 <Julian> would be fine
19:19:27 <MenTaLguY> I'm not familiar enough with how the hs-plugins ebuild is set up to really speculate on what's going on there
19:23:34 <MenTaLguY> @pl sequence_ . map (\i -> return (i * 2))
19:23:35 <lambdabot> sequence_ . map (return . (2 *))
20:03:48 <glguy> anyone know why gentoo uses ghc 6.2 (seems like an old version)
20:05:46 <rep> probably because ghc takes so long to compile
20:05:51 <Cale> http://packages.gentoo.org/search/?sstring=ghc
20:05:52 <dcoutts> glguy, it has 6.2.2 marked stable
20:06:28 <dcoutts> glguy, 6.4 and 6.4.1 are currently marked with ~arch keyword on all supported arches
20:06:48 <dcoutts> glguy, we're going to mark 6.4.1 stable on all arches quite soon
20:06:58 <Cale> hmm.. the maintainer for ghc appears to be named duncan :)
20:07:23 <glguy> I figured that one of you would be involved in that process :)
20:07:46 <dcoutts> 6.4 was actually very unstable, it broke all our packages so it took a while to get it into the tree and then we found it was also full of bugs :-)
20:08:15 <dcoutts> 6.4.1 only came out recently, so it's not been that long
20:08:47 <dcoutts> we're also going to start adding many more cabalised packages soon
20:09:17 <Cale> you'd probably want the binary package for something like that anyway
20:09:22 <Cale> wouldn't you?
20:09:33 <glguy> me?
20:09:41 <dcoutts> Cale, we do have a binary package of ghc
20:09:52 <Cale> yeah, I see it there
20:09:55 <glguy> compiling the source version depends on the binary version
20:10:10 <dcoutts> so if you get your cabal package into hackage then it's quite likely to make its way into gentoo, since we've not got a semi-automatic haskage->portage tool.
20:10:59 <dcoutts> glguy, yeah, that's because ghc depends on ghc, which is a rather tricky situation for a source-based distro :-)
20:11:08 <glguy> dcoutts, i understand why it's like that
20:11:22 <glguy> dcoutts, didn't know if everyone know how it worked
20:11:31 <glguy> so what haskell compiler made the first version of ghc
20:11:42 <dcoutts> I really don't know
20:12:04 <dcoutts> it's possibly lost in the mists of time :-)
20:12:09 <dcoutts> or ask SPJ
20:12:59 <dcoutts> ghc probably used another Haskell compler/interpreter up until the point where it was self-hosting
20:13:00 <glguy> Cale, I came up with my final solution to the gauss seidel method... if you are bored you can look at the paste of it http://rafb.net/paste/results/VsFckl20.html
20:13:09 * dcoutts goes to bed
20:13:19 <Cale> night dcoutts
20:13:48 <Cale> glguy: cool, that looks decent
20:14:20 <glguy> I know this is a trivial little function, but "optimizing" it has helped me a lot in general haskell usage
20:15:31 <Cale> yeah, I basically learned Haskell by lurking here and solving the exercise questions which people would bring up :)
20:15:57 <wchogg> When did you first start learning, Cale?
20:16:34 <Cale> hmm
20:16:52 <Cale> ~2 years ago or so
20:17:41 <wchogg> Has the language changed much in that time?
20:18:11 <Cale> The libraries certainly have. The core language hasn't changed, but new extensions have cropped up.
20:19:14 <glguy> LOL, the "offensive" background in the "gentoo-artwork" package compares Lenin, Castro, Che, and Gentoo as revolutionaries
20:49:35 <Frederick> hi folks can I make questions about formal languages here?
20:51:53 <Frederick> well is anyone here familiar with grammar simplification?
21:16:12 <sethk> Frederick, go ahead and ask.  Even if nobody answers people might come by who know
21:16:14 <dons> @type Char.ord
21:16:15 <lambdabot> Char -> Int
21:16:16 <dons> @eval map
21:16:17 <lambdabot> Terminated
21:16:25 <dons> @eval map
21:16:26 <lambdabot>  add an instance declaration for (Show ((a -> b) -> [a] -> [b]))
21:16:28 <dons> @eval map
21:16:28 <lambdabot>  add an instance declaration for (Show ((a -> b) -> [a] -> [b]))
21:16:29 <dons> @eval map
21:16:29 <lambdabot> Terminated
21:16:32 <dons> hmm.
21:17:03 <Frederick> sethk, thx im trying to put it int chomsky normal form http://rafb.net/paste/results/LZuQtc89.html
21:20:05 <sethk> Frederick, I don't really remember what chomsky normal form actually is.  I would probably cheat by pusing the grammar through a program that reads and reduces grammars (happy in Haskell or bison or yacc)
21:21:11 <Frederick> sethk, plz cheat, I got a test tommorow I must know tha answer
21:21:41 <sethk> Frederick, if you are on a unix or linux box bison or yacc is probably available
21:21:55 <Frederick> sethk, Ive never used it
21:23:00 <machack666> is there a pragma to prevent the caching of intermediate results for functions?  I'm trying to use Debug.Trace to output IO relating to the status of my computation, but once the computation has been completed once, it skips right to the result without outputting the trace for me.  (Using GHCi through haskell-mode...)
21:24:47 <Cale> machack666: um, trace will print exactly when its evaluation is forced
21:25:48 <Cale> if you're not seeing traces that you think you should be, then perhaps you're not evaluating some things. If it's really that sharing is happening, then well, you've already seen those traces
21:26:31 <Cale> machack666: if you're using Debug.Trace for anything other than debugging, then you're doing something wrong :)
21:28:23 <Cale> be careful to attach the trace to something which is going to change
21:30:47 <Cale> Personally, I recommend using trace to write a function (tqu :: (Show a) => a -> a) which is like id, except that it prints the result as it's evaluated, usually inside some rows of ***'s or something, to separate it from other output.
21:32:54 <Cale> (tqu is usually easy to search for when it comes time to remove the traces)
21:37:35 <dons> SamB, looks like the lambdabot on linux issue was due to different semantics for waitForProcess on that OS
21:37:38 <dons> it throws an exception if the process has already completed, whereas on openbsd you get ExitSuccess
21:41:15 <Cale> machack666: did you get that?
21:41:18 <machack666> Cale: thanks for the pointers ...
21:42:13 <machack666> the first time I evaluate in GHCi it prints the traces
21:42:35 <machack666> but when I try to alter the function, reload the file, etc, it just uses the shared result
21:42:48 <Cale> hmm
21:42:58 <Cale> when you reload the file it should clear all of that
21:43:41 <machack666> I tried finagling the function into the IO monad, but lacked the skills to get it to do what I needed without rewriting a large part of the code (so I'm obviously doing something wrong in that regard)
21:43:49 <Cale> also, ghci should only keep the values of top-level values around
21:44:34 <machack666> I have a function which returns my sample case (essentially a Data.Array object pre-populated with certain values)
21:45:21 <machack666> and I have a deduce function which populates further values
21:45:50 <Cale> that array is at the top level?
21:45:54 <machack666> from ghci, I am calling `deduce sampleStructure'
21:46:01 <machack666> yes
21:46:09 <Cale> er, hmm
21:46:15 <Cale> how is it changing?
21:46:29 <Cale> is it an array of IORefs or something?
21:46:36 <machack666> the structure itself is the same, but the definition of deduce is what I'm tinkering with.
21:46:44 <machack666> Data.Array.Diff of Maybe Ints
21:46:54 <machack666> nothing that should brek referential transparency
21:47:00 <Cale> right, okay
21:47:00 <machack666> unless DiffArrays do
21:47:12 <Cale> so once you evaluate a cell, it should never change
21:47:48 <Cale> note that myArray // [...] doesn't change the values of the elements of myArray
21:48:09 <machack666> right, I recurse over array // updateElems
21:48:20 <machack666> that's what deduce essentially does
21:48:40 <machack666> -- finds the elems which can be updated and the new values
21:49:11 <machack666> once it detects that no more elems can be inferred directly, returns the current array
21:49:39 <glguy> ah, the suduko thingy
21:49:48 <Cale> sudoku
21:50:17 <Cale> You'll see any traces associated to myArray the first time, and then when you call deduce again, you should only see those associated with deduce
21:50:31 <Cale> hmm
21:50:52 <Cale> I wonder if this has anything to do with the internal representation of DiffArrays
21:51:26 <Cale> if it's not doing that, it might be because  myArray // [...] does update myArray in a normally invisible way
21:51:36 <lament> weeee sudoku
21:51:43 <lament> that thing is fun
21:52:54 <machack666> I had tried it with IArrays before
21:53:09 <machack666> yes, sudoku
21:53:09 <Cale> er, Arrays?
21:53:23 <machack666> Data.Array.IArray
21:53:30 <Cale> DiffArray is an instance of IArray
21:53:35 <machack666> hey, I don't know what I'm doing here! :D
21:54:04 <Cale> :)
21:54:32 <machack666> because it does evaluate the first time, it seems like it's more of a caching issue to me
21:55:00 <machack666> the whole thing's kind of wonky right now -- it doesn't seem to do what I think I told it.
21:55:07 <machack666> obviously the computer is at fault.
21:55:10 <Cale> replace the signature so that it says Array rather than DiffArray and see if it behaves any differently -- where are the traces located?
21:56:58 <machack666> in the internal (top-level) helper functions
21:57:26 <Cale> which the array definition calls or which deduce calls?
21:57:53 <machack666> kind of sprinkled around.  I can put the code up so that you can see
21:57:56 <machack666> @paste
21:57:58 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:00:11 <machack666> ok, it's up there and looking beautiful
22:00:38 <machack666> Sudoku is just an Array (Int,Int) (Maybe Integer)
22:02:15 <dons> @eval map
22:02:21 <lambdabot>  add an instance declaration for (Show ((a -> b) -> [a] -> [b]))
22:02:23 <dons> @type ord
22:02:23 <lambdabot> Not in scope: `ord'
22:02:31 <dons> @version
22:02:31 <lambdabot> lambdabot 3p112, GHC 6.5.20050806 (Linux i686)
22:02:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:03:49 <Cale> so, none of the traces get printed the second time around?
22:03:56 <machack666> right
22:04:15 <dons> @type 2 + 3 + foldl
22:04:15 <lambdabot> forall a b.
22:04:15 <lambdabot> (Num ((a -> b -> a) -> a -> [b] -> a)) =>
22:04:15 <lambdabot> (a -> b -> a) -> a -> [b] -> a
22:04:21 <dons> haskell is fun sometimes
22:05:13 <glguy> I need a good way to pass 4 arrays around together
22:05:22 <glguy> am I looking at using 'data'
22:05:27 <glguy> (or should I be)
22:05:27 <Cale> glguy: a data declaration? yes
22:08:39 <glguy> does a data type with only one constructor look like: data Name = Name Int Int   or  data Name = Name2 Int Int
22:08:53 <Cale> either of those
22:08:56 <glguy> okay
22:16:59 <glguy> @t filter
22:17:00 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons
22:17:00 <lambdabot> topic-init topic-null topic-snoc topic-tail topic-tell type pl
22:17:00 <lambdabot> wn
22:17:02 <glguy> @type filter
22:17:03 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:17:07 <glguy> @type unfilter
22:17:08 <lambdabot> Not in scope: `unfilter'
22:17:39 <glguy> (that was dumb...)
22:19:14 <Cale> heh, that would be a useful function :)
22:20:16 <glguy> @eval div 4 3
22:20:18 <lambdabot> 1
22:20:22 <glguy> @eval mod 4 3
22:20:24 <lambdabot> 1
22:20:26 <dons> i've changed @type by the way, to return some diagnostics, rather than "bzzt"
22:20:26 <glguy> cool
22:20:29 <dons> hopefully it helps
22:20:35 <glguy> @liftIO
22:20:36 <lambdabot> Unknown command, try @listcommands.
22:20:38 <glguy> @type liftIO
22:20:40 <lambdabot> Not in scope: `liftIO'
22:20:42 <glguy> ahh
22:20:48 <glguy> that's much friendlier ;)
22:23:50 <glguy> @eval map (\(x,y) -> 3 * y `div` 3 + x `div` 3 + 1) [(1,1) (6,4) (9,9)]
22:23:51 <lambdabot>   The function `(1, 1)' is applied to two arguments,
22:23:51 <lambdabot>   but its type `(a, b)' has none
22:23:51 <lambdabot>   In the list element: (1, 1) (6, 4) (9, 9)
22:24:33 <glguy> @eval map (\(x,y) -> 3 * y `div` 3 + x `div` 3 + 1) [(1,1),(6,4),(9,9)]
22:24:34 <lambdabot> [2,7,13]
22:24:36 <glguy> this isn't matlab is it
22:24:57 <dons> nope
22:25:44 <glguy> @eval map (\(x,y) -> 3 * (y-1) `div` 3 + (x-1) `div` 3 + 1) [(1,1),(6,4),(9,9)]
22:25:53 <glguy> @eval map (\(x,y) -> 3 * (y-1) `div` 3 + (x-1) `div` 3 + 1) [(1,1),(6,4),(9,9)]
22:26:01 <lambdabot> [1,5,11]
22:26:38 <dons> @yow
22:26:39 <lambdabot> Now I am depressed ...
22:26:45 <dons> @ghc
22:26:46 <lambdabot>  even with cunning newtype deriving the newtype is recursive
22:32:40 <glguy> will hGetChar return the newline?
22:32:43 <glguy> ..
22:35:55 <glguy> @type foldl
22:35:56 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:40:27 <vegai> I love my Athlon. I get about 5 segfaults when compiling gtk2hs
22:41:17 <glguy> I love thinking of "foldl" as dragging the 'a' part of that type definition through the list
22:41:29 <glguy> and returning the poor thing after it's done
22:45:05 <vegai> ...and now it crashed.
22:45:07 <vegai> Time to underclock.
22:46:35 <glguy> how do i treat an IO String like an IO [Char]
22:47:30 <vegai> odd question
22:47:38 <vegai> String is [Char]
22:47:47 <glguy> yeah, but I'm getting message saying otherwise :)
22:48:02 <glguy> so I'm probably just doing something stupid
22:48:58 <glguy> trying to say: hGetLine h >>= (map read)
22:49:12 <aleator> add return there
22:49:19 <ibid> well, map read is not monadic :)
22:49:26 <glguy> fine
22:49:29 <glguy> what I'm really doing is
22:49:34 <glguy> line <- hGetLine h
22:49:53 <glguy> let input = zip (range ((1,1),(9,9))) (map read line)
22:50:35 <vegai> ...and?
22:50:46 <ibid> you really intend to apply read to single characters?
22:50:54 <glguy> return $ foldl (\b ((x,y),s) -> setSpace b x y s) initBoard input
22:50:55 <glguy> yeah
22:51:03 <glguy> yeah character is a number 1-9
22:51:04 <glguy> err
22:51:05 <glguy> 0-9
22:51:19 <glguy> and I want a list of Ints
22:51:36 <aleator> map (\a->[a]) ?
22:52:04 <glguy> but line is already a String and thus a [Char]
22:52:26 <aleator> but read wants [char] and thus map read wants [[char]] ?
22:52:28 <ibid> what's the type signature of setSpace?
22:52:45 <glguy> setSpace :: Board -> Int -> Int -> Int -> Board
22:52:54 <ibid> yeah, what aleator said.  how could i have missed that :)
22:53:05 <glguy> alright..
22:53:15 <glguy> where exactly would I add that...?
22:53:23 <glguy> before the read map?
22:53:30 <ibid> map (read . \ a -> [a]) line
22:53:33 <glguy> or? (\a -> read [a]
22:53:34 <ibid> or something
22:53:45 <ibid> that too
22:54:00 <glguy> @pl (\a -> read [a])
22:54:01 <lambdabot> read . return
22:54:16 <aleator> Ok. That'd be confusing :)
22:54:17 <vegai> :)
22:54:24 <ibid> @pl read . \ a -> [a]
22:54:25 <glguy> sweet, compiled
22:54:26 <lambdabot> read . return
22:55:06 <vegai> Someone needs to make an .el for @pl ... so that everything is pointless-reduced automatically
22:56:52 <C-Keen> moin
22:59:56 <glguy> @type ixmap
22:59:58 <lambdabot> Not in scope: `ixmap'
23:00:05 <glguy> @type Data.Array.ixmap
23:00:07 <lambdabot> forall e i j.
23:00:07 <lambdabot> (GHC.Arr.Ix j, GHC.Arr.Ix i) =>
23:00:07 <lambdabot> (i, i) -> (i -> j) -> GHC.Arr.Array j e -> GHC.Arr.Array i
23:00:07 <lambdabot> e
23:01:42 <glguy> so ixmap is a way to transform the indexes?
23:06:19 <dons> vegai, or have a cmd line interface to @pl
23:12:02 <TheHunter> There is a cmd-line-interface to @pl.
23:12:47 <TheHunter> cd lambdabot/Plugins/Pl; make; ./Test
23:14:07 <tismith> who ex_nor
23:15:31 <glguy> is there a good way to intersect two lists?
23:15:47 <ibid> intersect in what sense?
23:15:50 <basti_> glguy: define "good", "intersect" .)
23:15:58 <glguy> [1,2,3,4] ^ [3,4,5] -> [3,4]
23:16:03 <glguy> good  : in prelude :)
23:16:11 <ibid> glguy: can we assume that the lists are sorted?
23:16:23 <ibid> glguy: what about that an element occurs only once?
23:16:30 <glguy> both true
23:16:31 <TheHunter> @eval intersect [1,2,3,4] [3,4,5]
23:16:33 <lambdabot> [3,4]
23:16:41 <glguy> sweet, prelude to the rescue
23:16:56 <TheHunter> it's probably Data.List
23:16:59 <basti_> thats the O(n^2) solution i think
23:17:05 <glguy> @index intersect
23:17:06 <lambdabot> Data.List, Data.Set
23:17:08 <ibid> List.intersect
23:17:14 <ibid> (in h98)
23:18:48 <glguy> friggin golden, sudoku solver is almost done
23:19:28 <basti_> why do all people do prolog problems in haskell? ^^
23:19:44 <glguy> because we don't know what prolog is
23:19:51 <glguy> more than it's a computer language
23:20:00 <ibid> because haskell is the best logical programming language? ;)
23:20:16 <ibid> (paraphrasing spj and "imperative":)
23:20:43 <basti_> :P
23:21:22 <basti_> prolog is fun. it's just visibly 50 years old, thats the problem.
23:21:41 <ibid> well, i've started my fp course by giving a crash course on IO :)
23:21:55 <ibid> basti_: except that prolog is only ~35 years old :)
23:22:23 <ibid> (and the standard is much less)
23:22:28 <basti_> .)
23:23:16 <sethk> Cale, I figured out the State and StateT monads, but I have a specific question.  So
23:23:24 <Cale> yeah?
23:24:14 <sethk> Cale, for State, we have runState State s a -> s -> (a,s)
23:24:44 <sethk> Cale, now, what I do is this:   runState( do ........ )
23:25:26 <Cale> that will get you something of type s -> (a,s)
23:25:45 <sethk> Cale, yes, I know, but I'm getting at something different
23:25:55 <Cale> okay
23:26:13 <sethk> Cale, what happens is this.   I apply runState to a function.  The function returns something, of type a
23:26:49 <sethk> Cale, then I take the function returned by runState, and apply it to an s value.
23:27:02 <sethk> Cale, then I get    (a,s)
23:27:04 <sethk> Cale, but
23:27:06 <Cale> right
23:27:21 <sethk> Cale, a is the return value of the function I defined in runState (...)
23:27:37 <sethk> Cale, the monad creates the return pair (a,s)
23:27:54 <sethk> Cale, you follow?
23:28:06 <Cale> yeah
23:28:26 <Cale> though you're using "function" to mean the thing constructed by do {...}
23:28:43 <sethk> Cale, What I want to know is how, from the signature, I can know that in the return value  (a, s)    a comes from my function, and the monad creates the pair (a,s) using my a
23:28:57 <sethk> Cale, well, about the "function", not exactly
23:29:00 <musasabi> The happy attribute grammar stuff looked nifty.
23:29:17 <sethk> Cale, what's defined within runState( ... ) is certainly a function
23:29:29 <sethk> Cale, but applying runState to it returns another function
23:29:38 <sethk> Cale, that function takes s and returns (a, s)
23:30:00 <sethk> Cale, my function (the one defined within runState( ... )) returns a
23:30:23 <sethk> Cale, from the library doc on State, how do I know that my function isn't supposed to return (a, s)?
23:30:49 <sethk> Cale, how does the documentation tell me that within runState( ... ) I need to return one value, not a tuple?
23:31:06 <sethk> Cale, I want to know that so I can apply it to other monads.
23:31:08 <integral> @type Control.Monad.State.runState
23:31:08 <Cale> well the do {...} isn't a function
23:31:10 <lambdabot> forall s a. Control.Monad.State.State s a -> s -> (a, s)
23:31:12 <Cale> technically
23:31:28 <sethk> Cale, ok, then, what's the proper term
23:31:30 <Cale> because it's a  (State s a)
23:31:37 <Cale> or some such :)
23:31:43 <Cale> computation would be a better term
23:31:49 <sethk> Cale, although, what's returned by runState ( ... ) is surely a function
23:31:53 <Cale> right
23:31:58 <Cale> which you apply to s.
23:32:03 <sethk> Cale, ok, computation then, but the same question
23:32:05 <Cale> a value of type s rather
23:32:14 <sethk> Cale, now, another wrinkle
23:32:28 <Cale> because you want the type to be (State s a) and not (State s (a,s))
23:32:39 <Cale> that's why you return a value of type a
23:33:06 <sethk> Cale, the type is not State s a (the type of what is returned)
23:33:15 <sethk> Cale, the return type is (a, s)
23:33:18 <Cale> type of the do block
23:33:46 <sethk> Cale, what, in the documentation for State, tells me that I need a computation that returns one value
23:33:57 <integral> the type signature!
23:34:10 <sethk> which type signature tells me that I need to return one value
23:34:15 <sethk> integral, specifically
23:34:16 <integral> runState :: (State s) a -> (s -> (a, s))
23:34:21 <integral> sethk: the a after (State s)
23:34:29 <integral> the two a's in the type signature are the same type.
23:34:44 <sethk> integral, of course the a's are the same type.  I know that.
23:34:55 <sethk> but that doesn't track the signature
23:35:06 <Cale> um
23:35:18 <Cale> I suppose I don't know what you're asking then
23:35:23 <sethk> the signature is:  Control.Monad.State.State s a -> s -> (a, s)
23:35:30 <integral> pardon?
23:35:31 <Cale> @type return
23:35:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
23:35:44 <sethk> Cale, no, I'm not confused about making something into a monad
23:35:48 <Cale> your monad is State s
23:35:52 <sethk> no
23:35:58 <sethk> not according to the documentation
23:36:01 <Cale> that is m = State s
23:36:09 <sethk> my monad is State s a
23:36:17 <Cale> so return :: a -> State s a
23:36:32 <sethk> Cale, ok, but what does this have to do with anything?
23:36:45 <Cale> sethk: because it's how the type of the do-block is determined
23:36:59 <Cale> which influences the type of runState
23:37:03 <sethk> Cale, I know that, that isn't the question
23:37:09 <Cale> which influences the type of the result
23:37:11 <Cale> okay
23:37:13 <integral> What *is* the question?
23:37:53 <sethk> what, in the type signature, tells me my computation must return a single value
23:38:15 <integral> sethk: the type that the type constructor of the monad is being applied to.
23:38:19 <JohnMeacham> wow. for tight mathematical inner loops, jhc is 3-5x faster than ghc.. that was _completly_ unexpected. that code path doesn't involve any of jhc's crazy global optimizations at all. I will have to examine the generated assembly to figure out what is happening...
23:38:57 <sethk> integral, you mean Control.Monad.State.State s a -> s -> (a, s)?
23:39:06 <sethk> integral, that's the signature of runState
23:39:09 <integral> sethk: hmm?
23:39:12 <Cale> JohnMeacham: that's a nice result! :)
23:39:32 <sethk> integral, you said "the type that the type constructor of the monad is being applied to"
23:39:34 <integral> consider this: runState $ do { return x } :: s -> (a, s)
23:39:54 <integral> sethk: yep.
23:39:55 <JohnMeacham> Cale: yeah, I think there might be a bad misfeature in ghc, because I don't see why it couldn't produce the same output jhc does.
23:40:23 <integral> cale's already said that (State s) is the monad, ie there is an instance Monad (State s) for it
23:40:56 <sethk> integral, ok, I guess that's where you lost me.  Because the docs say that  State s a    is the monad, not  State s
23:41:07 <integral> the ghc docs?
23:41:13 <sethk> integral, right
23:42:12 <sethk> e.g.:     Control.Monad.State.State s a -> s -> (a, s)
23:42:19 <sethk> is the type of runState
23:42:23 <Cale> right
23:42:23 <integral> under "Instances" it says: Monad (State s)
23:42:27 <Cale> that's correct
23:42:37 <Cale> but it doesn't stop (State s) being the monad
23:42:39 <integral> sethk: a monad isn't a *type*, but a function from types to other types.
23:42:58 <Cale> Like with lists, [] is really the monad
23:43:02 <sethk> integral, it isn't a function from types to other types either
23:43:05 <Cale> or IO is the monad
23:43:14 <integral> sethk: pardon?  yes it is.
23:43:19 <Cale> IO is a function from types to types
23:43:20 <integral> @kind Control.Monad.State.State
23:43:22 <lambdabot> * -> * -> *
23:43:38 <integral> sethk: it's just not a normal haskell function, but a type constructor.
23:43:47 <sethk> integral, yes, yes, I know all that
23:44:02 <integral> umm, I'm not sure you do...
23:44:23 <sethk> integral, You are saying that when the docs say that the State monad is defined as State s a, that is not the monad?
23:44:26 <sethk> integral, please, I do
23:44:37 <sethk> integral, because we can't get to my question if we slip into that
23:44:47 <integral> "A parameterizable state monad where s is the type of the state to carry and a is the type of the return value."
23:45:02 <sethk> integral, I have read the docs 100 times.  PLEASE don't quote them at me
23:45:06 <integral> it doesn't explictly say what is the monad in the English.
23:45:27 <sethk> ewtype State s a
23:45:27 <sethk> A parameterizable state monad where s is the type of the state to carry and a is the type of the return value.
23:45:38 <sethk> sorry chopped the n off newtype
23:45:47 <sethk> newtype State s a
23:45:47 <sethk> A parameterizable state monad where s is the type of the state to carry and a is the type of the return value.
23:45:47 <integral> yes, but it doesn't say which of, (State), (State s) or (State s a) is the monad, in the English.
23:46:13 <sethk> integral, then what is the meaning?
23:46:47 <basti_> @google monad catholic
23:46:48 <lambdabot> http://www.newadvent.org/cathen/10447b.htm
23:46:50 <sethk> but forget that, because you were perhaps near the answer before and then went in this nonproductive direction
23:46:53 <integral> well it means that the newtype declares a *parameterizable* monad
23:47:07 <integral> which means that (State s) must be the monad I guess.  it's got a parameter at least
23:47:25 <sethk> integral, it clearly states that it has TWO parameters
23:47:28 <sethk> State s a
23:47:42 <sethk> but let's get back to something you said earlier
23:47:44 <integral> no, State is not the Monad.
23:47:48 <integral> (State s) is the monad!
23:48:00 <integral> You know what a monad consists of?
23:48:11 <sethk> integral, yes, please, don't veer off
23:48:24 <JohnMeacham> Ah! ghc's attempt to optimize tail calls itself is actually inhibiting the compiler from creating efficient loops. that is no good, ghc is causing a CPU pipeline flush on every iteration! I will have to notify the authorities.
23:48:38 <sethk> You are saying that the instance   Monad (State s)     is the definition that matters
23:48:51 <integral> I guess
23:49:43 <sethk> ok, that answers my question, if that is true in general for the monad documentation
23:50:16 <integral> well that is the line that documents what the code actually says is the monad.  In Haskell, something is not a monad just because it obeys all the laws etc,  but because it was declared an instance of Monad
23:50:43 <sethk> integral, I'm not talking about what makes it a member of the monad class
23:51:14 <sethk> I'll have to figure out the relationship between the monad instance and the type defined for a monad.
23:51:49 <integral> Do you know what a monad consists of?
23:52:15 <integral> sethk: a monad isn't a type, but a type constructor
23:52:31 <sethk> integral, so?
23:53:18 <glguy> alrighty so on the same lines as the intersection of lists... is there a good way to subtract from a list?
23:53:24 <sethk> integral, however, if it is a type constructor, then the type, which is State s a          is the monad
23:53:30 <integral> sethk: the newtype there is more declaring (State) than (State s a).
23:53:40 <glguy> [1,2,3,4] - [2,4,5] = [1,3[
23:53:52 <Cale> @eval [1,2,3,4] \\ [3,4,5]
23:53:53 <lambdabot> [1,2]
23:53:59 <Cale> @eval [1,2,3,4] \\ [2,4,5]
23:53:59 <integral> sethk: no, a monad *is* a type constructor.  (State) is a parameterised monad like the docs say,  and (State s) is a set of monads
23:54:00 <lambdabot> [1,3]
23:54:08 <glguy> oh yeah!
23:54:11 <glguy> we are golden
23:54:17 <Cale> integral: what?
23:54:25 <integral> err, no? oops
23:54:32 <Cale> given s, (State s) is a monad
23:54:47 <Cale> (State) is a function from types to monads
23:54:57 <sethk> Cale, then why do we have:       newtype State s a
23:55:12 <integral> { (State s) | s :: * } if I want to say it's a set of monads
23:55:23 <Cale> because it's defining what happens when all the parameters get applied
23:55:26 <Cale> it's curried
23:55:44 <sethk> Cale, I understand exactly how it works
23:55:49 <Cale> State s a is a particular type, which belongs to the monad State s
23:56:15 <sethk> Cale, why, then, isn't State s a   a particular type, which belongs to the monad State s a  ?
23:56:26 <sethk> Cale, what is the a doing in the contructor?
23:56:53 <Cale> If a monad is a kind of container, then the 'a' is the type which is presently being contained.
23:57:02 <Cale> (what kind of thing is in the box)
23:57:13 <sethk> Cale, ok
23:57:48 <sethk> then take the reader monad
23:58:02 <sethk> ok, it follows the same pattern
23:59:00 <Cale> or IO, it follows a slightly different pattern, since it doesn't have that extra parameter
23:59:26 <sethk> I'll look at it more.
23:59:28 <Cale> IO is the monad, and IO a is a type associated to that
23:59:32 <sethk> I completely understand how it works
23:59:50 <sethk> what I'm asking is how that related to type
