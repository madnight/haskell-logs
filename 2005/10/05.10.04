00:19:16 <gour> morning #haskell
00:23:47 * boegel noticed someone actually spoke
00:27:18 <dons> @yow
00:27:19 <lambdabot> Are the STEWED PRUNES still in the HAIR DRYER?
00:27:43 <basti_> morningÂ²
00:30:30 <heatsink> EGADS! This much-greater-than-or-equal-to operator is PURE GENIUS!
00:34:17 <ProfTeggy> Morning.
00:34:48 * malcolm waves
00:52:30 <JohnMeacham> yay. johnnson style lambda-lifter increases speed of output by 10-20% must be triggering gcc's tail call optimization now.
00:54:15 <Itkovian> meuning
01:05:35 <malcolm> JohnMeacham: Is the lambda-lifter for jhc?
01:06:45 <JohnMeacham> yup.
01:07:05 <malcolm> JohnMeacham: 20% is a lot
01:08:14 <kosmikus> morning
01:08:14 <JohnMeacham> oddly enough, it never occured to me to switch it over until I banged my head against the old one deciding to pass functions that take unboxed arguments as parameters...
01:08:50 <JohnMeacham> malcolm: yeah, my old one was pretty silly. and I still have a ways to go before it is ghc competitive.
01:09:08 <malcolm> If the new one is after Thomas Johnsson, what style was the old one?
01:09:28 <JohnMeacham> in particular the worker/wrapper split is disabled at the moment, which is quite important.
01:11:05 <JohnMeacham> just something I whipped up a long time ago, treat each let seperatly, get all its free vars, pass them as arguments. which is badbad for recursive functions as it passes its continuation as an argument rather than making a direct call to the supercombinator. I wrote the code a long time ago and hadn't had a reason to look at it until just now.
01:11:42 <malcolm> and how can you be sure that it now enables gcc t-c-e, rather than enabling some of the cool GRIN optimisations to do better?
01:12:20 <JohnMeacham> I can't. I hope to do a basic-blocks analysis right before C code generation to turn anything i can into loops and jumps.
01:14:00 <JohnMeacham> actually, I was toying with the idea of allowing local functions in Grin, with the caveat that local functions may only be called as tailcalls. that would enable expression of join-points and loops directly, which could turn into goto's and while loops respectivly. I don't even think it would break any of the monadic properties of grin..
01:14:04 * Heffalump gets up
01:14:23 <Heffalump> JohnMeacham: I have looked at the code produced by ghc :-) I was much more impressed by the jhc code, but it still made very little sense :-)
01:15:17 <JohnMeacham> It would also entail an explicit 'return' though.... the advantages would be great... but it makes we worry whether it breaks the theoretical niceness of grin..
01:15:27 <malcolm> Julian Seward (ex-ghc hacker) once sped up the inner loop of nhc98's interpreter just by turning a while loop with nested case statement into computed gotos - it hit gcc's sweet spot for something akin to tail recursion.
01:15:32 <rep> guys!
01:15:38 <rep> ghc finished compiling!!!!!
01:16:06 <JohnMeacham> oh... it would also mean I wouldn't have to lift lambdas that are only called in tail position. i.e. join points for the case-of-case tranlation. (and any others that happen to occur)
01:16:26 <malcolm> Got 25% speedup almost for free.
01:16:30 <rep> and now it links, when i include System.Posix!!!!
01:16:31 <rep> \o/
01:16:44 <rep> thank you, god.
01:17:50 <JohnMeacham> malcolm: sweet. jhc doesn't have an inner loop at all since it is just plain old C functions that call each other like normal. no higher order functions or computed gotos exist at code generation time. but getting those tail calls right is pretty vital. I don't think I can count on gcc always.
01:20:06 <malcolm> JohnMeacham: Well you certainly don't have an interpretive loop, but the program being compiled might have an "inner loop" of sorts, so tail-calls are kind of equivalent to gotos in my view.
01:20:15 <JohnMeacham> Heffalump: every supercombinator cooresponds to exactly one C function generated by jhc. each original function you write cooresponds to several supercombinators, you should be able to search for all the ones Main.foo turned into beacause they will be named things like fMain.foo$nn for some number nn... well, it is more complicated than that.. but it is a start.
01:21:29 <basti_> rep: congratulations
01:22:26 <Heffalump> JohnMeacham: right, thanks :-)
01:22:42 <JohnMeacham> malcolm: yeah. certainly. I will have to do something to ensure they are compiled efficiently... another possibility is another c-- based intermediate language, which I can analyze myself for inserting gotos properly...
01:23:28 <rep> :)
01:24:59 <JohnMeacham> Of course.. then I will be tempted to write a c-- compiler....  If I can work out some good theory behind local functions in grin then I think that would be an interesting result.. exceptions are also something that would be nice to be able to express, but I am even less sure what to do about those.
01:25:00 <Heffalump> hmm, I guess asking for >> to be superinlined would help a lot.
01:26:21 <lisppaste2> paolino pasted "Show issue" at http://paste.lisp.org/display/12225
01:26:32 <JohnMeacham> Heffalump: Yeah, it will when it can determine what type it is called at at compile time.. otherwise, it may or may not depending on how complicated the method is... liberal use of SUPERSPECIALIZE should help that out though..
01:26:33 <paolino> I'm having doubts on how to instantiate from Show can I have help ?
01:26:55 <basti_> add "deriving Show" to the datatype definition
01:27:06 <basti_> that works only with few types of course.
01:27:21 <ski> show (Foglia foglia)=show foglia
01:27:42 <ski> this calls 'show' on 'foglia', which has type 'value', here
01:28:03 <basti_> (uhm classes)
01:28:13 <ski> this means you need to say 'instance Show value => Show (Tree value) where ...'
01:28:33 <JohnMeacham> now I am working on getting CPR and the worker/wrapper split to play nice together.
01:29:09 <paolino> ski, what is the => for ?
01:29:20 <ski> paolino : the 'Show value =>' makes it say "*if* 'value' is in type-class 'Show', then 'Tree value' is also in type-class 'Show' and this is how the methods work .."
01:30:00 <ski> paolino : the '=>' is implication .. 'foo => bar' means, "if foo then bar"
01:30:10 <Heffalump> {-# SUPERINLINE (>>) #-}
01:30:10 <Heffalump> {-# SUPERSPECIALIZE (>>) #-}
01:30:14 <Heffalump> is that the right way to do it?
01:30:26 <Heffalump> (that's in my source)
01:30:38 <ski> paolino : do you understand ?
01:30:41 <Heffalump> or does it need a type too
01:30:50 <paolino> mmh
01:31:03 <JohnMeacham> Heffalump: yeah, but I don't think they are honored yet. well, SUPERINLINE is.
01:31:40 <paolino> ski you have been clear  anyway
01:32:05 <JohnMeacham> Heffalump: however, since (>>) is a class method, it automatically gets specialization rules. what needs to be done is improving the optimizer so said rules get more chances to fire.
01:32:14 <paolino> ski is there a more trivial example for => ?
01:33:00 <ski> paolino : '=>' can occur in different places .. one is in type signatures .. another is in instance declarations, this was the case here
01:33:19 <ski> paolino : you want an example for which case ?
01:33:53 <paolino> so is it a definable operator?
01:33:58 <ski> no
01:34:07 <Heffalump> JohnMeacham: right
01:34:13 <ski> in this case, consider e.g. the type 'Tree Foo', where 'Foo' is some type
01:34:28 <ski> can one 'show' values of type 'Tree Foo' ?
01:34:29 <JohnMeacham> hmm.. gosh the C code generator spits out a lot of useless temporaries. rather than translate each grin variable into a C one, I should just keep a mapping of grin variables to the current C expression that evaluates to it in a reader monad...
01:34:45 <ski> paolino : the answer is that depends
01:34:55 <Heffalump> btw, I found a bug in the dependency checking of the makefile - something that imports Info.Binary depends on the .hi-boot file but not the .hi file, so they get built in the wrong order and it fails.
01:35:10 <Heffalump> probably only happens to people on their first compile of it :-)
01:35:16 <ski> paolino : it depends on whether we can 'show' values of type 'Foo', i.e. whether that type is in class 'Show'
01:35:42 <ski> paolino : this is exactly what 'instance Show a => Show (Tree a)' expresses
01:36:01 <JohnMeacham> Heffalump: Yeah, the dependencies are generated by ghc's -M feature. do you know how to fix it generally for all the hs-boot modules?
01:36:11 <paolino> k
01:36:14 <ski> paolino : it says that we can 'show' values of type 'Tree a', *provided* we can 'show' values of type 'a'
01:36:24 <Heffalump> no idea, sorry :-)
01:37:00 <Heffalump> can jhc compile itself, OOI?
01:37:08 <ski> paolino : there are some types whose values can't be 'show'n .. so it makes sense to state this info
01:37:11 <JohnMeacham> Heffalump: I am sure it will bug shapr enough (since he compiles with -j 3) that he will fix it :)
01:37:19 <JohnMeacham> Heffalump: not even close. :)
01:38:04 <Heffalump> oh well :-)
01:38:38 <JohnMeacham> Heffalump: but that is certainly the goal. it is how I will make back the time I spend doing all the crazy optimizations :)
01:40:44 <JohnMeacham> I think when I started jhc I was afraid of dealing with mutually recursive equations and now I am paying for it.
01:45:09 <JohnMeacham> Ever notice there are like 5 or 6 papers out there claiming to have the algorithm ghc uses for strictness analysis? I wish every paper put the date of publication visibly on its front page. that would make figuring out how relevant the random paper I found in my pile is.
01:46:54 * ski seconds that
01:48:15 <JohnMeacham> oddly enough, the algorithm it actually uses (I think) is not in a paper claiming to give a strictness analysis algorithm, but rather in one claiming to have a method of measuring the effectiveness of a strictness analyzer.
01:48:57 <dcoutts> JohnMeacham, oh and there's another one that isn't used in ghc but should be. Google for boolean constraint solving and strictness analysis. It's some .au chaps I think.
01:49:46 <Heffalump> Martin Sulzmann et al?
01:49:51 <JohnMeacham> yeah, I read that one too :) seemed interesting and I was all ready to go into ghc's source and look at it.. but then I found something else completly.
01:50:04 <ProfTeggy> re
01:50:39 <JohnMeacham> I think it relyed on an external C boolean constraint solver. I wonder if there is a suitable haskell version out there.
01:50:39 <dblhelix> glynn01boolean
01:51:56 <dblhelix> there's an earlier paper that explain their approach for binding-time analysis
01:52:09 <dblhelix> /s/explain/explains
01:52:14 <JohnMeacham> lambdabot needs a scholar.google.com interface.
01:53:26 <JohnMeacham> yeah. I read both, had aspirations of implementing them for jhc, but then got distracted and implemented a simple fixpoint iteration one instead... I still would like to give it another whack though.
01:54:08 <dblhelix> n.b.: most papers of the papers you refer to claim to have plugged in their analysis in ghc... but these analyses never appeared in an actual release of ghc
01:54:46 <dblhelix> but they did not claim *that*, though
01:56:17 <JohnMeacham> dblhelix: yeah, it was never quite clear whether they put it in, but it has since been surpassed, or if it just never got integrated due to time constraints, or some horrible flaw was found when it was tried to be put into practice..
01:59:16 <JohnMeacham> So. does anyone actually know of a boolean constraint solver for haskell?
02:00:50 <JohnMeacham> I think an Algorithms.Solvers hierarchy would be awesome to have in the standard haskell library. imagine if you could simply call on an advanced simplex method or simulated annealing solver as simply as calling mapM ..
02:01:33 <basti_> like in oz?
02:01:46 <malcolm> You would probably need polytypic algorithms, so you weren't tied to any particular datastructure
02:02:18 <aleator> JohnMeacham: I would pay cash for that :)
02:03:25 <JohnMeacham> I played with an interface here http://repetae.net/john/recent/out/HsASA.html it lets you specify an arbitrary function of Paramater a => a -> Float and it will find its minimum.
02:04:35 <JohnMeacham> where instances are things like (Int,Maybe (Either Float Bool))  , it will automatically turn things like Bool and Either into binary parameters, flattening the whole thing down to a function of n floats to a float (some with integral constraints and bounds)
02:05:38 <JohnMeacham> I need to write some docs for it...
02:09:30 <beelsebob_> rocking
02:10:01 <beelsebob_> my new mac that was going to take "5 days build time" has just been shoved on a plane to me :)
02:10:37 <JohnMeacham> I used a similar technique in my options parsing library http://repetae.net/john/recent/out/GetOptions.html to let it infer all the parameters of your options from the _types_ of what you read from it. for very terse programs :) combined with the perllike regular expression (=~) operator, I can write much more terse haskel
02:10:43 <JohnMeacham> than perl code :)
02:13:01 <JohnMeacham> (and totally typesafe to boot) hmm... perhaps these should be compiled into a library for writing short scripts in haskell...
02:15:09 <JohnMeacham> "because every one-off script needs option parsing, regular expressions, and adaptive simulated annealing."
02:15:38 <aleator> JohnMeacham: Want to collaborate wrapping libsvm for haskell machine learning?
02:16:46 <JohnMeacham> first let me learn what libsvm is :)
02:17:12 <aleator> It is nice c support vector machine..
02:17:29 <gour> dcoutts: ping
02:18:12 <JohnMeacham> ah. looks interesting. A fully fleshed out Algorithms hierarchy with non-trivial stuff in it would be a really killer thing for haskell to have.
02:20:37 <dcoutts> gour, pong
02:21:01 <gour> dcoutts: it looks gtk2hs is becoming a spammer's target..
02:24:25 <aleator> JohnMeacham. It would. If you can actually make decently haskellish interface.. (Besides the fact that I need it in my work :)
02:35:21 <dcoutts> gour, yeah I saw that and deleted all the spam coments
02:35:36 <dcoutts> gour, if it hapens too much we should look at some more controls
02:35:45 <gour> dcoutts: i also removed few :-)
02:35:53 <dcoutts> ok, ta
02:36:38 <gour> there are two nice plugins fo it - spamkarma & SpamAssassin plugin
02:37:01 <dcoutts> gour, perhaps all we need is to prevent lots of comments from the same source in a short time
02:37:15 <gour> afaics, sa is on the haskell.org and i've checked reqs  - php is compiled with socekts support
02:37:32 <dcoutts> or require moderation for all comments with links
02:38:02 <gour> that's ok, if you think it won't bother regular users
02:38:03 <dcoutts> currently the threshold is 2. So if the comment has two links then it gets moderated. We could just lower that to 1.
02:38:18 <dcoutts> no-one has posted comments with links so far I think
02:38:20 * dcoutts checks
02:39:03 <gour> boegel did
02:39:25 <dcoutts> yep, he's the only one
02:39:33 <dcoutts> well that's not too bad
02:39:39 <dcoutts> I think I'll do that
02:39:50 <dcoutts> we can probably moderate pretty quickly
02:40:00 <dcoutts> can any of us moderate comments?
02:40:11 <dcoutts> or does it have to be admin or something?
02:40:46 <gour> afairemember, it must have privileges >= X
02:41:55 <dcoutts> ah the author gets emailed with comments for moderation
02:45:57 <gour> afaics, X = 5
02:46:31 <gour> so, all of us can do it
02:46:37 <dcoutts> gour, yep, good
02:46:45 <kolmodin> @where ghc-api
02:46:46 <lambdabot> http://scannedinavian.com/~lemmih/ghc-api
02:47:48 <dcoutts> kolmodin, trying to build hIDE too?
02:48:22 <kolmodin> just wanted to try to build ghc-api
02:48:54 <kolmodin> saw on the WP that it might fail
02:50:09 <dcoutts> yeah, we're not sure why yet
02:50:28 <dcoutts> so tell us if it works for you or not
02:50:33 <kolmodin> sure
03:02:26 <paolino> bast_ ping
03:02:42 <kolmodin> dcoutts: it seems to work to build it
03:02:53 <b0gg1e> morning
03:03:28 <paolino> morning b0gg1e
03:05:35 <kolmodin> dcoutts: yeah, it works fine
03:06:32 <dcoutts> kolmodin, ok good
03:07:11 <dcoutts> kolmodin, so when do you finnish your exams? :-)
03:24:41 <paolino> can I map a function to a tuple ?
03:26:35 <kolmodin> dcoutts: it turns out that I only have one exam, the 22:nd october
03:26:51 <dcoutts> kolmodin, oh that doesn't sound too bad
03:28:29 <dcoutts> paolino, mapPair f (a,b) = (f a, f b)
03:28:38 <dcoutts> is that what you mean?
03:29:58 <kolmodin> dcoutts: yeah, and it seems to be an easy one too
03:31:40 <dcoutts> kolmodin, great
03:41:07 <sam_mason> hi, I've just grabbed the latest windows build of GHC and the network code I'm playing with seems to be breaking
03:41:20 <paolino> yes dcoutts
03:49:01 <sam_mason> I get "WSAStartup not yet performed" yet I'm putting all the code in a withSocketsDo
03:49:38 <sam_mason> http://rafb.net/paste/results/0KyB4968.html  -- fails under windows but works as expected under Linux
03:53:07 <paolino> dcoutts,where mapPair is defined ?
03:56:28 <dcoutts> paolino, it's not a standard function, but as you can see it's easy to define yourself
04:01:31 <dblhelix> isn't mapPair an instance of some arrow combinator on (->)?
04:03:53 <dcoutts> I would have though that (,) would be an instance of functor
04:04:09 <dcoutts> but perhaps the instance decl wouldn't be H98
04:04:10 <JohnMeacham> uhoh. putChar _|_ == _|_  that isn't right.
04:04:35 <dcoutts> JohnMeacham, isn't it? why?
04:05:24 <dcoutts> putChar presumably needs to evaluate it's argument, so it's strict
04:05:38 <dblhelix> dcoutts: why not? instance Functor ((,) a) where fmap f (a, b) = (a, f b)
04:06:01 <dcoutts> dblhelix, ah ok, that's not the same as the map pair I gave
04:06:50 <dcoutts> if it applied f to both parts of the pair then the instance decl would not be H98
04:07:00 <dcoutts> since it'd be instance Functor ((,) a a)
04:07:14 <dcoutts> but h98 only allows distince type vars as args
04:07:21 <dcoutts> ie instance Functor ((,) a b)
04:07:48 <dblhelix> dcoutts: but pairs do really not capture the essence of a functor, I think
04:08:20 <dblhelix> class BiFunctor f where fmap2 :: (a -> c) -> (b -> d) -> f a b -> f b d
04:08:26 <dcoutts> hmm yeah
04:08:46 <dblhelix> yourMap :: (BiFunctor f) => (a -> b) -> f a a -> f b b
04:09:03 <dblhelix> yourMap f = fmap2 f f
04:09:22 <dblhelix> instance BiFunctor (,) where fmap2 f g (a, b) = (f a, g b)
04:09:46 <dblhelix> then, mapPair = yourMap
04:09:58 <dblhelix> just a thought
04:12:24 <dblhelix> dcoutts:  but anyway, my point was (and is) that where you say "if it applied f to both parts of the pair then the instance decl would not be H98", I'd say "if it applied f to both parts of the pair then it would be behave as a functor"
04:12:40 <dblhelix> /s/would be/would not
04:14:46 <rep> http://www.norvig.com/21-days.html
04:22:17 <dblhelix> ehm, fmap2 :: (a -> c) -> (b -> d) -> f a b -> f c d (but you already figured that one out, of course)
04:24:13 <ski> dcoutts : possibly putChar doesn't evaluate it's char arg before given the current world ..
04:24:37 <ski> (or did JohnMeacham state that it did ?)
04:25:58 <ski>  @eval putChar (error "apa") `seq` ()
04:26:01 <ski> @eval putChar (error "apa") `seq` ()
04:26:04 <lambdabot> ()
04:27:11 <dcoutts> ski, good point
04:28:06 <ski> the functor dcoutts wanted was '(\a -> (,) a a)' but type-lambda's aren't allowed
04:28:52 <ski> the nearest analogue would be  newtype Pair a = P (a,a)  {- or maybe data Pair a = P a a -} with instance Functor Pair
04:31:18 <ski> '(a,a)' can't even be uniquely split into 'f a', for some value of 'f' .. one possibility is f = \a -> (a,a) .. another is f = \a' -> (a,a')  .. etc
04:35:06 <JohnMeacham> dcoutts: yeah, it should be equal to a valid IO (), but won't be bottom until the IO action is executed. I think I inverted some case statements somewhere...
04:35:12 <rep> "SQL, Lisp, and Haskell are the only programming languages that I've seen where one spends more time thinking than typing."
04:35:16 <rep> - Philip Greenspun
04:35:18 <rep> hah
04:35:27 <ski> JohnMeacham,dcoutts : anyway, i think both variants of 'putChar' is ok, (unless the strictness is exactly specified), just that one is stricter than the other .. (if you compare e.g. 'compose [] = id; compose (f:fs) = f . compose fs' with 'compose [] a = a; compose (f:fs) a = f (compose fs a)' you get a similar difference in strictness)
04:36:56 <JohnMeacham> ski: I think it is pretty clear that it should not be strict in its argument... although.. I am not sure if it is specified in the report since we don't have a reference implementation of putChar..
04:37:44 <ski> mhm
04:38:33 <JohnMeacham> hmmm.. maybe not actually. it seems to be strict in its argument in ghc.
04:39:25 <JohnMeacham> however, putStr is _not_ strict in its argument...
04:40:29 <JohnMeacham> and it is lazy in its argument in 'hugs'! obviously there is some disagreement.
04:40:46 <ski> possibly both are allowed ..
04:42:09 <JohnMeacham> more likely the report is incomplete. it should definitly be specified.
04:42:46 <JohnMeacham> knowing the strictness of things is very important for reasoning about space and time behavior.
04:44:53 <dcoutts> I think it probably ought to be strict in the char arg
04:45:20 <ski> dcoutts : for what reason ?
04:46:48 <dcoutts> because otherwise when I stick an (IO ()) into some data structure (ie I don't evaluate the implicit world arg immediately) then i'm going to have a thunk for a char which I'm not going to expect. The cost of the thunk is vastly greater than the evaluated char.
04:47:26 <ski> ok
04:48:00 <dcoutts> I don't think it's likely I'm going to stick (putChar undefined) into a data structure and then never use it.
04:48:13 <dcoutts> which would be a use case for a lazy putChar
04:48:34 <dcoutts> any other compelling use cases?
04:48:49 <dblhelix> I can imagine you want to do that
04:48:54 <dcoutts> probably not if no-one has every complained about ghc's putchar being strict
04:49:02 <dcoutts> every/ever
04:49:26 <ski> maybe if the char derived from some datastructure which possibly not all should be forced to be evaluated ..
04:52:04 <dcoutts> are we sure ghc's putChar is strict?
04:52:08 <JohnMeacham> I sent a message to the list. lets see what people say.
04:52:34 <JohnMeacham> (putChar undefined `seq` ()) gave undefined in ghc, but () in hugs.
04:52:45 <dcoutts> ok
04:53:05 <dcoutts> ski, but you can still get lazyiness by letting the IO action itself be not forced
04:53:13 <dcoutts> @eval length [putChar undefined]
04:53:25 <lambdabot> 1
04:53:53 <ski> m, point
04:54:03 <JohnMeacham> that won't evaluate the list element.
04:54:20 <dcoutts> exactly
04:54:27 <JohnMeacham> since the only thing you can do with an IO () is apply it to the world, you need to use 'seq' to see the difference
04:54:33 <dcoutts> @eval let action = putChar undefined in action `seq` length [action]
04:54:36 <lambdabot> 1
04:54:49 <dcoutts> oh now i'm confusing myself :-)
04:54:52 <JohnMeacham> @eval (putChar undefined `seq` ())
04:54:54 <lambdabot> ()
04:54:59 <JohnMeacham> how strange!
04:55:01 <dcoutts> ?
04:55:05 <dcoutts> yes
04:55:16 <JohnMeacham> what version of ghc is lambdabot running?
04:55:20 <dcoutts> @version
04:55:21 <lambdabot> lambdabot 3p97, GHC 6.5 (OpenBSD i386)
04:55:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:55:36 <JohnMeacham> Prelude> putChar undefined `seq` ()
04:55:36 <JohnMeacham> *** Exception: Prelude.undefined
04:55:47 <dcoutts> I get the same with ghc-6.4.1
04:55:52 <dcoutts> in ghci
04:56:06 <rep> is there a "standard" way to format multi-line comments?
04:56:14 <JohnMeacham> ghc 6.5? perhaps it was fixed.
04:56:33 <dblhelix> JohnMeacham: are we sure it was broken, then...
04:56:34 <dblhelix> ?
04:56:53 <dcoutts> yeah, "fixed" for some definition of fixed :-)
04:56:55 <JohnMeacham> rep: I use -- on each line. I only use {- -} for commenting out blocks of code.
04:57:05 <rep> JohnMeacham ah
04:57:08 <dcoutts> rep, me too
04:57:20 <dblhelix> rep, me 2
04:57:39 * dcoutts wants hIDE to support witing multi-line comments in that style with word wraping at 80 cols
04:58:41 <dcoutts> JohnMeacham, are you going to follow up your email to not about ghc-6.5 or shall I?
04:58:48 <dcoutts> not/note
05:01:21 <JohnMeacham> I don't know, I don't have a version of 6.5 handy and I am not sure if lambdabots dynamic code loading thing is doing something odd...
05:01:40 <rep> Handles are such a pain in the ass
05:02:57 <JohnMeacham> can someone try it with a 6.5 ghci? feel free to respond if you want. I will muse on it for a while. one way jhc gets to unbox the results of getChar, the other way it gets to unbox its argument, it is an interesting dillema I hope I don't have to solve :)
05:04:10 <paolino> which is the function from [(1,2),(3,4),(5,6)] -> [(1,3,5),(2,4,6)] ?
05:04:33 <dcoutts> JohnMeacham, btw how do you do tail calls with the ANSI C backend?
05:04:46 <dcoutts> @eval unzip [(1,2),(3,4),(5,6)]
05:04:47 <ski> @type unzip
05:04:48 <lambdabot> ([1,3,5],[2,4,6])
05:04:49 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
05:04:58 <ski> paolino : i think you want this
05:05:06 <paolino> defenetly
05:05:11 <paolino> I tried dezip
05:05:15 <paolino> :)
05:05:28 <dcoutts> @hoogle dezip
05:05:51 <JohnMeacham> @hoogle antizip
05:05:57 <JohnMeacham> @hoogle rezip
05:06:05 <JohnMeacham> @hoogle zippythepinhead
05:06:11 <JohnMeacham> okay. I'll stop.
05:06:12 <ski> @hoogle winzip
05:06:33 <paolino> @google hoogle
05:06:35 <lambdabot> http://civicspacelabs.org/home/node/14218
05:06:35 * dcoutts wants spelling & type based correction suggestion for hIDE
05:07:00 * JohnMeacham want's the same thing for jhc's error messages
05:07:33 <dcoutts> eg ghc says that your value is undeclared, then we want suggestions on what you might have meant based on the spelling, module imports & types
05:07:35 * JohnMeacham is exploring bold new use's of apostrophe's
05:07:48 * paolino wants to learn haskell before getting fired
05:08:03 <JohnMeacham> Yeah. that is what I was thinking.
05:08:17 * dcoutts wonders if JohnMeacham has read "Eats, shoots and leaves"
05:08:23 <basti_> paolino: fired for not knowing haskell?
05:08:52 <ski> @whereis hoogle
05:08:53 <lambdabot> Maybe you meant: where where+
05:08:57 <ski> @where hoogle
05:08:58 <lambdabot> I know nothing about hoogle.
05:09:08 <dcoutts> @google hoogle
05:09:09 <lambdabot> http://civicspacelabs.org/home/node/14218
05:09:12 <ski> @where+ hoogle http://www-users.cs.york.ac.uk/~ndm/hoogle/
05:09:13 <lambdabot> hoogle ~> http://www-users.cs.york.ac.uk/~ndm/hoogle/
05:09:31 <JohnMeacham> no. no he has not.
05:10:00 <dcoutts> JohnMeacham, it's an excelent book for the grammer pedant in one
05:10:00 <paolino> basti_ for not translating the clusterer in Haskell (nor in C)
05:10:11 <basti_> oh
05:11:13 <earthy> @hoogle hoogle ? :)
05:11:14 <lambdabot> hoogle: Maybe.fromJust: Nothing
05:11:14 <lambdabot>  
05:11:39 <alar> if data constructor is just function then type can be defined with class constraint?
05:11:42 * dblhelix frowns
05:11:45 * dblhelix grins
05:11:49 * dblhelix laughs
05:12:09 <ski> alar : sorry ?
05:12:19 <ustenzel> JohnMeacham: (putChar undefined `seq` ()) gives () on my GHCi 6.4.1  (what are _you_ using?)
05:12:22 <alar> e.g. (Eq a)=> data ETree a = Leaf a | Node [ETree a]
05:12:46 <dblhelix> @hoogle head
05:12:47 <lambdabot> Prelude.head :: [a] -> a
05:12:47 <lambdabot> IO.hLookAhead :: Handle -> IO Char
05:13:07 <ski> alar : maybe you meant 'data Eq a => ETree a = Leaf a | Node [ETree a]' ?
05:13:11 <dblhelix> @hoogle unzip
05:13:12 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
05:13:12 <lambdabot> Prelude.unzip3 :: [(a, b, c)] -> ([a], [b], [c])
05:13:12 <lambdabot> List.unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
05:13:16 <alar> yes
05:13:26 <alar> I just don't know the right syntax
05:14:06 <ski> alar : though, at times this doesn't give you all you'd want ..
05:14:45 <ski> (alar : e.g. if one adds a 'Ord a =>' to a 'Set' type, one still can't make an 'Functor' instance)
05:15:56 <JohnMeacham> ustenzel: umm. ghci 6.4.1..
05:16:02 <alar> ski: I assume there can be special issues, but in general it should work even without h98 extensions, right?
05:16:33 <ski> i think this is not a 98 extension
05:16:53 <ustenzel> ouch.  okay, mine is actually the 6.4.1.20050801 deb from haskell-unsafe.
05:17:00 <ski> (and i know of no implemented extension which solves the issue i alluded to)
05:17:31 <alar> one more question
05:17:43 <JohnMeacham> it is also different in 6.4... how odd.
05:18:06 <alar> Mark Jones wrote: "For example, the type of the equality operator is written:
05:18:06 <alar> (==) :: Eq a ) a ! a ! Bool
05:18:06 <alar> The type variable a used here represents an arbitrary type (bound by an implicit
05:18:06 <alar> universal quantifier), but the predicate Eq a then restricts the possible choices
05:18:06 <alar> for a to types that are in Eq. More generally, functions in Haskell have types of
05:18:07 <alar> the form P )  , where P is some list of predicates and  is a monotype. If P
05:18:07 <pesco> Hey ho everybody.
05:18:09 <alar> is empty, then we usually abbreviate P )  as  . In most implementations, the
05:18:11 <alar> presence of a predicate in a function’s type indicates that an implicit parameter
05:18:13 <alar> will be added to pass some appropriate evidence for that predicate at run-time."
05:18:25 * ski wonders if having an extension which enables putting constraints in front of a data constructor, in a 'data' definition would be a good idea
05:18:37 <alar> why should class constraints be checked at runtime in statically-typed language
05:18:38 <alar> ?
05:18:51 <ski> lemme read that ..
05:19:06 <alar> omg
05:19:16 <ski> s/ ) / => /    s/ ! / -> /
05:19:23 <alar> IRC or Adobe Reader turned -> into !
05:19:55 <ski> s/  / tau / i guess :)
05:19:56 <alar> and tau into empty square
05:20:00 <alar> right
05:20:01 <ski> ;)
05:20:16 <JohnMeacham> how odd. use utf8 and it should all be dandy.
05:20:43 <alar> JohnMeacham: where should I use utf8?
05:20:54 <JohnMeacham> I don't know...
05:20:54 <pesco> alar: Everywhere! ;-)
05:21:03 <alar> :D
05:21:03 <JohnMeacham> what pesco said :)
05:21:31 <ski> alar : in most cases the implicit instance evidence can be removed .. by whole-program analysis, in worst case
05:21:51 <roconnor> @hoggle (A->A)->(A->A)
05:21:52 <lambdabot> Prelude.log :: Floating a => a -> a
05:21:52 <lambdabot> Prelude.atan :: Floating a => a -> a
05:21:52 <lambdabot> Prelude.significand :: RealFloat a => a -> a
05:22:01 <ski> alar : but for some cases, it can't .. e.g. "existential datatypes"
05:22:04 <pesco> JohnMeacham: How's jhc coming along? I bet everyone asks that, but I can't resist either... :)
05:22:08 <JohnMeacham> alanr: class constraints arn't checked at run time, what is passed at runtime (in ghc and hugs) is the actual functions that make up the class. jhc uses a different method alltogether.
05:22:40 <JohnMeacham> pesco: dandy. lots of progress today, I talked about it here quite a bit.
05:22:47 <roconnor> Is there a prelude function for computing f^k, f composed k times?
05:22:50 <ski> JohnMeacham : some partial evaluation ?
05:23:23 <integral> foldl1 (.) $ take k $ replicate f -- ?
05:23:31 <pesco> JohnMeacham: I figured. That's very cool. I'm pretty excited. I haven't tried it out, but I want to see how far it will reduce the executable size of the fingerd I wrote...
05:23:47 <pesco> GHC currently statically links it at 6MB. :/
05:24:00 <JohnMeacham> ski: for existential datatypes, it just adds another element to the datatype containing the methods, in the same way a hidden argument is added to functions.
05:24:14 <alar> ski: then typechecker should provide means to check something at runtime, to be able to handle existential datatypes, right?
05:24:26 <ski> foldr (.) id . replicate k
05:24:51 <roconnor> no prelude function then.  Okay.
05:24:57 <ski> JohnMeacham : interesting ..
05:25:02 <JohnMeacham> alanr: it need not check anything at runtime. but it does need to look up what functions to use. but it is not checking any types, just calling well-typed higher order functions
05:25:15 <ski> alar : no, no type-checking need to be done at run-time
05:25:57 <ski> alar : this is a bit similar to passing around method-tables for inclusional polymorphism in OO .. no run-time type-checking is needed
05:26:12 <rep> hm
05:26:16 <JohnMeacham> actually, now that we have rank-n polymorphism, the entire type class system can be handled as a preprocessing pass from haskell -> haskell. at least for ghc and hugs's implementation.
05:27:50 <ski> JohnMeacham : hm, you meant it added another argument to the dataconstructor ? (i for some reason read it as adding another dataconstructor)
05:27:50 <autrijus> JohnMeacham: yo
05:28:04 <autrijus> JohnMeacham: have you seen my in-progress GHC extensions? do you like them?
05:28:22 <Heffalump> hat do the current extensions do?
05:28:29 <Heffalump> s/hat/what/
05:28:40 <autrijus> Heffalump: the same one... GADT/Records/Existentials
05:28:53 <JohnMeacham> ski: nope, another argument. which is why you can't use newtype since it is no longer a single value.
05:29:00 <autrijus> submitted the working part and in-progress parts to simon and simon
05:29:12 <ski> JohnMeacham : yah
05:29:15 <JohnMeacham> autrijus: where are they? I am not sure if I have seen them.
05:29:41 <autrijus> JohnMeacham: data T = forall a. Con { label :: a }
05:30:08 <autrijus> data T a where Con { public :: a, private :: b } :: T a
05:30:09 <autrijus> that's it.
05:30:12 <astrolabe> roconner: How about interate f x !! k
05:30:41 <ski> iterate
05:31:05 <astrolabe> Hmm maybe :o
05:31:06 <JohnMeacham> ah. neat.
05:31:07 <pesco> Gotta leave. See you everyone!
05:32:03 <alar> ski: then, strictly speaking, this quote from MPJ is wrong?
05:32:11 <dblhelix> what's the {-# L #-} pragma used for??
05:32:26 <rep> is there something like "stringToInt" ?
05:32:35 <dblhelix> rep: read
05:32:35 <ski> alar : in what way, do you mean ?
05:32:50 <dblhelix> @eval read "5" :: Int
05:32:51 <JohnMeacham> dblhelix: where do you see it? looks like a strictness annotation, but people usually don't write those.
05:32:52 <lambdabot> 5
05:33:00 <rep> dblhelix oh, sweet, thanks
05:33:25 <alar> there is no checking "whether type a has instance of (==)" to find if it is possible to use it as an argument to f at runtime
05:33:26 <dblhelix> JohnMeacham: UU Parser combinators
05:33:54 <alar> autrijus: I do not understand where does b come from in your example
05:34:06 <JohnMeacham> alanr: I think he is just using 'evidence' in a different manner than usual.
05:34:18 <ski> alar : that checking happens at compile-time, yes .. did the paper say otherwise ?
05:34:33 <JohnMeacham> alanr: no, but it passes the actual function (==) needed. which can be considered evidence.
05:34:49 <dblhelix> JohnMeacham: so, L's for lazy then... makes sense... thanks!
05:35:02 <alar> yes, actual (==) should be passed along with the type
05:35:04 <JohnMeacham> alanr: but it need not check anything at run time, it just calls the function.
05:35:23 <alar> "In most implementations, the
05:35:23 <alar> presence of a predicate in a function’s type indicates that an implicit parameter
05:35:23 <alar> will be added to pass some appropriate evidence for that predicate at run-time."
05:35:40 <autrijus> alar: Con :: a -> b -> T a
05:35:49 <ski> yes, that means just what JohnMeacham said
05:35:51 <autrijus> alar: there's an implicit forall in front of it.
05:35:58 <alar> if typechecking is done statically - then what "evidence" does it need at runtime?
05:36:04 <JohnMeacham> alar : actually, ghc and hugs don't pass the type. just the functions. jhc passes just the type.
05:36:11 <autrijus> alar: data T a where forall a b. Con { public :: a, private b } :: T a
05:36:13 <ski> autrijus : hm
05:36:33 <ski> alar : the typechecking produces the evidence
05:37:08 <ski> alar : but it is passed around at run-time (if at all)
05:37:32 <basti_> lisppaste2: @url
05:37:32 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
05:37:41 <JohnMeacham> alar : it needs the actual methods to use. as in 'a' == 'b' and 1 == 2 actualy refer to two different (==) functions declared in their individual instances. what is passed is the appropriate (==) to use.
05:38:07 <lisppaste2> basti_ pasted "paolino's tree problem" at http://paste.lisp.org/display/12230
05:39:02 <ski> (autrijus : hm, i'm not fully sure it's good to be able to omit that 'forall' ..)
05:39:12 <alar> JohnMeacham: but the constraint (Eq a) is justified at compile time, so it should not persist to runtime. Only actual methods should
05:39:21 <autrijus> ski: GADT prefix omits that, so I'm not sure why recordfix should force that
05:39:50 <alar> what is lisppaste?
05:40:10 <ski> autrijus : hm 'foo :: ...a..b...' is just similar to qunatification on ordinary signatures
05:40:22 <ski> alar : a paste-bot
05:40:34 <autrijus> ski: nod. it's debatable
05:40:40 <alar> ski: what's the use of this bot?
05:40:43 <ski> alar : the methods *are* the evidence
05:41:00 <ski> alar : to paste code to discuss
05:41:33 <JohnMeacham> I get the feeling GADTs would make many things I do much simpler, but I am just not sure what they are.
05:41:40 <JohnMeacham> yet.
05:42:17 <ski> autrijus : i'm thinking of possibly having datatypes defined inside functions (with free tyvars from e.g. args or result)  .. or modules taking types as arguments
05:42:49 * ski wonders a think about GADTs
05:43:13 <ski> if types 'a' and 'b' are isomorphic, is types 'f a' and 'f b' supposed to be isomorphic, too ?
05:43:41 <basti_> ski: uhm
05:43:56 <JohnMeacham> ski: if f is a Functor then yes.
05:44:08 <JohnMeacham> ski: I think.
05:44:48 <ski> e.g. if we have 'data Foo a where F X', and 'data X = X' and 'data Y = Y',  then 'X' and 'Y' are iso, are then 'Foo X' and 'Foo Y' iso (and how then) ?
05:45:09 <ski> um 'data Foo a where F :: Foo X' i meant
05:45:40 <ski> JohnMeacham : ah, possibly Foo is not a functor here, then ..
05:47:28 <ski> alar : ok ?
05:49:08 <dcoutts> JohnMeacham, if putChar _|_ /= _|_ then what does is it? putChar _|_ = \w -> _|_ ?
05:49:40 <dcoutts> but \w -> _|_ = (_|_ :: World -> ())
05:49:54 <ski> or, at least it should be
05:49:57 <dcoutts> at least smantically they're supposed to be the same
05:50:06 <dcoutts> seq can distinguish them
05:50:09 <ski> @eval undefined `seq` ()
05:50:11 <lambdabot> Prelude.undefined
05:50:13 <ski> @eval const undefined `seq` ()
05:50:14 <lambdabot> ()
05:50:15 <dcoutts> but that's a semantic quirk
05:50:18 <ski> m
05:50:38 <dcoutts> so by that argument I'd say that putChar should be strict in both args
05:51:10 <ski> the same argument says that  undefined `seq` () = const undefined `seq` ()
05:51:25 <alar> ski: yes :)
05:51:36 <ski> good
05:52:17 <dcoutts> ski, yes because sematically seq = \_ x -> x
05:52:29 <ski> (dcoutts : btw, itym s/World -> ()/World -> ((),World)/ or something like that)
05:52:43 <dcoutts> seq is a pragmatic thing and breaks bits of the language semantics
05:53:03 <dcoutts> so when considering semantics it's usual to pretend it doesn't exist
05:53:32 <ski> i'm just saying, one could argue putChar should behave either way, it's symmetric (wrt to this)
05:53:32 <dcoutts> ski, er yes I probably do
05:54:16 <dcoutts> ski, ok so that makes it officialy undefined :-)
05:54:28 <dcoutts> since it's true that:
05:54:29 <dcoutts> putChar _|_ = _|_
05:54:33 <dcoutts> putChar _|_ = \w -> _|_
05:54:37 <ski> (possibly there may be other reasons to prefer one to another, though)
05:54:55 <ski> right
05:55:19 <dcoutts> so hugs/ghc/jhc's behaviour is all ok
05:55:35 <ski> possibly so, anyway :)
05:55:59 <dcoutts> JohnMeacham, the fact is that the language semantics cannot be used to reason about effeciency
05:56:09 <ski> (careful with those observable and refutable properties :)
05:57:32 <ski> dcoutts : not all follows from the declarative semantics ..
05:58:33 <ski> (i think JohnMeacham argued from the position from the operational semantics implemented and from what would be expected and most useful in the "common" case)
05:58:34 <dcoutts> yes, eg the semantics do not tell us about sharing
05:58:39 <ski> right
05:58:56 <JohnMeacham> dcoutts: well, we have seq, so in haskell \_ -> _|_ and _|_ are distinguishable. whether we like it or not :)
05:59:37 * earthy likes it
05:59:39 <dcoutts> JohnMeacham, but you were asking for the strictness to be defined in the report, however even if it were it wouldn't resolve your dilema
06:00:31 <JohnMeacham> hrm? sure it would. either (putChar undefined `seq` ()) should be _|_ or not.
06:00:42 <dcoutts> righ but that's not strictness
06:00:44 <ustenzel> dcoutts: I think, (putChar undefined) is (fail :: IO())
06:01:06 <JohnMeacham> no, fail is something different than _|_.. most of the time...
06:01:08 <ski> ustenzel : no
06:01:08 <dcoutts> ustenzel, no it can't be because fail is recoverable
06:01:24 <ustenzel> uhm, as is (putChar undefined), isn't it?
06:01:30 <Heffalump> yes
06:01:37 <ski> (hm, well 'undefined' is actually recoverable)
06:01:41 * Heffalump doesn't really understand how exceptions fit in with _|_, semantically.
06:02:06 <JohnMeacham> ustenzel : no.. well. sort of... pretend we are dealing with true _|_ :)
06:02:11 <dcoutts> ski, not if I define undefined differently :-)
06:02:38 <ustenzel> JohnMeacham: but we aren't... errm... I mean, we shouldn't be :)
06:02:57 <ski> maybe, "the IO world sometimes gets a fit and stops a computation which is semantically '_|_'" ?
06:03:21 <ski> dcoutts : yah, but that's obvious .. holds for 'map', etc, too
06:03:42 <dcoutts> ski, no, semantically equal but different implementation
06:04:03 <dcoutts> ski, ie a genuinely non-terminating compution rather than error "bah"
06:04:03 <ski> hm, right .. depends on how specified it is ..
06:04:26 <ski> and i think the errors-turns-into-excpetions is an extension ..
06:04:51 <dcoutts> ski, it only catches some simple non-terminations where stuff is shared properly
06:05:21 <ski> (yeah 'sometimes' as i said)
06:05:31 <dcoutts> the "fail <<loop>>" mechanism can obviously only catch some examples of non-terminaiton
06:05:36 <ski> indeed
06:05:47 <ski> (i wasn't even thinking along this)
06:06:01 <boegel> yo Oejet
06:06:26 <Oejet> Hey, boegel.
06:08:34 <ustenzel> JohnMeacham: oh, now I see it, you meant undefined is different from _|_.  true, it's undecidable whether some _|_ turns into an exception.
06:08:37 <JohnMeacham> Yeah, in jhc 'error' is never catchable. because it would actually inhibit optimizations if it had to be able to recover from error, (like, suddenly it would have to update closures it didn't need to before) and 99.9% of the time error should abort the program. I am still undecided on imprecise exceptions in general, they would require a new grin construct that I am not quite sure what it would look like.
06:09:34 <JohnMeacham> ustenzel: yeah, we are using 'undefined' as an approximation of true '_|_'.
06:09:59 <ustenzel> correct.  and I was taking (putChar undefined) quite literally.
06:10:00 <dblhelix> JohnMeacham: we have a student here that has actually extended the grin language with constructs for catchable exceptions
06:10:24 <dblhelix> JohnMeacham: he's doing a thesis project on grin
06:10:28 <ski> semantically, i think undefined and errors and exceptions (non-IO, anyway) are _|_   or is there a more detailed declarative semantics ?
06:10:56 <ski> (hm, yes, the imprecise exceptions paper possibly had such for them)
06:11:36 <JohnMeacham> dblhelix: yeah. I have seen his web site. I would love to see his work so far if it is available.
06:11:54 <ustenzel> ski: without imprecise exceptions they're all the same
06:11:59 <ski> yah
06:11:59 <JohnMeacham> dblhelix: he is the UHC guy right? or was it EHC?
06:12:51 <JohnMeacham> dblhelix: I think I can soundly add join points to grin, if exceptions can be added too, then it would be perfect all the way up to assembly generation.
06:13:07 <dblhelix> JohnMeacham: Atze (who is to defend his PhD thesis next month) is working on EHC, his master's student (Christof) is working on the grin stuff
06:14:38 <JohnMeacham> ooh. I see a thesis draft is online! sweet. time to track down a double-sided printer.
06:15:08 <dblhelix> JohnMeacham: I don't think there'll be much in it about grin, though
06:15:45 <JohnMeacham> well, mainly I want to see how he added exceptions to it.
06:16:00 <dblhelix> I don't think it's in his thesis
06:16:15 <dcoutts> JohnMeacham, I think the putChar issue might depend on your view of the IO type, is it's contents lifted or not?
06:16:18 <dblhelix> as said, the grin stuff is mainly a project of one of our master's students
06:16:53 <dcoutts> JohnMeacham, suppose we define data IO a = IO ..., then the question is: IO _|_ = _|_ or not.
06:17:41 <ski> (iirc, it's lifted in ghc)
06:17:48 <JohnMeacham> dcoutts: well, putStr is obviously _not_ strict given its definition in the report. so it is not just a matter of how you define IO.
06:18:08 * dcoutts looks up it's definition in the report
06:19:54 <dcoutts> JohnMeacham, it's not obvious to me; the report just says: putChar    =  primPutChar
06:20:19 <malcolm> I sent a couple of emails about putChar _|_ to the list, but basically, since nhc98, Hugs, and hbc all agree, can't we just gang up on ghc and say it's wrong... :-)
06:20:21 <JohnMeacham> dcoutts: yeah, perhaps it is not obvious.. hmm.. lets see how more people weigh in.
06:21:04 <ski> malcolm : we need to ensure we get it right :)
06:22:03 <JohnMeacham> BTW, I know that seq being able to tell the difference between _|_ and \_ -> _|_ weakens the "parametric qualities" (??) of the language or something like that. does anyone have a link to more information on that and what its consequences are? I have seen it mentioned on the list several times but have not seen anything formal on the subject.
06:22:13 <malcolm> I'm pretty sure JohnMeacham's first instinct was right - putChar _|_ `seq` () should evaluate to ().
06:23:05 <dblhelix> JohnMeacham: for one thing it troubles equational reasoning significantly
06:23:09 <Heffalump> JohnMeacham: Johann et al, POPL 04
06:23:12 <dcoutts> malcolm, did you see my argument? if we say putChar :: Char -> World -> (World, ()), then putChar _|_ = _|_ and putChar _|_ = \w -> _|_ are the same since \_ -> _|_ = _|_. But that is only if we assume the IO data constructor is strict. If it's non-strict then we could say putChar _|_ = IO _|_ /= _|_
06:23:41 <JohnMeacham> malcolm: it also seems that ghc can't agree with itself, 6.4 seems to go one way, and 6.4.1 another.. at least, that is what my brief testing showed.
06:23:49 <dblhelix> JohnMeacham: see the work of Patrik Jansson et al. (Chasing bottoms and a newer article)
06:24:13 <malcolm> I think semantically, _|_ is not equivalent to \a->_|_
06:24:18 <JohnMeacham> but \_ -> _|_ and _|_ are _not_ the same in haskell since we have 'seq'.
06:25:08 * ski thinks dcoutts' point was that the strictness or otherwise of IO is another contribution to the possible strictness of putChar
06:26:24 <dcoutts> ski, yes but also wheher _|_ = \_ -> _|_, the declarative semantics say it does but the operational ones do not
06:26:31 <JohnMeacham> Heffalump: thanks! exactly what I was looking for.
06:27:06 <ski> dcoutts : i think the declarative semantics actually might say not (_|_ = \_ -> _|_)
06:27:42 <malcolm> The parametricity theorem says that a parametrically polymorphic type argument cannot be inspected/modified/deconstructed in any way.
06:28:33 <dcoutts> we usually say that f = g iff f x = g x, forall x in dom f
06:28:39 * ski wonders what happens to that, if we have indexed types (aka GADTs)
06:29:00 <malcolm> But bottom is not a value of any type, so I don't think it necessarily applies when we are discussing strictness.
06:29:05 <Heffalump> use of GADTs stop things being parametrically polymorphic
06:29:06 <ski> dcoutts : but that's not true with 'seq'
06:29:14 <dcoutts> ski, indeed
06:29:59 <ski> Heffalump : ok, so 'foo :: forall a. Foo a -> Bar a' isn't parametric in 'a', then, if 'Foo' is such a type ?
06:30:12 <ski> (s/isn't/isn't generally/)
06:30:28 <boegel> yo xerox
06:31:14 <ski> (Heffalump : so what to call the 'forall' here, then, if not 'parametric polymorphism' (to distinguish from e.g. 'inclusional polymorphism'))
06:31:33 <xerox> Yo!
06:31:54 <ski> malcolm : do you consider [1,_|_,2] to be a value ?
06:32:04 <dblhelix> malcolm: bottom is a value of every type, or better: every type has its own bottom value!
06:32:17 <ski> (malcolm : or should we just refrain from reasoning about such thing ?)
06:32:18 * dcoutts agrees with dblhelix 
06:32:44 <xerox> What does the bottom value represent?
06:32:46 <Cale> xerox: hi
06:32:51 <xerox> Hello Cale!
06:32:52 <Cale> xerox: nontermination
06:32:53 <dblhelix> malcolm: that's what lifted types are about ;)
06:32:55 <malcolm> Yes, all types in Haskell (except unboxed ones) are lifted to include bottom.
06:32:59 <ski> xerox : an expression that has no proper value :)
06:33:20 <dcoutts> dblhelix, if that's true then (A -> B) has a bottom value distinct from any other value in the domain and that resolves the _|_ = \_ -> _|_ question
06:33:31 <ski> dcoutts : indeed
06:33:46 <ski> (whether this is good or not is another question)
06:33:54 <dcoutts> heh yes :-)
06:34:19 <dblhelix> dcoutts: _|_ and \_ -> _|_ are clearly different values: you can tell them apart with seq
06:34:54 <malcolm> Yeah, _|_ :: a is different from (\_ -> _|_) :: a -> b because their types are different.
06:35:24 <dblhelix> malcolm: but we were considering _|_ :: a -> b then
06:35:44 <ski> (malcolm : the question was whether '_|_ :: a -> b' and '(\_ -> _|_) :: a -> b' is (/should be) different)
06:36:05 <malcolm> Ah, but _|_ :: a -> b is distinguishable from (\_ -> _|_) :: a->b
06:36:11 <ski> yah
06:36:14 <dblhelix> @eval (\_ -> undefined) `seq` ()
06:36:15 <xerox> ski: for example?
06:36:15 <lambdabot> ()
06:36:18 <dcoutts> dblhelix, but the Haskell (suppsoedly, I've not read the whole thing) notes various properites with a side note about the expressions not containing seq, it seems to be agreed that it's an oddity and a practical hack that breaks the semantics
06:36:25 <dblhelix> @eval undefined `seq` ()
06:36:27 <lambdabot> Prelude.undefined
06:36:32 <ski> xerox : let a = a in a
06:36:38 <xerox> ski: uh-oh.
06:36:56 <dcoutts> so it depends on what semantics we use, the one that includes seq or the report which mostly doesn't
06:36:57 <ski> xerox : also stuff like   error "foo"
06:37:15 <malcolm> seq breaks parametricity because _|_ `seq` anything is different from (\_ -> _|_) `seq` anything
06:37:29 <malcolm> even if the types of the thing on the left of the seq are the same
06:37:38 <xerox> ski: I see.  Is any useful usage possible?
06:37:50 <dblhelix> dcoutts: well, indeed, it causes trouble: f.i., in the presence of seq the monad laws do not hold for most of the standard monads :)
06:38:15 <ski> xerox : bottom is used to semantically model things that does not terminate with a value
06:38:16 <dblhelix> dcoutts: many equational arguments shoud be read 'module seq'
06:38:31 <ski> (s/module/modulo/)
06:38:32 <dblhelix> dcoutts: eta equivalence does not hold in the presence of seq
06:38:48 <dblhelix> dcoutts: etc. (seq really opens pandora's box)
06:39:02 <ndm> has anyone used Visual Haskell?
06:39:09 <xerox> ndm: autrijus has
06:39:20 <dcoutts> indeed, so then what can we really say about the strictness of putChar as defined by the report
06:39:28 <ndm> i want to use the new version in teh office, but i need to install the old version first
06:39:32 <CosmicRay> hmm, quiet week in Haskell land.
06:39:33 <ndm> which seems to be impossible...
06:39:43 * ski wonders if a parallel 'or' would break stuff, too ..
06:39:45 <CosmicRay> I have only two items for HWN: TMR and endianness.
06:39:46 <malcolm> Interestingly, in strict languages like scheme and ML, they need to introduce delay+force to gain laziness
06:39:49 <CosmicRay> am I missing something?
06:39:52 <dcoutts> CosmicRay, yes
06:40:02 <ndm> haskell workshop?
06:40:14 <CosmicRay> ndm: interesting.  what list?
06:40:18 <ndm> a pretty busy week in haskell land, i'd have said
06:40:24 <ski> malcolm : or lazy datatypes
06:40:26 <dblhelix> dcoutts: still, "fast and loose reasoning is morally correct": http://www.cs.chalmers.se/~nad/publications/danielsson-et-al-fast-and-loose.html
06:40:30 <xerox> rep: CosmicRay could talk about httpd.hs?
06:40:31 <ndm> not on a list, most haskell people were off in estonia
06:40:40 <dcoutts> CosmicRay, ICFP/HW and the current discussion of the "is putChar strict" issue :-)
06:40:41 <ndm> at a physical haskell meeting
06:40:45 <rep> xerox ?
06:40:49 <CosmicRay> ndm: ahh, that would explain it.
06:40:50 <xerox> rep: for HWN
06:40:50 <dblhelix> CosmicRay: what about the present discussion about putChar and seq?
06:40:58 <rep> xerox what's HWN
06:41:04 <xerox> rep: Haskell Weekly Newsletter
06:41:12 <xerox> @where hwn
06:41:13 <lambdabot> http://sequence.complete.org/
06:41:21 <rep> xerox heh, httpd.hs sucks (for now)
06:41:24 <CosmicRay> dcoutts: ICFP was covered last week.  I'll add a writeup about the putChar thing.
06:41:40 <dcoutts> dblhelix, interesting
06:41:40 <xerox> rep: 'it's a darcs repo, try it and hack it, darcsending patches!'
06:41:54 <CosmicRay> ndm: ok, but what could I write about that meeting?  I haven't seen any news about it
06:42:34 <dcoutts> CosmicRay, you've covered the "Future of Haskell" discussion at the Haskell Workshop?
06:42:39 <ndm> CosmicRay, quite a few of the things in the program are now online
06:42:40 <rep> xerox simon marlow's httpd is much more interesting :)
06:42:43 <ndm> Visual Haskell paper
06:42:47 <rep> (and better written :P)
06:42:48 <CosmicRay> ndm: url me
06:42:48 <ndm> a few others i would guess
06:42:53 <xerox> rep: no fear
06:43:03 <ndm> CosmicRay: http://www.cs.ioc.ee/tfp-icfp-gpce05/page.php?page=prog
06:43:04 <CosmicRay> dcoutts: no, I haven't.  got a url?
06:43:04 * ski wonders if @where hwn shouldn't point to http://sequence.complete.org/hwn
06:43:11 <CosmicRay> ski: yes, it should.
06:43:18 <ndm> http://www.haskell.org/~simonmar/papers/vshaskell.pdf - the visual haskell paper
06:43:18 <xerox> @where+ hwn http://sequence.complete.org/hwn
06:43:20 <lambdabot> hwn ~> http://sequence.complete.org/hwn
06:43:26 * CosmicRay is somewhat bothered that all this haskell stuff hasn't appeared on any list.
06:43:31 <dcoutts> CosmicRay, it was covered live here on #haskell
06:43:46 <ndm> the haskell 06 stuff should be brought to the list at some point soon
06:43:54 <CosmicRay> dcoutts: not the same
06:43:57 <basti_> a new haskell standard? :)
06:44:01 <JohnMeacham> and a running commentary by me in #haskell on what I am working on at any given moment :)
06:44:11 <CosmicRay> dcoutts: that means that anybody that has an interest in it has to be on IRC at a particular time
06:44:18 <CosmicRay> dcoutts: obviously it is neat to have people in IRC
06:44:34 <CosmicRay> but it is incredibly difficult for a global community to participate fully.
06:44:36 <ndm> www.cs.uu.nl/dazzle/f08-schrage.pdf
06:44:37 <dcoutts> CosmicRay, indeed but it have a good flavour of the discussion, and should be a reasonalby basis for a quick writeup
06:44:38 <ski> CosmicRay : autrijus's been working on an extension ..
06:44:42 <xerox> ndm: there is a typo on the second line of the first paragraph, did you notice? :D
06:44:58 <xerox> '.. based on Microosft's extensible ..'
06:45:00 <CosmicRay> dcoutts: I'm not going to dredge IRC logs, but if you feel so inclined, please feel free to send me a writeup
06:45:12 <ndm> www.cs.chalmers.se/~d00nibro/hsp/hsp-hw05.pdf
06:45:16 <ndm> xerox, in what?
06:45:22 <malcolm> CosmicRay: there are searchable logs of IRC...
06:45:23 <xerox> ndm: in the Visual Haskell paper
06:45:30 <ndm> i read it when hungover...
06:45:39 <ndm> was mainly looking at the pretty screenshots
06:45:52 <dcoutts> malcolm, and we know exaclty what time the HW was on
06:45:54 <CosmicRay> malcolm: I know, but reading IRC logs still sucks
06:46:28 <CosmicRay> especially several days worth!
06:46:29 <xerox> ndm: how hard could it be to use Gtk2Hs with VisualHaskell ?
06:46:41 <ndm> xerox, hehe - very would be my guess
06:46:46 <CosmicRay> our secretary at SPI has a hard enough time summarizing a 45-minute moderated meeting by IRC ;-)
06:46:50 <ndm> well, maybe not too hard...
06:47:07 <ndm> but you wouldn't get Form's designer support, which would be the best bit of it
06:47:08 <CosmicRay> I would very much appreciate it if someone would volunteer to write up a summary
06:47:22 <CosmicRay> IRC log reading optional if you were there ;-)
06:47:43 <ndm> @seen jaffacake
06:47:44 <lambdabot> I saw jaffacake leaving #haskell 10 days, 22 hours, 48 minutes and
06:47:44 <lambdabot> 13 seconds ago, and I have missed 2 minutes and 40 seconds since
06:47:44 <lambdabot> then.
06:48:35 <JohnMeacham> Yeah, IRC is pretty sucky in a lot of ways.
06:48:41 <xerox> ndm: one could use glade!
06:48:49 <JohnMeacham> to bed with me.
06:49:00 <ndm> xerox, but then thats not using Visual Studio's power
06:49:09 <ndm> or the integrated environment to the full
06:49:10 * JohnMeacham goes to bed.
06:49:36 <xerox> I don't care.
06:50:00 <xerox> dcoutts: do you think it's possible in some way to use Gtk2Hs in Visual Haskell?
06:50:27 <dcoutts> xerox, nope
06:50:36 <dcoutts> xerox, but hIDE is written using Gtk2Hs :-)
06:50:37 <xerox> dcoutts: I could try to build windows binaries of Nymphaea at school!
06:50:56 <dcoutts> xerox, you can ust use ordinary ghc
06:51:25 <xerox> I'll try
06:51:55 <ndm> visual haskell does just use ordinary ghc
06:52:06 <ndm> so you should be able to compile and run a GTK2hs program with it
06:52:41 <dcoutts> CosmicRay, malcolm: in case you want to see the discussion the IRC log is here, starting at 15:36:33 with Heffalump saying "Future of Haskell discussion"
06:52:41 <dcoutts> http://meme.b9.com/cview.html?channel=haskell&date=050930
06:53:29 <dcoutts> it ended 16:17:12
06:55:06 <dcoutts> ndm, it uses a snapshot of ghc-6.5
06:55:33 <ndm> dcoutts, but a standard ghc, not one modified massively beyond normal development - i.e. still compiles the same programs in teh same way
06:55:35 <CosmicRay> geez, I was even online then and had no idea what was going on.
06:55:45 <dcoutts> xerox, oh I see what you mean, yes Gtk2Hs progs should complie with Visual Haskell, you just can't extend it with Gtk2Hs
06:55:56 <arjanb> CosmicRay: you could refer to autrijus journal for a few things
06:56:06 <dcoutts> xerox, but you'd need to build Gtk2Hs using the version of ghc that VS is using
06:56:49 <dcoutts> xerox, which would be a pain, since building Gtk2Hs from source on win32 is not trivial
06:56:53 <xerox> Indeed.
07:01:19 <boegel> CosmicRay: how's HWN ?
07:01:38 <CosmicRay> boegel: draft is posted at http://darcs.complete.org/hwn/prep.html
07:02:43 <boegel> CosmicRay: I won't look at the draft :) I just want to see the real thing ;)
07:03:02 <CosmicRay> in that case, I'll post it after I post my complaint about overuse of IRC ;-)
07:03:21 <Heffalump> hmm.
07:03:33 <Heffalump> Perhaps I should have been more polite when quoting John Launchbury :-)
07:04:26 <bortzmeyer> [Warning: beginner in Haskell networking] I try to talk to an HTTP server in Haskell:
07:04:34 <bortzmeyer> main = do
07:04:34 <bortzmeyer>     h <- connectTo host port
07:04:34 <bortzmeyer>     hPutStr h "GET / HTTP/1.0\r\n\r\n"
07:04:34 <bortzmeyer>     response <- hGetLine h
07:04:34 <bortzmeyer>     putStrLn response
07:04:58 <bortzmeyer> With Hugs, it works fine. With ghc, the program hangs forever. strace shows that it is in a select()
07:05:14 <bortzmeyer> ghc's fault or mine?
07:05:40 * alar doesn't see select in above code
07:06:02 * ski wonders if \r\n should possibly be just \n
07:06:12 <Igloo> You probably need to set buffering appropriately
07:06:22 <boegel> bortzmeyer: please don't most >5 lines of code in here
07:06:50 <bortzmeyer> Igloo: thanks, hSetBuffering h LineBuffering worked
07:06:55 <ski> (boegel : that was 5 lines)
07:07:11 <bortzmeyer> boegel: what should I do instead? (Beginner with IRC, too)
07:07:15 <boegel> ski: hmm, true :) still annoying though
07:07:16 <Heffalump> there's a pastebin
07:07:19 <boegel> @paste
07:07:20 <ski> @paste
07:07:20 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:07:21 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:07:22 <ski> lisppaste2 : url
07:07:23 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:07:24 <boegel> bortzmeyer: ^
07:07:26 <Heffalump> but I personally prefer short pastes
07:07:31 <Heffalump> and I think 5 lines was fine.
07:07:38 <ski> (or any other paste utility, such as e.g. rafb)
07:07:41 * Igloo agrees the above paste was fine
07:07:42 <Heffalump> I'd set the threshold for using a pastebin around 7-10 lines.
07:07:49 <alar> ski: if there is no locale twists, i.e. when '\r' & '\n' are both single-bytes, they are needed both in HTTP
07:08:00 <boegel> I just think people shouldn't paste 5 lines of code every 5 minutes
07:08:09 <ski> (alar : ok)
07:08:12 <paolino> is there anything nasty in this ?
07:08:19 <xerox> Oi paolino!
07:08:23 <paolino> represents level (Delegate representeds)=
07:08:23 <paolino>   if level == 0 then representeds
07:08:23 <paolino>   else concat $ map (represents level-1) representeds
07:08:31 <ski> boegel : :)
07:08:49 <Heffalump> boegel: yes, true
07:08:52 <paolino> the type inferred for it looks very wrong
07:09:01 <ski> paolino : possibly you want 'represents (level-1)' ?
07:09:03 * CosmicRay also gripes that the shootout people have checked their *output* into CVS.
07:09:05 <CosmicRay> grr grr grr.
07:09:16 <sethk> we have a steady state limit and a separate burst rate limit?
07:09:16 <paolino> xerox :)
07:10:11 <ski> paolino : also, there's a concatMap
07:10:24 <paolino> ski  ;)
07:10:27 <xerox> @pl concatMap
07:10:28 <lambdabot> (=<<)
07:10:30 <sethk> do type annotation lines count?  this could start to get complicated
07:10:40 <alar> what is @pl?
07:10:45 <xerox> @help @pl
07:10:46 <ski> @help pl
07:10:47 <lambdabot>  @help <command> - ask for help for <command>
07:10:47 <lambdabot>  @pointless <expr> - play with pointfree code
07:10:51 <xerox> Right.
07:11:00 <Heffalump> CosmicRay: having output in CVS can be useful when you want to track results changing
07:11:08 <alar> pointless?
07:11:11 <Heffalump> the overnight testing framework one project I work on uses does exactly that
07:11:28 <ski> alar : a pun/play on 'pointfree' vs. 'pointful'
07:11:33 <CosmicRay> Heffalump: having output in CVS makes for a merging *nightmare*
07:11:35 <xerox> alar: it generalize the pointy code to points-free code.
07:11:53 <alar> thanks
07:12:00 <CosmicRay> Heffalump: I'd say, just store it in the filesystem somewhere
07:12:17 <xerox> @pl \f xs -> xs >>= return . f
07:12:18 <lambdabot> fmap
07:12:20 <Heffalump> CosmicRay: depends on the usage scenario. In the one I refer to, no merges happen of that file, because only one thing updates it.
07:12:21 <alar> maybe there is also @parenless? :)
07:12:37 <CosmicRay> Heffalump: how do you know that will always be the case?
07:12:44 <CosmicRay> Heffalump: you're assuming that only one person ever runs the tests.
07:12:50 <CosmicRay> Heffalump: what if someone forks the project?
07:12:54 <Heffalump> only one person is ever allowed to *update* that file
07:12:57 <CosmicRay> Heffalump: what if that someone is CosmicRay? ;-)
07:13:08 <Heffalump> I wish them luck, since our CVS isn't publicly available.
07:13:11 <CosmicRay> I don't care about updating the file on alioth
07:13:13 <CosmicRay> Heffalump: yes it is
07:13:20 <Heffalump> no, it's not.
07:13:22 <CosmicRay> Heffalump: alioth.debian.org/projects/shootout
07:13:24 <CosmicRay> yes, it is.
07:13:30 <Heffalump> that's shootout, not the thing I'm referring to..
07:13:36 <CosmicRay> http://alioth.debian.org/scm/?group_id=30402
07:13:52 <CosmicRay> oh.
07:13:57 <CosmicRay> I thought we were talking about shootout.
07:14:07 <CosmicRay> *i* was talking about shootout, anyway ;-)
07:14:08 <Heffalump> >> [15:10] <Heffalump> the overnight testing framework
07:14:08 <Heffalump> >> one project I work on uses  does exactly that
07:14:20 <Heffalump> that's what I was talking about :-)
07:14:22 <CosmicRay> ah.
07:14:35 <Heffalump> in general, you can just regenerate the file after a merge, anyway.
07:14:36 <earthy> but that sentence doesn't parse
07:14:39 <Heffalump> So I don't see the real problem.
07:14:55 <CosmicRay> Heffalump: the merge will have a conflict
07:14:58 <Heffalump> earthy: it does, especially if you use the double space as a natural place to insert some parentheses
07:15:02 <CosmicRay> and you know how much fun those are in darcs.
07:15:05 <Heffalump> CosmicRay: which you can resolve by throwing away the file
07:15:11 <Heffalump> well, that's darcs' fault.
07:15:16 <CosmicRay> indeed ;-)
07:16:04 <earthy> ah! you've merged two sentences with different endings
07:16:06 <CosmicRay> and, this time I discovered there's a tarball of the shootout cvsroot out there, so I'm not trying to rebuild the entire repo over pserver anymore.
07:16:08 <CosmicRay> that sucked.
07:16:19 <CosmicRay> earthy: I think he's merged two endings with different sentences ;-)
07:16:31 <earthy> ;)
07:17:27 <Heffalump> it's one sentence, just badly constructed :-p
07:18:27 <earthy> but, yeah, there can be use in checked in output, e.g. for regression testing
07:18:58 <ski> @eval let f x = ["one","project","i","work","on"] ++ x ++ ["that"] in (f ["uses"],f ["does","exactly"])
07:19:00 <lambdabot> (["one","project","i","work","on","uses","that"],["one","project","i"
07:19:00 <lambdabot> ,"work","on","does","exactly","that"])
07:19:57 <Heffalump> earthy: precisely :-)
07:25:24 <pesco> Where's shapr? ;)
07:25:55 <boegel> @seen shapr
07:25:56 <lambdabot> I saw shapr leaving #haskell-blah, #unicycling and #haskell 15 hours,
07:25:56 <lambdabot> 58 minutes and 44 seconds ago.
07:26:02 <pesco> Hah, stupid me.
07:26:07 <boegel> up to something probably
07:26:09 * xerox sees shapr running away on his unicycle in the distance
07:26:15 <pesco> Hmm....
07:27:32 <alar> lambdabot in unicycling?
07:27:33 <pesco> When he comes back he'll probably say "Look here, I've made this Haskell web application server and this wow-theoretic tuple-space CMS to go with it!" and bounce around.
07:27:50 <alar> what's that channel about?
07:28:21 <pesco> alar: Unicycling! Riding unicycles.
07:28:41 <alar> how can lambdabot ride unicycle?
07:29:04 <pesco> Just like he can write Haskell.
07:29:29 * alar does not understand
07:29:57 <alar> it is in the nature of bots to write some nonsence, but riding - how can it be possible?
07:30:02 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051004"]' by CosmicRay
07:35:49 <dcoutts> CosmicRay, re: your email to haskell-cafe: yes that's a totaly fair comment. I would have liked to see more about ICFP/HW on the lists.
07:35:51 <xerox> @type System.IO.Error.try
07:35:52 <lambdabot> forall a. IO a -> IO (Either IOError a)
07:36:13 <xerox> @type System.IO.Error.throw
07:36:15 <lambdabot> bzzt
07:36:20 <xerox> @type System.IO.Error.catch
07:36:21 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
07:36:32 <ski> @type System.IO.Error.throwIO
07:36:34 <lambdabot> bzzt
07:36:43 <dcoutts> CosmicRay, actually I wish I had been there, but some info/summary would have been nice. I just happened to be on IRC at the time.
07:36:54 <CosmicRay> dcoutts: thanks.  I know it's hard to be there and them go write up summaries for lists.
07:37:03 <xerox> ski, is catch the only way to catch exceptions?  I remember I used another time ago.
07:37:04 * Igloo wonders what this important information is
07:37:07 <boegel> @hoogle hex
07:37:08 <lambdabot> Numeric.readHex :: Integral a => ReadS a
07:37:08 <lambdabot> Char.isHexDigit :: Char -> Bool
07:37:26 <Heffalump> I think it's a real problem of a somewhat fragmented community.
07:37:35 <Heffalump> There's the academics, the IRCers and the mailing list users.
07:37:38 <Igloo> (apart from H06, which I assume Jo(h)?n will be e-mailing a list about at some point
07:37:44 <xerox> @plugs let isHexNumber = all . map (Char.isHexDigit) in isHexNumber "cafebabe"
07:37:45 <lambdabot> <irc>:1:24:
07:37:45 <lambdabot>   Ambiguous occurrence `map'
07:37:45 <lambdabot>   It could refer to either `GHC.Base.map', imported from Data.List
07:37:45 <lambdabot> at /tmp/MBOiVk1705.hs:15:0-15
07:37:45 <lambdabot>          or `Data.Set.map', imported from Data.Set at /tmp/MBOiVk1705.
07:37:47 <lambdabot> hs:18:0-14
07:37:52 <Heffalump> and the intersection is non-zero, but relatively small.
07:37:54 <xerox> Boom boom boom.
07:38:00 <Heffalump> And information gets diffused in different ways.
07:38:03 <xerox> @plugs let isHexNumber = all . GHC.Base.map (Char.isHexDigit) in isHexNumber "cafebabe"
07:38:05 <lambdabot> <irc>:1:24: Not in scope: `GHC.Base.map'
07:38:20 <Igloo> CosmicRay: What important information are you thinking of?
07:38:21 <Heffalump> In principle, the mailing list is the ideal clearing house for making sure important things are known about.
07:38:28 <Heffalump> In practice, who should be "responsible" for this happening?
07:38:49 * Heffalump certainly didn't have time, and I think I was already performing a useful service by relaying the HW discussion to IRC.
07:38:54 <Heffalump> (along with others)
07:39:02 <ski> xerox : http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Exception.html
07:39:09 <dcoutts> Heffalump, yes it was very useful to get the live summary
07:39:13 <CosmicRay> Igloo: the "future of haskell" discussion, for one, and the things on http://use.perl.org/~autrijus/journal/26953
07:39:25 <nibro> well, Heffalump, you did the *reasonable* relaying... the rest of us were mostly spamming :)
07:41:20 <xerox> @type Data.Either.either
07:41:21 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
07:42:34 * Igloo thinks that's mostly already known stuff. I can't remember which bits have been announced on a list already, but they do generally get so once htey are more than vapourware
07:44:05 <Heffalump> CUFP had some interesting discussions too, none of which have been repeated elsewhere.
07:44:12 <Heffalump> But I expect a write-up will appear at some point.
07:44:16 <Heffalump> I think Simon Thompson was making one.
07:44:19 <Heffalump> !last kosmikus
07:44:25 <Heffalump> doh
07:44:28 <Heffalump> @seen kosmikus
07:44:29 <lambdabot> kosmikus is in #haskell. Last spoke 6 hours, 36 minutes and 15
07:44:29 <lambdabot> seconds ago.
07:44:39 <CosmicRay> Igloo: but some of this is "here's what we'd like to do next", that isn't necessarily on the list.
07:44:41 <ski> (CUFP ?)
07:44:45 <CosmicRay> Igloo: you're right that some of this has been on the list.
07:44:51 <dcoutts> Comercial Users of FP
07:44:54 <Heffalump> arguably the discussion chair (who was kosmikus this year) should arrange for someone to take notes formally.
07:44:57 <CosmicRay> Igloo: but then, if it's already public knowledge on the list, then why bother with a workshop?
07:44:59 <Heffalump> and post a summary to the list
07:44:59 <sethk> commercial
07:45:19 <CosmicRay> Igloo: I figure that if the workshop is providing useful information to people physically there, then those that aren't physically there could benefit too.
07:45:20 <Heffalump> it's evolving into "commercial + non-commercial", btw.
07:45:23 <CosmicRay> Heffalump: excellent suggestion.
07:45:34 <Heffalump> CosmicRay: entirely agreed. But I repeat, "whose responsibility should it be"?
07:45:43 <Igloo> CosmicRay: The workshop is mainly for the presentation of papers that are subsequently available from ACM
07:45:46 <Heffalump> It's not obvious that anyone in particular has such a duty.
07:45:52 <Heffalump> Igloo: the future of Haskell discussion is important
07:45:58 <Heffalump> and not echoed anywhere else by default
07:45:59 <Igloo> Like I said, I imagine JL will be mailing a list about the FoH stuff
07:46:07 <Heffalump> just his part of it
07:46:10 <CosmicRay> JL?
07:46:10 <Heffalump> what about SPJ's discussion?
07:46:21 <Heffalump> and what about JL's thing about "high assurance vs something else"?
07:46:25 <dcoutts> CosmicRay, John Launchbury (sp?)
07:46:30 <Heffalump> I'm sure he'll email about the H06 stuff.
07:46:43 <Igloo> He said it himself; he periodically mails a list about it to defeaning silence
07:49:25 <CosmicRay> fwiw, we have had this discussion in the debian community a few times as well
07:50:21 <CosmicRay> I don't mean to pick on conferences either... it's an issue but not the only one
07:51:47 <CosmicRay> Igloo: if the workshops really are relating to papers, I would find an e-mail saying, "hey, go to this URL to read the papers from this year's workshops" helpful
07:51:59 <Igloo> They aren't freely available
07:52:05 <CosmicRay> oh.
07:52:10 <CosmicRay> well then that is part of the problem
07:52:16 <Igloo> www.acm.org -> digital library -> Haskell or somesuch
07:52:41 <nibro> I think most of the authors have the papers up on their web pages
07:52:56 <nibro> so it wouldn't be hard to compile a list of URLs to post on the mailing list
07:53:02 <nibro> but again, who should do it?
07:54:01 <CosmicRay> hopefully the conference organizers would already have such a list
07:54:27 <nibro> I think it's a good thing that the HW is getting a steering committee
07:54:29 <Igloo> That would be very dodgy given the copyright situation
07:54:47 <CosmicRay> Igloo: how's posting a URL dodgy?
07:55:18 <nibro> then at least there is a focal point where one could bring up such organisational issues
07:55:26 <Oejet> CosmicRay: At least in Denmark we have rules about "deep linking".
07:55:41 <dcoutts> Igloo, if the authors have posted the papers on their own site then linking to them is fine
07:55:42 * Igloo isn't entirely sure of all the legalities, but I'm sure the ACM has the copyright of at least the collection of papers
07:56:03 <dcoutts> Igloo, in that case the authors are breaking ACM's copyright
07:56:26 <Igloo> I'm not sure about the individual paper copyrights
07:56:26 <nibro> ACM has the copyright, but authors retain the right to post a copy on their webpage
07:56:31 <dcoutts> we assume if the author has posted it themselves then it must be ok to download
07:58:49 <nibro> http://www.acm.org/pubs/copyright_form2sheridan.html
07:58:57 <nibro> that's the deal you have to sign as an author
07:59:03 <nibro> it says, among other things
07:59:16 <nibro> However, each of the authors retain the following rights:
07:59:17 <CosmicRay> geez, that's nasty.
07:59:19 <Heffalump> it would be nice if they would go open content
07:59:38 <nibro> " the right to post author-prepared versions of the work covered by ACM copyright in a personal collection on their own Home Page and on a publicly accessible server of their employer. Such posting is limited to noncommercial access and personal use by others, and must include this notice both embedded within the full text file and in the accompanying citation display as well, i.e.:"
07:59:58 <Igloo> Presumably they'd need to raise conference attendence prices or something if they did that, though
08:00:09 <CosmicRay> how so?
08:00:10 <Heffalump> Igloo: the usual model is to charge for publication
08:00:25 <Igloo> What do you mean by open content?
08:00:43 <Heffalump> and then research councils have to give higher grants
08:00:54 <Heffalump> which is taken away from the money given to unis to fund their libraries
08:00:56 <CosmicRay> so this agreement covers the haskell workshops?  or just "regular" ICFP talks?  (Sorry, I don't know how these things are structured)
08:01:03 <Heffalump> Igloo: as in freely available papers
08:01:07 <Heffalump> CosmicRay: both
08:01:12 <CosmicRay> ouch.
08:01:13 <Heffalump> haskell workshop, singular
08:01:24 <Igloo> Oh, charge for publication as in people who have papers accepted have to pay?
08:01:28 <Heffalump> Igloo: yes
08:01:31 <CosmicRay> that is insane
08:01:34 <CosmicRay> that is even more insance
08:01:40 <Heffalump> CosmicRay: no, it's the way the publication world works.
08:01:54 <Heffalump> historically, it's certainly not insane.
08:02:06 <Heffalump> and charging for publication is a sensible alternative that hopefully people will move to
08:02:16 <CosmicRay> to have to pay to present something for others to learn from?
08:02:29 <CosmicRay> the entry fees from the attendees should cover duplicating costs
08:02:30 <Heffalump> *someone* has to pay.
08:02:33 <CosmicRay> acm should have no interest in the IP
08:02:39 <Heffalump> CosmicRay: the ACM DL costs money to maintain
08:02:46 <CosmicRay> DL?
08:02:49 <Heffalump> digital library
08:02:54 <Heffalump> the place they archive things
08:02:58 <Heffalump> and that's a hugely valuable service
08:03:01 <CosmicRay> oh, sure, so the poeple that use it should pay, right?
08:03:02 <Igloo> CosmicRay: You are saying you shouldn't hav to pay to see the papers, right? So where should that missing money come from?
08:03:19 <Heffalump> CosmicRay: which they do.
08:03:24 <CosmicRay> Igloo: right.  if they want to subscribe to the DL, then fine, that can be a for-pay service.
08:03:26 <Igloo> Didn't you say having to pay to use the DL was insane earlier?
08:03:30 <Heffalump> But to make that viable, they have to have exclusive distribution rights.
08:03:39 <Heffalump> no, he said that authors giving up distribution rights is insane
08:03:40 <CosmicRay> Igloo: no, I was saying that having to pay to present at a workshop was insane.
08:03:43 <skew> no, they said paying to get your work in was insane..
08:03:50 <CosmicRay> Heffalump: giving up copyright.
08:04:14 <Igloo> Ah, right, you said that was nasty
08:04:14 <Heffalump> before the web, it was the only sane way of distributing things.
08:04:27 <Heffalump> Give people exclusive distribution rights in exchange for them distributing stuff.
08:04:35 <CosmicRay> Heffalump: the authors can give ACM the right to copy/distribute their papers, even if the authors retain copyright.
08:04:35 <Igloo> CosmicRay: If you can get everything from outside the DL then everyoen would do so and ACM couldn't exist
08:04:48 <Heffalump> CosmicRay: but then a competitor might emerge, fragmenting the market.
08:04:52 <CosmicRay> Igloo: ACM doesn't exist solely because of the DL, and if that's what happens, then fine.
08:04:55 <Heffalump> and the value of the ACM DL is the longevity.
08:05:25 <CosmicRay> Heffalump: so you pay if you use the DL.  I still don't see why the DL should be a tax on presenters at workshops.
08:05:35 <Heffalump> they've done stuff like digitising every past ACM paper.
08:05:46 <Igloo> CosmicRay: Well if you remove the DL (and hardcopy proceedings) source of income then you either need to charge more to go to the conference or charge people to present at the conference
08:05:46 <Heffalump> Which is a really great service, which would be in question if they didn't exist.
08:06:02 <CosmicRay> Igloo: or you just charge the people that use the DL for access to it.
08:06:09 <Heffalump> they are charged for access to it.
08:06:18 <CosmicRay> well then, charge them more.
08:06:23 <Igloo> Yes, but by saying authors keep copyright you are effectively closing the DL
08:06:24 <Heffalump> But if other people could make the same material available in their own collection, the competition might destroy the DL.
08:06:44 <CosmicRay> Igloo: no.  I'm saying that the authors could keep copyright but grant ACM rights to copy/distribute the paper as appropriate.
08:06:54 <Igloo> But then no-one has any reason to pay to use the DL...
08:06:58 <Heffalump> and that might make the DL unviable.
08:07:10 * Igloo gets the feeling we're going round in circles
08:07:11 <Heffalump> and preserving a paper for posterity is an important part of publication.
08:07:20 <CosmicRay> Heffalump: sure is.
08:07:26 <Heffalump> CosmicRay is of course free to start his own rival conference :-)
08:07:29 <CosmicRay> Heffalump: but let's say that I want to give a talk at a haskell workshop.
08:07:37 <CosmicRay> Heffalump: and I'd like to write up something about, say, MissingPy.
08:07:45 <CosmicRay> perhaps something that I'd like to include in the Debian package later on.
08:07:46 <Heffalump> that doesn't mean giving away copyright in MissingPy
08:07:49 <CosmicRay> I would not be able to do that.
08:07:51 <Heffalump> just in the paper.
08:07:54 <Heffalump> Well, bad luck.
08:08:02 <Heffalump> I don't think that's much of a price to pay.
08:08:03 <CosmicRay> because ACM would take the copyrgith from me and put that paper under a non-free license.
08:08:07 <CosmicRay> I disagree.
08:08:14 <Heffalump> start your own workshop then
08:08:15 <Igloo> Don't present at HW then
08:08:22 <CosmicRay> I think it's a huge problem.  I should be able to present information on a topic and not have to give the rights to ACM.
08:08:32 <Heffalump> you can. Just not at an ACM conference.
08:08:35 <Igloo> Then run your own conference
08:08:59 <Heffalump> But I would have no interest in attending, because such a conference is unlikely to be worthwhile.
08:09:00 <CosmicRay> I still don't see why ACM couldn't make do with a copyright license instead of a copyright grant.
08:09:21 <CosmicRay> Heffalump: I don't see why authors being able to retain copyright would make a conference less worthwhile.
08:09:21 <Igloo> They could, if they raised prices elsewhere
08:09:24 <Heffalump> because it would risk destroying the revenue stream required to maintain the DL.
08:09:43 <Trinsic> i am thinking if someone had created a free JavaScript (maybe instead HaskellScript in a modyfied version of say firefox) and made it as scable as said language, then it would be the next killer app. because that's all thats missing from client side processing.
08:09:43 <Heffalump> CosmicRay: because there would be little guarantee of the proceedings being preserved in a suitable way.
08:09:45 <CosmicRay> Heffalump: but you told me that the people that use the DL pay for it.
08:09:52 <Igloo> Gnngh
08:09:58 <CosmicRay> Heffalump: why?
08:10:01 <skew> Igloo: the only difference that mades would be the risk of competing libraries
08:10:01 <Heffalump> CosmicRay: yes, and if it was opened to competition then ACM would make less money out of it.
08:10:07 <CosmicRay> Heffalump: under my scenario, ACM can still do that.
08:10:19 <Igloo> skew: Exactly
08:10:22 <Heffalump> CosmicRay: because that's what academic conferences are about. Contributing to the body of work available to people in the future.
08:10:31 <CosmicRay> Heffalump: I seriously doubt that authors posting papers on their homepages and whatnot would seriously hamper the DL
08:10:35 <Heffalump> CosmicRay: but they have no guarantee of making the same revenue they do now.
08:10:38 <Heffalump> CosmicRay: it doesn't.
08:10:44 <Heffalump> But someone making their own collection could.
08:10:56 <Heffalump> what we have now is a good compromise.
08:10:58 <CosmicRay> Heffalump: those people would have to independently secure rights from authors.
08:11:01 <skew> Igloo: that's no immediate loss of revenue
08:11:05 <Heffalump> Bettwer would be charging for publication, but it'll take time to move.
08:11:10 <CosmicRay> Heffalump: no it's not.  what you have now is a monopoly with no real need to be one.
08:11:18 <Igloo> skew: It probably doesn't take long until it is
08:11:22 <CosmicRay> Heffalump: I don't see competing libraries as inherently bad.
08:11:27 <CosmicRay> in fact, I see redundancy as good.
08:11:47 <Heffalump> competition runs the risk of driving people out of business. And that's bad, cos stuff gets lost.
08:11:49 <CosmicRay> what happens if ACM perishes in some sort of evil accounting scandal?  There's no guarantee that the DL would survive
08:11:50 <Heffalump> got to go
08:12:07 <ski> sometime ago, i heard part of a talk about "Open Access Journals" http://www.doaj.org/ .. anyone's seen this ?
08:12:32 <Igloo> CosmicRay: Do you see that if competing libraries could exist then ACM's income could go down?
08:12:45 <CosmicRay> I still think it's a huge leap to go from "authors of papers can retain copyright" to "competitors to ACM DL will spring up"
08:12:48 <CosmicRay> Igloo: yes
08:13:10 <Igloo> Then for ACM to continue to make the same income they would need to increase other prices, right?
08:13:17 <skew> presumably if competeing libraries are doing well they offer some improvement?
08:13:19 <CosmicRay> Igloo: but I don't see that letting authors retain copyright would inevitably lead to that, or that ACM is unquestionably the best steward of this resource.
08:13:35 <ibid> it is my understanding that acm would accept djb's form
08:13:40 * dcoutts agrees with CosmicRay 
08:13:46 <Igloo> CosmicRay: You already suggested making a parallel Haskell library at the start fo this discussion
08:13:52 <CosmicRay> Igloo: well, they would need to replace the revenue in some form, whether it be selling advertising or increasing prices or government grants or whatnot.
08:14:13 <CosmicRay> Igloo: no, I suggested posting URLs to papers on someone's homepage to a list.
08:14:25 <skew> also, if the ACM holds the copyright, what happens if they go away, and all the copyrights go to somewhere random
08:14:36 <Igloo> So it wouldn't bother you that the links would probably slowly die in around 3 years?
08:14:41 <CosmicRay> skew: a valid concern.
08:14:56 <CosmicRay> Igloo: that would be an issue, but having those links available for people in no way means that they couldn't be in the DL.
08:15:03 <Heffalump> so we should do our best to preserve them
08:15:24 * Igloo is fairly sure that someone like you would make a competing HW library if they could
08:15:54 <CosmicRay> maybe.
08:16:13 <CosmicRay> so what's the harm in that?  if it is a better resource than the DL?
08:16:27 <CosmicRay> obviously it wouldn't have the scope, and probably not the search tools, of the DL
08:16:33 <Igloo> Which means uni libraries don't get requests to subscribe to the DL, so ACM lose money, so need to increase fees
08:16:57 <CosmicRay> which is fine by me if they're not providing an important service anymore.
08:17:18 <Igloo> The important service is the conference
08:17:40 <Heffalump> the important service is the longevity
08:18:04 <CosmicRay> Heffalump: well then, I hardly suspect my competing library would really compete with that.
08:18:14 <CosmicRay> I shoudl say, my hypothetical competing library ;-)
08:18:27 <Heffalump> Igloo just explained why it would.
08:18:58 <CosmicRay> Heffalump: so you think that people that have no need for longevity should subsidize the longevity needs of others?
08:19:03 <skew> Heffalump: you seem to be saying that the ACM library has great and unique features, but couldn't stand up to competeition. Could you explain that a little more?
08:19:09 <malcolm> Hmm, the Haskell Workshop has not always been published by the ACM.
08:19:34 <malcolm> Every year, the organisers have to put in a bid to the ACM, proving the HW is of high enough quality.
08:19:41 <Heffalump> CosmicRay: academia as a whole needs longevity.
08:19:48 <Heffalump> skew: longevity.
08:19:53 <CosmicRay> Heffalump: sure.
08:19:54 <Heffalump> I trust it more than anyone else to preserve work for a long time.
08:20:06 <skew> Heffalump: if that's a killer feature, then why can't the library survive competition>
08:20:08 <malcolm> But HW is free to publish its proceedings differently if it wishes, and as happened at least in 1995 and 1997
08:20:10 <Heffalump> the HW is an academic conference.
08:20:15 <CosmicRay> Heffalump: so then I would expect academia as a whole to see the value in the DL and continue their subscriptions
08:21:10 <malcolm> I think the main reason HW goes to ACM now is the cachet - it gives the HW greater credibility as an academic venue, rather than just some random people writing what they like.
08:22:00 <Heffalump> CosmicRay: but universities are individually driven by resource constraints
08:22:03 <Heffalump> so that effect won't happen
08:22:22 <Heffalump> whereas a collective decision to give away copyright so that they do pay is workable
08:22:24 <CosmicRay> Heffalump: but I thought that you said academia needs longevity, and you imply that the DL is the only place where they can get it.
08:22:29 <CosmicRay> Heffalump: I don't see them as having an option.
08:22:35 <Heffalump> the people who run the HW do
08:22:44 <malcolm> At least in the UK, research money depends on ratings in the research assessment exercise, which in turn depends on publishing in recognised "high-quality" venues.
08:22:51 <skew> Heffalump: if people that want more guarantee of longevity pay a little more for it, and others who don't pay less for potentially unreliable services, what's wrong?
08:23:08 <skew> Heffalump: I thought that was how the economy was supposed to work?
08:23:12 <Heffalump> skew: you shouldn't be able to publish in the hW without that guarantee.
08:23:21 <Heffalump> your work has less value to the academic community if that's not there
08:23:28 <CosmicRay> Heffalump: but that guarantee should not be tied to who owns the copyright.
08:23:40 <CosmicRay> Heffalump: I have no problem with ACM requiring that they be granted a nonexclusive right to reproduce the work
08:23:48 <Heffalump> CosmicRay: yes, I understand.
08:23:48 <CosmicRay> Heffalump: I have a problem with them demanding copyright.
08:24:01 <Heffalump> As Igloo and I have explained, the demand of copyright is at least arguably necessary for them to provide that service.
08:24:07 <Heffalump> (of longevity)
08:24:14 <skew> Heffalump: so how does giving a liscence to a reliable library failing to provide longevity?
08:24:16 <Heffalump> you don't like it, and are free to take your owrk elsewhere
08:24:34 <Heffalump> skew: which reliable library?
08:24:42 <skew> Heffalump: ACM, perhaps?
08:24:54 <Heffalump> but they are reliable because they have money to be so.
08:25:02 <skew> Heffalump: some university library? The U.S. Library of Congress?
08:25:05 <Heffalump> and giving them copyright helps them get that money
08:25:20 <Heffalump> skew: they don't run a global service
08:25:30 <CosmicRay> Heffalump: how so?
08:25:33 <skew> Heffalump: you have argued that giving them the copyright reduces the money they ask for
08:25:41 <skew> Heffalump: not that it is essential
08:25:42 <CosmicRay> Heffalump: the authors are already free to publish the work in other venues and on their homepages.
08:26:24 <skew> Heffalump: What does a few K of disk space and the amortized lifetime bandwidth of a paper cost these days?
08:27:04 <nibro> I must admit I don't really see the issue here
08:27:09 <Heffalump> quite a lot, if you want a decent guarantee of it not going away
08:27:33 <nibro> if I wanted to publish a book, as an author, I would go to a publisher and pay them to publish the book
08:27:52 <CosmicRay> nibro: let's say that I want to present a paper at a Haskell workshop and perhaps later include it with my software package.  ACM owns copyright to my paper, and I can no longer put it in my software package and expect people like Debian, who expect open licenses, to carry it due to the ACM copyright.
08:27:55 <nibro> or at the very least, if they deem my work good enough, give them exclusive rights to publish it for me
08:27:57 <Heffalump> and they'd take the copyright from you in exchange
08:28:07 <Heffalump> oh, not if you paid them.
08:28:16 <CosmicRay> Heffalump: not necessarily.  if you paid them, you'd most likely still hold copyright.
08:28:18 <Heffalump> but that's the alternative model being proposed, that I do support.
08:28:20 <Heffalump> CosmicRay: yeah.
08:28:31 <Heffalump> author pays, either in copyright, or in money.
08:28:43 <Heffalump> and I'd prefer the latter.
08:28:44 <nibro> exactly
08:29:00 <Heffalump> though it does increase barriers to entry to people outside the academic community
08:29:03 <CosmicRay> Heffalump: that places a high burden on authors without financial resources.
08:29:03 <Heffalump> which is less good
08:29:07 <Heffalump> right
08:29:07 <CosmicRay> indeed.
08:29:12 <nibro> CosmicRay, you could put it on your webpage, and distribute a link
08:29:19 <Heffalump> nibro: but he couldn't get published in HW.
08:29:31 <Heffalump> but the proportion of such people will be low, and a system of grants could be established.
08:29:38 <CosmicRay> right.  if I was going to give a talk at HW, I'd probably have my papers copied at the local Kinko's.
08:29:55 <skew> Heffalump: if you think you will make money on subscription at the other end, you might not care about taking money from authors
08:30:02 <CosmicRay> I would have no problem with my stuff being in the DL, but I do have a problem with not having rights to it anymore.
08:30:38 <Heffalump> CosmicRay: noone would let you talk at HW (in a regular refereed session) without having it in the proceedings and giving away copyright etc.
08:30:55 <Heffalump> which is as it should be, cos that's part of what HW is there for
08:31:02 <Heffalump> skew: right, but you might not.
08:31:15 <Heffalump> I think most publishers wouldn't.
08:31:22 <Heffalump> (i.e. would take money from authors)
08:31:30 <nibro> since the HW itself is sponsored by ACM, of course the papers would have to be published by them
08:31:34 <skew> Heffalump: well, most publishers are in it as a buisness
08:31:54 <skew> Heffalump: If I'm not mistaken, the ACM is a non-profit organization
08:32:19 <skew> so it's more a question of sustainability and what promotes the advance of the art
08:32:21 <Heffalump> skew: right.
08:33:20 <Philippa> bear in mind that pay-to-read also has influence on the advance of the art - anything UoN doesn't pay for undergrads to access, I can't afford
08:33:54 <skew> Philippa: that too
08:34:25 <ndm> Philippa - its not just a question of affording it, there is plenty of stuff out there, so the pay stuff gets ignored
08:34:54 <Philippa> not always, but yeah
08:35:09 <Philippa> most of the pay stuff I've been after's been old papers that were highly influential
08:35:23 <ndm> i always find them online or ignore them
08:35:26 <skew>  yeah, those are hard to find elsewhere
08:35:39 <ndm> but some subjects, namely chemistry, they pay for a lot of their papers - its standard practice
08:36:31 <ndm> the only paper i've ever wanted but not found online was by my supervisor, so i walked to his office and picked a paper copy out of his filing cabinet
08:37:26 <Philippa> heh
08:37:27 <kowey> could anyone give some starting hints for a Parsec newbie?
08:37:34 <Philippa> RTFM? :-)
08:37:34 <alar> from foreigners point of view: I agree to pay only for stuff that is translated and delivered right into my hands. All other I find online or ignore, just like ndm
08:37:38 <malcolm> As I see it, the ACM and other publishers don't bother to chase authors who make their own papers available on a homepage, so the discussion is a little "academic".
08:37:41 <Philippa> (really, it's helpful)
08:37:49 <kowey> i'm trying to make the simplest parser work, but i don't know what packages to import, include
08:37:58 <kowey> trying the example from the FM gives me errors :-)
08:38:06 <Philippa> Text.ParserCombinators.Parsec or some near relation
08:38:09 <kowey> src/geni/LexParser.lhs:42:10: Not in scope: type constructor or class `Parser'
08:38:10 <kowey> tried that
08:38:15 <kowey> hmm... digging around
08:38:47 <astrolabe> The main value journals add (as far as I can see) is that papers in them are peer reviewed, but the reviewers don't work for the journals.  I don't really understand it.
08:39:35 <Heffalump> the journals provide the infrastructure
08:39:40 <Igloo> malcolm: We started off with a suggestion the organisers should send an e-mail to the haskell list with (indirectly) all the papers presented, which I suspect the ACM wouldn't like
08:39:51 <Heffalump> I don't think they'd mind.
08:40:00 <Igloo> cv
08:40:01 <Heffalump> They might if CosmicRay starts distributing copies in Debian, though.
08:40:04 <malcolm> Surely the purpose of assigning copyright to the publisher of the entire proceedings is so that, were some rip-off merchant to put out a publication that claimed to be the HW proceedings, but changed half of the papers (e.g. to credit them to different authors, or something else underhand), then there is a legal redress to stop the bogus publication from causing bad reputation in the community.
08:41:23 <kowey> i'm still puzzled... do import Text.ParserCombinators.Parsec and friends supercede Parsec?
08:41:27 <dcoutts> but personal copyright allows that too, admititly its easier to persue infringers if an organisation holds the copyright
08:41:44 <Heffalump> it also allows the ACM to do new interesting things in future that aren't apparent now
08:41:58 <astrolabe> Heffalump:  They send copy out to reviewers, and produce paper copies which they SELL to libraries.
08:42:11 <kowey> i've imported everything Parsec-related, i'm using -package text, and it still doesn't know what "Parser" is
08:42:11 <skew> Heffalump: A think granting an unlimited non-exclusive liscence would cover that too
08:42:27 <Heffalump> skew: true.
08:42:29 <skew> anyway, enough talk about economics. Let's calculate
08:42:42 <Heffalump> astrolabe: it was definitely a useful service pre-web.
08:42:50 <Heffalump> now, it's less clear
08:42:57 <astrolabe> Heffalump: right!
08:43:26 <malcolm> skew: Copyright infringement must be pursued by the copyright owner.  It can't be done by a publisher who only holds a non-exclusive license.
08:43:29 <astrolabe> There is the ArXive model.
08:43:31 <kosmikus> Heffalump: pong?
08:44:21 <astrolabe> malcolm do you think ripping off of credit in that way is a real problem?
08:44:38 <kowey> oh geez, nevermind me... i had forgetten my \begin{code} and \end{code}... no wonder
08:44:41 <skew> malcolm: I think that is not the sort of new and non-obvious stuff Heffalump was talking about. I would be surprised if there wasn't some kind of fancy contract you could sign to cover that too
08:45:33 <malcolm> astrolabe: Since there is a well-developed framework of publishers etc to see that it doesn't happen, I can't tell whether there would be a real problem if the framework were absent.
08:46:00 <Heffalump> kosmikus: I was wondering about future "Future of Haskell" discussions having an explicitly assigned minute-taker for purposes of summarising to the mailing list etc.
08:46:31 <kosmikus> Heffalump: I've been asking several people before the discussion started and they all said "no, that won't be necessary"
08:46:58 <astrolabe> kosmikus:  People at the discussion?
08:47:22 <kosmikus> sure
08:47:23 <malcolm> skew: Sure, I'll bet there might be good ways to do it.  But some community needs to experiment with new models of copyright like that, before settling on a good solution which everyone else can adopt without worrying about unintended consequences.
08:47:49 <kosmikus> I guess I could write a summary though, if that's desired.
08:48:11 <Heffalump> kosmikus: I meant for future ones, but if you can do it for the past one too I think CosmicRay would appreciate it.
08:48:14 <Heffalump> Dunno how many other people :-)
08:48:16 <astrolabe> yes please
08:48:43 <malcolm> ditto
08:49:27 <kosmikus> I was a bit surprised that the people I asked said I shouldn't do it ...
08:49:50 <Heffalump> I would have said you should, if you'd asked me :-)
08:49:56 <Heffalump> I did try to summarise it for IRC as it was
08:50:11 <Heffalump> (so you could use the logs of that to help if you do want to make one now)
08:52:26 <alar> hello adept
08:53:05 <adept> alar:
08:53:35 <kosmikus> Heffalump: how many hours ago did you summarize?
08:53:47 * earthy would like to see some summary of the future of haskell talk
08:54:03 <earthy> kosmikus: it was summarized during the talk, so it should be easy to find in the logs
08:54:14 <astrolabe> kosmikus:  It started at 15:35 IIRC
08:54:21 <alar> is there a haskell course in Kiev university?
08:54:22 <astrolabe> 15:36
08:55:04 <Heffalump> kosmikus: on the HW day
08:55:17 <kosmikus> oh, I see
08:55:21 <kosmikus> you relayed it online
08:55:57 <dcoutts> kosmikus, http://meme.b9.com/cview.html?channel=haskell&date=050930
08:56:06 <dcoutts> search in the page for "Future of Haskell discussion"
08:56:47 <adept> alar: no, there is none. However we have (rather I had) a lot of theory: l. calculus, automata, turing machines, computability, that sort of thing
08:57:25 <alar> just standard CS stuff
08:58:02 <sethk> alar, calculus is often a shorthand for integral-differential calculus, which has little or nothing to do with cs
08:58:55 <skew> sethk: l[ambda] calculus is quite relevant
08:59:05 <sethk> skew, yes, but that's not what he meant
08:59:17 <alar> sethk: that IS integral-differential calculus
08:59:37 <sethk> alar, what is?
08:59:39 <skew> adept: what did "l. calculus" mean then?
08:59:53 <alar> the calculus adept mentioned
09:00:05 <basti_> "lambda calculus"?
09:00:07 <basti_> :D
09:00:27 <adept> actually, we had both, but I mentioned lambda calculus explicitly
09:00:45 <sethk> adept, ok, but I was answering someone else
09:00:46 <alar> adept: in MSU there is no FP either :)
09:00:56 <sethk> possibly by mistake  :)
09:01:03 <adept> hardly
09:01:06 <sethk> alar, that's what I assumed
09:01:45 <sethk> alar, but apparently not
09:01:51 <alar> I can hardly imagine mathematical university speciality without integral-differential calculus :))
09:02:10 <sethk> alar, no, of course not.  the problem is that it is often the _only_ calculus
09:02:21 <alar> in CS?
09:02:29 <alar> can't beleive
09:02:41 <sethk> alar, believe
09:02:52 <alar> then why is it called CS?
09:03:03 <alar> not applied mathematics
09:03:11 <smott> we don't have calculus in math uni. here, we have analysis
09:03:31 <sethk> smott, that's more correct
09:03:37 <alar> smott: that's only terminology
09:03:46 <kosmikus> dcoutts: thanks
09:03:52 <sethk> smott, but a typical analysis course would include integral and differential calculus, certainly
09:03:59 <kosmikus> Heffalump: thanks, too; looks like a useful source of information
09:05:17 <pejo> sethk, I think you're generalizing a bit much when you say calculus/analysis has nothing to do with CS.
09:05:43 <sethk> pejo, I don't think so.  You might have a problem domain in any area of science or math
09:05:49 <sethk> pejo, but that isn't part of cs, per se
09:06:02 <alar> pejo: almost nothing to do with CS
09:06:10 <alar> that might be better :)
09:06:51 <sethk> pejo, having a very very extensive background in that area of math, I think I would have run into those areas of cs that might intersect with it.
09:11:17 <alar> .éãóêí òøñëûóêì
09:12:17 <pejo> sethk, seems to be lots of statistics and yucky stuff in signal processing, control systems, networking stuff, etc.
09:13:14 <Oejet> alar: Ð§Ñ‚Ð¾?
09:13:27 <sethk> pejo, yes, certainly, but those are problem domains
09:13:37 <sethk> pejo, they aren't cs, per se.
09:13:55 <sethk> pejo, I might solve a signal processing problem with a DSP, but that doesn't make the mathematics part of CS
09:15:33 <ProfTeggy> off to a Jamiroquai concert, nice evening all
09:15:36 <pejo> sethk, how you perform your calculations for your signal processing problem is just an implementation issue.
09:16:03 <Oejet> ProfTeggy: Bye.
09:16:10 <sethk> pejo, true.  I might perform them with a custom designed analog circuit
09:16:41 * astrolabe thinks numerical analysis is part of comuter science, and that a lot of it requires calculus.
09:17:22 <pejo> astrolabe, did you read wikipedia for cs? ;)
09:18:08 <astrolabe> Yes :), but just to get evidence for my opinions.
09:25:36 <alar> Oejet: failed to switch charset
09:27:45 <Heffalump> kosmikus: I'd suggest that someone other than the chair is asked to take notes if this is considered worth doing in future, btw.
09:30:35 <humasect> @eval (1,2) . (3,4)
09:30:40 <lambdabot> <irc>:1:0:
09:30:40 <lambdabot>   Couldn't match `b -> c' against `(a, b1)'
09:30:40 <lambdabot>   Expected type: b -> c
09:30:40 <lambdabot>   Inferred type: (a, b1)
09:30:40 <lambdabot>   In the first argument of `(.)', namely `(1, 2)'
09:30:42 <lambdabot>   In the definition of `xxxx': xxxx = (1, 2) . (3, 4)
09:34:25 <skolulph> why is not
09:34:27 <skolulph> f :: Num a => (a -> a) -> Integer -> Integer
09:34:27 <skolulph> f m i = m i
09:34:30 <skolulph> allowed?
09:35:35 <Heffalump> because it doesn't work
09:35:46 <skolulph> hm
09:35:49 <Heffalump> if you pass it (Int -> Int) as an argument, it can't handle the Integer it claims to
09:36:23 <Heffalump> did you mean f :: (forall a . Num a => a -> a) -> Integer -> Integer ?
09:36:33 <Heffalump> which would work, but isn't valid Haskell 98
09:36:47 <xerox> @let f m i = m i in f (id) 1
09:36:48 <lambdabot> Unknown command, try @listcommands.
09:36:52 <xerox> @plugs let f m i = m i in f (id) 1
09:36:54 <lambdabot> 1
09:37:52 <Pistahh> whats the difference between @plugs and @eval ?
09:38:50 <paolino> let s=randomRs (0,4) $ mkStdGen (1::Int) .As usual I can't parse the error
09:39:19 <xerox> Pistahh: 4 letters
09:40:39 <skolulph> hm
09:40:55 <skolulph> so yeah it was obviously wrong
09:41:46 <alar> ÐóààôäãüçÆ öðí øû øå øòìôäøâ ð98,
09:41:57 <sethk> @(plugs - eval)
09:41:58 <lambdabot> <irc>:1:6: parse error on input `)'
09:42:00 <alar> Heffalump: why is it invalid?
09:42:25 <Heffalump> alar: my changed version that isn't H98, or the original completely type-incorrect code?
09:42:41 <Heffalump> mine isn't H98 cos it has a rank-two type (quantifier not at the top-level)
09:43:25 <alar> Heffalump: I just don't see where it contradicts h98
09:43:25 <skolulph> I want to be able to pass a function that can handle both negation of Integer and Double to a function, i.e. negate
09:43:36 <Heffalump> alar: the type does.
09:43:45 <Heffalump> skolulph: ok, you need the type I gave.
09:43:54 <Heffalump> and thus to accept going outside Haskell 98
09:43:57 <skolulph> The function will use the different versions depending on input
09:44:19 <Heffalump> alar: H98 doesn't even allow explicit specification of quantifiers (I don't think)
09:44:23 <Igloo> You might be able to define a class for what you want
09:44:24 <Heffalump> and that's essential to giving it a type
09:44:31 <xerox> Fundeps!
09:44:49 <Heffalump> igloo: how?
09:45:10 <Heffalump> there's still a need to pass in a polymorphic function that can be used at multiple types
09:45:10 <Igloo> It depends if you really need to pass teh same actual value at different types
09:45:19 <Heffalump> which implies nested quantification
09:45:42 <Igloo> f :: Foo a => (a -> a) -> a -> a   might do what skolulph really wants
09:45:46 <paolino> can someeone explain me how to use randomRs ?
09:45:50 <paolino> please
09:46:05 <Heffalump> igloo: not if his real function does some pattern matching then picks the type to apply to
09:46:17 <Igloo> That's why I said might
09:46:56 <Heffalump> true
09:47:19 <alar> lambdabot doesn't answer to my private queries
09:47:22 <alar> strange
09:47:43 <Igloo> alar: Are you getting messages from the server that your nick isn't registered?
09:47:57 <alar> I've just registered the nick
09:48:40 <alar> I receive neither bot answers nor server messages about unregistered nick now
09:49:32 <Igloo> Oh, lambdabot isn't registered
09:50:05 <xerox> alar: check that NickServ has an option to let unregistered people talk to you.
09:53:03 <alar> theese concerns about registering @ freenode seem strange
09:53:39 <Heffalump> it's to stop spam
09:54:06 <alar> =NickServ=            Nickname: lambdabot
09:54:06 <alar>  =NickServ=          Registered: 4 weeks 6 days (6h 48m 45s) ago
09:54:06 <alar>  =NickServ=           Last Seen: 3 days (7h 16m 34s) ago
09:54:06 <alar>  =NickServ=   Last Seen Address: n=lambdabo@129.94.174.82
09:54:21 <alar> and how does it stop spam?
09:54:33 <Heffalump> because only registered users can msg
09:54:41 <Heffalump> igloo: do you know if lambdabot has a nickserv password, and what it is?
09:54:55 <alar> one can easily register and start spamming
09:54:59 <Igloo> I believe it does, but I don't know it
09:55:25 <astrolabe> but spammers don't make the effort
09:55:49 <alar> strange spammers :)
09:55:57 <autrijus> alar: it's the same idea as hashcash :)
09:56:07 <autrijus> spammer will flow to places that demands less effort.
09:56:23 <alar> ah
09:56:42 <sethk> especially mechanical spammers
09:56:50 <sethk> they just probe for weaknesses
09:57:10 <astrolabe> spam only works economically because it is easier to send it than to read it.  It pushes work onto the receivers.
09:57:27 <alar> mechanical spammers are better killed by bots
09:59:49 <sethk> the spammers are usually ahead of the bots
10:00:41 <Heffalump> presumably it's easier to make people jump through hoops to register than it is to make them jump through hoops each time they send a message
10:00:49 <Heffalump> and if spammers start registering, you just increase the hoops
10:03:40 <alar> @karma+ xerox
10:03:41 <lambdabot> xerox's karma raised to 8.
10:03:41 <TheHunter> I doubt that forcing spammers to spam channels instead of individuals qualifies as a reasonable countermeasure against spam.
10:04:44 * xerox boings randomly
10:04:54 <autrijus> I think I'd rather people spamming channels that /msg'ing me.
10:04:58 <autrijus> s/that/than/
10:05:10 <Heffalump> yeah
10:05:22 <autrijus> the mental stress levels are imarkedly different
10:06:22 <astrolabe> The spammers might not even know they are blocked.
10:06:52 <TheHunter> well, it's arguably a very bad situation when a lot of people aren't aware that the pms they send to others are (almost) silently dropped.
10:07:05 <Heffalump> yes, that's true.
10:09:28 <Lemmih> Hi davve.
10:09:54 <davve> hi!
10:09:56 <Lemmih> Jeg er din navne bror (:
10:10:03 <davve> ah =)
10:13:17 <dcoutts> ha ha! I've got the hIDE html viewer working!
10:13:24 <Lemmih> Hurrah!
10:13:46 <dcoutts> GtkMozEmbed has a slightly odd bug with reparenting which I had to work around
10:13:51 <xerox> Horray, indeed!
10:14:02 <work_metaperl> first there was DrScheme, now there shall be: DrHaskell
10:14:17 <alar> is there a stable version of hIDE?
10:14:25 <alar> or just work-in-progress?
10:14:36 <dcoutts> alar, not yet, work in progress
10:14:44 <work_metaperl> inquiring minds want to browse around and see it
10:15:11 <dcoutts> Lemmih, in the end it's just a matter of explicitly hiding the widget before removing it from the container and then showing it again when adding it back
10:15:19 <psi> screenshots!
10:15:46 <dcoutts> Lemmih, one shouldn't have to do that but it doesn't hurt for other widgets so it's ok
10:15:48 * Lemmih found out that he is the cause of the ghc-api problems.
10:15:56 <dcoutts> Lemmih, oh really? :-)
10:16:27 <dcoutts> Lemmih, don't think of it that way, think of it as you figureing out the cause of the bug :-)
10:16:48 <Lemmih> heh
10:17:04 <dcoutts> Lemmih, does that mean we can fix it?
10:17:17 <dcoutts> and why does ghc report such an odd error?
10:17:39 <dcoutts> work_metaperl, well you can build it if you're brave
10:17:50 <Lemmih> dcoutts: I don't know exactly what's wrong.
10:18:44 <Lemmih> Oh, and it's not the building problems I'm referring to.
10:22:42 * work_metaperl is not brave. he has SJT to attend to
10:24:55 <Lemmih> What's up with all the Haskellers in here?
10:25:43 <astrolabe> lazyness ;)
10:25:56 <xerox> Unicycling!
10:26:00 <xerox> Lemmih: do you unicycle too?
10:26:07 <Lemmih> Yeah.
10:26:28 <xerox> As a transportation method, or to do tricks & co. ?
10:26:56 <Lemmih> Mostly the latter.
10:27:13 <dcoutts> Lemmih, I didn't know you were another unicycler?
10:27:20 <dcoutts> how many of us are there?
10:27:26 <xerox> Cool!  I'll order my first unicycle this week... !
10:27:34 <Korollary> all of you join #haskell-unicycle
10:27:35 <Lemmih> Neat!
10:27:37 * dcoutts counts shapr, xerox, Lemmih and himself
10:28:06 * xerox joins, Lemmih parts :D
10:28:33 <Lemmih> #unicyclist is the place.
10:28:39 <xerox> There is #unicycling yeah
10:28:43 <xerox> oh, -st.
10:29:06 <skolulph> unicycling!
10:29:10 <Korollary> apparently, lambdabot unicycles as well...
10:29:27 <skolulph> xerox: have you ordered anything yet?
10:29:43 <xerox> skolulph: Nope.
10:29:56 <skolulph> Oh this week
10:30:01 <Korollary> anybody watching the sun+google webcast ?
10:30:02 * skolulph actually reads the history
10:30:27 <xerox> skolulph: I'm going to order this one: http://www.einradladen.net/catalog/product_info.php?cPath=2&products_id=167
10:31:39 <astrolabe> korollary: link?
10:31:57 <alar> dcoutts: don't forget lambdabot
10:32:04 <skolulph> xerox: that's a nice unicycle! :)
10:32:09 <Korollary> astrolabe: http://wcdata.sun.com/webcast/archives/VIP-2166/
10:32:15 <astrolabe> ta
10:33:18 <xerox> skolulph: so you do unicycle?
10:34:42 <skolulph> xerox: sure
10:35:11 <skolulph> http://enhjulingsfolket.se/img/photos.big/easyride.jpg
10:35:27 <xerox> WOO!
10:36:28 <Pistahh> skolulph: did you jump up there from the ground?
10:36:35 * SamB wonders what the 486 is for in an acorn or compatible
10:37:41 <skolulph> Pistahh: no, i just mounted and balanced on it for a while and jumped down ;)
10:38:12 <Pistahh> skolulph: how were your balls after the jump? ;)
10:38:17 <xerox> skolulph: the shins protector are something I must get...
10:38:29 <xerox> It costs quite much on municycle.com, tough.
10:38:34 <skolulph> yeah the pedals are nasty
10:39:22 <skolulph> http://life.csbnet.se/~ulfc/porr/eddie/DSCN0880.JPG
10:39:47 <skolulph> my last encounter with Snafu-pedals, they told me that I had to stitch it since it was like 1/2 cm deep and 5 cm long
10:40:02 <SamB> hmm, apparantly in a RiscPc it is for running windows... odd!
10:40:19 <xerox> Ouch.  I had some incidents with skateboards too :-\
10:43:38 <xerox> skolulph: that uni is 20" or 24" ?
10:44:46 <skolulph> it's a KH 24"
10:46:38 * basti_ invites unicyclers over to #haskell-blah, after all, thats what that channel is for
10:47:22 <work_metaperl> basti_: quit doing type checking for channel content
10:47:34 * basti_ frowns
10:47:59 <work_metaperl> converseOk chan content :: Channel -> String -> Bool
10:48:09 <work_metaperl> ooops
10:48:09 <basti_> its just... i've seen too many channels going down the road from theme-centered to person-centered
10:48:18 <work_metaperl> converseOk :: Channel -> String -> Bool
10:48:23 <alar> basti_: is #unicycling bad for you?
10:48:28 <basti_> not at all!
10:48:38 <work_metaperl> converseOk #haskell (Topic Unicycling) = False
10:48:49 <basti_> i dont mind unicyclers
10:49:19 <basti_> but if some n00b comes here he'll think "typical IRC, aimless babbling about anything, no valuable info there"
10:53:59 <astrolabe> It would be useful if the prelude included lengthGT :: [a] -> Int -> Bool
10:54:52 <Korollary> what is it supposed to do ?
10:55:10 <astrolabe> Sorry, finds if a list has more than n elements.
10:55:53 <basti_> that could be done quicker than length too.
10:56:13 <astrolabe> basti_: right, and for infinite lists.
10:56:19 * basti_ nods
10:56:36 <paolino_> I have an error in GHCi, can I paste it here ?
10:56:48 <Korollary> paolino_: use lisppaste if you can
10:57:04 <basti_> but its not a thing so common that it'd fit into the prelude
10:57:26 <cjs> Lisppaste? Is that like http://rafb.net/paste/ ?
10:57:32 <basti_> lisppaste2: @url
10:57:32 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:57:56 <basti_> yes, and it sends a message to the channel after you're done
10:58:26 <astrolabe> basti: hmm, must be my coding style.
10:58:57 <lisppaste2> paolino_ pasted "Error in System.Random" at http://paste.lisp.org/display/12235
10:59:03 <basti_> i mean, i use length rarely
10:59:19 <basti_> thus even more rarely in conjunction with >
10:59:47 <basti_> paolino_: make a type annotation
11:00:11 * Korollary wonders why length :: [a] -> Int and not length :: (Integral b) => [a] -> b
11:00:30 <paolino_> I'm unaware of what it is
11:00:35 <paolino_> where ?
11:00:46 <basti_> something like "a::Int"
11:00:53 <Heffalump> genericLength exists
11:00:57 <paolino_> a ?
11:01:04 <Korollary> @type genericLength
11:01:05 <lambdabot> bzzt
11:01:07 <Heffalump> Korollary: but length gives less confusing type errors (I think that's the reason it's that way)
11:01:14 <Heffalump> @type List.genericLength
11:01:15 <lambdabot> forall i b. (Num i) => [b] -> i
11:01:27 <basti_> paolino_: basically that message means "i've many types to chose from and i'm confused."
11:01:45 <basti_> you need to give a hint what type you're actually referring to
11:01:46 <paolino_> basti_ which variable should I annotate ?
11:01:52 <basti_> I didnt say
11:01:54 <basti_> whoops
11:02:01 <basti_> you can annotate any expression
11:02:03 <Korollary> Heffalump: Thanks
11:02:21 <basti_> you should think about which type is ambigious
11:02:36 <basti_> usually this has to do with numbers, in some way
11:03:36 <basti_> paolino_: or would you prefer me directly telling you the solution, which wouldnt make you learn though? ;)
11:03:48 <paolino_> as a constraint on the result ?
11:03:59 <paolino_> :: [Int}
11:04:13 <paolino_> yep
11:04:16 <basti_> :D
11:04:24 <basti_> now why did that break?
11:04:34 <paolino_> more confused than before anyway, it works
11:04:48 <basti_> what was the problem, to start with?
11:05:20 <basti_> (I've discovered that putting it to words helps understanding, thats why I'm asking you this)
11:05:57 <paolino_> because no function uses the reesult ?
11:06:04 <basti_> mmm not exactly
11:06:23 <basti_> using a function might impose constraints that would hide the problem though
11:06:38 <basti_> actually two functions are using the result
11:06:40 <paolino_> oh
11:06:51 <basti_> take and then show (inside the environment, to display the result)
11:06:59 <paolino_> right
11:07:02 <basti_> but lets look at the types involved
11:07:05 <basti_> @type show
11:07:06 <lambdabot> forall a. (Show a) => a -> String
11:07:07 <basti_> @type take
11:07:08 <lambdabot> forall a. Int -> [a] -> [a]
11:07:09 <basti_> @type randoms
11:07:10 <lambdabot> bzzt
11:07:16 <basti_> @type System.Random.randoms
11:07:17 <lambdabot> forall a g.
11:07:17 <lambdabot> (System.Random.Random a, System.Random.RandomGen g) =>
11:07:17 <lambdabot> g -> [a]
11:07:27 <basti_> do you notice something?
11:07:52 <paolino_> the generator is somewhat an alien
11:07:56 <basti_> uhm
11:07:58 <basti_> besides that
11:08:00 <basti_> ;)
11:08:27 <basti_> i mean lets look at:
11:08:29 <basti_> @type take
11:08:30 <lambdabot> forall a. Int -> [a] -> [a]
11:08:32 <b0gg1e> bye.
11:08:46 <paolino_> forall a
11:08:58 <basti_> yes there is a forall a in all functions.
11:09:15 <basti_> what would have happened if you had taken a random number from your list and fed it into take as first parameter?
11:09:51 <basti_> and, uhm, why?
11:09:55 <paolino_> it would have be casted to Int
11:10:03 <basti_> not "casted"
11:10:10 <basti_> but you're right
11:10:22 <basti_> the "forall" things are type parameters
11:10:46 <basti_> but type parameters behave differently than value parameters
11:11:11 <basti_> they're calculated at run time, and constant during the program run
11:11:31 <basti_> at many points in your program you're making statements about types, often without noticing it
11:11:49 <basti_> if you use "take", you make the statement that the first parameter is an Int
11:12:14 <basti_> so if you fed a random number from your list into "take" as first parameter
11:12:23 <basti_> the compiler would spread that information through the program
11:12:35 <basti_> tracing where the value come from
11:12:53 <basti_> instantiating every "forall a" that refers to that value with "Int"
11:13:04 <basti_> and checking if that breaks anything
11:13:10 <basti_> (usually it does not)
11:13:28 <basti_> but what if you don't have a function like "take" that imposes "Int"?
11:13:39 <basti_> the compiler would just have "forall a" then
11:14:07 <basti_> thats the ambigious type variable that it referred to
11:14:25 <basti_> got that? :)
11:14:33 * basti_ monadic monologue finished
11:14:46 <paolino_> ok, I'm start seing the paint of type inference ,thanks
11:15:05 <basti_> the point or the paint?
11:15:21 <paolino_> should produce more of those, paint/figure
11:15:32 * autrijus mumbles sometihng about type interference.
11:15:35 <cjs> So is listGT typically defined as [a] -> Int -> Bool, and not Int -> [a] -> Bool?
11:15:49 <basti_> you mean, background/foreground illusion style visual phenomena? ;)
11:16:44 * astrolabe finds it helpful to include lots of superfluous type declarations.
11:17:00 <paolino_> ;) and useful monologue
11:17:03 <basti_> for functions, for example
11:17:22 <basti_> thats very useful when reading code
11:18:04 <astrolabe> basti_: yes, and it helps the compiler catch bugs too.
11:18:09 <basti_> yes
11:18:24 <basti_> paolino recently had a "f x-1" style bug
11:18:40 <basti_> it compiled correctly but the type was bizarre
11:19:03 <basti_> (he intended "f (x-1)", which would have been caught with type annotations)
11:19:30 * paolino_ relaxes eating with his children / his children .bbsol
11:20:04 <basti_> 'k
11:29:15 <sethk> basti_, don't eat the children - they give you indigestion
11:29:49 <basti_> uhhmmm i didn
11:29:53 <basti_> 't consider that
11:29:54 <basti_> argh
11:30:02 <basti_> both forearms "fell asleep"
11:31:07 <cjs> Can I ask some beginner-type questions?
11:31:35 <astrolabe> cjs:  Yes, just ask.
11:32:59 <cjs> "read_numbers :: IO ([a])" would be the signature of a function that returns a list of numbers read from stdin, right? Can I simulate this while I'm working on another piece of code? E.g., "read_numbers = IO ([1, 2, 3)" or something like that?
11:33:40 <basti_> uhm?
11:33:46 <basti_> read_numbers = return [1,2,3] maybe? :D
11:33:48 * goron thanks wikipedia
11:34:06 <heatsink> Is there some information online on how to call haskell from C?  I'm having trouble figuring out how to invoke the linker.
11:34:21 <cjs> Ah, return! thanks.
11:34:22 <Korollary> heatsink: did you check the wiki page ?
11:34:37 <basti_> heatsink: the calling style is very similar to gcc.
11:35:15 <heatsink> Korollary: I see lots of stuff on the wiki for calling C from haskell, not the other way around.
11:35:56 <goron> heatsink: The FFI should be enough (in theory).
11:36:26 <goron> (that's short for the specs of the FFI)
11:36:47 <heatsink> Well, I'm not having too much trouble writing the program.  My current problems are compiling and linking.
11:36:57 <astrolabe> cjs: If you can it would be good to do all your processing  of the [a] in a pure function (ie without the IO) and then just have the IO on the outside function.
11:37:20 * heatsink is practicing with a toy example: write "fibonacci" in haskell and call it from C
11:37:43 <cjs> I'm still getting the usual inexplicable HUGS errors, depending on whether I include the type signature or not.
11:38:31 <cjs> astrolabe: I think I am doing that, more or less. It's exercise 3.10 from YAHT. At the top level I read, process and print, basically, each of these is a separate set of functions.
11:38:51 <sethk> cjs, I know they do appear to be inexplicable, and it takes some work to understand them, by they are not in fact inexplicable.  Believe it or not.  :)
11:39:02 <sethk> cjs, I'm still working on it to some degree
11:39:11 <basti_> i mean
11:39:18 <basti_> theres @ghc you know
11:39:18 <sethk> cjs, but I've convinced my self that it is possible.  :)
11:39:19 <basti_> @ghc
11:39:20 <lambdabot>  Urk! Inventing strangely-kinded void TyCon: ZCt{tc a2AN} (* -> *) ->
11:39:20 <lambdabot> * -> *
11:39:20 <cjs> Well, "inexplicable to the uninitiated." And I thought that Dianetics was hard! :-)
11:39:28 <basti_> @ghc
11:39:28 <lambdabot>  the eta-reduction property does not hold
11:39:32 <basti_> etc.
11:39:39 <goron> heatsink: If it works (your simple function), please post it to the wiki.
11:39:56 <basti_> if I dig through that, I find that I dont have a clue what about half of them means.
11:39:57 <heatsink> ok
11:40:27 <lisppaste2> cjs pasted "hugs errors" at http://paste.lisp.org/display/12237
11:40:30 <basti_> but otoh i know pretty well that people wrote that with something in mind
11:41:32 <Heffalump> cjs: the second error is the monomorphism restriction biting
11:41:35 <Heffalump> give read_numbers a type signature
11:41:37 <astrolabe> Maybe a page on the wiki explaining compiler errors would be useful.
11:41:49 <Heffalump> oh, and the first one is you trying to give it a type signature but getting it wrong :-)
11:41:51 <basti_> cjs: uhm, "5" doesn't have a type in haskell
11:42:02 <Heffalump> the error explains what to do.
11:42:08 * basti_ nods
11:42:13 <Heffalump> it says that the constraints should be Num a, but you haven't given any.
11:42:16 <cjs> Actually, there is a hugs error page somewhere. But "the monomorphism restriction" is not entirely clear at this stage of my studies....
11:42:17 <Blicero> I've been trying to find an example of a main loop that reads one line at a time from stdin until eof. can anyone help?
11:42:18 <Heffalump> (in the explicit type signature)
11:42:26 <Heffalump> cjs: right, and I'd rather not explain.
11:42:39 <cjs> What's the type signature of something that reads in numbers and returns them as an array?
11:42:41 <sethk> cjs, I've been cheating about that, using ghci with the --f-no-monomorphism
11:42:49 <basti_> Blicero: we can construct that easily
11:42:49 <goron> I for one probably won't forget how the monomorhism restriction works...
11:42:53 <Heffalump> Basically the type checker deliberately refuses to infer types of top-level bindings if they would have a type class in them and the left hand side has no arguments.
11:42:53 <sethk> cjs, (I think it is two dashes, but might be one)
11:43:05 <goron> er morphism.
11:43:21 <cjs> Heffalump: oh, I'm starting to understand.
11:43:34 <sethk> goron, you didn't say you wouldn't forget how to spell it, just how it works.  :)
11:43:53 <goron> sethk: Well, that's more my typing skills.
11:44:05 <Heffalump> (the reasoning behind it is that you wrote a value not a function, so you might expect it to only be evaluated once ever, but cos of the type class it'll be evaluated each time it is used, so you have to give a type signature to acknowledge that you are happy with this)
11:44:09 <sethk> goron, ywAH, MIIBHE too
11:44:56 <goron> sethk: It was one letter...
11:45:16 <sethk> goron, well, details, defails ...
11:45:25 <goron> sethk: heh
11:48:00 <basti_> Blicero: how about "sequence $ repeat $ getLine >>= putStrLn"
11:48:05 <goron> The reason for the monomorphism restriction to exist is a bit lazyness on the side of compiler implementors. (OTOH removing it makes it again complexer for the users). If you defined a function like x = <some lambda stuff here>, then it's treated as a sort of "constant function".
11:49:04 <basti_> of course, that also outputs the read lines.
11:49:15 <Blicero> basti_: thanks!
11:49:36 <basti_> the behaviour on EOF is a little wacky still.
11:49:45 <Blicero> ohh
11:50:03 <basti_> but actually thats easy to circumvent
11:50:54 <Blicero> theres a function named catch or something like that for this?
11:50:57 <basti_> you could trivially install an error hander
11:50:59 <basti_> l
11:51:00 <basti_> yes
11:51:25 <basti_> it takes two parameters: the "script" that may fail, and the response to errors
11:51:32 <basti_> (which is a script too)
11:51:36 <Heffalump> goron: but once they've done type inference, it's obvious what to do..
11:51:49 <Heffalump> and since it works with the type annotation, they must be able to handle it ok
11:52:19 <goron> Heffalump: "they"? The users?
11:52:28 <Heffalump> compilers
11:52:36 <Heffalump> oh. google suggests that there's actually an undecidability issue.
11:52:42 <basti_> it'll be quite easy to replace "sequence $ repeat" by a small recursion that ends the list upon an error
11:52:42 * Heffalump investigates some more
11:53:46 <goron> Heffalump: I think undecidability has an influence in another way.
11:54:07 <goron> Heffalump: More like that you never know, which instance will actually be used.
11:54:52 <Heffalump> I'm a bit confused.
11:54:53 <goron> But that's not valid Haskell 98 (and this would be some uber instance of death-code elimination)
11:55:03 <goron> Heffalump: It doesn't have that much to do with it.
11:55:10 * Heffalump wonders if malcolm knows how the monomorphism restriction can lead to undecidability of type inference
11:55:29 <goron> I don't think it can.
11:56:11 <malcolm> Heffalump: eh? sounds weird to me
11:56:28 <Heffalump> ahah. http://haskell.org/onlinereport/decls.html#sect4.5.5
11:56:36 <Heffalump> not undecidability, as much as ambiguity
11:56:43 <goron> A: This type error depends on something called the "monomorphism restriction" in Haskell's type system. This is a restriction in the type inference that is due to Haskell's class system. Without it, the type system would be undecidable (that is, there would be programs where the type system wouldn't be able to decide whether they have valid types or not).
11:56:54 <goron>  http://www.idt.mdh.se/kurser/cd5100/ht05/FAQ.html
11:57:10 <goron> I guess these guys are confusing things.
11:57:27 <Heffalump> yeah.
11:57:30 <Heffalump> that's what I found too
11:57:35 <goron> Ow, I get what they don't understand.
11:57:42 <lisppaste2> cjs pasted "unresolved top level overloading" at http://paste.lisp.org/display/12238
11:57:53 <cjs> Ok, that error's got me completely stuck.
11:57:58 <goron> Well, they are using language that the rest of the world uses for another concept.
11:58:13 <Heffalump> the point is that binding values can lead to constrained type variables not appearing in the signature of the value
11:58:30 <goron> It's true the compiler can't "decide", but that has nothing to do with undecidability.
11:58:50 <Heffalump> cjs: Char isn't a "number"
11:58:56 * Heffalump suggests 
11:58:57 <basti_> cjs: whats the type of getLin?
11:58:59 <basti_> e
11:58:59 <Heffalump> numberText <- getLine
11:59:04 <Heffalump> let number = read numberText
11:59:06 <Heffalump> (...)
11:59:18 <sethk> goron, that's true, it's ambiguous, not undecidable
11:59:21 <Heffalump> or maybe there's a member of IO with more useful behaviour
11:59:27 <Heffalump> but I forget the name
11:59:32 <cjs> Ah, I need a read somewhere in there, right?
11:59:33 <Heffalump> (that does getLine and read together)
11:59:35 <Heffalump> cjs: right.
12:01:54 <malcolm> Heffalump: The swedish paragraph about the DMR making the type system undecidable is fairly misleading.
12:06:52 <Blicero> is there a way to imperatively terminate a haskell program
12:07:41 <malcolm> kill -9 haskellprog
12:07:46 <araujo> exit?
12:08:23 <Blicero> :|
12:10:42 <astrolabe> error?
12:12:38 <Heffalump> Blicero: where from?
12:12:52 <Heffalump> from within the program, from within a thread of the program, from outside the program, or what?
12:13:17 <Blicero> within
12:13:53 <goron> Why wouldn't the monomorphism restriction not apply to this:
12:13:54 <goron> x = \y -> y;y= x 1;z a b = (x a, x b)
12:14:46 <Heffalump> no type classes in sight
12:14:54 <Heffalump> oh, sorry, y = x 1
12:14:56 <malcolm> goron: x is just id
12:15:17 <Heffalump> the 1 in y = x 1 is defaulted
12:15:21 <malcolm> y :: Num a => a
12:16:05 <malcolm> so y would be defaulted (but not the 1)
12:16:28 <goron> malcolm: I know. I will read the rules in the report again.
12:17:04 <dcoutts> psi, re hIDE screenshots: http://haskell.org/~duncan/hIDE/hIDE2.png
12:17:19 <Heffalump> malcolm: yeah, sorry, being sloppy :-)
12:18:24 <goron> I learned last weekend that there's a default construct in Haskell. I guess it's not a very often used feature.
12:19:06 <Heffalump> indeed
12:19:25 <Heffalump> I looked into using it once and decided it was no use for what I wanted. I forget what that was now.
12:19:43 <ndm> its useful for getting things compiling with hat
12:21:02 <malcolm> ndm: in other words it is useful for getting round the mis-feature of the monomorphism restriction
12:21:38 <alar> dcoutts: seems too grey. Is the coloring customizable?
12:21:46 <goron> malcolm: You were a compiler implementor?
12:21:54 <dcoutts> alar, not yet but it will be, it's not hard to change
12:22:21 <dcoutts> alar, and the gtk widget colouring is down to your gtk theme
12:22:25 <malcolm> goron: yup, although I've never implemented a whole one
12:22:28 <davve> dcoutts, is that yi or sourceview?
12:22:43 <dcoutts> davve, it's sourceview, but yi looks just the same
12:22:48 <goron> "the constrained type variables of a restricted declaration group may not be generalized in the generalization step for that group."
12:22:52 <davve> dcoutts, okay cool
12:22:59 <goron> yep, no contrained type variables in sight.
12:23:08 <goron> er constrained
12:23:09 <alar> dcoutts: if it can be customized with Gnome theme, it seems enough
12:23:13 <dcoutts> davve, since yi uses a gtksourceview widget
12:23:34 <dcoutts> alar, I thought you were taling about the syntax highliting
12:23:34 <goron> malcolm: Then you should in favour of the restriction according to the wiki :)
12:23:43 <davve> dcotuts, aha
12:23:45 <dcoutts> alar, which will be customisable
12:23:55 <Heffalump> malcolm: who implemented nhc originally?
12:24:05 <araujo> dcoutts, where can i get the sources
12:24:09 <araujo> ?
12:24:26 <malcolm> Heffalump:Niklas R
12:24:43 <Lemmih> araujo: It's a bit hard to play with.
12:24:53 <Lemmih> @where hIDE
12:24:53 <dcoutts> @where hIDE
12:24:53 <lambdabot> http://www.haskell.org/hawiki/hIDE
12:24:54 <lambdabot> http://www.haskell.org/hawiki/hIDE
12:24:55 <dcoutts> heh
12:25:01 <alar> dcoutts: this screenshot doesn't tell much about syntax highlighting, so I don't know
12:25:15 <dcoutts> alar, huh?
12:25:45 <Heffalump> malcolm: on his own?
12:25:48 <kosmikus> Heffalump: agreed. I'll try to keep it in mind and organise it for the next FoH discussion, or at least tell the next chair to organise it ;)
12:26:17 <dcoutts> alar, the screenshot shows the syntax highliting & the error underliing thingy
12:26:44 <Heffalump> kosmikus: it's not a dead cert yet, then? :-)
12:26:50 <malcolm> Heffalump: Yes, pretty-much.
12:26:53 <psi> dcoutts: cool. looks promising :)
12:26:55 <araujo> Lemmih, it's ok :-P
12:27:22 <dcoutts> araujo, you need the latest darcs versions of several packages for hIDE
12:28:10 <araujo> Ok dcoutts
12:29:07 <goron> Is y free in  x = \y -> y ?
12:29:22 <kosmikus> Heffalump: next discussion chair, I meant ...
12:31:46 <basti_> goron: the distinction "free/bound" applies to -subterms- of valid terms only
12:32:13 <Heffalump> kosmikus: ah, right :-)
12:32:28 <basti_> in valid programs, all variables are bound
12:32:49 <goron> basti_: Could you give an example of a "subterm"?
12:32:51 <basti_> (other than in lisp, which supports unbound variables iirc)
12:32:54 <basti_> hmm ok:
12:33:36 <basti_> in x = \y -> y, y is bound. in x = \y -> y, it isn't. (subterms highlighted)
12:33:58 * Heffalump fails to see any highlighting
12:34:00 <basti_> of course every term trivially has itself as a subterm
12:34:03 * goron neither
12:34:07 <basti_> g-read
12:34:08 <basti_> t
12:34:11 * basti_ laughs
12:34:12 <basti_> okay
12:34:41 <basti_> in (x = \y -> y), y is bound. in x = \y -> (y), it isn't. (subterms parenthensed)
12:35:09 <basti_> actually bold, underline and flashing (yuck!) are part of the IRC standard.
12:35:28 <goron> Whoa, that would be a good question for an exam on this stuff!
12:35:48 <basti_> its trivial though
12:35:50 <basti_> :P
12:35:58 <basti_> once someone has explained correctly.
12:36:12 <basti_> the confusion stems from the fact, that in textbooks you see something like:
12:36:20 <basti_> "x" is an unbound variable
12:36:30 <basti_> but when you type "main" in ghc, its actually bound
12:36:41 <basti_> despite the absence of visible lambdas
12:36:44 <goron> basti_: But I don't see how the monomorphism restriction applies now.
12:37:19 <basti_> uhm. i don't know that too. but i know that it has something to do with lambda vs. declaration
12:37:23 <goron> I have to use it in a let?
12:37:28 <Heffalump> it doesn't apply to x = \y -> y
12:37:43 <goron> Heffalump: I want it to apply.
12:37:50 <basti_> then type x a = a
12:37:56 <basti_> there it could kick in
12:38:11 <work_metaperl> I'm pissed about SJT's definition of a relation: a 2-tuple consisting of 2 members of the same set. problem 1) the domain and range of a relation need not be of the same type, yet members of a set will be of the same type
12:38:50 <integral> work_metaperl: range of a relation?
12:38:52 <basti_> and the relation is not a 2-tuple.
12:39:01 <basti_> its a set of 2-tuples.
12:39:12 <goron> basti_: It doesn't.
12:39:16 <goron> x a = a;a = x 1;b = x ""
12:39:31 <Heffalump> work_metaperl: SJT?
12:39:37 <basti_> goron: depending on the circumstances. there was an example about this in the hawiki
12:39:40 <Heffalump> oh, Simon Thompson
12:39:48 <work_metaperl> I quote: a binary relation relates together certain elements of a set
12:40:06 <goron> basti_: Where? It's not on the Monomorphism restriction site.
12:40:14 <work_metaperl> f(5) = "hi"; f(5) = "jjjj" --- this is  relation between Int and String, they cannot be in the same set
12:40:19 <basti_> mm wait
12:40:27 <malcolm> x :: v->v,  a :: Integer,  b :: v->v
12:40:30 <integral> work_metaperl: that's a _function_ ...
12:40:40 <work_metaperl> no it is NOT. it fails the vertical line test
12:40:41 <basti_> http://www.haskell.org/hawiki/MonomorphismRestriction there, right in the first example
12:40:58 <work_metaperl> excuse my flaming tongue integral
12:41:02 <work_metaperl> :)
12:41:09 <integral> work_metaperl: well it's not a relation either, unless relation == multi-valued function suddenly
12:41:13 <work_metaperl> type Relation a = Set (a,a)
12:41:24 <work_metaperl> integral: that's what a relation _is_
12:41:26 <basti_> theres some point to both ways of seeing it
12:41:28 <goron> basti_: The show around the x makes it a subterm?
12:41:35 <basti_> goron: uhm no.
12:41:42 <work_metaperl> SELECT name from user where age=36;
12:41:57 <work_metaperl> same as f(36) = 'bob'; f(36) = 'joe';
12:42:07 <basti_> goron: i'd put it like: "show gives constraint, which triggers the restriction in certain circumstances"
12:42:14 <work_metaperl> it is impossible for a function to have 2 different range values for a single member of the domain
12:42:36 <basti_> i guess that relation stuff is a holy war (TM)
12:42:36 <integral> work_metaperl: hmm, I'll take your word for it.  I was thinking a relation is something like <, or ==, where either the pair is in the set (the relation is true), or it's not
12:42:43 <goron> basti_: Yes, but I am talking about the The usual Hindley-Milner restriction on polymorphism is that only type variables that do not occur free in the environment may be generalized.
12:42:46 <work_metaperl> SJT says: type Relation a = Set (a,a)
12:42:55 <basti_> its completely stupid to debate if a relation is in P(AxA) or in P(AxB)
12:43:02 <integral> work_metaperl: SJT's definition seems consistent with what I was thinking of :-/
12:43:06 <basti_> goron: urhmmm.
12:43:12 <work_metaperl> why couldnt it be type Relation a,b = Set (a,b)
12:43:25 <work_metaperl> why must the domain and range of a relation be the same type?
12:43:30 <work_metaperl> they needn't be
12:43:35 <goron> basti_: And I thought x was free.
12:43:42 <cjs> So can I think of "do" as returning a new action that's a concatenation of the actions it's given, in order? Or does that lead me wrong, somewhere?
12:43:44 <integral> hmm, good question!
12:43:48 <basti_> goron: not when you apply "show"
12:43:59 <integral> work_metaperl: do you have a useful example of such a relation?
12:44:10 <integral> (duh, I see why multi-value function == relation now)
12:44:13 <goron> basti_: The stuff with show is because of the monomorphism restriction.
12:44:19 <basti_> goron: yes.
12:44:25 <basti_> but youre talking about something else right?
12:44:26 <work_metaperl> integral: the relational database example earlier
12:44:55 <goron> basti_: I as unclear and was talking about this part: "The usual Hindley-Milner restriction on polymorphism is that only type variables that do not occur free in the environment may be generalized".
12:45:07 * basti_ nods
12:45:14 <basti_> i do not fully understand that statement
12:45:30 <goron> basti_: It's in the Haskell Report.
12:45:35 <integral> ah
12:45:37 <basti_> but i believe it translates to: "we had to design the type system so that it makes sense"
12:45:59 <goron> If you write x arg = arg, then arg is not free.
12:46:10 <basti_> wait we're talking about the -types- of these things
12:46:17 <basti_> which is a completely different concept
12:46:26 <basti_> (following similar rules, though)
12:46:27 <goron> But it you write x = \arg -> arg, it should be.
12:46:47 <dcoutts> kolmodin, ...
12:46:48 <goron> basti_: I was talking about the types. What were you talking about?
12:46:50 <work_metaperl> integral: join #math on irc.efnet.org - they agree with me
12:46:53 <dcoutts> @where fps
12:46:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
12:47:07 <basti_> if you wrinte x arg = arg, then x::a->a, with a being free (imo)
12:47:24 <basti_> wir you write x = \arg->arg, the type is still x::a->a, with a free "a"
12:47:29 <kolmodin> dcoutts: thanks a lot
12:47:44 <basti_> that criterion relates to matters outside of a specific definition
12:47:49 <basti_> (imho)
12:48:11 <goron> basti_: E.g. in a let?
12:48:24 <dcoutts> kolmodin, np, it's not a well advertised package actually
12:48:30 <goron> basti_: That's how it's illustrated in the same section in the report.
12:48:47 <basti_> hmm maybe the "in" part of the let sets constraints?
12:49:12 <davve> kolmodin, let me know if you succeed in building hIDE
12:49:25 <basti_> I'm just guessing now. I just think, the form of definition has not much to do with the freedom of type variables
12:49:29 <kosmikus> dons: could you make lambdabot join #gentoo-haskell, please?
12:49:49 <kolmodin> davve: you'll all here when I succeed. loud and clear~ :)
12:50:20 <davve> ok, hehe
12:51:08 <basti_> i repeat: i think the "freedom of type variables" refers to known facts about the types of your program
12:51:32 <basti_> not to haskell-program-code-subterms
12:52:29 <goron> basti_: Yes, it's basically that you already have some information about a type in your type environment.
12:52:35 <goron> basti_: I think I understand.
12:52:40 * basti_ nods
12:52:51 <basti_> i don't really know what's meant by a bound type var, but i think it translates to "having no constraint"
12:53:12 <goron> A bound variable is one which has a forall quantor in front of it.
12:53:21 * basti_ nods
12:53:23 <goron> (which are implicit in Haskell)
12:53:29 <goron> Haskell 98, that is.
12:53:33 <basti_> but basically, "a->a" has a forall too hasnt it? ;)
12:53:45 <psi> I'm going to try to build hide on os x
12:53:48 <goron> basti_: That's what implicit means, right ;)
12:53:56 <basti_> yup
12:54:12 <basti_> so the question would be "free in relation to WHAT EXACTLY?"
12:54:19 <psi> what do you need? I have hs-plugins, gtk2hs, glade...
12:54:21 <goron> basti_: Well, then we reached consensus. How unlikely ;)
12:54:28 <basti_> (where do we put the implicit quantors?)
12:54:32 * basti_ laughs
12:56:01 <goron> Are messages send during a netsplit not received by people being on the other side of the split?
12:56:08 <Heffalump> correct
12:56:11 <goron> (or just later)
12:56:17 <Heffalump> no, never
12:56:22 <basti_> there is some "overlap" phase
12:56:24 <goron> Heffalump: ok, good to know. Thanks.
12:56:31 * Oejet is always on the right side of a netsplit.
12:56:36 <basti_> the cut is not as hard as it is pretended
12:56:41 <Heffalump> goron: also, the "Netsplit over" messages are generated by irssi and are notoriously unreliable.
12:57:02 <goron> Heffalump: ow, I was kinda assuming validity. :P
12:57:06 <basti_> its also common that rejoins happen sequentially
12:57:12 <basti_> first one server, then the other...
12:57:41 <Heffalump> what actually happens on a protocol levle is that at the netsplit, a bunch of people quit with the message (server1 <-> server2) or similar.
12:57:51 <basti_> basically, often there's a time before the split where messages lag long times between the 2 parts
12:57:59 <Heffalump> irssi bunches those up and says "server1 and server2 split, disconnecting these people" (paraphrasing)
12:57:59 <basti_> so that effective conversation is destroyed
12:58:18 <Heffalump> when a netsplit rejoins, all that the protocol sees is a bunch of people joining the channel at once
12:58:28 <Heffalump> irssi tries to guess that it was a netsplit rejoin, but IME it can get it very wrong sometimes.
12:58:28 <basti_> yup
12:58:42 <basti_> but there's a speciall channel in most irc server implementations
12:58:46 <basti_> "&server" i think
12:59:04 <basti_> there you can see internal messages that reflect your server's view of the net
12:59:36 <Heffalump> oh, right
13:00:04 <basti_> thats a little more reliable
13:00:29 <int-e> there's also the /links command - but that will only tell you the servers that are there, not those that are missing.
13:01:35 <goron> I guess this 90% of the functions of an application isn't used by 90% (or something like that) are pretty true.
13:02:59 <basti_> goron: yes
13:03:25 <basti_> and the corollary "the 90% nobody uses make that of the remaining 10% actually 99% are shy to use the program" is true too
13:04:19 <goron> heh
13:04:45 <basti_> i mean... theres programs with MOVING MENU ITEMS now. how stupid is that? ;)
13:05:12 <goron> I hate those flashy menu's in Office 2003.
13:05:21 <goron> You can probably turn them off.
13:05:41 <goron> But I can't really bother since I don't plan to sue MS Office that much.
13:05:49 <goron> heh, nice error.
13:05:54 <goron> use
13:06:29 <basti_> -g-
13:06:35 <dcoutts> Lemmih: http://haskell.org/~duncan/hIDE/hIDE-htmlviewer.png
13:07:02 <dcoutts> Lemmih, so we ought to be able to implement a jump to documentation plugin
13:07:29 <goron> dcoutts: I am sure that will attract users.
13:07:46 <Lemmih> dcoutts: That's really neat.
13:07:51 <dcoutts> goron, yes it should be a really useful feature
13:07:58 <dcoutts> I need to look stuff up all the time
13:08:04 <sylvan> dammit, now I need to get hs-plugins working with ghc-6.5 so I can play around with this
13:08:13 <sylvan> (hIDE, that is)
13:08:17 <dcoutts> sylvan, we're using ghc-6.4.1
13:08:19 <goron> The only reason Java could be more productive is that there's JavaDoc integration.
13:08:31 <sylvan> dcoutts, would it be impossible to use with 6.5?
13:08:44 <Lemmih> Isn't dons using 6.5?
13:09:04 <dcoutts> though didn't he have trouble building some components with 6.5?
13:09:05 <psi> I can't build Yi :/ Setup: Line 11: Unknown field 'hs-source-dirs'
13:09:09 <sylvan> is there some restriction due to the ghc-lib thing?
13:09:16 <dcoutts> psi, you need a later version of cabal
13:09:23 <dcoutts> psi, try Cabal-1.1.3
13:09:32 <psi> alright
13:09:46 <goron> I said the exact same 8 months ago. But now, it's good someone is fixing the "problem". :D
13:09:58 <goron> Anyway, time to go. Bye.
13:10:03 <boegel|home> bye goron
13:10:11 <dcoutts> bye
13:11:23 <dcoutts> Lemmih, I need to change the Page interface to make it more flexable, eg for the doc we need to be able to have one html widget per-window rather than one per url
13:11:25 <Lemmih> hIDE really isn't that playable. dcoutts haven't pushed his documentation code and my CommonSense plugins are completely broken.
13:11:56 <dcoutts> I'll try and puch my documentation thing soon
13:12:05 <sylvan> ah.. I'll still need to get hs-plugins running at some point =/
13:12:48 <dcoutts> Lemmih, yeah, it's a case of needing publicity but not too much publicity or people will expect everything to work already :-)
13:15:37 <davve> would be cool if there was a haddock plugin that could extract haddock documenation from the project and add that info to the intellisense
13:15:56 <davve> just like typechecking with ghc-api adds info to intellisense
13:18:01 <Lemmih> It creates a problem with package dependencies.
13:18:08 <dons> moin
13:19:59 <dons> Lemmih, dcoutts: so we should all standardise on 6.4.1 should we?
13:20:10 <dcoutts> probably
13:20:19 <dons> dcoutts, htmlviewer, cool!
13:20:39 <dons> yeah. I'll look to stabalise everything this week. get the QC tests reintegrated too
13:21:03 <dcoutts> dons, it's actually very little code, it just took a bit of debugging to work around some oddities in the gtkmozembed widget
13:21:20 <dons> ah, so mozembed provides the rendering?
13:21:25 <dcoutts> yep
13:21:29 <dons> gtk wins again
13:21:37 <dcoutts> full mozilla/firefox rendering engine
13:21:51 <dcoutts> and it loads as a seperate plugin
13:21:56 <dons> I'd like a hoogle plugin that generates links to these pages
13:22:16 <dons> and i'd like a hoogle over the local project code, which pops up either the docs, or the code itself.
13:22:19 <dcoutts> and simple jump to documentation for the symbol under the cursor
13:22:27 <dons> yep
13:22:32 <dcoutts> hoogle is not required for that
13:22:57 <dons> right. we just keep our own db?
13:23:00 * Lemmih would like a hoogle that used ghc's unifier.
13:23:13 <dcoutts> if the code passes the renamer stage then we know exactly the full module name and the package it comes from
13:23:23 <dcoutts> if it doesn't then it needs more guesswork
13:23:38 <dons> Lemmih! hmm, ah, but ndm doesn't like using ghc only.
13:23:41 <dcoutts> and an index of symbols from the various packages
13:24:09 <dons> so we could do our own ctags thingy
13:24:28 <dcoutts> well it's just a matter of readign the .hi files
13:24:36 <dcoutts> using the ghc api I guess
13:25:06 <davve> btw, are there any slides from the haskell workshop talks on the net?
13:25:23 <Heffalump> David Roundy's are
13:25:28 <dons> I think there's also supposed to be transcripts of the questions asked somewhere too?
13:25:39 <Heffalump> http://darcs.net/hw_2005.pdf
13:25:40 <dons> Heffalump, or was that only icfp?
13:25:44 <davve> heffalump, thanks
13:25:44 <Heffalump> dons: only ICFP, I think
13:25:48 <Lemmih> Goodnight, #haskell.
13:25:49 <dons> hmm, should put my slides up too
13:25:50 <dcoutts> dons, it'd be nice to get Yi using the EditorPage interface like the current demo editor
13:25:54 <dcoutts> g'night Lemmih
13:25:55 <Heffalump> Olivier Danvy said he was going to email everyone involved with a transcript first
13:25:55 <dons> night Lemmih
13:26:00 <boegel|home> night Lemmih
13:26:06 * boegel|home decides to leave too
13:26:26 <dons> dcoutts, ok. shoudl I prioritize that?
13:26:32 <dcoutts> dons, but I'll need to finnish the ideShell api first :-)
13:27:01 <dcoutts> dons, well it will allow you to test the model/view thing and resource consumption minimisation strategies
13:27:16 <dcoutts> but maybe you wnat to get simpler things fixed first
13:27:37 <dons> yep, ok.
13:27:43 <dcoutts> like the keybinings/lexer language
13:27:54 <dcoutts> so we can make the editor properly usable
13:28:34 <dons> yes. I certainly want that done by the end of this weekend.
13:28:40 <dcoutts> satisfying people with the editor is going to be difficult
13:28:54 <dcoutts> people have such high expectations from their existing editors
13:29:10 <work_metaperl> M-x all-hail-xemacs
13:29:36 <dcoutts> we need to be not plagued by the "not very good internal editor" problem that some IDEs have
13:29:54 <dcoutts> which basically comes down to emulating vim/emacs sufficiently well
13:29:57 <dons> hmm. I am pretty happy with the vim mode yi has.
13:30:05 <dons> and I don't see why we can't do the same with the emacs omde
13:30:21 <dcoutts> yes I tried it too, it's good
13:30:30 <work_metaperl> xemacs is more than an editor... have you seen ecb.sf.net -- the emacs code browser
13:30:30 <dons> so, we'll see. but it's a good point you raise
13:30:41 <dcoutts> sure, so we just have to make it work as well with thr gtk interface
13:30:51 <dons> yes.
13:30:56 <work_metaperl> xemacs is a total layer on top of Unix to increase productivity in a number of areas
13:30:57 <dcoutts> and we'll need a gnome mode
13:31:17 <dcoutts> that behaves more like standard gnome/windows editors
13:31:32 <dcoutts> for all the people who hast vim/emacs
13:31:38 <dcoutts> hast/hate
13:31:56 <work_metaperl> eclipse is getting popular too -- autrijus uses it
13:32:11 <autrijus> yup.
13:32:28 <autrijus> I like eclipse and its ocaml/haskell mode.
13:32:37 <work_metaperl> my editor is _way_ more than keybindings
13:32:38 <autrijus> works better than visual haskell, actually.
13:32:49 * autrijus decides VH is not yet ready for prime time
13:32:53 <dcoutts> work_metaperl, yes?
13:33:04 <work_metaperl> dcoutts: what?
13:33:25 <dcoutts> work_metaperl, what other features of your editor do you rely on?
13:34:16 <bojohan> mail/news reader, irc client, ... :)
13:34:34 <dcoutts> bojohan, oh well that's eacy :-)
13:34:44 <dons> plugins for all!
13:34:56 <bojohan> interactive diffs, cvs integration
13:34:59 <dcoutts> and irc client would be easy, we've already got three
13:35:07 <bojohan> we've got 10!
13:35:15 <dcoutts> bojohan, darcs integration you mean :-)
13:35:20 <yaarg> tetris
13:35:27 <sylvan> autrijus, does ecplise have intellisense for haskell?
13:35:31 <work_metaperl> dcoutts: I use ecb.sf.net to develop
13:35:48 <work_metaperl> dcoutts: I used dired to move between directories and copy/edit/grok files
13:35:59 <work_metaperl> dcoutts: I use find-grep to search through files
13:36:18 <work_metaperl> dcoutts - I use shell mode sometimes
13:36:20 <dcoutts> work_metaperl, I think we aim to have most of those features
13:36:40 <dcoutts> good code browing is really a productivity boost
13:36:45 <work_metaperl> it will be interesting
13:36:45 <yaarg> i can see the appeal of emacs but i've never managed to configure it to how i like
13:36:59 <work_metaperl> to see it happen. yaarg try XEmacs
13:37:11 <dcoutts> jump to definition & jump to documentation would be great and quite possible
13:37:14 <autrijus> sylvan: the vim kind ;)
13:37:17 <autrijus> so, supidsense.
13:37:24 * Pistahh uses gedit.
13:37:27 <autrijus> but somewhat useful.
13:37:30 <autrijus> stupidsense, even.
13:38:32 <Dibrom> can someone help me figure out a problem I'm having with the State monad?
13:38:36 <dons> dcoutts, it would be nice to be able to browse and load/unload plugins (preserving their state perhap ...)
13:38:47 <bojohan> ...usable without a window system
13:38:56 <dons> so if you load the haddock plugin say, you get back the last pagee you looked at
13:38:58 <sylvan> Dibrom, I'm sure we can try
13:39:02 <Dibrom> ok
13:39:12 <Dibrom> can I paste some code in here?
13:39:15 <Dibrom> only a few short lines
13:39:16 <dons> hmm. 30 degrees in sydney today. yay :D
13:39:19 <dons> bye bye .ee ;)
13:39:35 <sylvan> @paste
13:39:36 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:39:50 <Dibrom> oh, ok :)
13:39:52 <sylvan> use that if it's more than a few lines
13:40:27 <Dibrom> yeah, I'm editing it now
13:42:50 <dons> for those interested, my talk from the haskell workshop is available at http://www.cse.unsw.edu.au/~dons/projects.html
13:42:53 <dcoutts> dons, the history of viewd pages should be held by each window, so if plugins can be unloaded and reloade then I don't see why you couldn't just flick back to the page you were viewing, I don't think it should be controled by which plugin you hapened to just load
13:43:09 <dons> ah, good point
13:44:01 <dons> I was thinking that if you close a window onto a plugin, then if you later open up a new window onto that plugin, you get back the old state
13:44:25 <dons> but I guess that's not how, say, mozilla works. so maybe not so useful
13:44:58 <dcoutts> well each page has a notion of a couple kinds of state. It's not unreasonable to ask that they may be saved/restored
13:45:24 <dcoutts> the html doc pages are essentially stateless
13:45:46 <Dibrom> sylvan: ok I added my problem
13:45:59 <Dibrom> it's basically an issue with sequencing monadic computations with an array vs a list
13:46:08 <Dibrom> the array sequencing isn't working like I'm expecting it
13:46:12 <dcoutts> its only state is what their current url is, which is given to it in the first place
13:46:16 <Dibrom> I'm probably doing something dumb, or don't understand something properly
13:47:11 <Dibrom> oh, and semantics for addw r1 r2 r3 are r3 = r1 + r2
13:51:40 <rep> there need to be more types of monad :P
13:51:54 <dons> hmm, john raises a good point about important community info happening on #haskell, but not spreading further.
13:52:02 <dons> i've worried about this myself.
13:52:21 <Igloo> Where is this?
13:52:22 <dons> for example, we probably could have advertised the hw2005 session in advance.
13:52:32 <dons> [Haskell-cafe] IRC for spreading information
13:52:44 <Igloo> Which hw2005 session?
13:52:55 <Igloo> Is it very recent?
13:53:03 <Heffalump> Igloo: same as the discussion earlier, I think
13:53:10 <Heffalump> oh, maybe not
13:53:30 <Heffalump> no, it is
13:53:39 <dons> quite possibly, since I just woke up
13:53:47 * dons checks the logs
13:54:14 <Igloo> Oh, the other John
13:54:19 <Dibrom> so anyone have any ideas why that code doesn't work right? or do I need to add more context?
13:55:05 <Igloo> I still don't understand the hw2005 comment though, unless you mean to suggest non-IRCers join IRC for the HW period?
13:55:57 <dons> that's what I was suggesting, yes.
13:56:13 <CosmicRay> main = interact $ show . (sum :: [Int] -> Int) . map read . lines
13:56:25 <CosmicRay> is there any clever way to add a "\n" to the end of that result?
13:56:39 <dons> yeah, umm. let me see...
13:56:44 <CosmicRay> adding (++) "\n" . before the show adds it to the beginning.
13:56:45 <Heffalump> (++\n) $
13:56:54 <Heffalump> oh, right, sorry
13:56:57 * Heffalump pays more attention
13:57:00 * Igloo doesn't really think that would have been better than sending the RL2IRC transcript to the list
13:57:04 <Heffalump> no, I did mean what I said, but with some quotes
13:57:06 <dons> . (++ ['\\n']) . ?
13:57:11 <Korollary> ew
13:57:16 <Heffalump> (++ "\n") .
13:57:26 <CosmicRay> Igloo: if the transcript has all conversations not related to the conversation edited out, that would be fine.
13:57:40 <dons> oh, sorry, mine was pasted out of h4sh, which is a meta-program, hence the extra quotes ;)
13:57:47 <CosmicRay> Heffalump: that did indeed do it.
13:58:03 <CosmicRay> Heffalump: why did that work, but (++) "\n" didn't?
13:58:19 <Heffalump> I would appreciate it if my slightly uncomplimentary assessments of John Launchbury's position were sanitised too (I said "going on about" or similar a couple of times)
13:58:22 <Heffalump> CosmicRay: means different things
13:58:26 <Igloo> (++) "\n" == ("\n" ++)
13:58:28 <Heffalump> (++"\n") is flip (++) "\n"
13:58:55 <CosmicRay> I understand what Igloo said.  I don't understand why what you're saying, heffalump, implies the flip.
13:59:03 <Heffalump> CosmicRay: cos it does.
13:59:07 <Heffalump> It's the way sectioned operators work
13:59:22 <Heffalump> "by definition" would be a more helpful explanation than "cos it does", perhaps
13:59:27 <CosmicRay> let me see if I understand.
13:59:27 <Igloo> Think of   (x op) as being (\y -> x op y) and (op y) as being (\x -> x op y)
13:59:39 <CosmicRay> so you mean that if I partially apply an operator without putting the op itself in parens, it implies a flip?
13:59:40 <dons> @seen jlouis
13:59:41 <lambdabot> jlouis is in #haskell. I don't know when jlouis last spoke.
13:59:46 <Cale> rep: more types of monad?
13:59:52 <CosmicRay> but if I put it in parens, it behaves like a regular function and does not imply a flip?
14:00:00 <Igloo> (it's times like these when you need Unicode's PLUS IN CIRCLE bound to a convenient key)
14:00:00 <Korollary> CosmicRay: It's not about the flip. It's about consuming the right op versus the left op
14:00:14 <Lunar^> Igloo: any progress on libghc6-cabal-dev issues?
14:00:25 <Igloo> (x op) and (op y) are sections
14:00:27 <CosmicRay> well, reword the flip to consuming the different parameters if you like, but is the statement essentially correct?
14:00:34 <Igloo> (op) is functionalising an operator
14:00:36 <Heffalump> sorje: it's not partially applied without the parens
14:00:38 <Cale> Dibrom: hmm... I'm not seeing a reason right away why that shouldn't be the same...
14:00:42 <Heffalump> s/sorje/cosmicray/
14:00:48 <Heffalump> it's a sectioned operator
14:00:52 <Heffalump> which are defined specially
14:00:56 <CosmicRay> Heffalump: what is the difference?
14:00:56 <Dibrom> Cale: yeah.. me either :/  Thanks for looking though
14:00:57 <Igloo> Lunar^: Syntax couldn't do it while at ICFP et al. Hopefully he will real soon now.
14:01:12 <Heffalump> cale/dibrom: what's the issue
14:01:16 <Igloo> Lunar^: What's the problem it causes you, OOI?
14:01:19 <Cale> Dibrom: How much more source would be required to run/test it
14:01:20 <Cale> ?
14:01:22 <Dibrom> I suppose I can use a list instead of an array if I simply can't figure it out, but that will get ugly and so for stuff like emulating jumps and branches
14:01:35 <Lunar^> Igloo: I need Cabal 1.1.3 to package hscurses
14:01:36 <Dibrom> not a whole lot.. I can post the whole file if needed.. it's not that much longer
14:01:42 <Dibrom> would you like me to do that?
14:01:42 * Heffalump reads the paste page
14:01:49 <Cale> sure
14:01:54 <Igloo> You mean it won't work with the cabal in ghc6?
14:01:56 <Dibrom> ok.. just a min
14:02:10 <Cale> oh
14:02:22 <Cale> that list comprehension isn't parallel
14:02:26 <Cale> [(ix,instr) | ix <- [1..3], instr <- instrList]
14:02:27 <Lunar^> Igloo: nope.. Can't understand exactly why, but the output of on hsc2hs+cpphs for haddock is truncated
14:02:37 <Cale> this is producing a Cartesian product
14:02:37 <Dibrom> what do you mean?
14:02:40 <Igloo> Lunar^: Bah  :-(
14:02:47 <Dibrom> hrmm
14:02:54 <Cale> you want zip
14:02:57 <Lunar^> Igloo: I quickly hacked a libghc6-cabal-dev 1.1.3, and it works with it
14:03:01 <Cale> zip [1..3] instrList
14:03:12 <Cale> or
14:03:18 <Cale> [(ix,instr) | ix <- [1..3] | instr <- instrList]
14:03:28 <Dibrom> ahh
14:03:28 <Heffalump> cale: but that's a GHC extension
14:03:33 <Cale> yeah
14:03:38 <Dibrom> well let me see if that changes things real quick
14:03:47 <Cale> (the second is a GHC extension)
14:04:13 <Dibrom> thats fine, I'm using a couple of other ghc extensions anyway
14:04:33 <Lunar^> Igloo: it's going to brake a lot of package though
14:04:43 <Cale> Seems like it should be part of the syntax anyway :)
14:04:44 <Dibrom> ahh, that did it :)
14:04:46 <Dibrom> thank you so much
14:04:51 <Cale> no problem
14:04:54 <Dibrom> I was starting to get frustrated
14:05:03 <Lunar^> Igloo: because it requires explicit depedency to haskell packages in .cabal
14:05:16 <Igloo> Lunar^: I don't follow
14:05:27 <Dibrom> I'm still not sure I understand exactly why the other one doesn't work though
14:06:03 <Lunar^> Igloo: The last cabal actually use the --hide-all-package of GHC 6.4.1, which means that every Debian package using cabal will need an update
14:06:07 <Cale> @eval [(x,y) | x <- [1..3], y <- [5..7]]
14:06:09 <lambdabot> [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7)]
14:06:26 <Lunar^> Igloo: I'm willing to help such work, though :)
14:06:32 <Dibrom> oh, right.  You said cartesian product ;)
14:06:51 <Igloo> Lunar^: Only buggy ones should need an update
14:07:55 <Dibrom> I guess the reason I didn't see this sooner is I wasn't pulling the second element for my other arrays out of lists
14:08:02 <Dibrom> so I've been creating arrays incorrectly
14:10:18 <Lunar^> Igloo: I will see with Syntax when he'll be back...
14:15:37 <heatsink> Has anyone here linked haskell with C using gcc before?
14:16:02 <dons> using gcc?
14:16:06 <heatsink> hes
14:16:08 <heatsink> yes
14:16:19 <dons> typer error in question
14:16:28 <heatsink> what?
14:16:28 <dons> you want gcc to do the linking??
14:16:32 <heatsink> right.
14:16:40 <dons> ghc does this all the time.
14:16:41 <heatsink> I'm calling haskell from C, and the existing code base is set up to link via gcc.
14:16:42 <dons> use ghc -v
14:16:48 <dons> to see what command line is used
14:17:12 <dons> ah. you should either use ghc as your C compiler, or extract the proper link line from ghc -v
14:17:26 <dons> using ghc as a C compiler is way easier.
14:17:35 <dons> possibly even just CC=ghc
14:18:08 <Igloo> You need to -optc lots of stuff if you do that
14:18:21 <Igloo> Or -optl when linking, possibly
14:19:46 <dons> maybe I've been lucky with my calling-haskell-from-C projects. I didn't need any magic flags when using ghc as gcc
14:20:03 <heatsink> hmm
14:20:14 <heatsink> well, I'll see what happens if I change CC first
14:20:22 <Igloo> In general, I mean. It'll depend what flags you use
14:20:47 <dons> ah, fair enough.
14:20:59 <kosmikus> thanks, dons
14:21:22 <dons> kosmikus?~[6~
14:21:44 <kosmikus> dons: lambdabot in gentoo-haskell
14:21:47 <MarcWeber> Hi dons, kosmikus (and everyone else)
14:22:11 <dons> ah, no worries kosmikus :)
14:22:35 <heatsink> hmm, ghc does it too.  I built the haskell part with --make already, so I'm not sure why it barfs.
14:22:41 * heatsink messes with stuff
14:23:36 <Igloo> Does what?
14:24:31 <kowey> completely random plug - in case anybody has been procrastinating on learning Parsec (like i have)... do it asap.  It's super easy to pick up and it makes your life easier
14:24:45 <heatsink> Igloo: it gives me multiple-symbol errors at the linking phase when I try to link haskell and C
14:24:54 <heatsink> Igloo: but not when I link just the haskell files
14:25:16 <dons> you not adding the C libs ?/
14:25:17 <dons> -lfoo
14:26:19 <rep> someone should write an irc client in haskell.
14:26:33 <heatsink> These aren't C libraries.  I'm trying to work some haskell code into an existing makefile setup with C code.
14:27:32 <dons> rep, we have one. ginsu
14:27:54 <rep> ah
14:30:04 <wagle> lambdabot: what language are you written in?
14:30:38 <wagle> 8(
14:30:42 <rep> well, you can't irc with lambdabot, afaik :)
14:30:44 <lambdabot> Haskell! The discriminating bot's language of choice ;)
14:31:04 <lambdabot> Hah, it's no problem at all
14:31:18 <rep> well
14:31:27 <wagle> i thought he would wake up when his name was uttered
14:31:31 <rep> it's probably only slightly better than telnet :)
14:32:05 <lambdabot> he's a she. see http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:32:06 <wagle> unfortunately, his human servant is a bit slow..  8)
14:32:08 <dcoutts> dons, I have one question about these dynamcic apps, they seem to need gobal vars to help stich the modules togeter at runtime
14:32:37 <dons> hmm, they do?
14:32:40 <dcoutts> ie plugins need to register themselves and that registration info needs to be held in some top level mutable var
14:32:50 <wagle> her
14:32:58 <dons> you could use a monad.
14:33:08 <dcoutts> dons, ok here's an example
14:34:00 <dons> but if they're going to register themselves, then yes, we'll need to keep track of them, a la lambdabot
14:34:06 <dcoutts> you can register a thing that handles urls, ie it maps them to pages (eg the demo editor or the htmlview or yi)
14:34:14 <dcoutts> so I've got a PagesRegistry
14:34:37 <dcoutts> and I can create an instance of that in the ide shell's plugin_main
14:34:58 <dcoutts> but then how do other plugins get themselves into that registry instance?
14:35:19 <dcoutts> unless they get passed some handle in their plugin_main
14:35:39 <dcoutts> but that doesn't scale to all the different registrys of interfaces that we'll have
14:36:15 <dons> hmm. you need something like a list of Modules, which is some abstraction over a plugin perhaps
14:36:29 <dcoutts> eg you could pass a handle to the ide shell instance but what about other interfaces we'll need
14:36:59 <dons> an existential hiding the ops a plugin provides, perhaps. not sure how far you want to go with this
14:37:16 <dons> perhaps look at lambdabot's MODULE existential, and the Map that keeps track of them
14:37:36 <dcoutts> but that's only one interface that a plugin might want to register with
14:37:46 <dcoutts> we have N of them
14:37:56 <dons> ah, you want to register across to other plugins, is that right?
14:38:23 <dcoutts> well this url handler registry is just one example, there will be several of these kind of things
14:38:56 <dons> well, it seems you need a global var, or a Registry monad, at least
14:39:10 <dcoutts> in some random plugin the plugin_main will want to register with half a dozen callback interfaces
14:39:26 <dcoutts> eg, the ide shell, yi, some type checker thingy, etc etc
14:39:49 <dons> ok. and registering involves what? insertign the Module handle into a Map or ListT?
14:39:52 <dcoutts> yes, so I can use a global var, just tring to see if there is anything better
14:39:54 <dons> or inserting a function
14:40:12 <dcoutts> in this case it's adding it to a map of handlers
14:40:13 <dons> I use a global var in Yi, and we have a lovely monad  in lambdabot
14:40:39 <dcoutts> lambdabot is ok since it has only one plugin interface available
14:40:48 <dons> yep
14:40:54 * heatsink discovers that the odd behavior goes away when I move the object file _before_ the first library on the command line
14:46:26 <heatsink> cool, it builds!
14:46:31 <heatsink> http://www.borg.com/~warren/Kiwanis/KIntBanr.gif
14:48:29 <wagle> has anyone used X11 under macosx 10.4 with a wheelmouse?
14:48:38 * wagle checks out heatsink's thing
14:48:42 <dons> hehe
14:49:00 <dons> I've used a wheel mouse and X11 but not on a mac
14:49:27 <dons> I had to dad          Option      "ZAxisMapping" "4 5"
14:49:29 <wagle> its just that X11 doesnt see single "ticks" of the wheel..
14:49:42 <dons> hmm
14:49:46 <wagle> if you spin it, it can see that
14:50:18 * wagle doesnt understand the kiwanis reference
14:50:27 <heatsink> "we build"
14:50:55 * wagle looks confused
14:51:06 <heatsink> I was just being silly *patpat*
14:51:11 * wagle doesnt understand the "we build" reference
14:51:22 * wagle cries
14:51:26 <int-e> "cool, it builds!" - "we build"
14:51:38 * wagle looks stupid..  8)
14:51:41 <int-e> yes.
14:52:15 * int-e gives wagle a lollipop.
14:53:31 * heatsink gets hungry and eats the computer
14:56:50 * wagle gives heatsink some fish to go with his chips
14:58:06 <work_metaperl> lol@wagle
14:58:45 <work_metaperl> here's one: jesus saves.... passes to Moses... shoots.. SCORES!!!
15:00:37 <joao> ;)
15:18:22 <thedward> is there an equivalent to 'split' from perl in Haskell?
15:18:49 <sylvan> what does "split" in perl do?
15:20:51 <thedward> takes a regex and a string and returns a list of strings by "cutting" where the regex matches. What I really want though is a function of type "( a -> Bool) -> [a] -> [[a]]" that will split the list where the function is true.
15:22:11 <sylvan> let split f x = takeWhile (not . f) xs : split (dropWhile (not . f) xs) in split (==' ') "hello test this"
15:22:17 <sylvan> @eval let split f x = takeWhile (not . f) xs : split (dropWhile (not . f) xs) in split (==' ') "hello test this"
15:22:18 <lambdabot> <irc>:1:36: Not in scope: `xs'
15:22:18 <lambdabot>  
15:22:18 <lambdabot> <irc>:1:68: Not in scope: `xs'
15:22:22 <sylvan> bah
15:22:27 <sylvan> @eval let split f xs = takeWhile (not . f) xs : split (dropWhile (not . f) xs) in split (==' ') "hello test this"
15:22:28 <lambdabot> <irc>:1:42:
15:22:28 <lambdabot>   Expecting a function type, but found `[a]'
15:22:28 <lambdabot>   Expected type: [[a]]
15:22:28 <lambdabot>   Inferred type: [a] -> t
15:22:28 <lambdabot>   Probable cause: `split' is applied to too few arguments in the
15:22:30 <lambdabot> call
15:22:32 <lambdabot>    (split (dropWhile (not . f) xs))
15:22:34 <lambdabot>   In the second argument of `(:)', namely `split (dropWhile (not . f)
15:22:36 <lambdabot> xs)'
15:22:43 <sylvan> I'm going to bed =(
15:23:34 <thedward> heh. okay.
15:23:56 <thedward> that looks much like what I've got; I know it can be done, was just trying to avoid reinventing the wheel.
15:25:30 <Korollary> there is regexp support in ghc
15:28:34 <sylvan> @eval let split _ [] = [] ; split f xs = takeWhile (not . f) xs : split f (dropWhile f (dropWhile ( not . f) xs)) in split (==' ') "hello test this"
15:28:35 <lambdabot> ["hello","test","this"]
15:28:38 <sylvan> there
15:28:41 <sylvan> Now I'll go to bed
15:31:08 <dons> hmm. should filter these @eval output a bit more
15:37:14 <Cale> @eval let split f [] = []; split f xs = let (u,v) = break f xs in Just (u, if null v then v else tail v) in unfoldr split (==' ') "Hello there world"
15:37:16 <lambdabot> <irc>:1:72:
15:37:16 <lambdabot>   Ambiguous occurrence `null'
15:37:16 <lambdabot>   It could refer to either `GHC.List.null', imported from Data.List
15:37:16 <lambdabot> at /tmp/MHysr11773.hs:15:0-15
15:37:16 <lambdabot>          or `Data.Set.null', imported from Data.Set at /tmp/MHysr11773
15:37:18 <lambdabot> .hs:18:0-14
15:37:28 <Cale> @eval let split f [] = []; split f xs = let (u,v) = break f xs in Just (u, if List.null v then v else tail v) in unfoldr split (==' ') "Hello there world"
15:37:29 <lambdabot> <irc>:1:60:
15:37:29 <lambdabot>   Couldn't match `[a]' against `Maybe a1'
15:37:29 <lambdabot>   Expected type: [a]
15:37:29 <lambdabot>   Inferred type: Maybe a1
15:37:29 <lambdabot>   In the application `Just (u, if GHC.List.null v then v else tail v)
15:37:31 <lambdabot> '
15:37:33 <lambdabot>   In the definition of `split':
15:37:35 <lambdabot> [16 @more lines]
15:37:46 <Cale> hm
15:37:57 <Heffalump> why is Data.Set in its default imports?
15:38:24 <Cale> let split f [] = Nothing; split f xs = let (u,v) = break f xs in Just (u, if List.null v then v else tail v) in unfoldr (split (==' ')) "Hello there world"
15:38:30 <Cale> @eval let split f [] = Nothing; split f xs = let (u,v) = break f xs in Just (u, if List.null v then v else tail v) in unfoldr (split (==' ')) "Hello there world"
15:38:32 <lambdabot> ["Hello","there","world"]
15:38:56 <dons> we have split in several non-standard libs. h4sh has it, as does MissingH
15:39:29 <Cale> Yeah, isn't Data.Set set up to be imported qualified by runplugs?
15:39:38 <dons> yes, S.*
15:39:42 <dons> also Map is M.*
15:40:18 <Cale> @eval null []
15:40:19 <lambdabot> <irc>:1:0:
15:40:19 <lambdabot>   Ambiguous occurrence `null'
15:40:19 <lambdabot>   It could refer to either `GHC.List.null', imported from Data.List
15:40:19 <lambdabot> at /tmp/MosOU10390.hs:15:0-15
15:40:19 <lambdabot>          or `Data.Set.null', imported from Data.Set at /tmp/MosOU10390
15:40:21 <lambdabot> .hs:18:0-14
15:40:34 <Cale> @eval S.null []
15:40:36 <lambdabot> <irc>:1:7:
15:40:36 <lambdabot>   Couldn't match `Set a' against `[a1]'
15:40:36 <lambdabot>   Expected type: Set a
15:40:36 <lambdabot>   Inferred type: [a1]
15:40:36 <lambdabot>   In the first argument of `Data.Set.null', namely `[]'
15:40:38 <lambdabot>   In the definition of `xxxx': xxxx = Data.Set.null []
15:40:41 <Cale> @eval List.null []
15:40:44 <lambdabot> True
15:41:09 <Cale> @eval map (+5) [1,2,3,4,5]
15:41:10 <lambdabot> <irc>:1:0:
15:41:10 <lambdabot>   Ambiguous occurrence `map'
15:41:10 <lambdabot>   It could refer to either `GHC.Base.map', imported from Data.List
15:41:10 <lambdabot> at /tmp/MSfgy16256.hs:15:0-15
15:41:10 <lambdabot>          or `Data.Set.map', imported from Data.Set at /tmp/MSfgy16256.
15:41:12 <lambdabot> hs:18:0-14
15:41:36 <Cale> doesn't appear to be qualified
15:43:13 <thedward> @plugs map (+5) [1,2,3,4,5]
15:43:15 <lambdabot> <irc>:1:0:
15:43:15 <lambdabot>   Ambiguous occurrence `map'
15:43:15 <lambdabot>   It could refer to either `GHC.Base.map', imported from Data.List
15:43:15 <lambdabot> at /tmp/MrKqpN3082.hs:15:0-15
15:43:15 <lambdabot>          or `Data.Set.map', imported from Data.Set at /tmp/MrKqpN3082.
15:43:17 <lambdabot> hs:18:0-14
15:43:28 <thedward> @plugs GHC.Base.map (+5) [1,2,3,4,5]
15:43:29 <lambdabot> <irc>:1:0: Not in scope: `GHC.Base.map'
15:43:33 <thedward> hah
15:43:41 <Cale> @plugs List.map (+5) [1,2,3,4,5]
15:43:43 <lambdabot> [6,7,8,9,10]
15:43:48 <Cale> @plugs Prelude.map (+5) [1,2,3,4,5]
15:43:50 <lambdabot> [6,7,8,9,10]
15:44:28 <Cale> GHC.Base probably isn't imported directly, though that's where the function actually exists.
15:45:58 <Cale> Someone probably modified the runplugs source to import Data.Set normally, without realising that it was also imported qualified already. Or it's been set up to import Data.Set as S, but not qualified as S
15:46:22 <dons> hmm. let's see.
15:46:59 <dons> maybe i have the wrong version of runplugs
15:50:56 <dons> @eval map (+5) [1,2,3,4,5]
15:50:58 <lambdabot> [6,7,8,9,10]
15:51:02 <dons> wrong runplugs version
15:51:56 * dcoutts pushes hIDE html viewer code
15:52:01 <dons> yay!
15:52:06 <dons> @karma+ dcoutts
15:52:07 <lambdabot> dcoutts's karma raised to 2.
15:52:08 <dcoutts> http://haskell.org/~duncan/hIDE/hIDE-htmlviewer.png
15:52:54 <dcoutts> it's built as a seperate plugin, so it should serve as an example of how to do that for Yi
15:53:20 <dcoutts> the demo editor is currently part of the ide shell package, though it should really be split out
15:54:24 <dcoutts> or at least it should not be added to the main window by the ide shell plugin_main, since that's a policy question and the ide shell should be policy neutral
15:54:39 <dcoutts> same goes for the file browser
15:55:02 <dcoutts> the file browser might be part of the ide shell package but it should only use the public interface
15:55:28 <dcoutts> and actually be added to the main window by some policy module (and probably based on user config)
15:55:53 <dcoutts> but for now it's hard coded
15:56:18 <rep> it'd be really nice if "darcs push blah@blah.com:~/repo" didn't need darcs installed on the remote machine as well.
15:56:19 <dons> ok, good. i'll take a look at that.
15:56:28 * dons wonders how we're going to test all this stuff
15:56:43 <dcoutts> dons, we've got lots of volunteers :-)
15:56:48 <dons> rep, that would be just too easy.
15:56:49 <rep> because right now i have to manually login in the machine, rm -rf the repo, and scp -r it again
15:56:52 <dons> dcoutts, true.
15:56:59 <dons> rep, what about rsync?
15:57:04 <rep> s/login in/log in/
15:57:08 <dons> oh, you need that on the remote repo too.
15:57:09 <rep> dons i don't know how to use it :P
15:57:12 <dons> ssh. oh you need that too
15:57:25 <dons> oh well. looks like you *always* need the server on the other end
15:57:32 <rep> let me see if the remote machine has rsync
15:57:33 <dons> at least the darcs 'server' is just darcs
15:57:54 <dcoutts> darcs push by xmlrpc via a php/cgi thing would be nice
15:58:09 <dcoutts> though the server would still need darcs
15:58:16 * dons gets scared that dcoutts would suggest pushing through php code...
15:58:35 <dcoutts> dons, well just because most web servers have php by default
15:58:46 <dcoutts> I would not otherwise advocate phph :-)
15:58:55 <dons> hehe. yeah, isn't this  what shapr wants too?
15:59:06 <rep> maybe i should just compile darcs on another machine, and upload it there
15:59:11 <rep> so that i can use it
15:59:13 <dcoutts> dons, yeah, but he'd use cgi
15:59:23 <dons> rep, is it the same kind of machine as the one you're on?
15:59:28 <dons> maybe you can just copy the binary?
15:59:39 <rep> dons no, that's why i haven't done this already
15:59:46 <dons> ok
15:59:56 <dcoutts> dons, but I think most web space you ca get ahold of limits cgi to some dirs but seems to allow php anywhere, so it'd be easier to deploy on ordinary webspace
16:00:41 <Heffalump> ick!
16:00:46 <dons> also, while you'r ehere. what should we do about the hIDE name?
16:00:47 <Heffalump> php *EVIL* :-)
16:00:51 <dons> do we just keep it
16:01:03 <dcoutts> dons, maybe, did we find anything better?
16:01:11 <dcoutts> @where hIDE
16:01:12 <lambdabot> http://www.haskell.org/hawiki/hIDE
16:01:31 <dons> I don't like yiDE, so we could scratch that. it doesn't make much sense, as yi is only 1 part
16:01:38 <dcoutts> #
16:01:38 <dcoutts> hs as Haskell Studio :-) (Gour)
16:01:38 <dcoutts> #
16:01:38 <dcoutts> yiDE - since it uses yi and is an IDE (aleator)
16:01:38 <dcoutts> #
16:01:39 <dcoutts> A name prefixed with "Free" or "Open", i.e. FreeIDE, ?FreeCode(?), FreeHS, ?FreeStudio, ?OpenStudio etc. (to emphasise that we are free!) (dons)
16:01:42 <dcoutts> #
16:01:44 <dcoutts> On the 'Studio' theme, the obvious one is "?HaskellStudio". But the MS haters might object :-) (dcoutts)
16:01:46 <dcoutts>     *
16:01:48 <dcoutts>       well, the full name of [WWW]Anjuta is "Anjuta ?DevStudio" :-) (gour)
16:01:50 <dcoutts> #
16:01:52 <dcoutts> why not hIDE?
16:01:54 <dcoutts> #
16:01:55 <dons> FreeCode: I like that.
16:01:58 <dcoutts> Hive: Haskell Integrated Visual Editor (Environment), or somesuch.
16:02:03 <ndm> yeah, hIDE seems pretty good
16:02:10 <ndm> its already got a name, why change it?
16:02:27 <dons> esp. after the "oh sorry, the source isn't available" that ended the Visual Studio talk at the HW :S
16:02:39 <dons> ndm, well, it isn't hIDE though
16:02:41 <dcoutts> dons, oh yeah? :-)
16:02:44 <rep> FreeHaskellStudioIDE
16:02:59 <dcoutts> rep, hmm that's a bit short
16:03:02 <rep> :D
16:03:18 <ndm> dons, the lack of source didn't worry anyone using Windows and Visual Studio
16:03:20 <dcoutts> OpenFreeHaskellStudioIDEThingy
16:03:30 <dons> ndm, but no good for anyone who wants to do research
16:03:30 <dcoutts> OpenFreeHaskellStudioIDEVisualThingy
16:03:35 <ndm> i think the haskell thing is great
16:03:35 <rep> hehe
16:03:38 <dons> it's ok for users
16:03:55 <ndm> its great for users
16:03:58 <Cale> OpenFreeHaskellStudioIDEVisualThingyByNiceMonomorphisms
16:04:03 <ndm> it just works, no stupid compiling and cvs checkouts etc.
16:04:09 <dons> and since it's all researchers at HW, lack of source is pretty bad, I think.
16:04:23 <ndm> maybe its lost a few potential devleopers, but hte cool factor outweights that
16:04:24 <dons> maybe it's all written in C! who knows ;)
16:04:49 <ndm> wouldn't worry me in the least if it was
16:04:54 <ndm> its pretty cool anyhow
16:05:01 <dons> well, I got a few questions about hIDE  source afterwards, which makes me suspicious the open src issue is troubling to some
16:05:13 <dcoutts> it's no good for people wanting to write extra plugins for their own tools
16:05:13 <Korollary> Why not pick a name like 'eclipse' which doesn't convey anything about the piece of software it's given to ?
16:05:21 <dons> ndm, it's hard to duplicate results, if you don't have access to how it was done.
16:05:37 <Cale> Yeah, let's call it "Eclipse", heh :)
16:05:52 <ndm> dons, depends whether you consider it research or an end product
16:06:14 <dons> sure. i'm not really concerned about users here. more on how we go about building on their work.
16:06:14 <Cale> (and stubbornly claim ignorance of the other Eclipse :)
16:06:22 <JohnMeacham> aftermorning.
16:06:26 <rep> call it FUNctor!
16:06:46 <rep> "it's fun to use!"
16:06:54 <Cale> "Natural Transformation"
16:06:55 <Korollary> Cale: And no "H"'s in the name
16:07:15 <dons> I am suspicious that closed src VH will be a dead end.
16:07:31 <dons> it will be hard for Krasimir to maintain it on his own.
16:07:42 <Korollary> dons: It's probably subject to the same restrictions as F# code.
16:07:44 <dons> maybe he will, but the successful projects are ones that take contributoins from outsiders
16:07:47 <ndm> since its build on a closed source OS, with a closed source tool, i'm less worried
16:08:08 <ndm> and since as far as I am concerned, visual haskell + winhugs is a pretty perfect platform
16:08:14 <ndm> all it lacks is a debugger
16:08:26 <Korollary> "AlienTech Quantum Source Editor"
16:08:33 <dons> what if krasimir stops working on it, then you're screwed if say, ghc libraries change
16:08:52 <dons> you end up having to develop code that works only with the ghc they bundle
16:09:03 <JohnMeacham> VH is closed source? whatever for?
16:09:13 <dons> M$ reasons.
16:09:23 <ndm> i only write code that works with winhugs
16:09:40 <ndm> since GHC 6.5 supports more features than WinHugs is ever likely to, i have little cause for concern
16:09:47 <thedward> @plugs let nine = mkRegex "[9]" in matchRegex nine "192939495"
16:09:52 <ndm> obviously, open source would be massively preferable!
16:09:54 <JohnMeacham> where can I win hugs? I need my daily affirmation.. /noise
16:09:56 <lambdabot> <irc>:1:11: Not in scope: `mkRegex'
16:09:56 <lambdabot>  
16:09:56 <lambdabot> <irc>:1:28: Not in scope: `matchRegex'
16:10:01 <Cale> How about calling it "MacLane" after one of the founders of Category theory :)
16:10:11 <dcoutts> ndm, except for all the bugs in ghc 6.5 that you can't fix :-)
16:10:23 <dons> dcoutts, I just worry that "hIDE" sounds kind of ugly or clunky
16:10:28 <ndm> dcoutts, yeah - a shame, but none have bit me yet
16:10:29 <Korollary> Cale: Why keep praising these useless mathematicians ;) Name it after Jessica Simpson instead.
16:10:40 <dons> oh, good idea K!
16:10:41 <thedward> @plugs let nine = Text.Regex.mkRegex "[9]" in Text.Regex.matchRegex nine "192939495"
16:10:41 <dcoutts> dons, yes it doesn't lower case very well
16:10:52 <lambdabot> <irc>:1:11: Not in scope: `Text.Regex.mkRegex'
16:10:52 <lambdabot>  
16:10:52 <lambdabot> <irc>:1:39: Not in scope: `Text.Regex.matchRegex'
16:10:58 <Cale> Just []
16:11:15 <thedward> why doesn't that return the nines?
16:11:27 <work_metaperl> freebsd only has ghc-5 in ports... my my my
16:11:39 <work_metaperl> but that will do for a rank n00b such as I
16:11:44 <Cale> thedward: you didn't ask for any subexpression matches
16:11:52 <Cale> Just [] means the match succeeded
16:12:09 <Korollary> thedward: It complained about out of scope symbols
16:12:18 <Cale> let nine = Text.Regex.mkRegex "([9])" in Text.Regex.matchRegex nine "192939495"
16:12:19 <thedward> got it
16:12:28 <Cale> this will give Just ["9"]
16:12:32 <dcoutts> dons, I'm not particularly tied to "hIDE", I'm happy to have something different if we can agree on something better
16:12:35 <thedward> I blame my abusive perl upbringing
16:12:52 <Cale> let nine = Text.Regex.mkRegex "(9.*9)" in Text.Regex.matchRegex nine "192939495"
16:12:53 <Cale> Just ["9293949"]
16:12:53 <thedward> perl has an implicit set of () around the regex
16:12:54 * Heffalump thinks hIDE is a good name
16:13:02 <Korollary> "Badass Edgy Code Editor"
16:13:09 <int-e> hideous
16:13:12 <Korollary> lol
16:13:15 <dcoutts> int-e, nice :-)
16:13:38 <dcoutts> hideous would be a good name for a hIDE plugin
16:13:48 <Heffalump> like vile
16:13:50 <Korollary> for some definition of good
16:14:18 <ndm> everyone now knows hIDE - if you change it you get a million "was that previously know as hIDE" questions
16:14:25 <dcoutts> ndm, true
16:14:26 <Korollary> "a million" ?
16:14:31 <dcoutts> well 7
16:14:33 <dcoutts> :-)
16:14:37 <dons> yeah. esp. after mentioning it at the HW
16:14:48 <Korollary> "The editor formally known as hIDE"
16:15:03 <dcoutts> so what's wrong with hIDE? as lowercase it's hide
16:15:10 <dcoutts> anything else bad?
16:15:16 <Cale> Heh, its name could just be some funky symbol which doesn't occur in Unicode
16:15:18 <Korollary> It's a timid verb
16:15:26 <dons> Cale, great idea!
16:15:39 <dons> symbols for all!
16:15:41 <Korollary> Cale: How about a large prime number that people can't remember ?
16:15:48 <dons> oh, even better
16:15:57 <dons> prim numbers, I really like that
16:16:05 <Korollary> This is the equivalent of a suicidal marketing department
16:16:15 <dcoutts> prim numbers are neater than prime numbers
16:16:16 * dons decides to name all future projects using prime numbers, in binary
16:16:35 <work_metaperl> you mean this IDE thing is not going to be called MyHaskell and be bought out by MySQL AB?
16:16:37 <Cale> Its true name is written as a product of two large prime numbers, but we'd only ever use the multiplied out version in public.
16:16:42 <work_metaperl> marketing is EVERYTHING
16:16:59 <work_metaperl> look at how MySQL over took postgres. We can overtake OCaml the same way
16:17:00 <dons> well, we can multiply by the prime numbers used to name all the plugins
16:17:11 <Cale> heh
16:17:19 <Heffalump> 10 11 101 111 1011 1101 ....
16:17:28 <Korollary> The name must include the letter X somehow. If possible, it should express the senses of "maximum", "extreme", "overlord", etc.
16:17:33 <dcoutts> dons, oh that'd be a good way of selecting which plugins to load, just spcify one massing prime number
16:17:43 <Heffalump> one massive composite number, surely
16:17:50 <dcoutts> err yah
16:17:51 <work_metaperl> the IDE _must_ have a ticker banner at the bottom with various propaganda scrolling by as you program: "did you know that haskell placed 1st in the 2005 and 2004 ICFP competition"???
16:17:57 <ndm> the number might be ambiguous as to which plugins
16:18:06 <thedward> Cale: is there anyway to make it return all the matches?
16:18:20 <dcoutts> work_metaperl, I'll let you write that plugin :-)
16:18:21 <ndm> work_metaperl - the great advantage of open source, the ability to remove advert banners!
16:18:23 <dons> dcoutts, ok. "hide" is fine with me. though we should probably release it as 2.0 when we're done.
16:18:33 <JohnMeacham> Hmm.. did someone already come up with a 'foreign' convention for .NET? any idea where I can see it?
16:18:37 <int-e> Hmm, I like signed ternary numbers. 0, +, +-, +0, ++, +-- ...
16:18:38 <work_metaperl> no, banners are removed for a small fee --- 200/month
16:18:43 <dcoutts> dons, except that then people will expect it to work :-)
16:18:54 <dons> ok. 0.2 then ;)
16:18:59 <work_metaperl> yes, this IDE needs flashing banner ads or I won't use it
16:19:12 <work_metaperl> and a built-in macromedia flash player
16:19:25 <dons> I hope that we can turn off most things so that it looks like vim or emacs, if needed
16:19:29 <Korollary> JohnMeacham: ghc has a GHC.Dotnet module iirc
16:19:30 <dcoutts> dons, the original hIDE got to version 0.3524578
16:19:40 <Cale> thedward: it normally does -- there's matchRegexAll though, which returns more information
16:19:41 <dons> just with lots of cool stuff underneath
16:19:49 <dons> 0.3524578 ?
16:19:50 <ndm> JohnMeacham, there is also a Hugs .NET module
16:19:57 <dcoutts> work_metaperl, it's already got a macromedia flash player, I just committed the mozilla plugin :-)
16:20:01 <dons> or we could use patch counts, a la lambdabot
16:20:11 <work_metaperl> dcoutts: sa-weet
16:20:13 * Cale hits up the Inverse Symbolic Calculator
16:20:23 <thedward> Cale: let nine = mkRegex "(9)" in matchRegex nine "192939495" ; returns just one 9
16:20:42 <ndm> surely hIDE will be upgraded incrementally, while running? hence version is not that relevant
16:20:46 <dcoutts> dons, you can see the crazy numbering system it used: http://www.dtek.chalmers.se/~d99josve/hide/CHANGELOG
16:20:47 <JohnMeacham> ah, I was more interested in what 'foreign import's should look like, since i plan native support for it.
16:20:55 <dons> 0.4pXYZ, where XYZ is $ darcs changes --xml-output | sed -n '/TAG/q;/^<\/patch/p' | wc -l | sed 's/ *//g'
16:20:58 <dons> 42
16:21:42 <dcoutts> dons, yeah that's ok
16:21:45 <Cale> hmm... 2^(1/3)/(11+10^(1/4))^(1/2)
16:21:56 <Cale> @eval 2**(1/3)/(11+10**(1/4))**(1/2)
16:21:59 <lambdabot> 0.3524578127513541
16:22:21 <dons> hmm. crazy swedes. it's not a monotonic version number?
16:22:37 <astrolabe> It looks like fibonacci to me
16:22:46 <dcoutts> dons, I think it's monotonic lexographically
16:22:54 <Cale> thedward: that regex only matches one of the 9's
16:22:54 <ndm> JohnMeacham, http://cvs.haskell.org/cgi-bin/cvsweb.cgi/hugs98/dotnet/examples/basic/Http.hs?rev=1.3;content-type=text%2Fplain
16:23:17 <ndm> foreign import dotnet  "static System.Net.WebRequest.Create" createURL :: String -> IO (WebRequest ())
16:23:18 <dons> ah, ok :)
16:23:49 <Cale> thedward: use matchRegexAll to catch the unmatched portions of the string and recurse
16:24:49 <thedward> Cale: will matchRegex ever return more than one value in the list?
16:25:11 <thedward> oh never mind
16:25:13 <thedward> I understand
16:25:56 <thedward> each sub expression can only match once
16:26:10 <Cale> let phone = Text.Regex.mkRegex "([0-9]{3})-([0-9]{4})" in Text.Regex.matchRegex phone "555-0972"
16:26:10 <Cale> Just ["555","0972"]
16:27:56 <Cale> http://oldweb.cecm.sfu.ca/cgi-bin/isc/lookup?number=0.3524578&lookup_type=simple :)
16:28:01 <dcoutts> dons, other ideas, blatently stealing names of other IDEs "HDevelop", "HCode", "HaskellStudio"
16:28:45 <JohnMeacham> ndm: ah cool! thanks. I will try to make it compatable. not sure what to do about the standard libs though.. I'd hate to have to use a preprocessor.. but I don't think I have a choice.
16:29:31 <Lunar^> haskode?
16:29:49 <work_metaperl> I like haskode
16:30:11 <Lunar^> sounds KDE a bit.. though
16:30:17 <humasect> haskitchen =(
16:30:48 <Korollary> rofl
16:31:49 <sethk> How about Eddie (for editor) as in EddieHaskell?
16:32:14 <humasect> interesting
16:32:30 <int-e> I'd be afraid it would mangle my code too much.
16:32:32 <sethk> I might be the only one here who remembers why that might sort of be funny
16:32:33 <humasect> "hIDE" is wrong?
16:32:43 * int-e likes hIDE btw.
16:32:44 <sethk> I like hIDE, actually
16:32:53 <work_metaperl> hIDE is fresh
16:32:55 <sethk> but since the topic came up ... :)
16:33:13 <humasect> to see if there is any hiding ideas that could blow it out of the water ? =)
16:33:23 <work_metaperl> leave it as hIDE and it keeps the hIDE/yIDE thing going
16:33:35 <Cale> Corona -- if they can use moderately astronomical terms, so can we
16:34:23 <dcoutts> Cale, :-)
16:34:38 <dons> dcoutts, HCode is nice.  I also like FreeCode
16:35:01 <dons> but it seems noone else does :p
16:35:34 <sethk> work_metaperl, if you want to blow it out of the water, you can use H-bomb
16:35:47 <humasect> heh
16:36:14 <dcoutts> I guess we stick with hIDE then unless someone comes up with something much better (and soon since it gets harder and harder to change)
16:36:32 <Korollary> is the capitalization mandatory ?
16:36:34 <sethk> dcoutts, I think hIDE is just fine
16:36:48 <sethk> anybody have a current email address for paul hudak?
16:36:54 <dcoutts> Korollary, pretty much otherwise it's hide
16:37:05 <dcoutts> which is just a word, not a name
16:37:16 <humasect> which google prefers over hIDE
16:37:20 <Korollary> ooh
16:37:22 <Korollary> good point
16:37:29 <Korollary> good luck googling for that name
16:37:39 <work_metaperl> hIDE is kOOL
16:37:42 <humasect> the wiki is on the first or second page =) (for hIDE)
16:37:47 <dcoutts> @google hIDE Haskell IDE
16:37:48 <lambdabot> http://haskell.org/hawiki/hIDE
16:38:01 <dcoutts> @google Haskell IDE
16:38:03 <lambdabot> http://eclipsefp.sourceforge.net/
16:38:07 <dcoutts> heh
16:38:11 <humasect> o_o
16:39:06 <Korollary> you don't have to put "eclipse java" in google to get to eclipse.org, tho
16:40:10 <humasect> it just takes a few popularity ranks for google to put it at the top
16:40:20 <humasect> ie. searching for Window Paint
16:40:27 <humasect> *s
16:41:43 <humasect> is Visual Haskell taken or too fruity? HCode is cute.
16:41:58 <dcoutts> Visual Haskell is taken
16:42:11 <work_metaperl> no, hIDE r00lz
16:42:16 <work_metaperl> ownz
16:42:18 <dcoutts> @google Visual Haskell
16:42:20 <lambdabot> http://www.haskell.org/visualhaskell/
16:42:35 <work_metaperl> hIDE and jEKYLL
16:42:37 <humasect> oh, right. fitting
16:43:09 <work_metaperl> jEKYLL: just-in-time Extended Y-ary Logic Language
16:43:12 <humasect> hYDE has the Yi in there..
16:43:27 <work_metaperl> no yI is a sidekick project...
16:43:34 <work_metaperl> hIDE and yI are siblings
16:43:48 <work_metaperl> synergistic acronym pumping going on here
16:43:58 <work_metaperl> linguistic backscratching
16:44:33 * dcoutts goes to bed
16:44:52 <dcoutts> tell us if you come up with anything you think is good
16:47:15 * dons attempts to prepare a class on detecting bugs in C programs (all of which would be ruled out statically in Haskell)
16:54:38 <Korollary> even logic errors ?
17:01:07 <dons> these are all memory management bugs, basically
17:02:15 <dons> terminating strings, not initialising variables, not distinguishing null ptrs from Just x
17:03:23 <sethk> dons, how about strcpy with a longer to a shorter string
17:03:28 <sethk> dons, memset with the wrong length
17:03:46 <sethk> dons, free x when x has already been freed
17:03:52 <dons> looping incorrectly, messing up types, not allocating memory dynamically etc.
17:04:03 <dons> free(x) is good
17:04:07 <dons> use after free is good too
17:04:29 <dons> and strcpy. all these are good examples, thanks!
17:04:42 <sethk> dons, I've got lots more if you need them.  :)
17:04:49 <dons> :S
17:05:31 <humasect> heh
17:05:33 * dons will sneak in lots of good haskell into this class, as "pseudocode" hehe
17:06:01 <Cale> :)
17:06:27 <sethk> dons, don't forget  x = malloc(whatever)     x = y   free x
17:06:40 <dons> heh. nice :)
17:06:47 <sethk> one of my favorites.  :)
17:06:51 <Korollary> also "printf("%d %d", 4)"
17:07:18 <dons> doesn't gcc spot that?, K?/
17:07:34 <dons> it would be a gcc extn if it does, though.
17:07:42 <sethk> dons, depends on the flags, I think
17:07:44 <Korollary> I dont know. MSVC didn't, once upon a time for me.
17:08:29 <sethk> dons, I know gcc didn't with version 2
17:08:39 <Korollary> sprintf a large string into a tiny buffer
17:08:41 <sethk> dons, easy enough to check.
17:09:04 <sethk> Korollary, dons, just sprintf( "%d", &q)   when the length of q < length of integer
17:09:12 <dons> hmm. doesn't spot it!
17:09:13 <sethk> much harder to spot and just as nasty
17:09:21 <dons> paprika$ gcc -Wall t.c
17:09:21 <dons> t.c: In function `main':
17:09:21 <dons> t.c:3: warning: too few arguments for format
17:09:29 <dons> so use -Wall :)
17:09:50 <sethk> dons, use my example.  The correct number of arguments, just one of the wrong size
17:09:54 <dons> sethk, another type error. mm.
17:09:57 <dons> good one.
17:10:01 <Korollary> use -Wall and lint
17:10:08 <dons> use Haskell!
17:10:28 <dons> and only use C if you can QC it ;)
17:10:30 <PKirby> I wish my uni would offer a class in Haskell or functional programming generally. I wonder if that could be made into a seminar or something here.
17:10:44 <wagle> can C be QC'd?
17:10:49 <Korollary> PKirby: Which uni is that ?
17:10:52 <dons> PKirby, come to UNSW, you'll get 3 or 4 courses in it.
17:11:00 <dons> wagle, using the FFI. examples in Yi.
17:11:03 <PKirby> not a big one, the CSU of Fullerton, California
17:11:09 <dons> import your C function, then run QC on it.
17:11:19 <Korollary> PKirby: maybe UC Irvine would do something like that
17:11:27 <sethk> PKirby, see if they'll hire an instructor with thirty years of experience but only a bachelors degree.  :)
17:11:34 <dons> maybe this isn't a widely-known trick, wagle?
17:11:43 <wagle> dons: i used to build "secure" linux distributions by modifying gcc to check for memory corruption..
17:12:15 <dons> cool. they do that on OpenBSD a lot. we use lots of custom gcc extns implemented by an OCaml/kernel hacker
17:12:17 <wagle> i was thinking QC was "Quality Control"
17:12:26 <dons> QuickCheck  :)
17:12:47 <Korollary> QuickIDE
17:13:05 * Korollary keels over
17:13:27 <wagle> ah
17:13:57 <wagle> what would a co-roll-ary do?
17:14:38 <Korollary> the term or me ?
17:15:07 <dons> yeah, I like this one:     char q = 0;
17:15:07 <dons>     printf("%d\n", &q);
17:15:28 <int-e> cute.
17:15:30 <Korollary> why &q ?
17:15:42 <int-e> 'print stack pointer or thereabouts'?
17:15:44 <wagle> i dunno..  i was just thinking that a koROLLary might actually "roll" over..  then i couldnt stop following that train of..  uhmm.. "thought"..
17:15:44 <PKirby> you want to print the address of the location of the char q?
17:16:09 <Korollary> sizeof(char*) is probably == sizeof(int)
17:16:11 <dons> oh, firstly, my mistake. that type error isn't picked up. but it wasn't the one that was suggested earlier
17:16:35 <Korollary> it's not a type error per se anyway
17:16:47 <sethk> Korollary, no, that's why c is so evil
17:16:53 <brx> given class Foo, instance Foo Bar and instance Foo Blah, is there a way to keep Blahs and Foos within the same datastructure in a painless way?
17:17:21 <dons> and anyway, printf is a totally crazy runtime metaprogramming construct, in a weakly typed language like C. no wonder there's so many bugs relating to printf/sprintf
17:18:00 <Korollary> dons: You could probably come up with more examples around the operator precedence subject
17:18:02 <sethk> dons, oh, absolutely
17:18:03 <dons> didn't they think: hmm, why are we doing this, when they realised they needed varargs to get printf working?
17:18:19 <sethk> dons, well, remember that varargs was a hack in the first place
17:18:29 <sethk> dons, and the original varargs was so bad that ANSI changed it
17:19:19 <wagle> printf seems a little better than fortran's format statement (but I dont remember how)
17:19:45 <wagle> varargs is still kinda broken
17:20:26 <Korollary> dons: also you could talk about the fact that the C object files don't have full signatures for symbols.
17:20:29 <dons> metaprogramming is *hard*, esp. runtime metaprogramming (i.e. printf(s,a,b,c,d)) ; and sprintf is even worse. good thing things like snprintf and strlcpy are slowly creeping into the idiom
17:20:30 <wagle> .. in the sense that things go wrong if the type signatures of the caller and callee dont match
17:21:10 <sethk> wagle, I think I'd dispute that.  There is no way to write to a random memory location with fortran's format
17:21:22 <sethk> wagle, although I must admit it's been about 20 years since I used it.
17:21:31 <dons> K, interesting point. so linking is a rather risky affair. then again, Haskell .o files are also untyped.
17:21:31 <wagle> sethk: same here
17:21:33 <Pseudonym> But you could set 4 to a random number.
17:21:42 <dons> luckily we have linkers that use .hi files as well :)
17:21:47 <sethk> Pseudonym, true  :)
17:21:55 <Pseudonym> Actually, I _think_ you can manipulate memory in modern Fortrans.
17:22:01 <Pseudonym> Fortran 90 or whatever it's called.
17:22:14 <sethk> Pseudonym, quite possible, I'm way older than that.  :)
17:22:18 <wagle> sethk: i was more thinking in terms of ease of use, though
17:22:28 <Pseudonym> But I purposely only learned enough Fortran to be able to translate GAMS code into Haskell.
17:22:34 <Korollary> 4 is a random number in a very limited set of outputs ;)
17:22:44 <wagle> no bounds checks  in the fortrans i used
17:22:59 <Pseudonym> sethk: How old ARE you?
17:23:06 <Korollary> drumroll
17:23:09 <sethk> Pseudonym, 53
17:23:15 <Pseudonym> OK, that's older than most.
17:23:23 <sethk> Pseudonym, and somehow I think I can figure out monads
17:23:30 <Korollary> living proof !
17:23:44 <Pseudonym> Well Moggi is older and he figured out monads.
17:23:50 <sethk> by the way, on that subject, all the docs say "monads are a concept from category theory" but I haven't found one that says _what_ a monad is in category theory
17:23:50 <Pseudonym> :-)
17:23:59 <sethk> Pseudonym, then at least it is theoretically possible
17:24:17 <sethk> Pseudonym, actually, I think I figured them out, and I'm writing a "monads for people like me who are supposed to be smart" document
17:24:22 <Pseudonym> :-)
17:24:25 <Pseudonym> I'd like to see that.
17:24:27 <dons> hmm. do Moggi's papers talk about category theory. I can't remember.
17:24:29 <sethk> Pseudonym, but it took me absolutely forever
17:24:36 <Korollary> sethk: You should submit that to The Monad Reader (of all places)
17:24:41 <dons> or do they talk about Liebniz.
17:24:47 <sethk> Korollary, I will when I think it is reasonably clear
17:24:56 <sethk> someone want to review it?  I should have it tomorrow, I hope
17:25:02 <Korollary> I want to review it
17:25:07 <Pseudonym> dons: Yes, they do.  KIND of.
17:25:10 <Korollary> I was going to write one myself even
17:25:10 <Pseudonym> I do too.
17:25:30 <Pseudonym> I'm in the enviable position of having a guaranteed salary for the next three months but having no work to do.
17:25:40 * Korollary hires Pseudonym
17:26:03 <Pseudonym> Korollary: Could you wait three months please?
17:26:04 <Korollary> 3 months. geez.
17:26:22 <Korollary> Pseudonym: you cannot be hired even as a janitor in the meantime ?
17:26:30 <wagle> Pseudonym: big chance to double your salary...
17:26:33 <Pseudonym> No, they have a contract for that.
17:26:39 <Korollary> wow
17:26:59 <Pseudonym> It was an odd piece of stupidity that resulted in me ending up this way.
17:27:12 <Pseudonym> Which I shall discuss on haskell-blah, since it's not logged.
17:27:16 <Korollary> lol
17:27:18 <Pseudonym> If anyone is curious.
17:27:21 <Korollary> I was just going to say that
17:27:25 <Pseudonym> :-)
17:27:29 <sethk> Korollary, ok, can you drop me an email?  seth@cql.com   or pm me your email.  (Most people don't like to put it on the channel although I don't worry on this channel)
17:27:43 <Korollary> This time I can pm you, so feel free to get it off your chest
17:27:49 <Pseudonym> :-)
17:28:11 <Pseudonym> My position isn't a secret, but there's always the chance that I'll inadvertantly badmouth someone that I shouldn't.
17:28:26 <Korollary> like the guy on kuro5hin.org ?
17:28:32 <Pseudonym> Oh, I loved that!
17:28:33 <sethk> Korollary, maybe we can publish it together if you think you have good stuff to add
17:28:55 <Pseudonym> So if anyone has any papers they need co-authored...
17:29:03 <Pseudonym> ;-)
17:29:12 * Korollary is sitting at home for 10 days as well.
17:29:24 <sethk> I'm merely between contracts
17:29:41 <sethk> except that I'm trying to think up a business that will bring in enough money so I never have to write C++ or Java again
17:30:00 <humasect> hmm... doing .NET for contract is similar
17:30:07 <Korollary> Hooters is a fine business model imho
17:30:21 <humasect> you could in theory let Google do the work for you
17:30:33 <sethk> humasect, not as bad as c++, perhaps, but not ideal
17:30:43 <sethk> Korollary, what's hooters?
17:30:53 <humasect> System.Configuration.SystemConfiguration <-- !!
17:31:13 <wagle> @google hooters
17:31:14 <lambdabot> http://www.hooters.com/
17:32:07 <Korollary> sethk: Umm, the certain restaurant & bar where the waitresses are, umm, unnecessarily sexy
17:32:26 <sethk> Korollary, unfortunately, I'm not unnecessarily sexy.
17:32:34 <sethk> unless you are turned on by logic, of course
17:32:39 <Korollary> sethk: You don't have to be. You'll be running the business.
17:32:49 <sethk> Korollary, I don't think I have enough capital  :)
17:33:09 <Korollary> damn capitalism
17:33:52 <sethk> based on a cursory look, I doubt any other system would produce hooters
17:36:45 <rep> is okasaki's book any good?
17:38:58 <sethk> rep, I like it
17:39:09 <sethk> rep, I found an error in a footnote, and he said it was the only one anyone found
17:39:20 <sethk> so it is accurate, if nothing else
17:39:29 <rep> hehe
17:39:32 <sethk> and I find the approaches interesting
17:39:42 <sethk> but I like quantifiable analyses
17:40:06 <Korollary> sethk: Maybe no one reads it ;)
17:40:36 <sethk> Korollary, possible, I suppose, but the book is in ML and the Haskell is in the footnotes, so I don't think that really explains it
17:40:48 <sethk> Korollary, did you read it?
17:41:01 <Korollary> sethk: No, even though amazon.com keeps recommending it to me.
17:41:26 <sethk> Korollary, it's the only one I've seen that says "here is how to calculate the characteristics of a purely functional algorithm"
17:41:44 <sethk> Korollary, although other books touch on it here and there
17:42:07 <Korollary> sethk: Neat. I should get it sometime.
17:42:16 <brx> due to haskell's static typing and my shortsightedness, "Either Plane Sphere": http://sphinx.tcs.ii.uj.edu.pl/~core/test.png http://sphinx.tcs.ii.uj.edu.pl/~core/planes.png
17:42:41 <sethk> Korollary, not to say I've read every book, of course
17:42:53 <sethk> Korollary, but I think I've read the ones that are in print
17:44:32 <sethk> now watch people list 10 books I haven't read   :)
17:46:08 <wagle> http://www.crm.umontreal.ca/pub/Ventes/desc/PM023.html
17:46:29 <wagle> best category theory books for csci people i know of
17:46:31 <Korollary> I should read that book, TaPL, and numerous others.
17:46:35 <wagle> book
17:46:54 <sethk> wagle, does that explain why a monad is called a monad?  Not that I'm uninterested if it doesn't.
17:47:13 <wagle> they've obviously been teaching category theory to csci people for years and years
17:47:30 <Pseudonym> monad == monoid + triad
17:47:34 <wagle> i'm only 50 pages into it
17:47:40 <Pseudonym> Seriously.  That's all there is to it.
17:47:50 <sethk> Pseudonym, thanks
17:49:43 <wagle> i wrapped by brain around adjunctions once, then it went away, like trying to remember a dream
17:50:37 <wagle> so this time i'm carefully keeping track of my progress through barr and wells
17:51:07 <wagle> (previously has used pierce's book in a course, but its quite short)
17:51:19 <PKirby> If you could recommend one book on functional programming, what would it be?
17:51:46 <wagle> PKirby: what is your goal?
17:51:56 <sethk> PKirby, I like both Hudak's and Simon Thompson's
17:52:04 <sethk> Hudak's is a bit newer
17:52:09 <PKirby> To be able to write software with Haskell, such as a game or a compiler.
17:52:24 <wagle> oh, so haskell specifically
17:52:26 <sethk> hmm, rather different programming tasks.  :)
17:52:52 <PKirby> Well, I am focusing in Haskell for now, as I don't want to try to swallow too much at once.
17:52:53 <humasect> TMR ;)
17:53:05 <wagle> i wonder how good appel's compiler book in ml is
17:53:22 <Pseudonym> PKirby, if you're interested in writing compilers, you might try one of the Peyton-Jones books on implementing functional languages.
17:53:43 <wagle> Pseudonym: yeah, i liked his first one..  never read the second
17:53:44 <Pseudonym> You get to learn the semantics of a Haskell-like language AND implement bits of its compiler at the same time.
17:54:03 <wagle> Pseudonym: (so that was a good candidate for his question)
17:54:27 <Pseudonym> I liked the first one too.
17:54:32 <wagle> it describes more miranda, which haskell was invented in large part to replace
17:54:48 <Pseudonym> We did Miranda in first year; never truly understood it until I read that book.
17:54:56 <Pseudonym> Well, we technically did Orwell.
17:55:11 <wagle> plus, its a plain g-machine, not spineless tagless g-machine
17:55:25 <Pseudonym> Haskell was actually designed to consolidate all of the potential Miranda-replacements.
17:55:32 <Pseudonym> Orwell, Miracula etc.
17:55:39 <Korollary> lol Miracula
17:55:42 <sethk> the peyton-jones books are hard to find, aren't they?
17:55:50 <Pseudonym> Miracula was pretty quirky.
17:55:53 <PKirby> Which book by Peyton-Jones? what's the title?
17:56:02 <wagle> Pseudonym: i only read the first draft of the haskell definition
17:56:06 <Pseudonym> "The Implementation of Functional Programming Languages" is the first.
17:56:10 <Pseudonym> And it's online.
17:56:16 <Pseudonym> Somewhere on haskell.org.
17:56:24 <Pseudonym> The second one is online too.
17:56:26 <sethk> it is?  that must be relatively new
17:56:29 <Pseudonym> But I can't recall what it's called.
17:56:31 <sethk> where is the second one?
17:56:43 <rep> i think i'll read SICP
17:56:49 <sethk> the second one is with a few chapters by wadler?
17:57:00 <wagle> the first in 1986ish, the second 1991ish
17:57:14 <Pseudonym> http://research.microsoft.com/Users/simonpj/papers/slpj-book-1987/
17:57:16 <Pseudonym> That's the first one.
17:57:48 <sethk> great!  I had to return it to the library when I left arizona
17:57:53 <sethk> how about the second?
17:58:10 <PKirby> Is Hudak's book "The Haskell School of Expression: Learning Functional Programming through Multimedia"?  Is Simon Thompson's book "Haskell: The Craft of Functional Programming"?
17:58:23 <sethk> PKirby, those are the ones I was talking about, yes
17:58:29 <sethk> PKirby, both are excellent, IMO
17:59:01 <Pseudonym> http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
17:59:04 <Pseudonym> That's the second book.
17:59:27 <sethk> that one I hadn't read.  thanks again
18:00:19 <PKirby> Pseudonym: thanks for the links!
18:00:25 <Pseudonym> No problem.
18:01:49 <wagle> is there a canonical description of the stgm?
18:02:07 <Pseudonym> @google "functional languages on stock hardware"
18:02:08 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
18:02:13 <Pseudonym> That's it.
18:02:40 <Pseudonym> Although it doesn't go into detail about how to translate STG into C.
18:02:49 <wagle> was just wondering why he didnt describe it in the second book
18:03:39 <sethk> Pseudonym, while you are on a roll, how about a downloadable book on category theory?
18:04:00 <Pseudonym> @google "categories types and structures" asperti longo
18:04:01 <lambdabot> http://www.di.ens.fr/users/longo/download.html
18:04:06 <Pseudonym> Like that one?
18:04:21 <wagle> there's a couple
18:04:44 <Pseudonym> Sure.  But that one sprang to mind first.
18:04:58 <wagle> yeah..  me too
18:05:02 <Korollary> @google "Barr Wills category theory lecture notes"
18:05:04 <lambdabot> No result found.
18:05:21 <wagle> @google "Barr Wells category theory lecture notes"
18:05:23 <lambdabot> No result found.
18:05:33 <Korollary> @google "computational category theory rydeheard"
18:05:34 <lambdabot> http://www.loria.fr/cgi-bin/DorisWeb/bibvisu?OCLC_W3=3927
18:05:55 <wagle> @google Barr Wells category theory lecture notes
18:05:56 <lambdabot> http://www.let.uu.nl/esslli/Courses/barr-wells.html
18:07:42 <sethk> of those, which do you think is the best one to read first?
18:08:29 <sethk> well, one is lecture notes, the other a book, so forget the question
18:14:53 <rep> what's the advantage of using liftIO over lift?
18:15:06 <rep> (when lifting IO computations)
18:15:25 <wagle> @type liftIO
18:15:31 <lambdabot> bzzt
18:15:36 <int-e> liftIO can work for some Monads that have no lift operation.
18:15:38 <wagle> @index liftIO
18:15:39 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
18:15:39 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
18:15:39 <lambdabot> Monad.Error, Control.Monad.List
18:15:54 <rep> hm
18:16:25 <dave_m> @type Control.Monad.Trans.liftIO
18:16:27 <lambdabot> forall (m :: * -> *) a.
18:16:27 <lambdabot> (Control.Monad.Trans.MonadIO m) =>
18:16:27 <lambdabot> IO a -> m a
18:16:30 <rep> so you can use it even when not using a monad transformer?
18:16:38 <wagle> @type lift
18:16:40 <lambdabot> bzzt
18:16:47 <wagle> @index lift
18:16:48 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
18:16:48 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
18:16:48 <lambdabot> Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
18:16:48 <lambdabot> ParserCombinators.ReadPrec, Text.Read
18:16:50 <dave_m> @type Control.Monad.Trans.lift
18:16:51 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
18:16:51 <lambdabot> (Control.Monad.Trans.MonadTrans t, Monad m) =>
18:16:52 <lambdabot> m a -> t m a
18:17:37 <dave_m> rep: in practice, any monad which implements MonadIO is going to be a transformation of IO
18:17:40 <rep> @type Control.Monad.liftM
18:17:41 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m
18:17:41 <lambdabot> r
18:18:08 <wagle> does IO need to be outermost in the composition?
18:18:48 <dave_m> There's no IO transformer, so it always has to be the base monad, like ST or Identity
18:20:10 <rep> good night
19:34:43 <sethk> Pseudonym, I'm reading that category theory link you posted and I'm wondering (if you know) why (on the first non-introduction page) he shows objects as denoted by a, b ... A, B...   then functions (sorry, morphisms  :)  ) as f, g ...       Does he mean that a, b, c, d, e, A, B, C, D, and E are the symbols used for objects?
19:34:58 <sethk> Pseudonym, that seems strange.
19:35:29 <sethk> Pseudonym, wouldn't it be more normal (if such a thing exists) to use small letters for one, large for the other?
19:36:20 <sethk> Pseudonym, but mostly I don't get the drift of how I'm supposed to know what is an object and what is a morphism
19:57:11 <wagle> sethk: its mostly about arrows (morphisms)..
19:57:27 <sethk> ok, just seems a strange start.  :)
19:57:28 <wagle> f g h are traditionally functions
19:57:45 <wagle> in general math
19:57:47 <sethk> yes, of course, I know that
19:58:03 <sethk> but then we see upper case letters used in a different way on the next page
19:58:17 <wagle> i dunno about the upper/lower case stuff
19:58:22 <Korollary> we need a CT irc channel and a weblog
19:58:58 <wagle> sethk: which one are you looking at?
19:59:23 <sethk> the first link, I think, categories, types, and structures is the title
19:59:56 <wagle> sethk: it'll get wierder very soon when the arrows start becoming the thing that you are transforming, etc
20:02:31 <wagle> asperti and longo?
20:02:45 <sethk> yes
20:03:07 <wagle> i see them saying that A, B, C, etc will denote objects, but i only see them using lower case
20:03:12 <wagle> later on
20:03:19 <wagle> for objects
20:03:42 <sethk> that makes more sense, since they use upper case letters for collections
20:03:49 <wagle> math C and D are used a bit to refer to categories
20:04:16 <sethk> ok, I'll ignore it for now
20:04:55 <wagle> the C for category seems to be in bold facve
20:04:57 <wagle> face
20:05:30 <sethk> sometimes it is a collection
20:05:38 <sethk> thus far it is rather sloppy
20:07:47 <Cale> it's calligraphic C and D that generally are used to refer to categories
20:07:54 <wagle> its a bit tough to learn..  it took me a month in a class to get over the hump
20:08:35 <wagle> which explained why a couple years of a day here and there didnt get anywhere
20:09:18 <sethk> I don't care about it being difficult.  But this is too much of a class text and not enough of a reference.  It isn't even three pages in and it's telling you to prove a crucial result as an exercise
20:09:21 <wagle> a lot of the books seem to assume a lecturer presenting the material and answering questions
20:09:42 <Cale> sethk: which are you looking at?
20:09:46 <wagle> yeah, thats why i recommended the barr and wells, _3rd_ edition
20:10:00 <sethk> last sentence, first paragraph page 3
20:10:06 <sethk> first partial paragraph
20:10:18 <sethk> wagle, was that one on line?
20:10:41 <Cale> oh, sorry, what was the link, rather :)
20:10:44 <wagle> they give lots of exercises and explain to a csci audience
20:10:55 <wagle> sethk: no..  but its cheap
20:11:06 <sethk> Cale, I'll get it, hold on ...
20:11:11 <wagle> gotta order from the canadian company direct
20:12:03 <sethk> http://www.di.ens.fr/users/longo/download.html
20:12:11 <sethk> cale   http://www.di.ens.fr/users/longo/download.html
20:12:26 <wagle> i dont think you can understand diagrams so early
20:12:42 <sethk> wagle, do you have that URL?  I know you gave it earlier but I'm not sure I wrote it down
20:13:17 <wagle> @google "michael barr"
20:13:18 <lambdabot> http://www.math.mcgill.ca/barr/
20:13:29 <wagle> its off his web page
20:13:49 <wagle> http://www.crm.umontreal.ca/pub/Ventes/desc/PM023.html
20:14:29 <wagle> $45 canadian dollars
20:14:58 <Korollary> I don't see a 3rd edition. Do you have an ISBN for that, wagle ?
20:15:06 <Cale> http://www.cwru.edu/artsci/math/wells/pub/ttt.html
20:15:09 <wagle> $45 canadian dollars
20:15:11 <Korollary> oops heh
20:15:17 <wagle> http://www.crm.umontreal.ca/pub/Ventes/desc/PM023.html
20:15:17 <Cale> there's a nice free text online
20:15:28 <gzl> you might like "Basic Category Theory for Computer Scientists"
20:15:34 <sethk> Cale, I'm listening :)
20:15:43 <Cale> http://www.cwru.edu/artsci/math/wells/pub/ttt.html
20:16:15 <wagle> ttt is different and more difficult
20:16:19 <sethk> oh, from the same page, that one I saw
20:16:25 <Cale> It unfortunately calls monads triples
20:16:27 <sethk> but I assumed it wasn't a great first read
20:16:46 <Cale> but it's good for the initial stuff
20:16:55 <Cale> definitions and such
20:16:56 <sethk> Cale, ok, I'll check it out
20:25:44 <wagle> araujo's quote is (quite unfortunately) why programs are so insecure
20:26:05 <wagle> a readable C program is not secure
20:26:08 <wagle> hmm
20:28:42 <sethk> which quote?
20:28:53 <wagle> 20:18 -!- araujo [n=araujo@gentoo/developer/araujo] has quit ["Programs must be
20:28:56 <wagle>           written for people to read, and only incidentally for machines to
20:28:59 <wagle>           execute"]
20:29:33 <sethk> hmm.  Remember the K&R quote about indentation?
20:29:43 <wagle> no...  what is it?
20:30:00 <sethk> wagle, they give an example and remind the reader that "the compiler doesn't get the message"
20:30:12 <wagle> ahaha
20:30:30 <wagle> haskell sortof forces you to indent correctly
20:30:43 <sethk> wagle, no, you can do it C style if you like
20:31:00 <sethk> wagle, haskell just gives you the option to let the compiler get the message
20:31:11 <sethk> which is nice
20:31:27 <Cale> I think that python should adopt a similar mechanism
20:31:45 <wagle> i thought python used the haskell idea
20:32:07 <wagle> (i havent written anything in python, this is just what i hear)
20:32:09 <sethk> for indentation?  Not as I recall
20:32:13 <Cale> I mean, allow braces and semicolons optionally
20:32:39 <Cale> It uses indentation for blocks, but you can't stick braces and semicolons in when you'd like them.
20:32:43 <sethk> Cale, I don't remember that there is an alternative
20:32:49 <Cale> right
20:32:54 <sethk> same with ruby, the indentation is mandatory
20:32:57 <Cale> in python there's no option
20:33:01 <Cale> hm?
20:33:03 <Cale> really?
20:33:16 <Cale> In Ruby, I thought indentation didn't matter -- I could be wrong
20:33:29 <sethk> ruby uses end, but not begin
20:33:35 <sethk> so I don't see how it could be optional
20:33:47 <sethk> well, maybe not
20:33:52 <sethk> for functions it uses def and end
20:34:08 <sethk> and it does have begin
20:34:13 <sethk> so I think I was wrong
20:34:30 <Cale> btw, http://poignantguide.net/ruby/ is a really fun Ruby tutorial -- worth reading just for the extra content :)
20:34:51 <sethk> I almost, but not quite, liked ruby
20:35:01 <sethk> has some interesting things
20:35:17 <Korollary> I like python except for the dynamic typin g business heh
20:36:12 <Cale> I'm actually finding it difficult to program without static typing these days :)
20:36:22 <sethk> well, that's like saying I like ruby except for the object business
20:37:16 <wagle> i've been prototyping some gui stuff in tcl/tk..  even syntax errors arent detected until runtime..  feel _my_ pain!  8)
20:38:20 <heatsink> NameError: name 'idnex' is not defined
20:38:58 <Cale> wagle: really?
20:39:27 <Cale> I wasn't aware that tcl/tk was quite that bad :)
20:39:50 <wagle> its all interpreted
20:39:51 <Korollary> for some definition of "bad". There are proponents of that philosophy as well.
20:39:59 <wagle> everything is a string
20:40:06 <Korollary> ok that's a bit too far.
20:40:09 <heatsink> Do they use strings as first-class functions?
20:40:28 * heatsink saw some php that did that recently
20:40:36 <wagle> it does some really clever stuff with that paradigm, but overall..  i wanna completely rewrite it
20:41:28 <wagle> heatsink: yup, here's one:
20:41:29 <wagle> ::namespace inscope :: {board::map_hex 0 0 {decr_newscan 2 -4}}
20:42:48 <wagle> scoping is a bit..  ahh.. odd, though
20:43:20 <wagle> people tend to write object systems in tcl
20:43:30 <Cale> just be glad that whatever it is, it's not mIRCscript :)
20:44:15 <wagle> ever see rpg II?
20:44:58 <sethk> wagle, crippled cobol
20:45:39 <wagle> rpg II is worse
20:46:19 <wagle> heh: http://www2.latech.edu/~acm/helloworld/rpg.html
20:48:56 <Cale> iirc, there was some issue like most functions in mIRCscript didn't care whether you put commas between the parameters, but some would behave differently depending on whether you did
20:49:23 <Cale> it gave the impression that the parser was completely ad-hoc
20:49:48 <wagle> do 10 i = 1.10
20:49:49 <wagle> ?
20:49:53 <wagle> heh
20:50:07 <wagle> yeah
21:07:29 <lament> heh
21:07:34 <lament> be happy it's not _forth_ ;)
21:07:47 <lament> some languages are merely bad
21:07:55 <lament> others actively drive you insane
21:08:33 <sethk> you don't like forth?  :)
21:08:56 <lament> i'm only vaguely familiar with it, really.
21:09:01 <lament> I really LIKE what i know
21:09:15 <lament> however it's quite obvious that the language WOULD drive insane anybody who used it for long :)
21:09:44 <sethk> it has its situations.  It's not a bad boot loader language
21:32:48 <Pseudonym> Sorry, back.
21:32:49 <Pseudonym> Was afk.
22:22:57 <sethk> The knicks signed a basketball player today named curry, which is messing up my mind when I'm trying to read the newspaper
22:23:50 <sethk> Why does the STG paper print perfectly, but look awful on my screen?
22:24:28 <Korollary> is it a ps file ?
22:24:44 <sethk> Korollary, no, that I see all the time with ps.  It's a pdf
22:24:52 <Korollary> that is odd
22:24:55 <sethk> the other pdfs I downloaded today don't have the problem
22:25:00 <sethk> most be a font mapping thing
22:25:13 <Korollary> maybe the pdf doesn't have the fonts embedded, and your system is missing them
22:25:30 <sethk> Korollary, but then why would it print properly?
22:25:39 <sethk> should use the same fonts for display and print
22:25:42 <Korollary> the printer must have them
22:26:11 <sethk> Korollary, that makes sense, only I don't think it does.
22:26:16 <sethk> too cheap  :)
22:26:29 <Korollary> try converting it into a ps and then back into pdf. maybe that'll fix it.
22:26:58 <sethk> Korollary, hmm, interesting idea, I'll try it.
22:39:39 <sethk> Korollary, that made it just a bit better.
22:42:16 <Korollary> which file is it ?
22:42:26 <sethk> peytonjones92implementing
22:43:59 <Korollary> sethk: The ps.gz version looks just fine on my pc
22:44:09 <sethk> Korollary, must be fonts, then
22:44:43 <Korollary> I got the original ps.gz, tho
22:44:51 <sethk> different?
22:45:00 <Korollary> 171936 bytes
22:45:33 <Korollary> from http://citeseer.ist.psu.edu/peytonjones92implementing.html
22:45:48 <Cale> I find that gv usually does well with papers produced using TeX
22:46:33 <Cale> It looks a little crunchy on the PDF from the citeseer page compared with the postscript file, but certainly readable.
22:47:33 <sethk> Cale, Korollary It looks fine with ps.gz
22:47:48 <Korollary> I converted it into pdf from gsview, and the pdf version looks a little worse
22:49:14 <Cale> yeah -- when given the choice, I usually go with postscript first, as I've had better luck with getting decent quality from it
22:50:28 <Korollary> damn windows xp. it's crawling
22:54:12 <Cale> It's amazing that with the number of users it has, that there seem to be categories of software which are lacking in windows. Good postscript viewers, and terminal emulators seem hard to find. (there's gsview which is moderately acceptable, but seemed sort of awkward)
22:56:19 <Korollary> Cale: I use putty for ssh-related activities
22:56:28 <Cale> yeah, putty is good
22:56:41 <Cale> but it doesn't work for running programs locally
22:56:42 <Korollary> ps should be replaced by pdf anyways
22:56:57 <Cale> hehe, never!
22:57:07 <Korollary> pdf is actually a better format from what I read
22:57:22 <Cale> well, it's not so Turing complete
22:57:28 <Korollary> oh shucks !
22:57:59 <Cale> My friend did some amazing things with hand-coded postscript.
22:58:16 <Cale> Did all of the assignments for his fractals course in it.
22:58:29 <alar> I did handcode postscript
22:59:33 <alar> 0.5 MB data + 48 KB PS code -> 8 MB PDF
23:07:20 <Korollary> let's see if I can drop 900Mb of mp3's over 802.11b into my ipod thru my laptop
23:33:07 <earthy> Good Morning #haskell!
23:37:06 <gour> morning
23:48:18 <alar> the same to you
