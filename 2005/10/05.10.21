00:15:25 <dons> sethk, does it help if you first unregister any old yi's that are installed?
00:15:43 <sethk> dons, let me try...
00:15:48 <dons> also, can you just mail me a log of what happens? dons@cse.unsw.edu.au
00:15:57 <basti_> Lemmih: are you there?
00:16:13 <dons> @localtime Lemmih
00:16:16 <lambdabot> Local time for Lemmih is Fri Oct 21 09:15:54 2005
00:16:21 <dons> Lemmih sleeps now :)
00:16:22 <sethk> dons, package name is yi?
00:16:24 <basti_> :P
00:16:31 <dons> yep , sethk
00:16:54 <dons> ghc-pkg list will tell you anyway
00:17:24 <sethk> dons, wasn't there.  still has the same error (which is to be expected as I didn't change anything)
00:17:32 <sethk> dons, remember I only built the ncurses version before
00:17:38 <sethk> and didn't register it.
00:17:42 <dons> ok. send a log of what I need to do to reproduce this
00:17:56 <sethk> dons, send to?
00:18:12 <dons> mail addr above
00:18:23 <dons> dons@cse.unsw.edu.au
00:25:41 <Lemmih> basti_: I'm here.
00:26:30 <basti_> Lemmih: i'm getting "Error in server: user error (resolveObjs failed with <>)", again with a request to mail you
00:26:34 <basti_> ;)
00:26:51 <basti_> (the other problem was due to me not restarting apache, d'oh! >.<)
00:27:04 <basti_> (in haspr)
00:27:12 * Lemmih stabs 'resolveObjs' with a trout.
00:27:33 <basti_> what is resolveObjs?
00:27:45 <basti_> I didn't find it in the source at all
00:28:09 <Lemmih> It's part of the GHC rts.
00:28:22 <basti_> ohh
00:29:20 <Lemmih> basti_: What does your Apache error log say?
00:29:36 <basti_> haspr: /usr/lib/ghc-6.4.1/HSbase.o: unknown symbol `setIOManagerPipe'
00:29:38 <basti_> ahh
00:29:58 * basti_ has to check that routinely :(
00:33:21 <basti_> Lemmih *highlight*
00:33:23 <Lemmih> The next release of haspr will be a lot more user friendly.
00:33:25 <basti_> ah
00:54:28 <sethk> dons, I've tared up an archive of the directory that had the problem.  Tell if you need it.
01:06:50 <kosmikus> morning
01:07:01 <dcoutts> g'morning
01:09:31 <dcoutts> sethk, what was your gtk2hs build bug?
01:11:22 <ProfTeggy> G'day
01:14:32 <sethk> dcoutts, should I paste it?
01:16:02 <sethk> dcoutts, ghc-6.4.1: internal error: evacuate: strange closure type 26222
01:16:03 <sethk>    Please report this as a bug to glasgow-haskell-bugs@haskell.org,
01:18:21 <dcoutts> sethk, oh you'd better report that to the ghc folk. I can't fix that one.
01:18:43 <dcoutts> sethk, the only other thing you can try it make clean and try it again.
01:18:43 <sethk> dcoutts, aready done
01:18:54 <sethk> dcoutts, I got it to build
01:19:03 <dcoutts> oh you did?
01:19:03 <sethk> dcoutts, you don't have to do make clean,  you just do make
01:19:12 <dcoutts> so the problem went away?
01:19:38 <sethk> dcoutts, it didn't go away, because this is the normal sympton
01:19:48 <sethk> dcoutts, restarting make worked
01:20:31 <dcoutts> hmm, odd
01:20:56 <sethk> dcoutts, it looks a lot like a problem I've seen often with gcc.  I wonder if it _is_ the gcc problem, propogating up.
01:22:19 <dcoutts> possible I guess if gcc miscomplied ghc itself
01:28:08 <CosmicRay> can anyone help me with this segfaulting haskell program?
01:28:14 <CosmicRay> I posted about it on glasgow-haskel-users.
01:28:29 <CosmicRay> strace is not of much help
01:28:32 <CosmicRay> ltrace doesn't work on it
01:28:41 <CosmicRay> and the rts debug stuff doesn't help me, at least.
01:29:25 <dons> hmm. not a good day for ghc bugs today :/
01:29:58 <CosmicRay> heh
01:30:08 <CosmicRay> this seems to have started with ghc 6.4.1
01:30:29 <CosmicRay> but I'm on x86 linux, so who knows what really is triggering it
01:30:35 <dons> is gopherbot a lambdabot-style bot?
01:31:18 <dons> or am i thinking of something else entirely
01:31:29 <CosmicRay> dons: it's a google-style bot
01:31:38 <dons> ah, right.
01:31:51 <CosmicRay> but it speaks gopher, not http.
01:31:58 <CosmicRay> it is something of a preservation project.
01:32:04 <dons> yep, i see. reading the src now.
01:32:08 <CosmicRay> I'm trying to cache as much of gopherspace as I can before it disappears.
01:32:17 <dons> have you tested it with 6.5, btw?
01:32:24 <CosmicRay> no, I haven't
01:32:27 <CosmicRay> I guess I should.
01:32:36 <dons> how do I reproduce the bug?
01:32:38 <CosmicRay> I apologize for the ugliness of the source in advance.  I wrote this in about 2 hours
01:32:45 <wilx> Hm, gopher, I know it exists but I have never ever used it.
01:32:55 <CosmicRay> well, you'll have to have a postgres database installed
01:33:05 <CosmicRay> once you have that, you should be able to just run it
01:33:25 <dons> why is CC-Options -O3?
01:33:27 <CosmicRay> you'll probably have to start it up 2 or 3 times before it has enough documents in its db to keep all its threads busy
01:33:54 <CosmicRay> dons: probably because I copied the cabal file from a different project, then hacked it up, and forgot to remove that line
01:34:03 <JohnMeacham> Sweet. generalized CPR is nicely beneficial. this could easily be ported back to GHC
01:34:32 <CosmicRay> dons: I'll try removing it and see if it makes a difference.
01:35:26 <CosmicRay> dons: the only even remotely suspicious thing I can think of about this is the msg function in Utils.hs, but Marlow looked at it yesterday and thought it should be fine.
01:35:42 <beelsebob_> hmm... how do I make this more beret like? http://www.cs.kent.ac.uk/people/rpg/tatd2/hat-delta.pdf\
01:35:42 <CosmicRay> JohnMeacham: what is generalized CPR, in this non-medical context? ;-)
01:35:53 <beelsebob_> s/\\$/$/
01:36:07 <wilx> Contraint programming?
01:36:14 <CosmicRay> dons: no difference
01:36:15 <CosmicRay> ah
01:36:29 <wilx> I don't know, I am just guessing :)
01:36:40 <JohnMeacham> Well, do you know the CPR analysis of GHC? it basically looks for product types, like tuples that are returned from a function and replaces them with unboxed tuples instead. it is _very_ good for math because numbers are product types holding unboxed values.
01:36:59 <CosmicRay> ah, ok, very nice.
01:37:00 <JohnMeacham> the paper is by SPJ and glynn I believe.
01:37:23 <JohnMeacham> In any case, for jhc I generalized it and the benefits appear to be substantial in some cases over the basic CPR ghc does.
01:37:34 <CosmicRay> JohnMeacham: how is jhc doing, overall, these days?
01:37:51 <CosmicRay> is there a website where I can read about how close it is to being a ghc replacement?
01:38:39 <beelsebob_> yhc is getting pretty damn close
01:38:46 <CosmicRay> yhc?
01:38:52 <beelsebob_> York Haskell Compiler
01:39:07 <mflux_> I was thinking already 'yet another'..
01:39:12 <beelsebob_> compiles faster than hugs, has a runtime somewhere between ghc and hugs
01:39:13 <CosmicRay> mflux_: me too
01:39:22 <CosmicRay> beelsebob_: got a url?
01:39:25 <dons> beelsebob_, url?
01:39:28 <JohnMeacham> the generalisations I did were: looking for constant values (like numbers) and treating them as products, working with enumerated types, like turnig False True into unboxed 0# and 1#, working recursivly, unboxing children of the value, and working on non product types if they are used in a product-like manner. the last one is very beneficial.
01:39:33 <beelsebob_> cosmic: not yet... it's still semi-secret
01:39:35 <mflux_> I would say that yhv isn't well represented in the web
01:39:39 <mflux_> or yhc
01:39:40 <dons> hehe
01:39:43 <mflux_> which kinda explains it
01:39:44 <ndm> its not quite finished
01:39:46 <JohnMeacham> not very close to a ghc replacement at all yet :)
01:39:58 <beelsebob_> john: well... it works
01:39:59 <CosmicRay> mflux_: yeah, and even googling for "jhc haskell" says "Did you mean 'ghc haskell'?" ;-)
01:40:06 <beelsebob_> so it's pretty close
01:40:10 <dons> ndm, you should still stick it in darcs and make it available though..
01:40:10 <CosmicRay> but the first result *is* the correct page.
01:40:12 <dons> you'd get patches.
01:40:19 <JohnMeacham> among other things it barely handles full haskell 98 so it needs a new front end. hopefully when haskell 06 is standardized it will give me something to shoot for in a front end.
01:40:28 <beelsebob_> dons: it's not ndms decision... it's Tom Shakell's
01:40:32 <ndm> dons, not my choice - if i had teh option it wouldn't be secret at all and it would be in darcs
01:40:47 <CosmicRay> ndm: does it produce smaller binaries than ghc, ala jhc?
01:40:55 <dons> ah, it really is a decision to be closed for now? that's weird, isn't it?
01:40:58 <ndm> no, it produces smaller than both
01:40:59 <dons> what's the motivation?
01:40:59 <neologism> where can I see the list of new features in haskell 06 ?
01:41:09 <ndm> 130bytes for hello world
01:41:13 <ndm> since its bytecode
01:41:18 <JohnMeacham> nelogism: they havn't been decided yet.
01:41:20 <CosmicRay> ndm: ah, no native code gen?
01:41:28 <neologism> JohnMeacham: some preliminary ones?
01:41:39 <JohnMeacham> jhc is 5000 bytes for hello world, and doesn't even need an interpreter.
01:41:44 <ndm> dons, because of social politics and various people it has to remain closed
01:41:45 <CosmicRay> neologism: the discussion just started this week, so I'd say nobody has any idea yet
01:41:52 <neologism> ah ;)
01:41:57 <ndm> CosmicRay: yep, no native code gen - as per nhc98
01:41:58 <lomeX> how i can convert 0::Int to 0::Integer in Hugs?
01:42:04 <dons> ndm, ah, oh well. hope to see it soon
01:42:05 <JohnMeacham> neologism: anything I say would be a guess. but looking at ghcs most used features would be a good place to start.
01:42:10 <ndm> IomeX, toInteger
01:42:14 <CosmicRay> ndm: er?  I thought nhc98 does only native code gen?
01:42:14 <neologism> yes, I think so
01:42:22 <ndm> CosmicRay: yes and no
01:42:30 <ndm> yes = it only produces native binaries
01:42:38 <lomeX> ndm: toInteger 0::Int doesnt work :(
01:42:52 <ndm> no = they contain a big C array of bytes to interpret as a bytecode sequence
01:42:57 <lomeX> oops
01:43:00 <beelsebob_> lome: function application binds tightest
01:43:07 <ndm> IomeX, bracketing! toInteger (0 :: Int)
01:43:08 <lomeX> toInteger (0::Int)
01:43:12 <dons> @hoogle Int -> Integer
01:43:13 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
01:43:13 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
01:43:13 <lambdabot> Prelude.floatRadix :: RealFloat a => a -> Integer
01:43:22 <lomeX> yes, thanx!!
01:43:35 <beelsebob_> ndm: so every binary contains the interpretter and the bytecode?
01:43:36 <ndm> hoogle giving toInteger is purely coincidence!
01:43:37 <CosmicRay> ndm: interesting, that sounds like ocamlc.
01:43:58 <ndm> beelsebob_: yep, the bytecode is a big bad C array, which is compiled in - not pretty
01:43:58 <JohnMeacham> ndm: yeah, I considerd making a nhc bytecode front end for jhc. to get a front end for free :) but by the time it gets there it looses too much type info to be fed into jhc's back end.
01:44:03 <dcoutts> dons, btw, thanks for the mini-patch :-)
01:44:16 <beelsebob_> ndm: yich... doesn't that put a whole bunch of stuff on the stack?
01:44:17 <dons> well, I thought I'd start somewhere.
01:44:24 <dons> i'm also keen to write docs, as i work things out
01:44:38 <ndm> JohnMeacham: you mean reuse nhc's front end, or jhc's?
01:44:38 <JohnMeacham> where is yhc? there is a RSS feed of changes to jhc source if anyone wants to keep updated.
01:44:49 <JohnMeacham> ndm: reuse nhcs front end I mean.
01:44:53 <ndm> yhc is semi-secret
01:44:55 <dcoutts> dons, oh you mean Gtk2Hs tutorial stuff?
01:45:00 <JohnMeacham> ndm: without having to change nhcs code.
01:45:07 <dons> nah, haddocks
01:45:10 <ndm> JohnMeacham: yhc did, but the plan is to kill it - the front end is unpleasant
01:45:16 <JohnMeacham> heh. so was jhc for its first 4 years of existance. :)
01:45:17 <ndm> esp. the type checker
01:45:28 <ndm> nhc is way older than that...
01:45:30 <beelsebob_> ndm: yeh... olaf said he keeps meaning to rewrite the type checker
01:45:33 <CosmicRay> dons: any other suspicious things about that code?
01:45:38 <dcoutts> dons, oh ok. Yeah, feel free to send any doc patches.
01:45:38 <CosmicRay> dons: thanks, btw, for glancing at it
01:45:43 <dons> haven't spotted anythiing yet CosmicRay
01:45:48 <ndm> beelsebob_: woot, i've been trying to convince people, but no one falls for it
01:45:49 <JohnMeacham> indeed. I couldn't figure out how to extract it at all, so I based mine on the old hatchet project combined with my partial type checker I had already written.
01:45:54 <ndm> i was going to write a new parser
01:46:00 <beelsebob_> ndm: I'm not sure he's going to fall for it
01:46:04 <beelsebob_> but he did comment on it
01:46:13 <CosmicRay> dons: I've got GHC 6.5 downloading.  I'll give it a whirl.
01:46:16 <beelsebob_> note that olaf is unlikely to write you fast code
01:46:22 <pejo> JohnMeacham, isn't there a specific format (.hc?) from ghc which is there just for other researchers to be able to use ghc frontend and plug in their own optimizations/backends?
01:46:24 <beelsebob_> he will write you correct code though
01:46:42 <dons> hehe. corect, but not fast eh?
01:46:56 <beelsebob_> better than the other way round
01:47:04 <dons> pejo, external core. .hcr
01:47:19 <pejo> dons, you're a mind reader. Thanks.
01:47:39 <JohnMeacham> pejo: yeah, it is based on system F rather than the lambda cube like jhc, but that is relativly easy to work around compared to 'primitive impeadance matching'. jhc and ghc just have very different ideas of what primitive operations exist and it would be quite a bit of work to translate between them.
01:48:04 <ndm> beelsebob_: code which handles multi-parameter type classes, overlapping instances etc. would be good - even a bit of higher rank polymorphism
01:48:19 <beelsebob_> m'hum
01:48:44 <JohnMeacham> ndm: do you want to work on the resurrected hatchet project? it will be a full haskell type checker in library form.
01:48:58 <beelsebob_> hahahahahaha! ndm's been got!
01:49:06 <ndm> JohnMeacham: i don't want to write it, if it worked i would want to use it :)
01:49:30 <ndm> i actually have a disturbingly large about to do, even ignoring yhc
01:49:45 <dons> ndm, no no! just keep piling on more projects
01:49:57 * dcoutts has the same problem
01:49:58 <ndm> dons, do you want hoogle, ever??
01:50:04 <dons> hehe
01:50:17 <araujo> Hello!
01:50:27 <dons> @localtime araujo
01:50:29 <lambdabot> Local time for araujo is Fri Oct 21 04:49:57
01:50:37 <dons> ;)
01:50:38 <{Arias}> hi
01:50:38 <araujo> Hey dons :-)
01:50:43 <JohnMeacham> ndm: yeah, I imagine it will just be a pretty open darcs repo with a lot of different contributors.
01:50:43 <dons> morning araujo
01:50:45 <araujo> Hola {Arias}
01:50:49 <{Arias}> hola araujo
01:50:53 <araujo> What's up dons ?
01:50:54 <{Arias}> @localtime {Arias}
01:51:00 <{Arias}> :(
01:51:16 <dons> maybe your client doesn't know how to tell the time?
01:51:45 <ndm> JohnMeacham: is it aiming to do any advantage type checking features (i.e. > h98, mp type classes etc)
01:51:47 <{Arias}> 10:50 ••• lambdabot(n=lambdabo@manzano.cse.unsw.EDU.AU) CTCP TIME
01:51:49 <{Arias}> ah x)
01:53:03 <JohnMeacham> well, at first it will be the front end of jhc split into a library. since I want jhc to support all those, eventually it will too.
01:53:19 <JohnMeacham> though, I'd like to implement heliums error messages.
01:53:29 <ndm> JohnMeacham: i may just get drunk, start hacking, and hope to end up with a type system
01:53:44 <ndm> anyway, i said i'd do a parser for nhc, so that comes first
01:53:47 <ndm> * yhc
01:54:58 <dons> you need to write a new one?
01:54:58 <pejo> JohnMeacham, isn't helium pretty restricted, in order to deliver good error messages? (hence it will be hard to do for full haskell).
01:55:15 <JohnMeacham> ndm that is pretty much how jhc was written.
01:56:52 <JohnMeacham> pejo; i wouldnt be interested if there wasn't a challenge :)
01:57:03 <JohnMeacham> gotta go for a bit. will be back.
01:57:13 <sieni> is yhc going to get publically available at some point?
01:57:33 <ndm> sieni, yes!
01:57:44 <sieni> when? ;-)
01:57:46 <ndm> open sourced as well, and open for everyone to hack on
01:57:58 <ndm> not my choice, or the answer would be today
01:58:08 <sieni> ahh
01:58:13 <sieni> any ideas?
01:58:28 <ndm> dons, i want to write a new one - http://www-users.cs.york.ac.uk/~ndm/projects/parsing.php
01:58:44 <ndm> well, its getting announced in the HCAR
01:58:54 <ndm> so hopefully soon after that it will become public with a website etc
01:59:03 <ndm> maybe a few weeks later we could have darcs
01:59:12 <ndm> and before christmas, a release
01:59:42 <ndm> its *really* easy to build from source - takes 1 min, ghc --make Main
01:59:58 <ndm> so hopefully the source release will allow people to start before the official release
02:00:20 <sieni> Howard County Association of Realtors? The Humboldt Community Access & Resource Center? or perhaps Health Care Access Resolution?
02:00:50 <dcoutts> ndm, so it'll have a .Cabal file then? and be distributed in hackage? :-)
02:01:24 <ndm> dcoutts, yes - esp if someone provides it :)
02:01:26 <earthy> sieni: Haskell Communities and Activities Report
02:01:34 <sieni> earthy: :-)
02:01:39 <earthy> ;)
02:01:44 <sieni> ndm: so in november 2005?
02:02:03 <ndm> sieni: the hcar is november, so the official announcement will be then
02:02:32 <ndm> sieni - i really want it released, so i can start using it properly
02:02:43 <ndm> and start working on the tools, WinYhc etc.
02:02:49 <ndm> and get GTK support etc. for it
02:03:46 <kosmikus> ndm: so I'll get a HCAR entry from you soon?
02:04:10 <ndm> kosmikus: no, the yhc one will be from someone else
02:04:17 <ndm> but you'll get one from me on hoogle
02:04:22 <CosmicRay> dons: still segfaults with ghc6.5
02:04:42 <ndm> i'm just waiting, because its being moved to haskell.org/hoogle soon, so i want to check it works there before i give a final URL in the article
02:04:48 <kosmikus> ndm: ah, who'll write the yhc entry?
02:04:57 <ndm> kosmikus: Tom Shackell
02:05:00 <kosmikus> good
02:17:58 <sylvan> how do you do fast parsing in PHP?
02:18:37 <sylvan> doing X regexps for X constructs seems wasteful, so I'd like to do more traditional parsing (lexing and then parsing tokens)
02:20:31 <romildo> Hi.
02:23:32 <Lemmih> Hi romildo.
02:24:32 <wilx> Heh.
02:24:40 <wilx> Isn't PHP a bit off topic here? :))
02:25:03 <romildo> Please, take a look at the simple module at http://rafb.net/paste/results/TQGzs958.html, and tell me why it does fail compilation (ghc -c -fglasgow-exts test.hs).
02:26:05 <romildo> Error message: No instance for (F Char b) ... In the definition of `x': x = f 'T'
02:26:49 <Lemmih> romildo: Specify the type of 'x' or declare 'F' as 'class F a b | a -> b'.
02:27:11 <romildo> Shouldn't the compiler be able to assign the type Bool to x itself?
02:27:53 <Lemmih> romildo: No, you could also have an instance like this 'instance F Char Int where ...'.
02:29:02 <romildo> So this happens because of Haskell assumption of an open world, instead of a closed world, right?
02:30:18 <Lemmih> romildo: The example will also compile if you disable the monomorphism restriction.
02:38:37 <beelsebob_> how's this? http://www.cs.kent.ac.uk/people/rpg/tatd2/hat-detect.pdf
02:38:39 <araujo> Has anybody worked with readLine here?
02:40:18 <Lemmih> @index readLine
02:40:19 <lambdabot> bzzt
02:42:18 <dcoutts> beelsebob_, mmm bugs in your hat.
02:42:28 <beelsebob_> :P
02:42:39 <beelsebob_> there certainly are in hat-detect at the mo
02:42:57 <dcoutts> heh, and I was just looking at the icon :-)
02:43:16 <beelsebob_> :P
02:43:28 <beelsebob_> none in hat-delta though http://www.cs.kent.ac.uk/people/rpg/tatd2/hat-delta.pdf
02:58:15 <roconnor> Did I just kill lambda bot?
02:59:23 <Maddas> roconnor: You cannot kill it, you can only anger it.
03:01:39 <beelsebob_> is this one clear? http://www.cs.kent.ac.uk/people/rpg/tatd2/hat-anim.pdf
03:03:42 <ProfTeggy> bbl, meeting
03:08:35 <earthy> beelsebob_: what is that pdf supposed to show?
03:08:47 <beelsebob_> earthy: it's an icon for hat-anim
03:08:51 <earthy> ah
03:09:13 <beelsebob_> and another... http://www.cs.kent.ac.uk/people/rpg/tatd2/hat-trail.pdf
03:09:20 <beelsebob_> (icon for hat-trail)
03:09:26 <earthy> hat-trail is cool
03:09:31 <earthy> I don't like the other two
03:09:46 <beelsebob_> how about http://www.cs.kent.ac.uk/people/rpg/tatd2/hat-detect.pdf
03:09:46 <earthy> and maybe you want to stick to one type of hat
03:10:01 <beelsebob_> nah, the hat's mean different things
03:10:09 <earthy> ooh, that's a neat one
03:10:09 <beelsebob_> admittedly, the mortar board is obscure
03:10:22 <beelsebob_> the mortar board is because hat-anim helped me get my degree
03:10:32 <earthy> um, but the hat is always hat, right?
03:10:47 <beelsebob_> and the beret is because it's meant to be a delta-force type military beret
03:10:57 <beelsebob_> yes... the hat always represents hat
03:11:08 <beelsebob_> http://www.cs.kent.ac.uk/people/rpg/tatd2/hat-observe.pdf
03:11:09 <earthy> so, theoretically you'd *want* it to be visually clear that it's always the same hat, just with different extra functionality
03:11:25 <beelsebob_> but it's different functionality, not extra
03:11:34 <earthy> oh, yeah, but it's still the same hat
03:11:37 <beelsebob_> hat-trail is entirely different from hat-detect
03:11:44 <beelsebob_> but they're all hats
03:11:44 <earthy> the code, yes
03:11:57 <beelsebob_> well, yes the code, but the functionality too
03:12:01 <earthy> so, take one hat, and make the functionality clear in the hat's situation
03:12:08 <earthy> that way you keep all hats related
03:12:19 <beelsebob_> but they're all related by being hats, no?
03:12:21 <earthy> now it's not clear that it's all to do with debugging
03:12:29 <earthy> ah, no. :)
03:12:54 <earthy> that relation is too far-fetched
03:13:07 <earthy> it needs to be immediately obvious for it to work in a user interface
03:13:19 <beelsebob_> it's not meant to be a user interface
03:13:23 <beelsebob_> it's meant to be logos
03:13:34 <earthy> yes. logos are a form of user interface
03:13:35 <neologism> about haskell 06 - will they accept any comments?
03:13:43 <neologism> or is there any vote for new features?
03:13:52 <earthy> neologism: haven't you seen the thread on the haskell mailinglist?
03:14:04 <earthy> if not: go read up
03:14:04 <neologism> I dont read the ml
03:14:15 <earthy> do you read HWN then at least?
03:14:18 <neologism> is there any web based archive of the ml?
03:14:22 <earthy> yes, there is
03:14:37 <neologism> url?
03:14:43 <neologism> found that;)
03:14:46 <shapr> @google haskell mailing list
03:14:47 <lambdabot> http://www.haskell.org/mailinglist.html
03:15:03 <earthy> http://sequence.complete.org/hwn ;)
03:15:08 <neologism> earthy: and url of hwn?
03:15:25 <neologism> ah. thats sent to the ml
03:15:28 <neologism> thnx for the informations
03:15:36 <earthy> http://article.gmane.org/gmane.comp.lang.haskell.cafe/8646 for the thread you were looking for
03:16:36 <neologism> tnx
03:24:55 <bourbaki> moin
03:25:25 <beelsebob_> moin moin
03:29:20 <neologism> what is GADT?
03:30:05 <Lemmih> neologism: http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
03:30:09 <earthy> generalized algebraic datatypes
03:32:02 <neologism> ah... thnx
03:36:31 <Wi> how to convert Integer to Int ?
03:36:36 <Wi> cause !! need Int
03:37:06 <shapr> @type fromIntegral
03:37:10 <lambdabot> forall b a. (Num b, Integral a) => a -> b
03:37:44 <neologism> isnt it possible to just ::Int ?
03:38:04 <Wi> Main> fromIntegral (5::Integer)
03:38:04 <Wi> 5 :: Integer
03:38:07 <Wi> don't work
03:38:55 <Wi> :: Int - only work with numbers, not variables
03:40:02 <Wi> look example :
03:40:03 <Wi> f :: Integer -> Integer
03:40:03 <Wi> f x = [1..] !! x
03:40:11 <Wi> t> :r
03:40:11 <Wi> ERROR "C:\prog\haskell\gr100.hs":28 - Type error in application
03:40:11 <Wi> *** Expression     : enumFrom 1 !! x
03:40:11 <Wi> *** Term           : x
03:40:11 <Wi> *** Type           : Integer
03:40:13 <Wi> *** Does not match : Int
03:42:05 <Wi> ups
03:42:08 <Wi> VERY SORRY
03:42:13 <Wi> fromIntegral works
03:42:23 <Wi> my brain doesn't work anymore
03:44:53 <shapr> Oh, mine neither! whee!
03:47:07 * Maddas laughs
03:48:12 <basti_> haspr gives me haspr: /usr/lib/ghc-6.4.1/HSbase.o: unknown symbol `setIOManagerPipe'
03:48:32 <basti_> in apache's error log
03:48:33 <basti_> any idea?
03:49:22 <shapr> linking problem?
03:49:30 <shapr> What lib has setIOManagerPipe?
03:49:42 <basti_> HSrts apparently
03:50:03 <basti_> i don't know how to link that additionally
03:52:16 <shapr> do you need to add a -package rts or something?
03:53:12 <basti_> hmm but where and how?
03:53:30 <shapr> On the --make line?
03:53:31 <basti_> its cabalized, i tried in the cabal file, but that didnt get through to the compile command apparently
03:53:40 <Lemmih> The RTS should always be linked.
03:53:49 <basti_> hmm :/
03:54:01 <basti_> that makes it all the more mysterious
03:56:30 <tromp> did they name haspr after shapr:-?
03:56:45 <basti_> good question
03:57:15 <shapr> wha?
03:57:34 * shapr is blindsided by an anagram
03:58:04 <shapr> Lemmih: Hey, is that a purposeful anagram?
03:59:14 <tromp> how does it feel, Shae, to have the 1st 3 letters of your name in common with your fave language:-?
03:59:43 <shapr> Coincidental, I hope...
03:59:53 <shapr> Otherwise all my factual arguments in favor of Haskell would be null and void!
04:00:08 <shapr> Speaking of which, I'm trying to talk sense into David B. Held again on LtU. Not like that'll ever happen.
04:04:45 <Lemmih> Ha. Hadn't noticed that 'haspr' is an anagram of 'shapr' (:
04:05:08 <beelsebob_> hehe, not as good as Tom Shakell, writing yhc
04:05:20 <dcoutts_> beelsebob_, ?
04:05:30 <dcoutts_> oh yah
04:05:33 <beelsebob_> hehe
04:05:34 * dcoutts_ notices
04:06:57 <Lemmih> shapr: Got an URL to the LtU discussion?
04:08:52 <tromp> tom should name his son Haskell...
04:09:13 <beelsebob_> heh
04:10:14 <tromp> yhc means Yet another Haskell Compiler?
04:10:22 <beelsebob_> no York Haskell Compiler
04:12:36 <ndm> http://www-users.cs.york.ac.uk/~ndm/yhc/
04:12:40 <ndm> the website for yhc
04:12:51 <ndm> just officially released, Tom gave me permission to post it :)
04:13:30 <beelsebob_> ndm: awww... still the poor compile time benchmark :(
04:13:41 <ndm> beelsebob_: write binary hi files....
04:13:47 <beelsebob_> hehe
04:13:59 <ndm> it should be doable, not too much effort
04:14:10 <ndm> a good, first hack at teh compiler project
04:15:08 <beelsebob_> true.. but I can't be arsed... I like you have too many projects
04:15:33 <ndm> i have more....
04:16:00 <tromp> it's not Shakell though...
04:16:04 <beelsebob_> heh
04:16:06 <tromp> it's Tom Shackell
04:17:33 <dcoutts_> ndm, the web site looks promising
04:17:45 * dcoutts_ looks forward to having a yhc package in gentoo
04:17:51 <ndm> dcoutts_, if there is anything missing, just yell
04:17:57 * dcoutts_ looks forward to making gtk2hs work with yhc
04:17:59 <ndm> apart from source download
04:18:09 <ndm> gtk2hs should be beautiful with yhc
04:18:12 <ndm> i want that too!
04:18:44 <dcoutts_> ndm, what's really helpful for packagers is a stable url & md5sum for the released tarballs. And version numbers. And a sane tarball layout. :-)
04:18:51 <beelsebob_> ndm: the icon's missing *g*
04:18:53 <shapr> Hm, should I give in and go hack with autrijus?
04:19:04 <ndm> shapr, you'll never return...
04:19:12 <ndm> dcoutts_, ok - that can be done
04:19:12 <shapr> Would be that be such a bad thing?
04:19:26 <shapr> I could move to .tw and live near autrijus and hack all the time.
04:19:29 <ndm> but not for a while, after the first stable release
04:19:47 <ndm> shapr, he ate his dinner off his laptop - was shocked to see
04:19:48 <shapr> I could become a professional Perl6 programmer.
04:20:01 <ndm> arrrrgggghhhhh! - no, stay away from the dark side of perl
04:20:15 <shapr> Perl6 seems like the light side of Perl. It has lambdacamels.
04:20:38 <ndm> dcoutts_, the website will probably change before the first yhc release, perhaps haskell.org, but once there we'll stabalise
04:20:50 <dcoutts_> ndm, ok, great
04:21:38 <dcoutts_> ndm, we might hold off if the first release is a "developer" release
04:21:55 <Igloo> beelsebob_: His name is Shackell
05:07:09 <mrchebas> question about heap profiling: what is the BLACKHOLE type?
05:07:30 <mrchebas> it appears in my profile graph when using option -hy
05:09:54 <basti_> I dont have the slightest clue mrchebas
05:11:15 <mrchebas> I googled it but i found references to parallel evaluation.
05:11:25 <mrchebas> But my program does not use threads :-O.
05:11:43 * basti_ shrugs
05:18:30 <CosmicRay> anybody with gdb (or whatever tool I need) experience that can tell me how to disassemble s34n_info as Simon asked me to?
05:19:47 <Igloo> IIRC it's as simple as "disassemble s34n_info" when it is in scope
05:19:55 <neologism> yes
05:20:12 <Igloo> If it is segfaulting in there then just run it in gdb and it will be in scope when it segfaults
05:20:54 * Igloo can't remember if it will be in scope when just loaded, but you can obviously just try it  :-)
05:21:12 <neologism> yes its in scope
05:21:32 <musasabi> mrchebas: black holes are used for thunks that are currently being evaluated iirc
05:21:44 <CosmicRay> ahh. ok.
05:21:51 <CosmicRay> I do know how to pull up that frame if need be.
05:22:08 <neologism> jsut frame n
05:22:12 <CosmicRay> right
05:22:14 <neologism> where n is the number of the frame you want
05:24:13 * mrchebas nods
05:24:45 <mrchebas> musasabi: what does it mean "currently being evaluated"?
05:24:57 <mrchebas> isn't it one thunk at a time?
05:28:15 <musasabi> http://citeseer.ist.psu.edu/reid98putting.html has some of the details.
05:28:51 <joelr> howdy folks
05:29:10 <Lemmih> Hiya joelr.
05:29:23 <joelr> anyone on windows?
05:29:47 <mrchebas> thanks
05:31:49 <dcoutts_> joelr, what's the question?
05:31:53 <joelr> getProtocolByName is not working for me or my customer
05:31:55 <joelr> on Windows
05:31:58 <joelr> fails
05:32:05 <dcoutts_> oh the "tcp" thing
05:32:16 <joelr> whereas the protocol entries exist in the protocol file and the C call to getprotobyname works
05:32:37 <dcoutts_> have you looked at the code getProtocolByName is using on windows?
05:32:43 <dcoutts_> and compared it to the C version?
05:32:50 <joelr> dcoutts_: yeah, but don't look down on it. i coded up a great haskell app, sold it to client as "simple scripting language" and now i cannot deploy it :(
05:33:12 <joelr> dcoutts_: it just hooks into the FFI call, nothing more except for a Try around it i believe
05:33:31 <dcoutts_> well to try and debug the problem I'd copy out the implementation of getProtocolByName and insert debugging output
05:33:34 <CosmicRay> thanks for the gdb hints.
05:34:31 <joelr> dcoutts_: except i don't have a development environment on windows
05:34:39 <joelr> well... maybe i do, the mingw
05:34:45 <joelr> never used it though
05:34:46 <dcoutts_> joelr, have you got some test code I can try?
05:34:52 <dcoutts_> i've got mingw
05:35:07 <joelr> yes, sure, try getProtocolByName "tcp" at your ghci prompt :)
05:35:12 <dcoutts_> ok
05:35:16 <joelr> actually, that would be Network.BSD....
05:35:44 <joelr> Network.BSD.getProtocolByName "tcp"
05:36:00 <dcoutts_> "no such service entry"
05:36:03 <dcoutts_> :-(
05:36:12 <dcoutts_> yes I see
05:36:12 <joelr> dcoutts_: there you go!
05:36:21 * dcoutts_ looks at the code
05:36:25 <joelr> now this makes networking on windows useless
05:36:36 <joelr> since when you call connectTo it tries to look up tcp
05:36:51 <joelr> look at the BSD.hsc (i think that's where it is)
05:36:59 <dcoutts_> getProtocolByName :: ProtocolName -> IO ProtocolEntry
05:36:59 <dcoutts_> getProtocolByName name = do
05:36:59 <dcoutts_>  withCString name $ \ name_cstr -> do
05:36:59 <dcoutts_>  throwNoSuchThingIfNull "getServiceEntry" "no such service entry"
05:36:59 <dcoutts_>    $ (trySysCall.c_getprotobyname) name_cstr
05:37:01 <dcoutts_>  >>= peek
05:37:09 <joelr> exactly
05:37:35 <joelr> it's a call to getprotobyname which apparently works. so i wonder if it's a try issue
05:38:34 <dcoutts_> #if !defined(mingw32_HOST_OS) && !defined(_WIN32)
05:38:34 <dcoutts_> trySysCall act = act
05:38:34 <dcoutts_> #else
05:38:34 <dcoutts_> trySysCall act = do
05:38:34 <dcoutts_>   ptr <- act
05:38:35 <dcoutts_>   if (ptr == nullPtr)
05:38:37 <dcoutts_>    then withSocketsDo act
05:38:39 <dcoutts_>    else return ptr
05:38:41 <dcoutts_> #endif
05:40:04 <dcoutts_> @index withSocketsDo
05:40:05 <lambdabot> Network.Socket, Network
05:41:39 <Igloo> Does withSocketsDo $ getProtocolByName "tcp" work?
05:41:43 <joelr> dcoutts_: it's a windows thing apparently, withSocketsDo. initializes sockets apparent
05:41:57 <joelr> let me boot up virtual pc (i'm on mac osx
05:43:47 <joelr> response from simon marlow
05:43:48 <joelr> Please try the updated installer for 6.4.1.  I believe this is caused by
05:43:48 <joelr> the same bug in the dynamic linker that was fixed in the update.  At
05:43:49 <joelr> least, I can reproduce your bug with the 6.4.1 installation I have, but
05:43:49 <joelr> not with a fresh build.
05:44:59 <dcoutts_> withSocketsDo $ getProtocolByName "tcp"  does not work for me
05:45:18 <joelr> where is that fresh build? i don' tsee it
05:46:19 <dcoutts_> http://haskell.org/ghc/dist/6.4.1/ghc-6-4-1-bld1.msi
05:46:30 <dcoutts_> joelr, it's not liked from the download page yet
05:46:41 <joelr> cool
05:49:15 <musasabi> Does getprotobyname have an useful function?
05:49:43 <joelr> musasabi: no idea :-)
05:49:51 <{Arias}> dcoutts_, it throws an exception?
05:49:53 <joelr> ghc uses it when setting up a socket so i guess yes
05:50:15 * musasabi does not think it really needs to be called.
05:50:33 <musasabi> @source Network.Socket
05:50:57 <{Arias}> yes, if you want to create a scoket you need use the function
05:51:01 <{Arias}> socket
05:51:47 <musasabi> Is there any OS where TCP is not 0?
05:52:08 <musasabi> or rather where protocol != 0, for everything haskell can do.
05:52:46 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
05:52:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:53:24 <dcoutts_> {Arias}, yes it throws an exception
05:53:34 <{Arias}> me too :(
05:53:44 <{Arias}> i dont know why
05:54:04 <musasabi> SUSv3 tells "Specifies a particular protocol to be used with the socket. Specifying a protocol of 0 causes socket() to use an unspecified default protocol appropriate for the requested socket type."
05:54:50 <{Arias}> i've mail to ghc mailing list, they tell me that is a problem of so configuration
05:55:07 <{Arias}> so = operating system sorry
05:56:33 <musasabi> sounds plausible.
05:57:25 <{Arias}> but i dont know how to fix it :(
05:57:27 <SamB> how were they supposed to know there would only be about two IP protocols in actual use?
05:58:55 <{Arias}> musasabi, tcp protocol is not always 0
05:58:58 <SamB> they wrote the first stack a LOOOONG time ago!
05:59:09 <dcoutts_> {Arias}, joelr, hmm it's working now.
05:59:15 <dcoutts_> I didn't really do anything.
05:59:15 <{Arias}> o_O
05:59:22 <{Arias}> wow
05:59:31 <dcoutts_> I wrote it as .hs file and compiled it. That worked.
05:59:36 <dcoutts_> now it works in ghci too
05:59:51 <{Arias}> :/
06:00:02 <dcoutts_> I didn't upgrade ghc to the new 6.4.1 build
06:00:19 <{Arias}> can i see the code?
06:00:32 <{Arias}> it dont works to me :(
06:00:46 <{Arias}> it doesnt work to me :P
06:00:48 <dcoutts_> oh now this is interesting...
06:00:56 <{Arias}> excose my english :(
06:01:02 <{Arias}> *excuse*
06:01:10 <musasabi> {Arias}: can you point an OS where haskell works and 0 does not work for tcp ?
06:02:04 <{Arias}> i dont know if it goes to work with 0
06:02:10 <{Arias}> but 0 is not the tcp protocol 8-)
06:02:32 <musasabi> 0 is the default protocol.
06:02:54 <musasabi> Thus you need an OS where TCP/UDP are not the default protocols for AFINET.
06:03:46 <{Arias}> example:
06:03:46 <{Arias}> <Aeoris> @eval var_dump(getprotobyname("TCP"));
06:03:47 <{Arias}> <Elsa_Pataky> int(6)
06:03:54 <{Arias}> elsa is a bot in php
06:04:04 <CosmicRay> grrr,
06:04:11 <CosmicRay> I am starting to be very annoyed at hsql.
06:04:25 <CosmicRay> it may be my segfault culprit.
06:04:43 <dcoutts_> {Arias}, well it seems to be random if it works in ghci.
06:04:48 <musasabi> {Arias}: that does not mean that 0 is not TCP too.
06:05:03 <dcoutts_> {Arias}, a moment ago it was working in one instance of ghci and not another
06:05:17 <{Arias}> :S
06:05:18 <dcoutts_> {Arias}, but it works consistently when complied with ghc to an .exe
06:05:59 <{Arias}> mmm
06:06:34 <{Arias}> how do you compile it?
06:06:42 <beelsebob_> hehehe http://www.cs.kent.ac.uk/people/rpg/tatd2/icons/
06:06:52 <JohnMeacham> TCP is 6
06:07:06 <dcoutts_> {Arias}, ghc --make net.hs
06:07:48 <farre> nibro?
06:07:59 <dcoutts_> {Arias}, main = withSocketsDo $ do { ent <- getProtocolByName "tcp"; print ent }
06:09:56 <{Arias}> main.exe: getServiceEntry: does not exist (no such service entry)
06:09:58 <{Arias}> :S
06:10:14 <{Arias}> this exception, isn't it?
06:11:58 <dcoutts_> yep
06:12:34 <{Arias}> gr
06:12:58 <dcoutts_> you've reported it as a ghc bug?
06:14:32 <{Arias}> can you try the funcion getHostName ?
06:15:00 <{Arias}> I have send the problem to ghc users ang ghc bugs mailing lists
06:15:17 <{Arias}> they've said that is a configuration problem
06:16:27 <{Arias}> getHostName:
06:16:28 <{Arias}> getHostName: failed (Successful WSAStartup not yet performed (WSANOTINITIALISED))
06:17:25 <musasabi> have you tried withSocketsDo (getHostName ...) ?
06:17:44 <{Arias}> yes
06:18:36 <SamB> @index getProtocolByName
06:18:37 <lambdabot> Network.BSD
06:24:01 <dcoutts_> {Arias}, in the standalong .exe getHostName works
06:24:50 <dcoutts_> {Arias}, in ghci I get the same error message as you
06:25:30 <SamB> what calls WSAStartup?
06:26:59 <{Arias}> gr
06:27:38 <SamB> hmm, why does 'print' result in lots of 1-char write calls??
06:29:59 <dcoutts_> {Arias}, so you get the same results when you complie the thing as an .exe ?
06:30:27 <dcoutts_> SamB, because it's doing lazy printing and you're not using a buffered handle
06:30:37 <SamB> dcoutts: oh, okay then
06:30:48 <{Arias}> in ghc or in a exe it always thorws an exception :(
06:30:54 <dcoutts_> hmm
06:35:15 * SamB wonders why the debian ghc6-libsrc package hasn't got .hsc files in it?
06:38:30 * SamB figures out how to check out ghc again
06:45:09 <SamB> do you have a problem with tigers wandering through the CVS repositories?
06:46:42 <beelsebob_> my tiger wanders through cvs repositories fine
06:48:53 <SamB> no, I meant, why is there a tigertrap among the repositories on cvs.haskel.org?
06:49:06 <beelsebob_> huh?
06:49:47 <SamB> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/tigertrap/
06:49:59 <adept> :)))))
06:50:01 <adept> LOL
06:53:33 <CosmicRay> SamB: somebody doesn't like OS X? ;-)
06:54:05 <beelsebob_> I don't know... my tiger doesn't get trapped in it
07:24:59 <xerox> Yow.
07:25:28 <dcoutts_> yarr
07:25:55 <Lemmih> yihaa
07:25:57 <xerox> Did you see?  Internet was dying this morning!
07:26:07 <dcoutts_> was it?
07:26:12 <syntaxfree> That was on slashdot, but I didn't have the time to read it.
07:26:16 <xerox> Yeah, some very BIG ISPs hat some problems.
07:26:31 <xerox> We were here when it happened!  ##level3
07:26:32 <syntaxfree> tier 1 people.
07:26:40 <syntaxfree> wow.
07:27:03 <syntaxfree> It's gonna make the news. I hope they don't use it as an argument for UN-led internet governance.
07:27:14 <xerox> I did submit it to /. but they published one of another dude, heh
07:27:33 <syntaxfree> I'm still trying to pick up points-free notation.
07:27:52 <syntaxfree> I understand how to perform arbitrary functions on one argument, and the simplest two-argument functions.
07:28:02 <syntaxfree> I mean, I know f = (+)  means f x y = x + y
07:28:12 <syntaxfree> but I don't know how to pointlessly express f a x y = a* x + y
07:28:18 <xerox> \pl f g x -> f (g x)
07:28:27 <xerox> @pl f g x -> f (g x)
07:28:28 <lambdabot> (line 1, column 7):
07:28:28 <lambdabot> unexpected ">" or "-"
07:28:28 <lambdabot> expecting variable, "(", operator or end of input
07:28:31 <xerox> @pl \f g x -> f (g x)
07:28:32 <lambdabot> (.)
07:28:36 <xerox> @pl \f g x y -> f (g x y)
07:28:37 <lambdabot> (.) . (.)
07:28:40 <xerox> @pl \f g x y z -> f (g x y z)
07:28:41 <lambdabot> (.) . (.) . (.)
07:28:42 <syntaxfree> yeah. I mean.
07:28:45 <xerox> :-D
07:28:51 <basti_> xerox: argh
07:28:58 <xerox> =^_^=
07:29:03 <Lemmih> Hiya JaffaCake.
07:29:12 <syntaxfree> f x = 3*x**2 + 1   goes f = (+1).(*3).(**2)
07:29:13 <JaffaCake> hiya
07:29:19 <syntaxfree> Hmm. I'm not understanding yet :~
07:29:27 * dcoutts_ welcomes JaffaCake (and wonders again about win32 dlls)
07:29:36 * JaffaCake runs away
07:29:37 <xerox> syntaxfree: think of "." as function composition
07:29:48 <dcoutts_> JaffaCake, ;-)
07:30:20 <syntaxfree> I know.
07:30:21 <xerox> syntaxfree: first, 'x' is consumed by (**2), then its result is passed as argument to (*3), then again, the result, is passed as argument to (+1)
07:30:34 <syntaxfree> yes. I understand that simple example.
07:30:51 <syntaxfree> I made it. I know how it works. But I can't figure out how to express "f a x y = a * x + y".
07:31:02 <syntaxfree> @pl \x->a*x+y
07:31:03 <lambdabot> (y +) . (a *)
07:31:06 <xerox> syntaxfree: your are not supposed to :-)
07:31:17 <xerox> @pl \a x y -> a * x + y
07:31:17 <lambdabot> ((+) .) . (*)
07:31:26 <psi> hah
07:31:26 <syntaxfree> I want to learn how to do that :~
07:31:42 <xerox> You can
07:31:59 <syntaxfree> @pl \ a x -> a * x + x
07:32:00 <lambdabot> join . ((+) .) . (*)
07:32:16 <eivuokko> lol
07:32:23 <syntaxfree> apparently a*x+y can still be expressed with fancy monadic operations.
07:32:34 <syntaxfree> But I don't understand ((+).) . (*)
07:32:50 <psi> @pl f a x y = a * x + y
07:32:51 <lambdabot> f = ((+) .) . (*)
07:33:12 <syntaxfree> yes. I saw that.
07:33:35 <syntaxfree> And it doesn't even use the fancy monadic operations I don't know. Still I can't parse that :~
07:33:39 <psi> i was just checking if a lambda expression was necessary
07:34:54 <syntaxfree> @pl f x y = x + y
07:34:55 <lambdabot> f = (+)
07:34:57 <syntaxfree> ok.
07:35:04 <syntaxfree> @pl f x y = 3* x + y
07:35:04 <lambdabot> f = (+) . (3 *)
07:35:05 <xerox> \a x y -> a * x + y
07:35:05 <xerox> \a x y -> (*) a (x + y)
07:35:05 <xerox> \x y -> (*) (x + y)
07:35:05 <xerox> ...
07:35:17 <syntaxfree> hmmm.
07:35:24 <syntaxfree> xerox: so THAT'S the method.
07:35:33 <syntaxfree> yes, I shoulda thought of that.
07:35:52 * syntaxfree picks up a pen.
07:36:56 <xerox> AH
07:37:55 <xerox> \a x y -> a * x + y
07:37:55 <xerox> \a x y -> (*) a (x + y)
07:37:55 <xerox> \x y -> (*) (x + y)
07:37:55 <xerox> \y -> (. (+y)) . (*)
07:37:58 <xerox> \ -> ((+) .) . (*)
07:38:11 <xerox> s/\\ -> //  ;-)
07:38:48 <syntaxfree> (.(+y)) is a partial operator like (+2), except for function composition, right?
07:39:13 <xerox> (+y) is a slice (i.e. partially evaluated (+))
07:39:33 <syntaxfree> I'll try one of my own and then check against @pl.
07:39:54 <xerox> Spit the expression, I want to try too.
07:40:03 <syntaxfree> don't ruin it for me.
07:40:10 <syntaxfree> f a b x y = a* x + b* y
07:41:34 <ptolomy> Crap. I know I came here for a specific purpose. I wonder what it was.
07:41:44 <xerox> Fun
07:41:49 <ptolomy> Maybe it was "avoid doing my job". hmm.
07:42:53 <JKnecht> something to do with Haskell?
07:42:57 <ptolomy> Oh yeah! What does "golf" mean?
07:43:20 <psi> @pl f x y = [a | a <- y, a /= x] ++ [b | b <- y, b /= 2*b]
07:43:21 <lambdabot> f = (`ap` ((: [b /= 2 * b]) . ((b | b) <-))) . ((++) .) . flip ((:) .
07:43:21 <lambdabot> ((a | a) <-)) . return . (a /=)
07:43:29 <psi> woot
07:44:16 <basti_> o.0
07:44:28 <syntaxfree> hmm. I still haven't learned this thing.
07:44:39 <basti_> ptolomy: apparently its a rather esoteric discipline in terse programming languages
07:44:40 <xerox> syntaxfree: I got stuck in trying to delete b :-D
07:44:47 <syntaxfree> let's try it?
07:45:03 <basti_> ptolomy: youre given a task and supposed to solve it in as few -characters- as possible
07:45:07 <syntaxfree> maybe it involves flips and joins and other fancty monadic things.
07:45:31 <ptolomy> Interesting.
07:45:35 <ptolomy> I learned something new.
07:45:37 <ptolomy> Thanks.
07:45:37 <syntaxfree> xerox: can i @pl it?
07:46:03 <xerox> syntaxfree: no please!
07:46:17 * ptolomy apparently did a lot of golfing in the late 90s.
07:46:43 <xerox> syntaxfree: bah, do it.
07:46:43 <syntaxfree> xerox: ok. I gave it up, after I realized I don't know how to duplicate a * x +y either.
07:46:59 <xerox> I got there \b x y -> ((+) (b * y)) . (* x)
07:47:30 <syntaxfree> @pl a* x + b* y
07:47:31 <lambdabot> a * x + b * y
07:47:34 <xerox> ..
07:47:36 <syntaxfree> haha.
07:47:42 <syntaxfree> @pl f a b x y = a*x +b * y
07:47:43 <lambdabot> f = (. (*)) . flip . (((.) . (+)) .) . (*)
07:47:44 <ptolomy> iS @pl an auto-obfuscator or somethign?
07:47:46 <syntaxfree> flips.
07:47:53 <xerox> Let's try again
07:47:57 <xerox> With a simpler one
07:48:19 <xerox> \f g x y -> f x (g y)
07:48:49 <basti_> ptolomy: its an auto-abstractor
07:49:08 <basti_> ptolomy: @pl something, and it will have no "formal parameters" (lambdas) after
07:49:34 <roconnor> could we say that @pl puts it in combinator form?
07:49:46 <xerox> It outputs points-free code.
07:50:07 <roconnor> What would be basic combinators be? (.) and flip?
07:50:31 <basti_> ask that someone who knows and cares, please ^^
07:50:46 <roconnor> @pl k a b = a
07:50:47 <lambdabot> k = const
07:50:49 <araujo> Hello!
07:51:56 <syntaxfree> there are many weird combinators.
07:51:56 <roconnor> @pl s x y z = x z (y z)
07:51:57 <lambdabot> s = ap
07:52:11 <roconnor> hmmm
07:52:13 <syntaxfree> @pl f a x b y = (a+x) / (b-y)
07:52:15 <lambdabot> f = flip flip (-) . (((.) . (.) . (/)) .) . (+)
07:52:26 <xerox> roconnor: lol
07:52:38 <xerox> @pl \f g x y -> f x (g y)
07:52:39 <lambdabot> flip . ((.) .)
07:52:43 <xerox> aaah.
07:52:43 <araujo> @pl (\f x y -> (f x) + (f y))
07:52:44 <lambdabot> flip =<< (((.) . (+)) .)
07:52:49 <roconnor> It ought to just use const and ap. ;-)
07:53:15 <xerox> araujo: I know another way to translate it!
07:53:25 <tromp> @pl x y = x y y
07:53:26 <lambdabot> x = fix join
07:53:30 <araujo> xerox, hah, trying to understand the lambdabot's way
07:54:13 <roconnor> @type ap
07:54:13 <tromp> @pl x y = x y x
07:54:14 <lambdabot> bzzt
07:54:14 <lambdabot> x = fix (join flip)
07:54:29 <roconnor> @type join
07:54:30 <lambdabot> bzzt
07:54:39 <basti_> i think its in mplus
07:54:40 <tromp> @pl f x y = x y x
07:54:41 <lambdabot> f = join flip
07:54:48 <basti_> @hoogle join
07:54:49 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
07:54:54 <basti_> @index join
07:54:55 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
07:54:55 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
07:54:55 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
07:55:00 <xerox> foo f = (f &&& f) >>> uncurry (+)
07:55:02 <roconnor> that can't be the join they mean.
07:55:06 <xerox> But it's a bit different.
07:55:12 <basti_> hmm
07:55:21 <tromp> my f is S S K
07:55:21 <timbod> any comments on wxhaskell v. gtk2hs ?
07:55:33 <xerox> timbod: the latter wins, end
07:55:36 <basti_> timbod: gtk sucks, generally.
07:55:37 * xerox chuckles
07:55:47 <xerox> basti_: baah!
07:55:52 <timbod> That was predictable....
07:55:55 <basti_> ^^
07:56:06 <basti_> i dont want to debate that, though ;)
07:56:06 <xerox> Gtk2Hs is way cool!
07:56:07 * araujo thinks gtk is the more decent out there
07:56:08 <timbod> I want to do some tinkering, but don't know which to choose...
07:56:18 <xerox> You get cairo graphics in Haskell too, in Gtk2Hs!
07:56:19 <araujo> What else do we have?
07:56:31 <xerox> ...and glade is very, very handy.
07:56:44 * dcoutts_ reccomends Gtk2Hs
07:56:56 <dcoutts_> however I'm biased of course :-)
07:57:05 <sethk> dons, I have a message from Simon Marlow saying that the error I am getting building yi is due to a bug, and what is really happening is that a package is missing.
07:57:33 <sethk> dons, can you hep me figure out which package?  I look for the obvious ones, but I don't think it will be one of the obvious ones.
07:57:35 <timbod> ok, cairo is one plus for gtk2hs. How do the compare in writing code?
07:58:00 <dcoutts_> failry similar, they both support an attributes api
07:58:43 <dcoutts_> Gtk2Hs allows you to use a visual gui builder. With wxHaskell you've got to write the gui construction code yourself (althouth they do have a combinator language for doing so)
07:58:58 <timbod> builder = glade?
07:59:02 <dcoutts_> yes
07:59:32 <xerox> ...and you have the maintainer to beg here :-)
07:59:45 <dcoutts_> heh heh
07:59:54 <timbod> maintainer = dcoutts_ ?
08:00:20 <dcoutts_> yep
08:00:43 <dcoutts_> xerox, I'm going to try to get the first release candidate for 0.9.10 out today
08:00:54 <dcoutts_> source tarball + win32 installer
08:00:55 <timbod> last question - is there a darcs repo, or should I just grab the tar file?
08:01:01 * xerox bounces happily
08:01:42 <dcoutts_> timbod, well you can get the latest development version with darcs now, or wait until I release the 0.9.10 release candidate tarball
08:02:01 <gour> dcoutts_: hi duncan
08:02:19 <dcoutts_> the tarball tends to be easier to use since one doesn't get problems with autoconf/automake
08:02:21 <dcoutts_> hi gour
08:02:26 <timbod> I'm liking darcs - what's the repo url? I can't see it on the web page.
08:02:27 * SamB would suggest trying both
08:02:59 * xerox waves his hands in front of SamB in a Jedi-like fashion
08:03:03 <dcoutts_> darcs get http://haskell.org/gtk2hs/darcs/gtk2hs/
08:03:03 <gour> dcoutts_: so you put up a (live) darcs repo for gtk2hs?
08:03:15 <xerox> gour: yeah, it very cool!
08:03:21 <dcoutts_> gour, it's not live, it's still the version that you did
08:03:26 <xerox> (it synchs)
08:03:36 <dcoutts_> well it's sort of live, updated every 24 hours
08:03:49 <ptolomy> Anybody know where I can get the code to Simon's original haskell web server?
08:03:52 <gour> dcoutts_: oh, it means i did not missed much :-)
08:04:03 <sethk> dcoutts, can you help me with my gtk2hs build problem?
08:04:03 <xerox> @google Simon Haskell Web Server Sources
08:04:03 <lambdabot> http://www.cs.uu.nl/~daan/pubs.html
08:04:05 <dcoutts_> gour, yeah  it's been working fine
08:04:21 <ptolomy> Lambdabot is so smart.
08:04:38 <gour> dcoutts_: that's nice to hear, at least i can contribute a little to haskell community
08:05:08 <ptolomy> well, except that he was wrong. dang.
08:05:40 <gour> dcoutts_: what's new with hide?
08:06:18 <SamB> wxHaskell seems pretty nice with all its combinators and attributes, but gtk2hs seems to have more widgets and things...
08:07:21 <dcoutts_> SamB, the main thing I've noticed recently is that there have not been any wxHaskell releases in a while
08:07:26 <timbod> And it looks like wx may have better mac support, but that's not important for me right now.
08:07:48 <sethk> dcoutts_, gtk2hs build problem?
08:07:50 <dcoutts_> it doesn't seem to have any contributers other than Daan, and he's a busy man.
08:08:01 <SamB> hmm
08:08:01 * gour thinks gtk2hs is a way to go (laughing)
08:08:08 <dcoutts_> sethk, what?
08:08:43 <dcoutts_> gour, I've not added anything to hIDE in the last few days. I've been working on the Gtk2Hs 0.9.10 release.
08:08:49 <sethk> dcoutts_, I'm getting the "impossible" error building, actually, yi at the moment.  I want to build hide presuming I can get yi to build
08:09:03 <sethk> dcoutts_, I fixed my gtk2hs problem finally
08:09:16 <dcoutts_> sethk, what was the problem/solutaion?
08:09:42 <sethk> dcoutts_, I restarted the build several times until it finally finished.
08:10:00 <sethk> dcoutts_, I've got a backup of the directory when the error occured if that helps anyone
08:10:14 <sethk> dcoutts_, simon said that error is new and he'll look at it.
08:10:23 <sethk> dcoutts_, do you want the specifics for that error?
08:11:23 <dcoutts_> sethk, was it more infomative than "the impossible happened" ?
08:11:42 <gour> dcoutts_: ok, and what about dons & Lemmih?
08:11:50 <sethk> dcoutts_, yes.
08:11:55 <dcoutts_> gour, dons has been adding patches
08:12:04 <dcoutts_> sethk, ok what was it?
08:12:22 <sethk> dcoutts_, hold on, I'll paste the exact error ...
08:12:52 <sethk> dcoutts_, ghc-6.4.1: internal error: evacuate: strange closure type 26222
08:13:03 <xerox> @ghc
08:13:04 <lambdabot>  GHC stack-space overflow
08:13:17 <xerox> @ghc
08:13:18 <lambdabot>  Malformed predicate
08:13:21 <sethk> dcoutts_, I think for my current "impossible" error, I just need a list of packages that are necessary.
08:13:32 <gour> dcoutts_:  ohh, i see that yi reqs gtk2hs-0.9.9.6 :-)
08:13:44 <ptolomy> @pl f x y = x * y
08:13:45 <sethk> dcoutts_, because simon told me the "impossibe" error is really a package is missing error, with a bogus message
08:13:45 <lambdabot> f = (*)
08:13:45 <xerox> gour: eventFunctions
08:13:49 <ptolomy> sweet.
08:19:49 <syntaxfree> re: gtk vs wx,  Wx looks good in OS X, GTK doesn't.
08:19:49 <syntaxfree> en Qt looks better in OS X. Anyone bothered to write QT bindings for Haskell already?
08:19:49 <gour> xerox: what?
08:19:55 <syntaxfree> s/en/even.
08:19:57 <timbod> dcoutts_: just satifying the build dependencies now. What's SOURCEVIEW, and do I want it?
08:20:16 <sethk> timbod, you need it, whether you want it or not.
08:20:19 <xerox> gour: there was some renaming because of name clashes on the Event type (x became eventX, and so on)
08:20:51 <gour> xerox: ahh...ok, thanks
08:21:16 <syntaxfree> xerox: do you think you can try and explain how to get to the pointless version of \a x y -> a * x +y  again?
08:21:40 <xerox> syntaxfree: as in reductions, or wordy explanation?
08:21:43 <syntaxfree> wordy explanation.
08:21:55 <syntaxfree> \a x y-> (*a) (x+y)
08:21:56 <timbod> sethk: thanks
08:21:58 <xerox> If you could wait, I'll do it in some minutes.
08:22:07 <syntaxfree> \a x y-> (*a).(+y) x
08:22:15 <syntaxfree> Now I can't get the variables out :~
08:22:17 <xerox> I don't think so.
08:22:28 <syntaxfree> oops. au contraire.
08:22:40 <syntaxfree> ((+y).(*a)) x
08:22:43 <xerox> You have to put the rightmost variable in the LHS as the leftmost thing on the RHS.
08:23:04 <syntaxfree> \a  y = (+y).(*a)
08:23:10 <syntaxfree> yes, yes. it's function composition, after all.
08:23:41 <xerox> No, your aim is to elide 'a'.
08:24:03 <syntaxfree> @eval let f a y = (+y).(*a) in f 2 1 2
08:24:04 <lambdabot> 5
08:24:13 <syntaxfree> hmm.
08:24:20 <syntaxfree> how do I elide a?
08:24:45 * syntaxfree sure can wait, worry not )
08:24:49 <syntaxfree> :)
08:27:25 <sethk> I've defined a type with data, then tried to use it as follows:   type X = IORef Y
08:27:29 <sethk> is that not allowed?
08:27:45 <sethk> Y is the type defined in a data statement
08:29:44 <syntaxfree> @eval let f y = (+).(*a) in f 2 1 2
08:29:45 <lambdabot>  Not in scope: `a'
08:31:08 <syntaxfree> @eval let f a = (+).(*a) in f 2 1 2
08:31:10 <syntaxfree> not good.
08:31:10 <syntaxfree> ah, good good yes.
08:31:28 <lambdabot> 4
08:31:46 <syntaxfree> yes, the argument order is back to normal n ow that i got y out.
08:31:51 <syntaxfree> f 2 2 1 => 5.
08:32:40 <syntaxfree> yes. I can get as far as f a = (+).(*a). removing the "a" is the hard thing.
08:34:15 <sethk> anyone?  I can do:  type IORef X    but if Y was defined with data, I can't do   type IORef Y     is there another way to do that?
08:35:12 <sethk> newtype, perhaps?
08:41:14 <timbod> gtk2hs built ok, and the demos work, except for the cairo ones. I get "not in scope:cairoCreateContext". Hints?
08:42:44 <gour> dcoutts_: i just pulled latest patches from  tailor's repo, there were quite a few
08:42:56 <sethk> timbod, are you sure cairo (gtk's) is installed?
08:43:05 <sethk> timbod, it will build without it, I believe, and then do that.
08:43:18 <sethk> timbod, probably you already checked that, though
08:44:26 <syntaxfree> mah poor brain.
08:44:32 <timbod> Yep, the configure script claims to have found it ok, and there is a cairo ghc package present
08:45:08 <wilx> @pl \a -> (+).(*a)
08:45:09 <lambdabot> ((+) .) . (*)
08:45:11 <wilx> :)
08:45:22 <syntaxfree> I manage to get the function written.
08:45:28 <syntaxfree> The argument order gets mangled, though.
08:45:55 <syntaxfree> oh, I also can never get the last variable out.
08:45:58 <wilx> @pl \a x y-> (*a) (x+y)
08:45:59 <lambdabot> (. (+)) . (.) . (*)
08:46:54 <syntaxfree> so is the pointless style of defining functions an application of the combinatory logic thing?
08:49:10 <syntaxfree> @pl \a -> a*x+y
08:49:10 <lambdabot> (y +) . (x *)
08:50:04 <xerox> Pay attention to free variables
08:50:22 <syntaxfree> yes, I'm trying to get the partial steps.
08:50:41 <timbod> sethk, found the problem. Although I have gtk and cairo installed, gtk is only 2.6, and it looks like 2.8 is needed for use with cairo (it seems to say so in docs for Graphics.UI.Gtk.Cairo).
08:50:56 <sethk> timbod, ok, didn't know that.
08:51:10 <xerox> timbod: yes, right.
08:51:34 <timbod> I'll wait for debian testing to upgrade. I'm to lazy/scared to do it otherwise....
08:51:42 <syntaxfree> I manage to get to \x->(.(x*)).(+)
08:52:01 <syntaxfree> How to get the x out seems beyond the scope of my intelligence.
08:52:56 <syntaxfree> also, the order of the argument is dead dead wrong :~
08:53:54 <xerox> I told you.
08:54:21 <syntaxfree> I tried removing the "a" first.
08:54:27 <xerox> How?
08:54:43 <syntaxfree> \a x y-> a * x +y
08:55:01 <syntaxfree> \a x y-> (+y) (a*x)
08:55:12 <syntaxfree> \a x y = (+y).(*x) a
08:55:24 <syntaxfree> \x y= (+y).(*x)
08:55:31 <xerox> Hmm, but.. ?
08:55:37 <syntaxfree> stupid me. then "a" becomes the last argument.
08:55:48 <syntaxfree> what happens if I reverse that to
08:56:05 <xerox> My approach is to get infix operators work prefix.
08:56:08 <syntaxfree> \x y = (.(*x))(+y)?
08:57:11 <xerox> \a x y -> a * x + y
08:57:11 <xerox> \a x y -> a * (x + y)
08:57:11 <xerox> \a x y -> (*) a (x + y)
08:57:26 <xerox> By commutativity: \a x y -> (*) (x + y) a
08:57:32 <xerox> \x y -> (*) (x + y)
08:57:43 <syntaxfree> yes, but it's not a*(x+y), it's (a*x) + y
08:57:55 <dcoutts_> timbod, you're probably not using Gtk+ 2.8.x. You only get the gtk/cairo integration functions with Gtk+ 2.8.x
08:58:11 <xerox> syntaxfree: oooh.
08:58:16 <xerox> syntaxfree: then I got it wrong!
08:58:32 <syntaxfree> remember, * has higher precedence than +.
08:58:51 <xerox> \a x y -> (a * x) + y
08:58:51 <xerox> \a x y -> (+y) ((*) a x)
08:58:52 <dcoutts_> timbod, otherwise you get standalone bindings for cairo which allow you to use cairo for writing to .png files but not to the screen.
08:58:55 <xerox> \a x y -> (a * x) + y
08:58:56 <xerox> \a x y -> (+y) ((*x) a)
08:59:02 <xerox> \a x y -> (a * x) + y
08:59:02 <xerox> \x y -> (+y) . (*x)
08:59:11 <syntaxfree> Yes, I got there.
08:59:23 <syntaxfree> Except that screws up the ordering of arguments.
08:59:29 <xerox> Why?
08:59:30 <syntaxfree> "a" becomes the last argument.
08:59:40 <xerox> It doesn't
08:59:44 <xerox> It does?
08:59:47 <xerox> Mumble :-)
09:00:12 <syntaxfree> I think it'll always do until one removes all variables.
09:00:19 <syntaxfree> the unsaid variable is always the last one.
09:00:46 <syntaxfree> I'm worried about keeping the argument order right when one goes point-free.
09:00:47 <timbod> dcoutts_, thanks I sussed that gtk 2.6 was not cairo suited from the Graphics.UI.Gtk.Cairo doco page.
09:00:51 <syntaxfree> but, looky there.
09:01:03 <syntaxfree> \y -> (+y).(*), right?
09:01:16 <xerox> a x get slurped, yes.
09:01:25 <syntaxfree> which is the same as
09:01:43 <syntaxfree> \y->(.(*))(+y)
09:01:51 <xerox> Yes.
09:01:55 <syntaxfree> \->(.(*)).(+)
09:01:58 <xerox> Yes.
09:02:01 <syntaxfree> but is the argument order right?
09:02:18 <syntaxfree> @pl \a x y->a*x+y
09:02:19 <lambdabot> ((+) .) . (*)
09:02:21 <xerox> Yes.
09:02:30 <xerox> That's what I said in first glance
09:02:41 <xerox> Purely intuitively - though.
09:02:51 * timbod is away: I'm busy
09:02:54 <syntaxfree> I still don't understand the ((+).) notation.
09:03:05 <xerox> You just explained it to me!
09:03:09 <syntaxfree> it's a left section of function composition?
09:03:47 <syntaxfree> I think (.(*)).(+) is in the wrong order.
09:09:58 <syntaxfree> nope.
09:10:09 <roconnor> How do I place myself on the Haskell IRC map?
09:10:12 <syntaxfree> (.(*)).(+) won't even run!
09:10:22 <syntaxfree> @hawiki HaskellUserLocations
09:10:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
09:10:41 <roconnor> Oh wait, I should probably register first
09:11:00 <syntaxfree> hey, araujo is in Pará.
09:11:09 <syntaxfree> hey araujo :)
09:12:23 <ProfTeggy> Bye all
09:14:31 <ndm> roconnor: no need, you can talk without registering
09:14:49 <roconnor> I mean I need to register on the wiki to add myself to the map
09:15:35 <syntaxfree> the wiki sometimes forbids editing from nonregistered users.
09:15:59 <syntaxfree> registering is easy, and you get a homepage that supports latex ;-).If you want, I can add you though;
09:20:02 <syntaxfree> I am still having trouble!
09:20:07 <roconnor> crap I created an account, but now I can't log in. :-(
09:20:19 <roconnor> Maybe I created it with the wrong password.
09:23:25 <ndm> username is case sensitive
09:23:35 <thedward> @eval map ("hello" !!) [3,4,2]
09:23:40 <lambdabot> "lol"
09:23:46 <roconnor> No my user name is right, because now I cannot create the account.
09:23:53 <thedward> haskell is nifty
09:23:58 <roconnor> So it must be my password.
09:24:08 <roconnor> can I have my password reset or mailed to me?
09:24:16 <thedward> for some reason using map with partially applied operators really amuses me
09:24:24 <syntaxfree> try to generate a string such that different functions yield different comprehensible strings.
09:25:17 <glasser> so i'm learning haskell and using it to model some probability stuff
09:25:33 <syntaxfree> @eval ["hello" !! x | x<-[3,4,2]]
09:25:35 <lambdabot> "lol"
09:25:41 <syntaxfree> that's more readable.
09:25:44 <glasser> specifically part of what i need is to be modeling functions from user-defined discrete sets to reals
09:26:05 <glasser> (and different functions might have different domains -- all of which are just cross products of specific finite sets)
09:26:07 <syntaxfree> specifically what I need now is a job.
09:26:29 <syntaxfree> About a year ago, I was saying "specifically what I need is a girl". But now I have a girl, but lost the job.
09:26:37 <glasser> should i be trying to implement these functions as lookup tables (which I probably would do in more imperative languages), or is there a clean way to implement them actually as functions?
09:26:51 <neologism> syntaxfree: glue that two into a... blowjob ;)
09:26:52 <syntaxfree> I don't understand.
09:27:36 <syntaxfree> what functions, glasser?
09:29:19 <glasser> so these are like conditional probability tables.  So one might enumerate all the values of (C,D) -> Reals, where C and D can each be "true" or "false" (so four values total)
09:29:20 <glasser> but different functions can have different domains, and the domains might not just be boolean (but they are definitely finite!)
09:29:20 <glasser> I can implement them as lookup tables (Data.Array or something), but should I be thinking more functional and actually implement them somehow as functions?
09:30:27 <integral> glasser: Data.Map is isomorphic to a function on a finite domain...
09:30:29 <markit> hi ppl :) any haskell bindings for a KDE/QT lover? Would like to have a look at haskell for developement in KDE
09:31:20 <syntaxfree> @eval let f = 0:12:[if (odd (floor x)) then 3*x+1 else x/2 | x<-tail f] in take 15 f
09:31:21 <lambdabot> [0.0,12.0,6.0,3.0,10.0,5.0,16.0,8.0,4.0,2.0,1.0,4.0,2.0,1.0,4.0]
09:31:27 <glasser> so i'm thinking too hard and should just use a map?
09:32:30 <integral> glasser: my heuristic would be that if the function ends up being a big list of individual cases I'd use a map
09:32:42 <integral> (eg. f "a" = 1; f "b" = 2; f "c" = 3)
09:33:23 <glasser> hmm.  I was thinking that a function would be nice for reasons like "then I can compose them" but i guess composition isn't actually the operator i'm using on them any way
09:33:24 <syntaxfree> markit: I asked that one about half an hour ago. No answer yet.
09:34:00 <markit> syntaxfree: ah, sounds not good, even in google I've not found anything
09:34:23 <SyntaxNinja> roconnor: what password is messed up?
09:34:41 <integral> glasser: you can compose maps!
09:34:41 <roconnor> I created an account on the wiki, but now I can't log in.
09:34:55 <roconnor> I thing i entered the wrong password when registering.
09:35:01 <roconnor> s/thing/think
09:35:01 <SyntaxNinja> roconnor: yeah, I had this problem too. shapr tried to fix it for me yesterday, but was unable to do so :(
09:35:07 <roconnor> oh
09:35:12 <roconnor> hmmmm
09:35:14 <glasser> integral: hmm, really?
09:35:19 <SyntaxNinja> moinmoin is a bit busticated it seems.
09:35:22 <roconnor> think it is a bit odd that we both have the same problem?
09:35:38 <SyntaxNinja> roconnor: well, he just started requiring passwords, and I probably did the same thing
09:35:52 <roconnor> mmmm
09:36:01 <SyntaxNinja> I bet it's a known problem, so if you have a chance, I'm sure you'd be welcome to google around and let shapr know if you find out how to fix it
09:36:23 <integral> glasser: sure!  \x -> m2 ! (m1 ! x) for example
09:36:38 <glasser> But that gives me a new function, not a map
09:36:57 <integral> well it's isomorphic ;-)   hmm, I can't find a nice combinator in Data.Map for this
09:37:28 <glasser> i'm sure I can write a function that'll build a map with those vaklues though
09:37:46 <glasser> (like, map that function over the input and fromList)
09:37:58 <integral> oh, Data.Map.map
09:38:14 <integral> Data.Map.map (m2!) m1
09:39:34 <glasser> ooh. that is cute
09:39:49 <integral> @pl \m1 m2 -> Data.Map.map (m2!) m1
09:39:50 <glasser> i really like haskell the more and more I learn about it.  I just wish I knew it better
09:39:50 <lambdabot> (((Data . Map) .) .) . flip (map . (!))
09:39:57 <integral> oops
09:40:00 <glasser> What does @pl show?
09:40:02 <integral> @pl \m1 m2 -> foo (m2!) m1
09:40:03 <lambdabot> flip (foo . (!))
09:40:23 <integral> glasser: point's free form.  it rewrites a lambda given point-wise as a composition of functions
09:41:00 <glasser> (I took one look at the sample Java code for my project in this class, said "wow this would be so much cleaner if Java had higher-order functions", and decided it was time to learn haskell for real...)
09:42:22 <integral> I like it when I can use them to get rid of explict recursion, that's amazing
09:43:27 * dcoutts_ likes pure APIs with hidden imperitives
09:43:46 <dcoutts_> eg the SOE has ops like: createRectangle :: Point -> Point -> Region
09:43:49 <dcoutts_> pure right?
09:43:59 <glasser> i mean this java code is just pages and pages of explicitly written-out filters and mappings and the same operations reimplemented over and over for different types
09:44:02 <xerox> Sounds like unsafePerformIO.
09:44:04 <dcoutts_> drawRegion :: Region -> Graphic
09:44:07 <dcoutts_> xerox, nope
09:44:11 <xerox> :-)
09:44:19 <dcoutts_> drawInWindow :: Window -> Graphic -> IO ()
09:44:23 <xerox> More like "Where did the monad go" ?
09:44:32 <dcoutts_> only at the very top level do you find that it involves IO
09:44:43 <dcoutts_> in al the other parts it hidden
09:44:51 <roconnor> SOE?
09:45:01 <gzl> Haskell School of Expression
09:45:03 <glasser> school of expression, the book
09:45:07 <dcoutts_> you can treat it purely, well it is pure
09:45:09 <glasser> very nice, i just borrowed a copy
09:45:13 <beelsebob_> ohhh! Henrik Nillson replied
09:45:14 <roconnor> Haskell School of Expression?
09:45:23 <beelsebob_> unfortunately he said nothing of huge interest
09:45:24 <beelsebob_> :(
09:45:26 <glasser> http://www.haskell.org/soe/
09:45:30 <dcoutts_> xerox, but underneath you can implement it by building up imperitive actions
09:45:43 <dcoutts_> whihc you only 'run' when you get to the top level
09:46:01 <roconnor> fancy
09:46:05 <dcoutts_> or you can implement it by building an expression tree which you then interpret at the top level
09:46:05 <glasser> well it's less describing actions than describing an object, specifically the graphic
09:46:19 <glasser> after all you don't have to draw it, theoretically you could calculate its area or something :)
09:46:40 <dcoutts_> that's tpyically less effecient but gives the possability to see the whole structure of the expression which can give you opportunities for runtime optimisation
09:47:11 <dcoutts_> xerox, so I implement region like so:
09:47:12 <dcoutts_> data Region = Region {
09:47:12 <dcoutts_>   regionGraphic :: Cairo.Render (),
09:47:12 <dcoutts_>   regionOriginX :: !Int,
09:47:12 <dcoutts_>   regionOriginY :: !Int,
09:47:12 <dcoutts_>   regionWidth   :: !Int,
09:47:14 <dcoutts_>   regionHeight  :: !Int
09:47:16 <dcoutts_> }
09:47:24 <dcoutts_> so there's a Cairo monad action in there
09:47:43 <dcoutts_> but you don't see that from the outside
09:47:49 <integral> the magic bit to be is the way that laziness turns that inside-out, so you've not really building the whole action before running it
09:47:51 <dcoutts_> it's rather nice
09:48:06 <dcoutts_> integral, yes exactly
09:48:10 <roconnor> You don't need the monad because you never get any data from it?
09:48:34 <dcoutts_> unless your interpreter examines the whole exression before evaluating it
09:48:45 <dcoutts_> roconnor, sorry? I don't follow
09:48:51 <tony2> @google lamdabot
09:48:53 <lambdabot> http://tunes.org/~nef/logs/haskell/04.04.21
09:49:00 <roconnor> Cairo.Render is always over ()
09:49:09 <dcoutts_> roconnor, well usually yes
09:49:14 <tony2> @google lambdabot
09:49:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
09:49:41 <xerox> dcoutts, WOW
09:49:47 <glasser> does anyone have any simple examples of using STRefs? I keep coming across them in the context or more complicated code
09:50:47 <dcoutts_> xerox, now I'm going to go and try and make it work with just Gdk :-(   (for those poor folk who don't have cairo installed)
09:53:55 <xerox> dcoutts_: aww.
09:53:58 <roconnor> http://haskell.org/gtk2hs/gallery/Cairo-demo/Cairo_demo_13
09:54:00 <roconnor> wow
09:54:03 <roconnor> pretty
09:54:04 <xerox> !
09:54:06 <glasser> What is Cairo?
09:54:17 <xerox> roconnor: I should upload more shots, these days I got very, very nice pics.
09:55:34 <xerox> glasser: it's a vector graphics engine, http://cairographics.org/
09:56:03 <roconnor> wow
09:56:15 <dcoutts_> glasser, and in particualr it's avector graphics system that's very easy to use from Haskell (thanks to the hard work of xerox)
09:56:21 <roconnor> I should use this for my gluplot replacement
09:56:25 <xerox> Let me show you something, roconnor...
09:56:33 <syntaxfree> someone should hack up a gnuplot interface.
09:56:34 <dcoutts_> roconnor, definately
09:56:38 <roconnor> I want to make a SVG backend!!!
09:57:02 <syntaxfree> I'm stuck with outputting text files, editing the with "tr" and feeding to gnuplot.
09:57:06 <dcoutts_> roconnor, Cairo will get a svg backend in a future version (it's already got ps & pdf)
09:57:25 <roconnor> Is it in the works?
09:57:36 <dcoutts_> it's under development apparently
09:57:38 <xerox> http://haskell.galois.com/~paolo/steo-2340-201005.png
09:57:55 <dcoutts_> mm, that's a nice one
09:58:07 <dcoutts_> oh and there's my one of it running on win32!
09:58:10 <xerox> Double-tree! :-)
09:58:21 <xerox> (hackish axiom, heh)
09:58:25 <dcoutts_> http://haskell.org/~duncan/cairo/Nymphaea-Win32.png
10:00:45 <syntaxfree> klezmer tune I'm obsessed with: http://s53.yousendit.com/d.aspx?id=2CSQHOKT2DTEJ03V25XZED0YN0
10:03:58 <roconnor> Time to head home
10:04:15 <thedward> @eval twice
10:04:17 <lambdabot>  Not in scope: `twice'
10:05:12 <thedward> @pl twice x = x . x
10:05:13 <lambdabot> twice = join (.)
10:05:33 <thedward> @index join
10:05:34 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
10:05:34 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
10:05:34 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
10:05:38 <ulfdoz> thedward: Eh, studiying in Passau (Germany)?
10:05:53 * thedward blinks
10:05:56 <thedward> ulfdoz: No, why do you ask?
10:06:28 <ulfdoz> thedward: Task of the current excercise sheet. "What's the type of twice f = f.f?"
10:06:35 <thedward> ah. heh.
10:06:49 <thedward> just trying to make my program more concise :)
10:07:04 <ulfdoz> additional remark: excercise sheet of the lessen functional programming.
10:07:14 <xerox> @type iterate
10:07:16 <lambdabot> forall a. (a -> a) -> a -> [a]
10:09:10 <thedward> @pl (take 3) .  repeat
10:09:11 <lambdabot> take 3 . repeat
10:11:12 <thedward> I don't think iterate will work
10:11:20 <thedward> I'm trying to build a matrix
10:11:28 <thedward> as a [[Integer]]
10:11:41 <thedward> that is, a matrix with all the same value
10:12:00 <xerox> take n $ iterate (const value)
10:12:10 <xerox> replicate n value -- maybe :-)
10:12:16 * SamB wonders if you can deal computationally with symmetrical polyhedra without losing much of their symmetry
10:12:23 <thedward> replicate is only Int
10:12:34 <thedward> and though I am doing Integers now, I want it general
10:12:38 <thedward> oh wait
10:12:40 <thedward> nevermind
10:12:51 <thedward> the number of times is Int, that should be fine for my purposes
10:13:13 <xerox> Indeed.
10:13:17 <SamB> thedward: I hope so!
10:14:16 <thedward> @pl replicate 3 $ replicate 3 9
10:14:17 <lambdabot> replicate 3 (replicate 3 9)
10:14:50 <thedward> @pl f w v = replicate w $ replicate w v
10:14:51 <lambdabot> f = liftM2 (.) replicate replicate
10:14:52 <xerox> @pl \n n' m -> replicate n $ replicate n' m
10:14:53 <lambdabot> (. replicate) . (.) . replicate
10:14:58 <SamB> if it weren't, though, there is always genericReplicate
10:15:05 <SamB> @type List.genericReplicate
10:15:06 <xerox> Woot!
10:15:06 <lambdabot> forall a i. (Integral i) => i -> a -> [a]
10:15:16 <xerox> liftM2 (.) replicate replicate -- is *SO* cute!!!
10:15:46 <thedward> I'm not sure 'cute' is the word I'd choose. ;)
10:15:50 * xerox fades slowly in the background
10:16:04 <thedward> is there any way to get rid of the second replicate?
10:16:14 <xerox> Yes, ^W
10:16:22 <thedward> :-P
10:16:23 <araujo> Hola syntaxfree
10:16:40 <thedward> just seems inelegant to have that repitition there
10:16:47 <thedward> ironically
10:16:49 <xerox> thedward: you're kidding.
10:16:49 <SamB> @type replicate
10:16:51 <lambdabot> forall a. Int -> a -> [a]
10:16:53 <SamB> @type liftM2
10:16:54 <lambdabot> bzzt
10:17:04 <SamB> @type Monad.liftM2
10:17:05 <xerox> @type Control.Monad.liftM2
10:17:05 <lambdabot> forall r (m :: * -> *) a2 a1.
10:17:05 <lambdabot> (Monad m) =>
10:17:05 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:17:06 <lambdabot> forall r (m :: * -> *) a2 a1.
10:17:06 <lambdabot> (Monad m) =>
10:17:07 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:17:11 <xerox> *boom*
10:17:26 <thedward> xerox: it isn't a practical concern, just trying to embed this stuff into my head
10:17:49 <thedward> reducing expressions seems a good way to do that
10:18:42 <SamB> @type (\f x -> liftM2 f replicate x)
10:18:43 <lambdabot> bzzt
10:18:58 <SamB> @type (\f x -> Monad.liftM2 f replicate x)
10:19:00 <lambdabot> bzzt
10:19:30 * SamB wonders what the trouble is
10:19:46 <SamB> @type Monad.liftM2 (.) replicate replicate
10:19:47 <lambdabot> bzzt
10:20:45 <SamB> oh, I see. there is no instance for (Monad ((->) Int)) in scope...
10:21:01 <xerox> thedward: reducing to meaningful cute expression is always fun - strip it to a bunch of letter never greater than 10 is perl
10:21:43 <thedward> xerox: eh. guess my brain damage from years of perl is showing through ;)
10:22:03 * xerox should take the pizzas if he want to eat this night
10:31:11 <syntaxfree> @seen araujo
10:31:12 <lambdabot> araujo is in #gentoo-haskell and #haskell. Last spoke 14 minutes and
10:31:12 <lambdabot> 48 seconds ago.
10:31:34 <SyntaxNinja> @type 4
10:31:35 <lambdabot> forall t. (Num t) => t
10:31:40 <SyntaxNinja> @eval 4+4
10:31:41 <lambdabot> 8
10:31:51 <SyntaxNinja> @seen shapr
10:31:51 <lambdabot> I saw shapr leaving #haskell-blah and #haskell 5 hours, 52 minutes
10:31:51 <lambdabot> and 26 seconds ago.
10:32:08 <SyntaxNinja> @listcommands
10:32:09 <lambdabot> use listcommands [module|command], please. Modules are:
10:32:09 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
10:32:09 <lambdabot> haddock help hoogle karma lambda localtime more pl plugs quote
10:32:09 <lambdabot> search seen spell state system todo topic type version vixen
10:32:09 <lambdabot> where
10:38:14 <syntaxfree> it's @listofcommands.
10:38:21 <syntaxfree> but don't do it in the channel, 'tis huge.
10:39:55 <syntaxfree> §2seen tizoc
10:39:58 <syntaxfree> @seen tizoc
10:39:59 <lambdabot> I saw tizoc leaving #haskell 12 hours, 54 minutes and 46 seconds ago,
10:39:59 <lambdabot> and I have missed 59 seconds since then.
10:41:25 <glasser> ha. i just managed to write an awful ST/STRef based version of
10:41:27 <glasser> countLeavesEasy Leaf = 1
10:41:27 <glasser> countLeavesEasy (Branch x y) = (countLeavesEasy x) + (countLeavesEasy y)
10:45:19 <xerox> glasser: what for?
10:45:43 <glasser> just to see if understood how to write in the ST monad
10:45:55 <glasser> "i can write imperative code in any language" and all
10:45:55 <xerox> I never did try, hmm.
10:46:52 <xerox> And the question again.. what for? ;-)
10:48:42 <glasser> "monads are hard" and it feels nice to have written my first bit of code that uses them that isn't copied out of a tutorial?
10:50:02 <xerox> But why ST at all?
10:52:38 <sethk> glasser, if you are hungry for work I have monad stuff you can do for me.  :)
10:52:54 <glasser> is ST not a useful tool in some cases?
10:53:05 <sethk> glasser, sure it is, that's why it is there
10:53:05 <glasser> it's one i've seen folks using
10:53:19 <glasser> sethk: oh, i think i should start my own project first :)
10:53:29 <sethk> glasser, definitely.  I think he meant that in this case maybe it didn't make sense
10:53:39 <sethk> glasser, not that there is anything wrong with the ST Monad in general.
10:53:47 <xerox> glasser: I never did.  Where did you see it?
10:54:11 <xerox> sethk: I'm not exactly sure about the former
10:54:15 <xerox> sethk: err, latter.
10:54:24 <glasser> well, it certainly doesn't make sense for reimplementing the function i already pasted (hell, it looks like it's 5 times slower that way)
10:54:53 <glasser> (and 10 times longer)
10:55:31 <xerox> glasser: where did you see it used?
10:55:41 <glasser> various articles i've read, etc
10:55:41 <sethk> xerox, IT'S AN INTERESTING LOOKING MONAD.
10:55:48 <glasser> say, http://www.haskell.org/tmrwiki/PracticalGraphHandling
10:56:27 <xerox> sethk: I remember some negative advice about using it.
10:56:42 <glasser> Why's that?
10:56:45 <sethk> xerox, possible.  I haven't read everything about monads by any means.
10:57:19 <xerox> glasser: ST is what IO is made of, in a certain sense.
10:57:29 <sethk> xerox, perhaps, though, to the fact that the situations where it is suitable are unusual
10:57:40 <glasser> sure
10:57:45 <glasser> so what's the problem?
10:58:29 <sethk> glasser, I doubt there is one.  Be interesting to know when to use this one rather than StateT
10:58:51 <glasser> Which is StateT? That's a transformer, right?
10:58:56 <glasser> I don't quite get the monad transformer
10:58:58 <glasser> s
10:59:06 <sethk> glasser, they are both transformers
10:59:12 <sethk> glasser, this one (ST) is strict
10:59:20 <sethk> glasser, StateT is more "normal"  :)
11:00:18 <glasser> what does strict mean exactly?
11:00:28 <sethk> glasser, the opposite of lazy
11:00:51 <sethk> glasser, e.g., arguments are evaluated when passed rather than when forced
11:01:08 <xerox> s/forced/and if strictly needed/
11:01:12 <glasser> Ah, right
11:01:30 <sethk> the brits use eager which I think is more evocative than strict
11:05:41 <syntaxfree> :)
11:09:11 <glasser> anyone have anything nice to recommend reading about StateT?
11:11:43 <Philippa_> glasser: a strict function f is one such that f _|_ = _|_
11:12:35 <Philippa_> what do you want to know about StateT?
11:14:35 <xerox> @google all about monads
11:14:37 <lambdabot> http://www.nomaware.com/monads/html/
11:14:40 <xerox> ^- that one
11:15:47 <glasser> ah right, i think i read that a while ago. thanks
11:15:52 <glasser> (anddidn't understand it :) )
11:25:48 <Frederick> hi folks
11:27:09 <araujo> syntaxfree!!
11:34:07 <Frederick> anyone alive?
11:34:43 <basti_> no
11:35:05 <basti_> are you, Frederick?
11:35:42 <Frederick> nope
11:35:51 <sethk> I'm having a near life experience
11:35:52 <basti_> sad
11:36:05 <basti_> Frederick: any questions about haskell?
11:36:35 <Frederick> basti_, sure
11:36:37 <Frederick> 1 sec
11:36:41 <xerox> autrijus: ping
11:36:45 * basti_ looks at his watch
11:36:45 <autrijus> xerox: pong
11:36:48 <basti_> your time is up.
11:36:51 <basti_> .)
11:37:06 <xerox> autrijus: what do you think about lisppaste?  someone was asking for using it in #p6
11:37:21 <autrijus> I know nothing about it
11:37:31 <xerox> lisppaste2: url
11:37:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:37:46 <autrijus> I don't think there should be anything against people setting up bots.
11:38:24 <autrijus> for this kind of purpose anyway.
11:38:32 <autrijus> (bbiab.)
11:38:33 <xerox> autrijus: ok great.  It's a very nice service.  I believe it was stevan that proposed it, and I took the occasion to ask the admin that I knew.
11:38:42 <autrijus> cool
11:39:05 <sethk> that might be a bit easier than the wiki paste
11:39:13 <sethk> sometimes you have to wait for the wiki page
11:39:19 <xerox> Someone should hack in Haskell synhl.
11:39:23 <sethk> wiki's not designed for updates on the order of minutes
11:39:33 * xerox offers a @karma+ to whoever does it!
11:41:19 * ValarQ reaches out his arms
11:42:26 * araujo askes again for the 111th time
11:42:36 <araujo> Anyone worked with readLine here?
11:42:55 <araujo> mm.. well, System.Console.ReadLine
11:42:58 <Frederick> basti_, im follwing parsecs tutorial and im trying to set up a context free grammar but Im not very experienced in haskell so I must be missing something here is the tutorial http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html and here is my source http://pastebin.ca/26194 all I want is give a list of terminals and productions
11:43:58 <basti_> you didn't specify a "main" function
11:44:27 <sethk> Frederick, is that really the right paste?
11:44:31 <stepcut> araujo: I have used it, but not in-depth...
11:44:40 <sethk> Frederick, because you'll get a syntax error message immediately with that
11:44:50 <Frederick> sethk, the source is wrong I know
11:44:56 <Frederick> but that is the idea
11:45:16 <Frederick> the right sample is http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html at separate scanners
11:45:21 <basti_> ...declaring some stuff and then not doing anything? ;)
11:45:47 <sethk> Frederick, yes, I've read that tutorial.  but I'm not sure what you are asking here.
11:46:03 <Frederick> basti_, since my declaration seems wrong ive stoppd to do step by step
11:46:26 <sethk> Frederick, ok, but you have to start with a shell that compiles
11:46:43 <sethk> Frederick, otherwise how can you know whether it is right or not?
11:46:47 <Frederick> sethk, that topic about separet scanners let me evaluate a word with a grammar
11:46:57 <sethk> Frederick, yes ...
11:46:57 <Frederick> sethk, I got ghc running
11:47:15 <araujo> stepcut, i got a very simple question (i think) , what is the function to include tab-comletion for specific directories?
11:47:24 <araujo> completion*
11:47:31 <sethk> Frederick, you think there is something wrong with your data statement?  or what?
11:48:36 <thedward> @pl f b = [ [ (head . head) b , (head . head . tail) b , (last . last) b ] ]
11:48:37 <lambdabot> f = return . ap ((:) . head . head) (ap ((:) . head . head . tail) (
11:48:37 <lambdabot> return . last . last))
11:48:50 <xerox> ...
11:49:09 <Frederick> sethk, Im confused about how to use it
11:49:25 <Frederick> I want to feed the program with that like a production and a terminal to evaluate a sample word
11:49:48 <sethk> Frederick, then take things one step at a time.  build the lexer.  the lexer is easy to test and can be built first.
11:50:04 <sethk> Frederick, or scanner as you called it.  same thing
11:50:27 <sethk> Frederick, then when your scanner is outputting tokens, we can build the parsers for them.
11:50:40 <sethk> Frederick, because, in a vacuum, it is difficult to do anything.
11:50:52 <Frederick> sethk, I know
11:50:52 <sethk> Frederick, so, start somewhere.  the scanner is a reasonable place to start.
11:51:17 <sethk> Frederick, can you start on the scanner, or are you too confused to even start?
11:51:27 <Frederick> sethk, im too confused to even start
11:51:51 <basti_> :/
11:51:54 <Frederick> sethk, ive read some papers but im quite new to haskell and ive found good explanations but im lacking of some samples
11:51:55 <xerox> Frederick: you could take a look at nymphaea's parser if you want.
11:52:12 <sethk> Frederick, ok.  I have an errand to do for the next 15 minutes or so.  I'll try to help after that.  Meanwhile, take a crack at something.  Anything.  The simplest thing you can think of.
11:52:15 <xerox> It parses strings like:
11:52:25 <Frederick> seafood, sure
11:52:28 <Frederick> sethk, sure
11:52:43 <basti_> Frederick: have you seen our bot?
11:52:48 <xerox> F -> {
11:52:48 <xerox>   1/2: F[++F]F[-F],
11:52:48 <xerox>   1/2: FG[-F]F[+F]
11:52:48 <xerox> }
11:53:01 <xerox> As in: char -> { probability: string, ... }
11:53:12 <basti_> @eval [1..4]
11:53:17 <ulfdoz> It looks ill.
11:53:17 <lambdabot> [1,2,3,4]
11:53:27 <ulfdoz> well done lambdabot
11:53:33 <basti_> @botsnack
11:53:34 <lambdabot> :)
11:53:44 <basti_> @eval map (10-) [1..4]
11:53:46 <lambdabot> [9,8,7,6]
11:54:45 <Frederick> basti_, nope
11:55:04 <basti_> Frederick: it's a nice toy for learning haskell basics. It doesn't do datatypes though.
11:55:39 <basti_> (which would help with your cause)
11:55:44 <basti_> do you understand lambdas?
11:55:47 <ulfdoz> btw. simple question. Probably syntactic stuff: shift :: (Integer -> Integer) -> Integer, shift f = (\\n -> f (n - 1)). Is there a way to do this shorter?
11:56:32 <basti_> ulfdoz: how do you make a Integer from an Integer->Integer? did you brace the wrong way around?
11:56:56 <ulfdoz> basti_: it's a functor.
11:57:02 <xerox> basti_: I think it's right
11:57:17 <xerox> Though it miss a '-> Integer'
11:57:23 <basti_> ^^
11:57:29 <Frederick> basti_, what do you mean by lambdas?
11:57:38 <xerox> @type \f n -> f (n - 1)
11:57:39 <lambdabot> forall a t. (Num a) => (a -> t) -> a -> t
11:57:44 <xerox> @pl \f n -> f (n - 1)
11:57:45 <lambdabot> (. subtract 1)
11:57:45 <basti_> Frederick: function abstractions. in haskell they are written "\"
11:57:56 <xerox> (. subtract 1) -- is so cute !!
11:57:59 <Frederick> basti_, I know lambda calculus
11:58:02 <Frederick> does it help?
11:58:04 <basti_> yes.
11:58:05 <basti_> a lot.
11:58:08 <Frederick> oki
11:58:25 <Frederick> basti_, I have the idea of what I want
11:58:36 <xerox> ulfdoz: is it short enough? :-)
11:58:37 <basti_> first, you need a certain datatype.
11:58:39 <Frederick> Im only having some problems to glue it up with haskell
11:58:54 <ulfdoz> xerox: Oh yes. that's nice.
11:59:16 <basti_> i'm not very good with parsec though
12:00:17 <Frederick> basti_, I will write a sample of what im trying to do in pastebin gimem a sec
12:00:28 * basti_ nodnods
12:04:07 <Frederick> basti_, http://pastebin.ca/26196
12:04:39 <basti_> yes, a grammar. I got this far, even without the paste ^^
12:04:56 <Frederick> basti_, well Im trying to translate that to haske??
12:05:02 * basti_ nods
12:05:08 <basti_> thats what parsec does for you
12:06:17 <Frederick> basti_, Ive found some more erros, im not importing parsec
12:06:35 <basti_> to do so would be adviseable
12:07:10 <Megz> Can Haskell have constants like PI with infinite precision?
12:07:14 <Frederick> basti_, does ghc comes with parsec by default?
12:07:21 <basti_> Megz: in principle, it can
12:07:22 <Frederick> Megz, no pc has infinite precision
12:07:26 <basti_> Frederick: i do not think so.
12:07:35 <Megz> Frederick: I'm asking about Haskell, not about PC's
12:07:38 <basti_> well it could represent a pi with -arbitary- precision
12:07:44 <Megz> I don't care what the precision of a PC is
12:08:43 <Megz> basti: My real question is.. can Haskell have a variable that's equal to 1/3 ?
12:08:52 <Megz> no, not 3.33, no, not 3.333333333
12:08:56 <Megz> sorry
12:09:00 <Megz> wrong decimal place
12:09:04 <Megz> no, not .333
12:09:04 <basti_> i see what you mean
12:09:07 <basti_> in principle it can
12:09:29 <Megz> So this is not one of the fundamental premises of Haskell?
12:09:33 <basti_> its just not very easy to implement this sort of number
12:09:34 <Megz> to be able to set a var to 1/3 ?
12:09:40 <Megz> I thought Haskell did this.
12:09:48 <basti_> @eval 1%3
12:09:49 <lambdabot> 1%3
12:09:50 <basti_> there
12:09:50 <basti_> :)
12:10:41 <stepcut> @eval (1%3) + (2%5)
12:10:42 <lambdabot> 11%15
12:10:57 <basti_> of course, pi is another league
12:10:59 * stepcut is working on a real Decimal arithmetic library
12:10:59 <Megz> nice
12:11:09 <Frederick> basti_, it seems ghc doesnt come with parsec by default
12:11:16 <basti_> but be assured, it is possible to represent this sort of number
12:11:20 <basti_> Frederick: thats what i said.
12:11:23 <basti_> -?-
12:12:04 <stepcut> Frederick: really?
12:12:06 <basti_> wb Frederick
12:12:14 <Frederick> lost con sorry
12:12:26 <Frederick> stefanw, yep
12:12:32 <basti_> so, no, ghc doesnt come with parsec.
12:12:32 <Frederick> and parsec package is a game
12:12:53 <basti_> ouhhmmm
12:12:55 <basti_> what distro?
12:12:56 <basti_> :D
12:13:14 <SamB> why does cvs want to write to /cvs/CVSROOT/history?
12:13:28 <Frederick> Compiling with GHC
12:13:29 <Frederick> Parsec is distributed as a package with GHC. This means that you can simply use the -package text switch to use the Parsec library
12:13:35 <Frederick> gentoo
12:14:13 <xerox> Frederick: GHC does come with Parsec
12:14:14 <stepcut> on debian/freebsd, parsec is included by default, and set to 'auto', so ghc --make, is all you need...
12:14:21 <sethk> 0back
12:14:26 <xerox> @docs
12:14:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:14:36 <basti_> Megz: do you see how this sort of number would work?
12:14:52 <Frederick> xerox, lemme read
12:15:00 <xerox> @docs Text.ParserCombinators.Parsec
12:15:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text.ParserCombinators.Parsec.html
12:15:04 * SamB didn't know Parsec didn't come with GHC in non-debian packages!
12:15:05 <xerox> ^- that one
12:15:29 <xerox> i.e. you have to do import Text.ParserCombinators.Parsec
12:15:30 <sethk> SamB, sure
12:15:47 <xerox> SamB: I think it does, in fact.
12:16:44 <Frederick> xerox, thx a lot now it is working
12:16:56 <sethk> definitely.  I installed it last week.  Like magic, there's parsec.  :)
12:17:23 <SamB> so why does cvs want to write to /cvs/CVSROOT/history?
12:17:46 <ValarQ> basti_: how did you do that 1%3 trick?
12:17:52 <basti_> ValarQ: Data.Ratio iirc.
12:17:59 <basti_> its an infix data constructor.
12:18:06 <ValarQ> basti_: thanks
12:18:19 <xerox> hehe, why 'trick' ? :-)
12:18:23 * basti_ shrugs
12:18:31 <basti_> haskell often appears to be magic
12:18:33 <sethk> SamB, because it wants to remember
12:18:36 <basti_> it's just smoke and mirrors though
12:18:38 <xerox> Agreed.
12:18:47 <SamB> sethk: but why would it want to write THERE?
12:18:56 <SamB> I have no such place, I don't even have a /cvs!
12:19:04 <ValarQ> such magic :-O
12:19:18 <sethk> SamB, oh, generally people set an environment variable CVSROOT, so they don't have to use -d on every cvs comman
12:19:21 <sethk> command
12:19:26 * xerox tries to go studying
12:19:42 <SamB> sethk: oh, usually I only have to do that when outside the directory!
12:21:03 <SamB> what strange games does fptools play that make it necessary to actually use CVSROOT?
12:21:27 <sethk> SamB, that I am unsure of
12:23:24 <SamB> why might I be missing mk/config.h.in?
12:24:07 <sethk> SamB, possibly you have to do autoconf or autoreconf?
12:24:53 <Frederick> guys Im trying this http://rafb.net/paste/results/XduHJl97.html it complains the constructors arent in scope
12:25:06 <Frederick> shouldnt parsec give the constructors?
12:25:15 <sethk> Frederick, yes.  but let us look.   :)
12:25:23 * SamB just got to that part of the manual
12:25:28 <Frederick> :d
12:25:30 <Frederick> :D
12:25:54 <sethk> Frederick, which constructor?  what's the first error message?
12:25:55 <ulfdoz> b:
12:26:00 * SamB still wonders where in the world it comes from
12:26:49 <Frederick> http://rafb.net/paste/results/VTW8bh41.html
12:27:19 <goron> How can I round a float on two decimal points?
12:27:36 <basti_> goron: (/100).round.(*100)?
12:30:39 <aFlag> i don't get the topic "Haskell is still the language of choice for discriminating hackers", what does it mean by discriminating hackers?
12:30:58 <Frederick> aFlag, top ones
12:31:13 <sethk> aFlag, you don't understand the use of discriminating, you mean?
12:31:19 <aFlag> yes
12:31:41 <Frederick> sethk, did you see the error massages?
12:32:08 <sethk> Frederick, no, sorry, I'll look now.
12:32:15 <Frederick> :)
12:32:18 <ski_> (aFlag : http://icfpc.plt-scheme.org/)
12:33:10 <sethk> aFlag, means those who care about quality, or those who recognize quality
12:34:13 <ski_> (or are picky about what they use .. or something like that)
12:34:21 <sethk> Frederick, you need to import  .......Parsec.Expr
12:34:32 <sethk> Frederick, or qualify it as Expr.AssocLeft
12:37:16 <Frederick> sethk, done, hm I tought that by importing parsec I would get all I need
12:37:31 <ski_> you import the bits you need
12:38:05 <sethk> Frederick, the name of it is ......Parsec.Expr.AssocLeft.  So you either import up to the last ., or you qualify
12:38:17 <Frederick> seems it imported right but im calling it worngly http://pastebin.ca/26198
12:38:35 * xerox shoots the TV with a BIG quake-like weapon... and then wakes up, and the TV is still there and noisy.
12:39:08 <sethk> Frederick, the code you pasted doesn't even have that line number
12:39:13 <ulfdoz> xerox: Big quake like? Bfg, chaingun? Gauntlet?=
12:39:17 <ulfdoz> Shotgun?
12:39:43 <sethk> Frederick, oh, it's ok
12:39:49 <xerox> Doesn't really matter, grmmblrrrr
12:39:50 <sethk> Frederick, it uses on past the last line number in this case
12:39:52 <sethk> Frederick, sorry
12:39:53 <ski_> Frederick : you can't apply the parser like that
12:40:11 <ski_> Frederick : you need to run it wiht one of the 'parse' functions, in Parsec.Prim ..
12:40:13 <Frederick> here http://pastebin.ca/26199
12:40:22 <sethk> expr doesn't take a String
12:41:14 <ski_> Frederick : http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Prim.html    look at 'runParser','parse','parseFromFile','parseTest'
12:41:40 <sethk> Frederick, start with something much simpler, then build it piece by piece.
12:41:46 <thedward> @pl f xs = ( all (==3) xs ) || ( all (==4) xs )
12:41:47 <lambdabot> f = ap ((||) . all (3 ==)) (all (4 ==))
12:42:27 <ski_> Frederick : try 'main = print =<< parse expr "test" "1+2*3"'
12:42:59 <thedward> @pl f x = (x==3) || (x==4)
12:42:59 <goron> basti_: That doesn't type check.
12:43:00 <lambdabot> f = liftM2 (||) (3 ==) (4 ==)
12:43:02 <ski_> (you need to import Parsec.Prim or qualify 'parse', of course)
12:43:24 <basti_> goron: because it doesnt know what type to assign?
12:43:33 <goron> basti_: yes
12:43:55 <goron> basti_: I gave it an explicit type signature.
12:44:01 <basti_> uhmmm
12:44:02 <goron> basti_: Float->Float
12:44:10 <ski_> @type round
12:44:11 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:44:23 <ski_> it given some integral type
12:44:24 <basti_> ohhh
12:44:25 <basti_> yes
12:44:31 <basti_> of course, you need fromIntegral in there
12:44:35 <goron> And Float isn't an instance of both.
12:44:35 <ski_> s/given/gives/
12:44:40 <ski_> m
12:44:54 <xerox> Expectably :-)
12:44:54 <basti_> @eval ((/100.0).fromIntegral.round.(*100.0)) 1.34141
12:44:56 <lambdabot> 1.34
12:45:12 <ski_> (the '.0' is not needed)
12:45:27 <basti_> no it isnt
12:45:32 <Frederick> http://pastebin.ca/26200
12:46:22 * ski_ <- stupid
12:46:30 <ski_> s/=<</$/
12:46:30 <basti_> ah no
12:46:41 <ski_> Frederick : ok
12:46:42 <ski_> ?
12:46:44 <xerox> ski_: you aren't!
12:46:54 <ski_> yes i am !
12:47:11 <Frederick> I got errors im googling to check what they are
12:47:20 <Frederick> the link has ghc output
12:47:25 <ski_> 'they' ?
12:48:13 <goron>  @eval ((/100.0).fromIntegral.round.(*100.0)) 2.565
12:48:17 <goron> @eval ((/100.0).fromIntegral.round.(*100.0)) 2.565
12:48:19 <lambdabot> 2.56
12:48:21 <ski_> Frederick : did you try changing into '$' yet ?
12:48:31 <goron> Shouldn't this be 2.57?
12:48:36 <ski_> (or even just do it like  'main = print (parse expr ...)')
12:48:41 <basti_> goron: hmmm
12:49:00 <basti_> it should, yes, imo.
12:49:02 <ski_> @eval ((/100.0).fromIntegral.round.(*100.0)) 2.575
12:49:03 <basti_> @eval round 0.5
12:49:04 <lambdabot> 2.58
12:49:04 <lambdabot> 0
12:49:07 <basti_> !!!!
12:49:11 <goron> Haskell is great for financial programming!
12:49:12 <ski_> as i thought
12:49:18 <goron> ROFL
12:49:32 <basti_> GHC DEVELOPERS!
12:49:34 <ski_> when rounding an exact '5', it will round so last digit is even
12:49:59 <basti_> o0
12:50:06 <basti_> why that?
12:50:17 <ski_> Frederick : well ?
12:50:21 <basti_> @eval round 1.5
12:50:22 <lambdabot> 2
12:50:28 <basti_> my
12:50:31 <basti_> why do people do that?
12:50:45 <thedward> @pl f (x:xs) = all (==x) xs
12:50:47 <lambdabot> f = ap (all . (==) . head) tail
12:50:57 <thedward> @type ap
12:50:58 <lambdabot> bzzt
12:51:02 <thedward> @index ap
12:51:02 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
12:51:02 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
12:51:02 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
12:51:02 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.
12:51:02 <lambdabot> Inductive
12:51:08 <sethk> basti_, do what?
12:51:14 <thedward> @type Monad.ap
12:51:17 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m
12:51:17 <lambdabot> b
12:51:17 <basti_> sethk: round in this strange way
12:51:18 <ski_> dunno, .. round up "same nomber of times" as down ?
12:51:32 <ski_> u
12:51:47 * goron thinks it's extremely userunfriendly. 
12:51:48 <basti_> never heard about that method
12:52:01 <ski_> i heard about both in school
12:52:04 <sethk> basti_, what, rounding .5 up to 1?
12:52:14 <basti_> sethk: no, rounding .5 to 0, and 1.5 to 2
12:52:24 <Frederick> ski_, it worked thx a lot!
12:52:30 <ski_> @eval map round [0.5,1.5,2.5,3.5]
12:52:31 <sethk> basti_, oh, ok.
12:52:32 <lambdabot> [0,2,2,4]
12:52:45 <ski_> Frederick : yw :)
12:53:35 <goron> But do we consider this to be a bug?
12:53:47 <ski_> possibly, in financial (/economic ?) computations one could want to in random round as many times up as down ..
12:53:57 <basti_> no not a bug, if it is a method that is accepted
12:54:01 <basti_> i just never heard about it
12:54:21 <goron> So the only other method to implement the rounding is showing the value?
12:54:30 <ski_> i'm not sure how often this variant is used, but it's sure a method that is used at times
12:54:59 <goron> And then getting the stuff before the point and getting the three first decimals and do a comparison?
12:55:21 <goron> Or is there some better way?
12:55:25 <basti_> you could also do something along the line of trunc.(+0.5)
12:55:31 <basti_> that would give "normal rounding"
12:55:31 <sethk> hm.  you have to close a comment with space -}
12:55:37 <sethk> -} not following a space doesn't work.
12:56:10 <basti_> yes.
12:56:25 <basti_> it could be mistaken as an operator
12:56:33 <basti_> or worse, as part of an operator
12:56:36 <sethk> I thought trunc is like floor
12:56:51 <basti_> yes.
12:57:01 <basti_> @eval trunc.(+0.5) 0.3
12:57:02 <lambdabot>  Not in scope: `trunc'
12:57:04 <basti_> grr
12:57:14 <sethk> Not in scope:  `grr'
12:57:14 <basti_> @index trunc
12:57:15 <goron> @eval truncate.(+0.5) 0.3
12:57:15 <lambdabot> System.Posix.IO, System.Posix
12:57:16 <lambdabot>  add an instance declaration for (Show (a -> b))
12:57:26 <basti_> ahh
12:57:29 <malcolm> @eval truncate.(+0.5) 0.3
12:57:31 <lambdabot>  add an instance declaration for (Show (a -> b))
12:57:34 <basti_> @eval truncate.(+0.5) $ 0.3
12:57:36 <lambdabot> 0
12:57:38 <basti_> @eval truncate.(+0.5) $ 0.5
12:57:39 <lambdabot> 1
12:57:53 <goron> @eval truncate.(+0.5) $ 1.5
12:57:55 <lambdabot> 2
12:57:58 <basti_> do you people notice that i was already programming rounding routines when you were in diapers?
12:58:03 * basti_ feels old old old
12:58:29 <syntaxfree> I programmed rounding routines as a 8-year old, in 1990.
12:58:37 <sethk> basti_, don't forget about floating point roundoff errors.  If you are as old as me you'll know what that means.  :)
12:58:39 <syntaxfree> I owned a ZX Spectrum.
12:58:43 <basti_> ^^
12:59:47 * basti_ had a c128
13:00:21 <syntaxfree> I programmed rounding routines as 8-year-old, and 15 years later I still can't figure points-free notation after hours of trying.
13:00:34 <syntaxfree> I _can_ write most functions, but I screw up argument order.
13:01:07 <syntaxfree> I need help.
13:01:30 * basti_ cuddles syntaxfree gently
13:02:30 * ski_ programmed a simple crypt (alphabet permutation) program in < 510 bytes when around 7 or 8 ..
13:02:31 <basti_> syntaxfree: its not all that bad
13:02:39 <basti_> basic or assembler?
13:03:13 <ski_> (syntaxfree : hm, which expression do you want in pointless ?)
13:03:25 <syntaxfree> @eval f = (.(*)) (+) in f 2 2 1
13:03:26 <lambdabot>  parse error on input `='
13:03:28 <ski_> basti_ : basic (PB-100F calculator)
13:03:40 <syntaxfree> @eval f = 5 in f
13:03:41 <lambdabot>  parse error on input `='
13:03:47 <syntaxfree> hmm of course.
13:03:52 <basti_> ski_: bizarre.
13:03:53 <sethk> basti_, you guys are kids.  I programmed a PDP 7
13:03:54 <ski_> syntaxfree : s//let /
13:03:56 <syntaxfree> @eval let f = (.(*)) (+) in f 2 2 1
13:03:57 <lambdabot>  add an instance declaration for (Num (a -> a))
13:04:03 <ski_> basti_ : how so ? :)
13:04:03 <basti_> sethk: oh my
13:04:18 <sethk> basti_, the funeral is the week after next  :)
13:04:41 <syntaxfree> @eval let f = (.(*)) (+) :: (Num a)=>(a->a->a->a) in f 2 2 1
13:04:42 <lambdabot>  (a -> a) -> a -> a -> a
13:04:42 <lambdabot>   Inferred type: (a -> a) -> (a -> a) -> a -> a
13:04:43 <basti_> yours or the pdp's?
13:05:09 <syntaxfree> there's no (a->a)  there. there shouldn't :(
13:05:13 <sethk> basti_, probably both, saves money
13:05:16 <syntaxfree> @pl f a x y= a * x + y
13:05:17 <lambdabot> f = ((+) .) . (*)
13:05:27 <ski_> @type (.(*)) . (+)
13:05:28 <lambdabot> forall a. (Num a, Num (a -> a)) => (a -> a) -> a -> a -> a
13:05:50 <ski_> \a x y -> a * x + y
13:05:53 <syntaxfree> how is ((+).) . (*) different from (+).(*)
13:06:02 <ski_> \a x y -> (+) (a * x) y
13:06:08 <ski_> \a x -> \y -> (+) (a * x) y
13:06:15 <ski_> \a x -> (+) (a * x)
13:06:26 <ski_> \a x -> (+) ((a *) x)
13:06:31 <syntaxfree> o got to \a x -> (+) (a*x)
13:06:35 <syntaxfree> s/o/i
13:06:35 <ski_> \a x -> ((+) . (a *)) x
13:06:42 <ski_> \a -> \x -> ((+) . (a *)) x
13:06:46 <ski_> \a -> (+) . (a *)
13:06:54 <ski_> \a -> (.) (+) (a *)
13:07:02 <syntaxfree> actually, I got to \a->(+).(*a)  too.
13:07:23 <syntaxfree> hmm. that's getting better.
13:07:27 <basti_> you guys did suffer.
13:07:42 <ski_> \a -> (.) (+) ((*) a)
13:07:55 <ski_> \a -> ((.) (+) . (*)) a   -- i think
13:07:58 <xerox> @eval (\a -> (.) (+) (*a)) 1 2 3
13:07:59 <lambdabot> 5
13:08:05 <ski_> @type (.) (+) . (*)
13:08:07 <lambdabot> forall a. (Num a) => a -> a -> a -> a
13:08:14 <ski_> @type ((+) .) . (*)
13:08:15 <lambdabot> forall a. (Num a) => a -> a -> a -> a
13:08:22 <syntaxfree> @eval (\a -> (.) (+) (*a)) 2 2 1
13:08:22 <ski_> syntaxfree : there you go
13:08:24 <lambdabot> 5
13:08:30 <syntaxfree> um. I see.
13:08:40 <syntaxfree> thanks.
13:08:52 <xerox> I was missing some steps :D
13:09:05 <ski_> (of course, doing this fully can be pointless)
13:10:21 <syntaxfree> 6:06 PM  ski_: \a -> (.) (+) ((*) a)
13:10:21 <syntaxfree> 6:07 PM  ski_: \a -> ((.) (+) . (*)) a   -- i think
13:10:27 <syntaxfree> that's the step I don't understand.
13:11:07 <syntaxfree> Is there such a thing as a "reverse @pl" to check out expressions?
13:11:33 <ski_> syntaxfree : ok, lets rename some to see more clearly
13:11:48 <ski_> f = (.);  g = (+);  h = (*)
13:11:52 <ski_> \a -> (.) (+) ((*) a)
13:12:00 <ski_> \a -> f g (h a)
13:12:01 <syntaxfree> hmm. goody. let's do it.
13:12:05 <ski_> \a -> (f g) (h a)
13:12:14 <ski_> \a -> ((f g) .h) a
13:12:25 <ski_> \a -> ((f g) . h) a   -i.e.
13:12:30 <ski_> ok ?
13:12:42 <syntaxfree> wait, wait. how do I guarantee  f g ( h a) = (f g) (h a)?
13:12:59 <ski_> 'f g' is just a function
13:13:11 <syntaxfree> yes, I know.
13:13:17 <ski_> application associates to the left
13:13:39 <ski_> foo bar baz = (foo bar) baz
13:13:47 <ski_> no more complicated than that
13:13:48 <syntaxfree> well, but (reverting to mathematical notation), aren't ou saying f(g(h(a)))  there?
13:13:52 <ski_> no
13:14:03 <ski_> f takes two (curried) arguments
13:14:10 <syntaxfree> hmm.
13:14:10 <ski_> first g, then h a
13:14:15 <syntaxfree> g then (h a)
13:14:19 <ski_> yah
13:14:24 <syntaxfree> I see.
13:14:31 <syntaxfree> I think I see. I hafta think about it.
13:14:35 <ski_> so, f partially applied to g is still a function
13:14:43 <syntaxfree> I mean, I'm convinced, I just have to learn how to do them myself.
13:14:49 <syntaxfree> oh ok. partial application, yah.
13:15:57 <ski_> compare with
13:15:59 <ski_> @eval map reverse (concat [["","a","bc"],["def","ghij"],["klmno"]])
13:16:02 <lambdabot> ["","a","cb","fed","jihg","onmlk"]
13:16:21 <ski_> @type map reverse
13:16:23 <lambdabot> forall a. [[a]] -> [[a]]
13:16:27 <ski_> @eval (map reverse) (concat [["","a","bc"],["def","ghij"],["klmno"]])
13:16:29 <lambdabot> ["","a","cb","fed","jihg","onmlk"]
13:18:46 <syntaxfree> hmm. lemme think.
13:19:06 <syntaxfree> \a x y = (a * x) - y
13:19:14 <syntaxfree> \a x y = (-) (a*x) y
13:19:26 <syntaxfree> \a x y = (-) ((*) a x)) y
13:19:38 <syntaxfree> \a x = (-) ((*) a x))
13:20:06 <ski_> yes
13:20:09 <syntaxfree> \a -> (-).(*) a
13:20:15 <ski_> (except s/=/->/ :)
13:20:26 <syntaxfree> er, ((-).(*)) a
13:20:39 <syntaxfree> nah, that's wrong.
13:20:40 <ski_> no
13:20:42 <ski_> m
13:21:02 <syntaxfree> \a x = (-) ((*) a x))
13:21:05 <ski_> (btw if you want to stop here, then '(*) a = (a *)')
13:21:20 <syntaxfree> yes, I know.
13:21:29 <syntaxfree> \a x -> (-) ((*a) x)
13:21:29 <ski_> remember that that application of (*) is curried
13:21:41 <syntaxfree> \a x -> (-).(*a) x
13:21:48 <syntaxfree> \a -> (-).(*a)
13:22:15 <ski_>  \a x -> (-).(*a) x    -- should be     \a x -> ((-).(a*) x
13:22:19 <syntaxfree> @eval f a = (-).(*a) in f 2 2 1
13:22:20 <lambdabot>  parse error on input `='
13:22:31 <syntaxfree> @eval let f a = (-).(*a) in f 2 2 1
13:22:33 <lambdabot> 3
13:22:45 <araujo> Hola syntaxfree
13:22:49 <xerox> If you want something like just 'in' use 'where'
13:22:50 <syntaxfree> hey.
13:22:50 <ski_> '(a*)', not '(*a)'
13:22:58 <xerox> f 2 2 1 where @eval let f a = (-).(*a)
13:23:02 <araujo> syntaxfree, tambien de sur-america? :-)
13:23:05 <xerox> @eval f 2 2 1 where let f a = (-).(*a)
13:23:06 <lambdabot>  parse error on input `}'
13:23:07 <xerox> Sorry :-)
13:23:10 <xerox> Oh :(
13:23:16 <xerox> Silly :-)
13:23:20 <ski_> xerox : that only works in declaration level ..
13:23:21 <syntaxfree> yeah. I thought you were in Pará, actually. So you're in Venezuela, instead?
13:23:26 <syntaxfree> or Colombia?
13:23:26 <xerox> @eval f 2 2 1 where f a = (-).(*a)
13:23:28 <lambdabot> 3
13:23:30 <xerox> It does work
13:23:33 <araujo> syntaxfree, venezuela.
13:23:35 <xerox> I left the 'let' :-)
13:23:37 <araujo> syntaxfree, you?
13:23:45 <syntaxfree> I live in Rio de Janeiro.
13:23:52 <araujo> Nice.
13:23:59 <araujo> That's kind of close then
13:24:14 * syntaxfree awaits impatiently to show up on /HaskellUserLocations
13:24:19 <{Arias}> hols :)
13:24:21 <araujo> :-)
13:24:22 <{Arias}> hola
13:24:26 <araujo> Hola {Arias}
13:24:33 <{Arias}> ^^
13:24:42 <syntaxfree> so, f a = (-).(*a)
13:25:05 <syntaxfree> f a = (-).((*) a)
13:25:38 <ski_> ya
13:25:41 <syntaxfree> f a = ((-).(*)) a?  naaah, that's not good.
13:25:52 <ski_> make the infix '.' be prefix
13:26:00 <ski_> or
13:26:06 <syntaxfree> f a = (.(*a))(-)
13:26:09 <syntaxfree> why?
13:26:30 <ski_> you can note that '(-) . ((*) a) = ((-) .) ((*) a)' :)
13:26:34 <ski_> nono
13:26:42 <ski_> either do
13:26:53 <ski_> (.) (-) ((*) a)
13:26:55 <ski_> or do
13:27:00 <ski_> ((-) .) ((*) a)
13:27:08 <ski_> in general
13:27:14 <syntaxfree> hmm.
13:27:22 <syntaxfree> why the left section on the composition? :~
13:27:37 <ski_> E0 <+> E1  =  (E0 <+>) E1  =  (<+> E1) E0
13:27:50 <ski_> for any expressions E0,E1 and any operator <+>
13:28:01 <ski_> E0 <+> E1  =  (E0 <+>) E1  =  (<+> E1) E0  =  (<+>) E0 E1
13:28:03 <syntaxfree> where <+> is a commutative operator?
13:28:09 <ski_> nono
13:28:11 <syntaxfree> ah, no. it's true.
13:28:14 <ski_> *any* binary op
13:28:36 <syntaxfree> hmm. let me think.
13:28:37 <araujo> Is there an equivalent 'eval' function in Haskell?
13:28:46 <syntaxfree> @eval (/2) 6
13:28:48 <ski_> lambdabot's @pl seem to sometimes (intended ?) use comutativity of e.g (*), though
13:28:48 <lambdabot> 3.0
13:28:57 <ski_> (i didn't use such above)
13:28:58 <syntaxfree> @eval (6/) 2
13:29:00 <lambdabot> 3.0
13:29:05 <syntaxfree> ahh. yes.
13:29:23 <ski_> araujo : ?
13:29:35 <syntaxfree> so, (-).((*) a) turns out to be..
13:29:41 <ski_> (araujo : there are a function in hs-plugins that take a string and compile it, iirc)
13:29:42 <araujo> 'eval' , the lisp function :-]
13:30:14 <xerox> araujo: yes
13:30:16 <syntaxfree> ((-).) ((*) a)
13:30:26 <xerox> What ski said :)
13:30:29 <araujo> xerox, yeah?
13:30:31 <araujo> Ok...
13:30:32 <ski_> syntaxfree : yes
13:30:53 <ski_> now just introduce another '.' ala 'f (g x) = (f . g) x' :)
13:31:14 <syntaxfree> ((-).).(*) a
13:31:18 <syntaxfree> ah.
13:31:20 <syntaxfree> hmm.
13:31:23 <ski_> no
13:31:29 <ski_> (((-).).(*)) a
13:31:37 <syntaxfree> yes, yes.
13:31:40 <ski_> otherwise it gets parsed as ((-).).((*) a)
13:31:45 <syntaxfree> yes.
13:31:54 <syntaxfree> I was about to elliminate the "a" in my head. Hmm.
13:32:00 <syntaxfree> The double composition is quite counterintuitive.
13:32:03 <ski_> now you can just eta-eliminate ..
13:32:50 <syntaxfree> @pl f a x y = a*x /y
13:32:51 <lambdabot> f = ((/) .) . (*)
13:32:58 <syntaxfree> let me try that on my own.
13:33:16 <ski_> (when playing around with stuff like this, i sometimes define 'dup k x = k x x' for duplicating a var ..)
13:33:49 <SamB> when might (*) not be commutative?
13:34:01 <ski_> dunno :)
13:34:15 <ski_> possibly it's included in the contract of Num, not sure
13:34:17 <syntaxfree> f a x y = ((*) a x)/y = (/) ((*) a x) = (/) ((*a) x) = ((/). (*a)) x
13:34:48 <int80_h> the hugs site is a bit hung up for me. Has it been ported to solaris?
13:34:49 <SamB> unlike Eiffel, most of our contracts aren't very detailed...
13:34:57 <ski_> (SamB : just it's good to be able to reason correctly about this when the operator/function isn't commutative ..)
13:34:59 <syntaxfree> @eval let f a  = (/).(*a) in f 13 2 13
13:35:01 <lambdabot> 2.0
13:35:11 <syntaxfree> @eval let f a  = (/).(*a) in f 13 2 26
13:35:12 <lambdabot> 1.0
13:36:15 * SamB would sooner make 6 return bottom than (*) not commute...
13:36:51 <xerox> Goodnight folks.
13:37:07 <syntaxfree> f a = (/).(*a) = ((/).) ((*) a) = ( ((/).).(*) )  a
13:37:10 <ski_> night xerox
13:37:17 <SamB> though that is probably because I'm more likely to use Galois Fields than whichever of quaternians/hypercomplex numbers don't have commutative multiplication...
13:37:26 <syntaxfree> @eval let f = ((/).).(*)  in f 13 2 26
13:37:28 <lambdabot> 1.0
13:37:37 <syntaxfree> oh yeaaaaah.
13:38:32 <ski_> (syntaxfree : if not assuming commutative '(*)', then '(* a) = flip (*) a')
13:38:38 <thedward> wow. Arrays are a much better fit for doing a tic tac toe board than Lists
13:38:53 <thedward> I should have read up on these earlier
13:39:03 <syntaxfree> ski:  I don't understand what flip does.
13:39:18 <ski_> it flips order of the (first) two arguments
13:39:23 <ski_> flip f x y = f y x
13:39:47 <ski_> so, saying that '(*)' is commutative is the same as saying that 'flip (*) = (*)'
13:39:59 <ski_> @type flip
13:40:00 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
13:40:16 <ski_> (E0 <+>) = (<+>) E0
13:40:23 <ski_> (<+> E1) = flip (<+>) E1
13:40:46 <syntaxfree> (*) needs to be commutative so you consider a group a "body".
13:40:46 <ski_> (<+> E1) = flip (<+>) E1 = (<+>) `flip` E1    :)
13:41:02 <syntaxfree> you need a group to be a body so it can be an ordered body.
13:41:08 <ski_> body ?
13:41:14 <ski_> s/bofy/field/ ??
13:41:20 <syntaxfree> breaking the commutativity of multiplication breaks order relations like (<)  as well.
13:41:22 <syntaxfree> maybe.
13:41:53 <{Arias}> grr, how can i convert a float to a integer?
13:42:02 <ski_> {Arias} : in what way ?
13:42:06 <ski_> @type round
13:42:08 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:42:10 <ski_> @type truncate
13:42:11 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:42:16 <ski_> @type floor
13:42:17 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:42:23 <ski_> @type cieling
13:42:24 <lambdabot> bzzt
13:42:25 <{Arias}> this is an integral
13:42:28 <ski_> @type ceiling
13:42:28 <{Arias}> not an integer
13:42:29 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:42:42 <ski_> instance Integral Integer
13:42:46 <SamB> why might the fptools configure script not find my docbook-xsl? Its from a debian package... I suppose because XML is a pita and has no standard catalog mechanism...
13:42:50 <ski_> so, it works for Integer
13:42:56 <{Arias}> m
13:43:23 <ski_> {Arias} : so you've got at least 4 standard ways of converting ..
13:43:57 <{Arias}> thanks
13:44:24 <syntaxfree> speaking in terms of mathematics, anyway :~
13:44:33 <ski_> truncate x   | x <= 0 = ceiling x  | x >= 0 floor x    -- iirc
13:44:47 <ski_> s/floor/= floor/
13:45:06 <{Arias}> i'm trying to do a funcion to check if a number is prime :(
13:45:20 <{Arias}> i dont know how to do it
13:45:34 <ski_> mhm, why are you messing with Floats, and not just Int/Integer, then ?
13:45:49 <{Arias}> let's see
13:46:11 <{Arias}> i dont know how to make a ... bucle ?
13:46:19 <{Arias}> araujo ?
13:46:43 <{Arias}> sorry, i dont speak english very well :(
13:46:57 <{Arias}> well
13:47:09 <{Arias}> i'm trying to make a list of elements
13:47:09 <SamB> Arias: write a function 'factor :: Integral i => i -> [i]'
13:47:40 <{Arias}> from 2 to sqrt num: [2..sqrt num]
13:47:49 <ski_> ok
13:47:51 <{Arias}> an then apply a mod
13:47:58 <{Arias}> mod num (list element)
13:48:17 <{Arias}> [ y | y <- [2..floor (sqrt x)], mod x y == 0 ]
13:48:21 <{Arias}> something like this
13:48:26 <ski_> so,m you could use 'floor (sqrt (fromIntegral num))' i think ..
13:48:28 <{Arias}> and then check if the list is empty or not
13:48:44 <ski_> @type sqrt
13:48:45 <lambdabot> forall a. (Floating a) => a -> a
13:49:15 <SamB> Arias: look at RealFrac
13:49:17 <ski_> if you use 'sqrt' directly on 'num' you force it to be of type in 'Floating' ..
13:49:58 <SamB> it has a few methods with type RealFrac n, Integral i => n -> i
13:49:59 <{Arias}> with fromIntegral works fine :D
13:50:18 <ski_> ({Arias} : also, possibly you think it's more readable using 'x `mod` y' ?)
13:50:37 <{Arias}> yes
13:50:40 <SamB> oh, you are using floor already ;-)
13:50:52 <goron> How expensive would it to put *all* hierarchical libraries in scope?
13:50:57 <SamB> there are SO many classes to look through when you want to do something with Float or Double...
13:51:01 <goron> +be
13:51:09 <SamB> goron: you can't pay the price!
13:51:24 <SamB> you would need to have more than one of the same identifier to give out!
13:51:41 <ski_> (possibly imported qualified, would be nice ..)
13:51:45 <{Arias}> thanks at all
13:51:50 <goron> ski_: That's what I meant.
13:51:56 <{Arias}> :)
13:52:40 <goron> Or maybe this is stuff that belongs in an IDE>
13:52:51 <{Arias}> isPrime x = [ y | y <- [2..floor (sqrt (fromIntegral x))], mod x y == 0 ] == []
13:52:53 <goron> I think it it.
13:52:56 <goron> it is
13:53:04 <{Arias}> is there a best way to check if a number is prime?
13:53:31 <ski_> use 'null ...' instead of '... == []'
13:54:03 <sethk> {Arias}, actually that is a very difficult problem.  For your purposes just use a calculation method
13:54:16 <sethk> {Arias}, the way to determine whether a number is prime was only discovered a few years ago
13:54:22 <sethk> well, the way to do it other than brute force
13:54:31 <{Arias}> jeje
13:54:32 <ski_> possibly you could also use 'not (any (\y -> x `mod` y == 0) [...])' instead ..
13:54:35 <sethk> {Arias}, before that they used probabalistic methods
13:54:36 <{Arias}> i'm just starting with haskell
13:55:11 <{Arias}> is a functo to practice
13:55:22 <{Arias}> is a function to practice
13:55:27 <ski_> (sethk : do you have any nice link ? :)
13:55:44 <sethk> ski_, for which?
13:55:52 <ski_> primality test
13:55:59 <{Arias}> and i dont know if this is the best way to do it
13:56:03 <{Arias}> :P
13:56:11 <sethk> ski_, let me look, I'm not sure if I kept it.
13:56:21 <sethk> ski_, shouldn't be hard to track down, though
13:56:24 <{Arias}> excuse my english :(
13:56:46 <ski_> {Arias} : well .. actually using 'all (\y -> x `mod` y /= 0) [...]' could be nicer ..
13:56:58 <ski_> {Arias} : np
13:57:31 <syntaxfree> @fact-set haskell Haskell is the language of choice for discriminating hackers.
13:57:32 <lambdabot> Fact recorded.
13:58:33 <stepcut> heh
13:58:41 <thedward> @fact haskell
13:58:42 <lambdabot> haskell: Haskell is the language of choice for discriminating
13:58:42 <lambdabot> hackers..
13:59:02 <syntaxfree> before, it said "I know nothing about Haskell".
13:59:04 <{Arias}> thanks ski_ :)
13:59:43 <ski_> ({Arias} : of course, using these two latter suggstions, you don't need a list comprehension)
14:00:26 <{Arias}> why?
14:02:09 <ski_> [y | y <- [...]] = [...]
14:02:32 <{Arias}> ah, yes :)
14:02:59 <{Arias}> thanks :)
14:03:12 <ski_> (actually, that rule is in some way similar to eta- reduction/expansion ..)
14:03:44 <syntaxfree> @pl f a b x y = a*x + b*y
14:03:45 <lambdabot> f = (. (*)) . flip . (((.) . (+)) .) . (*)
14:04:12 <syntaxfree> @pl f a b c x y z = a*x+b*y+c*z
14:04:14 <lambdabot> f = flip flip (*) . (((.) . flip . ((flip . (((.) . (+)) .)) .)) .) .
14:04:14 <lambdabot> (. (*)) . flip . (((.) . (+)) .) . (*)
14:04:33 * ski_ chuckles
14:04:36 <{Arias}> xD
14:04:46 <{Arias}> i go to bed
14:04:53 <{Arias}> thanks
14:04:54 <palomer> god my program would run _so_ much faster if I was running haskell
14:05:01 * palomer kicks C++
14:05:11 <{Arias}> bye
14:05:33 <syntaxfree> huh?
14:12:19 <sethk> palomer, it could be worse, it could be written in assembly language.  then it would be really slow.
14:15:58 <sethk> hey, would you guys finish hIDE, already?  I'm getting tired of the emacs haskell mode.
14:16:00 <b0gg1e> hi, is there any fuzzy logic lib for haskell?
14:16:08 <sethk> it won't let me put in blank lines without losing my indentation
14:18:20 <SamB> sethk: finish?
14:18:28 <SamB> it doesn't even WORK yet!
14:18:33 <sethk> SamB, Details, details.
14:18:38 <syntaxfree> I've been thinking of writing one.
14:18:47 <sethk> syntaxfree, an emacs mode?
14:18:48 <syntaxfree> At least generalized modus ponens.
14:18:56 <syntaxfree> no, writing a fuzzy logic lib.
14:19:04 <SamB> there would seem to be at least three haskell modes...
14:19:04 <sethk> I know, I was joking
14:19:19 <sethk> SamB, well, two indentation options
14:19:25 <sethk> SamB, maybe I'll go back to simple.
14:19:45 <syntaxfree> b0gg1e: let's make it an open source project.
14:19:53 <syntaxfree> you in? ;-)
14:20:03 <SamB> sethk: no, I mean I think I saw three different files named haskell-mode.el in fptools...
14:20:03 <b0gg1e> hmm already have some code :-)
14:20:08 <b0gg1e> i'm in.
14:20:17 <b0gg1e> but i'm still reading about it.
14:20:25 <sethk> SamB, there are two files with indent in the name
14:20:58 <sethk> haskell-simple-indent.el and haskell-indent.el
14:21:11 <SamB> note that the files I refer to are in different directories...
14:21:20 <b0gg1e> actually at work i have been interfacing a c-written neuro fuzzy inference engine to java weke via JNI, and that was such a pain, that i though it out to be possible to do this more easily...
14:21:46 <b0gg1e> (the c code was quite a mess)
14:21:52 <SamB> oh yeah, way easier
14:21:59 <SamB> JNI sounds quite scary
14:22:10 <sethk> SamB, that sounds like an older and newer version, perhaps.
14:22:26 <SamB> sethk: an older and two newer, if I'm not mistaken
14:22:35 <SamB> two diverging newer
14:22:52 <sethk> SamB, something can't be newer, unless something else is older.  :)
14:23:52 <SamB> sethk: yes, there is one older and two newer
14:24:07 <b0gg1e> syntaxfree, so how should we call it?
14:28:43 <syntaxfree> Fuzzkykell?
14:29:01 <b0gg1e> that's nice. i like it.
14:29:02 <syntaxfree> Hasfuzz?
14:29:10 <syntaxfree> Fuzzyball?
14:29:11 <b0gg1e> hasfuzz.. LOL
14:29:15 <syntaxfree> March to Fuzz?
14:29:18 <ski_> Fazzkell
14:29:36 <syntaxfree> The Dance of Just Ordinary People (TDOJOP)
14:29:46 <SyntaxNinja> @wiki
14:29:47 <lambdabot> http://www.haskell.org/hawiki/
14:29:56 <b0gg1e> The great lambda fuzzyficator?
14:29:57 <syntaxfree> why did you do that?
14:30:05 <syntaxfree> Fuzzmbda.
14:30:09 <b0gg1e> lambdafuzz...
14:31:21 <syntaxfree> we could draw some attention to it by calling it something like "Haskell Erotica".
14:31:30 <syntaxfree> it did work for Madonna.
14:31:52 <b0gg1e> Im still new to fuzzy logic, if i understand correctly, in order to allow defuzzyfication of arbitrary fuzzy number sets one would have to implement numeric integration.
14:32:21 <b0gg1e> that would be usefull to have in its own right.
14:32:23 <syntaxfree> ohh. I don't know anything about fuzzy number sets.
14:32:30 <aFlag> haskell erotica?
14:32:30 <b0gg1e> haha.
14:32:34 <aFlag> cool
14:32:38 <syntaxfree> My fuzzy stuff stops at the generalized modus ponens and fuzzy control.
14:32:45 <aFlag> i like sex, i'll probably like that
14:33:04 <b0gg1e> we ought to have a fuzzy logic monad (...warm fuzzy thin)
14:33:38 <ski_> (there are random monads, i think)
14:33:41 <aFlag> i have haskell fantasies during sex
14:33:58 <syntaxfree> :)
14:35:17 <b0gg1e> she: you are always looking after the other monads
14:37:45 <sethk> aFlag, you have sex?
14:37:53 <sethk> aFlag, what's it like?
14:38:38 <syntaxfree> the word hasn't caught on that geekery != money anymore.
14:38:39 <aFlag> it's like an I/O monad
14:38:57 <aFlag> but it's a bit less fun
14:39:40 <aFlag> certanly less fun than pure functions, that's for sure
14:46:42 <syntaxfree> sex is a great way to develop intimacy in a couple.
14:48:20 <dcoutts> my I stumbled into the conversation at an interesting moment
14:48:39 <sethk> that's what happens when you let people like me into the channel
14:49:19 <ski_> (sethk : have you seen #haskell-blah ?)
14:50:12 <sethk> ski_, not yet.  should I  ?  :)
14:50:30 <ski_> (at least you could check it's topic ..)
14:50:36 <ski_> s/'//
14:50:58 <sethk> BRB
14:51:05 * dcoutts agrees with syntaxfree btw
14:51:32 <SyntaxNinja> yes, this conversation belongs on #haskell-blah
14:52:08 <Muad_Dib> people still do not seem to get the idea of #haskell-blah indeed
14:53:11 <SamB> most of them don't know it exists, probably...
14:54:05 <SyntaxNinja> it's not a problem, IMO. if a conversation belongs there, it gets pointed out, and the conversation goes there. eventually everyone will catch on.
15:07:04 <SyntaxNinja> Igloo: why have haddock and alex not been reuploaded? is there anything that should be holding it out of testing?
15:08:01 <Igloo> What's "it"?
15:08:52 <SyntaxNinja> haddock & alex
15:09:37 <stepcut> hrm, I think the wxFruits system might port somewhat cleanly to kde/qt
15:10:10 <SamB> wxFruits?
15:10:16 <SamB> is that what they call the Mac version?
15:10:33 <stepcut> :p
15:11:08 <stepcut> oh wait, its, wxFruit, no `s'
15:11:34 <Igloo> I'm a bit lost, but no, not really. I have a slight preference for the latest ghc to build everywhere first, but that doesn't look like happening particularly soon
15:12:11 <Igloo> s/no, not/nothing/
15:14:15 <Frederick> back
15:14:45 <SyntaxNinja> Igloo: OK. folks here would like to use alex & haddock w/ testing, so it would be nice :)
15:17:30 <Igloo> OK (AFAIK installing the testing versions should work, though)
15:19:28 <SyntaxNinja> you mean the unstable versions?
15:19:41 <Igloo> Ooops, yes
15:21:00 <SyntaxNinja> yeah, that's what I told him to do
15:34:54 <syntaxfree> #haskell-blah isn't in the topic.
15:34:59 <syntaxfree> it's easy to forget it existw.
15:44:15 <araujo> @index hGetContents
15:44:16 <lambdabot> System.IO
15:50:29 <Marios> hello, im tryin to write few modules that will check out other haskell files, can u suggest some relevant reading on this? thanx
15:50:53 <thedward> Marios: you mean like unit testing?
15:51:20 <Marios> somethin like tracing but want to make it as simple as possible
15:52:01 <thedward> have you looked at hat?
15:52:04 <thedward> (http://www.haskell.org/hat/)
15:52:36 <Marios> yeh yeh
15:53:40 <thedward> wanting to write your own thing?
15:54:05 <Marios> yes
15:54:21 <Marios> need to start with simple stuff and then ill see..
15:55:14 <thedward> alas, I wouldn't know where to start on actually coding up something like that
15:56:06 <Marios> not sure if u can do much by just writing modules using io handle and stuff
15:56:58 <Marios> hmm have any idea where to look, i had a look around but havent found much to help get started
16:03:20 <Cale> apparently there's a ghc-api module which exposes a bunch of GHC's parsing and typechecking stuff. I haven't really taken a close look at it
16:06:55 <Marios> thanx ill have a look
16:07:39 <yaarg> so haskell cms...
16:09:00 <SyntaxNinja> cms?
16:09:33 <yaarg> content management system
16:22:15 <sethk> Cale, I did a few functions with and without the state monad.
16:22:21 <sethk> Cale, now I have to decide.
16:22:40 <sethk> Cale, what was it we said the other day about eliminating the liftIO calls?
16:23:47 <sethk> Cale, do you remember?  You (or someone) had a suggestion about not using liftIO routinely
16:46:17 <syntaxfree> @pl fact x= product [1..x]
16:46:18 <lambdabot> fact = product . enumFromTo 1
16:49:19 <syntaxfree> @type enumFromTo
16:49:21 <lambdabot> forall a. (Enum a) => a -> a -> [a]
17:24:09 <conal> Question: what do people like using to quickly make a pretty printer for a data type of expressions with infix operator precedence?
17:31:29 <syntaxfree> @eval head (filter (\x -> x > 5) [1..])
17:31:36 <lambdabot> 6
17:32:54 <TheHunter> @find (>5) [1..]
17:32:56 <lambdabot> bzzt
17:33:01 <TheHunter> @eval find (>5) [1..]
17:33:03 <lambdabot> Just 6
17:36:35 <syntaxfree> @type find
17:36:36 <lambdabot> bzzt
17:36:56 <syntaxfree> what _is_ find and Just?
17:38:09 <syntaxfree> does #haskell have searchable logs somewhere?
17:40:05 <dons> see /topic
17:40:05 <ski_> http://tunes.org/~nef/logs/haskell ?  (as well as the meme one in the topic)
17:40:11 <dons> for logs, also http://tunes.org/~nef/logs/haskell/05.10.21
17:40:18 <dons> find is a list function
17:40:20 <dons> @type find
17:40:21 <ski_> @index find
17:40:21 <lambdabot> bzzt
17:40:21 <lambdabot> Data.List
17:40:29 <ski_> @type Data.List.find
17:40:30 <sethk> you'll find Just in the libraries index
17:40:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:40:32 <dons> Just is a data construuctor
17:40:33 <sethk> part of maybe
17:40:47 <dons> @eval Just 1
17:40:49 <lambdabot> Just 1
17:41:15 <dons> the Maybe type is a union of two constructors, `Just a' and Nothing
17:41:33 <dons> it's great for representing values that have some kind of empty value
17:41:39 <dons> where you would use NULLl in C
17:41:55 <stefanw> not so great: why does haddock use '-' instead of '.' to delimit hierarchical module names?? All my links into the documentation tree of the ghc library are broken :-((
17:42:20 <dons> ah, I think this is  a known bug in fact, stefan
17:42:45 <syntaxfree> thanks, everyone.
17:42:52 <sethk> dons, can you help me get past the compilation problem?  According to Simon Marlow the problem is a missing package and the error message is bogus
17:42:59 <sethk> dons, but I don't know which package is missing
17:43:05 <dons> ah! ok, I'll check my mail
17:43:14 <dons> sounds promising, sethk
17:43:28 <sethk> dons, can you tell me the packages that yi requires?
17:43:43 <sethk> dons, fortunately I don't have that many extras installed, so my list of packages is relatively short
17:43:55 <dons> base, mtl, plugins>=0.9.10, gtk>=0.9.9.6, sourceview
17:44:05 <dons> trying to think of anything else..
17:44:06 <dons> hmm
17:44:26 <sethk> I have those
17:44:38 <dons> let me try and build on another machine, with no packages, and see what happens.
17:44:42 <sethk> thanks
17:45:44 <dons> stefanw, you need a little sh/perl script to rename the files perhaps
17:46:02 <dons> so, sethk, you just pulled from scannedinavian.com?
17:46:16 <sethk> dons, early this morning, yes
17:46:22 <sethk> when we were talking
17:46:23 <dons> @localtimme sethk
17:46:36 <dons> oh, you mean *yesterday* ;)
17:46:43 <sethk> :)  right.  we are in the same TZ
17:47:12 <dons> we are?? or you're just in .au TZ for some weird reason :}
17:47:26 <sethk> dons, I though you were in EDT
17:47:31 <sethk> but I get confused easily
17:47:35 <sethk> @localtime dons
17:47:35 <dons> @localtime dons
17:47:39 <lambdabot> Local time for dons is Sat Oct 22 10:41:26 2005
17:47:39 <lambdabot> Local time for dons is Sat Oct 22 10:41:26 2005
17:47:49 <dons> it's a lovely sunny morning
17:47:52 <sethk> hm, confused again.  :)
17:47:58 <dons> @map
17:47:59 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
17:48:02 <sethk> _somebody_ here is in my time zone.  :)
17:48:24 <dons> check the map, several people are :)
17:48:35 <dons> ok, Setup.hs configure worked
17:48:43 <stefanw> dons: how should I change the filenames on the haskell.org server?
17:48:50 <sethk> dons, I meant someone in last night's conversation
17:48:57 <dons> oh, on the server! ok stefanw, too hard
17:49:21 <dons> bah, sethk, it builds for me. hmm
17:49:27 <dons> let me try unregistering packages
17:49:27 <stefanw> dons: do you know if they are going to change it back to '.'? I did not find a bugreport...
17:49:35 <sethk> dons, right, because you aren't missing the package  :)
17:49:40 <sethk> dons, it is supposed to build for you.
17:49:45 <dons> stefanw, ok. you should report it.
17:49:46 <Cale> sethk: Well, by "not using listIO routinely", we meant that it's usually best to provide an abstracted interface to the operations which you're going to perform. That is, you're carrying around that state for a reason -- probably not just so that you can "get" and "put" it, but because it enables you to perform some operations.
17:50:09 <dons> sethk, let me see if there's some lib i forgot to mention
17:50:18 <Cale> So the idea is to write those operations, and hide get and put.
17:50:30 <Cale> (as well as the representation of the state monad)
17:50:44 <dons> I wish ghc-pkg unregister took a list of args
17:50:44 <sethk> Cale, ok, so we don't eliminate them, we just use them only once for each operation
17:50:58 <dons> writing for loops is so tedious ;)
17:52:13 <Cale> sethk: yeah -- this also lets you ensure that your state never gets set to something which is impossible -- for instance, if you were writing an othello game, and your state was the board position, you would only allow changing the state through valid moves.
17:53:08 <Cale> It's fairly rare that any value at all would serve as a valid state.
17:53:30 <Cale> (or that any changes at all are valid changes to the state)
17:53:31 <dons> sethk, could you /msg the output of ghc-pkg list please?
17:53:41 <sethk> dons, ok, one second.
17:54:11 <sethk>     rts-1.0, base-1.0, haskell98-1.0, template-haskell-1.0, unix-1.0,
17:54:11 <sethk>     parsec-1.0, haskell-src-1.0, network-1.0, QuickCheck-1.0,
17:54:11 <sethk>     HUnit-1.1, mtl-1.0, fgl-5.2, X11-1.1, HGL-3.1, OpenGL-2.0, stm-1.0,
17:54:11 <sethk>     readline-1.0, (lang-1.0), (concurrent-1.0), (posix-1.0),
17:54:12 <sethk>     (util-1.0), (data-1.0), (text-1.0), (net-1.0), (hssource-1.0),
17:54:14 <sethk>     (glib-0.9.9), (gtk-0.9.9), (mogul-0.9.9), (glade-0.9.9),
17:54:16 <sethk>     (gconf-0.9.9), wxcore-0.9.4, wx-0.9.4, plugins-0.9.10,
17:54:18 <sethk>     (glib-0.9.9.5), (gtk-0.9.9.5), (mogul-0.9.9.5), (glade-0.9.9.5),
17:54:20 <sethk>     (gconf-0.9.9.5), Cabal-1.1.3, glib-0.9.9.6, cairo-0.9.9.6,
17:54:24 <sethk>     gtk-0.9.9.6, mogul-0.9.9.6, glade-0.9.9.6, gconf-0.9.9.6,
17:54:26 <sethk>     sourceview-0.9.9.6
17:54:28 <sethk> dons, I _think_ I sent it  :)
17:54:47 <dons> oops ;)
17:54:59 <dons> ok. hmm. let me see
17:54:59 <sethk> oops  ?
17:55:08 <shapr> dons: I crashed yiDE by typing too fast.
17:55:16 <dons> oh no, shapr too!
17:55:25 <dons> Cale has the same issue, but I can't do it on my box
17:55:46 <dons> shapr, can you find out what gtk and sourceview C libs you're using?
17:55:50 <shapr> sure
17:56:53 <shapr> gtksourceview 1.4.2-1 and gtk+ 2.8.3-1
17:57:14 <dons> are you using the very latest yi and hIDE codeE?
17:57:40 <dons> last patch should be Fri Oct 21 12:32:19 EST 2005
17:58:09 * shapr checks
17:59:03 <shapr> Yes, all is the latest.
17:59:17 <shapr> I pulled, built, and installed just before I tried yi.
17:59:35 <dons> ok.
18:00:34 <dons> sethk, ok, I can't reproduce it just by removing haskell libs
18:00:52 <dons> is it possible for you to install ghc 6.5?
18:01:03 <sethk> dons, sure.
18:01:04 <shapr> Oh, I actually showed up here to ask about subrepo importing. I want to import darcs Pull(pull) and Record(record) directly into FLM. Is there a sane way to have the darcs source in subrepo and still import it?
18:01:12 <sethk> dons, do I pull it from darcs, or is there a tarball?
18:01:16 <dons> oh, hang on sethk, it's easier for me to test with 6.4.1 first
18:02:13 <syntaxfree> let f = 1: 1: [if (odd x) then 3*x+1 else x/2 | x<-tail f] in f
18:02:25 <syntaxfree> @eval let f = 1: 1: [if (odd x) then 3*x+1 else x/2 | x<-tail f] in f
18:02:30 <lambdabot> Ambiguous type variable `a' in the constraints
18:02:41 <dons>    :: [Int]
18:02:57 <syntaxfree> I don't know where to place type declarations in a one-liner like that.
18:03:04 <dons> at the end
18:03:08 <shapr> You can inline them too, if you want.
18:03:09 <ski_> put a take, too
18:03:15 <dons> I think I'll change that error msg to "Add a type signature!"
18:03:26 <dons> ski_! good idea
18:03:29 <dons> @karma+ ski_
18:03:30 <lambdabot> ski_'s karma raised to 1.
18:03:49 <ski_> danke, herr dons
18:03:57 <dons> syntaxfree, make sure you write:  ... in take 10 f :: Int
18:04:05 <dons> syntaxfree, make sure you write:  ... in take 10 f :: [Int]
18:04:28 <dons> otherwise you will be noisy, and people will complain and frown
18:04:41 <syntaxfree> @eval let f = 1: 1: [if (odd x) then 3*x+1 else x/2 | x<-tail f] in take 11 f :: [Int]]
18:04:42 <lambdabot>  parse error on input `]'
18:05:02 <syntaxfree> @eval let f = 1: 13: [if (odd x) then 3*x+1 else x/2 | x<-tail f] in take 11 f :: [Int]
18:05:03 <lambdabot>  add an instance declaration for (Fractional Int)
18:05:03 <lambdabot>   In the result of a list comprehension: if (odd x) then (3 * x) + 1
18:05:03 <lambdabot> else x / 2
18:05:15 <dons> `div` perhaps ?
18:05:34 <dons> @type (/)
18:05:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:05:39 <dons> @type div
18:05:40 <lambdabot> forall a. (Integral a) => a -> a -> a
18:05:44 <ski_> @type odd
18:05:45 <lambdabot> forall a. (Integral a) => a -> Bool
18:06:25 <syntaxfree>  @eval let f = 1: 13: [if (odd x) then 3*x+1 else x `div` 2 | x<-tail f] in take 11 f :: [Int]
18:07:03 <dons> sethk, I'm suspicious that SimonM guessed too soon what the bug was, without looking at a log of the bug (which you should always attach to email bug reports, btw).
18:07:03 <ski_> (also, the parens in the test in the if-then-else are unnecessary)
18:07:07 <dons> wake up lambdabot!
18:07:19 <dons> @bot
18:07:20 <lambdabot> :)
18:07:23 <ski_> remove the initial space, perchance .. ?
18:07:33 <tony2> dons, does lamdaboot screen scrape google or use the api?
18:07:34 <dons> ah, yes  :)
18:07:45 <dons> for @google ?
18:08:02 <tony2> dons, yes
18:08:16 <dons> have a look at the src:
18:08:18 <dons> @versoin
18:08:19 <lambdabot> lambdabot 3p107, GHC 6.5 (OpenBSD i386)
18:08:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:08:21 <syntaxfree> @eval let f = 1: 13: [if (odd x) then 3*x+1 else x `div` 2 | x<-tail f] in take 11 f :: [Int]
18:08:23 <lambdabot> [1,13,40,20,10,5,16,8,4,2,1]
18:08:24 <dons> it's in Plugins/Search.hs
18:08:47 <syntaxfree> so how would you have a function play that game until it reaches 1?
18:09:05 <dons> I think it hits 'I'm feeling lucky" and checks the http redirection
18:09:27 <tony2> dons, I wan't aware it was publicly available. I should have guessed - it seems like everything Haskell is :)
18:09:40 <syntaxfree> @eval let f n= 1: n: [if (odd x) then 3*x+1 else x `div` 2 | x<-tail f] in take 11 (f 10) :: [Int]
18:09:42 <lambdabot> Couldn't match `[a]' against `a1 -> t'
18:09:43 <dons> yeah :) closed source is unusual and weird
18:09:49 <ski_> syntaxfree : hm, why do you put that initial '1', there ?
18:10:00 <dons> syntaxfree, you can also talk to lambdabot in a private channel!
18:10:08 <dons>  /msg lambdabot @bot
18:10:12 <ski_> syntaxfree : takeWhile (/= 1) ?
18:10:40 <syntaxfree> dons: apparently I can't.
18:10:52 <dons> oh, you need to register your nick to do privmsgs
18:10:54 <ski_> needs to register
18:10:58 <dons> sigh, freenode, why do you do this to me?
18:11:01 <syntaxfree> I'm registered.
18:11:15 <dons> have you identified?
18:11:18 <dons> since you last logged in?
18:11:30 <dons>  /msg NickServ IDENTIFY passwd
18:11:54 <dons> or maybe lambdabot hasn't . hmm...
18:12:10 <dons> no lambdabot is ok.
18:12:31 <Cale> syntaxfree: try it with 83 :)
18:17:09 <syntaxfree> 83?
18:17:24 <Cale> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in collatzLen 83
18:17:26 <lambdabot> 111
18:17:48 <syntaxfree> hmm.
18:17:55 <syntaxfree> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in collatzLen 82
18:17:56 <lambdabot> 111
18:18:13 <Cale> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in collatzLen 81
18:18:14 <lambdabot> 23
18:18:18 <Cale> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in collatzLen 84
18:18:20 <lambdabot> 10
18:18:28 <syntaxfree> easier to map it to [75..85]
18:18:38 <Cale> well, sure :)
18:18:50 <Cale> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in map collatzLen [75..85]
18:18:52 <lambdabot> [15,23,23,36,36,10,23,111,111,10,10]
18:19:22 <Cale> Interesting how those pairs with the same lengths occur. I wonder what's going on there.
18:19:33 <syntaxfree> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in map collatzLen [175..185]
18:19:36 <lambdabot> [81,19,32,32,32,19,19,94,94,19,45]
18:20:17 <Cale> in fact, there seem to be quite large runs where the sequences have the same length
18:26:01 <sethk> Cale, I've made some progress on my monad document.  I have a six line example of using the state monad and a six line example of using the StateT monad
18:26:09 <sethk> Cale, two of the lines are signature lines
18:27:01 <dons> ok sethk, I'm now attempting to build with 6.4.1, let's see what happens
18:27:11 <sethk> Cale, I am still working on a minimal example stringing a couple of functions together.
18:27:24 <sethk> Cale, each of my examples is only one function call
18:27:32 <sethk> dons, I'm waiting.  :)
18:29:43 <dons> oh, I need to update 6.4.1 cabal first
18:29:45 <Cale> sethk: one example that's usually used is tree-relabeling - write a function which takes a tree, and replaces the values in the leaves with 1..n where n is the number of leaves. This is easier to do as a state monad computation.
18:29:58 <sethk> Cale, yes, I have that example in Hudak
18:30:08 <sethk> Cale, but I'm going for absolute minimum
18:30:31 <sethk> Cale, mathematicians see the need for the bare minimum in everything except program examples   :)
18:30:48 <Cale> hehe
18:31:38 <Cale> I think the first vector space we saw in Linear Algebra 1 was the zero space: {0}, with addition and scalar multiplication defined in the only way possible :)
18:32:51 <Cale> (not a terribly useful example, but good to know that it's there :)
18:33:25 <Cale> I suppose that the corresponding computation would be something along the lines of  "return ()", but that's no fun :)
18:33:47 <Cale> inc is a good small example
18:34:24 <sethk> Cale, the minimal thing to do is provide a function that just returns a value
18:34:36 <sethk> Cale, that way everything you see is related to the monad
18:34:50 <syntaxfree> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in filter (=21) $ map collatzLen [1..200]
18:34:50 <Cale> yeah
18:34:51 <lambdabot>  parse error on input `='
18:34:52 <sethk> Cale, as I said, a perfectly common technique for everything except programs.
18:34:57 <Cale> ==
18:35:04 <syntaxfree> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in filter (==21) $ map collatzLen [1..200]
18:35:06 <lambdabot> [21,21,21,21,21,21,21]
18:35:08 <syntaxfree> Freudian slip.
18:35:21 <syntaxfree> I didn't intend that :-P
18:36:08 <sethk> if there is something freudian there, it sailed right over my head
18:36:47 <syntaxfree> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in fst $ filter (\(x,y)-> (fst (x,y)) ==21) $ [ (x,y)  | (x,y)<-zip (map collatzLen [1..200]) [1..200])
18:36:48 <lambdabot>  parse error on input `)'
18:36:58 <syntaxfree> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in fst $ filter (\(x,y)-> (fst (x,y)) ==21) $ [ (x,y)  | (x,y)<-zip (map collatzLen [1..200]) [1..200]]
18:36:59 <lambdabot> Couldn't match `(a, b)' against `[(Int, b1)]'
18:39:02 <Cale> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq in [ y | (x,y)<-zip (map collatzLen [1..200]) [1..200], x == 21]
18:39:12 <lambdabot> [18,19,112,116,117,120,122]
18:40:52 <sethk> Cale, look at this sequence, for example.
18:41:19 <sethk> Cale, I'll send you the doc, it's too much to type in and I'll make mistakes.  :)
18:41:26 <syntaxfree> there should be an "inverse function" that returns the list of values in the domain that yield a specific value.
18:42:10 <Cale> syntaxfree: you could write that, though it would take forever on every input
18:42:29 <sethk> Cale, when I tried the "as container" perspective, I found that the state monad contains a _function_
18:42:29 <syntaxfree> @let inverse f y  domain = map fst $ [(x,y) | (x,y) <-zip domain (map f domain)] in inverse (x+1) 2 [-10..10]
18:42:30 <lambdabot> Unknown command, try @listcommands.
18:42:43 <syntaxfree> @eval let inverse f y  domain = map fst $ [(x,y) | (x,y) <-zip domain (map f domain)] in inverse (x+1) 2 [-10..10]
18:42:45 <lambdabot>  Not in scope: `x'
18:42:58 <syntaxfree> let inverse f y  domain = map fst $ [(x,y) | (x,y) <-zip domain (map f domain)] in inverse (\x->x+1) 2 [-10..10]
18:43:23 <syntaxfree> @eval let inverse f y  domain = map fst $ [(x,y) | (x,y) <-zip domain (map f domain)] in inverse (\x->x+1) 2 [-10..10]
18:43:25 <lambdabot> [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]
18:43:33 <syntaxfree> no, no.
18:43:54 <sethk> syntaxfree, it's just doing what you told it to do.  :)
18:44:10 <Cale> let inverse domain f n = [m | m <- domain, f m == n] in inverse [-10..10] (\x->x+1) 2
18:44:10 <syntaxfree> @eval let inverse f y  domain = map fst $ filter (\x->f x == y) $  [(x,y) | (x,y) <-zip domain (map f domain)] in inverse (\x->x+1) 2 [-10..10]
18:44:10 <syntaxfree> 11:42 PM  lambdabot: [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]
18:44:12 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, b)
18:44:12 <lambdabot>   Expected type: a
18:44:12 <lambdabot>   Inferred type: (a, b)
18:44:19 <Cale> @eval let inverse domain f n = [m | m <- domain, f m == n] in inverse [-10..10] (\x->x+1) 2
18:44:21 <lambdabot> [1]
18:44:25 <syntaxfree> goody.
18:44:30 <syntaxfree> I forgot about conditions in the right side.
18:45:29 <Cale> A better name would be fibre.
18:45:45 <syntaxfree> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq; inverse domain f n = [m | m <- domain, f m == n]  in inverse collatzLen 19 [1..200]
18:45:46 <lambdabot>   Expecting a function type, but found `[a]'
18:45:46 <lambdabot>   Expected type: [a]
18:45:46 <lambdabot>   Inferred type: a1 -> Int
18:46:00 <syntaxfree> hmm. you changed argument order.
18:46:03 <Cale> yes
18:46:13 <syntaxfree> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq; inverse domain f n = [m | m <- domain, f m == n]  in inverse [1..200] collatzLen 19
18:46:15 <lambdabot> [28,29,30,176,180,181,184,186]
18:46:52 <Cale> We need a combination of gobby and ghci
18:49:02 <sethk> what's gobby?
18:49:25 <Cale> a multiplayer text editor
18:49:50 <sethk> Cale, does the loudest person win?
18:49:56 <Cale> heh
18:51:13 <lisppaste2> syntaxfree pasted "more collatzes (if I just had ghc around)" at http://paste.lisp.org/display/12739
18:54:57 <syntaxfree> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq; inverse domain f n = [m | m <- domain, f m == n]  in inverse [1..200] collatzLen 49
18:55:00 <lambdabot> []
18:55:06 <syntaxfree> hmmm.
18:55:50 <Cale> replace 200 with 2000 and you'll get a bunch around 500
18:56:40 <syntaxfree> @eval let collatz x = if odd x then 3*x+1 else x `div` 2; collatzSeq x = takeWhile (/= 1) (iterate collatz x) ++ [1]; collatzLen = length . collatzSeq; inverse domain f n = [m | m <- domain, f m == n]  in inverse [1..800] collatzLen 49
18:56:43 <CosmicRay> Igloo: ping
18:56:43 <lambdabot> [481,489,492,493,494,498,499,508,509,510,539]
18:56:52 <Igloo> yes?
18:57:21 <CosmicRay> Igloo: if I were to redesign hsql from scratch, and came up with a sane design, would you be interested in writing a backend or two for it?
18:58:03 <sethk> CosmicRay, I'm part way through translating my SQL engine into haskell.
18:58:09 <Igloo> I don't have time right now, but I might add an sqlite3 one at some point in the future if you don't
18:58:14 <CosmicRay> as I was trying to track down my segfault today, it appeared to me that hsql's cursors are fake.
18:58:19 <sethk> CosmicRay, so if you do any substantial work there, please let me know about it.
18:58:20 <CosmicRay> Igloo: I was hoping you would say that.
18:58:41 <CosmicRay> sethk: hmm, that sounds interesting.  so you have an actual sql database and sql implementation in haskell?
18:58:46 <Igloo> I think you are misunderstanding the extent of "right now", then  :-)
18:58:59 <sethk> CosmicRay, I'm in the process of porting it from C++ to haskell
18:59:08 <CosmicRay> Igloo: I read it as "maybe by 2007" ;-)
18:59:12 <sethk> CosmicRay, what's your opinion of the interface in hsql?
18:59:13 <CosmicRay> sethk: very slick.
18:59:31 <Igloo> Oh, OK
18:59:32 <CosmicRay> sethk: it has the right idea but has some design flaws.
18:59:42 <sethk> CosmicRay, I would like to hear about both.
18:59:51 <CosmicRay> Igloo: actually, I read it as "OK, so that's one less thing CosmicRay will have to do" ;-)
18:59:52 <sethk> CosmicRay, to learn from the flaws hopefully
19:00:02 <sethk> CosmicRay, can you drop me an email?  seth@cql.cfom
19:00:08 <sethk> CosmicRay, sorry, seth@cql.com
19:00:11 <CosmicRay> sethk: I'd be happy to talk about it here
19:00:16 <sethk> CosmicRay, ok
19:00:20 <CosmicRay> Igloo also has some opinions on it.
19:00:23 <sethk> CosmicRay, then I'm listening
19:00:48 <CosmicRay> so the first complaint is that it has no support for a database that can optimize repeated queries in some fashion.
19:01:07 <CosmicRay> may databases can do something like PREPARE "INSERT INTO foo VALUES (?, ?, ?)"
19:01:17 <CosmicRay> and then EXECUTE prepared-statement (1, 2, 3)
19:01:20 <sethk> CosmicRay, right, in fact, that's a requirement of the ODBC syntax spec
19:01:22 <CosmicRay> (pseudocode here)
19:01:30 <CosmicRay> hsql does not support that at all.
19:01:39 <sethk> CosmicRay, that won't do, then.
19:01:55 <sethk> CosmicRay, do you have the "right" syntax in mind for supporting it?
19:02:02 <CosmicRay> on a more technical note, hsql's design forces a single string escaping algorithm on all databases, when there are real differences in what needs to be done.
19:02:05 <sethk> CosmicRay, a query monad?
19:02:26 <sethk> CosmicRay, that won't do either; ANSI requires that the escapes are specifiable and modifiable
19:02:43 <metaperl> DBI works by delegating work like string escaping, etc to the DBD (database driver)
19:02:53 <metaperl> (DBI is the Perl Database Interface)
19:02:54 <CosmicRay> sethk: I think the simplest thing is to have another function or two in the IO monad -- a prepare and an "execute prepared" like most other DB layers have.
19:02:59 <CosmicRay> metaperl: python does too.
19:03:04 <CosmicRay> HSQL should.
19:03:08 <metaperl> CosmicRay: I see
19:03:12 <CosmicRay> most C APIs have that feature anyway.
19:03:16 <sethk> CosmicRay, ok
19:03:33 <CosmicRay> sethk: so the next complaint I just discovered today, after being suspicious for a long time.
19:03:40 <CosmicRay> it turns out that cursors in hsql are fake.
19:03:56 <sethk> CosmicRay, explain.
19:04:01 <CosmicRay> it actually reads the entire result of a select into memory, and just increments an index each time you request a row.
19:04:09 <CosmicRay> rather than reading one row at a time from the database, as you process it.
19:04:28 <sethk> CosmicRay, most implementations actually do something in the middle
19:04:40 <sethk> CosmicRay, read chunks of some number of rows
19:04:52 <sethk> CosmicRay, too much network i/o to do each line over the wire
19:05:00 <sethk> CosmicRay, but that's an optimization at the communications layer
19:05:01 <CosmicRay> well, too much latency anyway.
19:05:02 <CosmicRay> right
19:05:15 <CosmicRay> presumably these chunks aren't 300MB chunks ;-)
19:05:20 <sethk> CosmicRay, right.  :)
19:05:37 <sethk> CosmicRay, that simplifies concurrency control, but at a totally unacceptable cost
19:05:48 <sethk> CosmicRay, no real world application would tolerate that.
19:05:48 <CosmicRay> that one explained why my programs were using 300+MB ram.  I was beating myself up over that.
19:05:52 <CosmicRay> exactly.
19:06:21 <sethk> CosmicRay, I have a bit of an advantage since my customers beat up on me about my c++ version until it was acceptable
19:06:22 <CosmicRay> my final big annoyance is that it is only possible to access a column by name, not by number
19:06:46 <CosmicRay> which is annoying since different DB engines call the result column in this query by different names: select count(*) from table
19:06:46 <sethk> CosmicRay, by number is a requirement of both ANSI and ODBC
19:07:09 <CosmicRay> whenever I'm trying to write portable code, i *very* rarely use anything else.
19:07:17 <sethk> CosmicRay, well, if they followed the ANSI spec, that wouldn't be a problem, but you are correct, they don't follow  the spec
19:07:40 <sethk> CosmicRay, so far I've got everything you want just by supporting the entire C interface in haskell
19:07:53 <CosmicRay> sethk: well, to be fair, the ANSI spec applies to the DB itself, not to an abstraction layer in a programming language, right? ;-)
19:07:57 <CosmicRay> heh
19:08:13 <sethk> CosmicRay, the ANSI spec has requirements
19:08:23 <CosmicRay> the value of a thing like HSQL (or JDBC or DB-API or DBI or whatever) is, of course, to be able to swap out db layers easily
19:08:24 <sethk> CosmicRay, syntax wise only for C and such
19:08:32 <sethk> CosmicRay, but you have to support the functionality
19:08:34 <CosmicRay> Python's DB-API is really nice IMHO
19:08:45 <Igloo> You could select count(*) as mycount as a workaround
19:09:03 <sethk> CosmicRay, yes, but python's layer doesn't remove cursors and such.
19:09:04 <CosmicRay> Igloo: some DBs return that as MYCOUNT and others as mycount, and hsql's match is case-sensitive
19:09:10 <sethk> Igloo, actually, that's not ANSI syntax
19:09:17 <CosmicRay> sethk: what do you mean by "doesn't remove cursors"?
19:09:37 <sethk> CosmicRay, I mean you can have a layer that allows swapping of DB back ends without giving up features like real cursors
19:09:59 <CosmicRay> sethk: oh, right.  AFAIK none of these three that I mentioned have that limitation.
19:10:19 <sethk> CosmicRay, and, in fact, as you noted, the numerical references to columns (which are on the ugly side) are more portable
19:11:21 <sethk> CosmicRay, and the commercial engines are all over the map on case sensitivity and such
19:11:29 <CosmicRay> yeah
19:11:45 <CosmicRay> sethk: have you ever used unixODBC or are you speaking of odbc on windows only?
19:11:52 <sethk> CosmicRay, both
19:12:03 <sethk> CosmicRay, properly used there is nothing windows specific in ODBC
19:12:07 <CosmicRay> right.
19:12:41 <sethk> let me save this window before it scrolls off into the void
19:12:46 <syntaxfree> hey Cale.
19:12:54 <Cale> hey
19:12:56 <CosmicRay> sethk: what do you think -- with unixODBC (plus windows ODBC), is there value in having DB-specific bindings in layers like HSQL/JDBC/etc. anymore?  Or could we do just as well by writing an ODBC layer and leaving it as that?
19:13:01 <syntaxfree> this is a plot of the collatzLen function for x=1..10000
19:13:09 <syntaxfree> http://www.navarro.mus.br/od/coll.jpg
19:13:12 <syntaxfree> it is suggestive.
19:13:19 <sethk> CosmicRay, odbc has a lot of inefficiency built into the interface
19:13:31 <Cale> syntaxfree: yeah :)
19:13:45 <sethk> CosmicRay, in my experience it is much more common for people to use the proprietary interface
19:13:58 <Cale> syntaxfree: have you heard of integer differentiation?
19:14:00 <sethk> CosmicRay, that may not be smart, but it is what I see people actually doing
19:14:11 <CosmicRay> sethk: yeah, I knew it was more common, but I didn't know why really.  but that's what I've always done, because it's what's there.
19:14:29 <Cale> syntaxfree: p' = 1 if p is prime, and (xy)' = x'y + xy'
19:14:41 <Cale> Let me show you a plot of that which I made :)
19:14:47 <sethk> CosmicRay, there are a number of things in odbc that have to be done on a per column basis (one call for each column in a query, for example)
19:14:47 <tony2> Chaps, it would appear to me from your converation that DB support in Haskell is more than a bit lacking.
19:14:58 <ski_> Cale : what is that ?
19:14:58 <sethk> tony2, well, this week, perhaps.  :)
19:15:18 <tony2> which is the most used lib, HSQL?
19:15:19 <Cale> ski_: just defined it
19:15:21 <CosmicRay> sethk: ah.  that stinks.
19:15:24 <syntaxfree> Cale: what is integer differentiation?
19:15:31 <Cale> p' = 1 if p is prime, and (xy)' = x'y + xy'
19:15:39 <CosmicRay> tony2: HSQL, yes.  It is usable, but doesn't scale.
19:15:43 <sethk> CosmicRay, so you don't want only ODBC, although you certainly do want ODBC to hook into major tools
19:15:51 <CosmicRay> right
19:15:53 <ski_> Cale : hm, iirc such a function in number theory is called multiplicative, is that correct ?
19:16:34 <Cale> not quite -- I'd call it a derivation. It satisfies the Leibniz rule
19:16:43 <ski_> um, right
19:16:53 <ski_> yes
19:16:54 <Cale> I'd call a function multiplicative if f(xy) = f(x) f(y)
19:17:00 * ski_ can't think rn
19:17:15 * ski_ heads for bed
19:17:22 <ski_> night #haskell
19:17:27 <tony2> CosmicRay, right. But just due to lack of prepare statement and proper cursors? or more?
19:17:49 <syntaxfree> a homeomorphism is a function such that f(x+y) = f(x)+f(y) and f(xy) = f(x)f(y)
19:18:01 <CosmicRay> well, mainly to the things I mentioned.  those would be the performance scability ones.  the others would be portability scalability ones.
19:18:08 <Cale> http://vx.hn.org/autoshare/arithmetic-derivative.png
19:18:11 <syntaxfree> basic real analysis shows that the only homeomorphism in the R field is f(x)=x
19:18:18 <Cale> http://vx.hn.org/autoshare/arithderiv.2.png
19:18:21 <Cale> there are some plots
19:18:32 <CosmicRay> the prepare statement and proper cursors won't really hurt unless you are dealing with large chunks of data at once
19:18:35 <Cale> for the first million values
19:18:52 <Cale> and cut off arbitrarily at 200000
19:19:51 <Cale> ski_: night
19:20:12 <tony2> They shouldn't be too hard to add.
19:20:40 <tony2> well, I wouldn't have thought so anyway.
19:21:41 <sethk> tony2, well, nothing is hard, in principle.  :)
19:21:52 <sethk> tony2, but I'm working at the other end.
19:22:06 <tony2> I was impressed with fastCGI performance when playing with it today. I was going to start interfacing with DB's tomorrow, so this is quite relevent.
19:22:51 <tony2> sethk, working on the other end?
19:23:03 <sethk> tony2, the database server end, not the interface end
19:23:18 <tony2> sethk, ok.
19:23:24 <sethk> tony2, I mean that I haven't tried, so it might be more complicated than I'm aware
19:26:18 <CosmicRay> tony2: no, I don't think it is too hard to fix up.
19:26:27 <CosmicRay> tony2: it just takes a bit of time, since you have C bindings to think of.
19:26:50 <CosmicRay> it seems to me to be more of something that takes time, rather than something that requires brilliance ;-)
19:27:02 <tony2> CosmicRay, sure.
19:27:09 <sethk> CosmicRay, well, some of each.
19:27:33 <sethk> CosmicRay, I'm especially interested at the moment, though, in what I can add on the server side to improve the interface on the client side
19:27:35 <CosmicRay> well sure, but I think that the basic layout of the thing is pretty straightforward, since it's been done n times already in other languages
19:28:05 <tony2> CosmicRay, is it a h/direct binding?
19:28:17 <CosmicRay> no, it uses hsc2hs
19:28:45 <tony2> right, I'll stay away then.
19:28:47 <sethk> CosmicRay, yes, but there are some things (like lazy infinite data structures) unavailable in other languages that can be very interesting in the database world.
19:28:49 <CosmicRay> actually it doesn't need much beyond pure FFI
19:28:59 <CosmicRay> tony2: why?  hsc2hs is very straightforward, plus is widely supported.
19:29:05 <CosmicRay> sethk: indeed
19:29:37 <CosmicRay> sethk: with unsafeInterleaveIO, one could transform a cursor into a list without losing the feature of only reading a row when you need it
19:29:51 <tony2> ComsmicRay, well I only know h/direct & greencard.
19:29:59 <CosmicRay> tony2: hsc2hs is very easy.
19:30:07 <CosmicRay> imho the easiest.
19:30:36 <CosmicRay> http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
19:30:40 <sethk> CosmicRay, unsafe is, well, unsafe - that would cause major concurrency control problems.  I think, though, that we can take care of lazyness without resorting to it.
19:30:51 <tony2> CosmicRay, well I'll take a look then, I ditched my other project yesterday after a chat with Lemmih.
19:31:04 <sethk> tony2, take a look at hsc2hs, before you let it scare you away
19:31:10 <sethk> tony2, it isn't too terrible.
19:31:11 <CosmicRay> sethk: unsafe is just not guaranteed.  it is possible for a careful library designer to implement it in a safe and correct way.
19:31:33 <sethk> CosmicRay, ok, as I said I want to take advantage of laziness and I believe we can do so.
19:31:40 <CosmicRay> tony2: I've done several projects in hsc2hs, including a larger one (Python binding) and a small one (libmagic binding)
19:31:42 <sethk> CosmicRay, but great care is required to preserve serializability
19:31:42 <CosmicRay> yup
19:31:52 <CosmicRay> I was just saying, "and here is how you could do so"
19:31:54 <CosmicRay> yes
19:33:54 <sethk> CosmicRay, there are significant similarities in a suspended computation and a partially evaluated query.
19:34:17 <CosmicRay> hum!  that makes some sense.
19:34:18 <CosmicRay> interesting.
19:35:44 <sethk> CosmicRay, the more you think about it, the more interesting it gets.  :)
19:42:35 <dons> sethk! ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
19:42:38 <dons>         unknown exception
19:42:42 <dons> but it's fixed in 6.5
19:42:52 <dons> hmm. let's investigate further.
19:43:18 <sethk> dons, I'm glad I didn't send you on a wild goose chase
19:43:46 <dons> :)
19:44:26 <dons> but I don't think it's a package issue
19:45:33 <tony2> chaps, I'd like to interface my code to the google W.S api. What would you say is the best way of doing so? HAIFA/C binding/manual
19:45:54 <rep> W.S?
19:46:01 <sethk> dons, ok.  I was relaying that from Simon Marlow; he seemed to be saying that it was only produced by that.  Maybe we've found a new one.
19:46:02 <tony2> web service.
19:46:09 <sethk> dons, although, if it is fixed in 6.5, that isn't likely.
19:47:53 <dons> i don't appear to have any different packages between 6.4 and 6.5, but with 6.4 it crashes
19:48:14 <dons> it could be Cabal perhaps, so I'm checking with the same versions of Cabal on both compilers
19:48:24 <tony2> its a SOAP api.
19:49:19 <dons> possibly ask on haskell-cafe@haskell.org, tony2
19:49:36 <dons> or later in the day, when the rest of europe wakes up
19:49:44 <dons> some more people will be around, who know about these kind of things
19:50:17 <CosmicRay> I think there is a soap binding for haskell now
19:50:19 <sethk> dons, ok.  is 6.5 stable enough for me to be using for my development efforts?
19:50:34 <CosmicRay> I had to talk to a soap server and it wasn't too bad to roll a special purpose one using haxml and http
19:50:42 <tony2> dons, yeah no probs.
19:50:55 <dons> sethk, ah ha! ghc-6.5: ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):
19:50:58 <dons>         unknown exception
19:51:02 <dons> all I did was update Cabal
19:51:05 <sethk> dons, aha
19:51:15 <tony2> CosmicRay, thats what I was considering, but wanted to know if there was a general way.
19:51:19 <sethk> dons   that also might explain why everyone's not seeing it.
19:51:46 <CosmicRay> I *think* ther eis
19:51:49 <dons> yeah, with default cabal it builds ok. time to report on this bug in a bit more detail
19:53:44 <tony2> right, I'd best get to bed like the rest of Europe. Goodnight all.
19:54:10 <Lemmih> Morning guys.
19:56:50 <sethk> @localtime Lemmih
19:56:51 <lambdabot> Local time for Lemmih is Sat Oct 22 04:56:35 2005
19:57:09 * sethk is out of control with lambdabot commands   :)
20:16:16 <conal> Question: what do people like using to quickly make a pretty printer for a data type of expressions with infix operator precedence?
20:23:03 <sethk> conal, parsec would be the place to start
20:23:26 <sethk> conal, quick there means quick to do once you know how, not necessarily quick to learn.
20:23:41 <sethk> conal, although you may  be much smarter than I am and learn it quickly.  :)
20:24:50 <conal> sethk: does parsec do pretty-printing, as well as parsing??
20:25:31 <sethk> conal, not per se, no, but you can't print it unless you know what it is.  There is built in support for pretty printing of haskell expressions.
20:25:37 <sethk> conal, let me check that module name for you ...
20:26:10 <sethk> conal, Language.Haskell.Pretty
20:26:17 <sethk> conal, and the other things in Language.Haskell
20:27:01 <conal> sethk:  thanks.  I know there are pretty-printers out there, and it's not a big deal to wrap the precendence stuff around it.  tedious, though, and i figure lots of people have done that, and maybe there's something reusable.
20:27:14 <sethk> conal, there may well be, yes.
20:27:30 <sethk> conal, I haven't heard of anything recently except for haskell, but all that means is just that, I haven't heard.
20:27:40 <sethk> conal, I wouldn't be surprised to find some things.
20:27:46 <conal> thanks. :)
20:30:18 <conal> dons: googling around some, I see Phrac, with its pretty-printing code.  are you involved in that project?  do you know if anyone would mind if i bummed some code (with credit given)?
20:33:40 <sethk> conal, I'm sure dons will answer; but you don't have to ask around here.  Bumming with credit is always allowed.
20:33:56 <sethk> conal, usually even appreciated.
20:35:05 <dons> concal, yes, I'm involved :) so is stefanw
20:35:10 <dons> it's GPL, so go nuts!
20:35:12 <conal> sethk, thanks.  i like my code to get used also.
20:35:27 <dons> s/concal/conal :S
20:35:44 <conal> dons, thanks.  oh -- now i see in the code.  could have figured out myself.
20:35:53 <conal> dons, is phrac an ongoing project?  what's it about?
20:36:20 <conal> dons, (besides "an interpreter and compiler for the MinHS language")
20:36:28 <dons> yep, we're using it as our group research compiler
20:36:48 <conal> nifty.  what kind of questions are you exploring with it?
20:37:01 <dons> so it started as a toy for use in our type systems course, then stefanw used it to implement associated types
20:37:19 <dons> it's also used as a certifying compiler for a dependently typed IR, based on LF/Twelf
20:37:35 <conal> oh, cool!
20:37:42 <dons> hopefully next year it will be polished up into a plugin-based haskell compiler
20:37:49 <dons> (if we get funding...)
20:38:00 <conal> The REAMDE says "More documentation can be found in the doc/ directory."  I don't see a doc directory.  is there one?
20:38:13 <dons> oh, um, hmm. let me see
20:38:26 <Cale> @docs Text.PrettyPrint.HughesPJ
20:38:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text.PrettyPrint.HughesPJ.html
20:38:39 <Cale> huh, not working
20:38:40 <dons> ah, that's a left over comment from the student-assignment version of the compiler :)
20:39:09 <conal> aha.  thanks.  does it generate Haskell code as output?
20:39:32 <Cale> http://www.cs.uu.nl/~daan/download/pprint/pprint.html
20:39:32 <dons> no code gen in phrac atm, I think. it's just a type checker for an associated types system.
20:39:59 <conal> i see.
20:40:03 <dons> oh, maybe it does have  an interpreter though
20:40:27 <dons> it used to generate Haskell from Mini-Haskell
20:40:36 <Cale> conal: anyway, there are some pretty printing libraries in the hierarchical modules, and that's a link to a pretty printer by the same person as did Parsec
20:40:58 <dons> the phrac Ppr uses Text.PrettyPrint iirc
20:41:26 <conal> sure.  i saw daan's PPrint.  i like his stuff.   operator precedence is sort of a pain, and i thought someone might have packaged that up in a nicely reusable way.
20:41:54 <Cale> ah
20:42:09 <sethk> conal, sorry, I forgot that pretty print
20:42:16 <conal> sethk: no prob.
20:42:58 <sethk> conal, even has a good paper that goes with it.
20:47:36 <conal> i think dons's Pretty.Pretty class is what i'm looking for (http://www.cse.unsw.edu.au/~pls/repos/phrac).  it's a simple layering on top of Text.PrettyPrint to handle precedences.  The examples in ParseSyntax.hs are pretty simple to imitate.
20:49:23 <sethk> conal, I wasn't expressing a preference, just saying I shouldn't have forgotten it since once upon a time I read the paper.
20:49:58 <conal> sethk, which paper do you mean?
20:51:28 <sethk> http://www.cs.chalmers.se/~rjmh/Papers/pretty.ps
20:52:15 <sethk> conal, it's an interesting paper although as I said I'm not advocating one or another library.
20:52:40 <conal> sethk, got it.  thanks for the pointers.  btw: who are you and what are you into?
20:53:01 <sethk> conal, I'm nobody, just an engineer whose been writing code for, ugh, 32 years now
20:53:19 <sethk> conal, I'm working on a port of my database server to Haskell at the moment.
20:53:53 <conal> sethk:  oh -- nobody's a nobody!  that's a while to be coding.  wow!
20:54:08 <sethk> conal, you can learn a lot of bad habits in 32 years.  :)
20:54:35 <conal> sethk: sure can.  :)  what's your name, and where are you?
20:54:40 <Cale> http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf is a neat paper too
20:54:55 <dons> this Pretty class idea I stole from GHC, btw
20:55:22 <sethk> dons, software reuse, not stealing  :)
20:55:50 <conal> mind amplification
20:56:20 <dons> it's called Outputable in ghc
20:56:32 <dons> e.g, instance Outputable Cmm where ppr c = pprCmm c
20:56:52 <sethk> damn, prettier broke my cups driver.  :)
20:57:15 <sethk> dons, outputable doesn't occur in the index in the haddock generated docs
20:57:41 <dons> no, it's internal to ghc
20:57:48 <dons> to ghc the compiler, not the libraries
20:58:07 <dons> see for example $fptools/ghc/compiler/cmm
20:58:17 <dons>  /PprCmm.hs
20:58:23 <sethk> dons, k, thanks
20:58:38 <sethk> dons, that one I _may_ not actually get to. :)
20:58:44 <dons> cvs co ;)
20:58:51 <dons> actually, there's a www interface
20:58:56 <sethk> dons, making progress on our problem, or reporting it and giving up?
20:59:17 <dons> no no. i've basically sorted it now. just seeing if it is some weird plugins-related issue
20:59:29 <dons> as I can only get if while plugins is a dep on yi
20:59:50 <dons> but yes, i am in the process of reporting it
20:59:52 <sethk> dons, what's the cause?
21:00:19 <sethk> dons, unless that means you'll be typing for the next five minutes.  :)
21:00:36 <dons> I'm not sure what the cause is. but Cabal-1.1.4 triggers it
21:00:44 <dons> and panics are bad anyway
21:01:05 <sethk> dons, well, yes, hard to argue that panics are not bad ... :)
21:01:20 <dons> ah, so how to fix it. you need to use the Cabal that comes with ghc-6.5 atm.
21:01:28 <dons> and you're using 1.1.3?
21:02:09 <sethk> dons, I downloaded it and built it yesterday, from darcs
21:02:15 <sethk> let me see ...
21:02:31 <sethk> 1.1.3, yes
21:02:55 <dons> if I unregister Cabal-1.1.4, and revert to Cabal-1.0 that comes with ghc 6.5, everything works
21:02:59 <dons> ok, time to report
21:03:12 <sethk> dons, should I use 6.5 for my development?
21:03:25 <sethk> dons, obviously you are using it, it's more or less stable?
21:03:51 <dons> yeah, it's stable usually. though I note it was broken in the last couple of nights
21:04:05 <sethk> if I say file/print in kghostview, do I get a dialog to choose pages or the whole thing ?
21:04:09 <dons> it only fails 27/~4k regress tests though, so that's stable
21:04:33 <sethk> dons, ok.  I'll get it.
21:15:42 <dons> sethk, is the plugins package hidden in when you do a : ghc-pkg list ?
21:15:50 <dons> i.e wrapped in: ( )
21:20:51 <luqui> hasktags++
21:22:14 <sethk> dons, how do I test that?
21:23:57 <sethk> dons, it's not shown in parens on list.
21:24:03 <dons> $ ghc-pkg list | grep plugins
21:24:07 <sethk> dons, sorry, I didn't read line2
21:24:14 <dons> ok. doesn't change the bug anyway
21:24:17 <sethk>     (gconf-0.9.9), wxcore-0.9.4, wx-0.9.4, plugins-0.9.10,
21:24:33 <dons> ok, sent my further info on the bug
21:24:55 <sethk> dons, what's the gist of it, if it isn't too much to type on a line or two
21:25:15 <dons> oh nice, microsoft.com rejected my bug report as spam :/
21:25:44 <Lemmih> What bug?
21:25:46 <dons> so *that's* why windows sucks so much.. all the bug reports go to /dev/null!
21:26:10 <sethk> dons, well, now that we've tracked that down.
21:26:14 <dons> Lemmih, yi/cabal-triggerred ghc panic
21:26:30 <sethk> dons, what could possibly cause it to make that decision?
21:26:45 <sethk> dons, did you mention $14,000,000 and Algeria or something?
21:27:21 <dons> don't think so. maybe "hIDE Rulz, VisualStudio Blowz" perhaps, but other than that...
21:27:36 <dons> hehe
21:35:13 <sethk> dons, M$ never wrote anything smart enough to bounce that.
21:37:01 <Cale> http://www.microsoft.com/athome/security/children/kidtalk.mspx
21:38:06 <Cale> Non-alphabet characters can be used to replace the letters they resemble. For example, "5" or even "$" can replace the letter S.
21:39:28 <dons> @elite Non-alphabet characters can be used to replace the letters they resemble
21:39:30 <lambdabot> nOn-a1fA83+ (h4rACt3Rz CaN 8e us3d TO rep|aC3 T|-|3 |E7t3rs They RE$
21:39:30 <lambdabot> EmB|e
21:39:54 <dons> it should be called @leet though perhaps
21:40:32 <tizoc> dons, or @l33t
21:40:55 <dons> @elite leet elite leet leet
21:40:55 <Cale> @arr
21:40:55 <lambdabot> |Ee+ 1337 le3+ 1EE+
21:40:56 <lambdabot> I want me grog!
21:41:04 <Cale> @elite I want me grog!
21:41:05 <lambdabot> i waNT me 9ROG!
21:41:22 <Cale> @arr
21:41:24 <lambdabot> I want me grog!
21:41:25 <Cale> @arr
21:41:26 <lambdabot> Avast!
21:41:33 <Cale> @elite Avast!
21:41:34 <lambdabot> avA57!
21:41:34 <tizoc> @elite haskell
21:41:35 <lambdabot> |-|askeL1
21:43:14 <Cale> heh, they also have a page about griefers
21:53:01 <sethk> dons, you want me to email it for you?
21:54:07 <sethk> griefers?
21:54:10 <sethk> what's that?
21:54:25 <xerox> 'morning!
21:54:33 <Cale> morning xerox!
21:54:39 <Cale> http://www.microsoft.com/athome/security/children/griefers.mspx
21:55:18 <Cale> People who play multiplayer games in an unsporting fashion, basically.
21:55:43 <dons> sethk, mail what to me, sorry?
21:55:56 <sethk> dons, I meant mail in the bug report, if it is rejecting yours'
21:56:09 <dons> no no, it got though to everyone 'cept SimonM's local addr
21:56:21 <Cale> dons: did you want the messages associated with the typing-too-fast crashes?
21:56:25 <sethk> Cale, we had one of those here the other night
21:56:44 <dons> Cale, yep, if you can send the log to me, that would help
21:57:47 <dons> huh, ForeignPtrs are around 50x faster in ghc 6.5 than 6.4.x
21:57:58 <Cale> cool
21:58:16 <sethk> dons, how did that happen?
21:58:18 <Cale> I wonder what was done with them
21:58:26 <sethk> have to look at the source.
21:58:33 <sethk> must have been doing everything twice.  :)
21:59:19 <dons> check the (longish) thread on haskell-cafe@
22:14:14 <dons> Cancun under 8m of water? huh.
22:53:18 <sethk> Cale, dons, whoever is here, feel like discussing a design question with me, on my database server?
22:53:43 <sethk> I'm about to make an irrevocable design decision.
22:53:52 <sethk> which means that if I change my mind it will be a lot of work.  :)
22:54:38 <sethk> there are multiple users.  In the current implementation, there are server threads and then a thread for each client
22:54:51 <sethk> I will probably keep that structure
22:55:04 <sethk> so a thread represents a client.
22:55:32 <sethk> each client has substantial state information
22:56:00 <sethk> there are representations of cursors (which are essentially queries)
22:56:19 <sethk> there are representation of prepared statements (similar, some different details, to cursors)
22:56:38 <sethk> there is a large amount of data collected and maintained for concurrency control
22:57:14 <sethk> clearly the program does lots and lots of I/O.  While the "smarts" are in the query processing, the mechanics are more in the I/O area
22:57:27 <sethk> so:
22:58:10 <sethk> do I run IO throughout the code using something like StateT that will allow the state data to coexist with IO
22:58:55 <sethk> do I write my code with a State (rather than StateT) monad, and then make calls that indirectly get me back "into" the IO monad.
22:59:11 <sethk> that is, I have code paths in IO, I have code paths in State
22:59:12 <sethk> or
22:59:23 <sethk> I use StateT and make IO and State coexist.
23:00:54 <sethk> the concurrency control algorithm is threaded throughout the other code.  It has many things that cross threads such as deadlock detection, one layer of the transaction processing subsystem.
23:01:04 <sethk>  
23:01:14 <sethk> What I need to do is to draw some diagrams.
23:01:28 <sethk> give some specificity to this vague explanation,
23:01:41 <sethk> and be more organized  :)
23:01:55 <sethk> I'll work on that and you'll hear from me again
23:02:03 * sethk watches everyone frantically doing  /ignore
23:03:09 <Lemmih> (:
23:03:31 <sethk> I'm horribly slow drawing diagrams, but it won't make any sense to anyone else until I do.
23:03:49 <sethk> too much stuff sitting in my brain thinking "this is too obvious to say."  :)
23:03:58 <sethk> when of  course it isn't the least bit obvious.
23:24:18 <basti_> are clean's "unique" values linear types?
