00:01:15 * ski thought the Empty type was a zero object
00:01:32 <Pseudonym> I thought so too.
00:01:33 <int-e> ski: in a category of sets with a distinguished element?
00:01:37 <Pseudonym> 0 * A = 0
00:01:45 <Pseudonym> 1 * A = A
00:01:53 <Pseudonym> So 1 is (), 0 is the empty type.
00:01:59 <ski> int-e : _|_ being the global point, yes
00:02:27 <int-e> uhm. actually I agree.
00:02:35 * int-e wonders why he's trying to argue.
00:03:34 <Pseudonym> Because you paid for the full half hour.
00:06:32 <skew> which is supposed to be terminal, and which is initial?
00:06:56 <int-e> 1 is terminal, 0 initial.
00:07:01 <Pseudonym> Nytol!
00:07:19 <skew> Isn't the empty type terminal and initial?
00:07:40 <int-e> no, because there is no morphism from an arbitrary type to the empty type
00:07:51 <skew> I thought that was undefined
00:07:57 <int-e> hmm.
00:08:00 <skew> if you are counting bottom
00:08:09 <int-e> if you do that, then yes. right
00:08:52 <skew> I don't quite see how unboxed types fit in
00:09:36 <skew> a function into an unboxed type is allowed not to terminate, but I think the semantics say that unboxed types are unlifted domains
00:09:40 <int-e> they don't.
00:12:43 <Cale`> sorry, did you get that before I was disconnected?
00:13:11 <int-e> [08:53:26] <Cale> oh, sorry, that isn't an initial object due to _|_
00:13:21 <int-e> is the last one I saw
00:13:54 <Cale`> what the...
00:13:56 <Cale`> really unstable net connection
00:14:14 <Cale> f,g :: Empty -> Int
00:14:14 <Cale> f = const 0
00:14:16 <Cale> g = const 1
00:14:37 <Cale> Functions aren't required to carry _|_ to _|_
00:15:22 <int-e> ah! thanks.
00:15:52 <ski> right
00:23:39 <boegel> yo Itkovian
00:24:45 <Itkovian> boegel.
00:24:57 <boegel> does anybody know where I can check for error messages regarding a php page connecting to a mysql server ?
00:25:28 <cjs_> Apache error log.
00:25:45 <boegel> cjs_: where can I find it (on a server, not my machine)
00:31:47 <C-Keen> moin.
00:33:36 <boegel> yo C-Keen
00:34:01 <C-Keen> hi boegel
00:35:37 <cjs_> It could be anywhere. You need to find the httpd.conf file that your apache is using, which may or may not be the one in /etc/httpd.conf. If you want more help with this, I can provide a bit, but we should probably start a separate channel.
00:35:56 <cjs_> (I think it's *extremely* annoying that non-registered users can't /msg.)
00:37:20 <JohnMeacham> Does anyone know if the source code to the strictness analyser via HORN constraints is available online anywhere?
00:44:15 <boegel> cjs_: thanks, but I managed to find the problem using the mysql_error() function in combination with die(..,..)
00:44:31 <boegel> cjs_: so just register ?
00:49:55 * boegel pokes Itkovian 
00:50:00 <Itkovian> yeah yeah
00:50:02 <Itkovian> busy busy
00:57:01 <cjs_> Someone's already registered cjs. I've never thought it's worth the hassle to contact admins, etc. etc.
00:58:47 <JohnMeacham> Full names are better anyway :)
00:59:27 <metaperl> For some reason, my subString implementation is failing: http://rafb.net/paste/results/jAhaFx87.html
01:00:26 <boegel> cjs_: then just register cjs_
01:03:03 <cjs_> Already registered. Let's just drop this.
01:05:02 <boegel> metaperl: "hi" is no prefix of "ohi there", thus False
01:05:28 <boegel> the problem is you have no guard on the first declaration of subString
01:05:48 <boegel> so that works, and it just checks the result for the prefix function, which is False
01:05:49 <metaperl> oh!
01:05:50 <boegel> y0 shapr
01:05:53 <shapr> y0
01:05:56 <metaperl> boegel: thanks
01:06:04 <shapr> This web framework thingy is sounding really good.
01:06:14 <boegel> metaperl: np :)
01:06:25 <Speck> web framework thingy?
01:06:27 <Speck> I'm interested!
01:06:32 * boegel hands out sweets to everyone
01:06:45 * Muad_Dib takes one, then runs off to uni
01:06:51 <shapr> Speck: er, look at the logs a few days back, poetix and I talked about it.
01:07:10 <ProfTeggy> metaperl, your prefix function is not as simple as it could be
01:07:12 <Speck> hmm... "a fre days"?
01:07:14 <Speck> *fre
01:07:18 <Speck> **few
01:07:54 <Cale> metaperl: put more specific cases of your function first
01:07:59 <shapr> Speck: Basically, the last time I was here. I think I also wrote about it on my blog.
01:08:28 <nibro> shapr: how about this one? :)
01:08:29 <nibro> http://www.cs.chalmers.se/~bringert/wiki/WebAppsFramework
01:08:46 * ProfTeggy feels very lousy because he doesn't run a blog.
01:08:49 <shapr> I want to build a Haskell Plone via Data.Graph with Haskell2Xml instances at each node.
01:08:52 <Speck> sep. 30 according to your blog
01:09:06 <metaperl> ok it works but I am getting a warning about overlapped pattern instances: http://rafb.net/paste/results/6GbZxZ26.html
01:09:06 <shapr> ProfTeggy: I only run a blog to remind myself of the stuff I know.
01:09:23 <Speck> shapr: using hsp at all?
01:10:31 <shapr> nibro: That page is just resources that could be combined, I think I've found a workable coherent Haskell-esque idea.
01:10:57 <shapr> I'm not sure though, I need to whip up some prototypes.
01:11:00 <nibro> shapr: checked your blog... HSP also has a typeclass IsXMLs, like the ShowXML one from HaXml :)
01:11:32 <nibro> that's the whole idea about programming in HSP, that you should have a high-level representation that could then be generated back down to XML
01:11:57 <shapr> Cool
01:12:04 <Speck> HSP is really cool... I just read the paper from the acm portal
01:12:20 <shapr> In that case, maybe I'll use HSP.
01:12:53 <shapr> I need to investigate Oleg's ZipperFS though... anyone know if the paper or source is available?
01:13:24 <Heffalump> shapr: do you know off the top of your head if the darcs wiki supports LaTeX?
01:13:34 <nibro> shapr: I don't think there is a paper, it was just a tool demo (thrown in because another author couldn't come)
01:14:01 <nibro> Speck: glad you like it :)
01:15:18 <shapr> Heffalump: I do not know. Look at the SystemInfo macro
01:15:27 <Speck> nibro: the forum example you had in the paper, is that running anywhere?
01:16:03 <metaperl> nibro: Haskell Server Pages link is broken there
01:16:21 <nibro> unfortunately not, lots of stuff in the paper that has never been implemented for real
01:16:27 <nibro> metaperl, which link?
01:18:45 <metaperl> nibro: http://www.cs.chalmers.se/~d00nibro/thesis.pdf
01:19:01 <Speck> is hsp available in a cabal package?
01:19:57 <nibro> Speck: yes
01:20:22 <Speck> excellent, let's see if I can get it built on OS X
01:20:26 <nibro> metaperl: http://www.cs.chalmers.se/~d00nibro/hsp/thesis.pdf
01:20:45 <nibro> where did you find that link?
01:21:37 <shapr> I wish for more significant names for papers and theses. I have a very large number of files named {thesis,paper}.{pdf,ps}.
01:22:06 <shapr> Better than being on the other side of China's firewall though :-)
01:23:36 <Speck> you can get around it with a proxy
01:23:44 <Speck> that's what I did to view blogs when I was there
01:24:36 <metaperl> shapr: nibro: this is my favorite web app builder for Perl. I have pasted the main subroutine. I can explain it a bit: http://rafb.net/paste/results/jbIX6n71.html
01:25:20 <shapr> metaperl: That's just cut apart into stages, right?
01:25:44 <shapr> Neat setup
01:26:51 <shapr> prototype, app (specialization?), get hold of yourself...
01:26:58 <shapr> Then some sort of CPS calls?
01:27:05 <nibro> Speck: sorry for the short answer, the repo is at http://www.cs.chalmers.se/~d00nibro/hsp
01:27:28 <metaperl> nibro: at the first link you pasted
01:27:48 <Speck> nibro: it's ok, I have to figure out the whole cabal thing in the first place. I've been reading about haskell a lot, but I haven't really built anything with it.
01:27:48 <nibro> metaperl: ah, thanks, will update it
01:28:22 <shapr> metaperl: Looks like a lot of explicit continuation passing style code.
01:28:33 <metaperl> shapr: it allows each page to focus on it's specifics and allows superclasses to focus on things applicable across pages
01:28:38 <metaperl> it works well...
01:28:43 * nibro puts on containment clothing and jumps into Perl code...
01:28:44 <metaperl> it is object-oriented though
01:29:08 <metaperl> each page usually just has a render method and engine method
01:29:19 <metaperl> does dispatch make sense to you?
01:29:26 <metaperl> how about respond?
01:29:33 <metaperl> render should make sense
01:29:57 <Speck> where do people normally install haskell libraries in their filesystem?
01:30:18 <shapr> I have a vague idea about respond, but I'm unsure about dispatch.
01:31:45 <shapr> Anyway, my idea of a Haskell-esque webapp server involves being able to statically check the entire website, including checking all of the possible resulting xml against DTDs.
01:32:04 <Speck> I'd go with schemas
01:32:06 <Speck> or something similar
01:32:28 <metaperl> dispatch means you look at the incoming CGI data, cookie info, what have you and you dispatch to a particular page...
01:32:28 <nibro> Speck: /usr/local ?
01:33:19 <metaperl> for example, /url?mode=signin   -- then you can dispatch to a sign-in based on the CGI query parameter
01:33:26 <Speck> nibro: if I install a library with /usr/local (assuming ghc is installed there), where will it put the actual installed files? (say for example, with hsp)
01:33:58 <metaperl> for /url?mode=list  -- then dispatch to a list page based on cgi mode parameter
01:34:15 <metaperl> so basically ahve a dispatch method which passed control to a particular page
01:34:28 <nibro> the library files will go whereever ghc wants them to go, for instance /usr/local/lib/ and /usr/local/include if ghc is in /usr/local
01:34:38 <Speck> I see... intelligent
01:35:03 <nibro> if installing hspr, the binaries would end up in /usr/local/bin and some other stuff in /usr/local/etc
01:35:05 <metaperl> respond is what that page does: it responds with a page that will handle the render phase... e.g. Page.Signin.Welcome or Page.Sign.Failed or Page.Signin.InvalidData for instance
01:35:11 <boegel> shapr: have you started uni already ?
01:35:22 <shapr> uni ... cycling ;-)
01:35:27 <Speck> hehe
01:35:30 <shapr> No, not yet.
01:36:00 * nibro really should go write his paper...
01:36:09 * shapr should really finish his Plone work.
01:36:18 <boegel> shapr: when are you starting ?
01:36:43 <shapr> When I have the spare time to organize everything... right now I'm scrambling for work to pay for my move and everything.
01:37:23 <ulfdoz> Noch besser macht es sich im Softraid mit <300kb/s.
01:37:24 <ulfdoz> ECHAN, sorry
01:40:03 <shapr> boegel: Why do you ask?
01:41:01 <ulfdoz> Was hat LAN und Raid miteinander zu tun?
01:41:23 <ulfdoz> Sorry, I'm not yet awake.
01:41:34 <earthy> ulfdoz, sag ma', wird's nicht zeit die kanaele besser aus einander zu halten? :)
01:41:36 * shapr throws water on ulfdoz 
01:41:48 <kosmikus> ulfdoz: vielleicht einen anderen irc-client verwenden?
01:41:55 <shapr> heheh
01:42:11 <shapr> ulfdoz: Are you asking about storage area networks?
01:43:16 <ulfdoz> nope, I just throw away my scsi-raid because two disk seemed dead this morning.
01:43:49 <shapr> wow, that sucks.
01:44:48 <ulfdoz> Both of the same type. I suppose, IBM implented some best-before-date.
01:44:53 * Speck cries for a faster computer
01:46:18 <boegel> shapr: just curious how you liked uni :)
01:47:05 <shapr> I'd love it if I could just wander around and learn stuff.
01:47:31 <earthy> 'The last good thing written in C was Franz Schubert's
01:47:32 <earthy>              Symphony No. 9.'
01:47:37 <metaperl> nibro: p.26 of thesis, small typo. hwColor color = <p style=("color" ++ c)>Hello</p> --- c should be color
01:47:53 <metaperl> lol @ earthy
01:48:16 <Speck> it should probably be ("color:" ++ color) no?
01:48:41 <Heffalump> shapr: bah, it doesn't work on the darcs wiki, and it's even broken on the wiki I run where I originally set it up, so I now can't remember how to do it.
01:49:55 <shapr> I found a broken version of latex.py for some antique moin version, and hacked at it until it worked with moin 1.2
01:50:04 <shapr> Chilli is using my hacked version also.
01:50:11 <Heffalump> I think I was too.
01:50:20 <Heffalump> I remember getting it from someone, I just couldn't remember whom. Must have been you :-)
01:51:10 <shapr> http://www.haskell.org/~shae/latex.py
01:51:14 <sieni> http://nikc.fdns.net/~nikke/collected/pics/00005796.jpg
01:51:29 <Heffalump> I seem t ohave it, but I have a feeling that the version of python moinmoin is using changed.
01:51:41 <boegel> shapr: :D
01:52:19 <shapr> It's likely plugins changed a bit between 1.2 and 1.3 of moin.
01:52:19 <Heffalump> Do you know how to work out what version of python a moinmoin install is using?
01:52:39 <Heffalump> ah, /me reads the Debian dependencies
01:53:15 <shapr> Speaking of which, I made a deb out of lelit's trac+darcs
01:53:54 <tromp> morning!
01:53:57 <shapr> hoi tromp
01:54:14 <tromp> here comes another one:)
01:54:23 * shapr gets ready to save another quote...
01:54:27 <tromp> The number of legal 16x16 Go positions is 4813066963822755416429056022484299646486874100967249263944719599975607459850502222039591149331431805524655467453067042377
01:54:53 <shapr> @quote tromp
01:54:53 <lambdabot>  the number of legal 15x15 Go positions is 107514643083613831187684137
01:54:53 <lambdabot> 5486612380973378882032784440276460166287088360171129830933923986899833
01:54:53 <lambdabot> 7801509491
01:54:59 <tromp> you'll have to wait for next year to get another quote;(
01:55:12 <shapr> I'm sure you'll find some shortcuts.
01:55:17 <Heffalump> do you remember if there's anything that's needed to intall it apart from putting it in the site-pakages/MoinMoin/processor directory?
01:55:27 <tromp> i wish...
01:55:43 <tromp> we haven't used any shortcuts so far:(
01:55:44 <Heffalump> make a distributed client
01:56:02 <tromp> it's alrd distributed
01:56:16 <shapr> tromp: Yeah, write a distributed.irc platform so we can run it on #haskell.
01:56:23 <tromp> see http://www.cwi.nl/~tromp/go/legal.html for our results so far and our nice paper
01:56:40 <tromp> the main problem is disk space
01:57:07 <tromp> we used 660GB for this result
01:57:41 <shapr> You can't fold over the data?
01:57:50 <shapr> Or does that already fold?
01:58:07 <nibro> a Go@home project over the irc channel? :)
01:58:38 <shapr> go-home, I like it!
01:58:43 <tromp> no, you have to keep a lot of state
01:59:15 <tromp> 4148642993 counters for 16x16
01:59:43 <tromp> got a talk to attend. see you later!
02:00:07 <shapr> cya!
02:00:14 <boegel> 660GB, just to compute 1 number, omg :)
02:05:49 <shapr> @yow !
02:05:50 <lambdabot> I'm using my X-RAY VISION to obtain a rare glimpse of the INNER
02:05:50 <lambdabot> WORKINGS of this POTATO!!
02:06:14 <ValarQ> ?
02:06:17 <shapr> !
02:06:27 <shapr> Vem Ã¤r jag?
02:06:45 <shapr> Jag glÃ¶mmer alting...
02:07:08 <ski> en röst i cyberrymden ?
02:07:20 <shapr> precis!
02:07:57 <shapr> bara en rÃ¶st... i obygden
02:08:40 <ski> o öde mark, vem skall väl dig förbarma ?
02:09:46 <ValarQ> vÃ¤rst vad ni blev poetiska
02:10:19 <shapr> Arbetsformedling probably... they'll get me a job at chalmers just like I've always wanted... but I'll have to clean the floors.
02:11:11 <shapr> ValarQ: Are you at Chalmers?
02:11:13 <davve> has anyone looked at daan leijens latest paper about extensible records?
02:11:15 <ValarQ> shapr: nope
02:11:25 <shapr> Are you a student?
02:11:31 * shapr goes the twenty questions route...
02:12:12 <ValarQ> shapr: yeah, at komvux in kalmar
02:12:49 <Speck> runghc: waitForProcess: interrupted (Interrupted system call)      <-- while trying to install the hs-plugins cabal package
02:12:55 <Heffalump> wi ValarQ
02:13:05 * Heffalump looks confused
02:13:18 <ValarQ> shapr: i used to work for the military thought
02:13:19 <Heffalump> oh. tab completion being weird.
02:13:28 <ValarQ> hello mr Lump
02:13:34 <Heffalump> :-)
02:13:36 <[Blownose]> how do I add a char to the end of a list without using    reverse twice :) ?
02:13:44 <Heffalump> [Blownose]: foo ++ [c]
02:13:55 <shapr> ValarQ: So, you've probably been to my town, Boden?
02:14:16 <ValarQ> shapr: no, i don't think so
02:14:17 <ski> [Blownose] : foldr (:) [c] foo
02:14:58 <Speck> should I be using cabal-get to install cabal packages?
02:15:09 <[Blownose]> hmm ski that will be in the beginning of the list
02:15:13 <Heffalump> ski: why is that better than mine?
02:15:16 <Heffalump> [Blownose]: no, it won't
02:15:17 <ProfTeggy> No, Blownose
02:15:32 <ski> Heffalump : it isn't :)
02:15:32 <[Blownose]> ok :)
02:15:37 <Heffalump> ok :-)
02:15:46 * Heffalump assumes that (++) is defined with foldr anyway so you get the deforestation
02:15:58 <shapr> ValarQ: So what brings you here? Interested in functional programming?
02:16:15 <ProfTeggy> Ah, sweet deforestation
02:16:26 <ProfTeggy> catamorphism fusion
02:16:37 <shapr> I sort of doubt I'd find any Haskell users in Boden's komvux. I wasn't thrilled with the Swedish program there.
02:16:46 <ValarQ> shapr: yeah, i find haskell pretty interesting
02:16:52 <shapr> They had one really good and nice teacher though.
02:16:56 <shapr> She was cute too :-)
02:18:00 <shapr> ValarQ: Any questions about Haskell?
02:18:53 <ValarQ> shapr: no, i think i'm gonna read through the tutorials and documents first
02:19:13 * shapr has a sudden urge to fly to Broken Hill, AU
02:19:20 <ValarQ> shapr: i'm having some trouble understanding this Monad thingie
02:19:27 <shapr> Awright, do you already have a good list of tutorials and docs?
02:19:42 <shapr> ValarQ: http://www.nomaware.com/monads/html/index.html
02:19:59 <ValarQ> shapr: i'm working with that one now :)
02:20:20 <Speck> I thought that the description of monads in the beginning of the arrows paper was pretty good
02:20:42 <shapr> Monads are very simple and powerful, but they're not easily explained in English.
02:21:00 <shapr> I like Cale's wiki page MonadsAsContainers.
02:21:01 <ValarQ> no, apparantly not
02:21:23 <shapr> @wiki MonadsAsContainers
02:21:24 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
02:21:37 <Speck> did lambdabot get updated recently?
02:21:38 <ProfTeggy> shapr, the situation with Monads and German isn't much better :-}
02:22:01 <shapr> In that case, I suspect translating to Swedish won't help much either.
02:22:21 <ProfTeggy> You never know
02:22:27 <ValarQ> ProfTeggy: try implement it in asm, maybe thats more expressive :)
02:23:06 <ski> "De magiska monaderna, eller hur Leibniz hittade in i din dator"
02:23:19 <ProfTeggy> I have a nice I/O monad introduction saved here that comes with a mini implementation of the monad in C
02:23:22 <shapr> heh
02:23:46 <ProfTeggy> Proved to be instructive to at least some of my students
02:26:21 <shapr> Oh frabjous day, callooh callay.
02:28:10 <ski> mutt mongering riff-raff
02:28:24 * shapr quickly mongers a nearby mutt.
02:30:12 <metaperl> that HSP thesis was a great read
02:30:22 <likens> I'm looking at http://www.haskell.org/~simonmar/papers/web-server-jfp.pdf and wondering if the source for the program described therein is available and if so, where.
02:30:22 <metaperl> looks like a very nice piece of work
02:31:15 <likens> gack!  what happened to the link?  I was trying to ref Marlow's haskell web server.
02:31:39 <shapr> likens: It's in fptools.
02:31:57 <shapr> Peter Thiemann has a version of hws that uses hs-plugins.
02:33:04 <likens> thank you, shapr
02:33:39 <Trinsic> why do people say 'heh'?
02:33:54 <shapr> It's an expression of amusement.
02:34:11 <shapr> IRC needs to have some sort of social signals.
02:34:47 <shapr> I personally despise the word 'lol', probably because I started using 'heh' on IRC in 1990 or so.
02:35:11 <Trinsic> whenever i see it, I have visions of 1930's gangsters pop into my head.
02:35:21 <shapr> I'm not quite *that* old.
02:35:23 <Oejet> Heh, heh.
02:35:53 <Khisanth> don't you mean "heh, heh heh"? :)
02:35:59 <shapr> Trinsic: Social signals are always contextual.
02:36:38 <Trinsic> suffice it to say it's a rather strange modality.
02:36:58 <shapr> I think it's just unfamiliar.
02:37:26 <shapr> What do you use to express amusement across email and irc?
02:37:35 <shapr> What textual social signals do you have?
02:37:49 <shapr> I'd rather use lojban's attitudinals, but only jewel would understand me :-)
02:40:05 <Cale> Trinsic: any reason why?
02:40:16 <Cale> (with the gangsters thing)
02:40:24 <shapr> Trinsic: And what part of it is strange?
02:41:45 <shapr> My father was in the Air Force, we never spent more than a year in the same place until I was thirteen or so. I got used to picking up new social signals on a regular basis. Southeast USA and Northwest USA have dramatically different signals.
02:42:18 <shapr> For example, what do you call it? coke, soda, or pop?
02:43:05 <ski> or soft drink ..
02:43:06 <Cale> shapr: I also despise 'lol'
02:43:28 <nibro> metaperl: thanks a million, glad you liked it :)
02:43:39 <shapr> ski: or lÃ¤sk
02:43:44 <Cale> except in mocking usage of course :)
02:43:46 <Trinsic> Cale,Shapr, it almost seems like forced aministration to say it. like i said before, it doesn't match with the person who is saying 'for some strange reason'.
02:44:14 <Cale> Trinsic: to say "heh"
02:44:16 <Cale> ?
02:45:01 * ski remembers an old 'children song' with 'heh' in it
02:45:17 <Trinsic> Cale, yup.
02:45:26 <Cale> Trinsic: I tend to use it when it's the sound I'd make while talking.
02:45:39 <shapr> You could consider heh to be a form of emoticon.
02:45:43 <Trinsic> it also rings to me. i don't care, what you say offends me.
02:45:56 <Cale> what?
02:46:26 <shapr> huh?
02:46:26 <Cale> the sound of a brief laugh offends you?
02:46:36 <Trinsic> it's certainly not unconditional.
02:46:58 <Cale> unconditional?
02:47:05 <Trinsic> anyway, just opinions, don't mean to offend.
02:47:27 <Cale> I just don't understand what it is that you're getting from 'heh' that I'm not :)
02:47:50 <Trinsic> heh
02:47:54 <Trinsic> hahaha.
02:48:12 <Cale> heheheh
02:48:17 <shapr> bwaha
02:48:34 <ski> hihihi hohoho heh heh heeh !
02:48:44 <ski> (that was the chorus)
02:51:29 <shapr> At least they're onomatopoeic.
02:52:16 <shapr> Trinsic: How would you express amusement in a text chat?
02:55:18 <Speck> I really can't figure out the cabal-get bootstrapping procedure
02:57:34 <Trinsic> shapr, i already did.
02:58:45 <Speck> oh drat... I need to update cabal
03:16:20 <dcoutts> dons, pong
03:23:16 <Speck> /opt/local/lib/ghc-6.4/HSreadline.o: unknown symbol `_rl_discard_keymap'   hurr... is my ghc install messed up?
03:25:59 <Speck> I'm not having very much luck getting any haskell libraries to compile
04:11:30 <shapr> I can't believe it's not butter!
04:11:41 <shapr> Speck: do you have readline installed?
04:17:46 <malcolm> Speck: and if so, do you have the right version of readline?
04:26:19 <b0gg1e> mornin'.
04:39:11 <boegel> hey b0gg1e
04:52:03 <dblhelix> metaperl: just read your blog entry... the last case of your substring function will never be taken into account...
04:53:45 <ketil> Hi, all
04:53:55 <ketil> Anybody know how well Data.Hashtable performs?
04:54:13 <dblhelix> metaperl: you should change the lhs of the first clause of your substring function into substring xs ys@(_ : _) or something, or change otherwise into not (null ys)
04:59:42 <ketil> Hi again - anybody know how well Data.HashTable performs?
04:59:57 <Lemmih> Pretty well, I would say.
05:00:12 <ketil> Memory-wise too?
05:00:28 <ketil> Does it use an array underneath, or a tree structure?
05:00:37 <Lemmih> An Array.
05:00:41 <Lemmih> @libsrc Data.HashTable
05:00:42 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/HashTable.hs
05:01:40 <ketil> Okay - I'm too tired from messing about with home-grown search structures.  Perhaps I'll give it a try.
05:01:52 * ketil hopes it will be more efficient than a FiniteMap.
05:02:41 <shapr> Hm, there are three job descriptions on Yahoo jobs that mention Haskell.
05:03:14 * dcoutts is suprised
05:03:20 <shapr> I'm actually tempted to apply for the Microsoft job.
05:03:24 <ProfTeggy> "Knowledge of Haskell won't help you here."?
05:03:42 <dcoutts> shapr, what's the MS job?
05:03:48 <rep> http://hotjobs.yahoo.com/ ?
05:04:11 <shapr> The MS job says "We are not a product oriented team, we're here to come up with possibilities, and see what happens."
05:04:28 <dcoutts> sounds nice
05:04:53 <shapr> Let's see... hang around and implement interesting ideas in Haskell. This is what I do in my free time.
05:06:48 <Lemmih> 10 years of C/C++ experience?
05:07:04 <shapr> I've got about ten minutes of C++ experience...
05:07:10 <Lemmih> Ten years ago I was eight /-:
05:07:34 <shapr> I started programming BASIC at 11. I would have used something better if it were available.
05:08:09 <shapr> Speaking of which, why don't we make a cheap embedded console that boots up running GHC instead of BASIC?
05:08:25 <shapr> I guess that would just be hOppix.
05:10:46 <shapr> coi djul
05:11:23 <shapr> What's ZurÃ¼ckziehen?
05:11:35 <ProfTeggy> depends on contect: retract
05:11:39 <shapr> ah thanks!
05:11:41 <ProfTeggy> context
05:12:01 <jewel> coi doi
05:12:46 <shapr> ma nuzba .i xu do gunka
05:14:01 <kolmodin> cd
05:14:01 <jewel> mi zvati le zdani
05:14:08 <kolmodin> crap, wrong window
05:15:30 <shapr> xu do djica lenu go'i
05:15:51 <jewel> mi bazi cliva mu'i lenu mi ba klama le te salci
05:16:10 <shapr> je'e
05:16:23 <shapr> have fun
05:16:27 <jewel> .ie u'i
05:17:35 <shapr> lojban attitudinals are nifty.
05:17:36 <ketil> shapr: I prefer "happix"
05:18:10 <shapr> ketil: Well, Lunar^ and seb already wrote hOp, the Haskell Operating System.
05:20:48 * boegel leaves for home
05:22:16 <JohnMeacham> I finally broke down and switched jhc to --make.. no more -j and slower incremental compiles..
05:24:24 <shapr> hiya JaffaCake
05:24:28 <JaffaCake> afternoon, #haskell
05:24:40 <shapr> JohnMeacham: awww
05:26:22 <dcoutts> hia JaffaCake, I think Lemmih has some ghc api questions for you :-)
05:26:36 <JaffaCake> fire away
05:27:03 <Lemmih> Yay. He's back.
05:29:31 * Lemmih will do some more research before asking stupid questions.
05:30:04 <dcoutts> JaffaCake, so Lemmih managed to get ghc api working with 6.4.1 by getting ghc api to read 6.4.1 .hi files.
05:30:19 <JaffaCake> really?
05:30:30 <dcoutts> so it looks like we can use it for at least parsing/renaming/typechecking
05:31:07 <JaffaCake> sounds fragile, though
05:31:09 <dcoutts> http://www.scannedinavian.com/YiWiki/ScreenShots
05:31:37 <dcoutts> the last one there shows it typecheckign with type class instances working
05:31:55 <JaffaCake> neat
05:31:59 <dcoutts> which was on of the bits that needed changing for 6.5 vs. 6.4.1 apparently
05:32:20 <dcoutts> JaffaCake, sure it's just so we can get stuff done 'til 6.6 is out
05:32:29 <dcoutts> or is near at least
05:32:50 <JohnMeacham> shapr: I suppose you could just not pull that patch. darcs is nice :)
05:33:03 <JaffaCake> right - I'm surprised, I didn't think it could be done :)
05:33:12 <JaffaCake> well not easily, at least
05:33:14 <Lemmih> Uh, a screenshot showing the use of instances from a library would be a lot better.
05:33:39 <shapr> JohnMeacham: Why did you switch to --make? Was it too much trouble to do deps?
05:33:43 <JaffaCake> Lemmih: you had to change the binary interface file parser to match the 6.4.1 format?
05:34:46 <JohnMeacham> shapr: no, I wanted a profiling and normal build to work in the same tree. it was too tricky to get make to recognize the .prof.* files and match them up properly
05:36:11 <Lemmih> JaffaCake: Yeah, I copied some code from 6.4.1 and then derived the new interface structure from the old.
05:36:29 <JaffaCake> right
05:38:11 <JohnMeacham> It would be neat if ghc --make created a little lock file or something on files it was compiling, so you could just run multiple instances of ghc --make in the same dir and they will all place nice together. if your directory is on nfs you could even do so on a bunch of different machines.
05:38:15 <Lemmih> We probably have to switch to 6.5 before 6.6 is out.
05:39:42 <JaffaCake> JohnMeacham: interesting idea - the compilation manager would also have to skip over locked files and try other branches of the dependency tree
05:40:51 <Igloo> But you can get the same effect with the new --make -j, right?
05:40:52 <JohnMeacham> JaffaCake: yeah, just what I was thinking.
05:41:16 <JohnMeacham> Igloo: yes you can, which is why I have held off using --make as long as possibel.
05:41:16 <JaffaCake> Igloo: yes, but it's not quite there yet
05:42:03 <JaffaCake> I'm about to rip the RTS to bits and put it back together again :-/
05:42:26 <JaffaCake> to improve SMP perf
05:42:30 <earthy> that'd be nice for hOp... :P
05:45:30 <b0gg1e> does ghc configure --enable-dotnet work on macosx?
05:49:42 <shapr> yay!
05:49:46 <dcoutts> Lemmih, so you figured out how to sue the ghc api for what you were doing?
05:49:53 <shapr> JaffaCake: Hey what do you think about adding priority to the scheduler?
05:49:56 <dcoutts> sue/use :-)
05:50:12 <dcoutts> shapr, hmm probably a can of worms :-)
05:50:31 <JaffaCake> shapr: I kind of hope we can get away without it... but I have a horrible feeling we can't
05:50:49 <JaffaCake> when you add priority, you have to deal with priority inversion
05:50:52 <dcoutts> welcome to deadlocks & priority inversion
05:52:02 <dcoutts> shapr, so what would you use priority for?
05:52:12 <shapr> hOp
05:52:23 <JohnMeacham> If I were to start a band, I think I might call it 'priority inversion'
05:52:33 <shapr> That is a good name.
05:53:18 <MarcWeber> Which is the option to tell ghc to look for files in another derectory, too?
05:53:25 <shapr> dcoutts: Lunar^ told me that hOp needed a scheduler with priority.
05:53:44 <JaffaCake> MarcWeber: -i<dir>
05:53:50 <dcoutts> shapr, fair enough. Are there any other good examples?
05:54:34 <JaffaCake> hOp probably just wants two levels of priority: interrupt threads and other threads
05:54:54 <MarcWeber> JaffaCake: Why doesnt ghc --help show this option?
05:54:58 <JaffaCake> two levels is probably easier than arbitrary priorities
05:55:10 <JaffaCake> MarcWeber: there's a lot of options that ghc --help doesn't show :)
05:55:40 <JaffaCake> MarcWeber: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
05:55:56 <Lemmih> dcoutts: I need a way to kill a thread without it being catchable.
05:56:15 <JaffaCake> Lemmih: you do?  that sounds dangerous
05:56:20 <dcoutts> Lemmih, ohh, hmm
05:56:28 <dcoutts> Lemmih, why?
05:56:39 <Lemmih> JaffaCake: I think I do (:
05:56:41 <manulito> what is functions defined with a \ inside mean, or where can i read mor about it. i got a (=='x') function described in this way and i undertand how the predicate works, but wanna read some more about the  \ notation
05:57:00 <manulito> (\a -> a=='x').
05:57:06 <kzm> manulito: the \ is lambda
05:57:19 <manulito> ok
05:57:21 <manulito> thanks
05:57:22 <dcoutts> Lemmih, you mean to kill the background thread that's doing the ghc parsing/typecheckign etc?
05:57:24 <kzm> i.e. the function that takes an a, and returns its comparison to 'x'
05:57:39 <dcoutts> Lemmih, why does it need to be not catchable?
05:58:14 <dcoutts> JaffaCake, how do you kill the background ghc thread when someone modifies the editor buffer in VH?
05:58:27 <JaffaCake> I don't think we do
05:58:44 <JaffaCake> but that's something that I need to look into
05:58:48 <Lemmih> vs does it for you, right?
05:59:02 <dcoutts> so if you type quickly you just have dozens of them running at once on different out-of-date version of the buffer?
05:59:04 <JaffaCake> no, we just wait until it's finished before starting a new parse
05:59:13 <dcoutts> ah ok
05:59:35 <Lemmih> Hm, I'll try that.
05:59:49 <JaffaCake> the parser starts as soon as the buffer is modified, but errors are only reported when the buffer is idle for a short time
06:00:01 <dcoutts> JaffaCake, so perhaps all we need is to have ghc recognise an exception which means just stop without complaining or printing any errors
06:00:10 <JaffaCake> yep
06:00:18 <dcoutts> hmm what does ghc do when you press ctl-C ?
06:00:27 <dcoutts> that throws an asynchronous exception right?
06:00:31 <JaffaCake> yes
06:00:40 <dcoutts> which ghc catches and then just stops
06:00:58 <JaffaCake> I think throwing the same exception might work
06:01:16 <dcoutts> Lemmih, there's a possibility
06:01:17 <JaffaCake> throwDyn Panic.Interrupted
06:01:32 <JaffaCake> ah, throwDynTo
06:01:57 <JaffaCake> you can Ctrl-C a compilation in GHCi, it's the same thing
06:04:35 <dcoutts> JaffaCake, in VS you've got "jump to doc" impelemented right?
06:04:47 <JaffaCake> yes
06:04:59 <JaffaCake> oh no - jump to definition
06:05:10 <JaffaCake> jump to doc shouldn't be too hard
06:05:22 <dcoutts> does that work only for files that pass the renamer stage or do you make best guesses for mal-formed editor buffers?
06:05:42 <JaffaCake> only for correct buffers right now
06:05:47 <dcoutts> JaffaCake, I implemented the hIDE html viewer component the other day, 50 lines of code :-)
06:05:54 <dcoutts> JaffaCake, ah ok.
06:05:55 <JaffaCake> heh, nice
06:06:24 <dcoutts> so that way we don't need big indexes since the renamer tells us exactly where to look for the docs
06:06:40 <JaffaCake> absolutely
06:07:00 <b0gg1e> my ghc on osx is broken, did someone have the same problem? ld is complaining about the missing symbol "___DISCARD__"
06:07:04 <JaffaCake> you'll need to find out which package to look in, though
06:07:04 <dcoutts> we can leave the guesswork feature to hoogle or something else
06:07:34 <JaffaCake> b0gg1e: go ask google, I think you have an out of date gcc or something
06:07:37 <dcoutts> JaffaCake, right but that's just a matter of consulting the package db, to find the package that exposes the module
06:08:22 <dcoutts> JaffaCake, and the .hi files now retain source locations for exported functions? so jump to def is easy too right?
06:08:30 <JaffaCake> yep, there's a function Packages.lookupModuleInAllPackages
06:09:08 <JaffaCake> dcoutts: not 100% sure that the .hi files retain the information, but it's retained in a session
06:09:25 <JaffaCake> you definitely get it for interpreted modules
06:09:41 <dcoutts> ah ok, hmm, so we may need to compile all the dependent modules
06:09:44 <dcoutts> http://haskell.org/~duncan/hIDE/hIDE-htmlviewer.png
06:10:18 <manulito> what does the '-sign mean, placed after an inparmetervariable somewhere in a function, like a'
06:10:33 <manulito> i dont have a book, and these small things are hard to google for =)
06:10:46 <ProfTeggy> manulito, nothing special about '
06:10:46 <dcoutts> manulito, it's just part of the variable name
06:10:52 <manulito> ok
06:11:01 <JaffaCake> dcoutts: maybe, but we should probably keep the SrcLoc in the .hi file (if we don't already)
06:11:33 <dcoutts> manulito, people sometimes make it mean " "a'" is a modified/updated version of the value held by the variable "a" "
06:11:43 <manulito> ok!
06:12:06 <b0gg1e> JaffaCake, thanks looks like this could solve the issue.
06:12:15 <JaffaCake> np
06:12:15 <dcoutts> JaffaCake, yeah that'd make it a bit quicker since we would not have to re-process the source files
06:12:35 <manulito> since the function doenst have any inparameters called a' or a'', only a, but all three of them are used in the function
06:13:10 * JaffaCake just got 'ghci foo.cabal' working
06:13:38 <dcoutts> JaffaCake, that does what exactly?
06:13:53 <JaffaCake> loads up the source files in GHCi
06:14:06 <JaffaCake> with appropriate flags, packages etc.
06:14:18 <dcoutts> nice, hIDE needs that feature :-)
06:14:51 <dcoutts> at least up to the renamer+typechecker stage
06:15:13 <dcoutts> we currently don't take account of flags or packages
06:15:34 <JaffaCake> it's not difficult
06:16:00 <dcoutts> does VH deal with multiple projects? ie multiple .cabal files?
06:16:08 <dcoutts> or just one at a time?
06:16:12 <JaffaCake> dcoutts: multiple
06:16:28 <dcoutts> and works out the dep between them
06:16:39 <JaffaCake> no, you have to order them explicitly
06:16:49 <dcoutts> oh
06:16:54 <JaffaCake> actually, I'm not sure it works properly :)
06:17:10 <JaffaCake> it works in theory, which is good enough for me :)
06:17:16 <dcoutts> does one have to select in the UI which project is current?
06:17:25 <dcoutts> or is that worked out automagically
06:17:34 <JaffaCake> there isn't a notion of "current"
06:17:44 <dcoutts> ok, that's nicer from a UI perspective
06:17:44 <JaffaCake> each one gets a separate GHC Session
06:18:05 <JaffaCake> ah, in VS there's a thing called a "solution" which is a container for multiple projects
06:18:14 <dcoutts> right
06:18:16 <shapr> CosmicRay: Any interesting plans for The Great Computer Language Beauty Contest?
06:18:23 <JaffaCake> when you're in VS you're always working with a solution
06:18:43 <dcoutts> so when trying to build a file, you always know which project it belongs to
06:18:44 <CosmicRay> shapr: morning.  yes, I hope to get a website going today.
06:18:49 <CosmicRay> shapr: the repo is available now
06:18:52 <JaffaCake> dcoutts: yes
06:18:58 <CosmicRay> I've got two example Haskell programs running already.
06:19:06 <dcoutts> because projects cannot share modules
06:19:17 <CosmicRay> JaffaCake: say, can I pick your brain about read being slow for Ints?
06:19:17 <dcoutts> because packages cannot have overlap
06:19:32 <shapr> Do you plan on staying synchronized with the Alioth Shootout?
06:19:38 <JaffaCake> CosmicRay: you can try, I'm not familiar with that code
06:19:47 <CosmicRay> shapr: I will try.  It will not be easy because they store their output in CVS.
06:20:12 <CosmicRay> JaffaCake: OK.  So basically, an implementation of http://shootout.alioth.debian.org/benchmark.php?test=sumcol&lang=ghc&id=0&sort=fullcpu that uses read instead of the home-grown parsing function is approxiamtely 70 times slower.
06:20:18 <JaffaCake> dcoutts: not sure what you're referring to - packages can overlap
06:20:33 <shapr> May I write a scathing and motivational rant against premature and in favor of code that communicates?
06:20:43 <shapr> er "premature optimization"
06:20:44 <CosmicRay> such as, main = interact $ (++ "\n") . show . (sum :: [Int] -> Int) . map read . lines
06:20:46 <CosmicRay> shapr: please
06:21:00 <CosmicRay> feel free to modify the faq.php (or whatever) file in the repo and send me a patch ;-)
06:21:04 <shapr> nifty
06:21:10 <Philippa> shapr: code that communicates /and/ turns out to be optimised, now that's good
06:21:37 <shapr> Yeah, but others cannot optimize what they cannot understand.
06:22:01 <dcoutts> JaffaCake, I was just wondering if I need to compile module A, do I know which project it belongs to, could it belong to more than one project? If one source file can be built into two packages then we don't know whihc way to compile that module - we'd need a UI notion of 'current' project.
06:22:03 * Philippa nods
06:22:05 <CosmicRay> http://darcs.complete.org/local-branches/shootout/bench/sumcol/sumcol.ghc-11.ghc is equally slow.
06:22:16 <shapr> And given the choice of three codebases that do roughly the same thing, I'll always end up using the most clearly written, because I can most quickly modify that to my own needs.
06:22:19 <Philippa> it would be good to be able to start with the trivial code and guide the compiler through all the optimisations as transformations on it
06:22:39 <Philippa> you don't do anything that needs to go really really fast though AFAICT
06:22:49 <JaffaCake> CosmicRay: not sure why
06:23:01 <CosmicRay> JaffaCake: who should I ask?
06:23:17 <CosmicRay> JaffaCake: igloo told me that he know read was slow on ints, but didn't know why.
06:23:38 <JaffaCake> Koen Claessen wrote the read parser
06:24:13 * JaffaCake goes to look at the code
06:24:34 <shapr> Philippa: No, but if I did, I'd strive to generate fast output from simple code.
06:25:00 <shapr> Hm, simple isn't the right word there.
06:25:33 * Igloo reads scrollback to get the context of that remark, and thinks "when you're in VS you're always working with a solution" is some great MS-speak  :-)
06:25:34 <JaffaCake> CosmicRay: the instsance of Read for Int doesn't look very efficient
06:25:42 <dcoutts> JaffaCake, I guess the simple form of the question is: does VS assume that each source file belongs to at most one project/package? (and thus it knows unambiguously how to build each source file)
06:25:50 <dcoutts> VS/VH
06:26:08 <JaffaCake> CosmicRay: it could use some specialisation, at least
06:26:18 <shapr> int-e wrote a faster number printing routine for GHC recently, did he submit it you?
06:26:24 <JaffaCake> CosmicRay: you might want to copy the code out of GHC/Read.lhs and play with it
06:26:56 <JaffaCake> dcoutts: the answer is no
06:27:09 <CosmicRay> JaffaCake: OK, thanks.
06:27:50 <JaffaCake> dcoutts: but I'm not sure I understand fully: when you "build" a source file you're always doing it in the context of a project
06:28:16 <JaffaCake> when would you need to know how to build a source file but not know which project it belongs to?
06:28:31 <dcoutts> you said there was no notion of current project
06:28:45 <JaffaCake> that's right
06:28:48 <dcoutts> and a source file may belong to more than one project
06:28:58 <gerdm> hello, is it possible to use type constraints for data constructors?
06:29:03 <JaffaCake> well, in theory, yes
06:29:15 <dcoutts> JaffaCake, so there's an ambiguity
06:29:26 <basti_> gerdm: no, only in functions.
06:29:32 <JaffaCake> no, I don't think so
06:29:57 <dcoutts> JaffaCake, I don't know which flags/settings to use when building the file because I don't know which project context to use
06:30:07 <JaffaCake> you build it twice
06:30:29 <gerdm> basti_: thx
06:30:39 <dcoutts> JaffaCake, heh yeah ok, but that doesn't help with which errors you report in the source buffer
06:30:50 <dcoutts> gerdm, yes you can but it only affects the data constructors, not the type itself
06:31:08 <JaffaCake> dcoutts: true, that's a problem
06:31:21 <JaffaCake> I guess the answer is "don't do that"
06:32:06 <dcoutts> JaffaCake, so we can just ban files belonging to more than one project, or ask the user which project they mean to build (and if they really noticed that this file is in multiple projects)
06:32:41 <dcoutts> JaffaCake, that's ok I guess.
06:33:22 <JaffaCake> or you could allow multiple open buffers on the same file, each one processed in the context of a different project
06:33:41 <JaffaCake> I don't think you can do that in VS, though
06:33:52 <JaffaCake> I'm sure it won't allow opening the same file multiple times
06:34:08 <dcoutts> right, each window has a current project, however I think it's probably not a nice UI style
06:34:28 <dcoutts> as you say it's probably not a common occurance that we can just bug the user in that case
06:34:53 <dcoutts> avoiding the notion of 'current' project in most cases is nice
06:35:07 <JaffaCake> when would you do this anyway?
06:35:08 <shapr> Wow, this is great! --> http://www.oreillynet.com/pub/wlg/7996
06:35:14 * shapr hugs -Ofun
06:35:40 <dcoutts> JaffaCake, well we want to know what flags to use when building a module
06:36:09 <dcoutts> JaffaCake, eg for giving errors in the editor, and all the other stuff, jump to def/doc
06:36:14 <JaffaCake> I mean, when would you have two packages that contain the same source file?
06:36:28 <CosmicRay> shapr: so, what do you think?  beauty.complete.org?  beautycontest.complete.org?  or should I go all out and spend the $15 for beautycontest.org? ;-)
06:36:43 <dcoutts> JaffaCake, right, it's not something we'd expect very often, I was just wondering if it's banned outright
06:37:17 <shapr> CosmicRay: I'd say beauty.complete.org
06:37:29 * CosmicRay hacks away.
06:37:38 <shapr> CosmicRay: Hey, lwn.net has three haskell items this week! Two HWNs and a TMR!
06:37:44 <CosmicRay> sweet!
06:38:02 <CosmicRay> did you send them the TMR link?
06:38:06 <dcoutts> JaffaCake, I mean it's allowed to have the same module name in more than one package (under some circumstances) so that module may arrise from the exact same file. Possibley.
06:38:06 <shapr> yup
06:38:11 <CosmicRay> shapr: nice
06:38:32 <CosmicRay> wow, first update to my zone file since January ;-)
06:38:41 <Igloo> LWN has 2 HWN's this week? *scratches head*
06:38:41 <JaffaCake> dcoutts: maybe, but you'd need two .cabal files sharing a source tree
06:38:42 * shapr throws elderberries at the paltry single entry 'Caml Weekly News'
06:38:50 <CosmicRay> Igloo: last week's HWN was late
06:38:51 <shapr> Igloo: It was a long week.
06:39:00 <dcoutts> JaffaCake, yes, there are several such 'projects'
06:39:11 * Igloo prefers shapr's answer
06:39:18 <dcoutts> JaffaCake, hSQL, hIDE, ... probably more
06:39:41 <dcoutts> Gtk2Hs would be another example when it gets cabalised
06:39:54 <JaffaCake> IMO, if the packages share a source file, then that file should be split off into another package
06:39:58 <CosmicRay> hehe
06:40:34 <dcoutts> JaffaCake, so yes, it's not something we expect or have to deal with gracefully.
06:40:39 <JaffaCake> dcoutts: how do you manage multiple .cabal files ATM?
06:40:54 <JaffaCake> I mean, what do you put in Setup.lhs?
06:40:56 <dcoutts> JaffaCake, we're still in the planning stages when it comes to project management
06:41:12 <dcoutts> hence al my questions :-)
06:41:20 <JaffaCake> ah
06:41:51 <dcoutts> JaffaCake, I'm not sure how we'll deal with Setup.(l)hs yet
06:42:06 <dcoutts> for a full project build we can just invoke cabal
06:42:44 <dcoutts> however for the interactive stuff, we need to do the building ourselves (at least up to the renaming typechecking phase)
06:42:52 <JaffaCake> you said hIDE has multiple .cabal files in the tree - what's the overall build system?
06:43:20 * JaffaCake should probably just go look at the source
06:43:35 <dcoutts> JaffaCake, the hIDE build system is pretty primitive atm, we have a scrpt that just configures, builds & installes al the packages in  the correct order
06:43:45 <JaffaCake> ok
06:43:47 <CosmicRay> dcoutts: say, will hIDE be usable without hs-plugins?
06:43:52 <dcoutts> we install them into the user's ghc packge db
06:44:05 <JaffaCake> so you have to install one before you can build the next?
06:44:11 <dcoutts> JaffaCake, yep
06:44:21 <dcoutts> JaffaCake, because they depend on each other
06:44:25 <JaffaCake> right, that's something we need to support better in Cabal
06:44:30 <dcoutts> CosmicRay, no reason why not, but that's not how it works just yet.
06:44:46 <dcoutts> CosmicRay, yi supported both modes
06:45:02 <CosmicRay> dcoutts: excellent.
06:45:09 <dcoutts> CosmicRay, it's just a matter of selecting the plugins you want statically and linking them all together
06:45:14 <CosmicRay> dcoutts: I am concerned about that since hs-plugins is not available on some platforms I use daily.
06:45:22 <dcoutts> CosmicRay, right
06:45:55 <dcoutts> CosmicRay, just don't complaing about having to relink hIDE each time you add/remove/change a plugin :-)
06:46:02 <CosmicRay> dcoutts: I won't ;-)
06:47:25 <dcoutts> JaffaCake, we've crrently got one cabal package for the static core (which generates an exe not a lib) and then in the plugins dir we have subdirs for each plugin and they all have their own .cabal file which produces a lib/package.
06:47:55 <JaffaCake> right
07:04:54 <boegel|home> yo xerox, shapr
07:04:59 <boegel|home> I meant shelarcy :)
07:05:10 <xerox> yo!
07:05:36 <shelarcy> yo!
07:09:38 <shapr> hiya boegel|home
07:09:50 <shapr> Man, I wanna get hold of Oleg's ZipperFS!
07:10:44 <shapr> but I can prototype the rest of this web system separately.
07:16:55 <pitecus> What's a good online Haskell tutorial (for someone who already knows some Scheme)?
07:17:51 <Lunglet> if i'm experienced with "normal" programming, but want to learn about functional programming and haskell, what should be the first book that i buy?
07:18:18 <xerox> pitecus, Lunglet, I'd give a try with  Yet Another Haskell Tutorial
07:18:31 <dcoutts> @learning
07:18:33 <lambdabot> Unknown command, try @listcommands.
07:18:37 <dcoutts> hmm
07:18:41 <z0d> Lunglet: depends on your level, try http://www.htdp.org/
07:18:56 <xerox> @where coolness
07:18:57 <lambdabot> I know nothing about coolness.
07:18:57 <pitecus> xerox, thanks. I think Lunglet wants book tho.
07:19:36 <C-Keen> I am reading "Introduction into the craft of functional programming using Haskell" which I find quite ok
07:21:44 <boegel|home> Lunglet: I read The Haskell School of Expression (P. Hudak)
07:22:01 <Philippa> myself I never bought a book. That said, I was given a course at uni that just about covered some stuff (mostly that algebraic datatypes and pattern matching're nice, admittedly) a couple of years before I started learning properly
07:22:02 <pitecus> z0d, what does htpd have to do with haskell?
07:22:19 <Philippa> so I already knew what to do about the lack of loops for example
07:22:29 <z0d> pitecus: sorry, I didn't notice the "Haskell" part
07:24:22 <Lunglet> thanks for all the suggestions
07:24:54 <basti_> theres a -lack- of loops? i never missed them!
07:25:18 <C-Keen> could be bypassed with iteration couldn't it?
07:26:07 <z0d> what are loops anyway? <-:
07:26:15 <integral> foreach = flip mapM_ -- loops work just fine for me!
07:26:20 <ValarQ> lol @ mr z0d
07:27:43 <pitecus> "The Anatomy of a Loop" http://www.cc.gatech.edu/~shivers/papers/loop.pdf
07:29:41 <z0d> it's like anatomy of an Alien queen. sci-fi
07:29:56 <shapr> @learn
07:29:57 <lambdabot> http://www.haskell.org/learning.html
07:31:33 <CosmicRay> pitecus: Yet Another Haskell Tutorial is good
07:31:43 <CosmicRay> pitecus: http://www.isi.edu/%7Ehdaume/htut/
07:32:36 <pitecus> Thnaks mate
07:33:50 <pitecus> Another thing: what editor do people usually use to write haskell?
07:33:50 <CosmicRay> shapr: if you are hacking on the faq, you might want to darcs pull, I've just checked in a bunch of stuff
07:34:00 <CosmicRay> pitecus: that varies as widely as for any other language
07:34:02 <CosmicRay> I use emacs
07:34:52 <pitecus> CosmicRay, for some pls emacs seems to be the only choice, such as for Lisp.
07:37:31 <rep> i use emacs
07:37:42 <rep> i tried using nvi, but it's too painful
07:37:48 <rep> (even though it's fine for C)
07:38:11 <JaffaCake> CosmicRay: i've had some more thoughts about darcs-ising everything
07:38:36 <malcolm> Let's not have an editor war.  (I use vim, which comes with Haskell syntax highlighting)
07:38:38 <CosmicRay> JaffaCake: excellent
07:38:58 <CosmicRay> JaffaCake: what are they? ;-)
07:39:25 <JaffaCake> CosmicRay: for Alex, Happy and Haddock I'm going to switch to using Cabal instead of the fptools build system, so I'm not concerned about keeping history for the build-system bits of these projects
07:40:00 <JaffaCake> basically I want separate GHC, Alex, Happy, Haddock repos
07:40:22 <JaffaCake> the fptools thing is confusing and daunting to newcomers
07:40:23 <CosmicRay> and have the remaining bits stay where they are?
07:40:31 <JaffaCake> yes
07:40:51 <CosmicRay> ok.
07:41:06 <CosmicRay> so can I just pull out those four dirs?
07:41:14 <shapr> malcolm: If we're going to have an editor war, it should involve intercontinental ballistic macros!
07:41:15 <JaffaCake> does that mean you'll have to do the conversion over again?
07:41:25 <CosmicRay> JaffaCake: yes.  but I am willing to do that.
07:41:31 <JaffaCake> great
07:42:24 <JaffaCake> so I'd like to have the alex,happy,haddock subdirs converted to darcs with history, and the rest of fptools as one big repo
07:42:53 <JaffaCake> I need to figure out what to do with H/Direct and the other stuff though
07:43:05 <CosmicRay> ok, so let me just make sure I understand everything correctly.  I should take the cvsroot from cvs.h.o and use the fptools module, splitting out those four dirs (ghc also, right?), then convert each, plus the remaining fptools, with history, to darcs?
07:43:08 <malcolm> Jaff
07:43:15 <malcolm> oops, JaffaCake
07:43:17 <Igloo> Is that a temporary thing, or do you envisage the libraries staying in a single repo forever?
07:43:43 <malcolm> oops again: tab completion not working.  JaffaCake: will the fptools library repo transfer to darcs?
07:43:48 <JaffaCake> CosmicRay: not the ghc subdir
07:43:58 <CosmicRay> oh ok, so ghc stays in fptools.
07:44:15 <CosmicRay> s/./?/
07:44:21 <JaffaCake> malcolm: yes (but not in one go, we're not pulling the rug out yet)
07:44:37 <JaffaCake> CosmicRay: yes
07:44:51 <CosmicRay> ok. got it.
07:44:55 <malcolm> JaffaCake: as I understand it, ghc depends on the base library, but all the rest could in theory be separate darcs repos, yes?
07:45:19 <JaffaCake> malcolm: that would be sensible, but I'm not sure that darcs handles nested repos
07:45:42 <malcolm> JaffaCake:, ah so my question is whether they need to be nested.
07:46:05 <CosmicRay> can someone remind me where on the cvs.h.o filesystem the fptools repo lies?
07:46:21 <JaffaCake> CosmicRay: /home/cvs/root
07:46:23 <CosmicRay> JaffaCake: it doesn't handle them automatically, but I believe it is possible to use them.
07:46:28 <CosmicRay> thanks
07:46:36 <malcolm> gotta go...
07:46:37 <pitecus> With emacs haskell-mode I get this indentation which looks a bit wierd. Is it correct?
07:46:38 <pitecus> if i `rem` k == 0
07:46:38 <pitecus>    then divisibles k (init+1) is
07:46:38 <pitecus> 	else divisibles k init is
07:46:51 <JaffaCake> CosmicRay: but hold off for a little while, I need to figure out what to do with libraries and the other bits
07:46:57 <CosmicRay> pitecus: yeah, I dislike the indentation there too.
07:47:06 <CosmicRay> JaffaCake: ok.
07:47:17 <CosmicRay> JaffaCake: let me know when you're ready to start.
07:47:42 <JaffaCake> where'd malcolm go?
07:47:45 <shapr> hej Lairs-, learning Haskell?
07:49:57 <shapr> One nice thing about GHC -smp is that I'll get to use BOTH cpus for darcs apply'ing. It's weird to see the GHC RTS migrating between my CPUs.
07:50:18 <CosmicRay> darcs is thread-aware?
07:50:53 * Igloo doubts SMP will make any difference for darcs apply
08:07:51 <shapr> CosmicRay: There are crude ways to automatically measure elegance/expressiveness via cyclomatic complexity, number of tokens compared among implementations, etc, see this paper - http://www.cs.stir.ac.uk/~kjt/techreps/pdf/TR141.pdf
08:08:42 <shapr> One amusing part about that paper is that it uses a version of Happy from 1996 or earlier for its preliminary results.
08:08:58 <CosmicRay> heh
08:12:42 <shapr> A short jaunt through CiteSeer for papers connected to this one implies to me that we may be able to automatically get a rough picture of code elegance by mixing and matching metrics.
08:13:31 <CosmicRay> shapr: I probably don't have time to hack up something like that, but I'd take patches ;-)
08:13:48 <shapr> Personally, I suspect that monads and arrows will smash OOP in terms of cyclomatic complexity differences.
08:13:57 <shapr> greetings Mr Fox!
08:14:05 <poetix> Gruntings!
08:14:15 <shapr> I remember reading through my first Yampa program thinking "where the heck is all the CODE?"
08:14:36 <xerox> Yampa?
08:15:01 <shapr> @google yampa haskell
08:15:02 <lambdabot> http://www.haskell.org/yampa/
08:15:08 <poetix> Who smashed Tom Robin in terms of cyclomatic complexity differences? "I", said the sparrow, "with my monads and arrows".
08:15:25 <CosmicRay> haha
08:15:36 <poetix> I agree, btw, that the "where the heck is all the CODE?" feeling is a common one with Haskell
08:15:58 <poetix> You just think, "this must be a sort of skeleton or toy app, this can't possibly *do* anything"
08:16:04 <xerox> Reactive?!
08:16:27 <earthy> hm. 'Type and data declarations are irrelevant, so are removed before counting.'
08:16:35 <earthy> I take issue with that paper, shapr. :)
08:17:09 * poetix backs up
08:17:48 <shapr> Hm, looks like Lairs- is actually a particularly sneaky spammer.
08:17:58 <poetix> That's a great title for a paper.
08:18:32 <poetix> Reminds me of Black Grape's song "Heroes": "Who's got the biggest...whos' got the biggest...who's got the biggest...BRAIN?"
08:18:53 <shapr> Lairs- sent me private messages asking me if I wanted to check out his Poker site.
08:19:14 <xerox> He asked me if I ever played proker.
08:19:16 <xerox> *poker
08:19:23 <shapr> ah, yes... definitely a spammer
08:19:25 <basti_> he did that to me too.
08:19:35 <poetix> A bot?
08:19:38 <basti_> prolly
08:19:41 <shapr> Probably
08:19:43 <basti_> where's the ircops?
08:19:56 <sethk> I'm insulted.  he didn't ask me.  :)
08:19:56 <shapr> Any staff here on #haskell?
08:20:26 <poetix> I wonder if vixen could be sent abroad to wreak chaos and confusion.
08:20:33 <xerox> Bother lilo, he like to bother the people with walls...
08:20:35 <ProfTeggy> Me neither, sethk.  Relax.  :-)
08:20:41 <shapr> Here's what I got: "<Lairs-> well i thought maybe ud like my site www.pokerpup.com" (site name changed)
08:20:50 <shapr> <Lairs-> it has tons of free tournaments with cash prizes everyday  <Lairs-> and lots of other poker stuff
08:21:34 <thaldyron> Hi, can someone advise me on this: For efficiency reasons I'm forced to use a datatype with non-nullary constructors as an array index type. Therefore I have to make it an instance of Ix and would have to define 'range' for all possible constructor combinations. Or is there another way?
08:23:36 <xerox> Do you buy any dead-tree-edition magazines?
08:23:45 <shapr> Not me, I'm too poor.
08:23:46 <xerox> Like, scientific american, or something.. ?
08:24:00 <poetix> I used to get New Scientist
08:24:01 <shapr> Oh wait, I get "Science News", because it's a gift subscription from someone else.
08:24:27 <earthy> thaldyron: um, that sounds off.
08:24:40 <xerox> I think I'm going to subscribe to the italian edition of the Scientific American...
08:24:42 <earthy> a datatype with non-nullary constructors as an array index for *efficiency* reasons?
08:25:40 <earthy> will a finite map (as in e.g. Data.Map) not do then?
08:26:37 <thaldyron> normally I would use a list/finite map but I really need fast lookup
08:26:46 <shapr> Did you guys get exactly the same messages from Lairs-?
08:27:12 <sethk> shapr, how would they know?
08:27:15 <Lemmih> Hurrah.
08:27:27 <sieni> "Our initial assessment is that they will all die"
08:27:28 <shapr> sethk: I'm pretty sure Lairs- is a scripted bot.
08:27:32 <earthy> thaldyron: Data.Map is optimised to provide you fast lookup
08:27:34 <Lemmih> dcoutts: Throwing Panic.Interrupt made everything much better (:
08:27:35 <shapr> Not even as good as vixen!
08:27:48 <sethk> shapr, yes, but if someone gets only one message, he can't know if someone else got the same message.  :)
08:27:50 * Lemmih will do a bit more testing before pushing.
08:28:08 <shapr> I suspect everyone gets the same series of messages.
08:28:15 <xerox> Lemmih: is it a solution to the panic! ? :D
08:28:40 <earthy> it is O(log n) even
08:28:41 <Lemmih> xerox: Unfortunately not.
08:29:26 <xerox> :-\
08:30:01 <thaldyron> earthy: mhm, thx I will give it try
08:30:28 <earthy> if you actually really *do* need constant-time lookup... well...
08:30:47 <earthy> then you're probably going to have to redesign anyway
08:33:57 <shapr> poetix: Oh hey, any more thoughts about Haskell on Heat?
08:41:02 <shapr> Sure is quiet today.
08:44:08 <Lemmih> shapr: Shouldn't you be busy writing fun Haskell code?
08:44:32 <poetix> shapr: yes, have a go at getting valid XHTML out of HaXml...
08:49:05 <sm> haskell in heat ?
08:49:14 * sm 's mind boggles
08:49:18 <Philippa> just what I was thinking...
08:49:27 <Philippa> I mean, I thought /I/ wrote dirty stuff about Haskell
08:49:54 <sm> look out scheme, python, ruby..
08:55:35 <Lemmih> JaffaCake: Does vshaskell remember instances? I got some code which uses an instance in Control.Monad.Error and it seems to keep the instance in scope even after the import is removed.
08:56:02 <JaffaCake> this may be a bug in GHC
08:56:32 <JaffaCake> IIRC, GHC keeps a single instance table and doesn't update it when it should
08:57:16 <JaffaCake> Lemmih: it would probably help if you could report it somehow, so we don't forget
08:57:16 <wagerlabs> hello everyone
08:57:41 <Lemmih> Hi wagerlabs.
08:57:56 <wagerlabs> what is the ghci command that shows types (exports?) in a module?
08:59:34 <Lemmih> wagerlabs: :browse?
08:59:39 <wagerlabs> lets see
08:59:57 <wagerlabs> Lemmih: yes, thank you!
09:03:25 <Lemmih> JaffaCake: How do you make a StringBuffer from the input data, btw?
09:03:47 <JaffaCake> what form is your input data in?
09:04:52 <Lemmih> It's a null terminated array of CChar's.
09:05:14 <JaffaCake> a StringBuffer is a ByteArray#, so you have to copy the data
09:05:26 <JaffaCake> we do this in VH
09:06:47 <JaffaCake> Lemmih: ask me tomorrow, I'll send you some code.  I've got to go now...
09:07:41 <Lemmih> Urk
09:07:54 * Lemmih just pasted some code on the wiki.
09:12:02 <poetix> OK, so what would be a better (more professionally credible, say) name for a Haskell-based web framework than "Haskell on Heat"?
09:12:32 <poetix> Haskell in a Handcart?
09:13:56 <Lemmih> Got an URL?
09:14:16 <earthy> Vindaloo?
09:14:32 <earthy> or even Web Vindaloo?
09:14:34 <poetix> Why Vindaloo?
09:14:49 <earthy> Haskell B. Curry was the namesake of Haskell the programming language
09:14:59 <earthy> we all know about Curry Vindaloo, I hope
09:15:05 <earthy> so Web Vindaloo would fit.
09:16:18 <Lemmih> dcoutts: ping.
09:16:29 <earthy> ofcourse, this is in keeping with the Haskell on Heat theme. ;)
09:16:53 <shapr> Webby Boomerang schvung Harrow Silk``Shirt Kombinator Wugs funkcore ChurchAndSTate
09:17:15 <shapr> These names stolen from bringert's page - http://www.cs.chalmers.se/~bringert/wiki/WebAppsFramework
09:17:36 <shapr> I think ChurchAndSTate is particularly cute.
09:19:07 <earthy> hm. in that vein Alonso would also be a nice name
09:22:06 <poetix> Gonzo
09:22:33 <poetix> Gonzo is a great name for a web framework - it suggests mad ease-of-use, just sling yer shit together and you're ready to go, man
09:23:03 <poetix> Also /some/ people's favourite muppet
09:24:28 <shapr> Hm, gonzo.org appears to be Hunter S. Thompsno
09:24:37 <dcoutts> Lemmih, pong
09:24:52 <xerox> ChurchAndSTate is great, hah.
09:25:32 <dcoutts> Lemmih, good to hear that the thread killing is working better
09:25:40 <poetix> Babbling Brooks
09:25:57 <poetix> (Brooks being what the B. in Haskell B. Curry stands for)
09:26:21 <davve> are you naming a web framework?
09:26:29 <davve> dcoutts, how's hIDE going?
09:26:42 <dcoutts> davve, ok at the moment
09:26:48 <dcoutts> davve, still early days however
09:27:10 <shapr> You could call it Dissed Tofua.
09:27:11 <dcoutts> davve, if you get some time I've got some GUI code for you to look at :-)
09:27:21 <davve> dcoutts, sure!
09:27:30 <davve> dcoutts, I can't build anything though
09:27:41 <dcoutts> davve, ah because of ghc-src
09:27:47 <davve> mmh :/
09:27:52 <dcoutts> davve, well you can still build all the other hIDE plugins
09:27:58 <poetix> I'm liking Schwung, which is also quite punchy
09:28:04 <davve> dcoutts, right
09:28:12 <shapr> schvung or schwung?
09:28:27 <shapr> Schvung is Swedish, schwung is German.
09:28:29 <dcoutts> davve, just modify the build.sh script, remove the CommonSense & HaskellSense from the packages that get built
09:28:44 <shapr> schvung.org is not taken.
09:28:51 <dcoutts> davve, I'm using threads and channels as an alternative way of dealing with state in the GUI. Rather than lots of IORefs/MVars.
09:28:51 <davve> dcoutts, yeah.. I'll reboot to ubuntu.
09:29:19 <dcoutts> davve, you might be interested in how that works compared to how it was done in Haste
09:29:20 * Lemmih pushes.
09:29:23 <poetix> Maybe Schvung, because then people would pronounce it right
09:29:24 <davve> dcoutts, hmm ok. Btw, what was the reason for using MVar instead of IORef?
09:29:26 * dcoutts pulls
09:29:34 <shapr> poetix: And even more amazingly, only 682 hits on google. Seems like an excellent google/domain choice.
09:29:35 <dcoutts> davve, thread safty
09:29:51 <dcoutts> davve, Gtk2Hs supports multiple threads accessing the GUI
09:29:58 <davve> dcoutts, ok
09:29:59 <shapr> Also, schvung is my favorite Swedish word, so I sure would like that name.
09:30:01 <dcoutts> and I intend to take advantage of that
09:30:24 <poetix> I wonder what it could plausibly be claimed to be an acronym for
09:30:26 <davve> dcoutts, are you going as far as having each plugin in a separate thread?
09:30:38 <dcoutts> davve, no. At the moment I've got one per window.
09:30:58 <dcoutts> davve, and the file browser widget uses one for itself too.
09:31:05 <davve> dcoutts, okay.. are you planning on using the libbegg-dock thing btw?
09:31:10 <shapr> SuperCombinator Haskell Verified User Neutral Grapple
09:31:17 <dcoutts> davve, I thought you might like to try that :-)
09:31:24 <poetix> scHvung!
09:31:39 <shapr> I like it!
09:31:45 <davve> dcoutts, I could take a look at it
09:32:06 <Lemmih> libbegg-dock?
09:32:08 <shapr> CosmicRay: How do you get domains for $15?
09:32:14 <dcoutts> davve, but it's something we could do later, there are probably other priorities
09:32:14 <davve> Lemmih, yep
09:32:22 <Lemmih> davve: What's that?
09:32:28 * poetix leaves for home
09:32:58 <dcoutts> davve, the MainWindow API I've got should not preclude other visual layouts. So we could do other implementations later.
09:33:04 <rep> do you agree that GHC should complain when trying to compile code that uses forkOS without -threaded, instead of compiling happily, and crashing the program when it tried to create a new thread?
09:33:19 <Philippa> yes
09:33:22 <Lemmih> no
09:33:23 <dcoutts> rep, no, because it depends on how you link it
09:33:32 <Philippa> ah, didn't know that - in that case, no
09:33:38 <rep> dcoutts what do you mean
09:33:43 <davve> dcoutts, definitely. One thing we learned from Haste dev was to keep priorities straight, focusing on getting a minimal, usable core working (which we didn't)
09:33:44 <dcoutts> rep, you might build a package and then I use it in a -threaded program
09:34:11 <rep> dcoutts when linking, then
09:34:29 <dcoutts> rep, the consumer of the package gets to choose which rts to use
09:34:59 <Philippa> an option to complain'd be a good start I guess
09:35:14 <dcoutts> rep, otherwise we'd need many versions of each package. The prof verson, the single threaded version, the multi-threaded version, the profiled multi-threaded version...
09:35:31 <Lemmih> Philippa: It would be a dirty hack at best.
09:35:38 <davve> Lemmih, it's a docking widget tool used in gtk-apps
09:35:48 <dcoutts> Philippa, the problem is you don't know until later if it's going to use the threaded or smp rts
09:35:49 <Philippa> yeah, I know. May as well provide a fake forkOS with the wrong type or something
09:35:49 <rep> but really crashing because it tried to create a new thread is lame
09:36:16 <dcoutts> rep, it doesn't crach, it throws an error which you can catch and deal with.
09:36:16 <Philippa> does it at least crash out nicely ("Error: program not compiled with -threaded")?
09:36:39 <Lemmih> rep: Then just make your problem use forkIO if the RTS is not threaded.
09:36:45 <Lemmih> s/problem/program/
09:36:52 <dcoutts> rep, so if you can do something in the case of a non-threaded rts then you can do that, or you can terminate the program more gracefully.
09:37:33 <rep> Lemmih how?
09:37:42 <dcoutts> davve, yes focusing on getting a usable and extendable core is important.
09:37:45 <Lemmih> @type Control.Concurrent.rtsSupportsBoundThreads
09:38:03 <Lemmih> Hm, lambdabot is gone.
09:38:34 <rep> Lemmih i see, thanks
09:38:37 <Lemmih> Control.Concurrent.rtsSupportsBoundThreads :: Bool
09:38:38 <ProfTeggy> Bye all
09:38:45 <araujo> Hello.
09:44:21 <dcoutts> Lemmih, you pinged me, did you have a Q? or an update?
09:44:56 * xerox yanws
09:45:09 <dcoutts> Lemmih, btw we can't use -threaded, it'll break the GUI
09:46:00 <dcoutts> do you really need it?
09:51:51 * Lemmih tries to remember the question he had for dcoutts.
09:53:13 <Lemmih> dcoutts: Not really. It just feels more responsive.
09:53:27 <dcoutts> Lemmih, ok because it really will break Gtk+ :-)
09:54:05 <dcoutts> Lemmih, I ca make the timeslices shorter if it feels sluggish
09:54:06 <autrijus> hm
09:54:13 <Lemmih> Aren't haskell threads still executed in a single thread?
09:54:22 <autrijus> I have hide Cabal-1.1.4 and exposed Cabal-1.0
09:54:24 <xerox> http://linuxgazette.net/119/oregan.html
09:54:31 <autrijus> but then GHC can't find Distribution/Simple.hi anymore
09:54:39 <dcoutts> Lemmih, yes but it'll run Gtk+ calls in random OS threads which will break Gtk+
09:54:40 <autrijus> even though package.conf looks correct
09:54:47 <autrijus> if I hide 1.0 again and expose 1.1.4, it works
09:54:52 <autrijus> anyone ran into that before?
09:54:55 <autrijus> it's kind of annoying.
09:55:16 <Lemmih> autrijus: Can you locate the interface files manually?
09:55:19 <autrijus> (ghc 6.4.1)
09:55:22 <autrijus> why, yes
09:55:30 <autrijus> /usr/local/lib/ghc-6.4/imports/Distribution/Simple.hi
09:55:50 <dcoutts> Lemmih, Gtk+ is basically single threaded
09:55:50 <autrijus> er I mean, /usr/local/lib/ghc-6.4.1/imports/Distributi
09:55:57 * autrijus ponders
09:56:00 <shapr> umask problems? maybe root isn't installing with ugo+r ?
09:56:04 <shapr> I have that problem regularly.
09:56:19 <autrijus> I have a permissive umask.
09:56:52 <autrijus> and I can access that file just fine
09:58:11 <autrijus> and it's weird that
09:58:11 <autrijus> hs-source-dir: src
09:58:20 <autrijus> triggers a warning for Cabal-1.1.4 and I can't turn it off.
09:58:36 <autrijus> but hs-source-dirs is not recognized by stock cabal.
09:59:15 <autrijus> so it leaves me with the choice between bundling a copy of renamed cabal, or ignoring 1.1.4 for now (but then I ran into the ghc pkg problem)
10:00:04 <rep> httpd: internal error: stg_ap_pv_ret
10:00:04 <rep>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
10:00:04 <rep>     or http://www.sourceforge.net/projects/ghc/
10:00:24 <autrijus> aha, I see why
10:00:33 <autrijus> it's Setup.o was around
10:00:45 <autrijus> and it's prebound to 1.1.4 symbols, and runghc won't trigger a rebuild between ghc-pkg changes.
10:00:53 <autrijus> naughty, naughty program!
10:12:49 <luqui> where is lambdabot?
10:21:09 <shapr> Stuck in Australia.
10:22:10 <autrijus> yay, Pugs is cabalified and Pugs.hs is installed with public API.
10:22:23 <autrijus> one step closer toward hIDE pluginhood.
10:24:45 <shapr> that'll be nifty
10:25:15 <xerox> What for?
10:26:19 <shapr> pugs-api will mean that Haskell and Perl6 will have equal support in hIDE.
10:27:57 <xerox> ...what for?  <grin>
10:28:43 <autrijus> for fun, silly :)
10:29:10 <Philippa> so the poor perl6 users become even more dependant on Haskell until one day they switch over entirely, duh
10:30:11 <Cale> Has Larry Wall started learning Haskell? I seem to recall he mentioned considering it.
10:30:15 <autrijus> there is no switch over.
10:30:16 <luqui> yeah he has
10:30:17 <autrijus> Cale: he had.
10:30:35 <autrijus> there is no "switch over" for a borg, no cap'tn
10:30:39 <luqui> he started talking about MonadPlus on sixperl
10:30:49 <shapr> Yeah, really. Haskell and Perl are both just programming.
10:31:04 <shapr> It's all programming, and we try to find the best parts.
10:31:13 <xerox> autrijus, then Kirk will be b0rgified and kill them all thinking it's the Right Thing(TM) to do!
10:32:02 <shapr> I think it's more like The Federation upgrading themselves with some Borg technology while the Borg learn the advantages of discord.
10:32:40 <wagerlabs> gents, anyone wants to talk endian-ness?
10:32:50 <autrijus> The only good endian is a dead endian!
10:32:57 * shapr grins
10:33:29 <wagerlabs> yeah, yeah, keep laughing
10:33:45 <wagerlabs> i have great plans for haskell in the next two weeks but i'm stuck on simple things
10:33:56 <wagerlabs> and no reading of haskell papers is helping :D
10:34:38 <wagerlabs> in the end i'll be forced to go with erlang
10:34:41 <autrijus> okay. sorry :) what about endianness?
10:34:56 <autrijus> I program in AIX with GHC with low level data, but somehow it did not manifest
10:35:56 <wagerlabs> autrijus: well, were is that link...
10:36:48 <Cale> wagerlabs: you can't just convert to word8's and permute things a bit?
10:37:18 <wagerlabs> http://www.archivum.info/haskell-cafe@haskell.org/2005-10/msg00017.html
10:37:35 <wagerlabs> cale: i don't get how to do it in style
10:37:42 * wagerlabs is stylish, he
10:38:17 <wagerlabs> Cale: i'm reading floats, doubles, 16 and 32 bit ints from a socket. byte stoo.
10:38:54 <wagerlabs> cale: i suppose i can read word32, 64, etc. and then do some massaging but i can't figure out how to do it with a type or typeclass, etc.
10:38:56 <Cale> okay, and some of this data is coming in with the wrong endianness?
10:39:12 <wagerlabs> Cale: kind of like BigEndian <something> or maybe Endian <Something> Big/Little
10:39:27 <Philippa> do you need that, or just network<->host?
10:39:41 <wagerlabs> Cale: there's no wrong endianness. the server is on wintel but i can be on mac osx/powerpc when testing and wintel when the client is running my code
10:40:01 <wagerlabs> the server on wintel sends everything little-endian
10:40:12 <wagerlabs> everything is int32, int64, byte and double
10:40:31 <Cale> Is Data.Bits inconsistent in what it does between platforms?
10:40:37 <wagerlabs> zero-terminated strings too, go figure
10:40:52 <wagerlabs> Cale: I wouldn't know re: Data.Bits
10:41:43 <Philippa> wagerlabs: you're looking to do network<->host-style translations then, no?#
10:41:59 <wagerlabs> the consistent thing is that each packet is prefixed by 4-byte length (of the packet + the data, not the following data) and that data is little-endian
10:42:16 <wagerlabs> Philippa: no :-) little-endian to host
10:42:32 <wagerlabs> Philippa: and host to little-endian
10:42:59 <Cale> Perhaps it would be best to make an instance of your Packet class for a newtype of Word16/Word32/Word64 which installs the Word8's in reverse order.
10:43:00 <Philippa> surely it's easier to shove out network format all the time?
10:43:27 <wagerlabs> Philippa: apparently not on windows
10:43:41 <wagerlabs> Philippa: i also do not have control over that. i cannot change their code.
10:44:09 <wagerlabs> Cale: what do you mean? unpack the packet into a list of word8s like you suggested in that email and then reverse some things?
10:44:17 <wagerlabs> http://www.archivum.info/haskell-cafe@haskell.org/2005-10/msg00017.html
10:44:32 <wagerlabs> this looked promising but i don't understand why i need the peek0, peekR, etc.
10:44:53 <Philippa> wagerlabs: fair enough if it's beyond your control. Windows does actually have the ability to do host<->network stuff
10:45:17 <Korollary> wagerlabs: Why don't you do a runtime check with System.Info.arch and perform the necessary endian conversions ?
10:45:20 <Philippa> it would be nice if I could actually find the conversions in the haskell libs though
10:45:26 <wagerlabs> Philippa: of course windows does. i was saying it in jest. it's just easier for people to serialize &data, sizeof(data) and not give a damn about byte order
10:45:38 <wagerlabs> Philippa: their code will always work with their own clients
10:46:06 <wagerlabs> Korollary: that's not an issue. there's even a  bit of TH code that was posted that does the checks
10:46:43 <Cale> Well, you read in some Word8's and you just need to interpret them in the right way, right?
10:47:08 <Philippa> gotta go. Good luck
10:47:15 <xerox> Bye Philippa!
10:48:01 <Cale> Currently, the way which we were combining Word8's into larger words was using one particular ordering. You could simply use the other, but presumably you still want the default to be the way it is now.
10:49:15 <Cale> So you could make a newtype wrapper which would instruct the class to read the Word8's for that element in reverse.
10:49:55 <wagerlabs> Korollary: the question is how to implement it elegantly as opposed to a hack. i would like to "compose" a packet from fields of different types for example
10:49:55 <wagerlabs> Korollary: and possibly even specify the endianness of the packet as opposed to each field
10:49:55 <wagerlabs> then i can reuse the packet definition to write big or little endian
10:49:55 <wagerlabs> Korollary: Prelude> :b System.Info.arch
10:49:57 <wagerlabs> syntax:  :browse <module>
10:49:59 <wagerlabs> doesn't seem to work
10:50:03 <wagerlabs> Cale: but the idea of reading the whole thing in, converting it to a list of word8s is interesting
10:50:21 <wagerlabs> cale: let me look at your email again...
10:50:52 <Cale> I didn't actually suggest a solution to this problem in the emails before, but it's solvable using the same technique
10:51:56 <wagerlabs> Cale: so would I have an if be then ... in each read/write method?
10:52:56 <Cale> Well, do you need to do this in a system-dependent way?
10:53:14 <Cale> Or should the code always do the same thing regardless of which machine it's running on?
10:53:15 <wagerlabs> Cale: what do you mean?
10:53:36 <Cale> (do you need to check the endianness of the computer that's reading the packets)
10:54:03 <wagerlabs> Cale: well... of course i do. because if i'm on wintel then i don't need to do conversions if i'm reading or writing little-endian
10:54:07 <Cale> okay
10:54:36 <Cale> hmm...
10:54:43 <wagerlabs> but i can use that line of code that Marc Ziegert sent to get the endianness of the platform
10:54:56 <wagerlabs> be = $( (1::CChar)/=(unsafePerformIO $ with (1::CInt) $ peekByteOff `flip` 0) ) :: Bool
10:55:21 <wagerlabs> Cale: do you understand the use of peek/poke, etc. in Storable?
10:55:25 <Cale> yeah
10:55:45 <Cale> they write to pointers
10:55:51 <wagerlabs> Cale: cause I don't. maybe if i did then i could use his solution
10:55:53 <Cale> (and read from them)
10:55:59 <wagerlabs> http://www.archivum.info/haskell-cafe@haskell.org/2005-10/msg00017.html
10:56:06 <Cale> you might want to read the FFI documentation
10:56:32 <wagerlabs> Cale: right, ok. btw, in that code peek and poke write a single byte? or can they write multiple?
10:56:54 <Cale> they write a single data structure of whatever size
10:57:03 <CosmicRay> shapr: gandi.net
10:57:16 <Cale> what they do depends on the instance of Storable for the type at which they are applied
10:58:20 <wagerlabs> Cale: hmm... where's the FFI documentation? the '98 report?
10:58:44 <ndm> wagerlabs, the FFI amendum
10:58:48 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
10:58:55 <Cale> but that seems down for me
10:58:57 <xerox> @where FFI
10:59:15 <xerox> @where is lambdabot?
10:59:27 <wagerlabs> Cale: for me too
10:59:47 <Cale> www.cse.unsw.edu.au seems to go down a lot
11:00:28 <Cale> I might have a copy I could put online
11:01:26 <Cale> http://vx.hn.org/autoshare/ffi.ps.gz
11:01:30 <heatsink> I don't know what specifically you're looking for; there's some ffi stuff on the wiki at http://www.haskell.org/hawiki/FfiCookbook
11:01:52 <wagerlabs> looking
11:02:11 <Oejet> And also in TMR!
11:02:44 <Cale> that ps.gz will tell you all about Ptr and Storable and such
11:03:42 <wagerlabs> Cale: thank you!
11:07:02 <wagerlabs> i would love to piggy-back on NewBinary
11:09:08 <wagerlabs> thank you cale and everyone
11:22:48 <wagerlabs> are Word8, Int8, etc. foreign types?
11:23:11 <wagerlabs> yep
11:24:26 <dcoutts> wagerlabs, no, the foreign types are CInt, CString, C.. etc. But of course Word8 etc are easily convertable into the foreign types.
11:24:50 <wagerlabs> dcoutts: Word8, etc. are exported by foreign, though
11:25:00 <wagerlabs> what's the difference between Word8 and Int8?
11:26:08 <heatsink> word8 is unsigned, int8 is signed
11:27:00 <Korollary> word8 comes from Data.Word actually
11:27:48 <wagerlabs> :b Foreign shows Word8, Int8, etc.
11:27:50 <wagerlabs> strange
11:27:58 <Korollary> it reexports them
11:28:22 <wagerlabs> i see /reexports/
11:29:03 <wagerlabs> so how do you convert between, say, Haskell float and CFloat?
11:30:30 <Igloo> realToFrac
11:31:28 <Korollary> ?
11:31:30 <wagerlabs> what about CInt to Int?
11:31:39 <Igloo> fromIntegral
11:31:46 <wagerlabs> ah
11:31:48 <wagerlabs> thanks
11:31:58 <Korollary> CInt is an instance of Integral ?
11:32:21 <Korollary> yes
11:32:31 <Korollary> neat
11:33:17 <wagerlabs> how would I read a CFloat from a buffer i wonder?
11:33:58 <wagerlabs> oh, write, Storable
11:34:48 <metaperl> I would like to know how to create an infinite lazy list of function applications as described in my blog post here: http://sequence.complete.org/node/114
11:35:30 <Igloo> iterate
11:35:35 <Cale> iterate, yeah
11:35:39 <metaperl> iterate?
11:35:41 <metaperl> @type iterate
11:35:52 <Cale> lambdabot seems down
11:35:52 <metaperl> @hoogle iterate
11:36:01 <Cale> iterate (+1) 0
11:36:18 <dcoutts> :t iterate
11:36:18 <dcoutts> iterate :: (a -> a) -> a -> [a]
11:36:25 <dcoutts> take 10 $ iterate (+1) 0
11:36:25 <dcoutts> [0,1,2,3,4,5,6,7,8,9]
11:36:46 <Cale> iterate f x = x : iterate f (f x)
11:37:10 <metaperl> sweet
11:37:21 <Cale> (it's in the prelude)
11:37:21 <metaperl> now why can't the function be a -> b
11:37:33 <Cale> because you have to apply it to its result
11:37:34 <basti_> because that would be similar to unfold then ;)
11:37:43 <metaperl> Cale: I was reading the List part of the prelude yesterday... I didn't finish though
11:38:10 <metaperl> unfold... I know about fold... oh well, yes, as soon as I finish SJT I'll hit more of the Prelude
11:38:58 <metaperl> thanks guys
11:39:01 <ndm> http://www-users.cs.york.ac.uk/~ndm/hoogle/
11:39:07 <ndm> hoogle, for when lambdabots down
11:39:15 <ndm> http://www-users.cs.york.ac.uk/~ndm/hoogle/?iterate
11:39:41 <metaperl> ndm: hoogle is great! it would be nice if you could also see the function implementation isntead of just the description
11:40:14 <ndm> metaperl, hoogle for map and you can
11:40:27 <ndm> i intend to add all the implementations in eventually...
11:41:01 <Cale> ndm: you should include the constructors for library types
11:41:15 <metaperl> ndm: why does the URL never change. it makes it impossible to point people to hoogle results
11:41:18 <ndm> Cale, hoogle3 :) - its been added in the development version
11:41:34 <ndm> metaperl, because it doesn't reload the whole thing, just the bottom frame
11:41:35 <metaperl> ndm: did you try to get the hoogle domain name?
11:41:48 <ndm> if/when i move over to full page hoogle it will do
11:41:57 <ndm> but hoogle.net is already owned by a porn compnay
11:42:01 <ndm> ditto for most other hoogles
11:42:06 <metaperl> ndm: what CGI library did you use?
11:42:08 <ndm> and i don't have any more money to buy domains
11:42:18 <ndm> metaperl, raw haskell, no CGI libraries in sight
11:42:24 <metaperl> :)
11:42:28 <Cale> perhaps it could get a haskell.org subdomain
11:42:36 <metaperl> hoogle.haskell.org
11:42:42 <ndm> that would suit me
11:42:48 <ndm> or just haskell.org/hoogle
11:42:54 <Cale> (or both)
11:42:56 <ndm> to follow all the other haskell tools
11:43:15 <shapr> der_eq: cool! Your first release!
11:43:38 <der_eq> shapr: thanks :)
11:43:58 * CosmicRay perks up at the mention of a release
11:44:02 <CosmicRay> what is this that's being released?
11:44:09 <Cale> ah
11:44:17 <Cale> check the mailing list :)
11:44:28 <Cale> shapr: you're quick :)
11:44:35 <CosmicRay> metaperl: how's the new manual html thing on sequence working out for you?
11:44:59 <metaperl> CosmicRay: so far so good I guess... everything is working at sequence just fine for me
11:44:59 <shapr> Cale: sometimes...
11:45:08 <CosmicRay> metaperl: good
11:45:10 <metaperl> I forgot what I complained about :)
11:45:16 <CosmicRay> metaperl: formatting of code
11:45:22 <metaperl> oh yeah spaces
11:45:25 <metaperl> now I remember
11:45:32 <CosmicRay> yeah if you do manual html, you can now do pre and xmp tags.
11:45:55 <metaperl> oh ok
11:46:02 <CosmicRay> metaperl: did you see my suggestion for your pattern matching problem?
11:46:14 <metaperl> drupal is written in PHP right? pattern matching... hmm, let me go look
11:46:26 <CosmicRay> metaperl: it was posted on your blog today or yesterday
11:46:57 <metaperl> CosmicRay: yes, I'm looking now
11:46:58 <Cale> what's xmp? I don't see it in the HTML 4 spec...
11:47:09 <magnus-> Is there a way to enforce that a value is only used once in haskell?
11:47:17 <magnus-> this would eliminate a lot of bugs for me
11:47:27 <CosmicRay> Cale: it's a super-extra-special version of pre.  even embedded chars like < and & are not interpreted, except for the sequence </xmp>
11:47:39 <Cale> ah
11:48:05 <metaperl> magnus-: what do you mean?
11:48:13 <metaperl> magnus-: why would that eliminate bugs?
11:48:21 <magnus-> metaperl: like for example (number,rng') = randomR (1,6) rng
11:48:27 <magnus-> here I don't want rng to be used any more
11:48:28 <Cale> magnus-: use a monad to thread the value
11:49:18 <basti_> CosmicRay: whats that good for? html represents < as &lt; and & as &amp; iirc.
11:49:34 <Cale> magnus-: check out http://www.haskell.org/hawiki/MonadTemplateLibrary_2fMonadRandom
11:49:39 <CosmicRay> basti_: so that you don't have to manually convert instances of < to &lt; in your code.
11:49:46 <magnus-> Cale: alright
11:50:06 <magnus-> Cale: I was hoping for a simpler solution but this will be ok
11:50:15 <magnus-> cheers
11:50:18 <basti_> CosmicRay: so, for laziness? ;)
11:51:04 <CosmicRay> basti_: err, convenience ;-)
11:51:05 <magnus-> I want to be able to explain my program to people without deep maths insigt
11:51:12 <magnus-> because it's for some statistics
11:51:26 <Cale> use do notation :)
11:51:29 <magnus-> monads are just plain hard to grasp
11:51:37 <basti_> monads are not hard to grasp.
11:51:41 <magnus-> for me they are :)
11:51:45 <basti_> ; in C programs behave like >>=
11:51:52 <Cale> Monads are merely hard to explain :)
11:51:56 <Cale> heh
11:51:57 <basti_> nobody has ever told you, thats the problem.
11:52:08 <ndm> for me, monads are hard to grasp...
11:52:17 <basti_> thats just an illusion.
11:53:08 <Cale> has everyone read MonadsAsContainers? :)
11:53:24 <magnus-> I think I've read every tutorial out there almost
11:53:41 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
11:53:42 <tic|away> magnus-, I don't quite undestand monads, I just think of them as boxes encapsulating state.
11:54:51 <basti_> the problem is this scary word "monad". Whats far more important than the monad itself is its bind operation imo.
11:55:23 <basti_> a value of type "IO a" is an IO script that delivers an a. not more and not less.
11:55:39 <basti_> and >>= binds two IO scripts so that one gets the other's result
11:55:45 <autrijus> I think we should rename "moand" as "actiontainer"
11:55:53 <Cale> hehe
11:55:55 <autrijus> except "actiontainer" is really too long.
11:55:58 <basti_> -g-
11:56:04 <autrijus> so maybe just "actainer"
11:56:08 <basti_> and it sounds microsoft.
11:56:12 <heatsink> :)
11:56:13 <basti_> close to activeX
11:56:14 <heatsink> sequencer
11:56:23 <heatsink> It describes how to link actions together.
11:56:24 <basti_> sequencer would be nice yes.
11:56:43 <autrijus> "the IO sequencer"
11:56:46 <autrijus> I like that.
11:56:46 <Cale> except that you don't always think of them as sequences of actions :)
11:56:54 <basti_> Cale: you don't?
11:56:54 <Cale> but yeah
11:57:04 <autrijus> "the List sequencer" and "the Maybe sequencer" sounds less good
11:57:05 <Cale> not necessarily
11:57:06 <autrijus> but still acceptable
11:57:21 <magnus-> I don't actually want to do any manual sequencing
11:57:31 <Cale> magnus-: you don't?
11:57:39 <magnus-> I want dependencies to automatically resolve
11:57:40 <basti_> then you'll be fine without monads too
11:57:50 <autrijus> "the IO doer"
11:57:52 <basti_> you're looking for dataflow semantics! :D
11:57:53 <autrijus> "the Maybe doer"
11:57:57 <autrijus> "the do notation denotes a doer"
11:58:05 <magnus-> basti_: yes, pretty much
11:58:18 <magnus-> and uniqueness types/ linear types
11:58:25 <basti_> magnus-: sadly that would involve comonads.
11:58:45 <basti_> which will scare you even worse
11:58:57 <Cale> comonads are not any scarier than monads
11:58:58 <magnus-> uniqueness would be enough (for this problem)
11:59:32 <basti_> what do you mean by uniqueness?
11:59:38 <basti_> clean's solution for this problem?
11:59:46 <magnus-> compiler-enforced checking that a value is used only once
11:59:46 <Cale> basti_: yeah
11:59:51 <basti_> or really "uniqueness types" (which would elude my grasp)
12:00:06 <basti_> magnus-: haskell doesn't do that.
12:00:11 * heatsink wants commutative monads
12:00:18 <Cale> heatsink: me too :)
12:00:35 <basti_> except for enforcing that, for example, all IO scripts have a type like "IO a"
12:00:53 <basti_> the unique thingie is hidden in the Monad
12:00:57 <Cale> very few monads that we use right now are commutative though.
12:01:15 <basti_> and enforced to be unique by the type of >>=
12:01:21 <heatsink> sure, but the ones that are are very annoying to have to put in IO
12:01:39 <Cale> heatsink: well, you don't have to put them in IO
12:01:40 <basti_> whats the problem? ;)
12:01:44 <heatsink> unique ID generation is the big one for me.
12:01:58 <magnus-> basti: IO monad is more or less making sense to me now
12:02:08 <Cale> heatsink: that's just a state monad :)
12:02:24 <heatsink> Cale: then it's not commutative, though
12:02:30 <Cale> right
12:02:31 <basti_> magnus-: thats good.
12:02:37 <basti_> hello cooz
12:02:41 <cooz> hello
12:03:01 <basti_> but, isnt there something about StateT?
12:03:03 <Cale> but it basically is if you don't have full access to the state
12:03:29 <Cale> like, if you used a newtype and restricted yourself to generating new IDs
12:03:42 <Cale> and you don't care what the actual IDs are
12:03:49 <Cale> then it's commutative :)
12:04:16 <heatsink> Cale: I don't understand.  Don't I still have to give it an explicit order for how I want to generate the IDs?
12:04:16 <magnus-> commutative wrt to which operator?
12:04:26 <heatsink> magnus-: wrt >> and >>=
12:05:01 <heatsink> I think it needs to be said a little more carefully, but basically, it commutes with respect to bind
12:05:09 <Cale> heatsink: well, it's noncommutative if you consider what the actual IDs are, but commutative if you only care that they're distinct.
12:05:16 <heatsink> right.
12:05:56 <Cale> so if you create a type where it's only possible to determine equality of the values, but not to observe them otherwise, then it's okay :)
12:06:22 <Cale> (which can be done by using the module barrier)
12:06:33 <magnus-> is a >> b = a >>= (\ () -> b) ?
12:06:58 <Cale> a >> b = a >>= (\_ -> b)
12:07:13 <magnus-> thx
12:07:24 <Cale> that is, a doesn't have to be m ()
12:07:34 <magnus-> I see
12:07:47 <wagerlabs> anyone sees a problem with this:
12:07:48 <wagerlabs> be = $( (1::CChar) /= (unsafePerformIO
12:07:48 <wagerlabs>                       $ with (1::CInt)
12:07:48 <wagerlabs>                       $ peekByteOff `flip` 0) ) :: Bool
12:08:10 <basti_> besides "unsafePerformIO" wagerlabs ?
12:08:10 <wagerlabs> i'm getting
12:08:13 <wagerlabs>     Couldn't match `Language.Haskell.TH.Lib.ExpQ' against `Bool'
12:08:13 <wagerlabs>       Expected type: Language.Haskell.TH.Lib.ExpQ
12:08:13 <wagerlabs>       Inferred type: Bool
12:08:44 <Cale> the $(...) that's wrapping it makes it a TH splice
12:08:44 <basti_> uhm
12:08:55 <Cale> but I'm not sure why it's a TH splice
12:09:11 <wagerlabs> Cale: so that it's done at compile-time?
12:09:26 <wagerlabs> it must be done at compile-time for sure
12:09:39 <wagerlabs> to determine endianness of the host platform
12:09:53 <basti_> ?
12:09:58 <basti_> how's that supposed to work?
12:10:00 <Cale> er, is it going to be compiled and run on different machines?
12:10:04 <Igloo> You probably want lift of that
12:10:08 <wagerlabs> Cale: for sure
12:10:08 <heatsink> Cale: sure, I can do it that way, but I have to implement the type using unsafePerformIO because there's no pure functional way to make unique IDs...
12:10:10 <CosmicRay> any perlers here can tell me why this is behaving weird:
12:10:12 <CosmicRay>         print "\n*** IMPNAME: $impname\n";
12:10:12 <CosmicRay> 	# Note:  We may need to append some ancillary data as well:
12:10:12 <CosmicRay> 	if ( $impname == "gnat") {
12:10:12 <CosmicRay> 	    my $pck_src = "bench/$benchdir/pck_$benchmark.$tag" . "$impl"
12:10:19 <autrijus> CosmicRay: yes, you want eq.
12:10:21 <CosmicRay> it's executing the stuff in the block even when $impname is not gnat.
12:10:21 <autrijus> not ==
12:10:22 <Cale> heatsink: what?
12:10:31 <autrijus> because there is no generic comparison in perl5 ;)
12:10:36 <CosmicRay> thanks autrijus
12:10:38 <basti_> afaics you can't determine endianness without exchange with the outside world
12:10:38 <Cale> heatsink: sure there is, if you can only get them inside the monad
12:10:40 <Igloo> You can do IO in the Q monad
12:10:44 * CosmicRay goes to report this bug to the shootout folks.
12:10:50 <Cale> (and observe them inside the monad)
12:10:50 <CosmicRay> looks like it's been there for ages ;-)
12:10:53 <wagerlabs> Igloo: sorry, lift where?
12:11:13 <basti_> imo there's no way to write a routine in a HLL that changes behaviour on a different-endian machine
12:11:50 <wagerlabs> so can someone tell me why that code does not compile?
12:11:54 <heatsink> Cale: but that's what I don't like.  The monad makes sequential code out of what could be pure functional code.
12:12:02 <autrijus> the Q monad is all-powerful, because it came out straight from Star Trek
12:12:10 <gtn> What is a monad
12:12:21 <basti_> gtn: a very nice thing.
12:12:24 <Cale> heatsink: I'm not arguing that, but I wouldn't consider that behaviour purely functional.
12:12:36 <gtn> does this have something to do with monadic logic
12:12:49 <basti_> gtn: it has to do with "kleisli triples"
12:13:01 <autrijus> gtn: it's an endofunctor on the category of types.
12:13:13 * basti_ head hurts
12:13:24 <Cale> but if you don't know much category theory, that's not going to mean a whole lot :)
12:13:29 <astrolabe> gtn: if monadic logic is from Liebnitz, then not much.  It is reminicent of monads in maths.
12:13:53 <gtn> mhmm
12:13:56 <gtn> I will read
12:13:59 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers is the way I tend to explain them to nonmathies
12:14:07 <astrolabe> They are used to do input/output and other stuff in Haskell.
12:14:12 <gtn> Cale: I am a mathie
12:14:14 <basti_> ("Leibniz", ei pronounced like ay in english, second i as in "in" z as ts)
12:14:18 <Cale> (and to mathies as well, though I'll say more in that case)
12:14:35 <Cale> Ah, fraxtal :)
12:14:45 <fraxtal> I can't keep up with all these nicks
12:14:53 * astrolabe can't spell :(
12:15:07 <wagerlabs> how do I lift Language.Haskell.TH.Lib.ExpQ to Bool?
12:15:11 <Cale> http://planetmath.org/encyclopedia/Monad.html
12:15:21 <Cale> that has the mathematical definition :)
12:16:25 <heatsink> wagerlabs: evaluate it, with splice
12:16:33 <wagerlabs> heatsink: how?
12:16:34 <Cale> I love the spurious links generated by the autolinker on PlanetMath
12:16:37 <heatsink> [| True |] :: ExpQ
12:16:43 <heatsink> $( [| True |] ) :: Bool
12:16:59 <Cale> "between" is linked to "linear ordered geometry"
12:17:06 <wagerlabs> heatsink: so just put [| ... |] around the code?
12:17:07 <wagerlabs> lets see
12:17:22 <heatsink> wagerlabs: no, that makes an Exp!
12:17:23 <heatsink> wagerlabs: no, that makes an ExpQ
12:17:38 <wagerlabs> be = $( [| (1::CChar) /= (unsafePerformIO
12:17:38 <wagerlabs>                       $ with (1::CInt)
12:17:38 <wagerlabs>                       $ peekByteOff `flip` 0) |] ) :: Bool
12:17:43 <wagerlabs> heatsink: like this?
12:18:00 <heatsink> wagerlabs: no... the $() undoes the [| |]
12:18:15 <heatsink> [| |] makes an ExpQ
12:18:26 <heatsink> $( ) turns an ExpQ into the expression that it represents
12:18:38 <wagerlabs> heatsink: so.... how do i do it then?
12:19:01 <heatsink> use $()
12:19:10 <wagerlabs> heatsink: i already am
12:19:17 <wagerlabs> be = $( (1::CChar) /= (unsafePerformIO
12:19:17 <wagerlabs>                       $ with (1::CInt)
12:19:18 <wagerlabs>                       $ peekByteOff `flip` 0) ) :: Bool
12:19:27 <heatsink> Oh I see.
12:19:32 <wagerlabs> the whole thing is in $( )
12:19:52 <heatsink> you have $( something :: Bool ) and you want to have $( something :: ExpQ )
12:20:15 <wagerlabs> heatsink: i want be to be a bool
12:20:27 <heatsink> $( case ... of {True -> [| True |]; -> False -> [| False |])
12:20:54 <wagerlabs> heatsink: any easier way?
12:20:58 <heatsink> let me see how to do that in general
12:22:05 <heatsink> @hoogle a -> ExpQ
12:22:30 <heatsink> Well, I'm not sure.
12:24:14 <heatsink> You can look for something useful in http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language.Haskell.TH.html
12:24:33 <heatsink> though it's not well documented
12:24:49 <magnus-> I don't seem to need the Monad class, I can just make a monad-like thing for the rng state without it :)
12:25:13 <magnus-> which I actually understand
12:25:19 <wagerlabs> heatsink: thanks
12:29:06 <TheHunter> @index liftQ
12:30:41 <CosmicRay> shapr: whee.  my hacked shootout tree is working.
12:30:47 <Cale> magnus-: well, of course, but the nice thing about using the monad class is that you get a whole bunch of common functions written for free
12:30:51 <CosmicRay> and even has two examples.
12:31:10 <TheHunter> wagerlabs, class Lift t where
12:31:10 <TheHunter> lift :: t -> Q Exp
12:31:26 <wagerlabs> TheHunter: so how do I use it?
12:31:34 <wagerlabs> in that expression
12:31:34 <magnus-> Cale: I see... but perhaps I need to do it the hard way before I can appreciate the easy way
12:31:39 <Cale> :)
12:32:07 <Cale> heatsink: so what do you think a suitable syntax for commutative monad expressions would be?
12:32:10 <TheHunter> $(lift ...)
12:32:22 <wagerlabs> TheHunter: trying...
12:32:53 <autrijus> hm, there's no "ghc --run" form.
12:32:53 <autrijus> sigh
12:33:08 <TheHunter> Cale, normal application syntax, with funny "unsafePerformIO"(reflect)-brackets.
12:33:10 <ValarQ> autrijus: runghc ?
12:33:14 <autrijus> ValarQ: yeah.
12:33:25 <wagerlabs> TheHunter: it says lift is not in scope
12:33:26 <autrijus> I'm just mumbling about ghc --interactive vs ghci
12:33:28 <ndm> is data.intmap faster than data.map for int's?
12:33:31 <autrijus> but no such symmetry
12:33:33 <ndm> (i assume so, just checking)
12:33:37 <autrijus> ndm: most certainly yes
12:33:37 <ValarQ> autrijus: ok
12:33:38 <TheHunter> wagerlabs, Language.Haskell.TH.Syntax
12:33:53 <ndm> autrijus, by how much? at a hand wavey figure
12:34:01 <heatsink> Cale: I haven't thought much about it.  It needs to specify the number of times functions are invoked, but not the order.
12:34:03 <wagerlabs> TheHunter: would you mind just telling me how to do it? :-)
12:34:23 <wagerlabs> TheHunter: or do yo umean to say that i should import that module?
12:34:32 <TheHunter> yes, sure.
12:34:43 <TheHunter> Prelude> :m +Language.Haskell.TH.Syntax
12:34:43 <TheHunter> Prelude Language.Haskell.TH.Syntax> $(lift True)
12:34:43 <TheHunter> Loading package haskell98-1.0 ... linking ... done.
12:34:43 <TheHunter> Loading package template-haskell-1.0 ... linking ... done.
12:34:44 <TheHunter> True
12:34:46 <TheHunter> Prelude Language.Haskell.TH.Syntax>
12:35:04 * Speck has been building ghc 6.4.1 with darwinports for about 12 hours
12:35:04 <autrijus> ndm: not sure at all. please benchmark
12:35:08 <wagerlabs> TheHunter: Couldn't match `Language.Haskell.TH.Lib.ExpQ' against `Bool'
12:35:11 * Speck needs a new computer
12:35:30 <xerox> <pjb> Since the useful life expectancy of the universe is less than (expt 2 69) seconds, when you timestamp with a 1-second resolution over 64-bit you can use modular arithmetic without ever looping back to the big bang.
12:35:42 <wagerlabs> TheHunter: i think the idea is to convert Exp to Bool, not vise versa
12:35:59 <heatsink> Cale: this could work functionally by making every call to the function take a token, with an additional function split :: (tok -> (tok, tok)) and join :: ((tok, tok) -> tok) actually I think random number generation does that
12:36:40 <Cale> yeah, without the join
12:36:56 <heatsink> Cale: The monad syntax's job would be to  make the invocation of split and join invisible,
12:37:21 <heatsink> Cale: the same way the lambdas are invisible in normal monadic code
12:37:31 <TheHunter> wagerlabs, i didn't follow the conversation, but what heatsink suggested is the same as lift.
12:37:46 <wagerlabs> TheHunter: oh
12:38:04 <wagerlabs> TheHunter: be = $( (1::CChar)/=(unsafePerformIO $ with (1::CInt) $ peekByteOff `flip` 0) )
12:38:09 <wagerlabs> :: Bool
12:38:12 <wagerlabs> TheHunter: i'm trying to make this compile
12:38:16 <wagerlabs> and it complains
12:38:29 <wagerlabs> Couldn't match `Language.Haskell.TH.Lib.ExpQ' against `Bool'
12:38:35 <Cale> wagerlabs: he's saying to apply lift to the expression inside the $(...)
12:38:54 <TheHunter> @index peekByteOff
12:39:21 <TheHunter> @index peekByteOff
12:39:21 <thbot> Foreign.Storable, Foreign
12:39:36 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign.Storable.html
12:39:43 <Cale> yeah
12:40:13 <TheHunter> Prelude Language.Haskell.TH.Syntax Foreign Foreign.C> $(lift $ (1::CChar)/=(unsafePerformIO $ with (1::CInt) $ peekByteOff `flip` 0))
12:40:13 <TheHunter> False
12:40:44 <wagerlabs> TheHunter: i'm missing a $
12:40:45 <wagerlabs> sec
12:41:27 <wagerlabs> TheHunter: how did you make ghci display Prelude Language.Haskell.TH.Syntax Foreign Foreign.C>
12:41:34 <wagerlabs> i.e. the two modules in there
12:41:43 <Cale> wagerlabs: :m + ModuleName
12:41:44 <TheHunter> :m +Foreign
12:41:45 <TheHunter> :m +Foreign.C
12:41:57 <wagerlabs> cool, thanks
12:43:15 <wagerlabs> TheHunter: thanks, moving on...
12:43:40 * heatsink discovered a new kind of compiler error today, yay!
12:43:47 <TheHunter> @ghc
12:43:48 <thbot>  Illegal constraint
12:43:58 <TheHunter> @ghc
12:43:58 <thbot>  parse error on input
12:44:01 <TheHunter> @ghc
12:44:01 <thbot>  GHC stage restriction
12:45:02 <wagerlabs> @paste
12:45:02 <thbot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:46:00 <TheHunter> heatsink, what you were just describing sounds awfully similar to linear implicit parameters...
12:46:43 <wagerlabs> http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
12:47:32 <Cale> (linear) implicit parameters seem evil to me :)
12:48:07 <heatsink> The no eta reduction rule (I think that's what it was called) seemed a little scary
12:48:49 <TheHunter> Cale, implicit parameters are perfectly well-behaved (modulo some implementation quirks)
12:49:03 <TheHunter> linear implicit parameters are kind of evil.
12:49:31 <heatsink> TheHunter: There were some examples about what linear implicit parameters are good for in the ghc manual.  They match the uses I've thought of for commutative monads.
12:49:49 <TheHunter> wagerlabs, the Num a constraint in the data declaration is meaningless.
12:50:17 <Cale> Even implicit parameters break things a bit. I'd rather have something like named instances to solve that problem.
12:50:31 <TheHunter> there's nothing commutative about linear implicit parameters.
12:51:03 <TheHunter> aren't implicit parameters and named instances basically the same thing?
12:51:22 <wagerlabs>     Could not deduce (Integral a)
12:51:22 <wagerlabs>       from the context (Storable (BigEndian a), Storable a)
12:51:22 <wagerlabs>       arising from use of `BigEndian' at Endian.hs:16:12-22
12:51:22 <wagerlabs>     Probable fix: add (Integral a) to the class or instance method `sizeOf'
12:51:22 <wagerlabs> anyone?
12:51:23 <wagerlabs> the code is at the bottom of the wiki page
12:51:27 <wagerlabs> oops
12:51:29 <wagerlabs> i got disconnected apparently
12:51:29 <Cale> they're related
12:52:12 <TheHunter> wagerlabs, try instance (Integral a, Storable a) => Storable (BigEndian a) where
12:52:52 <wagerlabs> TheHunter: so there's no need for the this
12:53:10 <wagerlabs> data (Num a) => BigEndian a = BigEndian a deriving (Eq, Ord)
12:53:19 <TheHunter> the constraint is meaningless.
12:54:26 <wagerlabs> TheHunter: so data BigEndian a deriving (Eq, Ord) then?
12:55:25 <TheHunter> "data (Num a) => BigEndian a = BigEndian a deriving (Eq, Ord)" is exactly the same as "data BigEndian a = BigEndian a deriving (Eq, Ord)" except the former checks on every invocation of the _constructor_ that the type belongs to the Num type class.
12:55:26 * dcoutts pushes more patches to hIDE
12:56:17 <wagerlabs> TheHunter: thanks, i'm making progress here
12:56:20 <dcoutts> Lemmih, I've tidied up the GUI code a bit. I'm actually quite pleased with the MainWindow module now.
12:57:30 <dcoutts> Lemmih, next I'm going to add a recent files browser view and maintain a history of files the user has looked at recently so we can easily switch back and forth.
12:57:55 <dcoutts> eg jump to definition and jump back
12:58:59 <wagerlabs> TheHunter: updated the wiki paste page
12:59:09 <wagerlabs> Endian.hs:18:22:
12:59:09 <wagerlabs>     Couldn't match `BigEndian (Ptr a)' against `Ptr (BigEndian a1)'
12:59:09 <wagerlabs>       Expected type: Ptr (BigEndian a1) -> IO (BigEndian a1)
12:59:09 <wagerlabs>       Inferred type: BigEndian (Ptr a) -> IO a
12:59:16 <wagerlabs> that's for peek
12:59:25 <wagerlabs> do i need lifting here or something like that?
12:59:48 <Cale> heatsink: I personally haven't had much trouble with it, because for commutative monads, you just think of do notation as a funny kind of "let". It's slightly annoying that you can't write an expression with monadic bits inlined as "foo getUnique getUnique", but I've usually found it saner to think about with the explicit extraction of values.
13:00:59 <Cale> funny brackets as TheHunter suggested might be a good idea
13:01:11 <ndm> autrijus, Data.IntMap is 30% faster than Data.Map
13:01:16 <autrijus> ndm: good to know!
13:01:25 <wagerlabs> Cale: are you talking to me?
13:01:33 <Cale> wagerlabs: no
13:01:41 <wagerlabs> Cale: oh, ok
13:01:47 <Cale> wagerlabs: I'll check the pastepage though :)
13:02:02 <wagerlabs> Cale: thanks! it's not compiling :(
13:02:15 <TheHunter> wagerlabs, you need to convert Pointers, I'm not sure if there are functions for it, since i'm not familiar with the ffi.
13:02:38 <TheHunter> i suggest changing data to newtype, so that you don't get the extra bottom.
13:03:06 <wagerlabs> TheHunter: This is my first serious day with Haskell
13:03:14 <wagerlabs> TheHunter: bear with me
13:03:24 <heatsink> Cale: I can understand that.  One thing I don't like about using do instead of let, aside from what you mentioned, is that I have to put code in the right place with respect to control flow for efficiency (can't rely on laziness).
13:03:30 <wagerlabs> TheHunter: and i have no idea about the extra bottom
13:03:48 <wagerlabs> TheHunter: so code examples would help
13:03:59 <TheHunter> it means if you use newtype, a and BigEndian a have the same runtime-representation.
13:04:15 <wagerlabs> TheHunter: how do I do that?
13:04:24 <TheHunter> newtype BigEndian a = BigEndian a deriving (Eq, Ord)
13:04:24 <wagerlabs> data BigEndian a = BigEndian a deriving (Eq, Ord)
13:04:33 <wagerlabs> TheHunter: let me try
13:05:07 <TheHunter> heh, using th and the ffi on your first serious haskell day is an interesting approach.
13:05:11 <wagerlabs> TheHunter: no visible changes
13:05:21 <wagerlabs> TheHunter: wait till you hear the whole thing ;)
13:05:25 <autrijus> TheHunter: it worked for this person :)
13:05:49 <wagerlabs> i have two more weeks to complete a serious project that also includes Concurrent Haskell :D
13:06:25 <wagerlabs> I mean, I could easily plug away with Erlang but I want to write scripts to test a poker server and want them to look like this
13:06:35 * TheHunter has never used either the fii or th in a serious way...
13:06:43 <wagerlabs> expect some games
13:06:54 <Lemmih> dcoutts: cool.
13:06:54 <wagerlabs> or should that be expect `some` Games
13:07:02 <wagerlabs> but you get the picture
13:07:23 <Cale> wagerlabs: it's because peek :: Ptr a -> IO a
13:07:29 <TheHunter> the data -> newtype change wasn't supposed to get rid of the errors, it is just a reasonable thing to do.
13:07:30 <wagerlabs> haskell should let me write the testing scripts in haskell
13:07:42 <wagerlabs> Cale: I looked that up, thanks ;)
13:07:42 <Cale> but in its definition, it's taking a (BigEndian t)
13:07:56 <wagerlabs> Cale: how do i fix it, though? i learn quickly, i promise!
13:08:04 <TheHunter> there we go,
13:08:08 <TheHunter> @index castPtr
13:08:08 <thbot> Foreign.Ptr, Foreign
13:08:37 <wagerlabs> TheHunter: ?
13:08:50 <TheHunter> @type Foreign.castPtr
13:08:51 <thbot> forall b a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b
13:09:30 <TheHunter> you need to convert a Ptr (BigEndian a) to a Ptr a somewhere, don't you?
13:09:42 <TheHunter> maybe not.
13:09:44 <Cale> yes
13:09:44 <wagerlabs>       Expected type: Ptr (BigEndian a1) -> IO (BigEndian a1)
13:09:45 <wagerlabs>       Inferred type: BigEndian (Ptr a) -> IO a
13:09:48 <Cale> that's exactly it :)
13:10:02 <wagerlabs> mmm
13:10:10 <Cale> okay, my copy compiles now :)
13:10:14 <wagerlabs> how do i write it?
13:10:20 <wagerlabs> can you change the wiki cale?
13:10:24 <Cale> sure
13:10:59 <wagerlabs> i promise to detail my journey in my blog :D http://wagerlabs.com/idealab
13:11:45 <wagerlabs> something like... Easy Haskell in 14 days... with a lot of help from the good folks of #haskell :D
13:11:58 <wagerlabs> although I wouldn't call this easy haskell
13:11:58 <Cale> actually, that castPtr may need an additional type signature
13:14:31 <wagerlabs> Cale: did you update the wiki by chance? i can't figure out if you did
13:14:41 <Cale> yes
13:15:06 <Cale> though I think that compiling version has a serious bug :)
13:16:04 <wagerlabs> Cale: ok, can't see the version w/o the serious bug
13:16:21 <wagerlabs> Cale: i'll write a unit test once it works
13:16:35 <Cale> okay, I'm going to write that version now :)
13:17:44 <wagerlabs> Cale: do you use emacs to edit haskell?
13:17:53 <Cale> wagerlabs: sometimes
13:17:57 <wagerlabs> cale: i can't get it to align like in your example
13:18:08 <Cale> that's because I used vim there
13:20:54 <Cale> are you editing?
13:20:58 <wagerlabs> cale: you also changed the logic for some reason
13:21:03 <wagerlabs> cale: dunno, let me exit that page
13:21:15 <wagerlabs> cale: i'm no longer there
13:21:45 <wagerlabs> @paste
13:21:45 <thbot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:22:09 <Cale> I just pasted a new version
13:22:24 <wagerlabs> cale: what's wrong with            peekR a = peekByteOff `flip` 0
13:22:24 <wagerlabs> ?
13:22:56 <Cale> nothing
13:23:03 <Cale> it's exactly the same as the version I have
13:23:31 <wagerlabs> hmm
13:23:50 <Cale> It's just that I was playing around with it, and that form was inconvenient
13:24:36 <wagerlabs> cale: it compiles, it compiles!
13:24:53 <Cale> yeah, my previous version with the bug compiled too :)
13:25:03 <Cale> but try this one
13:25:07 <Cale> I think it ought to work
13:25:28 <wagerlabs> Cale: i'll try writing the pokes
13:26:15 <wagerlabs> Cale: i wonder if just replacing peek with poker will work :D
13:26:59 <Cale> It probably will, actually, though pokes take an extra parameter
13:28:30 <wagerlabs> Cale: this is an excellent introduction, forget the Hello World stuff
13:29:18 <Cale> :)
13:29:50 <Cale> there's a lot of stuff going on there
13:29:52 <Korollary> There should be a Hello World monad
13:30:24 <wagerlabs> Cale: just you wait, I'll need Concurrent Haskell after i'm able to read and write packets from a socket :D
13:30:41 <SamB> wow, wxHaskell uses clever tricks, doesn't it?
13:30:51 <SamB> Korollary: nah, would probably be too simple!
13:30:52 <Cale> Korollary: that's a good idea
13:30:56 <Korollary> lol
13:31:00 <SamB> should be a factorial monad ;-)
13:31:10 <Cale> heh
13:31:26 <Cale> hmm... how should that work
13:31:49 <Korollary> This is a nice idea actually. Instead of the traditional hello world example, we can have a "google search" example as an introduction
13:31:49 <wagerlabs> Cale: well, i need to launch 40,000 bots against the poker server
13:32:00 <Korollary> wagerlabs: DDoS ?
13:32:27 * TheHunter wonders if it would be feasible to implement a safe IO monad for @eval.
13:32:31 <wagerlabs> Korollary: not really, a paid project. the c++ poker server has intermittent memory corruption
13:32:43 <Korollary> omg. paid haskell work.
13:32:56 <wagerlabs> i need to write a simulation environment (test harness) to bring down da house :D
13:33:18 <Korollary> ah, I see
13:33:24 <wagerlabs> well, yeah, i actually have the freedom to do it in any language i want. which is either erlang or haskell. i always take the difficult way out.
13:33:25 <SamB> Korollary: the haskell part is probably not the part they are paying for. they are probably paying for the part where they get results
13:33:36 <wagerlabs> SamB: right on
13:33:43 <Cale> I got paid for Haskell work :)
13:33:47 * xerox too
13:33:50 <Cale> :)
13:34:03 <SamB> shapr has done things like that too, right?
13:34:07 <wagerlabs> i want haskell to be able to write test scripts in haskell and make them look like test scripts instead of haskell
13:34:17 <wagerlabs> with erlang my test scripts look like... erlang :D
13:34:20 <sylvan> Does writing an article about Haskell for money count as "paid haskell work"? =)
13:34:23 <JohnMeacham> I did too but no-one knew I was using haskell.
13:34:35 <wagerlabs> and the customer has a thing for his qa people not having to learn erlang
13:35:08 <Cale> Hehe, I was hired shortly after adding a user page on the Haskell wiki
13:35:10 <SamB> wagerlabs: haskell very likely doesn't look like like much
13:35:14 <wagerlabs> now, i pitched "an easy scripting language" but i want to just make it haskell instead of having to write an interpreter
13:35:24 <SamB> and plus we have Parsec
13:35:24 <Korollary> haskell is an easy scripting language
13:35:32 <Cale> I think it was like 2 days before they found my email address and contacted me.
13:35:39 <wagerlabs> yes, i got grand plans, i swear!
13:35:59 <Korollary> I just wrote a haskell script to tag my mp3 files
13:36:12 <wagerlabs> and i'm sure i'll get to implementing those grand plans... just as soon as i'm done with "hello haskell world" here
13:36:34 <SamB> in haskell, you can just compile things into functions ;-)
13:36:47 <Cale> Korollary: heh, I always have to use scripts to untag my mp3 files :)
13:36:58 <xerox> Korollary: is it in public domain, or at least downloadable/viewable?  I'm very interested in it.
13:37:02 <Korollary> Cale: why untag ?
13:37:29 <Cale> Because I want xmms to show the filename, not the metadata
13:37:35 <Korollary> xerox: It's 10 lines or so, heh. I am using the id3v2 tool externally (hence a script).
13:37:55 <SamB> Cale: can't you just change a format string in the mp3 plugin configuration for that?
13:38:01 <Korollary> Cale: You could make them equal I suppose
13:38:13 <TheHunter> that reminds me, I have to tag a couple of mpc files.
13:38:18 <Cale> yeah, I could, but it's easier just to strip the data
13:38:22 <xerox> Korollary: got it.
13:38:33 <Cale> I use the directory hierarchy to store all the data anyway.
13:38:55 <Korollary> xerox: I was thinking of implementing id3v2 in haskell, but I am too sane for that at the moment (that thing is complex, sheesh)
13:38:56 <Cale> Genre/Artist/Album/(Disc/)Song
13:39:19 <xerox> Korollary: In three words: plase, do, it.  <blink>
13:39:28 * Korollary is hypnotized
13:39:29 <Cale> and the song filenames are prefixed with their track number
13:40:20 <xerox> Cale: no 'Year' information!  :-)
13:40:48 <Cale> oh, that's on the album
13:41:00 <xerox> It makes sense.
13:41:28 <Cale> I put it like an index before the album name so that I can drag someone's discography to xmms and have it play in order :)
13:41:42 <heatsink> Is there a way to make a Handle that writes nowhere? I tried opening /dev/null, but it didn't work.
13:41:44 <Korollary> Cale: I had to tag them because the iPod needs the id3v2 tag for each song
13:42:08 <xerox> Goodnight folks.
13:42:10 <TheHunter> anyone know a sane music player for linux?
13:42:14 <magnus-> when I define a polymorphic function inside a polymorphic function, how can I refer to the outer function's polymorphic types in the type signature of the inner function?
13:42:21 <Korollary> xerox: gn
13:42:23 <heatsink> TheHunter: sane?
13:42:24 <Cale> TheHunter: what do you mean by "sane"?
13:43:01 <heatsink> magnus-: I don't know how, but you usually don't need to do that -- if you really need it, unification will make them the same type.
13:43:24 <Korollary> magnus-: What would you do with that, anyway ?
13:43:37 <TheHunter> it should have a sane playlist, should be able to randomly play songs and everything should be greppable.
13:43:45 <TheHunter> The nearest approximation I know of is quodlibet.
13:43:48 <magnus-> histogram::(a->a->Bool)->[a]->[(a,Int)]
13:43:49 <magnus-> histogram eq xs = foldl addOne [] xs
13:43:49 <magnus->     where addOne::[(a,Int)]->a->[(a,Int)]
13:43:52 <xerox> TheHunter: rhythmbox?
13:43:59 <magnus-> where addOne uses eq
13:44:10 <Cale> nautilus + xmms? :)
13:44:35 <xerox> TheHunter: it has an iTunes-like interface, i.e. powerful search capabilities.
13:44:48 <magnus-> I will skip the type signature
13:46:15 <TheHunter> ideally, i want to have playlist, that before running empty, appends songs randomly (based on some criteria, of course) at the end of it, which are in a hybrid state then in which I can accept or reject them with a single keypress.
13:47:00 <Korollary> TheHunter: That's an idea for a plugin
13:47:10 <malcolm> magnus-: with ghc, you can use scoped type variables
13:47:36 <Cale> I don't understand why people always want random music. :) I always listen to entire albums at least.
13:48:16 <magnus-> malcolm: okay... will check it out but I prefer if it's a standard haskell thing
13:48:27 <TheHunter> only very few albums consist entirely out of good songs.
13:48:42 <Korollary> Cale: I don't always want it random. But sometimes I remember the order of songs and it bothers me, so I switch to shuffle mode
13:48:42 <malcolm> magnus-: I think you need an explicit "forall a . " on the outer signature to make the inner "a"s bind to the same type.
13:49:40 <TheHunter> Korollary, plugin for which player?
13:49:45 <malcolm> magnus-: In standard haskell, there are some local type signatures that cannot be written, because the variables are not purely polymorphic.
13:49:54 <sylvan> while we're on the topic of random music, try out www.pandora.com (free for 10h, no signups or anything like that, just go).. Pretty sweet if you ask me, I paid for it after my 10h expired
13:49:55 <Korollary> TheHunter: xmms, I suppose
13:50:07 <TheHunter> xmms suck big time, imo.
13:50:17 <wagerlabs> folks, could you comment on my version of poke on the paste page
13:50:22 <wagerlabs> please
13:50:43 <dcoutts> @paste
13:50:43 <thbot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:50:57 <wagerlabs> i put that (BigEndian b) in there intuitively
13:50:59 <magnus-> malcolm: I get parse error if I add forall a . before my type signature
13:51:03 <wagerlabs> it was compiling without it
13:51:06 <TheHunter> xmms doesn't even have a seperate playlist and music library.
13:51:22 <malcolm> magnus-: probably need to add -fglasgow-exts
13:51:23 <Cale> magnus-: make sure ghc extensions are turned on in that case
13:51:35 <magnus-> ahh
13:52:49 <Korollary> TheHunter: if shapr was around, he'd have you write an mp3 player in haskell...
13:53:02 * wagerlabs is moving on to HUnit
13:53:13 <wagerlabs> gotta test that code and see if it's doing the right thing
13:53:25 <Cale> TheHunter: most albums mostly consist of good songs
13:53:40 <Korollary> Cale: What kind of music do you listen to ???
13:53:53 <TheHunter> Korollary, don't have time for that right now, but I have often thought about it.
13:54:11 <wagerlabs> how do you say 0xff in haskell?
13:54:17 <Cale> Jazz, Blues, Rock from the 1960's and 70's, Avant Garde, Zappa.
13:54:21 <TheHunter> @eval 0xff
13:54:21 <Korollary> TheHunter: I thought about an mp3 or vorbis decoder in haskell
13:54:21 <thbot> 255
13:54:21 <Cale> wagerlabs: 0xff
13:54:38 <wagerlabs> Cale: no kidding
13:54:39 <Cale> and some other things, but that basically covers most of it
13:55:00 * Korollary want to see Cale's planet one day ;)
13:55:30 <Cale> heh
13:55:45 <Cale> I should probably have qualified my statement with "that I'll listen to"
13:56:02 <Cale> Or redefined the word "albums"
13:57:07 <Cale> Currently I'm listening to Steve Reich's "Music For 18 Musicians"
13:58:01 <basti_> i like reich's 4'33"
13:58:20 <basti_> :D
13:58:32 <poetix> That was Cage
13:58:45 <basti_> ah right
13:58:49 <Cale> Yeah, I was going to ask :)
13:59:11 * basti_ ponders
13:59:16 <poetix> I like Reich's "Different Trains", and the Pat Metheny composition that was released with it
13:59:19 <wagerlabs> what's the deal with putting commas in front?
13:59:20 <wagerlabs> myTestList =
13:59:20 <wagerlabs>     TestList [
13:59:20 <wagerlabs>               "add numbers" ~: 5 ~=? (3 + 2)
13:59:22 <wagerlabs>              ,"add numbers" ~: 5 ~=? (3 + 3)
13:59:23 <wagerlabs>              ]
13:59:30 <wagerlabs> as opposed to at the end/
13:59:39 <poetix> Never seen that before.
13:59:40 <Korollary> no deal
13:59:44 <basti_> nothing special
13:59:50 <Cale> wagerlabs: some people like that because you can insert list items at the end in a uniform way
13:59:53 <basti_> just for the look of it
13:59:56 <heatsink> wagerlabs: it lines up nicer that way
14:00:13 <wagerlabs> hmm
14:00:14 <Korollary> interesting point
14:00:15 <thaldyron> How does one model the memoisation needed for dynamic programming algorithms (e.g. Viterbi) in Haskell? Any alternatives to the State Monad?
14:00:31 <TheHunter> it just looks horrible, doesn't it?
14:00:42 * basti_ shrugs
14:00:43 <heatsink> thaldyron: http://www.haskell.org/hawiki/MemoisingCafs
14:00:47 <Cale> thaldyron: Define a value which keeps the results, and let lazy evaluation sort it out.
14:00:53 * TheHunter wonders why they don't just allow lists of the form [1,2,3,4,]
14:01:11 <Cale> TheHunter: GAP allows lists of the form [1,,,2,3,,4,]
14:01:18 <basti_> TheHunter: my words... i always liked terminators better than separators
14:01:19 <Cale> but that's not the same as [1,2,3,4]
14:01:22 <Cale> :)
14:01:41 <basti_> ahhh "it's gonna rain", thats where i know reich from
14:01:42 <Cale> (the holes are undefined)
14:02:03 <basti_> it sucks to have one element in the list standing out
14:02:12 <poetix> Does anyone remember what the command you run after make install is that updates pkg-config?
14:02:28 <basti_> "make register"?
14:02:39 * poetix seethes with quiet loathing for the Gnu build system
14:02:56 <dcoutts> poetix, it should just install it's pkg-config files
14:03:07 <TheHunter> fwiw, i'm currently listening to rory gallagher, but although he's a great musician, I wouldn't wanna listen to a whole album at once, i like diversion.
14:03:24 <dcoutts> poetix, you might need to adjust the pkg-config search path if you didn't install to a standard location
14:03:30 <poetix> I did this a while back, there was some extra step but I don't remember what it was.
14:03:58 <poetix> I hate constantly forgetting stuff it took me hours to find out the last time
14:04:23 <thaldyron> heatsink: I just found the "memoising Y-combinator":  http://www.haskell.org/hawiki/MemoizingRecursion  I think that fits better but thanks anyways
14:05:00 <Korollary> poetix: use gnu screen and have it log your sessions
14:05:15 <poetix> Korollary: good idea
14:05:31 <magnus-> http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show
14:05:52 <wagerlabs> how do i compile a module that depends on th?
14:06:08 <magnus-> I don't understand why this pattern above is not exhaustive
14:06:12 <sylvan> thaldyron, I usually just define an array using, say "arr = listArray (1,n) [  f x |  x <- [1..n]]" where "f" does some computation which references arr
14:06:19 <wagerlabs> i.e. assuming that i have A.hs with a main and B.hs that uses HUnit where A uses template haskell
14:07:27 <TheHunter> magnus-, check the spelling of addOne/addone
14:07:43 <wagerlabs> ghc EndianUnit.hs Endian.hs -package HUnit -package Language.Haskell.TH
14:07:47 <magnus-> wow, yes you are right
14:07:53 <wagerlabs> this cannot find TH
14:07:53 <magnus-> that was silly
14:08:00 <TheHunter> -Wall, would have given you a warning about an unused addone, btw.
14:08:33 <magnus-> I see
14:09:24 <wagerlabs> TheHunter: is that for me (-Wall)?
14:09:32 <magnus-> For me
14:10:36 <TheHunter> wagerlabs, no which functions need to be put in seperate modules with th is a complete mystery to me.
14:11:07 <Cale> I think that the odd problems with modules are another reason that TH isn't used more
14:11:10 <wagerlabs> TheHunter: well, the Endian stuff (see @paste) uses TH
14:11:40 <poetix> Oh, f***ing great...
14:11:42 <poetix> "sorry, unimplemented: adjusting pointers for covariant returns"
14:11:56 <poetix> I guess that means my version of gcc isn't cutting-edge enough
14:12:07 <Cale> hm?
14:12:08 <TheHunter> I think the reason why TH isn't used much is its untypedness.
14:12:16 <poetix> to build the latest version of gobby
14:12:16 <Cale> Well, there is that :)
14:12:48 <wagerlabs> cabal is nice, though
14:13:06 <dcoutts> poetix, what gcc version do you have?
14:13:07 <Cale> My biggest wish for TH is to be able to define how classes are derived when a library user types "deriving Foo"
14:13:20 <poetix> dcoutts: 3.3.5
14:13:32 <poetix> Apparently, covariant returns are supported by 3.4.x
14:13:51 <Cale> currently, using TH forces you to think about TH everywhere that you use it.
14:13:51 <dcoutts> poetix, hmm yeah, I'm using 3.4.x
14:14:07 <poetix> So, do I bother to upgrade gcc just to build the latest gobby? I guess I do, seeing as I want to integrate with it...
14:14:39 <Itkovian> poetix: http://www.rolandtanglao.com/archives/2005/10/06/socialtext_releases_open_source_subethaedit_for_perl_and_php
14:14:43 <Itkovian> this might interest you
14:15:05 <TheHunter> Cale, i can hardly think of a situation where you need something more powerful than "generic classes" for costum deriving clauses.
14:15:20 <poetix> I really hate it when programmers, myself included, insist on using the absolutely latest and l33t35t stuff all the time - it makes building the most piddling little things a continuous exercise in hunting down upgrades
14:15:45 <dcoutts> poetix, heh, hIDE uses the latest version of everyting :-)
14:15:50 <poetix> But I'll forgive deviations from Haskell98...
14:16:06 <poetix> Itkovian: Thanks, I'll look into that!
14:16:06 <Cale> poetix: sometimes in order to make things manageable to write, you need the new features that just became available
14:16:27 <poetix> Yeah, but there's the counterfactual - if they hadn't just come out last month, you'd have managed somehow without them
14:16:28 <Cale> (and sometimes the reason that you're writing a thing at all is because they did)
14:17:07 <poetix> I wonder how long it will be before ghc 6.4 won't cut it. Will I need 6.5 for hIDE?
14:17:07 <Cale> TheHunter: yeah, something like that would be good.
14:18:03 <TheHunter> it's there alright, but you have to write "instance Foo Bar" instead of data Bar = ... deriving (Foo).
14:18:10 <wagerlabs> so long folks and thanks for all your help!
14:20:39 <poetix> dcoutts: Hah, now I'm downloading ghc 4.0.2! I'm even more advanced than you! You'll have to upgrade to build /my/ code!
14:20:50 * poetix cackles feverishly
14:21:36 <Cale> I find it a little strange that C compilers are changing at all with respect to language features.
14:22:30 <heatsink> Cale: I think C is becoming more fortranish, while C++ is becoming... I don't know what it's becoming.
14:22:34 <SamB> Cale: but C has so few of those!
14:22:40 <heatsink> lol@SamB
14:22:46 <Cale> SamB: yeah :)
14:22:59 <heatsink> like builtin support for complex numbers, and the "restrict" keyword
14:22:59 <Cale> C++ is bizarre
14:23:26 <SamB> no idea what restrict is for. -fno-strict-aliasing, that I have a clue about.
14:23:45 <heatsink> SamB: restrict lets you tell the compiler to assume that two pointers don't alias
14:23:56 <heatsink> For example, if they are passed as function parameters
14:23:57 <SamB> heatsink: ah
14:24:01 <poetix> I want to like C++, or at least some subset thereof. Any language that huge can't be *all* bad...
14:24:11 <SamB> sounds more useful than strict aliasing
14:24:23 <heatsink> SamB: what is strict aliasing?
14:24:27 <Korollary> C++ is not too bad.
14:24:41 <poetix> Parts of it are horrifying
14:24:54 <poetix> Mind you, I've been scarred for life by exposure to MFC
14:24:57 <SamB> heatsink: it has to do with assuming that pointers of distinct types don't point at the same thing, or something like that...
14:25:00 <Korollary> mfc is bad
14:25:12 <Cale> poetix: heheh, know what you mean :)
14:25:24 <heatsink> mfc CIs CBad
14:25:32 <SamB> if wxWindows is written in C++ it can't be *totally* bad, right?
14:25:38 <poetix> It's a kind of DSEL embedded in C++, but a really horrible one.
14:25:43 <int-e> SamB: wrong
14:25:48 <poetix> ATL is slightly better, but still ugly as sin.
14:26:01 <SamB> int-e: wrong?
14:26:01 <Cale> The even scarier part is that MFC was potentially slightly better than making the raw win32 api calls.
14:26:04 <Korollary> ATL is evil
14:26:26 <int-e> SamB: it could be a fortran program written in C++ (I know it isn't, but you can't conclude that from the language alone)
14:26:28 <SamB> win32 API is too loose
14:26:39 <poetix> What I find weird is that it's still being developed - ATL in Visual C++ 7 is actually quite different from the previous version
14:26:42 <Korollary> SamB: not to worry. isn't it going away soon ?
14:27:00 <SamB> Korollary: no. they've kept on a lot of win32 in .NET, or so I hear.
14:27:02 <poetix> win32 API will die around the same time as COBOL dies
14:27:06 <Cale> I found it surprising that any applications were written for windows at all after working with the win32 api for a while.
14:27:11 <heatsink> SamB: I learned recently that C specification says that a char* can alias with any other kind of pointer, but pointers to larger datatypes cannot alias if their types don't match.
14:27:17 <SamB> only they've stuck it in modules and class heirarchies and stuff
14:27:17 <Cale> Especially the GDI
14:27:28 <heatsink> SamB: Learned because gcc prints warning messages about that.
14:27:43 <dcoutts> Cale, mind you xlib is not much better
14:27:44 <poetix> Windows Vista, et al, will introduce new APIs, but they won't ditch backward compatability completely (although they might break it in manifold horrible ways) for a long time
14:27:57 * SamB thinks gcc should have something like -Wmost on by default
14:28:02 <heatsink> They could do a windows emulator in Vista
14:28:04 <poetix> System.Windows.Forms in .Net is a managed wrapper around MFC
14:28:18 <heatsink> In the windows 95 emulator, they can emulate win3.1 and dos
14:28:28 <heatsink> I mean
14:28:29 <SamB> maybe they'll say "Just use WIME" ;-)
14:28:35 <SamB> er, WINE
14:28:35 <heatsink> In win95 they emulate dos
14:28:52 <poetix> Anyhow, much as I'd love to bitch about Windows for the next 20 minutes, I have to go to bed...
14:28:55 <poetix> cya all!
14:29:00 <Cale> dcoutts: you have a point there :)
14:29:00 <heatsink> bye poe
14:29:01 <SamB> 95 doesn't emulate DOS
14:29:16 <SamB> it sticks it in some kind of sandbox and does crazy things with the hardware
14:29:52 <heatsink> Okay...
14:30:01 <SamB> and it has the DOS inerds scattered throughout, reportedly...
14:31:13 <SamB> oh, has anyone noticed wxhaskell 0.9.4 not working right in GHCi when built without opengl support?
14:31:33 <SamB> with an error message like this?
14:31:35 <SamB> Loading package wxcore-0.9.4 ... can't load .so/.DLL for: wxc-gtk2.4.2-0.9.4 (/usr/lib/libwxc-gtk2.4.2-0.9.4.so: undefined symbol: _ZN10wxGLCanvasC1EP8wxWindowiRK7wxPointRK6wxSizelRK8wxStringPiRK9wxPalette)
14:32:17 * heatsink goes to start the other computer
14:34:10 <SamB> why does GHCi segfault if I try to start hello twice?
14:34:53 <rep> not godo
14:34:55 <rep> good
14:35:52 <SamB> I bet its a problem with wxWidgets
14:40:12 * SamB thinks GDB ought to stop trying to traverse the stack upon reaching a NULL return address
14:42:02 <int-e> hah. got the enormous input test on the sphere online judge accepted ... using hSetBuffering stdin (BlockBuffering (Just (2^10)))
14:42:14 <Cale> ahahaha!
14:42:21 <Cale> :)
14:42:42 <int-e> for some reason, bigger buffers seem to hurt rather than help
14:42:52 * sm wonders what the sphere online judge is
14:43:23 <int-e> sm: http://spoj.sphere.pl/problems/INTEST/
14:43:27 <int-e> that's the problem.
14:44:33 <Cale> how quickly does it run with block buffering?
14:45:43 <int-e> Cale: about a factor of 3.5 quicker than before, 2.88 seconds
14:45:52 <Cale> nice
14:47:35 <int-e> and not much slower than the equivalent C version (2.25 seconds; I wrote some tail recursive C functions for that, hoping that gcc optimizes them away - it did)
14:48:15 <sm> pretty cool
14:49:02 <int-e> btw, I did mean it when I said that bigger buffers hurt - a buffer of 2^16 slows down the program by a factor of 4 here ... I wonder why.
14:49:30 <SamB> how am I supposed to get textCtrls which are tall enough to actually hold a line of text?
14:50:54 <Cale> int-e: what does the rest of your solution look like -- just block buffering the naive solution doesn't seem to work
14:53:31 <int-e> http://paste.lisp.org/display/12285
14:53:40 <int-e> it's really awful :/
14:53:56 <int-e> but I thought it was the rest of the program that ate the cycles, not the getContents.
14:58:23 <int-e> so I wrote a bunch of functions that are obviously good list consumers.
15:08:13 <SamB> int-e: did they fuse?
15:09:05 <int-e> SamB: is there an easy way to find out?
15:09:36 <SamB> int-e: easy?
15:09:40 <SamB> not sure.
15:09:50 <SamB> but you could look at the core code...
15:13:00 <autrijus> hm, is it known that Cabal-1.0 is broken wrt Executable + C-sources ?
15:14:00 <dcoutts> autrijus, try a later cabal version. There's no particular reason to make your package work with Cabal-1.0
15:14:55 <dcoutts> Lemmih, yay hIDE page history is working (mostly)
15:15:12 <autrijus> dcoutts: the reason being without requiring user to install cabal by hand
15:15:17 <autrijus> or bundle a copy of cabal myself
15:15:31 <autrijus> I'll give up if I have to.
15:15:53 <dcoutts> gentoo forces a later version of cabal on users since we consider 1.0 to be too broken.
15:16:04 <autrijus> hlagh :-/
15:16:27 <autrijus> okay, duly noted.
15:16:30 <dcoutts> all our cabalised ebuilds require cabal-1.1.3 or later
15:16:32 <autrijus> can't say I like it.
15:17:13 <dcoutts> yeah, it's because of a strict interpretation of compatability taken by the ghc team, to not include a later cabal version in ghc-6.4.1
15:17:19 <dcoutts> dons!
15:17:55 <int-e> SamB: I think there wasn't much left to fuse - and the really interesting fuse of the list consumers with getContents does not happen.
15:18:41 <SamB> int-e: not unexpected.
15:18:46 <int-e> SamB: right
15:18:55 * SamB wonders how you would fuse stuff with that sort of thing anyways
15:19:08 * SamB has trouble believing it works at all
15:19:15 <autrijus> yeah, cabal-1.1.3+ works just fine.
15:19:20 <autrijus> bad bad bad.
15:19:41 * dcoutts thinks ghc 6.4.1 should have had a later cabal version
15:19:52 <autrijus> this is ultra annoying :-(
15:20:30 <dcoutts> just depend on the later cabal version
15:20:40 <autrijus> but is there a way to install it automatically?
15:20:48 <dcoutts> hackage
15:20:59 <autrijus> which is shipped with GHC of course? :)
15:21:29 <dcoutts> if you're looking for a "one click installer" then you might have to bundle cabal
15:21:50 <dcoutts> or if you make a distro package then that handles deps of course
15:22:33 <autrijus> I think I'll go with cabal bundling.
15:22:59 <autrijus> there doesn't seem to have much more options
15:24:41 <sethk> many, not much   :)
15:24:51 <sethk> don't, also
15:24:53 <autrijus> thank you.
15:25:04 <autrijus> there don't seem to have many more options.
15:25:13 <autrijus> really is it "don't"?
15:25:14 <autrijus> why?
15:25:22 <sethk> hmm., there don't seem to be many other options   is probably better
15:25:26 <sethk> or aren't
15:25:31 <sethk> there aren't many other options
15:25:46 <sethk> doesn't is third person singular
15:25:51 <sethk> like isn't
15:26:12 <sethk> it does, doesn't   they do, don't
15:26:29 <sethk> and since options is plural
15:27:05 <sethk> the top of the Empire State building just disappeared in fog
15:27:20 <autrijus> thank you.
15:29:26 <cm> hello haskell
15:50:19 <Korollary> int-e: it makes sense that huge buffers actually slow it down
15:54:20 <int-e> Korollary: hmm, usually 64k buffers are not considered 'huge' ... I thought. It increases cache pressure, of course - but wouldn't that mean the intermediate list is created in chunks?
15:55:05 <int-e> Korollary: (note that it starts slowing down for a buffer size of 2k already, with 512kb cache ...
15:56:15 <Korollary> int-e: That is interesting
15:58:01 <Korollary> int-e: I think I see why.
16:00:10 <Korollary> int-e: I think a 64k contiguous buffer cannot be all in cache
16:01:23 <Korollary> int-e: so you're forcing the cpu swap out some buffer rows for other buffer rows
16:08:31 <b0gg1e> hi, is there something like berkeley db available for (and preferably in) haskell?
16:08:45 <humasect> yes
16:09:39 <int-e> Korollary: it's spending a lot of time doing GC (buffer size 64k: 68%, buffer size 4k: 18%, buffer size 1k: 5%) ... says +RTS -S
16:09:58 <b0gg1e> humasect, got al link?
16:10:01 <int-e> for an input size of about 40 MB
16:10:46 <Korollary> int-e: why would it do different amounts of GC for the same input ???
16:11:38 <int-e> Korollary: I don't know yet; the only difference between the runs is the buffer size.
16:14:23 <int-e> uh, big difference:
16:14:27 <int-e>  19,179,132 bytes copied during GC
16:14:28 <int-e> vs.
16:14:32 <int-e> 1,062,550,856 bytes copied during GC
16:14:39 <int-e> apparently it copies the buffer during gc
16:15:23 <int-e> or something like that.
16:15:28 <Korollary> int-e: I was assuming that the buffering part was written in C in the libs
16:16:00 <int-e> Korollary: check again, it wasn't.
16:17:36 <Korollary> int-e: the fact that the total amount copied differs is strange for the same input
16:17:50 <int-e> Korollary: the interesting function here is lazyRead' in libraries/base/GHC/IO.hs
16:18:08 <int-e> (if you have the sources around)
16:18:15 <Philippa> it'll GC on heap-out, but with larger buffers more buffer space'll be live at once, right?
16:18:16 <Korollary> I think I do
16:18:25 <Philippa> => more copying
16:18:26 <int-e> Philippa: right
16:19:03 <Korollary> Philippa: I was thinking "bigger chunks copied less often"
16:20:43 <Philippa> but less often might not be the case
16:20:46 <int-e> Korollary: the GC isn't triggered by the buffering, it's triggered by the rest of the code which creates small list chunks that become garbage again immediately as they are consumed.
16:21:03 <Philippa> you won't recover as much per GC, so if anything you need to GC more often
16:21:41 <int-e> in fact the number of collections that happen is essentially the same (3108 for the small vs. 3067 for the big buffer, for my test case)
16:22:51 <Philippa> so 300-odd K live per GC on average in the big buffer case?
16:24:28 <int-e> something like that, yes.
16:24:49 <int-e>      32,868 bytes maximum residency (1 sample(s)) vs.     727,460 bytes maximum residency (611 sample(s))
16:24:55 <int-e> right order of magnitude.
16:25:18 <Philippa> max != average :-)
16:27:20 <JohnMeacham> so do we know why ghc is so sluggish on x86-64 as opposed to i386?
16:27:49 <Philippa> no idea. How big's the difference?
16:28:28 <Korollary> I think I don't know how GC works in GHC. Are there any papers ?
16:29:07 <Philippa> heh, I was just thinking of taking a poke through the source (for other reasons)
16:29:27 <Philippa> JohnMeacham: any progress on region inference for JHC? Failing that, got support for explicit regions yet?
16:36:17 <JohnMeacham> Philippa: not really, you can use the bohem gc, what I have been doing about garbage is program transformations that reduce the amount of it generated in the first place, since grin is first order, this is much simpler than in other FP languages. like I can calculate at compile time when to drop CAFs from the root set and can allocate a lot on the stack.
16:37:51 <JohnMeacham> But it actually should be pretty straightforward to do full region inference on grin, but there are other tricks I want to try before implementing the algorithms in the papers.
16:38:24 <Philippa> fair enough. I've kinda been wanting to play with an explicitly regioned monad for a while
16:39:30 <Philippa> return'd run pure functions in their own little heap, copy out the result and free the lot, and you could have a pure runRegioned func so you could write pure functions whose memory behaviour you were very, very sure of...
16:39:34 <JohnMeacham> yeah, grin will be such a one :) I am not sure whether explicit regions in the source will be easy or possible though. the code goes through so many transformations, anything given might be meaningless by the time we get to code generation.
16:40:47 <Philippa> you can't tell I want to use FP for really low-level stuff, oh no... :-)
16:41:11 <JohnMeacham> that and I am not sure what explicit region annotations in the source would look like.. but if you have an idea or a pointer to a paper. (I have read the cyclone one, but it is very different from haskell) that would be cool.
16:42:31 <JohnMeacham> actually, I was sort of toying with the idea of exposing the Grin monad at the haskell level. everything must be unboxed, no higher order functions are allowed, but it would still be a pure funttional strict monad which would be pretty much exactly translated to machine code. so you wouldn't have to resort to C for inner loops.
16:42:35 <Philippa> Hmm. I'd had some not-fully-fleshed-out ideas, is going ape with heavily-typed stuff going to be OK? Never quite sure if I want regions as values, types or both...
16:42:46 <Philippa> that could be cool
16:43:48 <Philippa> there sorta needs to be some notion in the monad of "current region" to make return work, I guess
16:43:51 <JohnMeacham> yeah, I could imagine using it instead of C for other projects :) I imagine programming in it would be a similar experience to programing in SISAL. which was a SSA languge without higher order functions. (which grin is isomorphic to)
16:43:58 <Philippa> or you could have an almost-monad where return takes an extra parm
16:44:18 <Philippa> see, I want the firstification and so forth done for me too :-)
16:44:21 <JohnMeacham> perhaps something where the regions are passed as implicit parameters...
16:44:40 <JohnMeacham> well, that is what jhc does. for haskell code.
16:44:50 <Philippa> not so sure I like that, would rather regions be explicit parameters if something's dynamically region-polymorphic
16:45:15 <Philippa> (if statically, you want the option to specialise and/or inline, no?)
16:45:36 <Philippa> a lot of stuff'd only be region-polymorphic insofar as "where do I put the result?" though...
16:45:42 <JohnMeacham> but then what do you do with that parameter? memory allocations arn't really explicit in haskell so you can't annoate them with which region to use.
16:46:15 <Philippa> nothing wrong with having a region monad that does have explicit allocations as a subset of the IO monad's capabilities
16:46:46 <Philippa> nor is there anything wrong with a reasonably clean "withRegion" combinator
16:47:10 <Philippa> (as in, build new region, run code in it, yank out result)
16:47:13 <JohnMeacham> indeed. but its the implicit allocations from building thunks that kills you space leak wise :) but for things like arrays and whatnot, I could see explicit allocation and lifetime control being quite handy.
16:47:36 <Philippa> thunks go in current region?
16:47:45 <Philippa> (then are copied out as need be)
16:48:12 <JohnMeacham> but how do you know which ones to copy out without implementing a GC to follow your pointers?
16:48:48 <Philippa> yeah, I'm kinda ending up with user-controlled generational GC here
16:49:10 <JohnMeacham> which also might be a good idea :)
16:49:15 <Philippa> right :-)
16:49:32 <Philippa> and really it amounts to ensuring values all know how to shift their region
16:49:54 <Philippa> certainly has a very C++ feel to it, though that's not necessarily a good thing
16:50:28 <Philippa> heh, you could go really crazy: different regions behave differently, values carry different baggage depending on their current region...
16:50:53 <JohnMeacham> but I am all about exposing the grin monad at the haskell level, it is unboxed types to the next level, it is 'the' unboxed monad :)
16:51:54 <JohnMeacham> too many ideas... brain filling up...
16:52:02 <sethk> JohnMeacham, does that mean you have to accept something akin to the risk of wild pointers in C?
16:52:12 <JohnMeacham> sethk, no. grin is fully typesafe.
16:52:51 <sethk> JohnMeacham, obviously I haven't looked at it.  If the only risk is leaks, that seems more than acceptable in carefully controlled doses
16:53:31 <JohnMeacham> sethk: well, the reason for exposing the grin monad would be that anything coded in it would be _inherently_ as fast as the equivalant C code.
16:54:30 <sethk> JohnMeacham, that's major.  It sounds a bit too good to be true, but then lots of things do when you don't understand them  :)
16:54:31 <JohnMeacham> I would have to play interesting tricks with new kinds in order to make it play nice with haskell code, but perhaps not too much more tricky than what was done to get user-visible unboxed types in ghc.
16:55:06 <sethk> JohnMeacham, any good URLs about it handy?
16:55:31 <JohnMeacham> sethk: yeah, i mean, there is no reason I couldn't write a grin front end to jhc now.. it actually would be a fine language to program in with a bit of syntatic sugar. the interesting thing would be to integrate it with haskells typesystem.
16:56:01 <sethk> JohnMeacham, interesting but hardly trivial
16:56:29 <arjanb> how would you ensure first orderness of the exposed grin monad?
16:56:33 <JohnMeacham> sethk: about what? grin in general? boquists paper is the best intro http://www.cs.chalmers.se/~boquist/ifl96-abstract.html
16:57:02 <sethk> JohnMeacham, ok, I'll read that, then maybe I can be a bit more intelligent  :)
16:57:04 <JohnMeacham> arjanb, with a new kind. the same way ghc ensures unboxed values can't be passed to polymorphic functions.
16:57:42 <JohnMeacham> I use "the same way" somewhat loosly here :)
16:57:50 <arjanb> i see
16:59:26 <JohnMeacham> at worst.. I create my own syntax, like a 'gdo' for grindo... but I don't want to resort to that.
17:00:00 <Pseudonym> I find it interesting that the more flexible a programming language's syntax is, the more people want to modify it further.
17:00:27 <Pseudonym> People make do with inflexible syntaxes, apparently.
17:01:31 <sethk> Pseudonym, I think I would put it another way.  People who are interested in flexibility tend to gravitate towards more flexible languages
17:01:53 <sethk> Pseudonym, if you are interested in flexibility, why put up with a less flexible alternative, among those that are readily available?
17:01:54 <JohnMeacham> I don't want to modify it is the thing.
17:02:51 <JohnMeacham> I worry I might end up having too. which isn't too bad for such a low level thing, but would disapoint me that I wasn't more clever :)
17:03:23 <cm> shapr, is there a list of pages hosted haskell.org? (i.e. stuff like /ghc, /happy, etc.)
17:03:36 <Philippa> you might have to alter the translation of do slightly instead so it translates into something that works for both monads and grin - then return's a matter of it not typing
17:03:49 <cm> hey Philippa
17:03:52 <Philippa> 'lo cm
17:07:45 <arjanb> it's straightforward to convert grin to haskell so i guess no new constructs are needed
17:08:21 <JohnMeacham> does Data.HashTable have any horrid bugs I should know about?
17:09:39 <Philippa> arjanb: it's entirely syntactic sugar we're talking about here
17:09:47 <sethk> Pseudonym, Korollary   I'm still working on the thing I asked if you would review.  It has some decent parts but it isn't coherent yet as a whole.
17:10:42 <Pseudonym> OK
17:11:17 <sethk> Pseudonym, writing something decent always takes me 10 times longer than I expect
17:11:47 <sethk> Pseudonym, even when I've already multiplied the original estimate by 10  :)
17:11:59 <Pseudonym> Me too.  I agonise over every word.
17:12:10 <JohnMeacham> it would be something like where a >>= b would have to be case a of x -> b x since unboxed values need to be evaluated in a case, but b is higher order there so it won't work unless we enforce it can only appear to the right of a >>=. with 'do' notation, it actually wouldn't be too hard to enforce that.
17:12:50 <sethk> JohnMeacham, don't force me to use do notation.  I can't handle it; I always use >>=
17:13:02 <sethk> JohnMeacham, for some reason I have a reverse mental block about it
17:13:39 <sethk> or maybe a forward mental block, how would I know?  :)
17:13:53 <cm> Philippa, is it feasible to use Win32 API from Haskell?
17:14:01 <cm> (how about callbacks, specifically?)
17:14:14 <Philippa> Not sure. I think it is for bits of it. Don't know what's involved with callbacks
17:14:32 <araujo> Now you talk about it, <- is supposed to be syntactic sugar for >>= , but i feel more confortable with the later....
17:14:58 <Philippa> I like >>= in some situations, but if I'm writing a lengthy sequence of instructions I'm less keen
17:15:21 <araujo> Does the <- notation have any other partixcular advantage taht i fail to see?
17:15:49 <Cale> araujo: well, you're allowed to fail pattern matches with <-
17:16:04 <Cale> the result gives the fail value for the monad
17:16:13 <araujo> Oh, i see...
17:16:58 <Cale> but mostly it's just that it's more convenient when there are lots of things going on
17:17:10 <cm> Philippa, hrm. I want to use UpdateLayeredWindow etc., maybe I should stick with C++ :)
17:17:30 <sethk> Cale, to me it's just confusing
17:17:43 <sethk> cm, there are ways to do all that stuff from haskell.
17:17:56 <sethk> cm, I've seen a gui interface that might as well be a C switch statement
17:18:02 <cm> sethk, does it make sense?
17:18:09 <sethk> cm, but then, I suppose, you might as well _use_ a C switch statement.  :)
17:18:14 <cm> :)
17:18:16 <sethk> cm, as much sense as windows ever makes, sure.  :)
17:18:25 <cm> using Haskell, that is.
17:18:40 <Philippa> using win32 directly doesn't really make sense IMO, but hey
17:18:56 <Philippa> but I'm guessing you want to mess with DX et al?
17:19:01 <sethk> cm, yes.  Unfortunately (or perhaps fortunately) I don't have the reference, but hunt for it
17:19:24 <sethk> Philippa, I suppose if you have some legacy code you would like to port with a minimum amount of effort ...
17:19:44 <cm> Philippa, in fact I'll do some simple 2D software rendering/composition & call UpdateLayeredWindow with the frame buffer (so that I get fancy alpha blending etc.)
17:20:27 <cm> Philippa, /'ll do/do... maybe I should do the GUI part in C++ and put it into a DLL.
17:20:58 <Philippa> you're looking at a skinned GUI type thing?
17:21:27 <cm> yea
17:21:46 <cm> I've written a prototype of the application in C++, now I'm kind of interested whether the code would look more elegant in Haskell :)
17:21:54 <Philippa> maybe write a C++ wrapper that gives a saneish interface?
17:22:02 <cm> it's kinda weird to prototype in a lower-level language, but hey.. :)
17:22:06 <Philippa> Haskell'll certainly be better at all the logic-type stuff
17:22:39 <cm> hm.
17:23:35 <cm> I could also start with the logic part and decide about the presentation part when it's clear that I stick with Haskell.
17:41:53 <araujo> mm.. is there any way in which we could get the sum of two lists using list comprehension?
17:42:34 <araujo> e.g. , [1,2,3] + [4,5,6] = [5,7,9]
17:42:38 <dons> a list comprehension is a map, you need a fold
17:42:51 <dons> oh, but that's not thhhe sum of two lists ;)
17:42:59 <araujo> yeah, i know i can do it with other things
17:43:04 <araujo> No, it is a sum of a vector
17:43:20 <cm> [ a+b | a <- as, b <- bs ] ?
17:43:21 <araujo> sorry, i had t say that :-)
17:43:59 <dons> @eval let as = [1,2,3] ; bs = [4,5,6] in [ a+b | a <- as, b <- bs ]
17:44:00 <thbot> (line 1, column 8):
17:44:00 <thbot> unexpected "="
17:44:00 <thbot> expecting var, "head", "tail", "null", bool, num, character, "[",
17:44:00 <thbot> string, "(", operator, simple term or end of input
17:44:10 <dons> lambdabot, @bot
17:44:21 <araujo> mm.. well, i tried that but it doesn't work at all.
17:44:31 <Philippa> is there a reason you want a list comprehension rather than zipWith?
17:44:42 <dons> no, it won't work. I was going to show why, until lamdabbot flaked on me
17:44:47 <araujo> Philippa, Only fun and curiosity :-]
17:45:05 <cm> with parens and crap?
17:45:09 <araujo> I know, with sipWith is straight ahead
17:45:14 <araujo> zipWith.
17:45:15 <cm> oh
17:45:16 <cm> duh.
17:45:40 <cm> .. | (a,b) <- zip as bs ] ;)
17:45:40 <araujo> cm, saw what i meant now :-]
17:46:00 <dons> what's the parallel list comprehension syntax again?
17:46:09 <cm> i recall there was some way for parallel list comprehension in GHC?
17:46:30 <dons> @eval zipWith (+) [1,2,3] [4,5,6]
17:46:30 <thbot> (line 1, column 10):
17:46:30 <thbot> unexpected "+"
17:46:30 <thbot> expecting simple term
17:46:37 <lambdabot> [5,7,9]
17:46:46 <dons> thbot, @part
17:46:55 <araujo> cm, hah, yeah that made it ... but there is no way to do it without using a function right?
17:46:56 <dons> thbot, ignore me then
17:47:18 <cm> dons: [ expr | foo | bar ]
17:48:02 <cm> araujo: [ a + b | a <- [1,2,3] | b <- [3,2,1] ] with -fglasgow-exts, I guess
17:48:09 <dons> ah ,right you are
17:48:15 <dons> @eval [ a + b | a <- [1,2,3] | b <- [4,5,6] ]
17:48:15 <thbot> (line 1, column 9):
17:48:15 <thbot> unexpected "|"
17:48:15 <thbot> expecting var, "head", "tail", "null", bool, num, character, "[",
17:48:15 <thbot> string, "(", operator, "-", "+", simple term, "," or "]"
17:48:18 <lambdabot>  Illegal parallel list comprehension: use -fglasgow-exts
17:48:24 <dons> :)
17:48:28 <cm> :D
17:48:29 <araujo> cm, yeah just tried it here, thanks :-)
17:49:11 <cm> is there a way to tell all GHC binaries to use a certain set of parameters? maybe some configuration file like ~/.ghc?
17:49:25 <dons> GHC_RTS env var?
17:49:44 <dons> what kind of parameters?
17:49:46 <dons> oh, like -fglasgow-exts you mean?
17:49:49 <cm> -fglasgow-exts :o)
17:50:11 <dons> you mean a default flag for the compiler. alias ghc='ghc -fglasgow-exts' ;)
17:50:31 <cm> ;)
17:50:43 <dons> I have: $ which ghci
17:50:43 <dons> ghci: aliased to ghci -v0
17:52:14 <cm> I have cmd.exe :o)
17:52:25 <Korollary> lol
17:52:35 <dons> oh, poor cm!
17:52:50 <dons> quick, you can cure this with ftp ;)
17:53:27 <sethk> cm, download cygwin, then run zsh
17:53:37 <cm> sethk, the reason I wondered about a global configuration setting was so that all shortcuts etc. automagically pick it up ;)
17:53:38 <sethk> cm, or bash if you want to be a prol
17:53:45 <cm> but I shall not waste your time with such questions.
17:53:59 <dons> sehtk :D
17:54:08 <Korollary> you could also get only mingw (I ran bash heh)
17:54:31 <int-e> sethk: what would using tcsh make him? (just curious, I'm a prol by your definition)
17:54:39 <Cale> Are zsh and bash all that different anymore? Even since bash got programmable completion, I've just found it easier to run bash simply because that's what most other people use.
17:54:39 <int-e> sethk: or ksh?
17:54:49 <Cale> ever*
17:54:52 <sethk> int-e, well, tcsh would make him a masochist
17:55:21 <dons> now who was using tcsh just the other day? hmm.
17:55:35 <dons> someone, and I was trying to explain why nothing was working for them.
17:55:40 <Korollary> I used to use tcsh at work because we were required to use csh and I couldn't stand it
17:56:24 <sethk> Korollary, solaris still has (I think) csh as the default shell for root, but they also have the toor user, which is root but with a reasonable shell
17:56:40 <Korollary> sethk: yes, this was on solaris
17:57:02 <sethk> Korollary, I truly hate the c shell, which I have refused to use since ksh came out.   which was a _long_ time ago
17:58:02 <Korollary> sethk: This is all moot; we'll all be using Monad once it comes out ! ;)
17:58:14 <sethk> sounds good to me
17:59:14 <dons> how long does it take them to write a shell??
17:59:31 <dons> it seems like they've been talking about Monad for years now
18:00:01 <Korollary> how long does it take to write an OS ?
18:00:01 <dons> or is this K's joke about a mythical haskell shell? ;)
18:00:12 <dons> ah, good question. 42 of course.
18:00:39 <Korollary> no, I think a haskell shell would be evil (like h4sh)
18:00:48 <dons> heh!
18:01:15 <cm> http://leetspeak.org/cgi-bin/trac.cgi/stuff/file/trunk/lsh/LSH.hs
18:01:15 <dons> shells are either list or IO monads, depending on how you view them, so it seems logical for a haskell shell to be called 'monad'
18:01:16 <cm> :o)
18:01:42 <dons> see Oleg's shell/monad isomorphism, or the little document on this that comes with h4sh
18:02:13 <cm> (this is very old code and I'm in no way responsible for any damage it may cause onto those reading it..)
18:03:05 <dons> http://www.cse.unsw.edu.au/~dons/code/h4sh/DOC
18:03:33 <dons> it's a bit half-finished, but the instances for Functor and Monad are there
18:03:52 <dons> it's kind of fun programming in the [a] monad in the shell :S
18:03:53 <wagle> monash
18:04:09 <Korollary> madness
18:04:11 <wagle> [monadish?]
18:05:44 <sethk> hash is good enough
18:09:19 <sethk> JohnMeacham, I meant to ask you, would it not make sense for -v to be the default for your compiler, and have a flag to turn _off_ verboseness?  Since you recommend turning it on to demonstrate that it isn't dead.
18:10:51 <cm> "mismatched interface file versions: expected 6041, found 6040" -- can I somehow regenerate the interface files for GHC 6.4.1? (error comes from wxHaskell)
18:11:07 <sethk> cm, just delete the .hi files, I believe
18:13:24 <dons> @seen Lemmih
18:13:24 <thbot> Lemmih is in #haskell. Last spoke 5 hours, 6 minutes and 30 seconds
18:13:24 <thbot> ago.
18:13:25 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
18:14:25 <dons> thbot, @quit
18:14:31 <dons> silly me.
18:15:57 <wagle> thbot, @come-back-to-life
18:16:03 <wagle> 8(
18:16:12 <dons> no no. we have lambdabot now, thbot was just filling in
18:17:06 <sethk> I sort of figured out why I was having problems with /pm to lambdabot at times
18:17:25 <sethk> for some reason (with xchat), sometimes it opens a new window, and other times uses the #haskell window
18:17:39 <sethk> so when I thought it wasn't responding, it was actually writing to the other window
18:17:46 <sm> is lambdabot a supybot ?
18:17:47 <int-e> sethk: it does the former for PRIVMSG and the latter for NOTICE
18:18:10 <sethk> int-e, yes, but afaik, I did the same commands  (/whatever) for both situations
18:18:12 <dons> sm, lambdabot is a lambdabot :)
18:18:14 <sethk> int-e, and didn't change my config
18:18:19 <sm> aha
18:18:26 <sm> written in haskell ?
18:18:33 <dons> @where lambdabot
18:18:33 <sethk> what's haskell ?
18:18:34 <dons> sm, yes
18:18:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:18:48 <dons> @version
18:18:49 <lambdabot> lambdabot 3p99, GHC 6.5 (OpenBSD i386)
18:18:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:18:54 <sm> it's not responding to privmsg, I suppose because it's not identified
18:18:58 <sm> thx
18:19:14 <dons> sm, good point, thanks.
18:19:26 * sm just got this worked out with supybot
18:19:47 <sethk> what's the slash command to talk to it.  Not /pm, the other one?
18:20:17 <dons>  /msg ?
18:21:11 <sethk> dons, that's one that I forgot, yes.  Isn't there another though?  Doesn't matter, /msg worked.  :)
18:33:55 <ape> hello
18:35:45 <dons> @seen musasabi
18:35:46 <lambdabot> musasabi is in #haskell-blah and #haskell. I don't know when
18:35:46 <lambdabot> musasabi last spoke.
18:36:16 <ape> dons: hey... do you know anything about that project where they want to make an IDE for haskell?
18:36:27 <dons> yes :)
18:36:31 <dons> @where hIDE
18:36:32 <lambdabot> http://www.haskell.org/hawiki/hIDE
18:36:38 <dons> check it out :)
18:37:25 <Speck> man once I get my haskell environment going again I'm gonna need to look at that hide business
18:37:30 <ape> yeah i've read that wiki page... but is there any code so far?
18:37:49 <dons> sure. check the darcs repo and the screenshots
18:38:03 <ape> screenshots?
18:38:27 <dons> e.g. on the Yi wiki
18:38:47 <ape> hm.... cool thanks, i'll check it out tomorrow i'm a bit wasted now
19:03:03 <autrijus> dons: libHSPugs-6.2.10.a linked fine and plays well with others :)
19:03:25 <autrijus> $ ghc-pkg latest Pugs
19:03:25 <autrijus> Pugs-6.2.10
19:03:44 <dons> yay :) excellent stuff
19:04:01 <sethk> what's pugs?
19:04:08 <autrijus> found half a dozen cabal and ghc bugs along the way ;)
19:04:12 <autrijus> fortunately all workaroundable.
19:04:15 <autrijus> sethk: pugscode.org
19:04:22 <autrijus> sethk: it's an implementaiton of perl 6.
19:04:27 <dons> ghc bugs?
19:04:33 <sethk> autrijus, thanks
19:04:48 <autrijus> dons: somehow the
19:04:50 <autrijus> "...\
19:04:52 <autrijus> \\n ..."
19:05:10 <autrijus> syntax did not work, either via-C or not, when linked with cabal
19:05:14 <autrijus> but straight --make is fine
19:05:33 <autrijus> "did not work" as in it's parsed as literal '\' and 'n'
19:05:40 <dons> hmm.
19:09:42 <dons> autrijus, cpp not getting involved somehow?
19:10:20 <dons> seems weird, since this is a lexer issue, and nothing to do with separate compilation
19:10:32 <dons> so i suspect something that happens prior to lexing.
19:13:50 <autrijus> dons: anyway, I worked around it, but indeed I suspect lexing
19:14:43 <dons> yeah, there's been a couple of lexer bugs since we switched over to an alex-generated one, so it's not impossible
19:15:01 <dons> esp. in corner cases like this
19:20:24 <autrijus> *nod*
19:24:03 <CosmicRay_> metaperl: nice blog post.
19:24:39 <dons> hmm. autrijus, works in ghci though
19:26:20 <dons> so when you build with cabal, the code doesn't function properly? or won't compile?
19:27:25 <autrijus> dons: it functions badly
19:27:31 <autrijus> because "lines" no longer breaks it
19:27:36 <autrijus> so I had to normalize it as a workaround
19:27:40 <autrijus> by explicitly replacing "\\n" into "\n"
19:28:36 <dons> hmm. but when? only when compiled under Cabal's control?
19:28:43 <dons> I'm trying to reproduce it here
19:29:07 <autrijus> only when compiled under cabal's control yes.
19:29:32 <autrijus> dons: you can checkout http://svn.openfoundry.org/pugs (svn) or the equiv darcs
19:29:36 <sethk> what's the definition of a supercombinator?  what makes it super?
19:29:56 <sethk> ah, found it in the haskell wiki
19:30:22 <autrijus> dons: if you comment out "renormalize" in src/Pugs/Prim.hs and/or use error to trace the long string at bottom of Prim.hs
19:30:36 <autrijus> then you'd perhaps see that \n is maligned.
19:30:41 <dons> sethk, they're at the top level or some such. it's defined in SPJs compiler book too.
19:30:41 <dave_m> sethk: supercombinators are only vulnerable to kryptonite
19:30:42 <autrijus> this is fbsd, ghc 6.4.1, vanilla.
19:30:54 <dons> ok.
19:31:58 <dons> weird, under Cabal versus ghci: Prelude T> putStrLn f
19:31:58 <dons> ..\n...
19:31:58 <dons> Prelude T> :l T.hs
19:31:58 <dons> *T> putStrLn f
19:31:58 <dons> ..
19:32:00 <dons> ...
19:33:14 <dons> ah, it was CPP!
19:33:36 <dons> turning off the extensions: CPP line in the .cabal file fixed it
19:33:47 * autrijus frowns rather sadly.
19:33:50 <dons> so I think it is just the well-known issue of cpp verus string gaps
19:33:54 <dons> try using cpphs instead, perhaps
19:35:41 <dons> you could also use (++) at compile time inside a TH splice ;)
19:36:28 <dons> $( intersperse "\n" ["my", "strings"] ) die cpp!
19:36:56 <autrijus> sadly this part is core, and I need it to build on AIX, which is not yet ghci'zed.
19:37:33 <dons> now, what's the standard way to defeat cpp here. hmm. there's some trick..
19:38:34 <dons> ah, you add a space to the end of the \ line
19:38:41 <autrijus> ...which breaks fbsd's cpp
19:38:43 <autrijus> for strange reasons.
19:38:49 <dons> oh, it's not a gnu cpp?
19:38:57 <autrijus> I imagine it is
19:39:06 <autrijus> but somehow all pkg that does this, is broken here
19:39:21 <autrijus> but it's memory from 6.2 time and fbsd 5.~early
19:39:24 <autrijus> so it may have changed
19:39:28 <autrijus> in any case I'm not using cpp :)
19:39:30 <autrijus> for Prim, that is
19:39:47 <dons> ok. good :)
19:40:14 <dons> yeah, adding a space to the end makes it work under Cabal on OpenBSD, at least
19:40:23 <dons> using $ cpp --version
19:40:23 <dons> cpp (GCC) 3.3.5 (propolice)
19:40:34 <autrijus> $ cpp --version
19:40:34 <autrijus> cpp (GCC) 3.4.4 [FreeBSD] 20050518
19:40:43 <dons> however, I seem to recall 4.x cpp breaking, or maybe it was 3.4.x
19:40:52 <dons> which was why cpphs was written
19:41:02 <dons> as cpp kept breaking our .hs code
19:42:36 <dons> another option is to force -traditional somehow
19:46:47 <autrijus> too painful
21:04:35 <JohnMeacham> hint: using ghc --make and a makefile and tired of it not picking up files you modified while it was running? use this:
21:04:39 <JohnMeacham> jhcp: $(HSFILES)
21:04:39 <JohnMeacham> 	date '+%y%m%d%H%M.%S' > /tmp/$@.date.tmp
21:04:39 <JohnMeacham> 	$(HC) $(GHCOPTS) $(EXTRAOPTS) $(GHCPROFOPTS) --make $(MAIN) -o $@
21:04:39 <JohnMeacham> 	touch -t `cat /tmp/$@.date.tmp` $@
21:05:50 <JohnMeacham> it gets the date before it starts, runs ghc, then touches the output file with the original date, which is correct from a dependency standpoint, you want the outputs date to be when the input files were read not when the compiler was finally done.
21:06:26 <JohnMeacham> here is another one: want to know all the .hs files to depend on in your --make rule?
21:06:32 <JohnMeacham>  $(HC) -M -optdep-f -optdepdep.tmp $(HC_OPTS) $(MAIN)
21:06:32 <JohnMeacham> 	echo HSFILES=`egrep -o '[A-Za-z/.]+.hs' dep.tmp | sed -e 's/^\.\///' | sort` > depend.make
22:12:19 <shapr> Good morning #haskell!
22:15:06 * shapr decides to reformat the QuotesPage
22:24:31 <shapr> coi zirpu .i xu do cilre la xaskel
22:31:23 <shapr> .uise'inai
22:33:21 <shapr> What's up today?
22:34:02 * basti_ yawns
22:34:39 <basti_> need caffeine
22:49:29 * pejo hands basti a triple ristretto
22:50:08 * basti_ has a coffee already
22:55:36 <shapr> Wow,  the new Finnish copy protection laws are evil.
22:56:34 <basti_> revolution time -.-
22:57:10 <Korollary> shapr for president
22:57:43 <ski> http://www.boingboing.net/2005/09/16/finnish_culture_mini.html http://hietanen.typepad.com/copyfraud/2005/09/the_story_of_fi.html ?
23:00:09 <basti_> always the same... :(
23:03:14 <shapr> http://www.theregister.co.uk/2005/10/06/finlands_drm_law/
23:03:35 <shapr> "But under the new laws, not only will copying for personal use become illegal, so will possessing, distributing or advertising tools that break copy protection. P2PNet points out that the law prohibits even "organised discussion" of such things."
23:04:33 <shapr> In that case, I think that the user groups should sue the Finnish lawmaking organizations for owning felt tipped markers, keyboards with shift keys, and that sort of thing.
23:05:45 <aleator> JohnMeacham: Do you have cabal for HsASA?
23:09:26 <ibid> now the interesting thing is, what does the finnish president make of the law
23:09:43 <ibid> and if it is made into law, how the courts apply it
23:09:52 <ibid> a visible test case early on would be good
23:10:06 <ibid> (but i don't want to be involved in it, except perhaps as one of the judges;)
23:10:42 <aleator> Just funny.. I'm now a kinda criminal.
23:12:07 <ibid> aleator: not yet
23:12:19 <ibid> besides, the law does not apply to past  behaviour
23:12:24 <aleator> Well. Soon anyhow.
23:13:54 <ibid> at least not in a criminal court
23:14:02 <ibid> not sure about civil suits
23:14:32 <basti_> actually germany's copyright laws have been evil all the time (and got a tad more evil recently, though not as evil as finland's is now), but nothing much ever happens because of it. You can't enforce this sort of thing.
23:15:59 <aleator> Well, It is just scary machiavellian thing. Have laws that no one enforces - and thus everyone disobeys. Then spring them on some fellow you don't like :)
23:16:25 <basti_> yep.
23:17:18 <aleator> What wouldn't I give for a country with just three laws and common sense..
23:19:09 <ibid> that would either give judges tremendous power or a system like in the usa, where most of the law is created by judges deciding precedent cases
23:19:59 <basti_> luckily not everything is like the usa.
23:22:42 <aleator> ibid: allow me my náive fantasy. It seems to me that most laws are way they are just for people that decide upon them can say "It's not my fault. It's the law" or "This is not illegal so I can do it, however foul it is."
23:25:01 <ibid> i'll allow you to keep your foolish and incorrect ideas
23:26:25 <aleator> Well. Since you have knowledge of The Truth, I'll turn other cheek for that :)
23:27:56 <ibid> i don't know if i have the truth, but i do know when i see a patent untruth
23:28:08 <ibid> (please excuse my foul mood)
23:28:40 <aleator> If you want to proceed with this, we should take it out of #haskell
23:29:21 <ibid> no, i'm not really interested
23:29:34 <ibid> i'm just in a bad mood, don't take it too personally
23:31:17 <aleator> I acknowledge your right for bad mood, but remind that allowing it to so affect your behaviour will incite hostility, whatever the message. :)
23:31:42 <aleator> But, talk about haskell now?
23:32:39 <ibid> heh :)
23:32:40 <ibid> yeah
23:32:59 <ibid> wanna review my first-lecture slides for functional programming 1?
23:33:02 <ibid> (in finnish=
23:33:03 <ibid> )
23:33:24 <aleator> I kinda already did :).
23:33:47 <ibid> oh? through batalyx?
23:33:47 <aleator> There is some pdf problem so it looks funny on kde viewer.
23:33:50 <aleator> Yep.
23:33:59 <ibid> works ok in xpdf
23:34:07 <aleator> Or atleast browsed through them.
23:34:16 <ibid> whatever viewer galeon starts has problems with the Ã¤Ã¤kkÃ¶set
23:34:43 <ibid> there's also the sxi file in the same directory
23:34:49 <aleator> Yeh. Not a big issue though.
23:35:01 <aleator> So you start straight with IO this time?
23:35:28 <ibid> yeah
23:35:57 <ibid> i'm working on a gtk2hs implementation of a SOEGraphics-style module which i plan to use, too
23:36:28 <aleator> Did they manage to install the gtk2hs in the classes?
23:38:24 <aleator> do you intend to explain monads at the beginning or the end?
23:38:42 <ibid> full monads go to the part 2 course
23:38:56 <ibid> i'm just giving a surviver course on IO :)
23:40:33 <aleator> Ok. Fine for that. what do you plan on having in the following lectures?
23:40:50 <ibid> that's what i'm figuring out right now :)
23:41:10 <ibid> i have a few ideas but we'll see what ends up being on the page :)
23:41:14 <ibid> (or slide)
23:41:39 <ibid> basic types, certainly, as well as basic lists, probably
23:42:01 <ibid> but with or without graphics, i can't yet decide
23:42:10 <aleator> i would recommend having some tutorial pointing out differences with pure functions and IOs. Otherwise this will get confusing. (Why no <- in pure functions?)
23:42:36 <aleator> Though it depends on the lecturing, more than slides.
23:42:46 <aleator>  -,
23:44:03 <ibid> what version of the first lecture slides you saw?
23:44:20 <aleator> Another thing. When studying basic haskell I got the feeling that everything must be a list. It could be nice to show some other datastructures.
23:44:22 <aleator> 1.1
23:44:30 <ibid> that's not a version number
23:44:45 <ibid> that's <course-number>.<lecture-number> :)
23:44:48 <Korollary> aleator: You can have pure monads functions, so you can have <-, return, etc. in pure code.
23:45:47 <ibid> aleator: what's the last slide?
23:46:17 <aleator> Korollary: Yeah. I know that. I would like to rephrase it "differences with 'normal' style and monadic style"
23:46:18 <ski> monads are pure
23:46:38 <ski> (or at least can be seen as, from one pov)
23:47:34 <aleator> Yes. But there are kinda like two syntaxes. Which confused me when I started.
23:48:04 <aleator> Ibid: last slide is copyright info.
23:48:36 <ibid> is this the version you looked at or are you just looking at whatever is now online?
23:48:58 <aleator> Ah.. Yes. It has changed..
23:49:48 <aleator> btw. my xpdf seems to show only 1/4th of a page.
23:50:28 <ibid> i asked because i think i deal with the issue you raise above in the new versions :)
23:50:36 <ibid> aleator: in what settings?
23:51:39 <aleator> Default? I just said xpdf <file> and it gives me top-left of the slide with no means to scroll it around like normal..
23:52:02 <aleator> But I have to go and have meeting now. bbl.
23:52:19 <ibid> strange
23:52:36 <aleator> yep. Openoffice?
23:52:44 <ibid> yeah
23:52:54 <ibid> works for me, even in xpdf
23:54:10 * boegel greets the gang
