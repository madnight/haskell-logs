00:31:43 <skew> there are useful operations like Ser a () -> (a -> Ser b c) -> Ser (a,b) c
00:44:44 <soysauce> isn't there a standard library in Haskell that can efficiently search and maintain a sorted list?
00:45:01 <soysauce> something akin to std::map in C++ or HashSet in Java...
00:45:38 <skew> data structures are a bit different
00:45:40 <vegai> Data.Map, perhaps?
00:46:03 <vegai> not a sorted list, though, but it wasn't clear what you really need
00:46:24 <soysauce> Data.Map is, I think, what I was looking for...
00:47:01 <skew> for most imperative data structures there is a functional data structure that supports the same operations in the same time, but the insides look a lot different
00:47:16 <soysauce> I have a list of elements, and I frequently have to search this list for nodes by name
00:47:24 <soysauce> which is O(n) and can obviously be done in O(log n)
00:47:27 <vegai> that's not standard, though, but probably included in most implementations
00:47:54 <vegai> is there something that supports search in O(1)?
00:48:05 <soysauce> hash tables...
00:48:30 <skew> there's one of those that lives in IO
00:48:36 <soysauce> hm
00:48:40 <soysauce> actually I have a better idea
00:48:42 <soysauce> but it will have to wait
00:49:24 <soysauce> a binary search has good search time, but I can use another data structure to dramatically reduce copying
00:49:29 <vegai> a functional hash-table is not possible, right?
00:49:46 <skew> honestly, a hash table is more like logarithmic in your word size
00:49:58 <vegai> hmm
00:50:50 <skew> and no, I don't think there is any way to make a persistent hash table, whether purely functional or internally mutating
00:52:53 <skew> If your data is big enough that the difference between a hash table and a Map matters, it's probably also big enough that you care about the storage space it's taking up too
00:53:35 <skew> and storage space is one of the few things it's easier to reason about in imperative programs
00:53:57 <pejo> Okasaki claims his implementation of balanced binary search trees really flies in practice. Also O(log n) for search.
00:55:43 <tuomov> you could make the "index" array of the hash an n-ary tree to avoid huge reallocations
00:58:33 <skew> and if you want to minimize the amount of data reallocated on an update, you'll send n to 2
00:59:06 <skew> I think
01:00:52 <skew> hmm, not quite
01:06:56 <skew> maybe e
01:25:27 <tuomov> yep, e
01:29:41 <Lemmih> John Hughes' survey says "Unspecified action" when I try to submit. Am I doing something wrong?
01:31:38 <boegel> Lemmih: same here, just mailed him on it
01:32:08 <boegel> and there's a reply on the already :)
01:32:18 <skew> where is the survey?
01:33:27 <Lemmih> http://www.cs.chalmers.se/~rjmh/Wash/Survey/Survey.cgi
01:40:32 <Cale> I get that too
01:41:54 <shapr> me too
01:42:14 <skew> works for me
01:42:41 <shapr> Did you see a blank entry before GHC?
01:43:12 <Cale> yes
01:43:14 <skew> yes
01:43:19 <shapr> hm
01:43:25 <shapr> Maybe I should turn off privoxy.
01:43:33 <Cale> oh, hmm :)
01:43:36 <skew> I filled out all the drop down things, and put some checks in every group, no text in any of the text inputs
01:43:42 <Cale> I'm running privoxy too
01:44:33 * boegel grr's on the survey thingie
01:45:15 <Cale> I know why the blank entry is there
01:45:42 <shapr> why?
01:45:43 <Cale> it's because it adds the tools listed in the edit box to the checkboxes for the next person
01:45:49 <shapr> ohh
01:45:59 <shapr> Suddenly there are more entries.
01:47:03 <shapr> aha, now it works!
01:47:14 <shapr> Oh I bet I know the problem.
01:47:44 <shapr> If you submit after someone else has updated the list of libraries but before your list is updated, I bet it explodes.
01:48:04 <shapr> Because WASH is roughly continuation-based, but uses a log.
01:49:28 <neadjneki> hi
01:49:32 <shapr> y0
01:52:36 <boegel> k, worked for me too now
01:56:38 <skew> does anyone know what happened to the Morrow interpreter?
02:03:11 <JKnecht> everytime I submit the questionnaire, I get a msg "out of sync, try again".
02:03:41 <boegel> JKnecht: try refreshing the page ?
02:04:17 <JKnecht> nope; (btw, re: http://www.cs.chalmers.se/~rjmh/Wash/Survey/Survey.cgi ).
02:06:11 <kolmodin> lisppaste2: url?
02:06:11 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
02:19:51 <kzm> hi!  Re the current discussion of error messages on the ghc-users mailing list... would it be possible to use TH to do what I currently use CPP for?
02:20:09 <kzm> I.e. provide line number and file name for error messages)
02:26:16 <araujo> Good morning!
02:26:41 <Lemmih> kzm: No.
02:27:20 <boegel> yo araujo
02:27:44 <araujo> Hi there boegel
02:27:54 <kzm> Hm.. tough luck.  We're stuck with CPP, then.
02:27:56 <araujo> How things go?
02:48:18 * roconnor wonders
02:48:34 * roconnor wonders what it would take to get ghc to complie to java bytecode
02:50:29 <eivuokko> Isn't there .net bytecode version, Mondrian or something.
03:18:26 <skew> I think there was some work on a Java backend some time ago
03:29:18 <dons> yay. my ncurses mp3 frontend in haskell is basically working :) haskell rules
03:30:26 <stefanw> do you know cplay?
03:30:56 <dons> nope. but I was looking at ksmp3play
03:31:04 <dons> which is nice, sort of mutt like. but segfaults
03:31:13 <dons> however, hmp3 is almost done :)
03:31:15 <stefanw> cplay is good
03:31:26 <dons> maybe i should check it out then
03:31:47 <dons> installing ...
03:32:23 <dons> ah, yes. i have looked at cplay
03:32:25 <skew> also mpd
03:32:28 <dons> a bit spartan.
03:33:27 <dons> oh. that's right. cplay doesn't seem to work nicely on openbsd.
03:33:41 <tuomov> moc is nice
03:33:51 <tuomov> (music on console)
03:33:55 <gour> dcoutts: i do not have luck with darcs+meld combo
03:34:08 <dons> hey tuomov
03:34:18 <tuomov> hey dons
03:34:45 <tuomov> most of the other curses players are a bit too playlist-oriented for me, but moc is quite straightforward to use for playing full albums in directories
03:35:13 <dons> right. that's interesting. that's what I was trying to do as well
03:37:09 <stefanw> dons: did you use some of the widgets in hscurses?
03:37:34 <dons> not yet.
03:38:03 <dons> just started a few hours ago. mthe general structure is in place, but pretty gui details are missing
03:39:03 <tuomov> is it just a frontend to e.g. mpg321 or are you using e.g. mad directly?
03:39:22 <dons> just a frontend to mpg321
03:39:28 <dons> to its -R mode
03:39:55 <dons> which is a nice text interface
03:40:02 <stefanw> ozones multimedia library would be interesting, again ;-)
03:40:04 <tuomov> I've had some latency issues with those players..
03:40:24 <dons> hmm. i've not noticed anything so far. but i'll keep an eye out then tuomov
03:41:04 <tuomov> at one point I just wrote a very dummy command line player for alsa (cos - "continuum of sound" :) that had a realtime thread for dumping decoded data to the soundcard, but then at some point moc started working fine
03:41:37 <tuomov> the latency issues are due to a very short buffer on my sound card
03:46:15 <skew> here's an idea: make a "with-open-file" using Oleg's region monad
03:48:23 <musasabi> Why not simply, withOpenFile :: MonadIO m => FilePath -> (Handle -> m a) -> m a
03:48:32 <skew> to prevent escape of the handle
03:49:07 <musasabi> sounds interesting, like ST?
03:49:20 <skew> same idea
03:49:33 <shapr> Wow, 54% self-study.
03:49:55 <shapr> hej usr26762
03:50:02 <mentomorph> hej
03:50:10 <mentomorph> hej shapr :)
03:50:14 <shapr> How's Gothenburg treating you?
03:50:27 <skew> There is apparently some dispute between the Scheme and Common Lisp people about whether Scheme should provide an unwind-protect, the question being what to do when you jump back in with a continuation
03:50:46 <mentomorph> Its been kind to me and I'm kind back.
03:50:47 <mentomorph> thc
03:51:13 <shapr> That's fair.
03:51:35 <skew> I was thinking some fancy types to keep you from smuggling out values might help, but maybe the types would just prevent you from jumping back in
03:52:27 <dcoutts> gour, what's the problem? I've not tried it either. I think meld needs a darcs plugin (it does now have a plugin interface for new vcs)
03:58:00 <gour> dcoutts: well, while trying to test darcs+meld i bumped on possible darcs bug
03:59:24 <gour> dcoutts: see http://bugs.darcs.net//index.html?q=577
03:59:44 <gour> dcoutts: there is small tarball included, try if you can reproduce it
04:00:07 <gour> dcoutts: otherwise, i agree that darcs plugin would be nice for meld
04:00:35 <gour> dcoutts: btw, i submitted ticket for that warnings and new meld-1.1.2 is already relased :-)
04:03:14 <dcoutts> gour, yes and it fixes the warnings
04:03:57 <dcoutts> gour, but the meld author is not writign new vcs plugins, someone who knows darcs and python will have to do that. It doesn't look hard however.
04:04:05 <olliej> anyone know a way to make ghc not decompose floating point values when it peforms floating point arithmetic
04:04:08 <olliej> ?
04:04:29 <dcoutts> decompose floating point values?
04:04:36 * dcoutts does not understand
04:04:51 <olliej> ghc decodes floating point values
04:04:56 <gour> dcoutts: so we have to canvas some python user ;)
04:05:04 <olliej> and then does arithmetic using the mantissa exponent, etc directly
04:05:14 <olliej> then recodes it all into a floating point vlaue again
04:05:28 <musasabi> olliej: are you *sure* about this?
04:05:31 <dcoutts> gour, yeah
04:05:47 <olliej> musasabi: yes, i'm looking at the core output
04:06:06 <olliej> and its calls to (de|en)codeFloat#
04:06:09 <gour> dcoutts: is there some extension for galeon browser to save the complete page in one archive file?
04:06:19 <dcoutts> gour, no idea
04:06:21 <shapr> gour: There's a firefox extension for that.
04:07:17 <gour> shapr: i know that, but there is none for epiphany (i opened a ticket), and what about galeon?
04:07:43 <shapr> We could always write our own based on MozEmbed. :-)
04:08:11 <gour> ahh, how many lives we would need to write everything...
04:08:45 <shapr> Probably less lives than we would need to fix all the bugs in the C software.
04:08:47 <gour> those are so basic things...
04:09:43 * gour lol
04:09:55 <gour> shapr: are you on gnome?
04:10:00 * dcoutts goes back to adding OpenGL support to Gtk2Hs
04:10:17 <shapr> Nah, I use ion3 and emacs.
04:10:23 * gour shouts "Jay dcoutts!"
04:11:55 <gour> shapr: so your cat does not get any food :-)
04:12:29 <gour> shapr: and no rsi ;)
04:12:35 <shapr> That's right.
04:12:48 <shapr> I do have a mouse, and I use it about once every five minutes or so.
04:15:24 <gour> shapr: and what's (if something) happening with vis?
04:15:41 <musasabi> Only shows GHC.Prim.+## for me.
04:15:42 <shapr> You'd have to ask the man behind vis, tuomov.
04:22:00 <dcoutts> Has everyone filled in the "Haskell Users Survey" yet?
04:22:01 <dcoutts> http://www.cs.chalmers.se/~rjmh/Wash/Survey/Survey.cgi
04:23:27 <gour> dcoutts: yes
04:25:32 <shapr> I did.
04:26:59 * boegel raises his hand
04:31:17 <jlouis> oy guys
04:31:26 <shapr> wha?
04:31:41 <jlouis> hey guys ;)
04:31:52 <shapr> hiya
04:38:00 <shapr> g'day Hasu
04:38:03 <jlouis> Theres some new Conjure patches, but none from e-mail the last days
04:38:17 <shapr> Did you see SamB's WireProtocol.hs ?
04:38:51 <jlouis> Not yet ;)
04:38:55 <jlouis> sounds really cool
04:39:03 <Hasu> hi shammah
04:39:09 <Hasu> shapr,
04:39:42 <jlouis> its probably in my inbox. I'll have to look at it later today when I get this box re-installed
04:40:03 <jlouis> I am not on the 'net all days at the time being, so...
04:40:19 <jlouis> it takes a while to integrate patches. But they will be
04:42:18 <jlouis> hi Jeroen!
04:42:38 <shapr> Hasu: Are you learning Haskell?
04:46:11 <Hasu> yeah, at uni shapr
04:46:19 <shapr> Do you have any questions?
04:46:37 <Hasu> not at the moment
04:46:38 <Hasu> just idling
04:46:54 <Hasu> hey is your internet address in ipv6??
04:48:06 <jlouis> dead:beef:baad:f00d::1
04:50:46 <shapr> Yes, I'm on IRC via 6to4
04:53:36 <shapr> Hasu: If you have a public IPv4 address, setup 6to4 and connect to irc.ipv6.freenode.net
04:54:43 <frederik_> i'm modifying HSQL to add an "instance SqlBind a => SqlBind (Maybe a)" - has anyone done this yet?
04:54:52 <frederik_> and the current version of HSQL is 1.6, right?
04:55:00 <frederik_> i want to make it easier to use NULL values in my algorithm
04:55:05 <Hasu> so how does that work, the internet uses ipv4 at the moment right? does it encapsulate the ipv6 frames in ipv4?
04:55:42 <Hasu> also how good are the linux kernel ipv6 modules?
04:56:52 <wilx> How good?
04:57:00 <wilx> They are working afaik :)
04:57:06 <shapr> There are native IPv6 runs. 6to4 and 6over4 are both IPv6 encapsulated in IPv4.
04:57:22 <shapr> I've been using the linux kernel IPv6 modules for ... hm, years?
04:57:45 <pesco> shapr: What. What are you talking about? IPv6?
04:57:50 <pesco> I'm just coming back from lunch.
04:57:59 <pesco> And we need to fix the Internet.
04:58:02 <Hasu> i was just wondering if they were stable
04:58:08 <pesco> Oh.
04:58:11 <Hasu> so they are apparently
04:58:16 <Hasu> i'll have to look into it soon
04:58:22 <pesco> Yes yes, I have a running IPv6 setup at home.
04:58:29 <shapr> The only disadvantage to 6over4 and 6to4 is that they depend on the underlying IPv4 runs for multicast. That means that 99% of the time, you don't get the nifty abilities of multicast.
04:58:59 <pesco> shapr: Can you sum up really quick, what are 6over4 and 6to4?
04:59:02 <Hasu> what's the difference with ipv6 multicast?
04:59:18 <shapr> IPv4 doesn't have multicast as basic feature, IPv6 does.
04:59:31 <shapr> pesco: Ways to run IPv6 inside IPv4.
04:59:56 <shapr> 6to4 is the most common, because it autoconfigs from your public IPv4 address.
04:59:57 <pesco> I know that there is reserved address space in IPv6 to encapsulate IPv4 addresses.
05:00:25 <pesco> So a v6 host can send to a v4 host. But how can the v4 host send back if the v6 one has no v4 address?
05:00:32 <pesco> Can any of those two schemes do that?
05:00:41 <shapr> Sure, because v6 hosts can only send to v6 hosts.
05:00:51 <shapr> 6to4 means that a v4 host can be a v6 host.
05:01:28 <pesco> Yes, but that requires a v6 routing infrastructure as well, which we don't have (for the most part).
05:01:40 <pesco> (i.e. in the comman internet connections)
05:01:43 <shapr> When you send from a 6to4 address, the nearest 6to4 router picks up your packets and sends them into the 'real' IPv6 address space.
05:02:24 <shapr> You know about the special IP addresses in v4 that mean 'nearest router' 'all routers on the subnet' and that sort of thing?
05:02:38 <pesco> Oh. No, I don't. are they a newer invention?
05:02:52 <shapr> I think they're not that much newer than 127.0.0.1 and other special addresses.
05:02:58 <pesco> :) Heheh.
05:03:25 <shapr> Most people do know about 10.*.*.* and 192.168.*.* and.. what's the other one?
05:03:37 <shapr> 176 something?
05:03:40 * shapr forgets...
05:04:09 <shapr> Hasu: Are you a TCP/IP expert? Do you remember the other private address?
05:04:11 <pesco> So the idea of 6to4 is to assign every v4 host a v6 address and have them put their v6 packets inside a v4 packet and send that to one of those addresses?
05:04:19 <pesco> 172 maybe?
05:04:19 <shapr> Right, exactly.
05:04:27 <shapr> Oh I think it is 172 something.
05:04:31 <Hasu> it's the different classes of network
05:04:35 <Hasu> wait i've got the RFC here..
05:04:37 <pesco> And is 6to4 supported by anyone?
05:04:53 <shapr> It's been supported everywhere I've been.
05:04:57 <shapr> Finland and Sweden.
05:04:58 <Hasu> if i was an expert i'd know more about ipv6 :)
05:05:04 <shapr> True that :-)
05:05:10 <shapr> I'm not an expert either, that's for sure.
05:05:44 <pesco> So I could just roll out a v6-only ISP and my users would all be fine as long as their peers had 6to4-capable hosts?
05:06:23 <shapr> Their peers would have to have 6to4 installed and working.
05:06:35 <pesco> Oh, there's the problem, it requires setup. Why?
05:06:38 <shapr> And, 6to4 can't receive multicasts.
05:06:51 <Hasu> it is 172.16.0.0/20
05:06:55 <pesco> Well, the "common people" don't use multicast, do they?
05:07:01 <shapr> They would if it were available.
05:07:11 <pesco> Which it would be anyway in a "real" v6 environment.
05:07:15 <Hasu> kind of a funny one
05:07:17 <shapr> It'd cut down FPS shooter bandwidth by 50% or more.
05:07:33 <pesco> Right. So we just need to get everyone on v6.
05:07:54 <shapr> It would mean that debian.org's bandwidth would drop by a huge amount. They'd just multicast new packages and interested parties would get what they need off the cast.
05:08:05 <pesco> Right.
05:08:11 <pesco> I want multicast.
05:08:13 <shapr> RSS feeds would work the same way too.
05:08:21 <pesco> Death to polling.
05:08:28 <shapr> You'd never get slashdotted :-)
05:08:37 <dcoutts> boegel, can I distribute a deriative of your RotatingCube.lhs demo as part of the Gtk2Hs OpenGL demos collection
05:08:38 <pesco> Anyway. Why does 6to4 require any setup?
05:08:39 <shapr> You'd just multicast-loop your website.
05:09:02 <pesco> And what is 6over4?
05:09:04 <shapr> Because most computers don't have an IPv6 stack instaled.
05:09:25 <pesco> Right.
05:09:29 <shapr> At least it's standard equipment in recent versions of Windows and Linux.
05:10:01 <pesco> It is in Linux. For Windows, I don't know. Is it?
05:10:05 <shapr> Yup.
05:10:11 <pesco> So on newer Windows' there is no setup required?
05:10:27 <shapr> I think you still need to turn on 6to4.
05:10:33 <pesco> Damn.
05:10:42 <shapr> And you require a public IPv4, which not everyone has.
05:10:48 <pesco> Ah, that's true.
05:10:49 <shapr> NAT'd addresses don't work.
05:10:55 <pesco> I forgot about that for a second.
05:10:59 <shapr> Hasu: Anyway, do you have any questions about Haskell?
05:11:08 <shapr> Hasu: Thanks for the reminder about the other private address.
05:11:35 <Hasu> shapr, not at the moment, when i start doing some study tomorrow i might
05:11:50 <jlouis> 172.16/12
05:11:54 <jlouis> 192.168/16
05:11:56 <jlouis> and 10/8
05:11:59 <jlouis> RFC 1918
05:12:09 <Hasu> beat ya to it jlouis :)
05:13:05 <jlouis> IPv6 is cool. My own networks runs inside IPv6
05:14:57 <boegel> dcoutts: it's not mine, I found it somewhere and adjusted it so it'd work again with HOpenGL, some I'm completely fine with that
05:15:43 <pesco> Does BitTorrent support IPv6?
05:15:44 <shapr> I think it's Igloo's Cube.
05:15:47 <shapr> pesco: yes.
05:15:48 <pesco> (I think it does.)
05:15:50 <pesco> Ah.
05:16:02 <shapr> Though I haven't found anyone else running bt with IPv6
05:16:07 <shapr> I can never connect to anyone that way.
05:16:24 <shapr> Some smart crackers do portscan me via IPv6 occasionally.
05:16:51 <dcoutts> boegel, do you know if we need a license for it? Where did it come from?
05:16:52 <pesco> I hope bt will use v6 by default if it is available, though.
05:17:16 <dcoutts> boegel, or did you translate it from a C demo?
05:18:57 <pesco> Anyway, that's not a big problem. I think some considerable part of the internet populace could have become responsive to the arguments "no longer firewalled" and "static ip-address". /As long/ as they can still connect to everyone else.
05:20:31 <syntaxfree> "main = do name<-getLine" picks up one line from stdin and stores in name.
05:20:41 <roconnor> My university gives me an IPv6 address.  Is there a way to connect to freenode though this?
05:20:47 <syntaxfree> so I can do some processing with it. I'd like to do processing with _every_ line from stdin until EOF.
05:20:54 * roconnor knows nothinga about ipv6 issues
05:20:56 <shapr> roconnor: Yes, irc.ipv6.freenode.net
05:21:42 <boegel> dcoutts: no, it was Haskell code.. I thought I plucked it from the wiki somewhere, let me see
05:22:36 <shapr> roconnor: You can test your IPv6 connectivity by looking at unicycle videos :-) http://[2002:51e0:9345::2]/~shae/unifilms/
05:22:37 <shapr> doh
05:22:52 <skew> syntaxfree: well, how about fmap lines getContents
05:22:53 <boegel> dcoutts: is it this one (2nd one on this page):
05:22:57 <boegel> http://haskell.org/hawiki/HaskellOpenGl
05:23:28 <syntaxfree> getContents will get everything out of stdin until eof?
05:23:30 <syntaxfree> @type fmap
05:23:31 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
05:23:33 <skew> yes
05:23:40 <syntaxfree> @type lines
05:23:40 <lambdabot> String -> [String]
05:23:51 <syntaxfree> I think I just need getContents, then :)
05:23:54 <dcoutts> boegel, ok, thanks
05:24:12 <syntaxfree> @eval lines "It will intersperse this with \n's?"
05:24:13 <lambdabot> ["It will intersperse this with ","'s?"]
05:24:36 <syntaxfree> @eval "It is \n not \n the opposite of Unlines then :-P"
05:24:37 <lambdabot> "It is \n not \n the opposite of Unlines then :-P"
05:24:48 <syntaxfree> well, I get the picture.
05:25:13 <syntaxfree> thanks for the direct-to-the-point yet informative help :)
05:26:12 <boegel> dcoutts: np :)
05:26:37 <skew> someone made up a list of plausible laws you might want from lines and unlines
05:26:38 <syntaxfree> I've been storing text files in different types of Caesar cyphers for a while.
05:27:15 <syntaxfree> and I wrote a text filter that will translate them to the most likely caesar un-cyphering according to letter frequency in english.
05:27:30 <roconnor> Unable to connect to remote host: Network is unreachable
05:27:35 <shapr> Hey my friend just told me about cheesy spammer trick.
05:27:35 <roconnor> oh well
05:27:43 <shapr> roconnor: You can test your IPv6 connectivity by looking at unicycle videos :-) http://[2002:51e0:9345::2]/~shae/unifilms/
05:27:59 <syntaxfree> even if the tricks were clever, they're still spammers.
05:28:18 <roconnor> Hmm, strange
05:28:23 <roconnor> still cannot connect
05:28:31 <shapr> What does traceroute6 give you?
05:29:00 <roconnor> connect: Network is unreachable
05:29:04 <roconnor> not a good sign
05:29:11 <shapr> Do you get any hops at all?
05:29:16 <roconnor> nothing
05:29:26 <shapr> Do you have the IPv6 module loaded?
05:29:41 <roconnor> ifconfig gives inet6 addr: fe80::20a:e4ff:fe2f:6b04/64
05:29:47 <shapr> lemme trace to that.
05:29:59 <tomaszz> stepcut: are you there?
05:30:13 <shapr> Says it's an invalid argument?
05:30:37 <musasabi> FE80 is that link local?
05:30:46 * shapr doesn't remember.
05:32:47 <kpreid_> my Mac has assigned itself an fe80:: address, so it probably is
05:33:22 <roconnor> oh
05:33:39 <roconnor> so maybe linux just gave me an ipv6 address, and not the university.
05:34:53 <earthy> that 20a:e4ff:fe2f:6b04 is probably directly related to the MAC address of your network card
05:35:10 <musasabi> roconnor: linux does that.
05:36:12 <earthy> um
05:36:17 <roconnor> indeed
05:36:18 <earthy> IPv6 *demands* that, even. ;)
05:38:51 <earthy> oh, and given the n032194.cs.kun.nl address I know for a fact you won't get IPv6 connectivity yet. ;)
05:39:10 <earthy> (what the?! shouldn't that resolve to cs.ru.nl?!)
05:39:49 <roconnor> I guess I'm not at Berkeley anymore.
05:42:20 <syntaxfree> you know what's odd?
05:42:49 <syntaxfree> if I import List under my own custom-made module Textile, I can use List functions in the code for the Textile module, but not in the code file that imports Textile.
05:44:40 <earthy> roconnor: definitely not. You're at the mercy of two levels of systems administration where it comes to your networking :)
05:51:30 <shapr> syntaxfree: Did you re-export List from Textile?
05:51:54 <musasabi> module Textile (..., module List) where import List ...
05:52:20 <chr1s> hey everyone, I'm trying to pick up haskell again
05:52:29 <shapr> So the nasty spammer trick my friend found is that if you ssh into *.homlinux.net you get to some random redhat box. That box then ssh's into \1.homelinux.net and tries to crack into your box.
05:52:42 <shapr> hiya chr1s, welcome to lambdaholics anonymous.
05:52:49 <chr1s> hehe
05:53:33 <chr1s> I'm trying to generate random numbers, I know I'll have to use System.Random (in GHC), but I didn't find a good explanation on using classes and stuff.
05:54:25 <chr1s> Can someone give me a kick in the right direction?
05:56:49 <boegel> chr1s: working witk random numbers is quite tricky
05:57:13 <chr1s> Yeah, it's definately not as easy as in c :)
05:57:16 <boegel> if you really want them to be random, there's no easy way afaik
05:57:19 <skew> look up System.Random, then use the functions listed under "class Random a", pretending a is whatever you're trying to generate
05:57:27 <boegel> hey, don't mention C here will you !
05:57:28 <boegel> :P
05:57:37 <chr1s> skew: that's exactly what I was intending to do
05:58:00 <chr1s> but I'll have to use System.Random
05:58:11 <chr1s> Can I do that by 'import System.Random'?
05:58:19 <pesco> Yep. :)
05:59:08 <pesco> Is there a ready-made monad for drawing random numbers in the standard libraries?
05:59:11 <boegel> chr1s: or 'import System.Random (function1,function2)
05:59:21 <musasabi> Actually System.Random is easier than C.
05:59:23 <chr1s> ah :)
05:59:25 <skew> randomIO is in IO
05:59:42 <boegel> it is ?
05:59:44 * boegel is shocked
05:59:46 <musasabi> With C you have to scale by hand and there are wrong ways of doing that.
06:00:13 <musasabi> and play around whether the scale used happens to be smaller or larger than you need etc
06:00:19 <chr1s> musasabi: that' true, but I didn't do haskell for about a year, so it's not very easy for me :)
06:01:10 <musasabi> basically randomIO "get a random value of the specified type in the IO monad" randomRIO (low,high) "get a random value between low and high in the IO monad"
06:02:11 <skew> pesco: random and randomR are perfect for wrapping up in the State monad
06:02:48 <skew> in a State StdGen monad, that is
06:02:59 <pesco> skew: Ah, I see.
06:27:08 <gour> anyone has some time to do some simple testing to debug darcs bug?
06:27:22 <gour> it requires 32-bit system
06:28:17 <gour> droundy asked me to test on 32-bit, but i only have access to amd64
06:35:24 <gour> dcoutts: do you have 10min to do some darcs testing?
06:43:04 <glasser> pesco: there is a MonadRandom on the wiki
06:43:08 <glasser> by Cale
06:43:19 <glasser> it gives you a Rand monad, which is basically just a specialized state monad
06:43:23 <xerox> MonadRandom rocks!
06:43:27 <glasser> I found it to work really well
06:43:33 <pesco> Yo.
06:44:28 <glasser> (sadly I do not yet understand the art of making efficient Haskell programs and the bayes-net inference program I made for my class project was so so so slow... I hope I don't do too poorly because I could only do about a tenth of the sample size of the sample Java code :( )
06:44:59 <xerox> Did you try profiling the code?
06:47:45 <glasser> Yeah, I did at first, which helped me clean up some things
06:48:25 <glasser> I suspect the fundamental problem was that my main data structure was a Data.Map with Data.Maps as keys; I could have saved a lot of memory by converting the keys to numbers and using an array
06:48:39 <glasser> (and possibly time too, unclear)
06:49:31 <musasabi> glasser: what data structures did the java code use?
06:49:59 <glasser> so, each structure represents a conditional probability table, with inputs over a finite domain
06:50:11 <skew> maps as keys?
06:50:30 <glasser> in my code, this was a Map with keys like {"Foo":="true","Bar":="ack"}
06:50:41 <skew> maps are pretty inefficient to be comparing all the time
06:50:52 <skew> oh, you are coding states as maps for the baysian stuff
06:51:16 <skew> yeah, compiling down to UArray Int Int would probably help a lot
06:51:18 <glasser> but since for each table, the inputs should have had the same keys and values drawn from a fixed finite set, I could have just converted into an integer (basically just using variable base encoding)
06:51:38 <glasser> Doing it my way made some of the code a whole lot cleaner, but all the map comparing sucked
06:51:43 <skew> that should be even better
06:52:06 <glasser> it made combining two maps (factor multiplication) really nice though...
06:52:12 <skew> but I don't know how well field access would work, though
06:56:15 <SamB> @seen jlouis
06:56:16 <lambdabot> jlouis is in #haskell. Last spoke 1 hour, 43 minutes and 10 seconds ago.
06:56:20 * SamB is testing
06:56:36 <jlouis> hey SamB
06:56:40 <jlouis> I am alive
06:56:41 <SamB> testing to make sure @seen really works
06:56:50 <SamB> or something
06:56:58 <SamB> jlouis: hey
06:57:06 <SamB> I didn't think you were dead
06:57:21 <jlouis> I still need to apply your patches. Will do when I get home from work.
06:57:22 <SamB> though it was pretty odd for you to be in the channel but AFK all day
06:57:42 <jlouis> I always lurk
06:57:47 <SamB> do you use screen or something?
06:58:03 <jlouis> even worse; screen on a host which I ssh to
06:58:14 <SamB> yeah, thats what I meant
06:59:00 <jlouis> And I do not have an internet connection at home (2-3 weeks until they set it up)
06:59:05 <SamB> hmm, I sense some conflicts brewing
06:59:17 <jlouis> Ah, i'll merge them
06:59:21 <SamB> for one, I made SHA1 illiterate to pacify haddock
06:59:38 <jlouis> cool!
06:59:42 <jlouis> I was thinking about that
07:00:22 <skew> haddock still doesn't do lhs?
07:01:17 <jlouis> SamB: So, while I might need 24 hours or so to pick up stuff, I _am_ going to add it for sure
07:03:08 <SamB> jlouis: so do you really want to do the merges or shall I attempt it?
07:04:06 <jlouis> SamB: Up to you. Whats on j.mongers.org is the newest things I did yesterday. I am in the process of a laptop reinstallation, so my mail setup is a bit flaky
07:04:22 <jlouis> and I am compiling like mad.
07:04:34 <jlouis> It will take some time before I am totally ``up to par''
07:07:02 <marcot> I'm trying to complile c2hs 0.14.3, but I have an error:
07:07:14 <marcot> Could not find module `CForeign':
07:07:24 <marcot> Does anyone know what it is?
07:07:30 <xerox> @index CForeign
07:07:31 <lambdabot> bzzt
07:07:34 <marcot> I mean, there's no CForeign in GHC.
07:07:43 <xerox> I think 'import CForeign' will do it
07:08:17 <marcot> hum..
07:08:55 <marcot> But is this a problem in the released version of c2hs?
07:09:25 <xerox> It is not a problem :-)
07:09:47 <marcot> I got this error message in the ./Setup.hs build.
07:09:51 <marcot> Isn't it?
07:09:53 <xerox> Uh..
07:09:58 <xerox> While building c2hs?
07:10:12 <marcot> xerox: yes.
07:10:29 <xerox> marcot: try s/CForeign/Foreign.C/
07:10:45 <marcot> xerox: in the released version? Ins't this strange?
07:11:22 <xerox> marcot: maybe Michael doesn't know about the latest GHC changes, like renaming CForeign..
07:11:55 <marcot> xerox: hum... but there's no CForeign in the error file:
07:12:05 <SamB> okay, I'm giving ftBEncode a meaningful name
07:12:11 <marcot> Chasing modules from: c2hs/toplevel/Main.hs
07:12:11 <marcot> Could not find module `CForeign':
07:12:18 <marcot> marcot@tonhao:~/desenvolvimento/debian/c2hs/c2hs-0.14.3/c2hs/toplevel$ grep CForeign Main.hs
07:12:22 <marcot> marcot@tonhao:~/desenvolvimento/debian/c2hs/c2hs-0.14.3/c2hs/toplevel$
07:12:25 <xerox> marcot: try 'grep -rni CForeign .' from the base directory of the sources
07:12:51 <xerox> marcot: it will tell filename and line number, searching recursively everywhere from the current working directory
07:14:03 <marcot> There's a CForeign.hs file.
07:14:10 <xerox> D'oh.
07:14:27 <marcot> Which imports some modules and exports them.
07:14:35 <xerox> Which modules?
07:14:35 <marcot> it's in doc/c2hs/lib
07:14:44 <marcot> import CTypes
07:14:45 <marcot> import CTypesISO
07:14:45 <marcot> import CError
07:14:45 <marcot> import CString
07:14:52 <xerox> Hmmm.
07:14:59 <marcot> But why isn't it reading this module is the problem.
07:15:04 <xerox> Where is CForeign imported anyway?
07:15:33 <marcot> ./c2hs/toplevel/C2HSConfig.hs:45:import CForeign (CInt)
07:15:41 <marcot> ./c2hs/lib/C2HS.hs:64:import CForeign
07:15:45 <marcot> /c2hs/gen/CInfo.hs:64:import CForeign
07:15:52 <marcot> Just these.
07:16:33 <xerox> :-|
07:16:42 <xerox> C2HS isn't meant to use anymore, though
07:16:56 <marcot> xerox: why?
07:17:18 <marcot> Doesn't gtk2hs uses it?
07:17:22 <xerox> Nah
07:17:36 <xerox> I mean, it contains some simple definition one can live without
07:17:57 <xerox> ..furthermore, locating C2HS during compilation is kinda a pain, because c2hs doesn't make a -package
07:18:01 <marcot> ok, you're talking about the lib. What about the binary?
07:18:25 <xerox> Try changing CForeign to Foreign.C
07:18:43 <xerox> (Yes, I was talking about C2HS.hs specifically, sorry)
07:18:57 <marcot> I'll mail chak about it.
07:19:06 <marcot> xerox: do you think that the binary is good?
07:19:17 <xerox> It would be nice if you do it on the mailing list (about C2HS.hs I mean)
07:19:22 <xerox> c2hs is *great* :-)
07:19:26 <xerox> (The program)
07:19:55 <ValarQ> it is?
07:20:03 * ValarQ searches for c2hs
07:20:07 <marcot> xerox: gtk2hs uses only the program, right?
07:20:19 <SamB> jlouis: so I made a patch, and I pulled it and all of the patches I just pulled from you into my publicly-accessible repository, and didn't get any complaints about conflicts
07:21:31 <xerox> marcot: Haskell has a nice FFI, c2hs makes it even better, with its annotated haskell sub-language.  Gtk2Hs uses it, yes.  I recommend it to anyone writing bindings to C libraries.
07:23:20 <SamB> jlouis: I'm just going to send you all my patches again. I can't be bothered to figure out how to get darcs to tell me what patches this last one depends on...
07:24:42 <SamB> what I can't understand is why none of these hunks look a bit like mergers...
07:25:30 <gour> xerox: does c2hs supports #enum hooks (in the tutorial it is written that it is not supported, although c2hs paper writes about it) ?
07:25:42 <marcot> xerox: I'm using it for developing haskell binding for a C library called gpc.
07:25:47 <xerox> gour: it does, with some limitations IIRC.
07:26:05 <xerox> gour: that is, named enums are still unimplemented, I think.
07:26:15 <marcot> But I'm have a problem in marshing parameters, the doc is not very good about it.
07:26:18 <xerox> marcot: cool, what is it about?  Precision Calculation?
07:26:20 <marcot> using fun
07:26:23 <jlouis> SamB: darcs send should just figure out patches I am missing
07:26:31 <marcot> xerox: no, Polygon operations.
07:26:31 <SamB> jlouis: well, yes.
07:26:44 <SamB> but I sent most of them to you before also
07:26:54 <xerox> marcot: I see.  Could you describe your problem?  I've a little experience with c2hs.
07:27:16 <jlouis> For how long time ago? I am currently far behind on patch merging. Anyway, sending them twice doesn't hurt. Darcs can figure out stuff
07:27:34 <xerox> Sentient revision control, woot.
07:27:35 <jlouis> I had hoped to be able to do it today, but the laptop here needs more software compiled
07:27:40 <marcot> xerox: I couldn't understand what kind of functions must be in inmarsh.
07:27:58 <xerox> marcot: there are different possibilities.
07:28:01 <jlouis> so its going to be in the j.mongers.org repo tomorrow
07:28:23 <marcot> xerox: I wanted to make a haskell function for a C void function which the return is the last parameter.
07:28:44 <marcot> like, polygon_clip(int op, polygon *a, polygon *b, polygon *result)
07:28:56 <xerox> marcot: ah, I see.  Wait a second.
07:28:58 <jlouis> SamB: I am sorry I can't do better right now. But that is how it is
07:29:10 <SamB> jlouis: don't worry!
07:29:21 <gour> xerox: thanks
07:29:40 <marcot> xerox: and I have a function polygonToCPolygon, which converts from the haskell type to the C type.
07:29:41 <shapr> I am really tired of people doing off-site linking to images on my server.
07:29:43 <gour> xerox: should we ask for the feature on the list? i posted about, but got no reply
07:29:57 <xerox> gour: you're welcome.  Anyway, it is very usable.  The problem with them is not so usual, and it can be passed by.
07:30:08 <xerox> marcot: what type does this function have?
07:30:17 <SamB> jlouis: not too long ago, no more than a couple of days
07:30:25 <SamB> its only 11 patches in all
07:30:35 <gour> xerox: well, one library i plan to bind, there are lot of #defines
07:30:45 <marcot> xerox: Something like polygonClip :: Int -> Polygon -> Polygon -> Polygon
07:30:47 <jlouis> shapr: Catch them and link them to a 32000x32000 jpeg with a big HASKELL ROCKZ banner
07:30:48 <basti_> did a "nopcode" show up here?
07:31:13 <shapr> jlouis: I pay for my own bandwidth. I'd rather 302 them to goatse.cx
07:31:17 <marcot> xerox: but the biggest problem is creating a struct withou having to write more C code.
07:32:05 <jlouis> SamB: I might have missed them. I pulled mail today and yesterday I did not pull mail at all. I am going to look at the mail at home
07:32:15 <jlouis> SamB: just resend the patches. I'll take them in and process them
07:32:18 <xinming> fun :: a -> a
07:32:27 <xinming> fun = reverse
07:32:28 <jlouis> @type id
07:32:29 <lambdabot> forall a. a -> a
07:32:32 <xinming> will this do right thing please?
07:32:35 <xerox> marcot: try with "polygonToClip*"
07:32:38 <SamB> jlouis: well, as I said, I sent them all again.
07:32:46 <jlouis> SamB: ok. Cool.
07:32:49 <ValarQ> @type reverse
07:32:50 <SamB> oh, and the 11th patch I just made right now.
07:32:50 <lambdabot> forall a. [a] -> [a]
07:32:52 <xinming> I mean, the definition of fun doesn't have a variable.
07:33:01 <xerox> Both inmarsh and outmarsh are identifiers of Haskell marshalling functions. By default they are assumed to be pure functions; if they have to be executed in the IO monad, the function name needs to be followed by a star symbol *. Alternatively, the identifier may be followed by a minux sign -, in which case the Haskell type does not appear as an argument (in marshaller) or result (out marshaller) of the generated Haskell function.
07:33:02 <marcot> xerox: ?
07:33:08 <xerox> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs-3.html#ss3.7
07:33:24 <marcot> xerox: I've read this.
07:33:25 <xinming> ValarQ: I don't mean the type and function.
07:33:29 <marcot> I've already tried some things.
07:33:35 * SamB goes to take his shower and then do his chores
07:33:37 <marcot> But the generetad haskell code is kind of strange.
07:33:46 <xinming> fun = reverse, But the definition takes an argument,
07:33:47 <marcot> Full of lambda notations.
07:33:56 <xinming> will this work?
07:34:06 <shapr> jlouis: I am tempted to 302 to an html page with <img width="999999" height="999999"> since that's an easy way to crash unpatched Windows.
07:34:23 <ValarQ> xinming: yes, it will work
07:34:26 <shapr> Yesterday's Windows vulnerability is WMF and eWMF files.
07:34:38 <ValarQ> xinming: thought i believe that the type a -> a is wrong
07:34:52 <xinming> ValarQ: So, will it have a default variable ?
07:34:59 <xinming> ValarQ: Just a bit like $_ in perl?
07:35:07 <shapr> You'd think Microsoft would be rich enough to purchase one copy of QuickCheck and hire some Haskell newb to use it on Windows.
07:35:15 <ValarQ> xinming: i have never used $_ in perl
07:35:25 <jlouis> shapr: yeah
07:35:33 <jlouis> SamB: got it.
07:35:35 <ValarQ> xinming: but no, there is no default variable anywhere
07:35:42 <xerox> marcot: look what I did for cairo_get_current_point, which returns the x/y coordinates as out parameters:
07:35:47 <xerox> {#fun get_current_point as getCurrentPoint { unCairo `Cairo', alloca- `Double' peekFloatConv*, alloca- `Double' peekFloatConv* } -> `()'#}
07:36:02 <xinming> ValarQ: hmm, Ok, I think I understand, for one argument, It can be omited.
07:36:10 <ValarQ> xinming: http://haskell.org/hawiki/PointFreeStyle
07:36:18 <xinming> ValarQ: thanks
07:36:32 <marcot> xerox: xerox my problem is more in inmarsh.
07:36:59 <marcot> xerox: I would like to have in inmarsh a function like polygonToCPolygon :: Polygon -> CPolygon
07:37:06 <marcot> alloca have much more than just this.
07:37:22 <xerox> marcot: 'alloca-' is the inmarshaller here.  It does translate to 'alloca $ \ptr -> ffiCall >>= \res -> do .. return (peekFloatConv ptr)'
07:37:39 <xerox> Ah, uhm.
07:37:50 <xerox> How is CPolygon defined?
07:42:52 <marcot> xerox: Ptr ()
07:43:08 <marcot> xerox: and Polygon is [(Boolean, VertexList)]
07:45:59 <marcot> But this is just a detail. The mais problem is that I can't create a struct without having a C function that does it. Is it possible to do it only in haskell?
07:46:29 <xerox> Yep, write a Storable instance
07:46:49 <marcot> xerox: hum.. I'll try it.
07:46:56 <xerox> I gotta run now, sorry :-|  Maybe check Gtk2Hs sources for examples.  Maybe Matrix.chs in the Cairo bindings.
07:47:55 <marcot> xerox: ok, thanks.
07:49:51 <jlouis> ok, i'll run
07:50:05 <jlouis> see you tomorrow with more patches in Conjure
07:57:20 <SamB> @localtime jlouis
07:57:21 <lambdabot> Local time for jlouis is Wed Nov  9 16:56:58 2005
07:57:56 * boegel leaves for home
07:58:02 <boegel> bye everyone !
08:01:14 <basti_> @seen nopcode
08:01:14 <lambdabot> I haven't seen nopcode.
08:07:26 <shapr> dons: Why does Reader automatically work in @eval, but not in ghci?
08:07:30 <SamB> is there a decent HTML parser for Haskell?
08:07:35 <shapr> HaXml
08:08:49 <SamB> shapr: @eval has things automatically imported and stuff
08:09:07 <shapr> Strange.
08:09:26 <SamB> shapr: what module?
08:24:27 * joelr waves
08:24:44 <shapr> hiya
08:24:45 <de1337> @eval help
08:24:46 <lambdabot>  Not in scope: `help'
08:24:50 <shapr> @help eval
08:24:51 <lambdabot>  @eval <expr>
08:24:51 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
08:25:02 * SamB wonders why he has no ghost
08:25:10 <joelr> ghc cannot physically compile my code :(
08:25:19 <joelr> i just posted to haskell-cafe about it
08:25:19 <shapr> joelr: Just that datatype?
08:25:28 <shapr> As in, only that datatype in one file?
08:25:32 <joelr> no
08:26:24 <joelr> i have about 100 HList data types in a module that's including two other modules with about 250 non-HList data types
08:26:24 <earthy> hlist tends to kinda explod4
08:26:24 <earthy> explode, even
08:26:24 <shapr> Have you tried to cut the module in half to see if that works?
08:26:24 <joelr> i cannot compile the HList module even if I liave just 4 data types in it
08:26:31 <shapr> Ok, does it work with one?
08:26:38 <joelr> shapr: no idea :) let me try
08:27:06 <dcoutts_> JaffaCake, I was talking to SyntaxNinja about support for GHC's -split-objs in Cabal
08:27:11 <joelr> what am i, a f,..g power user?!
08:27:20 <JaffaCake> dcoutts_: oh yes?
08:27:22 <dcoutts_> JaffaCake, of course Cabal uses ghc --make at the moment
08:27:36 <JaffaCake> hmm, we should really have -split-objs support in --make
08:27:45 <JaffaCake> it's been on my todo list for a while
08:28:00 <joelr> shapr: cannot compile even one!
08:28:00 <shapr> joelr: If you're using HList, yes.
08:28:04 <dcoutts_> JaffaCake, yeah I was thinking about it, because I just implemented support for -split-objs in Gtk2Hs. The Gtk2Hs hello world prog is now 90% smaller :-)
08:28:13 <shapr> joelr: That seems suspicious. Have you tried it on another arch?
08:28:15 <JaffaCake> cool!
08:28:44 <dcoutts_> JaffaCake, right so ghc supporint --make -split-objs would be good for Cabal. Though eventually Cabal might use something other than --make.
08:28:47 <joelr> shapr: let go try to bring down my windows machine :) it has 1/4 of the memory of my powerbook
08:28:56 <SamB> how do I build something in-place with Cabal?
08:29:05 <SamB> and register, that is?
08:29:09 <JaffaCake> yes, and eventually we'll use shared libs anyway
08:29:36 <dcoutts_> JaffaCake, yes the Gtk2Hs hello world prog is now only 30% bigger than this prog:  main = print "Hello World!"
08:29:58 <shapr> SamB: Why newtype/data for PiecePicker?
08:30:14 <SamB> shapr: I didn't do PiecePicker
08:30:20 <dcoutts_> JaffaCake, right, shared libs would be best (bar issues to do with runtime linker search paths :-) )
08:30:26 <SamB> or are you talking about that patch I unpulled?
08:30:49 <shapr> Oh, hm.
08:30:54 <shapr> Maybe so. I'm using your repo.
08:31:04 <JaffaCake> dcoutts_: yes, true
08:31:26 <SamB> well, you can go ahead and unpull it too
08:31:29 <araujo> Hello!
08:31:37 <shapr> Which patch is it?
08:31:40 <shapr> hiya araujo
08:31:50 <araujo> Hi hi shapr
08:31:55 <araujo> How you doing?
08:32:04 <basti_> I have reached a better knowledge over my system than autoconf has. This is scary.
08:32:10 <basti_> ^^
08:32:19 <shapr> I'm okay, how are you?
08:32:22 <SamB> shapr: you could do a dry push to my repo to find it
08:32:26 <shapr> SamB: ok
08:32:30 <ProfTeggy> Hi all.
08:32:37 <araujo> Veryy well, just got back from univ. :-]
08:32:55 <shapr> SamB: aha, smooth
08:32:59 <dcoutts_> JaffaCake, btw if you have a sec the link to the Gtk2Hs docs on the haddock page (http://haskell.org/haddock/#Examples) would remain up to date if you linked it to http://haskell.org/gtk2hs/docs/current/ rather than http://haskell.org/gtk2hs/docs/gtk2hs-docs-0.x.y/
08:33:21 <JaffaCake> ok, will do
08:33:26 <dcoutts_> ta muchly
08:33:54 <joelr> @google OOHaskell_cabal
08:33:56 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/haskell/
08:35:40 <shapr> SamB: Oh, I found the problem with MiniHTTP.hs, it assumes that the tracker will be alive.
08:36:20 <SamB> uh huh, I thought it was something like that
08:40:21 <dcoutts_> JaffaCake, SyntaxNinja and I were also trying to remember what the issue with deps and Haskell modules is. If it's more complex than the deps just being on imported modules or if there are indirect deps too. This affects how we can cache deps to make rebuilding fast when there is nothing to be done.
08:40:59 <dcoutts_> JaffaCake, so ghc --make chases imports afresh each time (and reads all the .hi files too?)
08:41:16 <JaffaCake> yes
08:41:52 <dcoutts_> but longer term it'd be nicer if Cabal could be more like make which can figure out there's nothing to rebuild very quickly (so long as you're not using recursive make)
08:41:57 <JaffaCake> in what context is this?  rebuilding in Cabal?
08:42:02 <dcoutts_> yes
08:42:47 * JaffaCake thinks
08:42:49 <dcoutts_> eg, in the current Gtk2Hs build system , running "make" is a build tree takes 0.3 sec to figure out that there is nothing to do.
08:42:57 <dcoutts_> it just stats 250+ files
08:43:18 <dcoutts_> and that's really good. currently using ghc --make is much slower.
08:43:20 <JaffaCake> right, in theory ghc --make could do that too
08:43:42 <JaffaCake> i.e. have a special case for "nothing to do"
08:44:13 <ulfdoz> why doesn't --make adopt the approach?
08:44:14 <dcoutts_> is it a special case?
08:44:48 <dcoutts_> JaffaCake, of course the difference with using make (and ghc -M) is that the deps themselves are cached
08:44:59 <JaffaCake> well yes... if there's anything to do, then GHC has to read all the interface files up to the point where compilation is required (that's what all the "skipping" stuff is about)
08:45:15 <joelr> shapr: on Windows I can compile the module with 1 HList type but the other one gives me a heap exhausted message
08:45:26 <JaffaCake> oh, and we re-caculate the deps each time, that's true
08:45:58 <JaffaCake> caching deps in --make is something I've wondered about before
08:46:13 <dcoutts_> I imagine that the "skipping" and the corresponding reading of files would not need to be done if the deps were cached
08:46:40 <JaffaCake> yes, if the deps were cached, then we can stat all the source files, and determine very quickly whether there's anything to do
08:46:50 <dcoutts_> but of course one needs to know the timestamps of the deps so that the deps themselves can be recaclulated if necessary
08:47:27 <JaffaCake> yes, and you probably have to cache deps per source file.. ghc doesn't know which file you're giong to ask it to compile next
08:48:14 <dcoutts_> does that mean the deps for each file need to be in their own file?
08:48:22 <JaffaCake> hmm, maybe not
08:48:23 <Igloo> Reminds me of something I keep wishing we had - having -M put the module list into the Makefile somehow so I can link the module without having to list the modules used myself
08:49:05 <dcoutts_> it'd be nicer (and more effecient) if the deps could be kept in one file (as a list of files with their timestamps)
08:49:29 <JaffaCake> dcoutts_: ghc could generate a dep cache file listing each source file with its timestamp, and its deps
08:49:32 <JaffaCake> yes
08:49:32 <dcoutts_> cabal could do that more easily than ghc perhaps because it knows what targets it's going to build
08:50:18 <dcoutts_> JaffaCake, or perhaps the deps cache could go in the .hi file?
08:50:38 <JaffaCake> the cache becomes invalid if you shadow a source file by putting another one earlier in the search path... maybe we don't care about that
08:50:51 <dcoutts_> then just read a little bit of each .hi file to find the deps
08:51:02 * dcoutts_ tries to understand the shadowing problem
08:51:44 <JaffaCake> the .hi file already has the deps in it, actually
08:51:47 <dcoutts_> JaffaCake, is that detectable? (at the cost of stating a few more files)
08:52:16 <Igloo> You can store "Module Path Time" and check you find the same path for the module
08:52:42 <JaffaCake> yes, you have to do the search for each module and make sure you come up with the same answer
08:52:48 <dcoutts_> JaffaCake, right
08:52:49 <Igloo> Actually, Module isn't necessary, you just find the file yourself and then try to find it in th elist
08:53:13 <JaffaCake> the search path better be the same each time, too
08:53:47 <dcoutts_> JaffaCake, the search path could be saved in the deps cache and used as a validity check
08:54:16 <JaffaCake> dcoutts_: can you measure how long ghc --make takes to calculate the deps in gtk2hs?  i.e. how long before the first "skipping" message
08:55:02 <dcoutts_> JaffaCake, I can try. I don't ususly build with ghc --make
08:55:12 <JaffaCake> ah yes, sorry
08:55:16 * dcoutts_ tries
08:55:42 <dcoutts_> ordinary: time make: 0.16 sec
08:55:59 <dcoutts_> (the time is less when not configured to build html docs)
08:57:25 <JaffaCake> GHCi does something a bit like this... when you :r in GHCi and there's nothing to do, it's instantaneous
08:58:32 <dcoutts_> with ghc --make: 1.352s
08:58:42 <dcoutts_> which is much better than I recall
08:58:57 <dcoutts_> that's only the gtk package
08:58:59 <JaffaCake> that's not bad - is that just up to the first skipping?
08:59:19 <dcoutts_> that's everything in the case that there is no files changed
08:59:25 <dcoutts_> and no linking step
08:59:28 <JaffaCake> right
08:59:39 <dcoutts_> which is pretty good actually
08:59:48 <dcoutts_> I remember it being much slower
08:59:57 <JaffaCake> maybe we improved something
09:00:01 * JaffaCake shrugs
09:00:23 <JaffaCake> I've got to go... let's continue this tomorrow
09:00:42 <JaffaCake> oh, do you have -O on, BTW?
09:01:01 <JaffaCake> it'll be slower with -O, because the .hi files are larger
09:02:16 <dcoutts_> that was without -O
09:02:35 <dcoutts_> make stat's 859 files, ghc --make stats 4128 files
09:02:44 <JaffaCake> wow
09:03:13 <dcoutts_> make opens 243 files, ghc --make opens 766 files
09:03:48 <JaffaCake> yes, but ghc is opening the .hi files for the libraries too
09:04:03 <dcoutts_> and make is actaully checking slightly more here because it's also checking the other 5 gtk2hs packages
09:04:07 <JaffaCake> it'd be easy for ghc to just proceed straight to the link if all the source files were unchanged
09:04:34 <JaffaCake> quick 30 min hack, I might try it tomorrow
09:04:40 <dcoutts_> ok
09:04:48 <dcoutts_> anyway, generally it's much better that I had remembered
09:04:51 <JaffaCake> caching deps is a bit harder
09:04:58 <dcoutts_> right
09:05:08 <JaffaCake> I'll be interested in what happens when you turn on -O
09:05:14 <JaffaCake> anyway, bye!
09:05:19 <dcoutts_> ok I'll try and reprty back
09:05:20 <dcoutts_> bye!
09:09:51 <joelr> any adventurous souls willing to see their GHC run out of memory when compiling?
09:10:15 * joelr has yet another power-issue on tap :D
09:11:23 <gour> dcoutts_: i just discovered http://www.cse.unsw.edu.au/~chak/haskell/gnome/
09:11:41 <joelr> help!
09:12:20 <ValarQ> gour: "last modified 2000" :/
09:12:55 <gour> ValarQ: well, i don't mind, what is important is original idea :-)
09:14:48 <ValarQ> gour: if you say so
09:15:18 <gour> ValarQ: well, i'm just thinking loud
09:17:09 * SamB is glad he tried parsing this html file with nsgmls before accusing HaXml's html parser of being incomplete
09:18:57 <joelr> SamB: wanna try my exploding code?
09:20:03 <SamB> joelr: sure
09:20:14 <joelr> http://wagerlabs.com/Foo.hs
09:20:32 <joelr> OOHaskell is at @google OOHaskell_cabal
09:20:47 <SamB> @google OOHaskell_cabal
09:20:48 <joelr> @google OOHaskell_cabal
09:20:48 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/haskell/
09:20:49 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/haskell/
09:23:50 <shapr> roconnor: Do you mind if I exploit your QuickCheck hawiki page for my next software testing TMR article?
09:24:12 <joelr> shapr: wanna test my exploding code?
09:24:39 <joelr> shapr: will you rise to the challenge?
09:24:45 * shapr is unleavened
09:25:10 <joelr> http://wagerlabs.com/Foo.hs makes ghc explode
09:26:12 <dcoutts> gour, as far as I know it's a dead project
09:26:38 <gour> dcoutts: yes, it looks so, or it needs revival ;)
09:26:53 <dcoutts> gour, you mean the bonobo bindings?
09:27:13 <gour> dcoutts: besides gnome-db stuff, what libs do you consider for gtk2hs project?
09:27:43 <dcoutts> gour, dbus perhaps, the new stuff that will end up in Gtk+ due to Project Ridley
09:29:12 <gour> dcoutts: how different would be  gtk programming from gnome (i mean in haskell) ?
09:30:30 <dcoutts> gour, not much different I guess. The gnome libs are less used to be honnest. Much of libgnome/libgnomeui is deprecated.
09:30:53 <dcoutts> the non-gtk parts of the platform are much less well documented and maintained
09:31:32 <dcoutts> which is the issue that project Ridley is aiming to tackle: http://live.gnome.org/ProjectRidley
09:32:40 <gour> how is one supposed to get some gnome-features like gnome-vfs etc. then?
09:33:37 <gour> sowhat, there will be more work for gtk2hs bindings
09:34:17 <gour> s/sowhat/so/
09:35:29 <shapr> joelr: It ran up to using 500mb of ram and I killed it.
09:35:37 <joelr> yup
09:35:55 <dcoutts> gour, gnome-vfs is one that might be worth adding
09:35:56 <joelr> enable -fglasgow-exts and comment out the [TableInfo] line
09:36:32 <gour> dcoutts: i also think so..
09:37:34 <joelr> shapr: did you see the magic effect?
09:38:45 <shapr> joelr: what the heck is that?
09:38:54 <joelr> what do you mean?
09:39:13 <joelr> shapr: magic = ghc not exploding when you do -fglasgow-exts and comment out the first line
09:39:26 <shapr> Yeah, but why? Is it the deriving?
09:39:42 <vegai> isn't -fglasgow-exts rather evil? Why is everyone using it?
09:40:08 <shapr> Because most projects require it nowadays.
09:40:13 <shapr> -fglasgow-exts does all sorts of cool stuff.
09:40:28 <vegai> is it that without it things would be a bit more complicated or downright impossible?
09:40:29 <joelr> shapr: i removed all the Typeables and removed -fglasgow-exts, it blows up if the first line is uncommented
09:40:42 <joelr> vegai: it just makes your life easier
09:40:46 <joelr> much easier
09:40:53 <shapr> joelr: Not if you comment out the deriving bit.
09:40:57 <vegai> ghc is the only implementation that supports those, I assume
09:41:26 <joelr> shapr: so if you stop if from deriving then it compiles?
09:41:30 <Igloo> vegai: hugs supports some of them
09:41:32 <vegai> it feels to me a bit like using GNU extensions in C code
09:41:33 <joelr> shapr: but i need the show :(
09:41:35 <shapr> Well, it complains about there being no main
09:41:36 <gour> dcoutts: taking into consideration that most of gnome-stuff works on mac, less on win32, and, of course, everything on linux, i'm just wondering whether gtk2hs project should be more oriented to provide just a bindings for gtk toolkit (e.g. win32 platform), or to provide a (more) complete (multi-platform) framework (like wxwidgets) ?
09:41:39 <shapr> joelr: Make your own instance.
09:41:53 <joelr> shapr: i'll go nuts doing that for every type
09:42:12 <shapr> Yeah, but see if that fixes the problem.
09:42:16 <ibid> vegai: there's talk of standardizing some of them
09:42:30 <shapr> joelr: Plus, I only commented out the first deriving.
09:42:44 <joelr> shapr: that's neat
09:42:47 <joelr> shapr: let me see
09:42:48 <eivuokko> And some stuff is just plain easier/more beautiful with ghc extensions
09:43:28 <joelr> shapr: are you using extensions?
09:43:45 <shapr> Yes, I'm using -fglasgow-exts
09:43:51 <joelr> shapr: cause i'm not. i have all the typeables commented out and the first derive show commented out. the code does not compile
09:44:27 <joelr> shapr: enabling extensions does make it compile. sheer wierdness but clearly something to do with deriving show for that table list
09:44:37 <joelr> shapr: let me see if doing it by hand works
09:44:42 <SyntaxNinja> 'morning
09:44:54 <shapr> joelr: Are you using -O2 ?
09:44:58 <shapr> hiya SyntaxNinja
09:45:10 <joelr> shapr: nope, just ghc --make -fglasgow-exts
09:45:11 <joelr> or no exts
09:45:23 <joelr> without exts it blows up
09:45:40 <shapr> I'm using "ghc --make -O2 -fglasgow-exts Foo" and I added "module Main where" and main = putStrLn "foo"
09:45:47 <shapr> and I have newtype Tables = Tables [TableInfo] --deriving (Show, Typeable)
09:45:52 <joelr> shapr: yes, i did that too
09:46:00 <shapr> And it builds fine.
09:47:03 <shapr> ghc --make -O2 -fglasgow-exts Foo  15.46s user 0.42s system 99% cpu 16.030 total
09:47:44 <joelr> shapr: instance Show Tables where
09:47:44 <joelr>     show (Tables (x:xs)) = show' x ++ show' xs
09:47:44 <joelr>         where show' [] = ""
09:47:44 <joelr>               show' (x:xs) = show' x ++ show xs
09:47:54 <joelr> exploding again
09:48:17 <joelr> i don't think -O2 is necessary to make it compile, btw
09:48:31 <shapr> Is type TableInfo automatically an instance of Show?
09:48:47 <joelr> shapr: well, all the elements are
09:50:32 <shapr> I think it's not.
09:51:06 <joelr> how so?
09:51:08 <shapr> Because I get the same huge memory use problem from "> show (TourType TourNone :: TableInfo)"
09:51:13 <joelr> all the types are in the file
09:51:28 * shapr shrugs
09:51:45 <joelr> hmm
09:51:57 <shapr> I don't know anything about OOHaskell, but I think the problem has something to do with Show on TableInfo
09:52:16 <shapr> type is just an alias, isn't it?
09:52:30 <joelr> shapr: clearly :) i think i'll go and manually remove Show derivations one by one to see which one it chokes on
09:53:04 <joelr> shapr: bet type and tour type are likely culprits
09:53:27 <joelr> hmm
09:53:27 <shapr> Why would it choke on those?
09:53:29 <joelr> actually
09:53:38 <joelr> then i cannot derive TableInfo
09:53:47 <joelr> shapr: didn't  you just say it choked on TourType?
09:54:37 <shapr> Nah, I said it choked on show of TableType
09:54:48 <shapr> "> show (TourType TourNone :: TableInfo)"
09:54:50 <shapr> er, TableInfo
09:55:09 <joelr> ok
09:56:15 <shapr> Does OOHaskell automatically derive Show for you?
09:56:28 <joelr> shapr: it's the same haskell :D
09:56:45 <shapr> Then, shouldn't you put deriving (Show) at the end?
09:56:48 <joelr> shapr: i'm just using the HList part anyway
09:57:00 <joelr> shapr: which line are you talking about?
09:57:07 <joelr> i thought i have show at ehe end everywhere
09:57:15 <shapr> It's not at the end of TableInfo
09:57:22 <dcoutts> @seen xerox
09:57:22 <lambdabot> I saw xerox leaving #haskell.it, #haskell-overflow, #haskell-blah and #
09:57:22 <lambdabot> haskell 47 minutes and 35 seconds ago.
09:57:45 <joelr> shapr: hmm... i thought ghc barfs when you do that so i did not do it. since type is an alias
09:57:59 <shapr> Oh, I see what you mean.
09:58:04 <joelr> Foo.hs:36:4: parse error on input `deriving'
09:58:47 <shapr> Ok, so, if TableInfo can't be show, then GHC can't derive a Show instance for the Tables type.
09:58:55 <shapr> That's the problem.
09:58:59 <joelr> shapr: nope
09:59:02 <shapr> huh?
09:59:06 <joelr> all the types in TableInfo can be shown, see below
09:59:24 <shapr> But they're not in the Tables type directly.
09:59:29 <joelr> so tableinfo should be shown too
09:59:36 <joelr> shapr: hmm...
09:59:38 <shapr> But it isn't, I just tried that.
09:59:47 <joelr> shapr: what did you try?
09:59:59 <shapr> "> show (TourType TourNone :: TableInfo)"
10:00:01 <shapr> Look at the type!
10:00:18 <shapr> It's not :: TourType, but instead :: TableInfo
10:00:23 <joelr> shapr: but TourType TourNone is not TableInfo
10:00:48 <shapr> Sure looks like it to me. What do these :*: things do?
10:01:00 <joelr> shapr: they make a list of cons cells
10:01:11 <shapr> How do you construct a value of :: TableInfo then?
10:01:26 <shapr> And, why does GHCi eat all my ram when I try to do that show statement above?
10:01:50 <shapr> I suspect that your problem is the reason that GHCi eats all my memory when I try that show function call.
10:02:06 <joelr> HCons AvgPot (HCons NumPlayers (HCons ...
10:02:31 <joelr> problem? do i have a problem :D
10:04:07 <joelr_> shapr: whanna see something fun?
10:04:34 <joelr_> shapr: i placed that code in module Foo. try loading that into ghci and browsing the module
10:04:56 <joelr_> you will see what TableInfo is
10:05:37 <shapr> Which code?
10:05:43 <joelr_> shapr: that same code
10:05:50 <joelr_> browse your module after loading it into ghci
10:06:02 <shapr> Uh oh, I can see Cthulhu in my near future.
10:06:11 <joelr_> shapr: what?
10:06:36 <joelr_> i don't see now Cthulhu, i see a data type scrolling across my screen a couple of times at least
10:06:50 <shapr> Like I said, that's a coupla SAN points down the drain.
10:07:09 <joelr_> shapr: what are SAN points? what are you talking about?
10:07:15 <shapr> Have you ever played the role playing game "Call of Cthulhu" ?
10:07:26 <joelr_> shapr: never
10:07:33 <joelr_> and SAN is storage area network in my book :)
10:07:47 <shapr> Your characters run around in HP Lovecraft's world trying to kick the Elder Gods out of this dimension.
10:08:08 <joelr_> hmm
10:08:09 <shapr> The downside is that exposure to anything of the Elder Gods makes you cumulatively insane.
10:08:29 <joelr_> shapr: haskell has infected my brain?!
10:08:52 <shapr> So your character starts with a certain number of SAN points, and they're lost bit by bit when you encounter truly alien evil.
10:09:09 <joelr_> hahaha
10:09:13 <shapr> Anyway, I often say that J2EE removes SAN points, and Haskell gives them back.
10:09:27 <joelr_> ah
10:09:33 <joelr_> i see what you do for a living now
10:09:45 <shapr> I quit doing J2EE, I do Plone nowadays.
10:09:52 <joelr_> ok
10:09:55 <shapr> Lucky me.
10:10:00 <joelr_> then i must be doing truly evil haskell
10:10:07 <joelr_> for a living
10:10:09 <shapr> Anyway, HList instances look pretty weird.
10:10:46 * dcoutts thinks HLists are evil
10:10:59 <shapr> How do you construct a value of type TableInfo?
10:11:03 <joelr_> dcoutts: try my code
10:11:15 <joelr_> shapr: using ... where was that
10:11:19 <joelr_> one sec
10:11:25 <joelr_> @google HList
10:11:26 <lambdabot> http://homepages.cwi.nl/~ralf/HList/
10:11:55 <joelr_> shapr: use .*.
10:11:56 <SamB> shapr: HaXml is inexplicably refusing to parse not-quite valid HTML, giving an error before it even reaches anything invalid...
10:12:57 <joelr_> shapr: try a simpler type lik type Foo = TourType :*: AvgPot :*: HNil
10:13:17 <joelr_> then you can construct it with TourNone .*. 100
10:13:59 <SamB> joelr_: what exactly does your program do?
10:14:35 <joelr_> SamB: packet parsing and unparsing. and creating, modifying, etc.
10:15:49 <joelr_> type Foo = (:*:) TourType ((:*:) AvgPot HNil)
10:17:43 <SamB> and it explodes how?
10:17:55 <joelr_> SamB: try it
10:18:08 <joelr_> seeing is believing
10:18:12 <SamB> too much memory?
10:18:28 <joelr_> shapr: foo = HCons (TourType TourNone)
10:18:28 <joelr_>       (HCons (AvgPot 100) HNil)
10:19:57 <SamB> ghci or ghc both eat all my memory trying to compile it...
10:20:08 <joelr_> exactly
10:20:12 <joelr_> all the memory
10:20:15 <SamB> granted, I don't have a lot to start with, but...
10:20:30 <shapr> Maybe the problem is that GHC only handles tuples up to a certain size?
10:20:39 <SamB> and I'm not counting virtual, that takes too long and makes everything too slow
10:20:41 <shapr> Or maybe GHC only derives up to certain size tuples?
10:21:16 <joelr_> hmm
10:22:49 * SamB tries splitting everything but Tables and TableInfo out
10:25:05 <shapr> joelr_: I can't get .*. to work in GHCi
10:25:20 <shapr> I'm using "type TestHlist = TourType :*: AvgPot :*: HNil"
10:25:24 <joelr_> shapr: no, you need to use HCons, i was wrong
10:25:33 <joelr_> foo = HCons (TourType TourNone)
10:25:33 <joelr_>       (HCons (AvgPot 100) HNil)
10:28:00 <SamB> if you take out the Show from the deriving for Tables, it works
10:29:42 <joelr_> Samb: I know but that does not help me
10:29:55 <joelr_> I mean, I would like to see the contents
10:30:04 <joelr_> it helps when debugging. helps immensely.
10:30:33 <SamB> joelr_: have you tried doing it manually?
10:30:52 <shapr> joelr_: This compiles : type TestHlist = TourType :*: AvgPot :*: HNil  ; newtype TestShow = Whatever TestHlist deriving Show
10:31:06 <joelr_> SamB: it's not clear what exactly is causing this but i'll try doing a show for an HCons .. of arbitrary length
10:31:13 <shapr> But it takes - ghc --make -O2 -fglasgow-exts Foo  15.86s user 0.43s system 98% cpu 16.471 total
10:31:40 <shapr> At this point I'd guess you're running into some large complexity issue with deriving Show on tuples.
10:31:40 <joelr_> shapr: that's not bad, right?
10:31:54 <shapr> Lemme try it with the next size up.
10:44:24 <SamB> somebody should try doing this with a profiling build of GHC to see what part of the compiler is the problem...
10:44:38 <shapr> joelr_: I think it will build these instances, I just think it's going to take a long time.
10:44:46 <joelr_> SamB: i hope Simon Marlow does that
10:44:47 <SamB> I'm beiginning to suspect the typechecker
10:44:53 <shapr> As I make my HList test type larger and larger, the build time increases.
10:44:58 <joelr_> shapr: let me check on something
10:45:14 <shapr> I have sixteen right now, type TestHlist = TourType :*: AvgPot :*: BetType :*: GameType :*: NumPlayers :*: Waiting :*: PlayersFlop :*: TableName :*: GameType :*: InfoMaxPlayers :*: RealMoneyTable :*: LowBet :*: HighBet :*: MinStartMoney :*: MaxStartMoney :*: GamesPerHour :*: HNil
10:45:21 <shapr> At seventeen it starts to swap a lot.
10:45:47 * shapr has an idea.
10:45:51 <SamB> you see, I've written out the Show instance and it still seems to do that
10:45:58 <basti_> beware. shapr has an idea.
10:46:03 <SamB> instance Show Tables where
10:46:03 <SamB>     showsPrec d (Tables xs) = showParen (d > app_prec) showStr
10:46:03 <SamB>         where showStr = showString "Tables " . showsPrec (app_prec+1) xs
10:46:22 <joelr_> check out Record.hs in the HList code
10:46:24 <SamB> how do you build a profiling build anyway?
10:46:26 <joelr_> they have ShowComponents
10:47:05 <joelr_> so i think it's just a matter of making types instance of that
10:48:04 <shapr> haha, I got it work :-)
10:48:16 <joelr_> shapr: really? what did you do?
10:48:36 <SamB> still, shouldn't the typechecker not have such bad complexity?
10:48:48 <shapr> I cut it into two HLists of length fifteen, and put each of those as the two pieces of another HList. Then I can derive Show on the UberList just fine.
10:49:31 <shapr> I was right, it is a tuple length problem, so I cut it into two tuples of fifteen that are parts of a two tuple.
10:49:39 <shapr> joelr_: Want to see the code?
10:49:50 <joelr_> hang on
10:49:53 <joelr_> i wanna try something
10:57:46 <joelr_> i think it needs a showComponents declaration
11:00:28 <joelr_> i thought this would help
11:00:28 <joelr_> instance (Show v, ShowComponents r) => ShowComponents (HCons v r) where
11:00:29 <joelr_>     showComponents comma (HCons v r)
11:00:29 <joelr_>         =  comma ++ show v ++ showComponents "," r
11:00:45 <joelr_> hmm... i need to replace that with a Show i think
11:04:22 <shapr> joelr_: Anyway, I got it to work, so I'm happy.
11:04:35 <joelr_> shapr: but you split it ;)
11:04:41 <joelr_> that's cheating!
11:04:43 <joelr_> or not/
11:04:46 <joelr_> can you paste the code?
11:05:17 <shapr> sure
11:06:23 <shapr> @paste check it out
11:06:24 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:06:54 <shapr> joelr_: You just want it to work, yes?
11:07:00 <joelr_> oh, cool
11:07:04 <joelr_> thanks shapr
11:07:16 <joelr_> shapr: that works just the same i think
11:07:19 <joelr_> let me try it
11:07:31 <shapr> So I think that everything will build fine if your HList isn't more than a fifteen tuple.
11:08:18 <shapr> You can probably decrease your build time and build memory requirement by keeping the tuples a bit smaller.
11:08:44 <joelr_> so long as it does not affect runtime i'm fine
11:08:52 <shapr> I dunno about that.
11:09:00 <joelr_> i'm about to find out
11:09:30 <joelr_> shapr: here's another idea
11:09:35 <joelr_> Record.hs
11:09:41 <joelr_> see how they build show for record?
11:09:49 <joelr_> can the same be done for any HCons v r?
11:10:31 <shapr> I don't know, have you tried it?
11:10:46 <joelr_> not yet
11:10:53 <joelr_> no, wait
11:10:55 <joelr_> i tried and failed
11:11:00 <joelr_> could not figure it out
11:13:42 <palomer> I'm a discriminating hacker, what's my language of choice?
11:13:59 <CosmicRay> palomer: we hope it would be haskell ;-)
11:14:11 <CosmicRay> welcome to #haskell, btw.
11:15:22 <palomer> righto!
11:15:32 <palomer> man, I gotta start learning this language one of these days
11:15:41 <CosmicRay> palomer: well, let us help you start.
11:15:52 <CosmicRay> how about a brief 3-page whet your appetite sort of article?
11:16:15 <CosmicRay> http://www.freesoftwaremagazine.com/free_issues/issue_05/haskell/
11:16:22 <CosmicRay> then, when you're ready to start, pick this one up:
11:16:31 <CosmicRay> http://www.isi.edu/%7Ehdaume/htut/
11:17:11 <CosmicRay> also, feel free to ask any questions here.
11:17:13 <integral> I can't seem find a standard function in the hierarchical libraries for: (f ??? g) (x,y) = (f x, g y).  Is there one?
11:20:15 <integral> hmm, I guess this would have type: (???) :: (a -> b) -> (c -> d) -> (a,c) -> (b,d) ?
11:20:26 <integral> @hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,d)
11:20:27 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) ->
11:20:27 <lambdabot> (b, d)
11:20:38 <integral> o_O :-/
11:21:40 <palomer> CosmicRay: is that the best haskell tutorial?
11:21:48 <CosmicRay> palomer: the best free one, yes.
11:21:58 <CosmicRay> palomer: there are better ones, but they are printed on dead trees and cost real money ;-)
11:22:10 <CosmicRay> YAHT is quite decent itself though
11:22:18 <CosmicRay> (YAHT is that htut link)
11:27:13 * joelr_ hifives shapr
11:27:23 <joelr_> gotta go hook this up to serialization now
11:40:34 <palomer> it says here that foldr can work on infinite lists
11:40:47 <palomer> how does that work?
11:41:59 <integral> lazily...
11:42:02 <yaarg> tail recursion
11:42:12 <palomer> but it will never return anything!
11:42:30 <palomer> give me an example where we might want to do this(and where it works)
11:43:32 <palomer> foldr is tail recursive?
11:44:32 <palomer> and when I type square x = x*x in hugs(as in the tutorial), I get the following: ERROR - Syntax error in input (unexpected `=')
11:44:34 <integral> @plugs foldr (\a b -> a) 1 [1..] -- note that b is never forced
11:44:34 <lambdabot>  parse error (possibly incorrect indentation)
11:45:03 <yaarg> no it's not
11:53:32 <astrolabe> palomer: I think you need to put definitions into a .hs file
11:53:51 <astrolabe> and then load them
11:53:53 <palomer> you can't bind in hugs?
11:54:03 <tomaszz> integral: how about (first f >>> second g) (x, y) ?
11:54:23 <tomaszz> integral: where >>> is a method from Control.Arrow.Arrow
11:54:45 <astrolabe> palomer: As far as I know, it isn't interactive in that way.
11:55:51 * CosmicRay returns
11:56:00 <CosmicRay> palomer: ok, let's try this....
11:56:17 <CosmicRay> Hugs.Base> take 5 [1..]
11:56:17 <CosmicRay> [1,2,3,4,5]
11:56:29 <CosmicRay> so basically, [1..] generates an infinite list of integers.
11:56:42 <CosmicRay> take can work on infinite lists because you are requesting a finite number of elements.
11:56:50 <CosmicRay> now consider:
11:58:10 <CosmicRay> erm.
11:58:11 <gzl> palomer: try let square x = x*x
11:58:18 <gzl> palomer: that works in GHCi
11:58:19 <CosmicRay> now I'm not seeing how this will work on infinite lists.  ;-)
11:59:28 <astrolabe> @eval foldr (:) [1..] ! 7
11:59:28 <lambdabot>  Not in scope: `!'
11:59:31 <astrolabe> boo
11:59:49 <tomaszz> @eval foldr (:) [1..] !! 7
11:59:49 <gzl> it's !!
11:59:49 <lambdabot>   Expecting a function type, but found `[a]'
11:59:49 <lambdabot>   Expected type: [a]
11:59:49 <lambdabot>   Inferred type: [a1] -> b
12:00:10 <tomaszz> @eval foldr (:) [] [1..] !! 7
12:00:10 <gzl> @eval foldr (:) [] [1..] !! 7
12:00:11 <lambdabot> 8
12:00:12 <lambdabot> 8
12:00:14 <gzl> there. :)
12:00:24 <tomaszz> :)
12:00:30 <gzl> if you do something like `foldr (+) 0 [1..]' it'll simply stack overflow
12:00:32 <CosmicRay> now wait a minute
12:00:44 <astrolabe> thank you.  You can see why I NEED static types.
12:00:54 <CosmicRay> how tightly does !! bind?
12:01:02 <CosmicRay> oh never mind
12:01:13 <CosmicRay> that would be the same as (foldr (:) [] [1..]) !! 7
12:01:29 <CosmicRay> palomer: ":" is the list-prepend operator (adds one element to the beginning of a list)
12:01:39 <CosmicRay> palomer: and !! is the list indexing operator (returns the element at that specific index)
12:01:50 <CosmicRay> palomer: "map" is an easier to understand function that handles infinite lists.
12:02:03 <CosmicRay> Hugs.Base> take 5 (map (+ 2) [1..])
12:02:04 <CosmicRay> [3,4,5,6,7]
12:02:06 <CosmicRay> as an example.
12:02:09 <tomaszz> CosmicRay: !! seems to have no fixity declaration (at least GHCi's :i doesn't show anything)
12:02:17 <tomaszz> CosmicRay: so it's probably 0
12:02:21 <integral> tomaszz: hmm, isn't that what (***) does?
12:02:28 <tomaszz> CosmicRay: the lowest priority
12:02:40 <CosmicRay> tomaszz: I figured it has to bind this way, because otherwise there would have been a type error in the call to foldr.
12:02:48 <tomaszz> integral: you are right! :-)
12:03:02 <CosmicRay> palomer: does any of this make sense?
12:03:10 <integral> @karma+ arrows
12:03:10 <lambdabot> arrows's karma raised to 1.
12:03:21 <astrolabe> ':' has precidence 5, and is right associative.
12:03:24 <CosmicRay> palomer: let me put it in concrete terms.
12:03:31 <CosmicRay> palomer: let's say you have a list of lines in a file.
12:03:40 <CosmicRay> palomer: this is not an infinite list, but could be pretty darn large.
12:03:46 <CosmicRay> palomer: haskell can read files lazily.
12:04:10 <CosmicRay> so functions like map and filter can easily be used to process huge amounts of data without storing it all in memory at once, or explicitly reading each line.
12:04:18 <astrolabe> '!!' has precidence 9 and is left associative
12:04:44 <tomaszz> astrolabe: strange, I wonder why ghci doesn't show it
12:04:49 <astrolabe> and 'precidence' is spelled 'precedence'
12:05:08 <CosmicRay> palomer: there is even a function (interact) designed to let you express your program as a function from String to String, representing a manipulation on the input to generate the output.
12:05:18 <astrolabe> tomaszz: hmm odd.  A bug?
12:05:22 <CosmicRay> palomer: very cool, and gets you right down to what a function really should be.
12:05:23 <integral> nevermind I really wanted &&&, oop :)
12:06:36 <paolino> good evenong
12:07:04 <paolino> I see the Ord class has many methods, which of them must be implemented ?
12:07:11 <tomaszz> astrolabe: a harmless one it seems
12:07:16 <SamB> paolino: the report tells all
12:07:45 <SamB> if you implement compare, you are covered
12:07:54 <tomaszz> @help karma
12:07:55 <lambdabot> return a person's karma value
12:08:43 <paolino> SamB, how does it work  to write a class with "overlapping" methods ?
12:09:04 <SamB> paolino: overlapping?
12:09:39 <paolino> I mean what does it mean implement compare and you are covered ?
12:09:54 <paolino> looks like I can choose
12:10:19 <SamB> well there are default methods such that if you implement compare all the others will work
12:10:43 <SamB> you could also just implement <=
12:11:01 <paolino> default methods ?
12:11:22 <paolino> what they are ?
12:11:37 <SamB> you write a definition in the class along with the type signature
12:11:47 <paolino> right
12:12:18 <SamB> which means that instances that don't define that method will get the default implementation
12:13:10 <paolino> ah than the default compare and (<=) depends on each other ?
12:14:16 <SamB> yeah
12:14:40 <paolino> so which ever I write the other default become useful
12:14:52 <SamB> yes
12:15:03 <astrolabe> I think if you implement <=, you'll need == too.
12:15:05 <paolino> a piece of magic :)
12:15:05 <SamB> otherwise they would just loop
12:15:13 <SamB> astrolabe: you need that anyways
12:15:19 <SamB> astrolabe: that is in Eq
12:15:25 <astrolabe> samB: doh. yes.
12:15:41 <paolino> compare depends on (<=) and (==)
12:15:44 <SamB> of course, you could implement it in terms of compare
12:17:09 <palomer> hrm
12:17:17 <palomer> I still don't see how foldr could be useful on infinite lists
12:17:32 <paolino> so methods (function defined inside a class) are overridable that's the main reason to define them there ?
12:24:12 <shapr> palomer: What about scanr being useful?
12:29:12 <palomer> shapr: I'm not there yet
12:30:20 <astrolabe> @eval foldr (++) [] (map show [1..]) 4321
12:30:21 <lambdabot> Couldn't match `[a]' against `t -> t1'
12:30:40 <astrolabe> @eval foldr (++) [] (map show [1..]) !! 4321
12:30:40 <lambdabot> '1'
12:31:15 <palomer> oh, righto
12:31:18 <palomer> I've been convinced
12:31:18 <astrolabe> @eval foldr (++) [] (map show [1..20])
12:31:19 <lambdabot> "1234567891011121314151617181920"
12:32:38 <palomer> can't we write a version of foldl which works on infinite lists?
12:35:47 <palomer> astrolabe: wait, I haven't been convinced! that was a finite list
12:36:02 <ctrlsoft> palomer: how would that ever work...? isn't the whole idea of foldl that you start with the last element?
12:37:34 <palomer> ctrlsoft: I raise the same objections with foldr: don't you need the last element to compute the value?
12:38:18 <ctrlsoft> palomer: uhm, right.. good point :-)
12:39:14 <gzl> with foldr you start with the last element of the list
12:39:17 <gzl> with foldl you start with the first one
12:40:06 <sieni> well, but scanl makes sense for infinite lists, but scanr doesnt
12:40:47 <palomer> gzl: which puzzles me, because infinite lists don't have a last element and yet you can call foldr on them
12:41:11 <palomer> gzl: are you sure you didn't mean "with foldr you start with the first element"?
12:41:29 <ctrlsoft> palomer: actually, no you don't need a finite list with foldl
12:41:46 <ctrlsoft> just as long as you make sure your function doesn't use the list elements
12:42:42 <palomer> you can call foldl on infinite lists?
12:42:59 <goron> ctrlsoft: What a nice theoretical comment!
12:43:26 <gzl> palomer: yeah. with foldr you start with the last element.
12:43:28 <ctrlsoft> palomer: just as long as you don't use the list.. so I guess it doesn't make much sense ;-)
12:43:54 <ctrlsoft> goron: Sorry, I guess was being a bit pedantic :-)
12:43:56 <astrolabe> palomer, it wasn't a finite list.
12:44:12 <astrolabe> the example with 20 was just to show what the list was
12:44:23 <astrolabe> but look up two lines
12:44:43 <astrolabe> Also, foldl can be used on infinite lists I think.
12:44:51 <palomer>  @eval foldr (++) [] (map show [1..]) !! 4321 <--this returned '1' ! shouldn't it have returned 4321?
12:45:06 <goron> ctrlsoft: I don't mind, since I understood. :D
12:45:20 <goron> ctrlsoft: I thought it was a great way to confuse someone.
12:45:23 <mauke> @eval foldr (++) [] (map show [1..]) !! 4322
12:45:24 <lambdabot> '3'
12:45:29 <astrolabe> palomer it returns the 4321th element of "12345678910..."
12:45:40 <palomer> oh, righto
12:46:07 <goron> Will that be optimized away by the compiler?
12:46:32 <palomer>  foldr (++) [] (map show [1..]) <-- this returns an infinite string?
12:46:45 <mauke> yes
12:46:48 <gzl> yes
12:46:52 <palomer> ahhh!
12:46:54 <palomer> much clearer
12:46:57 <gzl> which is fine as long as you only want a finite chunk of it
12:47:04 <gzl> e.g. if you take 20 (foo)
12:47:23 <palomer> so any datatype can be infinite?
12:48:02 <palomer> or, rather, any datatype value can be infinite (if the datatype is infinite)
12:48:21 <gzl> in general, nothing is evaluated until its value is required
12:49:03 <gzl> but you have to remember that ultimately it only makes sense to operate on a finite chunk of some infinite thing
12:50:54 <shapr> Unless it's a stream
12:50:56 <goron> gzl: In some applications you don't know whether something is finite or not.
12:51:24 <gzl> fine, unless it's a stream
12:51:40 <palomer> and the !! function is the same as index (h:t) 0 = h  index (h:t) i = index t (i-1) ?
12:51:41 <shapr> Yampa can deal with infinite streams just fine. I was pretty impressed by that.
12:51:54 <SamB> as long as you don't try to summarize the entire infinite object, you should be fine
12:52:16 <shapr> @eval maxBound :: Integer
12:52:16 <lambdabot>  add an instance declaration for (Bounded Integer)
12:52:16 <lambdabot>   In the expression: maxBound :: Integer
12:52:16 <lambdabot>   In the definition of `xxxx': xxxx = maxBound :: Integer
12:52:22 * shapr grins evilly
12:52:52 <goron> shapr: Where can I download hIde2.x?
12:53:20 <shapr> Do you have the scannedinavian repos with ghc-api, hIDE, yi-hIDE, etc?
12:53:55 <goron> shapr: never mind.
12:53:55 <palomer> so we have ("1"++("2"++("3"++(....))) !! 4321, doesn't !! need to evaluate the string before taking the index?
12:54:00 <gzl> SamB: yeah, that's what I was trying to say
12:54:04 <palomer> how does it get around this?
12:54:26 <shapr> @eval tail [1/0,1]
12:54:27 <lambdabot> [1.0]
12:54:38 <gzl> palomer: it doesn't matter what's after index 4321
12:55:04 <SamB> palomer: it doesn't have to evaluate the right arg of ++ until the whole left arg is traversed
12:55:55 <palomer> would this work if I was to construct an infinite tree instead of an infinite list? (with my own index function)?
12:56:01 <shapr> yup
12:56:18 <SamB> palomer: what sort of tree? what sort of index?
12:57:10 * CosmicRay returns again
12:57:15 <palomer> data Tree a = root | a (Tree a) (Tree a)
12:57:31 <palomer> and the index function is the standard post order traversal function
12:58:16 <palomer> written in the standard, simple way
12:58:31 <palomer> and the tree is some infinite tree
12:59:01 <astrolabe> palomer: there is nothing special about lists here. It will work with infinite trees too.
12:59:57 <SamB> postorder?
13:00:17 <shapr> USPS?
13:00:18 <SamB> anyway, the def would be
13:00:43 <CosmicRay> shapr: heh
13:00:51 <SamB> data Tree a = Leaf a | Node a (Tree a) (Tree a)
13:00:59 <palomer> have you guys ever thought that a computation should end, but it ended up you were wrong?
13:01:13 <palomer> why is Leaf capitalized? it's a value!
13:01:25 <CosmicRay> palomer: the value is "a"
13:01:30 <CosmicRay> Left and Node are constructors
13:01:32 <SamB> palomer: its a constructor
13:01:35 <SamB> maybe you meant
13:01:39 <CosmicRay> Leaf a is a function that returns a value of type Tree a
13:01:45 <SamB> data Tree a = Empty | Node a (Tree a) (Tree a)
13:01:47 <CosmicRay> well, not really....
13:01:57 <CosmicRay> but you can think of it that way.
13:02:01 <SamB> CosmicRay: yes it is!
13:02:24 <CosmicRay> oh, ok then.  nifty ;-)
13:02:37 <CosmicRay> I guess I do recall doing return . Just $ stuff.
13:02:47 <palomer> I thought Leaf was a function which takes a value of type a and returns a value of type Tree a
13:02:58 <CosmicRay> palomer: yes
13:03:10 <CosmicRay> but it is special
13:03:10 <palomer> so why is it capitaziled?
13:03:11 <SamB> okay, so "Leaf a" isn't a function
13:03:13 <CosmicRay> you can use it in patterns
13:03:27 <CosmicRay> case x of (Leaf y) -> ...
13:03:28 <SamB> palomer: because it is a syntax error to make it not?
13:03:43 <palomer> I thought the rule was "functions are not capitaziled"
13:03:43 <CosmicRay> it is just how it is defined to work in Haskell.
13:03:50 <astrolabe> @type (:)
13:03:51 <lambdabot> forall a. a -> [a] -> [a]
13:03:55 <CosmicRay> palomer: this is not a normal function ;-)
13:03:58 <astrolabe> is (:) a function?
13:04:11 <{Arias}> yes xD
13:04:18 <palomer> is it not?
13:04:24 <CosmicRay> palomer: data types, constructors, and modules are capitalized.  IIRC, nothing else is
13:04:28 <CosmicRay> palomer: it is.
13:04:32 <astrolabe> I think it is, but a special one.
13:04:37 <CosmicRay> but you can also use it in patterns.
13:06:15 <SamB> astrolabe: yes
13:06:20 <SamB> it has a special name, though
13:07:11 <SamB> special in that it always comes from Prelude (well actuall, in GHC, it comes from GHC.Base...)
13:07:47 <SamB> [] is also a (nullary) function...
13:08:03 <astrolabe> SamB: it does have a special name, but a user defined constructor would be a function too.
13:08:15 <SamB> astrolabe: yes
13:08:17 <astrolabe> as long as it wasn't nullary
13:08:32 <SamB> well, okay, so a nullary function isn't really much of a function.
13:08:41 <astrolabe> :)
13:09:05 * palomer likes monads
13:09:10 <palomer> so much better than the way sml does it
13:09:12 * palomer pukes
13:09:23 <CosmicRay> palomer: I didn't know sml had anything like them
13:09:26 * fworp sprinkles monads on his breakfast cereal
13:09:52 <astrolabe> fworp: do you not find they bind?
13:09:56 <SamB> would you like to see the STG from -ddump-stg on that datatype?
13:10:21 <palomer> CosmicRay: I mean the way sml handles io
13:10:43 <palomer> STG?
13:10:46 <SamB> palomer: thats probably why Monads are coming to ML
13:10:58 <SamB> STG -- splineless-tagless-G machine
13:11:06 <fworp> only with eachother
13:11:39 <palomer> monads are coming to ML?
13:11:40 <palomer> when?
13:11:47 <palomer> do we get type classes too?
13:11:53 <SamB> Tree.Leaf = \r [eta_s16N] Tree.Leaf [eta_s16N];
13:11:53 <SamB> SRT(Tree.Leaf): []
13:11:53 <SamB> Tree.Node =
13:11:53 <SamB>     \r [eta_s16V eta_s16W eta_s16X] Tree.Node [eta_s16V eta_s16W eta_s16X];
13:11:53 <SamB> SRT(Tree.Node): []
13:12:06 <astrolabe> ug
13:12:16 <integral> hrm, is there a function like zip, but which works with a list of lists rather than a pair of lists?
13:12:29 <SamB> its very hackish, obviously. I mean it is like self-referential...
13:13:01 <astrolabe> integral: to return what?  wouldn't you need extensions?
13:13:11 <integral> astrolabe: o_O?  I hope not
13:13:19 <astrolabe> @type zip
13:13:20 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
13:13:28 <mauke> @type transpose
13:13:29 <lambdabot> Not in scope: `transpose'
13:13:33 <integral> I want [[a]] -> [[a]], astrolabe
13:13:33 <mauke> @index transpose
13:13:34 <lambdabot> Data.List
13:13:52 <integral> thanks mauke !
13:17:05 * basti_ will do gtk2hs now.
13:18:29 <SamB> palomer: dunno!
13:18:36 <SamB> I have only heard rumours
13:19:39 <palomer> from whom?
13:19:47 <palomer> I thought the sml standard was set in stone
13:19:48 <kosmikus> @hoogle [[a]] -> [[a]]
13:19:49 <lambdabot> Data.List.transpose :: [[a]] -> [[a]]
13:19:56 <palomer> sml suffers from a gross lack of syntactic sugar too
13:20:13 <SamB> maybe another ML?
13:20:23 <palomer> haskell ML?
13:20:28 <palomer> this ML sounds like haskell without laziness
13:20:34 <SamB> no idea
13:21:22 <SamB> anyway, even if the SML standard *was* set in stone, you can always get a new stone...
13:22:00 <boegel|home> @where Nympheae
13:22:01 <lambdabot> I know nothing about nympheae.
13:22:03 <boegel|home> hmm
13:22:05 <boegel|home> help ?
13:22:15 <boegel|home> Cale, xerox: where can I find it ?
13:25:17 <SamB> @google Nympheae
13:25:20 <lambdabot> http://fins.actwin.com/aquatic-plants/month.200210/msg00364.html
13:25:34 <SamB> @what Nymheae
13:25:35 <lambdabot> I know nothing about nymheae.
13:25:55 <SamB> @google haskell Nympheae
13:25:57 <lambdabot> No result found.
13:26:23 <palomer> anyone here checked out delphin?
13:26:24 <boegel|home> SamB: it's strange, but I can't seem to find it
13:31:40 <benmos> Hi all - is there any generic advice on debugging approaches for Haskell anywhere? (Slightly more specifically I've got some code which is dynamically constructing a simple monadic parser - and it's going slightly wrong somewhere - but obviously it's kind of hard to inspect the parser which is generated without simply testing it on lots of cases - I guess maybe I need to instrument the construction function in someway?)
13:32:25 <SamB> benmos: label your parser?
13:32:40 <SamB> benmos: what does the code look like?
13:32:44 <benmos> I'm not quite sure I understand what you mean?
13:32:58 <SamB> what library are you using?
13:33:19 <benmos> building everything from scratch... basically this is just a learning exercise...
13:33:33 <basti_> @seen int-e
13:33:33 <lambdabot> I saw int-e leaving #haskell 16 hours, 19 minutes and 59 seconds ago.
13:33:52 <benmos> ...so I'm using the standard approach based on the Graham Hutton / Erik Meijer paper...
13:34:19 <SamB> you shouldn't try to do everything all at once as an exercise
13:34:32 <SamB> what do you mean by "dynamically"?
13:34:55 <benmos> ...the basic parsers work fine - ie I have it parsing a BNF syntax.... and the idea was to use that to generate a new parser on the fly for a new language...
13:34:59 * SamB really wants to see code
13:35:04 <benmos> ...it's nearly working...
13:35:19 <benmos> hmm - there's quite a bit
13:35:29 <SamB> darcs repo?
13:35:53 <benmos> well - not that much - it's all in one file!
13:36:25 <SamB> oh, well, then, put it up somewhere, or paste to lisppaste2
13:36:31 <SamB> lisppaste2: help
13:36:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:37:04 <benmos> ok - I'll do that thanks - I'd be grateful for any comments - I'll just take a couple of minutes to tidy it up a bit.
13:37:09 <benmos> will chat again in a min
13:39:04 <waltz> What did I miss!?!?
13:40:15 <SamB> waltz: when did you leave?
13:42:00 <waltz> Couple of days ago. Don't worry, I was being dramatic.
13:42:03 <lisppaste2> benmos pasted "Sample parsing code" at http://paste.lisp.org/display/13381
13:42:47 <SamB> % curl http://paste.lisp.org/display/13381/raw > benmos.hs
13:42:50 <benmos> Hi - have pasted it there - the top bit is basically a bog standard monadic parser... the bottom bit is where I'm trying to use it to read in a BNF file and generate a new parser on the fly
13:43:21 <benmos> ...basically I'd be interested in any general advice on strategies for debugging this kind of thing
13:44:12 <benmos> ....do people normally change the function to add in the IO Monad or some kind of monad to be able to record context / debugging info?
13:45:40 <benmos> ...also if you have any general stylistic advice I'd be very interested in that too!
13:46:18 <boegel|home> is anybody having problems with http://www.haskell.org/hawiki/HRay ? I got a mail from someone it's not reachable, but it's ok here
13:46:21 <SamB> benmos: well, Parsec has a nice error-handling technique
13:46:34 <benmos> ah ok - maybe I should try to imitate that?
13:46:40 <SamB> maybe
13:46:53 <benmos> (I don't want to start using Parsec itself just yet... want to try to DIY first)
13:48:50 <SamB> what is the fst (gram!!0) for?
13:49:07 <benmos> oh - just because the parsers are naturally non-deterministic...
13:49:19 <benmos> ...and return a list of possible parses....
13:49:26 <benmos> ...but in this case I think there should be only one
13:49:37 <musasabi> Has anyone tried Frown?
13:49:54 <SamB> what is the fst for?
13:50:07 <benmos> because the second part of the pair is the unparsed text...
13:50:26 <SamB> isn't it a BAD thing that there is some left?
13:50:48 <benmos> hmmm - ideally there shouldn't be - I should probably confirm that though.
13:51:01 <SamB> there is
13:51:04 <SamB> at least, for me
13:51:53 <benmos> ah - great - that'd be the problem then thanks!
13:52:10 <benmos> ....since you've taken the time to have a look - do you have any general comments?
13:52:31 <benmos> I'm starting to feel a bit bogged down under List / Maybe and Parser Monads all together ;-)
13:52:37 <benmos> maybe I'm taking a bad approach?
13:54:23 <SamB> well, I don't think this is the best way, but it seems okay if you are just playing around
13:54:33 <SamB> eof :: Parser ()
13:54:33 <SamB> eof = Parser (\s -> if s == "" then [((), s)] else [])
13:54:59 <benmos> ah, ok - thx will try that
13:55:07 <SamB> that may not be the best way to write eof, of course
13:55:27 <SamB> but it ought to work
13:55:44 <benmos> actually - that looks similar to the "completep" that I have...
13:55:51 <SamB> oh, then use that
13:56:10 <SamB> ah, that looks more convenient too
13:56:34 <SamB> because it takes a parser and returns the result
13:58:50 <benmos> thanks very much for taking the time to look! (and do let me know if there's any general comments you have ;-)
13:59:05 <SamB> the trouble with this approach is that you can't really do error messages
13:59:20 <benmos> yes ;-) I'm discovering that!
13:59:21 <SamB> or, at least, I don't see how
13:59:42 <benmos> Surely this must be a bit of a general issue though.... when you get a moderately complex function...
13:59:54 <benmos> ...which produces a result which is naturally unprintable.
14:00:04 <SamB> Parsec uses fairly-deterministic parsing
14:00:16 <SamB> benmos: well, only if you replace failure with a list of successes
14:00:17 <benmos> ....so do people normally temporarily change the type of the fn to put into the IO monad? or would that be a bad idea?
14:00:51 <benmos> you mean it would only be unprintable if you replace failure...?
14:01:46 <SamB> I mean Parsec's parsers don't return a list of possible parses
14:02:31 <benmos> ah, I see. But wouldn't the same issue exist anyway? it'd still be hard to make a Parser printable even if it only returned a single parse....
14:02:54 <benmos> (I started trying to make Parser instances an instance of Show ...and then started thinking maybe that was silly.
14:02:58 <benmos> )
14:03:38 <SamB> benmos: you don't make the parser printable
14:04:09 <SamB> instead of:
14:04:12 <SamB> data Parser a = Parser (String -> [(a, String)])
14:04:17 <SamB> Parsec has:
14:04:35 <SamB> newtype GenParser tok st a = Parser (State tok st -> Consumed (Reply tok st a))
14:04:35 <SamB> runP (Parser p)            = p
14:04:35 <SamB> data Consumed a         = Consumed a                --input is consumed
14:04:35 <SamB>                         | Empty !a                  --no input is consumed
14:04:35 <SamB>                     
14:04:36 <SamB> data Reply tok st a     = Ok !a !(State tok st) ParseError    --parsing succeeded with "a"
14:04:38 <SamB>                         | Error ParseError                    --parsing failed
14:06:10 <SamB> (State has the rest of the input as well as the source position (in case of error messages))
14:06:56 <benmos> Ok - great, thanks - it definitely sounds like I should start looking at Parsec. Just one more question if you don't mind....
14:07:26 <benmos> in my code, is it a bad idea declaring Parser with "data" rather than "newtype"?
14:08:21 <SamB> benmos: well, it doesn't make much difference in this case.
14:08:44 <benmos> ok, cool. Just wondering if one was more 'natural Haskell style'.
14:09:18 <SamB> nobody is going to want to use a parsing library with no error messages in important code, after all!
14:09:32 <benmos> very true!. Thanks very much for your help SamB. I need to head off now - cheers
14:10:02 <SamB> newtype is not much more than an optimization
14:11:21 <SamB> (it also makes pattern matching always succeed, since you use the same bottom as the inner type)
14:12:00 <SamB> basicly, a newtype makes type that is distinct from but shares the same representation as another type
14:12:15 <basti_> basti@deunan:~/haskell/gtk2hs-0.9.10/demo/cairo$ ./drawing
14:12:15 <basti_> ./drawing: symbol lookup error: ./drawing: undefined symbol: gdk_cairo_create
14:12:22 <basti_> whats that?
14:12:44 <SamB> so you get all the convenience of a new type, but all (or most of) the speed of type synonym
14:13:19 <SamB> basti_: does your gdk match your header?
14:13:19 <SamB> s/header/headers/
14:13:32 <basti_> SamB: how can i learn if it does?
14:13:42 <basti_> ahhhh
14:14:06 <SamB> benmos: do you understand what I am saying?
14:14:18 <basti_> heh no it's getting the wrong lib apparently
14:14:58 <basti_> SamB: how can i tell the dynamic linker to prefer some installation?
14:15:10 <basti_> LDPATH?
14:15:39 <SamB> basti_: I don't know.
14:15:45 <basti_> hm
14:16:18 <SamB> I don't have multiple GDKs with the same major version number...
14:16:38 <basti_> LD_LIBRARY_PATH
14:17:29 <basti_> now it's running
14:17:40 <SamB> (though presumably it would be okay if one was X11 and one was something else, for GDK2...)
14:28:21 <SamB> benmos: why do you have doubled up brackets on expr in <<addition>>?
14:28:40 <SamB> benmos: you don't seem to have any code to parse that
14:30:02 <SamB> benmos: if you take away one pair, it parses!
14:30:02 <SamB> the whole way, I mean
14:30:42 <SamB> benmos: are you another screen user?
14:33:26 * basti_ made gtk2hs draw things
14:33:30 * basti_ does the happydance
14:53:49 <Itkovian> any body knows of a haskell bibtex parser?
14:58:31 <dons> hmm, Itkovian, maybe. i'll see..
14:59:50 <Itkovian> dons: I googled, found something.
15:00:07 <dons> ah. cool.
15:01:52 <shapr> Maybe we should do ninety minute scrapheap challenges.
15:02:01 <Itkovian> but I'm still doing it in parsec :-)
15:02:08 <Itkovian> see if that works
15:02:27 <Itkovian> not sure about the order possibilites, but I guess I'll sort the strings first.
15:04:05 <basti_> shapr: i got that $(/)$/ gtk2hs to run
15:04:09 <basti_> with cairo
15:04:29 <shapr> cool
15:04:33 <dcoutts> yay
15:04:53 <shapr> Are you going to write up your problems and solutions so others won't have to go through the same trouble?
15:05:54 <Itkovian> I feel a TMR coming
15:05:57 <basti_> in the end, it was mainly debian cruft problems
15:06:05 <Itkovian> ah, maybe not
15:06:05 <shapr> What sort of 90 minute challenges would be fun to do for a weekend scrapheap challenge?
15:06:29 <stepcut> shapr: are these supposed to be useful or just fun ?
15:06:49 <shapr> A bit of both, check out the description - http://www.postmodernprogramming.org/scrapheap/workshop
15:07:37 <stepcut> hrm, tricky
15:07:48 <shapr> Of course, Nat's description of the results is what got me started on this - http://nat.truemesh.com/archives/2005_11.html
15:08:00 <tony2> hi all
15:08:14 <tony2> postmodern programing - how amusing.
15:08:20 <Itkovian> shapr: write a bibtex parser
15:08:23 <shapr> hiya tony2, how are ya?
15:08:37 <shapr> Itkovian: That sort of parser is probably a short task :-)
15:08:38 <tony2> very well thank you, and yourself?
15:08:46 <shapr> I'm okay.
15:08:53 <stepcut> one problem with haskell is that much of the stuff available on the net to reuse would take 90 mins just to get installed :p Cabal helps -- but, for example, installing HXT requirse you to install 4 or 5 dependencies
15:09:27 <shapr> stepcut: Well, I think that's the first useful output of the scrapheap challenge.
15:09:42 <shapr> "The workshop explored the usability of software components."
15:10:01 <shapr> We need cabal-get.
15:10:25 <shapr> tony2: Are you learning Haskell, or a long time user?
15:10:40 <shapr> @wiki CabalGet
15:10:40 <lambdabot> http://www.haskell.org/hawiki/CabalGet
15:11:57 <stepcut> In theory, I am supposed to be writing a debian dependency checking engine for work -- if I ever get to do it, it should be easy to port to cabal
15:12:08 <tony2> Hmm, I'm not sure. I did my final year project in it. I guess I know the language quite well.
15:12:18 <shapr> tony2: What was your final year project?
15:12:37 <shapr> stepcut: Should be pretty easy to do with Data.Graph actually.
15:13:12 <stepcut> shapr: it turns out to be a bit messy due to due the 'conflicts' tag
15:13:14 <shapr> tony2: Are you the TonyG of LShift.net?
15:13:50 <tony2> Real time control in Haskell, I ported the XVision components of FVision to haskell (pure haskell motion detection) so as to stress Andrew Cheadles real time GC for GHC.
15:13:56 <tony2> nope not me.
15:14:11 <shapr> ah cool
15:14:29 <stepcut> tony2: what OS ?
15:14:33 <shapr> Are the FVision sources online?
15:14:53 <tony2> linux. but any with ghc I guess.
15:15:02 <tony2> think so.
15:15:30 <tony2> shapr, you long term or new to haskell?
15:15:42 <shapr> midterm?
15:15:52 <shapr> I've been using it for slightly over four years.
15:16:14 <shapr> I've written a bit of code, done a bit of advocacy.
15:16:19 <SamB> he is the lifeblood of this channel ;-)
15:16:26 <SamB> if that tells you anything
15:16:27 <stepcut> tony2: did you have to deal with low-latency issues at all ?
15:16:33 <shapr> SamB: thanks :-)
15:16:58 <SamB> or something like that
15:17:09 <SamB> I suppose the channel would be rather dead if he was the only one in it...
15:17:26 <tony2> uh, well only GC issues. Thats where the incremental GC came in. Doing motion detection, at the bits and bytes level in haskell is madness of course.
15:17:34 <tony2> What when theres a FFI and all.
15:17:36 <SamB> but then it takes more than blood to keep a person alive too...
15:17:46 <dbremner> shapr - what about writing an implementation of Othello as a challenge?
15:18:24 <shapr> With graphics?
15:19:06 <shapr> Yeah, all the simple games would be good  challenges.
15:19:07 <dbremner> shapr - possibly.
15:19:27 <stepcut> tony2: ah.. I am trying to do some realtime music sythesis with haskell, linux, and MIDI -- but figuring out how to synchronize the MIDI is a bit tricky because the linux timer granularity is somewhat high by default... (2+ ms)
15:19:37 <stepcut> or, atleast, that is what I have read
15:19:56 <shapr> It's configurable in 2.6.14
15:20:21 <stepcut> I could use 'get time of day' and poll instead -- but if ntp is runnnig that could be ... interesting
15:20:22 * araujo will try to do something with Haskell right now. If he makes it, he will shout "I LOVE Haskell" to all the neighborhood from the window
15:20:53 <stepcut> shapr: yeah -- now if only reiser4 worked right with 2.6.14...
15:21:13 <shapr> true that
15:21:35 <stepcut> since my main partition is reiser4, that is rather important to me ;)
15:22:08 <shapr> I started using 4k pages before I got interested in reiser4, so I've still never tried it.
15:22:27 <stepcut> heh
15:22:31 * shapr plays with cabal-get-bootstrap
15:23:23 <stepcut> on the other hand, if I wait long enough, the jack developers are going to integrate MIDI into jack, and the MIDI time stamps will correspond to jack sample offsets -- which is exactly what I need
15:23:30 <SamB> stepcut: aren't there facilities for timing notes?
15:23:51 <SamB> oh
15:24:03 <stepcut> SamB: well, I am trying to do this real-time... so I need a way to link the timing of incoming MIDI data with the generation of audio samples
15:24:14 <tony2> what about garbage stepcut?
15:24:19 <shapr> tony2: So, what do you do with Haskell these days?
15:24:34 <SamB> stepcut: well, waiting for jack to do it is probably best then
15:24:51 <SamB> or possibly giving it a bit of help
15:24:54 <stepcut> tony2: dunno, that is part of why I am trying this project -- currently I just call performGC when I think I won't be doing anything for a while
15:25:19 <stepcut> there is a raging debat on the jack devel list right now about what to do, so I am going to let them hammer it out
15:25:56 <shapr> Does cabal autohide modules on build?
15:26:12 <tony2> shapr, well I've got afew projects on the go...
15:26:21 <shapr> I'm trying to build XmlRpc - "Could not find module `Network.Socket': it is a member of package network-1.0, which is hidden"
15:27:11 <tony2> but nothing of too much interest (yet).
15:27:23 <stepcut> tony2: is there any papers I should read regarding realtime GC in haskell ?
15:27:38 <shapr> I'd like to hear a bit about your projects. I'm always interested in Haskell info I haven't heard yet.
15:27:42 <araujo> Is there exist a function to get an Either value?
15:27:56 <musasabi> @type Left
15:27:56 <lambdabot> forall b a. a -> Either a b
15:28:02 <musasabi> @type Right
15:28:03 <lambdabot> forall b a. b -> Either a b
15:28:27 <stepcut> tony2: There are a number of realtime audio apps I am going to write, and I would like to do them in haskel if possible
15:29:04 <shapr> So I exposed network-1.0, but I still get the same error. Any idea what's happening?
15:29:09 <araujo> Thanks [Left lambdabot , Right musasabi]
15:29:20 <tony2> steepcut, Andrew Cheadle, who supervised my project at imperial is impementing an incremental GC for GHC...
15:29:45 <shapr> Is that from 'Nonstop Haskell' ?
15:29:56 <tony2> steepcut, yup thats the one.
15:30:22 <shapr> Funny how a bunch of names here on #haskell start with s
15:30:55 <dbremner> tony2 - is that Baker's Treadmill?
15:30:57 <tony2> steepcut, I think he intends to merge it into the main tree at some point.
15:30:59 <stepcut> tony2: cool, when I get to the point where GC is causing me problems I will check that out
15:31:29 <stepcut> I am sure more real-world apps that use it will help him out :)
15:31:32 <shapr> Henry Baker, GC expert and unicyclist.
15:32:09 <SamB> > 173 / 26
15:32:10 * dbremner stands on Times Square handing out flyers about the secret CompSci Unicyclist Cabal.
15:32:10 <lambdabot> 6.653846153846154
15:32:31 <shapr> dbremner: sure looks like it - http://citeseer.ist.psu.edu/cheadle00nonstop.html
15:32:43 <shapr> hiya as
15:32:50 <shapr> as: learning Haskell?
15:33:54 <shapr> dbremner: Have you seen my list of unicycling programmers?
15:34:15 <as> hi, shapr. yes, it looks like. slowly.
15:34:32 <shapr> as: Do you have any questions?
15:34:33 <dbremner> shapr - nope.
15:34:47 <shapr> http://www.scannedinavian.org/AvianWiki/UnicyclingProgrammers
15:35:17 <SamB> dbremner: why would a secret cabal hand out flyers?
15:36:21 <tony2> shapr, dbremner, Samb - so what Haskell projects are you all working on then?
15:36:29 <dbremner> SamB - The cabal isn't handing out flyers.
15:38:02 <shapr> I have a large collection of unfinished projects. Closest to completion at the moment is Fermat's Last Margin, an annotation tool - thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=TestMargin
15:38:11 <SamB> tony2: well, I'm helping out with Conjure
15:38:41 <tony2> good name for an annotation tool,
15:39:01 <tony2> SamB, what is Conjure?
15:39:04 <SamB> @remember conjure BitTorrent client in (hopefully) 10,000 lines: darcs get http://j.mongers.org/pub/haskell/darcs/conjure/
15:39:14 <SamB> er, no, not remember.
15:39:15 <shapr> Isn't it where+ ?
15:39:24 <SamB> @help what
15:39:24 <lambdabot> Remember urls of open source projects
15:39:37 <shapr> too many lambdabot commands...
15:39:58 <shapr> I think we'll be able to beat 10k lines easily.
15:40:34 <tony2> I'd have thought so, I don't know the protocol but 10k is quite a lot.
15:40:35 <shapr> Anyone know why network-1.0 is hidden when I try to build XmlRpc, even though it's exposed with ghc-pkg?
15:41:10 <dbremner> tony2 - I've got a lot of partial projects - I have yet to use Haskell in anger.
15:41:12 * shapr wants to try cabal-get
15:41:22 <SamB> @what+ conjure BitTorrent client in (hopefully) 10,000 lines: darcs get http://j.mongers.org/pub/haskell/darcs/conjure/
15:41:22 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
15:41:33 <shapr> tony2: Oh, I'm editor for The Monad.Reader, want to write an article?
15:42:04 <tony2> shapr, I'm don't think I'm quite up to that.
15:42:04 <shapr> Editor really just means recruiter for a wikizine.
15:42:29 <shapr> tony2: I'm sure you'd do fine. Short articles on any Haskell subject are welcome.
15:42:55 <tony2> shapr, I'll get back to you on that oe......
15:43:01 <shapr> We've had such illustrious authors as Oleg Kiselyov, Shae Erisson, Wouter Swierstra, Kenneth Hoste, Sven Moritz Hallberg, Isaac Jones, etc etc
15:43:32 <shapr> Lots of people from #haskell have contributed articles.
15:43:49 * stepcut swears he will finish his unix pipes article someday
15:43:54 <shapr> If you haven't seen TMR - http://www.haskell.org/tmrwiki/FrontPage
15:43:57 <stepcut> I think the code finally works atleast :p
15:44:12 <shapr> yay!
15:44:38 <shapr> I keep hoping to bring TMR back to once a month, but I don't think it's going to happen.
15:44:42 <SamB> shapr: but Shae Erisson is you!
15:44:45 <shapr> Not enough authors.
15:44:53 <SamB> you can't call yourself illustrious!
15:45:11 <wilx> Yo!
15:45:15 <shapr> SamB: Ok really I wanted one more article to make it five, and no one was available, so I wrote it myself.
15:45:31 <wilx> Have you seen the John Hughes survery on Haskell ml?
15:45:35 <shapr> On the good side, it turned out to be six articles.
15:45:42 <wilx> What is the difference between DARCS and darcs there?
15:45:42 <araujo> musasabi, oh, i meant.. if i could get the value '4' from something like... Left 4
15:45:44 <araujo> :-)
15:46:00 <stepcut> wilx: capslock
15:46:06 <wilx> Hehe.
15:46:25 <SamB> shapr: you can write articles, and mention that fact, but not call yourself illustrious
15:46:33 <shapr> SamB: Ok, fair enough.
15:46:42 <shapr> It was really meant to be humorous in my case :-)
15:47:19 <shapr> Wow, 39% of the surveyed learned Haskell in 2002 or later.
15:47:24 <SamB> shapr: oh, well then thats okay ;-)
15:47:28 <musasabi> araujo: either "either" of a case expression.
15:47:43 <stepcut> I started at the very beginning of 2002
15:47:56 <musasabi> You can also define fromLeft/Right like: fromLeft (Left x) = x
15:48:28 <araujo> musasabi, yeah, thanks, i just wanted to avoid reinventing the wheel if possible :-)
15:49:22 <shapr> I started mid 2001 I think.
15:49:46 <tony2> there's something bothering me a little...but why <i>another</i> bittorrent client?
15:49:51 <shapr> SyntaxNinja: Hey, I'm having trouble building xmlrpc for cabal-get-bootstrap
15:50:22 <shapr> SyntaxNinja: network-1.0 is hidden when I try to build XmlRpc, even though it's exposed with ghc-pkg. Any ideas?
15:51:04 <sh10151> learning
15:51:18 <tony2> I dont mean to crtisise, just can never undertand so many re-implmentations.
15:51:36 <tony2> learning...fair enough.
15:51:40 <sh10151> or maybe it is like Tanenbaum asking ... but why <i>another</i> monolithic kernel
15:51:51 <shapr> I started writing a BT client purely for my own entertainment, and because all the python clients had problems.
15:52:16 <tony2> lol sh10151, Tanenbaum was right though yeah?
15:52:19 <musasabi> Having a working BT client would be nice
15:52:49 <sh10151> has someone written a bittorrent client for emacs yet
15:52:56 <shapr> I've gotten 35gb of live shows from bt.etree.org since I found that site, and I'd like to be able to run thirty or forty torrents at once efficiently.
15:53:32 <shapr> Right now I can run about seven clients before cpu usage, disk responsiveness, and bandwidth start flaking out.
15:53:36 <musasabi> Does conjure support downloading single files from a multifile torrent?
15:53:52 <shapr> It could do so easily.
15:54:16 <tony2> well, if you've got solid performance/stability issues fair enough.
15:54:23 <shapr> It might do weird things for the choking though.
15:55:12 <shapr> tony2: Honestly, I could just use the Python clients and live with their problems, but I thought I'd spend a few hours hacking on it.
15:55:34 <shapr> I put up a darcs repo, got bored, went on to something else and forgot about it.
15:55:43 <SamB> musasabi: conjure doesn't work yet ;-)
15:56:02 <shapr> jlouis liked the idea, rewrote my tiny bit of code, extended it dramatically, and it's really moving now!
15:56:33 <SamB> shapr: you should put up an ideaboard of your ideas
15:56:40 <shapr> I got the BEncode parser from sylvan here on #haskell, so this is a real Open Source spirit project.
15:57:11 <shapr> I should put my ideas on my blog.
15:57:45 <SamB> shapr: no, board!
15:58:00 <shapr> What's an ideaboard?
15:58:06 <SamB> board more convenient for browsing
15:58:06 <wolverian> shapr, your bandwith can support forty torrents?
15:58:08 <Lemmih> shapr: XmlRpc may not explicitly depend on network.
15:58:46 <shapr> wolverian: when they're creeping along at 1k, sure.
15:58:59 <SamB> well, I guess blogging and then listing the blog entries would work equally well...
15:59:13 <shapr> Yeah, I need to switch to a Flippi based blog.
15:59:59 <shapr> Lemmih: Adding it to the build-depends will fix that?
16:00:08 <Lemmih> Yes.
16:00:14 <shapr> Thanks, I'll try that.
16:00:19 <wolverian> shapr, okay. just that is burdens the tracker.
16:00:41 <tony2> DO any of you actually work with Haskell? I mean in a day job fashion.
16:01:19 <shapr> wolverian: Even the khashmir tracker?
16:01:46 <SamB> I don't even *have* a day job yet
16:02:02 <wolverian> shapr, I have no idea.
16:02:09 <shapr> I've been paid to write Haskell twice. I'm a self-employed contract geek.
16:02:09 <tony2> good for you SamB, me neither.
16:02:11 <ndm> tony2, i have a phd in haskell, which pays money - so i guess kind of
16:02:40 <tony2> ndm, where/on what?
16:02:41 <shapr> SyntaxNinja has a day job doing Haskell.
16:03:12 <ndm> tony2, www.cs.york.ac.uk/~ndm/
16:03:24 <tony2> ah, lovely city.
16:03:25 <ndm> york, on various haskell projects
16:03:36 <ndm> officially on a case and terminatino checker for haskell
16:03:45 <ndm> proviing haskell doesn't crash and always termiantes
16:04:10 <tony2> guarented termination, hmm....
16:04:28 <ndm> yes, guaranteed terminatino
16:04:33 <shapr> Ah, poo. HaXml 1.14 removed Haskell2Xml entirely.
16:04:44 * shapr decides to give up and sleep
16:05:57 <tony2> Do they teach Haskell to undergrads at york ndm?
16:06:07 <ndm> tony2, an optional 3rd year course
16:06:14 <ndm> so not to all, but to some
16:06:30 <ndm> taught by Colin Runciman - a very good course!
16:07:10 <ndm> i am trying to persuade people to teach it as the first language in the first year, instead of Scheme
16:07:44 <tony2> It was the first language in first year at Imperial. But I feel they should have gone further.
16:07:58 <sh10151> ndm: do they use the MIT book for Scheme or something else?
16:07:59 <tony2> Scheme...urgh.
16:08:21 <ndm> sh10151: indeed they do, i have a copy on my shelf from the first year
16:08:42 <ndm> Structured Interpretation of Computer Programming
16:09:03 <ndm> tony2, its nice once you get over the brackets
16:09:09 <ndm> and if you've never seen haskell
16:10:19 <sh10151> scheme and lisp seem to be more hacker's languages
16:10:21 <tony2> ndm, yeah haskell does that to other languages.
16:10:51 <ndm> sh10151: hacker = someone who hacks things together badly, or someone who writes a lot of code ?
16:10:54 <sh10151> kind of like the Perl of the expression-oriented languages
16:11:13 <sh10151> ndm: i think the buzzword is "interactive development"
16:11:29 <ndm> sh10151: you mean Hugs :)
16:11:31 <sh10151> also iterative
16:11:34 <sh10151> well, no
16:11:35 <araujo> Can i do something like: (_,s) <- (putStr "greetings" , return "hello") ?
16:11:42 <sh10151> it's for people who might code as a thinking aid
16:11:49 <ndm> araujo, no
16:12:02 <ndm> a monadic action must be on the "outside" of a <-
16:12:04 <sh10151> i guess that's what I mean by hackers, code, then think, then maybe code again
16:12:17 <ndm> i find haskell lets me do that
16:12:35 <ndm> although with haskell you can usually give up before the think phase
16:12:36 <araujo> ndm, What is another equivalent way of doing what i want?
16:12:44 <Cale> araujo: what do you want from that?
16:12:53 <ndm> do x <- putStr "greeintgs" ; return "hello"
16:13:22 <araujo> Cale, Well, let's see.... i got a function that mighe return either IO () or IO String......
16:13:38 <Cale> do {x <- putStr "greetings" ; return "hello"} :: IO String
16:13:41 <ndm> araujo: no you don't! static typing makes that impossible
16:14:09 <ski> (_,s) <- liftM2 (,) (putStr "greetings") (return "hello")
16:14:14 <Cale> araujo: perhaps you want an IO (Maybe String)?
16:14:29 <araujo> mm yeah :-D
16:14:36 <araujo> Let's see.. thanks ski Cale
16:14:54 <ski> s <- putStr "greetings" >> return "hello"
16:16:13 <Frederick> heya ski
16:17:09 <dons> yyeah. my little ncurses mp3 player is refreshing nicely :)
16:17:16 <dons> hooray for ghc threads
16:17:32 <stepcut> heh
16:17:55 <stepcut> how soon til you integrate it into yi?
16:18:03 <dons> it's almost a fork of yi.
16:18:11 <dons> it uses the keymaps of yi, and much of the ui code
16:18:16 <stepcut> exactly, so why have all the duplicate code sitting around
16:18:18 <dons> also the state model
16:18:40 <dons> we should have a high level ncurses library
16:18:54 <dons> on the gtk2hs level of abstraction, built over hscursees
16:19:02 <ndm> dons, yhc is now in darcs - hoogle will be moving to darcs this week sometime
16:19:07 <dons> yay!
16:19:10 <dons> @karmma+ ndm
16:19:10 <lambdabot> ndm's karma raised to 5.
16:19:40 <dons> the cosmos looks well upon good rcs :)
16:19:52 <ndm> i actually like darcs, its funny
16:20:01 <dons> :D
16:20:02 <ndm> and i've spent the last 2 days writing a windows gui for darcs
16:20:10 <dons> oh, isn't there one already?
16:20:15 <ndm> nope
16:20:18 <stepcut> oh, yhc looks nice
16:20:19 <dons> hmm.
16:20:22 <dons> @karma+ ndm
16:20:22 * sh10151 has been looking at darcs too
16:20:22 <lambdabot> ndm's karma raised to 6.
16:20:22 <dons> :)
16:20:53 <stepcut> is there a plan to port the yhc runtime system to palmOS ?
16:20:55 <ndm> stepcut, why does it look nice? (its interesting to see what people see as the good features)
16:20:56 <ski> hi Frederick
16:20:58 <dons> ok, so all of hmp3 is now in place. time to make the ui pretty
16:20:59 <ndm> stepcut, want to do it?
16:21:10 <ndm> we'll except patches, and it shouldn't take more than 10 mins
16:21:37 <ndm> we would do it, but i don't have an appropriate device handy
16:21:47 <stepcut> ndm: hrm, I think it would take more than 10 mins for me to figure out how to compile a C program for palmOS.. I have only used LispMe
16:22:05 <stepcut> but, I am highly interested non-the-less
16:22:10 <ndm> stepcut, fair enough - but it should port easily
16:22:24 <ndm> it is 100% ansi C, nothing difficult, nothing complicated
16:22:38 <ndm> it should be 10 minutes from hello world
16:22:53 <stepcut> cool, I have to finish an ecommerce site first -- but maybe this weekend
16:22:58 <ndm> it took 2 minutes to port to a 64 bit opteron
16:23:04 <stepcut> oh...
16:23:06 <stepcut> hrm
16:23:21 <stepcut> hehe...
16:23:41 <ndm> when you feel the desire to port it, be sure to send the changes back to us, and ask for any help you need
16:23:51 <stepcut> if I am feeling extra adventurous -- I could try to recompile the byte-code for the flash virtual machine :p
16:23:59 <ndm> ndm, tomshackell, beelsebob - we'll all help
16:24:14 <ndm> thats quite advanced - sounds like a recompiler
16:24:36 <ndm> was going to write one for .NET bytecode, but its pretty complex - the YHC bytecode assumes lazy evaluation
16:24:47 <stepcut> I will have to look at the guts a bit
16:24:54 <ndm> @where yhc
16:24:55 <lambdabot> www.cs.york.ac.uk/~ndm/yhc
16:25:03 <ndm> 	www.cs.york.ac.uk/~ndm/yhc/notes/
16:25:12 <stepcut> I have a primitive scheme to .swf compile in the works -- so hopefully I can reuse that a bit
16:25:13 <ndm> thats a directory with some notes on the guts of yhc
16:25:31 <ndm> just IM conversations, but may help you a bit
16:25:35 <stepcut> ok
16:25:57 <stepcut> thanks
16:26:33 <ndm> .swf? flash files?
16:26:56 <stepcut> yeah
16:28:00 <stepcut> bbiab, gotta make dinner
16:29:40 <stepcut> nm.
16:30:24 <sh10151> are we ever going to see Microsoft let Haskell out of the mad scientist dungeon?
16:30:53 <stepcut> But yes -- I am writing a scheme to .swf compiler in haskell, and then I was going to port or write a scheme interpreter that would work on it -- so you could go to a flash page and writing interactive scheme apps
16:31:30 <ndm> stepcut, that would be way cool
16:31:35 <ndm> but more cool if you did yhc bytecode
16:31:41 <ndm> since yhc can be compiled to yhc bytecode
16:31:58 <ndm> then you could write and run a haskell program in scheme
16:32:03 <ndm> * scheme -> flash
16:32:33 <ndm> i was tempted to do a javascript runtime for yhc, but i think it would be too slow
16:32:42 <stepcut> or postscript ;)
16:33:09 <ndm> hehe, postscript would be amusing
16:38:00 <dons> well, you should at least have a sed bckend
16:38:36 <dbremner> dons - apparently an Amazon intern wrote an x86 disassembler in sed.
16:38:53 <dons> hehe. cool.
16:39:17 <dons> I always think the unlambda interpreter in sed is pretty cool.
16:43:49 <tony2> goodnight all
16:45:02 <dons> @pl \t -> hPutStrLn stderr ("ERROR " ++ t)
16:45:02 <lambdabot> hPutStrLn stderr . ("ERROR " ++)
17:16:45 <Frederick> ski, this is what Ive done so far http://rafb.net/paste/results/AKhSSN64.html
17:18:31 <ski> m
17:19:05 <ski> do you need/want type parameters 't' and 'nt' ?
17:19:10 <ski> anyway
17:19:18 <Frederick> as Ive said it is a draft
17:19:33 <Frederick> Im new to the language so I might be choosing the worst path to get it done
17:19:47 <ski> you should import Parsec, decide on format to parse and start coding the parsers
17:20:38 <Frederick> should I forget what Ive done so far?
17:20:59 <ski> no, why ?
17:21:12 <ski> http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html and submodules
17:21:19 <Frederick> dunno if I cant still using the strucure oki im reading it
17:21:24 <Frederick> in fact ive already read it
17:21:40 <fworp> that was quick
17:22:14 <ski> import Text.ParserCombinators.Parsec
17:22:15 <ski> etc
17:22:25 <Frederick> fworp, Ie read it during this week
17:22:32 <ski> hehe
17:22:40 <fworp> im just messing around :P
17:22:55 <Frederick> fworp, you are helping me the least I must do is beeing honest
17:24:08 <ski> actually http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Prim.html contains the basic things you need
17:24:59 <ski> so, hm
17:25:09 <Frederick> ski, im reading http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html
17:26:06 <Frederick> it is more tutorial like than the doc you gave me :p
17:26:49 <ski> yes
17:27:01 <ski> the doc i gave you is just API
17:27:16 <ski> you need to get some feel for how to use the combinators for parsing
17:28:39 <ski> Frederick : yell when you wonder something or are done for the moment with that doc (or want more detailed help/explanation), ok ?
17:29:13 <Frederick> ski, I will keep struggling but Im lost
17:29:26 <ski> ok, lost in what ?
17:30:18 <Frederick> In defining the structures as Ive said how will I call that lists and stuff
17:30:37 <ski> 'call that lists' means ?
17:30:50 <ski> do you mean 'how will i extract the lists' ?
17:31:48 <Frederick> once ive matched the expr with the pattern I want to have them in lists so I will be able to acces them, like I want to do something like run thorught the list getting its elements like x:xs but I wan to be able to reference to a given list
17:33:47 <ski> foo (CFG {terminals = ts, nonterminals = nts, root = r, productions = ps}) = ..do studd with ts, nts, r, ps..
17:33:48 <ski> ?
17:33:55 <ski> s/studd/stuff/
17:35:06 <Frederick> yes
17:36:18 <ski> a pattern like that destructures the CFG and accesses the parts
17:36:37 <ski> if you want, you can also use selector functions instead/also
17:37:17 <ski> foo cfg = ..do stuff with terminals cfg, nonterminals cfg, root cfg, productions cfg..
17:38:19 <JKnecht> Medak and Navratils Haskell tutorial is lousey with typos. I'm usually pretty tolerant of non-native English speakers but something about 'faculty' instead of 'factorial' just pisses me off.
17:41:43 <ski> Frederick : http://rafb.net/paste/results/FFVzme15.html
17:42:10 <ski> JKnecht : where's that ?
17:45:07 <JKnecht> It's a PDF which IIRC I got from Haskel.org. Dated 2/2003 and Geoinformation Inst. Wien is by-line.
17:46:27 <JKnecht> sect 3.1 Recursion - the fundamental principle of FP, or who stole loops and counters.
17:47:23 <JKnecht> s/./?/
17:50:56 <JKnecht> It's not worthless though, I think and will use but it does fail massively in it's intended purpose to be a 'hands-on' tutorial. IMNSHO.
17:51:48 <ski> "(comments and recommendations are welcome!)" :)
17:53:47 <JKnecht> guess that fuzzification, as such doesn't make sense for Haskell.
17:54:17 <ski> fuzzification ?
17:54:21 <JKnecht> Fuzzy Logic, yes. Fuzzy Mathematical Logic mehbe an oxymoron.
17:57:30 <fworp> JKnecht, are you saying the "hands-on" part doesnt make sense in haskell?
17:57:59 <fworp> in the context of a tutorial
17:58:57 <JKnecht> sorry. Switched context; of course latter an advanced question/topic.
17:59:14 <JKnecht> no relation to tutorial.
18:00:17 <Frederick> ski, it is 12 pm here im awake since 6 am
18:00:27 <Frederick> I gtg sleep or I wont be able to even think :p
18:00:37 <ski> ok
18:00:40 <ski> ttyl, then
18:00:51 <Frederick> I got more 14 days to do it do you consider it a good time?
18:01:02 <ski> possibly
18:01:17 * Frederick is afraid of failure
18:01:23 * ski don't know how long time the transformations will take
18:01:50 <Frederick> ski, I believe that a transformation would take at most 3 hours to be done
18:01:56 <Frederick> cause I have them in paper already
18:02:00 <ski> ok
18:02:03 <Frederick> into a functional style
18:02:14 <Frederick> already with lists and recursion abstractions
18:02:21 <ski> ok
18:02:37 <fworp> JKnecht: oh, i completely misread what you said, woops.
18:02:39 <Frederick> good night folks
18:02:45 <ski> night, Frederick
18:03:00 <Frederick> ski, I will be back tommorow as usually :) but then I wont have to wake up so early :)
18:03:03 * Frederick is gone
18:07:09 <JKnecht> fworp: no a hands on tutorial with the current Hugs definitely would work. The gotten item works by virtue of salvage value, i.e. reading it and getting the gist.
18:58:50 <palomer> hrm
18:59:00 <palomer> I was reading a .ps file about haskell before
18:59:06 <palomer> but I've lost the url
18:59:11 <palomer> cosmicray gave it to me
18:59:17 <palomer> what's the standard intro to haskell?
18:59:24 <ski> YAHT ?
18:59:35 <palomer> oh yes, found it
18:59:38 <palomer> is it the best one?
18:59:50 <ski> it's quite good, anyway
19:01:21 <fworp> is that the one you have to contact the author to get?
19:01:26 <palomer> when's the next haskell standard coming out?
19:01:35 <palomer> fworp: you need to fill out some contact information
19:02:11 <fworp> palomer: i did, at one point, and never got a copy, about a year ago
19:02:24 <fworp> i should try again
19:02:50 <palomer> it's automatic
19:03:42 <palomer> literate programming rocks
19:03:46 <fworp> oh. well.
19:05:42 <palomer> hrm, haskell doesn't have equality types?
19:05:44 <palomer> strange:O!
19:05:53 <Korollary> palomer: what do you mean ?
19:06:18 <ski> palomer : are you thinking of "''a" stuff in SML ?
19:06:31 * fworp wonders if it was automatic a year ago... i dont remember there being a big grey DOWNLOAD button there
19:06:44 <Korollary> fworp: I remember being emailed and such
19:09:27 <palomer> yeah
19:11:30 <ski> palomer : that is handled by "Eq a => ...a..." in haskell
19:11:42 <ski> @type elem
19:11:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
19:11:55 <ski> instead of  ''a * ''a list -> bool
19:12:20 <palomer> right
19:12:27 <palomer> but you have to declare an instance of Eq, no?
19:12:47 <ski> (in one way, type classes are a generalization of "equality types")
19:12:49 <ski> yes
19:12:58 <ski> either declare or derive
19:13:10 <ski> data Foo = ..... deriving Eq
19:13:23 <palomer> but, say I have a datatype with 10 constructors
19:13:28 <palomer> this means I need to write 10 lines of code!
19:13:34 <palomer> (for Eq)
19:15:05 <Korollary> no
19:15:52 <Korollary> just one deriving would do. If you want, you could declare and define 10 equalities as well.
19:15:53 <palomer> <ski> data Foo = ..... deriving Eq <--is this valid syntax?
19:16:44 <ski> data MyMaybe a = MyNothing | MyJust a deriving Eq
19:16:52 <ski> will automatically add an instance
19:17:03 <ski> instance Eq a => Eq (MyMaybe a)
19:17:06 <palomer> cool
19:17:07 <ski>   where
19:17:21 <palomer> can any instance be derived?
19:17:21 <ski>   MyNothing == MyNothing = True
19:17:32 <palomer> what if you have doubles in your type?
19:17:36 <ski>   MyJust a0 == MyJust a1 = a0 == a1
19:17:43 <ski>   _ == _ = False
19:18:07 <ski> not all, but many common can be derived
19:18:29 * ski leaves
19:20:18 <sh10151> there an easy way to build the .lhs in darcs source into a document?
19:20:27 <sh10151> inline code included?
19:21:32 <palomer> whoa, monad is a class
19:26:38 <araujo> You just found the truth!
19:36:56 <sh10151> i notice a lot of $ in the darcs code
19:39:41 <dons> saves on ()
19:55:50 <palomer> who here uses literate programming?
20:23:41 <stepcut> palomer: I do occasionally
21:00:14 <Lemmih> Good morning, SyntaxNinja.
21:07:04 <SyntaxNinja> hi Lemmih
21:18:39 <SyntaxNinja> party in here, 'eh:
21:20:50 <dons> is it possible to write a .cabal for building an executable only, with no associated libbrary?
21:20:57 <SyntaxNinja> yea
21:21:01 <dons> it seems like it's almost there, but I can't get it to preprocess my .hsc files
21:21:21 <SyntaxNinja> just don't list other-modules or exposed-modules in your first stanza
21:21:55 <dons> i currently have no modules listed, except Main-is:             Main.hs
21:22:06 <dons> but my Curses.hsc is not getting preprocessed.
21:22:24 <dons> so it's not chasing the dependency tree from Main.hs ? when doing preprocessing?
21:22:25 <SyntaxNinja> you need to list Curses in your other-modules in the executable stanza
21:22:30 <dons> ah. cool.
21:22:35 <SyntaxNinja> no, it doesn't chase dependencies like that, not yet.
21:22:43 <SyntaxNinja> we need a dependency analyzer
21:22:47 * SyntaxNinja pokes ndm
21:23:24 <dons> yep. that works :)
21:23:27 <dons> cheers.
21:25:41 <SyntaxNinja> no problem.
21:32:00 <dons> here's my new curses mp3 player frontend: darcs get http://www.cse.unsw.edu.au/~dons/code/hmp3
21:32:03 <dons> :D
21:32:34 <Korollary> are you kidding me
21:32:35 <dons> currently just a basic interface. next/prev. skip. pause. quit. but, heh, it's only a few hours old :)
21:32:50 <dons> anyone want a screenshot?
21:32:56 * dons fires up xwd
21:33:00 <Korollary> I believe you
21:33:20 <dons> uses mpg321 as the backend decoder.
21:33:23 <Korollary> ah
21:33:27 <Korollary> big cheat
21:33:36 <dons> once again haskell wins for rapid development.
21:33:43 <dons> nah, i just want decent non-crashing gui.
21:33:53 <dons> a native haskel decoder is a way bigger job
21:33:55 <Korollary> don't you have xmms ?
21:34:10 <dons> i've tried a bunch of curses uis, and they all seem to have problemms
21:34:27 <dons> not one hasn't been tricked into crashing (or not working for some reason)
21:34:30 <Korollary> console jockey eh
21:34:58 <dons> aren't we all ;)
21:35:21 <Korollary> I was actually looking for a console based player a few months ago.
21:35:44 <Korollary> I log on remotely to my own linux box. And I don't like vnc. I use screen all the time.
21:36:12 <Korollary> if something existed that let me suspend native X sessions and resume them later, I would switch
21:36:14 <dons> i should write a howto on writing multithreaded ncurses apps in haskell
21:37:48 <stepcut> a TMR article maybe ?
21:38:22 <stepcut> dons: screenshot please :p
21:38:28 <dons> it's on its way...
21:38:35 <SyntaxNinja> dons: screenshot, yeah :)
21:39:07 <dons> hmm. how to do xpm to .png or .jpg?
21:39:26 <stepcut> sox ? ;)
21:39:32 <dons> gimp!
21:39:38 <encryptio> convert.
21:39:42 <encryptio> as in imagemagick
21:40:03 <stepcut> I started writing a png decoder in haskell -- but it is currently stalled due to lack of time
21:42:36 <dons> first stab at a ui (rough draft!) : http://www.cse.unsw.edu.au/~dons/hmp3.png
21:43:29 <dons> works nicely though. you scroll up and down the mp3 list with arrows or jk, skip left and right with hl left and right. pause with p or ' '. and quit with 'q' or ^C
21:43:40 <dons> currently just accepts a list of .mp3 files on the cmd line
21:44:32 <stepcut> dons: maybe for the screen shot you should have just done hmp3 > hmp3-screenshot.txt
21:44:34 <stepcut> ;)
21:44:46 <dons> hehe
21:44:54 <dons> colours are more work
21:45:15 <stepcut> i love that cd though-- track07.cdda.wav.mp3 is a sweet tune
21:47:46 <SyntaxNinja> that's what I'm listening to right now
21:48:01 <dons> heh.
21:48:06 <stepcut> ~/projects/haskell/hmp3 # runhaskell Setup.lhs install
21:48:06 <stepcut> Installing: /tmp/hmp3/lib/hmp3-0.1 & /tmp/hmp3/bin hmp3-0.1...
21:48:06 <stepcut> *** Exception: dist/build/hmp3: copyFile: does not exist (No such file or directory)
21:48:17 <SyntaxNinja> dons: that's the ascii pr0n of screenshot pr0n
21:48:19 <dons> Cabal?
21:48:47 <stepcut> Cabal-1.0
21:49:14 <dons> i've only tested with Cabal-1.1.4
21:49:21 <stepcut> ok
21:49:48 <dons> @where+ hmp3 http://www.cse.unsw.edu.au/~dons/code/hmp3
21:49:48 <lambdabot> hmp3 ~> http://www.cse.unsw.edu.au/~dons/code/hmp3
21:50:28 <stepcut> oh wait, this is the real problem: Linking ...
21:50:29 <stepcut> gcc: dist/build/./hmp3-tmp/cbits/utils.o: No such file or directory
21:50:32 <stepcut> :p
21:50:57 <stepcut> ~/projects/haskell/hmp3 # find . -name "*utils.o"
21:50:57 <stepcut> ./dist/build/hmp3-tmp/cbits/cbits/utils.o
21:51:20 <dons> oh, similar to that other issue with cbits.
21:51:25 <dons> in yi.
21:51:45 <dons> aah, but the path is bogus?
21:51:56 <thou> howdy
21:52:12 <stepcut> yeah -- there is an extra cbits to where the file really lives
21:52:36 <dons> hey thou
21:54:39 <thou> dons: i just compiled lambdabot from darcs, and when i run it i get "lambdabot: ./Serial.o: unknown symbol `DataziFastPackedString_empty_closure'"; if I do "nm ~/local/lib/fps-0.1/ghc-6.4.1/HSfps-0.1.o|grep empty_closure" it shows me "00000288 D DataziFastPackedString_empty_closure"
21:55:15 <dons> hmm. weird.
21:55:23 <thou> evidently i've hosed something when i did the install of FPS?  ghc-pkg lists it in my home package.conf
21:55:40 <dons> if you make distclean and try again, does that help
21:55:44 <dons> what ghc version?
21:56:00 <thou> i just did that, and I did 'gmake way=static' and it still is doing the same thing
21:56:06 <thou> 6.4.1
21:56:19 <dons> weird. i don't know what would do this.
21:56:22 <thou> k
21:56:31 <thou> no biggie for me at the moment, more of a curiosity
21:56:40 <thou> ghc compiled from freebsd ports tree
21:57:06 <dons> sure. but bsd is no problem. i use openbsd.
21:58:24 <palomer> just saw house of the flying daggers
21:58:27 <palomer> beautiful story
21:59:32 <thou> dons: does it use ghc-pkg to know where to look?
22:00:51 <dons> lambdabot just takes a list of -package foo set in config.mk
22:00:54 <dons> ghc then does the rest
22:01:01 <thou> ok
22:01:02 <palomer> so a class is a set of functions, and an instance of a class are types within those functions, right?
22:01:34 <thou> palomer: an instance is a type that has those functions implemented for it
22:02:41 <palomer> oh, righto
22:03:01 <palomer> so what's the deal with the monad class?
22:03:10 <palomer> why is it special?
22:03:10 <thou> it's just handy
22:03:25 <thou> haskell has some sugar that makes working with monads easy
22:03:32 <thou> the do syntax
22:04:00 <dons> thou, you should stick yourself on the map:
22:04:01 <dons> @map
22:04:01 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
22:04:02 <dons> :D
22:04:24 <thou> palomer: so if you add an instance declaration for your type, you can use the do syntax with it
22:04:41 <thou> dons: i'm only here until the end of december
22:04:56 <dons> ok :)
22:05:05 <thou> dons: can lambdabot remind me to move myself on that map in january?
22:05:08 <thou> :)
22:05:25 <dons> not yet, but if you write a plugin....
22:05:29 <palomer> thou: that sounds evil
22:05:50 <thou> palomer: maybe "wicked", but not evil!
22:05:57 <palomer> what are the instances of monad?
22:06:09 <dons> hmm. could be good for an obfuscation contest.
22:06:13 <thou> palomer: there's tons
22:06:21 <palomer> the best known instance
22:06:27 <thou> palomer: common ones are List, Maybe, Either
22:06:32 <thou> IO, of course
22:06:47 <stepcut> maybe I should hook up my GPS receiver and dynamically update my location ... too bad it takes 20 mins to generate the damn image ;)
22:07:05 <dons> oh, it's only 3 mins now.
22:07:10 <palomer> if we removed monads from haskell completely
22:07:13 <dons> i parallelised it overr a cluster :)
22:07:14 <palomer> in another world
22:07:20 <palomer> but we kept type classes
22:07:25 <thou> yeah
22:07:27 <palomer> could we still do exactly the same stuff?
22:07:46 <thou> um ...
22:07:56 <Cale> palomer: you could just add the Monad class again
22:08:02 <dons> well you could get rid of type classes too, and fake them by packing up your own dictoinaries
22:08:04 <Cale> there's nothing special about it
22:08:24 <Cale> the only special support for monads is the do-notation
22:08:38 <thou> palomer: if you said "you're not allowed to write a function called called "bind" or "return"
22:08:51 <thou> palomer: then we might not be able to do some things :-)
22:09:11 <thou> palomer: old haskell didn't use monadic I/O, for example
22:09:33 <palomer> but how would we have sequential evaluation?
22:10:07 <dons> let x = one in y = two x in z  ...
22:10:22 <palomer> oh, righto
22:10:35 <dons> we just thread the state by hand, old skool style
22:10:39 <thou> (third_action (second_action (first_action)))
22:10:51 <Cale> you'd probably just reinvent the monad
22:11:17 <Cale> monads aren't a language feature, they're a (mathematical) concept
22:11:32 <palomer> thou: I thought haskell was left redex first
22:11:48 <dons> yeah, you'd invent some 'andThen' (bind) and you'd be back in monads again
22:11:52 <palomer> so, really, the big thing in haskell is type classes
22:12:06 <palomer> monads aren't really a "feature" of haskell
22:12:11 <thou> palomer: yes, and lazy evaluation
22:12:15 <thou> right
22:12:22 <thou> monadic i/o is a feature
22:12:32 <thou> i.e., that's how haskell has chosen to implement i/o
22:12:34 <palomer> which is done by implementing haskell functions in C?
22:12:56 <thou> not necessarily
22:13:02 <Cale> not necessarily in C, but in whatever the target language is
22:13:06 <palomer> yeah
22:13:16 <palomer> and then making the IO type an instance of Monad
22:13:24 <palomer> my god, why can't you people present this stuff right off the bat!
22:13:33 <Cale> hm?
22:13:39 <Cale> what do you mean?
22:13:51 <palomer> for example
22:13:59 <palomer> the YAHT starts off by saying
22:14:04 <palomer> "the hardest topic is monads"
22:14:12 <stefanw> dons: just added basic QC support to HTF
22:14:19 <palomer> and then mystefies us with 2 pages of goop
22:14:20 <dons> palomer: yeah, who wrote that?? what where they high on :p
22:14:22 <thou> palomer: i would just forget about monads
22:14:29 <dons> stefanw! cool.
22:14:52 <palomer> and, erm, why is haskell IO said to be slow?
22:15:00 <Cale> Monads are relatively easy to learn about if you actually try using them.
22:15:06 <thou> palomer: because strings are just lists of chars
22:15:18 <palomer> oh
22:15:21 <Cale> It is often pretty slow
22:15:23 <thou> palomer: it's not slow if you use the packed strings and stuff
22:15:24 <palomer> why did we decide to do things this way?
22:15:27 <dons> because of [Char]. Use a different type and things are happy.
22:15:38 <Cale> Lists are very convenient
22:15:41 <thou> palomer: it's very flexible
22:15:43 <dons> reasoning. [Char] has very nice properties
22:15:48 <thou> palomer: most of the time, it's plenty fast
22:15:57 <dons> convenne, flexibility, reasoning :)
22:15:59 <palomer> so everytime I implement a function on lists, I have a function on strings too?
22:16:00 <thou> palomer: in the few instances where speed of i/o matters, there's options available
22:16:06 <thou> palomer: yes
22:16:09 <palomer> oh, string = [Char]
22:16:13 <thou> yep
22:16:19 <thou> and char is unicode
22:16:22 <palomer> yeah, I could see that sucking
22:16:34 <palomer> and for these options, does it compare in speed with C?
22:16:39 <dons> nh, it hardly ever matters.
22:16:40 <thou> yeah
22:16:53 <dons> yeah, pretty easy to get close to C or better if you ditch [Char]
22:16:58 <thou> palomer: especially since one of "these options" *is* C
22:17:03 <thou> hehe
22:17:10 <palomer> right, functions implemented in C
22:17:36 <thou> palomer: but aside from that, there are packed string interfaces, block i/o functions
22:17:39 <palomer> and we can't do static analysis to figure out when we need to use [Char] and when we don't?
22:18:23 <thou> palomer: i'm not a compiler expert...  but i guess there's lots of work involved in that
22:18:28 <dons> well, packed strings are strict, which breaks laziness. so you have to be careful.
22:18:29 <thou> palomer: for little gain
22:18:48 <dons> often your strings to get unboxed anyway
22:19:01 <palomer> dons: yeah, but then we have static analysis for laziness:P
22:19:03 <dons> i.e. pakcked.
22:19:15 <Cale> Sometimes you really want lazy [Char] for efficiency.
22:19:35 <palomer> of course!
22:19:41 <palomer> but I think it should be the compilers job to figure it out
22:19:51 <Cale> possibly
22:20:09 <Cale> that's a fairly hard problem to solve
22:20:22 <Cale> especially if you want compiling not to take ages
22:20:33 <palomer> rather, it's a rather hard problem to state
22:21:02 <palomer> (exactly when can we forego laziness?)
22:21:07 <Cale> if you don't mind waiting a week for your executable, you could design a language such that lots of implementation details get dealt with by the compiler
22:21:33 <palomer> Cale: I wouldn't mind, as long as I could turn the optimizations off
22:21:40 <palomer> I mean, how many times am I going to actually release?
22:22:21 <palomer> and anyways, you can always use approximate solutions and forget about the really hard cases
22:22:23 <Korollary> You can use the strictness annotations, seq, etc.
22:23:49 <thou> palomer: i can see your point, i just think it's probably a tough problem to implement
22:24:11 <thou> in a general enough way so it would be useful
22:24:23 <Cale> Haskell still doesn't completely free the programmer from thinking about time and memory
22:24:29 <palomer> once you have your equations set up, it's easy (though maybe time consuming)
22:24:40 <stepcut> but it does free them from thinking about girls and money
22:24:47 <palomer> it's helped us forget about time a little
22:24:48 <Cale> haha
22:24:51 * Korollary kills stepcut
22:25:15 * stepcut should perhaps go to bed
22:25:58 <palomer> so if we remove the special syntax associated with monads from haskell
22:26:17 <palomer> I would have to do let a = getIo() in let b = getIo() in ...          ?
22:26:25 <thou> you'd do this:
22:26:37 <thou> action1 >>= \res ->
22:26:41 <thou> actio2
22:26:54 <Cale> you'd do something like getLine >>= \x -> putStrLn ("Hello " ++ x ++ "!")
22:27:02 <palomer> thou: res is the continuation?
22:27:12 <thou> palomer: sorry, bad example
22:27:22 <palomer> ah, I see what >>= does now!
22:27:27 <thou> palomer: yes, change 2nd line to:  action2 res
22:27:39 <palomer> and if we didn't have >>=?
22:27:46 <stepcut> http://www.cs.mu.oz.au/~dmo/se-litreview/node2.html
22:27:48 <thou> you'd write it yourself
22:27:58 <Cale> >>= is nothing special
22:27:59 <thou> or hire someone else to write it for you
22:28:06 <Cale> it is in the case of IO, a little
22:28:21 <palomer> let's you can only use getLine and let?
22:28:44 <Cale> palomer: what's the type of main in your Haskell-variant?
22:29:09 <palomer> Unit -> int
22:29:21 <Cale> then you can never do any IO
22:29:25 <ski> not referentially transparent
22:29:33 <stepcut> (that link I pasted gives an overview of the different ways to do IO in haskell-like languages)
22:29:36 <ski> palomer : you'd need some way of combining two IO-actions
22:30:18 <palomer> ski: can't that be done with let a = something in let b = something ...
22:30:25 <ski> palomer : '(<*>) :: IO a -> IO b -> IO (a,b)' would work for that
22:30:38 <ski> palomer : not with standard 'let'
22:31:01 <Cale> palomer: Unit -> Int implies that it's always going to return the same Int
22:31:16 <palomer> (what's the type of main?)
22:31:18 <palomer> @t main
22:31:19 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
22:31:19 <lambdabot> null topic-snoc topic-tail topic-tell type pl wn
22:31:22 <palomer> @type main
22:31:23 <lambdabot> Not in scope: `main'
22:31:28 <Cale> main :: IO a
22:31:38 <Cale> well, for some a
22:32:03 <Cale> (the return value is ignored)
22:32:16 <palomer> and these functions for combining IO actions are written in some other target language?
22:32:25 * ski almost always does  main :: IO ()
22:32:35 * Korollary ditto
22:32:36 <palomer> that's what bothers me: how would I combine actions if I didn't have monads?
22:32:55 <ski> these functions for combining IO-actions are provided by the implementation
22:33:02 <Cale> palomer: Well, if you weren't going to have a monadic IO system, then you'd use something else
22:33:16 <ski> palomer : what does 'if I didn't have monads?' mean ?
22:33:22 <palomer> so there IS something special about monads
22:33:24 <Cale> You always have monads
22:33:25 <stepcut> palomer: in clean they do, let (a, world') = getChar world in let (b, world'') = getChar world' in (a,b)
22:33:30 <ski> monads are an abstract concept
22:33:33 <Cale> you might not have monadic IO
22:33:43 <palomer> stepcut: that's what I proposed before
22:33:46 <palomer> but it was shot down!
22:33:54 <palomer> oh, forgot about the world
22:33:57 <stepcut> palomer: yeah
22:34:05 <ski> the world is important !
22:34:10 <stepcut> palomer: and you can only use each world once or you will get wacky results
22:34:23 <palomer> the world'' is bound but never used, why even bind it?
22:34:34 <ski> it *is* used
22:34:44 <ski> (it must be)
22:34:48 <palomer> where is it used?
22:34:56 <stepcut> palomer: world'' could be _ in that case
22:35:11 <ski> Start :: *World -> *World
22:35:20 <stepcut> palomer: in clean, they use uniqueness type checking to enforce that each copy for world is used at most once
22:35:24 <ski> 'Start' in Clean corresponds to 'main' in haskell
22:35:44 <stepcut> once again, this page describes the various ways of doing IO with and with out monads, http://www.cs.mu.oz.au/~dmo/se-litreview/node2.html
22:35:48 <thou> palomer: i guess the implementation would use the final world'''' value when it shuts down
22:35:57 <ski> 'Start' must return a world, so you can't get an executable, if you somewhere try to ignore (or copy) a world
22:36:07 <palomer> thou: but it will be out of scope by that time!
22:36:14 <thou> no
22:36:46 <stepcut> ski: true, I forget that you have to return the final world from your start function
22:36:53 <thou> i'm assuming it's magic in some way
22:36:58 <ski> Start world = let (a, world') = getChar world in let (b, world'') = getChar world' in putChar a (putChar b world'')
22:36:58 <tomaszz> hello
22:37:14 <Cale> palomer: there's nothing special about the idea of monads, but Haskell has decided to implement IO monadically. You could also use another abstract representation of IO actions and provide a different set of combinators, but you'd hope that return and bind would be implementable in terms of whatever you came up with.
22:37:17 <palomer> ski: ahh, that makes more sense
22:37:20 <tomaszz> anybody knows why I can't login into haskelldb CVS?
22:37:31 <stepcut> tomaszz: I can't either
22:37:33 <ski> or, if you want
22:37:34 <palomer> is the List monad completely implemented in haskell?
22:37:38 <tomaszz> I just follow the instructions from haskelldb site
22:37:38 <Cale> yes
22:37:43 <tomaszz> stepcut: :-(
22:37:45 <Cale> return x = [x]
22:37:53 <palomer> Cale: how do you get the sequential evaluation?
22:37:53 <Cale> x >>= f = concatMap f x
22:37:59 <stepcut> tomaszz: yes, I think it died or something -- I should probably have emailed bringert or something :-/
22:38:00 <Cale> that's it
22:38:05 <tomaszz> stepcut: maybe you have a version of haskelldb that compiles in GHC 6.4 ?
22:38:08 <palomer> with concatMap?
22:38:12 <Cale> yep
22:38:19 <ski> Start world0 = let (a, world1) = getChar world0 in let (b, world2) = getChar world1 in let ((),world3) = putChar b world2 in let ((),world4) = putChar b world3 in world4
22:38:22 <palomer> does concatMap call a non haskell function anywhere along the way?
22:38:23 <Cale> or  x >>= f = concat (map f x)
22:38:26 <Cale> no
22:38:30 <ski> (if you want a closer correspondance with monads)
22:38:40 <Cale> concat and map are perfectly implementable as recursive functions
22:38:51 <Cale> palomer: have you read my monad tutorial?
22:38:58 <palomer> Cale: nope, not yet
22:39:05 <stepcut> tomaszz: I have a version I compiled with ghc 6.4.1 -- twas a great pain in the ass too
22:39:05 <palomer> I just got introduced to the idea in YAHT
22:39:13 <Cale> http://haskell.org/hawiki/MonadsAsContainers
22:39:21 <tomaszz> stepcut: so you had to make some changes?
22:39:21 <Cale> read that :)
22:39:30 <thou> palomer: if you're trying to just learn haskell, then forget monads
22:39:49 <palomer> thou: but I already know sml quite well
22:39:56 <stepcut> tomaszz: I believe so ... I tried to do a cvs diff to see what I changed, and that is why I realized it was down ;)
22:40:00 <Cale> I think that monads are a useful programming technique
22:40:05 <thou> palomer: ok.
22:40:14 <thou> Cale: i do too but they can be a hang-up
22:40:28 <palomer> thou: so, like, the other stuff is quite easy (even identical)
22:40:29 <stepcut> tomaszz: but, in part, it now has a bunch of different cabal pieces you have to install, and not much in terms of directions
22:40:35 <thou> palomer: ok
22:40:50 <tomaszz> stepcut: so you don't recommend it?
22:40:51 <thou> palomer: except for lazy eval.  well, you have that too, if you choose...
22:40:52 <Cale> I think they're only a hang-up when people explain them in terms of computation. That view is a heck of a lot harder to get started with.
22:41:09 <palomer> Cale: container==class in your tutorial?
22:41:17 <Cale> container = functor
22:41:18 <thou> palomer: no
22:41:29 <stepcut> tomaszz: depends on what your goals are and how persistant you are
22:41:30 <palomer> and functor is a specific class
22:41:33 <Cale> yeah
22:41:47 <ski> class Functor f where fmap :: (a -> b) -> (f a -> f b)
22:41:48 <palomer> isn't functor the class of iterable types?
22:41:49 <stepcut> tomaszz: but, haskelldb is currently not a highly polished library, unfortunately
22:41:59 <palomer> what's the difference between map and fmap?
22:42:05 <ski> palomer : it's the class of 'map'able types
22:42:10 <Cale> map only works on lists
22:42:17 <palomer> why did they decide to do that?
22:42:17 <ski> map works for lists, fmap for any container/functor
22:42:18 <palomer> efficiency?
22:42:21 <tomaszz> stepcut: OK, for now I'll try to work with what I have.
22:42:28 <Cale> palomer: to help newbies
22:42:44 <Cale> but I don't like the decision
22:42:55 <stepcut> tomaszz: haskelldb has a number of landmines in it -- for example, it has serious issues if you use the same column name in more than one table
22:42:55 <Cale> I think it's easy enough to explain what a functor is
22:42:57 <tomaszz> stepcut: I'm going to test your optimizer now :-)
22:43:01 <palomer> something else: a -> m a <--this says that a is a monad
22:43:06 <Cale> no
22:43:10 <Cale> m is the monad
22:43:16 <ski> palomer : do you feel helped by 'map' being separate from 'fmap' ?
22:43:32 <palomer> Cale: that a is an instance of Monad?
22:43:38 <thou> Cale: and one can only be a newbie for so long ... eventually you have to know what fmap does and what a Functor is.  and then you think, "how come 'map' doesn't just do the trick"
22:43:38 <palomer> ski: err, no
22:43:39 <Cale> m is the instance of Monad
22:43:41 <stepcut> tomaszz: and without that optimizer it *requires* sub-queries when a simple join would do just fine :)
22:43:49 <palomer> so what's a?
22:43:53 <ski> any type
22:43:54 <Cale> the contained type
22:43:57 <palomer> m is parameterized by a?
22:44:00 <Cale> yeah
22:44:07 <Cale> so if m = [], then m a = [a]
22:44:21 <Cale> if m = Maybe, then m a = Maybe a
22:44:35 <tomaszz> stepcut: exactly, and that's why I can't simply join two tables on our productions server, which doesn't support subqueries
22:44:51 <palomer> oh my, I think I'm starting to get it
22:45:36 <palomer> fmap :: (Functor f) => (a -> b) -> f a -> f b <--why must the container be parametized?
22:45:51 <ski> otherwise we can't map freely
22:46:05 <Cale> well, what would one do otherwise?
22:46:13 <palomer> but, like, I could have data IntList = Nil | Cons int IntList
22:46:15 <thou> palomer: Functor is the class
22:46:18 <Cale> how would you ever know how to apply your function?
22:46:22 <ski> we can't change the contained type from 'a' to 'b' if the container type wasn't parameterized
22:46:31 <thou> palomer: you'd then make IntList an instance of Functor
22:46:35 <palomer> right
22:46:38 <stepcut> tomaszz: yeah -- there is another haskelldb like library based on HList that I have been meaning to investigate more -- I think it has a more solid foundation, but it only supports odbc and has some other tight dependencies that need to be dealt with
22:46:42 <palomer> but it's not parameterized!
22:46:48 <ski> IntList can't be an instance of Functor
22:46:53 <ski> since it's not parameterized
22:47:06 <palomer> that sucks
22:47:17 <ski> to be a functor, we should be able to do  fmap show :: f Int -> f String
22:47:17 <Cale> Well, it's just not a functor
22:47:18 <palomer> or what if my data structure is parameterized by 2 types?
22:47:35 <Cale> A functor is kind of a function from types to types
22:47:41 * stepcut goes off to watch a video
22:47:47 <thou> g'night, stepcut
22:47:48 <ski> palomer : that's a bifunctor :)
22:47:54 <palomer> night stepcut
22:48:01 <Cale> which also acts on functions
22:48:07 <Cale> via fmap
22:48:24 <Cale> you could read the type of fmap as (a -> b) -> (f a -> f b)
22:48:35 <Cale> (parens for emphasis)
22:48:37 <palomer> hrm, I think as functor as the class of types which are mapable, and IntList is clearly mapable
22:48:42 <Cale> no it's not
22:48:54 <Cale> IntList isn't mappable at all
22:49:02 <palomer> it's a list of ints!
22:49:06 <ski> palomer : you can't change the type of the elements in IntList by mapping
22:49:14 <Cale> right, but if I have a function Int -> Char
22:49:20 <Cale> then what do I do?
22:49:20 <Korollary> palomer: it's not a list. It's an arbitrary recursive datatype.
22:49:24 <ski> you should e.g. be able to map  show :: Int -> String
22:49:27 <palomer> oh, very good point
22:49:37 <palomer> okok, you win
22:49:55 <thou> dons: should i see -package fps in the 'make' output anywhere?
22:49:56 <palomer> what if I wanted to do data D a b = Nil | Cons a b (D a b)
22:50:11 <palomer> (in which case I would have to pass 2 functions to fmap)
22:50:15 <ski> then, (D a) is a Functor
22:50:25 <ski> and D is a Bifunctor
22:50:33 <palomer> is Bifunctor defined?
22:50:40 <Cale> not in the standard libraries
22:50:43 <Cale> but you could define it
22:50:46 <ski> easy to do
22:50:53 <palomer> damnit, haskell needs dependent types for these kinds of situations
22:51:17 <Cale> I don't know if fully dependent types are required
22:51:27 <ski> class Bifunctor f
22:51:27 <ski>   where
22:51:27 <ski>   bimap :: (a0 -> b0) -> (a1 -> b1) -> (f a0 b0 -> f a1 b1)
22:51:40 <ski> dependent types are not needed
22:51:51 <palomer> for general arity functors?
22:51:53 <Cale> ski: how about n-functors?
22:52:05 <ski> that's another thing
22:52:43 <Cale> maybe some cheating with fundeps would work, hmm...
22:52:54 <ski> i think it isn't doable, since we don't have "kind classes" :)
22:53:09 <Cale> ah right
22:53:21 <ski> maybe one could do it with fundeps, but i doubt
22:53:42 <palomer> could we have (D * b) as a functor?
22:53:45 <Cale> it's hard to see how you can extend the kinds involved
22:53:56 <Cale> palomer: it would be nice, but not at the moment
22:54:37 <palomer> type classes resemble sml higher order modules
22:54:39 <Cale>  /\a -> D a b
22:54:42 <palomer> very, very much
22:54:56 <ski> palomer : yes, to some degree, they do
22:54:59 <palomer> class = signature
22:55:22 <palomer> instance = structure
22:55:47 <ski> except type classes has at most one instance for a give type (combination), while there may be many structures implementing a given signature
22:55:50 <palomer> actually, instance = functor
22:55:56 <ski> no
22:56:04 <dons> palomer, in fact there's equivalent given associated types on the haskell side.
22:56:06 <ski> instance here corresponds to structure
22:56:11 <dons> stefanw did his thesis on this.
22:56:47 <dons> not sure if it's online yet.
22:56:54 <Cale> > [10,20,30] >>= \x -> [x,x+1]
22:56:55 <lambdabot> [10,11,20,21,30,31]
22:57:17 <palomer> ski: I didn't catch that "except type classes" bit
22:57:32 <ski> palomer : instances are not named
22:57:42 <palomer> in haskell, you mean
22:57:48 <ski> right
22:58:00 <ski> you can have at most one 'instance Ord String'
22:58:26 <palomer> so we could implement monads in sml with their module system
22:58:27 <palomer> oh my.
22:58:28 <ski> as opposed to, in ML, one can have many structures implementing an ordering signature for strings
22:58:43 <ski> yes, monads have been done some in SML
22:58:56 <palomer> ski: each structure is associated with an instances, I thought
22:58:58 <ski> Felleisen has done cool stuff with reifying and reflecting monads
22:59:18 <ski> (in SML, i mean)
22:59:40 <palomer> each class(signature) has many instances(structures), I see no difference
23:00:55 <ski> functor MakeSet (struct type t; val compare : t * t -> ordering end) = struct ... end;
23:01:35 <palomer> sure
23:01:41 <ski> structure CaseSensitiveStringOrdering = struct ... end;
23:01:49 <ski> structure CaseInsensitiveStringOrdering = struct ... end;
23:01:57 <ski> we can have both in SML
23:02:07 <ski> in haskell we can't only have at most *one*
23:02:14 <ski> instance Ord String where ...
23:02:42 <palomer> oh, I see
23:02:46 <ski> this is because structures are explicitely named in ML, and instances are not explicitely named in haskell
23:02:52 <palomer> but you're associating the structure with the underlying type
23:02:57 <ski> yes
23:02:59 <palomer> (which is something that I tend to do as a programmer)
23:03:17 <palomer> what do functors correspond to in haskell?
23:03:46 <ski> they don't fully
23:04:04 <palomer> and does haskell have parameterized signatures?
23:04:10 <ski> functors give abstract (unless otherwise specified) types in the produced structure
23:04:26 <ski> palomer : sadly, no
23:04:43 <palomer> humph!
23:04:50 <palomer> any plans?
23:04:57 <ski> ML's module system is more powerful than haskell's module system (but type classes make up for at least some of this)
23:05:20 <palomer> I see type classes as better syntax for signatures/structures
23:05:53 <Cale> Typeclasses in Haskell can have multiple type parameters -- one way to think of them is as type predicates, where if the predicate holds, extra functionality is present.
23:05:58 <palomer> ski: I thought we agreed that type classes are at most as powerful as what's provided with the sml module system
23:06:04 <ski> type classes and instances (at least in current form) can't be used in all circumstances that signatures and structures can, i think
23:06:45 <palomer> Cale: eh? is this an advanced feature?
23:06:47 <ski> the abstractness of types generated by functors in ML can be simulated by existential types
23:07:12 <Cale> It was one of the first extensions to the typeclass system
23:07:15 <palomer> which haskell doesn't have
23:07:38 <ski> palomer : it's a common extension
23:07:39 <Cale> GHC-Haskell and Hugs-Haskell have multiparameter typeclasses
23:07:52 <Cale> NHC too, I think
23:07:52 <palomer> existential types is a common extension?
23:07:56 <ski> yes
23:08:07 <Cale> also functional dependencies
23:08:11 <ski> yes
23:08:39 <Cale> GADTs are new, but I hope they'll become the standard way to declare data types :)
23:08:57 <palomer> yeah, I read about GADTs
23:09:14 <ski> they supercede existential types
23:09:18 <palomer> parametized types correspond to what in second order logic?
23:09:36 <ski> second order predicates
23:09:39 <palomer> ski: has there ever been a time where you wished for the sml module system?
23:10:02 <palomer> ski: second order logic doesn't have second order predicates:o
23:10:23 <palomer> it just lets you quantify first order predicates
23:10:38 <ski> palomer : yes .. sometimes i've e.g. wanted to have a module-scope type-variable .. to avoid repeating it all over the place (thinking of 's' for the ST monad)
23:11:04 * ski thinks again
23:11:34 <palomer> and, quite frankly, I don't see how second order predicates could be useful
23:12:01 <ski> forall P. ...P...
23:12:04 <palomer> yeah
23:12:13 <palomer> P is a first order predicate
23:12:20 <ski> assume  P : o  (i.e. P is a nullary predicate)
23:13:19 <ski> then, assume '...P...' doesn't actually use P .. in fact let's assume '...P...' is 'o'
23:13:25 <ski> then we get
23:13:30 <ski> forall P : o. o
23:13:36 <ski> which is same as
23:13:39 <ski> o => o
23:13:44 <ski> or, in haskell syntax
23:13:45 <ski> * -> *
23:13:48 <ski> @kind Maybe
23:13:49 <lambdabot> * -> *
23:14:06 <palomer> o = F?
23:14:15 <ski> 'o' is the kind of propositions/types
23:14:33 <palomer> '...P..." is 'o' <--what does this mean?
23:14:58 <palomer> and o. o?
23:15:10 <ski> it means : let's assume the not further specified expression '...P...
23:15:19 <ski> ' actually was the expression 'o'
23:15:32 <ski> forall (P : o). o
23:15:34 <ski> if you want
23:15:50 <ski> forall propositions P. o is true
23:16:22 * ski is here moving on border of type theory and logic
23:16:48 <palomer> ok, so we have forall P. o , o is a formula, and forall P. o is true
23:17:15 <ski> yah
23:17:19 <palomer> unless you were quantifying over predicates?
23:17:24 <ski> i was
23:17:28 <palomer> oh my.
23:17:37 <palomer> ok, so P is of type o
23:17:44 <ski> only, it was mostly vacuous quantification
23:17:46 <ski> yes
23:17:49 <palomer> and we're looking at forall P. some formula of type o
23:18:02 <ski> no
23:18:09 <ski> 'forall P. o'
23:18:21 <ski> the formula i quantified over *is* 'o'
23:18:22 <palomer> o takes a predicate, no?
23:18:42 <palomer> I thought we assumed o to be a 1-ary second order predicate
23:18:49 <ski> nono
23:18:51 <ski> sorry
23:19:17 <ski> 'o' is the kind (or type, if you will) of propositions, which is the same as nullary predicates
23:19:31 <palomer> ok, o is a set of propositions
23:19:38 <palomer> a 0-ary second order predicate
23:19:54 <palomer> so you're proposition is:
23:19:58 <ski> A : o
23:20:03 <ski> means A is a proposition
23:20:21 <ski> P : Natural -> o
23:20:24 <palomer> a special proposition
23:20:41 <ski> means P is a (1-ary) predicate over naturals
23:21:04 <ski> Q : (P -> Naturals) -> o
23:21:07 <palomer> oh my, you are mixing type theory and logic
23:21:22 <palomer> is  o a set of propositions?
23:21:27 <ski> means P is a second order (1-ary) predicate, over first order predicates over naturals
23:21:42 <palomer> oh, you're using HOL notation
23:21:44 <palomer> ugh.
23:21:45 <ski> palomer : yes, i'm mixing type theory and logic :)
23:22:00 <ski> hm, sorry i wrote wrong
23:22:08 <ski> Q : (Naturals -> o) -> o
23:22:13 <ski> was what i meant
23:22:24 <ski> <ski> means P is a second order (1-ary) predicate, over first order predicates over naturals
23:22:28 <ski> (was correct, though)
23:22:54 <palomer> in HOL notation, P : Natural -> bool <--this would be a unary predicate (I believe)
23:23:06 <ski> yes
23:23:10 <palomer> so o = bool?
23:23:16 <ski> 'bool' there corresponds to my 'o'
23:23:24 <palomer> ok, fair is fair
23:23:40 <palomer> (though I suggest you look into Krivine and Girard's work, much cleaner)
23:23:58 <ski> now, if we have lambda, we can express qunatification like this
23:24:06 <ski> Pi : (A -> o) -> o
23:24:26 <ski> Pi (\a. ...a...)   means the same as   forall a : A.  ...a...
23:24:29 <ski> etc
23:24:32 <palomer> right, dependent types
23:24:38 <palomer> quantifying over predicates
23:24:49 <palomer> but now you're mixing a whole bunch of stuff!
23:25:11 <ski> i haven't introduced dependent types, yet :)
23:25:28 <palomer> Pi quantifies predicates
23:25:48 <ski> Curry or Church did stuff on this, iirc
23:25:52 <palomer> ie, the predicate depends on how you instantiated the variables of Pi
23:25:59 <palomer> ie, dependent types
23:26:14 <ski> dependent logic, yes
23:26:41 <palomer> wait, are you using o because that's what they use when talking about CPSification?
23:26:43 <ski> but we don't get dependent types until we can use this in types, too
23:26:47 <ski> no
23:26:55 <palomer> then why are you using o?
23:26:59 <ski> i've just seen some people using 'o'
23:27:04 <palomer> instead of bool?
23:27:09 <ski> 'o' in CPS is another tradition
23:27:24 <ski> 'bool' could be misleading if e.g. the logic isn't boolean
23:27:44 <palomer> erm, if we're talking about second order logic, then the logic IS boolean
23:27:51 <ski> depends :)
23:27:59 <ski> second order *classical* logic ?
23:28:05 <ski> or intuitionistic ?
23:28:08 <ski> or linear ?
23:28:10 <ski> etc
23:28:17 <palomer> intuitionistic doesn't have any models
23:28:34 <palomer> (well, any good models in which to intepret the formulae)
23:28:38 <palomer> (model theory models)
23:28:50 * ski doesn't know much about model theory
23:28:59 <palomer> model theory is the basis of all this stuff!
23:29:21 <palomer> ok, so Pi is a quantifier, quantifying over predicates, right?
23:29:22 <ski> hm, isn't topoi (amongst other things) about having models for intuitionistic logics ?
23:29:37 <ski> Pi is a replacement for a quantifier
23:29:46 <ski> it's a second order predicate
23:29:59 <palomer> when people say "models of intuitionistic logic" they mean categories, which is pretty weak stuff IMHO
23:30:14 <palomer> is it a predicate or a quantifier?
23:30:20 <ski> Pi is not a quantifier itself, since it doesn't quantify any varaible (lambda does, however)
23:30:38 <ski> predicate
23:30:44 <palomer> ack! don't put lambdas in your types!
23:30:47 <ski> if F :
23:30:52 <ski> i haven't !
23:31:00 <ski> if F : Natural -> o
23:31:16 <ski> then  Pi F   is a perfectly well-formed formula
23:31:27 <palomer> what does it represent?
23:31:41 <palomer> oh, I see, Pi is a second order predicate
23:31:45 <palomer> why not just say so:o
23:31:46 <ski> the proposition that F holds for all naturals
23:31:49 <palomer> oh, you did
23:31:50 <palomer> :P
23:32:01 <ski> right :)
23:32:04 <palomer> right
23:32:39 <palomer> so, err, is this going anywhere?
23:32:50 <ski> you have to remember that i haven't read much of this formally, so take what i say with a grain of salt, ok ?
23:32:54 <ski> i don't know
23:33:01 * ski forgot where we were going
23:33:05 <palomer> I don't like this -> o notation
23:33:12 <ski> why not ?
23:33:24 <ski> do you like '-> bool' better ?
23:33:29 <palomer> neither
23:33:36 <ski> then, what ?
23:33:43 <palomer> why not just forgo -> and go into higher order quantifiers
23:34:00 <ski> you mean dependent stuff ?
23:34:14 <palomer> let Z be the function quantifier
23:34:16 <ski> example ?
23:34:25 <palomer> actually, even better
23:34:30 <ski> 'function quantifier' being ?
23:34:34 <palomer> the set of all functions on the integers is:
23:34:49 <palomer> forall A. forall x. N[x]-> A
23:35:03 <palomer> (where N is the induction formula)
23:35:11 <palomer> (too lazy to write it out)
23:35:17 <palomer> there, no more o!
23:35:37 <ski> hm
23:35:49 <ski> what is A ?  a proposition, i guess
23:35:58 <palomer> A is a predicate
23:36:01 <palomer> it's quantified by the forall
23:36:03 <ski> what is x ?  a natural number ?
23:36:19 <ski> ?-ary predicate
23:36:23 <ski> 0-ary ?
23:36:25 <palomer> 0-ary predicate
23:36:28 <ski> ok
23:36:32 <ski> and x ?
23:36:32 <palomer> x is a variable that's also quantified
23:36:37 <palomer> everything in that formula is quantified
23:36:39 <ski> yes
23:36:45 <ski> (except N)
23:36:58 <palomer> N[x] = forall X (X0 -> forall y( Xy -> Xsy) -> Xx)
23:37:02 <palomer> ok, fine, the only thing not bound is s
23:37:05 <gour> dcoutts: good morning
23:37:10 <ski> and 0
23:37:13 <palomer> and 0
23:37:19 <ski> :)
23:37:35 <ski> forall A. forall x. (forall X (X0 -> forall y( Xy -> Xsy) -> Xx)) -> A
23:37:37 <ski> ?
23:37:46 <palomer> yup
23:38:14 <palomer> if a function  has an integer argument, that's a type it will satisfy
23:38:29 <palomer> you can do a similar thing for all inductively constructed types
23:38:49 <palomer> and you can also do something like this for co inductively constructed types (you have to enlarge your logic slightly)
23:38:58 <ski> hm, still thinking about that formula
23:39:11 <ski> .. i don't like that A is only mentioned once .. seems bad
23:39:33 <palomer> it's an easy proof to see that t: N[s(s(s(0)))] => t = church numeral of 3
23:39:55 <palomer> ski: you can instantiate A to whatever you want
23:40:43 <ski> 'forall A. forall x. N[x]-> A' seems to say, that for whichever A i want, if N[x] is true for all x, then A is true
23:40:56 <ski> (did i understand your scoping properly ?)
23:41:00 <palomer> yes
23:41:23 <palomer> the type is not habitated, of course
23:41:32 <palomer> but if you instantiate A, it is
23:41:43 <palomer> (specialize, whatever you want to call it)
23:42:22 <ski> to my mind, there seems to be something wrong in that formula (or i'm not understanding your point)
23:42:43 <palomer> my point was that you don't need o (or any free predicates)
23:42:54 <ski> i see 'o' there :)
23:42:59 <palomer> where?
23:43:01 <ski> (just not explicit)
23:43:12 <ski> but i want to make sense of the formula, first
23:43:23 <palomer> ok
23:43:30 <palomer> here's an example:
23:43:45 <ski> you want a type that expresses the naturals, right ?
23:43:45 <palomer> successor:: forall x. N[x] -> N[s(x)]
23:44:00 <palomer> N[x] expresses the naturals
23:44:28 <ski> yes, that seems to be a fold over naturals
23:44:41 <palomer> fold?
23:44:50 <ski> (or catamorphism or however you want to call it)
23:45:48 <ski> in haskell   foldNat :: forall r. Nat -> r -> (r -> r) -> r
23:45:48 <palomer> you could also have addition: forall x. N[x] -> N[y] -> N[x+y]
23:46:23 <palomer> ski: yeah, that's because haskell doesn't have dependent types
23:46:46 <ski> with dependent types   cataNat :: Nat -> (forall p. p Zero -> (forall y. p y -> p (Succ y)) -> forall x. p x)
23:46:48 <palomer> foldNat f = foldr 0 f [1..] ?
23:47:07 <ski> not a list fold, a natural-number fold
23:47:25 <palomer> hmm?
23:47:37 <ski> foldr in haskell is a list-fold
23:48:02 <palomer> show me an example of foldNat
23:48:38 <palomer> ski: the return of cataNat is N[x]
23:49:03 <ski> (\n -> foldNat n "#" (\x -> x ++ x)) :: Nat -> String
23:49:35 <ski> is the function, that given a natural number n, gives a string which consists of 2^n '#' signs
23:49:39 <gour> dcoutts_: good morning
23:49:56 <ski> palomer : i know :)
23:50:29 <palomer> oh, I see
23:50:44 <ski> take
23:50:45 <ski> forall p. p Zero -> (forall y. p y -> p (Succ y)) -> forall x. p x
23:50:45 <palomer> that IS foldNat
23:50:53 <ski> this is short for
23:51:08 <ski> forall p :: Nat -> *. p Zero -> (forall y :: Nat. p y -> p (Succ y)) -> forall x :: Nat. p x
23:51:24 <ski> remember '*' is the same as 'o'
23:51:43 <palomer> why y::Nat?
23:51:47 <ski> so, if you add sorts to the quantifiers, you get 'o' back in the sorts(/types) there
23:51:55 <ski> because Succ :: Nat -> Nat
23:52:02 <ski> and Succ is applied to y
23:52:06 <ski> so y must be a Nat
23:52:18 <ski> also  p :: Nat -> o
23:52:38 <ski> so, p is a 1-ary predicate(/type-constructor) that takes naturals as argument
23:52:38 <palomer> that's the beauty of second order logic
23:52:53 <palomer> y::Nat <-- your notation N[y] <--my notation
23:53:05 <ski> really ?
23:53:08 <palomer> yes!
23:53:16 <ski> i thought your N[y] expanded to a formula
23:53:25 <palomer> and that formula represents the integers!
23:53:50 <ski> except, if you add sorts to the quantifiers in that formula, you get back a 'Nat'
23:54:03 <palomer> N[y] says that if 0 is in a predicate and if, for ANY element in that predicate, the successor is also in that predicate, then y must be in that predicate!
23:54:19 <palomer> sorts+
23:54:20 <palomer> ?
23:54:42 <ski> 'forall x. ...'  without (explicit, at least) sorts
23:54:50 <ski> 'forall x : A. ...'  with sorts
23:54:57 <palomer> right
23:55:00 <palomer> my logic doesn't have sorts
23:55:05 <ski> call them types, if you like
23:55:14 * ski prefers sorted logics :)
23:55:23 <palomer> forall x : A . B <=> forall x. Ax -> B
23:55:30 <palomer> sorts is syntactic sugar
23:55:51 <ski> only if you can convert that sort A to a unary predicate
23:56:15 <palomer> but it IS a predicate, really
23:56:23 <ski> in your logic :)
23:56:26 <palomer> adding sorts does not increase expressive power
23:56:36 <ski> it is nicer, i think
23:56:45 <palomer> and it barely decreases writing
23:56:57 <palomer> AND, what bothers me the most, is that:
23:57:17 <palomer> forall x:A . B is inhabitated with terms with at least one lambda in front
23:57:30 <ski> so ?
23:57:30 <palomer> now, for me, lambdas in front means arrows
23:57:42 <palomer> but you don't have any arrows!
23:57:46 <ski> 'arrows' meaning what, here ?
23:57:49 <palomer> ->
23:58:02 <palomer> forall x. Ax -> B
23:58:24 <ski> if 'x' doesn't occur in 'B', then 'forall x:A . B' is the same as 'A -> B', in dependent logic/type theory
23:58:28 <ski> do you mean that ?
