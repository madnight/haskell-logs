00:01:19 <sebell> m
00:33:28 <MarcWebe1> Good morning. I'm struggling with one sentence from the haskell tutorial which states that you cannot make Monad instances out of non fully applied type synonyms that's why they use "newtype State st a = State st-> (st, a)" except of "type State st a = st -> (st, a)"
00:34:54 <MarcWebe1> By now I know the use of newtype to specify your own equality or ord functions for existing types.. But what does non fully applied mean here?
00:44:38 <stefanw> fully applied means applied to all arguments
00:45:15 <stefanw> if you have 'type Foo a = [a]', you can't write just 'Foo' because the argument is missing
01:28:22 <shapr> jiihaa
01:30:19 <MarcWebe1> stefanw: instance Monad (State state) where
01:31:34 <ski_> that typesynonym needs 2 args
01:32:06 <ski_> with newtype or data, it works
01:32:40 <MarcWebe1> return a = State (\state -> (state , a))
01:33:03 <ski_> yes
01:35:32 <MarcWebe1> ski_: Why is State state valid here. Doesn't State need two type parameters (st and a) ?
01:35:55 <ski_> not if it's a data or newtype
01:36:18 <ski_> State :: * -> * -> *
01:36:24 <ski_> State state :: * -> *
01:36:36 <ski_> Monad wants an argument with kind * -> *
01:36:51 * MarcWebe1 agrees
01:37:05 <ski_> the only trouble is if we try to use a typesynonym
01:37:27 <ski_> since those needs to be applied to all args
01:37:36 <ski_> (can't be partially applied)
01:39:37 <MarcWebe1> ski_: Thanks.. That was the missing point.. But I think I'll have to spend some further days till I fully grasp State monads ;)
01:39:42 * shapr boings cheerfully
01:40:10 * ski_ drinks his tea
01:40:38 <ski_> (MarcWebe1 : btw, you forgot to define (>>=) above)
01:45:53 <dons> stefanw, nice!
01:46:37 <unixgreybeard> MarcWebe1: me too, monads are my current bane
01:46:47 <MarcWebe1> I just can't put the puzzle into one piece.. I think there are too much interferences with oo languages (C++/Java/Pascal/..)
01:46:57 <unixgreybeard> shapr: how exactly does one 'boing'? :-)
01:47:18 <dons> @karma+ stefanw
01:47:18 <lambdabot> stefanw's karma raised to 1.
01:47:51 <unixgreybeard> MarcW: I hear that....and I'm really current on my group theory, so the category theory stuff all makes sense to me in the literature about monads
01:47:53 <MarcWebe1> unixgreybeard: Let's introduce a chatroom #haskell-beginners-monads ;)
01:47:59 <unixgreybeard> heh, no shit!
01:48:21 <dons> stefanw, also, now finished hmp3 for the time being!
01:48:52 <dons> SamB, I'll just sit on it for a week or so and then announce, I think. wait for any bugs to come to me.
01:49:16 <unixgreybeard> dons: yeah, waiting to announce releases can pay off
01:49:56 <dons> yeah, I think so.
01:50:34 <dons> learnt this lesson from david roundy, he's good at waiting for things to stabilise before releasing darcs
01:50:47 <unixgreybeard> darcs is sweet
01:52:55 <unixgreybeard> oh no, morloth is in the Maybe monad!
01:54:27 <unixgreybeard> damn, see, I can make jokes about Monads, but haven't successfully used them yet
01:54:56 <dons> hehe
01:55:05 <unixgreybeard> much more of this and I'll be able to reel off the definition of them in my sleep before I can actually write code that uses them...is that part of the initiation? :-)
01:55:40 <dons> oh, i don't think they're that hard to use. they just have all this math in the background.
01:55:50 <dons> rather than being vague and ill-defined
01:55:53 <dons> :)
01:56:42 <shapr> unixgreybeard: Hey, I'm the same age as you, but I'm not a greybeard :-)
01:56:43 <unixgreybeard> the funny thing is that the math part is what I understand of them...that and dozens of other computer languages
01:56:55 <unixgreybeard> my beard literally has grey in it!
01:57:03 <shapr> Wow, cool.
01:57:26 <unixgreybeard> and I've been using unix since I was 16, which is when I could first grow one
01:57:31 <shapr> This is me five months ago:  http://www.scannedinavian.com/images/shae-sj.png
01:57:59 <shapr> Hm, I've been using Unix since I was 16 as well.
01:58:08 <ski_> falling on your knees ?
01:58:12 <asdasd> lol
01:58:19 <ski_> er
01:58:29 * ski_ meant in reference to the pic
01:58:38 <shapr> I started with a SCO Unix box. I used to think they were cool since they had the only affordable IBM-PC Unix way back then.
01:58:43 <unixgreybeard> it's just more and more streaks of grey, this is in may before it grew out again, now the grey is more visible: http://davidmercer.nfshost.com/
01:58:47 <dons> anyone who wants to do some hmp3 beta testing: http://www.cse.unsw.edu.au/~dons/hmp3.html
01:58:58 <unixgreybeard> eeewwww System III
01:59:26 <unixgreybeard> damnit I keep misreading that as hmp3 = h3mp = hemp
01:59:36 <shapr> ski_: Nah, I overused my knee pads - http://www.scannedinavian.com/~shae/unicycle/PICT3244.smaller.JPG
02:00:01 <ski_> ah
02:00:24 <unixgreybeard> the cube land in the background of that photo of me is in the Computer Center at the UofA
02:00:26 <shapr> Does xerox have a blog or website somewhere?
02:00:33 <unixgreybeard> xerox?
02:00:41 <shapr> paolo martini(sp?)
02:00:57 <shapr> @seen xerox
02:00:58 <lambdabot> I saw xerox leaving #haskell.it, #haskell-overflow, #haskell-blah and #
02:00:58 <lambdabot> haskell 13 hours, 3 minutes and 59 seconds ago.
02:01:20 <shapr> I think it's cool that #haskell is growing so much that we have #haskell.se #haskell.it and #haskell.de now.
02:01:35 <unixgreybeard> schweet
02:01:55 <dons> we have #haskell.de? do they want a lambdabot?
02:01:57 <unixgreybeard> I just wandered in from 20 years in the lisp/perl wilderness this last week 
02:02:00 <dons> @seen lambdabot
02:02:00 <lambdabot> Yes, I'm here. I'm in #webwitches, #haskell.es, #haskell.it, #gentoo-
02:02:00 <lambdabot> haskell, #haskell-overflow, #haskell-blah and #haskell
02:02:13 <shapr> Oh, #haskell.es !
02:02:18 <dons> shapr forgot .es ;)
02:02:36 <unixgreybeard> spain?
02:02:39 <shapr> yup
02:04:53 <MarcWebe1> May I try to sum up some things just for clarifying them in my mind? There are classes to have an abstraction from data types (e.g class Num defines +-/* and so on.. so I don't need to worry about the type). A Monad is some special kind of class (return, >>= (and >>) , fail)
02:05:37 <ski_> yes
02:06:37 <ski_> there is a type class named ''Monad', and a type constructor is said to be a monad if it's an instance of this class
02:07:56 <ski_> (there's nothing magical with this class .. one doesn't even need type classes to work with monads .. but it's a lot easier .. especially overloaded code that works over all / many monads)
02:08:33 <shapr> hiya jaidormi, are you awake now?
02:08:37 <jaidormi> yeah
02:08:46 <shapr> Are you learning Haskell?
02:08:50 <jaidormi> yes i am, actually
02:08:58 <shapr> Do you have any questions?
02:09:22 <jaidormi> well not at this particular moment; i expected i might see some interesting conversation
02:09:51 <jaidormi> i'm piecing back together my mac, so i decided to open irc while i rebuilt the ui and apps the way i like it
02:10:21 <jaidormi> but obviously this will be the place to come for help
02:10:43 <unixgreybeard> heh, I've been a mac user since 1984, so if you get stuck anywhere :-)
02:10:48 <MarcWebe1> ski_: and the type constructor must create something of kind * -> * which means it takes one argument which can hold a value and creates another type holding a value eg data a = a or data a = a a (beeing like a tuple or vector)..?
02:11:04 <shapr> jaidormi: If you think of any questions, feel free to ask.
02:11:15 <jaidormi> thanks, i will feel free indeed
02:11:53 <ski_> MarcWebe1 : itym data Foo a = F a, or data Bar a = B a a ?
02:12:26 <unixgreybeard> I just need one simple specific example coded up for me and I think I will be able to use monads at will
02:13:18 <MarcWebe1> unixgreybeard: Try http://www.nomaware.com/monads/html/
02:13:30 <MarcWebe1> There are different examples..
02:13:52 <unixgreybeard> oh I've been reading that a LOT this week! they are mostly examples of implementation, or of really simple or really complex things
02:14:22 <unixgreybeard> if I could understand how to do the following, I'll be golden: using the State monad, store an Int as a named parameter in a record
02:14:32 <MarcWebe1> ski_: You're right, I forgot the name to construct the data. data MyData a = MyData a or a a or whatever.
02:14:59 <ski_> unixgreybeard : where do you want to use a state, there ?
02:15:02 <unixgreybeard> then make functions to stick something new in that container, do something to it, return it back to main and print it
02:15:06 <ski_> hold the record in a state ??
02:15:33 <ski_> (and what do you mean by named parameter ?)
02:15:37 <unixgreybeard> I don't need to, but I need to carry a partially applied function, a counter, and an array
02:15:58 <unixgreybeard> record syntax {x :: Int, y :: Int}
02:16:56 <unixgreybeard> or a tuple, I don't care how I carry them along, but I need to get at the 3 different bits of state I need to lug around
02:18:18 <unixgreybeard> I need to start with a monad with one bit of state, then I can go from there in my groking of it!
02:21:36 <mentomorph> Godmorning/day: this won't compile on the other arrow and I dont know if it's doable: func = \inp -> func2 (inp) -> inp 
02:25:29 <MarcWebe1> ski_: Thanks a lot.. I feel that there isn't missing much to understand it, now. I'll have breakfast first.
02:25:58 <kowey> this question is about monads (trust me): could somebody name some effects of going out into space without a space suit?
02:26:15 <unixgreybeard> heh, explosive decompression?
02:26:27 <basti_> kowey: suffocating, mainly
02:26:31 <basti_> you wouldn't explode
02:26:34 <basti_> yes it has been tested.
02:27:34 <unixgreybeard> ah, thanks...I'm not sure I needed to know that!
02:27:41 <ski_> unixgreybeard : so your state is roughly a triple of some stuff ..
02:28:08 <unixgreybeard> yes, a quad at worst
02:28:13 <ski_> mentomorph : what are you trying to do ?
02:28:29 <mentomorph> I'd like to call a func2 bfr returning
02:28:36 <mentomorph>  func = \inp -> func2 (inp) -> inp 
02:29:04 <ski_> what you you want to call 'func2' with ?
02:29:17 <ski_> and what do you want to do with the result from that 'func2' call ?
02:29:44 <mentomorph> I'd like to scrap the result
02:29:58 <ski_> ignore it ?
02:30:01 <mentomorph> yes
02:30:12 <ski_> then you don't need to call the function
02:30:16 <mentomorph> lol
02:30:21 <mentomorph> true
02:30:56 <ski_> the effect of a function is in the returned value
02:31:03 <mentomorph> well the func2 is a drawLine func that returns an IO()
02:31:10 <ski_> you could write
02:31:12 <mentomorph> ur right, I was wondering
02:31:13 <mentomorph> what ?
02:31:31 <ski_> func = \inp -> let _ = func2 inp   in  inp
02:31:45 <ski_> that ignores the result of the function call to 'func2'
02:32:03 <ski_> in fact, it even doesn't bother to call that function, since the result isn't used
02:32:38 <ski_> (remember that haskell is lazy)
02:32:42 <mentomorph> ok, I wonder if Gtk2hs is gonna draw it then
02:33:02 <basti_> you can't issue a draw command that way
02:33:06 <ski_> is your 'func2' returning a monadic action ?
02:33:30 <mentomorph> no, but I guess it supposed to
02:33:52 <basti_> if it wants to draw something, it ought to
02:34:16 <mentomorph> ok, I
02:34:22 <xs> hm, don't you want: do {func2 inp; return inp} or similar?
02:35:42 <ski_> that would work, in this case
02:36:25 <mentomorph> ok nice ppl
02:36:56 <mentomorph> I'm gonna think about what've you said. th u
02:38:31 <ski_> mentomorph : also, you *do* know that you can write 'func = \inp -> ..' as 'func inp = ...', right ?
02:39:46 <unixgreybeard> you only need 'func = \inp ->' when you need to reorder parameters in partial application, no?
02:40:24 <ski_> reorder ?
02:40:53 <mentomorph> sure ski_, that I know )
02:41:13 <unixgreybeard> if you have f a b, and you want to partially apply f to b instead of a, you need to reorder the parameters
02:41:23 <ski_> '\inp -> ...' is mostly used for passing as argument to something, or storing in a data-structure
02:41:46 <ski_> otherwise, it's usual to put args to left of the '='
02:45:26 <unixgreybeard> for instance, in this function;
02:46:09 <unixgreybeard> w :: (FIPS a) => (FIPSarray a) -> Int -> a
02:46:09 <unixgreybeard> w m t
02:46:09 <unixgreybeard>   | t < 16   = m!t 
02:46:09 <unixgreybeard>   | t < 64   =  (smallSigmaOne (w m t-2)) + (w m t-15) + (w m t-16)
02:46:40 <ski_> if you want to partially apply f, giving second arg b, you can write (`f` b)
02:47:14 <ski_> (that sometimes can read nice)
02:47:39 <unixgreybeard> I originally had it as w t m, but I switched the arguments, as I want to be able to carry around a partially applied w in a monad, and m is going to change less frequently than t (for every m, various t's will be supplied and the whole mess evel'd)
02:48:09 <ski_> ok
02:48:41 <unixgreybeard> the ghc compiler smacked me hard when I'd only half switched them!
02:49:05 <ski_> half switched ?
02:49:13 <Oejet> unixgreybeard: Did you see the page http://www.haskell.org/hawiki/ImperativeHaskell ?  It contains some uses of the State monad.
02:49:22 <ValarQ> ski_: yeah, that automagic flip is nice
02:49:22 <ski_> you mean when you had just changed half of the places ?
02:49:24 <unixgreybeard> I had changed their order in the function definition but not somewhere else where it's used!
02:49:37 <ski_> right, ok
02:49:58 <unixgreybeard> and an Array and an Int aren't, well, you know
02:50:01 <ski_> (a refactoring tool would be nice, here)
02:50:14 <unixgreybeard> yes, haskell support in eclipse would rule
02:51:38 <o_Rocky> can someone teach me how to combine Monads?
02:51:46 <MarcWebe1> instance Monad (State state) where
02:51:53 <MarcWebe1> return a = State (\state -> (state , a))
02:51:54 <ValarQ> unixgreybeard: wouldn't hide be better suited?
02:52:04 <o_Rocky> like IO whith State
02:52:30 <MarcWebe1> ski_: Now I can use return with parameter a? How das the compiler know the type of state?
02:52:56 <ValarQ> unixgreybeard: and with a beard as grey as yours you should be in the emacs vs vi fight... :P
02:53:01 <MarcWebe1> s/das/does/
02:53:03 <ski_> o_Rocky : IO includes state, so why do you want a separate state thing ?
02:53:32 <o_Rocky> ?
02:53:51 <o_Rocky> come again?
02:53:55 <ski_> @index newIORef
02:53:55 <lambdabot> Data.IORef
02:54:03 <o_Rocky> O_O
02:54:05 <ski_> @type Data.IORef.newIORef
02:54:06 <lambdabot> forall a. a -> IO (GHC.IOBase.IORef a)
02:54:13 <ski_> @type Data.IORef.readIORef
02:54:14 <lambdabot> forall a. GHC.IOBase.IORef a -> IO a
02:54:17 <ski_> @type Data.IORef.rwriteIORef
02:54:17 <lambdabot> Not in scope: `Data.IORef.rwriteIORef'
02:54:20 <ski_> @type Data.IORef.writeIORef
02:54:21 <lambdabot> forall a. GHC.IOBase.IORef a -> a -> IO ()
02:54:43 <basti_> so whats the buzz?
02:54:44 <basti_> ^^
02:54:47 <unixgreybeard> valarq: is hide usable?
02:55:08 <ski_> if you want to combine IO and state anyway, try using 'StateT s IO'
02:55:20 <basti_> ST is fun too.
02:55:26 <basti_> for some values of fun.
02:55:26 <unixgreybeard> valarq: I'm an emacs user
02:55:34 <unixgreybeard> barti: I need to learn st probably
02:55:40 <ski_> MarcWebe1 : it infers the type of the state
02:55:48 <ValarQ> unixgreybeard: don't think it's usable yet
02:55:56 <basti_> unixgreybeard: what are you trying to do?
02:56:16 <ski_> MarcWebe1 : 'instance Monad (State state)' actually declares a family of state monads, one for each possible type that 'state' there could be
02:56:26 <unixgreybeard> high level goal: implement sha2 completely in haskell
02:56:31 <ski_> MarcWebe1 : 'State Int' is one monad, 'State String' is another
02:56:38 <basti_> ah that was you
02:56:41 <ski_> MarcWebe1 : they are all state monads, though
02:56:49 <unixgreybeard> yes
02:57:11 <basti_> ^^
02:57:22 <basti_> it kinda depends... I assume you want to implement some sort of bit operation on a block of bits?
02:57:33 <unixgreybeard> yes
02:57:34 <basti_> weird table lookups
02:57:36 <basti_> etc.
02:57:46 <trez> 'unixgreybeard' sounds lika a charater from lord of the rings
02:57:50 <unixgreybeard> a block of Word32 or Word64's, to be exact
02:57:54 <basti_> ah
02:57:57 <unixgreybeard> heh :-)
02:58:09 <unixgreybeard> I have everything done but the stateful bits
02:58:27 <basti_> you have two choices... either you can guard the state "at the root" or "locally
02:58:27 <MarcWebe1> ski_: But return is of type return:: a -> m a   within the class instance Monad (State state), right?
02:58:41 <ski_> (MarcWebe1 : the point being that that instance definition works, for any type 'state')
02:58:45 <ski_> right
02:58:52 <ski_> so, in this case m = State state
02:58:53 <ski_> so
02:58:53 <unixgreybeard> I can't pass it around everywhere, as I must take up to 2^128 bits of input
02:58:55 <basti_> "at the root" = IO for example. Locally can be anything to be true ^^
02:59:03 <ski_> return :: a -> State state a
02:59:09 <ski_> MarcWebe1 : see ?
02:59:18 <basti_> did you think of taking advantage of tail-recursion?
02:59:33 <unixgreybeard> no, I need a concrete example, I understand it all theoretically, but it always blows up very badly when I try to use it
02:59:35 <basti_> lazy eval etc.
02:59:44 <basti_> hmm lemme think
02:59:50 <basti_> i had some bitop at some point
02:59:55 <basti_> something about compression
02:59:59 <basti_> lets see how that behaves
03:00:04 * basti_ digs through the archive
03:00:13 <unixgreybeard> I though of the tail recursion, but the non-stateful parts of the program follow the FIPS 180-2 standard line per line in haskell, which is beautiful
03:00:29 <unixgreybeard> the stateful bits are two inner loops
03:00:37 <basti_> there it is... bit8.hs
03:01:01 <basti_> so its really in the inside?
03:01:05 <basti_> just a tiny bit
03:01:28 <MarcWebe1> ski_: So how does the compiler now to which "family" of State Monad classes "return 2" belongs? It might be instance Monad (State String) as well as instance Monad (State Num) ..
03:01:35 <unixgreybeard> the outer one is you going through each block of [512|1024] bits, for each block, construct a function that you use in each of the [64|80] iterations in the inner loop
03:01:59 <ski_> MarcWebe1 : simple, it belongs to all :), it's polymorphic
03:01:59 <basti_> its many repetitions of a tiny inner bit yes?
03:02:14 <unixgreybeard> yes, 64 or 80 repititions of the inner bit
03:02:23 <basti_> which need some state to initialize though
03:02:24 <unixgreybeard> I don't know how big that is if you unroll it
03:02:25 <basti_> s
03:02:28 <ski_> MarcWebe1 : in this case  return :: forall s a. a -> State s a
03:02:32 <unixgreybeard> the state to start with is a constant
03:02:35 <basti_> who talks about unrolling?
03:02:56 <unixgreybeard>  I mean if I wrote it non-monadically, the compiler would unroll the recursion
03:03:07 <basti_> no why?
03:03:07 <unixgreybeard> prolly into a loop in asm
03:03:16 <unixgreybeard> why what???
03:03:24 <basti_> see it could happen like this:
03:03:51 <basti_> there is a value like (innerloop *somestate*):(recurse *somestate*+1)
03:04:26 <unixgreybeard> my initial state in one case consists of this: 
03:04:26 <unixgreybeard> -- K, 256 bit version, from section 4.2.2 of FIPS 180-2
03:04:26 <unixgreybeard> k :: MessageDigest -> FIPSarray Word32
03:04:26 <unixgreybeard> k SHA256 = array (0,63) (zip [0..63]
03:04:26 <unixgreybeard>  [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 
03:04:27 <unixgreybeard>   0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
03:04:29 <unixgreybeard>   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
03:04:31 <unixgreybeard>   0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
03:04:33 <unixgreybeard>   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
03:04:35 <unixgreybeard>   0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
03:04:37 <unixgreybeard>   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
03:04:39 <unixgreybeard>   0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
03:04:42 <unixgreybeard>   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
03:04:43 <unixgreybeard>   0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
03:04:45 <unixgreybeard>   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
03:04:47 <unixgreybeard>   0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
03:04:49 <unixgreybeard>   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
03:04:51 <unixgreybeard>   0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
03:04:53 <unixgreybeard>   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
03:04:55 <unixgreybeard>   0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2])
03:04:57 <unixgreybeard> -- initial hash value H, 256 bit version, from 5.3.2 of FIPS 180-2
03:04:57 <basti_> mighty :D
03:04:59 <unixgreybeard> h :: MessageDigest -> FIPSarray Word32
03:05:01 <unixgreybeard> h SHA256 = array (0,7) (zip [0..7]
03:05:03 <unixgreybeard>  [0x6a09e667,
03:05:05 <unixgreybeard>   0xbb67ae85,
03:05:07 <unixgreybeard>   0x3c6ef372,
03:05:09 <unixgreybeard>   0xa54ff53a,
03:05:11 <unixgreybeard>   0x510e527f,
03:05:12 <MarcWebe1> unixgreybeard: You know that there are paste sites?
03:05:13 <unixgreybeard>   0x9b05688c,
03:05:15 <unixgreybeard>   0x1f83d9ab,
03:05:17 <unixgreybeard>   0x5be0cd19])
03:05:19 <unixgreybeard> oops, that was verra long
03:05:26 <basti_> actually yes it was ^^
03:05:30 * basti_ cant deny
03:05:57 <unixgreybeard> K is an array of the first 32 bits of the fractional part of the third root of the first 64 prime numbers
03:06:06 <basti_> yes thats a mighty state.
03:06:07 <unixgreybeard> that's what I just foolishly pasted :-)
03:06:17 <basti_> is that array staying constant?
03:06:22 <basti_> i can't tell from that mess ^^
03:06:50 <unixgreybeard> the other case is the same, but it's the first 64 bits of the fractional part of the third root of the first 80 prime numbers :-)
03:07:16 <basti_> so its just one value
03:07:22 <unixgreybeard> no, that array h is the thing that gets changed 64 (or 80) times in the inner loop
03:07:30 <basti_> hmm ah
03:07:37 <basti_> yes that would blow up
03:07:38 <basti_> ^^
03:08:07 <unixgreybeard> after that, you slurp in another 512 (or 1024) bits of the input (arrary or file), calculate a new partially applied w m t, do the inner loop again, wash rinse repeat
03:08:19 <basti_> yes you might look into muteable arrays for that.
03:08:20 <unixgreybeard> what goes on in the inner loop is, well, icky
03:08:31 <unixgreybeard> that's what I'm going to use, yes
03:08:31 <astrolabe> What does the program do?
03:08:38 <basti_> encryption
03:08:41 <unixgreybeard> calculates the sha2 message digest
03:08:57 <unixgreybeard> not actual encryption itself per se, but the building block that its made of
03:09:03 <astrolabe> google is my friend
03:09:05 <basti_> hmm yea ^^
03:09:08 <unixgreybeard> heh :-)
03:09:22 <basti_> hmm
03:09:28 <unixgreybeard> all of the open source sha2 versions are in C or C++ it seems
03:09:37 <unixgreybeard> I'm gpl'ing the whole thing
03:09:41 <basti_> so you can hopefully keep the inner parts pure
03:09:51 <basti_> and just call from the loop
03:09:57 <unixgreybeard> I'd prefer bsd, but I started with someone's gpl'd haskell wrapper to openssl for sha1
03:09:57 <basti_> x<-get
03:10:09 <basti_> put (purePuzzle x)
03:10:21 <unixgreybeard> the inner part is all pure, I have done all of the functions used in it already
03:10:33 <basti_> thats great :)
03:11:09 <unixgreybeard> everything except the last section of the sha spec is pure, and then it blows up in your face :-)
03:11:16 <unixgreybeard> which is the point!
03:11:33 <basti_> yea
03:11:38 <basti_> so you don't panic ^^
03:11:42 <unixgreybeard> bits flying off of the end of registers ON PURPOSE because the entire point is to fuss with entropy
03:11:55 <basti_> you just pick a monad of your likings
03:12:08 <basti_> and just call the pure stuff once
03:12:15 <unixgreybeard> needs to be at least ST to handle the data type I need for the mutable array
03:12:23 <basti_> or write a monadic "wrapper"
03:12:34 <basti_> you don't need to change everything
03:12:37 <basti_> good news
03:12:38 <basti_> etc.
03:12:38 <basti_> ;)
03:13:14 <unixgreybeard> the pure stuff used in the inner loop is all crap like this: bigSigmaOne x = rotateR x 14 `xor` rotateR x 18 `xor` rotateR x 41
03:13:46 <basti_> i wrote 500 k of zip like data ([(Length,Data)])->([Char8]) in 3.7 secs
03:14:12 <basti_> and that's the first guess approach
03:14:39 <unixgreybeard> doing this in a monad should give me constant memory usage, no?
03:15:14 <MarcWebe1> ski_: When having a do construct. Then the strategy to getting to know which monad is beeing used is determining the type of the return statement?
03:15:25 <basti_> unixgreybeard: sure
03:16:17 <o_Rocky> @do {line <- lift getLine; maybe <- lift mzero}
03:16:17 <lambdabot> {line <- lift getLine; maybe <- lift mzero} not available
03:19:48 <unixgreybeard> I fear stToIO greatly!
03:24:19 <basti_> why?
03:24:23 <ski_> MarcWebe1 : that can be once cue, yes
03:24:32 <basti_> thats just "do that, using memory as a statekeeper"
03:24:44 <ski_> MarcWebe1 : you could often also consider asking the typechecker
03:26:32 <MarcWebe1> ;)
03:27:41 <unixgreybeard> I will kick this bitchs ass...this monad where I've been stuck in this code for over 3 days running is going to result in work that is both publishable and gpl'd, so it's worth the pain!
03:28:09 <basti_> why do you have monads already?
03:28:18 <basti_> i'd go from a completely pure implementation
03:29:22 <kowey> i am working on yet another tutorial for monads
03:29:28 <kowey> this time, using space stations and astronauts as a metaphor
03:29:29 <kowey> http://www.loria.fr/~kow/monads/index.html
03:29:41 <kowey> perhaps you folks would like to give some comments, corrections, etc
03:33:12 <unixgreybeard> basti: I don't have monads yet, but the inner loop is really messy, in one (or eight!) steps it totally entangles the 8 elements of the array
03:33:38 <unixgreybeard> kind of a bitch to write nonimperitively, since some stuff references each other
03:33:48 <basti_> unixgreybeard: yes but the array could be made strict
03:36:24 <unixgreybeard> each element of the array appears in the definition of from 1 to 5 of the other elements on the next round of the computation
03:36:47 <unixgreybeard> I can write it lazy I suppose, that's what I started doing the other day
03:37:42 <unixgreybeard> that's gonna be one honkin' huge line though, hope ghc can handle all the line-wrapping!
03:38:24 <astrolabe> can't you abstract out the long bits?
03:38:42 <unixgreybeard> it's really icky
03:39:20 <basti_> uuuuh ^^^
03:39:33 <basti_> leave it like it is for now -g-
03:42:24 <unixgreybeard> it is just so frustrating to be stuck so close to the end of a program!
03:46:10 <basti_> ah youre not stuck
03:46:50 <unixgreybeard> feels like it after 3 days of monad frustration!
03:47:28 * basti_ gives unixgreybeard a hug
03:47:37 <unixgreybeard> thx
03:47:48 <basti_> best you start out with something simple
03:48:16 <unixgreybeard> that's why I wanna figure out how to mess with a State monad with just one parameter first
03:49:03 <basti_> hmm theres different bunches of monads
03:49:12 <basti_> and then there's monad transformers
03:49:13 <unixgreybeard> yeah, I'm seeing that!
03:49:15 * basti_ plays a minor chord
03:49:20 <unixgreybeard> yeah, those are kinda scary!
03:49:24 <basti_> both server different purposes
03:49:30 <unixgreybeard> like I said, I fear stToIO greatly
03:49:42 <basti_> you could try with State first.
03:49:53 <basti_> @kind Control.Monad.State
03:49:53 <lambdabot> Not in scope: type constructor or class `Control.Monad.State'
03:49:56 <basti_> hmm
03:49:59 <basti_> @index State
03:49:59 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.
03:49:59 <lambdabot> Monad.RWS, Test.HUnit.Base, Test.HUnit, Test.HUnit.Base, Test.HUnit, Text.
03:49:59 <lambdabot> ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec, Text.
03:49:59 <lambdabot> ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
03:50:01 <unixgreybeard> that's what I wanna play with first, yes
03:50:04 <basti_> ah
03:51:00 <unixgreybeard> I've read many Control.Monad.State pages the last few days, and I can't figure out how to use one yet
03:52:07 <basti_> hmm
03:52:13 <basti_> wait ill give a simple example
03:55:31 <basti_> lisppaste2: @url
03:55:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
03:56:01 <lisppaste2> basti_ pasted "self-explanatory state monad example" at http://paste.lisp.org/display/13797
03:57:02 <unixgreybeard> basti, I think that that will help a lot!!!!!
03:57:47 <basti_> unixgreybeard: :D
03:58:19 <unixgreybeard> I think that playing with that will let me get where I need to go, thanx a million!!!!
03:58:40 <unixgreybeard> it doesn't feel futile anymore
04:00:11 * basti_ plays a triloic resolution in the high notes
04:01:16 <unixgreybeard> aaahhhhh, :t statething and :t returnlaststate is a revelation!!!!
04:01:25 <kombinator> xs: ping
04:02:24 <chris2> kowey: spelling error: ununsual
04:02:39 * basti_ zens unixgreybeard 
04:02:51 <kowey> thanks!
04:05:49 * shapr wibbles
04:08:48 <xs> kombinator: pong?
04:09:02 <xs> i like them.
04:10:28 <ski_> basti_ : is that well-typed ?
04:10:48 <basti_> ski_: "well typed"?
04:10:48 <sebell> Is there a way to set ghc's connectTo timeout value? It seems quite long...
04:10:53 <basti_> ^^
04:11:07 <basti_> ski_: it might miss a type specification yes
04:11:24 <basti_> should be enough to feed "(0::Int)" eg.
04:11:57 <kombinator> xs: do you remenmber me whining about binary IO yesterday?
04:13:14 <kombinator> xs: you pointed me at BinaryIO page at hawiki. I've added my comment there (or my whining)
04:13:34 <unixgreybeard> I will need to do BinaryIO to slurp files I think
04:13:37 <xs> i saw
04:14:16 <basti_> unixgreybeard: we will all be happy in the end
04:14:25 * basti_ is talking unixgreybeard down from his horror trip
04:15:47 <xs> kombinator: i think windows is perhaps why people make a distinction between binary and non-binary handles. it's weird.
04:15:49 <ski_> basti_ : isn't  returnlaststate :: Monad m => m (State s s)  ?
04:15:59 <xs> kombinator: otherwise, binary.hs has what you want.
04:16:10 <basti_> ski_: hmm maybe yes.
04:16:28 * basti_ wonders though
04:16:39 <basti_> no its not
04:16:41 <ski_> also, 'statething >>= returnlaststate' wants 'returnlaststate' to be a function, yes ?
04:17:03 <ski_> (are you using Monad ((->) e) ?)
04:17:10 <basti_> oh wow
04:17:11 <basti_> ^^
04:18:51 <unixgreybeard> I need my binary io to not mess with what it thinks are line delimiters
04:18:58 <unixgreybeard> err, that's why it's binary io
04:20:48 <unixgreybeard> I just made a login on the haskell wiki to document the fruits of my pain later that that others need not suffer so intensely! (user DavidMercer)
04:21:06 <unixgreybeard> but I need to go to bed not!
04:21:13 <unixgreybeard> ^^now
04:21:15 <shapr> freudian slip?
04:21:34 <unixgreybeard> gawd...my wife hates it if our sleep cycles are too out of whack
04:21:44 <unixgreybeard> I call it....coding! :-)
04:22:05 <Heffalump> what time is it?
04:22:08 <xs> io doesn't mess with line delimiters. windows does.
04:22:15 <unixgreybeard> 5:20 in AZ
04:22:24 <Heffalump> when did she go to bed? :-)
04:22:40 <unixgreybeard> uhm, a couple/few hours ago?
04:22:52 <eivuokko> Windows doesn't mess with line delimiters, c (and other) library implementions do.
04:23:08 <unixgreybeard> I'm on Ubuntu (Intel and PPC)
04:23:59 <unixgreybeard> with a windows box available for cross platform testing, but not primary development in a million years
04:24:27 <lisppaste2> basti_ annotated #13797 with "better like that" at http://paste.lisp.org/display/13797#1
04:25:26 <luqui> haskell doesn't have a standard heap implementation?
04:25:36 <unixgreybeard> oh that is helpful!
04:25:59 <unixgreybeard> perhaps I'll roll another "final cigarette" before bed
04:26:03 <xs> eivuokko: unix doesn't. so... :)
04:26:16 <basti_> bed? australia?
04:26:17 <Heffalump> luqui: what kind of heap?
04:26:21 <basti_> or us?
04:26:21 <luqui> priority queue
04:26:34 <Heffalump> there's none in the standard libraries
04:26:43 <luqui> how do I use cabal?
04:26:48 <luqui> i.e. to find and install one?
04:27:29 <soysauce> helo happy haskell hackers
04:27:31 <unixgreybeard> US, arizona...it's 5:56 am here, I've been up all night
04:27:32 <Heffalump> not sure if there are any cabalised ones
04:27:36 <soysauce> alliteration is my friend
04:27:45 <soysauce> unixgreybeard - go to bed!
04:27:51 <soysauce> the sun is already up here ;)
04:27:57 <soysauce> you don't want to turn to stone
04:28:12 <unixgreybeard> yeah, good point!  or combust, or whatever!
04:28:30 * soysauce <- Florida
04:28:31 <unixgreybeard> <--smoking a final cig for the night
04:28:52 <soysauce> if we see the sun it means that Tropical Storm Gamma hasn't arrived yet. ;-)
04:28:52 <Heffalump> luqui: try http://www.informatik.uni-bonn.de/~ralf/software.html
04:28:54 <unixgreybeard> florida: go on vacation, leave on probation, go back on violation!
04:29:00 <basti_> :-o
04:29:01 <unixgreybeard> that sounds so scifi
04:29:07 <unixgreybeard> Tropical Storm Gamma
04:29:10 <soysauce> hehe
04:29:19 <soysauce> well we had Hurricane Beta, we just didn't get hit by it
04:29:31 <soysauce> that's really insane, though. This is *really* late in the season.
04:29:32 <unixgreybeard> I spent 3 weeks during spring planting in gainsville once
04:29:39 <soysauce> not to mention the fact that we had so fscking many
04:30:00 <soysauce> oh, well, I would appologize for my state
04:30:01 <luqui> Heffalump, thanks
04:30:23 <unixgreybeard> oh it's no thing, it was nice and all, but the law enforcement was, uhm, kinda fascist
04:30:23 <soysauce> would be helpful if Florida sank into the ocean
04:30:30 <soysauce> interesting
04:30:41 <soysauce> Gainesville is a college town
04:30:48 <unixgreybeard> but that is true in so many many places it doesn't really make fla special
04:30:55 <soysauce> I think the students at UF (~50,000) comprise more than half the population ;)
04:30:57 <gdfk> Florida has wonderful thunderstorms.
04:30:57 <Heffalump> doesn't the rest of the East Coast need Florida to protect it from the hurricanes? :-)
04:31:00 <unixgreybeard> I was on a hippy commune
04:31:01 <soysauce> that's probably not actually true
04:31:08 <soysauce> gdfk - lies. We *had* them 10 years ago. ;)
04:31:22 <Heffalump> Florida is a good place to get shot, I thought.
04:31:22 <soysauce> gdfk - where are you?
04:31:22 <gdfk> Ah, well that's about when I was last there.
04:31:31 <soysauce> when?
04:31:40 <gdfk> New England.
04:31:46 <gdfk> About ten years ago.
04:31:56 <unixgreybeard> I was last in fla in 1993?
04:32:01 <gdfk> Stayed there a few months.
04:32:11 <soysauce> ah
04:32:15 <unixgreybeard> <-- got eaten by mosquitos in fla
04:32:20 <soysauce> haha
04:32:30 <soysauce> well wtf do you expect when you live in the swamp?
04:32:38 <unixgreybeard> no doubt!
04:32:39 <gdfk> Malaria at the least.
04:32:47 <unixgreybeard> only 3 weeks there
04:32:59 <unixgreybeard> sleeping on a porch at the most covered
04:33:20 <soysauce> gdfk - it used to rain so regularly that the Tampa Tribute, the paper in Tampa (duh), would give out free copies if it didn't rain for 2 days in a row. Something like that.
04:33:28 <soysauce> they had to stop a long time ago
04:33:41 <gdfk> Interesting.
04:33:46 <soysauce> in the early 90s Florida entered a draught
04:33:56 <gdfk> Yes, I remember that vaguely.
04:33:59 <soysauce> went from receiving > 53" of annual rainfall to about 30" or so
04:34:02 <gdfk> From the news due to fires.
04:34:05 <soysauce> yeah
04:34:11 <soysauce> it's not as bad now
04:34:24 <soysauce> I'm not sure what the rainfall is anymore. This year was exceptionally high, though.
04:35:49 <unixgreybeard> I'm in AZ, grew up in central CA and have lived in CO: what is this 'rain' that you speak of?
04:36:07 <unixgreybeard> oh yeah wait it's that stuff during monsoons!
04:36:14 <soysauce> haha
04:36:35 <soysauce> would be fun to live through a monsoon
04:36:45 <soysauce> in the last 2 years I've been through 3 hurricanes ;)
04:36:51 <soysauce> well, technically more
04:37:03 <soysauce> the city where I live has been hit something like 5 times in the last 2 years
04:43:06 <unixgreybeard> nite all!
04:45:55 <mentomorph> Please help, I'm really stuck at this. I want to call Gtk2hs drawLine from a function that does not return IO() as drawLine does. How can this be done? It kinda looks like this unparsable piece
04:45:56 <mentomorph> main::IO()
04:45:56 <mentomorph> ..
04:45:56 <mentomorph> var = func inp
04:45:56 <mentomorph> ..
04:45:57 <mentomorph> func::Inp -> Inp
04:45:59 <mentomorph> func x -> drawLine x x -> x
04:47:41 <basti_> mentomorph: did you think about cairo?
04:48:50 <mentomorph> oh, the only thing I know bout it is that draws better looking stuff
04:48:51 <Lemmih> @wiki ThatAnnoyingIoType
04:48:51 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIoType
04:50:44 <mentomorph> Lemmih: I'm I supposed to find the answer there?
04:54:29 <luqui> mentomorph, do you mean that it doesn't return IO (), or that it doesn't return IO anything?
04:54:41 <Lemmih> mentomorph: Yes.
04:55:34 <luqui> it's clear that you meant the latter
04:55:40 <luqui> and the answer is that it's impossible
04:55:45 <luqui> (intentionally) :-)
04:56:15 <mentomorph> yes I understud that part of haskell
04:56:25 <luqui> so what is your question?
04:57:39 <mentomorph> I still need to call drawLine from a func
04:57:56 <luqui> so you're asking if you can cheat?
04:58:03 <soysauce> is there any datatype that can be used for fast 64-bit arithmetic? :/
04:58:23 <soysauce> I have numbers that can be valued up to 20 billion but no higher
04:59:16 <luqui> soysauce, and you need it to be fast, huh?
04:59:21 <mentomorph> I dont want to cheat I just dont know this can be done in Haskell but I suppose I'll find out at that wikipage
04:59:25 <soysauce> would be nice
05:00:05 <luqui> mentomorph, well, what that page is telling you (which you said you already understand) is that you can't call a function that returns IO from one that doesn't
05:00:12 <luqui> unless you cheat :-)
05:00:24 <luqui> soysauce, the only thing builtin is Integer
05:00:29 <soysauce> :(
05:00:29 <luqui> don't know about libraries
05:00:47 <soysauce> I was doing purely computational work, and run time was exactly proportional to memory allocation
05:00:51 <mentomorph> now I suddenlly want to cheat, please tell me how
05:01:03 <luqui> unsafePerformIO :: IO a -> a
05:01:05 <soysauce> Int doesn't allocate anything, so it was ridiculously fast
05:01:50 <mentomorph> aaah, I heard that that could get me killed
05:02:02 <luqui> :-)
05:02:07 <luqui> yeah, it's, er, unsafe
05:02:25 <luqui> hard to predict, given Haskell's lazy nature
05:02:28 <soysauce> Int64 is 3 times faster than Word64, wtf :/
05:02:29 <luqui> that's why we use the IO monad
05:02:48 <luqui> soysauce, ??? weird
05:02:55 <soysauce> test8                          Main                  66.7  100.0
05:02:56 <soysauce> test4                          Main                  22.5    0.0
05:03:05 <soysauce> the *only* difference is that test4 uses Int64 and test8 uses Word64
05:03:19 <soysauce> Int64 is semi-optimized, Word64 isn't optimized at all
05:03:30 <eivuokko> Is word64 unsigned?
05:03:30 <soysauce> I don't understand why; isn't the distinction only made for the type checker?
05:03:32 <soysauce> yes
05:03:52 <soysauce> I had the impression that int -> word conversion was cheap, and by cheap I mean 'free'
05:04:00 <soysauce> oh, d'oh, I see why
05:04:11 <soysauce> it has to allocate a new Int64 object when it does the conversion
05:04:31 <eivuokko> Naturally...
05:04:42 <soysauce> *grumble* *grumble*
05:05:02 <eivuokko> Altho maybe it should be mentioned to ghc hackers that it should be optimised if you have relatively simple case.
05:05:13 <luqui> mentomorph, why must the function that calls drawLine not return IO ?
05:05:23 <soysauce> I honestly don't see why 64-bit arithmetic isn't really cheap, even on my 32-bit machine.
05:05:27 <Lemmih> Neither Int64 or Word64 are optimized. They're both implemented as calls to C functions.
05:05:40 <soysauce> that honestly makes no sense :/
05:05:46 <soysauce> why wouldn't they map to long long?
05:06:01 <luqui> long long isn't necessarily 64 bit
05:06:08 <Lemmih> That means that GHC can't do any transformations and a call to C is very expensive.
05:06:16 <soysauce> long isn't necessarily 32-bits
05:06:24 <soysauce> long is defined to have size >= 32-bits
05:06:24 <luqui> touche
05:06:28 <soysauce> and long long to have size >= 64-bits
05:06:30 <gdfk> C99 says that long long int is at least 64-bit
05:06:41 <luqui> oh cool.  that's new in C99 then...
05:06:45 <soysauce> yeah, it is
05:06:50 <luqui> I remember that the old C standard was very unspecific
05:06:59 <soysauce> long long was not defined prior to C99. It was a GCC extension.
05:07:23 <Lemmih> soysauce: C is only one of the backends in GHC.
05:07:30 <soysauce> I know
05:07:38 <soysauce> I'm using the native back-end, I think. That is default, isn't it?
05:07:55 <soysauce> I can try -fvia-c, but I'll have to dig up a C compiler
05:08:09 * Lemmih got a patch which makes {Int|Word}64 a lot faster when compiling via C.
05:08:29 <Lemmih> The current implementation is still slow when compiling to C.
05:09:31 <soysauce> I don't understand why Int64 and Word64 aren't fast operations
05:10:25 <soysauce> I suppose they aren't frequently used; but why would you make them as slow as possible?
05:10:25 <Lemmih> Operations on those types are implemented as calls to functions in C.
05:10:31 <eivuokko> soysauce, simply because noone did the work to optimise their use in ghc.
05:11:41 <kombinator> isn't it possible to inline them?
05:12:20 <soysauce> inlining a function call for a cheap operation isn't going to do much more than bloat code
05:12:30 <soysauce> rather, for an operation that should be cheap but isn't
05:12:45 <soysauce> it probably has something to do with portability
05:12:54 <soysauce> since until C99 there was no way to get a guaranteed 64-bit type
05:13:03 <soysauce> but the native back-end should at least be able to generate that
05:13:45 <Lemmih> @libsrc GHC.Word
05:13:46 <lambdabot> GHC.Word not available
05:14:37 <Lemmih> Implementing the operations as out-of-line primops would probably be the best solution.
05:15:03 <eivuokko> What you mean out-of-line?
05:16:06 <pejo> soysauce, not just any C compiler has worked as backend for GHC, finding the 64 bit type for the small set of compilers "supported" is fairly easy.
05:16:14 <Lemmih> eivuokko: GHC got inline and out-of-line primops.
05:16:30 <eivuokko> Ahas.
05:17:21 <Lemmih> eivuokko: The backends must generate their own code for the inline ops and call the out-of-line ops which are defined in C--. (AFAIK)
05:18:02 <soysauce> Lemmih - well (+), (-), (==), and many other ops are primitive even for 64-bit integers
05:18:16 <soysauce> they have O(n) complexity, and when n == 2, that's not very bad.
05:18:19 <eivuokko> Lemmih, but they are allowed to inline their own def of out-of-line ops?
05:18:46 <soysauce> (*) is O(n^2) and div is O(n^2) too, I believe...
05:19:21 <basti_> :D
05:19:24 <Lemmih> eivuokko: I don't know. But calling a C function from C-- is fast than an unsafe foreign import from Haskell.
05:19:38 <eivuokko> Ah
05:19:42 <Lemmih> soysauce: eh?
05:20:00 <soysauce> Lemmih - complexity of the primitive operations
05:20:03 <eivuokko> Thanks for explaining, Lemmih :)
05:20:04 <soysauce> for arbitrary-sized integers
05:20:09 <eivuokko> @karma+ Lemmih
05:20:10 <lambdabot> Lemmih's karma raised to 6.
05:20:16 <Lemmih> (:
05:21:02 <soysauce> everything except for div and mod are simple enough that they warrant inlining for Int64
05:22:31 <soysauce> strange; are (+) and (-) defined for Word64?
05:22:45 <soysauce> they appear to be
05:22:45 <Lemmih> > 10 + 10 :: Word64
05:22:46 <lambdabot> 20
05:22:56 <Lemmih> Yup.
05:23:14 <soysauce> well apparently someone botched the implementation :/
05:23:19 <Lemmih> From GHC.Words: foreign import ccall unsafe "stg_plusInt64"     plusInt64#     :: Int64# -> Int64# -> Int64#
05:23:22 <soysauce> like I said, it's about 3-times slower than Int64
05:23:36 <Heffalump> I doubt anyone has cared enough to make sure it's fast.
05:23:40 <Heffalump> If you do, you should :_)
05:23:47 <soysauce> blah
05:24:02 <soysauce> once I fix it, it won't matter to me anymore ;)
05:24:10 <soysauce> but I might do that anyway
05:25:12 <Lemmih> The Num instance of Word64:  (W64# x#) + (W64# y#)  = W64# (int64ToWord64# (word64ToInt64# x# `plusInt64#` word64ToInt64# y#))
05:25:27 <soysauce> yep, that's why :/
05:25:47 <soysauce> one could write: foreign import ccall unsafe "stg_plusInt64"     plusWord64#     :: Word64# -> Word64# -> Word64#
05:25:47 <soysauce> right?
05:26:00 <soysauce> and thus fix half the problem with Word64
05:26:05 <Lemmih> Yeah, looks like it.
05:26:29 <soysauce> obviously they are the same at the machine level, at least on any machine with two's complement
05:26:37 <Lemmih> It would still be dog slow compared to Int.
05:26:39 <soysauce> which is pretty much every machine that it's going to run on ;)
05:26:42 <soysauce> I know
05:27:17 <soysauce> but a 1-line change making Word64 suddenly become 3 times faster -- I like that. ;)
05:30:21 <Lemmih> @seen JaffaCake
05:30:22 <lambdabot> I haven't seen JaffaCake.
05:38:40 <o_Rocky> @seen lambdabot
05:38:40 <lambdabot> Yes, I'm here. I'm in #webwitches, #haskell.es, #haskell.it, #gentoo-
05:38:40 <lambdabot> haskell, #haskell-overflow, #haskell-blah and #haskell
05:38:57 <o_Rocky> gentoo- ? very good
05:44:54 <Heffalump> errm, surely all those coercions in the Word64# (+) are no-ops?
05:45:07 <xs> is it possible to catch a call to error (:: String -> a)?
05:45:14 <soysauce> Heffalump - no
05:45:22 <soysauce> Word32 coercion to Int32 is a no-op
05:45:27 <soysauce> but not for the 64-bit case
05:45:33 <Heffalump> why not?
05:45:46 <Lemmih> xs: Yes.
05:45:55 <kowey> note: those of you who are helping me debug my tutorial (thanks), i've added some diagrams
05:45:58 <kowey> http://www.loria.fr/~kow/monads/index.html
05:46:01 <kowey> hope they don't confuse matters :-)
05:46:05 <soysauce> actually, I don't think Int32 -> Int is free
05:46:14 <xs> Lemmih: how?
05:46:21 <soysauce> data Int32 = I32# Int#
05:46:25 <Heffalump> Int32 -> Int should be free on a 32-bit platform
05:46:26 <soysauce> which means that they decompose identically
05:46:32 <Lemmih> @type Control.Exception.Catch
05:46:33 <lambdabot> Not in scope: data constructor `Control.Exception.Catch'
05:46:38 <soysauce> which means that all ops are implemented identically
05:46:39 <Lemmih> @type Control.Exception.catch
05:46:40 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
05:46:55 <xs> oh okay. cool. thanks.
05:47:02 <Lemmih> @type Control.Exception.ErrorCall
05:47:02 <lambdabot> String -> GHC.IOBase.Exception
05:47:08 <soysauce> (+) (I# a) (I# b) :: Int -> Int -> Int = I# (a +# b)
05:47:15 <soysauce> (+) (I# a) (I# b) :: Int32 -> Int32 -> Int32 = I# (a +# b)
05:47:18 <soysauce> er
05:47:23 <soysauce> in the second, s/I#/I32#/
05:47:41 <soysauce> that's my guess.
05:48:12 <soysauce> I can do a test and tell you if the coercion is free or not
05:48:15 <soysauce> brb.
05:54:26 <soysauce> @type fromIntegral
05:54:27 <lambdabot> forall b a. (Num b, Integral a) => a -> b
05:54:35 <soysauce> weird.
05:54:36 <xerox> Hey there.
05:54:40 <soysauce> 'lo
05:54:42 <xerox> soysauce: why?
05:54:56 <xerox> {Int,Integer} -> WhateverNumYouWant
05:55:06 <soysauce> GHC is complaining about (fromIntegral x) not matching Int where x :: Int32
05:55:17 <soysauce> I just wanted to double-check the type to make sure I wasn't crazy.
05:55:40 <xerox> instance Integral Integer       -- Imported from GHC.Real
05:55:40 <xerox> instance Integral Int   -- Imported from GHC.Real
05:55:54 <xerox> I don't know if there is an 'instance Integral Int32'
05:56:01 <soysauce> ah, I see
05:56:18 <soysauce> well, I need to convert Int32 to Int. Any ideas?
05:56:27 <xerox> Yes, there is.
05:56:32 <xerox> import Data.Int
05:56:45 <soysauce> you need Data.Int to get Int32 ;)
05:56:50 <soysauce> but what's the function?
05:56:53 <xerox> It defines Integral instances for Int{8,16,32,64}
05:56:58 <soysauce> the docs say to use fromIntegral to convert between everything
05:57:00 <xerox> fromIntegral it seems.
05:57:12 <soysauce> yeah, so... :p
05:57:54 <soysauce> http://www.rafb.net/paste/results/zV7Gc367.html
05:58:05 <soysauce> wait, sorry, let me post the error message too.
05:59:03 <soysauce> http://www.rafb.net/paste/results/ik1KrH51.html
05:59:40 <chris2> is there a function to return a copy without the nth value of a list?
05:59:56 <xerox> What's the purpose of that code, soysauce?
05:59:59 <soysauce> @type (!!)
06:00:00 <lambdabot> forall a. [a] -> Int -> a
06:00:06 <soysauce> xerox - to waste a lot of CPU cycles
06:00:15 <xerox> chris2: I think you have to roll on your own.
06:00:18 <soysauce> er, oops, misparse
06:00:21 <chris2> okay
06:00:22 <chris2> i did
06:00:36 <chris2> dropNth n (x:xs)    | n == 1    = xs    | otherwise = x : (dropNth (n-1) xs)
06:01:10 <chris2> it works, too... but i can't use it in scanl for some reason
06:01:10 <xerox> chris2: keep in mind that using index on lists is usually symptom of a bad algorithm in the functional world.
06:01:20 <chris2> xerox: no, it's needed here
06:01:22 <soysauce> @eval (\n xs -> (take (n - 1)) xs) ++ ((drop n) xs)) 5 [0 .. 10]
06:01:23 <lambdabot>  parse error on input `)'
06:01:31 <soysauce> @eval (\n xs -> (take (n - 1) xs) ++ ((drop n) xs)) 5 [0 .. 10]
06:01:32 <lambdabot> [0,1,2,3,5,6,7,8,9,10]
06:01:44 <chris2> nice
06:01:48 <luqui> chris2, also, using a 1 base is going to give a counter-intuitive interface
06:01:57 <soysauce> heh, remove redundant parentheses ;)
06:02:11 <chris2> luqui: maybe, but that's not important right now
06:02:59 <chris2> i have another function that generates a list. now i want to scan over a list always removing the nth element generated
06:03:04 <xerox> > let byebye n xs = take (n-1) xs ++ drop n xs in byebye 5 [1..10]
06:03:05 <lambdabot> [1,2,3,4,6,7,8,9,10]
06:03:51 <luqui> @type scan
06:03:52 <lambdabot> Not in scope: `scan'
06:03:53 <luqui> @type scanl
06:03:54 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
06:03:54 <soysauce> xerox - any idea about converting Int32 -> Int? I'm already importing Data.Int
06:04:02 <chris2> yeah, i found scanl
06:04:10 * luqui was just remembering what it was
06:04:23 <xerox> @type fromIntegral (0 :: Data.Int.Int32) :: Int
06:04:24 <lambdabot> Int :: Int
06:04:28 <xerox> It works.
06:04:40 <luqui> is that the kind of scan you were looking for?
06:04:40 <soysauce> then I'm missing something.
06:04:42 <xerox> > fromIntegral (0 :: Data.Int.Int32) :: Int
06:04:44 <lambdabot> 0
06:05:19 <soysauce> !!
06:05:24 <soysauce> ok, that was annoying
06:05:34 <soysauce> it was the first half of the if expression which I forgot to modify.
06:05:40 <soysauce> the functions former type was Int32 -> Int32 -> Int32
06:05:42 <soysauce> oh well.,
06:06:00 <soysauce> man that is annoying. :/
06:07:02 <chris2> @type  (\n xs -> take (n-1) xs ++ drop n xs)
06:07:03 <lambdabot> forall a. Int -> [a] -> [a]
06:07:22 <chris2> but scanl wants it different...
06:07:32 <luqui> chris2, how are you trying to scan?
06:07:36 <luqui> what are you trying to do?
06:07:40 <soysauce> chris2 - what is your list's type?
06:07:49 <soysauce> actually what luqui asked is better. :p
06:08:06 <chris2> [Int]
06:08:16 <chris2> i'm trying to do the josephus problem
06:08:28 <soysauce> scanl like that doesn't really make sense
06:08:35 <chris2> but i want to see the steps
06:09:05 <soysauce> you *could* do this: scanl foo xs [0 .. 10]
06:09:08 <soysauce> where foo is that other function
06:09:21 <luqui> what is the josephus problem?
06:09:22 <soysauce> flip . foo, rather
06:09:45 <soysauce> @type flip . (\n xs -> take (n-1) xs ++ drop n xs)
06:09:47 <lambdabot>   Couldn't match `b -> c' against `[a]'
06:09:47 <lambdabot>   Expected type: b -> c
06:09:50 <chris2> yeah
06:09:53 <soysauce> @type flip (\n xs -> take (n-1) xs ++ drop n xs)
06:09:53 <lambdabot> forall a. [a] -> Int -> [a]
06:09:57 <soysauce> there.
06:10:09 <soysauce> @type scanl (flip (\n xs -> take (n-1) xs ++ drop n xs))
06:10:10 <lambdabot> forall a. [a] -> [Int] -> [[a]]
06:10:15 <chris2> luqui: you have, say 15, people in a circle and go around and shoot every 7th. who is the least?
06:10:24 <luqui> last?
06:10:32 <chris2> erm, yeah
06:10:34 <luqui> :-)
06:11:02 <chris2> wonderful
06:11:07 <soysauce> seems like you could order the list such that scanl (drop 1) xs would give you what you want
06:11:12 <soysauce> it would be a lot faster for sure
06:11:34 * integral would have just implemented it with an array of people and then just shooting them...
06:12:05 <chris2> integral: the problem is counting with wrap-around
06:12:11 <luqui> chris2, cool, that sounds right
06:12:21 <luqui> well, make your delete zero-based like I said
06:12:23 <luqui> and then do a mod
06:12:24 <integral> Prelude.mod on the array index :-/
06:12:35 <integral> sorry, I must be misunderstanding the problem.
06:12:39 <chris2> hmm
06:12:53 <soysauce> heh, where is (+) :: Word64 -> Word64 -> Word64 defined? I can modify that in Prelude and not have to rebuild the compiler, yes?
06:12:54 <chris2> but the number to mod for gets less with every kill
06:13:17 <luqui> okay... and?
06:13:27 <chris2> i dont think it's that easy
06:13:38 <integral> ah, I did.  It's not an IArray I'd use, it's a State monad over a list
06:13:53 <luqui> the function you would scan would be: \xs n -> delete (n `mod` length xs) xs
06:14:00 <chris2> mmh
06:14:08 <luqui> but I see how you mean that it could be harder than that
06:14:27 <luqui> there may be some offset weirdness since you're changing the list and the index at the same time
06:14:47 <soysauce> > let kill n xs = take (n-1) xs ++ drop n xs in scanl (kill 5) [1 .. 8]
06:14:48 <lambdabot>   Expecting a function type, but found `[a]'
06:14:48 <lambdabot>   Expected type: [a] -> b -> [a]
06:14:48 <lambdabot>   Inferred type: [a] -> [a]
06:15:05 <soysauce> er, d'oh, right...
06:15:44 <luqui> so maybe a completely different approach would be better
06:15:50 <luqui> like keeping a list of the dead people
06:16:02 <luqui> and then counting one-by-one over them, skipping the dead ones
06:16:03 <soysauce> luqui - that's going to get really complicated
06:16:16 <luqui> but that's very proceduralish
06:16:27 <soysauce> Haskell isn't procedural. ;)
06:16:37 <soysauce> if you use a monad you might be able to make it somewhat acceptable
06:16:39 <luqui> yeah.  I mean, you could do it with a State monad
06:16:47 <soysauce> but otherwise isn't going to be really big and ugly
06:16:48 <luqui> but it just wouldn't be Haskellish
06:16:51 <soysauce> s/isn't/it is/
06:17:03 <soysauce> man, wtf, I can't even speak my native language today.
06:17:18 <integral> kill = do { people <- get; let (skipped, (dead:remaining)) = splitAt 6 people; put remaining ++ skipped } -- it may not be haskellish, but turning the problem directly into executable pseudo-code is good surely?
06:17:18 <luqui> well, g'night, good luck
06:17:39 <chris2> thx
06:18:27 <integral> {- not that that works when length people < 7 -}
06:18:44 <chris2> which will happen at the end
06:19:55 <soysauce> > let kill n xs = take (n-1) xs ++ drop n xs; dead n [] = []; dead n xs = xs!!(mod n (length xs)):(dead n (kill n xs)) in dead 2 [1 .. 8]
06:19:56 <lambdabot> [3,4,5,6,7,8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
06:19:56 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
06:19:56 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
06:19:56 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
06:19:56 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
06:19:57 <integral> kill 1 = do { (dead,remaining) <- get; put remaining; return dead }; kill n = do { (saved,remaining) <- get; put remaining ++ saved; kill n-1 }
06:19:58 <lambdabot> [23 @more lines]
06:20:07 <soysauce> oh, oops.
06:20:18 <soysauce> haha
06:20:43 <soysauce> > let kill n xs = take (n-1) xs ++ drop n xs; dead n [] = []; dead n xs = let n' = mod n (length xs) in xs!!n':(dead n (kill n' xs)) in dead 3 [1 .. 8]
06:20:44 <lambdabot> [4,5,6,7,8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
06:20:44 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
06:20:44 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
06:20:44 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
06:20:44 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
06:20:46 <lambdabot> [23 @more lines]
06:20:58 <soysauce> right, it doesn't preserve state...
06:21:04 <chris2> it needs to begin with 7, 14, 6, 13
06:21:29 <soysauce> > let kill n xs = drop n xs ++ take (n-1) xs; dead n [] = []; dead n xs = let n' = mod n (length xs) in xs!!n':(dead n (kill n' xs)) in dead 3 [1 .. 8]
06:21:30 <lambdabot> [4,7,2,7,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
06:21:30 <lambdabot> 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
06:21:30 <lambdabot> 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
06:21:30 <lambdabot> 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
06:21:30 <lambdabot> 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
06:21:32 <lambdabot> [23 @more lines]
06:21:47 <soysauce> let me debug in GHCi instead of spamming here ;)
06:21:48 <soysauce> brb
06:24:29 <Lemmih> Anyone familiar with the C-- used in GHC?
06:24:53 <soysauce> heh, crap. I don't know how to do this interactively.
06:25:01 <soysauce> Lemmih - do you know how to pattern match a parameter interactively?
06:25:25 <xerox> > let Just x = return 2 in x
06:25:26 <lambdabot> 2
06:25:49 <soysauce> not quite what I was looking for
06:26:00 <soysauce> I want to match empty list vs. non-empty list
06:26:24 <Lemmih> > let f [] = True; f (x:xs) = False in f [1.10]
06:26:25 <lambdabot> False
06:26:35 <soysauce> ok
06:26:57 <xerox> > let f [] = True; f _  = False in f [1]
06:26:58 <lambdabot> False
06:27:06 <Lemmih> > {- or -} let f = null in f [1..10]
06:27:07 <lambdabot> False
06:27:19 <soysauce> ah, yes, I forgot about null
06:27:30 <shapr> chris2: Do you have some test data for the josephus problem?
06:28:08 <xerox> http://img499.imageshack.us/my.php?image=boh1qf.png the number above the cards represent the mean of the values of the cards on the right and left of every number.  What's the value of the green card?  :-)
06:28:13 <chris2> only from a paper drawing
06:29:09 <shapr> What outputs should I get for what inputs?
06:30:36 <chris2> with 15 people and every 7th, i get them killed in that order: 7 14 6 15 9 3 7 13 11 10 12 2 8 7 4 5
06:30:38 <chris2> but let me double check
06:31:17 <Lemmih> Hi shapr.
06:31:17 <soysauce> let kill n xs = drop (n+1) xs ++ take n xs; dead n xs = dead' (n-1) xs; dead' _ [] = []; dead' n xs = let n' = mod n (length xs) in (n', xs!!n'):dead' n (kill n' xs) in take 8 (dead 7 [1 .. 15])
06:31:24 <shapr> hi Lemmih, what's up?
06:31:24 <soysauce> er
06:31:24 <soysauce> > let kill n xs = drop (n+1) xs ++ take n xs; dead n xs = dead' (n-1) xs; dead' _ [] = []; dead' n xs = let n' = mod n (length xs) in (n', xs!!n'):dead' n (kill n' xs) in take 8 (dead 7 [1 .. 15])
06:31:25 <lambdabot> [(6,7),(6,14),(6,6),(6,15),(6,9),(6,3),(6,13),(6,11)]
06:31:33 <soysauce> :) works
06:31:40 <shapr> I took a much simpler approach..
06:31:44 <soysauce> > let kill n xs = drop (n+1) xs ++ take n xs; dead n xs = dead' (n-1) xs; dead' _ [] = []; dead' n xs = let n' = mod n (length xs) in xs!!n':dead' n (kill n' xs) in take 8 (dead 7 [1 .. 15])
06:31:45 <lambdabot> [7,14,6,15,9,3,13,11]
06:32:10 <soysauce> the 1-based indexing was the bug
06:32:14 <Lemmih> shapr: I wanted to talk to you about integrating Hackage with a wiki, mailing list and a bug tracker.
06:32:33 <shapr> Lemmih: ok...?
06:32:42 <chris2> hmm, thx
06:32:46 * soysauce garbage collects his desktop
06:32:50 <chris2> ill dig into that
06:33:18 <soysauce> it seems to me that there should be a standard function that does the same sort of thing, but I can't think of any offhand.
06:33:40 <shapr> Standard function that does what?
06:33:51 <Lemmih> shapr: You wrote a web interface for a mailing list, right?
06:33:54 <soysauce> essentially the same recursion that dead' does
06:33:54 <shapr> yup
06:36:20 <shapr> Do you have a nicely indented flavor of that code?
06:36:56 <soysauce> shapr - me or Lemmih?
06:37:05 <shapr> soysauce: I want to understand dead'
06:37:09 <soysauce> ok, sec
06:37:25 <soysauce> oh, and if it helps, dead' :: Int -> [Int] -> [Int]
06:37:27 <shapr> Lemmih: How would you want to integrate them?
06:37:33 <soysauce> removes the nth element from the list and recurses.
06:37:51 <shapr> Could you use foldl for that?
06:39:15 <soysauce> http://www.rafb.net/paste/results/EWuPGF37.html
06:39:22 <soysauce> yes
06:39:31 <soysauce> well, maybe...
06:39:34 <Lemmih> shapr: I would like Hackage to provide those features to packages/projects.
06:39:50 <soysauce> no, foldl wouldn't work.
06:39:58 <xerox> Why so?
06:40:03 <soysauce> @type foldl
06:40:04 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:40:14 <xerox> Indeed.
06:40:24 <soysauce> the type would have to be (a -> b -> a) -> a -> [b] -> [b]
06:40:38 <shapr> good point
06:40:46 <xerox> Nah.
06:41:14 <Lemmih> shapr: But I'm not sure if automatically setting up trackers and mailing lists is vise or even feasible.
06:41:15 <soysauce> you need a state parameter which is the a, but with fold and scan that becomes your output
06:41:23 <xerox> Nope!
06:41:28 <soysauce> then?
06:41:30 <soysauce> do tell.
06:41:33 <xerox> Err, yes, but.. let me try.
06:41:37 <soysauce> ok :)
06:42:04 <shapr> Lemmih: The cheesy approach is to write trackers with a darcs backend and keep bugs in the same repo as the project.
06:42:23 <shapr> That would work just fine for a wiki, it's pretty much how FLM works.
06:43:42 <shapr> Actually... a darcs backed mailing list would mesh nicely with DJBernstein's im2000 ideas.
06:43:45 * shapr considers that
06:43:59 <shapr> hm!
06:44:04 <shapr> That's actually a really cool idea.
06:45:16 <eivuokko> At work I wrote a small utility program that makes simple xml to describe bugs, the bugs are kept in darcs repo with code.
06:45:51 <shapr> It wouldn't be a 'mailing list' as we know it though.
06:46:07 <shapr> You'd check the mailing list by pulling the repo.
06:46:12 <eivuokko> Yeah, I know, just saying it works nicely as little less conventional bug tracker
06:46:24 <shapr> I think it's a great idea
06:46:36 <shapr> oh hey
06:46:46 <shapr> it'll also let you show exactly what darcs context the bug refers to
06:46:55 <shapr> Since the bug will be a patch as well.
06:46:57 <eivuokko> Yeah
06:48:01 <shapr> So an easy tracker solution is to solicit unit tests along with bug reports. Then when the unit test runs, the issue is closed.
06:48:12 <eivuokko> lol
06:48:16 <shapr> :-)
06:48:25 <eivuokko> I must consider doing that at work.
06:49:26 <shapr> It would make sense, bugs that are sufficiently specified with unit tests can be automatically opened or closed, because they're synonymus.
06:49:26 <xerox> soysauce: watch out.
06:49:29 <xerox> > let kill n = snd . foldl (f) (1,[]) where f (m,xs) y | m == n = (m+1,xs) | otherwise = (m+1,xs ++ [y]) in kill 2 [1..10]
06:49:30 <lambdabot> [1,3,4,5,6,7,8,9,10]
06:49:34 <xerox> \o/
06:50:28 <shapr> Maybe I should suggest this for the darcs bug tracker.
06:50:39 <shapr> They're having such trouble finding a tracker that accepts bug reports via email...
06:50:44 <xerox> > let kill n = reverse . snd . foldl (f) (1,[]) where f (m,xs) y | m == n = (m+1,xs) | otherwise = (m+1,y:xs) in kill 2 [1..10]
06:50:45 <lambdabot> [1,3,4,5,6,7,8,9,10]
06:50:52 <xerox> Maybe less expensive.
06:51:16 <shapr> If the tracker data were in a repo (same or separate?) then it's easy to update.
06:51:34 <soysauce> xerox - doesn't work
06:51:42 <soysauce> er, oh
06:51:48 <soysauce> sorry, mis-read
06:52:01 <soysauce> > let kill n = reverse . snd . foldl (f) (1,[]) where f (m,xs) y | m == n = (m+1,xs) | otherwise = (m+1,y:xs) in kill 2 (kill 2 [1..10])
06:52:02 <lambdabot> [1,4,5,6,7,8,9,10]
06:52:17 <soysauce> yeah, doesn't work. I should get [1,3,5,6,7,8,9,10] ;)
06:52:27 <xerox> Why so?
06:52:47 <soysauce> because [1,4,5,6,7,8,9,10] != [1,3,5,6,7,8,9,10]
06:52:58 <xerox> kill 2 $ kill 2 [1..10] ==> kill 2 [1,3,4,5,6,7,8,9,10] ==> [1,4,5,6,7,8,9,10]
06:53:18 <soysauce> you could accumulate n, I suppose, which would make it feasable
06:53:41 <soysauce> hold. I have the "best" solution. ;)
06:54:13 <xerox> I do not see what you mean.
06:56:08 <shapr> Lemmih: The more I think about keeping this sort of data in the repo, the more I like it.
06:57:51 <shapr> Torrents use a python dictionary with string keys and num, string, list, or dict values. I think that same sort of structure would be perfect.
06:58:46 <shapr> Then the raw data is always available, and reconstituted when you view. You'd just add a bit of smarts to darcs.cgi
06:59:33 * shapr needs a reality check
06:59:50 <shapr> What am I missing? What are the downsides of this approach?
06:59:58 <bluejenny> what is a good reference to using Haskell to write language compilers?
07:00:10 <basti_> is it sensible to make typeclasses without a parameter?
07:00:17 <shapr> Greetings bluejenny and welcome to #haskell
07:00:29 <bluejenny> shapr, thankee
07:00:33 <shapr> bluejenny: Would you like the short tour of #haskell and Haskell?
07:00:51 <eivuokko> shapr, bugs in repo?
07:01:08 <shapr> eivuokko: How is that a downside?
07:01:11 <eivuokko> shapr, The downside on big projects is that user submitted bugs need to validated by a person that has commit access.
07:01:18 <eivuokko> "commit"
07:01:21 <shapr> eivuokko: They are...
07:01:28 <shapr> eivuokko: You submit bugs to *your* repo.
07:01:48 <Lemmih> basti_: I don't think so.
07:01:56 <soysauce> @type let nop = x y zs -> map id zs; dead n xs = nop n -1 xs in dead 4 [1 .. 4]
07:01:57 <lambdabot> parse error on input `->'
07:02:06 <soysauce> @type let nop x y zs = map id zs; dead n xs = nop n -1 xs in dead 4 [1 .. 4]
07:02:06 <lambdabot> forall a t a1.
07:02:06 <lambdabot> (Num a,
07:02:06 <lambdabot> Enum a,
07:02:06 <lambdabot> Num (t -> [a1] -> [a1]),
07:02:06 <lambdabot> Num ([a] -> t -> [a1] -> [a1])) =>
07:02:09 <lambdabot> t -> [a1] -> [a1]
07:02:15 <eivuokko> Yeah, well, assume user doesn't have darcs.  He will send mail or fill out form.  Someone needs to check that out.
07:02:34 <bluejenny> shapr, um, sure
07:02:36 <eivuokko> In practice that problem exist with normal bugtrackers, too
07:02:45 <shapr> eivuokko: I'll come back to that after the tour.
07:03:04 <shapr> bluejenny: Ok, welcome to #haskell! The first stop on our tour is the lovely lambdabot 
07:03:16 <shapr> lambdabot is an irc bot written in Haskell, and includes quite a few nifty features.
07:03:20 <shapr> @index delete
07:03:21 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.
07:03:21 <lambdabot> Set
07:03:21 <basti_> could you call the "kind" of a variable its "typewise arity"? ;)
07:03:24 <shapr> @index sepBy
07:03:25 <lambdabot> Text.ParserCombinators.Parsec.Combinator, Text.ParserCombinators.Parsec,
07:03:25 <lambdabot> Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
07:03:27 <shapr> @type map
07:03:28 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
07:03:54 <shapr> bluejenny: Next on our tour is the channel topic, repository of useful links for someone new to #haskell
07:04:29 <shapr> You can find links to: the learning page, the channel logs, the latest Haskell Weekly News, and much more!
07:05:06 <shapr> Next we have the Haskell wiki, container of large amounts of useful knowledge... http://www.haskell.org/hawiki/HaskellNewbie
07:05:44 <shapr> Last but not least there's the Baskin-Robbins one-spoon syntax taste for Haskell - http://www.haskell.org/hawiki/HaskellDemo
07:05:48 <soysauce> xerox:
07:05:57 <bluejenny> Delightful
07:06:00 <shapr> bluejenny: This concludes your short tour, if you have any questions, please ask the tour guide or one of the staff.
07:06:00 <soysauce> > let kill n xs = let (xs1, xs2) = splitAt n xs in xs1 ++ tail xs2 in kill 3 [1 .. 5]
07:06:02 <lambdabot> [1,2,3,5]
07:06:15 <soysauce> ;)
07:06:28 <soysauce> I rewrote dead to make it more efficient, too.
07:06:52 <soysauce> > let kill n xs = let (xs1, xs2) = splitAt n xs in xs1 ++ tail xs2; dead' n i xs = let i' = mod (i+n-1) (length xs) in if null xs then xs else xs!!i':dead' n i' (kill i' xs); dead n xs = dead' n 0 xs in dead 3 [1 .. 7]
07:06:53 <lambdabot> [3,6,2,7,5,1,4]
07:06:59 <bluejenny> Now all I need is HaskellEliza to answer a question about compiler writing
07:07:06 <shapr> @vixen a/s/l ?
07:07:06 <lambdabot> 19/f/California
07:07:56 <shapr> bluejenny: 'Compiler Writing' is a pretty big subject. Do you want to write a compiler for the Haskell language? How much do you know already?
07:08:30 <bluejenny> shapr, nah, more like a compiler for language X, *using* the Haskell language
07:09:31 <shapr> I'd suggest you start by writing an interpreter for language X.
07:09:39 <bluejenny> shapr, and I've read a couple of general books on compiler design, looking for any references that talk to the Haskell idiomatic way of doing it
07:09:56 <shapr> I'd suggest you start writing interpreters by learning about monads. Then you can write a module monadic interpreter.
07:10:09 <shapr> I'd suggest you start writing monads by learning lots about the pure parts of Haskell.
07:11:07 <bluejenny> fair enough
07:11:09 <shapr> bluejenny: http://haskell.readscheme.org/
07:11:36 <bluejenny> Beautiful!
07:11:36 <shapr> That has sections on compiler technology, monads, language design, and more.
07:12:00 <shapr> But you'll probably move faster if you hang out here and join the conversations.
07:12:14 <bluejenny> that is my plan
07:12:23 <bluejenny> :)
07:12:35 <shapr> Cool, do you have any other questions?
07:12:50 <bluejenny> shapr, thousands, I expect
07:12:59 <bluejenny> shapr, but will wait for a time before asking them
07:13:44 <shapr> Ok, ask when you get the urge...
07:13:47 <shapr> eivuokko: Ok, where were we?
07:13:56 <soysauce> xerox - did you see the splitAt solution?
07:14:42 <eivuokko> shapr, I am not sure :)   It seems like you were planing having bugs in repo, and how to integrate that with rest of the world.
07:15:12 <shapr> Well, the easiest way is to get the users to report bugs to developers.
07:15:34 <eivuokko> Yeah
07:15:48 <shapr> Darcs-challenged users can send mail, report, or whatever to someone with darcs.
07:15:49 <eivuokko> In practice all bugs are validated by developers anyway.
07:15:53 <shapr> Right
07:16:29 <eivuokko> In big projects, like gcc, there are people who don't really develop, but just validate bugs, tho.  But that's hardly anything new.
07:16:55 <eivuokko> Generating patches from mailing list, ala roundup/RT wouldn't be hard either, actually...
07:17:48 <shapr> If you think of either a canonical repository, or a distributed set of canonical repositories, then the bug validators would send patches to those.
07:18:12 <eivuokko> You might want to generate site with history of bugs, as sometimes closed up bugs might be removed from repo.
07:18:41 <shapr> If they're all in the repo, a partial get won't pull them, and a full get will.
07:19:04 <shapr> I don't know how darcs plans to deal with a repo like Linux and *all* of its history.
07:19:15 <eivuokko> Tags that have checkpoint
07:19:25 <shapr> In that case, why worry?
07:19:28 <shapr> It's just disk space.
07:20:07 <eivuokko> Not sure :)
07:20:07 <shapr> Other advantages of keeping bugs, wiki, and email in the repo is that they end up all being the same thing, and you don't get spam.
07:20:31 <eivuokko> Hmmm.
07:20:38 <eivuokko> Wiki in repo...man I'd love that.
07:20:44 <shapr> FLM works that way.
07:20:55 <shapr> Even better, there's no wiki server.
07:20:58 <eivuokko> The paper annotator?
07:21:01 <shapr> Yup,
07:21:16 <shapr> You run the client locally on your box, and other people pull patches from you.
07:21:21 <eivuokko> Yeah, but needs specialised software or temporary server....hmm..this start to be worth coding.
07:21:40 <shapr> What sort of specialised software?
07:22:05 <shapr> Lusers are those people who are not technically clueful enough to have a public IP address.
07:22:10 <eivuokko> I am thinking how I work....I have repo "checked out" on my machine, and I want to browse wiki offline.
07:22:19 <shapr> You're always offline.
07:22:35 <eivuokko> Yes, but I can't view wiki easily, unless you store generated pages in repo.
07:22:51 <shapr> Wiki pages are stored as source.
07:23:23 <shapr> You run a local web server with cgi, hs-plugins or whatever, and it generates the pages for your browser.
07:23:35 <shapr> Then when you've happily edited your local repository, you save all the changes.
07:23:35 <eivuokko> Normal developers don't run one :)
07:23:48 <eivuokko> (In Windows atleast)
07:23:58 <eivuokko> That is why I'd write a software for it
07:23:58 <tuomov> umm.. I don't even want to run servers on my system
07:24:11 <tuomov> so email is they way I want to let others know of my patches
07:24:13 <shapr> tuomov: You can put them on your canonical host if you prefer.
07:24:16 <eivuokko> But making a gui for wiki is easy.
07:24:38 <shapr> eivuokko: Fermat's Last Margin is a fork/extension of Flippi, the wiki written in Haskell.
07:26:19 <shapr> tuomov: You could also write an emacs mode that renders the wiki source. In any case, it's still a local filesystem wiki.
07:26:36 <tuomov> I was just referring to the lusers statement/not having a public ip
07:26:51 <tuomov> I have a public IP and I still don't want to expose any services to random ips
07:27:20 <shapr> Fair enough, let me modify my comment to say, those who do not have web hosting somewhere.
08:14:13 <xinming> @type basic
08:14:14 <lambdabot> Not in scope: `basic'
08:14:19 <xinming> @type Int
08:14:20 <lambdabot> Not in scope: data constructor `Int'
08:14:28 <xinming> @listcommands
08:14:29 <lambdabot> use listcommands [module|command], please. Modules are:
08:14:29 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
08:14:29 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
08:14:29 <lambdabot> topic type version vixen where
08:14:35 <xinming> @base type
08:14:36 <lambdabot> Maybe you meant: babel paste
08:15:04 <Lemmih> base type?
08:17:10 <xinming> yes
08:18:10 <xinming> class Name a where ... I wonder what a what is a short for. Just Int Bool Float and Integer?
08:18:30 <Lemmih> It can be anything.
08:20:02 <xinming> hmm, for example, if there is an "Int" and a string, and I wish to compare the string against Int, What the instance declaration is then?
08:20:40 <basti_> xinming: maybe you should convert explicitely?
08:21:01 <xinming> instance (Eq a, String_to_int a) => Myeq where
08:21:02 <xinming> right?
08:21:15 <chris2> what is the difference between Int and Integer, btw?
08:21:24 <basti_> uhmm
08:21:29 <basti_> what do you want to express?
08:21:38 <basti_> chris2: Int is "hardware" int (32 or 64 or whatever), Integer is arbitary precision
08:21:44 <chris2> i see
08:21:53 <Lemmih> chris2: Int has a precision of 29-32 bits, Integer has infinite precision.
08:22:01 <xinming> basti_: I just wonder how to do things in haskell, I am still in confusion about class, but not much for now.
08:22:24 <basti_> xinming: you want to see Strings as numbers?
08:22:40 <xinming> basti_: No, I want to know how to write the declaration.
08:22:46 <xinming> basti_: read can do this.
08:22:59 <basti_> yes
08:23:07 <basti_> but where do you want to make the translation?
08:23:34 <Heffalump> Lemmih: Int has a precision of 29 bits up
08:23:41 <Lemmih> right.
08:24:21 <basti_> xinming: for every "compare" or for every function that uses "numbers"
08:24:55 * Lemmih looks forward to the day where he can afford one of those fancy 64-bit machines he keeps hearing about.
08:25:00 <xinming> basti_: hmm, Just like, If I wish to write a class which can compare Int and a "string", how to write the `class content` and the `instance content`
08:25:40 <basti_> xinming: your request is ill-defined ^^
08:25:56 <xinming> hmm, I don't mean the implementation, I just mean the constraint
08:26:54 <basti_> that'd probably be something like class MyCompare a b where...
08:27:08 <basti_> because it's 2 different types in the end
08:27:37 <basti_> and then instance (Num a)=>(a,String) where ...
08:27:43 <basti_> or something
08:28:11 <Lemmih> xinming: Why do you want to make a class for comparing different types?
08:28:44 <xinming> basti_: and then, instance MyCompare (Bool a) => (a, String) where...
08:28:52 * xinming kisses basti_ ...
08:29:01 <xinming> haha, It's clear to me now
08:29:03 <basti_> whats "Bool a"?
08:29:18 <basti_> uhm, honey, please, not in public
08:29:31 <xinming> Lemmih: I just wish to know the grammar. As It's too difficult to understand just reading the book.
08:30:49 <xinming> basti_: hmm, for bool, we also need the definition. :-)
08:31:08 <xinming> basti_: One is for String, another is for Bool value.
08:31:14 <basti_> xinming: whats a bool type?
08:31:20 <basti_> as opposed to Bool?
08:31:22 <xinming> :-/
08:31:38 <basti_> ("THE bool type")
08:32:30 <xinming> basti_: thanks anyway, I need to go on reading. This stops me from going on, But I will read on. there are still many things I don't understand
08:33:32 <basti_> you could: instance (Num a) => MyCompare (Bool,a) where
08:33:50 <basti_> or something
08:34:46 <xinming> does => means inherit?
08:34:59 <basti_> something similar ^^
08:35:19 <xerox> xinming: it constrains the 'a' to be Nums
08:36:51 * xinming falls into confusion. go for reading. :-/
08:37:53 * basti_ locks xinming inside the precedent
08:40:25 <basti_> noone got it?
08:44:48 <flodin> x::xs is O(1) right?
08:46:04 <Heffalump> flodin: yes
08:46:41 <flodin> then i wonder... how do implementations usually handle add_split lst x y = (x::lst, y::lst)
08:47:20 <flodin> since the operation is O(1), there can't be two copies of the list
08:47:49 <flodin> but yet, we now have created two different lists
08:48:12 <sjanssen> flodin: Haskell takes advantage of the fact that the lists are immutable
08:48:14 <greenrd> What is x::lst ?
08:48:19 <greenrd> Don't you mean x:lst ?
08:48:24 <flodin> er, yeah sorry
08:48:46 <flodin> it's been a few months
08:49:34 <sjanssen> flodin: do you catch my drift?
08:51:58 <flodin> sjanssen: yeah i understood as much. I'm really asking because i'm implementing something with similar constraints in a different language, and i need to do it efficiently
08:52:28 <flodin> the way it is now i've got linked lists where the tail can be shared between two lists
08:52:37 <xerox> Sounds reasonable.
08:52:38 <flodin> and i have to keep a use-count for each "run" of elements
08:54:25 <sjanssen> flodin: Haskell is largely the same, however Haskell would use true garbage collection rather than refcounting
08:58:53 <moonlite_> are there anything like sleep or delay in haskell?
08:59:19 <xerox> @index sleep
08:59:20 <lambdabot> System.Posix.Unistd, System.Posix
08:59:26 <xerox> @type System.Posix.sleep
08:59:27 <lambdabot> Int -> IO Int
08:59:36 <xerox> @docs System.Posix
08:59:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix.html
08:59:58 <xinming> which class foldr belongs to?
09:00:05 <moonlite_> thx
09:00:10 <xerox> @index foldr
09:00:10 <lambdabot> Data.List, Prelude
09:00:19 <xerox> Do you mean which Module?  It is Data.List.
09:00:25 <xerox> moonlite_: you're welcome.
09:01:10 <xinming> @type foldr
09:01:11 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
09:02:58 <xinming> the type for foldr is `foldr :: (a -> b -> b) -> b -> [a] -> b` But while I try this, renamed foldr to different name in my file, It will emit an warning
09:03:08 <xinming>  Warning: Pattern match(es) are overlapped
09:03:08 <xinming>              In the definition of `toString': toString _ = ...
09:03:25 <greenrd> It would be nice if there was a way to avoid having to insert lots of liftMs etc. through a complicated recursive function, after you realised that the function had to return a monad not a value
09:03:27 <xerox> What's the actual definition, xinming?
09:04:04 <greenrd> "aspect-oriented monads" perhaps...
09:06:07 <xinming> Sorry for my carelessness, It's gnoe after I delete all my other test code.
09:06:49 <xerox> Don't worry.
09:07:28 <greenrd> It probably means you have specified your patterns in the wrong order
09:07:50 <greenrd> the most specific patterns should be first
09:09:09 <Lemmih> moonlite_: There's also 'threadDelay'.
09:09:58 <moonlite_> Lemmih: ok thx!
09:11:39 <soysauce> xerox - did you see the solution I posted, BTW?
09:11:44 <soysauce> it's not exactly relevant, but
09:11:44 <xerox> soysauce: yes I did
09:11:48 <soysauce> it's "optimal"
09:12:17 <xerox> I didn't understand what was wrong with kill, anyway.
09:13:15 <soysauce> well, nothing, except that dead has to keep state if you don't keep it using kill
09:15:07 <xerox> I fear that dead could use some 'a priori' known pattern to do its work.
09:17:13 <soysauce> I'm pretty sure that it can
09:17:49 <soysauce> the type needs to be :: (a -> b -> (a, b)) -> a -> [b] -> [b]
09:17:52 <soysauce> or something to that effect
09:18:04 <soysauce> scan with a state parameter, essentially
09:19:32 <xerox> Can't you use:
09:19:34 <xerox> @type scanl
09:19:36 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
09:19:40 <xerox> With a = some tuple ?
09:29:12 <soysauce> oh, true
09:29:15 <soysauce> and then map fst
09:29:46 <soysauce> or snd, whichever way you want to do it
09:31:27 <xerox> Yup.
09:32:40 <ricebowl> any idea where I can find the implementation of fromIntegral? I want to change it.
09:32:53 <ricebowl> trying to find GHC's implementation of Prelude...
09:33:05 <xerox> haha.
09:33:09 <ricebowl> ?
09:33:38 <xerox> Two options, a. discuss about it; b. import Prelude hiding (fromIntegral) and roll up your own.
09:33:51 <ricebowl> no, I mean in the source for GHC
09:33:51 <xerox> The third option seemed weird, that's all.
09:33:54 <integral> @libsrc Prelude
09:34:21 <ricebowl> well, I don't remember exactly what I was looking for.
09:34:36 <ricebowl> we were talking this morning about how (+) :: Word64 -> Word64 -> Word64 is really slow
09:34:41 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
09:34:49 <ricebowl> the conversion from Word64 to Int64 is not free and ought to be
09:35:49 <ricebowl> so anyway, I wanted to hop in and get my hands dirty.
09:35:53 <ricebowl> and that's a good place to start.
09:36:10 <ricebowl> am checking out the repository as we speak ;)
09:43:46 <Heffalump> is that darcs repo tracking GHC CVS?
09:44:06 <ricebowl> no idea. It's whatever is on SF.
09:45:48 <Cale> xerox: hey, did you get my message?
09:45:55 <ricebowl> heh, I don't understand how this even works
09:46:02 <ricebowl> oh, nevermind
09:46:04 * ricebowl smacks self
09:46:23 <ricebowl> thought there was a bug in multiply
09:46:49 <Cale> Word64 -> Int64 should be free?
09:47:08 <xerox> Cale: I didn't where was it?
09:47:08 <ricebowl> sorry; Word64# -> Int64# should be free
09:47:52 <Cale> xerox: just about your easy-to-use cairo thing :)
09:48:10 <xerox> Cale: please tell me, I didn't see it :-(
09:48:39 <Cale> Just that it's cool and we ought to develop it some more and add it to the library.
09:49:08 <xerox> I think so too.
09:49:28 <Cale> It's actually hard to find graphics libraries in any programming language which have that low of a startup cost.
09:49:43 <xerox> Agreed completely :-)
09:51:20 <Cale> I was thinking about adding animations :)
09:51:42 <xerox> Uh
09:51:51 <xerox> A-la Mathematica?
09:52:10 <Cale> (Time -> Render ()) -> IO ()
09:52:48 <xerox> This supposes some extra-state as IOrefs or something ?
09:52:54 <Cale> Possibly
09:53:21 <Cale> We'd need a timer
09:53:38 <Cale> Does GTK have a timer widget?
09:53:52 <xerox> So it's the Render action which is function of time.
09:53:55 <xerox> I like it.
09:53:57 <Cale> yeah
09:53:59 <xerox> Yes, I think it has.
09:54:09 <Cale> Interactivity can wait though :)
09:54:43 <xerox> Hmm, can one simply enough parametrize it on other 'variables' in the very sense of the word?
09:54:51 <xerox> Ah, you read my mind.
09:55:28 <Cale> Well, events are sort of different -- you could try to, but really you're going to want to eventually expose the event hooks from GTK in some nice friendly way
09:55:50 <Cale> hmmm :)
09:55:52 <xerox> I see.
09:56:20 <ricebowl> I should be able to test my changes by replacing Word.hi in the GHC install directory, yes?
09:56:29 <PaulKing> how can I tell ghc to import module from local directory?
09:56:31 <ricebowl> how do I get GHC to generate a .hi file? I see only options for .c, .s, .o, etc.
09:56:32 <xerox> I was wondering about a L-tree moving with the wind, whose speed is adjusted by some kind of GTK bar in realtime ;-)
09:56:37 <Heffalump> you'll need to replace a .o file too somewhere
09:56:45 <ricebowl> PaulKing - "import <foo>;" in your source file, or do you mean GHCi?
09:56:47 <Heffalump> GHC will make a .hi file when it makes the .o file
09:56:52 <Heffalump> .hi is just an interface specification
09:56:54 * xerox faces reality and stops dreaming
09:56:55 <Heffalump> .o is the object
09:56:56 <ricebowl> Heffalump - ah, I see
09:56:59 <ricebowl> thanks
09:57:05 <PaulKing> ricebowl: nope, just ghc -o test test.hs
09:57:08 <Cale> xerox: :)
09:57:13 <Heffalump> (you may find the the .o files are hidden inside a .a somewhere)
09:57:25 <Cale> xerox: I don't think it would be too hard
09:57:33 <ricebowl> PaulKing - then you should use an import statement in your source file
09:57:35 <Heffalump> I suggest you first implement your own type, then work out how to replace the standard library type with it
09:57:40 <ricebowl> Heffalump - no doubt
09:57:45 <PaulKing> ricebowl: test.hs:3:7: parse error on input `<'
09:57:47 <ricebowl> Heffalump - erm, no need?
09:57:55 <PaulKing> <foo> wasn't a good idea
09:58:01 <Heffalump> I just think it might be easier. Your choice :-)
09:58:05 <Cale> xerox: the hardest part is figuring out what you want the wind to do :)
09:58:08 <ricebowl> Heffalump - I optimized some of the Word64 primitives so that they don't do unnecessary conversions
09:58:21 <ricebowl> PaulKing - yes, right, I meant that you should replace that with the appropriate module name :p
09:58:26 <ricebowl> PaulKing - what are you trying to do?
09:58:33 <Heffalump> yeah, you said. I was just suggesting it might be easier to test this by making your own type, rather than trying to replace the standard library one/
09:58:40 <xerox> Cale: you think so?
09:58:51 <ricebowl> Heffalump - ah, I see, that's true
09:58:58 <xerox> Cale: I mean, yes sure, but what about the implementation of those concurrent events?
09:59:49 <Cale> xerox: ah, hmm -- wanting to keep the tree moving while you drag the bar :)
09:59:50 <PaulKing> ricebowl: it was module name previously, but it could't find it, this module .hs file is in current directory
10:00:02 <xerox> Cale: point!
10:00:09 <Cale> I still don't think it should be impossible :)
10:00:18 <ricebowl> PaulKing - need more details
10:00:26 * xerox notes the word 'impossible' showed up, though ;-)
10:00:26 <mentomorph> Can guards be used in a do construct ?
10:00:32 <Cale> doesn't gtk2hs work fine with multiple lightweight threads?
10:00:55 <ricebowl> mentomorph - man kan alltid anvnda "if then else"
10:01:03 <Cale> actually, you should really even need that much
10:01:07 <PaulKing> ricebowl: after the news, it's 19:00 here
10:01:08 <Cale> this is all event driven
10:01:09 <xerox> We need dcoutts for a precise answer, but I would say yes, given that famous document by him.
10:01:23 <Cale> you could do this in one thread
10:01:27 <Cale> I think
10:01:58 <Cale> depends if the timer stops while the user is moving the slider widget
10:02:04 <Cale> that would be annoying
10:02:05 <xerox> HMM, you're probably right, depending on how the "bar" works programmatically.
10:02:11 <ricebowl> PaulKing - sure
10:02:22 <xerox> It would, indeed.
10:04:51 <Cale> xerox: the other comment which I had is that there should be a library of nice drawing primitives
10:05:27 <xerox> Like 'circle' by center and radius, and so on?
10:05:43 <Cale> yeah, and regular polygons, stars, spirals, etc.
10:06:05 <xerox> Sounds fun :-)
10:06:06 <Cale> rounded polygons and stars too :)
10:06:14 <xerox> Sounds dirty :-P
10:06:23 <Cale> can't be that bad
10:06:26 <Cale> you have arcs
10:06:36 <xerox> At least, yep.
10:06:51 <Cale> do you have inkscape?
10:07:00 <xerox> I wonder if we'll have to do calculation with unboxed values, and such.
10:07:10 <xerox> Yes, I do.
10:07:22 <Cale> play around with the star tool :)
10:07:29 <Cale> should give some ideas :)
10:08:27 <xerox> I was using it today, for a problem I'd like to pose to you too, but later.  I was wondering if there's a way 'snap' things to other things, like say, squares to hexagon's vertices.
10:08:55 <Cale> in inkscape?
10:08:59 <xerox> Yep
10:10:06 <Cale> Unfortunately, I'm not really sure. You could place a couple guides at the vertex
10:10:11 <xerox> http://img499.imageshack.us/my.php?image=boh1qf.png
10:10:15 <Cale> It really needs smart guides though
10:10:23 <xerox> To do something like this, which I did by hand, unfortunately.
10:10:35 <Cale> aha
10:10:43 <xerox> :-D
10:12:46 <Cale> well, there's an exact rotation tool, anyway
10:12:53 <xerox> Right.
10:15:37 <soysauce> oy
10:15:46 <soysauce> trying to extract the Word64 implementation is a royal PITA
10:19:28 <ricebowl> @type error
10:19:28 <lambdabot> forall a. [Char] -> a
10:23:08 <joelr1> howdy
10:23:17 <joelr1> how do i set up a monadic any?
10:23:21 <joelr1> @index any
10:23:21 <lambdabot> Data.List, Prelude
10:23:29 <joelr1> @hoogle any
10:23:29 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
10:23:29 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
10:23:29 <lambdabot> Network.Socket.aNY_PORT :: PortNumber
10:23:49 <joelr1> to take in a (a -> m Bool)
10:24:11 <joelr1> err, the other way, hmm, i got it actually
10:24:20 <joelr1> never mind. just the mere fact of asking helped!
10:24:42 <xerox> Ah-ha, it happens some times!
10:24:57 <joelr1> but
10:25:05 <Cale> xerox: you can get that by starting with a hexagon and a rounded rectangle, perferably solid shaded, and slightly translucent, and copy/pasting them, rotating by 60 degrees, and then lining up the hexagon a bunch of times
10:25:10 <joelr1> is there a shortcut to unlift a -> m Bool to bool?
10:25:15 <joelr1> return?
10:25:32 <Cale> you can use align & distribute to align the first ones
10:25:58 <Cale> hm?
10:26:07 <Cale> (a -> m Bool) -> Bool?
10:26:19 <joelr1> yes, like that
10:26:28 <Cale> no, that can't be possible in general
10:26:41 <joelr1> wouldn't return do the trick?
10:26:55 <joelr1> no, i guess not
10:27:29 <Cale> you're missing two things, a value of type 'a' needed to apply the parameter function, and a function m Bool -> Bool
10:27:45 <joelr1> ok. i have
10:27:47 <Cale> which you can't have in general, since monads are one-way
10:27:54 <joelr1> tryTakeSeat :: [Word8] -> Word8 -> ScriptState Bool
10:28:11 <joelr1> i want to use that with any over a list
10:29:35 <Cale> Would you be okay with an (a -> m Bool) -> [a] -> m Bool?
10:29:56 <joelr1> sure
10:29:57 <PaulKing> ricebowl: I've found the reason
10:30:02 <ricebowl> PaulKing - yes?
10:30:14 <joelr1> i just want to go through the list and exit as soon as a true is returned
10:30:26 <PaulKing> ricebowl: there was an error in imported module, but ghc thrown an error that it can't find the module
10:30:36 <ricebowl> @type liftM all
10:30:36 <lambdabot> Not in scope: `liftM'
10:30:41 <ricebowl> @type Monad.liftM all
10:30:41 <lambdabot> forall a (m :: * -> *).
10:30:41 <lambdabot> (Monad m) =>
10:30:41 <lambdabot> m (a -> Bool) -> m ([a] -> Bool)
10:30:56 <PaulKing> ricebowl: after I've fixed it, ghc is able to find the module
10:30:58 <ricebowl> oh, d'oh
10:31:13 <PaulKing> but I have another problem
10:31:20 <ricebowl> @type flip (>>=) all
10:31:21 <lambdabot> forall a. (Monad ((->) [a])) => ([a] -> a -> Bool) -> [a] -> Bool
10:31:22 <Korollary> joelr1: so you have a [Word8], and a function (Word8 -> m Bool) ?
10:31:38 <PaulKing> test.hs:6:17:    Couldn't match `Foreign.C.String.CString' against `[Char]'
10:31:39 <ricebowl> @type (flip (>>=)) all
10:31:40 <lambdabot> forall a. (Monad ((->) [a])) => ([a] -> a -> Bool) -> [a] -> Bool
10:31:48 <joelr1> yes
10:31:49 <xerox> Cale: yep, that's a way.
10:31:53 <ricebowl> PaulKing - you're going to have to paste it
10:31:53 <joelr1> Korollary: like that
10:32:07 <PaulKing> how can I pass a string to C function?
10:32:11 <basti_> wow whats goin on? ^^
10:32:15 * ricebowl does not know
10:32:18 <Lemmih> @index peekCString
10:32:18 <lambdabot> Foreign.C.String, Foreign.C
10:32:25 <Lemmih> @type Foreign.C.String.peekCString
10:32:26 <lambdabot> Foreign.C.String.CString -> IO String
10:32:31 <Cale> aha
10:32:43 <PaulKing> I've used: import CForeign (CInt, CString)
10:32:48 <Cale> @type fmap any . sequence
10:32:50 <lambdabot>   Couldn't match `a -> Bool' against `[a1]'
10:32:50 <lambdabot>   Expected type: [m a1] -> m (a -> Bool)
10:33:00 <Cale> oops :)
10:33:00 <joelr1> hmm
10:33:06 <joelr1> it's actually tryTakeSeat :: [Word8] -> Word8 -> ScriptState Bool
10:33:16 <Cale> @type fmap any p . sequence
10:33:18 <lambdabot> Not in scope: `p'
10:33:18 <joelr1> but it's still a "predicate"
10:33:22 <Lemmih> PaulKing: There's also 'newCString :: String -> IO CString'
10:33:27 <Cale> @type fmap (any undefined) . sequence
10:33:28 <lambdabot> forall (m :: * -> *) a. (Functor m, Monad m) => [m a] -> m Bool
10:33:33 <Cale> yes
10:33:35 <joelr1> i would use it as a partial function application
10:33:43 <Lemmih> @docs Foreign.C.String
10:33:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html
10:33:48 <Cale> of course, you need to put a predicate where I put undefined :)
10:33:59 <Cale> @type \p -> fmap (any p) . sequence
10:34:00 <lambdabot> forall (m :: * -> *) a.
10:34:00 <lambdabot> (Functor m, Monad m) =>
10:34:00 <lambdabot> (a -> Bool) -> [m a] -> m Bool
10:34:10 <Cale> but that's not a -> m Bool
10:34:21 <Cale> oh
10:34:24 <PaulKing> Lemmih: hope garbage collector will destroy the string after C function is finished
10:34:30 <Cale> @type fmap or . sequence
10:34:31 <lambdabot> forall (m :: * -> *). (Functor m, Monad m) => [m Bool] -> m Bool
10:34:34 <Cale> aha
10:34:40 <Lemmih> PaulKing: It won't.
10:34:45 <Cale> that's it :)
10:34:50 <joelr1> Cale: or?
10:34:58 <Lemmih> PaulKing: Use 'withCString' if you want it to.
10:35:08 <PaulKing> Lemmih: I'll try, thanx
10:35:08 <Cale> > or [False, False, False]
10:35:09 <lambdabot> False
10:35:15 <Cale> > or [False, True, False]
10:35:16 <lambdabot> True
10:35:29 <joelr1> Cale: so it would stop at the first true?
10:35:33 <Cale> yeah
10:35:41 <joelr1> Cale: but how do i use my own predicate with that?
10:35:59 <Korollary> joelr1: put the predicates in the list
10:36:02 <Cale> map your a -> m Bool over the list of a's
10:36:39 <xerox> Monad m => m Bool is frightening.
10:36:42 <joelr1> Cale: i cannot map it, i need to apply to the first, check result, continue if false
10:36:45 <joelr1> return false on an empty list
10:36:53 <xerox> Monad m => m Bool sound like politics.  That is.
10:36:56 <SamB> its not really frightening.
10:36:57 <joelr1> but i guess that's not a task for any, etc.
10:37:06 <SamB> whats not nice is that you can't use if on it!
10:37:11 <Cale> joelr1: this is a lazy language
10:37:29 <xerox> SamB: you can, submitting to the rules of the monadic world.
10:37:35 <Cale> mapping a function over a list doesn't actually "do" anything
10:37:52 <Cale> (at least, right away)
10:38:01 <SamB> xerox: well its annoying to have to bind the Bool to a name first
10:38:10 <joelr1> Cale: ok, so fmap or $ map ....
10:38:10 <SamB> joelr1: whats the problem?
10:38:29 <Cale> we want an (a -> m Bool) -> [a] -> m Bool
10:38:29 <xerox> SamB: it depends, you can still use arguments-position-wise functions with >>=, for instance.
10:38:32 <joelr1> SamB: a silly one, sorry
10:38:55 <SamB> xerox: well, if, in case you hadn't noticed, isn't a function...
10:38:58 <SamB> nor is case
10:39:02 <Cale> @type \f xs -> (fmap or . sequence) (map f xs)
10:39:03 <lambdabot> forall (m :: * -> *) a.
10:39:03 <lambdabot> (Functor m, Monad m) =>
10:39:03 <lambdabot> (a -> m Bool) -> [a] -> m Bool
10:39:25 <xerox> SamB: that's right.  I suppose there is if' too, but whatever.
10:39:29 <joelr1> ah, got it now
10:39:34 <SamB> @type if'
10:39:35 <lambdabot> Not in scope: `if''
10:39:38 <SamB> @index if'
10:39:39 <lambdabot> bzzt
10:39:42 <SamB> if'?
10:39:45 <Cale> If that doesn't have the right semantics, let me know
10:39:50 <xerox> SamB: I mean the one @pl shouts at times
10:39:57 <joelr1> checking
10:40:05 <Cale> if' i t e = if i then t else e
10:40:17 <Cale> that's a folklore-function
10:40:17 <SamB> @pl \x y z -> if x then y else z
10:40:18 <lambdabot> if'
10:40:20 <dcoutts> xerox, Cale, what was the threading question exactly?
10:40:26 <SamB> @help pl
10:40:27 <lambdabot>  @pointless <expr> - play with pointfree code
10:40:45 <SamB> @help if'
10:40:46 <lambdabot>  @help <command> - ask for help for <command>
10:41:15 <Cale> dcoutts: whether you'd need threads to have an L-system tree animated, and the speed of that animation controlled by a slider control
10:41:17 <SamB> huh
10:41:35 <xerox> Someone generalized my idea, oh.. those mathematicians ;-)
10:41:37 <SamB> well, it would be nicer if if' was in the library
10:42:11 <dcoutts> Cale, it can use threads but it's not necessary. You can use Gtk+ timers.
10:42:39 <joelr1> @type or . sequence
10:42:39 <lambdabot>   Couldn't match `Bool' against `[a]'
10:42:39 <lambdabot>   Expected type: [[a]] -> [Bool]
10:43:00 <Cale> dcoutts: I thought so :)
10:43:26 <Cale> xerox: which idea?
10:43:53 <xerox> Cale: the answer my friend, is blowing in the wind
10:43:58 <joelr1> layout sucks sometimes
10:43:59 <joelr1>        if (not taken)
10:43:59 <joelr1>        then takeEmpty aff_id rest
10:43:59 <joelr1>        else return ()
10:44:12 <joelr1> why do i get an indentation error on this?
10:44:39 <Cale> then and else aren't indented more than if
10:44:49 <joelr1> that's emacs
10:44:55 <joelr1> ah, understood
10:45:05 <Cale> so they're new lines on the same level when they should be part of the if-expression
10:45:09 <joelr1> gotta look at the haskell mode
10:45:35 <basti_> the haskell mode for emacs sucks though 
10:45:36 <dcoutts> Cale, yeah, for simple animation I just user Gtk+ timers.
10:45:53 <dcoutts> Cale, the other advantage of that is that it scales with the drawing time.
10:46:24 <dcoutts> Cale, because you can adjust the timer priority to be lower than the screen re-draw priority
10:48:07 <Cale> dcoutts: are we talking about timeoutAdd/timeoutAddFull?
10:48:20 <dcoutts> Cale, yes
10:48:39 <Cale> okay
10:49:52 <Cale> We'll also have to keep track of time ourselves, but that's okay :)
10:50:30 <joelr1> basti_: why do you say so?
10:50:40 <Cale> what is the Int passed to timeoutAdd? Presumably it's the interval, but what is it measured in?
10:50:44 <joelr1> basti_: i actually like it and it has improved a  bit with the latest release
10:50:45 <basti_> joelr1: the automatic indentation is fubar
10:51:03 <joelr1> basti_: nah, not so
10:51:09 <joelr1> dcoutts: are you writing a game?
10:51:09 <basti_> yes it is -poit-
10:51:27 <dcoutts> joelr1, no not particularly
10:51:27 * joelr1 wonders if writing games in haskell is a fruitful endeavor
10:51:44 <dcoutts> well one can use opengl
10:51:56 <dcoutts> or SDL
10:52:00 <Cale> joelr1: I recall that a quake-like game was written in Haskell as a research project and it worked out okay
10:52:21 <joelr1> dcoutts: right
10:52:24 <Korollary> If it's an RPG kind of game, or RTS, writing the rules or a/i could be good in haskell.
10:52:50 <joelr1> dcoutts: but i would hook up haskell to Ogre 3D, Torque or something like that
10:53:03 <vegai> I wonder where the must game project for every platform, a mmorpg, is hiding
10:53:12 * dcoutts does not know much about computer games
10:53:18 <Cale> joelr1: that would require a nontrivial amount of binding work
10:53:42 <joelr1> Cale: but the result would be worth more than rolling your own game engine in haskell... probably. 
10:53:46 <joelr1> differently worth
10:54:02 <joelr1> but writing a game engine in haskell is a huge deal on its own
10:54:36 <Cale> joelr1: almost certainly you'd get decent performance and a reasonable API, but you wouldn't get an ideal API, most likely, without quite a lot of work.
10:54:36 <joelr1> maybe after i get concurrent haskell down pat (and my networking project) i could take a look at that
10:54:37 <Korollary> why must every project be a one man project anyway
10:55:00 <joelr1> Korollary: it does nto have to be
10:55:28 <joelr1> but sometimes it's hard to find another person with a similar amount of spare time, appetite for risk, etc.
10:55:58 <joelr1> if you were writing a cross-platform gui these days would you write it in wxHaskell or GtkHS?
10:56:03 <joelr1> Gtk2HS
10:56:13 <PaulKing> how can I check if Foreign.Ptr is NULL?
10:57:25 <ski_> joelr1 :   unless taken $ takeEmpty aff_id rest
10:57:39 <SamB> `withForeignPtr` (==nullPtr)
10:58:14 <SamB> er.
10:58:15 <SamB> not quite
10:58:32 <ski_> @type Control.Monad.unless
10:58:32 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:58:34 <joelr1> ski_: thanks
10:58:38 <PaulKing> SamB: so?
10:58:47 <ski_> often indented like
10:58:52 <ski_>    unless taken $
10:58:55 <ski_>      ...
10:58:56 <SamB> PaulKing: well, you'd probably use withForeignPtr at least
10:59:26 <ski_> (with a 'do' possibly after '$')
11:00:01 <joelr1> i'm trying to decide whether i should write a mac-only app (i would love that) or go with wxHaskell or Gtk2HS and be cross-platform from the start
11:00:22 <SamB> (`withForeignPtr` (\p -> return (p == nullPtr)))
11:00:25 <xerox> Or being modular enough...
11:00:35 <SamB> @pl (`withForeignPtr` (\p -> return (p == nullPtr)))
11:00:36 <lambdabot> (`withForeignPtr` (return . (nullPtr ==)))
11:01:35 <SamB> joelr1: hmm, how well does GTK work on OS X?
11:01:43 <SamB> not well, afaik
11:01:59 <joelr1> SamB: beats me. i think they do have a Cocoa renderer these days so you don't need to launch the X emulator
11:02:27 <SamB> joelr1: but does it have an Aqua look/feel?
11:02:34 <SamB> especially the latter?
11:03:09 <joelr1> SamB: within limits, i think. i.e. i doubt they provide all the controls, etc.
11:03:09 <SamB> PaulKing: you got that?
11:03:17 <SamB> well yeah
11:03:30 <joelr1> SamB: assuming that it's true and Gtk2Hs indeed has a Cocoa backend now
11:03:38 <joelr1> SamB: are you on Mac OSX?
11:03:42 <SamB> joelr1: no
11:03:48 <joelr1> ok
11:04:07 <SamB> but if someone sent me a box I'd happily accept it
11:04:31 <SamB> or whatever you call an apple computer
11:04:39 <SamB> not sure box is the right word ;-)
11:04:59 <Korollary> crate maybe ?
11:05:15 <xerox> Evil artifact
11:05:24 <SamB> no. I'm referring to the curvy exteriors...
11:05:37 <SamB> xerox: evil?
11:05:53 <SamB> come on! its not evil, its just expensive!
11:06:05 <joelr1> hehe
11:06:55 <ricebowl> who was talking to me earlier about optimizing Word64?
11:07:22 <ricebowl> I think I was fairly successful.
11:07:24 <ricebowl> test1                          Main                  52.8  100.0
11:07:24 <ricebowl> test3                          Main                  23.6    0.0
11:07:24 <ricebowl> test2                          Main                  23.5    0.0
11:07:24 <xerox> It crawls into the mind from the two spots in the front of the human body called eyes, and rapidly break inside, causing some troubles to the own buyer's mood.
11:07:43 <ricebowl> test1 = Word64, test2 = Word64' (optimized version), test3 = Int64
11:08:00 <ricebowl> Word64 primitve ops are now approximately twice as fast, heh!
11:08:14 <SamB> ricebowl: you hack GHC or something?
11:08:28 <ricebowl> SamB - I was messing with Word.hs
11:08:34 <SamB> ah
11:08:44 <SamB> does it still work?
11:09:17 <Lemmih> ricebowl: How does it perform compared to Int?
11:09:17 <ricebowl> good question, but I would presume so. One moment.
11:09:21 <ricebowl> Lemmih - abysmal ;)
11:09:40 <ricebowl> there was a test4 which performed the same operations but used Int.
11:09:50 <ricebowl> it doesn't even show up in the profiler output
11:10:56 * Lemmih wonders why JaffaCake stopped hanging out in #haskell.
11:12:11 <xerox> @seen JaffaCake
11:12:12 <lambdabot> I haven't seen JaffaCake.
11:13:27 <ricebowl> @type map show
11:13:28 <lambdabot> forall a. (Show a) => [a] -> [String]
11:13:34 <ricebowl> hm, strange
11:13:40 <ricebowl> @eval map show [0, 1, 2]
11:13:41 <lambdabot> ["0","1","2"]
11:13:48 <ricebowl> @eval unlines (map show [0, 1, 2])
11:13:49 <lambdabot> "0\n1\n2\n"
11:14:13 <ricebowl> oh, missing parens, d'oh
11:15:49 <Heffalump> Lemmih: busy with new kid?
11:17:01 <ricebowl> Heffalump - Word64 and Int64 now have the same performance :D
11:17:04 <ricebowl> it took like... 5 minutes
11:18:06 <Heffalump> ricebowl: cool
11:18:15 <Heffalump> do you know where to send the patch?
11:18:19 <ricebowl> nope
11:19:07 * SamB wonders when musasabi will cough up the patches he was going to do last weekend
11:19:13 <ricebowl> actually it appears that my Word64 is marginally faster than Int64.
11:19:20 <ricebowl> o_O
11:19:36 <SamB> not terribly peculiar
11:20:02 <ricebowl> how not? I'm only testing (==), (+), and (-)
11:22:31 <Heffalump> that sounds like measurement error
11:22:45 <ricebowl> heh maybe GHC is doing inlining, that's the only thing I can guess
11:23:25 <ricebowl> it's a small amount, but it's consistent.
11:24:13 <dcoutts> joelr1, re: your earlier cross-platform gui question. I'm biased of course, but I'd use Gtk2Hs :-)
11:24:21 <Heffalump> ricebowl: I guess you could post the patch to glasgow-haskell-users
11:24:30 <ricebowl> ok
11:24:32 <joelr1> dcoutts: and why would that be? does it do cocoa?
11:25:15 <joelr1> dcoutts: why not wxHaskell? ;)
11:25:25 <dcoutts> joelr1, because it's got cooler graphics?
11:25:45 <dcoutts> because Gtk2Hs is not bitrotting :-)
11:26:16 <dcoutts> because it gives a consistent cross-platform API
11:26:50 <joelr1> dcoutts: what about cocoa?
11:26:56 <dcoutts> rather than the semantics of the API changing as you move from one underlying toolkit to another (as you get with wxWidgets)
11:27:46 <dcoutts> joelr1, the current versions of Gtk+ use the X server. There is a port in progress to have it work without X.
11:28:37 <joelr1> dcoutts: strange, i thought the latest gtk (2.8?) had a cocoa driver
11:28:41 <joelr1> dcoutts: but ok, thanks!
11:28:48 <dcoutts> joelr1, you mean a theme engine?
11:29:29 <dcoutts> I think the idea in the end will be for it to use the same technique as on Win32, which is..
11:30:19 <ski_> hm .. a short-circuiting monadic fold would perhaps be nice to define anyM :: Monad m => (a -> m Bool) -> ([a] -> m Bool)
11:30:45 <dcoutts> that it draws everything with the native low level graphics api of the platform (ie gdi on win32) and then matches the native theme in it's drawing style, possibly useing a platform themeing library (which is what it does on win32 too).
11:30:59 <joelr1> ski_: ;)
11:31:16 <joelr1> dcoutts: interesting
11:31:47 <dcoutts> joelr1, so it's not using the high-level widgets api of the platform but is using the themeing api.
11:31:54 <joelr1> i think i'll still to native cocoa, though, using the haskell-cocoa bridge. i always wanted to find out how such an app would sell
11:32:04 <joelr1> dcoutts: i understand
11:32:18 <ski_> Control.Monad.foldM :: Monad m => (r -> a -> m r) -> r -> [a] -> m r
11:33:10 <dcoutts> joelr1, cairo has a OSX backend that uses the native hardware accelerated api. Quartz I think.
11:33:11 <ski_> foldrM' :: Monad m => (a -> m r -> m r) -> r -> [a] -> m r  -- ?
11:33:18 <ski_> foldrM' :: Monad m => (a -> m r -> m r) -> m r -> [a] -> m r  -- ?
11:33:41 <joelr1> dcoutts: that's what i thought i read. isn't cairo gtk too?
11:33:52 <dcoutts> joelr1, gtk uses cairo.
11:33:58 <joelr1> dcoutts: or did you mean to say that this is still in development?
11:33:59 <ricebowl> Heffalump - glasgow-haskell-users@haskell.org?
11:34:10 <ricebowl> I'll do that in a bit; am trying to make sure my patch is valid
11:34:26 <dcoutts> joelr1, cairo works on OSX now. The non X11 port of Gtk+ on OSX is still in development.
11:34:28 <SamB> @where fps
11:34:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
11:34:59 <ski_> foldlM' :: Monad m => (a -> m (Either r (r -> m r))) -> r -> [a] -> m r  -- ?
11:34:59 <Heffalump> ricebowl: yeah
11:35:50 <ricebowl> ok
11:35:57 <ricebowl> hmm
11:36:04 <ricebowl> they define separate operators for words than for ints
11:36:15 <joelr1> dcoutts: i guess i just don't understand the difference. why do a non=x11 port of gtk+ when you already have cairo
11:36:21 <ski_> @hoogle Monad m => Monad m => (a -> m r -> m r) -> r -> [a] -> m r
11:36:21 <lambdabot> hoogle: Hoogle/Parser.hs:(82,8)-(85,38): Non-exhaustive patterns in
11:36:21 <lambdabot> function g
11:36:21 <lambdabot>  
11:36:29 <ski_> oops :)
11:36:44 <ski_> dons !
11:36:44 <ricebowl> maybe I should do the same, in part for consistency's sake?
11:36:52 <ski_> or, hm
11:36:54 <ski_> ndm !
11:37:04 <ndm> indeed, fixing parse errors is on the todo list :)
11:37:24 <ski_> ok, just so it's known
11:37:34 <dcoutts> joelr1, porting a windowing toolkit involves more than just porting the graphics output part of it.
11:38:02 <ski_> @hoogle Monad m => (r -> a -> m r) -> r -> [a] -> m r
11:38:03 <lambdabot> No matches, try a more general search
11:38:13 <dcoutts> joelr1, but it is easier now that Gtk+ uses cairo.
11:38:13 <ski_> @type Contol.Monad.foldM
11:38:14 <lambdabot> Couldn't find qualified module.
11:38:14 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
11:38:14 <lambdabot> \\)?
11:38:19 <ski_> @type Conrtol.Monad.foldM
11:38:20 <lambdabot> Couldn't find qualified module.
11:38:20 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
11:38:20 <lambdabot> \\)?
11:38:27 <ski_> @type Control.Monad.foldM
11:38:28 <lambdabot> forall a (m :: * -> *) b.
11:38:28 <lambdabot> (Monad m) =>
11:38:28 <lambdabot> (a -> b -> m a) -> a -> [b] -> m a
11:38:53 <ndm> ski_, there are still quite a few bugs with hoogle, some are listed on
11:38:55 <ndm> @wiki Hoogle
11:38:55 <lambdabot> http://www.haskell.org/hawiki/Hoogle
11:38:56 <joelr1> dcoutts: ok, thanks
11:39:07 <ndm> i hope to have them all fixed before Hoogle 3 goes out of beta
11:39:09 <ski_> ndm : does it search in Control.Monad ?
11:39:30 <ndm> yes, in theory...
11:40:17 <ndm> but certain searches, esp monad ones seem to annoy my thing :)
11:42:13 <ricebowl> anyone around who knows about building GHC?
11:45:00 <ricebowl> :|
11:45:32 <ricebowl> aha, nevermind.
11:48:26 <Cale> People seem to care too much that all their applications have same-looking widgets. As long as they all work well, what is the difference? Ability to share memory, I suppose is one thing.
11:48:57 <SamB> hmm, anybody have a clue why Smerdyakov would refer to shapr as an inappropriate person?
11:49:01 <kombinator> 'desktop integration' is another
11:49:09 <heatsink> Cale: probably a quality control issue.
11:49:14 <Heffalump> cale: familiarity/ease of use
11:49:23 <Heffalump> samb: long-standing row about Smerdyakov's presence on here
11:49:27 <Heffalump> what's the context?
11:49:53 <SamB> Heffalump: I mentioned on ##c that haskell had a wonderful community
11:50:10 <nuffer> can anyone help me with getting Graphics.UI.SDL to work?
11:50:17 <nuffer> I'm having trouble compiling Test.hs
11:50:18 <nuffer> I get:
11:50:21 <SamB> he claims I was here at the time of whatever incident he is referring to
11:50:25 <nuffer> gcc: unrecognized option '-rpath'
11:50:25 <nuffer> /usr/lib: file not recognized: Is a directory
11:50:25 <nuffer> collect2: ld returned 1 exit status
11:50:31 <Heffalump> it was all over a year ago
11:50:32 <nuffer> but I'm really not sure what the problem is there
11:50:34 <nuffer> any help?
11:50:47 <Cale> Well, most programs use reasonably similar ideas, and as long as, say, drag and drop and the clipboard are standard, you're not going to get much more integration with today's programs just by using the same widgets
11:51:03 <Heffalump> there were a few epsiodes of Smerdyakov being fairly negative in response to people's questions
11:51:11 <Heffalump> (verging on insulting, though not exactly that)
11:51:12 <gdfk_> Smerdyakov liked off-topic discussions about various things, though I don't know if that's the problem.
11:51:26 <heatsink> nuffer: is this with ghc?
11:51:26 <SamB> gdfk_: nah
11:51:30 <Heffalump> and shapr banned him
11:51:35 <Heffalump> (which I didn't agree with)
11:51:36 <SamB> that wouldn't be the problem, exactly
11:51:37 <musasabi> Smerdyakov created various problems and didn't help to solve them in a constructive way.
11:51:58 <kombinator> Cale: gnome provides more integration, system tray for instance
11:52:03 <SamB> ah
11:52:07 <Heffalump> musasabi: I think that's putting it a little strongly.
11:52:09 <Cale> Smerdyakov was generally grating, almost a troll, maybe not quit.e
11:52:27 <Heffalump> ok, apparently most people he deserved to be gone :-)
11:52:31 <Heffalump> s/people/people think/
11:52:34 <heatsink> nuffer: Run the compiler with the verbose flag, ghc -v and paste the output on rafb.net/paste
11:53:13 <gdfk_> You could just look at logs, probably.
11:53:13 <nuffer> http://rafb.net/paste/results/kFEDix49.html
11:53:14 <vegai> did he gloat on SML here too?
11:53:21 <Cale> kombinator: I use gnome and I've never noticed any programs using the tray. My notification area is basically always empty.
11:53:32 <Heffalump> not that I can remember
11:53:39 <Heffalump> he might have discussed it sometimes
11:53:41 <Cale> so perhaps that's an issue in and of itself
11:53:49 <gdfk_> He liked to talk a lot about his sociological and economic ideas.
11:53:53 <xerox> gaim, skype, net-status, apt-updating-thingie, rhythmbox here :-)
11:54:22 <Cale> We should standardise things like that though.
11:54:32 <Heffalump> is he still banned?
11:54:37 <Heffalump> ah, yes :-)
11:55:11 <nuffer> I mean, it's clear that the problem is that -rpath option
11:55:14 <heatsink> nuffer: It's that rpath flag, I don't know what it means
11:55:17 <nuffer> but I don't know why that's there, or what it's supposed to be
11:55:17 <heatsink> right
11:55:21 <heatsink> :)
11:55:28 <SamB> gdfk_: I'm trying ;-)
11:55:36 <kombinator> Cale: there are zillions of standards of desktop functionality, most of them ended up horribly broken
11:55:56 <gdfk_> Unfortunately I missed the part where it came to a head :(
11:56:11 <heatsink> nuffer: what happens if you remove the flag?
11:56:13 <Cale> the ones from freedesktop.org seem to be going somewhere
11:56:36 <nuffer> um, let me try
11:57:43 <nuffer> about a million undefined references
11:58:03 <nuffer> I think -rpath wants a file, not a directory
11:58:50 <nuffer> or something like that
11:58:58 <heatsink> well, "path" would suggest it's a file
11:59:06 <Cale> http://freedesktop.org/wiki/Standards_2fsystemtray_2dspec :)
11:59:18 <nuffer> er, no, nevermind, that's not right
11:59:27 <nuffer> I think it just doesn't know what to do with it
11:59:31 <heatsink> right
11:59:48 <heatsink> When you take the flag out, also take out the /usr/lib that comes after it
12:00:07 <nuffer> I did, yeah
12:00:09 <nuffer> /usr/lib/libSDL.a(Xv.o)(.text+0x1efe):Xv.c: undefined reference to `_XRead'
12:00:21 <nuffer> that looks like the problem is more in libSDL.a than anything that gcc is doing
12:01:17 <nuffer> or rather, that some flags that libSDL needs aren't being properly passed in
12:02:42 <heatsink> When I google, it looks like maybe the flag should be --rpath
12:02:52 <nuffer> okay, let me try that in a minute
12:02:58 <nuffer> I'm re-installing libSDL through yum
12:03:33 <heatsink> oh here it is... it's a linker flag
12:03:52 <nuffer> heh, it worked without the linker flag
12:03:55 <nuffer> I was missing some dependencies
12:04:03 <heatsink> ok then
12:04:17 <nuffer> now, the question is
12:04:21 <nuffer> how can I get ghc to do that by default
12:04:28 <nuffer> so I don't have to give it huge gcc commands every time?
12:04:40 <heatsink> is the rpath thing in the output of `ghc-pkg describe SDL`?
12:06:10 <nuffer> um, let me see
12:06:34 <nuffer> doesn't look like it, no
12:06:41 * SamB wishes these logs would load faster
12:06:49 <nuffer> cc-options: -I/usr/include/SDL -D_REENTRANT
12:06:49 <nuffer> ld-options: -L/usr/lib -Wl -rpath /usr/lib -lSDL
12:06:53 <heatsink> hmm, I don't know what's producing it then.
12:06:53 <SamB> gdfk_: do you have any idea what month it was?
12:07:15 <heatsink> oh, there it is.
12:07:44 <heatsink> Okay, there's a mistake there
12:07:59 <heatsink> I think that should be -Wl,"-rpath /usr/lib"
12:08:02 <kombinator> Cale: I second freedesktop's efforts, but 'desktop' is very difficoult to standarise - it's very easy to overspecify/underspecify a desktop standard. Look at X - yes, I know it's old and we are much wiser now - there are many parts which are too liberal and sloppy and even more are not used by anyone
12:08:14 * heatsink looks up the syntax
12:08:27 <nuffer> oh, I see how I was missing that
12:08:28 <nuffer> one sec
12:08:37 <nuffer> how do I edit that, by the way?
12:08:51 <nuffer> oh, and it seems to work if I remove the flag entirely, so I'm happy doing that
12:09:01 <kombinator> Cale: but I think it's possible to standarise it partially
12:09:14 <heatsink> I don't know, someone else here should know how to edit it.
12:09:54 <kombinator> ot. did anyone manage to run yhc? yhi segfaults on my AMD64 box
12:11:59 <gour> dcoutts: ping
12:14:57 <vegai> kombinator: I did
12:15:18 <vegai> kombinator: oh, how recent?
12:16:33 <Oejet> Which command makes lambdabot give suggestions for functions given their signature?
12:16:57 <kombinator> vegai: pulled from stable darcs rep
12:17:29 <vegai> they have an interpreter there?
12:17:30 <xerox> @hoogle (a -> b) -> f a -> f b
12:17:30 <vegai> gotta try.
12:17:31 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
12:17:31 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
12:17:31 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
12:17:41 <xerox> @hoogle Functor f => (a -> b) -> f a -> f b
12:17:42 <lambdabot> No matches, try a more general search
12:17:46 <vegai> hot damn, 38 patches
12:17:55 <xerox> Bah, Oejet, anyway it's @hoogle :-)
12:18:15 <kombinator> vegai: what is the name of a runtime executable? Isn't it yhi?
12:18:52 <Oejet> xerox: Thanks.
12:18:55 <kombinator> vegai: s/a runtime executable/the executable containing runtime
12:19:12 <vegai> yhc is the runtime, yhcc is the compiler
12:19:18 <vegai> ...at least when I last installed it
12:19:36 <kombinator> vegai: weird...
12:20:15 <vegai> but that's 38 patches ago, they could've changed everything :)
12:20:56 <kombinator> in inst/bin I have only yhc and yhi
12:21:33 <vegai> york.ac.uk isn't very fast to my home... or darcs has hanged
12:21:41 <vegai> oy
12:21:47 <vegai>  6708 vegai     25   0 12844 9872 3504 R 89.8  1.9   2:27.37 darcs                                                             
12:21:53 <vegai> leeching CPU
12:22:02 <kombinator> but yhc calls itself yhcc...
12:22:40 <kombinator> how did you build it? I've run configure and make AFAIR
12:24:12 <vegai> darn, conflicts
12:24:31 <ndm> kombinator: yhc is the compiler
12:24:35 <ndm> yhi is the runtime
12:24:41 <ndm> we did indeed change everything :)
12:24:55 <kombinator> ndm: yhc works fine, yhi segfaults
12:25:08 <ndm> kombinator: what arch?
12:25:13 <kombinator> amd64
12:25:17 <ndm> and stable or devel branch?
12:25:21 <kombinator> stable
12:25:38 <ndm> stable is a few weeks old now
12:25:44 <ndm> it might be work trying devel
12:25:54 <ndm> unless you have any idea why it seg faults
12:26:23 <ndm> it has been ported to amd64, and should work there
12:26:49 <kombinator> ndm: oh, and I remember that I had to change something in order to compile it...
12:27:05 <ndm> send a patch over
12:27:31 <ndm> the makefile needs some love, someones intending to work on it this week
12:27:35 <kombinator> ndm: it needs YHC_BASE_PATH to compile?
12:27:40 <nuffer> yay, got it working
12:27:42 <ndm> yes
12:28:15 <ndm> set it to the inst directory of the darcs repo
12:28:32 <ndm> set YHC_BASE_PATH=.....\inst - for example
12:30:42 <kombinator> ndm: I had to change the prototype of decodeFloat64 in definition from IntegerNode* decodeFloat64(Double f, Int* rExp){ to IntegerNode* decodeFloat64(Float64 f, Int32* rExp){
12:31:23 <ndm> i have emailed that info off to the maintainer
12:31:30 <ndm> hopefully it will be fixed soonish in teh devel branch
12:34:40 <ndm> kombinator, have you figured out yhi is seg faulting?
12:35:24 <kombinator> ndm: no, all I have is a meaningless stacktrace - is there an easy way of compiling it with -g?
12:36:03 <ndm> i compile it on windows, have never done it under linux
12:36:32 <ndm> if you send an email with any details of your problem to me
12:36:40 <ndm> ndmitchell  -AT- gmail -DOT- com
12:36:50 <ndm> then i'll pass it on to everyone tomorrow
12:37:02 <ndm> we still don't quite have a mailing list, but will get on this week hopefully
12:39:49 <kombinator> ndm: I'm building the devel branch now
12:42:10 <kombinator> @where lisppaste
12:42:11 <lambdabot> I know nothing about lisppaste.
12:42:15 <kombinator> @where paste
12:42:16 <lambdabot> http://paste.lisp.org/new/haskell
12:42:23 <basti_> lisppaste2: @url
12:42:24 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:43:15 <lisppaste2> kombinator pasted "yhi backtrace" at http://paste.lisp.org/display/13810
12:43:59 <kombinator> ndm: can you take a look at my backtrace?
12:45:59 <ndm> sure, just taking a look
12:46:59 <ndm> ok, that seems to be the instruction pointer overruning itself
12:47:12 <ndm> what code is it that you are compiling/running?
12:47:43 <xerox> Bye bye.
12:48:19 <ndm> kombinator: what code is that you are compiling/running?
12:48:53 <kombinator> main = putStrLn "Hello"
12:49:04 <ndm> with a module declaration or not?
12:49:11 <kombinator> compiles without a fuss
12:49:23 <kombinator> module Main where
12:50:10 <sebell> Does anyone know how to specify a reasonable timeout value for ghc's connectTo?
12:50:13 <ndm> works fine on my machine...
12:50:37 <ndm> what is the length of your hbc file?
12:50:39 <ndm> Main.hbc
12:50:46 <kombinator> devel branch doesn't compile on my box: yhc: Unknown preprocessor directive at line 24 in file "./NHC/FFI/CTypesExtra.hs"
12:50:47 <kombinator> include "CTypes.h"
12:51:17 <ndm> are you doing Make?
12:51:33 <ndm> that compiles the libraries as well, which don't need to be compiled, because there are premade versions in teh darcs repo
12:51:45 <kombinator> when I build yhc? yes
12:52:25 <ndm> you can ignore that error
12:52:31 <ndm> and not build the libraries at all
12:52:58 <ndm> i'm not sure how yhc plays with cpp files at the mo, it changed a while ago
12:54:19 <kombinator> now I get ERROR: couldn't find module named 'NHC/FFI/ForeignObj' from yhi
12:54:35 <kombinator> maybe it doesn't find the libs?
12:54:37 <ndm> when you started compiling
12:54:49 <ndm> actually
12:54:54 <ndm> what is your YHC_BASE_PATH?
12:55:04 <ndm> it should look in there from yhi
12:55:07 <kombinator> YHC_BASE_PATH=/home/michal/prg/haskell/yhc-devel/inst
12:55:54 <kombinator> should I copy those premade versions of libs somewhere there?
12:56:05 <ndm> the inst directory would be the right place
12:56:23 <ndm> i would expect the file in
12:56:53 <ndm> \inst\lib\yhc\packages\yhc-base\1.0\NHC\FFI
12:57:00 <ndm> to have .hi and .hbc
12:57:05 <ndm> i remember when i compiled stuff
12:57:29 <ndm> it put the .hbc in the wrong place, under prelude\NHC\FFI
12:57:34 <ndm> so you may have to move them
12:59:22 <ndm> kombinator, what files starting with ForeignObj are in \inst\lib\yhc\packages\yhc-base\1.0\NHC\FFI ?
13:00:10 <kombinator> too late:P I've just done $ cp inst/prelude/NHC/FFI/*.hbc inst/lib/yhc/packages/yhc-base/1.0/NHC/FFI
13:00:22 <kosmikus> good evening
13:00:29 <ndm> i'll check out a fresh copy tomorrow, and get it working with that
13:00:32 <ndm> kombinator: does it work now?
13:00:45 <kombinator> yhi segfaults now
13:00:52 <ndm> same stack trace?
13:01:02 <kombinator> I'll check
13:02:15 <ndm> kombinator: i can't really help much from there - outside my expertise, but mail a bug report to shackell -AT- cs.york.ac.uk
13:02:32 <ndm> he should hopefully have a fix to you by the end off tomorrow
13:03:33 <kombinator> ndm: devel branch doesn't compile now that I've uncommented -g option in Makefile...
13:05:00 <kombinator> ndm: ok, I'll email him
13:19:10 <kosmikus> everyone: HCAR is available now :)
13:19:19 <ricebowl> @hoogle building GHC
13:19:20 <lambdabot> Prelude.undefined :: a
13:19:20 <lambdabot> Test.QuickCheck.Batch.bottom :: a
13:19:20 <lambdabot> Prelude.id :: a -> a
13:19:24 <ricebowl> erm
13:19:24 <boegel|home> shapr: ping
13:20:05 <shapr> boegel|home: phone, bbl
13:20:45 <Korollary> how did lambdabot spew that out ?
13:21:02 <Korollary> @hoogle building GHC
13:21:03 <lambdabot> Prelude.undefined :: a
13:21:03 <lambdabot> Test.QuickCheck.Batch.bottom :: a
13:21:03 <lambdabot> Prelude.id :: a -> a
13:21:14 <Korollary> heh
13:21:25 <ricebowl> weird, I have no ./configure script in my GHC check-out
13:21:28 <Korollary> building ghc is bottom I suppose
13:21:50 <sebell> I wonder if it's possible to specify a timeout value for connectTo, or whether I'll have to roll my own by limiting the thread lifetime
13:23:17 * ski_ thinks hoogle thought it was given a type
13:23:53 <boegel|home> shapr: just wanted to know how many people are preparing a TMR article for you ?
13:25:41 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051115","HCAR 11/2005: http://haskell.org/communities/"]' by kosmikus
13:31:24 <ulfdoz> your topics are definitely too long.
13:33:53 <SamB> ulfdoz: maybe.
13:34:11 <SamB> or maybe current clients provide inadequate facilities for dealing with topics
13:34:44 <ricebowl> what is the type of the topic?
13:34:47 <ricebowl> [String]?
13:35:04 <kosmikus> yes
13:35:09 <SamB> ricebowl: hopefully
13:35:12 <ulfdoz> It's not the client. It's me, who gets confused by long lines in style of lists.
13:35:13 <ricebowl> ought to be able to use ([String], URL) :/
13:35:13 <SamB> @help topic
13:35:14 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init
13:35:14 <lambdabot> topic-null
13:35:34 <SamB> @help topic-tell
13:35:35 <lambdabot>  @topic-tell #chan -- Tell the requesting person of the topic of the
13:35:35 <lambdabot> channel
13:36:35 <dons> moin
13:36:39 <thedward> @help topic-tail
13:36:40 <lambdabot>  @topic-tail #chan -- Remove the first topic item from the topic list
13:36:40 <kosmikus> moin dons
13:37:30 * boegel|home leaves for bed
13:37:34 <boegel|home> g'night everyone !
13:37:58 <SamB> dons: well, p154 has been running 26:49, though it was apparantly paused during the night
13:38:24 <dons> hmm. ok.
13:38:32 <dons> up to p167 now, btw
13:38:48 <dons> which has been running for 11:47 here
13:38:55 <dons> I'm basically done now.
13:39:04 <dons> just bug fixes, and minor cosmetic details
13:39:09 <dons> perhaps also input validation
13:40:28 * dons sits back with morning coffee and a copy of hcar
13:43:37 <SamB> hmm, I heard some player fades out when you quit...
13:44:17 <dons> oh, feature boy eh?
13:44:33 <dons> hehe
13:44:58 <SamB> they were talking about players in #zsnes
13:45:37 <dons> we don't have a way to control volume though, maybe in a v2.0 mpd backend
13:45:49 <SamB> ah
13:46:03 * SamB wonders why there was something about that in a comment
13:46:11 <SamB> volume, I mean
13:46:41 <dons> $ grep volume hmp3/*
13:46:41 <dons> hmp3/LICENSE:with the Program (or with a work based on the Program) on a volume of
13:46:44 <dons> ?
13:47:21 <SamB> maybe it isn't there anymore, now that you implemented help?
13:47:29 <dons> ah, perhaps.
13:47:39 <dons> it does ring a bell somewhere though
13:48:20 <SamB> \
13:48:22 <dons> I like these two new things: regex search and scrolling by directory
13:48:23 <SamB> oops
13:48:32 <SamB> you still haven't implemented MP3 detection
13:48:39 <dons> they're much more efficient for getting around big playlists.
13:48:46 <dons> yep, that's in the maybe todo.
13:49:01 <dons> i'll probably do it, though.
13:49:12 <SamB> and specifying a bunch of files by name doesn't seem to work too well
13:49:13 <dons> just have to decode this magic file format
13:49:18 <dons> oh?
13:49:40 <SamB> well, for one thing they are for some reason put at the end of the playlist
13:49:47 <dons> yep
13:49:54 <SamB> and for another the directory name is repeated over and over
13:50:02 <dons> ah.
13:50:10 <dons> it works fine then. just my algo you connsider silly
13:50:26 <dons> ;)
13:50:27 <SamB> I guess so!
13:50:39 <dons> yeah, I guess I could merge repeated entries
13:50:46 <dons> and also store them in the order  they appear on the cmd line
13:50:52 <gdfk> Hold out for the most important feature: visualization plugins
13:51:06 <SamB> gdfk: you are crazy
13:51:13 <gdfk> No, I'm kidding.
13:51:14 <dons> SamB, yeah, this is a good piont really. it's a bit weird, so i'll fix it.
13:51:17 <SamB> that isn't going to work with mpg123 as a backend
13:51:51 <SamB> on the plus side, at least you aren't ignoring them completely anymore like in p154
13:51:57 <dons> right.
13:52:09 <dons> i just had to think up a way to attach them as nodes in a tree
13:52:18 <dons> so 1) take the dirname, and attach it with that
13:52:25 <dons> however, the you get repeated nodes.
13:52:30 <dons> as you currently see.
13:52:43 <dons> so repeated entries could be merged.
13:52:50 <SamB> well, what I see looks nothing like a tree, actually ;-)
13:52:59 <dons> a tree on its side
13:53:01 <dons> of depth 2
13:53:03 <dons> ;)
13:53:18 <dons> that's a tree!!
13:53:32 <SamB> that seems vaguely reminiscent of what our DVD player does to CDs full of MP3s
14:01:46 <shapr> boegel: I don't know.
14:01:53 <shapr> boegel: I have a nifty software testing article in progress.
14:02:20 <shapr> I have a reviewer's copy of QuickCheck2.
14:02:35 <dons> shapr, see Tony Sloane's entry for Palm OS nhc?/ release due in Feb.
14:02:39 <shapr> w00
14:02:40 <dons> entry in hcar.
14:02:43 <Korollary> shapr: stefanw was talking about a quickcheck framework he did.
14:02:55 <shapr> poetix: Hey, I want to do more for schvung, but life is getting in the way.
14:03:02 <shapr> poetix: Your friend is way cool, I googled him.
14:03:02 <heatsink> schvung?
14:03:05 <dons> yeah shapr, did you see stefan has the (grand unified) Haskell Testing Framework out?
14:03:15 <dons> HUnit + QuickCheck + blackbox testing
14:03:16 <shapr> I've heard the reference, but haven't seen the code yet.
14:03:26 <shapr> I did find some way cool related software written in Clean.
14:03:42 <SamB> @where GUHTF
14:03:43 <lambdabot> I know nothing about guhtf.
14:03:46 <SamB> @where HTF
14:03:46 <lambdabot> I know nothing about htf.
14:03:56 <dons> ah wee should add the url
14:04:23 <shapr> They use a Clean port of QuickCheck to do proof by exhaustion, as in the busy beaver approach to turing machine termination.
14:04:43 <dons> cool.
14:05:19 <dons> shapr, so what's the reviewer's copy of QC like? (and what are these crazy guys on with reviewer's copies?)
14:05:44 <shapr> heatsink: The idea behind Schvung is, "What if Plone had been written in Haskell first?"
14:05:55 <shapr> It's way spiffy. It has some interesting use of generics.
14:06:13 <dons> @where+ htf http://www.stefanwehr.de/darcs/HTF
14:06:13 <lambdabot> htf ~> http://www.stefanwehr.de/darcs/HTF
14:06:51 <heatsink> okie.  Wasn't sure if it was a project or a person
14:06:52 <heatsink> or maybe a state of mind
14:07:07 * dons wants a laptop running in the H monad
14:07:16 <shapr> Yeah, me too.
14:10:06 <PaulKing> ok, video4linux2 binding is finished, it's here: http://king.net.pl/haskell/hsv4l2fg-20051120.tar.gz any comments are welcome (believe me, I'm new to haskell)
14:10:38 * dons attempts to build a Frag, a 3d kill kill game in haskell
14:10:57 <dons> now I should really bug the author to announce and release the src to this thingy
14:11:07 <shapr> What thingy?
14:11:25 <dons> Frag. it's a 3d game like Doom or such, written by a hons. student heree at unsw
14:11:39 <dons> I'm trying to convince him that it's ok to announce it publically. he's a bit shy
14:12:10 <dons> I wonder if he has screenshots up somewhere. it's mind blowing really.
14:12:13 <shapr> neato
14:12:30 <wchogg> Have you actually played it dons?
14:12:49 <heatsink> cool
14:12:49 <Korollary> there are no shy haskellers.
14:12:49 <dons> not yet, just seen his demo at his thesis presentation
14:13:05 <heatsink> Wait.  He wrote a video game FOR HIS THESIS?
14:13:25 * heatsink didn't know you could do that
14:13:26 <dons> a 3d game based on Yampa and lots of arrows
14:13:27 <SamB> its in Haskell, so its okay!
14:13:36 <dons> this is an honours thesis, so yeah, that's ok.
14:13:49 <wchogg> I'd be interested in hearing how it ran.  I just assumed that haskell wouldn't be good for games.
14:13:53 <dons> so you know how the arrows guys always use 2d space invaders as there demo?
14:14:00 <heatsink> XD
14:14:19 <dons> oh, really really fast. no speed problems
14:14:25 <dons> though I think he optimised the hell out of it 
14:14:40 <dons> that was one of the great points of the demo. it was really fast.
14:15:12 <wchogg> That is very cool dons.  Optimized or not, it at least means that it is possible to use a language like haskell and get good results.
14:15:12 <dons> I'll try to get him to announce it in the next few days,  since I KNOW there'll be some interest
14:15:24 <dons> yeah, definitely. I think the project was a great success
14:16:05 <wchogg> I actually find it encouraging for my own ideas of using haskell in physics simulation.
14:16:09 <heatsink> ish t3h nift.
14:16:16 * dons notes that with all the scene detail the source is 9M :}
14:16:37 <dons> wchogg, oh sounds very doable. he does lots of physics (well, gravity..)
14:16:39 <basti_> dons: any url?
14:16:49 <dons> not yet! he's scared to release it
14:16:54 <basti_> heh
14:16:59 <dons> this is his first large project
14:17:02 <Korollary> dons: kidnap his lambdas and threaten him
14:17:04 <SamB> he should use bittorrent
14:17:08 <dons> or perhaps first project, fullstop.
14:17:10 <kosmikus> heh
14:17:11 <basti_> yes.
14:17:13 <basti_> bittorrent
14:17:13 <basti_> ;)
14:17:15 <kosmikus> what's he afraid of?
14:17:18 <SamB> that way he won't have to worry about the bandwidth on the server ;-)
14:17:28 <Korollary> lambda chicks knocking on his doors
14:17:31 <dons> that people will criticise his code, I think. whiich I find highly unlikely..
14:17:46 <SamB> heh
14:17:47 <dons> anyway, I'll apply some pressure ;)
14:17:53 <basti_> :D
14:17:54 <kosmikus> do that :)
14:17:59 <wchogg> Even if there's criticism, there'd be at least as much praise for getting the whole thing working.
14:18:01 <SamB> tell him we promise to be nice ;-)
14:19:11 <dons> yeah , I will. I also already told him of all the patches he can expect to receive for free!
14:19:27 <wchogg> Dons, does your university actually teach haskell as a language?
14:19:34 <dons> sure
14:19:41 <dons> it's the first  languaggge they learn
14:19:44 <dons> :D
14:20:01 <wchogg> A pity mine only teaches java, java, more java, and a little c if they learn operating systems.
14:20:10 <dons> so we have around 500 new haskellers each year
14:20:39 <dons> then 1 or 2 a year go on and do research in haskell
14:20:44 <SamB> mine taught C++.
14:20:45 <dons> (interesting conversion rate..)
14:21:08 <SamB> only basicly the only C++ feature they taught was iostreams...
14:21:19 <SamB> and that very slightly.
14:21:25 <wchogg> You mean doing research using haskell, or research on developing haskell?
14:22:31 <dons> on developing haskell.
14:22:38 <dons> several more use haskell for other stuff
14:22:46 <dons> many more.
14:23:19 <wchogg> That's very cool, actually.  I'm surprised the students take to it as well as they do.
14:23:43 <dons> all the fundamental conncepts of comp.sci. are clear in the language, and not obfuscated by fuzzy semantics
14:23:51 <dons> s/fuzzy/undefined/
14:24:03 <dons> that's the basic idea.
14:24:10 <wchogg> I've just been trying to learn the language on my own, and it's been very slow going.
14:24:22 <Frederick> folks were can I get a didatical description of the map function?
14:24:24 <dons> oh, well ask more questions here!
14:24:43 <dons> didactic description?
14:24:57 <PaulKing> Frederick: in YAHT probably :>
14:25:06 <dons> how about the code? will this do:
14:25:06 <dons> map :: (a -> b) -> [a] -> [b]
14:25:06 <dons> map _ []     = []
14:25:06 <dons> map f (x:xs) = f x : map f xs
14:25:10 <dons> :)
14:25:12 <Frederick> dons, not a simple descrition of what it does
14:25:36 <bobwhoops> Yeah, haskell has been slow for me to. I think it's because I haven't really liked any of the tutorials I've found.
14:25:43 <PaulKing> Frederick: then YAHT should be enough
14:25:57 <unixgreybeard> bobw: not enough concrete example of use in my opinion
14:25:57 <shapr> bobwhoops: You could ask questions here on #haskell, maybe we can help.
14:26:14 <Korollary> read yaht, and definitely read the haskell wiki
14:26:21 <Korollary> there's a ton of stuff on the wiki
14:26:41 <bobwhoops> shapr: I already have, and got good answers :)
14:26:46 <wchogg> Are there any online solutions to craft of functional programming?  I'm absolutely stuck on one of them.
14:26:52 <dons> and get hold of some code you'd like to hack on. it helps to have some motivation.
14:26:59 <unixgreybeard> and beg, borrow or steal a copy of 'the craft of functional programming'
14:27:11 <dons> ah! good idea greybeard 
14:27:15 <dons> that's how I learnt.
14:27:23 <SamB> so why does HTF want GHC 6.4.1?
14:27:23 <wchogg> I had to get my copy from a different university's library.
14:27:25 <SamB> unixgreybeard: well, that isn't positively necessary.
14:27:33 <Korollary> I didn't know this existed: http://en.wikibooks.org/wiki/Programming:Haskell
14:27:34 <unixgreybeard> just checked out the first addition (pre-haskell 98) and it's awesome, has helped a lot
14:27:39 * dons looks across at my faded copy on the bookshelf
14:27:47 <dons> it's really faded!
14:27:48 <unixgreybeard> samb: no, but it is helping me a lot
14:27:51 * shapr reads HC&AR
14:28:01 <PaulKing> unixgreybeard: I've got one stolen copy of second ed in .pdf :>
14:28:14 <SamB> PaulKing: only one?
14:28:19 <unixgreybeard> pk: oh, we wants it!
14:28:27 <SamB> warez!
14:28:28 <eivuokko> Is there a way to attach handler for unhandled exceptions?
14:28:31 * SamB wants too
14:28:51 <unixgreybeard> heh, the second edition is checked out of the library hear for most of next year!
14:28:55 <dons> ok, I've asked him to announce the src, and offered to help set up the darcs repo for him. so fingers crossed :)
14:29:00 <unixgreybeard> ^^s/hear/here/
14:29:12 <SamB> too bad we can't use Conjure to traffik in warez
14:29:34 <dons> hehe
14:30:33 <PaulKing> unixgreybeard: it's 22MB .pdf file
14:30:35 * SamB should implement mktorrent in Conjure
14:30:40 <Lemmih> @type Control.Exception.setUncaughtExceptionHandler
14:30:41 <SamB> or whatever its called
14:30:41 <lambdabot> (GHC.IOBase.Exception -> IO ()) -> IO ()
14:30:45 <unixgreybeard> my email can handle that!
14:31:16 <unixgreybeard> :-)
14:31:45 <eivuokko> Lemmih, Cool, found it with the tip.  Thanks :)
14:33:33 <dons> beta testing! http://www.cse.unsw.edu.au/~dons/hmp3.html
14:34:00 <dons> an mp3 player written in haskell. good karma for those who test ;)
14:34:52 <eivuokko> Is there even a remote chance to get it to work in Windows? :)
14:35:12 <dons> sigh. a remote chance yes. 
14:35:28 <dons> but it would need a few of the *Posix* libs to work.
14:35:37 <dons> that's wasn't meant to be highlighed.
14:35:38 <eivuokko> Which things?
14:35:45 <eivuokko> Sorry :-(
14:35:45 <dons> * .Posix. *
14:35:54 <Frederick> dons, give us a compressed file and a make file so it is easier to test
14:36:11 <dons> darcs get http://www.cse.unsw.edu.au/~dons/code/hmp3
14:36:20 <dons> Frederick?
14:36:29 <dons> you want a tarball?
14:36:32 <SamB> Frederick: darcs is easy!
14:36:37 <dons> and a Makefile, instead of Cabal?
14:37:29 <dons> it's good haskell karma to use darcs anyway ;)
14:37:45 <Frederick> ive never used cabal I dont even know what it is
14:37:53 <SamB> hmm.
14:37:54 <Frederick> but why there is no all in one file?
14:38:04 <dons> it's the (I thought) de-facto build system for Haskell these days :)
14:38:25 <SamB> Conjure's Makefile doesn't want me to have more than one Main module
14:38:28 <dons> since it isn't released yet, it's easier to distribute via darcs
14:38:48 <dons> rather than tarring the darcs dir, and releasing that.
14:39:01 <SamB> dons: apparantly jlouis stole one of your makefiles for this, any idea how to get it to let me have another Main module?
14:39:10 * Frederick kicks and yells the maps
14:39:17 <SamB> Frederick: maps?
14:39:24 <dons> SamB, let me check the source
14:39:38 <SamB> Frederick: that stuff is insanely tricky, its true
14:39:43 <dons> everyone steals my Makefiles, and I don't even use them now :S
14:39:47 <Frederick> SamB, yep I was trying to do the CNF
14:39:55 <dons> oh, nice: Hi guys and gals. Welcome to the Conjure repository.
14:39:56 <dons>   Hack away on the code and provide a lot of patches
14:39:57 <dons> :D
14:39:58 <SamB> how you read my mind?
14:40:14 <Frederick> SamB, Ive started writting it in paper after reading the algorithm some times
14:40:21 <Frederick> but I curse the maps :p
14:40:23 <eivuokko> Eh, what else is there in posix (in haskell libs) than System.Posix?
14:40:29 <SamB> Frederick: I curse other things
14:40:47 <eivuokko> Ah, do you mean you control the child program via signals?
14:41:04 <kosmikus> good night everyone. hope you enjoy the new HCAR ... :)
14:41:19 <dons> we will!
14:41:44 <dons> eivuokko, there's base/System.Posix and unix/System.Posix
14:41:53 <shapr> kosmikus: I'm enjoying it already!
14:42:29 <eivuokko> dons, ah, I was reading it through visual haskell docs..throught all hierarchical libs are in it...not so then.
14:42:52 <dons> oh boy, this guy wrote 11k loc for the 3d game. wow.
14:43:15 <dons> that's a pretty good hack for a 4th year thesis, in my experience.
14:43:21 <SamB> dons: wow that much, or wow that little?
14:43:35 <dons> that much.
14:43:57 <dons> 11k lo Haskell code is a fairly large haskell app, I reckon.
14:44:25 * shapr is impressed
14:44:34 <SamB> dons: so, any idea how to do it?
14:44:56 <dons> oh boy: Requirements: A graphics card with support for multitexturing and vertex arrays
14:45:00 <dons> hehe!
14:45:23 <dons> SamB, just pulling conjur patches atm, gimme a sec.
14:45:31 <SamB> ah
14:45:56 <SamB> didn't realize it took that long on a decent connection
14:46:18 <Frederick> PaulKing, Ive checked YAHT Ive found nothing not even near of what I need to do
14:46:18 <dons> oh, it paused asking y/n, and I forgot about it.
14:47:41 <dons> Frederick, what's your map trouble? maybe we can help?
14:47:50 <shapr> dons: oh, I got that!
14:47:59 <shapr> Er, does it run on Linux?
14:48:25 <dons> yeah, think so.
14:48:25 <Frederick> dons, oki I got the concept
14:48:30 <shapr> spiffy
14:49:09 <Frederick> dons, I want to put the grammar in Chomskys Normal Form so I must create a function that splits productions if thet are bigger than 3 elements
14:49:32 <dons> ok. 
14:49:34 <SamB> oh noes!
14:49:41 <SamB> it requires a graphics card!
14:50:10 <dons> I like seeing haskell apps with weird prereqs like that.
14:50:25 <SamB> yeah, but I don't have one really :-(
14:50:26 <dons> means we're doing something fun!
14:50:28 <shapr> Oh wow, UUAG is cabalized!
14:50:46 <kosmikus> shapr: I haven't verified that claim though
14:51:17 <shapr> Too bad Doaitse didn't include an url to the uuag.cabal :-/
14:52:02 <dcoutts> shapr, oh cool. I've been pushing for it to be published better.
14:52:24 <shapr> I still don't know enough about AGs to have a real opinion.
14:52:30 <lisppaste2> Frederick pasted "how to map" at http://paste.lisp.org/display/13815
14:52:31 <dcoutts> shapr, does it finally have a stable url for the tarball?
14:52:32 <shapr> But if UUAG is cabalized, I will!
14:52:40 <dcoutts> and numbered releases!
14:52:45 <shapr> dcoutts: No url included, just the statement that UUAG has been cabalized.
14:52:52 <Philippa> I get the impression they're a pretty neat way of describing a lot of transformations
14:52:57 <dcoutts> shapr, ok, where was that announced?
14:52:58 * kosmikus sighs
14:53:05 <shapr> dcoutts: HC&AR, mr kosmikus 
14:53:21 <dcoutts> shapr, ta
14:53:22 <Philippa> I don't think they're an appropriate solution for "I'd like to be programming in a subtly different language, thanks"
14:53:30 <shapr> kosmikus: I'll look around, if I find 'em I'll tell you.
14:53:45 <shapr> Is there some relation between finger trees and kademlia?
14:53:54 <Frederick> dons, Ive pasted the source, basically what I need is using lenth over the left right side of the tuples if lengh < 2 it is oki, else breaking it in pairs
14:53:56 <shapr> For some reason I'm convinced they're similar...
14:54:53 <kosmikus> why doesn't it surprise me that the main UUAG page hasn't been updated ...
14:54:53 <dons> SamB, so you want what? another top level target alongside 'conjur' ?
14:55:00 <dons> 'conjure'?
14:55:07 <SamB> dons: yeah, basically.
14:55:10 <shapr> kosmikus: I'll happily email Doaitse
14:55:31 <Trixsey> anyone got time to look at an UML I made?
14:55:33 <shapr> And I'll ask Wouter when he next shows up here.
14:55:59 <dons> SamB, so add another target after: all: conjure
14:56:16 <shapr> Man, I'm tempted to offer darcs space to these guys who haven't released their code because they don't have any...
14:56:26 <dons> and then add a rule for that target, mirroring the body of the 'conjure' rule
14:56:26 <shapr> But the times they are a-changing...
14:56:45 <dons> hehe!
14:56:54 <shapr> ScannedInAvian.org is no longer my business server.
14:57:09 <Frederick> folks how can i get the length of a given element of a list?
14:57:23 <shapr> The webwitches partnership is being dissolved, so I'll be paying for ScannedInAvian myself.
14:57:23 <SamB> whats with all this foreshadowing?
14:57:26 <dons> oh, I misread. I thought you said they haven't released their code because they don't have any [code]
14:57:32 <shapr> dons: heh!
14:57:38 <dcoutts> Frederick, length?
14:57:38 <dons> so offering darcs spacee seems reasonable
14:57:54 <Frederick> dcoutts, look the code Ive just posted
14:57:57 <dons> Frederick, length?
14:58:09 <SamB> posted?
14:58:11 <dons> Frederick,do you know which element you want?
14:58:16 <dons> http://paste.lisp.org/display/13815
14:58:27 <Frederick> I have pairs like ["A","abda"] so I want the length of the second field
14:58:36 <Frederick> dons, no, I must pattern match it
14:58:43 <dons> length (list !! 1)
14:58:58 <dons> case list of [_,xs] -> length xs  ?
14:59:00 <dons> etc etc
14:59:02 <dcoutts> > length (["A","abda"] !! 1)
14:59:03 <lambdabot> 4
14:59:25 <Korollary> I think we should hack on that haskell wikibook
14:59:32 <dons> > case ["A","abda"] of [_,xs] -> length xs
14:59:33 <lambdabot> 4
14:59:57 <shapr> Can someone explain to me why Takusen's left-fold enumerator is cool?
15:00:07 <dons> > length . head . tail $ ["A","abda"]
15:00:07 <lambdabot> 4
15:00:26 <dons> > length . drop 1 $ ["A","abda"]
15:00:27 <lambdabot> 1
15:00:29 <dons> doh
15:01:03 <dons> > length . head . drop 1 $ ["A","abda"]
15:01:04 <lambdabot> 4
15:02:00 <ski_> shapr : url ?
15:03:49 <ski_> (ah, HCAR)
15:08:08 <shapr> Whoa SdfMetz is cool!
15:09:13 <Frederick> SamB, where can I find a description that shows how to use map to iterate throught a list like you did?
15:09:59 <SamB> Frederick: other than what I did?
15:10:37 <Frederick> SamB, Im not sure I understood you last question
15:10:42 <SamB> really, I don't think map is enough
15:11:05 <SamB> I think I would be trying it with a WriterT and an id generator...
15:11:11 <Frederick> SamB, map is a part of the solution
15:11:16 <SamB> if I wasn't too scared from trying last night
15:12:06 <Frederick> lemme google for writtert
15:12:37 <SamB> @index WriterT
15:12:38 <lambdabot> Control.Monad.Writer, Control.Monad.RWS, Control.Monad.Writer, Control.
15:12:38 <lambdabot> Monad.RWS
15:12:47 <SamB> well, if Writer is what I think it is ;-)
15:13:05 <SamB> if it isn't, I would make what I want up
15:13:18 <Frederick> SamB, I simply cant understand these descriptions from labdaboot
15:13:26 <Frederick> *lambdabot
15:13:50 <SamB> Frederick: that just tells you what modules export the type WriterT
15:13:59 <SamB> or rather, a type called WriterT
15:14:23 <SamB> @docs Control.Monad.Writer
15:14:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
15:14:32 <SamB> is that more understandable?
15:16:26 <SamB> okay, maybe thats not whats wanted.
15:16:54 <Frederick> SamB, ?
15:17:02 <SamB> I want something that would basically build up a list for me
15:17:29 <SamB> anyone else had a go at this CNF thing?
15:17:51 <sjanssen_> CNF?
15:18:16 <wilx> Thing?
15:18:19 <Frederick> sjanssen, Chomsky Normal Form
15:18:24 <SamB> sjanssen_: yeah. Frederick needs to convert context-free-grammars to chomsky normal form
15:18:41 <SamB> I tried it and it is insanely tricky
15:18:53 <wilx> Hmm, isn't it algorithmically unsolvable?
15:19:07 <SamB> wilx: um. what?
15:19:13 <Frederick> wilx, my teacher says it is trivial and suggested as an exercise :p
15:19:20 <SamB> I hope Fredericks homework is at least possible!
15:19:22 <wilx> Ah, ok :)
15:19:30 <Frederick> visually it isnt soooooooooooo hard
15:19:37 <wilx> I can be very likely wrong.
15:19:51 <Frederick> but algoritimically it involves very non-trivial steps
15:19:52 <SamB> it sure doesn't look at all impossible
15:19:54 <SamB> just annoying
15:20:20 <wilx> Though I clearly remember there was something that in the area of formal grammars that was algorithmically unsolvable.
15:20:40 <wilx> Probably G -> LL(k) conversion...dunno.
15:21:30 <Frederick> wilx, http://www.csee.umbc.edu/~squire/cs451_l16.html
15:22:07 <Frederick> wilx, it is surelly possible, but as SamB said it is tricky
15:22:34 <SamB> it makes my head hurt trying to plum it
15:22:57 <Frederick> SamB, maybe if the optimization is forgotten it becames easier, like not ajusting things like A -> a and B -> a just letting it be
15:23:17 <SamB> I'm not trying to optimize any
15:23:40 <SamB> you aren't really able to optimize within the framework of this conversion as far as I can tell, anyway
15:23:49 <Frederick> SamB, but if we can count the second field as I was discussing with the guys
15:24:05 <Frederick> it is a question of splitting its pairs I rhink
15:26:39 * SamB has no idea what Frederick is trying to say
15:27:51 <Frederick> SamB, Im taking a brute force aproach like the algorithm says that productions like A -> aaa must be split in a way like A -> aC hmmmm,,,,, not so easy
15:28:09 <gizban> what's the best _compiler_ for a Haskell newbie? (on windows)
15:28:11 <SamB> huh?
15:28:19 <SamB> are you sure you have the right normal form?
15:28:25 <gizban> hugs?
15:28:32 <Frederick> SamB, http://www.csee.umbc.edu/~squire/cs451_l16.html
15:28:32 <SamB> gizban: hmm. depends.
15:28:38 <SamB> hugs is probably easier to install
15:28:45 <Frederick> the problem is to know when I must substitute a simple simbol
15:28:49 <Frederick> *symbol
15:30:01 <Korollary> hugs is not a compiler tho. Use ghc. It's fine on windows.
15:31:41 <Frederick> SamB, hmmm so it might require the follwing serie of steps, if the productions is > 2 split it in parts generating new productions with size < 2 but how to handle the situation like aA where  I must create a new production like S -> a in order to have V -> SA
15:32:37 <SamB> Frederick: I know! this is SO tricky!
15:32:44 <SamB> my code is ugly
15:32:55 <SamB> and doesn't typecheck right now
15:33:02 <Frederick> SamB, may I see?
15:33:10 <Frederick> 1 sec I will look for a real book
15:33:11 <SamB> not until it at least typechecks
15:38:19 <shapr> gizban: I like GHC.
15:38:33 <shapr> gizban: Btw, welcome to #haskell, do you have any questions?
15:43:42 <shapr> Anyone know if there's a good tutorial for Michael Dummet's work that is slanted towards a CS background?
15:47:04 <ndm_> gizban, WinHugs, without a doubt!
15:47:12 <ndm_> www.cs.york.ac.uk/~ndm/projects/winhugs.php
15:47:48 <ndm_> @where+ WinHugs www.cs.york.ac.uk/~ndm/projects/winhugs.php
15:47:48 <lambdabot> winhugs ~> www.cs.york.ac.uk/~ndm/projects/winhugs.php
15:50:15 <shapr> ndm_: So, who's the author of this famous WinHugs? :-)
15:51:02 <ndm_> well most of the work was done by the hugs developers, in writing the underlying hugs!
15:51:55 <ndm_> and someone else wrote all the code before me
15:52:02 <ndm_> i just deleted it all and started again :)
15:52:23 <dons> hehe
15:52:31 <psi> will another @where+ simply replace the current item?
15:53:34 <astrolabe> ha! good plan psi.  We can reset it to GHC!
15:53:58 <psi> i was thinking about adding http:// to the link :)
15:54:08 <astrolabe> :)
15:54:20 <psi> safari doesn't open without it for some reason
15:54:37 <ndm_> @where+ WinHugs http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
15:54:37 <lambdabot> winhugs ~> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
15:54:58 <psi> cool, thanks
15:55:00 <ndm_> just wait til i'm pimping WinYhc
15:56:01 <shapr> Philippa: Hey, did you see that Oleg referenced one of your TMR articles?
15:56:11 <imphasing|sleep> Is it possible to use the haskell interpreter as a cgi page? just for kicks of course, but it might be interesting...
15:56:33 <shapr> imphasing|sleep: Yes, you can do that.
15:56:47 <shapr> You could also use the Network.CGI module and generate a binary.
15:56:52 <shapr> It's entirely your choice.
15:56:56 <Lemmih> imphasing|sleep: Yes it is. The first Haskell Apache module used Hugs and HAskell Server Pages uses GHCi.
15:57:05 <imphasing> That's pretty neat sounding...
15:57:15 <imphasing> I'll have to try and actually -learn- haskell
15:57:24 <shapr> I definitely have fun with Haskell.
15:57:43 <shapr> Do you have any questions about Haskell?
15:57:46 <imphasing> Functional programming sounds much more intuitive than imperative programming..
15:57:57 <SamB> that is the idea ;-)
15:58:03 <Korollary> ok this is no fun. you are already converted.
15:58:06 <imphasing> I'm reading the wiki page on it now, and getting a basic idea of what it's about
15:58:09 <SamB> hehe
15:58:19 <imphasing> Korollary, haha...yeah
15:58:34 <imphasing> I started out just looking at lisp, and researching recursion, and that led to haskell
15:58:59 <imphasing> It seems tp pave a better understanding to imperative languages too
15:59:09 <Korollary> quit now, or else you will find yourself reading research papers for the rest of your life !
15:59:49 <shapr> All of the many vies are present in programming at some level.
15:59:55 <shapr> er "views"
16:00:01 <imphasing> Korollary, It's possible...I'm reading the orignal LISP paper now.
16:00:09 <Korollary> imphasing: You may really enjoy reading http://mitpress.mit.edu/sicp/
16:00:19 <shapr> You don't execute both branches of an "if" that's one flavor of lazy evaluation.
16:00:30 <shapr> Or maybe I'm just stretching it :-)
16:00:31 <imphasing> Korollary, cool, thanks
16:02:20 <Korollary> shapr: I would use the short-cirtcuited if-expression analogy there
16:02:40 <Korollary> if (someBoolean && someFunc() ) { ... }
16:04:08 <imphasing> In haskell, are all operations and symbols functions?
16:04:11 <imphasing> IE, 'if'
16:04:48 <Korollary> 'if' is syntactic sugar, but it could have been a function 
16:05:04 <SamB> if then and else weren't wanted
16:05:05 <Korollary> (+) is a function. you can use "1 + 2" or "(+) 1 2"
16:05:11 <SamB> @type (+)
16:05:12 <lambdabot> forall a. (Num a) => a -> a -> a
16:05:35 <Korollary> why am I sleepy in the middle of the day ?
16:05:51 <dons> @localtime Korollary
16:05:51 <lambdabot> Local time for Korollary is Sun Nov 20 16:05:38
16:11:59 <SamB> okay, it seems to work sortof
16:14:45 <SamB> okay, I guess I can paste this now...
16:15:43 <SamB> Frederick: sorry this won't just drop in to your code, but its pretty ugly anyhow
16:16:17 <lisppaste2> SamB pasted "CFG to CNF" at http://paste.lisp.org/display/13820
16:16:36 <SamB> however:
16:16:42 <SamB> *Main> let cfg = run grammar "" (unlines ["termchars ab","start S","S -> aAS | a","A -> SbA | SS | ba"])
16:16:42 <SamB> *Main> putStr (unlines (prettyCnf (cfgToCnf cfg)))
16:16:42 <SamB> A(0) -> A(7)A(8) | S(0)A(5) | S(0)A(1)
16:16:42 <SamB> A(1) -> A(2)A(3)
16:16:42 <SamB> A(2) -> b
16:16:43 <SamB> A(3) -> A(0)A(4)
16:16:47 <SamB> A(4) -> $
16:16:49 <SamB> A(5) -> S(0)A(6)
16:16:51 <SamB> A(6) -> $
16:16:53 <SamB> A(7) -> b
16:16:55 <SamB> A(8) -> a
16:16:57 <SamB> S(0) -> a | S(1)S(2)
16:16:59 <SamB> S(1) -> a
16:17:01 <SamB> S(2) -> A(0)S(3)
16:17:03 <SamB> S(3) -> S(0)S(4)
16:17:05 <SamB> S(4) -> $
16:17:40 <SamB> clearly needs a bit o' work...
16:19:04 <imphasing> What package do you guys use for a haskell interpreter?
16:19:15 <sethk> imphasing, ghci
16:19:15 <SamB> imphasing: GHCi is my favorite
16:19:27 <SamB> especially because hugs acts broken on my system
16:19:29 <sethk> imphasing, using the same package for compiling and interpreting makes my life simpler
16:19:39 <imphasing> Ok, thanks.
16:19:51 <SamB> and it has lots of cool features, too
16:20:02 <imphasing> opengl bindings...weird
16:20:07 <dons> SamB, hugs acts broken?
16:20:09 <imphasing> can't see a use for it, but neat
16:20:13 <SamB> dons: yet
16:20:13 <dons> reminds me to test hugs and hmp3
16:20:16 <SamB> er, yes
16:20:19 <dons> how so?
16:20:36 <SamB> it doesn't want to load anything but the Prelude from its libraries
16:20:52 <dons> hmm. busted library install, perhaps?
16:20:58 <dons> debian?
16:21:31 <dons> well, hugs does work on linux. Hugs.Base> :l List
16:21:31 <dons> List> :t sort
16:21:31 <dons> sort :: Ord a => [a] -> [a]
16:21:32 <dons> ;)
16:22:07 <SamB> debian is what I have, yeah...
16:22:13 <dons> OK! so I'm having a meeting with the author of this 3d game TODAY, to help put the code in darcs :D
16:22:19 <imphasing> Does haskell care about capitalization? are functions like "foo" and "Foo" different?
16:22:21 * dons boings
16:22:25 <SamB> okay, so maybe I just need to pass it -98
16:22:29 <dons> yes, imphasing
16:22:30 <eivuokko> imphasing, Yes.
16:22:32 <SamB> I dunno
16:22:34 <dons> > let Foo = "x" in Foo
16:22:34 <lambdabot>  Not in scope: data constructor `Foo'
16:22:41 <SamB> it acts fairly useless at least
16:22:42 <dons> data constructor, not identifier, see?
16:22:47 <dons> > let foo = "x" in foo
16:22:48 <lambdabot> "x"
16:22:57 <SamB> maybe I tried to use :m for that or something...
16:23:02 <dons> SamB, I don't need to pass it -98.
16:23:04 <imphasing> There's a haskell interpreter bot?
16:23:06 <imphasing> cool...
16:23:06 <imphasing> :D
16:23:07 <dons> on linux, debian.
16:23:17 <dons> imphasing, yes. meet lambdabot! the bot of many powers
16:23:20 <dons> @type map
16:23:20 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
16:23:26 <dons> > map (+1) [1..10]
16:23:27 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
16:23:29 <imphasing> dons, that's pretty nifty...
16:23:31 <dons> @google haskell
16:23:32 <lambdabot> http://www.haskell.org/
16:23:34 <SamB> dons: I dont remember any of the problems I've had exactly
16:23:38 <SamB> it just isn't very nice
16:23:43 <dons> @localtime imphasing
16:23:43 <lambdabot> Local time for imphasing is Sun Nov 20 19:23:31
16:23:47 <dons> @version
16:23:48 <lambdabot> lambdabot 3p188, GHC 6.5.20050806 (Linux i686)
16:23:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
16:23:50 <dons> and it's free!
16:24:08 <Korollary> @vixen do you love me ?
16:24:08 <lambdabot> love is a powerful word...
16:24:18 <SamB> @vixen do you like haskell?
16:24:19 <lambdabot> church is my favourite computer scientist.
16:24:21 <imphasing> dons, cooooll :D
16:24:26 <SamB> @vixen do you like haskell?
16:24:27 <lambdabot> church is my favourite computer scientist.
16:24:34 <Korollary> at least she's consistent
16:24:35 <dons> @vixen what about haskell programmers?
16:24:35 <lambdabot> church is my favourite computer scientist.
16:24:38 <dons> oh well.
16:24:41 <SamB> thats a strange answer to that question
16:24:50 <SamB> @vixen functional programming?
16:24:51 <lambdabot> what's a program?
16:24:57 <SamB> @vixen lazy?
16:24:58 <lambdabot> who's to say?
16:25:03 <dons> @vixen can you send me a pic?
16:25:03 <lambdabot> i sure can
16:25:05 <SamB> @vixen functional?
16:25:05 <lambdabot> i love fun
16:25:13 <dons> @vixen what's your email address?
16:25:13 <lambdabot> vixenlove@hotmail.com
16:25:15 <Korollary> @yow
16:25:15 <dons> ah!
16:25:16 <lambdabot> I am NOT a nut....
16:25:32 <SamB> @vixen send me your pic at naesten at gmail.com?
16:25:33 <lambdabot> vixenlove@hotmail.com
16:25:49 <dons> @vixen so, you hang out on the haskell channel a lot? why's that?
16:25:49 <lambdabot> Ooh, functional programmers are so hot!
16:25:54 <dons> ah, well, that is true.
16:26:09 <Korollary> I've been suspecting that dons is a console application...
16:26:09 <astrolabe> hard to argue with that
16:26:29 <dons> Korlallary, ncurses programmers are hot!
16:26:30 <SamB> Korollary: is that why he's always writing things in curses?
16:26:37 <astrolabe> Written by lambdabot?
16:26:42 <dons> SamB, ncurses programmers are hot!
16:26:51 <SamB> @vixen ncurses?
16:26:51 <Korollary> yes, it's lambdabot that created dons !
16:26:52 <lambdabot> i think you know the answer to that one, silly
16:27:06 <SamB> @vixen foo?
16:27:07 <lambdabot> no
16:27:46 <shapr> dons: Awesome! I can barely wait to play Frag!
16:28:03 <dons> me too!
16:28:18 <SamB> somebody get me a graphics card so I can play too!
16:28:36 <dons> we need an aalib port, right?
16:28:40 <dons> SamB's first job.
16:28:43 <imphasing> Hot damn, it's easy to calculate Fibonacci numbers with haskell...
16:28:44 <eivuokko> Hehe
16:28:47 <Frederick> SamB, this is right but omfg this is wierd coding very hard to read
16:29:01 <SamB> Frederick: I agree!
16:29:16 <SamB> Frederick: clonk someone over the head and force them to clean it up
16:29:19 <dons> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20 :: Int
16:29:20 <lambdabot> 10946
16:29:37 <dons> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 20 fibs :: [Int]
16:29:38 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
16:29:38 <Frederick> SamB, this is right but omfg this is wierd coding very hard to read Im googling for the definitions
16:29:48 <SamB> definitions?
16:29:50 <Frederick> sorry for double post folks
16:30:01 <dons> oh, i just assumed youu were a bot, Frederick ;)
16:30:02 <Frederick> SamB, of the fuctions you used and stuff you have imported
16:30:10 <SamB> shapr: fixorate my code!
16:30:15 <SamB> it is ugly!
16:30:20 <Frederick> dons, Im a plant
16:30:38 <SamB> Frederick: you are the most intelligent plant I know of, if thats the case
16:30:43 <Frederick> I got enormous roots keeping me in front ofthe pc
16:30:58 <Frederick> I live just of water and sun light
16:31:05 <sethk> Frederick, as in vegetable, or as in an agent for ocaml?
16:31:28 <SamB> Frederick: how come you have to go to college if you are a plant?
16:31:50 <SamB> couldn't you just become a mascot for the gang at userfriendly?
16:31:59 <Frederick> SamB, actually I was born in College, Ive scaped from a biology lab
16:32:26 <SamB> Frederick: do you get the employee discount?
16:32:43 <Frederick> SamB, nope cause as Ive said my university is free as free beer
16:33:12 <SamB> oh
16:33:16 <SamB> maybe I should go there
16:34:04 <imphasing> My computer slows down after calculating fibonacci numbers for about 15 second... :D
16:34:07 <imphasing> they get pretty big
16:34:26 <imphasing> s/second/seconds/
16:34:32 <Frederick> imphasing, try it with python
16:34:57 <SamB> dons: look at my ugly code! find a monad that would make it prettier!
16:35:04 <Frederick> SamB, if it happen to you c0ome to Brazill specifically Porto Alegre let me know we can play pool or judo
16:35:08 <imphasing> Frederick, I bet it slows down alot quicker...
16:35:10 <astrolabe> imphasing: what code are you using? and how big?
16:35:31 <imphasing> let fibs = 0 : 1 : [ a+b | a <- fibs | b <- tail fibs ]
16:36:08 <imphasing> I just let it keep going
16:36:09 <imphasing> :D
16:36:19 <astrolabe> hmmm should be quite efficient for haskell I think.
16:36:43 * astrolabe loves list comprehensions
16:37:04 <imphasing> well, the last number it took was about 30,000 numbers in length
16:37:13 <imphasing> s/numbers/digits/
16:37:31 <imphasing> and I'm running gnome at the same time, so it's understandable
16:37:37 <SamB> the printing is probably one of the slowest parts...
16:41:45 <dons> SamB, code is where?
16:44:14 <Frederick> dons, http://paste.lisp.org/display/13820
16:45:49 <shapr> g'day Pseudonym, long time no see.
16:46:02 <Pseudonym> G'day.
16:46:05 <Pseudonym> Yeah, been a bit busy.
16:46:16 <shapr> How's life?
16:46:52 <Pseudonym> Not bad, not bad.
16:47:00 <Pseudonym> Yourself?
16:47:19 <shapr> Lotsa work, lotsa fun.
16:50:10 <SamB> hmm, apparantly if you type "dons" into hmp3 thinking it is X-Chat, bad things can happen
16:50:10 <Pseudonym> Fun is good, and work is good if it means you can eat.
16:50:16 <Pseudonym> Especially if it's fun.
16:50:35 <SamB> dons: did you see my demonstration of the code above?
16:52:13 * SamB wishes he had put more rice in his chicken rice roger
16:52:28 <Pseudonym> Otherwise it's just a chicken roger.
16:52:42 <Pseudonym> That's probably an English euphemism for something.
16:52:53 <SamB> yeah. probably.
16:54:27 <ski_> (imphasing : the sicp lectures http://sicp-lectures.webhop.org/ is also nice)
16:57:09 <ski_> > let fibs = 0 : zipWith (+) (1 : fibs) fibs in take 10 fibs
16:57:10 <lambdabot> [0,1,1,2,3,5,8,13,21,34]
16:57:24 <ski_> is also a nice variant (not needing the 'tail')
17:00:40 <SamB> ski: were you helping Frederick out?
17:01:09 <ski_> not right now, i think
17:01:09 <stefanw> anyone having experience with cabal's LANGUAGE pragma? Apperently, it doesn't work for my (cabal 1.1.3)
17:01:19 <stefanw> s/my/me
17:01:19 <Frederick> SamB, not now but he helped a lot too
17:01:25 * ski_ will leave in a few minutes
17:01:35 <SamB> ah
17:01:41 * SamB wrote some ugly code
17:02:01 <SamB> and I was hoping someone else would be able to figure out how to make it less ugly
17:02:08 <SamB> its for Frederick...
17:02:10 * ski_ could maybe find time and power to look some on Frederick's prob, later this week
17:05:25 <SamB> I think I need another Monad, but I'm not sure its been invented yet...
17:08:54 <Pseudonym> What does it need to do?
17:12:14 <SamB> Pseudonym: basically, add elements to a list to be output
17:12:51 <SamB> look at the code
17:29:16 <sjanssen_> From the HCAR: "We are planning to release GHC 6.6 some time in the next six months. This will include the parallel version of GHC."
17:29:36 <sjanssen_> how excited should I be about this parallel GHC? anyone know much about it?
17:32:52 <SamB> well, sounds like it provides access to GHCi via library
17:34:12 <SamB> where did everybody go?
17:38:26 <shapr> @timein EST
17:38:26 <lambdabot> Unknown command, try @listcommands.
17:38:30 <shapr> foo
17:38:42 <SamB> @localtime SamB
17:38:44 <lambdabot> Local time for SamB is Sun Nov 20 20:38:51
17:38:46 <shapr> sjanssen_: It's great, read the SMP-GHC paper.
17:38:52 <shapr> SamB: Spiffy, thanks.
17:39:09 <SamB> i'm in either EST or EDT
17:39:16 <shapr> cool
17:39:33 <Lemmih> It's a bit late in Europe.
17:39:40 <shapr> sjanssen_: If you have a dual core or full SMP setup, you'll like GHC-SMP.
17:59:17 <Frederick> did someone put sleeping pills in everybodys dinner?
17:59:25 <SamB> Frederick: no idea
17:59:34 <SamB> except not mine
17:59:46 <Frederick> SamB, wierd
17:59:59 <Frederick> bah I got my opegl airplane to work
17:59:59 <unixgreybeard> nah, actually working!
18:00:01 <Frederick> finally
18:00:09 <imphasing> What does it do?
18:00:13 <SamB> santa clause would be my chief suspect if that were the case
18:00:29 <Frederick> imphasing, it is a poor cousin of flight simulator
18:00:38 <imphasing> In haskell?
18:00:40 * ski_ leaves for the night
18:00:44 <SamB> imphasing: no, C
18:00:53 <imphasing> ah, funtime...
18:01:00 <SamB> its for a different class
18:01:21 <imphasing> I should take a comp-sci course some day...
18:01:35 <imphasing> Or major in that.
18:01:37 <Frederick> ski, party today?
18:01:40 <SamB> eh, those things are overrated, probably
18:01:57 <SamB> still, I'll probably major in that just the same...
18:02:08 <Frederick> imphasing, if I had to do a flight simulator in haskell I would suicide
18:02:11 <SamB> EE is a bit too hard, I think...
18:02:25 <Frederick> EE? Eletric Engeenering?
18:02:33 <SamB> yeah
18:02:55 <imphasing> Difficulty is not the issue...I would rather major in something challenging and cool, that somethign easy and boring.
18:03:22 <SamB> well, if it was easy and boring because I knew it already, that wouldn't be toooo bad.
18:03:26 <Frederick> imphasing, you say such things cause you arent in university
18:03:28 <SamB> I mean, better than hard and boring.
18:03:35 <Frederick> SamB, amem
18:03:41 <imphasing> Frederick, I -am-
18:03:55 <SamB> or even sometimes hard and interesting.
18:04:08 <imphasing> What's the point of taking a class for something if you already know it?
18:04:25 <SamB> imphasing: pieces of paper that say you know stuff?
18:04:38 <imphasing> So much for the point being, 'to learn'...
18:04:46 <imphasing> Although paper is nice...
18:05:17 <SamB> yeah. I would possibly be learning more in spite of my classes than in them, I dunno...
18:05:31 <SamB> that tends to work badly with the hard & boring variety, though...
18:06:38 <Frederick> SamB, amem
18:06:52 <SamB> I mean, why would I go to college just to learn something? isn't that a lot of money just to learn something?
18:07:21 <Frederick> SamB, I use to say to my mom i go uni to play cards, if I really wanted to LEARN I would be home studing
18:07:45 <imphasing> Frederick, Amen...
18:07:50 * imphasing was a homeschooled kid
18:08:00 <SamB> me too
18:08:05 <imphasing> Nice.
18:08:22 <SamB> it left me unprepared for homework deadlines, though...
18:08:24 <Frederick> imphasing, we dont have homeschool here
18:08:35 <Frederick> but I wouldnt like homeschool
18:08:48 <Frederick> this isnt something nice for the brazillian way of life
18:08:56 <shapr> I wasn't homeschooled, but I still don't do homework well.
18:09:01 <Frederick> our climatical conditions favor going out and stuff
18:09:04 <SamB> hmm
18:09:07 <imphasing> SamB, yeah, homework was a shock to me...
18:09:17 <SamB> well, I was totally unused to it, not just bad at getting it done...
18:09:30 <imphasing> I'd never done homework before
18:09:32 <imphasing> -ever-
18:09:37 <imphasing> it was a little strange
18:09:50 <shapr> I think the whole educational system is pretty artificial.
18:10:00 <SamB> I had done all homework but hadn't had deadlines or classes
18:10:05 <shapr> I don't see how it prepares people for 'the real world.'
18:10:10 <shapr> The social side is fun though.
18:10:11 <SamB> it doesn't ;-)
18:10:20 <Frederick> shapr, amem
18:10:42 <SamB> thas why I wasn't prepared for the educational system ;-)
18:10:43 <Frederick> but university is a kick in the but
18:10:59 <Frederick> you and you mates are on your own against the world
18:11:11 <Frederick> the thing is unite and survive at all costs
18:11:36 * Frederick has passed countless nights teaching/installing/configuring linux for classmates
18:11:38 <shapr> I never had mates, but I did have a bunch of books.
18:11:40 <Frederick> as other dis to me
18:12:00 <bobwhoops> Hi, I'm trying to write a function called scansum, which adds the elements in a list and keeps a running total (e.g scansum [2,3,4,5] should return [2,2+3,2+3+4,2+3+4+5] = [2,5,9,14]), but I can't get it to work. What I have is here: http://pastebin.ca/29851. I can see why it doesn't work, but I don't know how to fix it.
18:12:26 <Frederick> shapr, our acces to book in brazil is pretty reduced when we talk about printed copies
18:12:32 <imphasing> Frederick, the first rule of installing linux, is 'you will install it again'
18:12:37 <imphasing> :D
18:12:38 <shapr> Frederick: Yeah, that's true for me too.
18:12:47 <Frederick> imphasing, amem
18:13:01 * Frederick is currently running a 1 install gentoo
18:13:23 <bobwhoops> I don't think I installed linux twice the first time
18:13:38 <bobwhoops> Well, yes I did. But different distros
18:13:49 <shapr> bobwhoops: Do you know the function scan and flavors?
18:13:50 <sjanssen_> bobwhoops: what you're doing with your accumulator (the variable n) doesn't make sense
18:14:03 <bobwhoops> shapr: No
18:14:09 <Frederick> I was 17 when I entered university this is too damm soon
18:14:10 <shapr> Do you know fold?
18:14:22 <bobwhoops> shapr: No
18:14:24 <shapr> Frederick: I was 17 when I entered university, but I thought it was way too late.
18:14:39 <bobwhoops> I'm sure I can learn them, but this is supposed to be an exercise to do before I learn them
18:14:40 <Frederick> shapr, did you expected to graduate with 15?
18:14:45 <Frederick> and go work for nasa ? :p
18:14:58 <shapr> bobwhoops: The fold function takes two inputs, a function from two items to one item, and a list. It returns the function 'folded' over all the items in the list.
18:15:05 <shapr> Frederick: Sure, why not?
18:15:12 <bobwhoops> sjanssen: I know, because n + x is a list, right?
18:15:24 <Frederick> shapr, cause if you didnt had sex in university you shall never have
18:15:38 <imphasing> Frederick, I was 16 when I started college...
18:15:41 <imphasing> it was rough.
18:16:02 <bobwhoops> I started college this year at 17, and I'm one of the oldest
18:16:04 <shapr> Frederick: Um, I was overly successful in that way in college.
18:16:06 <shapr> My studies suffered.
18:16:17 <Frederick> shapr, what course did you take?
18:16:20 <shapr> Or maybe I majored in women.
18:16:33 <shapr> Anyway...
18:16:43 <bobwhoops> shapr: I'm using this: http://en.wikibooks.org/wiki/Programming:Haskell_lists . It's supposed to be doable without something like fold
18:17:23 <sjanssen_> bobwhoops: your program doesn't typecheck at the moment, correct?
18:17:56 <bobwhoops> sjanssen: I'm not sure what you mean. That's all there is to the program, so I guess not
18:18:45 <sjanssen_> bobwhoops: when you load it in ghci/hugs, it gives you errors before it actually runs?
18:19:00 <shapr> I know how I would write that, but my definition would use Prelude code.
18:20:02 <bobwhoops> sjanssen: Yeah, it won't run. It complains about the n : x because it's type [a], not [a]
18:20:12 <bobwhoops> err... n + x
18:20:25 <Frederick> shapr, what courses did you take besides women?
18:21:19 <shapr> I switched majors several times. I've had computer art, health physics (radiation safety), and computer science majors.
18:21:37 <shapr> Well, pre-computer science, I never got accepted to the program.
18:21:40 <Frederick> wierd
18:22:34 <shapr> I had something like six years of college, but no I have no degree.
18:22:34 <shapr> degree.
18:22:43 <shapr> Is there an echo in here?
18:22:53 <int-e> here?
18:22:58 * shapr snickers
18:23:05 <Frederick> the university system in my country is broken as hell
18:23:06 <int-e> No I don't think so.
18:23:17 <Cale> I'm sure you could get accepted.
18:23:30 <Cale> (if you wanted to finish now)
18:23:31 <sethk> @localtime Frederick
18:23:33 <lambdabot> Local time for Frederick is Mon Nov 21 00:23:13
18:24:03 <shapr> One day, hopefully.
18:24:11 <unixgreybeard> let's see if my stuff is setup right:
18:24:11 <Frederick> sethk, my mom used to say I should sleep at 10 pm
18:24:17 <unixgreybeard> @localtime unixgreybeard
18:24:22 <Cale> ugh, my net connection has been even more terrible than usual lately.
18:25:01 <Cale> 10 kB/s, and if I'm using that, my latency gets ridiculous
18:25:33 <unixgreybeard> oh so sorry, my 5Mbit/s cable modem is humming along fine, knock on wood!
18:25:40 * Cale wants his 3MB/s connection back
18:26:03 <sjanssen_> Cale: university hookup?
18:28:42 <Cale> no, dsl
18:28:55 <Cale> It was only $24/mo too.
18:28:57 <Frederick> I wish I could send my self via fedex to europe
18:29:16 <Cale> but that was in Waterloo, now I'm back in Brantford and the DSL is terrible
18:29:36 <Cale> Waterloo, Ontario
18:29:42 <bobwhoops> " because it's type [a], not [a]" Wait, that doesn't even make sense >_> The second [a] should just have been a
18:29:44 <shapr> We need wimax.
18:29:58 <shapr> Hey, I had a great idea!
18:30:29 <sjanssen_> bobwhoops: I'll tell you the first problem is in the first line of scanSum'
18:30:29 <shapr> Sell wimax access points in a chunky but cheap mobile phone size, and have them running in mesh network mode by default.
18:30:44 <unixgreybeard> is there any non-dsl service there at all? that you could maybe hook up to with wifi and a pringles can is you can't get it directly?
18:31:00 <shapr> It's hardware bittorrent.
18:31:01 <unixgreybeard> shapr: that's a great idea
18:31:26 <unixgreybeard> I've thought of something similar, and use ipv6 on it all with mandatory ipsec :-)
18:31:36 <bobwhoops> sjanssen: Oh, do I want [n]?
18:31:39 <shapr> So you get free mobile phone service and free DSL when you plug it into your computer.
18:32:01 <unixgreybeard> and ad hoc ipv4 gatewaying through otherwise connected systems
18:32:02 <sjanssen_> bobwhoops: that is a start ;)
18:32:31 <unixgreybeard> (back to haskel-blah with me!)
18:32:42 <bobwhoops> Ok, that runs, but wrong output.
18:33:24 <bobwhoops> Oh, silly me
18:34:13 <bobwhoops> Actually, that was still wrong, it should have been []
18:34:23 <bobwhoops> sjanssen: It's working now :) Thanks
18:34:46 <sjanssen_> bobwhoops: want to see a 10 character solution?
18:34:58 <bobwhoops> sjanssen: ok
18:35:06 <bobwhoops> Is this the fold stuff?
18:35:18 <sjanssen_> yeah
18:35:37 <sjanssen_> bobwhoops: scanl (+)
18:36:10 <sjanssen_> bobwhoops: as you learn more, learn about HOF's., they're quite neat
18:36:14 <bobwhoops> That's short >_>
18:36:40 <Cale> ah, trying to write a function to produce a list of partial sums?
18:37:15 <bobwhoops> Cale: Tried and got it
18:37:40 <int-e> sjanssen: it's scanl1
18:37:58 <Cale> one straightforward way if you don't know about scanl is (map sum . inits)
18:38:31 <int-e> but isn't that horribly inefficient?
18:38:42 <Cale> yeah, probably :)
18:39:07 <Cale> on the other hand, it didn't take much thinking ;)
18:40:19 <Cale> it doesn't make use of the fact that (+) is associative, so it's more costly
18:41:36 <sjanssen_> int-e: ah yes, my fingers hath betrayed me
18:41:43 <Frederick> folks gtg cya tommorows afternoon
18:41:44 <int-e> inits itself isn't very efficient (O(n^2)) and you also get O(n^2) additions ...
18:42:13 <int-e> because there is no sharing between the lists returned by inits.
18:42:27 <Cale> yeah
18:42:30 <Cale> inits is costly
18:42:35 <chckens> Anyone happen to know a lot about Cairo with gtk2hs? I'm trying to render images to a canvas and getting myself confused
18:42:47 <Cale> chckens: okay
18:42:49 <sjanssen_> yeah, it's a Theta(n^2) algorithm, compared with a Theta(n)
18:43:51 <chckens> Cale: specifically, the withImageSurfaceFromPNG function
18:44:07 <Cale> chckens: what about it?
18:45:01 <chckens> Cale: Looking at it, I'd imagine it should take a FilePath and return IO Surface. I don't get what it's really doing
18:45:17 <Cale> chckens: you pass it something to do with the surface
18:45:42 <Cale> it's going to allocate the Surface, perform whatever action you specify using it, and then deallocate
18:45:58 <Cale> you don't get to keep the Surface
18:46:16 <Cale> (though there are sneaky ways to squirrel it away, but that's a bad idea)
18:47:37 <Cale> You pass it the filename of a PNG you'd like to play with and a function from the image surface that will get created to something to do, and then it finishes the job of wrapping that up with the machinery to load the PNG and deallocate it afterwards.
18:48:41 <chckens> Cale: I have at the moment a canvas in a gtk window, which has an update function drawing text. From what you're saying it sounds like it'd have to load the PNG every time the canvas is updated if I wanted to draw it on there? :S
18:49:35 <Cale> well, you certainly don't want to do that :)
18:50:58 <Cale> hmmm, what was the right way to do this? :)
18:52:33 <chckens> I was wondering if there was some reason why none of the cairo demo programs showed off image loading, sounds like this could be it :D
18:53:46 <Cale> well, I'm not all that familiar with how it should be done -- I've only used the library a little bit, and it didn't really use that
18:54:41 <Cale> Let me try something and see if it works :)
18:54:56 <chckens> Cale: OK, thanks :)
19:01:14 <Cale> chckens: okay, so you definitely can't steal the Surface away by cheating
19:01:50 <Cale> (say, by storing it in an IORef and using it later)
19:03:15 <Cale> It might be a good idea to allow Surfaces to hang around by representing them internally with ForeignPtrs, but there are issues with GHC's garbage collection and ForeignPtrs to large blocks of data.
19:03:26 <Cale> (basically, it's slow about GCing them)
19:04:15 <dons> we think
19:04:25 <Cale> well, it certainly seems that way
19:04:43 <dons> well, I'm not sure SimonM has given us a definitive answer ;)
19:04:51 <dons> but it seems to be the case
19:04:59 <Cale> I've observed it anyway
19:05:17 <Cale> If it's not a GC problem, then I have no idea :)
19:05:44 <dons> yeah, I've seen slow to collect problems, and this is also my best guess
19:06:39 <Cale> Basically, ForeignPtrs to large Pixmaps weren't getting deallocated, even though there was only ever one IORef holding them and it was getting overwritten.
19:06:57 <Cale> Since this was as part of an animation, memory consumption was ugly :)
19:07:15 <dons> hmm.
19:07:30 <chckens> ugh, not painting a very pretty picture here (excuse the pun)
19:07:52 <Cale> (I found a good solution to my problem though :)
19:08:39 <dons> you can always finalise by hand
19:09:33 <Cale> chckens: well, at worst, you load up a bunch of image surfaces right off the bat and the rest of your program will have access to them
19:10:03 <Cale> for example, if you did this in main, you could pass the image surfaces into any action which needed them
19:10:39 <Cale> how many images are we looking at?
19:11:17 <Cale> I really think it should be converted to use ForeignPtrs myself.
19:12:20 <mwc> Quick question: when I construct an array, given that the intializer for the cells are nonstrict, am I not allowed to use a function that refers to the array itself? Basically I'm doing something recursive to initialize
19:12:42 <mwc> I'm getting a bizarre error with initialization I can't seem to put my finger on
19:12:42 <Cale> mwc: yeah, that should be fine
19:12:54 <Cale> what kind of array?
19:12:57 <mwc> array ((0,tSteps),(0,xSteps)) [((t,x),init t x solution) | x <- range (0,xSteps), t <- range(0,tSteps)]
19:13:04 <Cale> what's the type?
19:13:06 <chckens> Cale: the thing I'm building is eventually supposed to be a (toy) web browser. Doubt it'll be dealing with hugely complex pages ever
19:13:06 <mwc> for some reason there's an indexing exception
19:13:12 <mwc> oh, prelude array
19:13:13 <int-e> @type Control.Exception.bracket
19:13:14 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:13:46 <Cale> mwc: ((0,0),(tSteps,xSteps))
19:13:58 <mwc> Oh, hahaha
19:14:09 <Cale> I've been bitten by that before
19:14:32 <mwc> Thank you kindly
19:14:38 <Cale> no problem
19:14:53 <Pseudonym> Mmmm.  Free pizza.
19:14:59 <mwc> I could have looked at the docs for hours and not seen that
19:15:22 <Cale> chckens: still, that's a bit of an annoying issue for something like that. I suppose you could render onto something more permanent.
19:17:44 <chckens> Cale: now there's an idea. Render first to an offscreen surface, then update from there?
19:17:52 <Cale> yep
19:18:00 <chckens> Thanks much :)
19:19:02 <Cale> there seem to be lots of options for kinds of offscreen surfaces to render to, and I'm not very familiar with GTK, so I don't recall which of these are deprecated and which would be efficient
19:21:30 <Cale> I wish Cairo could automatically keep track of the drawing size.
19:22:35 <chckens> Not a problem I've encountered yet, but I'm sure it'll bite me soon enough :D
19:23:07 <Cale> perhaps some invisible state could get threaded through the Render monad to take care of that at the Haskell-binding level, but it really seems like something which should go into the original library
19:24:02 <Cale> Of course, you can always keep track of it yourself, but it would be a nice thing to have it keep track of.
19:24:51 <sebell> Does anyone know if there's an implementation of a timeout combinator or 'parallel or' targetting latest GHC?
19:25:45 <sjanssen_> sebell: in IO?
19:26:02 <sebell> sjanssen_: Yes
19:26:17 <Cale> There have been things on the mailing lists.
19:26:39 <Cale> Using the concurrency stuff
19:28:11 <sjanssen_> would Control.Concurrent.mergeIO do the trick?
19:28:24 <Cale> let me search my email
19:29:35 <sebell> Cale: Well, that's basically what I want to achieve, and most of Asynchronous Exception stuff is already implemented in ghc... but I'm lazy so I'm looking before I roll my own. Although this is an overengineered solution, I just want to be able to timeout my threads that return (Maybe a)
19:31:26 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:31:58 <Cale> I've actually never tried that code myself, but there were no complaints
19:34:32 <sebell> Cale: I saw both of those examples floating around on the list in some form or another, I think one might be a good starting point.. Thanks
19:35:09 <Cale> both?
19:35:28 <Cale> I only pasted the top block of code
19:36:12 <sebell> Cale: There's another further down along the same lines... sorry, I meant on the page
19:36:31 <Cale> aha
19:36:33 <Cale> :)
19:36:54 <int-e> @index forkIO
19:36:55 <lambdabot> Control.Concurrent
19:37:30 <Cale> this deserves a page
19:37:39 <Cale> I'll write it
19:38:02 <int-e> @index warn
19:38:02 <lambdabot> bzzt
19:38:05 <int-e> ?
19:41:16 <TheHunter> warn is unnecessary, killThread doesn't throw an exception even if the thread doesn't exist anymore.
19:41:58 <int-e> and actually that could happen if both threads finish simultaneously
19:42:46 <TheHunter> yeah, that's why it should be readMVar and not takeMVar...
19:44:48 <int-e> yep, that'd be better
19:45:08 <sebell> Cale: I slightly modified the timeout function on the paste site, works great
19:45:30 <TheHunter> and it doesn't DTRT if expensive throws an exception.
19:48:52 <TheHunter> and since expensive is an IO action, one could do without the `seq`.
19:50:13 <Cale> yeah, I'm not exactly sure why that was there
19:50:43 <int-e> hrm. there's a race condition there. thread 2 puts its value, main thread kills it and then kills thread 2 ... thread 1 is never killed.
19:52:28 <Cale> the killThread and putMVar should be swapped
20:19:15 <araujo> Hello.
20:24:59 <luqui> is there a good haskell STM tutorial/explanation somewhere?
20:25:25 <SamB> dons: this help doesn't work right in 80x24
20:27:01 <SamB> there is a nice paper
20:27:22 <SamB> @google simon peyton-jones composable transactions
20:27:23 <lambdabot> http://research.microsoft.com/Users/simonpj/
20:27:50 <SamB> well, I guess it is probably on his page ;-)
20:32:56 <Cale> http://www.haskell.org/hawiki/TimingOutComputations
20:34:43 <int-e> . o O ( action >>= putMVar mvar )
20:34:44 <Cale> It's bad that the documentation is so empty.
20:35:03 <Cale> int-e: that works :)
20:44:27 <Cale> that program is evidence that Haskell is a pretty decent imperative language, I think :)
20:45:20 <int-e> well ... maybe. but it's still hard to write loops that run within an order of magnitude of the equivalent C code
20:45:29 <int-e> (in terms of running time)
20:47:54 <Cale> Well, that's true, though I've come to expect it, and most often an order of magnitude really isn't so bad.
20:49:56 <int-e> Cale: I guess it's not vitally important, because Haskell's FFI is quite usable in when speed matters.
20:50:03 <Cale> yeah
20:50:31 <int-e> Cale: Although I still need to learn a bit about the cooperation with the garbage collector there.
20:51:10 <Cale> It seems to have some issues, though we should talk more with the Simons.
20:51:55 <Cale> It appears that ForeignPtrs look about the size of a pointer to the garbage collector, and not the size of the actual foreign object.
20:53:31 <Cale> you can always force them to finalize manually, but that sort of defeats the purpose
20:53:38 <int-e> hmm, well from the gc point of view that's right ... it doesn't really know about the C heap object associated with it.
20:54:02 <Cale> right, but that's a problem when the C heap object is really large
20:54:27 <Cale> finalizing that ForeignPtr might actually reclaim a huge amount of memory
20:55:17 <int-e> yeah, I see the problem.
21:00:37 <Cale> How does one obtain the size of a block of memory allocated on the heap in C?
21:00:53 <int-e> remember it
21:02:05 <mwc> Cale: you can't
21:02:05 <Cale> that's annoying, clearly it's stored somewhere, as otherwise, free wouldn't know what it is doing.
21:02:14 <mwc> It would be implementation defined
21:02:33 <mwc> write your own functions over malloc and free that keep the size of the block?
21:03:03 <Cale> That doesn't particularly help with garbage collection and FFI :)
21:03:21 <unixgreybeard> how much faster are pure haskell inner loops if you use an unboxed mutable array inside a monad (under ghc)?
21:03:57 <Cale> unixgreybeard: well, depends -- I'd probably try a DiffArray first.
21:04:16 <int-e> especially in a case of a library like cairo which does its own allocation using malloc and free ...
21:04:41 <mwc> Cale: you could try using realloc to change the block size?
21:04:47 <mwc> then you'd know :P
21:05:02 <Cale> heh
21:05:08 <Cale> terrible
21:05:33 <Cale> could the linker do anything about it?
21:05:48 <mwc> no, I don't think so
21:05:58 <mwc> The size of the block would be in the bowls of the libc
21:05:58 <int-e> but actually in the case of cairo knowing the size wouldn't help much either.
21:06:22 <Cale> int-e: hmm
21:06:41 <int-e> Cale: because the cairo objects are structs many of which contain more pointers
21:06:47 <Cale> ah, perhaps that pointer is to a structure with another pointer in it which h... yes
21:07:27 <unixgreybeard> cale: I'm prolly going to use a Data.Array.MArray
21:07:34 <unixgreybeard> of Word32
21:08:25 <Cale> unixgreybeard: well, that's just an abstract class of arrays, but probably something like an IOUArray
21:09:02 <Cale> If you don't mind writing your computations in the IO monad, mutable arrays are okay. :)
21:09:46 <Cale> Diff arrays give you most of the benefits of mutable arrays, while presenting a pure interface.
21:10:14 <Cale> But I haven't looked at speed comparisons
21:11:36 <Cale> Surely Diff arrays are a little bit slower (some constant), but how much that constant affects things in practice is a good question
21:11:51 <int-e> Cale: I guess you need an independent GC trigger for that. This could be just two variables on the RTS side - a counter and a threshold; the interface would allow adding a value to the counter; if the counter exceeds the threshold, a GC is triggered. There should be a way to increase the threshold, but I'm not sure how that should be done.
21:12:25 <Cale> int-e: Perhaps it would be sufficient to have size hints for ForeignPtrs
21:13:16 <int-e> Cale: that still wouldn't trigger a GC if there are few allocations on the Haskell side but many on the C side.
21:14:21 <int-e> Cale: A GC is only triggered right now when the current half-space of the nursery generation is full, for all I know.
21:15:00 <Cale> Well, we already have finalizeForeignPtr which forces the thing to call all its finalizers.
21:16:10 <Cale> I was thinking along the lines of addForeignPtrSizeHint :: Int -> ForeignPtr a -> IO (), which would cause the GC to treat the ForeignPtr as if it was the given size.
21:17:36 <Cale> which is not ideal, but in some cases you can estimate the size closely enough.
21:18:34 <Cale> s/add/set/
21:19:55 <dons> SamB, help doesn't work right? or not at all?
21:21:44 <joelk> any good examples of how to use MissingH.Compression.Inflate ?
21:24:25 <Cale> Igloo?
21:24:47 <Cale> (seems Igloo wrote it)
21:26:05 <Cale> heh, it's sort of nice that for most of the Haskell code you're likely to encounter, the people that wrote it are available either here, or at least on the mailing list :)
21:26:58 <luqui> therefore the set of "discriminating hackers" is fairly small
21:34:27 <Korollary> There's also another compression library mentioned in the HCAR
21:34:49 <Korollary> which seemed to provide lzma and grzip
21:35:34 <kmag> ooh... lzma :-D
21:35:55 <Korollary> I didnt know about grzip. Apparently that's a good one, too.
21:36:19 <kmag> lzma is much slower than gzip for compression
21:36:39 <kmag> but decompression is about the same speed
21:36:49 <kmag> and you generally get much better compression using lzma
21:37:11 <Korollary> yeah, I use 7-zip on windows
21:38:40 <kmag> at work, we have an NSIS script that tries to compress our software installer with zlib deflate, bzip2 (rle, bwt, mtf, huffman), and lzma
21:38:49 <kmag> and keeps the smallest package
21:39:23 <kmag> it always ends up keeping the lzma package
21:39:46 <kmag> of course, we keep telling it to try the others, just in case
21:40:13 <dons> SamB, ah, I see. the progress bar overwrites it. well spotted.
21:40:39 <kmag> so... is "strict evaluation" the opposite of "lazy evaluation"?
21:40:50 <kmag> I usually heard it called "eager evaluation"
21:41:11 <Cale> lazy evaluation is a kind of non-strict evaluation
21:41:50 <kmag> so what's the definition of strict?
21:42:18 <unixgreybeard> immediate, imperitive evaluation like in most other programming languages
21:42:29 <Cale> really, it's strict/nonstrict semantics
21:42:37 <Cale> and eager/lazy evaluation
21:42:39 <unixgreybeard> hi Korollary!
21:42:51 * Korollary high-fives Tucson, AZ
21:43:30 <kmag> Do any of you have write access on haskell.org?
21:43:39 <unixgreybeard> I think so
21:43:42 <kmag> On http://www.haskell.org/comparison.html,
21:43:44 <Cale> "strict evaluation" means the same thing as "eager evaluation" as far as I know though
21:44:09 <kmag> all of the "?" for Erlang can be replaced by the values from Scheme
21:44:55 <Korollary> That table needs more entries imho
21:45:02 <Korollary> to give people a better idea
21:45:11 <Korollary> there are tons of people that know none of those languages
21:47:24 <kmag> Python, C...
21:47:35 <unixgreybeard> K: I finished reading up more on the silly crypto laws in the US, and can post source since I've now sent the required email to the (ugh) NSA with it's url
21:48:06 <Korollary> unixgreybeard: now the NSA will start spamming you...
21:48:10 <unixgreybeard> but only people from these countries can click the link, or they are naughty bad!: United States, Canada, Austria, Australia, Belgium, Cyprus, Czech Republic,
21:48:10 <unixgreybeard> Estonia, Denmark, Finland, France, Germany, Greece, Hungary, Ireland, Italy,
21:48:10 <unixgreybeard> Japan, Latvia, Lithuania, Luxembourg, Malta, Netherlands, NewZealand, Norway,
21:48:10 <unixgreybeard> Poland, Portugal, Slovakia, Slovenia, Spain, Sweden, Switzerland, UK
21:48:50 <int-e> fun!
21:48:58 <unixgreybeard> So far, I've got the stateless functions and low bit length constants: http://davidmercer.nfshost.com/projects/shaskell/shaskell.hs
21:51:21 <kmag> I don't belive that digest functions are export controlled from the US
21:51:36 <kmag> since they cannot be directly used for encryption
21:52:03 <Korollary> apaprently, sha-224 and higher are.
21:52:19 <kmag> SHA-224 ?
21:52:27 <kmag> I'm not aware of such a spec
21:52:43 <Cale> heh, you could just send it to someone in one of those countries and have them export it to all the others
21:52:43 <kmag> Where are you reading  this?
21:53:36 <kmag> whoah... I think I was on the vast minority side of that net split
21:53:41 <Korollary> I know it exists (sha2 on wikipedia). unix..beard says it is export controlled.
21:54:01 <Cale> heh, you could just send it to someone in one of those countries and have them export it to all the others
21:54:51 <unixgreybeard> see section 11. on page ii of the pdf at http://davidmercer.nfshost.com/projects/shaskell/fips180-2withchangenotice.pdf
21:55:29 <unixgreybeard> the statefull parts in section 6.2.2 are what have had me asking horribly complex questions about monads here this whole past few days
21:55:48 <Cale> of course, you probably wouldn't be allowed to tell them to do that :)
21:56:01 <unixgreybeard> tell who to do what?
21:56:19 <Korollary> it's all redtape that won't prevent anything.
21:56:29 <Cale> unixgreybeard: reexport your code :)
21:56:36 <unixgreybeard> oh what, people from naughty countries go and look at the spec? THAT is ok, it's public domain, it's just sw that they care about
21:57:28 <unixgreybeard> yeah, it's all stupid since the publication exception got punched by Zimmerman, which is why they changed the rules in 2000 so that you just have to notify them via email "prior to posting"..the the exports.txt file in the dir you get by url chopping all those links above
21:57:58 <unixgreybeard> took me days of reading pdf's on .gov and mailing list archives to get all that sorted out
21:59:13 <unixgreybeard> I think it's a racist list myself, as all of the 'good' countries on can export/reexport crypto to from the US without a license are all pretty white, except for Japan.
21:59:16 <araujo> @index find
21:59:17 <lambdabot> Data.List
21:59:43 <int-e> Cale: here's a challenge: come up with a version of the matrix multiplication in http://web.inf.tu-dresden.de/~bf3/haskell/matrix.hs that does not allocate thunks like crazy and is more competetive with the C version.
22:00:40 <JoshTriplett> When reading a type from a string, how do I ensure that the entire string is read in (and there isn't any trailing garbage)?  If I use do ...; s <- getLine; let e = (read s)::TheType; ..., "read" may only consume part of the string to come up with "e".
22:01:16 <int-e> Cale: (just an idea why it still allocates so much, 73 bytes per inner 'loop' iteration would be nice, too)
22:01:58 <luqui> JoshTriplett, I think read reads the whole string no matter what
22:02:07 <luqui> do you have a counterexample?
22:03:47 <JoshTriplett> luqui: Well, it could be that my readsPrec function for TheType is broken. :)
22:04:24 <luqui> probably.
22:04:29 <luqui> > read "144foo" :: Int
22:04:30 <lambdabot> Prelude.read: no parse
22:04:51 <JoshTriplett> luqui: I'm still trying to get a clear understanding of how "read" and my readsPrec function interact.
22:04:52 <unixgreybeard> any comments on shaskell.hs can be sent to me off channel at radix42@gmail.com also
22:05:02 * luqui has never written a readsPrec function
22:05:04 * luqui looks
22:06:07 <JoshTriplett> luqui: I've created a LambdaExp type, and I'm making it an instance of Read.
22:08:13 <luqui> I think "read" returns "no parse" if there is a remainder from what ReadS returns
22:08:17 <luqui> er, readsPrec
22:08:44 <luqui> maybe a nonwhitespace remainder
22:08:48 <luqui> to be honest, I dunno
22:09:17 <joelk> ok, to answer my own question: the source of MissingH.FileArchive.Gzip is probably the best (and only) available example of MissingH.Compression.Inflate.  I was really looking for the former in the first place...
22:09:18 <JoshTriplett> luqui: I have an existing parser which works correctly, but takes up about two pages of dense Haskell code.  I'm trying to rewrite my parser along the lines of the readsTree parser described in http://www.haskell.org/tutorial/stdclasses.html
22:09:50 <luqui> or maybe you should just use parsec
22:10:03 <JoshTriplett> luqui: Yeah, I'm going to try that next.  Looks a lot easier. :)
22:10:16 <luqui> I've written enough parsers by hand to know that I'm never going to do that again :-)
22:10:20 <JoshTriplett> luqui: But I do want to understand how reading works in the standard library.
22:10:23 <luqui> and parsec is really nice
22:10:46 * luqui dunnos about that
22:11:27 <JoshTriplett> luqui: Well, the list-comprehension-based tree parser in the Gentle Introduction to Haskell doesn't look particularly nasty.
22:11:56 <luqui> well, it's just using the list monad
22:12:00 <luqui> for backtracking
22:12:19 <JoshTriplett> True.
22:12:46 <luqui> you can think of that comprehension as returning all possible parses of the input
22:12:52 <JoshTriplett> Right.
22:13:03 <JoshTriplett> And, for that matter, all possible partial parses.
22:13:03 <int-e> @index unsafeAt
22:13:04 <lambdabot> bzzt
22:13:06 <luqui> Bool.  Either.
22:13:27 <JoshTriplett> luqui: pardon?
22:13:33 <luqui> You said True, Right.
22:13:40 <luqui> :-)
22:13:48 <JoshTriplett> Heh.
22:14:02 * JoshTriplett tries to figure out how "Right :: Either"...
22:14:27 <luqui> well, Right 13 :: Either a Int... so it's kinda close
22:14:39 * JoshTriplett looks up Right
22:14:42 <luqui> @type Right
22:14:43 <lambdabot> forall b a. b -> Either a b
22:14:51 <dons> @kind Either
22:14:52 <lambdabot> * -> * -> *
22:16:01 <JoshTriplett> @find Right
22:16:02 <lambdabot> Not in scope: type constructor or class `Right'
22:16:12 <JoshTriplett> Where is it defined?
22:16:19 <dons> @docs Data.Either
22:16:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
22:16:23 <JoshTriplett> Thanks.
22:16:27 <dons> @index Either
22:16:27 <lambdabot> Data.Either, Prelude
22:21:40 <araujo> Hello dons !
22:22:00 <dons> hey araujo, how's code?
22:22:26 <araujo> dons, the hs-plugins's eval can perfectly run a 'case .. of .. { ..; ..; .. }' statement?
22:22:36 <araujo> dons, Doing pretty well , Thanks :-)
22:23:00 <araujo> I just got back home from a small trip , and now i a re-starting my usual hacking :-)
22:23:16 <dons> > case (1,2) of { x -> True ; _ -> False }
22:23:17 <lambdabot>   Warning: Pattern match(es) are overlapped
22:23:17 <lambdabot>      In a case alternative: _ -> ...
22:23:26 <dons> > case (1,2) of { (x,2) -> True ; _ -> False }
22:23:27 <lambdabot> True
22:23:33 <dons> is that what you mean?
22:24:40 <dons>  > is uses System.Eval.Haskell, so if it works here, it works in hs-plugins
22:25:17 <araujo> Good to know
22:25:23 <araujo> Yeah, taht's what i meant, thanks
22:25:31 <araujo> My error must be somewhere else
22:25:40 <araujo> dons, how your hacking goes?
22:26:03 <dons> almost finished hmp3, almost!
22:26:16 <dons> it's very stable now, and only one feature left to implement
22:26:51 <araujo> Terrific!
22:27:03 <araujo> gez.. i think i got it here to test it _yet_
22:33:15 <araujo> > let num = 5 in case num of{ Just _ -> [] ; Nothing -> num }
22:33:16 <lambdabot> Couldn't match `[a]' against `Maybe a1'
22:33:45 <araujo> > let num = [5] in case Just num of{ Just _ -> [] ; Nothing -> num }
22:33:46 <lambdabot> []
22:34:35 <luqui> dons, do hs-plugins work in ghc-6.4?
22:35:51 <dons> yes
22:36:25 <luqui> yes, I just found that.
22:36:32 <luqui> last time I tried to install them through gentoo it whined at me
22:36:38 <luqui> but I guess they updated their ebuilds since then
22:37:42 <mwc> wow, dons, how out of date is hs-plugins 20050407
22:38:40 <luqui> dons, hs-plugins hs-plugins hs-plugins, hs-plugins?
22:38:42 <luqui> :-)
22:38:51 <mwc> I just saw him here
22:38:58 <mwc> figured I'd ask a burning question
22:39:36 <araujo> luqui, it perfectly works on Gento
22:39:39 <araujo> Gentoo even
22:39:49 <dons> luqui, just use the darcs repo
22:39:52 <araujo> I am using it with ghc-6.4.1 with no problem so far
22:39:54 <luqui> right, but a few months ago it didn't...
22:40:18 <luqui> where few = one
22:40:19 <araujo> luqui, whenever that happens, don't doubt reporting a bug please 
22:40:45 <luqui> mmkay
22:41:10 <araujo> Oh, btw, now you mention it, correct
22:41:27 <araujo> It wasn't working around 2 months ago
22:41:42 <araujo> I updated it myself now i remenber it :-)
22:42:01 <mwc> dons: the reason I ask is that that's the version in darwin ports right now, and I'm wondering if I should bother trying to update it at some point
22:42:39 <dons> 0407 is fairly out of date
22:42:56 <dons> hs-plugins 0.9.10 was released in July
22:43:08 <dons> unless I'm reading that date the wrong way around...
22:43:20 <dons> the last stable release was July 6, 2005
22:43:26 <araujo> That's the release we've got i the tree.....
22:43:30 <dons> however, a new release is rapidly approaching.
22:43:47 <dons> it's in darcs. http://www.cse.unsw.edu.au/~dons/code/hs-plugins
22:44:25 * araujo would like to have darcs-based ebuilds
22:44:57 <dons> then I'd never have to produce a tarball again
22:45:00 <dons> cool!
22:45:03 <mwc> damn, what have I done here: ghc is inferring: (Ix (b, b), Ix b, Integral b, Floating b) =>
22:45:06 <mwc>               b 
22:45:07 <araujo> :-)
22:46:43 <mwc> is there even a type that's both Integral and Floating?
22:47:04 <int-e> no
22:47:17 <mwc> damn, okay, so I broke something :(
22:47:58 <int-e> a missing fromIntegral (to convert to Floating) maybe?
22:48:14 <mwc> I thought I'd taken care of it all
22:48:30 <mwc> I'm going to try compiling adding one definition at a time
22:48:35 <mwc> hopefully that will choke on the error
22:52:45 <int-e> Cale: ok, the culprit for the allocations was using pairs for indexing arrays - apparently the Ix operations for that don't get inlined. Avoiding them (thus not creating the pairs on the heap) cuts the running time down to a half, and the allocations to 9 MB instead of ~500 MB for the inner loop.
22:52:56 <mwc> Wow
22:53:02 <mwc> I was having the same problem
22:53:25 <mwc> it was taking 30 seconds to calculate a numerical solution to a pde on a 20x100 mesh
22:53:40 <mwc> I was using paired indexes as well
22:54:06 <int-e> well the C version is still 30 times faster ...
22:54:23 * araujo feels stupid when he can't find syntax errors
22:54:36 <dons> hehe. they're *really* annoying
22:54:57 <mwc> What I miss in Haskell is the ability to compile very often
22:55:01 <dons> I had some terrible one the other night, the line number was way off though
22:55:10 <dons> mwc, just stick the code in ghci
22:55:13 <dons> that's the easiest way
22:55:17 <mwc> yeah
22:55:18 <dons> do a :reload
22:55:18 <araujo> *nods*
22:55:24 <mwc> that's what I mean
22:55:42 <mwc> In my C style, I run a compile every 20 lines or so
22:55:50 <dons> anyway, all you really care about is typechecking, right?
22:56:01 <mwc> yeah
22:56:02 <dons> so maybe ghc -fno-code would be also reasonable
22:56:21 <mwc> true
22:56:44 <mwc> it seems that when I right haskell I don't have code that's ready to be typechecked until I've implemented the whole block
22:56:57 <mwc> s/right/write
22:57:02 <mwc> what can I say, it's 2 am
22:57:08 <dons> just do functions at a time, and sprinkly `undefined' all over the plaace
22:57:17 <dons> or 'error "foo"'
22:58:14 <mwc> Ah
22:58:15 <mwc> that works
22:58:32 <mwc> I'll keep that in mind
22:59:10 <araujo> repl rulez.
22:59:56 <int-e> right ... no inlining is done for the (Ix a, Ix b) => Ix (a, b) instance.
23:00:00 * lispy misses having time for #haskell
23:00:06 <Korollary> hey lispy
23:00:15 <lispy> Korollary: oh hey, how's it going
23:00:22 <mwc> Wow, that's a really horrible... bug I guess
23:00:25 <Korollary> all right. I am in Seattle now.
23:00:36 <lispy> Korollary: haha, cool
23:00:36 <int-e> there's a specialized instance (Int, Int) but that's not quite the same.
23:01:04 <mwc> Well, it handles my concern
23:01:22 <lispy> Korollary: I told my advisor i had enough of the kind of research our group does, found a new advisor, got told there would be no funding till at least next fall and now i'm looking for a new job (how's that for a run-on sentence)
23:01:29 <mwc> until I go to 3D
23:01:43 <int-e> interestingly, there used to be inline declarations there, I wonder why they were removed.
23:01:49 <Korollary> lispy: attaboy ! show them pinhead faculty how it's done !
23:03:22 <lispy> Korollary: yeah, i wanted to get out of the HCI rut and into something more excting like graphics
23:03:51 <int-e> mwc: there's also a specialised Ix instance (Int, Int, Int) ... but it will still have to allocate the triplet on the heap before it can call these functions.
23:03:57 <Korollary> lispy: humans shouldn't interface with computers imho
23:04:21 <lispy> Korollary: i was able to get a graphics/animation prof and an fp prof excited
23:04:30 <lispy> but, then this whole thing about funding came up
23:05:02 <lispy> Korollary: heh, yeah, no kidding
23:05:19 <Korollary> lispy: what kinda job are you looking for ?
23:05:50 <lispy> Korollary: i was hoping to find some programming position in town for 9 months
23:06:40 <lispy> Korollary: but, my town doesn't have many of those.  I see two right now.  One is for an Objective-C/Cocoa position and the other is Java/.NET
23:06:59 <lispy> they are at the same company interestingly enough
23:07:03 <araujo> @index isJust
23:07:03 <lambdabot> Data.Maybe
23:07:26 * lispy hasn't had time to write a line of haskell since this summer
23:07:32 <lispy> i've been too busy with "research"
23:07:42 <lispy> but how can it be CS research if there is no haskell???
23:07:47 <araujo> What kind of research?
23:08:00 <Korollary> heh, well there's all kinds of research.
23:08:03 <lispy> writing a journal paper on some weird HCI thing
23:08:07 <araujo> That's what i was about to get at :-)
23:08:09 <Korollary> HCI is not my favourite regardless
23:08:41 <araujo> HCI?
23:08:51 <lispy> i think HCI is like a car.  I like cars because they get me places and save me time.  I don't want to become a mechanic or an automotive engineer.
23:09:00 <lispy> human-comuter interaction
23:09:25 <Korollary> lispy, you can replace <car> with <computer> in that sentence heh.
23:10:14 <araujo> Oh...
23:10:18 <vegai> computers save time?
23:10:27 <vegai> now *there's* a research subject
23:10:34 <araujo> lispy, That sounds very general though , or i am missing something?
23:10:42 <pejo> vegai, sure, they let you do errors twice as fast!
23:10:44 <Korollary> vegai: not *your* time.
23:10:48 <vegai> :)
23:11:03 <lispy> araujo: i can be more specific if you like
23:11:19 <lispy> araujo: our group does "end-user software engineering"
23:11:19 <Korollary> let's all agree that HCI is bogus and move on imho
23:11:21 <araujo> lispy, Please do :-)
23:11:31 <vegai> @vera HCI
23:11:32 <lambdabot> *** "hci" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June
23:11:32 <lambdabot> 2002)"
23:11:32 <lambdabot> HCI
23:11:32 <lambdabot>   Host Controller Interface (Bluetooth, Linux)
23:11:32 <lambdabot>  
23:11:34 <lambdabot> [5 @more lines]
23:11:37 <vegai> oh.
23:11:42 <dons> has everyone filled out the Haskell survey?? 
23:11:44 <dons> http://www.cs.chalmers.se/~rjmh/Wash/Survey/Survey.cgi
23:11:48 <dons> please do if you haven't
23:11:50 <lispy> dons: hi!
23:11:53 <lispy> dons: okay
23:11:55 <dons> it's very fast to fill out
23:11:57 <dons> hey lispy.
23:12:15 <araujo> lispy, oh, i see, it is researching oriented to usability?
23:12:28 <lispy> araujo: we add software engineering inspired features to spreadsheets.  Except, my advisor is getting more and more into psychology and doing less and less CS
23:12:35 <lispy> araujo: yes!
23:13:07 <vegai> on the "Are you currently" -question. I'm in a way all of those selections
23:13:15 <vegai> oh well... :)
23:13:30 <araujo> lispy, i see now
23:14:01 <araujo> Well, i think you really need to work both with CS and psychology too.
23:14:26 <lispy> what is darcs vs. DARCS?
23:14:26 <Korollary> I think excel spreadsheets are psychologically damaging.
23:14:59 <araujo> I particulary like to see CS more related to philosophy than science.
23:15:06 <araujo> *but hey, that's just me*
23:15:06 <lispy> araujo: i think that collaborating with psychologists is improtant.  But I don't think as a CS researcher I need to be reading psychology papers and writing them
23:15:52 <araujo> hah, yeah, psychology uses to be a pain in the _head_ :-)
23:18:07 <lispy> man, those stats are cool
23:18:19 <lispy> dons: i'm going to email that to my schools grad list
23:25:42 <araujo> mm...
23:26:00 <araujo> People between 1980-85 are the most interested in Haskell so far (it looks)
23:26:37 <araujo> Makes sense, considering that the statdistic show 'students' as the main vocation.....
23:36:26 <Cale> whee, easy-to-use animation with cairo :)
23:38:18 <mwc> araujo: for statistical data: Born March 1985, 3rd Year Applied Mathematics Undegrad
23:39:44 <araujo> hah, 1982 here, and CS student :-]
23:40:23 <Cale> 1983, Pure mathematics graduate
23:41:10 <mwc> Could you take a look at: http://haskell.org/hawiki/HaskellIrcPastePage and tell me if that array I'm using is memoizing the calculations?
23:41:23 <mwc> basically, the performance is so slow I'm begining to wonder if i'm not
23:41:57 <mwc> My code is the topmost block
23:42:19 <Cale> it should memoise within a single call to waveSolver
23:42:26 <mwc> hmm
23:42:42 <mwc> so my usage pattern is: sol = waveSolver 1.0 ((\x -> 0.0),(\x -> 0.0)) (sinc,(\x -> 0.0)) (-20.0,20.0,nx) (0.0,20.0,nt)
23:42:45 <mwc>     dataPoints = [sol (x,t) | x <- range (0,nx), t <- range(0,nt)]
23:43:01 <mwc> so I'm partially applying the solver, and then pulling points out of it
23:43:45 <Cale> ah, hmm
23:43:57 <Cale> then likely not
23:44:04 <mwc> It's not memoizing?
23:44:05 <mwc> Hmm
23:44:14 <Cale> you'll have to lift mesh out to a higher level them
23:44:15 <Cale> then*
23:44:18 <mwc> blast, I was counting
23:44:28 <mwc> God, that'll be ugly
23:44:52 <Cale> um, hmm
23:45:13 <Cale> the definition of mesh doesn't explicitly use x' or t'
23:45:30 <mwc> good point
23:45:43 <mwc> So I return an array then
23:45:51 <Cale> So you should be able to reorganise that code into something where it will memoise
23:45:56 <Cale> use a let and return a function
23:46:46 <Cale> I'm not certain if it will do that already or not
23:48:57 <Cale> oh
23:49:23 <Cale> hmm, it's actually pretty surprising if that doesn't memoise
23:49:28 <Cale> well, there's a way to find out :)
23:49:52 <mwc> Debug.Trace?
23:50:07 <Cale> import Debug.Trace and put a "trace "Mesh" $" before the mesh array definition.
23:52:19 <joelk> hmmm.. for some reason debian's most current ghc doesn't seem to have opengl any more... nor is it looking at the user package.conf... argh.
23:52:36 <Cale> opengl is in a separate package
23:52:54 <Cale> ghc6-hopengl
23:52:59 <mwc> Cale: I don't seem to be getting any trace data out :(
23:53:11 <Cale> not even one "Mesh"?
23:53:30 <mwc> not so far
23:53:35 <Cale> oh
23:53:37 <mwc> mesh = trace "Mesh" $ array
23:53:46 <mwc> right?
23:54:28 <Cale> is init supposed to take mesh as a parameter?
23:54:32 <Cale> it doesn't have to
23:54:51 <joelk> ok, I know what's going on I think. apt troubles.
23:55:06 <mwc> no, it needs to
23:55:15 <mwc> basically I define most of the elements recursively
23:55:29 <Cale> but mesh is in scope in the body of init
23:55:30 <mwc> Cale: I see waht you mean though
23:55:38 <mwc> yeah, I just realized that
23:56:58 <Cale> call waveSolver with really small parameters -- you just want to see if the trace happens once or multiple times
23:57:45 <mwc> Well, I let it run for well over a minute, nothing
23:57:50 <mwc> but that was on a 20x40 domain
23:58:09 <mwc> you can see why I suspect I've written this in a way that's brought me into exponential time land
23:59:00 <mwc> do I have to pass a runtime flag to enable debug output?
23:59:52 <Cale> no
