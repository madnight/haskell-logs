00:06:37 <haskellnewbie> not sure...I'm having major trouble with monads
00:06:47 <haskellnewbie> I have made a class with polymorphic functions ok
00:07:43 <haskellnewbie> a class with instances to handle different types I've already got down ok
00:07:45 <basti_> haskellnewbie: thats great. it's very different than in C or the like isnt it?
00:08:03 <haskellnewbie> oh it's fucking beautiful
00:08:08 <basti_> ^^
00:08:19 <basti_> so what about monads?
00:09:11 <haskellnewbie> I just cannot grok what all of the different pieces are to a State monad
00:09:28 <haskellnewbie> I can't get any type signatures right at all for a monad
00:09:57 <basti_> hmmm
00:10:01 <basti_> do you mean State or StateT?
00:10:02 <yozora> is it just with the state monad, or monads in general?
00:10:14 <haskellnewbie> y: both
00:10:32 <haskellnewbie> b: I'm having trouble with State and StateT
00:10:36 <basti_> hmm
00:10:37 <basti_> do you know the maybe monad?
00:10:37 <yozora> do you understand Maybe?
00:10:39 <basti_> lol
00:10:47 <haskellnewbie> y: only dimly
00:11:06 <haskellnewbie> I'm trying to translate from imperitive pseudo-code that has 2 nested loops
00:11:06 <yozora> data Maybe a = Nothing | Just a
00:11:21 <yozora> go on
00:11:49 <haskellnewbie> so the state I need to keep is a function and an array that I pass in
00:12:31 <haskellnewbie> each "tick" of the loop would be updating the internally stored array, rather than passing the array around as a parameter, as in a non-monadic style
00:12:49 <basti_> are you sure you need a "tick"?
00:12:54 <haskellnewbie> not really
00:13:03 <basti_> > [x+y | x<-[1..3],y<-[1..3]]
00:13:04 <lambdabot> [2,3,4,3,4,5,4,5,6]
00:13:13 <yozora> what's the purpose of the two loops?
00:13:18 <basti_> (nested loops)
00:13:54 <haskellnewbie> I'm writing SHA-2 purely in haskell, rather than update the Digest.hs wrapper to openssl to handle the newer digests
00:14:15 <haskellnewbie> the loops are calculating the hash of the message
00:14:29 <basti_> hmm so you probably truly want to pass some state
00:14:36 <haskellnewbie> yes
00:14:38 <yozora> there's the ST monad as well
00:14:42 <basti_> from the previous incarnation of the loop to the next
00:14:54 <basti_> then you're at a good spot with the state monad
00:15:22 <yozora> you can use mutable state in the ST monad and then extract the pure result
00:15:53 <haskellnewbie> hhmmmm, lemme go look at the ST pages real quick
00:16:14 <basti_> or ST yes
00:16:40 <yozora> to be honest i haven't used the State monad since i found out about the ST monad
00:17:15 <haskellnewbie> and I will need to be in the IO monad for at least parts of it in my toplevel functions
00:17:38 <haskellnewbie> heh, this is my first haskell program, way to learn a language, huh?
00:17:47 <basti_> ^^
00:17:52 <yozora> a challenge is always nice :)
00:18:32 <yozora> the top level tends to be in the IO monad but you generally try to make stuff as pure as you can
00:18:47 <haskellnewbie> the stateless parts of it that I have done so far are just gorgeous: it's like a direct translation of the sha-2 spec's mathematical notation into code, one to one!
00:19:02 <basti_> :D
00:19:47 <araujo> haskellnewbie, definetly the best way to understand monads is through Maybe
00:19:50 <haskellnewbie> my long-term goal of this project is to be able to prove various properties of this implementation, something that can't be said with any other sha versions
00:19:56 <araujo> So, take that way
00:20:13 <araujo> Unless you are an expert in CT :-]
00:20:22 <haskellnewbie> CT?
00:20:28 <haskellnewbie> ah, category theory?
00:20:33 <araujo> Category Theory.
00:20:35 <araujo> yes
00:21:02 <haskellnewbie> the only reason I understand the theoretical bits about monads at all is because I'm taking group theory this semester
00:21:19 <haskellnewbie> it's the practice that's getting me!
00:21:24 <araujo> That sounds nice then
00:21:44 <basti_> > evalState ((sequence_ $ replicate 10 (get >>= \x->put $ 5+x)) >>= (\_->get >>= return )) 5
00:21:45 <lambdabot>  Not in scope: `get'
00:21:48 <basti_> argh
00:21:51 <basti_> :D
00:22:26 <haskellnewbie> oh lord that looks so far above my head!
00:22:38 <stratocaster> haskellnewbie: Have you taken a look at the http://nomaware.com/monads/ intro already?
00:22:39 <basti_> it took me quite a time to put together too
00:22:49 <basti_> mainly because there's so many single parts involved
00:23:06 <yozora> is there a new command for lambda bot?
00:23:10 <yozora> > 1+1
00:23:10 <lambdabot> 2
00:23:17 <yozora> ahh
00:23:23 <haskellnewbie> strato: yes, I have had parts of that open for the last two days!
00:23:47 <stratocaster> Great.
00:25:56 <haskellnewbie> strato: I don't understand something in the "state" example on that page: where the heck does StdGen come from?
00:26:27 <boegel> @index StdGen
00:26:28 <lambdabot> System.Random
00:26:32 <boegel> haskellnewbie: ^
00:26:35 <haskellnewbie> ok
00:26:45 <haskellnewbie> thx
00:27:09 <basti_> basically, monadic values are scripts
00:28:04 <haskellnewbie> this is harder to grok than call/cc in scheme!
00:28:14 <basti_> ah you haven't seen call/cc in haskell
00:28:14 <basti_> ^^
00:28:15 <yozora> callcc is nasty
00:28:37 <haskellnewbie> I"ve read the page for it on the wiki, kinda made more sense than the other monad stuff
00:28:58 <haskellnewbie> <-- abused myself by learning zetalisp at age 14, 20 years ago
00:30:24 <haskellnewbie> anyone have a page with a good ST monad example for me to go look at?
00:31:50 <basti_> hmm you could extend my iterator to work with a STRef instead of with State
00:31:58 <yozora> there's an imperative haskell page on the wiki i think
00:32:10 <basti_> ah yes
00:32:15 <basti_> @google imperative haskell
00:32:16 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2004-March/005876.html
00:32:24 <yozora> it looks just like imperative code
00:32:30 <yozora> with a runST at the front
00:33:55 <haskellnewbie> ok, I'm reading that example from the list that basti googled up....I'll holler when I get stuck (having a concrete thing to ask questions about is good)
00:35:14 <haskellnewbie> I'm baffled by one of the first lines: main = print $ runST something  
00:35:35 <basti_> yea
00:35:36 <basti_> why?
00:35:36 <basti_> ^^
00:35:59 <haskellnewbie> what does that do????
00:36:04 <basti_> @type runST
00:36:06 <lambdabot> Not in scope: `runST'
00:36:08 <basti_> :/
00:36:18 <basti_> runST must be something like :: ST a->a
00:36:29 <basti_> it runs the ST script
00:38:55 <basti_> @type  Control.Monad.ST.runST
00:38:56 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
00:39:22 <yozora> basically runST extracts the pure value from the monad
00:39:36 <astrolabe> Is this really a good way to learn about monads?
00:39:44 <yozora> you code up stuff inside the ST monad using mutable data
00:39:56 <yozora> and then extract the pure result with runST
00:40:06 <yozora> the type system prevents anything impure from leaking out
00:40:13 <haskellnewbie> how do I define my monad that uses ST???
00:40:27 <basti_> you don't need to "define" it
00:40:32 <yozora> just use it
00:40:33 <basti_> you need to define a monadic value
00:40:46 <haskellnewbie> what would THAT look like?
00:41:07 <basti_> hmm not all that hard
00:41:36 <basti_> newArray for example makes an STArray
00:42:17 <basti_> it goes like ... -> ST (STArray ...)
00:42:19 <basti_> in this case
00:44:48 <basti_> thats a monadic value
00:45:06 <haskellnewbie> how do I 'do stuff' to the STArray?
00:45:47 <basti_> (!) :: Ix i => Array i e -> i -> e
00:45:52 <basti_> ^^
00:46:20 <basti_> thats how you read
00:47:07 <basti_> ah no STArrays are MArrays
00:47:12 <haskellnewbie> I mean, how do I do more complicated things inside an ST monad? 
00:47:29 <basti_> so you use
00:47:30 <basti_> readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
00:47:31 <basti_> writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
00:48:05 <yozora> basically you write the code like it's imperative
00:48:14 <yozora> you define arrays and mutable cells
00:48:27 <yozora> and you use them and update them and whatever
00:48:31 <basti_> you just have to chain things with >>=, but the compiler can do that for you
00:48:39 <yozora> and at the end you return the result
00:48:48 <yozora> use the do notation
00:49:29 <yozora> @type Control.Monad.ST.STRef.newSTRef
00:49:30 <lambdabot> Couldn't find qualified module.
00:49:30 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
00:49:30 <lambdabot> \\)?
00:49:37 <yozora> @type Control.Monad.ST.newSTRef
00:49:38 <lambdabot> Not in scope: `Control.Monad.ST.newSTRef'
00:49:48 <yozora> @type Control.Monad.ST.STRef.makeSTRef
00:49:49 <lambdabot> Couldn't find qualified module.
00:49:49 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
00:49:49 <lambdabot> \\)?
00:49:53 <sethk> haskellnewbie, if it is possible, it is better to learn haskell in smaller chunks.  As in, get familiar with things in general before tackling monads.
00:50:03 <sethk> haskellnewbie, I know that means you don't get to write what you really need to write for a while, but it pays off.
00:50:16 <yozora> @type Data.STRef.makeSTRef
00:50:17 <lambdabot> Not in scope: `Data.STRef.makeSTRef'
00:50:22 <yozora> @type Data.STRef.newSTRef
00:50:23 <lambdabot> forall a s. a -> GHC.ST.ST s (GHC.STRef.STRef s a)
00:56:11 <haskellnewbie> here's what I've got so far, that builds, before adding any monad madness: http://davidmercer.nfshost.com/projects/SHA2.hs    (don't look at that URL unless you are a "US Person")
00:56:48 <sethk> haskellnewbie, I'm just a person
00:57:37 <haskellnewbie> heh, stupid legal disclaimer, since it's export controlled crypto code
00:57:48 <basti_> >.<
00:58:00 <basti_> will they come and get you if i look at that?
00:58:08 <haskellnewbie> what country are you in?
00:58:37 <haskellnewbie> hhhmmmm, maybe!
00:59:02 <haskellnewbie> not like the whole world doesn't have sha-2 code that wants it already, really
00:59:12 <haskellnewbie> it's just all in poopy C/C++
00:59:15 <basti_> ^^
01:00:11 <haskellnewbie> I want to make mathematically CORRECT munitions! :-)
01:00:20 <Lemmih> eivuokko: Got a patch? (:
01:03:07 <mardy> HI, got a question about ffi and haskell
01:04:03 <mardy> anybody have experience working with a c++ program depending on mmsystem.h then compiled and finally linked in ghc
01:04:54 <mardy> pretty much it works but of some reason I can't find methods that should be in mmsystem.h
01:05:40 <jlouis> Hey guys
01:05:42 <mardy> do I need to tell ghc where to find the .h files I need?
01:07:13 <jlouis> -I maybe
01:08:28 <Lemmih> The header file contains the actual methods?
01:09:29 <mardy> don't look that way to me no
01:15:14 <Lemmih> Then shouldn't you link with some library instead?
01:15:29 <mardy> looking at that currently :d
01:15:41 <mardy> just trying to find where that lib has hidden itself
01:26:30 * jlouis Applies a Conjure patch from SamB
01:28:03 <haskellnewbie> well I think I'm off for the night....thanx everyone, I'm at least a step closer to getting this crazy monad stuff now that I know which one I need to use!
01:45:14 <bringert> what's the difference netween Monoid and MonadPlus?
01:45:45 <bringert> just that a MonadPlus is a Monad?
01:48:38 <dons> class Monoid a where
01:48:38 <dons>     mempty  :: a
01:48:38 <dons>     -- ^ Identity of 'mappend'
01:48:38 <dons>     mappend :: a -> a -> a
01:48:38 <dons>     -- ^ An associative operation
01:48:41 <dons>     mconcat :: [a] -> a
01:49:02 <bringert> yeah, I can see the difference in the definitions
01:49:22 <bringert> I was wondering if anyone could help get an intuitive understanding of the difference
01:49:32 <bringert> help *me* get
01:49:52 <dons> hmm, not sure. perhaps read the monoid paper?
01:50:20 <musasabi> mempty ~ mzero; mappend ~ mplus, mconcat ~ foldl1 mplus
01:50:27 <musasabi> or something similar
01:50:46 <bringert> yeah, that what I thought, that why I was wondering about the difference
01:51:08 <mardy> yay! got it to work :D
01:51:29 <mardy> and hi bjˆrn :D
01:51:35 <bringert> hi mardy
01:52:23 <mardy> long time no see, I assume from you being here that you are still alive :D
01:52:25 <bringert> musasabi: isn't mconcat ~ foldl mplus mzero a better fit?
01:52:37 <bringert> it would seem that way, yes
01:54:21 <dons> unless brigert is a bot..
01:54:28 <dons> which is possible 
01:54:51 <bringert> tell me more about bots
01:55:00 <neologism> :))
01:55:05 <dons> haha
01:55:14 <bringert> @vixen Am I a bot?
01:55:15 <lambdabot> bots should be destroyed. they are so annoying
01:55:23 <dons> heh!
01:55:42 <neologism> why do you think bots are annoying
01:55:42 <neologism> :)
01:55:50 <dons> haha
01:55:55 <dons> :)
01:56:15 <bringert> @vixen why do you think bots are annoying
01:56:16 <lambdabot> a bot? what is that?
01:56:45 <bringert> vixen is not very convincing. her spelling is too good
01:56:57 <shapr> @vixen a/s/l
01:56:58 <lambdabot> 19/f/California
01:57:28 <bringert> there should be code in her to randomly mistype the output, after deciding what to write
01:57:43 <bringert> it shouldn't be to hard to mimic human mistakes
01:57:49 <shapr> Patch it!
01:57:50 <dons> I like this idea. very nice
01:57:53 <bringert> they're -> their etc.
01:58:00 <shapr> you're -> your
01:58:02 <bringert> I probably will
01:58:06 <dons> yeah, and then transposition errors and so on.
01:58:07 <bringert> and -> adn
01:58:20 <bringert> @vixen would you like that?
01:58:21 <lambdabot> i might :)
01:58:23 * shapr envisions an integration of GF and vixen
01:58:28 <neologism> 19/f/california
01:58:29 <neologism> hmmm ;)
01:58:39 * bringert has been considering that
01:58:46 <dons> GF?
01:58:51 <shapr> @where gf
01:58:51 <lambdabot> I know nothing about gf.
01:58:51 <dons> i can only guess..
01:59:08 <dons> oh, we've had this conversation I think
01:59:22 <bringert> dons: Grammatical Framework, though in vixen's case the other meaning might be more appropriate
01:59:24 <shapr> @where+ gf http://www.cs.chalmers.se/~aarne/GF/
01:59:26 <lambdabot> gf ~> http://www.cs.chalmers.se/~aarne/GF/
01:59:35 <bringert> GF is now in darcs btw
01:59:35 <dons> right ;)
02:00:04 <neologism> heh.. Ithought gf is a girlfriend :)))
02:00:48 <dons> my girlfriend isn't in darcs
02:00:50 <dons> but I'm trying!
02:01:08 <bringert> "you're not the person I fell in love with"
02:01:12 <bringert> darcs unpull
02:01:19 * dons thinks of some joke about bad conflict resolution
02:01:22 <neologism> yeah.. would be nice
02:01:37 <dons> darcs whatsnew -s
02:01:42 <bringert> haha
02:01:50 <dons> ah, cherry picking from other repos might be fun
02:01:55 <bringert> dude
02:02:12 <neologism> hm... cherry picking :)
02:02:15 * shapr bounces cheerfully
02:02:16 <kosmikus> too many dependencies between patches, usually
02:02:45 <bringert> dons, you want to have pieces of other people's versions of your girlfriend?
02:03:01 <dons> hehe. hmm. now I'm confused
02:03:17 <dons> I'm willing to accept patches though
02:03:49 <kosmikus> some company should patent the concept of a girlfriend
02:03:55 <bringert> but you won't grant read-write access to just anyone?
02:04:01 * bringert goes too far
02:04:15 <dons> oh bringert :p
02:04:18 <shapr> I just got email from SPJ. It's a sound file of him pronouncing Haskell, for the next issue of The.Monad.Reader. :-)
02:04:24 <bringert> haha
02:04:28 <dons> cool!
02:04:37 <dons> though he says it in a very normal way, doesn't he?
02:04:40 <shapr> bringert: ouch!
02:04:43 <jlouis> shapr: hahaha!
02:04:45 <bringert> "My name is SPJ, and I pronounce Haskell Haskell"
02:04:46 <dons> no weird linus-ism.
02:05:16 <bringert> hey, linux speaks swedish, his pronounciation is obviously the correct one
02:05:27 <shapr> Actually, SPJ doesn't say it the way I've been saying it.
02:05:39 <dons> oh, hehe. ok.
02:05:41 <dons> shapr?
02:05:48 * neologism wonders how can one say haskell in a different way
02:05:53 * dons wonders what optoins for pronouncing haskell there are.
02:06:01 <dons> ha-skell
02:06:03 * gdfk_ ponders the same thing
02:06:04 <dons> has-kell
02:06:10 <dons> hask-ell
02:06:10 <bringert> hask-ell
02:06:28 <shapr> I've been putting the stress on the last syllable, SPJ puts it on the first.
02:06:41 <neologism> what about "the damn functional thing" :)
02:06:44 <dons> ah, me too, on the first.
02:07:02 <bringert> in swedish it's pronounced with a different a sound
02:07:23 <bringert> I gues in french there is no h
02:07:59 <dons> and then there's the people who mishear you, and ask why you're working on Pascal
02:08:13 <bringert> which is pretty much everyone
02:08:19 <shapr> Yeah, true.
02:11:11 <dons> @uptime
02:11:11 <lambdabot> uptime: 1 day, 9 hours, 48 minutes and 36 seconds
02:11:21 <dons> someone want to patch @uptime to keep track of the maximum uptime?
02:11:31 <araujo> Good morning!!!!!
02:11:36 <dons> morning araujo!
02:11:42 <araujo> :-]
02:11:51 <araujo> What's up dons ?
02:12:02 <dons> must be 12 hours across the pacific.
02:12:16 <araujo> yeah
02:12:17 <dons> hackedy hack hack, as usual :)
02:12:24 <araujo> Cool :-]
02:13:09 <dcoutts> dons, so what are you hacking on?
02:13:21 <dons> just trying to finish hmp3 atm.
02:13:26 <dcoutts> cool
02:13:31 <araujo> :-]
02:13:38 <dons> dcoutts, btw, i'm working on a large gtk2hs project next year
02:13:41 * dcoutts would like to get back to hacking on the hIDE gui
02:13:45 <dcoutts> dons, oh yeah?
02:13:55 <araujo> dons, right now, i am using smsh , i was thinking to add history support for readline ....
02:14:08 <araujo> I should test your program
02:14:16 <dons> yeah, it's with some chemistry guys, doing polymerase (or something) simulation
02:14:26 <dcoutts> I've been doing a gui for a source code analysis algorithm
02:14:33 <dcoutts> lots of complicated graphs
02:14:35 <dons> and it will have a gtk2hs ui, I need to be able to draw 2 and 3 d plots
02:14:42 <dons> ah, graphs eh?
02:14:53 <dcoutts> dons, 2d and 3d plots, hmmm
02:15:04 <dcoutts> dons, cairo or opengl ?
02:15:11 <dcoutts> both work :-)
02:16:14 <dons> not sure. also, isn't there some gtkplot library?
02:16:19 <dcoutts> or if you don't want to draw the plots yourself then just call out to gnuplot
02:16:28 <dcoutts> there is a gtk plotting widget
02:16:32 * dcoutts finds it
02:17:08 <dons> right, that's how the demo works (via gnuplot). or are you thinking of a more integrated way with gnuplot?
02:17:15 <dcoutts> http://gtkextra.sourceforge.net/
02:17:17 <dons> araujo, yeah! test hmp3
02:17:26 <bringert> hmm, you can only make local fixity declarations of variables declared in the same scope
02:17:28 <bringert> annoying
02:17:56 <dcoutts> dons, for my graphs in my gui, I call out to graphviz and then display the result in an ordinary gtk image widget
02:18:07 <dcoutts> dons, you could do the same with gnuplot
02:18:12 <dons> ah! right.
02:18:17 <dcoutts> no need for a seperate gnuplot window
02:18:17 <dons> yes, nice idea.
02:18:38 <dcoutts> http://haskell.org/~duncan/gtk2hs/Constraints%20Viewer.png
02:19:05 <dcoutts> see the graphviz image loaded in the lower right pane?
02:19:15 <dcoutts> it was two lines of code :-)
02:19:52 <dcoutts>                   graphPixbuf <- makeGraphPixbuf (makeGraphFromConstraints cs)
02:19:52 <dcoutts>                   imageSetFromPixbuf image graphPixbuf
02:20:03 <dcoutts> oh, ok makeGraphPixbuf was 4 lines
02:20:37 <dcoutts> writeFile, system, pixbufNewFromFile
02:20:54 <dcoutts> you can use png or svg files
02:21:10 <araujo> dons, haha, goodie
02:21:53 <dons> dcoutts, great! thanks :)
02:21:56 <araujo> dons, haven't you thought about adding a gtk GUI? (i was thinking to do that with my code)
02:22:06 <dons> araujo: http://www.cse.unsw.edu.au/~dons/hmp3.html
02:22:12 <dons> no gtk yet. but wouldn't be hard I reckon
02:22:20 <shapr> dcoutts: That's really cool, considered a gtk2hs snippets post to the gtk2hs blog?
02:22:28 <dons> I'm really much more interested in improving the ease of writing ncurses uis atm.
02:22:56 <shapr> By the way, can I find four TMR authors before the end of the month?
02:23:19 <dcoutts> shapr, the development blog? It's not really development of gtk2hs, but development with gtk2hs. Maybe that's ok too.
02:23:31 <joelr1> howdy
02:23:57 <shapr> hiya joelr1 
02:26:32 <beelsebob_> wtf...
02:26:47 <beelsebob_> why does this throw a parse error at '('? "newtype FilePos = (Int,Int) -- Line, Col"
02:27:02 <dons> dcoutts, this scigraphica stuff looks good. know anything about that?
02:27:16 <araujo> dons, ive always found ncurses annoying myself :-/
02:27:19 <dons> beelsebob_, aren't you missing a constructor for the newtype?
02:27:28 <beelsebob_> bah... duh
02:28:01 <dcoutts> dons, the scigraphica uses gtkplot apparently
02:28:48 <dcoutts> dons, one would have to bind the gtkplot library, though one could use the gtk2hs code generator to get you 80% of the way there.
02:29:54 <dons> ah right. yes, a binding to gtkplot. that was one of the ideas. lots like maybe a good idea.
02:30:03 <dons> s/lots/looks/
02:32:49 <araujo> dons, Setup.lhs: cannot satisfy dependency fps-any
02:32:56 <araujo> I get that
02:33:05 <dons> @where fps
02:33:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
02:33:46 <araujo> Thanks dons 
02:35:47 <araujo> mm.. extremely fast IO...
02:35:56 <araujo> That's something to look at :-]
02:40:52 <bringert> hmm, is this ok:
02:40:54 <bringert> instance MonadPlus m => Monoid (m a) where
02:40:56 <bringert>     mempty = mzero
02:40:58 <bringert>     mappend = mplus
02:41:03 <bringert> if so, why isn't it in the standard libs?
02:50:54 <ski> hm, dunno, overlapping ?
02:51:01 <dons> @pl (\(_,f) -> (f,basenameP f))
02:51:01 <lambdabot> ap (,) basenameP . snd
02:51:07 <dons> hmm.
02:51:12 <ski> (also, i think it's not H98)
02:51:27 <dons> dare I... or will SamB yell at me again
02:51:31 <bringert> ski: yeah it's not haskell 98, but much of the standard libs aren't
02:51:43 <bringert> it does not seem to overlap with anything
02:51:52 <ski> i dunno
02:51:55 <bringert> at least ghc doesn't complin about it being overlapping
02:52:18 <ski> just thought maybe some monad already did a monoid instance (but it should prolly be equiv to this, then)
02:52:43 <dons> @pl map (\(_,f) -> map (\g -> (g,basenameP g)) f) ms
02:52:43 <lambdabot> map (map (ap (,) basenameP) . snd) ms
02:53:01 <bringert> ah, that might be true. maybe something declarared in Control.Monad.Something
02:53:02 <ski> hm
02:53:17 <ski> also, what exactly are the laws that MonadPlus should satisfy ?
02:54:03 <ski> not sure, but maybe this wouldn't always give both units and associativity ?
02:54:24 <bringert> mzero :: m a
02:54:24 <bringert> the identity of mplus. It should also satisfy the equations
02:54:24 <bringert>  mzero >>= f  =  mzero
02:54:24 <bringert>  v >> mzero   =  mzero
02:54:39 <bringert> mempty :: a
02:54:39 <bringert> Identity of mappend
02:54:56 <bringert> mplus :: m a -> m a -> m a
02:54:56 <bringert> an associative operation
02:55:00 <bringert> mappend :: a -> a -> a
02:55:00 <bringert> An associative operation
02:55:36 <ski> http://www.haskell.org/hawiki/MonadPlus
02:55:52 <bringert> lunch...
02:56:08 <dons> @pl \f -> (f,basenameP f))
02:56:08 <lambdabot> (line 1, column 22):
02:56:08 <lambdabot> unexpected ")"
02:56:08 <lambdabot> expecting variable, "(", operator or end of input
02:56:14 <dons> @pl (\f -> (f,basenameP f)))
02:56:15 <lambdabot> (line 1, column 24):
02:56:15 <lambdabot> unexpected ")"
02:56:15 <lambdabot> expecting variable, "(", operator or end of input
02:56:32 <ski> "The precise set of laws that a MonadPlus should satisfy is not agreed upon"
02:56:47 <ski> but
02:56:49 <ski>     *
02:56:49 <ski>       Maybe satisfies Monoid, Left Zero, Right Zero and Left Catch
02:56:49 <ski>     *
02:56:49 <ski>       [] satisfies Monoid, Left Zero, Right Zero and Left Distribution
02:56:49 <ski>     *
02:56:50 <ski>       IO satisfies Monoid, Left Zero and Left Catch
02:57:09 <bringert> the instance  MonadPlus m => Monoid (m a)
02:57:14 <ski> @pl \f -> (f,basenameP f)
02:57:14 <lambdabot> ap (,) basenameP
02:57:17 <bringert> gives you Monoid (Maybe a)
02:57:21 <bringert> ok, lunch
02:57:31 <ski> yes
03:24:15 <dons> @index !
03:24:15 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.
03:24:15 <lambdabot> Map, Data.Array, Text.Html
03:26:49 <ski> fun request (/imperative)
03:26:56 <ski> @index ?
03:26:56 <lambdabot> bzzt
03:29:36 <dons> @index !!
03:29:36 <lambdabot> Data.List, Prelude
03:30:52 <dcoutts> dons, I've tried the gtk2hs code generator on the gtkextra package. It doesn't generate much. :-(
03:30:58 <soysauce> Int is 32-bits, isn't it? Is there a way to get a 64-bit integer? :|
03:31:07 <soysauce> without using Integer, of course
03:31:27 <dcoutts> dons, the gtkextra package is written in too non-standard a style for the script to pickup the structure of the API.
03:31:58 <eivuokko> dcoutts, Hey, how does gtk2hs solve linking windows vs consolo program in Windows?
03:32:31 <dcoutts> eivuokko, http://haskell.org/gtk2hs/archives/2005/06/23/hiding-the-console-on-windows/
03:33:05 <dons> dcoutts, hmm ok. i have time though. i didn't pick it up though: is gtkplot part of gtkextra?
03:33:24 <dcoutts> dons, we use a perl script stolen from the Gtk# people to generate an xml description of the module's api. Then we have a haskell prog which generates code from that. However the perl script is not picking up the structure of most of the code in the gtkextra packae.
03:33:33 <ski> @index Int64
03:33:33 <lambdabot> Data.Int, Foreign
03:33:35 <dcoutts> dons, yes gtkpot is part of gtk+extras
03:34:14 <soysauce> hm
03:34:20 <dons> ok. cool. i'll be willing to do the port, if i have to
03:34:26 <soysauce> ski - do you think it would be faster than using Integer?
03:34:33 <ski> possibly
03:34:33 <eivuokko> dcoutts, So you provide WinMain, okies.  I made a small library that work semiautomatically, thinking whetever there is use for it.
03:34:38 <dons> dcoutts, since i'm getting PAID! :D
03:34:54 <dcoutts> dons, well if you can generate the appropriate xml then the existing gtk2hs code generator will still help.
03:35:04 <dons> excellent.
03:35:14 <dcoutts> dons, you might be able to generate the xml from the documentation
03:35:45 <dcoutts> dons, and if the documentation is in the right format then the gtk2hs code generator will generate haddock markup too.
03:36:18 <dcoutts> dons, gnuplot might be easier.
03:36:47 <dons> ok. 
03:36:54 <dcoutts> eivuokko, no, we don't provide winmain. But linking with the -optl-mwindows option makes it a gui app.
03:37:02 <dons> i'd probably use gnuplot in a buffer, as you describe, to start with
03:37:07 <dons> depends on performance probably
03:37:28 <dcoutts> can gnuplot be used as a daemon I wonder
03:37:38 <dcoutts> it'd save startup time
03:37:44 <dcoutts> if performance is important
03:38:03 <dons> yeah, you could script it.
03:38:09 <dons> over a pipe
03:38:12 <dcoutts> right
03:39:00 <dcoutts> I expect gnuplot is much better tested. The gtk+extra doesn't give me that good an impression.
03:39:13 <eivuokko> dcoutts, I am puzzled.  main is not entry point for windowed application.  Hmmm, gotta check if mingw does some magic, then.
03:39:48 <dcoutts> eivuokko, I dunno. But it works.
03:40:12 <dcoutts> eivuokko, do bear in mind the warning on that FAQ page.
03:40:49 <dons> dcoutts, good point.
03:42:51 <dcoutts> dons, oh, gnuplot does svg output I see.
03:43:02 <eivuokko> dcoutts, Uhm, this is some sort of magic as part of mingw.  I'll investigate why it doesn't work in all cases...  Thanks.  (I know about IO, I am mainly just trying to understand some problems there was with sdl bindings)
03:44:18 <sieni> lambdabot: @pl (\z->(ord z)`mod`39)
03:44:19 <lambdabot> (`mod` 39) . ord
03:45:38 <shapr> wheee
03:46:55 <shapr> oooh, neat! - http://www.soi.city.ac.uk/~ross/traversals/
03:47:01 <shapr> It's a traversals proposal.
03:47:20 <dons> laziness yay!
03:47:26 <dons> traversals, yay yay!
03:47:39 <dons> yeah, and just the day after you mentioned idioms to me
03:47:43 <dons> *now* I get it
03:48:02 <shapr> Yup
03:49:29 <shapr> I still don't completely understand it though.
03:51:18 <sieni> lambdabot: @pl (length x)==(length$nub$zipWith(\y z->(y+z)`mod`(length x))(map((`mod`39).ord)x)[1..])
03:51:19 <lambdabot> length x == length (nub (zipWith (flip flip (length x) . (mod .) . (+)) (
03:51:19 <lambdabot> map ((`mod` 39) . ord) x) [1..]))
03:51:20 <eivuokko> Is there a good reason why ghc puts package-libraries on commandline before haskell and c standard libraries?
03:51:36 <sieni> flip flip <3
03:51:50 <shapr> Probably because package configs can include haskell and C lib parameters.
03:51:55 <sieni> http://www.hurmio.org/~ville/SiteswapValidator2.hs
03:51:59 <shapr> sieni: testicle love!
03:52:10 <eivuokko> shapr, package linker options are put last, I think.
03:52:42 <shapr> Can the order of params matter to gcc or ld?
03:52:46 <eivuokko> Yes.
03:53:25 <sieni> lambdabot: @pl \x -> (length x)==(length$nub$zipWith(\y z->(y+z)`mod`(length x))(map((`mod`39).ord)x)[1..])
03:53:26 <lambdabot> liftM2 (==) length (length . nub . flip (ap (zipWith . flip (flip . (mod .
03:53:26 <lambdabot> ) . (+)) . length) (map ((`mod` 39) . ord))) [1..])
03:53:43 <sieni> liftM2?
03:53:52 <sieni> wtf is that?
03:54:01 <dons> @type Monad.liftM2
03:54:02 <lambdabot> forall r (m :: * -> *) a2 a1.
03:54:02 <lambdabot> (Monad m) =>
03:54:02 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:54:08 <dons> in all its glory
03:54:38 <dons> KNEEL DOWN BEFORE ITS TERRIBLE WRATH!
03:54:46 * shapr neals
03:54:55 <shapr> Would that be neil?
03:54:59 <shapr> anyway...
03:55:34 <dons> you are good, young shapr, but methinks you have a devious nature
03:55:47 <shapr> dons: What's the right replacement for the word thng on http://www.soi.city.ac.uk/~ross/traversals/Data-Traversable.html ?
03:56:01 <shapr> assigning?
03:56:09 <soysauce> shapr - if you were trying to write it phonetically, nils"
03:56:13 <soysauce> "nils", rather
03:56:21 <shapr> soysauce: good point
03:57:32 <soysauce> telia.com? ƒr du svensk?
03:57:48 <shapr> Nej, jag √§r Alabamisk. Jag kommer fr√•n Alabama.
03:58:01 <shapr> Varifr√•n kommer du?
03:58:17 <soysauce> um? Jag kommer frÂn Florida...
03:58:24 <shapr> vad bra :-)
03:58:31 <soysauce> men... varfˆr bor du i Sverige?
03:58:35 <soysauce> hehe ;)
03:58:42 <neologism> thats swedish?
03:58:46 <shapr> Det finns en long saga...
03:58:46 <soysauce> yes
03:58:50 <soysauce> haha
03:59:00 <soysauce> but, wait, aren't you a Swede?
03:59:08 <sieni> lÂng :-)
03:59:13 <shapr> Det borjade med en konversation p√• ICQ, och slutade n√§r jag flyttade till Finland i 1999.
03:59:14 <soysauce> klar
03:59:23 <shapr> sieni: tack
03:59:37 <soysauce> intressant o_O :p
03:59:44 <neologism> sounds like english+german mixed with a lot of vodka
03:59:58 <shapr> soysauce: No, I'm not a Swede. I spent my first 27 years in the USA.
04:00:13 <soysauce> it's more like English simplified with German-like phonology (there is no ch, for example)
04:00:22 <soysauce> shapr - hm, ok, just surprised I guess :p
04:00:41 <neologism> Det finns en long saga...
04:00:44 <neologism> what does this mean?
04:00:48 <shapr> You can find more info on http://www.scannedinavian.com/about.html
04:00:50 <soysauce> "it's a long story"
04:01:01 <neologism> finns != people in finland?
04:01:10 <soysauce> those are finskar :p
04:01:14 <neologism> ah :)
04:01:17 <soysauce> finns is a verb, passive voice or something like that
04:01:19 <shapr> neologism: no, it's "you can find"
04:01:21 <neologism> I thought you are cursing at finns :)
04:01:24 <soysauce> "Det finns" = "There is"
04:01:24 <shapr> "There is found"
04:01:30 <soysauce> yeah
04:01:36 <soysauce> att finna, I suppose it is
04:01:46 <soysauce> but my Swedish is pretty basic.
04:01:49 <shapr> soysauce: So how'd you learn Swedish? Are you a Swede?
04:01:59 <soysauce> nope, same as you; I was actually born in Texas, but grew up in Florida
04:02:21 <shapr> And you learned Swedish because of the large number of Swedes in Texas?
04:02:23 <soysauce> had a roommate who was a half-Swede (mum was 100% svenska, dad was 100% amerikan)
04:02:26 <shapr> ah right
04:02:31 <soysauce> er, no, I lived there until I was 5... :p
04:02:57 <soysauce> so I've picked up a bit of the language from him and people I've met online, but not much
04:03:21 <shapr> I've lived in Sweden for nearly three years.
04:03:26 <neologism> you should try some different language then those germanic ones
04:03:29 <soysauce> cool
04:03:39 <shapr> neologism: xu do tavla mi bau la lojban
04:03:41 <soysauce> neologism - I know Spanish
04:03:47 <neologism> shapr: whats that?
04:03:49 <shapr> neologism: puhutko suomea?
04:03:49 <soysauce> heh and a friend is urging me to pick up Lojban
04:03:57 <soysauce> en puhu suomea :(
04:04:04 <neologism> what language?
04:04:04 <shapr> mi djica lenu do tavla mi bau la lojban
04:04:08 <soysauce> neologism - Lojban
04:04:14 <shapr> One of those was lojban, the other was Finnish.
04:04:20 <neologism> where do they spoke lojban?
04:04:21 <soysauce> "la lojban" is something like "The Logical Language"
04:04:22 <shapr> min√§ haluan hampurilainen!
04:04:24 <soysauce> um, nowhere
04:04:29 <soysauce> there are like 1,500 people who speak Lojban... :p
04:04:30 <neologism> ehm?
04:04:35 <tuomov> shapr: haluat hampurilaisen
04:04:36 <soysauce> nobody speaks it as a native language
04:04:38 <neologism> who speak lojban?
04:04:47 <soysauce> nobody does, it's a conlan
04:04:47 <shapr> Lojban is an artificial constructed language, started by James Cooke Brown in 1956.
04:04:50 <soysauce> conlang, rather
04:05:00 <neologism> sounds awfully ;)
04:05:04 <soysauce> heh, he started Loglan in 1956 :p
04:05:07 <shapr> It started as LogLan, you can see mention of it in Robert Heinlein's "The Moon is a Harsh Mistress" for example.
04:05:07 <tuomov> lojban is rather "unnatural"
04:05:21 <shapr> Part of the point of lojban is to test the Sapir-Whorf hypothesis.
04:05:29 <neologism> what is this hypothesis?
04:05:38 <shapr> That is, "how you speak is how you think" or "the words you can use limit your thinking."
04:05:42 <soysauce> that you're smarter if you speak a more precise language
04:05:44 <sieni> Hmm... should one invest in that: http://www.buyswag.com/mchawking/product.aspx?id=554
04:05:44 <soysauce> or something like that
04:05:52 <shapr> Orwell's Newspeak is one fictional example of that.
04:05:55 <neologism> ah. .Iheard about that
04:06:03 <neologism> about the hypothesis
04:06:08 <soysauce> heh I thought newspeak was real
04:06:09 <neologism> and I actually quite believe that
04:06:23 <soysauce> </sarcasm>
04:06:31 <neologism> for example in my native langauge not(not(x)) != x
04:06:33 <shapr> neologism: C'mon, with a nick like that you should know these things ;-)
04:06:50 <soysauce> neologism - which language is that?
04:06:50 <neologism> which makes native czech quite dumb with bool logic
04:06:58 <soysauce> ah
04:07:00 <shapr> Nifty
04:07:03 <soysauce> Czech would be interesting
04:07:08 <shapr> Yeah, I agree.
04:07:09 <neologism> for example to say "I dont do anything"
04:07:10 * soysauce attempted once to learn Russian but failed
04:07:19 <neologism> we say "ja nedelam nic" -> "I dont do nothing"
04:07:22 <soysauce> everybody wants to teach the alphabet. That's the easy part.
04:07:23 <shapr> I like to learn languages, spoken or programming. It's all just means of expression.
04:07:48 <neologism> czech is flexive language
04:07:50 <soysauce> neologism - but that's essentially the same as English "I don't do anything" / "I do nothing", isn't it?
04:07:54 <neologism> which makes it quite hard for english speakers
04:08:07 <neologism> soysauce: yes.. but english follows bools logic, czech doesnt
04:08:11 <soysauce> well Spanish does the same thing
04:08:14 <tuomov> in Finnish "mit√§√§n" can mean both "nothing" and "anything" so it's not clear if there's double negation in "en tee mit√§√§n"/"I don't do anything/nothing"
04:08:15 <shapr> tuomov: Hey, did you see that you were the subject of a recent addition to @wiki QuotesPage ?
04:08:24 <tuomov> shapr: no..
04:08:28 <shapr> Finnish is seriously nifty.
04:08:30 <soysauce> "no hago nada" = literally "I don't do nothing"
04:08:52 <neologism> finnish is surprisingly similar to czch I found
04:09:00 <shapr> tiedostoj√§rjestelmill√§
04:09:01 <shapr> mmm
04:09:05 * shapr grins
04:09:13 <samc> historically double negatives weren't considered poor english
04:09:16 <gour> sanskrit is mother of all languages
04:09:18 <soysauce> English would be the same except for the way that class distinctions came to influence the language and its unique relationship to the U.S.
04:09:19 <samc> as negatives
04:09:34 <soysauce> I thought P.I.E. was the mother of all languages. ;-)
04:09:39 <shapr> sieni: opitko Haskellia?
04:09:51 <dcoutts> gour, we've got a problem with tailor and utf8
04:09:54 <neologism> samc: czech is the most similar langauge to sanskirt
04:09:55 <gour> and people working with languages say it is so precise it could be a programming language
04:10:09 <neologism> s/samc/gour
04:10:09 <soysauce> neologism - huh? Czech is Slavic, Sanskrit is something else
04:10:17 <dcoutts> gour, have you seen the gtk2hs darcs mirror cron job output from the last 2 days?
04:10:19 <neologism> but all are indoeropean
04:10:26 <neologism> if I am drunk I can read sanskirt ;)
04:10:36 <soysauce> heh I don't see how
04:10:40 <gour> dcoutts: i saw, already had such problems with lyx repo
04:10:42 <neologism> its really very similar at words level
04:10:54 <dcoutts> gour, it's because I added the name of a contributor which was not ascii
04:10:56 <soysauce> so are English, Swedish, and German
04:10:59 <shapr> Finnish is off in its own little world, with Estonian being its only distant neighbor.
04:11:00 <soysauce> and I can't read shit
04:11:00 <gour> croatian too
04:11:15 <neologism> soysauce: there's a lot of similar words between sanskirt and czech
04:11:17 <tuomov> no, estonian is a close neighbour. hungarian is a distant neighbour
04:11:22 <soysauce> shapr - there is also Hungarian which is not too far away
04:11:23 <shapr> I can read lots of languages when inebriated, I've always wondered about that.
04:11:24 <gour> dcoutts: maybe we should switch to darcs only?
04:11:32 <dcoutts> gour, it's converting ascii to unicode but it shouldn't be doing that since it's utf8 only
04:11:35 <shapr> tuomov: thanks :-)
04:11:37 <dcoutts> gour, the problem is not cvs
04:11:42 <dcoutts> gour, the problem is tailor
04:11:53 <gour> dcoutts: :-)
04:11:57 <neologism> there's a lot of ugro-finnish languages
04:12:06 <neologism> but all of them are extintcing ;(
04:12:06 <shapr> I thought there were only those?
04:12:07 <dcoutts> gour, it says: UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 115: ordinal not in range(128)
04:12:09 <shapr> oh
04:12:15 <neologism> shapr: small communities
04:12:17 <tuomov> neologism: finnish, estonian, hungarian and then some almost extinct minority languages in russia
04:12:17 <shapr> Where do the Sami languages fit in?
04:12:20 <neologism> "samoyeds" etc.
04:12:32 <neologism> tuomov: yes.. small communities in russa
04:12:33 <gour> dcoutts: i'll be back in a 20min
04:12:33 <neologism> tuomov: yes.. small communities in russia
04:12:37 <dcoutts> gour, we need it to not use the ascii encoding codec since it's not ascii, it's utif8
04:12:38 <shapr> dcoutts: I know how to fix that.
04:12:42 <dcoutts> gour, ok np
04:12:43 <gour> docutts: you can try #tailor
04:12:46 <neologism> sami is a close to finnish
04:12:47 <dcoutts> shapr, you do?
04:12:58 <shapr> Sure, I spend my life fixing encoding problems like that in Plone.
04:13:03 <dcoutts> shapr, hah, poor you.
04:13:12 <tuomov> hmm.. sami is actually classified as finno-ugric
04:13:13 <shapr> Python is my day job. Tailor is written in Python.
04:13:24 <dcoutts> shapr, yep.
04:13:39 <shapr> As depressing as it sounds, I know lots more about Python than I do about Haskell.
04:13:40 <neologism> tuomov: ask some native finn :)
04:13:50 <tuomov> tuomov: I am :)
04:13:55 * shapr grins
04:13:55 <dcoutts> so tailor is getting the changeset and trying to decode it from ascii
04:13:59 <shapr> Right
04:14:06 <neologism> tuomov: I read that sami is very close to finnish
04:14:13 <neologism> like say english and german
04:14:16 <neologism> or somthing like that
04:14:21 <tuomov> estonian is closer, I think
04:14:26 <shapr> I learned finnish for three years, I don't think sami is close at all.
04:14:34 <tuomov> http://en.wikipedia.org/wiki/Uralic_languages
04:14:51 <neologism> tuomov: wasnt finnish made from estonian some years ago?
04:14:56 <neologism> s/made/reconstructed
04:15:02 <tuomov> err..?
04:15:03 <shapr> My problem with Finnish was the combinatorial explosion you get when combining cases.
04:15:05 <dcoutts> we need to tell it to not be so strict about ascii, or perhaps to use utf8
04:15:36 <neologism> tuomov: I think that finnish was reconstruced as a language about 100 yrs ago
04:15:42 <tuomov> finnish and estonian diverged sometime in the past because different major powers conquered the lands and so on
04:16:40 <tuomov> neologism: but I don't know at all what you're talking about..
04:17:04 <neologism> w8 I am googling ;)
04:17:16 <tuomov> written Finnish was created in the 1500s, when Finland was under Swedish rule
04:17:30 <tuomov> written Estonian is much more recent, IIRC
04:17:58 <neologism> I read somewhere that finnish was created from "ancient" sources in... not thatlong ago
04:18:12 <neologism> and it was partly rewritten from esti
04:18:54 <tuomov> total BS
04:19:16 <neologism> finland was ruled by russians/swedens
04:19:59 <neologism> http://en.wikipedia.org/wiki/Finland's_language_strife
04:20:47 <neologism> this says it quite clearly
04:20:56 <eivuokko> Huh?
04:21:05 <shapr> I have *way* too many files named thesis.ps
04:21:23 <eivuokko> heh
04:22:19 <eivuokko> neologism, exactly what does that page say clearly?
04:22:27 <tuomov> yes, the ruling class spoke swedish under swedish rule and much of it long into the russian rule as well, but the people spoke finnish
04:22:33 <neologism> national awaking
04:22:34 <tuomov> obviously
04:22:45 <neologism> you know better then me
04:23:06 <neologism> but I just read that finnish was "recreated" from ancient sources
04:23:15 <neologism> which makes it sound very old now
04:23:25 <neologism> the same happened here in .cz and in .sk
04:23:29 <neologism> (for the same reasons)
04:23:33 <tuomov> uh?
04:23:35 <eivuokko> Yeah, but it says nothing about finnish being constructed or anything.  In fact, finnish was allowed and widely used in all classes, even ruling, of natives.
04:24:20 <neologism> if only I found the article
04:24:51 <tuomov> you've probably just misunderstood something
04:25:15 <neologism> or maybe the article just lied :)
04:25:18 <tuomov> maybe you just read about research on the development of languages, and how languages trace their roots back to older languages?
04:25:26 <eivuokko> Yeah, it would be major rewrite of history
04:25:35 <eivuokko> (major from finnish pov) ;)
04:26:12 <neologism> I clearly remember that the article talked about finnish being an ancient ugro-finnic language
04:26:19 <eivuokko> Yeah.
04:26:20 <neologism> becuase it was constructed from historical roots
04:27:34 * eivuokko is confused
04:28:00 <tuomov> so they recently traced how modern finnish developed for historial roots, thus "reconstructing" it?
04:28:07 <mrb`> Could someone do me a huge favor and tell me how to enable depth testing for HOpenGL? I am doing `depthFunc $= Just Never' (or Less, or whatever) but that doesn't seem to do it
04:28:13 <tuomov> s/for/from/
04:28:37 <neologism> tuomov: no... I read that noone used finnish so they had to recreate it. and did so using ancient sources -> thats why contemporary finnish is so ancient
04:28:38 <shapr> mrb`: I think the spinning cube example does that?
04:28:51 <tuomov> that's total bullshit
04:29:01 <neologism> I dont know.. I just read that
04:29:23 <mrb`> shapr: where is that example?
04:30:23 <tuomov> almost nobody spokes the written "book language", but different dialects that differ more or less from it. maybe that's what you mena?
04:30:44 <neologism> maybe it talked about formal finnish
04:30:45 <tuomov> but even the "book language" dates back to the 16th century
04:30:46 <samc> obviously the finnish were then all brainwashed with a false history
04:30:50 <neologism> which had to be created somehow
04:31:02 <neologism> and they created it using ancient sources
04:31:12 <neologism> thus making contemporary finnish very ancient
04:31:52 <shapr> mrb`: http://www.scannedinavian.org/~shae/Cube.hs.gz
04:32:03 <mrb`> cool. Thanks.
04:32:04 <tuomov> I'm confused about your confusion.
04:32:06 <shapr> mrb`: That's code by Igloo, from the ghc6-hopengl debian package.
04:32:34 <neologism> tuomov: when was formal finnish consituted?
04:32:50 <shapr> There's a beautiful sunset outside. Too bad it's 13:32 right now.
04:32:50 <tuomov> by formal you mean the "book language"?
04:32:56 <neologism> yes
04:33:05 <tuomov> 16th century as I mentioned above already
04:33:17 <tuomov> by Mikael Agricola (http://en.wikipedia.org/wiki/Mikael_Agricola)
04:33:42 <neologism> hm...
04:33:44 <neologism> forget it ;)
04:33:51 <tuomov> modern written Finnish does differ somewhat from this construction, though, but the change has been evolutionary and not a rewrite
04:35:08 <mrb`> My OpenGL code was fine, but I wasn't enabling depth buffering in GLUT... awesome. OK, I'm off to hopefully get something done. Thanks.
04:36:02 <gour> dcoutts: shall i report the issue to lelit (again) ?
04:36:17 <neologism> tuomov: you were ruled by sweden then by russia, right?
04:36:50 <tuomov> yes
04:37:03 <shitlog> more like traded back and forth
04:37:07 <neologism> so formed official language during occupation?
04:37:09 <tic|school> woo sweden! :)
04:37:17 <tuomov> yep
04:37:22 <neologism> wow..
04:38:02 <dcoutts> gour, oh, again?
04:38:11 <tuomov> although, I think swedish stayed the official language during russian occupation because finland did have some autonomy, and the ruling class was of swedish descent
04:38:24 <gour> dcoutts: i had the same issue when trying to pull from lyx-devel repo
04:38:34 <tuomov> mostly
04:38:46 <dcoutts> gour, lets talk about it in #tailor
04:39:27 <neologism> tuomov: anyway - would be interesting to hear some lingiustic opinion wheter finnish is ancient among ugro-finnic languages
04:41:01 <tuomov> well, I've read that Finnish is closer to the roots than Estonian, where many words and conjucations have been contracted
04:41:18 <neologism> might be
04:41:20 <neologism> I am no expert
04:41:58 <tuomov> Estonian also has been "corrupted" more by constructions typical of analytical rather than synthetic languages
04:42:21 <neologism> yes
04:42:24 <neologism> read that on wiki
04:42:31 <tuomov> (analytical=~prepositions etc., synthetic=~conjucations)
04:43:23 <tuomov> or whatever the right word is in which case... My dictionary says conjugation only applies to verbs
04:43:37 <neologism> you talk syntax or morfology?
04:43:55 <tuomov> what's morphology?
04:44:08 <neologism> how you construct words
04:44:20 <tuomov> and how does that differ from syntax?
04:44:27 <neologism> english is isolatie lanaguage
04:44:31 <neologism> finnish is agglutinative
04:44:40 <neologism> in english when female did somethin in past
04:44:45 <neologism> bad example ;)
04:44:57 <neologism> you "glue" words together in finnish, right?
04:45:15 <tuomov> words and endings
04:45:16 <neologism> thats what it makes agglutnative (aglue -> to glue in latin or something)
04:47:07 <tuomov> e.g. ty√∂p√∂yd√§ll√§k√∂? = On the work table (=desk)? ty√∂=work, p√∂yt√§=table, ll√§=on, k√∂=question
04:47:24 <araujo> There exist a function to find a sequence of elements in a list?
04:47:26 <neologism> I canont read 85% of the letters you wrote ;)
04:47:34 <eivuokko> I am gonna give up soon and start changing ghc against release or stable branch, cvs head is so badly broken :-S
04:48:08 <araujo> Something like: find "bar" "helleWbarW" => True 
04:48:30 <araujo> I know how to do it, i just want to kn ow if there exist something in the prelude,
04:48:45 <tuomov> neologism: tyopoydallako, with dots over all the a's and o's
04:48:52 <SamB> eivuokko: yeah, one wonders how HEAD got so broken and how they are going to fix it...
04:49:02 <neologism> tuomov: yes. thats agglutinative languages
04:49:05 * shapr finds a reference to Douglas Adams in a research paper.
04:49:05 <neologism> but I have to go:)
04:49:08 <neologism> see ya later
04:49:11 <tuomov> (and no, you can't write finnish with ae, oe; it's better to drop the dots)
04:49:47 <eivuokko> SamB, And for one and half day I thought it was just Windows and just me building it ;)
04:50:42 <SamB> eivuokko: how do you switch to another branch, anyway?
04:51:01 <eivuokko> SamB, cvs update to a branch-tag.
04:51:17 <eivuokko> I don't recall exact parameters right now ;)
04:54:56 <jlouis> What is a cool Haskell paper I ought to read?
04:58:55 <samc> It seems there are no cool Haskell papers one ought to read
05:00:24 <jlouis> not yet, at least
05:04:59 <tromp> good afternoon, folks
05:05:56 <tromp> i just solved 9x6 connect-4; it's a 2nd player win:)
05:07:47 <boegel> tromp: congrats ! (altough I don't know what you're talking about) 
05:07:51 <samc> how big is the standard grid?
05:24:03 <shapr> samc: 19x19 I think.
05:24:08 <shapr> er, wait, that's Go
05:24:26 <shapr> jlouis: I can give you a very long list of cool Haskell papers to read.
05:24:42 <araujo> Who plays Go here?
05:24:58 <shapr> @wiki HaskellGoPeople
05:24:59 <lambdabot> http://www.haskell.org/hawiki/HaskellGoPeople
05:25:10 <araujo> Oh!
05:25:17 <araujo> Nice, another list to add myself
05:26:33 <tromp> connect-4 is 7x6 normally
05:27:32 <tromp> see http://www.cwi.nl/~tromp/c4/c4.html for a table and source code
05:27:37 <shapr> jlouis: "Non-stop Haskell" "Haskell on a shared memory multiprocessor",  Erwig's Inductive Graphs work, The Web by Hinze, The Zipper by Huet, Scrap Your Boilerplate 1, 2, and 3. 
05:27:49 <bringert> how do you use operators with qualified names?
05:27:56 <shapr> (Module.***)
05:28:13 <bringert> ah, too easy
05:28:15 <bringert> Set.\\
05:28:28 <bringert> I was trying stuff like `Set.(\\)`
05:28:46 <shapr> I couldn't figure it out either, someone else told me.
05:29:14 <shapr> jlouis: You could read the Pure Haskell WiFi sources for the Gnu Universal Software Radio Peripheral.
05:29:23 <araujo> shapr, Don't you know a function to find if a sequence of elements exist in a list?
05:29:53 <mauke> @hoogle [a] -> [a] -> Bool
05:29:54 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
05:29:54 <lambdabot> Data.List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
05:29:54 <lambdabot> Graphics.UI.ObjectIO.CommonDef.disjointLists :: Eq x => [x] -> [x] ->
05:29:54 <lambdabot> Bool
05:30:10 <shapr> I have 346 megabytes of Haskell research papers and source code in my ~/download/programming/languages/haskell directory.
05:30:34 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051115"]' by CosmicRay
05:30:43 <shapr> Everything is gzip'd of course.
05:30:44 <CosmicRay> that would be the notice that the latest hwn is finally out ;-)
05:30:49 <shapr> yay!
05:31:07 <bringert> araujo: you want a subsetOf function?
05:31:22 <bringert> or isSubsetOf would be a better name
05:31:35 <shapr> CosmicRay: Good excuse!
05:31:41 <CosmicRay> shapr: thanks ;-)
05:32:15 <bringert> \xs ys -> isSubsefOf (Data.Set.fromList xs) (Data.Set.fromList ys)
05:32:35 <boegel> CosmicRay: w00 !
05:32:36 <bringert> which can be made more cryptic with arrow combinators and uncurry
05:32:38 <danY2K> > [1..10]
05:32:39 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
05:32:53 * boegel waits until HWN drops in his mailbox...
05:32:58 <boegel> danY2K: new to Haskell ? :)
05:33:04 * bringert too
05:33:06 <araujo> bringert, I think isSuffixOf will make it.
05:33:15 <araujo> bringert, But what exatly do you talk about?
05:33:39 <shapr> After looking at the bell curve of birth years in John Hughes' survey, I feel old.
05:33:45 <CosmicRay> heh
05:33:47 <bringert> araujo: I thought you wanted a function to check if all members of the first list are also members of the second one
05:33:51 <shapr> CosmicRay: Oh hey, I got SPJ to record how he says "Haskell" for the next TMR issue :-)
05:34:02 <CosmicRay> shapr: cool!
05:34:03 <danY2K> boegel, sry, just showed one of my friends the awesome features of lambdabot
05:34:10 <shapr> Sadly, he didn't say "My name is Simon Peyton-Jones and I say Haskell Haskell."
05:34:10 <araujo> bringert, aah ok, well, but preserving the order
05:34:11 <boegel> shapr: 'how he says' ?
05:34:14 <bringert> i.e. whether the elements of the first are a subset of the first
05:34:19 <boegel> danY2K: oh cool, continue !
05:34:23 <araujo> isSuffixOf makes it
05:34:26 <bringert> ok, so you are looking for a subsequence?
05:34:28 <bringert> ok
05:34:30 <shapr> boegel: Yeah, he recorded it with sound recorder, that's why I was asking.
05:34:34 <araujo> Yeah.
05:34:35 <CosmicRay> shapr: heh
05:34:39 <boegel> shapr: what's the use of that ? :)
05:34:49 <danY2K> boegel, ;-) yop
05:34:49 <shapr> boegel: I've been saying it wrong for YEARS!
05:34:58 <boegel> shapr: you have ? :s
05:35:04 <shapr> Yes! It's a tradegy!
05:35:08 <boegel> I don't see how you can pronounce it wrong :)
05:35:18 <shapr> Here, I'll upload the file to scannedinavian...
05:35:23 <boegel> can you let us hear it ? 
05:35:25 <boegel> oh cool :)
05:36:18 <shapr> http://www.scannedinavian.org/~shae/spj-haskell.wav
05:36:43 <Lemmih> heh
05:37:11 <Lemmih> shapr: How did you pronounce it?
05:38:01 <goron> Is it possible to write a Haskell program (via a hell of a lot unsafe operations), that rewrites itself *completely*?
05:38:13 <shapr> Lemmih: http://www.scannedinavian.org/~shae/shapr-haskell.wav
05:38:35 <mauke> @pl \x -> do {return x}
05:38:35 <lambdabot> (line 1, column 10):
05:38:35 <lambdabot> unexpected "{"
05:38:35 <lambdabot> expecting variable, "(", operator or end of input
05:38:37 <shapr> goron: Look at Pseudonym's 0th IOHCC entry.
05:39:55 <beelsebob_> shapr: you're just plain wrong
05:39:58 <beelsebob_> :P
05:40:00 <shapr> beelsebob_: no kidding :-P
05:40:00 <mauke> @pl \op next -> next >>= \x -> op >>= \f -> next >>= \y -> return (f x y)
05:40:00 <lambdabot> ap (>>=) . (. ((. (((return .) .) . flip id)) . (.) . (>>=))) . (.) . (>>=
05:40:00 <lambdabot> )
05:40:07 <goron> http://iohc.mgoetze.net/Pseudonym.hs?
05:40:21 <boegel> shapr: funny :) I would've though your voice was way deeper :)
05:40:33 <shapr> goron: Yup, also archived on http://www.scannedinavian.org/iohcc
05:40:47 <shapr> boegel: Yeah, lotsa people tell me that.
05:42:06 <goron> shapr: It's kinda hard to read ;)
05:42:29 <shapr> Play the game. Put an x or an o in the right place.
05:42:32 <shapr> Then run the program.
05:43:10 <boegel> CosmicRay: heh, nice excuse :) I'm (trying to) read(ing) the whole trilogy now
05:43:28 * goron crosses fingers
05:43:40 <ski> goron : 'rewrites' here means ?
05:43:40 <shapr> The last two IOHCC contests were filled with delightful surprises. I learned a *lot* about Haskell.
05:43:56 <shapr> Maybe I should run another one?
05:44:16 <shapr> I think I'd rather run a scrapheap challenge.
05:44:32 <shapr> But we really gotta get cabal-{get,put} working before that'll be successful.
05:44:57 <shapr> I always wonder, why don't more people organize fun events like this?
05:45:51 <goron> ski: I mean that a program can overwrite its own source code, and then execute that. (like is possible in  assembler).
05:45:59 <boegel> shapr: because they don't have time :)
05:47:05 <ski> goron : you mean it overwrites the source code and then invokes the compiler on that, executing the result then ?
05:47:20 <shapr> goron: Maybe you want Template Haskell?
05:47:33 * ski hasn't written assembler which overwrites the source and calls the assembler
05:47:36 <shapr> boegel: Well, I don't have time either... but I spend my fun time doing this sort of thing.
05:48:09 * ski though *has* written assember programs, which, when assembled and run, will rewrite the machine code of itself ..
05:48:11 <Philippa_> goron: it's possible if you know exactly which compiler you're working with, which platform you'll be working on, and know the RTS intimately
05:48:39 <Philippa_> you'll need the last part because your program's about to know it carnally ;-)
05:48:47 <ski> (no drastic rewrite, mind, though)
05:49:32 <goron> ski: No, I don't mean that, because that's very slow. But that's a simple solution. 
05:51:41 <ski> goron : for what reason should it rewrite itself ?
05:51:42 <boegel> shapr: and that's what makes you so cool ! :)
05:51:47 <boegel> y0w xerox
05:52:06 <xerox> Hey there!
05:52:22 <goron> ski: Because that might be provably better. 
05:54:58 <shapr> boegel: heh, thanks
05:55:15 <ski> goron : provably ?
05:55:27 <ski> goron : are you thinking of things like RTCG ?
05:56:10 <goron> ski: Runtime Code Generation? That's a part of it, yes. 
05:56:35 <ski> like e.g. unrolling a loop you know the size of
05:57:11 <ski> or, given config parameters, constructing specialized code that doesn't interpret it over and over again (e.g. printf or device drivers, iirc)
05:57:25 <goron> ski: well, that could be. But I am not going into that much detail.
05:58:08 <ski> if you're sayinG "rewrite" that implies taking some code and looking through it and generating new code
05:58:11 <goron> ski: It's more of a theoretical idea that I'd like to see in practice. 
05:58:20 <goron> ski: that's true. 
05:58:43 <goron> ski: But *I* don't need to figure out what code to generate.
05:58:45 <ski> do the code to be analyzed have to be compiled ? or could it be represented more abstractly ?
05:58:58 <shapr> What about lisp macros?
05:59:04 <ski> goron : why not ?
05:59:17 <goron> ski: since that's part of the model. 
05:59:29 <ski> what is the model ?
06:00:08 <goron> I'd rather first try to implement something, and then have something to show before I go into details. 
06:00:15 <ski> (macros are compile-time (or more specifically, macro-expand-time) .. which, thanks to eval and compile, can be interleaved with run-time)
06:00:26 <ski> heh, ok
06:00:42 <goron> ski: I know, but if I understand correctly, it's not possible to rewrite the complete runtime. 
06:00:43 <shapr> It's fun to browse http://www.haskell.org/hawiki/HaskellIrcPastePage , it's sort of like the code-specific stream-of-consciousness RSS feed for the #haskell community.
06:01:19 <goron> shapr: you mean all the previous versions.
06:01:22 <ski> (goron : no, i was just inquiring about some small part of the code at run-time .. not the whole run-time system)
06:01:30 <shapr> goron: That too.
06:02:13 <goron> ski: to implement it really correctly, that would be needed. 
06:02:30 <goron> ski: I could also use Java dynamic class loading, but then I would have the same problem.
06:03:05 <goron> ski: I.e. it could be possible that for whatever reason it's a suboptimal class loader. 
06:08:09 <xinming> what does succ and pred short for?
06:08:14 <xinming> s/does/is/
06:08:30 <mauke> successor, predecessor
06:11:10 <shapr> goron: What about hs-plugins?
06:11:58 <xinming> mauke: thanks
06:15:21 <goron> shapr: same problem, even hs-plugins has some code that can't be changed.
06:15:46 <goron> shapr: but maybe it's all to difficult to do it the Right Way. 
06:16:38 <goron> shapr: In that case hs-plugins is probably the way to go, although maybe the license it a bit bad. 
06:16:48 <goron> @license hs-plugins
06:16:49 <lambdabot> Unknown command, try @listcommands.
06:17:05 <goron> Someone implement that ;)
06:19:02 <eivuokko> LGPL iirc.
06:21:06 <goron> LoadType is GPL, so it's a bit complex legally seen...
06:22:51 <ski> goron : why is it a problem that some code can't be changed ?
06:24:49 <goron> ski: It could be suboptimal, while the point is to be optimal(sure this takes long, but to say it's impossible right from the start is restricting the program). 
06:26:41 <shapr> goron: Have you read the hs-plugins paper? The only static part is the boot loader.
06:26:54 <goron> shapr: I have. 
06:26:57 <shapr> ok
06:27:58 <shapr> Is hs-plugins GPL?
06:28:21 <goron> shapr: No LGPL, but according to Debian someparts are GPL. 
06:28:26 <goron> er some parts
06:28:29 <shapr> What's bad about that license?
06:29:06 <goron> shapr: Nothing wrong with LGPL.
06:29:32 <shapr> Would you prefer GPL or BSD?
06:30:13 <goron> Everybody prefers BSD new style (since it's compatible with GPL).
06:30:24 <xerox> Is it BSD3 ?
06:30:56 <Igloo> Not everyone prefers BSD over GPL, if that's what you mean
06:31:10 <goron> Igloo: for using a library people do.
06:31:22 <shapr> I prefer GPL myself.
06:31:33 <goron> Igloo: ofcourse if you wrote something, then you probably think different.
06:31:35 <xerox> shapr, why so?
06:31:50 <shapr> But I tend to stick to BSD3 for my Haskell code, because that follows the GHC example.
06:32:53 <goron> shapr: I ran the program, but isn't that just a lot of effort, instead of a run-time rewrite?
06:35:07 <shapr> xerox: Because I've been screwed over by too many employers not releasing my code after I stopped working there. Because of TransGaming using Wine for the commercial WineX and not contributing back their improvements. Because I don't mind companies using my code, as long as they let me use their code too.
06:36:47 <eivuokko> Hmmm.
06:37:02 <goron> shapr: what about LGPL?
06:39:10 <shapr> In general, I feel that companies should write their own libraries if they want to make money off of closed source.
06:39:40 <goron> shapr: but only large companies can afford that.
06:39:58 <Philippa_> right. That's why I find the GPL and near relatives damaging in a number of circumstances
06:40:10 <shapr> Most libraries in debian were written by a very small number of people, so I disagree with that.
06:40:24 <eivuokko> I hate the practical implication of GPL to do integration and project jobs, which are stressing.
06:40:27 <Philippa_> (I really resent smartarses talking about how GPLing their game engine is "giving something back to the community" rather than for the most part just going "nyah-nyah, can't do anything serious with this")
06:40:33 <shapr> Of course, I should produce some numbers to back that up, and I don't have any right now :-)
06:40:34 <goron> shapr: if you want to sell something really big, then you have to be a large company, since GPL'ing it gives you the total number of ONE customers... 
06:40:51 <Philippa_> (Carmack is a biiiig exception there, because there's always an existing, large content base when the GPLing happens)
06:41:15 <shapr> But, I don't want to sell anything. I want to spread the ability for people to do things for themselves. Closed source is the opposite of that.
06:41:17 <Philippa_> shapr: real projects need multiple libraries
06:41:37 <Philippa_> also, the open source libraries tend to be written by a small group of people who nevertheless really *really* care about what they're doing
06:41:48 <Philippa_> as companies get bigger, they're less able to reliably use people like that
06:42:13 <Philippa_> I want to eat. I also like games with high-quality content - content which costs silly money to create
06:42:20 <shapr> I don't think that software as a product works as well as software as a service.
06:42:35 <Philippa_> I'm in two minds about that, but I can go with it within reason
06:42:37 <goron> shapr: How do you see games to be a service?
06:42:46 <Philippa_> goron: subscription model
06:42:46 <shapr> Well, content isn't code.
06:43:07 <Philippa_> no. But in practice it's very very hard to use GPL code and commercial content together
06:43:24 <Philippa_> IIRC the last time I had this argument we worked out it was pretty much impossible on the consoles
06:43:42 <goron> Philippa_: people could also setup their own servers. I think shapr's point is better here,.
06:44:05 <shapr> I can't count the number of times I've found abandonware that I desperately wish were open source.
06:44:17 <Philippa_> goron: servers are one thing, models and levels and music and so forth are another
06:44:18 <shapr> I'd be fine with closed source that worked like IdGames.
06:44:34 <shapr> But the problem is that source code copyrights don't really expire if the source code is never released.
06:44:40 <Philippa_> shapr: agreed, the situation there's often rather sad. I'm all for GPLing at the end of commercial life
06:44:53 <goron> Philippa_: or public domain...
06:44:56 <eivuokko> Well, problem with that is that not all source is so cyclic like game engines.
06:45:22 <Philippa_> goron: I was in the Doom community back when the code for GLDoom was lost. I've seen the arguments
06:45:37 <shapr> eivuokko: I know, but there's no point in my previous J2EE-centered employer hanging onto my jython sources, either.
06:45:39 <Philippa_> GPL works for that because the point isn't creating new commercial games
06:46:21 <shapr> The IdGames approach follows the original spirit of the US patent system.
06:46:41 <shapr> You get encouragement to develop something new, because everyone will be able to benefit from it after a few years.
06:46:53 <dcoutts> shapr, exactly
06:47:03 * Philippa_ nods
06:47:13 <Philippa_> what really doesn't work is being GPL-encumbered at launch
06:47:42 <Philippa_> anyway, I gotta go
06:47:46 <shapr> But closed source is like trade secrets, it's unlikely the source will ever escape the company, and if the company goes bankrupt, the source will likely never be released.
06:48:10 <eivuokko> Where I work, our clients are banks and brokerages.  I possibly can't see how GPLing code woudl ever work for us.
06:48:22 <Philippa_> tbh, I'm not sure anyone cares about the source to Final Fantasy X. They'll just use a PS2 emulator
06:48:43 <shapr> eivuokko: If your users found a bunch of security bugs, it would benefit you.
06:48:48 <eivuokko> shapr, Heh, interesting point, is GPLing source before backrupt counted as intentionally lost capital?
06:48:54 <dcoutts> everyone's seen/listened to Lawrence Lessig's "free culture" presentation?
06:48:55 <eivuokko> shapr, Ehm?  Security?
06:48:56 <dcoutts> http://lessig.org/freeculture/free.html
06:49:01 <dcoutts> if not, they should
06:49:04 <dcoutts> it's excelent
06:49:04 <eivuokko> shapr, This stuff always runs over private lines.
06:49:16 <jlouis> shapr: thanks for the suggestion
06:51:07 <dcoutts> The massive coppyright extension makes me quite annoied. A couple years ago my drama group put on a play by a dead and forgotten playright. The thing was written in 1910 but the thing was still in copyright!!!
06:51:28 <shapr> eivuokko: Most investors or creditors would consider source code rights assets, even if no one knows how to make any money off of them.
06:51:35 <eivuokko> shapr, Yeah.
06:51:36 <shapr> dcoutts: Me too.
06:51:47 <dcoutts> we contacted the publisher which didn't even know they owned the copyright. That's how often this thing had been performed.
06:52:01 <dcoutts> and then they wanted royalites. From a charity drama group.
06:52:08 <dcoutts> it's outrageous.
06:52:09 <shapr> That's another problem.. source code copyright should always be traceable, or should be removed.
06:52:28 <goron> dcoutts: Couldn't you say:"Do you know XYZ? No? Ok, bye!".
06:52:36 <shapr> There's a new patent law that's been suggested... "if you don't enforce your patent, after a year or so it disappears."
06:52:37 <eivuokko> Removed copyright doesn't change legal standing of copyright holder or license in all countires.
06:52:42 <shapr> I think the same should happen to copyright law.
06:53:01 <dcoutts> goron, we needed copyright permission from the publisher to be able to convince the library to let us make a photocopy.
06:53:22 <gour> dcoutts: that's why i write & direct my own plays :-)
06:53:26 <eivuokko> Again, that kicks small companies that don't have means to look out for patent infringements.
06:53:37 <eivuokko> And patens would be even more a tool for big companies.
06:53:41 <shapr> Of course, I think laws should have a similar expiration date. If no one enforces the law, why is it there? Other than as a trap for the unwary...
06:53:48 <dcoutts> gour, yeah. We do that too now. It's easier than fighting with libraries and publishers
06:53:49 <flux__> shapr, I've been thinking that dramatically shorter patent periods for certain stuff would be nice, but I suppose that could be an alternative
06:54:23 <dcoutts> but it's a great shame because we're loosing our cultural heritage to corperate copyright theves.
06:54:38 <flux__> shapr, each law should have a rationale attached to it..
06:54:57 <shapr> eivuokko: If patent enforcement only requires publically stating it on your website and doing the occasional google search, it wouldn't be so bad.
06:55:09 <goron> My brother has "invented" something that will probably be patented, but he doesn't know *what* is so great about his invention. He basically designed something. I.e. in the gigantic design space he put a point in some suboptimal location. I think that's nonsense. 
06:55:11 <dcoutts> flux__, the rationale for modern copyright law is to print money for certain corperations.
06:55:25 <flux__> dcoutts, yes, but I mean for each clause in the law, there should be rationale
06:55:31 <dcoutts> flux__, I agree.
06:55:36 <flux__> explanation why the that clause says what it says :)
06:55:45 <flux__> it could then be referred to if there are inclarities
06:55:50 <flux__> (and when)
06:56:06 <dcoutts> flux__, "This clause is here because the Disney corperation paid for it to be here."
06:56:08 <flux__> there must be some applications of law that don't follow the original idea behind the law
06:56:16 <goron> It's also pretty odd that mathematics can't be patented, while it's very less trivial. 
06:56:23 <shapr> Math can be patented.
06:56:32 <dcoutts> Maths is often patented.
06:57:00 <dcoutts> eg, encryption, compression
06:57:03 <shapr> xor
06:57:06 * shapr snickers
06:57:31 <shapr> Yes, there really is a patent for XOR somewhere, though I forget the details.
06:57:32 <goron> I am pretty sure there was some rule in my country that said that. 
06:57:54 <shapr> Can a mathematical proof be patented?
06:58:03 <goron> But since we are a pet country of the USA, probably you are right.
06:58:09 <eivuokko> goron, usually it is the application of some maths in certain context that is patented.
06:58:12 <shapr> If not, the Curry-Howard isomorphism says that software can't be patented either.
06:58:38 <eivuokko> Uhm.
06:58:49 <shapr> Maybe we should ship patented software around in proof assistant format to get around patent laws?
07:00:17 <shapr> I think some software patent laws say "any computer executable format." Since Isabelle can generate ML code from a proof... does that count?
07:00:42 <goron> eivuokko: Hmm, ok, that sounds plausible.
07:01:06 <eivuokko> Computer executable format?  Heh...well legislation for software is lacking in many places...one more stupid thing to say
07:02:21 <gour> dcoutts: and when i write a play i have to consider how much actors i have on disposal :-)
07:02:22 <goron> We are also computers in some sense. If we would "execute" a patented algorithm, it would be illegal. It's completely ridiculous.
07:02:41 <eivuokko> Nah
07:03:00 <eivuokko> In most countries private use of patented stuff is allowed, just distribution etc isn't.  Iirc.
07:04:17 <goron> eivuokko: suppose you have some mobile robot which can read an algorithm and learn that algorithm. It goes to a customer and interacts with it and provides a solution using the patented algorithm. Is that illegal? You tell me.
07:04:52 <eivuokko> goron, Doesn't seem private use to me.
07:05:15 <eivuokko> goron, I am not a lawyer, this is all just my interpretation and collected knowledge.
07:05:52 <eivuokko> Sometimes laws are quite explicit of soem cases, but it very country specific.
07:06:07 <goron> eivuokko: suppose this machine is like The Doctor from Star Trek. It means that this doctor can't use some patented algorithm he has read about to perform some task better.
07:06:35 <goron> eivuokko: All this doesn't play _right_now_, but in some point in time it will. 
07:06:47 <eivuokko> Uhm
07:07:16 <xinming> > iter 3 (+)
07:07:17 <lambdabot>  Not in scope: `iter'
07:07:18 <shapr> There are lots of genetic patents recently, but a woman in the UK tried to patent herself and was turned down. 
07:07:38 <eivuokko> She probably wasn't an application or prototype was missing ;)
07:07:38 <ProfTeggy> shapr, re XOR parent: http://free.patentfetcher.com/GetPatentPDF.php?f=Pats/US/41/97/US4197590.pdf
07:07:54 <shapr> It's too bad too, I don't want to infringe on any patents by having children.
07:08:07 <xinming> > iterate 3 (+)
07:08:08 <lambdabot>  add an instance declaration for (Show (a -> a -> a))
07:08:12 <ProfTeggy> s/parent/patent/
07:08:38 <goron> iter 3 (+1)
07:09:06 <shapr> iirc, US patent laws state that ideas previously published in an accredited academic journal cannot be patented.
07:09:10 <xinming> > iterate 3 (+1)
07:09:10 <lambdabot>  add an instance declaration for (Show (a -> a))
07:09:11 <shapr> So I had this crazy idea...
07:09:19 <eivuokko> shapr, that is general idea with patents...
07:09:25 <shapr> It's not that hard to create an accredited journal
07:09:28 <eivuokko> shapr, "Common knowledge" cannot be patented.
07:09:32 <shapr> So why not create an idea spam journal?
07:09:33 <xinming> > iter 3 (+1)
07:09:33 <lambdabot>  Not in scope: `iter'
07:09:57 <shapr> Then you could publish everything from halfbakery.com and all the other 'good idea' sites, and invite anyone to put any idea into the journal.
07:10:09 <goron> take 5  $iterate (+1) 3
07:10:13 <tuomov> Even Turing machine machine was designed for human calculation
07:10:15 <shapr> That might kill off the US patent industry right there.
07:10:38 <eivuokko> shapr, But, note that idea being published there doesnt give any security against patents.  or getting sued for patent, even if that patent is going be turned doww in court.
07:10:59 <goron> >take 5  $iterate (+1) 3
07:11:20 <goron>  > take 5 $ iterate (+1) 3
07:11:38 <shapr> eivuokko: Yeah, but the separate problem of the legal system being an 'outbid your opponent' punishment is a separate problem.
07:11:41 <flux__> @type iterate
07:11:41 <lambdabot> forall a. (a -> a) -> a -> [a]
07:11:48 <eivuokko> shapr, Patents aren't used like that, they are used as threats of getting sued and making it harder, and less reliably, for others to build their business over it.  This is the maluse of patents that makes patents big corporates-only.
07:11:57 <tuomov> prior art doesn't mean much when you don't have the resources to go to court against a megacorp
07:12:37 <shapr> Legal battles should a way to arbitrate, not a way to punish.
07:12:38 <eivuokko> Or even if you have resources, you cant be sure which way the court decides with some wierd twitch.
07:12:47 <goron> How do I tell lambdabot to actually execute something?
07:12:48 <eivuokko> shapr, True.
07:13:01 <eivuokko> shapr, Sadly it doesn't work like that in today's world :-(
07:13:02 <flux__> > take 5 $ iterate (+) 42
07:13:03 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
07:13:03 <lambdabot>   Expected type: (t -> t1) -> t -> t1
07:13:03 <lambdabot>   Inferred type: (t -> t1) -> (t -> t1) -> t -> t1
07:13:13 <shapr> The legal system is the ultimate denial of service attack.
07:13:20 <flux__> > take 5 $ iterate (+5) 42
07:13:20 <eivuokko> Hehe, well said.
07:13:20 <xinming> >iterate 42 (+1)
07:13:21 <lambdabot> [42,47,52,57,62]
07:13:34 <eivuokko> @remember shapr The legal system is the ultimate denial of service attack.
07:13:41 <shapr> :-)
07:13:55 <goron>  > take 5 $ iterate (+5) 42
07:13:58 <shapr> ProfTeggy: That's a cool patent :-)
07:14:01 <goron> > take 5 $ iterate (+5) 42
07:14:02 <lambdabot> [42,47,52,57,62]
07:14:03 <goron> > take 5 $ iterate (+5) 42
07:14:04 <lambdabot> [42,47,52,57,62]
07:14:10 <goron> Ok, ty
07:14:33 * goron is not used to this IRC client.
07:14:55 <tuomov> The common people just need to organise a distributed denial of service attack against it :)
07:15:03 <eivuokko> Uhhuh
07:15:11 <shapr> I've thought of that too, that's why I came up with an idea spam journal.
07:15:24 <eivuokko> I doubt any sane person would want to sue on issues like that
07:15:45 <eivuokko> It is, atleast in here, rather hard to make a case and get to court as a hobby, over some patent..
07:15:48 <tuomov> I was thinking more along the lines of civil disobedience
07:16:14 <eivuokko> How can you civil disobey in regards of patents?
07:16:43 <shapr> Use a patented algorithm while standing in front of the country capitol building?
07:16:44 <eivuokko> Using patented stuff for somethign really nice public wellbeing is probably best idea.
07:17:00 <eivuokko> Ah, maybe I misunderstand civil disobedience then.
07:17:07 <shapr> eivuokko: Like the patented AIDS drugs that are being produced anyway?
07:17:25 <eivuokko> shapr, Yeah.
07:17:33 <shapr> Which country was doing that?
07:17:40 <tuomov> south africa?
07:17:43 <eivuokko> Probably the countries in far-east or africe.
07:17:53 <tuomov> maybe far east and brasilia too
07:18:01 <tuomov> err.. brazil
07:18:03 <eivuokko> The same is/going to happen with that bird flu thingy.
07:18:28 <tuomov> tamiflu may be a huge hoax too
07:18:46 <tuomov> d. e. rumsfeld is a major shareholder in the company that licensed it to roche
07:20:21 <eivuokko> I wish I wasn't so lazy, I'd go read law, lots of funny stuff there.
07:22:56 <tuomov> I'd go insane if I tried that
07:33:17 * joelr1 waves
07:33:26 <joelr1> anyone wants to try my repro case?
07:39:47 <eivuokko> Hmmm.
07:40:36 <joelr1> eivuokko: see my message to haskell-cafe, the last postmortem one
07:40:47 <eivuokko> Yeah, I did
07:41:18 <eivuokko> It is a bit beyond me to debug that, I think.
07:41:20 <joelr1> eivuokko = einar?
07:41:34 <eivuokko> No, Esa Ilari Vuokko.
07:41:34 <joelr1> eivuokko: just see if you get the same error
07:41:35 <joelr1> exception
07:42:06 <eivuokko> Mmmkay.
07:42:27 <joelr1> hmm?
07:42:50 <eivuokko> Btw, do you your Windows binaries in smp or ht machine?
07:43:56 <joelr1> eivuokko: no, just a regular celeron i think or duron, sempron, whatever
07:46:43 <joelr1> shapr: ping
07:47:23 <eivuokko> I am just curious, because I am thinking I spot more issues with ghc libraries in HT machine on Windows (I don't have smp to use)
07:47:47 <joelr1> eivuokko: well, my issues are on mac osx now :)
07:47:55 <eivuokko> Hmh?
07:48:05 <eivuokko> Yeah
07:48:54 <kolmodin> Test.QuickCheck.Batch.run uses the same test cases every time
07:49:04 <kolmodin> @libsrc Test.QuickCheck.Batch
07:49:04 <lambdabot> http://darcs.complete.org/fptools/libraries/QuickCheck/Test/QuickCheck/Batch.hs
07:50:03 <kolmodin> line 182 should be changed to use getStdGen instead of mkStdGen
07:52:12 <goron> dcoutts: I saw the presentation you posted. I never understood the Mickey Mouse joke on Slashdot. Now I do, ty. :D
07:57:17 <dcoutts> goron, yeah the presentation brings it home to you just how many times copyright has been extended
07:57:58 <dcoutts> perpetual copyright by 5 year extensions every 5 years.
08:00:37 <joelr1> dcoutts: duncan, would you be able to look at my stuff?
08:00:39 <joelr1> please
08:00:41 <joelr1> ?
08:00:55 <dcoutts> joelr1, sorry I'm just leaving
08:01:00 <joelr1> oops
08:01:01 <joelr1> ok
08:01:49 <joelr1> Cale: ping
08:01:53 <Cale> hi
08:02:11 <joelr1> do you think you can look at my stuff?
08:02:24 <joelr1> last postmortem message on haskell-cafe
08:03:25 <ski> (is lessing the one with creative commons ?)
08:03:49 <joelr1> ski: would you please look at my stuff?
08:04:03 * joelr1 needs all the help he can get
08:04:14 <ski> moment
08:04:36 <Frederick> yo folks
08:04:40 <Frederick> joelr1, may I help?
08:05:33 <joelr1> Frederick: 100%
08:05:43 <SamB> Frederick: yo
08:05:48 <Frederick> SamB, yo
08:05:50 <joelr1> Frederick: take a look at the last message to haskell-cafe under Postmortem
08:05:56 <joelr1> SamB: wanna help?
08:06:04 <SamB> lets see, what is that...
08:06:13 <joelr1> darcs get http://test.wagerlabs.com/postmortem
08:06:25 <joelr1> SamB: last message to haskell-cafe under postmortem
08:06:30 <xinming> @pl (\x -> x -3 )
08:06:30 <lambdabot> subtract 3
08:06:34 <joelr1> my threadDelay is throwin an exception
08:06:48 <Frederick> joelr1, where can i check it?
08:07:05 <SamB> news.gmane.org/gmane.comp.lang.haskell.cafe ?
08:07:05 <joelr1> Frederick: darcs get http://test.wagerlabs.com/postmortem
08:07:19 <joelr1> Frederick: i'm not sure but SamB must be right
08:07:23 <joelr1> let me get the thread URL
08:07:24 <Frederick> joelr1, oki
08:07:46 <SamB> joelr1: if I must be right, then why did I put a question mark after it?
08:08:22 <SamB> well the right newsgroup name at least ;-)
08:10:38 <goron> dcoutts:yes. I wonder whether there's an organisation like eff in my country.
08:20:46 <ski> http://www.haskell.org/pipermail/haskell-cafe/2005-November/thread.html
08:24:03 <joelr1> ski: is that my thread?
08:27:01 <o_Rocky> can someone tell me in what library is the defenition of cos, and sen?
08:27:19 <shapr> @index cos
08:27:19 <lambdabot> Prelude
08:27:25 <Frederick> SamB, can you help me on understanding the last code you gave me?
08:27:34 <o_Rocky> @index rads
08:27:35 <lambdabot> bzzt
08:27:43 <shapr> What's rads?
08:27:53 <o_Rocky> i don't know :P
08:28:41 <o_Rocky> it's a function that converts a Double to ...(radians?!)
08:29:01 <o_Rocky> @cos 370
08:29:02 <lambdabot> Maybe you meant: code docs yow
08:29:22 <o_Rocky> @type cos
08:29:22 <lambdabot> forall a. (Floating a) => a -> a
08:29:27 <Lemmih> @code
08:29:27 <lambdabot> Module "code" produced error: Text.Regex.Posix.regcomp: error in pattern
08:29:47 <o_Rocky> cos 370
08:30:23 <o_Rocky> 1 + 1
08:30:34 <shapr> What are you doing?
08:30:36 <Lemmih> > "You must start the line with > "
08:30:37 <lambdabot> "You must start the line with > "
08:32:48 <o_Rocky> > cos 370
08:32:49 <lambdabot> 0.7597075150201029
08:32:54 <o_Rocky> oki
08:33:10 <o_Rocky> > cos 360
08:33:12 <lambdabot> -0.2836910914865273
08:33:51 <o_Rocky> there must be a func that converts degrees into radians
08:34:17 <joelr1> Lemmih: wanna help?
08:34:20 <o_Rocky> rads x = (pi * x)/180
08:34:21 <wilx> Why must?
08:34:32 <joelr1> no must
08:35:18 <o_Rocky> :r
08:36:07 <o_Rocky> @index cos
08:36:07 <lambdabot> Prelude
08:36:10 <o_Rocky> @index sen
08:36:11 <lambdabot> bzzt
08:36:14 <o_Rocky> ok
08:36:21 <Cale> sin
08:36:41 <o_Rocky> sen x = cos (x +(pi/2))  (?)
08:36:48 <Cale> joelr1: I've been reading your posts :)
08:36:56 <Cale> > sin (pi/2)
08:36:58 <lambdabot> 1.0
08:37:04 <joelr1> Cale: thank you! just the last one truly matters
08:37:07 <o_Rocky> tks
08:38:03 <Cale> the repro case?
08:38:10 <joelr1> Cale: yes, of course
08:38:32 <joelr1> Cale: cause i can't even get it to where I want it to be
08:38:33 <astrolabe> sin x = cos (x - (pi/2))
08:38:52 <joelr1> Cale: for some strange reason an exception is thrown in treadDelay
08:39:05 <joelr1> and i comment that out then its thrown in expect
08:39:22 <Lemmih> joelr1: No time. Gotta kick some software out of the door before the day is over.
08:39:46 <joelr1> Lemmih: whatcha working on?
08:40:15 <Lemmih> Integrating HSP with GHC.
08:40:31 <joelr1> hmm... what's HSP? are you actually doing that for a living?
08:41:20 <Lemmih> Haskell Server Pages, and it's just a toy project.
08:41:38 <joelr1> Lemmih: very cool still
08:42:15 <joelr1> Cale: so what do you think?
08:42:30 <Cale> joelr1: I'm having trouble downloading the darcs repo.
08:43:54 <Cale> I can ping test.wagerlabs.com, but my browser just sits around waiting for a reply when I go there, and darcs does too.
08:44:07 <joelr1> @#@#^
08:44:07 <lambdabot> Unknown command, try @listcommands.
08:44:16 <joelr1> Cale: i think there's a problem somewhere on the net
08:44:29 <Cale> cale@zaphod[~]$ darcs get http://test.wagerlabs.com/postmortem
08:44:29 <Cale> Copying patch 1 of 1...
08:44:32 <Cale> finally :)
08:44:36 <Frederick> Cale, I cant enter too
08:44:49 <Cale> it's just really really slow perhaps
08:44:54 <joelr1> dreamhost must be having problems
08:45:19 <joelr1> cause i haven't been able to  upload the darcs binary for half an hour now
08:45:32 <joelr1> i wanna apply patches to my remote repo
08:47:17 * shapr bounces
08:47:45 <joelr1> shapr: wanna help?
08:48:29 <Cale> joelr1: perhaps run a local http server?
08:49:01 <SamB> Frederick: you still need help understanding that code?
08:49:04 <Cale> I could put it somewhere world-visible on my machine if it ever downloads
08:49:29 <joelr1> Cale: hmm
08:49:40 <Cale> ah, here we go
08:49:41 <joelr1> Cale: i'm behind a router and a firewall and dreamhost has never failed me before
08:51:10 <Frederick> SamB, sure
08:51:16 <Frederick> cause I have to do the same thing again
08:51:54 <Cale> http://vx.hn.org/postmortem/
08:51:57 <Cale> mirror :)
08:52:10 <joelr1> Cale: cool, thanks. would you post to haskell-cafe?
08:52:15 <Cale> okay
08:52:31 <joelr1> Cale: also, can i send you patches :-)
08:52:36 <Cale> yeah
08:55:11 <joelr1> Cale: you should have no trouble building this
08:56:53 <Cale> got it :)
08:56:54 <xinming> > foldr1 (:) [1..5]
08:56:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:56:55 <lambdabot>   Expected type: a -> a -> a
08:56:55 <lambdabot>   Inferred type: a -> [a] -> [a]
08:57:14 <Cale> (:) doesn't work with foldr1 because of its type
08:57:18 <SamB> Frederick: where to start?
08:57:21 <Cale> > foldr (:) [] [1..5]
08:57:23 <lambdabot> [1,2,3,4,5]
08:57:35 <Frederick> SamB, Im reading about the map usage
08:57:39 <xinming> Cale: thanks
08:57:57 <SamB> Frederick: map as in Data.Map.Map, or map as in Prelude.map, i.e.
08:58:24 <SamB> > map (-2*) [1..10]
08:58:25 <lambdabot>   The operator `*' [infixl 7] of a section
08:58:25 <lambdabot>    must have lower precedence than the operand prefix `-' [infixl 6]
08:58:25 <lambdabot>    in the section: `((- 2) *)'
08:58:30 <SamB> > map ((-2)*) [1..10]
08:58:31 <lambdabot> [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20]
08:59:01 <SamB> or maybe Data.Map.Map
08:59:05 <SamB> er, .map.
08:59:06 <xinming> > map (flip (-2) *) [1..5]
08:59:07 <lambdabot>  add an instance declaration for (Num (b -> a -> c))
08:59:07 <lambdabot>   In an arithmetic sequence: [1 .. 5]
08:59:07 <Frederick> the second
08:59:22 <SamB> Frederick: ah
08:59:33 <SamB> that just applies a function to every element of a list
09:00:22 <SamB> > M.map (^4) (M.fromList [("foo", 2), ("bar, 3)])
09:00:22 <lambdabot>  lexical error in string/character literal
09:00:24 <Frederick> SamB, yep. cause Im trying to put the grammar in CNF so it is very similar with the transitive closure
09:00:27 <SamB> > M.map (^4) (M.fromList [("foo", 2), ("bar", 3)])
09:00:28 <lambdabot> {"bar":=81,"foo":=16}
09:00:48 <SamB> Frederick: CNF?
09:00:57 <SamB> @google CNF normal form
09:00:58 <lambdabot> http://www.cs.duke.edu/csed/jflap/new/DOCS/gui.grammar.transform.ChomskyPane.html
09:01:13 <Frederick> yep
09:01:44 * SamB looks 'Chomsky normal form' up in dict
09:01:51 * SamB finds nothing
09:01:57 <SamB> @wikipedia Chomsky normal form
09:01:59 <lambdabot> http://en.wikipedia.org/wiki/Chomsky_normal_form
09:02:17 <joelr1> Cale?
09:02:21 <Cale> joelr1: okay, I can reproduce the errors
09:02:27 <Cale> having a look at it
09:02:29 <joelr1> cool!
09:02:37 <joelr1> Cale: what's your platform?
09:03:00 <Cale> Debian on Intel
09:03:10 <joelr1> ok
09:03:17 <SamB> Frederick: I see
09:03:43 <joelr1> Cale: Christian reported the same
09:04:44 <joelr1> Cale: how do i find out what the exception is?
09:05:57 <Cale> hmm, taking out the traces which force the evaluation of bio and n get it a little farther
09:06:41 <SamB> Frederick: personally, I would be looking around for some kind of "gensym" if I were you.
09:07:02 <joelr1> Cale: so the exception must be somewhere else then
09:07:17 <joelr1> Cale: cause I tried taking out treadDelay and got to expect
09:07:27 <Frederick> SamB, gensym?
09:07:36 <Cale> er, hmm, I can't reproduce that now
09:07:45 <SamB> @index gensym
09:07:46 <lambdabot> bzzt
09:07:47 <SamB> @index genSym
09:07:49 <lambdabot> bzzt
09:07:53 <SamB> hmm.
09:08:08 <SamB> some sort of symbol-generation functionality would be nice...
09:08:26 <Cale> SamB: it would have to be monadic
09:08:32 <Cale> just use a state monad
09:09:26 <Cale> let's try catching the exception
09:09:31 <joelr1> ok
09:09:42 <joelr1> where would you do that?
09:09:52 <joelr1> i thought i'm catching it with trapEx already
09:10:00 <joelr1> but this one seems to escape
09:10:07 <Cale> It does look like it's in threadDelay here too, I'm not sure why I got the results I did before
09:10:33 <SamB> Cale: yes I know ;-)
09:12:10 <SamB> hmm.
09:12:20 <SamB> @google unique name generation haskell
09:12:21 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/prelude.html
09:12:27 <SamB> not it
09:12:32 <SamB> @google unique name generation monad haskell
09:12:33 <lambdabot> http://www.haskell.org/tutorial/monads.html
09:12:54 <SamB> @google "unique name" generation monad haskell
09:12:56 <lambdabot> http://www.haskell.org/pipermail/haskell/2005-June/016076.html
09:13:11 <eivuokko> o.O
09:13:42 <shapr> Are you guys talking about the unique name generator monad?
09:14:00 <danY2K> hey guys, is there a possible way of overloading constructors inside a type declaration?
09:14:02 <SamB> shapr: I was just googling for one
09:14:10 <shapr> I think it was added in ghc 6.2
09:14:15 <SamB> because it looks like Frederick needs one ;-)
09:14:34 <shapr> iirc, GHC uses it internally, so they just exported it to the libs as well.
09:14:54 <SamB> shapr: what is the name?
09:14:55 <Cale> danY2K: in what sense?
09:15:00 <eivuokko> Is there something magic in such monad
09:15:00 <Cale> (probably not)
09:15:23 <SamB> eivuokko: not really
09:15:38 <SamB> eivuokko: at least, I don't think so
09:16:37 <SamB> eivuokko: certainly there is no NEED for magic
09:16:42 <eivuokko> ;)
09:16:57 <eivuokko> Just cursious, because I that's what I thought
09:17:07 <danY2K> Cale, for example i have a type like this: type Foo = Foo :*: Foo | Int :*: Int  
09:17:28 <Cale> danY2K: no, also, you can't use "type" there -- you'll want data
09:17:47 <Cale> however, you can do  data Foo a = a :*: a
09:17:51 <danY2K> Cale, sorry yep, thats what i wanted to write
09:18:43 <danY2K> Cale, which means that a can be an Int
09:18:47 <Cale> yeah
09:19:03 <SamB> shapr: I again ask you where that is in the library
09:19:08 <danY2K> cewl, thx Cale
09:19:11 <Cale> np
09:19:50 <Cale> if you want a tree of arbitrary depth, use  data Tree a = Branch (Tree a) (Tree a) | Leaf a
09:20:46 <Cale> hm, I wish I knew which thread this exception was coming from. The threadDelay isn't throwing an exception anyway.
09:21:36 <SamB> @google unique name generator monad
09:21:37 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/renamer.html
09:24:14 <shapr> SamB: And again I am silent!
09:24:30 <shapr> ... since I don't remember...
09:25:21 <Cale> It's a fairly trivial procedure to create a monad transformer to add a unique name supply
09:25:38 <shapr> Oh, it's Data.Unique
09:26:20 <shapr> SamB: I found it!
09:26:21 <Cale> Except that Uniques are somewhat restricted
09:26:41 <Cale> you can only compare them and hash them down to Int
09:26:41 <SamB> shapr: isn't that numbers?
09:26:43 <eivuokko> Hmm.  I cannot access HASP page in scannedinavian.org
09:26:52 <eivuokko> Means, I no response from server
09:27:23 <Cale> SamB: shall I write a unique name supply monad transformer?
09:27:43 <SamB> Cale: sure ;-)
09:27:59 <Cale> It's just a StateT Integer with put hidden, and only exposing inc
09:28:31 <SamB> Cale: I want a fancier one
09:28:39 <Cale> what should it be able to do?
09:28:41 <SamB> with, like, names!
09:29:00 <shapr> Oh, I think the unique name supply I read about uses linear implicit parameters.
09:29:11 <Cale> um, names like what?
09:29:33 <shapr> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#linear-implicit-parameters
09:29:46 <Cale> I could write a function which turns an integer into an alphabetic string pretty easily :)
09:30:42 <SamB> Cale: oh, whatever!
09:31:02 <Cale> I'm just not sure what you're looking for is all.
09:31:04 <SamB> I guess there is little point in keeping the old names...
09:31:36 <Cale> if you want to maintain a dictionary, I suppose we could do that
09:31:54 <Frederick> bah, SamB Ive just read the links you guys posted, and just now I realize haskell inst a simple language it is a mathematical notation, in the sence it could be used in many other contexts
09:32:18 * ski pondered comonoids and linear implicit parameters some, today
09:32:20 * SamB has to go to the doctor
09:32:30 <Frederick> SamB, good luck on the doctor
09:32:49 <SamB> Frederick: it is a programming language with a highly mathematical flavour
09:35:11 <Frederick> Cale, thena,es are like productions of the grammar SamB has beeing helping me with
09:35:31 <shapr> Frederick: Math and Programming are the same thing. Do you know the Curry-Howard isomorphism?
09:35:34 <Frederick> type Prod t nt = (ProdName,[Symb t nt])
09:35:53 <Frederick> shapr, for my curry is indian food
09:36:01 <basti_> @type curry
09:36:02 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
09:36:04 <basti_> no food there
09:36:10 <basti_> food elsewhere
09:36:26 <joelr1> @index catchError
09:36:26 <lambdabot> Control.Monad.Error
09:36:51 <shapr> Frederick: Is sch√∂nfinkeling a better name? That was the other option.
09:37:22 <Frederick> shapr, i shall read the curry recipt later :p
09:38:23 <shapr> @wikipedia Curry-Howard
09:38:27 <lambdabot> http://en.wikipedia.org/wiki/Curry-Howard
09:38:58 <shapr> The first guy mentioned there is "Haskel Curry", he's the guy who gave Haskell its name.
09:39:32 <neologism> I think he did more than this :)
09:39:48 <shapr> It's true, he did.
09:41:02 <shapr> What time is it in Portland?
09:41:15 <neologism> GMT-1 ?
09:41:37 <Frederick> brb
09:42:13 <xinming> > concat(concat( map ("title:":) [["help"]]))
09:42:14 <lambdabot> "title:help"
09:42:23 <xinming> @pl concat(concat( map ("title:":) [["help"]])
09:42:23 <lambdabot> (line 1, column 43):
09:42:23 <lambdabot> unexpected end of input
09:42:23 <lambdabot> expecting variable, "(", operator or ")"
09:42:33 <xinming> is there a way to shorten my example
09:42:50 <Igloo> Portland is more like -8 isn't it?
09:42:56 <Igloo> Or am I horribly confused?
09:43:51 <Igloo> xinming: Err, "title:help"
09:44:49 <xinming> Igloo: No, I just wish to compose 2 string
09:45:05 <shapr> salut dmitri83 
09:45:15 <shapr> dmitri83: or is privet better?
09:47:30 <dmitri83> shapr: hi
09:49:40 <neologism> privet is better I think
09:49:54 <xinming> @pl concat(concat( map ("title:":) [["learn","try","haskell"]])
09:49:54 <lambdabot> (line 1, column 60):
09:49:54 <lambdabot> unexpected end of input
09:49:54 <lambdabot> expecting variable, "(", operator or ")"
09:50:09 <xinming> > concat(concat( map ("title:":) [["learn","try","haskell"]])
09:50:09 <lambdabot>  parse error on input `}'
09:50:54 <Cale> > concat (concat (map ("title:":) [["learn","try","haskell"]]))
09:50:55 <lambdabot> "title:learntryhaskell"
09:51:44 <xinming> Cale: how to apply the "title" to every string?
09:52:06 <xinming> Cale: hmm, wish a clever version, mine is ugly.
09:52:46 <shapr> ooh, fun - http://people.debian.org/~igloo/popcon-graphs/index.php?packages=ghc6+ghc6-hopengl+ghc6-prof+hugs+hmake+pugs+drift
09:53:16 <shapr> Looks like ~170 ghc6 installations and ~300 hugs installations.
09:53:23 <shapr> Are all the debian users here also using popcon?
09:53:34 * Igloo suggests http://people.debian.org/~igloo/popcon-graphs/index.php?packages=ghc6+ghc6-hopengl+ghc6-prof+hugs+hmake+pugs+drift&show_installed=on&want_legend=on&beenhere=1 as a more readable alternative
09:54:24 <shapr> popularity-contest is the actual debian package name to install.
09:56:30 <shapr> I can't quite tell when the hugs numbers jumped so much.
09:57:14 <xinming> maybe for it's name is better. ;-)
10:18:28 * shapr sends a short description of "How to solve Ruby problem X in Haskell"
10:19:11 <ValarQ> Ruby problems?
10:19:32 <ValarQ> does that language create a specific group of problems?
10:20:19 <shapr> Two objects, each with their own string property were passed into some code.
10:21:13 <shapr> The original poster had a problem because he swapped the order of arguments to one function. They were the strings from the two objects.
10:21:40 <shapr> He said that his code got less buggy when he added assertions about the type of the passed in objects to the function that takes the two strings.
10:22:29 <shapr> So I described how to use newtype to make a type alias that gives a typechecked 'significant name', and I described how to unpack a datatype with constructor matching.
10:23:34 <shapr> I doubt anyone will respond. Usually my Haskell responses to a Java/Python/Ruby/etc question get ignored, or kill the conversation.
10:24:00 <ValarQ> ok...
10:24:06 <o_Rocky> :)
10:24:17 <o_Rocky> help me instead
10:24:19 <o_Rocky> :P
10:24:27 <shapr> Still, I hope that the different viewpoint will help people understand their problem better.
10:24:53 <ValarQ> o_Rocky: whats the problem?
10:25:17 <o_Rocky> i've been working with State monad
10:26:22 <o_Rocky> and i would like to make the next step... that is, working with State Monad within the IO Monad
10:26:42 <o_Rocky> my question is, How to?
10:27:01 <dcoutts_> xerox!
10:27:10 <xerox> Hey there!
10:27:37 <xerox> Connection breakup, /me trembles!
10:27:44 <shapr> o_Rocky: Did you read the nomaware monad tutorial?
10:28:00 <dcoutts_> xerox, a student here wants to do his masters thesis with this functional graphics / lsystem stuff
10:28:01 <o_Rocky> a little bit :P yes
10:28:15 <dcoutts_> xerox, after being inspired by the practical apparently
10:28:30 <shapr> o_Rocky: The answer is in that tutorial.
10:28:39 <o_Rocky> muhahaha
10:28:40 <o_Rocky> :P
10:28:44 <xerox> dcoutts_: what a news!  I'm very happy about it :-D  Does he IRC? :-)
10:28:54 <dcoutts_> xerox, no he doesn't
10:29:07 <dcoutts_> xerox, I demoed the 3D lsystems stuff to the professor today too. He was much impressed.
10:29:17 <xerox> Heh, lovely!
10:29:21 <dcoutts_> xerox, so next year we'll have it working with cairo and opengl
10:29:51 <xerox> dcoutts_: woo!
10:30:05 <xerox> You're having too much fun up there :-)
10:30:51 <dcoutts_> xerox, yeah
10:31:11 <dcoutts_> marcot, btw I still can't find the libghc6-gtk-dev debian package
10:31:20 <bringert> I think one reason why there are so many Debian hugs installs is that the ghc6 package requires hugs
10:31:32 <bringert> I seem to recall that it does anyway
10:31:33 <dcoutts_> marcot, I thought it went through weeks ago (at least the 0.9.9 version)
10:31:50 <marcot> dcoutts_: There's was a copyright problem with this version.
10:31:56 <dcoutts_> marcot, oh?
10:32:04 <marcot> dcoutts_: The Gtk2HS team was not enough.
10:32:13 <marcot> I sent the 0.9.10 one some time ago.
10:32:19 <marcot> CosmicRay: hello, there.
10:32:22 <dcoutts_> marcot, oh you need all contributers?
10:32:32 <marcot> CosmicRay: Have you uploaded 0.9.10?
10:32:34 <dcoutts_> marcot, they're listed in the AUTHORS file
10:32:38 <marcot> dcoutts_: yes, I've done this.
10:32:43 <dcoutts_> marcot, ok great
10:33:07 <marcot> dcoutts_: actually I've greped all the source with copyright
10:33:35 <dcoutts_> marcot, ok, did you find any differences between that and the AUTHORS file?
10:34:06 <dcoutts_> I try to keep the AUTHORS accurate
10:35:19 <marcot> dcoutts_: I haven't checked the AUTHORS file..
10:42:10 <o_Rocky> shapr: i have troubles with english, can you help me out? :P
10:47:11 <Frederick> o_Rocky, may I help you?
10:49:16 <o_Rocky> Maybe Bool
10:49:35 <o_Rocky> @Just True
10:49:36 <lambdabot> Not enough privileges
10:49:47 <xerox> @type Just True
10:49:48 <lambdabot> Maybe Bool
10:57:14 <soysauce> o_Rocky - you are from Portugal?
10:57:26 <o_Rocky> y
10:57:29 <o_Rocky> why?
10:57:40 <soysauce> you said you had trouble with English
10:57:45 <SamB> Frederick: have you been doing that all day?
10:58:09 <soysauce> I don't speak Portugese, but I can understand it
10:58:26 <Frederick> SamB, +-
10:58:36 <Frederick> SamB, just the afternoon
10:59:28 <o_Rocky> thats new, if you can't speak how can you understand?
10:59:36 <soysauce> because I speak Spanish
10:59:41 <Frederick> I do speak portuguese
11:00:43 <Frederick> SamB, btw what do you mean by that?
11:01:02 <o_Rocky> i was just kidding with shapr... what i want is someone to make some coding for me... :P
11:01:10 <soysauce> haha
11:01:12 <SamB> Frederick: asking to help people
11:01:16 <o_Rocky> some examples, and explain...
11:01:18 <Frederick> o_Rocky, what code?
11:01:30 <SamB> o_Rocky: ooh, I love to do that ;-)
11:01:43 <soysauce> @eval Monad.liftM2 (+) (Just 0) (Nothing)
11:01:43 <lambdabot>  Not in scope: `Monad.liftM2'
11:01:49 <soysauce> er?
11:01:53 <soysauce> @eval liftM2 (+) (Just 0) (Nothing)
11:01:54 <lambdabot> Nothing
11:01:58 <Frederick> SamB, nah Im mostly reading for the CNF stuff the functions Cale mentioned
11:01:59 <o_Rocky> SamB: i'm sure you do... everyone does :P
11:02:10 <soysauce> @eval liftM2 (+) (Just 1) (Just 2)
11:02:11 <lambdabot> Just 3
11:02:14 <soysauce> :D
11:02:25 <Frederick> SamB, but Im kinda down atm
11:02:49 <SamB> o_Rocky: I do not see any indication of forthcoming specification
11:03:22 <o_Rocky> i dont understood "forthcoming"
11:03:55 <o_Rocky> * i didn't
11:04:00 <soysauce> o_Rocky - "following"
11:04:20 <soysauce> o_Rocky - he means that it does not look like you are going to state the problem
11:04:32 * soysauce is an English -> English translator
11:04:42 <xerox> @babel en en English
11:04:44 <lambdabot> Module "babel" produced error: Prelude.head: empty list
11:04:59 <o_Rocky> any one of you uses Gobby?
11:05:10 <xerox> o_Rocky: many of us! :-D
11:05:59 <o_Rocky> ok, maybe i can create a server... and we can do some code :P ok?
11:06:06 <xerox> Okay.
11:06:56 <yaarg> It has Haskell syntax highlighting built in?
11:07:08 <xerox> It has.  Thanks to gtkSourceView.
11:07:15 <o_Rocky> yes
11:07:21 <o_Rocky> ok
11:07:24 <yaarg> Good stuff.
11:07:27 <xerox> dcoutts wrote the Haskell synhl for gtkSourceView, too.
11:07:39 <yaarg> Vim is becoming a bit of hassle for coding.
11:07:44 <o_Rocky> i think everyone can see my IP, so, you can log on...
11:08:04 <SamB> what is gobby?
11:08:07 <xerox> Gobby, at least in my version, does not have _any_ editing facility :-)
11:08:17 <o_Rocky> Gobby - Collaborative text editor
11:08:19 <Frederick> SamB, CODE EDITOR
11:08:19 <yaarg> collaborative editor
11:08:21 <xerox> Anyway, it's a good program.
11:08:25 <Frederick> sorry for caps
11:08:25 <SamB> oooh
11:08:38 <SamB> hmm.
11:08:47 <SamB> It won't install!
11:08:55 <SamB>   gobby: Depends: libgmpxx3 but it is not going to be installed
11:08:56 <xerox> Distributed concurrent text editing.
11:09:06 <xerox> Compile it from sources ;-)
11:09:13 <yaarg> 6
11:09:15 <SamB> @where gobby
11:09:15 <lambdabot> I know nothing about gobby.
11:09:16 <o_Rocky> xerox: log on
11:09:21 <SamB> @google gobby
11:09:22 <lambdabot> http://gobby.0x539.de/
11:09:26 <yaarg> http://gobby.0x539.de/
11:10:03 * yaarg installs
11:10:19 <yaarg> o_Rocky: what code are you writing anyway? :)
11:10:27 <o_Rocky> Haskell :P
11:10:31 <xerox> A Logo interpreter
11:10:42 <soysauce> nice
11:10:48 <soysauce> Logo is fun
11:14:36 <sieni> 275 catches in 5-ball cascade \o/
11:14:45 <gzl> damn
11:14:50 <gzl> that's good :)
11:14:57 <xerox> What is it?!
11:15:04 <gzl> juggling pattern.
11:15:10 <xerox> Woot.
11:15:23 <xerox> How did you count them? :-D
11:15:28 <gzl> I saw some guy do a 5-ball mills mess for about 4 minutes. that was crazy.
11:16:00 <gdfk_> I was never able to juggle at all.
11:18:09 <yaarg> Gobby rules
11:18:45 <SamB> which version of Gobby do I even want?
11:18:55 <sieni> xerox: just counted
11:19:25 <sieni> xerox: it's not that difficult if one has trained 5 ball cascade for 2 years and then basically counting the catches all the time
11:19:48 <SamB> 0.2.x or 0.3.x?
11:20:15 <yaarg> shame it's not a standalone executable
11:22:56 <sieni> xerox: http://jugglinglab.sourceforge.net/siteswap.php?5
11:23:46 <SamB> Frederick: what version of gobby do I want?
11:23:54 <xerox> sieni: hehe, nifty.
11:27:22 <sieni> there are lots of nice patterns
11:27:30 <sieni> like with 4 balls: http://jugglinglab.sourceforge.net/siteswap.php?(6x,4x)(2x,4x)(4x,6x)(4x,2x)
11:34:18 <xinming> in my understanding, that class is a collection of type definitions and instance is a collection of functions definitions, right?
11:34:34 <gzl> what class?
11:34:51 <xinming> class My a where ...
11:35:06 <xinming> instance My Int where ...
11:35:13 <gzl> oh, you're asking in general. sort of.
11:35:26 <gzl> even in the class definition, you can define some of the functions in terms of the others
11:35:43 <gzl> so for example x /= y = not (x == y) 
11:35:48 <xinming> hmm, what's the difference between class and instance.
11:36:05 <gzl> the instance provides the definitions of the essential functions specified by the class
11:36:16 <gzl> but there may be functions in the class that are defined in terms of those base functions
11:36:19 <gzl> and they need not be specified in the instance
11:36:29 <gzl> if you just define == for your type, you don't also need to define /=
11:36:41 <xinming> :-S
11:36:43 <gzl> because it's just the opposite, and that's specified in the class itself
11:36:44 <gzl> see?
11:37:07 <xinming> hmm, need to read more, thanks anyway.
11:37:13 <gzl> ...
11:37:18 <gzl> why, what's the problem?
11:41:02 <gzl> they're just default methods
11:41:09 <gzl> like abstract classes in Java
11:42:11 <kolmodin> jlouis: there?
11:42:18 <paolino> xinming I think classes are contracts for types, so types declaring to be instances of a class can be "used" before they are declared from a generic code which is based on the class contract , (far from been clear :P) 
11:43:09 <gzl> just think of them like abstract classes
11:44:39 <paolino> gzl , the concept of "classes implementing an abstract"  is wider here right ?
11:44:59 <gzl> I don't understand the question
11:45:29 <xinming> paolino: more confused. :-/
11:45:38 <gzl> xinming: do you know what an abstract class is?
11:45:44 <gzl> (in Java)
11:45:52 <xinming> hmm, sorry
11:46:34 <gzl> there's nothing that complicated about this concept. your original idea was right, except that a class can also have default methods, so it's not strictly just type signatures
11:46:48 <gzl> if you understood that I'm not sure why this minor addition is confusing you
11:47:14 <paolino> mmhh here the type must be at least in one place  in every method signature  which is a superset of the OO idea
11:47:24 <gzl> I think you're just confusing him more
11:47:49 <gzl> I can't follow what you're saying either :P
11:47:58 <paolino> ok, I shut up :)
11:48:24 <SamB> basicly, just pretend like the compiler cuts and pastes the default methods into each class which doesn't give code for those methods ;-)
11:48:33 <gzl> yeah
11:49:10 <shapr> gwahr!
11:49:14 <xinming> gzl: hmm, could you please give an example ? define a Myeq class which use === to test for equaility
11:49:36 <gzl> class Eq a where
11:49:41 <xinming> class Myeq a where
11:49:44 <gzl> (==), (/=) :: a -> a -> Bool
11:49:46 <xinming> not Eq
11:49:54 <gzl> what's the difference
11:50:05 <xinming> gzl: as this is built-in
11:50:13 <gzl> this is the definition of the built-in thing
11:50:13 <SamB> FYI, the convention clearly states that you should spell that MyEq
11:50:28 <gzl> fine, it makes no difference, but:
11:50:31 <gzl> class MyEq a where
11:50:35 <SamB> xinming: you think things are built-in by magic?
11:50:44 <gzl> (===), (=/=) :: a -> a -> Bool
11:50:54 <gzl> x =/= y = not (x === y)
11:51:02 <SamB> no, they use source code, mostly ;-)
11:51:12 <xinming> SamB: No. But built-in is a bit hard for me to test :-)
11:51:12 <gzl> that's the same thing as Eq only you've unnecessarily named it and its methods something else
11:51:43 <SamB> and the compiler can't derive instances
11:51:44 <SamB> and none of the library implements it
11:51:50 <SamB> and none of the library uses it
11:53:34 <joelr1> folks, how do i get a file descriptor from a handle?
11:54:03 <fworp> @hoogle Handle -> IO Fd
11:54:04 <lambdabot> No matches, try a more general search
11:54:05 <fworp> doh
11:54:10 <xinming> hmm, Ok, now, if we wish to test Bool, then, there is a function definition `greater :: MyEq => a -> a -> a ->Bool` 
11:54:16 <fworp> @hoogle Handle -> Fd
11:54:17 <lambdabot> No matches, try a more general search
11:54:20 <SamB> @hoogle Handle -> Fd
11:54:21 <lambdabot> No matches, try a more general search
11:54:29 <SamB> @hoogle toFd
11:54:30 <lambdabot> No matches found
11:54:36 <joelr1> @hoogle fd
11:54:36 <lambdabot> System.Posix.Types.Fd :: Fd
11:54:36 <lambdabot> System.Posix.Types.Fd :: CInt -> Fd
11:54:36 <lambdabot> Network.Socket.fdSocket :: Socket -> CInt
11:54:45 <SamB> probably buried in some undocumented file or something
11:54:51 <SamB> @hoogle ToFd
11:54:51 <lambdabot> No matches found
11:54:52 <joelr1> hmm
11:54:56 <SamB> @hoogle handleTo
11:54:57 <lambdabot> No matches found
11:54:58 <gzl> xinming: I don't understand the question
11:55:00 <SamB> @hoogle handle
11:55:00 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
11:55:00 <lambdabot> System.IO.Handle :: Handle
11:55:00 <lambdabot> Control.Exception.handleJust :: (Exception -> Maybe b) -> (b -> IO a) ->
11:55:00 <lambdabot> IO a -> IO a
11:55:10 <SamB> @hoogle handle fd
11:55:11 <lambdabot> Prelude.undefined :: a
11:55:11 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
11:55:11 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:55:21 <fworp> thats way ff
11:55:27 <SamB> @help hoogle
11:55:27 <lambdabot>  @hoogle <expr>, Haskell API Search for either names, or types.
11:55:33 <xinming> gzl: thanks anyway, I think I still not understand what a class is in haskell. :-/
11:55:43 <joelr1> @hoogle socket fd
11:55:43 <SamB> xinming: did you hear me?
11:55:44 <lambdabot> Prelude.undefined :: a
11:55:44 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
11:55:44 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:56:04 <gzl> xinming: I don't get it. you understood before, and I just made a minor correction
11:56:10 <Lemmih> @index handleToFd
11:56:11 <lambdabot> System.Posix.IO, System.Posix
11:56:19 <SamB> I told you to pretend the compiler cut and pasted the default methods into instances which did not implement those methods?
11:56:45 <joelr1> Lemmih: that's only available on Unix, right? not on Windows
11:56:53 <joelr1> no matter, though, thanks
11:57:02 <gzl> xinming: a type class is basically a collection of types with some common functionality (for example, the set of types for which (==) makes sense forms the type class Eq)
11:57:15 <SamB> joelr1: I would say to try it and see...
11:57:30 <gzl> xinming: you specify the class by first making a class declaration and defining the functions that types belonging to the class must implement
11:57:31 <xinming> lisppaste2: help
11:57:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:57:37 <SamB> unless you know the posix package to be totally missing on windows...
11:57:37 <gzl> xinming: and then define instances of the class for each of those types
11:57:38 <xinming> SamB: I did. :-)
11:57:40 <gzl> xinming: that's it
11:57:54 <kolmodin> anyone coding on conjure: where should I send my patches? to jlouis@mongers.org ?
11:57:56 <joelr1> ok, thank you guys
11:58:05 <shapr> kolmodin: yup
11:58:17 <SamB> kolmodin: what are they for?
11:58:19 <kolmodin> unsigned for now I suppose
11:58:27 <SamB> what modules are you hacking?
11:58:30 <shapr> kolmodin: You may also want to forward them to SamB
11:58:31 <kolmodin> QC of BEncode
11:58:37 <kombinator> all: what do you think about adding Qids to haskell?
11:58:43 <SamB> ah, yeah, jlouis is fine for that
11:58:49 <shapr> I thought there already was QC for BEncode?
11:58:50 <kolmodin> and a more efficient bShow
11:59:09 <shapr> I wrote QC for BEncode in Combinatorrent at least...
11:59:10 <SamB> shapr: there was like one property in the file, I think
11:59:16 <kolmodin> oh :)
11:59:33 <shapr> kolmodin: Anyway, the more the merrier
11:59:38 <kolmodin> :D
11:59:55 <shapr> How do you say that in Swedish? ju mer desto roligare?
11:59:57 <kolmodin> well, I didn't find any bugs
12:00:06 <kolmodin> "ju fler ju roligare"
12:00:25 <shapr> I found several bugs, but that's because sylvan wrote the original version of BEncode in about an hour and posted it the haskell-cafe  list.
12:00:25 <SamB> if you'd done something with the TrackerClient or the WireProtocol or the MiniHTTP module, I'd want in on that
12:00:48 <kombinator> does anyone have an opinion on this (qids)?
12:00:53 <shapr> I then stole that version, cleaned it up, wrote QC tests, fixed bugs, did a few other things, got bored and went off to do something else.
12:01:02 <SamB> what are qids?
12:01:06 <fworp> what is a Qid?
12:01:09 <kombinator> quoted identifiers
12:01:13 <SamB> um
12:01:18 <shapr> What's that?
12:01:24 <SamB> what do they look like?
12:01:27 <SamB> are they butt ugly?
12:01:33 <fworp> like ^var bname here^?
12:01:38 <kombinator> like strings, but with O(1) equality checking
12:01:43 <SamB> oh
12:01:44 <fworp> oh those
12:01:48 <SamB> eh.
12:01:52 <kombinator> and possibly restricted
12:02:03 <kombinator> not containing space etc.
12:02:07 <kolmodin> well, I found a property prop_identity before but no Arbitrary instance
12:02:16 <shapr> I still don't know what it is, but ok...
12:02:23 <SamB> as long as you don't have to actually extend the compiler to do it, why not?
12:02:59 <kombinator> I don't know how to implement them without extending the compiler:(
12:03:02 <shapr> kolmodin: http://www.scannedinavian.org/~shae/combinatorrent/Bittorrent/BEncode.hs
12:03:26 <SamB> anyway, the bulk of the comparisons would be less-then/greater-then
12:03:32 <shapr> kolmodin: I'd like to see your prop(s) also, I don't know how other people use QC.
12:03:44 <SamB> well, less-then/greater-then/equal-to
12:04:21 <SamB> so what does interning do for that, anyway?
12:04:22 <shapr> QC sure is fun.
12:04:31 <kombinator> I guess that (most of) lisp implementations have O(1) Qids
12:04:33 <fworp> shapr, i think they are like quoted lisp atoms 'foo etc
12:04:35 <shapr> It's amazing what sort of bugs you can find.
12:04:55 <SamB> kombinator: how do they implement DiffArray?
12:05:08 <SamB> look at that, and you could probably figure it out yourself ;-)
12:05:16 <shapr> Don't you have O(1) equality checking if you have full CSE?
12:05:25 <shapr> er, O(1) equality checking of string equality?
12:05:40 <kombinator> SamB: how is DiffArray related to Qids?
12:05:50 <shapr> I'm not sure if that works out or not.
12:05:54 <kombinator> shapr: it's done using a trick
12:06:03 <SamB> kombinator: A functional interface but imperative internals?
12:06:12 <kolmodin> shapr: I did it a bit differently
12:06:19 <SamB> kombinator: also, DiffArray, too, is done with a trick
12:06:31 <kombinator> SamB: I see...
12:06:37 <SamB> did I mention unsafePerformIO?
12:06:43 <kolmodin> is the Show BEncode instance used anywhere?
12:06:54 <SamB> kolmodin: I believe so
12:07:10 <SamB> build and then run ./conjure on a .torrent file
12:07:20 <kolmodin> ok, I changed it do deriving Show for debugging purposes
12:07:23 <kombinator> and do you think Qids would be useful?
12:07:46 <SamB> kombinator: not particularly, if Ord wasn't more efficient...
12:08:00 <shapr> I don't know the pros and cons of Qids.
12:08:34 <SamB> but I know that a Map Qid foo wouldn't be much more useful with O(1) ==
12:08:39 <kombinator> shapr: you can think of them as of unlimited enums
12:09:15 <SamB> kombinator: that isn't very usefull
12:09:32 <kombinator> case x of `eval -> ...; `apply -> ...
12:09:40 <SamB> um
12:09:47 <SamB> we have a type system for a reason
12:09:48 <Cale> > map ("title: " ++) ["Hello", "World"]
12:09:49 <lambdabot> ["title: Hello","title: World"]
12:09:51 <shapr> Is that like comparing strings by pointer equality or something?
12:09:54 <Cale> xinming: like that?
12:10:04 <SamB> shapr: exactly
12:10:05 <kombinator> shapr: exactly
12:10:09 <sieni> fsck
12:10:10 <shapr> oh
12:10:25 <sieni> managed to juggle a ball directly into a wine glass
12:10:29 <Cale> If you can actually test string equality in O(1), then I have some strings I'd like you to check the equality of :)
12:10:32 <sieni> (white wine fortunately)
12:10:55 <xinming> Cale: thanks, That is. :-) I finally know how to use ++ :-P
12:10:57 <SamB> kolmodin: did you make sure it has a read instance also?
12:11:18 <SamB> which is also derived?
12:11:22 <kombinator> Cale: but converting a String into a Qid is not O(1)
12:11:24 <kolmodin> nope... so (read . show) does not hold
12:11:35 <SamB> kolmodin: make it hold
12:11:51 <SamB> because you can't just paste the Show from a Map into GHCi and expect it to Work
12:11:54 <shapr> I use parse . render in my property.
12:12:19 <SamB> shapr: I haven't seen functions called that
12:12:42 <SamB> kombinator: also, make sure it still parses torrent files!
12:12:46 <SamB> er,
12:12:47 <shapr> It was pseudocode..
12:12:49 <SamB> kolmodin: 
12:12:52 <shapr> prop_Unit x = fromRight (parse beParse "" (renderBencoded x)) == x
12:12:55 <SamB> shapr: oh
12:13:07 <shapr> Anyway...
12:13:49 <SamB> kolmodin: got that?
12:14:02 <shapr> SamB: It's really jlouis' project.
12:14:13 <shapr> :-)
12:14:18 <kolmodin> well, I can undo the deriving part now that I'm satisfied with my Arbitrary generator
12:14:19 <SamB> shapr: I know that ;-)
12:14:51 <soysauce> is there any way to force a computation to run in order to benchmark performance?
12:15:00 <SamB> because I haven't done nearly enough to claim it as mine, and I don't have "darcs send"-friendly email eiher
12:15:45 <kombinator> SamB: ok, so I'll take a look at DiffArray
12:15:58 <SamB> thats in Data.Array.Diff
12:17:24 <basti_> whats up with haskell and matrices?
12:17:35 <Cale> Diff arrays are pretty cool
12:17:36 <soysauce> ?
12:17:50 <basti_> where is a decent matrix lib?
12:17:51 <SamB> kolmodin: oh, I'd like to pull your patches ;-)
12:17:52 <kombinator> now my second question: don't you think that being albe to catch any error in the IO monad is somehow evil?
12:17:55 <soysauce> what is the advantage to a diff array? I never understood...
12:18:07 <SamB> soysauce: O(m) //
12:18:24 <SamB> m being the length of the list passed as //'s second arg
12:18:35 <soysauce> *nods* but you lose O(1) !, don't you?
12:18:39 <tuomov> is there some really simple blogging tool for generating static rss (and maybe html from a text file)?
12:18:44 <SamB> / being the update operator
12:18:47 <SamB> er, //
12:18:48 <kolmodin> SamB: I'll just undo the deriving and put back the old Show BEncode
12:18:52 <soysauce> I know, I am familiar with it
12:18:55 <kolmodin> SamB: where should I send it?
12:18:59 <SamB> soysauce: not usually
12:19:08 <shapr> tuomov: I don't know of any, but Flippi could probably be hacked to do that.
12:19:18 <shapr> stepcut wrote a nice RSS.hs
12:19:19 <soysauce> SamB - how is that possible?
12:19:20 <SamB> only if you go back and look at an older one
12:19:29 <soysauce> ...?
12:19:42 <SamB> soysauce: look at the code ;-)
12:20:12 <shapr> kombinator: I think I saw in the 'inexact exceptions' paper that you can't catch string based exceptions in pure code.
12:20:31 <kombinator> oh, it seems it is not possible to catch evary error
12:20:42 <flux__> tuomov, btw, for some reason your irssi on jolt is huge, but otoh rss is small, so maybe it is ok (..but the machine is paging constantly nevertheless)
12:21:00 <kombinator> shapr: define 'string based exceptions'
12:21:00 <SamB> kombinator: I don't think being able to catch any error in IO is evil at all
12:21:06 <flux__> (i'm not a registered user, so no /msg for me ;))
12:21:06 <shapr> kombinator: I think that exceptions are separate from something like Either because of that. Either is a pure value that represents error, but exceptions don't have pure behaviour. Is there more to know about that?
12:21:08 <tuomov> hmm..
12:21:24 <SamB> kombinator: because there really isn't anywhere else to do it...
12:21:30 <soysauce> SamB - hm, interesting... I have an implementation of Floyd-Warhsall's algorithm in which I update a matrix N times which means copying N ** 2 elements N times... but my change list is much smaller
12:21:37 <shapr> What does vuotava mean?
12:21:41 <flux__> leaking
12:21:43 <shapr> oh
12:21:50 <soysauce> so can it actually rebuild the entire array in O(m)?
12:22:02 <soysauce> and Array.! is O(1) regardless of the (x,y) pair I pass to it?
12:22:07 <SamB>     -- When the '//' operator is applied to a diff array, its contents
12:22:07 <SamB>     -- are physically updated in place. The old array silently changes
12:22:07 <SamB>     -- its representation without changing the visible behavior:
12:22:07 <SamB>     -- it stores a link to the new current array along with the
12:22:07 <SamB>     -- difference to be applied to get the old contents.
12:22:17 <SamB> soysauce: it isn't, iirc, Array.!
12:22:21 <kombinator> shapr: now I realised that you can't catch 'normal' error (_|_)
12:22:44 <shapr> Would be nice if you could :-)
12:22:46 <soysauce> interesting...
12:22:50 <SamB> @type (Array.!)
12:22:51 <lambdabot> forall e i. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> i -> e
12:22:58 <SamB> @type (Data.Array.Diff.!)
12:22:59 <lambdabot> forall e i (a :: * -> * -> *).
12:22:59 <lambdabot> (GHC.Arr.Ix i, Data.Array.Base.IArray a e) =>
12:22:59 <lambdabot> a i e -> i -> e
12:23:11 <soysauce> ah, yes, sorry :)
12:23:19 <tuomov> flux__: why's bogofilter gone from jolt, btw?
12:23:23 <SamB> just nitpicking ;-)
12:23:26 <palomer> in haskell, a function _always_ returns the same thing for the same input, right?
12:23:28 <soysauce> but the types are nearly identical, the only difference being the array type
12:23:29 <soysauce> I know
12:23:38 <Cale> palomer: yes
12:23:40 <kombinator> I want to recall my question now;)
12:23:42 <SamB> palomer: yup
12:23:52 <SamB> unless the name of the function begins with unsafe!
12:23:54 <Cale> palomer: unless you're using something evil like unsafePerformIO
12:23:59 <Cale> yeah
12:24:04 <flux__> tuomov, hm, they must've disappeared when the system was switched to ubuntu..
12:24:18 <tuomov> no, it worked fine until very recently
12:24:20 <SamB> or it uses unsafe, and there is a bug in it
12:24:44 <SamB> (not the least of which is having a name which itself does not begin with unsafe)
12:24:49 <flux__> tuomov, maybe your path is missing /opt/mail/bin
12:24:59 <flux__> that might have changed due to some system update
12:25:05 <tuomov> yeah, that's it
12:25:23 <SamB> and then there are the not-actually-functions...
12:25:33 <Cale> Of course, you're allowed to hide the use of unsafe* if you can prove that it really is safe and referential transparency is preserved.
12:25:54 <shapr> I wish I could get research paper onto my iRiver in some viewable format.
12:26:12 <shapr> papercasting... hmm
12:26:28 <flux__> shapr, atleast ihp-120 supports txt-format :)
12:26:50 <shapr> Yeah, but I'm using an IFP-899.
12:26:56 <tuomov> the display is a bit too small for reading..
12:27:04 <shapr> About once a day I wish the IFP firmware were open source.
12:27:10 <shapr> I've thought of *so many* improvements.
12:27:17 <flux__> you would be desperate to use that for reading long texts anyway.
12:27:23 <flux__> but
12:27:34 <flux__> maybe it could have festival running!
12:27:37 <shapr> right :-)
12:27:53 <shapr> That's one of things iRiver should have.
12:28:10 <flux__> well, you could also bulk convert the texts into mp3 on your desktop
12:28:11 <SamB> do they run Linux? no?
12:28:20 <flux__> I think they might
12:28:21 <shapr> I unicycle furiously while listening, but I wish it would interrupt my music every half hour and tell me the time with festival.
12:28:26 <SamB> do they have enough CPU for festival?
12:28:43 <flux__> I doubt festival is _that_ cpu intensive?-o
12:28:48 <nuffer> http://www.haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL.html anyone know why this program would successfully compile and link and then when I run it, do nothing?
12:28:51 <shapr> For some applications, like the spoken time , you only need sound samples.
12:28:57 <nuffer> well, it doesn't return or exit, it just sort of sits there
12:28:59 <nuffer> an empty console
12:28:59 <flux__> I mean the thing can play mp3's, and I doubt it has hardware support for that
12:29:18 <flux__> (because it can play oggs too, maybe I should've picked that as an example ;))
12:29:20 <SamB> flux__: well, MP3s aren't really intensive at all...
12:29:25 <shapr> There are some excellent synthesis apps that just sew word samples together, that would be easy to do on the iriver.
12:29:26 <kombinator> SamB: DiffArray uses lots of unsafe*. I guess I could implement Qids like that, but what about getting rid of Qids that are garbage-collected?
12:29:33 <SamB> oggs, apparantly moreso
12:29:52 <flux__> well, 486/100 can just barely play mp3 128kbit/s
12:29:54 <SamB> kombinator: uh, I dunno.
12:30:14 <SamB> maybe you'd need to beg a nice way to do weak references of non-foreigny stuff?
12:30:19 <shapr> Then you'd just collect a bunch of samples that match the vocabulary of the text you want to hear, and listen!
12:30:51 <shapr> I also wish my iriver would save the record of the  songs I listened to so I could upload it to audioscrobbler.
12:31:34 <shapr> I wish it would have a less than one second boot time for recording, when I get cool ideas they're very fragile, and focussing my attention on making my iriver record sometimes blows them away.
12:31:52 <palomer> flux__: you're kidding me, right?
12:31:55 <shapr> I wish that play were also a one button operation.
12:32:00 <basti_> shapr: how do i do matrices in haskell?
12:32:12 <Cale> basti_: with arrays?
12:32:12 <palomer> flux__: I could probably get a 386/33 to play an mp3 128kbits/s
12:32:15 <Cale> Or lists
12:32:16 <kombinator> SamB: It's not obvoius to me how to do it. I won't try doing it unless I will be convinced that I need Qids.
12:32:17 <flux__> hmm
12:32:18 <shapr> palomer: do it!
12:32:26 <basti_> Cale: i.e. "is there some lib?"
12:32:30 <SamB> flux__: 486 isn't as powerful as same-clocked pentium is it?
12:32:34 <palomer> how fast do you think the processors on the mp3 players are?
12:32:38 <flux__> samb, no
12:32:43 <flux__> palomer, with the players of the '90s or the most recent ones?
12:32:45 <Cale> basti_: there are a couple of libraries out there, but nothing to call home aout
12:32:48 <Cale> about*
12:32:53 <palomer> flux__: players from the 90s
12:33:00 <basti_> :/
12:33:11 <shapr> palomer: I only know of one recent mp3 player that works on a pentium 75MHz
12:33:31 <SamB> basti_: call out to those famous C/Fortran libs?
12:33:37 <soysauce> what does "boxing" refer to in the context of Haskell?
12:33:40 * SamB can't rembember their names
12:33:44 <basti_> nyup
12:33:59 <shapr> soysauce: um, thunks versus being directly in memory.
12:34:05 <Cale> http://www.haskell.org/hawiki/LinearAlgebra
12:34:08 <flux__> I think I need to seriously doubt that. I'm soo sure I've done just that with 486, and the cpu load was almost maxed out :-o
12:34:19 <soysauce> hm
12:34:24 <flux__> http://fabrice.bellard.free.fr/mpg123-486.html
12:34:40 <soysauce> unboxed data requires pre-computation?
12:34:45 <shapr> flux__: musicpd.org will probably do it, but I can't think of anything else that would.
12:34:53 <nuffer> why does HGL not open a window at all?
12:34:55 <soysauce> i.e. can't be lazy with respect to it
12:34:57 <nuffer> would someone like to clue me in?
12:35:00 <flux__> it says mpg123 works with 486dx4/100 but not dx2/66, when in stereo and 44kHz
12:35:09 <kombinator> early mp3 decoders used fp operations, now there are several fixed-point implementations available
12:35:17 <shapr> flux__: And only with that patch
12:35:23 <kombinator> maybe they are faster on old processors
12:35:34 <shapr> Could be, madplay would be the one to try. It's pure integer.
12:35:44 <flux__> 486 is much faster than 386 anyway
12:35:58 <shapr> I tried to get madplay running on the Nokia 9210 long ago.
12:36:13 <shapr> soysauce: Not precomputation, just strictness.
12:36:13 <kombinator> what cpu is that?;)
12:36:34 <shapr> kombinator: I think the nokia 9210 was an ARM5 something.
12:36:43 <soysauce> er, ok, that's what I understood
12:37:11 <soysauce> so essentially an boxed array would be faster?
12:37:11 <shapr> soysauce: For example, you know that something isn't actually executed until its value is requested, right?
12:37:15 <soysauce> yes
12:37:21 <soysauce> lazy language
12:37:29 <soysauce> since [0..] is not fully evaluatable
12:37:34 <shapr> Right, exactly.
12:37:55 <shapr> If you tried to unbox [0..] you'd run out of memory.
12:38:15 <soysauce> *nods*
12:38:25 <shapr> Unboxing [0..5] would be okay, you'd end up with those value right next to each other in memory.
12:38:54 <soysauce> OK, that makes sense
12:38:55 <shapr> Read the mailing list archives on unboxed arrays for example.
12:39:05 <shapr> Unboxed values are faster, but they're not lazy.
12:39:09 <basti_> so the simple answer is: "different"?
12:39:20 <soysauce> once I get this program working, I think I'll rewrite the code to use unboxed, mutable arrays
12:39:46 <shapr> Sometimes lazy is more efficient than strict, with Okasaki's amortized complexity data structures for example.
12:40:09 <shapr> basti_: For the most part, unboxed arrays are faster.
12:40:38 <basti_> so we're down to "imperative style"?
12:40:43 <shapr> I'm still not sure if the reason for that is purely cultural or not.
12:41:24 <soysauce> I have to recompute this NxN matrix N times, the contents are :: Maybe Int, so it makes a *lot* of sense to use an unboxed array
12:41:26 <shapr> Laziness can be very powerful, but I don't see many people using it well.
12:41:32 <kolmodin> SamB: where does your mailbox live? (your email adress for the patches, please)
12:41:38 <basti_> lets say i'd want to have quick results.
12:41:56 * shapr will return in 36 hours...
12:42:29 <kolmodin> shapr: glhf
12:42:29 <flux__> laziness does sometimes need to be planned for though
12:42:36 <nuffer> I know someone wants to help me get HGL working...
12:42:38 <flux__> so your algorithm doesn't do stuff like length result
12:43:05 <soysauce> seems more like strictness is usually what you want; but laziness is appropriate sometimes... but I've always been an imperative programmer, so I don't know anything. :p
12:43:12 <gdfk_> I've always liked laziness more conceptually than practically.
12:43:29 <eivuokko> soysauce, usually you don't care...
12:44:01 <soysauce> well, don't care is the same as preferring strictness since the bookkeeping is probably more expensive than the computation itself
12:44:03 <kolmodin> anyone used Test.QuickCheck.Batch.run / runTests?
12:44:38 <kolmodin> I noticed that the same test cases are generated each time
12:45:05 <eivuokko> soysauce, No it isn't.  For most of the expressions in code, in general, it doesn't matter (except for part of semantics).
12:45:32 <tuomov> shapr: nanoblogger (.sf.net) seems pretty much what I want
12:45:52 <flux__> witch strict code there are cases when the code doesn't terminate while the lazy code would
12:45:59 <flux__> I don't think there's any other difference?-o
12:46:06 <flux__> (except performance of course)
12:46:11 <eivuokko> Yeah.
12:46:35 <nuffer> anyone... HGL... any help?
12:56:03 <palomer> don't you guys hate it when you think " I really shouldn't be doing this, because it will lead to this bug later on, but I'll remember to change it back later" and then you forget to change it back, and you spend 40 minutes trying to figure out where the bug is?
12:56:23 <nuffer> I hate it when HGL won't do anything, and I don't know why
12:56:36 <nuffer> it's not like it gives me an error message, or something, it compiles, links, runs, it just does nothing
12:59:23 <kolmodin> SamB: you've got mail
12:59:35 <dcoutts_> nuffer, SOE or full HGL?
13:00:39 <dcoutts_> nuffer, HGL with hugs or ghc? windows or linux?
13:00:44 <lisppaste2> xinming pasted "what's the problem" at http://paste.lisp.org/display/13743
13:01:27 <dcoutts_> xinming, what's the error message?
13:01:28 <xinming> after load into ghci 3 =+= 4 won't work
13:01:29 <nuffer> HGL with ghc on windows
13:01:37 <dcoutts_> nuffer, yeah. That doesn't work.
13:01:52 <nuffer> just doesn't work, and that's that?
13:01:56 <xinming> hmm, where I did wrong please?
13:01:57 <dcoutts_> nuffer, it is known to be non-functional.
13:02:11 <dcoutts_> nuffer, pretty much. No one has been bothered to fix it.
13:02:20 <nuffer> oh, okay
13:02:22 <nuffer> sweet
13:02:28 <nuffer> does HOpenGL work?
13:02:44 <dcoutts_> nuffer, HGL works with hugs on win32 apparently
13:03:20 <dcoutts_> nuffer, if you're just using SOE rather than the full HGL then there is a new implementation that works on all paltforms based on Gtk2Hs
13:03:31 <nuffer> SOE?
13:03:50 <dcoutts_> Graphics.SOE is a cut down version of Graphics.HGL
13:04:09 <dcoutts_> it's the version presented in the "Haskell School of Expression" book
13:04:11 <nuffer> cut down in what way?
13:04:15 <dcoutts_> smaller API
13:04:21 <xinming> dcoutts: 
13:04:22 <xinming> Ambiguous type variable `a' in the constraints:
13:04:22 <xinming>       `Plus a' arising from use of `=+=' at <interactive>:1:2-4
13:04:22 <xinming>       `Num a' arising from the literal `3' at <interactive>:1:6
13:04:22 <xinming>     Probable fix: add a type signature that fixes these type variable(s)
13:04:27 <nuffer> eh, whatever, I'm just getting hugs
13:04:50 <mauke> @type 3
13:04:50 <lambdabot> forall t. (Num t) => t
13:04:56 <mauke> 3 isn't an Int
13:05:02 <dcoutts_> nuffer, if you don't have to use HGL then I'd reccomend Gtk2Hs or wxHaskell instead.
13:05:37 <dcoutts_> nuffer, they're both less ugly, less broken and better maintained.
13:06:24 <dcoutts_> xinming, you didn't say what expression you typed at the ghci command line
13:06:33 <xinming> 3 =+= 3
13:06:45 <xinming> dcoutts_ xinming, what's the error message?
13:06:45 <xinming> xinming after load into ghci 3 =+= 4 won't work
13:06:54 <palomer> the attack of the killer operators
13:07:00 <mauke> xinming: 3 isn't an Int
13:07:08 <mauke> it doesn't know which overload you want
13:07:17 <xinming> mauke: hmm, How should I change that script please?
13:07:48 <fworp> not the script, just specify the type of numeric literals to ghci
13:08:07 <xinming> 3::Int ?
13:08:09 <fworp> right
13:08:52 <fworp> (3::Int) =+= 4 is probably sufficient
13:09:06 <dcoutts_> it is
13:09:17 <dcoutts_> however the definition is _|_
13:09:35 <nuffer> dcoutts_, if I'm looking for OGL support, should I be using HGL or HOpenGL?
13:09:38 <xinming> I think I comprenhend class and instance in haskell a little.
13:09:48 <dcoutts_> nuffer, OGL?
13:09:59 <nuffer> OpenGL
13:10:15 <dcoutts_> HOpenGL is a Haskell binding to OpenGL
13:10:20 <nuffer> well, really 3d graphics, but I doubt there are DirectX bindings
13:10:31 <dcoutts_> HGL has nothing to do with OpenGL
13:11:55 <dcoutts_> you can use HOpenGL with GLUT, Gtk2Hs or wxHaskell
13:12:55 <dcoutts_> I've been using HOpenGL with Gtk2Hs recently
13:13:10 <xinming> what is Ord short for?
13:13:15 <palomer> order
13:13:24 <xinming> thanks.
13:16:48 <eivuokko> Ordered ;)
13:17:59 <palomer> orderable?
13:18:57 <eivuokko> Orderd is what it's spelled out long in report, iirc.
13:19:40 <SamB> hehe
13:19:54 <SamB> who cares? we know what it *means*...
13:20:06 <eivuokko> Hence the smiley :)
13:26:11 <xinming> how to generate a tuple?
13:26:27 <xinming> hmm, just like, [1..5] will become (1,2,3,4,5)
13:27:38 <kolmodin> SamB: checked your email?
13:27:47 <palomer> xinming: you can't do that, the haskell type system is too weak
13:28:01 <SamB> kolmodin: no
13:28:25 <SamB> and I don't know how to get darcs to apply patches I get by gmail...
13:29:00 <palomer> xinming: and [1..5] becomes [1,2,3,4,5]
13:29:17 <soysauce> why would Word64 be significantly more expensive than Int64?
13:29:25 <xinming> palomer: yes, I know, So, I wish to write a function generate a tuple based on a list
13:29:34 <palomer> xinming: you can't!
13:29:44 <kolmodin> SamB: darcs apply patchfile         <-- I think it's like this
13:29:48 <xinming> palomer: hmm, How to convert a tuple into a list?
13:29:59 <mauke> xinming: you can't
13:30:01 <SamB> kolmodin: I think gmail messes up the line endings
13:30:17 <xinming> hmm, well, Why I ask this is because of the function show
13:30:20 <kolmodin> I attached the patch to the mail
13:30:22 <soysauce> Word64 seems to allocate 50% more data than Int64, and it takes nearly 2x the time for basic (+)
13:30:24 <palomer> xinming: that's different
13:30:27 <xinming> > show (1,2,3,4,5,6,7,8.9.10)
13:30:28 <lambdabot>  add an instance declaration for (Num (a -> b))
13:30:37 <SamB> xinming: case foo of (x,y) -> [x,y]
13:30:49 <mauke> > show (1,2,3,4,5,6,7,8,9,10)
13:30:49 <eivuokko> xinming, you know data?  Tuples are like data Tuple1 a = Tuple1 a, data Tuple2 a b = Tuple2 a b
13:30:50 <lambdabot> "(1,2,3,4,5,6,7,8,9,10)"
13:30:56 <SamB> xinming: or use TH
13:31:07 <mauke> hmm, I don't think that works in hugs
13:31:12 <kolmodin> gmail corrupts attached text files?
13:31:18 <SamB> oh, no, not in hugs ;-)
13:32:09 <SamB> hugs, being written in C, would have a hard time processing data in an algebraic datatype...
13:32:21 <SamB> I mean, as opposed to just implementing an ADT
13:32:55 <xinming> eivuokko: hmm, in my understanding, tuple is a data-struct like thing, And List is dynamic for its size
13:33:25 <palomer> every arity has a corresponding tuple type
13:34:08 <xinming> and the show function can show tuple "dynamic" I don't think It is done using fst. :-/
13:34:12 <eivuokko> xinming, Yeah.  We call data as ADT, algebraic datatype, for future reference.
13:35:30 <SamB> xinming: oh.
13:35:32 <SamB> I had an idea
13:35:59 <SamB> you could show the tuple and than replace the () with [] and then read it in again ;-)
13:36:14 <eivuokko> Uhhuh.
13:36:26 <flux__> :-)
13:36:41 <soysauce> @type GHC.Exts.==#
13:36:42 <lambdabot> parse error on input `GHC.Exts.==#'
13:36:42 <SamB> isn't that a strange way to do it?
13:36:47 <soysauce> oy.
13:36:57 <flux__> yes, too bad it is the simplest too?-o
13:36:57 <SamB> soysauce: you need -fglasgow exts to use # in an identifier
13:37:03 <soysauce> I know
13:37:10 <xinming> hmm, Do you mean show tuple is done by "internal" function?
13:37:12 <SamB> and @type doesn't supply it
13:37:16 <eivuokko> SamB, I'll be sure to use that in some future project! ;)
13:37:25 <soysauce> I'm not very familiar with lambdabot.
13:37:33 <SamB> maybe it used to
13:37:46 <soysauce> I'm confused and tired. I suspect that there is a correlation.
13:37:51 <SamB> but I recall there having been some issues with TH in the past.
13:37:54 <SamB> that is, exploits.
13:38:17 <SamB> like, if you look in the logs on cmeme, you can find where I had lambdabot print out dons's /etc/passwd ;-)
13:38:30 <SamB> I did not develop the exploit, though
13:38:33 <soysauce> is there any way to create an Int# constant? :(
13:38:43 <SamB> 1#
13:38:45 <soysauce> it's complaining about my writing x ==# 0
13:38:46 <soysauce> ah
13:39:01 <SamB> you can create a C string constant with "hello"#
13:39:02 <kolmodin> SamB: I'll just send the patches to jlouis if your gmail gives you a hard time
13:39:04 <soysauce> wow, that is ugly.
13:39:05 <soysauce> oh, neat
13:39:08 <SamB> };->
13:39:43 <SamB> kolmodin: do you have an httpd?
13:39:57 <soysauce> Couldn't match `Int#' against `Int32#'
13:40:00 <JohnnyL> hey does anyone know if haskell is being used more for real world application, like web development?
13:40:02 <kolmodin> I can put it at chalmers
13:40:11 <SamB> soysauce: huh
13:40:13 <soysauce> and fromIntegral won't work since it's unboxed...
13:40:28 <SamB> soysauce: let me play with
13:40:32 <soysauce> ok
13:40:49 * SamB wishes for nth time that GHCi supported unboxed types
13:40:58 <soysauce> http://www.rafb.net/paste/results/tBuZaI27.html
13:41:02 <soysauce> it's the 4th that breaks
13:41:10 <eivuokko> case 1 of #i or so?
13:41:19 <soysauce> I don't know if Int32# even exists, but it doesn't seem to complain
13:41:19 <SamB> I# i#
13:41:24 <kolmodin> http://www.dtek.chalmers.se/~kolmodin/conjure-bencode.darcs-patch
13:41:26 <soysauce> what does I# do?
13:41:53 <SamB> soysauce: it is the dataconstructor for Int in GHC's implementation
13:41:58 <soysauce> ahh, ok
13:42:06 <soysauce> so I# 4# would do it
13:42:15 <soysauce> well, to get 4# :: Int32# I mean
13:42:25 <SamB> uh
13:42:37 <xinming> Is my question too easy please? :-/
13:42:54 <SamB> xinming: no, it isn't
13:42:57 <xinming> hmm, How to convert a tuple to a string then?
13:43:02 <SamB> show
13:43:06 <SamB> @type show
13:43:07 <lambdabot> forall a. (Show a) => a -> String
13:43:16 <xinming> But, I wanna know, how show is written. :-/
13:43:30 <SamB> xinming: hmm
13:43:37 <SamB> good question, for tuple types ;-)
13:43:51 <xinming> hmm, Maybe this is in advanced topic. :-/
13:43:58 <SamB> not really
13:44:02 <Cale> hm?
13:44:13 <SamB> just that I'm not sure it uses "deriving (Show)"
13:44:34 <Cale> what uses deriving Show, sorry?
13:45:00 <Cale> I'm pretty sure the show instance for tuples is either handcoded or TH generated.
13:45:23 <SamB> Cale: I'm looking to see, anyways ;-)
13:45:57 <eivuokko> Well, onlinereport has example for pair and says that rest are similar.
13:46:04 <xinming> if it can't be written in haskell itself. then I give up. some parts need to be built-in I know.
13:46:25 <eivuokko> xinming, it can be.
13:46:39 <SamB> data (,) a b = (,) a b deriving (Eq, Ord)
13:46:46 <soysauce> ohh this is neat, GHC.Exts.Array# is what I *really* wanted to use before
13:46:49 <xinming> for pair and triple...
13:46:55 <Cale> xinming: you could write a simple version like show (a,b) = concat ["(",show a,",",show b,")"]
13:47:00 * soysauce proceeds to shoot self in the foot with unboxed types...and loves every moment
13:47:11 <SamB> aand... it looks suspiciously as if Show is hardwired!
13:47:25 <eivuokko> Hmm
13:47:38 <palomer> when was the last time you guys used _|_ in releasable code?
13:47:38 <SamB> on tuple types, I mean
13:47:47 <xinming> Cale: If a tuple is over 100 type, will you hand-code all of these situation?
13:47:57 * SamB asks for a second opinion
13:48:05 <eivuokko> Uhm, that means tuples can be unpacked in ghc?
13:48:06 <SamB> oh, wait
13:48:21 <Cale> xinming: you never see tuples larger than 2 or 3 elements long in Haskell code.
13:48:28 <SamB> after doing "show (1,2)" I get better info
13:48:36 <Cale> xinming: but yes
13:48:41 <SamB> its in GHC.Show
13:49:04 <Cale> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/GHC/Show.lhs?rev=1.13
13:49:06 <Cale> yes
13:49:08 <xinming> Cale: I am looking for the ultimate version. ;-)
13:49:13 * SamB doesn't like that GHC.Show would import types defined in Data.Tuple
13:49:19 <Cale> can't be written in Haskell
13:49:29 <Cale> You could write one with Template Haskell
13:49:36 <Cale> or Data.Generics perhaps
13:49:37 <sieni> xinming: if you actually want long tuples, then you might want to consider some lisp variant
13:49:57 <SamB> its hardcoded, apparantly
13:50:06 <SamB> er. *hand
13:50:14 <SamB> in GHC.Show
13:50:26 <Cale> yeah, I posted the link :)
13:50:27 <SamB> well, they have a nice utility function called "show_tuple"
13:50:31 <xinming> then, so as In hugs,
13:50:43 <SamB> oh
13:50:49 <SamB> well, it was so long
13:50:59 <sieni> (if you actually want to circumvent the type checking for list types etc.)
13:51:58 <Cale> You can use existential types or dynamic typing to get around the fact that lists can only have one kind of element, but this will obviously restrict what you can do.
13:52:07 <SamB> anyways, now that we have concluded that the implementation of Show for tuples is special only in that the compiler doesn't know how to do it without help, we can move on ;-)
13:52:55 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
13:53:01 <SamB> > let _|_ = _|_ in _|_
13:53:02 <lambdabot>  parse error on input `in'
13:53:03 <Cale> for dynamic typing
13:53:14 <Cale> > let loop = loop in loop
13:53:15 <lambdabot> Add a type signature
13:53:18 <Cale> > let loop = loop in loop :: Int
13:53:19 <lambdabot> Loop
13:54:38 * SamB NEVER uses _|_ in code
13:54:50 * SamB might consider using undefined, though
13:54:59 <Cale> undefined is bottom
13:56:08 <palomer> if your tuple has more than 3 elements, use a record
13:56:13 <palomer> (btw, does haskell have records?)
13:56:16 <Cale> yes
13:56:28 <Cale> well, it has algebraic data types with some syntax sugar
13:56:36 <palomer> yeah, that's what I was thinking
13:56:46 <palomer> so no records per say
13:56:50 <SamB> palomer: heh
13:57:07 <SamB> palomer: your suggestion is still good ;-)
13:57:08 <Cale> per se
13:57:26 <palomer> I suggested something?
13:57:30 <kolmodin> SamB: do you push directly to the darcs repo?
13:57:46 <SamB> kolmodin: nope
13:58:02 <SamB> did I forget to tell you to go ahead and send to jlouis?
13:58:31 <kolmodin> yeah... :)
13:58:43 <SamB> oops
13:58:55 <kolmodin> no harm done
14:00:05 <SamB> shouldn't you have done the QC before doing the faster implementation?
14:00:39 <SamB> I mean, not that it makes the slightest difference now ;-)
14:01:11 <SamB> musasabi: hey, where are those patches you promised me?
14:02:33 <kolmodin> I did write QC before the faster implementation, might not recorded it in that order though
14:02:58 <SamB> ah
14:03:08 <SamB> or I can't read times
14:04:28 <Cale> Well, at least you can read plus
14:05:39 <SamB> times as in measures of chronality
14:07:38 <SamB> hmm, I might have more luck with patch bundles if they were attachments...
14:07:42 <Cale> I know :)
14:08:39 <sieni> My boss (who is 4 years younger than me) gave me a quite funny birthday congratulation: so you are not anymore a hexadecimal teenager (it was my 32nd birthday less than a month ago)
14:09:00 <dcoutts_> boegel, the Gtk2Hs HaskLS port runs on Windows. I had to make a modification since it seems that the Win32 implementation of OpenGL does not support display lists.
14:09:24 <eivuokko> Hmmm.
14:09:31 <eivuokko> That'd be fairly wierd
14:09:32 <Cale> sieni: :)
14:09:35 <dcoutts_> boegel, interestingly the original version would not run on windows since windows does not comut with GLUT by default
14:10:10 <dcoutts_> boegel, microsoft only supply opengl32.dll and glu32.dll by default. No glut32.dll.
14:10:43 <SamB> maybe you are supposed to statically link GLUT?
14:11:47 <SamB> actually, apparantly you can use unboxed ints in GHCi
14:12:01 <SamB> but they of course do not instantiate Show :-(
14:14:31 <palomer> I wish java had tuples!
14:14:38 <palomer> what kind of screwed up language doesn't have tuples?
14:16:31 <SamB> palomer: C, C++, Java, VB, maybe even C#...
14:16:35 <Cale> palomer: if they added them, they'd probably add them in some stupid way with verbose syntax, making it so much trouble to get a tuple in the first place that nobody would ever use them.
14:17:26 <SamB> Cale: you can't call it a tuple if you don't use parentheses and commas, can you?
14:17:59 <dcoutts_> Cale, heh, yeah. In C++ they added pair<Foo,Bar>(a,b)
14:18:06 <palomer> Pair isn't so bad
14:18:10 <Cale> dcoutts: yes! like that
14:18:11 <eivuokko> In C++ you also have boost::tuple
14:18:14 <palomer> but java has _nothing_
14:19:13 <SamB> Cale: that doesn't look so bad that nobody would use them
14:19:23 <Cale> SamB: well, perhaps not quite
14:19:50 <Cale> Could be made a little worse I suppose :)
14:19:53 <SamB> probably the reason there is no Boost for Java is that Java doesn't have a turing-complete type system
14:21:06 <palomer> SamB: turing complete type system? what the hell is that:O!
14:21:11 <Cale> What you'd get in Java is some pair object with a constructor that takes two parameters, but you have to cast to Object first, and then back from Object when you're getting the elements out with the first and second methods.
14:21:21 <palomer> Cale: not with generics
14:21:47 <Cale> Perhaps, I haven't used Java since 1.1 or something.
14:21:48 <SamB> palomer: well, C++'s templates are turing complete
14:22:23 <Cale> Does Java have parametric polymorphism yet?
14:22:23 <palomer> java has templates now
14:22:24 <SamB> and if you allow overlapping instances, Haskell's type classes are too...
14:22:33 <Cale> ah, templates
14:22:49 <SamB> palomer: are they turing complete?
14:22:59 <Philippa_> no, they're very deliberately not
14:23:03 <eivuokko> SamB, they are not.
14:23:06 <SamB> hehe
14:23:07 <palomer> SamB: what does that mean??
14:23:12 <SamB> Philippa_: why is that?
14:23:21 <SamB> palomer: it means they can't compute anything
14:23:25 <SamB> C++'s can
14:23:28 <Philippa_> palomer: it means "can do everything any other computer can modulo IO"
14:23:43 <Philippa_> SamB: termination is good
14:23:51 <SamB> Philippa_: bah!
14:23:52 <Cale> any Turing machine, anyway :)
14:24:01 <palomer> oh, I see, you can think of the type system as a programming language
14:24:02 <SamB> who needs termination in the compiler?
14:24:02 <Philippa_> Cale: like I said, modulo IO
14:24:12 <SamB> they always pass around bytecode anyways!
14:24:17 <Philippa_> and also modulo finite storage if you wanna be picky
14:24:17 <palomer> SamB: the C++ compiler may not terminate?
14:24:19 <palomer> that's insane!
14:24:44 <Philippa_> yeah, it was an accident
14:24:54 <eivuokko> palomer, Yes, it is possible to express that with C++ templates.  In practice compilers abort early.
14:25:00 <SamB> palomer: it wouldn't be called turing complete if it didn't have the halting problem!
14:25:01 <Philippa_> a useful one sometimes, but you can sure as hell tell it wasn't intentional
14:25:08 <Cale> palomer: my friend wrote a compile time fractal generator
14:25:25 <Cale> In the C++ template system
14:25:46 <zamez> sick
14:26:01 <palomer> nuts!
14:26:30 <Cale> It's sort of nice to have a turing complete type system, once you get past the obvious downsides.
14:26:41 * sieni thinks that c++ templates are really strange
14:27:01 <palomer> in the future, all compilers will not be turing complete
14:27:03 <SamB> would boost be possible without one?
14:27:08 <zamez> they should have just made it dynamically typed instead
14:27:08 <eivuokko> Ehm
14:27:10 <SamB> palomer: you must be kidding
14:27:18 <Cale> Even if you miss Turing completeness, it's easy to end up with a type system in which certain programs take a ridiculously long time to typecheck.
14:27:19 <palomer> SamB: I'm talking way in the future
14:27:24 <palomer> by that time we'll all have 14 digits
14:27:35 <eivuokko> SamB, some part of boost could be done without templates, with limited functionality or repetition or code generation
14:27:36 <Cale> You're basically proving theorems about the program, that's hard to do.
14:28:08 <palomer> silly unintuitive theorems though
14:28:10 <SamB> GHC's template system is intentionally turing complete, in that it runs Haskell code at compile time to expand the templates ;-)
14:29:09 <SamB> Cale: did you see joelr's explosion which seemed to be in the typechecker?
14:29:26 <Cale> SamB: I think so
14:29:33 <SamB> he had an newtype of an HList of unholy size, and was trying to derive Show for it
14:29:39 <Cale> yeah
14:30:13 <Cale> something like 250 fields :)
14:30:14 <SamB> I really don't see why that has to happen...
14:30:19 <SamB> Cale: 250!
14:30:23 <eivuokko> Huh
14:30:26 <Cale> wasn't it?
14:30:35 <eivuokko> Why so many?
14:30:36 <Cale> I can't recall
14:30:37 <SamB> the one he demonstrated was more like 30
14:30:43 <SamB> iirc
14:30:45 <Cale> ah, okay, that's saner
14:31:00 <SamB> at least, GHC seemed to think it was unholy ;-)
14:31:20 <Cale> 250 isn't an unreasonable length for a list
14:31:44 <eivuokko> Hmmm.  It actually really isn't, if you want to compute something.
14:31:46 <SamB> yeah, but an HList is totally different, isn't it?
14:32:15 <Cale> It's awfully long when it comes to all the work that goes into proving that each of the elements is used in a typesafe way.
14:33:04 <Cale> An HList is basically a bunch of nested pairs, which isn't far from what a lisp list is.
14:33:19 <Cale> but it's statically typed
14:33:33 <SamB> yeah, I know ;-)
14:37:40 <palomer> 250? that's nothing
14:46:45 <kombinator> guys, have you seen that paper on ltu several days ago about extensible records?
14:47:08 <kombinator> could records like that replace HList in most places?
14:48:44 <kombinator> http://lambda-the-ultimate.org/node/view/1119
14:51:19 <exequor> haskell i s\hit]
14:51:35 <palomer> haskell is a hit?
14:51:45 <exequor> yeah
14:52:32 <exequor> u use it?
14:53:01 <exequor> cuz haskell sucks compared to visual basic
14:53:03 <xs> exequor: no, we just like the name.
14:53:37 <exequor> functional languages ewwwww
14:54:22 <haskellsucks> yea
14:54:50 <malcolm> Ken Anderson, didn't he create Thunderbirds?
14:55:23 <xs> gerry anderson?
14:55:33 <malcolm> oops, yeah
14:56:12 <haskellsucks> i'm writing an argumentitve essay on why people shud use c++ instead of haskell
14:56:17 <haskellsucks> prove me wrong some1
14:56:42 <haskellsucks> no1?
14:57:04 * Lemmih looks around for an op.
14:57:07 <malcolm> just saying "haskell sux" doesn't require much in the way of rebuttal.  How about "no it doesn't".  That should just about cover it.
14:57:22 <fworp> 'infinity'
14:57:25 <haskellrulez> I do not believe that a shorter or more correct implementation of the sha2 suite of algorithms than the haskell one I'm developing exists
14:57:51 <haskellsucks> but
14:57:52 <haskellrulez> from spec -> Haskell code is nearly one to one
14:58:03 <haskellsucks> it is?
14:58:12 <whatishaskell> is haskell anything like php?
14:58:12 <haskellrulez> and will be as fast or faster than C when it's done
14:58:38 <haskellrulez> and then I can prove properties about it's termination and runtime, and not just pass those silly statistical validation tests
14:58:39 <eivuokko> Lemmih, I would try to patch the sdl bindings to support Windows, but there is still some wierd errors, and I forgot exact way it worked "sort of" once.
14:58:41 <haskellrulez> heh, no
14:58:43 <fworp> yes, its got an h in its name
14:58:52 <haskellrulez> fworp: ha
14:59:00 <haskellsucks> hmm
14:59:03 <haskellsucks> interesting
14:59:09 <eivuokko> Lemmih, I don't really understand how sdl vs mingw vs ghc libraries somehow don't work together...undefined WinMain
14:59:09 <whatishaskell> will haskell let me write html programs?
14:59:16 <sh10151> :-D
14:59:25 <haskellrulez> if you aren't into heavy math or functional programming, it may not be for you
14:59:31 <haskellsucks> o
14:59:34 <eivuokko> Lemmih, Just FYI if someone asks, not really easy to use in Windows.
14:59:43 <newlightonhaskel> yea
14:59:49 <sieni> haskellsucks: at least you can verify siteswaps:
15:00:04 <xs> unfold is a generalised scanl?
15:00:06 <haskellisforn00b> haskell sux! It designed to teach programming to idiots! Stupid begin...end, it's wirthless!
15:00:13 <sieni> http://www.hurmio.org/~ville/SiteswapValidator2.hs
15:00:17 <Philippa> ;-)
15:00:22 <sh10151> i don't get the haskell == heavy math association
15:00:32 <haskellrulez> seeing as how I'm into algrebra and group theory, and have been a lisp user for 20+ years, haskell is like heaven
15:01:00 <haskellrulez> you can code up just about all non-stateful mathematical equations directly as haskell...which was a design goal back in the day
15:01:26 <sh10151> working mathematicians don't care much about abstract algebra, near as i can tell
15:01:26 <integral> and stateful...
15:01:39 * SamB hasn't even been alive for 20+ years, but still thinks haskell is like heaven
15:01:39 <Lemmih> eivuokko: oki.
15:01:47 <sh10151> heh
15:01:54 <integral> sh10151: even algebraicists?
15:01:56 <SamB> sh10151: which ones?
15:02:06 <SamB> there are a lot of branches, you know...
15:02:28 <sh10151> SamB: the ones that run the mathematics departments in US higher education
15:02:32 <haskellrulez> mathematicians are horribly narrowly specialized these days
15:02:52 <sh10151> i guess they maybe don't count as working
15:03:17 <sh10151> but then real "working" mathematicians would probably be doing applied mathematics anyway
15:03:25 <SamB> ah. hmm. I know someone who did that.
15:03:30 <sh10151> which neither algebraicists nor department chairs care about
15:03:37 <haskellrulez> I just switch from a mathematics to computational linguistics major
15:03:40 <Philippa> I've only ever seen abstract algebra taught to undergrads doing maths or physics
15:03:47 <SamB> and I think he probably knows abstract algebra
15:04:00 <sh10151> oh sure, there's a course in it
15:04:05 <haskellrulez> group theorists and topologists do abract algebra
15:04:05 <sh10151> but no one cares
15:04:15 <sh10151> kind of like operating systems classes
15:04:50 <haskellrulez> I loathe continuous mathematics, and just flamed out of vector calc, hence the major switch
15:04:51 <newlightonhaskel> compress::[Char]->[Char]
15:04:51 <newlightonhaskel> compress s
15:04:51 <newlightonhaskel>            |s == [] =""
15:04:51 <newlightonhaskel>            |otherwise = getWord (head s) (tail s) ("")
15:04:51 <newlightonhaskel>                       where getWord::Char->[Char]->[Char]->[Char]
15:04:52 <newlightonhaskel>                             getWord h t w
15:04:54 <newlightonhaskel>                                            |t == [] = checkLibrary (w ++ [h])
15:04:56 <newlightonhaskel>                                            |h /= ' ' = getWord (head t) (tail t) (w++[h])
15:04:58 <newlightonhaskel>                                            |h == ' ' = checkLibrary w ++ [h] ++ compress t
15:04:58 <sh10151> so you have amoeba or some random microkernel, woo, now do your work on this WinXP machine...
15:05:00 <newlightonhaskel> checkLibrary::[Char]->[Char]
15:05:02 <newlightonhaskel> checkLibrary c
15:05:04 <newlightonhaskel>           |c == "the" = "$t"
15:05:06 <newlightonhaskel>           |c == "and" = "$a"
15:05:08 <newlightonhaskel>           |c == "but" = "$b"
15:05:10 <newlightonhaskel>           |c == "other" = "$o"
15:05:12 <newlightonhaskel>           |c == "bad" = "$b2"
15:05:14 <newlightonhaskel>           |otherwise = c
15:05:16 <newlightonhaskel> i need help
15:05:18 <newlightonhaskel> with this compression
15:05:20 <newlightonhaskel> problem
15:07:15 <newlightonhaskel> ?
15:07:16 <newlightonhaskel> ?
15:07:19 <newlightonhaskel> n e 1
15:08:41 <malcolm> newlightonhaskel: so tell us what the problem is
15:10:13 <newlightonhaskel> i have to compress an email
15:10:20 <newlightonhaskel> so i have a library
15:10:41 <newlightonhaskel> of commonly used english words
15:11:04 <newlightonhaskel> that returns a character representing that word
15:12:30 <newlightonhaskel> and it goes through a file
15:12:45 <malcolm> newlightonhaskel: have you found the Prelude functions 'words' and 'unwords'?  They should help.
15:13:00 <newlightonhaskel> Prelude functions?
15:13:13 <malcolm> @where Prelude
15:13:13 <lambdabot> I know nothing about prelude.
15:13:15 <newlightonhaskel> unwords
15:13:22 <newlightonhaskel> wat do they do
15:14:09 <malcolm> newlightonhaskel: 'words' takes a string and splits it up into words at the space/tab/newline characters.
15:14:21 <malcolm> newlightonhaskel: 'unwords' does the reverse.
15:14:46 <newlightonhaskel> ok
15:15:38 <ndm> @index Prelude.words
15:15:39 <lambdabot> bzzt
15:15:44 <ndm> @docs Prelude.words
15:15:45 <lambdabot> Prelude.words not available
15:15:48 <SamB> > words "fourscore and seven years ago"
15:15:50 <lambdabot> ["fourscore","and","seven","years","ago"]
15:17:31 <malcolm> newlightonhaskel: so you can simplify your code to something like:  compress = unwords . checkLibrary . words
15:17:38 <palomer> @2+2
15:17:38 <lambdabot> Unknown command, try @listcommands.
15:17:42 <palomer> @listcommands
15:17:43 <lambdabot> use listcommands [module|command], please. Modules are:
15:17:43 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
15:17:43 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
15:17:43 <lambdabot> topic type version vixen where
15:18:14 <palomer> @vixen
15:18:15 <lambdabot> first you tell me.
15:18:19 <palomer> @vixen hello
15:18:20 <lambdabot> how're you?
15:27:47 <JohnnyL> @karma
15:27:48 <lambdabot> You have a karma of 0
15:31:31 <xinming> @pl 
15:31:32 <lambdabot> (line 1, column 1):
15:31:32 <lambdabot> unexpected end of input
15:31:32 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
15:31:32 <lambdabot> expression
15:31:41 <xinming> @pl (\x -> "title: " ++ x ++ "\n")
15:31:42 <lambdabot> ("title: " ++) . (++ "\n")
15:32:27 <xinming> where to find this full service bot?
15:32:48 <xinming> found it. :-)
16:06:32 <Frederick> yo Cale are you around?
16:35:13 <dons> @yow
16:35:13 <lambdabot> Has everybody got HALVAH spread all over their ANKLES??
16:36:32 <eivuokko> I think I am cursed.  Now I got even stable branch cvs ghc crash on me
16:36:55 <joelr1> Cale: ping
16:38:06 <lisppaste2> joelr1 pasted "bad-ass lazy eval is biting me!" at http://paste.lisp.org/display/13750
16:38:11 <joelr1> help!
16:38:16 <dons> heh
16:38:37 <joelr1> why is it that when i comment out the traces things stop working?!
16:38:48 <joelr1> repo at http://test.wagerlabs.com/postmortem/
16:39:58 <dons> they are forcing the computation, most likely
16:40:18 <joelr1> dons: that much i gather but i thought that all computations were evaluated in the IO monad
16:40:21 <joelr1> i.e. that it was strict
16:40:25 <Frederick> SamB, yo
16:40:26 <joelr1> am i wrong?
16:40:32 <dons> it's not strict, it's sequenced.
16:40:38 <Frederick> Cale, are you around?
16:40:43 <joelr1> so what does that mean in the context of my paste?
16:40:44 <dons> but you can still force the values joel.
16:41:13 <joelr1> dons: does recursing into shake not force the values?
16:41:50 <dons> hmm. 
16:42:37 <joelr1> dons: i guess not. how do i force the values to be evaluated then?
16:42:58 <dons> you have two options immediately: you can use Control.Exception.evaluate to eval any pure computatoin, and you can use `seq` to eval any value
16:43:14 <joelr1> @index seq
16:43:15 <lambdabot> Prelude, Control.Parallel
16:43:25 <dons> here's a real world example from scomesome code I wrote this year:
16:43:26 <dons>     do mvar <- newEmptyMVar
16:43:26 <dons>        tid1 <- forkIO $ do x <- expensive
16:43:26 <dons>                            x `seq` putMVar mvar (Just x)
16:43:26 <dons>        tid2 <- forkIO $ do threadDelay (millis * 1000)
16:43:28 <dons>                            putMVar mvar Nothing
16:43:31 <dons>        res <- takeMVar mvar
16:43:36 <joelr1> haha
16:43:46 <joelr1> my best friend the timeout combinator
16:43:48 <dons> I *had* to seq the 'x' otherwise the expensive computatoin would float out and not be demanded until later.
16:44:00 <dons> and the timeout would not run
16:44:18 <Spark> does anyone know william harrison?
16:44:26 <joelr1> dons: wierd. i would have thought that putting x into the mvar would have forced it
16:44:30 <joelr1> dons: but i guess not
16:44:43 <joelr1> dons: i suppose that's not using it, it's storing it away for later use
16:44:43 <dons> MVars hold normal haskell values, and can thus be unevaluated expressions
16:44:48 <dons> yep
16:45:08 <dons> for some uses you may even want to use DeepSeq
16:45:21 <dons> which is a recursive descent version of seq, basically.
16:45:27 <dons> it evaluates everything i na structure.
16:45:34 <dons> lambdabot needs it for some of the network code.
16:45:45 <joelr1> @hoogle seq
16:45:46 <lambdabot> Control.Parallel.seq :: a -> b -> b
16:45:46 <lambdabot> Prelude.seq :: a -> b -> b
16:45:46 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
16:46:02 <dons> seq is just in the Prelude.
16:46:14 <joelr1> dons: so it takes... what exactly?
16:46:18 <dons> here's DeepSeq: http://www.cse.unsw.edu.au/~dons/code/lambdabot/DeepSeq.hs  
16:46:22 <dons> @type seq
16:46:22 <lambdabot> forall b a. a -> b -> b
16:46:23 <joelr1> x `seq` y
16:46:31 <joelr1> x is the value to be evaluated and y is?
16:46:37 <joelr1> it's not clear from the signature
16:46:39 <dons> > let x = 1 + 2 in x `seq` 3
16:46:40 <lambdabot> 3
16:46:53 <dons> it just forces the expression to be evaluated to normal form
16:47:00 <dons> so it's a side effect(!)
16:47:17 <joelr1> dons: so it does not matter what you have on the right then?
16:47:29 <joelr1> > let x = 1 + 2 in x `seq` 5
16:47:30 <lambdabot> 5
16:47:33 <joelr1> hmm
16:47:33 <dons> no usually it is the rest of the ccomputatoin
16:48:12 <dons> or in do notation you might even write: x <- something ; x `seq` return () ; ....
16:48:31 <int-e> let x = error "foo" in x `seq` 5
16:48:34 <int-e> > let x = error "foo" in x `seq` 5
16:48:35 <lambdabot> foo
16:48:41 <dons> here's another example from some code I wrote yesterday:
16:48:46 <dons>     let ls = map joinPath . sort . filter notEdge $! ls_raw
16:48:46 <dons>     ls `seq` return ()
16:49:07 <dons>     (fs,ds) <- partition ls
16:49:11 <joelr1> dons: interesting
16:49:23 <joelr1> dons: btw, i'm reproducing that crash
16:49:24 <dons> so also I'm using $! (which is another form of eqseq)
16:49:28 <dons> s/eq//
16:49:40 <dons> @type ($!)
16:49:40 <lambdabot> forall b a. (a -> b) -> a -> b
16:52:01 <Frederick> SamB, Cale are any of you around?
16:53:10 <dons> joelr1, have you experimented with either ghcprof or hp2ps?
16:53:35 <dons> btw? I've just been playing with hp2ps, but am wondering if ghcprof would be more fun.
16:53:36 <joelr1> sure
16:53:42 <joelr1> but
16:53:51 <joelr1> no ghcprof, just -prof
16:53:55 <joelr1> are they the same?
16:54:14 <dons> nope, ghcprof does the nice graphical heap profiles
16:54:16 <dons> apparently.
16:54:22 <dons> but I'm yet to install it. here goes then.
16:55:04 <joelr1> cool
16:55:29 <Cale> Frederick: a question?
16:55:34 <dons> "You can view the time and allocation profiling graph of your program graphically, using ghcprof"
16:56:23 <Frederick> Cale, yes, what should I read to understand / craft the algorithm we were discussing before? for the chomsky normal form
16:58:00 <joelr1> Cale: i got to reproduce the crash, wanna try?
16:58:28 <Cale> one sec :)
16:59:06 <joelr1> should i say that i'm happy? hmm... dunno. i have a hunch that linux people are not gonna reproduce the bug
16:59:10 <joelr1> dons: what's your platform?
16:59:20 <dons> openbsd
16:59:24 <joelr1> oh!
16:59:26 <dons> where the code!
16:59:36 <dons> let me try, let me try!!
16:59:38 <joelr1> dons: can you lend a hand? 
16:59:47 <dons> sure
16:59:50 <joelr1> darcs get http://test.wagerlabs.com/postmortem
16:59:57 <joelr1> project postmortem, get it? he ehe
17:00:15 <dons> now what do i do?
17:00:18 <dons> build it?
17:00:26 <joelr1> yep
17:00:40 <dons> once for Server and for Client?
17:00:56 <joelr1> build the client and the server, set your ulimit -n unlimited
17:00:56 <joelr1> or something like that
17:00:56 <joelr1> look att README
17:01:05 <dons> README?
17:01:14 <dons> no readme checked in.
17:01:36 <dons> $ ghc -O --make Server.hs   ok?
17:01:51 <joelr1> hmm
17:02:01 <Frederick> Cale, k
17:02:01 <joelr1> yes but -lssl -lcrypto
17:02:01 <dons> though I need some ssl lib linked in.
17:02:04 <Cale> okay
17:02:05 <dons> ah.
17:02:08 <int-e> -o Server, maybe, and -lssl :)
17:02:18 <dons> yep. works. int-e ;)
17:02:28 <Cale> Frederick: I wasn't talking about Chomsky normal form at any point, but perhaps I can help find a reference
17:02:45 <dons> joelr1, build. now how to run it?
17:02:46 <int-e> "unknown exception" ... fun.
17:02:51 <int-e> run server, then client
17:02:54 <int-e> I think :)
17:02:54 <joelr1> nono
17:02:59 <joelr1> pull the patches!
17:03:05 <Frederick> Cale, you werent talking about the normal form but about the step in the algorithm about finding equal productions
17:03:16 <joelr1> dons: ./server and ./client
17:03:20 <dons> ok.
17:04:17 <dons> so server ends with: 
17:04:17 <dons> 12:00:57: ThreadId 4: waitForBio: gotta wait a bit...
17:04:18 <dons> Server: unknown exception
17:04:21 <joelr1> int-e: pull the patches please
17:04:26 <dons> cleint with:
17:04:27 <joelr1> dons: that's not it
17:04:27 <dons> 12:00:57: ThreadId 4: waitForBio: gotta wait a bit...
17:04:27 <Cale> Frederick: not to the best of my knowledge, unless I was doing it in my sleep
17:04:27 <dons> Client: thread blocked indefinitely
17:04:31 <joelr1> what's happening?
17:04:45 <joelr1> dons: i put a whole bunch of patches into that repo
17:04:58 <Frederick> Cale, lemme read the channel logs
17:05:01 <Frederick> brb
17:05:07 <dons> did you give me the right repo url? paprika$ darcs  pull
17:05:07 <dons> Pulling from "http://test.wagerlabs.com/postmortem"...
17:05:08 <dons> No remote changes to pull in!
17:05:18 <int-e> same here.
17:05:21 <dons> $ darcs changes   
17:05:21 <dons> Sat Nov 19 01:52:41 EST 2005  joelr@well.com
17:05:21 <dons>   * base
17:05:34 <joelr1> darcs changes --repo=http://test.wagerlabs.com/postmortem
17:05:34 <joelr1> Fri Nov 18 14:52:41 GMT 2005  joelr@well.com
17:05:34 <joelr1>   * base
17:05:41 <joelr1> how do i push my patches?
17:05:49 <dons> darcs record?
17:05:59 <joelr1> dons: no, i did that
17:06:00 <dons> or do you need to push them into the postmortem repo?
17:06:09 <joelr1> yeah, into the remote repo
17:06:16 <dons> darcs push
17:06:16 <joelr1> i put darcs on the other end
17:06:24 <dons> with an ssh url
17:06:39 <Frederick> Cale, bah I cant find the page with the logs but the discussion was how to do a production like S -> ABC became something like AD where D -> BC
17:06:41 <joelr1> dons: ok, let me blow away the one at wagerlabs
17:06:46 <dons> i.e. darcs push dons@foo:code/secretprojecttodestroyjava
17:06:49 <joelr1> how do i copy mine over?
17:06:52 <Cale> Frederick: that makes sense
17:07:07 <Cale> http://www.cs.uiowa.edu/~rus/Courses/Theory/Notes/cfg3.pdf - this seems to have some information
17:07:22 <joelr1> dons: i'm an idiot :)
17:07:30 <joelr1> i have been pushing into the wrong repo
17:07:34 <joelr1> a sibling to public :D
17:07:35 <dons> ah ha!
17:07:39 <Cale> http://www.csee.umbc.edu/~squire/cs451_l16.html -- this has a description
17:08:19 <joelr1> int-e, dons,. give me a sec
17:09:11 <Frederick> Cale, thx a lot
17:09:34 <Frederick> I will read it up and then come back with questions tommorow (I got a champioship tommorow =/)
17:09:56 * joelr1 is pushing patches as we speak
17:11:07 <joelr1> dons: ping
17:11:50 <dons> ah, 7 patches
17:11:57 <joelr1> int-e: ping
17:12:03 <joelr1> right
17:12:04 <int-e> I see 6. hmm.
17:12:06 <joelr1> and a readme
17:12:11 <joelr1> and a crash
17:12:24 <joelr1> int-e: base is 7, the initial one
17:12:27 <dons> you should build with -O, btw. you do for you normal project, right?
17:12:29 <int-e> oh. ok
17:12:39 <int-e> 6 new ones, I should've said
17:12:43 <joelr1> dons: nope, it takes too long to build, via c and everything
17:12:58 <dons> server: user error (Pattern match failure in do expression at Server.hs:19:7-16)
17:13:12 <dons> (Just ctx) <- serverStartSSL "server.crt" "server.pem"
17:13:14 <dons>  is failing
17:14:56 <Cale> yeah, I get that too
17:16:15 <joelr1> dons: i build without -O since i'm not in production yet
17:16:15 <joelr1> dons: no certs? one sec
17:16:15 <joelr1> pushing
17:16:15 <joelr1> hey, i'm loving this :D
17:16:15 <joelr1> dons: i forgot the private key, give me a minute
17:16:17 <joelr1> my hosting provider is slow today :(
17:16:21 <joelr1> i'm very sorry guys, one minute
17:17:09 <dons> no worries. just wondering, since sometimes bugs only show up in -Onot, and disappear with -O
17:17:15 <dons> something to keep in mind, anyway
17:17:17 <joelr1> not this one
17:17:23 <joelr1> i don't think so
17:17:23 <dons> ok :)
17:17:27 <joelr1> ok
17:17:27 <joelr1> guys
17:17:28 <joelr1> pick it up
17:17:33 <joelr1> server.pem
17:17:50 <dons> got it.
17:18:32 * joelr1 is rubbing his palms in anticipation
17:18:56 <int-e> scroll!
17:19:03 <int-e> client: user error (trapEx: getHostByName: does not exist (no such host entry))
17:19:09 <dons> yeah, I get that.
17:19:14 <joelr1> umm?
17:19:20 <joelr1> i'm just connecting to localhsot
17:19:22 <joelr1> localhost
17:20:02 <joelr1>        h <- trapEx $ connectTo "localhost" (PortNumber 8080)
17:20:07 <joelr1> just that
17:20:08 <dons> yeah, I see.
17:20:31 <joelr1> int-e: i ought to remove the scrolling but i need to grasp `seq` before i do :)
17:21:15 <joelr1> int-e: it's the traces in SSL.hs, line 104 and 106. if i remove these then i need a seq in there
17:21:32 <joelr1> anybody got a crash yet?
17:21:34 <int-e> I have no clue why though.
17:21:46 <int-e> no crash yet, just a lot of failed connection attempts.
17:21:50 <dons> same here
17:21:59 <joelr1> int-e: no clue about what?
17:22:09 <int-e> joelr1: why you'd need a seq there
17:22:18 <joelr1> dons: i did not even pay attention to the connections, i just ran client in gdb and waited for that bus error
17:22:18 <dons> thought the server is saying: 12:18:59: ThreadId 38: Starting SSL handshake...
17:22:18 <dons> 12:18:59: ThreadId 1: Accepted new connection: {handle: <socket: 41>}
17:22:40 <dons> 12:19:17: ThreadId 1: Accepted new connection: {handle: <socket: 62>}
17:22:40 <dons> 12:19:20: ThreadId 60: acceptSSL: 0/5
17:22:43 <dons> 12:19:20: ThreadId 60: Starting SSL handshake...
17:22:53 <joelr1> int-e: because dons says so :-) and because if i remove the traces then err and done are not evaluated and therefore the sslConnect, etc. are not either
17:23:06 <int-e> 0/5 ... hmm. I get -1/2 there. -1 is bad, isn't it?
17:23:21 <joelr1> well, yes, it does that a few times
17:23:34 <joelr1> if you want to make sure it's working then just replace 5000 with 1 in client.hs
17:23:42 <dons> the server really thrashes the cpu around: 7848K 5904K run      -        1:19 95.85% server
17:23:43 <joelr1> and see if you get Handshake completed
17:23:58 <joelr1> dons: i welcome yer patches
17:24:05 <joelr1> but try it with 1 client first
17:24:32 <joelr1> Client.hs:25, replace 5000 with 1, run, make sure you see Handshake completed
17:24:52 <dons> got it: 12:21:33: ThreadId 3: Handshake completed
17:25:01 <dons> child ides with: 12:21:33: ThreadId 3: Handshake completed
17:25:01 <dons> client: thread blocked indefinitely
17:25:06 <joelr1> dons: this program does nothing but ssl  handshakes but it's representative of what i need to do which is run thousands of these
17:25:19 <dons> scary
17:25:43 <joelr1> dons: this means the algorithm is working and the logic is sound. you probably just need to put in the seq into that clientSSLSync so that it does not dump so much to stdout
17:25:47 <joelr1> and then run 5000 clients
17:25:50 <joelr1> what's scary?
17:26:05 <dons> "thousands of these" :S
17:26:06 <joelr1> the client thread blocking is... something i'm doing wrong
17:26:16 <joelr1> dons: well, yes, thousands of poker bots
17:26:42 <joelr1> dons: 10k per machine would be good
17:26:48 <joelr1> excellent in fact
17:27:11 <joelr1> btw
17:27:17 <dons> no crashes yet. with a value of 10 instead of 1, the client gives me lots of: 12:23:18: ThreadId 6: sslIsInitFinished: False
17:27:19 <joelr1> regarding the indefinite blocking
17:27:21 <dons> 12:23:18: ThreadId 7: sslConnect: -1/2
17:27:23 <dons> 12:23:18: ThreadId 8: sslConnect: -1/2
17:27:37 <joelr1> dons: that's fine, it needs to go through a few rounds of these for whatever reason
17:27:49 <joelr1> dons: and exchange SSL handshake packets
17:28:00 <joelr1> take a look at logger in Conc.hs
17:28:04 <joelr1> it uses getChanContents
17:28:12 <joelr1> for fun try to make it read and print each time
17:28:13 <dons> ah yes, I see, and then: client: thread blocked indefinitely
17:28:19 <joelr1> things should slow down SIGNIFICANTLY
17:28:21 <dons> which sounds like a MVar bug.
17:28:34 <int-e> hmm. with one client I get client: thread blocked indefinitely. SSL_accept returns -1 in the server though ...
17:28:38 <joelr1> whereas just reading with getChanContents makes things go smoothly
17:28:44 <joelr1> but hangs the client and the server
17:28:57 <joelr1> yes, yes, Conc.hs, logger
17:29:05 <joelr1> getChanContents never returns
17:29:16 <joelr1> or rather logger' never returns
17:29:24 <dons> does this even work: {-# NoInline parent #-}
17:29:29 <dons> shoudln't that be NOINLINE ?
17:29:45 <dons> and then also, should they be IORefs to MVars?
17:29:52 <joelr1> dons: possibly, i'm not sure. i think that's how it was in the Async Exceptions paper, NoInline
17:30:05 <joelr1> dons: what's that? IORef where?
17:30:16 <dons> all the global vars I can ever think of have the type: :: IORef (MVar ...)
17:30:26 <dons> or IORef a, for some type a
17:30:29 <joelr1> dons: well, that's from the GHC docs
17:30:45 <joelr1> dons: i think from the html docs for Control.Concurrent
17:31:24 <dons> ah, ok.
17:31:26 <dons> I see it.
17:32:27 <dons> and maybe you should be using the non-race versions of MVar code?
17:32:31 <dons> withMVar, modifyMVar ?
17:32:38 <dons> rather than separate take/puts
17:32:53 <dons> (though not sure if the Client is multithreaded?)
17:33:14 <joelr1> 3) "thread blocked indefinitely" is from getChanContents in Conc.hs (logger). Try replacing that with readChan and an immediate printout to see printouts slow down significantly and memory start to accumulate.
17:33:20 <joelr1> just updated the readme
17:33:21 <dons> I always use modifyMVar_, btw.
17:33:59 <joelr1> dons: the client is multithreaded in the sense that it runs 5000 threads. there's only one logger, though
17:34:05 <joelr1> i'm not using -threaded
17:34:12 <int-e> fun. without the traces I just got a broken pipe from the client (trying with 50 childs)
17:34:36 <joelr1> yep
17:34:56 <joelr1> as dons says, seq is needed there to force evaluation. which is what the traces do right now
17:35:02 <joelr1> Cale: you are kinda quiet ;)
17:35:16 <int-e> but the values are CInts from an IO computation - it makes no sense
17:35:42 <int-e> it seems much more likely to be a timing issue to me.
17:36:01 <joelr1> int-e: i guess this is gonna be an eye-opener for you :D
17:36:14 <int-e> 02:34:18: ThreadId 50: Handshake completed
17:36:22 <int-e> is anything more supposed to happen?
17:36:23 <Cale> yeah, and kinda distracted :)
17:36:23 <joelr1> int-e: i had the misconception that computations in the io monad were strict, for example
17:36:36 <joelr1> int-e: well, take a look at the README ;)
17:36:42 <joelr1> int-e: i bomb out on Mac OSX
17:36:51 <int-e> joelr1: well, it'd be different for a IO [a], say ...
17:36:57 * joelr1 just pushed a README patch
17:37:08 <joelr1> int-e: can't say
17:37:58 <joelr1> the other thing that i gotta figure out is which variant of timeout in Timeout.hs is the best one 
17:37:58 <int-e> joelr1: but in this case the C function has been called and the CInt value is there, there's nothing left to be evaluated. This is assuming that the FFI implementation conforms to the FFI spec.
17:38:17 <joelr1> int-e: i think it was backwards
17:38:31 <dons> int-e, you're right.
17:38:34 <joelr1> int-e: ghc sees that done or err are not being used and thus it does not call the FFI
17:38:36 <dons> I was assuming it was some lazy structure
17:38:48 <joelr1> that's my take on it, anyway
17:38:52 <dons> ah, but you definitely need to use the values
17:39:14 <joelr1> but can i make a suggestion? why don't you guys post these questions to haskell-cafe as well? if they need to be brought up
17:39:34 <joelr1> anybody got a crash yet?
17:39:41 <joelr1> or is this particular to mac osx?
17:40:10 <int-e> hmm. I guess this indicates that ghc is best supported on x86/Linux.
17:40:24 <dons> hmm. or openbsd.
17:40:28 <int-e> no crash yet, just mysterious broken pipes since I took out those traces.
17:40:30 <dons> which is, umm, just me.
17:40:34 <int-e> dons: I wouldn't know.
17:40:41 <joelr1> he
17:40:43 <dons> linux certainly.
17:40:49 <joelr1> maybe something having to do with PowerPC?
17:41:02 <joelr1> and that generated assembler?
17:41:16 <int-e> oh, that was a powerpc message, too?
17:41:31 <int-e> i.e. when compiling on powerpc.
17:41:58 * dons boggles at the ghcprof call graph
17:42:13 <joelr1> well, yes
17:42:21 <joelr1> macintel laptops are not out yet
17:42:40 <joelr1> but i feel vindicated in a way. i have been going bananas over this problem
17:42:48 <joelr1> i thought it was me
17:42:53 <joelr1> it could still be me
17:42:55 <joelr1> for example
17:43:02 <joelr1> i'm not freeing the SSL descriptors
17:43:25 <joelr1> but that should not make ghc crash, should it? unless ssl is corrupting memory somehow but then it's not doing it on linux
17:43:28 <joelr1> apparently :)
17:43:34 <int-e> ok, that could be a shortcoming in the assembly generator that - apparently it generated a big offset for an instruction that only supports 16 bit offsets. (such instructions don't exist on x86 ...)
17:43:54 <dons> could be the backend, does it make a difference if you try -fvia-C ?
17:43:56 <int-e> s/that/then/
17:44:03 <dons> or -O -fasm even?
17:44:36 * int-e is somehow stuck in an all-the-world-is-x86 view despite knowing better :/
17:44:48 <joelr1> dons: not for me
17:44:53 <joelr1> did not know about -fasm
17:44:54 <joelr1> what's that?
17:45:23 <int-e> fwiw, strace-ing the client program seems to get rid of the broken pipes as well. 
17:45:24 <dons> it forces use of the native code gen.
17:45:28 <dons> rather than the C backend
17:45:33 <dons> you get -fasm if you don't use -O
17:45:41 <dons> but if you want asm with -O, you need -fassm
17:45:48 <dons> otherwise you get -fvia-C
17:46:04 <joelr1> hmm
17:46:07 <joelr1> let me try
17:47:27 <musasabi> delete *.{o,hi} to get new ones built.
17:47:57 <joelr1> musasabi: touch *hs works too ;)
17:48:25 <joelr1> running -O -fasm-ed code
17:49:13 <int-e> or -no-recomp (which means: turn off the recompilation checker)
17:49:46 <joelr1> hmm
17:49:53 <joelr1> -O -fasm takes a while to crash
17:50:25 <int-e> hmm. I'm up to threadid 379 in the client.
17:51:18 <joelr1> int-e: you could be higher, a single logger prints to screen and everyone sends traces to it. i don't think it's behaving optimally
17:51:30 <joelr1> it stops for a while then starts scrolling again, etc
17:51:58 <int-e> joelr1: oh that explains the bursts of output then
17:52:03 <int-e> yep
17:52:44 <int-e> client: user error (trapEx: connect: timeout (Connection timed out)) ... we've seen that before
17:53:04 <joelr1> i crashed again, in a different place, just after starting up
17:54:56 <int-e> ugh. there are lots of connections in CLOSE_WAIT state.
17:55:32 <lisppaste2> joelr1 pasted "new crash dump" at http://paste.lisp.org/display/13754
17:55:50 <joelr1> dons: so -O -fasm did not help
17:57:31 <joelr1> i wonder, how do i make ghc keep these around?
17:57:40 <joelr1> the temp files
17:57:51 <dons> -keep-tmp-files
17:57:54 <joelr1> ghc15171.hc
17:57:56 <joelr1> ok
17:58:27 <int-e> connections: syn_recv 48 syn_sent 21 established 320 close_wait 75 fin_wait2 8
17:58:41 <int-e> (all to that 'webcache')
17:58:58 <dons> hey, profiling freaks, check out the great ghcprof graphs! really nice tool: http://www.cse.unsw.edu.au/~dons/images/graph.png
17:59:03 <joelr1> dons: i don't think -O takes with -fasm because it compiles much faster
17:59:06 <dons> @karma+ ghcprof
17:59:06 <lambdabot> ghcprof's karma raised to 1.
17:59:24 <dons> joelr1, you need to put -fasm after -O
17:59:30 <dons> but also, the native code gen is just way faster anyway
17:59:47 <joelr1> dons: i did that, -O -fasm
17:59:58 <dons> then you're just seeing the fast native code gen :)
18:00:10 <dons> you can check with -v4, see if gcc is being called or not
18:00:23 <joelr1> dons: also, i don't think it saved the temp files with -keep-tmp-files
18:00:27 <joelr1> --keep maybe>
18:00:31 <joelr1> ?
18:00:56 <int-e> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#keeping-intermediates
18:00:58 <dons> it's definitely "-keep-tmp-files"
18:01:01 <araujo> Hello.
18:01:05 <dons> but with -fasm you don't get .hc files!
18:01:11 <dons> only .s files
18:01:24 <joelr1> b
18:01:30 <araujo> There exist some buffer limitations for the function runInteractiveProcess?
18:01:34 <joelr1> ghc --make -debug Server.hs -o server -lssl -lcrypto -O -keep-tmp-files
18:01:37 <joelr1> no temp files
18:01:49 <int-e> joelr1: with recompiling everything?
18:01:56 <joelr1> yes, everything
18:02:08 <joelr1> you can use -C to just produce the C files apparently
18:02:46 <dons> guys, try ghcprof! it's really reeally good compared to reading .prof files
18:02:47 <int-e> oh. they will be in /tmp (usually)
18:03:10 <joelr1> that's there i was looking for them but they are not there
18:03:17 <joelr1> dons: it looks good, did you write that?
18:03:26 <araujo> It crashes when i try to run a command that read more than 1178 lines of a file.
18:03:45 <dons> joelr1, nope. standard ghc tool. just no one uses it much
18:03:52 <joelr1> ok
18:04:01 <araujo> Does that ring the bell for someone?
18:04:23 <dons> these buttons that colour the "heap usage criticla path" for example, are very spiffy
18:04:28 <dons> araujo, nope. 
18:04:29 <dons> why ?
18:04:33 <dons> are you losing output?
18:04:42 <araujo> dons, It does nothing dude
18:04:58 <dons> do you force the output?
18:05:04 <araujo> It freezes up, and the process goes to sleep.
18:05:05 * int-e wonders if those 1178 lines translate to an interesting number of bytes
18:05:25 <araujo> dons, mm.. no i dont.
18:05:29 <dons> SimonM (and dons) recommend:     forkIO (Control.Exception.evaluate (length output) >> return ())
18:05:45 <dons> before calling     Control.Exception.catch (waitForProcess pid) (\_ -> return ExitSuccess)
18:05:54 <araujo> Let's see.....
18:06:18 <dons> in fact, all this can be found in: http://www.cse.unsw.edu.au/~dons/code/lambdabot/PosixCompat.hs
18:06:22 <dons> which you may steal ;)
18:06:29 <araujo> hah
18:07:53 <araujo> Thanks dons , i'll give it a try.
18:08:05 * araujo goes to look for caffeine
18:09:00 <int-e> of course, if you never read from the output, then it'll block after the buffer of the pipe fills up - POSIX guarantees 512 bytes (IIRC) for that and the number I'd expect for Linux (on x86) was 4096, but this may be too low.
18:14:47 <joelr1> dons: no crashes for you, right? 
18:14:56 <joelr1> int-e: and no crashes for you either?
18:15:05 <Axioplase> Hi
18:15:27 <int-e> joelr1: right. server and client running smoothly (and without those trace calls) for about half an hour.
18:15:49 <int-e> joelr1: (there still is that broken pipe problem lurking, but in this run it hasn't happened so far)
18:15:56 <Axioplase> Sorry for the newb question, but what is haskell for "type Plot = CPlot of (int,int)" ?
18:16:17 <joelr1> ok
18:16:33 <Axioplase> CPlot of int*int  for a better caml like syntax..
18:16:34 <dons> joelr1, no crashes..
18:16:42 <joelr1> darn
18:16:56 <int-e> Axioplase: data Plot = CPlot (Int, Int)  I'd guess
18:17:22 <joelr1> try running the thing a few times, maybe? it doesn't need to run for hours 
18:17:54 <Axioplase> int-e: well, I have data Point = CPlot (Num,Num)  but it doesn't seem to like Num...
18:18:01 <int-e> joelr1: I was curious if it could run to the end with 5000 children, but I guess I'm not patient enough
18:18:09 <joelr1> int-e: ah!
18:18:16 <int-e> Axioplase: Num is not a type. It's a type class, with types as instances
18:18:18 <joelr1> int-e: but it will hang anyways
18:18:27 <joelr1> unless you fix logger to use readChan
18:18:50 <Axioplase> int-e: ho. Got it.
18:18:59 <int-e> Axioplase: if you want something that works for different Num instances, you can use
18:19:15 <int-e> Axioplase: data Num a => Point a = CPlot (a, a)
18:20:34 <int-e> Axioplase: and then use Point Int for a ... named pair of Ints.
18:22:08 <int-e> Axioplase: in the case were you just want a label for another type you can also use newtype Point = CPlot (Int, Int)  (this works very much like a data declaration with only one alternative. it actually defines a type alias though; the difference is rather subtle.)
18:22:11 <araujo> dons, seems not working :-(
18:22:24 <Axioplase> int-e: thanks. btw, I can't fine any comment in haskell in the sites I'm reading. what is comment in haskell ?
18:22:37 <int-e> -- text
18:22:44 <Axioplase> great. thanks
18:22:49 <int-e> or {- text -} (if you prefer multiline comments)
18:23:08 <int-e> -- is a comment up to the end of the line
18:25:08 <dons> araujo, some other problem then?
18:27:31 <lisppaste2> araujo pasted "IO problem" at http://paste.lisp.org/display/13755
18:28:27 <araujo> Ok, that's the code with the problem.
18:29:02 <int-e> araujo: that doesn't compile, does it?
18:29:11 <araujo> dons, If you can test it, try something like, funcProcess "cat file" , with a file with >1178 lines
18:29:14 <araujo> int-e, yes it does
18:29:53 <araujo> oh, dam, sorry
18:30:00 <araujo> Change hFlush with length
18:30:24 * araujo following dons's advices
18:30:55 <seafood> Does anyone know the difference between the terms distfix and mixfix? They are both describe fixity.
18:31:12 <seafood> The both describe fixity.
18:31:24 <seafood> (Can't type straight today)
18:35:02 <int-e> seafood: you should really try google first. examples I've found (from C language): mixfix: a[b] distfix: a ? b : c
18:35:22 <seafood> I found a definition for distfix which was more than adequate.
18:35:26 <seafood> But I couldn't find one for mixfix.
18:35:26 <dons> hhaven't heard of distfiix before.
18:36:01 * int-e hadn't heard of either of these terms
18:36:13 <seafood> I think they're the same thing.
18:36:20 <dons> yeah, I reckon
18:36:24 <fworp> me too
18:36:27 <dons> at least the above code suggests so
18:36:46 <seafood> The FOLDOC definition is: A description of an operator represented by multiple symbols before, between, and/or after the arguments.
18:36:51 <seafood> (That's for distfix)
18:36:53 <bosie> i have a rather mathemtic question this time ;)
18:36:53 <bosie> is "boosie" a permutation of "bosie" ?
18:37:00 <dons> @foldoc distfix
18:37:02 <lambdabot> *** "distfix" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)
18:37:02 <lambdabot> "
18:37:02 <lambdabot> distfix
18:37:02 <lambdabot>  
18:37:02 <lambdabot>    <programming> ("distributed {fixity}"?) A description of an
18:37:03 * int-e guesses someone wanted to distinguish between the cases 'operands at both ends' and 'operands at only one end of the expression'
18:37:04 <lambdabot> [21 @more lines]
18:37:08 <dons> @more
18:37:09 <lambdabot>    {operator} represented by multiple symbols before, between,
18:37:09 <lambdabot>    and/or after the arguments.
18:37:10 <lambdabot>  
18:37:12 <lambdabot>    The classical example is the {C} conditional operator, "?:"
18:37:14 <lambdabot>    which is written
18:37:16 <lambdabot> [16 @more lines]
18:37:19 <dons> @foldoc mixfix
18:37:20 <lambdabot> No match for "mixfix".
18:37:30 <dons> hmm. that defn describes mixfix, to me
18:37:39 <seafood> That's what I thought.
18:37:45 <dons> ?: is certainly mixfix, as I understand it
18:37:46 <seafood> So perhaps they *are* the same thing?
18:38:10 <int-e> probably.
18:38:13 <bosie> hmm
18:38:39 <seafood> I'm not sure "boosie" is a permutation of "bosie". 
18:38:44 <seafood> I don't think it is.
18:38:52 <int-e> it's not
18:38:53 <bosie> its build from the same base ?
18:38:55 <bosie> ok
18:39:00 <araujo> obosie is one 
18:39:05 <int-e> nope.
18:39:19 <bosie> so a permutation of bosie is obsie ?
18:39:57 <int-e> I think the term is 'combination with repetition'
18:40:08 <int-e> bosie: yes
18:40:48 <araujo> int-e, why not?
18:40:48 <bosie> gah
18:40:55 * araujo back to his problem
18:41:21 <int-e> araujo: because 'permutation' is just a rearrangement of things - if you sort the original, and sort a permutation of the original, you get the same result.
18:41:29 <bosie> so a permutation of bosie is just all combinations including b,o,s,i,e
18:41:42 <bosie> int-e alright
18:41:45 <int-e> bosie: each exactly once
18:42:27 <araujo> int-e, well, and my example doesn't fit in that definition?
18:42:27 <araujo> For boosie
18:42:43 <araujo> dons, don't run away from me!
18:42:48 <int-e> araujo: oh, of boosie. yes it was a permutation of boosie
18:43:35 <dons> araujo, sorry. bit busy.
18:44:01 <int-e> araujo: I turned bosie's statement around because 'is a permutation of' is a symmetric relation.
18:44:07 <int-e> araujo: sorry.
18:44:12 <bosie> int-e i guess i owe you a thank you :(
18:44:20 <araujo> int-e, hah ok :-]
18:44:53 <bosie> so i was wrong to assume bosie being the same as boosie at my haskell exam? :(
18:45:48 <int-e> maybe
18:46:06 <int-e> maybe a kind soul will add bosie=boosie somewhere
18:46:09 <seafood> Was there a function called "permutation"?
18:46:23 <bosie> seafood we had to write it on our own
18:46:35 <bosie> and i implemented bosie being the same as boosie :(
18:47:26 <seafood> Oh. You shouldn't lose too many marks  then.
18:47:37 <bosie> i got 0
18:47:44 <seafood> :(
18:48:13 <ski> > let select [] = []; select (a:as) = (a,as) : [(a',a:as') | (a',as') <- select as]; perms [] = [[]]; perms as = [a0:as'' | (a0,as') <- select as, as'' <- perms as'] in perms "bosie"
18:48:14 <lambdabot> ["bosie","bosei","boise","boies","boesi","boeis","bsoie","bsoei","bsioe","
18:48:14 <lambdabot> bsieo","bseoi","bseio","biose","bioes","bisoe","biseo","bieos","bieso","
18:48:14 <lambdabot> beosi","beois","besoi","besio","beios","beiso","obsie","obsei","obise","
18:48:15 <lambdabot> obies","obesi","obeis","osbie","osbei","osibe","osieb","osebi","oseib","
18:48:17 <lambdabot> oibse","oibes","oisbe","oiseb","oiebs","oiesb","oebsi","oebis","oesbi","
18:48:19 <lambdabot> [9 @more lines]
18:48:39 <ski> > let select [] = []; select (a:as) = (a,as) : [(a',a:as') | (a',as') <- select as]; perms [] = [[]]; perms as = [a0:as'' | (a0,as') <- select as, as'' <- perms as'] in elem "obsie" (perms "bosie")
18:48:40 <lambdabot> True
18:48:52 <dons> haskell should just know what I mean without me having to use newtype constructors ;)
18:48:58 <dons> if I put a type decl in.
18:49:03 <dons> hehe.
18:49:16 <ski> bosie : there you go
18:49:25 <bosie> ski not sure what you do, but i found an easier solution tho
18:49:35 <bosie> ski ok sorry, forget my last statement
18:49:59 <int-e> > sort "obsie" == sort "bosie"
18:50:00 <lambdabot> True
18:50:06 <bosie> int-e exactly ;))
18:50:31 <bosie> just curious, is there some page like msdn where i can browse all modules and their fucntions etc ?
18:50:59 <bosie> Data.List has a sort but i implemented my own sort cos i didnt know there was already a sort :(
18:51:23 <fanopnaic> bosie: I found http://www.zvon.org/haskell/
18:51:50 <fanopnaic> No, I am lying. It should read http://www.zvon.org/other/haskell/Outputglobal/index.html
18:53:18 <bosie> waaaaaaaaaaaaaaaa
18:53:24 <bosie> der is a List.insert toooooooo
18:53:42 <ski> @type List.insert
18:53:43 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
18:53:47 <int-e> @hoogle merge
18:53:47 <lambdabot> Data.Graph.Inductive.Internal.Heap.merge :: Ord a => Heap a b -> Heap a b
18:53:47 <lambdabot> -> Heap a b
18:53:47 <lambdabot> Control.Concurrent.mergeIO :: [a] -> [a] -> IO [a]
18:53:47 <lambdabot> Data.Graph.Inductive.Internal.Heap.mergeAll :: Ord a => [Heap a b] ->
18:53:47 <lambdabot> Heap a b
18:53:52 <bosie> dear god i did that one too :(
18:54:01 <int-e> but no Data.List.merge ... I keep missing that
18:54:29 <bosie> int-e hmm isnt that ++ ?
18:54:34 <ski> (no unordered insert, though ..)
18:54:39 <int-e> bosie: no
18:54:45 <int-e> ski: (:)
18:55:20 <int-e> bosie: merge [1,4,7] [2,3,4,5] = [1,2,3,4,4,5,7] is what I'd expect
18:55:49 <int-e> bosie: i.e. take two sorted lists and return the sorted list that contains all elements from both.
18:55:59 <fanopnaic> > sort ([[1,4,7]] ++ [[2,3,4,5]])
18:56:00 <lambdabot> [[1,4,7],[2,3,4,5]]
18:56:06 <fanopnaic> mhm.
18:56:15 <fanopnaic> > sort ([1,4,7] ++ [2,3,4,5])
18:56:16 <lambdabot> [1,2,3,4,4,5,7]
18:57:21 <bosie> int-e isnt that the same as like map insert ?
18:57:58 <int-e> bosie: but merge can be done in O(n+m) operations where n and m are the lengths of the two arguments.
18:58:02 <ski> > let insert a0 as = (a0:as) : [a':as'' | a':as' <- return as, as'' <- insert a0 as'] in insert 1 [2,3,4]
18:58:03 <lambdabot> [[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,1]]
18:58:08 <ski> int-e : that's the one i meant
18:58:26 <int-e> ski: ah!
18:58:27 <ski> int-e : insert someone, list-monad-thingie
18:58:37 <ski> s/someone/somewhere/
18:59:13 <bosie> hmm what is monad anyway?
18:59:15 <int-e> bosie: namely, merge [] bs = bs; merge as [] = as; merge (a:as) (b:bs) | a<b = a:merge as (b:bs); | otherwise = b:merge (a:as) bs
19:00:42 <palomer> man, I wish google had a service to store and share bookmarks
19:00:52 <ski> there are many monads .. list-monad can be used when you can't decide which result you want to return .. so you return all of them
19:01:02 <Korollary> palomer: why google ?
19:01:18 <palomer> Korollary: or any site, really
19:01:22 <ski> bosie : like in that 'insert' i return a list of all ways to insert 1 somewhere into [2,3,4]
19:01:25 <bosie> ski what is monad anyway ?
19:01:34 <palomer> everytime I reinstall my OS, I never remember to store my bookmarks
19:01:35 <palomer> so they go away
19:01:36 <bosie> ski everytime i am here i just here monad this, monad that... ?
19:01:38 <Korollary> palomer: like http://del.icio.us ?
19:01:50 <ski> bosie : monad is a quite general concept
19:02:07 <bosie> ski of?
19:02:20 <ski> e.g. i/o is also a monad
19:02:30 <ski> @type putChar
19:02:30 <bosie> monad as in haskell-class ?
19:02:31 <lambdabot> Char -> IO ()
19:02:52 <ski> there is one particular haskell type-class for monads, yes
19:02:52 <palomer> Korollary: that's awesome!
19:03:07 <bosie> palomer you didnt know about that ?
19:03:10 <palomer> Korollary: another reason I'd like to do it with google: I'll never forget where it was
19:03:14 <palomer> bosie: no:(
19:03:31 <palomer> I might forget about del.icio.us
19:03:36 <bosie> ski i see
19:04:12 <bosie> palomer write you an email with a topic saying favorites ?
19:04:17 <bosie> bookmarks
19:04:26 <ski> bosie : when you see a type "Foo -> M Bar", when 'M' is a monad, then you think "this takes a Foo as argument, and returns a Bar, and also does some side-effect"
19:04:40 <ski> bosie : what the side-effect can be depends on the monad
19:05:14 <Korollary> not all monads involve side effects.
19:05:25 <ski> bosie : IO monad has as side-effects to do i/o :)  i.e. open and read are write and close files, and do graphics and pipes. etc
19:05:37 <ski> Korollary : right, the trivial monad, Id, doesn't
19:05:37 <palomer> bosie: then I'll forget about that too
19:06:29 <ski> bosie : list-monad has as side effects that there might not be exactly 1 result "Bar" above, it could be 0, or it could be 7, etc ..
19:06:53 <Korollary> ski: huh ?
19:07:21 <ski> data Id a = MkId a; instance Monad Id where return a = MkId a; MkId a >>= f = f a
19:07:33 <Axioplase> what is the float_of_int function in haskell ?
19:07:47 <ski> @type fromIntegral
19:07:48 <bosie> ski arent you expecting a list if you return a list-monad Bar ?
19:07:48 <lambdabot> forall b a. (Num b, Integral a) => a -> b
19:07:50 <Korollary> Axioplase: fromIntegral 
19:07:57 <Korollary> Axioplase: it is overloaded, btw
19:08:01 <Axioplase> thanks
19:08:15 <ski> bosie : sure, but if you use do-notation, that list is hidden
19:08:34 <bosie> do-notation ?
19:08:53 <Korollary> ski: the list monad does not have any side effects.
19:09:06 <ski> > let insert a0 as = (a0:as) : [a':as'' | a':as' <- return as, as'' <- insert a0 as'] in do as <- insert 10 [1,2,3]; bs <- insert 20 as; return bs
19:09:07 <lambdabot> [[20,10,1,2,3],[10,20,1,2,3],[10,1,20,2,3],[10,1,2,20,3],[10,1,2,3,20],[
19:09:07 <lambdabot> 20,1,10,2,3],[1,20,10,2,3],[1,10,20,2,3],[1,10,2,20,3],[1,10,2,3,20],[20,
19:09:07 <lambdabot> 1,2,10,3],[1,20,2,10,3],[1,2,20,10,3],[1,2,10,20,3],[1,2,10,3,20],[20,1,2,
19:09:07 <lambdabot> 3,10],[1,20,2,3,10],[1,2,20,3,10],[1,2,3,20,10],[1,2,3,10,20]]
19:09:11 <ski> Korollary : sure it does
19:09:29 <ski> Korollary : or, if you say it doesn't, then IO doesn't either
19:09:37 <ski> choose your viewpoint
19:09:55 <ski> bosie : look at "do as <- insert 10 [1,2,3]; bs <- insert 20 as; return bs"
19:10:11 <bosie> i still cant see what the problem is with M Bar, you say the side effect is that you get a list back and dont know if the list's size is 0, 1,2,...
19:10:36 <ski> bosie : that looks like it calls the function 'insert' twice, first inserting 10 in the list, then inserting 20 in the result, then returning the last list
19:11:53 <bosie> ski uff i am so not into that syntax
19:12:04 <Korollary> ski: Not quite. For the list constructor to have a side effect, it needs to modify something besides its return value.
19:12:05 <ski> me indents
19:12:15 <ski> do as <- insert 10 [1,2,3]
19:12:20 <bosie> kk
19:12:20 <ski>    bs <- insert 20 as
19:12:25 <ski>    return bs
19:12:29 <bosie> ok
19:12:33 <ski> compare with
19:12:38 <ski> {
19:12:46 <ski> as = insert(10,[1,2,3]);
19:12:52 <ski> bs = insert(20,as);
19:12:55 <ski> return bs;
19:12:55 <ski> }
19:13:59 <ski> Korollary : i don't agree .. it just has to have some effect besides it's return value .. i.e. a side-effect  (in this case, to not return exactly one value)
19:14:47 <bosie> ski not sure what you pointing me at
19:15:09 <ski> bosie : are you familiar with any imperative programming language ?
19:15:43 <bosie> yea
19:15:59 <bosie> ski yes
19:16:18 <ski> then you know that it's custom there that 'functions' can do side-effects, like printing out things, e.g.
19:16:36 <bosie> if you call that side ffect yes
19:16:55 <ski> everything observable, which is not the return value, is a side-effect
19:17:00 <bosie> kk
19:17:06 <bosie> good point tho
19:17:15 <bosie> in the haskell i had so far that really doesnt happen
19:17:25 <ski> of course, sometimes the side-effect is the main point
19:17:32 <ski> bosie : right
19:18:25 <ski> if you look at "putChar :: Char -> IO ()" and say "this takes a char, and returns an io-action over the dummy type", then indeed there *is* no side-effect
19:19:10 <bosie> ok, so writing the char to a file is a side effect
19:19:13 <ski> if on the other hand, you say "this takes a char, and returns a dummy value, and *does something on the side*", then there's is a side-effect
19:19:20 <ski> it's a matter of viewpoint
19:19:29 <ski> yes
19:19:41 <bosie> ok
19:19:56 <bosie> hm
19:20:05 <bosie> but there wouldnt be a way to write to a file in haskell w/o a sideeffect ?
19:20:29 <ski> "putChar 'a'" here is the same as "putChar 'a'" there .. so both those *always* returns the same io-action
19:20:52 <ski> bosie : there wouldn't be a way to write to a file w/o affecting the world in some way
19:21:30 <ski> the point about "IO" above is that it makes this explicit, so, it's not a *side*-effect, anymore, it's part of the io-action putChar returns
19:21:38 <bosie> ski just curious, is chaning the state of a class via a function in OOP a sideeffect ?
19:21:46 <ski> yes
19:22:13 <ski> bosie : that's an 'internal state' side effect .. this is assignment, which is a side-effect
19:22:57 <bosie> hm
19:23:18 <ski> there are also exception side-effects
19:23:35 <bosie> and what is an exception ?
19:23:52 <bosie> exception is kinda a return value ... cant be a side effect than
19:24:12 <ski> when some piece of code detects an exceptional situation, it "signals an exception"
19:24:25 <bosie> SE or not? ;)
19:24:39 <ski> which means that the current function stop execution, and the exception is propagated upwards to whatever function called it
19:24:43 <ski> side-effect !
19:24:54 <ski> it's not the return value, so .. :)
19:24:58 <bosie> public SkyNetClientImpl(Properties props) throws RemoteException {
19:25:04 <bosie> i declare it .... so....
19:25:32 <ski> if you write   foo = new SkyNetClientImpl(someProps);
19:25:39 <bosie> yes
19:25:40 <ski> then foo will never contain that exception
19:25:45 <ski> so, it's a side-effect
19:25:57 <bosie> try{
19:25:57 <bosie> foo = new ();
19:25:57 <bosie> }catch(RemoteException e)
19:26:03 <bosie> e will and it gets it from skynetclientimpl
19:26:08 <ski> yes
19:26:18 <ski> that is a special form to handle this side-effect
19:26:52 <ski> the point is, it's still not *the* return value
19:26:59 <bosie> nop
19:27:06 <bosie> but not a side-effect either
19:27:20 <ski> which means you need special constructions when/if you want to handle it specially
19:27:51 <ski> <ski> everything observable, which is not the return value, is a side-effect
19:27:51 <ski> :)
19:28:18 <bosie> yea i know
19:28:29 <ski> so, 'tis a side-effect
19:28:43 <ski> in haskell you have
19:28:44 <bosie> but since you declare the exception in the signature of the function.... anyway
19:28:46 <ski> @type lookup
19:28:47 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
19:28:55 <ski> if you do
19:29:05 <ski> case lookup key assocs of
19:29:22 <ski>   Just value -> continue with value
19:29:25 <ski>   Nothing -> handle failure
19:29:44 <ski> then tou think of the return value as having type "Maybe b"
19:29:54 <ski> so, no side-effect
19:30:18 <bosie> hm
19:30:18 <ski> if you instead use monadic do-notation (the Maybe monad)
19:30:30 <ski> do value <- lookup key assocs
19:30:36 <ski>    continue with value
19:30:42 <ski> then it's a side-effect
19:30:42 <fworp> do you 'have to' declare what exceptions some classes/method may throw in java?
19:30:55 <bosie> fworp yes
19:31:19 <araujo> dons, ping?
19:31:19 <bosie> i know that there is SOMETHING comming back but i know exactly the type of exception which is comming back and the latter is a side effect?
19:31:26 <ski> fworp : yes, for those that are subclasses of Exception (not for those that are subclasses of Error or RunTimeExcpetion, iirc)
19:31:26 <bosie> ski but i get ur point
19:31:38 <fworp> so if something calls that method, the caller also has to declare that it may throw that?
19:31:50 <bosie> fworp and it has to catch it or pass it
19:31:58 <fworp> cool.
19:33:16 <ski> bosie : whether it's *side*-effect depends on whether you think of "Maybe b" as type of return value there, or whether you think of "b" as type of return value .. and this is reflected in how you write, as i showed an example of
19:34:25 <ski> the do-notation focuses on the 'Bar' in the 'M Bar', so there you program with side-effects
19:35:48 <bosie> kk
19:36:17 <fworp> ski: ah, that kindof spoils it
19:36:27 <bosie> fworp lol
19:36:47 <ski> heh
19:38:17 <bosie> have to go back to java now
19:38:23 <bosie> thank you ski for skiing with my mind a bit ;)
19:39:07 <ski> m, cya
19:39:24 <bosie> m?
19:39:55 <ski> roughly 'm = yes'
19:40:17 <ski> (or 'agree' or 'affirmed', etc)
19:40:21 <bosie> aha
19:40:41 <Korollary> ski: by your definition, quicksort is a function with sideeffects.
19:41:11 <ski> for what reason ?
19:41:47 <Korollary> ski: because the list monad has side effects. So is "Just", etc.
19:42:12 <ski> but how often do you think of quicksort as nondeterministically returning an element ?
19:42:34 <Korollary> ski: nondeterministically ?
19:42:51 <ski> more often, id' bet, you think of it as returning a whole sorted list
19:43:07 <bosie> cu guys
19:43:09 <ski> list monad is (ordered) nondeterminism side-effects
19:43:39 <ski> like my 'insert' above, that nondeterministically inserts an element somewhere into a list
19:44:29 <Korollary> ski: are we calling it a side effect just because the return type is recursive and can vary in size ?
19:44:36 <ski> > let flip = [True,False] in  do b0 <- flip; b1 <- flip; return (b0,b1,b0 && b1)
19:44:37 <lambdabot> [(True,True,True),(True,False,False),(False,True,False),(False,False,
19:44:37 <lambdabot> False)]
19:44:43 <ski> Korollary : no
19:45:18 <ski> this nondeterministically flips a coin, twice, and then perform an AND on the result
19:46:02 <ski> Korollary : it's a matter of what you focus on
19:46:07 <Korollary> ski: I am sorry, but that doesn't explain it to me
19:46:37 <Korollary> ski: in my view, a function with a side effect is one that causes a state change that the caller cannot observe.
19:46:53 <Korollary> ski: just by looking at the return value, that is.
19:47:14 <ski> that is retricted to state side-effects
19:47:32 <ski> each monad has it's own kind of effect
19:47:41 <Korollary> ski: no, I belive that is the common usage of the term.
19:47:56 <ski> sure .. but this is a generalization
19:48:25 <ski> (that occurs in e.g. the monad literature, and also in at least some continuation papers)
19:48:26 <Axioplase> How do I overload (-) for my own type ?
19:48:36 <Korollary> ski: See http://en.wikipedia.org/wiki/Side-effect_%28computer_science%29
19:48:50 <ski> Axioplase : do you want it to be a kind of "number" ?
19:48:50 <dons> Axioplase, write an instance of Num
19:49:38 <Axioplase> ski: say, (2,1) - (1,1) => (1,0), where the pair is a handcrafted type.
19:50:29 <araujo> mm.. the problem is the waitForProcess thing......
19:50:55 <araujo> dons, When i don't wait for the process, it seems to work....
19:51:27 <Korollary> Axioplase: You can make it do anything you want. But it will be in the Num typeclass.
19:51:55 <Axioplase> Korollary: well, I guess that "Point.(-) p1 p2 = (fst p1 - fst p2, snd p1 - snd p2)" isn't the right way to do it..
19:52:34 <Korollary> Axioplase: why not ?
19:52:55 <Axioplase> Korollary: because ghci complains enveloppeconvexe.hs:24:0: Type signature given for an expression
19:53:21 <Korollary> Axioplase: your syntax is not valid I think
19:53:32 <Axioplase> where this line is Point.(-) :: Point -> Point -> Point
19:54:17 <Korollary> Axioplase: also, you need to use something other than the pair. define a custom pair type like data MyPair a a = Int Int, etc.
19:54:41 <Axioplase> Korollary: I have type Point = (Integer,Integer)
19:54:49 <ski> Korollary : i'll have to leave now .. but i'll try to dig up some papers that mention relation between monads and effects, ok ?
19:55:07 <Korollary> ski: of course
19:55:39 <Axioplase> Korollary: using a data doesn't help me parsing it manually because I'll have nested types like this..
19:58:30 <Axioplase> anyway, I'll do with a simple func for now
20:00:55 <Korollary> Axioplase: Use "data MyPair = MyPair Integer Integer" and "instance declarations for Eq, Show and Num.
20:01:26 <Korollary> actually
20:01:40 <Korollary> Axioplase: Use "data MyPair = MyPair Integer Integer deriving (Eq, Num)" and "instance declarations for Num.
20:02:28 <Axioplase> alright.
20:07:07 <Korollary> Axioplase: even better: Use "data Num a => MyPair a = MyPair a a" and "instance (Num a) => Num (MyPair a) where", and you can have pairs of all number types.
20:11:10 <fworp> @hoogle Num a => Integer -> a
20:11:11 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
20:11:11 <lambdabot> Prelude.negate :: Num a => a -> a
20:11:11 <lambdabot> Prelude.abs :: Num a => a -> a
20:11:34 <fworp> oh.. duh
20:15:19 * int-e still isn't sure whether it's good style to use Num instances for types that only have addition and negation.
20:16:40 <dons> use pred/succ perhaps?
20:17:11 <dons> @type pred
20:17:11 <lambdabot> forall a. (Enum a) => a -> a
20:17:14 <dons> @type succ
20:17:15 <lambdabot> forall a. (Enum a) => a -> a
20:18:50 <Korollary> dons for president
20:19:36 <dons> :p
20:20:02 <Korollary> > "dons " ++ "for " ++ "president"
20:20:03 <lambdabot> "dons for president"
20:21:28 <dons> Enum is under appreciated I think.
20:21:48 <araujo> dons dons !
20:21:53 <dons> araujo!!
20:22:17 <araujo> dons, hah, look, i am debuggin this problem, it is happening when i wait for the process.
20:22:30 <dons> hmm. ok
20:22:51 <araujo> I still don't understand it though.....
20:23:38 <dons> had the process alreaddy terminated when you wait for it?
20:23:53 <dons> (some times on linux that throws an error, but it's fixed in head I think)
20:24:28 <araujo> No, it isn't terminated.
20:25:14 <araujo> mmm....
20:27:17 <fworp> seems you can declare an instance of Num for pairs: instance (Num a,Num b) => Num (a,b) where ...
20:30:04 <fworp> though i have no idea what the natural definition of fromInteger would be
20:38:47 <Cale> fworp: fromInteger n = (fromInteger n, fromInteger n)
20:39:46 <Cale> The ring you define that way, assuming that you're just taking the operations to be pointwise, will have the unfortunate property of having zero divisors though.
20:40:38 <Cale> That is, there will be a and b, both not 0 such that a * b = 0.
20:44:30 <Cale> oh, perhaps you missed that?
20:44:36 <Cale> (fworp)
20:44:50 <fworp> probably
20:44:55 <Cale> <Cale> fworp: fromInteger n = (fromInteger n, fromInteger n)
20:44:56 <Cale> <Cale> The ring you define that way, assuming that you're just taking the operations to be pointwise, will have the unfortunate property of having zero divisors though.
20:44:56 <Cale> <Cale> That is, there will be a and b, both not 0 such that a * b = 0.
21:06:51 <fworp> cale, ok, i see. (0,1) (1,0) are both not 0, but (0,1) * (1,0) is 0
21:09:24 <araujo> dons, ping?
21:10:46 <araujo> dons, i found the way to solve the problem, i need to force the evaluation (i did it like you recommended with Control.Exception.evaluate) , but without using forkIO
21:11:40 <araujo> It apparently doesn't work if i try to force the evaluaytion within another thread. 
21:11:53 <araujo> (What is the point of it also?, i didn't get it)
21:12:14 <araujo> @karma+ dons 
21:12:14 <lambdabot> dons's karma raised to 16.
21:17:28 <dons> oh, you need -threaded for the forkIO, I'd expect
21:17:45 <dons> the idea is to consume all input before closing off the process
21:20:03 <fworp> cale: thats how i defined it, but yeah, for some reason it seemed unsatisfactory, though i didnt have any idea what a ring or a zero divisor was until you said that :P
21:21:50 <araujo> dons, i see i see.... well, right now it looks working fine doing that within the same process.
21:23:47 * fworp is math impaired
22:27:42 * araujo saluda a Nomius 
22:35:05 <araujo> There exist a function to do something like: find "bar" "FoObarbaz" => True 
22:40:23 <stefanw> dons, what are you doing with the poor GHC ;-) when compiling hmp3 it gives me the following error: Prologue junk?: 	.type	s8DI_ret, @function and the a couple of lines of assembler code follows...
22:40:35 <stefanw> s/the/then
22:41:27 <int-e> > let find a b = any ((map (const True) a ==).zipWith (==) a) (tails b) in find "bar" "FoObarbaz"
22:41:28 <lambdabot> True
22:43:09 <int-e> > let find a b = any ((a ==).take (length a)) (tails b) in find "bar" "FoObarbaz"
22:43:10 <lambdabot> True
22:47:58 <araujo> int-e, yeah, i know how to do one version, i was just looking for something in the prelude
22:49:06 <int-e> araujo: if I was aware of something there I'd have told you :)
22:54:26 <araujo> int-e, yeah, it's ok, it looks like there is nothing around
22:56:11 <fworp> is something like this valid haskell: class Foo a b where ...; instance Foo [a] a where ... 
23:03:26 <int-e> fworp: ghc has an extenstion that supports multiple parameter classes.
23:04:18 <int-e> fworp: use -fglasgow-exts to use it. Haskell 98 only has single parameter classes.
23:10:47 <fworp> i was actually refering to the two different references to a. class Sequence a b where { sCons :: b -> a -> a; ... } and then instance Sequence [a] a where ... almost seems magical. In conjunction with overlapping instances, you could define a set of polymorphic operations over both PackedStrings and Strings
23:26:39 <stepcut> hrm, fastcgi looks neat, but I don't think I can run a server on my web host -- so I am not sure if it buys me anything
23:55:06 <dons> stefanw, which ghc version? on linux?
23:56:16 <palomer> hrm
23:56:19 <palomer> I need entertainment
