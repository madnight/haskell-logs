00:00:38 <ibid> pediddle: the 1.4 report is on the same page as the 95 report
00:00:57 * ibid started haskelling in the 1.4 days
00:01:18 * dblhelix is a 98 man
00:01:56 * ibid is proud of having his name in the 98 acks :)
00:04:14 <ibid> (i think it was because i nagged them to make the reports free software)
00:06:29 <dons> :)
00:07:46 <stefanw> is there a way to write a preprocessor #ifdef based on the patchlevel of ghc?
00:08:21 <dons> I don't think so
00:08:33 <dons> it's explicitly not supported in fact :)
00:08:36 * ibid was the debian hugs maintainer back then, and i wanted to package the reports (this became the haskell-docs package which was later split)
00:08:42 <ibid> pediddle: also see http://haskell.org/definition/aboutHaskell98.html
00:08:47 <dons> unless you write your own ./confgure test stefan..
00:09:08 <dons>     GHC_VERSION=`$WithGhc --numeric-version`
00:09:45 <dons> (that's stolen from ncurses yi)
00:10:09 <stefanw> I wanted to avoid this, now that everything builds nicely with Cabal. But this preprocessor stuff in HUnit is so messed up that I need different code for different patchlevels (in HTF, not in GHC)
00:10:25 <dons> argh
00:10:56 <stefanw> the problem is that it's decided based on the prefix of the error message whether it's a failure or an error. Kind of nasty
00:11:16 <dons> oh, hmm. that's extremely evil
00:15:37 * stefanw decides to make it right and writes a dynamic exception
00:15:54 <dons> yay :)
00:32:11 <vegai> is it coincidental that the symbols in the Haskell logo form a pentagram?
00:32:23 <vegai> http://haskell.org/HaskellLogo_2.jpg
00:33:04 <kala> are you referring to some hidden conspiracy theory?
00:33:41 <vegai> well, I was thinking that it just means Haskell is magical
00:33:56 <vegai> s/magical/magickal/
00:34:41 <kala> actually, Haskell is given to humans by aliens
00:35:00 <kala> it remains mustery, why they did it and what we should do with it
00:35:20 <vegai> those pesky aliens
00:37:24 <Cale> kala: Simon Peyton-Jones is an alien?!
00:39:08 <basti_> he is?
00:39:08 <basti_> ^^
00:39:50 <stefanw> dons: what's the fastest way to get the fix into GHC?
00:47:40 <kzm> Hi,
00:47:58 <kzm> Question: is "sequence" strict?
00:48:14 <dross> I have to rewrite this code without a recursive call, and using foldr instead : translate _ [] = []           translate (xo, yo) ((x,y):vs) = (x+xo, y+yo) : translate (xo,yo) vs
00:48:22 <basti_> kzm: uhm.
00:48:24 <dross> anyone has an idea ?
00:48:31 <basti_> kzm: it evaluates the whole list.
00:48:51 <basti_> dross: that sounds like a homework problem ^^
00:49:04 <kzm> basically, I want to produce a progress report as a list (stream) is processed.
00:49:12 <dross> its not, im preparing for my exam and this is a problem from last year exam
00:49:37 <kzm> so I wrap the list in "returns" and every nth element, I insert a "print count >> return x" instead.
00:50:11 <basti_> dross: ^^ well what's the type of foldr?
00:50:41 <dross> (a -> b -> b) -> b -> [a] -> b
00:50:41 <kzm_> (argh - wrong window)
00:50:42 <basti_> kzm_ hmm. you will need explicit concurrency there i fear.
00:51:06 <sowhat> anybody experience with using the 0.2 version of TimeLib?
00:51:07 <basti_> dross: what's your list's type?
00:51:09 <kzm_> I guess you're right.  I just experimented with ghci, but it seems so.
00:51:28 <basti_> kzm: actually in some situations you might not to, but usually you will.
00:51:52 <basti_> kzm: for example you could do something like sequence $ map print fibs , and it will be "lazy"
00:51:58 <basti_> (evaluating fibs as it goes)
00:52:04 <kzm_> Is there a reason sequence cannot be lazy?
00:52:19 <basti_> "mu", kzm ^^
00:52:35 <dross> basti_ : doesn't matter... foldr does this : foldr op i [] = []        foldr op i (x:xs) = x 'op' foldr op i xs
00:52:38 <kzm_> but I want "ys <- sequence xs" and have ys be a lazy list.
00:52:57 <basti_> it -is- lazy, but monads' semantics isn't (no? - help! ;))
00:53:01 <kzm_> µ
00:53:13 <basti_> no not the greek letter, the koan response ^^
00:53:21 <kzm_> :-)
00:53:34 <basti_> dross: well it does matter in your case. you got pairs of numbers, and you want numbers as a result don't you?
00:53:56 <kzm_> I'll stare at it for a while, and see if I achieve enlightenment, then...
00:53:58 <basti_> erm pairs of numbers
00:54:09 <dross> well yeah in this case we use '+' in translate so i yeah its got to be Int
00:54:21 <basti_> kzm: hmm are you talking about IO or about [ ] as a monad?
00:54:34 <basti_> dross: at least some numbers.
00:54:43 <dross> yup
00:54:52 <basti_> dross: so basically you got a function like Num a => [(a,a)]->(a,a)
00:55:14 <basti_> that would be the curried rest of foldr. What does that tell you about your instance of the foldr type?
00:57:32 * basti_ is reversing the question ^^
00:59:53 <dross> mmm , im thinking , im not sure i understand
01:00:58 <basti_> lets start with a simple example
01:01:05 <basti_> foldr (+) 0 [1..3]
01:01:10 <basti_> whoops
01:01:13 <basti_> @eval foldr (+) 0 [1..3]
01:01:14 <lambdabot> 6
01:01:23 <Cale> http://vx.hn.org/autoshare/foldr.png
01:01:26 <dross> yeah
01:01:27 <basti_> @type foldr (+)
01:01:28 <lambdabot> forall b. (Num b) => b -> [b] -> b
01:01:45 <basti_> good image Cale ^^
01:02:15 * shapr yawns
01:03:44 <dross> yeah right
01:04:10 <basti_> now what you want is not to process a list of numbers.
01:04:32 <dross> right a list of tuples
01:05:14 <Cale> so your function `f` is going to take tuples on the left
01:05:31 <Cale> (that is, as its first parameter)
01:07:42 <Cale> and it's going to take lists of tuples on the right, since it's going to produce a list of tuples
01:07:47 <dross> im not sure where this is going... what bugs me real good is . foldr makes operations on the tuples of the list together, but what i want, is for each tuple in the list to be added to some number
01:08:13 <Cale> really, you should be writing map in terms of foldr first :)
01:08:21 <Cale> try that
01:08:40 <dross> ok
01:08:50 <shapr> dons: cool notes!
01:09:37 * basti_ will go have a shower
01:09:38 <basti_> ^^
01:10:26 <Cale> dross: so thinking of it in terms of replacement, what does map f replace (:) and [] with?
01:11:25 <Cale> really, you tend to think of map f as replacing the elements of the list
01:12:02 <Cale> but you can also say that it's replacing the list constructor with one which does a little work before adding the new element to the head of the list
01:15:36 <dross> mmm...even with map , the problem is that foldr makes operation between list elements, and thats not what we want :( ... we just want function f to be applicated to all elements
01:15:46 <Cale> (:) is a function
01:16:02 <Cale> okay, even easier problem than map
01:16:12 <Cale> write the identity function using foldr
01:16:29 <Cale> (did you see http://vx.hn.org/autoshare/foldr.png ?)
01:16:33 <dross> yup
01:17:22 <Cale> so what choice of f and z would leave that tree the same?
01:17:31 <Muad_Dibber> (:) []
01:17:33 <Muad_Dibber> :P
01:17:39 <Cale> well, yeah :)
01:17:43 <dross> hehe
01:17:45 * Muad_Dibber hides again
01:18:29 <dross> ok thats clear at least
01:19:15 <Cale> okay, so what if we replaced : with a modified version of : which applied f to its left parameter?
01:20:33 <Muad_Dibber> so Cale, explain the function f first, what it does :)
01:20:43 <Cale> f being any function
01:21:01 <Muad_Dibber> yeah so, what kind of paramters it gets :P
01:21:15 <Muad_Dibber> (btw, I understand it, so its not for me :))
01:21:18 <Cale> (this is toward the goal of writing map f in terms of foldr)
01:21:25 <dross> sorry if im 'slow' ... its 4am now and im kinda new in this ehe im really tring my best
01:21:48 <Muad_Dibber> thats good enough for me dross :)
01:22:05 <Cale> okay
01:22:54 <Cale> another way to write (:) is \x xs -> x : xs
01:23:07 <Cale> so how about \x xs -> (f x) : xs
01:23:07 <dross> well if we replace : by f we get again some function f operating on 2 list elements ?
01:23:41 <Cale> ah, perhaps I should use some other letter :)
01:23:59 <Cale> suppose we're trying to write map g in terms of foldr
01:24:41 <Cale> so we're writing f -- our replacement for cons, and z -- our replacement for nil
01:25:01 <Cale> we know that map g [] = []
01:25:40 <Cale> so, whatever f and z are, map g [] = foldr f z [] = []
01:25:58 <Cale> but from this, we can determine that z = []
01:26:03 <Cale> right?
01:26:16 <Cale> since foldr replaces the empty list with z
01:26:26 <dross> yep
01:26:34 <Cale> okay
01:26:40 <basti_> back-o
01:27:40 <Cale> now, let's have a look at replacing (:)
01:28:11 <Cale> map g (x:xs) = (g x) : (map g xs)
01:28:48 <dross> yes
01:30:13 <Cale> hmm, how to explain this in a non-confusing way :)
01:30:48 <Cale> one way to look at this is that we're replacing the element x with a new element g x
01:31:26 <Cale> but with a little work, we can factor things so that it looks more like we're replacing (:) with something new
01:31:50 <Cale> map g (x:xs) = (g x) : (map g xs) = newCons x (map g xs)
01:32:09 <Cale> where newCons y ys = g y : ys
01:32:49 <kzm_> Hi again!  It appears that "sequence" is too strict for my purposes (wrapping a list in IO actions to print progress to stdout).  Is there a better solution?
01:33:08 <Cale> dross: does that make sense?
01:33:31 <Cale> kzm_: hm?
01:34:16 <kzm_> I'm processing a (very long) list of data, and would like to provide output to the user, to show that something is happening.
01:34:45 <Cale> kzm_: are you going to process the whole list?
01:34:47 <kzm_> So I basically "map return" on it, but replace every nth with "print count >> return x" instead.
01:35:07 <Cale> okay
01:35:07 <kzm_> Yes, probably.  I'd prefer it if I didn't have to, though.
01:35:54 <kzm_> And then I do ys <- print_progress xs; mapM_ heavy_computation_per_element ys  -- or something like that.
01:35:55 <Cale> okay, what determines the cases when you stop somewhere in the middle, or skip elements?
01:36:09 <musasabi> kzm_: seqence [action >> putStrLn "progress" | action <- actions ]
01:36:27 <Cale> musasabi: that's basically what he already has
01:37:32 <dross> how could newCons accesses 'g' if it's arguments are y ys
01:37:33 <Cale> kzm_: you see, when you go to turn that list of actions into an action, it's going to produce the action that does everything in the list
01:37:46 <Cale> dross: it's in the where clause :)
01:37:48 <kzm_> I see.
01:38:07 <kzm_> There is no way to have that action be lazy, then?
01:38:18 <Cale> well, it will be lazy in some sense
01:39:50 <kzm_> Perhaps if I lift my computation into the IO monad?
01:40:06 <kzm_> I'd like to mangle the rest of my (mostly pure) code as little as possible, though.
01:40:17 <Cale> hmm
01:41:08 <basti_> the problem is: the list is forced before the IO happens
01:41:17 * basti_ tried it
01:41:38 <Cale> oh
01:41:56 <Cale> the actions are forced, yeah, that's likely
01:42:09 <Cale> but not the parameters to them?
01:42:35 <kzm_> Uh... unsafeInterleaveIO?
01:42:46 <basti_> oh no.
01:42:47 <basti_> hmm
01:42:53 <basti_> sequence_ $ cycle (putStrLn "x":(map (const $ return ()) [1..10]))
01:42:58 <basti_> that gives lots of x's
01:43:01 <kzm_> basti_ - huh?
01:43:20 <kzm_> ah.
01:43:34 <basti_> bascially thats [putStrLn "x",return (), return (), ... , putStrLn "x",return () ...
01:44:47 <musasabi> Has anyone got a working Web module (the generic Zipper-like structure)?
01:46:09 <Cale> let t x = trace (show x) x
01:46:18 <Cale> sequence $ (map return (map t [1..1000]))
01:46:24 <Cale> this prints nothing
01:46:37 <Cale> the elements of [1..1000] aren't forced
01:47:03 <basti_> hmmm :/
01:47:30 <basti_> hard to grasp, that stuff
01:48:02 <Cale> sequence $ (map (trace "x" . return) (map t [1..10]))
01:48:07 <Cale> this prints 10 x's
01:48:32 <kosmikus> morning
01:48:35 <dross> okay Cale newCons does make sense..
01:48:41 <Cale> dross: :)
01:49:02 <Cale> dross: so that is what we replace (:) with
01:49:27 <Cale> map g xs = foldr (\y ys -> g y : ys) []
01:49:45 <Cale> map g = foldr (\y ys -> g y : ys) []
01:49:49 <Cale> there :)
01:50:05 <kzm_> Cale: does that solve anything for me?
01:50:35 <kzm_> Btw. using unsafeInterleaveIO delayed output a bit, but exhibits the same behavior otherwise.
01:50:40 <Cale> kzm_: well, I'm just saying that your original list is not going to get evaluated unless absolutely necessary
01:51:14 <Cale> so it's not strict in that sense
01:51:36 <Cale> oh, I suppose it has to examine the list structure
01:51:49 <Cale> so it will evaluate the backbone of the list
01:52:13 <Cale> er
01:52:14 <Cale> no
01:52:18 <kzm_> Hah!
01:52:28 <Cale> it'll only do that as it's running
01:52:29 <kzm_> sequence $ map unsafeInterleaveIO $ ...
01:52:45 <Cale> sequence $ (map print [1..])
01:52:48 <Cale> this works
01:53:15 <kzm_> Nailed it, I think.
01:53:26 <Cale> ah
01:53:59 <Cale> alternately, you could have used evaluate
01:54:28 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#7
01:54:56 <Cale> I see what you're doing now :)
01:55:17 <kzm_> (now he tells me)
01:55:19 <Cale> your actions are all trivial, so they weren't getting evaluated
01:55:19 * kzm_ grins.
01:55:37 <Cale> return x doesn't need to evaluate x to stick it in the list at the end
01:55:44 <Cale> it just copies a pointer
01:55:49 <kzm_> (and he calls it trivial!  30 minutes of hard labor: trivial!)
01:55:52 <kzm_> :-)
01:56:02 <Cale> I mean the IO part of them
01:56:05 <kzm_> Okay.
01:56:45 <kzm_> I'm not sure I follow, though.
01:57:12 <Cale> pure computations are very lazy
01:57:47 <kzm_> ys <- sequence xs  -- perform all the IO, while building the spine of ys, right?
01:57:52 <Cale> okay, so you had something along the lines of:
01:58:06 <Cale> let xs = something
01:58:23 <Cale> ys <- sequence $ map return xs
01:58:51 <kzm_> so the actual values (inside returns in xs) weren't requested until later, is that it?
01:58:55 <Cale> this is effectively a no-op
01:59:08 <Cale> you could write let ys = xs and get the same semantics
01:59:24 <kosmikus> indeed.
01:59:48 <kzm_> So in a sense, IO is a little bit more strict than pure computations :-)
02:00:17 <kzm_> (maybe)
02:00:30 <kzm_> So: is using unsIIO an okay solution?
02:00:40 <Cale> It should work
02:00:42 <kzm_> Or should I use something else?
02:00:50 <Cale> it's about the same as using Debug.Trace actually
02:01:12 <Cale> If you want to force the evaluation of the list elements, then use Control.Exception.evaluate
02:01:40 <kosmikus> unsafeInterleaveIO is the same as trace??
02:01:56 <Cale> kosmikus: for what he's doing
02:02:04 <kosmikus> ok
02:02:04 <kzm_> Hmm...yes, I suppose I could just have added trace statements to the list elements. (sigh :-)
02:02:11 <Cale> kosmikus: he's printing messages as the list is evaluated
02:02:44 <kzm_> C.E.evaluate - would that be something like a monadic version of seq?
02:02:45 <Cale> for something like a progress meter, I'd probably use evaluate
02:02:58 <Cale> it's kind of, but not quite like that
02:03:20 * kzm_ is looking it up.
02:03:41 <Cale> I suppose it's like a seq underneath the IO constructor
02:03:48 <Cale> you can't actually write it in Haskell
02:05:13 <kzm_> Hmm.. the docs are somewhat terse on the subject.  "Its semantics are given by..."  Oh well.
02:05:15 <dons> did anyone see the progress meter stuff in the dazzle paper at this year's HW?
02:05:46 * kzm_ should probably read more papers :-)
02:06:06 <kosmikus> I was just about to suggest to look at that ...
02:06:18 <kosmikus> http://www.cs.uu.nl/dazzle/f08-schrage.pdf
02:08:29 <Cale> there ought to be a wikified version of the docs :)
02:12:31 <dross> wow
02:12:44 <dross> Cale thank you, i just evaluated with an example
02:13:16 <Cale> dross: it's quite a neat thing once you get it :)
02:14:07 <Cale> dross: you can also convince yourself that you could write folds for most algebraic data types (with a few restrictions -- you might need some Functor instances)
02:14:33 <Cale> or just other folds implemented, actually
02:14:51 <dross> i'm gonna have to reread all this to be sure to understand fully, and from there i think im gonna be able to solve my problem...so thank you lots!! need to go to sleep now my exam is tomorow loll see ya
02:15:19 <Cale> like, data Tree a = Leaf a | Branch a (Tree a) (Tree a)
02:15:41 <Cale> foldTree :: (a -> b) -> (a -> b -> b -> b) -> Tree a -> b
02:16:04 <fatbrain> What haskell implementation should I install on my Linux machine?
02:16:11 <Cale> foldTree l b (Leaf x) = l x
02:16:33 <Cale> foldTree l b (Branch x t t') = b x (foldTree l b t) (foldTree l b t')
02:16:42 <Cale> fatbrain: I like ghc
02:16:58 <Cale> in fact, most people do :)
02:17:16 <kzm_> fatbrain, ghc is usually a good choice.
02:17:22 <Cale> ghc comes with a compiler (unsurprisingly called ghc), and an interpreter ghci
02:17:34 <kzm_> hugs if you have a slow machine or obscure architecture.
02:17:51 <Cale> fatbrain: I also highly recommend not compiling it
02:18:01 <Cale> get the binary release
02:18:21 <kzm_> cale: I believe the politically correct speak about interactive, not interpreted :-)
02:18:31 <Cale> kzm_: ah, yeah
02:18:49 <kzm_> both ghc and hugs should be available with apt-get or similar.  If not, change distribution.
02:18:50 <Cale> I suppose it does actually compile things anyway
02:18:52 <kzm_> :-)
02:19:07 <kzm_> At least it seems to utilized compiled modules.
02:19:35 <Cale> oh, right
02:19:59 <kzm_> but interactivity is the imporant bit - see e.g. Java.  All the disadvantages of interpretaion combined with a lack of advantages from compilation.
02:20:19 <Cale> heh
02:20:24 <kzm_> (i.e. slow *and* cumbersome - who says you can't have your cake and eat it too?)
02:21:12 <kzm_> present company excepted of course (just in case somebody with an orangy flavor is hanging around)
02:21:21 <Cale> That reminds me of a scathing comment Wolfgang Thaller made about Matlab:  It has all the performance of Haskell and the clarity of C.
02:21:27 * kzm_ smiles innocently.
02:22:24 <kzm_> or the (apocryphal?) anecdote about Einstein and the actress/model whatever.
02:22:48 <kzm_> Hah again!
02:23:11 <kzm_> No measurable time cost either!  ProgressmetersRus!
02:23:43 <kzm_> (that is, running witout -v which triggers the metering.  There will be some printing penalties, of course)
02:24:15 <Cale> what are you printing?
02:24:34 <musasabi> kzm_: I think the Dazzle folks had some progressmeter stuff.
02:25:54 <kzm_> Yes, I heard.  Tried to get my irc client to fire up 'zilla, but I'm still waiting :-)
02:25:56 <fatbrain> kzm_, Cale: gotcha.
02:26:04 <kzm_> Anyway, I got it working now.
02:26:06 <musasabi> Haskell workshop proceedings / Haskell Ready to Dazzle the Real World / 6. A lazy progress bar
02:27:13 <Cale> fatbrain: a really good reason not to compile it is that it's written in Haskell, and so you need a GHC binary to compile GHC, unless you want to go through a somewhat tricky bootstrapping process. :)
02:29:37 <glguy> using [[a]]... is there a good way to set the first element in the first list to 0, second element in the second list to 0, etc...
02:30:01 <glguy> I know this is probably what arrays are for...
02:30:21 <glguy> but this would be the only reason to need arrays
02:30:30 <glguy> for this function
02:31:44 <kzm_> Cale, musasabi, (and others?) thanks for the help.  Must be off to mail my user about the new and wonderful progress feedback!
02:32:15 <dons> you already implemented it??
02:32:48 <Cale> set n x = zipWith (\m -> if m == n then const x else id) [0..]
02:32:55 * shapr boings cheerfully
02:33:12 * Speck notes that the swing combinator is quite cool
02:33:20 <Cale> Speck: :)
02:33:36 <shapr> Cale discovered the swing combinator.
02:33:39 <Speck> I saw shapr mention it on ltu and started playing with it -- fun!
02:34:00 * shapr gives credits to Cale for extra coolness.
02:34:11 <Cale> :)
02:34:17 * Speck acknowledges Cale
02:34:20 <Cale> heh
02:35:08 <shapr> I should have mentioned that in my post.
02:35:47 <Speck> hm, a relation on 3 that is an equivalence relation and a partial ordering, so it has to be reflexive, symmetric, antisymmetric and transitive
02:35:52 <Cale> actually, glguy, you're going to want set x n = zipWith (\m -> if m == n then const x else id) [0..]
02:36:02 <Cale> (with the parameters swapped)
02:36:29 <Speck> I should figure out how to get haskell to do my homework
02:36:32 <shapr> I notice that David Held hasn't responded to his many detractors today.
02:36:37 <Cale> then you can do zeroDiag = zipWith (set 0) [0..]
02:37:00 <glguy> yup, already did it
02:37:07 <glguy> :) thnx  for the recommendation on the set function
02:37:38 <shapr> Held really got jumped on for saying that Haskell is too dense for mortals to read, and for saying that abstractions in Haskell require immersing yourself in lambda calculus to understand.
02:38:28 <Cale> link?
02:39:58 <shapr> It started with http://lambda-the-ultimate.org/node/view/1084#comment-11592
02:39:59 <Cale> wow, only one person mentioned the reason that lists are popular which I'd have given
02:40:11 <Cale> (In "Why Lists?")
02:40:29 <Rene_d> Has anyone got any suggestions on how to write a multi-dimensional array to a file?
02:40:35 <shapr> I think the people who comment often don't match my opinion.
02:40:41 <shapr> Rene_d: You take the first item...
02:40:44 * shapr grins
02:41:06 <shapr> Rene_d: Ok, non-smart-ass answer... if you have a show instance, you can dump it as text.
02:41:57 <Rene_d> Hmm: It will be 50MB even if I dump it as binary, as text it will be probably 200MB?
02:42:23 <shapr> In that case, maybe use SerTH to get a binary dump?
02:42:26 <Cale> "But it is nicer to be able to crank out hundreds of lines of code that solve your problem without having to think too hard or wonder if your code is correct." --NOOOOOO!!!!
02:42:28 <shapr> @where SerTH
02:42:28 <lambdabot> I know nothing about serth.
02:42:47 <Rene_d> I had "fmapM_ (put_ bin) $elems winarr" but this was disgustingly slow
02:42:50 <shapr> Cale: I think most readers were just incredulous. Held says that sort of thing often.
02:43:03 <Cale> who is this guy?
02:43:23 <shapr> @where+ SerTH http://www.cs.helsinki.fi/u/ekarttun/SerTH/
02:43:24 <lambdabot> serth ~> http://www.cs.helsinki.fi/u/ekarttun/SerTH/
02:43:31 <Speck> can someone comfirm my suspicion that {(0,0),(1,1),(2,2)} is an equivalence relation and a partial ordering on 3?
02:43:43 <shapr> Rene_d: Check out that url, it might help.
02:44:04 <Cale> I suppose just some random person
02:44:20 <shapr> Cale: He's convinced that Haskell/Erlang/OCaml/etc are all academic masturbation.
02:44:35 <shapr> He makes vague broad statements about it, with nothing to back them up.
02:44:56 <shapr> Most of the time he's ignorable, but occasionally he says something really amazing.
02:45:38 <shapr> On the other hand, he has a lot of good points and thoughts when he talks about C++ and Java and their design.. so I dunno...
02:45:51 <shapr> I think he was viciously attacked by a Cons list during college.
02:45:54 <Rene_d> Found it. My array is only of Int32 (I can make it Int).
02:46:21 <shapr> See, I was viciously attacked by a Java inner class in college, thus my bias...
02:46:22 * shapr snickers
02:46:41 <Rene_d> SerTH doesn't seem to have an instance for arrays, though I guess it might be faster at dumping Int32 than NewBinary
02:47:10 <Cale> I was impressed by how stupid some of the comments were that van Rossum has made in the past, given that he's the author of a programming language.
02:47:11 <shapr> It works a lot like NewBinary, but it derives instances for you automatically.
02:47:32 <shapr> Cale: I met him.... I'm now less surprised at some of his comments.
02:47:35 <Rene_d> I am thinking I might have to write a generic version of hPutArray, but was hoping someone has already done something like this
02:47:41 <Cale> shapr: oh?
02:48:00 <shapr> I think it takes a certain amount of sheer bloody mindedness to make your own language and stick to your own design, and he's got more than enough of that.
02:48:17 <shapr> Rene_d: If you extend SerTH to handle arrays, we'll all benefit :-)
02:49:18 <shapr> I think that something like Python would have appeared anyway a few years later, but van Rossum noticed the good points early on and built the language by ignoring his critics.
02:49:43 <glguy> @pl \x y -> sum . (zipWith (*) x y)
02:49:44 <lambdabot> ((sum .) .) . zipWith (*)
02:50:05 <Rene_d> Yes, SerTH certainly looks interesting, looks like a good example for TH as well.
02:50:13 <shapr> Python came out of work by CWI.nl on ABC and Amoeba. Guido implemented one (both?) of those, and tried to tell his employers that he knew how to make a better language out of the same ideas. They ignored him, so he wrote it himself over Christmas of 1989.
02:50:59 <glguy> @pl \x -> map (/x)
02:51:00 <lambdabot> map . flip (/)
02:51:10 <shapr> I think I met Guido several times, I was a heavy Python geek for a few years.
02:51:23 <vegai> David B. Held: "...The density of some FP code is astoundingly high..." -- I'm afraid I have to agree there
02:51:40 <shapr> vegai: Yes, but do you think that's good or bad?
02:51:43 <Maddas> Cale: The quote you pasted ("[..]without having to think too hard[..]") is really saddening.
02:51:53 <Cale> Maddas: yeah
02:51:58 <vegai> shapr: that depends on the intended audience, I guess.
02:52:09 <vegai> probably many of you can easily write code that will take me weeks to decipher
02:52:32 <Cale> actually, it's not so much that the density is high
02:52:35 <shapr> I think that it won't take you weeks to decipher. Once you understand the patterns, it just makes sense.
02:52:43 <eivuokko> Meh, all code must be written to express you intent, to the reader and to the compiler.  Compiler is more forgiving imo.
02:52:43 <Cale> the density is about the same
02:53:07 <Cale> it's that there's usually another level of abstraction or two hanging around
02:53:18 <Cale> and if you don't understand the abstractions, you're out of luck
02:53:23 <Maddas> vegai: The idea is that the higher density comes with less code.
02:53:27 <Maddas> Well, that's what I'd think :-)
02:53:42 <vegai> in a nutshell: reading one line of Haskell code is potentially much more difficult a task than reading one line of C code.
02:53:52 <Cale> potentially
02:54:11 <Cale> I've seen some pretty bad lines of C code :)
02:54:14 <shapr> maybe much more informative as well?
02:54:17 <vegai> (of course, you could do a horrible C line with weird casts and pointer things, but it's hardly idiomatic)
02:54:19 <Maddas> shapr: Exactly!
02:54:33 <shapr> Idiomatic Haskell code is readable, I think.
02:54:35 <Maddas> And you'll need a lot more 'easy' lines than hard lines unless I misunderstood what you mean.
02:54:46 <shapr> But hey, I have a good idea on how to approach this..
02:54:56 <Maddas> A competition of sorts? :-)
02:54:56 <Cale> It's just that C has fewer abstractions around.
02:55:06 <vegai> sure, if we're talking about the whole, reading C is probably more difficult
02:55:12 <Cale> If you understand the abstractions well, then you can read them at the same rate as anything else
02:55:15 <Cale> they go away
02:55:21 <shapr> Yes! CosmicRay wants to make a version of the Great Computer Language Shootout, but instead the Great Computer Language Beauty Contest.
02:55:29 <Cale> as a beginner, there's a steeper hill to climb though
02:55:36 <Maddas> shapr: Hah :-)
02:55:36 <vegai> but the difference is, that with C, you usually can always move at least a bit forward
02:55:47 <Cale> you can with Haskell too :)
02:55:58 <shapr> Rather than comparing for speed, judge code samples according to how well they communicate. Let's treat code as literature and art!
02:56:02 <Cale> you just recursively look up definitions until you hit something that you know
02:56:14 <Maddas> vegai: Is it possible that the Haskell code you're thinking of is solving harder problems than the C code you're thinking of?
02:56:18 <eivuokko> shapr, what libraries are allowed in contest?
02:56:43 <astrolabe> Cale: By that argument, maths should be easy too
02:56:45 <shapr> eivuokko: I don't know, there aren't any set rules yet. The whole idea is to study code as communication with other humans.
02:56:50 <vegai> Maddas: yes, often it is
02:57:19 <Speck> since the identity relation is reflexive, antisymmetric, and transitive, does that make it a partial ordering?
02:57:25 <eivuokko> shapr, I see.
02:57:26 <shapr> I wrote a bit about that in the Shootout mailing list ... http://lists.alioth.debian.org/pipermail/shootout-list/2005-March/001296.html
02:57:27 <Maddas> vegai: In that case, I don't see the point of the comparison :-) Solving hard problems requires more thought than solving easy problems, either that or I've done something wrong the last ten years :-)
02:57:37 <astrolabe> Speck: yes
02:57:44 <Speck> astrolabe: thanks again :-P
02:57:54 <Cale> astrolabe: I'm not saying it's easy for a beginner, I'm saying it's easy once you know the abstractions involved
02:58:16 <vegai> Maddas: well, I was talking more about understanding existing code than writing new code
02:58:17 <Maddas> vegai: And spreading code out will also make it hard to follow at some point. Understanding a line doesn't help if you can't remember the context or the point of the line.
02:58:22 <Maddas> vegai: Me too.
02:58:46 <glguy> a good c function shouldn't span more than a screen full
02:58:47 <vegai> it's possible to write good code in C as well :)
02:58:55 <glguy> so at least you can try to keep the context viewable :)
02:59:19 <Maddas> vegai: Certainly, but isn't that going to be more 'dense' (ideas per line of code) than the code that is easier to read line-by-line? :-)
02:59:30 <astrolabe> Yeah.  The coder is more important than the language.
03:00:13 <astrolabe> But, given that we're all excellent coders ...
03:00:20 <shapr> Abstractions are all about sweeping the accidental details under the carpet so you can stare at the essential details.
03:00:34 <Maddas> Indeed.
03:01:36 <Cale> yes, exactly
03:02:22 <Cale> It's frustrating if you're reading something and it's at a different level of abstraction than you're used to.
03:02:44 <Maddas> Cale: Or very enlightening :-)
03:02:57 <Cale> possibly, if it's one step up, say
03:03:09 <Cale> (or even one step down in some cases)
03:03:11 <shapr> It can be fun though. When I read the source code for arrow based functional reactive programming, my first thought was, "Where's all the CODE?"
03:03:16 <vegai> Maddas: hmm, I guess.
03:03:35 <astrolabe> So learning haskell is like saving up for a good telescope (your desiratum here).  Short term pain for long term gain.
03:03:36 <vegai> shapr: indeed. Did you find it? :P
03:03:48 <glguy> Does this seem unnecessarily hard to read: zipWith (map . flip (/)) diags a
03:03:54 <Maddas> vegai: My point is just that solving hard problems is hard :-) If you take a less steep approach, you'll just need to walk longer until you reach the top of the hill.
03:03:58 <Cale> astrolabe: yeah
03:04:00 <shapr> vegai: Oh yeah, it was all right there in front of me, but it was pared down to the essentials of the essentials.
03:04:27 <Cale> glguy: If it involves flip, I usually just use lambda.
03:04:30 <shapr> It's amazing how much new abstractions can simplify old problems.
03:04:31 <glguy> where diags is a [Double] and a is a [[Double]]
03:04:36 <glguy> Cale, sounds good
03:04:59 <Maddas> vegai: Though I know the feeling of staring at something and wishing it was written in a simpler -- if more tedious -- fashion, though that usually passes, especially so once you understand what it does.
03:05:27 <glguy> Cale, zipWith (\x -> map (/x)) diags a
03:05:31 <glguy> is happier?
03:05:31 <Maddas> (Heh, that's the short term pain for long term gain that astrolabe was speaking of, I guess)
03:05:43 <Cale> glguy: I think so :)
03:06:03 * glguy just trying to get a feel for "idiomatic" (?) Haskell code
03:06:18 <Cale> glguy: well, there's a spectrum of idioms
03:06:21 <shapr> I still don't understand comonads enough to use them :-( I'm an abstraction collector and it frustrates me to have one right in front of me that I can't grasp!
03:06:28 <Maddas> Incidentally, "steep learning curve" has bad connotations, right? (Why? Isn't learning more better? :-))
03:07:01 <vegai> is learning more harder better? :)
03:07:02 <metaperl> Haskell has really improved my Perl programming as of late. "The Haskell Road.." is definitely the clearest presentation of the language
03:07:03 <Cale> shapr: given that they're functors, try thinking about them as containers, like monads :)
03:07:11 <astrolabe> Learning is a painful experience.
03:07:24 <shapr> Cognitive dissonance?
03:07:25 <Maddas> right, but whether the curve is steep or not isn't relevant to how much you learn
03:07:34 <shapr> Cale: I'll try that.
03:07:44 <Maddas> (Maybe I'm just plotting the wrong things, though)
03:07:59 <Maddas> astrolabe: Only when it's not loads of fun :-)
03:08:30 <astrolabe> Maddas: yeah, it can be fun too.
03:08:47 <shapr> But look at what Hamming says - "Knowledge and productivity are like compound interest. Given two people of approximately the same ability and one person who works ten percent more than the other, the latter will more than twice outproduce the former. The more you know, the more you learn; the more you learn, the more you can do; the more you can do, the more the opportunity - it is very much like compound interest."
03:09:02 <Maddas> shapr: Hah, nice quote.
03:09:48 <astrolabe> I think there is a painful stage where you are confused, and if you are lucky, a pleasant 'aha' moment.
03:10:06 <Maddas> I don't think the painful stage is necessary in general.
03:10:10 <gour> metaperl, how do you compare it with craft of fp?
03:10:18 <glguy> @pl next v = zipWith (-) b' (map (innerProduct v) a')
03:10:18 <lambdabot> next = zipWith (-) b' . flip map a' . innerProduct
03:10:43 <shapr> astrolabe: Happily, #haskell can help with the aha moments.
03:10:46 <gour> metaperl, how much of craft book you've covered so far?
03:11:04 <Maddas> Time to get some work done, later all :-)
03:11:16 <astrolabe> shapr: right
03:14:19 * Cale wants to better understand adjunctions
03:14:33 <shapr> Cale: Write a tutorial! That always works for me.
03:15:35 <Cale> hmm
03:16:40 <boegel|home> dons: my benchmark finished executing after 89hours :)
03:18:51 <Cale> I think I need more Haskellish examples. I wonder how many common monads arise out of adjunctions
03:19:53 <shapr> Can you work the other way to start? Maybe show adjunctions for common Haskell monads?
03:20:13 <Cale> that would be good
03:20:14 <glguy> seems like there should be a way to write   b `zipWith (-)` a
03:20:48 <glguy> without doing something like    where something = zipWith (-) and then using `something`
03:23:43 <Cale> glguy: well, if you're doing a lot of that, it helps to define functions like x .-. y = zipWith (-) x y somewhere
03:23:59 <Cale> but yeah, you can't put arbitrary expressions inside backticks
03:36:20 * joelr waves
03:38:03 <joelr> why is this so quiet
03:38:08 <joelr> eerie
03:38:13 <Cale> hi
03:38:16 <xerox> :)
03:38:22 <joelr> ah, the usual suspects
03:38:26 <joelr> hehe
03:38:41 <joelr> where are you guys geographically?
03:38:47 <Cale> Canada
03:38:51 <joelr> @where Cale
03:38:52 <lambdabot> I know nothing about cale.
03:38:55 <Cale> @map
03:38:55 <joelr> @where xerox
03:38:55 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
03:38:56 <lambdabot> I know nothing about xerox.
03:38:56 <joelr> hehe
03:39:01 <Cale> look at the map!
03:39:10 * joelr knows where canada is
03:39:23 <xerox> haha, @where person sounds too much 'FBI'-like
03:39:30 * joelr recently relocated to the canaries
03:39:32 <Cale> the map knows the location of my house
03:39:38 <joelr> wow
03:39:45 <Cale> 43.138651   -80.222222   "Cale"      align=above # Cale Gibbard
03:39:59 <Cale> if google maps is accurate, at least :)
03:40:02 <joelr> hey, how come it doesn't show me?!
03:40:13 <Cale> because you probably haven't added yourself
03:40:19 <Cale> heh
03:40:20 <joelr> how do i add meself?
03:40:41 <Cale> at the bottom, if you're logged into the wiki, there's a link which says EditText
03:41:01 <Cale> and you can add your latitude/longitude
03:41:32 <Cale> the pictures get updated regularly
03:41:47 <joelr> i'm looking for the registration page
03:41:58 <joelr> plus, how do i know my latitude/longitude?
03:42:05 <lisppaste2> joelr pasted "lift me please" at http://paste.lisp.org/display/13115
03:42:06 <Cale> upper right hand corner of every page, there's a link
03:42:20 <joelr> this is separate, btw :) as always i need help with something
03:42:45 * Cale wonders what those character entities are
03:43:30 <Cale> joelr: perhaps   Just (ssl', tob, fromb) <- ...
03:43:41 <Cale> or
03:43:49 <joelr> Cale: i want a guard, sort of
03:43:52 <Cale> x <- liftIO $ timeout 0 startSSL
03:43:55 <tuomov> hmm.. google maps resolution is quite poor in .fi
03:44:08 <joelr> meaning that if these result in nothing then i want the computation to stop
03:44:18 <Cale> case x of Nothing -> ...; Just (ssl', tob, fromb) -> ...
03:44:40 <joelr> Cale: i thought the whole purpose of the Maybe monad was to avoid doing things like that
03:44:46 <tuomov> aside from the beehive, that is
03:45:52 <shapr> tuomov: Helsinki/Espoo/etc?
03:45:56 <tuomov> yep
03:46:04 <glguy> what am I doing wrong here... : data Rank = A | 2 | 10 | J | Q | K
03:46:10 <tuomov> and a few other random blobs in the middle of nowhere, it appears
03:46:37 <tuomov> but for e.g. tampere and jyväskylä buildings are hardly detectable
03:47:48 <musasabi> it's quite good for Espoo, but when I tried to use it for Kirkkonummi or Lapland there was little hope.
03:48:04 <joelr> since I'm in a maybe monad i thought that any computations returning nothing will just stop the whole sequence
03:48:14 <pesco> glguy: Whats 2+10?
03:48:29 <glguy> I fixed it by changing the numbers to words
03:48:37 <glguy> 2 -> Two and 10 -> Ten
03:48:45 <tuomov> the city of jyväskylä does have a rather good and detailed aerial picture map online, though
03:49:02 <musasabi> joelr: Nothing `mplus` Just 2 == Just 2
03:49:17 <tuomov> don't know about tampere... they switched to java crap a year or few ago and that is when I switched to dead-tree map
03:49:44 <joelr> musasabi: thanks for this helpful bit of information ;)
03:49:53 <joelr> but if i'm doing
03:50:18 <joelr> do { a; b; c ; d } in a maybe monad i thought it will return nothing when either a b or c, etc. return nothing
03:50:21 <joelr> or d
03:51:06 <musasabi> yes, that should be true.
03:51:10 <joelr> and i am in a maybe monad type EngineState = MaybeT (WriterT [Log] (StateT World IO))
03:51:51 <joelr> so then why doesn't this work?
03:51:51 <joelr>  http://paste.lisp.org/display/13115
03:52:38 <joelr> timeout :: forall a.Int -> IO a -> IO (Maybe a) <--- should ensure that Nothing is returned for timeout and the computation stops, right?
03:55:04 <joelr> or i suppose that i'm mixing things up here
03:55:33 <joelr> and despite the computation stopping on Nothing, the types on the left side of <- still have to be Maybe a
03:56:51 <joelr> the strange thing is that h is assigned to socket :: Handle and brings out no complaints from ghc
04:01:00 <neadjneki> hi! is there any documentation for com-1.0? (part of visual haskell)
04:03:34 <glguy> @index lex
04:03:34 <lambdabot> Text.Read, Prelude, Text.Read.Lex
04:06:22 <joelr> btw, cale's solution was right
04:06:25 <joelr> it needs to be
04:06:37 <joelr>     do Just h <- liftIO $ timeout 0 $ connect_ h p
04:06:37 <joelr>        Just (ssl', tob, fromb) <- liftIO $ timeout 0 startSSL
04:06:45 <xerox> SSL? woo!
04:06:49 <joelr> since there's no other condition
04:06:59 <joelr> xerox: yeah, ssl, bio, zlib, etc.
04:07:38 <joelr> this is somewhat mind-twisting, though, as i thought it would generate an error
04:07:43 <joelr> but it doesn't and that's cool
04:08:00 <joelr> nothing -> computation exits so there's only Just ... left
04:08:07 <joelr> cool hack to stash away
04:10:44 <glguy> anyone have good examples on how to write a reads parser?
04:11:25 <glguy> I want to turn things like 10 S J H into [Card Ten Spades, Card Jack Hearts]
04:18:55 <kolmodin> glguy: you might want to have a look at parsec
04:19:09 <kolmodin> if it hasn't to be reads
04:19:53 <kolmodin> if you want it to be reads, I think there is a chapter about that in the gentle introduction to haskell
04:31:37 <sylvan> glguy, you can use readP_to_S in Test.ParserCombinators.ReadP
04:32:42 <joelr> oops, the cool hack did not work :(
04:32:49 <joelr> is there a better way to do this?
04:33:14 <joelr>     do m'h <- liftIO $ timeout 0 $ connect_ h p
04:33:14 <joelr>        guard $ m'h /= Nothing
04:33:14 <joelr>        m'ssl <- liftIO $ timeout 0 startSSL
04:33:26 <joelr> or given that these is in a maybe monad i don't need the guard
04:35:00 <sylvan> So this is a Maybe monad with an inner IO monad?
04:35:53 <joelr>  http://paste.lisp.org/display/13115
04:36:03 <joelr> sylvan: i think so, take a look at the past
04:36:09 <sylvan> check
04:36:26 <lisppaste2> joelr annotated #13115 with "any better way?" at http://paste.lisp.org/display/13115#1
04:37:16 <joelr> sorry, i forgot the let
04:37:30 <sylvan> ah.. I was just wonderinb about that =)
04:38:17 <sylvan> what's that last bit? Why are you using a case there if you're not pattern matching against anything?
04:38:44 <joelr>        let h = case m'h of (Just h) -> h
04:38:44 <joelr>        let (ssl', tob, fromb) = case m'ssl of Just a -> a
04:38:50 <joelr> this is what it should look like
04:39:01 <joelr> sylvan: is that what you are asking about?
04:39:04 <sylvan> yes
04:39:16 <sylvan> I don't think you should pattern match against Just and Nothing while inside the maybe monad
04:39:21 <joelr> sylvan: i'm saving h and the triple later on
04:39:41 <joelr> sylvan: well, i tried this before, like this, and got a runtime pattern matching failure
04:39:42 <sylvan> m'h isn't of type "Maybe Handle", it's just "Handle"
04:39:59 <joelr> *** Exception: Pattern match failure in do expression at ./Script/Engine.hs:103:
04:39:59 <sylvan> the <- extracts the value of the right hand side, if it's not Nothing
04:40:03 <joelr> which looked like this
04:40:14 <joelr> h <- liftIO $ timeout 0 $ connect_ h p
04:40:26 <joelr> (Just h) <- liftIO $ timeout 0 $ connect_ h p
04:40:36 <sylvan> That's your problem
04:40:37 <joelr> sylvan i tried it without the matching
04:40:42 <sylvan> ah
04:40:44 <joelr> sylvan: see earlier paste
04:40:45 <sylvan> hmm... that should work
04:40:57 <joelr> and the error that ghc was giving me
04:41:41 <joelr> sylvan: you saw the original error and code, right? i would have thought it's the way to go but it does not compile
04:41:56 <sylvan> yes
04:42:02 <joelr> and with the (Just h) <- ... variant it's possible to get a runeimt pattern matching error apparently
04:42:09 <joelr> so what's the scoop?
04:42:25 <sylvan> hmm.. Well the IO stuff is at the very inner monad.. It's inside, writer and state... does liftIO really work in that case?
04:42:48 <joelr> i'm using a MaybeT transformer :-) and it has a liftIO
04:43:55 <sylvan> I haven't really done much of this but I think you need to "lift" the function into the first inner monad (WriterT) and then lift again into the one inside that (StateT) and then again into the one inside that one (IO).. So you need something like let myLiftIO = lift . lift . lift
04:44:06 <sylvan> this is just a not-very-well-educated-guess though...
04:44:10 <joelr> sylvan: interesting
04:44:16 <joelr> sylvan: let me post to haskell-cafe then
04:44:22 <joelr> sylvan: thanks
04:44:25 <sylvan> np
04:50:58 <kolmodin> joelr: a monad transformer working around a monad which instances MonadIO should also implement MonadIO
04:51:27 <joelr> kolmodin: does this work for you? :)
04:51:27 <joelr> instance (MonadIO m) => MonadIO (MaybeT m) where
04:51:28 <joelr>     liftIO = lift . liftIO
04:51:47 <Cale> sylvan: I think you actually lift outwards
04:51:58 <Cale> lift goes from the inner monad to the outer one
04:52:22 * joelr just posted the whole shebang to haskell-cafe, for those interested
04:52:30 <joelr> this is a great mistery for me
04:52:45 <joelr> looks like the Maybe monad is not doing what it's supposed to. "not doing"
04:52:46 <kolmodin> joelr: I was about to post you something like that
04:53:11 <Cale> sorry, I missed the actual question, as people were getting up, and I went and got a coffee :)
04:53:15 <Cale> I'll read the post
04:53:23 <joelr> http://paste.lisp.org/display/13115
04:53:29 <joelr> Cale: it's the same
04:53:33 <Cale> oh
04:53:44 <joelr> Cale: the paste has been annotated, though
04:54:23 <Cale> hmm
04:54:28 <lisppaste2> joelr annotated #13115 with "small syntax fix" at http://paste.lisp.org/display/13115#2
04:54:33 <Cale> heh
04:54:40 <Cale> I was just about to complain
04:54:55 <Cale> also, don't forget the Nothing case
04:55:12 <Cale> let (ssl', tob, fromb) = case m'ssl of a -> a
04:55:22 <Cale> that case is needless
04:55:26 <joelr> this seems stupid
04:55:27 <joelr>        m'ssl <- liftIO $ timeout 0 startSSL
04:55:27 <joelr>        guard $ m'h /= Nothing && m'ssl /= Nothing
04:55:27 <joelr>        let h = case m'h of (Just h) -> h
04:55:52 <joelr> i thought the Maybe monad is supposed to fail on nothing
04:55:53 <joelr> dammit
04:56:03 <Cale> it is
04:56:15 <Cale> and you'll get a Nothing result
04:56:16 <sylvan> It does fail on nothing, so you shouldn't need to look for Nothing or Just
04:56:22 <joelr> Cale: well, then it should not get to the guard, right? and to the let
04:56:25 <Cale> oh
04:56:27 <Cale> right
04:56:31 <joelr> yes, but
04:56:32 <Cale> this is a bit silly :)
04:56:52 <joelr> i had the (Just h) <- ... in there and it gave me a runtime pattern matching failure
04:57:05 <sylvan> it _should_ work to just have h <- ..
04:57:08 <joelr> and it does not compile with just h <- liftIO $ timeout ...
04:57:24 <joelr> it will work if it compiles :) but it doesn'
04:57:28 <Cale> okay, you need to follow the types of all this stuff :)
04:57:40 <joelr> Cale: how exactly?
04:57:46 <neadjneki> the return type should be Maybe IO () ?
04:57:58 <joelr> return type of what?
04:57:59 <Cale> okay, you're writing a value of type EngineState ()
04:58:04 <Cale> type EngineState = MaybeT (WriterT [Log] (StateT World IO))
04:58:09 <joelr> yes
04:58:25 <Cale> liftIO :: IO a -> EngineState a
04:58:35 <Cale> and it should never ever fail
04:58:39 <Cale> that is
04:58:45 <Cale> you'll always get a Just x
04:58:57 <joelr> Cale: so i had that and got a pattern matching failure :D
04:59:02 <Cale> okay
04:59:19 <joelr> Cale: i had (Just h) <- liftIO $ timeout 0 $ connect ...
04:59:37 <joelr> and it bombed with *** Exception: Pattern match failure in do expression at ./Script/Engine.hs:103:
04:59:42 <sylvan> the <- "unpacks" the Just since you're in the Maybe monad
04:59:43 <Cale> hmm, that ought to be a compile time failure
05:00:17 * joelr wonders who's right, sylvan or Cale ;)
05:00:31 <Cale> well, we agree
05:00:37 <sylvan> I don't think we're saying different things =)
05:00:52 <Cale> joelr: did you have that type sig there in the code when you wrote that?
05:01:01 <joelr> sylvan says <- unpacks, cale says you need (Just h) <-
05:01:05 <Cale> no
05:01:08 <sylvan> did he say that?
05:01:11 <Cale> you don't need (Just h) <-
05:01:18 <joelr> Cale: which type sig?
05:01:23 <Cale> I misinterpreted what you were trying to do before
05:01:26 <Cale> connect :: [Prop] -> HostName -> Int -> EngineState ()
05:01:33 <joelr> in the paste
05:01:41 <joelr> connect :: [Prop] -> HostName -> Int -> EngineState ()
05:01:59 <Cale> was that in the code you compiled and got a pattern match failure from?
05:02:01 <joelr> Cale: yes, i had it there all along
05:02:04 <Cale> hmm
05:02:10 <joelr> but
05:02:20 <Cale> what's the type of timeout?
05:02:25 <joelr> when i got the pattern matching failure, i had (Just h) <- ...
05:02:46 <Cale> yes, the compiler shouldn't have allowed that at all
05:02:48 <joelr> since <- unpacks then i would have gotten (Just Handle) <- Handle which is a pattern matching failure, right
05:02:56 <Cale> ah
05:02:58 <sylvan> Uh.. if connect is of type EngineState (), why do you lift it?
05:02:58 <Cale> okay
05:03:02 <joelr> timeout :: forall a.Int -> IO a -> IO (Maybe a)
05:03:21 <joelr> sylvan: i don't lift connect, i think
05:03:21 <Cale> So the arrow unpacked the EngineState, but you had an EngineState (Maybe a)
05:03:23 <Cale> okay
05:03:25 <Cale> haha
05:03:27 <Cale> right
05:03:38 <joelr> sylvan: connect_ :: HostName -> Int -> IO Handle
05:03:41 <joelr> notice the underscore
05:03:46 <sylvan> ah...
05:03:47 <Cale> which is confusing because you have multiple levels of Maybe
05:04:00 <joelr> so
05:04:02 <joelr> lets see
05:04:09 <joelr> i'm gonna try to remove the crud
05:04:37 <sylvan> ah... You need to translate the Maybe into the MaybeT
05:04:42 <Cale> yeah
05:05:08 <joelr> this is how it's supposed to be, right?
05:05:08 <joelr>     do h <- liftIO $ timeout 0 $ connect_ h p
05:05:09 <joelr>        (ssl', tob, fromb) <- liftIO $ timeout 0 startSSL
05:05:09 <Cale> ought to be a function EngineState (Maybe a) -> EngineState a
05:05:13 <joelr> where do i translate?
05:05:45 <joelr> magic lifting someplace? where exactly?
05:06:08 <Cale> hmm
05:06:24 <Cale> okay
05:06:31 <joelr> cause i have a lot of places where i'm just assuming that a nothing within EngineState() will fail the computation
05:06:49 <Cale> mergeMaybe :: EngineState (Maybe a) -> EngineState a
05:07:17 <joelr> and the definition of it ?
05:07:29 <Cale> mergeMaybe k = do { v <- k; case k of Just x -> return x; Nothing -> mzero }
05:07:34 <joelr> hmm
05:07:57 <joelr> Cale: and how would i use it?
05:07:59 <kolmodin> isn't that what 'join' does?
05:08:00 <Cale> this actually has a more general type
05:08:09 <Cale> join couldn't possibly do that
05:08:20 <kolmodin> ok :)
05:08:42 <Cale> (because it applies to general monads, and this requires MonadPlus)
05:08:48 <Cale> joelr: okay
05:08:58 <Cale> h <- mergeMaybe $ liftIO $ timeout 0 $ connect_ h p
05:09:12 <Cale> then you should be cool
05:09:34 <joelr> Cale: let me try!
05:09:39 <Cale> they should bring back MonadZero
05:09:45 <Cale> it's a good idea
05:10:05 <Cale> also, the Boston rag
05:11:47 <joelr> Cale
05:11:56 <joelr>     Couldn't match `MaybeT (WriterT [Log] (StateT World IO)) (Maybe a)'
05:11:57 <joelr>            against `Maybe a1'
05:12:18 <Cale> hmm... could I see the whole piece of code?
05:12:30 <Cale> you shouldn't have any extra maybe-unpacking to do
05:12:34 <lisppaste2> joelr annotated #13115 with "mergeMaybe" at http://paste.lisp.org/display/13115#3
05:13:01 <joelr>     do h <- mmerge $ liftIO $ timeout 0 $ connect_ h p
05:13:01 <joelr>        (ssl', tob, fromb) <- mmerge $ liftIO $ timeout 0 startSSL
05:13:04 <joelr> like this, right?
05:13:24 <joelr> but i get the error
05:13:27 <lisppaste2> Cale annotated #13115 with "mergeMaybe" at http://paste.lisp.org/display/13115#4
05:13:44 <Cale> that code works, I tried it :)
05:13:48 <joelr> Cale rocks
05:14:27 <neadjneki> case k vs. case v :)
05:14:42 <Cale> ah
05:14:48 <Cale> yeah, I typoed that
05:14:52 <Cale> sorry
05:14:54 <joelr> i put that in the maybet
05:15:19 <Cale> ought to be case v
05:16:29 <Cale> nice how you can eat a maybe like that
05:16:41 <joelr> i'm compiling the whole thing
05:16:42 <Cale> I suppose you could also eat a list in the same way
05:16:44 <joelr> engine that is
05:16:56 <joelr> this would remove a log of ugly code
05:17:48 <joelr> what do you do about this?
05:18:11 <musasabi> Has anyone created a simpler interface to Gtk2Hs list views ?
05:18:18 <joelr>        let size' :: Maybe (LE Word16) = fst $ evalU fps appU
05:18:18 <joelr>        guard $ size' /= Nothing
05:18:19 <joelr>        let size = case size' of (Just size) -> fromIntegral $ size - 4
05:18:46 <joelr> evalU :: forall a.PU a => P.FastString -> UMonad a -> UEResult a
05:18:53 <joelr> where type UEResult a = (Maybe a, [String])
05:19:13 <joelr> i guess it needs the guard in here, does it?
05:19:43 <joelr> or do i just mergeMaybe here?
05:19:59 <Cale> oh, you can avoid the cases
05:20:03 <Cale> fromJust
05:20:04 <astrolabe> What is 'logical not' in haskell?
05:20:10 <Cale> not
05:20:14 <xerox> @type not
05:20:15 <lambdabot> Bool -> Bool
05:20:16 <Cale> @eval not True
05:20:17 <lambdabot> False
05:20:31 <astrolabe> Cale: is there a symbol?
05:20:34 <Cale> no
05:20:38 <joelr> Cale: what's fromJust?
05:20:40 <astrolabe> thanks
05:20:42 <Cale> @type fromJust
05:20:43 <xerox> @type Maybe.fromJust
05:20:44 <lambdabot> Not in scope: `fromJust'
05:20:44 <lambdabot> forall a. Maybe a -> a
05:21:04 <Cale> @eval fromJust (Just 5)
05:21:05 <lambdabot> 5
05:21:09 <Cale> @eval fromJust (Nothing)
05:21:10 <lambdabot> Add a type signature
05:21:14 <Cale> @eval fromJust (Nothing) :: Int
05:21:16 <lambdabot> Maybe.fromJust: Nothing
05:21:23 <Cale> (that's an error)
05:21:35 <xerox> Which<Interrupted by Cale>
05:21:44 <Cale> hehe
05:22:25 <joelr> Cale: forgive me for being dumb... 1) Nothing returned by evalU, does that interrupt the computation when returned in a let
05:22:37 <joelr>        let size' :: Maybe (LE Word16) = fst $ evalU fps appU
05:22:39 <joelr> like this
05:23:20 <joelr> or are you saying this should be written as let size = fromJust $ fst $ evalU fps appU since there will never be a Nothing here
05:26:20 <joelr> am i lagging
05:26:22 <joelr> ?
05:28:21 <Cale> no, I am :)
05:28:30 <Cale> lag caused by walking out of the room
05:28:50 <dcoutts_> ibid, you about?
05:29:05 <Cale> joelr: you use that case to unpack the thing
05:29:22 <Cale> joelr: fromJust is equivalent to your one-branch case
05:29:28 <joelr> ah!
05:29:37 <joelr> but what about let interrupting the computation?
05:29:48 <Cale> let will never do that
05:29:48 <joelr> does it? do i need a mergeMaybe?
05:30:00 <Cale> let only makes local definitions
05:30:05 <joelr> Cale: so then i _do_ need the guard, right?
05:30:05 <musasabi> dcoutts_: did anything come out of the "Implementing tree/list data models in Haskell" ?
05:30:12 <Cale> joelr: or something equivalent
05:30:28 <Cale> you could also use the case along with mzero
05:30:39 <Cale> let size' :: Maybe (LE Word16) = fst $ evalU fps appU
05:31:02 <Cale> size <- case size' of
05:31:15 <Cale>     Just s -> fromIntegral (s - 4)
05:31:20 <Cale>     Nothing -> mzero
05:31:28 <dcoutts_> musasabi, I'm going to look at that again after the current release is out of the way.
05:31:35 <Cale> er
05:31:38 <dcoutts_> musasabi, I want that feature for hIDE too.
05:31:44 <Cale> return $ fromIntegral...
05:31:50 <musasabi> nice.
05:32:01 <joelr> Cale: aha! thank you!
05:32:04 <Cale> dcoutts: "Implementing tree/list data models in Haskell" ?
05:32:12 <dcoutts_> musasabi, I had a first go at implementing it. It got a trivial one working.
05:32:29 <musasabi> Just giving a newListView :: IO ListView; setListViewTo :: ListView -> [String] -> [[String]] -> IO (); onButtonPress :: ListView -> (Int -> IO ()) would suffice for me.
05:32:42 <joelr> Cale: this can be abstracted away into a function, right?
05:32:50 <musasabi> that is onButtonPress :: ListView -> (Int -> IO ()) -> IO ()
05:33:08 <joelr> Cale: doesn't this look like mergeMaybe?
05:33:11 <Cale> joelr: I suppose we already have
05:33:12 <Cale> yeah
05:33:14 <dcoutts_> musasabi, and what do all those parameters mean exactly?
05:33:16 <joelr> Cale: with fromIntegral
05:33:33 <dcoutts_> Cale, the Gtk+ tree/list widgets can use custom data models. So we'd like to be able to define them in Haskell.
05:34:02 <joelr> Cale: right?
05:34:22 <musasabi> dcoutts_: setListViewTo listView ["Col1","Col2","Col3"] [["ValA1","ValA2","ValA3"],...,["ValN1","ValN2","ValN3"]]
05:34:41 <dcoutts_> ok
05:34:57 <musasabi> not very efficient but very nice for quick apps with small amount of data.
05:35:00 <Cale> joelr: yeah
05:35:11 <joelr> Cale: let me try that
05:35:14 <dcoutts_> musasabi, that function can be defined already
05:35:27 <dcoutts_> musasabi, using the ListStore
05:36:10 <Cale> size' <- mergeMaybe $ return $ fst $ evalU fps appU
05:37:07 <joelr> cool :-)
05:39:22 <Cale> I like how as polymorphism increases, the number of ways to write a function drops
05:39:42 <Cale> so by generalising the types of your functions as far as possible, you make them easier to write
05:40:06 <Cale> (or harder to write incorrectly, anyway)
05:41:37 <joelr> i like how haskell makes it easy to write correct code
05:41:47 <joelr> i had to do barely any debugging in my code
05:42:00 <Cale> yeah, the compiler does most of the work
05:42:04 <joelr> granted, i forgot how to set breakpoints a year ago when i started with lisp and then moved to erlang
05:42:13 <joelr> but still, there was a lot of debugging in both lisp and erlang
05:42:37 <joelr> i know this sounds like an infomercial but i haven't even felt the need for quickcheck :D
05:42:59 <joelr> haskell let me concentrate on overdelivering instead of debugging
05:43:15 <Cale> oh, I had to write some lisp code a while ago, and I was utterly perplexed at how people say they like dynamic typing -- almost all of my bugs were things which should have been caught by a typechecker
05:44:16 <Cale> I haven't written too much code in other languages since I learned Haskell.
05:45:03 <Cale> If it can be done in Haskell, that's where I'll do it, because I can feel a lot more confident that a given piece of code will do what I intend.
05:46:29 <joelr> Cale: what do you code for a living?
05:47:31 <Cale> Well, I've coded Haskell for a summer job (wrote a pipeline scheduler). I've just finished my undergrad degree, and I'm figuring out what to do next.
05:47:41 <Cale> (and relaxing a bit)
05:48:00 <Cale> My undergrad degree was in pure mathematics
05:48:28 <joelr> Cale: cool
05:48:42 <Cale> I'd like get a mathematical research position at some point, but I'm not sure what I want to do right away.
05:49:06 <Cale> I'm thinking I might apply to McMaster for a CS masters.
05:49:39 <joelr> does this look ugly?
05:49:40 <joelr>        size <- mergeMaybe $ return $ fst $ evalU fps appU :: EngineState (LE Word16)
05:50:02 <Cale> well, hmm...
05:50:18 <Cale> that EngineState monad is complicated
05:50:36 <Cale> are you sure that you need the full functionality of all the transformers?
05:50:58 <Cale> or can you wrap the special actions that each of the levels give you, and provide a cleaner interface?
05:51:39 <joelr> Cale: no idea :-) the way it works actually looks nice to me
05:51:50 <joelr> with the exception of some corner cases
05:52:20 <Cale> A simple example: Suppose you're writing a monad to play chess in. The computations are chess moves. You might use a state monad to carry around the state of the board, but not all modifications to that state should actually be valid.
05:52:49 <Cale> So what you'd do is to provide a bunch of actions to move chess pieces around in valid ways
05:53:16 <Cale> and then hide the newtype constructor by not exporting it from your module
05:53:22 <joelr> Cale: well, i'm sort of trying to do that, i think, with connect, etc.
05:53:28 <Cale> okay
05:53:34 <Cale> that's a good plan :)
05:53:50 <Cale> If you want an example -- maybe I pointed this out before, I'm not sure
05:54:13 <Cale> http://www.haskell.org/hawiki/MonadTemplateLibrary_2fMonadRandom
05:55:02 <Cale> note that unRT, unRand, and the RandomT, and Rand data constructors are not exported
05:55:47 <joelr> cool
05:56:23 <Cale> so there's no way that the computations can accidentally reuse the same random number generator state
05:57:11 <joelr> right
06:01:56 <shapr> Some people just make me crazy. It's worse if I have to live with them though.
06:02:17 * xerox knows the feeling
06:02:18 <jyp> -- woody allen
06:03:43 <ibid> dcoutts_: is was giving a lecture :)
06:04:00 <shapr> jyp: Did Woody Allen say that?
06:04:22 <jyp> he chould have, wouldn't he? :)
06:04:36 <shapr> Probably.
06:05:04 <Cale> I wonder for which n can one find a set of n disjoint solutions to the n-queens problem
06:10:53 <dcoutts_> ibid, I've pasted the stuff as a private chat message
06:12:53 <dcoutts_> juhp, ping
06:16:52 <ibid> i don't see it
06:17:08 <ibid> ah, the restriction again
06:17:12 <dcoutts_> ah yes
06:17:18 <dcoutts_> erm...
06:18:02 <ibid> private chan :)
06:18:07 <dcoutts_> heh
07:00:21 * dcoutts_ notes that Gtk2Hs is taking over: http://planet.gnome.org/news/
07:01:13 <xerox> @karma+ dcoutts -- :-)
07:01:14 <lambdabot> dcoutts's karma raised to 5.
07:01:15 <beelsebob_> yay... hat is finally tracing hoogle
07:08:32 <dcoutts_> thanks ibid!
07:08:59 <ibid> np :)
07:09:01 * dcoutts_ gets celebrity endorcements for Gtk2Hs :-)
07:09:07 <ibid> i always like free advertising :)
07:09:09 <xerox> :-)
07:10:42 * dcoutts_ wonders what IRC client to use which has non-broken unicode support
07:10:49 <xerox> I'm using Circe version from CVS (2005-10-19 17:14:33) with GNU Emacs 22.0.50.1 (of 2005-09-24)
07:10:55 <xerox> ^- :-)
07:11:09 <Cale> dcoutts_: X-Chat's support seems not too broken
07:11:18 <ibid> dcoutts_: yours doesn't answer to ctcp version, but i think that's the blockage again
07:11:22 <ibid> dcoutts_: what are you using?
07:11:40 <dcoutts_> X-Chat 1.4.3
07:11:43 <dcoutts_> err 2.4.3
07:12:02 <dcoutts_> Cale, how does this come out to you? "Jyv?skyl?"
07:12:13 <Cale> Jyv?skyl?
07:12:17 <dcoutts_> right
07:12:24 <xerox> Same here
07:12:28 <dcoutts_> see http://haskell.org/gtk2hs/ for the correct result
07:12:38 <Cale> if you don't have it set to UTF-8, it won't send UTF-8
07:12:41 <Cale> I don't think
07:12:46 <dcoutts_> how do I set that?
07:12:46 * ibid is using irssi with a script for handling multiple encodings
07:12:54 <xerox> Jyväskylä
07:12:59 * dcoutts_ pokes around in the setup
07:13:04 <Cale> Edit Freenode
07:13:10 <xerox> Did you see it?
07:13:23 <Cale> xerox: yeah
07:13:24 <dcoutts_> xerox, yes but without the non-ascii chars
07:13:42 <dcoutts_> ah!
07:13:45 <Cale> I get the dots over the ä's
07:13:59 <dcoutts_> I'll disconect and re-connect
07:14:01 <xerox> Cööl.
07:14:20 <xerox> Jyväskylä
07:14:23 <Cale> ä
07:14:23 <fatbrain> IRC should *upgrade* to Unicode.
07:14:26 <Cale> yes
07:14:28 <dcoutts_> "Jyv?skyl?"
07:14:28 <earthy> :)
07:14:31 <xerox> :-(
07:14:33 <Cale> dcoutts: :|
07:14:34 <ibid> dcoutts_: "?"
07:14:39 <Cale> hmm...
07:14:48 <earthy> Jäväskylä
07:14:50 <xerox> dcoutts_: can you type those a with two dots over?
07:14:53 <earthy> hmm.
07:14:54 <Cale> <earthy> JÃ¤vÃ¤skyÃlÃ¤
07:14:57 <fatbrain> 
07:14:58 <dcoutts_> did that come out right then? ""Jyv?skyl?"
07:15:11 <xerox> dcoutts_: interrogative points here :-|
07:15:12 * earthy thought that might come out garbled. :)
07:15:13 <Cale> dcoutts: the ä's are replaced by ?'s
07:15:14 <dcoutts_> xerox, huh?
07:15:23 <xerox> Jyv?..
07:15:32 <dcoutts_> oh :-(
07:15:37 <Cale> odd
07:15:43 <Cale> which version of X-Chat?
07:16:01 <Cale> well, it's been working for a long time anyway
07:16:06 <dcoutts_> 2.4.3 and I set the charset for FreeNode to UTF8
07:16:10 <Cale> yeah
07:16:11 <Cale> hmm
07:16:21 <Cale> really *ought* to work
07:16:24 * dcoutts_ tries properly shutting down X-Chat
07:17:30 <Cale> um...
07:20:34 <basti_> dcoutts: are you ok? ^^
07:23:10 <xerox> What a pain...
07:27:51 <sethk> I've been using 2.4.0 for quite a while, seems stable, in case updating might help
07:27:54 <Cale> αβγδεζηθικλμνξοπρστυφχψω
07:28:05 <CosmicRay> thanks cale, that was great.
07:28:33 --- topic: set to ' ["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051101"]' by CosmicRay
07:28:35 <Cale> CosmicRay: in all its unicode goodness, or misencoded gibberish?
07:28:38 <CosmicRay> the new HWN is out, yay
07:28:51 <CosmicRay> Cale: my xchat doesn't grok unicode for whatever reason, so I can't tell ;-)
07:28:55 <CosmicRay> it looks like random binary data
07:28:57 <Cale> ah
07:29:11 <Cale> You might not have a font with greek characters in it
07:29:31 <CosmicRay> no, my xchat doesn't grok unicode.  I've run into this before ;-)
07:29:38 <Cale> oh, okay :)
07:30:36 <xerox> Terminus got only some greek characters, unfortunately :)
07:31:04 * CosmicRay waits for people to notice why HWN was missing last week ;-)
07:31:45 <Cale> heh
07:32:47 <pesco> xerox: I'm using Terminus, and it looks pretty complete to me...
07:33:06 <CosmicRay> brb
07:33:15 <Cale> Andale Mono/Monotype.com has them all
07:33:27 <pesco> xerox: Oh, or is that gnome filling them in from other fonts? ...
07:33:40 <pesco> Fixed is also very complete.
07:34:11 <Cale> pesco: gnome will fill things in from other fonts if necessary
07:34:27 <pesco> I see, then I'm probably seeing the Andale Mono glyphs.
07:39:09 <xerox> pesco: oh, do you have any way to check?
07:40:06 <xerox> pesco: http://haskell.galois.com/~paolo/greek-1639-011105.png
07:41:54 * CosmicRay returns
07:42:52 * xerox tries to avoid the 'in which monad' joke
07:45:37 <goron> Richard M. Stallman, Linus Torvalds, and Donald E. Knuth
07:45:37 <goron> engage in a discussion on whose impact
07:45:37 <goron> on the computerized world was the greatest.
07:45:37 <goron> Stallman: "God told me I have programmed
07:45:37 <goron>  the best editor in the world!"
07:45:40 <goron> Torvalds: "Well, God told *me* that I have programmed
07:45:42 <goron>  the best operating system in the world!"
07:45:44 <goron> Knuth: "Wait, wait - I never said that."
07:45:50 <CosmicRay> hahah
07:47:19 <sylvan> hahaha
07:47:50 <Cale> heheheh
07:55:28 * xerox laughs :)
08:03:28 * shapr snickers at the C# interview...
08:03:51 <shapr> Anders Hejlsberg - "And, you know, honestly, first of all, let's give credit where credit is due. I am not inventing anything completely new here. It's all based on this thing called lambda expressions or lambda calculus or whatever, which has existed in the functional programming space for decades. But somehow, that has never really seen the light of day in a mainstream programming language."
08:04:42 <sylvan> what C#-interview?
08:04:59 <shapr> yup
08:05:05 <sylvan> where?
08:05:40 <dcoutts> basti_, yes thanks
08:05:46 <araujo> Hello!
08:06:13 <basti_> ^^
08:06:30 <shapr> sylvan: http://www.ondotnet.com/pub/a/dotnet/2005/10/31/interview-with-anders-hejlsberg-part-2.html?page=1
08:06:39 <shapr> also, I love privoxy :-)
08:06:40 <dcoutts> my xchat on my office machine kept dieing with a bus error :-)
08:06:45 <sylvan> thanks
08:06:46 <shapr> hola labra_
08:07:46 <dcoutts> shapr, yeah I saw people talking about this "crazy anonymous method" thing in the C# context :-)
08:09:25 <cinema> dcoutts, Have you seen the 'Harmonia' project at Berkeley http://harmonia.cs.berkeley.edu/harmonia/index.html
08:09:38 <cinema> dcoutts, in relation to hIde
08:10:12 <cinema> dcoutts, there is a plugin for XEmacs, there could be one for hIde
08:10:40 * CosmicRay sends in his HCAR entries.
08:10:40 * dcoutts checks it out
08:10:43 <CosmicRay> finally.
08:11:17 <dcoutts> "Harmonia can be used to augment text editors to robustly support the language-aware editing and navigation of documents, including those that are malformed, incomplete, or inconsistent"
08:11:20 <dcoutts> sounds cool
08:11:35 <dcoutts> thanks cinema, I was not aware of that
08:11:39 <cinema> I looked at it yesterday and found it interesting
08:11:58 <dcoutts> cinema, would you mind adding a link to it onthe hIDE/Design page?
08:12:07 <dcoutts> just so we don't forget
08:12:10 <kolmodin> someone who thinks microsoft is trying to be too clever by adding anonymous functions into C#: http://www.osnews.com/comment.php?news_id=12461
08:12:16 <cinema> dcoutts, OK I'll do it
08:12:43 <dcoutts> cinema, add it under the desirable plugins section
08:13:32 <cinema> dcoutts, OKgg
08:15:16 <shapr> Philippa_: I see that David B. Held hasn't responded to the various posts.
08:15:34 <goron> Cale: Do you remember we talked about Catalan numbers?
08:15:38 <xerox> Who cares, in the end.
08:15:44 <Cale> goron: yeah
08:16:24 <goron> Cale: Having a reference to a wikipedia article is not really "scientific". Any idea to what I could refer?
08:16:45 <Cale> almost any general text on combinatorics
08:16:52 <Cale> they show up everywhere
08:17:27 <goron> ok
08:22:36 * goron should download the whole of acm someday before graduation. 
08:23:14 <shapr> Or limit yourself to not-for-pay articles :-)
08:23:52 <goron> shapr: There are articles on acm that are free or do you mean avoid acm?
08:23:55 <shapr> Of course, I have the option to do that since I only read acm for fun.
08:24:22 <goron> ?
08:24:35 <shapr> I just mean that articles that are only available for money don't encourage science much.
08:25:09 * esap just found out about: http://www.improbable.com/airchives/paperair/volume2/v2i5/howto.htm 
08:25:10 <shapr> Most universities have a subscription to the big services, but not everyone who researches is at a university, and the big services get to charge pretty much whatever they want.
08:25:11 <goron> shapr: That's true. With the advent of Internet, I really don't see a need for the Elseviers of the world.
08:25:55 <goron> shapr: In the old days(as I understand it) those people helped to type set stuff.
08:25:57 <shapr> But because of the copyright policy of the journals, they'll keep those papers forevermore.
08:26:18 <vegai> agh, a programming language called Cool
08:26:30 <vegai> why do they insist on coming up with something ungooglable every time...
08:26:46 <vegai> (yeah, I found it already, but it took almost a minute :)
08:26:48 <shapr> What about a programming language called C? Does it get any worse?
08:27:01 <vegai> perhaps a programming language called
08:27:03 <dcoutts> @where yhc
08:27:04 <lambdabot> I know nothing about yhc.
08:27:07 <goron> shapr: We already have A,B,C and D. What about E?
08:27:07 <dcoutts> ba!
08:27:21 <esap> naming is hard. I've been trying to find a name for my programming language for many years, and I still don't have a good name for it.
08:27:22 <shapr> goron: e-rights.org, it's a capability based languaged.
08:27:45 <shapr> E is quite nifty. I'd even use it if weren't written in Java.
08:27:47 <vegai> Ocaml is pretty good in that sense
08:27:47 <xerox> There is E :D heh.
08:27:49 <goron> esap: What about esap?
08:28:23 <esap> goron: well that's a good name, but it already refers to something else :-)
08:28:39 <vegai> for a FP language, 'lambda' is a solid choice.
08:29:45 <vegai> or how about 'function'
08:29:51 <vegai> 'fun'!
08:30:31 <vegai> esap: but seriously, perhaps there are good Finnish words for this :)
08:31:25 <esap> vegai: Yes, that's a good approach, though probably fails the google test as well...
08:31:50 <esap> vegai: Would need to combine two words to get something unique and googlable.
08:32:55 <sylvan> If you're calling you FP language "lambda" you BETTER make it really solid! That's a big name to live up to
08:33:03 <jyp> Or you could use something really fancy, like हिन्दी
08:33:10 <xerox> ‽
08:33:28 <Maddas> esap: Do you know Knuth's quip on that topic?
08:33:30 * jyp laughs
08:33:37 <esap> Maddas: no
08:33:47 <pediddle> jyp, yay हिंदी
08:33:52 <xerox> What is it?
08:34:00 <Maddas> esap: "The most important thing in the programming language is the name. A language will not succeed without a good name. I have recently invented a very good name and now I am looking for a suitable language."
08:34:34 <jyp> xerox, hindi
08:34:43 <shapr> I find it easy to invent names. Now if only I could code as easily...
08:34:45 <esap> Maddas: I agree completely with that.
08:34:57 <Maddas> :-)
08:35:40 <esap> Although for me, I've already designed most of the language, and trying to find a name for it.
08:36:42 <pdzq> cbfvhgfhggfhd
08:36:52 <xerox> Err.. ?
08:36:54 <pdzq> It rolls off the tongue.
08:38:16 <vegai> have you people ever encountered trouble when trying to test functions with parameters Nothing or the empty list?
08:38:31 <sethk> after all, the most popular languages have really creative names, like, oh, C for example
08:38:35 <vegai> using HUnit
08:38:49 <esap> vegai: maybe you might need to specify the type
08:39:20 <esap> vegai: because both of those have universally quantified type.
08:40:04 <esap> vegai: the universal parameter needs to be bound to a concrete type before execution.
08:40:51 <vegai> yeah, I thought so too
08:41:02 <vegai> but oddly, only now I figured how to do it right
08:42:34 <goron> esap: Doesn't every 4 letter word refer to something already?
08:42:57 <esap> goron: I don't know, maybe.
08:43:11 <esap> goron: Three letter acronyms are pretty much taken already at least.
08:44:34 <goron> esap: Write an algorithm that finds something Google doesn't know.
08:45:09 <esap> goron: Heh, that's a nice idea!
08:48:43 <esap> though probably wouldn't find a good name, could find things I've (and everybody else) has missed :-)
08:51:26 <goron> esap: Yes, humans are biased. Although, I doubt whether the entire human race is.
08:56:04 <goron> Is it depth-first-search, depth-first search or depth first search? Everyone spells it differently.
08:56:34 <esap> I would use "depth-first search".
08:56:44 * esap is not native english though :-)
08:57:48 <goron> "The Free On-line Dictionary of Computing (27 SEP 03)"
08:57:50 <goron> depth-first search
08:58:07 <goron> Well, I will assume that then.
08:59:32 <sethk> with any reasonable search engine it shouldn't matter how you enter it
08:59:55 <Cale> all three of those are okay, though I agree with esap that "depth-first search" is the most correct. The hyphen there serves a purpose to disambiguate the parse so it's not "depth first-search".
09:00:29 <goron> Cale: It seems there are more words in English that can be written with or without hyphens.
09:00:46 <goron> Cale: E.g. floor-planning and floor planning.
09:00:52 <Cale> hyphens are basically always optional in English
09:01:12 <Cale> and over time, they degenerate
09:02:46 <Cale> You'll have some phrase that starts out separate, gets hyphenated for a while, and finally collapses into one word
09:04:44 <sethk> damn, the lastest non-stop flight I can find it 5:25 pm
09:06:05 <sethk> or I can go at 8 am and get there by about noon
09:09:36 <sethk> you can buy a 32 bit microcontroller with a 10 ua current consumption (in sleep mode) for about $1.50 in quantity.  :)
09:38:37 * roconnor looks at sudoku for the first time.
09:38:52 * roconnor starts designing haskell code in his head.
09:39:09 <roconnor> I see filter used alot
09:40:57 <xerox> I see an infinite list of solutions, hehe.
09:45:45 <glguy> Most sudouk puzzles are only supposed to have a single answer (IIRC)
09:47:01 <Lemmih> Hi SyntaxNinja.
09:49:33 <liyang> Correctly designed ones are certainly supposed to have one unique solution.
09:50:01 <SyntaxNinja> 'mornin
09:52:04 <phys_rules> hi Lemmih
09:52:06 <phys_rules> hi SyntaxNinja
09:52:17 <Lemmih> Hiya phys_rules.
09:52:45 <phys_rules> for IDE, I was thinking of having smart templates
09:53:10 <phys_rules> like you press Alt-Ins and you can choose for example for a datatype to implement some instance..
09:53:18 <phys_rules> and it generates the code for you in place that you can fill
09:53:46 <phys_rules> same goes for "Make new module" for example
09:54:03 <phys_rules> and having something like on-fly check would be really nice,
09:54:23 <phys_rules> for example pressing the Ctrl-Q or Ctrl-Click over something might give you the inferred type
09:54:52 <phys_rules> and of course code folding :)
09:55:18 <roconnor> http://www.websudoku.com/ says `` Each Sudoku has a unique solution that can be reached logically without guessing.''
09:55:53 <roconnor> so after putting all possible solutions into each empty square I would expect after filtering at least one square to have a list of one element.
09:56:02 <roconnor> add that to the solution and repeat untill all squares are filled.
09:56:07 <Lemmih> phys_rules: Sounds good. Planning on pushing some patches for hIDE?
09:56:16 <glguy> My Sudoku solving I wrote as a Haskell exercise can solve those
09:56:20 <glguy> but some require guessing
09:56:26 <glguy> and I didn't write mine to handle that
09:56:46 <roconnor> ah
09:56:57 <roconnor> It looks like a nice assignment question.
09:56:58 <phys_rules> Lemmih: as soon as I get something to build on my windows platform, hell yeah ;)
09:57:02 <glguy> at least some from other websites did
09:57:10 <roconnor> sure
09:57:29 <phys_rules> Lemmih: there seems to be a problem of finding a binary package for gtksourceview for windows :\
09:57:47 <roconnor> I'm doing my first one by hand now.
09:58:00 <roconnor> I can't help but think it would be faster to write the haskell code.
09:59:01 <sylvan> roconnor, there are _many_ ways to exclude possibles from a list.. "naked pair" "hidden pairs" etc etc...
09:59:24 <roconnor> are these in the wiki?
09:59:31 <sylvan> probably not
09:59:54 <sylvan> google on "solving sudukos" and you're bound to find a list of all known strategies somewhere
10:01:48 <glguy> You don't need fancy methods to solve sudoku... just figure out which squares can only be a certain number, set them to that number, repeat process till completion... right?
10:02:01 <liyang> glguy: nope.
10:02:55 <liyang> That method eliminates a lot of possibilities, but you do need more than one step of lookahead (as it were) in general.
10:03:15 <liyang> (That's what I thought until I tried to do some puzzles.)
10:04:04 <glguy> I'm looking at some methods and seeing what you mean
10:04:14 <glguy> http://www.conceptispuzzles.com/products/sudoku/solution_examples.htm  like #4
10:09:09 <sylvan> I'm getting the urge to write a Haskell program to do all those techniques over and over until completion....
10:11:02 <roconnor> 40 minutes 41 seconds.
10:39:48 <RemiTurk> hi all
10:39:58 <xerox> Hello!
10:40:58 <RemiTurk> does anyone know of a solution for ghc dying on compilation of ghc-api (probably the -ignore-package problem I found in the #haskell logs)
10:41:18 <RemiTurk> (dying with with an "unknown exception", to be "more precise")
10:41:52 <xerox> Yes, possibly...
10:42:09 <RemiTurk> tell me :D
10:42:33 <xerox> Which Cabal do you have?
10:42:40 <RemiTurk> (I have my new linux up and running (although X / DRI isn't too happy yet :() but still cannot try hIDE as long as ghc-api refuses to compile
10:42:51 <RemiTurk> Cabal-1.1.3
10:43:05 <xerox> If you have the sources there, can you lookup Cabal.cabal ?
10:43:14 <RemiTurk> I have
10:43:22 <xerox> Maybe upgrade them before.
10:43:27 <RemiTurk> I had to create a package myself for my distro ;)
10:44:04 * RemiTurk has Cabal.cabal open in gvim
10:44:11 <xerox> The fix there was this:
10:44:13 <xerox> hunk ./Cabal.cabal 4
10:44:13 <xerox> -Build-Depends: base, util
10:44:13 <xerox> +Build-Depends: base
10:44:24 <RemiTurk> thanks
10:44:27 <RemiTurk> I'll try :)
10:44:34 <xerox> Then recompile, reinstall, and such.
10:44:41 * xerox crosses fingers
10:45:52 * Lemmih sneaks up on ghc-api and guts it from behind.
10:46:33 <dcoutts> muwahahaha
10:46:36 * RemiTurk hopes Lemmih isn't going to take it down
10:46:38 <xerox> RemiTurk: also, with GHC 6.5, ghc-api, will not be used anymore
10:46:50 <RemiTurk> ahh
10:46:58 <dcoutts> we can use the real thing then
10:47:20 <RemiTurk> though, seeing how horribly long ghc took to compile itself, I'm not sure I'll do that before 6.6 is released :-/
10:47:44 <RemiTurk> (uhm, the fact that I compiled some 10 other packages concurrently might have mattered too ;))
10:48:15 <RemiTurk> cabal is building now...
10:48:30 <RemiTurk> Lemmih: what's so horrible about ghc-api you're gutting it?
10:48:40 <RemiTurk> the fact that ghc 6.4 isn't made to support it?
10:50:35 <Lemmih> It uses a horrible hack to load interface files from before 6.5 and the bytecode generator is broken.
10:51:15 <RemiTurk> sounds pretty :)
10:51:55 <RemiTurk> are there any plans about when 6.6 will be released by the way?
10:52:11 <RemiTurk> or are the Simons still deep down in SMP-land :)
10:52:43 <araujo> Hello here
10:53:01 <araujo> Anyone knows a good site to host haskell projects with a darc repo?
10:53:24 <RemiTurk> hm, there have been (very vague?) plans to set one up..
10:53:25 <Lemmih> araujo: scannedinavian.org is great (:
10:53:30 <RemiTurk> ahh
10:53:45 <araujo> Lemmih, is that the shapr's site? :-]
10:54:00 <RemiTurk> and bothering sourceforge might also be a good idea (one day, when enough people have complained... ;))
10:55:37 * RemiTurk cries
10:55:44 <RemiTurk> Building ghc-api-0.2...
10:55:44 <RemiTurk> ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
10:55:44 <RemiTurk>         unknown exception
10:57:15 <dcoutts> RemiTurk, your cabal version depends on the util package. That breaks things.
10:57:35 <dcoutts> ghc-pkg field Cabal depends
10:58:07 * RemiTurk slaps forehead
10:58:08 <RemiTurk> argh
10:58:16 <dcoutts> does that report util-1.0 ?
10:58:32 <RemiTurk> my previous distro was Rock (source based), in which building meant installing...
10:58:49 <RemiTurk> so I just patched Cabal.cabal, built it and didn't realize I also had to install it ;)
10:58:58 <dcoutts> yeah, we find these problems pretty early on gentoo too
11:00:02 * RemiTurk tries again
11:00:44 <RemiTurk> where, btw, am I supposed to leave my (un|)register.sh in installed packages?
11:03:08 <sylvan> if I do something like this: [ x // y | x <- xs, let y = foo x]
11:03:16 <sylvan> ie introduce a variable inside a list comprehension?
11:07:54 <xerox> @eval [ x + y | x <- [1], let y = 1 ]
11:07:55 <RemiTurk> it's getting further than it did (at least)
11:07:56 <lambdabot> [2]
11:08:03 <xerox> sylvan: it seems it's possible :-)
11:08:21 <RemiTurk> and now I'm going downstairs for dinner. thanks to all :)
11:08:32 <xerox> Enjoy :)
11:08:52 <RemiTurk> thx
11:25:58 <gour> dcoutts, ping
11:26:04 <thedward> @eval [ x | x <- [1,2,3], y <- [0] ]
11:26:05 <lambdabot> [1,2,3]
11:26:10 <thedward> @eval [ x | x <- [1,2,3], y <- [0,0] ]
11:26:11 <lambdabot> [1,1,2,2,3,3]
11:26:15 <thedward> @eval [ x | x <- [1,2,3], y <- [0,0,0] ]
11:26:16 <lambdabot> [1,1,1,2,2,2,3,3,3]
11:26:39 <thedward> @eval [ x + y  | x <- [1,2,3], y <- [1,1,1] ]
11:26:40 <lambdabot> [2,2,2,3,3,3,4,4,4]
11:26:57 <thedward> @eval [ x + y  | x <- [1,2,3], y <- [3,2,1] ]
11:26:58 <lambdabot> [4,3,2,5,4,3,6,5,4]
11:31:57 <xerox> @eval ['a','c'..'k']
11:31:58 <lambdabot> "acegik"
11:32:03 <xerox> O_O
11:32:06 <xerox> Ah :D
11:33:14 <dcoutts> gour, pong
11:34:08 * xerox mumbles
11:34:18 <xerox> QuickTest does automagically decide the domain of the tests?
11:34:27 <dcoutts> yep
11:34:32 <xerox> My gosh.
11:34:32 <dcoutts> you can adjust it however
11:34:44 <xerox> Didn't know that, I must try it!
11:35:19 <dcoutts> @cool+ QuickTest
11:35:20 <lambdabot> Unknown command, try @listcommands.
11:35:37 <gour> dcoutts, you are using evolution, true?
11:39:07 <xerox> Does QuickCheck come with GHC 6.4.1 ?
11:39:37 <kosmikus> yes
11:40:00 <dcoutts> gour, yes
12:02:37 <ricebowl> is there a brief reference on Haskell arrays somewhere?
12:02:49 <gour> dcoutts, hi, i had some problem with my net-connection
12:09:00 <gour> dcoutts, how are you advancing towards new release?
12:11:48 <wilx`> ricebowl, there is some documentation bundled with GHC.
12:12:57 <Khisanth> ricebowl...well at least your aren't a ricebucket :)
12:13:18 <xerox> @yow
12:13:19 <lambdabot> I smell like a wet reducing clinic on Columbus Day!
12:14:55 <CosmicRay> shapr: did you like my explanation for the lateness of HWN? ;-)
12:15:56 <xerox> shapr: did you write that QuickCheck 'invents' the domain of the parameters to try out the tests?  I didn't understand it until today, woot, it's great!
12:15:57 <ricebowl> eh?
12:16:01 <ricebowl> rice bucket?
12:18:31 <wearpants> but are there no online docs/examples of the array stuff/
12:18:35 <wearpants> ?
12:18:52 <wearpants> I'm trying to revise a program remotely over a connection that is really, really slow
12:19:16 <wearpants> I don't have GHC here at the uni and can't install it
12:19:42 <integral> all the hierarchical modules documentation is on the GHC website
12:19:45 <wilx`> Hm, I am not aware about any examples for arrays.
12:22:28 <wearpants> hmm :/
12:22:55 <wearpants> I have an assignment implemented using lists, I have an adjacency list representation of a graph
12:23:10 <wearpants> wanted to do the same using arrays, but I think this will be too expensive
12:23:15 <wearpants> essentially I need a matrix, but it has to be able to grow
12:30:10 <xerox> wilx`: I think there are examples of array usage in the hawiki
12:36:00 <ricebowl> well, the real question is this: how expensive is it to resize a matrix? It would involve copying the matrix, and my matrix is going to be something like 4,000 x 4,000
12:36:11 <ricebowl> which is why I want a matrix to begin with instead of a list of lists
12:37:39 <pesco> Which is the program again that was used to generate the GHCi (and Hugs?) start-up banner?
12:38:42 <dcoutts> @seen gour
12:38:42 <lambdabot> I saw gour leaving #haskell 4 minutes and 11 seconds ago.
12:39:13 <Lemmih> pesco: GHC prints it by itself.
12:39:32 <wearpants> hmm, does Prelude have anything more efficient than lookup which does the same thing?
12:39:44 <wearpants> something like an associative map container
12:39:46 <dcoutts> Lemmih, pesco, oh, but there was a program which generated those strings
12:39:46 <pesco> Lemmih: Yes, but it was originally generated by some tool.
12:39:55 <psi> figlet?
12:40:06 <pesco> That could be it...
12:40:10 <dcoutts> @google figlet
12:40:11 <lambdabot> http://www.figlet.org/
12:40:26 <dcoutts> yep, that's the one
12:40:28 * pesco apt-get installs figlet.
12:40:48 <ndm> anyone have any experience with quickCheck?
12:41:03 <ndm> i've used it before, but i'm having issues writing a new arbitrary type...
12:41:41 <ndm> i want to generate a random string
12:41:51 <ndm> of a random length, in the bounds of 0..50
12:42:02 <ndm> each character of which is a random character, in the printable range
12:42:46 <dcoutts> ndm, what was the yhc web page again?
12:43:01 <ndm> www.cs.york.ac.uk/~ndm/yhc
12:43:13 <ndm> it will be in the HCAR
12:43:37 <dcoutts> @where-add yhc www.cs.york.ac.uk/~ndm/yhc
12:43:37 <lambdabot> Unknown command, try @listcommands.
12:43:43 <dcoutts> @where+ yhc www.cs.york.ac.uk/~ndm/yhc
12:43:44 <lambdabot> yhc ~> www.cs.york.ac.uk/~ndm/yhc
12:43:48 <dcoutts> ta
12:47:33 <SamB> anyone seen the paper about lava 2000?
12:48:05 <ndm> SamB: lava the circuit layout library?
12:48:26 <SamB> ndm: yes, that lava
12:48:38 <ndm> i have seen a few papers about it
12:48:46 <ndm> the person who sits next to me is more into it than me
12:49:15 <SamB> who is the person who sits next to you?
12:49:57 <xerox> http://www.doheth.co.uk/funny/signs/Trance_Warning.jpg
12:51:11 <wearpants> isn't pop music still worse than trance? :p
12:51:20 <basti_> whats bad about trance?
12:51:26 <xerox> dunno
12:51:29 <wearpants> nothing according to me <shrug>
12:51:33 <SamB> anyway, I was trying to do something like that with GADTs...
12:51:53 <ndm> Matthew Naylor
12:52:12 <ndm> i know he's been writing a new version of lava
12:52:23 <ndm> similar, but freely available and with some benefits
12:52:24 <wearpants> that is too odd of a coincidence o_O
12:53:19 <SamB> I don't suppose he has a repo up somewhere?
12:53:45 <Philippa_> basti_: depends what kind of trance you mean
12:53:59 <Philippa_> the crappy borderline-pop stuff is a really bad thing...
12:54:12 <basti_> hmm.
12:54:15 <ndm> SamB, no
12:54:30 <ndm> but he has a draft of a technical report he's been writing sat on his desk
12:54:37 <Philippa_> (if you're going to sell stuff like that then yes, you *are* better off alone. The moon might be a good start)
12:55:27 <SamB> anyway, I couldn't figure out how to do something like Generic without using a monomorphic datatype...
12:56:33 <ndm> i certainly don't know it in that much detail
12:56:51 <basti_> @where arrow
12:56:52 <lambdabot> I know nothing about arrow.
12:57:18 <xerox> @where arrows
12:57:19 <lambdabot> http://www.haskell.org/arrows/
12:57:38 <SamB> what do arrows have to do with it?
12:57:46 <xerox> Dunno.
12:57:47 * SamB doubts anything
12:57:55 <basti_> ahh.
13:00:42 <SamB> well, arrows could be used for circuits, but it seems like theyd be even more of a pain than Monads were...
13:05:25 <SamB> so, anyone a real scary typeclass expert? look at the paper at http://www.cs.chalmers.se/~koen/Papers/lic.ps, in section C.2 ("Overloading", starting on page 148).
13:06:29 <SamB> I'm wondering how you'd do that without any Symbol type...
13:10:10 * SamB wishes Data.Generics could be used at polymorphic types
13:17:47 <xerox> dcoutts: ping
13:28:54 <dcoutts> xerox, pong
13:29:01 <dcoutts> yay! Gtk2Hs 0.9.10 is out!
13:29:10 <dcoutts> http://haskell.org/gtk2hs/download/
13:29:29 <xerox> dcoutts: http://pugscode.org/talks/euroscon05/haskell.xul slide 251 !!
13:29:33 <xerox> dcoutts: woo!
13:30:47 <dcoutts> xerox, nice!
13:31:23 <xerox> The whole slides are very, very cool.  I need to hug autrijus to put nymphaea in :)  (and doing gtk2hs+cairo advertising :D)
13:31:47 <dcoutts> and slide 254 :-)
13:32:02 <xerox> hehe!
13:32:12 <xerox> There should have been a CommonSense shot too! :)
13:32:13 <dcoutts> yes a screenshot of nymphaea would be nicer than the one he's got
13:32:18 <dcoutts> yes -)
13:32:55 <xerox> I want a video of the talk :D
13:33:06 <dcoutts> heh :-)
13:34:11 <dcoutts> I like slide 7: "Powered by Ph.D"
13:34:22 <dcoutts> it's funny and true
13:34:58 <xerox> heh!
13:35:07 * ibid is writing his nanowrimo manuscript
13:35:10 <gzl> what's up with those slides being written in XUL?
13:35:15 <xerox> Those slides are just great.
13:35:26 <gzl> I have yet to see one.
13:35:43 <xerox> gzl: that XUL app as an internal on-the-fly editor too!
13:36:00 <gzl> hm. it didn't display properly in my browser
13:36:29 <integral> use a mozilla-based browser
13:37:01 <gzl> urgh
13:37:02 <gzl> ok.
13:37:12 <integral> well, unless yours supports XUL of course :)
13:37:29 <gzl> isn't it kind of goofy to have browser-dependent slides?
13:38:23 <integral> sort of
13:38:41 <xerox> ..but the fact itself that is the browser to build them is cool.
13:39:04 <gzl> I can't parse that sentence
13:39:09 <gzl> but I think I know what you mean
13:39:20 <glguy> read: no parse
13:40:03 <gour> dcoutts, now i'm back
13:40:20 <dcoutts> gour, you were going to ask me something
13:41:10 <gour> dcoutts, yes how it goes with the release and something about evolution
13:42:08 <dcoutts> it's released!
13:42:14 <dcoutts> http://haskell.org/gtk2hs/download/
13:42:15 <gour> really?
13:43:14 <gzl> ok, well, these are at least really funny.
13:43:15 <gzl> :)
13:45:30 <SamB> this would be cooler with animated text
13:46:18 <SamB> what is that symbol on slide 82
13:46:18 <SamB> ?
13:48:45 <gour> dcoutts, is ebuild also ready?
13:49:49 <gour> dcoutts, probably 0.9.9.8 works
13:55:13 <dcoutts> gour, I'll update that now
13:56:53 <gour> dcoutts, ok, my getdelta cannot fetch it, so i'm downloading manually
13:57:20 <xerox> What is getdelta?
13:59:03 <gour> xerox, http://linux01.gwdg.de/~nlissne/
13:59:49 <gour> xerox, binary delta so one do not need to download the whole package when doing upgrade
14:00:06 <gour> xerox, saving bandwidth
14:00:24 <xerox> ah!
14:03:46 * ibid is 28 years old in about 20 hours
14:03:51 <ibid> (ie. today)
14:04:06 <xerox> Happy birthday ibid!
14:04:08 <phys_rules> congrats ;)
14:04:11 * xerox dances
14:04:37 <ibid> :)
14:05:07 <gour> all the best, ibid
14:05:12 * dcoutts congratulates ibid 
14:08:55 <gour> dcoutts, i'm emerging gtk2hs, but will save Qs for tomorrow
14:09:05 <gour> good night, #haskell
14:09:15 <dcoutts> gour, it's a bit more subtle
14:09:23 <dcoutts> the ebuild needs updating
14:09:31 <dcoutts> the 0.9.9.8 one is not right
14:09:42 <dcoutts> I'm just getting it reviewed now
14:10:02 <gour> dcoutts, ok, will go to sleep sooner :-)
14:10:13 <dcoutts> yep
14:10:21 <dcoutts> by tomorrow it should be in portage
14:10:29 <gour> ta
14:16:43 <dons> um, NetSplit (+173 more) ! :/
14:17:04 <dons> oh, .au got split from the rest of the world :(
14:20:09 <dcoutts> poor .au
14:20:51 <dons> dcoutts, you'll enjoy knowing that I had a dream last night that I found two bugs in gtk2hs :)
14:20:59 <dons> this is what i dream about, these days
14:21:12 <dcoutts> poor dons :-)
14:21:15 <kolmodin> dons: lol :)
14:21:16 <dons> hehe
14:21:56 * dcoutts is glad dons only found gtk2hs bugs in his dreams
14:22:03 <dons> hah!
14:22:42 <dcoutts> dons, if you get a OpenBSD gtk2hs 0.9.10 package out soon I'll mention it in the release notes
14:23:04 <dons> ah, hmm, i'll see what I can do
14:23:13 <dcoutts> the Gtk2Hs 0.9.10 release will be announced on the Haskell lists and gnome-announce in a couple days or so
14:23:37 <dons> oh, probably I won't get time, but I'll certainly let you know when I package it.
14:24:13 <dcoutts> dons, ok, cheers
14:24:28 <sylvan> I swear to god, Ralf named his parser generator "Frown" for thesole purpose of being able to say "Happy frowning, Ralf" at the end of the announcement message
14:24:30 <dons> Hinze releases "Frown"!? and alternative to happy. hmm
14:25:32 <sethk> what's the problem with happy that he's trying to solve?
14:27:10 <paj_> Errr, hello?  Is this working?
14:27:19 <xerox> No, please call again later.
14:27:37 <paj_> I'll take that as a yes.  I've never used IRC before.
14:27:44 <xerox> Welcome!
14:28:38 <paj_> I see lots of people apparently logged in (187).  Does everyone talk?  Whats the protocol?
14:28:47 <phys_rules> =)
14:28:55 <integral> most of them don't talk :)
14:29:06 <xerox> paj_: yeah, lately the channel become a little busy!
14:29:24 <integral> paj_: because each line is atomic, there's no need for anything like CDMA
14:29:53 <paj_> I'm not seeing anything except replies to me.  Am I missing something?
14:30:07 <psi> no
14:30:27 <integral> hmm, maybe I meant CSMA/CD
14:30:37 <sethk> paj_, I talk, and everybody else listens.  :)
14:30:43 <paj_> OK.  I'm in the UK, BTW, where its half ten.  I've been using Haskell for a year or two on and off
14:30:51 <sethk> integral, no collisions that way.  :)
14:31:02 <paj_> (For Americans, thats 10:30pm)
14:31:12 <xerox> paj_: cool!  Welcome to the Haskell IRC Channel!
14:31:20 <integral> paj_: it's more like early evening in america
14:31:27 <xerox> paj_: we have some good things here, apart from people ;-)
14:31:43 <paj_> I've seen references to the Lambdabot.  How does that work?
14:31:47 <xerox> paj_: for instance, the lambdabot program, which appears as a user here, but it's in fact an Haskell program.
14:32:01 <xerox> She can do very neat things, like infer types:
14:32:08 <sylvan> paj_, woah! "half ten" means "half PAST ten"? I always thought it ment "half to ten"...
14:32:20 <sylvan> maybe this isn't the right forum for that kind of inquiry though =)
14:32:27 <xerox> @type let ones = (1 :: Int) : ones in ones
14:32:28 <lambdabot> [Int]
14:32:32 <integral> @plugs let fib =  1 : 1 : zipWith (+) fib (tail fib) in take 5 fib
14:32:33 <lambdabot> [1,1,2,3,5]
14:32:39 <ndm> dons, i wanted to talk to you about hoogle orderings
14:32:39 <xerox> paj_: or eval some code, with @plugs, as integral showed.
14:32:43 <paj_> Lets see:
14:32:46 <sethk> at the moment it is 5:32 Eastern, which is the latest US zone
14:32:46 <dons> ndm, hi!
14:32:48 <paj_> @help
14:32:49 <lambdabot>  @help <command> - ask for help for <command>
14:32:57 <dons> ndm, maybe we should talk in -overflow..
14:33:01 <xerox> paj_: she also knows where the functions are, in the hierarchical modules.
14:33:07 <integral> @hoogle Int -> [a] -> [a]
14:33:08 <lambdabot> Data.List.take :: Int -> [a] -> [a]
14:33:08 <lambdabot> Data.List.drop :: Int -> [a] -> [a]
14:33:08 <lambdabot> Prelude.take :: Int -> [a] -> [a]
14:33:11 <xerox> @index fromJust
14:33:11 <lambdabot> Data.Maybe
14:33:19 <paj_> @help hoogle
14:33:20 <lambdabot>  @hoogle <expr>, Haskell API Search for either names, or types.
14:33:23 <dons> ndm, #haskell-overflow
14:33:32 <xerox> paj_: and then, she can tell you the link to the online documentation for modules, given the name:
14:33:37 <xerox> @docs Data.List
14:33:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
14:33:42 <sylvan> xerox, are you moving in on shapr's job as the #haskell tour guide? :-)
14:33:45 <xerox> And the sources!
14:33:49 <xerox> @libsrc Data.List
14:33:50 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
14:34:02 <integral> but the sources can be quite scary :)
14:34:05 <xerox> sylvan: it's a dirty job, but someone should do it :)
14:34:10 <psi> @botsnack
14:34:10 <lambdabot> :)
14:34:12 <ndm> there should be an @tour command
14:34:18 <paj_> Sources can be useful.  I keep having to dig around in the GHC CVS tree
14:34:24 <xerox> She also entertains us with random code!
14:34:24 <xerox> @code
14:34:25 <lambdabot> module "code" screwed up: getRandItem: empty list
14:34:26 <ndm> where lamdabot gives the hour, over a period of time (so they can absorb it)
14:34:31 <xerox> She does not.  OK.
14:34:43 <xerox> @dice 2d6
14:34:43 <lambdabot> module "dice" screwed up: getRandItem: empty list
14:35:00 <paj_> She seems to need her bit bucket refilling
14:35:00 <xerox> The entropy is lowering?  Please call a physicist!
14:35:18 <xerox> What other cool things can she do..
14:35:40 <integral> @yow
14:35:40 <lambdabot> module "quote" screwed up: getRandItem: empty list
14:35:44 <xerox> @babel it en Io posso tradurre!
14:35:46 <lambdabot>  I can translate!
14:35:59 <xerox> @wikipedia L-Systems
14:36:01 <lambdabot> http://en.wikipedia.org/wiki/L-systems
14:36:09 <xerox> @map
14:36:10 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
14:36:12 <paj_> This channel cannot substitute for demonical advice.  Please consult a registered physicist if you believe your universe is faulty
14:36:17 <xerox> @where nymphaea
14:36:18 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
14:36:25 <xerox> She does way too much things :-D
14:36:40 <thedward> @listofcommands
14:36:40 <lambdabot> use listcommands [module|command], please. Modules are:
14:36:40 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
14:36:40 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
14:36:40 <lambdabot> topic type version vixen where
14:36:53 <thedward> @vixen
14:36:54 <paj_> @karma
14:36:54 <lambdabot> module "vixen" screwed up: getRandItem: empty list
14:36:54 <lambdabot> You have a karma of 0
14:37:04 <xerox> ah, karma is for good and bad people.
14:37:05 <paj_> @localtime
14:37:06 <psi> what's wrong with lambdabot?
14:37:10 <xerox> @localtime paj_
14:37:21 <paj_> @localtime xerox
14:37:21 <{Arias}> em, is Maybe a monad like IO ?
14:37:22 <lambdabot> Local time for xerox is Tue Nov  1 23:37:04 2005
14:37:38 <thedward> @localtime thedward
14:37:41 <xerox> Your client have to answer the CTCP TIME request in order to show that information.
14:37:41 <lambdabot> Local time for thedward is Tue Nov  1 14:37:16 2005
14:37:50 <xerox> Ahhhh!
14:37:50 <paj_> Hmm.  Xerox in EUrope?
14:37:55 <xerox> paj_: yes, Italy!
14:37:58 <xerox> Check the map.
14:37:59 <xerox> @map
14:37:59 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
14:38:16 <xerox> Also, the coolest thing, is TheHunter's points-free toy:
14:38:27 <xerox> @pl \f xs -> xs >>= return . f
14:38:27 <lambdabot> fmap
14:38:37 <xerox> @pl \f g x y = f (g x y)
14:38:38 <lambdabot> (line 1, column 10):
14:38:38 <lambdabot> unexpected "="
14:38:38 <lambdabot> expecting pattern or "->"
14:38:43 <xerox> @pl \f g x y -> f (g x y)
14:38:43 <lambdabot> (.) . (.)
14:39:04 <xerox> @pl \f x -> f x x
14:39:04 <lambdabot> join
14:39:32 <paj_> @help pl
14:39:32 <xerox> OK, I think it's enough...
14:39:33 <lambdabot>  @pointless <expr> - play with pointfree code
14:39:56 <dons> dcoutts, Lemmih: phys_rules just built gtk yi on windows ! :)
14:40:00 <xerox> paj_: It generalizes the code to the points-free form, i.e. a composition without explicit parameters.
14:40:16 <paj_> I'm going to have to have a play with that.
14:40:18 <xerox> @karma+ phys_rules -- :-D
14:40:19 <lambdabot> phys_rules's karma raised to 1.
14:40:52 <xerox> It also can construct hawiki's urls, which is the Haskell Wiki.
14:40:53 <xerox> @wiki
14:40:54 <lambdabot> http://www.haskell.org/hawiki/
14:41:03 <xerox> @wiki HaskellDemo
14:41:04 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
14:41:10 <paj_> I found #haskell from Hawiki
14:41:45 <paj_> I've written a demo program, about 90 lines of source.  It does the PhoneCode problem
14:42:09 <xerox> There are people from all around the world here, you'll see them talking at every hour of night and day :-)
14:42:27 <xerox> What is the PhoneCode problem?
14:42:35 <paj_> SEc, looking for link
14:42:56 <JohnMeacham> We need one of these for haskell: http://www.c-jump.com/index.html
14:43:36 <sethk> JohnMeacham, well, get those typing fingers moving  :)
14:43:48 <xerox> Oh my... :-)
14:43:55 <paj_> http://www.cis.udel.edu/~silber/470STUFF/article.pdf is the link for the phonecode proble
14:44:26 <paj_> Given a mapping from digits to characters, and a dictionary, find all the mnemonics for a phone numnber
14:44:32 <phys_rules> @hide
14:44:33 <lambdabot> Maybe you meant: code dice
14:44:38 <dcoutts> dons, yep, he's been reporting his progress to me for the past couple hours :-)
14:44:39 <phys_rules> @hIDE
14:44:40 <lambdabot> Unknown command, try @listcommands.
14:44:55 <phys_rules> @wiki hIDE
14:44:55 <lambdabot> http://www.haskell.org/hawiki/hIDE
14:45:02 <paj_> It was used in a language comparison paper, so I thought I'd see how Haskell stacked up.
14:45:25 <sethk> paj_, somewhat strange choice of languages
14:45:26 <xerox> paj_: and what are the results?
14:45:45 <paj_> My solution was about the same length as the shortest Perl solutions, but they used built in assoc arrays.
14:45:49 <paj_> I built my own tree.
14:46:04 <paj_> I was wondering about sticking it in HaWiki
14:46:24 <xerox> There is a @paste page, or you can probably make one ad-hoc if you will.
14:46:42 <paj_> @help paste
14:46:43 <lambdabot> paste page url
14:46:44 <dons> another fun language comparison paper is "A Comparative Study of Language Support for Generic Programming"
14:46:53 <xerox> @paste
14:46:53 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:47:02 <xerox> @help url
14:47:03 <lambdabot>  @help <command> - ask for help for <command>
14:47:07 <dons> it has these fun tables of features, where most are empty, and the column for haskell is full of ticks :)
14:47:16 <xerox> heh!
14:48:22 <paj_> At work I've taken to carrying around the "Ada vs C++ vs ..." paper.  I show them the line count tables and say "this is not a misprint"
14:48:31 <paj_> "them" being the managers
14:50:35 <xerox> What was the reaction?
14:51:08 <paj_> Definite interest.  I've found that managers totally discount any explanation they can't tie to their personal experience
14:51:18 <dcoutts> dons, http://haskell.org/~duncan/hIDE/yi-win32.jpg
14:51:19 <paj_> but when you show them numbers they sit up.
14:51:36 <dcoutts> dons, it looks like macosx but it's actually win32 with an osx theme apparently
14:51:38 <sethk> paj_, what are they expecting?  On the linecounts?
14:51:40 <paj_> Of course most managers with a tech background learned programming in Ada or C, so
14:51:42 <xerox> paj_: good enough, I'd say! :-D
14:51:48 <paj_> its the blub paradox.
14:52:17 <xerox> Is there a @bannedcontent ?  <blink>
14:52:30 <paj_> sethk, I don't know what they are expecting, but the figures in that paper show an order of magnitude over Ada and C++.
14:52:55 <paj_> However I feel a bit nervous in case they think that is typical
14:53:14 <xerox> You have to get them to the darcs-side of the force
14:53:17 <paj_> My experience shows a factor 3-5 is more typical
14:53:26 <paj_> <Groan>
14:53:33 <sethk> paj_, which being smaller?
14:54:07 <paj_> I mean that the "Ada vs..." paper has something like Ada 83 = 850 lines, Haskell = 85 lines to implement a spec.
14:54:46 <paj_> However when I tried reimplementing "cat" (with all its command line flags) my solution was aobut a fifth the size of the GNU version
14:55:14 <sethk> paj_, and c++?
14:55:25 <paj_> I think that was something over 1100 lines!
14:56:50 <paj_> Of course, as the Phonecode paper shows, programmer variation is almost as significant.  Its an interesting paper: I recoommend it
14:56:58 <paj_> Gotta go now.  I'll be back.
14:57:07 <paj_> (but not tonight)
14:58:18 <xerox> ...bye
14:58:39 <xerox> What was the paper?
15:01:19 <thedward> xerox: http://www.cis.udel.edu/~silber/470STUFF/article.pdf ?
15:02:02 <xerox> thedward: I mean the "ADA vs .." one
15:02:40 <thedward> ah.
15:05:22 <sethk> is it allowable to use   let x = blah in ...    and also use a section   where  y = foo     at the end of the function?
15:05:35 <pediddle> sure
15:06:03 <sethk> pediddle, thanks
15:06:06 <pediddle> let ... in ... is an expression; where ... is part of function definition
15:06:45 <xerox> Goodnight!
15:06:53 <phys_rules> goodnight everyone ;)
15:07:56 <sethk> pediddle, makes sense, I've just never seen an example that does it so I wasn't sure.
15:14:48 <mwc> dcoutts: back on OS X, building a darwinports port for gtk2hs tonight
15:14:57 <mwc> better late than never
15:15:29 <thedward> xerox: this one maybe: haskell.org/papers/NSWC/jfp.ps ?
15:16:54 <dcoutts> mwc, cool. you're using the 0.9.10 release tarball right?
15:17:14 <mwc> Yeah
15:17:16 <mwc> will be
15:17:20 <dcoutts> great
15:17:37 <dcoutts> I've heard the gtk libs in darwin ports were being problematic
15:17:39 <mwc> It's good to be back to Haskell
15:18:30 <mwc> What officially is the project home page? http://haskell.org/gtk2hs/ or http://gtk2hs.sf.net?
15:18:38 <dcoutts> http://haskell.org/gtk2hs/
15:19:27 <dcoutts> psi, did you get the gtk on osx problems sorted out?
15:20:11 <mwc> I've had no troubles with them
15:20:43 <dcoutts> ok, good
15:20:58 <dcoutts> mwc, you might find the ebuild I maintain a useful reference:
15:20:59 <dcoutts> http://haskell.org/~gentoo/gentoo-haskell/portage/dev-haskell/gtk2hs/gtk2hs-0.9.10.ebuild
15:21:32 <mwc> excellent, should be useful
15:21:32 * dcoutts goes to bed
15:23:44 <Lemmih> g'night dcoutts.
15:26:03 <sethk> what's the best list function to use to process each member of a list?  I don't need map because I don't want a new list.
15:28:13 <astrolabe> maybe foldr?
15:28:49 <wilx`> Err, are we talking monads?
15:29:12 <mwc> sethk: when you say process, what kidn of value do you expect to get? That's what'll guide that decision
15:30:31 <sethk> wilx`, astrolabe, mwc   the list is a list of directories, and I'm doing some file processing on each directory, so wilx` yes, IO monad, mwc no specific return value, I'm writing a file that I will later read and process
15:30:51 <wilx`> @type mapM_
15:30:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
15:31:16 <int80_h> hi there
15:31:29 <int80_h> once I am finished working through my haskell books, I want to take on a project
15:31:51 <int80_h> two possible projects that intrest me, is an Interactive Fiction system. Or a mud engine
15:32:16 <int80_h> now, I'd like to start a general discussion on what it would take to start, say, the mud
15:32:38 <int80_h> would I need to use the FFI for sockets and OS access?
15:33:06 <sethk> int80_h, you don't need FFI for sockets, certainly
15:33:25 <sethk> int80_h, probably not for OS but I'm not sure since I don't know about mud
15:33:33 <sethk> int80_h, except the kind my dog likes
15:33:50 <int80_h> muds are enviroments where people can interact with objects, and talk to each other
15:34:09 <int80_h> more complexity follows but I'll be happy to simulate an enviroment where people can move from room to room
15:34:13 <int80_h> and talk to each other
15:34:53 <sethk> int80_h, you should be able to find what you need in the haskell libraries
15:34:58 <int80_h> sweet
15:35:04 <sethk> int80_h, I wouldn't expect you to need FFI
15:35:15 <int80_h> ah good
15:35:34 <int80_h> well, I'll need to be able to have a daemon that listens on a port
15:35:52 <int80_h> I was even thinking of using hugs as the starting place for that
15:35:58 <sethk> int80_h, you've got your usual sockets interface available
15:36:02 <int80_h> attach it to a port, and go from there
15:36:09 <int80_h> okay cool
15:36:17 <sethk> int80_h, I haven't done a daemon specifically but other folks have
15:36:44 <int80_h> would their work be found via haskell.org?
15:37:26 * int80_h goes to look
15:50:45 <int80_h> I don't see anything for ports and sockets yet
15:51:24 <sethk> int80_h, you mean the libraries?
15:57:04 <int80_h> yeah
16:04:35 <psi> dcoutts: no :(
16:06:55 <psi> did we think that ghc could be causing it?
16:07:06 <dons> @yow
16:07:07 <lambdabot> module "quote" screwed up: getRandItem: empty list
16:07:08 <dons> hmm
16:07:11 <dons> that's weird
16:07:21 <psi> it has been doing that for several functions
16:07:26 <dons> vegai, ^^ is that what you had too?
16:08:04 <dons> seems like all the commands hat use the random generator broke in 6.5 :/
16:09:27 <Pseudonym> http://members.aol.com/jeff570/mathword.html <- Some interesting stuff.
16:09:45 <Pseudonym> Unfortunately, it doesn't mention where "monoid" came from.
16:09:49 <astrolabe> int80_h: Maybe there is something here http://www.haskell.org/communities/05-2005/html/report.html
16:10:34 <sethk> astrolabe, he's gone.  I think he was looking for Network.Socket
16:10:59 <dons> I always think a `monoid' is some kind of tumourous growth
16:11:47 <Pseudonym> Yeah, I had to get the doctor to remove a monoid from my toe once.
16:12:15 <dons> well, excessive UV light can contribute to the spread of monoids. you have to be careful
16:12:20 <Pseudonym> My wife had a fibration once.  Very painful.
16:12:39 <dons> @seen lambdabot
16:12:39 <lambdabot> Yes, I'm here.
16:12:49 <dons> silly bot, you should say what channels you're in
16:13:00 <dons> @todo-add @seen on lambdabot should report lambdabot's channels too
16:13:00 <lambdabot> Entry added to the todo list
16:13:24 <dons> @code
16:13:25 <lambdabot> module "code" screwed up: getRandItem: empty list
16:13:43 <sethk> I don't know, I want the behavior of WriteMode, and just because I typed AppendMode, it didn't do what I wanted.
16:13:43 <dons> @quit try again
16:13:48 <dons> @code
16:13:53 <sethk> It should have known what I really meant.  :)
16:13:59 <lambdabot> module "code" screwed up: Text.Regex.Posix.regcomp: error in pattern
16:14:17 <dons> @dice 2d6
16:14:18 <lambdabot> 2d6 => 10
16:14:25 <dons> @yow
16:14:25 <lambdabot> Finally, Zippy drives his 1958 RAMBLER METROPOLITAN into the faculty
16:14:25 <lambdabot> dining room.
16:14:29 <Pseudonym> @dice 3d20+10
16:14:29 <lambdabot> 3d20+10 => 36
16:14:48 <Pseudonym> @dice d5
16:14:49 <lambdabot> "dice" (line 1, column 1):
16:14:49 <lambdabot> unexpected "d"
16:14:49 <lambdabot> expecting digit
16:14:56 <Pseudonym> @dice 1d5
16:14:57 <lambdabot> 1d5 => 1
16:15:11 <Pseudonym> Your exercise is now to build a physical fair d5.
16:15:29 <Pseudonym> And not a top, either.
16:16:35 <astrolabe> You could make a d20, and put the same number on 4 sides
16:16:58 <dons> @code
16:16:58 <lambdabot> module "code" screwed up: Text.Regex.Posix.regcomp: error in pattern
16:17:00 <dons> bah
16:17:15 <Pseudonym> Actually, you could in general segment a sphere such that the areas of the faces are the same.
16:17:19 <Pseudonym> I think that's fair.
16:17:28 <Pseudonym> The faces need not be congruent.
16:18:16 <astrolabe> Pseudonym:You might get arguments
16:18:52 <astrolabe> it would be hard to read sometimes
16:19:02 <Pseudonym> @todo-add @dice Allow "d6" form as a shorthand for "1d6".
16:19:03 <lambdabot> Entry added to the todo list
16:20:07 <astrolabe> @dice 1000d2
16:20:07 <lambdabot> 1000d2 => 0
16:20:17 <Pseudonym> @dice 1000d2
16:20:17 <lambdabot> 1000d2 => 0
16:20:20 <Pseudonym> @dice 1000d2
16:20:20 <lambdabot> 1000d2 => 0
16:20:22 <Pseudonym> @dice 1000d2
16:20:22 <lambdabot> 1000d2 => 0
16:20:25 <Pseudonym> Errr...
16:20:29 <Pseudonym> @dice 1000d2
16:20:30 <lambdabot> 1000d2 => 0
16:20:33 <dons> big numbers are squashed
16:20:44 <dons> since they lead to stack oflows in the current impl.
16:20:57 <Pseudonym> Garbage in, diagnostics out.
16:21:14 <dons> 0 is a diagnostic, if you get it enough times
16:21:26 <Pseudonym> So it's a stochastic diagnostic.
16:21:37 <dons> ask musasabi anyway. it's his plugin ;)
16:21:55 <dons> umm.. hang on. you're the author. it's *Pseudonym*'s fault!
16:21:57 <Pseudonym> @todo-add @dice Handle large numbers (e.g. 1000d2) sanely. Either work or report an error.
16:21:58 <lambdabot> Entry added to the todo list
16:22:44 <Pseudonym> Oh am I just.
16:23:32 <dons> hehe
16:23:40 * dons runs and hides
16:24:09 <Pseudonym> No need.  I'm very, VERY good at avoiding blame.
16:24:39 <Pseudonym> That, of course, is the #1 skill required of an engineer.
16:25:09 <Pseudonym> According to Dilbert, the goal of an engineer is to get to retirement without being blamed for a major failure.
16:28:46 <dons> a worthy goal, indeed
16:30:29 <int80_h> I had to leave a minute seth, did you add anything to my quest for socket/port libraries?
16:31:19 <sethk> int80_h, did you see what I wrote about Network.Socket?
16:32:00 <sethk> int80_h, Network.Socket is the berkeley sockets interface, which I think you are familiar with
16:32:30 <int80_h> oh I missed that
16:32:36 <int80_h> but thanks :)
16:33:38 * int80_h is all excited now
16:50:53 <juhp> dcoutts: pong
17:07:05 <machack666> I have a computation which is recursive, wherein I am testing sets of hypotheses.  For a given iteration, the whole hypotheses should fail if any one of the conditions is false (determined by a predicate p -> Bool).  These speculations are ranked in order of likelihood for failure, so the ones which provide the most information regarding failure occur first.  so our conditions are [Cond] for our hypothesis, [Hyp].  We are trying
17:07:05 <machack666>  to prove which hypotheses in [Hyp] are correct, so we want to abort the particular hypothesis when on of [Cond] fails -- there is no more point in trying further iterations of [Cont].  How do I break out of the processing of [Cond]?  It seems like a continuation may do what I need, but pointers in the right direction would be appreciated.
17:08:40 <franka> You can also use the exception monad.
17:09:41 <franka> Control.Monad.Error
17:11:28 <machack666> any examples of this in action?  I want to resume processing on the next [Hyp], just without further considering that hypothesis for future iterations.
17:13:17 <franka> I don't know of any online examples offhand, sorry.
17:13:33 <machack666> thanks anyway -- gives me a little more to go on.
17:29:03 <araujo> @index oenFile
17:29:04 <lambdabot> bzzt
17:29:05 <araujo> @index openFile
17:29:06 <lambdabot> System.IO
17:29:23 <cjs> lambdabot's a bit cheeky!
17:46:49 <dons> hmm. we could use the spell checker to correct mistakes to @index
17:46:52 <dons> that would be interesting
17:47:01 <dons> and pretty easy too
17:47:15 <dons> @todo-add spelling correction in @index, @doc
17:47:15 <lambdabot> Entry added to the todo list
17:47:23 <cjs> Oh no. Just what we need. "lambdabot: type 'openFile', dummy!"
17:48:44 <dons> no, I was thinking more that it would just return the nearest match, using first the prefix (if it is unique), and then trying the levinshtein edit distance
17:48:52 <dons> as we already do for top-level cmds
17:48:59 <dons> @botsanck
17:48:59 <lambdabot> :)
17:49:03 <dons> :)
17:49:47 <dons> we can do this for any cmd that has a static list of args
17:49:52 <dons> so not, say, @eval or @type
17:49:57 <dons> but the index-ish cmds
17:51:40 <dons> @todo
17:51:40 <lambdabot> 0. SamB: A way to get multiple results from a google search
17:51:40 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
17:51:40 <lambdabot> 2. SamB: stop mangling long urls
17:51:40 <lambdabot> 3. dons: improve formatting of @dict
17:51:40 <lambdabot> 4. dons: write Haskell Manifesto
17:51:43 <lambdabot> [18 @more lines]
17:51:52 <dons> @more
17:51:53 <lambdabot> 5. lispy: don't let lambdabot's prettyprinter split the sequence @foo
17:51:53 <lambdabot> across lines
17:51:53 <lambdabot> 6. TheHunter: priviledged users should get priviledged listcommands.
17:51:53 <lambdabot> 7. TheHunter: @type 1 :: Int
17:51:53 <lambdabot> 8. lispy: haddock gives a link from a type signature to the types.  It
17:51:55 <lambdabot> [13 @more lines]
17:52:04 <dons> @type 1 :: Int
17:52:05 <lambdabot> Int :: Int
17:52:08 <dons> heh
17:52:16 <dons> @more
17:52:16 <lambdabot> more: empty buffer
17:52:20 <dons> bah
18:40:57 <sethk> @seen sethk
18:40:58 <lambdabot> You are in #haskell. Last spoke just now.
18:41:01 <sethk> thanks
18:42:23 <Yubanalesco> o_O
18:42:27 <Korollary> that was weird
18:42:32 <Korollary> @seen sethk
18:42:32 <lambdabot> sethk is in #haskell. Last spoke 1 minute and 31 seconds ago.
18:42:53 <sethk> @seen sethk
18:42:54 <lambdabot> You are in #haskell. Last spoke just now.
18:43:07 <sethk> @seen sethk
18:43:08 <lambdabot> You are in #haskell-blah and #haskell. Last spoke just now.
18:43:14 <sethk> it only tracks haskell channels.
18:43:17 <Korollary> @seen sethk
18:43:18 <lambdabot> sethk is in #haskell-blah and #haskell. Last spoke 2 seconds ago.
18:43:23 <sethk> I was trying to get it to tell me the name of a channel I forgot  :)
18:44:07 <Yubanalesco> Well, you could always look, on-by-one, in the channel list!
18:44:13 <Yubanalesco> *one-by_one
18:44:38 <sethk> I found it actually.  /msg chanserv list pattern  doesn't really work properly
18:45:29 <sethk> Yubanalesco, there are a lot of channels on freenode  :)
18:45:46 <Yubanalesco> ;)
18:46:07 <Yubanalesco> Brute force attack always work! You just don't know when!
18:48:03 <sethk> plus my tivo won't fast forward when it is in real time mode
18:48:07 <sethk> nothing works  :)
19:16:18 <dons> I only tracks channels it's in
19:16:52 <dons> s/I/Lambdabot
19:20:55 <rep> hello
19:23:09 <Korollary> hello
19:24:39 <Korollary> Jesus, there are 333 in #perl
19:24:56 <sethk> people coding in perl need lots of help.  :)
19:25:23 <Korollary> I've been studying it for work
19:25:58 <Korollary> It's been... an experience...
19:27:23 <gzl> the contextual sigils are goofy
19:28:44 <dons> does this mean that there are 2/3rds as many haskell users on the planet, as perl users?
19:29:14 <Korollary> as you very well know, no :)
19:30:03 <dons> what!? they're equal?? or are there now more haskell hackers, since we *turned* all the perl guys?
19:30:39 <Korollary> there are 1/3 as many scheme coders as well then
19:30:50 <dons> cool. fp rules!
19:34:16 <Yubanalesco> Humm, an elementary question. In graphs, what does it mean to add points component wise ?
19:34:44 <gzl> Yubanalesco: it means something like (a,b) + (c,d) = (a + c, b + d)
19:35:05 <gzl> though I'm not sure exactly what kind of problem you're talking about
19:35:13 <Yubanalesco> o_O I wonder why the lecturer ask me to do it...
19:35:57 <Yubanalesco> It just feels weird when all the questions before this requires a more advance style, and suddently this.
19:36:03 <Yubanalesco> That is why I was asking...
19:36:19 <Cale> what was the question?
19:36:26 <gzl> yeah, what was the question
19:36:37 <Korollary> the terminology should have been "vertices" or something.
19:36:43 <Yubanalesco> Define the function that 'adds' two points component wise.
19:36:54 <gzl> hahah
19:37:00 <Cale> are points represented by pairs?
19:37:00 <Korollary> oh, not graph theory. just geometry
19:37:06 <gzl> ok, guess there wasn't much more to the question
19:37:07 <Yubanalesco> Yes.
19:37:15 <Yubanalesco> I was like o_O
19:37:17 <Cale> okay, then gzl's answer works
19:37:40 <Korollary> "vectors" maybe
19:37:40 <Cale> it's probably a priming question
19:37:54 <Yubanalesco> Is just that it feels weird :P The one before was defining Newton's Approximation method...
19:37:55 <gzl> if you want to deliberately complicate the problem, you might want to support adding two n-vectors component-wise
19:37:57 <Cale> Points in a vector space are vectors
19:38:14 <gzl> that's slightly less trivial but still very simple
19:38:15 <Yubanalesco> And the one before that one was about Modular exponentiation...
19:38:39 <Yubanalesco> yes it is simples, but then...Not something like...
19:38:44 <Yubanalesco> (a,b) + (c,d) = (a + c, b + d)
19:38:44 <Cale> how about the one after it?
19:38:44 <Korollary> Yubanalesco: Yes, an odd combination of questions.
19:39:01 <Cale> is it related?
19:39:08 <Yubanalesco> No, that was the last one.
19:39:11 <Cale> huh
19:39:15 <gzl> maybe he's just being nice then
19:39:16 <Cale> odd :)
19:39:19 <Cale> yeah
19:39:25 <Yubanalesco> A trick question!
19:39:26 <gzl> or he forgot the second half of the question
19:39:54 <Korollary> or he got bored
19:39:57 <gzl> or that
19:40:00 <Yubanalesco> Heh.
19:40:44 <Korollary> Bonus Q: What was Michael Jordan's free throw percentage in 94-95 ?
19:41:42 <gzl> 103.
19:42:19 <Yubanalesco> 103% o_O
19:42:21 <Yubanalesco> ?
19:42:53 <Korollary> He didn't play in 94-95
19:43:37 <arcus> can I get a tip on a data type I've written as an answer to a tutorial question?
19:43:44 <arcus> a tip or two.
19:44:24 <arcus> I might need a paste-bin
19:46:26 <Yubanalesco> I will want to die if I get a 99% in this coursework too :-/
19:46:57 <gzl> @paste
19:46:58 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:47:46 <sethk> we should put the paste bin in the subject line.  That's common for this sort of channel and I always look there for one.
19:50:47 <arcus> ok, so how do I edit the page? I've created a profile and signed in.
19:50:56 <arcus> someone said I'd have to do that the other day.
19:51:16 <gzl> one of those buttons
19:51:17 <gzl> at the top
19:51:22 <gzl> the little icons
19:51:36 <arcus> there are no buttons. They disappeared after I logged in.
19:51:40 <gzl> oh, weird.
19:51:42 <gzl> then I have no clue.
19:51:58 * Yubanalesco going to attempt to get 4 hours sleep before lectures
19:52:06 <Yubanalesco> Nite! ~_~
19:52:08 <gzl> I haven't used the paste page in a long time.
19:52:22 <arcus> well, I'll try ask without the paste bin, then.
19:52:52 <arcus> so, the question asked to define a tuple type, which could be constructed with 1 to 4 arguments.
19:53:47 <arcus> and then selectors such as tuple3 which would return Just thirdelement if there's a third element, and Nothing if otherwise.
19:54:17 <arcus> so I've ended up with 4 constructors, Tuple1, Tuple2, Tuple3 and Tuple4.
19:54:52 <arcus> I sort of thought initially I could get away with just having Tuple, and the system could work out from the number of arguments what it ought to do.
19:55:31 <arcus> is this not the case?
19:58:29 <gzl> you can't have two constructors with the same name, I'm pretty sure
20:04:28 <gzl> yeah, it doesn't like that.
20:05:38 <arcus> ok.
20:29:55 <sethk> arcus, I would use the record syntax instead of using a tuple type.  It's cleaner (IMO) because it uses names.  less brittle W.R.T. changes.
20:42:29 <Cale> foldTuple :: (a -> b) -> (a -> a -> b) -> (a -> a -> a -> b) -> (a -> a -> a -> a -> b) -> Tuple a -> b, guess the implementation :)
20:43:24 <aqua_scummm> whoa
20:46:02 <Cale> (for the Tuple type discussed above)
20:59:47 <aqua_scummm> missed it :/  its ok, im just here to listen anyways
21:00:18 <dons> it's much fun building lambdabot on a quad cpu box
21:02:05 <Cale> aqua_scummm: data Tuple a = Tuple1 a | Tuple2 a a | Tuple3 a a a | Tuple4 a a a a
21:05:45 <machack666> is there a function to return all possible permutations of a finite list?
21:07:30 <aqua_scummm> Cale: explain further, the first thing i saw is the implmentation of a Tuple of length between 1 and 4 inclusive?
21:07:42 <Cale> aqua_scummm: yeah
21:08:05 <Cale> I suppose more generally, you'd want to have distinct possibilities for element types
21:08:33 <aqua_scummm> yeah
21:08:48 <Cale> the folding function I gave the type for would take a bunch of replacement functions for the tuple constructors
21:08:50 <aqua_scummm> isnt that built in, would you ever actually need to define it like that?
21:09:16 <Cale> aqua_scummm: well, it's an exercise. There's no type which is currently quite like that
21:09:29 <aqua_scummm> ah ok :)
21:22:08 <Korollary> machack666: you can steal such a function from http://shootout.alioth.debian.org/benchmark.php?test=fannkuch&lang=ghc&id=0&sort=fullcpu
21:36:11 <machack666> Korollary, thanks
21:58:19 <sethk> I need to code the equivalent of bracket, but for any arbitrary monad.  bracket is only usable with the IO monad.
22:03:02 <Cale> well, exceptions can only be caught in IO
22:04:45 <Cale> but if you don't care about those, it's just something like bracket a r b = do { x <- a; v <- b x; r x; return v }
22:10:49 <sethk> Cale, hmm, I need to catch it within my StateT monad which is encapsulating IO, so I should be able to catch it with liftIO I think
22:14:39 <Cale> ah, yeah
22:19:12 <Cale> hmm
22:22:50 <aqua_scummm> well time to free up some RAM
22:22:55 <aqua_scummm> night
22:38:27 <C-Keen> moin.
22:49:43 <dons> @where newbinary
22:49:43 <lambdabot> I know nothing about newbinary.
23:07:57 <dcoutts> juhp, you still about?
23:08:04 <juhp> dcoutts: yeah
23:08:45 <phys_rules> do you people ever sleep ? =)
23:08:52 <dcoutts> psi, I'd suggest you ask mwc about gtk on osx
23:09:15 <juhp> phys_rules: well I'm in an Asian timezone :)
23:09:18 <dons> phys_rules, we're a global channel:
23:09:19 <dons> @map
23:09:20 <dcoutts> juhp, just wondering about Fedora packages for Gtk2Hs 0.9.10 :-)
23:09:20 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:09:25 <dons> juhp!?
23:09:35 <juhp> dons: hey
23:09:42 <dons> where are you now then?
23:09:45 <dcoutts> juhp, you saw the release announcement I hope
23:10:48 <phys_rules> dons: the setup.lhs fails for the latest hs-plugins (just took it off darcs)
23:11:03 <dons> we need a newer Cabal, iirc
23:11:05 <dcoutts> juhp, I do beleive this is the most bug free release ever :-)
23:11:11 <dons> update your Cabal to 1.14
23:11:38 <dcoutts> we've had lots of people start using Gtk2Hs since the last release and that has flushed out a number of bugs
23:11:41 <juhp> dcoutts: congrats!  Now I saw it ;)
23:11:49 <phys_rules> dons: but I just replaced the main = with defaultMain and it all works fine ;)
23:11:51 <juhp> cool
23:12:01 <dons> phys_rules, that'd do it as well ;)
23:12:03 <dcoutts> and we've now got cairo and full pango bindings too :-)
23:12:20 <juhp> dcoutts: I did build rc1 iirc, but think I need to adjust the install scripts
23:12:27 <dcoutts> and celebrity endorcements! :-)
23:12:30 <dons> where does NewBinary live these days?
23:12:42 <juhp> dons: still^Wback in Japan
23:12:49 <dcoutts> juhp, right, ok
23:12:55 * juhp was in Europe last week...
23:13:47 <juhp> dcoutts: ok, I'll try to do builds for Fedora real soon - what I really want is to submit to Fedora Extras
23:13:58 <dcoutts> juhp, that'd be cool
23:14:06 <juhp> dcoutts: I guess it will be something like ghc641-gtk2hs there?
23:14:44 <juhp> dcoutts: well ghc-gtk2hs and ghc641-gtk2hs-* subpackages
23:15:03 <dcoutts> juhp, ah right, I was about to ask about the subpackages
23:15:15 <dcoutts> we're going to be moving in that direction anyway
23:15:27 <juhp> I don't really like that naming scheme too much, but that seems what python and perl, etc are doing...
23:15:36 <dcoutts> ok
23:15:48 <juhp> dcoutts: how is it in gentoo?
23:16:10 <dcoutts> juhp, it's just dev-haskell/gtk2hs in gentoo with USE flags for the optional bits
23:16:22 <dcoutts> however that doesn't give very satisfactory deps
23:16:35 <dcoutts> I think eventually all the gtk2hs packages will be Cabal packages
23:16:53 <juhp> (up to now I have been using gtk2hs-ghcXYZ*)
23:16:57 <dcoutts> though they might all live in one tarball they shuld become buildable independently
23:17:06 <juhp> sounds good
23:17:40 <dcoutts> it's mostly waiting on improved support in Cabal
23:17:51 <juhp> okay
23:17:56 <dcoutts> but also on us switching back to the mainline c2hs
23:18:13 <juhp> aha
23:18:29 <juhp> has c2hs caught up?
23:18:43 <dcoutts> well c2hs is now fast
23:18:53 <dcoutts> but we have some feature drift
23:19:11 <dcoutts> in paricular in the handling of ForeignPtr
23:19:45 <dcoutts> we were in discussion with Manuel a couple months ago. We need to restart discussions.
23:19:56 <juhp> ok
23:20:04 <juhp> these things take time...
23:20:16 <dcoutts> it looked like there was a workable solution which didn't involve us rewriting everything :-)
23:20:27 <juhp> oh good
23:22:50 <dcoutts> juhp, so in the end the gentoo naming convention for a Cabal package Foo will probably be just dev-haskell/foo
23:23:53 <juhp> dcoutts: sorry, is dev-haskell part of the main gentoo distro?
23:24:45 <juhp> seems so
23:25:50 <dcoutts> we might be able to slot different versions of ghc and we're already aiming at slotting different versions of Cabal libraries
23:25:52 <juhp> you have quite a lot of packages there... :)
23:25:53 <dcoutts> now that ghc supports multiple versions of a library without complaining too much
23:28:34 <dcoutts> yep
23:28:43 <dcoutts> gentoo uses package categories
23:29:00 <dcoutts> eg sys-libs/glibc
23:29:18 <dcoutts> the catrgory is optional if the package name is unique
23:47:05 <dcoutts> juhp, I assume FC$ is using Gtk+ 2.6.x right? You might want to not bother with the cairo package in that case since it'll only work standalone (ie without Gtk) which I find tends to confuse people
23:47:12 <dcoutts> FC4 I mean :-)
23:47:29 <juhp> dcoutts: right
23:47:44 <juhp> dcoutts: fc devel has gtk 2.8
23:48:00 <juhp> and fc5 is due early next year
23:48:03 <dcoutts> cool
23:48:09 <musasabi> Seems that for a suitable usage-pattern Data.Sequence is 2x slower than Data.Queue :-(
23:48:09 <dcoutts> for that one we'll be fine
23:48:25 <juhp> :)
23:49:07 <ibid> is it conceivable that a haskell program's virtual & resident size both grow slowly although GC stats show a fairly constant-sized live set
23:50:22 <dcoutts> ibid, seems unlikely that there would be continued growth much above the maximum GC heap size
23:50:45 <dcoutts> unless you're using foreign objects that are not accounted for in the GC size
23:51:45 <ibid> dcoutts: this is a JyuGraphics program
23:51:57 <dcoutts> ah, hmm
23:52:12 <ibid> wanna take a look at it?
23:52:12 <dcoutts> that has plenty of foreign objects :-)
23:52:19 <dcoutts> ibid, yeah, sure
23:53:29 <ibid> msgd
23:53:53 <MarcWeber> Good morning! Having the data type
23:53:58 <MarcWeber> data Sheep = MkSheep { name:: [Char], father::(Maybe Sheep), mother::(Maybe Sheep) }
23:54:29 <MarcWeber> deriving show I don't have any problems. But when specifying my own Show instance:
23:54:45 <MarcWeber> instance Show Sheep where   \n show s = "Sheep name : '" ++ name s  ++"'"
23:55:08 <MarcWeber> I get the error Ambiguous occurence of `show'. Why ?
23:57:33 <MarcWeber> Do you need some more information?
23:58:28 <musasabi> MarcWeber: that does not cause an error here.
23:59:29 <Korollary> MarcWeber: do you use "deriving" and "instance" at the same time ?
23:59:47 <MarcWeber> Korollary: I wish I would ;)
