00:04:42 <MarcWeber> This is my complete code and error messages from ghc: http://www.rafb.net/paste/results/5BPW5u90.html
00:08:31 <Korollary> MarcWeber: in the instance declaration, you use "show :: Sheep -> [Char]".
00:09:19 <boegel|home> suppose I know the values of a/x b/y and c/z, is there some way to derive the value of (a+b+c)/(x+y+z) without knowing the values seperatly ?
00:09:20 <MarcWeber> Korollary: And what should it look like? I did also try omitting this line.
00:09:24 <Korollary> MarcWeber: the typeclass Show requires "show :: a -> String". Removing the type annotation may fix it.
00:09:29 <Korollary> oh ok
00:10:06 <MarcWeber> Korollary: I'm afraid it doesn't..
00:10:38 <Korollary> Uh. It compiles here even with the annotation.
00:13:40 <Korollary> ah ok
00:13:44 <Korollary> it doesnt link
00:14:34 <MarcWeber> boegel|home: Don't think so. because think of a=2, x,b,y,c,z=1. Then you'll have a/x=2 , b/y =1 and (a+b+c)/(x+..)=4/3
00:15:48 <MarcWeber> Now let a/x be 4/2=2 (equal to the previous case, But (a+b+c)/(x+y+z) will be 6/4=3/2 now
00:16:06 <MarcWeber> Korollary: Should I try another compiler then ghc?
00:16:15 <Korollary> MarcWeber: you have an indentation problem
00:16:19 <boegel|home> MarcWeber: nice example
00:17:48 <Korollary> MarcWeber: I removed the annotation and indented the show definition and it compiled and linked.
00:17:51 <MarcWeber> instance ... \n \tab show.. right?
00:18:15 <MarcWeber> I've tried that  but got another error (due to the wrong type annotation). Thanks!
00:18:20 <boegel|home> MarcWeber: that poses quite a big problem for me, but hey, I guess I'll have to live with it
00:18:37 <MarcWeber> boegel|home: I'm sorry, but it's impossible. Why do you need this?
00:19:39 <boegel|home> MarcWeber: for work
00:19:49 <boegel|home> because I'm doing measurements for benchmarks
00:19:56 <boegel|home> and I'm measuring each 10^5th instruction now
00:20:02 <boegel|home> I was hoping to aggregate the results for 10^6, 10^7 and so on
00:20:03 <MarcWeber> Korollary: You're a living walking compiler .. (at least the people who have passed a Java certification are called that way.. :)
00:20:07 <boegel|home> but now I can't, which means I have to run the tests again
00:20:14 <boegel|home> 1 benchmark took 89hours, so that means quite a lot of waste of time
00:20:19 <MarcWeber> Korollary: The type signature, is this right then: show :: Sheep -> String ?
00:20:50 * boegel|home makes a sheep sound in an attempt to be funny
00:21:28 <MarcWeber> *lol*.. Why do you need benchmarks which takes 89h?
00:21:57 <boegel|home> MarcWeber: the benchmark takes only 12min, but I instrumented it, to measure up some behaviour
00:22:08 <boegel|home> I'm doing research on the differences between benchmarks
00:26:58 <musasabi> How are Happy and Frown as compared to eachother?
00:29:49 <gour> dcoutts, hi, new release builds nicely
00:30:19 <MarcWeber> musasabi: Don't know Frown, haven't managed to use happy, yet.. Still busy learning monads ;)
00:32:01 <dcoutts> gour, excelent
00:32:40 <Itkovian> meuning
00:32:45 <gour> dcoutts, how does the roadmap for gtk2hs look like?
00:33:07 <Itkovian> why hi boegel|home
00:38:26 <boegel|home> why hi Itkovian
00:38:33 <boegel|home> hwo're things? :)
00:38:51 * Itkovian thought we had holiday on Monday and had to work today. Seems it's the other way around
00:39:04 <boegel|home> Itkovian: no, we have both ! :)
00:39:14 <boegel|home> check the caldendar
00:39:20 <boegel|home> *calendar
00:40:47 <Itkovian> boegel|home: well ... the paris calendar mailed me that today was holiday, but it said nothing about Monday.
00:41:11 <boegel|home> Itkovian: you should check the academic calendar, it's on there...
00:41:21 <Itkovian> ok.
00:41:23 <Itkovian> whatever.
00:41:31 <Itkovian> I'm gonna work anyway today
00:41:54 <Itkovian> Maybe I can finish the floor in the basement ...
00:42:06 <Itkovian> anyway ... this seems rather OT.
00:43:09 <boegel|home> nah :P
00:44:01 <boegel|home> anyway, I have to go
00:44:13 <boegel|home> I promised to help out Joke's niece with her pc
00:44:16 <boegel|home> she's cute, so hey :)
00:44:28 * boegel|home = off
00:50:18 <Itkovian> uhu
01:45:39 <dcoutts> gour, the gtk2hs roadmap? well in the release announcement I said a 1.0 release :-)
01:46:01 <gour> dcoutts: with nothing in between?
01:47:16 <dcoutts> dunno, I guess it depends on what turns up
01:48:32 <gour> dcoutts: ok, you're using evolution?
01:48:48 <dcoutts> yep
01:50:05 <gour> dcoutts: it looks like custom fields one uses on Palm Pilot pdas, does not sync
01:50:19 <dcoutts> sorty, no idea about that
01:50:25 <gour> dcoutts: and there is no way to define custom-fields in evolution like in e.g. kontact?
01:50:53 <jak> @index unfoldr
01:50:54 <lambdabot> Data.List
01:51:04 <gour> dcoutts: anyway, that's why i plan to move all my contacts in the future haskell application which
01:51:09 <dcoutts> gour, I don't know.
01:51:14 <gour> dcoutts: will embed sqlite3 database
01:51:29 <gour> dcoutts: that's why i need libgda/libgnome :-)
01:52:29 <dcoutts> I see
02:00:16 <ProfTeggy> G'day all.
02:07:33 <kosmikus> hi there
02:07:58 <kosmikus> ProfTeggy: nothing to write for the HCAR?
02:08:18 <ProfTeggy> Hi Andres.
02:08:28 <ProfTeggy> Please expand the acronym for me.
02:08:40 <ProfTeggy> Haskell Community ... Report?
02:09:16 <kosmikus> and Activities
02:09:20 <kosmikus> haskell.org/communities
02:09:26 * ProfTeggy nods.
02:11:29 <araujo> Morning!
02:11:39 <kolmodin> morning!
02:11:48 <kolmodin> @localtime araujo
02:11:49 <lambdabot> Local time for araujo is Wed Nov  2 06:11:15
02:11:56 <araujo> kolmodin, hello :-)
02:12:14 <kolmodin> it really is early in te morning for you :)
02:12:31 <araujo> :-)
02:12:40 * araujo just wakin' up
02:14:46 <kosmikus> ProfTeggy: so, don't you want to write something about pathfinder and where you use Haskell?
02:29:13 <wearpants> can anyone help me with arrays in Haskell? I want to know about the performance
02:30:44 <Speck> the author of the haskell xml toolbox would be a good person to ask
02:31:08 <Speck> see if his arrow implementation is speedy
02:31:32 <Speck> I heard that PArrows is pretty fast for being basically unoptimized
02:31:58 <wearpants> well
02:32:15 <wearpants> I'm basically just curious since I'm taking a course on Haskell this semester
02:32:28 <wearpants> talked to the professor yesterday and decided to try and optimize my program
02:32:42 <wearpants> was thinking arrays might be helpful, but I'm not sure.
02:34:36 <Speck> I don't know enough haskell to offer any good optimization techniques; ghc at least does some pretty funny stuff that make it by-and-large  beyond my reasoning
02:34:58 <Speck> I wonder if there's any info on the wiki
02:36:09 <wearpants> *nods*
02:36:23 <wearpants> I've noticed that !! performs interestingly well.
02:36:55 <wearpants> it's still O(n), but you can never forget that O(n) is really x0*n + x1
02:37:50 <dcoutts> wearpants, the rule of thumb for arrays in Haskell is that indexing is fast, updating is slow
02:37:57 <dcoutts> and uboxed arrays are even faster
02:38:25 <dcoutts> mutable arrays give fast updates but are annyoing to use since they're imperitive
02:38:39 <flux__> wearpants, you might want to familiarize yourself with diff arrays, they are cool, if you haven't already
02:39:15 <dcoutts> though they tend to be rather slow
02:40:34 <ProfTeggy> kosmikus, when would be the deadline for HCAR?
02:40:57 <kosmikus> ProfTeggy: it was yesterday ;)
02:41:05 <wearpants> hmm
02:41:12 <kosmikus> but when would you want it to be?
02:41:26 <wearpants> well, I have to create and iteratively update a graph
02:41:39 <wearpants> so I'm not sure that arrays would improve anything due to the copying
02:41:50 <ProfTeggy> kosmiskus, now way then.  My second baby is on its way (schedule to arrive this week) => busy time in the 2-4 weeks ahead.
02:41:54 <ProfTeggy> s/now/no/
02:41:59 <wearpants> I'm using an adjacency list representation right now
02:42:11 * wearpants has an idea
02:42:25 <wearpants> could use an array of arrays which is not the same thing as a matrix
02:44:09 <kosmikus> ProfTeggy: ok, in 6 months then :)
02:44:43 <dcoutts> wearpants, the Data.Graph library uses mutable arrays internally. STArrays
02:44:47 <ProfTeggy> That sounds more realistic.  I have an incomplete DFG proposal on the desk, too.
02:45:18 <kosmikus> ProfTeggy: I thought that maybe you had something lying around already that you could just reuse with about 5 minutes of work. This sort of thing doesn't have to be long ...
02:45:41 <kosmikus> but your first reason is a very good one :)
02:45:44 <sylvan> @source Data.List
02:45:45 <lambdabot> lambdabot 3p168, GHC 6.5.20050806 (Linux i686)
02:45:45 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:45:55 <sylvan> @src Data.List
02:45:56 <lambdabot> Maybe you meant: arr ghc
02:46:05 <sylvan> @help src
02:46:06 <lambdabot>  @help <command> - ask for help for <command>
02:46:09 <sylvan> @help source
02:46:10 <lambdabot> Report the build date, ghc version and darcs repo of this bot
02:46:13 <ProfTeggy> kosmikus, since the focus of Pathfinder really is on the database/XML side (Haskell really only being a vehicle here), I got nothing like that lying around.
02:46:20 <sylvan> wth... What's the command to link me to GHC-source?
02:46:26 <wearpants> dcoutts - but that's not part of Prelude, is it?
02:47:50 <shapr> @libsrc Data.Char.ord
02:47:51 <lambdabot> Data.Char.ord not available
02:47:57 <shapr> @help libsrc
02:47:57 <lambdabot> library source
02:48:15 <sylvan> ah.. thanks
02:48:19 <sylvan> @libsrc Data.List
02:48:19 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
02:50:20 <kosmikus> ProfTeggy: I hope your second child will be as enthusiastic about reading academic papers as your first one ;)
02:50:33 <ProfTeggy> kosmikus, :-)
02:50:46 <ProfTeggy> It will be a boy, for a change.
02:51:12 <ProfTeggy> I'll get him into FP as soon as possible.  Age 5, say.
02:51:28 <ProfTeggy> Well, maybe into soccer, first.  But then FP.
02:57:17 <dcoutts> wearpants, the array modules all live under Data.Array.*
02:57:26 <dcoutts> @doc Data.Array
02:57:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
02:57:39 <dcoutts> @doc Data.Array.Mutable
02:57:40 <lambdabot> Data.Array.Mutable not available
02:57:41 <wearpants> yes, but if my professor does not have this library then I can't use it
02:57:58 <dcoutts> it's part of the standard ghc library collection
02:58:01 <wearpants> ok
02:58:34 <dcoutts> @doc Data.Array.MArray
02:58:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
02:58:36 <dcoutts> @doc Data.Array.ST
02:58:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-ST.html
02:58:41 <dcoutts> etc
02:58:51 <dcoutts> you can see them all from:
02:58:51 <dcoutts> http://haskell.org/ghc/docs/latest/html/libraries/index.html
03:00:39 <wearpants> isn't there a standard function with type Maybe a -> (a -> b) -> Maybe b?
03:00:48 <wearpants> or something along those lines
03:01:13 <wearpants> I've benn hunting but no luck
03:01:19 <wearpants> been, too
03:01:31 <dcoutts> @type fmap
03:01:32 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
03:01:51 <dcoutts> @type (fmap :: (a -> b) -> Maybe a -> Maybe b)
03:01:52 <lambdabot> forall a b. (a -> b) -> Maybe a -> Maybe b
03:01:53 <wearpants> ah.
03:01:57 <wearpants> right
03:02:10 <dcoutts> since Maybe is a Functor
03:04:21 <wearpants> yes; I didn't think of that :p
03:04:37 <wearpants> I'm really tired, that wasn't quite what I was looking for, but it will work...
03:04:47 <wearpants> I got the type wrong
03:04:55 <dcoutts> in hugs or ghci ":info Functor" will tell you the instances of the Functor class
03:05:13 <wearpants> yes, I know; Maybe is a Functor because it is a Monad
03:05:15 <dcoutts> or ":info Maybe" will tell you the classes the type is an instance of
03:07:42 <{Arias}> araujo, are you there?
03:07:45 <{Arias}> 8-)
03:09:12 <{Arias}> can somebody help me with an english question?
03:09:15 <{Arias}> x)
03:10:31 <wearpants> {Arias} - qué necesitas?
03:10:51 <{Arias}> traducir "ha ocurrido un error mientras se leia del fichero"
03:10:52 <{Arias}> xD
03:11:15 <wearpants> "An error occured while reading the file."
03:11:42 <{Arias}> es que no sabia como poner ocurrido
03:11:48 <wearpants> ah
03:11:59 <wearpants> ha occurido = it has occured
03:12:00 <{Arias}> solo se me ocurria "happened" y no me sonaba muy bien :(
03:12:05 <wearpants> pero se suene mejor decir "An error occured"
03:12:42 <{Arias}> gracias... thanks
03:12:58 <{Arias}> where are you from?
03:13:34 <wearpants> the US
03:13:37 <wearpants> de nada
03:13:43 <wearpants> I live in Florida
03:13:52 <{Arias}> ohm
03:13:57 <{Arias}> why do you speack spanish?
03:13:58 <{Arias}> xD
03:14:03 <{Arias}> speak
03:14:09 * earthy could even read it
03:14:12 <wearpants> because I want to
03:14:17 <earthy> spanish is not that hard
03:14:29 <wearpants> because I learned it in school
03:14:41 <{Arias}> ohm
03:14:45 <wearpants> creo que es mejor aprovechar del tiempo
03:14:50 * Akshaal learned english in school
03:14:52 <{Arias}> you speak spanish very well :)
03:14:56 <wearpants> thanks
03:15:09 * earthy learned English, French and German in school
03:15:26 <earthy> oh, and Pascal :P
03:15:32 <{Arias}> aprovechar *el* tiempo
03:15:40 <wearpants> ah, gracias
03:16:08 <{Arias}> de nada, ya me gustaria hablar ingles como tu español
03:16:16 <wearpants> ;)
03:16:43 <wearpants> eres de España?
03:16:46 <{Arias}> si
03:17:10 <{Arias}> del norte de España
03:17:16 <wearpants> ah
03:17:26 <{Arias}> de donde Fernando Alonso
03:17:27 <{Arias}> xD
03:17:32 <srle> hello
03:17:38 <wearpants> cómo es?
03:17:41 <wearpants> 'lo there
03:17:43 <earthy> hiya srle
03:18:14 <srle> What is wrong in following code? : avg x = sum x / length x
03:18:15 <{Arias}> perdona, ¿cómo es el qué, España?
03:18:26 <srle> It doesn't work.
03:18:36 <wearpants> la ciudad dónde vives
03:18:46 <srle> I get error msg:ERROR - Cannot infer instance
03:18:47 <srle> *** Instance   : Fractional Int
03:18:54 <wearpants> srle - you need div
03:19:07 <wearpants> srle - (sum x) `div` (length x)
03:19:12 <Akshaal> sum x `div` length x
03:19:24 <wearpants> @type (/)
03:19:24 <lambdabot> forall a. (Fractional a) => a -> a -> a
03:19:27 <wearpants> @type div
03:19:28 <lambdabot> forall a. (Integral a) => a -> a -> a
03:19:32 <wearpants> see the difference? ;)
03:19:40 <{Arias}> se llama Oviedo
03:19:46 <srle> What do I have to do to get float result?
03:20:10 <wearpants> srle - then you want fromIntegral :p
03:20:25 <srle> wearpants : this is what bugs me: avg [1..10] - error
03:20:32 <srle> sum [1..10] -> 55
03:20:33 <wearpants> I think this would work: (fromIntegral (sum x)) / (fromIntegral (length x))
03:20:40 <srle> len [1..10] -> 10
03:20:49 <srle> 55/10 -> 5.5
03:21:01 <wearpants> yes, right
03:21:04 <roconnor> @eval let x=[1..10] in (fromIntegral (sum x)) / (fromIntegral (length x))
03:21:05 <lambdabot> 5.5
03:21:20 <wearpants> heh, there you go ;)
03:22:10 <srle> Thanks wearpants, lambdabot.
03:22:14 <sieni> @pl \x -> x
03:22:14 <lambdabot> id
03:22:31 <sieni> @pl \x (fromIntegral (sum x)) / (fromIntegral (length x))
03:22:32 <lambdabot> (line 1, column 18):
03:22:32 <lambdabot> unexpected "("
03:22:32 <lambdabot> expecting operator or ")"
03:22:36 <roconnor> @karma+ lambdabot
03:22:37 <lambdabot> lambdabot's karma raised to 5.
03:22:40 <sieni> oops
03:22:50 <sieni>  @pl \x -> (fromIntegral (sum x)) / (fromIntegral (length x))
03:23:01 <sieni> @pl \x (fromIntegral (sum x)) / (fromIntegral (length x))
03:23:02 <lambdabot> (line 1, column 18):
03:23:02 <lambdabot> unexpected "("
03:23:02 <lambdabot> expecting operator or ")"
03:23:05 <sieni> fuck
03:23:18 <sieni> @pl \x -> (fromIntegral (sum x)) / (fromIntegral (length x))
03:23:18 <lambdabot> ap ((/) . fromIntegral . sum) (fromIntegral . length)
03:23:34 <srle> @help
03:23:34 <lambdabot>  @help <command> - ask for help for <command>
03:23:48 <srle> @help help
03:23:49 <lambdabot>  @help <command> - ask for help for <command>
03:24:23 <sieni> @pl \x y -> (y (sum x)) / (y (length x))
03:24:24 <lambdabot> ap (ap . ((/) .) . flip id . sum) (flip id . length)
03:25:02 <sieni> @eval ap (ap . ((/) .) . flip id . sum) (flip id . length) [1..10] fromIntegral
03:25:03 <lambdabot> 5.5
03:25:08 <srle> @help eval
03:25:08 <lambdabot>  @eval <expr>
03:25:08 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
03:25:27 <srle> @help pl
03:25:28 <lambdabot>  @pointless <expr> - play with pointfree code
03:26:16 <liyang> @eval let avg x = sum x / genericLength x in avg $ map fromIntegral [1..10]
03:26:17 <lambdabot> 5.5
03:27:07 <srle> @commands
03:27:08 <lambdabot> Unknown command, try @listcommands.
03:27:15 <srle> @listcommands
03:27:16 <lambdabot> use listcommands [module|command], please. Modules are:
03:27:16 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
03:27:16 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
03:27:16 <lambdabot> topic type version vixen where
03:27:49 <srle> @listcommands where
03:27:50 <lambdabot> where provides: where what where+
03:28:00 <srle> @listcommands base
03:28:01 <lambdabot> base provides:
03:28:11 <srle> @listcommands code
03:28:12 <lambdabot> code provides: code
03:28:21 <srle> @listcommands plugs
03:28:21 <lambdabot> plugs provides: plugs eval
03:28:36 <srle> bye
03:43:29 <paolino_> morning, is there a more standard solution for this ?
03:43:31 <paolino_> Prelude List Data.Map> let f = let sm acc next = (acc+next,(acc+next,next)) in snd.(mapAccumL sm 0)
03:43:32 <paolino_> Prelude List Data.Map> f [1,2,3,4]
03:43:53 <paolino_> [(1,1),(3,2),(6,3),(10,4)]
03:44:45 <paolino_> I suppose somthing zipping the list against the partial accumulations
03:45:18 <paolino_> but I don't know about the function to perform partial accumulations
03:45:28 <paolino_> perform/calculate
03:46:00 <shapr> scan?
03:46:23 <kosmikus> @eval zip [1..] (scanl (+) 0 [1..4])
03:46:24 <lambdabot> [(1,0),(2,1),(3,3),(4,6),(5,10)]
03:46:41 <kosmikus> @eval tail $ zip [0..] (scanl (+) 0 [1..4])
03:46:42 <lambdabot> [(1,1),(2,3),(3,6),(4,10)]
03:46:57 <kosmikus> @eval tail $ zip (scanl (+) 0 [1..4]) [0..]
03:46:58 <lambdabot> [(1,1),(3,2),(6,3),(10,4)]
03:47:11 <paolino_> scanl
03:47:35 <paolino_> would never guess :P
03:47:39 <paolino_> thanks
03:47:58 <shapr> paolino_: Read through the Prelude, and Data.List. Whenever you find a function you don't know, play around with it.
03:48:08 <shapr> Suddenly you will become a powerful magician :-)
03:50:10 <kosmikus> @eval zip (scanl1 (+) [1..4]) [1..]
03:50:11 <lambdabot> [(1,1),(3,2),(6,3),(10,4)]
03:53:39 <ProfTeggy> sum (zipWith (+) [1,2..50] [100,99..50])  =  sum [1..1000]
03:53:49 <ProfTeggy> Which historical anecdote does this reflect?
03:53:50 <ProfTeggy> :-)
03:53:59 <ProfTeggy> err sum [1..100]
03:58:14 <shapr> Supposedly that's how Gauss solved the 'get out of my face' homework problem.
03:58:36 <ProfTeggy> Wonderful, shapr
03:58:43 <{Arias}> in 1787 :D
03:58:55 <{Arias}> when he had 10 years
03:59:24 <{Arias}> @type zipWith
03:59:25 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
04:00:03 * shapr tries to think of a geeky trivia question...
04:00:08 <ProfTeggy> 50 * head (List.nub (zipWith (+) [1,2..50] [100,99..50]))  would be a better lhs, I'd say
04:00:17 <sieni> that would be "wanha" as we say in Finnish net culture
04:00:43 <shapr> Which influential mathematician died in their early twenties in a pistol duel?
04:00:50 <{Arias}> [1,2..50] [100,99..51] no?
04:01:00 <{Arias}> you put 50 twice
04:01:07 <ProfTeggy> Yes, Arias
04:01:18 <ProfTeggy> It didn't matter because of the zipWith.
04:01:22 <ProfTeggy> Thanks for the correction.
04:01:30 <{Arias}> ^^
04:02:00 <shapr> And whoever knows the answer to my trivia question gets to come up with the next question :-)
04:02:09 <sieni> galois
04:03:03 <shapr> sieni: Correct! http://en.wikipedia.org/wiki/Galois
04:03:15 <ProfTeggy> Trivia in the age of Google is questionable in a sense.
04:03:34 <wolverian> sieni, hello, I like your nick. :)
04:03:40 <sieni> wolverian: thanks
04:03:47 <shapr> ProfTeggy: Yeah, but using google is no fun.
04:04:01 <shapr> ProfTeggy: Anyway, geeky trivia games are best played around a table at a bar or restaraunt.
04:04:15 * ProfTeggy nods.
04:04:34 <shapr> sieni: Ok, we await your trivia question
04:05:21 <sieni> Ok.
04:05:23 <shapr> Maybe we should save these questions and build a @trivia plugin for lambdabot :-)
04:06:09 <sieni> Which famous mathematician took the Binet IQ test and the score labeled him an imbecile?
04:06:32 * shapr has no idea
04:07:48 <ProfTeggy> Poincare?
04:08:15 <sieni> ProfTeggy: excellent, your turn :-)
04:08:23 <ProfTeggy> No, no, not m again
04:08:27 <ProfTeggy> s/m/&e/
04:09:12 <shapr> Well, you answered the last question...
04:09:19 <ProfTeggy> Ouch
04:09:21 <shapr> so you probably know more nifty trivi
04:09:23 <shapr> a
04:11:09 <ProfTeggy> Who discovered the principle of gravity while taking a bath?
04:11:44 <sieni> newton?
04:12:04 <earthy> mu. :)
04:12:08 <shapr> err, Archimedes?
04:12:15 <ProfTeggy> shapr!
04:12:33 <earthy> The concept of displacement volume, that was Archimedes
04:13:00 <shapr> He used it to answer the question of "is my crown made entirely of gold" I think.
04:13:08 <sieni> Transire suum pectus mundoque potiri!
04:13:24 <earthy> that yeah
04:13:39 <earthy> but for the fact that he was greek. :)
04:14:26 <shapr> Ok, what famous Finnish scientist came up with the first working neural networks?
04:14:37 <shapr> er "working multilayer neural networks"
04:14:40 <jlouis> shapr: Writing a bittorrent client in haskell is fun, I can put up code if you want it
04:15:06 <shapr> jlouis: You sent me a patch that I haven't applied yet, I just need to disentangle my existing changes...
04:15:15 <shapr> jlouis: In any case, more code is definitely good :-)
04:15:51 <ProfTeggy> No clue, shapr.
04:16:11 <sieni> shapr: teuvo kohonen?
04:16:12 <shapr> sieni: c'mon, Finnish trivia ;-)
04:16:16 <shapr> sieni: tada!
04:17:02 <shapr> sieni: ok, your turn
04:17:20 <jlouis> shapr: http://j.mongers.org/pub/haskell/darcs/conjure/
04:18:05 <shapr> jlouis: oh, awesome!
04:18:26 * shapr bounces cheerfully
04:18:34 <jlouis> shapr: currently, its a scratchpad of thoughts and things
04:18:47 <jlouis> I am optimizing for -Ofun! (Thanks autrijus)
04:19:42 <jlouis> And I am working on the storage wrapper code right now. I walk yesterday fleshed most of the ideas out
04:19:51 <jlouis> A walk
04:20:09 <shapr> ProfTeggy: More info on Kohonen - http://en.wikipedia.org/wiki/Teuvo_Kohonen
04:20:20 <kosmikus> what's "conjure"?
04:20:44 <sieni> shapr: which mathematician, famous for his work on dynamical systems, shot himself on the same day as his wife died and died himself three days later?
04:20:48 <jlouis> conjuration is the summoning of things by magic
04:21:05 <jlouis> So ''conjure'' is a proper name for a bittorrent client ;)
04:21:16 <sieni> at the age of 61
04:21:45 <kosmikus> bittorrent client in Haskell? cool -- is it done already?
04:21:46 <shapr> I have no clue, I hope ProfTeggy or someone else knows this one.
04:22:09 <shapr> It looks far more complete than combinatorrent.
04:22:26 <jlouis> kosmikus: far from finished. I postulate I have 4.5 % of the code in the STYLE document ;)
04:22:46 <jlouis> patches go to jlouis@mongers.org
04:22:55 * boegel|home starts spamming
04:22:56 <kosmikus> jlouis: nice idea though, good luck
04:23:11 <Akshaal> hrr
04:23:17 <boegel|home> jlouis: watch out with sharing your mail-address in irc logged chat rooms
04:23:18 <Akshaal> is there cabal maintaner?
04:23:20 <jlouis> boegel|home: you have to evade the Baysian Filter ;)
04:23:24 <shapr> jlouis: Darcs includes a SHA1 by Igloo than works on FPS. That's the speedy way to go.
04:23:28 <jlouis> Bayesian filter
04:23:41 <jlouis> shapr: yeah, I know
04:23:44 <boegel|home> jlouis: I will :P
04:24:22 <jlouis> boegel|home: haha
04:24:27 <shapr> kosmikus: ok, now I want to update my Combinatorrent entry to point to jlouis' conjure :-)
04:24:58 <pesco> Combinatorrent?!
04:25:07 * pesco stretches.
04:25:15 <pesco> Good day, #haskell!
04:25:44 <shapr> Yeah, combinatorrent was my Bittorrent implementation in Haskell, but jlouis has more code, so I'd rather work from that.
04:25:55 <jlouis> shapr: for URL fetching, and SHA1 generation, anything that does it gets imported. Calling system() on wget or curl to /tmp and doing things will be imported
04:26:01 <kosmikus> shapr: right, I remember seeing the name in your submission.
04:26:02 <jlouis> that part is boring and we can always optimize it
04:26:07 <kosmikus> shapr: feel free to write an update.
04:26:07 <shapr> Though I do like the combinatorrent name for easy googling.
04:26:19 <shapr> kosmikus: ok
04:26:46 <jlouis> same for SHA1, we'll go with Igloos code and change it to sha1(3) via FFI it is too slow (I don't think so)
04:27:13 <shapr> I think it'll be fast enough. Plus I want to get comfortable with FPS, I think I'll use that library a lot.
04:27:42 <jlouis> Yeah, the storage wrapper would love FPS or the like
04:27:58 <jlouis> It is most of the thing I am working on these days
04:32:18 <shapr> An IRL friend of mine is learning Haskell and is interested in working on a bittorrent client, hopefully conjure/combinatorrent will be usable soon.
04:34:46 <shapr> A kademlia implementation would be fun in Haskell - http://en.wikipedia.org/wiki/Kademlia
04:36:34 <jlouis> we will definitely need to implement khashmir
04:36:50 <jlouis> I'd better add it to the TODO
04:39:30 <shapr> Ah Khashmir is based on Kademlia.
04:39:53 <jlouis> added to the TODO
04:40:25 <paolino__> how I write this in ghci ?
04:40:30 <paolino__> let f dist =  let keys,values = unzip.toList $ dist in zip (scanl1 (+) values) keys
04:41:20 <boegel|home> paolino_: seems broken
04:41:24 <dcoutts> toList?
04:41:28 <boegel|home> dist = let ?
04:41:39 <dcoutts> no, that's ok boegel|home
04:41:54 <boegel|home> dcoutts: oh, okay, I'm not familiar with it
04:41:59 <boegel|home> @index toList
04:42:00 <lambdabot> Data.Graph.Inductive.Internal.Heap, Data.HashTable, Data.IntMap, Data.
04:42:00 <lambdabot> IntSet, Data.Map, Data.Set
04:42:24 <boegel|home> @type unzip
04:42:25 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
04:42:28 <dcoutts> let f dist =  let (keys,values) = unzip.toList $ dist in zip (scanl1 (+) values) keys
04:42:47 <paolino__> :/
04:42:51 <dcoutts> but I'm not sure which toList is being used here, and even then it looks like a type error
04:43:12 <paolino__> it was cmplaining on '='
04:43:28 <jlouis> put it in a file and ghci file
04:43:53 <jlouis> on the top-level a let-binding needs an ``in'' scope in which the binding eventually is used
04:43:55 <dcoutts> yes because you meant "(keys,values) =" rather than "keys,values ="
04:44:08 <paolino__> python reminescences
04:44:14 <dcoutts> jlouis, actually you can write that in ghci: let foo = 3
04:44:31 <jlouis> dcoutts: ok, thanks for the correction ;)
04:44:33 <dcoutts> without an in. the in is the rest of the interactive session
04:44:47 <paolino__> ok dcoutts it works
04:44:50 <dcoutts> like you can write in a 'do' block
04:45:29 <paolino__> I hope it's enough haskellish also :P
04:48:56 <paolino__> is there a standard bisection search on a list ?
04:50:02 <astrolabe> Wouldn't it be slow on a list?
04:50:36 <roconnor> not if comparision is a long process.
04:51:06 <paolino__> like , how I search the nearest higher number in a sorted number list to a given number
04:51:08 <paolino__> ?
04:51:33 <paolino__> I see lists are no for that
04:52:07 <shapr> What's up with 2-3 finger trees?
04:53:17 <paolino__> if it's for me I don't knowwhat they are
04:53:26 <shapr> Just a broadcast question :-)
04:53:42 <shapr> I don't understand your question about nearest higher number?
04:54:27 <astrolabe> paolino: Maybe make a binary tree from the list and search that.
04:55:26 <paolino__> I have [(32,1),(42,2),(57,3),(69,4)]  if I say 47 you answer 3 if I say 30 you 1 61 -> 4 ......
04:55:32 <astrolabe> I think he wants to find the least number in the list which is greater than his query number
04:55:42 <paolino__> :)
04:55:59 <paolino__> least = nearest higher
04:56:07 <shapr> Why not dropWhile (=< mynum) ?
04:56:23 <roconnor> astrolabe is right.
04:56:25 <ProfTeggy> This is, as astrolabe has said, a search tree problem
04:56:43 <roconnor> @karma+ astrolabe
04:56:44 <lambdabot> astrolabe's karma raised to 1.
04:56:49 <ProfTeggy> ;-)
04:56:55 <astrolabe> Wow thanks :)
04:57:59 * paolino__ is working only on binary trees since he met haskell (2 weeks) :)
04:58:30 <ProfTeggy> paolino, if you can work with lists, you can work with bin trees
04:58:44 <ProfTeggy> The former is just a degenerated variant of the latter
04:59:02 <paolino__> poor lists
04:59:08 <ProfTeggy> Yes.
04:59:16 <shapr> paolino__: How do you like Haskell so far?
04:59:48 <paolino__> I feel like I was 12 in front of basic
05:00:05 <shapr> haha
05:00:11 <paolino__> full emotioned
05:00:17 <shapr> I feel like that when reading some Haskell research papers.
05:00:36 <shapr> tmoertel: cool blog post! I had to read the whole series!
05:01:35 <shapr> Anyone know TonyG at LShift.net ? It freaks me out when I'm reading someone's blog and they refer to my own blog.
05:01:57 <tic> welcome to the Internet.... ;-)
05:02:01 * shapr grins
05:02:42 <Itkovian> shapr: so how's the rss feed on your blog coming along?
05:02:51 <paolino__> at least on this tree I don't need a zipper , right ?
05:03:03 <shapr> Itkovian: I haven't even looked at it yet :-(
05:03:19 <shapr> I do agree that it needs to be done though.
05:03:20 <Itkovian> aiai ... you need an employee ;-)
05:03:35 <shapr> Maybe I could hire my girlfriend to write Haskell for me...
05:05:09 <paolino__> do I have to keep on plitting the list to build the search tree ?
05:05:55 * paolino__ blames his math unculture
05:06:05 <roconnor> there is a list2tree function somewhere
05:06:15 <Itkovian> shapr: didn't you have a company together?
05:06:46 <shapr> Itkovian: er, that was my last girlfriend...
05:07:17 <Itkovian> ouch, sorry mate
05:07:27 <shapr> s'okay, my choice :-)
05:07:42 <Itkovian> ic
05:07:52 <Itkovian> well, best of luck with the 2.0 version, eh
05:08:00 <shapr> heh, thanks :-)
05:08:37 <shapr> Speaking of relationships, how's your child process?
05:08:45 <Itkovian> sleeping :-)
05:08:59 <Oejet> That's the best moment.
05:09:18 <Itkovian> the I/O 's good, the O better than the I, he's not very hungry these days it seems
05:09:21 <Itkovian> a tad ill
05:09:35 <shapr> Got any new pix?
05:09:35 <Itkovian> Oejet: no, I like him better when he's playing with me
05:09:54 <musasabi> After benchmarking sequences it seems that a simple "data Seq a = Seq [a] [a]" will beat all other implementations most of the time (including both Data.Queue and Data.Sequence)
05:10:00 <Itkovian> shapr: erm, yes, but not uploaded to flickr I think
05:10:03 * Oejet kracks his fingers loudly.
05:10:26 * musasabi ponders posting to libraries@h.o
05:10:29 <shapr> musasabi: yes!
05:10:34 <roconnor> implementations of what?
05:10:35 <shapr> I was about to ask you to post that.
05:10:36 <Itkovian> http://www.flickr.com/photos/88172461@N00/sets/196348/
05:11:01 <musasabi> roconnor: FIFO queues.
05:11:53 <shapr> Itkovian: much cuteness :-)
05:11:57 <Itkovian> shapr: I'll upload a few more
05:12:46 <paolino_> did I you get my question on splitting ?
05:13:19 <Itkovian> I think the process is awakening
05:13:30 <shapr> ah, time for process maintenance.
05:13:40 <Itkovian> yeah, checking the O
05:14:21 * ProfTeggy awaits the second fork these days.
05:14:25 <Itkovian> shapr: u have a flickr account?
05:14:42 <paolino_> mmhh do I have to keep on splitting the list to build the search tree ? (soory if you already got it ,I have a bad connection )
05:14:53 <Itkovian> ProfTeggy: hasn't the fork occured yet? I mean, you await the allocation in the process table ...
05:15:58 <Oejet> x-)
05:16:06 <ProfTeggy> Itkovian, :-)  Let's put it that way: the fork is done, but the child has not called exec() yet.  It's still executing pretty much what the parent does.
05:17:39 <Itkovian> heh
05:17:42 <ProfTeggy> Official exec() date is Nov 5.
05:17:44 <Itkovian> dream on dude.
05:17:46 <Itkovian> :-)
05:17:53 <Itkovian> it's very much execing whatever it likes ;-)
05:17:57 <ProfTeggy> :-)
05:18:11 <ProfTeggy> Yeah, I noticed with the first girlie fork
05:18:12 <Itkovian> well, let us know when the delivery occured, eh.
05:18:24 <Itkovian> ah, girlie forks can be even worse :-)
05:18:37 <ProfTeggy> Will do.
05:18:55 <jlouis> Itkovian: And you linux guys have clone() too. My my...
05:19:20 <Itkovian> jlouis: but hey, would you want that?
05:19:24 <Itkovian> I wouldn;t
05:20:02 <jlouis> In OpenBSD land, we can clone people too. But it is a bit harder. We have to call rfork() (of plan9 fame) with special parameters
05:20:05 <Itkovian> shapr: a recent one: http://www.flickr.com/photos/88172461@N00/58951249/
05:20:19 <Itkovian> jlouis: ah, family planning. sweet.
05:44:45 <kombinator> musasabi: I'm reading about FunctionalForms right now. It seems that I can do eveything like that conviniently using arrow-based GUI.
05:45:28 <musasabi> kombinator: while maintaining the readablity?
05:46:24 <kombinator> musasabi: I think so, but I will have to try. I will show you the results.
05:49:16 <musasabi> sounds promising :-)
05:57:46 <shapr> Itkovian: No, I don't have a flickr account. I may get one though.
05:58:50 <kombinator> dcoutts: How do you want to implement layout combintators in gtk2hs? Are widgets going to be first-class values? ie. if I write let wdgt = someWidget in wdgt <+> wdgt , am I going to get 2 distinct widgets next to eachother?
06:00:02 <musasabi> kombinator: what do you envisage the type of wdgt to be?
06:00:23 <kombinator> musasabi: that's a good question;)
06:00:53 <kombinator> obviously not the native type of normal gtk2hs widgets
06:01:07 <kombinator> they are not first-class
06:01:53 <musasabi> Since you want to have: label "Name:" <+> textEntry <+> button "Ok", they need all to have the same input and output types.
06:02:32 <kombinator> or to be in the same class maybe?
06:02:43 <Philippa_> I'd rather layout-of-widget be first-class rather than widgets themselves
06:02:47 <Philippa_> it's... sane
06:02:51 <Philippa_> the alternative isn't, really
06:03:16 <musasabi> kombinator: no. <+> :: a b c -> a b c -> a b c
06:03:46 <kombinator> sorry, I meant 'any additive combinator' by <+>
06:04:01 <musasabi> A nifty thing is calculating a suitable heterogenous list (the union of them) and use that as the type.
06:04:43 <Philippa_> union types're both cool and potentially a read PITA for readability
06:05:04 <Philippa_> er, real
06:05:19 <Philippa_> "my type expression is *how* long?!" :-)
06:05:23 <Si\Uni> I'm having difficulty with GADTs, I've got a type data TMonad m s a where ... Get :: TMonad m s s, and I'm trying to write a run function for it, but the case for the Get constructor won't work. i.e. runTMonad :: MonadState s m => TMonad m s b -> m b, runTMonad Get = get, I get a unification error
06:06:05 <musasabi> Philippa_: isn't it normal to have larger types than code ;)
06:06:44 <lisppaste2> paolino pasted "binary search for least bigger" at http://paste.lisp.org/display/13141
06:06:45 <kombinator> musasabi: true for dependent types
06:06:53 <Philippa_> abstraction-by-naming matters, who'da thunk it?
06:07:05 * musasabi has that already in hswebforms
06:07:13 <paolino_> I have coded that, can I have enhancement from you ?
06:07:22 <Philippa_> (not the concatenative language folks, of course)
06:07:26 <musasabi> but that is more about Haskell making it hard to express types in a suitably short notation
06:08:05 * Philippa_ nods
06:08:08 <paolino_> looks like it's working also
06:08:20 <Philippa_> it'd be nice to be able to declare "what you get out of type inference at this point" as a type synonym
06:08:56 <kombinator> musasabi: what complex types do you need?
06:08:57 <Philippa_> type Foo; bar :: Foo -> Int; bar a = ...
06:09:05 <Philippa_> or type Foo = #INFER
06:09:24 <kosmikus> @pl \x y z -> x ++ [y] ++ z
06:09:24 <kombinator> musasabi: union using Either and ()?
06:09:24 <lambdabot> (. (:)) . (.) . (++)
06:09:43 <sieni> (.) (.) look like boobs
06:09:54 <basti_> oh the pain
06:10:20 * mi_chiel once contemplated making a Boobean logic parser in Haskell
06:10:37 <Philippa_> basti_: my b/f read out shapr's definition of swing on LtU as "swing = boobies"
06:10:44 <mi_chiel> which would use the (.)(.) operator, and would finally allow people to make sense of female logic
06:10:44 <musasabi> kombinator: combining HaskellDB typeclasses and automatic derivation of suitable presentation and serialization functions.
06:10:51 <basti_> swing as in java?
06:11:02 * mi_chiel tends to make too ambitious plans
06:11:09 <musasabi> kombinator: evil HList like union things.
06:11:34 <Philippa_> basti_: swing = (.).(.)
06:11:38 <musasabi> why take the easy and well understood path when one can fight agains GHC's typechecker.
06:11:41 <basti_> ohh
06:12:22 <shapr> Philippa_: haha
06:12:29 <Philippa_> mi_chiel: funnily enough I've never had a problem there
06:13:49 <shapr> I just read Held's claim that only 5% of programmers are able to use list comprehensions. Do you think that's true?
06:14:48 <astrolabe> I don't even know what it means.  Most programmer haven't heard of them, how do you count those?
06:14:55 <SamB> shapr: probably only 5% use a language which has them...
06:15:12 <shapr> What languages other than Haskell and Python?
06:15:31 <SamB> shapr: do you count collect:?
06:15:54 <shapr> Where's that from?
06:15:59 <SamB> Smalltalk
06:16:02 <integral> list comprehensions seem simpler than map/zip
06:16:10 <mi_chiel> Philippa_: ah, but for those of us that do, it would be an invaluable tool :)
06:16:19 <astrolabe> I would guess most programmers could use them.
06:16:36 <SamB> well, okay, so that isn't quite a whole list comprehension...
06:16:52 <musasabi> List comprehensions usually just need 30mins woth of explaining.
06:16:58 <musasabi> After that they are trivial.
06:17:04 <Philippa_> mi_chiel: don't assume you're working from the same axioms regarding wants and needs. It's a good start
06:17:35 <tuomov> list comprehensions are trivial if you know any math set comprehension notation
06:17:43 <SamB> shapr: anyway, its obviously not because there is anything hard about them
06:17:44 <Philippa_> Most coders who attended a decent compsci course should be able to do list comprehensions with a short while to re-learn
06:18:24 <mi_chiel> Philippa_: that actually makes sense
06:18:37 <liyang> tuomov: mildly different though. There's no ordering on sets.
06:18:47 <mi_chiel> (not implying that women can't make sense, or anything... just that I sometimes don't understand them)
06:18:54 <lomeX> what's so hard-to-understand in list comprehension?
06:18:59 <SamB> mi_chiel: actually, that works for understanding alien male logics also
06:19:10 <musasabi> it is much harder to make sense of men.
06:19:31 <Philippa_> lomeX: depends on your background. If you're bad at maths generally they can be a bit awkward
06:19:43 <Philippa_> myself, I have to think atm because I've not really been reading comprehensions for a couple of years
06:19:45 <tuomov> musasabi: are you sure you're one?-)
06:19:54 <Philippa_> (a shame, last time I did a Z course I was scaring the lecturer)
06:20:47 <lomeX> Philippa_: are you talking about incorrect usage? could you provide an example?
06:20:54 <SamB> probably about 5% of Haskell programmers remember about the existence of list comprehensions more than 5% of the time...
06:21:12 <paolino_> last is O(n) ?
06:21:37 <SamB> lomeX: incorrect usage isn't scary!
06:21:47 <SamB> its correct but incomprehensible that is scary
06:22:16 <lomeX> oh! i see
06:22:33 <SamB> correct but incomprehensible comprehensions are especially so ;-)
06:22:40 <Philippa_> SamB: that's because it tends to be the TCS types who use them mostly
06:22:41 <lomeX> but this sentence concerns everything
06:23:14 <Philippa_> I possibly should try converting some of my more complex list ops into comprehensions sometime and comparing readability, I don't feel list comprehensions are as composable though
06:23:29 <astrolabe> paolino_: yes, I think so
06:23:30 <SamB> Philippa_: and here I thought it was because it was the people who hadn't settled into using map, filter, folds, and .!
06:24:00 <lomeX> paolino_: yes. may be compilers make some optimizations.
06:24:29 <paolino_> k
06:24:44 <Philippa_> SamB: arguably
06:25:02 <Philippa_> OTOH, Graham Hutton uses them and he's written articles on how useful fold is - 'nuff said?
06:25:14 <astrolabe> SamB: And the other 95% remember them all the time?
06:25:57 <astrolabe> Philippa_:You don't think fold is useful?
06:26:18 <SamB> astrolabe: no, the other 95% remember them 5% of the time or less. or something like that. I might be a bit off in my figures...
06:26:48 <astrolabe> SamB: You suprise me.  I would have guessed most haskellers use them alot.
06:27:21 <Philippa_> astrolabe: nonono, I use fold a lot (and foldM, and...)
06:27:39 <Philippa_> just gmh wrote some stuff on just how widely applicable it is and still advocates list comprehensions to students
06:27:51 <SamB> well, students sure.
06:28:02 <astrolabe> Phillipa: Ah. Thanks
06:28:03 <Philippa_> amongst other things, as being better style
06:28:15 <SamB> okay, so maybe I don't want to count students...
06:28:27 <Philippa_> (I was one of those students, btw - I first learnt haskell four and a half years back in his lectures)
06:28:34 <SamB> better style than what?
06:29:20 <jlouis> fold here, filter there. Wrap it inside a monad, add an M; map the list, zipWith two. Have fun. It is seldom I use list comprehensions, though they can be very very nice for solving exhaustive problems where you would need a lot of filters and a lot of cartesian products
06:29:26 <astrolabe> What are most haskellers anyway?  Students, academics, hobbyests?
06:29:40 <Philippa_> depends which students you want to count as haskellers - a lot hate it
06:29:42 <jlouis> astrolabe: hackers having fun!
06:30:30 <astrolabe> To me list comprehensions seem very intuitive and expressive
06:31:40 <SamB> academics, hobbyists, and those have managed to get paid doing it in a non-academic setting, I think...
06:31:45 <Philippa_> I've just not used them for long enough I'm not used to the structure. I used to be good with set comprehensions
06:32:13 <Philippa_> I'm a hobbyist who'd also count as an academic given better circumstances, I guess
06:32:25 <lomeX> what is set comprehensions?
06:32:33 <SamB> s/have/who have/
06:32:56 <Philippa_> lomeX: same idea as list comprehensions, but for sets. Set comprehensions came first
06:33:10 <astrolabe> lomeX: from maths I think, not programming
06:33:22 <SamB> I wouldn't count students who don't like it, because they stop as soon as they don't have to study it anymore
06:33:26 <lomeX> Philippa_: nub [|]? :-)
06:34:15 <lomeX> astrolabe: ok
06:36:41 <musasabi> folds tend to be hard to read.
06:36:50 <lomeX> how to define what i have to use - list comprehension or map/filter?
06:37:20 <musasabi> if the same thing can be expressed as a list comprehension, then folding is usually evil.
06:38:55 <Philippa> re, what'd I miss?
06:38:58 <Philippa> (my ISP stinks...)
06:39:27 <lomeX> Philippa: nothing
06:41:46 <lomeX> really, i'm a newbie in haskell and list comprehensions is one of the things I found fun and mighty in haskell.
06:42:15 <Philippa> I suspect part of the reason I don't use them is that there's no monadic version
06:42:37 <Philippa> so every time I want to build a list via IO or something, I have to do it another way
06:42:41 <musasabi> just sequence them.
06:42:45 <lomeX> oh...
06:42:51 * mi_chiel reminds himself to once again attempt to grok Monads
06:43:11 * musasabi frequently uses sequence [ someIOAction foobar | and the rest of the comprehension ]
06:43:17 <musasabi> or sequence_
06:43:23 * Philippa nods
06:43:41 <Philippa> may as well mapM someIOAction [comprehension] though, no?
06:43:45 <astrolabe> I do think its a shame they dropped monad comprehensions from haskell
06:43:54 <astrolabe> *it's
06:44:40 <musasabi> Philippa: if the args don't go nicely then the comprehension can be more readable - depends on the situation of course.
06:45:00 <musasabi> flipping mapM makes it nicer.
06:45:05 <Philippa> yeah, I've sorta got used to turning big list stuff into a paragraph rather than a line
06:45:09 <Philippa> I'd have this:
06:45:14 <Philippa> mapM someIOAction
06:45:19 <Philippa>      [comprehension]
06:45:42 <Philippa> (beware monospace/proportional issues, as ever)
06:46:00 <Philippa> (I'm using a proportional font for IRC, I should have a quickie way to switch in my own client methinks)
06:47:35 <Philippa> doing something similar is about the only reason I'll even attempt to read the page template code in Flippi at the moment...
06:50:23 <musasabi> What kind of lexer/parser thing does Flippi use?
06:50:58 <musasabi> I was thingking that using the dynamic lexer combinators from Yi with each plugin defining bits of syntax would be very nice for a wikilike thing.
07:07:49 <shapr> cool! Satnam Singh on LtU talking about Lava :-)
07:08:54 <Philippa> musasabi: the parser's Parsec-based with some dodgy stuff going on with the state to make it extensible
07:09:27 <Philippa> (the state is currently an Id -> Parser map, you can add and remove parsers from the state and run a "sum-of-parsers-in-state" parser)
07:09:44 <Philippa> parsing plugins add new things to that map
07:10:04 <Philippa> the root parser is, surprise surprise, pretty much the "sum-of-parsers-in-state" one
07:10:43 <shapr> Silly question, aren't C header files about declaring a signature way far away from the actual function definition?
07:10:55 <Philippa> pretty much
07:11:08 <Philippa> you can think of that as making interface available without implementation
07:11:19 <integral> two fold: 1) to allow you to link to code without needing it's object 2) to do with haskell's .hi files do but without automation
07:11:46 <Philippa> um, header files don't really do half of what .hi files do
07:12:04 <Philippa> .hi files contain a lot of compiler-specific info and non-language-level interface info
07:12:20 <integral> .h files can too, it just has to be manually written...
07:13:20 <SamB> integral: not really
07:13:36 <Philippa> you can pull pragma tricks, but they're not portable
07:13:45 <Philippa> so anything where that's *required* as part of the interface isn't viable
07:13:47 <Philippa> it's not C any more
07:14:00 <Philippa> .hi files contain a lot of stuff where if you don't know it, you can't possibly call the code
07:14:08 <Philippa> (eg "we unboxed all this stuff")
07:14:10 <integral> .hi files aren't portable either, so I was ignoring that :)
07:14:15 <SamB> anyway, a lot of the stuff in .hi files *can't* be done manually...
07:14:26 <Philippa> the non-portability is an important aspect of what .hi files are, though
07:14:33 <integral> Philippa: same with a gcc attribute saying that some functions are stdcall rather than cdecl, you have to know that to call the file
07:15:08 <integral> .h files can also separate out data types and function signatures/interface from implementation so that circular dependency things happen less...
07:15:29 <MarcWeber> What does put :: s -> m ()
07:15:41 <MarcWeber> mean? I don't understand () Does this mean tuple without any elements?
07:15:52 <Philippa> true, C really doesn't like circularity
07:15:56 <Philippa> yep
07:16:02 <jlouis> MarcWeber: it saves the state s into the State monad m and doesn't return a value ?
07:16:02 <SamB> integral: well, thats MS's fault... generally those are actually in VC's syntax...
07:16:03 <Philippa> you can think of it as the unit type if you prefer
07:16:20 <integral> SamB: hmm?  I don't know what you're referring to
07:16:36 <integral> Philippa: erm, neither does haskell between modules.   See some of the really giant files in Pugs
07:16:41 <MarcWeber> jlouis: Thanks. I didn't remember the "void" declaration ;)
07:17:23 <jlouis> MarcWeber: read what Philippa writes. void is so C/Java/C++ like. unit is type of () in the ML family of languages
07:17:40 <jlouis> (Which Haskell is not part of. There () is the type of ())
07:17:46 <SamB> MarcWeber: it would probably be called a 0-tuple if there was a 1-tuple
07:18:29 <SamB> integral: I was referring to the stuff about stdcall and cdecl
07:19:27 <integral> I still don't get the comment about VC...
07:20:35 <SamB> integral: microsoft is responsible for the stdcall convention, and functions tagged for that are usually tagged using Visual C's syntax, not GCC's syntax...
07:21:20 <integral> hmm, I thought stdcall had better semantics for tailcalls though?  (being callee-pops)
07:21:40 <integral> I have no idea though who actually uses stdcall
07:22:46 <SamB> integral: I don't see how that makes for better tailcalls
07:24:04 <integral> SamB: if the caller has to still clean up the stack, the "tailcall" isn't really at the end of the subroutine...
07:24:48 <SamB> integral: but the original caller does that...
07:24:48 <Philippa> MarcWeber: the only terminating value of type () is ()
07:25:14 <Philippa> () is thus often pronounced "unit" because it is the unit type
07:25:32 <Philippa> (more accurately, "a" unit type - but it's the canonical one)
07:25:45 <integral> SamB: except it doesn't know about the arguments pushed for the tailcall at the end of the routine it called
07:25:53 <MarcWeber> When reading unit I do remember pascal files which are called units. ;(
07:25:57 <Philippa> heh
07:26:03 <Philippa> TP5.5 was my first language...
07:26:19 <SamB> integral: hmm, you may have a point.
07:27:41 <integral> iirc, the trick that gcc uses is that hopefully the args you pass to the tailcall are shorter in stack size than the ones that you got called with, so you move the stack pointer back the same amount, and then push
07:32:53 <roconnor> $ quickcheck Dyadic.hs
07:33:04 <roconnor> sh: ./ghci: No such file or directory
07:33:08 <roconnor> :(
07:34:58 <shapr> oops
07:35:08 <shapr> Are you using the quickCheck script I got from tmoertel?
07:35:34 <shapr> try "grep -i shae `which quickcheck`"
07:35:49 <shapr> If so, try switching to runghc or getting rid of the "./" part.
07:36:16 <roconnor> okay, getting rid of ./ helps
07:36:25 <roconnor> Failed to load interface for `QuickCheck':
07:36:37 <shapr> Change it to Test.QuickCheck
07:36:41 <roconnor> On the plus side I can quickcheck by hand.
07:37:06 <shapr> Yeah, but the quickcheck script has extra goodies, and I want to encourage use of the script so people will be prepared for my TDD extension :-)
07:39:24 * shapr jousts again at David B. Held
07:39:51 <roconnor> yay
07:39:51 <roconnor> I need to write a wiki page
07:39:51 <roconnor> Falsifiable, after 0 tests:
07:39:51 <roconnor> 0 tests!  That's pretty fast
07:39:57 <roconnor> It doesn't say which test.
07:40:01 <roconnor> I only have one test so I know.
07:40:03 <roconnor> but still
07:40:09 <roconnor> TDD
07:40:13 <roconnor> TDD?
07:40:46 <shapr> test-driven-development
07:41:02 <shapr> roconnor: Wow, falsifiable after zero tests??
07:42:05 <roconnor> I found my broken code and was about to fix it.
07:42:18 <roconnor> then I thought this is perfect to try out quickCheck.
07:42:23 <jlouis> shapr: that quickcheck script would be quite good to have for conjure. Could you hand it over please?
07:42:30 <jlouis> an URL would be quite enough
07:42:30 <roconnor> so I wrote the property that was being violated.
07:42:43 <roconnor> http://www.cs.chalmers.se/~rjmh/QuickCheck/quickcheck
07:42:48 <shapr> jlouis: It's on John Hughes' page, but you can use the one out of qc-tdd if you want extra fun.
07:42:50 <roconnor> this is what I got.
07:43:08 <jlouis> I *definitely* want extra fun
07:43:08 <shapr> roconnor: see the "shae" on the first line?
07:43:15 <jlouis> where is qc-tdd located?
07:43:24 <roconnor> I see runhuggs
07:43:26 <roconnor> ;)
07:43:35 <shapr> jlouis: http://www.scannedinavian.org/~shae/qc-tdd.tgz
07:43:39 <jlouis> bingo, thanks
07:43:41 <roconnor> oh I want +name
07:43:49 <shapr> jlouis: Read the README, and tell me if you come up with a better way to do it!
07:43:58 <jlouis> shapr: will do!
07:44:14 <shapr> I have a darcs repo for qc-tdd, and I think that tgz is a darcs repo, so you could just send patches.
07:44:19 <roconnor> er +names
07:44:28 <roconnor> @karma+ shapr
07:44:29 <lambdabot> shapr's karma raised to 12.
07:44:39 <jlouis> shapr: are you trying to lure the sole developer of conjure to qc-tdd, eh shapr  ;P
07:45:02 <jlouis> I will definitely provide patches
07:45:13 <shapr> w00
07:45:20 <roconnor> ah, this time my test is wrong
07:45:24 <shapr> I have 12!
07:45:29 <roconnor> aka my specification is wrong
07:45:38 <shapr> jlouis: Nah, just trying to get more feedback on the qc-tdd idea.
07:45:52 <jlouis> or your specification is right, but your program wrong, depending on what way you look at it ;)
07:46:06 <roconnor> maybe both are wrong
07:46:08 <jlouis> shapr: I'll take a look later this evening
07:46:18 <roconnor> prop_ExpBound1: OK, passed 100 tests.
07:46:22 <ptolomy2> What percent of people do you think code Haskell because they have to?
07:46:54 <shapr> ptolomy2: 70% of the students who show up here :-)
07:46:56 <jlouis> ptolomy2: quite a number of first year students who are 1337 C-coderz-mad-skillz and now have to code functionally to pass this course
07:47:13 * ptolomy2 wishes he had to learn Haskell in college...
07:48:17 <jlouis> At DIKU everybody does SML. But SML is borng
07:48:18 <jlouis> boring
07:48:59 * ptolomy2 had one class that required Ocaml, and it was one of the best ones I took.
07:49:05 <Itkovian> ptolomy2: some of them stick around afterward
07:50:04 <shapr> I wish I had CS in college.
07:50:23 <shapr> On the other hand, it's more fun when I get to pursue whichever parts of CS look the most interesting at the moment.
07:50:32 <SamB> jlouis: probably not as boring as Java...
07:50:41 <ValarQ> is there a simple way to alter a value in a tuple?
07:51:24 * ptolomy2 had to learn C++ last night, and kept trying to make tuples for some reason..
07:51:29 <shapr> ValarQ: fst or pattern matching?
07:52:02 <ValarQ> shapr: ok, i might go for the pattern matching
07:52:09 <shapr> ValarQ: \(x,y) -> (1,y)
07:53:07 <shapr> or maybe \x -> (fst x,1) ?
07:53:36 <shapr> Speaking of which, Hughes has some crazy bit of code in QuickCheck that does something that took me half an hour to figure out.
07:56:07 <shapr> Philippa: What is Held talking about with VMs?
07:56:19 <jlouis> ptolomy2: oh, that is easy, there is a pair<foo,bar> template in STL ;)
07:56:23 <Philippa> he thinks eval requires one
07:56:37 <Philippa> which is true, in the sense that a C runtime also forms a virtual machine
07:57:20 <mi_chiel> wat een muziek zeg, op die begrafenis
07:57:27 <mi_chiel> uh, mischat
07:58:41 <shapr> mi_chiel: ik begrijp het niet!
07:59:10 <neologism> this si sweden?
07:59:24 * earthy ponders
07:59:29 <Philippa> anyway, gotta go
07:59:40 <shapr> Philippa: thanks, cya
07:59:56 <shapr> neologism: Nah, that was Dutch.
08:00:54 <shapr> neologism: Swedish is "Jag fÃ¶rstÃ¥r inte!"
08:00:54 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/sequence-performance/
08:00:54 <shapr> neologism: What do they say in .sk ?
08:01:30 <shapr> musasabi: nice pix
08:02:12 <ValarQ> shapr: that lambda pattern thingie work pretty good, thanks
08:03:29 <shapr> :-)
08:03:50 <neologism> shapr: what do you want to traslante? and I am not slovak btw ;)
08:05:40 <sylvan> Where can I find the "latest" library docs (haddock).. That is the GHC 6.5 docs?
08:06:05 <shapr> neologism: "I don't understand"
08:06:19 <neologism> [17:00] < shapr> neologism: What do they say in .sk ?
08:06:30 <neologism> what did you want to hear? :)
08:07:00 <roconnor> Does template haskell let me refer to my function name as a string for error messages?
08:08:10 <psi> shapr: you can also say "begriper" in swedish (similar to the dutch version)
08:14:09 <shapr> psi: Oh, I didn't know that. Thanks.
08:14:29 <shapr> neologism: I wanted to hear how they say "I don't understand"
08:15:30 <neologism> "nerozumiem" in slovak and "nerozumim" in czech (I am czech)
08:15:41 <kowey> hi room... does anybody have a handy script around for making .lhs files a little haddock friendlier?
08:15:55 <kowey> i realise i could just do unlit, but it'd be nice to preserve some comments
08:16:21 <shapr> neologism: Cool, looks like an agglutinative language.
08:17:08 <neologism> its not
08:17:17 <neologism> czech/slovak are flexive languages
08:17:23 <sylvan> @libsrc Data.Sequence
08:17:23 <lambdabot> Data.Sequence not available
08:17:29 <sylvan> crap
08:17:38 <neologism> not many indo-european languages are agglutinative
08:17:47 <neologism> in fact none that I am aware of
08:19:25 <shapr> Finno-Ugric languages are agglutinative, like Finnish and Estonian. I don't know if they count as indo-european though.
08:19:31 <neologism> they are not
08:19:38 <shapr> They aren't?
08:19:39 <neologism> this is finno-ugric language family
08:19:42 <neologism> not indo-european
08:19:47 <shapr> Oh, ok.
08:20:09 <MarcWeber> class Functor f where
08:20:12 <shapr> It's a lot more fun to read about flexive languages on wikipedia than it is to do paying work.
08:20:13 <MarcWeber> map :: (a->b) -> f a -> f b
08:20:28 <neologism> well, flexive language are pita to analyze
08:20:41 <neologism> its morfological variety is hufe
08:20:43 <neologism> huge
08:20:54 <neologism> for example english has 11 cases which coverst 99% of morfological forms
08:21:02 <neologism> while turkish has 600 bilions of morfological forms
08:21:18 <sylvan> @libsrcs Data.Queue
08:21:19 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Queue.hs
08:21:24 <Yubanalesco> morfological sounds like a dental paste...
08:22:16 <shapr> neologism: scary, and even more distracting...
08:22:30 <neologism> ;)
08:23:45 <neologism> it was very hard for me (as a native czech speaker) to learn english
08:24:44 <ProfTeggy> neologism, you must feel that the reward is even higher then.
08:24:49 <ProfTeggy> Lucky you.
08:24:56 <neologism> uhm?
08:25:00 <neologism> what reward?
08:25:17 <ProfTeggy> The reward of being able to communicate globally.
08:25:38 <ProfTeggy> Imagine how knowledge of English has expanded your world.
08:25:53 <neologism> yes.. no doubt there
08:26:01 <neologism> but the language type is entirely different to minbe
08:26:02 <neologism> mine
08:26:09 <neologism> its like coming from imperative world to functional one ;0
08:26:10 <ProfTeggy> From Czech-speaking countries (which are they?) to  thw whole fine planet.
08:26:17 <ProfTeggy> s/thw/the/
08:26:21 <ProfTeggy> nelogism, hehe
08:27:37 <neologism> of course but.. you know.. the more languages you speak the more literate you are :)
08:27:50 <neologism> its like being able to code functionaly/logically/imperatively
08:27:50 <Yubanalesco> Or more confused you are.
08:27:54 <MarcWeber> Does here f a and f b mean that a,b should be instances of class Functi
08:28:30 <Yubanalesco> But at the same time it seems that you can impress others by speaking in many different languages.
08:28:39 <MarcWeber> typo. I Hit return instead of backspace.. What does f a, f b mean in the lines pasted above?
08:29:05 <neologism> Yubanalesco: the bad thing is that in czech republic everyone speaks czech so it doesnt impress anyone :)
08:29:21 <ProfTeggy> MarcWeber, functor f applied to argument (type) a
08:29:38 <kala> neologism: but you can speak correct czech. I suppose that would impress some :)
08:29:46 <neologism> not here ;)
08:29:49 <Yubanalesco> (neologism): Well, but then if you are in like UK, that will impress people!
08:29:52 <musasabi> sylvan: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Data/Sequence.hs?rev=1.14 for Data.Sequence
08:30:01 <neologism> sure, but I am not in the UK
08:30:52 <Yubanalesco> Humm, is the until function limited totally by its output ?
08:31:13 <Yubanalesco> I assume I can't do something like until (abs(y^2-x)<0.001) ((y+x/y)/2) y
08:31:49 <MarcWeber> ProfTeggy: So when calling map A::a B::b the Functor is applied automatically? Which documentation would you recommend to learn this stuff?
08:33:11 <ProfTeggy> MarcWeber, I cannot parse map A::a B::b, sorry
08:34:08 <MarcWeber> ProfTeggy: That should have meant A of type a and B of type b
08:34:19 <ProfTeggy> What is says is that if (map g a) typechecks, then a is of type f t (for some t), and if g :: t -> t', then the result will be of type f t'
08:35:20 <ProfTeggy> The class decl above says that every f that is an instance of Functor will come with such a 'map'
08:36:48 <shapr> dons: I think a QuickCheck 'best practices' document would be nice. I've found a few useful ways to approach QuickCheck properties, generators, and QC testing in general, and I'm sure other people have found approaches I don't know yet.
08:38:57 <MarcWeber> ProfTeggy: The first argument is a function (a->b) the snd is of type f a which means it should be of type a? and I get back b.. So why not write map :: (a->b) -> a -> b ?
08:38:58 <SamB> MarcWeber: I think you need to parenthesise expressions to attach type signatures to them...
08:39:50 <ProfTeggy> MarcWeber, but this is not what 'map' does.
08:40:03 <ProfTeggy> f a != a
08:40:34 <MarcWeber> ProfTeggy: That's my problem I don't understand f a
08:40:45 <ProfTeggy> For example, [a] is an instance of class Functor.
08:40:49 <ProfTeggy> Thus, f a = [a]
08:41:36 <ProfTeggy> And the [.]-instance of map has type (a -> b) -> [a] -> [b]
08:42:44 <MarcWeber> ProfTeggy: What do you mean by [.]-instance?
08:43:21 <SamB> MarcWeber: I think that dot is what you call a "point"
08:43:38 <ProfTeggy> Classes are instantiated by concrete types
08:43:56 <SamB> in Haskell you would say [] instead
08:44:08 <araujo> Hello Haskell'ers!
08:44:42 <MarcWeber> ProfTeggy, SamB, Thanks. Will go for dinner now and think about it.. Will be back later.
08:45:08 <ProfTeggy> instance Functor [] where fmap = map  (here, 'map' is the regular list map)
08:55:16 <basti_> wanna see something?
08:55:18 <basti_> @pl \(ha:ta) (hb:tb) -> if (ha<hb) then ha:merge ta (hb:tb) else hb:merge (ha:ta) tb
08:55:22 <lambdabot> ap (flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (liftM2
08:55:22 <lambdabot> ap .) . ap ((.) . ap . (((.) . if') .) . (<)) ((. ((. (:)) . (.) . merge))
08:55:22 <lambdabot> . (.) . (.) . (:))) (((flip ((.) . (:)) . merge) .) . (:)) . head)
08:55:22 <lambdabot> tail
08:56:22 <wilx`> Heh.
08:56:31 <shapr> I wish apt would let me preserve new custom additions to a config file while putting in the package maintainer's additions too.
08:59:29 <basti_> shapr look at that @pl ^^
09:00:21 <psi> "flip flip"?
09:00:23 <astrolabe> basti: that's cool.
09:00:28 <basti_> its just mergesort
09:00:48 <basti_> oh it still calls itself with its name!
09:01:02 <neologism> looks scary
09:01:06 <basti_> its not even completely pointless yet!
09:01:35 <basti_> psi: flip (flip tail)
09:02:20 <shapr> scary
09:04:40 <astrolabe> @pl \a@(ha:ta) b@(hb:tb) -> if ha<hb then ha:merge ta b else hb:merge a tb
09:04:41 <lambdabot> (line 1, column 3):
09:04:41 <lambdabot> unexpected "@"
09:04:41 <lambdabot> expecting letter or digit, operator, pattern or "->"
09:06:28 <astrolabe> lambdabot doesn't know about labels?
09:15:44 <shapr> point-less uses a term rewriting implementation.
09:16:12 <xerox> astrolabe: I think so.
09:18:21 <ProfTeggy> Bye all
09:19:35 <astrolabe> Servus = slave?
09:20:09 <dcoutts> kombinator, gtk2hs doesn't have layout combinators yet. Patches welcome.
09:20:57 <dcoutts> kombinator, so far there has been less demand for them since yo don't have to do all the layout in code. You can use the glade gui builder.
09:21:10 <dcoutts> But yes, layout combinators would be nice.
09:21:59 <dcoutts> I imagine a straightforward implementation would be to have a layout property on container classes, eg windows etc.
09:22:21 <dcoutts> then there would be layout constructor functions that take lists of existing widgets
09:22:30 <dcoutts> so there are no naming problems.
09:22:49 <dcoutts> It doesn't help your higher level api however.
09:23:12 <dcoutts> because of the way we can side-step the widget identity issue at the medium layer.
09:26:17 * musasabi feels dirty after touching dynamics - coding things like "(unsafeCoerce# e) $(evilAccessor ''Dynamic 1)" does not feel sane.
09:27:24 <vegai> why did ya then? :)
09:27:57 <musasabi> vegai: because I want to serialize them.
09:42:04 <roconnor> I hate wiki markup
09:42:18 <shapr> why?
09:42:26 <roconnor> 2^''e''^ doesn't work.
09:42:37 <shapr> oh, you want a super markup?
09:42:54 <roconnor> it does the super, but it doesn't italicize the e
09:43:06 <shapr> If you're on HaWiki you can use LaTeX.
09:43:16 <roconnor> there's an idea
09:43:27 <roconnor> bah, I'll let someone else do it.
09:48:18 <MarcWeber> SamB: Do you know what ProfTeggy meant by [.]-instance?
09:50:46 <roconnor> @info liftM2
09:50:51 <lambdabot> Unknown command, try @listcommands.
09:54:55 <astrolabe> MarcWeber: I think he meant the value of fmap when the instance of Functor is [] (ie lists)
10:06:59 <ValarQ> shapr: still awake?
10:07:50 <SyntaxNinja> 'morning
10:08:13 <shapr> ValarQ: y0
10:08:19 <shapr> hiya SyntaxNinja
10:08:25 <Nico-> 'evening...
10:08:32 <ValarQ> shapr: i have another dumb question involving tuples :)
10:08:39 <shapr> ValarQ: I'm working and have erc-track turned off, but, how may I assist you?
10:09:22 <ValarQ> this time i wonder if i can create a (+) instance for (x,y) tuples
10:11:10 <ValarQ> i seem to be able to create a Point type, but then i can't do an instance and if i use data for creating the datastructure it isn't a simple tuple anymore...
10:12:28 <shapr> What about "instance (Num a, Num b) => Num (a , b) where ..." ?
10:12:45 <shapr> Is there already a Num instance for tuples?
10:12:51 <SyntaxNinja> y0 shapr
10:15:19 <araujo> Anyone knows a good site to host haskell projects with a darc repo?
10:15:39 <SyntaxNinja> araujo: possibly
10:15:58 <ValarQ> shapr: that actually works, i get a lot of warnings thought
10:16:01 <SyntaxNinja> araujo: I'm sorta hoping to use hackage.haskell.org for this some time.
10:16:08 <shapr> ValarQ: What sort of warnings?
10:16:21 <shapr> SyntaxNinja: Using the "suck 'em down" approach I suggested?
10:16:31 <ValarQ> shapr: Warning: No explicit method nor default method for `*' In the instance declaration for `Num (a, b)'
10:16:35 <araujo> SyntaxNinja, Good
10:17:13 <araujo> SyntaxNinja, i didn't know that existed
10:17:14 <SyntaxNinja> araujo: you can actually use cvs.haskell.org (same server, actually) if you have access to that machine
10:17:34 <SyntaxNinja> see http://cvs.haskell.org/darcs
10:17:38 <araujo> No, i don't have access
10:17:42 <shapr> ValarQ: http://www.scannedinavian.org/~shae/ProtoNumTuple.hs
10:18:04 <shapr> ValarQ: I think the reason there's no standard instance is that a tuple can signify a bunch of different things.
10:18:07 <SyntaxNinja> araujo: what project?
10:19:17 <araujo> SyntaxNinja, I mean, i still don't release any source ode, it is a haskell shell, please take  alook at some examples: http://paste.lisp.org/display/13028
10:19:20 <MarcWeber> astrolabe: Thanks. I've found an example where fmap is used as generalization of map and I think I got the point now what Functors are for.
10:19:32 <ValarQ> shapr: yeah, i understand that
10:19:33 <araujo> I am just loking for something like, sourceforge but for haskell stuff with darcs :-]
10:19:56 <ValarQ> shapr: but i want to try to simplify some code
10:20:09 <shapr> Simplicity is always a worth goal.
10:20:16 <kowey> araujo: http://www.darcs.net/DarcsWiki/TracOnDarcs ?
10:20:25 <MarcWeber> But as you can use fmap everytime is map obsolete then? Because you can use fmap for lists, too?
10:20:41 <kowey> nothing publically accesible up yet, but hoping someone puts something up
10:20:44 <SyntaxNinja> kowey: cabal is going to start using that: http://hackage.haskell.org/cgi-bin/trac/trac.cgi
10:21:08 <kowey> yay!
10:21:20 <SyntaxNinja> I'd sorta like to make hackage.haskell.org into a trac / darcs / cabal-get resource for the haskell community.
10:22:02 <araujo> kowey, But.. that's for me to mount it?
10:22:13 <ValarQ> shapr: can i create another class that uses (+) ?
10:22:14 * araujo is in lack of resources atm
10:22:24 <kowey> (sheepishly) well... it was written so that someone out there
10:22:25 <Igloo> Is hackage itself done yet?
10:22:30 <kowey> with a server to spare would put something up
10:22:59 <SyntaxNinja> Igloo: it's still sitting in beta. haven't gotten to work on it lately, and havign troulb getting people to beta test it.
10:23:17 <Igloo> Are cabal-get/put in Debian?
10:23:20 <araujo> kowey, i would do it if i could for sure :-(
10:23:24 <SyntaxNinja> Igloo: no
10:25:10 <ValarQ> apparently not...
10:28:47 <ValarQ> a special class with a +++ operation seems to be a pretty nice solution
11:00:24 <shapr> ValarQ: I think +++ is a standard conventional operator in Parser monads.
11:01:38 <ValarQ> shapr: is there a list of operators from the standard libraries?
11:02:00 <ValarQ> shapr: ( i switched to |+ because --- didn't work out ;)
11:02:44 <astrolabe> Is there a shortage of short operator symbols?
11:03:34 <ValarQ> astrolabe: i don't know yet, i don't know all of them
11:03:41 <mi_chiel> does Haskell allow for utf-8 symbols?
11:04:34 <ValarQ> mi_chiel: i believe haskell does, but it's really depends on the implementation to handle it
11:04:38 <shapr> ValarQ: haha
11:04:47 <int-e> The Haskell 98 report says: 'Haskell uses the Unicode [11] character set. However, source programs are currently biased toward the ASCII character set used in earlier versions of Haskell.' ... I don't know about implementation's support for that.
11:05:11 <kowey> my understanding is that the insides are Unicode
11:05:16 <kowey> but that it doesn't do IO in Unicode
11:05:49 <kowey> however, it does seem to read latin-1 or something similar
11:06:05 <ValarQ> is there a list of all operators?
11:07:44 <shapr> You can define new ones, so not really.
11:08:36 <int-e> (infix) operators are sequences of !#$%&*+./<=>?@\^|-~ and : after the first place, minus a few exceptions.
11:09:35 <nasha> StableName seems quite evil - that is given a and b of different types their stableNames can be equal :-(
11:09:46 <astrolabe> So about 20 characters.  I suppose that isn't too bad
11:10:03 <musasabi> (grah @ settings)
11:13:29 <mega> çäðàâñòâóéòå
11:13:30 <mega> Âû ÷òî íèáóäü ñëûøàëè î çàðàáîòêå â ñåòè
11:13:30 <mega> åñëè íåò ìîãó ðàññêàçàòü î èíòåðåñíîì ñïîñîáå
11:13:32 <mega> çà 20 äíåé 44 % ïðîöåíòà íà âëîæåííóþ ñóììó
11:13:34 <mega> îòâå÷ó íà âàøè âîïðîñû.
11:13:36 <mega> www.serf2007.narod.ru
11:13:55 <ibid> kÃ¤Ã¤k
11:14:02 <ValarQ> Â¿
11:14:08 --- mode: ChanServ set +o SyntaxNinja
11:14:27 <SyntaxNinja> is that just a character set that's not displaying on my machine?
11:14:36 <SyntaxNinja> or is that a spammer?
11:14:41 <jyp> both
11:14:48 --- kick: mega was kicked by SyntaxNinja (SyntaxNinja)
11:16:22 <shapr> looks like a spammer to me
11:16:40 <integral> it was
11:17:55 <adept> both
11:18:21 <astrolabe> That can't be cost effective.
11:18:21 <SyntaxNinja> anyone else?!?!
11:18:22 <adept> (charset is cyrillic/win-1251 is someone cares)
11:18:46 <Akshaal> he told: you can invest some money and get +44% after 20 days
11:19:04 <Akshaal> :)
11:19:14 <SyntaxNinja> for all the sucker russian speakers here, don't believe him!
11:19:25 <astrolabe> Wow, just let me remortgage my house.
11:19:38 <Akshaal> SyntaxNinja: are you kidding?
11:20:00 <SyntaxNinja> ?
11:20:27 <SyntaxNinja> I was being sarcastic.
11:20:33 <SyntaxNinja> sorta;
11:20:37 <Akshaal> SyntaxNinja: I am in half way to give all my money to this spammer...
11:20:59 <SyntaxNinja> Akshaal: give it to me instead. we'll buy a server for araujo.
11:21:35 <Akshaal> SyntaxNinja: how about 44% after 20 days?
11:22:21 <SyntaxNinja> how many cyrillic encodings are there? I think i can ususally read it.
11:22:44 <Akshaal> cp1251, koi8-r, koi8-u, cp866...
11:22:46 <Akshaal> at least
11:22:53 <SyntaxNinja> what a mess
11:23:58 <Akshaal> koi8-r was a first one, bill gates's company introduced cp1251, cp866
11:24:19 <kowey> apparantly, one of them overlaps with latin-1
11:24:33 <kowey> so if you're a russian speaker living in France, you're screwed
11:25:01 <Akshaal> they all are
11:25:11 <SyntaxNinja> CosmicRay: !
11:25:13 <ValarQ> yeah
11:25:30 <ValarQ> unicode is the solution
11:25:52 <Akshaal> wow, ipv6
11:26:11 * Akshaal didn't see it before in action
11:27:06 <adept> Akshaal: you forgot iso-ir-111, koi8-e, iso8859-5 :)
11:27:07 <mi_chiel> enjoy it while it still impresses; soon ipv6 will become the domain of chinese spammers and malaysian schoolchildren using msn
11:27:42 <adept> kowey: ALL of them overlap latin-1 in one way or another :)
11:27:51 <kowey> well, i meant in a very practical way
11:28:13 <kowey> i.e. cyrillic letters == accented latin letters and not some weird symbol
11:28:30 <kowey> of course, i'm at my easily confused time of day...
11:28:38 <adept> kowey: ah, it's iso8859-5
11:29:25 <glguy> I would like to give SGI the unreadable C++ coding award for their work on the STL
11:29:34 <adept> why, we even have RFC which defines iso-ir-111, but RFC text actually gives codepoint for mix between win-1251 and iso-8859-5 (dont know if it got fixed during last year or so)
11:30:19 * glguy is trying to read over the STL implementation of next_permutation to guide his version for Haskell
11:30:37 <kombinator> dcoutts: what do you mean by layout propertY?
11:31:26 <dcoutts> kombinator, eg set window [ layout := layoutVertical [widget1, widget2] ]
11:31:26 <CosmicRay> hey SyntaxNinja!
11:31:37 <CosmicRay> Akshaal: :-)
11:31:45 <CosmicRay> Akshaal: I've been using ipv6 for a year or more now, IIRC
11:32:03 * adept has ipv6 alias for localhost too
11:32:09 <franka> I was wondering if anyone had ever used the Zipper with Bird & Paterson's approach to higher-order syntax.
11:32:24 <franka> Meaning the S, Z types with polymorphic recursion and monads.
11:32:29 * SyntaxNinja thinks CosmicRay owes me an email
11:32:43 <Akshaal> adept: like that? fe00::0 ip6-localnet
11:32:51 <adept> yep
11:32:52 <CosmicRay> SyntaxNinja: will "count me in" suffice? ;-)
11:33:08 <CosmicRay> SyntaxNinja: though it's hard to predict how much free time I'll have to work on things
11:33:13 <CosmicRay> SyntaxNinja: thanks for your e-mail btw
11:33:37 <CosmicRay> SyntaxNinja: see the latest HWN for an explanation of why I blame the ancient egyptians for my lack of time ;-)
11:34:09 <dcoutts> CosmicRay, yeah, I liked that explanation
11:34:14 <CosmicRay> ;-)
11:35:09 <CosmicRay> dcoutts: I figure that if I force myself to write several paragraphs whenever HWN misses a week, it probably won't happen again ;-)
11:35:10 <franka> I should say, Succ and Zero types, to encode the environment of a term in HOAS.
11:35:38 * SyntaxNinja lunch &
11:37:10 <franka> I guess that's a "no".
11:41:05 <ValarQ> shapr: ok, i've done it again ;)
11:41:17 <ValarQ> http://arda.no-ip.org/ptest.hs
11:41:42 <ValarQ> what is wrong with my 'dist' function?
11:43:19 <ValarQ> i get this error message: "Couldn't match the rigid variable `a' against the rigid variable `a1'"
11:43:22 <Akshaal> valar, arda, someone loves tolkien alot...
11:43:44 <ValarQ> Akshaal: nah, not that much
11:44:20 <ValarQ> Akshaal: i'm just poor at making names compared to Tolkien ;)
11:44:38 <Akshaal> :)
11:45:34 <Akshaal> btw, valar is a plural form of 'vala'
11:46:12 <franka> ValarQ, have you got -fglasgow-exts on?
11:46:15 <int-e> ValarQ: you're using two different Num instances there, but dist only works if a and b are the same type, and sqrt only works if that type is an instance of Floating
11:46:43 <ValarQ> int-e: ok
11:47:04 <franka> I've never seen that "rigid variable" message.  Is it related to wobbly types?
11:47:14 <int-e> ValarQ: so your instance declaration should be instance (Floating a) => Position (a, a)
11:47:31 <int-e> hmm. rigid
11:47:44 <int-e> hypot should have a type signature
11:48:13 <int-e> franka: it's related to the 'monomorphism restriction' I believe.
11:48:26 <franka> Really?  Must be a new error message.
11:48:40 <franka> I haven't used the recent GHC versions much.
11:48:55 <ValarQ> int-e: ok, now it has
11:50:04 <int-e> franka: I'm guessing, mind you. the ghc code is gibberish to me :)
11:50:48 <ValarQ> int-e: (Floating a) => Position (a, a)  didn't work that good thought
11:51:36 * int-e missed the type of dist ... hmm.
11:52:05 <ValarQ> ?
11:53:03 <int-e> you need a way to get an arbitrary RealFloat from an arbitrary Floating ...
11:55:07 <ValarQ> why can't i use RealFloat everywhere?
11:56:34 <franka> ValarQ, try instance (Num a) => Position (a,a) where ...
11:56:41 <franka> Or do you need the extra generality?
11:57:21 <franka> The problem is that you can have Num a => a and Num b => b but no relation between the operations on both.
11:58:22 <ValarQ> franka: same error with Num
11:58:22 <franka> Or, no... you in a1+b1 you have a1 :: a and b1 :: a, looks like.
11:58:30 <SamB> franka: like if a was Int and b was something called GF8?
11:58:31 <ValarQ> "Illegal instance declaration for `Position (a, a)'"
11:58:32 <franka> you = you have
11:59:13 <franka> Eh?  Wait, lemme try this.
11:59:18 <ValarQ> well, they should be of the same type actually
11:59:38 <SamB> in which case fromInteger would only be valid on 0 and maybe 1...
11:59:39 <ValarQ> so  (Num a) => Position (a,a) where  feels right
12:01:40 <ValarQ> hmm :/
12:02:05 <franka> It works for me with -fglasgow-exts.
12:02:12 <franka> Well, something close to it does.
12:03:17 <franka> Ah, oops, your dist causes a problem.
12:04:06 <ValarQ> oh, thats good news :)
12:04:39 <int-e> @type abs
12:04:40 <lambdabot> forall a. (Num a) => a -> a
12:05:04 <ulfdoz> Does it make sense to define the isPrime predicate for negative numbers?
12:05:34 * ValarQ disappears
12:06:29 <int-e> ulfdoz: sure why not
12:06:36 <franka> OK, I don't understand what uncurry hypot (p2 |- p1) is supposed to mean.
12:07:09 <int-e> franka: (\(a,b) -> hypot a b) (p2 |- p1)
12:07:45 <franka> Yes, but... oh, OK.
12:07:47 <int-e> franka: that's not the problem; the problem is how to get that arbitrary RealFloat value from an arbitrary Num ...
12:07:48 <franka> Justasec.
12:08:23 <int-e> (where the 'arbitrary' ranges over the concrete type of the type class)
12:08:48 <franka> Yes, I see, nvm.
12:08:52 <int-e> @type sqrt
12:08:53 <lambdabot> forall a. (Floating a) => a -> a
12:09:20 <int-e> that's why I wanted Floating, but obviously there's still no way to get from there to every RealFloat ...
12:09:35 <int-e> @type realToFrac
12:09:36 <lambdabot> forall b a. (Fractional b, Real a) => a -> b
12:10:16 * int-e wonders how that's supposed to work for user defined Fractional and Real class instances ...
12:10:54 <ibid> @type fromRational
12:10:55 <lambdabot> forall a. (Fractional a) => Rational -> a
12:11:01 <ibid> @type toRational
12:11:01 <lambdabot> forall a. (Real a) => a -> Rational
12:11:10 <ibid> like that
12:11:15 <franka> I think I see the problem.
12:11:26 <franka> sqrt is getting instantiated at the wrong type.
12:11:41 <ibid> @type fromRational . toRational
12:11:42 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
12:11:50 <franka> First of all, you want dist :: p -> p -> p and instance (Floating a) => Position (a,a)
12:13:04 <franka> And, erm... lessee.
12:13:07 <int-e> ibid: good point, thanks
12:16:37 <franka> (still thinking)
12:16:39 <ulfdoz> int-e: A line of potencially buggy code deriving another part of the inherent lisp implementation. :)
12:16:44 <franka> (sorry, I'm a bit drunk atm)
12:17:43 <franka> Oops, I was wrong.
12:18:35 <franka> OK, the problem is that you DO want something like dist :: (Floating a) => p -> p -> a.
12:18:44 <franka> But a has to be related to the components of p.
12:19:12 <int-e> ulfdoz: it depends on what you want really, but for many purposes, -3 is as good a prime as 3.
12:20:18 <ulfdoz> int-e: I'm currently doing my homework, so there is not a real goal behind.
12:20:55 <int-e> class (RealFloat d) => Position p d | p -> d where [...] dist :: p -> p -> d
12:21:03 <int-e> this can be made to work at least.
12:22:23 <franka> Yes, that's what I was trying, and it works.
12:22:28 <int-e> ulfdoz: that being said the common definition for integers excludes negative primes to get a nicer unique factorization formulation.
12:23:53 <franka> class (Floating a) => Position p a | p -> a where ...
12:23:53 <franka> instance (Floating a) => Position (a,a) a where
12:23:54 <franka> etc.
12:25:01 <franka> What you really want here is a class Field, with scalars a and vectors p.
12:25:25 <franka> And you make the scalar multiplication a -> p -> p a method.
12:25:50 <int-e> they're vector spaces in english.
12:26:00 <franka> Oops, actually a class Metric.
12:26:04 <franka> Because you have a norm dist.
12:26:27 <franka> Yes, more or less.
12:26:40 <int-e> fields are rings with multiplicative inverses
12:26:44 <franka> A metric space being a vector space with a norm.
12:27:29 <franka> But people have tried defining these kinds of algebraic type classes and there are problems.
12:28:13 <SamB> franka: what sort of problems?
12:28:42 <franka> Hm, good question.  I always forget until I actually try it myself.
12:28:58 <int-e> well for one it seems you really need multi-parameter classes and functional dependencies to properly encode that.
12:29:12 <int-e> which are not part of Haskell 98.
12:29:40 <SamB> int-e: who cares!
12:29:59 <astrolabe_> franka a normed space is a vector space with a metric :)
12:30:33 <franka> Ah, thanks astrolabe.
12:33:10 <kosmikus> ... with a norm, not a metric
12:33:20 <kosmikus> every norm induces a metric, but not the other way around
12:34:08 <franka> Eh, a norm has to satisfy the triangle law, yes?
12:34:29 <int-e> kosmikus: nitpick, the example we were discussing had a metric (distance between two points)
12:34:40 <kosmikus> franka: yes
12:34:48 <kosmikus> int-e: sorry, haven't read the backlog
12:34:55 <franka> But not a metric?
12:35:45 <int-e> franka: I think the point is that a metric need not be invariant under translations.
12:36:11 * ValarQ appears again
12:36:30 * int-e would like to be corrected if that's wrong :)
12:37:11 <kosmikus> for a norm, you must have  \norm{av} = a \norm{v}  for every scalar a
12:37:37 <astrolabe_> kosmikus: sure, but that wasn't the point I was making
12:37:51 <kosmikus> sorry, \norm{av} = \abs{a}\norm{v}
12:38:15 <franka> nvm, We can find this in any text.
12:38:16 <kosmikus> astrolabe_: just trying to answer franka's question ...
12:38:24 <tuomov> a metric doesn't necessarily conform to the linear structure of a vector space
12:38:25 <franka> Not that I don't appreciate it.
12:39:11 <kosmikus> yes, tuomov's explanation is better. a metric is a wider concept, not only applicable to vector spaces.
12:39:41 <franka> Ah, OK.
12:39:53 <franka> A norm is a linear metric.
12:40:27 <tuomov> it isn't a linear functional, but a subadditive and positively homogenous one
12:43:12 <ValarQ> int-e: so there isn't any simple solution to my problem then?
12:44:39 <int-e> ValarQ: I think not (using type classes) because your vector type defines the return type of dist ...
12:48:27 <ValarQ> hmm, when i write dist as a standalone function it works
12:48:50 <int-e> ValarQ: but that will only work for one instance of your type class.
12:49:00 <ValarQ> and if i examine the type of dist with ghci it says  dist :: (Position (b, b), RealFloat b) => (b, b) -> (b, b) -> b
12:49:33 <ValarQ> int-e: right
12:50:00 <franka> Yes, but presumably you want dist to work for all instances of Position.
12:50:04 <int-e> ValarQ: note how (b,b) defines the return type of dist (also b)
12:51:55 <ValarQ> ok, i see the problem
12:52:41 <int-e> ValarQ: in particular, the type is not dist :: (Position (b, b), RealFloat a) => (b, b) -> a  which your original class signature would require.
12:52:44 <ValarQ> i think i go for a  dist :: Pnt -> Pnt -> Float  function
13:32:38 <water> from http://www.haskell.org/hawiki/LicensedPreludeExts , there is an HOF named swing which has no online documentation that i've found anywhere else. is there a way to explain this for those who are too rusty in haskell to read it immediately?
13:38:03 <musasabi> water: you might try to understand it through the given examples.
13:38:17 <musasabi> (it seems quite hard to describe what it does)
13:38:33 <int-e> @pl let swing f a b = f (\g -> g b) a in swing
13:38:34 <lambdabot> flip . (. flip id)
13:39:04 <musasabi> "swing map" takes a list of functions and a value. It returns a list of a applied to each of the functions given.
13:39:19 <water> unfortunately i can't tell how to read them. is forall an informal way to specify a formal logical formula or an HOF in haskell itself?
13:39:24 <int-e> @pl let swing f = flip (f . flip ($)) in swing
13:39:25 <lambdabot> flip . (. flip id)
13:39:33 <musasabi> "swing" any takes a list of functions and a value. It returns True if any of the functions applied to the value return True.
13:39:55 <water> hrm
13:40:07 <musasabi> "swing any" that is.
13:40:16 * water nods
13:40:46 <water> my problem is that i intend to port it if possible. i see the coolness, but not the idea :)
13:43:46 <int-e> @type partition
13:43:47 <lambdabot> Not in scope: `partition'
13:43:53 <int-e> @type Data.List.partition
13:43:54 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:45:09 <SamB> @type (.).(.)
13:45:10 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:45:57 <int-e> @pl let swing f b a = f (\g -> g b) a in swing
13:45:58 <lambdabot> (. flip id)
13:46:26 <SamB> @type let swing f b a = f (\g -> g b) a in swing
13:46:27 <lambdabot> forall t t1 t2 t3. (((t -> t1) -> t1) -> t2 -> t3) -> t -> t2 -> t3
13:46:51 <SamB> @type (.) (.)
13:46:52 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
13:46:58 <water> unfortunately this all is lost on me
13:47:02 <SamB> alright, what bozo said "swing = boobies"?
13:48:21 <int-e> well, obviously boobies don't flip.
13:48:38 <shapr> water: It swaps data and function.
13:48:58 <water> hey shapr
13:49:04 <shapr> hi water
13:49:35 <water> well, flip has a direct analogue for my purposes, of course. but i don't get the notation of dot and $
13:49:39 * int-e finds swing too obscure to be useful; it's interesting that this same pattern will appear in so seemingly different applications though.
13:49:52 <shapr> water: map takes a function and a list of data, swing map takes a piece of data and a list of functions.
13:50:01 <water> huh
13:50:19 <int-e> water: if you don't like ($), use id there. it's the same
13:50:21 <SamB> that sounds pretty usefull to me...
13:50:23 <water> ah
13:50:50 <SamB> @type ($)
13:50:51 <lambdabot> forall b a. (a -> b) -> a -> b
13:51:38 <musasabi> swing switches the component in the unlifted and lifted domain around ;)
13:54:16 * int-e would spell it out.  swing map a ==> map ($ a)   and   swing map ==> \a -> map ($ a)
13:57:52 <water> ok, now i've got it. the translation went directly, but not the documentation / explanation. thanks :)
13:59:19 <SamB> @type let swing' f a = f ($ a) in swing
13:59:19 <SamB> @type let swing' f a = f ($ a) in swing'
13:59:20 <lambdabot> Not in scope: `swing'
13:59:20 <lambdabot> forall a b t. (((a -> b) -> b) -> t) -> a -> t
14:00:00 <nuffer> if I have
14:00:07 <nuffer> data Blah = A | B | C
14:00:20 <nuffer> how can I make it so that A == A and B == B and C == C?
14:00:20 <int-e> hmm. I confused the arguments ... well, ok, I wanted to switch them anyway :-P
14:00:30 <SamB> nuffer: deriving (Eq)
14:00:32 <nuffer> instead of getting a "No instance for Eq in Blah" error
14:00:59 <int-e> @type let swing' f a b = f ($ b) a in swing'
14:01:00 <lambdabot> forall a b t t1. (((a -> b) -> b) -> t -> t1) -> t -> a -> t1
14:01:05 <nuffer> how do you derive more than one thing?
14:01:09 <nuffer> (it's already deriving Show)
14:01:19 <dons> use tuple syntax
14:01:30 <dons> derive (Eq,Ord,Show,Read,Typeable)
14:01:36 <dons> deriving, of course
14:01:38 <nuffer> oooh, got it, thanks
14:03:22 * CosmicRay must run, cyall later
14:03:58 <dons> @dynamic-reload dummy
14:03:59 <lambdabot> module reloaded
14:04:02 <dons> @help libsrc
14:04:03 <lambdabot>  @libsrc <lib>, lookup the url for the darcs source for a library
14:06:53 <dons> hello romildo!
14:06:55 <dons> welcome
14:07:08 <dons> are you learning haskell?
14:07:20 <romildo> dons: hello.
14:07:30 <romildo> Not exactly.
14:07:36 <dons> no?
14:07:40 <dons> you already know it?
14:07:53 <romildo> I already know it.
14:07:58 <dons> cool!
14:08:03 <dons> @karma+ romildo
14:08:04 <lambdabot> romildo's karma raised to 1.
14:08:22 <dons> have you met lambdabot?
14:08:30 <dons> @type map
14:08:30 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
14:08:34 <dons> @type map (+1)
14:08:35 <lambdabot> forall a. (Num a) => [a] -> [a]
14:08:35 <kosmikus> romildo: hey, you're the one with the tee: write error bug
14:08:47 <kosmikus> romildo: we're just discussing it on #gentoo-haskell ...
14:08:48 <dons> @eval map (+1) [1..10]
14:08:49 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
14:08:50 <romildo> I have not met lambdabot.
14:08:55 <dons> @kind Int
14:08:56 <lambdabot> *
14:09:02 <dons> @docs Data.List
14:09:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
14:09:09 <dons> @index fmap
14:09:09 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
14:09:09 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
14:09:09 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
14:09:15 <dons> lots of useful things for haskell hackers
14:09:35 <dons> oh, you might want to look at:
14:09:36 <dons> @map
14:09:37 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
14:09:38 <romildo> kolmodin: yes, I am the one from gentoo.
14:09:55 <dons> and maybe add yourself to the growing list of Brasillian Haskell hackers  :)
14:10:42 <kolmodin> romildo: you posted the tee bug in gentoos bugzilla?
14:10:50 <romildo> kolmodin: yes
14:11:12 <kolmodin> romildo: ok, I don't have a fix, I've only come up with a workaround
14:11:54 <romildo> kolmodin: I cannot explain the bug. I have just tried again, now at the console (no X Window running), and "emerge -v ghc" succeeded this time.
14:12:06 <astrolabe> dons: Any chance of expanding the map of western europe.  It's getting a bit crowded.
14:12:13 <kolmodin> romildo: don't know if you've been told yet, but it suffices to pipe emerges output to /dev/null
14:12:16 <kosmikus> yes, we know the bug, but we can't reliably reproduce it
14:12:34 <kolmodin> right, sometimes it works, but mostly not. not for me anyway
14:12:44 <dons> astrolabe, yes, good point. I'll do that
14:12:56 <astrolabe> dons: thanks very much!
14:13:12 <kosmikus> romildo: could you join #gentoo-haskell, please?
14:13:16 <romildo> kosmikus: have you gone through this tee bug too?
14:13:33 <kosmikus> romildo: in fact, I have
14:14:12 <romildo> I did not know there is a#gentoo-haskell
14:16:58 <kolmodin> oh, it is there allright :)
14:23:29 <kolmodin> -l
14:24:05 <tessier> WTF is there a gentoo specific haskell channel?!
14:24:26 <tessier> Does gentoo fsck haskell up so bad that it needs its own channel to support it?
14:24:53 <musasabi> Gentoo seems to support Haskell very well.
14:25:12 <musasabi> (I think it may even have the best support ;)
14:25:24 * mi_chiel shudders at the thought of having to build ghc every single time, though
14:25:59 <musasabi> Well each to their own lunacy ;)
14:26:05 <mi_chiel> musasabi: Debian claims to have ghc 6.2 binaries for Alpha, I found that reasonably impressive
14:26:36 * mi_chiel gave up trying to build it for NetBSD/alpha
14:26:41 <musasabi> now if I could get my alpha to boot debian instead of NetBSD
14:26:52 <mi_chiel> heheh
14:27:00 <mi_chiel> NetBSD is nice enough :)
14:27:15 <musasabi> mi_chiel: Maybe one could try using the linux emulation to run GHC on NetBSD/alpha.
14:27:26 <musasabi> mi_chiel: and then use that to build a native GHC.
14:27:37 <mi_chiel> musasabi: linux emulation on NetBSD/alpha is ancient
14:27:51 <mi_chiel> musasabi: only emulates 2.0.36 or something similarly 1998-ish :)
14:28:06 <musasabi> mi_chiel: ghc alpha support is ancient too, so they could match up with each other ;)
14:28:19 <mi_chiel> similarly, OSF/1 emulation didn't quite do the trick
14:28:20 <dons> i've actually run ghc with linux emul on openbsd. a few years ago
14:28:30 <dons> of course, running natively is more fun
14:28:34 <mi_chiel> musasabi: yeah, that's partially the problem with getting the thing to compile on Alpha
14:29:00 <mi_chiel> musasabi: lots of Alpha-related stuff there, but it seems out-of-date, and ghc source code is black magic to me.
14:29:06 <dons> so were did you get stuck mi_chiel?
14:29:29 <dons> hmm. maybe out of date. though alpha/linux is still working
14:29:37 <musasabi> Going via unregistered build should not have too many problems.
14:29:37 <mi_chiel> the native code register allocation thingy, IIRC
14:29:49 <musasabi> mi_chiel: just disable the NCG.
14:29:52 <dons> oh, yes, the ncg would be broken
14:29:54 <dons> but just disable that
14:30:00 <musasabi> dons: GHCI is broken too iirc.
14:30:04 <mi_chiel> well, that was the problem, it still wanted to build it, but it couldn't.
14:30:06 <dons> definitely broken
14:30:17 <dons> you won't be able to build the ncg
14:30:17 <mi_chiel> let me look at my mail archive
14:30:30 <dons> but you can still get a usable ghc
14:30:40 <mi_chiel> true
14:30:43 <mi_chiel> but my Alpha is venerable anyway
14:30:48 <mi_chiel> it's a 266 Mhz EV4
14:31:01 <dons> just add this to your build.mk:
14:31:02 <dons> GhcWithNativeCodeGen = NO
14:31:02 <dons> GhcWithInterpreter = NO
14:31:13 <mi_chiel> dons: yes, yes, did that, didn't work
14:31:22 <dons> what didn't work?
14:31:30 <mi_chiel> lemme look in my mail archive
14:31:50 <dons> (I'm not saying alpha/netbsd would be easy ... ;)
14:32:02 <mi_chiel> The RTS build
14:32:05 <mi_chiel> that didn't work
14:32:15 <dons> oh, the rts broke eh? hmm.
14:32:17 <mi_chiel> and apparently even the unregistered build needs some files from the RTS to work
14:32:23 <dons> of course
14:32:27 <dons> you need a runtime system
14:32:37 <dons> but the rts is all C, so you just need to hack at it
14:32:45 <dons> do you have the error msg somewhere?
14:32:52 <mi_chiel> no, IIRC, the stuff that failed was definately Haskell
14:33:05 <dons> unregistered /= no native code gen, btw
14:34:20 <mi_chiel> in any case, it's not trivial, and there was a lot of outdated cruft in it
14:34:25 <dons> yep :)
14:34:32 <mi_chiel> which makes me all the more interested in how the Debian people get it to build on Alpha
14:34:34 <dons> i never managed to get alpha/osf1 working either
14:34:45 <dons> only the debian guys seem to have done it in recent times
14:35:12 <dons> neither could I get netbsd/mac68k working :/
14:35:22 <dons> (due to ld segfaulting !)
14:35:38 <dons> after 31 hours of build time..
14:36:01 <dons> one day, one day...
14:36:12 <musasabi> Getting anything complex to compile on exotic platforms is an up-hill battle.
14:36:35 <musasabi> Wanted to have X11 with a vga card on my alpha...
14:36:56 <mi_chiel> depends very much on the card wether that works
14:37:07 <dons> musasabi, does Network-Alt let me get raw FastStrings off the network?
14:37:11 <dons> s/raw//
14:37:14 <mi_chiel> the alpha actually pretends to initialise the VGA bios during bootup
14:37:19 <mi_chiel> that might or might not work
14:37:26 <mi_chiel> or pretends
14:37:28 <mi_chiel> er.
14:37:35 <dons> musa, also, are you responsible for NewBinary?
14:37:37 <mi_chiel> It pretends to be a PC during vga initialisation
14:38:00 <mi_chiel> then there's XFree86, which isn't the most platform-independent code ever..
14:38:59 <dons> mi_chiel, you're not Emil Skoeldberg, by chance?
14:40:01 <dons> morning Pseudonym, if that is your real name
14:40:15 <mi_chiel> dons: nope
14:40:21 <mi_chiel> dons: never heard of him :)
14:40:40 <dons> ok, there you go. he's been mailing me recently about the ghc port on NetBSD in the ports tree
14:40:42 <musasabi> dons: like recvFPS :: Socket -> Int -> IO FastString ?
14:40:52 <dons> oh, that'd probably do it, yes :)
14:41:26 <dons> and I can send a FastString too?
14:41:28 <musasabi> mi_chiel: It was problems with various versions of X either not compiling or segfaulting or getting stuck.
14:41:39 <musasabi> sendFPS :: Socket -> FastString -> IO ()
14:42:03 * mi_chiel looks Emil Skoeldberg up on google
14:42:18 * mi_chiel can happily say that he's *not* into higher Algebras as this guy seems to be
14:42:20 <mi_chiel> in any case
14:42:22 <mi_chiel> good-night
14:42:35 <musasabi> dons: no, I am not related to NewBinary at all.
14:42:51 <romildo> What am I suposed to do to have myself marked on the map at http://www.haskell.org/hawiki/HaskellUserLocations ?
14:43:26 <musasabi> romildo: get your coordinates (e.g. from google maps) and edit add them to the wikipage.
14:43:32 <dons> romildo, either msg me the coords, and I'll add them, or login (click UserPreferences, get a name and passwd) then refresh
14:44:29 <musasabi> dons: planning to use network-alt for something? (just curious)
14:45:29 <romildo> dons, please, do that for me. Currently I live at Uberlândia, located at lat. 18 55 25 south, long. 48 17 19 west
14:46:32 <dons> musasabi, I'm thinking of a fast string layer for lambdabot
14:46:48 <dons> since there's now quite a few plugins which store most state as faststrings
14:46:58 <dons> but  then have to box them, before putting the values out on the network
14:47:00 <dons> i.e
14:47:03 <dons> @doc Data.List
14:47:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
14:47:32 <Yubanalesco> Is there any place where I can see some examples of using "until" ? Well, I can sort of use them for basic things, but it seems to dislike the way I put things...
14:50:42 <dons> romildo, done. the map updates in about 4 minutes
14:50:55 <romildo> dons: thanks.
14:55:16 <dons> @where NewBinary
14:55:16 <lambdabot> I know nothing about newbinary.
14:55:23 <dons> anyone know where NewBinary lives?
14:55:39 <dons> ah, maybe I've found it
14:55:43 <musasabi> Everyone seems just to include a version in their source trees.
14:56:04 <dons> yeah :/
14:56:06 <dons> bad bad
14:56:17 <dons> since it is now cabalised
14:56:43 <SyntaxNinja> cabal!
14:56:51 <musasabi> either darcs-subrepos or cabal-get.
14:57:23 <dons> hey uber-SyntaxNinja
14:57:47 <dons> @where+ NewBinary darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
14:57:47 <lambdabot> newbinary ~> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
14:58:03 <ndm> i still need to cabal hoogle - volunteers welcome....
14:58:04 * musasabi envisages that in a few years we get to the point where cabal, ghc and darcs all depend on each other ;)
14:58:25 <ndm> @where hoogle
14:58:26 <lambdabot> I know nothing about hoogle.
14:58:34 <dons> ndm, please add an url
14:58:39 <ndm> @where+ http://www.haskell.org/hoogle
14:58:39 <lambdabot> http://www.haskell.org/hoogle ~>
14:58:40 <dons> @hoogle where
14:58:41 <lambdabot> Graphics.UI.GLUT.Initialization.Where :: DisplayCapability -> Relation ->
14:58:41 <lambdabot> Int -> DisplayCapabilityDescription
14:58:41 <lambdabot> Graphics.UI.GLUT.GameMode.Where' :: GameModeCapability -> Relation -> Int
14:58:41 <lambdabot> -> GameModeCapabilityDescription
14:58:41 <lambdabot> Language.Haskell.TH.Ppr.where_clause :: [Dec] -> Doc
14:58:43 <dons> hehe
14:58:51 <SyntaxNinja> musasabi: it might not take a few years
14:58:52 <ndm> @where+ hoogle http://www.haskell.org/hoogle
14:58:52 <lambdabot> hoogle ~> http://www.haskell.org/hoogle
15:01:06 <dons> Binary should really, really be in the base libs
15:01:21 <ndm> the haskell98 libs have no way to write out binary files
15:01:27 <ndm> it bit yhc badly...
15:01:28 <dons> I know :/
15:02:13 <Yubanalesco> Can someone help me in Haskell ?
15:02:15 <ndm> to be fair, windows should give up on a stupid line ending and translation
15:02:18 <dons> really want i want is the ability to derive Binary without looking for DrIFT. Maybe I need SerTH then, eh musasabi?
15:02:25 <SyntaxNinja> Yubanalesco: probably
15:02:26 <ndm> and just output \n when someone asks for \n!
15:02:36 <ndm> Yubanalesco: whats your problem?
15:03:02 <Yubanalesco> Well, is just that I am not sure if I am using until properly. Of course if I use the basic way, it works...But I need a bit more.
15:03:07 <Yubanalesco> I am trying to do something like this: newton x y = until (abs(y^2-x)<0.001) ((y+x/y)/2) y
15:03:21 <ndm> @hoogle until
15:03:22 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
15:03:22 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
15:03:30 <ndm> @docs Prelude.until
15:03:30 <lambdabot> Prelude.until not available
15:03:48 <dons> ndm, those Win32 things are annoying ;)
15:03:52 <dcoutts> @docs Monad.until
15:03:53 <lambdabot> Monad.until not available
15:04:08 <ndm> i know! i removed the win32 libs from winhugs
15:04:14 <Yubanalesco> Should be in prelude...
15:04:15 <ndm> have to remove win32 and opengl from hoogle
15:04:17 <Yubanalesco> http://www.zvon.org/other/haskell/Outputglobal/
15:04:29 <dons> ndm, can I remove them by hand from hoogle.txt?
15:04:40 <dons> or is that going to break something
15:04:43 <ndm> sure
15:04:44 <astrolabe> Yubanalesco: your second argument isn't  :: a->a I think
15:04:51 <ndm> hoogle.txt is pretty robust
15:05:16 <dons> it's in blocks of decls sorted by module isn't it?
15:05:23 <SyntaxNinja> does ghc optimize tail calls if optimizations are not turned on?
15:05:39 <ndm> SyntaxNinja: i guess so
15:05:42 <dons> yeah, looks simple. I can just remove the blocks corresponding to the modules I don't like
15:05:45 <Yubanalesco> Well, it should be, in fact, at that case it is a Double -> Double.
15:06:00 <ndm> if it evaluates fully lazily, then thats optimising tali calls anyway
15:06:20 <ndm> dons, of course
15:06:37 <ndm> i have it on my todo list to break of win32 and opengl
15:06:50 <ndm> and add gtkhs and wxhaskell
15:06:54 <astrolabe> Yabanalesco: Can you describe it more in words?
15:07:07 <dons> @hoogle until
15:07:07 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
15:07:09 <dons> :)
15:07:19 <Yubanalesco> Well, I am *forced* to use "until" (which I am hating).
15:07:25 <ndm> why are you forced?
15:07:33 <dons> an exam?
15:07:37 <ndm> (is this an assignment...)
15:07:38 <Yubanalesco> It seems the lecturer wants us to us it.
15:07:55 <ndm> ignore your lecturer
15:08:03 <ndm> thats what i always did...
15:08:05 <astrolabe> I mean, can you describe the second argument in words?
15:08:06 <Yubanalesco> From what I understood, at least, so far...until in this case is "funny".
15:08:14 <astrolabe> ndm: bad advice :)
15:08:31 <Yubanalesco> Well, the second way is just a way to approximate a square root.
15:08:37 <ndm> astrolabe: i've been doing it for years, successfully
15:08:39 <dons> ndm, that's the best way to learn. I agree!
15:08:47 <Yubanalesco> For example, you choose any value, example: 1.
15:08:49 <Yubanalesco> So y=1
15:09:03 <Yubanalesco> Well, you are approximating, for example, square root of 2.
15:09:06 <Yubanalesco> So,x=2
15:09:52 * dons happily hacks binary persistence into lambdabot
15:10:10 <Yubanalesco> If you apply the formula once, you will see that you get "1" as result.
15:10:16 <astrolabe> Yubanalesco: Your second argument is a number, you need it to be a function
15:10:16 <Yubanalesco> Recursively, apply it again
15:10:38 <musasabi> dons: does NewBinary support advanced things like cyclic structures?
15:10:42 <astrolabe> So, what is the function that you apply repeatedly?
15:10:51 <Yubanalesco> (y+x/y)/2
15:11:00 <dons> musasabi, oh, I doubt it
15:11:09 <Yubanalesco> x, stays the same for the whole recursion.
15:11:14 <astrolabe> Yubanalesco: that isn't a function, it is a number
15:11:20 <musasabi> then again Show does not support them either.
15:11:23 <Yubanalesco> \y -> ((y+x/y)/2) ?
15:11:29 <dons> musasabi, yep :)
15:11:35 <astrolabe> Yubanalesco: right
15:12:04 <astrolabe> Yubanalesco: But maybe better say \z -> ((z+x/z)/2)
15:12:15 * dons says: read is *slow*
15:12:20 <Yubanalesco> Humm...
15:12:33 <Yubanalesco> But I need to assign the initial value...
15:12:58 <astrolabe> The third arg to until does that I think
15:13:01 <musasabi> I wish GHC wasn't so naughty - it uses the same physic value for multiple values of different types.
15:13:10 <Yubanalesco> Not that it was requested by the lecturer, but it is sensible for this approximation method since, with a right start value it helps in performance.
15:14:33 <musasabi> SerTH can either just unsafeCoerce# the way (opens holes with untrusted data Stream) or kill unsuspecting users (GHC shared your data of different types) or be slower (type-indexed maps instead of StableNames)
15:15:55 <astrolabe> Yubanalesco: Yep, thats what the third arg to until does
15:16:15 <Yubanalesco> Humm, gah...Can't believe it, well...It fixed the main problem now. Is just that I seldom use the lambda expression.
15:16:44 <astrolabe> :) Well, it is handy.
15:16:52 <Yubanalesco> Since when I start to work with too many functions, I will start don't know which is which...
15:17:00 <int-e> musasabi: I don't see anything naughty about it, after all this is a strictly typed language and users of unsafeCoerce# (or unsafePerformIO) really should know better ...
15:17:35 <astrolabe> Yubanalesco: You could define f z = ... and then use f
15:17:59 <Yubanalesco> True...I need to start that habit.
15:18:14 <Yubanalesco> Most of the things I can do in Haskell is based on what I know in ProLog...
15:18:25 <Yubanalesco> Even if they are...different :P
15:19:15 <dons> binary data at runtime always causes trouble, since it's untyped, it's easy to break things
15:19:29 <musasabi> int-e: you are saying I shouldn't access data members behind opaque constructors and unsafeCource# my function applications ;)
15:20:33 <int-e> musasabi: quite so
15:20:48 <int-e> musasabi: if you do, you better know what you're doing ;)
15:21:13 <int-e> musasabi: and it's you being naughty, not the compiler.
15:21:53 <musasabi> int-e: well that only causes errors if I try to check that I am not being naughty. If I just unsafeCource# without worrying whether the thing I am coercing is valid then there are no problems.
15:28:41 <int-e> musasabi: hehe
15:37:33 <Yubanalesco> Is there anyway to express "abs(y^2-x)<0.001" for the conditional argument for the function "until"? Well, I could move everything that is "non-y" to the other side, however that requires doing a square root...Not that I am not allowed to, but, I just find it funny doing a square root when my function approximates square roots...
15:40:29 <musasabi> sq x = until (\y -> y^2 - x < 0.01 ) <something> x
15:41:25 <astrolabe> except you need the abs
15:41:39 <musasabi> oh that one too.
15:41:50 <musasabi> sq x = until (\y -> abs (y^2 - x) < 0.01 ) <something> x
15:41:50 <astrolabe> Yubanalesco: You need to understand what was wrong last time.  It is the same problem again.
15:43:05 <Yubanalesco> Humm...
15:43:48 <Yubanalesco> I thought it was because the conditional ones is in the form "y <clause>" where y is omitted.
15:44:03 <Yubanalesco> I could do the workaround, as I said, with (<sqrt(0.00001+x))
15:44:21 <Yubanalesco> However, is just that I did not want to use sqrt.
15:44:42 <astrolabe> @type until
15:44:42 <Yubanalesco> Did not know that I could use the lambda expression like that :-/
15:44:43 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
15:45:07 <astrolabe> You need to make g:: a-> Bool
15:45:19 <Yubanalesco> Always thought that it was used, just to be lazy, so that you do not need to declare the function.
15:45:34 <astrolabe> Yubanalesco: It is
15:45:53 <astrolabe> lazyness is next to godliness
15:46:24 <Yubanalesco> Well, it is very handy...I am quite happy with the take + iterate combo.
15:47:10 <Yubanalesco> While iterate generates an infite list, Haskell just stops as soon that he got enough elements to take.
15:47:30 <astrolabe> Yeah, that is nice
15:48:32 <Yubanalesco> If it were a general programming language, an infinite loop is an infinite loop, you are pretty stuck!
15:49:41 <astrolabe> Well, in a strict language, you cannot have infinite data structures certainly.
15:49:43 <Yubanalesco> Since I am new to Haskell, it is quite interesting to see that normally I will need a handful of lines to do the same thing, while Haskell is just like 1-3 lines (for simple things).
15:50:56 <musasabi> Haskell programming tends to be about defining suitable abstractions and then expressing your ideas with those.
15:51:02 <astrolabe> I find it doesn't save thinking, but it does save typing and debugging.
15:51:29 <Yubanalesco> Typing yes, I don't know about debugging, at least for me :P
15:52:28 <astrolabe> The bugs tend to get caught by the compiler, which is much better than getting them at run-time.
15:53:52 <Yubanalesco> Well so far for me, true, most of the times as soon that it compiles, it seems that it would work as expected. While if I do programming in Java, I will waste a good amount of time catching run-time bug. But since it is different level of programming...I don't know for sure yet!
16:08:02 <kosmikus> JohnMeacham: nice mail to haskell@... :)
16:30:30 <araujo> Hola Nomius_ :-]
16:32:27 <MenTaLguY> hello
16:34:09 <SyntaxNinja> Haskell'
16:34:16 <SyntaxNinja> "Haskell Prime"
16:34:46 <SyntaxNinja> we can fork off a process of the great battle for the next name, and in the meantime, in order to get anything done, just call it Haskell' :)
16:35:41 <araujo> SyntaxNinja, what for?
16:36:25 <SyntaxNinja> araujo: ?
16:37:22 <araujo> SyntaxNinja, i mean, what is that haskell' all about? :-)
16:38:41 <int-e> hmm. a strict version of haskell? a derivative of haskell? something that is completely unlike haskell but that the coder didn't find a better name for?
16:39:00 <SyntaxNinja> no
16:39:18 <SyntaxNinja> the next version of Haskell.  I was responding to kosmikus comment about JohnMeacham's post
16:39:28 * heatsink can't find it in the logs
16:39:53 <SyntaxNinja> (16:07:40) kosmikus: JohnMeacham: nice mail to haskell@... :)
16:40:02 <SyntaxNinja> http://www.haskell.org//pipermail/haskell/2005-November/016731.html
16:40:54 * araujo checks
16:43:38 <soysauce> I'm looping over getLine, but I always get the following message: main: <stdin>: hGetLine: end of file
16:43:46 <soysauce> isn't there a way to detect end-of-input?
16:44:37 <heatsink> soysauce, hIsEOF
16:45:09 <heatsink> soysauce, you can use isEOF to detect EOF on stdin
16:45:18 <MenTaLguY> Question:  can anyone suggest a simple algorithm that benefits from lazy evaluation?
16:45:22 <MenTaLguY> I need one for an illustration
16:46:45 <araujo> @eval takeWhile (< 100) (map (^ 2) [0 ..])
16:46:46 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
16:47:42 <dons> many expressions are simpler, as generating the infinite series is easy, and then we just take as much as we need
16:47:53 * MenTaLguY nods
16:48:15 <dons> darcs, yi and dazzle, some large haskell applications, also use laziness as the general application structuring technique.
16:48:56 <heatsink> Hmm, how d'ya do that?
16:49:16 * heatsink uses a few laziness idioms, rarely relies on laziness beyond those
16:49:40 <dons> well, each application is different. but yi for example uses Chans to hook multiple threads together which communicate via these lazy lists.
16:49:48 <dons> thus all the threads just do as much works as they need to
16:50:06 <dons> also, input is a lazy list, so yi only computes as much editing as it needs
16:50:08 <heatsink> streaming apps!
16:50:11 <dons> right
16:51:24 <dons> ghc uses laziness to make sure only as much IO (when reading .hi files) is done as is required
16:52:53 <wilx`> Hmm, the constness thread in Haskell ml is interesting :)
17:09:47 <kosmikus> SyntaxNinja: I guess there'll be enough time to decide the name later on, when most of the work is done. Any working title is fine with me ...
17:17:32 <SyntaxNinja> kosmikus: same here :)
17:17:45 <SyntaxNinja> I just think it's kinda funny to be arguing about it already.
17:24:30 <stepcut> maybe there are too many haskell mailing lists
17:26:31 <Nomius> araujo, hola
17:28:23 <SyntaxNinja> stepcut: why?
17:29:17 <araujo> Nomius, :-]
17:31:30 <stepcut> SyntaxNinja: because I am subscribed to 3 or 4 already, and apparently, there is this other exciting one I am not subscribed to that I didn't even know about
17:33:37 <SyntaxNinja> stepcut: the haskell@haskell.org list?
17:34:37 <stepcut> yeah
17:34:53 <stepcut> I am only on haskell-cafe and a bunch of ghc-* ones i think
17:36:38 <stepcut> ok, crisis averted, I am now subscribed :)
17:37:07 <MenTaLguY> so what's the business about Haskell' or whatever it gets called?
17:44:25 <Pseudonym> Haskell is a brand of ice cream.
17:44:31 <Pseudonym> We're all fans of it.
17:47:23 <MenTaLguY>  /me sighs
17:47:24 <MenTaLguY> never mind
17:47:31 <Pseudonym> :-)
17:47:58 <MenTaLguY> as an addendum to my earlier question, anyone got any other lazy algorithms that don't involve simply take-ing from an infinite list?
17:48:40 <Pseudonym> Lots of them.  It turns out, usually, that strict functional algorithms in a lazy language turn amortised costs into worst-case costs.
17:48:46 <Pseudonym> A lot of the time, anyway.
17:49:01 <MenTaLguY> well, I'm just looking for a specific example
17:49:23 <MenTaLguY> I implemented lazy evaluation in Ruby, and I'm looking for something I can present with a Ruby version and a Haskell version
17:49:32 <Pseudonym> http://www.eecs.usma.edu/Personnel/okasaki/pubs.html#lazy
17:49:47 <MenTaLguY> Ruby doesn't really lend itself to lazy lists (or lists at all), unless you make your own list type
17:49:48 <Pseudonym> Some good stuff there.
17:49:51 <MenTaLguY> thanks
17:50:18 <SyntaxNinja> MenTaLguY: what do you mean "what's the business about Haskell' ..." ? what's your question?
17:50:47 <ndm> MenTaLguY: transitive closure
17:51:09 <ndm> in haskell, using lazy evaluation, you can perform the transitive closure in O(n) instead of O(n^2)
17:51:20 <ndm> without doing any additional work
17:51:29 <ndm> you simply pass the answer to the function generating the answer
17:51:38 <ndm> which is only possible with lazy evaluation
17:52:10 <ndm> that's laziness without an infinite list, its using laziness for performance benefits
17:52:36 <ndm> its called circular programming in general
17:53:24 <MenTaLguY> SyntaxNinja: oh, there was an earlier conversation about naming some Haskell successor
17:53:31 <MenTaLguY> I was wondering what the successor was supposed to offer
17:53:38 <Igloo> ndm: Hmm? Have you got some code so I can see what you mean?
17:53:54 <ndm> Igloo, hoogle :)
17:53:55 <Igloo> ndm: Or do you mean it's O(n) as long as you don't actually try and look at the full answer?
17:54:04 <ndm> will just get you the url of the cvs
17:54:16 <ndm> no, i mean O(n) if you evaluate it all
17:54:53 * Igloo realises ndm means hoogle itself, not that I should hoogle for it
17:55:13 <ndm> Igloo: http://cvs.sourceforge.net/viewcvs.py/hoogle/hoogle/src/Hoogle/TypeAlias.hs?rev=1.3&view=markup
17:55:15 <SyntaxNinja> MenTaLguY: we don't know what it'll offer yet.
17:55:29 <ndm> fixpAlias function
17:55:47 <heatsink> possible non-termination
17:55:49 <ndm>         map2 = AliasTable $ Map.map (\(a,b) -> (a, lookupAlias map2 b)) map1
17:56:02 <ndm> note that map2 is on both the right and the left of the function!
17:56:22 <ndm> heatsink: yes, possible non-termination - but i know all aliases terminate so its ok in this particular instance
17:56:30 <heatsink> so if you have a cyclic alias, you don't get an answer?
17:56:51 <Igloo> What are you taking the transitive closure of? I don't see a type where that makes sense
17:57:19 <MenTaLguY> ah, great
17:57:22 <ndm> heatsink, indeed "type A = B", "type B = A" would kill it
17:57:24 <MenTaLguY> that's exactly what I'm looking for
17:57:29 <ndm> Igloo, the transitive closure of types
17:57:35 <ndm> type FileName = String
17:57:40 <ndm> type String = [Char][
17:57:50 <ndm> and in one step, it resolves FileName -> [Char]
17:58:11 <Igloo> Is Type = String?
17:58:27 <MenTaLguY> oog, man
17:58:31 <MenTaLguY> now to try implementing that in Ruby
17:59:14 <MenTaLguY> let's see... AliasTable is just a data constructor that takes a Data.Map ?
17:59:17 <ndm> Igloo, its all about haskelkl type aliases
17:59:39 <ndm> MenTaLguY: yeah, its just a simple wrapper round a map [String, Type]
17:59:49 <Igloo> Oh, I see, it's only quadratic if you don't update intermediate steps in the strict version
18:00:03 <Igloo> But laziness does make it nicer code, agreed
18:00:14 <ndm> yes, the laziness made it beautiful
18:00:19 <MenTaLguY> hmm
18:02:58 <ndm>  Igloo, updating hte intermediate steps in the strict version would be very hard, and require dependancy analysis
18:03:13 <ndm> of course, in principle there is nothing strict code can do that lazy code can't
18:03:23 <Igloo> huh?
18:03:43 <ndm> at teh turing level - you can always encode strictness as laziness
18:03:44 <Igloo> if (x == null) { recurse; x = res; return res } else {return x}  roughly speaking
18:04:00 <Igloo> The "Huh" was at the previous line
18:04:24 <ndm> updating the strict version requires more boilerplate, and most people would avoid it since its harder
18:04:45 <Igloo> Yes, I said that above  :-)
18:05:03 <ndm> the massive advantage of laziness is equation reasoning: you can replace a function with its definitino at all points
18:05:14 <ndm> if you have strict evaluation, that no longer holds
18:05:51 <Igloo> No, that's the advantage of purity
18:06:15 <hyrax42> how logn can I expect a ghc build to take
18:06:36 <Igloo> On what spec machine?
18:06:40 <hyrax42> (installing from darwinports on ibook 1.33)
18:06:46 <ndm> Igloo: no, thats an advantage of laziness
18:06:53 <Igloo> 1.33GHz?
18:06:53 <ndm> in a pure language, its not true
18:07:02 <hyrax42> been going 2 hours now
18:07:03 <Igloo> Several hours I expect
18:07:04 <hyrax42> I think
18:07:06 <hyrax42> oh ok
18:07:10 <hyrax42> nothing's amiss then
18:07:12 <hyrax42> :p
18:07:27 <Igloo> ndm: Have you got an example?
18:07:34 <hyrax42> thanks Igloo
18:07:53 <ndm> cond (null x) [] (tail x)
18:08:01 <ndm> cond c t f = if c then t else f
18:08:20 <ndm> in a strict language, inlining changes the meaning, in a lazy language it doesn't
18:08:39 <heatsink> In a pure functional language it doesn't.
18:08:57 <heatsink> You can have a strict language in which inlining doesn't change the meaning.
18:09:05 <Igloo> Only because you have if as a lazy primitive
18:09:07 <ndm> heatsink, no, you can't
18:09:20 <ndm> Igloo: you always have to have a lazy primitive at some level
18:09:40 <heatsink> lambda calculus is lazy?
18:10:01 <Igloo> Hmm, that might be true
18:10:39 <Cale> lambda calculus doesn't have an evaluation mechanism, only an equivalence of terms
18:11:06 <Cale> so the lazy/strict thing doesn't really apply
18:11:31 <heatsink> It can be evaluated strictly as long as you stick to terms with a normal form.
18:11:41 <Cale> but I agree that lazy evaluation is better. It lets you be sure that correct programs compose as well as possible
18:12:18 <heatsink> What are the keys in System.IO.Weak for?
18:12:25 <heatsink> They seem to go into weak pointers and disappear.
18:12:35 <heatsink> *weak references
18:12:51 <heatsink> *System.Mem.Weak
18:13:41 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
18:13:50 <heatsink> Yup, that's what I was reading.
18:14:46 <heatsink> Are they just for determining reachability in the GC?
18:15:02 <Cale> I think that's a large part of it
18:15:50 <Cale> http://www.haskell.org/~simonmar/bib/weakptrs99_abstract.html
18:16:16 * heatsink is trying to write a typeclass for out-of-core data
18:21:53 <heatsink> "tombstone" :)
18:31:06 <heatsink> oh i get it. thx cale
18:43:10 <Korollary> holy moly. That "jhc vs ghc assembly" is a long thread...
19:59:43 <dons> @yow
19:59:44 <lambdabot> Hello, GORRY-O!!  I'm a GENIUS from HARVARD!!
21:27:31 <cge> Is there some way to do something like import "Data.Map as Map" in ghci?
21:27:56 <cge> I mean "import Data.Map as Map"
21:29:24 <Cale> well, there's  :m + Data.Map, of course, but that's not quite what you want
21:29:41 <cge> Cale: yes - that causes problems with map, etc.
21:30:15 <Cale> well, you can always use the fully qualified names
21:30:27 <Cale> but I'm not sure about renaming the import
21:30:38 <Cale> you could write that import into a file and load it
21:31:55 <cge> Cale: It works! Thanks
21:32:01 <JohnMeacham> Korollary: I have a habbit of starting obsenely long threads on occasion. theres always <whisper> global variables </whisper> proposal thread.
21:32:41 <Korollary> JohnMeacham: I am curious as if you can find time to sleep...
21:33:17 <Korollary> JohnMeacham: Just writing that stuff up would have taken me hours, let alone the actual work.
21:33:56 <JohnMeacham> Korollary: I sleep during the day of course :) actually, I have just been in a haskelly mood lately. it will pass and my activities will slow down. I think most of jhc was probably written in a handful of multi-day long coding sessions spread out over a few years.
21:34:41 <Korollary> JohnMeacham: When do you go to work ?
21:35:15 <JohnMeacham> At the moment I am recovering from an unplanned 5 day halloween binge so am a bit slow in responding. I still need to write up a response to SPJ about the cminusminus stuff.
21:36:35 <Korollary> JohnMeacham: I suppose that's a N/A.
21:36:36 <JohnMeacham> from home part of the time, from an office a block away the other part of the time. I took a pretty big pay cut to work somewhere relativly low stress so I had time to work on my own projects. it's like being a grad student with more pay and you get to work on what you want :)
21:36:55 <Korollary> JohnMeacham: ah, I see.
21:37:41 <Korollary> JohnMeacham: Working from home rocked when I was able to do it myself. Meetings get in the way, though.
21:39:40 <JohnMeacham> I think it is also because I really don't like writing english prose so have to power through it when I am in the right mood and try to fit as much as I can in.
21:41:05 <Korollary> JohnMeacham: Regarding c--, is it oblivious to things such as branch prediction, etc. or is there some other component that takes care of that ?
21:42:43 <JohnMeacham> Korollary: I don't know actually, I am still learning about it.
21:43:19 * Korollary is skimming the pdf
21:44:17 <Korollary> It says the c-- compiler is responsible for generating machine code, and only some arch properties are exposed.
21:45:00 <Korollary> I suppose high wizardry is captured in the c-- compiler and stuff like that is not visible in the c-- sources.
21:50:39 * Korollary wonders if somebody is writing a c-- compiler targeting x86
22:19:51 <JohnMeacham> Korollary: I imagine that implementations would be free to use annotations as hints on how to do things like branch prediction.
22:24:41 <Korollary> JohnMeacham: Do you mean like a front end may generate #pragma'tized c-- code, which the backend can exploit ?
22:25:57 <Korollary> JohnMeacham: Apparently they have a compiler up already, but it's slow.
22:26:10 <Korollary> I mean it generates inefficient code
23:08:52 <dons> aren't the C-- guys writing a compiler targeting x86??
23:09:10 <dons> ah, /me should scroll down
23:10:41 <basti_> Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤Ã¤
23:10:44 <basti_> ermn
23:10:52 <dons> basti_ goes nuts!
23:48:13 <JohnMeacham> Korollary: yup. I have only played with it a little. Once there are good c-- backends I will target it with jhc.
