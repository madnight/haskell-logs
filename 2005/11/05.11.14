00:03:50 <dons> people who like testing out new haskell software: http://www.cse.unsw.edu.au/~dons/hmp3.html
00:04:20 <dons> comments and problem reports are encouraged :)
00:04:38 <sethk> dons, what are we testing tonight?
00:04:54 <dons> hmp3.
00:05:13 <sethk> dons, I just got here, obviously; sorry for the obvious question
00:05:33 <dons> hehe  :) no, I just announced it. there was no context that you missed :)
00:06:06 <sethk> dons, well, in that case, I had better find something wrong with it.  :)
00:06:46 <dons> uh oh.
00:06:52 <dons> :S
00:07:17 <sethk> The next bit of code I'm doing (that I'm getting paid for doing, rather) can be in whatever language I like.  So I'm thinking about whether it fits into Haskell.  One part does nicely; I'm not sure about the other part.
00:07:49 <sethk> off hand, I'd say no, but I have to look at what assumptions are behind that "off hand"
00:08:01 <palomer> what's the project?
00:08:28 <sethk> palomer, I'm testing hardware as it comes off the assembly line, to accept it or reject it.
00:08:40 <dons> QuickCheck!
00:08:44 <sethk> palomer, processing the information I gather will work very nicely with haskell
00:09:07 <sethk> dons, problem with that is, I don't have an operating system.  :)
00:09:41 <sethk> I've never even thought about how one might right hardware test code in haskell
00:09:42 <tomaszz> Itkovian: one way is: oneOf "Bb" >> oneOf "Oo" >> oneOf "Oo" >> oneOf "Kk"
00:09:48 <sethk> it's an interesting question  :)
00:10:07 <Itkovian> tomaszz: ok. that's ugly :-) but thx.
00:10:08 <shapr> dash: you are here!
00:10:08 <tomaszz> Itkovian: the other is to define a case-insensitive 'char' function
00:10:18 <palomer> sethk: from my experience with functional programming: if you don't need datatypes or lazy evaluation (or quickcheck), then the other alternatives aren't so bad
00:10:27 <palomer> imoff!
00:10:27 <Itkovian> tomaszz: yeah, well I'll rewrite strings in terms of that
00:10:39 <shapr> sethk: I'd go with dons' idea. I'd use QuickCheck to generate tests, then execute those tests.
00:10:42 <tomaszz> Itkovian: how about: mapM_ oneOf ["Bb", "Oo", "Oo", "Kk"] ?
00:10:52 <Itkovian> tomaszz: idd
00:11:03 <sethk> shapr, ok, I haven't really looked at QuickCheck in detail.  I'll do that tomorrow.
00:11:20 <tomaszz> Itkovian: but in this case it's better to use case-insensitive combinators
00:11:52 <Itkovian> tomaszz: something like mapM_ oneOf (\x -> zip (map toUpper x) (map toLower x)) ?
00:12:16 <tomaszz> Itkovian: or preprocess the input (convert to uppercase, tokenize) ...
00:12:32 <tomaszz> Itkovian: yeah, why not
00:12:32 <shapr> dash: I've been playing with a nice TCP/IP stack written in Haskell lately.
00:13:00 <sethk> shapr, that might be useful for me.  The things I'm testing can report back to a server over TCP/IP, if I have a stack on the appliance
00:13:11 <dash> shapr: how can a TCP/IP stack possibly be nice
00:13:25 <dash> shapr: that is like talking about a nice wall socket or nice cinderblock
00:13:56 <shapr> Well, it's 1217 lines of Haskell code.
00:14:05 <dash> shapr: oh also! hi, how are you
00:14:18 <dash> shapr: huh, interesting.
00:14:20 <shapr> That's Ethernet frames up to TCP, with some IPv6 support.
00:14:34 <shapr> I've only used the IPv4 parts so far.
00:14:50 <shapr> Yes, hi! What's up?
00:15:13 <dash> shapr: temporary insanity is back, looking for network-protocol-parsing examples
00:15:30 <dash> i will probably just use parsec, since it doesn't have to be incremental parsing.
00:15:51 <shapr> Hm, I have some evil plans for just that sort of thing, but they're still in-progress.
00:16:14 <sethk> shapr, a sniffer application?
00:16:22 <shapr> Not exactly
00:16:39 <shapr> But I'll keep my blog updated with any results I get.
00:17:24 <shapr> Seems to me that protocols should be BNF specified as much as parsers. That's one thing I'd like to investigate with this project.
00:17:39 <dash> shapr: ok so maybe that code would be edifying to me
00:17:52 <dash> i would like to see how it deals with the TCP state machine
00:17:57 <sethk> shapr, I would suspect that you might have problems specifying more complicated protocols in BNF
00:18:08 <dash> sethk: such as?
00:18:15 <sethk> shapr, be interesting to prove or disprove that
00:18:28 <sethk> dash, well, some protocols have different methods of signalling the end of a transaction
00:18:32 <dash> i am contemplating a very state-machiney protocol, so it might come in handy
00:18:36 <shapr> If I can find some good way to write state machines, protocols should fit right in.
00:18:39 <sethk> dash, such as, closing the connection sometimes, but not always
00:18:49 <dash> sethk: yeah but that's not a parsing issue
00:19:07 <sethk> dash, why not?
00:19:47 <dash> sethk: because parsing is about the bytes you receive, not whether the connection closes or not
00:20:21 <sethk> dash, that's an arbitrary notion.  In any event, that would mean your parser fails if connection state is part of the protocol.  Hardly acceptable in general.
00:20:41 <dash> no
00:20:54 <dash> it just means that your parser is not your entire protocol implementation
00:21:39 <sethk> dash, that's an arbitrary distinction.  The effect would be messy code to deal with the real world.
00:22:07 <dash> sethk: surprise! that is the definition of the real world ;)
00:22:52 <sethk> dash, no, not really.  You design your software to model the real world, not the other way around
00:22:59 <dash> yes
00:23:07 <dash> hence, messy code.
00:23:30 <sethk> dash, I found it much cleaner to extend the notion of a parser to be independent of connection events
00:23:31 <shapr> Hm, my root partition says it's 95gb, has 86gb used, and 3.9gb free.
00:23:46 <sethk> shapr, overhead?  Or are those fake gigs?
00:23:53 <shapr> They were real yesterday.
00:24:02 <dash> sethk: anyway. i am looking at a protocol implementation i've been doing for work
00:24:23 <shapr> Yesterday I also had 91gb used. I tried checking my drive three times this morning, fsck fixed some stuff, but now I get incorrect results.
00:24:23 <boegel> shapr: maybe some disk errors ? :)
00:24:27 <sethk> dash, if that protocol doesn't use connection events in that matter, it isn't an issue obviously
00:24:43 <dash> sethk: it's about 13% parsing code
00:24:43 <sethk> shapr, what's the file system?
00:25:05 <shapr> It's an ext3 fs. Is there a --check-thoroughly option for e2fsck?
00:25:46 <sethk> shapr, there are a zillion options.  I have to reread the docs.  let me see if I have them here
00:25:53 <shapr> Seems to me that both parsers and protocols are just state machines. I think there's a nice generalization, but I haven't found it yet.
00:25:55 <sethk> shapr, I did a lot of digging in ext3 about 6 months ago.
00:26:30 <shapr> I changed to commit=300 two weeks ago, this is the first time I've had any weirdness with ext3.
00:26:54 <dash> shapr: yeah, good luck on the nice generalization
00:27:02 <sethk> shapr, one's an implementation, the other is I suppose conceptual, so they aren't exactly the same of course
00:27:04 <sethk> shapr, I can't imagine the commit spec having an effect on stability, baring lots of power failures or a major bug in the FS
00:27:06 <dash> shapr: i am facing a protocol with a 263 page RFC
00:27:14 <shapr> Which protocol?
00:27:16 <dash> it is made almost entirely out of special cases. ;)
00:27:18 <dash> SIP.
00:27:46 <sethk> dash, SIP is quite ugly, and I decided that a while back.  There have been revs, and lots more special cases, since then.  :)
00:28:09 <dash> sethk: you speak the truth
00:28:11 * shapr looks at the matching sip.py
00:28:53 <sethk> shapr, look at protocols with multiple versions, with streams from different versions intermingling.  A generalization there would be quite valuable, although I don't have a concept of one at the moment.  :)
00:29:19 <sethk> shapr, I wonder how up to date a sip.py would be.
00:29:39 <dash> sethk: last commit I made to it was friday. ;)
00:29:49 <shapr> Looks scary
00:29:49 <sethk> I found that things floating around for even elderly protocols like HTTP were often not well behaved for later revisions of the protocol.
00:29:58 <sethk> dash, it's yours?  That's different, of course.  :)
00:30:09 <dash> sethk: oh? :)
00:30:18 <dash> sethk: depends on what you mean by up to date
00:30:28 <dash> i'm only tracking RFC 3261, not any of the extensions
00:30:41 <sethk> dash, that's more than enough to track.
00:30:42 <dash> seeing how they aren't used in the wild
00:31:15 <sethk> dash, you mean the newer special cases aren't used in the wild?  Yet?
00:31:30 <dash> sethk: well which ones are you talking about
00:32:11 <sethk> dash, the project I was working on that used SIP got cancelled.  So I'm out of date on the RFC
00:33:26 <sethk> dash, and I wasn't really motivated to continue to read it after the thing got axed.
00:33:54 <dash> sethk: wow! i wonder why
00:34:09 <sethk> dash, perhaps a fatal lack of masochism  :)
00:34:09 <dash> (maybe because you don't have a desire to hurt your brain)
00:34:13 <dash> yeah! that
00:35:19 <shapr> Making Array an instance of Arbitrary is confusing me.
00:35:49 <shapr> Should I use coarbitrary to generate Arrays of different dimensions?
00:41:06 <sethk> shapr, if I use coarbitrary my entire brain will be garbage collected  :)
00:41:38 <shapr> I think coarbitrary is just for getting unique subpartitions of the generated results.
00:41:55 <shapr> I think it's a lot like splitting a prng.
00:42:03 <dons> isn't it for creating aribtrary functions?
00:42:08 <dons> maybe it has other uses
00:42:18 <shapr> g'day dons
00:42:21 * boegel asks again: what topic should I choose for the first issue of 'take 10 [1..]' ? (http://haskell.org/tmrwiki/TopTenHaskell)
00:42:32 * shapr doesn't know
00:42:41 <dons> I thought it was required so that you could write instance (Arbirary a, Arbitrary b) => Arbitrary (a -> b)
00:42:48 * boegel doesn't either, that's why he asks
00:43:46 * shapr looks at section 3.3 of quickcheck.ps
00:43:58 <stefanw> but dons, you told as just last week for what coarbitrary is good for ;-)
00:44:53 <dons> and like I say, it's so you can generate arbitrary functions
00:45:40 <stefanw> you wrote "I thought it was required ...", which sounds a bit unsure to me
00:46:17 <shapr> Yeah, it's used for arbitrary functions, but it gets those by making sure that the result of coarbitrary is dependent on the input.
00:47:40 <dons> yep. so if you have a Gen a -> b you can create Gen (a - b), iirc.
00:47:49 <dons> Gen (a -> b)
00:48:31 <shapr> So I guess it sort of makes sense to generate arrays of different dimensions according to the variant argument.
00:50:19 <dons> stefanw, "I thought ..." was a (bit subtle)  way of poliitely questioning the other person
00:50:38 <dons> so I didn't really mean I was unsure, but I pretend I am to be polite :)
00:51:19 <stefanw> or my ear for the english language is not good enough to hear (or better read) this subtle difference :)
00:51:51 <dons> yeah, there's a a fair bit of context involved, and text strips that all away
00:52:19 <earthy> actually, not so much context but rather more inflection of voice
00:52:41 <dons> yes. that's what's missing. the questioning inflection
00:52:42 <C-Keen> moin
00:53:00 <earthy> the non-textual subtleties of language. good thing we don't have to deal with that in code. :P
00:56:52 <dons> stefanw, have you tried the latest hmp3 code?
00:57:25 * dons needs to think up some Arbitrary MP3 instances.. :)
00:59:19 <stefanw> yes, works fine. I thought about adding a feature that lets you specify directories on the commandline
01:00:11 <stefanw> the *.mp3 files in these directories are then added to the playlist
01:01:36 <shapr> Why would someone portscan me once every five minutes?
01:01:45 <dash> spite?
01:02:02 <shapr> I dunno, it's only ports 135-445, so I wonder if it's a win32 worm.
01:05:18 <dons> stefanw, yes. I want to do that. In fact it's in the TODO :)
01:05:37 <dons>  - Read directory arguments to populate the list
01:07:27 <stefanw> I don't like at my own todo list, why should I look at hmp3's? :)
01:09:52 <dons> hehe
01:10:37 <dons> also, it now has random and loop modes
01:10:41 <tuomov> I constantly get scans on ports 610-612..
01:18:13 <sethk> shapr, why 135-445 meaning win32?  The windows naming ports?
01:25:31 <shapr> PSAD is fun: Scanned udp ports: [1026-1027: 2 packets, Nmap: -sU] inetnum: 221.208.0.0 - 221.212.255.255 descr: CNCGROUP Heilongjiang Province Network
01:25:54 <shapr> Anyway, back to the topic... What's a good way to make Arbitrary instances for Array?
01:36:08 <jlouis> Heh, yet another conjure update
01:36:14 <jlouis> shapr: good question!
01:36:39 <shapr> hiya jlouis
01:36:55 <jlouis> Arbitrary a => Array a is more or less mandatory
01:37:24 <jlouis> then you need to use size to pick sensible values (whatever that is)
01:39:32 <shapr> I tried to make a simple demo, but I get type errors.
01:40:08 <shapr> Meaning I don't have a complete understanding of the problem yet.
01:41:11 <araujo> Hello!!!!
01:41:32 <musasabi> What is the difference of http://www.scannedinavian.org/repos/yi and http://www.cse.unsw.edu.au/~dons/yi ?
01:41:50 <musasabi> They seem to have wastly different number of patches (38 vs 555)
01:42:29 <soysauce> is there a function that allows me to compare consecutive list elements and optionally delete one?
01:42:39 <musasabi> fold
01:42:44 <soysauce> no
01:42:47 <soysauce> I said optionally
01:43:01 <shapr> musasabi: The euro repo is the yi for hIDE
01:43:06 <soysauce> I want something like (a -> a -> Maybe a) -> [a] -> [a]
01:43:12 <soysauce> I'd swear I've seen a function with that type
01:43:22 <flux__> @hoogle (a -> a -> Maybe a) -> [a] -> [a]
01:43:24 <lambdabot> No matches, try a more general search
01:43:29 <musasabi> soysauce: you can do that perfectly well with fold.
01:43:39 <soysauce> musasabi - how? Fold produces a single value
01:43:53 <musasabi> soysauce: which can be a list or a tuple of a list and a value...
01:44:20 <soysauce> yes, a list, but only if I have a list of lists, and I do not
01:44:34 <triplah>  fold w/ lambda
01:44:36 <soysauce> hm
01:44:38 <soysauce> wait, I see
01:44:41 <soysauce> that's a thought
01:44:44 <soysauce> BRB then
01:46:14 <musasabi> @type let map f l = foldr ((:) . f) [] l in map
01:46:16 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
01:46:26 <musasabi> for example.
01:47:11 <araujo> @eval map (\ s -> if even s then Just s else Nothing) [2,3,53,4,6,3,4,6,4]
01:47:12 <lambdabot> [Just 2,Nothing,Nothing,Just 4,Just 6,Nothing,Just 4,Just 6,Just 4]
01:47:22 <araujo> @type map (\ s -> if even s then Just s else Nothing) [2,3,53,4,6,3,4,6,4]
01:47:24 <lambdabot> forall a. (Integral a) => [Maybe a]
01:47:44 <araujo> @type foldr
01:47:45 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
01:49:20 <musasabi> @type (\fun list -> foldr (\elt acc -> maybe acc (:acc) (f elt)) [] list)
01:49:21 <lambdabot> Not in scope: `f'
01:49:29 <musasabi> @type (\fun list -> foldr (\elt acc -> maybe acc (:acc) (fun elt)) [] list)
01:49:30 <lambdabot> forall a a1. (a -> Maybe a1) -> [a] -> [a1]
01:50:17 <musasabi> > (\fun list -> foldr (\elt acc -> maybe acc (:acc) (fun elt)) [] list) (\x -> if even x then Just (x*2) else Nothing) [1,2,3,4,5,6]
01:50:18 <lambdabot> [4,8,12]
01:50:38 <musasabi> and so on.
01:51:08 <wilx> @pl (\fun list -> foldr (\elt acc -> maybe acc (:acc) (fun elt)) [] list) (\x -> if even x then Just (x*2) else Nothing) [1,2,3,4,5,6]
01:51:16 <lambdabot> foldr (flip (ap maybe (flip (:))) . flip (liftM2 if' even (Just . (2 *)))
01:51:16 <lambdabot> Nothing) [] [1, 2, 3, 4, 5, 6]
01:51:26 <araujo> :-)
01:51:31 <araujo> devil!
01:54:59 <musasabi> I think list comprehensions may be the most readable alternative.
02:08:35 <jlouis> shapr: oh, and there is a nice Piece as a FastPackedString in conjure now for you to play SHA1 on ;)
02:14:18 <shapr> cool
02:38:39 <m3ga> @seen ozone
02:38:40 <lambdabot> ozone is in #haskell. I don't know when ozone last spoke.
02:40:53 <shapr> g'day m3ga
02:41:02 <m3ga> howdy
02:41:11 <shapr> How's code?
02:42:25 <Speck> shapr: are you familiar with Ralph Hinze's Web? (mentioned on TheZipper hawiki page)
02:43:00 <shapr> Not really. It's been on my list of things to learn.
02:43:12 <shapr> I spent about five minutes reading about it once, that's it.
02:43:17 <Speck> yeah me too
02:43:24 <shapr> @wiki TheZipper
02:43:25 <lambdabot> http://www.haskell.org/hawiki/TheZipper
02:43:27 <shapr> What do you want to know about it?
02:43:45 <Speck> I'm just wondering if you know if anyone has used it for interesting stuff.
02:44:18 <Speck> like does Proxima use it? or something similar? I believe Hinze is working on Proxima, and talks a lot about structured editors in that paper
02:45:06 <shapr> I don't know. I think I never got the source for Proxima.
02:45:26 <shapr> I think it wasn't available last time I looked. Seems to be available now though: http://www.cs.uu.nl/research/projects/proxima/installation.html
02:45:35 <shapr> So you could grab the source and grep for Web
02:46:07 <Speck> yeah
02:46:44 <shapr> Any ideas for making an Arbitrary instance for Array? :-)
02:46:51 <Speck> it's over my head, but a structured editor mode for yi would be pretty awesome
02:47:14 <Speck> sorry, I don't know what Arbitrary is :(
02:47:30 <shapr> It'd probably take less than an hour to get it into your head.
02:47:59 <shapr> Both the zipper and the web are considered functional pearls. That generally means they're completely obvious once you understand the motivation.
02:48:35 <Speck> yeah, it seems like the web is somehow compatable with type polymorphism in some way
02:48:44 <Speck> I really should revisit the paper more seriously
02:48:52 <shapr> http://archive.cs.uu.nl/pub/RUU/CS/techreps/CS-2001/2001-33.pdf
02:49:19 <shapr> Hinze looks like a nice guy.
02:50:15 <shapr> Oh hey, SPJ's new boxy types paper should be online Thursday. I'm looking forward to that.
02:50:30 <Speck> oooh
02:52:08 <dons> hey jlouis. how's the hacking going?
02:59:37 <shapr> Anyone here using haskell-mode 2.1?
03:19:05 <bojohan> yes. well, i use cvs.
03:45:50 <ndm> @seen dons
03:45:51 <lambdabot> dons is in #haskell-overflow and #haskell. Last spoke 13 minutes and 2
03:45:51 <lambdabot> seconds ago.
03:47:55 <tomshackell> is dons about?
03:49:55 <shapr> bojohan: What do you use cvs for?
03:50:07 <bojohan> haskell-mode
03:50:43 <shapr> oh, ok
03:50:51 <shapr> Any notable changes in 2.1?
03:51:54 <bojohan> changes between the release and today, or between 2.1 and 2.0?
03:52:14 <shapr> e) all of the above?
03:53:34 <shapr> Most 2.0 to 2.1 that I'm interested in.
03:56:41 <bojohan> bug fixes. indentation is supposed to be improved. nothing revolutionary.
04:00:04 <gour> dcoutts_: ping
04:00:52 <dcoutts> gour, pong
04:01:31 <gour> dcoutts: i just saw your msg on haskell list - it is wonderful you will write gtk2hs tutorials :-))
04:01:49 <dcoutts> gour, I didn't say when :-)
04:02:14 <gour> dcoutts: ah you, the tricky one
04:02:55 <gour> dcoutts: so 1st you will publish a blue gtk2hs & opengl book?
04:03:42 <dcoutts> to compliment the red book I suppose
04:03:54 <gour> dcoutts: :-)
04:03:56 <dcoutts> actaully I don't know much about 3D stuff
04:04:15 <gour> until hIDE matures, pida is very nice
04:04:38 <dcoutts> I'm glad the GL extension to Gtk2Hs works but I'm not going to do a lot on it
04:04:39 <gour> i got latest snapshot and one have gvim editor + darcs plugin for record/pull
04:04:52 <dcoutts> @google pida ide
04:04:53 <lambdabot> http://listas.aditel.org/archivos/python-es/2005-September/014627.html
04:05:37 <gour> http://pida.berlios.de/
04:06:06 <gour> and if you saw my msg. from yesterday, 0.3 will be language-independent
04:06:11 <dcoutts> right
04:10:54 <gour> dcoutts: short gnome question..
04:11:58 <shapr> I wanted to ask about a tall gnome myself.
04:12:19 <gour> dcoutts: when i select application from the notification applet on the panel, gnome puts that application in a current workspace, while i'd expect to activate the workspace where it was put, bug or feature?
04:15:45 <triplah> feature i'd expect
04:15:55 <triplah> thats predicatable behaviour imho
04:16:21 <gour> huh, in kde is different and that's logical to me
04:17:04 <triplah> if i click on something i'd expect it to come up on the currently selected desktop
04:17:10 <triplah> thats the point of clicking it normally
04:17:11 <triplah> :P
04:17:27 <gour> i.e. if put application on e.g. workspace-2, i want it to stay there
04:17:50 <triplah> but the act of clicking something almost by definition means bring it to where i am clicking
04:18:40 <gour> and if it triggers some notification event, i'd expect that e.g. worskpace-2 becomes active and not that application gets shifted to e.g. workspace1
04:18:50 <triplah> ahh
04:19:12 <gour> triplah: yes, to bring it where i click and not where i am :-(
04:19:20 <triplah> in e17 it brings it up where iever i am clicking on it
04:19:30 <triplah> ie, where i am currently
04:19:31 <triplah> :P
04:19:40 <triplah> i mean, notification area in e17 is sticky
04:19:47 <triplah> so it follows you
04:19:51 <jlouis> oh, this wasn't ##e17...
04:19:52 <jlouis> hehe
04:19:52 <triplah> so i guess it wouldnt know where it was
04:20:03 <triplah> notification area is a universal container of sorts i'd expect
04:20:21 <gour> but it is not consistent behaviour
04:20:21 <triplah> not ##gnome either
04:20:23 <triplah> ;)
04:20:45 <triplah> gour: it is in every WM i've used. admittedly not many
04:20:51 <triplah> i've never used kde to any great length
04:20:55 <triplah> or gnome for that matter
04:21:09 <gour> selecting application from the window list activates application in its own desktop
04:21:25 <gour> so why notification does the other thing?
04:22:27 <gour> which completey defeats the purpose of having notification window 'cause after reacting on event one has to re-arrange applications again in their own desktops :-(
04:22:45 <gour> let me go barking in #gnome
04:23:06 <triplah> ehe
04:23:35 <triplah> almost tempted to join to see the fireworks
04:23:36 <triplah> :D
04:23:51 <gour> triplah: well the ticket is free :-)
04:24:08 <triplah> aha
04:26:11 <jlouis>  /j #gnome; CTWM rocks your world; /p
04:26:29 <jlouis> I would be hit with an ICBM in less than 0.1 sec
04:26:32 <triplah> ehe
04:36:09 * shapr tries to find his way through the maze of type errors to an Arbitrary instance.
04:37:27 <bojohan> god natt, shapr
04:37:32 <shapr> sleeping so early?
04:37:41 <shapr> g'n√§tt
04:38:13 <kzm> Hi all!
04:38:27 <shapr> hiya ketil
04:38:33 <kzm> I read some reviews of mediawiki on their site, and the reviews are kinda negative.
04:39:15 <shapr> I'd rather use Flippi anyway.
04:39:28 <shapr> Since it's written in Haskell, we can always tell people to submit patches.
04:39:41 <shapr> And we can easily mold it to our needs as well.
04:39:49 <kzm> I thought I should set one up, perhaps I should look at Flippi?
04:39:52 <shapr> It's just not as much fun to hack on Moin or other non-haskell wiki.
04:39:55 <shapr> Sure, try it.
04:40:13 * kzm probably will.
04:40:41 <kzm> Do you realize we're building up a whole software ecology in Haskell?
04:40:49 <kzm> It's not just compilers anymore :-)
04:40:50 <shapr> I host the Flippi darcs repo, and I've been number one beta tester for awhile, so I can help you if you have problems.
04:40:54 <shapr> Yeah, I like that.
04:41:33 <kzm> We should implement our own network protocols, and just cut the umbilical to the rest of the plebes.
04:41:41 <shapr> um
04:41:54 <shapr> Have you seen my latest blog entries?
04:42:08 <kzm> brb
04:42:25 <shapr> I got the pure Haskell TCP/IP stack talking to the rest of the world via TUN/TAP :-)
04:42:58 <eivuokko> Cool
04:43:40 <shapr> Now I'm working on step two of my evil plan... I'll put up results when I get them.
04:47:59 <musasabi> shapr: how was performance?
04:48:47 * kzm is back from his phone call.
04:48:56 <kzm> shapr: immensely cool, of course :-)
04:49:06 <kzm> I guess I should read more blogs...
04:49:38 <kzm> IHopeFlippiDoesn'tInsistOnCamelCasedWords?IFindThemReallyAnnoying.
04:50:06 <musasabi> kzm: that is about ten lines to change I think.\
04:51:00 * kzm grins.
04:53:21 <shapr> musasabi: Haven't tested performance at all.
04:53:26 <Speck> are there any examples of practical usage of Oleg's Zipper in Haskell? -- outside the papers themselves
04:53:39 <Speck> and of course ZFS
04:53:55 * musasabi tried and failed (then again I wanted something twisted)
04:54:05 <shapr> I have an interesting plan for Oleg's Zipper, I think it's perfect for the built-in 'version control' for a Data.Graph based web dev framework in Haskell.
04:54:17 <shapr> musasabi: Using Zipper or House Stack?
04:54:30 <kzm> Perhaps darcs should have it's own URL type?  "click here to 'get'"?
04:54:32 <musasabi> shapr: Zipper (for HList like structures + some extra complications)
04:54:47 <musasabi> Also symbolic links are non-trivial to do in a zipper.
04:54:49 <shapr> Cale: Where did you find these QC extensions on the wiki? Do you know who wrote them?
04:54:57 <musasabi> Although Oleg had some ideas for those too.
04:55:33 <Itkovian> @hoogle [a] -> [a] -> [[a]]
04:55:34 <lambdabot> Data.List.inits :: [a] -> [[a]]
04:55:34 <lambdabot> Data.List.tails :: [a] -> [[a]]
04:56:15 <shapr> hiya puthrie_canticz
04:56:50 <shapr> puthrie_canticz: Are you learning Haskell?
04:57:39 <shapr> Guess not.
04:58:28 <kzm> Flippi thing: how is darcs going to like it if I remove all the ^Ms that are so liberally sprinkled over the sources?
04:58:41 <kzm> Would that be considered bad form?
05:00:16 <shapr> kzm: Are you using emacs?
05:00:42 <shapr> If so , you can just change the top line of those files to  {- -*- mode: haskell; coding: utf-8-dos -*-
05:03:15 <kzm> Okay, I'll do that instead, then.  I already found a documentation bug :-)
05:03:34 <kzm> (dataDirectory is defined in Config.hs, not PageIO.hs)
05:03:54 <shapr> You may want to pull the FLM repository and see if I've fixed anything there.
05:03:58 * kzm is beaming with self-satisfaction.
05:04:04 <kzm> FLM?
05:04:10 <shapr> Fermat's Last Margin
05:05:06 <tic|school> How do I convert an Integer to Int?
05:05:23 <shapr> You can get the not-quite-finished version of FLM from "darcs get http://www.scannedinavian.org/~shae/FLM/"
05:05:33 <shapr> tic|school: fromIntegral should do it.
05:05:42 <kzm> FLM is based on Flippi?
05:05:45 <shapr> Yup
05:05:48 <mauke> @type fromIntegral
05:05:49 <lambdabot> forall b a. (Num b, Integral a) => a -> b
05:06:18 <kzm> Should I use that instead, then?  Why the branch?  Don't you back propagate bugvfixes?
05:06:18 <shapr> I have a bunch of local changes for FLM that I haven't recorded and pushed yet.
05:06:24 <kzm> Okay :-)
05:06:58 <shapr> Yeah, but some of it isn't really bugfixes but entirely new code. Also, Philippa has high code standards, and FLM is still a first hack.
05:07:03 <wilx> Hmm, who had that Gopher crawler project?
05:07:16 <shapr> So some of the changes will be cleaned up and propagated back into Flippi proper, once FLM works.
05:07:34 <tic|school> shapshapr, no.
05:08:05 <shapr> > (fromIntegral (1 :: Integer) :: Int)
05:08:06 <lambdabot> 1
05:08:11 <shapr> Seems to work.
05:08:15 <tic|school> shapr, I want to do this: x' = anInt *  cos aDouble
05:08:28 <tic|school> shapr, Point Int Int; Point x'
05:08:33 <tic|school> (and y')
05:08:39 <shapr> ?
05:10:00 <tic|school> ultimately:
05:10:05 <tic|school> http://rafb.net/paste/results/PZYJBP76.html
05:10:14 <tic|school> oops
05:10:19 <tic|school> data Point = Point Int Int
05:10:55 <tic|school> I just can't figure out how to do it.
05:11:34 <tic|school> "no instance of Floating Int"
05:11:44 <shapr> @type (*)
05:11:44 <lambdabot> forall a. (Num a) => a -> a -> a
05:11:49 <norpan> tic|school: fromIntegral is your friend
05:11:50 <tic|school> Right.
05:11:51 <shapr> @type (cos)
05:11:52 <lambdabot> forall a. (Floating a) => a -> a
05:11:59 <shapr> So, cos wants a Floating
05:12:08 <tic|school> Yes...
05:12:17 <shapr> How do you get a Floating?
05:12:35 <norpan> what do you have?
05:12:41 <kzm> shapr - I think the FLM concept is great.  In a sense, it is a return to medieval times, where books were glossed (i.e. had notes added to the margins, improving and elaborating on the contents)
05:12:51 <tic|school> same thing, still....
05:13:02 <shapr> You could look at the typeclass hierarchy and see what classes are more general than Floating, and see if you can cast to one of those.
05:13:22 <shapr> kzm: Yeah, but the difference is that this is instantly syndicated improvements.
05:13:22 <norpan> a Double is a Floating
05:13:28 <norpan> which is probably what you want
05:14:03 <tic|school> http://rafb.net/paste/results/sXcIyL91.html
05:14:05 <mauke> > fromIntegral (2 :: Int) * cos 0
05:14:07 <JKnecht> where would one look at the typeclass hierarchy?
05:14:07 <lambdabot> 2.0
05:14:13 <Speck> shapr, did you ever turn subcontinuations into threads?
05:14:44 <kzm> ...which means I need to read more about it, I guess :-)
05:14:52 <norpan> tic|school: declare data Point = Point Double Double instead
05:14:59 <norpan> Int seems to be a very bad choice
05:15:11 <tic|school> norpan, I would, unless that was the standard type of wxHasklel.
05:15:32 <shapr> Speck: No?
05:15:49 <Speck> shapr: saw an old blog entry of yours where you mentioned it
05:15:52 <tic|school> norpan, it seems like a bad idea to have a toWxPoint everywhere
05:15:52 <norpan> I see, then you need to cast back to Int from Double by doing "round" or something like that
05:16:10 <norpan> so, Point (round x') (round y')
05:16:11 <tic|school> norpan, ! I'll try that.
05:16:50 <norpan> of course, you would get better error messages if you declare the type of z' and y'
05:16:54 <norpan> x'
05:17:00 <shapr> Speck: Which entry?
05:17:03 <norpan> type inference can sometimes be misleading
05:17:19 <kzm> At least it (flippi) was easy to install :-)
05:17:19 <tic|school> norpan, where'd I do that? let x' = .... :: Int?
05:17:29 <Speck> shapr: http://www.scannedinavian.com/2005-04-30.html
05:17:39 <norpan> tic|school: yes
05:18:16 <tic|school> norpan, didn't know I could do that... But :: Int is probably not the right type, though?
05:18:22 <norpan> no, Double
05:18:26 <tic|school> *nod*
05:18:43 <shapr> Speck: Oh, I never got back to look at that. If you find out, I want to know!
05:19:10 <norpan> or Float
05:19:47 <norpan> depends on what precision you want in the calculation
05:20:54 <shapr> That's one reason I keep a blog, ideas slide in and out of my head non-stop. Most of them never come back again, but if I write them down, sometimes I get back to them.
05:20:57 <tomshackell> @seen dons
05:20:57 <lambdabot> dons is in #haskell-overflow and #haskell. Last spoke 1 hour, 48 minutes
05:20:57 <lambdabot> and 8 seconds ago.
05:21:32 <ProfTeggy> Hi all.
05:21:49 <shapr> hiya ProfTeggy, you got mentioned on LtU again.
05:21:59 <ProfTeggy> Ugh
05:22:07 <shapr> Tired of your fame? :-)
05:22:25 <tic|school> norpan, doesn't matter much,  Ithink.
05:23:15 <norpan> tic|school: depends mostly on how big your integers are
05:23:21 <tic|school> norpan, "smal"
05:23:23 <shapr> They raise an interesting question, is there really a difference between fold and aggregate? They think so, but I'm not sure I believe it yet. I'll have to read the background material.
05:23:27 <tic|school> Ugh, need gvim.
05:23:30 <ProfTeggy> shapr, well... it is a two-sided coin.  One fellow poster was bickering over a sloppy definition in my PhD thesis for example ;-)
05:23:31 <tic|school> and Less lagging Nomad. )
05:23:33 <tic|school> :)
05:23:35 <ndm> shapr, how well backed up in the haskell wiki?
05:23:43 <shapr> ndm: eh?
05:24:01 <kzm> shapr - I tried to add an emacs mode thingy, but it didn't work.  I'm using Xemacs, but surely it's the same?
05:24:11 <ndm> now all the yhc docs are in the wiki, we were just wondering how much backup of that there is
05:24:19 <shapr> ndm: I think all of the previous versions of a page hang around until I manually clean them up, but I'm not sure.
05:24:20 <ndm> if its work backing it up as well ourselves
05:24:21 <norpan> normally, i would say it's a bad idea to use integers here, better create your own point type that uses Double and convert to integers when you want to display them
05:24:31 <shapr> ndm: It's *always* worth keeping your own backup of anything.
05:24:35 <ndm> what if the machine its running on dies?
05:24:52 <shapr> I don't make my own off-site backups of the content. Maybe I should.
05:24:52 <tic|school> norpan, agreed. In this case, however, precision doesn't matter.
05:25:15 <shapr> ndm: When I got the wiki job, it had just about nothing in the way of useful content.
05:25:37 <ndm> hehe, i know - we're very grateful for your efforts on the wiki!
05:25:39 <norpan> tic|school: in that case, sin x = x is an approximation that is VERY fast :)
05:25:47 <shapr> thanks :-)
05:26:02 <shapr> Just saying that times have changed. Now there's content and I hadn't even considered backing it up.
05:26:05 <ndm> i was reading the making haskell more open stuff on teh list, its simple - wiki it!
05:26:16 <shapr> I really do want to freeze the current wiki and make a new explicitly licensed wiki instance.
05:26:28 <ndm> shapr, sooner is better for that
05:26:30 <shapr> I also really want to use Flippi because any Haskeller can extend it then.
05:26:36 <shapr> Yeah, true.
05:26:41 <ndm> although i'd be tempted to just relicense it all, and see who complains :)
05:26:53 <shapr> But, we don't technically have the license or copyright at all.
05:27:02 <tic|school> norpan, hehe. Not _that_ small :)
05:27:04 <shapr> Only the author does, and how do you find them?
05:27:12 <ndm> give up - see if anyone complains
05:27:22 <ndm> its not a totally legally valid stance, but its more fun ;)
05:27:23 <shapr> kzm: emacs mode for what?
05:27:51 <astrolabe> the problem with that is that you will always have the license issue hanging over you.
05:27:56 <shapr> kzm: Oh, yes, it should work, once you've changed the top line to have those funny chars, revert the buffer.
05:28:13 <shapr> kzm: Or close and open again.
05:28:37 <shapr> Everything between the two -*- marks works like Local Variables:
05:28:41 <ndm> i put a note on teh yhc page that all edits under Yhc/ must be released under a BSD license
05:28:47 <shapr> Works for me.
05:28:53 <tic|school> Hm. do I need to align 'let' and 'in'?
05:29:16 <shapr> I probably should freeze the hawiki and create a new one ... maybe just wiki/ ?
05:29:39 <shapr> Flippi doesn't have access control yet, that's the only real drawback.
05:29:48 <shapr> But, it's written in Haskell, so it's easy to change.
05:30:22 <ndm> start with the MoinMoin, move to flippi when its ready
05:30:35 <ndm> would be my suggestion - rushing a project to its first massive use is a big risk :)
05:30:36 <astrolabe> automatic spam recognition would be nice
05:30:44 <shapr> Yeah, but.. will Flippi ever be ready if I don't install it and let people complain? :-)
05:30:46 <CosmicRay> autrijus: I seem to recall that you have GHC 6.4.1 for AIX5 built somewhere, but I can't find the package anywhere
05:30:49 <CosmicRay> autrijus: can you url me?
05:31:59 <shapr> CosmicRay: http://64.233.183.104/search?q=cache:AGMaa6lj50cJ:tunes.org/~nef/logs/haskell/05.01.10+autrijus+ghc+aix&hl=en
05:32:20 <kzm> Here's my installation:  http://www.ii.uib.no/~ketil/cgi-bin/flippi.cgi :-)
05:32:25 * boegel is enjoying the work on his php script to keep track of his papers
05:32:39 <CosmicRay> shapr: that appears to refer to 6.2.2
05:32:45 <shapr> CosmicRay: oh
05:32:47 <shapr> kzm: cool!
05:33:06 <CosmicRay> ah, he built 6.4.
05:33:09 <CosmicRay> I had built 6.2.1.
05:33:28 <CosmicRay> apparently there is some serious FUBAR in date arithmetic in 6.2.1 on AIX.  I am hoping it is better in 6.4.
05:33:41 <CosmicRay> things are off by *days* there, compared to the correct results on my linux box.
05:34:43 <shapr> yow
05:34:50 <shapr> kzm: Have you seen the FLM demo? http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=TestMargin
05:34:58 <kzm> shapr - well, it was the simplest possible software installation. :-)
05:35:38 <kzm> No, but I'll take a look.
05:36:40 * kzm is puzzled.  "You got it"?
05:37:40 <astrolabe> shapr: That looks cool and useful.  Any reason it's restricted to research papers?
05:38:02 * kzm checks to see if he is playing tag, and goes on to check for various unmentionable diseases.
05:38:17 <kzm> Perhaps something to do with my proxy?
05:39:36 <shapr> astrolabe: It's not restricted to research papers, just pdf and ps files at the moment. I want to use it for research because that's what I read, that's the comments I want to see.
05:40:32 <shapr> kzm: Yeah, "You got it." means that the images, wiki pages, etc were all generated correctly. It's a quote from The Crystal Method - Vegas - High Roller
05:40:55 <astrolabe> shapr: I see.  I was just remembering Hamming:  Make your ideas as general as possible.
05:40:55 <shapr> hoi sowhat
05:41:02 <shapr> astrolabe: Yeah, good point.
05:41:20 <sowhat> shapr: hi
05:41:28 <shapr> sowhat: How's code?
05:41:42 <shapr> I did find that book for less than 100 pounds sterling, but now I don't really have the spare cash. :-/
05:41:51 * shapr starts a "buy this cool book for shapr fund"
05:42:03 <shapr> Er wait, maybe I do have the cash!
05:42:11 * shapr remembers having random unexpeced paypal cash
05:42:14 <sowhat> shapr: its ok
05:42:47 <shapr> Just ok? C'mon, you could be writing PHP for a living ;-)
05:44:24 <kzm> Hmm... okay, so I can do [<uglyCapsPattern> | readable page name ]
05:48:38 * kzm was going to ask for a name, but answered his own question.
05:48:41 <kzm> :-)
05:50:45 <kzm> Parsec: with my keyboard I thee worship!
05:51:40 <rafl> dons: I've got an hs-plugins error on alpha for you: http://nopaste.debianforum.de/1610
05:52:33 <sowhat> shapr: yeah, just ok, hoping to finish it. But uhm.. do we know each other? (hoping not to offend anyone :o :) )
05:56:39 <kzm> shapr - I made a "readablePageName" alternative to uglyBuglyCasePattern, and specified it in Config, and it works.
05:57:06 <kzm> Well, almost: I have to quote the spaces in the URL (at least).  Working on that :-)
06:03:42 <xerox> WOOOOO
06:03:48 * xerox got paid !!
06:03:54 <xerox> Beer for everyone!
06:04:00 <Speck> oh boy!
06:04:08 <neologism> shit.. on my univ they canceled functional programming course for lack of interest among students
06:04:20 <xerox> Happy happy joy jow!
06:05:28 * Speck wants a hefeweizen
06:08:03 <boegel> yo xerox
06:08:26 <boegel> cool ! how much did you get eventually ?
06:08:52 <xerox> 3150$
06:08:54 <boegel> xerox: can you get me one of these ? -> http://www.apple.com/powerbook/
06:09:04 <xerox> boegel: I'm going to get one
06:09:06 <boegel> it's only $1499 ^_^
06:09:07 <xerox> arf arf.
06:09:14 <boegel> xerox: oh ! jealous !
06:09:17 <xerox> !
06:09:23 <kzm> So get two, and send one to boegel? :-)
06:09:31 <xerox> 15", 1Gb di RAM, 100Gb 7200rpm hd :-D
06:09:55 <xerox> Anyway, time to digitalize the money :-)
06:10:14 <boegel> 7200 ? hmm, that'll drink power like crazy
06:10:24 <boegel> I'd go for a 5600 orso
06:10:26 <xerox> I'm still in doubt about it
06:10:32 <xerox> I see
06:10:39 <xerox> We'll talk about it :-)
06:11:02 <xerox> BBL!
06:11:05 * xerox &
06:11:06 <boegel> it's 5400, sorry :)
06:11:09 <boegel> bye !
06:11:58 <kzm> How do .boot files work?
06:12:24 <kzm> (I suspect I shouldn't record changes to them, or should I?)
06:12:26 <boegel> shapr: ping !
06:15:18 <shapr> pong
06:15:24 <shapr> I love unicycling.
06:16:04 <kzm> Some small mods to Flippi available - darcs pull'able, that is -- from http://www.ii.uib.no/~ketil/Flippi
06:16:35 <kzm> (Added Makefile, defined readablePagePattern as an alternative to uglyCapsPattern
06:16:37 <kzm> )
06:17:07 <boegel> shapr: how do you make png's out of pdf's in your FLM ?
06:17:29 <kzm> There are a /few/ other features missing, but I think they'll have to wait until tomorrow. :-)
06:17:48 <shapr> sowhat: I don't think we know each other directly, but I try to greet people who are somewhat new to #haskell. My google-fu is good enough to guess that the code you're working on is Helium program analysis.
06:18:35 <shapr> sowhat: Hi, my name is Shae Erisson. I'm bouncer and disorganizer of #haskell, the Haskell Wiki, The Monad.Reader, scannedinavian.{org,com,net} and probably some other stuff that I forgot.
06:18:45 <shapr> boegel: convert from imagemagick
06:21:28 <boegel> shapr: okay, thanks :)
06:21:31 <mauke> what's a good name for a parsing library?
06:21:47 <boegel> ParseThis!
06:22:09 <mauke> not good enough
06:22:19 <boegel> :(
06:22:37 <boegel> HAPA
06:22:48 <boegel> HAskellPArser
06:23:57 <mauke> ok, I want an *awesome* name
06:24:09 <mauke> HaskellParser is boring
06:25:07 <boegel> mauke: find it yourself then, I can't think of an awesome name
06:25:20 <boegel> and if I would, I'd probably keep it for myself
06:26:02 <sowhat> shapr: cool! :) thanks for this warm welcome. My google-fu reveiled similar information about you as well :D
06:26:06 <JKnecht> I've got dibs on 'Eddie' :)
06:34:09 <JKnecht> ( http://www.wirtznet.net/alaskaride/images/haskell.jpg )
06:38:50 <jlouis> mauke: DevourToken!
06:39:02 <jlouis> or just Devour
06:39:26 <jlouis> ``Devour is a Haskell Parser consuming Tokens and outputting ASTs''
06:40:58 <eivuokko> ..consuming juicy Tokens and leaving AST for the dogs.
06:43:03 <JKnecht> (also: http://en.wikipedia.org/wiki/Eddie_Haskell )
06:45:42 <shapr> sowhat: Welcome to #haskell, if you have any questions, feel free to ask!
06:45:51 <shapr> And now, I have to focus on paying work.
06:47:12 <JKnecht> note the wiki comment about 'currying favor'
06:47:31 <marcot> CosmicRay: hello..
06:47:39 <marcot> CosmicRay: have you uploaded gtk2hs 0.9.10?
06:55:43 <neurogeek> Hello.. where's the best place to start with haskell?? any good tutorials you guys recommend??
06:57:10 <Cale> neurogeek: I like "Yet Another Haskell Tutorial"
06:57:27 <Cale> Though it's a little incomplete, it's a decent place to start
06:58:02 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
06:59:04 <neologism> I read a great book about haskell
06:59:21 <neologism> but all I remember is that its cover was violet ;)
06:59:56 <ndm> @seen dons
06:59:57 <lambdabot> dons is in #haskell-overflow and #haskell. Last spoke 3 hours, 27 minutes
06:59:57 <lambdabot> and 7 seconds ago.
07:04:29 <ndm> is there anywhere that has a list of all the haskell keywords, and their meanings?
07:04:32 <ProfTeggy> neologism: The Craft of Functional Programming, Simon Thompson
07:05:44 <neurogeek> Cale, thanks.. i'll give it a try
07:07:07 <Cale> neurogeek: also, I recall that "Two Dozen Short Lessons" was useful.
07:07:58 <Cale> Mostly I learned by doing small exercises collected from various tutorials and places online, as well as whevener someone asked a question in here :)
07:08:27 <SamB> @where+ ZMachine http://naesten.dyndns.org:8080/repos/ZMachine
07:08:28 <lambdabot> zmachine ~> http://naesten.dyndns.org:8080/repos/ZMachine
07:09:28 <neologism> ProfTeggy: yes ;)
07:09:40 <neologism> ProfTeggy: how did you know?
07:10:17 <ProfTeggy> neologism, it's on my shelf ;-)
07:10:48 <SamB> huh, where did shapr go
07:11:03 <neologism> ProfTeggy: :)
07:11:04 <SamB> I was just going to say that he is an excelent disorganizer
07:11:15 <Cale> what did he do?
07:11:48 <SamB> <shapr> sowhat: Hi, my name is Shae Erisson. I'm bouncer and disorganizer of #haskell, the Haskell Wiki, The Monad.Reader, scannedinavian.{org,com,net} and probably some other stuff that I forgot.
07:12:41 <ProfTeggy> shapr seems to be one of those guys with > 24 hours/day at hand.
07:13:12 <ProfTeggy> I wonder how they do it... simply rewing four hours @ 23:59?
07:13:18 <ProfTeggy> s/rewing/rewind/
07:15:23 <SamB> well, he doesn't spend more than 24 hours a day on IRC at least
07:18:21 <boegel> SamB: where did you get that ? wiki ?
07:19:16 * boegel leaves for home
07:19:20 <boegel> g'bye everybody !
07:19:36 <musasabi> Has anyone implemented a Tree with STM?
07:19:53 <musasabi> Seems quite hard actually.
07:20:40 <musasabi> As one does not want structure changes to make otherwise non-conflicting transactions retry.
07:20:43 <SamB> boegel: he said it on the channel
07:20:45 <Cale> musasabi: in what sense? A tree which uses TVars to link the nodes?
07:20:48 <SamB> look in todays logs
07:20:59 <SamB> yesterdays if not todays, dunno where the cutoff is
07:21:23 <musasabi> Cale: How to balance that thing without making physical (balancing) updates cause retries.
07:21:41 <Cale> Oh, a balanced tree
07:22:05 <musasabi> hmm I could use randomization to balance things - it could solve things.
07:22:59 <musasabi> then the tree would be probably balanced and overlapping writes could be minimized :-)
07:23:00 <SamB> musasabi: what are you wanting a tree for?
07:23:04 <SamB> did you work on conjure?
07:23:34 <musasabi> SamB: yes, although not yet ready to push code out.
07:24:09 <musasabi> SamB: to act as a cache for pages (think databases).
07:24:21 <SamB> what sort of pages?
07:25:33 <musasabi> SamB: Currently BinHandles to things in memory + some extra information.
07:25:50 <SamB> musasabi: whats it for?
07:26:07 <SamB> I mean, what project? conjure?
07:26:36 <musasabi> SamB: I am trying to test what STM would cause for a small database implementation.
07:26:46 <musasabi> i.e. going with it instead of the usual locks.
07:26:52 <SamB> hmm
07:27:13 <SamB> how are you trying to do it?
07:27:39 <musasabi> well I am thinking that STM is a lot like optimistic concurrency control.
07:28:08 <SamB> like, what is the type of your tree so far?
07:28:11 <musasabi> just modify things + log and STM will retry if there are conflicts (of course I doubt it will be this simple)
07:29:02 <musasabi> SamB: Currently I am using "TVar (Map.Map PageId Page)" which has some serious problems.
07:29:32 <SamB> oh
07:30:10 <SamB> what are those problems exactly?
07:30:15 <musasabi> Either a data TTree k v = TNull | TNode RandomValue k v (TTree k v) (TTree k v) or a hashtable converted to STM should do much better.
07:31:06 <musasabi> SamB: too large granuality - that is unrelated things mess eachother up.
07:31:13 <SamB> ah, right
07:31:25 <SamB> hmm, but what do you mean by "unrelated"?
07:31:55 <SamB> and why is there no TVar in the definition of TTree?
07:32:01 <musasabi> SamB: any two transactions adding a Page to the cache can conflict with each other.
07:32:16 <SamB> musasabi: isn't that normal?
07:33:04 <musasabi> make that data TTree' k v = TNull | TNode RandomValue k v (TTree k v) (TTree k v); type TTree k v = TVar (TTree' k v)
07:33:22 <SamB> what is the randomvalue for
07:33:32 <SamB> and why is that better than Map?
07:33:34 <musasabi> SamB: if they insert completely different pages.
07:34:32 <musasabi> SamB: Think about this - t1 inserts a new page p1 to the cache and t2 inserts p2 to the cache. They should only conflict if p1==p2.
07:35:06 <musasabi> SamB: A random value we use to balance the tree, otherwise we would need rotations to keep it in balance which also causes contention.
07:36:54 <musasabi> SamB: If transaction t1 writes the cache and aborts not all transactions that have read the page-cache since it modified the cache should abort. Thus we propagate the TVars to inner levels.
07:38:41 <reddi> why does this not work? > map "hugo" == ["hugo","leo"]
07:39:05 <basti_>  reddi because "hugo" is not a function
07:39:38 <musasabi> > map ("hugo" ==) ["hugo","leo"]
07:39:39 <lambdabot> [True,False]
07:41:33 <SamB> oh, now I see what you have there.
07:41:58 <SamB> what are you going to do about deleting pages, though?
07:43:38 <musasabi> Not yet entirely sure, LRU-policy with IORefs and unsafeIOtoST probably.
07:45:37 * SamB can't help but wonder if it wouldn't make more sense to have one thread manage the cache and others communicate with it via channels
07:47:09 <SamB> well, probably just one channel would be enough...
07:48:18 <musasabi> Yes, that would work at least with a Chan + unsafeIoToSt
07:48:53 <musasabi> The problem with TChans are the abort + repeat patterns and what causes a cascade and what not.
07:49:07 <SamB> huh
07:50:36 <jlouis> oy SamB
07:50:54 <xerox> Yo.
07:50:58 <jlouis> yo xerox
07:51:29 <xerox> It takes TWO MONTHS to get the cash out of a check, damn them.
07:51:59 <SamB> jlouis: hello
07:55:33 <Cale> xerox: wow, which cheque?
07:55:37 <Cale> the google one?
07:55:42 <xerox> Google's one! :-D
07:55:46 <xerox> It arrived today!
07:55:49 <Cale> :)
07:56:02 <Cale> Where did you deposit it?
07:56:03 <xerox> No pbook for christmas, though :-)
07:56:37 <xerox> The postal services here started doing "banks" for cheap prices, so I got an account there :-)
07:56:48 <Cale> ah
07:57:18 <ibid> the postal service used to be a national bank here
07:58:11 <xerox> In fact banks are probably faster in this sense, but they get much higher taxes.
08:14:10 <musasabi> Is there a way to support both old and new versions of Cabal for a package with hooks?
08:14:36 <musasabi> They have different types and there seems to be no foolproof way of using cpp in Setup.lhs...
08:23:59 <CosmicRay> autrijus: ping
08:24:10 <ndm> @seen shapr
08:24:10 <lambdabot> I saw shapr leaving #haskell-blah 51 minutes and 58 seconds ago.
08:24:12 <CosmicRay> autrijus: your AIX 5.1 ghc 6.4 package isn't working for me.  it's dying looking for stdint.h
08:24:15 <CosmicRay> @seen autrijus
08:24:16 <lambdabot> autrijus is in #haskell. I don't know when autrijus last spoke.
08:35:52 <reddi> is there a way to use div for float?
08:38:49 <jlouis> @type div
08:38:50 <lambdabot> forall a. (Integral a) => a -> a -> a
08:38:57 <jlouis> @type fromIntegral
08:38:58 <lambdabot> forall b a. (Num b, Integral a) => a -> b
08:39:07 <jlouis> bah
08:39:09 <jlouis> me forgetting
08:39:28 <SamB> reddi: what do you mean?
08:39:37 <reddi> div 5 2.4
08:39:38 <reddi> .e.g
08:39:47 <jlouis> that doesn't make sense
08:39:57 <jlouis> 5 / 2.4 does though
08:39:58 <musasabi> > 5 / 2.4
08:39:59 <lambdabot> 2.0833333333333335
08:40:02 <reddi> LOL
08:40:06 <reddi> ok, that is better
08:40:07 <reddi> ;-)
08:40:15 <SamB> reddi: hehe
08:40:18 <jlouis> div only works for Integral types
08:41:00 <jlouis> > 5 `div` 2
08:41:02 <lambdabot> 2
08:41:21 <jlouis> For the integers, its integral division (ie, throw the remainder away)
08:46:38 <paolino> good evening
08:46:50 <xerox> PAOLO!
08:46:56 <xerox> Vieni di la :-)
08:47:10 <paolino> aspe mo arrivo
08:47:14 <paolino> class A a where
08:47:15 <paolino>   id'::a
08:47:15 <paolino> type B a = A (A a)
08:47:36 <paolino> this is panicing ghci  -fglasgow-exts
08:47:50 <jlouis> ghci --version?
08:47:53 <xerox> Su su su su :-)
08:48:25 <paolino> jlouis, 6.4
08:48:46 <paolino> the impossible happened
08:49:05 <Oejet> Yay, I have a user for my Bzip2-binding!
08:49:33 <jlouis> hahaha
08:49:37 <jlouis> cool Oejet
08:50:50 * basti_ laughs
08:51:00 <Oejet> He couldn't compile it on Windows, but realized that GHC doesn't come with Posix.IO-libraries on that system.
08:52:02 <paolino> is there something obviously wrong in what I'm doing ?
08:53:39 <reddi> Instance of Fractional Int required for definition of erfolgreich_q
08:53:42 <reddi> what does this mean?
08:54:08 <mauke> your function tries to do fractional stuff with ints
08:54:23 <reddi> fractional means?
08:54:25 <reddi> is that english?
08:54:45 <reddi> oh...
08:54:48 <reddi> i see
08:54:50 <Cale> "Fractional" is an English word :)
08:55:15 <Cale> Though I think "Field" would be a better name for the class. :)
08:57:38 <Oejet> Aren't some of the Posix library implemented in GHC for Windows?
09:01:15 <Cale> I hope that doesn't continue
09:02:02 --- mode: ChanServ set +o Igloo
09:02:26 --- mode: Igloo set +bcm #haskell!*@*
09:02:33 <Igloo> Doh
09:02:53 --- mode: Igloo set -cmb #haskell!*@*
09:02:55 <mauke> heh
09:02:59 --- mode: Igloo set +b cmeme!*@*
09:03:46 --- mode: Igloo set -o Igloo
09:08:33 <musasabi> @seen shapr
09:08:33 <lambdabot> I saw shapr leaving #haskell-blah 1 hour, 36 minutes and 21 seconds ago.
09:08:40 <musasabi> blah
09:10:38 <basti_> back
09:24:50 <takuan> is it possible to have a function with a state in Haskell?
09:25:14 <basti_> yes definitely
09:25:22 <basti_> what kind of state are you looking for?
09:25:37 <xerox> Is it possible for a newbie to don't get basti's help? No! :-)
09:26:12 <basti_> :D
09:26:17 * basti_ has a forall quantor
09:26:27 <SamB> what are some of the best intermediate-to-advanced Haskell books? I'm especially interested in DSELs/combinator libraries
09:26:31 <soysauce> s/don't/not/ :p
09:26:54 <takuan> well, I just want my function to remember a vector since the last call
09:27:40 <SamB> SOE sounds good, but I was wondering about others.
09:28:04 <SamB> someone suggested the Fun of Programming, but it doesn't seem to be available here...
09:28:07 <neologism> takuan: why do you want this?
09:28:17 <takuan> good question
09:28:19 <takuan> f
09:28:27 <takuan> the function is a generator
09:28:45 <takuan> of course, i could make it into generating a list
09:28:57 <takuan> and then use take 100 list etc.
09:29:05 <basti_> takuan: what would be the advantages of the latter approach?
09:29:10 <SamB> takuan: why would you need to take 100 list?
09:29:25 <takuan> but the thing is that for some reason, sometimes we just want the first 20
09:29:28 <jlouis> SamB: Purely Functional Datastructures, Chris Okasaki. SML, but with Haskell examples in the back. Marvelous
09:29:29 <takuan> then get another 100
09:29:30 <takuan> etc.
09:29:33 <basti_> hmm
09:29:39 <basti_> ever thought about some kind of fold?
09:29:41 <SamB> anyway, the way we *do* iterators and generators is lists
09:29:51 <xerox> jlouis: indeed!
09:29:56 <SamB> that is, our generators/iterators *are* lists
09:30:07 <takuan> yup
09:30:17 <basti_> takuan: fold has some sort of state.
09:30:17 <takuan> got the picture, but once again
09:30:20 <takuan> is it possible?
09:30:24 <Frederick> yo SamB I got thebook Im reading it now
09:30:24 <basti_> certainly
09:30:33 <basti_> there are different ways of keeping state
09:30:49 <basti_> first, the "virtual machine" has some sort of state
09:30:50 <SamB> takuan: err, but more to the point, is it meaningful?
09:31:03 <basti_> you can reach around variables, and they can "keep" for quite a time
09:31:08 <SamB> this idea of "next call"... it doesn't really mean anything usefull in Haskell
09:31:10 <basti_> arbitary long
09:31:23 <basti_> then there is "low level state" of your memory etc.
09:31:51 <basti_> or a rather more abstract "running state" of some computation you don't want to fold, for some reason
09:32:08 <SamB> jlouis: yeah, I was going to put that one down too.
09:32:12 <basti_> like you were addressing takuan 
09:32:23 <basti_> ever heard about "monoids"?
09:32:23 <jlouis> you don't have state per se. You pass the values you wish to keep along to another function
09:32:29 * basti_ plays a minor chord
09:32:58 * basti_ then has it vanish into a faint xylophone melody
09:33:20 <xerox> Monads!
09:33:25 <takuan> now
09:33:30 <basti_> shh don't blow the effect ;)
09:33:31 <takuan> that's all very well
09:33:41 <xerox> Grumble.
09:33:44 <basti_> like that "funny IO type"
09:33:45 <soysauce> takuan - maybe you should describe the real problem
09:33:48 <takuan> but what is the simplest solution if I really really want something stupid like that?
09:34:01 <basti_> probably the State Monad
09:34:06 <takuan> aha
09:34:11 * basti_ plays another minor chord and adds some trembolo
09:34:21 * takuan plays a whole chopin etude
09:34:54 * jlouis sings a sonet on the correctness of soysauces argument
09:35:02 <SamB> the simplest solution would probably be to use Pytohn
09:35:09 <SamB> if you want something silly like that
09:35:15 <basti_> or that.
09:35:15 <SamB> only its not so simple after all
09:35:17 <basti_> or scheme.
09:35:22 <takuan> nah
09:35:28 <basti_> C++!
09:35:36 <jlouis> SML!
09:35:38 * basti_ plays a shrill noise
09:35:38 <takuan> i'm using computations on polynomials in a galois field
09:35:42 <takuan> try that in C++
09:35:48 <SamB> no thanks
09:35:54 * takuan neither
09:36:04 <SamB> though it isn't that hard if you pick your GF and stick to it
09:36:08 <jlouis> takuan: that would hurt big ass
09:36:18 <takuan> well, i don't intend to stick to one SamB ;)
09:36:27 <SamB> well yeah
09:36:33 <jlouis> take the GF as a template then.... oh ... wait....
09:36:45 <SamB> thats why you code that stuff in Haskell, at least when you are messing around with it...
09:37:00 <SamB> jlouis: that doesn't sound like a good idea
09:37:23 <neologism> one usually code the functional way in functional languages...
09:37:29 <takuan> i know
09:37:37 <takuan> but let's try to mess with the state monad
09:38:37 <SamB> is there an unsafeInterleaveST?
09:38:50 <SamB> @hoogle unsafeInterleave
09:38:51 <lambdabot> Control.Monad.ST.Lazy.unsafeInterleaveST :: ST s a -> ST s a
09:38:51 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
09:38:51 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
09:38:51 <xerox> @index unsafeInterleaveST
09:38:52 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
09:38:55 <SamB> yes, there is
09:43:17 <int80_h> q
09:44:38 <SyntaxNinja> good morning
09:44:53 <Frederick> SyntaxNinja, morning
09:45:01 <Frederick> @localtime SyntaxNinja 
09:45:14 <SamB> FYI, unsafeInterleaveIO is how getContents/hGetContents can read lazily
09:46:36 <basti_> takuan: so do you want to learn about monads?
09:47:18 <SamB> dons: I'm getting some pretty bad CPU usage with the latest hmp3
09:49:19 <ndm> morning SyntaxNinja 
09:49:34 <ndm> does anyone know how to do anchors on hawiki?
09:49:46 <SyntaxNinja> hi Frederick, ndm
09:49:49 <ndm> so i can do http://www.haskell.org/hawiki/Page#position
09:49:57 <ndm> i need it for the keywords page
09:50:00 <ndm> @wiki Keywords
09:50:01 <lambdabot> http://www.haskell.org/hawiki/Keywords
09:50:23 <SamB> after playing for a while, I'm seeing mostly 50% with some (rather long) 100% bursts with lots of skipping
09:52:18 <tomaszz> hmp3 is an mp3 decoder written in Haskell?
09:55:43 <SamB> tomaszz: no
09:55:50 <SamB> it is an mpg123 frontend
09:56:02 <SamB> mpg123 is surprisingly congenial to frontends
09:56:47 <SamB> it is quite new
09:59:48 <tomaszz> aha...
10:00:01 <tomaszz> so it's a GUI for mpg123?
10:12:23 <araujo> Hello Haskell'er!
10:14:17 <tomaszz> hello araujo
10:17:01 <SyntaxNinja> Cale: http://hackage.haskell.org/cgi-bin/trac/trac.cgi
10:19:41 <takuan> basti_: nah ;)
10:19:51 <takuan> i'm afraid i don't have time
10:20:10 <takuan> maybe if they let me doctorate on the subject of my thesis
10:20:35 <basti_> :-o
10:23:16 <araujo> Hello tomaszz 
10:34:49 <Frederick> SamB, finally ive undertood the last constructions you showed to me
10:46:40 <Frederick> folks how can I iterate over a list of strings but getting the contents of the list letter by letter?
10:46:57 <basti_> hmm
10:47:00 <basti_> @type foldr1
10:47:01 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
10:47:14 <basti_> like that maybe?
10:47:17 <basti_> or like:
10:47:19 <basti_> @type foldr
10:47:20 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
10:47:56 <basti_> > foldr1 (\x y->x+(ord y)) 0 "Hallo"
10:47:57 <lambdabot> Couldn't match `t -> t1' against `Int'
10:48:09 <basti_> uhm
10:48:58 <Frederick> basti_, ive looked for foldr but this is not exactly what I need at least I couldnt make it fit in the concecpt I neeed
10:49:06 <musasabi> > foldr1 (\x y->x+(ord y)) "Hallo"
10:49:07 <lambdabot> Couldn't match `Char' against `Int'
10:49:36 <mauke> > foldr (\x y->x+(ord y)) 0 "Hallo"
10:49:36 <musasabi> The problem is that foldr1 does not take the initial argument and wants a function of (a -> a -> a)
10:49:37 <lambdabot> Couldn't match `Char' against `Int'
10:49:59 <basti_> > foldr (\x y->y+(ord x)) 0 "Hallo"
10:50:00 <lambdabot> 496
10:50:02 * basti_ stoopid
10:50:07 <Frederick> basti_, SamB made the parser work and cleared my concepts here -> http://rafb.net/paste/results/2EaMuf62.html now Im reading haskell the craft of functional programming
10:51:05 <basti_> Frederick: great
10:51:22 <Frederick> I want to remove the $ productions of a grammar, this part isnt so hard, the algorithm is pretty simplethe problem is how to iterate over all productions
10:51:49 <Frederick> it will take at least 3 levels of recursion I think
10:51:56 <mauke> @pl \f l -> map f (concat l)
10:51:57 <lambdabot> (. join) . map
10:52:12 <basti_> uh
10:52:14 <basti_> okay
10:52:20 * basti_ .o∞ ( :-o )
10:52:40 <Frederick> let me post on rafb a draf
10:52:44 <Frederick> draft
10:55:15 <takuan> humz
10:55:23 <takuan> I get this error message
10:55:32 <takuan>     Ambiguous type variable `a' in the constraints:
10:55:32 <takuan>       `Field a' arising from use of `</>' at <interactive>:1:2-4
10:55:32 <takuan>       `Fractional a' arising from use of `</>' at <interactive>:1:2-4
10:55:53 <takuan> i've add Fractional and Field to the type signature of </>
10:55:57 <SamB> quick hint #1: instead of having "X -> $ | y" parse as (NT 'X',[[Empty],[T 'y']])
10:56:00 <takuan> what am I missng?
10:56:13 <SamB> have it parse as (NT 'X',[[],[T 'y']])
10:57:14 <SamB> quick hint #2: use this function I stole from Mrifk to make things easier
10:57:16 <SamB> doToDeath f code =
10:57:18 <SamB>   findFixedPoint (iterate (f . updateLabels) code)
10:57:18 <SamB>     where findFixedPoint (x:y:z)
10:57:18 <SamB>             | x == y    = x
10:57:18 <SamB>             | otherwise = findFixedPoint (y:z)
10:57:35 <SamB> oh, only take out the . updateLabels
10:57:52 <SamB> so more like:
10:58:31 <SamB> doToDeath f x = g (iterate f x)
10:58:50 <SamB>   where g (x:y:z)
10:58:58 <mauke> @type iterate
10:58:59 <lambdabot> forall a. (a -> a) -> a -> [a]
10:59:16 <SamB>       | x == y    = x
10:59:30 <SamB>       | otherwise = g (y:z)
11:00:00 <SamB> Frederick: you see that?
11:01:14 <Frederick> SamB, calm Ive checked it but my algorithm is kinda tricky
11:01:26 <mauke> haha, the @pl form is ... interesting
11:02:02 <SamB> Frederick: I know
11:02:15 <SamB> I've been thinking about how I would do it for a good while
11:03:15 <bringert> SamB: I'm using this fixed-point iteration function: fix f x = let x' = f x in if x' == x then x else fix f x'
11:03:31 <SamB> bringert: whatever works!
11:03:43 <SamB> anyway, the point is, it is very, very nice to use one
11:03:54 <bringert> sure, I was just wondering if there was some difference between them
11:04:02 <SamB> Frederick: oh, and do you want the final bit of the parser?
11:04:13 <Frederick> SamB, yep
11:04:25 <SamB> just a sec while I write it
11:04:36 <Frederick> I got the algorithm pasted here http://rafb.net/paste/results/Wcrvrs95.html
11:04:47 <SamB> I've seen the algorithm already
11:05:04 <SamB> and kept a copy in my folder of stuff from you
11:06:33 <Frederick> so my "plan" was to iterate over the rules lists somehow the part of removing $ is quite simple and the charparser is done but I need o sort of nest the checks and it is quite confusing
11:06:59 <SamB> Frederick: it is simpler if you just use an empty list for an empty production
11:07:29 <Frederick> I have checks to see if a letter is a terminal onterminal or $ so I just need to mach my productions agains it
11:07:39 * Frederick runs to the toillet
11:09:32 <SyntaxNinja> TMI
11:09:42 <SamB> SyntaxNinja: saya what?
11:11:04 * dcoutts agrees with SyntaxNinja 
11:11:14 <SamB> @jargon TMI
11:11:16 <lambdabot> No match for "TMI".
11:11:25 <basti_> "too much information"
11:11:25 <SamB> @vera TMI
11:11:27 <lambdabot> No match for "TMI".
11:11:30 <SamB> oh
11:11:38 <SamB> SyntaxNinja: from where?
11:11:45 <SamB> from me to Frederick ?
11:11:54 <SamB> in the channel period?
11:11:59 <dcoutts> SamB, TMPI
11:12:06 <SamB> P?
11:12:08 <Frederick> back
11:12:09 <dcoutts> too much personal information :-)
11:12:11 <SamB> oh, that
11:12:29 <SamB> maybe there was an elder god coming out of it or something
11:12:57 <SyntaxNinja> SamB: lol
11:13:32 <SamB> Frederick: do we need the list of nonterminals in a CFG?
11:13:48 <SamB> because we already have the keys of the map, so I'd think you could just use those
11:14:10 <Frederick> SamB, for formal reasons we need them
11:14:34 <SamB> Frederick: we can extract them from the map if ever we need them
11:14:41 <Frederick> Cause my theacher is dumb so if the grammar has a terminal b and no rule associated to it we need remove ir
11:14:43 <Frederick> *it
11:14:57 <Frederick> he must be able to input something that will have no usage at all
11:15:08 <SamB> so?
11:15:19 <Frederick> SamB, so we need a list
11:15:24 * Frederick thinks so at least
11:16:00 <Frederick> but I would call it a bonus feature, for now we just need a new map I think
11:18:01 <SamB> well, if you need a list, you can just as easily get one by doing Map.keys (productions cfg)...
11:18:22 <Frederick> SamB, easily :p
11:19:29 <Frederick> SamB, anyway I will only use this list on the end it i the last step match this list against the map cause first of all I need to make the sinplifications
11:23:17 <SamB> Frederick: whatever
11:23:48 <SamB> okay, I've written the top-level parser
11:24:01 <SamB> grammar = do string "termchars "; termchars <- many (noneOf " |\n"); newline
11:24:01 <SamB>              string "start ";     root <- nonterminal termchars;     newline
11:24:01 <SamB>              productionsList <- rule termchars `sepBy` newline
11:24:01 <SamB>              return (CFG { terminals = map T termchars,
11:24:01 <SamB>                            nonterminals = map fst productionsList,
11:24:02 <SamB>                            root = root,
11:24:04 <SamB>                            productions = Map.fromList productionsList
11:24:06 <SamB>                          })
11:24:11 <SamB> do you have any clue what that means?
11:25:18 <Frederick> let me place it in a place where I can read properly
11:26:10 <SamB> hmm, it doesn't quite seem to work
11:27:22 <SamB> wonder why...
11:28:52 <SamB> oh, your "nonterminal" function is the old, broken version
11:29:35 <Frederick> huh?
11:29:58 <Frederick> it was working before =/
11:30:03 * Frederick is confused
11:30:11 <SamB> well, it parses anything, including spaces
11:30:20 <Frederick> so now terminals is also broken <o>
11:30:26 <zagrius> How does a right shift work on negative numbers?
11:30:27 <SamB> maybe you have the right one in your file
11:30:33 <SamB> paste it
11:30:40 <SamB> (just that function)
11:30:46 <SamB> (here, in the channel)
11:30:55 <Frederick> nonterminal :: [Char] -> CharParser st (Symb Char Char)
11:30:56 <Frederick> nonterminal termchars = liftM NT (noneOf termchars)
11:31:07 <Frederick> yep it is broken
11:31:24 <Frederick> because we changed the definition of the productions
11:31:51 <Frederick> zagrius, doesn it divide the number by 2?
11:32:13 <SamB> Frederick: okay
11:32:26 <xinming> where to paste the code please?
11:32:31 <zagrius> Frederick: A right shift also has a parameter for the number of bits. 
11:32:38 <basti_> lisppaste2: @url
11:32:38 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:32:39 <basti_> xinming: ^
11:32:52 <SamB> nonterminal termchars = liftM NT (noneOf (" |\n"++termchars))
11:32:57 <SamB> that should work better
11:33:29 <lisppaste2> xinming pasted "why not works?" at http://paste.lisp.org/display/13574
11:34:10 <basti_> xinming: "xs" is not "declared" in the otherwise clause
11:34:22 <xinming> hmm, if I use mysum [] = 0 and another line is mysum (x:xs) = x + mysum( xs )
11:34:28 <xinming> it will get the right answer
11:35:02 <zagrius> Frederick: right shift in C is only defined for positive numbers. 
11:35:23 <zagrius> So I am wondering how it exactly works in Haskell for negative numbers.
11:36:03 <Frederick> zagrius, you must provide a correction to negative right shift
11:36:09 <xinming> basti_: But the interpreter won't give the error message
11:36:16 <SamB> and replace "sepBy" by "sepEndBy"
11:36:20 <basti_> ah oh
11:36:26 <basti_> sorry i was wrong
11:37:15 <zagrius> Frederick: a correction? What do you mean?
11:37:20 <Frederick> SamB, in the parser?
11:37:36 <SamB> Frederick: in the "grammar" function
11:37:46 <musasabi> shapr: Do you have your TCP/IP code somewhere?
11:37:59 <SamB> in particular, the line "             productionsList <- rule termchars `sepBy` newline"
11:38:02 <shapr> musasabi: What code do you want?
11:38:13 <SamB> should be "             productionsList <- rule termchars `sepEndBy` newline"
11:38:14 <musasabi> shapr: the one you blogged about
11:39:13 <shapr> musasabi: grab House from cvs, cd programatica/hOp/net/ && make
11:39:41 <xinming> hmm, anyone here would help?
11:40:50 <shapr> musasabi: The ifconfig line on my blog is a (probably hackish) way to get an ip assigned to /dev/net/tun. I also did chmod ugo+rw /dev/net/tun so I could access it as myself instead of root.
11:41:07 <Frederick> SamB, I got it
11:41:21 <Lemmih> xinming: Sure. Speak your mind.
11:41:44 <SamB> *CFG> parseTest grammar (unlines ["termchars sz","start N","N -> sN | z"])
11:41:49 <SamB> CFG {terminals = [T 's',T 'z'], nonterminals = [NT 'N'], root = NT 'N', productions = {NT 'N':=[[T 's',NT 'N'],[T 'z']]}}
11:42:10 <Frederick> SamB, I mssies part of the paste on the channel 1 sec
11:42:53 <xinming> Lemmih: http://paste.lisp.org/display/13574
11:44:20 <Lemmih> xinming: You've defined 'mysum (10:[])' to be '0'.
11:44:26 <Frederick> SamB, I got this  grammar = do string "termchars " ;
11:44:27 <Frederick>  termchars <- many (noneOf " |\n"); newline
11:44:27 <Frederick>  string "start ";     
11:44:27 <Frederick>  root <- nonterminal termchars;     newline
11:44:27 <Frederick>  productionsList <- rule termchars `sepEndBy` newline
11:44:27 <Frederick>  return (CFG { terminals = map T termchars,
11:44:29 <Frederick>  nonterminals = map fst productionsList,
11:44:32 <Frederick>  root = root,
11:44:33 <Frederick>  productions = Map.fromList productionsList
11:44:35 <Frederick>  })
11:44:57 <Frederick> but it doesnt parsers the second line of the definition Ive checked identation spaces and stuuf
11:45:07 <SamB> Frederick: you totally messed up the indentation
11:45:16 <SamB> how can you read that
11:45:20 <Lemmih> xinming: Define what 'mysum' should do on an empty list first.
11:45:37 <SamB> it won't likely run, either
11:48:08 <xinming> Lemmih: hmm, Can I write that within a function definition?
11:48:19 <SamB> Frederick: so, did you try the test?
11:48:32 <xinming> Lemmih: What I don't want is write 2 function defition,
11:48:38 <Frederick> SamB, Im trying to fix identation
11:48:40 <Frederick> calm down
11:48:55 <Lemmih> xinming: Why not?
11:48:56 <xinming> mysum [] = 0 "\n" mysum (x:xs) = x + mysum( xs );
11:49:14 <Frederick> fixed
11:49:36 <xinming> Lemmih: hmm, For TIMTOWTD :-)
11:50:02 <SamB> oh, maybe I shoulda pasted on a pasteboard, huh?
11:50:04 <Lemmih> xinming: You could check if the argument is null and then use a 'case' to pattern match out the first element.
11:50:15 <Lemmih> @wtf TIMTOWTD
11:50:16 <lambdabot> No match for "TIMTOWTD".
11:50:23 <Frederick> SamB, it compiles now but complains about no instance of show
11:50:28 <xinming> @wtf TMTOWTO
11:50:30 <lambdabot> No match for "TMTOWTO".
11:50:33 <xinming> ouch.
11:50:33 <Lemmih> @wtf TIMTOWTDI
11:50:34 <lambdabot> No match for "TIMTOWTDI".
11:50:37 <SamB> @vera TIMTOWTDI
11:50:38 <lambdabot> No match for "TIMTOWTDI".
11:50:46 <Lemmih> Got it (:
11:51:01 <xinming> @wtf TMTOWTDI
11:51:03 <lambdabot> No match for "TMTOWTDI".
11:51:11 <xinming> perl's motto... :-P
11:51:30 <SamB> @dict-all TIMTOWTDI
11:51:30 <lambdabot> Unknown command, try @listcommands.
11:51:51 <xinming> Lemmih: Could you give me an example? :-/
11:52:38 <Frederick> SamB, please ost in the pastebin something is missing here =/
11:53:41 <Lemmih> > fix (\s l -> case l of [] -> 0; (x:xs) -> x + s xs) [1..10]
11:53:42 <lambdabot> 55
11:54:20 <lisppaste2> SamB pasted "the whole thing" at http://paste.lisp.org/display/13575
11:55:26 <xinming> Lemmih: thanks.
11:56:24 <xinming> Lemmih: I catch the idea of lamba while I am learning haskell. Even In perl, I just know it is kind of function, But don't know how to use that. :-P
11:57:06 <gzl> xinming: you're confused about lambda?
11:57:26 <xinming> gzl: I understand it yesterday. :-)
11:57:33 <Frederick> SamB, oki Ive ran it with succes but I need to dig it now
11:57:49 <gzl> ok.
11:57:55 <SamB> Frederick: I really don't know what you could have been missing
11:58:21 <Frederick> SamB, damm Ive eraded the wrong one now =/
11:58:25 <Frederick> cant run diff
12:06:24 <Frederick> SamB, oki I got it now I must read about acesssing the members of the grammar structure
12:06:37 * Frederick thinks haskell is a very powerful tool
12:08:08 <SamB> Frederick: you don't need to read about it
12:08:11 <SamB> I'll show you
12:08:21 <Frederick> k
12:08:23 <SamB> as soon as I figure out how to parse better
12:08:37 <SamB> (that is, so that the result is returned)
12:09:02 * SyntaxNinja pokes kosmikus
12:11:14 <zagrius> @dict TMTOWTDI
12:11:15 <lambdabot> Supported dictionary-lookup commands:
12:11:15 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
12:11:15 <lambdabot> jargon @lojban @prelude @vera @web1913 @wn @world02
12:11:15 <lambdabot> Use "@dict-help [cmd...]" for more.
12:11:32 <zagrius> @all-dicts TMTOWTDI
12:11:33 <xinming> @all-dicts TMTOWTDI
12:11:35 <lambdabot> *** "tmtowtdi" vera "Virtual Entity of Relevant Acronyms (Version 1.9,
12:11:35 <lambdabot> June 2002)"
12:11:35 <lambdabot> TMTOWTDI
12:11:35 <lambdabot>   There's More Than One Way To Do It (slang, PERL)
12:11:35 <lambdabot>  
12:11:37 <lambdabot> [5 @more lines]
12:11:38 <xinming> ...
12:11:39 <lambdabot> *** "tmtowtdi" vera "Virtual Entity of Relevant Acronyms (Version 1.9,
12:11:41 <lambdabot> June 2002)"
12:11:42 <lambdabot> TMTOWTDI
12:11:45 <lambdabot>   There's More Than One Way To Do It (slang, PERL)
12:11:47 <lambdabot>  
12:11:49 <lambdabot> [5 @more lines]
12:12:39 <SamB> run p name xs = case parse p name xs of
12:12:39 <SamB>                 Left  err -> error (show err)
12:12:39 <SamB>                 Right res -> res
12:14:46 <eivuokko> Could someone explain or point me to the right direction what is diffrent on g :: forall a. (Ord a => a -> a) -> Int and g :: (forall a. Ord a => a -> a) -> Int  (taken from GHC User Manual, 7.4.9.3)?
12:15:11 <eivuokko> Why does it matter where quantification is done?
12:15:57 <SamB> can you do that and then put the Ord a => in with the a -> a?
12:16:21 <SamB> @type undefined :: forall a. (Ord a => a -> a) -> Int
12:16:22 <lambdabot>   No instance for (Ord a)
12:16:22 <lambdabot>   arising from instantiating a type signature at <interactive>:1:0-
12:16:22 <lambdabot> 8
12:17:08 <SamB> anyway, the latter takes a polymorphic function, the former takes a monomorphic function
12:17:16 <eivuokko> Ah.
12:17:22 <xinming> where to find the information about the '|' in lambda closure?
12:17:23 <eivuokko> Silly me, thanks.
12:17:30 <SamB> not silly at all!
12:17:38 <xinming> (\s l -> case l of [] -> 0; (x:xs) -> x + s xs)
12:17:44 <SamB> that stuff is confusing, especially when you are just learning about it
12:18:20 <eivuokko> SamB, yeah, but I already read over that part.  I wasn't thinking in right scope, is all :)
12:18:40 <SamB> eivuokko: still, that stuff is tricky!
12:19:21 <Frederick> SamB, haskell is trycky :p
12:19:25 <Frederick> *tricky
12:19:52 <SamB> I mean, who would have thought that one little $ could mean the difference between a typecheck and a type error?
12:20:17 <basti_> <-
12:20:43 <SamB> before it happened to them, I mean
12:20:48 <basti_> ah
12:20:50 <basti_> ^^
12:21:01 <SamB> whats "^^" mean?
12:21:01 <Frederick> SamB, how is it called the construction you gave for the parser?
12:21:12 <SamB> oh, right
12:21:14 <basti_> "two lifted eyebrows"
12:21:16 <SamB> *CFG> let cfg = run grammar "" (unlines ["termchars sz","start N","N -> sN | z"])
12:21:26 <SamB> *CFG> cfg
12:21:27 <SamB> CFG {terminals = [T 's',T 'z'], nonterminals = [NT 'N'], root = NT 'N', productions = {NT 'N':=[[T 's',NT 'N'],[T 'z']]}}
12:21:49 <SamB> *CFG> root cfg
12:21:50 <SamB> NT 'N'
12:21:56 <Frederick> No no
12:22:00 <SamB> hmm?
12:22:04 <Frederick> I mean call as it is  called a struct
12:22:10 <Frederick> or it is aclled a pointer
12:22:16 <SamB> huh?
12:22:21 <SamB> struct? pointer?
12:22:25 <SamB> there are no such things!
12:22:30 <Frederick> SamB, I know
12:22:38 <Frederick> but struct and pointer are names oki
12:22:44 <SamB> oh?
12:22:45 <Frederick> names give them no semantics just name
12:22:46 <Frederick> s
12:23:02 <SamB> ask the question again?
12:23:51 <Frederick> SamB, the structure you gave to the grammar must have a name
12:23:59 <Frederick> like class, pattern I dunno
12:24:14 <SamB> you mean the thing that starts with a "do"?
12:24:56 <Frederick> no the whole thing that starts at grammar =
12:25:25 <SamB> that is a definition
12:26:26 <mentomorph> Hi, whitch of these "wxHaskell TclHaskell Fudgets FranTk" is easiest to going with ?
12:26:27 <SamB> just like all the other things that aren't type signatures or type definitions
12:26:44 <SamB> mentomorph: you could go with Gtk2Hs
12:26:49 <SamB> that is actually maintained
12:26:54 <SamB> @where Gtk2Hs
12:26:55 <lambdabot> http://haskell.org/gtk2hs/
12:27:04 <mentomorph> allright thx
12:27:15 <SamB> wxHaskell still looks viable
12:27:33 <SamB> I mean, it still builds and runs ;-)
12:27:59 <mentomorph> :) ok
12:28:29 <Frederick> SamB, how did you run tha last example?
12:28:49 <SamB> oh
12:28:58 <SamB> did you catch the "run" function?
12:29:06 <SamB> run p name xs = case parse p name xs of
12:29:06 <SamB>                 Left  err -> error (show err)
12:29:06 <SamB>                 Right res -> res
12:29:07 <thou> mentomorph: i think wxhaskell or gtk2hs; seems like gtk is more popular, but i think there's a few active people using wxhaskell also.  the others are old
12:29:37 <mentomorph> k
12:29:42 <thou> mentomorph: gtk is nice because it works with the glade ui designer, so you can build a ui pretty easily
12:30:00 <SamB> wxHaskell looks like there are some things that are nice about it, too, though.
12:30:11 <SamB> if you can figure out how to use it, anyway
12:30:12 <thou> yeah, definitely - it's a mature product
12:30:14 <thou> hehe
12:30:22 <thou> i mean, wxwindows is mature
12:30:27 --- mode: ChanServ set +o Igloo
12:30:35 --- mode: Igloo set -bo cmeme!*@* Igloo
12:30:43 <mentomorph> lol, I need some for rapid dev. I'll consider those two. Thx
12:30:54 <SamB> well, wxHaskell does a number of things above and beyond wxWidgets
12:31:33 <thou> ah.  i haven't actually looked at it for a little while
12:31:55 <Frederick> SamB, does the case command defines something special about the identation?
12:32:09 <SamB> Frederick: not the case command, no.
12:32:20 <SamB> but it uses something special about indentation
12:32:26 <SamB> let me look it up
12:32:39 <SamB> @google site:haskell.org report layout rule
12:32:41 <lambdabot> http://www.haskell.org/definition/haskell98-report.pdf
12:32:44 <Frederick> CFG.hs:64:0: parse error (possibly incorrect indentation)
12:32:46 <Frederick> heh
12:32:46 <SamB> @google site:haskell.org layout rule
12:32:49 <lambdabot> http://www.haskell.org/pipermail/haskell-i18n/2003-August/000116.html
12:33:04 <SamB> arg
12:33:09 <SamB> @google site:haskell.org layout
12:33:10 <lambdabot> http://www.haskell.org/hawiki/Layout
12:33:17 <SamB> @google site:haskell.org report
12:33:18 <lambdabot> http://www.haskell.org/onlinereport/
12:33:23 * SamB is bumbling today
12:34:09 <SamB> an informal description: http://www.haskell.org/onlinereport/lexemes.html#lexemes-layout
12:35:21 <SamB> a formal description: http://www.haskell.org/onlinereport/syntax-iso.html#layout
12:36:57 <SamB> It hadn't crossed my mind that you wouldn't know that indentation was significant in Haskell ;-)
12:37:31 <Frederick> SamB, I know it is (as it is in python) but I cant keep consistent
12:38:54 <Frederick> folks why is that so wrong haskell cant read? http://rafb.net/paste/results/YrGcZI81.html
12:39:40 <Frederick> cause ghci complains of line 1 oki if 2 or 3 are broken I can understand but 1 beeing broken?!
12:40:07 <SamB> Frederick: um, I think maybe there was a problem with the code *before* that
12:40:10 <SamB> because that is fine
12:40:38 <Frederick> lemme check
12:40:56 <SamB> I tried it, too, didn't just assume my intuition is correct ;-)
12:41:30 <Frederick> SamB, Ive skipped a parentesys beforedammit
12:41:52 <SamB> yeah, it just says that about indentation so you don't ignore the possibility
12:42:54 <SamB> really, the layout rule can be quite a pain to implement, apparantly...
12:43:10 <Frederick> what?
12:43:18 <SamB> nevermind, irrelevant
12:43:27 <SamB> carry on!
12:44:33 <Frederick> I gtg for some hours (have practice now)
12:44:39 <Frederick> I will take a brak to cook it up
12:44:50 <Frederick> shall be back in line ~4 hours
12:46:01 <SamB> okay then
12:48:04 <integral> @plugs (\x -> case x of { 1 -> 2; _ -> 3 }) 3
12:48:05 <lambdabot> 3
12:48:11 <integral> xinming: there's an example :-)
12:53:39 <Cale> SyntaxNinja: :)
13:00:12 <xinming> integral: thanks, found writing something in haskell is a bit like writing a formula.
13:06:49 <integral> it's exactly like writing a formula; except I wish mathematicians were this unambiguous ;)
13:07:35 <Cale> They are unambiguous :)
13:08:45 <Cale> It's just that they're writing things in a different language in each branch, some of which would be difficult for a computer to work with.
13:09:00 <Cale> (as there's English involved)
13:09:10 <Cale> (or some other natural language of course)
13:10:20 <integral> "import Applied.QuantumMechanics (H);" vs. "import Statistics.Markov (H)"
13:10:44 <Cale> But if you think about it, Haskell is ultimately defined in terms of the Report, and that's written in English, and it's not even perfectly clear.
13:11:30 <Cale> Look at the section on the kind system.
13:11:47 <SamB> Cale: Kinds aren't clear?
13:12:11 <Cale> Well, how they work is understood, but the report doesn't really specify how kind inference works.
13:12:20 <lisppaste2> xinming pasted "Where I did wrong please?" at http://paste.lisp.org/display/13582
13:12:28 <SamB> too simple to bother with?
13:12:30 <Cale> It's just left to the reader to be smart enough to figure that out
13:12:32 <Cale> yeah
13:12:41 <Cale> and that happens a lot in mathematics
13:12:45 <Cale> and it's fine :)
13:13:10 <Cale> As long as you can convince yourself with a few minutes work that everything is good, it's okay, anyway
13:13:29 <int-e> xinming: the lambda abstraction \<variable> -> <expression> , i.e. \s -> case ... in your case
13:13:38 <SamB> well, with programming language specifications, there is the test of whether it works as expected
13:14:15 <SamB> I mean, you not only have to convince yourself, but also convince a computer to actually *do* it
13:14:19 <SamB> thats hard to fake
13:14:32 <SamB> and less error-prone
13:14:37 <Cale> With mathematics too -- if you do something wrong, you may run into a contradiction, at which point it will be obvious that something has gone wrong.
13:14:58 <Cale> Similarly, if you write your program incorrectly, you might spot a bug.
13:15:47 <Cale> In mathematics, there are people who review articles, and check that the steps provided in proofs make sense and follow from what is known.
13:15:54 <SamB> hmm
13:16:27 <SamB> still, there is nothing like a computer to find an obvious mistake
13:16:33 <lisppaste2> int-e annotated #13582 with "(for xinming) why not this way?" at http://paste.lisp.org/display/13582#1
13:16:35 <xinming> int-e: thanks, forgot it.
13:17:25 <xinming> int-e: thanks, I just wish to be familiar with the grammar. :-)
13:17:59 <int-e> xinming: just wondering :)
13:18:44 <Cale> Sometimes, perhaps even most of the time, but sometimes it will still be not obvious that anything is wrong. There are lots of bugs in software. I'd think that mathematics' track record is actually pretty good. There's a large body of mathematics out there which people have been staring at for hundreds of years and not found errors in. Newer stuff is subject to more faults for sure, but by the time you're teaching courses on it, it's likely to be pretty solid.
13:20:09 <Cale> Basically, proofs in mathematics are programs which run on human computers. :)
13:20:09 <SamB> well, true...
13:21:42 <Cale> heh, I wanted to install cabal-get so that it would be easier to install HTTP, but it turns out that HTTP is a dependency of cabal-get (should have guessed that :)
13:21:44 <astrolabe> Maybe people could have blind spots though
13:22:23 <SamB> Haskell compilers are excelent for at least ensuring that a notion is correctly typed
13:22:29 <astrolabe> For example, I think there was at least one missing axiom in Euclid, which was only spotted in modern times.
13:22:43 <astrolabe> (modern = Hilbert probably)
13:22:48 <SamB> missing?
13:23:06 <astrolabe> They assumed something that wasn't in their axiom system.
13:23:06 <SamB> I thought the trouble was that they were looking for a theorem instead
13:23:32 <Cale> Euclid doesn't quite count as modern mathematics, but yes, it's possible to miss things.
13:23:33 <astrolabe> The parallel postulate?  That's something else.
13:23:38 <SamB> oh
13:24:25 <Cale> Euclid is surprisingly close to modern mathematics given its date, but it's a bit loose in the way that it handles its assumptions.
13:24:47 <Cale> The fact that Euclid made an attempt at stating axioms at all was novel at that time.
13:25:47 <astrolabe> blind spots are interesting I think.
13:25:53 <SamB> yes
13:26:02 <SamB> and humans have a lot of those...
13:26:23 <Cale> Well, at that time, the philosophy was that there was one true geometry, which we now see as a philosophically naive perspective.
13:26:24 <SamB> which is why type systems are so helpful
13:26:41 <Cale> Type systems have plenty of blind spots.
13:27:03 <SamB> Cale: oh?
13:27:12 <Cale> The Haskell type system, for example, can't tell me that qsort sorts the list it's given.
13:27:17 <SamB> well duh
13:27:21 <Cale> yes
13:27:38 <Cale> They have quite obvious blind spots :)
13:27:40 <SamB> the type systems are for preventing stupid, idiotic mistake
13:27:53 <Cale> Now, you might say, they're just not for that.
13:28:02 <SamB> and for overloading
13:28:05 <integral> like using a sorted insert function on an unsorted list? :)
13:28:06 <Cale> But in Euclid's defense, the same argument applies :)
13:28:39 <Cale> There are certain assumptions about what his work is going to be useful for.
13:28:49 <xinming> hmm, for the function which use recursion to get the sub of an array, Is there a way to avoid this? :-/
13:28:50 <SamB> with Maths, you have to do all checking yourself.
13:28:51 <xinming> *** Exception: stack overflow
13:29:04 <xinming> s/sub/sum/
13:29:13 <gzl> astrolabe: what missing axiom/
13:29:22 <SamB> you can't depend on the computer to cover your back while you look at the interesting parts
13:29:56 <ulfdoz> I'm doing mergesort, and prof wants me to merge in linear time? is it even possible to merge more than two lists in O(n) where n overall number of elements?
13:30:22 <int-e> xinming: the usual trick is to do tail recursion .... define an accumulating version of sum that takes a partial sum and the remainder of the list:   sum l = sum' l 0 where sum' [] s = s; sum' (x:xs) s = sum' xs (x+s)
13:30:35 <SamB> ulfdoz: professor wants time in Haskell?
13:30:40 <astrolabe> gzl: I don't really know, I just read about it.  Something to do with the ordering of points on a line a think.  if A is to the left of B and B is to the left of C then A is to the left of C, something like that.
13:30:51 <SamB> how do you define "time" in Haskell?
13:30:54 <int-e> xinming: unfortunatetly, hugs seems to be too stupid to take advantage of the that. ghc does.
13:31:06 <SamB> what if the lists are O(n!) themselves?
13:31:15 <SamB> how do you time that?
13:31:26 <Cale> SamB: sure, but that's kind of what mathematics is about in some sense :)
13:31:30 <ulfdoz> SamB: At least complexity.
13:32:00 <gzl> astrolabe: and that's something not in Euclid that should be?
13:32:17 <astrolabe> ulfdoz: think how you would merge two sorted subpacks of cards.  It is linear in time.
13:32:19 <xinming> hmm, I'd suggest people here please don't use l for a list... as It is almost the same as '|' here. :-/
13:32:54 <SamB> ulfdoz: did he say he wanted you to merge n lists anyways?
13:33:00 <astrolabe> gzl: I believe so.
13:33:04 <shapr> You could get an OCR font.
13:33:17 <gzl> odd. ok.
13:33:25 <ulfdoz> astrolabe: For two is that ok. but I have a list of m lists. And complexity seems to me something like O(n * m)
13:33:45 <ulfdoz> SamB: That is how I interprete it.
13:34:04 <SamB> shapr: oh, would you like to see my z-machine interpreter? I need somebody to figure out how to actually implement IO...
13:34:09 <SamB> @where zmachine
13:34:10 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
13:34:41 <shapr> SamB: I'm still in the midst of my Evil Project right now.
13:35:01 <SamB> shapr: who do you think might be interested?
13:35:13 <SamB> you do know everybody in here, right?
13:35:24 <shapr> Not everyone, but nearly.
13:35:26 * SamB kids
13:35:47 <astrolabe> ulfdoz: is n the sum of the lengths of all the input lists?
13:35:56 <ValarQ> i hope he doesn't know me...
13:36:03 <SamB> I'm wondering if parts of Yi could be hijacked for this purpose, but have no idea how to do it myself...
13:36:20 * ValarQ feels uneasy with other peoples evil projects
13:36:24 <shapr> I don't know any Haskellers who are interested in text adventures. It's too bad Joe Strout never migrated to Haskell, he'd really enjoy a Z Machine interpreter.
13:36:27 <ValarQ> it's bad enough with my own
13:36:30 <SamB> ValarQ: adopt mine!
13:36:43 <ValarQ> shapr: i prefer tads
13:37:03 <ValarQ> SamB: nah, i got so many already
13:37:11 <SamB> TADS is way more complicated, I'd have to do so many types and parse so much and all that...
13:37:16 <Cale> I like text adventures :) I'm thinking of possibly writing a Haskell mush
13:37:31 <SamB> Cale: would you like to take a look?
13:37:42 <SamB> do you have any idea how to do a UI?
13:37:44 <ulfdoz> grybl, splitting the m lists into pairs of lists and folding the list of pairs of lists sounds good.
13:37:46 <Cale> at the Z-Machine interpreter?
13:37:49 <SamB> yeah
13:37:56 <amiddelk> Cale: you should read a paper by (forgot the name) who encodes all kinds of propositions in the type system so that you can proof that qsort sorts the list
13:38:14 <ulfdoz> But it isn't. linear.
13:38:23 <Cale> amiddelk: well, yeah, I know that it can be done -- dependent types make it fun and easy even
13:38:40 <Cale> amiddelk: but the point is one of intentions :)
13:39:11 <astrolabe> ulfdoz: What if you start by sorting the list of lists?
13:39:30 <SamB> @where zmachine
13:39:31 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
13:40:02 <ulfdoz> astrolabe: O(m * log m) is minimum upper bound for sorting, which also isn't linear.
13:40:30 <Cale> for general sorting anyway :)
13:40:36 <astrolabe> but if m << n?
13:41:11 <xinming> int-e: hmm, your example will also get the stack overflow in ghci. :-/
13:41:27 <xinming> let mysum l = sum' l 0 where sum' [] s = s; sum' (x:xs) s = sum' xs (x+s)
13:42:25 <int-e> xinming: I guess I should verify my assumptions before stating them :(
13:42:50 <Cale> xinming: what's the problem?
13:43:20 <xinming> Cale: if there is over 9 zeros, ghci will say stack overflow.
13:43:21 <Cale> ah, stack overflow?
13:43:24 <Cale> yeah
13:43:32 <Cale> you need to force some evaluation
13:43:51 <Cale> you're collecting some massively large expressions as you run over the list
13:44:06 * SamB discerns that Cale has grabbed his code
13:44:07 <Cale> when it gets to the end and tries to evaluate them, you get a stack overflow
13:44:09 <int-e> xinming: hmm. I try: let sum l = sum' l 0; sum' [] s = s; sum' (x:xs) s = sum' xs (x+s) in sum [1..] ... and get no stack overflow ...
13:44:16 <Cale> SamB:  :)
13:44:24 <int-e> xinming: maybe the stack overflow occurs in the list creation?
13:44:27 * SamB wonders why Cale's computer asked for /favicon.ico
13:44:38 <Cale> It occurs in the evaluation of the number for the expression
13:44:46 <Cale> SamB: I hit it with Firefox first :)
13:45:05 <SamB> well, really I'm wondering why I see that LAST in the log
13:45:39 <int-e> hmm. but I had 1.4 GB process for ghci now hehe.
13:45:46 <Cale> SamB: not sure
13:46:04 <Cale> let mysum l = sum' l 0 where sum' [] s = s; sum' (x:xs) s = sum' xs $! (x+s)
13:46:08 <xinming> int-e: let sum l = sum' l 0; sum' [] s = s; sum' (x:xs) s = sum' xs (x+s) in sum [1..1000000]
13:46:12 <Cale> that fixes the problem
13:46:37 <xinming> oops. another version. :-/
13:46:40 <Cale> > let mysum l = sum' l 0 where sum' [] s = s; sum' (x:xs) s = sum' xs $! (x+s) in mysum [1..1000000]
13:46:42 <xinming> I'll try that
13:46:42 <lambdabot> 500000500000
13:46:44 <Cale> > let mysum l = sum' l 0 where sum' [] s = s; sum' (x:xs) s = sum' xs $! (x+s) in mysum [1..10000000]
13:46:48 <lambdabot> Terminated
13:46:54 <xinming> :-P
13:46:56 <Cale> hehe
13:46:59 <Cale> took too long
13:47:19 <int-e> hmm. the prelude sum suffers from the same problem
13:47:42 <xinming> make computer do infinite calculating makes lots of fun...
13:47:44 <SamB> didn't we do this already?
13:47:53 <xinming> 1..10000000000
13:48:01 <xinming> I am trying this
13:48:05 <Cale> the problem is that the partial sums don't get evaluated until the very end
13:48:20 <xinming> If it isn't stoped. I will work how it works. :-)
13:48:23 <Cale> (without some additional strictness annotation)
13:48:27 <xinming> I will learn
13:48:32 <int-e> stupid :(
13:48:40 <ValarQ> > ((+1)&&&(+2)) 5
13:48:41 <SamB> @type foldl' (+)
13:48:41 <lambdabot> (6,7)
13:48:42 <lambdabot> Not in scope: `foldl''
13:48:50 <SamB> @type List.foldl' (+)
13:48:51 <lambdabot> Not in scope: `List.foldl''
13:48:57 <SamB> @type List.foldl (+)
13:48:58 <lambdabot> forall b. (Num b) => b -> [b] -> b
13:49:02 <ValarQ> > ((+1)&&&(subtract 1)) 5
13:49:03 <lambdabot> (6,4)
13:49:04 <Cale> @type Data.List.foldl'
13:49:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:49:08 <ValarQ> > ((+1)&&&(-1)) 5
13:49:09 <lambdabot>  add an instance declaration for (Num (b -> c'))
13:49:23 <Cale> > foldl' (+) 0 [1..1000000]
13:49:24 <lambdabot> 500000500000
13:49:29 <ValarQ> why doesn't that last one work?
13:50:04 <Cale> (-1) isn't a function
13:50:13 <Cale> > ((+1)&&&(subtract 1)) 5
13:50:14 <lambdabot> (6,4)
13:50:19 <SamB> (`sub`1)
13:50:44 <int-e> let mysum l = sum' l 0 where sum' [] s = s; sum' (x:xs) s = let s'=x+s in s' `seq` sum' xs s' in mysum [1..1000000]
13:51:06 <int-e> (stolen from the definition of foldl')
13:51:06 <ValarQ> Cale: oh, of course
13:51:49 <xinming> by the way, will [1..10000000000] takes so long? 2 minutes passed.
13:52:00 <Cale> xinming: yeah, that'll take ages
13:52:05 <xinming> on a Barton 2500+
13:52:08 <xinming> :-/
13:52:16 <SamB> > foldl' (+) 0 [1..10000000000]
13:52:19 <Maddas_> Hey there, Pseudonym.
13:52:20 <lambdabot> Terminated
13:52:23 <SamB> > foldl' (+) 0 [1..1000000000]
13:52:28 <lambdabot> Terminated
13:52:30 <SamB> > foldl' (+) 0 [1..100000000]
13:52:35 <lambdabot> Terminated
13:52:38 <SamB> > foldl' (+) 0 [1..10000000]
13:52:42 <int-e> well, it has to use long integers for the result which slows down the calculation tremendously.
13:52:42 <lambdabot> 50000005000000
13:52:45 <ValarQ> > take 0 [1.10000000000]
13:52:47 <lambdabot> []
13:52:49 <Cale> int-e: $! makes that prettier
13:53:06 <ValarQ> it's faster when not evaluating it :)
13:53:07 <SamB> > foldl' (+) 0 [1..10000000] :: Word64
13:53:10 <lambdabot> 50000005000000
13:53:15 <SamB> > foldl' (+) 0 [1..100000000] :: Word64
13:53:20 <lambdabot> Terminated
13:53:28 <SamB> > foldl' (+) 0 [1..50000000] :: Word64
13:53:33 <lambdabot> Terminated
13:53:36 <SamB> > foldl' (+) 0 [1..20000000] :: Word64
13:53:41 <lambdabot> Terminated
13:54:01 * SamB stops
13:54:11 <astrolabe> terminated?
13:54:27 <SamB> astrolabe: it means "killed for taking too long"
13:54:29 <SamB> @help eval
13:54:30 <lambdabot>  @eval <expr>
13:54:30 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
13:54:32 * xinming is considering if he need to buy a 64 bit processor to learn tail recursion. ;-)
13:54:45 <SamB> xinming: no.
13:54:57 <astrolabe> SamB: thanks, but it was a joke.
13:54:58 <SamB> if you get it right, it will work on a 32-bit processor also
13:54:59 <xinming> Just kidding. :-)
13:55:05 <int-e> Cale: for some reason, the $! version takes almost twice as long.
13:55:08 <SamB> astrolabe: oh
13:55:34 <SamB> of course...
13:55:36 <Cale> int-e: interesting
13:55:50 <Cale> int-e: even after compilation?
13:56:00 <SamB> there are smarter ways to add things like that
13:56:18 <int-e> Cale: no, in ghci. hmm. compiled ...
13:57:02 <SamB> sum [n..m] = n+m * (m-n+1) / 2
13:58:01 <musasabi> A rule could be used for that...
13:58:02 <SamB> > let f n m = (n+m) * (m-n+1) / 2
13:58:03 <lambdabot>  parse error on input `}'
13:58:14 <SamB> > let f n m = (n+m) * (m-n+1) / 2 in f 1 10000000000
13:58:15 <lambdabot> 5.0000000005e19
13:58:29 <SamB> > let f n m = (n+m) * (m-n+1) `div` 2 in f 1 10000000000
13:58:31 <lambdabot> 50000000005000000000
13:59:01 <SamB> but presumably [1...m] was just for testing
13:59:05 <int-e> Cale: it's still a tad slower after compilation (6 seconds versus 4 for [1..10000000]) ... let me try -O2
13:59:17 <xinming> SamB: hmm, I know this, It is just a kind of solution to a problem, If I happen to face the data which in computer I have to sum. I have to know how to do this. :-) not only for the 1..1000000 problem
13:59:41 <SamB> xinming: yes, I just said "but presumably [1...m] was just for testing:
13:59:51 <SamB> er, s/:$/"/
14:00:05 <int-e> Cale: with -O2 the difference is gone.
14:00:10 <Cale> okay
14:00:28 <Cale> I suppose if it's naive, $! will result in an extra closure which needs to be entered
14:01:33 <int-e> Cale: btw, without compiling it was 30 seconds vs. 15. Compiling really, really helps :)
14:01:40 <Cale> yeah
14:02:30 <Cale> hmm
14:02:46 <Cale> funny bug in mbot, maybe in lambdabot too
14:03:09 * Cale wonders if he has admin privs on lambdabot
14:03:13 <Cale> @reconnect
14:03:26 <Cale> okay, I can't test it then :)
14:03:31 <xinming> @reconnect
14:03:32 <lambdabot> not enough privileges
14:03:41 <SamB> heh
14:04:04 <Cale> I'll wait for dons
14:04:18 <dons> ?/
14:04:20 <Cale> hi
14:04:24 <dons> hey
14:04:33 <dons> what's up?
14:04:48 <Cale> Someone reported that they could cause mbot to quit by privmsging it with @exit
14:04:51 <int-e> that wasn't a very long wait ...
14:05:00 <Cale> (not @quit, that reports not enough privileges)
14:05:15 <dons>  @exit eh? sounds weird.
14:06:14 <dons> there's no @exit command, is there (in lambdabot)
14:06:19 <Cale> no there isn't
14:06:20 <SamB> nope
14:06:31 <Cale> but it seemed to work anyway
14:06:37 <dons> huh!
14:06:52 <SamB> >lambdabot< @exit
14:06:52 <SamB> <lambdabot> Maybe you meant: elite quit
14:07:00 <xinming> Maybe you meant: elite quit
14:07:15 <dons> does it have to be in a private channel?
14:07:27 <Cale> I'm not sure
14:07:35 <SamB> private channal?
14:07:37 <Cale> oh, hmm
14:07:39 <Cale> no
14:07:43 <SamB> @exit
14:07:43 <lambdabot> Maybe you meant: elite quit
14:07:54 <Cale> odd
14:08:04 <Cale> perhaps it's something I did :)
14:08:09 <dons> SamB, coul you type '@quit'
14:08:13 <SamB> @quit
14:08:13 <lambdabot> not enough privileges
14:08:28 <dons> so lambdabot may be unaffected
14:08:31 <SamB> @elite
14:08:32 <lambdabot> Say again?
14:08:35 <SamB> @help elite
14:08:35 <lambdabot> Translating english to elitespeak
14:08:42 <dons> and privileges has a `d' in it somewhere!
14:08:44 <SamB> @elite elite
14:08:44 <lambdabot> 1337
14:08:53 <dons> @spell privileges
14:08:54 <ulfdoz> Ok, O(n) for splitting and O(n) for merging makes O(n) for mergesort. I'm quite sure, he hasn't meant mergeSort.
14:09:03 <dons> @help spell
14:09:03 <lambdabot>  @spell <word>, show spelling of word
14:09:08 <dons> @spell happy
14:09:08 <mbot> Unknown command, try @listcommands.
14:09:13 <Cale> now try it :)
14:09:19 <dons> @exit
14:09:19 <lambdabot> Maybe you meant: elite quit
14:09:20 <SamB> @quit
14:09:21 <lambdabot> not enough privileges
14:09:24 <dons> hehe
14:09:34 <dons> Cale broke mbot
14:09:43 <Cale> and I haven't really done much with it
14:09:48 <astrolabe> @elite quit
14:09:49 <lambdabot> QUiT
14:09:53 <astrolabe> :)
14:09:57 <SamB> @where ZMachine
14:09:57 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
14:10:01 <Cale> I've added a single module, which doesn't define that command
14:10:09 <SamB> Cale: what does it define?
14:10:10 <dons> maybe you forked at an inopportune moment?
14:10:37 <SamB> bring mbot back and lets try @help
14:11:13 <Cale> @help
14:11:13 <mbot>  @help <command> - ask for help for <command>
14:11:13 <lambdabot>  @help <command> - ask for help for <command>
14:11:19 <Cale> @listcommands
14:11:19 <lambdabot> use listcommands [module|command], please. Modules are:
14:11:19 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
14:11:19 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
14:11:19 <lambdabot> topic type version vixen where
14:11:19 <mbot> use listcommands [module|command], please. Modules are:
14:11:19 <mbot> base dynamic help math more pl plugs seen system type version
14:11:25 <dons> mbot: @help exit
14:11:25 <mbot>  @help <command> - ask for help for <command>
14:11:36 <dons> mbot: @help quit
14:11:36 <mbot> quit [msg], have the bot exit with msg
14:11:47 <Cale> @exact
14:11:47 <mbot> Unknown command, try @listcommands.
14:11:48 <lambdabot> I can not handle empty facts.
14:12:04 <dons> maybe the spell correction is connverting it to something?
14:12:30 <SamB> mbot: @listcommands
14:12:30 <mbot> use listcommands [module|command], please. Modules are:
14:12:30 <mbot> base dynamic help math more pl plugs seen system type version
14:12:38 <dons> SamB, by the way, are you running latest hmp3? (p71)
14:12:41 <goron> @seen dcoutts 
14:12:41 <mbot> dcoutts is in #haskell. I don't know when dcoutts last spoke.
14:12:41 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #
14:12:41 <lambdabot> haskell. Last spoke 3 hours and 32 seconds ago.
14:13:03 <dons> SamB, I'm not seeing any cpu issues here yet
14:13:09 <SamB> dons: hmm, I dunno. it claims to be p53, but I disbelieve it
14:13:10 <dcoutts> goron, yarr!
14:13:21 <SamB> it hasn't done anything on this run
14:13:24 <xinming> hmm, by the way, if the haskell return the result as 123123e12 such kind of things, How can I ask for the exactly data?
14:13:29 <SamB> that I can recall
14:13:40 <goron> dcoutts: hi, I installed gtk2hs on my FreeBSD box via ports, and it doesn't build the documentation. 
14:13:40 <dons> SamB, hmm. ah, 'touch Config.hs' when rebuilding?
14:13:46 <SamB> xinming: you can't get exact results that way
14:13:54 <goron> dcoutts: I have hacked the port.
14:13:58 <goron> dcoutts: Now it does. 
14:14:06 <dons> though, hmm, maybe you don't rerun 'configure' often enough.
14:14:14 <ulfdoz> What is #gentoo-haskell for?
14:14:16 <SamB> maybe
14:14:20 <goron> dcoutts: Are you in any way involved in haskell@freebsd.org?
14:14:36 <dons> SamB, are you running it since the directory arg patch landed?
14:14:39 <dcoutts> goron, I am not. I just send them the release announcement :-)
14:14:55 <SamB> dons: yes
14:15:05 <SamB> and I notice that that doesn't sort the files
14:15:20 <SamB> which is rather disconcerting
14:15:20 <dcoutts> goron, well actually I help them debug stuff too. But I'm not involved in the port stuff.
14:15:27 <dons> it sorts them by the order they appear in the dir listing. 
14:15:30 <dons> at least it should
14:15:41 <dbremner> shapr - wrt network stacks, I'm wondering whether something like ASN.1 could be used to specify packet encodings.
14:15:42 <dons> ah, it sorts the dir entries
14:15:45 <dons> not the files
14:15:52 <dons> SamB, how should it work?
14:15:55 <goron> dcoutts: Ok, then I will hack some further and mail a patch. 
14:16:10 * Cale updates to the latest darcs release
14:16:11 <dcoutts> goron, ok
14:16:17 <SamB> when it reads directory entries, it should sort them by filename
14:16:31 <dons> ah, ok.
14:16:41 <dons> yes, that makes sense :)
14:16:45 * dons adds a call to sort.
14:16:52 <Klaus_Dieter> hello world
14:17:23 <dons> interestingly, that code uses packed string getArgs and getDirectoryContentts.
14:17:29 <dons> Fun code to write :)
14:17:35 <SamB> so if I have a.mp3, b.dir, and c.mp3 in a directory, I'll get a.mp3, then the mp3s in b.dir, and then c.mp3...
14:17:38 <dons> (fun with a capital 'F')
14:18:00 <SamB> and no, I don't actually name my dirs with .dir
14:18:05 <Klaus_Dieter> can anyone recommend a good tutorial? I  do not get the declaration of functions what the -> int -> int -> int thingy is for and how many I have to use....
14:18:08 <dons> why not!?
14:18:11 <dons> hehe
14:18:24 <SamB> well, not in general anyway.
14:18:32 <xinming> Klaus_Dieter: hmm, yet another haskell tutorial is good
14:18:36 <SamB> I might consider it on rare occasions
14:18:51 <SamB> but I can't think of any at the moment.
14:18:57 <goron> dcoutts: One other thing: how can I invalidate the current configuration, change one option via ports, and then get new results on a make configure? Now, it just gives no output, because probably it doesn't need them. 
14:19:42 <dcoutts> goron, I have no idea how FreeBSD ports work (except for the fact that it uses make)
14:20:16 <goron> dcoutts: Ok, but the configure files can be deleted, right?
14:20:37 <goron> dcoutts: modulo configure.ac?
14:20:50 <Klaus_Dieter> xinming: well I have found the gentle introduction to haskell but cannot find there what I am looking for
14:21:05 <dcoutts> well if you delete configure then you need autotools to regenerate it
14:22:09 <xinming> Klaus_Dieter: http://www.haskell.org/bookshelf/
14:22:29 <Klaus_Dieter> *shouldh ave found this* Thank you xinming 
14:22:37 <dons> SamB, how many files are you populating the playlist with?
14:22:57 <dons> trying to get an idea of how much I should conentrate on packing the state
14:22:58 <SamB> dons: oh, around 200
14:23:11 <dons> ah. ok. I've been testing with about 3000
14:23:15 <SamB> hehe
14:23:23 <dons> ok. sort patch has landed.
14:23:24 <Cale> dons: it appears that words which spell-correct to quit work
14:23:41 <dons> how does 'exit' -> 'quit'?
14:23:44 <dons> oh. 2 edits.
14:23:46 <dons> easy.
14:24:02 <dons> @exit
14:24:03 <lambdabot> Maybe you meant: elite quit
14:24:10 <Cale> try qu1t
14:24:15 <dons> SamB, can you type: '@quat'
14:24:22 <SamB> @quat
14:24:26 <SamB> heh
14:24:27 <dons> ah ha!
14:25:08 <dons> so the spell correction by passs the authentication.
14:25:15 <dons> bypasses.
14:25:17 <SamB> oh, any particular reason why you quit if mpg123 dies for any reason at all?
14:25:28 <dons> oh. maybe I shouldn't.
14:25:48 <dons> ok, in general I can try instead to keep it up at all costs.
14:25:52 <dons> that works nicely in yi and riot.
14:25:58 <SamB> of course, you'd have to figure out how to resuscitate it...
14:26:10 <dons> often it's just io errors, and who cares about them eh?
14:26:17 <SamB> yeah really.
14:26:23 <Cale> dons: spell correct first, then check permissions :)
14:26:31 <dons> did you have a particular error SamB?/
14:26:46 <SamB> I like to set things -r if I don't want to hear them but don't want to delete them either
14:26:54 <SamB> mpg321 likes this not
14:27:05 <xinming> what does $! mean please?
14:27:28 <dons> SamB, -r ?
14:27:34 <dons> oh, minus r
14:27:43 <dons> interesting.
14:27:43 <xinming> ?
14:27:51 <SamB> dons: hmp3 is using less memory than mpg321
14:28:00 <dons> cool :)
14:28:17 <SamB> at least, near the beginning of this run it is
14:28:24 <shapr> dbremner: House uses something vaguely like that, it has Parse and Unparse typeclasses.
14:28:29 <SamB> now I'm at p72
14:28:41 <SamB> (didn't download any patches, either)
14:29:31 <shapr> dbremner: I'd like to find something higher level though.
14:30:45 <Cale> dons: fixed it :)
14:33:25 <SamB> I suppose it depends on the MP3
14:34:18 <Cale> dons: should be in your mail shortly :)
14:35:47 <dons> oh, already fixed it too.
14:35:59 <dons> silly scoping issue.
14:36:09 <dons> scope can be dangerous.
14:36:53 <Cale> I just rerun doMsg on the correction
14:37:14 <dons> oh. hmm. I have a different solution.
14:38:03 <Cale> It's possibly not the most efficient way, but it certainly makes sure that any checks that need doing get done.
14:38:22 <dons> yeah, the problem was in docmd though
14:38:31 <dons> it was taking in an arg 'c', the spell checked command
14:38:46 <dons> but in the priv check was using the raw 'cmd' from the outer scope
14:38:56 <dons> not the normalised argument
14:39:30 <SamB> dons: see! this is why it shouldn't have that in the outer scope
14:39:33 <Cale> aha
14:40:02 <cinema> dcoutts, ping
14:40:09 <dons> yeah. evil dangerous scope.
14:40:20 <dons> we should have a type to distinguish raw and clean commands
14:40:27 <dons> lambdabot is a bit untyped
14:40:33 <dcoutts> cinema, pong
14:40:37 <Cale> ah, right
14:40:48 <SamB> perhaps it should just refuse to run such commands at all if they weren't spelled correctly anyway
14:40:52 <dons> lambdabot tends to just throw strings around for everything.
14:40:58 <cinema> dcoutts, Hi, are you aware of graphviz interface ?
14:41:01 <Cale> docmd should be lifted
14:41:08 <dons> Cale, yep.
14:41:10 <cinema> dcoutts, with Cairo and GTK+
14:41:12 <eivuokko> The type inference in haskell, does the result (simple success or false) of it depend whetever you unify bunch of decls at once or "foldl"-type reduce to unify relevant pieces?
14:41:13 <Cale> It's too large to be in a where clause anyway
14:41:16 <dcoutts> cinema, graphviz is great
14:41:27 <cinema> dcoutts, at http://www.graphviz.org/News.php
14:41:37 <dons> Cale, a bit like lambdabot, it sort of grew in an organic way :)
14:42:00 <dcoutts> cinema, oh cool. I didn't know about that.
14:42:02 <Cale> IRC bots are that sort of thing :)
14:42:16 <Cale> You should see the bash version of mbot :)
14:42:27 <cinema> dcoutts, I have written a binding to Graphviz using c2hs
14:42:38 <dons> hehe
14:42:42 <cinema> dcoutts, but it is a little old now
14:43:01 <Cale> lambdabot is much nicer :)
14:43:24 <dcoutts> cinema, really, cool. I've just been outputting to .dot files and calling the dot program.
14:43:26 <cinema> dcoutts, maybe it would be a good idea to see if it is possible to create another binding with the Cairo/GTK+ interface
14:43:30 <Cale> though the fifo feedback loop trick was neat, and had me a bot up and running in an hour or two
14:43:37 <dons> @version
14:43:38 <lambdabot> lambdabot 3p180, GHC 6.5.20050806 (Linux i686)
14:43:38 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:43:47 <dcoutts> cinema, go for it. I think that'd be great.
14:44:08 <dcoutts> cinema, xerox might be interested too.
14:44:13 <dcoutts> @seen xerox
14:44:13 <lambdabot> I haven't seen xerox.
14:44:30 <cinema> dcoutts, I'll have a look at the new version, and tell you about it
14:44:38 <dcoutts> ok
14:45:27 <xinming> anyone here can help me on tail-recursion? :-/
14:45:39 <dcoutts> cinema, I use graphviz in my research work. I'm also planning to use it in a hIDE plugin for browsing module graphs.
14:46:03 <dons> SamB, I have a suspicion that memory usage in lambdabot slowly increases over time. (about 4k/s)
14:46:09 <dons> s/lambddabot/hmp3/
14:46:13 <SamB> hmm
14:46:15 <SamB> could be
14:46:16 <cinema> dcoutts, It is really nice, and would create a great HCI
14:46:22 <SamB> CPU usage seems to
14:46:26 <dons> which might be a space leak in the refresh code.
14:46:42 <dcoutts> dons, or maybe it's a time leak!
14:46:46 <SamB> heh
14:46:51 <dons> which is pretty inefficient, I think.. constructing the screen is tricksy.
14:46:54 <dons> dcouts. oooh no!
14:47:02 <xinming> hmm, I don't understand the trick. :-/
14:47:04 <xinming> :'(
14:47:04 <SamB> again, I invite people to look at my z-machine interpreter
14:47:09 <xinming> no one would help?
14:47:11 <SamB> @where ZMachine
14:47:12 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
14:47:41 <dcoutts> xinming, the trick is not to ask for people to help, but just to ask your question.
14:48:13 <tmoertel> does anybody know the dates of the 2006 Haskell Workshop?
14:48:17 <dcoutts> xinming, people typically don't reply "yes I'll help" until they've seen the question.
14:48:21 <SamB> my question is: "how do you turn Yi into the UI for a Z-machine interpreter"
14:49:10 <dons> hmm. grab hmp3, I would.
14:49:15 <dons> rather than yi
14:49:30 <dons> but maybe check yi for code when hmp3 doesn't do what you want.
14:49:37 <xinming> dcoutts: hmm, let mysum l = sum' l 0 where sum' [] s = s; sum' (x:xs) s = sum' xs $! (x+s), in this example sum' isn't understandable to me. :-/
14:49:38 <dons> but hmp3 is a bit cleaner
14:50:02 <SamB> eh, whatever.
14:50:11 <dons> @quit this time for sure
14:50:23 <dons> SamBb, @quat, if you please :)
14:50:43 <SamB> but how to implement a terminal-like UI
14:50:46 <dcoutts> xinming, in what way is it not understandable
14:51:15 <SamB> only with a fixed region at the top
14:51:23 <xinming> dcoutts: hmm, sorry, not understandable to me.
14:51:27 <dons> oh, a terminal like ui. a bit harder.
14:51:30 <dons> but not too hard
14:51:46 <dons> SamB, could you type: @quat
14:51:53 <luqui> xinming, is it the $!?
14:51:57 <SamB> @quat
14:52:02 <dons> hmm...
14:52:02 <SamB> @quat
14:52:06 <dons> did I pull the patch?
14:52:06 <xinming> luqui: not only the $! part.
14:52:12 <SamB> @quat
14:52:24 <dons> ok. hang on a tick.
14:52:24 <SamB> hmm, why didn't it work the 2nd time?
14:52:44 <xinming> sum' [] s = s; this means if it is a empty list, return 0 IMHO
14:53:12 <luqui> yeah
14:53:16 <luqui> but not exactly
14:53:25 <dons> SamB, not sure. it just ignored it.
14:53:35 <xinming> sum' (x:xs) s = sum' xs $! (x+s) <==== But here, what it will do?
14:53:47 <dons> oh. maybe it helps if I pull the patch first.
14:53:53 <SamB> hehe
14:53:55 <luqui> okay, let's say the list is [1,2]
14:54:02 <xinming> yes.
14:54:04 <dcoutts> xinming, it's being used as an 'accumulating parameter'
14:54:37 <xinming> dcoutts: an example is better. :-P
14:54:38 <luqui> sum' [1,2] 0 == sum' (sum' [2] (0+1)) == sum' (sum' (sum' [] (0+1+2)))
14:54:40 <dcoutts> xinming, it's a way of writing the function to make it tail recursive (which might make it run faster)
14:54:48 <luqui> er
14:54:50 <luqui> noj, that's wrong
14:55:18 <dcoutts> xinming, are you familiar with foldr and foldl ?
14:55:18 <xinming> dcoutts: What I don't understand is about "tail recursive" :-/
14:55:36 <luqui> sum' [1,2] 0 == sum' [2] (0+1) == sum' [] (0+1+2) == 0+1+2
14:55:37 <dcoutts> xinming, so you know what tail recursive means?
14:56:14 <xinming> dcoutts: No. Just learn haskell for 2 days. :-P, And I don't understand what tail recursive mean, searched google. But not help. 
14:56:29 <dons> SamB, yeah cpu usage is now up to 6%, and mem
14:56:29 <dons> slowly creeping.
14:56:33 <luqui> xinming, a tail recursive function is one that calls itself as its last action
14:56:43 <luqui> foo x = foo (x+1)   -- tail recursive
14:56:49 <luqui> foo x = 1 + foo x   -- not tail recursive
14:56:58 <luqui> since in the latter, the last action is "+"
14:57:24 <luqui> the compiler can optimize tail recursive functions not to use any stack space
14:57:51 <xinming> luqui: But if there is a function call, the stack will be taken.
14:57:54 <xinming> luqui: Oh,Ok,
14:58:06 <xinming> hold on please.
14:58:08 <luqui> well, not *any* stack space, but certainly much less
15:00:37 <shapr> Cale: Any idea who wrote QCExts?
15:03:23 <ulfdoz> arg, it doesn't terminat. *grml*
15:03:48 <SamB> dons: yes, it is creeping
15:04:07 <SamB> CPU at 11% and mem at 1.8%
15:04:16 <dons>  I will profile!
15:04:18 <SamB> it was at 1.2% mem earlier
15:04:24 <xinming> luqui: Is this a tail-recursive?
15:04:26 <xinming> let fun = (\a -> case a of { [] -> 0; (x:y) -> x + (\a -> fun a ) y } )
15:05:03 <dons> mines now 7.52%, after about 1.5 hrs.
15:06:06 <xinming> hmm, this
15:06:07 <xinming> let fun = (\a -> case a of { [] -> 0; (x:y) -> x + (\b -> fun b ) y } )
15:06:19 <int-e> xinming: no. the code will have to evaluate fun for the tail before it can come back and add x to the result, in the x + fun y part (\a -> fun a) y equals fun y)
15:06:22 <SamB> dons: you ought to add an uptime clock to it
15:06:33 <dons> oh, nice idea :)
15:06:39 <SamB> just don't make it leak
15:06:48 <dons> hehe
15:06:52 <dons> I'll try
15:06:55 <SamB> or maybe it ought to be a playtime clock, I'm not sure
15:07:13 <SamB> do you think you would be leaking while paused also or not?
15:07:17 * xinming is keeping trying
15:07:37 <dons> not sure yet. could be something to do with all the messages coming in
15:07:44 <dons> or could be something to do with redrawing the screen
15:07:54 <dons> (the latter is the major cost)
15:07:59 <SamB> uptime is probably safer
15:08:24 <luqui> how do I write guards on a one-liner?
15:08:37 <luqui> foo x | x == 0 = 1 | x == 1 = 2
15:08:37 <ulfdoz> Why doesn't this terminate? http://www.rafb.net/paste/results/7FslzL56.html
15:08:47 <luqui> know what I'm trying to say?
15:08:49 <dons> > let f x | x == 0 = True ; | otherwise = False in f 2
15:08:57 <luqui> okay
15:08:59 <dons> ah, no bot. silly me.
15:09:31 <luqui> thanks
15:09:35 * dons is having a hard time fixing the bot, due to cabal 
15:09:44 <dons> oh well. version hell but the discipline is good.
15:11:23 <int-e> ulfdoz: well, you only accept empty lists as a simple case
15:11:35 <dons> SamB, I tweaked the color settings. does the help menu work for you now?
15:11:47 <int-e> ulfdoz: a one-element list will be split into a one-element list and an empty list, then both will be sorted. that's not good
15:11:53 <SamB> dons: ah, now it is actually visible.
15:12:07 <SamB> though I not that the help for 'm' sticks out of the box
15:12:13 <SamB> s/not/note/
15:12:17 <bosie> hello
15:12:26 <dons> ah, ok. your term might be smaller. haven't lookked at that.
15:12:46 <SamB> mine is just 80 chars wide, yeah
15:13:21 <dons> ok, I've 102
15:13:24 <shapr> hiya bosie 
15:14:43 <ulfdoz> int-e: Thanks, I see it now.
15:14:43 <bosie> today we learned lists and how to manipulate them... but actually how do you manipulate lists of lists?
15:15:29 <dons> they're just lists too!
15:15:33 <bosie> hm
15:16:02 <bosie> but i cant change them
15:16:08 <bosie> bosie_ :: [[Int]] -> [Int] -> [[Int]]
15:16:18 <int-e> > foldr (zipWith (:)) (repeat []) [[1,2],[3,4]]
15:16:32 <dons> sigh, this is really hard for some reason: Loading plugins .........Segmentation fault
15:16:52 <bosie> for example, i have bosie_ [[1,2],[1,2]] [1] how do i say erase all 1 out of the sub elements
15:17:01 <int-e> . o O ( <lambdabot> [[1,3],[2,4]] )
15:17:41 <bosie> i have a function which deletes on Int out of the [[Int]] but map or so doesnt work with [[Int]] and [int] mixed up
15:18:45 <joelr1> does anyone know if latest cabal has a debug flag?
15:18:51 <joelr1> sort of like -p for profiling
15:19:19 <dons> -v4 ?
15:19:26 <bosie> if that made any sense ;)
15:19:30 <joelr1> dons: what does that do?
15:19:36 <bosie> shapr howdy
15:19:56 <dons> verbosity. whicih is kind of debug info, right?
15:20:17 <joelr1> dons: well, not quite. i mean for running programs inside gdb, that kind of debug info
15:20:36 <joelr1> dons: my program crashes accessing memory at address 0x0000000c
15:20:36 <bosie> anyone ?
15:20:39 <joelr1> on windows
15:21:06 <joelr1> dons: i tried running from gdb but the stack trace is not there
15:21:09 <dons> oh. you'dll need  to use -debug to get a debugging rts
15:21:17 <dons> -debug is a ghc link flag
15:21:23 <dons> so add it to ghc-options in the .caball file
15:21:26 <joelr1> dons: that is when running? 
15:21:27 <joelr1> ah
15:21:32 <joelr1> ok, will do
15:21:51 <dons> -debug has to be the flag to the application (not a library)
15:22:05 <joelr1> dons: makes sense. makes my job even easier
15:22:11 <dons> it links in a gdb/debug rts
15:22:37 <luqui> brainfart: what/where is the getArgs :: IO [String] function?
15:22:54 <dons> @index getArgs
15:23:00 <dons> bah.
15:23:05 <dons> System.Environment
15:23:07 <eivuokko> System.Environment
15:23:23 <luqui> thanks
15:23:28 <luqui> hoogle turned up nothing for that
15:23:32 <luqui> (the one at haskell.org)
15:24:03 <thou> bosie: about your function, is it like "filter"?
15:24:05 <joelr1> dons: do i need to compile it with -O? i heard somewhere that ghc generates c code then
15:24:17 <bosie> thou thats my function: bosie :: [[Int]] -> Int -> [[Int]]
15:24:39 <dons> jeolr1, you're not using -O ??!
15:24:45 <joelr1> dons: no, why?
15:24:47 <thou> bosie: you call it with a list of list of ints, and an int, and you want it to remove that int from all of the lists?
15:24:57 <joelr1> dons: not using it makes my program compile about 5 times faster
15:24:58 <bosie> yes
15:25:08 <dons> ah, but it runs 10x slower  :)0
15:25:17 <xinming> luqui: ping
15:25:21 <dons> here's an example entry for an executable in a .cabal file: ghc-options:         -Wall -fglasgow-exts -O -optc-O3 -funbox-strict-fields 
15:25:24 <joelr1> dons: ok :)
15:25:24 <luqui> xinming, pong
15:25:25 <thou> > filter (/= 3) [1, 2, 3, 4, 5]
15:25:33 <bosie> yes
15:25:36 <dons> you caan say: -fvia-C to force C compilatoin.
15:25:43 <joelr1> cool
15:25:44 <thou> bosie: ok. then do something like this:
15:25:47 <bosie> thou actually i have a list of lists of integers
15:25:57 <thou> bosie: right
15:25:59 <joelr1> dons: so the library does need to be built with -debug and -O then, right? to get a stack trace
15:26:05 <bosie> [[1,2,3],[1,2,3]] and i want to replace [1,3] of the list
15:26:06 <thou> bosie: what i just showed is just one part of the full thing
15:26:15 <dons> nope. but the application needs -debug
15:26:16 <bosie> thou yes so far i have that
15:26:21 <dons> -O is for fun. and profit.
15:26:30 <lisppaste2> bosie pasted "so far so good" at http://paste.lisp.org/display/13589
15:26:38 <bosie> thou you can see my approach in the link
15:26:45 <thou> bosie: the full thing is something like this:  map (filter (/= 3) [[1, 2, 3], [3, 4, 5], [7, 3, 2]]
15:26:55 <xinming> luqui: hmm, I understand it now, normal recursion will directly call the function, But tail recursion will calculate the temp reslut before call the itself.
15:27:04 <xinming> luqui: what does $! mean then?
15:27:47 <int-e> xinming: the $! forces the immediate evaluation of its second argument.
15:27:48 <Cale> f $! x forces x to be evaluated somewhat before calling f on it
15:28:10 <Cale> it only causes x to be evaluated as far as the top level data constructor
15:28:19 <bosie> thou the question is how i can remove [] from [[]]
15:28:37 <luqui> xinming, it is used to kill unneeded laziness
15:28:49 <bosie> iterating through [] and removing every element from [[]]. the iteration is the problem, not the removal of the int in [[]]
15:28:57 <int-e> bosie: well add a filter (not.null) around the whole thing
15:29:00 <joelr1> dons: btw, going with native haskell structures and no fps reduced garbage collection by an order of magnitude
15:29:05 <thou> bosie: annotate that post with an example of the exact inputs & outputs you want
15:29:15 * joelr1 high-fives Cale
15:29:17 <thou> bosie: i'm not sure what you're struggling with
15:29:27 <Cale> joelr1: success of some sort?
15:29:30 <Cale> :)
15:29:38 <dons> joelr1, ah. interesting.
15:29:52 <thou> bosie: a simple answer would be "concat"
15:30:03 <joelr1> Cale: sort of :) trashing memory far less (an order of magnitude less) but need to deal with some random error on windows. memory access error.
15:30:17 <lisppaste2> bosie annotated #13589 with "inputs/outputs" at http://paste.lisp.org/display/13589#1
15:30:29 <thou> bosie: let ll = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]     concat ll  (shows [1,2,3,2,3,4,3,4,5])
15:30:44 <bosie> thou and ?
15:30:54 <xinming> thanks
15:30:54 <thou> bosie: but i don't think that's what you're really talking about :)
15:31:02 <joelr1> i must be pushing the limits of science
15:31:03 <Cale> joelr1: GHC seems to suck at ForignPtr garbage collection
15:31:05 <bosie> thou unfort. not :(
15:31:10 <joelr1> i get all sorts of errors from ghc
15:31:19 <joelr1> even during compilation
15:31:22 <dons> hmm. so fps was the problem?
15:31:32 <Cale> I think it's not taking into account the size of the things which the ForeignPtrs point to
15:31:33 <thou> bosie: so i'm not sure exactly what you want
15:31:38 <joelr1> like extent too large or ghc running out of memory when compiling 
15:31:44 <dons> Cale, yep.
15:31:46 <bosie> thou remove all values from [] in [[]]
15:31:59 <dons> ah, so they're not collected. and that was the problem we thought was the problem.
15:32:12 <thou> bosie: did you try this:  map (filter (/= 3)) ll
15:32:12 <joelr1> or like right now, -optc-O3 on Windows produces a "prologue junk? ... " and a couple of assembler instructions
15:32:16 <joelr1> and a bummer
15:32:24 <dons> you can turn off that :)
15:32:28 <joelr1> dons: i don't think it was fps. i think it was all the conversion to and from Dynamic
15:32:28 <bosie> thou i can remove int in [[]] BUT i dont know how to iterate [] and apply every element on my function and get a [[]] back
15:32:28 <thou> bosie: where ll is of type [[Int]]
15:32:31 <dons> that's the mangler barfing
15:32:36 <bosie> thou yes
15:32:42 <dons> oh, Dynamic eh?
15:32:52 <bosie> thou yes but i dont know how to iterate the []
15:32:56 <joelr1> dons: turn off what? the prelude junk? but it seems like a compilation error
15:33:14 <joelr1> dons: yes, i was using it literally all over
15:33:14 <thou> bosie: can you type out an example of what you want?
15:33:15 <dons> the -optc stuff
15:33:20 <bosie> thou i just did
15:33:22 <thou> bosie: just the input and output you expect?
15:33:24 <bosie> thou in the annotation
15:33:32 <joelr1> dons: yes, the mangling error is a compilation error
15:33:34 <thou> bosie: ah, sorry, i'll reload
15:33:52 <joelr1> dons: are you suggesting not passing in -optc-O3? cause that's what i did
15:33:55 <joelr1> skipped it
15:34:08 <xinming> luqui: let mysum l = sum' l 0 where sum' [] s = s; sum' (x:xs) s = sum' xs (x+s) in mysum [1..1000000], this example will fail because (x+s) will also need stack?
15:34:31 <thou> bosie: ah, so you want to get rid of the internal lists if they're empty
15:34:36 <joelr1> XML-RPC Threatens Linux, Unix Systems
15:34:45 <bosie> thou no
15:34:48 <dons> joelr1, now I'm confused. you get the mangler error with or without -optc-O3 ?
15:34:48 <joelr1> i wonder who comes up with silly headlines/articles like this
15:34:58 <bosie> i just remove every element in [] from [[]]
15:35:09 <xinming> luqui: for small number, the mysum works correctly, But for number which is with many 0 after that, It will fail.
15:35:10 <joelr1> dons: i get the error with -optc-O3. removing that lets compilation proceed smoothly.
15:35:19 <dons> yes. that's what I was suggesting you do :)
15:35:22 <thou> oh, ok, i see now!
15:35:22 <luqui> xinming, it shuoldn't
15:35:24 <joelr1> dons: giving that option makes compilation barf and stop
15:35:29 <joelr1> dons: ok, thanks
15:35:36 <joelr1> dons: so much for -optc-O3 :(
15:35:42 <dons> it means gcc on windows is generating some asm that the mangler doesn't know how to deal with.
15:35:45 <luqui> xinming, it ought to be optimized into a stackless loop
15:35:48 <dons> that's just a flag to gcc though.
15:35:50 <thou> bosie: you want to apply your bosie function once for each element of the final list (the [1, 3] in your example)
15:35:52 <dons> -O is the more important one.
15:35:55 <Cale> bosie: removing every element from [] from [[]] will yield [[]]
15:35:58 <Cale> er
15:35:58 <bosie> for example yes
15:36:01 <Cale> bosie: removing every element in [] from [[]] will yield [[]]
15:36:03 <luqui> xinming, it doesn't work in ghci, because ghci doesn't optimize
15:36:07 <dons> which lets ghc go nuts on the code.
15:36:21 <dons> and you shold always use in production code, imo.
15:36:26 <bosie> Cale sorry what does yield mean ?
15:36:27 <xinming> luqui: hmm, do you mean it will optimized after you compiled it into native binary?
15:36:30 <joelr1> dons: right
15:36:36 <xinming> s/will/will be/
15:36:39 * dcoutts notes that Cabal does't use -O by default
15:36:40 <Cale> give, result in
15:36:45 <joelr1> dons: nuts it surely goes
15:36:46 <Cale> > [[]] \\ []
15:36:54 <Cale> no bot!
15:37:01 <joelr1> dcoutts: duncan, i went with your plain haskell structures suggestion in the end
15:37:02 <dons> it's on its way. library/darcs hell.
15:37:05 <Cale> ah
15:37:09 <joelr1> dcoutts: in the name of simplicity 
15:37:14 <dcoutts> joelr1, and it's working ok?
15:37:16 <Cale> > [[]] \\ []
15:37:18 <mbot> Add a type signature
15:37:21 <dons> hehe
15:37:22 <joelr1> dcoutts: too much time on this project already, enough tinkering
15:37:24 <Cale> > [[]] \\ [] :: [[Int]]
15:37:25 <mbot> [[]]
15:37:26 <luqui> xinming, yeah, probably. may want to throw in -O to be sure
15:37:27 <joelr1> dcoutts: i think so
15:37:27 <shapr> hi joelr1
15:37:35 * joelr1 high-fives shapr 
15:37:37 <dcoutts> joelr1, yeah, simple is best
15:37:37 <dons> prize for anyone who can think of a defaulting mechanism for @eval
15:37:42 <SamB> dons: I notice the cyan bar doesn't track the playing song anymore, ever
15:37:43 <joelr1> easy does it
15:37:48 <shapr> joelr1: You got it working?
15:37:52 * joelr1 has a dazzle-like project on tap
15:37:55 <xinming> luqui: thanks, need sleep now... :-)
15:37:59 <xinming> luqui: bye
15:38:01 <xinming> bye all.
15:38:04 <Cale> > filter (not . null) [[],[5],[1,2,3]]
15:38:06 <mbot> [[5],[1,2,3]]
15:38:06 <bosie> Cale like that: map (\xs -> map (filter (/= xs)) c) d 
15:38:06 <bosie> (c = [[]], d[] )
15:38:09 <joelr1> shapr: yes but i'm now fighting with a random mem access error on windows
15:38:16 <dons> SamB, the blue track is the playing song. the cyan bar is the cursor.
15:38:24 <SamB> dons: I know.
15:38:33 <dons> so you can scroll around without triggering a load (whichh is nice for mpg321)
15:38:51 <SamB> but if I leave it on the playing song, I'd like it to track the playing song
15:38:52 <joelr1> i should note that producing a lot of debugging output in the form of strings and sending it from multiple threads down to a single channel ups garbage by an order of magnitude
15:39:04 <Itkovian> what could cause parsec to operate fine in ghci, but not when compiled and run from the command line?
15:39:05 <dons> ah, but you think that if they're in sync, they should track together.
15:39:07 <dons> good idea, SamB.
15:39:15 <shapr> joelr1: cool, when will you have a blog entry describing your experience?
15:39:41 <Itkovian> in ghci, the parsing gives the right result, when called from the command line, it tells me that 'many' is applied to a parser that parses an empty string.
15:39:43 <dons> ±SamB, i'll add that.
15:39:49 <joelr1> shapr: just as soon as i ... 1) update typo to email me comment notifications and 2) get some sleep :) 
15:39:56 <SamB> ¬±?
15:39:59 <bosie> map (\xs -> map (filter (/= xs)) c) d is it possible to say that xs is from type num ?
15:40:01 <joelr1> shapr: slept 2 hours + 1 hour today, all during the day
15:40:15 <joelr1> shapr: my life is just starting to return to normal
15:40:19 <shapr> aww
15:40:24 <shapr> I like code binges.
15:40:27 <dons> @version
15:40:27 <mbot> lambdabot 3p180, GHC 6.4.1 (Linux i686)
15:40:27 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:40:28 <joelr1> this project has been a nightmare in a way
15:40:34 <SamB> oh, I added a README to my Z-machine interpreter
15:40:34 <dons> :S
15:40:38 <lambdabot> lambdabot 3p188, GHC 6.5.20050806 (Linux i686)
15:40:40 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
15:40:42 <joelr1> but i like it. lots of things learned
15:40:46 <dons> SamB, : @quat please
15:40:47 <joelr1> the key lesson is to be humble
15:40:50 <SamB> @quat
15:40:50 <mbot> not enough privileges
15:40:50 <lambdabot> Not enough privileges
15:41:00 <dons> hooraay.
15:41:01 <araujo> bosie, Fractional i think
15:41:04 <thou> bosie: look at foldl
15:41:11 <dons> that was a *hard* upgrade.
15:41:20 <bosie> i hate foldl :(
15:41:22 <joelr1> if i had done it with simple haskell structures from the beginning (instead of prop lists ala wxHaskell and lots of calls toDyn/fromDynamic) it would not have been hell
15:41:29 <araujo> @type map (\xs -> map (filter (/= xs)) [1,2,3])
15:41:30 <Itkovian> bosie: it's cool
15:41:30 <lambdabot> forall a. (Eq a, Num [a]) => [a] -> [[[a]]]
15:41:30 <mbot> forall a.
15:41:30 <mbot>                (Eq a, Num [a]) =>
15:41:30 <mbot>                [a] -> [[[a]]]
15:41:34 <shapr> joelr1: Yup, simplicity is speed of change.
15:41:46 <araujo> mm.. 2 bots? :-P
15:41:46 <dons> darcs conflicts borke the repo, and then Cabal was out of date, then FPS was out fo date, then lambdabot segfaulted, then I reverted and started over, and it worked
15:41:53 <araujo> bosie, why!!!?
15:41:56 <joelr1> but i had to progress through the hackerdom levels and go as high as HList to realize i needed to go back down :)
15:42:04 <bosie> araujo cos i have no idea how that beast works ;)
15:42:06 <araujo> bosie, I am actually right _now_ readin' about it :-]
15:42:12 <shapr> joelr1: Yes, simplicity is the highest art.
15:42:12 <dons> mbot: @quit
15:42:23 <thou> bosie: :-/  well, it can be used to repeatedly apply your current bosie function against an initial [[Int]]
15:42:24 <Itkovian> bosie: it just folds :-)
15:42:34 <araujo> bosie, It goes in the opposite way of foldr , 
15:42:38 <dons> ok, so now what was I doing? oh, fixing spacce leaks .
15:42:38 <araujo> @type foldr
15:42:39 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
15:42:40 <araujo> @type foldl
15:42:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:42:41 <shapr> joelr1: You'll wrap around again a few times if you keep learning the Haskell way.
15:42:48 <thou> bosie: i.e., you want a function bosie2 :: [[Int]] -> [Int] -> [[Int]]
15:42:58 <shapr> Maybe you'll wrap around laterally, but I think you get the idea.
15:42:59 <SamB> this must be why a unified collection interface never materializes
15:43:13 <bosie> araujo why not use a nested map ?
15:43:40 <dons> SamB, 13M sleep    poll     6:40 13.28% hmp3   it never stops!
15:43:44 <joelr1> shapr :-)
15:44:06 <shapr> Monads are like that. They're simplistic power.
15:44:11 <bosie> thou well so i foldl but for foldl i would have to convert [] to [[]] ?
15:44:12 <SamB> 25-32%
15:44:17 <SamB> (cpu)
15:44:26 <SamB> 2.7% mem
15:44:46 <araujo> bosie, Check how foldr's function takes as first argument the element of the list, and as second argument the base case. 
15:45:17 <araujo> bosie, foldld does the opposite, the foldl's function takes as first argument the base case and as second argument the element of the list.
15:45:32 <bosie> hm
15:46:24 <SamB> Cale: did you see I added a README?
15:47:04 <Cale> SamB: cool, I'll read it
15:47:12 <thou> bosie: using your current bosie function, and foldl, it is possible to write it very simply
15:47:12 <Cale> ah
15:47:34 <thou> bosie: with the exact inputs you typed in as an example
15:47:50 <thou> @type foldl
15:47:51 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:47:57 <Cale> SamB: (I hadn't really had the chance to play with it yet, I'd just downloaded it)
15:48:13 <thou> bosie: where it says 'a', read [[Int]]
15:48:15 <bosie> thou where would i call bosie with foldl ?
15:48:23 <SamB> yeah, but you'll have an easier time of it with a README, right?
15:48:23 <thou> bosie: and where it says 'b', read Int
15:48:31 <bosie> erm
15:48:37 <bosie> shouldnt it be the other way around?
15:48:45 <SamB> especially since it isn't far enough along to have a Main.hs
15:49:06 <thou> foldl :: ([[Int]] -> Int -> [[Int]]) -> [[Int]] -> [Int] -> [[Int]]
15:49:19 <thou> bosie: that looks ... just like what you're looking for
15:49:21 <bosie> right
15:49:24 <araujo> bosie, Check it,  foldl (-) 0 [1..3] => ((-) ((-) ((-) 0 1) 2) 3) and , foldr (-) 0 [1..3] ((-) 1 ((-) 2 ((-) 3 0)))
15:49:45 <araujo>  foldr (-) 0 [1..3] => ((-) 1 ((-) 2 ((-) 3 0)))
15:49:47 <araujo> even
15:50:05 <bosie> that makes: foldl bosie [[]] []
15:50:36 <joelr1> i just tracked down the random memory error to the external ssl code
15:50:49 <bosie> or not ;)
15:51:11 <joelr1> not a lot of info but i at least see the issue 
15:52:10 <SamB> @google haskell ssl
15:52:11 <lambdabot> http://sequence.complete.org/hwn/20050809
15:52:12 <bosie> araujo foldl (bosie) a  b 
15:52:29 <araujo> @eval foldl (flip (:)) [] "HaSkELLRuLEZ"
15:52:30 <lambdabot> "ZELuRLLEkSaH"
15:52:36 <Cale> foldr f z xs replaces each (:) in xs with f and [] with z
15:52:47 <joelr1> does this ring a bell with anyone? 
15:52:47 <joelr1> warning: Failing creating uncommitted range (7fbfc000 for 5000)
15:52:55 <Cale> http://vx.hn.org/autoshare/foldr.png is my nice picture :)
15:53:05 <SamB> @elite Haskell rules
15:53:06 <lambdabot> hA$xE1| rUlez
15:53:06 <dons> never seen that before joelr
15:53:08 <joelr1> it says HEAP: warning: Failing creating uncommitted range (7fbfc000 for 5000)
15:53:16 <joelr1> i'll search the ghc code base
15:53:35 <dons> look in rts/
15:53:38 <Cale> joelr1: you seem to have inadvertently become the resident ghc stress-tester
15:53:47 <dons> yeah!
15:53:52 <dons> @karma+ joelr1
15:53:52 <lambdabot> joelr1's karma raised to 1.
15:54:14 <dons> this undying committment to get windows working as well as unix
15:54:22 <joelr1> Cale: indeed. the pioneers are the people with arrows in their back
15:54:24 <bosie> Cale i dont get it
15:54:34 <araujo> bosie, what you try to do?
15:54:42 <Cale> bosie: the foldr thing?
15:54:48 <joelr1> now i just have to figure out how to reproduce this things for ghc folks to fix them
15:54:48 <bosie> Cale yes
15:54:53 <shapr> joelr1: The indians get monads.
15:54:55 <joelr1> or maybe i should start hacking ghc myself
15:54:56 <bosie> araujo looking at it you have the same type
15:55:19 <shapr> joelr1: yes!
15:55:25 <bosie> you pass [] and [""] and get a list back
15:55:28 <araujo> No, check, there is a subtle but *important* difference
15:55:31 <shapr> The GHC Hacker's QuickStart Guide was just created.
15:55:34 <araujo> @type foldl
15:55:36 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:55:36 <araujo> @type foldr
15:55:37 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
15:55:40 <bosie> you pass [] and [Char] and get a list back
15:55:41 <Cale> bosie: lists in Haskell are either [] or (x:xs) where x is an element and xs is another list
15:56:14 <Cale> so they kind of look like trees as depicted there, with values and [] as leaves
15:56:24 <Cale> (very unbalanced trees)
15:56:41 <int-e> @eval foldr (:) [] "HaSkELLRuLEZ"
15:56:42 <lambdabot> "HaSkELLRuLEZ"
15:56:48 <Cale> foldr (:) [] = id
15:57:05 <shapr> @pl foldr (:) []
15:57:06 <lambdabot> foldr (:) []
15:57:06 <Cale> foldr ((:) . f) [] = map f
15:57:31 <int-e> it was just meant as a companion demonstration to the foldl (flip (:)) []  above :)
15:57:36 <joelr1> shapr: but i still can't use darcs :-) 
15:57:40 <shapr> joelr1: why not?
15:57:44 <joelr1> shapr: maybe i'll wait until that happens
15:57:51 <shapr> Oh, for GHC you mean.
15:57:55 <joelr1> shapr: i thought they are still talking about creating a darcs repo for ghc
15:58:03 <shapr> darcs totally kicks butt, I wish they'd get that repo online.
15:58:23 <joelr1> how abou tthis? rings a bell?
15:58:24 <joelr1> Program received signal SIGSEGV, Segmentation fault.
15:58:25 <joelr1> 0x10012ecd in LIBEAY32_dll_iname ()
15:58:25 <joelr1> (gdb) where
15:58:25 <joelr1> #0  0x10012ecd in LIBEAY32_dll_iname ()
15:58:27 <joelr1> #1  0x00000000 in ?? ()
15:58:33 <joelr1> what the hell is dll_iname?
15:58:34 <shapr> What's EAY?
15:58:38 <joelr1> it works a few times, btw
15:58:49 <Cale> I had a strange problem with lambdabot's repo a while back which just forced me to grab a new repo altogether -- one of the patches took seemingly forever to apply.
15:58:54 <joelr1> shapr: that's libcrypto for us unix folks
15:59:05 <shapr> oh
15:59:05 <joelr1> shapr: part of openssl
15:59:28 <dons> hmm. has anyone used hp2ps recently?
15:59:34 <dons> does it work with 6.4.1?
15:59:47 <joelr1> dons: works for me
16:00:22 <dons> ok. Just compiled with -prof -auto-all, then run with -hc, then : hp2ps foo.hp ?
16:00:35 <dons> or am I missing something (I'm getting empty graphs)
16:00:51 <dons> ah, or maybe not enough ticks have gone by..
16:01:07 <joelr1> dons: again, works for me :)
16:01:10 <Cale> joelr1: does that message only occur under windows?
16:01:24 <joelr1> Cale: runs like a charm on mac osx
16:01:41 <Cale> I get the sense that it might be a windows specific message
16:01:56 <joelr1> Cale: it's not an error in ghc anyway, what it says (the iname_dll) is that it retrieves the entry point of the dll and then calls some fun in it
16:01:59 <bosie> thou i dont get how i can foldl it
16:01:59 <joelr1> i think
16:02:11 <joelr1> #1 is the within libeay32 it seems
16:02:27 <joelr1> Cale: so i know where to go on the defense with coding
16:02:40 <joelr1> Cale: need to put a layer around with lots of error checking
16:02:49 <dons> ah ha. it works. hmp3 sleeps so much that no time gets recorded unless I thrash it
16:03:24 <dons> oh, hp2ps is really cool :)
16:04:48 <bosie> how do i foldl an [Int] list, pass each element to a functino with sig:
16:04:48 <bosie> bosie :: [[Int]] -> Int -> [[Int]]
16:04:48 <bosie> and return [[Int]]
16:07:09 <dons> map
16:07:11 <dons> ?
16:08:05 <dons> joelr, some of these reports are in fact ghc bug reports that should go to glasgow-haskell-bugs@
16:08:19 <dons> thhe "warning HEAP" should certainly go there.
16:08:21 <bosie> dons the final consense of the channel is not to use map but foldl
16:08:35 <int-e> > foldl (\a b -> [b]:a) [] [1,2,3]
16:08:36 <lambdabot> [[3],[2],[1]]
16:08:53 <joelr1> ok, i'll start emailing there
16:09:04 <dons> cafe can be a bit casual, and SimonM might not be reading it
16:09:09 <thou> bosie: just do:  foldl bosie [[1,2,3,4],[2,1,3,4],[2,3,4,1],[1,4,2,3]] [1, 3]
16:09:26 <joelr1> dons: he seems to be but i'll email glasgow-haskell-bugs in the future
16:09:37 <bosie> thou  Couldn't match `Int' against `[t]' 
16:09:37 <bosie>      Expected type: Int 
16:09:37 <bosie>      Inferred type: [t] 
16:09:37 <bosie>  In the second argument of `bosie', namely `[2]' 
16:09:37 <bosie>  In the definition of `it': 
16:09:38 <bosie>      it = bosie [[1, 2, 3], [3, 4, 5], [7, 3, 2]] [2]
16:10:45 <int-e> bosie: where'd the foldl go?
16:11:08 <thou> bosie: using the "bosie" function you pasted earlier?
16:11:09 <bosie> int-e i am sorry, what ?
16:11:13 <bosie> thou yea
16:11:44 <int-e> bosie: you wanted to use foldl. if you'd write it = foldl bosie [[1, 2, 3], [3, 4, 5], [7, 3, 2]] [2]  that would be correctly type
16:11:46 <thou> bosie: if you do ":t bosie", what does it say?
16:11:49 <int-e> bosie: d
16:12:10 <bosie> bosie :: [[Int]] -> Int -> [[Int]]
16:12:25 <thou> bosie: yeah, you forgot to put 'foldl' on the front
16:12:36 <bosie> bosie_ :: [[Int]] -> [Int] -> [[Int]]
16:12:36 <bosie> bosie_ a b = foldl bosie a b
16:12:40 <bosie> thats how i tried it
16:12:43 <thou> no
16:12:53 <thou> ah
16:12:55 <bosie> no ?
16:13:10 <int-e> bosie: but then you should use bosie_, not bosie
16:13:23 <bosie> doh
16:14:05 <bosie> oh boy thats embarrassing
16:14:12 <thou> hehe
16:23:33 <bosie> what exactly does it apply to bosie ?
16:25:19 <bosie> ok i think i found that one out
16:29:35 <shapr> hi dave_m 
16:29:45 <dave_m> hi, shapr
16:29:52 <shapr> How's code?
16:30:19 <SamB> dons: it just did it again
16:30:46 <dave_m> shapr: I've been thinking about implementing Markdown in Haskell
16:31:02 <dons> SamB, did what?
16:31:05 <dons> when nuts?
16:31:08 <dons> whent.
16:31:10 <dons> went.
16:31:32 <SamB> baseline CPU is 42-50%, mem is 3.2%, and it just shot up to 100% again
16:31:36 <dons> type too fast...
16:32:03 <dons> hmm. ok. i'mm running a heap profile at the moment, so hopefull that will spot what's doing the damage
16:32:15 <SamB> hopefully
16:32:33 <dons> unless it's in the rts.. :/
16:32:34 <shapr> dave_m: Markdown doesn't look too scary at first glance.
16:33:07 <dons> mine is up to 5% cpu, and doing the 4k/s inc mem.
16:34:39 <dave_m> perhaps I'm thinking too hard about it. I'd like something more elegant than the gigantic regular expression substitutions the current one uses
16:35:24 <dave_m> just nailing down the block-level syntax is tricky
16:38:41 * Frederick is back :p
16:39:20 <SamB> yes?
16:40:47 * Frederick looks forthe algorthm somewhere on his desk
16:43:18 <mentomorph> I've defined my own bind but it clashes with preludes, how can I resolve this ? (I'd like to do "hiding prelude.>>=" but it aint possible)
16:43:31 <mentomorph> Hi, btw and thx
16:43:43 <thou> mentomorph: hiding ((>>=))
16:43:52 * Frederick found the algorithm under his notebooks
16:43:55 <mentomorph> thx
16:43:56 <Frederick> http://rafb.net/paste/results/Wcrvrs95.html
16:44:54 <SamB> hmm. I can't understand that very well.
16:45:10 <Frederick> SamB, hold I will coment out steps
16:46:02 <thou> bosie: by the way, what do you get with this:  bosie [[], [2, 3, 4]] [3]
16:46:23 <SamB> I think the problem is that you can't use italic script to indicate variables in plaintext
16:46:32 <thou> bosie: erm, make that:  bosie [[], [2, 3, 4]] 3
16:48:20 <SamB> I understand everything before V$
16:49:17 <SamB> @google fixpoint haskell
16:49:18 <lambdabot> http://haskell.org/hawiki/FixedPointCombinator
16:50:26 <Frederick> SamB, V$ is the set of empty productions
16:50:56 <SamB> oh
16:51:04 <Frederick> so for all productions that derivate empty  like A -> $ I add them to this set, generating 2 disjunct sets
16:56:49 <SamB> something like "empties cfg = Map.keys (Map.filter (any (==[Empty])) (productions cfg))"?
16:58:32 <Frederick> SamB, yes but it is also recursive for the next step
16:58:51 <SamB> lets not do any recursion yet.
16:59:07 <Frederick> this code you just gave takes all productions that derive a $ right?
16:59:08 <Frederick> oki
16:59:46 <SamB> we can do just one iteration of this and then iterate until it is all done
17:01:26 <SamB> so I get:
17:01:29 <SamB> *CFG> let cfg = run grammar "" (unlines ["termchars ab","start S","S -> aXa | bXb | $","X -> a | b | Y","Y -> $"])
17:01:30 <SamB> *CFG> empties cfg
17:01:30 <SamB> [NT 'S',NT 'Y']
17:01:55 <Frederick> yep that is it =/
17:02:07 <SamB> do I need to explain any of it?
17:02:13 <SamB> you know what any does?
17:02:21 <Frederick> I keep thinking in imperative manner dammit
17:02:35 <SamB> > any (==100) [1..10]
17:02:37 <lambdabot> False
17:02:41 <SamB> > any (==5) [1..10]
17:02:42 <lambdabot> True
17:02:47 <SamB> > [1..10]
17:02:49 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
17:03:18 <SamB> is good?
17:03:29 <Frederick> yes
17:04:04 <gzl> is > the new @eval?
17:04:23 <SamB> gzl: it is the old eval, only with new syntax
17:04:35 <SamB> the old syntax, of course, still works
17:04:41 <gzl> that's what I meant. ok. :)
17:05:18 <SamB> yeah, I was just teasing you
17:05:20 <SamB> ;-)
17:06:34 <SamB> to think, I am a native speaker of english, skipping just about every-other word in a sentance...
17:06:53 <SamB> Frederick: so whats the next part
17:07:12 <SamB> oh, at this point I'd like to show off concatMap
17:08:26 <Frederick> once the empty productions are removed we must remove productions that substitute variables, for example S -> A, A -> a we not that the first derivation adds no real information about the grammar
17:08:35 <SamB> > let f 'x' = "XX"; f 'y' = "Y" in concatMap f "xy"
17:08:37 <lambdabot> "XXY"
17:09:13 <SamB> Frederick: explain that a little better?
17:09:19 <Frederick> so we must simplify that to S -> a , there is a think we call feixo transitivo, is the set of all elements that belong to the relation
17:09:27 <Frederick> Im googling for this right now
17:09:30 <SamB> amyway, we haven't removed empty productions yet
17:09:45 <Frederick> k
17:09:58 <SamB> only found nonterminals that have them
17:10:08 <bosie> n8 and thanks guys for the help
17:12:35 <mentomorph> what's the delimiter when "hiding" several things ? and shouldn't default () default to modules functions whenever ther's an ambiguity ??
17:13:04 <SamB> lets see
17:13:10 <mentomorph> modules functions = the current module's func
17:13:16 <mentomorph> :)
17:13:21 <dave_m> mentomorph: use "hiding (x, y, z)". Just like explicit imports
17:14:28 <mentomorph> I think I've might've got it wrong on what default () does
17:14:40 * dcoutts should write about RAD with Haskell and Gtk2Hs
17:15:02 * dcoutts cooked up a viewer for his source code analysis algorithm in 4 hours
17:15:04 <dcoutts> http://haskell.org/~duncan/gtk2hs/Constraints%20Viewer.png
17:15:05 <dave_m> IIRC, default has to do with instances
17:15:10 <Frederick> SamB, now we can match these terminals against the original set of productions to remove the empty productions
17:15:25 * dcoutts goes to bed
17:15:29 <SamB> Frederick: true
17:15:57 <Frederick> but the problem is that we must match it agains the proper occurence of the rule cause if in the map we have S -> a and S -> $ we must remove the right S
17:17:01 <SamB> or we could just Map.map (filter (/=[Empty])) over productions
17:17:07 * araujo back
17:17:14 <SamB> for the thing before that
17:17:19 <Frederick> SamB, that is a dirty trick :p
17:17:24 <SamB> no it isn't
17:18:01 <SamB> its actually easier than the other way
17:18:20 <Frederick> k
17:22:33 <SamB> and then we have to do something with everything that uses the possibly-empty productions
17:22:53 <SamB> er, nonterminals
17:23:07 <SamB> something like:
17:24:12 <SamB> f [] = [[]]
17:24:59 <Frederick> what is the porpouse of this constructions? an empty list?
17:25:15 <SamB> -- f (x:xs) | x `elem` e
17:25:24 <SamB> er, I'm called away in middle of function
17:26:50 <Frederick> what does this constructions stands for?
17:30:08 <Frederick> ??
17:34:05 <Frederick> SamB, ?
17:34:14 <sh10151> man, how am I going to get three letters of reference for grad school?
17:34:27 <Frederick> sh10151, bribe someone
17:34:42 <sh10151> i've been out of school for 4 years, probably none of my undergrad profs remember me, those that do are in nongermane fields
17:35:35 <sh10151> i can't very well go to my managers and say "hey, recommend me for this program because I'd much rather study for a pittance than work for you"
17:35:44 <sh10151> it is a quandary
17:36:48 <dave_m> you could offer to keep working while you study, and then stop when you turn out not to have enough time
17:38:11 <Frederick> SamB, ?
17:39:19 * shapr grumbles and falls asleep.
17:39:52 <sh10151> maybe I will take advantage of a reorganization or move within the company
17:40:05 <sh10151> old bosses no longer have anything to lose, i will give new bosses heads up
17:40:10 <eivuokko> Why is haskell.org so slow last few days?  Might be even down now..yawn.
17:40:10 <sh10151> that might work for 2
17:43:00 <SamB> Frederick: back
17:43:08 <SamB> Frederick: that wasn't finished
17:43:17 <SamB> I probably should have written it in emacs
17:44:19 <SamB> but you know how it says "Then, each production whose right side has a variable that generates an $ production, generates an extra production, without that variable. Example A -> aB and B-> $ results in A-> a"
17:44:44 <SamB> we need to do that
17:47:07 <Frederick> well each production whose right side has a variable that generates s is given by empties
17:48:03 <SamB> say that again?
17:48:13 <Frederick> so all the productions wich have members of the empties set, generates a new set without the variable
17:48:25 <SamB> oh, yeah
17:51:01 <Frederick> so it is very much like empties right? it is another application of map filter
17:51:49 <Frederick> isnt it?
17:52:13 <int-e> na, it's more like map map filter
17:52:21 <SamB> hmm, yes it is a Map.map
17:52:23 <Frederick> int-e, how is that?
17:52:29 <SamB> this function is complicated
17:53:43 <Frederick> =/
17:54:42 <int-e> oh, actually - yes, it's more complicated. from a production x = a b c d of length n (4 in the example) you can get up to 2^n-1 new productions
17:55:26 <int-e> it gets easier if you deal with only one potentially empty nonterminal at a time, but probably less efficient, too.
17:56:01 <SamB> well, I've got something
17:56:28 <SamB> is it allowable for me to paste it?
17:56:33 <SamB> hmm, doesn't parse anyway
17:57:20 <kaol> how would I make a function that results f 'a' = 0 ... f 'z' = 25 (and the reverse too)
17:57:40 <Frederick> kala, this one I know
17:57:45 <Frederick> lemem answer!
17:58:01 <kaol> other than by typing 26 guards...
17:58:01 <SamB> Frederick: answer away
17:58:10 <SamB> kaol: relax
17:58:25 <Frederick> kaol, so I dont know :p
17:58:33 <int-e> @type Data.Char.ord
17:58:35 <lambdabot> Char -> Int
17:58:38 <int-e> @type Data.Char.chr
17:58:39 <lambdabot> Int -> Char
17:58:41 <SamB> Frederick: what do you do in python?
17:58:58 <Frederick> SamB, what do you mean?
17:59:12 <SamB> Frederick: nevermind.
17:59:19 <SamB> int-e already mentioned the functions
18:00:01 <int-e> > (ord 'z' - ord 'a', chr (ord 'a' + 26))
18:00:03 <lambdabot> (25,'{')
18:00:43 <SamB> > (ord 'z' - ord 'a', chr (ord 'a' + 25))
18:00:45 <lambdabot> (25,'z')
18:00:57 <kaol> int-e: thank you
18:02:13 <ndm> @seen shapr
18:02:14 <lambdabot> shapr is in #haskell-blah and #haskell. Last spoke 22 minutes and 55
18:02:14 <lambdabot> seconds ago.
18:02:19 <ndm> ping shapr
18:03:03 <Frederick> SamB, what did you were going to paste?
18:03:31 <SamB> oh, okay, I got it working now
18:03:52 <SamB> well, I mean it does something and it typechecks, at least
18:04:15 <lisppaste2> SamB pasted "remove empties" at http://paste.lisp.org/display/13594
18:05:02 <SamB> *CFG> let cfg = run grammar "" (unlines ["termchars ab","start S","S -> aXa | bXb | $","X -> a | b | Y","Y -> $"])
18:05:02 <SamB> *CFG> removeEmpties cfg
18:05:02 <SamB> CFG {terminals = [T 'a',T 'b'], nonterminals = [NT 'S',NT 'X',NT 'Y'], root = NT 'S', productions = {NT 'S':=[[T 'a',NT 'X',T 'a'],[T 'b',NT 'X',T 'b']],NT 'X':=[[T 'a'],[T 'b'],[NT 'Y'],[]],NT 'Y':=[]}}
18:07:05 <Frederick> just testes here
18:07:21 <int-e> SamB: what's the 'X':=[...[]] doing down there, shouldn't that get removed?
18:08:18 <Frederick> int-e, one thing is removing the production anoter thing is removing the useless symbol
18:08:49 <SamB> int-e: why?
18:09:29 <int-e> SamB: because I thought that's what removeEmpties should do.
18:10:14 <SamB> int-e: but X is used!
18:11:53 <Frederick> SamB, but I think that for let cfg = run grammar "" (unlines ["termchars ab","start S","S -> aXa | bXb | $","X -> a | Yb | Y","Y -> $"])  it isnt consistent
18:12:25 <ndm> @seen Cale
18:12:26 <lambdabot> Cale is in #haskell-overflow and #haskell. Last spoke 2 hours, 10 minutes
18:12:26 <lambdabot> and 44 seconds ago.
18:12:35 <SamB> Frederick: you think?
18:12:37 <ndm> ping Cale
18:13:43 <SamB> Frederick: what is so inconsistent about it?
18:14:06 * Frederick is wrong
18:14:37 <SamB> I admit that this doesn't remove nonterminals with no productions
18:14:45 <SamB> we should add that
18:14:49 <Frederick> SamB, no no I wasnt talking about it
18:14:53 <SamB> any idea how?
18:15:25 <SamB> oh?
18:15:31 <Frederick> it is the same ideas of emptyes but backwards isnt it? we can get the list go elemente by element
18:15:52 <int-e> Frederick: ah. you want to iterate the whole 'find empties, adapt rules, remove superfluous productions' process.
18:15:53 <Frederick> and remove when the productions matches ""
18:16:29 <Frederick> int-e, kind of, not in this exact order maybe
18:16:30 <SamB> we can iterate easily enough
18:16:30 <int-e> Frederick: I thought you'd work with a complete set of potentially empty nonterminals.
18:17:55 <Frederick> hm
18:18:18 <SamB> hmm, we probably shouldn't be removing those from the productions for the root nonterminal...
18:18:34 <Frederick> ?
18:18:54 <SamB> oh, and when we get new empty productions they aren't [Empty] but []...
18:20:00 <SamB> hmm.
18:20:22 <SamB> well.
18:21:00 <SamB> *CFG> let cfg = run grammar "" (unlines ["termchars ","start S","S -> $"])
18:21:09 <SamB> *CFG> removeEmpties cfg
18:21:09 <SamB> CFG {terminals = [], nonterminals = [NT 'S'], root = NT 'S', productions = {NT 'S':=[]}}
18:21:09 <SamB> *
18:21:09 <SamB> this isn't really correct
18:21:36 <SamB> because this grammar ought to generate ""
18:21:44 <SamB> but it doesn't
18:21:58 <lisppaste2> Frederick pasted "seems to work" at http://paste.lisp.org/display/13595
18:22:32 <SamB> I guess we'll need to use filterWithKey
18:22:43 <Frederick> well for your extreme case it fails :p
18:22:54 <SamB> @type Data.Map.filterWithKey
18:22:55 <lambdabot> forall a k.
18:22:55 <lambdabot> (Ord k) =>
18:22:55 <lambdabot> (k -> a -> Bool) -> Data.Map.Map k a -> Data.Map.Map k a
18:23:31 <SamB> er, not quite
18:23:49 <Frederick> what?
18:24:01 <SamB> mapWithKey I guess
18:24:37 <Frederick> @type Data.Map.mapWithKey
18:24:39 <lambdabot> forall b k a. (k -> a -> b) -> Data.Map.Map k a -> Data.Map.Map k
18:24:39 <lambdabot> b
18:25:08 <Frederick> this?
18:25:50 <SamB> yes
18:26:00 <SamB>     prods'   = Map.mapWithKey (\k -> if k == root cfg
18:26:05 <SamB>                                         then id
18:26:05 <SamB>                                         else filter (/=[Empty]))
18:26:05 <SamB>                               prods
18:29:07 <SamB> *CFG> let cfg = run grammar "" (unlines ["termchars ab","start S","S -> aXa | bXb | $","X -> a | Yb | Y","Y -> $"])
18:29:12 <SamB> *CFG> removeEmpties cfg
18:29:12 <SamB> CFG {terminals = [T 'a',T 'b'], nonterminals = [NT 'S',NT 'X',NT 'Y'], root = NT 'S', productions = {NT 'S':=[[T 'a',NT 'X',T 'a'],[T 'b',NT 'X',T 'b'],[Empty]],NT 'X':=[[T 'a'],[NT 'Y',T 'b'],[T 'b'],[NT 'Y'],[]],NT 'Y':=[]}}
18:29:43 <Frederick> SamB, how  is prod's ?
18:29:52 <SamB> Frederick: hmm? what?
18:30:01 <Frederick> please post the prods' line
18:30:16 <SamB> I just replaced it with four lines
18:30:51 <int-e> prods  is just  productions cfg?
18:31:08 <SamB> int-e: yes
18:31:17 <int-e> I think that's Frederick's question.
18:31:36 <int-e> or maybe not
18:31:47 <int-e> I'm off to bed, good night
18:32:19 <Frederick> got it
18:32:23 <lisppaste2> SamB annotated #13595 with "fixed removeEmpties" at http://paste.lisp.org/display/13595#1
18:32:27 <Frederick> thx int-e
18:33:39 <SamB> Frederick: okay, but you'll notice that the last production for NT 'X' in my last test run is [], not [Empty]
18:34:20 <Frederick> removeEmpties1 cfg
18:34:21 <Frederick> CFG {terminals = [T 'a',T 'b'], nonterminals = [NT 'S',NT 'X',NT 'Y'], root = NT 'S', productions = {NT 'S':=[[T 'a',NT 'X',T 'a'],[T 'b',NT 'X',T 'b'],[Empty]],NT 'X':=[[T 'a'],[NT 'Y',T 'b'],[NT 'Y']],NT 'Y':=[]}}
18:34:50 <Frederick> I think now it is consistent
18:36:15 <Frederick> yep it is
18:37:15 <SamB> hmm, what was that fixpoint function
18:37:49 <Frederick> ?
18:40:20 <Frederick> what is a fixpoint function?
18:40:28 <SamB> the one that keeps applying a function until it doesn't change its argument, that function
18:40:40 <SamB> I just wrote it again
18:40:50 <SamB> doToDeath f x = findFixedPoint (iterate f x)
18:40:51 <SamB>     where
18:40:51 <SamB>     findFixedPoint (x:y:z)
18:40:51 <SamB>         | x == y    = x
18:40:51 <SamB>         | otherwise = findFixedPoint (y:z)
18:41:07 <SamB> > iterate (+1)
18:41:08 <lambdabot>  add an instance declaration for (Show (a -> [a]))
18:41:14 <SamB> > iterate (+1) 0
18:41:16 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
18:41:16 <lambdabot> 27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,
18:41:16 <lambdabot> 51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,
18:41:16 <lambdabot> 75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
18:41:16 <lambdabot> 99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
18:41:17 <lambdabot> [24 @more lines]
18:42:14 <SamB> with that, you can say removeEmpties = doToDeath removeEmpties1
18:42:19 <ndm> exit
18:43:25 <Cale> oh, he just quit
18:43:26 <Frederick> so we got out iteration for all prods
18:43:41 <Cale> anyone know why ndm was looking for me?
18:43:50 <SamB> there is just one problem
18:44:10 <SamB> when new empty productions are generated, they aren't [Empty] but []
18:44:19 <Frederick> hm
18:44:31 <SamB> I propose we drop Empty and just use []
18:44:37 <Frederick> a ugly solution would be swao them for :p
18:44:39 <Frederick> sure
18:44:51 <SamB> because thats really what we have anyway
18:45:05 <SamB> so, can you figure out what to change?
18:45:09 <SamB> I hope so
18:45:21 <Frederick> else filter (/=[])) 
18:45:28 <Cale> huh, that last edit of Yhc/RuntimeSystemDocumentation by ndm was odd
18:45:34 <Frederick> Map.filter (any (==[])
18:45:42 <Cale> he changed the c in "code" to an s
18:45:54 <Frederick> I think that is all
18:46:08 <SamB> well, we have to change the parser a bit too
18:46:18 <SamB> or else we won't parse them that way
18:47:05 <SamB> basically, replace: 
18:47:06 <SamB> production termchars = (do x <- empty; return [x])
18:47:06 <SamB>                        <|> many (terminal termchars <|> nonterminal termchars)
18:47:37 <SamB> with:
18:47:38 <SamB> production termchars = (do empty; return [])
18:47:38 <SamB>                        <|> many (terminal termchars <|> nonterminal termchars)
18:48:40 <Frederick> done
18:49:04 <SamB> oh, and do you have "removeEmpties = doToDeath removeEmpties1"?
18:49:56 <Frederick> yes but it doesnt recognises do todeadth
18:50:11 <SamB> oh, well, I just pasted it in the channel
18:50:25 <lisppaste2> Frederick pasted "death" at http://paste.lisp.org/display/13596
18:51:17 <lisppaste2> SamB annotated #13596 with "doToDeath" at http://paste.lisp.org/display/13596#1
18:52:27 <SamB> oh, and why is that f at the toplevel instead of in removeEmpties1's where clause?
18:55:30 <Frederick> SamB, Ive copied from channel
18:56:29 <SamB> put it back in the where clause, because it needs the binding of cfg
18:57:36 <Frederick> k
18:58:29 <SamB> should load now
18:58:39 <Frederick> nope im identing wrong
18:58:46 <SamB> oh
19:01:20 <Frederick> I should align it with the |'s right?
19:01:36 <SamB> I think so
19:04:38 <lisppaste2> Frederick pasted "Is this the idea?" at http://paste.lisp.org/display/13597
19:06:32 <SamB> that is the idea, yes
19:06:43 <SamB> hmm, but you are running into the monomorhpism restriction
19:06:49 <Frederick> yep
19:07:04 <SamB> type signatures are the standard way, so...
19:07:16 <musasabi> either an explicit type signature, lambda lifting or -fno-monomorphism-restriction
19:07:55 <musasabi> Basically moving arguments around the '=' can help.
19:08:11 <SamB> just copy the sig from the error message?
19:08:20 <Frederick> k
19:08:49 <lisppaste2> Frederick pasted "Runs to the hills <o>" at http://paste.lisp.org/display/13598
19:09:02 <SamB> oh, now we need to add (Ord t, Ord nt) =>
19:09:14 <Frederick> where?
19:09:25 <SamB> right here:
19:09:27 <SamB> removeEmpties :: (Ord t, Ord nt) => CFG t nt -> CFG t nt
19:09:28 <Frederick> Ive read about => yesterday leme fund the link
19:10:01 <SamB> apparantly this function was polymorphic and we didn't even know it ;-)
19:10:52 <Frederick> great it loaded, im becaming amazed but this type checks features
19:11:55 <SamB> yeah, type errors are my favorite kind of error because the compiler can tell me when I've gotten rid of them all ;-)
19:12:04 <lisppaste2> Frederick pasted "Happy Dances" at http://paste.lisp.org/display/13599
19:12:35 <Frederick> I got 2 classes (1 hour each) about functional programming in university with a louzy teacher
19:12:41 <Frederick> and she just confused us
19:13:02 <Frederick> now Im seeing that there are more reasons to use functional languages than I could believe
19:13:23 <SamB> you are unusually perceptive
19:13:29 <Frederick> :p
19:13:51 <SamB> most people would not only CLAIM to run screaming, they would *actually* do it, if they ran into all this trouble, I think...
19:14:01 <SamB> I suppose it helps that you chose this language ;-)
19:14:39 <Frederick> my classmates are doing it in C and they are a little bit back from me on the assigment (we still have 2 weeks) and they have like 1~2k lines sources
19:14:50 <SamB> heh
19:14:56 <SamB> wow
19:15:06 <Cale> yeah, that's believable
19:15:16 <SamB> wow that they can get so far, even
19:15:25 <Frederick> When I said them I had a ~100 lines code with comments
19:15:33 <Frederick> they said man you are doomed
19:15:39 <SamB> heh
19:15:41 <Frederick> you will fail, good luck next semester
19:15:43 <SamB> secret weapon
19:15:48 <Cale> then you told them what it did?
19:15:55 <Cale> hehe
19:16:10 <Frederick> and stuff so Ive showed they the "secret weapon" and they became omfg little phucker I will hit you
19:16:27 <Cale> heh
19:16:40 <Frederick> cause the source without comments has like 70 lineas :p
19:17:11 <musasabi> Haskell makes it very hard to be productive in lines of code. "What you have just 200 lousy lines, while the java guy has 1000" (of course both have the same number of bugs / source line and implement the same thing ;)
19:17:30 <Cale> Only a factor of 5?
19:17:31 <Cale> hehe
19:17:46 <SamB> you have to explain that "yes, but my 200 lines do about 100 times as much as his 1000"
19:17:49 <fnord123> in java everyone pads lines with { and } on their own lines
19:17:58 <fnord123> and huge amounts of javadoc crap
19:18:07 <SamB> I wouldn't do the former
19:18:16 <SamB> only } would get their own lines
19:18:21 <Cale> and even if you're not padding things out, it takes a lot of typing to get anything done in Java
19:18:23 <fnord123> ew
19:18:28 <SamB> true
19:18:42 <SamB> then again, I don't write Java
19:18:43 <fnord123> c++ - java programmers represent!
19:18:48 <SamB> its tooo boooooooriiiiing
19:18:48 <musasabi> Then again Haskell code will have documentation and documentation about overall invariants takes roughly the same space loc in both languages.
19:19:06 <SamB> yes, but there's so much less to document
19:19:21 <musasabi> Thus only the 1 / 5 factor (but it varies much in practise)
19:19:21 <fnord123> good god, when i move from C++ or java and write some scheme, it's so pleasurable
19:19:32 <Cale> My literate Haskell for the scheduler was about 50% documentation, and about 1200 lines.
19:19:55 <SamB> yeah, complicated Haskell does well at 50% I think
19:20:20 <SamB> simple stuff is more like 50:50 code/whitespace
19:20:26 <Cale> yeah
19:20:43 <musasabi> Complicated Haskell without comments can be quite evil. (especially if you pass IO-actions around and have concurrency)
19:21:23 <SamB> you should look at my z-machine interpreter and tell me how evil it is
19:21:36 <SamB> @where zmachine
19:21:37 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
19:21:37 <Cale> Haskell is pretty easy to obfuscate if you try. It's hard to obfuscate when you're not trying to.
19:22:05 <SamB> Cale: unless you outsmart yourself and do too much pointless stuff
19:22:16 <SamB> (points-free stuff ;-)
19:22:38 <Cale> points-free code is clear when it's clear and not when it's not :)
19:22:41 <fnord123> i dunno about that. folding over a mapping of folds and such gets hairy, but you do end up fitting 50 lines of java into one line
19:22:56 <musasabi> The ZMachine emulator looks quite nice.
19:23:04 <Cale> I've seen some pretty hairy uses of foldl
19:23:08 <SamB> cool
19:23:17 <SamB> but it looks horrible when you run it :-(
19:23:26 <SamB> at least, if you run it on an actual story file
19:23:26 <Cale> but they generally turned out to be sensible when you thought about it
19:23:52 <SamB> on the other hand, the one I started in Python never really got past the "hello world" stage, iirc
19:23:59 <Frederick> what is ZMachine?
19:24:00 <musasabi> but they require thought if they are non-trivial.
19:24:11 <SamB> Frederick: its what Zork runs on
19:24:17 <SamB> only spelled without a dash
19:24:24 <musasabi> thus usually list comprehensions etc are much nicer.
19:24:32 <SamB> its an imaginary machine
19:24:39 <SamB> fictional, you might even say
19:24:43 <Frederick> SamB, ?
19:24:43 <fnord123> no list comprehensions in scheme apart from cond
19:24:45 <fnord123> :-/
19:25:09 <SamB> Frederick: they didn't want to write in every ASM known to man, so they came up with a VM
19:25:10 <Cale> fnord123: I thought there was an SFRI or something with them
19:25:34 <thou> SamB: you need to make a web page that says "Z machine runs interactive fiction games.  here's my interpreter"
19:25:48 <Cale> SRFI
19:25:52 <fnord123> oh i use bigloo which has rubbish srfi support
19:25:53 <thou> with a link to the if archive :)
19:26:05 <SamB> thou: but it isn't interesting to non-Haskell-junkies yet
19:26:19 <thou> but every haskell junkie asks you what z machine is :)
19:26:27 <SamB> hmm
19:26:42 <thou> unless they happen to be if junkie as well
19:26:48 <Cale> hehe
19:27:24 <Frederick> SamB, wich is the point of this machine?
19:27:25 <Ferret> Like me. :)
19:27:41 <Ferret> Big fan of IF and similar.
19:27:44 <SamB> Frederick: to let interactive fiction run on anything under the sun
19:27:56 <SamB> without having to be recompiled
19:28:06 <Frederick> SamB, http://zmachine.com/ this is a Zmachine
19:28:17 <SamB> wrong one, I'm sure
19:28:29 <SamB> for one, the .com is a dead give-away
19:28:33 <Cale> http://www.inform-fiction.org/zmachine/
19:28:35 <Ferret> I also took the effort to complete BSD adventure to 100%, which involved reading the code (it's next to impossible otherwise).  I don't count that as cheating, however, as the code is all converted from FORTRAN, partly automatically. :/
19:28:37 <Frederick> nono It says Zmachine
19:29:28 <SamB> a third one?
19:30:21 <SamB> there was the fictional IF computer, the big lightningy thingy, and now there is some kind of flying disc too?
19:31:04 <Frederick> SamB, a flying disk thrower
19:31:10 <SamB> oh, thrower
19:31:25 <Frederick> SamB, good for lazy dog owners
19:31:27 <Frederick> :p
19:31:28 <SamB> so now there are TWO wrong ones
19:32:24 <Cale> "The Gostak - An Interofgan Halpock" is a rather nice abuse of IF :)
19:32:54 <Cale> SamB: were you around when I was talking about it a while back?
19:33:05 <SamB> don't think so
19:33:13 <Cale> It starts off like:
19:33:20 <SamB> @google "The Gostak - An Interofgan Halpock"
19:33:20 <Cale> Delcot
19:33:20 <Cale> This is the delcot of tondam, where gitches frike and duscats glake. Across from a tophthed curple, a gomway deaves to
19:33:20 <Cale> kiloff and kirf, gombing a samilen to its hoff.
19:33:20 <Cale> Crenned in the loff lutt are five glauds.
19:33:21 <lambdabot> http://thedave.homelinux.org:81/cgi-bin/zann/zannchoose.pl
19:33:52 <Cale> http://www.wurb.com/if/game/1670
19:34:03 <Cale> don't look at the dictionary!
19:34:06 <SamB> reminds me of the one with a "resting"
19:34:24 <SamB> "the sun has gone" and all that
19:34:28 <Cale> :)
19:34:48 <SamB> there is a toolman inscribed here
19:36:15 <Cale> I highly recommend it for the language experience :)
19:36:46 <SamB> really, the graphics in that game are unbeatable ;-)
19:36:58 <SamB> hmm, maybe I did
19:37:05 <SamB> because I already had a copy
19:37:08 <SamB> apparantly
19:38:29 <Cale> well, you'd have to remember what a roggler was then :)
19:38:49 <SamB> I haven't played it
19:39:00 <sethk> yesterday some folks were talking about a thing called QuickTest.  I find references to it with google, but I don't find "it", itself.
19:39:01 <SamB> that is to say, I remember none of the words
19:39:12 <SamB> QuickCheck?
19:39:13 <Cale> QuickCheck?
19:39:17 <Frederick> SamB, to remove the useless symbols I can use the same schema ofremoving $ productions cant it?
19:39:29 <SamB> Frederick: eh, not quite
19:39:42 <sethk> maybe that's why I didn't find it.  :)
19:39:53 <SamB> just Map.filter (not null)
19:39:59 <SamB> er, not.null
19:40:15 <SamB> @docs Test.QuickCheck
19:40:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
19:40:25 <SamB> @google QuickCheck
19:40:26 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
19:40:34 <sethk> I see it.  But it isn't relevant to what we were talking about yesterday.  Oh, well.  :)
19:40:36 <SamB> @where QuickCheck
19:40:37 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
19:41:17 <SamB> > null []
19:41:19 <lambdabot> True
19:41:59 <Frederick> SamB, something like removeUseless = Map.filter (not.null) prods''?
19:42:36 <sethk> Appears to be useful only for checking haskell programs.  I have to test hardware.  I wonder if I could specify my hardware functionality as if it were a haskell program.  That sounds bizarre but in fact it might not be.
19:42:39 <SamB> Frederick: not quite
19:42:42 <SamB> try it, though
19:42:56 <SamB> the type system might tell you how to fix it
19:42:57 <Frederick> CFG.hs:112:38: Not in scope: `prods'''
19:43:03 <SamB> well, and that
19:44:08 <SamB> hmm, it makes me say "bal" or "da"
19:44:13 <SamB> when I say quit
19:44:21 <SamB> at least I don't have to make up the commands
19:44:25 <Frederick> ?
19:44:36 <SamB> Frederick: that game musasabi mentioned
19:45:01 <SamB> I was just running it in frotz, a really working Z-machine emulator
19:45:04 <Frederick> SamB, I want to remove the useless from cfg'' right?
19:45:14 <SamB> Frederick: well, yes.
19:45:22 <SamB> so the firt thing you need is cfg
19:45:37 <Frederick> why?
19:46:07 <Cale> >doatch at droke about palgic darf
19:46:07 <Cale> "If you're stam of those, tund a whomm one! The whomm ones are even snaver."
19:46:16 <SamB> because how are you going to do anything without it?
19:46:27 <SamB> I'm assuming that by cfg'' you meant cfg?
19:46:37 <SamB> because we don't have any cfg''
19:47:37 * SamB wishes he had an interpreter with nice scrollback but decent fonts too
19:48:02 <SamB> anyone else have any trouble with the fonts for XGlk being a bit the wrong size?
19:48:10 <Frederick> SamB, what do you run in your box? Linux?
19:48:29 <SamB> Frederick: I'm still talking about games, not haskell
19:48:42 <SamB> yes, Linux
19:51:17 <SamB> wow
19:51:39 <SamB> don't tell me quit is the only command the same?
19:51:59 <thou> @index liftM
19:52:00 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
19:52:00 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
19:52:00 <lambdabot> Control.Monad.Error, Control.Monad.List
19:52:30 <Frederick> @index Map.filter
19:52:31 <lambdabot> bzzt
19:52:38 <SamB> @index filter
19:52:39 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
19:52:53 <SamB> Frederick: what you looking for?
19:53:39 <SamB> louks a dape, eh?
19:53:52 <SamB> Please louk SPACE, huh?
19:54:08 <Frederick> SamB, Im trying to wirte remove the useless symbols so all I need to do is filter the ones associated with []
19:54:17 <Frederick> so I want to filter them :p
19:54:42 <SamB> yes
19:54:48 <SamB> > null []
19:54:49 <lambdabot> True
19:54:54 <Frederick> ?
19:56:15 <SamB> > M.filter (not . null) (M.fromList [('x', [1]), ('y', [])])
19:56:16 <lambdabot> {'x':=[1]}
19:57:25 <SamB> Frederick: do you see that?
19:57:44 <SamB> thats about what you want to do, only of course lambdabot doesn't have our types ;-)
19:58:32 <SamB> actually, you will want to notice the beginning of removeEmpties1:
19:58:47 <SamB> removeEmpties1 cfg = cfg { productions = prods'' }
19:59:11 <Frederick> SamB, this is sort of what Im trying to do (code re-usage)
19:59:12 <SamB> that part where it says "cfg { productions = prods'' }" is called "record update"
19:59:26 <SamB> you'll need to do that in yours too
20:00:11 <fworp> does haskell have a mascot?
20:00:19 <SamB> only of course prods'' will be replaced whatever expression is appropraite
20:00:22 <SamB> fworp: not yet
20:00:28 <SamB> someone wanted to adopt glenda
20:00:38 <fworp> the good witch?
20:00:44 <SamB> the bunny
20:00:47 <fworp> oh.
20:00:52 <SamB> the bunny from outer space?
20:01:00 <SamB> er, I mean bell labs?
20:01:06 * fworp shrugs
20:01:20 <SamB> also the default account name for plan9
20:01:58 <SamB> (and the plan9 mascot)
20:02:17 <SamB> @google plan9 glenda
20:02:18 <lambdabot> http://www.cs.bell-labs.com/plan9dist/glenda.html
20:02:23 <SamB> yeah, thats the page
20:02:25 <Frederick> SamB, but in order to remove useless symbols I must remove them from the last productions listr
20:02:26 <SamB> take a look
20:02:37 <SamB> Frederick: hmm?
20:02:41 <SamB> oh, yes
20:02:55 <SamB> right.
20:02:57 <Frederick> this strep of the algorithm can only happen after the removal, so I need that instance of the cfg
20:03:00 <SamB> so you need to do something like
20:03:26 <SamB> useless cfg = Map.keys (Map.filter null (productions cfg))
20:03:30 <SamB> right?
20:05:04 <Frederick> SamB, I allways get confused about how do I refer to a structure Im nor returning explicitally
20:05:23 <SamB> Frederick: well, read about records
20:05:40 <SamB> also pattern matching
20:05:41 <Cale> Frederick: with 'let' perhaps
20:07:31 <SamB> wow
20:08:11 <Cale> hm?
20:08:27 <SamB> that game
20:08:33 <Cale> yeah, it's impressive
20:08:49 <SamB> I can barely understand it at all
20:09:05 <SamB> I've got the idea that I'm some sort of livestock-keeper
20:09:11 <SamB> or something like that
20:09:23 <Cale> yeah, try to play it for a while, you'll start to reb what's heamy
20:09:45 <SamB> hmm, what does reb mean...
20:10:11 <SamB> ah, see
20:10:18 <Cale> (for a jallon, louk JALLON)
20:10:28 <SamB> yes, I figured that one out
20:10:36 <SamB> it was the only word I had to go on
20:12:51 <SamB> do I want to look at "heamy dapes", or is it too spoiler-laden?
20:13:22 <Cale> you should look at them
20:13:30 <Cale> they're mostly English anyhow
20:13:36 <SamB> true
20:14:12 <SamB> it looks like the most useful things in here might be the way the english dapes are described
20:17:45 <Cale> aha, tavidlouker :)
20:17:57 <fworp> http://66.225.200.102/Haskell.png what about a dragon as a mascot?
20:18:51 <SamB> is this the only one with its own "language"?
20:19:08 <MenTaLguY> hi, someone had earlier given me an example of using circular programming to efficiently compute a transitive closure of a map
20:19:13 <MenTaLguY> anyone happen to have a reference for that?
20:19:19 <MenTaLguY> (I've lost the original example, I'm afraid)
20:19:23 <Cale> SamB: as far as I know
20:19:30 <Cale> I'd like some more :)
20:19:42 <Korollary> MenTaLguY: did you check the logs if you remember which day ?
20:20:02 <MenTaLguY> I don't, unfortunately
20:20:07 <MenTaLguY> is it possible to search the logs?
20:20:12 <MenTaLguY> (e.g. are the googlable?)
20:22:16 <Cale> Hmm, this pilter rasks just the murgous goaves I need to malk the nayfes of jenth, but I can't just rask the goaves, it wouldn't be stam of that at all.
20:23:44 <SamB> Cale: I must have seen it mentioned in some XYZZY award ceremony transcript
20:24:33 <SamB> http://meme.b9.com/cview.html?channel=haskell&date=today
20:24:39 <SamB> @logs
20:24:40 <lambdabot> Maybe you meant: docs plugs
20:24:51 <SamB> @where logs
20:24:52 <lambdabot> I know nothing about logs.
20:25:16 <SamB> MenTaLguY: that was a link to the logs, by the way
20:25:37 <SamB> if you want to search them, you need to sign up
20:25:44 <SamB> but it can be done
20:25:55 <SamB> or you could find the plaintext versions and grep them
20:26:34 <MenTaLguY> currently trying to sign up without much luck
20:27:09 <SamB> huh
20:27:15 <MenTaLguY> are you signed up?
20:27:18 <SamB> clog: help
20:27:23 <MenTaLguY> if so, could you do a search for "transitive closure" for me?
20:27:27 <MenTaLguY> that should turn it up
20:27:30 <SamB> MenTaLguY: yeah
20:27:38 <MenTaLguY> it should be within the last three weeks
20:30:36 * SamB waits
20:31:07 <Frederick> SamB, bah Transitive Closure is the term I was looking for before just googled for it now =/
20:32:31 <SamB> structure and interpretation of computer programming has its own channel? ick.
20:32:45 <SamB> 2005/11/03
20:33:22 <SamB> <ndm>	MenTaLguY: transitive closure	01:50:25
20:33:22 <SamB> <ndm>	in haskell, using lazy evaluation, you can perform the transitive closure in O(n) instead of O(n^2)	01:50:46
20:33:22 <SamB> <ndm>	without doing any additional work	01:50:58
20:33:22 <SamB> <ndm>	you simply pass the answer to the function generating the answer	01:51:07
20:36:45 <Frederick> SamB, where can I find the info about the records?
20:37:59 <SamB> Frederick: I thought you said you had a book?
20:38:05 <SamB> @google Haskell record constructors
20:38:06 <lambdabot> http://www.haskell.org/pipermail/template-haskell/2003-February/000036.html
20:38:18 <Frederick> SamB, but the book doesnt cover them apparently =/
20:38:48 <fworp> haskells mascot cant just be an animal, it has to be some kind of side show. Like a hairy midget or conjoined walrus twins.
20:39:37 <SamB> fworp: does o'reilly DO that kind of thing?
20:40:04 <Frederick> SamB, thx a lot for th info
20:40:09 <sh10151> SamB: heck yes, especially if it involves a loofah
20:40:10 <Frederick> gtg sleep 2:30 am here
20:40:18 <sh10151> oh, wrong oreilly, sorry
20:40:32 <fworp> well if the language has already got a mascot, i dont see how they could refuse
20:40:37 <Frederick> I will read about recoeds and see it it starts to make sence, cya folks hope everyone be oki
20:40:53 <SamB> Frederick: well, you can look in the report
20:41:04 <SamB> or maybe the tutorial covers them
20:41:09 <Frederick> good | night | morning | afternoon
20:41:20 <Frederick> SamB, I got a tutorial just about them but I newed some sleep
20:41:36 <Frederick> cya folks
20:41:43 <SamB> Frederick: ah, cool!
20:42:04 <MenTaLguY> SamB: thanks .. looks like the actual message with the code was in PM, sadly
20:42:15 <MenTaLguY> though I could have sworn there was a bit of code later on
20:42:24 <MenTaLguY> I'll dig some more
20:42:36 <SamB> http://meme.b9.com/cview.html?channel=haskell&date=051103
20:43:03 <SamB> also, you at least know who to interrogate
20:57:02 <dbremner> Cale - that reminds me of Uncleftish Beholding and Riddley Walker.
22:06:22 <araujo> dons, ping!
22:06:41 <dons> pong!
22:07:05 <araujo> dons, hello there :-)
22:07:28 <araujo> dons, Could we get lambdabot into _yet_ another haskell channel? :-)
22:07:44 <dons> sure :)
22:07:46 <dons> which one?
22:07:54 <araujo> Btw, just registered #haskell.es for spanish-speakers 
22:08:00 <dons> cool!
22:08:03 <araujo> That one above :-]
22:08:05 <dons> @karma+ araujo
22:08:06 <lambdabot> araujo's karma raised to 3.
22:08:10 <araujo> WOW!
22:08:21 * araujo full of karma :-]
22:08:29 <dons> @join #haskell.es
22:09:31 <Korollary> @seen lambdabot
22:09:31 <lambdabot> Yes, I'm here. I'm in #haskell.es, #haskell.it, #gentoo-haskell, #haskell-
22:09:31 <lambdabot> overflow, #haskell-blah and #haskell
22:10:11 <dons> hmm. probably should be in #haskell.se too?
22:10:14 <ski> morning #haskell
22:10:24 <rep> evening
23:05:43 <svens> morning
23:26:01 <dons> @index touch
23:26:01 <lambdabot> bzzt
23:28:31 <Lemmih> @type GHC.Exts.touch#
23:28:32 <lambdabot> forall a.
23:28:32 <lambdabot> -> GHC.Prim.State# GHC.Prim.RealWorld
23:28:32 <lambdabot> -> GHC.Prim.State# GHC.Prim.RealWorld
23:28:36 <Lemmih> Hi dons.
23:29:36 <Lemmih> That type is wrong /-:
23:30:41 <dons> hey Lemmih
23:37:29 <stefanw> dons: hmp3 stops after playing 1 of 13 files. How can I debug that?
23:38:24 <dons> hmm. have a look at the hPutStrLns in each thread in Core.hs, and print out some things.
23:38:36 <dons> is it reproducible? (anyway, I think I introduced a bug in my last commit)
23:39:10 <dons> @index allocaBytes
23:39:10 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
23:39:27 <dons> @hoogle allocaByte
23:39:28 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO
23:39:28 <lambdabot> b
23:39:30 <stefanw> yes, it's reproducible: hmp3 does not like "Bad Religion"
23:39:36 <dons> hehe
23:39:43 <dons> is it just that one file?
23:39:53 <dons> or does it depend on the number of files in the list?
23:41:00 * stefanw is checking, but this takes some time because the first song must be played
23:41:37 <dons> you can skip through it
23:41:44 <dons> with the right arrow.
23:43:04 <stefanw> it works fine for Queen 
23:43:20 <stefanw> but now I noticed that the progress bar on dark terminals is not displayed properly
23:43:53 <dons> how so?
23:44:30 <dons> works for me. cyan on grey
23:47:14 <stefanw> ok, it works with my "regular" terminal. I probably messed something up
23:47:37 <dons> the 'refresh' isn't working yet, due to that ncurses issue you found with refresh, I suspect
23:47:42 <dons> so possibly that was the cause
23:47:50 <dons> refresh on sigwinch
23:51:41 <tuomov> sigwinch etc. is a mess because haskell doesn't have proper posix select etc.
23:52:05 <dons> yeah, it's tricky and fragile
23:53:56 <stefanw> tuomov, have you ever experienced riot taking 99% CPU time
23:54:25 * boegel boings
23:54:31 <boegel> cool, I'm all alone at work
23:55:24 <stefanw> (riot is still responsive, I should mention)
