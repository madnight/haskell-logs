00:10:52 <Oejet> Moin!
00:15:16 <dons> @yow
00:15:16 <lambdabot> Am I elected yet?
00:17:44 <ibid> you are elected to shine the channel kicking boots
00:17:47 <ibid> :)
00:20:59 <dons> @vixen shine those boots!
00:20:59 <lambdabot> let me answer that later, okay?
00:33:36 <basti_> http://www.lyricsondemand.com/onehitwonders/thesebootsaremadeforwalkinglyrics.html
01:20:52 <xerox> @yow
01:20:53 <lambdabot> If Robert Di Niro assassinates Walter Slezak, will Jodie Foster marry
01:20:53 <lambdabot> Bonzo??
01:26:33 <C-Keen> moin
02:09:16 <Maddas> xerox: Since I'm on OS X, I was thinking of using WxHaskell or HOC :-)
02:11:58 <xerox> D'oh!
02:12:28 * xerox shakes Maddas
02:13:14 <joelr> howdy
02:13:25 <malcolm_> what's HOC?
02:14:19 <basti_> there is no HSU.
02:14:20 <basti_> ^^
02:18:21 * joelr sulks
02:20:08 <joelr> my project is on the brink of failure
02:20:21 <joelr> due to extremely high memory usage
02:21:37 <malcolm_> joelr: have you profiled it to find the culprits?
02:22:25 <joelr> malcolm_: see my message on haskell-cafe
02:22:47 <joelr> do you see it?
02:27:03 <malcolm_> joelr: had a look at your message
02:27:16 <joelr> aha
02:27:51 <malcolm_> joelr: the profile you post is just a textual one.  Have you tried heap-profiling + hp2ps to visualise?
02:28:12 <joelr> malcolm_: no, would that help?
02:28:51 <joelr> malcolm_: what options would i give to the heap profiler?
02:29:03 <malcolm_> joelr: it might be able to point to the kind of data that is hanging around unnecessarily.
02:29:31 <joelr> malcolm_: what options, though? there are quite a few modifiers to -h
02:29:47 <xerox> Do you think CSE is smart enough to avoid to unwrap the datatype of 'x' (let's say 'data Wrapped a = Wrapped { unWrap :: a }') in f x = unWrap x : f x ?
02:29:59 <malcolm_> joelr: I don't know the ghc options off by heart.  hold on a mo.
02:30:53 <joelr> malcolm_: http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#retainer-prof
02:31:06 <joelr> is that what you are talking about?
02:33:22 <joelr> malcolm_: i'm running a profile by cost center first
02:33:41 <malcolm_> joelr: yeah.  You could start with a data profile -hd, which show what the data is, then a constructor profile -hc, which tells you who built it.
02:34:07 <joelr> malcolm_: ok, i'll run the data profile next
02:34:27 <xerox> > take 5 $ evalRands (fromList ifs) (mkStdGen 0)
02:34:27 <xerox> [<function>,<function>,<function>,<function>,<function>]
02:34:29 <xerox> heh.
02:34:38 <malcolm_> You can slice any segment of the graph along some more axes, e.g. "tell me who built the Data.Wibble things?"
02:34:57 <xerox> Cale: ping!
02:35:08 <joelr> malcolm_: let me get the results and upload them to my web server
02:35:18 <snowzz> hi malcolm, found ur gtk2hs debs in debian mentors, but it doesnt seem to install on my box
02:35:21 <snowzz> ghc-pkg: dependency cairo-0.9.10 doesn't exist (use --force to override)
02:35:35 <malcolm_> joelr: and more complex, "Of the Data.Wibble things built by foo and retained by bar, tell me the biographies"
02:35:38 <snowzz> this is when trying to install libghc6-gtk-dev =)
02:36:11 <joelr> malcolm_: who shows me where the things are retained?
02:37:03 <dsacode> are there good NP-problems in linear\tensor algebra that could be nicely solved using Haskell?
02:39:41 <malcolm_> joelr: A retainer profile typically shows /sets/ of retainers.  A retainer is the nearest enclosing thunk, and because of sharing, there can be many such retainers for any one data item.  If there is only one, then that is a good candidate to look closer and see why it is holding onto the data.  Sometimes a little more (or less) strictness will solve the retention problem.
02:40:25 <joelr> malcolm_: ok, so apart from the -hc and -hd runs i also need a -hr, right?
02:40:53 <malcolm_> joelr: yeah.  But it might be helpful to try each option individually before you start to combine them
02:41:59 <joelr> malcolm_: i'm not combining, just trying individual ones. except each run takes about 10 minutes
02:42:11 <joelr> still going through -hc
02:42:43 <malcolm_> joelr: I notice that ghc requires an extra option -xt to make sure you see the memory used by thread descriptors as well.
02:43:35 <malcolm_> joelr: which might be important if it turns out that e.g. threads are not being reaped properly once they have finished
02:43:43 <joelr> malcolm_: i don't think i want that since my threads do the same thing, all of them
02:43:58 <joelr> malcolm_: and how would i know that they are not being reaped properly?
02:44:14 <malcolm_> joelr: because they show up in the profile :-)
02:44:33 <joelr> which profile shows the thread descriptors?
02:45:38 <malcolm_> joelr: with the -xt option, they show up as "TSO" in any profile
02:45:56 <joelr> malcolm_: and -xt is given to the program run?
02:46:02 <joelr> or to ghc when compiling
02:46:09 <malcolm_> joelr: to the runtime
02:46:13 <joelr> because i'm compiling with -prof and -auto-all
02:46:28 <joelr> malcolm_: so how would i know that they are not properly reaped once they show up?
02:46:44 <malcolm_> joelr: I'm not saying that threads are definitely a culprit, just that we wouldn't want to ignore them as a possibility
02:47:47 <joelr> malcolm_: right, although i wonder how threads themselves can retain memory
02:47:57 <joelr> malcolm_: i'm launching less than 500, would it matter?
02:48:01 <malcolm_> joelr: If there is a large and growing spike of TSOs in the graph, that would show they are hanging around too long.  Ideally you want a pretty flat graph for just about every data object.
02:48:17 <joelr> ok, i just got the -hc run done
02:49:29 <malcolm_> joelr: I don't know the details of your application, but I could imagine that you might allocate lots of small threads each of which is supposed to die quickly, and be replaced by new ones.  Maybe yours is not like that.
02:50:35 <joelr> malcolm_: http://wagerlabs.com/logon.hc.ps.gz
02:50:47 <joelr> malcolm_: no, nine is not like that
02:51:11 <malcolm_> joelr: just looking now
02:51:40 <joelr> ./logon +RTS -p -hd, like this, right?
02:53:20 <joelr> doing that now
02:53:23 <joelr> another 10 minutes
02:53:56 <malcolm_> joelr: so there is a ~10Mb spike of stuff.  Doesn't seem _too_ bad, but you reckoned this was running out of memory on Windows?
02:54:00 <xerox> I'd suggest to remove the "sleep 10*60" from the code..
02:54:02 * xerox hides
02:54:17 <joelr> xerox: are you talking to me?
02:54:21 <joelr> malcolm_: 100%
02:54:30 <xerox> <whistle>
02:54:43 <joelr> where's the sleep that you are talking about?
02:54:48 <xerox> Just kidding.
02:55:05 <joelr> malcolm_: malloc error
02:55:09 <joelr> malcolm_: out of memory
02:55:14 <xerox> :(
02:55:39 <malcolm_> joelr: do you use the FFI to call out to C's malloc?
02:55:47 <joelr> malcolm_: oh yes
02:56:19 <malcolm_> joelr: and are you calling 'free'?
02:56:37 <joelr> hmm
02:57:15 <xerox> Gulp.
02:57:33 <joelr> i only do it at the beginning for ssl setup
02:57:40 <joelr> that can't be must stuff
02:57:46 <joelr> let me see where else i'm doing it
02:57:53 <malcolm_> joelr: It might be better to use e.g. Foreign.mallocForeignPtr, which will automatically call free from the normal Haskell garbage collector once it is no longer needed.
02:58:20 <xerox> Agreed.
02:58:46 <lisppaste2> joelr pasted "fps hGet" at http://paste.lisp.org/display/13230
02:58:52 <joelr> this deallocates, right?
02:59:05 <joelr> malcolm_: i'm certainly not calling malloc directly
03:00:26 <malcolm_> joelr: in the paste, the ForeignPtr is being returned to the caller.  Can you be sure that the caller throws it away when it has finished with it?
03:00:45 <joelr> malcolm_: this is hGet from FastPackedString
03:00:51 <joelr> malcolm_: and i'm the caller
03:01:24 <joelr> what do you mean by throwing it away? if you see my haskell-cafe post you should see the expect function where hGet is being called.
03:01:27 <joelr> do you see the post?
03:01:40 <malcolm_> joelr: yeah, I know.  OK, I'll check the post again
03:02:04 <lisppaste2> joelr annotated #13230 with "other allocations, infrequent" at http://paste.lisp.org/display/13230#1
03:02:32 <joelr> i also do this but this is just 2-3 times per script launch, notice that i'm also using FPS stuff
03:03:50 <joelr> malcolm_: http://wagerlabs.com/logon.hd.ps.gz
03:03:56 <joelr> this is from the -hd run
03:03:59 <joelr> going for -hr
03:05:46 <malcolm_> joelr: now that's weird.  Your -hd profile has a completely different shape to the -hc one.
03:06:29 <joelr> i'm looking
03:07:24 <joelr> what do you mean by different profiles?
03:08:35 <malcolm_> joelr: well, the -hc one has a single large spike.  the -hd one has lots of tiny spikes.  Did you restrict the -hd profile with any additional options?
03:10:04 <malcolm_> joelr: (note the vertical scales of the graphs are different)
03:24:56 * joelr_ had to plug in a new adsl wireless router
03:24:59 <joelr_> malcolm_: no restrictions on the -hd
03:25:35 <malcolm_> joelr: hmm.  its difficult to explain the discrepancy in shape then
03:34:43 <olliej> Anyone know how to convince ghc to not do floating point arithmetic by decoding and recoding the values?
03:38:25 <musasabi> use Double ?
03:38:33 <joelr_> malcolm_: let me post the retainer run
03:40:05 <malcolm_> joelr_: where?
03:40:20 <olliej> musasabi: then it just does the same thing for double precision numbers
03:40:26 <joelr_> malcolm_: i don't have it yet, i'll send you the link once i upload it
03:40:26 <olliej> obnoxious thing
03:41:07 <joelr_> malcolm_: i'll just zip up all the profile reports, garbage collection summaries and the heap profiles from -hc -hd and -hr runs
03:43:24 <musasabi> joelr_: your problem sounds like you are allocating values from the C heap and not freeing them.
03:43:42 <musasabi> Having e.g. 20000 threads is no problem for GHC...
03:44:19 <joelr_> malcolm_: http://wagerlabs.com/logon.hr.ps.gz
03:44:35 <joelr_> musasabi: you think so? not peak memory usage?
03:45:33 <musasabi> "69,790,544 bytes maximum residency (53 sample(s))"
03:45:40 <musasabi> hints to that direction.
03:45:45 <malcolm_> joelr_: that links seems to be corrupt - the resulting .ps is only 1Kb
03:45:54 <musasabi> Since that is only 69mb
03:48:10 <joelr_> malcolm_: give me one sec
03:48:40 <joelr_> i need to redo the retainer run
03:49:18 <joelr_> musasabi: the strange thing is that i'm only dealing with FastStrings
03:49:42 <malcolm_> joelr_: you may not need to redo the run, just the conversion to a graph with hp2ps?
03:49:55 <joelr_> musasabi: i don't think it will run out of memory if i not fee 5k x 500 threads when doing the ssl handshake
03:50:10 <joelr_> on the other hand, i am using FastStrings all the time
03:50:22 <dsacode> hey, guys, is there some list of Haskell programs that solves NP-complete problems?
03:50:24 <joelr_> malcolm_: i think that run finished too quickly
03:50:33 <musasabi> joelr_: FastStrings might show up on the C heap instead of the Haskell heap. At least I think so.
03:50:34 <joelr_> malcolm_: due to an error or something
03:50:43 <musasabi> What are you using for SSL?
03:50:49 <joelr_> musasabi: how do i troubleshoot my C memory profile
03:50:54 <joelr_> musasabi: openssl
03:51:14 <joelr_> musasabi: even then i'm still using FastStrings :)
03:51:34 <joelr_> musasabi: http://paste.lisp.org/display/13230#1
03:52:43 <joelr_> musasabi: check out the hGet at the beginning of the paste
03:52:49 <joelr_> i do hGet all the time
03:52:51 <joelr_> for example
03:53:06 <xerox> Do you know of any Haskell ECC code?
03:53:38 <musasabi> joelr_: One suspect would be that you keep references to the FastStrings aroung somewhere and thus they are not freed...
03:54:11 <joelr_> musasabi: do you see my post on haskell cafe? the expect function code
03:54:18 <joelr_> musasabi: i'm not keeping them around at all
03:54:35 <joelr_> i unpickle from fps and deal with property lists afterwards
03:54:39 <joelr_> i just don't do anything with fps
03:55:03 <joelr_> but it could well be that the finalizers for the fast strings are not running
03:55:08 <joelr_> that would be a huge bummer
03:55:12 <joelr_> but how do i troubleshoot this?
03:55:38 <joelr_> malcolm_: got the hr run
03:56:14 <musasabi> joelr_: That has at least one bug.
03:56:21 <joelr_> malcolm_: please try again
03:56:26 <musasabi> mallocForeignPtrBytes vs mallocForeignPtr
03:56:28 <joelr_> the ps should be bigger now
03:56:34 <joelr_> musasabi: where? in FPS?
03:56:40 <joelr_> or in my code
03:57:39 <musasabi> it seems like fps, but then again I think fps should not have such bugs.
03:57:42 <musasabi> dons: ping
03:58:36 <malcolm_> joelr_: the retainer profile shows that launchScripts is holding on to the majority of the data.  That could be exactly what you expect, but maybe it would be worth pasting the code
03:59:20 <joelr_> malcolm_: one sec
03:59:44 <joelr_> malcolm_: not worth it. it just launches the threads in a loop
03:59:49 <malcolm_> joelr_: I do find it a bit worrying that the time taken for the -hr run was only 4 seconds, against 80+ for the -hc and -hd
04:00:12 <joelr_> let me check that (hr vs...) it surely was NOT 4 seconds
04:00:35 <xerox> Do you know of any Haskell ECC code? where ECC = Elliptic Curve Cryptography
04:00:51 <joelr_> #@@#^$%
04:01:00 <joelr_> maybe it was. checking again
04:03:11 <xs> xerox: could use openssl stuff?
04:03:21 <joelr_> musasabi: so how would i troubleshoot the malloc usage
04:03:29 <joelr_> to see if its a problem with FPS
04:03:36 <xerox> xs: do you think it's too much to try writing it in Haskell itself?
04:04:31 <xerox> xs: the FFI way could be taken in consideration too, but Haskell code would be much nicer, wouldn't it? :)
04:13:53 <joelr_> i had a wierd issue with my script run, rebuilt and rerunning
04:15:42 <joelr_> how can i profile my malloc usage?
04:15:50 <joelr_> or memory usage outside of the haskell heap
04:18:07 <xs> xerox: thing that bugged me about crypto in haskell is it's hard enough to wipe sensitive memory in c...
04:19:29 <malcolm_> joelr_: I only know of Linux-based memory profilers for C.  e.g. memprof, valgrind.
04:19:42 <xerox> xs hmm.
04:19:44 <joelr_> malcolm_: well, i'm on mac osx which is freebsd
04:19:57 <joelr_> malcolm_: maybe i have them too. need to check
04:21:09 <malcolm_> joelr_: the profile pictures you generated, were they on MacOS too?  Generating them on Windows might make a difference.
04:21:29 <joelr_> malcolm_: yes, that is all on osx
04:21:31 <malcolm_> joelr_: After all, Windows is where you have the problem, right?
04:21:49 <joelr_> malcolm_: yes but i also have 1Gb of memory and 6Gb of VM on the mac :)
04:22:12 <joelr_> i'll redo the runs on windows later on but i suspect that memory leaks are memory leaks
04:22:18 <joelr_> let me search for tools
04:22:25 <joelr_> i think shark does that on mac osx
04:22:46 <malcolm_> joelr_: is there any difference in versions between your haskell compiler on Mac vs Windows?
04:23:58 <joelr_> much better now (time wise for hr)
04:24:01 <joelr_> malcolm_: same
04:24:05 <joelr_> let me upload the hr run
04:24:49 <dons> you can explicitly run the finalizers, can't you?
04:24:56 <joelr_> yes
04:24:58 <joelr_> no
04:25:12 <dons> unsafeFinalize
04:25:18 <joelr_> dons: sorry, glad you popped up :-) i do not run them explicitly. do you suggest i do? i saw that function
04:25:30 <joelr_> malcolm_: http://wagerlabs.com/logon.hr.ps.gz
04:25:32 <dons> well, i don't know what the problem is yet :)
04:25:37 <joelr_> malcolm_: better now?
04:25:57 * joelr_ is packaging up all the stats
04:26:04 <joelr_> dons: see the last two messages on haskell-cafe
04:27:11 <malcolm_> joelr_: OK, the retainer profile at least has the same shape as the construction profile now. :-)
04:27:36 <dons> wow, i don't think i've seen such a number: 5,695,379,620 bytes allocated in the heap
04:27:47 <malcolm_> joelr_: And it seems 'connect' is the sole retainer of over half of the program data.
04:28:03 <joelr_> let me post connect
04:28:43 <lisppaste2> joelr annotated #13230 with "connect" at http://paste.lisp.org/display/13230#2
04:28:56 <joelr_> malcolm_: it saves everything into the "world"
04:30:36 <joelr_> malcolm_: it saves things into the initial state of the EngineState monad
04:31:01 <malcolm_> joelr_: So there is some "global variable" that holds onto lots of state information throughout the run of the program?
04:31:19 <joelr_> malcolm_: no, just the state of the monad for every thread
04:31:58 <malcolm_> joelr_: what is the definition of the EngineState monad?
04:32:09 <lisppaste2> joelr annotated #13230 with "EngineState and World" at http://paste.lisp.org/display/13230#3
04:33:05 <joelr_> dons: do you suggest running the finalizers?
04:33:23 <shapr> hiya malcolm_
04:33:32 <shapr> I haven't tried to rebuild 1.14 yet, I'll do that now.
04:33:35 * malcolm_ waves at shapr
04:33:50 <shapr> XmlContent looks nifty.
04:35:11 <malcolm_> shapr: I realised afterwards that the set of parser combinators I came up with for XmlContent is basically a reinvention of Parsec (but not as good :-()
04:36:03 <malcolm_> shapr: ...but what can I say?  I was in a hurry.
04:36:11 <shapr> That process happens to me often. I write a bunch of code. I generalize the code. I realize it's just like some other library, but not as good. Then I use that other library and suddenly I have 1. much less code 2. a better understanding of both my problem and the library.
04:36:22 <shapr> I think that's a good process.
04:37:48 <joelr_> malcolm_: this is the whole tarball, from all the runs http://wagerlabs.com/logon-stats.tgz
04:38:40 <Oejet> shapr: Good you're not paid by the line.
04:39:20 <malcolm_> shapr: Actually, I'm thinking of releasing a staged set of different parser combinators, like in the original Hutton Meijer tutorial paper.  First the simple string ones, then add polymorphic tokens, then state, then error-handling, etc.  But with essentially the same names for functions - only the types change.  Then it would be easy to start a project and swap to something more complicated as the need arose.
04:41:23 <shapr> Is there some way to specialize or generalize automatically?
04:41:39 <shapr> Can you always use the same names, but only the types change?
04:42:14 <malcolm_> shapr: dunno yet.  haven't written them :-)
04:42:15 <joelr_> dons: if i run the osx leaks tool on the running binary it shows that it's leaking memory like there's no tomorrow
04:42:20 * shapr grin
04:42:20 <shapr> s
04:46:02 <malcolm_> joelr_: I think we can probably be fairly confident that the problem doesn't lie directly in the Haskell heap then.  The profiles could certainly be improved (flattened out), but even as they are, they do not account for the huge leakages you are seeing.  My guess is that finalizers are not running.
04:47:14 <joelr_> malcolm_: so would you suggest inserting unsafeFinalize into the expect to see if the footprint improves?
04:47:29 <joelr_> malcolm_: should i profile with -hd -hr or -hc then?
04:48:38 <malcolm_> joelr_: not sure.  I have a suspicion (from the retainer profile) that 'connect' is being too lazy, and potentially not releasing the malloc'd memory early enough.
04:49:14 <joelr_> malcolm_: but connect just initializes the world
04:49:28 <joelr_> malcolm_: that is supplies initial state to the monad
04:50:04 <malcolm_> joelr_: I /think/ the state being supplied by connect is only partially initialised during the 'put' operation.
04:50:19 <dons> joelr_, you could aways put print statements in the finalisers, couldn't you?
04:50:45 <dons> that would be some info. however, malcolm sounds like he's on to something.
04:51:05 <malcolm_> joelr_: So the World holds onto lots of stuff that hasn't been evaluated yet, forcing the retention of any malloc'd memory needed to calculate it?
04:51:19 <joelr_> malcolm_: let me see again what i'm saving
04:52:12 <joelr_> malcolm_: you mean initial world?
04:52:24 <malcolm_> joelr_: On the graph, at about 25 secs or so, where the memory peaks, you can see the data retained by 'connect' starts to reduce.  (There is also a set of {SYSTEM,connect} that drops to zero very quickly, fifth band down.)
04:52:26 <joelr_> malcolm_: because i'm not passing much to it to be evaluated
04:52:31 <dons> joelr_, btw, did you see the ref I made to simonM's paper on high performance haskell apps?
04:52:51 <dons> it may be of interest to you, if you haven't read it yte
04:52:57 <joelr_> dons: probably not. are you talking about the web server? i've been all over that paper
04:53:04 <dons> ah ok :)
04:53:07 <dons> that's the one
04:53:28 <joelr_> how can i tell ghc to use a debug version of the malloc library when building?
04:53:50 <joelr_> cause on osx i can troubleshoot easily if i link against libDebugMalloc
04:54:56 <malcolm_> joelr_: 'connect' updates the World with ssl', tob, and fromb.  Maybe try forcing them with 'seq' before storing them?
04:55:31 <joelr_> malcolm_: these are foreign pointers, though, small chunks
04:55:48 <malcolm_> joelr_: also, userVars calculates something lazily based on 'env'?
04:56:02 <joelr_> yes, there's a list of ints, about 3k length
04:56:25 <joelr_> so even assuming that it stores that list 500 times it's still not a lot of memory
04:56:42 <malcolm_> joelr_: I would guess the ForeignPtrs probably
04:57:04 <joelr_> malcolm_: it tries to calculate a var from that list and then store that in a Data.Map which is what userVars is
04:57:24 <joelr_> malcolm_: these are returned by corresponding calls to the openssl library
04:58:35 <malcolm_> joelr_: another thing to note is that the record update   w{...} keeps the old w around with a thunk to update its value.  If you force that, it might make allocation more smooth too.  Laziness is sometimes tricky to spot.
04:59:31 <malcolm_> joelr_: let newworld = w{...};   newworld `seq` put newworld;
04:59:33 <joelr_> malcolm_: that's probably it or could be. how can i force that?
04:59:36 <joelr_> aha
05:00:20 <joelr_> malcolm_: so i do that and then do a re-run with the heap-retainer options, right? -hr?
05:00:43 <joelr_> malcolm_: i _am_ updating world quite a lot
05:01:18 <joelr_> malcolm_: or should i seq only in the connect function?
05:02:03 <joelr_> i also wonder if there's an idiom of sorts to make this easier because i will now have to go in and update all the functions that do put $ w { ... }
05:02:15 <malcolm_> joelr_: the question is how often do you /use/ the world.  If you update far more often than reading it out again, the closures will build up.  If you read more often than update, you would be fine.
05:02:33 <joelr_> malcolm_: i update it for every packet received
05:02:37 <joelr_> malcolm_: at least
05:02:54 <joelr_> malcolm_: but shouldn't that be reflected in the profile info?
05:03:24 <joelr_> i thought we figured that the problem was not in the haskell heap because the peak memory profile was not huge
05:03:27 <malcolm_> joelr_: putStrict w = w `seq` put w
05:04:02 <Maddas> xerox: oh, now I remember why I didn't do anything GUI-related. I couldn't build either WxHaskell or HOC
05:04:07 <joelr_> malcolm_: let me do this and then another -hr run
05:04:13 <joelr_> malcolm_: right?
05:04:14 <malcolm_> joelr_: yeah, but the stored data is mostly being held in malloc-land rather than the Haskell heap...
05:05:48 <dons> joelr_, which ghc are you using, btw?
05:05:54 <joelr_> 6.4.1
05:06:15 <dons> did you see the notes recently that showed foreign ptrs were around 50x faster with 6.5?
05:06:19 <joelr_> rebuilding with strictness as per malcolm
05:06:41 <joelr_> dons: is 6.5 out yet? do not remember the notes, must have been in that FPS discussion and i did not follow it thoroughly
05:06:44 <dons> s/notes/mail thread regarding packed strings?/
05:06:51 <dons> 6.5 is always out :)
05:07:22 <joelr_> dons: so you suggest gettign that from cvs?
05:07:49 <dons> no, you could try a snapshot though (nightly snapshots for linux and bsd are built)
05:08:01 <dons> though i'm not sure this is the problem you're seeing thouugh
05:08:08 <dons> your numbers look far to high
05:08:43 <joelr_> dons: i'm trashing memory like crazy. to wit...
05:09:11 <dons> right
05:09:17 <joelr_> i'm getting binary packets as fps. i'm unpacking them into haskell structures and converting those to property lists
05:09:27 <joelr_> where prop lists are these things from wxHaskell, attr := foo
05:09:52 <joelr_> with the added bonus of "converters", i.e.
05:09:53 <joelr_> instance Convertible [Prop] ServerInfo where
05:09:53 <joelr_>     convert_AB a = ServerInfo $ mergeprops a serverInfoProps
05:09:53 <joelr_>     convert_BA (ServerInfo b) = b
05:10:06 <joelr_> to convert list of [Prop] into ServerInfo and back
05:10:13 <dons> ah. ok. so you don't really need packed strings except for the byte level hackery? (which could also be done with a `normal' haskell type?)
05:10:39 <joelr_> dons: there's no way i'm redoing that, i'm fine with fps
05:10:44 <dons> ok :)
05:11:42 <joelr_> i'm putting a lot of faith in this run :)
05:11:50 <joelr_> hope it's a strictness issue
05:12:23 <joelr_> malcolm_: but how come the profile report does not show other puts retaining data?
05:12:31 <joelr_> i'm using put in other functions too
05:13:01 <malcolm_> joelr_: because the put is not retaining anything...
05:13:20 <joelr_> malcolm_: no, i mean the funs that use put
05:13:27 <joelr_> malcolm_: to update the state in the monad
05:13:32 <malcolm_> joelr_: understanding a heap profile can be a bit mind bending.  Laziness does strange things.
05:13:40 * shapr agrees
05:13:46 <shapr> Sure is cool though.
05:14:02 <joelr_> malcolm_: are you saying that it counts connect because it was the bit that created the state?
05:14:21 <joelr_> and then all the other stuff sort of dangles off of it? all other puts
05:14:26 <malcolm_> joelr_: maybe the other callers of 'put' are not storing data computed from ForeignPtrs in the World.
05:14:54 <malcolm_> joelr_: yes, connect was the creator of the thunk.
05:15:03 <joelr_> malcolm_: something is fishy because connect only stores a couple of small things in the world
05:15:29 <joelr_> expect, for example, stores the received command (computed from the parsed fps) on every call
05:15:57 <joelr_> so it puts the last command into the world every time. does that not count as retaining memory/
05:16:31 <malcolm_> Well, I have to say that in my experience of interpreting heap profiles, you need to come up with half a dozen plausible hypotheses before you discover the real culprit.  It takes perseverance.  If 'connect' is not the one, then we'll just have to keep looking.
05:18:00 <malcolm_> joelr_: 'expect' is the fourth band down in the retainer profile.  So yes, it is high on the hit list.  But it only really grows in size after the 'connect' starts shrinking.
05:19:07 <joelr_> i'm waiting for the new -hr run to complete
05:19:15 <Cale> joelr_: still tracking down memory problems?
05:19:26 <joelr_> Cale: a full scale assault!
05:19:32 <Cale> hehe
05:19:33 <joelr_> ok, it's done
05:19:46 <joelr_> malcolm_: what do you want to see? all the reports?
05:19:54 <joelr_> hp + prof + gc summary?
05:20:07 <malcolm_> joelr_: for me, just the -hr graph
05:21:23 <joelr_> http://wagerlabs.com/logon.hr.ps.gz
05:22:11 <malcolm_> joelr_: hmm.  virtually identical to previous.
05:23:10 <joelr_> looks identical to me
05:24:02 <joelr_> well, no, a few things changed
05:24:08 <shapr> malcolm_: I still had to delete the Hughes PrettyPrinter.
05:24:14 <malcolm_> joelr_: Either my hypothesis was wrong, or maybe your modification didn't really make it strict.  I've been bitten by that before.
05:24:46 <malcolm_> shapr: oops, didn't that get deleted in the darcs repo?  OK, will do now.
05:25:04 <shapr> And there's a lexical error on line 326 of Parse.hs
05:25:16 <shapr> It looks like a line continuation with an extra space after the slash.
05:25:34 <shapr> same on line 391 of Parse.hs
05:26:08 <shapr> And line 508 ..
05:26:12 * shapr is merrily fixing
05:26:20 <joelr_> i'm going bonkers
05:26:37 <shapr> and line 536
05:28:54 <malcolm_> shapr: as I recall, I needed to add space after the backslash in order to get it past cpp
05:29:24 <shapr> oh
05:29:34 <malcolm_> shapr: maybe your cpp is different
05:30:34 <malcolm_> shapr: in Haskell, you are allowed any whitespace chars between the slashes.
05:30:40 <shapr> hmm
05:30:54 <shapr> I'm just using runghc Setup.hs build
05:31:05 <shapr> I think that's calling cpphs
05:32:35 <shapr> The sun is just going down, I can see one pixel of light over the horizon. Winter days this far north are very short.
05:32:48 <shapr> Oops, pixel gone.
05:33:02 * xerox hates dead pixels
05:33:08 <malcolm_> shapr: wow.  when did the sun rise?
05:33:15 <shapr> I better get out and unicycle before it gets really dark.
05:33:33 <shapr> I don't know, I slept through it :-)
05:33:41 <beelsebob_> shapr: where're you off to today?
05:34:08 <beelsebob_> oh and... oh oh oh! I got kick up mounts... Running kick ups are next on the list
05:34:15 <shapr> I'll just be unicycling around the playgrounds and footpaths. This is a paradise for mountain unicycling. Especially with my 3" Gazz on a Large Marge rim :-)
05:34:25 * malcolm_ is thankful for sunshine at 20 degrees above the horizon
05:34:51 <joelr_> mountain unicycling?
05:34:57 * beelsebob_ is not thankful for being in an office which gets no natural light... ever
05:35:00 <beelsebob_> joelr_: yeh?
05:35:01 <joelr_> malcolm_: where are you geographically?
05:35:15 <joelr_> what's mountain unicicling
05:35:15 <shapr> joelr_: Yes, big fat tires and crazy downhill terrain.
05:35:16 <malcolm_> joelr_: York, UK
05:35:17 <beelsebob_> shapr: playgrounds?
05:35:27 * joelr_ is keeping quiet about the weather
05:35:35 <beelsebob_> do kids in sweden do some scary things that british kids don't?
05:35:36 <joelr_> i wonder if haskell user maps updated
05:35:52 <joelr_> shapr: but that's _uni_ cycling
05:35:57 <joelr_> 1 wheel downhill?!
05:35:59 <malcolm_> joelr_: where are you?  hot desert, Las Vegas?
05:36:04 <shapr> Sure, here's my ride - http://www.scannedinavian.com/images/shae-sj.png
05:36:05 <beelsebob_> joelr: and uphill too
05:36:11 <joelr_> how do i see the haskell user map?
05:36:48 <joelr_> shapr: you are nuts!
05:37:02 <beelsebob_> joelr_: there's several haskellers that do it
05:37:05 * malcolm_ wonders why beelsebob_ stays in a dark office when he has a laptop...
05:37:06 <shapr> Nah, it's fun - http://www.scannedinavian.org/~shae/unicycle/PICT3242.smaller.JPG
05:37:17 <joelr_> where's the map
05:37:28 <joelr_> i added my coordinates recently
05:37:34 <shapr> I stay in good shape and I have massive leg muscles.
05:37:40 <beelsebob_> malcolm_: the wireless connection here won't let me IRC and various other things... and it's cold outside
05:38:13 <shapr> beelsebob_: Can you ssh?
05:38:16 <malcolm_> beelsebob_: I use port-forwarding to get round that.
05:38:32 <beelsebob_> malcolm_: that would be a sensible plan wouldn't it...
05:38:42 <beelsebob_> but it doesn't really get round the cold issue
05:38:43 <shapr> joelr_: Here's me practicing jumping across gaps - http://www.scannedinavian.org/~shae/unicycle/PICT3246.smaller.JPG
05:38:44 <joelr_> @map
05:38:44 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
05:38:56 <beelsebob_> joelr_: also... look at the size of the tyre on his uike... it's designed for big bastard off road stuff
05:38:57 <shapr> joelr_: It's fun, you should try it.
05:39:05 <beelsebob_> everyone should try it... it rocks
05:39:05 <malcolm_> beelsebob_: ssh -L 55555:irc.freennode.net:6667 some.decently.connected.machine
05:39:15 <shapr> beelsebob_: Still haven't been able to afford the Endomorph yet :-(
05:39:24 <joelr_> malcolm_: check out the map, i'm there :) the north-western side of Africa
05:39:37 <beelsebob_> malcolm_: yep, indeed, I may wander... if I can remember the password to get onto VPN
05:39:58 <beelsebob_> joelr_: perfect place for unicycling then!
05:40:06 <malcolm_> joelr_: Tenerife?
05:40:10 <joelr_> yup
05:40:20 <joelr_> beelsebob_: you think so? check out the terrain...
05:40:28 * beelsebob_ notes that he's *still* not on the map
05:40:40 <joelr_> http://en.wikipedia.org/wiki/Tenerife
05:40:42 <joelr_> hehehe
05:40:55 <joelr_> how's that for a mountain-unicycling
05:40:56 <shapr> beelsebob_: c'mon, add yerself!
05:41:00 * joelr_ rolls on the floor laughing
05:41:07 <beelsebob_> shapr: I already did
05:41:11 <beelsebob_> joelr_: hang on a sec
05:41:25 <shapr> joelr_: Can I visit you? :-)
05:41:29 <joelr_> shapr: sure
05:41:43 <joelr_> shapr: you can roll down from the teide
05:41:46 <beelsebob_> joelr_: YOU STOLE OUR NATIONAL FLAG!!!!!
05:41:56 <joelr_> or better yet, you can try cycling up!
05:42:04 <joelr_> beelsebob_: what's that?
05:42:20 <beelsebob_> joelr_: that's the Scottish flag!
05:43:09 <beelsebob_> joelr_: this is where I was unicycling this summer... http://www.cs.kent.ac.uk/people/rpg/tatd2/Albums/Holiday/Holiday-Pages/Image2.html
05:43:32 <joelr_> he
05:43:37 * joelr_ is out to lunch
05:45:32 <shapr> beelsebob_: nice place to unicycle.
05:45:49 <beelsebob_> shapr: yeh... lots of terrain of varying difficulty
05:48:19 <beelsebob_> hehehehehe http://www.patmedia.net/marklevinson/cool/image.gif
05:48:23 <beelsebob_> stare at the plus
05:49:38 * shapr doesn't see anything but a pink dot.
05:50:14 <beelsebob_> a pink dot?
05:50:16 <beelsebob_> just one?
05:52:13 <malcolm_> a green dot spinning
05:52:28 <beelsebob_> yeh... tis weird
05:52:35 <beelsebob_> pink ones disapeared yet?
05:52:42 <sieni> wanha, as we say in finland
05:52:44 <shapr> I only see a pink dot.
05:52:50 <malcolm_> yup, pink ones disappear gradually from the bottom upwards
05:53:49 <shapr> I suspect it's a hardware difference. I also take Ritalin, and hear differences between mp3s and lossless encodings.
05:53:49 <sieni> well, there are other "wanha"s as well
05:54:16 <beelsebob_> shapr: you only see the ring of dots? :(
05:54:17 <beelsebob_> boring
05:54:20 <psi> shapr: do you only see one pink dot in that image?
05:54:22 <malcolm_> there's a ring of pink dots
05:54:53 * beelsebob_ sticks SICD lectures on his iPod
05:55:09 <psi> when i focus on the cross, the pink dots are replaced by a spinning green dot
05:55:16 <xerox> beelsebob_: SICP?
05:55:19 <sieni> http://www.ritsumei.ac.jp/~akitaoka/expansion.gif
05:55:38 <beelsebob_> xerox: Structure and Interpretation of Computer Programs... the purple and red book
05:55:45 <Igloo> shapr: Do you have image animation off?
05:55:55 <shapr> Igloo: oops, I did.
05:56:01 <xerox> beelsebob_: okay, I thoughts "SICD" was something differnt.
05:56:02 <shapr> Now I see the green dot! w00!
05:56:08 <sieni> Or http://www.ritsumei.ac.jp/~akitaoka/rotsnake.gif
05:56:31 <sieni> those pictures that the guy makes are really disturbing
05:56:45 <psi> sieni: it is as though you were on drugs
05:57:13 <shapr> Whoa that's cool. I'd guess it uses up the visual purple on that part of the retina?
05:57:22 <beelsebob_> http://feeds.feedburner.com/SICP
05:57:37 <beelsebob_> xerox: oh... I just saw my mistake
05:57:52 <xerox> np
05:58:03 <beelsebob_> sydlexia :(
05:58:34 <sieni> or http://www.ritsumei.ac.jp/~akitaoka/rollers.gif
05:58:44 <sieni> psi: it's more disturbing than that ;-)
05:59:32 <marcot> Hello..
06:01:52 <shapr> malcolm_: Oh, I have more problems with Parse.hs. There seem to be extra parens on lines 547 and 555, but removing them gave me "i not in scope." Is there some weird indentation happening in conditionalsect?
06:02:12 <malcolm_> shapr: looking now
06:03:15 <malcolm_> shapr: missing ( just before failP.
06:03:45 <malcolm_> shapr: I merged a CVS conflict and didn't look too carefully.  my bad.
06:04:09 <sieni> That's also very disturbing: http://www.psy.ritsumei.ac.jp/~akitaoka/donwave.gif
06:04:15 <shapr> Should I just use the cvs version? :-)
06:04:31 * shapr runs into a few more type errors.
06:04:45 * shapr gets the cvs repo
06:05:32 <shapr> The reason cvs irritates me is that I can't easily send patches from an anonymous checkout.
06:05:53 <malcolm_> shapr: You can cvs diff and email them to me.
06:06:10 <shapr> Yeah, but with darcs I can just do "darcs push"
06:06:19 <beelsebob_> should reimplemented be hyphenated?
06:06:22 <sieni> the reason, why cvs irritates me is the same, why emacs irritates me: both suck more than 20 industrial grade vacuum cleaners
06:06:28 <malcolm_> only if you have write access
06:06:41 <malcolm_> otherwise it is darcs send
06:06:49 <shapr> right, yes :-)
06:06:51 <shapr> darcs send I meant
06:07:26 <malcolm_> Hi ndm
06:07:40 <ndm> hi malcolm_
06:08:44 <joelr> malcolm_: ping
06:10:04 <malcolm_> joelr: pong
06:10:28 <joelr> regarding connect and the profile report. it shows connect retaining 5mb, am i wrong?
06:10:38 <joelr> should that just be diregarded?
06:10:50 <joelr> should that not
06:10:53 <shapr> xerox: Are you writing ECC.hs now?
06:11:39 <xerox> shapr: still thinking about it
06:11:48 <shapr> ok
06:12:09 <malcolm_> joelr: yeah, connect seems to be retaining about that.
06:12:51 <joelr> i'm also running a memory leak tool and it shows that it's not leaking much memory
06:12:57 <joelr> 30k right now
06:13:01 <shapr> Yay, 1.14 cvs builds!
06:13:06 * shapr boings cheerfully
06:13:29 <malcolm_> shapr: what are you using 1.14 for?  Blobs?
06:13:30 <joelr> i now suspect that it's a windows-only problem
06:14:00 <shapr> The magpie effect.
06:14:46 <ndm> dcoutts, you asked for a darcs repo for yhc - its detailed on the web page
06:14:55 <shapr> That's what Larry Wall called it in his most recent State of the Onion speech. "There's one class of user I call magpies who will go through considerable effort to use the latest and newest tools, just because they're cool."
06:15:00 <malcolm_> shapr: I hope you read the big warnings in red about how it is unfinished.
06:15:29 * shapr shrugs
06:15:37 <shapr> If I don't play with it, who will?
06:16:04 <shapr> Plus I want to see where XmlContent is going.
06:16:05 <malcolm_> shapr: that's the spirit.  so you are going to help finish it for me.  excellent
06:16:19 <shapr> Yes, by testing and whining :-)
06:16:32 <shapr> Or maybe even by fixing stuff and sending diffs if I have sufficient clue.
06:18:05 <malcolm_> shapr: the latter is preferred.  but the former is a valuable contribution too.
06:18:12 * shapr grins
06:18:29 <beelsebob_> oh oh oh oh!!!! *whines*
06:18:33 <beelsebob_> *g*
06:19:12 * joelr is now wondering if his customer would have been better served by python
06:19:59 * beelsebob_ can't explain what an EDT is :(
06:20:04 <joelr> i surely had a lot of fun with haskell but this last mile... darn, it's tough going
06:20:15 <ndm> beelsebob_: what does EDT stand for?
06:20:23 <beelsebob_> Evaluation Dependancy Tree
06:20:35 <beelsebob_> but... it's surprisingly hard to explain what that means
06:20:47 <beelsebob_> especially when it isn't a tree
06:20:52 <beelsebob_> *g*
06:21:07 <malcolm_> beelsebob_: the evaluation of x depended on evaluating y.  so y is a child of x.
06:21:38 <beelsebob_> yeh... *tries to put words in the right order on paper*
06:21:40 <beelsebob_> thanks malcolm_
06:22:36 <shapr> joelr: Of course, if you do it...
06:23:27 <joelr> shapr: do what ?
06:23:36 <Lunar^> shapr: http://www.geof.net/code/annotation/ <-- for FLM
06:23:36 <shapr> If you finish that last mile
06:23:52 <joelr> shapr: i have no other option. i need to fix this issue by monday
06:24:12 <shapr> Lunar^: neat!
06:24:44 <shapr> Speaking of which, I need to finish those last few lines of FLM and kick it out the door.
06:25:03 <shapr> I only need to write about five lines of code to finish 0.1
06:25:18 <jlouis> oy shapr
06:25:36 <jlouis> We are up to 8% code on Conjure, heh
06:25:40 <shapr> cool!
06:25:53 <shapr> Maybe I'll finish FLM 0.1 tomorrow after I've done my bookkeeping.
06:26:00 <jlouis> FLM?
06:26:08 <shapr> Fermat's Last Margin
06:26:12 <jlouis> ah
06:26:53 <jlouis> So... any jobs with Haskell in? I think my current python/perl job is going away very soon
06:26:54 <dcoutts> ndm, oh great
06:26:55 * shapr pulls conjure
06:26:57 <dcoutts> @where yhc
06:26:58 <lambdabot> www.cs.york.ac.uk/~ndm/yhc
06:27:11 <jlouis> @where conjure
06:27:11 <lambdabot> I know nothing about conjure.
06:27:14 <shapr> jlouis: You can likely get hired in the USA.
06:27:30 <jlouis> Green Card needed sorely then
06:27:51 <joelr> time to hit the beach
06:27:51 <jlouis> @help where
06:27:52 <lambdabot>  @where <key>, return element associated with key
06:28:03 <jlouis> @help modules
06:28:03 <lambdabot>  @help <command> - ask for help for <command>
06:28:05 <ndm> you want @where+
06:28:11 <joelr> first day off in the last few weeks
06:28:16 <jlouis> ah, thanks
06:28:53 <jlouis> @where+ conjure http://j.mongers.org/pub/haskell/darcs/conjure/
06:28:54 <lambdabot> conjure ~> http://j.mongers.org/pub/haskell/darcs/conjure/
06:29:05 <jlouis> @where conjure
06:29:06 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
06:29:09 <jlouis> magic!
06:29:52 <jlouis> shapr: the TODO and STYLE documents are fun to read ;)
06:30:04 <xerox> What is conjure?
06:30:22 <gour_> dcoutts: ping
06:30:34 <dcoutts> gour_, pong
06:30:43 <jlouis> xerox: attempt at a bittorrent client in Haskell
06:30:54 <kolmodin> cool
06:31:10 <gour_> dcoutts: so, have you seen that all the gnomedb should be available for mac os?
06:31:54 <dcoutts> gour_, that sounds good
06:32:30 <gour_> dcoutts: yup, it means that effort in previding those bindings will have wider usage
06:32:52 <xerox> all_lowercase_seperated_by_underscores.
06:32:54 <xerox> urgh.
06:33:05 <gour_> dcoutts: maybe we can try to achieve even gnome-level
06:33:56 <dcoutts> gour_, well I do encourage you to have a go at writing those bindings
06:34:10 <dcoutts> gour_, btw have you seen: http://haskell.org/gtk2hs/archives/2005/11/04/start-of-opengl-binding/
06:35:01 <gour> dcoutts: yes, yesterday arrived in a news feed, who is doing that?
06:35:21 <dcoutts> gour, me :-)
06:35:33 <gour> dcoutts: is opengl usable for 'general' applications?
06:35:42 <dcoutts> I guess so
06:35:44 <jlouis> xerox: I hope that doesn't scare too many away
06:35:52 <gour> dcouts: huh, you're a real gtk2hs hacker
06:36:26 <gour> dcouts: any example of usage? (i always think opengl is just for cad-like stuff)
06:36:48 <dcoutts> gour, have you seen boegel's HaskLS ? thing
06:36:48 <xerox> jlouis: what about making it a dynamical from the ground up application, with a Config.hs ?
06:36:52 <dcoutts> @where HaskLS
06:36:52 <lambdabot> I know nothing about haskls.
06:37:21 <dcoutts> @where+ HaskLS http://scannedinavian.com/~boegel/HaskLS/
06:37:21 <lambdabot> haskls ~> http://scannedinavian.com/~boegel/HaskLS/
06:37:22 <gour> dcoutts: no, what's that?
06:37:39 <musasabi> yes, please tell.
06:37:45 <dcoutts> gour, see: http://scannedinavian.org/~boegel/HaskLS/img/trees1.png
06:37:53 <jlouis> xerox: bought. Provide code or ideas, please. Your idea of having a fully dynamical application is very cool.
06:37:55 <dcoutts> gour, in the real thing it rotates in 3D
06:38:04 <musasabi> (I am @ home with fever in bed and this machine has only a text console with no cut-and-paste)
06:38:20 <shapr> musasabi: get well soon!
06:38:28 <gour> dcoutts: nice, isn't the nature wonderful?
06:38:36 <dcoutts> gour, yeah
06:38:39 <xerox> jlouis: at least for the tracker part, which is the one needing configuration, right?
06:38:42 <musasabi> well this is just a common cold, so it shouldn't last too long. Thanks :-)
06:38:44 <JKnecht> what is it everyone seems to have, grippe/flu?
06:39:03 <jlouis> xerox: there are configuration concerns all over the place
06:39:07 <xerox> gour: a certain "Benoit" folk said that economics is the same too :D
06:39:09 <musasabi> It is that time of the year.
06:39:21 <jlouis> number of open fd's in the FS for instance
06:39:21 <shapr> j'ai la grippe
06:39:21 <gour> dcoutts: for a few days i use only gnome-desktop
06:39:26 <xerox> jlouis: hmm, I see.
06:39:30 <gour> dcoutts: what's that?
06:39:34 <shapr> musasabi: Time to get a flu vaccination :-)
06:39:42 <gour> dcoutts: it looks like addiction :-)
06:40:11 <gour> shapr: no vaccination please, it's very stupid thing
06:40:27 <shapr> ?
06:40:34 <shapr> Works for me.
06:40:35 <JKnecht> in general? even polio?
06:41:14 <gour> shapr: you just put down your global immune system anticipating attack of the certain enemy
06:41:33 <gour> it's much wiser to icnrease general level of imune system
06:41:42 <shapr> Well, that's okay by me. I have enough allergies that I'd like to suppress.
06:41:50 <gour> xerox: :-)
06:42:08 * xerox is allergic to work
06:42:16 * dcoutts too
06:42:26 * shapr still wants to get paid
06:42:32 <xerox> Point.
06:42:44 <gour> JKnecht: my wife is a doctor and can confirm that vaccination does not work - people are still getting flu
06:43:02 <gour> the same as TBC, people get vaccination, but still TBC is here
06:43:08 <shapr> I want to have a wife too.
06:43:10 <JKnecht> gour: so for example you think the right global public health policy re H5N1 is to let the worlds population strengten the human immune system by experiencing it without intervention?
06:43:11 <jlouis> viruses mutate very fast. Especially flu
06:43:22 <musasabi> Not having to worry about money is much more important than gettting more money for me.
06:43:22 <basti_> => #blah
06:43:26 <shapr> gour: Yes, but the idea is to reach a symbiotic balance, like E. coli.
06:43:32 * gour likes his wife
06:43:41 <shapr> gour: Yes, I want my own :-)
06:43:46 <shapr> not yours :-)
06:44:01 <gour> shapr: homeopathy, ayurveda etc. does not work with vaccination at all
06:44:07 * sieni likes his wife as well
06:44:21 <gour> shapr: pray for it
06:44:25 <shapr> I have a candidate in mind right now. Is Angelina Jolie taken? ;-)
06:44:37 <JKnecht> likes his life. Right now, anyway.
06:44:43 <gour> shapr: it won't last too long
06:44:47 <xerox> shapr: I think wife.jpg is not a valid wife.
06:44:52 <shapr> haha
06:44:59 <gour> shapr: you said about wife, not a girlfirend, true?
06:45:10 <shapr> yes
06:45:29 <gour> shapr: then forget angelina ;)
06:45:41 <gour> dcoutts: have you seen xchat-gnome?
06:45:44 <shapr> Yeah, I was just teasing :-)
06:45:55 <gour> shapr: i was serious :-)
06:46:05 <jlouis> is angelina jolie a doctor?
06:46:28 <gour> dcoutts: it's interesting in regards to 'tree' outline interface
06:46:51 <gour> dcoutts: same like latest xchat, see e.g. http://xchat-gnome.navi.cx/screenshots.shtml
06:47:04 <gour> dcoutts: for a hiDE interface
06:48:02 <xerox> gour: what's about that?
06:48:42 <gour> xerox: hiDE?
06:48:56 <xerox> gour: no, the thing you're talking about
06:49:05 <gour> xerox: vaccination?
06:49:17 <xerox> "same like latest xchat" in what?
06:49:22 <basti_> bird flu => #blah, please ^^
06:49:50 <gour> xerox: latest xchat-2.6.0 has option for a 'tree' outline instead of tabs
06:50:07 <xerox> gour: doesn't hIDE use that TreeView too?
06:50:43 * beelsebob_ farts
06:51:36 <gour> xerox: yes, although there was discussion about regarding the interface of Leo
06:51:37 <xerox> jlouis: I've not finished thinking about Conjure.  I just need more propellent :D
06:51:40 <sieni> beelsebob_: thanks for the info
06:52:01 <beelsebob_> sieni: np
06:52:28 <gour> anyone uses gnome desktop?
06:52:29 <shapr> hiya xfchf
06:53:05 <xfchf> shapr :)
06:53:18 <shapr> learning Haskell?
06:53:33 <shapr> The sun is gone, no more light :-(
06:53:38 <shapr> And I got distracted from unicycling.
06:53:39 <shapr> dang
06:53:42 <xfchf> hmm, i still learning lisp
06:53:49 <xfchf> maybe before
06:53:53 <shapr> xfchf: Ok, if you have any questions about Haskell, feel free to ask.
06:54:07 <der_eq> gour: of course
06:54:16 <xfchf> thnx
06:55:22 <gour> der_eq: what do you use for cd/dvd burning?
06:55:24 <sieni> xfchf: what a lovely nick! easy to pronounce and all that
06:55:48 <gour> der_eq: on kde i used k3b, but now i have big problems with gnomebaker
06:55:52 <xfchf> its becouse i dont think in english, im from brazil
06:55:58 <gour> der_eq: an i better to stay with k3b?
06:56:03 <der_eq> gour: gnomebaker, but I don't burn a lot
06:56:36 <gour> der_eq: on my box (amd64, 2.6.14) it cannot blank crw, write cd.. .-(
06:56:51 <der_eq> many versions of gnomebaker are very unstable
06:57:14 <der_eq> what version do you use?
06:58:37 <gour> der_eq: 0.5
06:59:12 <gour> der_eq: that's in portage
06:59:57 <gour> metaperl: do you have some time?
07:00:14 <sieni> xfchf: what's this thinking in english? does somebody actually do that? must be a mess
07:00:44 <shapr> It's okay, I don't think in words.
07:01:20 <sieni> me neither
07:01:29 <beelsebob_> shapr: nothing wrong with night unicycling
07:01:31 <beelsebob_> just harder
07:01:36 <sieni> but even if I did, I wouldn't choose english for that :-)
07:01:43 <der_eq> gour: me too... in that case, I'd stay with k3b
07:01:46 <xfchf> sorry, but i spell characters in portuguese :) not english
07:02:12 <gour> der_eq: ok, ta, will try on gnome if it is possible to solve the problem
07:11:54 <basti_> can I pick from the smallest element over a certain bound from a Set?
07:12:01 <basti_> preferably with log(N) runtime? ^^
07:12:28 <basti_> using split maybe?
07:12:29 <jlouis> You mean the I'th order statistic?
07:12:36 <musasabi> partition + findMin
07:12:51 <basti_> rather split + findMin
07:13:22 <xerox> jlouis: I'm liking the fact that Conjure's code is very short.
07:14:31 <jlouis> xerox: short?
07:14:43 <jlouis> do elaborate
07:15:00 <xerox> The modules are compact, I'm having fun reading them.
07:15:22 <SamB> conjure's code?
07:15:28 <jlouis> @where conjure
07:15:28 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
07:15:35 <jlouis> bittorrent client in haskell ;)
07:15:38 <SamB> who or what is conjure?
07:15:44 <jlouis> though far from finished
07:15:50 <SamB> ah
07:16:06 <jlouis> things I can feed through patch(1) or darcs apply are welcome!
07:16:21 <SamB> it is probably far easier to read than the official client!
07:16:27 <SamB> (which is not saying much)
07:16:52 <jlouis> SamB: I am grinning my ass off reading code on the official client. It can probably be done much nicer than what it has in the code
07:17:12 <jlouis> xerox: read the documentation directory, and correct my spelling nits, please ;)
07:17:31 <SamB> jlouis: you can read that chickenscratch?
07:18:07 <xerox> jlouis: let me darcsget it.
07:18:32 <jlouis> SamB: yes. I am extremely good at reading bad source code ...
07:18:48 <shapr> Conjure looks nice! Much better than the source I had in Combinatorrent.
07:20:16 <xerox> This document is separated into a number of sections, each attacking a certain part of the system to treader.
07:20:18 <xerox> treader?
07:20:48 <jlouis> xerox: I must have been very sleepy
07:21:01 <jlouis> each explaining a certain part of the system to the reader
07:21:02 <xerox> haha.
07:21:12 * xerox trades
07:27:06 <basti_> ./a.out: error while loading shared libraries: libwxc-gtk2.5.3-0.9.4.so: cannot open shared object file: No such file or directory
07:27:09 <basti_> -?-
07:27:36 <SamB> each attacking a certain part of the system
07:27:53 * SamB contends contentiously
07:30:41 <jlouis> basti_: ldd -v ./a.out
07:31:16 <basti_> jlouis: ldconfig made that give way to a segfault
07:33:23 <wilx`> Wow!!
07:33:29 <wilx`> Another BT client in Haskell!?
07:33:41 <jlouis> Another!
07:33:48 <wilx`> Cool! :)
07:33:54 <jlouis> Who should I lure into joining?
07:34:12 <Maddas> Wee :-)
07:34:28 <xerox> jlouis: mail?
07:34:50 <jlouis> map pred "kmpvjtAnpohfst/psh"
07:34:52 * Oejet is still to find good software published with Bittorrent only.
07:36:42 <shapr> jlouis: I think that the SHA1 and FastPackedString bit are fun.
07:36:43 <xerox> jlouis: you got mail
07:37:01 <jlouis> xerox: cool!
07:37:25 <jlouis> shapr: okie, shall I write you on the TODO list for that?
07:37:38 <jlouis> at least people will be able to coordinate then
07:38:25 <xerox> I think we learnt from pugs that foo++ and code access are the best medicines :D
07:38:42 <xerox> ...oh, and the AUTHORS file too!
07:40:09 <shapr> and READTHEM
07:40:13 <jlouis> You will be added to AUTHORS, be sure about that. As soon as the mail survives the grey-list filter ;) (30 mins or so)
07:40:22 <shapr> Which should point to the spec
07:40:31 <jlouis> READTHEM noted
07:40:35 <shapr> I'll add the file
07:40:44 <jlouis> cool!
07:41:07 <jlouis> oh, by the way, xerox and shapr are extremely cool haskell hackers!
07:41:11 * shapr cheers
07:41:12 <xerox> haha.
07:41:19 * xerox striked!
07:44:29 <SamB> jlouis: I've sent a patch
07:45:22 <jlouis> oh, so SamB is an extremely cool haskell hacker too!
07:45:27 <jlouis> Rather nice
07:45:44 <xerox> jlouis is an extremely cool haskell hacker :)
07:46:07 <SamB> oh, I forgot to include the apidocs directory...
07:46:48 <jlouis> SamB: More patches are always good!
07:47:09 <jlouis> however, one patch per line might be a bit over-reactive
07:47:14 <wilx> Omg! Coding frezny!!!
07:47:20 <wilx> Somebody help them!
07:47:45 <shapr> I just sent three more patches.
07:48:14 <jlouis> We are just saving the young ones from Amphetamine, Hashish and alcohol by making them code stuff instead
07:48:17 <SamB> I'd suggest putting your email in _darcs/prefs/email under the repo
07:48:24 <wilx> :))
07:48:24 <shapr> yeah, me too
07:48:28 <jlouis> check
07:48:36 <shapr> Too late to save me from Amphetamines.
07:49:02 <xerox> Save me! Save me!
07:49:06 <jlouis> ... or the cronical haskell drug!
07:49:12 <wilx> :)
07:50:47 * jlouis waits impaitiently on the greylist filter
07:51:07 <xerox> JOKE!  No patches!
07:51:11 <xerox> haha.
07:51:46 <xerox> Kidding :)
07:52:15 <jlouis> ok, i'll walk away a bit from the computer out into the real world. I have to cool down a bit I think. Patches will be applied and my email is added to _darcs/prefs/email now ;)
07:52:24 <shapr> yay
07:56:52 <beelsebob_> gyargh!
07:57:01 <beelsebob_> why oh why underfull vbox
07:57:23 <beelsebob_> it's deliberately shoved the last two lines of a paragraph onto the next page and then complained!
07:59:16 <araujo> Morning!
07:59:37 <xerox> Howdy TheHunter.
07:59:48 <TheHunter> moin xerox
08:01:53 <tmoertel> /?
08:02:45 <SamB> what did other people do to conjure?
08:04:00 <shapr> tmoertel: /!
08:06:11 <shapr> hiya heisenbug
08:06:43 * beelsebob_ hands shapr a banana
08:07:44 <heisenbug> hi folks
08:08:26 <ionOS> hello everyone
08:26:06 <_andre> hello
08:28:47 <_andre> i've just wrote my first haskell program :)
08:29:06 <Cale> :)
08:29:26 <xerox> _andre: happy happy, joy joy!
08:29:29 <xerox> What is it about?
08:29:40 <Cale> what does it do?
08:30:04 <_andre> it calculates a hash so that i can locate a mailbox directory in the cyrus-imapd directory structure
08:30:05 <xerox> "it comes on irc saying the author wrote his first haskell program :)"
08:30:14 <xerox> "and answers to questions on it"
08:30:15 <xerox> hah.
08:31:14 <_andre> i had to do some "casting" though, like using fromIntegral and toInteger, and i wonder if i could get rid of them
08:31:35 <xerox> It depends on the calculation you have to do.
08:31:38 <xerox> @type (/)
08:31:39 <lambdabot> forall a. (Fractional a) => a -> a -> a
08:31:42 <xerox> @type div
08:31:43 <lambdabot> forall a. (Integral a) => a -> a -> a
08:31:51 <xerox> @type mod
08:31:52 <lambdabot> forall a. (Integral a) => a -> a -> a
08:33:45 <_andre> well, the program is at http://rafb.net/paste/results/rbSk6n97.html
08:34:04 <_andre> i think that i can't get rid of fromIntegral in bitWork, because ord returns an Int
08:36:02 <_andre> but i'm not really sure :)
08:36:19 <Cale> I don't think you need the toInteger there
08:36:36 <wilx> Ah!
08:36:52 <wilx> You cannot mix newtype with records, can you?
08:36:59 <xerox> You can.
08:37:10 <Cale> wilx: you can, just the records need to have one field
08:37:29 <wilx> Ok, that's the problem, it doesn't have just one field :)
08:37:30 <wilx> Thanks.
08:37:45 <wilx> Actually, it is the Conjure BT code :)
08:37:54 <_andre> Cale: indeed... it work. weird, i was sure i had tried that...
08:37:59 <Cale> newtype is for making a new type which is implemented in an isomorphic way to the original type
08:39:01 <xerox> @eval [1..] !! 600000
08:39:02 <lambdabot> Stack overflow
08:39:20 <Cale> why not to use !!
08:39:33 <Cale> :)
08:39:43 <xerox> Is it normal?  I mean, given that a list is el : rest, when el are evaluated and not used anymore, shouldn't them be GC-ed?
08:40:29 <Lor> It's stack overflow, not out of heap space.
08:40:35 <xerox> Right.
08:40:36 <Lor> Apparently !! isn't tail-recursive.
08:40:44 <Lor> Which is quite bizarre.
08:40:46 <Cale> (x:_) !! 0 = x
08:40:57 <Cale> (_:xs) !! n = xs !! (n-1)
08:41:07 <xerox> So it is
08:41:09 <SamB> @index Handle
08:41:09 <lambdabot> System.IO
08:41:45 <xerox> @let (x:_) `f` 0 = x; (_:xs) `f` n = xs `f` (n-1) in [1..] `f` 600000
08:41:45 <lambdabot> Unknown command, try @listcommands.
08:41:49 <xerox> @eval let (x:_) `f` 0 = x; (_:xs) `f` n = xs `f` (n-1) in [1..] `f` 600000
08:41:51 <lambdabot> Stack overflow
08:42:07 <Lor> Ah, the problem is in computing n-1
08:42:10 <Cale> yes
08:42:18 <Cale> I was about to say that :)
08:42:23 <xerox> Hm?
08:42:26 <Lor> it should be strict.
08:42:29 <Cale> xerox: you're getting large expressions like
08:42:32 <xerox> @eval let (x:_) `f` 0 = x; (_:xs) `f` ~n = xs `f` (n-1) in [1..] `f` 600000
08:42:34 <lambdabot> Stack overflow
08:42:35 <Cale> 600000 - 1 - 1 - 1 - 1...
08:42:37 <Cale> - 1
08:42:53 <Cale> which aren't getting evaluated until too late
08:43:13 <xerox> @eval let (x:_) `f` 0 = x; (_:xs) `f` n = let m = (n-1) `seq` n-1 in xs `f` (n-1) in [1..] `f` 600000
08:43:14 <lambdabot> Stack overflow
08:43:17 <xerox> Hmpf :D
08:43:30 <SamB> @eval let (x:_) `f` 0 = x; (_:xs) `f` ~n = f xs $! (n-1) in [1..] `f` 600000
08:43:31 <xerox> @eval let (x:_) `f` 0 = x; (_:xs) `f` n = f $! xs (n-1) in [1..] `f` 600000
08:43:32 <lambdabot> Stack overflow
08:43:32 <lambdabot>   The function `xs' is applied to one arguments,
08:43:32 <lambdabot>   but its type `[w_a1tw]' has none
08:43:36 <Cale> x `seq` x never does anything
08:43:44 <xerox> @eval let (x:_) `f` 0 = x; (_:xs) `f` n = f xs $! (n-1) in [1..] `f` 600000
08:43:46 <lambdabot> Stack overflow
08:44:00 <xerox> @eval let (x:_) `f` 0 = x; (_:xs) `f` n = f $! xs $! (n-1) in [1..] `f` 600000
08:44:01 <lambdabot>   Expecting a function type, but found `[w_a1tw]'
08:44:01 <lambdabot>   Expected type: a -> b
08:44:01 <lambdabot>   Inferred type: [a1]
08:44:06 <xerox> heh.
08:44:39 <musasabi> @eval  let f (x:_) 0 = x; f (_:xs) (k+1) f xs k in [1..] `f` 600000
08:44:40 <lambdabot>  parse error on input `in'
08:45:05 <musasabi> @eval let f (x:_) 0 = x; f (_:xs) (k+1) = f xs k in [1..] `f` 600000
08:45:06 <lambdabot> Stack overflow
08:45:10 <xerox> :-|
08:45:14 <SamB> @plugs let (x:_) `f` 0 = x; (_:xs) `f` ~n = xs `f` (n-1) in [1..] `f` 600000
08:45:16 <lambdabot> Stack overflow
08:45:30 <SamB> @plugs let (x:_) `f` 0 = x; (_:xs) `f` ~n = f xs $! (n-1) in [1..] `f` 600000
08:45:32 * xerox offers a @karma+ to who succeed :D
08:45:32 <lambdabot> Stack overflow
08:45:36 <musasabi> @plugs let f (x:_) 0 = x; f (_:xs) (k+1) = f xs k in [1..] `f` (600000 :: Int)
08:45:38 <lambdabot> Stack overflow
08:46:19 <paolino> @eval take 1 drop 520150
08:46:20 <lambdabot>   The function `take' is applied to three arguments,
08:46:20 <lambdabot>   but its type `Int -> [a] -> [a]' has only two
08:46:20 <lambdabot>   In the definition of `xxxx': xxxx = take 1 drop 520150
08:46:29 <paolino> @eval take 1 $ drop 520150
08:46:30 <lambdabot>   Expecting a function type, but found `a'
08:46:30 <lambdabot>   Expected type: [a]
08:46:30 <lambdabot>   Inferred type: [a1] -> [a1]
08:46:36 <xerox> @eval take 1 $ drop 520150 [1..]
08:46:37 <lambdabot> [520151]
08:46:45 <xerox> @eval take 1 $ drop 520151 [1..]
08:46:47 <lambdabot> [520152]
08:46:52 <xerox> @eval take 1 $ drop 600000 [1..]
08:46:53 <lambdabot> Stack overflow
08:46:56 <xerox> :D
08:47:07 <paolino> wow it has more stack than here :)
08:47:19 <xerox> You can adjust it with some options :D
08:47:50 <paolino> mmhh I doubt infinite lists are useful :/
08:48:28 <xerox> So sad!
08:49:18 <Cale> they are useful
08:49:22 <Cale> it's that !! is not useful
08:49:30 <musasabi> @plugs let f k = head (foldl (\e x -> if x == 0 then [x] else e) [] [1..]) in f 600000
08:49:34 <Cale> if you need !! to work, don't use lists
08:49:36 <lambdabot> Terminated
08:49:49 <musasabi> No stack overflow :-)
08:49:53 <xerox> :-D
08:49:57 <paolino> :))
08:50:00 <musasabi> mm that is wrong.
08:50:13 <xerox> Yeah
08:50:17 <Cale> nontermination, together with bad memory consumption
08:52:13 <paolino> I suppose someone tried an eval [1..] on the channel .
08:52:26 <Cale> @eval [1..]
08:52:28 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
08:52:28 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
08:52:28 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
08:52:28 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
08:52:28 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
08:52:29 <lambdabot> [24 @more lines]
08:52:49 <paolino> wow
08:53:09 <paolino> I was just scared
08:53:22 <benmos> only 24 more lines.... I never knew we were running so short on integers these days... ;-)
08:53:40 <SamB> benmos: thats not it
08:53:43 <SamB> @more
08:53:44 <lambdabot> 118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,
08:53:44 <lambdabot> 136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,
08:53:44 <lambdabot> 154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,
08:53:44 <lambdabot> 172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,
08:53:44 <lambdabot> 190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
08:53:45 <SamB> @more
08:53:46 <lambdabot> [19 @more lines]
08:53:48 <lambdabot> 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,
08:53:49 <lambdabot> 226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,
08:53:52 <lambdabot> 244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,
08:53:54 <lambdabot> 262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,
08:53:56 <lambdabot> 280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,
08:53:58 <lambdabot> [14 @more lines]
08:53:59 <SamB> @more
08:54:00 <lambdabot> 298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,
08:54:01 <flux__> or maybe it's more cpu intensive to calculate integers than you thought
08:54:02 <lambdabot> 316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,
08:54:04 <lambdabot> 334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,
08:54:06 <lambdabot> 352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,
08:54:08 <lambdabot> 370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,
08:54:10 <lambdabot> [9 @more lines]
08:54:11 <SamB> @more
08:54:12 <lambdabot> 388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,
08:54:14 <lambdabot> 406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,
08:54:16 <lambdabot> 424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,
08:54:18 <lambdabot> 442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,
08:54:19 <Cale> it cuts them off at an arbitrary character limit
08:54:20 <lambdabot> 460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,
08:54:20 <xerox> SamB: we got it.
08:54:21 <lambdabot> [4 @more lines]
08:54:22 <flux__> I smell a point coming up any time soon :)
08:54:28 <SamB> @more
08:54:29 <lambdabot> 478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,
08:54:29 <lambdabot> 496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,
08:54:29 <lambdabot> 514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,
08:54:30 <lambdabot> 532,533,534,535,536,537,538,539
08:54:40 <xerox> Four? :D
08:54:42 <SamB> see, no ']'!
08:55:04 <xerox> No more lines, though.
08:55:04 <benmos> ah!
08:55:14 <benmos> I think we can live without the rest
08:55:24 <SamB> benmos: there is no more, lambdabot is very forgetful
08:55:30 <Cale> who needs 539 + 1 anyway
08:55:41 <Cale> whatever that is :)
08:56:12 * beelsebob_ installs yhc on his x86 server to check that something compiled there works on his mac
08:56:15 <paolino> @type randoms
08:56:16 <lambdabot> Not in scope: `randoms'
08:56:21 <flux__> maybe some astrophysicists, but not common folk.
08:56:26 <Cale> @type Random.randoms
08:56:27 <lambdabot> forall a g.
08:56:27 <lambdabot> (System.Random.Random a, System.Random.RandomGen g) =>
08:56:27 <lambdabot> g -> [a]
08:57:39 <paolino> @eval take 1 $ drop 600000 $ Random.randoms (Random.mkStdGen 0)
08:57:40 <lambdabot> Add a type signature
08:57:49 <paolino> @eval take 1 $ drop 600000 $ Random.randoms (Random.mkStdGen 0) :: Int
08:57:50 <lambdabot> Couldn't match `Int' against `[a]'
08:57:50 <xerox> heeh
08:58:10 <paolino> @eval head $ drop 600000 $ Random.randoms (Random.mkStdGen 0) :: Int
08:58:12 <lambdabot> Stack overflow
08:58:56 <xerox> You don't want to do that anyway, do you?
08:59:00 <Cale> you shouldn't use a list if you plan on not consuming the elements
08:59:16 <Cale> (near the head)
08:59:25 <SamB> Cale: why not?
08:59:32 <xerox> So writing drop as a strict const... ?
08:59:33 <lightstep> isn't it lazy?
08:59:46 <flux__> hmm.. why does that overflow stack?-o
08:59:50 <Cale> well, it is lazy, it's okay to not consume the elements of the tail
09:00:06 <lightstep> @plugs head $ drop 600000 $ Random.randoms (Random.mkStdGen 0) :: Int
09:00:09 <lambdabot> Stack overflow
09:00:15 <SamB> anyone want to see what I get for let (x:_) `f` 0 = x; (_:xs) `f` n = f xs (n-1) in [1..] `f` 600000 with -ddump-simpl?
09:00:27 <SamB> lisppaste2: help
09:00:27 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:02:47 <xerox> Yes sir
09:03:13 <Cale> ah
09:03:29 <Cale> it's actually not that which is the problem, I think
09:03:41 * xerox is all eyes
09:03:44 <Cale> it's evaluating the first element of the resulting list
09:04:01 <Cale> which overflows the stack
09:04:10 <lightstep> i think Random is broken
09:04:32 <Cale> not Random
09:04:36 <Cale> anything like this
09:04:47 <Cale> where the next element of the list depends on the previous one
09:05:07 <SamB> oh, wow...
09:05:09 <Cale> you're not doing any of the computation, and then all of a sudden, you have this ridiculous-sized expression to collapse
09:05:13 <xerox> Hm
09:05:23 <SamB> so we need to seq the previous things...
09:05:29 <lightstep> i don't buy it
09:05:29 <dcoutts> xerox, you're on the Gtk2Hs front page again :-)
09:05:31 <SamB> or something
09:05:33 <xerox> I tried @eval let cut ~(x:xs) = x `seq` xs; drop 0 = id; drop n = iterate cut in head $ drop 10 [0..]
09:05:33 <Cale> zip [0..] [0..] >>= \(x,y) -> if y > 600000 then [x] else x `seq` []
09:05:35 <xerox> but nothing..
09:05:38 <xerox> dcoutts OH?
09:05:46 <Cale> @eval head $ zip [0..] [0..] >>= \(x,y) -> if y > 600000 then [x] else x `seq` []
09:05:48 <lambdabot> 600001
09:05:52 <SamB> @eval let (x:_) `f` 0 = x; (~_:xs) `f` n = f xs (n-1) in [1..] `f` 600000
09:05:53 <lambdabot> Stack overflow
09:06:08 <SamB> @plugs let (x:_) `f` 0 = x; (~_:xs) `f` n = f xs (n-1) in [1..] `f` 600000
09:06:09 <xerox> dcoutts, cool :D
09:06:10 <lambdabot> Stack overflow
09:06:11 <dcoutts> xerox, I've sent out the 0.9.10 release announcement to various mailing lists and updated the web pages
09:06:20 <SamB> @plugs let (x:_) `f` 0 = x; (x:xs) `f` n = x `seq` f xs (n-1) in [1..] `f` 600000
09:06:21 <xerox> dcoutts, I should have payed you to put my name.
09:06:22 <lambdabot> 600001
09:06:23 <xerox> ;-)
09:06:28 <Cale> @eval head $ zip [10,20..] [0..] >>= \(x,y) -> if y > 600000 then [x] else x `seq` []
09:06:31 <lambdabot> 6000020
09:06:31 <xerox> SamB: AH!
09:06:35 <xerox> paolino: saw?
09:06:36 <dcoutts> xerox, so your google project triumph get's more publicity :-)
09:06:55 <paolino> seeing
09:06:59 <paolino> foggish
09:07:02 <SamB> xerox: what is that for?
09:07:11 <xerox> SamB: you did it.
09:07:19 <Cale> I did it too :)
09:07:20 <xerox> But it's Cale credit?
09:07:29 <xerox> I have to assign the @karma+ :-)
09:07:41 * xerox re-reads
09:07:46 <basti_> hmm i can't build wxhaskell for wx2.6, and it crashes for some 2.5
09:07:51 <SamB> Cale got it first, yes
09:07:53 <xerox> @karma+ Cale -- sorry :D
09:07:53 <lambdabot> Cale's karma raised to 2.
09:08:03 <Cale> @karma+ SamB
09:08:04 <lambdabot> SamB's karma raised to 2.
09:08:11 <xerox> You have ONLY 2?  People is unfair with you here ;-)
09:08:14 <SamB> hmm, where did I get the other one?
09:08:20 <Cale> karma-chaining
09:08:25 <SamB> chaining?
09:08:31 <xerox> Cale: be sure of evaluate the previous one!
09:08:31 <Cale> hehe
09:08:35 <Cale> heh
09:08:37 <xerox> :D
09:08:51 <xerox> The last one would get a karma blow-up, in case ;D
09:09:03 <Cale> yeah, so perhaps we need !!! in the prelude :)
09:09:13 <SamB> heh
09:09:15 <xerox> We do need !!!
09:09:17 <SamB> thats a funny name
09:09:18 <dcoutts> basti_, I reccomend: http://haskell.org/gtk2hs/archives/2005/11/05/gtk2hs-0910-released/
09:09:28 <SamB> xerox: that is a confusing sentance!
09:09:30 <xerox> Buddhism tells us to avoid needing !!!
09:09:32 <lightstep> @plugs iterate (snd . next) (Random.mkStdGen 0) !! 600000
09:09:32 <flux__> could !! (/drop) somehow be smarter about that?
09:09:35 <lambdabot> Stack overflow
09:09:35 * xerox laughs
09:09:38 <flux__> as to avoid stack overflow
09:09:40 <lightstep> it's not lazy enough
09:09:53 <basti_> dcoutts: what if i severly loathe gtk?
09:10:02 <lightstep> err, Random.next isn't strict enought
09:10:05 <basti_> ok there's a cairo binding
09:10:08 <basti_> ^^
09:10:14 * xerox bounces happily
09:10:29 <paolino> xerox go explain me on .it please
09:10:36 <xerox> If I wasn't so lazy I would have gone to the back for the details for the payment.  Pfft :D
09:11:05 <basti_> @where gtk2hs
09:11:06 <dcoutts> basti_, in that case you can't use wxHaskell or Gtk2Hs since they both use Gtk+. In that case I'd reccomend HsFLTK.
09:11:06 <lambdabot> http://haskell.org/gtk2hs/
09:11:25 <basti_>  wx doesn't depend on gtk
09:11:29 <Cale> lightstep: it's not Random, I don't think
09:11:39 <SamB> @eval let xs !!! n = (foldr (\x xs -> x `seq` (x:xs)) !! n in [1..] !!! 600000
09:11:40 <lambdabot>  parse error on input `in'
09:11:47 <basti_> ^^
09:11:47 <dcoutts> basti_, on linux it does
09:11:48 <SamB> @eval let xs !!! n = (foldr (\x xs -> x `seq` (x:xs))) !! n in [1..] !!! 600000
09:11:50 <lambdabot>   Expecting a function type, but found `[a]'
09:11:50 <lambdabot>   Expected type: [a]
09:11:50 <lambdabot>   Inferred type: b -> [a1] -> b
09:11:59 <dcoutts> @where hsfltk
09:11:59 <lambdabot> I know nothing about hsfltk.
09:12:01 <dcoutts> @where hs-fltk
09:12:02 <lambdabot> I know nothing about hs-fltk.
09:12:07 <Cale> It's that !! doesn't force evaluation as it walks down the list, and you get a buildup of code
09:12:12 <dcoutts> @where+ hsfltk http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/
09:12:13 <lambdabot> hsfltk ~> http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/
09:12:16 <dcoutts> @where+ hs-fltk http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/
09:12:16 <lambdabot> hs-fltk ~> http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/
09:12:57 <dcoutts> basti_, on linux wxWidgets uses Gtk+ or Motif.
09:13:04 <Cale> @eval let xs !!! n = (foldr (\x xs -> x `seq` (x:xs)) []) !! n in [1..] !!! 600000
09:13:05 <lambdabot>   Expecting a function type, but found `[a]'
09:13:05 <lambdabot>   Expected type: [a]
09:13:05 <lambdabot>   Inferred type: [a1] -> b
09:13:16 <Cale> @eval let xs !!! n = (foldr (\x xs -> x `seq` (x:xs)) [] xs) !! n in [1..] !!! 600000
09:13:17 <lambdabot> 600001
09:13:25 <lightstep> Cale, is this related to '-' being lazy?
09:13:45 <Cale> lightstep: it's related to everything being lazy
09:13:47 <basti_> dcoutts: i was half kidding about loathing gtk. I know it's in wide use, but i tried it a few times, and everything i was like "yuck"
09:14:10 <Cale> @eval let xs !!! n = (foldr ((:).seq) [] xs) !! n in [1..] !!! 600000
09:14:11 <lambdabot>  add an instance declaration for (Show (t -> t))
09:14:13 <SamB> @eval let xs !!! n = foldr (\x xs -> x `seq` (x:xs)) [] !! n in [1..] !!! 600000
09:14:14 <lambdabot>   Expecting a function type, but found `[a]'
09:14:14 <lambdabot>   Expected type: [a]
09:14:14 <lambdabot>   Inferred type: [a1] -> b
09:14:29 <Cale> oh, hehe, silly me
09:14:32 <dcoutts> basti_, you mean the way it looks or the way the API works?
09:14:37 <SamB> @type (\x xs -> x `seq` (x:xs))
09:14:38 <lambdabot> forall a. a -> [a] -> [a]
09:14:40 <SamB> @type foldr
09:14:41 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
09:14:55 <Cale> @pl \x xs -> seq x (x:xs)
09:14:56 <lambdabot> liftM2 (.) seq (:)
09:15:04 <Cale> blah
09:15:19 <basti_> like, halfway both. The look can be hidden with a lot of practice, obviously. Then it's not ergonomic (for example the way it handles popup menus). And the API is uncomfortable.
09:15:20 <SamB> @eval let xs !!! n = foldr (\x xs -> x `seq` (x:xs)) [] xs !! n in [1..] !!! 600000
09:15:21 <lambdabot> 600001
09:15:26 <basti_> can't remember why i feel so though.
09:15:33 <lightstep> i imagine next implemented as \(StdGen seed) -> (extract seed, StdGen $ transform seed)
09:15:59 <SamB> @eval let xs !!! n = foldr (seq.(:)) [] xs !! n in [1..] !!! 600000
09:16:00 <lambdabot> Add a type signature
09:16:05 <dcoutts> basti_, maybe you were looking at Gtk+ 1.2 :-)
09:16:09 <lightstep> then the `iterate' should be unlifted to the `transform'
09:16:13 <Cale> SamB: tried that :)
09:16:17 <SamB> @eval let xs !!! n = foldr ((.) : (:)) [] xs !! n in [1..] !!! 600000
09:16:17 <lambdabot>   Expecting a function type, but found `[a]'
09:16:17 <lambdabot>   Expected type: [(b -> c) -> (a -> b) -> a -> c]
09:16:17 <lambdabot>   Inferred type: a1 -> [a1] -> [a1]
09:16:22 <SamB> @eval let xs !!! n = foldr ((.) seq (:)) [] xs !! n in [1..] !!! 600000
09:16:22 <lambdabot> Add a type signature
09:16:24 <Cale> the pointfree version sucks
09:16:30 <SamB> @eval let xs !!! n = foldr (\x xs -> x `seq` (x:xs)) [] xs !! n in [1..] !!! 600000
09:16:32 <lambdabot> 600001
09:16:35 <Cale> @pl \x xs -> x `seq` (x:xs)
09:16:36 <lambdabot> liftM2 (.) seq (:)
09:16:39 <SamB> that one actually works
09:16:41 <Cale> liftM2 :)
09:16:50 <Cale> yeah
09:17:12 <SamB> @eval let xs !!! n = foldr (liftM2 (.) seq (:)) [] xs !! n in [1..] !!! 600000
09:17:14 <lambdabot> 600001
09:17:36 <lightstep> List.!! is a fold and Random.randoms is an unfold
09:17:42 <lightstep> and ghc should fix those
09:17:45 <SamB> not much shorter and a lot less clear...
09:17:49 <Cale> yeah
09:18:09 <xerox> Let's see the patch :D
09:18:10 <Cale> lightstep: they don't need fixing -- you just need something else for other times
09:18:20 <Cale> They're good at what they do
09:18:38 <Cale> but you have to be careful about the stack sometimes in a lazy language :)
09:19:01 <SamB> @index build
09:19:02 <lambdabot> Data.Graph.Inductive.Internal.Heap, Distribution.Simple.Build, GHC.
09:19:02 <lambdabot> Exts
09:19:06 <Cale> Sometimes you *really* don't want !! to evaluate all the elements of the list up to that point
09:19:08 <xerox> So let's put (!!!) somewhere!
09:19:12 <sylvan> does the windows installer of gtk2hs include the cairo-binding?
09:19:20 <xerox> sylvan: I think so.
09:19:21 <Cale> consider the case where evaluating each element of the list takes a day
09:19:34 <lightstep> is (!!) strict at all?
09:19:37 <Cale> and the list elements don't depend on each other
09:19:38 <Cale> no
09:19:41 <xerox> It is not
09:19:42 <Cale> !! is lazy
09:20:02 <Cale> almost everything is completely lazy
09:20:07 * xerox is lazy
09:20:10 <lightstep> so why does it compute all the previous elements?
09:20:15 <Cale> it doesn't
09:20:21 <Cale> that was the whole problem
09:20:30 <lightstep> so next is problematic
09:20:36 <lightstep> since it isn't tail-recursive
09:21:03 <Cale> it doesn't really matter what function you use to move from one element of the list to the next
09:21:06 <lightstep> randoms computes all the previous generators on the stack, instead of leaving them to the GC
09:21:09 <Cale> you're going to get a stack overflow
09:22:05 <Cale> @eval let xs = 1 : map id xs in xs !! 6000000
09:22:08 <lambdabot> Stack overflow
09:22:24 <lightstep> why?
09:22:39 <lightstep> oh
09:22:45 <Cale> because the 6000000th element looks like:  id (id (id (id ... id 1)
09:22:56 <lightstep> this example needs to go over the list n times
09:23:10 <lightstep> why isn't id strict?
09:23:11 <SamB> hmm, randoms doesn't look much like a build...
09:23:16 <Cale> why should it be?
09:23:29 <paolino> *Fern Random> fst (iterate' (mkStdGen 0)) !! 100000 :: Punto
09:23:29 <paolino> Punto (-0.18350236,1.7552712)
09:23:34 * paolino thanks all
09:23:35 <lightstep> since it is
09:24:04 <lightstep> what is iterate'?
09:24:34 <lightstep> Cale, to reduce id x you must reduce x
09:24:49 <Cale> okay, sure
09:25:04 <Cale> you could make it strict and not lose anything
09:25:06 <dcoutts> Cale, xerox: your discussion made me think of this. Here's a little quiz, what does the following function do? :
09:25:06 <dcoutts> f [] = []
09:25:06 <dcoutts> f (x:xs) = x : seq x (f xs)
09:25:17 <beelsebob_> YAY!!!!
09:25:20 <lightstep> same with Random.next
09:25:25 <beelsebob_> tatd2@jet ~ $ yhcc Spam.hs
09:25:25 <beelsebob_> tatd2@jet ~ $ yhc Main
09:25:25 <beelsebob_> "SPAM!"
09:25:51 <ndm_> we really need a better name for yhcc and yhc...
09:26:08 <dcoutts> yhcc?
09:26:13 <beelsebob_> yhc compile
09:26:17 <beelsebob_> yhc runs programs
09:26:18 <Cale> dcoutts: yeah, that function is really what is needed in the prelude :)
09:26:21 <beelsebob_> yhcc compiles them
09:26:38 <xerox> @type let f [] = []; f (x:xs) = x : seq x (f xs) in f
09:26:39 <lambdabot> forall a. [a] -> [a]
09:26:39 <ndm_> yhcc :: Haskell -> ByteCode
09:26:50 <ndm_> yhc :: ByteCode -> IO ()
09:26:51 <beelsebob_> neil: yhc and yhr (york haskell compiler, and york Haskell runtime)?
09:26:56 <xerox> It forces the evaluation of the list!
09:26:57 <dcoutts> ndm_, beelsebob_: whay do you need yhc? doesn't it produce standalone programs?
09:27:01 <lightstep> @where yhc
09:27:02 <lambdabot> www.cs.york.ac.uk/~ndm/yhc
09:27:03 <Cale> xerox: not quite :)
09:27:07 <dcoutts> xerox, does it really?
09:27:12 <beelsebob_> dcoutts: it produces York Haskell Bytecode
09:27:14 <ndm_> dcoutts, no
09:27:16 <xerox> Hm.
09:27:17 <beelsebob_> that will run on any machine
09:27:19 <SamB> @eval iterate (+1) 0
09:27:19 <ndm_> but it can do
09:27:20 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
09:27:20 <lambdabot> 27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,
09:27:20 <lambdabot> 51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,
09:27:20 <lambdabot> 75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
09:27:20 <lambdabot> 99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
09:27:22 <lambdabot> [24 @more lines]
09:27:33 <beelsebob_> dcoutts: I just compiled on my x86 box and then ran on my Mac :)
09:27:40 <ndm_> cat yhr.exe spam.hbc > spam.exe
09:27:43 * xerox thinks more.
09:27:47 <ndm_> that will give you a standalone binary
09:27:53 <Cale> @eval let f [] = []; f (x:xs) = x : seq x (f xs) in head (f [1..])
09:27:54 <lambdabot> 1
09:28:04 <xerox> So the (:) is still lazy.
09:28:10 <dcoutts> xerox, yes
09:28:10 <beelsebob_> ndm_: so has yhc and yhr just stuck?
09:28:29 <ndm_> ndm_, no - i still like yhcc
09:28:29 <Cale> It's that the nth element of the list now forces the evaluation of the (n-1)st when it is evaluated
09:28:33 <xerox> BUT, you evaluate the previous element, to calculate the next one.
09:28:42 <xerox> previous elements*
09:28:43 <lightstep> it makes the cdrs strict in the cars
09:28:44 <ndm_> since on my machine i have cyhc and cyhcc to build the compiler and teh runtime :)
09:28:51 <beelsebob_> ndm_: why yhcc what does it stand for?
09:28:51 <dcoutts> @eval let f [] = []; f (x:xs) = x : seq x (f xs) in f [1,2,undefined,4] !! 1
09:28:52 <lambdabot> 2
09:28:52 <xerox> dcoutts: very nice one.
09:28:54 <lightstep> not just the cadrs in the cars
09:28:57 <dcoutts> @eval let f [] = []; f (x:xs) = x : seq x (f xs) in f [1,2,undefined,4] !! 3
09:28:58 <lambdabot> Undefined
09:29:08 <dcoutts> @eval let f [] = []; f (x:xs) = x : seq x (f xs) in [1,2,undefined,4] !! 3
09:29:09 <lambdabot> 4
09:29:12 <ndm_> beelsebob_: "york haskell compiler" compiler - yhcc
09:29:20 <beelsebob_> yeh... precicely
09:29:21 <xerox> Yay!
09:29:32 <lightstep> @eval let f [] = []; f (x:xs) = x : seq x (f xs) in tail $ tail $ f [1,2,undefined,4]
09:29:34 <lambdabot> Undefined
09:29:34 <dcoutts> xerox, right
09:29:36 <beelsebob_> so York Haskell Compiler and York Haskell Runtime is a bit better
09:29:38 <Cale> which is why you don't want !! to always be strict, btw
09:29:54 <xerox> Cale: point.
09:30:07 <ndm_> beelsebob_: better, but still...
09:30:19 <Cale> but that's a useful strategy function
09:30:19 <ndm_> yhr has the wrong sound
09:30:36 <beelsebob_> ndm_: a bit like a pirate?
09:30:37 <beelsebob_> YAHR!
09:30:43 <xerox> dcoutts, Cale: we need a name for that function :-D
09:30:47 <ndm_> indeed
09:30:58 <beelsebob_> nothing wrong with pirates
09:31:10 <xerox> @arr
09:31:11 <lambdabot> I'd like to drop me anchor in her lagoon
09:31:14 <xerox> @yahr
09:31:15 <lambdabot> This is the END for you, you gutter-crawling cur!
09:31:20 <xerox> It also works on lambdabot :-D
09:31:23 <dcoutts> @yarr
09:31:23 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
09:31:23 <beelsebob_> hehe
09:31:32 <beelsebob_> @yarr
09:31:32 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
09:31:33 <dcoutts> oh, I like that one
09:31:34 <beelsebob_> booring
09:31:46 <beelsebob_> @aye
09:31:47 <lambdabot> Maybe you meant: arr type
09:31:50 <xerox> "<newcomer> what about yahr? <xerox> @yahr !"
09:31:51 <beelsebob_> :(
09:32:05 <beelsebob_> @yahr !
09:32:05 <lambdabot> Yeh scurvy dog...
09:32:11 <dcoutts> xerox, Cale, it's a special case of a more general piping function
09:32:17 <SamB> what was the point of changing randoms again?
09:32:35 <SamB> oh, not that I can run GHCi with my build of GHC...
09:33:22 <dcoutts> xerox, eg you could write one that evaluates lists in blocks on N elements.
09:33:54 <lightstep> having to fight lazyness is bad
09:33:57 <xerox> Would it be shiny happy writed too? :D
09:34:03 <malcolm_> how about yhi for the interpretive runtime?
09:34:03 <dcoutts> xerox, I imagine it might make some operations more effecient since it's like block buffering compared to no buffering
09:34:17 <xerox> dcoutts, right.
09:34:36 <beelsebob_> malcolm_: strangely the file I'm editing is called yhi.hs
09:34:37 <beelsebob_> *g*
09:34:39 <ndm_> malcolm_: i like that :)
09:40:54 <beelsebob_> ndm_: Hoogle for String -> IO String
09:41:29 <ndm_> beelsebob_: you were expecting return?
09:41:43 <beelsebob_> I was expecting something other than a broken page ;)
09:41:51 <xerox> @hoogle (a -> b) -> f a -> f b
09:41:52 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
09:41:52 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
09:41:52 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
09:42:02 <xerox> @hoogle Functor f => (a -> b) -> f a -> f b
09:42:03 <lambdabot> No matches, try a more general search
09:42:07 <xerox> @hoogle Functor f => (a -> b) -> (f a -> f b)
09:42:08 <lambdabot> No matches, try a more general search
09:42:15 <beelsebob_> in fact... hoogle is generally breaking for anything with arraws in
09:42:25 <ndm_> maybe....
09:42:37 <ndm_> it works for me, that search
09:42:52 <ndm_> beelsebob_: give me the url of the broken page, including the search
09:43:03 <beelsebob_> http://www-users.cs.york.ac.uk/~ndm/cgi-bin/hoogle3-cgi?q=a+-%253E+b
09:43:13 <Cale> lightstep: yeah, but it's not that bad :) The stuff in Control.Parallel.Strategies is pretty good to kill off problems with laziness. Most (really all) of the problems come from folding large structures down to single values, and you can generally write good fold operators which are strict.
09:43:22 <ndm_> @where hoogle
09:43:22 <lambdabot> http://www.haskell.org/hoogle
09:43:30 <ndm_> beelsebob_: an updated version :)
09:43:44 <beelsebob_> better :)
09:43:44 <Cale> @hoogle (a -> b) -> f a -> f b
09:43:45 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
09:43:45 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
09:43:45 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
09:43:57 <Cale> @hoogle (Functor f) => (a -> b) -> f a -> f b
09:43:58 <lambdabot> No matches, try a more general search
09:44:13 <Cale> @hoogle (a -> b) -> [a] -> [b]
09:44:14 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
09:44:14 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
09:44:14 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
09:44:23 <Cale> @hoogle (a -> b) -> ([a] -> [b])
09:44:24 <lambdabot> No matches, try a more general search
09:44:38 <Cale> ndm_: that's a bug
09:45:05 <ndm_> Cale, indeed
09:45:14 <ndm_> it should unbracket on the left
09:45:26 <ndm_> and it should know that [] is a functor
09:45:40 <Cale> and it should know about fmap
09:45:59 <ndm_> it also seems to have bugs on sequence, not sure why...
09:46:26 <beelsebob_> ndm_: does the yhc prelude not include unsafePerformIO?
09:46:42 <Cale> "Functor f => (a -> b) -> f a -> f b" in the online version doesn't seem to find fmap
09:46:50 <ndm_> beelsebob_: you tell me...
09:46:59 <ndm_> it should be in IOExts, i think
09:47:04 <beelsebob_> ah... okay
09:47:42 <sylvan> the Gtk2hs still doesn't work for me. It complains that the GTK+ libs are not installed on the path even though they clearly are
09:48:07 <sylvan> the windows installer, that is
09:48:14 <beelsebob_> ndm_: no... that module isn't installed by default
09:48:21 <beelsebob_> just IO... which doesn't contain it
09:48:30 <ndm_> beelsebob_: then patch it :)
09:48:58 <xerox> Howdy astrolabe!
09:49:13 <ndm_> Cale, http://haskell.org/hawiki/Hoogle - if you find any more bad searches add tehm to that
09:49:23 <vegai> I assume that making a new Haskell implementation is not very easy
09:49:26 <Cale> ndm_: also, if you put in things like Integer -> Integer, you end up with lots of irrelevant results
09:49:28 <ndm_> then when i hit development on hoogle again (one day this week, hopefully) i'll fix this
09:49:37 <vegai> not exactly like writing another scheme implementation, is it?
09:49:52 <Cale> It should be aware of what classes various types are in
09:49:58 <astrolabe> hia xerox :)
09:50:02 <ndm_> Cale, it is
09:50:17 <ndm_> Integer is in Enum, Bits, Integral etc.
09:50:33 <Cale> does it use that in scoring?
09:50:41 <ndm_> yep
09:50:47 <Killer666> where from i could find info about converting expressions to normal form?
09:50:57 <ndm_> but not perfectly yet, the scoring vs classes needs some work, and some brand new thought
09:51:02 <Cale> If I put in Integer -> Integer, all the stuff about Num ends up on page 4
09:51:34 <Cale> hmm
09:51:37 <xerox> Hello nsttcrhgtnh, uncovered xah ;-)
09:51:43 <Cale> well, some things land on page 1
09:51:52 <nsttcrhgtnh> lol
09:52:05 <nsttcrhgtnh> i seems to have some problem joining the #python room
09:52:06 <Cale> but seq is certainly less appropriate than (+)
09:52:44 <basti_> nsttcrhgtnh: maybe it's an about channel?
09:52:46 <basti_> try ##python
09:53:35 <ndm_> Cale, i have a training set of information
09:53:45 <nsttcrhgtnh> mmm ##python only has 7 person, but i can see #python has some 200
09:54:01 <Cale> what's the error?
09:54:06 <Cale> I can join #python
09:54:08 <ndm_> Cale: i think one of the things lacks enough information, i'll add seq being more important than (+)
09:54:22 <nsttcrhgtnh> Cale: how many people it has?
09:54:24 <xerox> There also seem to be no ban about your mask, for #python and ##python.
09:54:41 <Cale> nsttcrhgtnh: lots
09:54:51 <Cale> 217
09:55:56 <Cale> ndm_: other way around :)
09:56:06 <basti_> nsttcrhgtnh: are you registered?
09:56:19 <ndm_> Cale, indeed - added - after the next update and regeneration it will be fixed
09:56:22 <ndm_> maybe a week or so
09:56:31 <basti_> identified
09:58:20 <nsttcrhgtnh> basti_: i don't think so. I'm Xah.
09:58:28 <basti_> hmm
09:58:30 <basti_> maybe you need to be
09:58:42 <nsttcrhgtnh> how to register?
09:59:04 <Cale>  /msg nickserv register somepassword
09:59:26 <nsttcrhgtnh> nickserv is for haskell or python?
09:59:35 <Cale> for the network
09:59:50 <Cale> it registers your nick so others can't take it
10:00:27 <nsttcrhgtnh> oh cool.
10:00:39 <nsttcrhgtnh> brb
10:01:10 <ulfdoz> Spare nick does, too.
10:01:33 <SamB> I stopped going to #python after I couldn't figure out how to get xchat to automatically ghost & NICK to SamB (if necessary) and then identify...
10:02:12 <SamB> I wasn't really getting anything out of it anymore anyway, or putting much in for that matter...
10:02:36 <SamB> @localtime jlouis
10:02:38 <lambdabot> Local time for jlouis is Sat Nov  5 19:02:15 2005
10:04:26 <xahlee> yeeep. Just registered.
10:05:39 <xahlee> basti_: thx ^_^
10:06:32 <ski> (xahlee : registering doesn't hinder anyone else from using your nick, but it allows you to kick that person for taking your nick, so you can then change to your normal nick)
10:06:49 <SamB> even if that person is you some minutes ago ;-)
10:07:20 <ski> (like '/msg nickserv ghost xahlee password' and then '/nick xahlee' and '/msg nickserv identify password')
10:07:32 <ski> SamB : right :)
10:07:42 <SamB> as the name implies
10:08:19 <xahlee> ski: thanks. going to have some dialogue with nickserve now
10:08:37 <gour> dcoutts: have you read about novell & gnome?
10:09:25 <basti_> xahlee: :)
10:09:53 * basti_ did a gtk2hs window 
10:09:55 * basti_ bounces
10:10:01 <SamB> what about novell and gnome? its probably not too surprising considering they bought Ximian...
10:15:21 <ndm_> beelsebob_: join #haskell-overflow
10:18:10 <jlouis> SamB: pong ;)
10:18:46 <SamB> jlouis: but I didn't say ping yet
10:19:08 <SamB> you must be some kind of optimistic psychic or something!
10:19:24 <basti_> anticassandra?
10:20:10 <SamB> jlouis: when are you going to merge stuff?
10:21:05 <SamB> also, what is up with FS/FilePool.hs (which starts with "module FilePool" inside)?
10:21:19 <jlouis> SamB: I am working on it now. I will be offline tomorrow at least, but i'll find time to hack on the code
10:21:44 <jlouis> SamB: it should be FS.FilePool I think. It is a bug. But FilePool is going away soon. It is called HandlePool intsead
10:24:08 <SamB> jlouis: I suspected as much!
10:26:56 <jlouis> SamB: I have applied all patches to the repo. This afternoon I will try to understand what is going on. There is suddenly quite much speed on this project
10:27:15 <jlouis> But extremely cool haskell hackers must be productive
10:29:58 <proloy> newbie help : can anyone tell what's wrong with this code .. seems show_facts is the one creating problem URL: http://www.nomorepasting.com/paste.php?pasteID=51963
10:31:07 <ski> well, you have no base case
10:31:35 <ski> also, my_fact doesn't accept a list
10:31:55 <ski> (you compare x to [] in show_facts, so it thinks x should be a list)
10:32:19 <proloy> oh yeah. damn ( i am two days old with haskell ) , let me see if i can fix it
10:32:40 <ski> also, 'show(x)' can be written simply as 'show x'
10:33:02 <ski> similarly 'show(my_fact(x))' can be written as 'show (my_fact x)'
10:33:25 <proloy> yup thanks..
10:34:10 <dcoutts> gour, yeah I saw that
10:34:30 <ski> ('show( foldr (*) 1 testList)' is more commonly written as 'show (foldr (*) 1 testList)')
10:34:45 <dcoutts> basti_, glad to see you're overcomming your prejudices agaisnt Gtk+ :-)
10:34:49 <int-e> or show (product testList)
10:35:08 <ski> proloy : otherwise your code looks fine, i think :)
10:36:04 <proloy> thanks  ;) i have been following the tutorial by Hal Daume , you have any other freely available suggestions ?
10:36:43 <ski> product = foldr (*) 1
10:37:17 <ski> proloy : most people here have their suggestions freely available :)
10:37:35 <proloy> heh i meant suggestions for tutorials available on net freely ;)
10:37:45 <ski> oh
10:38:04 <ski> Hal Daume's possibly the best, if you're new to functional programming
10:38:57 <proloy> I initially tried to read lambda calculus, which was a bit too much for me , and  then jumped into haskell directly.
10:39:22 <ski> oh, heh
10:39:39 <basti_> try combinator logic!
10:40:22 <proloy> will see if my library has anything on it.
10:40:58 <ski> SKI-calculus is even more unreadable than pure lambda calculus
10:41:36 <proloy> i will maintain my distance.
10:41:44 <ski> hehe
10:42:53 <ski> proloy : of course your code could be indented nicer .. and some more sophistication can be used .. but that will come, given that you start with the simple things first
10:42:55 <ski> :)
10:43:15 <proloy> i wrote on notepad, dont have emacs at home.
10:43:21 <ski> ok
10:43:39 <ski> proloy : do you get it to work ?
10:43:50 <ski> (the code, i.e.)
10:44:12 <proloy> not yet .. was wondering how to pass a number to my_fact , could passing it "head testList" work ?
10:45:11 <paolino> !!! n operation make things very slow and it's exponential in n, possible ?
10:45:14 <ski> you are passing a list of numbers to show_facts
10:45:34 <ski> proloy : the trouble stems from 'x == []'
10:45:43 <proloy> yup , and i want to take a number at a time and pass it to my_fact , so that should work no ?
10:45:50 <ski> why are you trying to compare a number with the empty list ?
10:46:16 <kombinator>  droundy: do you think it would be feasible to add indetation patches to darcs?
10:46:19 <ski> it should work, provided you figure out the trouble with 'x == []'
10:46:24 <proloy> what i intented was "showFact would take  the list and then take each element , get its factorial and putStrLn it
10:46:29 <paolino> SamB ?
10:46:42 <ski> (proloy : i don't know what you want to do with that test ..)
10:46:51 <ski> proloy : aha
10:46:59 <droundy> kombinator:  Yeah, it's been in the plans from the beginning.  It just got sort of delayed by darcs becoming popular...
10:47:09 <SamB> paolino: yes?
10:47:14 <ski> proloy : you shouldn't check if x is an empty list
10:47:20 <paolino> !! n operation make things very slow and it's exponential in n, possible ?
10:47:23 <paolino> !!!
10:47:29 <ski> proloy : you should check if the list passed to show_facts is an empty list
10:47:48 <proloy> ah okay
10:48:04 <SamB> what was the question again, I was playing with torrent files
10:48:31 <SamB> !! is not exactly exponential...
10:48:36 <paolino> !!!
10:48:48 <paolino> your code
10:48:49 <SamB> @eval let xs !!! n = foldr (\x xs -> x `seq` (x:xs)) [] xs !! n in [1..] !!! 600000
10:48:51 <lambdabot> 600001
10:49:34 <paolino> *Fern Random> fst (iterate' (mkStdGen 0)) !!! 1000 ::(Float,Float)
10:49:35 <paolino> (1.36 secs, 50756248 bytes)
10:49:35 <paolino> *Fern Random> fst (iterate' (mkStdGen 0)) !!! 2000 ::(Float,Float)
10:49:35 <paolino> (8.70 secs, 198080504 bytes)
10:50:02 <SamB> that is hopefully O(n)
10:50:54 <droundy> kombinator: the hardest part is actually is figuring out a scheme for when to create indentation patches.
10:51:11 <paolino> and ...
10:51:13 <paolino> *Fern Random> fst (iterate' (mkStdGen 0)) !! 1000 ::(Float,Float)
10:51:14 <paolino> (0.09 secs, 3004164 bytes)
10:51:14 <paolino> *Fern Random> fst (iterate' (mkStdGen 0)) !! 2000 ::(Float,Float)
10:51:14 <paolino> (0.17 secs, 4978268 bytes)
10:51:33 <SamB> huh
10:51:36 <kombinator> droundy: the ui should enable choosing this
10:52:06 <droundy> yeah, it really should, but writing UI is unpleasant... (plus there keep being bugs and more important features...)
10:52:20 <SamB> what is iterate'?
10:52:27 <kombinator> droundy: I think that the diffing algo can't guess what the user wants in many cases
10:52:53 <kombinator> droundy: and that it should be possible to override its choices
10:53:12 <paolino> iterate' generator = (apply (fst $ chooseFrom functions generator) zero,fst $ split generator) where
10:53:14 <paolino>   apply fs x = map ($ x) (scanl (.) id fs)
10:53:32 <droundy> kombinator: Indeed, that's certainly the case, but you also don't want to force the user to always do it by hand, you need a way of specifying files that you want indentation patches for, and ones where you don't want them (like binaries).
10:54:15 <kombinator> droundy: of course auto diffing should be the default
10:54:16 <SamB> paolino: how about trying !!! on a simpler list?
10:54:51 <droundy> kombinator: except that by default you shouldn't create indent patches at all (since they won't work with older darcs)
10:55:03 <proloy> ski : got it to work , http://nomorepasting.com/paste.php?pasteID=51968   does it look amateurish ?
10:56:20 <kombinator> droundy: well, backwards compatibility is a separate issue
10:56:28 <ski> one peculiarity .. 'return True' .. no need to return a 'Bool' from the IO-action
10:56:32 <droundy> kombinator: true
10:56:43 <ski> proloy : you can use 'return ()' instead
10:56:50 <paolino> SamB, it works fine
10:56:51 <dcoutts> droundy, have you ever used meld?
10:56:57 <SamB> Prelude> [1..] !!! 100000
10:57:02 <proloy> oh okay . i returned true for want of anything else ;)
10:57:10 <SamB> 100001
10:57:10 <SamB> (0.26 secs, 6588604 bytes)
10:57:10 <SamB> Prelude> [1..] !!! 200000
10:57:10 <SamB> 200001
10:57:10 <SamB> (0.50 secs, 15049204 bytes)
10:57:16 <SamB> Prelude> [1..] !!! 400000
10:57:18 <SamB> 400001
10:57:18 <ski> proloy : also, one can use pattern-matching instead of if-then-else to check when to stop .. that looks nicer
10:57:20 <SamB> (0.99 secs, 26758304 bytes)
10:57:24 <kombinator> dcoutts: what's meld?
10:57:24 <SamB> that looks like good time behaviour to me
10:57:28 <dcoutts> droundy, it's a visual diff/merge tool. When ever I think of a darcs gui I think of meld.
10:57:33 <paolino> yep
10:57:37 <dcoutts> @google meld diff merge tool
10:57:38 <lambdabot> http://meld.sourceforge.net/
10:57:39 <sylvan> proloy: I'd say do this: show_fact [] = return ()
10:57:39 <sylvan> show_fact (x:xs) = do putStrLn .....
10:57:39 <sylvan>          show_fact xs
10:57:47 <vegai> and space behaviour? :P
10:57:55 <paolino> SamB, I wonder what is wrong then :/
10:58:06 <proloy> hmm thanks sylvan that does look nicer .. modifying it now
10:58:41 <dcoutts> kombinator, unlike many GUIs meld actually improves on some aspects of similar command line tools. It makes it very easy to see the diffs and to merge patches between two versions.
10:59:00 <ski> proloy : that was pattern-matching in work :)
10:59:05 <droundy> dcoutts: I looked at meld, and even contacted its author about improving the command-line interface to allow it to be used as an external resolution tool.  I seem to recall it didn't have  an appropriate set of cmd line flags.
10:59:22 <sylvan> proloy, you probably want to decouple some things though.. Like generating a list of factorials and printing the list of factorial shouldn't be done in one function
10:59:23 <kombinator> dcoutts: does it support moves?
10:59:33 <dcoutts> droundy, the latest version of meld has a plugin interface for vcs's
11:00:02 <sylvan> proloy, so you write a function which will print an arbitrary list of values (given some label, perhaps), and then pass it "map my_fact testlist"
11:00:12 <droundy> dcoutts: ah, that sounds nice.  It was a long time ago that I looked at it.
11:00:19 <dcoutts> droundy, the cvs and svn plugins are just short .py files. It looks like it might be an easy way to get an initial darcs ui.
11:00:23 <kombinator> dcoutts: I mean xx\nyy -> yy\nxx
11:00:36 <ski> proloy : 'map' is a nice function :)
11:00:47 <ski> @eval map (* 3) [0..4]
11:00:48 <lambdabot> [0,3,6,9,12]
11:00:51 <kombinator> dcoutts: anyway, it looks nice
11:00:55 <ski> @eval map (^ 2) [0..4]
11:00:56 <lambdabot> [0,1,4,9,16]
11:00:57 <dcoutts> it wouldn't deal with all the darcs features of course but at least just for viewing the differences betweent the current and the recorded version it should be good.
11:01:02 <proloy> ah cool
11:01:14 <ski> @eval map (\x -> (x,100 * x + (10 - x))) [0..4]
11:01:16 <lambdabot> [(0,10),(1,109),(2,208),(3,307),(4,406)]
11:01:24 <dcoutts> kombinator, I don't know about it's vcs move commands.
11:01:43 * SamB wishes dpkg used a real database instead of a flat text file
11:01:45 <ski> (proloy : in that last, i passed an (anonymous) function to 'map')
11:01:57 * SamB thinks it ought to use sqlite
11:02:13 <proloy> yeah , i saw it fly overhead.
11:02:15 <dcoutts> kombinator, I use meld with cvs for gtk2hs. I never use meld to actually commit or update. I use the cvs command line for that. But it's imensely useful for seeing what changes I've got in my local tree.
11:02:42 * ski leaves
11:02:48 <proloy> thanks ski for the help !
11:02:54 <ski> yw
11:03:06 <kombinator> dcoutts: that 'moves' were slightly off-topic;)
11:09:05 <goron> dcoutts_: ping
11:15:01 <syntaxfree> @pl f m n = (mod n m) + 1
11:15:01 <lambdabot> f = flip flip 1 . ((+) .) . flip mod
11:15:20 <syntaxfree> hmm. what's wrong with (+1). (flip mod)?
11:17:20 <int-e> @pl f m n = 1 + (mod n m)
11:17:20 <lambdabot> f = ((1 +) .) . flip mod
11:18:42 <proloy> 3:15 am .. i am off too , thanks sylvan for the help.
11:20:42 <syntaxfree> oh. ok. yes.
11:31:51 <syntaxfree> "span" is broken.
11:32:00 <syntaxfree> @eval span even [1..10]
11:32:01 <lambdabot> ([],[1,2,3,4,5,6,7,8,9,10])
11:32:10 <syntaxfree> @eval span odd [1..10]
11:32:11 <lambdabot> ([1],[2,3,4,5,6,7,8,9,10])
11:32:50 <syntaxfree> @eval let properspan pred l = (filter pred l, filter (not . pred) l) in properspan odd [1..10]
11:32:51 <lambdabot> ([1,3,5,7,9],[2,4,6,8,10])
11:33:18 <syntaxfree> what does "span" mean, anyway?
11:34:43 <int-e> @eval scanl (+) 0 [1,2,3,4,5,6]
11:34:44 <lambdabot> [0,1,3,6,10,15,21]
11:34:47 <Lemmih> @wn span
11:34:49 <lambdabot> *** "span" wn "WordNet (r) 2.0"
11:34:49 <lambdabot> span
11:34:49 <lambdabot>   n 1: the complete duration of something; "the job was finished in
11:34:51 <lambdabot>     the span of an hour"
11:34:53 <lambdabot>   2: the distance or interval between two points
11:34:55 <lambdabot> [13 @more lines]
11:35:01 <SamB> -- | 'span' @p xs@ is equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
11:35:15 <Lemmih> @eval span (<10) [1..15]
11:35:16 <syntaxfree> oh.
11:35:17 <lambdabot> ([1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15])
11:35:40 <syntaxfree> what is scanl, by the way?
11:35:59 <syntaxfree> @eval scanl (+) 1 [1..10]
11:36:00 <lambdabot> [1,2,4,7,11,16,22,29,37,46,56]
11:36:07 <int-e> something like a mix of foldl and inits
11:36:38 <syntaxfree> huh?
11:36:41 <syntaxfree> @type inits
11:36:42 <lambdabot> Not in scope: `inits'
11:36:45 <int-e> the elements are: foldl (+) 1 [], foldl (+) 1 [1], foldl (+) 1 [1,2]  and so on.
11:36:51 <int-e> @type Data.List.inits
11:36:52 <lambdabot> forall a. [a] -> [[a]]
11:37:04 <syntaxfree> @eval inits [1..10]
11:37:05 <int-e> @eval Data.List.inits [1,2,3]
11:37:05 <lambdabot> [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],
11:37:05 <lambdabot> [1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9,10]]
11:37:06 <lambdabot> [[],[1],[1,2],[1,2,3]]
11:37:14 <syntaxfree> hmm. I've been wanting that.
11:37:22 <int-e> @eval Data.List.tails [1,2,3]
11:37:23 <lambdabot> [[1,2,3],[2,3],[3],[]]
11:37:44 <int-e> @eval scanr (+) 0 [1..10]
11:37:45 <lambdabot> [55,54,52,49,45,40,34,27,19,10,0]
11:37:49 <SamB> group odd [1..10]
11:37:57 <syntaxfree> @eval group odd [1..10]
11:37:58 <lambdabot>   The function `group' is applied to two arguments,
11:37:58 <lambdabot>   but its type `[a] -> [[a]]' has only one
11:37:58 <lambdabot>   In the definition of `xxxx': xxxx = group odd ([1 .. 10])
11:38:05 <syntaxfree> @type group
11:38:05 <lambdabot> Not in scope: `group'
11:38:08 <SamB> @eval group odd [1..10]
11:38:09 <lambdabot>   The function `group' is applied to two arguments,
11:38:09 <lambdabot>   but its type `[a] -> [[a]]' has only one
11:38:09 <lambdabot>   In the definition of `xxxx': xxxx = group odd ([1 .. 10])
11:38:14 <syntaxfree> @type Data.list.group
11:38:15 <lambdabot>   Failed to load interface for `Data':
11:38:15 <lambdabot>    Could not find module `Data':
11:38:33 <SamB> @type Data.List.group
11:38:34 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
11:38:50 <SamB> @eval groupBy odd [1..10]
11:38:51 <lambdabot>   Expecting a function type, but found `Bool'
11:38:51 <lambdabot>   Expected type: a -> a -> Bool
11:38:51 <lambdabot>   Inferred type: a -> Bool
11:38:59 <SamB> erg.
11:39:01 <SamB> thats not it.
11:39:58 <SamB> what do you want, anyway?
11:40:31 <syntaxfree> @eval group [1..10]
11:40:32 <lambdabot> [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
11:41:05 <int-e> @eval break odd [1..10]
11:41:06 <lambdabot> ([],[1,2,3,4,5,6,7,8,9,10])
11:41:16 <int-e> @eval partition odd [1..10]
11:41:17 <lambdabot> ([1,3,5,7,9],[2,4,6,8,10])
11:43:39 * SamB would like groupThrough f = groupBy (\x y -> f x == f y)
11:43:58 <syntaxfree> hmm. nice.
11:44:39 <syntaxfree> @eval let groupThrough f = groupBy (\x y -> f x == f y) in groupThrough (**2) [-10..10]
11:44:40 <lambdabot> [[-10.0],[-9.0],[-8.0],[-7.0],[-6.0],[-5.0],[-4.0],[-3.0],[-2.0],[-1.0],[
11:44:40 <lambdabot> 0.0],[1.0],[2.0],[3.0],[4.0],[5.0],[6.0],[7.0],[8.0],[9.0],[10.0]]
11:44:45 <SamB> I wish the haskell library had margins
11:44:58 <syntaxfree> margins?
11:45:13 <SamB> to write down missing functions in
11:45:20 <syntaxfree> hehe :)
11:45:37 <syntaxfree> @eval let groupThrough f = groupBy (\x y -> f x == f y) in groupThrough (**3) [-10..10]
11:45:38 <lambdabot> [[-10.0],[-9.0],[-8.0],[-7.0],[-6.0],[-5.0],[-4.0],[-3.0],[-2.0],[-1.0],[
11:45:38 <lambdabot> 0.0],[1.0],[2.0],[3.0],[4.0],[5.0],[6.0],[7.0],[8.0],[9.0],[10.0]]
11:57:38 <xahlee> info autrijus
11:58:02 <xerox> xahlee: do you mean /WHOIS autrijus ?
11:58:36 <xahlee> xerox: i think i meant /msg nickserv info xyz
11:58:53 <xahlee> what's the diff?
11:58:55 <xerox> If you think you meant, then okay :-D
11:59:16 <xerox> There is no much difference.
11:59:17 <xahlee> xerox: where can i get a list of such slash commands?
11:59:38 <syntaxfree> slash help.
11:59:58 <xerox> xahlee: with my client I get completition pressing '/' and then 'TAB' some times...
12:00:04 <xerox> But maybe there is an /HELP :-)
12:00:05 <xahlee> doesn't seems to work
12:01:50 <xahlee> do people know lisp here?
12:02:12 <xerox> xahlee: Yes, I think so.
12:02:14 <xahlee> i'm wondering, whta's in it in haskell not in lisp.
12:02:36 <xerox> What is in Haskell that is not in lisp?
12:02:45 <xahlee> y
12:02:49 <xerox> It comes to mind: curried functions.
12:03:06 <xerox> So... sections?
12:03:19 <araujo> typeclasses?
12:03:40 <xerox> CL has a hierarchical type system, but I don't completely know..
12:04:36 <syntaxfree> Haskell is compilable.
12:04:42 <syntaxfree> as a dynamic language, Lisp by definition isn't.
12:05:22 <basti_> compilation is just preponed interpretation ^^
12:05:55 <araujo> mm.. after all, i don't think that compilable or interpreted might be considered a language feature.
12:07:41 <vegai> a language symptom, perhaps..
12:07:53 <xerox> Ah
12:07:56 <syntaxfree> well, you might want to write closed-source apps after all.
12:07:57 <xerox> A very cool community.
12:08:04 <xerox> :-)
12:08:10 <syntaxfree> slapping a license on a with-source-code package is not always effective.
12:08:21 <xerox> (i.e. a community that encourage newcomers!)
12:08:33 <ski> Lisp is compilable
12:08:33 <syntaxfree> I second what xerox said.
12:08:37 <vegai> yeah, but they don't have shapr, so that's not fair
12:08:53 <syntaxfree> ski: maybe by embedding an interpreter. How do you compile a language with eval()?
12:08:57 <xerox> It's not just because of him - all the people is very helpful here around.
12:09:08 <vegai> I jest, I jest
12:09:18 <vegai> or do I?
12:09:19 <ski> syntaxfree : haskell has hs-plugins .. is haskell not compilable ?
12:09:39 <SamB> lisp is compilable...
12:09:44 <syntaxfree> I thought hs-plugins was just a plugin architecture.
12:09:59 <ski> syntaxfree : with eval, a lisp compiler could compile at run-time
12:10:05 <syntaxfree> I can write a Lisp program that consists of (a) wait for user input (b) eval user input as Lispstuff.
12:10:10 <araujo> Actually, as far as i know, Lisp was even compilable first than C.
12:10:19 <syntaxfree> how do I compile that to a binary not needing Lisp?
12:10:24 <basti_> lisp is older than C, yes.
12:10:31 <araujo> As i said, compilable or interpreted is more an implementation concern.
12:10:51 <ski> (syntaxfree : of course it couldn't compile the code ast before it's known ..)
12:10:53 <basti_> and if "eval" means that a language isn't truly compiled, what is compiled, then?
12:10:53 <ski> hi moomlyn
12:10:53 <syntaxfree> as I understand it, you can't really compile a dynamic language, though you can embed an interpreter.
12:11:11 <syntaxfree> ski: so, basically, you need to embed a compiler/interpreter in your binary.
12:11:23 <ski> yes, if you allow eval
12:11:34 <basti_> As I understand it, this conversation is pointless.
12:11:35 <syntaxfree> therefore, it's not really compilable.
12:11:50 <ski> i think some lisp compilers allow not linking with the lib containing eval .. so then you don't get a compiler at run-time
12:12:03 <syntaxfree> and compileability issues can arise from a language's design, making it a design concern as well as an interpretation concern.
12:12:28 <araujo> For example, you can even get C interpreted.
12:12:31 <syntaxfree> Lisp - eval = something not lisp.
12:12:43 <xahlee> i think than many scheme compiles to C or java vm..
12:12:58 <SamB> syntaxfree: nobody said it could generate compiler-free executables in all case...
12:13:01 <ski> another, more relevant distinction between haskell and lisp (really statically typed and dynamically tagged) is that in haskell one can compile away more things than in lisp
12:13:10 <syntaxfree> Scheme "compilers" make ""binaries" for the scheme interpreter to use.
12:13:13 <araujo> syntaxfree, you can also have eval in haskell
12:13:16 <syntaxfree> it's just a way to speed up applications.
12:13:32 <ski> syntaxfree : you are now talking about byte-compilers
12:13:33 <basti_> as you might have notices, you're not making a point.
12:13:38 <araujo> I can't see how that affects if a language is compilable or interpreted.
12:13:54 <ski> syntaxfree : those compile part-way, and then interpret the rest
12:14:02 <SamB> anyway, linking is irrelevant
12:14:15 <ski> (but a hardware processor is also an interpreter, interpreting the machine code)
12:14:35 <gour> dcoutts: ping
12:14:56 <syntaxfree> as I understand it -- maybe I'm wrong -- if I compile "main = do putStrLn "Hello World"", I get an executable that does not contain a Haskell interpreter.
12:15:06 <syntaxfree> if I compile "(begin (display "Hello World"))", I do.
12:15:10 <ski> syntaxfree : same with lisp
12:15:17 <ski> i.e.
12:15:23 <ski> it could be the case
12:16:10 <araujo> I also could go further and say that all languages are interpreted. Being compilable/interpreted is just a clear high level distinction to create executables that depends upon the implementation.
12:16:35 <araujo> syntaxfree, i think you might probably be confusing static with dynamic , which is totally different.
12:16:48 <ski> (araujo : typing ?)
12:17:03 <ski> (ah, right)
12:17:03 <araujo> I can have dynamic features inside compilable implementations of languages like C even.
12:17:14 <syntaxfree> hmm. as I understand it, a dynamic language can write and run code in itself.
12:17:57 <musasabi> syntaxfree: have you looked at hs-plugins ;)
12:18:01 <musasabi> eval for Haskell.
12:18:14 <Lor> (with some caveats)
12:18:27 <syntaxfree> so what does GHC use if I use eval-for-Haskell?
12:18:34 <syntaxfree> s/GHC use/GHC do
12:19:03 <Lor> at run-time the program will call ghc to compile the new code into a shared object file, then it gets dynloaded into the running process
12:19:41 <musasabi> which is not much different from some lisp implementations.
12:19:58 <syntaxfree> so basically I need ghc around wherever I need to run the program with an eval.
12:20:01 <Lor> Yeah, if you're going to generate machine code at run-time, that is the easiest way of doing it.
12:20:15 <Lor> (Easiest in the sense that all the necessary components already exist)
12:20:31 <musasabi> syntaxfree: if you want to have eval you will need a compiler/interpreter in all languages.
12:20:37 <syntaxfree> exactly.
12:20:38 <Lor> The other option would be to actually generate machine code directly in memory, like gnu lightning does.
12:21:26 <ski> this is called Run-time-code-generation
12:21:44 <ski> (hugs (and possibly ghc ?) does this in the ffi, actually)
12:22:16 <Lor> Right.
12:22:31 <ski> (namely, when passing closures to the foreign language)
12:22:33 <franka> Run-time evaluation is not an intrinsic property of untyped languages.
12:22:35 <Lor> Uh, ghc certainly, I didn't know hugs did it too (doesn't that hinder its portability?)
12:22:48 <Lor> No, but it's certainly easier there.
12:23:09 <ski> Lor : it needs to be implemented in different ways on different platforms, obviously ..
12:23:10 <franka> It's easier because it does less.
12:24:06 <franka> And, actually, it's not really easier.  It's easy to have a typed language which has run-time evaluation of untyped code.
12:24:22 <franka> What's hard is having a typed language which has run-time evaluation of typed code.
12:25:20 <musasabi> franka: is a typed VM that hard?
12:25:31 <Lor> JVM is arguably a typed VM.
12:26:06 <musasabi> And there have been typed hardware platforms even.
12:26:27 <Lor> Typed in which sense?
12:26:27 <franka> A typed VM does not do run-time evaluation of typed code.  It does run-time checking of typed code, then forgets the types and evaluates the resulting untyped code.
12:26:42 <franka> I am talking about two-stage languages like MetaML and MetaOcaml.
12:27:00 <ski> franka : what do you mean by 'run-time evaluation', here ?
12:27:02 <ski> ah
12:27:02 <Lor> Those don't do _run-time_ checking of typed code.
12:27:04 <ski> yes
12:27:27 <franka> Yes, they do.  The VM checks the code when it starts up.
12:27:29 <ski> (franka : MetaML at least, is multistage)
12:27:41 <musasabi> Lor: distinguishing between at least two types of objects - data and capabilities.
12:27:47 <vegai> I'd wager that the stalin scheme compiler doesn't create binaries that contain the interpreter, unless needed
12:28:06 <vegai> but that's a guess
12:28:07 <Lor> Sure, it's easy to make a conservative approximation of whether the program ever calls eval.
12:28:26 <franka> But maybe the phrase "run-time checking" is misleading here.  I don't mean it interleaves the checks with the execution.
12:28:45 <Lor> But that is exactly what's needed for a real eval in a typed language.
12:28:57 <franka> No, it isn't.
12:29:02 <franka> MetaML doesn't do it.
12:29:08 <Lor> metaml doesn't have a real eval.
12:29:19 <vegai> actually, about stalin: "It places a few limitations on the content of the source code. For example, you may not not LOAD or EVAL new expressions or procedure definitions at runtime,..."
12:29:26 <franka> Well, of course, that depends on your definition of "real".
12:29:36 <vegai> so I guess it never creates binaries with the interpreter
12:29:43 <vegai> that's kinda weak.
12:29:48 <Lor> It should be able to evaluate arbitrary code, even something that's received as run-time input from the user.
12:30:20 <ski> Hughes did a program specializer that when applied to a simple (binding-time annotated) lambda-calc interpreter, and a program for it, specialized the interpreter away, so it compiled the program
12:30:46 <franka> Lor: You can always do that by embedding an interpreter.
12:31:04 <Lor> Then you lose the types.
12:31:13 <franka> There are no types in an untyped language.
12:31:27 <franka> So how is it any worse
12:31:28 <Lor> I thought we were talking about typed languages.
12:31:28 <franka> ?
12:31:35 <franka> We were comparing the two.
12:31:41 <Lor> It's not worse. It's just not enough.
12:31:49 <franka> It's the same.
12:31:58 <SamB> Lor: not necessarily
12:32:02 <franka> And you cannot do MetaML still eval in an untyped language.
12:32:17 <franka> still=style
12:32:22 <franka> Since there are no types to begin with.
12:32:43 <Lor> I'm not at all sure about that.
12:32:53 <xerox> ski: that sound weird :D
12:34:06 <franka> I read your Master's, BTW.
12:34:18 <franka> I had some serious disagreements with parts, which I wrote down somewhere.
12:36:19 <Lor> Your only comment at LtU was about the (admittedly liberal) comparison to Turing machines.
12:37:02 <franka> I don't recall it.  ... and I can't find my notes right now.
12:37:26 <Lor> Ah. Well, I'm quite keen to hear any comments.
12:37:48 <franka> I'll try to find them some other time.
12:38:07 <xerox> @babel en it keen
12:38:09 <lambdabot>  acuto
12:38:19 <xerox> @bot
12:38:20 <lambdabot> :)
12:38:59 <Lor> Somehow I doubt that that conveys the intended meaning correctly. :)
12:39:03 <franka> BTW, you don't always lose the types in an interpreter.
12:39:21 <franka> For example, you can make a typed interpreter using guarded recursive types in GHC.
12:39:36 <ski> xerox : heh
12:39:44 <franka> Though not for the whole language, of course.
12:39:55 <Lor> Right. And there are the fully typed interpreters that Sheard and Pasalic have been working on.
12:40:23 <Lor> But always the interpreted language has a weaker type system than the host language.
12:40:34 <franka> Yes, of course.
12:40:53 <franka> And untyped languages have the weakest type systems of all.
12:41:01 <franka> So, you are no worse off.
12:41:05 <xerox> @eval not False
12:41:07 <lambdabot> True
12:41:23 <xerox> </subtle pun>
12:43:25 <franka> And possibly better off.
12:46:18 <ski> xerox : if you're interested, look at 'type specialisation' at http://www.cs.chalmers.se/~rjmh/pubs.htm
12:46:43 <xerox> ski: tanks.
12:46:47 <xerox> Thanks, even.
12:51:20 * basti_ got expose events working
12:53:17 <Techniks> hey all
12:53:24 <Techniks> I am going through a sample questions page
12:53:24 <Techniks> Rotate the elements of a list (of zero or more elements) to the left. For example [1,
12:53:25 <Techniks> 2, 3, 4] would become [2, 3, 4, 1].
12:53:32 <Techniks> how would i do this
12:53:48 <Techniks> i was able to do the previous question, which wanted a triples elements to the left, which was easy
12:53:55 <Techniks> rotateLeft (a, b, c) = (b, c, a)
12:54:04 <Techniks> rotateLeft :: (Int, Int, Int) -> (Int, Int, Int)
12:54:15 <Techniks> i got that, but i dont understand how to do it with a List
12:54:16 <xerox> Techniks: so it's like, get the head, and the tail, and build up a new list.
12:54:24 <Techniks> of a size thats indefinite
12:54:30 <Techniks> have to do it recursively i think
12:54:39 <xerox> Techniks: yes, taking care of the [] case.
12:54:48 <Techniks> aha
12:54:59 <ulfdoz> x:xs = xs ^ [x]
12:55:09 <xerox> No explicit recursion is really needed.
12:55:16 <Techniks> what does the ^ do again hehe
12:55:32 <xerox> Techniks: f [] = []; f (x:xs) = xs ++ [x]
12:55:43 <marcot> Isn't there a prelude function for it?
12:55:53 <norpan> reverse
12:55:55 <xerox> Techniks: or, if you prefer, the latter could e written as  f xs = tail xs ++ [head xs]
12:56:03 <xerox> @hoogle [a] -> [a]
12:56:04 <lambdabot> Data.List.tail :: [a] -> [a]
12:56:04 <lambdabot> Data.List.init :: [a] -> [a]
12:56:04 <lambdabot> Data.List.reverse :: [a] -> [a]
12:56:07 <xerox> @hoogle+ [a] -> [a]
12:56:08 <lambdabot> Data.List.cycle :: [a] -> [a]
12:56:08 <lambdabot> Prelude.tail :: [a] -> [a]
12:56:08 <lambdabot> Prelude.init :: [a] -> [a]
12:56:08 <ulfdoz> Oh sorry, I'm doing more ocaml in the last months, so I wasn't sure.
12:56:20 <xerox> @eval Data.List.cycle [1,2,3,4]
12:56:21 <lambdabot> [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,
12:56:21 <lambdabot> 1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,
12:56:21 <lambdabot> 2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,
12:56:21 <lambdabot> 3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,
12:56:21 <lambdabot> 4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,
12:56:23 <lambdabot> [23 @more lines]
12:56:28 <ulfdoz> lol
12:56:31 <xerox> I'm sorry.  Dunno :-)
12:56:55 <marcot> xerox: what's the difference between hoogle and hoogle+?
12:57:28 <ski> hoogle+ gets 3 more hits, i think
12:57:30 <xerox> marcot: '+' is like a @more
12:57:36 <ski> @help hoogle+
12:57:36 <lambdabot>  @hoogle <expr>, Haskell API Search for either names, or types.
12:58:01 <marcot> ok, thanks.
12:58:09 <xerox> You're welcome.
12:58:19 <Techniks> thanks "_
12:58:56 <Techniks> how do you count the number of lines in a section of text
12:59:00 <Techniks> is it the return character?
13:00:10 <xerox> @eval countLines = length . filter (=='\n') in countLines $ lines ["hi","mate","foo","bar","baz"]
13:00:10 <lambdabot>  parse error on input `='
13:00:18 <xerox> @eval let countLines = length . filter (=='\n') in countLines $ lines ["hi","mate","foo","bar","baz"]
13:00:18 <lambdabot> Couldn't match `Char' against `String'
13:00:25 <xerox> Woot.
13:00:43 <ski> @type lines ["hi","mate","foo","bar","baz"]
13:00:43 <lambdabot>   Couldn't match `Char' against `[Char]'
13:00:43 <lambdabot>   Expected type: Char
13:00:47 <int-e> @eval length . lines . unlines ["hi","mate","foo","bar","baz"]
13:00:47 <xerox> @eval let countLines = length . filter (=='\n') in countLines $ unlines ["hi","mate","foo","bar","baz"]
13:00:48 <lambdabot>   Expecting a function type, but found `[Char]'
13:00:48 <lambdabot>   Expected type: a -> String
13:00:48 <lambdabot>   Inferred type: String
13:00:48 <lambdabot> 5
13:00:54 <int-e> @eval (length . lines . unlines) ["hi","mate","foo","bar","baz"]
13:00:55 <xerox> :)
13:00:56 <lambdabot> 5
13:01:18 <Techniks> .
13:01:20 <Techniks> means?
13:01:29 <ski> function composition
13:01:30 <xerox> countLines = length . lines
13:01:32 <int-e> (a . b) x = a (b x)
13:01:36 <xerox> countLines xs = length (lines xs)
13:01:36 <ski> (f . g) x = f (g x)
13:01:51 <xerox> Three different explanations in a rowe
13:02:05 <ski> two
13:02:09 <xerox> This community encourages newcomers...
13:02:13 <xerox> Goodnight :-)
13:02:19 <ski> night xerox
13:08:29 <ski> hello Muad_Dib
13:08:54 <Guest50132> hi
13:11:35 <basti_> Cale: why does setGCValues break?
13:14:29 <syntaxfree> http://slashdot.org/article.pl?sid=05/11/03/1744230&tid=190&tid=109
13:17:50 <sylvan> syntaxfree, what now! Interesting! I've been wanting a new OS (instead of old 70's tech with upgrades) for quite some time...
13:20:50 <Techniks> how does one print to the screen in haskell
13:21:08 <Techniks> ie if i want to print "****"
13:21:08 <Techniks> ?
13:21:20 <franka> putStrLn
13:21:25 <franka> or print
13:21:27 <franka> or putStr
13:22:03 <Techniks> cool thx: )
13:24:46 <syntaxfree> @type print
13:24:47 <lambdabot> forall a. (Show a) => a -> IO ()
13:30:04 <Techniks> How would u guys go about writing a program to print a triangle
13:30:07 <Techniks> with stars
13:30:08 <Techniks> hehe
13:30:19 <Techniks> ie if n was Four
13:30:40 <Techniks>         *
13:30:48 <Techniks>       ***
13:31:00 <Techniks>       *****
13:31:09 <basti_> is that a homework problem?
13:31:11 <Techniks>    **********
13:31:15 <Techniks> you get the picture but
13:31:26 <Techniks> nah, im going through a sample examination
13:31:33 <Techniks> i can expect similar questions on my exam hehe
13:31:44 <basti_> @plugs let spaces=' ':spaces in take 10 spaces
13:31:45 <lambdabot> "          "
13:31:59 <Techniks> i want to work it out myself, i just mean, what is ur thinking behind this problem
13:32:13 <franka> First I would ask myself what the type should be.
13:33:02 <Techniks> type?
13:33:16 <basti_> type.
13:33:25 <franka> Yes, what is the type of the function that implements your program?
13:33:32 <Techniks> its just
13:33:39 <Techniks> Printstars n = .....
13:33:43 <Techniks> well
13:33:49 <Techniks> printStars n = ....
13:33:50 <Techniks> then
13:34:04 <franka> That's the program, not its type.
13:34:05 <Techniks> printStars :: Int -> [a]
13:34:13 <franka> Yes.
13:34:16 <Techniks> that what you meant?
13:34:48 <franka> Now I would observe that some recursion is probably involved.
13:34:57 <Techniks> ye[
13:35:01 <Techniks> yep*
13:35:52 <franka> So I would ask myself what the base case and recursive step are.
13:35:56 <Techniks> yep
13:36:45 <franka> What are they?
13:37:16 <Techniks> well u need to print n-1 spaces ++ n number of stars
13:37:19 <Techniks> for each line
13:37:38 <Techniks> well this is what i think hehe
13:37:39 <Techniks> :p
13:37:40 <Oejet> Techniks: Well, for line n, right?
13:37:44 <Techniks> yep
13:37:56 <franka> If n = 0, you print nothing.  This is the base case.
13:38:07 <Techniks> so i use some guards
13:38:19 <Techniks> PrintStars n =
13:38:34 <Techniks>    | (n==0) = print ""
13:38:40 <Techniks>    | otherwise =
13:38:42 <franka> There are two cases, so I get two clauses in my function.
13:38:48 <Techniks> that what u mean?
13:39:02 <franka> Yeah, that's OK, except that print "" does not have type [a].
13:39:18 <musasabi> Techniks: you might want to separate the generation and printing.
13:39:23 <franka> Yes.
13:39:25 <Techniks> two functions?
13:39:40 <Oejet> Techniks: How would you create the string of line n?
13:39:47 <musasabi> Techniks: it is more natural to generate the triangle from bottom-to-top while you have to print from top-to-down.
13:40:20 <ulfdoz> What about \x -> [ print "*" | i <- [1..x]]?
13:40:41 <ulfdoz> [ ] tested
13:41:06 <franka> For the base case, the most natural thing to write is printStars n = []
13:41:15 <franka> Oops, printStars 0 = []
13:41:16 <Techniks> yu[
13:41:22 <Techniks> i knew what u meant
13:41:52 <franka> The other case should look like printStars n = ... printStars (n-1) ...
13:42:19 * musasabi wonders why people use n when i or k would be much more natural
13:42:28 <musasabi> then again math has spoiled me.
13:43:01 <Techniks> n, is logical, n for number haha
13:43:20 <Techniks> wtf is i or k meaning, where is the logic in that
13:43:21 <Techniks> haha
13:44:06 <Techniks> @eval \x -> [ print "*" | i <- [1..x]]
13:44:07 <lambdabot>  add an instance declaration for (Show (a -> [IO ()]))
13:44:10 <Techniks> ?
13:44:25 <ulfdoz> Was just a guess.
13:44:37 <Oejet> Techniks: i and k are typically used as indeces in e.g. sum and product symbols.  n is typically a given constant integer.
13:44:43 <musasabi> Techniks: in math n is usually used for the natural number which is the upper bound while i and k are for recursion indeces.
13:44:53 <franka> Try this: (\x -> [ print "*" | i <- [1..x]]) 5
13:45:05 <Techniks> @eval (\x -> [ print "*" | i <- [1..x]]) 5
13:45:06 <lambdabot> No IO allowed
13:45:51 <Oejet> musasabi: Too slow again. :-P
13:46:06 <musasabi> Oejet: someday I will beat you :-)
13:46:14 <musasabi> and be faster
13:46:38 <franka> @eval (\x -> [ "*" | i <- [1..x]]) 5
13:46:39 <lambdabot> ["*","*","*","*","*"]
13:46:57 <ulfdoz> franka: Fails with IO () is not instance of Show. :(
13:47:00 <Techniks> what is the function to repeat a character
13:47:10 <franka> @eval concat (\x -> [ "*" | i <- [1..x]]) 5
13:47:11 <lambdabot>   The function `concat' is applied to two arguments,
13:47:11 <lambdabot>   but its type `[[a]] -> [a]' has only one
13:47:11 <lambdabot>   In the definition of `xxxx': xxxx = concat (\ x -> ["*" | i <- [... .. .
13:47:11 <lambdabot> ..]]) 5
13:47:13 <Techniks> ie, repeat * 5 times
13:47:19 <Oejet> @type replicate
13:47:21 <lambdabot> forall a. Int -> a -> [a]
13:47:21 <franka> @eval concat $ (\x -> [ "*" | i <- [1..x]]) 5
13:47:22 <lambdabot> "*****"
13:47:52 <ulfdoz> franka: nice :) I knew, list comprehensions are cool, when done right.
13:47:55 <Techniks> @eval replicate 3 "*"
13:47:57 <lambdabot> ["*","*","*"]
13:47:57 <Oejet> @eval replicate 5 '*'
13:47:58 <lambdabot> "*****"
13:48:08 <Techniks> @eval replicate 3 '*'
13:48:09 <lambdabot> "***"
13:48:31 <Techniks> @eval (replicate 3 ' ') ++ '*'
13:48:32 <lambdabot> Couldn't match `[Char]' against `Char'
13:48:44 <Techniks> @eval (replicate 3 " ") ++ '*'
13:48:45 <lambdabot> Couldn't match `[[Char]]' against `Char'
13:48:55 <Techniks> @eval (replicate 3 ' ')
13:48:56 <lambdabot> "   "
13:48:58 <musasabi> @eval (replicate 3 ' ') ++ "*"
13:48:59 <lambdabot> "   *"
13:49:07 <Techniks> hehe
13:49:20 <musasabi> @type ' '
13:49:21 <lambdabot> Char
13:49:25 <musasabi> @type " "
13:49:26 <lambdabot> [Char]
13:49:34 <musasabi> That is the difference.
13:49:43 <musasabi> And [Char] == String.
13:50:16 <ulfdoz> Shouldn't be a problem, to write some generalized loop function by recursion.
13:52:17 <franka> Techniks: Do you see the solution now?
13:52:34 <Techniks> printStars :: Int -> [a]
13:52:34 <Techniks> printStars 0 = []
13:52:34 <Techniks> printStars n =
13:52:34 <Techniks>    print replicate (n-1) ' ' ++ (replicate (n-1) '*')
13:52:34 <Techniks>    printStars (n-1)
13:52:40 <Techniks> this is what i have so far
13:52:43 <Techniks> just experiemnting
13:52:52 <Techniks> i get an error with that, i dont understand why iether hehe
13:53:18 <franka> One thing that will help you is to change the name of the function.
13:53:31 <franka> It shouldn't be called printStars because it has type Int -> [a].
13:53:37 <franka> It produces a list, but doesn't print it.
13:53:40 <Techniks> aha
13:53:44 <franka> Call it 'stars'.
13:53:55 <ulfdoz> Techniks: You get a type error, bcoz type of print.
13:54:04 <ulfdoz> @type print
13:54:05 <lambdabot> forall a. (Show a) => a -> IO ()
13:54:14 <ulfdoz> @type []
13:54:15 <lambdabot> forall a. [a]
13:55:28 <Techniks> still get same error
13:55:28 <Techniks> hmm
13:55:59 <ulfdoz> Techniks: All cases must return same type.
13:56:04 <ulfdoz> s/return/have/
13:56:06 <Techniks> stars n = putStrLn replicate n "*"
13:56:06 <Techniks> printStars :: Int -> [a]
13:56:06 <Techniks> printStars 0 = []
13:56:06 <Techniks> printStars n =
13:56:06 <Techniks>    stars (n-1)
13:56:13 <Techniks> how can i make this to not have an error
13:56:33 <franka> You have it backwards.
13:56:40 <Techniks> forget the logic
13:56:41 <Techniks> its not done
13:56:46 <Muad_Dibber> Techniks: what is the type of stars?
13:56:48 <Techniks> i just want it to print some stars at this point
13:56:48 <Techniks> hehe
13:56:53 <Techniks> [a]
13:56:56 <Techniks> a string
13:56:59 <franka> 'stars' should be the function of Int -> [a], and 'printStars' should be the one that calls 'stars'.
13:57:07 <Muad_Dibber> Techniks: are you sure about that?
13:57:14 <Techniks> yeah
13:57:27 <Techniks> the stars are a string, definately
13:57:29 <Techniks> hehe
13:57:33 <Muad_Dibber> @type putStrLn replicate n "*"
13:57:34 <lambdabot> Not in scope: `n'
13:57:41 <Muad_Dibber> @type \n -> putStrLn replicate n "*"
13:57:42 <lambdabot>   The function `putStrLn' is applied to three arguments,
13:57:42 <lambdabot>   but its type `String -> IO ()' has only one
13:57:53 <musasabi> stars :: Int -> [String], printStars :: Int -> IO ()
13:57:57 <Muad_Dibber> @type \n -> putStrLn $ replicate n "*"
13:57:57 <lambdabot>   Couldn't match `Char' against `[Char]'
13:57:57 <lambdabot>   Expected type: Char
13:58:13 <Techniks> surely somebody knows how to do this
13:58:17 <Techniks> its very simple i thought :\
13:58:40 <musasabi> Techniks: you might want to first generate a list of the lines and worry about IO later.
14:00:11 <Techniks> okei
14:00:22 <Techniks> can you walk me through this
14:01:57 <franka> You will write a function 'stars' of type Int -> [String].
14:02:21 <Techniks> stars :: Int -> [a]
14:02:22 <Techniks> stars n = replicate n "*"
14:02:25 <Techniks> so far
14:02:26 <Techniks> yep
14:02:36 <musasabi> I would start thinking about it like: 1) the bottom line has n-stars. 2) the next line up has n-2 stars and 1 space around it, 3) the next line has n-4 stars and 2 spaces around it, ... N) the line is empty.
14:02:52 <franka> So stars 3 = ["   ", " * ", "***"]
14:03:31 <musasabi> Now you need to find out the recursion pattern in that and the case where you stop the recursion.
14:03:45 <franka> Given a list like this, you can print it with: putStrLn (unlines ["  ", " * ", "***"])
14:03:57 <franka> So that part is something you don't have to worry about, let us say.
14:04:12 <franka> @eval  unlines ["  ", " * ", "***"]
14:04:13 <lambdabot> "  \n * \n***\n"
14:05:22 <franka> (Or actually you might have stars 3 produce a list which is a bit different, but anyway.)
14:06:27 <franka> printStars n = putStrLn (unlines (stars n))
14:06:35 <franka> OK, that part is done.  Let's concentrate on stars.
14:07:17 <Techniks> stars :: Int -> [a]
14:07:17 <Techniks> stars 0 = " "
14:07:17 <Techniks> stars n =
14:07:17 <Techniks>    replicate n "*" : (stars (n-1))
14:07:29 <Techniks> why is this giving me an error
14:07:43 <franka> The type is Int -> [String].
14:07:49 <Techniks> yep and
14:07:55 <franka> You have Int -> [a]
14:08:01 <Techniks> whats the difference there
14:08:15 <franka> String is a type, while a is a type variable.
14:08:20 <Techniks> aha
14:08:31 <Techniks> what about if i did
14:08:35 <Techniks> Int -> a
14:08:37 <Techniks> then.. ?
14:08:42 <Techniks> what does this mean, i meant
14:08:43 <Techniks> hehe
14:08:47 <franka> [String] is a list of strings.  [Int] is a list of integers.  [Char] is a list of characters, that is, a string.
14:08:59 <Techniks> aha
14:09:16 <franka> Int -> a would be the type of functions which, given an Int, can produce a value of any type.
14:09:17 <Techniks> so if i use
14:09:24 <franka> Such functions don't exist.
14:09:31 <Techniks> Int -> [a]
14:09:39 <Techniks> this means input a Integer output 1 string
14:09:40 <Techniks> ?
14:10:05 <franka> No, it means input an Int, and output a list of anything.
14:10:16 <Techniks> just means a list
14:10:18 <Techniks> ok
14:10:26 <Techniks> but, a string a list
14:10:30 <Techniks> isnt it?
14:10:35 <Techniks> its just a list of characters
14:10:35 <franka> Yes.
14:10:40 <benmos> Hi - quick question that someone might know the answer to - does the current GHC use a descendent of the "Henk" TIL? or did that never happen?
14:10:48 <franka> You are returning a list of lists of characters.
14:11:14 <franka> benmos: I think it is related, although I don't know if it is a descendant.
14:11:23 <franka> Oops. No.
14:11:37 <franka> Henk is a PTS.  GHC uses a second-order lambda-calculus, I think.
14:11:40 <benmos> ok, thanks... is the Oops. to me?
14:11:44 <benmos> ah, ok.
14:12:06 <Techniks> so how do i make a list of stars going from 1 to 10
14:12:06 <Techniks> ie
14:12:08 <Techniks> [
14:12:23 <franka> Techniks: You are returning a list [], of lists [], of characters Char.
14:12:28 <franka> Hence [[Char]]
14:12:42 <Techniks> ["*", "**", "***".., "**********"]
14:12:43 <franka> And String = [Char], hence [[Char]] = [String]
14:14:33 <franka> That is close to the function we are writing.
14:15:13 <int-e> @eval scanl (:) "" "*******"
14:15:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:15:14 <lambdabot>   Expected type: a -> [a] -> a
14:15:14 <lambdabot>   Inferred type: a -> [a] -> [a]
14:15:47 <franka> Would you like to write that? Let's call it 'starStrings'.
14:16:00 <Techniks> i just want to learn how to print the star Triangle
14:16:06 <Techniks> surely this is 3-4 lines of short code :S
14:16:07 <int-e> @eval scanl (flip (:)) "" "*******"
14:16:08 <lambdabot> ["","*","**","***","****","*****","******","*******"]
14:16:46 <franka> int-e: I don't think that is going to help him.
14:16:54 <int-e> @eval take 6 $ iterate ('*':) ""
14:16:55 <lambdabot> ["","*","**","***","****","*****"]
14:17:07 <int-e> franka: just fooling around, sorry
14:18:05 <int-e> @eval map (`replicate` '*') [0..6]
14:18:06 <lambdabot> ["","*","**","***","****","*****","******"]
14:18:10 <franka> OK, let's just print a right triangle.  Then we can get to the triangle you want pretty quickly.
14:18:28 <Techniks> ok
14:18:39 <franka> If n = 0, we have an empty list.  stars 0 = []
14:18:52 <Techniks> got it
14:19:31 <franka> If n=1, we want a list ["*"] = "*" : [].
14:20:11 <franka> If n=2, we want a list ["**", "* "] = "**" : "* " : [].
14:20:15 <franka> And so on.
14:20:41 <Techniks> got that :)
14:21:02 <franka> I meant: If n=2, we want a list ["**", "*"] = "**" : "*" : [].
14:21:10 <franka> (no ending spaces)
14:21:27 <Techniks> yup
14:21:49 <franka> And we know replicate n '*' produces a string with n stars.
14:22:00 <syntaxfree> as Haskellers, would you choose Common Lisp or MIT Scheme?
14:22:13 <franka> Scheme.
14:22:41 <franka> So stars n = replicate n '*' : stars (n-1) is the recursive step.
14:23:33 <Techniks> now we make a printStars function
14:23:55 <franka> I already gave it to you earlier.
14:24:12 <franka> printStars n = putStrLn (unlines (stars n))
14:24:24 <Techniks> yep
14:25:22 <Techniks> @help reverse
14:25:22 <lambdabot>  @help <command> - ask for help for <command>
14:25:37 <Techniks> @help <reverse>
14:25:37 <lambdabot>  @help <command> - ask for help for <command>
14:25:45 <franka> @type reverse
14:25:46 <lambdabot> forall a. [a] -> [a]
14:25:52 <ulfdoz> @help
14:25:52 <lambdabot>  @help <command> - ask for help for <command>
14:26:03 <Techniks> ok the function gives me this now
14:26:10 <Techniks> ****
14:26:11 <Techniks> ***
14:26:12 <Techniks> **
14:26:13 <Techniks> *
14:26:19 <Techniks> obviously i need to print the string backwards
14:26:20 <Techniks> hehe
14:26:22 <franka> Yes, so you're halfway there.
14:26:33 <franka> Not quite, but almost.
14:27:01 <Techniks> just need a pattern matching function
14:27:33 <Techniks> :\
14:29:53 <Techniks> how do i do this :\
14:31:40 <franka> Try: stars n = reverse s ++ s where s = replicate n '*' : stars (n-1)
14:31:54 <franka> Oops, no.
14:32:28 <ski> Techniks : do you want the list in reverse order ??
14:32:31 <franka> stars n = reverse s ++ s : stars (n-1) where s = replicate n '*'
14:33:20 <ski> hm
14:34:18 <musasabi> @eval let stars n = inner n 0 where inner 0 _ = []; inner j k = (replicate k ' ' ++ replicate j '*' ++ replicate k ' ') : inner (j-2) (k-1) in stars 5
14:34:19 <lambdabot> ["*****","***","*","","","","","","","","","","","","","","","","","","","
14:34:19 <lambdabot> ","","","","","","","","","","","","","","","","","","","","","","","","",
14:34:19 <lambdabot> "","","","","","","","","","","","","","","","","","","","","","","","",""
14:34:19 <lambdabot> ,"","","","","","","","","","","","","","","","","","","","","","","","","
14:34:19 <lambdabot> ","","","","","","","","","","","","","","","","","","","","","","","","",
14:34:21 <lambdabot> [23 @more lines]
14:34:26 <ski> @type let stars n = reverse s ++ s : stars (n-1) where s = replicate n '*' in stars
14:34:27 <lambdabot>   Couldn't match `Char' against `[Char]'
14:34:27 <lambdabot>   Expected type: [Char]
14:34:32 <ski> right
14:34:35 <Techniks> ugh i didnt realise this was so hard
14:34:36 <Techniks> lol
14:34:42 <musasabi> termination would be good too.
14:35:02 <musasabi> @eval let stars n = inner n 0 where inner j _ | j <= 0 = []; inner j k = (replicate k ' ' ++ replicate j '*' ++ replicate k ' ') : inner (j-2) (k-1) in stars 5
14:35:03 <lambdabot> ["*****","***","*"]
14:35:08 * ski tries to understand what problem should be solved ..
14:35:11 * musasabi is too tired
14:35:26 <ski> Techniks : what should e.g. 'stars 3' be ?
14:35:34 <Techniks> *
14:35:34 <Techniks> **
14:35:35 <Techniks> ***
14:35:42 <ski> just that ?
14:35:49 <Techniks> for now yep
14:35:54 <Techniks> we got this so far
14:35:55 <ski> that's dead simple
14:36:07 <Techniks> ["***", "**", "*"]
14:36:12 <ski> right
14:36:27 <ski> you want the "*" first, and the "***" last
14:36:44 <ski> right ?
14:37:04 <franka> stars n = (reverse s ++ s) : stars (n-1) where s = replicate n '*'
14:37:13 <franka> Sorry, I got the precedence wrong.
14:37:14 <Techniks> yeps skik
14:37:16 <Techniks> ski
14:37:32 <int-e> you want stars' n = reverse (stars n)
14:37:41 * ski wonder why franka complicates it ..
14:37:44 <int-e> or a different stars function.
14:37:59 <franka> No, int-e: that is only the second clause of a declaration.
14:38:16 <ski> Techniks : you just want the individual strings in the reverse order, iiuc
14:38:21 <int-e> franka: reversing strings of stars will do you no good
14:38:25 <Techniks> yeah :)
14:38:38 <Techniks> cant i just take the tail
14:38:39 <franka> It will. Try it.
14:38:46 <ski> Techniks : so, if you reverse the list of those star-strings, you get in opposite order
14:38:49 <Techniks> print it and pass the head to a function
14:38:50 <Techniks> ?
14:39:02 <franka> int-e: The way you do it you have to interleave them.
14:39:16 <ski> Techniks : you could print the tail first, and then the head, yes
14:39:34 <int-e> franka: no. I make a *new* function that uses star and reverses the returned list.
14:39:43 <ski> Techniks : but, it seems simpler to just reverse the order, and then print ["***","**","*"]
14:40:05 <int-e> franka: besides I'd probably just define stars n = map (`replicate` '*') [1..n]  and be done with it.
14:40:13 <franka> No, you don't get it.
14:40:44 <int-e> franka: s++reverse s where s is a string of only stars  is the same as s++s - a string of stars but with double length.
14:40:51 <franka> stars n ++ stars' n is not what is wanted.
14:40:58 <Techniks> how do i reverse a list of strings then?
14:41:18 <franka> int-e: Ah, wait, I forgot the spaces.
14:41:23 <ski> Techniks : just as you reverse any list
14:41:33 <int-e> Techniks: you do it after stars has run. like: (putStrLn . unlines . reverse) stars n
14:41:37 <ski> @eval reverse ["foo","bar","baz"]
14:41:38 <lambdabot> ["baz","bar","foo"]
14:41:48 <int-e> err, (putStrLn . unlines . reverse) (stars n)
14:41:52 <ski> @eval reverse ["one","two","three"]
14:41:54 <lambdabot> ["three","two","one"]
14:42:09 <ski> Techniks : ok ?
14:42:35 <franka> stars 0 m = replicate m ' '
14:42:42 <ski> int-e : or (mapM_ putStrLn . reverse . stars) n
14:43:41 <int-e> ski: Hmm I'd write sequence . map putStrLn . -- I've never used mapM_ ...
14:43:54 <Techniks> printStars n = putStrLn (unlines reverse(stars n))
14:44:01 <ski> mapM = sequence . map
14:44:02 <Techniks> this gives me an error
14:44:26 <ski> Techniks : you need another pair of parens
14:44:33 <ski> or use '.' or '$'
14:44:33 <Techniks> aha
14:44:38 <franka> stars n m = (replicate (n-m) '  ' ++ reverse s ++ s ) ++ replicate (n-m) ' '): stars (n-1) where s = replicate n '*'
14:44:57 <franka> stars 0 m = replicate (2*m) ' '
14:45:08 <franka> Crap.
14:45:11 <franka> I hate IRC.
14:45:11 <ulfdoz> And the "Teacher of the month"-Award goes to franka. :)
14:45:26 <franka> stars n m = (replicate (n-m) '  ' ++ reverse s ++ s ) ++ replicate (n-m) ' '): stars (n-1) m where s = replicate n '*'
14:45:27 <ulfdoz> franka: Eh, where else to meet others?
14:46:04 <ski> Techniks : does it work, now ?
14:46:40 <franka> ulfdoz: Actually was thinking about going out to meet others tonight, but it's getting late...
14:46:41 <Techniks> sure does :)
14:46:47 <Techniks> thx ski
14:47:01 <yozora> @type \x y -> x >>= \z -> y x
14:47:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (m a -> m b) -> m b
14:47:12 <yozora> @pl \x y -> x >>= \z -> y x
14:47:13 <lambdabot> liftM2 (.) (>>=) ((const .) . flip id)
14:48:20 <ski> yozora : did you intend to throw away 'z' ?
14:48:32 <ski> @type \x y -> x >>= \z -> y z
14:48:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:48:35 <yozora> nah, i'm just playing with pl
14:48:43 <yozora> i saw it in the logs
14:48:45 <ski> @pl \x y -> x >>= \z -> y z
14:48:45 <lambdabot> (>>=)
14:48:50 <yozora> and thaough "that looks fun"
14:48:53 <yozora> thought*
14:49:10 <ski> @pl \f g x y -> f (g x y)
14:49:10 <lambdabot> (.) . (.)
14:49:17 <ski> smiley generator
14:49:22 <yozora> hehe
14:49:39 <ulfdoz> I see tits. :)
14:49:46 <yozora> oh btw, is the latest version of haskelldb the one on the sourceforge site?
14:49:53 <franka> Maybe I'll just stay in and read.
14:50:04 <Techniks> now all i need to do is make this
14:50:05 <Techniks> into this
14:50:07 <Techniks> *
14:50:09 <ski> @vixen did you hear what ulfdoz said about you?
14:50:10 <Techniks> ***
14:50:10 <lambdabot> what about me?
14:50:11 <interferon> can someone point me at a good explanation of monads
14:50:12 <Techniks> *****
14:50:13 <Techniks> into
14:50:20 <Techniks>    *
14:50:23 <Techniks>   ***
14:50:30 <Techniks> *****
14:50:33 <Techniks> erm
14:50:38 <Techniks>   *****
14:50:44 <ski> @wiki MonadsAsContainers
14:50:44 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
14:50:47 <Techniks> so its a proper triangle
14:50:52 <ski> interferon : try that one
14:51:01 <ski> @google all about monads
14:51:02 <lambdabot> http://www.nomaware.com/monads/html/
14:51:04 <interferon> ski, thanks
14:51:13 <ski> interferon : and that one
14:52:10 <yozora> i tried compiling the 0.9 version of haskelldb and bumped into source code problems
14:52:16 <ski> Techniks : now you want to have successive odd numbers of stars, right ?
14:52:26 <Techniks> nup
14:52:41 <Techniks> you just need to insert white space at the beginning of the string i think
14:53:12 <ski> and, decreasing number of spaces in front of each star sequence
14:53:17 <Techniks> yep
14:53:25 <ulfdoz> @help vixen
14:53:26 <lambdabot> sergeant curry's lonely hearts club
14:53:40 <ski> yes, that, and change from 1,2,3 to 1,3,5 number of stars
14:53:47 <ski> maybe you should start with doing
14:53:48 <ski> *
14:53:49 <ski> ***
14:53:50 <ski> *****
14:53:53 <ski> *******
14:54:06 <Techniks> i have :)
14:54:10 <ski> and then add the spaces
14:54:13 <ski> ok, :)
14:54:17 <Techniks> stars n = replicate (n*2 - 1) '*' : stars (n-1)
14:54:17 <Techniks> printStars n = putStrLn (unlines (reverse(stars n)))
14:54:25 <Techniks> now i need to figure the whitespace bit out
14:54:31 <ski> right
14:54:52 <ski> one way to do it would be to use zipWith
14:55:32 <ski> @eval zipWith (+) [3,2,1] [10,20,30]
14:55:33 <lambdabot> [13,22,31]
14:56:07 <ski> you could also do it in a more primitive way, if you want
14:56:19 <int-e> @pl \m -> replicate (n-m) ' '++replicate (2*m-1) '*'
14:56:19 <lambdabot> ap ((++) . flip replicate ' ' . (-) n) (flip replicate '*' . subtract 1 .
14:56:19 <lambdabot> (2 *))
14:56:43 <ski> (interferon : feel free to ask when wondering about somwthing ..)
14:57:48 <franka> Shit, you're right my function was totally wrong.
14:58:23 <ski> (Techniks : you could use zipWith to join a list ["   ","  "," ",""] with a list ["*","***","*****","*******"], element by element ..)
15:01:57 <Techniks> 'a' ++ replicate (n*2 - 1) '*'
15:02:01 <Techniks> how can i add something like
15:02:02 <Techniks> 'a'
15:02:04 <Techniks> or ' '
15:02:06 <Techniks> before that
15:02:08 <Techniks> ?
15:02:12 <Techniks> like add it to that string
15:02:13 <Techniks> ?
15:02:39 <Lemmih> "a" ++ ...
15:03:17 <Techniks> yeah thats what i did
15:04:10 <int-e> Techniks: 'a' is a single character. "a" is a string, a list of characters.
15:05:00 <Techniks> gotcha
15:05:41 <ski> Techniks : you also prolly need a pair of parens, to get it like (... ++ ...) : ...
15:06:11 <Techniks> gives me an error
15:06:17 <Techniks> [[]] not []
15:06:18 <Techniks> or something
15:07:06 <ski> what is the error ?
15:07:18 <Techniks> String
15:07:22 <Techniks> does not match [[Char]]
15:08:23 <Techniks> got it now :)
15:08:26 <Techniks> my bad
15:08:43 <SamB> is anyone a glade expert?
15:09:06 <SamB> or even reasonably competent?
15:10:41 <ski> Techniks : and what is your code, now, then ?
15:18:43 <lightstep> the Hoogle page in the wiki is immutable
15:19:25 <lightstep> so may the owner move the Monad m => [m a] -> m [a] example from "Todo" to "Bad Searched"
15:19:30 <lightstep> ?
15:20:05 <SamB> anyone want to give me some pointers on glade? I have a partial mockup for Conjurer's download window and I'm having a bit of trouble with it
15:20:40 <SamB> er, s/conjurer/conjure/
15:23:39 <araujo> @index readline
15:23:40 <lambdabot> System.Console.Readline
15:24:32 <Techniks> stars 0 0= []
15:24:32 <Techniks> stars n m = (replicate m ' ' ++ replicate (n*2 - 1) '*') : stars (n-1) (m+1)
15:24:32 <Techniks> printStars n = putStrLn (unlines (reverse(stars n 0)))
15:24:37 <Techniks> i am getting a garbage collection error
15:24:39 <Techniks> anyone know why?
15:25:20 <lightstep> what is the error?
15:25:22 <Techniks> if i try to do a replicate 0 ' '
15:25:24 <Techniks> is that an error?
15:25:27 <ski> you are incrementing m
15:25:32 <Techniks> yep
15:25:40 <ski> so, you shouldn't match it against 0 in the base case
15:25:47 <ski> then that will not match
15:25:52 <Techniks> m is for the spaces
15:25:55 <Techniks> not the stars
15:25:55 <Techniks> hehe
15:26:04 <ski> just ignore m in the base case
15:26:04 <lightstep> Techniks, this is an infinite loop that allocates memory
15:26:26 <lightstep> you require both the parameters to be 0 in the base case
15:26:40 <Techniks> thats what i had isnt it
15:27:06 <Techniks> or should i do
15:27:10 <Techniks> stars 0 m = []
15:27:22 <lightstep> yes
15:27:35 <Techniks> done
15:27:36 <Techniks> i did it :p
15:27:37 <lightstep> or, stars 0 _ = []
15:27:38 <Techniks> thx guys
15:28:41 <Techniks> is there a function to pick a random string from a list? hehe
15:28:46 <Techniks> ie
15:29:04 <Techniks> ['*', 'F', '%', 'D']
15:29:11 <Techniks> to pick a random char from that list
15:29:30 <ski> you need a random generator
15:29:37 <Techniks> ah yeha
15:32:52 <Techniks> printStars n = putStrLn (unlines (reverse(stars n 0)))
15:32:52 <Techniks> upsideprintStars n = putStrLn (unlines (stars n 0))
15:32:52 <Techniks> diamond n =
15:32:52 <Techniks>    printStars n
15:32:52 <Techniks>    upsideprintStars n
15:32:55 <Techniks> what is wrong with this
15:32:58 <Techniks> getting IO error :S
15:33:20 <ski> you're missing a 'do'
15:35:08 <Techniks> thx
15:36:32 <Techniks> hehe cool now i can print diamonds to the screen :P
15:36:33 <Techniks> haha
15:39:51 <ulfdoz> lol
15:40:25 <ski> Techniks : nice
15:40:28 <ulfdoz> Techniks: For more practice, I can give you my homework. I need it on wednesday. :)
15:40:49 <Techniks> lol!
15:40:55 <Techniks> i have an exam tm, so i am studying hard
15:40:55 <Techniks> hehe
15:41:03 <ulfdoz> No joke, I wanted to do it today, but yesterday I was drunk, so no single line written yet.
15:41:29 <Techniks> what is the test for a prime number, do u need to recursively loop through it to try to get mod x = 0
15:41:38 <Techniks> and if u dont get that, its prime?
15:41:44 <Techniks> is there a simpler way or is this it hehe
15:42:18 <ulfdoz> Last week I found a short one, but it isn't optimised.
15:42:41 <ulfdoz> found is the wrong word, I mean wrote.
15:43:37 <yozora> you can use trial division up to square root of the number
15:43:49 <yozora> there are quicker probabalistic methods
15:44:06 <ulfdoz> but they aren't proven. ;)
15:44:47 <Korollary> http://mathworld.wolfram.com/PrimalityTest.html
15:44:52 <ulfdoz> 2^n - 1 is always prime. :)
15:45:21 <yozora> @eval 2^8 - 1
15:45:21 <lambdabot> 255
15:45:37 <Techniks> listNumbers :: Int -> Int -> [a]
15:45:37 <Techniks> listNumbers x y = [n | n <- [x..y]]
15:45:37 <yozora> @eval mod (2^8 - 1) 5
15:45:38 <lambdabot> 0
15:45:44 <Techniks> whats wrong with this?
15:46:15 <ulfdoz> ok, you won.
15:46:23 <yozora> @eval (\x y -> [n | n <- [x..y]]) 1 5
15:46:24 <lambdabot> [1,2,3,4,5]
15:46:34 <yozora> the return type has to be int
15:46:40 <yozora> i think, if the params are int
15:46:46 <yozora> @type (\x y -> [n | n <- [x..y]])
15:46:47 <lambdabot> forall a. (Enum a) => a -> a -> [a]
15:47:01 <Techniks> can anyone explain these so i properly understand it not just use
15:47:03 <Techniks> <-
15:47:04 <yozora> @type (\(x::Int) (y::Int) -> [n | n <- [x..y]])
15:47:05 <lambdabot> Int -> Int -> [Int]
15:47:09 <Techniks> ->
15:47:13 <Techniks> whats the difference
15:47:14 <Techniks> ?
15:47:26 <yozora> <- gets used in monads and list comprehension
15:47:33 <Techniks> ok
15:47:41 <yozora> -> gets used in type definitions and lambda expressions
15:47:47 <Techniks> aha
15:47:50 <yozora> and case statements, i think
15:47:52 <Techniks> =>
15:47:54 <Techniks> ?
15:48:02 <yozora> type contraints
15:48:13 <yozora> @type sort
15:48:14 <lambdabot> Not in scope: `sort'
15:48:21 <yozora> @type (>=)
15:48:22 <lambdabot> forall a. (Ord a) => a -> a -> Bool
15:48:41 <yozora> for example, >= is only defined on types with an ordering relationship
15:48:55 <yozora> so the Ord is a type constraint
15:49:08 <yozora> I hope i'm not torturing the terminology
15:50:23 <ski> @eval (\x y -> [x..y]) 1 5
15:50:25 <lambdabot> [1,2,3,4,5]
15:50:36 <ski> listNumbers x y = [x..y]  -- this is simpler
15:50:37 <Techniks> ok now for a function that finds prime numbers
15:50:42 <Techniks> yeah
15:50:54 <Techniks> primeNumbers :: Int -> Int -> [Int]
15:50:54 <Techniks> primeNumbers x y = [n | n <- [x..y], (n `isprime` 2) == 1]
15:51:22 <Techniks> isprime :: Int -> Int
15:51:31 <Techniks> if its prime it returns 1 else 0
15:52:08 <Techniks> should i use an if statement here
15:52:10 <Techniks> :S
15:52:12 <Lemmih> There's 'Bool' for that.
15:52:25 <Techniks> yeah there is but my other functions are using that structure
15:52:30 <Techniks> so im just going to use 0 and 1
15:52:32 <Techniks> for this
15:52:39 <Techniks> i understand its just as easy to use Bool though.
15:52:40 <Techniks> :)
15:52:49 <yozora> eww, kind of C-ish
15:53:00 <Speck> yeah. definitely not Haskell style
15:53:04 <Techniks> oh well hehe
15:53:24 <Techniks> how do i check if a number is prime
15:53:34 <Techniks> do i start from 2 upwards till i get to n
15:53:37 <Speck> is speed important?
15:53:41 <Techniks> nup
15:53:58 <Techniks> do i just check for  n mod x = 0
15:54:11 <astrolabe> nup = no + yup?
15:54:18 <Techniks> until x = n-1
15:54:18 <Techniks> ?
15:54:39 <yozora> until x > sqrt n
15:54:53 <yozora> you don't have to go above the sqrt
15:54:56 <Techniks> thats ugly but
15:55:06 <Techniks> coz not all numbers have a whole sqrt
15:55:07 <Techniks> hehe
15:55:14 <Techniks> sure its less efficient though
15:55:15 <Techniks> :)
15:55:15 <astrolabe> until x*x>n
15:55:43 <Techniks> so how do i put this into haskell code hehe
15:56:06 <Speck> recurse over x
15:56:12 <ski> @type all
15:56:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:56:21 <ski> @eval all odd [1,3,5,7]
15:56:22 <lambdabot> True
15:56:25 <ski> @eval all odd [1,3,5,6,7]
15:56:27 <lambdabot> False
15:57:00 <ski> you could use that to check that all nums from 2 upwards to whenever you stop has modulus /= 0
15:59:57 <BigMike04> hey
16:00:09 <BigMike04> does anyone can give a newbie here a guide to hack?
16:00:31 <astrolabe> @learn
16:00:31 <lambdabot> http://www.haskell.org/learning.html
16:00:42 <BigMike04> @learn
16:00:43 <lambdabot> http://www.haskell.org/learning.html
16:00:48 <BigMike04> @learn
16:00:48 <lambdabot> http://www.haskell.org/learning.html
16:00:52 <BigMike04> opps sorry
16:00:55 <astrolabe> :)
16:01:01 <astrolabe> Give one of those a try
16:01:02 <Speck> I wish that was enough :-(
16:01:03 <Korollary> hey astro
16:01:05 <ski> @google yet another haskell tutorial
16:01:06 <lambdabot> http://www.isi.edu/~hdaume/htut/
16:01:14 <ski> @google haskell c tutorial
16:01:15 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
16:01:19 <astrolabe> Hia Korollary.  How's tricks?
16:01:31 <ulfdoz> Hack? He knows C!
16:01:33 <ski> BigMike04 : check those out, too
16:01:35 <BigMike04> i got one right here but it is exploit tut http://www.wifiscan.net/td/tutorials/exploits.htm
16:01:39 <Korollary> astrolabe: aw'right matey. heh.
16:01:49 <BigMike04> now, any of you guys actually hack?
16:01:59 <Korollary> Ugh
16:02:14 <Speck> I think we have different working definitions of "hack"
16:02:15 <ulfdoz> I prefer "to program".
16:02:18 <Korollary> "that" kind of hacking... umm no.
16:02:21 <Lemmih> I so hope you're a bad joke.
16:02:57 <astrolabe> You need to say 'where hack = ...'
16:03:19 <Speck> the best advice I can give if you want to learn how to be a hax0r is to learn C. Maybe you'll get so distracted you come out a good programmer by mistake.
16:03:42 <BigMike04> yes a friend told me that
16:04:09 <BigMike04> im only 16 guys..the so far i have taken info tech..next year i will be in cisco
16:04:10 <Speck> what would you do with your hacking knowledge?
16:04:51 <Korollary> Why hack instead of program useful stuff like decent people ...
16:04:58 <BigMike04> what will i do with the hacking knowledge? just like anyonem hack computers! lol im joking. i would use it in good use and not to mess around or anything.
16:05:12 <astrolabe> LOL!
16:05:17 <rep> hacking is fun.
16:05:28 <ulfdoz> He watched 23. This evening it was broadcasted in germany.
16:05:32 <rep> and you learn a lot
16:06:09 <BigMike04> but yeah is cisco worth it?
16:06:16 <yozora> hacking for a noble cause then huh
16:06:32 <Speck> learn C, they probably have a channel somewhere. Haskell is horrible if you want to have dangerous knowledge -- you might accidentally hurt your manhood in Oleg's zipper, but you couldn't DDoS anyone with Haskell; your heap would explode.
16:09:14 <Techniks> isPrime :: Int -> Int
16:09:15 <Techniks> isPrime x = do
16:09:22 <Techniks> can someone help me, i want to return 1 if prime
16:09:24 <Techniks> zero if not
16:09:25 <Techniks> :S
16:09:41 <ulfdoz> Why won't you return True or False?
16:09:49 <Techniks> because i want to do it this way
16:09:52 <yozora> @eval \x -> if x then 1 else 0 $ True
16:09:53 <lambdabot>  add an instance declaration for (Num (Bool -> b))
16:09:59 <yozora> @eval (\x -> if x then 1 else 0) $ True
16:10:00 <lambdabot> 1
16:10:04 <yozora> @eval (\x -> if x then 1 else 0) $ False
16:10:05 <lambdabot> 0
16:10:09 <Techniks> yeah i understand Bool is easiest
16:10:14 <Techniks> but i want to implement it this way
16:10:18 <Techniks> as i may be tested on it
16:10:19 <Techniks> ok ?
16:10:24 <Techniks> thats not the bit i dont understand
16:10:30 <Techniks> its how to make the isPrime function
16:10:31 <Techniks> :S
16:10:41 <yozora> why would they test you on returning 0s and 1s?
16:10:49 <Techniks> grtt
16:10:55 <Techniks> forget the 0 and 1's
16:11:02 <Speck> Techniks: iirc, there is a prime example on the wikipedia entry on Haskell
16:11:12 <Techniks> wikipedia?
16:11:21 <yozora> @eval takewhile (\x -> x*x <= 10) [1..]
16:11:22 <lambdabot>  Not in scope: `takewhile'
16:11:27 <yozora> @eval takeWhile (\x -> x*x <= 10) [1..]
16:11:28 <lambdabot> [1,2,3]
16:11:52 <SamB> @pl f x = x - 1
16:11:53 <lambdabot> f = subtract 1
16:12:17 <yozora> @pl \x y -> x >>= \z -> y z
16:12:18 <lambdabot> (>>=)
16:12:26 <yozora> @pl \x y -> x >>= \z -> z y
16:12:26 <lambdabot> (. flip id) . (>>=)
16:12:52 <yozora> @pl \x y z -> z y x
16:12:52 <lambdabot> flip (flip . flip id)
16:16:43 <Techniks> how can i loop back from 10 to find the prime numbers
16:19:13 <ski> @eval let x = 13 in takeWhile (\x -> x*x <= x) [1..]
16:19:14 <lambdabot> [1]
16:19:25 <Techniks> that cant be right
16:19:28 <ski> hm
16:19:29 <ski> no
16:19:32 <Techniks> coz say it was 10, that limits it to just 3
16:19:32 <Techniks> hehe
16:19:41 <ski> @eval let x = 13 in takeWhile (\d -> d*d <= x) [1..]
16:19:42 <lambdabot> [1,2,3]
16:19:48 <ski> that's better
16:19:51 <ski> @eval let x = 17 in takeWhile (\d -> d*d <= x) [1..]
16:19:52 <lambdabot> [1,2,3,4]
16:20:00 <Techniks> yeah
16:20:20 <Techniks> but like 5,7,11,13 are all the prime numbers
16:20:25 <ski> (didn't notice it reused 'x' locally, there)
16:20:26 <ski> yes
16:20:46 <ski> you need to pass in an x that you want to check if it is prime
16:21:06 <Techniks> haha i just noticed something
16:21:06 <ski> then this will give you all the things you have to check is not factors
16:21:10 <ski> actually, it should be
16:21:14 <ski> @eval let x = 17 in takeWhile (\d -> d*d <= x) [2..]
16:21:15 <lambdabot> [2,3,4]
16:21:28 <ski> 1 is a factor, even in primes
16:21:32 <Techniks> yeah
16:22:03 <SamB> haskell has probably the nicest file I/O of any language I know...
16:22:18 <SamB> just readFile to read a file is so easy!
16:22:21 <Techniks> why do you want just 2,3,4
16:22:22 <Techniks> ?
16:22:26 <Techniks> i dont understand
16:22:28 <Techniks> i need the primes
16:22:30 <Techniks> :S
16:22:43 <astrolabe> :[
16:23:31 <astrolabe> 2,3,4 are the numbers that you try as factors of your potential prime.
16:24:02 <SamB> why aren't you doing the seive?
16:24:37 <ski> Techniks : currently you want to define isPrime, right ?
16:24:41 <Techniks> yeah
16:24:47 <Techniks> i see what you've done
16:24:55 <Techniks> now you need to devide it by every number in that list hehe
16:25:01 <Techniks> or mod it
16:25:05 <Techniks> to get 0
16:25:06 <ski> so, as astrolabe said, you should try those numbers as potential factors
16:25:07 <Techniks> else its prime
16:25:14 <ski> e.g. you could test them with
16:25:20 <ski> @type all
16:25:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:25:49 <ski> @eval all (\x -> x < 10) [1,4,2,8,5,7]
16:25:50 <lambdabot> True
16:25:54 <ski> @eval all (\x -> x < 10) [1,4,2,14,8,5,7]
16:25:55 <lambdabot> False
16:26:07 <ski> you should be able to do something similar here, i think
16:26:21 <ski> (you could also do it in another way, if you like that better)
16:27:56 <Techniks> confusing :S
16:28:28 <astrolabe> confusing is good.
16:28:49 <Techniks> its great, i love it
16:28:55 <ski> nice
16:30:27 <astrolabe> @eval (\x -> x<10) 5
16:30:28 <lambdabot> True
16:31:46 <astrolabe> @eval all [True, False, True]
16:31:47 <lambdabot> Couldn't match `a -> Bool' against `[a1]'
16:31:54 <astrolabe> oops
16:33:57 <ski> re moomlyn
16:36:27 <moomlyn> ski: hey
17:14:14 <Techniks> @eval [x**2, x <- [1..98], isprime(x)]
17:14:14 <lambdabot>  parse error on input `<-'
17:14:34 <Techniks> @eval [[x**2, x <- [1..98], isprime(x)]]
17:14:34 <lambdabot>  parse error on input `<-'
17:15:03 <Techniks> @eval isprime(3)
17:15:04 <lambdabot>  Not in scope: `isprime'
17:15:12 <yozora> you need the | in any case
17:15:32 <yozora> @eval [x**2 | x <- [1..3]]
17:15:33 <lambdabot> [1.0,4.0,9.0]
17:15:47 <yozora> @type (**)
17:15:49 <lambdabot> forall a. (Floating a) => a -> a -> a
17:15:50 <Techniks> is there already a isprime thing in haskhell hehe
17:19:20 <yozora> @type (^)
17:19:21 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
17:24:41 <yozora> @
17:24:42 <lambdabot> Maybe you meant: all-dicts arr babel botsnack code devils dice dict dict-
17:24:42 <lambdabot> help docs dummy dynamic-load dynamic-reload dynamic-unload easton echo
17:24:42 <lambdabot> elements elite eurohaskell eval fact fact-cons fact-delete fact-set fact-
17:24:42 <lambdabot> snoc fact-update foldoc fortune gazetteer ghc google help hitchcock
17:24:42 <lambdabot> hoogle hoogle+ index jargon join karma karma+ karma- kind learn leave
17:24:44 <lambdabot> [6 @more lines]
17:25:07 <yozora> @elite hello
17:25:07 <lambdabot> HE1|0
17:25:27 <yozora> @jargon
17:25:28 <trez> thats useful
17:26:00 <yozora> @fact
17:26:00 <lambdabot> I can not handle empty facts.
17:26:07 <yozora> @fact lambdabot
17:26:07 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female.
17:27:14 <yozora> @fact comonad
17:27:15 <lambdabot> I know nothing about comonad
17:27:22 <yozora> @help
17:27:23 <lambdabot>  @help <command> - ask for help for <command>
17:27:28 <yozora> @help fact
17:27:28 <lambdabot>  @fact <fact>, Retrieve a fact from the database
17:27:49 <yozora> @help jargon
17:27:50 <lambdabot> I perform dictionary lookups via the following 14 commands:
17:27:50 <lambdabot>  @all-dicts .. Query all databases on dict.org
17:27:50 <lambdabot>  @devils ..... The Devil's Dictionary
17:27:50 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
17:27:50 <lambdabot>  @elements ... Elements database
17:27:52 <lambdabot> [10 @more lines]
17:44:00 <ski_> yozora : comonads are the duals of monads ..
17:46:54 <yozora> yeah, so I hear, but I can't seem to understand the papers about them
17:47:37 <yozora> I can understand monads as container-type things, but comonads escape me altogether
17:49:29 <Lor> monads are not container-type things.
17:52:37 <yozora> i'm not saying that they are
18:36:52 <shocker> can i get some help
18:37:24 <dons> ask away
18:39:31 <araujo> Hello.
18:39:35 <araujo> dons, hey there
18:39:59 <araujo> dons, you told me once you know a publi darc repo right?, what is it?
18:41:24 <dons> @version
18:41:24 <lambdabot> lambdabot 3p168, GHC 6.5.20050806 (Linux i686)
18:41:24 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:41:29 <dons> why? are you testing darcs?
18:41:36 <araujo> mm..
18:41:45 * araujo probably asked the wrong question
18:41:51 <dons> there are lots of world-readable darcs repos.
18:42:25 <araujo> dons, i am actually looking for a site to host some code
18:42:25 <dons> oh, do you mean world-writable?
18:42:30 <araujo> Yeah
18:42:34 <dons> ah. ok. hmm. is it haskell code?
18:42:38 <araujo> Yes
18:43:04 <dons> you could host it on haskell.org possibly. you could ask shapr, also. and he'll host it on scannedinavian.com maybe
18:43:17 <dons> do you have a url for it?
18:43:22 <araujo> Ah ok, i will ask him then
18:43:28 <dons> oh, I guess you need shell access?
18:43:30 <araujo> No, nothing uploaded yet
18:43:58 <araujo> Well, yes, probably a small site would be fine too.. i was wondering if there existed something like SF but for haskell stuff using darcs
18:44:23 <dons> oh yeah, there's also SF. but I don't know anywhere except haskell.org that does darcs
18:44:40 <dons> I'm not sure who the contact at haskell.org is, but several members of #haskell host code there
18:44:43 <araujo> yeah, :-(
18:45:13 <araujo> yeah, most of the people i ask point me to haskell.org .....
18:46:04 <dons> what's the project?
18:47:03 <Lemmih> shapr does darcs.
18:47:07 <araujo> A shell written in haskell ... just for fun
18:47:28 <dons> ah, cool!
18:47:34 <araujo> Nothing big/serious really
18:47:35 <dons> hey Lemmih!
18:47:51 <dons> anyone know of an mp3 player written in haskell?
18:48:00 <araujo> Let me paste some line examples somewhere
18:48:03 <Lemmih> Tsk. Should read the logs before sending redundant information /-:
18:48:09 <Lemmih> Hiya dons.
18:48:42 <dons> Lemmih, i've got a student here at unsw now who's going to be working on a math/prover environment on top of hIDE
18:49:01 <dons> he has some rewriter tool, and wants and editor gui. so he'll be working on hIDE :)
18:49:08 <dons> s/and/an/
18:49:16 <Lemmih> Yeah, you told me (:
18:49:27 <dons> well, i've actually met him now, and he's real :)
18:49:32 <lisppaste2> araujo pasted "my processes  la haskell" at http://paste.lisp.org/display/13247
18:50:14 <araujo> I am also some handy stuff so you can redirect output/input to/from files....
18:50:19 <dons> niice araujo :)
18:50:19 <araujo> *adding*
18:50:29 <dons> have you seen HsShellScript?
18:50:45 <araujo> dons, yeah :-]
18:51:51 <araujo> Though i really haven't needed it
18:51:58 <araujo> *i think*
18:52:22 <araujo> most of the stuff have been very straightforward with the standard libs
18:54:26 <skew> What happened to Daan's Morrow interpreter?
18:55:04 <sh10151> ach, why rewrite editors?
18:55:25 * Lemmih pokes shocker.
18:56:34 <shocker> how can i do    func n x | x<=n = PutStrLn $ replicate n 'A' $ func n (x + 1)
18:58:14 <dons> you want to do that?
18:58:41 <dons> @type let f n x | x <= n = show $ replicate n 'A' $ f n (x + 1) in f
18:58:42 <lambdabot>   Expecting a function type, but found `[a]'
18:58:42 <lambdabot>   Expected type: a -> b
18:59:11 <shocker> yep
18:59:33 <shocker> i want to do somethign with a function then be able to call another one or itself
18:59:40 <sh10151> haskell wiki is written in python
18:59:47 <dons> @type replicate
18:59:48 <lambdabot> forall a. Int -> a -> [a]
18:59:51 <araujo> mm.. isn't replicate trying to get the result of func as argument too?
18:59:55 <dons> replicate only takes 2 args, not 3
19:00:34 <shocker> yea, what im trying to do is do the replicate and then  do another 'f' with different arguments
19:00:52 <dons> you want to write imperative code?
19:01:02 <araujo> sounds like so
19:01:23 <dons> and have a print statement with side effects? this isn't very haskellish
19:01:33 <dons> better would be to return a list of actions, and then sequence them
19:01:39 <shocker> ok
19:02:32 <araujo> shocker, do you program in O'Caml?
19:02:59 <dons> @eval let f n x | x <= n = replicate n 'A' in [ f 3 x | x <- [0..3] ]
19:02:59 <lambdabot> ["AAA","AAA","AAA","AAA"]
19:03:12 <dons> keep it pure :)
19:03:19 <skew> Daan's papers on MLF and extensible records are pretty impressive
19:03:32 <shocker> araujo no
19:03:34 <dons> if you really need the side effects, then you need to look at the do-notattoin in the IO monad
19:03:40 <araujo> shocker, ok, nvm
19:04:04 <dons> i.e.  ... x <= n = do print (replicate n 'A') ; f n (x + 1)
19:05:07 <dons> or the nicer (imo) way:
19:05:08 <shocker> yep thanks
19:05:11 <dons> @type let f n x | x <= n = putStrLn $ replicate n 'A' in sequence_ [ f 3 x | x <- [0..3] ]
19:05:12 <lambdabot> IO ()
19:05:28 <dons> nice than explictly printing each time around
19:25:32 <shocker> in a function declaration how do i say the input is a List of lists
19:26:15 <araujo> [[a]] ?
19:26:19 <shocker> yep
19:26:23 <shocker> thats what i thought
19:28:29 <SamB> @license
19:28:30 <lambdabot> Unknown command, try @listcommands.
19:28:35 <SamB> @version
19:28:35 <lambdabot> lambdabot 3p168, GHC 6.5.20050806 (Linux i686)
19:28:35 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:28:42 <dons> SamB?
19:28:55 <dons> maybe we should have an @license
19:28:56 <SamB> dons: I want to steal MiniHTTP.hs
19:29:01 <dons> it's gpl
19:29:05 <SamB> oh
19:29:10 <dons> -- <http://homepages.paradise.net.nz/warrickg/haskell/http/>
19:29:10 <dons> -- <http://www.dtek.chalmers.se/~d00bring/haskell-xml-rpc/http.html>
19:29:16 <dons> I think.
19:29:20 <dons> it's not my code
19:30:00 <dons> @where http http://www.haskell.org/http/
19:30:01 <lambdabot> I know nothing about http.
19:30:07 <dons> @where+ http http://www.haskell.org/http/
19:30:07 <lambdabot> http ~> http://www.haskell.org/http/
19:30:17 <dons> $ darcs get http://cvs.haskell.org/darcs/http/
19:30:33 <dons> ah, it's  BSD
19:30:49 <SamB> These modules are published under the BSD licence, with only a small alteration to account for having no ORGANIZATION
19:30:52 <dons> http://cvs.haskell.org/darcs/http/LICENSE
19:31:08 <SamB> hmm, I forgot quotation marks...
19:33:38 <SamB> have you seen conjurer?
19:33:42 <SamB> er, conjure?
19:34:02 <SamB> darcs get http://j.mongers.org/pub/haskell/darcs/conjure/
19:37:14 <dons> this is the bittorrent client?
19:37:29 <SamB> yeah
19:38:15 <dons> ... Copying patch 20 of 42...
19:38:17 <dons>   ;)
19:38:22 <SamB> the version there can't actually read torrent files, but I've sent in some changes that will get it to work...
19:39:54 <dons> ah, it's a jlouis project?
19:39:58 <SamB> yes
19:40:12 <SamB> does he do those a lot?
19:40:42 <dons> he's hacked on some of my code. but I don't know of any other haskell projects he's done.
20:06:44 <shocker> is there a shapes class in haskell?
20:07:39 <shocker> dw
20:08:25 <MenTaLguY> shapes class?
20:13:16 <Spark> [1;2B
20:13:23 <Spark> unix
20:13:28 <Spark> what can you do
20:20:11 <Julian> Hi folks!
20:20:17 <Julian> ;-)
20:26:15 <Lemmih> Hi Julian.
20:41:23 * SamB calls it quits, enough BT stuff for tonight
21:35:37 <skew> has anybody made a TH thing for opening a Parsec Token parser?
21:35:45 <araujo> let do { var <- func; } in func1 var .....
21:35:49 <araujo> is that possible?
21:36:10 <skew> not as you've written it
21:36:23 <araujo> What's wrong with it?
21:36:25 <skew> a do block isn't allowed to end with a binding
21:36:39 <skew> you can write do { var <- func; func1 var}
21:36:58 <skew> bindings can't escape a do block like that
21:37:05 <skew> but you can use them inside the do
21:37:32 <gzl> araujo: you could informally think of it this way. when you're doing var <- func, you're pulling something out of a box. you have to put it back by the end of the block, so you can't still be playing with it after the block is done.
21:38:30 <araujo> gzl, mm, nice explanation
21:38:31 <araujo> Thanks
21:39:29 <gzl> np
22:00:25 <skew> The TH widget was really simple - openToken def = [d| TokenParser identifier reserved ... = makeTokenParser $def |]
22:00:43 <gzl> what's that [| |] syntax?
22:00:49 <gzl> some TH thing?
22:00:53 <skew> template haskell - that's quasiquote
22:00:58 <skew> $ is splice
22:01:16 <skew> [d| is a quasiquotation of a sequence of definitions
22:01:39 <skew> Have you used a Parsec token parser?
22:04:11 <araujo> gzl, Probably i am thinking _too_ imperatively, but, what if i want to read a file and save that value in some way so i can use it without reading the file everytime i need the value?
22:05:40 <skew> araujo: read the value from the file and then pass it into a function that does stuff with it
22:06:02 <skew> do value <- imperativeStuff; moreImperative (pureFunction value)
22:06:21 <skew> not let value = imperativeStuff() in pureFunction value
22:08:50 <araujo> Thanks skew
22:15:21 <gzl> araujo: sorry, just saw this. try thinking of it "inside out." imperatively, you'd write functions that operate on the value and call the function to grab the value within those functions. here, you write a block in which you grab the value from the file and then you call functions that operate on the value right there. it's backwards, in a certain sense. does that help at all?
22:15:39 <gzl> well, imperatively, you might do that, you don't have to
22:21:13 <gzl> skew: yeah, I've used Parsec, but not recently
22:22:38 <bignose> I'm well versed in Python, familiar with Lisp.
22:22:43 <bignose> What's the deal with Haskell?
22:23:00 <skew> types that don't suck, laziness, monads
22:23:37 <bignose> skew: the first two I believe I already have, the last one I don't know the meaning
22:23:53 <skew> http://www.md.chalmers.se/~rjmh/Papers/whyfp.html
22:24:32 <gzl> type classes are good too
22:24:54 <skew> That's a good paper about how laziness and referential transparency can be useful
22:24:55 <fworp> but that probably falls under 'types that dont suck'
22:24:57 <gzl> I guess that falls under types that don't suck
22:24:59 <gzl> haha
22:25:06 <bignose> gzl: is that the same thing as "the class of an object is itself an object"?
22:25:19 <gzl> no
22:25:27 <skew> no, it's like "this function works on any object for which you have defined addition"
22:25:28 <bignose> gzl: then what is a "type class"?
22:25:33 <skew> it's kind of like multimethods, actually
22:25:44 <gzl> bignose: http://en.wikipedia.org/wiki/Overloading#Type_Classes
22:25:58 <skew> in that you declare instances separately from the type, and the behaviour can depend on the type of the arguments
22:26:19 <skew> except it's a typed language, so it behaviour can also depend on the result type too
22:26:35 <bignose> similar to functional programming in Lisp? how different?
22:26:57 <skew> and you can do generic things like a method for printing "any pair of objects we know how to print"
22:27:10 <skew> I mean type classes are somewhat similar to the multimethods in lisp
22:28:06 <gzl> bignose: http://www.haskell.org/aboutHaskell.html may help also
22:29:21 <fworp> they are similar to interfaces and mixins in oo.
22:29:41 <fworp> kinda sorta
22:29:43 <bignose> so reading the Overloading#Type_Classes section
22:30:00 <skew> with the big difference that most oo languages make you describe how a class impelements an interface when you define it (or forever hold your peace)
22:30:06 <bignose> in Haskell, "type classes" are groupings of types defined by what methods they have
22:30:26 <gzl> bignose: defined by some common functionality
22:30:30 <bignose> and any type can belong to any number of type classes, by implementing the associated methods
22:31:16 <gzl> well, the type itself does not implement the methods
22:31:32 <gzl> but you can more or less think of it that way
22:31:53 <bignose> ah, so the method implementation is not "part of" the type *or* the class?
22:32:11 <bignose> s/not/neither/ s/or/nor/
22:32:18 <gzl> it's in an instance declaration for the class
22:32:25 <skew> repeating, the important difference from most OO systems (and a similarity with lisp multimethods) is that you write down a separate declaration somewhere which gives an implementation for the typeclass methods for that particular type
22:32:34 <gzl> but it's not really important
22:32:44 <gzl> the point is that you're grouping together all the types for which certain operations make sense
22:32:58 <skew> if you invent some new typeclass you can make built in stuff like lists and Int instances
22:33:21 <bignose> right. so type classes define method interfaces; types define data types; and method implementations can exist to implement any type class for any type
22:33:24 <bignose> yes?
22:33:40 <skew> pretty much
22:33:44 <bignose> interesting
22:33:46 <gzl> bignose: http://www.haskell.org/tutorial/classes.html will help
22:34:01 <bignose> so what's a monad?
22:34:07 <fworp> good question
22:34:20 <skew> something we ripped off from mathematicians
22:35:05 <bignose> well, functional programming was pretty much also ripped off from mathematicians :-)
22:35:25 <skew> a monad is kind of like a language
22:36:35 <skew> but I don't explain this stuff very well without confusing people - I'd like to talk about referential transparency a bit
22:36:40 <skew> which leads back into monads
22:36:49 <bignose> a couple of links on monads lead me to think of tail recursion
22:37:06 <skew> kind of. CPS transform is getting closer
22:37:15 <gzl> monads are used for a lot of things, unfortunately, so all the descriptions of them end up being fairly general
22:38:01 <bignose> is it really "unfortunate"?
22:38:13 <gzl> well, it's unfortuante in the sense that they're quite hard to grasp
22:38:17 <gzl> at first, anyway
22:38:21 <gzl> so people get turned off
22:38:27 <skew> not really, the point is that they are general enough to describe lots of things, but just specific enough to write code in terms of them
22:38:57 <skew> which then is useful really generally. It's like category theory, which is the branch of math Moggi stole the idea from
22:39:02 <gzl> one thing they buy you is the ability to incorporate nasty things like side effects or state into a purely functional context
22:39:11 <gzl> yeah, and category theory turns people off too :)
22:39:17 <bignose> "computations that can be combined into other computations" is one approximation
22:39:25 <skew> pretty much
22:39:35 <bignose> how do they differ from simple (procedural language) functions?
22:39:38 <gzl> yeah, only that isn't a very satisfying description if you're trying to find out what the hell they are
22:39:56 <gzl> the best thing to do is to go through some monad tutorials to get a feel for them
22:40:02 <gzl> http://www.nomaware.com/monads/html/ is a good one
22:40:13 <bignose> that's where I'm at :-)
22:40:20 <skew> for any simple procedural language, there is a corresponding monad where code in the monad is pretty much equivalent
22:40:43 <skew> but there are also monads which correspond to stuff like languages with exceptions, or nondeterminism, or whatever you can think of
22:40:57 <gzl> here's a crazy example
22:41:20 <gzl> some guys made a "hardware monad" as part of their haskell OS
22:42:18 <bignose> well, theoretical topics seem to be a strength of Wikipedia, let's see if that helps me
22:42:42 <gzl> one should hope, since wikipedia is pretty bad at a lot of other stuff :)
22:43:18 <skew> this is a good tutorial on monads: http://www.nomaware.com/monads/html/
22:43:26 <gzl> haha
22:43:28 <bignose> "data types that encapsulate sequential computation, and state-activity or operations which may fail".
22:43:35 <bignose> how's that?
22:43:46 <skew> those are instances of monads
22:43:49 <gzl> bignose: this is what I'm saying, go through that nomaware tutorial and you'll see some code
22:44:01 <gzl> bignose: once you go through several examples it'll start becoming clearer
22:44:21 <bignose> gzl: I'm attempting -- perversely -- to understand Haskell's advantages from outside
22:44:34 <gzl> well, the easiest way to understand the advantages is to play with them
22:45:09 <fworp> i like to think of monads as descriptions of how to combine actions of a given type, like IO, or state transformers, or parsers
22:45:58 <bignose> this Wikipedia article is asking for verification from more knowledgeable folk:
22:46:02 <bignose> <URL:http://en.wikipedia.org/wiki/Monads_in_functional_programming>
22:46:04 <gzl> bignose: http://www.haskell.org/hawiki/MonadsAsContainers might be useful too
22:46:37 <skew> bignose: are you familiar with the denotational semantics of Scheme?
22:46:46 <bignose> skew: nope
22:46:55 <skew> have you looked at that part of the report anyway?
22:47:02 <bignose> skew: what report?
22:47:11 <skew> R5RS
22:47:36 <bignose> skew: I'm not too familiar with Scheme, other than that it's a smaller Lisp
22:48:01 <bignose> s/smaller/smaller-than-Common-Lisp/
22:48:36 <skew> Looking through the nomaware tutorial might explain some of what's up with monads
22:48:45 <bignose> skew: it has helped
22:48:47 <gzl> and MonadsAsContainers
22:49:03 <bignose> thanks everyone for attempting to quickly answer my questions :-)
22:49:31 <skew> this paper is one example of the crazy things that can be expressed as monads: http://lambda-the-ultimate.org/node/view/792
22:50:03 <gzl> if you want to see where monads came from, look up wikipedia on just 'monads' (not monads in FP) :)
22:50:25 <skew> The cool things about using monads is that you can change the definition of your monad without needing to change the code that isn't directly affected
22:51:31 <skew> like, if you are writing an interpreter for some language in terms of monads, and suddenly you decide you want to support continuations, you can change the monad to add some continuation functions, and then just write some new code for how to interpret continuation stuff
22:51:54 <skew> if you hadn't used monads you would have had to rewrite everything in terms of CPS transformed code, or whatever
22:52:21 <bignose> gzl: yep, the Monad article led me to the category theory and functional programming articles on monads
22:52:44 <gzl> there are also some papers by Philip Wadler
22:52:55 <gzl> dunno if they're referenced there
22:52:56 <skew> It's only really compelling when you are talking about simulating things the host language doesn't support, which is a whole lot (state, IO, etc) when you are talking about a pure language like Haskell, and not so much (continuations, state that travels back in time) against Lisp
22:53:28 <bignose> it would be great if you guys could help verify the Wikipedia "Monads in functional programming" article
22:53:50 <lambdawar> hello
22:53:56 <lambdawar> I have a question regarding linear continuations
22:54:12 <lambdawar> does it means they are used only 1 time, e.g. only on 1 distinct flow ?
22:54:17 <lambdawar> or one time at all in the whole program
22:54:28 <skew> I think it means you can only jump to them once
22:54:52 <lambdawar> you mean the execution flow will use the continuation only one time in the program
22:55:09 <skew> is only allowed to use it once, I think
22:55:33 <skew> I see the term "one-shot continuation" for that a lot, anyway
22:56:02 <lambdawar> hum
22:56:06 <skew> But I could see them being called linear, in the same way as linear type systems
22:56:11 <lambdawar> it means that you cant do recursive procedures anymore that easily
22:56:28 <lambdawar> in the sense of the linear logic yea
22:56:47 <lambdawar> how do you do a recursive call using only linear continuations ?
22:57:13 <lambdawar> probably I miss something
22:57:14 <skew> it works fine, I think
22:57:36 <lambdawar> the continuation will be used multiple times
22:57:43 <lambdawar> no ?
22:57:46 <skew> if you think in CPS terms, the continuation you get when you come in is the once for returning the final result
22:58:18 <lambdawar> which means that it is used multiple time, isnt it ?
22:58:19 <skew> when you make the recursive call, the continuation for that call will have the work of the parent function to finish stuff up, and then go the final continuation
22:58:59 <lambdawar> hum
22:59:07 <lambdawar> I dont understand how the cont can only be used 1 time
22:59:18 <skew> if it's tail recursive the continuation just keeps getting passed deeper until the recursion is done and the continuation is used
22:59:24 <skew> so it's passed around lots but only called once
22:59:38 <skew> just like a linear value can be passed around lots as long as it isn't duplicated, but only used once
23:00:06 <lambdawar> okay, then you refer to the continuation that will be taken after the recursion is over
23:00:14 <lambdawar> not the continuation that allow the recursion itself
23:00:30 <skew> which continuation is that?
23:00:38 <skew> the recursion is just functions calling other functions
23:00:44 <skew> and maybe doing some work after they return
23:01:02 <skew> recursion doesn't involve returning from the original call lots of times
23:01:50 <lambdawar> I understand
23:04:57 <lambdawar> what if you modelize a system of mutually recursive functions using continuations (e.g. you want to recurse using the continuation parameter)
23:05:04 <lambdawar> Im not sure its good functional programming practive
23:05:06 <lambdawar> practice
23:05:18 <lambdawar> but I imagine it doable / useful some way
23:05:32 <skew> like CPS, where you tail call to the continuation?
23:05:36 <lambdawar> yea
23:06:10 <lambdawar> then, can you make it with linear conts ?
23:06:19 <skew> that's not a problem, you're allowed to take a linear value and embed it into a larger linear value
23:06:25 <skew> which counts as consuming the original
23:07:00 <skew> so you can make a new continuation that will do your cleanup work and then call your return continuation, and pass that down as the return continuation for the recursive call
23:13:49 <lambdawar> so you will insert an intermediate continuation each time, but then that mean you need as much continuations as tail-recursive calls
23:13:58 <lambdawar> even, twice as many times
23:14:26 <lambdawar> for the intermediate, and return continuation, at each recursion
23:14:28 <skew> that's what happens when you take a non tail-recursive functions and make them tail recursive by explicit continuation passing
23:14:47 <skew> instead of n calls, you get a chain of n continuations
23:15:12 <lambdawar> ok
23:15:16 <lambdawar> thanks for your explanations skew
23:15:56 <lambdawar> also, I have another question while Im there, how is called a inverse continuation in good words ?
23:16:13 <lambdawar> like a continuation, but for backward analysis
23:16:25 <lambdawar> does it have a name different than inverse continuation ?
23:20:36 <skew> inverse?
23:21:20 <skew> isn't that just normal evaluation?
23:21:39 <skew> or, the expresion that evaluated down to give a value
23:22:31 <lambdawar> yea, but reasoning on past rather than future
23:23:20 <lambdawar> like, trying to find a counter example when you find a flaw (once the flaw is found, usually using forward analysis)
23:24:43 <lambdawar> the counter example generation is more easily done with a sort of inverse continuation mechanism that abstract the different kind of control flow and its implications on the data environment
23:25:57 <lambdawar> the evaluation you mention is a forward analysis
23:28:48 <lambdawar> do you know what I mean ?
23:40:46 <skew> Haskell is such a nice language for writing interpreters - 61 lines for a complete interpreter for the first language in TaPL
23:41:35 <skew> well, the printing is a derived Show instances, but it does parsing, evalution, and printing
23:49:06 <aleator__> @seen igloo
23:49:07 <lambdabot> igloo is in #haskell. Last spoke 17 hours, 53 minutes and 20 seconds ago.
23:49:49 <aleator__> igloo: ping?
