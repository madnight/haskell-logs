01:34:22 <joelk> @seen lambdabot
01:34:25 <joelk> :)
01:35:51 <phys_rules> yo
01:36:37 <ValarQ> g'day
02:47:40 <joelr1> howdy y'all
02:47:46 <phys_rules> hey
02:48:11 <joelr1> anybody acquainted with shared transactional memory?
02:57:16 <thorsten_> hi, which compiler supports OOHakell ?
02:57:54 <thorsten_> or is it haskell++ ??
02:58:50 <phys_rules> what do you mean OOHaskell ? Haskell is OO
03:00:17 <ValarQ> http://homepages.cwi.nl/~ralf/OOHaskell/
03:00:45 <phys_rules> ah, ok =)
03:01:46 <thorsten_> yup thanks
03:02:14 <sieni> phys_rules: haskell is certainly no OO, which is good, unless you make it so
03:02:23 <sieni> s/no/not/
03:03:25 <sieni> I would say that OO requires that objects have a mutable state and that's not possible in Haskell unless you use IORef or something
03:03:35 <phys_rules> sieni: I have to disagree with you there, you have modules, types, inheritence, overloading, etc..
03:03:56 <xerox> Hi buddies!
03:04:00 <phys_rules> hey xerox
03:04:20 <phys_rules> sieni: not necessarily
03:04:48 <sieni> phys_rules: Well, but that's different. They are in the context of functional, not object-oriented, programming.
03:05:07 <phys_rules> sieni: that's why it's not "oriented" but rather "supporting" :)
03:05:33 <phys_rules> imagine all the mess without modules :)
03:06:43 <sieni> modules and typed don't have anything to do with objects or object-oriented programming (unless it is for the fact that some object-oriented languages support them as well)
03:07:39 <phys_rules> in some sense it's true, but then again you have polymorphism, inheritance, two main feats of OO
03:08:11 <phys_rules> but most certainly modules resemble a good part of a class
03:10:23 <fworp> though they are debatably inseperable from oo. lots of oo language only support inheritance and oo flavored polymorphism as after thoughts, and side-effects of the weakness of the type system. even classes seem like they arent really nessesary abstractions in oo
03:10:24 <sieni> Polymorphism hasn't got anything to do with object-orientedness
03:10:53 <phys_rules> sieni: well, then we're in different boats with different definitions of OO ;)
03:11:41 <sieni> phys_rules: as I said, I think that object orientedness requires that you have objects and they have mutable state
03:11:46 <ValarQ> OO is about objects passing messages to eachother (thats my view anyway)
03:12:01 <sieni> phys_rules: which is possible in Haskell, but not very convenient
03:12:04 <ValarQ> polymorphism is a feature of the language
03:13:17 <phys_rules> I think OO is simply the fact that the system is constructed of objects in sort of an aggregation of smaller systems
03:13:47 <ValarQ> phys_rules: isn't that simply modularity?
03:13:56 <phys_rules> to some extent, yes
03:14:18 <thorsten_> are there some examples about how to use OpenGL with GHC ??
03:15:14 <thorsten_> on the OOHaskell-page there is a paper that clarifies, why haskell needs OO extensions
03:15:58 <ValarQ> thorsten_: there is a few HGL and GLUT demos in the hugs package
03:16:09 <ValarQ> thorsten_: should work with ghc
03:17:47 <xerox> thorsten_: do you know those reasons?
03:18:02 <thorsten_> yep, but ghc has its own OpenGL bindings. Do you mean ghc and hopengl are source-code compatible ?
03:18:21 <thorsten_> xerox, not exactly
03:18:38 <xerox> thorsten_: I could point you to the Gtk2Hs latest new entry: OpenGL (widget?) support!
03:19:08 <xerox> thorsten_: there are at least two posts on <http://haskell.org/gtk2hs/>, and the demos in the sources.
03:19:34 <thorsten_> k thx
03:19:45 <phys_rules> thorsten_: http://www.haskell.org/hawiki/Frag
03:19:52 <phys_rules> a good big example of using HOpenGL :)
03:21:16 <thorsten_> yo thx
03:22:43 <thorsten_> phys_rules, the site has also a link to a paper about functional 3d programming
03:24:17 <phys_rules> yeah, I saw it
03:25:20 <fworp> im not sure haskell needs oo extensions, though it would be nice to have some abstractions that made oo-ish library bindings and modeling a little easier. extensible records, for instance.
03:25:43 <fworp> HList is pretty neat too
03:31:34 <chris2> is there an idiot's guide to the Hindley-Milner algorithm?
03:31:49 <Akshaal> :)
03:32:36 <eivuokko> I liked Typing Haskell in Haskell.
03:35:23 <astrolabe> This might be helpful http://en.wikipedia.org/wiki/Type_inference
03:36:57 <chris2> thx all
03:43:29 <chris2> looks easier than i thought...
03:44:11 <joelr1> how do you pattern-match on records?
03:45:58 <joelr1> hmm... i just figured it out. thanks for listening!
03:59:05 <araujo> Hello all.
04:03:16 * kolmodin is having a cup of hot tea without honey
04:03:21 <kolmodin> hi araujo :)
04:05:00 <Lor> Is the honeylessness extraordinary?
04:06:42 <kolmodin> I prefer with honey, but apperently you should be careful with that since honey gets poisonous if it's warmer than ~40 C
04:07:03 <kolmodin> we got a lecure from gour yesterday :)
04:07:04 <Lor> Er?
04:07:31 <kolmodin> er? indeed!
04:07:32 <Saulzar> Would you want to drink honey > 40 C anyway? 
04:07:41 <tic> in tea, it is warmer.
04:07:45 <Lor> Would you want to drink tea < 40 C anyway?
04:07:45 <kolmodin> :D
04:07:55 <tic> kolmodin, ipop!
04:07:59 <kolmodin> tic: argh!
04:08:06 <kolmodin> tic: you're right...
04:08:19 <kolmodin> back to my studies..
04:08:52 <araujo> kolmodin, haha, hey there!
04:09:14 <Saulzar> Wow, Frag looks impressive 
04:11:38 <maniacH> how can ei get 4th element from list ?
04:11:48 <kolmodin> xs !! 3
04:12:00 <maniacH> thnx
04:12:09 <kolmodin> np
04:12:48 <kolmodin> araujo: hi. got to finish this stupid program I'm supposed to write
04:21:48 <maniacH> how to check if number is even number ?
04:22:20 <Lor> @type even
04:22:57 <Lor> Where's lambdabot?
04:25:51 <araujo> kolmodin, what is it?
04:26:11 <araujo> lambdabot not here
04:26:59 <astrolabe> come back boegel-bot, all is forgiven
04:32:02 <xerox> even :: (Integral a) => a -> Bool
04:33:47 <kolmodin> araujo: calculating multiple regression using gauss, prediction interval and ranges... wouldn't be so bad if it wheren't in java, and that I had to document _everything_ I do
04:34:03 <araujo> kolmodin, sorry to hear that
04:34:50 <kolmodin> heh :)
04:34:54 <araujo> kolmodin, haskell is the perfect tool for that work :-P
04:35:01 <kolmodin> but it's the last programming assignment in that course
04:35:48 <kolmodin> next (and the last) assignment is to write a report of how things went, how good my estimations of development time and LOC and tons of other stuff where
04:37:14 <shapr> I'm building ghc-cvs and the OpenAL code fails to build. Since I want ghc-smp, how do I disable build the OpenAL code?
04:39:03 <twb> Hi.  I'm learning Haskell.
04:39:14 <shapr> g'day twb, welcome 
04:39:29 <superibor> welcome twb, I'm learning too
04:39:31 <twb> Is there a way to pattern match before doing guards?
04:39:32 * xerox hugs twb
04:39:33 <shapr> Do you have any questions?
04:39:35 <maniacH> how can i write down  Not even 2 
04:39:35 <maniacH> even = true
04:39:35 <maniacH> i want not even 2 = true  :)
04:39:44 <twb> Like, in SML, "fun member _ nil = false | member e (h::t) = if e = h then true else member e t;"
04:40:26 <shapr> twb: I think you can do pretty much that.
04:40:38 * shapr writes an example
04:40:43 <superibor> twb: that's the way it works always in Haskell
04:40:52 <xerox> let f (x:xs) | xs == [] = x | otherwise f xs in f [1..3]
04:41:11 <xerox> Oh, I see what you mean.
04:41:16 <twb> xerox: yeah
04:41:38 <twb> Ew, you spell it ==?
04:41:59 <shapr> Well, give the syntax a chance, you might like it.
04:42:24 <xerox> member _ [] = False
04:42:24 <xerox> member e (x:xs) | e == x = True
04:42:24 <xerox>                 | otherwise = member e xs
04:42:32 <shapr> xerox: beat me to it...
04:42:42 <twb> xerox: I take it "nil" isn't bound?
04:43:10 <xerox> [1..3] == [1,2,3] == 1:[2,3] == 1:2:[3] == 1:2:3:[]
04:44:03 <twb> The thing I find hardest atm is mixed infix and prefix notation.
04:44:34 <xerox> member e = foldl (\r x -> r || x == e) False
04:44:49 <twb> xerox: heh
04:44:50 <xerox> @pl \r x -> r || x == e
04:44:59 <xerox> twb: ^_^
04:45:12 <shapr> In general, functions are prefix and operators are infix. Operators use nonalphanumeric characters.
04:45:20 <shapr> You can make functions infix with `name`
04:45:31 <twb> shapr: it still looks ugly tho.
04:45:32 <xerox> ...and prefix with (name)
04:45:50 <twb> Did I mention my favourite languages are Lisp and Forth? ;-)
04:45:52 <xerox> If only there was a lambdabot, nobody can run one instance?
04:45:55 <shapr> twb: Give it a few weeks, it might just be unfamiliar.
04:46:55 <phys_rules> the more powerful is the language the more possibilities it gives you to write unmanagable code =)
04:47:12 <phys_rules> but you always have a choice ;)
04:47:34 <twb> phys_rules: so by inference brainfuck is highly readable?
04:47:46 * xerox stabs twb
04:47:55 <fworp> highly powerful atleast
04:47:57 <shapr> I think that you got the cause and effect backwards there :-)
04:48:32 <shapr> What do they call it in statistics, dependent variable versus independent variable?
04:49:12 <twb> I don't suppose it's possible to modify eval() to behave more like forth/joy?
04:49:47 <shapr> As in, the eval() from hs-plugins?
04:50:07 <twb> I mean the function that reads programs and evaluates them.
04:50:45 <superibor> Too much Lisp there, you cannot do that directly in Haskell
04:50:51 <twb> superibor: bleh
04:50:52 <shapr> You can use braces and semicolons instead of whitespace.
04:51:00 <maniacH> anyone know some place where i can copy code ?
04:51:04 <shapr> @paste
04:51:07 <shapr> hmm
04:51:07 <maniacH> past ei mean
04:51:08 <maniacH> :P
04:51:13 <shapr> lisppaste2: url
04:51:13 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
04:51:20 <fworp> yeah, lambdabot is mia
04:51:43 <lisppaste2> maniacH pasted "splitting list " at http://paste.lisp.org/display/14047
04:52:01 <maniacH> whats wrong there :S
04:52:42 <twb> Why does hugs complain when I try something like "id" at the REPL?
04:52:57 <shapr> How did you try it?
04:52:58 <twb> In SML, it prints the function's type.
04:53:17 <shapr> You can get the type of a function with :type name or just :t name
04:53:20 <xerox> twb: :m + Text.Show.Functions
04:53:21 <xerox> :-)
04:53:36 <twb> shapr: is that portable?
04:53:41 <shapr> Portable to what?
04:53:47 <xerox> (Tought it will not print the types)
04:53:49 <twb> Across Haskell implementations.
04:53:50 <maniacH> okei, in my code there is missing second split2 but what else is wrong :S
04:54:01 <xerox> :t is a GHCi command
04:54:06 <xerox> See :help
04:54:11 <twb> Ick.
04:54:28 <twb> I get pissed off about portability in Scheme, too.
04:54:28 <shapr> twb: It'll work in hugs and ghci, it won't work in yhc, uhc, hbc, nhc98, or some others.
04:54:42 <Philippa> and it won't work with a compiler for obvious reasons
04:54:43 <shapr> Why are you learning Haskell?
04:54:48 <xerox> Some of them aren't interpreters too.
04:54:51 <twb> shapr: boredom
04:55:00 <shapr> twb: Ah I see.
04:55:23 <astrolabe> hugs know ':t'
04:55:24 <twb> So I can be *officially* smug about Lisp's superiority. ;-)
04:55:25 <malcolm> you can use :type exp in any compiler, provided you use the 'hmake interactive' REPLY
04:55:30 <shapr> In that case, instead of going 'ick' a lot, why don't you try to see the really cool parts of Haskell?
04:55:38 <malcolm> REPL*
04:55:55 <twb> shapr: I reserve the right to say "ick" regularly :-)
04:56:11 <astrolabe> twb: good luck!
04:56:25 <Philippa> twb: don't worry, I feel the same about lisp as you do about haskell ;-)
04:56:57 <twb> Philippa: I certainly miss Lisp's structured editing... :-(
04:57:18 <shapr> I prefer to keep an open mind and approach every new thing looking for its good points and advantages.
04:57:32 <astrolabe> Are you getting parenthesis withdrawel yet?
04:57:41 <twb> astrolabe: oh, yeah.
04:57:41 <shapr> Plus, if you start sounding like rahul or Smerdyakov, you won't last long here.
04:57:47 <malcolm> people sometimes forget that the first ever haskell interpreter was hbc's hbi
04:58:12 * xerox didn't know, actually.
04:58:14 <xerox> What is it?
04:58:16 * shapr neither
04:58:22 <Philippa> twb: I'd appreciate a bit more help from the text editor, yeah. The layout rule's something you get used to quickly though, if it helps. If you want a formal spec for it, read the Haskell 98 report - I've not seen a better description anywhere else
04:58:25 <astrolabe> twb: If you have any questions, here is an excellent place to ask.
04:58:40 <maniacH> whoooo i got it work.. i'm genius :D:D
04:58:49 <Heffalump> shapr: I don't think threatening people is a very good idea
04:58:51 <shapr> Was hbc Lennart Augustsson's compiler?
04:58:51 <maniacH> i love haskell :D
04:58:54 <superibor> maniacH can you paste the working code ?
04:59:01 <shapr> Heffalump: That wasn't a threat.
04:59:08 <Heffalump> it sounded like one
04:59:14 <twb> Heffalump: it comes with the territory; I'm used to it.
04:59:23 <malcolm> hbc = haskell B compiler, by Lennart, yes
04:59:24 <reductor> I was a lisp fanatic just before i started learning haskell.
04:59:26 <twb> You guys *can't* be more defensive than #python.
04:59:37 <malcolm> Named for Haskell B Curry
04:59:40 <Heffalump> :-)
04:59:52 <kolmodin> shapr: yes, his haskell compiler :)
05:00:25 <Philippa> twb: depends. But I suspect willingness to dislocate kneecaps in a fight isn't what you have in mind?
05:00:31 <malcolm> I still use hbc every night.
05:00:33 <shapr> twb: Sorry, no threat intended. Not enough sleep, so my wording must have been off.
05:00:47 <twb> What's the English translation of "(\r x -> r || x == e)"?
05:01:09 <twb> \ is obviously lambda
05:01:15 <xerox> (lambda (r x) (or r (eq? x e)))
05:01:27 <fworp> thats not english.
05:01:44 <twb> Good enough, though
05:02:06 <xerox> I thought so.
05:02:17 <twb> It was the use of || for logical or that confused me.
05:02:27 <xerox> twb: ...aaaand, the parens are optional ;-)
05:02:43 <twb> xerox: not in the surrounding foldl statement.
05:02:56 <xerox> twb: point!
05:05:50 <twb> Don't you find it annoying, being unable to type definitions at the REPL?
05:06:07 <Philippa> nope
05:06:36 <Philippa> tbh, I find it helpful that I refresh everything regularly, stops me worrying about a pile of ways I could screw up
05:06:54 <twb> tbh?
05:06:55 <Philippa> I appreciate that a better REPL could eg offer me a complete dump of current definitions...
05:07:05 <astrolabe> twb: If you use ghci, you can type in let statements
05:07:06 <twb> You mean an image?
05:07:51 <Philippa> depends on whether the image is something I can run through a text editor, scan etc etc etc
05:07:59 <reductor> actually I find it annoying and now i'm trying to write an extended console for ghc. something like the one in DrScheme
05:08:01 <Philippa> though yeah, what astrolabe said
05:08:33 <twb> What's the equivalent of SML's explode/implode?
05:08:44 <twb> i.e. String -> [Char]
05:08:51 <flux__> ;)
05:08:56 <fworp> String is [Char]
05:09:09 * twb tries whitespace c = member c "\t\n\r"
05:09:41 <twb> What about car/cdr / first/rest / hd/tl?
05:09:54 <fworp> 'head' and 'tail'
05:09:58 <Philippa> mostly we pattern-match, but head and tail for the last two
05:10:21 <Philippa> (car/cdr has several translations depending on how you intend the cell to be used)
05:10:24 <twb> Yeah, pattern matching should be in Lisp's core.
05:10:37 <xerox> You can type definition in the repl.
05:10:43 <astrolabe> where is that bot?
05:11:14 <Philippa> I'm not sure that'd be of as much value in a dynamically typed language
05:11:23 <twb> Philippa: it is, trust me.
05:11:47 <Philippa> compared to merely being expected to be in the libraries provided by every implementation?
05:12:01 <twb> Philippa: same thing
05:12:15 <Philippa> OK, fair enough. I think we have different values of 'core' then?
05:12:20 <Philippa> 'lo Per, LTNS
05:12:25 <psykotic> hi
05:12:34 <twb> Support for pattern matching in Common Lisp is mostly proof-of-concept level.
05:12:39 <twb> It looks ugly.
05:12:48 <Philippa> yeah, I've seen some examples and that does stink
05:12:48 <astrolabe> hello psykotic
05:13:30 <lisppaste2> twb pasted "pattern matching in CL" at http://paste.lisp.org/display/14050
05:14:17 <lisppaste2> maniacH pasted "splitting working for superibor" at http://paste.lisp.org/display/14051
05:14:45 <Philippa> anyway, I gotta go shower soon, got people heading 'round
05:14:49 <maniacH> superibor bitte :)
05:14:53 <superibor> maniacH got it
05:15:08 <Philippa> psyk: you just lurking, or are you after any info we can offer?
05:15:14 <psykotic> just lurking
05:15:50 <Philippa> 'k. I won't worry about missing an interesting question while I'm off showering, then
05:16:02 <twb> OK, now I gotta grok the parsec stuff.
05:16:10 <robajs> hello
05:16:14 <basti_> hi robajs 
05:16:26 <Philippa> twb: parsec's fairly easy if you're familiar with EBNF
05:16:31 <twb> How do I require it in ghci?
05:16:33 <astrolabe> twb: have you done monads already?
05:16:39 <twb> astrolabe: not properly.
05:16:50 <Philippa> :m +Text.ParserCombinators.Parsec or something similar, IIRC
05:17:03 <twb> astrolabe: at the moment I basically picture them as the invisible environment variable.
05:17:09 <Heffalump> ghci's REPL does allow definitions, btw, doesn't it?
05:17:10 <Philippa> beware you'll need to use one of the parse functions to run the parser
05:17:23 <Philippa> Heffalump: function definitions only
05:17:25 <twb> Heffalump: but you have to mangle the code first.
05:17:31 <Heffalump> oh, not types etc.
05:17:34 * Philippa leaves
05:17:39 <twb> Bye
05:18:22 <fworp> twb, what about type classes?
05:18:31 <twb> fworp: what about them?
05:19:08 <fworp> have you gotten around to learning how to use them?
05:19:16 <twb> fworp: nope.
05:19:25 <twb> SML only has the (eq) type class.
05:20:56 <Heffalump> and you can't make your own definition of it
05:21:17 <Heffalump> that was one of the most annoying things about it
05:21:19 <astrolabe> twb: you might find http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html useful
05:23:45 <shapr> Has anyone built hs-plugins recently? I get "Probable cause: `(postConf defaultUserHooks)' is applied to too many arguments in the call" Is there a known fix to this?
05:25:08 <araujo> shapr, i have
05:25:20 <reductor> i cannot build it in ms windows right now
05:26:02 <shapr> reductor: Do you have the same error?
05:26:10 <reductor> not. this is because couldn't build haskell-src-extras and happy
05:26:17 <shapr> ah, ok
05:26:21 <araujo> Which version?
05:26:34 <shapr> I'm using the latest from the darcs repo.
05:26:50 <shapr> TuringTest: Hi, learning Haskell?
05:27:46 <shapr> TuringTest: @hello
05:28:51 <reductor> are there any binary packages of hs-plugins for windows?
05:32:15 <shapr> Should make -j3 work with fptools?
05:32:47 <twb> Is there something to put in the .hs file to require other libraries?
05:32:59 <shapr> @wiki HaskellDemo
05:33:01 * twb opens another box of grammar.
05:33:07 <araujo> lambdabot is off
05:33:20 <shapr> twb: http://www.haskell.org/hawiki/HaskellDemo this may help.
05:33:29 <robajs> is haskell suitable for GUI program for processing and analysis of tons of logs? (on resonable desktop hw)
05:33:44 <shapr> Although I just realized that doesn't have an import statement... hmm.
05:34:25 <shapr> robajs: Yes, if you're careful about laziness it can use less memory than a comparable strict solution.
05:35:03 <twb> shapr: of course, you can implement normal-order datatypes in an applicative-order language :-)
05:35:09 <maniacH> how can i easyli get list that contains a numbers a element => [1] , [2,2],  [3,3,3] etc
05:35:18 <twb> specbot: you in here?
05:35:24 <Heffalump> well, you could always write a strict program that would use the same memory, it's just easier to structure the lazy program
05:36:12 <Heffalump> robajs: it'll do a reasonable job, but you'll probably pay a small constant factor time and memory usage for laziness in the first place, though
05:36:15 <ski_> (twb : at least if you have mutability)
05:36:15 <twb> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html
05:36:44 <shapr> reductor: I just updated my cabal to the latest darcs version, and now hs-plugins builds. Seems to have fixed the posthook problem.
05:36:45 <malcolm> maniacH: list n = replicate n n
05:37:39 <shapr> Whee, make -j3 does work with fptools.
05:37:41 <maniacH> nice, thanks malcolm :)
05:38:22 <twb> functions must start with [a-z], right?
05:38:39 <malcolm> twb: or underscore
05:39:03 * twb tries "u f = f f"
05:39:12 <ski_> infinite type
05:39:16 <twb> I didn't think that would work.
05:39:28 <twb> Stupid type unifier.
05:39:47 <ski_> (you can make it work if you make a new type)
05:39:52 <twb> Yeah.
05:40:02 <twb> But it'd be nice if you could just type combinators like that.
05:40:16 <ski_> newtype U a = MkU {unU :: U a -> a}
05:40:36 <ski_> u f = f (MkU f)
05:40:53 <ski_> (you can define Omega and Y with that)
05:41:05 <twb> Indeedy.
05:41:30 <ski_> (also, MkU and unU is operationally id, i.e. they're O(0) ops)
05:42:01 <twb> ski_: are you saying that the compiler optimizes them away entirely?
05:42:28 <ski_> no, no optimisation
05:42:36 <malcolm> twb: in most cases, yes
05:42:45 <ski_> newtype makes an isomorphicv type
05:43:06 <malcolm> twb: a simple application of MkU or unU would disappear in the generated code
05:43:11 <twb> Haskell doesn't have hierarchical types, right?  Just type classes?
05:43:12 <ski_> and, since haskell is lazy, MkU can't be an ordinary lazy constructor
05:43:19 <Philippa_> twb: right
05:43:32 <Philippa_> the hierarchy wouldn't necessarily go the way you'd expect, either
05:43:42 <Philippa_> (I hacked up a typechecker for something related that did have them)
05:43:50 <twb> And I guess you can't do a numeric tower the way Scheme does?
05:44:06 * ski_ ponders whether implementations of haskell are allowed to make newtype constructors not O(0)
05:44:15 <Philippa_> not quite the same, you need casts between types
05:44:40 <malcolm> ski_: there are occasions when it is difficult to optimise the newtype constructor away
05:44:42 * ski_ assumes one could have a big type, Number, which could be of various internal forms
05:44:42 <Philippa_> but you can get the tower of operations because typeclasses are allowed superclasses
05:44:49 <twb> Oh, that reminds me: do Haskell have tail-call optimization?
05:44:57 <ski_> malcolm : hm, ok .. can you give an example ?
05:45:01 <Philippa_> not mandated by the Report, no
05:45:09 <twb> Bleh
05:45:19 <malcolm> ski_: map MkU 
05:45:31 <twb> If you listen to GJS, that means you need separate iteration constructs.
05:45:40 <Heffalump> I don't know of any implementations that don't optimise simple tail-calls, though.
05:45:41 <malcolm> ski_: equivalent to map id, and so equivalent to just id
05:45:52 <Philippa_> it'd be hard to mandate in the report because implementation models differ wildly
05:45:57 <twb> ...unless normal-order automatically gives you tail-call optimization, I'm too stupid to work it out.
05:45:57 <ski_> tail-calls are not always useful, without some forcing/strictness (witness the standard accumulator factorial, which is not efficient)
05:45:59 <Philippa_> that is, it'd be hard to /specify/ adequately
05:46:05 <Philippa_> Scheme has problems with that as it is
05:46:16 <ski_> malcolm : that's another thing
05:46:28 <Philippa_> it doesn't automatically, but it can pretty much give you the equivalent once the GC gets called
05:46:33 <twb> ski_: so mandate memoization also :-)
05:46:57 <Philippa_> there're good reasons not to do that sometimes
05:47:05 <ski_> malcolm : that is what we would want to optimise away .. but it's not part of how newtype works .. it's part of how map works
05:47:11 <Philippa_> when a haskell program develops a space leak, it's bad
05:48:11 <ski_> twb : just of expressions, or also of functions ?
05:48:21 <malcolm> ski_: right.  In the FFI code of most implementations, there is a definition pseudomap _ = unsafeCoerce for just this reason
05:48:41 <Philippa_> twb: once you've evaluated a given call to a tail-recursive function, you have a thunk for the next value. The memory the function used up on that particular call is now dead. Not as pretty as if it compiled down to a loop, but the GC'll get it
05:49:29 <jlouis> ... eventually ;)
05:49:35 <twb> Philippa_: the GC does work, too...
05:49:56 <ski_> malcolm : mm .. i'd like some way of specifying this with perhaps a rewrite rule .. i.e. at least for newtype constructors and selectors
05:50:02 <twb> Does the Report actually require GC?  I know CL doesn't.
05:50:06 <Philippa_> yeah. OTOH, most implementations'll do work proportional to the live set
05:50:09 <Philippa_> no, it doesn't
05:50:20 <malcolm> ski_: see ghc's RULES pragma
05:50:38 <r2do2> hello all 
05:50:50 <Philippa_> OTOH, I don't think anybody'd really use an implementation that didn't have GC or some other means of deallocating memory (I understand region inference in the presence of laziness is a bit of a bugger, but hey)
05:50:50 <ski_> malcolm : yes, i know .. but is there a way to do this in general for all newtype constructors ?
05:51:22 <ski_> tail-calls is typically used to lower space complexity
05:51:24 <malcolm> ski_: where does it stop though?  Just map, or are there other functions to optimise away too?
05:51:36 <twb> Philippa_: what about a bootloader?
05:51:37 <ski_> (like, not growing stack linearly, when recursing)
05:51:45 <twb> Philippa_: a la OF or movitz.
05:52:00 <ski_> laziness can also sometimes have this effect of reducing space complexity
05:52:30 <jlouis> I must hereby announce that Dmitry Astapov is an extremely cool haskell hacker. 
05:52:39 <jlouis> He provides cool Conjure patches
05:52:44 <ski_> like, looping through lazy lists, and not keeping around a cons cell once you've looked at it
05:52:51 <r2do2> can postgresql databases be used effectively with haskell program which is cross platform ( windows and linux ) ?
05:53:04 <Philippa_> twb: sure. In practice we're not going to see a lot of that - so it pretty much meets the value of "nobody" I had in mind ;-)
05:53:26 <shapr> jlouis: w00!
05:53:34 <Philippa_> ski: yup, flippi developed a neat example of that when I was plugging some nasty concatenation behaviour
05:53:38 <twb> Philippa_: really?  I thought you lot had two or three on-the-metal haskell OSes.
05:53:46 <ski_> malcolm : .. well, we know that  'map id = id' is true .. so, this in some sense warrants having 'map SomeNewTypeConstructor' be O(0)
05:53:48 <jlouis> 2 secs, I'll add the latest *groovy* stuff
05:53:48 <Philippa_> twb: we do, but they're using the GHC RTS
05:53:59 <Philippa_> so they're GCed anyway
05:54:17 <shapr> r2do2: I know of at least two Haskell bindings to Postgresql, but I've never tried them with windows, only with Linux.
05:54:34 <r2do2> shapr: are they any good on linux ? 
05:54:53 <twb> Windows?  Pah, nobody uses that anymore.
05:55:03 <malcolm> ski_: the trouble is, map may only receive its function argument dynamically at runtime, so you can only optimise away the statically known cases, not all possible cases.
05:55:18 <Philippa_> twb: there're windows users in here. I'm one of them (and I have my reasons)
05:55:28 <ski_> malcolm : hm .. assuming 'newtype B = Con {des :: A}', then we know 'Con . des = id' and also 'des . Con = id' .. hm
05:55:30 <malcolm> ski_: let f g = map g xs in f MkU
05:55:39 <r2do2> windows linux osx all i want is my paycheque ;) 
05:56:01 <shapr> r2do2: They're pretty good. Not bad, not perfect, but definitely good.
05:56:15 <ski_> malcolm : yes, sure .. but even those statically know, would be good (so one doesn't have to open implementation)
05:56:28 <twb> Philippa_: lemme guess: legacy applications / games?
05:56:43 <r2do2> shapr: and what do you prefer for your gui requirements ? 
05:57:04 <Philippa_> games, plus by now I've got the UI burnt into my synapses and the time involved in learning something substantially different is a pain in the arse
05:57:18 <r2do2> shapr: and before i digress are there any better options to postgresql w.r.t haskell ? haskelldb maybe ? 
05:57:26 <Philippa_> (I'm still waiting on a really /good/ text editor, but I figure we can skip that argument?)
05:57:26 <ski_> malcolm : .. so, 'map id = map (Con . des)' and 'map id' is O(0) .. though i think it doesn't necessarily follow that 'map (Con . des)' should be O(0), in the general case
05:57:28 <shapr> r2do2: I've only used gtk2hs, but I know wxHaskell also works.
05:57:31 <jlouis> shapr: conjure updated. Seems really nice. I do not have that much time to work on it at the moment (Studies) but hopefully, I'll get around to hack a bit on the FS code
05:57:38 <Heffalump> r2do2: if you want direct SQL access, HSQL is the thing to use
05:57:45 <Heffalump> if you want a high level relational abstraction, then haskelldb
05:58:01 <shapr> HaskellDB is worth trying, it's way cool.
05:58:05 <malcolm> Philippa_: synapse-burning is something a certain monopoly vendor relies on for continuing income stream
05:58:12 <Philippa_> malcolm: I know
05:58:14 * reductor looked in happy README and decided to forget 'hs-plugins', forget 'hsx' and definitely forget 'happy'.
05:58:21 <jlouis> shapr: also, the rocket is ready for you. You can just rock on SHA1+FPS
05:58:25 <Philippa_> OTOH, they've got me by the games anyway, and I use very little of their software beyond the OS itself
05:58:37 <shapr> jlouis: cool
05:59:02 <twb> Philippa_: A *good* text editor?  You don't like Emacs?
05:59:23 <malcolm> text editor wars!  Yay!
05:59:42 <Philippa_> twb: I don't, no. It would take a long, long time to beat into shape, doubly so as I actively want to use the 'local' conventions I'm used to
05:59:43 <shapr> Wars are so productive.
05:59:52 <twb> I play music in Emacs.  I browse the web in Emacs.  I read mail in Emacs.
05:59:53 <r2do2> shapr: can haskelldb handle a moderate inventory management program ? 
05:59:55 <Philippa_> I'm planning on messing around with Yi once there's a stable GUI release
06:00:04 <jlouis> shapr: Look at FS.Piece.sha1Checksum and attempt to kill the FPS.unpack there by making SHA1 attack FPS's directly would be my bet
06:00:06 <Philippa_> yes, I know. RMSOS is not for me though
06:00:11 <r2do2> Heffalump: i will give HSQL a trial tnx ;) 
06:00:21 <reductor> is there any other way to load and eval hs code?
06:00:27 <maniacH> can someone give me a little map functon example ?
06:00:37 <twb> Philippa_: you say you're used to Windows' GUI?
06:00:40 <twb> Philippa_: http://cyber.com.au/product/safe_internet_computer/mainscreen2.png
06:00:43 <Philippa_> maniacH: map (+1) [1,2,3] => [2,3,4]
06:00:55 <Philippa_> twb: a screenshot can't and won't tell me sufficient
06:00:59 <maniacH> gud :)
06:01:14 <shapr> r2do2: I think so, but it depends on your definition of moderate :-)
06:01:22 <shapr> > map (+1) [1..5]
06:01:26 <ScannedInAvian> [2,3,4,5,6]
06:01:36 <twb> Philippa_: aw :-(
06:02:03 <malcolm> > replicate 4 4
06:02:03 <r2do2> shapr: oh nothing much just a small stationary store plus all their inventory etc etc ...
06:02:05 <Philippa_> twb: I tried GAIM on windows and hated it because it didn't quite get the details right, for example
06:02:06 <ScannedInAvian> [4,4,4,4]
06:02:20 <twb> Philippa_: that wasn't a screenshot of windows.
06:02:40 <Philippa_> it's still loading. And... yeah, OK, can see
06:03:04 <Philippa_> thing is, I'm picky. Gotta get it /exactly/ right, or those burnt-in synapses'll be wondering WTF it's not behaving the way it should
06:03:19 <Philippa_> I've used a couple of the windows-like desktops for linux, they were... OK if I wasn't doing anything serious
06:03:28 <twb> Philippa_: I spent a *long* time getting it close.
06:03:35 * Philippa_ nods
06:03:37 <Philippa_> I'm not willing to
06:03:38 <twb> Philippa_: things like Alt+Escape work the same.
06:04:07 <Philippa_> and like I said, they've got me by the games
06:04:11 <twb> Anyhow, I was just showing off.
06:04:19 <twb> Heh, I don't play computer games.
06:04:26 <twb> I must be fucking unique by now.
06:04:53 <Philippa_> not quite. But I used to be a pretty serious player and I probably will be again sometime
06:05:11 <Philippa_> in fact, very likely if I can afford a machine that plays UT2007 properly by the time it's out
06:05:18 <twb> I don't have the spare money to buy games.
06:05:33 * Heffalump doesn't play computer games at the moment, and has probably escaped being sucked in by Civ4 because of the hardware requirements
06:05:35 <shapr> hi frevidar, learning Haskell?
06:05:40 <twb> My entire life savings was blown on tuition fees.
06:05:43 <Philippa_> we only do because it's more cost-efficient than books or DVDs
06:05:44 * Philippa_ nods
06:05:56 <twb> You think books are expensive?!
06:05:56 <Philippa_> stuck on benefits here 'cos I'm not in a state to work or study
06:06:05 <frevidar> shapr: you've been here forever.
06:06:12 <shapr> frevidar: Longer than that.
06:06:17 <Philippa_> I think I get more hours out of the games than I do out of a novel
06:06:39 <araujo> twb, some of them are.....
06:06:45 <shapr> frevidar: Some people claim I'm just a bot.
06:06:48 <jlouis> Good games are hard to find. I have no computer ready for Oblivion
06:06:54 <jlouis> argh
06:06:57 <Philippa_> the sorts of books I get a decent length of time out of cost as much as the games anyway
06:07:11 * jlouis makes a mental note: Conjure must be finished before Oblivion
06:07:17 <Philippa_> jlouis: ouch. Damien wants a copy too, I think we're just going to end up getting an xbox 360 once the price drops
06:07:21 <frevidar> shapr: seemingly so.
06:07:32 <twb> Even a brand new book costs like $50 bucks, max.
06:07:42 <twb> Computer games cost list $120.
06:07:42 <Philippa_> I'm a fast reader, 'nuff said?
06:07:43 <shapr> Not the books I want :-(
06:07:52 <superibor> jlouis I concurr
06:08:12 * malcolm has never managed to get more than 1/2 hour out of any game before getting frustrated at his inability to play it.
06:08:16 <twb> http://www.george-orwell.org/Books_vs._Cigarettes/
06:08:34 <twb> Argh, that's not the actual essay :-/
06:08:36 <Philippa_> twb: I agree vs ciggies. But really, I know what I'm talking about when it comes to the games
06:08:39 <superibor> I'm getting one Xbox 360 too for Oblivion
06:08:51 <Philippa_> when two people get 100+ hours each out of a game that cost £14.99...
06:08:53 <Philippa_> door, brb
06:09:03 <jlouis> twb: +the newest computer you need to play the game
06:09:12 <twb> jlouis: yeah
06:09:32 <fworp> usually you walk away from a book with more than just x hours of time spent though.
06:09:51 <twb> fworp: except for Harry Potter books :-)
06:10:00 <twb> http://www.george-orwell.org/Books_vs._Cigarettes/0.html
06:10:25 <fworp> twb: hehe
06:11:06 <shapr> Any good forkOS using Haskell programs I can try with -smp ?
06:11:21 <Philippa_> fworp: I got more than just x hours spent from gaming, too
06:11:31 <twb> Ugh.  I'm gonna go back to learning Korean for a bit, because I'm actually making some progress with that.
06:11:42 <twb> Philippa_: calloused thumbs? ;-)
06:11:49 <maniacH> what  . does in haskell ?
06:11:53 <Philippa_> twb: I'm a Street Fighter player. I bought a stick...
06:12:00 <fworp> lol
06:12:10 <fworp> a wooden stick?
06:12:11 <r2do2> why korean ? i thought mandarin makes more sense ;)
06:12:22 <twb> r2do2: I'm too stupid to learn ideograms
06:12:24 <shapr> maniacH: function composition
06:12:31 <Philippa_> fworp: a joy stick. If it helps any, that one's not made of silicone
06:12:37 <twb> r2do2: hanguel kicks arse.
06:12:42 <shapr> Written Korean is surprisingly simple.
06:12:47 <maniacH> shapr , example please ?
06:12:55 <twb> http://twb.ath.cx/~twb/doc/muse/HTML/speak-korean.html
06:12:58 <r2do2> ah yes the more structured writing ;)
06:13:07 <Philippa_> anyway, gotta go
06:13:09 <r2do2> ofcoures they do have their own equivalent to kanji ;) 
06:13:16 <Philippa_> a different kind of gaming awaits
06:13:38 <r2do2> but i think its only for school 
06:13:44 <r2do2> hanji iirc ... ... 
06:13:45 <twb> r2do2: but it's banned in NK and deprecated in most of SK
06:13:52 <fworp> i thought you meant something else, woops.
06:14:02 <twb> Whereas getting along in .jp without kanji would be difficult.
06:14:33 <shapr> Has anyone else tried building ghc-spm?
06:14:35 <shapr> smp*
06:16:06 <shapr> > (Data.Char.chr . (+1) . Data.Char.ord)  'a'
06:16:09 <ScannedInAvian> 'b'
06:16:44 <kombinator> > ['a'..]!!1
06:16:44 <jlouis> > succ 'a'
06:16:45 * ski_ wonders if #haskell and #haskell-blah just merged
06:16:45 <shapr> > map (Data.Char.chr . (+1) . Data.Char.ord) "ScannedInAvian"
06:16:46 <ScannedInAvian> 'b'
06:16:47 <ScannedInAvian> 'b'
06:16:48 <ScannedInAvian> "TdboofeJoBwjbo"
06:17:12 <jlouis> Where is lambdabot?
06:17:20 <jlouis> since ScannedInAvian now answers?
06:17:41 <ski_> (where is dons ?)
06:17:43 <shapr> I dunno, I assume it went down?
06:20:15 <reductor> so there is no way to load and eval haskell code at runtime not using hs-plugins?
06:20:33 <shapr> You could use hugs.
06:21:15 <reductor> from ghc?
06:21:37 <fworp> @pl (\ e l -> foldr (\r x -> r || x == e) False l)
06:21:38 <ScannedInAvian> flip foldr False . flip ((.) . (||)) . (==)
06:21:44 <shapr> Yes, you could also call hugs from ghc.
06:22:10 <ski_> @type \e l -> foldr (\r x -> r || x == e) False l
06:22:12 <ScannedInAvian> Bool
06:22:12 <ScannedInAvian>                 -> [Bool]
06:22:12 <ScannedInAvian>                 -> Bool
06:22:29 <fworp> thats not what i was expecting
06:22:53 <fworp> though i guess it makes sense
06:22:57 <ski_> @type \e l -> foldl (\r x -> r || x == e) False l
06:22:59 <ScannedInAvian> forall b.
06:22:59 <ScannedInAvian>                 (Eq b) =>
06:22:59 <ScannedInAvian>                 b -> [b] -> Bool
06:23:02 <reductor> thank you
06:23:12 <fworp> oh, right
06:23:17 <ski_> @type \e l -> foldr (\x r -> r || x == e) False l
06:23:19 <ScannedInAvian> forall a.
06:23:19 <ScannedInAvian>                 (Eq a) =>
06:23:19 <ScannedInAvian>                 a -> [a] -> Bool
06:23:37 <ski_> (you possibly mean that last one)
06:24:39 <ski_> @type \e l -> any (== e) l
06:24:41 <ScannedInAvian> forall a. (Eq a) => a -> [a] -> Bool
06:24:49 <fworp> @pl \ e l -> foldr (\x r -> r || x == e) False l
06:24:51 <ScannedInAvian> flip foldr False . (flip (||) .) . (==)
06:24:51 <ski_> (or maybe even that)
06:25:54 <fworp> @pl \e l -> any (== e) l
06:25:55 <ScannedInAvian> any . (==)
06:26:46 <ski_> > any (== 'c') "abcd"
06:26:48 <ScannedInAvian> True
06:26:50 <ski_> > any (== 'c') "abed"
06:26:52 <ScannedInAvian> False
06:31:00 * ski_ wonders if one could have "GADT newtypes with multiple constructors"
06:33:43 <ski_> (hm, prolly not, since the tyargs could be variables)
06:34:10 <Heffalump> ski_: surely that would destroy the point of a newtype
06:34:24 <Heffalump> oh, maybe not.
06:34:48 <ski_> if was thinking if we could get away with having no tag, if the tyarg determined the form
06:34:48 <Heffalump> you'd need to guarantee no overlap.
06:34:53 <Heffalump> yeah
06:35:38 <ski_> (like when implementing e.g. lambdacalc .. having Expr as a 'data', then you'd like to remove 'Fun' tags, if the stuff typechecks)
06:36:12 <Heffalump> hmm, that's harder cos there are other situations where you can't remove the tags
06:36:32 <ski_> but 'foo : Bar a -> ..' will still be problematic .. since how are we going to recover what 'a' is ?
06:38:24 <ski_> (yes, like ''App' tags can't be removed, of course)
06:39:09 <Heffalump> but the point is to remove the tags from the representation
06:39:15 <ski_> right
06:39:28 <Heffalump> and you can't even remove Fun tags because they might be used in situations where you don't know it's a Fun
06:39:30 <ski_> (which is why i said "newtype")
06:39:42 <ski_> hm
06:39:54 <ski_> if polymorphic, right .. point
06:40:04 <Heffalump> so I think what you are describing is an optimisation that GADTs enable.
06:40:21 <ski_> ok
06:40:24 <Heffalump> (namely that you don't need to _inspect_ the tag in some situations)
06:40:33 <ski_> m-m
06:40:38 <Heffalump> also, that possibly you can remove it when the entire dataflow is known
06:43:29 <ski_> possibly monomorphic code could remove tags ..
06:45:30 <Heffalump> well, even Lam Int could be Ap (Lam (Int->Int)) (Lam Int) or Con Int
06:47:00 <ski_> yes, App and Con is a prob
06:47:12 <ski_> (had an idea for Con, but it possibly doesn't work)
06:49:16 <phys_rules> ghc-6.5: internal error: stg_ap_p_ret
06:49:16 <phys_rules>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
06:49:20 <phys_rules> grr :|
06:59:53 <musasabi> Has anyone used Haifa for purposes similar to DtdToHaskell (except for XML Schemas instead of DTDs) ?
07:09:07 <malcolm> musasabi: no.  But I wonder how hard it would be to write  XSDToHaskell and RelaxNGToHaskell tools
07:10:11 <musasabi> Probably not too hard, but I am not very familiar with XSD, just want to parse the XML files to sensible Haskell representation.
07:10:22 <phys_rules> hey musasabi :)
07:11:43 <musasabi> hello phys_rules 
07:15:34 <jlouis> regarding our XML discussion yesterday: http://homepages.inf.ed.ac.uk/wadler/xml/
07:24:48 <Frederick> yo folks
07:32:56 <phys_rules> hey Frederick
07:40:15 <shapr> Doesn't stage=2 build ghci?
07:51:08 <phys_rules> shapr: IMHO no
07:51:19 <phys_rules> in an unregistered build
07:51:31 <phys_rules> in registered it could build ghci right away (and nativeGen)
07:51:38 <phys_rules> as in the first stage
08:10:14 <jlouis> Conjure updated again. Nice hacks by Dmitry Astapov yet again
08:51:47 <datenmaulwurf> Hi
08:52:05 <datenmaulwurf> with which function can i get the first element of a list xs?
08:52:12 <tromp> head
08:52:16 <datenmaulwurf> thx!
08:52:57 <tromp> though it's rarely needed
08:55:35 <datenmaulwurf> and the rest of a list xs?
08:55:46 <datenmaulwurf> so, the list without teh first element?
08:55:50 <datenmaulwurf> in miranda it's tl
08:56:46 <tromp> tail
08:56:54 <datenmaulwurf> omg, thanks
08:57:25 <tromp> you can write these functions yourself
08:57:32 <tromp> head (a:_) = a
08:57:41 <tromp> tail (_:b) = b
08:57:45 <datenmaulwurf> yeha, bu i know, that they exists in the prelude-enviroment
08:57:50 <datenmaulwurf> :P
08:58:15 <tromp> say you want to swap the 1st and 2nd element in a list
08:58:25 <tromp> then you wldnt use head/tail
08:58:43 <tromp> swap (a:b:t) = b:a:t
08:59:43 <datenmaulwurf> i write a conclave tomorrow
08:59:47 <datenmaulwurf> about miranda
08:59:57 <datenmaulwurf> and i have a ibook, where miranda doesn't runs
09:00:07 <mwc> Haskell runs great on OS X
09:00:09 <datenmaulwurf> so i have to test my code in haskell
09:00:09 <mwc> use that
09:00:12 <mwc> ah
09:00:17 <datenmaulwurf> right, i do it
09:00:19 <mwc> How does that work?
09:00:28 <datenmaulwurf> yeah, some things are different
09:00:33 <datenmaulwurf> strange something
09:00:43 <datenmaulwurf> i don't understand haskell sometimes
09:00:45 <datenmaulwurf> example
09:01:34 <datenmaulwurf> a replaceall-function
09:01:38 <datenmaulwurf> works great in miranda
09:01:39 <datenmaulwurf> replaceall x y []     = []
09:01:39 <datenmaulwurf> replaceall x y (x:xs) = y:replaceall x y xs
09:01:39 <datenmaulwurf> replaceall x y (z:xs) = z:replaceall x y xs
09:01:48 <datenmaulwurf> but in haskell you can't do something like this
09:01:58 <Frederick> SamB, Cale, astrolabe are you around?
09:02:08 <datenmaulwurf> you're not allowed to put a variable into a muster
09:02:12 <Heffalump> Haskell insists on linear patterns
09:02:17 <datenmaulwurf> yeah
09:02:19 <datenmaulwurf> why?
09:02:22 <Heffalump> you can use guards instead
09:02:24 <datenmaulwurf> it's wonderful in miranda
09:02:29 <datenmaulwurf> hmm
09:02:32 <Heffalump> because of the confusion non-linear patterns cause for the type
09:02:42 <Heffalump> - you end up with an Eq constraint when you never wrote ==
09:02:50 <Heffalump> you can replace your non-linear line with
09:02:57 <Heffalump> replaceall x y (x':xs) | x == x' = ...
09:03:04 <datenmaulwurf> -.-
09:03:05 <Heffalump> and it'll behave exactly the same
09:03:09 <datenmaulwurf> ok, thanks
09:03:16 <datenmaulwurf> but it's not that nice :P
09:03:43 <datenmaulwurf> it doesn't matter - on college i'm learning haskell, in school miranda
09:04:32 <tromp> replaceall = map (\z -> z==x ? y : z)
09:04:40 <datenmaulwurf> :P
09:04:55 <tromp> i mean replaceall x y = map (\z -> z==x ? y : z)
09:06:23 <tromp> hmm, maybe haskell doesn't have ?:   :(
09:06:28 <palomer> is x ? y : z exactly the same as if x then y else z?
09:06:38 <Heffalump> yes
09:06:44 <Heffalump> (apart from not existing in Haskell)
09:06:49 <tromp> try replace x y z = if x==z then y else z
09:06:59 <palomer> oh, right, non existence is a difference
09:07:12 <palomer> we should do away with if then else and just use ?:
09:07:20 <palomer> who's with me?
09:07:22 <tromp> replaceall x y = map $ replace x y
09:07:30 <Heffalump> we don't want to turn Haskell into Perl :-)
09:09:05 <mentomorph> Hi! How can I make Gtk2Hs Color data type an instance of Eq class. Id like to use deriving Eq isntead of defining my own but since it's a built in datatype I dont know how to write that.
09:10:19 <musasabi> @seen malcolm
09:10:20 <ScannedInAvian> I saw malcolm leaving #haskell-blah and #haskell 1 hour, 49 minutes and
09:10:20 <ScannedInAvian> 10 seconds ago.
09:11:43 <Frederick> @seen SamB 
09:11:44 <ScannedInAvian> SamB is in #haskell-blah and #haskell. I don't know when SamB last spoke.
09:11:49 <mentomorph> nm'
09:11:52 <Frederick> @seen astrolabe 
09:11:54 <ScannedInAvian> astrolabe is in #haskell-blah and #haskell. I don't know when astrolabe
09:11:54 <ScannedInAvian> last spoke.
09:31:02 <palomer> cayenne looks interesting
09:31:19 <astrolabe> hello Frederick
09:31:39 <palomer> though the examples don't really show off the power of dependent types
10:30:06 * SamB wonders why Just{} doesn't result in a warning
10:30:13 <SamB> > Just{}
10:30:15 <ScannedInAvian> Add a type signature
10:30:32 <SamB> > Just{} :: Maybe ()
10:30:35 <ScannedInAvian>  Missing field in record construction
10:30:43 <eivuokko> Huh.
10:31:14 <basti_> hmm
10:31:19 <SamB> I suppose its because people who do that probably know that what they are doing is strange ;-)
10:31:30 <basti_> @type {}
10:31:32 <ScannedInAvian> parse error on input `{'
10:31:38 <basti_> @type Just{}
10:31:40 <ScannedInAvian> forall a. Maybe a
10:31:49 <basti_> @type Just()
10:31:51 <ScannedInAvian> Maybe ()
10:31:55 <basti_> whats {}?
10:31:58 <basti_> a type _?
10:32:05 <SamB> from DsExpr.lhs:
10:32:05 <eivuokko> Empty expression?
10:32:12 <SamB> We also handle @C{}@ as valid construction syntax for an unlabelled
10:32:14 <SamB> constructor @C@, setting all of @C@'s fields to bottom.
10:32:46 <basti_> ah
10:33:01 <basti_> then the type seems a little broad tbh
10:33:11 <basti_> "forall a. Maybe a"
10:33:22 <SamB> @type undefined
10:33:24 <ScannedInAvian> forall a. a
10:33:48 <basti_> i wouldnt expect all things to be an record.
10:34:01 <SamB> they aren't
10:34:05 <basti_> a record that fails on its fields is different to one that fails on its value
10:34:38 <SamB> well yeah
10:35:46 <SamB> which is why Just{} != _|_
10:35:51 <basti_> yep
10:35:58 <basti_> but now you try to force it to be Maybe ()
10:36:12 <basti_> which is something else than tuples that fail on every value
10:36:15 <SamB> anyhow, its presumably an extension...
10:39:49 <SamB> hmm, I wonder why the desugarer needs to deal with type applications/lambdas
10:41:52 * SamB also wonders why all this stuff in DsExpr uses `thenDs` instead of >>= or "do"
10:46:48 <ski_> (what's DsExpr ?)
10:47:07 <phys_rules> JaffaCake: are you around ? :)
10:48:47 <Heffalump> SamB: how old is it?
10:49:05 <SamB> Heffalump: there is that
10:49:22 <SamB> its probably from long, long ago....
10:52:26 <ski_> (datenmaulwurf : fwiw, prolog allows nonlinear "patterns", too)
11:01:24 * SamB doesn't see how to use STM in Conjure
11:03:51 <reddi> is there no string library in haskell?
11:06:41 <reddi> is it cause string is [char]?
11:07:21 <SamB> reddi: string library?
11:07:39 <SamB> reddi: what is it you wish to do?
11:07:42 <reddi> hm i cannot find any functions on strings
11:07:58 <reddi> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
11:08:04 <reddi> something like that, only for strings 
11:08:21 <SamB> reddi: all of those work on strings
11:08:40 <reddi> but there is no library especially for strings
11:08:51 <SamB> except the ones that work on [Bool] or Num a => [a] only, of course...
11:09:04 <SamB> reddi: not really
11:09:11 <reddi> ok, thx
11:09:31 <reddi> i see, type String = [Char]
11:09:32 <SamB> I mean, not the String kind
11:09:33 <reddi> this is the reason ;-)
11:09:44 <SamB> there are some packed-string libraries
11:09:48 <SamB> reddi: yes, exactly!
11:11:58 <TheHunter> has anybody ever started to write a replacement for Data.List?
11:14:59 <Heffalump> with what properties?
11:15:50 <TheHunter> I don't know, just better.
11:16:40 <TheHunter> A lot of things are awkward with Data.List. For example [1,2,3,4] -> [(1,2),(3,4)].
11:16:56 <TheHunter> I had a couple of ideas on the issue, but I've forgotten most of them.
11:17:49 <Heffalump> awkward, or inefficient?
11:17:57 <SamB> hmm. isn't that kind of thing what MissingH is for?
11:18:16 <TheHunter> probably both.
11:18:59 <TheHunter> I also would like to be able to express things nicely that need two traversals which can be done parallel.
11:19:14 <TheHunter> eg. simultaneously computing sum and product.
11:19:32 <TheHunter> @where MissingH
11:19:34 <ScannedInAvian> I know nothing about missingh.
11:19:41 <SamB> huh
11:19:55 <SamB> oh, lambdabot knows it but isn't here
11:20:09 <SamB> ScannedInAvian is just a cheap knockoff
11:20:21 <Xianianol> erm, how do I get the pastebin ?
11:20:29 <TheHunter> lambdabot: where art thou?
11:20:33 * SamB wonders if lambdabot's codebase is gender-neutral or not
11:20:42 <SamB> lisppaste2: help
11:20:43 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:20:54 <Xianianol> Thanks.
11:22:14 <TheHunter> MissingH.List isn't radical enough :)
11:22:57 <adept> re ppl
11:23:04 <adept> jlouis: hi :)
11:23:53 <SamB> TheHunter: hmm. I suppose it would be better if there was a repo...
11:23:54 <TheHunter> the WholeMap concept is a good idea.
11:25:06 <Frederick> hello astrolabe 
11:32:12 <lisppaste2> Xianianol pasted "Arithmetic Expression Parser (without evalutation)" at http://paste.lisp.org/display/14059
11:34:12 <adept> what happened to lambdabot?
11:35:50 <SamB> adept: who knows?
11:36:37 <jlouis> adept: hi, and thanks
11:36:48 <SamB> jlouis: hello
11:36:50 <Cale> > map (*2) [1..10]
11:36:52 <ScannedInAvian> [2,4,6,8,10,12,14,16,18,20]
11:36:53 <mbot> [2,4,6,8,10,12,14,16,18,20]
11:36:55 <Cale> ah
11:36:59 <Cale> hehe
11:37:11 <Cale> mbot: @part #haskell
11:37:13 <adept> jlouis: now you know my irc handle. I already fixed the AUTHORS though
11:37:27 <adept> jlouis: latest set of patches should be on it's way to you
11:37:30 <Xianianol> I've pasted a problem that I am having in the pastebin: http://paste.lisp.org/display/14059 If anyone have any clue, please tell me.
11:37:39 <jlouis> I guessed it was ADept, but I was not sure
11:37:43 <jlouis> thanks for correcting
11:38:09 <jlouis> adept: cool
11:38:32 <jlouis> I'll try to pull them and see
11:38:40 <Cale> Xianianol: Expr and String aren't the same type
11:39:13 <Cale> despite the fact that there's a function Var :: String -> Expr
11:39:13 <Xianianol> Expr is just a data that I've defined myself, and one of its type "Var" is a String.
11:39:26 <Xianianol> Humm...
11:39:56 <adept> jlouis: i had coplu of question. should we go off-channel?
11:40:59 <sylvan> Xianianol, you write "return (Var e)" where e is of type Expr, not String
11:41:15 <jlouis> adept: it depends on other people
11:41:26 <jlouis> I'd rather want it here
11:41:37 <Xianianol> Is just that I thought that would be fine as soon that I've defined that Var is a string.
11:42:24 <Cale> Var isn't a String, it takes a string as a parameter, and returns an Expr
11:42:36 <Cale> it's a data constructor
11:43:42 <sylvan> Xianianol, you've defined Var to take a String, yes, but you're not passing it a String, you're passing it an Expr ("e <- parseExpr" and then later "return (Var e)")
11:44:09 <Cale> perhaps you want (return e) there
11:44:25 <Cale> since e is already an expression
11:44:59 <SamB> I find the use of overlapping instances in BEncode rather disconcerting...
11:45:39 <Xianianol> returning just e (taking Var out) fixes that error, but it causes error saying that f++t is not possible, since the term "t" is a Expr and it does not match [a].
11:46:48 <Cale> right
11:46:56 <sylvan> The compiler isn't lying! :-)
11:46:57 <Cale> do you see why that's an error?
11:47:09 <Cale> t and e are expressions
11:47:18 <Xianianol> Yeah and the ++ is for [a]
11:47:22 <Cale> yeah
11:47:25 <Cale> er
11:47:33 <Cale> f and t as well
11:48:05 <Xianianol> So I must find a way to convert them into Strings ?
11:48:05 <Cale> so you have to decide what it is that you really want to do in that case
11:48:47 <SamB> jlouis: are you there?
11:48:57 <Cale> well, you're presumably parsing them to convert them from Strings into some more structured representation -- converting back into strings at that point would seem like a step in the wrong direction
11:49:11 <araujo> Anyone knows a function that might help me to separate tokens which can contain special characters like whitespaces? , for example: f "foo foo_special{ } bar" => ["foo" , "foo_special{ }", "bar"] 
11:49:15 <Cale> why not something like  return (t :+ e) ?
11:49:28 <Cale> you have :+ and :* in your datatype
11:49:29 <araujo> Or probably some doc/tutorial that might help me.
11:49:34 <musasabi> Is DtdToHaskell working with HaXml 1.14 ? It seemed broken with the CVS one...
11:49:54 <Cale> araujo: look into parsec, I suppose
11:50:10 <Cale> It might be overkill, but looking at that, it might not be :)
11:50:20 <araujo> Cale, there i go, thank
11:51:02 <Cale> "{ { } { { } } }" -- if that has to parse as one token, then you'll want something like parsec, definitely :)
11:51:27 <Xianianol> Humm, is just that if I do that it would produce outputs like [(Nat 2 :+ (Nat 2 :* Nat 5),"")], one of my parsers does that already.
11:51:56 <SamB> Xianianol: so what are you trying to do? calculate the answer?
11:52:16 <Cale> Xianianol: Why not start from there, and convert the structure into a string
11:52:26 <SamB> or prettyprint it?
11:52:56 <Cale> or if you're just checking that the parse succeeds, you don't care what the structure looks like at all
11:53:15 <Xianianol> Well, I got 3 parsers (2 of them working). One evaluates arithmetic expressions and one does the "[(Nat 2 :+ (Nat 2 :* Nat 5),"")]" thing.
11:53:36 <Xianianol> And I sort of want to make one parser in the middle to confirm the input
11:54:00 <Cale> Confirm?
11:54:19 <Xianianol> For example, if you write "2++2", that parser would reject it.
11:54:21 <SamB> confirm what properties of the input?
11:54:32 <Cale> Doesn't your other parser already do that?
11:54:37 <SamB> Xianianol: don't both your existing parsers do that just fine?
11:54:47 <Xianianol> Well yeah.
11:54:52 <SamB> so whats the problem?
11:55:05 <Xianianol> But for example, my evaluate parser just accepts Int
11:55:15 <SamB> ?
11:55:22 <Cale> what?
11:55:26 <SamB> what is the problem?
11:55:38 <Cale> also, you probably shouldn't really evaluate in the parser
11:55:42 <_Codex> maybe he wants more checks than just syntax check?
11:55:49 <Xianianol> Well, is just that the input would be in the form Expr.
11:56:05 <Xianianol> That is, I got a eval function that Expr -> Int
11:56:21 <Cale> okay, that's the right type -- that's not a parser though
11:56:46 <Xianianol> Well, yeah, that just a side function.
11:57:28 <Cale> okay, so you parse this language, if it fails, you handle that, if it succeeds, you get this nice data structure, and then you potentially evaluate it
11:57:41 <Xianianol> Yes.
11:57:51 <Cale> you only need one parser
11:58:14 <Xianianol> Humm...Well, since I am no good in parsing, I thought would be easier if I do it in bits.
11:58:33 <Xianianol> One for the form, one for the structure and one for the evalutation
11:58:45 <Cale> oh, well, you've already done that
11:58:57 <Cale> you have a Parser Expr (the first part)
11:59:05 <Cale> and then an Expr -> Int
11:59:07 <Cale> (the second)
11:59:33 <Xianianol> Is just that I don't know how to evaluate something at this format: "[(Nat 2 :+ (Nat 2 :* Nat 5),"")]"
11:59:41 <Cale> okay
11:59:57 <SamB> Xianianol: thats easy!
12:00:23 <Xianianol> Well, it seems harder than writing the parsers :P
12:00:28 <SamB> you just need to define a little function with a body for each case
12:00:39 <SamB> that is, for each constructor in Expr
12:00:57 <Xianianol> Humm, you mean...like in the evalFunction ?
12:01:10 <SamB> yeah
12:01:14 <Cale> eval (e1 :+ e2) = (eval e1) + (eval e2)
12:01:16 <Cale> etc.
12:01:35 <Xianianol> err, but it is impossible to define all of them manually...
12:01:46 <Cale> what?
12:01:47 <SamB> Xianianol: oh come now
12:01:55 <Cale> there's only 3 cases!
12:01:56 <SamB> you have a finite number of constructors
12:02:09 <Cale> :+, :*, and Nat
12:02:12 <SamB> so you only need a finite number of cases
12:02:20 <Cale> (and possibly you want to so something with Var)
12:02:24 <Cale> do*
12:02:50 <Xianianol> Humm, but then wouldn't e1 :+ (e2 :+ e3) be another case ?
12:02:55 <Cale> no
12:02:56 <SamB> no
12:03:00 <Cale> that's the :+ case
12:03:10 <ValarQ> @type (:+)
12:03:12 <ScannedInAvian> Not in scope: data constructor `:+'
12:03:16 <_Codex> xianianol: the call to eval handles that.
12:03:21 <Cale> with e1 as the first expression, and e2 :+ e3 as the second
12:03:29 <SamB> you just handle the :+ at the top, and then the recursion into eval will take care of te (e2 :+ e3)
12:03:53 <Cale> you could also write a handy folding function for your Expr type
12:04:00 <ski_> (TheHunter : WholeMap ?)
12:04:22 <Xianianol> Let me see...
12:05:08 * SamB does away with overlapping instances
12:05:55 <Cale> foldExpr v n p t e = case e of (Var s) -> v s; (Nat x) -> n x; (x :+ y) -> p (foldExpr v n p t x) (foldExpr v n p t y); (x :* y) -> {- similar to :+ -}
12:06:05 <Cale> sorry that's all squashed onto one line :)
12:06:46 <SamB> jlouis: observe patches in inbox
12:06:48 <Xianianol> Well, that is not important. Is just that I need to understand the concept.
12:07:01 <Cale> then you could write eval like  eval = foldExpr undefined id (+) (*) 
12:07:25 <_Codex> cale: isnt that a little too difficult? :)
12:07:33 <SamB> what are the variables for?
12:07:48 <SamB> that is, you seem not to have a binding construct
12:08:13 <jlouis> SamB: cool, coordinate with adept. He has some plans to work on the WireMessage protocol
12:08:13 <Xianianol> Well, later I need to use variables, so I can assign them values.
12:08:27 <SamB> jlouis: my patches are not for that
12:08:35 <Xianianol> Since right now I am concentrating in evaluating simple things like 2+3*2.
12:08:47 <Xianianol> But later I need to be able to handle 2+3*2+x
12:08:55 <Xianianol> That is where the Var comes in.
12:09:08 <SamB> are they to be bound or not?
12:09:33 <Xianianol> Humm, sorry, I don't know what you mean bound.
12:09:39 <Xianianol> *with bound.
12:09:53 <jlouis> SamB: it was not directly to your patches ;)
12:09:58 <SamB> jlouis: ah
12:10:07 <SamB> whatever happened with musasabi?
12:10:09 <SamB> anything?
12:10:54 <SamB> so what kind of stuff did adept want to do?
12:11:19 <jlouis> I do not know exactly, but I am just trying to coordinate people to avoid double work
12:11:28 <SamB> yeah
12:11:43 <jlouis> If you hack on it, send him a heads-up I think
12:12:03 <adept> SamB: i want to see the Big Picture :)
12:12:09 <SamB> adept: big picture?
12:12:26 <Cale> _Codex: I don't know, it seems like a sane thing to do -- look how successful it is at cleaning up the definition of eval :)
12:12:32 <SamB> the WireProtocol module is not about big picture ;-)
12:12:37 <adept> SamB: like, hack something which actually performs startup-connect to tracker-get peer-handshake with peer thing
12:13:02 <Cale> You could also, for instance, write a variable replacer using foldExpr
12:13:02 <adept> SamB: otherwise, it is not at all clear how things are going to mingle
12:13:02 <SamB> hmm
12:13:22 <SamB> adept: hmm, let me look at the milestones
12:13:27 <adept> SamB: yeah, I know :) I want to touch it just a little bit - add handshake there
12:13:50 <SamB> jlouis: do we have to do 1 and 2 before 3?
12:13:57 <jlouis> SamB: nope!
12:13:59 <_Codex> cale: yes, when same primitives have more than one interpretation in different contexts folds can be very useful.
12:14:00 <ski_> foldExpr v n p t = loop where loop (Var s) = v s; loop (Nat x) = n x; loop (x :+ y) = p (loop x) (loop y); loop (x :* y) = t (loop x) (loop y)
12:14:02 <SamB> cool
12:14:06 <adept> SamB: milestones say thay design goes bottom-up. Which means that we defer troubles till later. Is it really cool? :)
12:14:13 <ski_> (that's more readable, imo)
12:14:33 * musasabi thinks musasabi has been distracted by other projects (+ work) and should go hacking, but I don't think he would mind if someone else hacked that
12:14:36 <Cale> ski_: nice :)
12:14:42 <SamB> hmm, I suppose we need to write something up for what this milestone even is
12:14:54 <SamB> oh, we'll need four also
12:15:08 <jlouis> theh MILESTONE document is there to provide some reference points where we can say: ``phew, we got that part finished, mostly''
12:15:14 <adept> SamB: didnt get your point :(
12:15:28 <SamB> adept: well, it says:
12:15:28 <Cale> _Codex: folds are almost always useful on recursive data types.
12:15:37 <SamB> Milestone 3: Thread for Peer communication
12:15:37 <SamB> ==========================================
12:15:37 <SamB> TBW.
12:15:37 <SamB> Milestone 4: Master thread.
12:15:37 <SamB> ===========================
12:15:38 <SamB> TBW.
12:15:54 <araujo> lisppaste2, help?
12:15:55 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:16:15 <jlouis> and I like the idea of attacking the project top-down as well
12:16:18 <SamB> jlouis: I don't think the ability to send parts of pieces is a special case
12:16:24 <jlouis> It is just that I tend to work best bottom-up
12:16:42 <_Codex> cale: I think it as just neat trick to avoid copy-pasting same pattern matching code.
12:16:43 <SamB> jlouis: its rather tricky to test bottom-down ;-)
12:16:48 <SamB> er, top-down.
12:16:49 <SamB> whatever
12:17:29 <jlouis> SamB: its not a special case. I just want to get a simpler version running first, where partiality isn't there (But it is there in thought)
12:18:14 <Cale> _Codex: well, anything which avoids copying and pasting code has theoretical benefits too
12:18:14 <adept> jlouis: +1!
12:18:44 <musasabi> I think the hard part is an intelligent algorithm selecting what pieces to want from which peer.
12:19:04 <jlouis> musasabi: it is fixed. We have the implementation from the original bittorrent client already
12:19:08 <jlouis> (more or less)
12:19:08 <Cale> basically, now that you have that recursion handled in one place, you get it right once, and then don't have to think about it
12:19:36 <musasabi> jlouis: that is not very good (it is quite easy to do better in many circumstances)
12:20:10 <musasabi> the algorithm does not work very well if some peers are 1000x better than others.
12:20:27 <Cale> also, suppose you start having space issues, or stack problems due to laziness at some point -- it's easy enough to write a stricter fold, and then drop it in place wherever the lazy fold was having performance problem
12:20:28 <Cale> s
12:20:49 <lispy> what would haskell performance be like if laziness was not the default...
12:21:03 <adept> SamB: well, going bottom up we will reach the point where in order to test something we will need to have rather elaborate context set up. And setting up this context is a job of more up-level modules. Rather than code tests like those in Tests.hs, I would rather have such code in some simple modules with lots of FIXME's around
12:21:15 <Cale> lispy: well, laziness isn't always a performance problem -- quite often it's a huge win
12:21:18 <jlouis> musasabi: I know. It is better than nothing though. If you like, feel free to select them in a smarter way. The code right now is a but too murky for my taste
12:22:02 <lispy> Cale: i guess that true.  I was thinking about ocaml and how it usually higher perormance than say, ghc
12:22:08 <musasabi> jlouis: maybe I should hack the wireprotocol code first ;)
12:22:21 <Cale> well, yeah, because more is known about optimising strict evaluation
12:22:30 <Cale> (and it seems an easier problem)
12:22:31 <jlouis> musasabi: What has the biggest -Ofun! level?
12:22:31 <lispy> Cale: and the big differences i see are laziness and being able to mutate state in ocaml
12:22:49 <jlouis> (hehe)
12:22:58 <musasabi> jlouis: chocolate ;)
12:23:02 <lispy> heh
12:23:26 <Cale> A lot of the speed problems in GHC come from the use of [Char] for large IO problems, rather than some more efficient format.
12:23:47 <lispy> Cale: and continuing down this line of thought, i was wondering if i'd be able to make a Haskell -> OCaml translator to experiment with
12:23:53 <jlouis> adept: I see your point. When I write code, I tend to follow the ideas of Paul Graham (Build successively more expressive mini-languages)
12:24:00 <SamB> jlouis: I'm about to send you a patch to MILESTONES
12:24:07 <Cale> Also, laziness is a poor strategy for consuming large structures completely and reducing them tow to small ones.
12:24:07 <jlouis> Fire away
12:24:10 <Cale> to*
12:24:11 <_Codex> it might help with performance if people knew better how it works in the low level. I at least have a little difficult to guess what primitives have good performance and which are not very good. (for example lots of small functions probably wont give good perf)
12:24:13 <lispy> Cale: ah, FPS helps there right?
12:24:18 <SamB> I'm only waiting for the tests to finish
12:24:18 <Cale> lispy: yeah
12:24:34 <musasabi> I could hack something tonight after I get the work stuff done.
12:25:00 <Cale> You kind of have to get used to lazy evaluation before you can write efficient code, but this in unsurprising.
12:25:13 <_Codex> things like list comprehensions might obviously cause big loops in the low level, but difficult to say how big problem it is.
12:25:16 <jlouis> My problem is I have to go away soon -- And I only get internet connectivity back again tomorrow
12:25:29 <jlouis> I intend to fixup problems in FS
12:25:50 <lispy> Cale: i find that most of the time i want laziness is when i could be using an ML stream
12:26:03 <SamB> _Codex: what makes you think that?
12:26:04 <Cale> I think if you take a beginner C programmer and a beginner Haskell programmer and have them solve a hard problem, whether you get an efficient program out of either one of them will be a toss up :)
12:26:14 <SamB> er, about the small functions being bad
12:26:14 <lispy> so to that effect, i feel like having optional laziness would be nice
12:26:34 <Cale> I usually find that I rarely want strictness
12:26:42 <Cale> (explicitly)
12:26:51 <Cale> most of the time, either evaluation strategy is okay
12:26:58 <_Codex> samb: separation of two code pieces always costs a little. Functions provide separation and thus many small ones increase the cost.
12:27:09 <SamB> I think the likelyhood of getting something that works out of the C programmer is like 1%
12:27:21 <Cale> lispy: Laziness has this nice effect of turning data structures into control flow mechanisms
12:27:35 <Cale> SamB: :)
12:27:44 <lispy> Cale: yeah, i was thinking of it this way:  Most of the time I don't care.  But once in a while I want one or the other.  and strictness is easier to optimize, so lets default to that one.
12:28:01 <_Codex> samb: and only thing that avoids it would be inlining; dunno how could avoid the cost of small functions.
12:28:02 <Cale> lispy: however, laziness gives better compositionality
12:28:06 <Cale> :)
12:28:08 <SamB> of course, maybe the likelyhood of getting an efficient program out of the Haskell programmer is less than 1%
12:28:23 <lispy> Cale: i've heard that, but what does it mean?
12:28:23 <Cale> There are some solutions to problems which you can't even think of if you're in a strict language.
12:28:33 <SamB> _Codex: didn't you just say inlining would do it?
12:28:57 <Cale> For example, consider the problem of looking for a particular substring in a string.
12:29:05 <jlouis> if you combine polyvariance, inlining and contification, small functions are irrelavant
12:29:07 <cognominal_> Cale:  "laziness gives better compositionality". Can you elaborate on that one?
12:29:21 <Cale> In Haskell, I might write  any (isPrefixOf s) (tails str)
12:29:27 <jlouis> I do not think GHC does polyvar and contification, though
12:29:35 <Cale> in a strict language, this is a stupid thing to write
12:29:38 <_Codex> samb: I have a feeling inlining cannot be used in all the situations I would like performance.
12:29:51 <Cale> tails str is hideously inefficient if you do it all at once
12:30:10 <SamB> cognominal_: you can reuse previous functions a lot more easily with laziness
12:30:20 <eNTi> hey guys. simple noob question:
12:30:20 <lispy> Cale: hmm...but in some cases even with laziness you'll have to compute all of tails
12:30:22 <Cale> but in Haskell, I get to reuse my tails function
12:30:40 <Cale> lispy: right, but laziness ensures that I only have to compute the tails that I need
12:30:44 <eNTi> floor:: Float->Int
12:30:44 <eNTi> floor x 0   | n <= x && x < (n+1) = n
12:30:44 <eNTi>             | otherwise = floor x (n+1)
12:30:53 <lispy> and laziness seems to make garbage collection leaky
12:30:58 <eNTi> how do i tell my function to start n at 0?
12:31:09 <Cale> lispy: not in general, just in specific cases
12:31:11 <xerox> eNTi: where n = 0 ?
12:31:20 <xerox> eNTi: oh, no sorry.
12:31:33 <Cale> lispy: Really just in the one general case I mentioned
12:31:41 <Cale> Folding large structures into small ones
12:31:52 <Cale> (where you consume the entire large structure)
12:32:07 <Cale> Like, say, summing a large list of numbers.
12:32:13 <xerox> floor x = floor' x 0
12:32:13 <xerox>   where floor' x n | n <= x && x < (n+1) = n
12:32:13 <xerox>                    | otherwuse           = floor x (n+1)
12:32:25 <eNTi> thx
12:32:35 <lispy> otherwuse
12:32:35 <Cale> These cases are usually easily handled by producing a stricter version of the folding function.
12:32:37 <lispy> nice
12:32:40 <xerox> eNTi: it is usually done by defining an helper function.  You're welcome.
12:33:12 <Cale> xerox: hey, what's up? Has Spivak's text arrived yet?
12:33:36 <xerox> Cale: Amazon says the expected date of arrival is 8 Dec, I can't stay in my skin ;-)
12:33:41 <Cale> :)
12:34:18 <lispy> Cale: i think what i'm struggling with is that Haskell is very hard to optimize
12:34:49 <lispy> i can write efficient code in most strict languages after playing with them for a bit.  I can't sayt hat about haskell
12:34:53 <Cale> lispy: it's really not that bad once you get used to the way that evaluation proceeds. You have to think in terms of demand.
12:35:21 <xerox> Nicely posed.
12:35:36 <musasabi> Optimizing Haskell is profiling-driven
12:35:46 <Cale> Most of the *really* inefficient code I've seen was because the wrong data structures were being used, and the algorithms were asymptotically poor.
12:35:52 <Frederick> yo SamB, ski_ , astrolabe 
12:36:01 <Cale> like [(a,b)] used instead of Map a b
12:36:07 <lispy> musasabi: i've used profilers in several languages, and ghc's profiler didin't help me much if any the last time used it
12:36:26 <xerox> And hey, the whipuptitude helps so much in changing those parts on the fly.
12:36:34 <Cale> yeah
12:36:38 <eNTi> uh... another one: how do i cast from Float->Int?
12:36:48 <xerox> To not talk about how Monads work in this play.
12:36:49 <Cale> eNTi: floor, round, ceiling?
12:36:52 <lispy> eNTi: there are several ways, try hoogle
12:36:58 <lispy> @hoogle Float -> Int
12:37:00 <ScannedInAvian> An error occured.
12:37:03 <lispy> hmm...
12:37:05 <Cale> oops :)
12:37:06 <lispy> where is hoogle?
12:37:11 <eNTi> hoogle.
12:37:13 <Cale> the real lambdabot has gone missing
12:37:20 <xerox> Oh, we got an emergency instance of lambdabot!
12:37:26 <SamB> lispy: GHCs profiler works better if you label cost centers
12:37:34 <phys_rules> lambdabot went for a holiday =)
12:37:47 <xerox> > (floor 1.6, round 1.6, ceiling 1.6)
12:37:50 <ScannedInAvian> (1,2,2)
12:37:52 <SamB> phys_rules: I didn't think they had thanksgiving in .au
12:38:02 <lispy> SamB: hmm...maybe that's my problem, but I also think the slow down was in code that was linked in, but which didn't have profiling info
12:38:04 <SamB> not that lambdabot is there anymore
12:38:04 <Cale> > round 1.5
12:38:07 <ScannedInAvian> 2
12:38:11 <Cale> > round 2.5
12:38:13 <ScannedInAvian> 2
12:38:16 <Cale> good :)
12:38:24 <SamB> lispy: such as?
12:38:31 <xerox> > (ceiling 2.5, ceiling 1.5)
12:38:33 <ScannedInAvian> (3,2)
12:38:37 <lispy> SamB: HOpenGL
12:38:40 <xerox> I see.
12:38:42 * SamB didn't know that was allowed
12:38:51 <SamB> lispy: in the C stuff or the Haskell stuff?
12:38:52 <eNTi> xerox: the point is to "create" a floor function, not to use it :)
12:39:11 <xerox> eNTi: Gotcha.
12:39:19 <astrolabe> Hi Frederick
12:39:29 <xerox> > floor -2.3
12:39:29 <SamB> > round [1.5..]
12:39:31 <ScannedInAvian>  add an instance declaration for (Fractional (a -> b))
12:39:31 <ScannedInAvian>  add an instance declaration for (RealFrac [a])
12:39:31 <ScannedInAvian>   In the definition of `xxxx': xxxx = round ([1.5 .. ])
12:39:31 <ScannedInAvian>   In the definition of `v':
12:39:32 <xerox> > floor (-2.3)
12:39:35 <ScannedInAvian> -3
12:39:43 <SamB> > round ([1.5..] :: Double)
12:39:45 <ScannedInAvian> Couldn't match `Double' against `[a]'
12:39:47 <lispy> SamB: well, i couldn't tell.  My code was spending very little time compared to the wall clock, but my program was slow.  Basically, I couldn't figure out what to change
12:39:50 <xerox> It complicates the thing a bit.
12:39:51 <eNTi> nm. i'll find it out on myself :)
12:39:52 <SamB> > map round ([1.5..] :: Double)
12:39:53 <Frederick> hi astrolabe :)
12:39:54 <ScannedInAvian> Couldn't match `Double' against `[a]'
12:40:01 <SamB> > map round [1.5..]
12:40:03 <ScannedInAvian> [2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28,
12:40:03 <ScannedInAvian> 28,30,30,32,32,34,34,36,36,38,38,40,40,42,42,44,44,46,46,48,48,50,50,52,
12:40:03 <ScannedInAvian> 52,54,54,56,56,58,58,60,60,62,62,64,64,66,66,68,68,70,70,72,72,74,74,76,
12:40:03 <ScannedInAvian> 76,78,78,80,80,82,82,84,84,86,86,88,88,90,90,92,92,94,94,96,96,98,98,100,
12:40:03 <ScannedInAvian> 100,102,102,104,104,106,106,108,108,110,110,112,112,114,114,116,116,118,
12:40:05 <ScannedInAvian> [24 @more lines]
12:40:20 * Frederick ducks so he isnt hitten by the numbers
12:40:36 <SamB> lispy: well, is that usually easy with GL?
12:40:38 <Cale> > all even (map round [1.5..1000.5])
12:40:41 <ScannedInAvian> True
12:40:45 <xerox> heh
12:40:56 <Frederick> astrolabe, yesterday you said you had some ideas about solving my problem, but it was late and I had to leave im here to listen now
12:41:19 * SamB didn't think round-to-even was supposed to be taken to this sort of extreme
12:41:29 <lispy> SamB: at the time i knew nothing about GL, I could probably optimize it a bit based on what i now know.  But, the impression I got was that there was a lot of time that ghc wasn't keeping track of
12:41:30 <SamB> > all even (map round [1.5..])
12:41:35 <ScannedInAvian> Terminated
12:41:36 <astrolabe> Frederick: Want to go to #haskell-overflow, it's a bit busy in here.
12:41:47 <Cale> SamB: we're only rounding things which are on the boundary
12:41:59 <Frederick> astrolabe, sure Im opening the window
12:42:09 <Cale> > all even (map round [1,1.1..100])
12:42:12 <ScannedInAvian> False
12:42:23 <lispy> SamB: perhaps it was just a weird experience.
12:42:35 <SamB> lispy: unless you have GL built for profiling (and even then...), you don't get much help even in C, do you?
12:43:01 <lispy> i've yet to use a C profiler :)
12:43:13 <lispy> mostly i've used profilers with lisp
12:43:22 <SamB> ah
12:43:23 <lispy> VB and a few other random langs
12:43:40 * SamB didn't know VB had a profiler
12:43:42 <lispy> sbcl has the best profiler i've used thus far.
12:43:49 <lispy> SamB: well...i had to write it
12:43:55 <SamB> okay...
12:43:55 <Cale> I haven't used GHC's profiler too much, but it seems sane enough.
12:44:00 <SamB> how do you do that?
12:44:07 <Cale> Not sure about FFI interactions
12:44:24 <lispy> SamB: it was all done by hand.  Each place to profile had to be chosen carefully
12:44:43 <lispy> and it was only measure execution time
12:44:49 <SamB> lispy: GHC's cost centers are probably somewhat similar
12:45:14 <SamB> in that you probably should choose where to put them carefully
12:45:57 <lispy> IIRC it doesn't say how much time it spent garbage collecting.
12:45:58 <Cale> With GHC, you add cost centre annotations by hand to whatever you're interested in, and it gives you a report on how much time, memory, etc. was spent on the evaluation of that expression.
12:46:32 <SamB> ah, well, no...
12:46:33 <lispy> i suspected my program was creating excess garbage at bad times
12:46:56 <SamB> well, you can look at the allocation stats though
12:47:15 <lispy> i wonder if i still have the output
12:47:27 <eNTi> ok i give up (already). xerox built me a wonderful function, but that's just not Float -> Int, it's Float -> Float, but that's not what i want. i want to give the function a Float value and return me an Int, as floor should do actually. any ideas?
12:47:51 <SamB> you can also set GHC to ring the bell on every GC
12:48:02 <lispy> SamB: ring the bell?
12:48:15 <Cale> eNTi: xerox's function seems to have a more general type, are you sure?
12:48:17 <SamB> yes, the bell
12:48:25 <lispy> like the ^G?
12:48:30 <SamB> isn't your terminal equiped with a bell?
12:48:30 <jlouis> yeah
12:50:07 <eNTi> Cale: i tried it out. it's Float -> Float, not Float -> Int.
12:50:25 <xerox> Was the float thing resolved?
12:51:23 <Cale> ah
12:51:29 <Cale> yeah
12:51:37 <Cale> hehe
12:52:29 <Cale> you need to add some fromIntegrals
12:52:46 <eNTi> xerox: ? sorry to bugger you again. the function you showed me is Float->Float, not Float->Int any longer...
12:53:01 <Cale> floor x = floor' x 0
12:53:02 <Cale>     where floor' x n | n' <= x && x < (n'+1) = n
12:53:02 <Cale>                      | otherwise = floor' x (n+1)
12:53:02 <Cale>                 where n' = fromIntegral n
12:53:04 <xerox> ..as Cale said.
12:53:08 <phys_rules> http://haskell.org/hoogle/?q=Float+-%3E+Int
12:53:13 <xerox> Or even...
12:53:32 <eNTi> mhm. ok. thx
12:53:45 <phys_rules> hoogle rocks :)
12:53:52 <Cale> eNTi: the comparison between x and n forces them to be the same type
12:53:57 <eNTi> sorry, got an exam tomorrow and just can't get the basics yet :9
12:54:09 <eNTi> Cale: yes. i can see that now :)
12:54:10 <xerox> Hmpf.  That's right.
12:54:15 <Cale> it wasn't really Float -> Float, but (Num a, Ord a) => a -> a
12:54:38 <Cale> now it's (Integral a, Num b, Ord b) => b -> a
12:54:49 <Cale> @type floor
12:54:51 <ScannedInAvian> forall a b. (RealFrac a, Integral b) => a -> b
12:54:58 <xerox> Good.
12:55:09 <Cale> not quite the same, but close :)
12:55:36 <Cale> this one we have is a bit more general
12:55:57 <xerox> It would work on pi :-)
12:56:10 <Cale> but also slower, and doesn't work for negative numbers
12:56:34 <_Codex> I have to say, number conversions in haskell is always a little magic.
12:56:42 <xerox> > floor (-2.5)
12:56:42 <Cale> mmmm... floor pi
12:56:44 <ScannedInAvian> -3
12:56:49 <xerox> > floor pi
12:56:51 <ScannedInAvian> 3
12:56:53 <xerox> Uh.
12:57:05 <xerox> @type pi
12:57:06 <ScannedInAvian> forall a. (Floating a) => a
12:57:14 <xerox> Okay.
12:57:33 <SamB> > pi :: Complex
12:57:35 <ScannedInAvian>  Not in scope: type constructor or class `Complex'
12:57:47 <SamB> > pi :: Complex.Complex Double
12:57:48 <ScannedInAvian>  Not in scope: type constructor or class `Complex.Complex'
12:57:50 <xerox> Hm?
12:57:56 <araujo> The hawiki frontpage can't be edited?
12:58:05 <xerox> araujo: I think so
12:58:17 <SamB> think it can or think it can't?
12:58:30 <Cale> > pi :: Data.Complex.Complex Double
12:58:32 <ScannedInAvian>  Not in scope: type constructor or class `Data.Complex.Complex'
12:58:33 <xerox> 'so' stands for what he said
12:58:41 <Cale> araujo: It can
12:58:48 <Cale> araujo: log in first
12:59:00 <araujo> Cale, aha, let me see
12:59:03 <SamB> that always helps ;-)
12:59:36 <Cale> xerox: did I mention I've started work on a binding to EFL with c2hs :)
13:00:01 <Cale> Enlightenment Foundation Libraries
13:00:11 <araujo> aagh! 
13:00:15 <araujo> forgot the pass
13:00:22 <araujo> Can anyone re-stat it for me ?
13:00:30 <araujo> reset*
13:00:32 <Cale> shapr could
13:00:42 <adept> SamB: speaking of wire protocol ...
13:01:06 * araujo throws some S.O.S lambdas at shapr 
13:01:20 <Cale> @get-shapr
13:01:22 <ScannedInAvian> shapr!!
13:01:43 <xerox> Cale: yeah, I spotted you fighting imlibs :-)
13:01:47 <Cale> :)
13:01:53 <adept> SamB: in order to initiate p2p, client only has to send handshake packet, and that's it? According to specs, it is, but does not elicit any reaction for me ...
13:02:08 <Cale> xerox: It's going okay now -- the libraries are huge though
13:02:10 <xerox> Cale: what do the EFL give ?
13:02:19 <SamB> adept: what are you doing?
13:02:28 <SamB> adept: do you have some code I can look at?
13:04:22 <Cale> xerox: A lot of stuff, ranging from optimised graphics primitives (Imlib2), to a nice canvas library (evas), a bunch of tools for writing general X programs (ecore), a themable gui component abstraction (edje), a widget set (ewl), and some other stuff
13:04:46 <Cale> It's pretty nicely designed too, as far as libraries in C go.
13:04:57 <Cale> and it's all really really fast
13:05:25 <lispy> SamB, Cale: this is what i get from profiling one of my example programs which is much faster in C
13:05:27 <lispy> http://codersbase.com/index.php/Sandbox
13:05:32 <Cale> http://enlightenment.sourceforge.net/Libraries/Overview/
13:05:35 <xerox> How is Enlightenment needed in using those libs?
13:05:57 <jlouis> ok, i'll log off. Have fun!
13:05:59 <Cale> these are the libs which they've spent 5 years writing in preparation for the next enlightenment
13:06:05 <xerox> Bye jlouis!
13:06:29 <Cale> lispy: add cost centres to drawScene
13:06:44 <adept> SamB: i have code, but how to send it to you?
13:06:46 <Cale> (or is that a library call?)
13:06:56 <adept> SamB: i am not that much darcs-literate
13:07:08 <SamB> adept: well, I prefer to pull. do you have an httpd handy?
13:07:12 <xerox> Five years, that's thought.
13:07:31 <lispy> Cale: i'll try it
13:07:53 <adept> SamB: not really. And I am behind three NAT, even if they are controlled by me :)
13:08:10 <adept> SamB: however ....
13:08:15 <Cale> "Edje provides a revolutionary method of absstacting every aspect of your interface from the application itself. By passing signals between the interface and the application all communication is done in an interface neutral way. No longer are "themes" simple changes of pixmaps over a fixed area."
13:08:25 <SamB> adept: you don't have an httpd on the outermost router?
13:08:36 <xerox> Cale: tuomov's heaven?
13:08:38 <adept> i have
13:08:40 <tuomov> unfortunately it's still pixel-based crap
13:08:47 <Cale> xerox: I'm not sure, I haven't quite used it
13:08:48 <tuomov> s/pixel/widget7
13:08:49 <xerox> Aww.
13:08:56 <adept> SamB: how I can made a patch in the file?
13:09:04 <tuomov> there's no true abstraction, just the same old widget shit in a new box
13:09:11 <SamB> adept: well, you can rsync a copy of your repository up to there
13:09:19 <Cale> tuomov: are you sure?
13:09:28 <SamB> adept: thats generally easiest
13:09:31 <Cale> The demos that I saw looked quite a bit more abstract than that
13:09:34 <adept> SamB: nice :)
13:09:34 <tuomov> to the extent there was information available when I was pointed to it some months ago
13:09:49 <adept> SamB: will try my code once again and do that.
13:09:49 <tuomov> i.e. you still create buttons and so on
13:10:02 <tuomov> you may not control their position, but you create buttons and checkboxes and menus
13:10:03 <Cale> tuomov: that's all in the edje file though
13:10:12 <lispy> oh dear...adding cost centers messed up the layout
13:10:17 <lispy> now it doesn't comile...
13:10:24 <Cale> and you can control their position
13:10:42 <adept> SamB: ah. I forgot 8 reserved bytes. Just a moment ...
13:10:45 <xerox> edje is like... .glade?
13:10:46 <Cale> separately from behaviour
13:11:08 <tuomov> xerox: seemed similar
13:11:14 <SamB> lispy: oh?
13:11:36 <SamB> isn't there a function you can use for that that won't mess up layout?
13:11:46 <lispy> yeah, i just did a darcs revert, but it compiled before i inserted them
13:13:00 <Cale> xerox: somewhat, though more programmable on the frontend side
13:13:29 <lispy> adding a comment shouldn't throw off layout
13:13:40 <SamB> um
13:13:52 <SamB> do they count as lexemes?
13:14:03 <Cale> Edjes can contain code to manipulate aspects of the interface
13:14:46 <Cale> and are separate from the app
13:14:58 <xerox> lispy: it does not in my experience.
13:15:55 <tuomov> edje seems to be a layout and event lib, nothing more
13:16:09 <tuomov> i.e. still very low-level
13:16:30 <lispy> hmm....i removed the very first cost-center annotation and it compiles now
13:16:36 <tuomov> of course there still doesn't seem to be any proper documentation available
13:16:36 <lispy> something weird about that one
13:16:48 <Cale> http://enlightenment.sourceforge.net/doxy/edje/index.html -- click globals
13:17:17 <tuomov> oh, those links were very well hidden
13:18:33 <Cale> hehe, it seems the documentation still needs work
13:18:37 <tuomov> there's talk of font sizes and drag steps and stuff
13:18:44 <lispy> hmm..that helps a little, the problem is where i thought it might be
13:18:46 <tuomov> so it surely isn't very abstract
13:18:51 <lispy> now to add more cost-centers
13:19:17 <SamB> @index _ccs_
13:19:18 <ScannedInAvian> bzzt
13:19:23 <Cale> tuomov: I'm not exactly sure what that's for, as font sizes and such can be handled in the edje file itself
13:19:24 <adept> SamB: ah! it works :)
13:19:36 <SamB> adept: it works?
13:19:48 <Cale> I think there's a lot of stuff exposed there which needn't be
13:20:00 <adept> SamB: yes :)
13:20:27 <tuomov> not even the main library should know of such, it should be up to the UI backend
13:20:45 <tuomov> it must be possible to generate UIs for text terminals, simple web forms, whatever
13:21:02 <SamB> tuomov: are you one of those CLIM people?
13:21:06 <tuomov> as long as specific display capabilities are not needed by the application
13:21:08 <tuomov> clim?
13:21:20 <SamB> yes, CLIM
13:21:41 <tuomov> what's that?
13:23:51 <tuomov> The edje README says more clearly "A graphical layout and animation library for animated resizable, compressed and
13:23:54 <tuomov> scalable themes."
13:25:55 <Cale> but you could use it such that all you ever do is send signals to whichever theme and get signals back
13:26:46 <lispy> SamB, Cale: given the first chunk of code and the profiling info what would you recommend? http://codersbase.com/index.php/Sandbox
13:27:35 <tuomov> the problem is that the code seems to still be subordinate to the themes
13:27:57 <tuomov> the code doesn't expose data and callbacks that the themes can use, but themes expose stuff that the code can use
13:28:10 <tuomov> or so it seems to be
13:28:14 <Cale> tuomov: no, it's really intended to be used the other way
13:28:43 <tuomov> and there's actually _code in the .edc files_, wtf?
13:29:00 <Cale> yeah, for manipulating the interface in various ways
13:29:03 <SamB> lispy: what type is points?
13:29:07 <Cale> animating components and whatnot
13:29:16 <lispy> SamB: hang on
13:29:28 <Cale> lispy: hmm
13:29:42 <lispy> SamB: points <- newListArray ((0,0,0), (44,44,2)) elems :: IO Points
13:30:09 <SamB> lisppaste2: what is Points?
13:30:12 <SamB> er, lispy
13:30:14 <lispy> import Data.Array.IO ( readArray, IOUArray, newListArray )
13:30:58 <lispy> SamB: http://projects.codersbase.com/repos/nehe-tuts/lesson11.hs
13:31:12 <lispy> type Points = IOUArray (Int, Int, Int) Float
13:31:35 <lispy> SamB: maybe something in there will be helpful ;)
13:32:04 <SamB> hmm.
13:32:26 <SamB> you could try using the unsafe* methods in MArray...
13:32:39 <lispy> my reason for the IOUArray is that it is meant to be raw like a C array (since htis is code ported over from C, I figured i should respect C assumptions)
13:33:12 <Cale> hmm, it does look like you consume the whole array there
13:34:00 <lispy> yeah, in the C version the array was update in the loop everytime
13:34:16 <lispy> iirc this version just reads the array (it used to update it but that was even slower)
13:34:55 <maniacH> can someone give me example of using foldr1 ?
13:34:58 <lispy> iirc that's what offset is all about
13:35:17 <Cale> > foldr1 (+) [1,2,3]
13:35:19 <ScannedInAvian> 6
13:35:57 <Cale> > foldr1 (-) [1,2,3]
13:35:59 <SamB> or skip the array, since you have to unpack it totally to apply Vertex3 to the points anyways...
13:36:00 <ScannedInAvian> 2
13:36:16 <lispy> ah yeah it is.  It used to be that the array elements were shifted.  I changed it so thta the array indexing shifted since it required less data movement
13:36:41 <SamB> or wait, no.
13:36:42 <Cale> yeah, I wonder if it would help to just create the Vertex3's that you'll need in the first place
13:37:01 <SamB> what is x' for
13:37:28 <lispy> SamB: that's related to the shifting offset.
13:37:40 <Cale> use a boxed array of Vertex3's
13:37:43 <lispy> the array is meant to be precomputed from a sine curve
13:37:57 <Cale> or pass a function
13:38:25 <maniacH> can someone give me example of using scanl ?
13:38:30 <Cale> well, I suppose an array ought to be better
13:38:52 <SamB> Cale: well, maybe not in Haskell
13:39:38 <SamB> if its a sine curve it might be faster to just calculate it on the spot...
13:39:51 <Cale> yeah, it's worth trying
13:40:13 <Cale> > scanl (++) [] ["scanl", " builds", " up", " lists"]
13:40:15 <ScannedInAvian> ["","scanl","scanl builds","scanl builds up","scanl builds up lists"]
13:40:39 <Cale> > scanl (+) 0 [1..10]
13:40:42 <ScannedInAvian> [0,1,3,6,10,15,21,28,36,45,55]
13:41:43 <xerox> :-)
13:42:11 <lispy> hmm...i guess i could replace it with a function, but what i don't like about that solution is that it is not very general.  I guess I'd like something that shows arrays can be used without slowdown.
13:42:38 <Cale> I think the slowdown here is that you're rebuilding the Vertex3's every time
13:42:39 <TheHunter> ski, http://quux.org/devel/missingh/html/MissingH-List.html#v%3AwholeMap
13:43:06 <lispy> Cale: so another approach might be to change the HOpenGL api?
13:43:25 <SamB> can you get detailed statistics regarding the constructors allocated for?
13:43:43 <Cale> lispy: well, possibly, but I think just changing your use of arrays might be better
13:43:50 <Cale> store an array of Vertex3's
13:44:02 <Cale> so you don't have to rebuild them 220 times
13:44:54 <SamB> Cale: can that be done?
13:44:55 <Cale> vertex1 is getting entered 425920 times
13:45:16 <Cale> does it really need to be recomputed that many times?
13:45:35 <lispy> Cale: i think that might work here, but it's not a solution i'm happy about :)
13:45:43 <SamB> whats this? Graphics.Rendering.OpenGL.GL.VertexArrays?
13:45:43 <Cale> (is it different every time?)
13:46:06 <astrolabe> @type element
13:46:07 <ScannedInAvian> Not in scope: `element'
13:46:13 <Cale> @type elem
13:46:14 <ScannedInAvian> forall a. (Eq a) => a -> [a] -> Bool
13:46:18 <astrolabe> thanks
13:46:32 <lispy> Cale: not in my program, by factoring out the offset i've already shown that it's okay to precomput and then twiddle the indexing.  but what if the array was changing?
13:47:01 <Cale> lispy: it'd still be better to keep the array closer to the form where you're actually going to make the calls
13:47:08 <lispy> SamB: I think so, the module import are explicit
13:47:14 <Cale> think of arrays in Haskell as caches of precomputed computations
13:47:37 <Cale> you don't really want to have to do extra work after indexing the array
13:47:40 <lispy> SamB: but i'm not sure exactly what you mean by "this"
13:48:01 <SamB> lispy: I was wondering if it was something that would be useful
13:48:36 <lispy> SamB: I think vertexarrays are an opengl concept...i remember learning about them recently.  They may help
13:49:17 <Cale> lispy: I might be wrong, but I think that a boxed array of Vertex3's would be more efficient given your usage pattern here than an unboxed array of things which just have to be reboxed every time you need them
13:49:36 <lispy> Cale: one thing that I've thought for a while could help the HOpenGL api is if vertex came in a vertex3 variant that was vertex3 :: RealFrac a => a -> a -> a -> IO ()
13:49:59 <Cale> lispy: yes, that would help, if it was really an interface into the low level libraries
13:49:59 <SamB> lispy: that wouldn't even need to be in the API
13:50:04 <SamB> it could just be a RULE
13:50:07 <Cale> yeah
13:50:11 <lispy> a rule?
13:50:16 <Cale> making that a RULE would be a good idea
13:50:25 <dons> morning haskell hackers
13:50:26 <Cale> An optimising rewrite rule
13:50:36 <astrolabe> evening dons :)
13:50:55 <dons> is SamB promoting RULEs again? ;)
13:51:00 <lispy> Cale: well, in opengl the function is void vertex3f(float, float, float)
13:51:01 <astrolabe> And if you are trying to convince me that the world isn't flat, it's not working.
13:51:04 <Cale> GHC lets you write RULE pragmas which (somewhat evilly) let code get rewritten at compile time.
13:51:10 <lispy> Cale: and there is one for doubles as well
13:51:17 <Cale> lispy: yeah
13:51:19 <dons> it's like TH on a diet
13:51:42 <Cale> yeah, it's much more invisible than TH
13:52:43 <lispy> well, shoot i have to work on other stuff
13:52:45 <lispy> thanks for the help
13:52:50 <Cale> no problem
13:53:07 <Cale> try the unboxed array of Vertex3's at some point and get back to me
13:53:13 <Cale> I'm interested in the result :)
13:53:14 <lispy> okay
13:53:19 <lispy> i bet that will be faster
13:53:42 <lispy> but i'm still very much interested in getting rid of the extra constructors
13:54:03 <Cale> yeah, you might actually suggest the addition of a RULE there
13:54:04 <lispy> vertex is often called in a very performance critical loop in opengl programs
13:54:21 <lispy> well, i don't even like having to use Vertex3
13:54:27 <lispy> i'd rather have all those functions be curried
13:55:01 <SamB> like TH on a diet and automated
13:55:01 <Cale> maybe email Sven?
13:55:57 <lispy> who is Sven
13:56:03 <lispy> the HopenGL author?
13:56:10 <dons> SamB, what was that nice -ddump flag for rewrite rules?/
13:56:16 <dons> -ddump-rules ?
13:56:22 <Cale> I think the reason that TH isn't getting used much is that if a library uses it, it can either only use it to generate its own code (which is boring), or expose the fact that it's using TH in a way which forces the user to know how TH works, which is annoying.
13:56:46 <SamB> dons: that one is supposed to be nice, but didn't seem to work at all
13:57:02 <SamB> dons: -ddump-inlinings is the one that I got results from, iirc
13:57:07 <dons> ah, right.
13:57:18 <Cale> otoh, if it could be made invisible, you could do some really evil stuff with TH
13:57:20 <basti_> dumplings?
13:57:25 <Cale> heheh
13:57:50 * SamB comes up with evil plots involving TH in RULES
13:58:47 <dons> hehe. I posed this to SPJ a few years back
13:59:08 <dons> it's doable, with only a few mods to the compiler, iirc
13:59:20 <dons> whether you'd want to... well..
13:59:34 <Cale> making TH invisible? Or TH in RULES?
14:00:08 <Cale> I suppose they're moderately equivalent
14:01:23 <Cale> I think TH perhaps seems to add a lot of complexity to the compiler for what it does, though I'm not very familiar with GHC's code, so I could be wrong.
14:03:51 <dons> SamB, it's nice watch all those pack/packAddress rules firing :)
14:13:31 <lispy> being in charge of 6 other authors is a pain in the butt
14:15:34 <lispy> hey, china is going to put a man on the moon.
14:18:17 <basti_> cool
14:18:22 <dons> sure, they've been talking about it for a few years now. so watch out, they'll take your flag down, lispy ;)
14:18:26 <basti_> much potential for action -> #blah
14:18:48 <psykotic> lispy: do they have an official reason, or is it just one-upmanship? :)
14:19:14 <dons> they want to look for moon-cheese?
14:19:29 <lispy> i only read the headline and that they are going to do it "in the next 15 years" so that will put them what?  50 years behind?
14:20:28 <psykotic> they might be doing it just as a catalyst for research and such. kind of like how a war gets the economy going :)
14:20:31 <dons> wow, gnome-terminal doesn't handle ncurses apps very well
14:21:08 <lispy> dons: you might be able to help it out with your TERM setting
14:21:26 <dons> ah, ok. good idea.
14:22:16 <rt> well, it's not like we can really go back to the moon any faster than they can, even though we have done it once.
14:22:28 <rt> or, before, I should say.
14:22:31 <dons> ah, that's nicer lispy, using xterm-xfree86
14:22:39 <maniacH> what is 'mod' ?
14:22:44 * basti_ invites everyone to discuss chinese moon landing to #haskell-blah
14:22:46 <dons> @type mod
14:22:47 <SamB> @google SpikeSolution
14:22:48 <ScannedInAvian> forall a. (Integral a) => a -> a -> a
14:22:48 <ScannedInAvian> Module "search" produced error: getHostByName: does not exist (no such
14:22:48 <ScannedInAvian> host entry)
14:22:59 <SamB> dons: what happened to lambdabot?
14:23:10 <dons> oh. hmm.
14:23:32 <SamB> shapr: why does @google not work?
14:23:49 <dons> looks like a big disconnect last night
14:23:50 <sethk> google's not registered  :)
14:24:35 <dons> hehe, maybe ScannedInAvian's proxy settings are wrong.
14:24:42 <dons> ScannedInAvian: @quit
14:24:53 <dons> @yow
14:24:54 <lambdabot> And furthermore, my bowling average is unimpeachable!!!
14:26:40 <phys_rules> yay, lambdabot =)
14:34:44 <shapr> yay lambdabot!
14:35:56 <shapr> hiya conal, how's code?
14:36:56 <conal> hi shapr.  code is great!  i'm back to work and loving it.
14:37:03 <shapr> yay!
14:37:07 <conal> :)
14:37:23 <conal> i've been working on a new version of Pan, to run in Java
14:38:05 <conal> the compiler will run on all OSes that run haskell, and the applets in browsers that support java 1.5
14:38:15 <conal> so a lot more accessible than in the past.
14:38:35 <shapr> cool
14:38:50 <shapr> Will you be using the java bytecode generator in ghc?
14:39:15 <conal> i haven't seen one.
14:39:21 <conal> would be interested.
14:39:27 <dons> surely not, shapr, it's really bitrotted
14:39:33 <conal> right now i'm generating java source.  
14:39:34 <Lemmih> Probably because there isn't one.
14:39:37 <dons> and never worked in the first place.
14:39:41 <xerox> What is Pan?  The newsreader?
14:40:08 <SamB> xerox: no, the image generation thingamajig
14:40:13 <conal> no, my image language compiler: see http://conal.net/Pan/Gallery
14:40:22 <SamB> the one with the really cool EDSL?
14:40:30 <xerox> Woot.
14:40:37 <SamB> and really neat pictures on the site?
14:40:48 <SamB> but a god-awful license and windows-only code?
14:40:49 <conal> yep - that one. :)
14:41:19 <dons> heh
14:41:27 <shapr> Pan made awesome pix.
14:41:48 <conal> thx!  i love playing with it.
14:42:06 <conal> and i wished i'd made it more accessible to other folks.  soon it will be.
14:42:26 <SamB> conal: oh, are you the original creator?
14:42:34 <conal> yep
14:42:45 <SamB> how did you get stuck with that license?
14:43:21 <conal> SamB: the license that says free to use, but not commercially and must give mods to Microsoft?
14:43:36 <SamB> I suppose thats what it said
14:44:04 <SamB> all I remember is it didn't qualify as "free" or OSI compliant
14:44:15 <conal> that's right. i was lucky to get it released as source code at all.  the MS lawyers hate that. 
14:44:23 <SamB> ah, yeah.
14:45:13 <SamB> I suppose they only let you do that because it would have been useless without source?
14:45:26 <conal> my plan is to keep replacing parts until it's no longer a modification but a different implementation.  i don't know exactly when it will qualify as new.
14:46:35 <conal> SamB: i implied as such by  describing Haskell as an "interpreted language".  a half truth.  it was really important to me to get the source release.
14:46:45 <conal> because i was leaving MS.
14:47:13 <conal> i did the same with Vertigo (http://conal.net/Vertigo)
14:47:14 <SamB> conal: well, its true enough as far as it describes the way you would generally use something like Pan
14:47:41 <adept> bb
14:48:21 <conal> SamB: it works fine as a compiled library, though, for ghc users.
14:48:29 <SamB> and I guess its easier to just say that than it is to explain that GHC doesn't have an ABI for its library
14:48:52 <maniacH> how can i find minimal and maximal element in list ?
14:48:57 <maniacH> maximum
14:49:02 <SamB> @type maximum
14:49:02 <maniacH> biggest ans smallest
14:49:03 <lambdabot> forall a. (Ord a) => [a] -> a
14:49:07 <SamB> @type minimum
14:49:08 <lambdabot> forall a. (Ord a) => [a] -> a
14:49:09 <Cale> > minimum [12,3,7,2,15]
14:49:11 <lambdabot> 2
14:49:14 <maniacH> ok :)
14:49:15 <Cale> > maximum [12,3,7,2,15]
14:49:16 <lambdabot> 15
14:49:20 <maniacH> thnx
14:49:26 <conal> anyway, one funny thing about the MS license is that it says mods have to go back to MS but doesn't say how or when.  sounds unenforceable.
14:49:35 <Cale> heh
14:49:39 <SamB> conal: yes!
14:49:41 <SamB> thats true
14:49:48 <Cale> "I added a clause to my will"
14:49:58 <SamB> they must not have been wearing their lawyer hats when they came up with that
14:50:43 <conal> so my current plan is to keep modifying it until it's no longer a modification.  before that point, i can say that i intent to eventually give the mods.  after that point i no longer have to.  
14:51:03 <Cale> heh
14:51:06 <conal> all moot, though, because i don't think anyone at MS would care.
14:51:28 <SamB> conal: anyhow, you are going to publish this under a BSD-style license on the web, right?
14:51:52 <maniacH> how can i replace somethin in list or in string ? how can i get substring ?
14:52:16 * SamB would probably have interpreted that as "send patches to the author and let him figure out how to get them to MS"
14:52:34 <conal> SamB: i'd like input on the license decision.  whatever makes it most accessible to people to use and help with.
14:52:59 <SamB> BSD is definately accessible
14:53:33 <SamB> I know shapr has changed his opinion somewhere around... was it the 21st?
14:53:36 <conal> is there a description somewhere of BSD vs LGPL, etc?
14:53:49 <SamB> LGPL is more complicated and harder to understand
14:53:51 <Cale> maniacH: hmm, could you be a little more specific?
14:54:13 <SamB> and makes more restrictions
14:54:21 <Cale> maniacH: you don't really replace things in a string, you create a new string, using information about the old one
14:54:34 <SamB> shapr: what was that blog entry?
14:55:00 <ChilliX> Moin
14:55:23 <conal> SamB & shapr: i see: http://www.scannedinavian.com/2005-11-23.html
14:55:49 <SamB> 23rd, I guess, then
14:56:07 <SamB> or not
14:56:25 <maniacH> isnt there some replace function, something like replace 'i' ai' "string" => "strang"
14:56:47 <Heffalump> conal: if you develop something by incrementally replacing parts of something else, I suspect that legally it'll all be a derived work
14:57:38 <Cale> no, at a certain point, it stops being a derived work
14:57:59 <rt> I think that's an increddibly shaky premise.
14:58:26 <conal> i would like to know where the line is.
14:58:54 <rt> the line typically can only be understood by taking someone to court and getting a ruling.
14:59:03 <SamB> Heffalump: haven't you heard of GNU?
14:59:11 <SamB> GNU's not unix, you know!
14:59:40 <Cale> > map (\x -> if x == 'i' then 'a' else x) "string"
14:59:41 <lambdabot> "strang"
15:00:49 <Heffalump> samb: that worked by replacing separate components that were just distributed by aggregation
15:01:00 <ChilliX> conal: I agree with rt that it'd be a risky business
15:02:08 <conal> i'm sure open to advice about how to (a) safely work around the MS license on Pan and (b) making an implementation that people can and want to use.
15:02:14 <Philippa_> Cale: got a citation for that, legally speaking?
15:02:23 <Philippa_> I sure wouldn't want to gamble on it
15:02:38 <maniacH> Cale, thanks
15:02:51 <SamB> you could try and parody it instead ;-)
15:03:06 <SamB> thats always okay
15:03:23 <Heffalump> conal: I suspect the only safe way is to start from scratch
15:03:39 <ChilliX> conal: Re (a) may not be your favourite, but re-implementation from scratch seems the right way
15:03:46 <SamB> Heffalump: what? you don't think a parody wouldwork?
15:04:01 <Heffalump> Keeping the same language would probably be ok, but you'd need a completely new implementation
15:04:12 <conal> Heffalump: and "without looking" at the original?  so it's not "derived"?  
15:04:18 <rt> besides, any program worth writing is worth rewriting. :-)
15:04:23 <Heffalump> samb: no. Parody is not an absolute exemption, and it isn't useful as way of getting round copyright
15:04:33 <Cale> I think LAME started out as a patch against the source of a closed source program
15:04:43 <rt> well, it's hard for you to make the claim that it's not derived, since you actually implemented it once.
15:04:47 <Heffalump> conal: I don't think that would matter too much. IANAL.
15:04:47 <ChilliX> conal: In your case, the not looking at the impl is probably not important, as you *know* the impl anyway
15:05:03 <ChilliX> conal: you can't claim clean room anyway
15:05:08 <SamB> look at the GNU guidelines, I guess
15:05:30 <Heffalump> SamB: in particular, since the final implementation would not be a parody, it'd be a complete waste of time
15:05:46 <SamB> Heffalump: what if it was in a comonad?
15:05:52 <SamB> woudln't that count as a parody?
15:05:56 <Heffalump> ok, yes :-)
15:06:09 <Heffalump> though I wish you luck explaining why to a judge ;-)
15:06:48 <rt> in general, I've found the book "Who owns what is inside you head?" to be useful for these kind of employment contract/licensing/intellectual property/worker rights sort of issues.
15:06:54 <SamB> well, how about having a bunch of 'skellers come to the hearing and burst into laughter?
15:07:05 <SamB> wouldn't that work pretty well?
15:07:12 <rt> err... "inside your head".
15:08:00 <Cale> Generally, I think that in cases where the entirety of the program is reimplemented, it can't be considered a derivative work anymore.
15:08:08 <Cale> If you're not sharing any code
15:08:20 <Cale> Sharing ideas is okay, so long as there are no patents
15:08:24 <sethk> Cale, if you write 100% of the code, that's a safe assertion
15:08:27 <Heffalump> M$ would have difficulty enforcing any non-compete agreement (a) given the length of time since Conal left and (b) the fact that they don't make money from PAN
15:08:34 <Heffalump> s/PAN/Pan/
15:08:40 <sethk> Cale, but, remember, a bedrock principle is that you cannot patent or copyright an _idea_
15:08:44 <rt> they might still be able to make a claim of trade secret violations.  Harder to make, but possible.
15:08:56 <sethk> Cale, you can copyright or patent an implementation, but _not_ the idea itself, at least in US law
15:09:09 <ChilliX> I think (b) is the key
15:09:10 * xerox patents the idea of having ideas
15:09:12 <Cale> sethk: you do patent ideas
15:09:15 <sethk> rt, that's true, trade secret is much more murky
15:09:20 <sethk> Cale, not officially, no.
15:09:27 <ChilliX> if its re-implemented, sure they could try to make a case, but I doubt, they'd bother
15:09:31 <conal> i'm glad there are no Pan patents
15:09:36 <SamB> how can they claim trade secret violations?
15:09:45 <rt> but given they published the source code under an openlicense, it would be difficult for them to really claim that anything about it was a secret.
15:09:48 <ChilliX> So, it seems safe enough
15:09:49 <sethk> SamB, they say "that's a trade secret"  :)
15:09:53 <SamB> they don't use Pan for anything, and they permited publication of the source
15:10:10 <Cale> sethk: you patent designs, and copyright implementations
15:10:13 <sethk> SamB, that just means they can't win.  Not that they can't claim
15:10:21 <sethk> Cale, designs, yes, but not ideas.
15:10:29 <rt> you are probably safe, you just have to be careful.  I was tangentially involved in an ugly trade secret case, and it got VERY ugly.
15:10:30 <SamB> if there were trade secrets in there, they should have thought of that before they let conal publish source
15:10:49 <Cale> well, I meant the same thing by "ideas" and "designs"
15:10:54 <sethk> Cale, you can patent the way a mousetrap works, but you can't stop someone else from building all devices that traps mice
15:10:59 <SamB> rt: was there anything the slightest bit secret involved?
15:11:03 <conal> no
15:11:04 <sethk> Cale, legally they are different concepts
15:11:07 <Cale> sethk: oh, for sure
15:11:21 <rt> yes.  
15:11:27 <Cale> there are limitations on how general the ideas can be
15:11:32 <Heffalump> I doubt M$ would sue Conal unless he was blatantly violating their license (e.g. redistributing the same source under the GPL or whatever). The key point is to make something that most other people will believe is unencumbered.
15:11:35 <rt> as it turns out, there was also basic theft involved.
15:11:40 <conal> SamB: (sorry about my "no".  i at first thought you were asking me about trade secrets.)
15:11:45 <Cale> but you don't actually have to even show that they can be implemented
15:11:46 <SamB> rt: nobody stole anything here!
15:11:51 <SamB> and nothing here is a secret!
15:12:06 <SamB> and unless MS steals something, there won't be any stealing.
15:12:07 <sethk> Heffalump, microsoft has been known to do frivilous legal things just to scare people
15:12:10 <Cale> (though it's stupid to patent things which can't be implemented)
15:12:33 <sethk> Cale, actually, it is much easier to get a patent like that.  Less competition.  :)
15:12:36 <rt> sigh.  I understand that.  But I think that the idea that a motivated former employer couldn't make you spend lots of time with lawyers if they wanted to is absurd.
15:12:43 <Cale> sethk: hehe
15:12:44 <SamB> Cale: but that saves the time it takes to figure out whether it can be done or not
15:13:05 <Cale> SamB: but there's a limited amount of time before your patent runs out
15:13:23 <Heffalump> sethk: yes, but this is too small
15:13:44 <sethk> Heffalump, probably yes, unless one of their lawyers had a fight with his wife or something
15:18:41 <conal> on a different topic, i became a grandfather this morning.  Pictures: http://photobucket.com/albums/d166/ConalElliott/Audrey%20Michelle%20Elliott-Heye
15:18:52 <conal> i'm thrilled!
15:19:14 <ChilliX> congrats!
15:19:21 <rt> wow.  very cool.   congrats!
15:20:02 <xerox> Congratulations, conal :-)
15:21:58 <conal> thanks all!  the mom is my daughter Charlotte (my #3 of 4), who appeared in many of my fran examples (much younger), including http://conal.net/fran/patOrbitsCharlotte.gif and in http://conal.net/fran/tutorial.htm.  
15:24:49 <xerox> conal: haha, that thing seem so much funny.
15:24:55 <xerox> Anyway, goodnight!
15:24:59 <Cale> 'night
15:25:31 * SamB expects megacorps would be more hesitant to take people to court if they could come up with prior art 99% of the time...
15:25:54 <conal> goodnight xerox
15:26:06 <Cale> and congrats conal :)
15:26:38 <conal> :)
15:41:42 <Frederick> SamB, can you give a check in haskell overflow please?
16:00:12 <Heffalump> conal: congratulations :-)
16:04:37 <phys_rules> conal: congrats as well ;)
16:22:53 <Frederick> anyone alive?
16:24:17 <Lemmih> More or less.
16:25:42 <Frederick> :(
16:30:15 <conal> heffalump & phys_rules: thanks for the congrats.
16:41:53 <ricebowl> can anyone help me with the ST monad? I'm really lost.
16:42:17 <lispy> conal: hi and congrats
16:42:31 <lispy> conal: guess what
16:42:47 <lispy> conal: i'm going to start working on an animation DSL
16:42:59 <musasabi> ricebowl: anything in special?
16:43:00 <tic> like Fran?
16:43:22 <lispy> tic: we're still exploring, but possibly
16:43:26 <tic> lispy okay
16:43:28 <tic> cool.
16:43:32 <ricebowl> musasabi - yes. Type is ST a b, right? If I understand correctly, the second type is some data contained in ST. But what's the first?
16:43:55 <musasabi> ricebowl: are you familiar with the State monad?
16:44:00 <ricebowl> no, not at all
16:44:07 <ricebowl> this is probably one of the problems. ;)
16:44:11 <lispy> tic: basically i said i wanted to change the topic of my masters and now I have an FP profs and a graphics/animation prof that I want to work with.
16:44:11 <musasabi> mmh ok, monads in general?
16:44:14 <ricebowl> yes
16:44:31 <tic> lispy, awesome. that sounds like a fun project for a master's thesis.
16:44:49 <ricebowl> I'm trying to use runSTUArray
16:44:57 <musasabi> the monad is (ST s) so e.g. return :: a -> ST s a
16:45:02 <tic> lispy, I'm going to do some, uh, documenting of side-effects in an imperative api :)
16:45:09 <ricebowl> right
16:45:12 <ricebowl> but what's the s?
16:45:23 <ricebowl> a dummy parameter used to sequence computation?
16:45:29 <ricebowl> well, s/dummy//
16:45:32 <tic> lispy, ... seems everyone are studying CS :)
16:45:43 <lispy> tic: my previous project was implementing testing/debugging in a webservices language ;)
16:46:02 <musasabi> ricebowl: it is used to force the code play nice.
16:46:13 <lispy> but that was starting to get dicey and i wanted to get away from it.
16:46:14 <tic> lispy, so this new sounds a fair bite more fun to hack on. :)
16:46:17 <tic> mhm
16:46:23 <lispy> tic: yeah, i think so
16:46:32 <musasabi> basically you cannot mix variables from differnt ST computations.
16:46:46 <ricebowl> musasabi - right, I understand that...
16:46:53 <lispy> especially since i decided i don't want to be a researcher and the old project was more for PhD preparations than for a master's theme
16:47:06 <jg_> anyone out there using wash?
16:47:22 <lispy> yaarg: i think dons used it to create a web survey
16:47:42 <lispy> er
16:47:49 <lispy> no, that wasn't dons, but he posted it
16:48:07 <ricebowl> musasabi - what I don't understand is how to run computations inside the ST monad
16:48:16 <ricebowl> well, I know that I can use bind for that
16:48:22 <yaarg> it looks interesting..
16:48:34 <ricebowl> but I guess I just don't understand how that works with runSTUArray in Data.Array.ST
16:48:40 <yaarg> i need to look into connecting to databases from haskell too
16:48:56 <lispy> yaarg: there have been several nice appoarches to sql/db
16:50:53 <lispy> yaarg: what sort of database setup are you connecting to?
16:51:11 <lispy> yaarg: i've found that if it's just an app that needs to store some data, sqlite is really nice
16:53:14 <yaarg> lispy: well i've developed quite a few web apps using postgresql + perl :)
16:54:07 <lispy> yaarg: ah, otay
16:54:12 <yaarg> i've studied ml and that sparked my interest in fp and consquently haskell but i've yet to write a proper app in it yet. :)
16:54:47 <lispy> i like to use haskell for my homework
16:55:20 <lispy> but i don't tend to write much else in it.  I've yet to figure out how to make a gui program with it
16:55:45 <lispy> there is wxHaskell but it seems like i had installion problems or some such
16:59:48 <fworp> it installed pretty easy for me, but i just installed the binaries.
17:00:52 <lispy> hmm...maybe it was osx specific.  I know several of the gui libs i looked at didn't run natively on OSX
17:01:48 <fworp> i think there are some issue with osx's application bundle framework, vanilla binaries i dont think can use the gui
17:02:45 <lispy> why does osx have to be a pain in the butt :)
17:03:03 <ricebowl> musasabi - still there?
17:04:05 <ricebowl> I'm not sure how to construct an STUArray
17:04:11 <ricebowl> I figured everything else out
17:04:25 <musasabi> yes.
17:04:44 <ricebowl> @type Data.Array.ST.runSTUArray . return
17:04:45 <lambdabot>   Inferred type is less polymorphic than expected
17:04:45 <lambdabot>   Quantified type variable `s' escapes
17:05:01 <ricebowl> @type Data.Array.MArray.runSTUArray . return
17:05:02 <lambdabot> Not in scope: `Data.Array.MArray.runSTUArray'
17:05:02 <musasabi> either newArray or newArray_
17:05:05 <SamB> @type Data.Array.ST.array
17:05:06 <lambdabot> Not in scope: `Data.Array.ST.array'
17:05:12 <SamB> @type Data.Array.IArray.array
17:05:13 <lambdabot> forall e i (a :: * -> * -> *).
17:05:13 <lambdabot> (GHC.Arr.Ix i, Data.Array.Base.IArray a e) =>
17:05:13 <lambdabot> (i, i) -> [(i, e)] -> a i e
17:05:29 <Cale> @type Data.MArray.newArray
17:05:30 <lambdabot> Couldn't find qualified module.
17:05:30 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
17:05:30 <lambdabot> \\)?
17:05:31 <SamB> er, no
17:05:37 <Cale> @type Data.Array.MArray.newArray
17:05:38 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i.
17:05:38 <lambdabot> (Data.Array.Base.MArray a e m, GHC.Arr.Ix i) =>
17:05:38 <lambdabot> (i, i) -> e -> m (a i e)
17:05:46 <SamB> yeah, that one ;-)
17:05:49 <ricebowl> ah
17:06:00 <SamB> or you could try
17:06:02 <ricebowl> where is that documented?
17:06:09 <SamB> @type Data.Array.MArray.freeze
17:06:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
17:06:10 <lambdabot> forall e i (b :: * -> * -> *) (m :: * -> *) (a :: * -> * -> *).
17:06:10 <lambdabot> (Data.Array.Base.IArray b e,
17:06:10 <lambdabot> Data.Array.Base.MArray a e m,
17:06:10 <lambdabot> GHC.Arr.Ix i) =>
17:06:10 <lambdabot> a i e -> m (b i e)
17:06:14 <ricebowl> oh, hm, I see
17:06:20 <SamB> @index newArray
17:06:20 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable,
17:06:20 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
17:06:41 <yaarg> ttp://www.willamette.edu/~fruehr/haskell/evolution.html <-- haha i love this
17:06:54 <SamB> I'm guessing
17:06:55 <ricebowl> thanks
17:06:58 <SamB> @docs Data.Array.MArray
17:06:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
17:07:17 <Cale> yaarg: yeah, it's great :)
17:07:22 <araujo> Hello!
17:07:24 <araujo> @yaw!
17:07:24 <lambdabot> I'm ANN LANDERS!!  I can SHOPLIFT!!
17:08:55 * SamB didn't think it was any accident that low-bandwidth BT peers downloaded more than they upload when higher-bandwidth peers are around
17:10:10 <fworp> lispy: you might have better luck with gtk2hs, since you would be using the x11 server rather than cocoa. You can make something like wxHaskell work, but i think its nearly impossible when you are using ghci, lots of hackery involved at the very least
17:10:25 <conal> lispy: still there?  thanks for the congrats.  i'm interested to hear about your animation DSL 
17:11:07 <Cale> lispy: looking for a graphics library?
17:11:35 <Cale> oh, a gui
17:11:58 <Cale> gtk2hs along with cairo is quite nice :)
17:13:08 <SamB> @yaarg
17:13:10 <lambdabot> Unknown command, try @listcommands.
17:13:12 <SamB> @yaag
17:13:13 <lambdabot> Unknown command, try @listcommands.
17:13:15 <SamB> @yaar
17:13:16 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
17:13:25 <SamB> @yaar
17:13:26 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
17:18:18 <SamB> @yaar
17:18:18 <lambdabot> Arrr!
17:18:21 <SamB> @yow
17:18:22 <lambdabot> You can't hurt me!!  I have an ASSUMABLE MORTGAGE!!
17:18:27 <SamB> @yow
17:18:28 <lambdabot> I'm changing the CHANNEL ... But all I get is commercials for "RONCO
17:18:28 <lambdabot> MIRACLE BAMBOO STEAMERS"!
17:18:38 <SamB> @yow
17:18:38 <lambdabot> Everybody is going somewhere!!  It's probably a garage sale or a
17:18:38 <lambdabot> disaster Movie!!
17:18:46 <SamB> @yow
17:18:46 <lambdabot> Loni Anderson's hair should be LEGALIZED!!
17:19:41 <SamB> @yow
17:19:41 <lambdabot> Psychoanalysis??  I thought this was a nude rap session!!!
17:19:47 <SamB> @yow
17:19:48 <lambdabot> This MUST be a good party -- My RIB CAGE is being painfully pressed
17:19:48 <lambdabot> up
17:19:48 <lambdabot> against someone's MARTINI!!
17:19:58 <SamB> @yow
17:19:59 <lambdabot> Is this the line for the latest whimsical YUGOSLAVIAN drama which
17:19:59 <lambdabot> also
17:19:59 <lambdabot> makes you want to CRY and reconsider the VIETNAM WAR?
17:20:05 <SamB> @quote
17:20:05 <lambdabot> chromatic says: My productivity increased when Autrijus told me about
17:20:05 <lambdabot> Haskell's trace function. He called it a refreshing desert in the oasis
17:20:05 <lambdabot> of referential transparency.
17:20:13 <SamB> @quote
17:20:14 <lambdabot> Module "babel" produced error: getRandItem: empty list
17:20:30 <SamB> @quote
17:20:31 <lambdabot> Module "babel" produced error: getRandItem: empty list
17:20:32 <SamB> @quote
17:20:33 <lambdabot> Module "babel" produced error: getRandItem: empty list
17:20:37 <SamB> @quote
17:20:38 <lambdabot> Module "babel" produced error: getRandItem: empty list
17:20:43 <SamB> dons!
17:20:46 <Cale> hehe
17:20:47 * SamB is alarmed
17:20:53 <dons> SamB!
17:21:03 <SamB> dons: why is the list empty?
17:21:05 <dons> yeah, I think vegai reported this weird bug
17:21:20 <dons> the random numbers dry up after a module scerws up I think
17:21:24 <dons> @quit
17:21:26 <SamB> oh?
17:21:28 <ricebowl> @index array
17:21:29 <dons> @quot
17:21:35 <dons> thinking ....
17:21:37 <SamB> so its not like I messed up the quotes or anything?
17:21:44 <dons> nah, don't think so.
17:21:45 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
17:21:46 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
17:21:54 <dons> see.
17:21:57 <SamB> if I had, it would have been prudent to backup the state file...
17:22:10 <SamB> @quote
17:22:10 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up
17:22:10 <lambdabot> monad on wikipedia, find the category theory page, and crap themselves
17:22:10 <dons> it's ok ;) all is good.
17:22:21 <SamB> @quote
17:22:22 <lambdabot> joelr says: the learning curve is far steeper with Haskell but it is far
17:22:22 <lambdabot> more elegant and readable
17:22:30 <SamB> @quote
17:22:31 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
17:22:34 <SamB> @quote
17:22:34 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
17:22:41 <SamB> @quote
17:22:41 <lambdabot> Igloo says: Yes
17:22:47 <SamB> what?
17:23:02 <Lemmih> He totally got that from me.
17:23:03 <SamB> what kind of quote is "Yes"?
17:23:13 <SamB> @quote
17:23:14 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way
17:23:14 <lambdabot> most other programmers say "It's a one liner".
17:23:31 <SamB> nah. that would be "its a two-pager"
17:23:46 <SamB> @quote
17:23:46 <lambdabot> samc says: monads are hard, let's go shopping
17:23:51 <SamB> @quote
17:23:51 <lambdabot> reffie says: yi is clearly the editor of the future.
17:23:54 <SamB> @quote
17:23:54 <lambdabot> conjure says: BitTorrent client in (hopefully) 10,000 lines: darcs get
17:23:54 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
17:24:21 * SamB turns crimson and wonders how to get rid of that one
17:24:50 <SamB> @ghc
17:24:50 <lambdabot>  Can't represent Oxford brackets
17:24:54 <SamB> @ghc
17:24:54 <lambdabot>  absApply: Duff function
17:24:56 <SamB> @ghc
17:24:57 <lambdabot>  No constructor has all these fields
17:25:03 <SamB> @ghc
17:25:04 <lambdabot>  WARNING: SE CAFs unsupported, forcing UPD instead
17:25:10 <SamB> @ghc
17:25:10 <lambdabot>  even with cunning newtype deriving the newtype is recursive
17:25:19 <SamB> @ghc
17:25:19 <lambdabot>  Can't combine named fields with locally-quantified type variables or
17:25:19 <lambdabot> context
17:25:28 <SamB> @ghc
17:25:28 <lambdabot>  Urk infer
17:25:32 <SamB> @ghc
17:25:33 <lambdabot>  There must be at least one non-type-variable in the instance head
17:25:37 <SamB> @ghc
17:25:37 <lambdabot>  From-type of Coerce differs from type of enclosed expression
17:25:48 <SamB> @ghc
17:25:48 <lambdabot>  the eta-reduction property does not hold
17:25:59 <SamB> @ghc
17:25:59 <lambdabot>  Occurs check: cannot construct the infinite kind
17:26:03 <SamB> @ghc
17:26:03 <lambdabot>  On Alpha, I can only handle 4 non-floating-point arguments to foreign
17:26:03 <lambdabot> export dynamic
17:26:12 <Cale> I wish I got such interesting error messages :)
17:26:20 <Cale> (perhaps not :)
17:26:20 <SamB> @ghc
17:26:20 <lambdabot>  The instance types do not agree with the functional dependencies of the
17:26:20 <lambdabot> class
17:26:25 <SamB> @ghc
17:26:25 <lambdabot>  absApply: Duff function
17:26:27 <SamB> @ghc
17:26:28 <lambdabot>  Functional dependencies conflict between instance declarations
17:26:32 <SamB> @ghc
17:26:33 <lambdabot>  invalid character
17:26:34 <SamB> @ghc
17:26:35 <lambdabot>  In a case expression, type of scrutinee does not match patterns
17:26:39 <SamB> @ghc
17:26:39 <lambdabot>  Illegal unlifted type argument
17:26:44 <SamB> @ghc
17:26:45 <lambdabot>  Bad eta expand
17:26:48 <SamB> @ghc
17:26:48 <lambdabot>  At least one of the forall'd type variables mentioned by the constraint
17:26:48 <lambdabot> must be reachable from the type after the '=>'
17:26:57 <SamB> @ghc
17:26:57 <lambdabot>  Can't combine named fields with locally-quantified type variables or
17:26:57 <lambdabot> context
17:27:13 <SamB> @ghc
17:27:14 <lambdabot>  Try -fglasgow-exts for GHC's newtype-deriving extension
17:27:16 <SamB> @ghc
17:27:17 <lambdabot>  Offending Program
17:27:22 <SamB> heh
17:27:25 <Cale> heh
17:27:26 <fworp> ha
17:27:40 <dons> that's cool.
17:28:23 <Cale> I wish there were references for how to generate all these messages :)
17:28:59 <dons> we don't know how to generate them though. TheHunter played the game for a while, but some of them are only triggered by compiler bugs
17:29:12 <Cale> ah
17:29:51 <Cale> @ghc
17:29:52 <lambdabot>  parse error on input
17:29:54 <Cale> @ghc
17:29:55 <lambdabot>  Pattern bindings (except simple variables) not allowed in instance
17:29:55 <lambdabot> declarations
17:30:03 <Cale> who came up with the list?
17:30:06 <Cale> @ghc
17:30:07 <lambdabot>  The signature contexts in a mutually recursive group should all be
17:30:07 <lambdabot> identical
17:30:17 <Cale> @ghc
17:30:17 <lambdabot>  Bindings in hs-boot files are not allowed
17:30:37 <dons> I added them in one day
17:30:54 <Cale> did you just look through the ghc source for them?
17:31:19 <dons> I wrote a script to find them
17:31:24 <dons> mostly in the type checker, iirc
17:32:32 <dons> yay, with a few little tweaks: 956K    dist/build/hmp3/hmp3
17:32:53 <dons> note: derivings are bloat inducing
17:38:28 <Lokadin> anyone know of a way to view pdf without wasting 100% cpu?
17:39:10 <dons> umm ... use xpdf maybe? or gv?
17:39:18 <Lokadin> kk thanks :D
17:39:28 <Cale> does evince use 100% cpu?
17:39:37 <Lokadin> acroread does
17:39:59 <Cale> evince is nice
17:40:15 <Lokadin> don't have gnome
17:40:16 <Cale> there's still a few things I go back to gv for though
17:40:35 <Lokadin> but i guess it doesn't really matter, i use ion3
17:40:48 <Cale> you don't need the whole gnome setup, just the libraries
17:41:24 <Lokadin> i got those so is fine
17:41:28 <Lokadin> i'm merging it
17:41:55 <Lokadin> show of hands who uses gentoo here?
17:41:59 * Lokadin picks up hand
17:42:13 <Cale> I think dcoutts does
17:42:19 <dons> @seen lambdabot
17:42:20 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #haskell.es, #haskell.it, #gentoo-
17:42:20 <lambdabot> haskell, #haskell-overflow, #haskell-blah and #haskell
17:42:24 <dons> apparently lambdabot does ;)
17:42:44 <Lokadin> oo
17:42:45 <Lokadin> lol
17:42:57 <Lokadin> what you guys use?
17:43:03 <Cale> Debian here
17:43:12 <Lokadin> dons: you?
17:43:12 <dons> OpenBSD 3.8 i386
17:43:15 <Lokadin> o
17:43:16 <musasabi> NetBSD and Debian.
17:43:28 <Lokadin> crazy i never managed to figure out the bsd's
17:43:46 <dons> what's to figure out? ;)
17:43:49 <dons> you just install it
17:43:58 <Lokadin> well i couldn't find ports
17:44:12 <Lokadin> and there was no syntax highlighting and all the device names were scary
17:44:21 <Lokadin> :(
17:44:46 <Lokadin> You are currently using 50 MB (2%) of your 2668 MB.You are currently using 50 MB (2%) of your 2668 MB.
17:44:48 <Lokadin> :|
17:44:57 <Lokadin> that's quite a bit of extra space
17:45:16 <palomer> and then I got high
17:45:38 <Lokadin> palomer: that's a really old song, but did you really?
17:45:46 <palomer> no
17:46:02 <Lokadin> o okay just wondering
17:46:18 <Lokadin> tiz takin a whjile to compile the libraries
17:46:28 <Lokadin> poppler or some such
17:46:34 <Lokadin> load 4.49
17:46:37 <dons> no syntax highlighting? in your editor?
17:46:44 <Lokadin> on the command line
17:46:49 <wilx> Hmm, the only bad thing about BSDs is having to do make buildworld stuff.
17:46:52 <dons> oh, you mean colorls ?/
17:46:52 <Lokadin> the directories weren't coloured nicely
17:47:02 <wilx> I tried it once and failed miserably.
17:47:13 <Lokadin> i'm sure i could have just done ls --color
17:47:20 <dons> right.
17:47:27 <Lokadin> i dono, i had only been using linux for a year back then
17:47:33 <dons> try man colorls ;)
17:47:57 <Lokadin> gentoo makes me happy :(
17:47:59 <palomer> man 2 man
17:48:11 <Lokadin> :o
17:48:20 <musasabi> coloring ls output by default causes all kinds of harm (when used with pipes etc)
17:48:37 <palomer> the worst distribution I've ever used is gentoo
17:48:42 <Lokadin> never encountered such harm
17:48:44 <dons> any reasonable implementation won't color when connected to a pipe, surely?
17:49:08 <dons> i think in the bad old days they used to though. I rmemeber  having | more always looking ugly.
17:49:25 <Lokadin> back in the days..
17:49:29 <Lokadin> :D
17:49:30 <Lokadin> lol
17:49:43 <Lokadin> palomer: really? i dono i love it sooo much!! :D
17:50:08 <Cale> dons: right, ls when connected to a pipe should produce its output as if called with -1 and with colour turned off
17:50:19 <palomer> When I wasn't compiling I was trying to find out why it wasn't compiling
17:50:28 <dons> this is the behaviour with bsd `colorls', according to the man page
17:50:56 <Lokadin> palomer: :)
17:52:32 <Lokadin> dono *shrugs* while i have to admit that does happen quite a bit, after a while it becomes really smooth and there are no problems, first few weeks suck *shrugS*
17:52:48 <Lokadin> as long as the cflags are reasonably safe
17:53:30 <Lokadin> i changed my stuff to unstable yesterday :|
17:53:45 <Lokadin> i have er 232 packages to go
17:53:49 <Lokadin> lol
17:54:07 <Frederick> Lokadin, wich distro?
17:54:16 <Lokadin> gentoo
17:54:32 <Frederick> Lokadin, take A LOT o care with etc update
17:54:34 <Lokadin> i wonder if it will finish before tuesday
17:54:42 <Frederick> brb
17:54:44 <Frederick> I need to reboot
17:54:51 <Lokadin> Frederick: :P i've been using gentoo for like 3 years
17:54:56 <Frederick> @localtime SamB 
17:54:57 <lambdabot> Local time for SamB is Sun Nov 27 20:55:24
17:55:38 <Cale> I might try gentoo if it looked like I didn't have to compile anything.
17:55:54 <Lokadin> lol
17:56:00 <Lokadin> what would be the point?
17:56:00 <Lokadin> lol
17:56:00 <Cale> I've heard that there are binary versions of some packages
17:56:07 <Cale> To run gentoo?
17:56:16 <Lokadin> i mean to not compile things
17:56:30 <Cale> Not wasting CPU time?
17:56:49 <Lokadin> :| do you really need it that much? i mean how often do you install new programs?
17:56:58 <Lokadin> and large applications do have binaries available
17:57:12 <Lokadin> in general anything over 10mb or so
17:57:12 <ricebowl> there's a binary GHC
17:57:21 <Lokadin> and binary openoffice and firefox
17:57:23 <Cale> It's much smarter to have one machine compile things to binaries which are then distributed, than to have many machines compiling the same binaries.
17:57:27 <ricebowl> and binary stuff for (some parts of?) X
17:57:43 <Lokadin> Cale: well if you had a lot of computers..
17:57:46 <ricebowl> but...it's not really worthwhile
17:57:55 <Lokadin> you can always have it compile on one and distribute to the others
17:58:10 <Cale> Even if you only have one machine
17:58:15 <Frederick> SamB are you alive?
17:58:17 <ricebowl> Lokadin - I think the hallmark of installing Gentoo is the sheer amount of time it takes to get a system up and running. ;)
17:58:20 <Cale> It's nicer to not have to do any compiling
17:58:26 <Cale> that's a 100% savings
17:58:31 <Lokadin> ricebowl: i would have to agree
17:58:45 <Lokadin> i just finnd it's worth while because the system is soo nice afterwards
17:58:48 <Frederick> Cale can you give me some advice on my code? deadline is tommorow I cant fix it =/
17:58:51 <ricebowl> Cale - Gentoo users suggest that you can optimize for your architecture. (Although personally I think this makes little overall difference.)
17:59:10 <Cale> Frederick: well, I can take a look
17:59:17 <Frederick> oki I will reboot
17:59:19 <Frederick> brb
17:59:30 <ricebowl> heh it's a good thing that Portage has a binary GHC, even if it's old. Portage barfed on compiling 6.4.1 :/
17:59:52 <Cale> ricebowl: yeah, I think any benefit in CPU cost would be negated by the sheer amount of compiling you'd do
18:00:07 <rt> gentoo is founded on the premise that it's a better use of your time to recompile `ls' to get a 3 microsecond speed increase than just to live with the possibility that you might be squandering 3 microseconds of your precious computer power later.
18:00:08 <ricebowl> Cale - Gentoo is a good distro for something that you want to be mostly hands-off, e.g. a server, but very poor for almost everything else
18:00:11 <Lokadin> ricebowl: really i got 6.4.1-r1 compiled
18:00:37 <Lokadin> rt: and that is the right way to go! :D
18:00:38 <ricebowl> Lokadin - well I'll have to go back and check, but it did *not* work for me
18:00:46 <rt> no, it isn't.
18:00:51 <ricebowl> Cale - not really; compiling is a one-time cost
18:00:52 <Lokadin> rt: :P maybe not for you
18:00:53 <Lokadin> lol
18:00:53 <Cale> I'm presently running Debian. I think if I was to do a reinstall, I'd go with ubuntu, at least for the initial install phase.
18:01:07 <ricebowl> but they're micro-optimizations and GCC does such a poor job of applying them that they amount to almost nothing.
18:01:20 <rt> i'm sorry.  i guess if you place a value on your time of zero, then gentoo is no worse than other distributions. :-)
18:01:25 <Cale> ricebowl: yeah, but it's large, and are you really going to save all that time between this update, and the next one?
18:01:27 <ricebowl> plus the majority of time is spent in memory traffic and you simply can't optimize that unless you rewrite all the crappy code--which nobody is going to do.
18:02:09 <ricebowl> Cale - I've been thinking of switching from Gentoo to Debian; I presume Debian is a little saner about updates and such
18:02:25 <Cale> yeah, it just downloads binaries and installs them
18:02:32 <ricebowl> i.e. not requiring me to hand-merge 70+ files every time I update my system.
18:02:37 <Cale> and handles dependencies etc
18:02:41 <ricebowl> *cough* portage sucks *cough*
18:02:48 <yaarg> I just switched from Debian to Gentoo and I detest it. 
18:03:12 <yaarg> I'll switch as soon as I finish my current assignment. :)
18:03:13 <ricebowl> and having used apt-get on Ubuntu I noticed that it is significantly faster than using portage, i.e. search times of several minutes falls to like 3 seconds
18:03:15 <lisppaste2> Frederick pasted "the final battle" at http://paste.lisp.org/display/14072
18:04:01 <yaarg> Debian's packages were faster presumably because the maintainers actually know what they are doing. 
18:04:15 <ricebowl> Gentoo would be OK if portage weren't so slow and such a headache. But portage is terrible. Therefore...
18:04:18 <yaarg> unlike me that just -o3 -funroll-loops -fomit-frame-pointer eveyrhting :)
18:04:38 <ricebowl> yaarg - I am referring to emerge -s and emerge -a or -p
18:04:47 <ricebowl> it feels like watching grass grow.
18:04:57 <yaarg> heh
18:05:09 <ricebowl> the -a flag would not *need* to exist if emerge weren't so horribly slow.
18:05:59 <ricebowl> my favorite Gentoo user experience is having to hand-merge init scripts that *I haven't modified* because some loser changed indentation
18:06:06 <Frederick> Cale it fails for composed cases
18:06:14 <Frederick> like if I need to re-evaluate the closure
18:06:23 <ricebowl> apparently there is a well-kept secret about how to get emerge to do that automatically.
18:06:39 <Cale> Frederick: well, the first problem I'm having is that removeReplacers isn't finished :)
18:07:09 <Frederick> Cale, Ive expend 4 hours today trying to finish it =/
18:07:44 <Frederick> astrolabe suggested something like http://paste.lisp.org/display/14066
18:10:01 <Cale> this is all quite undocumented
18:10:35 <yaarg> Yes. After all Gentoo is for ricers. ;)
18:10:49 <Frederick> I couldnt comment and fix cause I didnt understood the whole thing basically the idea was avoid loops
18:11:13 <Frederick> we creates a list of expansior and symbols to evaluate
18:11:27 <Cale> what is closure supposed to compute?
18:11:31 <Frederick> so we cjhack ifthat symbol was evaluated or not, pop the list or push it in the casw
18:12:00 <Frederick> closure should compute the transitivo closure of the nonterminals in the rhs of the rules like the X from S -> aXX
18:12:06 <ricebowl> yaarg - I saw that page too, heh
18:12:09 <ricebowl> amusing
18:12:49 <ricebowl> at this point I keep threatening myself to reinstall my router with a different distro. However, Gentoo headaches are easier than learning a new distro.
18:13:30 <rt> pick a distribution that doesn't require you learning a bazillion useless things.
18:13:51 <Cale> hmm
18:14:05 <ricebowl> Debian is probably what I would choose.
18:14:17 <ricebowl> I am holding out, though; they keep talking about keeping FreeBSD kernels in Portage
18:14:19 <rt> I would probably go ubuntu. 
18:14:24 <rt> or even fedora core N.
18:14:26 <ricebowl> rt - on a router?
18:14:42 <rt> well, depends on what your router is. :-)
18:14:50 <ricebowl> VIA C3 1 GHz with 512MB of ram
18:14:55 <ricebowl> Ubuntu probably uses more than that on boot.
18:14:58 <Lokadin> you gentoo works fast on pentium 2 laptops
18:15:09 <rt> my webserver runs on one of those.
18:15:25 <rt> you could run freebsd. :)
18:15:28 <Lokadin> i tried it on quite a few 
18:15:31 <ricebowl> I have thought of that, too
18:15:45 <ricebowl> but then I would have to learn--er, I forget the name of the tool, the BSD equivalent of iptables
18:16:01 <rt> ipfw or ipf or ... the other one.
18:16:04 <rt> I can't remember.
18:16:07 <ricebowl> ipfw
18:16:09 <rt> never used it.
18:16:12 <ricebowl> likewise
18:16:20 <ricebowl> heh I wanted to say ipfwadm but that's not BSD ;)
18:16:23 * rt just uses cheesy linksys gadgets for routers now.
18:16:40 <ricebowl> those are Linux, but they're still seriously broken
18:16:51 <rt> works fine for me.
18:16:53 <ricebowl> just "less broken than everyone else's NAT box"
18:17:12 <Cale> Frederick: okay, I see how it kind of does something like that
18:17:28 <ricebowl> well, I've had a mountain of problems with such NAT boxes including the WRT51G models.
18:17:29 <Frederick> Cale, Im stuck on it
18:17:40 <ricebowl> with respect to UDP traffic. Works great for anything on TCP.
18:17:57 <ricebowl> they close tunnels to UDP ports that are open, hence the problem.
18:18:21 <ricebowl> the Linksys boxes did something different, though, which was very weird. I don't know what was going on.
18:18:44 * rt shrugs.  I have ssh and http ports open, and little else.
18:18:50 <ricebowl> anyway, a Linksys box can't route *and* forward at the same time.
18:18:56 <rt> don't use those silly warez clients that require udp packets.
18:19:01 <ricebowl> haha
18:19:14 <ricebowl> not a warez client. Anything requiring timely transmission uses UDP.
18:19:24 <Frederick> Cale, I was talking with the guys before that is like 3 or 4 lines of code but I dont know how to implement
18:19:25 <ricebowl> which means media broadcasting, games, etc.
18:19:31 <Frederick> the algorithm s too tricky
18:19:45 <rt> well, i do run voip behind my linksys box.  with minor tweaking the qos stuff seems to work fine.
18:20:11 <ricebowl> in a month or so I'll be switching to SpeakEasy OneLink which gives me and my roomie 8 static IPs
18:22:12 <Frederick> Cale, the problem for me is to handle a structure that doesnt ends on a infinite loop
18:24:54 * rt wonders if anyone ever used the mng file format for anything.
18:30:23 <Frederick> Cale, ?
18:30:45 <Cale> um, well, I don't know what you'd like me to tell you
18:31:01 <Cale> do you have a question?
18:31:10 <Frederick> yes
18:31:25 <Frederick> how can I make this step of looking back if I cant generate new productions?
18:31:39 <Cale> looking back?
18:32:00 <Cale> can't generate new productions?
18:32:45 <Frederick> like if I need new substitutions, yes like currently the program only solves replacements in the form A -> S , S -> D, D -> ... it means, for a single variable, into a single option I must be able to handle expansions in forms like ASD 
18:34:12 <Cale> So if you had W -> ASD, with the rules above, what would that result in?
18:35:37 <Cale> hm?
18:35:44 <Frederick> the result would be W -> DDD where D should be replaced for all possible combinations of its productions like if D can derivate a or b we would end with aaa aab aba baa abb bba bab bbb bba bab abb aab aba baa aaa]
18:36:24 <Cale> okay
18:36:36 <Cale> what if D -> Da | Db ?
18:37:28 <Cale> Are we trying to generate all the words possible from a given grammar?
18:37:51 <Frederick> this rule isnt reducible, it has a left recursion it needs a rule like ifthe nt of rhs is the same from lhs we shouldnt expand, more or less
18:38:04 <Frederick> we are trying to reduce the grammar
18:38:35 <Cale> okay, so basically, we avoid doing things with at least directly cyclic dependencies
18:38:48 <Frederick> yep
18:38:55 * Frederick goes take coffe
18:39:06 <Cale> If we have A -> aB, B -> bC, C -> cA, then what?
18:39:25 <Cale> does this simplify to A -> abcA ?
18:40:23 <Frederick> yes
18:43:29 <Cale> so in some sense, we're iterating a simplification function until the thing doesn't change anymore
18:44:04 <Frederick>  yes exaclty this is th perfect concept of the idea
18:44:57 <Cale> simplify cfg = cfg { productions = newProds
18:44:57 <Cale>                      nonterminals = Map.keys newProds }
18:44:57 <Cale>     where newProds = fix simplifier (productions cfg)
18:44:57 <Cale>           simplifier = ...
18:45:38 <Cale> and,  fix f x = let y = f x in if x == y then x else fix f y
18:45:53 <Frederick> what does the .. stands for?
18:46:13 <Cale> well, the function which is going to simplify the cfg by one step
18:47:44 <Cale> It just has to satisfy two properties: 1. Iterating it eventually produces a fully simplified cfg, and 2. If the input cfg is already simplified, it doesn't change it.
18:48:28 <Cale> we need (2) because in the definition of fix, we're using == to test if any change has occurred.
18:49:23 <Cale> also, I've been saying cfg when I meant the productions of the cfg, of course
18:49:55 <Cale> so let's say we have a bunch of productions -- what's the least we can do?
18:50:27 <Frederick> iterate along all of them to check for possiblem expansions?
18:50:44 <Cale> yeah, probably using map
18:50:58 <Cale> and of course, producing the expanded version
18:51:07 <Cale> we just want to expand by one step
18:51:43 <Frederick> this approach is 100x more simple than the one astrolabe suggested in fact this is the soul ofthe algorithm
18:53:13 <Cale> okay, so perhaps try and write 'simplifier'
18:53:33 <Cale> remember to not expand a nonterminal if it's equal to the LHS of the production
18:53:47 <Frederick> oki so all we need are 2 function 1 to map the size ofthe productions and a lookahead to expand the rhs
18:53:58 <Cale> the size?
18:54:11 <Frederick> expansion in fact
18:54:28 <Cale> mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
18:54:36 <Cale> that'll be useful
18:56:26 <lisppaste2> Frederick pasted "like that?" at http://paste.lisp.org/display/14074
18:56:30 <Cale> It'll let you only need to think about one particular LHS -> RHSs
18:57:02 <Cale> hmm...
18:57:12 <Frederick> I mean the concept not the fucntion
18:57:22 <Frederick> just the use of Map.MapWithKey
18:57:22 <Cale> simplify cfg = cfg { productions = newProds
18:57:22 <Cale>                      nonterminals = Map.keys newProds }
18:57:22 <Cale>     where newProds = fix simplifier (productions cfg)
18:57:22 <Cale>           simplifier prods = mapWithKey (expandProd prods) prods
18:57:22 <Cale>           expandProd prods key results = ...
18:58:18 <Cale> expandProd takes the current Map of productions, the key of the production we're focusing on simplifying, and the list of possible RHSs (results)
18:58:32 <Cale> and it's going to produce a new list of RHSs
18:58:36 <Cale> somehow
18:58:56 <Cale> so now instead of thinking about the whole Map
18:59:16 <Cale> we just have to think about one set of productions associated to a particular nonterminal
18:59:45 <Cale> now, it would be nice if we could focus our view a little further, right?
18:59:55 <Frederick> yes
19:00:01 <Frederick> so now the ... stands for a new list
19:00:07 <Cale> just focus on a single LHS -> RHS pair
19:00:20 <Cale> rather than a list
19:00:28 <Cale> to do that, we use map
19:00:40 <Frederick> we get the value of the map
19:00:48 <Cale> I mean Prelude.map
19:00:53 <Cale> @type map
19:00:54 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:00:55 <Frederick> map.value I think right?
19:01:04 <Frederick> we want the [b] right?
19:01:13 <Cale> yeah
19:01:25 <Cale> and the [a] is the list of current RHSs
19:01:47 <Cale> since we'll be simplifying each RHS in the same way, map is just what we want
19:02:06 <Frederick> [a] is called by Map.keys how do I call the other side? the [b]
19:02:45 <Cale> hmm?, not Map.keys
19:02:59 <Cale> [a] is results, the parameter to our current function
19:03:19 <Cale> the list of possible results of expanding the nonterminal 'key'
19:03:36 <Cale> and we're trying to simplify it
19:03:45 <Cale> actually, let's think a little more about this
19:04:01 <Cale> it's not quite just a map
19:04:28 <Cale> since when we do the expanding, we're going to end up with potentially more than one new RHS to replace the old one
19:04:55 <Frederick> yes so cant we concat the maps? I think in that in terms of derivation trees
19:05:02 <Cale> yeah
19:05:07 <Cale> @type concatMap
19:05:08 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
19:05:20 <Cale> or even
19:05:23 <Cale> @type (>>=)
19:05:24 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:05:33 <Cale> but let's not get into that :)
19:05:46 <Frederick> ski talked a lot about (>>=)
19:06:03 <Cale> yeah, this is really a computation in the list monad
19:06:23 <Cale> but seeing as you don't have tons of time...
19:06:37 <Frederick> 14 hours :p
19:07:59 <Cale> so now we've knocked it down from a Data.Map of productions, to a single production group, to a single LHS/RHS pair to expand
19:08:07 <Frederick> oki so we use concatMap to add the new rules so I think there are basically 2 cases 1 the rule needs no expansion so we just concat it or it needs expansio so we must somehow know how long to expand and concat right?
19:09:34 <lisppaste2> Cale annotated #14074 with "like this" at http://paste.lisp.org/display/14074#1
19:10:14 <Cale> key is a nonterminal, and result is a single RHS
19:10:25 <Cale> and we just need to return a list of potential expansions
19:11:09 <Cale> it doesn't even need to be terribly thorough, as we're just going to go and hammer it all over again anyway, until it's completely simplified
19:11:47 <Cale> something you might like...
19:11:58 <Cale> > sequence [[1,2,3],[4,5],[6,7]]
19:11:59 <lambdabot> [[1,4,6],[1,4,7],[1,5,6],[1,5,7],[2,4,6],[2,4,7],[2,5,6],[2,5,7],[3,4,6],[
19:11:59 <lambdabot> 3,4,7],[3,5,6],[3,5,7]]
19:12:11 <Cale> that might be handy
19:12:29 <Frederick> oki so we have a condition that is as long the nonterm from the rhs is not the same ofthe lhs we must expand right? but if something like S -> Ax | AAx, A -> whatever how we combine it?
19:13:26 <Frederick> does sequence return all the possible combinations?
19:13:31 <Cale> it's not clear that those can be combined
19:13:39 <Cale> yeah
19:13:54 <Cale> of picking one thing from the first list, and one thing from the second, and so on
19:16:16 <Cale> you think about it a while, let me know if you run into more difficulty -- all you have to do is focus on that single key/result pair and produce a list of possible expansions of the nonterminals, not including any nonterminal which is equal to key
19:19:10 <Frederick> how will I generate the lists to give to sequence?
19:21:35 <Frederick> ???
19:25:29 <Frederick> Cale, ?
19:34:03 <Cale> Frederick: good question :)
19:34:04 <Cale> hehe
19:34:26 * Frederick is alive
19:35:17 <Cale> work on it a bit and see if you manage to figure it out :)
19:35:52 <Frederick> @localtime Cale 
19:35:53 <lambdabot> Local time for Cale is Sun Nov 27 22:35:31
19:37:13 <yaarg> @localtime yaarg
19:37:16 <lambdabot> Local time for yaarg is Mon Nov 28 03:36:51 2005
19:38:37 <Cale> you'd get a closer estimate of my current internal clock by doing @localtime dons :)
19:39:20 <Cale> @localtime dons
19:39:22 <lambdabot> Local time for dons is Mon Nov 28 14:33:51 2005
19:39:30 <Cale> yeah, that seems about right :)
19:42:50 <Lokadin> how do you search in apt
19:43:04 <Lokadin> lik e i mean in debian
19:43:08 <Lokadin> how do you search packages?
19:44:33 <Lokadin> ?
19:44:34 <Lokadin> *pokes*
19:44:36 <Lokadin> :(
19:48:20 <dons> 2.30 pm eh Cale?
19:49:32 <yaarg> Lokadin: apt-cache search
19:51:39 <Lokadin> yaarg: thanks :D
19:59:58 <Cale> Lokadin: apt-cache search
20:00:00 <Cale> oh
20:00:01 <Cale> hehe
20:04:47 <Frederick> Cale, I got no improvement at all =/
20:06:00 <Frederick> cause this is a composed list a list that is composed by a part of the elements of the other list
20:06:55 <Cale> Perhaps you could apply the function by hand a few times and see what it should do?
20:07:47 <Frederick> I can do it by hand but not in haskell
20:08:20 <Cale> well, what are you doing by hand?
20:08:42 <Cale> like, do an expandProd by hand
20:08:48 <Cale> and see what it should do
20:09:34 <Frederick> I just combine all the possibilities, like S -> Aa, A -> a | b | c I look on a and replace for its productions it is a "dumb" procedure but it is very tricky to program
20:10:54 <Cale> so you look at each symbol of Aa
20:11:09 <Cale> and if it's a terminal, the only possibility is itself
20:11:17 <Cale> same goes if it's 'S'
20:11:44 <Cale> if it's a nonterminal, you have to look and see what that nonterminal could expand to
20:12:21 <Frederick> it is like is isUpper(prod[i]) for each production append(prod[i].productions)
20:14:17 <Cale> it's like  map possibilities result, where possibilities will give [x] if x is a terminal, or if x == key, and otherwise it looks up the nonterminal in the prods map
20:14:19 <Frederick> but I have no clue about how to do it in haskell absolutelly no clue cause I find a pain to acces complex structurres
20:14:40 <Cale> this is just a list
20:14:48 <Cale> you use things like map and filter and concat
20:15:01 <Cale> or just recursion
20:19:47 <Frederick> how can I use just recursion? 2 am here of the last day im awake since yesterdays 5:30 am
20:19:55 <Frederick> Im loosing the faith =/
20:20:53 <Cale> well, here you don't need to, the pattern of recursion you need is captured by the map function
20:21:01 <Cale> and sequence
20:22:34 <Frederick> what do you mean?
20:23:44 <Cale> well, you want to map some function over the list to get a list of the lists of possible replacements at each spot
20:24:00 <Cale> and then use sequence on that to produce the list of expansions, right?
20:24:31 <Frederick> yes
20:24:41 <Cale> so do that :)
20:24:47 <Frederick> this is the concept but doing it for me looks like black magic :(
20:25:19 <Cale> haven't you gone and written a bunch of little programs which use map and filter and such?
20:26:00 <Frederick> Cale, yes but his is very tricky and Ive done it for 1 week, Ive read all tutorials and stuff than Im on 2 weeks on this code
20:26:35 <Cale> heck, there's some pretty sophisticated examples in your own code
20:26:45 <Frederick> and today is the end incomplete versions wont be evaluated so it is like 3 weaks thrown away and I will fail the class
20:27:02 <Frederick> Cale, Ive code with the help of the folks like 5 lines of code / day
20:27:17 <Frederick> with like 6 hours effor a day
20:28:36 <Frederick> and I will fail now :(
20:28:52 <Lokadin> sya with yet another haskell tutorial how do i declare a list made with "data List a = Nil | Cons a (List a)"
20:29:04 <Lokadin> i mean do i have it as (Cons 1 2)
20:29:05 <Lokadin> ?
20:29:17 <Cale> Lokadin: Cons 1 (Cons 2 Nil)
20:29:25 <Lokadin> o okay
20:29:27 <Lokadin> thanks :D
20:29:31 <Cale> np
20:30:10 <Cale> Frederick: well, I hope you'll include all their names on your assignment, but seriously, you should be reading and making sure you understand what's going on in any code that people give you
20:30:23 <Cale> you know what map does, certainly
20:30:44 <Cale> It takes a list, and applies a function to each element, producing a new list
20:30:54 <Frederick> yes I need something like  prods''  = Map.map (concatMap f) prods'
20:30:54 <Frederick>     f []     = [[]] 
20:30:54 <Frederick>     f (x:xs) | x `elem` empties cfg = map (x:) (f xs) ++ f xs
20:30:54 <Frederick>     	     | otherwise            = map (x:) (f xs)
20:30:57 <Frederick> I think
20:31:13 <Frederick> it is almost the same thing as the empties
20:31:24 <Lokadin> wow you actually got a course on haskell :(
20:31:37 <Frederick> Lokadin, who?
20:31:41 <Lokadin> you
20:31:43 <Lokadin> :P
20:31:45 <Lokadin> or what is it for?
20:31:58 <Lokadin> i mean i'm stuck doinng it recreationally on my spare time 
20:32:00 <Lokadin> lol
20:32:10 <Frederick> Lokadin, a formal languages class were the teacher reproved already 1/2 of the class
20:32:47 <Lokadin> reproved?
20:33:09 <Frederick> Lokadin, 1/2 of the class already failed the avarage grade is 5
20:33:20 <Lokadin> soudns like my calc class
20:33:40 <Lokadin> our average is under a 50
20:33:46 <Lokadin> lol
20:33:47 <yaarg> haha
20:33:54 <Frederick> so is mine
20:34:01 <yaarg> they teach haskell to first and second year students at my university these days
20:34:04 <Frederick> and the bitch gave us this insane assigment
20:34:07 <Lokadin> and at least 150 peoplle dropped out of a 200 person class
20:34:09 <yaarg> which is very cool... :)
20:34:19 <Frederick> yaarg, at least they do teach you
20:34:21 <yaarg> Lokadin: ha that's my CS degree
20:34:30 <yaarg> i did ML in my third year..
20:34:33 <Frederick> mineteachers just ask
20:34:37 <Lokadin> o
20:34:43 <Frederick> and teach nothing, mostly because they are ignorant
20:34:48 <Lokadin> can't wait until i get to comp sci courses
20:34:56 <Lokadin> but it's all java from what i can tell
20:35:08 <Lokadin> i mean in my school
20:35:48 <Cale> there's one (programming languages) course at Waterloo where people are exposed to Haskell for about a few months
20:35:53 <Lokadin> Frederick: i'm sure if the teacher taught us anything in that calc class more than 40% of the class would be passing lol
20:36:08 <yaarg> and I'm studying Advances in Programming Languages atm
20:36:16 <yaarg> which covers lots of fun stuff :)
20:36:20 <Lokadin> :D
20:36:25 <lisppaste2> Frederick pasted "Is this the general idea?" at http://paste.lisp.org/display/14075
20:38:00 <Cale> Map.map?
20:38:08 <Frederick> Lokadin, they need to get things hard by turning the subject an ocult science cause their knowledge is deep as a puddle of pee
20:38:18 <Cale> Map.map doesn't have the right result type
20:38:29 <Frederick> just map?
20:38:50 <Cale> sequence (map something result)
20:38:52 <Lokadin> Frederick: lol
20:39:13 <Frederick> Lokadin, thats why they teach the same subject forever
20:40:22 <Frederick> Cale, can I replace somethig by prods?
20:42:19 <Cale> you want a function which looks things up in prods
20:42:47 <Cale> and also handles the cases where it's a terminal, or it's a nonterminal, but that nonterminal is key
20:43:09 <Cale> (i.e. you don't want to replace D in D -> a D)
20:44:01 <Lokadin> why doesn't this work: listTail (Cons x xs) = listHead x + listHead xs
20:44:20 <Cale> what's the type of listHead?
20:44:35 <Cale> and what is listTail supposed to do?
20:44:37 <Lokadin> listHead (Cons x xs) = x
20:44:42 <Lokadin> be like tail
20:45:05 <Cale> Cons x xs represents the list whose head is x and whose tail is xs
20:45:25 <Lokadin> yea
20:45:42 <Lokadin> data List a = Nil | Cons a (List a)
20:45:46 <Cale> so don't you just want it to give xs?
20:46:04 <Lokadin> well listTail (Cons x xs) = xs
20:46:05 <Lokadin> doesn't work
20:46:12 <Cale> uh, it ought to
20:46:16 <Lokadin> really?
20:46:19 <Cale> yeah
20:46:21 <Lokadin> here i'll do a paste one sec
20:47:13 <lisppaste2> Lokadin pasted "Cons" at http://paste.lisp.org/display/14076
20:48:01 <Cale> well, listFoldr needs another parameter and another case, but listTail is fine
20:48:44 <Lokadin> listTail (Cons 1 (Cons 2 Nil))
20:48:45 <Lokadin> Top level: No instance for (Show (List a))
20:48:49 <Cale> you might want to add "deriving Show" to the end of your data declaration
20:48:58 <Lokadin> o okay
20:49:01 <Cale> it doesn't currently have a way to print lists
20:49:39 <Cale> so the listTail works, but then it can't show you the result
20:49:48 <Lokadin> o
20:49:51 <Frederick> Cale, all nonterminals are keys
20:49:54 <Lokadin> well it works now :D
20:49:58 <Lokadin> thanks
20:50:15 <Lokadin> @type foldr
20:50:16 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
20:50:20 <Cale> Frederick: yeah, but they may or may not be the current one, which is 'key'
20:50:42 <Cale> > foldr (:) [] [1,2,3,4,5]
20:50:43 <lambdabot> [1,2,3,4,5]
20:50:51 <Frederick> why does haskell needs a sooooooooooooooo tricky syntax?
20:51:01 <Cale> the syntax isn't so tricky
20:51:04 <Cale> it's nice
20:51:07 <Lokadin> yep
20:51:12 <wchogg> Haskell's syntax is actually quite regular.  The only thing more regular would be lisp.
20:52:01 <Lokadin> say to be quite honest i'm really stuck on foldr i mean i have no idea how to do it
20:52:27 <Frederick> Cale, is the idea somethint like expandProd prods key result =  sequence (map prods Map.keys)?
20:52:27 <Cale> Lokadin: the idea behind foldr is that it replaces (:) with some function, and [] with some value
20:52:59 <Cale> Frederick: no, you're mapping over result, not Map.keys
20:53:01 <Lokadin> yea it's the value part i'm stuck on
20:53:21 <Cale> Frederick: that should actually be obvious if you know what the rest of the code that I gave you does
20:53:24 <Lokadin> i eman i don't know how to add a value at the begining, and then not for every reoccuring one
20:53:31 <Lokadin> *thinks*
20:53:47 <Cale> Lokadin: okay, either a list is Cons x xs, or it's Nil
20:54:20 <Cale> listFoldr f z (Cons 1 (Cons 2 Nil)) = f 1 (f 2 z)
20:54:42 <Lokadin> kk
20:54:48 <Cale> what should listFoldr f z Nil be?
20:54:52 <Lokadin> but wouldn't it add it at the end? and foldr adds at beginiign?
20:55:00 <Lokadin> that was my problem really
20:55:04 <Cale> at the end, the beginning?
20:55:24 <Cale> http://vx.hn.org/autoshare/foldr.png -- see this picture :)
20:55:35 <Frederick> you initialize the register and expand the prods with a function that doesnt exist yet :p
20:55:37 <Lokadin> er well i think when they were explainig it at the top of the tutorial foldr adds value at begining of list and foldl adds it at the end
20:55:46 <Lokadin> kk
20:56:02 <Cale> Lokadin: I think it's the other way around
20:56:08 <Cale> if I know what you mean at all :)
20:56:13 <Lokadin> lol kk
20:56:15 <Lokadin> :D
20:56:28 <jeffno> On syntax: I'm just learning Haskell and it's really frustrating.
20:56:37 <Cale> jeffno: why?
20:56:43 <Frederick> jeffno, welcome to the club
20:56:45 <jeffno> Lack of keywords.
20:56:46 <palomer> haskell syntax > sml syntax
20:56:48 <jeffno> Nothing to grab onto.
20:56:54 <Cale> jeffno: lack of keywords?
20:57:01 <Cale> what language are you coming from?
20:57:04 <jeffno> Java.
20:57:17 <Cale> oh, Java is hideously verbose :)
20:57:22 <palomer> oh my, I think we have an emergency
20:57:22 <Khisanth> Java doesn't have that many keywords either :)
20:57:26 <jeffno> As an example, when Java added parameterized types they used <> around the parameter.
20:57:40 <jeffno> Ok, maybe not keywords necessarily, but *something*
20:57:45 <Cale> but I think Java actually might have fewer keywords than haskell
20:57:51 <palomer> Cale: probably
20:57:54 <jeffno> In Haskell, it's very Lispish.
20:58:05 <jeffno> You have to know what the n'th entry is in a list.
20:58:11 <Khisanth> depending on what you mean by keywords, Haskell could probably cheat :)
20:58:13 <Cale> yeah, I was going to say, if you want low keyword count, try scheme :)
20:58:25 <Frederick> Cale, Im 99% sure Im wrong but... is that what you meant by mapping over the results?           expandProd prods key result =  sequence (map prods results)
20:58:28 <Cale> jeffno: hm?
20:58:36 <wchogg> The thing I have had and still have trouble with in Haskell is figuring out how to do things without c style for loops.
20:58:46 <Cale> Frederick: almost, except that prods isn't a function
20:59:07 <dons> jeffno, the nth entry?
20:59:08 <Frederick> in fact map simplifier?
20:59:12 <palomer> they should make random access lazy lists
20:59:14 <jeffno> Looking at a line of Haskell code, it's all just a big list of words.
20:59:15 <palomer> who's with me?
20:59:27 <Frederick> palomer, im
20:59:28 <Cale> wchogg: well, you could write a C-style for loop combinator
20:59:42 <Cale> wchogg: of course, it would only apply in the IO monad
20:59:46 * palomer high fives Frederick 
21:00:10 <Cale> random access lazy lists?
21:00:16 <Cale> you mean, like Arrays?
21:00:24 <Cale> which Haskell already has? :)
21:00:39 <palomer> :o
21:00:43 <palomer> how does haskell deal with arrays?
21:00:44 <wchogg> Cale-What do you mean by a looop combinator?  I use "for = flip mapM" for alot of things, but it doesn't always work.
21:00:59 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
21:01:04 <Cale> immutable arrays there
21:01:12 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
21:01:15 <Cale> mutable arrays
21:01:24 <Khisanth> wchogg: seen http://www.haskell.org/~pairwise/intro/section4.html#part1 ?
21:01:27 <Cale> there are many many array types for different scenarios
21:01:35 <palomer> does haskell even try to establish referential transparency when it isn't obvious?
21:01:44 <Frederick> Cale, wich is this damm missing function?
21:01:51 <Cale> palomer: sometimes, see DiffArrays
21:02:04 <palomer> I mean ghc
21:02:11 <Frederick> do I need to write it? or it is recursive in the mean I can call simfplify again?
21:03:44 <Lokadin> yay!! :D
21:03:52 <Frederick> ??
21:04:25 <Cale> Frederick: it's not recursive
21:04:32 <Lokadin> i got listFoldl to work :D
21:04:34 <Lokadin> i mean r
21:05:06 <Frederick> this is wierd this is not an algorithm this is black magic like I cant believe this can be so hard and so trciky this isnt al algorithm this is at most an heuristic
21:06:45 <jeffno> The thing I find most disconcerting about Haskell is the lack of parens around function calls.
21:06:59 <dons> > id(2)
21:06:59 <Lokadin> jeffno: you can add them if you wish
21:06:59 <Cale> jeffno: I like that
21:07:00 <lambdabot> 2
21:07:09 <dons> > (id 2)
21:07:11 <lambdabot> 2
21:07:15 <dons> > (id(2))
21:07:16 <lambdabot> 2
21:07:27 <Cale> of course f (x,y,z) isn't the same as f x y z
21:07:29 <Frederick> Cale, do I need to create this new function?
21:07:35 <Cale> Frederick: yes
21:07:35 <wchogg> The reason why I like the syntax of haskell is because it looks more like mathematics.  It feels very familiar.
21:07:51 <Frederick> can I call it expand?
21:07:52 <dons> > (id(()))
21:07:54 <lambdabot> ()
21:07:54 <Khisanth> f(x(y(z)))?
21:08:08 <Cale> (((f x) y) z)
21:08:19 <Cale> ((f x) y) z = f x y z
21:09:02 <Cale> application is left-associative
21:09:15 <jeffno> I also hate the idiom for single letter variables :)
21:09:17 <Cale> all functions in Haskell are one-parameter
21:09:29 <Cale> jeffno: usually longer variables are inappropriate
21:09:59 <jeffno> It just gets so confusing, what is a parameter to a function and what's actually a function.
21:10:00 <Frederick> cale what a heck does this function have to do cause I seem to be creating tons of new functions with features I dont know and I habe like 3 hours before go university
21:10:02 <Cale> If your function is polymorphic such that you have no concept of what could be there, then it's inappropriate to have a name for it
21:10:06 <Frederick> I cant read all the stuff
21:10:11 <sethk> people seem to either use one letter, or 45 letters
21:10:17 <Cale> jeffno: functions can be parameters to functions
21:10:18 <sethk> there might be something reasonable in between.
21:10:24 <jeffno> Cale: Exactly!
21:10:30 <jeffno> That's why it gets so confusing.
21:10:35 <Cale> jeffno: that's a good thing!
21:10:35 <sethk> Cale, I don't think it makes sense to say that it _has_ to be one letter
21:10:41 <jeffno> No, confusing is bad!
21:10:44 <Cale> It's not confusing, it's nice
21:10:48 <sethk> Cale, that makes sense in an algebra with precise definitions, but it is overkill here
21:10:52 <jeffno> Higher-order good, hard to parse bad.
21:10:53 <Cale> functions are values just like anything else
21:10:57 <sethk> Cale, it isn't nice for those who don't already understand it.
21:11:04 <Khisanth> jeffno: everything is a function :)
21:11:09 <Cale> there's nothing special about functions
21:11:28 <sethk> Cale, there's nothing special about one character names
21:11:37 <Cale> yeah, you could formalise it by saying that other values are functions which don't take any parameters
21:11:38 <jeffno> But how do I know when a function is missing an argument, so it is another function, and when it has all it's arguments?
21:11:41 <sethk> Cale, "anytype" would do just as well
21:11:54 <Lokadin> say how in the world do you do foldl? i mean how to you get the last item first?
21:12:00 <Cale> jeffno: by looking at the type
21:12:13 <Cale> jeffno: or letting the compiler sort it out
21:12:16 <jeffno> Cale: But this is exactly the kind of thing I'd like to see by glancing at the code.
21:12:16 <dons> count the number of -> in the type
21:12:35 <jeffno> Which is why I don't like the minimalist approach to syntax.
21:12:37 <Cale> jeffno: how do you tell if you've given the right number of parameters in C?
21:12:40 <Cale> or Java?
21:12:49 <dons> you look up the man page ;)
21:12:53 <jeffno> But I know where the programmer *intended* the function to end.
21:12:54 <Cale> exactly
21:12:57 <Khisanth> the compile will complain :)
21:13:06 <Cale> This isn't specific to Haskell
21:13:09 <sethk> Cale, but in C you would have something like   FILE, not f
21:13:18 <jeffno> Open-paren, close-paren.  Function call done.
21:13:21 <Cale> sethk: the discussion changed topic :)
21:13:28 <sethk> Cale, yes, I know
21:13:32 <Lokadin> say how in the world do you do foldl? i mean how to you get the last item first?
21:13:40 <sethk> Cale, but cryptic is not necessarily better, even though it is less typing
21:13:44 <Cale> sethk: in Haskell, if you know that it's a file, the convention is to say so
21:13:59 <sethk> Cale, yes, I know.
21:14:01 <Cale> but if your function is polymorphic, as functions often are
21:14:03 <Cale> ...
21:14:19 <Lokadin> any ideas?
21:14:22 <Cale> then you often have no idea what sort of thing that parameter is
21:14:35 <sethk> Cale, right, so you can use a symbol that emphasizes that
21:14:44 <Cale> like 'x'
21:14:50 <dons> @type foldl
21:14:51 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
21:14:57 <Lokadin> Cale: how do i get the last variable first?
21:15:06 <Cale> Lokadin: the last variable first? :)
21:15:12 <Lokadin> Cale: for foldl
21:15:15 <Cale> you recurse right away
21:15:25 <sethk> cale, dons, ok, does that imply (the type of foldl) that a must be a different type than b?
21:15:26 <Cale> again, if I know what you're saying :)
21:15:42 <Cale> sethk: no, just means that they might be different
21:15:55 <sethk> confusing
21:15:57 <Frederick> Cale, in fact I think I already have the functio i need can I just call replace over results?
21:15:58 <dons> > foldl (\as b-> b:as) [] [1..10]
21:15:59 <lambdabot> [10,9,8,7,6,5,4,3,2,1]
21:16:02 <Cale> but you have no idea what they actually are
21:16:08 <Lokadin> how do you recurse right away? :| i mean don't they all recure right away?
21:16:11 <sethk> Cale, yes, of course, I understand that.
21:16:13 <Lokadin> recursE*
21:17:07 <Frederick> Cale, ?
21:17:17 <jeffno> Wouldn't Haskell be a lot easier for people to pick up if you could say something like " map ( :list = theList, :function = (? + 2) )
21:17:18 <Cale> Lokadin, in the cons case, foldl just calls itself with different arguments
21:17:54 <Lokadin> so f ((foldl xs) x) ?
21:18:06 <Lokadin> i mean f (foldl xs) x
21:18:10 <Cale> foldl f z (x:xs) = foldl ...
21:18:33 <Lokadin> o
21:18:36 <dons> thankfully haskell doesn't have such syntax, jeffno, or I would cry every day.
21:18:38 <Lokadin> thanks 
21:18:44 <Frederick> Cale, expandProd prods key result =  sequence (map replace results)
21:18:54 <Cale> jeffno: if it looked like that, my hands would be broken :)
21:18:57 <Cale> heh
21:19:10 <Khisanth> jeffno: way too much typing
21:19:22 <Cale> Frederick: something like that, I don't know what replace is.
21:19:23 <jeffno> IDEs and auto-completion.
21:19:48 <Khisanth> so that is why there are so many Java IDEs :)
21:19:48 <Cale> actually more likely you want to pass along prods and key to replace
21:20:00 <lisppaste2> Frederick pasted "repalce" at http://paste.lisp.org/display/14077
21:20:10 <Cale> jeffno: one shouldn't rely on IDEs to fix broken languages
21:20:10 <Cale> :)
21:20:21 <jeffno> Not broken, readable!
21:20:28 <Cale> map f xs is readable
21:20:37 <Frederick> Cale, if you are an expert
21:20:38 <jeffno> No, its pure gibberish.
21:20:44 <jeffno> Looks worse than Perl!
21:21:02 <Cale> I immediately know that there's a function called f, and a list called xs, and f is getting applied to each element of xs
21:21:23 <jeffno> Cale, the language shouldn't just be for people proficient in it.
21:21:28 <Cale> just because the map is sitting there
21:21:30 <Frederick> jeffno, amem
21:21:38 <Cale> no, it really should be :)
21:21:44 <Cale> Try this with C
21:21:46 <sethk> jeffno, it is hard to learn to read these, but it isn't impossible
21:21:46 <Cale> hehe
21:21:53 <Khisanth> actually map f xs looks the same as Perl minus the sigils :)
21:22:00 <sethk> jeffno, the difference with Perl is that, even when you understand it, Perl is gibberish.  :)
21:22:10 <dons> I wish C and Java hadn't broken so many people''s brains.
21:22:15 <Cale> Sit a complete novice down in front of a bunch of Java code and get them to try to read it
21:22:22 <sethk> jeffno, you can always rewrite the type with longer names, which I in fact sometimes do.
21:22:36 <jeffno> It's not just the names, it's also the lack of syntax.
21:22:40 <Cale> They'll have just as much, if not more trouble than reading a Haskell program
21:22:42 <Frederick> Cale, did you see my last post?
21:22:58 <Cale> replace has obviously the wrong type
21:23:00 <sethk> jeffno, well, that's not quite true.  There is no lack of syntax, there is just a lack of sugar.
21:23:06 <Frederick> bah this is impossibler
21:23:13 <jeffno> seth, that is of  course my meaning.
21:23:14 <sethk> jeffno, which, once you get used to it, is a definite advantage
21:23:24 <jeffno> My point is one shouldn't *have* to get used to it.
21:23:26 <sethk> jeffno, I know, but the difference is important
21:23:40 <jeffno> Readability is important for people who don't live and breath the language.
21:23:41 <sethk> jeffno, well, should?  shouldn't?  What syntax would be better?
21:23:45 <Cale> jeffno: some people complain that Haskell has *too much* syntax sugar
21:23:46 <dons> jeffno, why? because you learn Java or soemthing first?
21:24:01 <jeffno> dons, no, because maybe I want to learn lots of languages.
21:24:02 <wchogg> Cale-Those people are probably old fans of lisp.
21:24:02 <Cale> I've seen people complain that 'if' shouldn't be a keyword
21:24:19 <Frederick> oki cale can you actually do i for me? Im trying for more than 10 hours to have it done and I need to go class in like 2:30 hours
21:24:20 <dons> you want to learn lots of languages, but they all must have the same syntax?
21:24:22 <jeffno> Who says I'm going to program in haskell all day?
21:24:29 <jeffno> dons, they need *readable* syntax.
21:24:41 <jeffno> I looked at J and I ran screaming for the hills!
21:24:45 <Cale> jeffno: Haskell is the most readable programming language I've come across
21:24:49 <sethk> jeffno, seriously, what syntax would be more readable?
21:25:00 <Frederick> Cale, look pascal
21:25:01 <jeffno> Cale: But only if you know it well.  It is hard to read if you don't.
21:25:04 <Cale> and I know 15 or 20 programming languages reasonably well
21:25:07 <sethk> jeffno, I'm not sure what would make it less confusing.
21:25:13 <jeffno> sethk: I already gave my example.
21:25:25 <sethk> jeffno, I missed it, can you paste it in again?
21:25:25 <yaarg> Perl is easiest. :P
21:25:30 <yaarg> It just looks like a novel
21:25:33 <jeffno> map ( :list = theList, :function = (? + 2) )
21:25:35 <sethk> yaarg, please.  :)
21:25:39 <Cale> Perl is easy to write and hard to read
21:25:41 <sethk> yaarg, at least go with Python    :)
21:25:48 <wchogg> jeffno-I honestly think that's harder to read.
21:25:51 <Cale> jeffno: that's not more readable
21:26:02 <Cale> also, the ? syntax is confusing
21:26:03 <dons> jeffno, please go and write a desugarer from your arbitrarily verbose syntax to haskell -- then you can program in glue all day long ;)
21:26:07 <sethk> jeffno, that's just names, and I agreed with you earlier that longer names would be better
21:26:17 <dons> it would only be a few hundred lines of haskell to program..
21:26:28 <sethk> jeffno, but except for the :, and god knows what that is for, it isn't syntax
21:26:29 <jeffno> dons: I've been considering it, but that's a bit much to just learn and code in Haskell :)
21:26:51 <jeffno> seth, it uses the idea of Lisp's keyword parameters.
21:26:54 <jeffno> Which I really like.
21:26:55 <sethk> jeffno, hey, there are a million other languages around; you can find one that is more to your liking I'm sure.
21:27:10 <jeffno> But I want to learn the One :)
21:27:14 <sethk> jeffno, I like keyword parameters also, but they don't fit into the underlying mathematical model of haskell.
21:27:22 <Cale> jeffno: I recommend writing Haskell code for a few months and see if you don't change your mind, and if you don't, you should be skilled enough to write a compiler for your new language :)
21:27:28 <yaarg> Python is no fun. :(
21:27:31 <sethk> jeffno, but a preprocessor for keyword parameters would be great.
21:27:35 <wchogg> jeffno-But if you're happy with the way lisp does it, why not stick with that?  It is the most flexible language out there.
21:27:46 <jeffno> Cale: I know after a few months I will be used to it, but it just sucks getting there.
21:27:54 <Cale> If you want keyword parameters, why not just use record types?
21:27:58 <sethk> jeffno, but you do have to give your mind a bit of time to reorient.  By the way, I use several languages every day.
21:28:07 <jeffno> Most functions don't take records.
21:28:08 <sethk> Cale, that's a good point too
21:28:16 <sethk> jeffno, write a wrapper that does
21:28:31 <sethk> jeffno, but give it a chance, don't reject it out of hand.
21:28:36 <Frederick> Cale, should i give up?
21:28:49 <sethk> Frederick, no, of course not.
21:28:53 <Cale> Frederick: no! It's really easy, I just don't want to give it away
21:28:54 <sethk> Frederick, how long have you been trying?
21:29:01 <jeffno> I haven't rejected it, but I'm just saying that lack of readability is probably a good reason people get turned away.
21:29:03 <Frederick> sethk, +- 10 hours
21:29:10 <Cale> there's no further hint I could give you without just typing up the solution and handing it in for you
21:29:14 <sethk> Frederick, no, give it more time than that
21:29:15 <jeffno> Not only are the new concepts hard, but the syntax makes it even harder.
21:29:23 <Frederick> sethk, I got only more 2 hours
21:29:27 <sethk> Cale, well, a working example is actually often the best explanation.
21:29:35 <Cale> jeffno: I don't think the syntax is any harder than Java's
21:29:43 <Frederick> sethk, Ive beeing trying the whole thing for 3 weeks
21:29:56 <jeffno> Cale: It is because Java has more things to grab onto.
21:30:01 <Cale> Java syntax doesn't tell you what each parameter is in a labelled, unordered fashion, and people get along just fine
21:30:03 <sethk> Frederick, you have a grasp of much of it; I can tell by the questions you ask.
21:30:06 <Cale> what do you mean?
21:30:19 <jeffno> Cale: But in Java there's a () to say when the function ends.
21:30:20 <Frederick> sethk, what do you mean?
21:30:22 <Cale> "more things to grab onto"?
21:30:31 <wchogg> jeffno-I'm not sure if it is really that much harder to read for someone who isn't programmed to think in c-derivative languages.  My wife finds haskell easier to understand that java because she didn't learn java first.
21:30:36 <Cale> the function ends?
21:30:41 <sethk> Frederick, that you shouldn't give up because you understand a lot of it already and you are close to where you need to be.
21:30:42 <Cale> what?
21:30:44 <wchogg> jeffno-So the problem is the fact that it uses whitespace like python?
21:30:44 <jeffno> Like when Java added parmeterized type, they use "<>" for the type variable.
21:30:54 <sethk> jeffno, you should use the explicit form of the language, not the indentation delimited form
21:30:57 <jeffno> The "<>" is something I can immediately spot.
21:31:03 <sethk> jeffno, the end of a function is exactly the same as in java that way
21:31:06 <Cale> so?
21:31:13 <jeffno> What do you mean so?
21:31:14 <Frederick> sethk, I got only more2:30 mins
21:31:18 <Cale> Wouldn't you spot the type parameter anyway?
21:31:23 <Frederick> and Im probably sitting on the solution
21:31:27 <sethk> Frederick, then I can't really advise you.
21:31:30 <Frederick> but hell I cant grab it
21:31:32 <jeffno> But in Haskell, it's the 2nd item in a list.
21:31:37 <sethk> Cale, at times giving the solution is not the wrong thing to do.
21:31:43 <Cale> Like, in Haskell, it's hard to confuse  (Tree) and (Tree Integer)
21:31:46 <jeffno> And everything in Haskell looks like a list of terms.
21:31:59 <sethk> jeffno, indeed.  that's because everything is.
21:32:16 <sethk> jeffno, you don't really want it to like other than what it is, do you?
21:32:22 <sethk> look, not like.  :)
21:32:24 <dons> > let { myLongUglyFun(x) = x + x; somethingElseSucky(y) = y * 2; } in myLongUglyFun(2)
21:32:25 <sethk> or look like
21:32:25 <lambdabot> 4
21:32:50 <dons> write your code like that, and then you're kicked out of the haskell club
21:33:01 <sethk> dons, I like that, although the names could possibly use some work.  :)
21:33:14 <dons> oh, I forget to add type annotations all over the place!
21:33:23 <dons> stupid type inference infecting my brain
21:33:26 <dons> ;)
21:33:26 <jeffno> Writing single letter variables means I have to translate in my head.  It slows me down.
21:33:39 <sethk> dons, actually, the books all recommend adding type annotations at least sometimes.
21:33:41 <wchogg> Then don't use single letter variables.
21:33:43 <jeffno> I much prefer code that I can *read*.
21:33:45 <sethk> jeffno, so rewrite
21:34:01 <jeffno> But there is the Haskell idiom to contend with.
21:34:08 <jeffno> I'm not just writing code, I'm reading others code.
21:34:17 <dons> sethk, I always add type sigs to top level funs, rarely in let-bound fns
21:34:23 <dons> unless they use IO
21:34:25 <Cale> Frederick: okay, here's what the function does: it takes: a production Map called prods, the name of the current nonterminal called key, and a Symbol x, and produces a list of symbols. If the input symbol x is a terminal, or if x == key, then it returns [x]. If it's a nonterminal, then it looks up the nonterminal in the map called prods, and it returns the list obtained from that
21:34:26 <sethk> jeffno, it's work, that's true.  You have to decide whether it is worth the effort
21:34:49 <dons> now I am sick: let { myLongUglyFun(x :: Int) = x + x :: Int; somethingElseSucky(y :: Int) = y * 2 :: Int; }
21:34:53 <sethk> Cale, good.
21:34:54 <jeffno> I'm just explaining why the syntax is off-putting to someone just coming to the language..
21:35:01 <dons> but maybe jeffno, that's got enough stuff to hang on to?
21:35:05 <sethk> Cale, that's concise but easier to read.
21:35:36 <dons> just pretend type inference and layout were never invented!1
21:35:44 <Cale> heh
21:35:45 <sethk> Cale, and working examples really do help.  That's my only real disagreement on this issue, I want to see many more maximally simple working examples in the documentation.
21:35:59 <dons> and when the types don't match, use a coerce!
21:36:04 <sethk> dons, for a beginner to put off learning indentation, vs explicit {} and ;, is not a bad idea.
21:36:06 <dons> then it's *just like C*!!
21:36:12 <Cale> sethk: I really want to see the documentation improve too
21:36:18 <Khisanth> jeffno: hmm what makes you think people are turning away from Haskell anyway?
21:36:27 <Cale> sethk: I think that when fptools properly moves to darcs, we'll see a lot of improvement
21:36:27 <sethk> Cale, I'm still trying to make my monad thing useful.  :)  It's tough.
21:36:36 <Cale> sethk: :)
21:36:43 <sethk> Cale, I think that's true; a lot of this is due to machine generated docs.
21:36:54 <jeffno> Khisanth: For one, it's hardly mainstream after over a decade.
21:37:08 <rt> s/hardly/no where near/
21:37:11 <jeffno> For two, I have my own experience, and I can't believe it is unique.
21:37:12 <Cale> sethk: well, the fact that they're machine generated isn't so much the problem as the code isn't literate enough :)
21:37:17 <dons> jeffno chooses today to battle the haskell community
21:37:26 <jeffno> Not battle, engage :)
21:37:31 <dons> kick their stupid lambdas back to the 1930s!
21:37:42 <wchogg> Why the '30s?
21:37:44 <sethk> Cale, yes, I suppose.  :)
21:37:44 <dons> and type inference -- dumb dumb dumb
21:37:48 <Cale> jeffno: really, Haskell has only been anywhere close to ready for mainstream use in the last year or two.
21:37:49 <jeffno> I'm just relating my experience, dons.
21:37:54 <sethk> BBL, 'night all
21:37:58 <dons> wchogg, Haskell worked on lambda calc in the 30s
21:38:05 <wchogg> Ah.
21:38:23 <dons> night sethk
21:38:37 <Cale> jeffno: and I'm personally of the opinion that it shouldn't do anything to *try* to go mainstream.
21:38:42 <Cale> if it happens, it happens
21:38:57 <Cale> but it has as many problems as it does benefits
21:39:09 <dons> either way, we keep programming happy, pretty, non-crashing programs, eh Cale?
21:39:10 <wchogg> Cale-What problems?
21:39:12 <Cale> mainstreamness means people complain when you change the language
21:39:30 <Frederick> Cale, I give up
21:39:33 <Frederick> gtg sleep
21:39:33 <Cale> which means that if problems become obvious, you can't fix them
21:39:37 <dons> and about why the syntax doesn't look like java.
21:39:43 <Cale> heh
21:39:53 <Cale> like the current Prelude
21:39:57 <jeffno> dons, you are totally misunderstanding my argument.
21:40:03 <Cale> it's nice, but I certainly don't want it to stay that way
21:40:25 <Cale> I want map :: (Functor f) => (a -> b) -> (f a -> f b)
21:40:39 <Cale> and class (Functor m) => Monad m where...
21:40:58 <dons> I'm just making fun of the rather, hmm, assertive way you have been discussing things jeffno ;)
21:41:11 <Frederick> folks good night
21:41:23 <jeffno> dons, cut and paste something I've said that bothers you.
21:41:55 <dons> hehe, it needn't come to scissors!
21:42:07 <Cale> hehe
21:42:10 <jeffno> No, please back up what you say.
21:42:56 <jeffno> G'night Frederick, and good luck!
21:43:07 <Cale> Frederick: 'night, good luck
21:43:33 <sethk> jeffno, well, remember that confusing is clearly in the mind of the beholder.
21:43:40 <sethk> jeffno, things like that.
21:43:53 <jeffno> sethk, did you not find it confusing when you first learned it?
21:44:00 <sethk> jeffno, absolutely
21:44:01 <Frederick> my luck is gone
21:44:05 <dons> there's just been a general tone of "i don't undertand such-and-such. therefore your language sucks". sometimes people come here with that frame of mind, and it can be tedious.
21:44:05 <Frederick> I will fail the class
21:44:05 <jeffno> absolutely not?
21:44:08 <sethk> jeffno, still do at times
21:44:18 <sethk> jeffno, absolutely I found it confusing.
21:44:26 <sethk> jeffno, ask Cale; I was much worse than you.  :)
21:44:32 <Cale> hehe, "map ( :list = theList, :function = (? + 2) )" -- that was kind of awful ;)  You realise that you just turned 16 keystrokes into 44 ?
21:44:36 <sethk> jeffno, but I kept hammering.
21:44:46 <sethk> jeffno, because it is worth the effort
21:44:50 <Frederick> btw this crap was an assigment for 3 ppl groups I had to do this crap "alone"
21:44:53 <jeffno> dons, I never said it sucks, I said the problems I am having trying to learn it and suggest others probably have the same problems.
21:44:54 <sethk> jeffno, because the other languages are fatally flawed
21:45:07 <Cale> and the code was pretty readable before
21:45:12 <Cale> map (+2) theList
21:45:16 <sethk> jeffno, indeed, you are correct, many if not most others have the same problems.
21:45:26 <dons> ok jeffno, maybe  just be aware of your tone then.
21:45:32 <sethk> jeffno, have you tried either of the books on Haskell?  Both are excellent.
21:45:34 <jeffno> I'm glad to hear you say so, sethk, thank you.
21:45:41 <wchogg> sethk-How are other languages fatally flawed?
21:45:43 <Cale> Also, note that people get by in italian just fine without too many braces and parens and such
21:45:57 <Cale> Or English, for that matter
21:46:02 <jeffno> dons, and you likewise.  You are very defensive, whereas Cale is not.
21:46:04 <sethk> wchogg, by other languages I mean the common ones in commercial use.  Obviously I don't know every language
21:46:21 <sethk> wchogg, but I am very interested in reliability and predictability and stability
21:46:41 <sethk> wchogg, and languages like c/c++, java, csharp, etc., have big problems in those areas.
21:46:49 <jeffno> sethk: I've been reading tons of online stuff, and also have been going the Craft of Functional Programming (Miranda though)
21:46:57 <wchogg> sethk-So were there languages other than those you considered sinking your time into?
21:47:10 <wchogg> sethk-What made you decide on haskell?
21:47:13 <sethk> wchogg, sure.  I spent some time with ocaml, but I hate the syntax
21:47:19 <dons> ok.  maybe 8 hours of haskell hacking gives me a shorter fuse.
21:47:34 <Cale> dons: working on hmp3?
21:47:36 <dons> have some code as a peace offerring: www.cse.unsw.edu.au/~dons/hmp3.html
21:47:38 <wchogg> sethk-I agree with that on ocaml.  I wanted something fast, but it "feels" bad.
21:47:39 <sethk> wchogg, and I've done extensive programming in python, ruby, and csharp lately, purely for investigational purposes.
21:47:41 <dons> Cale, right ;)
21:47:58 <wchogg> sethk-I like ruby.  It's what got me into common lisp.
21:47:59 <Cale> the biggest problem with ocaml is lack of typeclasses
21:48:08 <sethk> wchogg, I like many things about ruby, yes.
21:48:09 <Cale> resulting in ugly operators
21:48:12 <wchogg> Cale-Hence the + vs. +. right?
21:48:15 <Cale> yeah
21:48:15 <jeffno> ok dons :)
21:48:27 <Cale> (from the syntax perspective anyway)
21:48:36 <wchogg> Yeah, that was a big turnoff for me with ocaml.  I still wonder if I should give it more of a shot though.
21:48:44 <Cale> from the semantics perspective, well, ocaml has some neat stuff
21:49:09 <Cale> but I don't see it as different enough from Haskell to switch
21:49:09 <sethk> wchogg, it has its advantages.  It think though that with the object extension it is off into never-never land
21:49:16 <Cale> and I have a hard time with strict evaluation
21:49:19 <sethk> wchogg, but that's just my opinion
21:49:33 <wchogg> sethk-What do you mean?
21:49:39 <Cale> honestly, I find it quite hard to program with strict evaluation now :)
21:49:41 <sethk> wchogg, I always say I want to learn as many languages as I can; rather, as many language families as I can.
21:49:42 <wchogg> Cale-Lazy evaluation seems rather addictive.
21:49:46 <Cale> wchogg: yeah
21:49:59 <sethk> wchogg, with the object extension you get behavior with the type inference engine that I consider unacceptable.
21:50:04 <Cale> see, if you only do strict evaluation things in a lazy language, it will mostly work
21:50:10 <sethk> wchogg, but engineering is all about tradeoffs.
21:50:18 <Cale> if you do lazy evaluation things in a strict language...
21:50:52 <wchogg> Are there features in ocaml that would be nice to have in haskell?
21:51:07 <Cale> The module system seems nice
21:52:01 <Cale> they have parametric modules
21:52:20 <Cale> which they confusingly call functors
21:52:35 <wchogg> I don't really understand that myself, Cale.
21:52:48 <wchogg> Of course, I only spent a few hours with ocaml.
21:53:46 <sethk> Cale, I do very much like that ocaml feature. 
21:54:02 <sethk> Cale, I thought perhaps TH was similar, but it looks much too much like c++ templates for me to use.
21:54:56 <sethk> Cale, which is I admit a rather emotional reaction.  :)
21:55:00 <Cale> I kind of dislike TH. It's a bit too syntax-driven. It's better than the C preprocessor, I suppose.
21:55:06 <wchogg> My time is generally divided between haskell and common lisp.  I really do like lisp, but it doesn't seem to be developing at the rate Haskell is.  It doesn't seem to be really growing.
21:55:36 <jeffno> wchogg, does the lack of typing in Lisp bother you?
21:55:37 <Cale> wchogg: I wrote a bunch of code in CL a while back and was very frustrated
21:56:10 <wchogg> jeffno-Not really no.  You can test it so quickly it doesnt' seem like too much of an issue.  Besides, it can be typed if you want to be verbose.
21:56:17 <wchogg> Cale-What frustrated you?
21:56:23 <Cale> lack of static typing and functions being treated differently from other values mostly
21:56:40 <wchogg> Cale-Ah, ' versus #' and things like that?
21:56:44 <Cale> yes
21:57:05 <Cale> I got used to it to some extent, but it was always annoying to have to type funcall
21:57:26 <Cale> and no currying is also irritating
21:57:26 <wchogg> Cale-Yeah, that's one of my only real complaints about it.  I really wish there were a new lisp standard in the works.  I haven't heard of one though.
21:57:31 <Cale> but I can live with it
21:57:54 <Cale> like, you end up with a million lambdas because functions aren't curried
21:58:13 <Cale> how about scheme?
21:58:22 <Cale> scheme seemed a good deal nicer to me
21:58:38 <wchogg> I've never really tried scheme.  I thought macros didn't work the same in scheme though?
21:58:55 <Cale> well, they're not entirely standard, I don't think
21:59:09 <Cale> I think they're semantically mostly the same though
22:00:03 <Cale> what do you use macros for?
22:00:31 <wchogg> Not much, actually.  I've never used lisp for a big project though.
22:00:45 <Cale> I used a macro to simulate the state monad in my project.
22:01:00 <Cale> rather than write a full blown monad syntax :)
22:01:06 <Cale> (like do)
22:01:19 <wchogg> So you made state explicit?
22:01:27 <Cale> oh, yeah
22:01:33 <Cale> all my functions were pure
22:02:02 <wchogg> Did you just want to do it that way or was there a big advantage?
22:02:12 <Cale> there's always a big advantage
22:02:19 <Cale> referential transparency.
22:03:04 <wchogg> Now does that mostly make a difference in how easy it is to write code or how easy it is to understand later?
22:03:37 <Cale> how easy it is to test code, think about the code while writing it, and understanding it later
22:03:45 <rt> frankly, i think in most cases it's neither.
22:04:29 <Cale> The difference between referentially transparent code, and stateful code is like night and day to me.
22:04:52 <wchogg> Yeah, but haven't you ever wanted to be impure to make something convenient?
22:04:59 <rt> there is plenty of code with referential transparency which is a nightmare to understand, and plenty without that is entirely straightforward.
22:05:33 <wchogg> rt-Are you just talking about well written vs. badly written code or something intrinsic to forcing explicit state?
22:05:44 <rt> both.
22:06:28 <Cale> State immediately imposes temporal reasoning on things
22:06:38 <jeffno> I came to Haskell because I got tired of wondering "I wonder what evil side effects this function call hsa".
22:06:46 <rt> the problem with many of the more obscure languages is that it's hard to actually find significant projects that demonstrate good style and reasonable performance.
22:07:27 <rt> jeffno: well, if the side effects weren't needed, nobody was really twisting your arm to put them in.   If they were needed, I'm not sure how a language that disallows them makes your job easier.
22:07:28 <Cale> well, look at most any significant Haskell project
22:07:30 <wchogg> I think my biggest problem with having explicit state is the reliance on recursion it imposes.  I find recursion harder to think in than iteration.
22:07:46 <Khisanth> d'oh! missed the "Solutions to Exercises" section in YAHT >_<
22:07:47 <Cale> wchogg: I'd rather think in neither
22:07:57 <rt> cale: well, there really aren't very many significant haskell projects.   That's really rather the point.
22:08:05 <wchogg> Cale-What do you mean?
22:08:07 <Cale> Higher order functions are what you really want :)
22:08:24 <wchogg> Cale-That isn't always the most natural way to do things though.
22:08:29 <Cale> you implement them however, and then you don't think about the recursion or iteration that's going on
22:08:54 <palomer> wchogg: start doing things this way and you'll see that many times it is really the most natural way to do things
22:09:34 <dons> rt, did you read the community report that came out last week? there's quite a number of new interesting projects
22:09:44 <palomer> url?
22:09:48 <rt> url?
22:09:49 <dons> and there's always pugs to go and read.
22:09:54 <dons> @where hacr
22:09:55 <lambdabot> I know nothing about hacr.
22:09:58 <dons> @where hcar
22:09:59 <lambdabot> http://www.haskell.org/communities/
22:10:16 <dons> you could try lambdabot:
22:10:18 <dons> @version
22:10:19 <lambdabot> lambdabot 3p196, GHC 6.5.20050806 (Linux i686)
22:10:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:10:29 <jeffno> I'm new to IRC.  What's this "@..." stuff?
22:10:35 <Khisanth> dons: assuming one is interested in writing compilers? :)
22:10:43 <dons> and, off the top of my head, ghc has 1/4M loc. so that's fairly significant..
22:10:48 <Khisanth> jeffno: just one of many ways to give commands to bots
22:10:49 <Cale> My friend, who, truth in advertising, is a mathematician, had the following comment about Haskell, after I taught him a bit: "Haskell is a lot more like real life thinking than other programming languages. When I want to wash the dishes, I don't assign them all numbers, and increment a counter and use a loop, I just wash all the dishes: map wash dishes."
22:10:59 <dons> then pugs, also darcs. yi is fun
22:10:59 <dons> dazzle, visual haskell. hmm. 
22:11:03 <Khisanth> err to indicate a command to a bot
22:11:16 <Khisanth> . and ! are also commonly used
22:11:28 <palomer> HaRP looks really cool
22:11:31 <jeffno> Ah, ok.  I have lambdabot ignored, so I never see the result.
22:11:42 <Cale> jeffno: you probably shouldn't :)
22:11:58 <jeffno> Cale, I wouldn't mind useful info, but it's usually too much noise.
22:12:29 <dons> oh, there's also Frag.
22:12:31 <dons> @where Frag
22:12:32 <lambdabot> http://www.cse.unsw.edu.au/~pls/repos/frag
22:12:36 <rt> the strangely disturbing thing about haskell projects are that they all seem to center around haskell.
22:12:42 <dons> and these are just things that have appeared in the last few months.
22:12:49 <dons> @hawiki Frag
22:12:50 <Cale> rt: um...
22:12:50 <lambdabot> http://www.haskell.org/hawiki/Frag
22:13:04 <dons> if killing evil robots is haskell-centred...
22:13:11 <Cale> hehe
22:13:15 <dons> or evaluating perl. hmm.
22:13:19 <jeffno> What about the Haskell File System?
22:13:34 <dons> yeah, just a normal fs.
22:13:43 <rt> there are counter examples, but way fewer than other languages.
22:13:43 <dons> or try House, an operating system
22:13:57 <wchogg> A haskell based operating system?
22:13:57 <Cale> Yeah, evaluating perl is a nice example of an obviously Haskell-centred project. Obviously, we're just trying to convert all the perl people into Haskell people.
22:14:00 <rt> tell me, why would anyone run House?
22:14:09 <rt> what possible reason could there be?
22:14:23 <jeffno> See dons, now rt I think is being much more abrasive than I was :)
22:14:29 <Cale> rt: why would anyone run any operating system?
22:14:36 <dons> why not? you like hacking OS code? think about it...
22:14:48 <dons> jeffno, right ;)
22:15:05 <Cale> "I just flip the switches on the front of my box, and read the lights."
22:15:12 <rt> there are gazillions of people who run Linux who can't program in C and don't care to. 
22:15:31 <rt> Of what benefit could a Haskell operating system be to those kind of people?
22:15:39 <palomer> anyone here tried generic haskell?
22:15:47 <Khisanth> rt: but they actually care what language Linux is written in?
22:15:47 <dons> i'm not sure converting the masses is the goal of every project, rtt.
22:15:52 <Cale> rt: an OS with verifiable semantics perhaps?
22:15:56 <rt> if writing an os in haskell doesn't yield benefits for them, why bother doing it?
22:16:05 <jeffno> I'd hope the Haskell OS was more stable and secure.
22:16:14 <dons> heh. please don't go into research, rt.
22:16:31 <rt> you can make any OS secure if it doesn't do very much or support very much hardware.
22:16:38 <Cale> Verifiable semantics, and strongly typed data representation at the OS level.
22:16:56 <jeffno> rt: Think buffer overflows.
22:17:17 <rt> that has been the promise since I was gumming my food.  It still seems very far away.
22:17:20 <Cale> I'd love an operating system with statically typed programs.
22:17:34 <rt> buffer overflows are idiocy.  You dont need to go to haskell to solve those.
22:17:37 <dons> there's been a lot of progress in the last 5 or so years.
22:17:44 <dons> people do verify kernels now
22:17:54 <jeffno> rt: But it shows how a language you choose can effect the outcome.
22:18:55 <rt> well, of course it can.  As can virtually every other design choice you make.
22:19:01 <sethk> rt, I'd say that other languages are more error prone, even if you don't do the totally stupid things that allow things like buffer overflows.
22:19:12 <sethk> rt, you are always better off in an environment where it can't happen.
22:19:20 <Cale> rt: It seems to require leaving C, because it only takes one programmer in C who doesn't know what they're doing to create lots of security risks in the code, and there's essentially no way that invariants like that can be statically enforced without sophisticated additional tools that basically amount to using another programming language anyway.
22:19:26 <rt> the question is, what does it cost you?
22:20:05 <rt> there is no substitute for knowing what you are doing, no matter what language you use.  
22:20:18 <jeffno> Cale says it very nicely.
22:21:27 <Cale> There is a substitute for a lot of stupid mistakes. It's called having the compiler enforce invariants via the typesystem.
22:21:39 <rt> i see no reason to believe that programmers of equal experience level generate better haskell programs than they do C programs.
22:21:40 <Cale> C does this already to some small extent, it's just not enough.
22:21:47 <dons> why do people get the idea that it's bad to automate the dull tasks? like checking types?
22:21:59 <dons> if not for automation, we'd still be programming in binary
22:22:08 <palomer>  we should have other ways of forcing invariants
22:22:27 <jeffno> rt, what's your language of choice?
22:22:36 <rt> I've been programming C for twenty years.   I just don't ever have type errors.  It just not a problem.   There are many _other_ kinds of problems that are common, but typing isn't oen of them.
22:22:56 <dons> you have to type more code to get the same tasks done. that's a waste of your time.
22:23:18 <Cale> rt: you might not have C type errors, however, you may have errors which would be type errors, were the C type system more expressive
22:24:04 <rt> when all you have is a hammer everything looks like a nail.  People like to pretend that polymorphic typing solves all sorts of problems, but the reality I think is much less obvious.
22:24:07 <Cale> You probably even make lots of runtime bugs which would have been compile time errors were there more powerful types.
22:24:18 <Cale> It's not just polymorphic typing
22:24:27 <dons> i just don't understand why people don't want things checked for them. it's like it's an insult to have a program criticise their code.
22:24:55 <flux__> rt, I infact have noticed, after learning ocaml and haskell, that there have been type-related bugs in the C-programs (at work). I hadn't noticed that before.
22:24:56 <rt> no, frankly I love it when my compiler checks things for me.  
22:25:00 <palomer> and often times you don't need to type more, everything is infered 
22:25:13 <Cale> Even Haskell's type system is not as strong as one might want it, but it's stronger than most common languages by far.
22:25:20 <rt> and I don't mind being more verbose for the sake of clarity.
22:25:40 <flux__> (well, whathesaid, they wouldn't have been there had the type system had more expressivity)
22:26:39 <Cale> The type system is basically the name for the compiler code-invariant checking system, whatever that happens to be. If you have a kind of compiler-enforced invariant in your language, it might as well be considered a type.
22:27:17 <tic> there's a nice paper on types and such I started reading yesterday
22:27:35 <tic> http://citeseer.ist.psu.edu/cardelli85understanding.html
22:29:01 <tic> http://www.risc.uni-linz.ac.at/education/courses/ss98/types/understand/slides-main.ps.gz
22:30:09 <jeffno> Survey papers are the best.
22:30:38 <fworp> is polymorphic typing really all that specific of an abstraction? I mean, having the hammer is better than just not having a hammer. What is the trade off?
22:30:41 <Cale> I've written a pipeline scheduler and register allocator for PPC+Altivec code in Haskell. The code was about 1200 lines and 50% of that was documentation (it was literate code). My supervisor had been a C programmer for a long time, and commented that to do the same thing my program did in C would have been 15000 lines of code. I don't think I could have even written it.
22:31:07 <Cale> The type system helped immensely. Especially things like typeclasses.
22:31:54 <Cale> I'd wonder why some type error was happening and find out that the reason was that I'd made a major error in my thinking about the algorithm, and once I corrected that, the code generally worked.
22:32:02 * rt isn't really trying to pick a fight.
22:32:32 <Cale> There were only one or two bugs in the code which made it through to runtime, and referential transparency was absolutely insanely valuable in debugging.
22:32:44 <tic> what's "referential transparency" ?
22:33:02 <Cale> the property that a function gives the same result when passed the same arguments
22:33:04 * palomer takes this outside
22:33:14 <palomer> why is it called referential transparency?
22:33:15 <Cale> and generally, that it has no side effects
22:33:19 <tic> Cale, ah, yes, no side effects.
22:33:24 <jeffno> Ah, the very question I had, palomer.
22:33:35 <palomer> can you ask ghc if a function is referentially transparent?
22:33:36 <wchogg> Well, I think it's more that there's no implicit side effects.
22:33:41 <ozone_> Cale: are you wolfram, by any chance?
22:33:45 <Cale> Becuase the function is the same regardless of where you refer to it.
22:33:47 <ozone_> oh, no, you're not
22:33:51 <Cale> ozone_: wolfram?
22:33:51 <ozone_> never mind me, my brain's in lala land
22:34:00 <Cale> as in Dr. Kahl?
22:34:05 <rt> basically, in a language like C, if you see a call to a function foo(3), it might return a different value even when passed the same argument.
22:34:13 <ozone_> Cale: sorry, wolfram's another person who's writing a pipeline scheduler for PPC (at mcmaster university in canada)
22:34:18 <ozone_> oh, not wolfram
22:34:20 <ozone_> one of his other students
22:34:23 <ozone_> never mind me :)
22:34:26 <Cale> Wolfgang?
22:34:32 <Cale> I did this at McMaster
22:34:33 <ozone_> one of wolfgang's comrades at mcmaster
22:34:39 <ozone_> oh!
22:34:39 <rt> in a language with referential transparency, that can't happen.
22:34:41 <Cale> me :)
22:34:43 <Cale> hehe
22:34:47 <ozone_> ok, so i'm not totally stupid
22:34:50 <palomer> wolfram is an idiot
22:34:53 <ozone> anyway :)
22:35:00 <Cale> palomer: different wolfram
22:35:00 <ozone> say hello to wolfgang if he's around
22:35:01 <rt> there are no stupid questions.   Only stupid people. :-)
22:35:02 <dons> wolfgang, and wolfram? sounds like a conspiracy
22:35:10 <Cale> ozone: that was a while back that I was working there
22:35:11 * rt ducks.
22:35:20 <ozone> dons: i hear chilli likes this band named "wolfmother"
22:35:23 <Cale> I'll have to call them up and see if they'd like to hire me again :)
22:35:28 <ozone> i reckon there's something going on
22:40:10 <wchogg> I'm trying to think of a clean way to swap two elements of a list, got any ideas?
22:40:36 <dons> which two elements?
22:40:59 <wchogg> Arbitrary.
22:41:15 <dons> by index, or by == ?
22:41:34 <wchogg> By index.
22:41:38 <Cale> wchogg: If by index that's going to be O(max{n,m}) where n and m are the positions of the list elements to swap.
22:42:03 <palomer> Cale: how would one define arrays in haskell?
22:42:13 <palomer> if one was to do it from scratch
22:42:15 <dons> @index Array
22:42:16 <lambdabot> Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
22:42:50 <Cale> ah, from scratch... I suppose one would start by abusing the FFI primitives
22:43:07 <Cale> allocate some memory, etc
22:43:21 <dons> yeah, a la Array.Storable
22:45:05 <Cale> They're presently language primitives though.
22:45:28 <Cale> I really rather like the current GHC array system
22:45:47 <dons> it has enough type args for you? ;)
22:45:57 <Cale> The one in the Report is somewhat deficient, but Data.Array.{M,I}Array is rather nice.
22:46:37 <dons> @kind Data.Array.Array
22:46:38 <lambdabot> * -> * -> *
22:46:49 <dons> yeah, lovely jubbly :D
22:47:06 <Cale> not that bad a kind :)
22:47:25 <dons> esp. for what sounds like a garden-variety data type
22:47:41 <Cale> accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
22:47:47 <dons> hehe
22:48:04 <Cale> this might scare some people, but if you calm down and examine it slowly, it's really not so bad
22:48:38 <Cale> esp. with some consultation of the docs :)
22:48:54 <jeffno> Where did the x and xs idiom come from?
22:48:58 <dons> I always feel I don't have enough functions returning types like `a i e' in my code.
22:49:03 <Cale> xs is plural
22:49:08 <Cale> :)
22:49:08 <jeffno> Ah.
22:49:10 <palomer> Cale: no FFI allowed
22:49:19 <Cale> palomer: then you probably can't.
22:49:23 <dons> palomer, thne you've got lists.
22:49:27 <dons> or else primops
22:49:31 <Cale> You have lists
22:49:41 <palomer> hrmph, there must be a way to reason about arrays
22:49:42 <Cale> but you won't get identical runtime performance
22:49:43 <dons> or data types.
22:49:53 <Cale> arrays are memoised functions
22:50:14 <dons> check the docs, they're cool. they have such a haskell-flavoured view of arrays.
22:50:17 <palomer> with some attributes
22:50:23 <Cale> palomer: yeah
22:50:25 <skew> I'm sure you can find an excuse to write a r g h if you try
22:50:51 <palomer> well, imoff to bed
22:50:54 <palomer> night!
22:50:56 <dons> "a programmer may reasonably expect rapid access to
22:50:57 <dons> the components.  To ensure the possibility of such an implementation,
22:50:57 <dons> arrays are treated as data, not as general functions."
22:51:03 <skew> separation logic kind of helps the reasoning
22:51:12 <dons> doh! but I was expecting functions ;)
22:51:31 <dons> as if we'd treat arrays as data. what a ludicrous concept ;)
22:51:47 <Cale> It would be kind of neat if we had overloaded application
22:51:59 <Cale> so that arrays could be applied to parameters
22:52:03 <Cale> (indices)
22:52:08 <skew> they are obviously codata ;)
22:52:26 <skew> unless you like writing case statements over an infinite number of constructors
23:55:53 <boegel> @poll-list
23:55:54 <lambdabot> ["TheLanguageOfChoiceForDiscriminatingHackers"]
23:56:06 <boegel> eej, my TopTenLibraries poll is gone :(
23:57:05 <astrolabe> lambdabot went AOL for a bit
23:57:29 <boegel> yeah, but I thought dons took care of state-saving for the polls :(
23:59:07 <astrolabe> I suppose it is better to find out now, than after everyone has been voting
23:59:12 <sieni> @help poll
23:59:13 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result
23:59:13 <lambdabot> poll-close poll-remove
23:59:23 <sieni> @poll-result
23:59:24 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
23:59:39 <sieni> @poll-result TheLanguageOfChoiceForDiscriminatingHackers
23:59:39 <lambdabot> Poll results for TheLanguageOfChoiceForDiscriminatingHackers (Open):
23:59:39 <lambdabot> Haskell=2
23:59:55 <dons> oh. hmm.
23:59:57 <kzm> @poll-show TheLanguageOfChoiceForDiscriminatingHackers
23:59:57 <lambdabot> ["Haskell"]
