01:52:21 <azuroth> let's partyyy
01:53:14 <shapr> g'day azuroth, how's code?
01:54:18 <azuroth> pretty good, actually. how about you?
01:54:42 <shapr> flat out spiffy
01:55:09 <shapr> I just need to build masq into my kernel to see if I can get traffic to the outside world.
01:55:26 <azuroth> ahh. fun times
01:55:30 <shapr> What are you working on?
01:56:56 <azuroth> at the moment, I'm learning about connecting to postrgresql from c++
01:57:19 <shapr> Cool, what's the native interface/protocol like?
01:58:19 <shapr> Databases are based on set theory, is that exposed in the native layer?
01:58:55 <azuroth> I found a library called pqxx, which seems nice and proper C++ish. I could've gone with ODBC or something, but I'd really prefer not having to put up with pointers
02:00:07 <azuroth> not really - you mainly just talk to it through SQL strings. e.g. "select name from users where id = 5" and whatnot
02:00:28 <shapr> Is there a 'more native' interface where you can talk to the set theory parts directly?
02:02:23 <azuroth> as far as I know, the only way to communicate, is via SQL
02:03:03 <azuroth> I'm slightly dodging the question though, because I don't know much about set theory :-)
02:03:24 <shapr> The basic stuff is about as complicated as looking at rocks in a box.
02:03:48 <shapr> Stuff like "What's the intersection of the sets of {1,2,3} and {3,4,5} ?"
02:04:01 <azuroth> ahh
02:04:07 <shapr> Union in SQL, right?
02:04:15 <shapr> inner join
02:04:45 <shapr> Have you seen the tutorials that have the two circles where one is lying partway over the other?
02:04:51 <azuroth> that sounds right
02:05:45 <azuroth> hmm, no, I don't think I have. but I think I get what you're talking about
02:05:48 <shapr> The nice thing about expressing the set theory ops directly is that there are some extra optimizations allowed that way.
02:06:03 <shapr> Ok, I'll scrape up one of the tutorials with circles. That's what cleared it up for me.
02:06:21 <azuroth> oh, okay
02:07:48 <shapr> Here's the first one I found - http://www.databasedev.co.uk/query_joins.html
02:08:16 <zagrius> How can I draw plots with Haskell?
02:08:36 <shapr> Cairo is a good gtk2 approach.
02:08:43 <shapr> I've seen some people dump data to gnuplot.
02:09:00 <shapr> There's a PDF writing lib around somewhere.
02:09:10 <azuroth> cool, thanks shapr
02:09:17 <zagrius> What do I need for Cairo?
02:09:34 <shapr> azuroth: Does that make all the 'inner join', 'left outer join' etc stuff clear?
02:09:44 <azuroth> still reading
02:09:54 <shapr> zagrius: You need to install ghc 6.4.1, cabal 1.1.4, and gtk2hs 0.9.10
02:12:56 <shapr> zagrius: There's more gtk2hs info on the blog/homepage - http://www.haskell.org/gtk2hs/
02:13:06 <zagrius> shapr: ok, let's see whether we can do that :)
02:13:23 <shapr> zagrius: I've installed it myself several times, so if you have problems, I'll try to help.
02:14:52 <azuroth> I think I mostly understand, shapr
02:15:43 <shapr> It's useful to know if you use databases much.
02:17:10 <zagrius> shapr: On the Cabal page the latests rc is 1.13.
02:17:58 <shapr> Which page?
02:18:13 <azuroth> cool
02:19:16 <shapr> hi jak_
02:19:20 <zagrius> http://www.haskell.org/cabal/download.html
02:19:46 <shapr> zagrius: That seems to be out of date.
02:20:13 <jak_> hey shapr
02:20:48 <azuroth> I like how the stop button on this cd player goes to the next track
02:21:40 <zagrius> shapr: What release do I need then?
02:22:30 <shapr> zagrius: I'd suggest 1.1.4
02:22:53 <shapr> 1.1.4 is available from the darcs repo.
02:23:40 <zagrius> shapr: That's what I needed.
02:28:17 <soysauce> why do exceptions have to be so useless
02:28:48 <soysauce> *Main> Array.array ((0, 2), (0, 2)) [((x, y), fwinit (x, y)) | x <- indices, y <- indices]
02:28:48 <soysauce> array *** Exception: Error in array index
02:29:10 <soysauce> what is that supposed to mean. :|
02:30:20 <basti_> soysauce: that's a list comprehension
02:30:29 <basti_> in this form, it represents a cartesian product
02:30:53 <basti_> @eval [(x,y) | x<-[1..3] , y<-['a'..'c']]
02:30:53 <soysauce> I know what it is, I wrote it
02:30:54 <lambdabot> [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
02:30:57 <basti_> ah
02:30:57 <soysauce> but why do I get the exception
02:31:01 <soysauce> heh :p
02:31:09 <basti_> well, because the arrays are too small? ^^
02:31:17 <basti_> no
02:31:21 <soysauce> how is it too small? It's 3x3
02:31:28 <soysauce> indices = [0..2] FYI
02:31:33 <basti_> hmm
02:31:55 <basti_> let me look up the semantics of array
02:32:35 <basti_> mmh
02:32:39 <basti_> no problem there
02:32:50 <zagrius> file:///usr/local/share/doc/ghc6/libraries/base/Data.Array.html#t%3AArray
02:33:14 <zagrius> soysauce: Read carafully.
02:33:22 <zagrius> make that carefully.
02:34:38 <zagrius> )', and a one-origin '10' by '10' matrix has bounds '((1,1),(10,10))'.
02:35:14 <basti_> zagrius: so?
02:35:44 <Lemmih> The range should be ((0,0),(2,2)) and not ((0,2),(0,2)).
02:35:47 <azuroth> ((0,0),(2,2)) ?
02:35:50 <soysauce> "These bounds are the lowest and highest indices in the array, in that order."
02:35:52 <basti_> ARGH
02:35:55 <soysauce> er, oh
02:36:00 * basti_ donks
02:36:01 <basti_> okay
02:36:02 <soysauce> haha
02:36:17 <zagrius> :)
02:36:32 <soysauce> I wish it had printed out a helpful message, though :(
02:36:42 <zagrius> Still a lot of the documentation is unclear.
02:37:03 <zagrius> It sometimes looks like Java comments.
02:37:09 <basti_> a warning for empty arrays would be nice
02:37:18 <zagrius> E.g. getFoo().
02:37:28 <zagrius> gets the Foo
02:37:31 <basti_> ?
02:37:35 <Lemmih> basti_: It wouldn't be empty.
02:37:40 <zagrius> And what exactly is a Foo?
02:37:43 <soysauce> yay, it works, thanks
02:37:45 <basti_> Lemmih: ah ok its incluseive
02:37:50 <zagrius> np
02:37:53 <basti_> luseeifvdlfkjksf
02:38:07 <soysauce> it's odd but I always seem to be coding Haskell when I am tired.
02:39:57 <amiddelk> Or is it that you got tired from coding Haskell ;)
02:40:53 <soysauce> maybe!
02:41:18 <soysauce> maybe :: a -> (b -> a) -> Maybe b
02:42:43 <amiddelk> that probably confirms it :P
02:43:50 <zagrius> shapr: I did a checkout of cabal, but the src directory is *empty*?
02:44:11 <Lemmih> zagrius: That's OK.
02:44:33 <Lemmih> The code is still in Distribution/
02:46:12 <zagrius> Lemmih: There's a small error in the makefile.
02:46:25 <zagrius> Lemmih: It assumes that ghc is in /usr/bin/
02:46:43 <Lemmih> Don't use the makefile.
02:47:15 <Lemmih> The makefile is only for people with *really* old GHCs.
02:49:07 <zagrius> Lemmih: Then how do I install it? I already removed an old version of Cabal (like the README told me to do)
02:49:17 <Lemmih> ack.
02:49:21 <Lemmih> Too bad.
02:50:02 <zagrius> ?
02:50:09 <Lemmih> Someone should gut that README.
02:51:16 <zagrius> Lemmih: Ok, I could get myself a new ghc with an old Cabal, and then what?
02:52:09 <Lemmih> 'runhaskell -cpp Setup.lhs {configure|build|install}' should also work.
02:54:58 <zagrius> Lemmih: What does cpp refer to?
02:55:48 <Lemmih> The C Preprocessor.
02:59:03 <zagrius> I don't have a number of dependencies, and pfesetup is the only one I don't know.
03:03:09 <Lemmih> Does it fail?
03:04:13 <zagrius> Lemmih: wel, it doesn't explicitly says so in the configure phase.
03:05:16 <Lemmih> Good, it's just letting you know that some services won't be available.
03:05:54 <zagrius> And how important are those services?
03:06:58 <Lemmih> I'm not sure what pfesetup does but you need cpphs and haddock if you want to build your own documentation.
03:07:26 <zagrius> pfesetup seems some Programmatica tool. How is that package commonly called?
03:11:17 <soysauce> zagrius - where you from?
03:15:18 <zagrius> soysauce: Can't you do a /whois ;)
03:16:16 <ricebowl> I did
03:16:19 <ricebowl> oops.
03:16:24 <ricebowl> wrong client
03:16:38 <ricebowl> well anyway, I was asking largely because of your /whois ;)
03:17:18 <ricebowl> bist du deutsch?
03:20:57 <zagrius> ricebowl: heh, you are logged in twice.
03:21:27 <zagrius> ricebowl: Is that to artificially inflate the number of Haskell users?
03:22:03 <dons> @yow
03:22:03 <lambdabot> YOW!!  Everybody out of the GENETIC POOL!
03:23:28 * pesco dries off his genes.
03:24:16 <zagrius> Setup.lhs: Error: Could not find module: Distribution.Compat.ReadP with any suffix: ["hi"]
03:24:49 <zagrius> This Cabal thing is not being friendly to me. :-(
03:25:08 <azuroth> evening, dons
03:25:29 <dons> hi
03:27:07 <zagrius> Lemmih: Are you familiar with this error?
03:27:30 <soysauce> zagrius - no :p
03:27:34 <soysauce> extreme laziness
03:27:45 <soysauce> normally I'd have 3 of myself here
03:27:56 <soysauce> 1 persona per PC
03:28:04 <soysauce> or rather, per PC that I actively use
03:28:15 <dons> why not use screen?
03:28:59 <soysauce> because I'm not using UNIX? ;)
03:29:09 <Lemmih> zagrius: Did you notice that module being built?
03:29:41 <dons> soysauce, you know you can get unix for free these days? ;)
03:29:50 <soysauce> this PC is Windows XP x64, ricebowl is Windows XP, the 3rd is my laptop which is currently XP but about to get formatted and installed with Linux
03:29:58 <soysauce> dons - I know
03:30:07 <soysauce> dons - I just haven't figured out why I would want to yet :|
03:30:20 <dons> so you can use screen!
03:30:25 <dons> and hmp3 ;)
03:30:29 <soysauce> hah
03:30:36 <soysauce> what's hmp3?
03:30:54 <soysauce> my router runs Linux, I can always connect to it, but then I don't think there's much point in doing that to use screen
03:31:07 <dons> @where hmp3
03:31:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3
03:32:55 <dons> perhaps more helpful: http://www.cse.unsw.edu.au/~dons/hmp3.png
03:32:55 <zagrius> Lemmih: When I run runhaskell Setup.lhs configure again, it gives #ifdef DEBUG
03:32:58 <zagrius>         simpleHunitTests
03:33:05 <zagrius> #endif
03:33:27 <soysauce> dons - oh, a Haskell mp3 player?
03:33:37 <zagrius> Lemmih: More precisely it gives a line number and a column number and that code is on that line.
03:34:15 <Lemmih> zagrius: It fails? If so, please paste the entire error message.
03:35:04 <zagrius> zagrius: ./Distribution/Simple.hs:61:1: lexical error
03:35:20 <zagrius> Lemmih: ./Distribution/Simple.hs:61:1: lexical error
03:36:01 <Lemmih> How did you invoke 'runhaskell'?
03:36:50 <zagrius> runhaskell Setup.lhs configure
03:37:00 <dons> soysauce, yep
03:37:32 <Lemmih> zagrius: You forgot the -cpp flag.
03:37:49 <zagrius> Lemmih: makes a lot of sense
03:40:10 <zagrius> Lemmih: I just saw some early documentation of Cabal and that mentioned the build target. I did install right away instead, and therefor I got an error.
03:40:55 <zagrius> Lemmih: thanks for your help, it is now installed.
03:48:38 <kolmodin> @index concat
03:48:39 <lambdabot> Data.List, Prelude
03:48:47 <kolmodin> @libsrc Data.List
03:48:47 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
03:49:49 <kolmodin> @libsrc Prelude
03:49:50 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
04:06:53 <masm> Can haskell pattern match negative numbers? How?
04:07:32 <basti_> masm: f -1 = 0
04:08:11 <soysauce> heh if you put it in parens it would work I suspect
04:08:22 <basti_> ah
04:08:23 <basti_> ^^
04:09:35 <soysauce> uh, this is odd
04:09:43 <soysauce> *Main> let f n = f (n-1)
04:09:43 <soysauce> *Main> let f (-1) = 0
04:09:43 <soysauce> *Main> f 2
04:09:43 <soysauce> *** Exception: <interactive>:1:4-13: Non-exhaustive patterns in function f
04:10:02 <Lemmih> The second definition of 'f' shadows the first.
04:10:08 <soysauce> ah
04:10:11 <basti_> its a let.
04:10:22 <soysauce> sorry; just tired :p
04:10:59 <Lemmih> > let f (-1) = True; f _ = False in (f (-1), f 10)
04:11:00 <lambdabot> (True,False)
04:11:17 <soysauce> cool
04:14:56 <soysauce> is it true that ((0, 0), 1) == (0, 0, 1)?
04:15:03 <shapr> try it
04:15:19 <soysauce> well, it doesn't seem to work
04:15:20 <shapr> > ((0, 0), 1) == (0, 0, 1)
04:15:21 <lambdabot> Couldn't match `((a, b1), b)' against `(a1, b2, c)'
04:15:26 <soysauce> yes...
04:15:36 <soysauce> but someone in here made a comment recently about the , operator
04:15:47 <shapr> ?
04:15:51 <soysauce> I wish I could remember the exact statement.
04:15:59 <shapr> > (,) 0 1
04:16:00 <lambdabot> (0,1)
04:16:02 <soysauce> but it was something about how (a, b, c) was supposed to be shorthand for (a, (b, c))
04:16:29 <shapr> Maybe you're thinking of lists?
04:16:33 <soysauce> nope.
04:16:37 <soysauce> it was in the context of tuples
04:16:56 <shapr> > 1 : [2,3]
04:16:57 <lambdabot> [1,2,3]
04:17:01 <soysauce> yes, I know. :p
04:17:04 <shapr> ok
04:17:06 <soysauce> > 1:2:3:[]
04:17:07 <lambdabot> [1,2,3]
04:17:08 <soysauce> > [1,2,3]
04:17:09 <lambdabot> [1,2,3]
04:17:14 <shapr> yup
04:17:42 <shapr> Yay, I can send packets to the outside world from this pure Haskell TCP/IP stack.
04:17:54 * shapr successfully pings www.scannedinavian.com
04:17:56 <Philippa_> soysauce: that's true in some places, but not in Haskell
04:18:09 <soysauce> ok, maybe it was in reference to a particular variant
04:18:14 <shapr> Ok, now for part 2...
04:18:17 <azuroth> is it fast, shapr?
04:18:49 <shapr> Seems fast, though I doubt the pure Haskell stack is as fast as a pure C stack.
04:18:55 <shapr> I bet it's a lot safer though.
04:19:22 <dons>  @ping scannedinavian.com
04:19:28 <azuroth> is it open?
04:19:32 <soysauce> C code that's been around 20+ years is probably fairly safe too ;)
04:19:43 <shapr> soysauce: You mean like xdrlib?
04:20:02 <shapr> Remember that huge hole they found in ASN.1?
04:20:19 <wilx> > 1, 2
04:20:19 <lambdabot>  parse error on input `,'
04:20:28 <soysauce> happens occasionally.
04:20:52 <shapr> g'day dons, how's code?
04:21:13 <wilx> Huge hole?
04:21:29 <soysauce> but at the same time, production code that is in use on hundreds of millions of computers and more than 2 decades old is probably mostly bug-free
04:21:47 <soysauce> probably.
04:22:09 <azuroth> how does it work, shapr? how do you... do it?
04:22:16 <shapr> I think the commonly used paths probably don't have any obvious bugs.
04:22:37 <shapr> azuroth: I grabbed the House cvs repo from http://www.cse.ogi.edu/~hallgren/House/
04:23:09 <soysauce> over 20 years and hundreds of millions of machines you get a lot of coverage over the code.
04:23:14 <dons> shapr, hey good. hacking away on hmp3
04:23:29 <shapr> Then I built tun/tap support into my kernel, and then I used the EthernetOverTun.hs module.
04:24:02 <shapr> soysauce: Still, is the Linux TCP/IP code twenty years old? Or the windows code?
04:24:24 <soysauce> AFAIK Microsoft essentially ripped the BSD networking stack, and I seem to recall that Linux did something similar
04:24:24 <azuroth> that's crazy
04:25:04 <shapr> I doubt Microsoft is using the BSD stack, how would they have gotten the ping of death problem?
04:25:12 <lkrt_> That's not true.
04:26:05 <soysauce> well brb then, let me check
04:26:33 <shapr> For once I wish I had a win32 box here, can you guess the next part of my evil plan?
04:26:54 <lkrt_> Computers running Windows are hard to find these days.
04:27:00 <Philippa_> shapr: they did in 2K onwards IIRC
04:27:14 <lkrt_> No, the NT stack is not the BSD stack.
04:27:16 <Philippa_> lkrt_: y'think? I'm on one
04:27:38 <Philippa_> lkrt_: they did a major replacement job at one stage IIRC
04:28:13 <lkrt_> Microsoft licensed a stack derived from the BSD code in the '9x/NT3.x days.
04:28:55 <Maddas> shapr: Pure Haskell TCP/IP stack? Where, where?
04:29:07 <dons> House?
04:29:25 <shapr> azuroth: It's easy, you can do it yourself. I can also tell you the magic incantation to give your tun0 device an acceptable addresses for broadcast, self, etc
04:29:33 <shapr> Yup, I'm using the TCP/IP stack from House.
04:29:36 <Maddas> Ah, I see. Cool.
04:29:40 <dons> why have just windows, when you want a House?
04:29:44 <Maddas> :-)
04:30:12 * soysauce gives up
04:30:57 <dons> mmm. I enjoy these late night hacking sessions, where I just hack and let the type checker do the thinking
04:31:06 <Maddas> haha
04:31:49 <Maddas> dons: And after the type checker did the thinking you let QuickCheck do the testing, right?
04:32:00 <azuroth> I might look into it later. for now, I need to get TAFE work out of the way
04:33:09 <dons> Maddas, I try not to write code that will need a lot of testing this late at night
04:33:26 <dons> so more like profiling, or ticking off todo items
04:33:46 <dons> ooh, like that: a fast packed string ncurses ui :)
04:33:54 <dons> nice and faaaast :D
04:34:08 <shapr> soysauce: http://online.securityfocus.com/news/474
04:37:15 <dons> my new favourite constructor: "fooo"#
04:37:57 <dons> more particularly, FastPackedString.packAddress "foo"#
04:42:45 <dons> SamBb, you'll like this: 0.00% hmp3
04:42:56 <dons> SamB ^^
04:43:38 <Maddas> Incidentally, I was just reading a paper about Cyclone where they describe found bugs in ported programs (used as benchmarks), one dating from the mid 1980s.
04:43:46 <Maddas> (programs ported from C)
04:44:42 <lkrt_> Code that 'works' isn't usually inspected rigorously.
04:44:53 <dons> new screenshot: http://www.cse.unsw.edu.au/~dons/hmp3.png
04:45:14 <Maddas> dons: Woo cool!
04:45:24 <Maddas> (Insert comma at will)
04:45:45 <dons> :)
04:46:22 <lkrt_> Interesting color selection.
04:46:43 <dons> ?/
04:46:58 <boegel|gf> dons?
04:47:13 <dons> I was querying lkrt_
04:47:28 <dons> but my fingers slipped (poised precariously on the couch here..)
04:49:12 <dons> lkrt_, why interesting?
04:49:59 <dons> SamB: I couldn't get the cpu load above 3%. Maybe the load issue is squashed
04:51:07 <lkrt_> Oh, I just didn't like the cyan and the green together.
04:51:13 <lkrt_> It's not really interesting.
04:51:43 <dons> ah, ok. I like it. Good thing the colours are configurable then, eh ?
04:52:21 <lkrt_> If nothing else the terminal is.
04:53:16 <dons> the app in fact is configurable. you edit Config.hs
04:56:35 <lkrt> Now begins the hgstreamer
04:56:42 <tic> How do I make an Int from a Double?
04:59:09 <dons> @hoogle Double -> Int
04:59:09 <lambdabot> Text.Regex.Posix.regExtended :: Int
04:59:09 <lambdabot> Text.Regex.Posix.regIgnoreCase :: Int
04:59:09 <lambdabot> Text.Regex.Posix.regNewline :: Int
04:59:14 <dons> bah.
04:59:17 <dons> @type round
04:59:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
04:59:25 <dons> > round (1.72 :: Double)
04:59:26 <lambdabot> 2
04:59:38 <dons> > truncate (1.72 :: Double)
04:59:39 <lambdabot> 1
04:59:50 <dons> > ceiling (1.72 :: Double)
04:59:50 <lambdabot> 2
05:01:04 <dons> > floor (1.72 :: Double)
05:01:05 <lambdabot> 1
05:01:11 <dons> so many choices!
05:01:23 <tic> err. Sorry, wrong question.
05:01:32 <tic> I meant to ask: How do I make a (bound) Int from an Integer?
05:01:32 <azuroth> night, all
05:01:47 <dons> > fromIntegral (1 :: Integer) :: Int
05:01:48 <lambdabot> 1
05:01:55 <tic> ahh. thanks!
05:01:55 <dons> @type fromIntegral (1 :: Integer) :: Int
05:01:56 <lambdabot> Int :: Int
05:02:07 <dons> night all.
05:02:13 <dons> @localtime azuroth
05:02:22 <dons> ah, that's right. he's in my timezone :)
05:03:10 <shapr> g'nite dons
05:03:26 <azuroth> about 300 kilometers north of you, I think
05:04:32 <azuroth> @localtime lambdabot
05:04:46 <azuroth> @localtime dons
05:04:47 <lambdabot> Local time for dons is Sun Nov 13 23:59:00 2005
05:07:10 <xs> hello, how can i declare twin as a functor of a pair?
05:08:04 <xs> instance Functor (a,a) where fmap = twin gives a kind error
05:10:20 <Heffalump> you'd need -fallow-undecidable-instances to do that
05:10:49 <xs> hm, it's undecidable?
05:11:34 <Heffalump> yeah, cos you repeat the variable a
05:12:19 <tic> Grr. No instance for (Integral Double). Possible fix: add an instance declaration for (Integral Double).
05:12:25 <tic> This when doing fromIntegral (d+100.0)
05:13:21 <xs> Heffalump: thanks! i'll read up :)
05:20:30 <Heffalump> tic: try fromIntegral d + 100.0
05:20:37 <Heffalump> oh, sorry.
05:20:42 <Heffalump> ignore me :-)
05:20:50 <Heffalump> you want toIntegral (d+100.0) ..
05:20:58 <Heffalump> d+100.0 is clearly not going to be an integer.
05:21:04 <Heffalump> or anything integral
05:21:35 <tic> okay, but I want an "Int"
05:21:52 <Heffalump> @type toIntegral 100.0
05:21:53 <lambdabot> Not in scope: `toIntegral'
05:21:55 <tic> and where is toIntegral defined?
05:22:01 <Heffalump> maybe I've got the name wrong
05:22:10 <Heffalump> @type fromRational 100.0
05:22:11 <lambdabot> forall a. (Fractional a) => a
05:22:18 <ibid> there's many of those
05:22:19 <Heffalump> @type fromRational 100.0 :: Int
05:22:20 <lambdabot>   No instance for (Fractional Int)
05:22:20 <lambdabot>   arising from use of `fromRational' at <interactive>:1:0-11
05:22:24 <Heffalump> hmm
05:22:27 <ibid> because there are many ways to convert
05:22:28 <Heffalump> confused now :-)
05:22:32 <tic> toInteger perhaps?
05:22:32 <Heffalump> oh, yes
05:22:35 <ibid> round, ceiling, floor etc
05:22:35 <Heffalump> @type floor 100.0
05:22:36 <lambdabot> forall b. (Integral b) => b
05:22:39 <Heffalump> there you go
05:22:48 <tic> but that's not really the problem.
05:22:55 <tic> Once I've gotten to Integer, I need to make it an Int
05:23:03 <tic> and that I still haven't figured out.
05:23:21 <ibid> tic: you can make it straight to Int, no need to go through Integer
05:23:39 <tic> ibid, through floor or something?
05:23:56 <Heffalump> tic: indeed
05:23:56 <tic> yes, that seemed to work. thanks.
05:24:02 <tic> But what if I do want to go through Integer?
05:24:23 <ibid> well, floor converts to Integer just as well
05:24:27 <ibid> then you'd use
05:24:40 <ibid> @type fromIntegral . fromInteger
05:24:41 <lambdabot> forall b. (Num b) => Integer -> b
05:25:01 <ibid> (i'm not sure but there may be something named like that already
05:25:05 <ibid> )
05:25:08 <ibid> gah
05:25:19 <ibid> ... may be something that does that already
05:25:27 <ibid> (named something)
05:28:28 <soysauce> heh, is there any way to import qualified Array and get ! into my namespace?
05:28:34 <soysauce> writing Array.! is really annoying
05:28:58 <soysauce> ! = Array.! apparently doesn't work :/
05:29:27 <ibid> import Array (!)
05:29:34 <ibid> imports Array.! unqualified
05:29:48 <soysauce> hm, I see
05:29:51 <ibid> (!) = (Array.!) might work too
05:29:56 <ibid> i often do
05:30:01 <ibid> import qualified Array
05:30:10 <ibid> import Array (Array, (!))
05:30:13 <ibid> or something
05:30:15 <soysauce> oh, nice, the parens fix it
05:30:49 <ibid> parens convert the operator to a plain function
05:30:57 <ibid> on both sides
05:31:13 <soysauce> yeah
05:31:30 <soysauce> I tried that before but didn't do that on the right-hand side
05:32:01 <soysauce> that makes sense, though
05:43:53 <shapr> I'm making new Random instances, and I'm surprised there's not a default for Bounded instances. Seems to me that if map genRange onto minBound and maxBound, you can just scale the result of the generator to get a simple result. Any obvious flaws in that?
06:19:32 <musasabi> shapr: I managed to get weird bugs with Random instances, so be carefull - or at least test them properly.
06:20:20 <musasabi> Having a program mixing STM and IO abort with <<Loop>> and finally finding out the problem was a Random instance was quite frustrating.
06:22:46 <Heffalump> how on earth could that happen?
06:22:54 <Heffalump> did your random instance itself loop?
06:24:18 <musasabi> Heffalump: yes, made me look into lots of different places first.
06:24:48 <Heffalump> oh, right :-)
06:24:56 <musasabi> "Why does the database thingy deadlock when I test it with random page requests"
06:25:03 <Heffalump> lol
06:25:38 <musasabi> It must be some IO/STM issue lets debug it... ;)
07:03:18 <shapr> musasabi: I'm making a Random instance for Word8, haven't found a smooth way to cast everything to Integer for maxBound - minBound calculations.
07:03:30 <shapr> Didn't JoelR have a Random instance of Word8 somewhere?
07:11:07 <shapr> Ah, there's useful code in Hugs' System.Random. randomIvalInteger and randomIvalFloat are useful.
07:11:09 <m0rbidini> hello
07:11:24 <m0rbidini> need some help convertings a Char to Int
07:11:26 <m0rbidini> is is possible?
07:11:28 <basti_> "ord"
07:11:33 <basti_> Data.Char
07:11:34 <m0rbidini> (absolute newbie)
07:11:48 <m0rbidini> ord gives me "unused variable"
07:11:53 <m0rbidini> ??
07:11:59 <m0rbidini> do i need an imporT?
07:12:03 <basti_> yes
07:12:04 <basti_> Data.Char
07:12:04 <m0rbidini> i'm using hugs
07:12:11 <m0rbidini> ok
07:12:12 <basti_> try ":m Data.Char"
07:12:17 <m0rbidini> thx
07:12:23 <m0rbidini> and what about search and replace?
07:12:42 <m0rbidini> can I describe my problem? (somewhat lenghty)
07:12:46 <basti_> @index search
07:12:46 <lambdabot> bzzt
07:12:52 <basti_> is it a homework problem?
07:13:01 <m0rbidini> nope, a proof of concept over Java
07:13:05 <m0rbidini> (not going very well)
07:13:27 <basti_> dont let me stop you then
07:13:34 <basti_> I'll be off soon though
07:13:45 <m0rbidini> it's like this : I have a pre-formatted file that goes like this - 1st line: number of macros
07:13:49 <m0rbidini> example :
07:13:51 <m0rbidini> 2
07:13:52 <m0rbidini> A
07:13:53 <m0rbidini> 123
07:13:54 <m0rbidini> B
07:13:55 <m0rbidini> 456
07:13:57 <m0rbidini> text
07:14:05 <m0rbidini> meaning 1st line 2 macros
07:14:11 <m0rbidini> macro A = 123
07:14:15 <m0rbidini> macro B = 456
07:14:23 <m0rbidini> text contains $A and $B
07:14:30 <m0rbidini> i have to replace the macros in the text
07:14:43 <m0rbidini> pretty easy in java, haskell not so easy
07:14:45 <m0rbidini> :(
07:15:07 <basti_> you aren't as good in haskell, you want to say?
07:15:09 <m0rbidini> so far I read the file and use "lines" to put it into a list of strings
07:15:18 <m0rbidini> not by a long shot
07:15:32 <m0rbidini> and I have the number of macros at the head, as a char
07:15:36 <m0rbidini> now what? :)
07:16:09 <eivuokko> If you used lines-function, it is a string, not a char
07:16:13 <m0rbidini> I'm thinking of creating tuples with the 2nd,3rd and 4th,5th lines into a list (for this example)
07:16:14 <eivuokko> use read
07:16:33 <m0rbidini> read?
07:16:42 <m0rbidini> as in line-by-line?
07:16:57 <m0rbidini> isn't it easier to process the whole list?
07:18:39 <m0rbidini> ping
07:18:50 <eivuokko> read as in function from Prelude.  Just for converting String into an Int.
07:19:26 <m0rbidini> how can I convert? toInt :: String -> Int
07:19:36 <m0rbidini> toInt s = read(s)
07:19:37 <m0rbidini> ?
07:19:47 <eivuokko> toInt = read
07:19:51 <eivuokko> :)
07:20:06 <m0rbidini> how do I refer the string??
07:20:07 <eivuokko> toInt s = read s <- don't need parentheses
07:20:12 <m0rbidini> oh ok
07:21:02 <vegai> you realize that 'toInt = read' works just like 'toInt s = read s'?
07:21:14 <eivuokko> You did something like do { content <- readFile "foo"; let l = lines content } ?
07:23:58 <m0rbidini> import IO
07:23:58 <m0rbidini> {----------------------------------------------------------
07:23:58 <m0rbidini> Title:
07:23:58 <m0rbidini>    Haskell code sample for file read and write
07:23:58 <m0rbidini> Description:
07:23:59 <m0rbidini>  
07:24:01 <m0rbidini>    This program reads a text file and swaps lowercase to uppercase
07:24:03 <m0rbidini>    and vice versa, writing the result on file "out.txt"
07:24:05 <m0rbidini> Use in Hugs:
07:24:07 <m0rbidini>    > start "filename"
07:24:09 <m0rbidini> -----------------------------------------------------------}
07:24:11 <m0rbidini> start :: String -> IO ()
07:24:13 <m0rbidini> start filename = do
07:24:15 <m0rbidini>         s <- readFile filename      -- read the entire text file into string 's'
07:24:17 <m0rbidini> 	res <- processData s        -- process 's', returning the final result
07:24:19 <m0rbidini> 	putStr (show res)           -- print the result in Hugs (opcional)
07:24:21 <m0rbidini>         writeFile ("out.txt") res   -- write it to the output text file
07:24:23 <m0rbidini> --------------
07:24:26 <m0rbidini> processData :: String -> IO String
07:24:27 <m0rbidini> processData s = return result
07:24:29 <m0rbidini> 	where
07:24:31 <m0rbidini> 	result = map swap s
07:24:33 <m0rbidini>         swap c
07:24:35 <m0rbidini> 	  | c >= 'a' && c <= 'z' = chr (ord c - 32)
07:24:37 <m0rbidini> 	  | c >= 'A' && c <= 'Z' = chr (ord c + 32)
07:24:39 <m0rbidini>           | otherwise            = c
07:24:41 <m0rbidini> i mean, sorry...
07:24:43 <m0rbidini> import IO
07:24:45 <m0rbidini> import Data.Char
07:24:45 <vegai> that is why you should use irssi
07:24:47 <m0rbidini> start :: String -> IO ()
07:24:49 <m0rbidini> start filename = do
07:24:51 <m0rbidini>         s <- readFile filename
07:24:53 <m0rbidini> 	slist <- processData s
07:24:55 <m0rbidini> 	nMacros <- countMacros slist
07:24:57 <m0rbidini> 	putStr (show res)           -- debug
07:24:59 <m0rbidini> 	res <- expandMacros nMacros slist
07:25:01 <m0rbidini>         writeFile ("out.txt") res
07:25:03 <m0rbidini> --------------
07:25:05 <m0rbidini> processData :: String -> IO String
07:25:07 <m0rbidini> processData s = return result
07:25:08 <vegai> oh, you did that on purpose? :P
07:25:09 <m0rbidini> 	where
07:25:11 <m0rbidini> 	result = lines s
07:25:13 <m0rbidini> countMacros :: [String] -> Int
07:25:14 <Frederick> yo folks
07:25:15 <m0rbidini> countMacros s = read (head (head [s]))
07:25:17 <m0rbidini> this will work, except for expandMacros
07:25:22 <m0rbidini> sorry bout that : http://pastebin.com/427775
07:25:56 <m0rbidini> forgot about thebin
07:26:03 <Frederick> yo SamB
07:26:04 <m0rbidini> :P
07:26:30 <m0rbidini> any comments?
07:27:14 <Lemmih> > let c s = read (head (head [s])) in c ["10"] :: Int
07:27:15 <lambdabot> 10
07:27:28 <m0rbidini> hmmm
07:27:34 <Lemmih> 'head [s]' => 's', btw.
07:28:14 <m0rbidini> i don't get " in c["10"] "
07:28:27 <m0rbidini> i get the ordinal from it?
07:28:31 <m0rbidini> pretty cool
07:29:06 <eivuokko> I am trying to track while my irssi does this...by any chance did I DC after someone entered unicode here?
07:29:19 <Lemmih> > read (head ["10"]) :: Int
07:29:20 <lambdabot> 10
07:29:41 <m0rbidini> cool
07:30:16 <m0rbidini> my imperative judgement cludges me
07:30:28 <m0rbidini> so, how can I loop "n" times the list ?
07:30:56 <Lemmih> Loop "n" times the list?
07:30:57 <m0rbidini> I was thinking "now I have the int nMacros, I can add nMacros*2 tuples to a 'macros' list"
07:31:06 <m0rbidini> using "!!", right ?
07:31:34 <m0rbidini> loop it so I can populate a tuples list
07:32:05 <m0rbidini> if I have a macro defined by A,123 I was thinking of adding it to a list as [(A,123)]
07:32:25 <m0rbidini> so I read the 2nd and 3rd lines and append them to a tuple, and them to a list
07:32:36 <m0rbidini> same for the number of macros... right?
07:32:45 <m0rbidini> or am I being too "imperative"?
07:32:54 <m0rbidini> the simplicity of Haskell still eludes me
07:33:16 <eivuokko> @type splitAt
07:33:16 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:33:32 <eivuokko> You probably want to make a list of to-be-macros and rest
07:33:42 <m0rbidini> yes
07:33:53 <m0rbidini> forall, thought, scans the whole list, right?
07:34:30 <eivuokko> Uhm, it is part of type signature
07:35:30 <eivuokko> forall a. foo   means, quite literally, that for all types a, foo is valid.
07:36:08 <eivuokko> So, it just means, in this case, that splitAt :: Int -> [a] -> ([a],[a])
07:37:40 <m0rbidini> this IO thing is a "monad", right? I mean, it just looks so "imperative"
07:37:46 <eivuokko> As for taking two first items and making tuple out of them, I'd probably just make a recursive function and pattern match.  like foo (name:value:rest) = (name,value):foo rest.
07:38:10 <Cale> m0rbidini: monads are kind of a generalisation of imperative languages if you look at them in one way
07:38:21 <Frederick> @localtime SamB
07:38:22 <lambdabot> Local time for SamB is Sun Nov 13 10:38:10
07:38:51 <m0rbidini> isn't Haskell supposed to be smarter? I saw the quicksort algorhytm and was baffled by it
07:39:11 <m0rbidini> this looks a lot like the Java cludge I wrote in comparison
07:39:19 <Cale> what are you writing?
07:39:28 <m0rbidini> except for all the "new"s on objects
07:39:35 <Cale> I've just started looking at the channel
07:39:40 <Cale> could I see your code?
07:40:01 <eivuokko> Your code is overusing monad, yes, but that's just few lines here or there
07:40:08 <eivuokko> http://pastebin.com/427775 is last I saw
07:40:21 <m0rbidini> a comparison of a "search and replace" between an imperative language and a "pattern matching" one (Haskell)
07:40:30 <m0rbidini> I chose Haskell over Prolog
07:40:42 <m0rbidini> but I just can't get it to work
07:40:42 <Cale> why not let nMacros = lines slist ?
07:40:53 <Cale> we
07:40:54 <Cale> er
07:40:59 <Cale> no
07:41:05 <Cale> let slist = lines s
07:41:06 <Cale> yeah
07:41:21 <m0rbidini> that makes sense, yeah
07:41:27 <Cale> then nMacros <- countMacros slist is clearly wrong
07:41:39 <Cale> because countMacros slist isn't an IO action
07:41:44 <Cale> so you can't run it for a result
07:41:51 <Cale> let nMacros = countMacros slist
07:42:14 <Cale> I don't see expandMacros
07:42:25 <m0rbidini> i haven't wrote it yet :)
07:42:26 <Cale> but this all looks like pure stuff
07:42:31 <Cale> you can use let to chain things together
07:42:44 <Cale> but you're not doing any IO there, so you don't really need the monad
07:43:01 <m0rbidini> how can I get "out" of IO
07:43:02 <m0rbidini> ?
07:43:22 <m0rbidini> the "monad" seems to enjail-me
07:43:32 <Cale> it does
07:43:38 <Cale> that's intentional
07:43:56 <neadjneki> you write pure functions then lift them into IO, so actually do the opposite i think
07:43:58 <Cale> but you can call pure functions from IO code
07:44:05 <Cale> yes
07:44:24 <Cale> the only stuff you should have to write in the IO monad is stuff that actually does IO
07:44:32 <shapr> It's amazing, once I finally understand what I'm doing, the code just flows from my fingers. Before I understand what I'm doing, it's all so difficult.
07:45:00 <m0rbidini> i felt the same after reading the quicksort in Haskell
07:45:09 <m0rbidini> so simple it takes a genius to write :P
07:45:11 <boegel|gf> shapr: how's that ?
07:45:19 <vegai> shapr: does that always happen?
07:46:46 <Cale> m0rbidini: I don't think I really understood quicksort until I saw the Haskell implementation
07:46:53 <m0rbidini> lol
07:47:07 <m0rbidini> yeah, it's pretty dense in C or Java
07:47:29 <shapr> vegai: Yeah, pretty much.
07:47:47 <vegai> good for you :)
07:47:50 <shapr> boegel|gf: I get type errors until I understand my problem.
07:48:06 <vegai> dunno what my problem is there. Lack of motivation, I hope.
07:48:31 <shapr> It's also amazing how much content there is in Haskell source.
07:49:49 <Cale> shapr: yeah, I found that when I was working on the scheduler, that most of the time I just had to think, and I spent very little time actually writing lines of code
07:50:29 <Frederick> Cale, Im feeling it right now
07:56:30 <m0rbidini> http://pastebin.com/427814
07:56:51 <m0rbidini> i'm getting an error about the last generator in the "do"
07:56:53 <m0rbidini> ?
07:58:45 <int-e> I don't think haskell understands your tabulator size of 2 ...
07:59:34 <int-e> and at a tab size of 8 the indentation is quite messed up.
08:00:30 <m0rbidini> i feel so stupid... i really feel like Knuth was right - I started coding in BASIC and will NEVER let go of the paradigm in my mind
08:01:56 <maitscha> hallo. what is wrong with the following while-statement? http://rafb.net/paste/results/Gr1SFP92.html
08:02:36 <m0rbidini> got it tabbed right - i get an error about "res" though
08:02:50 <Lemmih> maitscha: Um, there's no 'while' keyword in Haskell.
08:03:50 <m0rbidini> http://pastebin.com/427814
08:03:55 <m0rbidini> ping :P
08:04:05 <Frederick> maitscha, you sources looks like C
08:04:10 <m0rbidini> lol
08:04:17 <m0rbidini> (no offense)
08:04:42 <kombinator> m0rbidini: "writeFile ("out.txt") res" should have the same indentation as "s <- readFile filename" imo
08:04:55 <Lemmih> m0rbidini: Where do you define 'res'?
08:05:16 <Lemmih> m0rbidini: And 'let c   s = read (head (head [s])) in c ["10"] :: Int' is wrong.
08:05:48 <ndm> m0rbidini: i was a VB programmer first, now I'm a haskell programmer - it doesn't destroy you for life
08:07:23 <m0rbidini> Lemmih : tought that line was wrong
08:07:30 <m0rbidini> it doesn't make sense to me
08:08:22 <m0rbidini> i didn't get the "in c[10]" thingy
08:08:27 <Lemmih> m0rbidini: let res = read (head slist) :: Int, perhaps?
08:08:58 <Lemmih> m0rbidini: '["10"]' is a singleton list.
08:09:05 <shapr> Er, how do I turn two liftM5 calls into a liftM10?
08:09:18 <m0rbidini> the read is to assing the head of the list (a Char) to an Int (nMacros)
08:09:45 <gour> dcoutts: ping
08:09:57 <dcoutts> gour, pong
08:10:25 <gour> dcoutts: hi, i'm just chatting with ali (pida) author on #pida
08:10:51 <gour> dcoutts: he prepares 0.3 with integrated meld and language-independent
08:11:14 <m0rbidini> http://pastebin.com/427832 (getting hotter?)
08:12:09 <Lemmih> m0rbidini: Remove the 'in ["10"]' and 'expandMacros' is not an IO action.
08:12:38 <Lemmih> (so use 'let res = ...' instead of 'res <- ...')
08:13:46 <m0rbidini> how 'bout this http://pastebin.com/427835 ?
08:13:47 <gour> dcoutts: and he told me about gazpacho - glade-compatible ui desginer (written by oen of main gtk devs), you know for it?
08:14:11 <m0rbidini> type mismatch...
08:14:17 <Lemmih> m0rbidini: Good, but 'expandMacros' is still not an IO action.
08:14:30 <dcoutts> gour, yeah, hopefully it'll be better than glade
08:14:51 <m0rbidini> why not? I have it as "IO String" return
08:15:24 <Lemmih> m0rbidini: Oh, right.
08:17:05 <m0rbidini> Lemmih : why does Hugs assume read must be [Char] ?
08:17:39 <m0rbidini> i'm not converting it to an Int...
08:18:19 <Lemmih> @type read
08:18:20 <lambdabot> forall a. (Read a) => String -> a
08:19:00 <m0rbidini> so, read is sugar for Read ?
08:19:12 <Lemmih> m0rbidini: 'expandMacros' shouldn't be an IO action, IMHO.
08:19:38 <m0rbidini> is there any way other than the IO "loop" ?
08:21:17 <Lemmih> other way to do what?
08:21:26 <m0rbidini> expandMacros
08:21:43 <m0rbidini> how can I call it without being an IO action?
08:21:54 <m0rbidini> I haven't gone into "monads" very much.
08:22:01 <shapr> They're pretty simple.
08:22:01 <Lemmih> let res = expandMacros nMacros slist
08:22:09 <m0rbidini> hmm
08:22:21 <Lemmih> Just like 'read' and 'lines'.
08:22:54 <m0rbidini> ok, got that
08:23:02 <m0rbidini> but still the read problem...
08:23:09 <m0rbidini> i need another function
08:23:23 <Lemmih> How so?
08:24:01 <shapr> Is there an easy way to get liftM10 out of two liftM5 calls?
08:24:41 <Lemmih> shapr: You really need a liftM10? wow (:
08:24:50 <david__> respect!
08:24:54 <david__> ;)
08:25:06 <m0rbidini> http://pastebin.com/427856
08:25:13 <m0rbidini> i get an error in expandMacros
08:25:21 <m0rbidini> guess I should write it :)
08:25:37 <shapr> Actually, I need liftM11 for this Arbitrary instance, but if someone tells me how to build liftM10 from two liftM5 calls, I'll be good to go.
08:25:50 <Lemmih> m0rbidini: Delete the 'return' in 'expandMacros'.
08:26:23 <shapr> On the other hand, a simpler way to make Arbitrary instances for records would also solve my problem.
08:26:27 <Cale> m0rbidini: at which point (after deleting the return), you could just write  expandMacros i [s] = "cool"
08:27:03 <m0rbidini> got that
08:27:16 <m0rbidini> but the read is still eluding me
08:27:40 <m0rbidini> let nMacros = read (head (head slist))
08:27:48 <Lemmih> @type \a a1 a2 a3 a4 a5 a6 a7 a8 a9 a0 -> do b <- Control.Monad.liftM5 a a1 a2 a3 a4 a5; Control.Monad.liftM5 b a6 a7 a8 a9 a0
08:27:49 <lambdabot> forall a1 a2 a3 a4 a5 (m :: * -> *) r a11 a21 a31 a41 a51.
08:27:49 <lambdabot> (Monad m) =>
08:27:49 <lambdabot> (a1
08:27:49 <lambdabot> -> a2
08:27:49 <lambdabot> -> a3
08:27:50 <lambdabot> [19 @more lines]
08:27:57 <Lemmih> @more
08:27:57 <lambdabot> -> a4
08:27:57 <lambdabot> -> a5
08:27:57 <lambdabot> -> a11
08:27:58 <lambdabot> -> a21
08:28:00 <lambdabot> -> a31
08:28:02 <lambdabot> [14 @more lines]
08:28:03 <m0rbidini> type error
08:28:14 <Lemmih> @more
08:28:14 <lambdabot> -> a41
08:28:14 <lambdabot> -> a51
08:28:14 <lambdabot> -> r)
08:28:14 <lambdabot> -> m a1
08:28:14 <lambdabot> -> m a2
08:28:16 <lambdabot> [9 @more lines]
08:28:43 <Lemmih> m0rbidini: You've got a head too many.
08:29:24 <shapr> Lemmih: thanks
08:29:44 <Lemmih> shapr: I'm not sure that's the right way.
08:29:51 <shapr> I'll try it and see what happens.
08:29:53 <m0rbidini> got it! kinda... http://pastebin.com/427869
08:29:58 <m0rbidini> thx guys
08:30:04 <m0rbidini> now, the macros
08:30:06 <m0rbidini> :P
08:30:16 <Lemmih> m0rbidini: 'head [a]' is the same as just 'a'.
08:30:24 <Lemmih> > head [10]
08:30:25 <lambdabot> 10
08:30:26 <Lemmih> > 10
08:30:27 <lambdabot> 10
08:30:37 <Lemmih> > head [10] == 10
08:30:38 <lambdabot> True
08:30:38 <Cale> m0rbidini: you could also splice out all the pure stuff from that IO block and make it into its own function
08:33:14 <m0rbidini> wow . big error : Main> start "C:\\in.txt"
08:33:14 <m0rbidini> 2"
08:33:14 <m0rbidini> Program error: pattern match failure: expandMacros 2 ["2",_SEL (,) (lines_v822 (
08:33:14 <m0rbidini> break (instEq_v11 Eq_== '\n') "A" ++ _hreader {handle})) 1] ++ lines_v823 (_SEL
08:33:14 <m0rbidini> (,) (lines_v822 (break (instEq_v11 Eq_== '\n') "A" ++ _hreader {handle})) 2)
08:33:26 <m0rbidini> geez... :)
08:36:04 <Cale> hugs has awful errors
08:36:37 <Cale> but you've only defined expandMacros i [s] -- that is only for one-element lists
08:37:03 <ibid> dcoutts: here's the output of my sample answer to one of this week's exercises: http://www.mit.jyu.fi/antkaij/opetus/fo/2005-2006/demot/1-3_7-8.png
08:37:29 <ibid> though i like http://antti-juhani.kaijanaho.info/tmp/frakt.png much more (obtained by changing one line in the program)
08:38:10 <Cale> ibid: have you seen nymphaea?
08:38:42 <ibid> Cale: the name does not ring a bell
08:39:05 <dcoutts> ibid, that's cool
08:39:11 <Cale> hmm, now where did xerox put that page...
08:39:19 <dcoutts> @where nymphaea
08:39:19 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
08:39:30 <Cale> It's the LSystem generator which xerox and I have been working on
08:39:52 <Cale> well, that's the old version anyway
08:39:52 <ibid> ah, too advanced for this course then :)
08:39:57 <dcoutts> and the practical I'm running is based on it (though it doesn't share any code)
08:42:14 <m0rbidini> this code http://pastebin.com/427893 is accepted, but does not work
08:42:21 <m0rbidini> is the approach right?
08:42:58 <Cale> m0rbidini: what exactly are you trying to do?
08:42:59 <m0rbidini> the loadMacros function is too functional for me... how can I do something "i" times?
08:43:10 <shapr> Man, liftM14 made my eyes cross.
08:43:13 <m0rbidini> I want to fill the tuples list nMacros times
08:43:25 <Cale> m0rbidini: fill it with what?
08:43:31 <m0rbidini> the macros
08:43:37 <shapr> I need to setup the Template Haskell liftN for this code.
08:43:41 <m0rbidini> pairs of Char, String
08:43:48 <Cale> > replicate 5 'a'
08:43:49 <lambdabot> "aaaaa"
08:44:36 <m0rbidini> how can I "fill" the macros list?
08:45:00 <Cale> I don't understand at all what you mean by fill
08:45:13 <m0rbidini> I have nMacros
08:45:18 <Cale> a list is a list, you don't really fill it
08:45:41 <Cale> remember that everything is a constant
08:46:04 <m0rbidini> I want to place the 2nd(Char) and 3rd(String) indexes of slist as a tuple into the macros list
08:46:13 <m0rbidini> if i == 1
08:46:48 <m0rbidini> if it's 2, then it's 2 tuples, first one being 2nd and 3rd indexes the second being the 4th and 5th indexes
08:47:03 <m0rbidini> I need a for!! :P
08:47:19 <Cale> nMacros :: [(Char, String)]; nMacros = (read $ slist !! 1, read $ slist !! 2)
08:47:24 <Cale> ?
08:47:39 <Cale> do you know about map and filter and such?
08:47:47 <Cale> > map (*2) [1,2,3,4,5,6,7]
08:47:48 <lambdabot> [2,4,6,8,10,12,14]
08:48:32 <Cale> > filter (<3) [1,2,3,4,5,6,7]
08:48:33 <lambdabot> [1,2]
08:48:52 <m0rbidini> loadMacros		:: Int -> [String] -> [(Char,String)]
08:48:52 <m0rbidini> loadMacros i [s]	= macros = (read $ slist !! 1, read $ slist !! 2)
08:48:55 <Cale> > take 10 $ zip [1..] [10,20..]
08:48:56 <lambdabot> [(1,10),(2,20),(3,30),(4,40),(5,50),(6,60),(7,70),(8,80),(9,90),(10,100)]
08:48:57 <m0rbidini> this is wrong
08:49:08 <Cale> slist is out of scope
08:50:00 <m0rbidini> ok, I have loadMacros		:: Int -> [String] -> [(Char,String)]
08:50:07 <m0rbidini> loadMacros i [s]	= ???
08:50:19 <m0rbidini> "i" is the number of iterations
08:50:22 <Cale> are you defining some base case here?
08:50:55 <m0rbidini> no, maybe I should but recurring has always been hard for me :D
08:51:19 <Cale> [s] will only match a 1-element list
08:51:31 <Cale> and bind the only element of that list to s
08:52:07 <m0rbidini> yeah, but [s] contains the macros
08:52:21 <m0rbidini> and the text
08:53:09 <m0rbidini> maybe i should weed them out first
08:54:14 <m0rbidini> maybe I should give up and cough up the 20€ :)
08:54:35 <m0rbidini> (i made a bet, and the other guy wrote this in Java in 15 minutes)
08:54:41 <m0rbidini> it's my second day
08:54:46 <m0rbidini> still nothin'
08:55:38 <m0rbidini> Cale : how can I control the number of times this is done : nMacros = (read $ slist !! 1, read $ slist !! 2)
08:55:53 <m0rbidini> there is no while, right?
08:56:07 <Cale> do you mean ss or something?
08:56:16 <m0rbidini> maybe with a control list? and do a dropWhile?
08:56:19 <Cale> [s] -- this makes s refer to a single element of a list
08:56:21 <Frederick> @seen Samb
08:56:22 <lambdabot> I saw Samb leaving #haskell-blah, #haskell-overflow and #haskell 10
08:56:22 <lambdabot> minutes and 4 seconds ago.
08:56:32 <Cale> m0rbidini: you have to stop thinking of loops
08:56:41 <Cale> loops always do something
08:56:42 <m0rbidini> Cale : i'm trying... :)
08:56:58 <Cale> you have to start thinking in terms of what the loops accomplish again
08:57:27 <Cale> this is a more natural way of thinking, but you learn to forget about it while writing imperative programs :)
08:57:39 <int-e> oh! (head [slist]) ...
08:58:12 <Cale> head [slist] = slist
08:58:16 <m0rbidini> i know... i do a take from the list as I read what I want!
08:58:30 <Cale> > head [5]
08:58:31 <lambdabot> 5
08:58:35 <Cale> > head [[1,2,3]]
08:58:37 <lambdabot> [1,2,3]
08:58:39 <m0rbidini> take 1 [1,2,3]
08:58:48 <Cale> > take 1 [1,2,3]
08:58:49 <lambdabot> [1]
08:58:56 <m0rbidini> drop 1 [1,2,3]
08:59:05 <m0rbidini> init [1,2,3]
08:59:05 <Cale> don't forget the "> "
08:59:11 <m0rbidini> > init [1,2,3]
08:59:13 <lambdabot> [1,2]
08:59:16 <int-e> > drop 1 [1,2,3]
08:59:17 <lambdabot> [2,3]
08:59:22 <int-e> > tail [1,2,3]
08:59:23 <lambdabot> [2,3]
08:59:26 <m0rbidini> > tail [1,2,3]
08:59:27 <lambdabot> [2,3]
08:59:32 <m0rbidini> that's it!!!
08:59:36 <m0rbidini> i'll brb~
09:00:28 <m0rbidini> is this valid : let slist = tail slist ?
09:01:14 <int-e> m0rbidini: uh yes, but it
09:01:19 <int-e> will lead to confusion
09:01:34 <m0rbidini> i'm hoping it doesn't :P
09:01:56 <int-e> let slist' = tail slist  will cause less confusion and still saves you the effort of thinking of a new variable name.
09:02:40 <m0rbidini> thx
09:02:54 <Cale> let slist = tail slist just shadows the previous definition of slist with a new one
09:03:05 <Cale> it doesn't reassign anything
09:03:16 <Cale> and the old slist could still be hanging around
09:04:19 <m0rbidini> first index is 1, right ?
09:04:31 <int-e> > [1,2,3]!!1
09:04:32 <Cale> 0
09:04:32 <lambdabot> 2
09:04:55 <m0rbidini>  > [1,2,3]!!0
09:05:09 <int-e> no space :) but it'll be 1
09:05:17 <m0rbidini> > [1,2,3]!!0
09:05:18 <lambdabot> 1
09:05:24 <m0rbidini> thx :)
09:06:15 <m0rbidini> loadMacros 0 [s]	= [s]
09:06:15 <m0rbidini> loadMacros 1 [s]	= macros = (read $ s !! 0, read $ s !! 1)
09:06:15 <m0rbidini> 			  take 2 [s]
09:06:15 <m0rbidini> loadMacros n [s]	=
09:06:18 <m0rbidini> ???
09:06:30 <m0rbidini> what's the recursion where?
09:06:50 <m0rbidini> i have the 0 and 1 cases, what is the recursion expression ?
09:07:18 <int-e> the 1 case isn't right. the 0 case isn't right either.
09:07:27 <m0rbidini> geez... 2 strikes
09:07:36 <m0rbidini> i suck at proving cases
09:08:10 <m0rbidini> but this was the base idea, right?
09:08:10 <int-e> m0rbidini: the usual list recursion pattern is
09:08:17 <int-e> function [] = code for empty list
09:08:45 <m0rbidini> oh, but I have this INSIDE the function definition...
09:08:49 <int-e> function (hd:tl) = code for processing hd, with recursive call 'function tl'
09:09:57 <m0rbidini> http://pastebin.com/427927 this is what I thought could do
09:11:29 <m0rbidini> in loadMacros
09:11:54 <int-e> > map (\s -> (head s, tail s)) $ take 4 $ tail $ ["<nr>", "abc", "cde", "def", "ghi", "more text"]
09:11:55 <lambdabot> [('a',"bc"),('c',"de"),('d',"ef"),('g',"hi")]
09:12:40 <int-e> m0rbidini: the 0 case should be loadMacros 0 _ = []  (_ is a dummy variable for pattern matching - it basically means that the value there doesn't matter for the result)
09:14:26 <int-e> m0rbidini: and [s] is a pattern that matches *only* lists of length 1, binding s to the head of the list - you definitely do not want that. (m:ms) is a pattern that matches a non-empty list and binds m to the head, and ms to the tail of the list. that's much more useful.
09:16:19 <m0rbidini> but the thing is the list is like so : ["A","123","B","456","text","more text","even more"]
09:16:28 <m0rbidini> with a list like this, nMacros is 2
09:17:05 <m0rbidini> and I want to "fill" the macros list with [("A","123"),("B","456")] in this case
09:17:14 <int-e> m0rbidini: ok. you mean just s instead of [s] on the left side then
09:17:38 <Frederick> @seen Samb
09:17:39 <lambdabot> I saw Samb leaving #haskell-blah, #haskell-overflow and #haskell 31
09:17:39 <lambdabot> minutes and 21 seconds ago.
09:17:47 <int-e> loadMacros 0 s        = []  -- no macros to process, empty result
09:18:23 <m0rbidini> so, it's loadMacros 0 s		= macros = []
09:18:39 <m0rbidini> meaning, macros is empty
09:18:54 <int-e> no macros = there ... whatever should that do?!
09:19:51 <m0rbidini> when there are no macros (nMacros = 0), the list "macros" is []
09:19:51 <int-e> maybe you want  loadMacros n s = let macro = ... in macro:loadMacros (n-1) (drop 2 s)
09:20:10 <int-e> m0rbidini: it doesn't have a name. it's just a list.
09:20:28 <int-e> loadMacros 0 s = []   is exactly what you want.
09:20:32 <m0rbidini> loadMacros n s = let macro = ... in macro:loadMacros (n-1) (drop 2 s) : what does ... stand for?
09:20:43 <m0rbidini> creating the tuple?
09:20:50 <int-e> yep
09:21:06 <m0rbidini> with indexes? related to what? !!
09:21:23 <int-e> but you can also just write    loadMacros n s = ...:loadMacros (n-1) (drop 2 s) for that
09:21:50 <int-e> s!!0 is your first line, s!!1 your second line
09:21:54 * int-e shrugs
09:23:55 <m0rbidini> loadMacros n s = let macros = [(s!!0,s!!1)] in macros:loadMacros (n-1) (drop 2 s)
09:24:07 <m0rbidini> error:
09:24:16 <m0rbidini> *** Expression     : macros : loadMacros (n - 1) (drop 2 s)
09:24:16 <m0rbidini> *** Term           : macros
09:24:16 <m0rbidini> *** Type           : [([Char],[Char])]
09:24:16 <m0rbidini> *** Does not match : (Char,String)
09:24:45 <m0rbidini> the thing is, the even indexes are chars and the odd ones are Strings...
09:25:08 <m0rbidini> there's got to be a better way, this looks like a lot of cruft
09:26:30 <Korollary> m0rbidini: What are you trying to do ?
09:27:05 <m0rbidini> i have a list like so : ["A","123","B","456","text","text","text"]
09:27:13 <m0rbidini> and an int that equals 2 in this case
09:27:36 <m0rbidini> so I want to build a list of [("A","123"),("B","456")]
09:27:50 <m0rbidini> the int already equals 2
09:28:07 <m0rbidini> the recursion necessary is not in my grasp apparently
09:28:09 <Korollary> you wanna be able to group by 3 if n = 3 as well ?
09:28:17 <Lemmih> > let mkMac (a:b:rs) = (a,read b::Int):mkMac rs; mkMac _ = [] in mkMac ["name","10","other name","100"]
09:28:18 <lambdabot> [("name",10),("other name",100)]
09:29:21 <m0rbidini> if the int is 3m the list is : ["A","123","B","456","C","789","text","text","text"]
09:29:32 <m0rbidini> and the macro list would be
09:29:49 <m0rbidini> [("A","123"),("B","456"),("C","789")]
09:30:16 <Korollary> ok, the int specifies the number of tuples to form
09:30:21 <m0rbidini> precisely
09:30:22 <Lemmih> > splitAt (3*2) ["A","123","B","456","C","789","text","text","text"]
09:30:24 <lambdabot> (["A","123","B","456","C","789"],["text","text","text"])
09:30:35 <m0rbidini> gosh
09:30:40 <m0rbidini> that's... amazing :)
09:31:08 <Korollary> it's a tuple of lists instead of list of tuples, though
09:31:24 <m0rbidini> problem there
09:31:32 <Lemmih> 'mkMac' will make the tuple list.
09:31:40 <m0rbidini> I wanted to create the tuples and drop them from the main list as I go
09:31:53 <m0rbidini> splitAt is in the prelude?
09:32:00 <Lemmih> @index splitAt
09:32:01 <lambdabot> Data.List, Prelude
09:32:26 <Korollary> Yes, mkMac is more like it, although he doesn't want to convert "123" to 123.
09:33:00 <m0rbidini> how can I make a list of tuples... maybe mapping splitAt
09:33:03 <Korollary> so it's probably like "take n $ mkMac inputList"
09:33:03 <m0rbidini> ?
09:33:44 <Korollary> m0rbidini: splitAt works on a list to produce lists, so it won't give you tuples.
09:33:55 <m0rbidini> too good to be true
09:34:17 <m0rbidini> so I want to build them, but how can I control the iterations? I'm still tinking loops here...
09:34:23 <m0rbidini> damn Java! :P
09:34:34 <Korollary> m0rbidini: try solving a simpler example. how would you implement "take" ?
09:34:40 <shapr> Has anyone here played with the TCP/IP stack in House? I'm trying to figure out how parse and unparse work, any clues?
09:35:00 <Korollary> > take 3 [5,6,7,8,9,0]
09:35:01 <lambdabot> [5,6,7]
09:35:15 <m0rbidini> hmmm
09:35:24 <int-e> m0rbidini: should the macros be expanded simultaneously? i.e. if a -> bc and b -> cd, should 'a' expand to 'bc' or to 'cdc'?
09:36:00 <m0rbidini> in the "text" bits, the macros are marked as $A, so abc$A would expand into abc123
09:36:14 <int-e> ah
09:36:16 <m0rbidini> and abc$AB would expand into abc123B
09:36:40 <int-e> @type just
09:36:40 <m0rbidini> just a "simple" search and replace
09:36:40 <lambdabot> Not in scope: `just'
09:36:48 <m0rbidini> @type Just
09:36:48 <xerox> @type Just
09:36:49 <lambdabot> forall a. a -> Maybe a
09:36:49 <lambdabot> forall a. a -> Maybe a
09:37:35 <Cale> Haskell has regular expressions too, if that's the sort of thing you want.
09:37:58 <Korollary> m0rbidini: what is the type of "take" ?
09:38:14 <m0rbidini> Int -> [a] -> [a]
09:38:23 <m0rbidini> makes sense
09:38:27 <int-e> @index just
09:38:27 <lambdabot> bzzt
09:38:36 <m0rbidini> > take 2 [2,3,4]
09:38:37 <lambdabot> [2,3]
09:38:47 <Korollary> m0rbidini: ok, let's do pattern matching. What would you produce for "take 0 anyListYouCanThinkOf" ?
09:38:47 <m0rbidini> > take 2 ['a','b','c']
09:38:48 <lambdabot> "ab"
09:38:56 <int-e> @hoogle Maybe a -> a
09:38:56 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
09:38:56 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
09:38:56 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
09:39:05 <int-e> ah! fromJust.
09:39:26 <m0rbidini> [] ?
09:39:38 <Korollary> > take 0 "Blah"
09:39:39 <lambdabot> ""
09:39:51 <m0rbidini> take 0 [1,2,3,4]
09:39:54 <m0rbidini> > take 0 [1,2,3,4]
09:39:55 <lambdabot> []
09:39:59 <m0rbidini> yeah
09:40:13 <musasabi> let replace kvs [] = []; replace kvs ('$':x:xs) = maybe (error "...") id (lookup x kvs) ++ replace kvs xs; replace kvs (x:xs) = x:replace kvs xs
09:40:18 <Korollary> ok, how about "take 1 someList", where someList could possibly be empty
09:40:29 <m0rbidini> take would break
09:40:35 <Korollary> > take 1 []
09:40:35 <lambdabot> Add a type signature
09:40:38 <m0rbidini> > take 1 []
09:40:39 <lambdabot> Add a type signature
09:40:56 <paolino> good evening I have a question on classes
09:40:56 <m0rbidini> > take 1 []::Int
09:40:57 <lambdabot> Couldn't match `Int' against `[a]'
09:41:02 <m0rbidini> > take 1 []::a
09:41:03 <lambdabot>  a
09:41:03 <lambdabot>   Inferred type: [a1]
09:41:03 <lambdabot>   In the application `take 1 []'
09:41:03 <Lemmih> > take 1 ([]::[Int])
09:41:04 <lambdabot> []
09:41:21 <m0rbidini> > take 1 ([]::[Int])
09:41:22 <lambdabot> []
09:41:25 <m0rbidini> hmmm
09:42:06 <Korollary> Weird. The report says "take _ [] = []"
09:42:25 <paolino> if two instances have different constraints on same method ,how to  signal it ?
09:42:43 <m0rbidini> > take 1 ([]::[a])
09:42:43 <lambdabot> Add a type signature
09:43:20 <paolino> if I try to correct the signature of the method in the instance I get a mispaced signature
09:43:39 <int-e> > take 1 ([]::Show a => [a])
09:43:40 <lambdabot> Add a type signature
09:43:53 <Korollary> it shouldn't ask for a type signature here
09:44:15 <int-e> Korollary: it can't derive a Show instance for the result list
09:44:32 <int-e> Korollary: ghci has some awful type hackery to make it work for that case.
09:44:46 <Frederick> @localtime ski_
09:44:47 <lambdabot> Local time for ski_ is Sun Nov 13 18:44:53
09:45:06 <int-e> Korollary: or a special case for printing empty lists. I forgot.
09:45:17 <ibid> > take 1 ([]::[Int])
09:45:18 <lambdabot> []
09:45:29 <m0rbidini> i'm giving up
09:45:34 <m0rbidini> i lost my bet
09:45:36 <int-e> > null (take 1 [])
09:45:37 <lambdabot> True
09:46:30 <Korollary> oh I see.
09:46:36 <m0rbidini> I don't doubt Haskell rocks, but this simple task has proven way beyond the skill of a newbie as me
09:46:41 <shapr> Anyone know of Arbitrary instances for Data.Array types?
09:46:55 <Korollary> m0rbidini: what was your bet ?
09:46:56 <shapr> What was your bet?
09:46:58 <Cale> m0rbidini: well, Haskell takes a different way of thinking :)
09:47:02 <m0rbidini> 20€ :P
09:47:12 <Cale> m0rbidini: how long have you been writing Haskell code?
09:47:13 <Korollary> m0rbidini: what was the challange, that is
09:47:21 * Korollary misspells profusely
09:47:26 <m0rbidini> Cale : 2 days
09:47:37 <int-e> m0rbidini: you should try to make your functions do less at once
09:47:49 <m0rbidini> the challenge was producing an app that could do what a friend of mine did in Java in 15 minutes
09:47:49 <Cale> m0rbidini: okay, could you have done this after 2 days of learning your first programming language?
09:47:52 <m0rbidini> in 48 hours
09:47:54 <paolino> Is my question clear enough ?
09:48:01 <int-e> m0rbidini: for example, your expandMacros as in the paste does two things: concatenate lines and expand macros
09:48:20 <Korollary> paolino: the two instances have to have the same signature
09:48:24 <m0rbidini> the thing is i don't "see" this
09:48:24 <int-e> m0rbidini: for one of those, the Haskell library actually provides a function already - unlines concatenates lines
09:48:50 <m0rbidini> i know the Prelude has a lot of useful functions
09:48:58 <m0rbidini> but I think I'm stuck in imperative land
09:49:05 <int-e> m0rbidini: so you can get away with using that and coding a simpler expandMacros function that only deals with a single string instead of a list
09:49:14 <m0rbidini> I mean, after seeing quicksort in 4 lines, is looks logical
09:49:20 <m0rbidini> but writing it? geez
09:49:33 <paolino> Korollary ,the suggestion is Probable fix: add (Ord c) to the class or instance method `Classes.Cluster.map' is that a half wrong suggestion ?
09:49:34 <Korollary> m0rbidini: you'll get used to it after a few weeks
09:49:52 <int-e> lisppaste, url
09:49:52 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:50:06 <m0rbidini> I'm giving up on functional languages : I suck at Prolog, ML and now Haskell
09:50:34 <Korollary> m0rbidini: why do you think you should pick it in just two days ?
09:50:38 <m0rbidini> Java, Python and Ruby adapt to my brain much easierly
09:50:45 <lisppaste2> int-e pasted "macro expansion in haskell" at http://paste.lisp.org/display/13544
09:50:53 <m0rbidini> because I picked Python up in 1 day
09:50:55 <m0rbidini> :P
09:50:57 <shapr> m0rbidini: Because they are different in syntax, not basic viewpoint.
09:51:06 <shapr> I picked up Python in a day after knowing Java and VB.
09:51:18 <Korollary> m0rbidini: Python to Java is like French to Spanish. Haskell is like Japanese in that analogy.
09:51:22 <shapr> Haskell still took me a few weeks until I was able to see how to structure my code.
09:51:50 <int-e> Haskell has a lot of syntactic sugar to get used to, a different mind set of thinking about programs and a lot of stuff in the standard library to learn about.
09:51:59 <paolino> Korollary  ?
09:52:15 <shapr> m0rbidini: Haskell has very few pieces, but very many ideas. Once you understand the ideas, you don't need the many pieces you see in other languages.
09:52:21 <Korollary> paolino: why dont you lisppaste your question ?
09:52:30 * shapr throws lambdas
09:52:39 * int-e catches a lambda
09:52:51 * Korollary pattern-matches
09:52:59 * basti_ throws an error
09:53:07 * sieni_ throws up
09:53:09 * shapr writes an Arbitrary instance for Data.Array.UArray
09:53:12 <m0rbidini> int-e : your solution... how does it run? (i don't even know that)
09:53:22 <m0rbidini> main "C:\\file.txt"
09:53:24 <m0rbidini> ?
09:53:27 * int-e bends a lambda so it looks like a tau, and throws it back at shapr where it arrives as a bottom symbol
09:53:30 * paolino get holed
09:53:44 <m0rbidini> oh, it's main :)
09:53:47 <int-e> m0rbidini: nah, I was too lazy; it just reads input from input.txt and writes output to output.txt
09:53:51 * shapr does some lambda lifting to get big brain muscles.
09:54:08 * Korollary uses illegal substances to improve his lambdas
09:54:34 * paolino produce them in the field
09:54:37 <Korollary> amazing emotions running wild in a channel of 187 clients.
09:54:52 * musasabi uses a null-mapping for all these buffed-lambdas to create a vast sea of useless bottoms
09:55:08 <shapr> I want a collection of Arbitrary instances for all the standard types :-/
09:55:14 <shapr> It's no fun writing bunches of my own.
09:55:31 <Korollary> @index Arbitrary
09:55:31 <lambdabot> Test.QuickCheck, Debug.QuickCheck
09:55:43 <ibid> shapr: derving (Arbitrary)? :)
09:55:55 <shapr> Does that work for unboxed arrays?
09:56:29 <ibid> i don't expect it to work at all
09:57:05 <Korollary> shapr: I suppose that's why QuickCheck is at version 0.2
09:57:31 <shapr> Does anyone have an Arbitrary instance for any of the Array flavors?
09:58:02 <paolino> Korollary, you want a compilable code ? (Leaving out the error of the question ?)
09:58:33 <Korollary> paolino: just the typeclass and instance declarations
09:58:40 <paolino> k
09:59:25 <lisppaste2> paolino pasted "classes rock ?" at http://paste.lisp.org/display/13545
10:00:29 <xah> is there a ghc for os x 10.4?
10:01:01 <noj> xah, darwinports is what I use
10:01:06 <paolino> Korollary, my problem is with 'map' method
10:01:18 <paolino> with its 'c' parameter
10:02:12 <xah> noj: what's the diff between darwinports & fink?
10:02:32 <noj> fink == binary packages, older versions. dports == compile from source, newer versions
10:03:04 <m0rbidini> well, thx for all the help guys. The talk was worth the 20€. :D
10:03:19 <m0rbidini> I haven't given up on Haskell, but Ruby is my new toy now.
10:03:20 <ibid> 20 null characters?
10:03:26 <m0rbidini> thank you all for your time
10:03:28 <m0rbidini> bye
10:03:53 <int-e> you're welcome :)
10:04:28 <paolino> mmhh I met haskell and ruby almost together, then I read STM paper .....
10:04:48 <xah> noj: i've been using fink for years... would it cause any conflict or other system headaches to get dp now?
10:05:18 <noj> xah, depends on how bad you want ghc 6.4.1 :)  but dports installs into /opt/local, so it shouldn't be an issue
10:05:29 <xah> noj: cool. thx.
10:05:51 <paolino> I'm not sure if I'm discriminating ruby or I am discriminated by haskell :/
10:09:09 <paolino> Korollary I can force Groupable on 'c', but I know this will strike me again in the future.Anyway the rule is same methods in different instances has to have same constraints on their parameters ?
10:10:03 <Korollary> paolino: Yes
10:10:25 <paolino> mmhh a bit rude
10:11:28 <paolino> I really don't see the reason, but I have no idea on how it works haskell internals
10:11:37 <Korollary> paolino: would you consider them to be of the same typeclass if they differed in method signatures ?
10:12:10 <paolino> well the signature is the same
10:12:38 <paolino> they just have a different constraint on a "third" paramater
10:12:52 <Korollary> context is part of the signature
10:14:24 <paolino> this means the typeclass is aware on something regarding its specific instances
10:15:22 <paolino> can't be generic on things it doesn't care about for its functioning
10:16:33 <Korollary> paolino: I don't understand what you are saying, but if you look at Class Monad, it doesn't care about how (>>=) works. It just wants to have it a specific type.
10:16:58 <Korollary>  s/wants to have it/wants it to have/
10:17:12 <Maddas> xah: I used fink to install ghc
10:17:52 <Maddas> xah: Works fine here, version 6.4.1-1
10:18:44 <paolino> Korollary np I need some more understanding before I can question
10:21:50 <Maddas> noj: I always compile from source with fink...
10:23:10 <xah> maddas: it turns out the latest also came in a binary... http://haskell.org/ghc/download_ghc_64.html#macosx
10:23:23 <xah> but i've got dawinport now anyway.
10:23:36 <Maddas> xah: Oh, nifty
10:23:59 * boegel|gf is bored again
10:26:21 <noj> Maddas, I see. I've not really used fink that much, especially not the source-based packages
10:28:50 * boegel|gf asks: what topic should be the first in the 'take 10 [1..]' series of articles for The Monad.Reader ?
10:33:40 * boegel|gf blinks on the amount of reply he's getting
10:34:19 <Korollary> boegel|gf: why don't you ask boegel ?
10:37:32 <musasabi> tools and typical mistakes are quite high on my list at least.
10:40:40 <boegel|gf> Korollary: I am boegel :P
10:40:49 <boegel|gf> musasabi: ok, one vote in
11:04:56 <takuan> damn, stuck again
11:05:45 <takuan> can you use functions as in pattern matching?
11:07:05 <takuan> what I have is a class Rng which has a function zzero:: a which contains the zero element for a ring
11:07:31 <takuan> now I would like to use the value zzero in some pattern matching
11:07:43 <takuan> apparently that's not possible
11:08:50 <takuan> is there a way around this?
11:09:49 <kombinator> use x == zzero (needs Eq class)
11:11:09 <takuan> ah
11:13:47 <takuan> thanks
11:47:36 <xah> when i put in a file      putStr "hi", and run in shell ghc myfile.hs
11:47:45 <xah> why would it say parse error?
11:48:26 <xah> haskell tutorial said it should work in hugs
11:48:53 <sploo22> if you want to run it as a program, try: main = putStr "hi"
11:49:09 <sploo22> or you can just type putStr "hi" at the interactive prompt
11:53:53 <xah> sploo22: is it supposed to work in hugs as is?
11:54:17 <Korollary> xah: in the interactive prompt, yes.
11:54:49 <sploo22> i don't have hugs installed but it works fine for me in ghci
11:54:52 <xah> hugs also comes in interactive mode?
11:55:02 <Korollary> xah: hugs and ghci are interactive interpreters
11:55:56 <xah> my experiences so far with ghc/ghci isn't great... for instance, the above problem, but then if i use simply ghci, then there's the problem that i can't define types or the like...
11:56:15 <Korollary> xah: the way to go is to put your code in a file and load it in ghci
11:56:27 <xah> o, ok. Let me try
11:56:35 <eivuokko> And :reload is your friend
11:56:45 <Korollary> xah: use :load <filename> to load. And when you make changes, just do a :reload
11:57:02 <Korollary> xah: :l and :r are the short versions of the commands
11:57:07 <sploo22> the problem is, putStr "hi" isn't a valid program. it's an expression, not a declaration
11:57:29 <sploo22> you can declare your types and functions in a file, and then evaluate and test them in hugs/ghci
11:57:46 <Korollary> @google yaht.pdf
11:57:47 <lambdabot> http://cs.annauniv.edu/~portal/files/dev/haskell-yaht.pdf
11:57:58 <xah> whats the diff between ghc and ghci?
11:58:04 <Korollary> that tutorial goes step by step, iirc
11:58:05 <xah> i mean, when would i use ghc?
11:58:12 <Korollary> xah: ghc is the native code compiler
11:58:25 <xah> file not found
11:58:56 <xah> mm... ok. thanks... i'm back to reading..
11:59:39 <xerox> xah: Haskell is not a dynamic language (modulo hs-plugins).  Anyway, you can introduce new bindings in GHCi using the syntax 'let <name> [<args>] = <expression> [:: <type>]' (where things enclosed in '[' ']' are optional.)
11:59:56 <Frederick> @localtime ski_
11:59:57 <lambdabot> Local time for ski_ is Sun Nov 13 21:00:03
12:00:06 <Frederick> @seen Samb
12:00:07 <lambdabot> I saw Samb leaving #haskell-blah, #haskell-overflow and #haskell 3 hours,
12:00:07 <lambdabot> 13 minutes and 49 seconds ago.
12:00:42 <xah> thx xerox :) good noon or so. :)
12:00:46 <xerox> xah: also, hugs is only an interpreter, while GHC comes with 'ghc', the compiler, and 'ghci', the interactive interpreter (which works like being in a 'do' block)
12:00:59 <xerox> xah: you're welcome, good 'yourtimehere' too :-)
12:01:46 <palomer> man, I got to finish this semester so I can get into haskell
12:01:49 <palomer> and start contributing to yi!
12:06:36 <Frederick> palomer, im trying to use haskell to finish the semester :p
12:07:33 <Frederick> brb
12:11:13 <Speck> are there any good examples of Ralf Hinze's and Johan Jeuring's web in Haskell? http://citeseer.ist.psu.edu/hinze01web.html
12:12:36 <palomer> hrm
12:12:42 <palomer> what exactly is a "combinator parser"?
12:12:57 <Speck> see Parsec
12:14:04 <palomer> parsec seems to be a library, is this true?
12:14:10 <Speck> yes
12:14:24 <Speck> PArrows is a parsec-like library using arrows
12:14:47 <palomer> I've always wondered, why not just write a parser/generator that simply generates the parse tree, and then you can do whatever you want with the parse tree afterwards
12:15:11 <palomer> instead of running code at every reduce
12:15:28 <vegai> what we really need is an AI that takes a look at the file and produces a parser from it
12:15:41 <vegai> from it, for it
12:16:06 <palomer> vegai: that's a very interesting idea
12:16:25 <palomer> has anyone ever thought of making one?
12:16:41 <Speck> I feel like the AI would need to make too many assumptions to be future-proof
12:17:18 <vegai> if a human can do it...
12:17:51 <vegai> palomer: not that I have heard
12:18:04 <vegai> it's probably still in the "science fiction" departement
12:20:24 <vegai> Speck: I would assume that the AI could finetune the parser while using it
12:20:29 <vegai> a bit like humans would do
12:20:49 <Speck> you can't get me to say it would be easy :-)
12:20:50 <vegai> if you see one string in some language, you can make some assumptions, and when you see another, you can make more
12:20:53 <vegai> and so on
12:21:27 <vegai> not easy, but it would be quite spiffy
12:21:57 <vegai> this will happen a day before the machines take over
12:22:04 <Speck> haha yeah
12:22:22 <Speck> with great computational understanding comes great responsibility
12:32:22 <xah> speck: like this? http://xahlee.org/Periodic_dosage_dir/lanci/merko/xadni_pixra/al-spiderman.jpg
12:32:56 <sebell> That guy obviously wasn't ready for responsibility when he chose that tattoo
12:33:20 <xah> well... that's WASP American
12:35:03 <Speck> funky
12:35:59 <xah> if i put â€œputStr "ttt"â€ in a file x2.hs, and run ghci's :l the file, why it says parse error?
12:39:01 <sploo22> you need to put "main =" before that, otherwise it's not a complete program
12:45:43 <qnix_> hi all
12:45:47 <palomer> yo.
12:46:11 <qnix_> hope someone could help me with this little monad exercise.
12:47:10 <qnix_> i am trying to learn monad from "all about monad".  on ex3
12:48:04 <qnix_> parent s = (maybeToList (mother s) `mplus` (maybeToList (father s))
12:48:19 <qnix_> I had no problem arrive to that, but this stump me.
12:48:34 <qnix_> grandparent s = do p<- parent s; parent p
12:49:14 <qnix_> how does that type check because: parent :: Sheep -> [Sheep] ???
12:49:57 <xah> i got tired of the incompatibilities of ghc with online tutorials, i'm gettin hugs
12:50:13 <basti_> qnix_: could you maybe give the URL of that exercise?
12:51:36 <qnix_> basti_: http://www.nomaware.com/monads/html/exercises.html.   it 's ex 3
12:52:44 <basti_> @plugs [2,3] `mplus` [4,5]
12:52:45 <lambdabot> [2,3,4,5]
12:52:49 <palomer> qnix_: wouldn't grandparent :: Sheep -> [[Sheep]] ?
12:53:12 <basti_> actually granparent could be Sheep -> ((Sheep,Sheep),(Sheep,Sheep))
12:53:29 <palomer> basti_: but parent :: Sheep -> [Sheep]
12:53:38 <basti_> yes
12:53:45 <qnix_> no, it's:  grandparent :: Sheep -> [Sheep]    -- I gave up so I peek at the answer :)
12:53:48 <basti_> one sheep has potentially several parents
12:54:03 <qnix_> yes
12:54:04 <basti_> and one sheep also has potentially several grandparents
12:54:11 <qnix_> yes
12:54:14 <basti_> not several sets of several grandparents.
12:54:29 <qnix_> y
12:54:56 <basti_> well, who are your granparents?
12:54:59 <palomer> basti_: what if we're unsure and we can't go on maury?
12:55:06 <basti_> A and B, and then C and D?
12:55:09 <basti_> or A,B,C and D?
12:55:14 <qnix_> does this has anything to do with the fact that List is also a monad?
12:55:31 <basti_> kinda, yes. that enables "do" notation
12:56:06 <palomer> did we actually need to go into category theory to invent the do notation?
12:56:15 <basti_> no why
12:56:25 <palomer> one of the tutorials implied so
12:56:36 <palomer> "to solve this, we needed to go deep into category theory" or somesuch
12:56:40 <Korollary> the do-notation is just syntactic sugar. has nothing to do with CT
12:56:40 <basti_> ahh
12:56:51 <palomer> ok, then monads
12:57:36 <basti_> @plugs  [2,4] >>= \x->[x+1,x+2] >>= \x->[x,x+10,x+20]
12:57:37 <lambdabot> [3,13,23,4,14,24,5,15,25,6,16,26]
12:58:16 <basti_> @plugs do { x<-[2,4] ; y<-[x+1,x+2] ; [y,y+10,y+20] }
12:58:17 <lambdabot> [3,13,23,4,14,24,5,15,25,6,16,26]
12:58:51 <Korollary> hey astro
12:59:44 <astrolabe> Hia Korollary.  How's things?
12:59:59 <Korollary> things are all right. watching US soccer heh.
13:05:49 <qnix_> I got it.  thanks basti_.  It start to make sense to me when I think in "list comprehension" term: [ parent p | p <- parent s ]  -- is that about right ?
13:06:05 <basti_> qnix_: yes.
13:06:13 <basti_> qnix_: it's basically the same sort of stuff
13:14:00 <araujo> Hello Haskell'ers!!!!
13:14:39 <basti_> hi araujo
13:28:14 <ndm> @seen dons
13:28:14 <lambdabot> I haven't seen dons.
13:30:07 <dons> @seen dons
13:30:07 <lambdabot> I haven't seen you.
13:30:14 <dons> lambdabot, you're nuts.
13:30:22 <Korollary> it just believes in evolution
13:30:28 <dons> @seen dons
13:30:28 <lambdabot> I haven't seen you.
13:30:34 <dons> @2seen ndm
13:30:34 <lambdabot> ndm is in #haskell-overflow, #haskell-blah and #haskell. Last spoke 2
13:30:34 <lambdabot> minutes and 20 seconds ago.
13:30:37 <dons> hmm
13:30:42 <dons> @seen dons
13:30:42 <lambdabot> I haven't seen you.
13:30:45 <dons> stop it!
13:30:54 <ndm> hehe, its got upset with you!
13:30:58 <Korollary> it's referentially transparent
13:31:03 <dons> hehe
13:31:23 <ndm> i am doing some improvements to hoogle
13:31:28 <dons> ah, cool.
13:31:35 <ndm> i've removed all of Graphics.* from teh docs - reasonable?
13:31:52 <dons> yes. also, I noticed something last night:
13:31:59 <dons> @hoogle Double -> Int
13:32:00 <lambdabot> Text.Regex.Posix.regExtended :: Int
13:32:00 <lambdabot> Text.Regex.Posix.regIgnoreCase :: Int
13:32:00 <lambdabot> Text.Regex.Posix.regNewline :: Int
13:32:05 <dons> is kind of a bad result
13:32:11 <dons> when I want:
13:32:12 <dons> @type round
13:32:12 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:32:13 <dons> perhaps
13:32:15 <ndm> yeah, i'll add it to the list of bad results
13:32:33 <ndm> i'm not touching the matching at this point, so i'll investigate that at a later date
13:32:38 <dons> ok.
13:32:41 <ndm> does IRC have any way of outputting colours?
13:32:53 <dons> hmm. yes. there's is some way.
13:32:56 <basti_> ndm: please abstain from any attempt to do so.
13:33:00 <dons> though not all clients will use it
13:33:22 <dons> whoo: "I'm pleased to announce the release of darcs 1.0.4"
13:33:27 <basti_> if you want to highlight stuff, use bold,underlined  or  flashing text. Flashing text is the last resort though.
13:33:33 <basti_> oops
13:33:41 <ndm> well, i have added support to the command line version for ansi escape characters
13:33:47 <ndm> but its off by default
13:34:08 <basti_> the point is that colors are non-standard
13:34:23 <ndm> i'll leave it off then
13:35:08 <basti_> its usually not recieved well
13:35:21 <basti_> "sftu n00b!" etc.
13:35:56 <dons> and irc users are kinda picky about fonts and colours and the like.
13:36:06 <dons> as happenend when lambdabot started using notices
13:36:11 <dons> and everyone got flustered
13:36:25 <basti_> notices are annoying, too, yes.
13:36:26 <basti_> ^^
13:36:33 <Cale> which is dumb, since it's really an issue of misconfigured/broken clients there
13:36:49 <dons> it's in the rfc people! get a better client :)
13:37:46 <Korollary> it's time for MS to embrace and extend the irc rfc
13:38:11 <dons> or at least try  to follow it
13:38:56 <dons> @seen dons
13:38:56 <lambdabot> I haven't seen you.
13:38:58 <Cale> MS?
13:39:00 <dons> bah
13:39:28 <Cale> MS has an IRC client?
13:39:45 <Korollary> Cale: not afaik. but why not !
13:39:46 <Frederick> Cale, not afaik
13:39:51 <dons> oh, the problem was gaim, wasn't it?
13:39:53 <Lemmih> @vixen Why don't you wanna look at dons?
13:39:54 <lambdabot> whoa whoa whoa, one question at a time!
13:39:56 <Cale> Yeah
13:40:13 <dons> @seen Lemmih
13:40:13 <lambdabot> Lemmih is in #haskell. Last spoke 19 seconds ago.
13:40:15 <Cale> gaim has ridiculous settings for notices
13:40:25 <Lemmih> @seen Lemmih
13:40:26 <lambdabot> You are in #haskell. Last spoke just now.
13:40:36 <Lemmih> @seen dons
13:40:36 <lambdabot> I haven't seen dons.
13:40:38 <dons> lookks like I broke one particular case branch when rewriting @seen last week
13:40:49 <dons> hmm. no, that doesn't make sense
13:40:57 <dons> @uptime
13:40:57 <lambdabot> uptime: 1 day, 20 hours, 56 minutes and 11 seconds
13:41:07 <dons> @quit
13:41:11 <dons> @seen dons
13:41:18 <Korollary> hmm
13:41:23 <lambdabot> You are in #haskell-overflow and #haskell. Last spoke just now.
13:41:28 <dons> resync the state.
13:41:37 <dons> that's  clearly a bug though
13:42:04 <xah> i just tried to use darwinports to install hugs98... it stuck at the line "--->  Attempting to fetch readline-5.0.tar.gz from ftp://ftp.gnu.org/gnu/readline" for over 30 min now. Is this normal?
13:42:20 <xah> top shows tclsh8.4 hogging cpu.
13:43:01 <ski_> evening, #haskell
13:43:09 <dons> morning ski_
13:43:14 * dons sips on coffee
13:43:39 * ski_ yawns
13:45:00 <Igloo> xah: No idea, but stracing it might reveal something
13:45:47 <xah> stracing?
13:46:12 <Igloo> Using strace, or perhaps truss
13:47:07 <xah> mm... not in os x. Not familiar with them.
13:47:39 * Igloo doubts tclsh should be using much CPU in the hugs build process, anyway
13:48:07 <xah> i'll give it another 10 min... then kill it. Am going back to fink after that.
13:48:25 <Korollary> readline is not a big package. It shouldnt take 30 mins.
13:48:30 <Cale> readline-5.0.tar.gz  	1767 KB  	08/03/2004  	12:00:00 AM
13:49:13 <xah> i'm running port inside a shell in emacs... so i'm thinking possibly it might just be a appearance glitch...not sure.
13:49:29 <xah> i.e. of the fact stucking on that line.
13:49:48 <Korollary> do a ps -aef in another shell. if it's 30 mins old, it's stuck.
13:49:53 <dons> @remember lambdabot Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
13:51:54 <ski_> dons : hm ?
13:52:04 <dons> build error in lambdabot :}
13:52:22 <ski_> mhm
13:52:37 <dons> simple, but fun
13:53:13 <ski_> it said this for what query ?
13:53:39 <dons> no, it said this when trying to compile it
13:53:46 <dons> after sjw had hacked on it a bit.
13:53:47 <ski_> ah
13:54:04 <dons> fortunately it is usually hard to get kind errors at runtime ;)
13:54:39 <dons> >> Attempting to fetch /usr/ports/distfiles/darcs-1.0.4.tar.gz from http://www.darcs.net/.
13:54:41 <ski_> even with plugs ?
13:54:42 <dons> :D
13:54:43 <xah> korollary: killed it.
13:54:51 <dons> ski_, yes, that could do it
13:54:54 <xah> korollary: are you on solaris or bsd?
13:55:18 <ski_> (hm, run-time kind error, sounds scary :)
13:55:26 <ski_> hi Buggaboo
13:55:35 <Buggaboo> hey ski
13:55:50 <Buggaboo> I managed to compile hugs!
13:55:54 <ski_> nice :)
13:57:09 <ski_> > unwords . replicate 3 $ "hooray !"
13:57:09 <lambdabot> "hooray ! hooray ! hooray !"
13:57:50 <dons> a cookie for anyone who gets lambdabot to print a kind error in @eval
13:57:58 <dons> the above kind error.
13:59:11 <ski_> Buggaboo : so, are you going to go through tutorials now ?
13:59:22 <Buggaboo> I already know haskell :)
13:59:32 <Buggaboo> much better than my prolog mind you.
13:59:45 <Buggaboo> I didn't manage to finish my agent ai btw.
13:59:50 <ski_> ah, ok
13:59:52 <mauke> haha, I managed to compile my parsing lib
13:59:53 <Buggaboo> *sigh*
14:00:02 <mauke> I wonder if it works
14:00:14 <wilx> Do you realise that putting space between word and interpunction is unholy?
14:00:26 <dons> a new parsing lib, mauke?
14:00:29 <Buggaboo> I had two synchronous deadlines, one java raytracer (didn't finish all the required specs either)...
14:00:45 <mauke> dons: yeah, I wanted to understand how parsec works so I wrote my own
14:00:46 <Buggaboo> and the other one was the wumpus world ai agent...
14:00:49 <dons> @foldoc interpunction
14:00:51 <lambdabot> No match for "interpunction".
14:00:59 <dons> @dict interpunction
14:00:59 <lambdabot> Supported dictionary-lookup commands:
14:00:59 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
14:00:59 <lambdabot> jargon @lojban @prelude @vera @web1913 @wn @world02
14:00:59 <lambdabot> Use "@dict-help [cmd...]" for more.
14:01:11 <dons> @web1913 interpunction
14:01:12 <lambdabot> *** "Interpunction" web1913 "Webster's Revised Unabridged Dictionary (
14:01:12 <lambdabot> 1913)"
14:01:12 <lambdabot> Interpunction \In`ter*punc"tion\, n. [L. interpunctio, fr.
14:01:12 <lambdabot>  interpungere, interppunctum, to interpoint. See {Inter-}, and
14:01:12 <lambdabot>  {Point}.]
14:01:14 <lambdabot>  The insertion of points between word or sentences;
14:01:16 <lambdabot>  punctuation.
14:01:22 <dons> there you go!
14:01:27 <Buggaboo> ski: actually... I might get into a few tutorials... it's been two years now...
14:01:45 <Buggaboo> ski:  I haven't looked into the oop aspects of haskell yet, dunno much about it.
14:01:53 <wilx> :)
14:02:07 <dons> hehe
14:02:18 <ski_> (wilx : i consider the other way around nonproper :)
14:02:33 <wilx> Eh, you are confused! :)
14:02:59 <wilx> You need to get exorcized!
14:03:27 <wilx> Really, think about it, have you ever seen such use in books or news papers?
14:03:41 * ski_ 's foaming
14:03:58 <ski_> no
14:04:00 <ski_> so ?
14:04:26 <wilx> So it is obviously uncommon :)
14:06:11 <ski_> better make it more common , then :)
14:06:22 <ski_> you have to start somewhere
14:06:29 <wilx> :)
14:07:10 <Korollary> xah: I'm on winxp hehe.
14:09:09 <Cale>  Ithin kw eshoul dmov espace son et oth elef t
14:10:27 <wilx> :)
14:11:47 <dons> ndm, should I try yhc on some of my funny openbsd machines?
14:12:00 <dons> powerpc, amd64
14:12:03 <dons> sparc.
14:12:13 <dons> since nhc is dead there now
14:12:20 <dons> (did I say that??)
14:12:36 <ndm> yep, try yhc there
14:12:50 <ndm> and add yourself to the ports list :)
14:12:54 <ndm> @wiki Yhc/Todo
14:12:55 <lambdabot> http://www.haskell.org/hawiki/Yhc/Todo
14:12:58 <dons> do you compile it with -O, btw?
14:13:06 <ndm> with ghc?
14:13:08 <ndm> no
14:13:14 <dons> maybe you should..
14:13:26 <dons> or, more to the point, why not?
14:13:27 <ndm> will try it tomorrow, see if its any faster
14:13:32 <ndm> its not the default
14:13:36 <ndm> its 3 more key strokes :)
14:13:44 <dons> I bet it's faster :)
14:13:54 <Korollary> dons: have you ever built jhc ?
14:13:57 <ndm> will do that tomorrow, for the graph :)
14:14:00 <dons> once
14:14:40 <xah> Korollary: winxp! how did you get that ps -aef then? i don't believe cywin come with a bsd ps.
14:14:43 <ndm> how much slower is building with -O?
14:14:59 <Korollary> xah: I didn't run ps here. It was just a recommendation.
14:15:03 <dons> hmmm twice as slow nmd?/
14:15:11 <dons> depends on the code though.
14:15:32 <ndm> that would be nice
14:15:54 <dons> I would use -O -funbox-strict-fields (but then, I'd use strict fields too)
14:16:15 <xah> korollary: that recommendation indicates you are used to bsd things.
14:16:18 <dons> and probably throw in some packed strings for good measure, ghc style ;)
14:16:20 <ndm> if that makes it go faster, feel free to submit a patch :)
14:16:25 <dons> ok. cool :)
14:16:27 <ndm> i think it does use packed strings already
14:16:40 * stepcut is working on compiling yhc for palmos...
14:16:51 <stepcut> the runtime part...
14:16:57 <ndm> probably a very old variant though - so if they are cross platform then that would be good
14:17:03 <dons> @where yhhc
14:17:03 <lambdabot> I know nothing about yhhc.
14:17:04 <ndm> stepcut, how goes the port?
14:17:07 <dons> @where yhhc
14:17:07 <lambdabot> I know nothing about yhhc.
14:17:08 <ndm> @where yhc
14:17:09 <lambdabot> www.cs.york.ac.uk/~ndm/yhc
14:17:23 <dons> i can't believe I mistyped it twice.
14:18:01 <dons> oh, I also have a mips64 . that might be fun to try
14:18:05 <stepcut> ndm: so-so, gmp does not work on PalmOS, there is no 64bit Int support, and palmos does not have fread/fwrite/fseek
14:18:12 <dons> how arch neutral do you think it is, ndm?
14:18:18 <ndm> dons, very
14:18:20 <Heffalump> stepcut: which arch?
14:18:29 <stepcut> Heffalump: m8k
14:18:33 <dons> ndm, ok. i'll have a porting festival!
14:18:34 <ndm> stepcut, you can remove gmp with a bit of effort
14:18:58 <ndm> read/write/seek are pretty required - you'd probably need to write a file interface to the records provided
14:19:32 <stepcut> ndm: yeah, removing the gmp and 64 bit stuff for now is pretty easy, the harder part is porting module.c to use palmos
14:19:33 <ndm> stepcut, what is 64bit int needed for?
14:19:37 * dons wonders about the mac68k-netbsd. does it bootstrap itself yet ndm?
14:19:49 <ndm> not yet on bootstrapping itself
14:19:53 <stepcut> ndm: no idea, the platfrom.h just defineds some Int64 stuff
14:19:56 <ndm> but within a few weeks
14:20:13 <ndm> hmm, from my knowledge, it doesn't use int64 - but i could be wrong
14:20:31 <stepcut> ndm: palmos has functions similar too, but not quite compatible fread/fwrite/fseek -- so it is not a huge change, but there is a bit of work
14:20:49 <stepcut> ndm: palmos also does not have a strdup function (which is only used 2 or 3 times..)
14:21:05 <ndm> strdup is an easy one to get round
14:21:17 <dons> ndm, ah, I see no $(HC_FLAGS). would that be a good var to add to the  makefiles?
14:21:25 <stepcut> ndm: so, basically, there is a bunch of little stuff -- the only big thing so far being the lack of unix FILE
14:21:27 <dons> e.g. for     ghc -cpp --make Main -o $(TARGET)
14:21:30 * stepcut goes to the store
14:21:36 <ndm> makefile? i don't use it
14:21:43 <ndm> if its a good idea to add, then add it!
14:21:56 <dons> oh, you just do the top level build thingy
14:22:04 <ndm> no, i just run windows
14:22:08 <ndm> no makefile at all
14:22:22 <dons> ok.
14:23:07 <dons> which tests should I run to check everything works?
14:23:10 <dons> test or testttts/
14:23:17 <dons> tests/
14:23:22 <ndm> tests don't all work
14:23:34 <ndm> so i'd just try compiling nqueens
14:23:52 <dons> ok. maybe you should import ghc-regress?
14:23:52 <ndm> i'm hoping to get all the tests working, and written in haskell, this week
14:24:05 <ndm> tests are fairly good tests
14:24:15 <dons> ok cool.
14:24:17 <ndm> its just not all of them pass, and the driver is in python (for now)
14:26:53 <dons> ok, first run took exactly 1:00.00 total
14:27:00 <dons> to bulid on openbsd/x86
14:27:03 <dons> without -O
14:27:28 <ndm> porting the runtime will be the only "hard" bit
14:30:20 <Igloo> Getting the fptools testsuite (plus any new bits you have) impl-independent and standalone would be really nice
14:30:23 <dons> ah, but it doesn't run inplace? what should YHC_BASE_PATH be set to?
14:30:35 <ndm> inst
14:30:46 <dons> Igloo, I already ripped out this so I could have nhc98 regress tests in the openbsd port
14:30:49 <ndm> and you probably want to set NHC_BASE_PATH
14:31:03 <ndm> i think the cmopiler and the runtime use different names :)
14:31:25 <Igloo> dons: I want something I can package separately and build-depend on and run while building any implementation
14:31:39 <dons> ftp://ftp.cse.unsw.edu.au/pub/users/dons/nhc/1.16/nhc98-1.16-regress.tar.bz2
14:31:42 <dons> iirc
14:31:59 <dons> Igloo, fair enough.
14:32:06 <ndm> Igloo, yhc's tests should be implementation independant
14:32:25 <ndm> and i now have a haskell driver (not yet committed) so in a few days it should be totallly done
14:33:01 <dons> Main.hbc!
14:33:10 <dons> oh, no 'hbc' as in HBC, I guess.
14:33:11 <ndm> haskell byte code?
14:33:19 <dons> not "Haskell-B Compiler"
14:33:24 <ndm> indeed not
14:33:39 <dons> pill00$ hbc -v
14:33:39 <dons> hbc Haskell98 version 0.9999.5c, 2004 Jun 29
14:33:59 <dons> ;)
14:34:07 <ndm> its pretty old now, so we figured we could reuse the acryonym
14:34:09 <Speck> are there any good examples of Ralf Hinze's and Johan Jeuring's web in Haskell? http://citeseer.ist.psu.edu/hinze01web.html
14:34:19 <ndm> we were going to do with nbc - nhc byte code
14:34:20 <dons> am i the only person who got confused so farR?
14:34:32 <ndm> but hopefully other compilers will support it
14:34:40 <ndm> not that many people remember hbc or have a copy :)
14:34:52 <dons> now, who do I run this .bc file?
14:34:54 <dons> how.
14:35:00 <ndm> build the runtime
14:35:03 <dons> ah.
14:35:05 <ndm> then yhi main
14:35:15 <dons> ok. cool.
14:35:57 <dons> requires GNU make, I see (?)
14:36:08 <ndm> i am not a makefile person :)
14:36:24 <ndm> if you can do whatever it does currently, without relying on GNU make, send a patch :)
14:36:42 <dons> bad. the makefile overridess LD_DFLAGS
14:36:43 <dons> patching..
14:38:25 <ndm> do you know where to send patches?
14:38:50 <dons> can I just darcs send?
14:38:57 <dons> or what's the addr?
14:39:08 <ndm> shackell -AT- cs.york.ac.uk
14:39:23 <ndm> i don't think he's put it in the repo
14:39:28 <ndm> i don't htink he's figured out hwo to :)
14:40:10 <dons> oh. an 'email' file in _darcs/prefs
14:40:18 <dons> ok. rts is built
14:41:20 <dons> oh this is nice: Warning: typeUnify horrible yucky string hack!!
14:41:26 <Korollary> lol
14:41:32 <ndm> yeah - thats not a warning about your code
14:41:40 <ndm> its a warning to remind Tom to fix that bit up
14:41:43 <dons> nice work guys. that was really easy to build :)
14:41:48 <ndm> cool :)
14:41:51 <dons> @karma+ yhc
14:41:51 <lambdabot> yhc's karma raised to 1.
14:42:04 <ski_> @type Control.Monad.Trans.lift :: Control.Monad.Trans.MonadTrans (->) => m a -> m -> a
14:42:04 <lambdabot>   Kind mis-match
14:42:04 <lambdabot>   Expected kind `(* -> *) -> * -> *', but `(->)' has kind `?? -> ? -> *'
14:42:12 <ski_> dons : does that suffice ?
14:42:22 <ndm> i want it to be as easy as "make" - so thats thats the goal
14:42:28 <dons> hehe: paprika$ ./yhi ../../Main.hbc
14:42:28 <dons> ERROR: 'NHC_BASE_PATH' is not set!
14:42:28 <dons> zsh: segmentation fault (core dumped)  ./yhi ../../Main.hbc
14:42:46 <ndm> yeah, set the NHC_BASE_PATH to the same as YHC
14:42:48 <dons> oh well. now I try to set NHC_BASE_PATH then
14:43:01 * SyntaxNinja thwaps ndm with a cabal
14:43:02 <ndm> we need to change them both ot the same thing
14:43:16 <ndm> SyntaxNinja: the code for some cabal is there :)
14:43:37 <dons> ndm, ah, that's a bit confusing:; ../../Main.hbc.hbc
14:43:45 <dons> it doesn't like the full file name?
14:43:53 <ndm> SyntaxNinja: http://www.cs.york.ac.uk/fp/darcs/yhc/src/compiler98/Package.hs - packageCabal
14:43:57 <ndm> dons, not today it doesn't
14:44:02 <ndm> take off the .hbc
14:44:19 <ndm> ironically - the compiler demands a qualified name, the runtime demands no extension
14:44:23 <dons> $ ./yhi ../../Main
14:44:23 <dons> Couldn't find 'queens' in module 'Main'
14:44:24 <dons> zsh: abort (core dumped)  ./yhi ../../Main
14:44:26 <ndm> we need to make them both happy with both :)
14:44:46 <dons> do I need to be in the queens dir?
14:44:53 <ndm> don't think so
14:44:58 <SyntaxNinja> ndm: can your compiler build the cabal code?
14:45:02 <ndm> that shouldn't happen
14:45:09 <ndm> SyntaxNinja: no idea - try it :)
14:45:21 <ndm> but i really really doubt it - it has no Directory support yet
14:45:37 <SyntaxNinja> that could be a slight issue ;)
14:45:38 <dons> ah ha!
14:45:43 <dons> it works!
14:45:47 <ndm> woot
14:45:48 <dons> my fault I think
14:45:56 <dons> ok, so add OpenBSD/x86 :)
14:45:58 <ndm> add the architecture to the ports list!
14:46:05 <Heffalump> is yhc intended to replace nhc, or be in addition to it?
14:46:22 <int-e> > Control.Monad.Trans.lift error error
14:46:22 <ndm> Heffalump - it will probably end up replacing it
14:46:22 <dons> ndm, oh, though I note it ran to completion then: zsh: segmentation fault (core dumped)  inst/bin/yhi Main
14:46:22 <lambdabot>  Not in scope: `Control.Monad.Trans.lift'
14:46:27 <int-e> :(
14:46:30 <ndm> although official polich is still unsure
14:46:43 <int-e> (that gives the kind error dons had in my ghci)
14:46:59 <dons> signal 11, Segmentation fault
14:47:04 <ndm> dons, it doesn't exit cleanly at the mo - it throws an interupt or something - that may be the cause
14:47:05 <dons> int-e, then try @type
14:47:12 <int-e> @type Control.Monad.Trans.lift error error
14:47:13 <lambdabot>   The function `Control.Monad.Trans.lift' is applied to two arguments,
14:47:13 <lambdabot>   but its type `m a -> t m a' has only one
14:47:28 <int-e> and I don't know why it says that. which ghci version is that?
14:47:37 <dons> 6.5
14:48:04 <int-e> (6.4.1 only says: Probable cause: `Control.Monad.Trans.lift' is applied to too many arguments in the call)
14:48:16 <int-e> after giving that kind error.
14:49:09 <dons> int-e, ah, @type might be chopping off the output
14:49:30 <dons> nope, 6.5 just doesn't give the kind error.
14:49:42 <int-e> funny.
14:49:44 <dons>     Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
14:49:44 <dons>     When matching the kinds of `t :: (* -> *) -> * -> *' and `(->) :: ?? -> ? -> *'
14:49:48 <dons> 6.4.1
14:49:49 <dons> Well done
14:49:54 <dons> @karma+ int-e
14:49:54 <lambdabot> int-e's karma raised to 4.
14:50:15 <dons> (I was using 6.4.1 when I got the error as well)
14:50:55 <ndm> going for food now - good luck with yhc on other archs - thanks for your effort!
14:51:07 <dons> no worries. now to send in my patches
14:51:34 <ndm> i plan a lot of janitorial work next week, which will hopefully make it easier to build in future
14:51:42 <ndm> and a more consistent user interface between them
14:51:47 <SyntaxNinja> isn't there a 'cvs move'?
14:51:54 <ndm> SyntaxNinja: hehe
14:51:55 <SyntaxNinja> am I supposed to delete and re-add a file?
14:51:55 <Igloo> No
14:51:59 <ndm> yes
14:52:11 <ndm> separately, since there are no atomic commits either
14:52:13 <SyntaxNinja> how easy it is to forget how badly cvs sucks.
14:52:21 <dons> hehe
14:53:39 <Korollary> cvs is horrible
14:54:53 <int-e> @kind (->)
14:54:54 <lambdabot> ?? -> ? -> *
14:54:57 * Korollary schedules cvs for uninstallation. Korollary commits.
14:55:04 <int-e> that was the tough part of it, actually.
14:55:48 <dons> anyone want to try hmp3, and comment on the ui, or anything else? darcs get http://www.cse.unsw.edu.au/~dons/code/hmp3
14:56:54 <dons> screenshot: http://www.cse.unsw.edu.au/~dons/hmp3.png
14:57:41 <int-e> there's another funny message from the type checker: "Urk! Inventing strangely-kinded void TyCon:" "ZCt{tc a1DU}" "(* -> *) -> * -> *" -- I like the "Urk!" part of it :)
14:57:56 <Igloo> What mp3 library does it use?
14:58:06 <Korollary> Urk!
14:58:10 <dons> it uses an external decoder. currently mpg321 or mpg123
14:58:21 <dons> running over some posix pipes
14:58:27 <Igloo> Ah, right
14:58:30 <dons> a library binding would be nice though.
14:58:38 * Igloo has one for gstreamer
14:58:48 <dons> mmm!
14:59:05 * dons add this to the todo list. 
14:59:14 <dons> url Igloo?
14:59:28 <Igloo> But the GUI code needs reworking(read: rewriting) when I have some time. I lost some incentive when it started working though  :-)
14:59:38 <dons> hehe
14:59:46 <Korollary> the curse of the consumer programmer
14:59:52 <dons> what kind of ui? gtk?
14:59:58 <wilx> Well, I won't compile on Windows :/
15:00:20 <dons> wilx, right. you have your media players.
15:00:24 <wilx> :)
15:00:26 <Igloo> http://urchin.earth.li/~ian/minstrel/ (I'm not sure if the code currently there builds or works; haven't touched it in ages. Hopefully it will, though)
15:00:35 <wilx> So do you...
15:00:41 <Korollary> does anyone cabalize anything ?
15:00:45 <Igloo> It has a curses GUI, but it's a mess
15:00:45 <dons> I couldn't get reliable pipes with Process , so had to try Posix instead
15:01:12 <Korollary> dons: my Process pipes broke intermittently as well.
15:01:12 <dons> I think curses guis are getting easier. stefanw and I have a secret plan..
15:01:19 <wilx> Bah, somebody should port and package GHC for Cygwin.
15:01:21 <dons> for a Text.PrettyPrint.Curses
15:01:28 <wilx> Then it would be usable.
15:01:29 <Korollary> wilx: I tried, but failed.
15:01:31 <Igloo> I should split it into something that uses commands to manipulate a tree and a UI on top of that to show the visible bit of tree
15:01:43 <dons> yes, Igloo!
15:01:46 <wilx> Korollary, try harder! :)
15:01:52 <wilx> What went wrong?
15:02:10 <dons> ncurses should be considered super evil gunk that is isolated to its own contained box
15:02:39 <Igloo> The UI design itself needs tweaking, too. I think I should just have a generic tree rather than fixed artist/album/track hierarchy
15:03:06 <dons> that's an interesting idea. hmm.
15:03:16 <Igloo> The other reason I got discouraged was trying to think through exactly how it should cope with half-equal tracks, e.g. 2 versions of the same song by the same artist, or by different artists
15:03:22 <dons> hmp3 is just a flat list atm. maybe i could steal some tree code
15:03:26 <Korollary> wilx: cygwin doesn't have full posix, so somethings failed. I didn't fully understand the build system either. I know it was done before, but it was just taking so long to compile. I quit.
15:03:44 <wilx> I see.
15:05:29 <eivuokko> ghc used to compile in cygwin with fairly little poking, I think.
15:05:39 <dons> Igloo, did you announce minstrel?
15:05:55 <Igloo> Only here
15:06:01 <Igloo> Why?
15:06:14 <dons> 'cause I didn't know about it :/
15:06:26 <Korollary> eivuokko: Yes, it looked like it didn't need much, but I didn't know what exactly.
15:06:55 <wilx> eivuokko, really? I haven't ever seen it.
15:07:15 <Korollary> wilx: there used to be a cygwin binary for an earlier version or two.
15:07:22 <wilx> Ah.
15:07:38 <dons> looks like it does hmp3, but has tree listing which I don't have yet.
15:08:08 <eivuokko> wilx, yes, you only needed to get ghc to use cygwin gcc basically, but it used to require activestate perl instead of cygwin perl for some wierd reason, which kind of made it annoying.
15:08:28 <dons> Igloo, 'not robust'? how so?
15:09:09 <wilx> Ah.
15:09:10 <wilx> Hm.
15:09:16 <wilx> I wonder if it would work now.
15:09:18 <eivuokko> wilx, But I haven't tried that for a long time.  I don't use cygwin anymore.
15:09:23 * dons tempts fate and tries to build yhc on mips64
15:11:08 <dons> mmmm! looking good so far.
15:11:18 <Igloo> dons: You can probably ignore that. I've been using it daily for over a year, so it can't be that bad.
15:11:46 <ndm> sounds tempting :)
15:12:11 <dons> ndm, is the ports page on the wiki?
15:12:12 <Igloo> The library bindings are incomplete, but I can't think why they'd be broken
15:12:29 <ndm> dons, give me one sec - its under Todo, I'll move it then let you know where it is
15:12:34 <SyntaxNinja> hm. is there an easy way to disallow an account from logging in without changing the password?
15:12:41 <SyntaxNinja> (in linux)
15:12:57 <dons> Igloo, what's this hcurses? another curses binding?
15:13:14 <eivuokko> SyntaxNinja, does that exclude using passwd -l (lock) as well?
15:13:20 <dons> we need a glorious grand unified curses binding.
15:13:22 <Igloo> Yes
15:13:24 <Igloo> And yes
15:13:37 <dons> maybe if stefan and I can get  this curses Ppr working.
15:13:40 <ndm> @wiki Yhc/Ports
15:13:41 <lambdabot> http://www.haskell.org/hawiki/Yhc/Ports
15:13:59 <dons> cheers ndm
15:17:21 <dons> Igloo, could the play pool fields be populated by reading the .ogg files for id tags?
15:17:24 <dons> or dooesn't .ogg work like that
15:17:55 <Igloo> play pool fields?
15:18:12 <dons> your play pool file contains lines of : The Foo Band/Bar Album/The First Track.ogg
15:18:16 <dons> ?
15:18:25 <Igloo> Right
15:18:41 <dons> could you not just supply the directory of tracks, and read the ogg files to find the album,artist.. fields?
15:18:45 <Igloo> You want the text in the UI to be the id-tag equivalent instead?
15:19:03 <Igloo> I'm confused
15:19:06 <dons> I'm wondering if the play pool could be done away with
15:19:13 <Igloo> Ah
15:19:21 <dons> and instead automagically constructed from just the directory arg
15:19:21 <Igloo> The playpool is a file that contains a list of filenames
15:19:26 <SyntaxNinja> eivuokko: password lock sounds good. hmm
15:19:42 <Igloo> You could instead have it take a directory and have it do essentially "find ." itself
15:19:51 <dons> right.
15:20:12 <Igloo> You could also have it display the album etc info from teh file instead of the filename, but that's separate
15:20:29 <dons> yes. 
15:20:39 <dons> or optionnally do either
15:20:40 <Igloo> Oh, not entirely separate. If you wanted to do that you'd have to make the tree yourself too
15:20:45 <dons> since some files don't have tags in the file
15:21:26 <Igloo> Hmm, I should update that screenshot with one now my filenames don't needlessly repeat the artist
15:22:07 <dons> oh, you've got the world's smallest haskell curses binding!
15:22:13 <dons> @karma+ Igloo
15:22:13 <lambdabot> Igloo's karma raised to 3.
15:22:19 <SyntaxNinja> eivuokko: perfect :)
15:22:28 <dons> paprika$ wc -l Curses.hsc
15:22:28 <dons>      272 Curses.hsc
15:22:28 <dons> paprika$ wc -l ~/hmp3/Curses.hsc
15:22:28 <dons>     1716 /home/dons/hmp3/Curses.hsc
15:22:53 <Igloo> Unfortunately it needs TH, although I might have hacked it to be able to produce a .hs(c?) file for arches that don't have it
15:23:15 <dons> is the code gpl?
15:23:45 <dons> (i.e. can I encorporate any tasty bits into hmp3?)
15:24:09 <beelsebob_> @where hash
15:24:09 <lambdabot> I know nothing about hash.
15:24:11 <Igloo> If GPL is OK with you then it's OK with me  :-)
15:24:12 <beelsebob_> ~(
15:24:14 <beelsebob_> :(
15:24:19 <dons> @where h4sh
15:24:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
15:24:20 <dons> ?
15:24:24 <dons> Igloo, cool.
15:24:27 <beelsebob_> :)
15:26:08 <ndm> beelsebob_: we have a few more ports of yhc already
15:26:15 <beelsebob_> excellent :)
15:26:18 <beelsebob_> what platforms?
15:26:29 <ndm> @wiki Yhc/Ports
15:26:29 <lambdabot> http://www.haskell.org/hawiki/Yhc/Ports
15:26:42 <dons> half way through the mips64 build now..
15:26:42 <beelsebob_> excellent :)
15:26:45 <ndm> OpenBSD/x86
15:26:55 <beelsebob_> I'll port it to iPod when they boot linux on the 5th gen ones
15:26:58 <beelsebob_> *g*
15:27:24 <dons> this YHC_BAse_PATH thingy bit me again :/
15:27:25 <dons> grr.
15:27:29 <ndm> we'll fix that
15:27:30 <beelsebob_> haha
15:27:38 <ndm> once we get the package architecture sorted
15:27:42 <beelsebob_> yeh, once the inst dir is sorted
15:27:56 <ndm> we can then have a sensible default, and only a small number of users will want to override it
15:28:08 <beelsebob_> indeed
15:28:19 * beelsebob_ has just poluted his /usr dirs
15:28:30 <beelsebob_> but it does need sorted
15:28:41 <ndm> i thought Mac went with Users and Applications directories?
15:28:55 <dons> ok, mips64/irix is now into the libraries. fingers crossed.
15:29:25 <beelsebob_> :)
15:29:32 <dons> interesting: Stack space overflow: current size 1048576 bytes.
15:29:32 <dons> Use `+RTS -Ksize' to increase it.
15:29:34 <dons> gmake[1]: *** [Prelude.hi] Error 2
15:29:35 <beelsebob_> ndm: not for that kind of stuff
15:30:09 <beelsebob_> rather than command line tools
15:30:15 <beelsebob_> bah
15:30:28 <beelsebob_>  /Applications is for propper OS X apps, not cmd line tools
15:31:16 <ndm> dons, do you have to make the libraries for yhc?
15:31:28 <ndm> i thought .hbc files were already checked into the darcs repo
15:31:36 <beelsebob_> ndm: I don't think so
15:31:40 <ndm> which you can use directly - since they are cross platform
15:31:42 <dons> oh, I just typed 'make'
15:31:48 <beelsebob_> and it would be a bad thing even if they were
15:31:55 <beelsebob_> the source should be there... so you can edit it
15:31:56 <ndm> yeah, no need to build the libraries
15:31:57 <dons> but still, it's a good test of the system.
15:32:09 <ndm> beelsebob_: they are checked in, am pretty sure
15:32:14 <beelsebob_> hmm... silly
15:32:19 <ndm> the libraries will change massively within the next week or so
15:32:26 <ndm> maybe 2 weeks
15:32:28 <beelsebob_> :)
15:32:40 <dons> ok, so I needed -K20M  (arbitrary value)) to compile Prelude.hs on the mips64
15:32:53 <dons> but compiling yhc  with -O might help possibly
15:33:08 <beelsebob_> ... or compiling it with yhc *g*
15:33:09 * Igloo wonders if apache can be told there are no default index files inside any _darcs/ URL
15:33:11 <ndm> ok, but thats ghc's fault a bit
15:33:20 <ndm> yhc will automatically share memory between stack and heap
15:33:30 <ndm> and increase if needed, so no runtime arbitrary values
15:33:37 <ndm> (it will, it doesn't do all of that yet)
15:39:47 <dons> hmm. what's this cpphs binary that comes with yhc?
15:39:59 <dons> ELF 32-bit LSB 80386
15:40:01 <dons> ???
15:40:04 <beelsebob_> it's fucing stupid is what it is
15:40:08 <beelsebob_> it should be part of yhc
15:40:19 <beelsebob_> it doesn't work on OS X either surprisingly
15:40:29 <dons> it only worked on my openbsd box cause I have linux emulation (transparently)
15:40:37 <dons> but died on irix, unsurprisingly
15:41:13 <dons> should I replace it with a ln -s to cpp ?
15:42:00 <beelsebob_> it'll not deal with comments right
15:42:10 <dons> you have string gap comments?
15:42:17 <beelsebob_> ?
15:42:29 <dons> it'll handle almost all comments, except tricksy ones, won't it?
15:42:33 <beelsebob_> {-
15:42:33 <beelsebob_> #define JAM 5
15:42:33 <beelsebob_> -}
15:45:17 <dons> oops. you can get surprisingly far into the build without running configure :S
15:46:18 <xah> in this code: "product . enumFromTo 1" is it application one one function to a list?
15:46:37 <dons> @type enumFromTo 1
15:46:37 <lambdabot> forall a. (Enum a, Num a) => a -> [a]
15:46:48 <dons> @type product . (enumFromTo 1)
15:46:49 <lambdabot> forall a. (Enum a, Num a) => a -> a
15:48:41 <dons> ah, now we're taalking: checking size of long... 8
15:49:08 <Frederick> yo, SamB
15:51:40 <dons> hm. that looks like a 64 bit type error in the rts:
15:51:41 <dons> IntegerNode* decodeFloat64(Float64 f, Int32* exp);
15:51:46 <dons> IntegerNode* decodeFloat64(Double f, Int* rExp){
15:52:02 <dons> at least gcc says so.
15:52:07 <dons> beelsebob_, ndm: ?
15:52:23 <ndm> back - just reading the notes...
15:52:54 <dons> in integer.c
15:53:16 <ndm> with reference to cpphs, its going to be put into yhc as source
15:53:34 <ndm> so yhc will automatically have cpp support, without external binaries
15:53:40 <dons> replacing it with a ln -s to cpp seems to have worked so far, anyway.
15:53:40 <ski_> "Now I feel less geeky for trying to define which algorithm I'm using to clean up my house. Lately I'm using a generational, mark and compact, GC but I'm trying to use regions"
15:54:04 <ndm> dons, I don't have any idea on the 64 bit error
15:54:23 <dons> ok, I think it's just a typo. someone forgot to update the prototype
15:54:30 <ndm> woops
15:54:33 <dons> yep. works now
15:54:48 <dons> I guess it doesn''t get run in the 32 bit code?
15:55:01 <dons> does linux amd64 use 64 bits?
15:55:02 <ndm> unsure - i don't know much of the details
15:55:07 <ndm> it does indeed
15:55:48 <ndm> but its a second class port - it may not have been built recently on that
16:02:08 <dons> ok, rts built!
16:02:24 <dons> 2 wibbles only onn a weird box like a mips64/irix :)
16:03:20 <dons> doh: $ inst/bin/yhi Main
16:03:21 <dons> zsh: bus error (core dumped)  inst/bin/yhi Main
16:03:56 <dons> it compiled ok though.
16:04:22 <ndm> and those two wibbles are one offs that will be fixed in future, so thats ok
16:04:37 <dons> there were a few builtin/Prelude.c:236: warning: passing arg 2 of `decodeFloat64' from incompatible pointer type
16:04:40 <ndm> and it seems the runtime likes to core dump to exit
16:04:40 <dons> style msgs
16:04:58 <ndm> there are currently 3 warning messages building with windows
16:05:02 <ndm> must track them down as well
16:05:16 <dons> ah, manye more than that on the 64 bit box
16:05:30 <dons> builtin/Int.c:32: warning: comparison is always false due to limited range of data type
16:05:44 <ndm> last time amd64 was compiled on, it gave no warnings i think
16:06:02 <dons> maybe 40 or so errors of that style. all to do with 64 bit widths
16:06:16 <dons> mutator.c: In function `trace':
16:06:16 <dons> mutator.c:695: warning: long long int format, Long arg (arg 3)
16:06:28 <dons> do you want a log, perhaps?
16:07:02 <ndm> that would be good
16:07:15 <ndm> send it to me - ndmitchell -AT- gmail.com
16:07:28 <dons> ok.
16:07:37 <ndm> we really need a yhc mailing list
16:09:36 <ndm> got them, thanks
16:10:54 <araujo> hi hi shapr
16:11:09 <araujo> How can i load two modules at once in ghci?
16:11:31 <dons> :m +
16:11:34 <basti_> :m +<module2>
16:11:56 <dons> araujo! want to try hmp3: http://www.cse.unsw.edu.au/~dons/hmp3.png
16:12:00 <araujo> Thanks dons , basti_
16:12:03 <dons> since it was your code that started all this
16:12:12 <araujo> Really?!, Let's see :-]
16:12:27 <dons> darcs get http://www.cse.unsw.edu.au/~dons/code/hmp3
16:12:31 <dons> needs mpg321
16:12:36 <araujo> WOW
16:12:39 <araujo> Cool dons !
16:12:49 * araujo pulls it out
16:13:02 <ndm> i guess hmp3 doesn't work on windows?
16:13:21 <araujo> dons, Did you finally use some of my code?
16:13:31 <dons> ndm, yeah :/ needs posix pipes
16:13:52 <dons> araujo, I read your code, then started from scratch using yi code
16:14:04 * araujo happy
16:14:37 <dons> ndm, so if there was a way to do bidirectional pipes on windows, thhat could be used instead. then it would work
16:14:53 <dons> oh, and you'd need ncurses.h
16:14:57 <araujo> dons, That was precisely what i had in mind to do....
16:14:58 <ndm> not sure
16:15:06 <ndm> windows has no ncurses
16:15:09 <araujo> I just didn't go any further :-(
16:15:40 <araujo> I am happy to see that somebody else caught up on this though :-)
16:15:49 <dons> :)
16:19:42 <araujo> dons, right now i am having fun with this tiny shelly
16:21:19 <araujo> shell are usually designed from a program to language pÃ©rspective, why not to do it in the other way around? :-]
16:26:18 <zacch> hi, in typed lambda calculus, how is the degree of a term defined?
16:30:10 <zacch> is it the sum of the redexes it contains?
16:34:53 <Heffalump> I don't think there's one universally used definition.
16:36:16 <zacch> OK - I'm trying to understand weak normalization, and reading the book of Girard, "Proofs and Types"
16:36:19 <zacch> he says:
16:36:51 <zacch> (page 25) "the degree d(t) of a term is the sup of the degrees of the redexes it contains"
16:36:58 <zacch> but I suspect that's an unfortunate typo
16:37:42 <zacch> because if it's actually the sup(remum) (which doesn't make sense for finite discrete things anyways), it would always equal the degree of the term as a redex, wouldn't it?
16:42:31 <Heffalump> why does the sup not make sense for finite discrete things?
16:42:39 <Heffalump> it's just the maximum then
16:42:59 <zacch> yes exactly, so it seems odd to say "sup" when there's no need for more generality
16:43:28 <zacch> especially as "sup" would be rather odd anyways - why not spelt out as "supremum" then?
16:43:37 <Heffalump> true
16:43:52 * Heffalump is now not sure whether 'degree' and 'order' are the same thing.
16:44:13 <Heffalump> so my original comment about there being multiple definitions may not be true, because I was thinking of 'order' when I said that
16:44:19 <zacch> anyway's, he gives an important inequality, stating that the degree of the redex (as a redex) is less than or equal its degree as a term
16:45:10 <zacch> and I assume the "less than" part can happen (otherwise, why not state equality), and if it were the sup, it couldn't (take the term itself)
16:46:04 <Heffalump> sorry, I think I'm now confused enough that I can't be of any help
16:46:15 <zacch> no problem, where is shapr ?
16:46:17 <Heffalump> this isn't really a lambda calculus channel anyway :-)
16:46:32 <Heffalump> no idea. He's been mostly avoiding IRC lately to study and work, I think.
16:46:35 <zacch> shapr said you could answer that, as a group, sorry if I'm wrong
16:47:05 <zacch> (in the wrong channel, that is) - I thought you wouldn't mind about a theory question
16:47:20 <Korollary> this is probably the channel with most people knowledgable about LC, perhaps
16:47:24 <Heffalump> I'm sure there are some people who could answer it, yeah. I don't mind particularly, certainly.
16:48:02 <Heffalump> I wouldn't want theory conversation to end up drowning out the Haskell conversation - but it's nowhere doing that at the moment, so I don't see a problem.
16:48:23 <Korollary> palomer would be the guy to ask about LC I think
16:49:04 <zacch> thank you, where is he?
16:49:27 <Korollary> @seen palomer
16:49:28 <lambdabot> I haven't seen palomer.
16:49:54 <zacch> @search palomer
16:49:55 <lambdabot> Unknown command, try @listcommands.
16:50:07 <Korollary> @summon evil
16:50:07 <lambdabot> Unknown command, try @listcommands.
16:50:25 <Oejet> Good night all!
16:53:50 <Frederick> @localtime SamB
16:54:01 <lambdabot> Local time for SamB is Sun Nov 13 19:53:50
17:00:53 <Frederick> @localtime Cale
17:00:54 <lambdabot> Local time for Cale is Sun Nov 13 19:59:49
17:04:32 <int-e> zacch: the 'less than' part can happen. consider, say, \x -> fst (x,(x,x))  [ i.e.  \lambda x. \pi^1 (x,(x,x)) ] - as a redex, that has degree 2, but it contains a redex of degree 3, so as a term it has degree 3.
17:05:08 * SamB hides under a rock
17:05:31 * Frederick lifts the rock
17:05:33 <int-e> zacch: err, missing an outer application. I mean (\x -> fst (x,(x,x))) x where the outer x is of some atomic type T
17:08:54 * SamB is called AFK again already anyway
17:15:37 <dons> hey SamB
17:23:26 <zacch> int-e: you're right, thank you! so "sup" is here indeed correct, and it amounts to the maximum?
17:25:59 <zacch> int-e: and the outer application was necessary to make the whole thing actually a redex at its root, wasn't it?
17:28:01 <int-e> zacch: right
17:28:06 <wilx> Hmpf.
17:28:22 <wilx> GHC build on Cygwin dies on missing Apply.o.
17:28:36 <dons> no .hc file?
17:28:46 <wilx> Only Apply.cmm.
17:29:01 <wilx> ghc/rts/Apply.cmm
17:29:28 <dons> hmm. not sure if that is ok.
17:29:55 <Korollary> iirc you're supposed to bootstrap from hc files built on linux
17:31:06 <wilx> Hm.
17:34:32 <SyntaxNinja> kosmikus: alive?
17:34:34 <SyntaxNinja> @seen kosmikus
17:34:34 <lambdabot> kosmikus is in #gentoo-haskell and #haskell. I don't know when kosmikus
17:34:34 <lambdabot> last spoke.
17:46:28 <sh10151> what do people use as a haskell editor?
17:47:03 <gzl> many people use emacs
17:47:22 <wilx> Right.
17:47:26 <dons> vim too
17:47:36 <gzl> yeah, vim. or maybe yi now too?
17:47:37 <Korollary> nobody uses yi, tho
17:47:43 <gzl> no?
17:47:51 * Korollary is messing with dons
17:47:53 <dons> some people use yi, but not for editing haskell full time, I think.
17:47:53 <gzl> aha.
17:48:07 <dons> SamB, some tasty hmp3 patches for you
17:50:34 <sh10151> no one uses that eclipsefp yet?
17:50:35 <sh10151> :)
17:50:42 <gzl> what's that?
17:53:19 <dons> @index setEnv
17:53:19 <lambdabot> System.Posix.Env, System.Posix
17:53:39 <sh10151> plugin for eclipse
17:53:44 <sh10151> i think it does ocaml and haskell
17:55:42 <gzl> cool.
17:55:56 <gzl> I used Eclipse for Java for a while. it does lots of nice stuff.
17:56:38 <gzl> the refactoring tools in particular
17:58:36 <SamB> dons: oh, cool. but its family story time right now, so I can't test them for a bit
18:00:02 <dons> hehe ok :)
18:00:03 <SamB> well, exept I don't seem to have a keymap module
18:00:07 <dons> ah!
18:00:33 <ndm> sh10151: I use TextPad, its the best choice on windows
18:00:57 <dons> SamB, done.
18:03:11 <SamB> @localtime musasabi
18:03:13 <lambdabot> Local time for musasabi is Mon Nov 14 04:02:50 2005
18:04:20 * SamB gets:
18:04:22 <SamB> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
18:04:23 <SamB>         expectJust upsweep_mod:old_linkable
18:04:30 * SamB cleans, builds again
18:04:33 <dons> yes.
18:04:41 <dons> means the module space got weird
18:05:21 <dons> since we last talked you get a help screen, performance should be better, and there's a slightly different song selection mechanism.
18:05:33 <dons> scroll with arrows, and press return or space to actually start playing
18:05:43 <dons> seems to be the standard way to do things
18:06:12 <SamB> also sounds more like what you described in the comments
18:06:37 <SamB> only how will I pause if space starts it now?
18:06:43 <dons> 'p'
18:06:51 <dons> try 'h' to read the help :)
18:06:55 <SamB> its not that strange for space to pause
18:07:06 <dons> ah, ok.
18:07:13 <int-e> hmm, maybe space could pause if you're still on the same song?
18:07:15 <SamB> hasn't finished building yet
18:07:20 <dons> maybe space could toggle play pause.
18:07:20 <int-e> and that song is playing ...
18:07:23 <SamB> int-e: too complicated
18:07:31 <int-e> SamB: could be.
18:07:49 <dons> I think pause is fairly rare (?)
18:08:54 <dons> so almost all features done now.
18:09:08 <dons> just need the tree branching layout, and the dir argument parsing
18:09:26 <SamB> hmm, the impossible is still happening
18:09:34 <dons> hmm. i'll try here
18:10:41 <dons> you did: ./Setuphs clean ; ./Setup.hs configure ; ./Setup.hs build
18:10:55 <dons> ah, i've added recursive modules. maybe 6.4 doesn't like them?
18:11:02 <dons> i'm using 6.4.1
18:17:58 <dons> yep, looks like 6.4 bug
18:18:06 <dons> at the linking phase: ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
18:18:09 <dons>         expectJust upsweep_mod:old_linkable
18:18:14 <dons> doesn't happen with 6.4.1
18:18:39 <Frederick> guys how do I call a structure ive defined like in http://rafb.net/paste/results/UhRiGh31.html I want to say that rule is a nonterminal followed by a production seby ->
18:18:51 <SamB> how annoying
18:19:17 <dons> :/
18:19:32 <SamB> but that isn't exactly evidence supporting the conclusion that the problem has to do with mutual recursion
18:19:47 <SamB> I mean, I can build GHC!
18:19:56 <dons> well, that's the only weird thing I added.
18:20:05 <dons> ah, but it uses a different build system.
18:20:14 <dons> it doesn't use --make, which is where all the upsweep stuff happens.
18:20:17 <SamB> true
18:20:25 <SamB> oh
18:20:31 <dons> you could probably link by hand without --make, once all the objs are built
18:20:42 <dons> let's see.
18:21:06 <dons> ./Setup.lhs build -v4 gives you the command line
18:22:21 <dons> hmm. doesn't seem to compile Keymap.hs
18:22:26 <SamB> however, the commandline doesn't have more than Main.hs
18:23:02 <dons> yeah, I was thinking more like: cd dist/build/hmp3/tmp-hmp3 ; ghc-6.4 -o hmp3 *.o cbits/utils.o -lncurses -package fps
18:23:03 <SamB> dons: did you forget to import it the normal way?
18:23:15 <dons> however, the Keymap.o isn't built.
18:23:15 <SamB> there was a note in one of GHCs source files saying "don't remove this import" for an import that imported precisely nothing
18:23:42 <dons> hmm. also recall the .hs-boot stuff changed with 6.4, and there were bugs
18:24:30 <SamB> naesten@hydrogen:~/hacking/haskell/hmp3% grep 'import .*Keymap' *
18:24:30 <SamB> Config.hs:import {-# SOURCE #-} qualified Keymap as Default
18:24:30 <SamB> UI.hs:import {-# SOURCE #-} Keymap
18:24:30 <SamB> naesten@hydrogen:~/hacking/haskell/hmp3%
18:24:33 <SamB> you need to import once without {-# SOURCE #-}
18:24:56 <dons> oh, really?
18:25:15 <dons> that sounds like the kind of bug that was fixed with 6.4.1
18:25:17 <dons> but let's see..
18:25:45 <SamB> but it doesn't sound like a terrible price to pay
18:26:09 <dons> no, if it works. let's see.
18:26:28 <SamB> well, yeah. there is that.
18:26:40 <dons> * dons spins the src and looks for a place to do a silly import
18:27:11 <SamB> well, there is always main.
18:27:30 <SamB> if you import nothing, it probably won't cause much trouble!
18:28:27 <dons> hmm! it works!
18:28:33 <dons> @karma+ SamB
18:28:33 <lambdabot> SamB's karma raised to 3.
18:28:43 <SamB> cool
18:31:04 <dons> ok, try that patch
18:31:57 * SamB tries to pull, but it isn't going very quickly
18:32:41 <dons> you using a modern darcs?
18:33:55 <dons> i updated to darcs 1.0.4 stable today, and sometimes updating does weird things to repos.
18:34:20 <dons> however I can darcs get perfectly well (and pull)
18:39:08 <SamB> dons: actually, its just that ppp0 is fully saturated.
18:39:13 <SamB> I think.
18:39:17 <SamB> I mean, it is.
18:40:11 <dons> hehe, ok.
18:40:45 <SamB> the part I'm not sure about is whether that is the entire problem or not...
18:50:29 <SamB> okau, I've got some bandwidth now ;-)
18:51:07 <ndm> WinHugs now supports ANSI escape codes :)
18:51:24 <dons> cool.
18:51:35 <ndm> and now i sleep...
18:55:16 * heatsink writes haskell code in Python
18:55:40 <SamB> that help screen has bad contrast with white on black terminals
18:55:50 <SamB> or mine, anyways
18:56:07 <SamB> and I'm pretty sure its just the default xterm color scheme
18:56:37 <Cale> heatsink: in which sense?
18:56:42 <dons> hmm. white on black isn't the default, is it?
18:56:57 <SamB> are you sure?
18:57:07 <SamB> maybe you are right...
18:57:09 <dons> SamB, maybe you'd like to write a darkScreen style setting in Config.hs ?
18:57:40 <dons> since the style there assumes the background is light, i'm fairly certain
18:57:50 <heatsink> Cale: Using haskell idioms
18:57:54 <SamB> is there a reason why the next song to play is the one after the one highlighted in that wierd light blue/green color?
18:58:11 <Cale> heatsink: ah, I thought perhaps you were doing some metaprogramming :)
18:58:41 <dons> the blue one is the currently playing song
18:58:50 <dons> so the next one is the one after that.
18:58:55 <Cale> heh
18:58:59 <dons> unless you move the cursor (the cyan bar) and hit return.
18:58:59 <SamB> it doesn't seem to be so
18:59:07 <heatsink> Cale: does code intended to aid in generating Python bytecode count as metaprogramming?
18:59:10 <dons> there was an off-by-one bug. maybe i didn't push it.
18:59:21 <SamB> because if I move the cyan bar, it seems to play the one after that next if I just leave it ther
18:59:43 <Cale> heatsink: :)
18:59:45 <SamB> I got an off-by-one-bug patch
19:00:01 <SamB> heatsink: thats called a compiler, I think
19:00:07 <SamB> or a macro-hack
19:00:18 <SamB> depends
19:00:21 <dons> SamB, can you describe the problem in terms of what keys you type so I can see what you mean?
19:00:53 <Cale> I suppose writing a compiler is a delayed form of metaprogramming :)
19:01:12 <SamB> If I hit the down arrow a couple of times, and then wait for the blue song to end, it seems to play the song below the cyan bar
19:01:26 <dons> ah, ok.  haven't checked that.
19:01:58 <dons> yep, got it. a bug! thanks :)
19:02:10 <dons> easy to fix.
19:02:48 <SamB> yeah, I figured
19:03:26 <dons> I changed the semantics of the 'down' primitive.
19:04:21 <SamB> so this is basicly Yi, only it plays MP3s and has more complicated rendering?
19:04:41 <heatsink> oh my gosh, yi is becoming like emacs
19:05:00 <dons> SamB, um. sort of ;)
19:05:00 <SamB> heatsink: only not all in one executable, and the code isn't in elisp
19:05:21 <dons> simpler build system too, for hmp3
19:05:37 <dons> but heh, if the code works, reuse! right?
19:05:46 <heatsink> right.
19:05:51 <SamB> yeah, I guess so.
19:06:47 <SamB> so how do I take Yi and turn it into a ZMachine "terminal"?
19:07:07 <dons> a ZMachine?
19:07:14 <SamB> Z-Machine, rather
19:07:42 <SamB> I've written most of a Z-machine interpreter in Haskell.
19:07:57 <SamB> however, the IO implementation is horrible.
19:08:52 <SamB> It doesn't allow for proper drawing of the statusbar, looks really nasty, and you can't really do any sort of line-editing of your input
19:09:23 <SamB> the Z-machine, of course, being the machine that Infocom's Zork runs on
19:10:07 <dons> ah, ok :)
19:10:38 <SamB> along with a bunch of games written in Inform by hobbyists
19:13:15 <SamB> actually, my implementation can't even run the Zork story files I have, because they are V3 and I've only got V5 so far
19:13:29 <heatsink> You're on version 5?
19:13:32 <heatsink> ??
19:13:57 <SamB> heatsink: of the story file format, yeah
19:14:36 <dons> SamB, ok fixed that I think
19:14:50 <SamB> If I ever get a real I/O implementation in there, I'd like to implement V8 and then maybe V3
19:15:08 <SamB> (V8 is almost identical to V5, but V3 is more different)
19:15:36 <heatsink> maybe I'll port my partially-implemented curses-based web browser to yi if ever I feel the desire for it.
19:16:30 <heatsink> So they're not backward compatible i take it.
19:16:45 <SamB> not exactly.
19:16:59 <SamB> I mean, the first byte of each file says which version it is
19:18:07 <SamB> but they changed the meaning of fair number of the opcodes, and changed a few other significant things
19:18:21 <SamB> it will be tricky to support V3.
19:18:45 <SamB> V8 really just has one difference
19:19:12 <bojohan> you're trying to compete with emacs?
19:19:15 <heatsink> while v6 has just one-third of a difference.
19:19:32 <SamB> v6 is totally different, actually
19:19:41 <SamB> they aren't in a linear order
19:19:50 <heatsink> oh, okay.
19:20:02 <SamB> v7 and v8 were done by "fans"
19:20:08 <SamB> v7 was ill-fated
19:20:24 <SamB> v8 is only used for larger games
19:20:32 <heatsink> Ah, interesting.
19:21:18 <SamB> the only difference between v5 and v8 is that in v8, instead of multiplying packed addresses by 4 you multiply them by 8
19:22:02 <SamB> v6 has graphics and stuff, though
19:22:14 <SamB> and its really rather tricky
19:23:19 <SamB> I suppose it is possible to do a plaintext implementation, but it wouldn't really be very much fun considering there aren't that many games in that format, and probably Zork Zero is the only reasonably textual one...
19:24:22 <heatsink> I thought z machine was for text games.
19:25:04 <SamB> well, the other versions all are, and even Zork Zero is reasonably text-based
19:25:31 <SamB> but it has some graphics around the borders, and an iconic map
19:26:26 * heatsink reads the z-machine standards document
19:26:36 <heatsink> Wow, talk about CISC.
19:26:45 <SamB> well duh
19:27:03 <SamB> but it isn't too bad, actually, mostly
19:27:20 <SamB> they do at least make it pretty easy to decode instructions and fetch their arguments
19:27:37 <SamB> so that the implementations of the individual instructions don't need to do that
19:27:52 <SamB> I'm pretty sure this was intentional
19:28:21 <SamB> (its not like they ever built one, after all! they had to write all this in 8-bit ASM!)
19:28:29 <heatsink> eew!
19:28:52 * heatsink wipes off the 8 bit asm cooties
19:30:43 <SamB> well, if it leads to an easier-to-implement VM...
19:31:06 <SamB> without a great need for duplicated code...
19:32:43 <heatsink> Hmm, so C wasn't really popular until the 1980s?
19:33:12 <SamB> I wouldn't know, I wasn't really born until the middle of the 1980s myself ;-)
19:34:23 <SamB> but I think it wasn't really any good for anything less powerfull than a 65816
19:34:35 * heatsink doesn't know what a 65816 is
19:34:54 <SamB> (apparantly a segmented variant of the 6502)
19:34:56 <SamB> sort of
19:35:10 <SamB> maybe I should say "paged"
19:35:44 <SamB> used in Apple IIs (at least some models) and the SNES
19:35:52 <qnix_> how can I call main with args in ghci/hugs ?
19:36:04 <SamB> qnix_: :args, is it?
19:36:09 <palomer> quick, someone give me a gmail referral!
19:36:13 <heatsink> :set args
19:36:16 <SamB> palomer: at what address?
19:36:25 <Frederick> palomer, do you need an invitation?
19:36:29 <Frederick> I can give you one
19:36:31 <SamB> I have like 100
19:36:36 <SamB> I demand to give mine!
19:36:37 <palomer> Frederick: yeah
19:36:50 <palomer> SamB: yeah
19:37:02 <Frederick> SamB, I wont argue with you you are my mentor :p
19:37:07 <SamB> hehe
19:37:23 <SamB> so, what email address shall I send it to?
19:37:41 <qnix_> heatsink: thanks!
19:40:24 <SamB> palomer: I need an address to send it to!
19:40:37 <palomer> oh, right
19:42:10 * SamB taps feet
19:42:18 * SamB is really, really patient
19:42:28 * SamB is humble too
19:43:20 * Frederick is very upset
19:43:27 <SamB> Frederick: oh?
19:43:34 <SamB> whats the trouble?
19:43:41 <palomer> SamB: I msg'd you
19:43:49 <SamB> palomer: oh.
19:43:53 <SamB> I don't think it worked
19:44:21 <SamB> or maybe it did
19:45:44 * Frederick hits the head against the table
19:47:04 <SamB> Frederick: so you didn't get anywhere?
19:47:11 <Frederick> SamB, nope
19:47:23 <SamB> do you at least understand the code from last night yet?
19:47:26 <Frederick> SamB, but I think I will get a good book
19:47:44 <Frederick> SamB, I understood but I wouldnt be able to do that by my self that is why Im trying to getthe book
19:47:50 <SamB> please do not be afraid to ask about code we suggest
19:48:15 <SamB> do you understand each part of it, and not just the gist of it?
19:48:31 <Frederick> SamB, you are helping me a lot but I need to somehow start walking over my own feets
19:49:02 <SamB> yes, which is why I want to know if you are unsure about any of the code I gave you last night
19:49:15 <SamB> I mean, I don't want it to be just *my* code
19:49:25 <SamB> I want to help you make it yours ;-)
19:49:42 <Frederick> SamB, yes, I understand the use and concepts but it is like I know what the function does and stuff but since I quite new to the language and lack of experience so I loose a lot of time untill I can find what I need
19:50:40 <Frederick> I spent time today tryng to do the damm productions rules without sucess, it is pissing me off
19:52:51 <SamB> Frederick: what did you try?
19:53:00 <SamB> and did you try running it through parsec?
19:53:16 <SamB> or couldn't you get it to typecheck?
19:53:27 <Frederick> SamB, I couldnt even define the rules properly
19:54:25 <SamB> have you tried just getting it to parse something simple?
19:54:31 <SamB> just to try what something would do?
19:55:33 <Frederick> SamB, I couldnt define the structure for productions I tryed to associate things like lhs rules = nonterminal `sepBy` string " -> " rhs rules = rhs termchars without succes
19:55:56 <SamB> oh
19:56:18 <SamB> okay. lets try something easier then.
19:56:31 <Frederick> and I cant get the book I eant
19:56:33 <Frederick> *want
19:56:44 <SamB> lets say we want to parse two words
19:56:50 <SamB> nothing fancy, just two words
19:57:25 <SamB> and, say, we want to make a tuple ("foo", "bar") when we parse "foo bar"
19:57:27 <SamB> okay?
19:57:54 <Frederick> sure
19:58:21 <SamB> okay, so what we'll do is this
19:59:20 <SamB> first, define, interactively, a function to parse a word:
19:59:50 <Frederick> SamB, Ive done parsers sample to parser parenteses and stuff
19:59:55 <Frederick> but I really need a book
20:00:51 <SamB> this one is to introduce the concept of a "do" block, actually
20:00:56 <SamB> you really, really need one!
20:01:47 <SamB> okay, so a word is a bunch of letters right?
20:01:53 <Frederick> SamB, sure
20:01:56 <SamB> and it turns out that there is a function
20:02:06 <SamB> @type Text.ParserCombinators.Parsec.Char.letter
20:02:08 <lambdabot> forall st. Text.ParserCombinators.Parsec.Char.CharParser st Char
20:02:17 <SamB> that parses one letter
20:02:31 <SamB> so, we say:
20:02:48 <SamB> *CFG> let word = many1 letter
20:03:14 <SamB> (many1 is a varient of many that always parses at least one of whatever thing)
20:04:13 <SamB> now, we want to parse two words, one after the other, and then return a tuple of both words, so
20:05:03 <SamB> *CFG> let twowords = do { word1 <- word; word2 <- word; return (word1, word2) }
20:05:11 <palomer> SamB: I can't seem to msg you
20:05:21 <palomer> SamB: I'm very sorry, but I'm going to have to get the invite from Frederick
20:05:24 <SamB> palomer: one got through
20:05:33 <SamB> no idea why one did but no others
20:05:49 <SamB> okay, I got another one too
20:05:50 <palomer> didn't they let anyone sign up for gmail at one point?
20:05:57 <SamB> palomer: yes
20:05:59 <Frederick> Invited
20:06:03 <SamB> you were not hallucinating
20:06:11 <SamB> I signed up at that point
20:06:16 <SamB> I also sent you an invite
20:06:43 <gzl> I have about 100 invites lying around if you need one
20:06:51 <SamB> I have only 99!
20:06:55 <palomer> SamB: ok, got your invite
20:07:07 <Frederick> palomer, now you will have 2 invites :p
20:07:16 <palomer> oooh, I'm so popular
20:07:19 <SamB> I have no diea how anyone can use all tohse things
20:07:42 <SamB> palomer: its because they give people so many of the things and so fast that you want to get rid of them at any opportunity
20:07:58 <palomer> didn't they open sign up?
20:08:03 <palomer> did they claso it again?
20:08:08 <SamB> palomer: yes!
20:08:09 <SamB> they did.
20:08:10 <palomer> s/claso/close
20:08:11 <palomer> why?
20:08:19 <SamB> at least, I couldn't find any way to do it anymore!
20:08:23 <SamB> no idea!
20:08:26 <gzl> it was just a big tease
20:08:29 <SamB> maybe they like the hype?
20:08:48 * palomer loves you guys
20:08:49 <SamB> anyone who talks to anyone can get one, probably
20:09:43 <palomer> humph!
20:09:47 <palomer> picking a username is no easy task
20:10:14 <SamB> my sister imprudently added a .14 to her name when none was needed!
20:10:39 <SamB> (said name being "blueblaze" or "blueblazes" or something like that)
20:10:43 <Frederick> I dont like mail boxes that tell the users age
20:11:12 <palomer> they should set up a new domain
20:11:23 <palomer> like geemail.com
20:11:42 <SamB> Frederick: I didn't realize it was supposed to be her age!
20:11:59 <SamB> I figured there must have been a blueblaze already or something
20:12:00 <Frederick> SamB, but it is right?
20:12:09 <SamB> Frederick: well, now, yes.
20:12:21 <Frederick> hehe
20:12:25 * Frederick isnt so dumb
20:12:36 * Frederick got a sister at this age too
20:12:41 <SamB> at least, thats what she told me when I mentioned it!
20:12:54 <Frederick> rofl
20:12:54 <SamB> and I don't think she has any reasons to be lying about her age
20:13:31 <SamB> Frederick: okay, so do you want me to explain this to you?
20:13:45 <SamB> I've done:
20:13:46 <SamB> *CFG> let word = many1 letter
20:13:47 <SamB> Loading package parsec-1.0 ... linking ... done.
20:13:47 <SamB> *CFG> let twowords = do { word1 <- word; word2 <- word; return (word1, word2) }
20:13:53 <Frederick> SamB, 2 am here all I want is to get the book give a good read on it
20:14:02 <SamB> ah
20:14:13 <SamB> well, you'll want to use a do for this function is all I can say
20:14:29 <SamB> I sure did!
20:14:52 <Frederick> SamB, brb I will reboot and get a link
20:15:02 <Frederick> I want to read the book so I will have "smart" questions
20:15:17 <Frederick> will need guidance as in the beginning not someone to do it forme
20:15:20 <Frederick> brb
20:16:00 <SamB> boy, the way he wanted to write that function was wierd
20:16:15 <SamB> lhs rules = nonterminal `sepBy` string " -> " rhs rules = rhs termchars
20:18:09 <SamB> my version is
20:18:14 <SamB> rule termchars = do x <- nonterminal termchars
20:18:15 <SamB>                     string " -> "
20:18:15 <SamB>                     ys <- rhs termchars
20:18:15 <SamB>                     return (x, ys)
20:18:37 <SamB> oh, he came on
20:18:43 <SamB> Frederick: disregard that code!
20:18:48 <SamB> you don't want to see it
20:18:51 <Frederick> k
20:19:05 <Frederick> hahah
20:19:08 <SamB> if you really, really get stuck, you might want to look at it
20:19:09 <Frederick> this is the solution :p
20:19:34 <SamB> hmm, should we send him to the monad tutorial?
20:19:45 <SamB> @google nomaware monads
20:19:47 <lambdabot> http://www.nomaware.com/monads/html/
20:20:00 <palomer> anyone have a link for interesting words?
20:20:23 <SamB> @google gutenberg alice in wonderland
20:20:25 <lambdabot> http://www-2.cs.cmu.edu/People/rgs/alice-table.html
20:20:51 <SamB> palomer: that was for you ;-)
20:21:22 <SamB> Frederick: yeah, its the solution
20:21:28 <SamB> at least, it is mine
20:21:47 <SamB> but if you don't want to look at the simple example of do, I don't know if that one will help much more!
20:21:53 <palomer> pfft
20:21:58 <palomer> someone took easytoremember@gmail.com
20:22:04 <SamB> palomer: heh
20:22:22 <SamB> the only thing nicer about this one is that I didn't use {;}
20:22:31 <Frederick> palomercan you plese check forthat link?
20:22:56 <SamB> Frederick: link?
20:23:24 <Frederick> SamB Im asking palomer a favor :p
20:24:38 <SamB> well, and there is the fact that this one is useful
20:24:56 <Frederick> SamB what do you mean?
20:25:26 <SamB> Frederick: well, I mean, its not particularly useful to parse two words into a tuple.
20:25:34 <SamB> or at least, not most of the time
20:32:08 <SamB> Frederick: I can sort of see what you were trying to do there, but it didn't actually make any sense the way you had written it. you had used Haskell tokens (and function names), but not for their intended purposes
20:32:59 <Frederick> SamB as ive said I got the idea but not the language abstraction
20:35:21 <SamB> Frederick: also, rhs and lhs mean nothing to the language
20:35:47 <Frederick> SamB I know but lhs of a production is a nonterminal
20:35:57 <palomer> what do you guys think of this email address: remarquable@gmail.com?
20:36:17 <SamB> Frederick: true, but you don't need your code to say that explicitly ;-)
20:36:28 <SamB> palomer: it sounds a bit hard to spell
20:36:49 <palomer> it's french!
20:36:49 * heatsink looks up "marque" in the dictionary... "retaliation, reprisal"
20:37:06 <palomer> it means remarkable
20:37:58 * fworp wonders about the people who review books on amazon... especially those that reviewed "Haskell: The Craft of Functional Programming"
20:38:24 <Frederick> SamB =/
20:38:30 <palomer> beware
20:38:45 <Frederick> ?
20:38:56 <SamB> Frederick: well, I'll stop messing with your brain for now, I guess
20:39:11 <Cale> fworp: what do you wonder about them?
20:39:19 <SamB> I mean, I'm tired enough myself...
20:39:22 <fworp> i wonder what drugs they are on
20:39:25 <Frederick> SamB I will read the book than I can ask you and cale better questions
20:39:36 <fworp> atleast one of them
20:39:38 <SamB> fworp: what did they say?
20:39:46 <SamB> did they say it was bad when it is good?
20:41:10 <fworp> i dunno if its either, thats why i was reading the reviews.. its kindof hard to describe: http://www.amazon.com/exec/obidos/tg/detail/-/0201342758/qid=1131942457/sr=2-1/ref=pd_bbs_b_2_1/104-4129835-1279956?v=glance&s=books
20:41:18 <palomer> what's THE haskell book?
20:42:36 <Cale> there's a "THE Haskell book"?
20:42:54 <palomer> like THE book all haskell programmers should read
20:43:11 <SamB> palomer: I haven't read any Haskell book yet
20:43:14 <palomer> the SICP of haskell
20:43:33 <SamB> I never made it through SICP either, maybe its why I'm so bad at LISP
20:43:37 <Cale> I took a few out from the library at one point, but got more use out of online tutorials.
20:43:50 <SamB> Cale: you have a strange library
20:43:52 <Cale> and writing code
20:43:54 <SamB> if it has Haskell books
20:44:02 <Cale> It had 5 or 6 of them
20:44:07 <palomer> my library has haskell books
20:44:11 <SamB> or at least a nice big one
20:44:24 <Cale> I'd expect just about any technical university library to have some :)
20:44:46 <SamB> then again, I haven't actually been to the library at a technical university for books
20:46:20 <stepcut> is the an md5sum library? Or do I just call the program ?
20:46:49 <Cale> technical (university library)
20:46:59 <Cale> not much of a difference anyway :)
20:47:10 <bojohan> "it has very little explantion of recursion for an introductory cs book". huh?
20:49:29 <fworp> bojohan: have you read the book?
20:49:37 <bojohan> yes
20:50:15 <fworp> would you recommend it to someone already familiar with haskell?
20:50:16 <palomer> do you guys fail to lookup pop.gmail.com too?
20:50:31 <SamB> palomer: I never try
20:50:40 <bojohan> fworp: not really. it was quite basic and slow-going.
20:50:50 <fworp> ah, alright.
20:50:54 <SamB> # host pop.gmail.com
20:50:54 <SamB> pop.gmail.com           CNAME   gmail-pop.l.google.com
20:50:54 <SamB> gmail-pop.l.google.com  A       64.233.163.111
20:50:54 <SamB> gmail-pop.l.google.com  A       64.233.163.109
20:50:59 <palomer> hrm
20:51:03 <palomer> evolution is on crack then
20:51:25 <SamB> or your DNS servers have somehow gotten wrong info
20:52:41 <bojohan> "the haskell school of expression" looked more interesting. i haven't read it, just flipped through it, though.
20:53:10 <Cale> I should construct a good set of exercises in Haskell and put them on the wiki
20:53:19 <heatsink> That's an excellent idea
20:54:22 <Frederick> Cale GREAT IDEA
20:54:24 <Frederick> wooops
20:54:28 <Frederick> sorry by caps
20:54:49 <thou> stepcut: hmm, i see in the ghc 6.2.2 release notes that the MD5 library was removed
20:55:44 <thou> stepcut: shouldn't be hard to find it and add it to your project though
20:55:49 <palomer> Cale: yes!
20:57:16 <thou> stepcut: there's a crc32 module in the MissingH library
21:01:51 <stepcut> hrm, I will just call the external version for now
21:02:14 <stepcut> I have already written too many things for this project :p
21:02:30 <palomer> yes!
21:02:35 <palomer> I unified all my email addresses
21:03:02 <Cale> http://www.haskell.org/crypto/doc/html/Data.Digest.MD5.html
21:04:07 <stepcut> Cale: sweet, I will switch to that later -- fortunately I already have crypto installed
21:04:33 <stepcut> cuz it depends on NewBinary, and the currently maintainer is a big slacker about updating it
21:06:34 <thou> Cale: huh, i couldn't find that with a google search :(
21:07:10 <Cale> thou: I got to it by searching for "Haskell crypto"
21:07:13 <stepcut> I don't think it sums md5sum anywhere on the page
21:07:34 <thou> hehe, i looked for haskell crypt and haskell cryptography
21:07:41 <thou> i thought there was somethign like that ... :)
21:08:14 <Cale> Haskell cryptographic also would have worked
21:10:43 <palomer> has anyone found any collisions for MD5?
21:11:24 <int-e> http://www.cits.rub.de/MD5Collisions/
21:20:05 <Frederick> SamB I got more 2 weeks to do this project, do you think im on the schedule?
21:20:15 <SamB> Frederick: I dunno.
21:20:21 <SamB> I think it can be done.
21:20:30 <SamB> but I dunno what all else you need to do.
21:20:44 <Frederick> SamB failure is not an option :p
21:21:17 <Frederick> I need to remove useless symbols, £ productions, left recursion
21:21:24 <Frederick> ah and place the grammar in 2 normals forms
21:21:53 <Frederick> once the parser is done the worst part is gone I believe
21:22:13 <Frederick> parsec has a function to remove left recursion
21:22:19 <SamB> well, that doesn't sound like a whole lot, but you'll probably need to pick up the pace a little. hopefully the parser is indeed the slowest part; certainly its the only part that requires monads.
21:23:10 <Frederick> the angorithms I need to implement have at most 5 lines each
21:23:18 <Frederick> so Im like 40 lines away of the end
21:23:42 <SamB> well, the lines isn't all that indicitive.
21:23:47 <SamB> at least, I hope not.
21:24:01 <SamB> anyway, to bed with me!
21:24:19 <Frederick> SamB cya tommorow :p
21:24:23 <Frederick> good night
21:24:46 <SamB> Frederick: okay, I hope so
21:26:43 <dash> Hi, the haskell bug is controlling my brain again and I want to write a UDP server
21:26:50 <stepcut> heh
21:26:57 <dons> it's a virus!
21:27:00 <dash> anyone got an example they can throw at me?
21:27:38 <Frederick> dash write my homework :p
21:27:50 <dash> Frederick: drop out
21:27:59 <Frederick> dash Im jk
21:28:04 <dash> (school is bad for programmers)
21:28:13 <Frederick> dash university
21:28:27 <dash> yes
21:28:31 <Frederick> dash it is a haskell assignment
21:28:32 <dash> that is what I mean.
21:29:20 <dash> Frederick: yes. that's my point
21:29:37 <Frederick> dash and Im not sure I will accomplish
21:29:57 <dash> anyway. udp server? do people use haskell on the inter nets?
21:31:08 <palomer> man, I love this gmail account
21:31:12 <dons> lambdabot lives on the inter nets. but she swings more to the udp side
21:31:13 <palomer> thx Frederick
21:31:17 <dons> s/udp/tcp/
21:31:20 <palomer> (and samb)
21:31:26 <palomer> do any of you have several gmail accounts?
21:31:39 <Frederick> palomer I have 1
21:46:20 <Frederick> bye folks
21:46:26 <palomer> cya
21:46:33 <Frederick> palomer I will be here tommorow
21:46:39 <Frederick> whole day long
21:46:53 <palomer> I might drop by
21:53:14 <dons> @index alloca
21:53:14 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
21:53:44 <dons> @index peekArray
21:53:44 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
21:54:01 <dons> @index peek
21:54:02 <lambdabot> Foreign.Storable, Foreign
21:54:27 <dons> @index Ptr
21:54:28 <lambdabot> Foreign.Ptr, Foreign, GHC.Exts, GHC.Exts
21:58:55 <ChronoWiz> why do i get an error about fractional ints when i try to calculate an average
21:59:15 <ChronoWiz> eg foldr (+) 0 [1..10] / length [1..10]
22:00:36 <dons> @type (/)
22:00:37 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:00:39 <ChronoWiz> whereas if I just put 10 as the denominator it works
22:01:05 <dons> @type length
22:01:06 <lambdabot> forall a. [a] -> Int
22:01:16 <dons> @type 10
22:01:16 <lambdabot> forall t. (Num t) => t
22:01:23 <dons> @type length [1..10]
22:01:23 <lambdabot> Int
22:01:26 <dons> that's why.
22:01:45 <ChronoWiz> how do i change length into a fractional number?
22:01:56 <dons> liberal application of fromIntegral is usually the solution :)
22:02:00 <dons> or else use `div`
22:02:07 <ChronoWiz> but i want a floating point answer
22:02:22 <dons> > foldr (+) 0 [1..10] / fromIntegral (length [1..10])
22:02:23 <lambdabot> 5.5
22:02:38 <ChronoWiz> hmm that totally wasn't working before..
22:02:56 <dons> maybe the parens?
22:03:13 <ChronoWiz> bah it works now
22:03:15 <ChronoWiz> yeah maybe
22:03:16 <ChronoWiz> thanks
22:03:18 <dons> they often make things weird. the precendence is a bit tricky around / :)
22:04:30 <ChronoWiz> i was resorting to using foldr (+) 0 (map (\x -> 1) [1..10]) for length which is just stupid :)
22:10:57 <palomer> length of a number?
22:13:29 <palomer> :type `\'
22:13:32 <palomer> @:type `\'
22:13:34 <lambdabot> parse error on input ``'
22:13:36 <palomer> @:type `\`
22:13:37 <lambdabot> parse error on input ``'
22:13:46 <palomer> @:type \
22:13:47 <lambdabot> parse error (possibly incorrect indentation)
22:13:53 <palomer> how do I get the type of \?
22:14:58 <ChronoWiz> @:type (\)
22:14:59 <lambdabot> parse error on input `)'
22:15:03 <ChronoWiz> @:type (\\)
22:15:05 <lambdabot> Not in scope: `\\'
22:15:21 <palomer> @4\3
22:15:22 <lambdabot> Unknown command, try @listcommands.
22:15:23 <ChronoWiz> didn't know there was a function \
22:15:31 <ChronoWiz> do you mean / ?
22:15:37 <palomer> @type (/)
22:15:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:15:55 <dash> hngh
22:15:58 <palomer> Num isn't an instance of Fractional
22:16:06 <dash> i need a python-to-haskell translating dictionary
22:16:10 <palomer> how does that work?
22:16:24 <dash> how do i say string.split(foo, "\r\n") in haskell =/
22:17:08 <ChronoWiz> gimme a sec dash..
22:17:18 <palomer> is it possible to find information about modules in ghci?
22:18:47 <ChronoWiz> words splits on all whitespace, but you want just \r\n
22:19:03 <dash> correct
22:19:16 <ChronoWiz> you could write your own function to do it..
22:19:24 <dash> i am writing network protocol parsing code
22:19:36 <dash> ChronoWiz: now i remember why i do everything in python
22:19:43 <ChronoWiz> why do you want to write it in haskell?
22:19:56 <palomer> pish posh
22:20:01 <palomer> we can find a function..
22:20:01 <dash> ChronoWiz: to make people's heads explode
22:20:39 <ChronoWiz> oh, dash, there is unlines which splits on \n
22:20:46 <dash> eh that's a start
22:20:53 <ChronoWiz> and you could filter out the carriage returns..
22:21:06 <dash> ChronoWiz: also sometimes I get temporary insanity and I think that haskell is useful for writing real programs
22:21:39 <ChronoWiz> er wrong way, lines
22:21:57 * dash nods
22:23:00 <Korollary> I translated some of my python scripts into haskell scripts. No big deal as long as the library has similar functionality.
22:23:31 <dash> Korollary: yeah, i'm looking at translating a 2000 line library though :)
22:23:42 <Korollary> dash: which library is that ?
22:23:54 <palomer> dash: http://haskell.org/hawiki/HaskellNewbie_2fStringParsing
22:23:59 <ChronoWiz> hm hugs complains about having \c in a string
22:25:04 <dash> korollary: http://divmod.org/trac/browser/trunk/Sine/sine/sip.py
22:27:18 <Korollary> dash: Yeah, this is couple of weeks' worth of stuff.
22:27:39 <dash> Korollary: heh heh
22:27:53 <dash> Korollary: i started writing that module two years ago
22:29:19 <Korollary> dash: so why do you want to translate it ?
22:29:28 <dash> Korollary: Crackheadedness
22:29:43 <dash> Korollary: my friends think it's impossible
22:30:47 <Korollary> dash: well, it's a good thing that your friends are obviously wrong.
22:30:53 <dash> five years after learning haskell i still don't know what it's good for
22:31:08 <dash> i am still trying to figure that out.
22:31:57 <Korollary> dash: I don't write python scripts anymore.
22:32:11 <dash> Korollary: Me neither.
22:32:18 <dash> Just programs.
22:32:28 <Korollary> dash: I meant, I write whatever it is in haskell instead.
22:32:44 <dash> Korollary: what kinds of things
22:33:24 <Korollary> dash: most recently I wrote something to rip a cd and encode the tracks in flac and mp3 (using lame and flac external encoders).
22:33:30 <dash> oh
22:33:38 <Korollary> dash: I would normally have done that in python.
22:33:41 <dash> it's probably less typing to use sh for that
22:34:08 <Korollary> dash: nah. It was a lot of id3 tagging, etc. besides, I don't know sh scripting.
22:34:44 <dash> well
22:34:52 <dash> actually i would use gstreamer for that, if i had to write it
22:35:00 <dash> in real life i would use abcde
22:36:45 <dash> anyway all that's irrelevant, i am talking about actual programs, not just glue
22:37:05 <Korollary> darcs
22:37:13 <dash> what about it?
22:37:20 <Korollary> it's in haskell
22:37:23 <dash> indeed it is
22:37:29 <Korollary> it's a real program
22:37:36 <dash> yes, it is
22:37:40 <dash> and mercurial and bzr are in python
22:37:45 * dash shrugs
22:37:50 <Korollary> dons is writing yi, which is a text editor
22:37:54 <azuroth> pugs is pretty awesome...
22:38:07 <dash> Korollary: yes, but is haskell /good/ for these things? :)
22:38:46 <dash> ok yes, haskell is probably good for a certain variety of language-interpreter research
22:39:10 <dons> I wrote hmp3 (an mp3 player) in haskell last week.
22:39:21 <dons> haskell's good for building robust software in general
22:39:23 <dash> I didn't make a whole lot of headway last time i tried to do that, but it was ok.
22:39:25 <dash> dons: why so?
22:39:36 <dons> the type system means you can't get a segfault
22:39:40 <dash> dons: erm
22:39:44 <dash> dons: no it doesn't
22:39:51 <dash> dons: it means you can't get a runtime type error
22:39:52 <dons> many many more properties are enforced statically
22:40:09 <dons> well typed programs don't segfault, dash
22:40:17 <dons> unless you do something untyped (like call C)
22:40:17 <dash> dons: that's hardly unique to haskell
22:40:26 <dons> you need strong static typing for this.
22:40:36 <dons> and not many languages have that
22:40:43 <dash> dons: java, python, sh, ruby, C#, etc, all exhibit this behaviour
22:40:54 <dons> umm..
22:41:11 <dons> the properties you can check statically aren't as strong in those languages
22:41:21 <dons> there's a reason haskell wins the icfp contest
22:41:30 <dons> despite a majority of entires being in C++ or C
22:41:32 <dons> and perl
22:41:34 <dash> dons: yes, but they don't segfault unless there's an implementation bug
22:42:19 <dons> they still need runtime checks though. which makes the system more complex. not sure about ruby.
22:42:39 <dons> and, really, sh is untyped!
22:42:45 <dash> yes, it is
22:42:51 <dash> but it doesn't segfault on erroneous programs
22:43:09 <Korollary> I dont know what you are discussing anymore.
22:43:16 <dash> Korollary: segfaults :)
22:43:58 <Korollary> segfaults are a thing of the past for languages younger than ten years.
22:44:18 <dash> as long as your implementation doesn't suck ;)
22:44:37 <dons> but whether they use dynamic checks, and the correspondingly bewildering semantics, or static checks, which remain fairly simple, is an interesting division
22:44:51 <Korollary> if haskell doesn't suit what you need, you can give ocaml a try, or scheme a try.
22:44:54 <dash> dons: why is it interesting?
22:45:06 <palomer> so, erm, how does (/) work?
22:45:11 <dash> Korollary: between ocaml and haskell, i'm going to choose haskell every time :)
22:45:14 <Korollary> palomer: ?
22:45:19 <palomer> it takes a Fractional, but 3 is a Num !
22:45:23 <palomer> @type (/)
22:45:25 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:45:28 <palomer> @type 3
22:45:30 <lambdabot> forall t. (Num t) => t
22:45:36 <palomer> and Num is not an instance of Fractional
22:45:50 <Korollary> palomer: Num is a typeclass itself.
22:46:04 <Korollary> palomer: check out the fractional typeclass declaration
22:46:18 <palomer> oh, righto
22:46:20 <dash> dons: everything's gotta do some variety of dynamic checks
22:46:22 <Lemmih> @google Why functional programming matters
22:46:23 <lambdabot> http://www.md.chalmers.se/~rjmh/Papers/whyfp.html
22:46:41 <dash> whether you call it types, or something else
22:46:54 <palomer> are hierarchal typeclasses part of haskell98?
22:47:04 <Korollary> yes
22:47:34 <palomer> say you have two types which implement a class
22:47:39 <palomer> with member foo
22:47:56 <palomer> actually, wait, nevermind
22:47:58 <palomer> it works:O
22:48:00 <palomer> typeclasses rock!
22:48:30 <palomer> too bad you can't have double dispatch type classes
22:48:32 <palomer> (or can you?)
22:49:05 <dash> ok
22:49:31 <dash> ok i take it back, i do know of exactly one thing haskell is good for
22:49:39 <dash> "monadic modular interpreters"
22:49:57 <palomer> it's good at being fun?
22:50:04 <dash> palomer: Eh
22:50:52 <dash> fun is playing monopoly or dancing
22:51:02 <dash> programming is something one does to make the voices in your head stop
22:52:05 <palomer> but seriously, could you have a typeclass who's instances are 2 types, call this typeclass tc. say b,f is an instance of tc, and a member of tc is blah :: f -> b -> (f,b). blah f would be a function which would do different things depending upon the argument
22:52:08 <palomer> do you have this?
22:52:13 <Maddas> surely anything that does that counts as fun, dash :-)
22:52:36 <dash> Maddas: mmm
22:52:46 <palomer> dash: that's _so_ true
22:52:49 <palomer> (about the voices)
22:52:51 <Maddas> dash: Hm, no, I take that back.
22:53:07 <dash> Maddas: yeah. see?
22:53:26 <Maddas> :-)
22:53:43 <dash> hmm
22:53:43 <Korollary> palomer: a method in a typeclass is parametric. It can't be restricted to involve two of the class instance types.
22:54:04 <dash> i guess i could write a parsec parser for this.
22:54:57 <dash> have you guys got a place people can lodge random semi-interesting hacks?
22:54:58 <palomer> Korollary: members are parametric, sure, but I was wondering if it would be possible to make them doubly parametric!
22:55:38 <dash> python's got the python cookbook
22:56:12 <Korollary> dash: There's The Monad Reader on the wiki. a bunch of articles on the cool stuff.
22:57:18 <dash> Korollary: well, lemme 'splain
22:57:29 <dash> Korollary: last year I wanted to write a lisp interpreter in haskell
22:57:45 <dash> i googled a bit and then I said "I can't believe there isn't a lisp interpreter in haskell"
22:57:56 <dash> so i wrote one
22:58:12 <dash> now where should I put it so that someone else doesn't have the same experience? :)
22:58:28 <Korollary> dash: Ah, I know one guy who was trying to write one himself.
22:58:51 <dash> there was HScheme or something, IIRC
22:59:04 <dash> but it had code that confused shapr in it
22:59:07 <Korollary> dash: There are some darcs repositories. Check with dons.
22:59:10 <dash> and when shapr is confused, I give up
22:59:21 <dash> dons: hi
22:59:37 <dash> hm, for that matter, i guess I could host one.
23:00:36 <Korollary> dash: There's also this: http://hackage.haskell.org/
23:01:18 <palomer> Korollary: ok, look at it this way: if I do foo bar blah, the compiler figures out what function I mean by looking at bar, right?
23:01:36 <palomer> the typeclasses of bar will decide which foo to use
23:02:49 <Korollary> palomer: or you may annotate the types. Whatever it is, it is statically determined.
23:03:59 <palomer> right
23:04:05 <palomer> why not have both bar and blah decide foo?
23:04:07 <Maddas> dash: The paper on Composable Memory Transaction is one that showed me a good example of where Haskell's powerful type system is really useful
23:04:48 <dash> Maddas: hm
23:05:07 <dash> Maddas: concurrency is something i care a lot about
23:05:23 <Maddas> I just like reading papers :-)
23:05:27 <dash> Maddas: yeah see
23:05:38 <dash> that's the cultural problem i have with haskell :)
23:05:42 <soysauce> hm, what's wrong with this:
23:05:42 <soysauce> type Matrix = Ix.Ix a => Array.Array (a, a) b
23:05:49 <Maddas> dash: I don't use Haskell much in particular :-)
23:05:54 <dash> right
23:05:56 <dash> me neither
23:06:12 <soysauce> "Illegal polymorphic or qualified type ..."
23:07:05 <Maddas> It did seem like a very interesting thing to check out, though, especially if I ever need to write anything using concurrency (I'm sure I will). Conjure (the BitTorrent client being written) claims to make heavy use of it, too.
23:07:49 <dash> Maddas: mmm
23:08:10 <Korollary> soysauce: 'b' should be on the left side of '=' as well, methinks
23:08:13 <dash> Maddas: i think if i was to switch away from python, it'd probably be to erlang
23:08:57 <Maddas> dash: You could still read the paper (assuming you didn't, of course) just to see how the type system fits in.
23:09:03 <soysauce> Korollary - yes, I saw that, but doesn't seem to fix anything
23:09:05 <palomer> dash: check out oz!
23:09:08 <soysauce> I have right now: type Matrix a b = Ix.Ix (a, a) => Array.Array (a, a) b
23:09:10 <dash> palomer: oz is rad!
23:09:28 <dash> palomer: it just doesn't have enough platform integration
23:09:42 <Korollary> soysauce: I don't think contexts are allowed in type synonyms
23:09:42 <palomer> dash: do you have any specific gripes about haskell other than lack of built in functions?
23:09:54 <soysauce> hm
23:09:57 <dash> palomer: it's just a cultural thing
23:10:01 <soysauce> you're right; I remembered wrong, I guess
23:10:07 <soysauce> oh well, that fixes it; thanks
23:10:24 <dash> palomer: like maddas demonstrates, people on the whole prefer reading and writing papers to writing substantial programs
23:10:49 <Korollary> dash: icfp entries notwithstanding maybe
23:11:02 <Maddas> dash: Um, I feel that people here are very productive regarding code.
23:11:07 <dash> korollary: a program that can be written in 3 days is not a substantial program
23:11:10 <dash> palomer: nothing wrong with that
23:11:20 <dash> palomer: it's just different from what i'm interested in :)
23:11:20 <Maddas> dash: I don't write substantial program in any languages, that's nothing specific to Haskell.
23:11:34 <palomer> substantial programs are for chumps!
23:11:43 <dash> right :)
23:11:49 <palomer> hrm
23:12:01 <Korollary> dash: check out missingH, darcs, ghc itself. There is just not many of us, so don't expect the depth of CPAN.
23:12:06 <palomer> is there ever a time when you guys think "man I wish I could dispatch dynamically"?
23:12:28 <dash> Korollary: seen 'em!
23:12:35 <Korollary> palomer: dispatch as in OO ?
23:12:59 <palomer> Korollary: well, erm, you have dispatch in OO
23:13:12 <palomer> what I mean to say is that the function used depends on the type applied
23:13:18 <dash> dispatch is pretty much the definition of OO :)
23:13:19 <palomer> and this process is done at runtime
23:13:23 <dash> palomer: yep, that's OO
23:13:33 <Korollary> palomer: There is dynamic support for ghc, I believe
23:13:39 <Korollary> @index Dynamic
23:13:40 <lambdabot> Data.Dynamic
23:13:47 <dash> or else OO doesn't mean anything :)
23:14:19 <palomer> but OO has a specific way of deciding which function to use
23:14:49 <dash> palomer: a specific way that's different for every OO system ;)
23:14:55 <Korollary> palomer: I think you mean polymorphic dispatch
23:15:32 <palomer> ok, OO is a template as to how to decide
23:15:38 <palomer> I'm sure erlang has dynamic features
23:15:45 <palomer> (and ghc has Data.Dynamic)
23:15:45 <dash> palomer: erlang is dynamically typed
23:15:53 <palomer> and erlang is certainly not OO
23:16:12 <dash> well if you squint just right
23:16:19 <palomer> (well, erm, according to the erlang people at least)
23:16:30 <palomer> is scheme OO? I think not!
23:16:35 <Maddas> palomer: What definition of 'OO' do you use? There's no widely agreed-upon one, from what I can say
23:16:37 <dash> what!
23:16:42 <dash> scheme is an actor language! ;)
23:16:58 <dash> palomer: "object oriented" is really one of those phrases that has had all meaning leached out of it by competing definitions
23:17:01 <Maddas> palomer: Depends on what you consider OO (well, and whether you restrict yourself to R5RS)
23:17:03 <Maddas> Indeed..
23:17:07 <palomer> Maddas: right, I start off with the assumption that certain languages are certainly not OO and work from there
23:17:18 <dash> all it means now is "I think it is good"
23:17:20 <Maddas> palomer: Then I don't see the point of discussing whether they are OO.
23:17:30 <palomer> you guys brought it up!
23:17:31 <palomer> not me!
23:17:42 <dash> palomer: yes, sorry.
23:18:24 <dash> the only real common feature between OO languages is dynamic method dispatch on type, is all :)
23:18:33 <Maddas> There's a number of features commonly associated with it at http://www.paulgraham.com/reesoo.html
23:18:38 <palomer> what about inheritance?
23:18:56 <dash> palomer: not essential
23:19:09 <Korollary> palomer: explicit hierarchies are not necessary for OO
23:19:12 <Maddas> dash: Even then, some people argue Java isn't really OO because not everything is an object -- you know the drill :)
23:19:38 * Korollary dispatches XOR on individual bits of a Double object.
23:19:45 <dash> hee _hee_
23:19:49 <Maddas> heh
23:20:06 <Korollary> Let me explain this MD5 checksum using UML
23:20:28 * Maddas leaves to hunt breakfast
23:20:31 <Maddas> Later!
23:20:37 <Korollary> bonne appetite
23:20:46 <Maddas> Thanks ;-)
23:20:54 <dash> anyway
23:21:10 <dash> the point at which i start taking a language seriously is when someone writes a usable imap server in it
23:21:24 <dash> or something equally complex
23:21:31 <dash> like, say, a jabber daemon
23:23:39 <palomer> it would take way too long to write such a paper
23:23:47 <dash> gwa ha ha
23:23:54 <dash> man
23:24:04 <dash> i _wrote_ this code and I think I don't understand it now.
23:24:11 <dash> someone else want to explain my program to me?
23:24:40 * dash kicks his httpd
23:32:32 <dash> aha
23:32:32 <dash> http://ghostwheel.ath.cx/~washort/arnis.hs
23:32:57 <dash> the runFooT bits confuse me terribly.
23:45:39 <Itkovian> any idea how I can have Parsec parse the following regex: [Bb][Oo][Oo][Kk]? without giving all possibe combinations, that is.
23:47:21 <Speck> hmm... it might be interesting to have haskell bindings to this: http://neshla.sourceforge.net/
23:47:59 <Korollary> ahah
