00:00:04 <shapr> :-)
00:00:33 <gour> unusednick: well, 'bok' you cannot find in Croatian dictionary with the meaning 'bye', 'hi'...
00:03:09 <gour> unusednick: actually, if you meet older people, they are still using 'bog' in the same context
00:03:37 <shapr> hi skew
00:03:42 <skew_> hi
00:04:16 <shapr> wassup?
00:04:26 <skew_> writing code about grammars
00:04:38 <shapr> Sounds like fun.
00:04:47 <shapr> Hey, any progress on that TMR article? :-)
00:05:01 <shapr> It's the 30th, so I'm trolling for publications again...
00:05:24 <skew_> I'm converting BNF to normal forms, using Data.Graph.Inductive.
00:06:03 <shapr> Cool, I like inductive graphs.
00:08:59 <skew_> does the library have good documentation anywhere?
00:09:22 <ADEpt> skew_: use the source, reaaly
00:09:23 <shapr> Yes, several papers and erwig's thesis.
00:09:39 <ADEpt> shapr: they seem to be slightly outdated, though
00:09:59 <shapr> They do describe the viewpoint behind inductive graphs though, I like that.
00:10:59 <shapr> heh
00:22:58 <shapr> cute quit message
00:24:43 <shapr> Has anyone tried the supercollider protocol implementation?
00:25:07 <ADEpt> shapr: what's this?
00:25:50 * shapr gets url
00:25:58 <sieni> www.google.com?
00:27:14 <shapr> ADEpt: http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/9503
00:27:57 <shapr> I'm just reading the source first to make sure it's not really a keyboard logger or something...
00:28:56 <shapr> I like the idea of dot output.
00:31:02 <shapr> I think I'm going to enjoy this library...
00:37:25 <dons> Cale, those warnings look like the 6.4 bogus import bug
00:37:32 <dons> no -Werror should be the soln
00:40:58 <Cale> dons: okay, cool, he said he'd just upgrade ghc
00:42:57 <ADEpt> @seen jlouis
00:42:58 <lambdabot> jlouis is in #haskell-blah and #haskell. Last spoke 15 hours, 39 minutes
00:42:58 <lambdabot> and 44 seconds ago.
00:44:53 * gour goes back to his study
00:45:11 * shapr goes back to his library
00:45:21 <musasabi> morning
00:45:38 * musasabi got GHCI to run on NetBSD (linux emulation)
00:46:36 <shapr> SamB: Yes, I'm the wiki maintainer, and the FrontPage does say that you need to login.
00:47:09 <Heffalump> musasabi: building linux binaries?
00:50:03 <musasabi> Heffalump: yes, but they work transparently...
00:50:13 <musasabi> next I am trying to build a native GHC.
00:50:46 <Heffalump> what was hard about getting it to run under emulation, OOI?
00:51:39 <shapr> Wow, these slavepianos guys are cool.
00:52:05 <musasabi> 1) unpack it, 2) run configure under linux, 3) install the right glibc rpm to NetBSD /emul/linux, 4) gmake install, 5) it just works
00:52:26 <Heffalump> ok, so nothing :-)
00:52:32 <neologism> I built native ghc for fbsd without any problems
00:52:57 <musasabi> The only small thing, was that configure had to be run inside linux.
00:55:36 <shapr> Neat, "A Long Tale with Many Notes. 54 min. Twenty-seven works for string quartet, fax machine, and white board." is from the same guys who wrote the SuperCollider protocol binding in Haskell.
00:56:46 <shapr> Wow, they combine turntables and violins.
01:00:30 <kolmodin> @where conjure
01:00:30 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
01:09:28 <shapr> It's a beautiful day out there campers!
01:09:40 <ProfTeggy> Moin
01:11:36 <int-e> shapr: Hmm. I disagree. The sky is grey, although I have to admit that it's not raining and not as cold as it was during the weekend.
01:12:10 * joelr1 waves
01:12:40 <shapr> int-e: Better than black.
01:13:04 <shapr> I've been waking up when the sun was going down the last few days, so it looks nice to me.
01:13:06 <shapr> hiya joelr1 
01:15:06 <kolmodin> @where fps
01:15:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
01:17:47 <ADEpt> kolmodin: hi
01:17:51 <kolmodin> ADEpt: hi
01:18:06 <ADEpt> kolmodin: since you are the one who added quickCheck.hs to conjure, i'll ask you
01:18:12 <kolmodin> shoot
01:18:26 <ADEpt> kolmodin: do you know how to make it report test failures via exit code?
01:18:35 <kolmodin> :( no
01:19:07 <kolmodin> quickCheck :: (Testable a) => a -> IO ()
01:19:17 <ADEpt> kolmodin: btw, cool arbitraries for BEncode :)
01:19:24 <kolmodin> as far as I know it's not possible
01:19:33 <kolmodin> ADEpt: thanks :)
01:19:40 <shapr> How would you want test failures to be reported?
01:20:16 <shapr> I report test failures via exit code with HUnit and haskell-mode - http://www.haskell.org/hawiki/HaskellMode
01:20:19 <ADEpt> shapr: as exit code. so that "runghc quickCheck.hs" could be used as darcs test script, and will terminate record in case of test failures
01:20:54 <shapr> hmm
01:21:31 <kolmodin> I'll ask Koen if there is a way to do it, otherwise it will be a feature request :)
01:22:41 <shapr> I think QuickCheck catches errors by default, but you could probably put into the quickCheck script.
01:23:00 <shapr> That's how I did my test-driven-development extension to QuickCheck.
01:26:11 <ADEpt> shapr: i could grep the output of quickCheck.hs, but that is not neat and nice
01:30:00 <shapr> I think there's a better way, but I'm not sure what it is..
01:30:53 <kolmodin> perhaps it's possible to use Test.QuickCheck.evaluate?
01:31:00 <kolmodin> anyway, got to go
01:31:01 <kolmodin> bye
01:44:59 <shapr> What package has System.Posix?
01:45:06 * shapr is trying to fix a cabal spec
01:45:25 <ADEpt> shapr: unix ?
01:45:48 <shapr> Thanks :-)
01:47:03 <shapr> yay, fixed
01:51:55 <shapr> Ok, I patched the SuperCollider protocol binding to build with the latest cabal.
01:55:52 <dcoutts> shapr, clearly we need a @ghc-pkg lambdabot command :-)
01:56:30 <ADEpt> or better @fix-cabal :)
02:02:36 <shapr> dcoutts: Truly, I'd like to find a package by module name.
02:14:08 <typhen> howdy haskells
02:15:30 <typhen> i'm a beginning haskell programmer, looking for advice on a problem
02:16:17 <typhen> how does one write a program that loops and continually asks for input, processing that input each time?
02:18:51 <araujo> Good morning Haskell!
02:20:49 <araujo> typhen, what is exactly your problem?
02:23:38 <typhen> well,
02:24:14 <typhen> i'm thinking to make a tic-tac-toe program for a first try at haskell,
02:24:38 <typhen> so i'd like it to accept a number 1-9 to represent user input
02:25:32 <typhen> with those numbers corresponding to the possible squares one can select
02:29:04 <typhen> so, i imagine i'd have a main function, which calls getLine, and passes that as a function argument
02:29:22 <typhen> (I may be using C++ terminology here, I'm coming from C++/Prolog backgroud)
02:29:30 <int-e> typhen: you can represent the whole loop as a function that calls itself recursively
02:30:22 <typhen> okay. does it make sense to call main recursively, or is that immoral?
02:30:39 <int-e> typhen: it can take the current tic-tac-toe board as its argument, read a line, modify the board and call itself with a new state. the basic pattern is   function foo = do one loop iteration; function foo'
02:30:53 <int-e> main doesn't have a signature that allows passing additional arguments
02:31:03 <int-e> it always has type IO ()
02:31:09 <int-e> main :: IO ()
02:31:18 <typhen> okay,  makes sense
02:31:55 <typhen> i'll have a shot at writing that up, and come back when i've come up with something
02:32:01 <int-e> if you have a final question 'do you want to play another game 'Y/N'' and the user answers 'yes', you can just call main again.
02:32:37 <typhen> okay
02:34:04 <joelr1> how do you pattern-match a Dynamic value?
02:34:18 <joelr1> can you, actually?
02:35:51 <dcoutts> joelr1, I think you have to convert it to something concrete first
02:36:01 <joelr1> dcoutts: thanks, i thought so
02:39:36 <typhen> is it okay to ask basic syntax questions here, or should I rtfm? specifically: how to declare a data type that's an array of ints? (possibly data Board = [Int])
02:40:23 <ski> it's ok
02:40:36 <ski> type Board = [Int]
02:40:42 <ski> that's a list of ints
02:40:56 <ski> 'type' defines type synomyms (like typedef)
02:41:09 <boegel|home> typhen: either 'type Board = [Int]'  or 'data Board= Board [Int]'
02:41:20 <boegel|home> you probably want the former
02:42:17 <boegel|home> yeah, thanks for the help and byebye everyone :|
02:42:37 <ski> bye boegel|home ..
02:43:07 <dcoutts> typhen, it's possible to use an array but it's much easier to use a list (and for small lists/arrays there's no performance advantage)
02:43:28 <typhen> oh yeah, list is what i meant
02:46:16 <roadkill> newbie question. if I open a file for writing and get filehandle h; how can i map "c <- IO.hGetChar h" to get a list of Char for example?
02:46:44 <boegel|home> @index readFile
02:46:44 <lambdabot> System.IO, Prelude
02:46:49 <boegel|home> @type readFile
02:46:50 <lambdabot> FilePath -> IO String
02:46:54 <boegel|home> @type String
02:46:55 <lambdabot> Not in scope: data constructor `String'
02:47:00 <boegel|home> erm
02:47:07 <boegel|home> well, String = [Char]
02:47:57 <roadkill> yeah, but i want to know how to make a list from the values obtained from the (<-) operator basically
02:48:27 <boegel|home> using hGetCharh ?
02:48:33 <ADEpt> roadkill: mapM or mapM_ if you dont want the list, but want the side-effects
02:48:42 <roadkill> ah!
02:48:59 <roadkill> thank you very much!
02:49:52 <ski> @type mapM
02:49:53 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
02:50:38 <ski> mapM will call a monadic function over each element in a list, performing effects in order, and returns list of answers
02:51:53 <roadkill> and in this the list parameter will be a list of file handles, and the function will be IO.hGetChar...
02:52:20 <ski> roadkill : otoh, in your example, it seemed like you want to call 'IO.hGetChar h' a certain number of times (maybe until end of file ?) instead
02:52:38 <ski> do you really want to read one char from each file
02:52:53 <ski> i thought you wanted to read many chars from same file
02:53:01 <roadkill> ski: i want to read many chars from the same file
02:53:24 <roadkill> so i can just supply a list of the same handle. i think. hehe
02:53:48 <Cale> hGetContents is a slightly evil, but also nice way to get a lazy list of a file's contents
02:54:05 <Cale> note that if the file changes as you're evaluating that list, bad things happen
02:54:06 <ski> roadkill : how many chars do you want to read ?
02:54:22 <Cale> the file will automatically be closed at the end
02:54:49 <ski> @type \h -> sequence $ replicate 42 $ IO.hGetChar h
02:54:50 <lambdabot> GHC.IOBase.Handle -> IO [Char]
02:55:09 <ski> roadkill : that will e.g. read 42 chars from same file
02:55:36 <ski> > replicate 5 ('a',3)
02:55:37 <lambdabot> [('a',3),('a',3),('a',3),('a',3),('a',3)]
02:55:42 <ski> wb
02:55:56 <roadkill> yes i was just looking for that command. and yes a finine number of chars
02:56:00 <Cale> just restarting X with what it hopefully the new driver :)
02:56:05 <Cale> is*
02:56:25 <roadkill> ski: thanks for the help.  
02:56:29 <int-e> @type hGetChar
02:56:30 <lambdabot> Not in scope: `hGetChar'
02:56:44 <int-e> @type IO.hGetChar
02:56:45 <lambdabot> GHC.IOBase.Handle -> IO Char
02:56:45 <ski> roadkill : so my code there makes a list of 42 (identical) IO-actions, then when run, will read a char from the file .. then 'sequence' runs each action in the list in turn, finally monadically returning the list of results (chars)
02:56:47 * boegel|home leaves for lunch
02:56:49 <roadkill> @type IO.hGetChar
02:56:50 <lambdabot> GHC.IOBase.Handle -> IO Char
02:57:02 <int-e> uh - no Maybe?
02:57:27 <ski> exception
02:57:43 <ADEpt> roadkill: i was not paying attention. you want something like sequence (repeat gGetChar h)
02:57:49 <ski> (possibly there should be a variant with Maybe ..)
02:57:50 <ADEpt> @type sequence
02:57:51 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
02:57:58 <roadkill> cool
02:58:00 <ski> in this case
02:58:07 <ski> sequence :: [IO a] -> IO [a]
02:58:26 <ski> ADEpt : repeat will create an infinite list
02:58:37 <ADEpt> ski: so what? :)
02:58:51 <roadkill> i'm using /dev/zero so its ok :P
02:58:58 <ADEpt> sequence $ take 1024 $ repeat ...
02:59:05 <ski> if file is finite, i think it will raise exception when coming to end of file
02:59:37 <ski> ADEpt : also, i think that call to sequence is strict .. i.e. it tries to do all actions before returning result of any of them
02:59:55 <triplah> isnt $! strict?
03:00:01 <ski> (so you can't escape here by just looking at, say, the 42 first chars)
03:00:19 <ski> triplah : yes that is strict in second arg
03:00:31 <triplah> ahh
03:00:36 <roadkill> My question has been answered, thanks very much folks!
03:03:15 <ski> @type let lazySequenceIO [] = do {return []}; lazySequenceIO (ma:mas) = System.IO.Unsafe.unsafeInterleaveIO $ do {a <- ma; as <- lazySequenceIO mas; return (a:as)} in lazySequenceIO
03:03:16 <lambdabot> forall a. [IO a] -> IO [a]
03:03:53 <ski> ADEpt,roadkill : that should lazily sequence a list of IO-actions .. like ADEpt's example with an infinite list
03:06:12 <ski> (ADEpt : replicate n = take n . repeat)
03:07:32 <roadkill> hehe haskell is hard!
03:07:59 <typhen> i don't see the difference between "read" and "getLine". Which one actually reads the character from input?
03:08:00 <ski> haskell is different !
03:08:08 <ski> @type read
03:08:09 <lambdabot> forall a. (Read a) => String -> a
03:08:17 <ski> that only reads from a string
03:08:17 <ulfdoz> What's the concrete implementation of splitAt?
03:08:23 <ski> @type getLine
03:08:24 <lambdabot> IO String
03:08:32 <ski> that only read *a* string
03:08:38 <roadkill> typhen: read takes a string and parses it to determine if is a number
03:08:48 <ski> 'read' parses a string into something (like a numner, e.g.)
03:08:49 <int-e> lazySequenceIO = sequence . map unsafeInterleaveIO :)
03:09:02 <ski> @type readIO
03:09:03 <lambdabot> forall a. (Read a) => String -> IO a
03:09:25 <ski> int-e : that won't work, i think
03:09:33 <int-e> ski: it does
03:09:53 <ski> how about if you force second element before first ?
03:10:12 <ski> won't it, in the file reading case, read first char in file into second element, then ?
03:10:38 <int-e> hmm.
03:10:42 <int-e> yes it does. thanks.
03:11:28 <typhen> hmm, how do i invoke read in the interpreter? things like "read 22" or "(read 22) :: Int" give the same error
03:11:37 <ski> so, it's really unsafe (impure, i.e.), then .. sadly, since it was so short and simple
03:11:45 <ski> try
03:11:50 <ski> read "22" :: Int
03:11:59 <ski> you must pass a string to 'read'
03:12:05 <typhen> aha
03:12:34 <ski> mostly you don't have to say the type like ':: Int', since if you write that in code, it will be determined by context (or get overloaded, which is also ok)
03:12:48 <typhen> and it throws an error if it can't parse it as the desired type
03:13:12 <ski> but, in interpreter, it doesn't know what the type of the whole expr you write is meant to be, here, so that's why you need a type asciption here
03:13:22 <typhen> yeah
03:13:27 <ski> > read "x" :: Int
03:13:28 <lambdabot> Prelude.read: no parse
03:13:34 <ski> > read "23" :: Int
03:13:35 <lambdabot> 23
03:13:59 <roadkill> > read "22.0
03:13:59 <lambdabot>  lexical error in string/character literal
03:14:01 <typhen> lambdabot: oh, you're an interpreter. Thanks
03:14:03 <roadkill> > read "22.0"
03:14:04 <lambdabot> Add a type signature
03:14:05 <typhen> :-)
03:14:18 <roadkill> > read "22.0" :: Fractional Int
03:14:18 <lambdabot>   Class `Fractional' used as a type
03:14:18 <lambdabot>   In the type `Fractional Int'
03:14:18 <lambdabot>   In an expression type signature: Fractional Int
03:14:23 <ski> > let maybeRead s = case reads s of [(a,_)] -> Just a; _ -> Nothing in  maybeRead "23" :: Int
03:14:24 <lambdabot> Couldn't match `Int' against `Maybe a'
03:14:31 <ski> > let maybeRead s = case reads s of [(a,_)] -> Just a; _ -> Nothing in  maybeRead "23" :: Maybe Int
03:14:32 <lambdabot> Just 23
03:14:38 <ski> > let maybeRead s = case reads s of [(a,_)] -> Just a; _ -> Nothing in  maybeRead "xyz" :: Maybe Int
03:14:40 <lambdabot> Nothing
03:14:48 <ski> that let you catch parse failure
03:15:42 <ski> > read "22.0" :: Fractional a => a
03:15:43 <lambdabot>  add (Read a) to the expected type of an expression
03:15:43 <lambdabot>   In the expression: read "22.0" :: (Fractional a) => a
03:15:43 <lambdabot>   In the definition of `xxxx': xxxx = read "22.0" :: (Fractional a) =>
03:15:43 <lambdabot> a
03:15:56 <ski> > read "22.0" :: (Read a,Fractional a) => a
03:15:57 <lambdabot> 22.0
03:16:00 <roadkill> Just to let you know, I am finding Haskell understandable since i have used python.   I tried to learn OCaml and Scheme before i knew python and i didnt get it.
03:16:21 <typhen> read "22.0" :: Float
03:16:27 <typhen> > read "22.0" :: Float
03:16:28 <lambdabot> 22.0
03:16:47 <ski> above it defaulted (to Double, iirc)
03:16:51 <ski> roadkill : ok
03:17:24 <ski> @hoogle Read a => String -> Maybe a
03:17:25 <lambdabot> No matches, try a more general search
03:17:31 <ski> @hoogle Read a => String -> a
03:17:32 <lambdabot> Prelude.read :: Read a => String -> a
03:17:32 <lambdabot> Text.Read.read :: Read a => String -> a
03:17:32 <lambdabot> Data.HashTable.hashString :: String -> Int32
03:17:37 <ski> @hoogle Read a => String -> IO a
03:17:38 <lambdabot> Prelude.readIO :: Read a => String -> IO a
03:17:38 <lambdabot> System.IO.readIO :: Read a => String -> IO a
03:17:38 <lambdabot> Prelude.readLn :: Read a => IO a
03:17:44 <ski> right
03:18:01 * ski wonders why there's nothing like 'maybeRead' above
03:18:33 <roadkill> very nice bot
03:19:08 <ski> @arr
03:19:09 <lambdabot> Yeh scurvy dog...
03:19:26 <ski> @yow
03:19:27 <lambdabot> Actually, what I'd like is a little toy spaceship!!
03:19:47 <ski> @vixen how are you today ?
03:19:47 <lambdabot> i'm good, you?
03:20:02 <ski> @vixen fine, ty, reading some papers
03:20:03 <lambdabot> you're very welcome!
03:20:23 <roadkill> @vixen what's your favourite language?
03:20:24 <lambdabot> i just turned 19
03:20:27 <roadkill> lol
03:20:45 <Cale> heh, ati's nice new installer lulled me into a false sense of security. To get direct rendering, you still need to build the kernel module by hand which they silently place the tarball for into /usr/src/
03:20:49 <typhen> heh, i've never seen a well-behaved irc bot. the ones i know just insult, insult, insult.
03:22:00 <int-e> @botsnack
03:22:01 <lambdabot> :)
03:22:33 <roadkill> Cale:  some distros ship the ATI module as a package, eg ubuntu
03:23:41 <xerox> Howdy.
03:23:56 <yozora> hiya
03:25:18 <yozora> i'm curious, is there an idiomatic way of writing
03:25:36 <xerox> (I think there is)
03:25:47 <yozora> \n f g -> foldr (const f) g [1..n]
03:25:59 <xerox> map?
03:26:13 <yozora> i don't think that's quite it
03:26:17 <Cale> @pl \n f g -> foldr (const f) g [1..n]
03:26:17 <xerox> @pl \n f k -> foldr (const f) k [1..n]
03:26:17 <lambdabot> flip (flip . foldr . const) . enumFromTo 1
03:26:17 <lambdabot> flip (flip . foldr . const) . enumFromTo 1
03:26:21 <Cale> nope
03:26:22 <xerox> heh.
03:26:43 <yozora> @pl \x -> (x,x)
03:26:44 <lambdabot> join (,)
03:26:57 <yozora> :t join
03:27:01 <yozora> @type join
03:27:02 <lambdabot> Not in scope: `join'
03:27:10 <xerox> @type Control.Monad.join
03:27:12 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
03:27:12 <Cale> hey, wait a minute...
03:27:16 <yozora> @type (,)
03:27:17 <lambdabot> forall b a. a -> b -> (a, b)
03:27:17 <xerox> Cale: dang!
03:27:40 <yozora> i've never seen those before!
03:28:07 <ADEpt> @seen jlouis
03:28:08 <lambdabot> jlouis is in #haskell-blah and #haskell. Last spoke 18 hours, 24 minutes
03:28:08 <lambdabot> and 54 seconds ago.
03:28:19 <dcoutts> JaffaCake, so the ghc darcs repo at: http://cvs.haskell.org/darcs/ghc/ corresponds to cvs HEAD right?
03:28:41 <xerox> Is k unused or only it is used?
03:28:48 <JaffaCake> I'm not sure it's ready yet, but it will be HEAD yes
03:29:06 <dcoutts> ok
03:30:34 <xerox> yozora: could you please give me a sample use of that function?
03:30:42 <yozora> okay
03:30:50 <yozora> it basically applies f n times
03:30:51 <int-e> ski: lazySequenceIO = foldM (\r -> unsafeInterleaveIO . fmap . (:r)) []   ... of course it's a fold!
03:31:00 <yozora> f (f (f g)))
03:31:09 <yozora> the time i used it was to create unit vectors
03:31:20 <Cale> the list elements are ignored
03:31:32 <yozora> it's only used to number the applications of f
03:31:32 <xerox> @type iterate
03:31:33 <lambdabot> forall a. (a -> a) -> a -> [a]
03:31:45 <Cale> you probably want iterate
03:31:59 <yozora> > iterate (+1) 0
03:32:00 <xerox> @type \n -> ((!! n) .) . iterate
03:32:00 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
03:32:00 <lambdabot> 27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,
03:32:00 <lambdabot> 51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,
03:32:00 <lambdabot> 75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
03:32:00 <lambdabot> 99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
03:32:02 <lambdabot> [24 @more lines]
03:32:04 <lambdabot> forall a. Int -> (a -> a) -> a -> a
03:32:04 <yozora> oops
03:32:08 <xerox> @type \n -> ((!! n) .) . iterate
03:32:09 <lambdabot> forall a. Int -> (a -> a) -> a -> a
03:32:17 <int-e> > iterate (*5) 1 !! 5
03:32:18 <lambdabot> 3125
03:32:26 <int-e> > 5^5
03:32:28 <lambdabot> 3125
03:33:07 * xerox got pointlessy style by hand!
03:33:52 <typhen> trying to make an imperative-style void function -- hugs spits it back at me though. first 2 lines are:
03:33:52 <typhen> playStep :: Board -> ()
03:33:53 <typhen> playStep board = do
03:34:20 <typhen> what's the problem with this?
03:34:20 <int-e> @pl \n -> ((!! n) .) . iterate
03:34:21 <lambdabot> (. iterate) . (.) . flip (!!)
03:34:32 <xerox> int-e: too much :)
03:34:38 <Cale> typhen: the do block is empty
03:34:39 <int-e> xerox: I agree.
03:34:57 <Cale> playStep :: Board -> IO ()
03:35:03 <int-e> . (.) . ...
03:35:04 <Cale> playStep = return ()
03:35:10 <typhen> how about if it's followed by:
03:35:11 <typhen>     getLine = a
03:35:11 <typhen>     board2 = doPlayerMove board (read a)
03:35:20 <xerox> @type \f g -> f . (.) . g
03:35:21 <lambdabot> forall c b c1 a a1.
03:35:21 <lambdabot> (((a -> b) -> a -> c1) -> c) -> (a1 -> b -> c1) -> a1 -> c
03:35:24 <Cale> also invalid :)
03:35:24 <xerox> Bah.
03:35:34 <yozora> > let ii = \n f g -> foldr (const f) g [1..n] in (\m -> ii m (\l->1:(replicate (length l) 0):(map (0:) l)) []) 2
03:35:35 <Cale> typhen: perhaps:
03:35:35 <lambdabot>  add an instance declaration for (Num [a])
03:35:40 <Cale>   a <- getLine
03:35:50 <Cale>   board2 <- doPlayerMove board (read a)
03:35:53 <xerox>   line <- getLine
03:35:53 <xerox>   newBoard <- doPlayerMove board (read line)
03:36:04 <int-e> hmm.
03:36:08 <int-e> @type (.(.).)
03:36:09 <xerox> yozora: urgh?
03:36:09 <lambdabot> parse error on input `)'
03:36:19 <int-e> @type (.((.).))
03:36:20 <lambdabot> forall b c a a1 c1.
03:36:20 <lambdabot> ((a1 -> (a -> b) -> a -> c) -> c1) -> (a1 -> b -> c) -> c1
03:36:24 <xerox> Same thing?
03:36:29 <int-e> @type (.((.)).)
03:36:30 <lambdabot> parse error on input `)'
03:36:35 <yozora> yeah, i was trying to do that unitvector function on one line off by heart
03:36:38 <int-e> @type ((.(.)).)
03:36:39 <lambdabot> forall b c a c1 a1.
03:36:39 <lambdabot> (a1 -> ((a -> b) -> a -> c) -> c1) -> a1 -> (b -> c) -> c1
03:36:44 <yozora> @type let ii = \n f g -> foldr (const f) g [1..n] in (\m -> ii m (\l->1:(replicate (length l) 0):(map (0:) l)) [])
03:36:45 <lambdabot> forall a a1. (Enum a, Num a, Num [a1], Num a1) => a -> [[a1]]
03:37:25 * joelr1 gently prods JaffaCake
03:37:34 <yozora> @type let ii = \n f g -> foldr (const f) g [1..n] in (\m -> ii m (\l->1:(replicate (length l) 0):(map (0:) l)) []) 0
03:37:35 <lambdabot> forall a. (Num [a], Num a) => [[a]]
03:37:43 <yozora> > let ii = \n f g -> foldr (const f) g [1..n] in (\m -> ii m (\l->1:(replicate (length l) 0):(map (0:) l)) []) 0
03:37:44 <lambdabot>  add an instance declaration for (Num [a])
03:37:50 <yozora> > let ii = \n f g -> foldr (const f) g [1..n] in (\m -> ii m (\l->1:(replicate (length l) 0):(map (0:) l)) []) (0::Int)
03:37:50 <lambdabot>  add an instance declaration for (Num [a])
03:37:59 <JaffaCake> joelr1: hi there
03:38:06 <yozora> > let ii = \n f g -> foldr (const f) g [1..n] in (\m -> ii m (\l->(1:(replicate (length l) 0)):(map (0:) l)) []) 2
03:38:07 <lambdabot> [[1,0],[0,1]]
03:38:14 <yozora> > let ii = \n f g -> foldr (const f) g [1..n] in (\m -> ii m (\l->(1:(replicate (length l) 0)):(map (0:) l)) []) 3
03:38:14 <typhen> ah okay, it's true, the <- are required in lieu of =
03:38:15 <lambdabot> [[1,0,0],[0,1,0],[0,0,1]]
03:38:22 <xerox> (yozora: you can use lambdabot privately too)
03:38:26 <yozora> sorry
03:38:29 <joelr1> JaffaCake: howdy! ghc failed to build yesterday, i sent you an email re that
03:38:30 <xerox> No problem.
03:38:39 <yozora> would iterate work there i wonder
03:38:52 <yozora> i did it first with recursion
03:38:56 <xerox> What's the purpose of that function?
03:39:00 <JaffaCake> joelr1: I'm trying to get the repro set up on my home machine, it's a more familiar environment and has a faster link, so hopefully I'll be able to make better progress
03:39:03 <yozora> generates unit vectors
03:39:13 <yozora> in n dimensions
03:39:16 <boegel|home> @seen astrolabe
03:39:17 <lambdabot> astrolabe is in #haskell-overflow, #haskell-blah and #haskell. Last spoke
03:39:17 <lambdabot> 12 hours, 11 minutes and 6 seconds ago.
03:39:23 <boegel|home> astrolabe: ping!
03:39:36 <yozora> i read that hofs are preferable to recursion so i tried to rewrite it
03:39:43 <joelr1> JaffaCake: cool, thanks. how come your home machine is a freebsd one? i
03:39:45 <xerox> yozora: that's quite simple I think
03:40:04 <yozora> ?
03:40:05 <JaffaCake> joelr1: I always had a soft spot for FreeBSD :)
03:40:15 <joelr1> JaffaCake: interesting...
03:40:24 <Cale> > (\n -> [replicate i 0 ++ 1 : replicate (n-i-1) 0 | i <- [0..n-1]]) 3
03:40:25 <lambdabot> [[1,0,0],[0,1,0],[0,0,1]]
03:40:32 <Cale> that's a bit clearer perhaps
03:41:16 <yozora> append is bad for efficiency, though, right?
03:41:25 <xerox> > let insert x xs = [(x:xs)] ++ [y:zs | (y:ys) <- return xs, zs <- insert x ys] in insert 1 [0,0]
03:41:26 <lambdabot> [[1,0,0],[0,1,0],[0,0,1]]
03:41:28 <Cale> um, there's only 2 appends there
03:41:36 * xerox prods ski
03:41:51 <Cale> per vector, and it's really not so bad for efficiency
03:42:22 <Cale> The only time ++ is bad for efficiency is when you are doing lots of small concatenations to the end of a list
03:42:36 <xerox> Second time in two days :-)
03:42:40 <Cale> yeah
03:42:58 <yozora> am i the second person to bleat about append?
03:43:00 <Cale> otherwise, ++ is just fine
03:43:02 <Cale> yeah
03:43:04 <typhen> my whole program looks like it's gonna be made of do blocks. Am I correct in my guess that tic-tac-toe is a crappy program to try first?
03:43:36 <typhen> it seems like i'll just have to make everything imperative
03:43:55 <Cale> typhen: well, shouldn't be that bad. If everything is imperative, you're doing something wrong.
03:44:02 <dcoutts> typhen, ideally most of the program is not imperative
03:44:04 <Cale> You should only be doing IO in IO.
03:44:24 <dcoutts> one can usually split the IO part of the program out
03:44:31 <typhen> only doing IO in IO?
03:44:31 <dcoutts> and use pure functions for most of it
03:44:38 <xerox> Don't you like insert? :)
03:46:55 <yozora> i'm going to be wilful and say i still like the ex-recusive version :)
03:47:00 <typhen> what do you guys mean about splitting the IO part out?
03:47:13 <yozora> i like that you can pull out recursion into a hof
03:47:36 <Cale> > (\k -> map (sequence (replicate k [0,1]) !!) (map (2^) [0..k-1])) 4
03:47:37 <lambdabot> [[0,0,0,1],[0,0,1,0],[0,1,0,0],[1,0,0,0]]
03:47:49 <xerox> :-)
03:48:02 <yozora> @type sequence
03:48:03 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
03:48:09 <dcoutts> typhen, probably the only bits that need to be in 'do' form is the interactive prompt loop
03:48:18 <Cale> > sequence (replicate 3 [0,1])
03:48:19 <xerox> What do you think about giving @type "T .." ?
03:48:19 <lambdabot> [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
03:48:25 <dcoutts> typhen, all the other game calculations are pure
03:48:29 <xerox> Cale: that is fun.
03:48:47 <yozora> that is pretty cool, whatever it is
03:49:07 <typhen> dcoutts, so i call all IO from main then?
03:49:09 <Cale> sequence in the list monad is a sort of Cartesian product.
03:49:12 <yozora> is sequence transposing the lists?
03:49:23 <yozora> sequence [[1,2], [3,4]]
03:49:26 <yozora> > sequence [[1,2], [3,4]]
03:49:27 <lambdabot> [[1,3],[1,4],[2,3],[2,4]]
03:49:31 <Cale> it picks one element from each of the lists in each possible way
03:49:39 <yozora> that is convenient
03:49:53 <xerox> > sequence [[1], [0,0]]
03:49:54 <dcoutts> typhen, well you've probably got a function that main calls that then calls itself. But probably yes appart from main and that other one, everything else can be pure.
03:49:55 <lambdabot> [[1,0],[1,0]]
03:50:00 <xerox> > sequence [[1], [0,0,0]]
03:50:01 <lambdabot> [[1,0],[1,0],[1,0]]
03:50:07 <Cale> heh
03:50:11 <xerox> :-D
03:50:22 <yozora> i think xerox wins the prize :)
03:50:30 <typhen> dcoutts, okay, that's doable
03:51:03 <yozora> oh wait that was cale
03:51:09 <xerox> Indeed.
03:51:20 <yozora> > map (2^) [0..3]
03:51:21 <lambdabot> [1,2,4,8]
03:51:53 <yozora> so you grab these indices from the list of all combinations
03:52:11 <xerox> > nub (sequence [[1,1],[0,0],[0,0]]) ++ nub (sequence [[0,0],[1,1],[0,0]]) ++ nub (sequence [[0,0],[0,0],[1,1]])
03:52:13 <lambdabot> [[1,0,0],[0,1,0],[0,0,1]]
03:52:25 <xerox> > head (sequence [[1,1],[0,0],[0,0]]) ++ head (sequence [[0,0],[1,1],[0,0]]) ++ head (sequence [[0,0],[0,0],[1,1]])
03:52:26 <lambdabot> [1,0,0,0,1,0,0,0,1]
03:52:29 <yozora> @type nub
03:52:29 <Cale> (\k -> map (sequence (sequence [replicate k 0,[1]]) !!) (map (2^) [0..k-1])) 4
03:52:30 <lambdabot> Not in scope: `nub'
03:52:31 <Cale> > (\k -> map (sequence (sequence [replicate k 0,[1]]) !!) (map (2^) [0..k-1])) 4
03:52:32 <xerox> Err, whatever :)
03:52:32 <lambdabot> [[0,0,0,1],[0,0,1,0],[0,1,0,0],[1,0,0,0]]
03:52:35 <yozora> @type Data.List.nub
03:52:36 <lambdabot> forall a. (Eq a) => [a] -> [a]
03:52:46 <yozora> num [1,2,3,1,2,3,4,3]
03:52:59 <yozora> > nub [1,2,3,1,2,3,4,3]
03:53:00 <lambdabot> [1,2,3,4]
03:53:07 <xerox> > nub $ repeat 1
03:53:12 <lambdabot> Terminated
03:53:15 * xerox ducks
03:53:17 <yozora> :)
03:53:40 <xerox> Would it possible in any language to have "nub $ repeat 1" evaluate to [1] ?
03:54:09 <Cale> yeah, but you get to write the compiler for that language
03:54:32 <xerox> What does that answer hide, too ? :)
03:54:42 <Cale> I mean, obviously, we, as humans, can figure out that the nub of that list is [1]
03:55:04 <Cale> I suppose that if you get to change the implementation of nub, it's perhaps not so bad
03:55:23 <dblhelix> well, a very specific program analysis can find that out too, of course
03:55:23 <typhen> what happens if you call a function and none of the versions of that function accept the arguments? such as
03:55:24 <typhen> doComputerMove (0:tail) = (1:tail) 
03:55:24 <typhen> doComputerMove (n:tail) = doComputerMove(tail)
03:55:27 <Cale> you'd need the ability to compare pointer equality
03:55:40 <typhen> if we pass an empty list, does the program just die?
03:55:42 <Cale> dblhelix: right
03:55:43 <xerox> I mean, if function application worked somehow differently, you could get the informations needed to accomplish that goal.  I think.
03:55:56 <dblhelix> typhen: you get an error, yes
03:56:08 <Cale> typhen: an exception is thrown
03:56:15 <typhen> can i catch it?
03:56:18 <xerox> Like if you could pattern-match on functions; coalgebraic datatypes?
03:56:18 <dblhelix> typhen: unexhausitive pattern match
03:56:19 <Cale> in the IO monad
03:56:49 <Cale> but you probably are better off either filling that case in, or using the Maybe type
03:57:09 <dblhelix> @eval head []
03:57:09 <lambdabot> Add a type signature
03:57:19 <dblhelix> @eval head [] :: Int
03:57:20 <lambdabot> Prelude.head: empty list
03:57:39 <dblhelix> head _ = error "Prelude.head: empty list"
03:57:46 <xerox> head [] = ..
03:57:47 <dblhelix> just an example
03:57:55 <Cale> typhen: why not something like doComputerMove [] = [] ?
03:58:58 <typhen> Cale: hmm better example is for doPlayerMove. if the player puts in a 4, but slot 4's already taken, i want to change flow
03:59:06 <typhen> and make them put in another number
03:59:26 <dblhelix> perhaps Maybe is more appropriate there
03:59:30 <dblhelix> or CPS
03:59:34 <typhen> instead of what normally happens -- doComputerMove
03:59:35 <Cale> yeah, use the Maybe type
03:59:46 <typhen> what's a Maybe?
03:59:56 <dblhelix> data Maybe a = Nothing | Just a
04:00:29 <Cale> @type Just "Hello"
04:00:30 <lambdabot> Maybe [Char]
04:00:34 <Cale> @type Nothing
04:00:34 <lambdabot> forall a. Maybe a
04:00:44 <int-e> @type map Just "Hello"
04:00:45 <lambdabot> [Maybe Char]
04:01:08 <Cale> fmap (+1) (Just 6)
04:01:11 <Cale> > fmap (+1) (Just 6)
04:01:12 <lambdabot> Just 7
04:01:16 <dblhelix> let myhead [] = Nothing ; myhead (a : as) = Just a in (myhead [], myhead [1 ..])
04:01:20 <Cale> > fmap (+1) Nothing
04:01:21 <lambdabot> Nothing
04:01:28 <dblhelix> @eval let myhead [] = Nothing ; myhead (a : as) = Just a in (myhead [], myhead [1 ..])
04:01:29 <lambdabot> Add a type signature
04:01:54 <typhen> Cale: does that map to something I know from C? Looks like returning a pointer (that may or may not be null)?
04:02:04 <Saulzar_> Hmm, is there some way to combine the result of a function with another function? eg. I have  foo :: a -> b -> c -> d         and a function bar :: d -> e -> f, is there some way to make a -> b -> c -> d -> e -> f  without re-wrapping all the arguments?
04:02:11 <dblhelix> @eval let myhead [] = Nothing ; myhead (a : as) = Just a in (myhead [], myhead "foo")
04:02:11 <lambdabot> Add a type signature
04:02:12 <Cale> typhen: somewhat like that, only not horrible :)
04:02:28 <typhen> cale: :-)
04:03:04 <typhen> Cale: What do I do with the Maybe then? Do a case on the Maybe that comes out of doPlayerMove?
04:03:05 <Cale> Saulzar: do you perhaps mean a -> b -> c -> e -> f ?
04:03:10 <dblhelix> Saulzar: not sure if that makes sense
04:03:20 <ski> xerox : ?
04:03:21 <Cale> typhen: yeah
04:03:22 <Saulzar_> Cale, Ah yes
04:04:31 <dblhelix> barAfterFoo a b c e = flip bar e . foo a b c
04:04:44 <dblhelix> not what you're looking for?
04:06:16 <Cale> dblhelix: that looks right to me
04:06:18 <ski> @type let (.::) = (.) . (.) . (.) in \(foo,bar) -> bar .:: foo
04:06:19 <lambdabot> forall b c a a1 a2.
04:06:19 <lambdabot> (a -> a1 -> a2 -> b, b -> c) -> a -> a1 -> a2 -> c
04:06:35 <xerox> You think so?
04:06:38 <Saulzar_> Yes while that is entirely possible, adding the arguments clutters things a little .. I was just thinking there may be a more consise way
04:06:48 <dblhelix> :)
04:06:53 <ski> Saulzar : how about that way ?
04:07:04 <xerox> It misses an argument
04:07:05 <dblhelix> @pl flip bar e . foo a b c
04:07:06 <lambdabot> flip bar e . foo a b c
04:07:23 <xerox> @pl \a b c e -> flip g e . f a b c
04:07:24 <lambdabot> ((flip ((.) . flip g) .) .) . f
04:07:27 <dblhelix> @pl \a b c e -> flip bar e . foo a b c
04:07:27 <lambdabot> ((flip ((.) . flip bar) .) .) . foo
04:07:28 <Cale> xerox: not really, since c is arbitrary
04:07:28 <ski> @type let (.::) = (.) . (.) . (.) in \(foo,bar :: x -> y -> z) -> bar .:: foo
04:07:29 <lambdabot> forall y z b a a1 a2.
04:07:29 <lambdabot> (a -> a1 -> a2 -> b, b -> y -> z) -> a -> a1 -> a2 -> y -> z
04:07:36 <xerox> Cale: ah-uhm.
04:07:40 <Saulzar_> ski, Now by brain is spinning :)
04:07:41 <ski> xerox : satisfied ?
04:07:50 <Cale> hehe
04:07:52 <xerox> Sorry :(
04:08:17 <Cale> agh! too many function parameters!
04:08:18 <Cale> hehe
04:08:19 <dblhelix> @pl \foo bar -> ((flip ((.) . flip bar) .) .) . foo
04:08:20 <lambdabot> flip ((.) . (.) . (.) . flip . ((.) .) . flip)
04:08:35 * dblhelix grins
04:08:46 <dblhelix> I'd go for the cluttered one
04:08:52 <Cale> Saulzar: you're better off using let and writing something pointful
04:08:57 <xerox> AH, I got it.
04:09:05 <Saulzar_> I think so, yes :)
04:09:06 <int-e> @pl (\x -> x x) (\x -> x x)
04:09:18 <xerox> Boom?
04:09:19 <lambdabot> ap id id (ap id id)
04:09:19 <lambdabot> optimization suspended, use @pl-resume to continue.
04:09:30 <xerox> Phew.
04:09:31 <int-e> ah, it has a timeout :)
04:09:36 <int-e> phew indeed.
04:09:56 <int-e> @index ap
04:09:57 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
04:09:57 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
04:09:57 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
04:09:57 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
04:09:57 <Cale> that's especially telling, as (\x -> x x) doesn't have a type
04:10:08 <yozora> thanks for the help guys
04:10:09 <dblhelix> ap = liftM2 ($)
04:10:38 <Cale> and it's being used there in the reader monad
04:10:54 <Cale> (the kind which isn't wrapped in a newtype)
04:11:13 <int-e> @index liftM2
04:11:14 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
04:11:14 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
04:11:14 <lambdabot> Control.Monad.Error, Control.Monad.List
04:11:16 <dblhelix> @eval Just id `ap` Just "foo"
04:11:17 <lambdabot> Just "foo"
04:11:24 <int-e> @type Control.Monad.liftM2 id
04:11:25 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
04:11:32 <dblhelix> @eval Just succ `ap` Just 3
04:11:33 <lambdabot> Just 4
04:11:41 <dblhelix> @eval Just succ `ap` Nothing
04:11:42 <lambdabot> Add a type signature
04:12:00 <Cale> > return (+1) `ap` [1,2,3]
04:12:02 <lambdabot> [2,3,4]
04:12:03 <dblhelix> @eval Just succ `ap (Nothing :: Maybe Int)
04:12:04 <lambdabot>  parse error on input `('
04:12:09 <xerox> No I dont, hmpf.
04:12:18 <dblhelix> @eval Just succ `ap` (Nothing :: Maybe Int)
04:12:20 <lambdabot> Nothing
04:12:59 <ski> \x -> x x :: forall a. _a where _a = _a -> a
04:12:59 <Cale> > [(+10),(+20)] `ap` [1,2,3]
04:13:00 <lambdabot> [11,12,13,21,22,23]
04:13:11 <xerox> @pl \f g a b c e -> g (f a b c) e
04:13:11 <lambdabot> flip ((.) . (.) . (.))
04:13:14 <xerox> Ah!
04:13:18 <Cale> of course, that's just liftM
04:13:21 <xerox> @pl \g f a b c e -> g (f a b c) e
04:13:21 <lambdabot> (.) . (.) . (.)
04:13:25 <xerox> That's how you find it.
04:13:27 <Cale> using return
04:13:45 <ski> (xerox : no .. i derived it myself, by hand, some years ago ..)
04:13:54 <xerox> That's how you find it nowadays.
04:14:00 <ski> hehe, ok :)
04:14:10 <dblhelix> @type let fix f = f (fix f) in fix
04:14:11 <lambdabot> forall t. (t -> t) -> t
04:14:19 <Cale> I love that type
04:14:33 <Cale> (t -> t) -> t
04:14:37 <dcoutts> JaffaCake, I think I mentioned this before: if I cooked up the patch, would you mind adding a feature to allow a package to specify an alternative libs list to use when using the ghci dynamic linker rather than the native linker.
04:14:52 <JaffaCake> sure
04:14:57 <ski> # let u t = t t;;
04:14:57 <ski> val u : ('a -> 'b as 'a) -> 'b = <fun>
04:15:08 <dcoutts> JaffaCake, This would allow us to work around cases like ghci not understanding gnu ld scripts and the probelm for Gtk2Hs on windows where the .dll names to not match the .a names.
04:15:09 <JaffaCake> I remember you asked for it before, it's been on my todo list
04:15:20 * xerox wonders more Haskell poetry
04:15:25 <dblhelix> @eval let fix f = f (fix f); fac = \f n -> if n == 0 then 1 else n * f (n -1) in fac 7
04:15:26 <lambdabot>  add an instance declaration for (Num (a -> a))
04:15:41 <dcoutts> JaffaCake, I'm about to send a patch that shows more precicely what I mean, it's not a full patch.
04:15:42 <ski> you forgot the fix
04:15:55 <JaffaCake> dcoutts: ok
04:15:58 <xerox> Heh, why = let me = fix in fix . me
04:16:08 <dblhelix> @eval let fix f = f (fix f); fac = fix (\f n -> if n == 0 then 1 else n * f (n -1)) in fac 7
04:16:09 <lambdabot> 5040
04:16:18 <dblhelix> descriptive error message :)
04:16:37 <xerox> I got a very nice one.
04:16:39 <ski> @type let why = let me = fix in fix . me in why
04:16:39 <lambdabot> Not in scope: `fix'
04:16:39 <lambdabot>  
04:16:39 <lambdabot> <interactive>:1:26: Not in scope: `fix'
04:16:51 <xerox> to = {- be -} or [not to {- be -}]
04:16:52 <int-e> let Nothing = Just Nothing in 42
04:17:05 <triplah> haha
04:17:10 <xerox> (Which is of type Bool, so it is either True or False, but it's an infinite loop, so you can't find the answer.)
04:17:35 <xerox> \o/
04:17:45 <dblhelix> xerox: nice one
04:17:49 <xerox> :-D
04:18:11 <dblhelix> @type to = or [not to]
04:18:12 <lambdabot> parse error on input `='
04:18:15 <xerox> Other people isn't open to poetry it seems :-)
04:18:25 <triplah> he = loves me or he not loves me where loves = (+)
04:18:27 <dblhelix> @type let to = or [not to] in to
04:18:28 <lambdabot> Bool
04:18:35 <xerox> :-D
04:18:46 <xerox> @type to = {- be -} or [not to {- be -}] in to
04:18:47 <lambdabot> parse error on input `='
04:18:52 <xerox> Err, whatever.
04:19:05 <int-e> let, xerox, let it=be
04:19:12 <xerox> Yeah.
04:19:23 <xerox> @type let to = {- be -} or [not to {- be -}] in to
04:19:24 <lambdabot> Bool
04:19:31 <dblhelix> @type it
04:19:32 <lambdabot> Not in scope: `it'
04:19:34 <xerox> idea.
04:19:37 <ski> let light = ...
04:19:54 <xerox> I can't find a solution for:
04:20:02 <xerox> who = let the = do {gs out} ..
04:20:20 <triplah> let me x = alone where alone = not friends where friends = \x -> x-1
04:20:59 <xerox> It should compile.. :)
04:21:29 <triplah> @type let me x = alone where alone = not friends where friends = \x -> x-1
04:21:59 <lambdabot> not an expression: `let me x = alone where alone = not friends where
04:22:01 <lambdabot> friends = \x -> x-1'
04:22:08 <triplah> boo!
04:22:12 <Cale> @type let me x = alone where alone = not friends where friends = \x -> x-1 in me
04:22:13 <lambdabot>   Expecting a function type, but found `Bool'
04:22:13 <lambdabot>   Expected type: Bool
04:22:21 <ski> 220 and 284 are friends
04:22:30 <Cale> @type let me x = alone where alone = not friends where friends = False in me
04:22:31 <lambdabot> forall t. t -> Bool
04:22:37 <xerox> ahaha
04:22:41 <triplah> nice :P
04:22:43 <int-e> false friends?
04:22:44 <xerox> Let's start a poetry page.
04:22:49 <Cale> @type let me x = alone where alone = not friends where friends = False in me 0
04:22:50 <lambdabot> Bool
04:22:58 <Cale> > let me x = alone where alone = not friends where friends = False in me 0
04:22:59 <lambdabot> True
04:23:13 <Cale> > let me x = alone where alone = not friends where friends = False in me Nothing
04:23:14 <lambdabot> True
04:23:19 <triplah> can you use data with lambdabot?
04:23:24 <xerox> triplah: nope.
04:23:24 <Cale> nope
04:23:27 <triplah> :(
04:23:30 <ski> > let decay n = sum (filter (\d -> n `mod` d == 0) [1..n-1]) in (decay 220,decay 248)
04:23:31 <lambdabot> (284,232)
04:23:32 <ADEpt> > let me be = alone where alone = not friends where friends = False in me 0
04:23:33 <lambdabot> True
04:23:35 <xerox> I also got...
04:23:36 <ski> hm
04:23:50 <ski> > let decay n = sum (filter (\d -> n `mod` d == 0) [1..n-1]) in (decay 220,decay 284)
04:23:51 <lambdabot> (284,220)
04:23:58 <xerox> see = undefined
04:23:58 <xerox> so = Just $ let me = see in map
04:24:25 <ski> (that's the first pair of 'amicable numbers' (amicable = friendly))
04:24:39 <triplah> really?
04:24:40 <ADEpt> > let me define = undefined
04:24:41 <lambdabot>  parse error on input `}'
04:25:03 <ski> > let decay n = sum (filter (\d -> n `mod` d == 0) [1..n-1]) in take 10 $ iterate decay 12496
04:25:05 <lambdabot> [12496,14288,15472,14536,14264,12496,14288,15472,14536,14264]
04:25:28 <ski> (that's the first five-cycle)
04:25:37 <int-e> ah.
04:25:45 <xerox> more poetry!
04:26:02 <triplah> ehe
04:26:39 <ski> (supposedly, in the old testament, when jacob met esau, he brought 220 cattle, to symbolize that he wanted friendship)
04:26:58 <xerox> D'oh!
04:27:03 <ski> > let decay n = sum (filter (\d -> n `mod` d == 0) [1..n-1]) in take 5 $ iterate decay 220
04:27:05 <lambdabot> [220,284,220,284,220]
04:28:29 <xerox> Lunch :-)
04:28:48 <dcoutts> JaffaCake, sent
04:29:12 <triplah> let the cat = out bag where out = \x -> if x then true else true in the 1
04:29:16 <triplah> > let the cat = out bag where out = \x -> if x then true else true in the 1
04:29:17 <lambdabot>  Not in scope: `true'
04:29:26 <triplah> whats the keyword for true?
04:29:43 <dcoutts> True
04:29:46 <dcoutts> > True
04:29:47 <lambdabot> True
04:29:52 <triplah> > let the cat = out bag where out = \x -> if x then True else True in the 1
04:29:53 <lambdabot>  Not in scope: `bag'
04:29:58 <triplah> argh :)
04:31:15 <int-e> > let decay n = sum (filter (\d -> n `mod` d == 0) [1..n-1]) in take 10 $ iterate decay 138
04:31:16 <lambdabot> [138,150,222,234,312,528,960,2088,3762,5598]
04:31:33 <triplah> > let the cat = out bag where out = (\cat -> if (fst cat) == b then True else True) in the "bag"
04:31:34 <lambdabot>  Not in scope: `b'
04:31:38 <dcoutts> > let the cat = out bag where {out = const True; bag = undefined} in the 1
04:31:39 <lambdabot> True
04:31:41 <triplah> > let the cat = out bag where out = (\cat -> if (fst cat) == 'b' then True else True) in the "bag"
04:31:42 <lambdabot>  Not in scope: `bag'
04:31:46 <triplah> eep :)
04:32:26 <triplah> i give up
04:32:27 <triplah> haha
04:32:36 <triplah> this is distracting me from my network tech assignment :D
04:32:40 <Cale> A definition is a statement of equivalence between one expression and another, usually more complex expression that gives the meaning of the first.
04:33:06 <ski> int-e : that terminates, i think
04:33:34 <ski> (iirc, they weren't sure if sequence for 276 terminated, though)
04:34:37 <int-e> ski: it certainly takes its time to terminate, if it does.
04:38:01 <ski> > let decay n = sum (filter (\d -> n `mod` d == 0) [1..n-1]) in map (take 10 . takeWhile (/= 0) . iterate decay . (2 ^)) [13..16]
04:38:03 <lambdabot> [[8192,8191,1],[16384,16383,6145,1235,445,95,25,6,6,6],[32768,32767,6145,
04:38:03 <lambdabot> 1235,445,95,25,6,6,6],[65536,65535,45921,15311,313,1]]
04:46:17 <int-e> ok, 138 take 177 steps to get to 1.
04:46:36 <int-e> and the largest intermediate value is 179931895322.
04:46:43 <ski> > let decay n = sum (filter (`divides` n) [1..n-1]); decayInvs 1 = sieve [2..]; decayInvs n = filter (\m -> decay m == n) [1..(n-1)^2]; d `divides` n = n `mod`d == 0; primes = sieve [2..]; sieve (p:ns) = p : sieve (filter (not . (p `divides`)) ns) in map decayInvs [2..10]
04:46:44 <lambdabot> [[],[4],[9],[],[6,25],[8],[10,49],[15],[14]]
04:46:51 <ski> > let decay n = sum (filter (`divides` n) [1..n-1]); decayInvs 1 = sieve [2..]; decayInvs n = filter (\m -> decay m == n) [1..(n-1)^2]; d `divides` n = n `mod`d == 0; primes = sieve [2..]; sieve (p:ns) = p : sieve (filter (not . (p `divides`)) ns) in map decayInvs [0,52]
04:46:53 <lambdabot> [[1],[]]
04:47:26 <ski> (2,5,52 is the first 3 that no numbers decay into)
04:48:39 <Speck> Is there any source code available for Henrik Nilsson's Yampa+GADT optimizations?
04:48:41 <triplah> :O
04:54:21 <xinming> (Just s) `comb` mother `comb` father `comb` father 
04:54:31 <xinming> how do I write this version in brace form?
04:55:08 <xinming> parenthesis form
04:55:35 <ski> is `comb`left associative, or right associative ?
04:56:15 <xinming> > 3-5-2
04:56:16 <lambdabot> -4
04:56:27 <xinming> maybe left associative
04:56:28 <xinming> :-)
04:57:02 <ski> do you have a declaration 'infix? ? `comb`' (with first '?' being either 'l' or 'r' and second being a number between 0 and 9)
04:57:24 <xinming> ski: I don't think so.
04:57:27 * ski tries to recall what the default associativity and precedence is
04:57:32 <xinming> I got this from an example.
04:57:35 <JaffaCake> joelr1: ping
04:57:43 <ski> possibly the default is  infixr 9 `comb`
04:57:45 <joelr1> JaffaCake: ping
04:57:46 <joelr1> pong
04:57:48 <joelr1> that i
04:57:49 <joelr1> is
04:57:51 <ski> in that case, it is
04:58:13 <JaffaCake> joelr1: it's much harder to repeat on my FreeBSD box - I had one crash, but in a different place
04:58:15 <ski> comb (Just s) (comb mother (comb father father))
04:58:20 <JaffaCake> I have a new theory though
04:58:28 <joelr1> JaffaCake: really? would you share it?
04:58:35 <xinming> ski: thanks.
04:58:45 <JaffaCake> I think it's caused by using more file descriptors than FD_SETSIZE
04:59:09 <triplah> ski: you strike me as the kind of person who wouldnt have a problem getting work
04:59:14 <JaffaCake> ghc's IO library doesn't check whether the file descriptor is larger than FD_SETSIZE when it fills in the fd_set for select()
04:59:16 <triplah> yet i swear you spend all day on irc :D
04:59:17 <joelr1> JaffaCake: hmm... think so? could well be since i'm also getting the lockFile descriptor out of range error
04:59:35 <JaffaCake> do you happen to know what FD_SETSIZE is on your box?
04:59:35 <joelr1> JaffaCake: i believe you have it hardcoded to 1024 for lockFile 
04:59:37 <joelr1> JaffaCake: but
04:59:50 <ski> triplah : hm
04:59:53 <joelr1> JaffaCake: i edited my system headers to make FD_SETSIZE 10240
04:59:56 <joelr1> lets see
05:00:21 <JaffaCake> right, and do you think it's likely that the client is crashing when it uses FDs larger than 1024?
05:00:45 <joelr1> select.h:#define        FD_SETSIZE      10240
05:00:53 <joelr1> time.h:#define  FD_SETSIZE      10240
05:01:01 <joelr1> types.h:#define FD_SETSIZE      10240
05:01:15 <JaffaCake> ok, you edited those by hand?  that's brave :)
05:01:28 <joelr1> JaffaCake: very likely since the whole point of what i'm doing is to launch more than 1024 clients
05:01:54 <joelr1> JaffaCake: i had to do it for Erlang since they were going by FD_SETSIZE as well. this is fine (the m anual edit) as the max on Mac OSX is 10240
05:02:32 <JaffaCake> we can test the theory - since you have changed FD_SETSIZE, the GHC you built yesterday will be using the new setting, so it shouldn't crash
05:02:38 <joelr1> so yes, it's probably crashing when i go past 1024 descriptors
05:02:56 <joelr1> JaffaCake: actually, the GHC on my machine should not be crashing since i had 10240 when i built it
05:03:03 <JaffaCake> oh
05:03:14 <joelr1> when you pull stuff from darwinports it builds it after applying patches
05:03:51 <joelr1> JaffaCake: could it be something hardcoded to 1024 in GHC? like with lockFile?
05:04:02 <joelr1> lockFile does not appear to use FD_SETSIZE
05:04:05 <JaffaCake> lockFile is using FD_SETSIZE, I believe
05:04:21 <joelr1> at least i do not think it does because that's what i think someone on the list told me
05:04:24 <joelr1> i could be wrong
05:04:28 <joelr1> of course
05:04:34 <JaffaCake> maybe it gets it from somewhere else?
05:04:39 <joelr1> JaffaCake: ok, i'll take your word for it
05:04:48 <JaffaCake> definitely does, I just looked at the code
05:04:48 <joelr1> but 
05:04:52 <joelr1> ok
05:04:58 <joelr1> hmm
05:05:12 <joelr1> let me see something
05:05:13 <JaffaCake> I'll log into your box again and poke around
05:05:16 <joelr1> ok
05:05:28 <joelr1> JaffaCake: i did not finish building ghc, it failed on tools and utilities
05:05:43 <joelr1> since the configure prefix was not /opt/local
05:05:57 <JaffaCake> the prefix shouldn't make any difference until you try to install
05:06:04 <JaffaCake> install isn't necessary
05:06:51 <joelr1> JaffaCake: i just typed make and it bombed out at the end since it was looking for headers or something
05:07:03 <JaffaCake> oh
05:07:06 <joelr1> JaffaCake: try finishing the build when you login
05:07:15 <joelr1> it was trying to build hs.. something
05:15:26 <xinming> > getLine >>= putStr (\x -> x ++ "\n")
05:15:27 <lambdabot>   Expecting a function type, but found `IO ()'
05:15:27 <lambdabot>   Expected type: String -> IO b
05:15:27 <lambdabot>   Inferred type: IO ()
05:15:44 <xinming> hmm, How to correct this example please?
05:16:06 <kzm> > getLine >>= \x -> putStr (x++"\n") -- ?
05:16:06 <lambdabot>  parse error (possibly incorrect indentation)
05:16:14 <kzm> > getLine >>= \x -> putStr (x++"\n")
05:16:15 <lambdabot> No IO allowed
05:16:20 <kzm> Oh well.
05:16:39 <ValarQ> > getLine >>= putStr . (\x -> x ++ "\n")
05:16:40 <lambdabot> No IO allowed
05:17:14 <xinming> thanks, I think I got it
05:17:36 <ValarQ> xinming: you know there is a putStrLn?
05:17:37 <xinming> \x -> x ++ "\n"
05:18:32 <xinming> x here is IO a type, why can it work with convert IO String -> String, But the value can't be returned ?
05:19:01 <xinming> ValarQ: Certainly I know. I just wish to try some IO Monad.
05:20:23 <kzm> If x is an IO type, then you can't (++) it to a string.
05:20:34 <kzm> @type (++)
05:20:35 <lambdabot> forall a. [a] -> [a] -> [a]
05:21:20 <ValarQ> xinming: ok :)
05:21:22 <kzm> and putStr takes a string as its argument, but you try to feed it a function (String -> String)
05:22:26 <ValarQ> getLine >>= return.(++"\n") >>= putStr -- would do the same thing :)
05:23:00 <ski> @type liftM (++ "\n")
05:23:01 <lambdabot> Not in scope: `liftM'
05:23:08 <ski> @type Control.Monad.liftM (++ "\n")
05:23:08 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char] -> m [Char]
05:23:26 <ski> @type Control.Monad.liftM (++ "\n") getLine
05:23:27 <lambdabot> IO [Char]
05:24:03 <xinming> > Control.Monad.listM (++ "\n") getLine >>= putStr
05:24:04 <lambdabot>  Not in scope: `Control.Monad.listM'
05:24:16 <xinming> is my example valid?
05:24:28 * xinming will try himself
05:24:29 <ski> > Control.Monad.liftM (++ "\n") getLine >>= putStr
05:24:30 <lambdabot> No IO allowed
05:24:38 <ski> @type Control.Monad.liftM (++ "\n") getLine >>= putStr
05:24:39 <lambdabot> IO ()
05:24:58 <xinming> works.
05:24:59 <ski> xinming : you said 'list' by mistake, instead of 'lift' ..
05:25:11 <xinming> ski: yes. a typo. ;-)
05:25:15 <ski> @type putStr =<< Control.Monad.liftM (++ "\n") getLine
05:25:16 <lambdabot> IO ()
05:25:29 <ski> @type putStr =<< fmap (++ "\n") getLine
05:25:30 <lambdabot> IO ()
05:25:46 * ValarQ takes notes
05:25:50 <ski> @type putStrLn =<< getLine
05:25:51 <lambdabot> IO ()
05:29:20 <xinming> hmm, for example. If we make a function, which will allow user to input some strings, and then, we keep them somewhere. People here ever told me that I can call this function recursively.
05:29:49 <xinming> hmm, But the problem is, I still won't be able to keep the data the user ever made
05:31:07 <xinming> hmm, How to do this in haskell?
05:32:15 <greenrd> xinming, build a list?
05:32:17 <ADEpt> xinming: if you just want "to keep user input somwhere" and will not use it, haskell will optimize such storage away, most probably
05:33:13 <ADEpt> xinming: 
05:33:13 <ADEpt> main = do
05:33:13 <ADEpt>   contents <- getContents
05:33:13 <ADEpt>   let l = lines contents
05:33:13 <ADEpt>   mapM_ putStrLn l
05:33:14 <ADEpt> Try this on some file or user input
05:33:19 <xerox> xinming :: [String] -> IO a
05:33:19 <xerox> xinming xs = do
05:33:19 <xerox>   line <- getLine
05:33:19 <xerox>   xinming (line:xs)
05:33:42 <triplah> align :: String -> String -> [(a,a),(a,a)]
05:33:48 <triplah> how would i right that properly?
05:34:05 <triplah> a function that takes two strings then returns a list of pairs
05:34:15 <xerox> triplah: what is it?, also, [(a,a),(a,a)] is not a type I think.
05:34:27 <xinming> greenrd: hmm, yes, build a list, But the problem is, the data will gone after the function is finished.
05:34:32 <triplah> xerox: its the a,a stuff i'm worried about
05:34:39 <triplah> xerox: a list of pairs
05:34:57 <triplah> each part of the pair is the same data type
05:35:01 <xerox> List of pairs; [(a,a)], pair of pairs ((a,a),(a,a))
05:35:03 <triplah> and all pairs are the same data type
05:35:20 <triplah> ok, thanks
05:35:28 <Cale> triplah: where are you going to get a value of type 'a'?
05:35:36 <triplah> Couldn't match `Char' against `(a, a)'
05:35:38 <triplah> :)
05:35:40 <triplah> nowhere apparently
05:35:44 <Cale> your function is going to need more parameters
05:35:58 <xerox> xinming: can you explain what do you want to do more comprehensively?
05:36:07 <Cale> (or a less-polymorphic type)
05:36:19 <triplah> > align "xx" "yy"
05:36:20 <lambdabot>  Not in scope: `align'
05:36:21 <triplah> [("xx","yy"),("xx-","y-y"),("x-x","yy-"),("xx-","-yy"),("xx--","--yy"),("x-x","-yy"),("x-x-","-y-y"),("x--x","-yy-"),("-xx","yy-"),("-xx","y-y"),("-xx-","y--y"),("-x-x","y-y-"),("--xx","yy--")]
05:36:31 <triplah> i need align to do that
05:36:35 <ADEpt> xinming: in a sence, all data accumulated in program will be gone after program finishes. Haskell program is a function 'main'. Does this make any sense?
05:36:41 <triplah> take two strings, then return all possible alignments of them
05:37:12 <greenrd> xinming, so return it from the function
05:37:54 <Speck> Is there any source code available for Henrik Nilsson's Yampa+GADT optimizations?
05:38:11 <joelr1> Speck: is there a paper on that? where can i find it?
05:38:35 <Speck> search for Yampa and GADT
05:38:43 <joelr1> @google yampa gadt
05:38:44 <lambdabot> http://portal.acm.org/ft_gateway.cfm?id=1086374&type=pdf
05:38:58 <joelr1> Speck: is there a non ACM version?
05:38:59 <Speck> I have an portal membership, but I bet it's available outside that
05:39:15 <joelr1> Speck: i'm not a member of the ACM :(
05:39:26 <Speck> I'm almost positive it's on Nilsson's homepage
05:39:27 <xinming> xerox: hmm, there is a example in a book, which needs a database, and the database is static into program for illustrate example, But I wonder If I have a chance to update the informations in that database.
05:40:07 <ADEpt> xinming: define 'database'. Oracle? Flat file? Something else?. Anyways, I bet it is possible to update info.
05:40:24 <joelr1> Speck: i don't think it's available, can you email me a copy?
05:40:27 <Speck> basically it uses GADTs to do optimization transformation over various properties of arrows (and properties of yampa itself) -- very neat stuff
05:40:31 <ADEpt> xinming: your program should read data from the external DB, process it, write it back. What's the problem? :)
05:40:41 <xinming> ADEpt: No, a simple database. database = [(Name, Int)]
05:40:56 <ADEpt> xinming: use flat file for that
05:41:02 <joelr1> Speck: i take it back, it _is_ available
05:41:12 <xinming> ADEpt: hmm, But I wish I can keep these information in the memory. :-/
05:41:25 <xinming> a bit hard to explain what I wish to do.
05:42:32 <ADEpt> xinming: 
05:42:32 <ADEpt> main = do
05:42:32 <ADEpt>   contents <- readFile "abc.txt"
05:42:32 <ADEpt>   let db = map (\[a,b] -> (read a, b)) $ map words $ lines contents
05:42:32 <ADEpt>   let db' = process db
05:42:33 <ADEpt>   putStrLn $ show db'
05:42:44 <Speck> too bad it seems like frp is losing mindshare in the functional programming community :-(
05:42:49 <ADEpt> xinming: here 'db' is your 'storage in memory'
05:43:23 <joelr1> Speck: i don't necessarily think so. not after the Frag which is based on the Yampa Arcade
05:43:30 <xinming> ADEpt: So, If you add an entry, Do I have to write the information into file first, and reload it again?
05:43:31 <joelr1> @google Frag
05:43:31 <lambdabot> http://www.gotfrag.com/
05:43:34 <joelr1> nope
05:44:02 <Speck> joelr1: yeah I saw that :-) I was thinking it would be a great testbed for optimizations in Yampa
05:44:11 <ADEpt> xinming: i dont get that. who adds entry? program? external human being? when? how it correlates with your program execution? ....
05:44:31 <joelr1> Speck: http://haskell.org/hawiki/Frag
05:45:14 <xinming> ADEpt: hmm, Just like, a program which will ask user for existing command, and there is a command named add which will add an entry into database. :-)
05:45:26 <ADEpt> xinming: suppose that you have desired program written in your favorite language (C? :) What would be the answer to your question?
05:45:45 <ADEpt> xinming: ah, i see
05:47:04 <xinming> ADEpt: Do we have to add the entry into file first, and reload the file again in haskell?
05:47:16 <ADEpt> xinming: of course not
05:47:44 <xinming> then the performance will be a big issue
05:48:34 <ADEpt> xinming: just like in any other language, you would read command from user, execute it, it would modify sdome data ....
05:48:55 <ADEpt> xinming: why the performance will be an issue?
05:48:59 <xinming> ADEpt: yes.
05:49:22 <xinming> ADEpt: because, If the program will write to the file everytime a new entry is added.
05:49:47 <ADEpt> xinming: once again, program should not have to da that
05:49:54 <Speck> would Oleg's zipper by useful? (albeit overkill?)
05:49:57 <Mamut> Hi all. I am very sorry to interrupt the conversation between ADEpt and xinming, but on the following two questions depends my entire interest in Haskell :)
05:50:46 <joelr1> JaffaCake: any further insight?
05:51:12 <ADEpt> xinming: 'process' from my example could read and process commands, modify db, and pass it back to itself recursively
05:51:20 <Mamut> Can one bind callback functions froma C/C++ library with Haskell (say, by using HaskellDirect)? And does Haskell handle Unicode well? Thank you!
05:51:34 <ADEpt> Mamut: yes and yes
05:51:50 <Speck> :-)
05:52:46 <Mamut> ADEpt, thank you! I am still interested in Haskell :)
05:53:19 <ADEpt> xinming: observe:
05:53:19 <ADEpt> process db =
05:53:19 <ADEpt>   cmd <- getLine
05:53:19 <ADEpt>   let db' = case cmd of
05:53:19 <ADEpt>               "add" -> (123,"456"):db
05:53:20 <ADEpt>               "delete" -> tail db
05:53:22 <ADEpt>   process db'
05:53:31 <xinming> ADEpt: thanks, found learning haskell is a bigger challenge to me than learning English. :-/
05:55:29 <ADEpt> xinming: so, as you can see, by 'modify' i mean 'produce modified copy and throw out old one'
05:55:58 <musasabi> unicode support is not that good, but Chars support the full range of unicode characters.
05:56:40 <ADEpt> musasabi: i would say unicode I/O support is not that good.
05:56:59 <ADEpt> @seen SamB
05:56:59 <lambdabot> SamB is in #haskell-blah, #haskell-overflow and #haskell. Last spoke 7
05:56:59 <lambdabot> hours, 26 minutes and 29 seconds ago.
05:57:05 <ADEpt> @seen jlouis
05:57:05 <lambdabot> jlouis is in #haskell-blah and #haskell. Last spoke 20 hours, 53 minutes
05:57:05 <lambdabot> and 51 seconds ago.
05:57:16 <xerox> @type lookup
05:57:17 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
05:58:11 <xerox> insert = (:) -- in some sense, without checking for dups
06:00:04 <Mamut> musasabi, ADEpt... Hmmm... Suppose I want to send and receive Unicode data across a network and store it in a database. I'd like to use Haskell to implement the logic and some C libraries for netork communication. I know it's doable. : ) However, I am not sure how Haskell will work with Unicode in this case...
06:00:31 <musasabi> ADEpt: yes, and that is an essential part of it. But then again no language does that particularly well.
06:01:17 <musasabi> Mamut: you want a function to decode the octets depending on your transfer encoding.
06:01:53 <ADEpt> Mamut: that is, you want it implemented outside of haskell
06:02:42 <ADEpt> musasabi: " ... But then again no language does that particularly well" - i wholeheartedly agree. That's why I consider current support as "good" one :)
06:02:51 <xerox> perl6?
06:02:57 <int-e> ski: 276 is no fun - after 488 steps the result is a 50 digits number ... and pollard rho factorization is getting slow.
06:03:18 <xerox> pugs> 1,2,3  1,2,3
06:03:18 <xerox> (1, 1, 2, 2, 3, 3)
06:04:16 <musasabi> xerox: the real problems are datastreams with data in multiple encodings maybe containing a few errors.
06:04:47 <xerox> pugs> (1..10) * (1..10)
06:04:48 <xerox> (1, 4, 9, 16, 25, 36, 49, 64, 81, 100)
06:05:09 <Mamut> ADEpt: hmmm... I figured that would be the case... But that's a workaround anyway. Thank you!
06:05:18 <xerox> musasabi: what about a 'sanely enough' fall-back mechanisms?
06:05:33 <xerox> pugs> [+] 1..10
06:05:33 <xerox> 55
06:05:34 <xerox> ihih.
06:05:45 <xinming> what does ihih mean please xerox ?
06:05:48 <xinming> :-?
06:05:52 <xerox> xinming: little lough.
06:06:03 <xerox> laugh, sorry :-9
06:06:07 <xerox> I can't type today!
06:06:08 <xinming> xerox: thanks.
06:06:10 <musasabi> xerox: I think a sane fallback mechanism is just leaving the octets alone.
06:06:36 <xerox> musasabi: someone should try to Unicode-ify GHC :-\
06:06:54 <xinming> hmm, getLine >>= putStr
06:07:05 <xerox> [1..10]  [1..10]
06:07:15 <SamB> ADEpt: looking for me?
06:07:25 <xerox> xinming: what about it?
06:07:29 <xinming> since getLine will return IO String, But putStr accpets String as a parameter, How does this be done?
06:07:39 <xerox> xinming: check the (>>=) type.
06:07:43 <xerox> @type (>>=)
06:07:44 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
06:07:59 <xerox> Substitute 'IO' for 'm'.
06:07:59 <xinming> :-)
06:08:01 <musasabi> xerox: well there is the NewIO framework for instance.
06:08:10 <xinming> a -> IO b
06:08:11 <xerox> musasabi: uh?  What is it?
06:08:11 <xinming> thanks.
06:08:18 <xerox> xinming: you're welcome!
06:08:54 <musasabi> xerox: http://www.haskell.org/~simonmar/io/System.IO.html
06:09:13 <ADEpt> SamB: maybe :)
06:09:27 <ADEpt> SamB: wanted to say that I (almost) fixed that bug
06:09:41 <xerox> musasabi: ah, it works on Arrays of Words.
06:09:46 <musasabi> I think one problem was that the type of a charset decoding function was not agreed upon.
06:11:06 <xerox> Why so?
06:11:32 <musasabi> "[Word8] -> IO ([Char],[Word8],Maybe EncodingError)" seems required and that is more complex than most people like.
06:12:00 <xerox> Ah, exceptions aren't enough?
06:12:09 <SamB> so?
06:12:16 <tuomov> hmm.. I think decoding could be outside IO
06:12:20 <SamB> wouldn't that mostly be wrapped up in libraries?
06:12:23 <tuomov> should
06:12:31 <musasabi> xerox: Exceptions make it hard to substitute decoding errors with blank characters.
06:12:44 <xerox> I see.  Also, why is it in IO?
06:12:55 <SamB> hmm
06:13:08 <musasabi> xerox: bacause it will most probably need to load files from disk etc
06:13:15 <musasabi> of course one could use unsafePerformIO
06:13:16 <SamB> okay...
06:13:32 <musasabi> So we would have "[Word8] -> ([Char],[Word8],Maybe EncodingError)"
06:13:54 <tuomov> one could have loadRecoder :: Encoding -> Encoding -> IO Decoder
06:13:59 <xerox> ...to efficiently do it in the function instead of relying on the return value of some getFoo ?
06:14:02 <tuomov> s/R/D/
06:14:04 <tuomov> or something like that
06:14:15 <musasabi> tuomov: yes, that could take the IO part away.
06:14:27 <musasabi> but the type is still quite non-trivial.
06:14:51 <musasabi> of course one could have a convenience interface like:
06:15:09 <musasabi> convert :: ([Word8] -> ([Char],[Word8],Maybe EncodingError)) -> [Word8] -> [Char]
06:15:38 <SamB> (almost) the whole point of standardizing the interface is to have convenient wrappers, isn't it?
06:15:50 <SamB> also, we would call
06:15:52 <SamB> [Word8] -> ([Char],[Word8],Maybe EncodingError)
06:15:56 <SamB> Decoder
06:16:37 <musasabi> But is that efficient? (and good if people are moving into the direction of FastStrings)
06:17:01 <JaffaCake> joelr1: this time, I think I really know what it is :)
06:17:14 <xerox> I'd mostly like a not-verbose interface than then a Very Fast one, but then..
06:17:16 <joelr1> JaffaCake: what, what?
06:17:23 <joelr1> tell me, tell me!
06:17:26 <roconnor> Can I have more than one module in a file?
06:17:31 <xerox> roconnor: I think not.
06:17:36 <JaffaCake> joelr1: Network.BSD.getHostByName isn't thread-safe
06:17:36 <musasabi> roconnor: not with GHC at least.
06:17:50 <tuomov> type Decoder = [Word8] -> [Either Char EncodingError]
06:17:55 <roconnor> http://www.haskell.org/onlinereport/modules.html seems to imply otherwise
06:18:01 <JaffaCake> it calls gethostbyname() underneath, which returns a pointer to static data
06:18:07 <SamB> roconnor: seriously?
06:18:10 <roconnor> well
06:18:11 <xerox> tuomov: nice
06:18:14 <tuomov> or possibly something a bit more complicated
06:18:20 <roconnor> It says: For exmaple, here is a three-module program
06:18:28 <JaffaCake> but the static data is overwritten by subsequent calls, possibly before the first call has read it all out
06:18:37 <SamB> anyways, GHC insists on a straightforward mapping from module names to file paths
06:18:42 <roconnor> I mean, it doesn't really talk about files.
06:18:47 <SamB> except for Main
06:18:56 <tuomov> type Decoder = [Word8] -> EncodingResult; data EncodingResult = ERChar c EncodingResult | ERError ErrorType RestOfInput
06:19:02 <roconnor> oh
06:19:03 <musasabi> JaffaCake: I have working address resolution which works with threaded in network-alt if you are interested.
06:19:12 <tuomov> | ERNili
06:19:13 <tuomov> -i
06:19:17 <SamB> jhc does too, only it doesn't insist on such a simpleminded mapping
06:19:24 <JaffaCake> musasabi: sounds cool, where do I get it?
06:19:35 <SamB> that is to say, you can use dots instead of slashes if you don't want all those directories
06:19:42 <JaffaCake> what do you use, getnameinfo()?
06:19:52 <roconnor> That is a good reason.
06:20:08 <roconnor> But I sort of wanted to distribute my Haskell program in one file.
06:20:09 * SamB wonders why almost everyone else is dark blue
06:20:19 <roconnor> Seems reasonable.
06:20:20 <SamB> roconnor: well, you can do that.
06:20:24 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/network-alt/network-alt/Network/Alt/Resolver.hsc or  http://www.cs.helsinki.fi/u/ekarttun/network-alt for the whole thing.
06:20:32 <SamB> and have the user paste it into three files
06:20:46 <SamB> or you could distribute it in MIME format
06:20:47 <roconnor> I suppose it is easy for people to split my file into modules.
06:20:53 <musasabi> JaffaCake: depends on the platform (I have autoconf magic to detect the correct one for different platforms)
06:21:02 <SamB> or you could uuencode, but thats just silly
06:21:26 <roconnor> ... To be more precice I'm trying to place my haskell program into an appendix of my article.
06:21:40 <SamB> ah
06:21:47 <SamB> TMR article?
06:21:51 <roconnor> So I figured I'd say Appendix A, and they list a bunch of modules.
06:21:52 <musasabi> Basically I have 1) getAddrInfo, 2) gethostname on the platforms that don't support it, 3) an optional lock (#ifdeffed) because both of them may not be threadsafe on certain platforms.
06:21:57 <roconnor> TMR?
06:22:02 <SamB> roconnor: what is it for?
06:22:05 <xerox> roconnor: what format does this article have?
06:22:09 <SamB> what publication?
06:22:22 <SamB> TMR = The Monad.Reader
06:22:26 <Pita> Every month i check back here, this channel keeps growing
06:22:26 <roconnor> I am going to submit it to mathematical structures in computer science.
06:22:28 <Pita> wonder where all the new people come from
06:22:37 <SamB> Pita: perhaps #perl6 ?
06:22:39 <JaffaCake> musasabi: sounds like you've done all the hard work
06:22:47 <roconnor> Ah, sorry, not the monad reader I'm afraid.
06:23:04 <Pita> what's a good haskell editor on osx
06:23:04 <JaffaCake> I don't want to repeat that, but I need something that works
06:23:14 <SamB> roconnor: I figured you would know that TMR was The Monad.Reader if you were actually writing an article for it ;-)
06:23:26 <roconnor> ;-)
06:23:31 <Mamut> Pita: some come long ways from www.rsdn.ru -> functional programming forum -> haskell -> haskell channel
06:23:40 <SamB> anyways, I was going to advise you to use a tarball like everyone else if you were ;-)
06:23:54 <Pita> i am liking lisp a lot now . came from java
06:24:00 <Pita> wonder if i will now like haskell if i like lisp
06:24:06 <roconnor> yea, My code is maaaaaaaaybe short enough to stick in as text.
06:24:44 <SamB> okay, so, this is going to be in postscript/print form than?
06:24:49 <JaffaCake> musasabi:  You don't have permission to access /u/ekarttun/network-alt/doc/ on this server.
06:25:08 <joelr1> JaffaCake: 83.51.137.26
06:25:11 <joelr1> power outage :(
06:25:23 <SamB> then yes, just go ahead and use multiple modules and ignore the issue of files entirely
06:25:39 <joelr1> JaffaCake: last thing i heard from you was that getHostByName is not thread-safe
06:25:47 <JaffaCake> joelr1: s'ok, now I know what the problem is, it's just a case of fixing it
06:25:48 <joelr1> which explains both stack traces, i suppose
06:25:52 <xerox> joelr1: check the logs?
06:25:59 <joelr1> xerox: logs aren't quick
06:26:18 <SamB> I mean, thats what people tend to do in *e-mails*, so surely its fine in academic papers
06:26:20 <joelr1> JaffaCake: can I fix it myself or is there a workaround?
06:26:23 <JaffaCake> joelr1: yes, I followed the Haskell stack a bit further back, and it originated in getHostByName
06:26:36 <SamB> JaffaCake: how do you follow the stack?
06:26:44 <SamB> GDB is no good at it
06:26:49 <JaffaCake> you need to put a lock around getHostByName, and anything that calls it; eg connectTo
06:27:10 <JaffaCake> that might not be a good solution for you, I doin't know
06:27:11 <joelr1> JaffaCake: ok, great. how do you do that?
06:27:13 <roconnor> SamB, sounds reasonable.
06:27:25 <joelr1> JaffaCake: and how do you follow the stack further back?
06:27:40 <SamB> JaffaCake: is getHostByName going to continue in this way?
06:27:59 <JaffaCake> joelr1: create an MVar, and call connectTo like this:  withMVar m $ connectTo ...
06:28:18 <JaffaCake> SamB: I'm going to fix it, somehow
06:28:23 <joelr1> JaffaCake: ok, thansk
06:28:36 <SamB> JaffaCake: when is this an issue?
06:28:44 <JaffaCake> joelr1: to follow the Haskell stack further back, you need to examine memory from r22 (the Haskell stack pointer)
06:28:54 <SamB> i.e., what flags do you need to compile with for it to be a problem? any?
06:28:56 <JaffaCake> I have some gdb macros in ~backup/.gdbinit
06:29:06 <SamB> JaffaCake: ooh, macros!
06:29:07 <musasabi> JaffaCake: fixed.
06:29:20 <joelr1> JaffaCake: thanks!
06:29:24 <musasabi> was a Cabal bug preventing autobuild of documentation :-(
06:29:46 <JaffaCake> musasabi: oops
06:29:54 * SamB is thinking of Conjure and how it uses threads everywhere
06:30:18 <musasabi> (the haddock command does not read .buildinfo files which have -DCALLCONV=ccall - thus parse errors in when running runghc Setup.hs haddock)
06:30:49 <JaffaCake> musasabi: short term, I need to fix Network.BSD to be thread-safe, longer term we should look at redesigning Network and your Network.Alt
06:30:53 <ADEpt> SamB: rather how it uses only 1 thread now, but plans to have threads everywhere :)
06:31:12 <joelr1> JaffaCake: so r22 is a function that is the haskell stack trace?
06:31:14 <SamB> ADEpt: your point being?
06:31:21 <SamB> anyway, are you sure about that?
06:31:26 <JaffaCake> joelr1: you might just want to try out musasabi's Network.Alt package
06:31:46 <JaffaCake> joelr1: r22 is a register, pointing to the top of the Haskell stack
06:31:59 <ADEpt> SamB: my point is that threads are there, but Main does not make use of them all ;)
06:32:02 <joelr1> JaffaCake: ah, ok. but that's on PowerPC only, right?
06:32:03 <musasabi> JaffaCake: I could make a patch to Network.BSD to make it safe, I think I will have it ready by the weekend.
06:32:17 <JaffaCake> joelr1: right, on x86 it's $ebp
06:32:35 <JaffaCake> musasabi: that's fantastic, thanks!
06:32:39 <SamB> ADEpt: well, conjure is a bittorrent client too, but you don't see it downloading torrents do you?
06:32:55 <joelr1> JaffaCake: i think i will just stick to regular networking for now and go with the MVar. it needs to be a global MVar, right?
06:33:17 <JaffaCake> doesn't have to be global, depends how inconvenient it is to pass around
06:33:24 <joelr1> ok
06:33:59 <JaffaCake> Network.BSD was written in the dark ages before threads, I guess nobody noticed it was broken :(
06:34:32 <ADEpt> SamB: yep. Basically, my comment was triggered by you using word 'uses', that's it.
06:34:35 <joelr1> JaffaCake: thank you very much!
06:34:46 <JaffaCake> joelr1: you're very welcome, that's a good bug
06:34:51 <SamB> ADEpt: I just ran it like
06:34:58 <SamB> % ./conjure +RTS -Ds -RTS pjlester-1.11.tar.Z.torrent
06:35:04 <SamB> and I saw four threads at a time
06:35:09 <joelr1> JaffaCake: just you wait ;) i got another one with putStrLn printing out garbage ;)
06:35:28 <ADEpt> SamB: 1 is main, 1 is peer thread, and two are created and not used.
06:35:35 <SamB> well, okay.
06:35:42 <SamB> so maybe it doesn't use many yet.
06:35:46 <joelr1> JaffaCake: i'll let you know as soon as it shows up. should not be long
06:35:56 <SamB> but you said it used *one*
06:36:31 <JaffaCake> joelr1: sure it's not the same one?  printing out a host name might yield garbage with this bug
06:36:47 <joelr1> JaffaCake: i'm not printing out the host name, though
06:36:55 <JaffaCake> ok
06:37:13 <ADEpt> SamB: yep. *one* besides main it is :)
06:38:12 <SamB> @hoogle labelThread
06:38:13 <lambdabot> GHC.Conc.labelThread :: ThreadId -> String -> IO ()
06:38:18 <SamB> ADEpt: thats two!
06:38:29 <ADEpt> SamB: anyway. nextPiece is broken so no torrents for now :)
06:41:00 <SamB> ADEpt: what would you call a function to fork a thread and give it a name (for debugging purposes)?
06:41:16 <musasabi> joelr1: try to add a mvar to the host resolution too.
06:41:30 <joelr1> musasabi: where's that?
06:41:41 <joelr1> musasabi: i just call connecTo, i do no separate host resolution
06:41:48 <ADEpt> SamB: forkNamedIO ?
06:42:07 <joelr1> musasabi: how is Network.Alt better?
06:42:09 <ADEpt> SamB: namedForkIO?
06:42:11 <SamB> hmm, I was thinking forkLabeledIO
06:42:19 <musasabi> joelr1: getHostByName
06:42:26 <ADEpt> SamB: even better! 
06:42:36 <joelr1> musasabi: wouldn't a single lock around connectTo suffice?
06:42:48 <musasabi> joelr1: that should do it also.
06:43:00 <SamB> I was thinking that 'cause the function to label a thread is called labelThread...
06:43:09 <xerox> Cale: do you have firefox 1.5?
06:43:30 <musasabi> joelr1: well e.g. adding kqueue support to network-alt should take less than a day ;)
06:43:37 <musasabi> and it supports threaded operations fine.
06:43:41 <joelr1> musasabi: ah
06:43:48 <joelr1> @google Network.Alt
06:43:49 <lambdabot> http://www.otan.us/webfarm/alt/home.html
06:43:51 <pmurias> are there UUAG syntax files for vim?
06:44:02 <ADEpt> @type labelThread
06:44:03 <joelr1> musasabi: where's that?
06:44:03 <lambdabot> Not in scope: `labelThread'
06:44:20 <ADEpt> @seen jlouis
06:44:21 <lambdabot> jlouis is in #haskell-blah and #haskell. Last spoke 21 hours, 41 minutes
06:44:21 <lambdabot> and 7 seconds ago.
06:44:25 <musasabi> then again there is less testing on various platforms (but it works fine on all the ones I have had testers)
06:45:00 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/network-alt/
06:45:54 <joelr1> musasabi: cool. and you have your own getHostByName?
06:46:34 <SamB> ADEpt: use @hoogle or @index
06:46:45 <ADEpt> @index labelThread
06:46:45 <lambdabot> GHC.Conc
06:47:00 <ADEpt> @hoogle labelThread
06:47:01 <lambdabot> GHC.Conc.labelThread :: ThreadId -> String -> IO ()
06:47:08 <musasabi> getAddrInfo on those platforms which support it (+ mutex on the platforms on which it is not threadsafe), gethostbyname + mutex on the platforms which don't support it.
06:47:25 <ADEpt> SamB: just curious: what you will test?
06:47:33 <joelr1> musasabi: but i'm using ghc built-in threads, will your mutex work with them?
06:47:40 <musasabi> of course.
06:47:44 <joelr1> ok
06:47:52 <SamB> ADEpt: hmm?
06:48:06 <musasabi> But -threaded makes sense.
06:48:10 <shapr> jiihaa
06:48:26 <SamB> okay, so maybe this function is actually not just for debugging ;-)
06:48:26 <joelr1> musasabi: i already run with -threaded as suggested by simon
06:48:45 <ADEpt> SamB: "... to fork a thread and give it a name (for debugging purposes)?" Ah, for debugging. Sorry, my mistake.
06:48:48 <musasabi> yep, there is no standard asynchronous api for name resolution.
06:48:54 <musasabi> thus -threaded is needed.
06:48:58 <SamB> ADEpt: you do have a point
06:53:00 <JaffaCake> musasabi: if you were thinking of adding kqueue support, it would be better to add it to GHC.Conc so all  I/O can benefit from it
06:55:33 <musasabi> JaffaCake: I suspect it is the same as epoll - it needs a different definition of filehandle, and that is invasive.
06:56:42 <musasabi> e.g. for epoll one has to define sockets to be data Socket = Socket !Int !(MVar [MVar ()]) !(MVar [MVar ()]) !(StablePtr Socket)
06:58:20 <JaffaCake> musasabi:  http://www.freebsd.org/cgi/man.cgi?query=kqueue&apropos=0&sektion=0&manpath=FreeBSD+6.0-RELEASE+and+Ports&format=html
06:58:26 <JaffaCake> it uses file descriptors, I think
06:59:27 <musasabi> JaffaCake: yes, so does epoll, the trick is that if the mechanism is event (not level) triggered, then having multiple parallel readers/writers complicates things.
07:00:40 <musasabi> basically one gets a notification when a socket is readable/writable and then no notifications until the socket is first empty and then again readable.
07:01:10 <JaffaCake> I see
07:02:01 <musasabi> Thus if the interface returns that a fd can be read all the the blocking calls have to retry, until they start to block.
07:02:40 <JaffaCake> is that problematic?
07:02:43 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/network-alt/network-alt/Network/Alt/impl/epoll.hsc has the implementation - I think kqueue will be very much like that.
07:05:23 <JaffaCake> ok, it's similar to what I imagined, but you don't have to change the type of Socket
07:05:54 <musasabi> As an unrelated note "make hc-file-bundle Project=Ghc" fails for me on missing hc files which appear to be differently named, and some are cmm instead of .hc - with GHC 6.4.1 sources.
07:06:03 <JaffaCake> you could use an interface much like that in GHC.Conc, where a thread that needs to block registers itself with the I/O manager, and then blocks on an MVar
07:06:34 <musasabi> JaffaCake: except there is a race condition there.
07:07:09 <JaffaCake> oh, you mean if the event triggers while the thread is registering itself?
07:07:33 <musasabi> JaffaCake: 1) thread receives EAGAIN, 2) io manager gets a "can be read" event for that fd, 3) the thread registers itself with the io manager, 4) there will be no wakeup ever.
07:08:02 <JaffaCake> riiight
07:08:13 * JaffaCake thinks
07:09:07 <musasabi> network-alt does 1) thread takes the read/write queue of this fd, 2) thread gets EAGAIN, 3) io manager gets "can be read", 4) io manager blocks on the MVar of the fd, 5) the thread has added it to the wait list and gives up the mvar, 6) the io-manager gets the mvar and wakes the thread up
07:20:46 <lome> hi! is there constraint programming lib in haskell?
07:24:41 <shapr> lome: I think so. I've seen at least one embedding of prolog in Haskell.
07:25:35 <shapr> For example - http://lambda-the-ultimate.org/node/view/112
07:27:08 * shapr hOps
07:27:18 <xerox> Oops!
07:29:12 <lome> shapr: thx! it's fantastic!
07:31:41 <Pita> hmm
07:31:57 <shapr> Pita: flatbread!
07:31:58 <JaffaCake> musasabi: did you consider using epoll() in level-triggered mode?  that would avoid your race condition (though, probably kqueue() can't be used that way)
07:33:04 <SamB> oooh, -xc looks like a sweet RTS option
07:35:00 <musasabi> JaffaCake: yes, but that was quite a bit slower.
07:35:32 <JaffaCake> interesting.. any idea why it was slower?
07:35:34 <shapr> y0 phys
07:35:37 <musasabi> and there is very rarely contention on the MVar as simultaneous readers are rare.
07:35:38 <phys_rules> hey guys
07:35:50 <phys_rules> I have ghc 6.4.1 unregistered up and running on solarix 86 =)
07:35:56 <phys_rules> err, solaris x86 :)
07:36:19 <phys_rules> hey shapr :)
07:36:39 <shapr> phys_rules: spiffy! post about it to ghc-users?
07:37:26 <phys_rules> I'm not subscribed to any lists yet, should do it, would be nice if you could post it for me
07:37:38 <JaffaCake> phys_rules: congratulations :)
07:37:56 <phys_rules> JaffaCake: did a total rebuild from 0 on windows, this time on cygwin, not on mingw
07:38:39 <phys_rules> and it seems even if I was doing "touch" on the config files they still got replaced :)
07:38:48 <phys_rules> so I just made them read-only ;)
07:39:08 <phys_rules> and had to tweak cygwin's includes a little
07:40:01 <JaffaCake> phys_rules: yes, this problem was reported on the list a while back... I tweaked the docs (but I don't think the new docs are uploaded yet)
07:40:05 <musasabi> Also in the level triggered case one has to worry about "can I insert this fd into epoll or is it inserted yet" (or add a weak Map of handlers inside epoll)
07:41:33 <JaffaCake> musasabi: true, that doesn't matter with select()
07:42:12 <musasabi> I think it could be done, but the ET implementation works quite nicely too...
07:42:59 <JaffaCake> it could be incorporated into the Handle implementation without too much difficulty
07:43:35 <JaffaCake> we already have an MVar around each read/write side of a Handle, we'd just need to add the queue
07:44:29 <musasabi> and probably detect at runtime which implementation to use (since it is in base)
07:44:43 <musasabi> since not all linux machines support epoll (to make things more fun)
07:45:04 <JaffaCake> yes, that's annoying
07:45:54 <shapr> Ohh! Is GHC in darcs now??
07:46:08 * shapr just noticed dcoutts_ submitted a darcs patch to ghc-users
07:46:19 <JaffaCake> ask CosmicRay
07:47:29 <JaffaCake> looks like it is done now
07:47:35 <shapr> pitui: Cute nickname, learning Haskell? Have questions?
07:48:48 <pitui> shapr: yeah, just learning, i've plenty to read before questions ...thanks
07:49:03 <shapr> pitui: I can give you the short tour of #haskell and Haskell if you wish.
07:49:10 <shapr> If not, feel free to ask questions when you get them.
07:50:33 <shapr> boegel: Top Ten TMR article?
07:50:53 <shapr> Who else is working on a TMR article that they may be able to have done by tomorrow?
07:51:20 <shapr> I'd like to publish an issue tomorrow, especially because a GHC-SMP article should be sooner rather than later.
07:53:18 <shapr> greetz Lokadin 
07:53:30 <shapr> Let's see... who can I hit up for a TMR article?
07:53:56 <shapr> Cale: Laziness article for tomorrow?
07:54:36 <shapr> SamB: Want to write an article on monads or parsec that has a good 'gee whiz' factor?
07:55:00 <SamB> shapr: sure
07:55:41 <SamB> you are referring to ShortExamples/BFInterpreter in some way?
07:56:11 <ADEpt> shapr: I can tell how I converted 30K+ parser from JavaCC to parsec using only search and replace, and it worked :)
07:56:26 <shapr> SamB: However did you guess? :-)
07:56:29 <shapr> ADEpt: ooh yes!
07:56:30 <ADEpt> BTW, perchance author(s) of CryptoLib for haskell are here?
07:56:43 <shapr> I've never seen Dominic Steinitz here.
07:56:55 <SamB> shapr: you said "'gee whiz' factor" ;-)
07:57:00 <shapr> Fractal contributed some of the software in the CryptoLib though.
07:57:05 <SamB> shapr: I need to walk the dog right now
07:57:10 <ADEpt> shapr: I even mused to write semu-converter from JavaCC syntax to parsec ...
07:57:35 <xerox> Fractal?
07:57:41 <shapr> @seen Fractal
07:57:41 <lambdabot> I haven't seen Fractal.
07:57:45 <shapr> hmm
07:57:52 <shapr> SamB: k
07:58:06 <ADEpt> shapr: i wrote ASN.1 parser sometime ago, and cryptolib has nice ber encoder/decoder. I though about combining the two to obtain ASN.1 compiler for haskell.
07:58:24 <shapr> oh good idea!
07:58:33 <shapr> Question is, what can you write by tomorrow? :-)
07:58:48 <SamB> shapr: email me to remind me
07:59:38 <ADEpt> shapr: no :)
07:59:45 <shapr> heh, ok
08:00:02 * ADEpt is off to kill some co-workers
08:14:33 <kosmikus> @pl \x -> r (\a -> m (a x))
08:14:33 <lambdabot> r . (m .) . flip id
08:14:52 <kosmikus> @pl r (\a -> m (a x))
08:14:53 <lambdabot> r (m . ($ x))
08:22:17 <basti_> Hi guys. Problem: I got a list of STM TVars representing resource. I'm atomically (but concurrently) checking a random set of them for "being free", and if such a set is found, I'd "allocate them" and later free them again
08:22:52 <basti_> now i do that in several threads (like 30), and every thread is started, some finish their job, and a few stay standing, blankly looking at the unoccupied resources
08:23:06 <dcoutts_> musasabi, you know epoll can be either level or edge triggered right
08:24:09 <musasabi> dcoutts_: yes, I tried them both out.
08:24:28 <basti_> arrgggghghhhhhh
08:24:30 * basti_ stoopid
08:24:34 * basti_ SO SO SO stoopid
08:24:41 <basti_> >.<
08:25:35 <basti_> "nub"
08:25:54 <xerox> n00b
08:26:38 <basti_> n0 i forgot "nub"
08:26:42 <xerox> ;-)
08:26:44 <basti_> u sp33k l33t?
08:27:04 <xerox> @elite just in case.
08:27:05 <lambdabot> Jus7 iN (4ze.
08:27:09 <dcoutts_> musasabi, ok. Which seems the better approach?
08:27:57 <musasabi> ET had better performance.
08:28:17 <musasabi> I could dig up the old sources and add a LT implementation for benchmarking.
08:28:25 <basti_> ^ 4r13|) 40 /\||0cA4t3 T3H s4/\/\3 R350UR(3 tW|C3
08:28:45 <basti_> (by forgetting "nub")
08:28:57 <xerox> Ick.
08:29:03 <dcoutts_> musasabi, but the semantics for both are workable? I got the impression that edge triggered was rather tricky.
08:29:16 <basti_> its just virtual resources ^^ but still they didnt allow me to get allocated twice
08:29:55 <musasabi> dcoutts_: getting the semantics right for ET was tricky, but after I got it done it has worked very neatly.
08:31:21 <dcoutts_> musasabi, excelent. Well done.
08:31:41 <dcoutts_> musasabi, I've often wondered about using epoll for the ghc rts.
08:32:54 <musasabi> dcoutts_: the problem with epoll and the rts is that one really wants a different Handle definition with epoll
08:33:20 <dcoutts_> oh, why is that?
08:33:33 <musasabi> dcoutts_: LT will use a Map Fd [BlockedWaiters] with frequent modifications (and maybe 10k elements)...
08:34:21 <musasabi> dcoutts_: ET will want to use a handle implementation with two lists behind an MVar (for read- and writeblocking)
08:35:39 <Oejet> basti_: How can you forget No doUBlets?
08:36:32 <basti_> Oejet: ...
08:37:20 <dcoutts_> musasabi, so it's a bit difficult to have a pluggable IO manager, eg posix select, linux epoll, bsd kpoll, win32 etc
08:37:36 <dcoutts_> musasabi, the other interesting one of course might be to take advantage of async IO features, however I don't think that async IO necesarily performes much better than normal IO on most OSs.
08:39:48 <eivuokko> I think Windows has pretty big diffrence on that..
08:40:03 <dcoutts_> eivuokko, you mean it's faster?
08:40:11 <eivuokko> Yeah.
08:40:15 <dcoutts_> I thought it just used extra threads in the background
08:40:22 <musasabi> dcoutts_: async IO is not supported natively on most linux hosts.
08:40:24 <dcoutts_> which one could have done anyway
08:40:33 <musasabi> dcoutts_: and even there it is not supported for sockets.
08:40:58 <dcoutts_> musasabi, yeah, it's still pretty patchy on linux, but apparently it's expected to improve
08:41:24 <musasabi> dcoutts_: yes, but the API has still some glitches.
08:41:28 <dcoutts_> musasabi, it started with just O_DIRECT files, and it'll get ordinary buffered files soonish I hear
08:41:40 <musasabi> dcoutts_: it was not designed to work together with threads...
08:42:08 <dcoutts_> musasabi, so currently the glibc implementation of the posic async IO api just uses threads.
08:42:08 <musasabi> of course all AIO implementations offer some extension to make that work...
08:42:28 <musasabi> dcoutts_: yes, and is most likely slower than GHC.
08:42:33 <dcoutts_> musasabi, indeed
08:42:57 <dcoutts_> which is why there'd be no performance advantage 'til the kernel gets it done properly
08:43:41 <musasabi> and the aio_select is just like poll - with all the same disadvantages.
08:43:42 <dcoutts_> but when it does it should allow the kernel to oprimise your IO requests because you can have several outstanding at once
08:44:13 <musasabi> dcoutts_: but as the Haskell side has synchronous IO requests that is not much help.
08:44:26 <musasabi> as we have to wait for the IO to be complete
08:44:30 <dcoutts_> musasabi, that's not essential
08:44:40 <dcoutts_> the requests come in serially
08:44:48 <dcoutts_> but the responses don't have to do they?
08:44:54 <musasabi> nope
08:44:55 <dcoutts_> if they come from different threads
08:45:39 <SamB> hmm, it looks like Brian Rice is looking for new hosting for the Slate project...
08:45:45 <musasabi> and we can either 1) tie down one OS thread per requests (for completion notification), 2) use aio_select which is O(number of requests), 3) use extensions not in the standard. iirc
08:46:05 <dcoutts_> musasabi, yeah the aio handles would need to work with epoll to be really usable
08:46:25 <musasabi> true
08:46:50 <dcoutts_> so the aio possabilites are still a few years off it looks like, on linux at least.
08:47:34 <musasabi> dcoutts_: a more evil way would be to provide multiple shared libraries and link with the correct one depending on system IO capabilities (when GHC has shared lib support)
08:48:03 <SamB> evil?
08:48:07 <SamB> thats evil now?
08:48:30 * SamB thought it was accepted practice
08:49:07 <musasabi> SamB: it makes for fun things when you try to copy all libraries needed to a chroot ;)
08:49:27 <SamB> musasabi: I suppose so
08:50:19 <SamB> I notice a directory called /lib/tls
08:50:47 <SamB> which has an additional libpthread.so.0
08:51:28 <araujo> Hello Haskell'ers!
08:52:14 <musasabi> JaffaCake: Would the multiple shared libs be a possible way to go after GHC has support for shared libs?
08:53:12 <JaffaCake> yes, it's a possibiliy
08:53:51 <JaffaCake> we'd want to try to separate the IO library as much as possible from the rest of base, though
08:54:12 <musasabi> makes sense
09:17:40 <SamB> shapr: do you think I should actually write the article based on that program?
09:18:29 <shapr> Sure, any Haskell related subject that you want.
09:20:33 <kosmikus> @index unsafeCoerce
09:20:34 <lambdabot> bzzt
09:20:41 <kosmikus> @hoogle unsafeCoerce
09:20:42 <lambdabot> No matches found
09:20:43 <Igloo> @index unsafeCoerce#
09:20:44 <lambdabot> bzzt
09:20:53 <Igloo> @type GHC.Exts.unsafeCoerce#
09:20:54 <lambdabot> forall b a. a -> b
09:20:57 <kosmikus> thanks
09:21:01 <SamB> should I go through a long process by which I gradually arrive at this program (or a similar one), or should I just go through the program and explain what everything does?
09:21:08 <Igloo> np
09:21:13 <kosmikus> Igloo: why the #?
09:22:04 <Igloo> You can apply it to 5#, unlike id
09:22:37 <shapr> SamB: I'd prefer the long process. That way people will learn patterns they can use themselves.
09:22:58 <Igloo> I'm not sure what the exact rule is, but I suspect that's why it applies in this case  :-)
09:23:03 <SamB> of course, this will be entirely a retcon
09:23:40 <SamB> but I suppose it doesn't make any sense to start where I am when trying to bring people there ;-)
09:25:22 <SamB> this will of course involve many intermediate versions of the code...
09:26:09 <SamB> how shall I ensure that the code in the article is actually the same as the code that will run?
09:26:46 <Igloo> Don't suppose anyone has any docs on Debianising cabal packages?
09:27:12 * SamB doesn't either
09:27:24 <SamB> what package did you have in mind?
09:27:43 <Igloo> Various of my own
09:27:58 <SamB> ah
09:28:29 <shapr> I think CosmicRay had some code to automatically convert cabal packages into debs.
09:28:31 <shapr> Not sure about that.
09:28:33 <SamB> its got to be a lot trickier than debianizing a Python extension...
09:28:48 <Igloo> Why's that?
09:29:37 <shapr> SamB: You don't need to detail all the changes. The best information is where you hit a rough spot that changed your design or implementation significantly.
09:29:39 <SamB> well, Python keeps an ABI over a major.minor version
09:29:57 <SamB> shapr: rough spot?
09:30:05 <Igloo> That doesn't make it harder, just means you need to rebuild it more frequently
09:30:33 <SamB> well, okay.
09:30:38 <shapr> An imperative programmer will read your article and try to understand the mindset needed to write Haskell.
09:31:04 <shapr> An inexperienced Haskell programmer will look for deeper patterns along the same lines.
09:31:22 <SamB> shapr: did you send me an email?
09:31:29 <shapr> not yet :-)
09:31:37 <SamB> ah
09:31:39 <SamB> good
09:31:52 <SamB> I was afraid gmail had dropped it ;-)
09:32:52 <shapr> Sent now
09:35:15 <shapr> I very much wish for an article showing the benefits of laziness.
09:35:19 <shapr> Maybe I should write it myself.
09:36:43 * xerox cheers up for that
09:38:00 <shapr> I have a strong urge to rewrite the PhoneNumber ( http://www.haskell.org/hawiki/PhoneNumber ) program using laziness and suffix trees to get a speedier implementation.
09:38:03 <SamB> well, one of my favorites is stuff like "zip [1..] xs"
09:38:21 <SamB> also lists as iterators
09:38:26 <SamB> well thats the same thing really
09:43:23 <mentomorph> HI! How can I fix it when GHC says: `>>=` is not a (visible) method of class `Monad`.
09:43:49 <SamB> mentomorph: well, that means that you don't have >>= in scope for somer reason
09:44:07 <SamB> mentomorph: have you by any chance hid it?
09:44:20 <xerox> import Control.Monad ?
09:44:25 <xerox> @index (>>=)
09:44:26 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
09:44:26 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
09:44:26 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
09:44:35 <xerox> ...or import the Prelude it seems ;-)
09:45:56 <mentomorph> Well I dont think I've hidden it. I wrote type CIO a = Inp -> Out and instance Monad CIO where io >>= f = code
09:46:34 <xerox> (You need -fglasgow-exts to do that, too)
09:46:43 <xerox> Hmm, dunno, in fact.
09:47:17 <mentomorph> It can also say that synonym CIO should have 1 argument, but has been given 0 when I fiddle with idents.
09:47:35 <SamB> xerox: you can import the Prelude all you want
09:47:39 <samx_> i'm trying to figure out how to do anything useful with Control.Monad.Fix.fix. As far as I understand, it should allow some kind of 'while' type semantics, but I'm just not 'getting it'
09:47:53 <SamB> its just that if you don't, you get it imported as if by "import Prelude"
09:48:28 <mentomorph> oh samB. sorry. I've hidden it yes... sorry thx
09:48:32 <mentomorph> tiered
09:48:32 <SamB> shapr: I didn't get it
09:48:36 <SamB> mentomorph: hehe
09:52:01 <samx_> can someone please give an example of the use of it :-)
09:53:12 <SamB> shapr: okay, so I've sent you a reply
09:53:48 <shapr> Foo, I googled for a SuffixTree implementation in Haskell... and found one in ScannedInAvian.org/~shae :-|
09:53:49 <liyang> samx_: fix (\fib -> 1 : 1 : zipWith (+) fib (tail fib))
09:53:59 <xerox> > let fix f = f (fix f); fac = fix (\f n -> if n == 0 then 1 else n * f (n -1)) in fac 7
09:54:00 <lambdabot> 5040
09:54:23 <liyang> > take 10 $ fix (\fib -> 1 : 1 : zipWith (+) fib (tail fib))
09:54:25 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
09:56:13 <arguile> Heh, for a second I had flashbacks of the "Evolution of a Functional Programmer"
09:56:44 <SamB> arguile: how is that different from "Evolution of a Haskell Programmer"?
09:57:08 <arguile> Probably the same thing and I messed up the title
09:57:19 <SamB> ah
09:57:23 <SamB> I thought maybe ;-)
09:57:40 <Igloo> @index fix
09:57:43 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.
09:57:43 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.
09:57:43 <lambdabot> Error
09:57:53 * arguile shudders to imagine a LISP version of that page
09:57:54 <SamB> well actually :-(, because I would have liked to look at it
09:58:00 <Igloo> Strange
09:58:25 <SamB> arguile: I think the lisp programmer would probably not go through such extremes
09:59:09 <SamB> and the lisp programmer would be more likely to be doing "Hello, World" than factorials or the fibonocci sequence
09:59:30 <SamB> shapr: answer my query!
10:02:11 <musasabi> Does anyone have a FreeBSD GHC .tar.gz handy?
10:02:11 * SamB wonders off and waits for shapr to answer his email
10:02:45 <SamB> musasabi: isn't there a FreeBSD binary package for that?
10:04:21 <musasabi> found it.
10:04:32 <musasabi> it was not in the ghc-6.4.1 dir..
10:04:51 <xerox> The harder the funnier
10:05:45 <SamB> musasabi: oh, you actually want an up-to-date copy?
10:06:15 * SamB thought musasabi just needed something to build GHC with
10:07:40 <musasabi> mmh, that does not like me very much (I am building under DragonFly)
10:07:59 <musasabi> Unrecognized platform: i386-unkown-freebsd
10:08:10 <musasabi> (configure dies with that)
10:08:31 <SamB> hmm, apparantly the guy who did dragonfly doesn't like the FreeBSD developers and they don't like him either
10:08:33 <neologism> using pkgsrc?
10:09:55 <musasabi> mmg fixed
10:10:24 <musasabi> --build=i386-unknown-freebsd5 worked
10:13:04 <musasabi> mmh, but that is compatible with FreeBSD5, now to find a FreeBSD4 GHC...
10:13:34 <d99mary> Hi, does anybody know if threading don't work while using function system to execute console-commands?
10:14:02 <SamB> d99mary: basicly it won't
10:14:12 <SamB> I mean, you could use -threaded, but that has issues
10:14:18 <d99mary> have tried using forkIO but it seems to block further progress of my haskell program until the console-one is done
10:15:01 <SamB> well, it actually depends how you do it
10:15:11 <d99mary> k
10:15:22 <samx_> I think I'm getting 'fix' now.. Basically, it's recursion thorugh a higher order function, but instead of needing a symbol defined, the recursed value is passed as the parameter. Right? :-)
10:15:27 <SamB> if you grab a copy of hmp3 you can look at the popen function in there
10:15:51 <SamB> that will allow you to run a program and read its output without blocking yours...
10:16:19 <SamB> give it input, too
10:16:34 <SamB> @where mp3
10:16:35 <lambdabot> I know nothing about mp3.
10:16:40 <SamB> @where jmp3
10:16:40 <lambdabot> I know nothing about jmp3.
10:16:42 <SamB> @where hhmp3
10:16:42 <lambdabot> I know nothing about hhmp3.
10:16:44 <SamB> @where hmp3
10:16:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3
10:16:47 <SamB> arg
10:16:52 <SamB> too many typos!
10:17:17 <SamB> anyway, you can darcs get that and take a look...
10:17:31 <d99mary> downloading now
10:26:40 <SamB> my copy has been running mpg321 for 16:59 (hh:mm)
10:29:23 <SamB> d99mary: got it yet?
10:30:47 <SamB> anyway, it looks like popen is in Utils.hs at the moment
10:31:32 <d99mary> great was searching for it :D
10:33:22 <Igloo> How do you stop cabal using --auto-ghci-libs again?
10:35:30 <SamB> d99mary: you might also be interested in trying out hmp3 itself
10:35:57 <SamB> I think its only a couple of weeks old, but it works pretty well
10:37:10 <Igloo> Hmm, doesn't seem to be possible in 6.4.1. *sigh*.
10:38:01 <SamB> Igloo: for the purpose of working on ghci-less arches, or to save time/space?
10:38:51 <Igloo> To not go behind the packaging system's back
10:39:27 <SamB> hmm?
10:39:58 <Igloo> I don't want my packages to go around creating files without the package manager knowing at install time
10:40:26 <SamB> hmm...
10:40:33 <SamB> is that even against policy?
10:41:36 <Igloo> I doubt it's againt the letter of policy given packages will want to create the odd little config file if it doesn't exist or whatever
10:41:52 <Gs30ng> hi
10:41:53 <SamB> what do the other packages do?
10:41:59 <Igloo> What other packages?
10:43:07 <SamB> other haskell packages?
10:43:28 <Igloo> Oh, no idea. Not sure which if any are actually packages of cabalised stuff yet
10:43:54 <SamB> well, do they use --auto-ghci-libs also, is what I mean...
10:44:24 <Igloo> Nothing will use it explicitly, I'm sure. As for cabal stuff, no idea, like I said
10:44:31 * Igloo decides to just sed it out for now
10:55:15 * CosmicRay points out: darcs get --partial http://cvs.haskell.org/darcs/ghc
10:55:51 <neologism> its quite funny that its cvs.haskell.org for a darcs repo :)
10:56:20 <CosmicRay> neologism: the request has been made for a new hostname ;-)
10:59:28 <SamB> neologism: not really all that funny
10:59:41 <SamB> I mean, its tied to CVS, right?
11:00:13 <CosmicRay> at this precise moment, the precise repo I mentioned is.
11:00:14 <SamB> CosmicRay: how much downloading will that do?
11:00:18 <CosmicRay> other repos in that area aren't.
11:00:22 <CosmicRay> SamB: 3.5MB or so.
11:00:26 <SamB> hmm
11:00:26 <CosmicRay> *if* you use --partial.
11:00:30 <CosmicRay> far, far more if you don't.
11:00:30 <SamB> well yeah!
11:00:38 <CosmicRay> we're talking 13,000 patches here.
11:00:48 <SamB> I am not stupid enough to take off the --partial on 56k!
11:00:53 <CosmicRay> hehe
11:01:00 <SamB> I don't want the entire CVS history of the repo!
11:01:29 <CosmicRay> ahh, but I'm sure there are some that do ;-)
11:01:49 <CosmicRay> that have been waiting for years -- *years* I tell ya -- to have a local copy of the entire CVS history since 1997.
11:01:56 <SamB> yes, but they probably aren't on 56k ;-)
11:02:01 <CosmicRay> either that, or people that will just forget to say --partial ;-)
11:04:26 <musasabi> Sometimes I feel like darcs should support a repo setting whether the default get will be normal or --partial
11:04:53 <SamB> that does sound like a good idea
11:05:19 <ADEpt> i would generalize to something akin to .cvsrc
11:05:20 <SamB> if it did, though, it ought to also support a way to get the history when you have a partial checkout without doing a whole checkout again
11:05:40 <SamB> ADEpt: can you stick that in a repo?
11:05:40 <ADEpt> where you could specify user-wide default params for all available commands
11:05:52 <ADEpt> SamB: unfortunately, no
11:06:26 <ADEpt> SamB: i mean, with cvs - no. 
11:06:39 <SamB> so you don't really mean something like .cvsrc, then
11:06:53 <SamB> though one of those *might* be nice, too
11:06:57 <ADEpt> SamB: I mean, with the same functionality
11:07:11 <ADEpt> SamB: like 'darcs setpref diff-args "-u"'
11:07:22 <ADEpt> SamB: etc for all other commands
11:07:28 <SamB> that sounds like something WAY more advanced than CVS
11:07:35 <SamB> does svn have that?
11:07:43 <ADEpt> SamB: no, it is repository-local .cvsrc
11:08:17 <ADEpt> SamB: mine .cvsrc:
11:08:17 <ADEpt> cvs -z3
11:08:17 <ADEpt> diff -uBb
11:08:17 <ADEpt> update -dRP
11:08:32 <SamB> anyway, we aren't talking about such a general method
11:08:37 <SamB> would that even work on get?
11:09:01 <ADEpt> SamB: which "get" -- darcs get or cvs checkout? :)
11:09:06 <SamB> darcs get
11:09:19 <ADEpt> SamB: ah. good question :)
11:09:34 <ADEpt> SamB: why not, though? :)
11:09:45 <ADEpt> dons: could it work on "darcs get"? :))
11:10:48 * SamB thinks such a mechanism could be downright confusing, actually
11:11:29 <ADEpt> SamB: for "darcs get", setting could be taken from ~/.darcsrc
11:11:50 <Gs30ng> uhm... can i ask you guys a question?
11:12:03 <CosmicRay> Gs30ng: please
11:12:04 <ValarQ> Gs30ng: sure, go ahead
11:12:08 <SamB> ADEpt: that doesn't even do what musasabi suggested
11:12:14 * Igloo wonders where in the hierarchy to put a gobject binding
11:12:16 <ADEpt> SamB: and in order not to be confusing, darcs could say "using --partial, as instructed by ~/.darcsrc"
11:12:21 <SamB> Gs30ng: its practically required!
11:12:37 <Gs30ng> well, in haskell, i clearly see [] means an empty list
11:12:47 <SamB> yes?
11:12:48 <ADEpt> Gs30ng: now it would be even impolite to part without asking question :)
11:13:01 <Gs30ng> but is there any expression that means a list with exactly one element?
11:13:11 <CosmicRay> Gs30ng: [1]
11:13:13 <SamB> > [1]
11:13:13 <lambdabot> [1]
11:13:20 <SamB> > length [1]
11:13:21 <lambdabot> 1
11:13:24 <Gs30ng> oh, thanks
11:13:26 <ADEpt> Gs30ng: [1], ['a'], ["a"] - pick any
11:13:37 <SamB> > length "a"
11:13:38 <lambdabot> 1
11:13:47 <CosmicRay> in fact, even:
11:13:49 <ADEpt> > length ["a"]
11:13:50 <lambdabot> 1
11:13:52 <CosmicRay> > length ["foo"]
11:13:52 <SamB> > ['a']
11:13:53 <lambdabot> 1
11:13:54 <lambdabot> "a"
11:14:10 <ADEpt> > length [[]]
11:14:11 <lambdabot> 1
11:14:26 <SamB> > length [1,2]
11:14:27 <lambdabot> 2
11:16:00 <jethr0> now you are confusing him ;-)
11:16:09 <jethr0> or her...
11:16:11 <SamB> sorry
11:16:16 <SamB> Gs30ng: I do that!
11:16:17 <jethr0> hehe
11:16:34 <ADEpt> SamB: as I understood, musasabi wanted server-side setting, which overides default for clients, who "darcs get" it, right?
11:17:07 <SamB> ADEpt: basically
11:17:09 <Gs30ng> my function should return 1 when (and only) it is given a 1-length list
11:17:27 <ADEpt> Gs30ng: and what seems to be the problem?
11:17:48 <jethr0> might already have been it *g*
11:17:56 <Gs30ng> count x
11:17:56 <Gs30ng> 	| length x == 1 = 1
11:18:01 <Gs30ng> this code works
11:18:04 <SamB> > let f = length in f [1]
11:18:04 <lambdabot> 1
11:18:14 <Gs30ng> but i'd like to do it with pattern matching
11:18:24 <ADEpt> Gs30ng: you can :)
11:18:34 <astrolabe> gs30ng: match with [a]
11:18:34 <Gs30ng> could you tell me how?
11:18:38 <jethr0> > count [x] = 1
11:18:38 <lambdabot>  parse error on input `='
11:18:49 <ADEpt> Gs30ng: what have you got so far?
11:18:53 <jethr0> let count [x] = 1 in count [1]
11:18:58 <SamB> Gs30ng: ah
11:19:11 <SamB> well, you could do it like
11:19:23 <SamB> count [] = 0
11:19:23 <SamB> count [_] = 1
11:19:35 <SamB> count [_,_] = 2
11:19:40 <Gs30ng> my hugs interpreter says:
11:19:40 <ADEpt> > let count [_] = 1; count _ = 0 in [count [1], count [1,2,3]
11:19:40 <SamB> but that would take an infinite number of cases
11:19:41 <lambdabot>  parse error on input `}'
11:19:58 <ADEpt> > let count [_] = 1; count _ = 0 in [count [1], count [1,2,3]]
11:19:59 <lambdabot> [1,0]
11:20:09 <Gs30ng> "Instance of Num Char required for definition of count" when i tried [1]
11:20:21 <ADEpt> Gs30ng: try [1::Int]
11:20:22 <SamB> > let count [_] = 1; count _ = 0 in [count [1], count [1,2,3]]
11:20:23 <lambdabot> [1,0]
11:20:57 <ADEpt> Gs30ng: it cant figure out which "1" do you mean - Int, Integer, or something else -- and needs a hint
11:21:22 <ADEpt> Gs30ng: ah. sorry. I am wrong. Show the code.
11:21:41 <astrolabe> I think SamB has got it
11:21:52 <astrolabe> (the right idea)
11:22:03 <ADEpt> astrolabe: i got it too, so we both get half of it :)
11:22:03 <Gs30ng> underbar seems to work
11:22:06 <jethr0> you mean copy-pasting adepts idea ;-)
11:22:07 <Gs30ng> anyway thanks all
11:22:22 <astrolabe> Oh yeah :)
11:22:35 <astrolabe> so SamB is a plagerist huh?
11:22:41 <jethr0> didn't say that
11:22:55 <jethr0> wouldn't be the first time that discoveries are made INDEPENDENTLY at the same time...
11:22:59 <ADEpt> astrolabe: nah. It is called "following of the best practices" :)
11:23:06 <SamB> astrolabe: no!
11:23:11 <SamB> I am lagged!
11:23:17 <jethr0> hehe
11:23:25 <astrolabe> :)  That's what all the best plagerists say
11:23:40 <astrolabe> now where is @karma- when you need it?
11:24:39 <SamB> CosmicRay: so what shall we do with our darcs patches?
11:24:40 * ADEpt remembers sitting on #haskell over GSM 9600 kbps .... Now those were lags.
11:24:58 <ADEpt> SamB: unrecord & revert ;)
11:24:59 <CosmicRay> SamB: nobody is accepting them yet
11:25:08 <ADEpt> SamB: Ha! Told ya!
11:25:10 <CosmicRay> SamB: but lean on jaffacake to use darcs as the authoritative source ASAP ;-)
11:25:33 <SamB> oh, well I did copy/paste his idea
11:25:37 <Igloo> What happens to patches that are darcs sent?
11:25:38 <SamB> but added the missing square bracket
11:25:56 <Igloo> If they go to the mailing list then Simon will apply them I expect
11:26:00 <CosmicRay> Igloo: there is no email file in _darcs/prefs, so there is no way they can be darcs sent
11:26:08 <Igloo> Then fix it  :-)
11:26:13 <CosmicRay> Igloo: also the darcs patch format isn't compatible with patch(1)
11:26:24 <CosmicRay> Igloo: My impression is that JaffaCake doesn't want it fixed yet ;-)
11:26:25 <SamB> CosmicRay: don't care about authoritatative, just care about not-causing-conflicting-patches-to-be-generated-by-tailor
11:26:46 <SamB> and popular
11:27:25 <SamB> CosmicRay: darcs send just requires the user to enter an address if there is no email in _darcs/prefs on the destination
11:30:08 <CosmicRay> well then, they can enter whatever address they want, and know full well that there is no guarantee that the recipient will do anything with it ;-)
11:30:09 <ADEpt> On the related note, I wonder how one can "darcs send" some patches, and then later "darcs send" some more before the first batch is applied to the repo, without sending same patches twice?
11:32:36 <SamB> ADEpt: you can't!
11:32:43 <ADEpt> (this assumes that I dont remember properly which was the last patch I sent)
11:33:37 <SamB> I think the problem is that jlouis doesn't apply them when they come like that
11:33:45 <SamB> well, not always
11:34:28 <samx_> how can I define a new type in the toplevel interpreter? I'm getting "<interactive>:1:0: parse error on input `type` (or newtype/data)
11:35:22 <SamB> samx_: use a file
11:35:38 <SamB> if you need types, you probably would like to keep your stuff around for a while anyways
11:36:10 <samx_> no, not really :-) just playing around trying to figure things out
11:36:14 <ADEpt> SamB: you mean jlouis does not apply patches sent over mail? But he does.
11:36:40 <SamB> ADEpt: no, I mean that sometimes he doesn't seem to apply patch bundles that start with patches he already applied
11:39:43 <ADEpt> SamB: seems like he is plain busy at the moment, because i sent set of, say, patches [1,2,3] and then [1,2,3,4,5,6], and none of them are applied so far :)
11:39:49 <ADEpt> @seen jlouis
11:39:49 <lambdabot> jlouis is in #haskell-blah and #haskell. Last spoke 1 day, 2 hours, 36
11:39:49 <lambdabot> minutes and 35 seconds ago.
11:42:10 <CosmicRay> BWAHAHAHA.
11:42:21 <CosmicRay> finally got the ghc-6-4-branch tree converting.
11:42:21 <CosmicRay> yay
11:44:12 <musasabi> congratulations :-)
11:45:19 <CosmicRay> by the way.
11:45:20 <CosmicRay> I hate cvs.
11:45:39 <CosmicRay> it appears to be impossible to derive a clean point at which something branched solely by looking at a cvs repo.
11:45:44 <SamB> CosmicRay: are there people who don't?
11:45:50 <CosmicRay> SamB: apparently
11:46:00 <CosmicRay> SamB: otherwise, why would it still be so popular?
11:46:43 <SamB> CosmicRay: because its available, and because it can take some effort to move over to SVN or darcs, besides being scary...
11:47:11 <CosmicRay> but the benefits are realized so very quickly...
11:47:13 <CosmicRay> sigh.
11:47:58 <JKnecht> darcs and SVN ... redundant or complementary?
11:48:10 <SamB> not redundant
11:48:13 <SamB> they are different
11:48:15 <ADEpt> JKnecht: different
11:48:20 <CosmicRay> different, indeed.
11:48:22 <SamB> I'm not sure how complementary they can be yet
11:48:38 <CosmicRay> though personally darcs advantages over svn completely outweigh svn's advantages over darcs, for me at least.
11:48:46 <Gs30ng> oops
11:48:53 <Gs30ng> i've got 2 more questions
11:48:59 <SamB> they don't seem to be very complementary in the case of pugs
11:49:11 * JKnecht knew them to be different, intends them to be complementary.
11:49:24 <Gs30ng> how can i make an integer a string?
11:49:31 <CosmicRay> read
11:49:36 <CosmicRay> see the PRelude docs
11:49:38 <ADEpt> CosmicRay: you could only guess about branch if branch was not followed by tag on branch immediately. Hardly anyone does that.
11:49:42 <SamB> CosmicRay: you've got ti backwards
11:49:47 <SamB> thats show
11:50:02 <CosmicRay> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
11:50:09 <CosmicRay> oh, geez, I did.
11:50:24 <CosmicRay> I read that as "integer from a string"
11:50:25 <SamB> hehe
11:50:27 <CosmicRay> for whatever reason.
11:52:32 <astrolabe> > show 23
11:52:34 <lambdabot> "23"
11:52:59 * astrolabe 4 lambdabot
11:54:18 <Gs30ng> prelude docs... prelude is a basic library of haskell functions, right?
11:54:26 <Gs30ng> i should check it once... thanks
11:55:33 <CosmicRay> Gs30ng: Prelude is the library of functions that is always implicitly available
11:55:38 <CosmicRay> you don't need to import anything to use it
11:56:23 <Gs30ng> yeap... my hugs prompt tells me that :)
11:57:05 <samx_> is there any difference between using newtype, or using data with just one constructor with one parameter.. e.g. 'newtype Age = Age { age :: Int }' or 'data Age = Age { age :: Int }' ?
11:58:03 <astrolabe> can you label newtypes?
11:58:19 <samx_> yes
11:58:42 <astrolabe> I think newtype is more efficient
11:59:10 <musasabi> newtypes are different from data semantically and more efficient.
11:59:15 <bringert> samx_: newtype is strict, and the constructor is compiled away
11:59:44 <musasabi> basically given (\(Foo _) -> True) (Foo undefined), newtype and data are different.
12:11:18 <jethr0> so, when should one use "data" then??
12:12:10 <phys_rules> hey everyone ;)
12:12:25 <liyang> jethr0: when you need more than one constructor.
12:13:04 <jethr0> aaah, ok.
12:13:25 <liyang> newtype is cheaper, when it's applicable.
12:14:52 <musasabi> of course if there are multiple data members data is usually better
12:15:21 <musasabi> newtype F = F (A,B,C,D) vs data F = F A B C D
12:18:50 <astrolabe> Would it be fair to say that newtype is only there for efficiency?  Like Array?
12:20:38 <jethr0> what would the counterpart of Array be? lists?
12:21:32 <samx_> hmm.. I tried (\(Foo _) -> True) (Foo undefined) with both newtype and data, but not seeing any difference
12:21:41 <astrolabe> jethr0: yeah
12:37:56 <dataangel> I'm going through the haskell tutorial, and trying to type stuff from the tutorial into the hugs interpreter, but none of it works. "inc n = n+1" for example gives: "ERROR - Syntax error in input (unexpected `=')"
12:38:01 <dataangel> What am I missing? :P
12:38:34 <astrolabe> dataangel: you can't type defns into hugs
12:38:46 <astrolabe> you can put them in a file and load it.
12:38:53 <jethr0> > let inc n = n+1 in inc 4
12:38:55 <lambdabot> 5
12:39:07 <jethr0> > inc 4 where inc n = n+1
12:39:08 <lambdabot> 5
12:39:22 <xerox> n + 1 = 1 + n = (+) 1 n = (+) 1 = (+1)
12:40:06 <dataangel> astrolabe: I tried that, put putStr "Hello" into a file and ran hugs on it: ERROR "temp.hs":1 - Syntax error in declaration (unexpected `}', possibly due to bad layout)
12:40:10 <jethr0> > inc 4 where inc = (+1)
12:40:11 <lambdabot> 5
12:41:05 <astrolabe> dataangel: change it to 'main = putStr "hello"  '  I think
12:41:33 <astrolabe> or type it in at the hugs prompt
12:41:52 <dataangel> astrolabe: Well, that doesn't give the error but it doesn't print the string either, the interpreter just loads
12:42:27 <dataangel> Seems kind of silly for the tutorial not to explain that the examples it gives don't work out of the box, in a file or in the interpreter :P
12:43:00 <astrolabe> dataangel: I agree it is a problem.  We should be able to get you started though.
12:43:08 <astrolabe> and it isn't as illogical as it seems
12:43:17 <dataangel> k
12:43:43 <astrolabe> try typing 'main' at the prompt with that file loaded.
12:44:02 <dataangel> ah
12:45:18 <dataangel> But most normal apps aren't going to work like that -- you'll want it to do what the file specifies when it's loaded. Adding a call to main in the file right after I define it doesn't help. I'm guessing I'm not allowed to do that since the app has to be one expression?
12:46:01 <astrolabe> With a compiler, you create an executable.
12:46:26 <astrolabe> With an interpreter, you need to type something at the prompt to get it to work.
12:46:54 <dataangel> so, if I compiled it, and ran it, it would automatically run main?
12:47:04 <astrolabe> yes
12:47:18 <astrolabe> provided the file was called Main.hs
12:48:07 <dataangel> ic
12:49:52 <dataangel> how do I get hugs into compiler mode? Or is it only an interpreter?
12:50:28 <CosmicRay> hugs is an interpreter only
12:50:32 <CosmicRay> if you want a compiler, you need ghc
12:51:02 <astrolabe> ghc has an interpreter mode too
12:51:55 <phys_rules> ghci rocks
12:52:25 <SamB> astrolabe: or invoke it by a more imperative name
12:52:43 <SamB> ... probably something with the word "run" in it
12:53:38 <astrolabe> SamB: how do you mean?  What does your 'or' refer to?
12:55:33 <SamB> astrolabe: the file can be called anything as long as it contains a "Main" module
12:57:31 <astrolabe> This is something I should find out about.
12:57:46 <astrolabe> Doesn't the Main module have to be in Main.hs?
12:57:49 <Saulzar_> There is a script called runhugs to just run the program
13:00:13 <SamB> astrolabe: am I that lagged?
13:00:26 <SamB> <astrolabe> With an interpreter, you need to type something at the prompt to get it to work.
13:00:26 <SamB> <-- lisppaste2 has quit (Read error: 104 (Connection reset by peer))
13:00:26 <SamB> <SamB> astrolabe: or invoke it by a more imperative name
13:00:50 <dataangel> Saluzar: Thanks ;)
13:01:00 <dataangel> Saluzar: Is there a runghc?
13:02:56 <astrolabe> 04[20:45] astrolabe: 01With an interpreter, you need to type something at the prompt to get it to work.
13:03:06 <astrolabe> 10[20:51] SamB: 01astrolabe: or invoke it by a more imperative name
13:03:25 <astrolabe> I don't know who has the lag though.
13:04:45 <SamB> astrolabe: no!
13:05:33 <SamB> astrolabe: the Main module is the one exception to that rule that doesn't involve GHCi
13:05:42 <SamB> or hugs
13:06:11 <SamB> astrolabe: ping me and lambdabot 
13:06:22 <SamB> no wait, lambdabot probably won't answer...
13:06:33 <ricebowl> would appear to be SamB who is lagging :p
13:06:49 <astrolabe> ping SamB
13:07:08 * SamB pings dons instead
13:07:43 <astrolabe> @eval 1
13:07:44 <lambdabot> 1
13:07:55 <astrolabe> less than a second for lambdabot
13:08:40 <ricebowl> [16:08:03] [astrolabe PING reply]: 1sec
13:08:50 * ricebowl is still waiting for SamB's PING reply :p
13:11:08 * astrolabe could do with a more informative run-time error than "Exception: Error in array index"
13:11:19 <Saulzar_> dataangel, ghc is a compiler, so it can produce a binary (which will run itself)
13:11:32 <phys_rules> Saulzar: yes
13:11:32 <ricebowl> that would be relatively simple to do, no?
13:12:02 <ricebowl> just modify the GHC.Arr stuff in the GHC libraries to name the index in the error string
13:12:17 <ricebowl> since that should never happen *anyway*, it should be a cheap thing to do
13:12:19 <astrolabe> I would have thought so, but that's easy to say for someone who has never written a compiler
13:12:35 <ricebowl> it has nothing to do with writing a compiler
13:12:40 <ricebowl> Array is implemented in Haskell :p
13:13:00 <astrolabe> oh yeah
13:13:05 <ricebowl> I think it would take maybe 5 minutes to make the changes. Of course, that makes some implications.
13:13:10 <SamB> astrolabe: this is what comes of trying to darcs get ghc on 56k
13:13:15 <ricebowl> because the indices have to instantiate class Enum
13:13:27 <ricebowl> does Enum imply Show?
13:13:44 <astrolabe> hmmm no, I don't think so.
13:13:56 <adept_> ricebowl: no
13:14:10 <ricebowl> hmm, ok, well then that is a small problem :p
13:14:27 <astrolabe> and it all seemed so easy a moment ago.
13:15:04 <ricebowl> I expect that most of the time the indices will have class Integral which IIRC does imply Show (or rather a fromIntegral function, and Integer *does* instantiate Show)
13:15:11 <SamB> ricebowl: does Ix imply Enum?
13:15:32 <ricebowl> SamB - doesn't it?
13:15:46 <ricebowl> might be that I don't know wtf I'm talking about.
13:16:57 <ricebowl> hmm, I guess it's Ix and not Enum that I was thinking of
13:16:59 <adept_> ricebowl: mighht be ;) I cant see why some class shoule have 'Show a =>' in declaration
13:17:33 <ricebowl> I suspect everything in Prelude that has Ix also has Show, but that is not a firm requirement, so...
13:18:08 <ferdy> fine... so I could built a Unregisterised ghc in alpha... It creates HUGE binaries. I guess thats because it is unregisterised, am I wrong ?
13:18:09 <astrolabe> Is Ix even in the Prelude?
13:18:17 <phys_rules> ferdy: true
13:18:20 <SamB> ricebowl: of course, you could print out the indexes after they've been Ixed...
13:18:25 <SamB> whatever Ix does
13:18:26 <ricebowl> s/Prelude/standard Haskell/
13:18:30 <fworp> no, its Data.Ix and it implies Ord
13:18:40 <phys_rules> ferdy: you can try building a stage 2 build , should be better
13:18:40 <adept_> ricebowl: and what's the problem? (sorry for asking in the middle of conversation)
13:19:04 <ricebowl> adept_ - astrolabe commented that it would be nice to get a more informative error message when you access an array out of bounds
13:19:08 <ferdy> phys_rules: mmm how should I proceed ?
13:19:22 <ricebowl> and I commented that if you can guarantee that the array's index derives Show then it would be an easy fix
13:19:33 <ricebowl> and take maybe 5 minutes
13:19:35 <ferdy> phys_rules: or even more.... what are the proper steps to get a registerised one ?
13:20:05 <adept_> @hoogle Ix
13:20:06 <lambdabot> Data.Ix.Ix :: Ord a => Ix a
13:20:06 <lambdabot> Data.Array.IArray.ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j)
13:20:06 <lambdabot> -> a j e -> a i e
13:20:06 <lambdabot> Data.Array.ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e ->
13:20:06 <lambdabot> Array i e
13:20:07 <phys_rules> ferdy: AFAIK a stage 2 should be registered if you enable nativeGen and ghci
13:20:48 <phys_rules> ferdy: so you just remove the old build.mk and cd ghc && gmake boot stage=2 && gmake stage=2
13:21:00 <ferdy> phys_rules: k, will check. Every attempt to build a registered one failed in Apply (it generated faulty assembly)
13:21:04 <adept_> ricebowl: no luck. it just have to be Ord'able. I though it would be more restrictive, line Integral ...
13:21:21 <ricebowl> not Integral. That's why I said Enum initially. :p
13:21:40 <phys_rules> ferdy: I'm making a registered build as well :) for solaris x86
13:21:54 <ricebowl> an Enum can be used as an array index which is rather nifty
13:22:02 <phys_rules> ferdy: so good luck to both of us :)
13:22:06 <ferdy> phys_rules: this one took 10 hours to build :P
13:22:13 <ferdy> phys_rules: yeah, thanks and good luck
13:22:13 <phys_rules> ferdy: hmm
13:22:21 <phys_rules> ferdy: too about 3 hours on my computer
13:22:40 <SyntaxNinja> 'morning
13:22:40 <ferdy> phys_rules: this is a not so fast alpha (164LX) and not so good I/O
13:22:50 <phys_rules> bad IO sucks :\
13:22:54 <samx_> anyone aware of a reasonable (and simple) example/tutorial into using MArrays?
13:23:24 <ferdy> phys_rules: that model was meant to be a workstation anyway :P and it is like 7 years old at least
13:23:31 <adept_> SamB: am I right that you intended each PeerThread to be accompanied by thread that listens to the socket channel and convert incoming messages into commands for PeerThread's command TChan?
13:26:15 <musasabi> If I have a transaction like "atomically (readTChan chan)" will it only get values written by committed transactions ?
13:26:45 <fworp> you could have Ix provide a maybeShowIx function with a default implementation of const Nothing
13:26:48 <adept_> musasabi: i'd say yes
13:27:06 <adept_> musasabi: otherwise it would not be "atomical"
13:28:40 <phys_rules> ferdy: how big is the generated genapply ? :)
13:28:44 <SamB> adept_: not exactly
13:28:52 <phys_rules> ferdy: mine is 5mb ... =)
13:28:58 <SamB> adept_: may not be a bad way to do it though
13:29:06 <ferdy> phys_rules: genapply ? where to look for it ?
13:29:14 <phys_rules> ferdy: ghc/utils/genapply
13:29:44 <adept_> SamB: otherwise I cant see how single thread could block on both TChan and socket at the same time and process inputs concurrently
13:30:16 <ferdy> phys_rules: mmmmm can't find it now... (I trashed my sources dir)
13:30:17 <adept_> SamB: and PeerThread needs to listen to net and to master thread at the same time
13:30:35 <ferdy> phys_rules: but a 'simple' test is 6Mb and 4,2Mb stripped
13:30:46 <phys_rules> ferdy: yeah, about the same here :)
13:31:10 <ferdy> phys_rules: and not so good performance... but I don't really care much about that
13:31:13 <SamB> adept_: TChan is it now?
13:31:26 <phys_rules> and files built with stage2 dump core.. :\
13:31:47 <ferdy> phys_rules: weird
13:32:29 <phys_rules> ferdy: and they're not smaller either :\
13:32:46 <adept_> SamB: i dont have sources at hand, but PeerThread and Master/InterestTable threads communicate via TChan's, dont they?
13:33:14 <ferdy> phys_rules: well... I'll check with my 'local expert' and see if I can start working a bit on ghc for alpha
13:33:30 <ferdy> phys_rules: where 'local expert' = some gentoo haskell developer :P
13:33:43 <maitscha> hallo, I have to check if a given graph has a cycle. is there any easy way to do this? i think a depth-first-search algorithm is to much complex for haskell...
13:34:10 <phys_rules> ferdy: hehe
13:34:11 <adept_> @hoogle Data.Graph
13:34:12 <lambdabot> Prelude.undefined :: a
13:34:12 <lambdabot> Test.QuickCheck.Batch.bottom :: a
13:34:38 <adept_> maitscha: check out module Data.Graph ;)
13:34:39 <fworp> that seems off.
13:34:58 <adept_> @hoogle dfs
13:34:59 <lambdabot> Data.Graph.dfs :: Graph -> [Vertex] -> Forest Vertex
13:34:59 <lambdabot> Data.Graph.Inductive.Query.DFS.dfs :: Graph gr => [Node] -> gr a b -> [
13:34:59 <lambdabot> Node]
13:34:59 <lambdabot> Data.Graph.Inductive.Query.DFS.dfs' :: Graph gr => gr a b -> [Node]
13:35:18 <adept_> here it is :)
13:37:45 * SamB wonders how hard it would be to port GHC to house
13:38:13 <adept_> SamB: one first have to port gcc to house :)
13:38:29 <SamB> adept_: there has to be another way!
13:38:33 <maitscha> hmmm... how is the data type graph defined? cant find it anywhere...
13:38:45 <xerox> @docs Data.Graph
13:38:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
13:38:48 <xerox> There!
13:38:57 <SamB> not that it would be all that hard to port gcc...
13:39:10 <SamB> probably all you'd have to do would be get it to run...
13:39:23 <SamB> which would mean libc, I guess
13:40:02 * SamB wonders if you could implement libc in Haskell
13:40:45 <Saulzar_> Might be interesting trying to implement malloc
13:41:03 <SamB> Saulzar: don't we already have one of those?
13:41:28 <Saulzar_> Not sure, I thought it was part of libc though?
13:41:46 <SamB> well of course everything I'm saying is hot air
13:41:50 <Saulzar_> You have lower level alloc stuff from the OS... 
13:41:56 * SamB hasn't even downloaded the OS yet
13:41:59 <Saulzar_> Really? :)
13:42:02 <SamB> anyways, we could use malloc.c
13:42:09 <SamB> er, the source
13:42:22 <SamB> I have a demo floppy ;-)
13:42:28 <Saulzar_> Sorry - haven't been watching, which OS?
13:42:31 <SamB> House
13:42:41 <maitscha> hmmm... up to the present i had my own defintion of a graph which was type Graph = [(Int,[Int]), Int,[Int]), ...]. will it be difficult to convert it?
13:42:47 <SamB> @where house
13:42:47 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
13:43:11 <adept_> maitscha: no
13:43:56 <Saulzar_> Wow, crazy
13:44:14 <SamB> but doable
13:44:16 <SamB> done
13:44:23 <SamB> try that in Python!
13:44:32 <maitscha> I am very new to haskell so it is a little bit difficult to read the definition of the data type of Data.Graph.
13:44:34 * SamB couldn't fit the runtime on a floppy
13:44:38 * SamB doesn't thinl
13:44:43 <SamB> s/l$/k/
13:45:01 <maitscha> How is a graph specified in Data.Graph?
13:45:09 <xerox> @libsrc Data.Graph
13:45:09 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Graph.hs
13:45:14 <xerox> Last resource.
13:45:20 <adept_> @type Data.Graph.Graph
13:45:21 <lambdabot> Not in scope: data constructor `Data.Graph.Graph'
13:45:36 <kzm_> Good evening!
13:45:39 <kzm_> @seen shapr
13:45:40 <lambdabot> shapr is in #ScannedInAvian and #haskell. Last spoke 2 hours, 17 minutes
13:45:40 <lambdabot> and 43 seconds ago.
13:45:57 <xerox> @kind Data.Graph.Graph
13:45:58 <lambdabot> *
13:46:56 <jethr0> "House is based on hOp (older version) - a variant of the Haskell compiler GHC and its run-time system, adapted to produce code that can run in a standalone environment.
13:47:12 <adept_> maitscha: look at the examples in Data.Graph.Examples
13:47:22 <jethr0> doesn't this take some sense out of porting ghc to house?
13:48:34 <adept_> maitscha: I distinctly remember example which worked on graph of Ints with edges denoted by Ints
13:48:42 <SamB> jethr0: nope!
13:49:03 <SamB> after all, how are you supposed to get it to be self-hosting without GHC running on it?
13:49:42 <jethr0> but if i understand it correctly, house already contains parts of ghc...
13:50:00 <Saulzar_> But that is for compiling the OS itself .. no?
13:50:19 <Saulzar_> If you then wanted to compile programs for it ... 
13:50:26 <SamB> the house source tree contains a version of GHC
13:50:44 <SamB> but what about getting GHC to run *on* house?
13:51:17 <jethr0> hmm, ok, i think house mainly relies mainly on the ghc runtime.
13:51:32 <Saulzar_> All I can guess is that they must have a fair amount of layer code to do the hardware bit fiddling stuff, or some extensions for manipulating C like structs... surely?
13:52:06 <SamB> it seems to have a fair amount of Haskell code for that stuff, yes
13:52:08 <jethr0> i had a brief look at their code and it seemed amazingly non-ugly *g*
13:52:23 <SamB> and I'm sure they had to hack a bit of C in the runtime to get it to work standalone
13:53:04 <Saulzar_> Any communication with hardware is going to require manipulating structures in memory
13:54:18 <SamB> eh, the hardware doesn't have that much in the way of structures in memory...
13:55:07 <jethr0> from the paper: in place of the usual file-based I/O we provide direct access to the IA32's IO ports and memory-mapped regions.
13:55:24 <Saulzar_> Hmm..
13:55:54 <jethr0> this is supposedly all encapsulated in a hardware monad.
13:56:56 <jethr0> "like IO, the H[ardware] monad provides primites for expressing stateful computations and for interacting with the "real world" but a a lower level"
13:57:04 <jethr0> primitives*
13:59:20 <jethr0> the paper as well as the code make it seem like a very beautiful solution to a potentially ugly problem ^_^
13:59:31 <SamB> a really ugly problem
13:59:52 * jethr0 glances at the linux kernel and nods frantically
13:59:55 <SamB> or at least, most of the solutions are very hard to understand
14:00:32 <SamB> okay, so on x86 it is in fact very ugly... but thats because there are so many slightly-incompatible things...
14:00:40 <jethr0> i mean, proving the correctness of a kernel is quite the feat.
14:01:18 <jethr0> it's really a question of modularization (microkernels) and creeping featurism.
14:01:47 <jethr0> even small, nice kernels tend to be overloaded by this and that architecture and this and that driver...
14:01:54 <jethr0> over time
14:03:45 <SamB> I'm not too sure what microkernels are good for, or what they really are, anymore...
14:04:11 <SamB> Is a microkernel a bit like lambdabot?
14:04:52 <adept_> SamB: look at minix
14:05:22 <SamB> adept_: I don't have to buy the book for that anymore, do I?
14:05:32 <adept_> SamB: no :)
14:05:49 <jethr0> i really like the idea of having a small intermediator/kernel and all the daemons, etc running with less privileges.
14:05:53 <SamB> I have Linus to thank for it, no doubt...
14:06:15 <adept_> SamB: in essence, kernel is supersmall and provides a central mediation point for processes that implement everything else: drivers, fs, ...
14:06:38 <SamB> adept_: mach just doesn't fit my idea of "small"
14:06:42 <jethr0> so, you can switch VM implementations at runtime or restart your kernel security subsystem...
14:06:52 <adept_> jethr0: on one condition: no significant performance impact, right? :)
14:07:11 <adept_> SamB: who said 'mach'? :)
14:07:26 <SamB> NT was also supposed to be one
14:07:36 <jethr0> hmm, even with a performance impact, i might be willing to forego a few cycles per second to feel a little safer with my kernel.
14:07:44 <SamB> but they couldn't get it to pass messages fast enough so they just threw it all into the kernel
14:07:46 <kolmodin> ADEpt: I was wrong earlier, something can be built out of Test.QuickCheck.{generate,evaluate}
14:07:49 <wilx> It still is, in a way, isn't it?
14:07:50 <jethr0> and monoliths like linux can simply not be proven correct.
14:08:01 <jethr0> whereas small, well separated modules might be...
14:08:17 <Saulzar_> Can anything of massive size be proven correct?
14:08:19 <adept_> kolmodin: do you have a patch I can pull? :)
14:08:35 <kolmodin> well.... I haven't actually done anything yet... :)
14:08:36 <SamB> jethr0: I don't care so much about being proven correct as having large parts of it cleared from potential blame
14:08:37 <jethr0> NT has too many system calls in the "kernel" to be considered _micro_ by most.
14:09:05 <wilx> Well, it has some message passing and it is rather modular too.
14:09:11 <kolmodin> adept_: just saw that Test.QuickCheck.Batch uses that technique
14:09:22 <SamB> like I said, they couldn't get it to pass messages fast enough so they threw it all into the kernel...
14:09:24 <jethr0> and image all those driver developers who wouldn't have to reboot their system every time they compile.
14:09:36 <adept_> jjethr0: i'm afraid it wouldnt be "few cycles". Conside fs<->vm/buffer cache relationships, f.e., or things like sendfile
14:09:42 <jethr0> or rather every time they cause a kernel oops.
14:10:08 <jethr0> L4 micro kernel and other ones have pretty good performance...
14:10:09 <SamB> jethr0: I bet house could do that if it had an hs-plugins workalike
14:10:09 <adept_> jethr0: for that vmware exists or things like UML
14:10:25 <SamB> and a self-hosted GHC
14:10:44 <SamB> which you'd need to get the hs-plugins to work
14:10:57 <SamB> as well as to recompile
14:11:09 <adept_> kolmodin: any chance that you would do something to quickCheck.hs you-know-where? :)
14:11:19 <jethr0> http://os.inf.tu-dresden.de/pubs/sosp97/
14:11:42 <kolmodin> adept_: I might if no one else does it first :)
14:11:58 <jethr0> yes, but being able to restart daemons is better than virtualization, i think
14:12:10 <kolmodin> adept_: I don't know how much time I'll have to spend on things except school the next few weeks
14:13:13 <adept_> kolmodin: end of semester? wish you luck
14:13:31 * adept_ is off to bed
14:13:31 <jethr0> samb: i am very fond of house. but i wonder whether it is rather an academic experiment or could be developed to usability...
14:13:33 <kolmodin> adept_: but it might be possible that I do something. somehow things outside school gets a lot more interesting when the examinations gets closer
14:13:47 <kolmodin> adept_: thanks
14:13:52 <SamB> jethr0: probably both
14:14:00 <adept_> kolmodin: procrastination at it's finest, yes
14:14:08 <SamB> thats the lovely thing about Haskell
14:14:14 * adept_ is really off to bed
14:14:17 <jethr0> hehe
14:14:20 <jethr0> @localtime adept_
14:14:22 <lambdabot> Local time for adept_ is Thu Dec  1 00:13:58 2005
14:14:28 <SamB> you can make something usable and write papers about it too
14:14:31 <xerox> 'night
14:14:52 <SamB> or write papers about things and then make them usable
14:15:04 <SamB> or even both at the same time
14:15:31 <jethr0> yup, i'd really like an os where kernel level exploits can be discarded as impossible (more or less).
14:16:20 <jethr0> and where failing drivers won't crash the whole system!
14:17:28 <SamB> I'd settle for (perhaps prefer) one where it was just easier to write good code than bad
14:18:48 <jethr0> hmm, me too, but then it will be hard to gather legions of haskell programmers for OS work. but we can always hope ;-)
14:18:53 <SamB> certainly theres no real need to have (more than 1 or 2) filesystem drivers in the kernel...
14:19:31 <jethr0> hmm, samba, nfs, iso9660, ext2/3 vfat ntfs, ...
14:19:57 <jethr0> but they certainly could be abstracted and layerd better!
14:20:04 <jethr0> layered*
14:20:11 <SamB> I mean, plan9 does fine with only a few builtin filesystems...
14:21:50 <jethr0> yes, but mightn't that be correlated with its number of users?
14:22:10 <SamB> no, I mean the rest aren't in the kernel
14:23:49 <jethr0> ok, that's a good thing. but how do user level fs drivers access the devices?
14:23:55 <tuomov> the kernel should be just about ipc, scheduling and memory management...
14:24:04 <SamB> using the fs drivers in the kernel
14:24:30 <SamB> plan9 uses filesystems for that too...
14:25:14 <jethr0> seems like a good solution for something that makes up thousands of lines of kernel code in linux...
14:25:14 <tuomov> 64bit architechtures, if done right, should make microkernels more feasible since there's enough address space for context switches to not be needed to the most common services
14:25:35 <jethr0> ??
14:27:16 <SamB> tuomov: that sounds more complicated to me
14:27:34 <tuomov> safer, easily extensible
14:27:39 <SamB> its safer?
14:27:54 <tuomov> than a monolithic accident waiting to happen like the linux kernel is becoming
14:28:00 <SamB> oh, well, yeah
14:28:17 <SamB> I mean, without context switching?
14:28:33 <tuomov> with appropriate memory protections, yes
14:28:42 * jethr0 wonders what samb and tuomov are on about
14:28:46 <tuomov> it should be safe I mean
14:28:47 <astrolabe> How do you guys feel about global variables in haskell?  I guess they are less worrying in a referentially transparent language?
14:28:54 <rep> if you have to change teh memory protections you might as well do a full context switch, tuomov 
14:28:55 <tuomov> but of course it is more complicated than with context switches
14:29:01 <SamB> astrolabe: they are great when they are constant
14:29:08 <SamB> what do you think your functions are?
14:29:18 <astrolabe> SamB: I had realised that :)
14:29:33 <tuomov> no, I mean something a bit more extended from user/sys separation 
14:29:33 <SamB> often even those are called functions ;-)
14:30:25 <SamB> tuomov: you mean like a way to mark pages or regions with a PID or somesuch and then have PID register?
14:30:33 <tuomov> there's no context switch involved in calling the kernel, whose memory user code can't access
14:30:39 <tuomov> SamB: yep
14:30:45 <SamB> ah
14:30:52 <SamB> I think MMIX has something like that
14:31:00 <jethr0> context switches can be pretty cheap (well, except for some cache invalidation). as i said L4 microkernel has only a small performance penalty.
14:31:02 <SamB> but I don't think it has nearly enough bits
14:31:26 <tuomov> such isn't very feasible in 32bit address space, but should be in 64bit if that PID thing can be done efficiently
14:31:41 <jethr0> tuomov: but the idea of microkernels is to have all kernel daemons separated safely from each other!
14:31:46 <tuomov> jethr0: the processor needs to change its context, though
14:31:49 * SamB would want his cache to be caching by physical address
14:32:02 <jethr0> aahh
14:32:03 <tuomov> jethr0: they are, they can't access each others' pages although share the same address space
14:32:20 <SamB> jethr0: you can safely seperate things in the same address space
14:32:25 <tuomov> the kernel and programs share the same address space, and kernel is protected from user programs
14:32:40 <jethr0> to my knowledge this feature is not implemented in hardware and would have to be enforced by context switches to the microkernel, no?
14:32:54 <tuomov> I don't know the details of current 64bit hardware
14:33:04 <SamB> you don't ever need to context switch to the kernel unless you are using SKAS
14:33:18 <SamB> which would be silly in a 64-bit environment
14:33:19 * jethr0 is in way over his head ;-)
14:33:40 <jethr0> samb: how do you denote which process is allowed what in the same address space?
14:33:44 <tuomov> divide the 64bit address space e.g. in half, reserving the lower half for programs, and divide the upper half to 4G slices for services..
14:33:56 <tuomov> protected from each other
14:34:22 <jethr0> yes, but who would prevent a service from accessing another slice?
14:34:25 <tuomov> where memory needs to be shared, it just has to be mapped in each service's slice separately
14:34:36 <SamB> jethr0: you tag the different process's regions with unique identifiers and set a register to match the identifier of the current process, presumably
14:34:36 <tuomov> jethr0: the bits in the page tables
14:35:57 <jethr0> sorry, it's not my area of expertise... i would be happy enough with a context-switching microkernel with some usable OS on top of it *gg*
14:36:24 <tuomov> me too, but I was just pointing out that with 64bit architechtures context switches aren't necessarily a problem
14:36:38 <tuomov> they can be avoided if the MMU is decent
14:36:55 <SamB> tuomov: does it have to have an MMU?
14:37:23 <SamB> wouldn't a TLB and an exception handler be enough?
14:37:30 <tuomov> hmm.. what's an MMU after all? I've heard there are some CPUs that do much of its job in software..
14:37:33 <tuomov> but I'm really not an expert either
14:37:36 <tuomov> but I'm really not an expert eit
14:37:37 <tuomov> hmm.. that's strange
14:38:00 <tuomov> irssi reacts to ssh lag or something..
14:46:29 <musasabi> Seems that is impossible to have really unbuffered Handles with the current API :-(
14:46:49 <bosie> shapr u there?
14:46:50 <musasabi> hLookAhead is evil.
14:47:51 <bosie> shapr have a vid for you, but you probably know it already
14:51:45 <musasabi> or not, I think I know how to work around that :-)
15:07:16 <SamB> JaffaCake: any idea why GHC's configure never finds my docbook XML stylesheets?
15:14:43 <pitui> b
15:18:07 <jeffno> Apropos nothing: There's an interesting link to an online book on the Haskell idioms page.  The description of the link says " for someone just starting coming from an imperative/OO background, it makes a wonderful introduction".
15:18:49 <jeffno> The curious thing is that the main argument of the book is that pure functional programming is not practical, and talks about bringing functional methods into OO languages.
15:19:00 <Frederick> yo folks
15:20:33 <liyang> jeffno: but we have the IO monad. :)
15:21:40 <Frederick> does anyone knws where I can find an implementation of kruskalls algorithm?
15:24:02 <jeffno> Have you tried googling -> haskell kruskal's algorithm
15:24:06 <jeffno> ?
15:24:07 <Frederick> yes
15:24:11 <Frederick> no sources avaliable
15:25:30 <bosie> and here comes the next stupid question ;)
15:26:00 <SamB> hmm, I can't seem to get GHC to build out of darcs...
15:26:31 <bosie> test :: String -> [String]
15:26:31 <bosie> test [] = []
15:26:31 <bosie> test sp = sp:(test sp)
15:26:40 <bosie> why doesnt that compile
15:26:57 <SamB> you maybe want ++?
15:27:14 <bosie> nop
15:27:19 <bosie> ++ just works on chars doesnt it
15:27:19 <Lor> bosie, your cases are overlapping.
15:27:19 <bosie> ?
15:27:24 <SamB> well thats a type error
15:27:27 <bosie> Lor i beg your pardon?
15:27:50 <Lor> The latter case "test sp" matches _every_ string, including the empty string.
15:27:52 <SamB> are you trying to implement cycle?
15:27:59 <SamB> > cycle [1..10]
15:28:00 <lambdabot> [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,
15:28:00 <lambdabot> 6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,
15:28:00 <lambdabot> 1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,
15:28:00 <lambdabot> 6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,
15:28:00 <lambdabot> 1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,
15:28:02 <lambdabot> [23 @more lines]
15:28:04 <SamB> > cycle []
15:28:05 <lambdabot> Add a type signature
15:28:11 <bosie> i have no idea what a cycle is
15:28:11 <SamB> > cycle [] :: [Int]
15:28:13 <lambdabot> Prelude.cycle: empty list
15:28:16 <SamB> hmm
15:28:24 <Lor> bosie, what's your function meant to do?
15:28:38 <bosie> Lor oh well here we go:
15:29:10 <bosie> i pass a string (ie: "bo[test]hello[test]")
15:29:57 <bosie> and i want to return in a string-list all possiblities of this string.
15:29:57 <bosie> means: either i keep the []-parts in the string or not, for example
15:29:57 <bosie> ["botesthello","bohello","botesthellotest","bohellotest"]
15:30:36 <Lor> Are you certain that you understand how strings work?
15:30:45 <bosie> hm
15:30:53 <bosie> i guess so ;)
15:30:59 <Lor> Are you sure you want brackets _inside_ your strings?
15:31:07 <bosie> yes
15:31:17 <Lor> All right, so you want to actually parse it.
15:31:27 <bosie> and return all possibilities, yes
15:31:46 <bosie> i figured i write me a function which i call recursivle until there is no [] in the string anymore
15:31:49 <Lor> Using brackets may be a bit confusing, though, since they are also used in list syntax.
15:31:59 <bosie> well
15:32:19 <bosie> think of any other delimiter ... i could use say... @ for the start element and } for the endelement
15:33:29 <SamB> hmm
15:33:40 <Cale> use parsec
15:33:43 <Lor> There's nothing wrong with using the bracket character, as long as you know what you're doing.
15:33:50 <bosie> Lor ;)
15:33:51 <SamB> that does seem like the best idea
15:34:13 <Cale> it'd be silly not to, as you have to match brackets
15:34:30 <SamB> because my head hurts when I try to do that without monads
15:34:42 <SamB> even just thinking about it
15:34:45 <bosie> SamB what you mean?
15:35:10 <SamB> bosie: well, how do you handle ']'?
15:35:34 <bosie> it just tells me that the part between [] is optional and i want all combinations of [] in a string and return those strings
15:35:58 <SamB> nevermind, your better off not knowing
15:36:09 <Lor> No, the task is simple enough to do manually.
15:36:11 <Cale> right, but what about "[abc[def][ghi]]jkl"
15:36:14 <jeffno> bosie, did you say your test function didn't *compile*?  I can compile and run it, though it doesn't do what you want.
15:36:21 <Lor> You shouldn't start using tools until you understand what they do.
15:36:43 <Cale> are we allowed to nest the brackets?
15:36:51 <bosie> Cale yes
15:37:07 <bosie> jeffno yea it tells me that my function excpects String but the inferred type is [String]
15:37:20 <SamB> Lor: it makes my head hurt!
15:37:24 <Cale> then we need some way to tell which bracket matches which bracket
15:37:31 <bosie> Cale say... [[test]test would be equivalent to [test]test
15:37:45 <bosie> the first [ matches the first ]... i dont want to make it too complicated
15:38:03 <Cale> well, it's easy enough to do the right way
15:38:30 <bosie> Cale yea elementindeces of [ and ] first ] matches last [
15:38:31 <Cale> especially if you use a parsing monad like Parsec
15:38:49 <bosie> Cale nop
15:38:49 <Cale> [abc]def[ghi]
15:40:18 <bosie> Cale so?
15:40:31 <bosie> Cale combinations would be: def, abcdef, abcdefghi, defghi
15:40:33 <Cale> well, there the first [ doesn't match the last ]
15:40:47 <bosie> Cale right, the first last thingie was for nested brackets
15:43:12 <jethr0> bosie: just out of curiosity? are you trying to match a string (like with simplified regular expressions)?
15:43:31 <bosie> jethr0 yea
15:43:49 <jethr0> well, i'm sure there is some implementation of reg exps for haskell you could use...
15:44:04 <Cale> yeah, there's a regular expression library
15:44:05 <SamB> okay, to whom can I complain that the GHC darcs repo has too long a patchlist?
15:44:08 <bosie> jethr0 yes, but i wanna learn lists and text manipulation for now ;)
15:44:11 <jethr0> @google haskell regular expressions
15:44:12 <lambdabot> http://www.dcs.gla.ac.uk/~meurig/regexp/
15:44:14 <Cale> SamB: use --partial !!
15:44:50 <jethr0> bosie: but your idea is already pretty complex, methinks.
15:45:08 <SamB> Cale: its the file itself that I'm talking about
15:45:09 <phys_rules> dang, files produced by stage2 ghc dump core :\
15:45:20 <SamB> I did use partial
15:45:24 <Cale> oh
15:45:29 <Cale> how long is the file?
15:45:46 <bosie> jethr0 teacher said that maybe something like that is comming as the coding part of our next exam so i figured i wanna program it now... ;)
15:46:00 <bosie> so that i am not too surprised when it really comes...
15:46:21 <jethr0> unless i am imagining it as more diffucult that it is, this seems WAY too complex for an exam question...
15:46:26 <jethr0> than*
15:46:38 <SamB> okay, maybe not the actual inventory...
15:46:40 <bosie> jethr0 you should see our C-programming exam questions
15:47:09 <jethr0> hmm
15:47:11 <Cale> A parser for things is a function from strings to lists of pairs of things and strings!
15:47:40 <jethr0> cale: that's really verbose ;-)
15:47:56 <bosie> Cale right... ;)
15:48:08 <Cale> type Parser a = String -> [(a, String)]
15:48:15 <jethr0> ahh, much better
15:48:28 <bosie> brb
15:48:30 <Cale> now, you want a Parser [String]
15:48:36 <SamB> okay, I'm seeing a GET of /darcs/ghc/_darcs/inventories/20051130033234-c2a52-d0621fe0f3221a7bfedceae3244acbc211fc0ed1.gz
15:51:14 <SamB> -rw-r--r--  1 naesten naesten 449904 Nov 30 16:34 _darcs/inventories/20051130033234-c2a52-d0621fe0f3221a7bfedceae3244acbc211fc0ed1.gz
15:53:58 <dataangel> Why in the haskell tutorial for the add function does it say add :: Integer -> Integer -> Integer? Shouldn't it just be Integer -> Integer?
15:54:15 <Cale> how is add defined?
15:54:26 <Cale> add x y = x + y ?
15:54:26 <SamB> dataangel: dude, that would only take one argument
15:54:38 <Cale> addOne = add 1
15:55:19 <Cale> Integer -> Integer -> Integer is the same as Integer -> (Integer -> Integer), since (->) is right associative
15:55:55 <Cale> In some sense, all functions in Haskell take one argument. It's just that they potentially return a function which takes another argument.
15:56:27 <dataangel> Cale: That makes sense for if you only pass add 1 argument, since then you get a function that takes and returns an integer, but I don't see how that makes sense for when you supply add with both arguments.
15:56:33 <Cale> well
15:56:39 <Cale> add 1 2 = (add 1) 2
15:56:55 <Cale> you get back a function which takes the next parameter :)
15:57:08 <dataangel> is that how multiple parameters are always held? @_@
15:57:11 <Cale> yes
15:57:16 <dataangel> that's bizarre
15:57:21 <Cale> it's very very convenient
15:57:34 <Cale> here's a nice example
15:57:40 <Cale> map :: (a -> b) -> [a] -> [b]
15:57:53 <bosie> back
15:58:14 <Cale> map is a function which you pass it a function on values and it turns it into a function on lists of values
15:58:22 <Cale> > map (+1) [1,2,3,4,5]
15:58:23 <lambdabot> [2,3,4,5,6]
15:58:38 <dataangel> yeah, I'm reading that right now and my brain is exploding
15:58:52 <Cale> sometimes you care more about the function map (+1) than you care about any one of its results
15:59:09 <SamB> dataangel: thats normal
15:59:13 <Cale> It really changes the way you think about programming :)
15:59:18 <SamB> you will recover your senses in a few days
15:59:20 <Cale> hehe
15:59:22 <tic> mmm higher-order functions
15:59:53 <bosie> Cale actucally i was thinking of it this way: i just have a function which cuts the first [] out and replaces all the other [] by nothing (first found string) and then calls in a map the same functino (recursivly) with the untouched string except it replaces the first [] completely and removes the brackets of the second []
15:59:54 <jeffno> The hard part is when the missing argument is not explicit, as it is in operators.
15:59:55 <Cale> map can be seen as a function which transforms functions into other functions
16:00:14 <SamB> Cale: maybe you ought to have said map (1+)
16:00:26 <Cale> jeffno: not really any harder
16:00:35 <Cale> SamB: to avoid the implicit flip?
16:00:39 <araujo> bosie, i coded a small finSubString function if you are interested.
16:00:54 <jeffno> Cale: Well I find it as the "next hurdle" for me to overcome.
16:01:02 <bosie> araujo always
16:01:03 <Heffalump> 'lo
16:01:06 <bosie> whats finsubstring?
16:01:10 <SamB> Cale: yes
16:01:18 <araujo> Sorry, findSubString (mistyped)
16:01:31 <Cale> SamB: does it matter that much? I find (+1) reads better
16:01:39 <bosie> whats findsubstring
16:01:44 <araujo> bosie, findSubString "foo" "brZbarF00..foo" => True
16:02:01 <dataangel> I'm a bit confused
16:02:07 <dataangel> if all functions only really take one parameter
16:02:11 <dataangel> why do we define add with
16:02:15 <SyntaxNinja> there's no standard lib for a finite map who might have multiple range items per domain item?
16:02:16 <dataangel> add x y = x + y
16:02:20 <SyntaxNinja> or multiple values per key
16:02:24 <tic> dataangel, syntactic sugar. :)
16:02:26 <jeffno> Can you pick which argument to partially apply without converting prefix to infix?
16:02:32 <SamB> Cale: whatever, ti doesn't seem to have confused dataangel any
16:02:33 <bosie> araujo not sure how much that helps me
16:02:46 <Cale> jeffno: with lambda
16:02:47 <SamB> Cale: and yes, in real programs I always use (+1)
16:02:50 <dataangel> What is that syntactic sugar doing exactly?
16:03:03 <Cale> add = \x -> \y -> x + y
16:03:07 <dataangel> like, if I wanted to write it sugar free
16:03:09 <araujo> bosie, i thught you were looking for a way to get all the existent strings in a text?
16:03:10 <SyntaxNinja> it causes cancer of the semi-colon
16:03:13 <Cale> add = \x -> (\y -> x + y)
16:03:17 <tic> SyntaxNinja, hrhr :)
16:03:30 <bosie> araujo well, i am looking for all combinatinos of [] in a string
16:03:30 <araujo> mm..
16:03:40 <araujo> dataangel, hola?
16:03:56 <jeffno> Cale: Ok, thanks.
16:04:01 <araujo> bosie, give an example...
16:04:16 <bosie> sub[test]hallo[test]
16:04:16 <bosie> output: subhallo, subtesthallo, subhallotest, subtesthallotest
16:04:19 <dataangel> araujo: hola?
16:04:33 <Cale> jeffno: it doesn't really have the same implementation benefits, but it works
16:04:59 <dataangel> Cale: What's the \x and \y doing there? Tutorial hasn't mentioned \ yet
16:05:12 <Cale> ah
16:05:12 <araujo> bosie,  sub[test]hallo[test] is the input right?
16:05:19 <bosie> araujo yes
16:05:29 <araujo> dataangel, lambda == \
16:05:45 <Cale> (\x -> y) is a way of writing the function which takes a value 'x' and returns 'y'
16:05:48 <Cale> for example
16:05:52 <Cale> (\x -> x + x)
16:05:59 <Cale> is the function which doubles its parameter
16:06:06 <Cale> > (\x -> x + x) 10
16:06:07 <lambdabot> 20
16:06:11 <Cale> > (\x -> x + x) 15
16:06:13 <lambdabot> 30
16:06:16 * dataangel implodes
16:06:34 <Cale> so you can have functions without naming them
16:06:39 <tic> > double = (\x -> x*2)
16:06:40 <lambdabot>  parse error on input `='
16:06:42 <tic> bleh
16:06:53 <tic> > let double = (\x -> x*2) in double 10
16:06:54 <lambdabot> 20
16:07:01 <tic> dataangel, does that make more sense?
16:07:10 <dataangel> I'm getting it
16:07:14 <tic> double :: Num a => a -> a
16:07:29 <araujo> dataangel, in case you speak spanish, we've got #haskell.es
16:07:31 <tic> (was that right? Not quite sure which class has * defined)
16:07:32 <jeffno> Where is "=>" explained, btw?
16:07:38 <Cale> tic: yes
16:07:44 <tic> jeffno, that's a pre-condition on a
16:07:44 <dataangel> araujo: Ah, I don't :P
16:07:57 <araujo> dataangel, it is ok, i just thought you did :-]
16:08:01 <dataangel> oic
16:08:01 <Cale> jeffno: in the report and in just about every tutorial -- it goes with the stuff on typeclasses
16:08:40 <jeffno> I looked in the report, and in the syntax it mentioned it as "Concept", but didn't say anything about it.
16:08:50 <Cale> Concept?
16:08:56 <Cale> context
16:09:03 <Cale> It should say a bunch
16:09:06 <Cale> let me find it
16:09:09 <araujo> yeah, that's the context
16:09:26 * _Codex always thinks => as implication. :)
16:09:57 <araujo> double :. Num a => a -> a , means double is a function that takes an argument restricted by the context of the typeclass Num
16:10:14 <araujo> *And* return it under that context too.
16:10:22 <lisppaste2> jethr0 pasted "regexp after parsing" at http://paste.lisp.org/display/14165
16:10:24 <Cale> well, it'll be the same type
16:10:29 <dataangel> coming from a C mentality, this seems more intuitive: add :: (Integer, Integer) -> Integer
16:10:36 <Cale> dataangel: you can do that too
16:10:42 <dataangel> add (x, y) = x + y
16:10:42 <jethr0> it ain't pretty, but then i am just a newbie ^_^
16:10:50 <Cale> but that's a function which takes a tuple, and returns an integer
16:10:55 <dataangel> right
16:11:00 <araujo> dataangel, that is just not too haskellish :-P
16:11:00 <Philippa> dataangel: Integer's an instance of Num
16:11:02 <tic> all functions in haskell take only one argument.
16:11:08 <Cale> > let add x y = x + y in uncurry add (1,2)
16:11:10 <lambdabot> 3
16:11:21 <Cale> > let add (x, y) = x + y in curry add 1 2
16:11:22 <lambdabot> 3
16:11:24 <dataangel> if I do add 1 3 with it defined the tuple way though it won't work right? I have to do add (1, 3)
16:11:30 <Philippa> the currying stuff's good, partial application is your friend
16:11:31 <Cale> right
16:11:32 <Philippa> dataangel: right
16:11:43 <Philippa> which means you can't define inc = add 1
16:12:12 <dataangel> Cale: Eh? You can actually put the words curry and uncurry there?
16:12:14 <Cale> you'd have to write something like  inc = (\x -> add (1, x)) or inc x = add (1,x)
16:12:27 <Cale> dataangel: curry and uncurry are just functions
16:12:27 <Philippa> dataangel: they're ordinary functions
16:12:32 <Cale> they're in the prelude
16:12:37 <araujo> dataangel, the best (and right) way to look at it , is that (a,b) is by itself a datatype
16:12:40 <Cale> curry f (x,y) = f x y
16:12:45 <dataangel> right, I get the tuple distinction
16:12:45 <Cale> er
16:12:51 <Cale> curry f x y = f (x, y)
16:12:55 <dataangel> now I'm just surprised that curry and uncurry functions exist
16:12:59 <Cale> uncurry f (x, y) = f x y
16:13:04 <araujo> dataangel, That's why (neat) things like partial applications just won't work
16:13:20 <Philippa> mostly for pedagogical purposes AFAICT. I don't think I've ever seen them used in the wild
16:13:25 <araujo> dataangel, unless you've got stuff like, (\ x (a,b) -> .....  , :-)
16:13:58 <Cale> Philippa: I've seen them used, but yeah, it's very very rare :)
16:14:27 <Philippa> I'm thinking manhattan distance on vectors represented as tuples now
16:14:36 <Cale> by the way  \x y -> z is syntax sugar for \x -> \y -> z
16:14:47 <jethr0> @seen bosie
16:14:47 <lambdabot> bosie is in #haskell. Last spoke 9 minutes and 28 seconds ago.
16:14:54 <bosie> here
16:14:55 <Heffalump> Philippa: pointless, IM pointfree, style uses them sometimes
16:15:01 <bosie> sorry, did someone talk to me?
16:15:05 <jethr0> bosie: have a look at http://paste.lisp.org/display/14165
16:15:18 <Heffalump> see for example the chapter in Bird's book about the functional calculator
16:15:29 <Philippa> Heffalump: figures - I don't see the level of pointless style that'd involve that in the wild (as opposed to @pl results) either though
16:15:31 <jethr0> it's my (tentative) solution to your problem once your parsing problems are done.
16:15:33 * dons attempts to darcs get fptools
16:15:41 <Philippa> ah. Not read Bird's book
16:15:48 <dataangel> What exactly does the single : operator do? The tutorial says 'infix list constructor' but I don't know what to take from that :P
16:15:57 <Philippa> dataangel: 1:[2,3] = [1,2,3]
16:16:02 <araujo> dataangel, what tutorial are you reading?
16:16:09 <wilx> @type (:)
16:16:10 <lambdabot> forall a. a -> [a] -> [a]
16:16:14 <dataangel> a gentle introduction to haskell on haskell.org
16:16:16 <jethr0> > 1:(2:(3(:4)))
16:16:17 <lambdabot>  add an instance declaration for (Num [a])
16:16:25 <Philippa> jeffno: not quite
16:16:33 <bosie> jethr0 what the heck is that
16:16:33 <jethr0> ups
16:16:34 <Philippa> er, jethr0
16:16:35 <araujo> The (:) is the data list operator
16:16:36 <Lemmih> > 1:2:3:4:[]
16:16:37 <lambdabot> [1,2,3,4]
16:16:46 * jethr0 wasn't thinking straight
16:16:54 <Philippa> dataangel: "prepend to list", if you like
16:16:55 * jeffno looks like jethr0
16:16:59 <dataangel> what's the distinction between 1 ++ [2, 3] and 1:[2,3]?
16:17:05 <Philippa> jeffno: tab completion
16:17:19 <Philippa> dataangel: 1 ++ [2,3] will eventually evaluate to 1:[2,3]
16:17:20 <jeffno> Philippa, Cool, I was looking for that feature!
16:17:25 <jethr0> bosie: it takes a list like [Opt "abc", NonOpt "def", Opt "ghi"] and returns your solution.
16:17:26 <Philippa> er, wait
16:17:27 <Philippa> not it won't
16:17:32 <Lemmih> 1 ++ [2,3] doesn't make sense.
16:17:39 <Philippa> [1] ++ [2,3] = 1:[2,3]
16:17:46 <dataangel> err that's what I meant
16:17:47 <jethr0> where Opt stands for optional.
16:17:52 <dataangel> why do both exist?
16:17:53 <bosie> whats module where
16:17:54 <wilx> > [1] ++ [2,3] = 1:[2,3]
16:17:54 <lambdabot>  parse error on input `='
16:17:59 <wilx> > [1] ++ [2,3] == 1:[2,3]
16:18:00 <lambdabot> True
16:18:01 <Philippa> dataangel: ++ is written in terms of :
16:18:09 <Philippa> ++ is slower if you're prepending a single item
16:18:24 <Philippa> : is an ordinary data constructor (like Just and Nothing, for example)
16:18:26 <jethr0> bosie: optify [Opt "abc", NonOpt "def", Opt "ghi"]
16:18:30 <dataangel> for a high level language like haskell speed as the main reason for having both doesn't seem right
16:18:31 <araujo> That'd be something like: data [a] = a : [a] | []
16:18:33 <jethr0> yields ["def","abcdef","defghi","abcdefghi"]
16:18:35 <Philippa> it just happens to be an infix operator
16:18:47 <Philippa> dataangel: : is a data constructor. ++ is not
16:19:02 <Philippa> and if you have : only, you're gonna build ++ anyway
16:19:04 * jethr0 even sounds like jeffno
16:19:10 <Lemmih> dataangel: The two functions do two different things.
16:19:16 <dataangel> I guess I still don't get what : is doing then
16:19:25 <Philippa> it's building a new list from an item and another list
16:19:26 <liyang> : isn't a function. :)
16:19:36 <Philippa> liyang: all data constructors are functions, no?
16:19:42 <Philippa> they're just other things as well
16:19:45 <dataangel> the examples you just gave me all seemed like list cating :P
16:19:46 <Lemmih> liyang: But it is.
16:19:49 <liyang> well... okay. 
16:19:55 <araujo> dataangel, (:) is a data constructor that creates values of types 'list'
16:20:18 <Philippa> dataangel: have you met the data statement yet, or any type more complex than numbers?
16:20:20 <_Codex> (:) :: a -> [a] -> [a]
16:20:30 <Philippa> if not, you'll get it when you have done
16:20:55 <dataangel> Phillipa: Yeah, I've seen like data Color = Red | Green | Blue, and the data [a] = a : [a] | [] example (but I don't understand the latter yet)
16:21:00 <_Codex> (++) :: [a] -> [a] -> [a]     // that should show the difference between ++ and :
16:21:01 <dons> oh, my life is so great now I can type: darcs changes inside fptools :D hooray!
16:21:05 <bosie> jethr0 why u need module mail?
16:21:09 <araujo> dataangel, (:) == (cons) , if you programm in Lisp
16:21:19 <dons> @karma+ CosmicRay
16:21:19 <lambdabot> CosmicRay's karma raised to 4.
16:21:21 <Philippa> dataangel: try this intermediate one then
16:21:22 <jethr0> bosie: damn, that was supposed to spell Main
16:21:23 <jethr0> *g*
16:21:30 <Philippa> "data IntList = Cons Int IntList | Nil"
16:21:48 <dataangel> unfortunately I haven't studied lisp yet :/
16:21:57 <jethr0> bosie: there usually has to be a module Main when you want to compile the code (i hope this is correct).
16:22:02 <Philippa> Cons is equivalent :, only as an ordinary function. Nil is equivalent to []. It only takes Ints as items though
16:22:13 * dataangel must be trying to make this hard
16:22:15 <Philippa> do you understand how Cons works, or do you want it explained?
16:22:29 <dons> @where+ darcs-ghc darcs get http://cvs.haskell.org/darcs/ghc
16:22:29 <lambdabot> darcs-ghc ~> darcs get http://cvs.haskell.org/darcs/ghc
16:22:35 <dataangel> Philippa: Well, maybe let me try looking it up first. I've not heard of it before.
16:22:48 <Philippa> you'll get a load of lisp hits I'm afraid
16:22:53 <dons> @where+ darcs-libs darcs get http://cvs.haskell.org/darcs/libraries
16:22:54 <lambdabot> darcs-libs ~> darcs get http://cvs.haskell.org/darcs/libraries
16:22:58 <Philippa> either you understand how to read off that definition or you don't...
16:23:02 <Philippa> if the latter, we can explain
16:23:05 <dataangel> first hit is on the haskell wiki if I google 'haskell cons' ;)
16:23:14 <Philippa> that helps
16:23:35 <dons> @where+ hmp3 darcs get --partial http://www.cse.unsw.edu.au/~dons/code/hmp3
16:23:36 <lambdabot> hmp3 ~> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/
16:23:36 <lambdabot> hmp3
16:23:43 <Philippa> but really, you're better off looking at exactly what I defined, because it's a generic term that originates outside haskell rather than something specific to the IntList type I just defined
16:23:53 <jethr0> bosie: did that help or have i just confused you with my bad function naming??
16:24:07 <bosie> may i PM u?
16:24:33 <jethr0> try, not sure if i got that working yet...
16:24:40 <bosie> i already did
16:24:49 <dataangel> oh
16:24:58 <dataangel> except the wiki page is discussing the 'cons' of syntactic sugar :P
16:25:23 <jethr0> bosie: you can come to channel #bosie ;-)
16:25:35 <dataangel> this seems to say cons adds an item to the start of a list
16:25:42 <bosie> ok, but all my other fans from that channel will join ...
16:25:50 <jethr0> hehe
16:25:55 <Philippa> dataangel: Cons is a data constructor. That is, it's a function used for constructing values. Nil is also a data constructor, but because it doesn't take any parameters it's just an ordinary IntList value rather than a function that builds one
16:25:58 <Philippa> dataangel: yup
16:26:10 <bosie> lol now i did join #jethr0
16:26:12 <Philippa> the Cons function takes an Int and then an IntList as parameters
16:26:21 <Philippa> the end of the list is represented by Nil
16:26:43 <Philippa> much like a linked list in languages with pointers, if you like
16:27:28 <Philippa> then you can pattern-match on it using a case statement or (more commonly) a function definition. For example:
16:27:38 <dons> bosie, btw, I always found it cute when you first joined that in the problems you asked, you always named variables and types 'bosie' and 'Bosie' :) 
16:27:38 <Philippa> incrementItems Nil = Nil
16:27:49 <Philippa> ("incrementing the items of an empty list gives you an empty list")
16:27:54 <dons> bosie, just thought I'd say that :)
16:28:11 <ihope> 'Ello everybody...
16:28:15 <dataangel> Philippa: So for your example, it makes an intList datatype, because it's lazily evaluated, each time you get a function back that can be passed another int. So to add items to an intList would you just do "myintlist 3" like calling a function?
16:28:17 <Philippa> incrementItems (Cons x xs) = Cons (x+1) (incrementItems xs)
16:28:41 <bosie> dons thats cos i am a narcist
16:29:04 <Philippa> dataangel: it's not a laziness thing, it's a currying thing. To add an item you'd do "Cons 3 myintlist"
16:29:23 <dons> fair enough. /me wonders if your everyday code in fact contains 'bosie' variables
16:29:59 <bosie> dons they contain playboy, pimp and ofc bosie
16:30:07 * Philippa suspects dons is relieved that she just uses names like x or thing...
16:30:17 <dataangel> Philippa: Oh, thought that was what must be meant by lazy evaluation because it's lazy in the sense that it doesn't "need" a value now
16:30:23 <Philippa> bosie: you wanna be careful about that, I make pimps my bitches :-)
16:30:37 <Philippa> dataangel: nope. Lazy evaluation means you don't have to calculate the value when it's first passed
16:30:38 <bosie> Philippa whats worrying me more is that you have pimps
16:30:57 <dataangel> Phillipa: Ah.
16:30:57 <ihope> I'm having a bit of trouble with the "read" function. Whenever I pass it a string like "3.0", it gives a "no parse" error.
16:31:02 <Philippa> dataangel: what happens if you have "ones = Cons 1 ones"?
16:31:27 <dons> yes, I really prefer: f, g, n, x, y, xs, ys. that's it.
16:31:37 <dons> hehe
16:31:44 <Philippa> bosie: those aren't the kinds of variable names I used. And frankly, I wouldn't /need/ a pimp - I'm guessing you've not heard me on the subject of self-defence?
16:32:17 <bosie> Philippa i havent
16:32:20 <dons> hey Philippa, btw, long time no chat
16:32:44 <Philippa> dons: yeah. Unfortunately I'm going to be AFK for a couple of days after I go to bed (hopefully soon) - will be staying with a friend in birmingham
16:33:30 <dataangel> Philippa: ones has one more 1 in it? :P
16:33:48 <Philippa> dataangel: What other languages do you know?
16:33:50 <dataangel> Philippa: Or do you loop because lazy evaluation?
16:34:17 <ChilliX> dataangel: What's infinity plus one? ;)
16:34:21 <Philippa> ones has an infinite number of ones in it
16:34:26 <dataangel> I see
16:34:37 <musasabi> Has anyone tried GHC from darcs?
16:34:37 <dataangel> because it loops forever because ones isn't evaluated until after its passed?
16:34:48 <Philippa> dataangel: er, no. It *doesn't* loop forever
16:34:53 <dataangel> Philippa: C++, Python
16:34:58 <Philippa> you have to have something attempt to use all the ones in order to make that happen
16:35:09 <musasabi> ./configure complains for me: "config.status: error: cannot find input file: mk/config.h.in"
16:35:09 <dons> musasabi, I've downloaded it.  not tried to build it yet.
16:35:09 <dons> any troubles?
16:35:13 <Philippa> if you did this in C++:
16:35:18 <dons> did you: autoreconf ?
16:35:32 <musasabi> normal autoconf.
16:35:39 <dons> you need autoreconf
16:35:49 <ChilliX> > let ones = 1 : ones in take 5 ones
16:35:50 <lambdabot> [1,1,1,1,1]
16:35:54 <dons> whenever you see a missing .h.in file, that's almost always going to be a lack of autoreconf
16:36:05 <Philippa> struct IntList {int item; IntList &tail;}; ones = IntList(1, ones); and it compiled, it'd spend forever trying to build ones, right?
16:36:17 <ihope> Hmm, lambdabot...
16:36:26 <Philippa> (actually it wouldn't, d'oh)
16:36:43 <Philippa> if you had a function ones that did that however, it would
16:36:53 <musasabi> actually one could implement the same with lots of templates in C++
16:37:07 <musasabi> FC++ ;)
16:37:10 <Philippa> IntList ones () {return IntList (1, ones());}
16:37:11 <dons> ihope, lambdabot just sits at her desk all day evaluating scraps of haskell for us :)
16:37:16 <Philippa> ones() takes forever to run, right?
16:37:22 <ihope> :-)
16:37:38 <Philippa> or rather, it eventually runs out of memory. Assume a default constructor and all that crap...
16:37:39 <ihope> What if you told her to evaluate "repeat 1"?
16:37:50 <Philippa> she'll timeout
16:37:53 <Philippa> > repeat 1
16:37:54 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
16:37:54 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
16:37:54 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
16:37:54 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
16:37:54 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
16:37:56 <dons> not quite.
16:37:57 <lambdabot> [23 @more lines]
16:38:09 <dons> it'll get chopped at 2048 bytes.
16:38:15 <dons> > last (repeat 1)
16:38:20 <lambdabot> Terminated
16:38:21 <Philippa> ah. I assume there's a timeout as well?
16:38:23 <Philippa> yep
16:38:26 <ihope> > getLine
16:38:28 <lambdabot> No IO allowed
16:38:32 <ihope> Heh
16:38:36 <Philippa> dataangel: you still following?
16:38:52 <ChilliX> Philippa: no, still evaluating ;)
16:38:54 <dataangel> Philippa: Yeah, gimme a sec though
16:39:02 <dons> ChilliX, hehe
16:39:18 <ChilliX> Ok, I'm mean
16:39:21 * Philippa sighs
16:39:22 * ChilliX slaps his wrist.
16:39:28 <Philippa> sending viagra spam to dykes is just pointless...
16:40:35 <dataangel> Philippa: Yep, it would run forever. The stack would overflow from infinite recursion. There's no terminating condition.
16:41:07 <ihope> Which is better: Haskell or COBOL?
16:41:20 <jethr0> ihope: cobol, definitely
16:41:33 <_Codex> ihope: prolog
16:41:44 <dons> > scanr (*) 1 [1..]
16:41:47 <lambdabot> Stack overflow
16:42:02 <ihope> You see, the last element of the list of ones is 3.
16:42:39 <ihope> And there are a couple of bigger numbers before that one, like the Ackermann function on the numbers 28 and 295.
16:43:19 <_Codex> ever tried to do sum of all ones?
16:43:26 <Philippa> dataangel: right. In haskell it won't, because it won't evaluate a given Cons call until something needs to see it (that is, until something pattern-matches on it or some piece of IO needs the value)
16:44:18 <wilx> Hehe, associations are funny thing.
16:44:22 <dataangel> Philippa: So say I do that with ones, and then I say, hey haskell, I'd like the 53rd element of the list ones. Does it somehow know to request each element sequentially so ones will have been built that far or ?
16:44:27 <wilx> I have been reading the 6th book of the Dune series.
16:44:41 <wilx> Chapterhouse Dune.
16:44:59 <wilx> There are Monored Matres.
16:45:15 <_Codex> dataangel: it doesnt need the 1's, but it needs the :'s.
16:45:29 <dataangel> _Codex: Huh?
16:45:35 <wilx> And few minutes ago Philippa has been talking about "making pimps her bitches."
16:45:50 <wilx> It connected, Philippa = Honored Matre? :D
16:45:50 <Philippa> dataangel: it'll have to request the ones before the 53rd to find the 53rd
16:46:01 <Philippa> _Codex: right
16:46:09 <_Codex> dataangel: lazy eval considers : and 1 separately.
16:46:19 <Philippa> dataangel: it doesn't evaluate the "item" parameters winding through the other elements, just the "rest of list" ones
16:46:32 <dataangel> Philippa: In implentation then, are all haskell lists actually linked lists? Because if it were represented as an array it would just jump 53 bytes ahead and not need to evaluate 1-52
16:46:43 <_Codex> dataangel: only : for every 53 elements is needed. The 1's are not evaluated other than the last one.
16:46:48 <ChilliX> dataangel: just think of "let ones = 1 : ones" as a graph
16:47:04 <ChilliX> dataangel: there is one node (containg the 1) which points pack at itself
16:47:19 <ChilliX> Of course you can run around in circles in this thing as long as you want
16:47:26 <ChilliX> But building it is trivial and terminates
16:47:38 <Philippa> dataangel: getting on for it, yes
16:47:44 <ChilliX> (In fact, this is what the Haskell impl does.)
16:47:53 <ChilliX> pack = back
16:48:01 <ihope> > repeat . (take 3) Nothing
16:48:02 <lambdabot>   Expecting a function type, but found `[a]'
16:48:02 <lambdabot>   Expected type: a -> b
16:48:02 <lambdabot>   Inferred type: [a1]
16:48:14 <Philippa> dataangel: give or take. In theory it'd be possible for the compiler to implement some as arrays, but it'd usually make things slow in other ways
16:48:30 <dons> small Int lists are packed as arrays
16:48:32 <dons> in ghc.
16:48:42 <Philippa> ChilliX: not all implementations yield just the one data cell in memory, unfortunately
16:48:55 <Philippa> (at least, upon evaluation)
16:49:00 <ChilliX> Philippa: which ones does not?
16:49:09 <Philippa> amongst other things, the one running in my mind :-)
16:49:20 <ChilliX> Anything that's build on lazy graph reduction will have.
16:49:25 <ChilliX> have to
16:49:29 <Philippa> I think at least one of the abstract machines I've looked at doesn't either
16:49:35 <Philippa> BICBW
16:49:49 <Philippa> (insert a "possible" in my original statement if you like)
16:50:57 <ChilliX> In principle, you can always use more than one node with a 1 and just have the last one loop back.
16:51:01 <ihope> > (read "3.0") + 2
16:51:02 <lambdabot> Prelude.read: no parse
16:51:15 <ihope> So why is that?
16:51:22 <ChilliX> But without good reason (some sort of speculative eval) that's pointless.
16:51:56 <Philippa> you don't even need the last one to loop back, you're entitled to keep generating new 1:<thunk evaluating to 1:<th...>> cells ad infinitum
16:52:41 <_Codex> > let ones = 1 : ones in take 3 [ones, ones, ones, 1, ones, ones]
16:52:42 <lambdabot>  add an instance declaration for (Num [a])
16:52:42 <lambdabot>   In the list element: 1
16:53:19 <dons> > (read "3") + 2   {- ihope -}
16:53:21 <lambdabot> 5
16:53:41 <ihope> > (read "3.5") + 2
16:53:43 <lambdabot> Prelude.read: no parse
16:53:52 <dons> @type 3.5
16:53:53 <lambdabot> forall t. (Fractional t) => t
16:53:55 <dons> @type 2
16:53:56 <lambdabot> forall t. (Num t) => t
16:53:56 <ChilliX> Philippa: if you are dead set on avoiding cycles, yes
16:53:58 <_Codex> didnt work the way I first thought :)
16:54:00 <arjanb> > (read "3.5") + 2.5
16:54:01 <lambdabot> 6.0
16:54:17 <ihope> > (read "3.5") + (read "2.5")
16:54:18 <lambdabot> Prelude.read: no parse
16:54:43 <dons> > (read "3.5") + (read "2.5") :: Float
16:54:44 <lambdabot> 6.0
16:54:47 <dons> ;)
16:54:56 <ihope> !
16:55:19 <ihope> Hmm, I guess that works.
16:55:41 <ihope> Thanks
16:56:45 <_Codex> (!!) (ones : ones : ones : [[1]]) 3   works better for that, the ones are never evaluated when indexing the list. :)
16:57:54 <Philippa> ChilliX: you might be for the sake of a GC scheme with particular properties or something like that, I guess
16:57:55 <dons> > [undefined, undefined, 42, undefined] !! 2 {- for instance -}
16:57:58 <lambdabot> 42
16:58:12 <dons> I think -- style commens would be nice with @eval. hmm.
16:58:20 <ChilliX> Philippa: I don't think ti would help for GC, as updates could introduyce cycles, too
16:58:38 <ChilliX> And a lazy language per definition needs sharing
17:02:15 <dons> > map (+1) [1..5] -- is lots of fun
17:02:16 <lambdabot> [2,3,4,5,6]
17:02:25 <dons> that's better.
17:02:29 <ChilliX> dons: :)
17:07:03 <ihope> > (*2) . (+1) 3
17:07:04 <lambdabot>  add an instance declaration for (Num (a -> b))
17:07:22 <ihope> > (*2) . (+1) 3 :: Integer
17:07:23 <lambdabot>   Expecting a function type, but found `Integer'
17:07:23 <lambdabot>   Expected type: Integer
17:07:23 <lambdabot>   Inferred type: a -> b
17:07:34 <musasabi> > (*2) $ (+1) 3
17:07:35 <lambdabot> 8
17:07:50 <ihope> > ($)
17:07:50 <lambdabot>  add an instance declaration for (Show ((a -> b) -> a -> b))
17:07:58 <musasabi> @type ($)
17:07:59 <lambdabot> forall b a. (a -> b) -> a -> b
17:08:09 <ihope> :-)
17:08:30 <ihope> So just what does that do?
17:08:46 <musasabi> f $ x = f x
17:09:03 <ihope> Oh...
17:09:31 <ihope> And what does . do?
17:09:41 <dons> function composition.
17:09:52 <musasabi> so (*2) $ (+1) 3 is ~equal to (*2) ((+1) 3)
17:10:01 <musasabi> > (*2) ((+1) 3)
17:10:02 <lambdabot> 8
17:10:22 <ihope> So x . y z = y(x z)... right?
17:11:04 <musasabi> > ((*2) . (+1)) 3
17:11:04 <ChilliX> x . y $ z = x (y z)
17:11:05 <lambdabot> 8
17:11:14 <musasabi> it is about the parenthesises
17:11:24 <ihope> Aha.
17:11:25 <mwc> Is there a page on a wiki that explains what forall means? All I can find is this: http://www.haskell.org/hawiki/Keywords
17:11:51 <ihope> So it's an "after" rather than a "then"?
17:12:38 <ChilliX> yes
17:13:18 <ihope> concat . repeat . repeat $ 1
17:13:32 <ChilliX> :)
17:13:42 <_Codex> . is very useful
17:13:56 <_Codex> one of the most fundamental things related to functions
17:14:20 <ihope> What does seq do?
17:15:22 <mwc> takes the value of the first parameter, then discards it and lazily takes the value of the second
17:15:28 <wilx> Black magic, mostly :)
17:16:02 <ihope> Aha...
17:16:25 <ihope> So its first parameter is evaluated somehow before being thrown away?
17:16:30 <Cale> well, the value won't get discarded if it's being used elsewhere due to sharing
17:16:31 <mwc> yeah
17:16:32 <musasabi> mwc: forall means roughly the same as in predicate logic (there are some differences)
17:16:45 <mwc> ihope, it forces strict evaluation
17:16:46 <Cale> like in x `seq` f x
17:17:02 <Cale> which, in fact has a name:  f $! x = x `seq` f x
17:17:12 <ihope> Yep, that's why I asked.
17:17:23 <Cale> f $! x forces the evaluation of x to its top level constructor before applying f
17:18:00 <Cale> note that nothing happens until (f $! x) itself is evaluated of course.
17:18:10 <ihope> Hmm... s x y z = z $! x z $ y z
17:18:14 <Cale> seq gives you really fine level control over evaluation
17:18:23 <mwc> If I recall the report, seq _|_ _ = _|_ ; seq _ x = x
17:19:04 <mwc> the implication being that we don't know the value of the seq until the first parameter has been "entirely" evaluated
17:19:17 <ihope> Does the Report or something actually give a value to _|_?
17:19:30 <Cale> _|_ represents nontermination
17:19:33 <mwc> No, it means an uncomputable value
17:19:50 <Cale> (or generally some kind of error)
17:19:51 <ihope> Erm, as in _|_ = _|_? :-)
17:19:57 <Cale> yeah
17:19:59 <Cale> heh
17:20:01 <Cale> loop = loop
17:20:12 <ihope> bot = bot
17:20:20 <ihope> > bot where bot = bot
17:20:21 <lambdabot> Add a type signature
17:20:35 <Cale> also, things like  undefined = error "Prelude.undefined"
17:20:46 <Cale> > undefined :: Int
17:20:47 <lambdabot> Undefined
17:20:55 <bosie> night
17:20:58 <ihope> > error "Hello, world!" 3
17:20:59 <lambdabot> Add a type signature
17:21:01 <bosie> and thanks all
17:21:16 <ihope> > error "Hello, world!" 3 :: Integer
17:21:17 <lambdabot> Hello, world!
17:21:35 <ihope> A roundabout "hello world" program?
17:21:44 <Cale> hehe
17:22:04 <Cale> by the way, exceptions thrown by error can be caught in the IO monad
17:22:16 <ihope> Hmm, cool
17:22:54 <ihope> > return Nothing
17:22:55 <lambdabot>  add an instance declaration for (Show (m (Maybe a)))
17:23:08 <Cale> @type return Nothing
17:23:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Maybe a)
17:23:16 <araujo> Cale, exceptions can only be caught in the IO monad?
17:23:23 <Cale> araujo: yes
17:23:31 <araujo> Ok.
17:23:42 <Cale> if they could be caught elsewhere, it would break referential transparency
17:23:46 <palomer> one of my students _always_ dresses sexy when she comes to my office hours
17:23:48 <araujo> Right.
17:23:52 <palomer> too bad she has a mustache
17:24:10 <ihope> What is * -> *, exactly?
17:24:13 <Philippa> maybe she just always dresses sexy?
17:24:14 <Cale> It's a kind
17:24:33 <ihope> What's a kind?
17:24:34 <Cale> * is the kind of types
17:24:43 <Cale> * -> * is the kind of type constructors
17:24:45 <Philippa> ihope: "types of types"
17:24:52 <Cale> (which take one type and give another)
17:24:54 <Philippa> kinds are to types what types are to ordinary values
17:24:57 <Cale> @kind Maybe
17:24:58 <ihope> Ah right.
17:24:58 <lambdabot> * -> *
17:25:04 <Cale> @kind Maybe Integer
17:25:05 <lambdabot> *
17:25:27 <ihope> @kind *
17:25:28 <lambdabot> parse error on input `*'
17:25:31 <ihope> Tee hee.
17:26:52 <musasabi> Is there a reason that referring to RealWorld# inside .hsc files fails with link error: "GHC/HandleBase_hsc_make.o: In function `main':HandleBase_hsc_make.c:(.text+0x101): undefined reference to `hsc_RealWorld'" (or is it related to the fact that I am playing with GHC internals)
17:27:18 <ChilliX> I hate page limits of 8 pages in LNCS.
17:27:37 <ChilliX> You can't fit anything into that.
17:27:58 <ihope> Especially if it's a COBOL program...
17:28:05 <ChilliX> ihope: lol
17:28:42 <ihope> How about a SLOBOL program? They're *really* long.
17:28:52 <Heffalump> 8 LNCS pages? What for?
17:29:32 <ChilliX> http://graal.ens-lyon.fr/~abenoit/conf/papp2006.html
17:31:49 * Heffalump 's grid detector goes off repeatedly
17:32:05 <ChilliX> hehe
17:32:15 <ChilliX> Don't worry, I am not doing anythign with grids...
17:32:35 <Heffalump> I didn't think you would be :-)
17:32:37 <ChilliX> But any conference about anything parallel will have grid in the CFP...unfortunaterly.
17:36:51 <dons> @seen Lemmih
17:36:52 <lambdabot> Lemmih is in #haskell-blah and #haskell. Last spoke 1 hour, 17 minutes
17:36:52 <lambdabot> and 5 seconds ago.
17:37:17 <dons> Lemmih, any ideas on how to add a cabal version requirement to Setup.hs?
17:37:43 <dons> I guess I could do it by hand. urgh.
17:38:30 * dons imagines system "ghc-pkg list Cabal" >>= maybeYourCabalIsToOld
17:40:23 <Lemmih> Cabal >=1.0?
17:40:49 <Lemmih> Oh, you don't want to link with Cabal?
17:41:00 <dons> nope. 
17:41:29 <dons> I have two casess now where the project won't build if the cabal is too old, but the user won't know until it doesn't build ;)
17:42:12 <dons> so, much as configure scripts let you specificy a minimum autoconf version, so to with Setup.hs scripts.
17:42:13 <Lemmih> Maybe Cabal should expose Distribution.Version.cabalVersion.
17:42:25 <dons> and a version check hook
17:43:01 <Lemmih> But that'll fail if the script isn't compilable.
17:43:11 <Lemmih> Which is the case most of the time.
17:43:24 <dons> ah, hmm.
17:44:13 <dons> not always, actually. it is for the extra hooks change, but for the problems with cbits and some issues with building executables -- they just show up as weird issues at the end of the build
17:44:19 <dons> the script itself type checks.
17:45:12 <dons> so, yeah, there are known backwards-incompatible changes. but there are also bug fixes that don't break the types, but do mean you need a newer cabal for things to work.
17:45:36 <dons> maybe these problems go aways with a stable Cabal after the next ghc anyway
17:45:48 <dons> as it seems to be basically ok in the darcs  branch.
17:46:00 <dons> SyntaxNinja: release a new cabal! ;)
17:46:46 <moonlite> dons: you're the maintainer of hs-plugins right?
17:46:52 <nuffer> what's the quickest way to express the list that consists of False 150 times?
17:46:56 <Lemmih> Parsing the result of `pkg-pkg field Cabal version` should be trivial. You could have a two-phase Setup script.
17:47:12 <Lemmih> > length $ replicate 150 False
17:47:13 <lambdabot> 150
17:47:23 <dons> Lemmih, yep. 
17:47:26 <nuffer> thanks
17:47:27 <dons> moonlite. yes I am.
17:47:37 <moonlite> do you know if there are or should be any problems using hs-plugins on a native amd64-system?
17:47:48 <nuffer> will I get kicked if I have lambdabot execute "replicate 150 False"?
17:47:58 <Lemmih> > replicate 150 False
17:47:59 <lambdabot> [False,False,False,False,False,False,False,False,False,False,False,False,
17:47:59 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,False,
17:47:59 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,False,
17:47:59 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,False,
17:47:59 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,False,
17:48:01 <lambdabot> [8 @more lines]
17:48:11 <nuffer> oh, not so bad
17:48:14 <dons> I don't know of any issues. and hs-plugins does work on 64 bit archs. not sure how stable the dynamic linker is on amd64 though. does ghci work for you?
17:49:39 <moonlite> i belive so
17:49:54 <dons> are you having trouble?
17:50:00 <dons> or just checking before diving in ;)
17:50:12 <moonlite> :)
17:50:20 <moonlite> actually, i'm not admin on the machine in question. it's our project-machine for a school-project here at chalmers and it is amd64. we've been having various problems installing hsp actually
17:50:45 <dons> ah, I think gus said something about this too.
17:50:51 <moonlite> and we are not sure, but we think it might be hs-plugins. 
17:51:07 <dons> do you have any error messages yet? does the hs-plugins testsuite run?
17:51:11 <moonlite> yeah, he's the one using his spare-time trying to compile hsp :)
17:52:24 <moonlite> heh, i have none. its only gus thats been trying so far. i didn't know he'd already spoken to you
17:53:13 <dons> well, if you see him, get him to try to run the hs-plugins testsuite, and mail me the result. and also feel free to mail me any weird hs-plugins errors.
17:53:28 <moonlite> ok eat
17:53:29 <dons> so far noone's shown me any error messages, so it's hard to debug ;)
17:53:32 <moonlite> umm, neat
17:53:44 <moonlite> heh :)
17:54:38 <moonlite> anyway, hs-plugins is masked "-amd64" on gentoo with a comment "currently broken on amd64"
17:54:52 <ihope> I tawt I taw a . It's not a putty tat, is it?
17:55:10 <dons> hmm. interesting. that's probably because they don't have a working ghci for amd64 on gentoo?
17:55:11 <moonlite> i wouldn't say that that is something one should trust immediately, but atleast someone else has had problems
17:55:38 <dons> unless there's some other problem that people aren't telling me about!
17:56:01 <ihope> > ''
17:56:02 <lambdabot>  lexical error in string/character literal
17:57:26 <moonlite> i'll try and search gentoo's bugzilla some and talk to gus some more later too. now off to sleep
18:03:36 <ihope> Is it possible to create a (lazily evaluated) infinite MP3 file?
18:05:03 <dons> ihope, depends on the mp3 format. maybe it needs to read the whole file before it starts playing. not sure.
18:05:22 <dons> if it reds it incrementally, in a stream-like fashion, then sure.
18:05:33 <jethr0> i think it only needs to read the file if it wants to determine its playing length.
18:05:39 <eivuokko> Yeah.
18:05:57 <jethr0> and reading an mp3 stream-like is quite feasible, i guess
18:06:21 <dons> the play length isn't stored in a field?
18:06:31 <dons> maybe not.
18:06:35 <eivuokko> Nope.
18:06:36 <jethr0> no, i don't think so.
18:06:42 * araujo in middle of a dilemma
18:06:47 <jethr0> i remember that i had to calculate it last time.
18:06:56 <ihope> So I could write a web server thinger that serves the whole pi song?
18:07:00 <jethr0> but then there's always my stupidity to  deal with ;-))
18:07:18 <palomer> anyone see the pi movie?
18:07:21 <palomer> it's genius
18:07:29 <jethr0> hmm, but mp3s have frames and if the frame headers are missing it will not play it easily.
18:07:40 <ihope> Is that the one with the perfect circle?
18:07:47 <jethr0> yup, seen it quite a while ago. that man is going crazy!
18:09:37 <nuffer> getFilledTiles' :: Array (Int, Int) Bool -> (Int, Int)
18:09:37 <nuffer> getFilledTiles' a = indices a
18:09:40 <nuffer> why does that fail?
18:10:01 <nuffer> Couldn't match `(Int, Int)' against `[i]'
18:10:04 <nuffer> rather, that's why it fails
18:10:06 <nuffer> but why is that coming up?
18:10:10 <nuffer> the function is typed correctly, no?
18:10:26 <dons> apparently not.
18:10:32 <dons> @type Data.Array.indices
18:10:33 <lambdabot> forall i e. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> [i]
18:10:46 <nuffer> I mena
18:10:49 <nuffer> mean rather
18:10:52 <dons> so you need a [(Int,Int)]
18:10:57 <nuffer> didn't I specify that "i" is (Int, Int)
18:11:06 <syntaxfree> yo.
18:11:06 <dons> and indices returns a [i]
18:11:17 <syntaxfree> @karma+ dons
18:11:18 <lambdabot> dons's karma raised to 18.
18:11:28 <nuffer> ahhh
18:11:37 <nuffer> it was making a pretty unclear error there
18:11:38 <nuffer> thanks
18:11:38 <jethr0> dons is the karma _champion_
18:11:56 <dons> I think: Couldn't match `(Int, Int)' against `[i]'  is pretty good, as far as ghc errors go ;)
18:12:00 <dons> @ghc
18:12:01 <lambdabot>  lexical error in string/character literal
18:12:02 <jethr0> ;-)
18:12:04 <dons> @ghc
18:12:04 <lambdabot>  You need -fglasgow-exts to derive an instance for this class
18:12:09 <syntaxfree> we should consistently reward helping hands, especially if involved, with karma.
18:12:14 <dons> @ghc
18:12:15 <lambdabot>  Cannot desugar this Template Haskell declaration
18:12:19 <dons> you could have got that ^^
18:12:24 <jethr0> @karma jethr0
18:12:25 <lambdabot> You have a karma of 0
18:12:27 <jethr0> ohh
18:12:34 <syntaxfree> @karma syntaxfree
18:12:35 <lambdabot> You have a karma of 1
18:12:54 <dons> @ghc
18:12:55 <lambdabot>  Multiple default declarations
18:13:08 <ihope> I don't suppose a person could increment his/her own karma value?
18:13:13 <jethr0> @karma JaffaCake
18:13:13 <lambdabot> JaffaCake has a karma of 4
18:13:14 <dons> oh, these are easy errors. where's a bad one?
18:13:16 <dons> @ghc
18:13:17 <lambdabot>  Can't happen
18:13:22 <dons> like that!! ^^
18:13:24 <syntaxfree> ihope only with a second client.
18:13:28 <dons> then you cry and go home.
18:13:39 <syntaxfree> I have problems.
18:13:49 <jethr0> *yeah*, second and third client coming up...
18:13:54 * ihope develops the Dragon Karma System
18:14:10 * syntaxfree will trade slashdot karma for #haskell karma.
18:14:18 <ihope> @karma lambdabot
18:14:19 <lambdabot> lambdabot has a karma of 7
18:14:21 <jethr0> me too
18:14:28 <jethr0> @karma+ lambdabot
18:14:28 <lambdabot> lambdabot's karma raised to 8.
18:14:49 * jethr0 is a huge fan of lambdabot *hug*
18:14:51 <syntaxfree> it would be interesting to have an internet karma system that can be used by various services.
18:14:58 <ihope> Ooh!
18:15:00 <syntaxfree> online forums could use it, IRC bots, etc.
18:15:06 <ihope> Using the DKS?
18:15:08 <ihope> :;-)
18:15:12 <jethr0> to achieve what. haskell karma doesn't exactly buy you anything, does it?
18:15:19 <ihope> (oops, mutant emoticon)
18:15:32 <jethr0> it's like the six-eyes fish on the simpsons.
18:15:37 <jethr0> smiling...
18:15:50 <syntaxfree> I guess.
18:15:59 <syntaxfree> how old are y'all?
18:16:17 <jethr0> but it still would be cool elsewhere, to get better visibility like on slashdot...
18:16:29 <jethr0> asl? ???
18:16:43 <syntaxfree> just age.
18:16:48 <jethr0> 25
18:16:51 <ihope> > error "@karma+ lambdabot" :: Integer
18:16:53 <lambdabot>  @karma+ lambdabot
18:17:07 <ihope> Bah...
18:17:20 <jethr0> > show "hello"
18:17:21 <lambdabot> "\"hello\""
18:17:29 <jethr0> > show 'hello'
18:17:30 <lambdabot>  lexical error in string/character literal
18:17:33 <syntaxfree> @eval words "Hello"
18:17:35 <lambdabot> ["Hello"]
18:17:50 <jethr0> @eval 5
18:17:50 <syntaxfree> @eval words "H e l l o"
18:17:51 <lambdabot> 5
18:17:51 <lambdabot> ["H","e","l","l","o"]
18:17:58 <jethr0> @eval "hello"
18:17:59 <lambdabot> "hello"
18:18:04 <jethr0> @eval hello
18:18:05 <lambdabot>  Not in scope: `hello'
18:18:13 <jethr0> @echo "hello"
18:18:14 <lambdabot> echo; msg:Message {msgPrefix = "jethr0!n=jethr0@p54A34D4C.dip.t-dialin.
18:18:14 <lambdabot> net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \"hello\""]}
18:18:14 <lambdabot> rest:"\"hello\""
18:18:20 <ihope> !
18:18:26 <jethr0> aaahh
18:18:46 <syntaxfree> @eval let f x = if x==[] then [] else head x: f (tail x) in f "Hello"
18:18:47 <lambdabot> "Hello"
18:18:52 <syntaxfree> oh the putz.
18:19:16 <syntaxfree>  @eval let f x = if x==[] then [] else head x: " ": f (tail x) in (words.f) "Hello"
18:19:33 <syntaxfree> @eval let f x = if x==[] then [] else head x: " ": f (tail x) in (words.f) "Hello"
18:19:34 <lambdabot> Couldn't match `Char' against `[Char]'
18:20:19 <syntaxfree> what is the opposite operation to "show"?
18:20:24 <ihope> read
18:20:31 <syntaxfree> @eval show ["H", "e", "l", "l", "o"]
18:20:33 <lambdabot> "[\"H\",\"e\",\"l\",\"l\",\"o\"]"
18:20:34 <jethr0> > read "hello"
18:20:35 <lambdabot> Add a type signature
18:20:39 <ihope> > read "\"Hello\""
18:20:41 <lambdabot> Add a type signature
18:20:44 <ihope> > read "\"Hello\"" :: String
18:20:45 <lambdabot> "Hello"
18:20:47 <syntaxfree> > 2 +2
18:20:48 <lambdabot> 4
18:20:53 <syntaxfree> oh, teh cool
18:20:59 <ihope> > read "2+2" :: Integer
18:21:00 <lambdabot> Prelude.read: no parse
18:21:02 <jethr0> syntaxfree: what _are_ you trying?
18:21:20 <syntaxfree> I want to transform "Hello" in ["H", "e", " l", "l", "o"]
18:21:31 <ihope> > concat ["H", "e", " l", "l", "o"]
18:21:33 <lambdabot> "He llo"
18:21:38 <jethr0> unwords or so?
18:21:48 <syntaxfree> (unwords.intersperse), I guess.
18:21:53 <syntaxfree> @type intersperse
18:21:54 <lambdabot> Not in scope: `intersperse'
18:22:00 <jethr0> it's the same thing, you know!
18:22:01 <syntaxfree> @hoogle intersperse
18:22:02 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
18:22:14 <Lemmih> > map (:[]) "Hello"
18:22:15 <lambdabot> ["H","e","l","l","o"]
18:22:20 <jethr0> "Hello" == ["H","e","l","l","o"]
18:22:24 <syntaxfree> > (unwords.intersperse " ") "Hello"
18:22:25 <lambdabot> Couldn't match `String' against `Char'
18:22:31 <jethr0> > "Hello" == ["H","e","l","l","o"]
18:22:32 <lambdabot> Couldn't match `Char' against `[Char]'
18:22:38 <syntaxfree> map (:[]) is pretty good.
18:22:50 <jethr0> > "Hello" == ['H','e','l','l','o']
18:22:51 <lambdabot> True
18:22:58 * ihope was gonna do that
18:23:03 <syntaxfree> I'm trying to find a case where doing a recursion by hand is justifiable :-)
18:23:24 <dons> plenty of times you need to write fast loops
18:23:25 <syntaxfree> (unwords.(intersperse " ")) "Hello"
18:23:41 <ihope> > (unwords.(intersperse " ")) "Hello"
18:23:42 <lambdabot> Couldn't match `String' against `Char'
18:23:55 <syntaxfree> ?
18:23:56 <jethr0> > unwords "Hello"
18:23:57 <lambdabot> Couldn't match `String' against `Char'
18:23:59 <ihope> @type unwords.intersperse
18:24:00 <lambdabot> Not in scope: `intersperse'
18:24:08 <jethr0> unwords is wrong!
18:24:18 <jethr0> > unwords "hello world"
18:24:19 <lambdabot> Couldn't match `String' against `Char'
18:24:20 <syntaxfree> > intersperse "z" "H ello"
18:24:21 <lambdabot> Couldn't match `[Char]' against `Char'
18:24:22 <jethr0> > words "hello world"
18:24:23 <lambdabot> ["hello","world"]
18:24:27 <ihope> 'd' != ' '
18:24:30 <syntaxfree> oh true.
18:24:45 <syntaxfree> > (words. (intersperse " ")) "I have a problem"
18:24:46 <lambdabot> Couldn't match `Char' against `[Char]'
18:24:59 <jethr0> you need a function Char->String
18:25:09 <jethr0> like (:[])
18:25:15 <syntaxfree> I know what I'm doing wrong.
18:25:24 <syntaxfree> > (words. (intersperse ' ')) "I have a problem"
18:25:25 <lambdabot> ["I","h","a","v","e","a","p","r","o","b","l","e","m"]
18:25:34 <jethr0> nice
18:25:36 <syntaxfree> "x" is  a string, 'x' is a char
18:25:37 <ihope> Hmm
18:25:44 <jethr0> yup
18:25:53 <ihope> @kind Either
18:25:54 <lambdabot> * -> * -> *
18:26:18 <jethr0> syntaxfree: although it's kind of an awkward solution
18:26:46 <syntaxfree> map (:[])  is wrong because of this. Looky:
18:26:56 <syntaxfree> > map (:[]) "I have a problem with whitespace. See?"
18:26:57 <lambdabot> ["I"," ","h","a","v","e"," ","a"," ","p","r","o","b","l","e","m"," ","w","
18:26:57 <lambdabot> i","t","h"," ","w","h","i","t","e","s","p","a","c","e","."," ","S","e","e"
18:26:57 <lambdabot> ,"?"]
18:27:10 <rep> hehe
18:27:12 <jethr0> i didn't know you didn't want white space!
18:27:20 <syntaxfree> > (words.(intersperse ' ')) "This is what I want"
18:27:21 <lambdabot> ["T","h","i","s","i","s","w","h","a","t","I","w","a","n","t"]
18:27:41 <jethr0> filter (!=' ') . map (:[]) $ "hello world"
18:27:45 <jethr0> > filter (!=' ') . map (:[]) $ "hello world"
18:27:46 <lambdabot>  Not in scope: `!='
18:27:55 <jethr0> > filter (/=' ') . map (:[]) $ "hello world"
18:27:56 <lambdabot> Couldn't match `Char' against `[a]'
18:28:02 <rep> " "
18:28:10 <jethr0> > filter (/=" ") . map (:[]) $ "hello world"
18:28:10 <ihope> > filter ((!=)' ') . map (:[]) $ "hello world"
18:28:11 <lambdabot> ["h","e","l","l","o","w","o","r","l","d"]
18:28:11 <lambdabot>  Not in scope: `!='
18:28:24 <syntaxfree> ihope: I was about to do that.
18:28:31 <syntaxfree> (!=) is an infix function.
18:29:46 <syntaxfree> > (lines.(intersperse ' ')) "This is \nuseful too"
18:29:47 <lambdabot> ["T h i s   i s   "," u s e f u l   t o o"]
18:29:53 <syntaxfree> oops.
18:30:04 <ihope> Nuseful eh? ;-)
18:30:09 <syntaxfree> > (lines.(intersperse '\n')) "This is possible too"
18:30:11 <lambdabot> ["T","h","i","s"," ","i","s"," ","p","o","s","s","i","b","l","e"," ","t","
18:30:11 <lambdabot> o","o"]
18:30:33 <jethr0> > (words.(intersperse ' ')) "This is \nuseful too"
18:30:34 <lambdabot> ["T","h","i","s","i","s","u","s","e","f","u","l","t","o","o"]
18:30:56 <ihope> Whew. What are we trying to accomplish here? :-)
18:31:12 <jethr0> syntaxfree: but now you got " " again!
18:31:22 <syntaxfree>  that can be fixed.
18:31:24 <jethr0> @localtime syntaxfree
18:31:30 <ihope> @arr
18:31:30 <lambdabot> Avast!
18:32:06 <jethr0> @localtime jethr0
18:32:09 <lambdabot> Local time for jethr0 is Thu Dec  1 03:31:49
18:32:14 <ihope> 	> error "> error \"Hello\" :: Integer" :: Integer
18:32:19 * jethr0 is going to bed now!
18:32:24 <ihope> Eh, how'd that happen?
18:32:29 <syntaxfree> > (map (:' '). lines . (intersperse '\n')) "What here?"
18:32:30 <lambdabot> Couldn't match `[a]' against `Char'
18:32:32 <ihope> > error "> error \"Hello\" :: Integer" :: Integer
18:32:33 <lambdabot> > error "Hello" :: Integer
18:32:53 <syntaxfree> (map (++"  "). lines . (intersperse '\n')) "What here?"
18:33:02 <dons> lambdabot's not that silly ;)
18:33:11 <syntaxfree> > (map (++"  "). lines . (intersperse '\n')) "What here?"
18:33:12 <lambdabot> ["W  ","h  ","a  ","t  ","   ","h  ","e  ","r  ","e  ","?  "]
18:33:30 <jethr0> good night
18:33:34 <syntaxfree> > (words. concat . map (++"  "). lines . (intersperse '\n')) "What here?"
18:33:35 <lambdabot> ["W","h","a","t","h","e","r","e","?"]
18:33:40 <syntaxfree> fixed!
18:33:51 * syntaxfree does the "I win"  dance.
18:33:52 <jethr0> yacc
18:34:05 <ihope> Bbut what does it *do*?
18:34:10 <jethr0> > words . lines . (intersperse '\n') $ "hello world"
18:34:11 <lambdabot> Couldn't match `Char' against `String'
18:34:23 <syntaxfree> > (words. concat . map (++"  "). lines . (intersperse '\n')) "syntaxfree has clearly won here as all in the room can see"
18:34:24 <lambdabot> ["s","y","n","t","a","x","f","r","e","e","h","a","s","c","l","e","a","r","
18:34:24 <lambdabot> l","y","w","o","n","h","e","r","e","a","s","a","l","l","i","n","t","h","e"
18:34:24 <lambdabot> ,"r","o","o","m","c","a","n","s","e","e"]
18:34:56 <jethr0> > map words . lines . (intersperse '\n') $ "hello world"
18:34:57 <lambdabot> [["h"],["e"],["l"],["l"],["o"],[],["w"],["o"],["r"],["l"],["d"]]
18:35:02 <jethr0> *damn*
18:35:27 <jethr0> well, n8
18:35:28 <syntaxfree> > 'T':"his should work"
18:35:29 <lambdabot> "This should work"
18:35:50 <ihope> What if I *really* want IO with Lambdabot? :-)
18:36:11 <syntaxfree> > putStr "oh please"
18:36:12 <lambdabot> No IO allowed
18:36:24 <syntaxfree> > putStr "Is IO allowed?"
18:36:25 <lambdabot> No IO allowed
18:36:34 <syntaxfree> and hereby lambdabot passes the turing test.
18:36:37 <ihope> > error "I guess I can always do this." :: ()
18:36:38 <lambdabot> I guess I can always do this.
18:36:44 <JohnMeacham> > unsafePerformIO (putStr "hello")
18:36:45 <lambdabot>  Not in scope: `unsafePerformIO'
18:36:55 <JohnMeacham> > System.IO.Unsafe.unsafePerformIO (putStr "hello")
18:36:56 <lambdabot>  Not in scope: `System.IO.Unsafe.unsafePerformIO'
18:37:06 <ihope> > error "> error \"I can't do this, however.\" :: ()" :: ()
18:37:07 <lambdabot> > error "I can't do this, however." :: ()
18:37:55 <syntaxfree> > error "it's not \n the same \n  \t or is it? \n"
18:37:57 <lambdabot> Add a type signature
18:38:11 <syntaxfree>  > error "it's not \n the same \n  \t or is it? \n" :()
18:38:21 <syntaxfree> > error "it's not \n the same \n  \t or is it? \n" ::()
18:38:22 <lambdabot> it's not
18:38:22 <lambdabot>  the same
18:38:22 <lambdabot>     or is it?
18:38:36 <syntaxfree> yippee. #haskelll floody goodiness  :-P
18:38:54 <ihope> There's nobody on #haskelll.
18:38:59 <ihope> Except me...
18:39:36 <dons> syntaxfree, ihope, you can always play games with lambdabot in #haskell-overflow or in a private message.
18:39:47 <syntaxfree> I know. Sorry.
18:39:58 <syntaxfree> I use Haskell like some peopple use booze.
18:43:57 <Speck> Is there any source code available for Henrik Nilsson's Yampa+GADT optimizations?
18:49:07 <lisppaste2> joelr1 pasted "wierd stuff" at http://paste.lisp.org/display/14171
18:49:18 <joelr1> howdy folks
18:49:28 <joelr1> would someone take a look at my issue please?
18:52:03 <shapr> f
18:52:12 <joelr1> shapr: ?
18:52:14 <shapr> oops, wrong window
18:52:20 <shapr> I obviously need sleep.
18:52:27 <joelr1> shapr: can you help?
18:52:28 * shapr has been trying to fix the RSS generating code in PLog.
18:52:32 * shapr looks
18:53:07 <Speck> PLog?
18:53:13 <shapr> joelr1: no clue, sorry.
18:53:24 <joelr1> shapr: ok, thanks!
18:53:25 <shapr> Speck: Peter Gammie's blog software written in Haskell.
18:53:25 <Speck> shapr: have you seen the Yampa+GADT paper?
18:53:35 <shapr> No, only the acm summary.
18:53:46 <joelr1> Cale: ping
18:53:54 <shapr> I would very much like to see the paper, but I am not willing to get a copy if it's not freely available.
18:53:55 <joelr1> SamB: ping
18:54:01 <Speck> it's freely available
18:54:11 <shapr> Where?
18:54:20 <shapr> I only found the reference on his home page.
18:54:21 <joelr1> dcoutts: ping
18:54:28 <joelr1> dons: ping
18:54:44 <Speck> hmm -- I do have a acm membership but I remember seeing it. let me look
18:54:56 <shapr> Speck: If it's freely available, then yes, Frag is a perfect testing ground for it.
18:55:03 <Speck> yeah that's what I thought
18:55:05 <shapr> Frag already requires 6.4.1
18:55:32 <shapr> If the paper is acm-only, I won't read it, due to my boycott of for-pay-only research paper services.
18:55:43 <Speck> I get it through my school
18:55:58 <shapr> I'm self-employed, the owner and employee of my company.
18:56:16 <dons> shapr, only due to HOpenGL 2.0. If you can install HOpenGL with 6.2.2, then that would also work. We're not sure if that's possible though.
18:56:19 <Speck> academia and economia have never mixed well, nor should they
18:56:22 <dons> @hawiki Frag
18:56:22 <lambdabot> http://www.haskell.org/hawiki/Frag
18:56:30 <joelr1> dons: can you give me a hand please?
18:56:32 <dons> and it should only need 6.4, not 6.4.1
18:56:36 <shapr> Speck: I disagree, I'd like to follow joelr1's example and be a profitable and intellectual contract programmer.
18:56:46 <dons> joelr1, I'm having a look.
18:56:56 <joelr1> shapr: ;)
18:57:00 <dons> shapr, yeah. it just says 6.4 on the Frag page.
18:57:05 <Speck> shapr: yes, there is nothing wrong with involving both -- I just think ideas should be free
18:57:18 <joelr1> i'm still banging at the same stuff :( going into my 3d month now and running out of money
18:57:32 <shapr> I think the attitude that academia does not mix with the outside world is obviously the whole ivory tower viewpoint.
18:58:36 <dons> joelr1, can't see anything there that's munging your state.
18:58:49 <dons> is your 'get' a read, or a take?
18:58:57 <joelr1> dons: that's what i'm trying to figure out
18:59:03 <joelr1> dons: what do you mean?
18:59:11 <shapr> Speck: Yeah, I think they should find a better way to mix.
18:59:14 <joelr1> dons: type ScriptState = ErrorT String (StateT World IO)
18:59:22 <Speck> perhaps poorly phrased. what I meant was that you can't really employ economics (probably capitalism specifically) to academia for a number of reasons. Primarily it needlessly overfocuses the evolution of thought. (this is turning into a -blah conversation though)
18:59:37 <shapr> Speck: You make an excellent point.
19:00:01 <shapr> And yet, I do not request the helm of academia, I merely wish to look in the cargo hold.
19:00:13 * shapr grins
19:00:13 <joelr1> dons: does recursion matter here?
19:00:39 <joelr1> dons: cause i'm going like this        runner state' dispatcher
19:00:39 <dons> joelr1, should you be doing something with the state returned  by peek?
19:00:44 <shapr> Speck: I don't want to tell the academics what to do, I just want to know what they found out. :-)
19:00:51 <joelr1> where state' is Stop
19:01:00 <dons> i.e. s' <- peek ; put s' ?
19:01:07 <joelr1> joelr1: i'm just using it for side effects
19:01:23 <joelr1> dons: to get a trace and see what's on the stack
19:01:30 <shapr> Speck: Anyway, if you find a freely available copy of that paper, send me an url. I'm *very* interested.
19:01:45 <dons> joelr1, well, is the stae empty before the peek, in runner Stop?
19:01:56 <Speck> shapr: but anyway, what he does is he uses GADTs as a form of dependant types, so situations like identity and associativity (and a wide array of unimplemented, possible optimizations further)
19:02:00 <joelr1> dons: you are seeing it in the paste
19:02:11 <joelr1> i'm doing a peek right after w <- get
19:02:12 <Speck> I was actually kind of disappointed that he didn't take the idea further
19:02:12 <shapr> What about those situations?
19:02:30 <shapr> I think you left out the rest of that sentence.
19:02:44 <dons> joelr1, yeah,and then straight after, you check it, and its empty. but in runner Stop, is the stack empty before the peek?
19:02:48 <joelr1> dons: i do w <- get then peek which prints that the stack is not empty and then i do a trace which prints the stack as empty
19:02:48 <Speck> like ...can be optimized out entirely at compile time by the type system
19:02:51 <shapr> oh!
19:03:09 <shapr> Ok, now I *really* want to read it!
19:03:15 <joelr1> dons: i have no idea. peek prints the stack
19:03:29 <Speck> he also mentions some runtime optimizations that would be possible
19:03:32 <shapr> Have you seen Lerner's Yampa optimization paper from a year or two ago?
19:03:33 <joelr1> dons: and i inserted it there because the trace was showing the stack as empty
19:03:33 <dons> well, i'd slip in a "trace 10 $ "runner: Stop: stack: " ++ show (stack w)" before the peek, just to check
19:03:43 <joelr1> dons: i did
19:03:52 <Speck> shapr: no, but Nilsson talks about that
19:04:01 <joelr1> dons: before this. exactly the reason why i inserted peek in there
19:04:03 <SamB> dons: 0.1p97 has made it for 25:38
19:04:04 <dons> do you have other threads messing with the state?
19:04:23 <joelr1> dons: hmm...
19:04:25 <dons> SamB, cool. thinking of relesae 0.2 in a few days. just letting the code rest till then.
19:04:46 <SamB> dons: what p are you at?
19:04:55 <shapr> Lerner found that the Yampa laws were not quite as stated, but when rephrased to match the spec, could be further optimized by using some of the associativity and identity laws.
19:04:57 <joelr1> dons: investigating!
19:05:04 <dons> SamB, I have: 18:20 hmp3 0.1p107, but we're up to 109 now, I think.
19:05:24 <shapr> It sounds like the GADT+Yampa paper is a direct successor to Benjamin Lerner's paper.
19:05:26 <dons> (my last patch actually turned off the pXYZ feature, since it doesn't work in tarballs)
19:05:28 * SamB pulls
19:05:30 <Speck> yeah it soundslike that
19:05:34 <Speck> it's very, very cleanly done
19:05:57 <SamB> dons: you ought to make it conditional on whether the build tree is a darcs repo
19:06:11 <dons> that would be nice, hmm...
19:06:16 <dons> yes.
19:06:21 <dons> yes, good idea.
19:06:23 <shapr> Lerner's paper was something like an undergrad thesis, and yet, very nicely done. I'd hire Benjamin Lerner if that's how he codes in real life :-)
19:07:08 <SamB> shapr: you have money to hire underlings?
19:07:15 <Speck> Nilsson's method allows for a lot of unnecessary polling of discrete events to be optimized out
19:07:24 <shapr> Have you seen JohnMeacham's JHC compiler? It exploits monadic properties of the GRIN intermediate language for similar optimizations.
19:07:31 <shapr> This makes me wonder if the two can meet...
19:07:37 <shapr> SamB: No, but if I did...
19:07:43 <SamB> ah
19:08:48 <Speck> shapr: yeah, and I think that GADTs could be a good optimization tactic for GHC in this manner, but I'm not sure if I'm ignoring some things
19:08:51 <Speck> I gtg
19:08:56 <shapr> I think you're right.
19:09:01 <SamB> shapr: you still haven't answered my reply
19:09:07 <shapr> But it's probably easier to apply the ideas to JHC first.
19:09:10 <shapr> oh, right...
19:09:33 <joelr1> dons: this is wierd
19:09:36 <shapr> SamB: I don't know, I just write a bunch of stuff down and then try to mold it into something with real evolution in the timeline.
19:10:05 <joelr1> dons:     do w <- get
19:10:05 <joelr1>        trace 10 $ "runner: Stop: stack: " ++ show (stack w)
19:10:05 <joelr1>        peek
19:10:05 <joelr1>        trace 10 $ "runner: Stop: stack: " ++ show (stack w)
19:10:09 <SamB> shapr: so you don't write it on the wiki then?
19:10:31 <joelr1> dons: but then 03:08:43: ThreadId 21: Peek: [State: "goToLobby'"]
19:10:31 <joelr1> 03:08:43: ThreadId 21: runner: Stop: stack: []
19:10:31 <joelr1> 03:08:43: ThreadId 21: runner: Stop: stack: []
19:10:52 <shapr> SamB: Sometimes I do, but once my browser crashed...
19:10:58 <SamB> ah
19:11:05 <joelr1> dons: i was expecting trace <peek output> trace
19:11:06 <shapr> ever since then I edit it in emacs, and paste the result into the page whenever I have an update.
19:11:07 <JohnMeacham> shapr: what is this?
19:11:34 <SamB> JohnMeacham: he finally convinced me I had something to write a TMR article about
19:11:47 <shapr> JohnMeacham: GADTs might allow further optimizations, I think it *might* be one jump away from GRIN.
19:12:00 <joelr1> dons: i think i'm up against laziness
19:12:11 <shapr> JohnMeacham: I can't access Nilsson's paper, it's acm-only as far as I can see.
19:12:16 <dons> joelr1, does 'get' take the state and leave it empty? do you need to  'put' it back? (/me can't remember the semanitcs of this `get')
19:12:23 <SamB> joelr1: than what you need is persistance, right?
19:12:28 * SamB makes lame jokes
19:12:50 <joelr1> dons: yes, i need to put the state back but in this case i'm just checking it
19:12:54 <shapr> I think the summary is that the paper uses GADTs to extend the amount of shortcut information available.
19:13:19 <shapr> JohnMeacham: Oh, and I finally found out why SSA machine code is a good thing!
19:13:58 <dons> joelr1, so does the 'get' inside `peek' then leave the state empty back in `runner'? should `peek' do a `put'? (I might be off the mark here)
19:14:01 * SamB thinks it would be really slick if hmp3 could be dynamically upgraded
19:14:12 <JohnMeacham> shapr: actually, In an odd coincidence of parallel development, I implemented GADTs for jhc's intermediate language (E) in order to implement type classes. since when case'ing a type variable, you need to refine the type within said branch based on your scrutinee in order to typecheck properly. I just wrote it as a needed hack, it was good to see that feature actually has a name and the theory is sound.
19:14:12 <SamB> -- in the middle of a song
19:14:17 <joelr1> dons: peek just retrieves the value
19:14:42 <joelr1> dons: but notice that the printous are in the wrong order
19:14:52 <JohnMeacham> Yup. I prefer monadic code to SSA and CPS actually. but all three have straightforward translations between them. opening up a whole lot of optimization algorithms out there in papers.
19:15:05 <dons> oh, interesting joelr1.
19:15:28 <SamB> JohnMeacham: yeah, monadic code is a lot more readable ;-)
19:15:43 <dons> SamB: well, doable I reckon. but since only you and me use the devel branch...
19:15:53 <JohnMeacham> I never liked CPS. but a lot of people seem to think it is the bomb. it just never felt right to me.
19:15:54 <shapr> Oh, for completely off-topic random input, I bought this thing called a 'Buff'. A Buff is a hat/scarf/headband/balaclava/hairband, depending on how you fold and twist it. It's the best hat-thing I've ever owned.
19:15:56 <SamB> dons: yes. I know it could be done!
19:16:24 <JohnMeacham> shapr: is it a survivor buff? that is what they are given on that show.
19:16:30 <shapr> What show?
19:16:48 <shapr> The website is http://www.buff.es/
19:16:57 <lisppaste2> joelr1 annotated #14171 with "more wierdness" at http://paste.lisp.org/display/14171#1
19:17:04 <joelr1> wtf?
19:17:11 <JohnMeacham> it can also be a tube top. or a skirt. their normal clothes fall apart so they have to be creative with their buffs. "survivor" that reality show with everyone on an island voting each other off.
19:17:14 <shapr> The normal ones cost about 15 euro, and the spiffy polar versions (of which I now own two) cost about 25 euro. It's worth it.
19:17:18 <SamB> you'd just have to shut down curses, save the persistant state, and pass off the ephemereal state and the needed to the new version...
19:17:30 <SamB> s/needed/needed handles/
19:17:35 <shapr> JohnMeacham: I've heard of such a thing, but the whole idea turned me off so fast...
19:17:45 <SamB> now the tricky part would be dealing with the buffers on those handles...
19:17:59 <SamB> or don't you actually use handles?
19:18:04 <shapr> JohnMeacham: Anyway, it sounds like the same sort of idea, but I've only seen head things and shoulder things.
19:18:53 <dons> SamB, file descriptors. So yeah, just follow the paper :)
19:19:04 <JohnMeacham> shapr: it is the same thing. they call them 'buffs' I think it is some sort of cross-promotion thing. actually, survivor is the only reality show I watch. a lot of interesting psychology, peoplewatching is fun.
19:19:24 <SamB> paper?
19:19:27 <SamB> theres a paper?
19:19:55 <dons> you partially described the dynamic update scheme used in yi, described in the yi paper.
19:20:03 * SamB thinks his inspiration is irssi
19:20:08 <dons> @google Dynamic Applications from the Ground Up
19:20:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
19:20:18 <SamB> whats the ps file called?
19:20:58 <dons> it's not so much svaing the persistent state, as hanging on to it in the static core.
19:21:04 <shapr> JohnMeacham: I've seen enough of people for the moment.
19:21:08 <dons> yi.ps.gz ?
19:21:29 <SamB> dons: I'm talking a much more primitive scheme, actually
19:21:50 <SamB> there wouldn't be a static core in this scheme
19:22:04 <dons> I don't think we could having on to mpg321 without keeping some code running, we'd lose the fds
19:22:16 <dons> s/having/hang
19:22:30 <SamB> you can pass fds to the next image when you exec, you know ;-)
19:22:38 <lisppaste2> joelr1 annotated #14171 with "what do you make of this?" at http://paste.lisp.org/display/14171#2
19:22:45 <shapr> JohnMeacham: In any case, you gotta try one of these Buffs, they are way cool. They're popular in the unicycling and mountain biking cultures.
19:22:49 <dons> ah right. easier than Handles.
19:23:08 <joelr1> dons: does this give you any clues? notice how in the first peek the printout is something but the result is actually empty
19:23:10 <JohnMeacham> shapr: I just ordered an eTrex legend and will fashion a bike mount out of shapelock.
19:23:12 <SamB> assuming that GHC's RTS doesn't drop them, of course
19:23:43 <JohnMeacham> (BTW, shapelock is the best stuff ever. you can just make any temporary tool or whatever, then recycle it when done)
19:24:00 <shapr> Never heard of it... I'll ask google.
19:24:14 <shapr> JohnMeacham: wanna take this to #haskell-blah?
19:24:42 <shapr> whoa shapelock looks cool!
19:26:17 <JohnMeacham> shapr: it is. it is like the motie putty from the mote in gods eye. I think it is also sold under the name 'polymorph' in europe.
19:28:58 <JohnMeacham> it is quite fun to play with, I made a splint for my hand, a better handle for my razor, pushed it into a keyhole to make a key, a custom plastic mask for a haloween party.. lots of random art stuff... some more things.. also get a cheap water heater ($9 at target) to quickly heat it up. (a mcrowave works too for small amounts)
19:30:24 <SamB> JohnMeacham: a key?
19:30:37 <JohnMeacham> I learned of it through the reprap project. (reprap.blogspot.com)
19:30:58 <JohnMeacham> SamB: yup, for one of those little circular locks used on bike locks.
19:31:03 <SamB> ah!
19:32:24 <dons> heya blackdog
19:43:20 <nuffer> um
19:43:53 <dons> -fasm is really so so much faster than -fvia-C these days. some numbers for hmp3: -fasm: 19s, -fvia-C: 44.7s (and it switches on the laptop fan)
19:44:22 <dons> both with -O cranked up.
19:44:24 <skew> how about the program you get?
19:44:24 <nuffer> > -3 % 5
19:44:25 <lambdabot> (-3)%5
19:44:37 <nuffer> is there a modulus operator in haskell?
19:44:47 <dons> @type quotRem
19:44:48 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
19:44:51 <dons> @type mod
19:44:52 <lambdabot> forall a. (Integral a) => a -> a -> a
19:45:03 <nuffer> > mod -3 5
19:45:04 <lambdabot>  add an instance declaration for (Num (t -> a -> a -> a))
19:45:17 <ChilliX> dons: Was always much faster; in fact, speed of compilation was one of the main (the main) motivation for having it.
19:45:24 <skew> > mod (-3) 5
19:45:25 <lambdabot> 2
19:45:34 <dons> seems that gcc is getting slower though.
19:45:47 <nuffer> oh that
19:45:53 <SamB> dons: yes!
19:45:59 <nuffer> so, mod is guaranteed to return a non-negative result?
19:46:00 <SamB> it is from all the C++, I think
19:46:04 <skew> "mod -3 5" is parsed as ((-) mod 3) 5, I think
19:46:11 <ChilliX> dons: That wouldn't surprise me...
19:47:18 <ChilliX> Surely throwing inreasing amounts of useless optimisations at the .hc files.
19:47:30 <dons> yeah.
19:47:32 * SamB would like a shiny new C compiler with faster compilation
19:47:42 <shapr> C-- ?
19:47:47 <SamB> unfortunately tcc doesn't quite work
19:47:50 <skew> I was just about to say that.
19:47:57 <SamB> which?
19:48:12 <skew> C--, for a faster compiler
19:48:14 <dons> plus the mangler gets throwin in to the mix, with -fvia-C
19:48:15 <SamB> ah
19:48:33 <skew> and probably a more appropriate level of optimization, too
19:48:41 <SamB> yes, probably
19:50:12 <Saulzar_> Hmm, -fasm also seems to produce faster code for my little raytracer.. 50 seconds vs 39
19:51:05 <dons> Saulzar_, oh, that's nice :)
19:51:49 <SamB> Saulzar: you mean it runs faster compiled with -fasm?
19:51:59 <Saulzar_> Yeah
19:52:30 <SamB> cool
19:52:42 <SamB> so much for all those C optimizations...
19:53:50 <dons> we generate weird low-level C, for the C compiler. so most opts are probably useless.
19:54:03 <SamB> yeah
19:54:31 <SamB> about the only ones that would likely be any use are patterns for obscure ops...
19:55:05 <SlowByte> so basically it gets used for only the instruction selection and scheduling part?
19:55:34 <SamB> basicly, yes
19:55:36 <SamB> I gues
19:55:39 <SlowByte> scheduling is pretty much obsoleted with nowadays x86 processors
19:56:12 <SamB> hmm
19:56:15 * SamB has a PII
19:56:26 * SamB thinks PIIs can benefit from scheduling
19:56:43 <SlowByte> I wonder what optimizations icc gets its main speedup from
19:57:50 <SlowByte> there's still room for order of magnitude speedups by specializing into SIMD code at runtime :)
19:58:18 <Saulzar_> I don't think any compiler really succesfully does that automatically...
19:58:47 <SlowByte> yeah, it would require a different language, vector-oriented I guess
19:59:04 <SlowByte> I wonder what the K/J/APL folks are doing
19:59:48 <nuffer> with a Data.Array
19:59:59 <nuffer> bleh
20:00:06 <nuffer> is there any haskell data structure like a deque in C++?
20:00:52 <skew> not in GHC's libraries
20:00:59 <nuffer> hmmm
20:01:08 <nuffer> so if I wanted to pop the bottom row off an array
20:01:18 <nuffer> errr, pop the back
20:01:22 <nuffer> and push to the front
20:01:24 <nuffer> so to speak
20:01:28 <nuffer> is there no particularly efficient way?
20:01:51 <skew> there are deques, but I don't know where to find them, and you could probably search as well as I.
20:02:01 <nuffer> okay
20:02:06 <SamB> you could use catenable sequences...
20:02:27 <skew> that is, there are purely functional deques out there. You can also build mutable ones out of IORefs
20:02:29 <SamB> probably not the best complexity
20:03:02 <skew> there are O(1) versions out there, probably just not the best constant factors
20:03:23 <skew> Okasaki had worst case constant time catenable deques
20:03:44 * SamB wants okasaki
20:03:47 <skew> Data.Queue provides plain queues
20:03:54 <nuffer> yeah, I just stumbled upon those
20:04:08 <nuffer> yeah, a Data.Queue is probably what I really want
20:04:19 <skew> what are you trying to write?
20:04:23 <nuffer> a tetris clone
20:04:32 <nuffer> although I guess I'm making a stupid assumption there
20:04:39 <nuffer> that the bottom line will always be the one that will be destroyed
20:04:52 <nuffer> bleh, I should just be lazy and move all the elements above it down
20:30:29 <skew> why can't you slice tupling?
20:30:53 <skew> (1,,2) :: Int -> (Int,Int,Int), etc
20:47:58 <JohnMeacham> skew: I'll bring it up with the haskell-prime comitee. 
20:49:05 <JohnMeacham> the reason I heard was that nested tuples were unintuitive,  ((,3),,4) looks like it should be \a b -> ((a,3),b,4) but is actually \b -> (\a -> (a,3),b,4)
20:50:54 <ChilliX> Besides, I am not convinced the power weight ratio is sufficient here.  Haskell parser are complicated enough.
20:51:04 <ChilliX> And I can't remember ever wanting to slice a tuple.
20:58:01 <JohnMeacham> I really like the idea and have proposed it on the list myself. so have a lot of other people. I will push for it in haskell-prime unless someone comes up with a particularly good objection.
20:58:40 <skew> the obvious complication is that it's really tempting to generalize to multiple holes then
21:00:12 * SamB often wants do
21:00:22 <SamB> (x,)
21:00:27 <SamB> okay, maybe not *often*
21:00:31 <SamB> but sometimes
21:03:33 <JohnMeacham> there is no problem with multiple holes (a,,) -> \b c -> (a,b,c)
21:03:35 <SamB> man, someone needs to figure out why darcs wants old inventories for that ghc repo
21:04:05 <SamB> anyone know why I get this:
21:04:15 <SamB> Distribution/Compat/FilePath.hs:2: error: Cabal/Distribution/Compat/FilePath.hs: No such file or directory
21:06:37 <SamB> I'm trying to build after doing
21:06:57 <SamB> darcs get --partial http://cvs.haskell.org/darcs/ghc
21:07:06 <SamB> followed by
21:07:20 <SamB> autoreconf && ./configure
21:08:44 <skew> Hmm, I guess that's how binary operators already work - (+) :: (Num a) => a -> a -> a
21:09:57 * SamB wonders if #haskell has him on /ignore
21:10:04 <skew> ?
21:10:39 <JohnMeacham> SamB is not being ignored.
21:11:09 <SamB> does anybody have any idea who might have any idea about any of this?
21:12:06 <JohnMeacham> SamB: no idea. I have not tried it yet.
21:12:20 <monochrom> I have version control and build configurations on /ignore :)
21:14:05 <SamB> man, some people think Haskell people never write useful programs...
21:21:48 <monochrom> What do you care what other people think?
21:22:05 <SamB> I don't know
21:22:31 <skew> challenge them to a rousing game of frag
21:22:56 <SamB> skew: that would work better if I had a graphics card and a decent net connection
21:23:39 <skew> cool, you use a teletype for IRC?
21:24:20 <SamB> ok, so I really do have a graphics card
21:24:35 <SamB> but it doesn't have enough VRAM to give me 3d acceleration anymore
21:24:56 <skew> that's a whole new meaning for IRC log
21:24:57 <SamB> @where frag
21:24:58 <lambdabot> http://www.cse.unsw.edu.au/~pls/repos/frag
21:25:14 <skew> I don't think anybody has added network support yet, either.
21:28:01 * SamB wonders how many s/frame he would get
21:28:31 <SamB> @wiki Frag
21:28:31 <lambdabot> http://www.haskell.org/hawiki/Frag
21:29:15 <ChilliX> SamB what card do you have?
21:31:11 <SamB> ChilliX: Voodoo 3 with 16 MiB
21:31:11 <SamB> I don't remember which model
21:31:21 <ChilliX> Won't run at all
21:32:21 <ChilliX> I don't think a Voodoo 3 supports the required OpenGL extensions
21:33:28 <SamB> anyway, I get soft GL because that isn't enough VRAM
21:33:47 <ChilliX> yeah
21:35:03 <SamB> okay, maybe they are not really all that anti-Haskell... dash says it is awesome, and Yosomono is apparantly just picking on Haskell...
21:36:52 <SamB> POD is possibly serious but then again possibly not...
21:40:24 <lispy> i don't get very good frames on my ibook with an ati9200(??)
21:46:21 <ChilliX> Radeon 9200 isn't a particularily good graphics card by current standard either
21:47:10 <ulfdoz> Woah, hw-talk here?
21:47:18 <SamB> hmm, applicatations wanted! apply today at http://www.haskell.org/hawiki/CategoryApplication!
21:48:00 * dons has a whole bunch I can think of to add to the list. do you have to also create a wiki page for the projects?
21:48:03 <dons> or do you just want links?
21:48:07 <SamB> ulfdoz: Frag did it!
21:48:41 <SamB> dons: a wiki page is desired
21:48:47 <ChilliX> ulfdoz: You need to seek a balance between category theory and VLSI.
21:48:53 <dons> heh!
21:49:00 <ChilliX> hehehe :)
21:49:01 <SamB> though now that the category actually has a page it isn't absolutely necessary
21:49:16 <dons> @remember Chilli You need to seek a balance between category theory and VLSI
21:49:55 <ChilliX> dons: here (= freenode) it is ChilliX
21:50:06 <ChilliX> Chilli is taken already ;(
21:50:14 <ulfdoz> ChilliX: Nope, me doesn't, yet. I'm still quite new to categories, so hopefully I have a better understanding in february. :)
21:54:59 <SamB> @where conjure
21:55:00 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
21:56:48 <dons> SamB, maybe the apps page should have a little flag or such next to each entry that is also available via darcs?
21:58:02 <SamB> dons: you want to hack Moin to figure out how to implement that?
21:58:20 <dons> blargh.
21:59:48 <SamB> or we could just list them manually, I suppose...
22:00:23 <SamB> or! we could bribe shapr to do it
22:00:40 <SamB> I am hearing that he will do things for money
22:01:14 <dons> hehe
22:06:36 * SamB wanders off to bed
22:08:27 * unusednick builds lambdabot
22:08:46 * SamB sets reactos to build whilst he is asleepin
22:25:55 <unusednick> aaargh
22:26:03 * unusednick can't get lambdabot to run
22:27:11 <Gs30ng> a friend of mine who's considering learning haskell asked me, "is there any OpenGL library for Haskell?"
22:36:03 <Korollary> Gs30ng: ghc comes with hopengl
22:36:18 <Gs30ng> aha
22:36:20 <Gs30ng> thx
22:40:19 <Korollary> Gs30ng: Your friend may be interested in this: http://haskell.org/hawiki/Frag
22:41:23 <Gs30ng> wow
22:41:40 <Gs30ng> should show him it
22:41:44 <Gs30ng> thanks a lot
23:01:56 <cjb> http://chris.printf.net/monitor_go3.jpg # the Ultimate Go Board?  :)
23:03:46 * unusednick finally managed to get lambdabot to run
23:04:08 <unusednick> now i just don't know how to use it :-(
23:04:13 <Khisanth> cjb: don't see anything special with that board
23:06:40 <cjb> Khisanth: Well, no, that's true.  :)
23:09:33 <dons> unusednick, what problems did you have getting lambdabot running?
23:09:44 <unusednick> dons: really dumb ones
23:09:45 <dons> I'll try to fix them, if you let me know what the hard parts were
23:10:11 <unusednick> well, the one thing that's really lambdabot specific is that when connections fail, its reporting is not very friendly
23:10:22 <unusednick> it seems to go into this connection attempt loop
23:10:45 <unusednick> the biggest problems i had were setting up my ghc environment
23:13:10 <dons> yeah, the reporting isn't very friendly. we should work on that.
23:13:13 <dons> i'll add it as a todo.
23:13:28 <dons> what issues did you have with ghc?
23:14:32 <dons> hmm. 'unusednick' isn't the best attribution in a commit message..
23:14:34 <dons> ;)
23:16:44 <unusednick> dons: i accidentally built 6.4 instead of 6.4.1
23:17:02 <dons> ah, which breaks runplugs. any other issues with 6.4?
23:17:08 <unusednick> as in, my package management system (Darwinports) was acting funny
23:17:12 <unusednick> no, that was really it
23:17:20 <unusednick> the rest was dependency hell from upgrading haskell
23:17:29 <dons> was it runplugs that caused problems with ghc 6.4?
23:17:32 <dons> or something else?
23:17:41 <unusednick> i somehow ended up with an hs-plugins pointing at a 6.4 package.conf
23:17:57 <dons> oh, ok. I jsut run all this stuff from the darcs repos ;)
23:18:28 <unusednick> so i was getting a message when trying to start lambdabot, that /opt/local/lib/ghc-6.4/package.conf did not exist..
23:18:31 <dons> so the build instructions were fairly clear? or did they point you to the wrong versions fo things/
23:19:05 <unusednick> if found that lambdabot's instructions on how to build it, from the readme, could use being less detailed
23:19:18 <unusednick> in particular, for the required libs
23:19:42 <unusednick> upgrading cabal was more involved than lambdabot's readme says
23:19:45 <unusednick> in particular
23:21:45 <dons> could be less detailed?
23:22:00 <dons> really? how did building cabal break?
23:22:11 <unusednick> it did not
23:22:19 <unusednick> but i had to do more steps than were shown
23:22:30 <dons> oh? what step did I miss?
23:22:42 <unusednick> removing the cabal installed with ghc
23:23:08 <dons> hmm. should it not be hidden automatically? or did you have to do a ghc-pkg unregister Cabal-1.0 ?
23:23:21 <unusednick> well, i did that
23:23:27 <unusednick> (the latter)
23:23:35 <unusednick> which was what the Cabal README recommended
23:23:53 <dons> ok. when do they reccomend doing it?
23:24:01 <dons> (I'll update the lambdabot instrs..)
23:24:20 <unusednick> in the README
23:24:51 <unusednick> I think it's just fine for the lambdabot instrs to just say to read the READMES for the packages in question...
23:25:11 <dons> hmm. ok. maybe for Cabal -- since they might change their instrs.
23:25:26 <unusednick> yeah, the others you can control...
23:25:28 <dons> for the others, since I'm the author of those packages, I think that's ok.
23:25:30 <dons> right.
23:39:47 <ADEpt> @where house
23:39:47 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
23:54:46 <unusednick> @vixen
23:54:47 <lambdabot> isn't it obvious?
23:54:51 <unusednick> @vixen
23:54:52 <lambdabot> whoa whoa whoa, one question at a time!
23:55:00 <unusednick> @help vixen
23:55:00 <lambdabot> sergeant curry's lonely hearts club
23:56:44 <dons> @vixen what do you think of haskell programmers?
23:56:45 <lambdabot> church is my favourite computer scientist.
23:57:11 <unusednick> dons: my vixen does not work
23:57:15 <palomer> wants you all to know
23:57:38 <unusednick> Module "vixen" produced error: Text.Regex.Posix.regcomp: error in pattern
23:57:59 <palomer> @vixen would you still love me if I got up and sang?
23:58:00 <lambdabot> i might :)
23:58:18 * palomer gets up and sings
23:58:22 <dons> hmm. strange unusednick. I wonder if you regex lib is different?
23:58:24 <palomer> @vixen do you still love me?
23:58:25 <lambdabot> love is a powerful word...
23:58:38 <unusednick> is there anyting i can type in to find out?
23:58:43 <palomer> @vixen ok, then do you still like me?
23:58:43 <lambdabot> sure, i like you so far
23:58:57 <palomer> @vixen could this turn into love someday?
23:58:58 <lambdabot> i think you know the answer to that one, silly
23:59:07 <palomer> @vixen you're such a tease
23:59:08 <lambdabot> let me answer that later, okay?
