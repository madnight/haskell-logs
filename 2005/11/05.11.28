00:00:06 <dons> maybe I shouldn't have kill -KILL'd it :/
00:00:15 <kzm> @choice-add  TheLanguageOfChoiceForDiscriminatingHackers Whitespace
00:00:15 <lambdabot> New candidate "Whitespace", added to poll "TheLanguageOfChoiceForDiscrimina
00:00:15 <lambdabot> tingHackers".
00:00:16 <dons> sorry!
00:00:29 <kzm> @vote  TheLanguageOfChoiceForDiscriminatingHackers Whitespace
00:00:30 <lambdabot> voted on "Whitespace"
00:00:34 <kzm> Hah!
00:00:45 <sieni> @choice-add  TheLanguageOfChoiceForDiscriminatingHackers Norvegian
00:00:45 <lambdabot> New candidate "Norvegian", added to poll "TheLanguageOfChoiceForDiscriminat
00:00:45 <lambdabot> ingHackers".
00:00:54 <kzm> Oooh.
00:00:55 <sieni> @vote  TheLanguageOfChoiceForDiscriminatingHackers Norvegian
00:00:56 <lambdabot> voted on "Norvegian"
00:01:02 <dons> hehe
00:01:02 <kzm> @vote  TheLanguageOfChoiceForDiscriminatingHackers Norwegian
00:01:03 <lambdabot> "Norwegian" is not currently a candidate in this poll
00:01:10 <kzm> @vote  TheLanguageOfChoiceForDiscriminatingHackers Norvegian
00:01:11 <lambdabot> voted on "Norvegian"
00:01:20 <sieni> oops ^_^
00:01:20 <boegel> dons: now you're responsible for making people vote on my poll :P
00:01:35 <sieni> maybe /me should learn to spell
00:01:39 <Muad_Dibler> @choice-add TheLanguageOfChoiceForDiscriminatingHackers 13375p34k
00:01:39 <lambdabot> New candidate "13375p34k", added to poll "TheLanguageOfChoiceForDiscriminat
00:01:39 <lambdabot> ingHackers".
00:01:42 <dons> well, you hve the logs, you can reconstruct the votes ;)
00:01:54 <dons> @elite vote for me!
00:01:55 <kzm> @poll-add BestBotPlugin
00:01:55 <lambdabot> VO+e phOr /\/\e!
00:01:55 <lambdabot> Added new poll: "BestBotPlugin"
00:02:04 <boegel> dons: no I can't, people can vote privately
00:02:05 <kzm> @choice-add BestBotPlugin Poll
00:02:06 <lambdabot> New candidate "Poll", added to poll "BestBotPlugin".
00:02:07 <Muad_Dibler> @vote TheLanguageOfCoiceForDiscriminatingHackers 13375p34k
00:02:07 <lambdabot> No such poll:"TheLanguageOfCoiceForDiscriminatingHackers"
00:02:08 <ulfdoz> 0xC0FFEE!
00:02:15 <Muad_Dibler> @vote TheLanguageOfChoiceForDiscriminatingHackers 13375p34k
00:02:16 <lambdabot> voted on "13375p34k"
00:02:16 <kzm> @vote BestBotPlugin Poll
00:02:17 <lambdabot> voted on "Poll"
00:02:17 <kzm> :-)
00:03:10 <kzm> Whatever did I do all day before there was \bot?
00:03:23 <kzm> (I guess that was when I had a TV)
00:04:43 <Cale> @poll-add BestPoll
00:04:44 <lambdabot> Added new poll: "BestPoll"
00:04:52 <Cale> @choice-add BestPoll BestPoll
00:04:52 <lambdabot> New candidate "BestPoll", added to poll "BestPoll".
00:05:01 <kzm> @vote BestPoll BestPoll
00:05:02 <lambdabot> voted on "BestPoll"
00:05:24 <Cale> @vote BestPoll BestPoll
00:05:24 <lambdabot> voted on "BestPoll"
00:05:33 <boegel> @poll-show TopTenLibraries -> start voting !
00:05:34 <lambdabot> usage: @poll-show <poll>
00:05:40 <boegel> @poll-show TopTenLibraries
00:05:41 <lambdabot> ["stm","WASH","HOpenGL","Arrows","FastPackedString","FGL","wxHaskell","
00:05:41 <lambdabot> QuickCheck","Parsec","MissingH","HaXml","HList","hs-plugins","Yampa","
00:05:41 <lambdabot> Gtk2Hs","HTTP","NewBinary","XmlRpc"]
00:05:58 <boegel> @vote TopTenLibraries Gtk2Hs
00:05:59 <lambdabot> voted on "Gtk2Hs"
00:06:04 <boegel> @vote TopTenLibraries Parsec
00:06:04 <lambdabot> voted on "Parsec"
00:06:19 <Muad_Dibler> @vote TopTenLibraries wxHaskell
00:06:20 <lambdabot> voted on "wxHaskell"
00:06:54 <Muad_Dibler> it isn't possible to do a "blanco stem" is it? :P
00:14:49 <adu> hi
00:14:57 <Roboguy> Hello
00:14:57 <skew> hi
00:15:06 <adu> wow full house in here
00:15:39 <adu> i didn't know haskell was this popular
00:16:11 <Roboguy> Heh, I was thinking the same thing
00:16:16 <adu> i thought haskell was just too abstract to be popular
00:16:54 <skew> not a lot of competetion in that space
00:17:08 <adu> i suppose
00:17:29 <skew> and a fine language too. The channel is running about usual today, I think
00:18:21 <adu> i know, I don't understand much but the parts i do understand are logically and architecturally beautiful
00:21:53 <yaarg> haskell is very popular in the academic world..
00:24:03 <adu> well i need to take a trip there!
00:24:45 <adu> does the academic world allow turism?
00:26:06 <yaarg> :)
00:28:57 <skew> does anyone know where to find SPJ's new paper?
00:29:04 <skew> the link from his home page is broken
00:30:09 <Roboguy> Excuse my ignorance, but who is SPJ?
00:30:27 <skew> Simon Peyton-Jones
00:30:45 <skew> one of the two Simon's who are largely responsible for GHC (the other being Marlow)
00:30:51 <Roboguy> Ah
00:31:25 <skew> http://research.microsoft.com/Users/simonpj/
00:32:19 <skew> "Lock-free data structures using Software Transactional Memory in Haskell"
00:33:01 <skew> I win the game of guess-the-url: http://research.microsoft.com/Users/simonpj/papers/stm/lock-free.htm
00:33:14 <skew> Word document :(
00:33:35 <adu> later
00:34:01 <Roboguy> G'bye
01:11:56 <Lokadin> so anyone know how to do foldl?
01:12:28 <int-e> > foldl (flip (:)) [] [1,2,3,4,5,42]
01:12:29 <lambdabot> [42,5,4,3,2,1]
01:12:37 <Lokadin> er i mean write it
01:12:44 <Lokadin> the actual algorithm for it
01:12:54 <Lokadin> er doing it for yet another haskell tutorial
01:13:41 <guro> the whole point is you figure it out yourself
01:13:48 <Lokadin> well i dono
01:13:54 <Lokadin> i mean i've been thinking for quite a while
01:13:59 <Lokadin> and i haven't come up with anything
01:14:39 <Lokadin> i was never really strong in recursion, and i only know how to go recursively forwards. *shrugS* if i knew substrings i could do it like that
01:14:53 <Lokadin> but they haven't said anything about them so i'm assuming that's not the way to go about it
01:15:05 <Lokadin> and from what Cale said i start with foldl
01:15:24 <Lokadin> and i'm just lost, like how do you recursively get to the last and start operating and go to the first one
01:15:31 <Lokadin> all the while being faster then foldr :|
01:17:31 <Lokadin> it just really daunts me
01:18:52 <skew> take some examples - what is foldl f x [], foldl f x (v:vs)?
01:19:32 <Lokadin> kk
01:20:24 <Lokadin> semms to just give the proper result *shrugs*
01:20:38 <Lokadin> i mean no different then foldr
01:20:52 <Lokadin> except fro the whole going in the opposite direction part
01:23:46 <skew> what is foldl f x []?
01:23:57 <Lokadin> x
01:24:06 <neologism> f x :)
01:24:16 <skew> what about foldl f x [y]?
01:24:38 <Lokadin> f y x
01:24:57 <skew> how about foldl f x [y1, y2]
01:25:16 <Lokadin> f y1 (y2 x)
01:25:31 <Lokadin> er
01:25:38 <Lokadin> f y1 (f y2 x)
01:25:51 <skew> now, write that in terms of fold f x [y2]
01:26:11 <skew> foldl f x [y1, y2] = ... (foldl f x [y2]) ...
01:26:45 <ProfTeggy> Moin
01:26:51 <skew> hi
01:27:20 <Lokadin> i don't see how that works
01:27:23 <Lokadin> :|
01:27:39 <Lokadin> i mean you can't get anything else out of y2
01:27:41 <skew> you said that foldl f x [y1, y2] = f y1 (f y2 x)
01:27:51 <skew> and that foldl f x [y2] = (f y2 x)
01:27:52 <Lokadin> yea
01:28:22 <skew> actually, try out that first line with (flip (:)) and some numbers
01:28:39 <skew> foldl (flip (:)) [] [1, 2] => ?
01:29:08 <skew> (flip (:)) 1 ( (flip (:)) 2 []) isn't even well typed
01:30:01 <Lokadin> :|
01:30:04 <Lokadin> er one sec
01:31:03 <Lokadin> what does flip do ?
01:31:13 <int-e> > foldl (-) 0 [1,2,3]
01:31:14 <lambdabot> -6
01:31:17 <int-e> > foldr (-) 0 [1,2,3]
01:31:18 <lambdabot> 2
01:31:25 <skew> oh, that example was from int-e
01:31:36 <skew> flip (:) x y = x:y
01:31:45 <int-e> no. y:x it is.
01:31:57 <skew> flip f x y = f y x is the definition
01:32:25 <skew> (flip (:)) [] 1 => [1], for example
01:32:48 <Lokadin> i don't think we learned that in the tutorial
01:32:49 <Lokadin> let me check
01:32:51 <int-e> Lokadin: do you know what (:) is / does?
01:33:10 <int-e> Lokadin: e.g. what 1:[] is?
01:33:10 <Lokadin> i know what : does
01:33:14 <Lokadin> yea
01:33:17 <Lokadin> it's [1]
01:33:36 <Lokadin> a list 
01:34:09 <Lokadin> yep as i suspected
01:34:15 <Lokadin> we don't get to that until er chapter 7
01:34:22 <Lokadin> and we are in 4.5
01:34:35 <Lokadin> ummm
01:35:03 <Lokadin> so maybe someone could tell me the algorithm? life would be soo much easier
01:36:28 * ProfTeggy smells homework fraud
01:36:41 <Lokadin> it really isn't lol
01:36:47 <Lokadin> :P
01:36:52 * int-e wonders if he should mention Prelude.hs
01:36:55 <Lokadin> it's from yet another haskell tutorial
01:36:58 <skew> people have to work for answers here...
01:37:01 <neologism> foldl f a (x:xs) = foldl (f a x) xs ?
01:37:04 <Lokadin> lol
01:37:11 <skew> well, usually...
01:37:27 <Lokadin> thanks
01:37:28 <ProfTeggy> From a purely pedagogicial perspective, the channel cannot help you, really
01:37:39 <Lokadin> what do you mean?
01:38:38 <Cale> I think he means you can only help yourself :) However, we can put interesting things in front of you
01:38:59 <Lokadin> well that's always good
01:39:02 <Lokadin> :D
01:39:12 <neologism> try foldr
01:39:17 <Cale> have you looked at the prelude?
01:39:25 <Lokadin> foldr is easy in comparison to foldl
01:39:26 <skew> I was trying to show that a function is defined by it's action
01:39:31 <Lokadin> i still don't understand it to be honest
01:39:55 <neologism> to me foldr looks harder then foldl
01:39:55 <skew> so if you know what it does for each constructor of lists, recursively, then you know the function
01:40:21 <Lokadin> Cale: prelude.hs?
01:40:35 <skew> well, foldr comes from universal algebra and stuff
01:40:36 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
01:41:10 <Cale> those aren't the actual implementations of those functions, but they're close :)
01:41:19 <Cale> there is some cheating for efficiency in the real version
01:41:26 <neologism> cheating?
01:41:32 <neologism> what cheating?
01:41:40 <Cale> like unboxing values, etc.
01:42:04 <Cale> also, RULE pragmas will rewrite your code for you anyway :)
01:42:07 <skew> Lokadin: where are you in the tutorial?
01:42:36 <skew> shouldn't list fusion be using something a bit stronger than RULE pragmas by now?
01:42:53 <Lokadin> p 62
01:42:59 <int-e> > let foldlFromZip f x l = let folds = x:zipWith f folds l in last folds in foldlFromZip (flip (:)) [] [1,2,3,4]
01:43:00 <lambdabot> [4,3,2,1]
01:43:21 <Cale> skew: stronger?
01:43:48 <skew> a more thorough analysis
01:44:05 <skew> catching simple user-defined functions should be possible
01:44:31 <Cale> probably should be, but the list fusion RULE stuff was in there last time I looked
01:44:55 <xerox> Hey there!
01:44:58 <Cale> hey!
01:45:08 <skew> Lokadin: check the example that runs from page 19 onto page 20
01:45:25 <xerox> @botsnack
01:45:25 <lambdabot> :)
01:45:34 <xerox> Ooh, she's back too :-)
01:47:03 <kosmikus> palomer: I have (tried Generic Haskell) ...
01:47:08 <Lokadin> skew: skew how to run the interpreter?
01:47:11 <skew> that should make it pretty clear that foldl f x (y:ys) = foldl f (f x y) ys, and foldl f x [] = x.
01:47:18 <skew> hey, that looks like a definition...
01:47:30 <xerox> Hm?
01:47:41 <xerox> Oh, nevermind.
01:47:54 <skew> ghci, if you've got it installed
01:48:00 <Lokadin> i do
01:48:19 <Lokadin> it's what i use to test all the programs
01:49:41 <Lokadin> wow that's a really crazy algorithm,
01:51:33 <Lokadin> actually all of haskell is absolutely insane lol
01:51:54 <guro> what is insane about it?
01:52:12 <xerox> ALL! Muaaahahahah!
01:52:23 <ProfTeggy> xerox ;-)
01:52:43 <int-e> There's nothing insane about it actually, it's an abstraction of a recurring pattern when working with lists ...
01:52:46 * xerox takes a deep breath.
01:52:57 <Lokadin> lol
01:53:03 <xerox> > let sum = foldl (+) 0 in sum [1..10]
01:53:04 <lambdabot> 55
01:53:13 <xerox> > let product = foldl (*) 1 in product [1..10]
01:53:14 <lambdabot> 3628800
01:53:31 <xerox> (which happen to be defined in the prelude, too)
01:53:42 <Lokadin> yep i noticed
01:54:01 <Lokadin> i don't mean it in a bad way :P
01:55:11 <Lokadin> bah gentoo keeps inventing new scripts with new names
01:55:32 <Cale> foldl has the nice property of being tail recursive, but for things like sum and product, the benefit of tail recursion is all but completely lost because lazy evaluation order causes large unevaluated expressions to get built up and then evaluated only after the whole list has been processed.
01:55:35 <xerox> There are 'collecting' versions of folds called scans, too.
01:55:57 <Cale> So there's a strict version called foldl' (that's with a prime)
01:56:13 <xerox> > scanl (+) 0 [1..10]
01:56:15 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55]
01:56:34 <Cale> > scanr (+) 0 [1..10]
01:56:35 <lambdabot> [55,54,52,49,45,40,34,27,19,10,0]
01:57:21 <Lokadin> :|
01:57:47 <Cale> catch what that's doing?
01:58:06 <Lokadin> can't say that i do
01:58:14 <Lokadin> well scanr yes
01:58:18 <xerox> (You can lie)
01:58:22 <Lokadin> but scanl
01:58:27 <Cale> you get scanr but not scanl?
01:58:31 <int-e> > let fib = scanl (+) 1 (1:fib) in take 10 fib
01:58:32 <lambdabot> [1,2,3,5,8,13,21,34,55,89]
01:58:40 <Cale> [1, 1 + 2, 1 + 2 + 3, ...]
01:58:50 <Cale> er
01:59:00 <Cale> [0, 1, 1+2, 1+2+3, ...]
01:59:54 <Lokadin> oh oaky
01:59:56 <Lokadin> i get it
02:00:16 <Lokadin> makes sense now
02:00:34 <Lokadin> :D
02:02:53 <Lokadin> er
02:02:54 <Lokadin> listFoldl f n (Cons x xs) = n
02:02:54 <Lokadin> listFoldl f n (Cons x xs) = listFoldl f (f n x) xs
02:03:12 <Lokadin> for some reason if i try using it all it gives me is initial n
02:03:18 <Lokadin> o
02:03:20 <Lokadin> sorry
02:03:21 <Lokadin> nm
02:03:26 <Lokadin> (runs away)
02:03:47 * boegel catches Lokadin and throws him back in the Haskell pit
02:04:12 <Lokadin> lol
02:04:14 <Lokadin> :P
02:07:05 <triplah> > let listFoldl f n (Cons x xs) = n; listFoldl f n (Cons x xs) = listFoldl f (f n x) xs in listFoldl (+) 0 (Cons 5 6)
02:07:06 <lambdabot>  Not in scope: data constructor `Cons'
02:07:10 <triplah> boo
02:07:32 <Lokadin> lol
02:07:34 <triplah> > let listFoldl f n (Cons x xs) = n; listFoldl f n (x:xs) = listFoldl f (f n x) xs in listFoldl (+) 0 [5,6]
02:07:34 <lambdabot>  Not in scope: data constructor `Cons'
02:07:37 <triplah> argh
02:07:48 <triplah> > let listFoldl f n (x:xs) = n; listFoldl f n (x:xs) = listFoldl f (f n x) xs in listFoldl (+) 0 [5,6]
02:07:49 <lambdabot>   Warning: Pattern match(es) are overlapped
02:07:49 <lambdabot>      In the definition of `listFoldl': listFoldl f n (x : xs) = ...
02:08:00 <Lokadin> what are you doing?
02:08:19 <triplah> thats what is wrong
02:08:24 <Lokadin> ?
02:08:38 <triplah> your first pattern matches your second?
02:08:41 <Lokadin> well i know what's wrong i fixed it already, that's why i said (run away) as in from embarassment
02:08:44 <int-e> triplah: you need the other constructor of list
02:08:48 <triplah> it'll never get to the second clause
02:08:56 <Lokadin> :) thanks
02:08:59 <triplah> int-e: yeah thats why i changed it to (x:xs)
02:09:06 <triplah> Lokadin: ahh
02:09:06 <triplah> rofl
02:09:20 * triplah runs
02:09:36 <Lokadin> lol
02:09:41 <Lokadin> :P
02:10:12 <triplah> changed it to something like listFoldl f n EmptyList  = n  ?
02:10:36 <triplah> <-- learning
02:10:41 <Lokadin> listFoldl f n Nil = n
02:10:43 <Lokadin> yep
02:10:51 <Lokadin> original constructor was
02:11:29 <Lokadin> data List a = Nil |Cons (List a)
02:11:33 <Lokadin> deriving show
02:11:43 <triplah> cool
02:11:47 <Lokadin> Show
02:11:48 <Lokadin> *
02:11:53 <Lokadin> yep
02:12:00 <Lokadin> yet another haskell tutorial
02:12:04 <triplah> hehe
02:12:10 <triplah> i learnt about data in class this week
02:12:28 <Lokadin> o? you're taking a course?
02:13:03 <triplah> i'm doing a principles of programming subject
02:13:07 <triplah> scheme haskell and prolog
02:13:13 <triplah> at uni
02:13:17 <Lokadin> cool
02:13:18 <Lokadin> uni?
02:13:26 <triplah> university
02:13:41 <Lokadin> o
02:13:48 <Lokadin> sorry i thought it said and
02:13:54 <triplah> ahh :D
02:14:10 <Lokadin> Yet Another Haskell Tutorial -> http://www.isi.edu/~hdaume/htut/
02:14:21 <triplah> cool ta
02:14:30 <Lokadin> what uni you at?
02:14:38 <triplah> Bond University in australia
02:14:51 <xerox> @where YAHT
02:14:51 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
02:15:09 <Lokadin> o
02:15:12 <Lokadin> fancy
02:15:24 <triplah> ehe
02:15:27 <Lokadin> wow is a far ways away
02:15:30 <Lokadin> hmmm
02:15:34 <Lokadin> it's 5:15 here
02:15:43 <triplah> Mon Nov 28 20:19:06 EST 2005
02:15:50 <Lokadin> i think i should probably get to bed, as i do have class in the morning
02:15:55 * xerox is hating mail quotas ...
02:15:58 <Lokadin> yep same day 5 am
02:16:02 <triplah> got a multimedia practical exam tomorrow
02:16:09 <triplah> i'd rather be coding haskell :|
02:16:14 <Lokadin> who wouldn't :P
02:16:15 <Lokadin> lol
02:16:20 <Lokadin> it's soo amazing
02:16:27 <triplah> yep :>
02:16:44 * Lokadin runs around preaching the superiority of haskell 
02:16:44 <Lokadin> lol
02:16:54 <triplah> ehe
02:16:59 <Lokadin> oi
02:17:00 <Lokadin> hmmm
02:17:15 <Lokadin> anyways i'm gonna head off as soon as i get some emerge's running
02:17:34 <triplah> heh, fellow gentoo user :)
02:17:51 <triplah> http://www.it.bond.edu.au/inft313/053/assessment/a3.html <-- thats my current assignment
02:17:57 <triplah> its due next monday
02:18:08 <triplah> and i have an exam and assignment to do between now and then
02:18:14 <triplah> then i hav to do the haskell one
02:18:15 * triplah dies
02:18:21 <triplah> gonna be a few sleepless nights
02:18:21 <triplah> :)
02:20:58 <Lokadin> damn
02:21:11 <Lokadin> not bad
02:24:02 <Lokadin> bah i can't wait until my comp sci courses start
02:24:13 <Lokadin> :| unfortunatly that is going to be next y ear at soonest
02:24:34 <Lokadin> but then again maybe not so bad as i get to learn haskell in the meantime~ :D
02:24:40 <triplah> haha
02:24:50 <triplah> i wish i had time to do my own coding
02:24:51 <triplah> :(
02:25:37 <Lokadin> yea i know what you mean ;P
02:30:00 <Lokadin> hmmm does anyone know that linux command that performs an action for each line and uses the line as the arguemnt of the command?
02:30:57 <xerox> xargs
02:30:58 <flux__> xargs
02:31:02 <flux__> slow ;(
02:31:33 <xerox> Always complaining about efficiency, hmpf.  We're not #lisp!
02:31:37 <Lokadin> yea
02:31:40 <Lokadin> thanks :D
02:31:54 <Lokadin> wha'ts slow?
02:31:59 <flux__> I was
02:32:04 * xerox blinks
02:32:50 <Lokadin> o
02:32:57 <Lokadin> k
02:35:52 <shapr> k
02:35:52 <shapr> o
02:36:11 * shapr boings
02:38:09 <Lokadin> poing
02:42:04 <Lokadin> bah okay sleep sleep time
02:42:05 <Lokadin> cya
02:43:05 <xerox> Bye bye.
02:43:55 <xerox> IRC is sleeping, today.
02:44:12 <yaarg> Woah @ http://pandora.com . Nothing to do with Haskell but extremely cool software never the less..
02:45:12 <xerox> Yeah, found it yesterday.  Seems quite cool!
02:55:42 <kzm> shapr?
02:56:59 <xerox> @get-shapr
02:57:13 <lambdabot> shapr!!
03:00:14 <kzm> Even lambdabot's strictness annotations won't help when shapr is too lazy :-)
03:00:23 * kzm goes to lunch instead.
03:12:04 <tic> Is there some way I can break up strings by newline? I.e., not having separate strings and do ++ between them?
03:12:22 <xerox> Sure.
03:12:44 <xerox> > lines "is\nit\nthis\none?\n"
03:12:45 <lambdabot> ["is","it","this","one?"]
03:12:46 <musasabi> > lines "foo\nbar\nbaz"
03:12:47 <lambdabot> ["foo","bar","baz"]
03:13:35 <tic> Not like that. :)
03:13:40 <tic> I want Python or C-style strings
03:14:00 <tic> start with a " somewhere, write a couple of lines and then another "
03:14:43 <dons> end each line with a \
03:15:07 <dons> banner = "\ 
03:15:07 <dons> \           __                          \n\
03:15:07 <dons> \    ____  / /_  ______ ______          \n\
03:15:07 <dons> \   / __ \\/ / / / / __ `/ ___/     PLugin User's GHCi System, for Haskell 98\n\
03:15:10 <dons> for example
03:15:32 <int-e> old C style
03:15:36 <tic> Ah, so you can use \ at the end of lines. Great!
03:15:38 <tic> That works.
03:15:40 <tic> Thanks!
03:15:53 <tic> why does it begin with a \ though?
03:16:00 <xerox> You could also:
03:16:03 <ski> so you can indent
03:16:10 <tic> ski, don't get it
03:16:20 <xerox> lines ["first line",
03:16:20 <xerox>        "second line",
03:16:20 <xerox>        ...]
03:16:25 <ski> x = "apa \
03:16:25 <ski>     \bepa \
03:16:25 <ski>     \cepa"
03:16:34 <ski> tic : like that
03:17:06 <tic> ski, doesn't that escape the b and c though?
03:17:13 <ski> nope
03:17:16 <tic> weird. :)
03:17:23 <tic> doesn't it do that everywhere else?
03:17:30 <ski> 'backslash whitespace* backslash' in string literals are removed
03:17:39 <tic> aha.
03:17:45 <tic> Thought it was special syntax
03:19:50 * ski wonders if h4sh can do xargs-like stuff
03:22:25 <dons> concat?
03:22:32 <ski> > read "\"a\\ \\b\"" :: String
03:22:33 <dons> map
03:22:33 <lambdabot> "ab"
03:22:49 <ski> yes, map or mapM or mapM_, i guess
03:26:51 <ski> (maybe a concat, too, yes)
03:40:58 <int-e> Hmm, wasn't there talk about a debian gtk2hs package?
03:57:11 <gdgsd23> hi champions
03:57:20 <Lemmih> hiya
04:00:05 <kzm> Re Simon's recent comment on using select() for IO...
04:00:31 <kzm> Shouldn't that be epoll() on Linux?  Not sure how things are these days, but ISTR select/poll not scaling too well?
04:00:41 <kzm> Also: http://lse.sourceforge.net/epoll/index.html for some graphs etc.
04:04:18 <int-e> epoll(4) is a new API introduced in Linux kernel 2.5.44.
04:04:28 <int-e> says the manpage
04:04:34 <kzm> Hmm..yes?
04:05:00 <int-e> sorry, misread a word.
04:06:00 <kzm> Anyway - it's new and niche, but if the point is to support 10Ks of simultaneous connection, it seems like the way to go.  Similar for /dev/poll on Solaris.
04:07:14 <kzm> So I was just wondering whether GHC would use them.
04:17:45 <araujo> Good morning Haskell'ers!!!!
04:18:13 <int-e> ghc doesn't use epoll at the moment.
04:25:49 <JaffaCake> yes, epoll() on Linux, and kqueue on *BSD
04:26:29 <ProfTeggy> araujo: nub "!!!!" = "!"
04:30:29 <eivuokko> JaffaCake, Hey!  Should the patch for GHc, to address lack or sleep() in recent mingw...should it really be autotools check?  I just checked for windows.h and #define sleep(x) Sleep((x)*1000)
04:30:39 <eivuokko> ;)
04:31:07 <JaffaCake> I don't care too much, cgprof is dead
04:31:18 <JaffaCake> should really fix it, though
04:31:33 <JaffaCake> I don't have a new enough mingw installed in order to test, though
04:31:38 <eivuokko> Well.  It seems dubious to me to if(Verbose) sleep(10);
04:31:43 <JaffaCake> bottom line, I'm waiting for someone to send me a diff :)
04:31:49 <eivuokko> I don't have old mingw to test with...
04:32:08 <eivuokko> I have diff..
04:37:59 <pejo> JaffaCake, your future research in your thesis mentions further generalisations of the deforestation algorithm. Were there any later publications on the issue, or did you dive deep into subtyping for Erlang?
04:38:35 <JaffaCake> pejo: yes, I didn't follow that up
04:39:04 <JaffaCake> short-cut deforestation turned out to be a more practical solution in the end
04:39:12 <ProfTeggy> JaffaCake, it turned out though, that deforestation generalizes certain optimization in the db query lanuage context (whcih the database people didn't anticipate).
04:39:35 <JaffaCake> right, I can believe that
04:39:47 <ProfTeggy> JaffaCake, I found this work to be most useful.
04:40:02 <pejo> JaffaCake, ok, thanks.
04:40:09 <JaffaCake> great!
04:41:23 <prionic> good day
04:42:12 <prionic> question: how do i convert an utf encoded string to latin1?
04:43:59 <dcoutts> prionic, you can do nothing, or you can replace high chars with some other char, eg '?'
04:44:30 <dcoutts> prionic, or use iconv or similar
04:47:53 <prionic> iconv? its not part of standard libraries, isnt it?
04:49:12 <dcoutts> iconv is not in the Haskell libs
04:49:39 <dcoutts> prionic, do you jsut mean ascii or you really mean latin1 (which uses all 255 chars right?)
04:52:36 <tuomov> another thing about iconv is that the encoding names are not standardised
04:54:03 <tuomov> but converting utf-8 to latin1 if you want to take the latin1 part of unicode and replace the rest with something else is quite easy
04:54:38 <tuomov> utf-8 is very easy to decode to unicode, and then you just replace everything above 255 with some replacement character, '?', for example.
04:56:14 <tuomov> however, I suggest not using a fixed encoding anywhere, although I don't know what exactly you're doing
05:12:49 * shapr yodels cheerfully
05:13:57 <shapr> kzm: you called?
05:38:37 * shapr boings
05:39:11 * shapr finds an excellent quote
05:39:51 <shapr> @remember SebastianHanowski I tried to formalise a proof of rev (rev l)  = l i found in W. Kluges book "Abstract Computing Machines - A Lambda Calculus Perspective" which is pretty much a 'Pimp My Ride' for SECD-machines.
05:42:40 <boegel> @quote shapr
05:42:40 <lambdabot>  I am hexed and vexed ;-)
05:42:53 <shapr> @quote boegel 
05:42:53 <lambdabot> boegel hasn't said anything memorable
05:43:01 * shapr doesn't believe it
05:43:09 <shapr> @quote
05:43:09 * boegel doesn't either
05:43:10 <lambdabot> kzm says: My program contains a bug.  How ungrateful, after all I've done
05:43:10 <lambdabot> for it.
05:43:38 <shapr> @quote JaffaCake 
05:43:38 <lambdabot>  I'm afraid I'm completely IA64-ignorant (and hoping to remain that way
05:43:38 <lambdabot> until IA64 goes away :-)
05:43:56 <dcoutts> that's a nice quote :-)
05:44:01 <JKnecht> yeah.
05:44:06 <boegel> @quote Itkovian
05:44:07 <lambdabot>  real programmers don't write docs, if it was hard to write, it should be
05:44:07 <lambdabot> hard to understand
05:44:22 <dcoutts> @quote shapr 
05:44:23 <lambdabot>  Programming is the Magic Executable Fridge Poetry, it is machines made
05:44:23 <lambdabot> of thought, fueled by ideas.
05:49:48 <dcoutts> I'm not quite sure to be honnest why everyone hates ia64 so much and loves amd64. At first ia64 seemed like a nice design. Of course no-one has been able to get their hands on any hardware because it's too expensive.
05:50:09 <dcoutts> and then there's the intel vs. amd thing
05:50:36 <dcoutts> but that doesn't completely explain it (I think)
05:51:52 <liyang> ia64 seemed a much nicer architecture.
05:52:01 <liyang> Last I read anything about it.
05:52:25 <liyang> Then again, these days niceness on a technical level has nothing to do with mass acceptance.
05:53:22 <Heffalump> amd64 has the backwards compatibility story. Which when all's said and done, and no matter how much they whinge about the resulting mess it leaves architectures in, people really care about.
05:53:46 <dcoutts> even us open-source folk
05:53:51 <dcoutts> (which seems odd)
05:55:31 <liyang> I don't care about binary compatibility. The problem is that there is no architecture in place for handling different platforms in the Win/x86 world.
05:56:44 <liyang> I care a hell of a lot more with regards to ease of low-level programming. Though I'm a little biased at the minute.
05:58:47 <liyang> (Four not-so-general-purpose registers is enough for anyone!)
06:01:04 <CosmicRay> JaffaCake: can you add me to the darcs group on cvs.h.o?
06:01:12 <JaffaCake> sure thing
06:02:00 <JaffaCake> CosmicRay: done
06:02:02 <CosmicRay> JaffaCake: thanks
06:02:55 <boegel> CosmicRay: yow ! working on HWN ? :)
06:04:35 <CosmicRay> boegel: dude, don't scare me like that!  it's just Monday! ;-)
06:04:54 <CosmicRay> boegel: actually, working on david roundy's plot to take over the world.
06:05:04 <CosmicRay> boegel: (aka the darcsification of fptools)
06:07:40 <boegel> CosmicRay: ok, cool
06:08:16 <boegel> it's just, I don't know anymore when HWN is supposed to be published, because it's so damn regular :P
06:08:51 <CosmicRay> hehe
06:08:59 <CosmicRay> it's supposed to be out on Tuesdays, US time
06:09:08 <CosmicRay> it actually happened on time last week! ;-)
06:09:17 <earthy> i.e. wednesdays, everywhere else. :)
06:09:27 <ricebowl> liyang - if you care about ease of programming, why care about IA-64? You have to hand-order instructions in one of a few patterns. It is very much not nice.
06:09:53 <ricebowl> liyang - x86 is 7 GPRs, not 4, and x86-64 is 15 GPRs which is sufficient even if not as nice as the 32ish that you get on most RISCs.
06:10:17 <earthy> um.
06:10:34 <earthy> the idea with IA-64 is that compilers do the instruction-ordering for you
06:11:10 <ricebowl> indeed, that was the point. The idea with IA-64 is that it is near-impossible to hand-write assembly.
06:11:43 <earthy> no, actually, the idea with IA-64 is to shift the burden of instruction ordering from the out-of-order scheduler in the processor to the compiler
06:12:10 <earthy> thereby saving on-die space, and assuming that a compiler has more knowledge about the program to optimize scheduling with
06:13:28 <Heffalump> how are compilers supposed to use all the microarchitectural registers, though?
06:13:44 <ricebowl> they're not
06:13:51 <Heffalump> so they can't schedule well
06:14:03 <ricebowl> they can schedule "relatively well"
06:14:18 <ricebowl> until you have to implement control structures, though if/else statements get special handling
06:14:57 <ricebowl> there is some special handling for loops, IIRC, so that a second iteration can start before the first finishes. And there is a loop counter register.
06:15:24 <Heffalump> so the hardware does "software" pipelining?
06:15:30 <ricebowl> no
06:15:35 <ricebowl> pipelining is different
06:15:46 <ricebowl> if it weren't pipelined, performance would be abysmal
06:16:09 <ricebowl> the compiler decides when an instruction will execute rather than the CPU itself re-ordering instructions on-the-fly
06:16:24 <ricebowl> it's the difference between a Pentium and a Pentium Pro or Pentium II
06:16:36 <Heffalump> but does the CPU do register renaming?
06:16:54 <ricebowl> hmm...I don't know. I don't think it has to.
06:17:07 <Heffalump> how many architectural registers are there, then?
06:17:21 <Heffalump> oh, 15, you said
06:17:26 <Heffalump> that doesn't seem very many
06:17:32 <ricebowl> a shitload, but a program can access up to 128 integer, 128 "media" (vector), and 128 floating-point registers simultaneously
06:17:39 <wilx> IA-64 != x86-64
06:17:57 <ricebowl> no, x86-64 has 16 integer registers + 16 vector/floating-point registers
06:18:05 <Heffalump> oh, right
06:18:15 <ricebowl> one is a stack pointer so I don't count that
06:18:20 <Heffalump> so how wide are the instruction encodings?
06:18:53 <ricebowl> hmm, I don't remember now; each individual instruction is an odd number of bits
06:18:59 <ricebowl> it's really foobar
06:19:21 <ricebowl> they use a register stack like SPARC, except the difference is that the window is 4 times wider.
06:19:26 <wilx> IA-64 uses bundles of three instructions...I do not remember the bundle width either.
06:19:32 <ricebowl> the lower *32* registers are program global
06:19:50 <liyang> ricebowl: they're not so general is my gripe. Anyway, I've been spoilt by RISC architectures.
06:19:53 <ricebowl> wilx - I want to say it's something like 42 bits
06:20:09 <ricebowl> liyang - that was true 15 years ago, but the 386 changed that ;)
06:20:17 <wilx> 128bit Bundle:. –. 3 x 41bt?
06:20:21 <wilx> (Googled.)
06:20:23 <ricebowl> wilx - something like that
06:20:48 <ricebowl> liyang - long multiplies and divides are *effectively* the only non-general uses left in the architecture
06:20:48 <liyang> ricebowl: I was doing hand-crafted x86 up to the 486.
06:21:05 <liyang> memory indexing?
06:21:21 <ricebowl> any register can be used to index memory
06:22:03 <liyang> hrm.
06:22:47 <liyang> I remember finding my PalmPilot much more pleasant.
06:22:50 <ricebowl> liyang - all memory references have the general form [base+index*scale+displacement], it can simplify to other forms, e.g. [base+disp] or [index*scale+disp]
06:23:13 <ricebowl> base and index can be any register except that index cannot be esp
06:24:31 <ricebowl> liyang - I thought SPARC was more fun than x86 ;) but not as fast, ironically
06:25:26 <liyang> Is that an issue with the architecture as opposed to the amount of effort thrown at it to make it go faster, though?
06:25:47 <ricebowl> well, in a sense, it can be.
06:26:21 <ricebowl> I'm CS, but I have talked with a bunch of EE guys. Most tell me that the register stack is a *terrible* idea for performance. The register file has to be small.
06:26:46 <ricebowl> SPARC has something like 512 or 1,024 regs. It has the floating window just like IA-64.
06:27:23 <jlouis> also, you do not win that much by the register stack. The Alpha just did everything faster than the Sparc
06:27:53 <ricebowl> liyang - I think that ultimately your answer is right, though ;)
06:28:18 <ricebowl> x86 killed off most of the RISCs just because it was cheaper
06:28:41 <jlouis> and it became faster over time
06:28:56 <SlowByte> ARM is still alive :) I like it
06:28:58 <ricebowl> yeah, around the time of the Pentium and Pentium Pro/Pentium II
06:29:26 <liyang> I imagine the register stack would be easier / faster for implementing a G machine though.
06:29:27 <SlowByte> and the chinese are working on the MIPS-based Godson
06:29:47 <SlowByte> that should deliver tolerable performance
06:29:54 <SamB> I thought most of the RISCs just got indistinguishable from CISC
06:29:57 <jlouis> ... with performance like a pii 400mhz
06:30:10 <jlouis> SamB: nah
06:30:17 <ricebowl> SamB - there are only 2 serious CISCs these days: PowerPC and x86
06:30:31 <ricebowl> ...and they're not really very CISCish anymore
06:30:34 <jlouis> They have a + b -> c type operations, while the CISCs tend to have a + b -> a
06:30:39 <SlowByte> I checked the architecture docs, it might be clocked 400MHz but it's superscalar to the max
06:30:51 <jlouis> (not that it matters that much)
06:30:58 <SamB> oh, is that how it is?
06:31:43 <Heffalump> SlowByte: ARM only has 16 architectural regs, though :-)
06:31:47 <CosmicRay> JaffaCake: how did you determine that the earliest commit on ghc-6-4 was 2005/02/04?  I don't have a good way of checking, but I'm seeing some files in 2004-11-10 when I do cvs rlog -bghc-6-4
06:32:03 <SamB> is there something wrong with a PII 400MHz?
06:32:05 <CosmicRay> though it has been ages since I have used branching in cvs and I may not correctly remember how it is supposed to work
06:32:12 <jlouis> SamB: not at all
06:32:13 <SlowByte> Heffalump: well, 32 usually, one reg group for fast interrupts
06:32:29 <SamB> good, because mine is a PII 450 MHz ;-)
06:32:31 <JaffaCake> CosmicRay: I looked in CVSROOT/commitlogs/ghc, and grepped for 'ghc-6-4-branch'
06:32:46 <Heffalump> SlowByte: yeah, not useful for  general purpose, though
06:33:13 <ndm> is there any way in GHC to get prodded when a Handle is written to?
06:33:15 <JaffaCake> CosmicRay: that only checks ghc though, there may have been earlier commits to libraries, testsuite or nofib
06:33:26 <ndm> i don't really want to use either polling or threads
06:33:28 <SlowByte> but I'd say 16 is "enough"
06:33:32 <CosmicRay> JaffaCake: ok, thanks.
06:33:39 <CosmicRay> it is testsuite that I'm looking at now.
06:33:58 <JaffaCake> ok, I'm surprised if there were commits that much earlier
06:34:06 <SlowByte> though actually only 13 or 14 are usable
06:34:10 <CosmicRay> I may be misinterpreting the results
06:34:12 <JaffaCake> CosmicRay:  which file?
06:34:27 <CosmicRay> perhaps the last version in HEAD as of the date of the branch could have the branch tag as well
06:34:43 <Heffalump> I'd say 14 or 15
06:34:49 <CosmicRay> JaffaCake: testsuite/README, rev 1.11, 2004-11-10
06:35:02 <JaffaCake> ah right, that's not a commit on the branch
06:35:04 <Heffalump> (depending on lr)
06:35:33 <CosmicRay> JaffaCake: yeah, I guess the version number should have told me that.  ok.  I think I can make this go somehow.
06:35:44 <SlowByte> well yeah, if you're not doing any ffi.. but otherwise there's sp, pc, lr and 0 IIRC?
06:36:35 <Heffalump> well, you can stack lr before making a call
06:36:39 <Heffalump> same with 0
06:36:42 <SlowByte> true
06:36:44 <Heffalump> depends what you're doing
06:37:04 <Heffalump> sorry, I did mean 13 or 14.
06:37:15 <Heffalump> cos sp and pc are pretty much unconditionally unusable, and lr might be
06:39:00 <flux__> ndm, I don't seem to be able to find select or poll-like functions, so maybe they don't exist
06:39:13 <ndm> flux__: :(, thanks for looking though
06:39:17 <SlowByte> the XScale Wireless MMX extensions are interesting... though I don't really see how they've got anything to do with Wireless.. someone must've liked buzzwords
06:39:18 <ndm> i cound't find any either
06:39:39 <flux__> so I imagine threads it is
06:40:37 <flux__> I think it should be possible to write a monad that would support read/write/accept in a way that would not need threads, but only a select/poll loop
06:40:38 <SlowByte> too bad there isn't a demand for ARM/Linux-based subnotebooks, I'd love to have one
06:41:04 <ndm> flux__: if i could create my own handle, which had functions to do these things
06:41:08 <ndm> then i could do it
06:51:17 <flux__> hm, can one extend Text.Printf somehow?
06:52:30 <Heffalump> SlowByte: I think it's the fact that the XScale is intended for wireless
06:56:39 <Heffalump> SlowByte: there's also http://www.arm.com/products/CPUs/NEON.html now, but it'll be a while before you get silicon with it
06:57:03 <shapr> I'd also like to have an inexpensive linux laptop that doesn't use x86 of any flavor.
06:57:22 <CosmicRay> JaffaCake: there are some .hi files checked in on nofib.  darcs will ignore them by default due to its "boring" rules.  Is that OK with you, or do you really want those files to be versioned in the repo?
06:57:39 <JaffaCake> really? where?
06:58:06 <CosmicRay> all over the place
06:58:13 <CosmicRay> cd /srv/cvs/cvs.haskell.org/fptools/nofib
06:58:16 <CosmicRay> find . -name "*.hi,v"
06:58:26 <CosmicRay> 725 of them
06:58:36 <JaffaCake> wow
06:58:37 <CosmicRay> all but two are in Attic, though
06:58:51 <CosmicRay> so 723 of them wouldn't appear in a checkout of HEAD
06:58:54 <CosmicRay> the two remaining ones are:
06:58:59 <CosmicRay> ./real/HMMS/lib/haskell/Builtin.hi,v
06:58:59 <JaffaCake> perhaps it was a big mistake at some point
06:58:59 <CosmicRay> ./PRIVATE/nhccomp/test.hi
06:59:30 <JaffaCake> ah right, this is probably because we used to keep .hi files in the source tree
06:59:46 <CosmicRay> so is it OK to ignore them on the darcs side?
07:00:04 <CosmicRay> or do you really want that history to come along?
07:00:07 <JaffaCake> the HMMS one is in a part of the tree that is never built
07:00:31 <JaffaCake> yes, it would be more correct to include these in the repo
07:00:38 <CosmicRay> ok.
07:00:43 <CosmicRay> hmm, this PRIVATE dir...
07:00:48 <CosmicRay> it is not world-readable.
07:00:52 <CosmicRay> what do you want to happen with it?
07:00:54 <JaffaCake> oh yes, forget the PRIVATE dir
07:01:02 <JaffaCake> leave it out, if possible
07:01:25 <CosmicRay> ok, I will try.
07:01:55 <CosmicRay> are there any other dirs like that in the tree?
07:14:42 <shapr> shazam!
07:17:05 <CosmicRay> heh
07:22:36 <ski> flux__ : iirc, this was about something like implementing a "thread" monad, with help of 'select'-like things http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lab2.html
07:22:46 <boegel> @elite radio
07:22:46 <lambdabot> RaDIo
07:22:52 <boegel> @elite boegel radio
07:22:53 <lambdabot> bO39E1 RADi0
07:26:36 <ski> hi Frederick_uni
07:26:50 <Frederick_uni> ski can you see me??
07:26:59 <ski> sure
07:27:00 <Frederick_uni> omfg it works!
07:27:11 <ski> why shouldn't i be able to ?
07:27:23 <ski> (what works ?)
07:28:00 <Frederick_uni> im actually executing irc from behing uni network what is "blocked"
07:28:30 <ski> oh
07:31:12 <lisppaste2> Frederick pasted "closure problem" at http://paste.lisp.org/display/14081
07:33:24 <boegel> doesn't seem to be blocked to me :)
07:35:16 <basbom> how to use the get CurrentDirectory function in hugs. It just returns a IO (). I would like to see the list of files.
07:36:09 <SlowByte> heehee, it's fun to read comments from 2002... "Intel will never use AMD64's instruction set! NEVER! impossible!"
07:36:22 <int-e> uhm. open ".", get the directory contents?
07:36:45 <SlowByte> I bet those guys must feel pretty stupid reading their comments now
07:36:53 <basbom> Is this possible from the hugs command prompt?
07:36:58 <Lemmih> @type System.Directory.getDirectoryContents
07:36:59 <lambdabot> FilePath -> IO [FilePath]
07:37:11 <tromp> g'afternoon
07:37:35 <SamB> SlowByte: they did insist on changing the name and implementing it in a slightly incompatible way
07:38:00 <basbom> yes sorry about that IO [FilePath] is the correct returned value. But still how can I see the list of files?
07:38:33 <SamB>  >>= print?
07:39:50 <SamB> @index getCurrentDirectory
07:39:51 <lambdabot> System.Directory, Distribution.Compat.Directory
07:40:14 <SamB> like:
07:40:16 <SamB> System.Directory> getCurrentDirectory >>= print
07:40:16 <SamB> "/home/naesten/hacking/haskell/conjure"
07:40:41 <SamB> and that looks like IO String == IO FilePath to me
07:41:52 <int-e> type FilePath = String  -- Imported from GHC.IOBase
07:42:22 <SamB> as opposed to IO [FilePath]
07:43:35 <basbom> SamB: thx. Is it now possible to list the contents of this directory?
07:44:01 <basbom> with getDirectoryContents
07:45:49 <SamB> getCurrentDirectory >>= getDirectoryContents >>= print
07:46:07 <basbom> very nice indeed.
07:46:22 <basbom> i'm doing some sysadmin work with hugs
07:46:31 <basbom> renaming files and the like
07:46:37 <basbom> seems to be feasible
07:47:39 <CosmicRay> JaffaCake: I think we ought to have a darcs.haskell.org set up, that points at the same place that cvs.haskell.org/darcs goes to.
07:47:48 <SamB> nice
07:47:57 <JaffaCake> sure
07:47:58 <CosmicRay> JaffaCake: I don't know who runs DNS, would you mind making the request?
07:48:05 <JaffaCake> ok, will do
07:48:13 <CosmicRay> JaffaCake: thanks again.
07:48:25 <CosmicRay> JaffaCake: I have nofib, testsuite, and libraries in progress right now.
07:48:50 <SamB> its nice to see sysadmin work in Haskell ;-)
07:49:19 <SamB> it shows that Haskell can be very down-to-earth
07:49:42 <JaffaCake> CosmicRay: excellent, I look forward to trying it out :)
07:50:47 <SamB> jlouis: oh, are you around still?
07:51:16 <SamB> Frederick_uni: oh, you wanted to bug me some?
07:55:47 <Saulzar_> Hmm, hs-plugins looks really cool. I wonder if it is possible to do something like Robocode with dynamic loaded bots
07:56:01 <SamB> whats robocode?
07:56:02 <SamB> and yes.
07:56:19 <SamB> is that that java thing?
07:56:26 <Saulzar_> Robocode is a java AI game where you write your little bot in Java and it fights other bots
07:56:29 <Saulzar_> Yeah
07:56:38 <SamB> yeah, of course it is
07:57:56 <Saulzar_> Might be a neat project (I'm just looking for something to do, been writing a little raytracer) 
07:58:36 <SamB> yeah, it might
08:00:57 <SamB> another neat project is conjure
08:01:01 <SamB> @where conjure
08:01:02 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
08:01:03 <Saulzar_> To do it well though I suspect would be hard, various issues like ensuring a bot doesn't steal the cpu for more than it's share, or stopping it being naughty with IO 
08:01:34 <eivuokko> Sub-processes are easier in that regard.
08:02:09 <SamB> well, besides scanning the source code for unsafe, I'm not sure what you could do in that regard ;-)
08:02:51 <Frederick_uni> ski I got a real connection now
08:03:01 <Saulzar_> Well, perhaps that would be enough if you had it dynamically compiled...
08:03:19 <ski> m
08:06:53 <jeffno> I'm trying to run a simple Minesweeper app in Hugs.  Can somebody see if it works for them, and if not, how to fix it?
08:06:56 <SamB> Saulzar_: personally, I would just not worry about it
08:06:57 <jeffno> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/Games/
08:07:14 <Saulzar_> SamB, I'm not - first get something which works - yes? :) 
08:07:24 <SamB> exactly ;-)
08:07:45 <jeffno> The two files are Minesweeper.hs and MineRandom.hs
08:07:57 <Frederick_uni> yo SamB I still believe and try :-)
08:08:01 <SamB> its not like you are going to set up your system to accept programs by email automatically, or anything
08:08:14 <jeffno> I get the error: MineRandom.hs":55 Undefined constructor function "TOD"
08:08:53 <Saulzar_> Robocode is fairly robust in that regard - Java has all sorts of security stuff, so they have tournament servers where people can upload bots and whatnot 
08:11:24 <SamB> jeffno: try using System.Time instead of Time
08:11:38 <SamB> Time apparantly exports ClockTime abstractly
08:11:52 <SamB> which you can see by doing :b Time
08:12:12 <SamB> and noting the lack of an equal sign after "data ClockTime"
08:12:58 <skew> even the : command is unhappy about it
08:13:25 <SamB> skew: about what?
08:14:19 <SamB> in any case, if you WERE accepting programs via email or whatever, you could just scan the source for "unsafe"
08:14:41 <SamB> and maybe restrict the imports or something
08:14:56 <skew> I don't know that the ffi stuff is safe either
08:15:02 <SamB> oh, true
08:15:09 <jeffno> SamB: Pardon, I'm a total n00b.  So after I changed the import to System.Time, I get the error: Minesweeper.hs":39 - Syntax erroin instance head (variable expected)r 
08:15:16 <skew> some of the pointer arithmetic and so on
08:15:24 <SamB> jeffno: oh?
08:16:09 <SamB> jeffno: well, that means the trouble is now in Minesweeper.hs, which is progress ;-)
08:16:25 <jeffno> Yes, I think so :)
08:16:57 <SamB> so which instance head is on line 39?
08:17:23 <SamB> instance AddThree [Int]?
08:17:31 <SamB> I think you want to use
08:17:46 <SamB> instance AddThree a => instance AddThree [a]
08:18:32 <skew> the Foreign.Ptr stuff has a cast and doesn't do bounds checking, does it
08:18:48 <SamB> skew: well, so, restrict imports, no pragmas, no unsafe
08:19:05 <SamB> or just inspect code first ;-)
08:19:11 <skew> also, run in a separate process to control resource usage
08:19:50 <SamB> but, don't worry about it until you have something that works
08:23:36 * SamB sends jlouis patches from him and adept
08:24:12 <SamB> jeffno: you got that about the instance head?
08:25:16 <Saulzar_> Yes - have to see how steep the slope is for a haskell nearly-novice :)
08:25:37 <jeffno> SamB: Nope, I can't get it to work.
08:26:13 <skew> Saulzar_: that means if we keep pushing they'll rise quickly!
08:26:39 <CosmicRay> JaffaCake: is it conceivable that there have been no commits on the ghc-6-4 branch for nofib?
08:26:53 <JaffaCake> yes, quite likely
08:27:19 <SamB> jeffno: okay, I guess I'll try it myself ;-)
08:27:27 <jeffno> Thanks!
08:28:30 <SamB> @index unsafePerformIO
08:28:31 <lambdabot> System.IO.Unsafe, Foreign
08:30:30 <SamB> jeffno: so you got only one error?
08:30:37 <SamB> at "instance AddThree [Int] where"?
08:30:56 <jeffno> Yes.
08:31:17 <jeffno> Maybe I changed that line wrong based on your suggestion?
08:31:35 <SamB> when you replace that with "instance AddThree a => AddThree [a] where" it seems to work.
08:31:48 <SamB> maybe I confused you be leaving off the where in my change suggestion?
08:32:10 <jeffno> Yes, that was it.  Thanks!
08:32:37 <SamB> you are welcome
08:34:13 <jeffno> Ah, I missed the comment at the top: "NB: Requires Hugs Exts Mode for ..."
08:34:49 <SamB> oh
08:35:21 <SamB> well, this way is better style and safer
08:35:34 <SamB> those extensions are best avoided when possible
08:35:43 <jeffno> Ok, I'll make a note of that.
08:36:31 <SamB> I think -fallow-overlapping-instances or -fallow-undecidable-instances would have worked for that
08:36:58 <CosmicRay> JaffaCake: darcs get --partial http://cvs.haskell.org/darcs/nofib
08:37:07 <CosmicRay> JaffaCake: omit the --partial if you want to see the complete history.
08:37:26 <JaffaCake> CosmicRay: fantastic, thanks, I'm off now will look tomorrow
08:37:30 <CosmicRay> ok.
08:38:05 <xerox> Downstream Speed:  5056 kbps
08:38:07 * xerox dances
08:39:09 <SamB> jeffno: I just now notice that it says "earlier versions require the Hugs extensions", implying that some later version(s) should be okay
08:39:52 <jeffno> I dunno, this code was written in 2002.
08:41:37 <SamB> Minesweeper5.hs does the same thing as I just did.
08:41:50 <SamB> although probably it was actually some earlier version
08:42:20 <SamB> hmm, it wants a square board?
08:42:33 <jeffno> ?
08:42:57 <jeffno> Do you mean the lack of horizontal spacing?
08:43:12 <SamB> this version requires you to pass number of mines and square boardsize
08:43:16 <CosmicRay> JaffaCake: quick question.  when you said to look at the branch "ghc-6-4", did you really mean "ghc-6-4-branch"?  I don't see any commits to "ghc-6-4" in the commitlogs.
08:43:41 <JaffaCake> yes, sorry
08:43:46 <JaffaCake> ghc-6-4 is the tag
08:43:48 <jeffno> Oh, I'm still on the first version.  I just wanted some simple, but interesting, running code to play with.
08:48:56 <xerox> @bot
08:48:57 <lambdabot> :)
08:50:40 <SamB> jeffno: I'm not sure this qualifies as "simple"
08:51:20 <jeffno> Well, the functionality is simple.
08:52:00 <jeffno> If the code includes all the goodies of Haskell, I'm even happier :)
08:52:31 <xerox> Gtk2Hs minesweeper?
08:52:34 <SamB> want to see my BF interpreter?
08:52:45 <jeffno> What's BF?
08:52:47 <SamB> note that it uses some "advanced" techniques
08:52:53 <SamB> brainf*ck
08:53:08 <jeffno> Sure, why not?
08:53:31 <SamB> @google site:paste.lisp.org BF SamB
08:53:33 <lambdabot> http://paste.lisp.org/list?20
08:53:36 <SamB> hmm
08:53:40 <SamB> @google site:paste.lisp.org BF SamB Parsec
08:53:41 <lambdabot> No result found.
08:53:58 <SamB> @google site:paste.lisp.org SamB bf interpreter
08:53:59 <lambdabot> No result found.
08:54:18 * SamB looks on the first result...
08:56:29 <SamB> http://paste.lisp.org/display/13015
09:00:55 <lisppaste2> ski annotated #14081 with "simplify" at http://paste.lisp.org/display/14081#1
09:01:21 <xerox> What is it?
09:01:50 <SamB> xerox: which, mine?
09:01:59 <SamB> thats my BF interpreter
09:02:04 <xerox> No, I know that nice interpreter :-)
09:03:25 <ski> (xerox : Frederick's stuff .. i worked through with him what he seemed to want to do, and he wanted me to paste it somewhere, since he had to leave)
09:06:52 <SamB> jeffno: anyway, the URL for my BF interpreter is http://paste.lisp.org/display/13015
09:06:58 <SamB> you can download it from http://paste.lisp.org/display/13015/raw
09:11:45 <jeffno> SamB: Cool, it works!  Got a "Hello World!" running :)
09:11:57 <xerox> Heh.
09:14:02 <araujo> Hello Haskell'ers!
09:14:13 <xerox> Boingy-boing.
09:23:39 <SamB> jeffno: that interpreter is a simple program which uses complicated features ;-)
09:25:35 <SamB> it is a demo of a some of the coolest Haskell features and libraries
09:27:24 <SamB> namely, monads, Parsec, the monad transformer library (Control.Monad.*), and probably a bunch more stuff
09:27:48 <SamB> oh, and Foreign.Ptr
09:29:05 <SamB> jeffno: parseInstr is probably the closest thing in that program to an "inner loop"
09:29:59 <jeffno> You mean non-recursive?
09:30:57 <SamB> no, I mean that my interpreter parses BF code into a Haskell function
09:31:29 <jeffno> I don't understand how that equates with inner loop?
09:31:48 <SamB> its where all the interesting parsing happens
09:31:53 <SyntaxNinja> 'morning
09:31:58 <Lemmih> Hiya SyntaxNinja.
09:32:56 <shapr> hiya SyntaxNinja 
09:33:17 <SyntaxNinja> y0 Lemmih y0 shapr
09:33:31 <SyntaxNinja> Lemmih: I'm re-doing the cabal-get-bootstrap stuff to use my new cabal-install script :)
09:33:59 <SamB> the BF is parsed directly into a Haskell value of type BF a () = StateT (Ptr a) IO b
09:34:00 <SyntaxNinja> cabal-install foo-1.0.tgz bar/bar.cabal --user --prefix=$HOME/usr
09:34:11 <Lemmih> Nice.
09:34:28 <SyntaxNinja> so it can take a tarball, a directory, or a .cabal file on the command line, plus configure args, and configures, builds, and installs it.
09:34:31 <jeffno> So Haskell has an eval-like function?
09:34:39 <SamB> nope
09:34:44 <araujo> jeffno, you can use hs-plugins
09:34:54 * Lemmih has secretly been planning to reimplement HackageDB with HASP-0.4.
09:34:54 <SamB> I just build up the code from component parts
09:36:14 <SyntaxNinja> Lemmih: you have to stop reimplementing HackageDB
09:36:23 <SamB> like, (char '<' >> return prev) will parse a '<' and return prev, which is the implementation of the < instruction
09:36:34 <SyntaxNinja> Lemmih: or you can do it some day, but first we need to release it. I think I might have someone to take over maintainership. we'll see.
09:37:24 <SamB> so basicly we parse a program directly into its implementation
09:37:37 <jeffno> I think I see.
09:37:57 <SamB> and whats more, the parsing is right in with the ordinary code
09:39:11 <SamB> I suppose this might be better with comments
09:39:27 <SamB> anybody have a repo of neat haskell demos?
09:40:42 <shapr> of what sort?
09:41:00 <SamB> shapr: well, take http://paste.lisp.org/display/13015 for example
09:41:10 <SamB> only pretend it has comments
09:41:53 <shapr> http://cvs.sf.net/viewcvs.py/haskell-libs/libs/brainfuck/Brainfuck.hs?rev=1.1&view=markup
09:42:34 <shapr> Oh, you want neat parsing demos?
09:43:03 <shapr> http://cryp.to/hsemail/
09:43:10 <shapr> Those are really neat.
09:43:11 <SamB> not just parsing
09:43:23 <davve_> was there a specific ghc snapshot agreed upon for hIDE dev?
09:43:24 <shapr> Frag is the coolest recent Haskell demo.
09:43:50 <Lemmih> davve_: We still use GHC-6.4.1
09:44:10 <SamB> well, something that is preferably not too long for a n00b to have some chance of at least getting an inkling of how it works
09:44:23 <SamB> anyway, what about the "repo" part?
09:44:38 <shapr> oh
09:45:02 * Lemmih hasn't been able to get hIDE/hs-plugins working with /any/ snapshot of ghc-6.5.
09:45:11 <SamB> also, that bf function has too many args
09:45:18 <shapr> Actually, RFC parsers probably are simple enough for a n00b, but that may be my biased viewpoint.
09:45:19 <SamB> and too little alignment
09:45:42 <SamB> well, you mentioned Frag
09:45:44 <fworp> RFC parsers?
09:45:55 <SamB> which is most likely too complicated for a n00b to get much out of 
09:46:10 <fworp> oh
09:46:12 <shapr> Yeah, HsEmail includes RFC2234, RFC2821, and RFC2822
09:46:15 <SamB> and they almost certainly wouldn't know where to start
09:46:34 <shapr> Yeah, true. lambdabot was designed to be a code-toy for n00bs to jump into.
09:47:08 <jeffno> Something like DrScheme for Haskell would be interesting.
09:47:11 <shapr> Especially since you get immediate public visibility of a cool plugin.
09:47:18 <Frederick_uni> back
09:47:28 <SamB> maybe so, but its hard to make much sense out of the lambdabot core these days, isn't it?
09:47:35 <SamB> I mean, not insanely hard or anything.
09:47:46 <shapr> What about Pivotal? http://www.cs.kent.ac.uk/projects/pivotal/
09:47:58 <Frederick_uni> yo ski are you alive?
09:48:00 <SamB> also, I'm sensing a lack of "gee wiz" in lambdabot's core
09:48:05 <shapr> You don't have to make sense out of the core, plugins are easy to write.
09:48:16 <SamB> true
09:48:38 <shapr> Oh hey
09:48:44 <SamB> but how does that show off Parsec and monad transformers and all?
09:49:23 <SamB> thats more of a sandbox than a demo
09:49:25 <shapr> hs-plugins can do the whole recompile and reload bit whenever the source is changed, maybe that should be a Config setting for lambdabot?
09:49:59 <SamB> hmm.
09:50:01 <shapr> As in, what about a setting where execution of a known command will check to see if that module has changed, and if so, rebuild and reload?
09:50:08 <SamB> maybe!
09:50:10 <shapr> That would be more interactive.
09:50:23 <SamB> but definately should default to "off" position
09:50:39 <shapr> Of course, Yi with a C-x C-e command would be best.
09:51:31 <SamB> anyway, I just mean a repo for neat little demos
09:51:34 <shapr> If you want a monad transformers demo, check out http://www.haskell.org/tmrwiki/SolvingSudoku
09:51:51 <xerox> @where Frag
09:51:51 <lambdabot> http://www.cse.unsw.edu.au/~pls/repos/frag
09:52:24 <shapr> If you want a crazy cool Parsec demo, try http://www.haskell.org/tmrwiki/ImpureThoughts_2f1
09:53:32 <davve_> lemmih, okay
09:54:16 <davve_> lemmih, and the problem with the unknown exception from ghc-api is still there I guess?
09:54:31 <SamB> isn't TH a bit much for n00bs?
09:57:20 <SamB> besides being an awkward way to write a compiler?
09:57:55 <SamB> in that the resulting compiler would be awkward to use
09:58:07 <Lemmih> davve_: Yeah. I would like hear about it if you manage to run hIDE with ghc-6.5. It has been a show-stopper for the last month or so.
09:59:29 <davve_> Lemmih, okay.. well.. for now I'm still using ghc-6.4.1 but maybe later.. sooner or later I'll want to try to do something with ghc-api
10:00:39 <shapr> SamB: The 'Gee Whiz' score is very high though.
10:00:40 <xerox> Anybody has a subscription to: http://www.jstor.org/ ?
10:00:59 <shapr> That's an extremely easy way to write a compiler. 
10:01:23 <davve_> Lemmih, right now I'm compiling gtk2hs since i saw you're depending on the latest version
10:02:51 * jeffno tries to compile Frag
10:03:09 <jeffno> "Could not find module `Graphics.UI.GLUT'"
10:03:21 * xerox wants to read "The root-finding route to chaos (4 Jun 03) describes how fractals can be inserted into the precalculus curriculum."
10:07:28 * jeffno installs the optional ghc modules he didn't when first installing.
10:08:55 <shapr> xerox: Wow, sounds cool.
10:09:39 <jeffno> Yikes, slow compile.
10:10:02 <shapr> Bet it's faster than building Quake
10:10:20 <jeffno> Probably not line for line, but maybe for the whole project :)
10:11:51 <shapr> SamB: bringert's ParseDate is a thoroughly useful Parsec demo. It's strftime in reverse.
10:12:15 <shapr> er, formatCalendarTime in reverse.
10:16:33 <xerox> shapr: yea, hmpf!
10:17:02 <xerox> It's the second time I face those darn institutions....
10:17:15 <shapr> We could reverse engineer it from the description.
10:17:45 <xerox> Pick up all the pre-calculus ideas in a.. fractal?  Hmm.
10:18:01 <shapr> Root finding probably refers to roots of negative numbers?
10:18:29 <xerox> I think it refers to polynomials, iteration, and fixed points.
10:18:38 <shapr> hm
10:19:46 <xerox> I can't really say if you need {,after}-calculus ideas to grok dynamical systems...
10:21:24 <xerox> I could be wrong, too :-)
10:22:37 <shapr> I'd like to learn some control theory.
10:22:41 <xerox> Do you want a free teaching-and-learning-iteration.pdf, to please the mouth with some taste of what it could be?
10:22:52 <shapr> I wonder if the Yampa soccer robots demo still works.
10:23:49 <basbom> how can i run a program with hugs. the program is in a file called test.hs
10:24:11 <shapr> hugs test.hs ?
10:24:18 <SamB> runhugs?
10:24:30 <xerox> runhaskell!
10:24:33 * shapr writes Haskell code to do his timesheet for him.
10:24:48 <xerox> shapr: that's something I'd like very much, too.
10:25:05 <SamB> shapr: control theory? I don't think there is such, per se
10:25:15 <shapr> At the moment I'm using MoinMoin with @DATE@ and bringert's ParseDate like so: parseCalendarTime defaultTimeLocale "%Y-%m-%dT%T%Z" "2005-11-01T12:47:21Z"
10:25:23 <tuomov> xerox: 4 jun 03? I found something from '91.
10:26:12 <basbom> the program should print "hello". but nothing happens. I am using putStr "hello"
10:26:16 <ndm> basbom, windows or linux?
10:26:17 <shapr> @wikipedia Control theory
10:26:19 <lambdabot> http://en.wikipedia.org/wiki/Control_theory
10:26:22 <basbom> windows
10:26:33 <ndm> first, if i were you i'd get the new copy of winhugs
10:26:35 <ndm> @where WinHugs
10:26:36 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
10:26:40 <xerox> tuomov: uh, could you point me to it?  Thanks very, very much.
10:26:44 <ndm> then File, Open - select the file you wish to load
10:26:57 <ndm> in Test.hs you should have something like: main = putStr "hello"
10:27:07 <ndm> then in WinHugs, just type "main" (without the quotes)
10:27:54 <basbom> but why doesn't this work from the command prompt. with hugs.
10:28:52 <shapr> Actually, I'd like to write some TORCS robots with Yampa.
10:29:10 <flux__> ndm, did you find select for haskell already?
10:30:27 <ndm> flux__: no
10:30:42 <flux__> ndm, ski bumped me into right direction, it appears to be in package util, module Select
10:30:46 <ndm> basbom, runhugs should be used instead
10:30:55 <ndm> flux__: windows as well?
10:31:00 <flux__> ndm, no idea
10:31:28 <ndm> flux__: thanks anyway
10:33:53 <xerox> shapr: tuomov seem to have found an updated version to my eyes, want to check it out too?
10:37:03 <astrolabe> control theory is interesting, from what I've seen of it.
10:37:28 <lisppaste2> Frederick pasted "doesnt compile!" at http://paste.lisp.org/display/14089
10:40:13 <basbom> ndm: thx. I will try winhugs.
10:40:44 <ndm> basbom: if you find any bugs, make sure you email a hugs users list, or me personally
10:42:15 <basbom> ndm: ok
10:49:20 <SamB> @google docs GTK_STOCK_OPEN
10:49:22 <lambdabot> http://home.y3m.net/~zach/docs/gtk/gtk-stock-items.html
10:51:02 * SamB realizes that has nothing to do with his problem
10:54:44 <basbom> are there any tools to parse an xml file with haskell?
11:11:57 <Akshaal> is there deep version of Control.Exception.evaluate ?
11:13:28 <Cale> Akshaal: combine it with Control.Parallel.Strategies.rnf
11:13:42 <Cale> evaluate (blah `using` rnf)
11:16:16 <Cale> unfortunately, you'll have to make any data structures you have instances of NFData for that, but the really common ones already are
11:16:33 * Akshaal in a state of stupor looks at Control.Parallel.Strategies
11:16:49 <Akshaal> looks like a hack...
11:16:54 <Cale> You should have a look at the paper :)
11:17:05 <Cale> it's actually pretty elegant :)
11:17:45 <Akshaal> Cale: thanks anyway :)
11:18:13 <Cale> http://research.microsoft.com/Users/simonpj/Papers/strategies.ps.gz
11:20:50 * SamB wonders why you can't really run pivotal with ghc -e
11:26:15 <Akshaal>  Control.Exception.catch (evaluate $ Just undefined) (\e->do {print $ show e; return $ Just 10}) >>= print
11:26:19 <Akshaal> Just *** Exception: Prelude.undefined
11:35:00 <shapr> gwahr
11:35:35 <shapr> If I read too much about Feynman at the same time, I start coming up with even crazier ideas than usual.
11:35:42 <SyntaxNinja> OK cabal darcs repo now has cabal-install as a "make install" target. you'll get a new executable that is 1337
11:35:58 <xerox> What are you reading about Feynman?
11:36:08 <ski> Akshaal : i think that 'evaluate' will only force the outer constructor, but not the argument ('undefined') .. so it doesn't catch the exception
11:36:17 <shapr> xerox: http://www.longnow.org/views/essays/articles/ArtFeynman.php
11:36:22 <SyntaxNinja> oh, actually it's a "make cabal-install" target. lemmy fix that
11:36:29 <xerox> Danke.
11:36:29 <shapr> I wish I'd known Feynman.
11:37:08 <SyntaxNinja> fixed
11:37:18 <SyntaxNinja> cabal-install rules. you guys should go try it.
11:37:22 <shapr> When Feynman died, the university that employed him did an academic search to find a replacement. They couldn't, unsurprisingly.
11:37:23 <Cale> (evaluate $ Just $! undefined)
11:38:06 * shapr grabs the latest cabal
11:39:53 <davve_> hm.. ghc complains about finding a certain module in two different packages, even though one of them is hidden.. 
11:40:07 <davve_> what's up with that?
11:40:13 <ski> (let evaluateMaybe Nothing = return Nothing; evaluateMaybe (Just a) = evaluate a >>= \a -> return (Just a) in evaluateMaybe $ Just undefined)
11:40:24 <Philippa> shapr: my english teacher once lent me one of his autobiographies because she thought I'd like it and find some of it familiar
11:40:24 <chucky> davve: Do you have old .o or .hi files lying around that might confuse ghc?
11:40:50 <SyntaxNinja> davve_: which version of ghc?
11:41:47 <davve_> syntax, ghc 6.4.1
11:41:54 <davve_> chucky, ah.. that might be it
11:42:15 <SyntaxNinja> davve_: good chance that there's somethng that depends on both the hidden and exposed one.  
11:42:42 <CosmicRay> SyntaxNinja: jaffacake is saying that this is your bug: https://sourceforge.net/tracker/?func=detail&atid=108032&aid=1364839&group_id=8032
11:42:55 <CosmicRay> SyntaxNinja: and that the auto ghci libs option is going away
11:46:26 <CosmicRay> heh: 11:45:51 [I] Cached information about 23353 pending changesets
11:46:45 <Cale> instance (NFData a) => NFData (Maybe a) where rnf Nothing = (); rnf (Just x) = rnf x
11:46:53 <SyntaxNinja> CosmicRay: right. I think i mentioned that the other day.
11:47:11 <CosmicRay> oh, I thought you told me that the bug was in ghc-pkg.
11:47:25 <SyntaxNinja> CosmicRay: but it's possible that cabal will still try to build the ghci libs during the build phase, even if that's not valid.
11:47:48 <SyntaxNinja> well, ghc-pkg should definitely do something smarter there.
11:48:02 <CosmicRay> SyntaxNinja: that should still work even if ghci isn't supported ona  given platform, right/
11:48:25 <SyntaxNinja> ghc-pkg should know that it can't do that on a platform that doesn't support ghci
11:48:40 <SyntaxNinja> CosmicRay: don't know. depends on the flags that ld accepts.
11:49:00 <SyntaxNinja> CosmicRay: cabal > 1.0 has flags to turn off building ghci libs, also fwiw.
11:49:20 <CosmicRay> SyntaxNinja: I suspect it would be broken on AIX.
11:49:32 <CosmicRay> SyntaxNinja: I'd call it a bug of ./setup build and ./setup install don't DTRT on every platform
11:49:47 <CosmicRay> people on non-GHCI platforms should have excessively difficult lives
11:49:50 <bojohan> shapr: that's indeed a very interesting article. i think i've read it twice.
11:50:17 <SyntaxNinja> CosmicRay: right. I think cabal should make --no-ghci-libs (or whatever) the default on non-ghci platforms, but I doubt it does that now.
11:50:33 <CosmicRay> SyntaxNinja: is there a cabal bts somewhere that Ishould report this to?
11:51:20 <SyntaxNinja> CosmicRay: yeah, http://hackage.haskell.org/cgi-bin/trac/trac.cgi
11:51:39 <SyntaxNinja> CosmicRay: but it should be an easy fix, fwiw, in the newer cabals.
11:53:09 <SyntaxNinja> CosmicRay: btw, grab the darcs version of cabal and try out cabal-install :)
11:54:57 <bojohan> shapr: have you read "The Radioactive Boy Scout"?
11:56:31 <CosmicRay> SyntaxNinja: yup, I really need to do that.
11:58:36 <SyntaxNinja> CosmicRay: have you actually checked to see that building fails on AIX?
11:58:41 <SyntaxNinja> with the new cabal?
11:58:51 <CosmicRay> not with the new cabal, no.
11:59:04 <CosmicRay> however IBM ld doesn't use standard flags so I suspect it will fail
11:59:40 <SyntaxNinja> I still don't know why ghc-pkg was passing --auto-ghc-libs raw to ld
12:00:03 <SyntaxNinja> CosmicRay: could you include an example of how to conditionally compile something based on AIX being the platform?
12:00:48 <CosmicRay> I think you should rather key off GHC configuration.  if GHCI was not built, don't build the libs.
12:00:53 <CosmicRay> this will be a problem on  more than AIX
12:01:07 <CosmicRay> also, for instance, alpha/linux, sparc/linux, etc.
12:01:13 <SyntaxNinja> I have no clue how to tell if a platform has ghci. I guess we could look for it at configure time.
12:01:46 <CosmicRay> let me poke about a bit.
12:01:58 <CosmicRay> well it's obviously in config.mk but I don't know if that gets installed anywhere
12:02:36 <CosmicRay> nope, it doesn't.
12:02:48 <CosmicRay> does your configure deduce the ghc library dir?
12:03:13 <SyntaxNinja> no, I don't think so.
12:03:20 <CosmicRay> I guess you could, for instance, look at /usr/local/lib/ghc-6.4.1, and if it exists, look for ghci-6.4.1 in the same place.
12:03:21 <CosmicRay> hmm.
12:03:27 <SyntaxNinja> we could just look for ghci and key off its existence. that would make lots of sense and that would be pretty simple.
12:03:34 <CosmicRay> yup.
12:03:44 <CosmicRay> that should work 99% of the time.
12:03:45 <SyntaxNinja> yeah, I guess it's not THAT easy. we have to deduce ghci from ghc
12:03:49 <SyntaxNinja> anyway lunch &
12:06:57 <shapr> bojohan: Don't think so
12:08:52 <bojohan> google for it
12:08:59 <ValarQ> shapr: 'lo formarn
12:14:13 <bisby> is there a "map" like function that I can use monads in?
12:14:27 <musasabi> the configure looks for ghc and ghc-pkg, looking for ghci shouldn't be much harder.
12:14:31 <basti_> @type Control.Monad.mapM
12:14:32 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
12:15:23 <bisby> basti_: I'll try that. thx.
12:15:59 <basti_> bisby: i hope thats what you were looking for
12:16:10 <Cale> you're probably either looking for that or liftM
12:16:19 <Cale> @type Control.Monad.liftM
12:16:20 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
12:16:44 <Cale> which is roughly the same as fmap
12:16:47 <Cale> @type fmap
12:16:48 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
12:17:22 <bisby> basti_: I have the contents of a directory. Some of these are directories. Now I want to recursively traverse and print the contents of these directories as well. I'm using functions like getDirectoryContents.
12:17:51 <basti_> hmm
12:17:51 <SamB> hmm
12:18:04 <basti_> hmm²
12:18:13 <basti_> i think i see yes
12:18:47 <basti_> mapM could be your best bet.
12:18:50 <SamB> expandDirectory :: FilePath -> IO [FilePath]
12:19:17 <SamB> expandDirectories :: [FilePath] -> IO [FilePath]
12:19:32 <basti_> SamB: where is that from?
12:19:47 <SamB> basti_: I'm paraphrasing hmp3 from memory
12:19:56 <basti_> ah
12:21:38 <SamB> hmm, apparantly there isn't a plural function anymore
12:22:14 <SamB> @google hmp3 Tree.hs
12:22:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3/
12:22:45 <SamB> anyway, the current hmp3 code is in http://www.cse.unsw.edu.au/~dons/code/hmp3/Tree.hs
12:23:50 <SamB> a little more complicated than it used to be, though
12:23:55 <SamB> and it filters out non-mp3s
12:25:01 <adept> hi all
12:25:03 <adept> SamB: 
12:25:08 <SamB> adept: 
12:25:11 <adept> jlouis: 
12:25:25 * SamB thinks jlouis isn't here right now
12:26:17 <SamB> @seen jlouis 
12:26:17 <lambdabot> jlouis is in #haskell-blah and #haskell. Last spoke 5 hours, 54 minutes
12:26:17 <lambdabot> and 4 seconds ago.
12:26:21 <adept> @seen jloius
12:26:22 <lambdabot> I haven't seen jloius.
12:26:29 <adept> :)
12:39:47 <fworp> @seen lambdabot
12:39:47 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #haskell.es, #haskell.it, #gentoo-
12:39:47 <lambdabot> haskell, #haskell-overflow, #haskell-blah and #haskell
12:40:19 <chucky> why is lambdabot not in #haskell.se?
12:45:19 <ricebowl> is an unboxed array an array of unboxed types, or simply an array which forces strict evaluation on its contents
12:45:20 <ricebowl> ?
12:45:42 <ricebowl> i.e. is there a way to get an array of Int#?
12:46:09 <musasabi> unboxed types essentially.
12:46:23 <gus> dons:  Have you encountered any problems with hs-plugins for a 64 bits processor (AMD64)  ?
12:56:54 <SyntaxNinja> back
13:07:04 <xerox> Goodnight folks-.
13:07:16 <araujo> xerox!!!!
13:08:32 * CosmicRay points out darcs get --partial http://cvs.haskell.org/darcs/libraries
13:12:32 <dcoutts> CosmicRay, so is that the new master repo? or is it a mirror of cvs?
13:12:33 <SyntaxNinja> whoa sweet
13:12:43 <CosmicRay> a mirror of CVS.
13:12:49 <SyntaxNinja> maybe someday I can ditch the separate darcs repo for cabal
13:13:03 <dcoutts> CosmicRay, and it's now synced daily or something?
13:13:06 <CosmicRay> all of Simon's Master Plan for mirroring has so far been implemented, with the exception of the new ghc repo
13:13:17 <dcoutts> cool
13:13:22 <CosmicRay> dcoutts: when the GHC repo comes across in a day or two, it'll probably be hourly or something.
13:13:26 <chucky> nice. :D
13:13:30 <dcoutts> excelent!
13:13:37 <CosmicRay> and of course his plan is eventually to make the darcs repos authoritative.
13:13:43 <dcoutts> right
13:13:43 <SyntaxNinja> yay simon
13:13:56 <dcoutts> @karma+ JaffaCake
13:13:57 <lambdabot> JaffaCake's karma raised to 3.
13:13:58 <SyntaxNinja> that's totally the bomb
13:14:11 <SyntaxNinja> we should write up an article and see if we can get it slashdottted
13:14:18 <dcoutts> heh heh
13:14:28 <CosmicRay> thanks to lelit for helping me with some tailor stuff nobody had tried before ;-)
13:14:41 <SyntaxNinja> CosmicRay: you set it up? sweet. nice work.
13:14:46 <CosmicRay> yup
13:14:52 <CosmicRay> with lelit's help on tailor
13:15:00 <CosmicRay> thanks
13:15:03 <dcoutts> tailor is great. We've been using it for the darcs mirror of Gtk2Hs
13:15:13 <CosmicRay> and jaffacake's help on CVS ;-)
13:15:18 <SyntaxNinja> I'm serious about getting slashdotted
13:15:19 <dcoutts> though currently we're having some problems with character conversions
13:15:38 <CosmicRay> SyntaxNinja: wait a day or two until GHC comes over and there's a mailing list announcement perhaps
13:15:40 * dcoutts curses character encoding problems
13:15:49 * SamB thinks JaffaCake strangely lacking in karma
13:15:53 <SyntaxNinja> we could explain it as part of the haskell community's work to grow more inclusive
13:15:57 * dcoutts agrees with SamB 
13:16:03 <CosmicRay> @karma+ JaffaCake
13:16:03 <SyntaxNinja> @karma SyntaxNinja
13:16:03 <lambdabot> JaffaCake's karma raised to 4.
13:16:04 <lambdabot> You have a karma of 1
13:16:06 <SyntaxNinja> bah
13:16:16 <dcoutts> poor SyntaxNinja 
13:16:20 <chucky> @karma+ SyntaxNinja
13:16:21 <lambdabot> SyntaxNinja's karma raised to 2.
13:16:21 <CosmicRay> @karma+ SyntaxNinja
13:16:22 <lambdabot> SyntaxNinja's karma raised to 3.
13:16:23 * SamB expects this is related to the fact that lambdabot doesn't support mailinglist karma
13:16:25 <chucky> you deserved more. :)
13:16:31 <SyntaxNinja> awwwww
13:16:43 <SyntaxNinja> thanks guys
13:16:52 <SamB> @karma SamB 
13:16:54 <lambdabot> You have a karma of 8
13:17:01 <SamB> what the heck?
13:17:01 <dcoutts> @karma dcoutts 
13:17:02 <lambdabot> You have a karma of 6
13:17:06 <SamB> I have 8?
13:17:20 <chucky> lambdabot obviously likes you. :)
13:17:48 * SamB consults meme
13:17:51 <ricebowl> karma tastes good.
13:17:59 <SyntaxNinja> CosmicRay: you gunna write the article? 
13:18:00 <chucky> damn, using IRC via gaim instead of xchat is going to totally kill my productivity. I'm actually talking now
13:18:29 <chucky> it used to be so far away on desktop 6, now it's right there. :)
13:18:56 <CosmicRay> SyntaxNinja: it'd be fine if you do
13:20:00 <chucky> and then we could have a follow-up article a few months later on how much going to darcs helped, and get slashdotted again?
13:23:03 * SamB suspects jlouis 
13:25:41 <SamB> it seems to have transpired between the 14th and the 22nd that my karma was raised by 4 outside the channel...
13:26:06 <CosmicRay> @karma CosmicRay
13:26:07 <lambdabot> You have a karma of 3
13:26:22 <SamB> from 3 to 7
13:26:24 <dcoutts> SamB, lambdabot used to accept @karma commands in privmsgs, I don't think it does anymore
13:26:45 <SamB> it could have been in another #haskell-* channel
13:26:50 <dcoutts> since it made it no fun
13:26:52 <dcoutts> SamB, true
13:52:12 <CosmicRay> btw nofib and testsuite are also converted already.
13:59:51 <adept> ppl, does anyone use xemacs + haskell-mode 2.1
13:59:57 <adept> ?
14:01:41 <dons> adept, i think a lot of people do, but not me!
14:02:04 <adept> eh
14:02:47 <adept> i got a lot of changes for worse during upgrade 2.0 -> 2.1, just wanted to compare my feelings ...
14:08:28 <gus> dons: I'm having a problem: my HSP installation won't work, and Niklas thinks it might be a bug in hs-plugins, but he's not sure. 
14:09:21 <dons> this is on a 64 bit box?
14:09:30 <gus> yes
14:09:54 <dons> well, hs-plugins does work on 64 bit machines, as far as  I know. I've tested on an ia64.
14:10:04 <SyntaxNinja> adept: what problems?
14:10:06 <dons> I'll need more info in order to debug any problem.
14:10:59 <gus> Ok, the only info I've got is that the server says something like:  "resolveObj failed"
14:11:46 <adept> SyntaxNinja: 1. *haskell* buffer now comes with compilation-minor-mode on, which prevents from using it as "scratch pad"
14:12:17 <adept> SyntaxNinja: 2. if initial load of module fails (due to missing "-package"), it is not indicated in any way
14:13:09 <adept> SyntaxNinja: 3. C-u C-c C-s is gone, to launch ghci with a set of parameters one should C-u M-x inferior-haskell-*-process
14:14:06 <SyntaxNinja> adept: hm. dono.  I'd email the author; he's been good about replying to stuff
14:14:15 <Xianianol> Humm, in an error when it says:
14:14:15 <Xianianol> [([Char],Expr)]
14:14:15 <Xianianol> IO a
14:14:38 <Xianianol> The first line is type and the second is does not match.
14:14:47 <Cale> Xianianol: code?
14:14:58 <Xianianol> Does that means that the result of the term is [([Char],Expr)] and it wants IO a ?
14:15:02 <Xianianol> Or the other way around ?
14:15:07 <Cale> you're using a list where an IO action is wanted, or vice versa
14:15:36 <Cale> probably it wants an IO action
14:15:41 <Cale> can I see the snippet?
14:15:47 * boegel|home leaves for bed
14:15:51 <boegel|home> g'night everyone !
14:15:52 <Xianianol> Humm, weird, it should be receiving a string.
14:15:58 <Cale> night
14:15:59 <Xianianol> snippet ?
14:16:06 <Cale> of code
14:16:10 <Cale> which is failing to compile
14:16:36 <Xianianol> I think I should be using the pastebin when it is more than 2 lines, isn't it ?
14:16:53 <Cale> up to 5 lines is okay, I think
14:17:04 <Cale> pastebins are generally nice though
14:17:05 <adept> SyntaxNinja: i'll email him, thats sure. It's only that I usually have a great deal of doublt about my own configs and such, so I usually double-check first. You've seen no such behavoir?
14:17:09 <Xianianol> "s" -> catch (do script <- readFile arg
14:17:09 <Xianianol> putStrLn script
14:17:09 <Xianianol> reploop env)
14:17:21 <Xianianol> uups, wrong line :P
14:17:27 <Xianianol> I better use pastebin...
14:18:36 <SyntaxNinja> adept: no, I haven't seen that
14:19:04 <lisppaste2> Xianianol pasted "Wrong type" at http://paste.lisp.org/display/14095
14:19:56 <Xianianol> Of course, the "l" part is a part of a larger function, but the problem is in "createEnv script"
14:20:34 <ski> 'createEnv script' should prolly be 'env <- createEnv script'
14:20:43 <ski> hm
14:20:44 <Xianianol> Since putStrLn works with the "script" created by readFile, I don't see why the function createEnv that also receives a string does not work.
14:20:54 <ski> though, there's still a problem, there
14:21:28 <ski> you either want to make createEnv return an IO Env, or use 'let env = createEnv script'
14:21:55 <Cale> yeah
14:22:07 <ski> hm, the latter, methinks
14:22:32 <Cale> (createEnv script) is an Env (a list), while you're using it as an IO action in that do block
14:23:01 <ski> he's also using an (presumably) unbound 'env' in next line
14:23:32 <Cale> env also gets used in the other part of the catch
14:23:42 <Xianianol> Yeah.
14:24:00 <Xianianol> Basically I start with an empty env, an empty list.
14:24:23 <Xianianol> And when I call that function to load a env, it will substitute the empty env with the new one.
14:24:36 <Cale> but it doesn't
14:24:37 <Xianianol> (or that is what I think I am doing)
14:24:41 <Cale> functions only return values
14:24:54 <Cale> they don't have side effects
14:25:11 <Cale> createEnv simply takes a string, and produces a list
14:25:31 <Cale> it doesn't set some global state parameter in any way
14:25:52 <ski> Xianianol : do you already have an 'env' var above the lines you pasted ?
14:25:55 <Cale> If it did, it would have to have type String -> IO Env, or perhaps String -> IO ()
14:26:22 <Xianianol> Humm, but since I am always working inside an env which is basically os values, it sort of stores thing, doesn't it ?
14:26:31 <Xianianol> Since the env does not really end.
14:26:37 <Xianianol> Until I quit my program.
14:26:41 <Cale> hm?
14:26:55 <Cale> an Env is just a list of pairs of strings and expressions
14:27:11 <Cale> according to that type declaration
14:27:24 <Xianianol> Yes, but I reploop env, but I stay in the env.
14:27:29 <Xianianol> *but->so
14:27:34 <Cale> what's reploop?
14:27:45 <Cale> and what do you mean by "stay-in"
14:27:51 <Xianianol> Well, it is just a main looping function.
14:28:23 <Xianianol> It is like those command prompt programs where you run it, it will stay in the "menu loop" so that you can input commands
14:28:51 <Xianianol> Instead of "execute and quit"
14:28:53 <Cale> do you perhaps mean to do something like  let newEnv = env ++ createEnv script; reploop newEnv ?
14:29:58 <Xianianol> Humm, not really.
14:30:15 <Xianianol> Humm, sorry for not being good in explaining.
14:30:32 * Xianianol thinks of a way to explain better
14:33:34 <Cale> perhaps you want an IORef?
14:33:50 <Xianianol> IORef ?
14:34:12 <Cale> IORefs are mutable variables in the IO monad
14:34:55 <Cale> they're useful if you have various pieces of IO code that need to observe and modify a piece of state
14:35:41 <Xianianol> Never really them, let me check my Haskell Book see if it talks about it.
14:35:47 <Xianianol> *never really used
14:38:46 <resiak> dcoutts: plz2install darcs on the ecs machines kthx
14:43:30 <Cale> Xianianol: well, they're fairly simple http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
14:43:38 <Cale> but I'm not even sure they're what you need
14:44:43 <dcoutts> resiak, or you can build it yourself!
14:45:00 <Heffalump> can dcoutts actually install stuff?
14:45:11 <dcoutts> resiak, the support at comlab are the people to ask.
14:45:33 <dcoutts> Heffalump, sadly not. I can merely pester support at comlab
14:45:41 <resiak> dcoutts: It's added to my todo list. I didn't really expect you to do it yourself. :-)
14:45:58 <dcoutts> resiak, I've got it installed in my home dir :-)
14:46:00 <Heffalump> what does ECS run these days?
14:46:06 <dcoutts> Heffalump, Solaris 9
14:46:11 <Heffalump> on Sparc?
14:46:18 <dcoutts> yep
14:46:29 <dcoutts> without any of useful patches Sun have releases since 2003
14:46:37 * Heffalump wonders what resiak wants darcs on those for anyway
14:46:52 <dcoutts> eg RENDER extension, so I couldn't build Gtk2Hs with cairo :-(
14:47:12 <resiak> Heffalump: because I hate juggling which tree contains the most recent version of my practical stuff --- my laptop, my desktop or ecs.
14:47:23 <Heffalump> ah, good point
14:47:43 <Heffalump> when I arrived in Oxford, I remember having to compile ssh for myself on my ECS account :-)
14:47:47 <dcoutts> resiak, which is why the pics we generate FP practical doesn't look as nice as the one in the practical desciption
14:47:54 <dcoutts> Heffalump, ha!
14:48:11 <Heffalump> so give it another 8 years and I'm sure darcs will be standard ;-)
14:48:20 <Heffalump> what is the FP practical these days?
14:48:33 * dcoutts wrote the new FP practical :-)
14:48:36 <resiak> dcoutts: But I wouldn't know what they look like _in_ the practical, since I missed it :(
14:48:51 <dcoutts> resiak, oh yeah :-)
14:49:04 * ski wonders what 'FP practical' si
14:49:08 <Heffalump> people from Worcester, lazy arses the lot of them
14:49:13 <Heffalump> ski: Functional Programming = FP
14:49:18 <ski> yes
14:49:23 <ski> but 'practical' ?
14:49:29 <Heffalump> write a program
14:49:42 <Heffalump> as opposed to prove theorems which the class work/exams is mostly about
14:49:47 <resiak> Heffalump: I'm a year or so too late :)
14:49:53 <ski> ah
14:49:54 <dcoutts> Heffalump, they use formal grammers to generate pretty pictures. It's using L-Systems.
14:50:18 <dcoutts> Heffalump, if you can still get into the .ox.ac.uk domain then I can give you the url
14:50:31 <Heffalump> I've found the URL, just need to fiddle with my web routing :-)
14:50:34 <dcoutts> it's quite a fun practical
14:50:43 <dcoutts> and it uses Gtk2Hs of coruse :-)
14:50:59 <Heffalump> I think you should have made them write an ant metalanguage ;-)
14:51:02 <dcoutts> next year I'm planing to extend it to 3D :-)
14:51:08 <dcoutts> Heffalump, hah ha
14:51:38 <dcoutts> which suprisingly does actually run on the ECS machines. Their 3D graphics are not as rubbish as you might expect.
14:55:50 <ChilliX> Moin
14:56:33 * SamB wonders why his alt key never seems to work anymore
14:58:07 <Cale> SamB: perhaps the WM is catching it
14:59:49 <SamB> Cale: surely not!
15:00:18 <SamB> perhaps Emacs is just being temperamental
15:00:39 <Cale> is this across all apps?
15:01:11 <Cale> you might run xev, and see what keysym it's generating
15:01:17 <SamB> I suppose I really ought to restart X before I can really complain...
15:01:47 <SamB> its been running for quite some time now and I probably run something nasty at some point...
15:02:24 <SamB> well, except for complaining that X makes it too easy to remap things from any old thing...
15:20:05 <bisby> how can I create a temporary variable inside a do-notation?
15:20:44 <basti_> let x=5
15:20:48 <basti_> for example
15:21:09 <bisby> thx. I'll try that.
16:06:43 <araujo> @yaw!
16:06:44 <lambdabot> Are the STEWED PRUNES still in the HAIR DRYER?
16:09:28 <musasabi> A
16:09:33 <musasabi> @arr
16:09:34 <lambdabot> Avast!
16:17:09 <soysauce> @pl \f x y -> f y x
16:17:09 <lambdabot> flip
16:17:40 <soysauce> @pl (>>=) map
16:17:40 <lambdabot> (map >>=)
16:17:44 <soysauce> hmm...
16:18:04 <soysauce> @pl \f -> (>>=) f
16:18:05 <lambdabot> (>>=)
16:19:22 <soysauce> @pl (\(x, y) -> (y, x))
16:19:23 <lambdabot> uncurry (flip (,))
16:19:55 <soysauce> @pl (\(s, (x, y)) -> (s, (y, x)))
16:19:56 <lambdabot> uncurry ((`ap` snd) . (. fst) . (. flip (,)) . (.) . (,))
16:20:04 <soysauce> @type ap
16:20:05 <lambdabot> Not in scope: `ap'
16:20:29 <arjanb> @type Control.Monad.ap
16:20:29 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
16:21:01 <soysauce> thanks -- am showing off lambdabot in class ;)
16:21:10 <soysauce> (perhaps not the best idea but was talking about @pl)
16:27:08 <SyntaxNinja> soysauce: you know you can msg lambdabot so you can keep your private conversations w/ her private :)
17:16:47 <jethr0> bit slow tonight, huh?
17:18:07 <SyntaxNinja> yeah
17:19:09 <jethr0> so, how come there's 162 ppl lurking? everyone sleeping and upping uptime on the channel or what :-)
17:20:08 <jethr0> i didn't know you can have equal-signs in your mail-address *g*
17:20:23 <SyntaxNinja> it goes in phases. we're probably between shifts or something
17:20:35 <liyang> That's not an email address...
17:20:44 <Frederick> hi folks Im hre just to thank you all by the help you provided me in these last 3 weeks
17:21:00 <Frederick> SamB, Cale, astrolabe, ski thx a lot!
17:21:13 <jethr0> oh, sorry, hadn't seen that format before...
17:21:54 <jethr0> @ninja: between time zones more likely
17:21:55 <lambdabot> Unknown command, try @listcommands.
17:22:11 <jethr0> @listcommands
17:22:11 <lambdabot> use listcommands [module|command], please. Modules are:
17:22:11 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
17:22:11 <lambdabot> karma localtime more pl plugs poll quote search seen spell state system
17:22:11 <lambdabot> todo topic type version vixen where
17:22:56 <SyntaxNinja> Frederick: don't forget to thank all the little people.
17:23:00 <SyntaxNinja> and your mother.
17:23:03 <SyntaxNinja> that's very important.
17:23:23 <Frederick> thx mom dad and little people
17:23:29 <SyntaxNinja> jethr0: that's what I meant ,yeah :)
17:23:30 <fworp> dont forget jesus.
17:23:35 <SyntaxNinja> @localtime SyntaxNinja
17:23:37 <Frederick> fworp, Im atheist
17:24:04 <SyntaxNinja> Frederick: even atheists usually admit that jesus existed ;)
17:24:13 <jethr0> well, should be no reason not to thank someone.
17:24:28 <Frederick> SyntaxNinja, yes he was a great seller / marketing expert
17:24:56 * Heffalump thanks the 15th man in Caesar's army to set foot on British soil.
17:25:10 <rt> not really, given that we don't have any record about anything he did until fifty years after he died.
17:25:37 <liyang> (supposedly.)
17:26:06 <rt> guess it was harder to get the message out before text-messaging.
17:26:20 * jethr0 sets channel topic to "roman/nazarean history"
17:26:24 <rt> maybe he should have witheld his coming until after the invention of the RSS feed and the cell phone.
17:26:52 <jethr0> yeah, but the saviour's arrival might have been lost in between the spam.
17:26:57 <fworp> theres always the second comming.
17:27:24 <jethr0> but doesn't that spell "DOOM" supposedly?
17:29:17 <SyntaxNinja> jethr0: see what happens when people actually talk?
17:30:29 <fworp> according to john the baptist
17:31:00 <jethr0> hmm
17:32:19 <Heffalump> anyone know how to fiddle with the margins on a LaTeX letter?
17:32:43 <jethr0> hmm, how about geometry package?
17:37:38 <Heffalump> jethr0: great, thanks
17:38:09 <jethr0> wellcome
17:38:26 <jethr0> s/ll/l/
17:53:52 <SamB> Frederick: why are you an atheist? that seems like such a lot of bother for so little value!
17:54:53 <jethr0> hmm, being atheist isn't that much trouble really, is it!?
17:58:07 <Frederick> no it isnt
17:58:30 <SamB> well, still, it isn't terribly profitable
17:58:37 <SamB> might as well be an apathist!
17:59:00 <jethr0> only the payoff after death is rather slim!
18:01:05 <SamB> in most matrices, it is in fact not slim but negative!
18:01:53 <SamB> except that strange american matrix in which most people are considered "good" and supposedly go to heaven
18:02:10 <jethr0> well, it really depends on what kind of guy "god" is... and whether he/they exist
18:25:12 <CosmicRay> well.  ghc is darcsified up through 1999 now.
18:25:24 <CosmicRay> this cvs repo apparently dates back to ghc 0.29 or some such.
18:27:09 <shapr> wow
19:11:02 <dmg_> Hi there
19:24:34 <dmg_> Well, looks like nobody is on?
19:24:53 <dmg_> Let me introduce myself just in case somebody is.
19:25:18 <dmg_> I am Dimitry Golubovsky, first time in this chat.
19:25:34 <dons> welcome dmg_
19:35:25 <fworp> can you use associated types in relatively recent ghc snapshots?
19:36:51 <dons> they're not in the head branch fworp, so nope.
19:36:59 <fworp> oh, where are they?
19:37:23 <dons> in the associated types branch.
19:37:41 <fworp> that would make sense
19:38:14 <dons> once it's done, it'll be merged into the head, I presume.
19:38:27 <dmg_> I'm just curious: has anybody used Fudgets for their projects?
19:42:14 <shapr> Hiya Dimitry
19:42:21 <shapr> How's HsFFIg?
19:42:49 <shapr> whoops, it's nearly 5am...
19:43:27 <shapr> dmg_: I'm Shae Erisson, about to go to sleep :-)
19:52:18 <dmg_> Hi Shae! HSFFIG is OK. Have you seen the HsffigLinkageOptimization on Hawiki? It looks like ghc --make and split-objects libraries can live together.
19:53:39 <dmg_> And I'm thinking about some Cabal-like tool (perhaps restricted to GHC so far) to create Haskell packages out of C header files and split-object libraries produced with HSFFIG.
20:08:35 <ricebowl> dmg_ - privet :D
20:09:25 <dmg_> Privet - ?>=8<05B5 ?>-@CAA:8? (oops, will this be readable, let's see ;)
20:09:39 <ricebowl> nope, not at all :S
20:09:54 <dmg_> OK ;)
20:09:55 <ricebowl> but don't worry about it--ja ne govarju po-rouskij :p
20:13:18 <ricebowl> dmg_ - I want to learn though... so it is good to meet people with whom I can practice ;)
20:15:52 <dmg_> exit
20:15:58 <ricebowl> /quit :p
20:16:41 <dmg_> Oops, didn't mean that: this was supposed to go to a shell window, but focus was on IRC.
20:16:47 <ricebowl> hehe
20:18:35 <dmg_> Well, but it's indeed time for me to exit the chat: bye everybody!
20:18:46 <ricebowl> do svidanja
20:59:23 <Roboguy> Hmm, isn't there a proposal for adding template metaprogramming to Haskell?
21:03:29 <skew> well there was, and now there is an implementation
21:03:41 <Roboguy> There is?
21:03:42 <skew> GHC does it
21:03:46 <Roboguy> Hmm
21:04:04 <Roboguy> Is there information on the GHC site?
21:04:18 <skew> probably
21:04:40 <skew> in the User's guide, section 7.6
21:05:07 <Roboguy> Thanks
21:17:24 <Cale> a little more than template metaprogramming
21:17:38 <Roboguy> Hmm?
21:18:01 <Cale> Your code can build syntax trees directly.
21:19:22 <Cale> There's some neat examples of using compile-time IO to write quick compilers for simple programming languages in a TMR article. :)
21:19:48 <Roboguy> Hmm
21:19:51 <Cale> (you parse the language and generate Haskell code at compile time :)
21:20:22 <Roboguy> Metalinguistic programming, hmm
21:25:41 <skew> Is there documentation on Data.Graph.Inductive? I'm trying to figure out why the "level aggregation" function takes a Maybe d instead of just being d -> c -> c
21:30:51 <skew> Nothing seems to come up when loops are involved
21:54:05 <SyntaxNinja> any debian, darcs-using, non i386-users around?
21:54:22 <Roboguy> I'm on a PPC
21:54:26 <Roboguy> Why?
21:54:59 <SyntaxNinja> Roboguy: with the new version of darcs, I get this error, can't reproduce on my i386 box: http://buildd.debian.org/fetch.php?&pkg=darcs&ver=1.0.4-1&arch=powerpc&stamp=1133046690&file=log&as=raw
21:55:16 <SyntaxNinja> Roboguy: of you have darcs installed, can you "nm /usr/lib/libcurl.a|grep global_init" and let me know if that symbol is defined
21:57:31 <Roboguy> Don't think I have darcs
21:58:24 <SyntaxNinja> hm. perhaps you don't qualify as darcs-using then ;)
21:58:34 <Roboguy> Probably not =)
21:58:47 <SyntaxNinja> are you on debian?
21:58:55 <Roboguy> No
21:58:57 <Roboguy> OS X
21:58:59 <SyntaxNinja> hehe
21:59:12 <Roboguy> Heh
21:59:23 <SyntaxNinja> Roboguy: I built all my dreams upon you, and now they have collapsed.
21:59:29 <Roboguy> Heh heh
22:22:11 <skew> Data.Graph.Inductive needs to provide more induction principles
22:23:45 <Roboguy> What does O'Haskell add?
22:23:49 <skew> I'm writing grammar manipulation algorithms as graph algorithms, which makes for elegant code, but a lot of reading the Docs, and building up my own folds
23:11:04 <palomer> and then I got high
23:40:03 <Lokadin> say how is haskell in terms of ajax support?
23:40:30 <Lokadin> palomer: you seem to get high a lot
