00:02:50 <glasser> hmm. how do I do a "transitive closure"?
00:02:59 <glasser> ie, i have a bunch of things, each of which has a list of parents
00:03:03 <Itkovian> good question
00:03:06 <glasser> I want to get a list of ancestors
00:17:25 <ski> @eval let parents 'a' = ['c','d']; parents 'b' = ['d','e']; parents 'c' = ['f']; parents _ = []; in concat . takeWhile (not . null) $ iterate (\xs -> concatMap parents xs) ['a','b']
00:17:26 <lambdabot> "abcddef"
00:20:44 <ski> @eval let parents 'a' = ['c','d']; parents 'b' = ['d','e']; parents 'c' = ['f']; parents _ = []; in concat . takeWhile (not . null) . map snd $ iterate (\(old,new) -> (new++old,concatMap parents new List.\\ old)) ([],['a','b'])
00:20:45 <lambdabot> "abcddef"
00:21:06 <ski> @eval let parents 'a' = ['c','d']; parents 'b' = ['d','e']; parents 'c' = ['f']; parents _ = []; in concat . takeWhile (not . null) . map snd $ iterate (\(old,new) -> (new++old,nub (concatMap parents new) List.\\ old)) ([],['a','b'])
00:21:07 <lambdabot> "abcdef"
00:21:11 <boegel> :)
00:21:12 <ski> ah
00:21:23 <boegel> @type nub
00:21:24 <lambdabot> Not in scope: `nub'
00:21:30 <ski> @type List.nub
00:21:31 <lambdabot> forall a. (Eq a) => [a] -> [a]
00:21:45 <boegel> what does nub do ?
00:21:51 <ski> remove duplicates
00:22:07 <ski> @eval nub [0,1,0,2,0,1,0,3]
00:22:08 <lambdabot> [0,1,2,3]
00:24:00 <ski> that above is the standard differential / semi-naive fixedpoint iteration for transitive closure
00:38:49 <joelr> good morning
00:40:53 <joelr> anybody home?
00:42:42 <boegel> joelr: yeah sure
00:43:02 <boegel> @index unique
00:43:03 <lambdabot> bzzt
00:43:13 <boegel> ski: why not call it 'unique' ?
00:43:17 <joelr> boegel: can you give me a hand?
00:43:19 <joelr> fixlist :: PU a -> Int -> PU [a]
00:43:20 <joelr> list :: PU a -> PU b -> PU [b]
00:43:20 <joelr> list = sequ length num . fixlist
00:43:33 <ski> boegel : no idea :)
00:43:35 <boegel> @eval let unique = nub in unique [0,1,0,2,0,3,1,2]
00:43:36 <lambdabot> [0,1,2,3]
00:43:44 <joelr> how do i translate list into the ... what's that called the non "." way
00:43:57 <boegel> @type (.)
00:43:58 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
00:44:05 <joelr> sequ :: (b -> a) -> PU a -> (a -> PU b) -> PU b
00:44:10 <joelr> this is the missing piece
00:44:30 <boegel> @type num
00:44:31 <lambdabot> Not in scope: `num'
00:44:32 <ski> list foo = sequ length num (fixList foo)
00:44:35 <boegel> @index num
00:44:36 <lambdabot> bzzt
00:44:41 <ski> list foo bar = sequ length num (fixList foo) bar
00:44:42 <boegel> joelr: what's num ? :)
00:44:43 <joelr> boegel: num is a function
00:44:56 <joelr> ski: let me try that
00:45:33 <boegel> ski: or list = \x -> sequ length num (fixList x)
00:45:36 <ski> joelr : 'non "." way' = pointful, i think
00:46:06 <boegel> ski: not necessarely
00:46:12 <boegel> mine is pointless :)
00:46:23 <ski> it's not
00:46:31 <boegel> @pl list foo  =sequ length num (fixList foo)
00:46:32 <lambdabot> list = sequ length num . fixList
00:46:32 <ski> x is a point
00:46:40 <Itkovian> pointless - isn't that where one leaves out the args
00:46:46 <ski> right
00:46:47 <Itkovian> erm, the explcicit args?
00:46:48 <boegel> yeah but lambda notation makes it pointless
00:46:52 <ski> no
00:46:54 <boegel> isn't it ? ::)
00:46:55 <Itkovian> no
00:47:06 <boegel> oh, well, sorry then :) my mistake
00:47:22 <Itkovian> joelr: that code looks pretty pointless to me.
00:47:27 <boegel> @pl list = (\x -> sequ length num (fixList x) )
00:47:28 <lambdabot> list = sequ length num . fixList
00:47:33 <boegel> hmm, I see :)
00:47:50 <joelr> Itkovian: it's wayy not
00:47:55 <ski> @pl \x -> sequ length num (fixList x)
00:47:56 <lambdabot> sequ length num . fixList
00:47:58 <Itkovian> what are the advantages of writing pointless code
00:48:20 <joelr> it did not write that, but it's neat. and hard to translate for me.
00:48:21 <ski> sometimes more easier to read and understand, sometimes not
00:48:25 <Itkovian> (u have to love that ... 'pointless code')
00:48:51 <ski> Itkovian : also, equational reasoning is often simpler with pointless
00:49:05 <ski> map (f . g) = map f . map g
00:49:06 <ski> etc
00:49:11 <Itkovian> ski: maybe
00:50:27 <joelr> Itkovian: here
00:50:33 <joelr> let x :: [Int] = [5, 5, 5]
00:50:38 <joelr>  pickle (list num) x
00:50:45 <joelr> [0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,3]
00:51:00 <joelr> except it stores the size of the list at the end which is not how it's supposed to be
00:51:46 <Itkovian> @type pickle
00:51:47 <lambdabot> Not in scope: `pickle'
00:51:49 <joelr> so there's a bug in that code, becase
00:51:57 <joelr> unpickle (list num) [0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,3] :: [Int]
00:52:03 <joelr> [5,5,3,0,0]
00:52:11 <joelr> Itkovian: google for pickler combinators
00:52:21 <Itkovian> @google pickle combinators
00:52:22 <lambdabot> http://www.itu.dk/research/plt/lbs_phd_course/slides/pu.pdf
00:52:33 <joelr> Itkovian: pickler, important!
00:52:39 <joelr> @google pickler combinators
00:52:41 <lambdabot> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
00:52:47 <Itkovian> hmm :-)
00:53:10 <joelr> i want to modify list to take the pickler for the size and store it _before_ the list itself, not after
00:53:30 <Itkovian> ok, I recall pickling now :-)
00:55:40 <Itkovian> joelr: uhu
00:55:53 <joelr> list :: PU a -> PU b -> PU [b]
00:55:54 <joelr> list pa pb = sequ length pa (\a -> fixlist pb (fromIntegral a))
00:56:02 <joelr> this is unsightly and does not compile
00:58:02 <joelr> this works
00:58:03 <joelr> list :: (Integral a, Bits a) => PU a -> PU b -> PU [b]
00:58:03 <joelr> list pa pb = sequ (fromIntegral . length) pa (\a -> fixlist pb (fromIntegral a))
00:58:07 <joelr> but it's still unsightly
00:58:13 <Itkovian> it is indeed
00:58:17 <joelr> pickle (list byte endian) x
00:58:17 <joelr> [5,0,0,0,5,0,0,0,5,0,0,0,3]
00:58:32 <joelr> notice how the bytes are reversed by endian and the size is 1-byte
00:58:45 <Itkovian> yeah
00:58:52 <joelr> now i need to move size to the front and clean up that one-liner of a function
00:58:56 <joelr> then i'll be in heaven
00:59:04 <Itkovian> so you want [3,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0]?
00:59:12 <joelr> Itkovian: of course
01:00:51 <Itkovian> the size movement means changing pickle, right
01:01:14 <joelr> Itkovian: it's changing the order of arguments to sequ or something
01:01:48 <joelr> Itkovian: it does not require modifying the internals of pickle if that's what you mean
01:02:42 <joelr> fixlist by itself is fine
01:02:43 <joelr> pickle (fixlist endian 2) x
01:02:43 <joelr> [5,0,0,0,5,0,0,0]
01:05:35 <joelr> @paste
01:05:35 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:08:08 <lisppaste2> haskell  pasted "pickler combinators" at http://paste.lisp.org/display/13327
01:08:20 <joelr> sequ is wrong in that it stores the arguments in the wrong order
01:08:23 <joelr> to wit
01:08:34 <joelr> pickle (pair byte byte) (1,0)
01:08:34 <joelr> [0,1]
01:08:39 <joelr> not what you would expect
01:10:24 <joelr> it's unpickling right but pickling wrong
01:10:40 <joelr> unpickle (pair byte byte) [0,1]
01:10:41 <joelr> (0,1)
01:12:43 <Itkovian> hmm, that seems to be quite weird, considering that the code should have been tested :-)
01:13:04 <joelr> pickle (pair byte byte) (1,0)
01:13:04 <joelr> [1,0]
01:13:14 <joelr>                              in appP pb (b, appP pa (a, s)))
01:13:24 <joelr> it needs to be this way in the first lambda of sequ, then it works
01:13:51 <joelr> pickle (list byte endian) x
01:13:51 <joelr> [3,5,0,0,0,5,0,0,0,5,0,0,0]
01:13:54 <joelr> problem solved!
01:14:15 <Itkovian> erm, but the size is still a single byte, eh
01:14:22 <joelr> yes, notice the spec ;)
01:14:25 <joelr> pickle (list byte endian) x
01:14:25 <joelr> [3,5,0,0,0,5,0,0,0,5,0,0,0]
01:14:34 <Itkovian> ah yes
01:14:50 <joelr> no, i wonder why i can't edit the hawiki?
01:14:54 <joelr> i registered and everything
01:15:22 <shapr> When logged in, you can edit.
01:15:32 <joelr> i can't, the controls do not show up
01:15:34 * shapr is HaWiki maintainer.
01:15:40 * shapr looks
01:15:54 <joelr> @paste
01:15:55 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:16:01 <shapr> Works for me.
01:16:07 <boegel> joelr: add '?action=edit' to the url
01:16:15 <shapr> Do you see JoelR? in the top right corner of the page?
01:16:22 <shapr> If you see UserPreferences, then you're not logged in.
01:16:27 <joelr> shapr: yep, i surely do. but the controls disappeared
01:16:38 <joelr> and adding ?action=edit is a drag
01:16:45 <boegel> shapr: same with me, but I solve it by adding ?action=edit myself :)
01:16:50 <joelr> this paste thing is supposed to be simple, right?
01:16:51 <shapr> You don't see EditText at the bottom of the screen?
01:17:01 <shapr> boegel: You too?
01:17:02 <shapr> wtf?
01:17:05 <joelr> shapr: i see the word test
01:17:10 <shapr> huh?
01:17:11 <joelr> at the bottom of the screen :D
01:17:19 <joelr> right above RefreshCache
01:17:33 <shapr> Do you see EditTex after RefreshCache ?
01:17:38 <shapr> er, EditText ?
01:17:45 <joelr> it would also be helpful to have the edit controls at the top, i think that's where everyone pastes, right?
01:18:00 <joelr> oh, yes, i do see edit test
01:18:01 <joelr> err
01:18:05 <joelr> EditText
01:18:08 <shapr> There's a little thought bubble that means "edit"
01:18:30 <joelr> shapr: but what about those controls at the top, i do not no thought bubble and that block of controls. that's what i'm complaining about
01:18:56 <shapr> You don't see something like this? http://www.haskell.org/moinwiki/classic/img/moin-edit.png ?
01:19:13 <shapr> Ok, take a screenshot and send it to me, I'll see if I can figure it out.
01:20:02 <boegel> shapr: nope, that's gone
01:20:05 <joelr> shapr: just imagine empty space where all that stuff is supposed to be. with my name in the corner of course
01:20:09 <shapr> These days I think the best solution is to upgrade to the latest version of Flippi and make the darcs repo available too.
01:20:18 <shapr> That's screwy, send me a screenshot.
01:20:22 <joelr> hehe :) and you thought why the usage of the wiki for paste has gone down :)
01:20:34 <shapr> I had wondered.
01:21:01 <boegel> shapr: http://www.elis.ugent.be/~kehoste/Screenshot.png
01:21:02 <joelr> question
01:21:12 <joelr> conceptual
01:21:31 <joelr> i'm trying to describe record layout in a flexible fashion
01:21:35 <shapr> boegel: mmm, antialiased fonts :-)
01:21:36 <joelr> dynamically
01:21:43 <boegel> hehe
01:21:56 <Itkovian> joelr: u should mail Andrew Kennedy because it's clearly wrong in the paper as well
01:22:27 <joelr> Itkovian: i emailed him about how to monadify sequ (i could not manage). i'll tell him about the error if he replies
01:22:46 <shapr> boegel: Something's clearly wrong there.
01:22:54 <joelr> so i'm trying to describe record dynamically, i just took care of field types with pickler combinators (i was doing it differently before)
01:23:07 <boegel> shapr: yeah, I'd say so :)
01:23:14 <joelr> i take care of assignments using the attribute scheme from wxHaskell, i.e. attr := val
01:24:19 <joelr> i used to keep the values around as property lists, i.e [ a := b, c := d ] but modifying this is bitching and overall my program spends 50% of its time collecting garbage and moves around a few gygabytes in a few minutes while doing it
01:24:38 <boegel> Itkovian: any idea on the Haskell project you'll assign to students too next semester?
01:24:39 <joelr> so what's a good way of doing this/
01:24:43 <boegel> or projects :)
01:25:00 * joelr wonders if ltkovian is the nhc98 blog guy
01:25:11 <Itkovian> joelr: no.
01:25:19 <joelr> ok
01:25:25 <boegel> there's another Itkovian out there ? scary
01:25:31 <shapr> Malcolm is the nhc98 blog guy.
01:26:22 <joelr> so the best scheme i could come up with now is to store in the record a list of names in a list (so that i know the field order) and store the values in a map, indexed by name
01:26:28 <joelr> how can i do better?
01:27:54 <joelr> store the values in a tuple (seqnum, value) and sort the list by seqnum before pickling it?
01:28:32 <shapr> joelr: Theoretically, kosmikus' extensible types would help you out, but they're not available.
01:28:54 <shapr> I don't know if some rough approximation is available, that might be worth investigating.
01:28:57 <joelr> i have no idea what that is, extensible types. i just need a simple scheme
01:29:28 <shapr> Extensible types mean that a type like data Seasons = Winter | Summer can be extended to have Fall | Spring in some other file.
01:29:38 <joelr> i wonder how much garbage does sorting a list generate
01:29:43 <joelr> shapr: no,  i'm doing something different
01:29:48 <shapr> oh, ok
01:29:51 * shapr rereads
01:30:02 <joelr> shapr: i'm treating records as a "list" of properties
01:30:13 <shapr> ok
01:30:22 <joelr> where there's an order to those properties that is used for pickling and unpickling
01:30:33 <joelr> another twist is that records can be nested
01:31:12 <joelr> so i have a choice between keeping field names in a list, separately from the map or storing the field order together with the values
01:31:32 <joelr> each value in a property of, basically field name, type and value
01:31:49 <joelr> so if i keep field names in a separate list then i duplicate all the field names
01:32:32 <joelr> if i keep the field# in a tuple with the values then i have to convert the map to a list and sort that list by the first element of the tuple before pickling
01:32:36 <joelr> shapr: which way is better?
01:32:46 <shapr> Are maps not ordered?
01:32:47 <joelr> or is there a third way?
01:33:04 <joelr> shapr: i have no idea but if they are they are probably ordered by key which is not what i need
01:33:15 <joelr> shapr: i mean if my key was the field# then it would be fine
01:33:28 <shapr> How about, see if they're an instance of Ord, and if not, define your own instance that orders them how you want?
01:33:31 <joelr> hmm... maybe keep two maps? name -> field# and field# to value?
01:34:04 <joelr> shapr: i don't think i can define an instance of ord that refers to a separate structure that keeps field order, can i ?
01:34:13 <shapr> huh?
01:34:23 <shapr> I think I'm still brainslow from this cold.
01:34:28 <joelr> shapr: assume i have fielda "a", "b", and "c"
01:34:29 <Itkovian> joelr: I would store as much information as possible
01:34:31 <dons> joelr, so you've solved or somehow fixed this windows space leak issue?
01:34:57 <joelr> dons: i'm trying. for starters i switched pickling schemes. now i'm trying to find a better way to store records
01:35:05 <dons> and it's not in the packed string code?
01:35:07 <joelr> dons: my records are basically property lists
01:35:14 <shapr> g'day dons
01:35:19 <shapr> @timein dons
01:35:20 <lambdabot> Unknown command, try @listcommands.
01:35:27 <dons> @localtime dons
01:35:27 <shapr> @localtime dons
01:35:29 <lambdabot> Local time for dons is Tue Nov  8 20:29:35 2005
01:35:29 <lambdabot> Local time for dons is Tue Nov  8 20:29:35 2005
01:35:37 <joelr> dons: beats me. i'm generating a lot of garbage as it is but as udo said fps is no advantage for small strings
01:35:37 <dons> dinner time!
01:35:40 <shapr> Ah, good evening dons :-)
01:35:52 <joelr> yeah, hi dons
01:36:01 <joelr> dons: i think it's not fps
01:36:04 <boegel> shapr: I'll be throwing my 'take 10 [1..]' idea on the Haskell mailing list this afternoon, unless someone here has more idea's on it (http://haskell.org/tmrwiki/TopTenHaskell)
01:36:15 <dons> jooelr, ok good.
01:36:23 <shapr> Ok, so you're storing a Map of names to values. The Map needs to be stored in order, right?
01:36:56 <shapr> boegel: I like the graphics suggestion. Eye candy gets viewers :-)
01:36:57 <joelr> more likely than not when i run and generate all that garbage and then try to allocate memory to initialize another ssl conection i don't get the memory and write to a random location
01:37:21 <dons> hmm. in the non-haskell code?
01:37:35 <joelr> dons: yes, there's _very_ little of it
01:37:40 <dons> ok.
01:38:08 <joelr> basically, the ... folks that wrote the c++ server piggyback on the ssl handshake to initialize the connection
01:38:20 <joelr> and then use it for 2 or 3 packets
01:39:07 <joelr> they plug in memory BIOs into ssl so that it writes to memory when something is encrypted. this is so that they can take the chunk of encrypted data and package it within their own packet
01:39:43 <joelr> i carefully explained to them that this can be done much simpler, using the same openssl library and manually encrypting things after doing the public/private key exchange
01:40:38 <joelr> but for now i have to do the stupid ssl piggibacking from haskell, at the beginning of each connection and i'm launching hundreds or thousands of these. somewhere along the way i run out of memory due to all the garbage that the rest of my code is generating
01:40:47 <shapr> bizarre.
01:41:06 <shapr> I'd never be a good C++ programmer.
01:42:24 <joelr> yeah, talk about a successful project :) the thing runs fine on my mac and crashes all over the place on windows
01:42:24 <joelr> latest issue? it gets stuck between two function calls for 2 minutes
01:42:24 <joelr> it prints "packet received" and right away it's supposed to send a response packet but it does it 2 minutes later
01:42:24 <joelr> my take on it? garbage collection
01:42:44 <Itkovian> shapr: why would the map need to be sotred in order? It could be easier when unpickling, but it need not be stored like that imo.
01:42:57 <shapr> I dunno, I was hoping joelr would tell me that.
01:43:01 <Itkovian> the unpickler might simply recreate the Map by inserting the records
01:43:01 <joelr> Itkovian: that's a question to me
01:43:21 <joelr> Itkovian: the answer is that i'm dealing with records sent from c++, they have a fixed structure
01:43:26 <Itkovian> joelr: ow, sorry ...
01:43:34 <dons> have you tuned the GC?
01:44:16 <autrijus> dons: I don't have complete itinerary with me
01:44:18 <joelr> Itkovian: so if i have a map of fields they need to be ordered somehow. i think i can make properties just type := value and leave the name out of it. then i can have a map of field name -> order and another one of order -> property
01:44:28 <joelr> dons: i have not tried. should i?
01:44:33 <shapr> Oh, so your Haskell datastructures must retain binary compatibilty with the C++ in-memory formats?
01:44:36 <dons> just need to know what time you arrive and when you leaavce, so I can pick a good time for the talk
01:44:39 <autrijus> dons: I believe I arrive at 11 and leave at 13, but I'm not sure
01:44:53 <joelr> shapr: only when pickled
01:44:55 <joelr> 1,818,930,352 bytes allocated in the heap
01:44:55 <joelr> 2,310,538,288 bytes copied during GC
01:44:55 <joelr>  46,566,768 bytes maximum residency (230 sample(s))
01:44:56 <dons> autrijus, unless you have some preference? also what were the dates again?
01:45:01 <autrijus> it might not be 11 but 10, or 14 but 13
01:45:11 <autrijus> I'm going to catch plane back to .tw
01:45:20 <autrijus> after I arrive to .tw I'll actually have access to the ticket they sent me
01:45:27 <autrijus> then I can give you the details in full confidence :)
01:45:30 <joelr>   %GC time      49.7%  (38.8% elapsed)
01:45:30 <joelr>   Alloc rate    74,822,309 bytes per MUT second
01:45:30 <joelr>   Productivity  18.8% of total user, 9.2% of total elapsed
01:45:53 <joelr>   Total time  129.23s  (264.96s elapsed)
01:45:57 <dons> ah, so you think Dec 11 -> 14, or else Dec 10 -> 13?
01:46:21 <dons> then I can either way book a seminra room for Monday 12th
01:46:23 <autrijus> yes, so 12 for the talk is safest
01:46:25 <autrijus> aye aye
01:46:35 <dons> ok. cool. will do.
01:46:53 <autrijus> cool. I gotta run. take care!
01:46:56 <dons> maybe in a a couple or 3 weeks you can send me a little abstract for the talk to advertise :)0
01:47:21 <autrijus> I'm sure the talk will be "Introduction to Pugs" :)
01:47:28 <autrijus> and not, say, "Learning Haskell"
01:47:30 <autrijus> ;)
01:47:33 <joelr> anyway, i think i figured it out with two maps and removing field names form attributes. in fact properties should be in the form of field name := value
01:47:39 <joelr> "field name" := value
01:48:08 <autrijus> dons: how's that for an abstract? http://conferences.oreillynet.com/cs/eurooscon/view/e_sess/7925
01:48:10 <joelr> many fine people on #haskell :-)
01:48:19 <dons> autrijus, the more perl the better.
01:48:24 <autrijus> dons: oops, I mean this. http://conferences.oreillynet.com/cs/eurooscon/view/e_sess/7279
01:48:28 <dons> lots of perl people in how school.
01:48:37 <autrijus> the #7925 is damian, not me.
01:48:56 <dons> yes, that looks great!
01:49:47 <shapr> joelr: Yes, I think this channel's newbie encouraging attitude and mean people removal stance has been effective.
01:50:02 <joelr> :-)
01:50:03 <shapr> The mean people removal part is often unpopular though.
01:50:15 <Itkovian> I am still around, am I not?
01:50:17 <joelr> i have not seen any mean people
01:50:25 <shapr> joelr: Yes, I know :-)
01:50:30 <shapr> But they have been here and I have removed them.
01:50:53 * shapr hugs Itkovian 
01:50:55 <shapr> You're not mean.
01:51:00 <Itkovian> eek!
01:51:10 <Itkovian> try that again and you'll soon change yr mind :-)
01:51:24 <shapr> C'mon, hugging is an American cultural thing :-)
01:51:35 <Itkovian> I'm a European.
01:51:41 <Itkovian> lol
01:51:48 <joelr> hehe
01:52:09 <Itkovian> I do not recall mean people being here ..
01:52:13 <Itkovian> anyway.
01:52:41 <ski> what do you mean ?
01:52:53 * ski couldn't resist
01:53:26 <shapr> I mean mean people.
01:54:03 <shapr> I really do wish the iRiver firmware were open. I could suggest so many improvements.
01:58:03 <Itkovian> shapr: Post them somewhere, maybe people will take notice.
02:15:45 <shapr> dons: Hey, wouldn't matching type keys between static and dynamic code require hashing or some other way to uniquely identify types?
02:16:08 <shapr> dons: If so, wouldn't that also give a useful way to migrate types across the wire to another hs-plugins instance on another rts?
02:16:48 * shapr envisions migrating bytecode that includes type keys.
02:26:10 <Itkovian> I am wondering if pretty print thingies lie around for printing lists ...
02:26:29 <shapr> Tried the standard pretty printers?
02:28:32 <Itkovian> looking atm.
02:30:09 <Itkovian> ah well, I'll make do with tr and sed
02:34:34 <araujo> Good morning.
02:34:39 <shapr> shazam!
02:34:56 <araujo> :-)
02:35:29 <araujo> shapr, quick question, a good doc/paper for category theory?
02:35:45 <araujo> Something that a normal human being can understand
02:36:13 <shapr> http://www.xp123.com/wwake/dissertation/model.shtml
02:36:21 <araujo> Thanks!
02:36:46 <musasabi> shapr: moving code would involve moving hashes of the type implementations with the types (which can be done with TH)
02:36:58 <musasabi> shapr: the real problem is things like existentials.
02:38:45 <shapr> musasabi: Any ideas how to handle existentials?
02:41:47 <ski> possibly an existential could include some info identifying the type ..
02:43:12 <musasabi> If existentials had e.g. a Typeable constraint things would be easy.
02:44:14 <musasabi> In practise people tend to just use "data Obj = Obj (forall x. x) SomethingRepresentingTheType" and they need hand-attention
02:45:20 <ski> hm, iirc, existentials (e.g. univ) in Mercury, and the Dynamic type in Clean, automatically include type info in the object, so one can later try matching the contents out to a specific type
02:46:06 <ski> dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
02:46:09 <musasabi> that is how Dynamic works in Haskell.
02:46:20 <musasabi> but the raw existentials pose a problem.
02:46:28 <ski> dynApply (f :: a -> b) (x :: a) = dynamic f x
02:46:36 <musasabi> Even serializing a Dynamic requires evil hacks with GHC-6.4
02:46:45 <ski> no, Dynamic in haskell is not automatic
02:46:57 <ski> bah
02:47:00 <musasabi> (one needs to subvert the module system, but that is just one dirty trick(
02:47:04 <ski> dynApply (f :: a -> b) (x :: a) = Just (dynamic f x)
02:47:09 <ski> dynApply _ _ = Nothing
02:47:11 <ski> of course
02:47:29 <ski> (that was Clean)
02:48:21 <ski> i suspect it would be easier if Dynamic etc had more language support
02:49:13 <musasabi> Personally I consider being able to much inside opaque datatypes a bug in TH
02:49:19 <musasabi> *muck
02:49:31 <ski> hm, surely
02:50:30 <musasabi> Then again it is quite neat to have for dirty code.
02:50:40 <juhp> dons: hmm, updating to current cabal didn't help
02:57:52 <ski> hm .. on look in docs, i see Clean has a type class TC, probably somewhat similar to Typeable (but more built-in support)
02:58:58 <juhp> dcoutts: do you have any idea about:
02:59:10 <juhp> Reading package info from "/usr/lib64/fps-0.1/fps.pkg" ... done.
02:59:10 <juhp> ghc-pkg: cbits doesn't exist or isn't a directory (use --force to override)
02:59:11 <ski> (http://www.cs.ru.nl/~clean/CleanExtra/report20/chapter8/index.html)
02:59:11 <juhp> ?
03:08:11 <JohnMeacham> musasabi: I added serialization for Dynamic in jhc, see Info.Binary. pretty hacky, but it really simplifies the code a ton. compare ghcs IdInfo.lhs. (though, it is not really a fair comparasion, jhc has most of that code, just distributed to the various modules)
03:11:19 <dcoutts> juhp, presumably the package file mentions cbits
03:11:27 <musasabi> JohnMeacham: btw the SerTH jhc thing hit some troubles with Info.Info (have to look how the Binary instances are done)
03:11:32 <dcoutts> juhp, you probably meant to ask dons
03:11:41 <juhp> dcoutts: yes it does
03:11:44 <musasabi> SerTH supports Dynamics so that should not be the problem.
03:11:46 <juhp> dcoutts: I did :)
03:12:03 <juhp> dcoutts: you have fps installed?
03:12:17 <dcoutts> juhp, an old version, yes
03:12:33 <JohnMeacham> musasabi: ah. yeah, it is pretty hacky. I was just curious if SerTH would be any savings over my current Binary. it is not terribly critical for programs bigger than HelloWorld.hs though :) (but might become more important once larger libraries are created)
03:12:37 <juhp> dcoutts: but no cbits dir :)
03:12:39 <juhp> ?
03:12:50 <JohnMeacham> musasabi: I will have to look at how you solved it.
03:13:31 <dcoutts> juhp, include-dirs: cbits, yeah that's odd
03:13:58 <musasabi> JohnMeacham: my problem was (with Info) that you have binTable with only a few types and even the SelfTest inserts other types into the Info.
03:14:18 <juhp> dcoutts: should I try 0.1?
03:14:32 <JohnMeacham> musasabi: that is because I don't want everything to be dumped in the ho files. it is how I control which things will be.
03:14:44 <dcoutts> juhp, I've no idea why it worked for me. I don't think it should have worked :-)
03:14:46 <juhp> dcoutts: well dons thought it is just for building?
03:14:51 <juhp> heh
03:15:10 <dcoutts> juhp, if it's just for building then it should not be mentioned in the package file
03:15:16 <juhp> dcoutts: can that line just go from the package file??
03:15:30 <juhp> that was what I thought originally
03:15:46 <dcoutts> juhp, however with optimisations and inlining it might need the headers when compiling client modules
03:15:54 <musasabi> JohnMeacham: oh, that makes things simple - I thought that I was just missing something and tried to add support for all things you stuff into Infos and there were quite many of them...
03:15:59 <juhp> dcoutts: right
03:16:23 <dcoutts> juhp, so it doesn't have any includes, which is suspious
03:16:57 <juhp> yeah
03:17:23 <dcoutts> juhp, oh actually ,grepping the source it looks ok...
03:17:24 <juhp> dcoutts: I'm actually trying again to build hide ;)
03:17:43 <JohnMeacham> gosh jhci is slow... I mean, jhc is pretty slow.. but this is horrible.
03:17:43 <juhp> dcoutts: to remove it?
03:17:53 <dcoutts> juhp, all the foreign imports are of the form: foreign import ccall unsafe "static fpstring.h utf8_to_ints" utf8_to_ints
03:18:01 <dcoutts> mentioning an explicit header file
03:18:13 <dcoutts> that inhibits cross-module inlining of the foreign call itself
03:18:21 <dcoutts> so no headers are needed in client modules
03:18:29 <juhp> I see, thanks
03:18:36 <dcoutts> however this is an undocumented ghc quirk :-)
03:18:42 <juhp> ah
03:18:46 <dcoutts> or semi-documented
03:18:57 <dcoutts> it's not guaranteed to stay that way
03:19:13 <juhp> dcoutts: so better to install the header file?
03:19:18 <dcoutts> it was done that way because it was the easiest thing to do in ghc at the time
03:19:46 <dcoutts> juhp, yes the cbits/fpstring.h file
03:20:00 <dcoutts> all the other headers it uses are system ones
03:20:51 <juhp> dcoutts: would it search under import-dirs for that?
03:21:08 <dcoutts> juhp, include-dirs
03:21:18 <dcoutts> import-dirs is for .hi files
03:21:33 <juhp> hmm, so I need to modify the pkg file? :-/
03:21:47 <juhp> only /usr/include??
03:23:31 <juhp> dcoutts: btw I noticed that gtk2hs-0.9.10 now has a include/gtk2hs-config.h
03:24:02 <juhp> and I needed to include that in ghc-ghc641-gconf for it to ghc-pkg install
03:24:23 <juhp> seems naively slightly similar
03:26:38 <dcoutts> juhp, I don't see why the gconf package needs gtk2hs-config.h to install
03:26:54 <dcoutts> juhp, the include/gtk2hs-config.h should be installed along with the glib package
03:27:01 <juhp> dcoutts: looking now I don't either ;)
03:27:17 <juhp> dcoutts: ah I meant glib sorry :)
03:27:21 <dcoutts> then all other gtk2hs packages can have it available
03:27:49 <dcoutts> so if I build a prog which uses gtk2hs then in my Haskell source code I can #include <gtk2hs-config.h>
03:28:10 <dcoutts> and do things like find out which bits were built, the versio of Gtk+ it was built against etc
03:28:23 <juhp> dcoutts: grepping the sources I don't see why the glib module requires it though :)
03:28:35 <dcoutts> basically to do conditional compilatiorn in client code
03:28:44 <dcoutts> the glib package itself doesn't need it
03:28:57 <dcoutts> it's a service for user's code to make itself more portable
03:29:06 <juhp> dcoutts: so how does ghc-pkg know that it is needed?
03:29:14 <dcoutts> eg it allows code to fallback to gdk if cairo is not available
03:29:26 <dcoutts> juhp, because it's mentioned in the package file
03:29:27 <paolino> morning
03:29:49 <dcoutts> juhp, oh actually its not. :-)
03:29:50 <paolino> how I write this type (can I ?)
03:30:01 <paolino> newtype  Solution = (Groupable a) => Solution [a]
03:30:15 <dcoutts> juhp, the glib package mentions include-dirs: /usr/local/lib/gtk2hs/include
03:30:23 <paolino> wherer Groupable is a class
03:30:25 <juhp> right
03:30:26 <dcoutts> juhp, and that's where we must install the gtk2hs-config.h
03:30:36 <juhp> ok
03:30:37 <ski> data Solution = forall a. (Groupable a) => Solution [a]
03:30:54 <ski> paolino : you can't use newtype with existentials
03:31:15 <dcoutts> juhp, the include-dirs for used packages are used as search dirs when cpp'ing users code
03:31:20 <paolino> ski does that involve more work for the program in manipulations ?
03:31:35 <ski> more work than what ?
03:31:54 <juhp> dcoutts: I still don't see how it knows it is gtk2hs-config.h?  or maybe ghc-pkg only complained about the missing dir? :)
03:32:03 <dcoutts> juhp, probably
03:32:04 <juhp> I can't remember now
03:32:09 <dcoutts> it doesn't know about the file
03:32:19 <paolino> using (Groupable a)=>  in the functions ?
03:32:22 <juhp> in which case it is exactly what I'm seeing now with fps ;)
03:32:30 <juhp> dcoutts: thanks a lot
03:33:40 <ski> paolino : using existentials allow you to use heterogenous collections .. if you don't need that, then you don't to use existentials
03:34:35 <ski> paolino : anyway, it should be roughly the same amount of work, i think, maybe slightly more .. at most constant overhead anyway
03:34:55 <paolino> thanks
03:35:01 <ski> (hm, actually, that depends, i just realized)
03:35:21 <ski> but, if you use it in similar ways, then it should be roughly same work
03:35:46 <paolino> ty..afk
03:39:53 <juhp> dcoutts: hIDE is building now :)
03:40:23 <juhp> until "Setup.lhs: cannot satisfy dependency ghc-api-any" anyway ;o)
03:41:00 <musasabi> Why is TH (in compile time) so slow?
03:41:06 <shapr> @where ghc-api
03:41:07 <lambdabot> http://www.scannedinavian.org/~lemmih/ghc-api/
03:44:05 <dcoutts> juhp, thinking of hacking on hIDE? :-)
03:44:27 <juhp> thanks shapr
03:44:29 <dcoutts> we're in need of more contributers
03:44:40 <juhp> dcoutts: well, more dreaming :-|
03:44:57 <juhp> I would really like to I think
03:45:05 <dcoutts> juhp, hIDE is still pretty alpha
03:45:13 <juhp> having said that yi still doesn't work for me....
03:45:23 <dcoutts> plenty of opportunities to help out
03:45:28 <juhp> still freezes on delete (backspace)
03:45:41 <juhp> which is not so cool :)
03:45:47 <dcoutts> and plenty to debug! :-)
03:45:51 <juhp> hehe
03:45:59 * dcoutts has to go now
03:46:32 * dcoutts is off to present a nasty algorithm to his PhD supervisor
03:46:44 <juhp> have fun!
03:50:40 <juhp> sigh
03:50:55 <juhp> ghc-api gives me another build error ;)
03:51:05 <juhp> Setup.lhs:7:59:
03:51:06 <juhp>     Couldn't match `LocalBuildInfo'
03:51:06 <juhp>            against `Distribution.PackageDescription.PackageDescription'
03:51:20 <kzm> I'm reading old archives of LtU, and stumbled across some memorable sayings by Paul Graham.  Should/can I add them to the 'bot with quote-add?
03:51:29 <shapr> Sure, go for it.
03:51:48 <vegai> the command is @remember, actually
03:52:13 <juhp> is my cabal too new or something?
03:53:16 <SamB> hmm, is jlouis around?
03:53:25 <kzm> @remember Paul_Graham I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
03:53:29 <kzm> Like so?
03:54:54 * kzm thought it was a hilarious comparison, with just the right amount of truth to it.
03:55:45 <vegai> dunno
03:55:48 <vegai> @quote Paul_Graham
03:55:49 <lambdabot>  I get the impression that using [Haskell] would feel like reading a
03:55:49 <lambdabot> novel written by a literary critic.
03:55:55 <vegai> => Yes.
03:56:24 <vegai> yes, well said.
03:58:22 <SamB> @localtime jlouis
03:58:24 <lambdabot> Local time for jlouis is Tue Nov  8 12:58:01 2005
04:00:16 <pierre> hello
04:00:56 <shapr> hiya pierre
04:01:27 <pierre> can you recommend me some manuals about "haskell style" practical programming?
04:02:11 <SamB> pierre: manuals?
04:02:14 <pierre> i want to start write something, but all that i found is basically teory
04:02:34 <shapr> Maybe there's something on the wiki?
04:02:48 <SamB> pierre: you should probably look at practical code if you want to learn about it...
04:03:02 <kzm> The GHC docs are good as a reference.
04:03:09 <shapr> lambdabot is fun to read.
04:03:15 <kzm> ..but you probably wanted more of a tutorial thing?
04:03:33 <SamB> pierre: what sort of program do you want to write?
04:03:34 <pierre> ..  probably yes
04:03:40 <kzm> What about the books?  Haskell, the craft (Thompson) or...
04:04:00 <pierre> the problem is i don't know that sort of
04:04:08 * kzm is escaped by the name of the other book, check the bookshelf at haskell.org?
04:04:15 <SamB> oh, you don't know what you want to write?
04:04:21 <pierre> i'm currently CPP game programmer
04:04:29 <SamB> you mean C++?
04:04:33 <pierre> yes
04:04:37 <Itkovian> what games?
04:04:42 <SamB> because you can't write games in the C preprocessor
04:04:43 <kzm> Ah, not the C preprocessor, then :-)
04:04:44 <pierre> 3D :-)
04:04:52 <Itkovian> titles?
04:04:56 <pierre> no :-)
04:05:02 <Itkovian> ok then
04:05:03 <pierre> engines
04:05:13 <Itkovian> nice.
04:05:14 <SamB> do these engines have names?
04:05:36 <kzm> Feel free to download my code, read it, and ask any questions.  Preferably improving it in the process :-)
04:06:16 <pierre> kzm: hm, and where your code is?
04:06:18 <kzm> You should be able to find plenty of examples of how not to do it :-)
04:07:14 <musasabi> Are there known problems with TH + profiling? GHC keeps telling me that:
04:07:16 <pierre> SamB: i'm currently working for RGDE project
04:07:16 <musasabi> ghc-6.4.1: dist/build/Codec/Serialize/SerTH/BSerDerive.p_o: unknown symbol `era'
04:07:28 <musasabi> But the file builds fine without profiling.
04:12:23 <pierre> Another question: are there good tutorials for WinApi in haskell?
04:20:00 <SamB> pierre: it probably isn't much different from in C, but I'm not sure.
04:22:05 <SamB> huh, I wonder if there is any specific reason why fptools/libraries/Win32/doc/HSWin32.xml has a book id of "HSX11"...
04:22:53 <shapr> Maybe it's derived from Alastair Reid's HSX11 ?
04:24:01 <pitecus> Why is the function "nub" called nub?
04:24:11 <SamB> that docbook file at least appears to derive from a docbook file describing HSX11
04:45:55 <shapr> hiya tony2
04:56:42 <tony2> hiya shapr
05:03:02 <SamB> is there some way to tell ghc to be quiet about pattern match failure for a particular function?
05:03:15 <SamB> er, not failure
05:03:21 <SamB> just unmatched patterns
05:20:34 <paolino> good afternoon, is there another  way to zip (f xs) xs ?
05:22:09 <paolino> is that operation efficent or it runs the list twice ?
05:22:53 <paolino> oops  zip (map f xs) xs
05:24:58 <Igloo> xs is only evaluated once
05:25:22 <paolino> map (\x -> (f x,x)) xs is the same ?
05:27:00 <paolino> ok
05:30:57 * SamB wonders when jlouis comes around
05:31:01 <SamB> jlouis: PING
06:43:53 <joelr> musasabi: did you ever find a cabalized HList?
06:48:43 <musasabi> joelr: I have such a beast.
06:48:55 <joelr> he
06:49:02 <xerox> What is HList?
06:49:05 <joelr> can you shoot me the HList.cabal please?
06:49:13 <joelr> @google HList
06:49:14 <lambdabot> http://homepages.cwi.nl/~ralf/HList/
06:49:33 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/OOHaskell_cabal.tar.gz (very unofficial, I think the authors are working on a proper release)
06:50:57 <joelr> musasabi: is this actually HList?
06:50:59 <Cale> Any windows Haskell users around? de1337 would like to know how to install hs-plugins on windows
06:51:20 <joelr> i tried this /hs plugins/ it worked
06:51:23 <joelr> what's the issue?
06:51:25 <Cale> ndm would perhaps know?
06:51:46 <joelr> de1337: what's the problem?
06:52:08 <musasabi> joelr: that is OOHaskell which includes HList.
06:52:10 <Cale> Well, how does one run a confugure script under windows :)
06:52:12 <Cale> ?
06:52:15 <joelr> musasabi: what's OOHaskell? is this HList and can I use it in regular ghci?
06:52:23 <Cale> configure*
06:52:33 <musasabi> joelr: it is HList + fancy OO stuff.
06:52:47 <joelr> hmm... i don't remember how i did it now, let me look. i know i had the mingw + cygwin environments
06:53:02 <de1337> hmm ok
06:53:05 <musasabi> joelr: basically just "import OOHaskell" and it just works.
06:53:20 <xerox> .zip sucks, hmpf.
06:53:34 <joelr> musasabi: will try
06:53:45 <joelr> i want to use the extensible records
06:55:26 <joelr> de1337: still here?
06:57:05 <joelr> de1337: the README file suggests that you don't need to run configure. check it out, it's got good instructions :-) there are somehow different versions of plugins and i think the later ones _need_ configure
06:57:29 <joelr> de1337: but the version that I have can be built without it, like a regular cabalized package
06:58:25 <joelr> de1337: it's the same version 0.9.10 apparently and i don't know where mine, the one that includes plugins.cabal
06:58:29 <de1337> good instructions? yeah right :p
06:58:46 <joelr> de1337: try darcs, i think that's what i did
06:59:02 <de1337> i wonder if its able to install without alot of extra stuff like cygwin/gcc and so on
06:59:36 <joelr> de1337: you don't need that if you get the version that's cabalized
06:59:47 <joelr> de1337: the variant even. try darcs get http://www.cse.unsw.edu.au/~dons/code/hs-plugins
07:00:00 <joelr> i think that has the plugins.cabal
07:00:25 <joelr> then follow the readme file, i.e. ghc --make Setup.hs -o setup && setup configure && setup build && setup install
07:00:47 <joelr> for some reason the tarball that you download from the site is configure-based
07:01:10 <de1337> okay thanks, btw what it cabalized?
07:01:36 <joelr> de1337: ugh... easy to build, essentially :) using my instructions above
07:02:05 <joelr> @google cabal
07:02:06 <lambdabot> http://www.thecabal.net/
07:02:11 <joelr> hmm
07:02:17 <joelr> @google haskell cabal
07:02:18 <lambdabot> http://www.haskell.org/cabal/
07:02:25 <joelr> de1337: there you go
07:02:45 * joelr finally has been able to help someone! hehehe
07:02:46 <de1337> will check it out, what i finally want to do is to just implement a little haskell interpreter in a c++ program just for fun, like eval
07:03:11 <joelr> de1337: that did not work very well for me on windows. try it and report your findings
07:16:08 <boegel> shapr: ping
07:16:11 <shapr> y0
07:17:58 <boegel> peoples: haskell@ or haskell-cafe@ for asking for suggestions on the 'take 10 [1..]' project for TMR (http://haskell.org/tmrwiki/TopTenHaskell)
07:18:26 <xerox> coffee :)
07:18:51 * dcoutts_ agrees with xerox
07:19:27 <boegel> no-one ?
07:19:53 <shapr> I'd say haskell-cafe
07:21:02 <boegel> and how about subject ? how's "Request for subject suggestions for a series of informal top 10 Haskell articles"
07:21:59 <shapr> I like it.
07:27:13 <gour> dcoutts_: coffee or tea?
07:29:22 <neologism> take 10 [1..] :)))
07:29:25 <neologism> soudns nice ;)
07:29:54 <dcoutts_> gour, tea usually
07:30:31 <gour> dcoutts_: ahh good, i was already afraid for salvation of your soul ;)
07:31:31 <gour> dcoutts_: how was the meeting with your guru?
07:36:30 <pesco> araujo: You asked for category theory material earlier. I just obtained this: http://katmat.math.uni-bremen.de/acc/acc.pdf
07:37:35 <pesco> (Which is a pedagogical book on the subject, no prerequisites except basic set theory, and, appearently, background in computer science helpful for the examples.
07:37:37 <pesco> )
07:38:56 <dcoutts_> gour, the meeting was ok
07:39:11 <dcoutts_> we're trying to figure out a semantics of the thing I'm working on
07:39:15 <dcoutts_> because it's not clear
07:43:55 <gour_> dcoutts_: my isp as some problems with the dsl line
07:44:33 <neadjneki> could someone give me a link to some opensource project in haskell to study?
07:44:44 <dcoutts_> @where gtk2hs
07:44:44 <lambdabot> http://haskell.org/gtk2hs/
07:44:56 <neadjneki> thanks
07:44:59 <dcoutts_> neadjneki, or are you looking for something more specific?
07:45:01 <pejo> dcoutts, duh, I pinged you the other day, then I lost track of irc.
07:45:11 <dcoutts_> pejo, oh yeah about PE
07:46:13 <pejo> dcoutts, nod. I lost track of time too, so I have no idea when you said "Ping me in a month", but I figured it was about now. :-)
07:46:35 <dcoutts_> pejo, oh right. Sorry I've still not got anything published :-(
07:46:55 <dcoutts_> pejo, I might be able to answer a question or two however
07:47:03 <pejo> dcoutts, any scribbles of some sort?
07:47:11 <neadjneki> dcoutts i have trouble understanding basic things (arrays right now) and i believe it would be far easier to look at some code instead of trying to figure everything out
07:47:16 <Peach44> hello all
07:47:35 <pejo> dcoutts, currently out of questions. Turchin with his supercompilation is pretty close to how I'd implement it naively.
07:47:35 <Peach44> I'm having a problem with the show thing in Haskell
07:47:37 <dcoutts_> pejo, not anyhing properly written down
07:47:45 <Peach44> show class*
07:48:10 <dcoutts_> pejo, at the moment I'm working on the binding time analysis
07:48:16 <Peach44> i have an instance where by I have blah (x,y) - i want to show both x and y
07:48:20 <Peach44> how would I got about it ?
07:48:37 <dcoutts_> pejo, and trying to be a little formal in the treatment of the simplification rules
07:49:05 <dcoutts_> neadjneki, hmm. gtk2hs doesn't use arrays much.
07:49:18 <Peach44> i.e. show (Blah "+" [fstNumber, sndNumber]) = (show fstNumber) (show +) (show sndNumber)
07:49:38 <pejo> dcoutts, ok. Feel free to honk when you have something you dare to show. :-) (I'm not picky, I'm pretty used to getting "articles" that totally lack text consisting of 5-10 figures).
07:49:50 <dcoutts_> pejo, ok :-0
07:50:55 <Peach44> anyone have any idea with the show class ?
07:51:05 <Cale> show (Blah s []) = ""; show (Blah s [x]) = show x; show (Blah s (x:y:xs)) = show x ++ s ++ show (Blah s (y:xs))
07:51:11 <Cale> does that do what you want?
07:52:23 <pejo> dcoutts, simplification of what btw?
07:53:01 <Peach44> thanks Cale :)
07:53:07 <Cale> no problem :)
07:53:10 <Peach44> how can I show a + symbol ?
07:53:18 <Cale> "+"
07:53:23 <Peach44> ok
07:53:38 <Cale> you can't show the function (+) of course
07:53:43 <dcoutts_> pejo, simplification of constraints arising from the binding time analysis
07:53:57 <Itkovian> ttyl
07:54:21 <Cale> I'm assuming  data Blah a = Blah String [a]
07:54:31 <pejo> dcoutts, ah, ok.
07:56:02 <Cale> btw, loading the list module, show (Blah s xs) = concat $ intersperse s (map show xs)
07:56:06 <Cale> that does the same thing
08:08:53 <boegel> I'm off, bye everyone !
08:12:53 <Si\Uni> is it possible to have multiple fundeps in a class head?
08:22:43 <araujo> Hello!
08:22:57 * araujo back
08:31:58 <exe> Hello araujo.
08:33:30 <SamB> @seen jlouis
08:33:30 <lambdabot> jlouis is in #haskell. I don't know when jlouis last spoke.
08:33:47 <SamB> @vixen you are so useless
08:33:47 <lambdabot> good question
08:39:59 <joelr> @paste
08:39:59 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:42:42 <gour> dcoutts_: ping
08:44:01 <joelr> can someone help me with the inferred type less than polymorphic error?
08:44:04 <joelr> please
08:44:23 <joelr> err, less poly than expected
08:44:30 <araujo> Hola exe :-)
08:48:16 * SamB wonders how long Binary is
08:49:09 * malcolm_ gets out shapr's tape measure
08:50:56 <joelr> @paste
08:50:57 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:50:58 <joelr> anyone?
08:51:33 <SamB> joelr: probably not, there isn't usually much you can do about those
08:51:40 <joelr> hmm
08:51:44 <joelr> apart from?
08:52:52 <SamB> you could try -fglasgow-exts, if thats yours  at the top
08:53:01 <joelr> mine for sure
08:53:42 <joelr> nope, did not help
08:53:54 <SamB> what are PU and P these days?
08:54:13 <joelr> @google pickler combinators
08:54:14 <lambdabot> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
08:54:18 <joelr> SamB: ;)
08:55:55 <joelr> actually, i understand what the problem is... just don't know how to fix it.
08:57:49 <SamB> which page?
08:58:06 <joelr> hmm
08:58:19 <joelr> the second big set of code samples
08:58:20 <joelr> hang on
08:58:49 <joelr> SamB: top of page4
08:59:31 <joelr> wrap goes from a to b and back, see, but the type of a is nowhere in the signature of the function
08:59:38 <malcolm_> joelr: can you rewrite with without existentials?  You'd have to include more type variables in lots of signatures, but it would almost certainly eliminate the escaping quantified poly wotsit
08:59:54 <joelr> hmm
09:00:00 <joelr> the existensials are the forall stuff?
09:00:14 <malcolm_> joelr: yes, confusingly enough
09:00:33 <joelr> malcolm_: how would you suggest i rewrite it? remove the forall and then include the (eq, show) where needed?
09:01:21 <malcolm_> joelr: data (Show a, Eq a) => Prop a = Attr a := a
09:01:45 <joelr> malcolm_: before i do that... i'm actually storing the toDyn and fromDynamic within the attribute, could that be used in the wrap code?
09:01:56 <joelr> i guess that would be more complex. let me try removing the existensials
09:01:57 <joelr> sec
09:02:42 <malcolm_> joelr: just wondering about the forall b .  (b is not mentioned on the RHS)  Does it work if you just delete b?
09:03:17 <joelr> malcolm_: let me try. i forgot to remove it
09:03:46 <joelr> no, b has nothing to do with it
09:05:03 <joelr> malcolm_: is the snippet you posted equivalent to mine?
09:05:10 <joelr> is := still a constructor in your case?
09:06:13 <malcolm_> joelr: yes.  But you could ditch the (Show a, Eq a) context if you like.  Just put them (where necessary) on the function signatures rather than the datatype decl
09:06:22 <joelr> malcolm_: the other thing is that [Prop] is heterogeneous, whereas removing the existentials makes it homogeneous which is not quite what i want
09:06:35 <joelr> for example
09:06:40 <joelr> type Props = M.Map String (Int, Prop)
09:06:43 <joelr> this stops working
09:06:58 <SamB> hmm, how to implement this protocol...
09:07:07 <joelr> SamB: which one?
09:07:11 <joelr> the pickler one?
09:07:21 <malcolm_> joelr: well, heterogeneous collections is why one uses existentials in Haskell, so i guess you need to stick with it.
09:07:36 <joelr> in Props it builds a closure of pairs, with two functions that convert from pair by adding to list and vise versa
09:07:48 <joelr> the problem is that it knows nothing about type of a at this point but
09:07:53 <SamB> joelr: no, I'm trying to figure out how to implement the bittorrent wire protocol. you can read about it here: http://wiki.theory.org/BitTorrentSpecification
09:08:07 <joelr> i actually have the (toDyn, fromDynamic) stored in the Attr
09:08:18 <joelr> and i'm making extensive use of that throughout
09:08:33 <joelr> i wonder if i can apply these here
09:08:38 <joelr> what do you think malcolm_ ?
09:09:17 <joelr> maybe if i encode a into dynamic using toDynamic and extract it using my stored fromDyn it would work?
09:09:27 <malcolm_> joelr:  I think what the error message is trying to tell you is that props' returns a PU [a], not a PU Props like you wanted it to.
09:09:52 <joelr> i hate this #%#% and would rather go with the extensible records from HList but i don't have time for that
09:09:58 <joelr> malcolm_: no, it's not that
09:10:17 <joelr> wrap :: (a -> b, b -> a) -> PU a -> PU b
09:10:19 <joelr> it's this
09:10:42 <joelr> i can't just build a closure from pairs without using wrap, i think
09:10:52 <joelr> or maybe i can
09:11:05 <joelr>               wrap (\(a, b) -> a : b,
09:11:05 <joelr>                     \(a : b) -> (a, b))
09:11:05 <joelr>                        (pair pp (props' xs))
09:11:34 <joelr> this builds a closure of pairs and includes functions that go from pair-list to list and back
09:11:42 <joelr> i think that's where the issue is
09:12:13 <malcolm_> joelr: what does pair do?
09:12:23 <joelr> the pair pickler would invoke pp and pp is PU a or something like that
09:12:32 <joelr> malcolm_: actually, following my logic i think you are right
09:12:40 <joelr> and i need a list of [Prop]
09:12:41 <malcolm_> joelr: what is pair's type?
09:12:45 <joelr> sec
09:12:51 <joelr> @google pickler combinators
09:12:53 <lambdabot> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
09:12:55 <joelr> page 4
09:13:14 <joelr> pair :: PU a -> PU b -> PU (a,b)
09:13:50 <joelr> i'm modifying the fixedList bit from the paper
09:15:11 <joelr> malcolm_: take a look at @paste
09:15:21 <malcolm_> joelr: props' is definitely returning a PU [something] then, but your type signature for props says it ought to return a PU Props.  Since type Props /= [something], there's your problem.
09:16:05 <joelr> malcolm_: any suggestions on how i can modify this?
09:16:13 <joelr> oh
09:17:00 <joelr> it looks like i need to return the Props map
09:17:02 <malcolm_> joelr: wrap (\(a,b) -> Map.insert a b,  ...) (pair ...)
09:17:07 <joelr> so that's my issue
09:19:15 <joelr> malcolm_: right... let me think about this. the insert is surely what i need to do but i gotta figure out how to get actual item to insert. i think i need to make a list and then convert it back into a map in one fell swoop.
09:19:28 <joelr> thanks, though, as you pointed me in the right direction
09:20:47 <malcolm_> joelr: no probs
09:30:32 <neadjneki> is it possible to create (cast) an array from a Ptr?
09:32:00 <neadjneki> i also have the size of course
09:33:21 <Cale> Have you looked in Foreign.Storable?
09:34:01 <Cale> you could do a bunch of peeks off a Ptr
09:34:22 <Cale> as long as there are Storable instances for the elements
09:37:37 <SamB> @hoogle Int -> [a] -> ([a], [a])
09:37:38 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
09:37:38 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
09:37:38 <lambdabot> Graphics.UI.ObjectIO.CommonDef.split :: Int -> [x] -> ([x], [x])
09:37:52 <SamB> @hoogle b -> [a] -> ([a], [a])
09:37:53 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
09:37:53 <lambdabot> Data.List.genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
09:37:53 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
09:38:24 <SamB> @hoogle [a] -> (a, [a])
09:38:25 <lambdabot> No matches, try a more general search
09:39:29 <SamB> @hoogle Handle -> Int -> IO String
09:39:30 <lambdabot> System.IO.hShow :: Handle -> IO String
09:39:30 <lambdabot> System.IO.hGetLine :: Handle -> IO String
09:39:30 <lambdabot> System.IO.hGetContents :: Handle -> IO String
09:42:52 <neadjneki> cale thanks
09:43:40 <neadjneki> that was the only module i didnt check :)
09:49:05 <SamB> whats a good way to read some number of bytes from a handle?
09:50:06 <gour> dcoutts_: do you use meld for resolving darcs conflicts?
09:53:24 <SamB> okay, at the risk of offending someone, what I am about to do is this:
09:54:44 <SamB> hGetChars h n = sequence (replicate n (hGetChar h))
09:55:44 <paolino_> good evening. How I print a list an element for line ?
09:55:59 <SamB> map print list
09:56:09 <wilx> @type print
09:56:09 <lambdabot> forall a. (Show a) => a -> IO ()
09:56:11 <SamB> er, mapM print list
09:56:20 <SamB> @type mapM print
09:56:21 <lambdabot> forall a. (Show a) => [a] -> IO [()]
09:56:36 <SamB> mapM_ print list, even
09:56:45 <SamB> @type mapM_ print
09:56:46 <lambdabot> forall a. (Show a) => [a] -> IO ()
09:57:28 <paolino_> @type MapM
09:57:29 <lambdabot> Not in scope: data constructor `MapM'
09:57:34 <paolino_> @type mapM
09:57:35 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
09:58:21 <paolino_> grrazie
10:00:19 <shapr> y0 SyntaxNinja
10:00:28 <araujo> y0 y0
10:01:19 <paolino_> can I see an example with lift resolving the same problem ?
10:01:31 <SamB> shapr: do you know the Haskell equivalent of f.read(n)?
10:02:11 <paolino_> liftM maybe ...
10:05:57 <neadjneki> samb hGetBuf?
10:06:22 <SamB> neadjneki: well, that would work, but I don't really want to use a Ptr...
10:06:31 <SamB> well, not at this point anyway
10:21:32 <dcoutts> gour, I use meld with cvs. So far with darcs I just use the darcs command line. But I'd like support in meld. I think it would be more productive with larger programs.
10:22:57 <gour> dcoutts: i'm interested regarding the 'external-merge' option
10:23:24 <gour> dcoutts: on kde i was using 'ALL external-merge kdiff3 --output %o %a %1 %2' to launch kdiff3 when conflicts
10:23:39 <gour> dcoutts: is it possible with meld too?
10:24:04 * ndm is writing WinDarcs as we speak
10:24:12 <dcoutts> gour, it's possible to do a 3-way merge which will show conflicts in the middle column
10:24:33 <dcoutts> meld does that and shows conflicts in a different colour from other differences
10:24:42 <dcoutts> ndm, cool
10:24:46 <gour> dcoutts: when i try to invoke meld --help i get several warnings
10:24:54 <dcoutts> gour, from python.
10:24:59 <ndm> its taken 4 hours so far, and i can already pick and send my patches
10:25:07 <ndm> and have nice whatsnew support
10:25:10 <gour> ndm: still i'm staying on linux os :-)
10:25:13 <ndm> just revert and commit
10:25:15 <dcoutts> ndm, what kind of GUI are you bulding?
10:25:31 <dcoutts> ndm, what is the UI model you're using
10:25:31 <ndm> gour, its C# and not particularly complex - mono may work
10:25:43 <ndm> dcoutts, a tray icon, always available
10:25:52 <ndm> which on right click gives about 4 options
10:25:53 <gour> dcoutts: so what is the meld eq. for the above kdiff3 command
10:25:59 <ndm> darcs send, darcs whatsnew, darcs pull
10:26:06 <ndm> i'll screenshot and post a few of them...
10:26:15 <dcoutts> ndm, meld file1 file2 file3
10:26:18 <gour> dcoutts: i do not see any options like that
10:26:31 <ndm> dcoutts, does meld work on windows?
10:26:36 <ndm> i couldn't find any binaries
10:26:47 <dcoutts> ndm, not sure, it might do
10:27:03 <gour> dcoutts: so ALL external-merge meld %1 %2 %3 should work?
10:27:16 <dcoutts> external-merge?
10:27:17 <ndm> if it doesn, i would like a copy...
10:28:21 <JKnecht> darcs appears to have become the principal Haskell app. That in 6 mos?
10:29:22 <gour> dcoutts: yes, that is the option you can put in your ~/.darcs/defaults
10:29:57 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/darcs_send.png
10:30:01 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/darcs_whatsnew.png
10:30:26 <SyntaxNinja> y0 shapr
10:30:35 <SyntaxNinja> Cale: any new logos? :)
10:31:19 <Cale> not for the moment, I'll probably work on some more later today :)
10:31:32 <boegel|home> hmm, I'm getting haskell and haskell-cafe mails on my email adres, but when I send a mail, I get a notification that my message awaits moderator approval :s
10:32:01 <dcoutts> gour, oh I see. I didn't know about that. I'll try it.
10:32:14 <Igloo> boegel|home: Are you sure they're both the exact same address?
10:32:36 <Igloo> boegel|home: I don't know if it'll be looking at the From:, Sender: or envelope from
10:32:57 <boegel|home> Igloo: I'm unsubscribing and resubscribing as we speak, to avoid that :)
10:33:10 <boegel|home> I just need a password reminder...
10:35:02 <boegel|home> which takes a while apparently
10:35:43 <SyntaxNinja> Cale: cool :)
10:38:02 <gour> dcoutts: i'm using it all the time, you probably didn't read docs (hacker :-)
10:39:05 <boegel|home> shapr: ping
10:39:09 <shapr> pong
10:39:30 <boegel|home> shapr: is there any way I can add a netstat thingie to the TopTenHaskell wiki page ?
10:39:43 <shapr> Not that I can think of.
10:39:59 <boegel|home> shapr: bummer :(
10:40:11 <boegel|home> it's some javascript code, I guess I can't paste that in a wiki ?
10:40:23 <shapr> You can, but I don't know how to get it executed.
10:40:33 <boegel|home> hmm
10:40:35 <boegel|home> lemme try :)
10:41:41 <SamB> shapr: review WireProtocol.hs!
10:42:18 <SamB> repo is http://naesten.dyndns.org:8080/repos/conjure-SamB
10:42:45 * shapr pulls
10:43:46 * SamB checks to make sure he pulled that patch to the right repo
10:43:52 * SamB did
10:45:06 <SamB> sorry about the lag, someone seems to have decided now is a good time to browse the web or something...
10:46:28 <SamB> hmm, maybe I ought to unpull that patch to PiecePicker.hs...
10:47:19 <shapr> The one that causes conflicts and doesn't typecheck? :-)
10:47:36 <SamB> causes conflicts? yes.
10:48:54 <Cale> hrm, darcs pull in the lambdabot repo on my machine results in 100% cpu for a long time
10:50:37 <Cale> (too long, my machine overheats -- seems I really need to clean up my cpu and reapply some fresh thermal paste)
10:52:25 <SamB> shapr: also let me know if you have any ideas about how to test that
10:52:31 <shapr> ok
10:52:46 <shapr> Cale: You can just pull into a new repo, that generally fixes it.
10:53:01 <joelr> gents, is there a way to fold a map into a list in ascending order of elements as opposed to keys?
10:53:05 <SamB> oh, and have you tried running ./a.out on a torrent file yet?
10:53:18 <joelr> toAscList :: Map k a -> [(k,a)]
10:53:18 <joelr> toAscList t   = foldr (\k x xs -> (k,x):xs) [] t
10:53:26 <joelr> this goes by key i believe
10:53:30 <Speck> oh man, I just saw a monad described as "the new hot thing in computer science"
10:53:38 <shapr> Speck: Where's that from?
10:53:45 <SamB> Speck: cool!
10:53:51 <Speck> a ruby blog, http://cwilliams.textdriven.com/pages/monads
10:53:57 <SamB> huh
10:54:25 <Speck> I see an uninformative oreilly blog/tutorial about haskell in the near future
10:54:52 <shapr> Well, it is called 'Late to the Party'.
10:55:08 <Speck> presumably late to the ruby party
10:55:17 <SamB> common pattern in functional programming?
10:55:29 <SamB> hmm... is that so yet?
10:55:36 <shapr> It's common in the Haskell world.
10:55:43 <shapr> FP == Haskell?
10:55:48 <shapr> Probably not.
10:56:06 <Speck> a lot of people in the ruby world are learning haskell now because matz said it and io were two languages he recommended learning
10:56:45 <shapr> Wow, neat.
10:57:15 <SamB> probably the reason why they are often described as black magic is because thats how IO is implemented
10:57:16 <Speck> it'll be interesting... I'm kind of afraid, but at least we're not getting PHP or something :-P
11:01:32 <Oejet> There is room for a nice Haskell/Gtk2HS-GUI for Git the stupid tree content tracker, which is used by the Linux kernel.  That could be another scoop for Haskell, so if anyone is interested...?
11:02:50 <thedward> someone should just write a darcs gui, then use darcs git support
11:03:03 <ndm> i'm writing a darcs gui
11:03:12 <ndm> WinDarcs :)
11:05:30 <arjanb> :) do you ever lose count of how many project you're working on?
11:05:40 <ndm> arjanb, yes - but i have a list on my desk
11:05:51 <ndm> (seriously, otherwise i have been known to loose projects)
11:06:59 <shapr> hiya malcolm_
11:07:12 * malcolm_ waves
11:07:22 <shapr> malcolm_: What was that abut shapr's tape measure?
11:07:32 * shapr is obviously feeling Canadian today.
11:07:44 <malcolm_> someone asked how long was a piece of string, errm, Binary
11:08:06 <shapr> um. ok.
11:08:30 <shapr> I am confused, but used to that mental state.
11:08:42 <malcolm_> I recall you making the same joke a few days back, so it deserved attribution
11:09:04 <shapr> oh :-)
11:09:06 <shapr> thanks :-)
11:09:15 * shapr boings cheerfully
11:10:21 <malcolm_> what Canadian are you feeling?
11:10:25 <shapr> abut :-)
11:10:50 <shapr> I made a typo that looked suspiciously canadian.
11:11:32 <vegai> abut. Is that really canadian or southpark-canadian? :P
11:12:05 <shapr> From what I understand it's mostly southpark-canadian. I spoke to a canadian guy on skype who said that a very few canadians do speak that way, but less than you think.
11:12:44 <SamB> shapr: I asked how long Binary was
11:13:16 <SamB> shapr: I was at the time still trying to figure out how in the world to do WireProtocol
11:14:17 <SyntaxNinja> hi malcolm_
11:14:21 <SyntaxNinja> malcolm_: heh
11:14:33 <malcolm_> SyntaxNinja: eh
11:14:48 <malcolm_> SyntaxNinja: (we're being Canadian)
11:14:57 * shapr snickers
11:15:18 <SyntaxNinja> malcolm_: I'm afraid of being Canadian. shapr might feel me.
11:16:33 <shapr> We're hunting Treasure.
11:19:23 <shapr> SamB: WireProtocol looks good to me.
11:19:41 <SamB> shapr: cool
11:23:35 * CosmicRay misses part of the context and notes that abut is a fine british and american word also
11:23:42 <CosmicRay> (means adjacent)
11:25:31 <shapr> What're you on abut?
11:25:46 <CosmicRay> oh, you mean aboot? ;-)
11:25:57 * shapr grins
11:26:33 <CosmicRay> Igloo: any ideas on 337818?
11:26:41 <CosmicRay> or, for that matter, SyntaxNinja
11:26:50 <CosmicRay> it seems to be linking in the wrong library on amd64 but not on x86
11:27:42 <shapr> SamB: I'm confused. Did conjure check my torrent that quickly?
11:27:49 <SyntaxNinja> can we get a new lambdabot pluggin for debian bugs? i twould be like the wiki one
11:28:06 <SyntaxNinja> @debbug 337818 would give: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=337818
11:28:06 <lambdabot> Unknown command, try @listcommands.
11:28:19 <shapr> That would take about ten seconds.
11:28:25 <shapr> Edit Dummy.hs and add it in.
11:28:25 <SamB> shapr: check?
11:28:44 <SyntaxNinja> in fact, it should be abstracted, so I can say '@addFun debbug (\bugNum -> "http://..." ++ bugNum)
11:28:46 <SyntaxNinja> '
11:28:52 <shapr> SamB: I have a large single file torrent. It appears that conjure checked my torrent somewhat instantly.
11:29:01 * SyntaxNinja pokes dons
11:29:03 <SamB> shapr: it didn't actually check it
11:29:08 <shapr> oh, ok
11:29:11 <shapr> That's my job, right?
11:29:16 <SamB> heh
11:29:19 <SamB> if you want to
11:29:27 <shapr> It did try to download more chunks of an incomplete torrent I have.
11:29:47 <shapr> At least, it looks like it did.
11:30:01 <SamB> no, it doesn't try to download anything really
11:30:06 <shapr> "a.out: ./MiniHTTP.hs:59:10-59: Irrefutable pattern failed for pattern (rheaders, _ : rbodylines)"
11:30:24 <SamB> hmm.
11:31:13 <SamB> hmm, I have to go vote or something now... you can figure out how to debug it, it isn't that complicated...
11:31:37 <SyntaxNinja> CosmicRay: how does your ghc-pkg output differ?
11:32:32 <SamB> that HTTP stuff is just querying the tracker
11:32:45 <shapr> ok
11:35:12 <CosmicRay> SyntaxNinja: Mine shoes sqlite3 for extra-libraries
11:35:15 <CosmicRay> which is what it should
11:36:10 <SyntaxNinja> for which package?
11:37:57 <kombinator> CosmicRay: (I'm the submitter of the bug) do you have any idea what I can check on my side?
11:41:57 <CosmicRay> oh hi kombinator
11:42:04 <CosmicRay> SyntaxNinja: hsql-sqlite3
11:42:09 <CosmicRay> kombinator: I am totally confused.
11:42:24 <CosmicRay> kombinator: I would suggest maybe trying to build the package from source and see if anything leaps out at you.
11:43:02 <CosmicRay> kombinator: thanks for being persistent, BTW.  It *really* looked like a missing -package option to start with ;-)
11:43:04 <kombinator> could the order in which i've installed my packages have an influence on that?
11:43:35 <CosmicRay> shouldn't
11:43:41 <CosmicRay> I suspect somethign is wrong with the deb on amd64
11:43:47 <kombinator> I've installed hsql + hsql-sqlite and hsql-sqlite3 afterwards
11:43:53 <kombinator> no prob
11:44:04 <Igloo> Does it only happen on one machine?
11:44:37 <CosmicRay> kombinator: do you have another amd64 box to test on?
11:44:48 <kombinator> CosmicRay: can you try the packages on some amd64 debian dev machine
11:44:53 <kombinator> CosmicRay: no
11:45:05 <CosmicRay> kombinator: no, we (debian developers) don't have root on them
11:45:18 <Igloo> Can anyone summarise the actual problem? The bug report is huge
11:45:39 <CosmicRay> hey kombinator, what does extra-libraries in /usr/lib/haskell-packages/ghc6/lib/hsql-sqlite3-1.0/installed-pkg-config say
11:45:42 <Igloo> CosmicRay: You can mail debian-admin to get things installed. That's what they're for, after all...
11:46:04 <CosmicRay> Igloo: -package hsql-sqlite3 is linking in sqlite instead of sqlite3 for him, and ghc-pkg describe on hsql-sqlite3 lists sqlite instead of sqlite3 in extra-libraries.
11:46:13 <CosmicRay> Igloo: yeah but then you wait a few weeks, right?
11:46:19 <CosmicRay> if they ever do it at all
11:47:23 <Igloo> Normally less than a day, rarely more than a few, IME
11:47:29 <kombinator> CosmicRay: do you need to add -package hsql-sqlite in case of sqlite2?
11:47:36 <CosmicRay> oh, I guess they're better than in the old days
11:47:39 <CosmicRay> kombinator: yes
11:47:40 <Igloo> OK, so ghc is doing the right thing, but something went wrong when building the package, then?
11:47:48 <CosmicRay> Igloo: that's my theory
11:48:06 <kombinator> CosmicRay: I don't;)
11:48:10 <kombinator> CosmicRay: it links -lsqlite without that
11:48:28 <Igloo> So you probably either need to look at the build logs or, if that doesn't help, rebuild yourself and prod it as it goes
11:49:16 <CosmicRay> I don't know where to find amd64 build logs.  sigh.  actually I don't know if they're even available.
11:49:31 <gour> dcoutts: have you tried meld with darcs?
11:50:01 <CosmicRay> oh, here we go.
11:50:23 <Igloo> http://amd64.ftbfs.de/
11:51:41 <CosmicRay> <CosmicRay> hey kombinator, what does extra-libraries in /usr/lib/haskell-packages/ghc6/lib/hsql-sqlite3-1.0/installed-pkg-config say
11:53:37 <kombinator> extra-libraries: sqlite
11:53:47 <kombinator> sorry, didn't notice that previous question
11:55:29 <CosmicRay> ok, so something definately went awry with the build.
11:55:54 <kombinator> CosmicRay: new developments: I don't have to include -package hsql-sqlite while using sqlite2 if I compile with --make option!
11:56:10 <kombinator> this is weird
11:56:44 <CosmicRay> AH HA.
11:56:50 <CosmicRay> I think I need a build-dep on pkg-config.
11:56:55 <SamB> shapr: getting anywhere?
11:57:07 * CosmicRay forgot that ths hsql setup.lhs is not the average setup.lhs
11:58:03 <kombinator> CosmicRay: do you still want me to build haskell-hsql?
11:58:10 <CosmicRay> no
12:01:13 <sonden> how is hIDE dev going?
12:05:22 <SamB> @localtime jlouis
12:05:24 <lambdabot> Local time for jlouis is Tue Nov  8 21:05:01 2005
12:06:37 <ibid> how does that work?
12:06:40 <ibid> @localtime ibid
12:06:43 <lambdabot> Local time for ibid is Tue Nov  8 22:06:19 2005
12:06:48 <ibid> ah, ctcp time
12:07:12 <shapr> @localtime lambdabot
12:07:15 <shapr> hmm
12:07:27 <SamB> bug!
12:07:33 <SamB> @localtime dons
12:07:34 <lambdabot> Local time for dons is Wed Nov  9 07:01:43 2005
12:08:05 <SamB> shapr: get anywhere?
12:08:11 <ibid> lambdabot doesn't seem to respond to CTCP TIME
12:08:25 <shapr> SamB: I got distracted :-)
12:08:46 <SamB> shapr: ah
12:09:00 <SamB> shapr: you could at least send me a copy of that torrent
12:10:02 <astrolabe> dons' time looks weird to me
12:10:33 <astrolabe> How can it be 1 minute past when ibid's was 6 minutes past.
12:10:35 <astrolabe> ?
12:10:54 <integral> local time?
12:10:59 <SamB> @localtime dons
12:10:59 <lambdabot> Local time for dons is Wed Nov  9 07:05:08 2005
12:11:02 <basti_> astrolabe: its the PC's clocks, not UTC+x
12:11:03 <SamB> @localtime ibid
12:11:04 <lambdabot> Local time for ibid is Tue Nov  8 22:10:41 2005
12:11:08 <shapr> @localtime shapr
12:11:09 <lambdabot> Local time for shapr is Tue Nov  8 21:10:46 2005
12:11:20 <shapr> I think dons isn't using ntpd.
12:11:30 <SamB> @localtime SamB
12:11:40 <astrolabe> basti: ah ha
12:11:40 <lambdabot> Local time for SamB is Tue Nov  8 15:14:16
12:11:59 <SamB> shapr: or his clock drifted off and it wouldn't sink
12:12:05 <shapr> could be
12:12:06 <SamB> *synch
12:12:12 <astrolabe> @localtime astrolabe
12:12:13 <Igloo> Is there a lambdabot test channel?
12:12:14 <lambdabot> Local time for astrolabe is Tue Nov 08 20:11:40 2005
12:12:25 <astrolabe> :)  Sorry igloo
12:12:29 <SamB> haskell-overflow?
12:12:38 <shapr> But, if you have ntpdate and ntpd running, then ntpdate is executed on startup and ntpd corrects the drift after that.
12:12:39 <Igloo> Oh, that wasn't actually a complaint, I want to test something
12:12:56 <astrolabe> Igloo: you can /msg it I think
12:13:06 <shapr> Yeah, or #haskell-overflow
12:13:10 <astrolabe> ( her)
12:13:18 <SamB> when I try to run ntpdate, it complains that no servers can be used...
12:13:49 <shapr> You need to find your local ntpd servers.
12:13:55 <shapr> I found some nice tier 3 servers nearby.
12:14:17 <SamB> shapr: how do you do that?
12:14:31 <integral> or you can just use <2-letter-country-code>.pool.ntp.org
12:14:34 <shapr> Look on the ntp server lists.
12:15:57 <ricebowl> heh, you can also use time.windows.com ;)
12:16:00 <ricebowl> /leech
12:16:12 <ricebowl> but MS's servers aren't as good as my local ones
12:16:25 <SamB> windows uses NTP for that?
12:16:30 <ricebowl> yes
12:16:31 <SamB> I had no idea!
12:16:41 <wilx> Windows is l33t OS.
12:16:51 <ricebowl> well, I run an NTP server on my LAN and sync all the Windows boxen to it
12:16:55 <ricebowl> they've had SNTP for a while
12:19:00 <ricebowl> anyway, in XP Pro and above it comes enabled by default and syncs to MS's servers, and they don't check to make sure you've got a Windows client
12:19:29 <ricebowl> initially I had my ntp server syncing to theirs...figured nobody would complain to have 1 box syncing instead of like 10
12:21:03 <dcoutts> gour, not yet
12:21:19 <gour> dcoutts: ok
12:22:04 <SamB> @localtime shapr
12:22:05 <lambdabot> Local time for shapr is Tue Nov  8 21:21:42 2005
12:22:37 <ricebowl> man, the box that I'm on loses like 2 minutes per day :/
12:23:38 <shapr> What're the units for ntp.drift?
12:24:59 <Frederick> yo folks
12:25:29 <JKnecht> yo Frederick
12:29:37 <ricebowl> um, weird
12:29:48 <ricebowl> I'm using GHCi, :load myfile.hs
12:29:51 <ricebowl> which imports another
12:30:11 <ricebowl> the other file is in the same directory, and I *think* GHCi is trying to find it in another directory
12:32:21 <shapr> :set -i$DIRECTORY
12:32:46 <shapr> Or, :cd $DIRECTORY
12:32:50 <shapr> but you'll need to reload after that.
12:34:35 <ricebowl> shapr - I did :cd
12:34:56 <ricebowl> hm, you *have* to do a reload? It said they would be automatically reloaded
12:35:06 <araujo> Ok, i think i saw it!
12:35:10 * araujo giggles
12:35:40 * araujo throws honey lambdas at everyone
12:38:36 <ricebowl> heh, oh well, got it to work
12:38:54 * xerox yummys a flying honey lambda
12:41:17 <araujo> hi xerox !
12:41:19 <araujo> :-)
12:41:43 <xerox> Howdy!
13:08:56 <dons> @yow
13:08:56 <lambdabot> Yow!  Am I having fun yet?
13:11:23 <tumm> @arr
13:11:24 <lambdabot> Yeh scurvy dog...
13:26:43 <boegel|home> TheHunter: you got another feedback thingie on your TMR article in issue 2
13:27:00 * TheHunter looks.
13:28:56 <ulfdoz> "where" is not allowed in lamdas?
13:29:10 <dons> where is not an expression form
13:29:17 <dcoutts> "where" is part of a decleration
13:29:25 <dcoutts> a lambda is just an expression
13:29:47 <dons> many people complain about this. but you can always use 'let' instead
13:30:08 <dcoutts> let and where are mostly interchangable
13:30:08 <TheHunter> hey dons
13:30:19 <musasabi> You can have let x = foo where foo = bar in x
13:30:31 <dons> heya TheHunter
13:30:32 <dcoutts> but let is in an expression context and where is in a decleration context
13:30:54 <CosmicRay> guess what everybody.
13:30:57 <dons> > let x = y where y = 7 in x
13:30:58 <CosmicRay> hwn will be out on time today.
13:30:58 <lambdabot> 7
13:30:59 <CosmicRay> ;-)
13:31:05 <boegel|home> CosmicRay: yaay !
13:31:07 <dons> @karma+ musasabi
13:31:07 <lambdabot> musasabi's karma raised to 5.
13:31:09 <CosmicRay> :-)
13:31:11 <boegel|home> CosmicRay: are you sending it now ?
13:31:18 <dons> @karma+ CosmicRay
13:31:18 <lambdabot> CosmicRay's karma raised to 3.
13:31:20 <CosmicRay> in about 20 minutes
13:31:23 <TheHunter> > y where y = 7
13:31:24 <lambdabot> 7
13:31:25 <SyntaxNinja> @karma SyntaxNinja
13:31:25 <lambdabot> You have a karma of 1
13:31:26 <CosmicRay> woo, I had no idea I had positive karma ;-)
13:31:29 <SyntaxNinja> I don't get no respect
13:31:29 <boegel|home> CosmicRay: you should mention my little project!
13:31:37 <boegel|home> CosmicRay: if you have time that is:)
13:31:45 <CosmicRay> boegel|home: which little project do you mean?
13:31:53 <boegel|home> CosmicRay: http://haskell.org/tmrwiki/TopTenHaskell
13:32:04 <CosmicRay> oh right!
13:32:06 <CosmicRay> just saw that
13:32:09 <CosmicRay> I will.
13:32:29 <boegel|home> cool, thanks man!
13:33:14 <boegel|home> Igloo: posting works now, it's indeed the 'From' part of the email that gets checked, caused some problems with my configuration
13:39:59 <reddi_> are there no people in?
13:40:17 <ibid> sorry, we are fresh out of people
13:40:26 <reddi_> i only see 2
13:40:28 <reddi_> hm....
13:40:32 <SyntaxNinja> and one of them is a bot
13:41:03 <reddi_> anyway!
13:41:08 <reddi_> i have a small problem
13:41:12 <dons> hmm
13:41:29 <dons> I have: Total of 190 nicks
13:41:32 <SyntaxNinja> we solve problems, because we are problem solvers. </gwb>
13:41:41 <reddi_> http://pastebin.com/422286
13:41:51 <SyntaxNinja> dons: that's a little obsessive
13:41:57 <dons> hehe
13:41:57 <reddi_> makeindex shall output [1,2]
13:42:19 <reddi_> as u can see in the line 1 it gives out the name with index 1 and 2
13:43:19 <reddi_> and if i use makeindex which uses kandidathatminerstestimmen [so it gets judy hall and john doug] i get 0,1 instead (but i need 1,2)
13:43:52 <SyntaxNinja> what's this [x | x <- map ...] business? you don't need the list comp there
13:44:28 <SyntaxNinja> @eval [x | x <- [1,2,3]]
13:44:29 <lambdabot> [1,2,3]
13:44:51 <dons> I think everyone should move to the new literate @eval. it's nicer on the brain for some reason:
13:44:55 <dons> > [x | x <- [1,2,3]]
13:44:56 <lambdabot> [1,2,3]
13:45:10 <SyntaxNinja> > [x | map (+1) [1,2,3]]
13:45:11 <lambdabot>  Not in scope: `x'
13:45:17 <SyntaxNinja> errr
13:45:24 <SyntaxNinja> > [x | x <- map (+1) [1,2,3]]
13:45:25 <lambdabot> [2,3,4]
13:45:33 <SyntaxNinja> > map (+1) [1,2,3]
13:45:35 <lambdabot> [2,3,4]
13:45:43 <SyntaxNinja> dons: yes, it's quite nice.
13:45:49 <reddi_> i want to use elemindices for every element of the resulthatminerstestimmen with the full list
13:45:58 <reddi_> so i have to use map
13:46:13 <musasabi> > v = let x = tail x in head x
13:46:13 <lambdabot>  parse error on input `='
13:46:26 <musasabi> > let x = tail x in head x
13:46:26 <lambdabot> Add a type signature
13:46:39 <musasabi> > let x = tail x in head x :: Int
13:46:40 <lambdabot> Loop
13:46:43 <musasabi> bah
13:46:55 <musasabi> no simple overflows then
13:47:16 <reddi_> where is my thinking error?
13:47:24 <SyntaxNinja> reddi_: oh, sorry, your list comp is fine; didn't notice the condition
13:48:11 <reddi_> do u understand what i want to do?
13:48:22 <dons> musasabi, what were you trying to do?
13:48:42 <SyntaxNinja> reddi_: no, what is the mess of numbers that's the 2nd argument to makeIndex?
13:49:46 <reddi_> what do mean with mess?
13:50:13 <SyntaxNinja> what is the 2nd argument?
13:50:20 <SyntaxNinja> stimmzettel?
13:50:29 <reddi_> yes
13:50:33 <SyntaxNinja> what does it mean
13:51:13 <reddi_> it is a list of lists, u dont have to care about it - kandidathatminerstestimmen has to use it
13:51:17 <ski> (pesco : that cat theory book is quite nice ..)
13:51:25 <ski> Si\Uni : yes
13:51:26 <dons> yay, HWN arrives. And it's coffee time too :)
13:51:52 <reddi_> and kandidathaterstestimme returns as u can see in line 2 a PART of wahlvorschlag
13:52:15 <reddi_> and i want to know WHICH part of wahlvorschlag (in indexes) this is
13:53:28 <reddi_> do u understand my problem now?
13:53:58 <reddi_> i have a programm arround this and i have found out that the return values of makeindex ar wrong
13:55:11 <reddi_> does makeindex something else than elemIndices "Judy Hall" ["John Smith","Judy Hall","John Doug"], elemIndices "John Doug" ["John Smith","Judy Hall","John Doug"]  ------> [1,2]
13:55:19 <reddi_> that is what i want to do ;-)
13:55:40 <SyntaxNinja> right
13:55:55 <reddi_> but somehow i get as an return value [0,1]
13:56:19 <reddi_> and as u can see kandidathatminerstestimmen is not the error (see line 1)
13:58:39 <ski> 'null(x)==False' is better written 'not (null x)'
13:59:28 <SyntaxNinja> reddi_: you're lookin gup the index in the output of kandi...
13:59:48 <SyntaxNinja> right?
13:59:51 <reddi_> yes
13:59:56 <SyntaxNinja> er, it's confusing the way you have it written with ticks
14:00:13 <reddi_> how would u write it? i have to use map and i have to use elemindces i think?
14:00:27 <SyntaxNinja> but basically you're mapping over the lists in the wrong place
14:00:34 <SyntaxNinja> I think.
14:00:58 <SyntaxNinja> try replacing the lists with what you expect to be there at that moment, and I would use lambda instead of ticks and such to clarify it.
14:01:23 <SyntaxNinja> @type elemIndex
14:01:24 <lambdabot> Not in scope: `elemIndex'
14:01:31 <SyntaxNinja> @type Data.List.elemIndex
14:01:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
14:01:47 <SyntaxNinja> @type Data.List.elemIndicies
14:01:48 <lambdabot> Not in scope: `Data.List.elemIndicies'
14:01:59 <SyntaxNinja> @type Data.List.elemIndices
14:01:59 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
14:02:31 <reddi_> i dont know befor what i want to get, this depends on the result of kandidathatminerstestimmen
14:02:36 <SyntaxNinja> > map (`Data.List.elemIndices` [1,2]) [1,2]
14:02:37 <lambdabot> [[0],[1]]
14:02:48 <reddi_> and of course of the value of wahlzvorschlag
14:03:15 <SyntaxNinja> plug in dummy values into ghci to see what the program outputs for subexpressions
14:03:21 <SyntaxNinja> like I just did
14:03:38 <SyntaxNinja>  > map (`Data.List.elemIndices` [1,2]) [2,1]
14:03:49 <SyntaxNinja> > map (`Data.List.elemIndices` [1,2]) [2,1]
14:03:50 <lambdabot> [[1],[0]]
14:05:27 <reddi_> the problem is that i am now! not familar with lamdba (this will come in the course later i think ;-()
14:05:34 * ski wonders if reddi_ expected one-based indexing, but program gave zero-based indexing ..
14:05:38 <SyntaxNinja> reddi_: OK.
14:05:49 <SyntaxNinja> ski: no. reddi_ has the arguments mixed up
14:05:58 <ski> hm, ok
14:06:06 <reddi_> ski: i have tried the +1 variant ;-)
14:06:13 <reddi_> but there is something wrong
14:06:39 <ski> reddi_ : are you saying 'kandidathatminerstestimmen' works, but 'makeIndex' doesn't ?
14:06:51 <SyntaxNinja> reddi_: you want to find the index in the ORIGINAL list, not the kandid... list
14:07:09 <reddi_> YES
14:07:34 <reddi_> the orginal list is the bigger one
14:07:38 <RemiTurk> hi to all
14:07:41 <SyntaxNinja> but currently, you're getting the indexes of the wrong list.
14:08:07 <ulfdoz> Hm, stupid task  was to implement modulo operation with finite-state automaton on decimal numbers represented as strings. Result is really huge memory consumptions with strings of length ~10
14:08:15 <SyntaxNinja> you want indexOf smallList bigList, basically, but you've got it written as indexOf bigList smallList. you'd see an error, but you're throwing away the null.
14:08:38 <reddi_> mom, i change the order
14:08:48 <SyntaxNinja> mom?
14:09:10 <pesco> ski: Did you know it before?
14:09:30 <reddi_> one moment
14:09:49 <ski> pesco : yes, i have borrowed and read part of it, in paper-form
14:10:03 <pesco> Ah, cool.
14:11:16 <reddi_> i get the same values
14:11:19 <ski> (many examples are from algebra or topology or algebraic topology, though)
14:11:22 <reddi_> [0,1]
14:11:51 <SyntaxNinja> let's see your new code
14:12:15 <reddi_> SRY
14:12:16 <pesco> ski: Hm, okay.
14:12:16 <reddi_> my fault
14:12:22 <reddi_> i have copied the method
14:12:25 <reddi_> with another name
14:12:30 <reddi_> and i changed the older one
14:12:46 <reddi_> i will test the rest of my programm out ;-)'
14:12:49 <reddi_> thx for now
14:13:10 <SyntaxNinja> :)
14:23:14 <SamB> @seen jlouis
14:23:14 <lambdabot> jlouis is in #haskell. I don't know when jlouis last spoke.
14:23:14 <dons> I switched @seen to a binary state format yesterday. so the 'last spoke' data got wiped (too hard to convert text to binary with sed!)
14:23:14 <SamB> dons: yes, I know you did, and I figured out that the data got wiped
14:23:14 <SamB> I'
14:23:14 <integral> dons: use perl not sed! :P
14:23:15 <SamB> ve been doing that like all day
14:23:15 <dons> SamB :)
14:23:15 <dons> you've been doing what all day?
14:23:15 <dons> integral, bah.
14:23:15 <SamB> dons: @seen jlouis
14:23:15 <dons> ah.
14:23:25 <SamB> @seen me
14:23:25 <lambdabot> I haven't seen me.
14:23:43 <SamB> @seen SamB
14:23:44 <lambdabot> You are in #haskell-blah, #haskell-overflow and #haskell. Last spoke just
14:23:44 <lambdabot> now.
14:24:04 <SamB> @seen dons
14:24:04 <lambdabot> dons is in #haskell-overflow and #haskell. Last spoke 1 minute and 23
14:24:04 <lambdabot> seconds ago.
14:24:06 <dons> SamB, i'm heading towards a lambdabot release, I think. so anything you want in v3.1 you should send before the end of the week, I think.
14:24:25 <SamB> dons: why doesn't it handle me? in case someone comes along with that for a nick?
14:24:34 <SamB> dons: I care not for releases
14:24:37 <dons> :)
14:25:57 <SamB> also, why does lambdabot bother to remember when someone spoke, but not where or what was said?
14:25:58 <Frederick> guys can I ave some help with parsec and chainr?
14:26:40 <dons> SamB, that would be a lot of info
14:26:47 <dons> is there anything useful we could do with it?
14:26:53 <dons> besides *evil things*
14:26:55 <dons> mwhahaha
14:27:13 <SamB> dons: it would be nice if lambdabot would at least remember where it was spoken
14:28:13 <dons> yeah, I like that idea.
14:28:31 <dons> @todo-add it would be nice if lambdabot would at least remember where someone last spoke
14:28:31 <lambdabot> Entry added to the todo list
14:29:10 <SyntaxNinja> haskell sequence must have got slashdotted. it seems down
14:29:48 <malcolm_> how can we cheer it up?
14:33:02 <dons> @seen lambdabot
14:33:02 <lambdabot> module "seen" screwed up: I'm here, but not here. And very confused!
14:33:08 <xerox> 'night folks!
14:33:12 <dons> @quit try again
14:33:20 <dons> @seen lambdabot
14:33:30 <lambdabot> Yes, I'm here. I'm in #gentoo-haskell, #haskell-overflow, #haskell-blah
14:33:32 <lambdabot> and #haskell
14:33:38 <dons> @get-shapr
14:33:39 <lambdabot> shapr!!
14:33:40 <dons> :)
14:33:43 <basti_> lol
14:33:47 <SyntaxNinja> malcolm_: heh
14:33:47 <basti_> whats THAT?
14:34:09 <dons> an often requested command :)
14:34:15 <xerox> Someone went trough the todo list :D
14:34:18 <dons> maybe it should use ctcp ping though
14:34:20 <dons> yep
14:34:34 <dons> @version
14:34:35 <lambdabot> lambdabot 3p180, GHC 6.5.20050806 (Linux i686)
14:34:35 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:34:37 <xerox> Bye bye.
14:34:41 <dons> night xerox
14:36:24 <lisppaste2> Frederick pasted "What is wrong?" at http://paste.lisp.org/display/13347
14:36:40 <basti_> 13347? that is almost LEET!
14:36:59 <basti_> Frederick: whats the error?
14:37:02 <Frederick> guys i still trying parsec out :p please help me put :)
14:37:04 <Frederick> *out
14:40:44 <Frederick> basti_, may I post error in pvt for you?
14:41:02 <lisppaste2> Frederick pasted "error output" at http://paste.lisp.org/display/13348
14:41:07 <Frederick> done
14:42:26 <basti_> that seems to be caused by a erroneous call
14:42:38 <Frederick> basti_, wich would be the right call?
14:42:46 <basti_> I do not know a lot about parsec i'm sorry
14:42:53 <Frederick> Ive loaded the source Ive showed you
14:42:54 <basti_> it's probably written in the tutorials though
14:43:28 <Frederick> http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html Im trying sequence and choice
14:43:33 <Frederick> this is the first exercise
14:45:59 <malcolm_> Frederick: don't you need something like parse parens "(())"?
14:47:08 <ulfdoz> @hoogle [Char] -> [a]
14:47:09 <lambdabot> Data.List.tail :: [a] -> [a]
14:47:09 <lambdabot> Data.List.init :: [a] -> [a]
14:47:09 <lambdabot> Data.List.reverse :: [a] -> [a]
14:47:25 <Frederick> malcolm_, lemme try
14:47:38 <dons> ulfdoz? that's a weird type you describe.
14:47:57 <dons> a String to [a] function is an evaluator, usually
14:48:28 <basti_> Frederick: practically no programmer who doesn't have long experience with a certain thing will be able to tell you wha to type -exactly-. The hints we're giving are intended to be helpful though, and might turn out as being such
14:48:30 <ulfdoz> dons: Actually I want String -> [Int]
14:48:59 <dons> @type map Char.ord
14:49:00 <lambdabot> [Char] -> [Int]
14:49:06 <Frederick> basti_, sure
14:49:18 <dons> @type Char.ord
14:49:19 <lambdabot> Char -> Int
14:49:29 <Frederick> malcolm_, Ive tried with runs parens "(())()"
14:49:34 <Frederick> as described in the sample
14:49:43 <ulfdoz> dons: That's the part I have, but I need to filter the character as only digits are allowed.
14:49:55 <Frederick> <interactive>:1: Variable not in scope: `run'
14:50:17 <dons> @type map Char.ord . filter Char.isDigit
14:50:18 <lambdabot> [Char] -> [Int]
14:50:30 <Frederick> malcolm_, this was my fault
14:50:37 <Frederick> I havent copied the definition of run
14:50:47 <dons> > map ord . filter isDigit $ "123xyz456abc"
14:50:48 <lambdabot> [49,50,51,52,53,54]
14:51:08 <ulfdoz> dons: I searched for a smarter way, as I return Maybe Int. So I want to include handling of letters in the function it self, but that seems to need some redesign.
14:51:34 <dons> so rather than map ord, you might want a fold
14:51:47 <dons> if you're trying to combine the ord with the filter
14:54:20 <ulfdoz> dons: and . map look
14:57:01 <Frederick> is a variable unitialised in haskell set to default value 0?
14:57:23 <ski> no
14:57:30 <ski> variables are not uninitialized
14:57:42 <dons> how can you create an uninitialised variable in the first place, Frederick?
14:57:49 <Frederick> heya ski
14:57:55 <Frederick> dons, I didnt created
14:58:02 <Frederick> brb lemme dinner and I come back
14:58:04 <dons> it's not possible, anyway.
14:58:11 <ski> if you didn't create it, then it doesn't exist
14:58:18 <musasabi> You can have bottom.
14:58:29 <musasabi> Like undefined or error "foobar"
15:01:46 <tbfg> I've a strange probleam (and i'm a haskell newbie, so who knows)
15:02:08 <tbfg> i've a function with an otherwise = branch
15:02:19 <ski> ok
15:02:45 <tbfg> and the value returned by this branch differs from calling the function called there directly
15:03:10 <tbfg> which confuses me a lot
15:03:20 <tbfg> its ident in ghci and hugs
15:04:04 <Lemmih> Got the code pasted somewhere?
15:04:13 <tbfg> Lemmih no still not
15:04:29 <ski> lisppaste2: url
15:04:29 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:04:37 <ski> you can e.g. use that
15:05:01 <joelr_> gents,
15:05:07 <lisppaste2> tbfg pasted "otherwise problem" at http://paste.lisp.org/display/13351
15:05:15 <dons> hey joelr, how's code?
15:05:24 <tbfg> cool bot!
15:05:28 <joelr_> given infixr 2 :*: and infixr 4 :=:
15:06:04 <joelr_> how does Tkey :=: Attribute AnimalId SqlInteger :*: ... parse?
15:06:11 <tbfg> Lemmih the problem occures as soon as the arguemnts for pascalTriangle are >= 13
15:06:21 <dons> joelr_ you can dump ghc's parse tree, to check
15:06:26 <dons> -ddump-parse, iirc
15:06:27 <joelr_> oh, also type l :=: v = (l,v)
15:06:41 <joelr_> no, what i mean is how does it get associated
15:06:44 <tbfg> Lemmih pascalTriangle 13 13 works, pascalTriangle 14 14 not
15:07:06 <joelr_> is it a tuple of (TKey, Attribute AnimalID SqlInteger)?
15:07:37 <joelr_> i.e. does infixr 4 have higher priority, so to speak, than infixr 2?
15:08:15 <dons> higher priority binds first
15:08:15 <Lemmih> tbfg: How does it not work?
15:08:28 <joelr_> cool, thanks dons
15:08:30 <tbfg> Lemmih the values are not the ones expected
15:08:46 <dons> seriously, dump the parse tree, which will disambiguate it all
15:08:52 <joelr_> i'm thinking of going with the extensible records from HList for my purposes
15:09:14 <tbfg> Lemmih try this: appendPascalLines 14 14 vs pascalTriangle 14 14 which shoudl be tha same
15:09:19 <joelr_> dons: how do you dump a parse tree? ah, i see you already answered that, thanks
15:09:36 <Lemmih> *Main> appendPascalLines 14 14 == pascalTriangle 14 14
15:09:36 <Lemmih> True
15:09:56 <wchogg> Stupid question, but for someone just learning about compilers would Happy or ParSec be easier/more instructive?
15:10:03 <tbfg> Lemmih just print it
15:10:57 <dons> -ddump-parsed I think
15:11:24 <tbfg> Lemmih does the output differ for you ?
15:11:35 <Frederick> back folks
15:11:54 <Frederick> dons, did you see what I mean?
15:12:15 <joelr_> has anyone used HList ?
15:12:27 <dons> e.g.: f = (((=:) . (*:)) . (*:)) . (=:)
15:12:45 <dons> whereas the input was : f = (=:) . (*:) . (*:) . (=:)
15:12:51 <Lemmih> tbfg: Heh. You've actually found a nice corner of Haskell (:
15:12:51 <dons> using: paprika$ ghc -ddump-parsed M.hs
15:13:03 <tbfg> Lemmih it's not nice!
15:13:22 <Lemmih> *Main> appendPascalLines 14 14 :: [[Int]]
15:13:22 <Lemmih> [[1,4,24,88,221,399,532,532,399,221,88,24,4,1]]
15:13:22 <Lemmih> *Main> appendPascalLines 14 14 :: [[Integer]]
15:13:22 <Lemmih> [[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1]]
15:13:36 <tbfg> Lemmih right, thats my problem
15:13:38 <joelr_> dons: thanks!
15:13:49 * joelr_ learns something new every day
15:13:51 <dons> wchogg, hmm. happy is more traditional. Parsec is a different model, but also very interesting
15:14:04 <Lemmih> tbfg: pascalTriangle uses Ints but appendPascalLines defaults to Integer.
15:14:10 <dons> seems to me joelr_- learns about 20 new things a day :)
15:14:21 <dons> since you're already up to HList hacking!
15:14:33 <joelr_> dons: it's not my fault that i need it :(
15:14:54 <joelr_> dons: but haskell has been so hard on me that i hardly have any time for blogging about the experience :-)
15:14:58 <tbfg> Lemmih I don't think so as "normally" the signatures are not commeted out same results
15:15:13 <joelr_> dons: thing is i tried to reinvent what HList does and they just do it better
15:15:16 <Frederick> ski, do you remmember that word I needed to do of matching words in ml ive just done it now im haskell in like 10 mins
15:15:25 <dons> joelr_, i'm at a  bit of a loss, or perhaps a bit concerned, that it has been so hard
15:15:58 <joelr_> dons: it's me, really. every normal person starts slowly and learns along a few easy projects
15:16:13 <joelr_> dons: i had to start from 0 with a difficult project that requires all the difficult stuff
15:16:22 <dons> perhaps coming at it from a python-ish point of view also influences how you think problems should be solved as well
15:16:24 <Lemmih> tbfg: If you uncomment the type-signature for 'appendPascalLines' then it'll work as you expect.
15:16:39 <joelr_> dons: i'd say that's overly ambitions
15:16:46 <joelr_> dons: are you talking to me (pytonish?)
15:16:53 <ski> Frederick : nice
15:16:57 <tbfg> Lemmih I#ve just tried so, no appendPascalLines gives same result as pascalTrangel but wrong values
15:17:03 <dons> oh, I just recall a comment youu made about "should have used python".
15:17:06 <tbfg> Lemmih no == now
15:17:27 <dons> i.e. dynmically typed interpreted language. whereas you're using a statically typed compiled language, so that's quite a different model
15:17:38 <dons> oh, plus it's fp and pure and lazy :)
15:17:38 <tbfg> Lemmih and the values are far away from MAXINT
15:17:40 <joelr_> dons: ah, i have no huge experience with python :) i come from c++, lisp and erlang
15:18:00 <dons> ah, right. ok. that explains some of your rapid progress then :)
15:18:32 <joelr_> dons: http://wagerlabs.com, my blog, categorized by erlang, lisp, trading, poker, etc.
15:18:51 <dons> may the type system be with you :)
15:18:53 <Lemmih> tbfg: You're overflowing an intermediate value.
15:19:10 <musasabi> Haskell code written like it would be Erlang looks very ugly.
15:19:18 <joelr_> dons: thing is that i have been quite successful in getting the project done, considering that i was only  2 weeks late :-) but then i got hit by the lazyness of haskell or something like that
15:19:26 <joelr_> musasabi: i don't try that :-)
15:19:35 <tbfg> Lemmih hmm one of the fact values for sure
15:19:37 <joelr_> it's very easy to do things wrong in haskell
15:19:50 <Cale> certain things anyway :)
15:19:53 <dons> really? how so? can you summarise your experience?
15:20:05 <dons> normally we would say the type system prevents you from doing "wrong" things
15:20:17 <dons> then again, you were FFIing and other advanced tricks, all over the place
15:20:22 <musasabi> Code using functions which really send things to channels (and a confusing web of threads sending messages to each other - with no static reference of each other) and no convenient monad transformers used.
15:20:53 <joelr_> dons: well, i'll surely blog about it but here's a summary
15:21:30 <Frederick> hey guys how do I read <?> I got the semantics of trying both and traceback but how do I call it?
15:21:48 <joelr_> i need to send and receive packets and users need an easy way to deal with them so i took the attr := value thing out of wxHaskell and used lists of such things (properties) to describe records
15:22:01 <tbfg> Lemmih is there a way to "promote" an Int to an Integer ?
15:22:06 <Cale> Frederick: the operator <?> from parsec?
15:22:11 <musasabi> tbfg: fromIntegral
15:22:13 <dons> @hoogle Int -> Integer
15:22:14 <joelr_> so i can have several levels of nesting for this because the c++ records are nested
15:22:14 <lambdabot> System.CPUTime.cpuTimePrecision :: Integer
15:22:14 <lambdabot> Data.Bits.bit :: Bits a => Int -> a
15:22:14 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
15:22:17 <dons> bah.
15:22:20 <Lemmih> @eval product [1..13]
15:22:21 <lambdabot> 6227020800
15:22:23 <Lemmih> @eval product [1..13] :: Int
15:22:24 <lambdabot> 1932053504
15:22:31 <dons> joelr_, also interacting with C++ is tricky
15:22:38 <musasabi> > (romInteger (1 :: Int) :: Integer
15:22:38 <lambdabot>  parse error on input `}'
15:22:40 <joelr_> then i figured that i serialize things differently from how they are stored in haskell
15:22:48 <musasabi> > fromInteger (1 :: Int) :: Integer
15:22:48 <joelr_> dons: it's over sockets
15:22:49 <lambdabot> Couldn't match `Integer' against `Int'
15:23:00 <musasabi> grah
15:23:00 <Frederick> Cale, yup
15:23:00 <Lemmih> tbfg: Just change the signature of pascalTriangle to use Integers.
15:23:01 <joelr_> because the c++ people send everything little-endian, for example
15:23:02 <Cale> > fromIntegral (1 :: Int) :: Integer
15:23:03 <lambdabot> 1
15:23:07 <Lemmih> tbfg: Or use 'fromIntegral'.
15:23:11 <dons> ah, right. how'd you do the serialisation? not with Storable I guess. but FPS?
15:23:12 <tbfg> Lemmih no this siganture is given
15:23:28 <dons> and not with Binary either?
15:23:32 <musasabi> s/fromInteger/fromIntegral/
15:23:36 <joelr_> so i created this class Convertible a b and required that attributes are Attr a b where b is the type that gets stored and a is the Haskell type
15:23:47 <joelr_> then the properties are Attr a b := a
15:23:58 <Cale> Frederick: that gives the parser a name for usage in "expected" messages
15:24:01 <joelr_> and there has to be a Convertible a b
15:24:24 <dons> ok, that's nice. that's a bit like a stronger Storable claaass
15:24:24 <Frederick> Cale, hm thx a lot
15:24:33 <joelr_> dons: not with binary, no, storing everything into fast-strings, building a list of that and then concatenating all the fps
15:24:48 <dons> oh, you know concat is expensive?
15:25:03 <Cale> So if the parser fails without consuming input, that name will show up for the user
15:25:04 <joelr_> what i ended up with, for starters is a lot of boilerplate code to convert things from Word8 to Word8 for example :-)
15:25:25 <joelr_> needed that when the attribute was Attr Word8 Word8 := Word8
15:25:31 <dons> hmm. right.
15:25:35 <joelr_> no one told me concat was expensive
15:25:47 <joelr_> i also did the endian conversion by reversing a fps
15:25:54 <dons> in comparison to the O(1) FPS functions it is expensive.
15:25:58 <joelr_> all in all i built up a working system
15:26:00 <joelr_> but
15:26:00 <dons> it needs to copy and realloc
15:26:20 <tbfg> Lemmih it works now, thanks a lot!
15:26:22 <joelr_> i'm launching, say, 500 threads that connect to the c++ server
15:26:43 <lisppaste2> Frederick pasted "Cant Find ParsecExpr" at http://paste.lisp.org/display/13352
15:26:50 <joelr_> they need to do fancy ssl handshaking for starters but that's all c++ code that is used, calls into openssl to initialize the connection
15:26:52 <dons> ah you able to push the  packed strings straight onto the network without boxing them into String?
15:26:58 <dons> (I hope so)
15:27:01 <musasabi> joelr_: I have some code which writes/reads things from a binary buffer with networking.
15:27:06 <joelr_> after all that, believe it or not the thing is dropped
15:27:07 <Frederick> I cant find parsec expr here, also -v havent worked for me =/
15:27:24 <joelr_> dons: well, you wrote FPS, no? :) you have hPut :)
15:27:31 <Cale> Frederick: Text.ParserCombinators.Parsec.Expr
15:27:36 <dons> ah :) right you are
15:27:42 <joelr_> dons: that pushes a FPS into a handle and also gets stuff from it into a FPS
15:27:54 <joelr_> musasabi: thanks, i have that by now as well
15:27:55 <Cale> try compiling with --make if it fails to find it
15:28:20 <Pseudonym> G'day.
15:28:21 <Cale> (it really shouldn't, given that you're compiling with a relatively recent version of GHC)
15:28:23 <dons> I only rewrote FPS, the original code comes from darcs, via Data.PackedString and a long lineage behind that
15:28:25 <Frederick> Cale, it worked thx a lot
15:28:34 <Cale> no problem
15:28:40 <dons> so in the end the, what, C++ killed you?
15:28:45 <joelr_> so anyway, i'm launching, say, 500 clients in separate threads and everything is swell on mac osx even though the app runs for 5 minutes, spends 50% of the time collecting garbage and moves, say, 3Gb while collecting
15:28:52 <dons> or it didn't kill you. since you say it's a success?
15:28:56 <joelr_> even though the resident size is, say, 40Mb tops
15:29:02 * Frederick is using the last ghc from portage
15:29:07 <joelr_> dons: it's a failure :)
15:29:25 <dons> 3Gb that's so much data.
15:29:28 <joelr_> now, everything is fine on mac osx for whatever reason, maybe because i have 1Gb of memory and 6Gb of VM
15:29:38 <dons> why so much data?
15:30:00 <joelr_> dons: yes, that's a lot of garbage. the packets themselves are quite small so it's all the fancy serialization and unpacking into fps that i'm doing
15:30:08 <joelr_> but then i replaced fps with regular lists and it did not get better
15:30:09 <dons> hmm.
15:30:17 <dons> no I wouldn't expect it to
15:30:27 <musasabi> If you have 500 threads 3000 that means over 5 mb / thread which sounds like a lot.
15:30:34 <joelr_> the issue is that it crashes on windows. i think it happens when there's not enough memory left and the c++ stuff tries to allocate a buffer to initialize a  connection
15:30:43 <joelr_> yes, it's a lot
15:30:44 <musasabi> Are you sure you don't have a lazyness issue?
15:31:10 <joelr_>   Alloc rate    62,623,778 bytes per MUT second
15:31:20 * dcoutts has a lazyness issue
15:31:30 <joelr_> no laziness that i can think of because the resident size is not too high
15:31:41 <musasabi> joelr_: have you looked at the profile - what function allocates much?
15:31:50 <dons> what are the consequences of the failure? you don't get paid? you'd never use haskell again? or is it only a notional failure?
15:31:52 <joelr_> so now i'm behind and the app does not look good on windows which is the client platform
15:32:21 <joelr_> dons: i already got paid in full. said the project was basically working and i needed just one thing to fix. well, who knew it would be this hard?!
15:32:41 <joelr_> musasabi: yes, i looked at profiles and it's the fun that unpickles packets
15:32:55 <SamB> so they get really upset at you and your reputation suffers?
15:33:06 <musasabi> joelr_: can you paste the fun (and the relevant profile) somewhere?
15:33:08 <joelr_> dons: the consequences are a loss of credibility and, potentially, not becoming the head of something big that this particular client seems to have in store for me
15:33:33 <dons> so you're parsing packets from FPS into some boxed, normal haskell values, and there's a lot of memory eaten up?
15:33:44 <joelr_> musasabi: i already did over the weekend, etc. don't have time to do it again. check out the archives from haskell-cafe over the weekend as well
15:33:57 <joelr_> dons: they are not normall haskell values, they are lists of properties
15:34:10 <joelr_> so now i threw away my pickling stuff and went with pickler combinators
15:34:13 <joelr_> so far so good
15:34:17 <joelr_> @google pickler combinators
15:34:18 <lambdabot> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
15:34:27 <dons> oh. interesting.
15:34:27 <joelr_> now i need to redo the way i define my records
15:35:04 <joelr_> i also redid the interface that the user sees to monadify it and hide the internals of the system which worked
15:35:12 <joelr_> so now i need to redo the records
15:35:32 <joelr_> and i discovered hlist today and the fact that they do exactly what i'm doing but better
15:35:57 <dons> complex data arriving in a packed format, i would probably use the Binary class to unpickle/parse, fwiw
15:36:31 <joelr_> dons: i'll try picklers first, they pickle in/from [Word8] in my case but i can easily change that to Ptr
15:36:34 <joelr_> and use Storable
15:36:40 <joelr_> if this proves to be a problem
15:36:47 <dons> which is like Read/Show, for binary data. whereas this pickle combinators sounds more like the  Parsec equivalent of Read/Show.
15:36:58 <joelr_> no i need to build a phantom type Attribute, like they have in the HList paper
15:37:09 <dons> so we often have either a noormal parser based way to solve these problems, or a combinator library way.
15:37:10 <joelr_> @google HList
15:37:11 <lisppaste2> Frederick pasted "Grammar Grammar" at http://paste.lisp.org/display/13353
15:37:11 <lambdabot> http://homepages.cwi.nl/~ralf/HList/
15:37:15 <dons> combinators are easier to hack on
15:37:42 <joelr_> dons: combinators were a godsend in that they let me scrap all the Convertible fromT toT boilerplate
15:38:05 <dons> in fact, I didn't know we had such a binary combinator lib. looks cool
15:38:08 <joelr_> and extensible records from HList seem to fit the bill
15:38:11 <Frederick> guys after reading parsecagain ive corrected a few bugs ive found in my grammar grammar (a grammar that checks if the given input is really a grammar) now I would like to know if you could help me out in how can I refer to a given rule ive created
15:38:12 <dons> ah yes. no boilerplate
15:38:17 <joelr_> but
15:38:34 <joelr_> i need to bridge HList and pickler combinators
15:38:36 <dons> so you couldn't automatically derive the Convertible class.
15:38:41 <dons> hmm. hard.
15:39:02 * dons has visions of joelr emails to come..
15:39:03 <dons> :)
15:39:07 <joelr_> no, could not because i could have a Word32 value on one end and Endian Word32 to store it as
15:39:21 <dons> hmm. yes. endianess makes this harder.
15:39:25 <dons> excellent piont
15:39:39 <joelr_> alternatively, i could have [Prop] in the Haskell world and store it as list word32 byte, meaning length as word32 and each element as byte
15:39:43 <dons> a derivable, endian-neutral Binary class would be nice for Haskell 1.6
15:39:53 <joelr_> or length could be word8 and the type word64, whatever
15:40:06 <SamB> dons: I endian-neutral?
15:40:11 <joelr_> lots of boilerplate code with convertible, probably leading to lots of garbage
15:40:15 <SamB> but what if I need this or that endian?
15:40:23 <dons> yes. then that's hard.
15:40:26 <joelr_> having to convert from a list of word64 into the haskell list of props for example
15:40:41 <dons> but we could at least ensure that Binary get/put didn't worry about endianess
15:40:43 <joelr_> now to bridge HList and picklers
15:41:22 <joelr_> they have this a :=: b thing in HList which builds a tuple (a, b) and they have :*: to join the record fields
15:41:29 <dons> the good thing about Binary is that DrIFT - the auto class deriver - can derive the code for us.
15:41:48 <joelr_> what i need is a phantom Attribute type like they did in the HList paper for SQL columns
15:42:10 <joelr_> Attribute would associate the haskell type with the pickler
15:42:19 <dons> this code of yours, joelr, may be the most high-end haskell app written yet
15:42:31 <dons> seems like a few research papers are ending up in the code :)
15:42:42 <joelr_> Tkey :=: Attribute AnimalId SqlInteger :*:
15:42:46 <dons> anything that combines FFI and HList is fairly cutting edge
15:42:48 <joelr_> like they do on page 9 of the HList paper
15:43:33 <joelr_> dons: yes, indeed. quite a few. just you wait till i'm done with this :-) next project on the plate is collusion detection in poker. techniques pilfered straight from the Dazzle paper
15:43:41 <joelr_> @google haskell ready to dazzle the real world
15:43:42 <lambdabot> http://www.cs.uu.nl/dazzle/f08-schrage.pdf
15:43:44 <joelr_> he
15:43:54 <lisppaste2> Frederick pasted "CFG" at http://paste.lisp.org/display/13354
15:44:07 <musasabi> http://youzen.ext.b2.fi/~musasabi/lumikko/lib/ has one kind of quite optimized serialization/deserialization that I am usually using for binary data with a given format.
15:44:34 <joelr_> in this Tkey :=: Attribute AnimalId SqlInteger :*:, see how they associate the haskell type AnimalId with SqlInteger which is the sql type?
15:44:48 <dons> musasabi, wherre the format is determined outside of haskell?
15:44:53 <joelr_> I'll try to do the same but SqlInteger is gonna be my pickler
15:44:54 <musasabi> dons: yes.
15:45:13 <musasabi> dons: DNS server, NTP client and other such stuff.
15:45:25 <joelr_> and i need to do it tonight to see if i get any improvement in memory usage
15:45:52 <joelr_> because the "scripts" get stuck for the client for something like 2 minutes from time to time and i think it's due to garbage collection
15:45:59 <dons> musasabi, are you at the point where you can just define the data type in haskell, and mostly mechaniically produce a parser from the external type to the haskell one?
15:46:04 <Frederick> any ideas for me?
15:46:11 <musasabi> joelr_: if you are in a hurry it might be faster to write the instances you want by hand with good combinators.
15:46:16 <dons> joelr_, you know how to collect GC stats?
15:46:34 <joelr_> dons: oh, yeah, spent a weekend on that with the help of kind folks from this channel
15:46:40 <dons> right.
15:46:43 * joelr_ learned 40 things over the weekend
15:46:48 <joelr_> two days, 20 things per day :D
15:47:10 <musasabi> dons: well I have code to go from a Haskell datatype to the mechanical representation, but most of the time there are extra checks to be made, so I end up writing the code by hand.
15:47:38 <dons> is it fairly easy though musasabi, in the style of instance Binary Foo where get .. ; put ..
15:47:42 <dons> ?
15:47:42 * Frederick needs to learn 100 things today
15:48:05 <SamB> Frederick: which 100 things?
15:48:10 <joelr_> with that said, let me get back to the project. need to try my best to complete it by this morning
15:48:11 * dons thinks we're in need of some standard binary / foreign binary library(s)
15:48:17 <joelr_> @localtime joelr_
15:48:21 <lambdabot> Local time for joelr_ is Tue Nov  8 23:47:56 2005
15:48:25 <dons> hack hack hack!
15:48:27 <Frederick> SamB, I still trying to accomplish that grammar work
15:48:48 * joelr_ is now on the map of #haskell users 
15:48:59 <joelr_> smack near the north-western end of africa
15:49:00 <joelr_> he
15:49:08 <Frederick> SamB, rules of productions are checked right now but I dont know how to refer to them
15:49:14 <joelr_> across the western sahara desert
15:49:20 * Frederick needs to acces given rules
15:49:20 <dons> and you've looked at the ways to tune the GC?
15:49:38 <musasabi> dons: I have explicit types which is more suitable to hard wire format.
15:49:39 <Frederick> dons, what do you mean?
15:49:54 <dons> joelr_, for example, +RTS -c (I think) to use the compacting gc algo.
15:50:01 <ulfdoz> I use Char.isDigit (qualified) in an *.lhs. ghci complains with "Not in scope: `Char.isDigit'". What do I miss?
15:50:21 <joelr_> dons: nope, no optimizing gc yet
15:50:22 <dons> joelr_, "compaction algorithm is slower than the copying algorithm, but the savings in memory use can be considerable.
15:50:32 <joelr_> dons: is that described somewhere?
15:50:37 <musasabi> dons: e.g. you would write putFoo (Foo x y) = putWord32 x >> putWord16list y
15:50:47 <dons> in the GHC users's guide,  section 4.14.1.
15:50:57 <joelr_> dons: ok, thanks don
15:51:08 <dons> you can also have the compacting algo kick in after a certain heap pressure is reached
15:51:18 <dons> -cN%
15:51:18 <Frederick> SamB, can you give me a hand on it?
15:51:20 <SamB> Frederick: do you return them?
15:51:25 <joelr_> i will surely be back
15:51:26 * joelr_ rides into the sunset
15:51:28 <Frederick> SamB, nope
15:51:31 <musasabi> dons: which is because I don't want my wire formats to change when I happen to cahnge a datastructure definition (a compile time error is nicer than debugging binary protocols on wire)
15:51:32 <SamB> Frederick: what have you got?
15:51:37 <Frederick> SamB, Im storing them on a list
15:51:51 <SamB> Frederick: let me see your code
15:51:58 <dons> musa, good piont
15:52:03 <Frederick> SamB, http://paste.lisp.org/display/13354
15:54:10 <SamB> Frederick: but how do you parse?
15:55:12 <Frederick> SamB, by the momment all I want to know if the given grammar is valid parsing words is the last part of the work now I need to put his grammar in chomkys and greibachs normal form
15:56:14 <SamB> Frederick: I don't see any parsers here
15:56:49 <Frederick> SamB, this is just a grammar grammar if you input a grammar it will check if it has the right syntax
15:59:33 <Frederick> SamB, did you get what I mean?
15:59:42 <ulfdoz> How does this fit? http://www.rafb.net/paste/results/oSKv4y48.html
16:00:39 <SamB> Frederick: I don't really understand it
16:00:55 <Frederick> SamB, do you know what is a CFG?
16:01:08 <SamB> there doesn't actually seem to be any code, just types and a piece of data
16:01:34 <Frederick> SamB, are you familiar with context free-grammars?
16:02:07 <SamB> Frederick: not really
16:02:43 <SamB> Frederick: so what do you want to do with this?
16:03:17 <Frederick> SamB, 1 sec lemme open a link to show you
16:03:34 <Frederick> SamB, http://en.wikipedia.org/wiki/Context_free_grammars
16:05:05 <Frederick> SamB, im trying to do a grammar to check if the input is a grammar
16:05:49 <SamB> Frederick: won't you need to first write code that does something?
16:06:24 <Frederick> SamB, how can I write code that does something if I dont have some input before to do something?
16:07:29 <SamB> Frederick: well, how am I supposed to understand your datastructures without code that takes them apart and uses them?
16:08:07 <Frederick> SamB, sorry Ihad missunderstand you. Lemme explain
16:09:44 <Frederick> ive defined a CFG as a set of terminals that can be symbols that are terminals ot non terminals, a Production that is a Name Associeted to the mappyng of a Simbol to another, |-> is like an "overloaded" operator taking a variable into its productions
16:11:48 <Frederick> ski, heya
16:12:16 <SamB> Parsing Expression Grammars (http://en.wikipedia.org/wiki/Parsing_expression_grammar) remind me of Parsec...
16:12:39 <Frederick> SamB, that is why I did all parsec samples
16:13:43 <Frederick> SamB, but I still with some dificulties since Im new to haskell
16:14:31 * Frederick runs to the kitchen to take some juice
16:14:45 <SamB> Frederick: how about you try something more concrete first?
16:16:37 <Frederick> SamB, what do you mean? ive done all tutorials in the website
16:17:16 <SamB> Frederick: like write code that does things
16:17:34 <SamB> things that everyone else can understand
16:17:49 <Frederick> SamB, IM trying but how can I write a code that does things if I dont know how to give the proper input?
16:17:57 <SamB> then it might be easier to help you with them ;-)
16:18:11 <stepcut> I realized that I have been writing haskell for 3+ years -- yet I have practically no programs to show for it :-/
16:18:47 <SamB> Frederick: write a lambdabot module!
16:18:55 <dons> stepcut :}
16:19:05 <SamB> @todo
16:19:05 <lambdabot> 0. SamB: A way to get multiple results from a google search
16:19:05 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
16:19:05 <lambdabot> 2. SamB: stop mangling long urls
16:19:05 <lambdabot> 3. dons: improve formatting of @dict
16:19:05 <lambdabot> 4. dons: write Haskell Manifesto
16:19:05 <araujo> Hello!
16:19:07 <lambdabot> [14 @more lines]
16:19:22 * araujo wonder what stepcut has been writting
16:19:29 <Frederick> SamB, Im not here for joking I really need to accomplish this wokr
16:19:44 <SamB> @more
16:19:45 <lambdabot> 5. lispy: don't let lambdabot's prettyprinter split the sequence @foo
16:19:45 <lambdabot> across lines
16:19:45 <lambdabot> 6. TheHunter: priviledged users should get priviledged listcommands.
16:19:45 <lambdabot> 7. TheHunter: @type 1 :: Int
16:19:45 <lambdabot> 8. lispy: haddock gives a link from a type signature to the types.  It
16:19:47 <lambdabot> [9 @more lines]
16:20:06 <SamB> Frederick: Well I don't understand the relationship between your questions and your code
16:20:18 <stepcut> araujo: I think I just keep reading white papers, and trying to implement higher and higher level code, but I never get around to actually writing something complete
16:20:19 <Frederick> maybe if I accomplish this work I can help with lambda bot using the magic skillz I will have :p
16:20:30 <Frederick> SamB, do you see where I check it the given expr is a grammar?
16:20:44 <dons> anyone know an mp3 player/front end written in haskell?
16:21:11 <araujo> stepcut, yeah, you can spend quite a time doing that. That isn't bad at all.
16:21:16 * dons thinks all the curses-baesd ones he's tried aren't nice
16:21:24 <SamB> Frederick: no. I see where you define expr, though...
16:21:27 <araujo> dons, I wrote a command line front end :-]
16:21:32 <stepcut> dons: I wrote some haskell bindings to libmad... but that is probably not what you are looking for
16:21:50 <Frederick> SamB, Im checking if expr is a well formed grammar
16:22:01 <dons> really just looking for a lightweight curses front end, a bit like ksmp3play, but without the segfaults
16:22:19 <dons> so I can use my laptop as an ipod while on the bus :)
16:22:26 <SamB> Frederick: you aren't checking anything, all you do is define it!
16:22:44 <SamB> the compiler checks that it is well-typed, but that's it
16:23:20 <Frederick> SamB, this is the point of the first part of the assignment, I ned to check if it is well-typed it it really consists on a grammar
16:23:22 <dons> hmm. whats a good name for a haskell based mp3 ui/frontend?
16:23:27 <stepcut> araujo: plus, I keep trying to do things that maybe can't be done in haskell :p
16:23:35 <araujo> mpHask3ll
16:23:38 <araujo> :-P
16:23:54 <araujo> stepcut, There exist such a things? :-]
16:24:03 <stepcut> dons: just mp3? or ogg, etc ?
16:24:24 <dons> well, mp3 is ok for now. but i'd expect to use an external decoder, like mpg123 etc.
16:24:35 <Frederick> dons, MfunkP
16:24:49 <dons> the haskell code would just do a nice non-crashing curses ui
16:24:56 <SamB> dons: not a plugin system?
16:24:56 <dons> or maybe gtk too..
16:25:20 <dons> a ui much like riot.
16:25:37 <stepcut> araujo: well -- I am currently trying to figure out if I can some how make a serialization/deserialization library that can be extend to include new types by simpling importing additional modules
16:25:50 <araujo> dons, http://dev.gentoo.org/~araujo/stuff/src/Smsh.hs
16:25:52 <dons> just passing FilePaths and flags over to mpg123 (or whatever other backend)
16:25:52 <Frederick> SamB, did you get what I men?
16:25:54 <Frederick> *mean
16:26:10 <araujo> That's the script i use for playing mp3 :-]
16:26:25 <SamB> Frederick: it really sounds like you'd want to write a function for that
16:26:28 <dons> araujo!
16:26:30 <dons> nice
16:26:30 <stepcut> araujo: scrape your boilerplate III almost gets me there, but not quite...
16:26:44 <araujo> dons, At least it works :-]
16:26:53 <dons> araujo, I think i'd like to just use the file system as the db
16:27:16 <dons> but yes, I think maybe I'll just take that and wrap a ui on top, eh?
16:27:17 <araujo> dons, Ok.
16:27:23 <Frederick> SamB, I need a function to get the expr but also I need yo have a way to reffer to the productions like if I want to modify "add"
16:27:30 <dons> @karma+ araujo
16:27:30 <lambdabot> araujo's karma raised to 2.
16:27:35 <araujo> dons, That was actually my "next step" for it :-)
16:27:46 <araujo> But if you think you can do it, go for it!
16:27:51 <Speck> araujo: it's always so impressive when I read a healthy amount of practical haskell code
16:27:55 <dons> ok, i'm pretty familiar with the curses binding for haskell, so maybe I could do it today. let's see..
16:27:55 <Speck> but I gotta run!
16:27:56 <araujo> hah, Thanks :-)
16:28:14 <araujo> Speck, :-)
16:28:48 <stepcut> my cat is yelling at me :( I don't think he understands the concept of day light savings and its affect on his dinner time
16:29:20 <araujo> dons, I think it'd be pretty straightforward to add an UI right?, i was thinking to use GTK , though you can perfectly have several UIs, i don't think it'd be complicated.
16:30:06 * Frederick is lost
16:30:47 <dons> araujo, if we have a nice interface to the backend, i.e. a typeclass, then arbitrary ui frontends should be ok.
16:31:00 <dons> i'll take some of the portable ui ideas from yi
16:31:51 * stepcut is working on a DJ-style mp3 player with an openGL front end -- but so far only has simple libmad bindings and jack bindings working
16:32:03 <stepcut> oh, and initail MIDI support
16:32:22 <dons> nice code araujo
16:32:25 * Frederick sits at the dark and cries
16:34:01 <araujo> dons, hah, really?
16:34:12 <araujo> Well, Thanks!
16:34:13 <araujo> :-]
16:37:28 <ricebowl> what's wrong with this: type Tower = {name :: TowerId, edges :: [TowerId]}
16:37:42 <ricebowl> I get a parse error on '{'
16:37:59 <ricebowl> do I have to declare it with a data declaration?
16:38:26 <stepcut> ricebowl: type is only used for aliases, you probably need data or newtype
16:39:00 <stepcut> and a constructor...
16:39:10 <ricebowl> I read that records don't need ctors...
16:39:13 <ricebowl> hum, guess that's wrong
16:39:48 <ricebowl> and this won't work either, correct? data Tower = Tower {name :: TowerId, edges :: [TowerId]}
16:39:53 <ricebowl> i.e. have to name the ctor something else
16:40:10 <ricebowl> oh nevermind, I thought it was complaining but misread
16:40:53 <stepcut> heh, yeah that should work fine
16:41:19 <stepcut> and you can't use newtype in this case, because you have more than one field in the record
16:41:23 <ricebowl> heh, looking at a page of errors makes it difficult to spot which are relevant
16:41:29 <ricebowl> *nods*
16:41:36 <stepcut> :p
16:41:50 <ricebowl> yes, now I just have to go back and fix all the places where I used a tuple for the same...
16:42:11 <stepcut> I once got something like 1000 lines of error messages from g++ when I missed a semicolon :p
16:42:30 <ricebowl> haha
16:42:35 <ricebowl> I've done the same
16:43:11 <ricebowl> ah, crap... I conveniently used lookup, but that obviously won't work with records ;)
16:43:43 <stepcut> heh
16:43:45 <ricebowl> question, if I wrote foo x y = lookup x y, would it be more expensive to call foo even with optimization?
16:43:54 <ricebowl> or would GHC do inlining?
16:44:52 * stepcut has no idea
16:45:06 <stepcut> but I would like to believe GHC will do something smart ;)
16:45:34 <ricebowl> I would too
16:47:49 <Igloo> Why are you worried about the cost with optimisation turned off?
16:50:14 <stepcut> foo x y = lookup x y
16:50:14 <stepcut> main = print (foo 1 [(1,"hi")])
16:50:42 <ricebowl> Igloo - I'm not
16:50:46 <ricebowl> I said "even with optimization"
16:50:49 <stepcut> and then did, ghc -fext-core Test.hs, and in the Test.hcr it looks like it calls lookup in main, not foo
16:51:16 <ricebowl> stepcut - ah, cool :)
16:51:53 <ricebowl> erm, so apparently the . does not work to select fields from a record
16:51:56 <ricebowl> which I had *also* read
16:52:00 <stepcut> ??
16:52:21 <ricebowl> t :: Tower
16:52:28 <ricebowl> t.tid is a syntax error
16:52:43 <ricebowl> and recall: data Tower = Tower {name :: TowerId, edges :: [TowerId]}
16:52:51 <ricebowl> er, minor note, I renamed "name" to "tid"
16:53:18 <stepcut> are you sure you were reading about haskell and not clean or something ?
16:53:22 <stepcut> :p
16:53:28 <ricebowl> must have been one of the variants
16:54:24 <stepcut> 'tid t' is probably what you want
16:54:36 <ricebowl> yeah, but that means I have to call my variable something else
16:54:44 <ricebowl> humm...
16:55:01 <ricebowl> I've never used records in Haskell before... though I am quite the newbie
16:55:07 <stepcut> haskell records are a bit on the weak side, but there is not agreement on what to replace it with
16:55:18 <Igloo> Oh, sorry, misread it
16:55:42 <ricebowl> *nods*
16:57:41 <ricebowl> oh well.
16:57:51 <ricebowl> I might as well use a tuple
16:57:58 <stepcut> :p
16:58:01 <Cale> Haskell records are basically just syntax sugar around the ordinary algebraic data types
16:58:16 <Cale> you really should use them over things like tuples
16:58:18 <ricebowl> there is no point to using a record except that I get functions to extract the fields for free
16:58:30 <ricebowl> Cale - well it's going to clutter my namespace
16:59:01 <stepcut> ricebowl: yep -- that is about all haskell records are good for :-/
17:00:47 <SyntaxNinja> nah, they are also good for accessing / updating data in a manner that doesn't change when the type changes
17:01:15 <SyntaxNinja> x{y=2} will work even when you add more fields to x's type.
17:02:14 <stepcut> true..
17:02:30 <stepcut> though, you could make a updateY function that did the same thing
17:02:42 <soysauce> you would have to change it with the change of the type
17:03:10 * SyntaxNinja pokes stepcut
17:03:40 <stepcut> soysauce: right, that is the 'for free' part that ricebowl was refering to
17:03:49 * ricebowl == soysauce
17:03:58 <ricebowl> ;)
17:03:59 <stepcut> :p
17:04:06 <ricebowl> have *way* too many boxen
17:04:16 <ricebowl> and I'm getting tired of connecting to this one to IRC :p
17:04:31 <ricebowl> since I am actually working from the other
17:05:17 <Cale> It's generally considered unusual to use tuples which are larger than pairs
17:05:37 <ricebowl> Cale - I am using pairs
17:05:44 <int-e> . o O (  (a,(b,(c,d)))  )
17:05:50 <SamB> its really odd that GHC supports such huge ones...
17:06:05 <SamB> int-e: what are you on? Arrows?
17:06:07 <Cale> int-e: I think even that's preferable to (a,b,c,d)
17:06:19 <dons> some mechanically generated code (c2hs?) uses big tuples
17:06:42 <int-e> "However, every Haskell implementation must support tuples up to size 15,"
17:06:49 <int-e> says the haskell report.
17:06:56 <SamB> int-e: GHC goes way higher
17:07:08 <SamB> it doesn't implement the classes that high though
17:07:33 <SamB> but -split-objs is really important for Data.Tuple
17:07:53 <dons> yeah, up to 70 iirc. but e.g. Typeable only goes to 7
17:08:37 <Cale> That's kind of ridiculous. I'd rather that it only supported pairs, but (a,b,c) was syntax sugar for (a,(b,c))
17:08:38 <SamB> I have difficulty seeing anyone want Typeable past 4 or 5
17:09:48 <dons> mechanically generated stuff, again. or code generators for other languages
17:09:58 <int-e> Cale: I'm not sure I agree there, because of the difference in representation on the implementation level - this would basically mean implementing typles as lists. (Ok, the compiler could optimize that, but does it do that?)
17:11:27 <int-e> Cale: that being said you probably want named records in most of these cases anyway. I don't know.
17:11:37 <Cale> int-e: okay, but there are still record/algebraic types, yeah
17:12:04 <Cale> and how often do you even see a triple?
17:12:21 <int-e> I'd argue triples and quadruples make nice vectors.
17:12:54 <stepcut> I have written code that ran into problems with tuples not have show/read past 6 elements
17:12:59 <soysauce> stepcut - how did you determine that bit about GHC's optimization, btw?
17:13:06 <int-e> and I guess vector arithmetic is the only thing I'd use them for.
17:13:17 <soysauce> I want to see if it will precompute some other things
17:13:52 <stepcut> soysauce: ghc -fext-core dumps out mid-level code called 'Core'
17:13:59 <stepcut> http://www.haskell.org/ghc/docs/latest/html/users_guide/ext-core.html
17:14:14 <soysauce> ah ok
17:14:25 <stepcut> In the core, I saw that it called lookup directly and never called foo
17:17:08 <soysauce> heh, htf do you manage to read that ;)
17:17:30 <stepcut> soysauce: I just searched for foo and lookup
17:17:33 <stepcut> tis not easy to read
17:17:40 <soysauce> yeah obviously :p
17:18:14 <dons> ok. so hmp3 is now playing music. next step. add a curses ui
17:20:05 <Cale> oh neat
17:20:36 <stepcut> unlike me, dons actually gets things done :p
17:21:18 <Cale> An ffi binding to an mp3 decoder library?
17:23:27 <dons> a curses frontend to a standalone decoder
17:23:37 <dons> a library binding is left as an exercise for thhe reader
17:24:19 <dons> it helps that most of the ui code can be ripped straight from ncurses yi :)
17:24:52 <jose_da_bicla> hello.. can someone tell me if all the libraries described in ghc documentation are available with ghc?
17:25:06 <dons> yes
17:25:08 <dons> they are.
17:25:15 <dons> @docs Data.List
17:25:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
17:26:00 <jose_da_bicla> for instance i need to use QuickCheck should i just compile my prog with -lQuickCheck ?
17:26:15 <dons> -package QuickCheck
17:26:29 <Cale> or just --make
17:26:43 <jose_da_bicla> oh
17:26:43 <jose_da_bicla> ok
17:26:43 <jose_da_bicla> thks
17:26:43 <jose_da_bicla> :)
17:26:47 <Cale> which ought to be able to figure things like that out
17:27:41 <jose_da_bicla> can i import this as a module on my program?
17:28:10 <Cale> well, you'll need to import Test.QuickCheck
17:28:48 <jose_da_bicla> that explains a lot :\
17:29:29 <stepcut> :p
17:30:23 * jose_da_bicla blushes
17:30:23 <jose_da_bicla> :p
17:57:02 <soysauce> hm, how do I use the GHC profiler? I'm doing something wrong :/
17:57:15 <soysauce> compiled -O -prof and I run the executable with -RTS and don't get meaningful output
17:57:53 <dons> -prof -auto-all
17:57:57 <dons> and run with +RTS -p
17:58:06 <soysauce> ah
17:58:12 <dons> :)
17:58:14 <soysauce> thanks
18:00:30 <soysauce> blah, it seems like everything in Haskell is documented but poorly organized; it's so hard to find information :/
18:01:26 <dons> @docs Control.Monad
18:01:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
18:01:32 <dons> @type map
18:01:32 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
18:01:41 <dons> lambdabot might help
18:01:48 <dons> @index fmap
18:01:48 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
18:01:48 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
18:01:48 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
18:01:55 <dons> @hoogle a -> b -> [a]
18:01:56 <lambdabot> Data.List.repeat :: a -> [a]
18:01:56 <lambdabot> Prelude.repeat :: a -> [a]
18:01:56 <lambdabot> Data.List.replicate :: Int -> a -> [a]
18:01:58 <dons> and so on
18:02:12 <dave_m> of course, lambdabot itself isn't very well documented
18:02:13 <soysauce> @docs profiler
18:02:14 <lambdabot> profiler not available
18:02:17 <soysauce> :|
18:02:26 <soysauce> oh well
18:02:37 <dons> read the ghc user's guide. it has 2 chapters on profiling.
18:02:42 <dons> @where ghc
18:02:42 <lambdabot> http://haskell.org/ghc
18:02:50 <dons> on the documentation page of the above site.
18:03:31 <soysauce> ah cool
18:03:51 <dons> the ghc user's guide is highly recommended
18:06:26 <dons> i'm not sure that lambdabot is that badly documented by the way
18:06:33 <dons> it used to be, but we've made some effort
18:06:51 <dons> there's a wiki now, a website, haddocks, and all modules have at least some documentation
18:07:11 <dave_m> @where lambdabot
18:07:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:07:15 <dons> meta-info, such as tutorials on writing plugins, are certainly missing though
18:08:11 <dave_m> hmm. The Lambdabot homepage points to the wiki, which points back to the homepage
18:08:26 <dons> sure.
18:08:31 <dons> add some documentation if you like :)
18:09:47 <dave_m> It would probably be good to mention "@help"
18:10:05 <dons> on the website? feel free to add it to the wiki page
18:10:38 <dons> yes, also we've added @help. so I feel we're addressing the documentation issue.
18:11:27 <dave_m> the difficulty is getting started. There's nowhere you can go to learn that commands to lambdabot are of the form "@"+word, for example
18:11:47 <dons> yes. no meta info
18:11:52 <ski> > "except this command"
18:11:53 <lambdabot> "except this command"
18:11:56 <dons> above the level of get it, bulid it. etc.
18:12:43 <dave_m> exactly. There's plenty of information about how to build lambdabot, but very little about how to use it.
18:13:37 <dons> please write down anything, even a list of points, that you think should be addressed, on the wiki
18:13:40 <dave_m> I'm not complaning. I'm just saying that telling a newbie to use lambdabot probably isn't very helpful
18:13:42 <dons> then someone will feel them out
18:13:54 <dons> do we tell newbies to use lambdabot? i hope not
18:14:11 <dons> it's kinda tricky and advanced. though plugins are fairly simple themselves
18:14:31 <ski> newbies use it here on channel
18:14:44 <ski> another thing to build it and add plugins, etc
18:14:48 <dave_m> I'm talking about the bot here on #haskell, not the software itself
18:15:01 <dons> that's what i meant earlier. use lambdabot here in the channel. it's easy to pick up by watching others.
18:15:11 <soysauce> to some extent
18:15:23 <dons> you only have to look at yesterday's logs to see how to use it
18:15:53 <dons> and the logs are references in the /topic
18:17:32 <dave_m> sure, and you can talk to the bot in a private channel to experiment, but that's not documentation. I'm not complaining; I'm just saying.
18:17:52 <dons> ok. there should be a tutorial or a howto, in an ideal world
18:17:54 <dons> I agree
18:18:25 <soysauce> hm, ever looked at GHC's --show-profile output?
18:18:34 <soysauce> I'm trying to understand how my functions are lazy...
18:18:35 <dons> didn't even know about that flag.
18:18:38 <dons> what does it do?
18:18:41 <soysauce> http://haskell.org/ghc/docs/latest/html/users_guide/faster.html
18:18:48 <soysauce> something to do with strictness
18:19:10 <soysauce> I think A corresponds to an unused parameter, a _, but the others I am not sure about.
18:20:02 <soysauce> I see this:
18:20:03 <soysauce> findtower1 :: TowerId -> [Tower] -> Data.Maybe.Maybe Tower
18:20:03 <soysauce>   {- Arity: 2 HasNoCafRefs Strictness: LS -}
18:22:26 <Igloo> soysauce: That page doesn't mention --show-profile?
18:22:43 <soysauce> sorry, --show-iface
18:23:15 <soysauce> cursed lack of caffeine ;)
18:24:02 <Igloo> See the "How do I find out a function's strictness?" section of that page
18:24:26 <soysauce> yes, that is what I just read
18:24:39 <soysauce> I know it's strictness, now I want to understand *why*
18:26:31 <soysauce> oh well, bbl
19:06:23 <dons> @hoogle Int -> Bool
19:06:24 <lambdabot> Control.Concurrent.rtsSupportsBoundThreads :: Bool
19:06:24 <lambdabot> Data.Bool.False :: Bool
19:06:24 <lambdabot> Data.Bool.True :: Bool
19:06:29 <dons> bah
19:09:20 <int-e> @type odd
19:09:20 <lambdabot> forall a. (Integral a) => a -> Bool
19:09:57 <Cale> @hoogle a -> Bool
19:09:58 <lambdabot> Test.QuickCheck.Batch.isBottom :: a -> Bool
19:09:58 <lambdabot> Control.Concurrent.rtsSupportsBoundThreads :: Bool
19:09:58 <lambdabot> Data.Bool.False :: Bool
19:10:08 <Cale> @hoogle (Integral a) => a -> Bool
19:10:09 <lambdabot> Prelude.even :: Integral a => a -> Bool
19:10:09 <lambdabot> Prelude.odd :: Integral a => a -> Bool
19:10:09 <lambdabot> Test.QuickCheck.Batch.isBottom :: a -> Bool
19:10:21 <Cale> @hoogle (Ord a) => a -> Bool
19:10:22 <lambdabot> Test.QuickCheck.Batch.isBottom :: a -> Bool
19:10:22 <lambdabot> Control.Concurrent.rtsSupportsBoundThreads :: Bool
19:10:22 <lambdabot> Data.Bool.False :: Bool
19:10:54 <Cale> @hoogle (Ord a) => a -> a -> Bool
19:10:56 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
19:10:56 <lambdabot> Prelude.(<=) :: Ord a => a -> a -> Bool
19:10:56 <lambdabot> Prelude.(>) :: Ord a => a -> a -> Bool
19:11:27 <Cale> Which version of hoogle is in the bot?
19:11:57 <dons> cvs
19:12:22 <dons> from a few days ago
19:30:30 <joelr> anyone alive?
19:31:07 <Speck> hopefully!
19:31:13 <joelr> he
19:31:29 <joelr> is there any way to write a function that matches on any constructor with 1 argument?
19:32:20 <dons> that wouldn't be type safe
19:32:33 <Speck> also, don't all constructors have one argument? due to currying?
19:33:00 <joelr> dons: i know but consider my predicament... i'm gonna have a bunch of newtypes and i want to write a generic pickler for them
19:33:19 <dons> so you want: case x of _ a -> a ; _ b -> b and so on
19:33:30 <dons> then the type isn't known
19:33:31 <joelr> the wrapper for the pickler has to strip the constructor on the way in and put it back on the way out
19:33:34 <dons> so: bad.
19:33:37 <joelr> or something like that
19:33:58 <joelr> actually, i can't just match on an argument because i have to reconstruct the type
19:34:03 <dons> oh, there's probably sneaky ways with scrap your boilerplate code, or template haskell
19:34:07 <joelr> i'm considering Data.Dynamic
19:34:12 <dons> right.
19:34:15 <dons> maybe that would work.
19:34:22 <dave_m> if the pickling code is in a class, you could use newtype deriving
19:34:29 <joelr> dons: have you tried that?
19:34:36 <joelr> no, the pickling code is not in a class
19:34:38 <dons> you can certainly write a type case with a Dynamic
19:34:59 <joelr> mkTyConApp (mkTyCon "AvgPot1") [typeOf (100 :: Word64)] :: TypeRep
19:35:13 <joelr> something like that for newtype AvgPot = AvgPot Word64
19:35:28 <joelr> i'm trying to figure out how to go form a TypeRep to a regular value now
19:36:15 <dons> um. don't you want toDyn and fromDyn?
19:36:24 <dons> > toDyn 'c'
19:36:25 <lambdabot> <<Char>>
19:36:34 <dons> > fromDyn (toDyn 'c') :: Chra
19:36:35 <lambdabot>  Not in scope: type constructor or class `Chra'
19:36:36 <dons> > fromDyn (toDyn 'c') :: Char
19:36:37 <lambdabot>   Expecting a function type, but found `Char'
19:36:37 <lambdabot>   Expected type: Char
19:36:37 <lambdabot>   Inferred type: a -> a
19:36:45 <joelr> dons: possibly, let me take a quick look
19:36:51 <dons> > fromDynamic (toDyn 'c') :: Char
19:36:51 <lambdabot> Couldn't match `Char' against `Maybe a'
19:36:55 <dons> > fromDynamic (toDyn 'c') :: Maybe Char
19:36:56 <lambdabot> Just 'c'
19:36:59 <dons> > fromDynamic (toDyn 'c') :: Maybe Int
19:36:59 <lambdabot> Nothing
19:37:00 <joelr> i know they go to dynamic
19:37:05 <joelr> but not TypeRep
19:37:16 <dons> you're not supposed to construt type reps by hand, i think.
19:37:31 <joelr> mkTyConApp (mkTyCon "AvgPot1") [typeOf (100 :: Word64)]
19:37:38 <joelr> this gives a type rep i think
19:37:40 <dons> unless you're writing Typeable instances.
19:37:48 <joelr> dons: i am
19:37:56 <dons> okeydokey.
19:37:58 <joelr> i think i am. Word64 is typeable
19:38:10 <joelr> maybe template haskell would be better
19:38:12 <joelr> would it?
19:38:15 <dave_m> joelr: why not use "deriving (Typeable)"?
19:38:35 <joelr> dave_m: i would. but i'm trying to cut down on boilerplate code
19:38:45 <dons> ?
19:39:02 <joelr> newtype AvgPot = AvgPot Word64
19:39:02 <joelr> puAvgPot = wrap (\a -> AvgPot a, \(AvgPot b) -> b) endian
19:39:14 <joelr> i would need to write a pickler for every type
19:39:14 <fworp> @hoogle Socket -> Bool
19:39:15 <lambdabot> Control.Concurrent.rtsSupportsBoundThreads :: Bool
19:39:15 <lambdabot> Data.Bool.False :: Bool
19:39:15 <lambdabot> Data.Bool.True :: Bool
19:39:18 <joelr> which i would hate doing
19:39:56 <fworp> not what i was expecting...
19:40:01 <joelr> so i'm trying to see if i can pass the constructor name and then construct the type, etc. but i think that's error-prone as i can get the name of the constructor wrong
19:40:07 <joelr> how would i use template haskell here?
19:40:08 <dons> not sure you can get around it with tricksiness
19:40:18 <dons> generate the code at compile time.
19:40:40 <fworp> @hoogle (Socket -> Bool)
19:40:41 <lambdabot> Control.Concurrent.rtsSupportsBoundThreads :: Bool
19:40:41 <lambdabot> Data.Bool.False :: Bool
19:40:41 <lambdabot> Data.Bool.True :: Bool
19:40:42 <joelr> dons: with TH? how?
19:40:43 <dons> but seriously, it would be easier to just write the code once (perhaps with the help of a perl or sed script)
19:41:01 <dons> TH is a compile time meta programmign language. you can wrrite algorithms that let you construct code at compile time
19:41:03 <joelr> dons: so template haskell would not help?
19:41:07 <dons> this could include deriving code.
19:41:17 <joelr> dons: which is exactly what i'm trying to do
19:41:32 <dons> well, if you don't like writing your own instances, you could have TH do it, but then you need to write a instance-generator in TH
19:41:34 <joelr> i'd love to have a template pickler that takes a type and the pickler itself
19:41:39 <dons> might be shorter, but you have to learn TH.
19:41:58 <dons> check the TH paper, it describes this stuff
19:42:07 <joelr> looking for it
19:42:20 <dons> depends really on how many experimental parts of haskell you want to play  with in 1 week
19:42:38 <joelr> dons: they seem to be working so why not use them?
19:42:40 <Speck> TH + plugins?
19:42:52 <dons> why not?! :D
19:42:59 <joelr> i'm pretty good at using bits of technology that i understand from a bigger whole that i don't
19:43:03 <joelr> hole :)
19:43:04 <dons> do the whole lot and have compile time, and runtime meta programming
19:43:19 <joelr> dons: i got the HList in, btw :) figured it out
19:43:20 <Speck> always seemed like a good idea -- pluginizing a haskell environment would allow for some pretty neat stuff
19:43:25 <fworp> @hoogle (Socket -> Maybe Handle)
19:43:25 <dave_m> if all you want is a pickler, then create a class, make Word64 an instance, and have AvgPot derive an instance.
19:43:25 <lambdabot> No matches, try a more general search
19:43:50 <joelr> dave_m: hmm... thinking about it
19:44:16 <joelr> dave_m: what about constructors?
19:44:45 <joelr> a pickler is a data PU = PU a b
19:44:46 <dave_m> newtypes don't actually have constructors
19:45:11 <joelr> dave_m: where a and b are pickler functions, in and out
19:46:04 <dons> @hoogle Handle -> Fd
19:46:05 <lambdabot> No matches, try a more general search
19:46:21 <joelr> dave_m: since pickler is a data type it seems that i could only specify a and b picklers for the class and i would still have to put them together
19:46:27 <joelr> in a pickler which does not save me any code
19:47:04 <joelr> i.e class Foo where a :: PU a, b :: PU b
19:47:04 <dave_m> PU has no type parameter?
19:47:08 <joelr> something like that, roughly
19:47:30 <joelr> data PU a = PU { appP :: (a, [Word8]) -> [Word8],
19:47:30 <joelr>                  appU :: [Word8] -> (a, [Word8]) }
19:47:35 <fworp> dons, i dont think i can use System.Posix (i dont want to anyhow)
19:47:38 <joelr> dave_m: check out pickler combinators
19:47:43 <joelr> @google pickler combinators
19:47:44 <lambdabot> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
19:48:05 <dave_m> Then the class you want is "class Picklable a where pickler :: PU a"
19:49:03 <joelr> dave_m: yes, but consider this puAvgPot = wrap (\a -> AvgPot a, \(AvgPot b) -> b) endian
19:49:33 <joelr> generic puAvgPot would be parameterized on endian
19:49:41 <joelr> because instead of endian there could be something else
19:50:04 <joelr> and there need to be functions for the wrapper. so it doesn't quite work with classes
19:50:12 <joelr> i'm looking into template haskell
19:50:18 <dave_m> right, newtype deriving is only helpful if the code you want is identical
19:50:32 <dave_m> (modulo wrapping/unwrapping)
19:50:39 <joelr> any template haskellers?
19:52:45 <dave_m> how generic do you want this to be?
19:53:05 <joelr> well, i have a LOT of newtypes like AvgPot
19:53:27 <joelr> so i need a fun that takes the end pickler (like endian)
19:53:46 <joelr> as well as the newtype and automatically generates the rest
19:53:57 <joelr> puAvgPot pa = wrap (\a -> AvgPot a, \(AvgPot b) -> b) pa
19:54:13 <joelr> something like that, except it needs to take AvgPot in as argument as well
19:54:38 <joelr> pickler pa = wrap (\a -> XX a, \(XX b) -> b) pa
19:54:59 <joelr> pickler pa XX = wrap (\a -> XX a, \(XX b) -> b) pa
19:54:59 <joelr> there
19:55:02 <joelr> something like that
19:55:40 <dave_m> how easy is it to determine the underlying pickler?
19:55:57 <joelr> pickler pa XX = wrap (\a -> XX a, \(XX b) -> b) pa <--- this is it
19:55:59 <joelr> it's a given
19:56:04 <joelr> passed in as argumen
19:56:07 <joelr> argument
19:56:42 <joelr> maybe i need reify T
19:57:25 <dave_m> so, you want a single, run-time function "pickler"?
19:57:35 <joelr> yup
19:57:43 <joelr> constructed at compile time
19:58:50 <dave_m> It wouldn't be typeable, because its result type depends on its input values
19:59:34 <joelr> it's fine, really
19:59:37 <joelr> i mean
19:59:40 <dave_m> You could do a typeclass
19:59:44 <joelr> here's the type
19:59:53 <joelr> pickler pa XX = wrap (\a -> XX a, \(XX b) -> b) pa :: PU XX
20:00:06 <joelr> this really calls for template haskell
20:00:45 <dave_m> oh, so $(pickler pa XX) :: PU XX
20:01:29 <joelr> dave_m: that's it?!
20:01:42 <joelr> dave_m: but yes, that's the deal
20:01:46 <joelr> the type
20:01:50 <dave_m> no, the syntax for passing types may be different
20:01:57 <joelr> dave_m: what about the contents of the pickler?
20:03:20 <dave_m> along these lines: "pickler pa t = [| wrap (...) pa |]"
20:03:42 <joelr> dave_m: does that work?
20:03:55 <dave_m> no, you need to fill in the parentheses
20:04:23 <joelr> pickler pa t = [| wrap (\a -> t a, \(t b) -> b) pa |]
20:04:27 <joelr> like that?
20:05:13 <dave_m> no, it would be more like pickler pa t = [| wrap (\a -> $t a, \($t b) -> b) pa |]
20:05:21 <dave_m> but I don't think that would work, either
20:05:52 <joelr> why not?
20:05:57 <dave_m> TH is going to distinguish types from constructors, and I don't know if you can splice into pattern matches
20:06:35 <dave_m> I'm pretty sure it's doable, but I'd have to spend some time looking at the docs
20:07:25 <joelr> i'm looking, really need this ... now :(
20:07:33 <joelr> gotta finish a project by this morning
20:09:23 <dave_m> I'd go with the boilerplate, then. Save the TH for version 2.0
20:09:27 <Lemmih> newtype T1' a = T1 a; type T1 = T1' Int; pickler :: a b -> b; pickler = unsafeCoerce#
20:09:54 <Lemmih> Typesafe coercion (:
20:10:25 <joelr> Lemmih: any TH in your toolbox?
20:11:02 <Lemmih> Yeah, but I think it's overkill in your situation.
20:11:36 <joelr> Lemmih: well,
20:11:38 <joelr> data PU a = PU { appP :: (a, [Word8]) -> [Word8],
20:11:38 <joelr>                  appU :: [Word8] -> (a, [Word8]) }
20:11:43 <joelr> this is a pickler, see
20:11:57 <joelr> newtype AvgPot = AvgPot Word64
20:11:57 <joelr> puAvgPot = wrap (\a -> AvgPot a, \(AvgPot b) -> b) endian
20:12:05 <joelr> this is what i'm trying to generalize
20:12:11 <joelr> parameterize on AvgPot
20:12:31 <joelr> i don't think you can do that without TH
20:12:48 <joelr> pickler pa t = [| wrap (\a -> $t a, \($t b) -> b) pa |]
20:12:54 <joelr> something like this would solve it
20:13:12 <joelr> except it barfs on the second $t
20:14:07 <dave_m> you could do a CPP macro...
20:14:19 <joelr> that would surely work
20:14:21 <joelr> hmm
20:14:49 <joelr> TH is cooler but i can't figure that out. cpp is dirty but does the trick... i would prefer TH, though :)
20:15:21 <stepcut> joelr: can you unpickle something without knowing its target type before hand ?
20:15:30 <joelr> otherwise i would need to put ugly UPPERCASE_MACROS all over the place
20:15:34 <joelr> stepcut: no
20:16:01 <stepcut> joelr: too bad :-( I have been trying to solve that problem for the last year or so :p
20:17:00 <Lemmih> joelr: What's 'wrap'?
20:17:01 <stepcut> I can sort of do it, but I have to stitch a bunch of stuff together by hand in the top-level module, and that is error prone...
20:17:02 <joelr> stepcut: think different ;)
20:17:07 <joelr> Lemmih: that's easy
20:17:18 <joelr> Lemmih: wrap :: (a -> b, b -> a) -> PU a -> PU b
20:17:34 <joelr> stepcut: @google pickler combinators
20:18:08 <stepcut> joelr: yeah, I looked at that a bit -- it did not immediately give me any ideas how to solve my problem, but I will probably look at it more later
20:19:53 <Lemmih> How can 'wrap' be anything else than a type cast?
20:20:04 <stepcut> "There and back again: Arrows for invertible programming" ftp://ftp.cs.kun.nl/pub/Clean/papers/2005/alia2005-biarrowsHaskellWorkshop.pdf was also kind of neat
20:20:31 <joelr> Lemmih: that's what it is, a type cast. to and from.
20:20:31 <Lemmih> (when the two function in the tuple are 'id')
20:20:56 <dave_m> it's more of an embedding projection
20:20:56 <joelr> Lemmih: but it's not always that way, sometimes you can twist things
20:22:49 <joelr> Lemmih: any idea how to do this with TH?
20:23:41 <Lemmih> joelr: reify the type and construct the pattern yourself.
20:24:10 <joelr> Lemmih: don't know how. never used TH before
20:25:08 <joelr> i want something like pickler pa T = wrap (\a -> T a, \(T b) -> b) pa
20:25:10 <Lemmih> There's documentation in the library source code.
20:25:35 <joelr> hmm
20:25:42 <Lemmih> But I still think TH is the wrong answer.
20:25:42 <joelr> where should i start digging?
20:27:42 <joelr> Lemmih: show me another way then. i would certainly appreciate it
20:28:12 <joelr> actually, i just need a cpp for this, i think
20:28:18 <Lemmih> pickler is just an 'unsafeCoerce#' in disguise.
20:28:22 <joelr> as dave_m suggested
20:28:32 <joelr> Lemmih: there can be a lot of code in the wrap, you see
20:29:15 <Lemmih> It can only be a cast the way 'pickler' is using it.
20:29:56 <joelr> you mean an unsafe coerce cast?
20:30:19 <dave_m> it's as safe as the conversion functions
20:30:39 <dave_m> consider wrap (ord, chr)
20:30:41 <joelr> ok, so i apologize for now thinking clearly
20:30:51 <joelr> how would this work for any T?
20:31:02 <joelr> in pickler pa T = wrap (\a -> T a, \(T b) -> b) pa
20:32:33 <Lemmih> Where 'T' can be a non-newtype?
20:33:09 <joelr> no, just newtype is fine. for data i would have to define picklers anyway
20:33:22 <dave_m> how do you see yourself using pickler?
20:33:34 <dave_m> would you use it with different values of pa for the same T?
20:33:43 <joelr> dave_m: correct
20:33:48 <joelr> wait, no
20:33:57 <joelr> i would use it with different pa for different T
20:34:06 <joelr> in different permutations
20:34:18 <joelr> avgPot :: Attr Word64 = makeAttr "avgPot" endian -- double, fix
20:34:18 <joelr> numberOfPlayers :: Attr Word16 = makeAttr "numberOfPlayers" endian
20:34:30 <joelr> this is what i do right now. this says that avgpot is stored as endian Word64
20:34:39 <joelr> and numplayers is endian word16
20:34:54 <joelr> tableName :: Attr String = makeAttr "tableName" wstring
20:34:57 <joelr> another example, string stored as wide string
20:35:28 <joelr> these are simple and require a "generic" pickler
20:35:33 <dave_m> where does the AvgPot type come in?
20:35:51 <joelr> in this case it does not
20:35:59 <joelr> but i'm trying to rewrite things differently
20:36:08 <joelr> this is a more complex type
20:36:09 <joelr> newsMap :: Attr [(Word32, String)] =
20:36:09 <joelr>            makeAttr "newsMap" (list endian16 (pair endian wstring))
20:36:31 <joelr> so i would say data NewsMap = NewsMap [(Word32, String)]
20:36:56 <joelr> hmm... it's still simple, actually
20:37:23 <dave_m> this has to do with the HList retrofit?
20:37:30 <joelr> dave_m: yeah
20:37:53 <joelr> for now if i took care of newtype T = T x  i would be good
20:38:12 <joelr> where wrap just "strips" the constructor and puts it back
20:40:33 <joelr> let x = AvgPot 100
20:40:40 <joelr> Data.Typeable.cast x :: Maybe Word64
20:40:41 <joelr> oops
20:41:19 <dave_m> I would suggest reading Hinze's "Generics for the Masses", if you didn't need to get this done by tomorrow
20:41:50 <joelr> Data.Typeable.cast (100 :: Word64) :: Maybe AvgPot
20:41:50 <joelr> Nothing
20:41:56 <joelr> i spent too much time on this already
20:42:19 <joelr> writing boilerplate code :(((
20:45:23 <dave_m> In your situation, I think I'd write a Perl script to write the boilerplate for me. I don't see an elegant way out that doesn't involve more redesign
20:46:27 <joelr> right
20:46:29 <joelr> ok, thanks
20:46:50 <joelr> i'll post to the list to see if someone can give me a TH snippet
20:53:07 <tessier> What list?
20:54:12 <joelr> haskell-cafe
20:54:14 <joelr> just idd
20:54:16 <joelr> did
20:54:54 <tessier> wow
20:55:04 <tessier> haskell-cafe is for stuff that is off topic for the main haskell list...neat!
20:55:25 <Speck> not necessarily OT, but haskell is supposed to be low-bw I think
20:55:25 <tessier> My LUG has "kooler" list which serves the same function as your "cafe" list for off topic stuff
20:55:51 <tessier> haskell is for announcements etc?
20:56:24 <Speck> I get announcements on both, empirically at least the distinction has been fuzzy
20:56:32 <Speck> but things are moved to -cafe, not the other way around
20:56:42 * tessier subscribes to both
20:56:44 <Cale> lots of discussions start on haskell and move to -cafe as they get longer
20:56:53 <joelr> cale: do you know TH?
20:57:07 <Cale> joelr: not terribly well, but a little
20:57:21 <Speck> @uptime
20:57:22 <lambdabot> uptime: 6 hours, 24 minutes and 8 seconds
20:57:26 <Speck> liar!
20:57:39 <dons> ?
20:57:44 <Speck> oh wait, that looked like a log-on, not a ctcp time
20:57:48 * Speck so tired
20:57:49 <dons> yep
20:58:05 <lisppaste2> joelr pasted "parameterizing on type" at http://paste.lisp.org/display/13358
20:58:15 <joelr> cale: any help with this?
21:00:59 <Cale> joelr: I'll have a look at it
21:01:06 <joelr> thanks
21:19:26 <joelr> ping
21:19:44 <joelr> how do you do a cpp macro that concatenates with the value?
21:19:55 <Cale> hmm
21:19:58 <joelr> #define foo (a, b) my##a?
21:20:04 <joelr> that does not work
21:20:15 <skew> cpp is one of the worst functional languages ever
21:20:18 <skew> right up there with XSLT
21:20:29 <skew> #define foo(a,b) my##a should work
21:20:44 <joelr> #define foo(a) a##Stuff
21:20:58 <joelr> so that foo(blah) gives me blahStuff
21:21:03 <joelr> that does not work for some reason
21:21:25 <skew> works for me
21:21:30 <joelr> #define pickler(T, pa) \
21:21:30 <joelr> pu##T :: PU T \
21:21:30 <joelr> pu##T = wrap (\a -> T a, \(T b) -> b) pa
21:21:32 <joelr> try this
21:21:49 <joelr> i could well be doing something wrong
21:22:01 <skew> well, pu /= pa
21:22:28 <joelr> skew: i don't get puAvgPot when calling pickler(AvgPot, ...)
21:23:55 <joelr>     In the definition of `pu##':
21:23:55 <joelr>         pu## AvgPot
21:23:57 <joelr> oops
21:25:04 <skew> I wrote something like vaugely like QuickCheck in cpp once
21:28:04 <skew> if they hadn't gone and disallowed recursion it wouldn't be so bad
21:28:27 <joelr> mm]
21:29:35 <joelr> Cale: any idea on that TH bit?
21:30:35 <Cale> I'm trying :)
21:30:43 <Cale> It's been a while since I touched TH
21:30:53 <joelr> :-)
21:30:55 <joelr> thanks
21:31:08 <joelr> man, i can't even get cpp working :(
21:31:19 <joelr> won't even bother looking at TH
21:31:25 <Cale> It's one of the most volatile and underdocumented Haskell libraries :|
21:31:34 <joelr> yeah
21:31:55 <skew> what are you trying to do?
21:32:08 <skew> It's really easy to do simple things with TH
21:32:08 <joelr> #define pickler(T, PA) \
21:32:08 <joelr> pu ## T :: PU T \
21:32:16 <joelr> this does not work for me :((
21:32:20 <joelr> the ## does not
21:32:27 <joelr> skew: other than that i'm trying to do this
21:32:30 <skew> as long as you stick to quasiquotation, you are fine
21:32:54 <joelr> http://paste.lisp.org/display/13358
21:33:46 <skew> what cpp are you using? with GNU 4.0.2 ## gives me no trouble
21:34:28 <skew> note that ## suspends evaluation of the argument substituted in next to it
21:34:45 <joelr> powerpc-apple-darwin8-gcc-4.0.0 (GCC) 4.0.0 (Apple Computer, Inc. build 5026)
21:34:56 <joelr> gcc -E is my cpp
21:38:19 <skew> dude, make a typeclass and use the GHC extended deriving clause for newtypes
21:38:30 <joelr> does not work skew
21:38:34 <skew> why not?
21:38:36 <joelr> look at PU
21:38:39 <joelr> the definition
21:41:19 <skew> I don't see a problem with that
21:41:46 <joelr> skew: how about the fact that i don't always plug in endian as the pickler and it can be other things?
21:42:06 <joelr> i went through this a couple of hours ago on this channel, same discussion :-)
21:42:20 <joelr> i'd rather focus on how to get it done with TH
21:42:22 <joelr> or even cpp
21:43:37 <skew> deriving PU works for me
21:43:52 <joelr> skew: can you annotate the paste?
21:44:02 <skew> it's only an issue if you want to possibly have different serializers for the same type
21:44:17 <joelr> i do skew
21:44:23 <joelr> ;)
21:44:46 <joelr> still, can you please annotate lisp paste?
21:44:55 <skew> then you can play the fun games oleg taught us
21:45:19 <lisppaste2> skew annotated #13358 with "generalized deriving" at http://paste.lisp.org/display/13358#1
21:46:12 <skew> why did you think the definition of PU presented it from being translated to a class and used in a generalized deriving clause?
21:46:20 <joelr> skew: i just want to avoid boilerplate, that's all
21:46:34 <joelr> skew: because i do _not_ want to translate it to a class
21:46:39 <joelr> a need a generic pickler function
21:46:55 <joelr> i need PU to be exactly as it is
21:47:40 <joelr> exactly, precisely, 100% as it is
21:47:46 <skew> there's always unsafeCoerece
21:48:02 <joelr> will it work?
21:48:14 <skew> sure, newtypes are compiled out
21:48:44 <joelr> so how would you define the generic pickler?
21:48:59 <skew> wait, how generic do you want it?
21:49:05 <skew> I thought you were just looking to hit newtypes
21:49:12 <joelr> correct, just newtypes
21:50:11 <skew> puAvgPot :: PU AvgPot; puAvgPot = unsafeCoerce puWord64
21:51:29 <joelr> that would not work
21:51:34 <joelr> did i paste the definition of wrap?
21:51:35 <skew> no?
21:51:45 <joelr> hmm
21:51:57 <skew> no, I don't think you did
21:52:09 <skew> I got the idea you wanted the serialized representation of the newtype to be the same as of the oldtype
21:52:16 <joelr> wrap :: (a -> b, b -> a) -> PU a -> PU b
21:52:27 <skew> and considering that the runtime representation is identical, you can just use the old functions too
21:52:37 <joelr> and puWord64 is a PU a b as well
21:52:51 <joelr> don't think you can apply unsafeCoerce to that
21:53:37 <skew> sure you can - unsafeCoerce :: a -> b
21:54:30 <joelr> @index unsafeCoerce
21:54:30 <lambdabot> bzzt
21:54:37 <joelr> which module is that in?
21:54:41 <skew> maybe it's unsafeCoerce#
21:54:48 <Lemmih> @type GHC.Exts.unsafeCoerce#
21:54:49 <lambdabot> forall b a. a -> b
21:55:19 <joelr> *Script.Dictionary System.IO.Unsafe GHC.Exts> unsafeCoerce# x
21:55:20 <joelr> <interactive>: internal error: stg_ap_v_ret
21:55:20 <joelr>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
21:55:37 <joelr> truly unsafe!
21:56:04 <skew> it's not sure what it wanted the return type to be, I think
21:56:22 <skew> or maybe it decided to make the return type an IO action...
21:56:24 <skew> and run it
21:56:29 <joelr> he
21:56:35 <joelr> but giving it a return type works
21:56:51 <skew> why is PU not presented as a state monad?
21:56:57 <skew> the components at least
21:57:10 <joelr> skew: you cannot do it with the unpickle portion
21:57:37 <joelr> at least in a single monad you cannot define >>= such that both pickle and unpickle are propagated
21:58:32 <skew> as long as you allow that (a,b) -> c is isomorphic to a->b->c
21:58:57 <skew> appP :: a -> ([Word8] -> ((),[Word8]))
21:59:09 <skew> appU :: ([Word8] -> (a, [Word8])
21:59:35 <skew> not that have any idea why you might want to be pickling things onto and off the stream in the same action
22:00:11 <skew> ie, appP :: a -> Pickle (), appU :: Pickle a
22:00:15 <joelr> skew: try defining >= for that monad
22:00:20 <joelr> of two actions
22:00:28 <skew> type Pickle a = State [Word8] a
22:00:35 <joelr> ha!
22:00:46 <joelr> no, then you cannot require that both ops are defined for something
22:00:55 <skew> huh?
22:01:04 <joelr> no, try it as a monad around PU as it is
22:01:25 <joelr> this way you define the computation once and it (theoretically) works both ways, for pickle and unpickle
22:02:27 <skew> oh, that's more interesting
22:04:41 <skew> I was just talking about wrappping up the [Word8] threading in a state monad, to make it easier to define the members
22:04:48 <skew> even if you only do that in internal library functions
22:04:56 <joelr> ok
22:06:26 <stepcut> the more I learn about SQL the less I like it
22:06:27 <stepcut> :p
22:16:00 <skew> joelr's thing wants a strange categorical foundation
22:24:41 <ski> relational databases are good .. SQL is not so good
22:25:38 <stepcut> if I want to make a table have a specific row, I can't just do insert or update
22:26:08 <stepcut> because one will only work if the primary key does not already exist, and the other will only work if the primary key already exists
22:26:25 <stepcut> so, now I must do a two or three step process, or use a database specific extension
22:26:44 <stepcut> this is, of course, where something like haskelldb could be come in nice
22:27:11 <stepcut> I could just make a higher level haskelldb function that does what I want, and then have it generate the correct code for the database backend...
23:01:34 <earthy> Good Morning #haskell!
23:02:17 <skew> hi
23:03:43 <stepcut> morning
23:04:03 <stepcut> greetings and salutations
23:05:12 <earthy> hm. poor joel still at it with the pickling?
23:05:22 <skew> he was, but he left
23:05:44 <earthy> yeah, that makes sense, given his location and the time he was still active ;)
23:05:53 <skew> he was trying to use CPP, of all the silly things
23:06:10 <dons> he should get some kind of award. at least for covering the most parts of haskell in 1 week.
23:06:33 <earthy> he's panicking. it messes with his sense of good code.
23:06:37 <skew> I was about to show how TH is easy if you stick to quasiquotations (which is all he needed)
23:06:55 <skew> but I started thinking about compositionality
23:07:09 <skew> He actually needs more generality that arrows
23:07:17 <skew> just a straight up category
23:07:56 <earthy> yeah, I thought about the pickler/unpickler stuff, and he should just let his wish for syntactic nicety go
23:08:09 <earthy> he won't get it anyway
23:09:01 <skew> actually, you could hijack arrow notation and do pretty well for yourself
23:09:10 <skew> but that's deeper use of TH
23:09:28 <earthy> yeah, but then you'd be metaprogramming a syntax processor
23:09:30 <skew> or, you could just pretend and define an arrow instance with arr = undefined
23:09:40 * earthy nods
23:10:02 <earthy> then you kinda lose the laws normally associated with the syntax though. ;)
23:10:22 <skew> nah, you still keep all the stuff about composition
23:10:32 <skew> and in his case the alternation and pairing works too
23:10:37 <earthy> yah
23:10:41 <earthy> but not the lifting
23:10:58 <skew> oh wait, you do need to hook into the syntax to get binding names to work out right
23:11:04 <skew> and you have to disallow loops
23:20:13 <skew> wait, there are some strange composition rules going on
23:28:26 * earthy nods
23:28:46 <earthy> the problem is that you're *not* building pickled values, but picklers themselves
23:29:02 <skew> I was just confusing things a little bit
23:29:17 <skew> arrow notation with expressions restricted to patterns should work nicely
23:29:31 * shapr shoots an arrow at lambdabot 
23:29:49 * stepcut read about bi-arrows yesterday
23:32:46 <dons> @yow
23:32:46 <lambdabot> I just got my PRINCE bumper sticker ... But now I can't remember WHO
23:32:46 <lambdabot> he
23:32:46 <lambdabot> is ...
23:32:54 <dons> lambdabot seems fast these days
23:33:06 <dons> is that other people's perception?
23:33:22 <skew> what's the story with bi-arrows
23:33:42 <skew> is that like arrows except you only consider isomorphisms?
23:34:05 <shapr> They swing both ways.
23:34:10 <shapr> Or something.
23:34:27 * shapr hasn't reached the serious part of the day yet.
23:34:44 <shapr> skew: Are those the ones use in the comonads for dataflow paper?
23:34:48 <stepcut> skew: this is the only reference I have seen to them ftp://ftp.cs.kun.nl/pub/Clean/papers/2005/alia2005-biarrowsHaskellWorkshop.pdf
23:35:08 <stepcut> Invertible programming occurs in the area of data conversion where
23:35:08 <stepcut>                   it is required that the conversion in one direction is the inverse
23:35:08 <stepcut>                   of the other.
23:35:22 <skew> yep, those are isomorphisms
23:35:35 <shapr> Oh that's neat. Arrows for Reversible Computations?
23:35:46 <skew> I think the nicest thing to do with them is just work in a category where you only include morphisms that are iso
23:35:50 <shapr> Hm, I think arrows were used for some of the quantum computing stuff at ICFP2003, so it would fit.
23:37:15 * shapr creates an account at artima.com
23:37:21 <skew> they should really be a superclass of arrow instead
23:37:24 * ski played around some with such arrows, some year ago ..
23:37:31 <ski> skew : yes
23:38:10 <skew> although maybe the syntactic sugar doesn't use lambdas as much as I thought and it's ok
23:48:06 <Speck> hm, when I read this file that I know has null characters haskell skips over them
23:48:25 <Speck> at least I think they're null, they look like ^@ in vim
23:59:44 <basti_> I still can't link pango in building gtk
