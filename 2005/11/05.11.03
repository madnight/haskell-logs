00:02:16 <shapr> So, what up?
00:02:29 <ValarQ> up?
00:02:34 <shapr> vad händer?
00:02:39 <shapr> hur läget?
00:03:20 <ValarQ> i'm alive and is practising typeclasses :)
00:03:29 <shapr> Cool!
00:04:28 <ValarQ> yeah
00:04:46 <shapr> So what do you think of Haskell so far?
00:05:32 <ValarQ> i love it :)
00:05:46 * shapr boings!
00:05:56 <shapr> Yeah, me too. Haskell is great!
00:06:25 <ValarQ> maybe it doesn't do as well as C for IO heavy stuff, and i will still use python/twisted for networking
00:06:46 <ValarQ> but for calculations and more complex stuff, haskell is great
00:07:00 <shapr> Yeah, as long as it's teaching you something new, it's good.
00:08:59 <ValarQ> shapr: here, have a look at my latest crap  http://arda.no-ip.org/arm.hs
00:10:06 <shapr> cool, a simple drawing program?
00:10:54 <ValarQ> well, it draws a couple of lines depending on mouseactions
00:12:05 <shapr> Are you using dcoutts' HGL implementation?
00:12:27 <ValarQ> dunno, i use the one in ghc-6.4.1
00:12:50 <shapr> whoa, that's neat
00:13:09 <neologism> ValarQ: how long have you been learning haskell?
00:13:16 <MauS> ValarQ: nice app :)
00:13:36 <ValarQ> neologism: dunno, more than a week and less than two months i guess
00:13:41 <ValarQ> MauS: thanks
00:13:55 <ValarQ> it's just a little testprogram for some of my calculations :)
00:14:30 <ValarQ> i'm doing a small pneumatic robotarm thingie and thought haskell would work good for the calculations
00:15:00 * ValarQ wonders if haskell runs well in kernelspace...
00:16:35 <shapr> hoi boegel
00:18:23 <boegel> yo shapr
00:19:51 <shapr> ValarQ: There's hOp/House which is Haskell as a kernel.
00:24:08 <boegel> what's the best way to compile a Haskell program for Alpha ? I want to use my HRay for some profiling tests
00:24:22 <ValarQ> shapr: impressive
00:24:49 <neologism> boegel: you have alpha machine?
00:25:04 <JohnMeacham> ValarQ: I find it _much_ better than C for IO heavy stuff :) haskell is a better imperitive language than imperitive ones.
00:25:36 <boegel> neologism: not my machine, some machine here at work
00:25:49 <neologism> by a chance it doesnt run fbsd
00:26:12 <ValarQ> JohnMeacham: that might be true, i guess i only lack some experience
00:26:22 <boegel> neologism: no, Digital Unix
00:26:35 <neologism> ok... thn
00:27:27 <boegel> damn, I guess I'll have to look for another program to test
00:28:53 <shapr> boegel: Like I said before, I think debian/alpha ghc6 debs.
00:30:08 <MauS> how HGL compares to Rendering.OpenGL for 2d apps? Say, i want to draw some fractals. Which library should i choose?
00:33:26 <shapr> I think HGL uses line drawings, isn't it Hudak's SOE library?
00:34:39 <MauS> shapr: SOE? what's this?
00:35:07 <shapr> Paul Hudak's book "The Haskell School of Expression"
00:35:10 <boegel> MauS: if you want fractals, Gtk2hs with Cairo support is your choice
00:35:29 <shapr> Yeah, check out Nymphaea by xerox and Cale
00:36:01 <boegel> MauS: http://haskell.org/gtk2hs/gallery/Cairo-demo/Cairo_demo_13
00:36:16 <shapr> http://haskell.galois.com/~paolo/nymphaea/
00:39:17 <shapr> Also check out HRay by boegel :-)
00:39:28 <shapr> http://www.haskell.org/gtk2hs/gallery/HRay
00:41:29 <boegel> http://scannedinavian.org/~boegel/HRay !
00:42:27 <gour> shapr: bok, any news regarding haskellforge?
00:42:42 <MauS> hmm, seems it't time to upgrade my gtk :)
00:42:44 <shapr> Sort of...
00:42:46 <vegai> Horge?
00:43:37 <shapr> gour: I think a simple darcsforge will work, and I got an offer to integrate it into hackage.
00:44:08 <shapr> But I have a big deadline this month, so it's unlikely I'll have enough time to do the integration until December.
00:44:40 <gour> shapr: what will be included in darcsforge? only darcs repo & some web services?
00:44:50 <C-Keen> moin.
00:44:50 <gour> shapr: no rush, just curious...
00:45:23 * boegel swears
00:45:24 <shapr> The way I see it, developers submit the url to their repository, and the central host does 'darcs pull -a' nightly.
00:45:40 <boegel> I left my Haskell program on my laptop, so I can't use it here at work... stupid stupid !
00:46:04 <gour> boegel: write it (again) ;)
00:46:06 <shapr> That way you get hostname/projectname for your darcs repo, and you can put an index.html into the root of your darcs repo
00:46:07 <integral> shapr: if each developer has hosting for their darcs repos,  why do they need darcsforge?
00:46:43 <gour> shapr: you know, i'm thinking about trac+darcs ;)
00:46:47 <shapr> integral: Because indexing and bandwidth make life easier.
00:46:52 <ProfTeggy> Moin
00:46:52 <shapr> trac+darcs is nice.
00:46:57 <shapr> hiya ProfTeggy
00:47:19 <boegel> gour: yeah, I guess that's the only solution :)
00:47:24 <boegel> @type break
00:47:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
00:47:31 <gour> boegel: :-)
00:47:36 <shapr> integral: Think of an RSS aggregator for darcs. darcsplanet :-)
00:48:12 * integral doesn't think pull is the best model for that :-/
00:48:39 <shapr> Look at it from the ratio of admin effort to developer benefit.
00:49:19 <shapr> Integrating this sort of model into hackage will require only adding a darcs-repo-url field to Cabal, and adding a cronscript to the hackage server.
00:49:33 <gour> shapr: i do not think the whole sourceforge-functionality is required, but basic web services (php,mysql..) + e.g. having trac+darcs would be great
00:49:40 <shapr> No user accounts needed, no admin effort, etc
00:49:49 <integral> sounds simple enough :)
00:50:26 <shapr> It makes it easy to index all of the sources as well.
00:50:58 <shapr> integral: If you think of improvements, I want to hear 'em :-)
00:51:33 <shapr> gour: I'll think about it.
00:52:01 <gour> shapr: hmm..several projects (ghc,gtk2hs) already use haskell.org, so i'm thinking to just add the rest
00:53:09 <gour> shapr: to take advantage of darcs and still be able to host complete project with bugtracker, wiki etc. on one place
00:57:28 <shapr> I may host trac on ScannedInAvian, but I don't think haskell.org will have enough admin effort left over to host trac there.
00:58:32 <boegel> @hoogle inter
00:58:33 <lambdabot> Data.FiniteMap.intersectFM :: Ord key => FiniteMap key elt -> FiniteMap
00:58:33 <lambdabot> key elt -> FiniteMap key elt
00:58:33 <lambdabot> Data.FiniteMap.intersectFM_C :: Ord key => (elt1 -> elt2 -> elt3) ->
00:58:33 <lambdabot> FiniteMap key elt1 -> FiniteMap key elt2 -> FiniteMap key elt3
00:58:33 <lambdabot> Data.IntMap.intersection :: IntMap a -> IntMap b -> IntMap a
00:58:37 <shapr> It might though, it's worth trying.
00:58:45 <boegel> @hoogle intersperse
00:58:45 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
00:58:59 <gour> shapr: well, i don't mind if is on your site or haskell.org
00:59:12 <boegel> @eval intersperse " : " ["foo","bar"]
00:59:13 <lambdabot> ["foo"," : ","bar"]
00:59:23 <boegel> @eval concat $ intersperse " : " ["foo","bar"]
00:59:24 <lambdabot> "foo : bar"
00:59:25 <gour> shapr: and you think it is too complicated to have trac on haskell.org..
01:02:09 <shapr> You either have a sqlite db for each project, or you have a postgresql database. Trac needs either wikispam protection or user authentication. trac+darcs isn't officially in trac yet, so you'll want to track the latest sources...
01:03:27 <gour> shapr: yes, i know that, lele (author) will provide a patch on standard 0.9 tarball
01:03:41 <gour> shapr: i'd prefer to stay with sqlite
01:04:07 <shapr> Does trac do authentication other than htpasswd or svn?
01:07:12 <boegel> @hoogle showFFloat
01:07:13 <lambdabot> Numeric.showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
01:07:18 <gour> shapr: let me check..
01:07:58 <gour> shapr: For better security, it is recommended that you either enable SSL or at least use the “Digest” authentication scheme instead of “Basic”.
01:08:07 <gour> shapr: see http://projects.edgewall.com/trac/wiki/TracCgi
01:08:43 <gour> shapr: and http://projects.edgewall.com/trac/wiki/TracModPython for mod_python
01:14:26 <lomeX> is there a wildcard in case expression? something like else or otherwise?
01:14:52 * sieni tries to understand the list monad
01:20:56 <Cale> lomeX: just use a single variable, or _ if you don't want to give it a name
01:25:20 <lomeX> Cale: thx!
01:26:04 <boegel> @type System.getArgs
01:26:05 <lambdabot> IO [String]
01:26:45 <kowey> gour: would you consider maybe improving the trac howto on the darcs wiki?
01:39:17 <ricebowl> @type maybe
01:39:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:41:03 <ricebowl> hm
01:41:15 <ricebowl> is there any way to get behavior equivalent to sequence but for tuples?
01:41:35 <ricebowl> well, without writing it myself... :p
01:41:45 <Cale> um, what would it do in general?
01:41:53 <Cale> what would its type be?
01:42:18 <ricebowl> :: (Monad m) => (m a, m b) -> m (a, b)
01:43:20 <Cale> uncurry (liftM2 (,))?
01:44:11 <ricebowl> oh swift
01:44:12 <ricebowl> thanks
01:44:16 <ricebowl> I forgot about liftM2
01:44:31 <neologism> @type liftM
01:44:32 <lambdabot> Not in scope: `liftM'
01:44:36 <ricebowl> @type uncurry (liftM3 (,,))
01:44:37 <lambdabot> Not in scope: `liftM3'
01:44:43 <Cale> @type Monad.liftM
01:44:43 <ricebowl> @type uncurry (Monad.liftM3 (,,))
01:44:44 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
01:44:45 <lambdabot> forall (m :: * -> *) a1 a2 a3.
01:44:45 <lambdabot> (Monad m) =>
01:44:45 <lambdabot> (m a1, m a2) -> m a3 -> m (a1, a2, a3)
01:45:15 <ricebowl> how is liftM different from fmap?
01:45:19 <ricebowl> since all monads are functors
01:45:22 <Cale> it's not
01:45:26 <ricebowl> oh, strange
01:46:02 <Cale> it's just implemented in terms of the monad operations, the only reason it exists is because Monad isn't a subclass of Functor (which I think is bad)
01:47:32 * earthy nods in full agreement
01:47:47 <ricebowl> oh, I thought they were
01:48:02 <Cale> they used to be in Haskell 1.4, I think
01:48:07 <ricebowl> well, I can't pretend to really understand since I still don't know what a monad is *or* what a functor is ;)
01:48:22 <ricebowl> Monads are essentially "containers-which-compute-and-could-have-side-effects" right?
01:48:27 <Cale> Every monad is a functor, but not every Monad is a Functor.
01:48:29 <yaarg> anyone have a link that summarises why fp rules? (so i spam people ;)
01:48:32 <earthy> monads are functors by definition, but the Monad class is not a subclass of the Functor class
01:49:14 <boegel> why do my strings change when I pass them to some function ? :(
01:49:48 <boegel> @eval let f = show (head ls) in f ["This","is","just","a","test"]
01:49:49 <lambdabot>  Not in scope: `ls'
01:49:56 <boegel> @eval let f ls = show (head ls) in f ["This","is","just","a","test"]
01:49:57 <lambdabot> "\"This\""
01:50:00 <boegel> like this !
01:50:06 <boegel> what's with the \'s ?
01:50:17 <boegel> this is _really_ annoying
01:51:05 <boegel> @eval let f ls = (head ls) !! 0 in f ["This","is","just","a","test"]
01:51:06 <lambdabot> 'T'
01:51:17 <boegel> makes no sense :(
01:51:23 <boegel> or is that just show talking here ,
01:51:24 <boegel> ?
01:51:45 <basti_> i think it is, yes
01:51:55 <boegel> hmm
01:51:56 <boegel> kay
01:52:09 <boegel> then I have found a bug which wasn't there :P
01:52:19 <boegel> "It's not a bug, it's a feature" comes to mind
01:53:17 <basti_> hehe
01:54:26 <yaarg> @type until
01:54:27 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
01:54:32 <boegel> @eval transpose ["abc",def"]
01:54:32 <lambdabot>  lexical error in string/character literal
01:54:36 <boegel> @eval transpose ["abc","def"]
01:54:37 <lambdabot> ["ad","be","cf"]
01:54:40 <boegel> hmm
01:54:44 <yaarg> hmm
01:55:05 <boegel> kay, my mistake :)
01:57:15 <ricebowl> hm
01:57:30 <ricebowl> why would lookup be the cause of 80% of my program's memory allocation?
01:57:42 <ricebowl> that doesn't make sense :|
01:58:31 <kowey> in case anybody finds this useful, i've whipped up a small literal haskell -> haddock filter
01:58:40 <kowey> that preserves (some) comments
02:15:24 <boegel> @eval concat.intersperse "." ["a","b","c"]
02:15:24 <lambdabot>   Expecting a function type, but found `[a]'
02:15:24 <lambdabot>   Expected type: a1 -> [[a]]
02:15:24 <lambdabot>   Inferred type: [a2]
02:15:31 <boegel> @eval (concat.intersperse) "." ["a","b","c"]
02:15:32 <lambdabot>   Expecting a function type, but found `b'
02:15:32 <lambdabot>   Expected type: a1 -> [[a]]
02:15:32 <lambdabot>   Inferred type: a1 -> [a1] -> [a1]
02:15:39 <boegel> @eval concat $ intersperse "." ["a","b","c"]
02:15:41 <lambdabot> "a.b.c"
02:15:53 <boegel> @type (.)
02:15:54 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
02:16:12 <boegel> @type intersperse
02:16:14 <lambdabot> Not in scope: `intersperse'
02:16:16 <boegel> @type concat
02:16:16 <lambdabot> forall a. [[a]] -> [a]
02:16:19 <boegel> @type List.intersperse
02:16:20 <lambdabot> forall a. a -> [a] -> [a]
02:17:05 <boegel> @eval (concat.intersperse) ("." ["a","b","c"])
02:17:06 <lambdabot>   Expecting a function type, but found `b'
02:17:06 <lambdabot>   Expected type: a1 -> [[a]]
02:17:06 <lambdabot>   Inferred type: a1 -> [a1] -> [a1]
02:17:25 <boegel> is this possible with (.) ? since intersperse takes >1 arg
02:17:55 <dblhelix> @eval (concat . intersperse ".") ["a", "b", "c"]
02:17:56 <lambdabot> "a.b.c"
02:19:04 <dblhelix> @eval curry (concat . uncurry intersperse) "." ["a", "b", "c"]
02:19:05 <lambdabot> "a.b.c"
02:19:36 <boegel> dblhelix: thanks :)
02:19:51 <dblhelix> boegel: you're more than welcome :)
02:20:12 <boegel> @type writeFile
02:20:13 <lambdabot> FilePath -> String -> IO ()
02:21:59 <dblhelix> @eval let f <.> g = curry (f . uncurry g) in (concat <.> intersperse) "." ["a", "b", "c"]
02:22:00 <lambdabot> "a.b.c"
02:23:15 * dblhelix dubs (<.>) the "boegel operator"
02:24:27 <dblhelix> so, what about (concat `boegel` intersperse) "e" ["bo", "g", "l"]?
02:24:48 <dblhelix> @eval let boegel f g = curry (f . uncurry g) in (concat `boegel` intersperse) "e" ["bo", "g", "l"]
02:24:49 <lambdabot> "boegel"
02:25:27 <Cale> boegel = (.) . (.)
02:26:01 <dblhelix> @pl \f -> \g -> curry (f . uncurry g)
02:26:01 <lambdabot> (curry .) . (. uncurry) . (.)
02:26:51 <Cale> @type (.) . (.)
02:26:52 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
02:27:11 <Cale> @type \f g -> curry (f . uncurry g)
02:27:12 <lambdabot> forall c c1 a b. (c1 -> c) -> (a -> b -> c1) -> a -> b -> c
02:27:28 <gour> kowey: excuse me, i was away but didn't put a notice
02:27:53 <dblhelix> @eval let boegel = (.) . (.) in (concat `boegel` intersperse) "." ["a", "b", "c"]
02:27:54 <lambdabot> "a.b.c"
02:28:14 <gour> kowey: in what sense to improve trac howto?
02:29:00 <kowey> i got the impression that you had some security ideas that you could incorporate into the howto
02:29:45 <gour> kowey: no, i was just answering shapr's inquiries in regard
02:30:11 <gour> kowey: i only have trac+darcs installed on my localhost without too much bothering with security :-)
02:30:44 <kowey> hmm... ok... :-) my goal was just to collect the trac+darcs best practices into
02:30:56 <kowey> a simple A-Z howto so that various darcsforges could spring up
02:31:46 <gour> kowey: all i can say that pulling the code from trac+darcs repo works on my machine
02:32:32 <kowey> good deal... do you work with other coders on the same repo?
02:33:23 <gour> kowey: not (yet) - still working on learning haskell to be able to start desired project ;)
02:33:45 <gour> kowey: but definitely i plan (hope) to find some helper :-)
02:33:58 <boegel> @type append
02:33:59 <lambdabot> Not in scope: `append'
02:34:00 <kowey> :-) good luck
02:34:07 <gour> kowey: so it will become an issue to have working trac+darcs
02:34:24 * gour looking at TracOnDarcs wiki
02:34:29 <dblhelix> boegel: append is called (++) ;)
02:34:58 <boegel> @eval (++) "\n" "boe"
02:34:59 <lambdabot> "\nboe"
02:35:06 <boegel> I want it the other way around :)
02:35:12 <boegel> @type flip
02:35:13 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
02:35:22 <boegel> hmm, nah
02:36:24 <dblhelix> @eval flip (++) "gel" "boe"
02:36:26 <lambdabot> "boegel"
02:36:40 <gour> kowey: thanks, btw, good info on the wiki, wasn't aware of it
02:36:59 <boegel> oh :)
02:37:11 <kowey> hope it helps... people seem to have some better ideas, but nobody's editing the page
02:37:24 <kowey> (not entirely true, there have been some helpful tweaks)
02:37:50 <gour> kowey: well, i'll go through, try to update my repo and see if i can think of something
02:38:09 <gour> kowey: in any case, your contribution is most welcome
02:38:14 <shapr> jiihaa
02:38:16 * shapr boings
02:38:49 <gour> shapr: what happened?
02:39:01 <boegel> how big can values of Int be ?
02:39:07 <ricebowl> 2^31 - 1
02:39:10 <ricebowl> or something like that
02:39:21 <dons> @eval maxBound :: Int
02:39:22 <lambdabot> 2147483647
02:39:50 <dons> let's see...
02:39:55 <dons> @eval maxBound :: Integer
02:39:56 <lambdabot>  add an instance declaration for (Bounded Integer)
02:39:56 <lambdabot>   In the expression: maxBound :: Integer
02:39:56 <lambdabot>   In the definition of `xxxx': xxxx = maxBound :: Integer
02:40:02 <ricebowl> @type liftM
02:40:02 <dons> :)
02:40:03 <lambdabot> Not in scope: `liftM'
02:40:08 <ricebowl> @type Monad.liftM
02:40:08 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
02:40:32 <boegel> roughly 2 billion.. ok, that should do it
02:40:40 <boegel> @eval maxBound :: Integer
02:40:41 <lambdabot>  add an instance declaration for (Bounded Integer)
02:40:41 <lambdabot>   In the expression: maxBound :: Integer
02:40:41 <lambdabot>   In the definition of `xxxx': xxxx = maxBound :: Integer
02:40:55 * ricebowl is having trouble figuring IO out :/
02:41:11 <ricebowl> say for the moment that I have a function with type (Graph, String) -> (Graph, IO ())
02:41:22 <shapr> gour: I got to spend time with my girlfriend.
02:41:44 <ricebowl> I want to loop over the lines of input and execute this function, but I need the current state
02:42:19 <ricebowl> the way I solved it before was pass in an IO () and then sequence them, but then that accumulates I/O until all computation has finished--very nasty :|
02:42:36 * ricebowl is totally lost
02:43:26 <gour> shapr: ahh..i though it is something more fp-oriented :-)
02:44:20 <boegel> @hoogle Float -> Int
02:44:21 <lambdabot> Graphics.UI.ObjectIO.StdSystem.hmm :: Float -> Int
02:44:21 <lambdabot> Graphics.UI.ObjectIO.StdSystem.vmm :: Float -> Int
02:44:21 <lambdabot> Graphics.UI.ObjectIO.StdSystem.hinch :: Float -> Int
02:44:31 <boegel> @index fromIntegral
02:44:32 <lambdabot> Prelude
02:45:03 <boegel> @type round
02:45:04 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
02:45:59 <ricebowl> nm, yay, I figured it out :D
02:48:58 <shapr> gour: Well, I would rather not have any side effects, it's true.
02:49:20 <shapr> gour: If you want fp-related niftiness, read my blog.
02:50:03 <xerox2> yow
02:50:10 <shapr> shazam!
02:50:12 <shapr> @yow !
02:50:12 <lambdabot> Didn't I buy a 1951 Packard from you last March in Cairo?
02:50:20 <xerox2> I need gtk2hs's darcs repo url!
02:50:20 <shapr> I think not!
02:50:33 <xerox2> I want to do cairo programming on trip, woot!
02:51:15 <xerox2> Oh, it was on the site, false allarm.
02:51:54 <gour> xerox2:  http://haskell.org/gtk2hs/darcs/gtk2hs
02:52:16 <xerox2> Thanks!
02:52:48 <boegel> xerox2: any news from the google guys already ?
02:53:00 <xerox2> boegel: yep!
02:53:15 <xerox2> http://code.google.com/
02:53:30 * xerox2 hops
02:53:34 <shapr> Mooninite1: Have you written any Haskell fractal code?
02:53:45 * xerox2 woots at fractals
02:53:52 <xerox2> shapr: I'm going to see Mandelbrot today!
02:53:57 <shapr> awesome! take pix!
02:54:02 <shapr> Benoit himself!
02:54:04 <xerox2> Will do!
02:54:27 <shapr> Hey, can you ask him whether a fractal would make a good compression dictionary? ;-)
02:54:45 <ricebowl> Array isn't a monad, is it?
02:54:49 <boegel> xerox2: in which category is your project ?
02:55:06 * sieni wonders why sets are implemented usually stupidly
02:55:29 <sieni> The most natural thing is to represent Set a as a -> Bool
02:55:55 <boegel> @type zip
02:55:56 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
02:57:55 <xerox2> boegel: its sorted by mentoring organization (under Google)
03:03:37 <boegel> xerox2: cool ! did you get payed ?
03:03:52 <xerox2> boegel: the cash is flowing, or something :-)
03:05:35 <ski_> sieni : how to fold on such a set ?
03:05:57 <ski_> (also, how to map over it ?)
03:07:18 <sieni> ski_: you don't :-) You can pull it back to get f^{-1}A = {a | f(a) \in A}
03:07:35 <xerox2> config.status: error: cannot find input file: Makefile.in
03:07:39 <xerox2> brhmbllgh.
03:08:10 <ski_> sieni : and in haskell ? :)
03:09:10 <sieni> ski_: newtype Set a = SetI (a -> Bool)
03:09:23 <ski_> the map, i meant ..
03:09:29 <sieni> pullBackSet :: (a -> b) -> Set b -> Set a
03:09:29 <sieni> pullBackSet f (SetI x) = SetI (x . f)
03:09:45 <ski_> that's a contravariant map
03:09:51 <sieni> yes
03:09:54 <ski_> i want a covariant one :)
03:10:23 <ski_> can you code f^{-1}A = {a | f(a) \in A} in haskell ?
03:10:40 <sieni> ski_: I just gave it
03:11:06 <ski_> oh, right
03:11:39 <sieni> It's true that covariant map doesn't bend well to the a -> Bool representation
03:11:59 * ski_ misread, and thought that was the covariant map
03:12:35 <ski_> actually .. this is related to e.g. prolog predicates
03:12:54 <ski_> (sieni : know prolog ?)
03:14:35 <sieni> ski_: some... I read most of Clocksin-Mellish book when I was a kid
03:14:51 <ski_> if we have a predicate
03:14:59 <ski_> foo(A)
03:15:01 <sieni> I don't know if I remember much :-)
03:15:29 <ski_> some such predicates can be used as enumerators ..
03:15:32 <ski_> e.g.
03:16:04 <ski_> ?- prime(P).  could give successive solutions P = 2  ;  P = 3  ; P = 5  ;  ...
03:16:29 <ski_> this corresponds to implementing a set as a list or tree or something like that
03:16:39 <ski_> we can also use it like
03:16:52 <ski_> ?- prime(17).  which succeeds
03:16:59 <ski_> ?- prime(18).  which fails
03:17:18 <ski_> so, now, it behaves like  a function  Integer -> Bool
03:17:27 <ski_> see what i mean ?
03:17:39 <sieni> I think so
03:18:16 <ski_> some predicates only support the enumeration usage
03:18:26 <ski_> and some only support the testing usage
03:18:40 <ski_> (and some, like this prime(P), support both)
03:19:19 <ski_> (the set i spoke of here is the characteristic set of the predicate, of course)
03:20:01 <sieni> I guess to get both, one needs some ordering consistent with the enumeration in order to detect, whether your element is in the list or not
03:21:02 <ski_> or, at least some way to narrow down the subset where the input might be found, until it either consist of that element, or is empty ..
03:22:29 <shapr> Has anyone built monadius on Linux?
03:22:42 <ski_> i guess the simplest things to enumerate are finite .. though ordered countable is also quite simple
03:23:06 <ski_> (enumerating all trees is more complicated)
03:23:14 * ski_ wonders what monadius is
03:23:25 <shapr> http://www.geocities.jp/takascience/windows/monadius_e.html
03:25:45 <vegai> whoa, a nemesis clone
03:25:58 <vegai> (apparently called 'gradius' by the non-c64 folk)
03:26:10 <shapr> The sound won't link :-/
03:26:48 <shapr> oh. foreign import ccall "open_audio_w" openAudio_w :: CString -> CString -> AudioHandle -> IO ()
03:27:00 <shapr> I betcha that's not at all how ALSA handles sound.
03:27:21 <joelr> g'day everyone
03:27:29 <shapr> joelr: Your blog post is tantalizing, but not fulfilling ;-)
03:27:46 <joelr> shapr: haha :-) i thought i lost my readership
03:27:50 <sieni> hmm... it seems to be a not-so-good idea to use Sawfish as the window damager on Mac OS X in rootless mode
03:27:54 <shapr> Though I guess finishing a five week long Haskell project is a good thing.
03:28:05 <joelr> shapr: i will post more, except the project is still not finished :(
03:28:06 <joelr>     appU = liftM3 (,) appU appU appU
03:28:08 <sieni> When you use expose to select windows, then
03:28:14 <shapr> joelr: Ok, I look forward to it.
03:28:16 <joelr> is there a "," for triples?
03:28:16 <sieni> Sawfish gets badly confused ;-)
03:28:23 <shapr> joelr: I really want to hear how well your model based testing went.
03:28:46 <joelr> shapr: i did not find it necessary (model testing) for packing/unpacking binary data :-)
03:28:48 <ski_> @type (,,)
03:28:48 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
03:28:58 <joelr> coolio! thanks ski
03:29:24 <joelr> shapr: i have to finish describing a whole lot more packets today, otherwise i don't get paid tomorrow :(
03:29:32 <joelr> shapr: this weekend should be time for blogging
03:29:35 <shapr> ok
03:29:45 * shapr hacks the sound playing out of monadius
03:30:07 <joelr> shapr: the next project should be the really cool one :) sort of like dazzle but for collusion in poker
03:30:25 <joelr> they wanted me to do java :D
03:30:26 <joelr> hehe
03:30:40 <joelr> i isaid i'll deliver them a working prototype which they can then rewrite in java if they wish
03:30:44 <joelr> :D
03:31:28 <shapr> yow
03:31:48 <ricebowl> isn't there a way to transform an array? :/
03:32:04 <shapr> What are you trying to do to your arry?
03:32:09 <ricebowl> well
03:32:13 <ricebowl> use it for one.
03:32:23 <ricebowl> but besides that, I basically want to replace lists with an array
03:32:31 <ricebowl> rather, a list with an array
03:32:56 <ricebowl> it's fixed-size, so I want something that's O(1) traversal
03:33:51 <ricebowl> basically I want to make a 63-way tree
03:34:09 <ricebowl> and writing it all out 63 times would be, well, annoying.
03:34:35 <shapr> Yes, arrays do O(1) lookup. 63-way tree? huh?
03:34:44 <ricebowl> here:
03:35:00 <ricebowl> data Tree = Leaf | Node (Tree t1) (Tree t2) (Tree t3) ... (Tree t63)
03:35:25 <shapr> oh
03:35:29 <ricebowl> I thought it might be a little easier to manage with data Tree = Leaf | Node (Array Tree a)
03:35:44 <ricebowl> er, pardon my syntactic errors
03:35:48 <ricebowl> anyway, you get the idea.
03:35:51 <shapr> Hm, probably so.
03:36:02 <shapr> So, does it work?
03:36:05 <ricebowl> no
03:36:10 <shapr> Why not?
03:36:18 <ricebowl> because I'm a clueless novice
03:36:20 <ski_> you want to map over the array ?
03:36:33 <shapr> I mean like, what doesn't work?
03:36:37 <ricebowl> no, I just want to be able to modify the array
03:36:46 <ricebowl> shapr - you're missing the point. I know what I want to do, but don't know how to do it. :p
03:36:47 <shapr> I'm a clueless novice too, just not in Haskell :-)
03:37:01 <ski_> 'Array' is immutable
03:37:04 <ricebowl> I know
03:37:10 <ski_> possibly you want IOArray or STArray ?
03:37:11 <ricebowl> which is fine. So is everything else that I have used.
03:37:19 <shapr> What modifications do you want to make?
03:37:31 <ricebowl> shapr - I just want something similar to map
03:37:33 <ricebowl> @type map
03:37:33 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
03:37:41 <ski_> instance Ix i => Functor (Array i)
03:37:45 <ricebowl> I don't care if I have to copy; I just want to be able to modify the array!
03:38:02 <ski_> fmap :: Ix i => (a -> b) -> (Array i a -> Array i b)
03:38:15 <ski_> you can use that to map over an Array
03:38:21 <ricebowl> yes
03:38:25 <ricebowl> but I still have a problem
03:38:35 <ski_> yes ?
03:38:45 <ricebowl> I want something like :: Num i => (i, a) -> Array i a -> Array i a
03:39:20 <ski_> you want to change one element, at a specified index ?
03:39:23 <ricebowl> right
03:39:41 <ricebowl> or to expand the array
03:39:52 <ski_> /
03:40:01 <ski_> @type (Data.Array.//)
03:40:02 <lambdabot> forall e i.
03:40:02 <lambdabot> (GHC.Arr.Ix i) =>
03:40:02 <lambdabot> GHC.Arr.Array i e -> [(i, e)] -> GHC.Arr.Array i e
03:40:12 <xerox_> Hola.
03:40:25 <ski_> that takes a list of array updates, so if you just want to change one element, pass a singleton list
03:40:53 <ricebowl> ah, that was what I was looking for, guess I misunderstood the docs
03:41:00 <ricebowl> hm...
03:41:05 <ski_> @type let update (i,a) arr = array Data.Array.// (i,a) in update
03:41:06 <lambdabot> Not in scope: `array'
03:41:08 <ricebowl> that's inherited from something, isn't it?
03:41:14 <ski_> @type let update (i,a) arr = arr Data.Array.// (i,a) in update
03:41:14 <lambdabot>   Couldn't match `[(i, e)]' against `(a, b)'
03:41:14 <lambdabot>   Expected type: [(i, e)]
03:41:21 <ricebowl> @type (//)
03:41:22 <lambdabot> Not in scope: `//'
03:41:25 <ski_> @type let update (i,a) arr = arr Data.Array.// [(i,a)] in update
03:41:26 <lambdabot> forall a b.
03:41:28 <lambdabot> (GHC.Arr.Ix a) =>
03:41:28 <lambdabot> (a, b) -> GHC.Arr.Array a b -> GHC.Arr.Array a b
03:41:35 <ski_> that's your function
03:41:38 <ricebowl> yeah, that's easy enough
03:41:40 <ricebowl> thanks
03:41:54 <ricebowl> heh I'm still a little lost, but at least I can play around with arrays now
03:41:56 <ricebowl> :/
03:42:05 <ski_> you can of course skip 'Data.Array', if you import that module unqualified
03:42:12 <ricebowl> *nods*
03:42:35 <ricebowl> I'm playing with the profiler trying to improve my app's efficiency
03:42:57 <ricebowl> it reports that 80% of my program's memory is allocated in a function that just calls lookup
03:43:40 <shapr> foo, monadius doesn't call glutInit
03:44:56 <boegel> @type zipWith
03:44:57 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
03:45:35 * ski_ 'd like typechecker to respond with 'Data.Array.Array' instead of 'GHC.Arr.Array' even if that's where it's defined
03:46:09 <boegel> @eval zipWith concat [[1,2],[4,5],[7,8]] [[3,0],[6,0],[9,0]]
03:46:10 <lambdabot>   Expecting a function type, but found `[a]'
03:46:10 <lambdabot>   Expected type: [[a]] -> b -> c
03:46:10 <lambdabot>   Inferred type: [[a]] -> [a]
03:46:24 <boegel> @eval zipWith (++) [[1,2],[4,5],[7,8]] [[3,0],[6,0],[9,0]]
03:46:25 <lambdabot> [[1,2,3,0],[4,5,6,0],[7,8,9,0]]
03:46:50 <boegel> @eval zipWith (:) [1..4] [5..8]
03:46:51 <lambdabot>  add an instance declaration for (Num [a])
03:46:51 <lambdabot>   In an arithmetic sequence: [5 .. 8]
03:46:55 <boegel> 5:8
03:47:01 <boegel> @eval 5:8:[]
03:47:03 <lambdabot> [5,8]
03:47:24 <boegel> @eval zipWith (:) [1..4] (zipWith (:) [5..8] (repeat []))
03:47:25 <lambdabot> [[1,5],[2,6],[3,7],[4,8]]
03:48:05 <ski_> @eval foldr (zipWith (:)) (repeat []) [[1..4],[5..8]]
03:48:06 <lambdabot> [[1,5],[2,6],[3,7],[4,8]]
03:48:28 <boegel> @eval transpose [[1..4],[5..8]]
03:48:29 <lambdabot> [[1,5],[2,6],[3,7],[4,8]]
03:48:43 <ski_> hm, that's nice
03:49:15 <shapr> Anyone know how to call glutInit inside HOpenGL?
03:49:16 <ski_> hadn't thought of that being concat
03:52:51 <ski_> @eval let uncons (x:xs) = (x,xs) in List.unfoldr (\xss -> if all null xss then Nothing else Just (unzip (map uncons xss))) [[1..4],[5..8]]
03:52:52 <lambdabot> [[1,5],[2,6],[3,7],[4,8]]
03:53:09 <ski_> boegel : that's how i think of concat
03:53:10 <shapr> @index try
03:53:10 <lambdabot> Control.Exception, System.IO.Error, Text.ParserCombinators.Parsec.Prim,
03:53:10 <lambdabot> Text.ParserCombinators.Parsec
03:53:14 <shapr> hmm
03:53:25 <ricebowl> another question on arrays -- how do you make them bigger? :p
03:53:26 <ski_> (boegel : it looks nicer in prolog :)
03:53:47 <ricebowl> @eval Array.array (0, 4) (zip [0..4] (repeat False))
03:53:48 <lambdabot>  Not in scope: `Array.array'
03:54:38 <ricebowl> @eval Data.Array.array (0, 4) (zip [0..4] (repeat False))
03:54:39 <lambdabot>  Not in scope: `Data.Array.array'
03:54:51 <ski_> hm, possibly arrays are not imported to be in scope, in @eval ..
03:55:12 <ricebowl> @eval array (0, 4) (zip [0..4] (repeat False))
03:55:13 <lambdabot>  Not in scope: `array'
03:55:19 <ricebowl> blah.
03:55:29 <shapr> Wow, this guy has bunches of Haskell games on his website.
03:55:51 * shapr plays Haskello, an Othello clone
03:56:04 <ricebowl> well, anyway, Array.// does not auto-extend the array, as I figured it wouldn't
03:56:13 <ricebowl> so I'm not really sure how to do it.
03:56:18 <ricebowl> the length isn't really part of the type.
03:56:24 <ricebowl> do you convert to a list and then back to an array?
03:56:27 <ricebowl> or is there a better way?
03:57:38 <boegel> @eval [1,2]++[]
03:57:40 <lambdabot> [1,2]
03:58:08 <shapr> ricebowl: I don't know, I haven't used arrays much.
03:58:45 <ricebowl> hm, ok
04:00:01 <ricebowl> heh, would have been a bit easier if the lower bound was implied to be 0 :/
04:03:43 <ski_> sieni : mapSet :: (Countable a,Eq b) => (a -> b) -> (Set a -> Set b); mapSet f (SetI isInA :: Set a) = SetI (`elem` map f (filter isInA (enumeration :: [a]))); class Countable a where enumeration :: [a]
04:03:47 <jlouis> Hah, Conjure is 6.7% finished ;)
04:03:57 <jlouis> The storage wrapper is actually quite fun to write
04:04:14 <wolverian> conjure?
04:06:56 <jlouis> wolverian: a bittorrent client in haskell ;)
04:07:33 <wolverian> jlouis, neat. :) how do you figure the %?
04:08:54 <jlouis> wolverian: I am pretty sure I can do it under 10k lines of code, since that is what the original bittorrent client in python has. It also has a GTK frontend, I do not go for.
04:09:03 <jlouis> So, 1% == 100 lines of code
04:10:24 <wolverian> jlouis, ah. okay.
04:11:13 <vegai> even the C++-implementation (ctorrent) is less than 10k
04:11:56 <vegai> 5523 lines (*.h *.cpp)
04:12:00 * ski_ leaves
04:12:13 <dons> I should remove this UIi stuff from the hoogle db.
04:12:59 * dons attempts to mount an ipod nano on openbsd. fingers crossed..
04:13:17 <boegel> @eval zip [1,2,3] [[0.3,0.4,0.5],[0.6,0.7,0.8],[0.1,0.2,0.3]]
04:13:18 <lambdabot> [(1,[0.3,0.4,0.5]),(2,[0.6,0.7,0.8]),(3,[0.1,0.2,0.3])]
04:15:18 <sieni> ski_: where do you need Eq b?
04:15:49 <ski_> @type elem
04:15:49 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
04:16:13 <ricebowl> how do you make multiple class assertions?
04:16:21 <ricebowl> i.e. I need to say Ix a and Num a
04:16:33 <ski_> (Ix a,Num b) =>
04:16:38 <ski_> (Ix a,Num a) =>
04:16:47 <ricebowl> hm, I missed the parens; thanks
04:18:20 <ski_> (sieni : ok ?)
04:22:18 <sieni> ski_: yes
04:25:43 <boegel> @type uncurry
04:25:44 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
04:27:01 <ski_> (boegel : s/all/any/ in that alternate concat using List.unfoldr, of course)
04:28:50 <dons> hello Soliah
04:29:07 <Soliah> hi
04:29:09 <dons> learning haskell, or you know it already?
04:29:24 <Soliah> i'd say know some of it already :)
04:29:33 <dons> you in sydney?
04:29:38 <Soliah> yup :)
04:29:46 <dons> learn haskell at unsw?
04:29:49 <Soliah> ooh looked at my mask hey?
04:29:50 <Soliah> OHH!
04:29:52 <Soliah> lolz yes
04:29:56 <Soliah> i'm scared now ;p
04:29:57 <Soliah> jk jk
04:30:04 <xerox_> he's there too :)
04:30:10 <dons> hehe
04:30:14 <Soliah> oh wow
04:30:18 <Soliah> cse :O
04:30:28 <dons> :)
04:30:40 <Soliah> are you a tutor, lecturer?
04:30:51 <dons> phd student, i tutor 3161 and 2041
04:30:54 <dons> sometimes 1021
04:31:04 <Soliah> soft cons?
04:31:08 <dons> yup
04:31:13 <Soliah> are you michael?
04:31:19 <dons> nope. i'm dons
04:31:21 <Soliah> oh
04:31:21 <Soliah> haha
04:31:32 <Soliah> michael is my tutor
04:31:40 <dons> ah, you doing 2041 this session?
04:31:42 <Soliah> yup
04:31:44 <Soliah> i'm screwed
04:31:47 <Soliah> ;(
04:32:09 <dons> oh, so you should have taken my class ;) then you would have got lots of extra haskell hints :)
04:32:15 <Soliah> haha
04:32:21 <Soliah> it's more like I've lost motivation
04:32:31 <Soliah> I pretty much stopped doing work around week 6 (mid session break)
04:32:37 <dons> nah, just do all the practice prac exams, in each language: just perl, sh and C will do
04:32:39 <Soliah> so yea, oh well
04:33:08 <Soliah> back to haskell
04:33:11 <Soliah> i notice alot of the first years i know
04:33:15 <Soliah> are doing comp 1091 now?
04:33:16 <Soliah> instead of 1a?
04:33:22 <Soliah> its such a shame
04:34:00 <dons> yeah. but there's some kind of restructuring happening, and the haskell will be taught in 2nd session I think
04:34:24 <Soliah> oooh 3161 looks interesting
04:34:35 <dons> yeah, it's great :)
04:34:39 <dons> all in haskell too
04:35:00 <Soliah> OOH
04:35:02 <Soliah> how i miss haskell
04:35:27 <shapr> JohnMeacham: Hey, can the GRIN optimizer implement optimistic evaluation directly?
04:35:35 * shapr suspects so
04:36:40 <shapr> Soliah: So hang out here and write some code!
04:36:55 <shapr> We're friendly and cheerful!
04:36:58 <Soliah> haha yes i should :)
04:37:19 <Soliah> right now though, i have a pressing java assignment to do :<
04:37:39 * ski_ leaves-leaves
04:38:18 <Soliah> woooo
04:38:22 <dons> hooray! : sd0 at scsibus0 targ 1 lun 0: <Apple, iPod, 1.62> SCSI0 0/direct removable
04:38:22 <Soliah> this assignment looks like fun
04:38:31 <Soliah> (haskell one)
04:38:49 <dons> yeah, we write an interpreter from scratch
04:38:52 <xerox_> dons: got an iPod? :)
04:38:55 <dons> for a haskell like language
04:39:08 <dons> xerxo, yep. now my kernel behaves itself, things are looking better :)
04:39:15 <xerox_> hehe.
04:39:21 <jlouis> spank the kernel if it doesn't behave ;)
04:39:27 <xerox_> I'm using a friend's ibook atm, it's kinda cool.
04:39:37 <Soliah> tiger?
04:39:42 <xerox_> Yep.
04:39:44 <Soliah> <3
04:39:46 <Soliah> i love my ibook
04:40:05 <dons> hey jlouis, this is on openbsd, so it's nice the nano gets detected :)
04:40:20 <jlouis> dons: of course it does, this is OpenBSD, not Tiger ;)
04:40:23 <dons> now, to void my warrenty by mounting the fs
04:40:27 <xerox_> hehe, i find it difficult to type but i'm in difficult environmental conditions ;)
04:40:37 <dons> jlouis :D
04:41:10 <Soliah> what time are the lectures for 3161 dons?
04:41:29 <Soliah> i've noticed that comp courses tend to be late :(
04:41:38 <dons> whoo: paprika$ sudo mount /ipod
04:41:38 <dons> paprika$ cd /ipod
04:41:38 <dons> paprika$ ls
04:41:39 <dons> Calendars     Contacts      Notes         iPod_Control
04:41:42 <jlouis> Soliah: that is certainly not a coincidence
04:41:42 <dons> :)
04:41:58 <Soliah> hehe
04:42:00 <jlouis> Programming is easiest at night. Or so I've come to think
04:42:03 <dons> Soliah, hmm, probably 11-12am?
04:42:14 <dons> and tuts around 3 or so, whenever I wake up :)
04:42:20 <shapr> jlouis: fewer distractions.
04:42:24 <jlouis> shapr: indeed
04:42:25 <Soliah> oh wait
04:42:28 <Soliah> they're pretty early
04:42:29 <Soliah> wow
04:42:34 <Soliah> security is like 6-9pm :\
04:42:49 <jlouis> Here at work, I need my headphones and my big monitor to hide behind, or it is impossible to get anything done
04:42:50 <shapr> jlouis: But you can also reinforce your work via Pair Programming
04:43:04 <Soliah> extreme programming ftw :D
04:43:14 <shapr> I have a "geek shield" that I hang over my monitor and my head.
04:43:45 <jlouis> shapr: I am the lone programmer, but code reviews are good ;) Pair programming does not win in my world
04:43:54 <Soliah> dons: what is your phd in? :D
04:44:06 <shapr> Have you ever tried pair programming with someone on an equal level?
04:44:07 <jlouis> Soliah: let us guess: Semantics of some kind
04:44:23 <Soliah> hmm
04:44:33 <jlouis> shapr: That might be the problem. Every time I program with other people I am better than them
04:44:56 <dons> Soliah, dynamically extensible, statically typed languages. aka dynamic linking with haskell
04:45:03 <shapr> That's happened to me. It's good for teaching those people, but not much fun for me.
04:45:29 <dons> Soliah, meet lambdabot, your friendly cse bot:
04:45:31 <dons> @version
04:45:31 <lambdabot> lambdabot 3p168, GHC 6.5.20050806 (Linux i686)
04:45:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:45:36 <dons> @eval map (+1) [1..10]
04:45:37 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
04:45:39 <dons> @type map
04:45:39 <jlouis> Anyway, back to work. There is some perl that has to run ... ;)
04:45:39 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
04:45:43 <Soliah> woah
04:45:49 <Soliah> @t foldr
04:45:49 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
04:45:49 <lambdabot> null topic-snoc topic-tail topic-tell type pl wn
04:45:53 <Soliah> @type foldr
04:45:53 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
04:46:10 <Soliah> i love it!
04:46:19 <dons> lambdabot loves you too :)
04:46:24 <shapr> @botsnack
04:46:25 <lambdabot> :)
04:46:30 <dons> @vixen do you love Soliah?
04:46:30 <lambdabot> love is a powerful word...
04:46:40 <shapr> @vixen a/s/l ?
04:46:40 <Soliah> haha
04:46:40 <lambdabot> 19/f/California
04:46:55 <kowey> ahem... would Gregory Wright be around by any chance?
04:47:23 * shapr doesn't know
04:51:02 * dons gets some sleep
04:51:52 <Soliah> sleep well :)
04:52:06 <Soliah> i'll attempt 3161's assignment 1 i think
04:52:10 <Soliah> this summer ^_^
05:01:54 * shapr boings
05:02:05 * xerox_ too
05:02:15 * xerox_ is intoxicated by smoke of people here...
05:02:36 <ulfdoz> save the state - start smoking!
05:02:45 <xerox_> :-(
05:02:48 * xerox_ chougs
05:02:52 <xerox_> *coughs
05:03:36 * ulfdoz dict.leo.orgs
05:08:11 <vegai> are there any GUI/Graphics bindings for any non-ghc compilers?
05:08:47 <shapr> vegai: I think FranTk is for Hugs?
05:09:16 <boegel> shapr: FranTk is broken, very broken... but it should work with Hugs, yeah
05:09:35 <vegai> anything for nhc98?
05:09:53 <boegel> no idea, never tried that
05:27:33 <shapr> hiya Mista Goerzen
05:28:27 <CosmicRay> morning shapr
05:28:32 <CosmicRay> sorry I couldn't come up with anything clever ;-)
05:28:39 <CosmicRay> it's still early over here
05:31:28 <boegel> @type curry
05:31:28 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
05:31:38 <boegel> @type triple
05:31:39 <lambdabot> Not in scope: `triple'
05:31:43 <boegel> @type pair
05:31:44 <lambdabot> Not in scope: `pair'
05:31:55 <boegel> @hoogle a -> b -> c -> (a,b,c)
05:31:56 <lambdabot> No matches, try a more general search
05:32:04 <boegel> @hoogle a -> b -> (a,b)
05:32:05 <lambdabot> No matches, try a more general search
05:32:08 <boegel> hmm
05:32:57 <boegel> I'm using a function f which uses only the first x elements of some lists that it gets from some function g
05:33:20 <boegel> so: g x y z = f (take n x) (take n y) (take n z)
05:33:31 <boegel> any way to do this nicer ?
05:33:42 <boegel> it's more complicated, but it comes down to this
05:34:27 <boegel> @index tuple
05:34:28 <lambdabot> bzzt
05:34:41 <boegel> @index triple
05:34:41 <lambdabot> bzzt
05:35:22 <xerox_> @pl \x y z -> f (take n x) (take n y) (take n z)
05:35:23 <lambdabot> flip flip (take n) . ((.) .) . (. take n) . f . take n
05:36:06 <boegel> :)
05:36:20 <boegel> @simplify
05:36:21 <lambdabot> Unknown command, try @listcommands.
05:36:26 <boegel> @listcommands
05:36:26 <lambdabot> use listcommands [module|command], please. Modules are:
05:36:26 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
05:36:26 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
05:36:26 <lambdabot> topic type version vixen where
05:36:40 <boegel> @elite yow
05:36:41 <lambdabot> Y0\/\/
05:36:41 * xerox_ is having big fun
05:36:56 <xerox_> @vixen are you having big fun?
05:36:56 <lambdabot> i try to be fun... what do you think?
05:40:03 <boegel> @type zip
05:40:04 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
05:40:54 <araujo> Morning!
05:42:16 <boegel> yo araujo
05:42:19 <boegel> @type zipWith
05:42:20 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
05:43:15 <boegel> @eval zipWith (\(x,y) -> x + y) [1..4] [5..8]
05:43:16 <lambdabot>  add an instance declaration for (Num (b -> c, b -> c))
05:43:16 <lambdabot>   In an arithmetic sequence: [1 .. 4]
05:43:24 <boegel> @eval zipWith (\xy -> x + y) [1..4] [5..8]
05:43:25 <lambdabot>  Not in scope: `y'
05:43:33 <boegel> @eval zipWith (\(xy) -> x + y) [1..4] [5..8]
05:43:34 <lambdabot>  Not in scope: `y'
05:43:49 <boegel> @eval zipWith (+) [1..4] [5..8]
05:43:50 <lambdabot> [6,8,10,12]
05:44:00 <boegel> how do I note this with lambda syntax ?
05:45:06 <araujo> ?
05:45:18 <sieni> eval zipWith (\x y -> x + y) [1..4] [5..8]
05:45:24 <sieni> @eval zipWith (\x y -> x + y) [1..4] [5..8]
05:45:25 <lambdabot> [6,8,10,12]
05:45:35 <boegel> sieni: oh, stupid me :) thanks
05:49:52 <boegel> @eval zipWith (\x y -> map (/y) x) [[6,12,24],[18,36,72]] [2,3]
05:49:53 <lambdabot> [[3.0,6.0,12.0],[6.0,12.0,24.0]]
05:51:10 <boegel> @eval zipWith (\x y -> map (/y) x) (transpose [[2,3],[4,6],[6,9],[8,12]]) [2,3]
05:51:11 <lambdabot> [[1.0,2.0,3.0,4.0],[1.0,2.0,3.0,4.0]]
05:51:18 <boegel> @eval transpose $ zipWith (\x y -> map (/y) x) (transpose [[2,3],[4,6],[6,9],[8,12]]) [2,3]
05:51:19 <lambdabot> [[1.0,1.0],[2.0,2.0],[3.0,3.0],[4.0,4.0]]
05:51:36 <boegel> any other way to do this ^ ? without transpose maybe ?
05:52:11 <vegai> @pl transpose $ zipWith (\x y -> map (/y) x) (transpose [[2,3],[4,6],[6,9],[8,12]]) [2,3]
05:52:12 <lambdabot> transpose (zipWith (flip (map . flip (/))) (transpose [[2, 3], [4, 6], [6,
05:52:12 <lambdabot> 9], [8, 12]]) [2, 3])
05:52:20 <vegai> heh. Ok, not like that.
05:52:32 <boegel> :)
05:53:15 <boegel> @pl (\a b -> transpose $ zipWith (\x y -> map (/y) x) (transpose a) b
05:53:16 <lambdabot> (line 1, column 66):
05:53:16 <lambdabot> unexpected end of input
05:53:16 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or ")"
05:53:17 <boegel> @pl (\a b -> transpose $ zipWith (\x y -> map (/y) x) (transpose a) b)
05:53:18 <lambdabot> (transpose .) . zipWith (flip (map . flip (/))) . transpose
05:53:23 <boegel> hmm
05:54:26 <shapr> CosmicRay: Do you have a *real* IPv6 address?
05:54:40 <shapr> I'm trying to get decent multicast somewhere :-/
05:55:00 <shapr> Maybe I can get my colo ISP to sell me a block of IPv6 addresses for ScannedInAvian.org
05:58:30 <shapr> Sure is quiet today.
05:59:38 <CosmicRay> shapr: well, it is a real IPv6 address, but it is in the 6to4 space.
05:59:50 <shapr> 6to4 doesn't do multicast.
05:59:52 <CosmicRay> so it is routable on the global IPv6 network, but it is based on the IPv4 address.
06:00:35 <shapr> At least, 6to4 doesn't do multicast unless the underlying IPv4 supports multicast, and that's rare.
06:03:58 <boegel> @eval transpose $ zipWith (\x y -> zipWith (\x y -> x/y)) (transpose [[2,3],[4,6]]) [[2,3],[4,5]]
06:03:59 <lambdabot>   Expecting a function type, but found `c'
06:03:59 <lambdabot>   Expected type: [a]
06:03:59 <lambdabot>   Inferred type: [a1] -> [b] -> [c]
06:04:39 <boegel> @eval transpose $ zipWith (\x y -> zipWith (\a b -> a/b) x y) (transpose [[2,3],[4,6]]) [[2,3],[4,5]]
06:04:40 <lambdabot> [[1.0,0.75],[1.3333333333333333,1.2]]
06:05:20 <boegel> @eval transpose $ zipWith (\x y -> zipWith (\a b -> a/b) x y) [[2,3],[4,6]] [[2,3],[4,5]]
06:05:21 <lambdabot> [[1.0,1.0],[1.0,1.2]]
06:05:58 <boegel> @pl transpose $ zipWith (\x y -> zipWith (\a b -> a/b) x y) [[2,3],[4,6]] [[2,3],[4,5]]
06:05:59 <lambdabot> transpose (zipWith (zipWith (/)) [[2, 3], [4, 6]] [[2, 3], [4, 5]])
06:06:33 <boegel> @eval transpose $ zipWith $  zipWith (\) [[2,3],[4,6]] [[2,3],[4,5]]
06:06:34 <lambdabot>  parse error on input `)'
06:07:03 <boegel> @eval transpose $ zipWith $ zipWith (\) $ [[2,3],[4,6]] [[2,3],[4,5]]
06:07:04 <lambdabot>  parse error on input `)'
06:07:13 <boegel> @eval (transpose $ zipWith $ zipWith (\)) [[2,3],[4,6]] [[2,3],[4,5]]
06:07:14 <lambdabot>  parse error on input `)'
06:07:16 <boegel> grr
06:07:20 <boegel> nvm
06:08:18 <Igloo> You probably mean \\
06:08:30 <boegel> @eval transpose $ zipWith $ zipWith (\\) $ [[2,3],[4,6]] [[2,3],[4,5]]
06:08:30 <lambdabot>   The function `[[2, 3], [4, 6]]' is applied to one arguments,
06:08:30 <lambdabot>   but its type `[a]' has none
06:08:37 <boegel> @eval transpose $ zipWith $ zipWith (\\) [[2,3],[4,6]] [[2,3],[4,5]]
06:08:38 <lambdabot> Couldn't match `a -> b -> c' against `[c1]'
06:08:46 <boegel> @eval (transpose $ zipWith $ zipWith (\\)) [[2,3],[4,6]] [[2,3],[4,5]]
06:08:46 <lambdabot> Couldn't match `[[a]]' against `[[[a1]]] -> [[[a1]]] -> [[[a1]]]'
06:08:50 <boegel> nope :)
06:09:19 <Igloo> Actually, what you've written can never be type correct for any operator
06:09:35 <Igloo> As you apply wipWith to one argument, yielding a function, and then apply transpose, that wants a list
06:10:06 <boegel> @eval transpose $ zipWith (\x y -> zipWith (\a b -> a/ (fromIntegral b)) x y) [[2.0,3.0],[4.2,6.6]] [[2,3],[4,5]]
06:10:07 <lambdabot> [[1.0,1.05],[1.0,1.3199999999999998]]
06:11:10 <boegel> @eval zipWith (\x y -> zipWith (\a b -> a/ (fromIntegral b)) x y) [[2.0,3.0],[4.2,6.6]] [[2,3],[4,5]]
06:11:11 <lambdabot> [[1.0,1.0],[1.05,1.3199999999999998]]
06:13:51 <boegel> @pl zipWith (\x y -> zipWith (\a b -> a / (fromIntegral b) ) )
06:13:51 <lambdabot> zipWith (const (const (zipWith ((. fromIntegral) . (/)))))
06:13:56 <boegel> :|
06:21:51 <shapr> hej mikael, ltns
06:22:00 <mikael> hej shapr :-)
06:22:30 <shapr> How's code treating you?
06:23:02 <mikael> not at all, lately
06:23:35 <mikael> I'm on fall break and consequently a lazy bum
06:25:13 <datenmaulwurf> Hi!
06:25:58 <datenmaulwurf> Exists there a function to delete one element in String?
06:26:16 <boegel> @hoogle a -> [a]
06:26:17 <lambdabot> Data.List.repeat :: a -> [a]
06:26:17 <lambdabot> Prelude.repeat :: a -> [a]
06:26:17 <lambdabot> Data.List.replicate :: Int -> a -> [a]
06:26:43 <boegel> @replicate 8 [1]
06:26:44 <lambdabot> Unknown command, try @listcommands.
06:26:49 <boegel> @eval replicate 8 [1]
06:26:50 <lambdabot> [[1],[1],[1],[1],[1],[1],[1],[1]]
06:27:06 <dcoutts_> @type List.delete
06:27:07 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
06:27:42 <datenmaulwurf> thanks :D
06:27:43 <dcoutts_> @eval delete 'a' "foobar"
06:27:44 <lambdabot> "foobr"
06:28:23 * dcoutts_ goes to get his unicycle axel mended
06:28:45 <datenmaulwurf> eval 'a' "foobar"
06:28:45 <datenmaulwurf> ERROR - Undefined variable "eval"
06:28:48 <datenmaulwurf> sorry, i'm a noob
06:30:28 <kzm> Hi all!  I have a (probably) trivial problem:  I installed WASH, but GHC doesn't seem to find it.
06:31:16 <dcoutts_> datenmaulwurf, @eval is a command to the IRC lambdabot, not a Haskell function. In hugs just say: delete 'a' "foobar"
06:31:39 <dcoutts_> though you'll need to load the List module first, since the delete function is in the List module
06:32:31 <datenmaulwurf> thanks
06:32:32 <datenmaulwurf> hmm...
06:33:35 <datenmaulwurf> i should write a procedure, to return - accroding the ascii-table - "highest" letter from a string
06:33:40 <datenmaulwurf> String -> Char
06:35:14 <kowey> folks, i have a couple of small, potentially useful utilities for doing stuff to haskell source (i.e. dep to graphviz, lhs to haddock)
06:35:25 <kowey> is there some package i can donate them to?
06:35:43 <kowey> or should i just make my own?
06:36:27 <kzm> Okay, I'll try a more concrete question: is -package deprecated?
06:37:47 <kzm> Ah, think I found it.  Nevermind.
06:37:52 <gour> dcoutts, what do are you having with unicycle?
06:39:29 <kzm> Anybody actually try to use Wash?
06:40:23 <CosmicRay> kzm: yes
06:40:27 <CosmicRay> I've written an entire app with it.
06:40:39 <gour> kzm: can Wash serve for a cgiemail-like replacament?
06:40:54 <kzm> Okay.  I tried to copy an example from the user manual, and get:
06:41:05 <kzm> parse error on input `<'
06:41:18 <gour> kzm, well i know one can write the whole app, but i need only a cgiemail-like replacement
06:41:23 <kzm> Apparently, embedding HTML in the code didn't quite work.
06:41:57 <shapr> gour: dcoutts is one of the unicycling Haskellers. Others are me, Lemmih, ulph, and phb.
06:41:57 <kzm> gour: No idea - I'm trying to learn. :-)
06:42:03 <datenmaulwurf> i should write a procedure, to return - according the ascii-table - "highest" letter from a string
06:42:08 <datenmaulwurf> String -> Char
06:42:12 <datenmaulwurf> sorry :(
06:42:24 <datenmaulwurf> but i need help for this trivial function
06:42:36 <shapr> kowey: You could donate to CosmicRay's MissingH
06:43:00 <gour> kzm, pls. let me know if you discover something ;)
06:43:01 <CosmicRay> kowey: that would be great
06:43:15 <CosmicRay> kowey: darcs get http://darcs.complete.org/missingh and hack away
06:43:19 <gour> shapr: who has started the trend?
06:43:22 <CosmicRay> let us know if you're not familiar with darcs
06:43:29 <kzm> well, I'll let you know if I get the examples from the user guide to compile.
06:43:40 <gour> kzm, ta
06:44:25 <gour> shapr, isn't it too risky to have such core haskellers risking their life on unicycle?
06:45:12 <gour> shapr, who will work on gtk2hs, hide etc. ?
06:45:17 <shapr> gour: Um, I dunno. I guess I might worry if SPJ, Simon M, and those guys unicycled.
06:45:49 <shapr> datenmaulwurf: First, figure out how to find the max of two chars, then figure out how to apply that to a list of chars.
06:46:04 <gour> shapr, well, they're in england, so, taking into consideration dcoutts' influence (i have personal experience)
06:46:13 <gour> shapr, anything can happen..
06:46:26 <shapr> gour: I think that dcoutts, Lemmih, and I all started unicycling independently. Same for ulph and phb.
06:46:41 <shapr> I guess the Haskell community just attracts people who like balance and elegance ;-)
06:46:41 <gour> shapr, and we'll have (another) syndrom: "fallen from the unicycle)" :-)
06:47:05 <gour> shapr, i don't believe you. probably your were sending some waves into ether
06:47:14 <shapr> It's possible.
06:47:32 <datenmaulwurf> shapr, chr
06:47:47 <shapr> datenmaulwurf: Try it.
06:47:48 <gour> how do those walking on their feet fit into balance & elegance?
06:47:51 <datenmaulwurf> gives me the ascii-value (int) of a char
06:47:52 <datenmaulwurf> i know it
06:47:55 <datenmaulwurf> but...
06:48:12 <datenmaulwurf> i programmed imparative's
06:48:12 <kzm> CosmicRay, is the Wash user manual simply misleading?  Or are you actually supposed to just type HTML code into your program?
06:48:21 <datenmaulwurf> there i can safe values to variables
06:48:31 <gour> shapr, do you have some pics of dcoutts in action?
06:49:03 <datenmaulwurf> how is it possible, to "safe" the highest asciivalue and compare it with the other elements in String?
06:49:45 <shapr> gour: No, I don't. But I've seen some before.
06:50:03 <datenmaulwurf> shapr? sorry
06:50:11 <datenmaulwurf> but i need help for it
06:50:20 <gour> shapr, maybe a new section on wiki should be added
06:50:41 <kzm> Is -package deprecated with recent GHC?
06:52:02 <boegel> @type sum
06:52:03 <lambdabot> forall a. (Num a) => [a] -> a
06:52:10 <jlouis> datenmaulwurf: you pass the value with you in the next function call you make
06:52:31 <datenmaulwurf> and then compare with the other elements?
06:52:47 <datenmaulwurf> ok, i'll try it
06:52:54 <jlouis> datenmaulwurf: yes, you can then always choose to pass the max value you've seen along
06:53:02 <datenmaulwurf> thanks for your (both) help
06:53:10 <datenmaulwurf> i have to go to university know
06:53:16 <datenmaulwurf> i'll try it "on the way"
06:53:19 <datenmaulwurf> thanks
06:53:22 <datenmaulwurf> cu
06:53:31 * jlouis grins.
06:54:31 <jlouis> I guess Germans have a hard time learning English
06:57:08 <ProfTeggy> ?
06:57:22 <ProfTeggy> jlouis, please elaborate :-)
06:58:46 * ProfTeggy reads the backlog and withdraws the plea.
07:06:53 <shapr> hiya roconnor, nice Wiki page.
07:07:24 <roconnor> I'm obligated to document things I learn
07:08:24 <shapr> roconnor: Few people believe that, but I think it's at least a nice thing to do.
07:09:04 <roconnor> there are now 3 haskellers
07:09:46 <dcoutts> gour, the axel on my unicycle was being dodgy. I've taken it into a bike shop.
07:10:11 <gour> dcoutts, bike or unibike shop?
07:11:28 <kzm> gour: got it (wash) to run.  1. it's WASH.CGI.CGI (not just CGI) and 2. manually run wash2hs first.
07:11:49 <gour> kzm, so how do you like it?
07:12:19 <dcoutts> gour, not everyone in the UK unicycles :-)
07:12:31 <dcoutts> gour, so there are not many unicycle repair shops
07:12:40 <shapr> roconnor: 3 Haskellers what?
07:12:49 <dcoutts> so yeah, it was a bike shop
07:12:51 <roconnor> in frapper, or whatever
07:13:01 <dcoutts> they were most impressed by the size of the thing
07:13:02 <gour> dcoutts, here i see unicycle onle when some circus is around or stree-performance :)
07:13:08 <roconnor> 3 people in the world use haskell.
07:13:14 <gour> roconnor, ?
07:13:31 <roconnor> ;)
07:13:33 <shapr> roconnor: Nah, I think it's just that lambdatheultimate is so huge.
07:13:42 <shapr> http://www.frappr.com/lambdatheultimate
07:15:42 <gour> dcoutts, do you believe bonobo will stay in gnome3?
07:16:15 <dcoutts> goron, no. It'll be replaces by dbus
07:16:38 <dcoutts> many of it's features will go into gtk itself
07:16:49 <dcoutts> and it get's used less and less anyway
07:16:49 <marcot> dcoutts: hello!
07:16:54 <dcoutts> hi marcot
07:17:03 <marcot> dcoutts: have you seen the debian patch for renaming the directories?
07:17:28 <gour> dcoutts, i'm asking regarding libgda/libgnome dependency
07:17:30 <marcot> CosmicRay: hello..
07:17:32 <dcoutts> marcot, yes I saw it
07:17:34 <marcot> CosmicRay: are you there?
07:17:40 <marcot> dcoutts: what did you find about it?
07:17:47 <dcoutts> gour, yeah, they'll probably dissapear someday
07:18:17 <dcoutts> marcot, well it's not really applicable to us since it just changes the paths rather than makign them configurable
07:18:22 <gour> dcoutts, i can ask on liggnomedb list to hear their feedback
07:18:31 <dcoutts> gour, right
07:18:35 <marcot> dcoutts: sure it's not..
07:18:45 <dcoutts> marcot, which patch then?
07:18:52 <gour> dcoutts, one question regarding future vista (longhorn)..
07:19:05 <gour> dcoutts, what will change for haskell development?
07:19:12 <dcoutts> marcot, you sent me the path you used for gtk2hs 0.9.9
07:19:27 <gour> dcoutts, afaics, compatibility with win32 should be preserved
07:19:40 <dcoutts> gour, I think so, so it should all be ok
07:19:49 <marcot> dcoutts: yes, I was talking about this one.. What did you stranged?
07:20:08 <roconnor> I still need to figure out how to make a new coarbitrary element
07:20:30 <dcoutts> marcot, the patch you sent me did this kind of thing:
07:20:30 <dcoutts> -import-dirs: "@hidir@/gconf"
07:20:30 <dcoutts> -library-dirs: @GCONF_LIBDIR_CQ@
07:20:30 <dcoutts> +import-dirs: "${libdir}/libghc6-gconf-dev/imports"
07:20:30 <dcoutts> +library-dirs: "${libdir}/libghc6-gconf-dev"
07:20:50 <dcoutts> which is ok for debian but not for upstream
07:22:07 <marcot> dcoutts: that's why I agreed with you.
07:22:11 <marcot> 13:18 < marcot> dcoutts: sure it's not..
07:22:23 <dcoutts> marcot, oh sorry, I misunderstood
07:22:40 <marcot> dcoutts: ok. That's what I thought.
07:22:53 <roconnor> In my old code case 1 takes 0.9 seconds and case 2 takes 37.5 seconds
07:23:02 <roconnor> in my new code both caes take 18.8 seconds
07:23:06 <CosmicRay> marcot: yes
07:23:59 <marcot> CosmicRay: =D
07:24:02 <marcot> CosmicRay: just sent you a mail.
07:24:18 <marcot> CosmicRay: are you going to sponsor me in gtk2hs packages?
07:25:22 <roconnor> I suppose on average it is an improvement
07:30:22 <shapr> hi fworp
07:30:30 <kzm> gour, sorry was away.  It seems okay.  Not sure I prefer the embedded XHTML to s-exp-like nested functions, but I'll work with it some more.
07:31:15 <kzm> Gotta go now, but will continue tomorrow.  Too bad with the outdated docs, not a good way to aquire users :-(
07:31:46 <kzm> Oops, did he leave?
07:31:49 <kzm> @seen gour
07:31:49 <lambdabot> gour is in #haskell. Last spoke 12 minutes and 21 seconds ago.
07:31:53 <gour> kzm, thanks, will ask you tomorrow
07:32:09 * kzm is apparently having problems with user completion in his IRC client.
07:32:47 * kzm sighs.  Computers suck.  I hate technology.  Have a nice day.
07:34:00 <gour> kzm, you too :-)
07:37:01 <marcot> CosmicRay: ?
07:40:11 <Oejet> kzm: Yeah, computers suck.
07:44:47 * boegel disagrees with Oejet and kzm
07:48:14 <roconnor> what's the fastest way to compute the length in bits of an integer?
07:49:04 <shapr> Probably shiftR and cmp zero
07:49:13 <Oejet> roconnor: Of type Int or Integer?
07:49:19 <roconnor> Of type integer
07:49:41 <shapr> oh
07:49:45 <Oejet> log2 is my first guess.
07:49:46 <Igloo> It probably depends on the distribution of the data
07:49:47 <roconnor> I am currently counting the number of  shiftR 1  until I get to 0
07:50:01 <shapr> Integer is libgmp, right?
07:50:15 <Igloo> In ghc, yes
07:50:43 <Igloo> And libgmp already knows, I think, so if you're willing to break the abstraction you could ask it
07:50:46 <roconnor> 88% of the time of my code is spent doing this.
07:51:02 <Igloo> Do you have an upper bound?
07:51:32 <roconnor> perhaps
07:51:42 <Igloo> If not you probably want to find one by shifting by increasing powers of 2
07:51:47 <Igloo> Then do binary search
07:51:50 <marcot> dcoutts: I'm trying to build gtk2hs 0.9.10 in debian, but I don't know which package has the dev files for firefox.
07:51:53 <marcot> Any idea?
07:51:55 <roconnor> oooh binary search
07:52:20 <CosmicRay> marcot: didn't I already upload gtk2hs for you?
07:52:35 <roconnor> It seems my degree in CS is worth nothing.
07:52:43 <Oejet> roconnor: What lengths are you getting?
07:53:52 <marcot> CosmicRay: sorry, I'm sleeping here. You had done it, it's just not in sid yet.
07:54:00 <CosmicRay> ah
07:54:08 <CosmicRay> still in NEW?
07:54:18 <Igloo> yup
07:54:24 <marcot> CosmicRay: I don't know, how do I look this?
07:54:37 <marcot> CosmicRay: I just can't find it with the packages.debian.org search.
07:54:43 <Igloo> http://ftp-master.debian.org/new.html
07:54:54 <marcot> Igloo: thanks.
07:54:58 <CosmicRay> that's the link I was trying to find.
07:55:24 <CosmicRay> so it looks ilke they've got about a 1-2 week backlog right now
07:55:39 <CosmicRay> so gtk2hs should hit sid RSN
07:56:21 <marcot> CosmicRay: ok, nice. I'm packaging the new upstream version.
07:57:15 <marcot> CosmicRay: I'm just with a problem in finding the debian package with the firefox-dev files.
07:59:52 <kowey> CosmicRay: will take a look at MissingH
08:00:01 <CosmicRay> kowey: great
08:00:06 <CosmicRay> marcot: super
08:00:07 <roconnor> god this function must be written somewhere
08:00:26 <CosmicRay> marcot: it may be mozilla dev files, not sure
08:00:42 <CosmicRay> marcot: you might want to look at the source packages for other firefox things
08:00:45 <marcot> CosmicRay: It's installed. I'm trying to read the configure.ac file from gtk2hs.
08:01:10 <CosmicRay> marcot: you might also ask on #debian-devel
08:01:46 <dcoutts> marcot, CosmicRay, you probably want to build against mozilla rather than firefox. It's more usual.
08:02:00 <dcoutts> eg does galeon on debian use mozilla or firefox?
08:02:13 <dcoutts> it's probably mozilla
08:02:40 <dcoutts> or perhaps there are two versions
08:02:42 <marcot> dcoutts: hum... I think it uses mozilla.
08:02:43 <dcoutts> but mozilla usually provides the right dev files and firefox only does sometimes
08:03:03 <marcot> dcoutts: It's it one xor the other?
08:03:11 <marcot> I can't build with both, right?
08:03:12 <Igloo> Does it make a difference which one you use?
08:03:14 <dcoutts> marcot, yes it's one or the other
08:03:21 <CosmicRay> marcot: I opened your message...  we're cool, right?  I can just delete this?
08:03:25 <dcoutts> you could build two versions I guess
08:03:30 <marcot> CosmicRay: sure!
08:03:33 <dcoutts> but I don't see that that is necessary
08:03:38 <CosmicRay> ok
08:03:41 <marcot> CosmicRay: I just mailed you cause I thought you wasn't here.
08:03:49 <CosmicRay> yeah I've been in and out
08:03:49 <marcot> dcoutts: ok.
08:04:01 <dcoutts> so if you have to pick one rather than doing both then I'd pick mozilla
08:04:30 <dcoutts> on gentoo of course we just let the user choose but you pobably have to pick on
08:05:10 <CosmicRay> marcot: look at what libgtk-mozembed-ruby does and mimic it
08:07:20 <marcot> CosmicRay: it uses mozilla.
08:07:25 <roconnor> Hmm, I should probably cabalize my real number library.
08:07:28 <Oejet> I don't understand the result of this: map (logBase 2) [(10^100)..(10^100)]
08:09:15 <Igloo> It's due to Doubles not being precise
08:09:24 <roconnor> does .. work well with floats?
08:09:25 <Igloo> try    [(10^100)..(10^100)] :: [Double]
08:10:09 <Igloo> I wouldn't say "well", no
08:10:15 <marcot> @eval  map (logBase 2) [(10^100)..(10^100)]
08:10:16 <lambdabot> [332.19280948873626,332.19280948873626,332.19280948873626,332.1928094887362
08:10:16 <lambdabot> 6,332.19280948873626,332.19280948873626,332.19280948873626,332.192809488736
08:10:16 <lambdabot> 26,332.19280948873626,332.19280948873626,332.19280948873626,332.19280948873
08:10:16 <lambdabot> 626,332.19280948873626,332.19280948873626,332.19280948873626,332.1928094887
08:10:16 <lambdabot> 3626,332.19280948873626,332.19280948873626,332.19280948873626,332.
08:10:18 <lambdabot> [23 @more lines]
08:10:46 <marcot> @eval  map (logBase 2) [(10^100)..(10^100)] :: [Double]
08:10:47 <lambdabot> [332.19280948873626,332.19280948873626,332.19280948873626,332.1928094887362
08:10:47 <lambdabot> 6,332.19280948873626,332.19280948873626,332.19280948873626,332.192809488736
08:10:47 <lambdabot> 26,332.19280948873626,332.19280948873626,332.19280948873626,332.19280948873
08:10:47 <lambdabot> 626,332.19280948873626,332.19280948873626,332.19280948873626,332.1928094887
08:10:47 <lambdabot> 3626,332.19280948873626,332.19280948873626,332.19280948873626,332.
08:10:49 <lambdabot> [23 @more lines]
08:13:55 <Igloo> I meant by itself, to see what the problem is. So:
08:14:05 <Igloo> @eval take 4 ([(10^100)..(10^100)] :: [Double])
08:14:06 <lambdabot> [1.0000000000000002e100,1.0000000000000002e100,1.0000000000000002e100,1.
08:14:06 <lambdabot> 0000000000000002e100]
08:14:48 <Igloo> Which in turn is due to the enum instance for doubles and the fact that
08:14:52 <Igloo> @eval (10^100 + 1) == ((10^100) :: Double)
08:14:53 <lambdabot> True
08:15:17 <marcot> @eval take 1 ([(10^100)..(10^100)] :: [Integer])
08:15:17 <lambdabot> [10000000000000000000000000000000000000000000000000000000000000000000000000
08:15:17 <lambdabot> 000000000000000000000000000]
08:15:23 <marcot> @eval take 2 ([(10^100)..(10^100)] :: [Integer])
08:15:24 <lambdabot> [10000000000000000000000000000000000000000000000000000000000000000000000000
08:15:24 <lambdabot> 000000000000000000000000000]
08:17:14 <kowey> hmm CosmicRay: my stuff is probably not what missingh is looking for
08:17:29 <CosmicRay> kowey: you have standalone utilities then?
08:17:38 <kowey> for starters, one's written in Python, and the other Perl... and yeah, they're standalone
08:17:42 <CosmicRay> ah
08:17:48 <CosmicRay> you're right then
08:17:49 <kowey> of course, i *could* rewrite them in haskell
08:18:03 <kowey> especially with Parsec... and they *could* be libraries... but probably won't be useful as such
08:20:03 <roconnor> Double shouldn't be an enum
08:20:09 <roconnor> it's crazy
08:20:40 <shapr> Why?
08:23:13 <Oejet> Igloo: Ah, thanks.  I get it now.
08:33:07 <marcot> dcoutts: what's this mtl in cairo depends on cairo.package.conf?
08:37:02 <shapr> monad template library
08:37:41 <kosmikus> marcot: no worries, mtl is included in ghc
08:39:00 <roconnor> now 60% of my time is spent calculating bit lengths.
08:40:04 <roconnor> er lengths of integers in bits
08:41:09 <marcot> kosmikus: thanks.
08:41:32 <roconnor> still, it's a pretty good improvement
08:41:59 <Igloo> What are these integers?
08:42:24 <roconnor> I am computing exp(3/5) to 1000 decimal places
08:42:56 <Igloo> Just for fun?
08:43:08 <roconnor> well that is just a test case.
08:43:18 <roconnor> I'm making a real number library for Coq
08:43:34 <Igloo> Is that a theorem prover, or do I misremember?
08:44:17 <Igloo> If efficiency is important to you, and portability isn't, I'm sure you could do a lot better by calling a libgmp function yourself
08:44:38 <roconnor> I'm making a haskell implementation test bed.
08:44:56 <roconnor> I won't get to call gmp in Coq.
08:45:06 <Igloo> ah
08:45:13 <roconnor> In some respects it is unfair to be using Integer at all.
08:45:32 <roconnor> Actually I can export Coq integers to Haskell and use them.
08:45:38 <roconnor> I am just using Integer for now.
08:45:46 <marcot> Igloo: is there a way of getting the .deb files in NEW?
08:45:51 <Igloo> marcot: No
08:46:00 <roconnor> Because anything I do to make this faster will make things faster no matter what representation I use.
08:46:26 <Igloo> If Coq integers are only 32bit or something then it's obviously much easier
08:46:27 <roconnor> still, it seems odd that 60% of my time is spent finding the length of numbers.
08:46:41 <roconnor> Coq Integers are basically lists of bools.
08:47:41 <roconnor> Anyhow, now my test cases are 3x slower than David Lester's Era implementation.
08:47:44 <roconnor> so that isn't too bad.
09:18:06 <Oejet> roconnor: I'm curious as to how fast floor(logBase 2 x) would be in your case.
09:19:31 <Igloo> You have to cope with it not giving exactly the right answer, and potentially have to worry about infinities too
09:20:46 <Friartuck> Hey, can someone help me?
09:21:27 <Oejet> Friartuck: The standard price is $599 US for an answer.
09:21:52 <Friartuck> I have a function which takes an Int and needs to process it. The problem is that I need to do some processing of that number involving trig, and the trig functions require a flot
09:22:09 <Igloo> fromIntegral
09:22:33 * Oejet should get a fromIntegral button on his keyboard too.
09:23:03 <int-e> @index partition
09:23:03 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
09:23:04 <Friartuck> lol - sorry, I've looked around but couldn't find anything, if thats a FAQ.
09:23:53 <Oejet> Friartuck: It is a normal question, since Haskell, I guess, does it a bit differently than other good programming tools.
09:24:03 <marcot> Hum.. I'm with a problem in gtk2hs.
09:24:33 <Friartuck> Yeah, alright - Thanks!
09:24:35 <marcot> I've done a calendar window, and I would like to call it in two different places, for updating two different data fields.
09:25:16 <Oejet> roconnor: You could maybe find inspiration in http://www.jjj.de/fxt/ page 16.
09:25:44 <musasabi> I think most of us have at some point asked the fromIntegral question.
09:26:18 <marcot> But how can I tell the calendar which field it must update?
09:28:07 <musasabi> marcot: make the update action read an IORef which contains the widget to be updated?
09:30:32 <marcot> musasabi: what's this IORef?
09:31:49 <musasabi> @doc Data.IORef
09:31:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
09:32:10 <marcot> musasabi: thanks.
09:32:12 <musasabi> Basically a mutable variable in the IO-monad.
09:35:38 <marcot> I have an doubt about it. I create it with newIORef and read it with readIORef, but how do I delete it?
09:35:44 <bourbaki> moin
09:35:52 <bourbaki> @seen esap
09:35:53 <lambdabot> I saw esap leaving #haskell 1 day, 19 hours, 4 minutes and 7 seconds ago,
09:35:53 <lambdabot> and I have missed 4 hours, 55 minutes and 39 seconds since then.
09:36:38 <bourbaki> can anyone help me to see how either is the coproduct categorically?
09:37:36 <Cale> bourbaki: the two maps are the Left and Right constructors
09:37:48 <bourbaki> the inclusions"
09:37:53 <bourbaki> er "=?
09:38:05 <int-e> injections
09:38:12 <bourbaki> sry yes injections
09:38:25 <bourbaki> ok cool thanks
09:38:50 <bourbaki> i think i finally am able to construct programs as graphs :)
09:39:17 <Cale> for any types, a,b,c, and functions f :: a -> c, and g :: b -> c, you have a diagram with a unique function  either f g :: Either a b -> c, and those two inclusion maps
09:39:24 <bourbaki> i just have one open thingy to show that all the partial applications exist
09:39:58 <Cale> I'd say inclusions is okay terminology, despite the fact that they're not really subtypes :)
09:40:23 <bourbaki> Cale: would you mind to listen for a min to my idea?
09:40:32 <Cale> not at all :)
09:40:36 <bourbaki> cool thanks
09:40:40 <int-e> Cale: that breaks for bottom, doesn't it?
09:40:48 <bourbaki> well my idea is to write programs as graphs
09:41:04 <bourbaki> the nodes are types
09:41:11 <bourbaki> and the edges are functions
09:41:13 <Cale> int-e: does it? I didn't really think about bottom
09:41:24 <bourbaki> the nodes also can store a specific token
09:41:34 <marcot> musasabi: can you help me?
09:41:45 <bourbaki> no you can concaternate functions in the graph
09:41:57 <bourbaki> just by following it through the graph
09:42:09 <bourbaki> for chains that easy
09:42:14 <Cale> bourbaki: that is, as diagrams in the caregory of types
09:42:19 <Cale> category*
09:42:19 <bourbaki> for anything that joins and branches ...
09:42:23 <bourbaki> yes
09:42:29 <musasabi> marcot: maybe, depends on what you need.
09:42:34 <musasabi> I can try at least.
09:42:41 <bourbaki> i am about to show that programs that you write that way are in itself categories
09:42:41 <int-e> Cale: hmm. not sure, actually, as Left bottom != Right bottom ... it's not specified how either left right should map bottom (although it's not possible to define it in a way that maps bottom to a value ...)
09:42:48 <bourbaki> with terminal and initial elements
09:42:55 <bourbaki> namely the input and output of the program
09:43:13 <bourbaki> and that is maps directly to arrows
09:43:21 <bourbaki> though for that i need to show that these programs are topi
09:43:39 <Cale> I doubt that programs are topoi
09:43:44 <bourbaki> well
09:43:48 <Cale> that's too strong
09:43:50 <bourbaki> you need all the products
09:43:55 <bourbaki> thats not that hard
09:44:09 <bourbaki> and for the exponetial objects i use paritial applications
09:44:17 <bourbaki> which map to arr for arrows
09:44:21 <Friartuck> Hey, thanks y'all I got it.
09:44:36 <Cale> I don't think that even the full category of haskell types is a topos
09:45:00 <Cale> it would be nice, but there are incomputable things which crop up if you try to make it one
09:45:03 <bourbaki> ok but in the thingy i descriped you agree that all products exist
09:45:26 <musasabi> Cale: but do they need to be computable?
09:45:32 <bourbaki> that is if there are two input nodes then the product is just the usual product
09:45:46 <bourbaki> i am atm talking about loop free programs
09:45:50 <bourbaki> that is no recursion yet
09:46:08 <bourbaki> and no either atm so no indeterministic programs yet
09:46:33 <bourbaki> think of the following program graph
09:46:58 <bourbaki> A -> D x E <- B , D x E -> C
09:47:06 <Cale> well, if two types are there, then the product type is potentially used in the program, but not necessarily
09:47:24 <bourbaki> you would like to write programs that way that is a and b go into the other node and then they map to something that is made of both
09:47:38 <bourbaki> now you just draw the cat like this
09:48:22 <bourbaki> A -> D , B -> D, D x E -> E, D x E -> D, D x E -> C
09:48:31 <shapr> Silly question, can you use GRIN for your graph?
09:48:38 <bourbaki> now the morphism from A x B -> C exists
09:49:02 <bourbaki> its not that hard to show that this is true for all graphs of that kind
09:49:16 <bourbaki> and for branching functions its alot easier
09:49:43 <bourbaki> A -> B, A -> C => A -> B x C is canonically true
09:49:56 <bourbaki> now what i mean with partial application and the exponential element is the folling
09:50:03 <bourbaki> think of the first "program"
09:50:11 <bourbaki> if i just plug something in A and not in B
09:50:23 <bourbaki> then the program would have to halt until B is fed
09:50:30 <bourbaki> this is like in lambda calculus
09:51:06 <bourbaki> so if i have morphisms from A to B^E then i would be done
09:51:48 <bourbaki> the other idea was to show that there exist a morphism from every node to the paritial application forunctions
09:52:06 <bourbaki> plus all permutations as morphisms from there to the end node i intended to reach
09:52:10 <bourbaki> still with me?
09:53:08 <Cale> well, I'm not entirely sure what you're talking about anymore
09:53:24 <bourbaki> still willing to listen :)?
09:53:33 <bourbaki> im quite bad at explaining
09:53:36 <Cale> You're presumably defining a programming language. Could you give some concrete syntax and an evaluation mechanism?
09:53:45 <bourbaki> yes
09:53:53 <bourbaki> the idea is that like in petri nets you have tokens
09:54:17 <bourbaki> if all the sucessor nodes are fed with tokens you apply all the functions to them and shift the stuff to the sucessor
09:54:38 <bourbaki> so the nodes are like containers
09:54:44 <bourbaki> typed though
09:55:25 <bourbaki> so you build something like this for all your programs you want to have
09:55:41 <Cale> hmm
09:55:44 <bourbaki> and i can show with arrows and ct that you can fold all these graphs to a single arrow
09:56:16 <bourbaki> and that these categories have initial and terminal elements
09:56:22 <Cale> I don't really know much about petri nets, but okay. If you have a commutative diagram, and a chain of arrows, you can certainly follow that chain along.
09:56:24 <bourbaki> which are the input and output of the program
09:56:39 <bourbaki> chains are easy yes
09:56:51 <bourbaki> and branches are just like &&& in arrow
09:57:07 <bourbaki> er no
09:57:22 <bourbaki> well the branching thingy is like the arrow construct where you use
09:57:48 <bourbaki> arr \x -> (x,x) >>> first f >>> second g
09:57:57 <bourbaki> and the thingy that joins is like
09:58:03 <bourbaki> first f >>> second g
09:58:31 <bourbaki> just with curry and uncurry which i need and if i have that in my cat of these programs i think that i have a topos
09:58:50 <Cale> well, branches don't really exist in the execution of the program, only in its construction
09:58:52 <bourbaki> cause if i can uncurry and uncurry i have exponential objects
09:59:05 <bourbaki> yes
09:59:12 <Cale> you have a Cartesian closed category, but I don't think a topos.
09:59:14 <bourbaki> though you can do concurrent programs like that
09:59:30 <bourbaki> all i need for the topos is the exponential objects
09:59:34 <Cale> no
09:59:35 <bourbaki> dont they map to parial applications?
09:59:44 <bourbaki> well thats what wikipedia says
09:59:57 <Cale> You need that all limits over finite index categories exists
09:59:59 <bourbaki> all products and exponential objects
10:00:14 <bourbaki> dont i get that with the products?
10:00:18 <Cale> no
10:00:25 <Cale> I don't think so
10:00:30 <bourbaki> i mean all pushouts and pullbacks should exist
10:00:55 <Cale> really?
10:01:05 <Cale> how about equalisers?
10:01:13 <bourbaki> well the pullback is like the products really
10:01:27 <bourbaki> and the pushouts is like joining the outputs
10:01:33 <Cale> in general, this makes your typing system undecidable, I think
10:01:34 <bourbaki> if its indeterministic
10:01:55 * int-e has a sort of deja vu.
10:01:57 <bourbaki> well equilizers are just needed if there are real branches right?
10:01:58 <Cale> heh
10:02:11 <bourbaki> that is if you have two possible ways to go in your program
10:02:18 <bourbaki> you usually dont want this
10:02:24 <Cale> bourbaki: equalisers will have to exist if you're going to say it's a topos
10:02:39 <roconnor> Oejet, my integers may be too big for floor(logBase 2 x) to be accurate
10:02:42 <bourbaki> what would be an equiliser there?
10:03:48 <Cale> basically, the type of values x in A where two functions f,g : A -> B evaluate to the same thing
10:03:56 <Cale> that is {x : f(x) = g(x)}
10:04:01 <bourbaki> i mean in order to get something like this you would have to have two elements that are something like you have an output either there or there
10:04:12 <bourbaki> otherwise it wouldnt make sense right?
10:04:33 <Cale> well, you need to be able to do this in order to support the claim that it's a topos
10:04:58 <bourbaki> hm
10:05:23 <Cale> because equalisers and products are consequences of that
10:05:47 <bourbaki> well lets construct an example
10:05:49 <Cale> I don't really think you want equalisers, because they make the typechecking undecidable
10:05:54 <bourbaki> lets say you have one image and two filters
10:06:19 <Cale> hm?
10:06:20 <bourbaki> then the eqilizer would map to all the images that would yield the same image in both filters right?
10:06:28 <Cale> yes
10:06:41 <bourbaki> hm
10:06:55 <Cale> it would be the type consisting of only those images
10:07:00 <bourbaki> well but i thought that its enough to have the exp objects
10:07:19 <bourbaki> i see the problem
10:07:35 <bourbaki> though at least according to wikipedia that follow from showing that you have the exp objects
10:07:40 <bourbaki> which i thought i would have
10:07:43 <Cale> you probably just want Cartesian closed
10:07:49 <int-e> Ah. A pullback is a special case of an equalizer - the pullback of f:X->Z and g:Y->Z is the equalizer of f o pi_1 : X x Y -> Z and g o pi_2 : X x Y -> Z.
10:07:51 <bourbaki> though i am usre that this is not always constructable
10:07:52 <Cale> rather than a topos
10:08:00 <Cale> int-e: yes
10:08:16 <bourbaki> hmhmhm
10:08:18 <Cale> http://en.wikipedia.org/wiki/Cartesian-closed_category
10:08:35 <bourbaki> ok but isnt that still interesting and good?
10:08:44 <Cale> int-e: a pushout is like a disjoint union (coproduct) followed by some gluing (coequaliser)
10:08:55 <Cale> yeah
10:08:56 <Cale> :)
10:09:21 <Lemmih> Hiya SyntaxNinja.
10:09:34 <bourbaki> Cale: can you think of something i could do for this in addition
10:09:54 <bourbaki> what about limits of implementation  functors or so?
10:10:56 <Cale> well, you should be able to do endofunctors on the category of types in the same way Haskell does
10:11:02 <bourbaki> i think the cool thing is that i can connect programs in several places after constructing them
10:11:09 <bourbaki> so its like arrow++
10:11:27 <bourbaki> its arrow + structurs
10:11:30 <bourbaki> er structure
10:11:59 <Cale> I'd like to see an implementation of this in order to see what it's like better. I think that being forced to specify all of my programs in points free style might get a little tedious
10:12:31 <Cale> sometimes you really want to be able to specify an elementwise action
10:12:41 <bourbaki> what i need also is the curry and uncurry thing though and the partial application
10:12:59 <bourbaki> which i think is in there cause its just like waiting for all the other inputs to be made
10:13:07 <Cale> well, sure
10:13:11 <Cale> Haskell has those :)
10:13:17 <bourbaki> i know :)
10:13:28 <bourbaki> i need to show though that they exist in this category
10:13:40 <bourbaki> elementwise action?
10:13:44 <bourbaki> you could do that with either
10:14:00 <Oejet> roconnor: f x = floor(logBase 2 (2^x)), f 1023 => 1023, f 1024 => 179769313486...
10:14:14 <bourbaki> something like is it this element -> yes no and then a new function doing something on yes or no
10:14:33 <Cale> well, you don't want to do that for every element :)
10:14:45 <Cale> or you'll be drawing graphs for a long time
10:14:48 <bourbaki> well all you need to show is that you can do that
10:14:55 <bourbaki> theoretically
10:15:06 <bourbaki> you can just write the arrow like that if you want
10:15:11 <Cale> let's say I want to write the function Integer -> Integer which sends x to x^2
10:15:23 <Cale> what will I have to type/draw?
10:15:40 <bourbaki> Int -> Int x Int <- Int
10:15:43 <Cale> how about sending x to x^2 + x + 5?
10:15:51 <bourbaki> er
10:15:52 <bourbaki> bullocks
10:16:10 <musasabi> Are ":::", "::::", "::::..." reserved names in Haskell?
10:16:19 <bourbaki> Integer <- Integer -> Integer
10:16:22 <int-e> musasabi: they're type constructors
10:16:29 <bourbaki> sec
10:16:30 <musasabi> int-e: so they are fair game?
10:16:34 <Igloo> They aren't reserved
10:16:40 <Cale> data constructors
10:16:45 <bourbaki> you want f(x) = x^2 + x + 5 ?
10:16:47 <int-e> Cale: err, right.
10:16:49 <Cale> bourbaki: yeah
10:16:53 <bourbaki> ok
10:17:05 <bourbaki> Cale: let me draw the diagram ok?
10:17:15 <bourbaki> ill upload it thats easier then writeing it down
10:17:25 <roconnor> Oejet, that doesn't look good
10:17:25 <int-e> @pl \x -> x*x + x + 5
10:17:25 <lambdabot> (5 +) . ((+) =<< join (*))
10:17:39 <int-e> . o O ( yuck! )
10:17:44 <Cale> :)
10:17:48 <dcoutts> boegel, you stil interested in OpenGL ?
10:18:06 * dcoutts is looking at OpenGL for Gtk2Hs again
10:18:29 <Cale> bourbaki: or how about the function which takes a list of integers and produces the polynomial function with those integers as coefficients? :)
10:18:48 <bourbaki> sec sec :)
10:18:51 <bourbaki> first things frist
10:18:52 <roconnor> @eval floor(logBase 2 (2^1024))
10:18:53 <lambdabot> 179769313486231590772930519078902473361797697894230657273430081157732675805
10:18:53 <lambdabot> 500963132708477322407536021120113879871393357658789768814416622492847430639
10:18:53 <lambdabot> 474124377767893424865485276302219601246094119453082952085005768838150682342
10:18:53 <lambdabot> 462881473913110540827237163350510684586298239947245938479716304835356329624
10:18:53 <lambdabot> 224137216
10:19:02 <Cale> My point is that this kind of programming will get tedious without some additional mechanisms
10:19:10 <bourbaki> Cale: that would be the thingy i meant with exp and partial application
10:19:59 <Cale> bourbaki: that's at the type level though -- your language seems deficient at the value-level
10:20:59 <Cale> and while you might be able to rig things up with using terminal objects to talk about elements, it's not so pretty
10:21:46 <bourbaki> Cale: can you rephrase that?
10:21:52 <Cale> so you may need to work out some syntax which turns a definition like x |---> x^2 + 3*x + 5 into a big wad of categorical nonsense :)
10:22:32 <Cale> because it's quite a mess otherwise :)
10:22:45 <bourbaki> well the idea is that the morphism from the input to the output is your compiled program
10:23:37 <Cale> sure, and sometimes it's easier to get morphisms by specifying them directly, rather than expressing them as universal arrows in your category :)
10:24:14 <bourbaki> yes but the idea is that you build small programs and write you big ones out of them
10:24:22 <bourbaki> cause i can do a lot of nifty things with them
10:24:28 <bourbaki> topological stuff and such
10:24:40 <bourbaki> and i can build the quotient space of them
10:24:53 <bourbaki> or so the oposit of derivation in c++s classes
10:24:55 <Cale> yeah, but I'm saying it's still going to get tedious, even for writing simple programs like polynomials
10:25:03 <bourbaki> so you can ask whats the same on all the programs and so
10:25:19 <Cale> you'll have an excellent type-language and a deficient value-language.
10:25:24 <bourbaki> yes but you can wirite a graph that builds graphs
10:25:25 <int-e> you need to implement the small things, too. it's no good if the hard stuff is easy if you never get there.
10:25:39 <bourbaki> i want to do that for neural nets
10:25:47 <bourbaki> http://img23.imageshack.us/my.php?image=diagram6jj.jpg
10:25:53 <bourbaki> there is the diagram for your functions
10:26:15 <bourbaki> thats what you would write for the programm thingy
10:26:27 <bourbaki> the cat would have all arrows that point towards products into the other direction
10:26:42 <bourbaki> so you can show with the product (ct) that there is an <f,g>
10:27:08 <Cale> that's x^2 + 5
10:27:16 <Cale> :)
10:27:24 <Cale> if I understand it correctly
10:27:25 <int-e> Cale: no, it's not well typed ;)
10:27:26 <bourbaki> no
10:27:34 <bourbaki> the +5 adds  + 5
10:27:52 <Cale> ah
10:27:53 <int-e> bourbaki: you need a + : Int x Int -> Int before doing the +5
10:27:53 <Cale> okay
10:27:54 <bourbaki> and the thingy before that takes the input from the first node and builds the product of x and x^2
10:28:11 <bourbaki> int-e: ?
10:28:23 <bourbaki> +5 is just a function that adds 5 :)
10:28:31 <bourbaki> i was too lazy to draw another product :)
10:28:34 <int-e> bourbaki: and you apply it to Int x Int ... how?
10:28:43 <Cale> well, it's a function which adds, and then adds 5
10:28:54 <Cale> and how do you say "5" in this language anyway? :)
10:29:09 <bourbaki> you dont say 5 you just name the edge
10:29:16 <Cale> Is it a morphism from some terminal object into Integer?
10:29:17 <bourbaki> and then there is a functor that implemtns the functions
10:29:29 <bourbaki> no
10:29:39 <bourbaki> the terminal element is the one in the lower right
10:29:47 <bourbaki> int-e: sorry i dont get it
10:29:49 <Cale> Int isn't terminal
10:29:58 <Cale> not in the category theory sense
10:29:58 <bourbaki> why?
10:30:02 <bourbaki> sure
10:30:10 <bourbaki> you have to draw in all the missing morphisms
10:30:16 <MarcWeber>  /exit
10:30:25 <Cale> Because for any type T, there are lots of functions T -> Int
10:30:28 <bourbaki> and dont forget you have to turn the arrows on the products
10:30:31 <int-e> bourbaki: I'd expect the end to be bubble(int x int) -- + --> bubble(int) -- +5 --> bubble(int)
10:30:34 <Cale> not a unique one
10:30:53 <bourbaki> cale if you reverse the arrows on those you get a unique one
10:31:00 <Cale> bourbaki: no
10:31:05 <bourbaki> ill draw another program a smaller one sec
10:31:10 <int-e> bourbaki: instead of just  bubble(int x int) -- +5 --> bubble(int)
10:31:29 <bourbaki> the +5 is like this
10:31:44 <bourbaki> \x,y -> x + y + 5
10:32:15 <Cale> bourbaki: regardless, you see what I mean about things being hard to write?
10:33:26 <Cale> wouldn't it be nice if you could just write Int ---> Int and label the arrow with x |--> x^2 + x + 5
10:33:34 * int-e also finds the graph potentially ambigous - how do you know the first node replicates the value along all three outgoing edges, instead of, say, only one, as for a case distinction?
10:33:42 <int-e> ambiguous.
10:33:58 <Cale> int-e: I'd assumed those were intended as arrows marked with id
10:34:09 <bourbaki> Cale: why?
10:34:14 <Cale> and er....
10:34:36 <Cale> wait, yeah the arrows going into the product are wrong
10:34:45 <Cale> they should be pointing the other way
10:34:50 <bourbaki> Cale: the function you want is just the compiled program:)
10:34:55 <Cale> they're projection maps
10:35:15 <bourbaki> Cale: the next picture will show the thingy
10:35:22 <Cale> you really want the unique arrow arising from the product
10:35:30 <bourbaki> you want to write it in another way then the category is really like
10:35:40 <int-e> there's a lot of semantics hidden in the nodes.
10:35:42 <bourbaki> intuitively that is
10:35:50 <bourbaki> no thats the only thing thats hidden
10:35:57 <bourbaki> you also could label the edges for the products
10:36:05 <Cale> really, you want to be able to write x^2 + x + 5, and have the compiler sort it out ;)
10:36:08 <bourbaki> which one will yield with element in the product
10:36:18 <bourbaki> but the other way is doing that with the projections
10:36:30 <bourbaki> with is better for the ct stuff cause you can do your prooves then
10:36:45 <bourbaki> Cale: well but i can do it with arrows
10:36:50 <bourbaki> so the compiler is just haskell
10:36:54 * int-e wants to see    \n -> if odd n then f n else g n
10:37:04 <bourbaki> and you can run the programs live and see what they do
10:37:22 <Cale> bourbaki: you have an implementation of this?
10:37:23 <bourbaki> int-e: heh well youd need either for that
10:37:24 <bourbaki> i think
10:37:36 <bourbaki> Cale: i tried it but i failed when i had to use HLIST
10:37:53 <int-e> bourbaki: so I can't have a graph with separate f and g arrows for that?
10:38:39 <bourbaki> hm
10:38:59 <bourbaki> they dont overlap
10:39:04 <bourbaki> so you are fine with either
10:39:08 <bourbaki> its all still deterministic
10:39:20 <bourbaki> it would be something else if you wanted to spawn to new things really
10:39:31 <Cale> remember that in basing a language on category theory directly, you're going to end up with the same problems that category theory has. CT is concise sometimes, but also sometimes really bloated and horrible for expressing simple elementwise things.
10:39:48 <bourbaki> well i dont base it on ct
10:40:00 <bourbaki> i just want to use it to show that there are always initial and terminal elements
10:40:08 <bourbaki> and maybe something else i dont know yet
10:40:29 <bourbaki> its just cool to have a cat for all programs maybe someone can think of other nice thingies
10:40:32 <bourbaki> ie
10:40:33 <bourbaki> bisimulation
10:40:38 <Cale> Somehow I don't think you intend the words "initial" and "terminal" in quite the category theoretic sense
10:40:42 <bourbaki> or haveing a functor from one to another program
10:40:46 <Cale> Int is not a terminal object at all
10:41:25 <bourbaki> not in that picture yes
10:41:31 <bourbaki> but in the one ill show you now
10:41:44 <Cale> all you need to show that Int isn't terminal is that there are two functions Int -> Int
10:41:46 <bourbaki> you just have to add the missing morphisms
10:41:54 <bourbaki> damn!! that damn site
10:42:05 <Cale> right?
10:42:28 <bourbaki> yes
10:42:35 <Cale> a terminal object is something like a one-element type
10:42:48 <Cale> an initial object is an empty type
10:42:50 <bourbaki> well it can be a product also
10:42:52 <Cale> no
10:42:55 <Cale> well
10:43:05 <Cale> it could be the product of two terminal objects
10:43:15 <bourbaki> initial is just that there is a morphism form this to every other object
10:43:25 <int-e> no!
10:43:31 <Cale> a unique!!!!! morphism
10:43:34 <int-e> there is an morphism and it's unique.
10:43:45 <bourbaki> yes a unique
10:43:59 <bourbaki> but thats quite trivial if you talk a bout a program
10:44:09 <bourbaki> damn i cant upload the picture
10:44:12 * sieni found nice paper about implementing regexen in haskell
10:44:16 <bourbaki> can i send it to you via dcc?
10:44:23 <Cale> sure
10:44:37 <sieni> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/regExp.ps
10:44:48 <sieni> simple, but effective <3
10:45:13 <beelsebob_> hehehehehehehe! results for hat-delta are looking distinctly rosy
10:45:22 <beelsebob_> best cut so far... hat-detect 112, hat-delta 4
10:45:25 <int-e> hmm. let me see, you're viewing your program as a graph, and that graph as a category, where there is at most one arrow from one object to another?
10:45:28 <bourbaki> Cale: are you registered?
10:45:40 <Cale> yeah
10:45:50 <bourbaki> hm i cant send the file to you
10:45:53 <int-e> bourbaki: you're not, or at least not identified
10:46:04 <bourbaki> no i am indented :(
10:46:08 <Cale> nope
10:46:09 <bourbaki> *sob*
10:46:20 <bourbaki> int-e: no there are more then one morphism
10:46:25 <bourbaki> but if so they are identical
10:46:33 <int-e> bourbaki: to the nameserv ...
10:46:34 <bourbaki> ie the concaternation
10:46:42 <bourbaki> i am
10:47:05 <bourbaki> or not :)
10:47:14 <int-e> what's the difference between 'at most one morphism' and 'there can be more than one, but if there are two they are identical'?
10:47:17 <bourbaki> mistyped my pass
10:47:41 <bourbaki> is there a difference?
10:48:03 <Cale> cale@zaphod[~/dcc]$ feh diagram2.jpg
10:48:04 <Cale> feh WARNING: diagram2.jpg - No Imlib2 loader for that file format
10:48:04 <Cale> feh - No loadable images specified.
10:48:04 <Cale> Use feh --help for detailed usage information
10:48:04 <Cale> cale@zaphod[~/dcc]$ file diagram2.jpg
10:48:04 <Cale> diagram2.jpg: data
10:48:12 <bourbaki> erm
10:48:16 <bourbaki> thats really strange ...
10:48:18 <int-e> what's in that file?
10:48:21 <int-e> hehe.
10:48:28 <bourbaki> i just saved it with painter ...
10:49:37 * fworp tries and fails to get ghc5 binaries setup without root permissions on fbsd
10:50:25 <Cale> ghc5?
10:50:32 <Cale> why not 6?
10:50:35 <bourbaki> well but i think that you can show that there always exists a pullback for nodes that are required to fill to map to a product node
10:51:04 <fworp> Cale: because i dont have a working set of 5.04 binaries yet to bootstrap with
10:51:36 <Cale> fworp: ah
10:51:50 <Cale> fworp: aren't there ghc 6 binaries around?
10:52:07 <fworp> not sure if there are for fbsd, they arent in the ports tree
10:52:11 <int-e> feh ...
10:52:39 <Cale> http://www.haskell.org/ghc/download_ghc_641.html#freebsd
10:52:53 <fworp> Cale: which refers me to the ports tree
10:53:57 <Cale> fakeroot?
10:55:22 <int-e> bourbaki: re: the x*x+x+5 diagram: if I understand what you're trying to do correctly, there should be an arrow from the uppermost Int node (to the right of the input node) to the output Int node ... what is it?
10:55:42 <fworp> Cale: what do you mean? like chroot?
10:55:46 <bourbaki> int-e: yes you are right
10:56:03 <bourbaki> this morphism would be the compiled program
10:56:12 <bourbaki> that is x^2 + x + 5
10:56:39 <marcot> musasabi: 15:35 < marcot> I have an doubt about it. I create it with newIORef and read it with readIORef, but how do I delete it?
10:56:50 <Cale> fworp: well, I don't run freebsd, but on Debian at least, there's a program called fakeroot which one can use to set up an environment for faking root priveleges for file manipulation
10:57:06 <marcot> musasabi: sorry for taking so long.
10:57:09 <Cale> you could use it to install the package in a subtree of your home directory, say
10:57:17 <Cale> (if it's available)
10:57:40 <Igloo> marcot: It gets garbage collected when it's no longer needed
10:58:28 <Cale> fworp: but it might be easier to just talk to your sysadmin
10:58:38 <fworp> Cale: probably
10:58:57 <bourbaki> finally
10:59:00 <bourbaki> Cale: int-e http://img342.imageshack.us/my.php?image=diagram39vm.png
11:01:31 <marcot> Igloo: thanks.
11:05:15 <bourbaki> Cale: got the pic?
11:05:26 <bourbaki> int-e: did you see the new pic?
11:06:34 <int-e> bourbaki: it's confusing.
11:07:24 <bourbaki> int-e: the thing is that when you reverse the arrows at the products
11:07:30 <bourbaki> then you select the place where they belong
11:07:35 <bourbaki> with the projection
11:08:39 <int-e> but what I initially wanted was a coproduct (set theoretic sum) and I also wanted to join the arrows together again - now you have three sinks in that graph instead of only one.
11:10:12 <bourbaki> int-e: well in that category you can show that there exists the arrow from the input to the output though
11:10:30 <bourbaki> you also can do something else with new nodes that model partial aplication i think
11:12:08 <bourbaki> int-e: what i have done there is something my prof told me to do
11:12:17 <bourbaki> i also wanted to proov what you just thought
11:12:25 <bourbaki> but that was really complicated
11:12:49 <bourbaki> i introduced new objects for partial applications
11:13:06 <bourbaki> and from there every permutation to the end node
11:13:17 <bourbaki> so if you have f x y = x + y
11:13:25 <bourbaki> the new object would have all functions
11:13:35 <bourbaki> g y = ... + y
11:13:43 <bourbaki> where ... if the morphism you used to get there
11:13:56 <bourbaki> and for the y you make one morphism for every y there is
11:17:07 <bourbaki> int-e: do you know what i mean?
11:18:06 <int-e> bourbaki: a bit.
11:18:16 <int-e> bourbaki: enough for me for the moment.
11:18:34 <bourbaki> sorry didnt want to bother
11:19:27 <int-e> bourbaki: it's ok, it was interesting so far, albeit confusing.
11:19:53 <bourbaki> yes im like that its a really bad trait of me :(
11:20:00 <bourbaki> i just cant explain anything
11:24:43 <joelr> howdy
11:25:02 <joelr> when should i use a STM TChat instead of a regular Chan?
11:26:16 <fnord123> hi joel
11:27:14 <joelr> hi fnord123
11:31:00 <fnord123> bbiab
11:38:08 <musasabi> marcot: it is automatically deallocated when there are no more references to it.
11:42:53 <shapr> yay netsplits
11:51:31 <astrolabe_> What are the most important extensions to haskell, that a chap ought to know about?
11:52:03 <kombinator> is it possible to write a state monad with garbage-collected refs in pure haskell (without using IO, or ST)?
11:52:59 <shapr> Yes, that's ST.
11:53:08 <shapr> At least, I think it is.
11:53:40 <shapr> astrolabe_: http://www.haskell.org/hawiki/FundamentalConcepts
11:55:57 * dcoutts tries to kill "uninterruptible" process
11:56:00 <dcoutts> grr
11:56:27 <astrolabe_> shapr: thank you
11:57:47 <kombinator> dcoutts: most likely a kernel bug
11:58:53 <dcoutts> kombinator, I guess so (and annoyingly it's preventing my cd drive from ejecting since the uninterruptible has the cdrom device held open)
12:08:34 <marcot> How do I test IORef in ghci?
12:08:58 <marcot> I mean, how do I "import" Data.IORef
12:09:56 <musasabi> marcot: :m +Data.IORef
12:10:13 <marcot> musasabi: thanks.
12:13:42 <marcot> about this, how can I read the IORef variable in the function of the calendar?
12:14:01 <marcot> hum... I found a way here, ok.
12:15:29 <astrolabe_> This seems a bit silly http://www.haskell.org/hawiki/Closure
12:15:43 <astrolabe_> I don't see that much difference between x and y
12:16:17 <shapr> astrolabe_: You know about partial application?
12:16:51 <astrolabe_> shapr: I expect so.  Like (+) 5   ?
12:17:01 <shapr> Right, that's a closure.
12:17:21 <astrolabe_> Hmm. I looks like a function to me.
12:17:26 <astrolabe_> *It looks
12:17:30 <shapr> @type (+ 5)
12:17:31 <lambdabot> forall a. (Num a) => a -> a
12:17:54 <shapr> @type (+)
12:17:55 <lambdabot> forall a. (Num a) => a -> a -> a
12:18:10 <shapr> So the (+) function closes over the 5 and hangs onto it.
12:18:38 <astrolabe_> So, f x = x + 5 isn't a closure?
12:18:52 <shapr> I don't think so.
12:19:09 <shapr> Closures are about getting something from the environment and hanging onto it.
12:19:10 <astrolabe_> maybe it makes more sense in other languages
12:19:31 <Cale> f kind of becomes a closure there, doesn't it?
12:19:42 <shapr> Cale: You tell me :-)
12:19:44 <Cale> hmm
12:19:51 <Cale> I suppose it's an implementation thing
12:20:11 <shapr> I'm often fuzzy on the details, but I generally know how things work :-)
12:20:21 <Cale> f = \x -> x + 5
12:20:23 <shapr> @foldoc closure
12:20:25 <lambdabot> *** "closure" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)
12:20:25 <lambdabot> "
12:20:25 <lambdabot> closure
12:20:25 <lambdabot>  
12:20:25 <lambdabot>    1. <programming> In a {reduction system}, a closure is a data
12:20:28 <lambdabot> [29 @more lines]
12:20:33 <Cale> @more
12:20:34 <lambdabot>    structure that holds an expression and an environment of
12:20:34 <lambdabot>    variable bindings in which that expression is to be evaluated.
12:20:34 <lambdabot>    The variables may be local or global.  Closures are used to
12:20:35 <lambdabot>    represent unevaluated expressions when implementing
12:20:38 <lambdabot>    {functional programming languages} with {lazy evaluation}.  In
12:20:40 <lambdabot> [24 @more lines]
12:20:53 <Cale> so in some sense, f is a closure around +
12:21:04 <Cale> holding 5
12:21:36 <astrolabe_> It all seems so trivial in haskell
12:21:42 <astrolabe_> thanks guys
12:22:01 <benmos> ...I guess it's kinda holding the value of '+' too - ...maybe that was what you meant.
12:22:57 <Cale> well, yeah, it's holding on to + and 5, and waiting for another parameter before it evaluates
12:23:29 <benmos> ...yeah. I suppose it's a bit of a moot point.... but I always think of all the 'built-in's as being sort of closed-over....
12:27:33 <astrolabe_> I thought an abstract data type was something other than this http://www.haskell.org/hawiki/AbstractDataType
12:27:58 <fworp> me too
12:28:15 <astrolabe_> I thought it was the interface with an understanding of it's functionality, but with the implementation.
12:28:19 <shapr> 'Data Lego' ?
12:28:26 <Cale> the initial part of that page is talking about an algebraic data type
12:28:27 <astrolabe_> but without the implementation!
12:28:40 <Cale> later, the page discusses things correctly
12:28:41 <shapr> I think ADTs are just about being able to build your own data tinkertoys.
12:28:45 <astrolabe_> Ah, ok, that makes sense.
12:28:46 <Cale> using typeclasses
12:29:06 <Cale> I think that page needs some refactoring
12:29:38 <arjanoosting> @seen SyntaxNinja
12:29:39 <lambdabot> SyntaxNinja is in #haskell and #haskell-blah. Last spoke 1 hour, 51
12:29:39 <lambdabot> minutes and 47 seconds ago.
12:29:56 <Cale> I suppose that they're moderately correct about the use of the word "abstract", though "parametric" would be more correct for the first usage
12:30:00 <shapr> hiya franka
12:30:10 <franka> Hi, shapr.
12:30:11 <kombinator> why are monads used in this way when specifying abstract interfaces to datatypes: left  :: (Monad m) => t a -> m (t a) ?
12:30:17 <shapr> How's things?
12:30:27 <kombinator> (left means left subtree)
12:30:29 <franka> Could really hardly be worse.
12:30:38 <Cale> kombinator: probably should be MonadPlus
12:30:47 <Cale> it's to express failure
12:30:54 <shapr> franka: Wow, what happened?
12:30:59 <Cale> You might want to use the Maybe monad, or the List monad
12:31:04 <shapr> Or should we discuss this on an un-logged channel? :-)
12:31:08 <franka> My ex-girlfriend again.
12:31:10 <Cale> or some other monad with a failure mechanism
12:31:39 <shapr> oh my
12:31:44 <franka> She really hates my guts now.  It's pretty remarkable, actually.
12:32:10 <astrolabe_> Sorry to hear that franka
12:32:12 <Cale> actually, better than MonadPlus would be MonadZero, but Haskell doesn't have that anymore :)
12:32:51 <kombinator> Cale: I see
12:36:06 <kombinator> Cale: but aren't monads a heavywieght concept to use to express failure?
12:36:10 <shapr> hej Nasty
12:36:19 <Nasty> hej
12:36:24 <shapr> Monads are lighter than objects...
12:37:41 <kombinator> shapr: what do you mean?
12:41:13 <Cale> kombinator: yeah
12:42:19 <Cale> Conceptually monads are a bit heavier than necessary. Monoid would be better
12:42:38 <Cale> or even just having a Zero class would likely be a good idea
12:43:06 <shapr> kombinator: I was just thinking about the Command objects I see flying around in J2EE all the time.
12:43:28 <astrolabe_> Is there a haskell typeclass called Monoid?
12:43:35 <benmos> Java...urgh... shudder.... I come here to try to forget about it
12:43:39 <Cale> astrolabe_: yeah
12:44:17 <astrolabe_> I thought a monad was the computer version of a monoid anyway.
12:44:20 <Cale> shapr: it's not so much that the implementation is heavy, it's just that conceptually monads have a lot more properties than necessary to express failure
12:44:24 <Cale> astrolabe_: not at all
12:44:36 <Cale> Monads are the computer version of monads
12:44:37 <shapr> benmos: hehe
12:44:41 <Cale> heh
12:44:52 <Cale> monads come from category theory
12:45:05 <astrolabe_> Cale: right, but maths monads are named that because they are like monoids
12:45:17 <Cale> somewhat, yeah
12:45:46 <Cale> I think they're monoid objects in the category of endofunctors over a given category.
12:45:56 <Cale> or something like that
12:45:56 <franka> A monad is a monoid.
12:46:09 <franka> A monad is a monoid object in the category of endofunctors on a category.
12:46:15 <Cale> yeah
12:46:25 <Cale> But I wouldn't call a monoid object a monoid :)
12:46:41 <Cale> To me, a monoid is a monoid object in Set
12:47:33 <astrolabe_> Ug parse error, cannot parse sentence.
12:47:48 <Cale> Set being the category of sets
12:48:24 <{Arias}> a question, if I have a string, what's the best way to take the string except the n first chars?
12:48:30 <astrolabe_> Do you mean a computer science monoid is a maths monoid in Set?
12:48:37 <Cale> drop n string
12:48:45 <{Arias}> mmm
12:48:50 <{Arias}> @type drop
12:48:51 <lambdabot> forall a. Int -> [a] -> [a]
12:48:54 <{Arias}> :)
12:48:56 <{Arias}> thanksss
12:48:57 <Cale> astrolabe_: yeah, tends to be :)
12:49:42 <{Arias}> @eval drop 20 "test"
12:49:43 <lambdabot> ""
12:49:53 <{Arias}> :)
12:51:14 <Cale> astrolabe_: a maths monoid is a category theory "monoid object" in the category of sets
12:51:43 <{Arias}> and... to find a index in a list I use List.findIndex, but if i want to find the index starting at the n position?
12:51:54 <Cale> Category theory has a generalisation of the concept of a monoid.
12:52:12 <{Arias}> is ther another funcion or i have to make the function?
12:52:16 <Cale> (+n . findIndex . drop n
12:52:20 <Cale> (+n) . findIndex . drop n
12:52:23 <Cale> ?
12:52:38 <Cale> er, not quite that, perhaps
12:52:44 <Cale> @type List.findIndex
12:52:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
12:52:58 <Cale> (+n) . findIndex p . drop n
12:53:13 <{Arias}> yes, thanks a lot :)
12:53:13 <kombinator> Cale: and if there was Zero class, could we use (Monad a, Zero a) instead of MonadZero a?
12:53:27 <Cale> kombinator: yeah
12:53:40 <kombinator> neat
12:54:55 <Cale> hmm... I wonder how much work it would be to create a separate version of the Haskell prelude/libraries that's more Haskell 1.4ish
12:55:07 <Cale> (in a good way)
12:55:24 <Cale> I wish that ghc had skill level modes :)
12:55:56 <Cale> so we wouldn't have to give up monad comprehensions and such just because the error messages require slightly more knowledge to read
12:56:55 <kombinator> Cale: like drscheme? not a bad idea
12:56:59 <Cale> yeah
12:57:06 <Cale> Haskell really needs that
12:57:28 <Cale> because there's a lot of stuff that the advanced users want that new users might possibly be scared by
12:57:33 <benmos> I for one couldn't handle any more complex error messages at the moment ;-)
12:57:40 <Cale> hehe :)
12:57:44 <benmos> (scared) ;-)
12:58:12 <Cale> well, it would give you errors about monads and functors instead of about lists at certain points, if I had things the way I want :)
12:58:54 <Cale> but I think that error reporting could be specialised to common types like lists, if it's known beforehand that you're working with lists
12:59:20 <Cale> and there could be a defaulting mechanism to make things work nicely with the interactive interface
12:59:52 <Cale> (the default type of a monad comprehension being a list, if nothing else steps in and takes it)
13:00:06 <marcot> Which function can I use to convert from Int to Double?
13:00:14 <Cale> fromIntegral
13:00:40 <Cale> which converts from Int or Integer to anything else
13:01:28 <marcot> Cale: thanks..
13:03:50 <vigen> How do I split string to words?
13:04:07 <Oejet> @type words
13:04:08 <lambdabot> String -> [String]
13:04:10 <musasabi> @types words
13:04:11 <lambdabot> String -> [String]
13:04:22 <musasabi> too slow :-(
13:04:25 <Oejet> Wow, I'm fast.
13:05:30 <vigen> Ooops, sorry Im beginner. What is @types?
13:05:59 <Cale> Lambdabot has the @type command to tell you the type of haskell expressions
13:06:28 <vigen> Ok, I see now. Thanks.
13:06:33 <Cale> @eval words "Hello, World! This is a string."
13:06:34 <lambdabot> ["Hello,","World!","This","is","a","string."]
13:06:35 <tic> they're trying to tell you to use the words function to split a string into a list of strings... ):
13:07:31 <benmos> Is there a word for the attack of type-error-fear you get before you hit the compile button?   ...and on a more serious note.... if I find that I'm chaining "liftM"s or "liftM2"s together.... is that a sign that I'm doing something horribly wrong... (I'm starting to get the feeling I'm never going to be able to understand my code if I come back to it later...)
13:07:49 <Cale> benmos: perhaps you could use ap?
13:07:55 <vigen> Is there a more general function to split List at certain element ?
13:08:01 <Cale> benmos: or do-notation
13:08:12 <benmos> ap? ...ah I think I did see it mentioned somewhere...
13:08:20 <benmos> ah - maybe do notation would make sense
13:08:21 <Cale> @eval splitAt 6 "Hello, World!"
13:08:22 <lambdabot> ("Hello,"," World!")
13:08:42 <JohnMeacham> shapr: which version? yeah, you should be able to just express the algorithm in grin itself.
13:08:50 <JohnMeacham> might be an interesting project.
13:09:13 <benmos> @type ap
13:09:14 <lambdabot> Not in scope: `ap'
13:09:34 <Cale> @eval return (,) `ap` [1,2,3] `ap` [4,5,6]
13:09:36 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
13:10:04 <Cale> @eval liftM2 (,) [1,2,3] [4,5,6]
13:10:05 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
13:10:32 <Cale> return and ap together generalise liftMn
13:10:53 <benmos> ok -thx
13:11:06 <shapr> JohnMeacham: And it'll be *fast* too
13:11:17 <Cale> but if you're using it a lot, it might be clearer just to do things in more than one step
13:11:22 <joelr> @index unsafeIOToSTM
13:11:22 <lambdabot> GHC.Conc
13:11:27 <joelr> hmm
13:11:30 <shapr> JohnMeacham: Since thunks are just GRIN nodes, speculative evaluation is just an optimization, right?
13:11:57 <joelr> howdy folks
13:12:05 <shapr> hola joelr
13:12:05 <Cale> hello
13:12:18 <shapr> joelr: Lemme guess, socket finalization?
13:12:30 <joelr> shapr: nah
13:12:36 <shapr> aww, I'm out of touch
13:12:49 <joelr> my output is getting garbled
13:12:53 <joelr> i run two threads
13:12:59 <joelr> they sent data back via a chan
13:13:02 <joelr> which i print
13:13:05 <joelr> but then i get this
13:13:06 <joelr> ThreadId 24T:h Tr[he5ra7ed,aI1dd,I 0d2, 412 ,5-1 -,--0--,- 0-S, c0Sr,ci1rp,it4p 4tf, i1fn,ii0ns,ih0se,hd0e ,d-0 -,--0--,-
13:13:09 <joelr> 0-,
13:13:19 <Cale> don't send characters down the chan
13:13:22 <Cale> send strings
13:13:43 <shapr> hiya borism
13:13:49 <joelr> Cale: I send strings. it could be something else, actually. i am printing things directly to stdout in one place
13:13:52 <joelr> checking
13:14:01 <vigen> How to split e.g. [1,2,3,0,5,6,0,7,8] -> [[1,2,3],[5,6],[7,8]]? Any function ready?
13:14:15 <shapr> partition?
13:14:20 <Cale> no
13:14:25 <basti_> he wants to split at 0's
13:14:32 <shapr> @index splitAt
13:14:33 <lambdabot> Data.List, Prelude
13:14:36 <musasabi> foldl
13:14:43 <Cale> splitAt splits at an index
13:14:50 <Cale> span or break would be handy
13:15:04 <Cale> @eval break (==0) [1,2,3,0,5,6,0,7,8]
13:15:04 <joelr> how do i set up a global STM variable?
13:15:05 <lambdabot> ([1,2,3],[0,5,6,0,7,8])
13:15:06 <shapr> Yeah, span or break
13:15:36 <Cale> joelr: You probably don't. You create one in main and pass it into your other computations.
13:16:18 <joelr> Cale: i'm trying to hide it from the users
13:16:25 <musasabi> fun list = let (xs:x) = foldl (\(acc,cur) elt -> if elt == 0 then ((reverse cur):acc,[]) else (acc,elt:cur)) ([],[]) list in reverse (x:xs)
13:16:52 <Cale> (xs:x)?
13:16:59 <vigen> break breaks to touple. I need list!?
13:17:01 <musasabi> (xs,x)
13:17:15 <musasabi> that was a typo.
13:17:38 <musasabi> vigen: you use a tuple in the foldl and then just collect a non-tuple result.
13:17:46 <musasabi> fun list = let (xs,x) = foldl (\(acc,cur) elt -> if elt == 0 then ((reverse cur):acc,[]) else (acc,elt:cur)) ([],[]) list in reverse (x:xs)
13:18:15 <vigen> musasabi: thnx. I am going to try
13:18:49 <musasabi> and make that "reverse ((reverse x):xs)
13:19:05 <musasabi> using foldr might get rid of all the reversing.
13:19:59 <musasabi> let fun2 list = let (xs,x) = foldr (\elt (acc,cur) -> if elt == 0 then (cur:acc,[]) else (acc,elt:cur)) ([],[]) list in (x:xs)
13:20:40 <Cale> foldr (\x u -> if x == 0 then []:u else case u of [] -> [x]:u; (y:ys) -> (x:y):ys) []
13:21:26 <Cale> which would perhaps be clearer if you just wrote the function recursively
13:22:03 <Cale> splitZero [] = []
13:22:46 <Cale> splitZero (x:xs) | x == 0 = [] : splitZero xs
13:23:25 <Cale> splitZero (x:xs) | otherwise = case splitZero xs of [] -> [x]; (y:ys) -> (x:y):ys
13:23:45 <Cale> which made me notice something stupid in my foldr implementation:
13:23:54 <Cale> foldr (\x u -> if x == 0 then []:u else case u of [] -> [x]; (y:ys) -> (x:y):ys) []
13:24:25 <Cale> er
13:24:31 <Cale> foldr (\x u -> if x == 0 then []:u else case u of [] -> [[x]]; (y:ys) -> (x:y):ys) []
13:24:51 <Cale> splitZero (x:xs) | otherwise = case splitZero xs of [] -> [[x]]; (y:ys) -> (x:y):ys
13:24:56 <Cale> there :)
13:25:38 <Cale> this can of course be generalised to an arbitrary predicate on the elements, which would probably be a good idea
13:25:45 <vigen> Cale: thanks. My imperative brain is trying hard to understand :)
13:26:19 <Cale> http://vx.hn.org/autoshare/foldr.png
13:26:27 <Cale> there's a picture of what foldr does
13:26:56 <Cale> foldr is the most natural fold for lists
13:27:21 <Oejet> Cale: Wow, how was that made?
13:27:22 <shapr> hei kaol
13:27:28 <Cale> Oejet: inkscape
13:27:44 <shapr> Cale: Doesn't Kahl have a project to do that automatically?
13:27:56 <Oejet> It looks like a Computer Modern font.
13:28:09 <Cale> Oejet: it's just Georgia, I think
13:28:44 * Oejet 's Oeje is untrained.
13:28:45 <Cale> shapr: well, foldr would show up like that in Kahl's language
13:28:56 <shapr> cool
13:30:23 <Cale> vigen: so the trick is choosing a good replacement for (:) and []
13:30:57 <Cale> instead of adding the element to the front of your list, your replacement (:) is going to do something with it to add it to the structure which you're building up
13:31:29 <Cale> (in this case, the list of zero-delimited segments)
13:31:49 <Cale> if it's a 0, then it starts a new segment, by adding an empty list to the front of the structure
13:32:12 <Cale> otherwise, it tacks the element onto the first list in the list of segments
13:32:25 <Cale> see how that works?
13:32:29 <vigen> Cale: isn't then easier to do it with map?
13:32:56 <Cale> map is only able to modify the elements of the list, not play around with its structure
13:33:12 <vigen> Cale: no. I take it back :)
13:33:20 <Cale> map f = foldr ((:) . f) []
13:34:07 <Cale> which could be written like  map f = foldr (\x xs -> f x : xs) []
13:35:37 <shapr> hiya poetix
13:35:40 <poetix> Hey
13:35:41 <Cale> In general, if you have an algebraic data structure, it's a good idea to write a fold which replaces the constructors of that structure with functions of a similar type.
13:36:21 <SyntaxNinja> y0
13:38:18 <Yubanalesco> Humm, can someone help me in this?: With pairs l = [(x,y) | x <- l, y <- l, x>y], I will be able to get a list of pairs where the condition x>y applies. However, it would be handy for me if instead of having pair of the elements, having pairs of indice of the element.
13:38:30 <Cale> if you had, say, a tree data type like: data Tree a = Leaf a | Branch a (Tree a) (Tree a), a good folding function would have type (a -> b) -> (a -> b -> b -> b) -> Tree a -> b -- taking replacements for the Leaf and Branch constructors
13:38:51 <basti_> Yubanalesco: are you sure that you'd not be better off with the elements themselves?
13:38:53 <Cale> Yubanalesco: zip the list with [0..]
13:40:00 <Cale> pairs l = [(x',y') | (x, x') <- zip l [0..], (y, y') <- zip l [0..], x > y]
13:40:09 <Yubanalesco> I do know that (!!) n will give me the element of the indice that of index "n". However, it seems I can't get it to work properly with list comprehension.
13:40:26 <Cale> Yubanalesco: does that do what you want?
13:40:43 <Yubanalesco> Reading it.
13:40:52 <Cale> (!! n) gives the element at index n
13:41:09 <Cale> (!!) xs is a function from indices to elements
13:41:14 * araujo wonders what the Yubanalesco nick means
13:41:24 <araujo> Hello Haskell'ers!
13:41:29 <Cale> hello
13:41:34 <Yubanalesco> Humm...Yes it does gives me the result...
13:42:09 <Cale> Yubanalesco: but in general with Haskell lists, indices are a good thing to avoid, because xs !! n takes O(n) time
13:42:12 <Yubanalesco> So you basically, assigned an extra value to each element of the list, making it work like as in index.
13:42:16 <Cale> yeah
13:42:35 <Yubanalesco> And then, using the element to compare while outputting the index...
13:42:44 <Cale> yeah
13:42:46 <Yubanalesco> Someone shoot :-/
13:42:48 <Yubanalesco> me
13:43:12 <Yubanalesco> Well, thanks Cale.
13:43:19 <Cale> pairs l = [(x',y') | let l' = zip l [0..], (x, x') <- l', (y, y') <- l', x > y]
13:43:32 <Cale> that's a little shorter perhaps
13:43:45 <Cale> hm, it's not :)
13:45:03 <Cale> well, it eliminates the common subexpression at least, which is perhaps a good thing
13:45:03 <Cale> and you're welcome btw :)
13:45:03 <Cale> hehe
13:45:06 <Yubanalesco> About the performance issue. So you are saying that it would be better if I just assign an extra value instead of using (!!) at all ?
13:45:08 <Cale> hm, lag
13:45:15 <Yubanalesco> Yeah
13:45:47 <Yubanalesco> Humm, I wouldn't really expect (!!) to be O(n)...
13:45:55 <Cale> Using !! a lot is usually a sign that you're using a list for something which lists aren't good for
13:46:06 <Cale> Haskell lists are linked lists
13:46:11 <Cale> (sort of)
13:46:21 <Yubanalesco> Well, I could use arrays, but I was thinking it may be overkill.
13:46:46 <Cale> well, if the indices you'll be using are bounded, you can probably get away with it :)
13:47:05 <Cale> there's often a better way to do things though
13:47:43 <Yubanalesco> Well, performance is what I worry a lot about.
13:48:13 <Cale> It's perhaps best to think of lists as trees which look somewhat like the tree on the left in http://vx.hn.org/autoshare/foldr.png
13:48:48 <Yubanalesco> Well, ordered trees are lethal to performance :-/
13:49:00 <Cale> well, they can be
13:49:06 <Cale> indexing into them is bad
13:49:57 <Yubanalesco> Heh, I will take your advice and start avoiding indexing so much with lists.
13:50:05 <Cale> but if you're going to recursively use the whole structure, it's not so bad, and with laziness, it's okay so long as you only use an initial segment of it
13:50:37 <Cale> You can have really long, or of course, infinite lists.
13:51:08 <Cale> (which are not ever completely built)
13:51:18 <Yubanalesco> At least, Haskell is better in dealing with infinite lists than others general languages.
13:51:25 <int-e> or unterminated lists that are (like  l = 1:l ...)
13:51:28 <Cale> Really, lists are the analogues of loops
13:52:12 <Cale> they're a data-structure realisation of loops
13:52:37 <Yubanalesco> I never viewed lists are loops...humm
13:52:57 <Yubanalesco> Or in fact, never thought about that idea.
13:53:01 <Cale> which makes them look pretty impressive if you start thinking about what sorts of operations you have on lists, and think about how that would relate to transforming code
13:53:29 <shapr> hei esap
13:53:36 <esap> Hi!
13:53:40 <shapr> How's code?
13:54:02 <Cale> Every data structure in Haskell is also a mechanism for control flow.
13:54:10 * esap is wondering how to build explicit examples of non-principal ultrafilters :-)
13:54:17 <Cale> esap: you don't
13:54:35 <Cale> iirc, you need the axiom of choice to give one
13:54:47 <esap> cale: yea, I've read it involves the axiom of choice. But maybe the mandelbrot set is one :-)
13:54:56 <Cale> um...
13:55:47 <Cale> on what lattice?
13:56:51 <esap> cale: depth of iteration should give ordering.
13:57:11 <Cale> well, that gives you a collection of sets
13:57:16 <Cale> (subsets of C)
13:57:24 <Cale> but that's not an ultrafilter
13:57:36 <Cale> on 2^C
14:00:14 * esap doesn't understand the notion of an ultrafilter well enough to distinguish it.
14:00:29 <Cale> and the mandelbrot set itself makes sure that it's a filter base, but it's not an upper set.
14:01:06 <Cale> that is, there are supersets of sets there which aren't in your collection
14:01:15 <Cale> in particular, all of C isn't one of your sets
14:01:34 <Cale> well, I suppose it might be
14:01:50 <Cale> but then, say, the disc of radius 10 in C isn't there
14:03:23 <esap> How about choosing just the "outside" of the mandelbrot set?
14:04:08 <Cale> well, you could use the M set to generate a principal ultrafilter
14:04:24 <Cale> er, hmm
14:04:30 <Cale> maybe not ultra
14:05:06 <Cale> a principal filter anyway
14:05:45 <Cale> like, the set of all sets containing the M-set is a filter on 2^C
14:07:07 <Cale> to get an ultrafilter, you have to have the property that adding one more set would force you to add every subset of C
14:07:09 <Cale> but I don't see any particular way to involve the M-set in such a thing
14:07:12 <int-e> Cale: an ultrafilter is a maximum non-trivial filter (i.e. adding one more element to it forces it to become trivial)?
14:07:12 <Cale> sorry, I'm terribly lagged for some reason
14:07:22 <Cale> int-e: yeah
14:07:33 <Cale> maximal
14:07:59 <Cale> (usually not maximum)
14:08:12 <int-e> Cale: (where 'element' means an element of the lattice). maximal, right. thanks.
14:08:32 <esap> Cale: Maybe that can happen if you choose the order in such way that largest elements of the order are in the border between inside and outside of the mandelbrot set?
14:08:41 <bourbaki> hey esap
14:08:52 <esap> hi
14:09:12 <Cale> well, ultrafilters on a set have the property that either a set or its complement are in the ultrafilter
14:09:26 <bourbaki> a pitty that you havent been there a bit earlier when i tried to explain my program stuff again i think i have made some progression
14:09:26 <Cale> so they in some sense fill half the lattice
14:10:14 <Cale> (some top half)
14:10:56 <int-e> [you need a boolean algebra to make that precise I'd say]
14:11:15 <Cale> well, that is the precise formulation
14:11:44 <Cale> that for every subset X of S either X or S\X is in the ultrafilter, and not both.
14:12:12 <bourbaki> and zorns lemma is also needed
14:12:31 <int-e> obviously, because if it contained both, it'd also contain X /\ S\X = 0, and therefore all subsets of S, i.e. be trivial.
14:12:37 <Cale> right
14:12:50 <int-e> and if it'd contain neither, one of them could be added to the filter.
14:13:04 <Cale> bourbaki: well, zorn's lemma gets involved in constructing nonprincipal ultrafilters
14:13:10 <Cale> int-e: yeah
14:13:22 <int-e> it comes back :)
14:13:58 <bourbaki> i just remembered that we used zorns lemma to proof something with boolean algebras :)
14:14:02 <int-e> it's coming back, I mean. I've heard a lecture about logic and ultrafilters and stuff ... uhm ... 6 years ago or so.
14:14:09 <Cale> :)
14:14:14 <Cale> Model theory?
14:14:37 <int-e> yes, for first order logic.
14:14:40 <Cale> I took a course on model theory, which is where I picked this stuff up.
14:14:45 <esap> Ok, then if I define subset X of S to be in the proposed ultrafilter, if area(S \intersect Mandelbrot-set) <= area(S\X \intersect Mandelbrot-set) ?
14:15:05 <Cale> well, you'll run into problems talking about area
14:15:14 <Cale> what about nonmeasurable sets? :)
14:15:26 <esap> heh, well mandelbrot set is undecidable anyway :-)
14:16:02 <Cale> Well the area is well-defined, at least, I'm fairly sure the mandelbrot set is measurable :)
14:16:47 <basti_> the area of the mandelbrot set is well-known i think
14:16:50 <Cale> the area of the whole M-set
14:16:52 <esap> I meant area(X \intersect Mandelbrot-set) <= area(S\X \intersect Mandelbrot-set)  [obviously]
14:16:53 <Cale> yeah
14:17:09 <Cale> yeah
14:17:23 <int-e> but that doesn't define a lattice
14:17:27 <int-e> hmm
14:17:53 <int-e> nm
14:18:31 <Cale> what happens when they're both 0?
14:18:49 <Cale> er
14:18:51 <Cale> heh
14:18:52 <Cale> nm
14:19:14 <Cale> but they might both be undefined
14:19:17 <int-e> measurable sets form a lattice, right?
14:19:34 <Cale> yeah
14:19:48 <Cale> Fairly sure they do, anyway
14:20:42 <int-e> well, we can restrict ourselves to measurable setz X and S (for there to be a maximum subset of S) then.
14:20:43 <Cale> well, yeah, they form more than that
14:20:48 <bourbaki> arent all haussdorff sets lattices?
14:20:59 <Cale> bourbaki: in what sense?
14:21:36 <bourbaki> well there is a union and an intersetion
14:21:45 <bourbaki> which is like and and or
14:21:50 <Cale> of open sets?
14:21:51 <int-e> but the defined set isn't a filter. In fact, S should be an element of the filter and isn't.
14:22:04 <bourbaki> if its a compact space there also is a top element
14:22:13 <Cale> int-e: yeah
14:22:16 <Cale> good point :)
14:22:37 <Cale> bourbaki: what?
14:22:51 <bourbaki> if the space is compact that you define your stuff on
14:22:52 <Cale> what poset are you talking about?
14:22:58 <bourbaki> then this set is the top element
14:23:01 <esap> maybe could use approximations to the mandelbrot set to define ordering
14:23:03 <gzl> are you guys talking about the Stone representation theorem or something?
14:23:07 <bourbaki> cause its the infimum of all the operations
14:23:23 <Cale> gzl: I have no idea what bourbaki is referring to at the moment
14:23:28 <esap> gzl: ultrafilters and mandelbrot set.
14:23:32 <gzl> oh
14:24:07 <bourbaki> Cale: a lattice has basically two operatios
14:24:13 <Cale> bourbaki: right
14:24:15 <bourbaki> union and intersection
14:24:16 <gzl> because that theorem gives an equivalence between totally disconnected compact Hausdorff spaces and Boolean algebras, which sounds similar to what you're saying
14:24:33 <bourbaki> there always is a union and intersection for hausdorff spaces
14:24:50 <esap> gzl: Actually stone representation theorem is very closely related to this.
14:24:50 <bourbaki> and if you talk about a compact space
14:25:04 <bourbaki> not an infinitely big then there is of course a limit
14:25:12 <bourbaki> and this limit is the top elemnt
14:25:12 <Cale> bourbaki: perhaps you mean something different from what I think of when you're saying Hausdorff space
14:25:21 <bourbaki> that is the union of all sets you use
14:25:39 <bourbaki> hausdorff just says that there are sets that are speratable
14:25:47 <gzl> no
14:25:53 <gzl> that's not what it says
14:26:06 <gzl> it just says that any two points can be separated by nbhds
14:26:12 <bourbaki> ok that points are sperateble
14:26:13 <Cale> it says that points can be separated by open sets, yeah
14:26:29 <bourbaki> but in quotioent spaces thats the same
14:26:37 <Cale> what?
14:26:40 <gzl> ?
14:26:54 <bourbaki> well areas are points in quotient spaces
14:27:08 <Cale> um
14:27:13 <Cale> areas?
14:27:33 <bourbaki> lets say you have the surface of the table T
14:27:46 <bourbaki> and it you use your flex to cut something out
14:27:53 <bourbaki> and this area is called ~
14:28:18 <gzl> your flex?
14:28:26 <Cale> um, huh? You're defining an equivalence relation by partitioning the table?
14:28:29 <bourbaki> then T \ ~ is the table plus one "point" that is the stuff you cut out
14:28:34 <Cale> um, no
14:28:36 <bourbaki> contraction that is
14:28:39 <Cale> what?
14:28:48 <bourbaki> you contract an area to a point
14:29:00 <esap> I think you mean the points are equivalence classes in quotient spaces?
14:29:08 <bourbaki> yes
14:29:22 <bourbaki> or cells
14:30:10 <syntaxfree> I is back, after a short sabbatical.
14:30:11 <bourbaki> anyway any compact space that is hausdorffs can also form a lattice
14:30:23 <syntaxfree> oo topology.
14:30:30 <Cale> bourbaki: there is a certain irony in your nickname, you know :)
14:30:34 <bourbaki> the empty set is the bottom element
14:30:40 <bourbaki> and the whole area is the top
14:30:46 <bourbaki> which one?
14:30:54 <Cale> bourbaki: you just mean the lattice of open sets?
14:31:06 <bourbaki> Cale: yes
14:31:15 <Cale> okay, well, you could have said that :)
14:31:22 <syntaxfree> anyway. In one line, a function that gives me a random  integer between 1 and n?
14:31:28 <bourbaki> if you do all this in a non compact space there is no top element though
14:31:45 <bourbaki> Cale: i was trying to do that but i am bad at explaining stuff
14:31:45 <Cale> syntaxfree: that's not a function :) Look in the Random library
14:32:01 <syntaxfree> I've been trying that.
14:32:10 <Cale> syntaxfree: well, it's a function from a random number generator to an integer
14:32:14 <syntaxfree> I'm still half-way grokking monads and stuff.
14:32:19 <syntaxfree> yes, yes.
14:32:21 <Cale> or an IO computation
14:32:46 <bourbaki> Cale: and i think that there is a strong connection of utrafilters and hausdorff spaces
14:32:49 <Cale> x <- randomRIO (1,n)
14:33:21 <syntaxfree> can I write that as a function?
14:33:29 <syntaxfree> rn x = randomRIO (1,x)
14:33:30 <syntaxfree> ?
14:33:37 <Cale> well, yeah
14:33:46 <Cale> but that function doesn't return an Integer
14:34:05 <Cale> it returns an IO computation which if executed, produces an Integer
14:34:47 <Cale> syntaxfree: in Haskell, functions always produce the same result when you pass them the same input
14:35:01 <Cale> this is a very nice property to obey
14:35:28 <esap> referential transparency
14:35:32 <Cale> yes
14:37:03 <syntaxfree> hmm.
14:37:15 <syntaxfree> ok, this is the deal. I'm trying to write a genetic algorithm.
14:37:35 <syntaxfree> the randomness part has to be written in the "do" block of my main function, then?
14:37:43 <Cale> yeah
14:37:53 <Cale> main isn't a function though :)
14:38:13 <Cale> well, part of it has to be
14:38:14 <bourbaki> syntaxfree: use my program graphs for genetric algos :)
14:38:28 <bourbaki> they are perfectly suited for genetic programs
14:38:32 <Cale> you at least have to get a generator from main
14:38:57 <syntaxfree> my genetic algorithm is a simple combinatorial optimization problem, not fancier genetic programming stuff.
14:39:11 <syntaxfree> I've been wishing for a ready-made GA lib for Haskell, though.
14:39:52 <syntaxfree> One more newb question?
14:40:01 <syntaxfree> why is Data Bit = 0 | 1  invalid?
14:40:23 <syntaxfree> I'm encoding them as a list of bools now, which is useful because I have xor, but..
14:40:29 <Cale> because 0 and 1 aren't valid constructor names
14:40:35 <syntaxfree> hmm.
14:40:40 <syntaxfree> but, but
14:40:42 <Cale> also Data shouldn't be capitalised
14:40:43 <joelr> any multithreading experts?
14:40:57 <Cale> Constructors have to start with an uppercase letter
14:40:59 <syntaxfree> in the examples you see things like "data Color = Red | Green | Blue
14:41:09 <Cale> data Bit = Zero | One
14:41:13 <syntaxfree> hmm.
14:41:17 <SyntaxNinja> joelr: what's your question?
14:41:23 <xerox2> yooooooo
14:41:27 <syntaxfree> and suppose I want to implement xor for Bit?
14:41:35 <xerox2> Cale, straigthforward!
14:41:53 <xerox2> @index .|.
14:41:53 <lambdabot> Data.Bits, Foreign
14:42:00 <joelr> i start a bunch of threads that write back through a Chan. the code that waits for children launches a separate thread to read from the chan and write to screen and file
14:42:01 <Cale> xor = (/=)
14:42:01 <xerox2> @docs Data.Bits
14:42:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
14:42:16 <Cale> Why not just use Bool?
14:42:17 <int-e> syntaxfree: neg Zero = One; negate One = Zero; xor Zero a = a; xor One a = negate a
14:42:17 <xerox2> Cale: yeah, that was cool when I first read it :D
14:42:36 <joelr> SyntaxNinja: for some reason i don't always see the complete output, specially after waitForChildren terminates before the logging thread has had a chance to log all the data
14:42:42 <syntaxfree> I just sat "xor Zero" etc. etc?
14:43:02 <syntaxfree> but isn't "xor" declared something like Bool->Bool->Bool?
14:43:19 <syntaxfree> @type xor
14:43:19 <lambdabot> Not in scope: `xor'
14:43:21 <Cale> (/=) :: (Eq a) => a -> a -> Bool
14:43:28 <joelr> SyntaxNinja: if i try to do something else then, like run main again then the rest of the output shows up. i'm doing this from ghci
14:43:34 <Cale> @eval True /= False
14:43:35 <lambdabot> True
14:43:41 <Cale> @eval True /= True
14:43:42 <lambdabot> False
14:43:48 <Cale> @eval False /= False
14:43:49 <lambdabot> False
14:43:54 <syntaxfree> smart.
14:44:57 <SyntaxNinja> joelr: so is the program terminating before it has done all the logging?
14:45:13 <joelr> SyntaxNinja: the "main thread" certainly is
14:45:41 <joelr> SyntaxNinja: it appears that the logger thread then sort of stops too. until i do something at the ghci prompt that somehow awakes it and it finishes up
14:46:02 <Cale> joelr: if the main thread terminates, all the others will too
14:46:11 <joelr> hmm
14:46:16 <Cale> but I don't know how concurrency works with GHCi
14:46:33 <Cale> I'd recommend just compiling the bloody thing so it works sanely :)
14:47:18 <joelr> :-)
14:47:33 <joelr> i'm gonna try to make the logger thread one of the children to be watched
14:47:41 <joelr> and terminate it on a read timeout from the channel
14:49:57 <SyntaxNinja> makes  sense
14:50:32 <joelr> i'm curious if anyone has done heavy-duty networking with ghci
14:50:33 <joelr> err
14:50:34 <joelr> ghc
14:51:21 <joelr> making the logger thread one of the children has certainly helped!
14:51:22 <sylvan> joelr, some people wrote a web server that faired pretty well against apache
14:51:24 <joelr> with 2 threads
14:51:29 <joelr> i gotta try a few thousand
14:51:29 <Cale> syntaxfree: you might consider just using the Rand monad which I put on the wiki
14:51:43 <joelr> sylvan: i think i know who these people are :)
14:52:10 <Cale> syntaxfree: if your code is pure except for needing random numbers every now and then, that's a good way to write it
14:53:23 <Cale> http://www.haskell.org/hawiki/MonadTemplateLibrary_2fMonadRandom
14:53:36 <Cale> also see http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
14:56:41 * xerox2 advocates MonadRandom too
15:05:53 <shapr> g'day Pseudonym
15:06:07 <Pseudonym> G'day.
15:06:10 <shapr> hiya cge, learning Haskell?
15:10:19 * shapr yodels
15:10:27 <syntaxfree> so.
15:10:31 <syntaxfree> this is my sad life story.
15:10:36 <syntaxfree> bring out the kleenexes. it's weepy.
15:10:39 <syntaxfree> ready?
15:10:46 <shapr> k
15:10:58 <syntaxfree> I'm about to complete my BS in economics.
15:11:14 <Cale> syntaxfree: did you read the Wiki pages I posted links to, btw?
15:11:14 <shapr> yeah?
15:11:31 <syntaxfree> Horrible GPA, a couple of failed courses. Been completely unmotivated all the time through.
15:11:56 <syntaxfree> So now I'm trying to claw my way into a program in applied numerical mathematics at another place.
15:12:13 <shapr> Er, why not just finish your Economics degree?
15:12:25 <syntaxfree> yes, I'm gonna finish it.
15:12:31 <syntaxfree> it's just one more month.
15:12:34 <shapr> ok
15:12:53 <syntaxfree> So, the maths school mostly want a school record, recommendation letters  and one letter from myself stating my intentions, etc.
15:12:58 <syntaxfree> I don't know WHAT to write there.
15:13:09 <syntaxfree> It has to be pretty magical, as it needs to offset my bad school history.
15:13:22 <shapr> Why not just say you like it?
15:13:47 <syntaxfree> because my school record shows that, although smart-ish, I'm an irresponsible slob.
15:13:50 <Cale> Well, intentions letters are sometimes not for the profs, but for the people who are deciding who to consider
15:14:21 <Cale> (who might be administrative people)
15:14:47 <syntaxfree> what should I say?
15:14:58 <Cale> Well, what are you intending to do?
15:15:08 <shapr> I tell the truth on those sorts of letters. Works for me.
15:15:12 <Cale> Why are you interested in numerical math?
15:15:26 <shapr> Or in the cases where it doesn't work, at least I know they didn't want my sort of person :-)
15:15:54 <Cale> right, if they don't accept you, they're doing you a favour
15:15:55 <syntaxfree> hmm. Because I like it? :~
15:16:07 <syntaxfree> I took a summer course in numerical math at that school.
15:16:13 <bourbaki> Cale: how old are you?:)
15:16:20 <Cale> 22
15:16:24 <syntaxfree> I'm 23 years old.
15:16:42 <syntaxfree> Masters programs in economics require going through a national exam.
15:16:57 <syntaxfree> It's a three-day, 12-hours-a-day massacre. I flunked it.
15:17:09 <pdzq> It seems as if transitioning from econ to math would be...hard.
15:17:21 <Cale> pdzq: why?
15:17:24 <syntaxfree> I need to find something to do next year, or I'll have to ... get .. a .. job.
15:17:31 <syntaxfree> pdzq: it isn't, really.
15:17:43 <joelr> how do you get the current time in haskell? for logging/timestamping
15:18:00 <syntaxfree> pdzq: my problem is my underwhelming scholastic record.
15:18:01 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
15:18:16 <pdzq> Well unless you have a good standing in the mathematics core...
15:18:21 <joelr> Cale: thanks!
15:18:30 <syntaxfree> economics courses are pretty strong in the mathematics core.
15:18:39 <SamB> Cale: you are doing things the hard way
15:18:52 <SamB> @doc System.Time
15:18:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
15:19:33 <pdzq> Are you stating that you have performed well in your requisite math courses?
15:19:57 <syntaxfree> I have taken summer courses at the school I'm applying to.
15:20:06 <pdzq> Yes, but have you done well?
15:20:25 <syntaxfree> yes, in the odd summer courses I've taken at the school I'm applying to.
15:20:36 <pdzq> Then that's reassuring.
15:20:37 <syntaxfree> Then again, I flunked one math course at the school I'm currently in.
15:20:53 <syntaxfree> I've mostly fucked up my record in the school I'm in right now.
15:21:09 <pdzq> Do you have any interesting research projects?
15:21:29 <syntaxfree> I've done undergrad-level research in economics, with a government grant.
15:21:48 <pdzq> Ah.
15:21:54 <syntaxfree> I'll never understand why they gave me the grant.
15:22:09 <syntaxfree> I don't have an outstanding GPA.
15:22:19 <pdzq> What country?
15:22:39 <syntaxfree> and the people responsible for choosing me were the professors from my own department.
15:22:53 <syntaxfree> Brazil.
15:22:57 <pdzq> Ah.
15:24:34 <syntaxfree> I'm basically screwed.
15:24:54 <syntaxfree> So my intentions letter has to be hypnotically, magically compelling.
15:25:19 <syntaxfree> something that tells them "I've been a slob all my life but now I'm ready to get my act together. Please give me a chance".
15:26:06 <pdzq> Have your marks improved?
15:26:56 <shapr> syntaxfree: There's an easy solution. Do what motivates you.
15:27:06 <syntaxfree> Yes. What motivates me is numerical maths.
15:27:11 <syntaxfree> But... I need to get in the program.
15:27:23 <shapr> Whether or not you get accepted to this particular program, continue to do what motivates you, and you'll do a good job.
15:27:41 <pdzq> Well if you've demonstrated a significant improvement in your academics that goes further to saying, "I'm ready to turn my life around."
15:27:43 <syntaxfree> I can't just stay at home next year.
15:27:58 <shapr> I got self-employed and now I can study all the type theory I want.
15:28:06 <shapr> Of course, I still get paid to write Python.....
15:28:19 <syntaxfree> actually, there's a significant descent in my academic scores since I've become fed up with economics.
15:28:29 <shapr> ergo, don't do something you can't stand
15:28:42 <syntaxfree> I've abandoned a BA program in film studies before.
15:29:01 <syntaxfree> I look like an inconstant, ever-drifting, smart-ish but forever irresponsible slob.
15:29:01 <shapr> I abandoned Radiation Safety, Art, Computer Art, and Computer Science.
15:29:15 <shapr> syntaxfree: You could take my solution...
15:29:17 <shapr> Ritalin!
15:29:29 * shapr grins
15:29:37 <pdzq> I'll have some Ritalin with a side of Adderall.
15:29:50 <shapr> Actually, I take Concerta these days.
15:29:50 <pdzq> And the triple shot espresso.
15:30:04 <shapr> Ritalin and Adderall have their good points though.
15:30:11 <joelr> does the error monad stop computations on Nothing?
15:30:15 <syntaxfree> well, I'm trying to convince the fine folks at the maths school that I will get my act together right now.
15:30:24 <syntaxfree> Though I'm not really that convinced myself.
15:30:34 <integral> joelr: isn't Nothing a constructor of the Just monad?...
15:30:35 <dbremner> shapr - amen. Better living through controlled substances. ;-)
15:30:45 <shapr> dbremner: y0, wassup? Haven't heard anything from you lately.
15:31:01 <shapr> syntaxfree: Well, either get convinced or do something else.
15:31:16 <joelr> integral: well, i'm using the maybe monad now so if nothing is returned then the computation is stopped
15:31:22 <joelr> integral: thus my question
15:31:59 <integral> joelr: umm, well in the Error monad you wouldn't be returning Nothing :).   Maybe fail would help?
15:32:04 <integral> @type Control.Monad.fail
15:32:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
15:32:25 <syntaxfree> I want to change.
15:32:28 <dbremner> shapr - I spent a week in California fixing computers, I've been trying to stay offline to give my wrists a rest.
15:32:28 <syntaxfree> I really want to change.
15:32:40 <joelr> integral: umm... right
15:33:04 <integral> hmm, what's the difference between fail and mzero?
15:33:31 <dbremner> syntaxfree - is it just a letter or is there a personal interview?
15:33:52 <syntaxfree> a letteer.
15:36:17 <dbremner> shapr - is your "I am not a koala" layout publically available?
15:38:35 <shapr> yes!
15:38:46 <shapr> Do you have a Kinesis keyboard?
15:38:51 <dbremner> shapr - I just got one.
15:38:55 <shapr> w00!
15:38:59 <shapr> Are you using dvorak?
15:39:34 <dbremner> shapr - not yet, but I'm going to switch.
15:39:46 <shapr> Anyway, the principle is simple, I put Shift_L onto DEL, and remapped Home and PgUp to Hyper, and End and PgDn to Super.
15:40:26 <shapr> Then I made purpose specific keybindings for emacs, caps_lock is hippie-expand, Shift_R is now iswitchb
15:40:39 <shapr> And I have a bunch more purpose specific keys on the F keys.
15:40:39 <syntaxfree> trying dvorak is like being 3 years old again./
15:40:42 <syntaxfree> not. pleasant.
15:41:01 <shapr> syntaxfree: Except that I tried dvorak in 1992, and stuck with it.
15:41:16 <syntaxfree> persistence is the name of the game.
15:41:24 <syntaxfree> most of the time, anyway.
15:41:28 <dbremner> syntaxfree- I'm a 2 finger typist right now, so it's not like I'm losing years of experience. ;-)
15:41:43 <syntaxfree> I'm a six-finger typist.
15:41:47 <syntaxfree> But I'm bloody fast at it.
15:42:56 <syntaxfree> I'm as good as fried chicken.
15:43:10 <Lor> Does anyone really use all ten fingers? _Both_ thumbs?
15:43:40 <shapr> I do.
15:43:57 <syntaxfree> I use both thumbs.
15:44:07 <syntaxfree> Plus three other fingers.
15:44:15 <shapr> My custom chording keymap really helps me use my thumbs.
15:44:16 <syntaxfree> I think the only fingers I don't use are my pinkies.
15:48:09 <shapr> Lor: If you put Shift under your left thumb and space and enter under your right thumb, you too will use both thumbs.
15:56:24 <marcot> dcoutts: hello there.
15:56:37 <marcot> Just packaged gtk2hs 0.9.10
15:58:32 <dcoutts> marcot, cool!
15:58:49 <dcoutts> I've got got my first Gtk2Hs with HOpenGL program working :-)
15:58:59 <dons> cool!
15:59:08 <dcoutts> I've got a Gtk+ window with a rotating code :-)
15:59:15 <dcoutts> cube I mean
15:59:29 <ozone> dcoutts: rotating code would be cooler :)
15:59:35 <dcoutts> look ma! no segfaults!
15:59:46 <dcoutts> ozone, heh, yeah I'll do that next :-)
16:00:07 <dons> yeah, haskell has 2-d layout, maybe 3-d would be better
16:00:31 <dons> might need editor support though.
16:01:37 <xerox2> What would you use the third dimension of code for?
16:02:11 <marcot> dcoutts: it doesn't require gtk 2.8
16:02:15 <marcot> The site is wrong.
16:02:26 <dons> parallel code?
16:02:59 <xerox2> dons: AH.
16:03:07 <dcoutts> marcot, I'm not sure what you mean. What site?
16:03:09 <xerox2> A better visualization for
16:03:41 <xerox2> @eval [(x,y) | x <- [0..] | y <- [0..]]
16:03:42 <lambdabot>  Illegal parallel list comprehension: use -fglasgow-exts
16:03:43 <marcot> dcoutts: sorry, I'm missing some things here.
16:18:09 <marcot> dcoutts: when I'm trying to compile the mozembed demo it sais:
16:18:17 <marcot> /usr/bin/ld: cannot find -lgtkembedmoz
16:18:26 <marcot> but:
16:18:49 <marcot> marcot@tonhao:~/desenvolvimento/debian/gtk2hs/gtk2hs-0.9.10/demo/mozembed$ ls /usr/include/mozilla/gtkembedmoz/
16:18:53 <marcot> gtkmozembed.h  gtkmozembed_internal.h
16:18:59 <marcot> dcoutts: do you know what's getting wrong?
16:22:42 <marcot> This is the only example where I don't get things to work.
16:24:19 <Cale> maybe the headers are installed but not the library?
16:25:01 <marcot> Cale: hum.. I installed mozilla-dev in debian. Do you have a suggestion of package?
16:25:24 <Cale> hmm
16:30:52 <marcot> You should add a entry in the website for the 0.9.10 release.
16:31:19 <Cale> you mean dcoutts should :)
16:31:20 <marcot> And update the windows version in the download page.
16:31:26 <marcot> =D
16:38:42 <syntaxfree> Cale: yes, I saw those some time ago.
16:38:47 <syntaxfree> Cale: the hawiki links.
16:38:50 <Cale> yeah
16:39:03 <syntaxfree> I was just wondering if there was a simple way to do the simplest stuff.
16:39:40 * syntaxfree luvs paralell list comprehensions.
16:41:52 <marcot> syntaxfree: where are you from?
16:48:00 <marcot> dcoutts: are you there?
16:50:33 <syntaxfree> Im in thr hawiki map.
16:50:36 <syntaxfree> Go fetch me :)
16:50:42 <syntaxfree> s/fetch/find.
16:51:25 <marcot> dcoutts: the map does not say the city.
16:52:27 <syntaxfree> google maps to the rescue?
17:01:28 <marcot> syntaxfree: ok, you're free not to say it.
17:03:57 <syntaxfree> Rio de Janeiro. I just wanted to make it more fun.
17:23:25 <luqui> Only unit numeric type pattern is valid
17:23:31 <luqui> what's the "unit numeric type pattern"?
17:23:51 <syntaxfree> @fact unit numeric type pattern
17:23:51 <lambdabot> I know nothing about unit
17:23:58 <syntaxfree> @fact Haskell
17:23:58 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
17:24:19 <bojohan> "1"
17:24:25 <xerox2> luqui: maybe you're using the same argument as multiple values-types?
17:24:27 * luqui gathered that much
17:24:32 <marcot> syntaxfree: ok, I'm from Belo Horizonte.
17:24:37 <marcot> syntaxfree: what do you do there?
17:24:46 <luqui> I just wrote: undefined :: 2 in ghci
17:24:55 <luqui> and it said that, so I wrote: undefined :: 1
17:25:06 <luqui> and it told me that it couldn't show GHC.Base.Unit
17:25:12 <luqui> but I can't tell what GHC.Base.Unit is
17:25:23 <xerox2> Type 2 ?!
17:25:30 <luqui> yeah, I was just screwing around
17:25:32 <luqui> and now I'm curiou
17:25:33 <luqui> s
17:26:43 <luqui> oh, it appears (from the logs): data Unit = Unit
17:27:12 <syntaxfree> marcot: Nowadays, I angst over applying for a masters program.
17:27:24 <luqui> @kind 1
17:27:25 <lambdabot> *
17:27:32 <syntaxfree> marcot: http://www.navarro.mus.br/od/profissional
17:27:34 <syntaxfree> that's me.
17:28:53 <marcot> syntaxfree: have you graduated in CS?
17:29:08 <marcot> Now I saw the link
17:29:49 <marcot> syntaxfree: hum... cool.
17:31:12 <Cale> 1 has a single value called Unit
17:31:23 <Cale> it's just a GHC thing
17:32:23 <luqui> why does it get such a special name?
17:32:44 <Cale> because it's the unit with respect to product of types
17:32:53 <luqui> ?
17:33:08 <Cale> (a,1) is isomorphic to 1
17:33:09 <Cale> er
17:33:10 <Cale> a
17:33:13 <Cale> (a,1) is isomorphic to a
17:33:24 <luqui> oh, so it's just like ()
17:33:26 <Cale> if (,) is the product type
17:33:28 <Cale> yeah
17:33:40 <luqui> huh. how boring.
17:33:43 <luqui> :-)
17:33:48 <Cale> yeah, it's quite boring :)
17:34:26 <luqui> thanks
17:36:11 <marcot> @kind 0
17:36:12 <lambdabot> Only unit numeric type pattern is valid
17:36:20 <marcot> @kind 2
17:36:21 <lambdabot> Only unit numeric type pattern is valid
17:43:14 <xerox2> Goofnight
17:47:55 <ski> @kind (*)
17:47:56 <lambdabot> parse error on input `*'
17:48:02 <ski> @kind (->)
17:48:03 <lambdabot> ?? -> ? -> *
17:51:54 <dons> lots of kinds for everyone!
17:52:30 <ski> @sort *
17:52:30 <lambdabot> Maybe you meant: more part
17:52:34 <ski> @sort ?
17:52:35 <lambdabot> Maybe you meant: more part
17:52:38 <ski> bah :)
17:53:13 <syntaxfree> @type (.)
17:53:13 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
17:53:27 <syntaxfree> @type ap
17:53:28 <lambdabot> Not in scope: `ap'
17:53:36 <Cale> @type Monad.ap
17:53:37 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
17:54:03 <ski> @type flip . (.)
17:54:04 <lambdabot> forall b b1 c. (b1 -> c) -> b -> (b -> b1) -> c
17:54:52 <ski> @type flip . flip (.)
17:54:53 <lambdabot> forall b b1 c. (b -> b1) -> b -> (b1 -> c) -> c
17:58:57 <ski> @type (flip ($) .)
17:58:57 <lambdabot> forall b b1 a. (a -> b) -> a -> (b -> b1) -> b1
17:59:15 <ski> @pl flip . flip (.)
17:59:15 <lambdabot> flip . flip (.)
17:59:23 <ski> @pl (flip ($) .)
17:59:24 <lambdabot> (flip id .)
18:03:32 <araujo> @index exitFailure
18:03:33 <lambdabot> System.Exit
18:03:46 <araujo> @index hPutStrLn
18:03:46 <lambdabot> System.IO
18:04:44 <araujo> @index handle
18:04:44 <lambdabot> Control.Exception
18:10:13 <syntaxfree> @eval (/) 3 5
18:10:14 <lambdabot> 0.6
18:10:29 <syntaxfree> @eval (flip . (/)) 3 5
18:10:30 <lambdabot>  add an instance declaration for (Show ((b -> c) -> c))
18:10:57 <syntaxfree> @eval (flip . (/))
18:10:57 <lambdabot>   add an instance declaration for (Show ((b -> c) -> b -> (b -> c) -> c))
18:11:08 <syntaxfree> @eval (flip . (/)) 3
18:11:08 <lambdabot>  add an instance declaration for (Show (b -> (b -> c) -> c))
18:11:11 <syntaxfree> :(
18:11:45 <araujo> @type flip
18:11:46 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
18:12:00 <syntaxfree> @eval (flip . (/3)) 5
18:12:01 <lambdabot>  add an instance declaration for (Show (b -> a -> c))
18:12:30 <syntaxfree> @ ((1/) . (/3)) 5
18:12:30 <lambdabot> Maybe you meant: all-dicts arr babel botsnack code devils dice dict dict-
18:12:30 <lambdabot> help docs dummy dynamic-load dynamic-reload dynamic-unload easton echo
18:12:30 <lambdabot> elements elite eurohaskell eval fact fact-cons fact-delete fact-set fact-
18:12:30 <lambdabot> snoc fact-update foldoc fortune gazetteer ghc google help hitchcock
18:12:30 <lambdabot> hoogle hoogle+ index jargon join karma karma+ karma- kind learn leave
18:12:32 <lambdabot> [6 @more lines]
18:12:36 <arjanb> @eval (flip (/)) 3 5
18:12:37 <lambdabot> 1.6666666666666667
18:12:37 <luqui> @eval (flip (/)) 3 5
18:12:38 <lambdabot> 1.6666666666666667
18:12:45 <syntaxfree> hmm.
18:12:56 <luqui> @t flip (/)
18:12:57 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
18:12:57 <lambdabot> null topic-snoc topic-tail topic-tell type pl wn
18:12:59 <syntaxfree> @eval (flip (**)) 2 9
18:13:00 <luqui> @type flip (/)
18:13:01 <lambdabot> 81.0
18:13:01 <lambdabot> forall b. (Fractional b) => b -> b -> b
18:13:05 <syntaxfree> goooooood.
18:13:06 <luqui> @type flip . (/)
18:13:06 <lambdabot> forall b c. (Fractional (b -> c)) => (b -> c) -> b -> (b -> c) ->
18:13:06 <lambdabot> c
18:13:16 <syntaxfree> flip sounds useful for pointless stuffl.
18:13:26 <syntaxfree> @pl f x y = (x+y)/(x-y)
18:13:26 <lambdabot> f = ap (ap . ((/) .) . (+)) (-)
18:13:29 <luqui> I think flip is kinda useful for everyday readability
18:13:50 <syntaxfree> @pl f x y = (x+y)/x
18:13:50 <lambdabot> f = flip =<< ((/) .) . (+)
18:13:59 <syntaxfree> @type (=<<)
18:14:00 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
18:14:14 <syntaxfree> @pl f x y = 1 + y/x
18:14:14 <lambdabot> f = ((1 +) .) . flip (/)
18:14:15 <luqui> it's using the (->) a monad again
18:14:26 <syntaxfree> nice.
18:15:00 <araujo> @eval (flip (++)) "rules " "haskell"
18:15:01 <lambdabot> "haskellrules "
18:15:43 <luqui> @eval flip flip "rules" (++) "haskell "
18:15:45 <lambdabot> "haskell rules"
18:16:11 <luqui> @eval flip flip "rules" flip (++) "haskell "
18:16:12 <lambdabot> "haskell rules"
18:16:14 <luqui> wheeee
18:16:49 <syntaxfree> @pl f x r n = x*(1+r)**n
18:16:49 <lambdabot> f = (. ((**) . (1 +))) . (.) . (*)
18:17:03 <luqui> @pl \x -> x x
18:17:03 <lambdabot> join id
18:25:24 <spacko> http://spacko.sky.prohosting.com/
18:27:02 <araujo> spacko, ?
18:27:14 <spacko> its my website
18:36:19 <syntaxfree> @spam
18:36:19 <lambdabot> Unknown command, try @listcommands.
18:36:25 <syntaxfree> @fact spam
18:36:26 <lambdabot> I know nothing about spam
18:36:33 <syntaxfree> @fact-set spam Spacko sometimes does it
18:36:34 <lambdabot> Fact recorded.
18:53:59 <spacko> http://spacko.sky.prohosting.com/
18:55:09 <spacko> http://spacko.sky.prohosting.com/
18:56:05 <luqui> @fact-set spam spacko does it frequently
18:56:05 <lambdabot> Fact already exists, not updating
18:56:11 <luqui> @fact-update spam spacko does it frequently
18:56:11 <lambdabot> Fact recorded.
18:56:28 <spacko> hahahahaha
18:56:34 <spacko> cool
18:56:44 <spacko> @fact-set faggot luqui
18:56:44 <lambdabot> Fact recorded.
18:56:51 <luqui> how fun
18:57:31 <spacko> http://spacko.sky.prohosting.com/
19:03:50 <spacko> http://spacko.sky.prohosting.com/
19:05:35 <bojohan> can someone kick this jerk?
19:17:14 <Korollary> just 140 ? What happened ? Finals are over ?
19:37:06 <Techniks> hey all
19:37:06 <Techniks> can anyone explain the data function to me
19:37:06 <Techniks> ie
19:39:18 <luqui> you mean data declarations?
19:39:18 <luqui> data Maybe a = Just a | Nothing
19:39:18 <luqui> that kind of thing?
19:40:24 <Techniks> exactly
19:41:25 <Techniks> ?
19:41:28 <luqui> Let's say you have "data Foo = Foo Int | Bar String"
19:41:28 <luqui> You've just defined a new data type called "Foo"
19:41:28 <luqui> Examples of things that are Foos are: Foo 13, Bar "hello", Foo 25
19:41:29 <luqui> But not Bar 25
19:41:30 <luqui> Oh, I should back up a bit
19:41:31 <luqui> Functions that start with capital letters (not to be confused with types, which also start with capital letters) are called "constructors"
19:41:31 <luqui> In that example, both Foo and Bar are constructors.
19:41:36 <Techniks> aha
19:41:37 <luqui> And the thing that makes them special is that you can pattern match against them:
19:41:37 <Techniks> okei
19:41:38 <Techniks> for example ?
19:41:39 <luqui> getFoo (Foo x) = x
19:41:42 <luqui> getFoo (Bar x) = error "Can't get the Foo out of a Bar"
19:41:43 <Techniks> confusing stuff hehe
19:41:46 <luqui> I suggest you try to make a few data types and do some pattern matching
19:41:46 <luqui> just play with them a little
19:41:47 <Techniks> Whats a standard data type in the prelude
19:41:50 <luqui> Maybe
19:41:50 <Techniks> that u could use as an example
19:41:50 <Techniks> ?
19:41:50 <luqui> data Maybe a = Just a | Nothing
19:41:50 <Techniks> and how does that work
19:41:51 <luqui> That is, a Maybe Int either has, say "Just 25" or it has "Nothing"
19:41:51 <Techniks> what would be a good use for that?
19:41:51 <luqui> it's one of the common ways to return failure
19:42:02 <luqui> @type find
19:42:02 <luqui> lambdabot?
19:42:02 <luqui> anyway: find :: (a -> Bool) -> [a] -> Maybe a
19:42:02 <luqui> that takes a condition and a list, and finds the first element that satisfies the condition
19:42:02 <lambdabot> Not in scope: `find'
19:42:04 <luqui> @eval find (\x -> x `mod` 2 == 0) [1,3,5,3,7,6,2]
19:42:04 <lambdabot> Just 6
19:42:04 <luqui> (Find the first one that is even)
19:42:04 <luqui> But if it can't find it:
19:42:04 <luqui> @eval find (\x -> x `mod` 2 == 0) [1,3,5,3,7,1,9]
19:42:04 <lambdabot> Nothing
19:42:05 <luqui> It returns Nothing as failure
19:42:06 <luqui> Then you use the
19:42:06 <luqui> @type maybe
19:42:06 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:42:07 <luqui> function to do switches on that
19:42:07 <Techniks> @type Int
19:42:07 <lambdabot> Not in scope: data constructor `Int'
19:42:07 <luqui> Ahh, Int is a type, so to ask for the type of it doesn't make sense
19:42:07 <luqui> @type 42
19:42:07 <lambdabot> forall t. (Num t) => t
19:42:07 <luqui> er
19:42:07 <luqui> @type "hello, world"
19:42:07 <lambdabot> [Char]
19:42:08 <Pseudonym> @arr
19:42:08 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
19:44:28 <Techniks> @type 'h' : 'e' : 'y' : []
19:44:30 <Techniks> ?
19:45:05 <luqui> Read: http://www.haskell.org/tutorial/goodies.html
19:45:06 <lambdabot> [Char]
19:45:06 <luqui> Section 2.2: User defined Types
19:45:06 <Techniks> @type 'h' : 'e' : 'y' : []
19:45:09 <luqui> lambdabot seems a bit laggy
19:45:09 <Techniks> fully does
19:45:09 <lambdabot> [Char]
19:45:09 <Techniks> yeah
19:45:09 <luqui> @eval 'h' : 'e' : 'y' : []
19:45:09 <lambdabot> "hey"
19:47:14 <luqui> @eval let myFunc (Nothing) = "I didn't get nuffin"; myFunc (Just x) = "I got " ++ show x   in myFunc (Just 25)
19:47:14 <lambdabot> "I got 25"
19:47:14 <luqui> @eval let myFunc (Nothing) = "I didn't get nuffin"; myFunc (Just x) = "I got " ++ show x   in myFunc (Nothing)
19:47:14 <lambdabot> Add a type signature
19:47:14 <luqui> screw you lambdabot :-)
19:47:14 <luqui> @eval let myFunc (Nothing) = "I didn't get nuffin"; myFunc (Just x) = "I got " ++ show x   in myFunc (Nothing :: Maybe Int)
19:47:14 <lambdabot> "I didn't get nuffin"
19:47:14 <cge> @eval map (uncurry (+)) [(1,2),(3,4)]
19:47:14 <lambdabot> [3,7]
19:47:14 <araujo> What is a reasonable size (number of lines) for a haskell module?
19:47:15 <Pseudonym> That depends what's in it.
19:47:24 <luqui> uh, a conceptually unified number of lines
19:47:42 <araujo> I just want to know if there is some limit of what it is considered a good written module.
19:47:49 <luqui> anywhere from 20 to 500 probably.  500 is getting up there.
19:47:51 <Pseudonym> Yes.  Too much is considered too much.
19:47:52 <luqui> but it's really not about lines
19:48:14 <Pseudonym> "Too much" is precisely that amount which is in excess.
19:48:28 <Korollary> "Too much" is universally agreed upon.
19:48:32 <luqui> :-)
19:48:57 <Korollary> I am not sure if there's such a thing as "too much haskell code", though ;)
19:49:07 * luqui is
19:49:15 <luqui> Pugs is too much haskell code :-)
19:49:25 <Korollary> What's with Pugs ?
19:49:44 <de1337> Anyone know of any example/how to implement an eval(haskell expression parser) in C/C++?
19:49:46 <luqui> (but it's cool because it works.  I just think it could have been a lot smaller and do the same thing)
19:50:10 <luqui> but that's the nature of a "hackathon project"
19:50:32 <luqui> de1337, link to haskell?
19:50:42 <luqui> You want to make something that parses haskell in C++?
19:50:55 <luqui> Do you want to evaluate the expression too?
19:52:11 <JohnMeacham> shapr: well, moreso than fast the mechanism will be open to all the optimizations I write for grin since it will be expressed in it.
19:52:39 <de1337> luqui: well, ive hardly used haskell but what i want to do, is you input a string a the c++ program, then it gets evaluated (eval) as haskell and returns a string as answer
19:53:21 <luqui> do you mind linking to ghc?  or do you want to do it yourself?
19:53:30 <Korollary> de1337: that means you want a haskell interpreter accessible from c++
19:53:38 <JohnMeacham> shapr: there would be some code bloat, since we would move the machinery from the runtime system to the eval points, but grin is based pretty much on the concept on specializing evals so it makes sense.
19:53:41 <de1337> Korollary: yeah
19:54:01 <de1337> luqui: ghc?
19:54:09 <Korollary> de1337: I think hugs is written in c or c++. Check that out.
19:54:14 <luqui> @fact ghc
19:54:19 <JohnMeacham> shapr: the odd thing will be aborting of long running stuff. It will require some thought and experimentation to decide how to best handle that.
19:54:20 <lambdabot> ghc: Haskell implementation
19:54:22 <luqui> ahh, yes, hugs
19:54:30 * luqui has never used that
19:54:49 <Korollary> JohnMeacham: fyi, shapr quit.
19:55:25 <de1337> hmm is there none that runs under win?
19:55:33 <Korollary> de1337: hugs does run in windows
19:56:22 <de1337> ah there
19:57:38 <de1337> http://www.cse.unsw.edu.au/~dons/hs-plugins/ i found this also, seems to be only for *nix though
19:58:19 <Korollary> de1337: that's not what you want.
19:58:48 <luqui> de1337, do you mind telling us why you want to do this?
19:59:31 <de1337> luqui: just for fun, implemention for a c++ bot ive made
20:00:01 <luqui> mmk
20:00:16 <Techniks> data Color              = Red | Green | Blue | Indigo | Violet
20:00:19 <Techniks> ive made a data type right
20:00:27 <Techniks> :t Red
20:00:29 <Techniks> returns color
20:00:34 <Techniks> Color*
20:00:35 <de1337> Korollary: if you look at 7.2 foreign eval, it looks pretty neat though
20:00:37 <JohnMeacham> Korollary: I figure maybe he will read the logs. or someone else will be interested. who knows.
20:00:39 <luqui> righto
20:00:42 <Techniks> how do i add attributes
20:00:49 <de1337> that would have been just what i needed
20:00:52 <Techniks> to either
20:00:53 <Techniks> Color
20:00:56 <Techniks> or Red
20:00:56 <Techniks> hehe
20:00:57 <luqui> you mean how do say, like, "Red 16"
20:01:06 <luqui> or "Red "hello""
20:01:08 <luqui> or whatever?
20:02:07 <Techniks> whats the point of "Red Hello"
20:02:22 <luqui> well, just describe what you mean by "attributes"?
20:02:32 <Korollary> Techniks: What is an 'attribute' ?
20:04:07 <Korollary> Techniks: Check out the labelled fields section of the tutorial
20:04:32 * luqui always forgets about those :-)
20:05:09 <Techniks> im just curious how "Red 16" might have a useful purpose
20:05:17 <Techniks> im just confused about the concept and need to see a real example is all
20:05:36 * Korollary is baffled
20:06:01 <luqui> maybe colors weren't such a good example for this
20:06:50 <Korollary> http://www.haskell.org/tutorial/moretypes.html
20:06:52 <Korollary> section 6.2
20:06:54 <Korollary> with examples
20:07:03 <Techniks> got it now :)
20:13:03 <Techniks> if i make my own type
20:13:07 <Techniks> how do i print it to the screen
20:13:10 <Techniks> is it using Show ?
20:13:20 <Techniks> ie i made a function that changes Red to Green
20:13:31 <Techniks> change Red
20:13:34 <Techniks> should return Green
20:13:39 <Techniks> but how do i show this to the screen?
20:14:35 <luqui> data MyType = MyCons ...  deriving Show
20:14:45 <luqui> maybe that doesn't work in hugs...
20:14:53 <Techniks> sounds too hard
20:14:55 <Korollary> it is legal h98
20:14:58 <Techniks> yeah
20:15:08 <Techniks> im just in hugs running a script and at the prompt i typed
20:15:12 <Techniks> Show (change Red)
20:15:16 <Techniks> but i get error obviously hehe
20:15:29 <Korollary> Techniks: I think you need to revisit the tutorial
20:15:53 <Techniks> i read it but isnt clear
20:15:57 <Techniks> omk
20:16:41 <Korollary> http://www.haskell.org/tutorial/stdclasses.html
20:17:43 <luqui> is there any way at all to catch an "undefined" error?
20:17:49 <luqui> or an "error" error
20:19:39 <Korollary> luqui: like bottom ?
20:20:07 <luqui> yeah, the bottom value (assuming I understand it correctly)
20:24:35 <Korollary> luqui: I am not sure. maybe ghc has something
20:24:57 <tennin> is X^T x X^U isomorphic to X^(T+U) in all categories with those map objects, or only in certain kinds (e.g. cartesian closed)?
20:24:57 <tennin> * RichiH has quit IRC (Remote closed the connection)
20:25:11 <tennin>  the book i'm reading (Conceptual Mathematics by Lawvere and Schanuel (sp?) ) asks for a general proof, but I can't seem to do it and the book's own sketch of a proof, in the next chapter, seems to assume that X^Y exists for all Y
20:25:27 <tennin> but i could be missing something obvious
20:25:40 <luqui> nothing is obvious about what you just said ;-)
20:27:28 <tennin> obvious to category theory freaks, of which there must be at least a few in this channel... surely?  =)
20:27:44 <Korollary> tennin: there are a few
20:29:22 <Pseudonym> That proof makes sense, though.  It's true in those categories which have ALL map objects.
20:29:52 <tennin> Right, I can see that.
20:30:35 <Pseudonym> How does the proof use this fact?
20:33:17 <Techniks> (x:_) !! 0 = x
20:33:21 <Techniks> what does that do :p
20:33:27 <Techniks> more specifically the !! function
20:33:28 <Techniks> :p
20:33:36 <Pseudonym> @type (!!)
20:33:37 <lambdabot> forall a. [a] -> Int -> a
20:35:42 <Pseudonym> @eval [1,2,3] !! 0
20:35:43 <lambdabot> 1
20:35:45 <Pseudonym> @eval [1,2,3] !! 1
20:35:45 <lambdabot> 2
20:35:46 <Pseudonym> @eval [1,2,3] !! 2
20:35:47 <lambdabot> 3
20:35:49 <Pseudonym> Make sense?
20:36:20 <luqui> [1,2,3] is such a bad list for that kind of example
20:36:27 <Pseudonym> True.
20:36:29 <luqui> but I don't doubt that he got it anyway
20:36:37 <Pseudonym> ['Z','Y'..'A'] !! 0
20:36:54 <Pseudonym> @eval ['Z','Y'..'A'] !! 0
20:36:55 <lambdabot> 'Z'
20:36:57 <Pseudonym> @eval ['Z','Y'..'A'] !! 1
20:36:58 <lambdabot> 'Y'
20:37:01 <Pseudonym> Better example.
20:37:35 <luqui> @eval ['Y'..'A']
20:37:36 <lambdabot> ""
20:37:42 <tennin> basically, given maps Y->X^T and Y->X^U, we have maps YxT->X and YxU->X, therefore T->X^Y and U->X^Y, therefore T+U->X^Y, Y x (T+U) -> X, Y -> X^(T+U)
20:37:48 <luqui> oh, it's different from perl :-)
20:38:03 <luqui> @eval ['a','c'..'k']
20:38:04 <lambdabot> "acegik"
20:38:14 <Techniks> aha
20:38:17 <Techniks> does it mean exists in list?
20:38:22 <Pseudonym> No.
20:38:30 <luqui> it indexes into a list
20:38:32 <Pseudonym> @eval "HELLOWORLD" !! 0
20:38:33 <lambdabot> 'H'
20:38:35 <Pseudonym> @eval "HELLOWORLD" !! 1
20:38:36 <lambdabot> 'E'
20:38:38 <Pseudonym> @eval "HELLOWORLD" !! 2
20:38:39 <lambdabot> 'L'
20:38:43 <Techniks> @eval ['Z', 'Y'] !! 1
20:38:44 <lambdabot> 'Y'
20:38:45 <tennin> of course you start with the evaluation map or somesuch
20:38:48 <Techniks> @eval ['Z', 'Y'] !! 0
20:38:49 <lambdabot> 'Z'
20:38:51 <Pseudonym> Right.
20:38:51 <Techniks> @eval ['Z', 'Y'] !! 3
20:38:52 <lambdabot> Prelude.(!!): index too large
20:38:52 <Techniks> error
20:38:54 <Techniks> yeah
20:38:56 <Techniks> got it now
20:38:58 <Techniks> th
20:38:58 <Techniks> x
20:38:59 <Techniks> :)
20:39:09 <tennin> so, this form of proof only works if X^Y exists.
20:39:17 <tennin> the book only "sketches" the proof
20:39:18 <Techniks> so after the !! it returns the nth of the list
20:42:09 <Techniks> @type .
20:42:10 <lambdabot> parse error on input `.'
20:44:39 <luqui> operators need to have parentheses if you want to use them as regular functions
20:44:40 <luqui> @type (.)
20:44:41 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
21:00:19 <tennin> and clearly, you can also prove it if the category is distributive
21:10:51 <Pseudonym> "Rarely do we find men who willingly engage in hard, solid thinking. There is an almost universal quest for easy answers and half-baked solutions. Nothing pains some people more than having to think."
21:11:38 <tennin> =(
21:11:59 <Pseudonym> I didn't mean that about anyone here, of course.
21:12:01 <Pseudonym> :-)
21:17:04 <Korollary> Pseudonym: good quote
21:17:11 <Korollary> who said it ?
21:20:05 <Pseudonym> Martin Luther King, Jr
21:20:18 <Pseudonym> Which makes it even more profound, were that possible.
21:26:45 <Korollary> We have this ability to believe in solutions that we can't be sure of.
22:17:56 <juhp> dcoutts: does one (do I?) still want --disable-dependency-tracking when building gtk2hs?
22:38:01 * joelr is up bright and early
22:38:03 <joelr> howdy
22:41:51 <dons> ~[6~[6~[6~[6~
22:42:00 <joelr> :-)
22:42:02 <dons> oops.
22:51:41 <joelr> dons: have you done heavy-duty network servers in haskell?
22:54:57 <Korollary> heh, not many people idle in #scheme and #perl at the same time
22:55:34 <joelr> @localtime Korollary
22:55:35 <lambdabot> Local time for Korollary is Thu Nov 03 22:55:17
22:55:51 <joelr> must be the western coast of canada ;)
22:56:24 <fworp> @localtime fworp
22:56:25 <Korollary> no, it's the pacific standard time (Los Angeles)
22:56:26 <lambdabot> Local time for fworp is Fri Nov 04 00:56:05 2005
22:56:42 <fworp> oh he cheated
22:57:11 <Korollary> about 25% of #scheme is in #haskell
22:57:28 <Korollary> 1/3 of #ocaml is in #haskell
22:58:05 <joelr> i do i get my latitude and longitude for the map of haskell users?
22:58:30 <Korollary> joelr: google earth ? your city's entry wikipedia  ?
22:58:41 <joelr> aha
22:58:46 <joelr> let me try that
22:59:21 <joelr> never tried google earth
23:01:22 <joelr> where's that hawiki users link... hmm
23:03:00 <fworp> http://www.haskell.org/hawiki/HaskellUserLocations
23:05:51 <fworp> that?
23:09:22 <joelr> 28.90          16.420       "joelr"       # JoelReymont
23:09:32 <joelr> http://en.wikipedia.org/wiki/Tenerife
23:09:36 <joelr> did i get this right?
